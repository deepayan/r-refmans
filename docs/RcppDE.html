<!DOCTYPE html><html><head><title>Help for package RcppDE</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RcppDE}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#DEoptim'><p>Differential Evolution Optimization</p></a></li>
<li><a href='#DEoptim-methods'><p>DEoptim-methods</p></a></li>
<li><a href='#DEoptim.control'><p>Control various aspects of the DEoptim implementation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.1.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-12-18</td>
</tr>
<tr>
<td>Title:</td>
<td>Global Optimization by Differential Evolution in C++</td>
</tr>
<tr>
<td>Author:</td>
<td>Dirk Eddelbuettel extending DEoptim (by David Ardia, Katharine Mullen,
 Brian Peterson, Joshua Ulrich) which itself is based on DE-Engine (by Rainer Storn)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dirk Eddelbuettel &lt;edd@debian.org&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>An efficient C++ based implementation of the 'DEoptim'
 function which performs global optimization by differential evolution.
 Its creation was motivated by trying to see if the old approximation "easier,
 shorter, faster: pick any two" could in fact be extended to achieving all
 three goals while moving the code from plain old C to modern C++.  The
 initial version did in fact do so, but a good part of the gain was due to
 an implicit code review which eliminated a few inefficiencies which have
 since been eliminated in 'DEoptim'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>inline, DEoptim, lattice</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/eddelbuettel/rcppde">https://github.com/eddelbuettel/rcppde</a>,
<a href="https://dirk.eddelbuettel.com/code/rcpp.de.html">https://dirk.eddelbuettel.com/code/rcpp.de.html</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/eddelbuettel/rcppde/issues">https://github.com/eddelbuettel/rcppde/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-18 14:15:31 UTC; edd</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-12-20 10:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='DEoptim'>Differential Evolution Optimization</h2><span id='topic+DEoptim'></span>

<h3>Description</h3>

<p>Performs evolutionary global optimization via the Differential Evolution algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DEoptim(fn, lower, upper, control = DEoptim.control(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DEoptim_+3A_fn">fn</code></td>
<td>
<p>the function to be optimized (minimized). The function should have as its first 
argument the vector of real-valued parameters to optimize, and return a scalar real result. <code>NA</code> 
and <code>NaN</code> values are not allowed. Note that <code>fn</code> can also
be an external pointer object encapsulating a C/C++-level function pointer
to a compiled functions which may offer considerable speed improvements.</p>
</td></tr>
<tr><td><code id="DEoptim_+3A_lower">lower</code>, <code id="DEoptim_+3A_upper">upper</code></td>
<td>
<p>two vectors specifying scalar real lower and upper bounds on each parameter to be optimized, so that the i-th element 
of <code>lower</code> and <code>upper</code> applied to the i-th parameter. The implementation searches
between <code>lower</code> and <code>upper</code> for the global optimum (minimum) of <code>fn</code>.</p>
</td></tr>
<tr><td><code id="DEoptim_+3A_control">control</code></td>
<td>
<p>a list of control parameters; see <code><a href="#topic+DEoptim.control">DEoptim.control</a></code>.</p>
</td></tr>
<tr><td><code id="DEoptim_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>fn</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>DEoptim</code> performs optimization (minimization) of <code>fn</code>. 
</p>
<p>The <code>control</code> argument is a list; see the help file for
<code><a href="#topic+DEoptim.control">DEoptim.control</a></code> for details.
</p>
<p>The <span class="rlang"><b>R</b></span> implementation of Differential Evolution (DE), <span class="pkg">DEoptim</span>, was first published on the Comprehensive <span class="rlang"><b>R</b></span> Archive
Network (CRAN) in 2005 by David Ardia. Early versions were written in 
pure <span class="rlang"><b>R</b></span>. Since version 2.0-0 (published to CRAN in 2009) the package has relied on an
interface to a C implementation of DE, which is significantly 
faster on most problems as compared to the implementation in 
pure <span class="rlang"><b>R</b></span>. The C interface is in many respects similar to the MS
Visual C++ v5.0 implementation of the Differential Evolution algorithm
distributed with the book <em>Differential Evolution &ndash; A Practical
Approach to Global Optimization</em> by Price, K.V., Storn, R.M., Lampinen
J.A, Springer-Verlag, 2006. Since version 2.0-3 the C 
implementation dynamically allocates the memory required to store the population, removing limitations on the 
number of members in the population and length of the parameter vectors that may be optimized. 
Since becoming publicly available, the package <span class="pkg">DEoptim</span> has been used by several authors to solve optimization 
problems arising in diverse domains; see Mullen et al. (2009) for a review.
</p>
<p>To perform a maximization (instead of minimization) of a given
function, simply define a new function which is the opposite of the
function to maximize and apply <code>DEoptim</code> to it.
</p>
<p>To integrate additional constraints (than box constraints) on the parameters <code>x</code> of
<code>fn(x)</code>, for instance <code>x[1] + x[2]^2 &lt; 2</code>, integrate the
constraint within the function to optimize, for instance: 
</p>
<pre>
    fn &lt;- function(x){
      if (x[1] + x[2]^2 &lt; 2){
        r &lt;- Inf
      else{
        ...
      }
      return(r)
    }
  </pre>
<p>This simplistic strategy usually does not work all that well for gradient-based or Newton-type 
methods. It is likely to be alright when the solution is in the interior of the feasible region, but when 
the solution is on the boundary, optimization algorithm would have a difficult time converging. Furthermore, when
the solution is on the boundary, this strategy would make the algorithm converge to an inferior solution in the interior. 
However, for methods such as DE which are not gradient based, this strategy might not be that bad.
</p>
<p>Note that <code>DEoptim</code> stops if any <code>NA</code> or <code>NaN</code> value is
obtained. You have to redefine your function to handle these values
(for instance, set <code>NA</code> to <code>Inf</code> in your objective function).
</p>
<p>It is important to emphasize that the result of <code>DEoptim</code> is a random variable, 
i.e., different results will obtain when the algorithm is run repeatedly with the same 
settings. Hence, the user should set the random seed if they want to reproduce the results, e.g., by 
setting <code>set.seed(1234)</code> before the call of <code>DEoptim</code>.
</p>
<p><code>DEoptim</code> relies on repeated evaluation of the objective function
in order to move the population toward a global minimum. Users
interested in making <code>DEoptim</code> run as fast as possible should
ensure that evaluation of the objective function is as efficient as
possible. Using pure <span class="rlang"><b>R</b></span> code, this may often be accomplished
using vectorization. Writing parts of the objective function in a
lower-level language like C or Fortran may also increase speed.
</p>
<p>Further details and examples of the <span class="rlang"><b>R</b></span> package <span class="pkg">DEoptim</span> can be found
in Mullen et al. (2009) and Ardia et al. (2010).
</p>
<p>Please cite the package in publications. 
</p>


<h3>Value</h3>

<p>The output of the function <code>DEoptim</code> is a member of the <code>S3</code> class <code>DEoptim</code>. More precisely,
this is a list (of length 2) containing the following elements:<br />
</p>
<p><code>optim</code>, a list containing the following elements:
</p>

<ul>
<li> <p><code>bestmem</code>: the best set of parameters found.
</p>
</li>
<li> <p><code>bestval</code>: the value of <code>fn</code> corresponding to <code>bestmem</code>.
</p>
</li>
<li> <p><code>nfeval</code>: number of function evaluations.
</p>
</li>
<li> <p><code>iter</code>: number of procedure iterations.
</p>
</li></ul>

<p><code>member</code>, a list containing the following elements:
</p>

<ul>
<li> <p><code>lower</code>: the lower boundary.
</p>
</li>
<li> <p><code>upper</code>: the upper boundary.
</p>
</li>
<li> <p><code>bestvalit</code>: the best value of <code>fn</code> at each iteration.
</p>
</li>
<li> <p><code>bestmemit</code>: the best member at each iteration.
</p>
</li>
<li> <p><code>pop</code>: the population generated at the last iteration.
</p>
</li>
<li> <p><code>storepop</code>: a list containing the intermediate populations.
</p>
</li></ul>

<p>Members of the class <code>DEoptim</code> have a <code>plot</code> method that
accepts the argument <code>plot.type</code>. <code>plot.type = "bestmemit"</code> results
in a plot of the parameter values that represent the lowest value of the objective function
each generation. <code>plot.type = "bestvalit"</code> plots the best value of
the objective function each generation. Finally, <code>plot.type = "storepop"</code> results in a plot of
stored populations (which are only available if these have been saved by
setting the <code>control</code> argument of <code>DEoptim</code> appropriately). Storing intermediate populations 
allows us to examine the progress of the optimization in detail.   
A summary method also exists and returns the best parameter vector, the best value of the objective function,
the number of generations optimization ran, and the number of times the 
objective function was evaluated. 
</p>


<h3>Note</h3>

<p><em>Differential Evolution</em> (DE) is a search heuristic introduced by Storn and Price (1997). 
Its remarkable performance as a global optimization algorithm on continuous numerical minimization 
problems has been extensively explored; see Price et al. (2006). DE belongs to the class of genetic 
algorithms which use biology-inspired operations of 
crossover, mutation, and selection on a population in order to minimize an objective 
function over the course of successive generations (see Mitchell, 1998). As with other evolutionary algorithms, 
DE solves optimization problems by evolving a population of candidate solutions using alteration and selection
operators. DE uses floating-point instead of bit-string encoding of population members, and 
arithmetic operations instead of logical operations in mutation. DE is particularly well-suited to find the global optimum of a 
real-valued function of real-valued parameters, and does not require that the function be
either continuous or differentiable.
</p>
<p>Let <code class="reqn">\mathit{NP}</code> denote the number of parameter vectors (members) <code class="reqn">x \in R^d</code> in the population. 
In order to create the initial generation, <code class="reqn">\mathit{NP}</code> guesses for the optimal value
of the parameter vector are made, either using random values between lower and upper 
bounds (defined by the user) or using values given by
the user. Each generation involves creation of a new population from
the current population members <code class="reqn">\{ x_i \,|\, i = 1, \ldots, \mathit{NP}\}</code>, 
where <code class="reqn">i</code> indexes the vectors that make up the population.
This is accomplished using <em>differential mutation</em> of the
population members. An initial mutant parameter vector <code class="reqn">v_i</code> is
created by choosing three members of the population, <code class="reqn">x_{r_0}</code>,
<code class="reqn">x_{r_1}</code> and <code class="reqn">x_{r_2}</code>, at random. Then <code class="reqn">v_i</code> is
generated as
</p>
<p style="text-align: center;"><code class="reqn">v_i \doteq x_{r_0} + \mathit{F} \cdot (x_{r_1} - x_{r_2})</code>
</p>
  
<p>where <code class="reqn">\mathit{F}</code> is a positive scale factor, effective values for which are
typically less than one. After the first mutation operation, mutation is
continued until <code class="reqn">d</code> mutations have been made, with a crossover probability 
<code class="reqn">\mathit{CR} \in [0,1]</code>.
The crossover probability <code class="reqn">\mathit{CR}</code> controls the fraction of the parameter
values that are copied from the mutant. If an element of the trial parameter vector is found to violate the
bounds after mutation and crossover, it is reset in such a way that the bounds are respected (with the
specific protocol depending on the implementation).
Then, the objective function values associated with the children are determined. If a trial
vector has equal or lower objective function value than the previous
vector it replaces the previous vector in the population;
otherwise the previous vector remains. Variations of this scheme have also
been proposed; see Price et al. (2006) and <code><a href="#topic+DEoptim.control">DEoptim.control</a></code>.
</p>
<p>Intuitively, the effect of the scheme is that the shape of the distribution of the population in the
search space is converging with respect to size and direction towards areas with high
fitness. The closer the population gets to the global optimum, the more the distribution
will shrink and therefore reinforce the generation of smaller difference vectors.  
</p>
<p>As a general advice regarding the choice of <code class="reqn">\mathit{NP}</code>, <code class="reqn">\mathit{F}</code> and <code class="reqn">\mathit{CR}</code>, 
Storn et al. (2006) state the following: Set the number
of parents <code class="reqn">\mathit{NP}</code> to 10 times the number of parameters, select weighting factor 
<code class="reqn">\mathit{F} = 0.8</code> and crossover constant <code class="reqn">\mathit{CR} = 0.9</code>. Make sure that you initialize your parameter vectors
by exploiting their full numerical range, i.e., if a parameter is allowed to exhibit
values in the range [-100, 100] it is a good idea to pick the initial values from this
range instead of unnecessarily restricting diversity. If you experience misconvergence in 
the optimization process you usually have to increase the value for <code class="reqn">\mathit{NP}</code>, but often you only have to adjust
<code class="reqn">\mathit{F}</code> to be a little lower or higher than 0.8. If you increase
<code class="reqn">\mathit{NP}</code> and simultaneously lower <code class="reqn">\mathit{F}</code> a little, convergence is more
likely to occur but generally takes longer, i.e., DE is getting
more robust (there is always a convergence speed/robustness trade-off).
</p>
<p>DE is much more sensitive to the choice of <code class="reqn">\mathit{F}</code> than it is to
the choice of <code class="reqn">\mathit{CR}</code>. <code class="reqn">\mathit{CR}</code> is more like a fine tuning element. High
values of <code class="reqn">\mathit{CR}</code> like <code class="reqn">\mathit{CR} = 1</code> give faster convergence if convergence
occurs. Sometimes, however, you have to go down as much as <code class="reqn">\mathit{CR} = 0</code> to
make DE robust enough for a particular problem. For more details on the DE strategy, we refer 
the reader to Storn and Price (1997) and Price et al. (2006).
</p>


<h3>Author(s)</h3>

<p>For <span class="pkg">RcppDE</span>: Dirk Eddelbuettel.
</p>
<p>For <span class="pkg">DEoptim</span>: 
David Ardia, Katharine Mullen <a href="mailto:katharine.mullen@nist.gov">katharine.mullen@nist.gov</a>, 
Brian Peterson and Joshua Ulrich.
</p>


<h3>References</h3>

<p>Storn, R. and Price, K. (1997) 
Differential Evolution &ndash; A Simple and Efficient Heuristic for Global Optimization over Continuous Spaces,
<em>Journal of Global Optimization</em>, 11:4, 341&ndash;359.  
</p>
<p>Price, K.V., Storn, R.M., Lampinen J.A. (2006)
<em>Differential Evolution - A Practical Approach to Global Optimization</em>.
Berlin Heidelberg: Springer-Verlag. ISBN 3540209506.
</p>
<p>Mitchell, M. (1998) 
<em>An Introduction to Genetic Algorithms</em>.
The MIT Press. ISBN 0262631857.
</p>
<p>Mullen, K.M., Ardia, D., Gil, D.L, Windover, D., Cline, J. (2009)
<span class="pkg">DEoptim</span>: An <span class="rlang"><b>R</b></span> Package for Global Optimization by Differential Evolution.
URL <a href="https://www.ssrn.com/abstract=1526466">https://www.ssrn.com/abstract=1526466</a>
</p>
<p>Ardia, D., Boudt, K., Carl, P., Mullen, K.M., Peterson, B.G. (2010)
Differential Evolution (<span class="pkg">DEoptim</span>) for Non-Convex Portfolio Optimization.
URL <a href="https://www.ssrn.com/abstract=1584905">https://www.ssrn.com/abstract=1584905</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DEoptim.control">DEoptim.control</a></code> for control arguments,
<code><a href="#topic+DEoptim-methods">DEoptim-methods</a></code> for methods on <code>DEoptim</code> objects,
including some examples in plotting the results;
<code><a href="stats.html#topic+optim">optim</a></code> or <code><a href="stats.html#topic+constrOptim">constrOptim</a></code>
for alternative optimization algorithms.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Rosenbrock Banana function
  ## The function has a global minimum f(x) = 0 at the point (0,0).  
  ## Note that the vector of parameters to be optimized must be the first 
  ## argument of the objective function passed to DEoptim.
  Rosenbrock &lt;- function(x){
    x1 &lt;- x[1]
    x2 &lt;- x[2]
    100 * (x2 - x1 * x1)^2 + (1 - x1)^2
  }

  ## DEoptim searches for minima of the objective function between
  ## lower and upper bounds on each parameter to be optimized. Therefore
  ## in the call to DEoptim we specify vectors that comprise the
  ## lower and upper bounds; these vectors are the same length as the
  ## parameter vector.
  lower &lt;- c(-10,-10)
  upper &lt;- -lower
 
  ## run DEoptim and set a seed first for replicability
  set.seed(1234)
  DEoptim(Rosenbrock, lower, upper)

  ## increase the population size
  DEoptim(Rosenbrock, lower, upper, DEoptim.control(NP = 100))

  ## change other settings and store the output
  outDEoptim &lt;- DEoptim(Rosenbrock, lower, upper, DEoptim.control(NP = 80,
                        itermax = 400, F = 1.2, CR = 0.7))
  
  ## plot the output
  plot(outDEoptim)

  ## 'Wild' function, global minimum at about -15.81515
  Wild &lt;- function(x)
    10 * sin(0.3 * x) * sin(1.3 * x^2) +
       0.00001 * x^4 + 0.2 * x + 80

  plot(Wild, -50, 50, n = 1000, main = "'Wild function'")

  outDEoptim &lt;- DEoptim(Wild, lower = -50, upper = 50,
                        control = DEoptim.control(trace = FALSE))
  
  plot(outDEoptim)

  DEoptim(Wild, lower = -50, upper = 50,
          control = DEoptim.control(NP = 50))
</code></pre>

<hr>
<h2 id='DEoptim-methods'>DEoptim-methods</h2><span id='topic+DEoptim-methods'></span><span id='topic+plot.DEoptim'></span><span id='topic+summary.DEoptim'></span>

<h3>Description</h3>

<p>Methods for DEoptim objects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DEoptim'
summary(object, ...)
## S3 method for class 'DEoptim'
plot(x, plot.type = c("bestmemit", "bestvalit", "storepop"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DEoptim-methods_+3A_object">object</code></td>
<td>
<p>an object of class <code>DEoptim</code>; usually, a result
of a call to <code><a href="#topic+DEoptim">DEoptim</a></code>.</p>
</td></tr>
<tr><td><code id="DEoptim-methods_+3A_x">x</code></td>
<td>
<p>an object of class <code>DEoptim</code>; usually, a result
of a call to <code><a href="#topic+DEoptim">DEoptim</a></code>.</p>
</td></tr>
<tr><td><code id="DEoptim-methods_+3A_plot.type">plot.type</code></td>
<td>
<p>should we plot the best member at each iteration, the best value
at each iteration or the intermediate populations?</p>
</td></tr>
<tr><td><code id="DEoptim-methods_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Members of the class <code>DEoptim</code> have a <code>plot</code> method that
accepts the argument <code>plot.type</code>. <code>plot.type = "bestmemit"</code> results
in a plot of the parameter values that represent the lowest value of the objective function
each generation. <code>plot.type = "bestvalit"</code> plots the best value of
the objective function each generation. Finally, <code>plot.type = "storepop"</code> results in a plot of
stored populations (which are only available if these have been saved by
setting the <code>control</code> argument of <code>DEoptim</code> appropriately). Storing intermediate populations 
allows us to examine the progress of the optimization in detail.   
A summary method also exists and returns the best parameter vector, the best value of the objective function,
the number of generations optimization ran, and the number of times the 
objective function was evaluated. 
</p>


<h3>Note</h3>

<p>Further details and examples of the <span class="rlang"><b>R</b></span> package <span class="pkg">DEoptim</span> can be found
in Mullen et al. (2009) and Ardia et al. (2010).
</p>
<p>Please cite the package in publications. 
</p>


<h3>Author(s)</h3>

<p>For <span class="pkg">RcppDE</span>: Dirk Eddelbuettel.
</p>
<p>For <span class="pkg">DEoptim</span>: 
David Ardia, Katharine Mullen <a href="mailto:katharine.mullen@nist.gov">katharine.mullen@nist.gov</a>, 
Brian Peterson and Joshua Ulrich.
</p>


<h3>References</h3>

<p>Mullen, K.M., Ardia, D., Gil, D.L, Windover, D., Cline, J. (2009)
<span class="pkg">DEoptim</span>: An <span class="rlang"><b>R</b></span> Package for Global Optimization by Differential Evolution.
URL <a href="https://www.ssrn.com/abstract=1526466">https://www.ssrn.com/abstract=1526466</a>
</p>
<p>Ardia, D., Boudt, K., Carl, P., Mullen, K.M., Peterson, B.G. (2010)
Differential Evolution (<span class="pkg">DEoptim</span>) for Non-Convex Portfolio Optimization.
URL <a href="https://www.ssrn.com/abstract=1584905">https://www.ssrn.com/abstract=1584905</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DEoptim">DEoptim</a></code> and <code><a href="#topic+DEoptim.control">DEoptim.control</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Rosenbrock Banana function
  ## The function has a global minimum f(x) = 0 at the point (0,0).  
  ## Note that the vector of parameters to be optimized must be the first 
  ## argument of the objective function passed to DEoptim.
  Rosenbrock &lt;- function(x){
    x1 &lt;- x[1]
    x2 &lt;- x[2]
    100 * (x2 - x1 * x1)^2 + (1 - x1)^2
  }

  lower &lt;- c(-10, -10)
  upper &lt;- -lower
  
  set.seed(1234)
  outDEoptim &lt;- DEoptim(Rosenbrock, lower, upper)
  
  ## print output information
  summary(outDEoptim)

  ## plot the best members
  plot(outDEoptim, type = 'b')

  ## plot the best values
  dev.new()
  plot(outDEoptim, plot.type = "bestvalit", type = 'b', col = 'blue')

  ## rerun the optimization, and store intermediate populations
  outDEoptim &lt;- DEoptim(Rosenbrock, lower, upper,
                        DEoptim.control(itermax = 500,
                        storepopfrom = 1, storepopfreq = 2))
  summary(outDEoptim)
  
  ## plot intermediate populations
  dev.new()
  plot(outDEoptim, plot.type = "storepop")

  ## Wild function
  Wild &lt;- function(x)
    10 * sin(0.3 * x) * sin(1.3 * x^2) +
       0.00001 * x^4 + 0.2 * x + 80

  outDEoptim = DEoptim(Wild, lower = -50, upper = 50,
                       DEoptim.control(trace = FALSE, storepopfrom = 50,
                       storepopfreq = 1))
  
  plot(outDEoptim, type = 'b')

  dev.new()
  plot(outDEoptim, plot.type = "bestvalit", type = 'b')

## Not run: 
  ## an example with a normal mixture model: requires package mvtnorm
  library(mvtnorm)

  ## neg value of the density function
  negPdfMix &lt;- function(x) {
     tmp &lt;- 0.5 * dmvnorm(x, c(-3, -3)) + 0.5 * dmvnorm(x, c(3, 3))
     -tmp
  }

  ## wrapper plotting function
  plotNegPdfMix &lt;- function(x1, x2)
     negPdfMix(cbind(x1, x2))

  ## contour plot of the mixture
  x1 &lt;- x2 &lt;- seq(from = -10.0, to = 10.0, by = 0.1)
  thexlim &lt;- theylim &lt;- range(x1)
  z &lt;- outer(x1, x2, FUN = plotNegPdfMix)
  
  contour(x1, x2, z, nlevel = 20, las = 1, col = rainbow(20),
     xlim = thexlim, ylim = theylim)

  set.seed(1234)
  outDEoptim &lt;- DEoptim(negPdfMix, c(-10, -10), c(10, 10),
     DEoptim.control(NP = 100, itermax = 100, storepopfrom = 1,
     storepopfreq = 5))

  ## convergence plot
  dev.new()
  plot(outDEoptim)
  
  ## the intermediate populations indicate the bi-modality of the function
  dev.new()
  plot(outDEoptim, plot.type = "storepop")

## End(Not run)
</code></pre>

<hr>
<h2 id='DEoptim.control'>Control various aspects of the DEoptim implementation</h2><span id='topic+DEoptim.control'></span>

<h3>Description</h3>

<p>Allow the user to set some characteristics of the 
Differential Evolution optimization algorithm implemented
in <code>DEoptim</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DEoptim.control(VTR = -Inf, strategy = 2, bs = FALSE, NP = 50,
   itermax = 200, CR = 0.5, F = 0.8, trace = TRUE,
   initialpop = NULL, storepopfrom = itermax + 1,
   storepopfreq = 1, p = 0.2, c = 0, reltol = sqrt(.Machine$double.eps),
   steptol = itermax)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DEoptim.control_+3A_vtr">VTR</code></td>
<td>
<p>the value to be reached. The optimization process
will stop if either the maximum number of iterations <code>itermax</code>
is reached or the best parameter vector <code>bestmem</code> has found a value
<code>fn(bestmem) &lt;= VTR</code>. Default to <code>-Inf</code>.</p>
</td></tr>
<tr><td><code id="DEoptim.control_+3A_strategy">strategy</code></td>
<td>
<p>defines the Differential Evolution
strategy used in the optimization procedure:<br />
<code>1</code>: DE / rand / 1 / bin (classical strategy)<br />
<code>2</code>: DE / local-to-best / 1 / bin (default)<br />
<code>3</code>: DE / best / 1 / bin with jitter<br />
<code>4</code>: DE / rand / 1 / bin with per-vector-dither<br />
<code>5</code>: DE / rand / 1 / bin with per-generation-dither<br />
<code>6</code>: DE / current-to-p-best / 1<br />
any value not above: variation to DE / rand / 1 / bin: either-or-algorithm.  Default
strategy is currently <code>2</code>. See *Details*.
</p>
</td></tr>
<tr><td><code id="DEoptim.control_+3A_bs">bs</code></td>
<td>
<p>if <code>FALSE</code> then every mutant will be tested against a
member in the previous generation, and the best value will proceed
into the next generation (this is standard trial vs. target
selection). If <code>TRUE</code> then the old generation and <code>NP</code>
mutants will be sorted by their associated objective function
values, and the best <code>NP</code> vectors will proceed into the next
generation (best of parent and child selection). Default is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="DEoptim.control_+3A_np">NP</code></td>
<td>
<p>number of population members. Defaults to <code>50</code>.  For
many problems it is best to set
<code>NP</code> to be at least 10 times the length
of the parameter vector.  </p>
</td></tr>
<tr><td><code id="DEoptim.control_+3A_itermax">itermax</code></td>
<td>
<p>the maximum iteration (population generation) allowed.
Default is <code>200</code>.</p>
</td></tr>
<tr><td><code id="DEoptim.control_+3A_cr">CR</code></td>
<td>
<p>crossover probability from interval [0,1]. Default
to <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="DEoptim.control_+3A_f">F</code></td>
<td>
<p>step-size from interval [0,2]. Default to <code>0.8</code>.</p>
</td></tr>
<tr><td><code id="DEoptim.control_+3A_trace">trace</code></td>
<td>
<p>Printing of progress occurs? Default to <code>TRUE</code>. If
numeric, progress will be printed every <code>trace</code> iterations.</p>
</td></tr>
<tr><td><code id="DEoptim.control_+3A_initialpop">initialpop</code></td>
<td>
<p>an initial population used as a starting
population in the optimization procedure. May be useful to speed up
the convergence. Default to <code>NULL</code>.  If given, each member of
the initial population should be given as a row of a numeric matrix, so that
<code>initialpop</code> is a matrix with <code>NP</code> rows and a number of
columns equal to the length of the parameter vector to be optimized. </p>
</td></tr>
<tr><td><code id="DEoptim.control_+3A_storepopfrom">storepopfrom</code></td>
<td>
<p>from which generation should the following
intermediate populations be stored in memory. Default to
<code>itermax + 1</code>, i.e., no intermediate population is stored.</p>
</td></tr>
<tr><td><code id="DEoptim.control_+3A_storepopfreq">storepopfreq</code></td>
<td>
<p>the frequency with which populations are stored.
Default to <code>1</code>, i.e., every intermediate population
is stored.</p>
</td></tr>
<tr><td><code id="DEoptim.control_+3A_p">p</code></td>
<td>
<p>when <code>strategy = 6</code>, the top (100 * p)% best 
solutions are used in the mutation. <code>p</code> must be defined in
(0,1].</p>
</td></tr>
<tr><td><code id="DEoptim.control_+3A_c">c</code></td>
<td>
<p>when <code>c &gt; 0</code>, crossover probability(CR) and step-size(F) are randomized 
at each mutation as an implementation of the JADE algorithm . <code>c</code> must be defined in
[0,1].</p>
</td></tr>
<tr><td><code id="DEoptim.control_+3A_reltol">reltol</code></td>
<td>
<p>relative convergence tolerance.  The algorithm stops if
it is unable to reduce the value by a factor of <code>reltol * (abs(val) +
        reltol)</code> after <code>steptol</code> steps. Defaults to
<code>sqrt(.Machine$double.eps)</code>, typically about <code>1e-8</code>.</p>
</td></tr>
<tr><td><code id="DEoptim.control_+3A_steptol">steptol</code></td>
<td>
<p>see <code>reltol</code>. Defaults to <code>itermax</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This defines the Differential Evolution 
strategy used in the optimization procedure, described below in the 
terms used by Price et al. (2006); see also Mullen et al. (2009) for details. 
</p>

<ul>
<li> <p><code>strategy = 1</code>: DE / rand / 1 / bin. <br /> 
This strategy is the classical approach for DE, and is described in <code><a href="#topic+DEoptim">DEoptim</a></code>. 
</p>
</li>
<li> <p><code>strategy = 2</code>: DE / local-to-best / 1 / bin. <br />
In place of the classical DE mutation the expression
</p>
<p style="text-align: center;"><code class="reqn">
      v_{i,g} = old_{i,g} + (best_{g} - old_{i,g}) + x_{r0,g} + F \cdot (x_{r1,g} - x_{r2,g})
    </code>
</p>
 
<p>is used, where <code class="reqn">old_{i,g}</code> and <code class="reqn">best_{g}</code> are the 
<code class="reqn">i</code>-th member and best member, respectively, of the previous population.
This strategy is currently used by default.  
</p>
</li>
<li> <p><code>strategy = 3</code>: DE / best / 1 / bin with jitter.<br />
In place of the classical DE mutation the expression
</p>
<p style="text-align: center;"><code class="reqn">
       v_{i,g} = best_{g} + jitter + F \cdot (x_{r1,g} - x_{r2,g}) 
     </code>
</p>

<p>is used, where <code class="reqn">jitter</code> is defined as 0.0001 * <code>rand</code> + F.
</p>
</li>
<li> <p><code>strategy = 4</code>: DE / rand / 1 / bin with per vector dither.<br />
In place of the classical DE mutation the expression
</p>
<p style="text-align: center;"><code class="reqn">
       v_{i,g} = x_{r0,g} + dither \cdot (x_{r1,g} - x_{r2,g})
     </code>
</p>

<p>is used, where <code class="reqn">dither</code> is calculated as <code class="reqn">F + \code{rand} * (1 - F)</code>.
</p>
</li>
<li> <p><code>strategy = 5</code>: DE / rand / 1 / bin with per generation dither.<br />
The strategy described for <code>4</code> is used, but <code class="reqn">dither</code>
is only determined once per-generation. 
</p>
</li>
<li><p> any value not above: variation to DE / rand / 1 / bin: either-or algorithm.<br />
In the case that <code>rand</code> &lt; 0.5, the classical strategy <code>strategy = 1</code> is used. 
Otherwise, the expression
</p>
<p style="text-align: center;"><code class="reqn">
       v_{i,g} = x_{r0,g} + 0.5 \cdot (F + 1) \cdot (x_{r1,g} + x_{r2,g} -  2 \cdot x_{r0,g})
     </code>
</p>

<p>is used. 
</p>
</li></ul>



<h3>Value</h3>

<p>The default value of <code>control</code> is the return value of 
<code>DEoptim.control()</code>, which is  a list (and a member of the <code>S3</code> class  
<code>DEoptim.control</code>) with the above elements.
</p>


<h3>Note</h3>

<p>Further details and examples of the <span class="rlang"><b>R</b></span> package <span class="pkg">DEoptim</span> can be found
in Mullen et al. (2009) and Ardia et al. (2010).
</p>
<p>Please cite the package in publications. 
</p>


<h3>Author(s)</h3>

<p>For <span class="pkg">RcppDE</span>: Dirk Eddelbuettel.
</p>
<p>For <span class="pkg">DEoptim</span>: 
David Ardia, Katharine Mullen <a href="mailto:katharine.mullen@nist.gov">katharine.mullen@nist.gov</a>, 
Brian Peterson and Joshua Ulrich.
</p>


<h3>References</h3>

<p>Price, K.V., Storn, R.M., Lampinen J.A. (2006)
<em>Differential Evolution - A Practical Approach to Global Optimization</em>.
Berlin Heidelberg: Springer-Verlag. ISBN 3540209506.
</p>
<p>Mullen, K.M., Ardia, D., Gil, D.L, Windover, D., Cline, J. (2009)
<span class="pkg">DEoptim</span>: An <span class="rlang"><b>R</b></span> Package for Global Optimization by Differential Evolution.
URL <a href="https://www.ssrn.com/abstract=1526466">https://www.ssrn.com/abstract=1526466</a>
</p>
<p>Ardia, D., Boudt, K., Carl, P., Mullen, K.M., Peterson, B.G. (2010)
Differential Evolution (<span class="pkg">DEoptim</span>) for Non-Convex Portfolio Optimization.
URL <a href="https://www.ssrn.com/abstract=1584905">https://www.ssrn.com/abstract=1584905</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DEoptim">DEoptim</a></code> and <code><a href="#topic+DEoptim-methods">DEoptim-methods</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set the population size to 20
DEoptim.control(NP = 20)

## set the population size, the number of iterations and don't
## display the iterations during optimization
DEoptim.control(NP = 20, itermax = 100, trace = FALSE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
