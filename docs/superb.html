<!DOCTYPE html><html><head><title>Help for package superb</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {superb}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#superb-package'><p>superb: Summary Plots with Adjusted Error Bars</p></a></li>
<li><a href='#biasCorrectionTransform'><p>bias-correction transform</p></a></li>
<li><a href='#bootstrapPrecisionMeasures'><p>Bootstrapped measures of precision</p></a></li>
<li><a href='#CousineauLaurencelleLambda'><p>Cousineau-Laurencelle's lambda correction for cluster-randomized sampling</p></a></li>
<li><a href='#dataFigure1'><p>Data for Figure 1</p></a></li>
<li><a href='#dataFigure2'><p>Data for Figure 2</p></a></li>
<li><a href='#dataFigure3'><p>Data for Figure 3</p></a></li>
<li><a href='#dataFigure4'><p>Data for Figure 4</p></a></li>
<li><a href='#geom_superberrorbar'><p>geom_superberrorbar for expanded error bar displays</p></a></li>
<li><a href='#GRD'><p>Generate random data</p></a></li>
<li><a href='#HyunhFeldtEpsilon'><p>Hyunh and Feldt's epsilon measure of sphericity</p></a></li>
<li><a href='#makeTransparent'><p>makes ggplots with transparent elements</p></a></li>
<li><a href='#MauchlySphericityTest'><p>Mauchly's test of Sphericity</p></a></li>
<li><a href='#measuresWithMissingData'><p>Measures with missing data</p></a></li>
<li><a href='#poolSDTransform'><p>pooled standard deviation transform</p></a></li>
<li><a href='#precisionMeasures'><p>Precision measures</p></a></li>
<li><a href='#precisionMeasureWithCustomDF'><p>Confidence intervals with custom degree of freedom</p></a></li>
<li><a href='#runDebug'><p>runDebug</p></a></li>
<li><a href='#showSignificance'><p>Annotate significance of results on plots</p></a></li>
<li><a href='#ShroutFleissICC1'><p>Shrout and Fleiss intra-class correlation functions</p></a></li>
<li><a href='#slope'><p>Effect description</p></a></li>
<li><a href='#subjectCenteringTransform'><p>subject-centering transform</p></a></li>
<li><a href='#summaryStatistics'><p>Additional summary statistics</p></a></li>
<li><a href='#superbData'><p>Obtain summary statistics with correct error bars.</p></a></li>
<li><a href='#superbPlot'><p>summary plot of any statistics with adjusted error bars.</p></a></li>
<li><a href='#superbPlot.bar'><p>superbPlot 'bar' layout</p></a></li>
<li><a href='#superbPlot.boxplot'><p>superbPlot 'boxplot' layout</p></a></li>
<li><a href='#superbPlot.halfwidthline'><p>superbPlot 'halfwidthline' layout</p></a></li>
<li><a href='#superbPlot.line'><p>superbPlot 'line' layout</p></a></li>
<li><a href='#superbPlot.lineBand'><p>superbPlot 'lineBand' layout</p></a></li>
<li><a href='#superbPlot.point'><p>superbPlot 'point' layout</p></a></li>
<li><a href='#superbPlot.pointindividualline'><p>superbPlot point and individual-line layout for within-subject design</p></a></li>
<li><a href='#superbPlot.pointjitter'><p>superbPlot point-and-jitter dots layout</p></a></li>
<li><a href='#superbPlot.pointjitterviolin'><p>superbPlot point, jitter and violin plot layout</p></a></li>
<li><a href='#superbPlot.raincloud'><p>superbPlot 'raincloud' layout</p></a></li>
<li><a href='#superbShiny'><p>User Interface to get summary plot of any statistics with adjusted error bars.</p></a></li>
<li><a href='#superbToWide'><p>superbToWide: Reshape long data frame to wide, suitable for superbPlot</p></a></li>
<li><a href='#TMB1964r'><p>Data of Tulving, Mandler, &amp; Baumal, 1964 (reproduction of 2021)</p></a></li>
<li><a href='#twoStepTransform'><p>two-step transform for subject centering and bias correction</p></a></li>
<li><a href='#WelchDegreeOfFreedom'><p>Welch's rectified degree of freedom</p></a></li>
<li><a href='#WinerCompoundSymmetryTest'><p>Winer's test of compound symmetry</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Summary Plots with Adjusted Error Bars</td>
</tr>
<tr>
<td>Version:</td>
<td>0.95.9</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-08</td>
</tr>
<tr>
<td>Author:</td>
<td>Denis Cousineau [aut, cre],
  Bradley Harding [ctb],
  Marc-Andre Goulet [ctb],
  Jesika Walker [art, pre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Denis Cousineau &lt;denis.cousineau@uottawa.ca&gt;</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/dcousin3/superb/issues/">https://github.com/dcousin3/superb/issues/</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://dcousin3.github.io/superb/">https://dcousin3.github.io/superb/</a></td>
</tr>
<tr>
<td>Description:</td>
<td>
    Computes standard error and confidence interval of various descriptive statistics under 
    various designs and sampling schemes. The main function, superbPlot(), return a plot. superbData() 
    returns a dataframe with the statistic and its precision interval so that other plotting package
    can be used. See Cousineau and colleagues (2021) &lt;<a href="https://doi.org/10.1177%2F25152459211035109">doi:10.1177/25152459211035109</a>&gt; 
    or Cousineau (2017) &lt;<a href="https://doi.org/10.5709%2Facp-0214-z">doi:10.5709/acp-0214-z</a>&gt; for a review as well as Cousineau (2005)
    &lt;<a href="https://doi.org/10.20982%2Ftqmp.01.1.p042">doi:10.20982/tqmp.01.1.p042</a>&gt;, Morey (2008) &lt;<a href="https://doi.org/10.20982%2Ftqmp.04.2.p061">doi:10.20982/tqmp.04.2.p061</a>&gt;, Baguley (2012)
    &lt;<a href="https://doi.org/10.3758%2Fs13428-011-0123-7">doi:10.3758/s13428-011-0123-7</a>&gt;, Cousineau &amp; Laurencelle (2016) &lt;<a href="https://doi.org/10.1037%2Fmet0000055">doi:10.1037/met0000055</a>&gt;,
    Cousineau &amp; O'Brien (2014) &lt;<a href="https://doi.org/10.3758%2Fs13428-013-0441-z">doi:10.3758/s13428-013-0441-z</a>&gt;, Calderini &amp; Harding 
    &lt;<a href="https://doi.org/10.20982%2Ftqmp.15.1.p001">doi:10.20982/tqmp.15.1.p001</a>&gt; for specific references.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>foreign, plyr (&ge; 1.8.4), ggplot2 (&ge; 3.1.0), MASS, lsr (&ge;
0.5), methods, Rdpack (&ge; 0.7), stats, shiny, shinyBS, stringr,
utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>dplyr, psych, emojifont, fMultivar, grid, gridExtra, knitr,
lattice, lawstat, boot, png, reshape2, rmarkdown, sadists,
scales, testthat, tibble</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-09 17:31:08 UTC; Denis Cousineau</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-09 18:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='superb-package'>superb: Summary Plots with Adjusted Error Bars</h2><span id='topic+superb'></span><span id='topic+superb-package'></span>

<h3>Description</h3>

<p>Computes standard error and confidence interval of various descriptive statistics under various designs and sampling schemes. The main function, superbPlot(), return a plot. superbData() returns a dataframe with the statistic and its precision interval so that other plotting package can be used. See Cousineau and colleagues (2021) <a href="https://doi.org/10.1177/25152459211035109">doi:10.1177/25152459211035109</a> or Cousineau (2017) <a href="https://doi.org/10.5709/acp-0214-z">doi:10.5709/acp-0214-z</a> for a review as well as Cousineau (2005) <a href="https://doi.org/10.20982/tqmp.01.1.p042">doi:10.20982/tqmp.01.1.p042</a>, Morey (2008) <a href="https://doi.org/10.20982/tqmp.04.2.p061">doi:10.20982/tqmp.04.2.p061</a>, Baguley (2012) <a href="https://doi.org/10.3758/s13428-011-0123-7">doi:10.3758/s13428-011-0123-7</a>, Cousineau &amp; Laurencelle (2016) <a href="https://doi.org/10.1037/met0000055">doi:10.1037/met0000055</a>, Cousineau &amp; O'Brien (2014) <a href="https://doi.org/10.3758/s13428-013-0441-z">doi:10.3758/s13428-013-0441-z</a>, Calderini &amp; Harding <a href="https://doi.org/10.20982/tqmp.15.1.p001">doi:10.20982/tqmp.15.1.p001</a> for specific references.
</p>


<h3>Details</h3>

<p>'suberb' is a library to perform descriptive statistics plots
based on the superb framework. In a nutshell, the framework 
assert that confidence intervals must be devised according to 
all the relevant information that can be used to assess precision.
For example, confidence intervals should be informed of the presence
of within-subject design, of the fact that the sample is random or clustered,
of whether the population is finite or infinite, etc.
</p>
<p>Would you do a t-test on independent groups when you know that the data
are paired? Of course, not! Why use the classic &quot;stand-alone&quot; confidence interval then?
These classic confidence intervals are oblivious to most relevant information.
</p>
<p>The superb framework is based on the idea that correct, well-informed, confidence 
intervals can be obtained with a succession of simple corrections. I call these
&quot;adjusted confidence intervals&quot;. 
</p>
<p>The main function is
</p>
<p><code>superbPlot(df,  ...)</code>  
</p>
<p>where <code>df</code> is a dataframe.
</p>
<p>For more details on the underlying math, see
(Cousineau 2005, 2019; Cousineau and Laurencelle 2016; Morey 2008; Baguley 2012; Loftus and Masson 1994; Goulet and Cousineau 2019)
</p>
<p>A second function inserted in this package is (Calderini and Harding 2019)
</p>
<p><code>GRD( ...)</code>
</p>
<p>which generates random datasets. It easily generate ficticious dataset
so that superbPlot can be tested rapidly. This function is described in 
(Calderini and Harding 2019).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Denis Cousineau <a href="mailto:denis.cousineau@uottawa.ca">denis.cousineau@uottawa.ca</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Bradley Harding <a href="mailto:bradley.harding@umoncton.ca">bradley.harding@umoncton.ca</a> [contributor]
</p>
</li>
<li><p> Marc-Andre Goulet <a href="mailto:magoulet101@gmail.com">magoulet101@gmail.com</a> [contributor]
</p>
</li>
<li><p> Jesika Walker <a href="mailto:jwalk050@uottawa.ca">jwalk050@uottawa.ca</a> [artist, presenter]
</p>
</li></ul>



<h3>References</h3>

<p>Baguley T (2012).
&ldquo;Calculating and graphing within-subject confidence intervals for ANOVA.&rdquo;
<em>Behavior Research Methods</em>, <b>44</b>, 158 &ndash; 175.
<a href="https://doi.org/10.3758/s13428-011-0123-7">doi:10.3758/s13428-011-0123-7</a>.<br /><br /> Calderini M, Harding B (2019).
&ldquo;GRD for R: An intuitive tool for generating random data in R.&rdquo;
<em>The Quantitative Methods for Psychology</em>, <b>15</b>(1), 1&ndash;11.
<a href="https://doi.org/10.20982/tqmp.15.1.p001">doi:10.20982/tqmp.15.1.p001</a>.<br /><br /> Cousineau D (2005).
&ldquo;Confidence intervals in within-subject designs: A simpler solution to Loftus and Masson's method.&rdquo;
<em>Tutorials in Quantitative Methods for Psychology</em>, <b>1</b>, 42 &ndash; 45.
<a href="https://doi.org/10.20982/tqmp.01.1.p042">doi:10.20982/tqmp.01.1.p042</a>.<br /><br /> Cousineau D (2017).
&ldquo;Varieties of confidence intervals.&rdquo;
<em>Advances in Cognitive Psychology</em>, <b>13</b>, 140 &ndash; 155.
<a href="https://doi.org/10.5709/acp-0214-z">doi:10.5709/acp-0214-z</a>.<br /><br /> Cousineau D (2019).
&ldquo;Correlation-adjusted standard errors and confidence intervals for within-subject designs: A simple multiplicative approach.&rdquo;
<em>The Quantitative Methods for Psychology</em>, <b>15</b>, 226 &ndash; 241.
<a href="https://doi.org/10.20982/tqmp.15.3.p226">doi:10.20982/tqmp.15.3.p226</a>.<br /><br /> Cousineau D, Laurencelle L (2016).
&ldquo;A Correction Factor for the Impact of Cluster Randomized Sampling and Its Applications.&rdquo;
<em>Psychological Methods</em>, <b>21</b>, 121 &ndash; 135.
<a href="https://doi.org/10.1037/met0000055">doi:10.1037/met0000055</a>.<br /><br /> Goulet M, Cousineau D (2019).
&ldquo;The power of replicated measures to increase statistical power.&rdquo;
<em>Advances in Methods and Practices in Psychological Sciences</em>, <b>Online</b>, 1 &ndash; 15.
<a href="https://doi.org/10.1177/2515245919849434">doi:10.1177/2515245919849434</a>.<br /><br /> Loftus GR, Masson MEJ (1994).
&ldquo;Using confidence intervals in within-subject designs.&rdquo;
<em>Psychonomic Bulletin &amp; Review</em>, <b>1</b>, 476 &ndash; 490.
<a href="https://doi.org/10.3758/BF03210951">doi:10.3758/BF03210951</a>.<br /><br /> Morey RD (2008).
&ldquo;Confidence Intervals from Normalized Data: A correction to Cousineau (2005).&rdquo;
<em>Tutorials in Quantitative Methods for Psychology</em>, <b>4</b>, 61 &ndash; 64.
<a href="https://doi.org/10.20982/tqmp.04.2.p061">doi:10.20982/tqmp.04.2.p061</a>.
</p>
<p>The package includes additional, helper, functions: </p>

<ul>
<li><p><code>ShroutFleissICC1</code> to compute intra-class correlation;
</p>
</li>
<li><p><code>epsilon</code> to compute the sphericity measure;
</p>
</li>
<li><p><code>lambda</code> to compute the cluster-sampling adjustment;
</p>
</li>
<li><p><code>MauchlySphericityTest</code> to perform a test of sphericity;
</p>
</li>
<li><p><code>WinerCompoundSymmetry</code> to perform a test of compound symmetry;
</p>
</li></ul>

<p>and example datasets described in the paper:  </p>

<ul>
<li><p><code>dataFigure1</code> illustrate the paradox of using stand-alone CI in between-group design;
</p>
</li>
<li><p><code>dataFigure2</code> illustrate the paradox of using stand-alone CI in within-subject design;
</p>
</li>
<li><p><code>dataFigure3</code> illustrate the paradox of using stand-alone CI in cluster-randomized sampling study;
</p>
</li>
<li><p><code>dataFigure4</code> illustrate the paradox of using stand-alone CI with population of finite size.
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://dcousin3.github.io/superb/">https://dcousin3.github.io/superb/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/dcousin3/superb/issues/">https://github.com/dcousin3/superb/issues/</a>
</p>
</li></ul>


<hr>
<h2 id='biasCorrectionTransform'>bias-correction transform</h2><span id='topic+biasCorrectionTransform'></span>

<h3>Description</h3>

<p><code>biasCorrectionTransform</code>  is a transformation that can
be applied to a matrix of data. The resulting matrix's variance
is corrected for bias (Morey 2008)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>biasCorrectionTransform(dta, variables)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="biasCorrectionTransform_+3A_dta">dta</code></td>
<td>
<p>a data.frame containing the data in wide format;</p>
</td></tr>
<tr><td><code id="biasCorrectionTransform_+3A_variables">variables</code></td>
<td>
<p>a vector of column names on which the transformation will be applied.
the remaining columns will be left unchanged</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame of the same form as dta with the variables transformed.
</p>
<p>This function is useful when passed to the argument <code>preprocessfct</code> of <code>superbPlot()</code>
where it performs a modification of the data matrix.
</p>


<h3>References</h3>

<p>Morey RD (2008).
&ldquo;Confidence Intervals from Normalized Data: A correction to Cousineau (2005).&rdquo;
<em>Tutorials in Quantitative Methods for Psychology</em>, <b>4</b>, 61 &ndash; 64.
<a href="https://doi.org/10.20982/tqmp.04.2.p061">doi:10.20982/tqmp.04.2.p061</a>.
</p>

<hr>
<h2 id='bootstrapPrecisionMeasures'>Bootstrapped measures of precision</h2><span id='topic+bootstrapPrecisionMeasures'></span><span id='topic+bootstrapSE.mean'></span><span id='topic+bootstrapPI.mean'></span><span id='topic+bootstrapSE.median'></span><span id='topic+bootstrapPI.median'></span><span id='topic+bootstrapSE.hmean'></span><span id='topic+bootstrapPI.hmean'></span><span id='topic+bootstrapSE.gmean'></span><span id='topic+bootstrapPI.gmean'></span><span id='topic+bootstrapSE.var'></span><span id='topic+bootstrapPI.var'></span><span id='topic+bootstrapSE.sd'></span><span id='topic+bootstrapPI.sd'></span>

<h3>Description</h3>

<p>superb also comes with a few built-in measures of
precisions that uses bootstrap. More can be added based on users needs.
All <code>bootstrapSE.fct()</code> functions produces an interval width;
all <code>bootstrapPI.fct()</code> produces the lower and upper limits of an interval.
These estimates are based on 5,000 sub-samples by default. Change this
default with<code>options("superb.bootstrapIter" = number )</code>.
See Efron and Tibshirani (1994) for a comprehensive introduction.
The bootstrap estimates are called PI which stands for Precision intervals.
This is to denote that they estimate the sampling distribution, not the
predictive distribution on which all confidence intervals are based
(Rousselet et al. 2019; Poitevineau and Lecoutre 2010; Lecoutre 1999).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrapSE.mean(x)

bootstrapPI.mean(x, gamma)

bootstrapSE.median(x)

bootstrapPI.median(x, gamma)

bootstrapSE.hmean(x)

bootstrapPI.hmean(x, gamma)

bootstrapSE.gmean(x)

bootstrapPI.gmean(x, gamma)

bootstrapSE.var(x)

bootstrapPI.var(x, gamma)

bootstrapSE.sd(x)

bootstrapPI.sd(x, gamma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootstrapPrecisionMeasures_+3A_x">x</code></td>
<td>
<p>a vector of numbers, the sample data (mandatory);</p>
</td></tr>
<tr><td><code id="bootstrapPrecisionMeasures_+3A_gamma">gamma</code></td>
<td>
<p>a confidence level for PI (default 0.95).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a measure of precision (SE) or an interval of precision (PI).
</p>


<h3>References</h3>

<p>Efron B, Tibshirani RJ (1994).
<em>An introduction to the bootstrap</em>.
CRC press.<br /><br /> Lecoutre B (1999).
&ldquo;Two useful distributions for Bayesian predictive procedures under normal models.&rdquo;
<em>Journal of Statistical Planning and Inference</em>, <b>79</b>, 93 &ndash; 105.
<a href="https://doi.org/10.1016/S0378-3758%2898%2900231-6">doi:10.1016/S0378-3758(98)00231-6</a>.<br /><br /> Poitevineau J, Lecoutre B (2010).
&ldquo;Implementing Bayesian predictive procedures: The K-prime and K-square distributions.&rdquo;
<em>Computational Statistics and Data Analysis</em>, <b>54</b>, 724 &ndash; 731.
<a href="https://doi.org/10.1016/j.csda.2008.11.004">doi:10.1016/j.csda.2008.11.004</a>.<br /><br /> Rousselet GA, Pernet CR, Wilcox RR (2019).
&ldquo;A practical introduction to the bootstrap: A versatile method to make inferences by using data-driven simulations.&rdquo;
<em>psyArXiv</em>.
<a href="https://doi.org/10.31234/osf.io/h8ft7">doi:10.31234/osf.io/h8ft7</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># the confidence interval of the mean for default 95% and 90% confidence level
bootstrapPI.mean( c(1,2,3) )
bootstrapPI.mean( c(1,2,3), gamma = 0.90)

# Standard errors for standard deviation or variance
bootstrapSE.sd( c(1,2,3) )
bootstrapSE.var( c(1,2,3) )

</code></pre>

<hr>
<h2 id='CousineauLaurencelleLambda'>Cousineau-Laurencelle's lambda correction for cluster-randomized sampling</h2><span id='topic+CousineauLaurencelleLambda'></span>

<h3>Description</h3>

<p>The functions CousineauLaurencelleLambda() returns the correction factor
for cluster-randomized sampling. This correction is then used
in a variety of ways, for example, to get the effective number of
participants (in a power study) or to correct a t-test.
See (Cousineau and Laurencelle 2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CousineauLaurencelleLambda(paramvector)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CousineauLaurencelleLambda_+3A_paramvector">paramvector</code></td>
<td>
<p>A vector with, in that order, the intra-class correlation r,
the number of clusters, then the number of participants in all the clusters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>lambda the correction factor for cluster-randomized sampling.
</p>


<h3>References</h3>

<p>Cousineau D, Laurencelle L (2016).
&ldquo;A Correction Factor for the Impact of Cluster Randomized Sampling and Its Applications.&rdquo;
<em>Psychological Methods</em>, <b>21</b>, 121 &ndash; 135.
<a href="https://doi.org/10.1037/met0000055">doi:10.1037/met0000055</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example from Cousineau &amp; Laurencelle, 2017, p. 124:
CousineauLaurencelleLambda( c(0.2, 5, 20, 20, 20, 20, 20) )
# 2.234188  

</code></pre>

<hr>
<h2 id='dataFigure1'>Data for Figure 1</h2><span id='topic+dataFigure1'></span>

<h3>Description</h3>

<p>The data, taken from (Cousineau 2017), is an example where the
&quot;stand-alone&quot; 95\% confidence interval of the means returns
a result in contradiction with the result of a statistical test.
The paradoxical result is resolved by using adjusted confidence intervals,
here the different-adjusted confidence interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dataFigure1)
</code></pre>


<h3>Format</h3>

<p>An object of class data.frame.
</p>


<h3>Source</h3>

<p><a href="https://doi.org/10.5709/acp-0214-z">doi:10.5709/acp-0214-z</a>
</p>


<h3>References</h3>

<p>Cousineau D (2017).
&ldquo;Varieties of confidence intervals.&rdquo;
<em>Advances in Cognitive Psychology</em>, <b>13</b>, 140 &ndash; 155.
<a href="https://doi.org/10.5709/acp-0214-z">doi:10.5709/acp-0214-z</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
library(gridExtra)
data(dataFigure1)

options(superb.feedback = 'none') # shut down 'warnings' and 'design' interpretation messages

## realize the plot with unadjusted (left) and ajusted (right) 95% confidence intervals
plt1a &lt;- superbPlot(dataFigure1, BSFactors = "grp", 
    adjustments=list(purpose = "single"), 
    variables = c("score"), plotStyle="bar" ) + 
  xlab("Group") + ylab("Score") + labs(title="95% CI\n") +
  coord_cartesian( ylim = c(85,115) ) +
  geom_hline(yintercept = 100, colour = "black", linewidth = 0.5, linetype=2)
plt1b &lt;- superbPlot(dataFigure1, BSFactors = "grp", 
    adjustments=list(purpose = "difference"), 
    variables = c("score"), plotStyle="bar" ) + 
  xlab("Group") + ylab("Score") + labs(title="Difference-adjusted 95% CI\n") +
  coord_cartesian( ylim = c(85,115) ) + 
  geom_hline(yintercept = 100, colour = "black", linewidth = 0.5, linetype=2)
plt1  &lt;- grid.arrange(plt1a,plt1b,ncol=2)

## realise the correct t-test to see the discrepancy
t.test(dataFigure1$score[dataFigure1$grp==1], 
       dataFigure1$score[dataFigure1$grp==2],
       var.equal=TRUE)

</code></pre>

<hr>
<h2 id='dataFigure2'>Data for Figure 2</h2><span id='topic+dataFigure2'></span>

<h3>Description</h3>

<p>The data, taken from (Cousineau 2017)7, is an example
where the
&quot;stand-alone&quot; 95\% confidence interval of the means returns
a result in contradiction with the result of a statistical test.
The paradoxical result is resolved by using adjusted confidence intervals,
here the correlation- and different-adjusted confidence interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dataFigure2)
</code></pre>


<h3>Format</h3>

<p>An object of class data.frame.
</p>


<h3>Source</h3>

<p><a href="https://doi.org/10.5709/acp-0214-z">doi:10.5709/acp-0214-z</a>
</p>


<h3>References</h3>

<p>Cousineau D (2017).
&ldquo;Varieties of confidence intervals.&rdquo;
<em>Advances in Cognitive Psychology</em>, <b>13</b>, 140 &ndash; 155.
<a href="https://doi.org/10.5709/acp-0214-z">doi:10.5709/acp-0214-z</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
library(gridExtra)
data(dataFigure2)

options(superb.feedback = 'none') # shut down 'warnings' and 'design' interpretation messages

## realize the plot with unadjusted (left) and ajusted (right) 95% confidence intervals
plt2a &lt;- superbPlot(dataFigure2, WSFactors = "Moment(2)", 
    adjustments=list(purpose = "difference"), 
    variables = c("pre","post"), plotStyle="bar" ) + 
  xlab("Group") + ylab("Score") + labs(title="Difference-adjusted 95% CI\n") +
  coord_cartesian( ylim = c(85,115) ) +
  geom_hline(yintercept = 100, colour = "black", linewidth = 0.5, linetype=2)
plt2b &lt;- superbPlot(dataFigure2, WSFactors = "Moment(2)", 
    adjustments=list(purpose = "difference", decorrelation = "CA"), 
    variables = c("pre","post"), plotStyle="bar" ) + 
  xlab("Group") + ylab("Score") + labs(title="Correlation and difference-adjusted\n95% CI") +
  coord_cartesian( ylim = c(85,115) ) + 
  geom_hline(yintercept = 100, colour = "black", linewidth = 0.5, linetype=2)
plt2  &lt;- grid.arrange(plt2a,plt2b,ncol=2)

## realise the correct t-test to see the discrepancy
t.test(dataFigure2$pre, dataFigure2$post, paired=TRUE)

</code></pre>

<hr>
<h2 id='dataFigure3'>Data for Figure 3</h2><span id='topic+dataFigure3'></span>

<h3>Description</h3>

<p>The data, inspired from (Cousineau and Laurencelle 2016), is an example where the
&quot;stand-alone&quot; 95\
a result in contradiction with the result of a statistical test.
The paradoxical result is resolved by using adjusted confidence intervals,
here the cluster- and different-adjusted confidence interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dataFigure3)
</code></pre>


<h3>Format</h3>

<p>An object of class data.frame.
</p>


<h3>Source</h3>

<p><a href="https://doi.org/10.5709/acp-0214-z">doi:10.5709/acp-0214-z</a>
</p>


<h3>References</h3>

<p>Cousineau D, Laurencelle L (2016).
&ldquo;A Correction Factor for the Impact of Cluster Randomized Sampling and Its Applications.&rdquo;
<em>Psychological Methods</em>, <b>21</b>, 121 &ndash; 135.
<a href="https://doi.org/10.1037/met0000055">doi:10.1037/met0000055</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
library(gridExtra)
data(dataFigure3)

options(superb.feedback = 'none') # shut down 'warnings' and 'design' interpretation messages

## realize the plot with unadjusted (left) and ajusted (right) 95% confidence intervals
plt3a &lt;- superbPlot(dataFigure3, BSFactors = "grp", 
    adjustments=list(purpose = "difference", samplingDesign = "SRS"), 
    variables = c("VD"), plotStyle="bar" ) + 
  xlab("Group") + ylab("Score") + labs(title="Difference-adjusted 95% CI\n") +
  coord_cartesian( ylim = c(85,115) ) +
  geom_hline(yintercept = 100, colour = "black", linewidth = 0.5, linetype=2)
plt3b &lt;- superbPlot(dataFigure3, BSFactors = "grp", 
    adjustments=list(purpose = "difference", samplingDesign = "CRS"), 
    variables = c("VD"), plotStyle="bar", clusterColumn = "cluster" ) + 
  xlab("Group") + ylab("Score") + labs(title="Cluster and difference-adjusted\n95% CI") +
  coord_cartesian( ylim = c(85,115) ) + 
  geom_hline(yintercept = 100, colour = "black", linewidth = 0.5, linetype=2)
plt3  &lt;- grid.arrange(plt3a,plt3b,ncol=2)

## realise the correct t-test to see the discrepancy
res   &lt;- t.test(dataFigure3$VD[dataFigure3$grp==1], 
               dataFigure3$VD[dataFigure3$grp==2],
               var.equal=TRUE)
micc  &lt;- mean(c(0.491334683772226, 0.20385744842838)) # mean ICC given by superbPlot
lam   &lt;- CousineauLaurencelleLambda(c(micc, 5,5,5,5,5,5))
tcorr &lt;- res$statistic / lam
pcorr &lt;- 1-pt(tcorr,4)
# let's see the t value and its p value:
c(tcorr, pcorr)

</code></pre>

<hr>
<h2 id='dataFigure4'>Data for Figure 4</h2><span id='topic+dataFigure4'></span>

<h3>Description</h3>

<p>The data, inspired from (Cousineau 2017), shows an example where the
&quot;stand-alone&quot; 95\
a result in contradiction with the result of a statistical test.
The paradoxical result is resolved by using adjusted confidence intervals,
here the population size-adjusted confidence interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dataFigure4)
</code></pre>


<h3>Format</h3>

<p>An object of class data.frame.
</p>


<h3>Source</h3>

<p><a href="https://doi.org/10.5709/acp-0214-z">doi:10.5709/acp-0214-z</a>
</p>


<h3>References</h3>

<p>Cousineau D (2017).
&ldquo;Varieties of confidence intervals.&rdquo;
<em>Advances in Cognitive Psychology</em>, <b>13</b>, 140 &ndash; 155.
<a href="https://doi.org/10.5709/acp-0214-z">doi:10.5709/acp-0214-z</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
library(gridExtra)
data(dataFigure4)

options(superb.feedback = 'none') # shut down 'warnings' and 'design' interpretation messages

## realize the plot with unadjusted (left) and ajusted (right) 95% confidence intervals
plt4a = superbPlot(dataFigure4, BSFactors = "group", 
    adjustments=list(purpose = "single", popSize = Inf), 
    variables = c("score"), plotStyle="bar" ) + 
  xlab("Group") + ylab("Score") + labs(title="Difference-adjusted 95% CI\n") +
  coord_cartesian( ylim = c(85,115) ) +
  geom_hline(yintercept = 100, colour = "black", linewidth = 0.5, linetype=2)
plt4b = superbPlot(dataFigure4, BSFactors = "group",
    adjustments=list(purpose = "single", popSize = 50 ), 
    variables = c("score"), plotStyle="bar" ) + 
  xlab("Group") + ylab("Score") + labs(title="Population size and difference-\nadjusted 95% CI") +
  coord_cartesian( ylim = c(85,115) ) + 
  geom_hline(yintercept = 100, colour = "black", linewidth = 0.5, linetype=2)
plt4 = grid.arrange(plt4a,plt4b,ncol=2)

## realise the correct t-test to see the discrepancy
res = t.test(dataFigure4$score, mu=100)
tcorr = res$statistic /sqrt(1-25/50)
pcorr = 1-pt(tcorr,24)
c(tcorr, pcorr)


</code></pre>

<hr>
<h2 id='geom_superberrorbar'>geom_superberrorbar for expanded error bar displays</h2><span id='topic+geom_superberrorbar'></span>

<h3>Description</h3>

<p><code>geom_superberrorbar()</code> is a geom for ggplots; it is based on
the original geom_errorbar (and is totally compatible with it) but
expands this geom in four different ways. First, it is possible to
decide whether the error bar tips are unidirectional, pointing to
the &quot;left&quot; or to the &quot;right&quot; or if they go in &quot;both&quot; directions.
Second, it is possible to &quot;double&quot; or &quot;triple&quot; the horizontal marks
at the extremities of the error bar, with a &quot;tipgap&quot; of your liking.
Third, an additiona characteristic is vcolour to set a different colour
for the vertical part of the error bar. The colour can also be &quot;NA&quot; to
have it invisible. Lastly, the error bar can be pointing &quot;up&quot; and &quot;down&quot;
or go in &quot;both&quot; (the default)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_superberrorbar(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  direction = "both",
  tipformat = "single",
  tipgap = 0.1,
  ...,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_superberrorbar_+3A_mapping">mapping</code></td>
<td>
<p>(as usual) see geom_errorbar</p>
</td></tr>
<tr><td><code id="geom_superberrorbar_+3A_data">data</code></td>
<td>
<p>(as usual) see geom_errorbar</p>
</td></tr>
<tr><td><code id="geom_superberrorbar_+3A_stat">stat</code></td>
<td>
<p>(as usual) see geom_errorbar</p>
</td></tr>
<tr><td><code id="geom_superberrorbar_+3A_position">position</code></td>
<td>
<p>(as usual) see geom_errorbar</p>
</td></tr>
<tr><td><code id="geom_superberrorbar_+3A_direction">direction</code></td>
<td>
<p>(NEW) &quot;left&quot;, &quot;right&quot; or &quot;both&quot; (Default is &quot;both&quot;)</p>
</td></tr>
<tr><td><code id="geom_superberrorbar_+3A_tipformat">tipformat</code></td>
<td>
<p>(NEW) &quot;single&quot;, &quot;double&quot; or &quot;triple&quot; to add additional
marker lines to the tips (default is &quot;single&quot;)</p>
</td></tr>
<tr><td><code id="geom_superberrorbar_+3A_tipgap">tipgap</code></td>
<td>
<p>(NEW) The spacing between the markers when &quot;double&quot; or &quot;triple&quot; is used (default 0.1)</p>
</td></tr>
<tr><td><code id="geom_superberrorbar_+3A_...">...</code></td>
<td>
<p>all additional parameters are sent to the underlying geom_path</p>
</td></tr>
<tr><td><code id="geom_superberrorbar_+3A_na.rm">na.rm</code></td>
<td>
<p>(as usual) see geom_errorbar</p>
</td></tr>
<tr><td><code id="geom_superberrorbar_+3A_orientation">orientation</code></td>
<td>
<p>(as usual) see geom_errorbar</p>
</td></tr>
<tr><td><code id="geom_superberrorbar_+3A_show.legend">show.legend</code></td>
<td>
<p>(as usual) see geom_errorbar</p>
</td></tr>
<tr><td><code id="geom_superberrorbar_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>(as usual) see geom_errorbar</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a layer containing error bars in a ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(superb) # to import the geom_superberrorbar
library(ggplot2)

# let's have a fake data frame
dta &lt;- data.frame(grp = c(1,2,3), center=c(1,2,3), width = c(1,1,1.5) )

# an example with none of the new features = a regular error bar
ggplot(dta, aes(ymin=center-width, ymax=center+width, x = grp ) ) +
  geom_superberrorbar()

# an example with left-pointing error bars
ggplot(dta, aes(ymin=center-width, ymax=center+width, x = grp ) ) +
  geom_superberrorbar(direction="left", width = 0.1)

# an example with doubled-tipped error bar and the default tipgap
ggplot(dta, aes(ymin=center-width, ymax=center+width, x = grp ) ) +
  geom_superberrorbar(tipformat = "double", width = 0.1)

# an example with left-pointing tripled-tip error bars with small gaps
ggplot(dta, aes(ymin=center-width, ymax=center+width, x = grp ) ) +
  geom_superberrorbar(tipformat = "triple", width= 0.1, tipgap = 0.04, direction = "left")

# an example with unidirectional error bars (here "up" bars)
ggplot(dta, aes(y= center, ymin=center-width, ymax=center+width, x = grp ) ) +
  geom_bar(stat="identity", fill = "yellow") + 
  geom_superberrorbar(pointing = "up")

# a final example with two-coloured, left-pointing tripled-tip error bars with small gaps
ggplot(dta, aes(ymin=center-width, ymax=center+width, x = grp ) ) +
  geom_superberrorbar(tipformat = "triple", width= 0.1, tipgap = 0.04, direction = "left",
           colour = "black", vcolour = "orange")

# This new geom is integrated inside superbPlot() so that you can vary the 
# error bar shapes. Let's see examples:

# using GRD to generate random data with a moderate effect
options(superb.feedback = 'none') # shut down 'warnings' and 'design' interpretation messages
test &lt;- GRD(SubjectsPerGroup  = 20,
		   WSFactors = "Moment(5)", 
            Effects = list("Moment" = extent(10) ),
            Population = list(mean = 100, stddev = 25, rho = 0.8) ) 

ornate = list(
        labs(title =paste("(left)            95% confidence intervals",
                        "\n(right)          99% confidence intervals",
                        "\n(center, up) 99.9% confidence intervals")),
        xlab("Moment"), ylab("Score"),
        coord_cartesian( ylim = c(85,110) )
)

plt1 &lt;- superbPlot(test, 
            WSFactors = "Moment(5)",  
            variables = c("DV.1","DV.2","DV.3","DV.4","DV.5"), 
            adjustments=list(purpose = "difference", decorrelation = "CA"), 
            errorbarParams = list(direction = "left", color="purple", 
                                  width = 0.2, position = position_nudge(-0.05) ),
            gamma     = 0.95,
            plotStyle = "line" ) + ornate
plt2 &lt;- superbPlot(test, 
            WSFactors = "Moment(5)",  
            variables = c("DV.1","DV.2","DV.3","DV.4","DV.5"), 
            adjustments=list(purpose = "difference", decorrelation = "CA"), 
            errorbarParams = list(direction = "right", tipgap = 0.25, tipformat = "double", 
                                  width = 0.2, position = position_nudge(+0.05) ),
            gamma     = 0.99,
            plotStyle = "line" ) + ornate 
plt3 &lt;- superbPlot(test, 
            WSFactors = "Moment(5)",  
            variables = c("DV.1","DV.2","DV.3","DV.4","DV.5"), 
            adjustments=list(purpose = "difference", decorrelation = "CA"), 
            errorbarParams = list(direction = "both", tipformat = "single", pointing="up", 
                                  width = 0.2, position = position_nudge(0) ),
            gamma     = 0.999,
            plotStyle = "line" ) + ornate 

# transform the ggplots into "grob" so that they can be manipulated
plt1 &lt;- ggplotGrob(plt1)
plt2 &lt;- ggplotGrob(plt2 + makeTransparent() )
plt3 &lt;- ggplotGrob(plt3 + makeTransparent() )

# put the grobs onto an empty ggplot 
ggplot() + 
    annotation_custom(grob=plt1) + 
    annotation_custom(grob=plt2) + 
    annotation_custom(grob=plt3)

</code></pre>

<hr>
<h2 id='GRD'>Generate random data</h2><span id='topic+GRD'></span>

<h3>Description</h3>

<p>The function <code>GRD()</code> generates a data frame containing
random data suitable for analyses.
The data can be from within-subject or between-group designs.
Within-subject designs are in wide format. The function was originally
presented in Calderini and Harding (2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GRD(
  RenameDV = "DV",
  SubjectsPerGroup = 100,
  BSFactors = "",
  WSFactors = "",
  Effects = list(),
  Population = list(mean = 0, stddev = 1, rho = 0, scores =
    "rnorm(1, mean = GM, sd = STDDEV)"),
  Contaminant = list(mean = 0, stddev = 1, rho = 0, scores =
    "rnorm(1, mean = CGM, sd = CSTDDEV)", proportion = 0)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GRD_+3A_renamedv">RenameDV</code></td>
<td>
<p>provide a name for the dependent variable (default DV)</p>
</td></tr>
<tr><td><code id="GRD_+3A_subjectspergroup">SubjectsPerGroup</code></td>
<td>
<p>indicates the number of simulated scores per
group (default 100 in each group)</p>
</td></tr>
<tr><td><code id="GRD_+3A_bsfactors">BSFactors</code></td>
<td>
<p>a string indicating the between-subject factor(s)
with, between parenthesis, the number of levels or the list of
level names. Multiple factors are separated with a colon &quot;:&quot; or
enumerated in a vector of strings.</p>
</td></tr>
<tr><td><code id="GRD_+3A_wsfactors">WSFactors</code></td>
<td>
<p>a string indicating the within-subject factor(s) in
the same format as the between-subject factors</p>
</td></tr>
<tr><td><code id="GRD_+3A_effects">Effects</code></td>
<td>
<p>a list detailing the effects to apply to the data</p>
</td></tr>
<tr><td><code id="GRD_+3A_population">Population</code></td>
<td>
<p>a list providing the population characteristics
(default is a normal distribution with a mean of 0 and standard deviation of 1)</p>
</td></tr>
<tr><td><code id="GRD_+3A_contaminant">Contaminant</code></td>
<td>
<p>a list providing the contaminant characteristics
and the proportion of contaminant (default 0)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with the simulated scores.
</p>


<h3>Note</h3>

<p>Note that the <code>range</code> effect specification has been renamed
<code>extent</code> to avoid masking the base function <code>base::range</code>.
</p>


<h3>References</h3>

<p>Calderini M, Harding B (2019).
&ldquo;GRD for R: An intuitive tool for generating random data in R.&rdquo;
<em>The Quantitative Methods for Psychology</em>, <b>15</b>(1), 1&ndash;11.
<a href="https://doi.org/10.20982/tqmp.15.1.p001">doi:10.20982/tqmp.15.1.p001</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # Simplest example using all the default arguments: 
 dta &lt;- GRD()
 head(dta)
 hist(dta$DV)

 # Renaming the dependant variable and setting the group size:
 dta &lt;- GRD( RenameDV = "score", SubjectsPerGroup = 200 )
 hist(dta$score )

 # Examples for a between-subject design and for a within-subject design: 
 dta &lt;- GRD( BSFactors = '3', SubjectsPerGroup = 20)
 dta &lt;- GRD( WSFactors = "Moment (2)", SubjectsPerGroup = 20)

 # A complex, 3 x 2 x (2) mixed design with a variable amount of participants in the 6 groups:
 dta &lt;- GRD(BSFactors = "difficulty(3) : gender (2)", 
         WSFactors="day(2)",
         SubjectsPerGroup=c(20,24,12,13,28,29)
       )

 # Defining population characteristics :
 dta &lt;- GRD( 
         RenameDV = "IQ",
		SubjectsPerGroup = 20,
         Population=list(
                      mean=100,  # will set GM to 100
                      stddev=15  # will set STDDEV to 15
                    ) 
        )
 hist(dta$IQ)

 # This example adds an effect along the "Difficulty" factor with a slope of 15
 dta &lt;- GRD(BSFactors="Difficulty(5)", SubjectsPerGroup = 100,
     Population=list(mean=50,stddev=5), 
     Effects = list("Difficulty" = slope(15) )  )
 # show the mean performance as a function of difficulty:
 superbPlot(dta, BSFactors = "Difficulty", variables="DV")

 # An example in which the moments are correlated
 dta &lt;- GRD( BSFactors = "Difficulty(2)",WSFactors = "Moment (2)", 
     SubjectsPerGroup = 250,
     Effects = list("Difficulty" = slope(3), "Moment" = slope(1) ),
     Population=list(mean=50,stddev=20,rho=0.85)
 )
 # the mean plot on the raw data...
 superbPlot(dta, BSFactors = "Difficulty", WSFactors = "Moment(2)", 
     variables=c("DV.1","DV.2"), plotStyle="line",
     adjustments = list (purpose="difference") )
 # ... and the mean plot on the decorrelated data; 
 # because of high correlation, the error bars are markedly different
 superbPlot(dta, BSFactors = "Difficulty", WSFactors = "Moment(2)", 
     variables=c("DV.1","DV.2"), plotStyle="line",
     adjustments = list (purpose="difference", decorrelation = "CM") )
 
</code></pre>

<hr>
<h2 id='HyunhFeldtEpsilon'>Hyunh and Feldt's epsilon measure of sphericity</h2><span id='topic+HyunhFeldtEpsilon'></span>

<h3>Description</h3>

<p>HyunhFeldtEpsilon() is a measure of sphericity created by
Geisser and Greenhouse (1958). The original measure was biased
and therefore, Huynh and Feldt (1976) produced a revised version
(note that the 1976 paper contained typos that were uncorrected
in SPSS; Lecoutre (1991))
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HyunhFeldtEpsilon(dta, cols)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HyunhFeldtEpsilon_+3A_dta">dta</code></td>
<td>
<p>a data.frame</p>
</td></tr>
<tr><td><code id="HyunhFeldtEpsilon_+3A_cols">cols</code></td>
<td>
<p>a vector of column names indicating the relevant
columns on which to compute epsilon. Any other columns are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the Hyunh-Feldt estimate of sphericity epsilon
</p>


<h3>References</h3>

<p>Geisser S, Greenhouse SW (1958).
&ldquo;An extension of Box's results on the use of the <code class="reqn">F</code> distribution in multivariate analysis.&rdquo;
<em>Annals of Mathematical Statistics</em>, <b>29</b>(3), 885&ndash;891.<br /><br /> Huynh H, Feldt LS (1976).
&ldquo;Estimation of the Box correction for degrees of freedom from sample data in randomized block and split-plot designs.&rdquo;
<em>Journal of educational statistics</em>, <b>1</b>(1), 69&ndash;82.<br /><br /> Lecoutre B (1991).
&ldquo;A correction for the <code class="reqn">\varepsilon</code> approximate test in repeated measures designs with two or more independent groups.&rdquo;
<em>Journal of Educational Statistics</em>, <b>16</b>(4), 371&ndash;372.
</p>

<hr>
<h2 id='makeTransparent'>makes ggplots with transparent elements</h2><span id='topic+makeTransparent'></span>

<h3>Description</h3>

<p>makeTransparent is an extension to ggplots
which makes all the elements of the plot transparent
except the data being displayed. This is useful to
superimpose multiple plots, e.g. to generate plots with
multiple error bars for example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeTransparent()
</code></pre>


<h3>Value</h3>

<p>does not return anything; set the elements to transparent.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# make a basic plot
superbPlot(ToothGrowth, BSFactors = c("dose", "supp"), 
  variables = "len") 
# make a basic plot with transparent elements
superbPlot(ToothGrowth, BSFactors = c("dose", "supp"), 
  variables = "len") + makeTransparent()

</code></pre>

<hr>
<h2 id='MauchlySphericityTest'>Mauchly's test of Sphericity</h2><span id='topic+MauchlySphericityTest'></span>

<h3>Description</h3>

<p>Performs a test of sphericity on a dataframe with
multiple measures, one subject per line. It assesses the significance of the
null hypothesis that the covariance matrix is spherical.
This test is described in (Abdi 2010)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MauchlySphericityTest(dta, cols)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MauchlySphericityTest_+3A_dta">dta</code></td>
<td>
<p>A data frame containing within-subject measures, one participant per line;</p>
</td></tr>
<tr><td><code id="MauchlySphericityTest_+3A_cols">cols</code></td>
<td>
<p>A vector indicating the columns containing the measures.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>p the p-value of the null hypothesis that the data are spherical.
</p>


<h3>References</h3>

<p>Abdi H (2010).
&ldquo;The greenhouse-geisser correction.&rdquo;
<em>Encyclopedia of research design</em>, <b>1</b>(1), 544&ndash;548.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># creates a small data frames with 4 subject's scores for 5 measures:
dta &lt;- data.frame(cbind(
        col1 &lt;- c(3., 6., 2., 2., 5.),
        col2 &lt;- c(4., 5., 4., 4., 3.),
        col3 &lt;- c(2., 7., 7., 8., 6.),
        col4 &lt;- c(6., 8., 4., 6., 5.)
    ))
# performs the test (here p = 0.5824)
MauchlySphericityTest(dta)

</code></pre>

<hr>
<h2 id='measuresWithMissingData'>Measures with missing data</h2><span id='topic+measuresWithMissingData'></span><span id='topic+meanNArm'></span><span id='topic+meanNArm+2C'></span><span id='topic+SE.meanNArm'></span><span id='topic+CI.meanNArm'></span>

<h3>Description</h3>

<p>The following three functions can be used with missing data.
They return the mean, the standard error of the mean and the confidence
interval of the mean.Note that we hesitated to provide these functions: you
should deal with missing data prior to making your plot.
Also note that for repeated-measure design, only CA adjustment is available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meanNArm(x)

SE.meanNArm(x)

CI.meanNArm(x, gamma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="measuresWithMissingData_+3A_x">x</code></td>
<td>
<p>a vector of numbers, the sample data (mandatory);</p>
</td></tr>
<tr><td><code id="measuresWithMissingData_+3A_gamma">gamma</code></td>
<td>
<p>a confidence level for CI (default 0.95).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the means, a measure of precision (SE) or an interval of precision
(CI) in the presence of missing data.
</p>


<h3>References</h3>

<p>There are no references for Rd macro <code style="white-space: pre;">&#8288;\insertAllCites&#8288;</code> on this help page.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># the confidence interval of the mean for default 95% and 90% confidence level
meanNArm( c(1,2,3, NA) )
SE.meanNArm( c(1,2,3, NA) )
CI.meanNArm( c(1,2,3, NA) )
CI.meanNArm( c(1,2,3, NA), gamma = 0.90)

</code></pre>

<hr>
<h2 id='poolSDTransform'>pooled standard deviation transform</h2><span id='topic+poolSDTransform'></span>

<h3>Description</h3>

<p><code>poolSDTransform</code>  is a transformations that can
be applied to a matrix of data. The resulting matrix has the column-
standard deviations equal to the pool standard deviations of the
individual columns, the solution adopted by (Loftus and Masson 1994).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poolSDTransform(dta, variables)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poolSDTransform_+3A_dta">dta</code></td>
<td>
<p>a data.frame containing the data in wide format;</p>
</td></tr>
<tr><td><code id="poolSDTransform_+3A_variables">variables</code></td>
<td>
<p>a vector of column names on which the transformation will be applied.
the remaining columns will be left unchanged</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame of the same form as dta with the variables transformed.
</p>
<p>This function is useful when passed to the argument <code>preprocessfct</code> of <code>superbPlot()</code>
where it performs a modification of the data matrix.
</p>


<h3>References</h3>

<p>Loftus GR, Masson MEJ (1994).
&ldquo;Using confidence intervals in within-subject designs.&rdquo;
<em>Psychonomic Bulletin &amp; Review</em>, <b>1</b>, 476 &ndash; 490.
<a href="https://doi.org/10.3758/BF03210951">doi:10.3758/BF03210951</a>.
</p>

<hr>
<h2 id='precisionMeasures'>Precision measures</h2><span id='topic+precisionMeasures'></span><span id='topic+SE.mean'></span><span id='topic+CI.mean'></span><span id='topic+SE.median'></span><span id='topic+CI.median'></span><span id='topic+SE.hmean'></span><span id='topic+CI.hmean'></span><span id='topic+SE.gmean'></span><span id='topic+CI.gmean'></span><span id='topic+SE.var'></span><span id='topic+CI.var'></span><span id='topic+SE.sd'></span><span id='topic+CI.sd'></span><span id='topic+SE.MAD'></span><span id='topic+CI.MAD'></span><span id='topic+SE.IQR'></span><span id='topic+CI.IQR'></span><span id='topic+SE.fisherskew'></span><span id='topic+CI.fisherskew'></span><span id='topic+SE.pearsonskew'></span><span id='topic+CI.pearsonskew'></span><span id='topic+SE.fisherkurtosis'></span><span id='topic+CI.fisherkurtosis'></span>

<h3>Description</h3>

<p>superb comes with a few built-in measures of
precisions. All <code>SE.fct()</code> functions produces an interval width;
all <code>CI.fct()</code> produces the lower and upper limits of an interval.
See (Harding et al. 2014; Harding et al. 2015) for more.
&quot;superbPlot-compatible&quot; precision measures must have these parameters:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SE.mean(x)

CI.mean(x, gamma)

SE.median(x)

CI.median(x, gamma)

SE.hmean(x)

CI.hmean(x, gamma)

SE.gmean(x)

CI.gmean(x, gamma)

SE.var(x)

CI.var(x, gamma)

SE.sd(x)

CI.sd(x, gamma)

SE.MAD(x)

CI.MAD(x, gamma)

SE.IQR(x)

CI.IQR(x, gamma)

SE.fisherskew(x)

CI.fisherskew(x, gamma)

SE.pearsonskew(x)

CI.pearsonskew(x, gamma)

SE.fisherkurtosis(x)

CI.fisherkurtosis(x, gamma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="precisionMeasures_+3A_x">x</code></td>
<td>
<p>a vector of numbers, the sample data (mandatory);</p>
</td></tr>
<tr><td><code id="precisionMeasures_+3A_gamma">gamma</code></td>
<td>
<p>a confidence level for CI (default 0.95).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a measure of precision (SE) or an interval of precision (CI).
</p>


<h3>References</h3>

<p>Harding B, Tremblay C, Cousineau D (2014).
&ldquo;Standard errors: A review and evaluation of standard error estimators using Monte Carlo simulations.&rdquo;
<em>The Quantitative Methods for Psychology</em>, <b>10</b>(2), 107&ndash;123.<br /><br /> Harding B, Tremblay C, Cousineau D (2015).
&ldquo;The standard error of the Pearson skew.&rdquo;
<em>The Quantitative Methods for Psychology</em>, <b>11</b>(1), 32&ndash;36.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># the confidence interval of the mean for default 95% and 90% confidence level
CI.mean( c(1,2,3) )
CI.mean( c(1,2,3), gamma = 0.90)

# Standard errors for standard deviation, for MAD and for fisher skew
SE.sd( c(1,2,3) )
SE.MAD( c(1,2,3) )
SE.fisherskew( c(1,2,3) )

</code></pre>

<hr>
<h2 id='precisionMeasureWithCustomDF'>Confidence intervals with custom degree of freedom</h2><span id='topic+precisionMeasureWithCustomDF'></span><span id='topic+CIwithDF.mean'></span>

<h3>Description</h3>

<p>The following function computes a confidence interval with
custom degree of freedom. The default is to use N-1 but this number is not
always appropriate. For example, when there are heterogeneous variances,
the confidence interval of the mean should mirror a Welsh test where the
degrees of freedom are altered based on variances. The function <code>CIwithDF.mean()</code>
accept an arbitrary defined degree of freedom (df).
The df must be combined to the argument <code>gamma</code> after the confidence level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CIwithDF.mean(x, gamma = 0.95 )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="precisionMeasureWithCustomDF_+3A_x">x</code></td>
<td>
<p>a vector of numbers, the sample data (mandatory);</p>
</td></tr>
<tr><td><code id="precisionMeasureWithCustomDF_+3A_gamma">gamma</code></td>
<td>
<p>a vector containing first a confidence level for CI (default 0.95) and
a custom degree of freedom (when unspecified, it uses <code>n-1</code> where <code>n</code> is the number of observations in x).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the vignette &quot;Unequal variances, Welch test, Tryon adjustment, and superb&quot;
for an example of use.
</p>


<h3>Value</h3>

<p>the confidence interval (CI) where the <code>t</code> value is based on the custom-set degree of freedom.
</p>


<h3>References</h3>

<p>There are no references for Rd macro <code style="white-space: pre;">&#8288;\insertAllCites&#8288;</code> on this help page.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># this will issue a warning as no custom degree of freedom is provided
CIwithDF.mean( c(1,2,3), gamma = 0.90)          
# the confidence interval of the mean for 90% confidence level
CIwithDF.mean( c(1,2,3), gamma = c(0.90, 1.5) ) # uses 1.5 as df instead of 2.

</code></pre>

<hr>
<h2 id='runDebug'>runDebug</h2><span id='topic+runDebug'></span>

<h3>Description</h3>

<p>runDebug is an internal function used by GRD and superb
to help in debugging the functions. It assigns in the global environment
the variables that are local to a function so that they become visible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runDebug(where, title, vars, vals)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runDebug_+3A_where">where</code></td>
<td>
<p>indicates where in the program runDebug was called</p>
</td></tr>
<tr><td><code id="runDebug_+3A_title">title</code></td>
<td>
<p>string text to be displayed when this function is triggered</p>
</td></tr>
<tr><td><code id="runDebug_+3A_vars">vars</code></td>
<td>
<p>strings names of the variables to be placed in the global environment</p>
</td></tr>
<tr><td><code id="runDebug_+3A_vals">vals</code></td>
<td>
<p>numeric values to be given to the variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>puts in the globalenvironment the variables named &quot;vars&quot;
</p>

<hr>
<h2 id='showSignificance'>Annotate significance of results on plots</h2><span id='topic+showSignificance'></span><span id='topic+showVerticalSignificance'></span><span id='topic+showHorizontalSignificance'></span>

<h3>Description</h3>

<p>showSignificance is used to add an annotation to
a ggplot in the form of a bracket with a text. The bracket
extends from x range (left, right) with a heigth of width. It is also possible
to have the bracket and the text vertical when y is a range (bottom, top).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showSignificance(
  x,
  y,
  width,
  text = NULL,
  panel = list(),
  segmentParams = list(),
  textParams = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showSignificance_+3A_x">x</code></td>
<td>
<p>(a vector of 2 when horizontal) indicates the limits of the annotation;</p>
</td></tr>
<tr><td><code id="showSignificance_+3A_y">y</code></td>
<td>
<p>(a vector of 2 when vertical) the location of the annotation in the y direction</p>
</td></tr>
<tr><td><code id="showSignificance_+3A_width">width</code></td>
<td>
<p>height of the annotation; for negative width, the legs extends towards the bottom;</p>
</td></tr>
<tr><td><code id="showSignificance_+3A_text">text</code></td>
<td>
<p>(optional) string text to be display on the opposite side of width;</p>
</td></tr>
<tr><td><code id="showSignificance_+3A_panel">panel</code></td>
<td>
<p>(optional) a list to identify in which panel to put the annotation;</p>
</td></tr>
<tr><td><code id="showSignificance_+3A_segmentparams">segmentParams</code></td>
<td>
<p>(optional) a list of directives that will be sent to the geom_segment items;</p>
</td></tr>
<tr><td><code id="showSignificance_+3A_textparams">textParams</code></td>
<td>
<p>(optional) a list of directives that will be sent to the geom_text item.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>adds an annotation in a ggplot
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading required libraries
library(superb)
library(ggplot2)
library(grid)

# making one random data set with three factors 2 x 3 x (3)
dta &lt;- GRD(
    SubjectsPerGroup = 20,
    BSFactors = c("Group(2)","Age(3)"), 
    WSFactors = c("Moment(3)"),
    Population = list(mean = 75, stddev = 5),
    Effects   = list("Group" = slope(10) )
)

# making a two-factor plot and a three-factor plots (having panels)
plt2 &lt;- superbPlot(dta, 
        BSFactor = c("Group"),
        WSFactor = c("Moment(3)"),
        variables = c("DV.1","DV.2","DV.3"),
        adjustments = list(purpose="difference"),
        factorOrder = c("Moment","Group")
    )
plt3 &lt;- superbPlot(dta, 
        BSFactor = c("Group","Age"),
        WSFactor = c("Moment(3)"),
        variables = c("DV.1","DV.2","DV.3"),
        adjustments = list(purpose="difference"),
        factorOrder = c("Moment","Group","Age")
    )

# lets decorate these plots a bit...
plt2 &lt;- plt2 +  scale_fill_manual( name = "Group", 
        labels = c("Easy", "Hard"), 
        values = c("blue", "purple")) + 
  scale_colour_manual( name = "Group", 
        labels = c("Easy", "Hard"), 
        values = c("blue", "purple")) +
  coord_cartesian( ylim = c(50,100), xlim = c(0.5, 3.9) )
plt3 &lt;- plt3 +  scale_fill_manual( name = "Group", 
        labels = c("Easy", "Hard"), 
        values = c("blue", "purple")) + 
  scale_colour_manual( name = "Group", 
        labels = c("Easy", "Hard"), 
        values = c("blue", "purple")) +
  coord_cartesian( ylim = c(50,105) )

# a very basic example
plt2 +  showSignificance( c(0.75, 1.25), 90, -1, "++1++")

# the annotation can be vertical when y is a vector with bottom and top location:
plt2 + showSignificance( 3.75, c(70,80), -0.1, "++1++")

# an example with panels; the "panel" argument is used to identify on 
# which panel to put the annotation (or else they appear on all panels)
# and with arms of differing lengths, and one flat ending
plt3 + 
    showSignificance( c(0.75, 1.25), 90, -2.5,      "++1++", panel = list(Age= 1)) + 
    showSignificance( c(1.75, 2.25), 90, -2.5,      "++2++", panel = list(Age= 2)) + 
    showSignificance( c(0.75, 1.25), 90, c(-10,-5), "++3++", panel = list(Age= 3)) +
    showSignificance( c(2.00, 3.25), 95, -10,       "++4++", panel = list(Age= 3)) + 
    showSignificance( c(1.75, 2.25), 85, 0,                  panel = list(Age= 3))  

# here, we send additional directives to the annotations
plt3 + 
    showSignificance( c(0.75, 1.25), 90, -5,  "++1++", panel = list(Age= 1)) + 
    showSignificance( c(1.75, 2.25), 95, -10, "++2++", panel = list(Age = 2),
        textParams    = list(size = 3,              # smaller font
                            family  = "mono",       # courrier font
                            colour= "chartreuse3"   # dark green color
        ), 
        segmentParams = list(linewidth = 1.,             # thicker lines
                            arrow   = arrow(length = unit(0.2, "cm") ), # arrow heads
                            colour = "chartreuse3"  # dark green color as well
        )
    ) +
    showSignificance( c(1.75, 3.25), 95, -30, "++3++", panel = list(Age = 3),
        textParams    = list(size = 5,              # larger font
                            family  = "serif",      # times font
                            alpha = 0.3 ),          # transparent
        segmentParams = list(linewidth = 2., 
                            arrow   = arrow(length = unit(0.2, "cm") ), 
                            alpha = 0.3, 
                            lineend = "round"       # so that line end overlap nicely
        )
    )

</code></pre>

<hr>
<h2 id='ShroutFleissICC1'>Shrout and Fleiss intra-class correlation functions</h2><span id='topic+ShroutFleissICC1'></span><span id='topic+ShroutFleissICC11'></span><span id='topic+ShroutFleissICC1k'></span>

<h3>Description</h3>

<p>The functions ShroutFleissICC1, ShroutFleissICC11
and ShroutFleissICC1k computes the intra-class correlation ICC
for a given data frame containing repeated measures in columns cols
when the measures are in distinct clusters, identified in column clustercol.
See (Shrout and Fleiss 1979).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ShroutFleissICC1(dta, clustercol, cols)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ShroutFleissICC1_+3A_dta">dta</code></td>
<td>
<p>A data frame containing within-subject measures, one participant per line;</p>
</td></tr>
<tr><td><code id="ShroutFleissICC1_+3A_clustercol">clustercol</code></td>
<td>
<p>is the column index where cluster belonging are given;</p>
</td></tr>
<tr><td><code id="ShroutFleissICC1_+3A_cols">cols</code></td>
<td>
<p>A vector indicating the columns containing the measures.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ICC the intra-class measure of association.
</p>


<h3>References</h3>

<p>Shrout PE, Fleiss JL (1979).
&ldquo;Intraclass correlations: uses in assessing rater reliability.&rdquo;
<em>Psychological bulletin</em>, <b>86</b>(2), 420.
</p>
<p>Shrout PE, Fleiss JL (1979).
&ldquo;Intraclass correlations: uses in assessing rater reliability.&rdquo;
<em>Psychological bulletin</em>, <b>86</b>(2), 420.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># creates a small data frames with 4 subject's scores for 5 measures:
dta &lt;- data.frame(cbind(
        clus &lt;- c(1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3),
        col1 &lt;- c(2, 4, 4, 6, 4, 5, 8, 8, 5, 8, 9, 9)
    ))

ShroutFleissICC1(dta, 1, 2)
# 0.434343434 
ShroutFleissICC11(dta[, 1], dta[,2])
# 0.434343434 

dta2 &lt;- data.frame(cbind(
        clus &lt;- c(1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3),
        col1 &lt;- c(1, 3, 3, 5, 3, 4, 7, 7, 4, 7, 8, 8),
        col1 &lt;- c(2, 4, 4, 6, 4, 5, 8, 8, 5, 8, 9, 9),
        col1 &lt;- c(3, 5, 5, 7, 5, 6, 9, 9, 6, 9, 10, 10)
    ))
 
ShroutFleissICC1(dta2, 1, 2:4)
# 0.7543859649 
ShroutFleissICC1k(dta2[, 1], dta2[,2:4])
# 0.7543859649 
  
</code></pre>

<hr>
<h2 id='slope'>Effect description</h2><span id='topic+slope'></span><span id='topic+extent'></span><span id='topic+custom'></span><span id='topic+Rexpression'></span>

<h3>Description</h3>

<p>There is four ways that effects can be defined
in GRD. &quot;factor = slope(s)&quot; will vary the means by an amount of s for 
each step of the factor; &quot;factor = extent(s)&quot; will vary the means
uniformly so that there is a difference of s between the first and
the last factor level; &quot;factor = custom(a,b,c..)&quot; will alter each
means by an amount of a for the first, b for the second, etc. Finally
&quot;factor = Rexpression(&quot;R code&quot;)&quot; will apply R code to all levels of 
the factors. R code result alters the base mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slope(s)

extent(s)

custom(...)

Rexpression(str)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slope_+3A_s">s</code></td>
<td>
<p>the size of the effect</p>
</td></tr>
<tr><td><code id="slope_+3A_...">...</code></td>
<td>
<p>a sequence with the sizes of the effects</p>
</td></tr>
<tr><td><code id="slope_+3A_str">str</code></td>
<td>
<p>R code string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>These internal functions are not meant to be used in 
isolation in any meaningful way...
</p>

<hr>
<h2 id='subjectCenteringTransform'>subject-centering transform</h2><span id='topic+subjectCenteringTransform'></span>

<h3>Description</h3>

<p><code>subjectCenteringTransform</code> is a transformation that can
be applied to a matrix of data. the resulting matrix have means
that are centered on the grand mean, subject-wise (Cousineau 2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subjectCenteringTransform(dta, variables)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subjectCenteringTransform_+3A_dta">dta</code></td>
<td>
<p>a data.frame containing the data in wide format;</p>
</td></tr>
<tr><td><code id="subjectCenteringTransform_+3A_variables">variables</code></td>
<td>
<p>a vector of column names on which the transformation will be applied.
the remaining columns will be left unchanged</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame of the same form as dta with the variables transformed.
</p>
<p>This function is useful when passed to the argument <code>preprocessfct</code> of <code>superbPlot()</code>
where it performs a modification of the data matrix.
</p>


<h3>References</h3>

<p>Cousineau D (2005).
&ldquo;Confidence intervals in within-subject designs: A simpler solution to Loftus and Masson's method.&rdquo;
<em>Tutorials in Quantitative Methods for Psychology</em>, <b>1</b>, 42 &ndash; 45.
<a href="https://doi.org/10.20982/tqmp.01.1.p042">doi:10.20982/tqmp.01.1.p042</a>.
</p>

<hr>
<h2 id='summaryStatistics'>Additional summary statistics</h2><span id='topic+summaryStatistics'></span><span id='topic+hmean'></span><span id='topic+gmean'></span><span id='topic+MAD'></span><span id='topic+fisherskew'></span><span id='topic+pearsonskew'></span><span id='topic+fisherkurtosis'></span>

<h3>Description</h3>

<p>superb adds a few summary statistics that can
be used to characterize a dataset. All comes with <code>SE.fct()</code> and <code>CI.fct()</code>.
See (Harding et al. 2014; Harding et al. 2015) for more.
<em>superbPlot-compatible</em> summary statistics functions must have one parameter:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmean(x)

gmean(x)

MAD(x)

fisherskew(x)

pearsonskew(x)

fisherkurtosis(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summaryStatistics_+3A_x">x</code></td>
<td>
<p>a vector of numbers, the sample data (mandatory);</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a summary statistic describing the sample.
</p>


<h3>References</h3>

<p>Harding B, Tremblay C, Cousineau D (2014).
&ldquo;Standard errors: A review and evaluation of standard error estimators using Monte Carlo simulations.&rdquo;
<em>The Quantitative Methods for Psychology</em>, <b>10</b>(2), 107&ndash;123.<br /><br /> Harding B, Tremblay C, Cousineau D (2015).
&ldquo;The standard error of the Pearson skew.&rdquo;
<em>The Quantitative Methods for Psychology</em>, <b>11</b>(1), 32&ndash;36.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># the confidence interval of the mean for default 95% and 90% confidence level
gmean( c(1,2,3) )  # the geometric mean; also available in psych::geometric.mean 	
hmean( c(1,2,3) )  # the harmonic mean;  also available in psych::harmonic.mean 	
MAD( c(1,2,3) )    # the median absolute deviation to the median (not the same as mad)
fisherskew( c(1,2,3) )     # the Fisher skew corrected for sample size
fisherkurtosis( c(1,2,3) ) # the Fisher kurtosis corrected for sample size
pearsonskew( c(1,2,3) )    # the Pearson skew

</code></pre>

<hr>
<h2 id='superbData'>Obtain summary statistics with correct error bars.</h2><span id='topic+superbData'></span>

<h3>Description</h3>

<p>The function <code>suberbData()</code> computes standard error or confidence interval for various descriptive
statistics under various designs, sampling schemes, population size and purposes,
according to the <code>suberb</code> framework. See (Cousineau et al. 2021) for more.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>superbData(
  data,
  BSFactors = NULL,
  WSFactors = NULL,
  WSDesign = "fullfactorial",
  factorOrder = NULL,
  variables,
  statistic = "mean",
  errorbar = "CI",
  gamma = 0.95,
  adjustments = list(purpose = "single", popSize = Inf, decorrelation = "none",
    samplingDesign = "SRS"),
  preprocessfct = NULL,
  postprocessfct = NULL,
  clusterColumn = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="superbData_+3A_data">data</code></td>
<td>
<p>Dataframe in wide format</p>
</td></tr>
<tr><td><code id="superbData_+3A_bsfactors">BSFactors</code></td>
<td>
<p>The name of the columns containing the between-subject factor(s)</p>
</td></tr>
<tr><td><code id="superbData_+3A_wsfactors">WSFactors</code></td>
<td>
<p>The name of the within-subject factor(s)</p>
</td></tr>
<tr><td><code id="superbData_+3A_wsdesign">WSDesign</code></td>
<td>
<p>the within-subject design if not a full factorial design (default &quot;fullfactorial&quot;)</p>
</td></tr>
<tr><td><code id="superbData_+3A_factororder">factorOrder</code></td>
<td>
<p>Order of factors as shown in the graph (x axis, groups, horizontal
panels, vertical panels)</p>
</td></tr>
<tr><td><code id="superbData_+3A_variables">variables</code></td>
<td>
<p>The dependent variable(s)</p>
</td></tr>
<tr><td><code id="superbData_+3A_statistic">statistic</code></td>
<td>
<p>The summary statistic function to use</p>
</td></tr>
<tr><td><code id="superbData_+3A_errorbar">errorbar</code></td>
<td>
<p>The function that computes the error bar. Should be &quot;CI&quot; or &quot;SE&quot; or
any function name. Defaults to &quot;CI&quot;</p>
</td></tr>
<tr><td><code id="superbData_+3A_gamma">gamma</code></td>
<td>
<p>The coverage factor; necessary when errorbar == &quot;CI&quot;. Default is 0.95.</p>
</td></tr>
<tr><td><code id="superbData_+3A_adjustments">adjustments</code></td>
<td>
<p>List of adjustments as described below.
Default is <code>adjustments = list(purpose = "single", popSize = Inf, decorrelation = "none", samplingDesign = "SRS")</code></p>
</td></tr>
<tr><td><code id="superbData_+3A_preprocessfct">preprocessfct</code></td>
<td>
<p>is a transform (or vector of) to be performed first on data matrix of each group</p>
</td></tr>
<tr><td><code id="superbData_+3A_postprocessfct">postprocessfct</code></td>
<td>
<p>is a transform (or vector of)</p>
</td></tr>
<tr><td><code id="superbData_+3A_clustercolumn">clusterColumn</code></td>
<td>
<p>used in conjunction with samplingDesign = &quot;CRS&quot;, indicates which column contains the cluster membership</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The possible adjustements are the following
</p>

<ul>
<li><p> popsize: Size of the population under study. Defaults to Inf
</p>
</li>
<li><p> purpose: The purpose of the comparisons. Defaults to &quot;single&quot;.
Can be &quot;single&quot;, &quot;difference&quot;, or &quot;tryon&quot;.
</p>
</li>
<li><p> decorrelation: Decorrelation method for repeated measure designs.
Chooses among the methods &quot;CM&quot;, &quot;LM&quot;, &quot;CA&quot; or &quot;none&quot;. Defaults to &quot;none&quot;.
</p>
</li>
<li><p> samplingDesign: Sampling method to obtain the sample. implemented
sampling is &quot;SRS&quot; (Simple Randomize Sampling) and &quot;CRS&quot; (Cluster-Randomized Sampling).
</p>
</li></ul>



<h3>Value</h3>

<p>a list with (1) the summary statistics in summaryStatistics
(2) the raw data in long format in rawData (using numeric levels for
repeated-measure variables).
</p>


<h3>References</h3>

<p>Cousineau D, Goulet M, Harding B (2021).
&ldquo;Summary plots with adjusted error bars: The superb framework with an implementation in R.&rdquo;
<em>Advances in Methods and Practices in Psychological Science</em>, <b>4</b>, 1&ndash;18.
<a href="https://doi.org/10.1177/25152459211035109">doi:10.1177/25152459211035109</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Basic example using a built-in dataframe as data; 
# by default, the mean is computed and the error bar are 95% confidence intervals
# (it also produces a $rawData dataframe, not shown here)
res &lt;- superbData(ToothGrowth, BSFactors = c("dose", "supp"), 
  variables = "len") 
res$summaryStatistics

# Example introducing adjustments for pairwise comparisons 
# and assuming that the whole population is limited to 200 persons
res &lt;- superbData(ToothGrowth, BSFactors = c("dose", "supp"), 
  variables = "len",  
  statistic = "median", errorbar = "CI", gamma = .80,
  adjustments = list( purpose = "difference", popSize = 200) )
res$summaryStatistics


</code></pre>

<hr>
<h2 id='superbPlot'>summary plot of any statistics with adjusted error bars.</h2><span id='topic+superbPlot'></span>

<h3>Description</h3>

<p>The function <code>suberbPlot()</code> plots standard error or confidence interval for various descriptive
statistics under various designs, sampling schemes, population size and purposes,
according to the <code>suberb</code> framework. See (Cousineau et al. 2021) for more.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>superbPlot(
  data,
  BSFactors = NULL,
  WSFactors = NULL,
  WSDesign = "fullfactorial",
  factorOrder = NULL,
  variables,
  statistic = "mean",
  errorbar = "CI",
  gamma = 0.95,
  adjustments = list(purpose = "single", popSize = Inf, decorrelation = "none",
    samplingDesign = "SRS"),
  showPlot = TRUE,
  plotStyle = "bar",
  preprocessfct = NULL,
  postprocessfct = NULL,
  clusterColumn = "",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="superbPlot_+3A_data">data</code></td>
<td>
<p>Dataframe in wide format</p>
</td></tr>
<tr><td><code id="superbPlot_+3A_bsfactors">BSFactors</code></td>
<td>
<p>The name of the columns containing the between-subject factor(s)</p>
</td></tr>
<tr><td><code id="superbPlot_+3A_wsfactors">WSFactors</code></td>
<td>
<p>The name of the within-subject factor(s)</p>
</td></tr>
<tr><td><code id="superbPlot_+3A_wsdesign">WSDesign</code></td>
<td>
<p>the within-subject design if not a full factorial design (default &quot;fullfactorial&quot;)</p>
</td></tr>
<tr><td><code id="superbPlot_+3A_factororder">factorOrder</code></td>
<td>
<p>Order of factors as shown in the graph (in that order: x axis,
groups, horizontal panels, vertical panels)</p>
</td></tr>
<tr><td><code id="superbPlot_+3A_variables">variables</code></td>
<td>
<p>The dependent variable(s) as strings</p>
</td></tr>
<tr><td><code id="superbPlot_+3A_statistic">statistic</code></td>
<td>
<p>The summary statistic function to use as a string</p>
</td></tr>
<tr><td><code id="superbPlot_+3A_errorbar">errorbar</code></td>
<td>
<p>The function that computes the error bar. Should be &quot;CI&quot; or &quot;SE&quot; or
any function name if you defined a custom function. Default to &quot;CI&quot;</p>
</td></tr>
<tr><td><code id="superbPlot_+3A_gamma">gamma</code></td>
<td>
<p>The coverage factor; necessary when <code>errorbar == "CI"</code>. Default is 0.95.</p>
</td></tr>
<tr><td><code id="superbPlot_+3A_adjustments">adjustments</code></td>
<td>
<p>List of adjustments as described below.
Default is <code>adjustments = list(purpose = "single", popSize = Inf, decorrelation = "none", samplingDesign = "SRS")</code></p>
</td></tr>
<tr><td><code id="superbPlot_+3A_showplot">showPlot</code></td>
<td>
<p>Defaults to TRUE. Set to FALSE if you want the output to be the summary statistics and intervals.</p>
</td></tr>
<tr><td><code id="superbPlot_+3A_plotstyle">plotStyle</code></td>
<td>
<p>The type of object to plot on the graph. See full list below.
Defaults to &quot;bar&quot;.</p>
</td></tr>
<tr><td><code id="superbPlot_+3A_preprocessfct">preprocessfct</code></td>
<td>
<p>is a transform (or vector of) to be performed first on data matrix of each group</p>
</td></tr>
<tr><td><code id="superbPlot_+3A_postprocessfct">postprocessfct</code></td>
<td>
<p>is a transform (or vector of)</p>
</td></tr>
<tr><td><code id="superbPlot_+3A_clustercolumn">clusterColumn</code></td>
<td>
<p>used in conjunction with samplingDesign = &quot;CRS&quot;, indicates which column contains the cluster membership</p>
</td></tr>
<tr><td><code id="superbPlot_+3A_...">...</code></td>
<td>
<p>In addition to the parameters above, superbPlot also accept a number of
optional arguments that will be transmitted to the plotting function, such as
pointParams (a list of ggplot2 parameters to input inside geoms; see ?geom_bar2) and
errorbarParams (a list of ggplot2 parameters for geom_errorbar; see ?geom_errorbar)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The possible adjustements are the following
</p>

<ul>
<li><p> popsize: Size of the population under study. Defaults to Inf
</p>
</li>
<li><p> purpose: The purpose of the comparisons. Defaults to &quot;single&quot;.
Can be &quot;single&quot;, &quot;difference&quot;, or &quot;tryon&quot;.
</p>
</li>
<li><p> decorrelation: Decorrelation method for repeated measure designs.
Chooses among the methods &quot;CM&quot;, &quot;LM&quot;, &quot;CA&quot;, &quot;UA&quot;, or &quot;none&quot;. Defaults to
&quot;none&quot;. &quot;CA&quot; is correlation-adjusted (Cousineau 2019);
&quot;UA&quot; is based on the unitary Alpha method (derived from the Cronbach alpha);
see (L. and D. 2023).
</p>
</li>
<li><p> samplingDesign: Sampling method to obtain the sample. implemented
sampling is &quot;SRS&quot; (Simple Randomize Sampling) and &quot;CRS&quot; (Cluster-Randomized Sampling).
</p>
</li></ul>

<p>In version 0.97.5, the layouts for plots are the following:
</p>

<ul>
<li><p> &quot;bar&quot; Shows the summary statistics with bars and error bars;
</p>
</li>
<li><p> &quot;line&quot; Shows the summary statistics with lines connecting the conditions over the first factor;
</p>
</li>
<li><p> &quot;point&quot; Shows the summary statistics with isolated points
</p>
</li>
<li><p> &quot;pointjitter&quot; Shows the summary statistics along with jittered points depicting the raw data;
</p>
</li>
<li><p> &quot;pointjitterviolin&quot; Also adds violin plots to the previous layout
</p>
</li>
<li><p> &quot;pointindividualline&quot; Connects the raw data with line along the first factor (which should be a repeated-measure factor)
</p>
</li>
<li><p> &quot;raincloud&quot; Illustrates the distribution with a cloud (half_violin_plot) and jittered dots next to it. Looks better when coordinates are flipped <code>+coord_flip()</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>a plot with the correct error bars or a table of those summary statistics.
The plot is a ggplot2 object with can be modified with additional declarations.
</p>


<h3>References</h3>

<p>Cousineau D (2019).
&ldquo;Correlation-adjusted standard errors and confidence intervals for within-subject designs: A simple multiplicative approach.&rdquo;
<em>The Quantitative Methods for Psychology</em>, <b>15</b>, 226 &ndash; 241.
<a href="https://doi.org/10.20982/tqmp.15.3.p226">doi:10.20982/tqmp.15.3.p226</a>.<br /><br /> Cousineau D, Goulet M, Harding B (2021).
&ldquo;Summary plots with adjusted error bars: The superb framework with an implementation in R.&rdquo;
<em>Advances in Methods and Practices in Psychological Science</em>, <b>4</b>, 1&ndash;18.
<a href="https://doi.org/10.1177/25152459211035109">doi:10.1177/25152459211035109</a>.<br /><br /> L. L, D. C (2023).
&ldquo;Analysis of proportions using arcsine transform with any experimental design.&rdquo;
<em>Frontiers in Psychology</em>, <b>13</b>, 1045436.
<a href="https://doi.org/10.3389/fpsyg.2022.1045436">doi:10.3389/fpsyg.2022.1045436</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Basic example using a built-in dataframe as data. 
# By default, the mean is computed and the error bar are 95% confidence intervals
superbPlot(ToothGrowth, BSFactors = c("dose", "supp"), 
  variables = "len") 

# Example changing the summary statistics to the median and
# the error bar to 80% confidence intervals
superbPlot(ToothGrowth, BSFactors = c("dose", "supp"), 
  variables = "len", statistic = "median", errorbar = "CI", gamma = .80) 

# Example introducing adjustments for pairwise comparisons 
# and assuming that the whole population is limited to 200 persons
superbPlot(ToothGrowth, BSFactors = c("dose", "supp"), 
  variables = "len",  
  adjustments = list( purpose = "difference", popSize = 200) )

# This example adds ggplot directives to the plot produced
library(ggplot2)
superbPlot(ToothGrowth, BSFactors = c("dose", "supp"), 
  variables = "len") + 
xlab("Dose") + ylab("Tooth Growth") +
theme_bw()

# This example is based on repeated measures
library(gridExtra)
options(superb.feedback = 'none') # shut down 'warnings' and 'design' interpretation messages

# Use the Orange example, but let's define shorter column names...
names(Orange) &lt;- c("Tree","age","circ")
# ... and turn the data into a wide format using superbToWide:
Orange.wide &lt;- superbToWide(Orange, id = "Tree", WSFactors = c("age"), variable = "circ") 

# This example contains 5 trees whose diameter (in mm) has been measured at various age (in days):
head(Orange.wide)

# Makes the plots first without decorrelation:
p1=superbPlot( Orange.wide, WSFactors = "age(7)",
  variables = c("circ_118","circ_484","circ_664","circ_1004","circ_1231","circ_1372","circ_1582"),
  adjustments = list(purpose = "difference", decorrelation = "none")
) + 
  xlab("Age level") + ylab("Trunk diameter (mm)") +
  coord_cartesian( ylim = c(0,250) ) + labs(title="''Standalone'' confidence intervals")
# ... and then with decorrelation (technique Correlation-adjusted CA):
p2=superbPlot( Orange.wide, WSFactors = "age(7)",
  variables = c("circ_118","circ_484","circ_664","circ_1004","circ_1231","circ_1372","circ_1582"),
  adjustments = list(purpose = "difference", decorrelation = "CA")
) + 
  xlab("Age level") + ylab("Trunk diameter (mm)") +
  coord_cartesian( ylim = c(0,250) ) + labs(title="Decorrelated confidence intervals")
grid.arrange(p1,p2,ncol=2)


</code></pre>

<hr>
<h2 id='superbPlot.bar'>superbPlot 'bar' layout</h2><span id='topic+superbPlot.bar'></span>

<h3>Description</h3>

<p>superbPlot comes with a few built-in templates for making the final plots.
All produces ggplot objects that can be further customized. Additionally, it is
possible to add custom-make templates (see vignette 6). The functions, to be
&quot;superbPlot-compatible&quot;, must have these parameters:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>superbPlot.bar(
  summarydata,
  xfactor,
  groupingfactor,
  addfactors,
  rawdata = NULL,
  barParams = list(),
  errorbarParams = list(),
  facetParams = list(),
  xAsFactor = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="superbPlot.bar_+3A_summarydata">summarydata</code></td>
<td>
<p>a data.frame with columns &quot;center&quot;, &quot;lowerwidth&quot; and &quot;upperwidth&quot; for each level of the factors;</p>
</td></tr>
<tr><td><code id="superbPlot.bar_+3A_xfactor">xfactor</code></td>
<td>
<p>a string with the name of the column where the factor going on the horizontal axis is given;</p>
</td></tr>
<tr><td><code id="superbPlot.bar_+3A_groupingfactor">groupingfactor</code></td>
<td>
<p>a string with the name of the column for which the data will be grouped on the plot;</p>
</td></tr>
<tr><td><code id="superbPlot.bar_+3A_addfactors">addfactors</code></td>
<td>
<p>a string with up to two additional factors to make the rows and columns panels, in the form &quot;fact1 ~ fact2&quot;;</p>
</td></tr>
<tr><td><code id="superbPlot.bar_+3A_rawdata">rawdata</code></td>
<td>
<p>always contains &quot;DV&quot; for each participants and each level of the factors</p>
</td></tr>
<tr><td><code id="superbPlot.bar_+3A_barparams">barParams</code></td>
<td>
<p>(optional) list of graphic directives that are sent to the geom_bar layer</p>
</td></tr>
<tr><td><code id="superbPlot.bar_+3A_errorbarparams">errorbarParams</code></td>
<td>
<p>(optional) list of graphic directives that are sent to the geom_superberrorbar layer</p>
</td></tr>
<tr><td><code id="superbPlot.bar_+3A_facetparams">facetParams</code></td>
<td>
<p>(optional) list of graphic directives that are sent to the facet_grid layer</p>
</td></tr>
<tr><td><code id="superbPlot.bar_+3A_xasfactor">xAsFactor</code></td>
<td>
<p>(optional) Boolean to indicate if the factor on the horizontal should continuous or discrete (default is discrete)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This will make a plot with bars
superbPlot(ToothGrowth, 
   BSFactors = c("dose","supp"), variables = "len",
   plotStyle="bar" 
)

# if you extract the data with superbData, you can 
# run this layout directly
#processedData &lt;- superbData(ToothGrowth, 
#   BSFactors = c("dose","supp"), variables = "len"
#)
#
#superbPlot.bar(processedData$summaryStatistic,
#   "dose",
#   "supp",
#   ".~.",
#   processedData$rawData)

</code></pre>

<hr>
<h2 id='superbPlot.boxplot'>superbPlot 'boxplot' layout</h2><span id='topic+superbPlot.boxplot'></span>

<h3>Description</h3>

<p>superbPlot comes with a few built-in templates for making the final plots.
All produces ggplot objects that can be further customized. Additionally, it is
possible to create custom-make templates (see vignette 5). The functions, to be
&quot;superbPlot-compatible&quot;, must have these parameters:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>superbPlot.boxplot(
  summarydata,
  xfactor,
  groupingfactor,
  addfactors,
  rawdata = NULL,
  pointParams = list(),
  errorbarParams = list(),
  facetParams = list(),
  boxplotParams = list(),
  xAsFactor = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="superbPlot.boxplot_+3A_summarydata">summarydata</code></td>
<td>
<p>a data.frame with columns &quot;center&quot;, &quot;lowerwidth&quot; and &quot;upperwidth&quot; for each level of the factors;</p>
</td></tr>
<tr><td><code id="superbPlot.boxplot_+3A_xfactor">xfactor</code></td>
<td>
<p>a string with the name of the column where the factor going on the horizontal axis is given;</p>
</td></tr>
<tr><td><code id="superbPlot.boxplot_+3A_groupingfactor">groupingfactor</code></td>
<td>
<p>a string with the name of the column for which the data will be grouped on the plot;</p>
</td></tr>
<tr><td><code id="superbPlot.boxplot_+3A_addfactors">addfactors</code></td>
<td>
<p>a string with up to two additional factors to make the rows and columns panels, in the form &quot;fact1 ~ fact2&quot;;</p>
</td></tr>
<tr><td><code id="superbPlot.boxplot_+3A_rawdata">rawdata</code></td>
<td>
<p>always contains &quot;DV&quot; for each participants and each level of the factors;</p>
</td></tr>
<tr><td><code id="superbPlot.boxplot_+3A_pointparams">pointParams</code></td>
<td>
<p>(optional) list of graphic directives that are sent to the geom_bar layer;</p>
</td></tr>
<tr><td><code id="superbPlot.boxplot_+3A_errorbarparams">errorbarParams</code></td>
<td>
<p>(optional) list of graphic directives that are sent to the geom_superberrorbar layer;</p>
</td></tr>
<tr><td><code id="superbPlot.boxplot_+3A_facetparams">facetParams</code></td>
<td>
<p>(optional) list of graphic directives that are sent to the facet_grid layer;</p>
</td></tr>
<tr><td><code id="superbPlot.boxplot_+3A_boxplotparams">boxplotParams</code></td>
<td>
<p>(optional) list f graphic directives that are sent to the geo_boxplot layer;</p>
</td></tr>
<tr><td><code id="superbPlot.boxplot_+3A_xasfactor">xAsFactor</code></td>
<td>
<p>(optional) Boolean to indicate if the factor on the horizontal should continuous or discrete (default is discrete).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This will make a plot with boxes for interquartile (box), median (line) and outliers (whiskers)
superbPlot(ToothGrowth, 
   BSFactors = c("dose","supp"), variables = "len",
   plotStyle = "boxplot" 
)

# This layout of course is more meaningful if the statistic displayed is the median
superbPlot(ToothGrowth, 
   BSFactors = c("dose","supp"), 
   variables = "len",
   statistic = "median",
   plotStyle = "boxplot" 
)

# if you extracted the data with superbData, you can 
# run this layout directly
processedData &lt;- superbData(ToothGrowth, 
   BSFactors = c("dose","supp"), variables = "len", statistic = "median"
)

superbPlot.boxplot(processedData$summaryStatistic,
   "dose", "supp", ".~.",
   processedData$rawData)

# This will make a plot with customized boxplot parameters and black dots
superbPlot(ToothGrowth, 
   BSFactors = c("dose","supp"), variables = "len",
   statistic = "median",
   plotStyle = "boxplot",
   boxplotParams = list( outlier.shape=8, outlier.size=4 ),
   pointParams = list(color="black") 
)

# You can customize the plot in various ways, e.g.
plt3 &lt;- superbPlot(ToothGrowth, 
   BSFactors = c("dose","supp"), variables = "len",
   statistic = "median",
   plotStyle = "boxplot",
   pointParams = list(color="black")
)

# ... by changing the colors of the fillings
library(ggplot2) # for scale_fill_manual, geom_jitter and geom_dotplot
plt3 + scale_fill_manual(values=c("#999999", "#E69F00", "#56B4E9"))

# ... by overlaying jittered dots of the raw data
plt3 + geom_jitter(data = processedData$rawData, mapping=aes(x=dose, y=DV), 
   position= position_jitterdodge(jitter.width=0.5 , dodge.width=0.8 ) )
 
# ... by overlaying dots of the raw data, aligned along the center of the box
plt3 + geom_dotplot(data = processedData$rawData, mapping=aes(x=dose, y=DV), dotsize=0.5,
   binaxis='y', stackdir='center', position=position_dodge(0.8))  
 

</code></pre>

<hr>
<h2 id='superbPlot.halfwidthline'>superbPlot 'halfwidthline' layout</h2><span id='topic+superbPlot.halfwidthline'></span>

<h3>Description</h3>

<p>superbPlot comes with a few built-in templates for making the final plots.
All produces ggplot objects that can be further customized. The half-width confidence
interval line plot is EXPERIMENTAL. It divides the CI length by two, one thick section and one thin section.
The functions, to be &quot;superbPlot-compatible&quot;, must have these parameters:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>superbPlot.halfwidthline(
  summarydata,
  xfactor,
  groupingfactor,
  addfactors,
  rawdata = NULL,
  pointParams = list(),
  lineParams = list(),
  errorbarParams = list(),
  errorbarlightParams = list(),
  facetParams = list(),
  xAsFactor = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="superbPlot.halfwidthline_+3A_summarydata">summarydata</code></td>
<td>
<p>a data.frame with columns &quot;center&quot;, &quot;lowerwidth&quot; and &quot;upperwidth&quot; for each level of the factors;</p>
</td></tr>
<tr><td><code id="superbPlot.halfwidthline_+3A_xfactor">xfactor</code></td>
<td>
<p>a string with the name of the column where the factor going on the horizontal axis is given;</p>
</td></tr>
<tr><td><code id="superbPlot.halfwidthline_+3A_groupingfactor">groupingfactor</code></td>
<td>
<p>a string with the name of the column for which the data will be grouped on the plot;</p>
</td></tr>
<tr><td><code id="superbPlot.halfwidthline_+3A_addfactors">addfactors</code></td>
<td>
<p>a string with up to two additional factors to make the rows and columns panels, in the form &quot;fact1 ~ fact2&quot;;</p>
</td></tr>
<tr><td><code id="superbPlot.halfwidthline_+3A_rawdata">rawdata</code></td>
<td>
<p>always contains &quot;DV&quot; for each participants and each level of the factors</p>
</td></tr>
<tr><td><code id="superbPlot.halfwidthline_+3A_pointparams">pointParams</code></td>
<td>
<p>(optional) list of graphic directives that are sent to the geom_bar layer</p>
</td></tr>
<tr><td><code id="superbPlot.halfwidthline_+3A_lineparams">lineParams</code></td>
<td>
<p>(optional) list of graphic directives that are sent to the geom_bar layer</p>
</td></tr>
<tr><td><code id="superbPlot.halfwidthline_+3A_errorbarparams">errorbarParams</code></td>
<td>
<p>(optional) list of graphic directives that are sent to the geom_superberrorbar layer</p>
</td></tr>
<tr><td><code id="superbPlot.halfwidthline_+3A_errorbarlightparams">errorbarlightParams</code></td>
<td>
<p>(optional) graphic directives for the second half of the error bar;</p>
</td></tr>
<tr><td><code id="superbPlot.halfwidthline_+3A_facetparams">facetParams</code></td>
<td>
<p>(optional) list of graphic directives that are sent to the facet_grid layer</p>
</td></tr>
<tr><td><code id="superbPlot.halfwidthline_+3A_xasfactor">xAsFactor</code></td>
<td>
<p>(optional) Boolean to indicate if the factor on the horizontal should continuous or discrete (default is discrete)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This will make a plot with lines
superbPlot(ToothGrowth, 
   BSFactor = c("dose","supp"), variables = "len",
   plotStyle="halfwidthline" 
)

# if you extract the data with superbData, you can 
# run this layout directly
#processedData &lt;- superbData(ToothGrowth, 
#   BSFactor = c("dose","supp"), variables = "len"
#)
#
#superbPlot.halfwidthline(processedData$summaryStatistic,
#   "dose",
#   "supp",
#   ".~.",
#   processedData$rawData)

</code></pre>

<hr>
<h2 id='superbPlot.line'>superbPlot 'line' layout</h2><span id='topic+superbPlot.line'></span>

<h3>Description</h3>

<p>superbPlot comes with a few built-in templates for making the final plots.
All produces ggplot objects that can be further customized. Additionally, it is
possible to add custom-make templates (see vignette 6). The functions, to be
&quot;superbPlot-compatible&quot;, must have these parameters:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>superbPlot.line(
  summarydata,
  xfactor,
  groupingfactor,
  addfactors,
  rawdata = NULL,
  pointParams = list(),
  lineParams = list(),
  errorbarParams = list(),
  facetParams = list(),
  xAsFactor = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="superbPlot.line_+3A_summarydata">summarydata</code></td>
<td>
<p>a data.frame with columns &quot;center&quot;, &quot;lowerwidth&quot; and &quot;upperwidth&quot; for each level of the factors;</p>
</td></tr>
<tr><td><code id="superbPlot.line_+3A_xfactor">xfactor</code></td>
<td>
<p>a string with the name of the column where the factor going on the horizontal axis is given;</p>
</td></tr>
<tr><td><code id="superbPlot.line_+3A_groupingfactor">groupingfactor</code></td>
<td>
<p>a string with the name of the column for which the data will be grouped on the plot;</p>
</td></tr>
<tr><td><code id="superbPlot.line_+3A_addfactors">addfactors</code></td>
<td>
<p>a string with up to two additional factors to make the rows and columns panels, in the form &quot;fact1 ~ fact2&quot;;</p>
</td></tr>
<tr><td><code id="superbPlot.line_+3A_rawdata">rawdata</code></td>
<td>
<p>always contains &quot;DV&quot; for each participants and each level of the factors</p>
</td></tr>
<tr><td><code id="superbPlot.line_+3A_pointparams">pointParams</code></td>
<td>
<p>(optional) list of graphic directives that are sent to the geom_bar layer</p>
</td></tr>
<tr><td><code id="superbPlot.line_+3A_lineparams">lineParams</code></td>
<td>
<p>(optional) list of graphic directives that are sent to the geom_bar layer</p>
</td></tr>
<tr><td><code id="superbPlot.line_+3A_errorbarparams">errorbarParams</code></td>
<td>
<p>(optional) list of graphic directives that are sent to the geom_superberrorbar layer</p>
</td></tr>
<tr><td><code id="superbPlot.line_+3A_facetparams">facetParams</code></td>
<td>
<p>(optional) list of graphic directives that are sent to the facet_grid layer</p>
</td></tr>
<tr><td><code id="superbPlot.line_+3A_xasfactor">xAsFactor</code></td>
<td>
<p>(optional) Boolean to indicate if the factor on the horizontal should continuous or discrete (default is discrete)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This will make a plot with lines
superbPlot(ToothGrowth, 
   BSFactors = c("dose","supp"), variables = "len",
   plotStyle="line" 
)

# if you extract the data with superbData, you can 
# run this layout directly
#processedData &lt;- superbData(ToothGrowth, 
#   BSFactors = c("dose","supp"), variables = "len"
#)
#
#superbPlot.line(processedData$summaryStatistic,
#   "dose",
#   "supp",
#   ".~.",
#   processedData$rawData)

</code></pre>

<hr>
<h2 id='superbPlot.lineBand'>superbPlot 'lineBand' layout</h2><span id='topic+superbPlot.lineBand'></span>

<h3>Description</h3>

<p>The lineBand layout displays an error band instead of individual error bars. This layout is
convenient when you have many points on your horizontal axis (so that the error bars are difficult to distinguish)
and when the results are fairly smooth.
</p>
<p>The functions has these parameters:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>superbPlot.lineBand(
  summarydata,
  xfactor,
  groupingfactor,
  addfactors,
  rawdata,
  pointParams = list(),
  lineParams = list(),
  facetParams = list(),
  errorbandParams = list(),
  xAsFactor = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="superbPlot.lineBand_+3A_summarydata">summarydata</code></td>
<td>
<p>a data.frame with columns &quot;center&quot;, &quot;lowerwidth&quot; and &quot;upperwidth&quot; for each level of the factors;</p>
</td></tr>
<tr><td><code id="superbPlot.lineBand_+3A_xfactor">xfactor</code></td>
<td>
<p>a string with the name of the column where the factor going on the horizontal axis is given;</p>
</td></tr>
<tr><td><code id="superbPlot.lineBand_+3A_groupingfactor">groupingfactor</code></td>
<td>
<p>a string with the name of the column for which the data will be grouped on the plot;</p>
</td></tr>
<tr><td><code id="superbPlot.lineBand_+3A_addfactors">addfactors</code></td>
<td>
<p>a string with up to two additional factors to make the rows and columns panels, in the form &quot;fact1 ~ fact2&quot;;</p>
</td></tr>
<tr><td><code id="superbPlot.lineBand_+3A_rawdata">rawdata</code></td>
<td>
<p>always contains &quot;DV&quot; for each participants and each level of the factors</p>
</td></tr>
<tr><td><code id="superbPlot.lineBand_+3A_pointparams">pointParams</code></td>
<td>
<p>(optional) list of graphic directives that are sent to the geom_point layer</p>
</td></tr>
<tr><td><code id="superbPlot.lineBand_+3A_lineparams">lineParams</code></td>
<td>
<p>(optional) list of graphic directives that are sent to the geom_jitter layer</p>
</td></tr>
<tr><td><code id="superbPlot.lineBand_+3A_facetparams">facetParams</code></td>
<td>
<p>(optional) list of graphic directives that are sent to the facet_grid layer</p>
</td></tr>
<tr><td><code id="superbPlot.lineBand_+3A_errorbandparams">errorbandParams</code></td>
<td>
<p>(optional) list of graphic directives that are sent to the geom_ribbon layer</p>
</td></tr>
<tr><td><code id="superbPlot.lineBand_+3A_xasfactor">xAsFactor</code></td>
<td>
<p>(optional) Boolean to indicate if the factor on the horizontal should continuous or discrete (default is discrete)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object
</p>


<h3>References</h3>

<p>There are no references for Rd macro <code style="white-space: pre;">&#8288;\insertAllCites&#8288;</code> on this help page.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># this creates a fictious time series at 100 time points obtained in two conditions:
dta &lt;- GRD( WSFactors = "timepoints (50) : condition(2)", 
    SubjectsPerGroup = 20,
    RenameDV = "activation",
    Effects = list("timepoints" = extent(5), "condition" = extent(3) ),
    Population=list(mean=50,stddev=10,rho=0.75)
)

# This will make a plot with error band
superbPlot(dta, 
   WSFactors   = c("timepoints(50)", "condition(2)"),
   variables = colnames(dta)[2:101],   ## all the names of the dataframe except "id"
   adjustments = list(
        purpose       = "single",
        decorrelation = "CM"        ## or none for no decorrelation
   ),
   plotStyle="lineBand",            # note the uppercase B 
   pointParams = list(size= 1)      # making points smaller has better look
)

# if you extract the data with superbData, you can 
# run this layout directly
#processedData &lt;- superbData(dta, 
#   WSFactors   = c("timepoints(100)", "condition(2)"), variables = colnames(dta)[2:201],
#   adjustments = list(
#        purpose       = "single",
#        decorrelation = "CM"        ## or none for no decorrelation
#   )
#)
#
#superbPlot.lineBand(processedData$summaryStatistic,
#   "timepoints",
#   "condition",
#   ".~.",
#   processedData$rawData)

</code></pre>

<hr>
<h2 id='superbPlot.point'>superbPlot 'point' layout</h2><span id='topic+superbPlot.point'></span>

<h3>Description</h3>

<p>superbPlot comes with a few built-in templates for making the final plots.
All produces ggplot objects that can be further customized. Additionally, it is
possible to add custom-make templates (see vignette 6). The functions, to be
&quot;superbPlot-compatible&quot;, must have these parameters:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>superbPlot.point(
  summarydata,
  xfactor,
  groupingfactor,
  addfactors,
  rawdata = NULL,
  pointParams = list(),
  errorbarParams = list(),
  facetParams = list(),
  xAsFactor = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="superbPlot.point_+3A_summarydata">summarydata</code></td>
<td>
<p>a data.frame with columns &quot;center&quot;, &quot;lowerwidth&quot; and &quot;upperwidth&quot; for each level of the factors;</p>
</td></tr>
<tr><td><code id="superbPlot.point_+3A_xfactor">xfactor</code></td>
<td>
<p>a string with the name of the column where the factor going on the horizontal axis is given;</p>
</td></tr>
<tr><td><code id="superbPlot.point_+3A_groupingfactor">groupingfactor</code></td>
<td>
<p>a string with the name of the column for which the data will be grouped on the plot;</p>
</td></tr>
<tr><td><code id="superbPlot.point_+3A_addfactors">addfactors</code></td>
<td>
<p>a string with up to two additional factors to make the rows and columns panels, in the form &quot;fact1 ~ fact2&quot;;</p>
</td></tr>
<tr><td><code id="superbPlot.point_+3A_rawdata">rawdata</code></td>
<td>
<p>always contains &quot;DV&quot; for each participants and each level of the factors</p>
</td></tr>
<tr><td><code id="superbPlot.point_+3A_pointparams">pointParams</code></td>
<td>
<p>(optional) list of graphic directives that are sent to the geom_bar layer</p>
</td></tr>
<tr><td><code id="superbPlot.point_+3A_errorbarparams">errorbarParams</code></td>
<td>
<p>(optional) list of graphic directives that are sent to the geom_superberrorbar layer</p>
</td></tr>
<tr><td><code id="superbPlot.point_+3A_facetparams">facetParams</code></td>
<td>
<p>(optional) list of graphic directives that are sent to the facet_grid layer</p>
</td></tr>
<tr><td><code id="superbPlot.point_+3A_xasfactor">xAsFactor</code></td>
<td>
<p>(optional) Boolean to indicate if the factor on the horizontal should continuous or discrete (default is discrete)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This will make a plot with points
superbPlot(ToothGrowth, 
   BSFactors = c("dose","supp"), variables = "len",
   plotStyle = "point" 
)

# if you extract the data with superbData, you can 
# run this layout directly
#processedData &lt;- superbData(ToothGrowth, 
# BSFactors = c("dose","supp"), variables = "len"
#)
#
#superbPlot.point(processedData$summaryStatistic,
#   "dose",
#   "supp",
#   ".~.",
#   processedData$rawData)

</code></pre>

<hr>
<h2 id='superbPlot.pointindividualline'>superbPlot point and individual-line layout for within-subject design</h2><span id='topic+superbPlot.pointindividualline'></span>

<h3>Description</h3>

<p>superbPlot comes with a few built-in templates for making the final plots.
All produces ggplot objects that can be further customized. Additionally, it is
possible to add custom-make templates (see vignette 6). The functions, to be
&quot;superbPlot-compatible&quot;, must have these parameters:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>superbPlot.pointindividualline(
  summarydata,
  xfactor,
  groupingfactor,
  addfactors,
  rawdata,
  pointParams = list(),
  lineParams = list(),
  errorbarParams = list(),
  facetParams = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="superbPlot.pointindividualline_+3A_summarydata">summarydata</code></td>
<td>
<p>a data.frame with columns &quot;center&quot;, &quot;lowerwidth&quot; and &quot;upperwidth&quot; for each level of the factors;</p>
</td></tr>
<tr><td><code id="superbPlot.pointindividualline_+3A_xfactor">xfactor</code></td>
<td>
<p>a string with the name of the column where the factor going on the horizontal axis is given;</p>
</td></tr>
<tr><td><code id="superbPlot.pointindividualline_+3A_groupingfactor">groupingfactor</code></td>
<td>
<p>a string with the name of the column for which the data will be grouped on the plot;</p>
</td></tr>
<tr><td><code id="superbPlot.pointindividualline_+3A_addfactors">addfactors</code></td>
<td>
<p>a string with up to two additional factors to make the rows and columns panels, in the form &quot;fact1 ~ fact2&quot;;</p>
</td></tr>
<tr><td><code id="superbPlot.pointindividualline_+3A_rawdata">rawdata</code></td>
<td>
<p>always contains &quot;DV&quot; for each participants and each level of the factors</p>
</td></tr>
<tr><td><code id="superbPlot.pointindividualline_+3A_pointparams">pointParams</code></td>
<td>
<p>(optional) list of graphic directives that are sent to the geom_bar layer</p>
</td></tr>
<tr><td><code id="superbPlot.pointindividualline_+3A_lineparams">lineParams</code></td>
<td>
<p>(optional) list of graphic directives that are sent to the geom_bar layer</p>
</td></tr>
<tr><td><code id="superbPlot.pointindividualline_+3A_errorbarparams">errorbarParams</code></td>
<td>
<p>(optional) list of graphic directives that are sent to the geom_superberrorbar layer</p>
</td></tr>
<tr><td><code id="superbPlot.pointindividualline_+3A_facetparams">facetParams</code></td>
<td>
<p>(optional) list of graphic directives that are sent to the facet_grid layer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This will make a plot with points and individual lines for each subject's scores
library(lsr)

# we take the Orange built-in data.frame which has a within-subject design
names(Orange) &lt;- c("Tree","age","circ")
# turn the data into a wide format
Orange.wide &lt;- longToWide(Orange, circ ~ age)
# the identifier to each tree must be in a column called id
Orange.wide$id = Orange.wide$Tree

# Makes the plots two different way:
superbPlot( Orange.wide, WSFactors = "age(7)",
  variables = c("circ_118","circ_484","circ_664","circ_1004","circ_1231","circ_1372","circ_1582"),
  adjustments = list(purpose = "difference", decorrelation = "none"),
  plotStyle= "pointindividualline"
)

# if you extract the data with superbData, you can 
# run this layout directly
#processedData &lt;- superbData(Orange.wide, WSFactors = "age(7)",
#  variables = c("circ_118","circ_484","circ_664","circ_1004","circ_1231","circ_1372","circ_1582"),
#  adjustments = list(purpose = "difference", decorrelation = "none"),
#)
#
#superbPlot.pointindividualline(processedData$summaryStatistic,
#   "age",
#   NULL,
#   ".~.",
#   processedData$rawData)

</code></pre>

<hr>
<h2 id='superbPlot.pointjitter'>superbPlot point-and-jitter dots layout</h2><span id='topic+superbPlot.pointjitter'></span>

<h3>Description</h3>

<p>superbPlot comes with a few built-in templates for making the final plots.
All produces ggplot objects that can be further customized. Additionally, it is
possible to add custom-make templates (see vignette 6). The functions, to be
&quot;superbPlot-compatible&quot;, must have these parameters:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>superbPlot.pointjitter(
  summarydata,
  xfactor,
  groupingfactor,
  addfactors,
  rawdata,
  pointParams = list(),
  jitterParams = list(),
  errorbarParams = list(),
  facetParams = list(),
  xAsFactor = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="superbPlot.pointjitter_+3A_summarydata">summarydata</code></td>
<td>
<p>a data.frame with columns &quot;center&quot;, &quot;lowerwidth&quot; and &quot;upperwidth&quot; for each level of the factors;</p>
</td></tr>
<tr><td><code id="superbPlot.pointjitter_+3A_xfactor">xfactor</code></td>
<td>
<p>a string with the name of the column where the factor going on the horizontal axis is given;</p>
</td></tr>
<tr><td><code id="superbPlot.pointjitter_+3A_groupingfactor">groupingfactor</code></td>
<td>
<p>a string with the name of the column for which the data will be grouped on the plot;</p>
</td></tr>
<tr><td><code id="superbPlot.pointjitter_+3A_addfactors">addfactors</code></td>
<td>
<p>a string with up to two additional factors to make the rows and columns panels, in the form &quot;fact1 ~ fact2&quot;;</p>
</td></tr>
<tr><td><code id="superbPlot.pointjitter_+3A_rawdata">rawdata</code></td>
<td>
<p>always contains &quot;DV&quot; for each participants and each level of the factors</p>
</td></tr>
<tr><td><code id="superbPlot.pointjitter_+3A_pointparams">pointParams</code></td>
<td>
<p>(optional) list of graphic directives that are sent to the geom_bar layer</p>
</td></tr>
<tr><td><code id="superbPlot.pointjitter_+3A_jitterparams">jitterParams</code></td>
<td>
<p>(optional) list of graphic directives that are sent to the geom_bar layer</p>
</td></tr>
<tr><td><code id="superbPlot.pointjitter_+3A_errorbarparams">errorbarParams</code></td>
<td>
<p>(optional) list of graphic directives that are sent to the geom_superberrorbar layer</p>
</td></tr>
<tr><td><code id="superbPlot.pointjitter_+3A_facetparams">facetParams</code></td>
<td>
<p>(optional) list of graphic directives that are sent to the facet_grid layer</p>
</td></tr>
<tr><td><code id="superbPlot.pointjitter_+3A_xasfactor">xAsFactor</code></td>
<td>
<p>(optional) Boolean to indicate if the factor on the horizontal should continuous or discrete (default is discrete)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This will make a plot with jittered points, aka dot plots
superbPlot(ToothGrowth, 
   BSFactors = c("dose","supp"), variables = "len",
   plotStyle="pointjitter" 
)

# if you extract the data with superbData, you can 
# run this layout directly
#processedData &lt;- superbData(ToothGrowth, 
#   BSFactors = c("dose","supp"), variables = "len"
#)
#
#superbPlot.pointjitter(processedData$summaryStatistic,
#   "dose",
#   "supp",
#   ".~.",
#   processedData$rawData)

</code></pre>

<hr>
<h2 id='superbPlot.pointjitterviolin'>superbPlot point, jitter and violin plot layout</h2><span id='topic+superbPlot.pointjitterviolin'></span>

<h3>Description</h3>

<p>superbPlot comes with a few built-in templates for making the final plots.
All produces ggplot objects that can be further customized. Additionally, it is
possible to add custom-make templates (see vignette 6). The functions, to be
&quot;superbPlot-compatible&quot;, must have these parameters:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>superbPlot.pointjitterviolin(
  summarydata,
  xfactor,
  groupingfactor,
  addfactors,
  rawdata,
  pointParams = list(),
  jitterParams = list(),
  violinParams = list(),
  errorbarParams = list(),
  facetParams = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="superbPlot.pointjitterviolin_+3A_summarydata">summarydata</code></td>
<td>
<p>a data.frame with columns &quot;center&quot;, &quot;lowerwidth&quot; and &quot;upperwidth&quot; for each level of the factors;</p>
</td></tr>
<tr><td><code id="superbPlot.pointjitterviolin_+3A_xfactor">xfactor</code></td>
<td>
<p>a string with the name of the column where the factor going on the horizontal axis is given;</p>
</td></tr>
<tr><td><code id="superbPlot.pointjitterviolin_+3A_groupingfactor">groupingfactor</code></td>
<td>
<p>a string with the name of the column for which the data will be grouped on the plot;</p>
</td></tr>
<tr><td><code id="superbPlot.pointjitterviolin_+3A_addfactors">addfactors</code></td>
<td>
<p>a string with up to two additional factors to make the rows and columns panels, in the form &quot;fact1 ~ fact2&quot;;</p>
</td></tr>
<tr><td><code id="superbPlot.pointjitterviolin_+3A_rawdata">rawdata</code></td>
<td>
<p>always contains &quot;DV&quot; for each participants and each level of the factors</p>
</td></tr>
<tr><td><code id="superbPlot.pointjitterviolin_+3A_pointparams">pointParams</code></td>
<td>
<p>(optional) list of graphic directives that are sent to the geom_bar layer</p>
</td></tr>
<tr><td><code id="superbPlot.pointjitterviolin_+3A_jitterparams">jitterParams</code></td>
<td>
<p>(optional) list of graphic directives that are sent to the geom_bar layer</p>
</td></tr>
<tr><td><code id="superbPlot.pointjitterviolin_+3A_violinparams">violinParams</code></td>
<td>
<p>(optional) list of graphic directives that are sent to the geom_bar layer</p>
</td></tr>
<tr><td><code id="superbPlot.pointjitterviolin_+3A_errorbarparams">errorbarParams</code></td>
<td>
<p>(optional) list of graphic directives that are sent to the geom_superberrorbar layer</p>
</td></tr>
<tr><td><code id="superbPlot.pointjitterviolin_+3A_facetparams">facetParams</code></td>
<td>
<p>(optional) list of graphic directives that are sent to the facet_grid layer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This will make a plot with jittered points and violins for the overall distribution
superbPlot(ToothGrowth, 
   BSFactors = c("dose","supp"), variables = "len",
   plotStyle = "pointjitterviolin" 
)

# if you extract the data with superbData, you can 
# run this layout directly
#processedData &lt;- superbData(ToothGrowth, 
#   BSFactors = c("dose","supp"), variables = "len"
#)
#
#superbPlot.pointjitterviolin(processedData$summaryStatistic,
#   "dose",
#   "supp",
#   ".~.",
#   processedData$rawData)

</code></pre>

<hr>
<h2 id='superbPlot.raincloud'>superbPlot 'raincloud' layout</h2><span id='topic+superbPlot.raincloud'></span>

<h3>Description</h3>

<p>The raincloud layout display jittered dots as well as a &quot;cloud&quot; (half of a violin) above them.
See Allen, Poggiali, Whitaker, Marshall, &amp; Kievit (2018)
The functions has these parameters:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>superbPlot.raincloud(
  summarydata,
  xfactor,
  groupingfactor,
  addfactors,
  rawdata = NULL,
  violinParams = list(),
  jitterParams = list(),
  pointParams = list(),
  errorbarParams = list(),
  facetParams = list(),
  xAsFactor = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="superbPlot.raincloud_+3A_summarydata">summarydata</code></td>
<td>
<p>a data.frame with columns &quot;center&quot;, &quot;lowerwidth&quot; and &quot;upperwidth&quot; for each level of the factors;</p>
</td></tr>
<tr><td><code id="superbPlot.raincloud_+3A_xfactor">xfactor</code></td>
<td>
<p>a string with the name of the column where the factor going on the horizontal axis is given;</p>
</td></tr>
<tr><td><code id="superbPlot.raincloud_+3A_groupingfactor">groupingfactor</code></td>
<td>
<p>a string with the name of the column for which the data will be grouped on the plot;</p>
</td></tr>
<tr><td><code id="superbPlot.raincloud_+3A_addfactors">addfactors</code></td>
<td>
<p>a string with up to two additional factors to make the rows and columns panels, in the form &quot;fact1 ~ fact2&quot;;</p>
</td></tr>
<tr><td><code id="superbPlot.raincloud_+3A_rawdata">rawdata</code></td>
<td>
<p>always contains &quot;DV&quot; for each participants and each level of the factors</p>
</td></tr>
<tr><td><code id="superbPlot.raincloud_+3A_violinparams">violinParams</code></td>
<td>
<p>(optional) list of graphic directives that are sent to the geom_violin layer</p>
</td></tr>
<tr><td><code id="superbPlot.raincloud_+3A_jitterparams">jitterParams</code></td>
<td>
<p>(optional) list of graphic directives that are sent to the geom_jitter layer</p>
</td></tr>
<tr><td><code id="superbPlot.raincloud_+3A_pointparams">pointParams</code></td>
<td>
<p>(optional) list of graphic directives that are sent to the geom_point layer</p>
</td></tr>
<tr><td><code id="superbPlot.raincloud_+3A_errorbarparams">errorbarParams</code></td>
<td>
<p>(optional) list of graphic directives that are sent to the geom_superberrorbar layer</p>
</td></tr>
<tr><td><code id="superbPlot.raincloud_+3A_facetparams">facetParams</code></td>
<td>
<p>(optional) list of graphic directives that are sent to the facet_grid layer</p>
</td></tr>
<tr><td><code id="superbPlot.raincloud_+3A_xasfactor">xAsFactor</code></td>
<td>
<p>(optional) Boolean to indicate if the factor on the horizontal should continuous or discrete (default is discrete)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object
</p>


<h3>References</h3>

<p>There are no references for Rd macro <code style="white-space: pre;">&#8288;\insertAllCites&#8288;</code> on this help page.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This will make a plot with raincloud; they are better seen rotated: +coord_flip()
superbPlot(ToothGrowth, 
   BSFactors = c("dose","supp"), variables = "len",
   plotStyle="raincloud" 
)

# if you extract the data with superbData, you can 
# run this layout directly
#processedData &lt;- superbData(ToothGrowth, 
#   BSFactors = c("dose","supp"), variables = "len"
#)
#
#superbPlot.raincloud(processedData$summaryStatistic,
#   "dose",
#   "supp",
#   ".~.",
#   processedData$rawData)

</code></pre>

<hr>
<h2 id='superbShiny'>User Interface to get summary plot of any statistics with adjusted error bars.</h2><span id='topic+superbShiny'></span>

<h3>Description</h3>

<p>The function <code>suberbShiny()</code> provides a simple user interface
to plot standard error or confidence interval for various descriptive
statistics under various designs, population size and purposes,
according to the <code>suberb</code> framework. See (Cousineau et al. 2021) for more.
Also see this <a href="https://www.youtube.com/watch?v=rw_6ll5nVus/">video</a>
from (Walker 2021) for a demo using
the shinyapps.io installation accessible at
<a href="https://dcousin3.shinyapps.io/superbshiny/">dcousin3.shinyapps.io/superbshiny</a>
Limitations: it is not possible to use custom-made statistics with the
graphical user interface, nor is it possible to request an adjustment for cluster-
randomized sampling. These options are available with <code>superbPlot()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>superbShiny()
</code></pre>


<h3>Value</h3>

<p>A plot that can be cut-and-paste.
</p>


<h3>References</h3>

<p>Cousineau D, Goulet M, Harding B (2021).
&ldquo;Summary plots with adjusted error bars: The superb framework with an implementation in R.&rdquo;
<em>Advances in Methods and Practices in Psychological Science</em>, <b>4</b>, 1&ndash;18.
<a href="https://doi.org/10.1177/25152459211035109">doi:10.1177/25152459211035109</a>.<br /><br /> Walker JAL (2021).
<em>Summary plots with adjusted error bars (superb)</em>.
<a href="https://www.youtube.com/watch?v=rw_6ll5nVus">https://www.youtube.com/watch?v=rw_6ll5nVus</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Launch the user interface: 

if (interactive())
   superbShiny() 


</code></pre>

<hr>
<h2 id='superbToWide'>superbToWide: Reshape long data frame to wide, suitable for superbPlot</h2><span id='topic+superbToWide'></span>

<h3>Description</h3>

<p>The function <code>suberbToWide()</code> is an extension to Navarro's WideToLong function
with ample checks to make sure all is legit, so that the data
is suitably organized for <code>suberb</code>. See (Cousineau et al. 2021) for more.
Other techniques are available to transform long to wide, but many asked for it within <code>superb</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>superbToWide(
  data,
  id = NULL,
  BSFactors = NULL,
  WSFactors = NULL,
  variable = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="superbToWide_+3A_data">data</code></td>
<td>
<p>Dataframe in long format</p>
</td></tr>
<tr><td><code id="superbToWide_+3A_id">id</code></td>
<td>
<p>A column with unique identifiers per subject</p>
</td></tr>
<tr><td><code id="superbToWide_+3A_bsfactors">BSFactors</code></td>
<td>
<p>The name(s) of the between-subject factor(s) as string(s)</p>
</td></tr>
<tr><td><code id="superbToWide_+3A_wsfactors">WSFactors</code></td>
<td>
<p>The name(s) of the within-subject factor(s) as string(s)</p>
</td></tr>
<tr><td><code id="superbToWide_+3A_variable">variable</code></td>
<td>
<p>The dependent variable as string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A wide-format data frame ready for superbPlot() or superbData(). All other variables will be erased.
</p>


<h3>References</h3>

<p>Cousineau D, Goulet M, Harding B (2021).
&ldquo;Summary plots with adjusted error bars: The superb framework with an implementation in R.&rdquo;
<em>Advances in Methods and Practices in Psychological Science</em>, <b>4</b>, 1&ndash;18.
<a href="https://doi.org/10.1177/25152459211035109">doi:10.1177/25152459211035109</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
library(gridExtra)

# Example using the built-in dataframe Orange. 
superbToWide(Orange, id = "Tree", WSFactors = c("age"), variable = "circumference") 

# Optional: change column names to shorten "circumference" to "DV"
names(Orange) &lt;- c("Tree","age","DV")
# turn the data into a wide format
Orange.wide &lt;- superbToWide(Orange, id = "Tree", WSFactors = c("age"), variable = "DV") 

# Makes the plots two different way:
p1=superbPlot( Orange.wide, WSFactors = "age(7)",
  variables = c("DV_118","DV_484","DV_664","DV_1004","DV_1231","DV_1372","DV_1582"),
  adjustments = list(purpose = "difference", decorrelation = "none")
) + 
  xlab("Age level") + ylab("Trunk diameter (mm)") +
  coord_cartesian( ylim = c(0,250) ) + labs(title="Basic confidence intervals")

p2=superbPlot( Orange.wide, WSFactors = "age(7)",
  variables = c("DV_118","DV_484","DV_664","DV_1004","DV_1231","DV_1372","DV_1582"),
  adjustments = list(purpose = "difference", decorrelation = "CA")
) + 
  xlab("Age level") + ylab("Trunk diameter (mm)") +
  coord_cartesian( ylim = c(0,250) ) + labs(title="Decorrelated confidence intervals")
grid.arrange(p1,p2,ncol=2)


</code></pre>

<hr>
<h2 id='TMB1964r'>Data of Tulving, Mandler, &amp; Baumal, 1964 (reproduction of 2021)</h2><span id='topic+TMB1964r'></span>

<h3>Description</h3>

<p>The data comes from Bradley-Garcia and 37 others (2021). It is a near exact
replication of the original study from (Tulving et al. 1964).
</p>
<p>The design is a (7) x 4 with:  7 levels of stimulus duration (within-subject) and
4 between-subject conditions.
Additional variables included in the reproduction is the primary language of the participant
in which he/she participated (mainly francophones and anglophones;
and the gender (mainly male and female).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(TMB1964r)
</code></pre>


<h3>Format</h3>

<p>An object of class data.frame.
</p>


<h3>References</h3>

<p>Bradley-Garcia M, 37 others (2021).
&ldquo;The influence of exposure duration and context length on word recall: A replication of Tulving et al. (1964).&rdquo;
<em>The Quantitative Methods for Psychology</em>, <b>17</b>(2), r1-r9.
<a href="https://doi.org/10.20982/tqmp.17.2.r001">doi:10.20982/tqmp.17.2.r001</a>.<br /><br /> Tulving E, Mandler G, Baumal R (1964).
&ldquo;Interaction of two sources of information in tachistoscopic word recognition.&rdquo;
<em>Canadian Journal of Psychology/Revue canadienne de psychologie</em>, <b>18</b>(1), 62.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)

data(TMB1964r)

options(superb.feedback = 'none') # shut down 'warnings' and 'design' interpretation messages

# general plot ignoring covariates sex and languages with only defaults
# We illustrate correlation- and difference-adjusted 95% confidence intervals of the mean
superbPlot(TMB1964r,
    WSFactors = "T(7)",      # the within-subject factor (spanning 7 columns)
    BSFactors = "Condition", # the between-subject factor (4 levels)
    variables = c("T1","T2","T3","T4","T5","T6","T7"),
    adjustments = list(purpose="difference", decorrelation="CM"),
    plotStyle = "line"
)

# We add directives for the error bars (thick), for the points (larger) and for the lines (thick)
plt &lt;- superbPlot(TMB1964r,
    WSFactors = "T(7)",
    BSFactors = "Condition",
    variables = c("T1","T2","T3","T4","T5","T6","T7"),
    adjustments = list(purpose="difference", decorrelation="CM"),
    plotStyle = "line", 
    errorbarParams = list(width = 0.5, linewidth=1.25, position = position_dodge(.5) ),
    pointParams = list(size=2.5, position = position_dodge(.5)),
    lineParams = list(linewidth=1.25)
)
plt

# Additional directives to set manually the colors, shapes, thick marks and labels.
plt + 
scale_colour_manual( 
    labels = c("Context 0", "Context 2", "Context 4", "Context 8"), 
    values = c("blue", "black", "purple", "red")) +
scale_shape_manual( 
    labels = c("Context 0", "Context 2", "Context 4", "Context 8"), 
    values = c("circle", "triangle", "square", "plus")) +
theme_bw(base_size = 16) +
labs(x = "Exposure duration (ms)", y = "Mean of correct responses", 
    colour = "Context length\n", shape = "Context length\n" ) + 
scale_x_discrete(labels=c("1" = "16.67", "2" = "33.33",
    "3"="50.00", "4" = "66.67", "5"="83.33", "6"="100.00", "7"="116.67"))



# Exploring three factors simultaneously: T, Condition and Sex (last two between-group)
superbPlot(TMB1964r,
    WSFactors = "T(7)",
    BSFactors = c("Condition","Sex"),
    variables = c("T1","T2","T3","T4","T5","T6","T7"),
    adjustments = list(purpose="difference", decorrelation="CM"),
    plotStyle = "line", 
    errorbarParams = list(linewidth=0.15, position = position_dodge(.5) ),
    pointParams = list(size=2.5, position = position_dodge(.5)),
    lineParams = list(linewidth=0.25)
) + 
scale_colour_manual( 
    labels = c("Context 0", "Context 2", "Context 4", "Context 8"), 
    values = c("blue", "black", "purple", "red")) +
scale_shape_manual( 
    labels = c("Context 0", "Context 2", "Context 4", "Context 8"), 
    values = c("circle", "triangle", "square", "plus")) +
theme_bw(base_size = 16) +
labs(x = "Exposure duration (ms)", y = "Mean of correct responses", 
    colour = "Context length\n", shape = "Context length\n" ) + 
scale_x_discrete(labels=c("1" = "16.67", "2" = "33.33",
    "3"="50.00", "4" = "66.67", "5"="83.33", "6"="100.00", "7"="116.67"))


#only keep 2 sex and 2 languages; the remaining cases are too sparse.
mee3 &lt;- TMB1964r[(TMB1964r$Language != "I prefer not to answer")&amp;TMB1964r$Language !="Other",]

### This last example is commented as CRAN servers are too slow
#
# advanced plots are available, such as pointjitter 
# and pointjitterviolin : a plot that superimposes the distribution as a violin plot
# 
# superbPlot(mee3,
#    WSFactors = "T(7)",
#    BSFactors = c("Condition","Language"),
#    variables = c("T1","T2","T3","T4","T5","T6","T7"),
#    adjustments = list(purpose="difference", decorrelation="CM"), 
#    plotStyle = "pointjitterviolin",
#    jitterParams = list(alpha = 0.4), #near transparent jitter points
#    violinParams = list(alpha = 0.2)
#) + 
#scale_fill_manual( name = "Amount of context", 
#    labels = c("Context 0", "Context 2", "Context 4", "Context 8"), 
#    values = c("blue", "black", "purple", "red")) +
#scale_colour_manual( name = "Amount of context", 
#    labels = c("Context 0", "Context 2", "Context 4", "Context 8"), 
#    values = c("blue", "black", "purple", "red")) +
#scale_shape_manual( name = "Amount of context",
#    labels = c("Context 0", "Context 2", "Context 4", "Context 8"), 
#    values = c("circle", "triangle", "square", "cross")) +
#theme_bw(base_size = 16) +
#labs(x = "Exposure duration (ms)", y = "Mean of correct responses" )+ 
#scale_x_discrete(labels=c("1" = "16.67", "2" = "33.33",
#    "3"="50.00", "4" = "66.67", "5"="83.33", "6"="100.00", "7"="116.67"))
#


</code></pre>

<hr>
<h2 id='twoStepTransform'>two-step transform for subject centering and bias correction</h2><span id='topic+twoStepTransform'></span>

<h3>Description</h3>

<p><code>twoStepTransform</code> is a transformation that can
be applied to a matrix of data. The resulting matrix is both
subject-centered and bias corrected, a technique called
the CM technique (Baguley 2012; Cousineau 2005; Morey 2008)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>twoStepTransform(dta, variables)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="twoStepTransform_+3A_dta">dta</code></td>
<td>
<p>a data.frame containing the data in wide format;</p>
</td></tr>
<tr><td><code id="twoStepTransform_+3A_variables">variables</code></td>
<td>
<p>a vector of column names on which the transformation will be applied.
the remaining columns will be left unchanged</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame of the same form as dta with the variables transformed.
</p>
<p>This function is useful when passed to the argument <code>preprocessfct</code> of <code>superbPlot()</code>
where it performs a modification of the data matrix.
</p>


<h3>References</h3>

<p>Baguley T (2012).
&ldquo;Calculating and graphing within-subject confidence intervals for ANOVA.&rdquo;
<em>Behavior Research Methods</em>, <b>44</b>, 158 &ndash; 175.
<a href="https://doi.org/10.3758/s13428-011-0123-7">doi:10.3758/s13428-011-0123-7</a>.<br /><br /> Cousineau D (2005).
&ldquo;Confidence intervals in within-subject designs: A simpler solution to Loftus and Masson's method.&rdquo;
<em>Tutorials in Quantitative Methods for Psychology</em>, <b>1</b>, 42 &ndash; 45.
<a href="https://doi.org/10.20982/tqmp.01.1.p042">doi:10.20982/tqmp.01.1.p042</a>.<br /><br /> Morey RD (2008).
&ldquo;Confidence Intervals from Normalized Data: A correction to Cousineau (2005).&rdquo;
<em>Tutorials in Quantitative Methods for Psychology</em>, <b>4</b>, 61 &ndash; 64.
<a href="https://doi.org/10.20982/tqmp.04.2.p061">doi:10.20982/tqmp.04.2.p061</a>.
</p>

<hr>
<h2 id='WelchDegreeOfFreedom'>Welch's rectified degree of freedom</h2><span id='topic+WelchDegreeOfFreedom'></span>

<h3>Description</h3>

<p>When variance across groups are heterogeneous,
the Student <code>t</code> distribution with <code>n - 1</code> df is not the exact distribution.
However, (Welch 1947), using methods of moments, was able to find the
best-fitting <code>t</code> distribution. This distribution has degree of freedom reduced
based on the sample sizes and the variances of the group tests. The present
function returns the rectified degree of freedom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WelchDegreeOfFreedom(dta, cols, groupingcols)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WelchDegreeOfFreedom_+3A_dta">dta</code></td>
<td>
<p>A data frame containing within-subject measures, one participant per line;</p>
</td></tr>
<tr><td><code id="WelchDegreeOfFreedom_+3A_cols">cols</code></td>
<td>
<p>A vector indicating the columns containing the measures.</p>
</td></tr>
<tr><td><code id="WelchDegreeOfFreedom_+3A_groupingcols">groupingcols</code></td>
<td>
<p>A vector indicating the columns containing the groups.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>df the degrees of freedom rectified according to Welch (1947).
</p>


<h3>References</h3>

<p>Welch BL (1947).
&ldquo;The generalization of student's' problem when several different population variances are involved.&rdquo;
<em>Biometrika</em>, <b>34</b>(1/2), 28&ndash;35.
<a href="https://doi.org/10.1093/biomet/34.1-2.28">doi:10.1093/biomet/34.1-2.28</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># creates a small data frames with 4 subject's scores for 5 measures:
dta &lt;- data.frame(cbind(
        DV.1 = c(3., 6., 2., 2., 5.),
        DV.2 = c(4., 5., 4., 4., 3.),
        DV.3 = c(2., 7., 7., 8., 6.),
        DV.4 = c(6., 8., 4., 6., 5.),
        grp  = c(1., 1., 2., 2., 2.)
    ))
# performs the test (here rectified df = 1.898876)
WelchDegreeOfFreedom(dta, "DV.1","grp")

</code></pre>

<hr>
<h2 id='WinerCompoundSymmetryTest'>Winer's test of compound symmetry</h2><span id='topic+WinerCompoundSymmetryTest'></span>

<h3>Description</h3>

<p>Run a test of compound symmetry.
generates a data frame of random data suitable for analyses.
It assesses the significance of the null hypothesis that
the covariance matrix is compound symmetric.
This test is given without demonstration in
(Winer et al. 1991), p. 517.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WinerCompoundSymmetryTest(dta, cols)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WinerCompoundSymmetryTest_+3A_dta">dta</code></td>
<td>
<p>A data frame containing within-subject measures, one participant per line;</p>
</td></tr>
<tr><td><code id="WinerCompoundSymmetryTest_+3A_cols">cols</code></td>
<td>
<p>A vector indicating the columns containing the measures.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>p the p-value of the null hypothesis that the data are compound symmetric.
</p>


<h3>References</h3>

<p>Winer BJ, Brown DR, Michels KM (1991).
<em>Statistical principles in experimental design</em>.
McGraw-Hill, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># creates a small data frames with 4 subject's scores for 5 measures:
dta &lt;- data.frame(cbind(
        col1 &lt;- c(3., 6., 2., 2., 5.),
        col2 &lt;- c(4., 5., 4., 4., 3.),
        col3 &lt;- c(2., 7., 7., 8., 6.),
        col4 &lt;- c(6., 8., 4., 6., 5.)
    ))
# performs the test (here p = 0.6733)
WinerCompoundSymmetryTest(dta)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
