<!DOCTYPE html><html><head><title>Help for package mclogit</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mclogit}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dispersion'><p>Overdispersion in Multinomial Logit Models</p></a></li>
<li><a href='#electors'><p>Class, Party Position, and Electoral Choice</p></a></li>
<li><a href='#getSummary-methods'><p>'getSummary' Methods</p></a></li>
<li><a href='#mblogit'><p>Baseline-Category Logit Models for Categorical and Multinomial Responses</p></a></li>
<li><a href='#mclogit'><p>Conditional Logit Models and Mixed Conditional Logit Models</p></a></li>
<li><a href='#mclogit.control'><p>Control Parameters for the Fitting Process</p></a></li>
<li><a href='#mclogit.fit'>
<p>Internal functions used for model fit.</p></a></li>
<li><a href='#predict'><p>Predicting responses or linear parts of the baseline-category and</p>
conditional logit models</a></li>
<li><a href='#simulate.mclogit'>
<p>Simulating responses from baseline-category and conditional logit models</p></a></li>
<li><a href='#Transport'><p>Choice of Means of Transport</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multinomial Logit Models, with or without Random Effects or
Overdispersion</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-10-27</td>
</tr>
<tr>
<td>Author:</td>
<td>Martin Elff</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martin Elff &lt;mclogit@elff.eu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides estimators for multinomial logit models in their
    conditional logit and baseline logit variants, with or without random effects,
    with or without overdispersion. 
    Random effects models are estimated using the PQL technique (based on a Laplace approximation)
    or the MQL technique (based on a Solomon-Cox approximation). Estimates should be treated
    with caution if the group sizes are small.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>stats, Matrix</td>
</tr>
<tr>
<td>Imports:</td>
<td>memisc, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS, nnet</td>
</tr>
<tr>
<td>Enhances:</td>
<td>emmeans</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>Yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://mclogit.elff.eu">http://mclogit.elff.eu</a>,<a href="https://github.com/melff/mclogit/">https://github.com/melff/mclogit/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/melff/mclogit/issues">https://github.com/melff/mclogit/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-27 09:17:22 UTC; elff</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-27 10:02:37 UTC</td>
</tr>
</table>
<hr>
<h2 id='dispersion'>Overdispersion in Multinomial Logit Models</h2><span id='topic+dispersion'></span><span id='topic+dispersion.mclogit'></span>

<h3>Description</h3>

<p>The function <code>dispersion()</code> extracts the dispersion parameter
from a multinomial logit model or computes a dispersion parameter
estimate based on a given method. This dispersion parameter can
be attached to a model using <code>update()</code>. It can also given as an
argument to <code>summary()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dispersion(object,method, ...)
## S3 method for class 'mclogit'
dispersion(object,method=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dispersion_+3A_object">object</code></td>
<td>
<p>an object that inherits class <code>"mclogit"</code>.
When passed to <code>dispersion()</code>, it 
should be the result of a call of <code>mclogit()</code> of
<code>mblogit()</code>, <em>without</em> random effects.
</p>
</td></tr>
<tr><td><code id="dispersion_+3A_method">method</code></td>
<td>
<p>a character string, either <code>"Afroz"</code>,
<code>"Fletcher"</code>, <code>"Pearson"</code>, or <code>"Deviance"</code>, that
specifies the estimator of the dispersion; or
<code>NULL</code>, in which case the default estimator, <code>"Afroz"</code> 
is used. The estimators are discussed in Afroz et al. (2019).
</p>
</td></tr>
<tr><td><code id="dispersion_+3A_...">...</code></td>
<td>
<p>other arguments, ignored or passed to other methods.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Afroz, Farzana, Matt Parry, and David Fletcher. (2020).
&quot;Estimating Overdispersion in Sparse Multinomial Data.&quot;
<em>Biometrics</em> 76(3): 834-842. <a href="https://doi.org/10.1111/biom.13194">doi:10.1111/biom.13194</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MASS) # For 'housing' data

# Note that with a factor response and frequency weighted data,
# Overdispersion will be overestimated:
house.mblogit &lt;- mblogit(Sat ~ Infl + Type + Cont, weights = Freq,
                         data = housing)

dispersion(house.mblogit,method="Afroz")
dispersion(house.mblogit,method="Deviance")

summary(house.mblogit)

phi.Afroz &lt;- dispersion(house.mblogit,method="Afroz")
summary(house.mblogit, dispersion=phi.Afroz)

summary(update(house.mblogit, dispersion="Afroz"))

# In order to be able to estimate overdispersion accurately,
# data like the above (which usually comes from applying
# 'as.data.frame' to a contingency table) the model has to be
# fitted with the optional argument 'from.table=TRUE':
house.mblogit.corrected &lt;- mblogit(Sat ~ Infl + Type + Cont, weights = Freq,
                                   data = housing, from.table=TRUE,
                                   dispersion="Afroz")
# Now the estimated dispersion parameter is no longer larger than 20,
# but just bit over 1.0.
summary(house.mblogit.corrected)
</code></pre>

<hr>
<h2 id='electors'>Class, Party Position, and Electoral Choice</h2><span id='topic+electors'></span>

<h3>Description</h3>

<p>This is an artificial data set on
electoral choice as influenced by class and party positions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(electors)</code></pre>


<h3>Format</h3>

<p>A data frame containing the following variables:
</p>

<dl>
<dt>class</dt><dd><p>class position of voters</p>
</dd>
<dt>party</dt><dd><p>party that runs for election</p>
</dd>
<dt>Freq</dt><dd><p>freqency by which each party list is chosen by members of each class</p>
</dd>
<dt>time</dt><dd><p>time variable, runs from zero to one</p>
</dd>
<dt>econ.left</dt><dd><p>economic-policy &quot;leftness&quot; of each party</p>
</dd>
<dt>welfare</dt><dd><p>emphasis of welfare expansion of each party</p>
</dd>
<dt>auth</dt><dd><p>position on authoritarian issues</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(electors)

summary(mclogit(
  cbind(Freq,interaction(time,class))~econ.left+welfare+auth,
  data=electors))

summary(mclogit(
  cbind(Freq,interaction(time,class))~econ.left/class+welfare/class+auth/class,
  data=electors))

## Not run: # This takes a bit longer.
summary(mclogit(
  cbind(Freq,interaction(time,class))~econ.left/class+welfare/class+auth/class,
  random=~1|party.time,
  data=within(electors,party.time&lt;-interaction(party,time))))

summary(mclogit(
  cbind(Freq,interaction(time,class))~econ.left/(class*time)+welfare/class+auth/class,
  random=~1|party.time,
  data=within(electors,{
        party.time &lt;-interaction(party,time)
        econ.left.sq &lt;- (econ.left-mean(econ.left))^2
        })))

## End(Not run)
</code></pre>

<hr>
<h2 id='getSummary-methods'>'getSummary' Methods</h2><span id='topic+getSummary.mclogit'></span><span id='topic+getSummary.mblogit'></span><span id='topic+getSummary.mmclogit'></span><span id='topic+getSummary.mmblogit'></span>

<h3>Description</h3>

<p><code><a href="memisc.html#topic+getSummary">getSummary</a></code> methods for use by <code><a href="memisc.html#topic+mtable">mtable</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mblogit'
getSummary(obj,
            alpha=.05,
            ...)
## S3 method for class 'mclogit'
getSummary(obj,
            alpha=.05,
            rearrange=NULL,
            ...)
## S3 method for class 'mmblogit'
getSummary(obj,
            alpha=.05,
            ...)
## S3 method for class 'mmclogit'
getSummary(obj,
            alpha=.05,
            rearrange=NULL,
            ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSummary-methods_+3A_obj">obj</code></td>
<td>
<p>an object returned by <code><a href="#topic+mblogit">mblogit</a></code> or <code><a href="#topic+mclogit">mclogit</a></code></p>
</td></tr>
<tr><td><code id="getSummary-methods_+3A_alpha">alpha</code></td>
<td>
<p>level of the confidence intervals; their coverage should
be 1-alpha/2 </p>
</td></tr>
<tr><td><code id="getSummary-methods_+3A_rearrange">rearrange</code></td>
<td>
<p>an optional named list of character vectors.
Each element of the list designates a column in the table of estimates,
and each element of a character vector refers to a coefficient.
Names of list elements become column heads and names
of the character vector elements become coefficient labels.
</p>
</td></tr>
<tr><td><code id="getSummary-methods_+3A_...">...</code></td>
<td>
<p>further arguments; ignored.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
summary(classd.model &lt;- mclogit(cbind(Freq,choice.set)~
                   (econdim1.sq+nonmatdim1.sq+nonmatdim2.sq)+
                   (econdim1+nonmatdim1+nonmatdim2)+
                   (econdim1+nonmatdim1+nonmatdim2):classd,
                  data=mvoteint.classd,random=~1|mvoteint/eb,
                  subset=classd!="Farmers"))
myGetSummary.classd &lt;- function(x)getSummary.mclogit(x,rearrange=list(
        "Econ. Left/Right"=c(
                    "Squared effect"="econdim1.sq",
                    "Linear effect"="econdim1",
                    " x Intermediate/Manual worker"="econdim1:classdIntermediate",
                    " x Service class/Manual worker"="econdim1:classdService class",
                    " x Self-employed/Manual worker"="econdim1:classdSelf-employed"
                    ),
        "Lib./Auth."=c(
                    "Squared effect"="nonmatdim1.sq",
                    "Linear effect"="nonmatdim1",
                    " x Intermediate/Manual worker"="nonmatdim1:classdIntermediate",
                    " x Service class/Manual worker"="nonmatdim1:classdService class",
                    " x Self-employed/Manual worker"="nonmatdim1:classdSelf-employed"
                    ),
        "Mod./Trad."=c(
                    "Squared effect"="nonmatdim2.sq",
                    "Linear effect"="nonmatdim2",
                    " x Intermediate/Manual worker"="nonmatdim2:classdIntermediate",
                    " x Service class/Manual worker"="nonmatdim2:classdService class",
                    " x Self-employed/Manual worker"="nonmatdim2:classdSelf-employed"
                    )
        ))

library(memisc)
mtable(classd.model,getSummary=myGetSummary.classd)
# Output would look like so:
# ==================================================================================
#                                 Econ. Left/Right    Lib./Auth.       Mod./Trad.
# ----------------------------------------------------------------------------------
# Squared effect                      0.030            0.008           -0.129**
#                                    (0.081)          (0.041)          (0.047)
# Linear effect                      -0.583***        -0.038            0.137**
#                                    (0.063)          (0.041)          (0.045)
#  x Intermediate/Manual worker       0.632***        -0.029           -0.015
#                                    (0.026)          (0.020)          (0.019)
#  x Service class/Manual worker      1.158***         0.084**          0.000
#                                    (0.040)          (0.032)          (0.030)
#  x Self-employed/Manual worker      1.140***         0.363***         0.112***
#                                    (0.035)          (0.027)          (0.026)
# Var(mvoteint)                       1.080***
#                                    (0.000)
# Var(mvoteint x eb)                  0.118***
#                                    (0.000)
# ----------------------------------------------------------------------------------
# Dispersion                              1.561
# Deviance                            15007.0
# N                                  173445
# ==================================================================================

## End(Not run)
</code></pre>

<hr>
<h2 id='mblogit'>Baseline-Category Logit Models for Categorical and Multinomial Responses</h2><span id='topic+mblogit'></span><span id='topic+print.mblogit'></span><span id='topic+summary.mblogit'></span><span id='topic+print.summary.mblogit'></span><span id='topic+fitted.mblogit'></span><span id='topic+weights.mblogit'></span><span id='topic+print.mmblogit'></span><span id='topic+summary.mmblogit'></span><span id='topic+print.summary.mmblogit'></span>

<h3>Description</h3>

<p>The function <code>mblogit</code> fits baseline-category logit models for categorical
and multinomial count responses with fixed alternatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mblogit(
  formula,
  data = parent.frame(),
  random = NULL,
  catCov = c("free", "diagonal", "single"),
  subset,
  weights = NULL,
  na.action = getOption("na.action"),
  model = TRUE,
  x = FALSE,
  y = TRUE,
  contrasts = NULL,
  method = NULL,
  estimator = c("ML", "REML"),
  dispersion = FALSE,
  start = NULL,
  from.table = FALSE,
  groups = NULL,
  control = if (length(random)) mmclogit.control(...) else mclogit.control(...),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mblogit_+3A_formula">formula</code></td>
<td>
<p>the model formula. The response must be a factor or a matrix
of counts.</p>
</td></tr>
<tr><td><code id="mblogit_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object coercible
by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame) containing the variables
in the model.  If not found in <code>data</code>, the variables are taken from
<code>environment(formula)</code>, typically the environment from which
<code>glm</code> is called.</p>
</td></tr>
<tr><td><code id="mblogit_+3A_random">random</code></td>
<td>
<p>an optional formula or list of formulas that specify the
random-effects structure or NULL.</p>
</td></tr>
<tr><td><code id="mblogit_+3A_catcov">catCov</code></td>
<td>
<p>a character string that specifies optional restrictions
on the covariances of random effects between the logit equations.
&quot;free&quot; means no restrictions, &quot;diagonal&quot; means that random effects
pertinent to different categories are uncorrelated, while &quot;single&quot; means
that the random effect variances pertinent to all categories are identical.</p>
</td></tr>
<tr><td><code id="mblogit_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="mblogit_+3A_weights">weights</code></td>
<td>
<p>an optional vector of weights to be used in the fitting
process.  Should be <code>NULL</code> or a numeric vector.</p>
</td></tr>
<tr><td><code id="mblogit_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain <code>NA</code>s.  The default is set by the <code>na.action</code> setting
of <code><a href="base.html#topic+options">options</a></code>, and is <code><a href="stats.html#topic+na.fail">na.fail</a></code> if that is unset.
The &lsquo;factory-fresh&rsquo; default is <code><a href="stats.html#topic+na.omit">na.omit</a></code>.  Another
possible value is <code>NULL</code>, no action.  Value <code><a href="stats.html#topic+na.exclude">na.exclude</a></code>
can be useful.</p>
</td></tr>
<tr><td><code id="mblogit_+3A_model">model</code></td>
<td>
<p>a logical value indicating whether <em>model frame</em> should be
included as a component of the returned value.</p>
</td></tr>
<tr><td><code id="mblogit_+3A_x">x</code>, <code id="mblogit_+3A_y">y</code></td>
<td>
<p>logical values indicating whether the response vector and model
matrix used in the fitting process should be returned as components of
the returned value.</p>
</td></tr>
<tr><td><code id="mblogit_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list. See the <code>contrasts.arg</code> of
<code>model.matrix.default</code>.</p>
</td></tr>
<tr><td><code id="mblogit_+3A_method">method</code></td>
<td>
<p><code>NULL</code> or a character string, either &quot;PQL&quot; or &quot;MQL&quot;,
specifies the type of the quasilikelihood approximation to be used if a
random-effects model is to be estimated.</p>
</td></tr>
<tr><td><code id="mblogit_+3A_estimator">estimator</code></td>
<td>
<p>a character string; either &quot;ML&quot; or &quot;REML&quot;, specifies which
estimator is to be used/approximated.</p>
</td></tr>
<tr><td><code id="mblogit_+3A_dispersion">dispersion</code></td>
<td>
<p>a logical value or a character string; whether and how a
dispersion parameter should be estimated. For details see
<code><a href="#topic+dispersion">dispersion</a></code>.</p>
</td></tr>
<tr><td><code id="mblogit_+3A_start">start</code></td>
<td>
<p>an optional matrix of starting values (with as many rows
as logit equations). If the model has random effects, the matrix
should have a &quot;VarCov&quot; attribute wtih starting values for
the random effects (co-)variances. If the random effects model
is estimated with the &quot;PQL&quot; method, the starting values matrix
should also have a &quot;random.effects&quot; attribute, which should have
the same structure as the &quot;random.effects&quot; component of an object
returned by <code>mblogit()</code>.</p>
</td></tr>
<tr><td><code id="mblogit_+3A_from.table">from.table</code></td>
<td>
<p>a logical value; do the data represent a contingency table,
e.g. were created by applying <code>as.data.frame()</code> a the result of
<code>table()</code> or <code>xtabs()</code>.  This relevant only if the response is
a factor. This argument should be set to <code>TRUE</code> if the data do come
from a contingency table. Correctly setting <code>from.table=TRUE</code> in
this case, will lead to efficiency gains in computing, but more
importantly overdispersion will correctly be computed if present.</p>
</td></tr>
<tr><td><code id="mblogit_+3A_groups">groups</code></td>
<td>
<p>an optional formula that specifies groups of observations
relevant for the specification of overdispersed response counts.</p>
</td></tr>
<tr><td><code id="mblogit_+3A_control">control</code></td>
<td>
<p>a list of parameters for the fitting process.  See
<code><a href="#topic+mclogit.control">mclogit.control</a></code></p>
</td></tr>
<tr><td><code id="mblogit_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code>mclogit.control</code> or
<code>mmclogit.control</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>mblogit</code> internally rearranges the data into a
'long' format and uses <code><a href="#topic+mclogit.fit">mclogit.fit</a></code> to compute
estimates. Nevertheless, the 'user data' are unaffected.
</p>


<h3>Value</h3>

<p><code>mblogit</code> returns an object of class &quot;mblogit&quot;, which has almost
the same structure as an object of class &quot;<a href="stats.html#topic+glm">glm</a>&quot;. The
difference are the components <code>coefficients</code>, <code>residuals</code>,
<code>fitted.values</code>, <code>linear.predictors</code>, and <code>y</code>, which are
matrices with number of columns equal to the number of response
categories minus one.
</p>


<h3>References</h3>

<p>Agresti, Alan. 2002.
<em>Categorical Data Analysis.</em> 2nd ed, Hoboken, NJ: Wiley.
<a href="https://doi.org/10.1002/0471249688">doi:10.1002/0471249688</a>
</p>
<p>Breslow, N.E. and D.G. Clayton. 1993.
&quot;Approximate Inference in Generalized Linear Mixed Models&quot;.
<em>Journal of the American Statistical Association</em> 88 (421): 9-25.
<a href="https://doi.org/10.1080/01621459.1993.10594284">doi:10.1080/01621459.1993.10594284</a>
</p>


<h3>See Also</h3>

<p>The function <code><a href="nnet.html#topic+multinom">multinom</a></code> in package <span class="pkg">nnet</span> also
fits multinomial baseline-category logit models, but has a slightly less
convenient output and does not support overdispersion or random
effects. However, it provides some other options. Baseline-category logit
models are also supported by the package <span class="pkg">VGAM</span>, as well as some
reduced-rank and (semi-parametric) additive generalisations.  The package
<span class="pkg">mnlogit</span> estimates logit models in a way optimized for large numbers
of alternatives.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MASS) # For 'housing' data
library(nnet)
library(memisc)

(house.mult&lt;- multinom(Sat ~ Infl + Type + Cont, weights = Freq,
                       data = housing))


(house.mblogit &lt;- mblogit(Sat ~ Infl + Type + Cont, weights = Freq,
                         data = housing))

summary(house.mult)

summary(house.mblogit)

mtable(house.mblogit)
</code></pre>

<hr>
<h2 id='mclogit'>Conditional Logit Models and Mixed Conditional Logit Models</h2><span id='topic+mclogit'></span><span id='topic+anova.mclogit'></span><span id='topic+print.mclogit'></span><span id='topic+vcov.mclogit'></span><span id='topic+deviance.mclogit'></span><span id='topic+logLik.mclogit'></span><span id='topic+summary.mclogit'></span><span id='topic+print.summary.mclogit'></span><span id='topic+fitted.mclogit'></span><span id='topic+residuals.mclogit'></span><span id='topic+weights.mclogit'></span><span id='topic+AIC.mclogit'></span><span id='topic+BIC.mclogit'></span><span id='topic+update.mclogit'></span><span id='topic+anova.mclogit'></span><span id='topic+summary.mmclogit'></span><span id='topic+print.summary.mmclogit'></span>

<h3>Description</h3>

<p><code>mclogit</code> fits conditional logit models and mixed conditional
logit models to count data and individual choice data,
where the choice set may vary across choice occasions.
</p>
<p>Conditional logit models without random effects are fitted by
Fisher-scoring/IWLS. Models with random effects 
(mixed conditional logit models) are estimated via maximum likelihood
with a simple Laplace aproximation (aka PQL).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
mclogit(formula, data=parent.frame(), random=NULL,
        subset, weights = NULL, offset=NULL, na.action = getOption("na.action"),
        model = TRUE, x = FALSE, y = TRUE, contrasts=NULL,
        method = NULL, estimator=c("ML","REML"),
        dispersion = FALSE,
        start=NULL,
        control=if(length(random))
                    mmclogit.control(...)
                else mclogit.control(...), ...)

## S3 method for class 'mclogit'
update(object, formula., dispersion, ...)

## S3 method for class 'mclogit'
summary(object, dispersion = NULL, correlation = FALSE,
        symbolic.cor = FALSE,  ...)    
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mclogit_+3A_formula">formula</code></td>
<td>
<p>a model formula: a symbolic description of the
model to be fitted. The left-hand side should result in
a two-column matrix. The first column contains
the choice counts or choice indicators (alternative is
chosen=1, is not chosen=0). The second column contains
unique numbers for each choice set.
</p>
<p>The left-hand side can either take the form <code>cbind(choice,set)</code>
or (from version 0.9.1) <code>choice|set</code>
</p>
<p>If individual-level data is used, choice sets correspond
to individuals, if aggregated data with choice counts are used,
choice sets usually correspond to covariate classes.
</p>
<p>The right-hand of the formula contains choice predictors. It should be noted
that constants are deleted from the formula as are predictors that do not vary
within choice sets.
</p>
</td></tr>
<tr><td><code id="mclogit_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object
coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame) containing
the variables in the model.  If not found in <code>data</code>, the
variables are taken from <code>environment(formula)</code>,
typically the environment from which <code>glm</code> is called.</p>
</td></tr>
<tr><td><code id="mclogit_+3A_random">random</code></td>
<td>
<p>an optional formula or list of formulas that specify the
random-effects structure or NULL.</p>
</td></tr>
<tr><td><code id="mclogit_+3A_weights">weights</code></td>
<td>
<p>an optional vector of weights to be used in the fitting
process.  Should be <code>NULL</code> or a numeric vector.</p>
</td></tr>
<tr><td><code id="mclogit_+3A_offset">offset</code></td>
<td>
<p>an optional model offset. Currently only supported
for models without random effects.</p>
</td></tr>
<tr><td><code id="mclogit_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations
to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="mclogit_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen
when the data contain <code>NA</code>s.  The default is set by
the <code>na.action</code> setting of <code><a href="base.html#topic+options">options</a></code>, and is
<code><a href="stats.html#topic+na.fail">na.fail</a></code> if that is unset.  The &lsquo;factory-fresh&rsquo;
default is <code><a href="stats.html#topic+na.omit">na.omit</a></code>.  Another possible value is
<code>NULL</code>, no action.  Value <code><a href="stats.html#topic+na.exclude">na.exclude</a></code> can be useful.</p>
</td></tr>
<tr><td><code id="mclogit_+3A_start">start</code></td>
<td>
<p>an optional numerical vector of starting values for the
conditional logit parameters.  If the model has random effects, the
vector should have a &quot;VarCov&quot; attribute wtih starting values for the
random effects (co-)variances. If the random effects model is
estimated with the &quot;PQL&quot; method, the starting values matrix should
also have a &quot;random.effects&quot; attribute, which should have the same
structure as the &quot;random.effects&quot; component of an object returned by
<code>mblogit()</code>.  </p>
</td></tr>
<tr><td><code id="mclogit_+3A_model">model</code></td>
<td>
<p>a logical value indicating whether <em>model frame</em>
should be included as a component of the returned value.</p>
</td></tr>
<tr><td><code id="mclogit_+3A_x">x</code>, <code id="mclogit_+3A_y">y</code></td>
<td>

<p>logical values indicating whether the response vector and model
matrix used in the fitting process should be returned as components
of the returned value.
</p>
</td></tr>
<tr><td><code id="mclogit_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list. See the <code>contrasts.arg</code>
of <code>model.matrix.default</code>.</p>
</td></tr>
<tr><td><code id="mclogit_+3A_method">method</code></td>
<td>
<p><code>NULL</code> or a character string, either &quot;PQL&quot; or &quot;MQL&quot;, specifies
the type of the quasilikelihood approximation to be used if
a random-effects model is to be estimated.</p>
</td></tr>
<tr><td><code id="mclogit_+3A_estimator">estimator</code></td>
<td>
<p>a character string; either &quot;ML&quot; or &quot;REML&quot;,
specifies which estimator is to be used/approximated.</p>
</td></tr>
<tr><td><code id="mclogit_+3A_dispersion">dispersion</code></td>
<td>
<p>a real number used as dispersion parameter;
a character vector that specifies the method to compute the dispersion;
a logical value &ndash; if <code>TRUE</code> the default method
(<code>"Afroz"</code>) is used, if <code>FALSE</code>, the dispersion parameter
is set to 1, that is, no dispersion. For details see <code><a href="#topic+dispersion">dispersion</a></code>.</p>
</td></tr>
<tr><td><code id="mclogit_+3A_control">control</code></td>
<td>
<p>a list of parameters for the fitting process.
See <code><a href="#topic+mclogit.control">mclogit.control</a></code> </p>
</td></tr>
<tr><td><code id="mclogit_+3A_...">...</code></td>
<td>

<p>arguments to be passed to <code>mclogit.control</code> or <code>mmclogit.control</code>
</p>
</td></tr>
<tr><td><code id="mclogit_+3A_object">object</code></td>
<td>
<p>an object that inherits class <code>"mclogit"</code>.
When passed to <code>dispersion()</code>, it 
should be the result of a call of <code>mclogit()</code> of
<code>mblogit()</code>, <em>without</em> random effects.
</p>
</td></tr>
<tr><td><code id="mclogit_+3A_formula.">formula.</code></td>
<td>
<p>a changes to the model formula,
see <code><a href="stats.html#topic+update">update.default</a></code> and
<code><a href="stats.html#topic+update.formula">update.formula</a></code>.</p>
</td></tr>
<tr><td><code id="mclogit_+3A_correlation">correlation</code></td>
<td>
<p>logical; see <code><a href="stats.html#topic+summary.lm">summary.lm</a></code>.</p>
</td></tr>
<tr><td><code id="mclogit_+3A_symbolic.cor">symbolic.cor</code></td>
<td>
<p>logical; see <code><a href="stats.html#topic+summary.lm">summary.lm</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>mclogit</code> returns an object of class &quot;mclogit&quot;, which has almost the
same structure as an object of class &quot;<a href="stats.html#topic+glm">glm</a>&quot;.
</p>


<h3>Note</h3>

<p>Covariates that are constant within choice sets are automatically
dropped from the model formula specified by the <code>formula</code>
argument of <code>mclogit</code>.
</p>
<p>If the model contains random effects, these should
</p>

<ul>
<li><p> either vary within choice sets (e.g. the levels of a factor
that defines the choice sets should not be nested within the levels
of factor)
</p>
</li>
<li><p> or be random coefficients of covariates that vary within
choice sets. 
</p>
</li></ul>

<p>In earlier versions of the package (prior to 0.6) it will lead to a
failure of the model fitting algorithm if these conditions are not
satisfied. Since version 0.6 of the package, the function
<code>mclogit</code> will complain about such model a misspecification
explicitely.
</p>


<h3>References</h3>

<p>Agresti, Alan (2002).
<em>Categorical Data Analysis.</em> 2nd ed, Hoboken, NJ: Wiley.
<a href="https://doi.org/10.1002/0471249688">doi:10.1002/0471249688</a>
</p>
<p>Breslow, N.E. and D.G. Clayton (1993).
&quot;Approximate Inference in Generalized Linear Mixed Models&quot;.
<em>Journal of the American Statistical Association</em> 88 (421): 9-25.
<a href="https://doi.org/10.1080/01621459.1993.10594284">doi:10.1080/01621459.1993.10594284</a>
</p>
<p>Elff, Martin (2009).
&quot;Social Divisions, Party Positions, and Electoral Behaviour&quot;.
<em>Electoral Studies</em> 28(2): 297-308.
<a href="https://doi.org/10.1016/j.electstud.2009.02.002">doi:10.1016/j.electstud.2009.02.002</a>
</p>
<p>McFadden, D. (1973).
&quot;Conditionial Logit Analysis of Qualitative Choice Behavior&quot;.
Pp. 105-135 in P. Zarembka (ed.).
<em>Frontiers in Econometrics</em>.
New York: Wiley.
<a href="https://eml.berkeley.edu/reprints/mcfadden/zarembka.pdf">https://eml.berkeley.edu/reprints/mcfadden/zarembka.pdf</a>
</p>


<h3>See Also</h3>

<p>Conditional logit models are also supported by <span class="pkg">gmnl</span>, <span class="pkg">mlogit</span>, and <span class="pkg">survival</span>.
<span class="pkg">survival</span> supports conditional logit models for binary panel data and case-control studies.     
<span class="pkg">mlogit</span> and <span class="pkg">gmnl</span> treat conditional logit models from an econometric perspective.
Unlike the present package, they focus on the random utility interpretation of discrete choice models
and support generalisations of conditional logit models, such as nested logit models, that are intended
to overcome the IIA (indipendence from irrelevant alterantives) assumption. Mixed multinomial models are
also supported and estimated using simulation-based techniques. Unlike the present package,
mixed or random-effects extensions are mainly intended to fit repeated choices of the same individuals and not
aggregated choices of many individuals facing identical alternatives.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Transport)

summary(mclogit(
  cbind(resp,suburb)~distance+cost,
  data=Transport
  ))
# New syntactic sugar:
summary(mclogit(
  resp|suburb~distance+cost,
  data=Transport
  ))


## Not run:  # This takes a bit longer.
data(electors)

electors &lt;- within(electors,{
    party.time &lt;-interaction(party,time)
    time.class &lt;- interaction(time,class)
})

# Time points nested within parties
summary(mclogit(
  Freq|time.class~econ.left/class+welfare/class+auth/class,
  random=~1|party/time,
  data=electors))

# Party-level random intercepts and random slopes varying over time points
summary(mclogit(
  Freq|time.class~econ.left/class+welfare/class+auth/class,
  random=list(~1|party,~econ.left+0|time),
  data=electors))

## End(Not run)
</code></pre>

<hr>
<h2 id='mclogit.control'>Control Parameters for the Fitting Process</h2><span id='topic+mclogit.control'></span><span id='topic+mmclogit.control'></span>

<h3>Description</h3>

<p><code>mclogit.control</code> returns a list of default parameters
that control the fitting process of <code>mclogit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mclogit.control(epsilon = 1e-08,
                maxit = 25, trace=TRUE)
mmclogit.control(epsilon = 1e-08,
                 maxit = 25, trace=TRUE,
                 trace.inner=FALSE,
                 avoid.increase = FALSE,
                 break.on.increase = FALSE,
                 break.on.infinite = FALSE,
                 break.on.negative = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mclogit.control_+3A_epsilon">epsilon</code></td>
<td>
<p>positive convergence tolerance <code class="reqn">\epsilon</code>;
the iterations converge when
<code class="reqn">|dev - dev_{old}|/(|dev| + 0.1) &lt; \epsilon</code>.</p>
</td></tr>
<tr><td><code id="mclogit.control_+3A_maxit">maxit</code></td>
<td>
<p>integer giving the maximal number of IWLS or PQL iterations.</p>
</td></tr>
<tr><td><code id="mclogit.control_+3A_trace">trace</code></td>
<td>
<p>logical indicating if output should be produced for each
iteration.</p>
</td></tr>
<tr><td><code id="mclogit.control_+3A_trace.inner">trace.inner</code></td>
<td>
<p>logical; indicating if output should be produced for each
inner iteration of the PQL method.</p>
</td></tr>
<tr><td><code id="mclogit.control_+3A_avoid.increase">avoid.increase</code></td>
<td>
<p>logical; should an increase of the deviance
be avoided by step truncation?</p>
</td></tr>
<tr><td><code id="mclogit.control_+3A_break.on.increase">break.on.increase</code></td>
<td>
<p>logical; should an increase of the deviance
be avoided by stopping the algorithm?</p>
</td></tr>
<tr><td><code id="mclogit.control_+3A_break.on.infinite">break.on.infinite</code></td>
<td>
<p>logical; should an infinite deviance
stop the algorithm instead of leading to step truncation?</p>
</td></tr>
<tr><td><code id="mclogit.control_+3A_break.on.negative">break.on.negative</code></td>
<td>
<p>logical; should a negative deviance
stop the algorithm?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list.
</p>

<hr>
<h2 id='mclogit.fit'>
Internal functions used for model fit.
</h2><span id='topic+mclogit.fit'></span><span id='topic+mmclogit.fitPQLMQL'></span>

<h3>Description</h3>

<p>These functions are exported and documented for use by other packages. They are not
intended for end users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mclogit.fit(y, s, w, X,
            dispersion=FALSE,
            start = NULL, offset = NULL,
            control = mclogit.control())

mmclogit.fitPQLMQL(y, s, w, X, Z, d, 
                   start = NULL,
                   start.Phi = NULL,
                   start.b = NULL,
                   offset = NULL, method=c("PQL","MQL"),
                   estimator = c("ML","REML"),
                   control = mmclogit.control())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mclogit.fit_+3A_y">y</code></td>
<td>
<p>a response vector. Should be binary.</p>
</td></tr>
<tr><td><code id="mclogit.fit_+3A_s">s</code></td>
<td>
<p>a vector identifying individuals or covariate strata</p>
</td></tr>
<tr><td><code id="mclogit.fit_+3A_w">w</code></td>
<td>
<p>a vector with observation weights.</p>
</td></tr>
<tr><td><code id="mclogit.fit_+3A_x">X</code></td>
<td>
<p>a model matrix; required.</p>
</td></tr>
<tr><td><code id="mclogit.fit_+3A_dispersion">dispersion</code></td>
<td>
<p>a logical value or a character string; whether and how
a dispersion parameter should be estimated. For details see <code><a href="#topic+dispersion">dispersion</a></code>.</p>
</td></tr>
<tr><td><code id="mclogit.fit_+3A_z">Z</code></td>
<td>
<p>the random effects design matrix.</p>
</td></tr>
<tr><td><code id="mclogit.fit_+3A_d">d</code></td>
<td>
<p>dimension of random effects. Typically $d=1$ for random intercepts
only, $d&gt;1$ for models with random intercepts.</p>
</td></tr>
<tr><td><code id="mclogit.fit_+3A_start">start</code></td>
<td>
<p>an optional numerical vector of starting values
for the coefficients.
</p>
</td></tr>
<tr><td><code id="mclogit.fit_+3A_offset">offset</code></td>
<td>
<p>an optional model offset. Currently only supported
for models without random effects.</p>
</td></tr>
<tr><td><code id="mclogit.fit_+3A_start.phi">start.Phi</code></td>
<td>
<p>an optional matrix of strarting values for the
(co-)variance parameters.</p>
</td></tr>
<tr><td><code id="mclogit.fit_+3A_start.b">start.b</code></td>
<td>
<p>an optional list of vectors with starting values
for the random effects.</p>
</td></tr>
<tr><td><code id="mclogit.fit_+3A_method">method</code></td>
<td>
<p>a character string, either &quot;PQL&quot; or &quot;MQL&quot;, specifies
the type of the quasilikelihood approximation.</p>
</td></tr>
<tr><td><code id="mclogit.fit_+3A_estimator">estimator</code></td>
<td>
<p>a character string; either &quot;ML&quot; or &quot;REML&quot;,
specifies which estimator is to be used/approximated.</p>
</td></tr>
<tr><td><code id="mclogit.fit_+3A_control">control</code></td>
<td>
<p>a list of parameters for the fitting process.
See <code><a href="#topic+mclogit.control">mclogit.control</a></code> </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components describing the fitted model.
</p>

<hr>
<h2 id='predict'>Predicting responses or linear parts of the baseline-category and
conditional logit models</h2><span id='topic+predict.mblogit'></span><span id='topic+predict.mmblogit'></span><span id='topic+predict.mclogit'></span><span id='topic+predict.mmclogit'></span>

<h3>Description</h3>

<p>The <code>predict()</code> methods allow to obtain within-sample and
out-of-sample predictions from models
fitted with <code>mclogit()</code> and <code>mblogit()</code>.
</p>
<p>For models with random effecs fitted using the PQL-method, it is
possible to obtain responses that are conditional on the reconstructed
random effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'mblogit'
predict(object, newdata=NULL,type=c("link","response"),se.fit=FALSE, ...)
## S3 method for class 'mclogit'
predict(object, newdata=NULL,type=c("link","response"),se.fit=FALSE, ...)
## S3 method for class 'mmblogit'
predict(object, newdata=NULL,type=c("link","response"),se.fit=FALSE,
                             conditional=TRUE, ...)
## S3 method for class 'mmclogit'
predict(object, newdata=NULL,type=c("link","response"),se.fit=FALSE,
                             conditional=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_+3A_object">object</code></td>
<td>
<p>an object in class &quot;mblogit&quot;, &quot;mmblogit&quot;, &quot;mclogit&quot;, or
&quot;mmclogit&quot;</p>
</td></tr>
<tr><td><code id="predict_+3A_newdata">newdata</code></td>
<td>
<p>an optional data frame with new data</p>
</td></tr>
<tr><td><code id="predict_+3A_type">type</code></td>
<td>
<p>a character string specifying the kind of prediction</p>
</td></tr>
<tr><td><code id="predict_+3A_se.fit">se.fit</code></td>
<td>
<p>a logical value; whether predictions should be
accompanied with standard errors</p>
</td></tr>
<tr><td><code id="predict_+3A_conditional">conditional</code></td>
<td>
<p>a logical value; whether predictions should be made
conditional on the random effects (or whether they are set to zero,
i.e. their expectation). This argument is consequential only if
the &quot;mmblogit&quot; or &quot;mmclogit&quot; object was created with <code>method="PQL"</code>.</p>
</td></tr>
<tr><td><code id="predict_+3A_...">...</code></td>
<td>
<p>other arguments, ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>predict</code> methods return either a matrix (unless called with
<code>se.fit=TRUE</code>) or a list with two matrix-valued elements
<code>"fit"</code> and <code>"se.fit"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MASS)
(house.mblogit &lt;- mblogit(Sat ~ Infl + Type + Cont, 
                          data = housing,
                          weights=Freq))

head(pred.house.mblogit &lt;- predict(house.mblogit))
str(pred.house.mblogit &lt;- predict(house.mblogit,se=TRUE))

head(pred.house.mblogit &lt;- predict(house.mblogit,
                                   type="response"))
str(pred.house.mblogit &lt;- predict(house.mblogit,se=TRUE,
                                  type="response"))
 # This takes a bit longer.
data(electors)
(mcre &lt;- mclogit(
    cbind(Freq,interaction(time,class))~econ.left/class+welfare/class+auth/class,
    random=~1|party.time,
    data=within(electors,party.time&lt;-interaction(party,time))))

str(predict(mcre))
str(predict(mcre,type="response"))

str(predict(mcre,se.fit=TRUE))
str(predict(mcre,type="response",se.fit=TRUE))

</code></pre>

<hr>
<h2 id='simulate.mclogit'>
Simulating responses from baseline-category and conditional logit models
</h2><span id='topic+simulate.mclogit'></span><span id='topic+simulate.mblogit'></span><span id='topic+simulate.mmclogit'></span><span id='topic+simulate.mmblogit'></span>

<h3>Description</h3>

<p>The <code>simulate()</code> methods allow to simulate responses from models
fitted with <code>mclogit()</code> and <code>mblogit()</code>. Currently only
models <em>without</em> random effects are supported for this.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mblogit'
simulate(object, nsim = 1, seed = NULL, ...)
## S3 method for class 'mclogit'
simulate(object, nsim = 1, seed = NULL, ...)

# These methods are currently just 'stubs', causing an error
# message stating that simulation from models with random
# effects are not supported yet
## S3 method for class 'mmblogit'
simulate(object, nsim = 1, seed = NULL, ...)
## S3 method for class 'mmclogit'
simulate(object, nsim = 1, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.mclogit_+3A_object">object</code></td>
<td>
<p>an object from the relevant class</p>
</td></tr>
<tr><td><code id="simulate.mclogit_+3A_nsim">nsim</code></td>
<td>
<p>a number, specifying the number of simulated responses
for each observation.</p>
</td></tr>
<tr><td><code id="simulate.mclogit_+3A_seed">seed</code></td>
<td>
<p>an object specifying if and how the random number
generator should be initialized ('seeded'). The interpetation of
this argument follows the default method, see <code>link[stats]{simulate}</code>
</p>
</td></tr>
<tr><td><code id="simulate.mclogit_+3A_...">...</code></td>
<td>
<p>other arguments, ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of the <code><a href="stats.html#topic+simulate">simulate</a></code> method for objects
created by <code><a href="#topic+mclogit">mclogit</a></code> is a data frame with one variable for
each requested simulation run (their number is given by the
<code>nsim=</code> argument). The contents of the columns are counts (or
zero-one values), with group-wise multinomial distribution (within
choice sets) just like it is assumed for the original response.
</p>
<p>The shape of the result of the <code><a href="stats.html#topic+simulate">simulate</a></code> method
for objects created by <code><a href="#topic+mblogit">mblogit</a></code> is also a data frame.
The variables within the data frame have a mode or shape that
corresponds to the response to which the model was fitted. If the
response is a matrix of counts, then the variables in the data frame
are also matrices of counts.  If the response is a factor and
<code><a href="#topic+mblogit">mblogit</a></code> was called with an argument
<code>from.table=FALSE</code>, the variables in the data frame are factors
with the same factor levels as the response to which the model was
fitted. If instead the function was called with
<code>from.table=TRUE</code>, the variables in the data frame are counts,
which represent frequency weights that would result from applying
<code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a contingency table of simulated
frequency counts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(MASS)
(house.mblogit &lt;- mblogit(Sat ~ Infl + Type + Cont, 
                          data = housing,
                          weights=Freq,
                          from.table=TRUE))
sm &lt;- simulate(house.mblogit,nsim=7)

housing.long &lt;- housing[rep(seq.int(nrow(housing)),housing$Freq),]
(housel.mblogit &lt;- mblogit(Sat ~ Infl + Type + Cont,
                           data=housing.long))
sml &lt;- simulate(housel.mblogit,nsim=7)

housing.table &lt;- xtabs(Freq~.,data=housing)
housing.mat &lt;- memisc::to.data.frame(housing.table)
head(housing.mat)

(housem.mblogit &lt;- mblogit(cbind(Low,Medium,High) ~
                               Infl + Type + Cont,
                           data=housing.mat))
smm &lt;- simulate(housem.mblogit,nsim=7)

str(sm)
str(sml)
str(smm)

head(smm[[1]])
</code></pre>

<hr>
<h2 id='Transport'>Choice of Means of Transport</h2><span id='topic+Transport'></span>

<h3>Description</h3>

<p>This is an artificial data set on
choice of means of transport based on cost and walking distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Transport)</code></pre>


<h3>Format</h3>

<p>A data frame containing the following variables:
</p>

<dl>
<dt>transport</dt><dd><p>means of transportation that can be chosen.</p>
</dd>
<dt>suburb</dt><dd><p>identifying number for each suburb</p>
</dd>
<dt>distance</dt><dd><p>walking distance to bus or train station</p>
</dd>
<dt>cost</dt><dd><p>cost of each means of transportation</p>
</dd>
<dt>working</dt><dd><p>size of working population of each suburb</p>
</dd>
<dt>prop.true</dt><dd><p>true choice probabilities</p>
</dd>
<dt>resp</dt><dd><p>choice frequencies of means of transportation</p>
</dd>
</dl>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
