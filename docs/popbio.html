<!DOCTYPE html><html><head><title>Help for package popbio</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {popbio}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#01.Introduction'><p>Introduction to the popbio Package</p></a></li>
<li><a href='#02.Caswell'><p>Converted Matlab functions from Caswell (2001)</p></a></li>
<li><a href='#03.Morris'><p>Converted Matlab functions from Morris and Doak (2002)</p></a></li>
<li><a href='#aq.census'><p>Annual census data for Aquilegia chrysantha</p></a></li>
<li><a href='#aq.matrix'><p>Create a projection matrix for Aquilegia</p></a></li>
<li><a href='#aq.trans'><p>Annual transition data for Aquilegia chrysantha</p></a></li>
<li><a href='#betaval'><p>Generate beta-distributed random numbers</p></a></li>
<li><a href='#boot.transitions'><p>Bootstrap observed census transitions</p></a></li>
<li><a href='#calathea'><p>Projection matrices for a tropical understory herb</p></a></li>
<li><a href='#countCDFxt'><p>Count-based extinction probabilities and bootstrap confidence intervals</p></a></li>
<li><a href='#damping.ratio'><p>Damping ratio</p></a></li>
<li><a href='#eigen.analysis'><p>Eigenvalue and eigenvector analysis of a projection matrix</p></a></li>
<li><a href='#elasticity'><p>Elasticity analysis of a projection matrix</p></a></li>
<li><a href='#extCDF'><p>Count-based extinction time cumulative distribution function</p></a></li>
<li><a href='#fundamental.matrix'><p>Fundamental matrix and age-specific survival</p></a></li>
<li><a href='#generation.time'><p>Generation time</p></a></li>
<li><a href='#grizzly'><p>Population sizes of grizzly bears in Yellowstone from 1959-1997</p></a></li>
<li><a href='#head2'><p>Return the first and last part of a matrix or dataframe</p></a></li>
<li><a href='#hudcorrs'><p>Correlation matrices for Hudsonia vital rates</p></a></li>
<li><a href='#hudmxdef'><p>Matrix definition program for Hudsonia vital rates</p></a></li>
<li><a href='#hudsonia'><p>Projection matrices for mountain golden heather</p></a></li>
<li><a href='#hudvrs'><p>Best Kendall estimates of Hudsonia vital rate means and variances</p></a></li>
<li><a href='#image2'><p>Display a matrix image</p></a></li>
<li><a href='#Kendall'><p>Find the best Kendall's estimates of mean and environmental variance for</p>
beta-binomial vital rates</a></li>
<li><a href='#lambda'><p>Population growth rate</p></a></li>
<li><a href='#lnorms'><p>Generate random lognormal values for fertility rates</p></a></li>
<li><a href='#logi.hist.plot'><p>Plot logistic regression</p></a></li>
<li><a href='#LTRE'><p>Life Table Response Experiment</p></a></li>
<li><a href='#matplot2'><p>Plot a matrix</p></a></li>
<li><a href='#matrix2'><p>Square matrices</p></a></li>
<li><a href='#mean.list'><p>Mean matrix</p></a></li>
<li><a href='#monkeyflower'><p>Projection matrices for monkeyflower</p></a></li>
<li><a href='#multiresultm'><p>Incorporate demographic stochasticity into population projections</p></a></li>
<li><a href='#nematode'><p>Population densities for the sugarbeet cyst nematode</p></a></li>
<li><a href='#net.reproductive.rate'><p>Net reproductive rate</p></a></li>
<li><a href='#pfister.plot'><p>Create log-log plots of variance vs. sensitivity and CV vs. elasticity</p></a></li>
<li><a href='#pop.projection'><p>Calculate population growth rates by projection</p></a></li>
<li><a href='#projection.matrix'><p>Construct projection matrix models using transition frequency tables</p></a></li>
<li><a href='#QPmat'><p>Build a projection matrix from a time series of individuals (or densities) per stage</p></a></li>
<li><a href='#reproductive.value'><p>Reproductive value</p></a></li>
<li><a href='#resample'><p>Resample a projection matrix</p></a></li>
<li><a href='#secder'><p>Second derivatives of the dominant eigenvalue</p></a></li>
<li><a href='#sensitivity'><p>Sensitivity analysis of a projection matrix</p></a></li>
<li><a href='#splitA'><p>Split a projection matrix into separate T and F matrices</p></a></li>
<li><a href='#stable.stage'><p>Stable stage distribution</p></a></li>
<li><a href='#stage.vector.plot'><p>Plot stage vector projections</p></a></li>
<li><a href='#stoch.growth.rate'><p>Log stochastic growth rate</p></a></li>
<li><a href='#stoch.projection'><p>Project stochastic growth from a sequence of matrices</p></a></li>
<li><a href='#stoch.quasi.ext'><p>Quasi-extinction threshold</p></a></li>
<li><a href='#stoch.sens'><p>Stochastic growth rate sensitivity</p></a></li>
<li><a href='#stretchbetaval'><p>Stretched beta-distributed random numbers</p></a></li>
<li><a href='#teasel'><p>Projection matrix for teasel</p></a></li>
<li><a href='#test.census'><p>Census data for hypothetical plant</p></a></li>
<li><a href='#tortoise'><p>Projection matrices for desert tortoise</p></a></li>
<li><a href='#var2'><p>Variance matrix</p></a></li>
<li><a href='#varEst'><p>Estimate the variance of beta-binomial vital rates</p></a></li>
<li><a href='#vitalsens'><p>Vital rate sensitivities and elasticities</p></a></li>
<li><a href='#vitalsim'><p>Stochastic vital rate simulations</p></a></li>
<li><a href='#whale'><p>Projection matrix for killer whale</p></a></li>
<li><a href='#woodpecker'><p>Survirvorship data for adult and juvenile Acorn Woodpeckers</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.8</td>
</tr>
<tr>
<td>Author:</td>
<td>Chris Stubben, Brook Milligan, Patrick Nantel</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Chris Stubben &lt;chris.stubben@hci.utah.edu&gt;</td>
</tr>
<tr>
<td>Title:</td>
<td>Construction and Analysis of Matrix Population Models</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>quadprog</td>
</tr>
<tr>
<td>Description:</td>
<td>Construct and analyze projection matrix models from a demography study of marked individuals classified by age or stage. The package covers methods described in Matrix Population Models by Caswell (2001) and Quantitative Conservation Biology by Morris and Doak (2002).</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-28 23:00:28 UTC; chrisstubben</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-28 23:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='01.Introduction'>Introduction to the popbio Package</h2><span id='topic+01.Introduction'></span><span id='topic+popbio'></span>

<h3>Description</h3>

<p><code>Popbio</code> is a package for the construction and analysis of matrix
population models.   First, the package consists  of the <span class="rlang"><b>R</b></span> translation of
<code>Matlab</code> code found in Caswell (2001) or Morris and Doak
(2002).  A list of converted functions within each book can be accessed
using <code>help(Caswell)</code> and <code>help(Morris)</code> within R,  or by following
the links to  <a href="#topic+02.Caswell">02.Caswell</a> and <a href="#topic+03.Morris">03.Morris</a> from the help content pages.
</p>
<p>Second, the <code>popbio</code> package includes functions to estimate vital
rates and construct projection matrices from raw census data typically
collected in plant demography studies. In these studies, vital rates
can often be estimated directly from annual censuses of tagged
individuals using transition frequency tables.  To estimate vital
rates in animal demography using capture-recapture methods, try the
<code>Rcapture</code> or <code>mra</code> package instead.
</p>
<p>Finally, the package includes plotting methods and sample datasets
consisting of either published projection matrices or annual census
data from demography studies.  Three sample demonstrations
illustrate some of the package capabilities (<code>Caswell, fillmore
and stage.classify</code>).  A description of the package
in the Journal of Statistical Software is available at
<a href="https://www.jstatsoft.org/article/view/v022i11">https://www.jstatsoft.org/article/view/v022i11</a>.
</p>


<h3>Author(s)</h3>

<p>Chris Stubben</p>


<h3>References</h3>

<p>To cite the popbio package in publications, type
<code>citation('popbio')</code>.  For details on matrix population models, see
</p>
<p>Caswell, H. 2001. Matrix population models: Construction,
analysis, and interpretation, Second edition. Sinauer, Sunderland,
Massachusetts, USA.
</p>
<p>Morris, W. F., and D. F. Doak. 2002. Quantitative conservation
biology: Theory and practice of population viability
analysis. Sinauer, Sunderland, Massachusetts, USA.
</p>

<hr>
<h2 id='02.Caswell'>Converted Matlab functions from Caswell (2001) </h2><span id='topic+02.Caswell'></span><span id='topic+Caswell'></span>

<h3>Description</h3>

 
<p><b>Chapter 2</b>.  Age-classified matrix models
</p>

<dl>
<dt> <code><a href="#topic+pop.projection">pop.projection</a></code> </dt><dd><p> section 2.2. Projection of
population growth rates.  </p>
</dd>
</dl>

<p><b>Chapter 4</b>.  Stage-classified matrix models
</p>

<dl>
<dt> <code><a href="#topic+lambda">lambda</a></code> </dt><dd><p> section 4.4. Returns the dominant eigenvalue    </p>
</dd>
<dt> <code><a href="#topic+stable.stage">stable.stage</a></code> </dt><dd><p> section 4.5. Returns the stable
stage distribution (right eigenvector)    </p>
</dd>
<dt> <code><a href="#topic+reproductive.value">reproductive.value</a></code> </dt><dd><p> section 4.6. Returns the
reproductive value (left eigenvector)   </p>
</dd>
<dt> <code><a href="#topic+damping.ratio">damping.ratio</a></code> </dt><dd><p> section 4.7. Returns the damping
ratio </p>
</dd>
<dt> <code><a href="#topic+eigen.analysis">eigen.analysis</a></code> </dt><dd><p> section 4.8. Computes
eigenvalues and vectors, including the dominant eigenvalue , 
stable stage distribution, reproductive value, damping
ratio, sensitivities, and elasticities.  Since version 2.0, these
are now included as separate functions as well </p>
</dd>
</dl>

<p><b>Chapter 5</b>.  Events in the Life Cycle
</p>

<dl>
<dt> <code><a href="#topic+fundamental.matrix">fundamental.matrix</a></code> </dt><dd><p>section 5.3.1.
Calculate age-specific survival from a stage classified matrix
using the fundamental matrix N </p>
</dd>
<dt> <code><a href="#topic+net.reproductive.rate">net.reproductive.rate</a></code> </dt><dd><p>section 5.3.4.
Calculate the net reproductive rate of a stage classified matrix
using the dominant eigenvalue of the matrix R.  </p>
</dd>
<dt> <code><a href="#topic+generation.time">generation.time</a></code> </dt><dd><p> section 5.3.5. Calculate the
generation time of a stage-classified matrix  </p>
</dd>
</dl>

<p>Age-specific  survivorship and fertility curves in Fig 5.1 and 5.2 are
now included in <code>demo(Caswell)</code>.  
</p>
<p><b>Chapter 6</b>. Parameter estimation
</p>

<dl>
<dt> <code><a href="#topic+projection.matrix">projection.matrix</a></code> </dt><dd><p> section 6.1.1. Estimate
vital rates and construct a projection matrix using transtion
frequency tables</p>
</dd>
<dt> <code><a href="#topic+QPmat">QPmat</a></code> </dt><dd><p> section 6.2.2. Construct a projection
matrix from a time series of  individuals per stage using Wood's
quadratic programming method.  Requires <code>quadprog</code> library.</p>
</dd>
</dl>

<p><b>Chapter 9</b>.  Sensitivity analysis
</p>

<dl>
<dt> <code><a href="#topic+sensitivity">sensitivity</a></code> </dt><dd><p> section 9.1. Calculate sensitivities </p>
</dd>
<dt> <code><a href="#topic+elasticity">elasticity</a></code> </dt><dd><p> section 9.2. Calculate elasticities </p>
</dd>
<dt> <code><a href="#topic+secder">secder</a></code> </dt><dd><p> section 9.7. Second derivatives of eigenvalues </p>
</dd>
</dl>

<p><b>Chapter 10</b>.  Life Table Response Experiments
</p>

<dl>
<dt> <code><a href="#topic+LTRE">LTRE</a></code> </dt><dd><p> section 10.1 and 10.2.  Fixed designs in
LTREs.  See  <code>demo(Caswell)</code> for variance
decomposition in random design (Fig 10.10). </p>
</dd> 
</dl>

<p><b>Chapter 12</b>.  Statistical inference
</p>

<dl>
<dt> <code><a href="#topic+boot.transitions">boot.transitions</a></code> </dt><dd><p> section 12.1.4. Resample
observed census transitions in a stage-fate data frame   </p>
</dd>
<dt> <code><a href="#topic+resample">resample</a></code> </dt><dd><p> section 12.1.5.2. Resample transitions
in a projction matrix from a multinomial distribution (and fertilites from a log
normal)</p>
</dd> 
</dl>

<p><b>Chapter 14</b>.  Environmental stochasticity
</p>

<dl>
<dt> <code><a href="#topic+stoch.growth.rate">stoch.growth.rate</a></code> </dt><dd><p> section 14.3. Calculate the
log stochastic growth rate by simulation and Tuljapukar's approximation  </p>
</dd>
<dt> <code><a href="#topic+stoch.sens">stoch.sens</a></code> </dt><dd><p> section 14.4.1. Senstivity and elasticity of 
stochastic growth rate from numerical simultations </p>
</dd>
<dt> <code><a href="#topic+stoch.projection">stoch.projection</a></code> </dt><dd><p>  section 14.5.3. Project
stochastic growth from a sequence of matrices in a uniform and
nonuniform environment </p>
</dd>
</dl>

<p><b>Chapter 15</b>.  Demographic stochasticity
</p>

<dl>
<dt> <code><a href="#topic+multiresultm">multiresultm</a></code> </dt><dd><p> section 15.1.3. Incorporate
demographic stochasticity into population projections. The
example uses the <a href="#topic+whale">whale</a> dataset to create a plot like figure
15.3. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Chris Stubben</p>

<hr>
<h2 id='03.Morris'>Converted Matlab functions from Morris and Doak (2002)</h2><span id='topic+03.Morris'></span><span id='topic+Morris'></span>

<h3>Description</h3>

 
<p><b>Chapter 3</b>
</p>

<dl>
<dt> <code><a href="#topic+grizzly">grizzly</a></code> </dt><dd><p> Table 3.1. Grizzly bear population
counts.  The example includes code to calculate mean, variance and
confidence intervals using regression and other procedures </p>
</dd>
<dt> <code><a href="#topic+extCDF">extCDF</a></code> </dt><dd><p> Box 3.3. Count-based
extinction time cumulative distribution function  </p>
</dd>
<dt> <code><a href="#topic+countCDFxt">countCDFxt</a></code> </dt><dd><p> Box 3.4. Count-based
extinction probabilities with bootstrap confidence intervals </p>
</dd>
</dl>

<p><b>Chapter 7</b>
</p>

<dl>
<dt> <code><a href="#topic+stoch.projection">stoch.projection</a></code> </dt><dd><p>  Box 7.3.  Project stochastic growth from a sequence of matrices </p>
</dd>
<dt> <code><a href="#topic+stoch.growth.rate">stoch.growth.rate</a></code> </dt><dd><p> Box 7.4.  Calculate the log stochastic growth rate by Tuljapukar's approximation and by simulation   </p>
</dd>
<dt> <code><a href="#topic+stoch.quasi.ext">stoch.quasi.ext</a></code> </dt><dd><p>  Box 7.5.  Estimate quasi-extinction threshold    </p>
</dd>
</dl>

<p><b>Chapter 8</b>
</p>

<dl>
<dt> <code><a href="#topic+Kendall">Kendall</a></code> </dt><dd><p>  Box 8.2. Kendall's method to correct for sampling variation  </p>
</dd>
<dt> <code><a href="#topic+betaval">betaval</a></code> </dt><dd><p>  Box 8.3. Generate beta-distributed random numbers  </p>
</dd>
<dt> <code><a href="#topic+lnorms">lnorms</a></code> </dt><dd><p> Box 8.4.  Generate random lognormal values   </p>
</dd>
<dt> <code><a href="#topic+stretchbetaval">stretchbetaval</a></code> </dt><dd><p> Box 8.5.  Generate stretched
beta-distributed random numbers  </p>
</dd>
<dt> <code><a href="#topic+vitalsim">vitalsim</a></code> </dt><dd><p>  Box 8.10.  Calculate stochastic growth rate and extinction time CDF using
vital rates  </p>
</dd>
<dt> <code><a href="#topic+multiresultm">multiresultm</a></code> </dt><dd><p> Box 8.11.  Incorporate demographic stochasticity into population
projections </p>
</dd>
</dl>

<p><b>Chapter 9</b>
</p>

<dl>
<dt> <code><a href="#topic+vitalsens">vitalsens</a></code> </dt><dd><p>  Box 9.1. Vital rate sensitivity and
elasticity</p>
</dd>
</dl>


<hr>
<h2 id='aq.census'>Annual census data for Aquilegia chrysantha</h2><span id='topic+aq.census'></span>

<h3>Description</h3>

<p>Demography census data from <em>Aquilegia chrysantha</em> in Fillmore Canyon,
Organ Mountains, New Mexico, 1996-2003.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aq.census
</code></pre>


<h3>Format</h3>

<p>A data frame with 2853 rows on the following 8 variables:
</p>

<dl>
<dt>plot</dt><dd><p>Plot number</p>
</dd>
<dt>year</dt><dd><p>Year of census</p>
</dd>
<dt>plant</dt><dd><p>Plant id number</p>
</dd>
<dt>status</dt><dd><p>Plant status recorded in field: dead, dormant, recruit0
(with cotyledons only), recruit1, flowering or vegetative. </p>
</dd>
<dt>rose</dt><dd><p>Total number of rosettes</p>
</dd>
<dt>leaf</dt><dd><p>Total number of leaves</p>
</dd>
<dt>infl</dt><dd><p>Total number of infloresences or flowering stalks</p>
</dd>
<dt>fruits</dt><dd><p>Total number of mature fruits</p>
</dd>
</dl>



<h3>Details</h3>

<p>This sample data set includes census data from 10 of the 15 total demography
plots established in 1995.
</p>


<h3>Source</h3>

<p>Data set owners: Brook Milligan, Chris Stubben, Allan Strand
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aq.trans">aq.trans</a></code> for annual transitions with stage and fate
in same row
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head2(aq.census)
sv &lt;- table(aq.census$status, aq.census$year)
sv
stage.vector.plot(sv[-1, ], prop = FALSE)
</code></pre>

<hr>
<h2 id='aq.matrix'>Create a projection matrix for Aquilegia</h2><span id='topic+aq.matrix'></span>

<h3>Description</h3>

<p>Creates a projection matrix for <em>Aquilegia</em> from annual transition data,
assuming new seeds and seed bank seeds have an equal chance for successful
germination and equal survival rates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aq.matrix(
  trans,
  recruits,
  summary = TRUE,
  seed.survival = 0.126,
  seed.bank.size = 10000,
  seeds.per.fruit = 120,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aq.matrix_+3A_trans">trans</code></td>
<td>
<p>A data frame with transitions listing <code><a href="base.html#topic+ordered">ordered</a></code>
stages and fates and counts of mature fruits</p>
</td></tr>
<tr><td><code id="aq.matrix_+3A_recruits">recruits</code></td>
<td>
<p>The number of observed recruits in year <code>t + 1</code>.</p>
</td></tr>
<tr><td><code id="aq.matrix_+3A_summary">summary</code></td>
<td>
<p>Output projection matrix and summaries.  Otherwise output
transition table with added individual fertilities.</p>
</td></tr>
<tr><td><code id="aq.matrix_+3A_seed.survival">seed.survival</code></td>
<td>
<p>Estimated seed survival rate for both new seeds and seed
bank.  Default is 12.6 percent survival.</p>
</td></tr>
<tr><td><code id="aq.matrix_+3A_seed.bank.size">seed.bank.size</code></td>
<td>
<p>Estimated size of the seed bank.  Seed bank and new
seeds contribute to a common germinant pool with equal chance for
germination. Default is 10,000 seeds in seed bank.</p>
</td></tr>
<tr><td><code id="aq.matrix_+3A_seeds.per.fruit">seeds.per.fruit</code></td>
<td>
<p>The number of seeds produced per mature fruit.
Default is 120 seeds.</p>
</td></tr>
<tr><td><code id="aq.matrix_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="#topic+projection.matrix">projection.matrix</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Adds individual fertilites to annual transitions using a prebreeding census.
</p>


<h3>Value</h3>

<p>If summary is TRUE, a list with
</p>
<table>
<tr><td><code>recruits</code></td>
<td>
<p>total number of recruits</p>
</td></tr>
<tr><td><code>seed.survival</code></td>
<td>
<p>seed survival rate</p>
</td></tr>
<tr><td><code>seed.bank</code></td>
<td>
<p>total number of seeds in seed bank </p>
</td></tr>
<tr><td><code>seeds.from.plants</code></td>
<td>
<p> total number of new seeds just released from fruits </p>
</td></tr>
<tr><td><code>recruitment.rate</code></td>
<td>
<p> recruitment rate calculated as recruits/(seed.bank.size + seeds.from.plants)</p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>projection matrix</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>population growth rate</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>initial population vector</p>
</td></tr>
<tr><td><code>n1</code></td>
<td>
<p>final population vector</p>
</td></tr>
</table>
<p>If summary is FALSE, a data frame with individual fertilities added
to the transition data frame only.
</p>


<h3>Author(s)</h3>

<p>Chris Stubben
</p>


<h3>See Also</h3>

<p><code><a href="#topic+projection.matrix">projection.matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- subset(aq.trans, year==1996)
## number of recruits in 1997
rec &lt;- nrow(subset(aq.trans, year==1997 &amp; stage == "recruit"))
aq.matrix(x, recruits=rec)
aq.matrix(x, recruits=rec, seed.survival=.7, seed.bank=3000)

</code></pre>

<hr>
<h2 id='aq.trans'>Annual transition data for Aquilegia chrysantha</h2><span id='topic+aq.trans'></span>

<h3>Description</h3>

<p>Transition data listing stages and fates from <em>Aquilegia chrysantha</em>  in
Fillmore Canyon, Organ Mountains, New Mexico, 1996-2003.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aq.trans
</code></pre>


<h3>Format</h3>

<p>A data frame with 1637 rows on the following 9 variables:
</p>

<dl>
<dt><code>plot</code></dt><dd><p>Plot number</p>
</dd>
<dt><code>year</code></dt><dd><p>Staring year of census</p>
</dd>
<dt><code>plant</code></dt><dd><p>Plant id number</p>
</dd>
<dt><code>stage</code></dt><dd><p>Initial stage class with ordered factor
levels <code>seed</code> &lt; <code>recruit</code> &lt; <code>small</code> &lt; <code>large</code>
&lt; <code>flower</code>.</p>
</dd>
<dt><code>leaf</code></dt><dd><p>Total number of leaves</p>
</dd>
<dt><code>rose</code></dt><dd><p>Total number of rosettes</p>
</dd>
<dt><code>fruits</code></dt><dd><p>Total number of mature fruits</p>
</dd>
<dt><code>fate</code></dt><dd><p>Final stage class or fate with levels
<code>seed</code> &lt; <code>recruit</code> &lt; <code>small</code> &lt; <code>large</code> &lt;
<code>flower</code> &lt; <code>dead</code></p>
</dd>
<dt><code>rose2</code></dt><dd><p>Final number of rosettes</p>
</dd>
</dl>



<h3>Details</h3>

<p>The five stage classes include seeds in the seed bank, new recruits or
seedlings, small vegetative plants with 1 rosette, large vegetative plants
with 2 or more rosettes, and flowering plants. Stage classes were assigned to
census plants using a combination of status and size data recorded in the
field.  See <code>demo(stage.classify)</code> for more details.
</p>


<h3>Source</h3>

<p>Data set owners: Brook Milligan, Chris Stubben, Allan Strand
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aq.census">aq.census</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head2(aq.trans)
sv &lt;- table(aq.trans$stage, aq.trans$year)
addmargins(sv)
stage.vector.plot(sv[-1, ], prop = FALSE, main = "Aquilegia stage vectors")
## plot proportions with barplot
## use xpd to draw legend outside plot boundaries
op &lt;- par(mar = c(5, 4, 4, 1), xpd = TRUE)
x &lt;- barplot(prop.table(sv[-1, ], 2),
  las = 1, col = 1:4, ylim = c(0, 1),
  xaxt = "n", space = .5, xlab = "Year", ylab = "Proportion in stage class"
)
yrs &lt;- substr(colnames(sv), 3, 4)
axis(1, x, yrs)
legend(2.7, 1.25, rev(rownames(sv)[-1]), fill = 4:1, bty = "n", ncol = 2)
par(op)
</code></pre>

<hr>
<h2 id='betaval'>Generate beta-distributed random numbers</h2><span id='topic+betaval'></span>

<h3>Description</h3>

<p>Calculates a random number from a beta distribution and uses the R function
pbeta(x,vv,ww).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>betaval(mn, sdev, fx = runif(1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="betaval_+3A_mn">mn</code></td>
<td>
<p>mean rate between 0 and 1</p>
</td></tr>
<tr><td><code id="betaval_+3A_sdev">sdev</code></td>
<td>
<p>standard deviation</p>
</td></tr>
<tr><td><code id="betaval_+3A_fx">fx</code></td>
<td>
<p>cumulative distribution function, default is a random number
between 0 and 1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used by <code><a href="#topic+vitalsim">vitalsim</a></code>
</p>


<h3>Value</h3>

<p>a random beta value
</p>


<h3>Author(s)</h3>

<p>Original MATLAB code by Morris and Doak (2002: 277- 278), adapted to
R by Patrick Nantel, 20 June 2005
</p>


<h3>Source</h3>

<p>converted Matlab code from Box 8.3 in Morris and Doak (2002)
</p>


<h3>References</h3>

<p>Morris, W. F., and D. F. Doak. 2002. Quantitative conservation
biology: Theory and practice of population viability analysis. Sinauer,
Sunderland, Massachusetts, USA.
</p>


<h3>See Also</h3>

<p>Beta Distribution <code><a href="stats.html#topic+rbeta">rbeta</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>betaval(.5, sd=.05)
betaval(.5, sd=.05)
## histogram with mean=0.5 and sd=0.05
x &lt;- sapply(1:100, function(x) betaval(0.5, 0.05))
hist(x, seq(0,1,.025), col="green", ylim=c(0,25), xlab="Value",
main="Beta distribution with mean=0.5 and sd=0.05")
# generates a graph similar to Figure 8.2 A in Morris &amp; Doak (2002:264)
# a much simpler version of BetaDemo in Box 8.3
x &lt;- matrix(numeric(3*1000), nrow=3)
sd &lt;-c(.05, .25, .45)
for (i in 1:3){
  for (j in 1:1000){
    x[i,j]&lt;-betaval(.5,sd[i])
  }
}
plot(0,0,xlim=c(0,1), ylim=c(0,0.4), type='n', ylab='Frequency',
xlab='Value', main="Examples of beta distributions")
for (i in 1:3){
   h &lt;- hist(x[i,], plot=FALSE, breaks=seq(0,1,.02)  )
   lines(h$mids, h$counts/1000, type='l', col=1+i, lwd=2, lty=i)
}
legend(0.5,0.4, c("(0.50, 0.05)", "(0.50, 0.25)", "(0.50, 0.45)"),
lty=1:3, lwd=2, col=2:4, title="mean and sd")

</code></pre>

<hr>
<h2 id='boot.transitions'>Bootstrap observed census transitions</h2><span id='topic+boot.transitions'></span>

<h3>Description</h3>

<p>Calculate bootstrap distributions of population growth rates (lambda), stage
vectors, and projection matrix elements by randomly sampling with replacement
from a stage-fate data frame of observed transitions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot.transitions(transitions, iterations, by.stage.counts = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot.transitions_+3A_transitions">transitions</code></td>
<td>
<p>a stage-fate data frame with stage or age class in the
current census,  fate in the subsequent census, and one or more fertility
columns</p>
</td></tr>
<tr><td><code id="boot.transitions_+3A_iterations">iterations</code></td>
<td>
<p>Number of bootstrap iterations</p>
</td></tr>
<tr><td><code id="boot.transitions_+3A_by.stage.counts">by.stage.counts</code></td>
<td>
<p>Resample transitions with equal probability (default)
or by subsets of initial stage counts</p>
</td></tr>
<tr><td><code id="boot.transitions_+3A_...">...</code></td>
<td>
<p>additional options passed to <code><a href="#topic+projection.matrix">projection.matrix</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with 3 items
</p>
<table>
<tr><td><code>lambda</code></td>
<td>
<p>A vector containing bootstrap values for lambda</p>
</td></tr>
<tr><td><code>matrix</code></td>
<td>
<p>A matrix containing bootstrap transtion matrices with one
projection matrix per row.</p>
</td></tr>
<tr><td><code>vector</code></td>
<td>
<p>A matrix containing bootstrap stage vectors with one stage
vector per row.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Chris Stubben
</p>


<h3>References</h3>

<p>see Morris and Doak 2005 in <a href="http://esapubs.org/Archive/mono/M075/004/appendix-A.htm">http://esapubs.org/Archive/mono/M075/004/appendix-A.htm</a>
for resampling by stage class counts
</p>


<h3>See Also</h3>

<p><code><a href="#topic+projection.matrix">projection.matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create stage-fate dataframe using merge and subset
trans01 &lt;- subset(
             merge(test.census, test.census, by="plant", sort=FALSE),
                     year.x==2001 &amp; year.y==2002)
## format column and row names
trans01 &lt;- trans01[,c(1:4,6)]
colnames(trans01)[2:5] &lt;- c("year", "stage", "fruits", "fate")
rownames(trans01) &lt;- 1:nrow(trans01)
# order stage columns corresponding to matrix
trans01$stage &lt;- ordered(trans01$stage,
                                  levels = c("seedling", "vegetative", "reproductive"))
## add individual fertilities using prebreeding census with no seed bank
##  based on the proportional reproductive outputs of flowering plants
## and the total number of seedlings at the end of the projection interval
seedlings &lt;- nrow(subset(test.census, year==2002 &amp; stage=="seedling"))
trans01$seedling &lt;- trans01$fruits/sum(trans01$fruits) * seedlings
trans01
## Step by step instructions for bootstrapping dataframe
n &lt;- nrow(trans01)
n
set.seed(77)
x &lt;- sample(n, replace=TRUE)
x
bt &lt;- trans01[x,]
bt
projection.matrix(bt)
## or respample by stage class counts
 lapply(split(trans01, trans01$stage, drop=TRUE),
      function(x) x[sample(nrow(x), replace=TRUE),])
## using boot.transitions
boot.transitions(trans01, 5)
boot.transitions(trans01, 5, by.stage=TRUE)
## Aquilegia example
x &lt;- subset(aq.trans, year==1996)
# calculate lamda, seed survival and recruitment rate using aq.matrix
rec &lt;- nrow(subset(aq.trans, year==1997 &amp; stage == "recruit"))
aq.96 &lt;-  aq.matrix(x, rec)
# add  individual fertilities to data frame only
aq.96.trans &lt;- aq.matrix(x, rec, summary=FALSE)
# pass estimated transitions in aq.96 to projection matrix
aq.96.boot &lt;- boot.transitions(aq.96.trans, 200,
            add=c(1,1, aq.96$seed.survival, 2,1, aq.96$recruitment.rate) )
# calculate percentile intervals using quantile()
ci &lt;- quantile(aq.96.boot$lambda, c(0.025,0.975) )
aq.96$lambda
ci
# plot histogram
hist(aq.96.boot$lambda, col="green", xlab="Lambda",
        main=paste('Bootstrap estimates of population\ngrowth rate from 1996-1997'))
abline(v=ci, lty=3)

</code></pre>

<hr>
<h2 id='calathea'>Projection matrices for a tropical understory herb</h2><span id='topic+calathea'></span>

<h3>Description</h3>

<p>Projection matrices for a tropical understory herb (<em>Calathea
ovandensis</em>) for plots 1-4 in years 1982-1985 and the pooled matrix.
Matrices were constructed using a post-breeding census with 8 size classes:
seed, seedling, juvenile, pre-reproductive, and 4 reproductive classes
divided by leaf area.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calathea
</code></pre>


<h3>Format</h3>

<p>A list of 17 matrices ordered by plot then year, with the pooled
matrix last.
</p>


<h3>Source</h3>

<p>Table 7 in Horvitz and Schemske (1995).  The pooled matrix is from
Table 8.
</p>


<h3>References</h3>

<p>Horvitz, C.C. and D.W. Schemske. 1995. Spatiotemporal variation
in demographic transitions of a tropical understory herb: Projection matrix
analysis. Ecological Monographs 65:155-192.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>calathea
## Single matrix
calathea[[11]]
image2(calathea[[11]], text.cex = .8)
title(paste("Calathea", names(calathea[11])), line = 3)
## MEAN matrix (exclude pooled matrix)
mean(calathea[-17])
## all plot 1
calathea[1:4]
## all 1982 matrices
calathea[ grep("1982", names(calathea)) ]
# OR
# calathea[seq(1,16,4)]
# split(calathea, 1:4)[[1]]
## Growth rates -see Figure 7
x &lt;- sapply(calathea[-17], lambda)
x &lt;- matrix(x, nrow = 4, byrow = TRUE, dimnames = list(paste("plot", 1:4), 1982:1985))
x
matplot2(x, type = "b", ylab = "Growth rate", main = "Calathea growth rates")
</code></pre>

<hr>
<h2 id='countCDFxt'>Count-based extinction probabilities and bootstrap confidence intervals</h2><span id='topic+countCDFxt'></span>

<h3>Description</h3>

<p>This function takes parameters derived from population counts and calculates
the probability of extinction with bootstrap confidence intervals for a
density-independent model, using a diffusion approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countCDFxt(mu, sig2, nt, Nc, Ne, tq = nt, tmax = 50, Nboot = 500, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="countCDFxt_+3A_mu">mu</code></td>
<td>
<p>estimated value of mean mu</p>
</td></tr>
<tr><td><code id="countCDFxt_+3A_sig2">sig2</code></td>
<td>
<p>estimated value of sample variance</p>
</td></tr>
<tr><td><code id="countCDFxt_+3A_nt">nt</code></td>
<td>
<p>number of transitions in the data set</p>
</td></tr>
<tr><td><code id="countCDFxt_+3A_nc">Nc</code></td>
<td>
<p>current population size</p>
</td></tr>
<tr><td><code id="countCDFxt_+3A_ne">Ne</code></td>
<td>
<p>quasi-extinction threshold</p>
</td></tr>
<tr><td><code id="countCDFxt_+3A_tq">tq</code></td>
<td>
<p>length of the census (in years), default is number of transitions</p>
</td></tr>
<tr><td><code id="countCDFxt_+3A_tmax">tmax</code></td>
<td>
<p>latest time to calculate extinction probability, default 50</p>
</td></tr>
<tr><td><code id="countCDFxt_+3A_nboot">Nboot</code></td>
<td>
<p>number of bootstrap samples for calculating confidence intervals
for extinction probabilities, default 500)</p>
</td></tr>
<tr><td><code id="countCDFxt_+3A_plot">plot</code></td>
<td>
<p>draw extinction time CDF plot with log-scale on y-axis</p>
</td></tr>
</table>


<h3>Details</h3>

<p>converted Matlab code from  Box 3.4 in Morris and Doak (2002)
</p>


<h3>Value</h3>

<p>The function plots the cumulative probabilities of quasi-extinction
through time with 95% confidence intervals. It also returns a data frame
with the extinction time CDF for the best parameter estimates (Gbest), and
the lower and upper bootstrap confidence limits for extinction probabilites
(Glo, Gup).
</p>


<h3>Author(s)</h3>

<p>Adapted to R by Patrick Nantel, 4 May 2005, from program 'extprob'
of Morris and Doak (2002: 79-86)
</p>


<h3>References</h3>

<p>Dennis et al. 1991, Ecological Monographs 61: 115-143
</p>
<p>Morris, W. F., and D. F. Doak. 2002. Quantitative conservation
biology: Theory and practice of population viability analysis. Sinauer,
Sunderland, Massachusetts, USA.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extCDF">extCDF</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## plot like Figure 3.8 in Morris and Doak (2002).
logN &lt;- log(grizzly$N[-1]/grizzly$N[-39])
countCDFxt(mu=mean(logN), sig2=var(logN), nt=38, tq=38, Nc=99, Ne=20)

</code></pre>

<hr>
<h2 id='damping.ratio'>Damping ratio</h2><span id='topic+damping.ratio'></span>

<h3>Description</h3>

<p>Calculate the damping ratio of a projection matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>damping.ratio(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="damping.ratio_+3A_a">A</code></td>
<td>
<p>A projection matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>see section 4.7 in Caswell (2001)
</p>


<h3>Value</h3>

<p>Damping ratio
</p>


<h3>Note</h3>

<p>The damping ratio is calculated by dividing the dominant eigenvalue by
the eigenvalue with the second largest magnitude.
</p>


<h3>Author(s)</h3>

<p>Chris Stubben
</p>


<h3>References</h3>

<p>Caswell, H. 2001. Matrix population models: construction,
analysis, and interpretation, Second edition. Sinauer, Sunderland,
Massachusetts, USA.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lambda">lambda</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## whale converges slowly to stable stage distribution
matplot2(pop.projection(whale, c(1,1,1,1), 60)$stage.vectors,
prop=TRUE, legend=NA,
main=paste("whale damping ratio = ", round(damping.ratio(whale),3) ) )
# Calathea - compare to Table 12 in Horvitz and Schemske (1995)
x &lt;- sapply(calathea[-17], damping.ratio)
x &lt;- matrix(x, nrow=4, byrow=TRUE, dimnames= list(paste("plot", 1:4), 1982:1985))
x
matplot2(x, type='b', ylab="Damping ratio", main="Calathea")

</code></pre>

<hr>
<h2 id='eigen.analysis'>Eigenvalue and eigenvector analysis of a projection matrix</h2><span id='topic+eigen.analysis'></span>

<h3>Description</h3>

<p>Calculate population growth rate and other demographic parameters from a
projection matrix model using matrix algebra
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eigen.analysis(A, zero = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eigen.analysis_+3A_a">A</code></td>
<td>
<p>A projection matrix</p>
</td></tr>
<tr><td><code id="eigen.analysis_+3A_zero">zero</code></td>
<td>
<p>Set sensitivities for unobserved transitions to zero, default is FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The calculation of eigenvalues and eigenvectors partly follows Matlab code in
section 4.8.1 (p. 107) in Caswell (2001). Since <code>popbio</code> version 2.0,
each part returned by <code>eigen.analysis</code> is now inlcuded as a separate
function.
</p>


<h3>Value</h3>

<p>A list with 6 items
</p>
<table>
<tr><td><code>lambda1</code></td>
<td>
<p>dominant eigenvalue with largest real part </p>
</td></tr>
<tr><td><code>stable.stage</code></td>
<td>
<p>proportional stable stage distribution</p>
</td></tr>
<tr><td><code>sensitivities</code></td>
<td>
<p>matrix of eigenvalue sensitivities</p>
</td></tr>
<tr><td><code>elasticities</code></td>
<td>
<p>matrix of eigenvalue elasticities</p>
</td></tr>
<tr><td><code>repro.value</code></td>
<td>
<p>reproductive value scaled so v[1]=1</p>
</td></tr>
<tr><td><code>damping.ratio</code></td>
<td>
<p>damping ratio  </p>
</td></tr>
</table>


<h3>Note</h3>

<p>If matrix A is singular, then <code>eigen.analysis</code> will return
elasticities, sensitivities, and reproductive values with NAs.
</p>


<h3>Author(s)</h3>

<p>Original code by James Holland Jones, Stanford University, August 2005
</p>


<h3>References</h3>

<p>Caswell, H. 2001. Matrix population models: construction,
analysis and interpretation, Second edition. Sinauer, Sunderland,
Massachusetts, USA.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+eigen">eigen</a></code> and <code><a href="#topic+pop.projection">pop.projection</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Imprimitive matrix
A &lt;- matrix(c(0,0,2,.3,0,0,0,.6,0), nrow=3,byrow=TRUE)
A
ev &lt;- eigen(A)
ev$values
Mod(ev$values)
lmax &lt;- which.max(Re(ev$values))
lmax
Re(ev$values)[lmax]
## damping ratio is NA
eigen.analysis(A)
## cycles every 3 years
stage.vector.plot(pop.projection(A, c(1,1,1), 10)$stage.vectors)
### Teasel
a &lt;- eigen.analysis(teasel)
a
barplot(a$stable.stage, col="green", ylim=c(0,1),
  ylab="Stable stage proportion", xlab="Stage class", main="Teasel")
box()
op &lt;- par(mfrow=c(2,2))
image2(teasel, cex=.8, mar=c(0.5,3,4,1) )
title("Teasel projection matrix", line=3)
image2(a$elasticities, cex=.8, mar=c(0.5,3,4,1) )
title("Elasticity matrix", line=3)
## default is sensitivity for non-zero elements in matrix
image2(a$sensitivities, cex=.8, mar=c(0.5,3,4,1) )
title("Sensitivity matrix 1", line=3)
## use zero=FALSE to get sensitivities of all elements
image2(eigen.analysis(teasel, zero=FALSE)$sensitivities, cex=.8, mar=c(0.5,3,4,1) )
title("Sensitivity matrix 2", line=3)
par(op)

</code></pre>

<hr>
<h2 id='elasticity'>Elasticity analysis of a projection matrix</h2><span id='topic+elasticity'></span>

<h3>Description</h3>

<p>Calculate the elasticities of eigenvalues to changes in the projection matrix
elements
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elasticity(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elasticity_+3A_a">A</code></td>
<td>
<p>A projection matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>see section 9.2 in Caswell (2001)
</p>


<h3>Value</h3>

<p>An elasticity matrix
</p>


<h3>Author(s)</h3>

<p>Chris Stubben
</p>


<h3>References</h3>

<p>Caswell, H. 2001. Matrix population models: construction,
analysis, and interpretation, Second edition. Sinauer, Sunderland,
Massachusetts, USA.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sensitivity">sensitivity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>elas &lt;- elasticity(teasel)
image2(elas, mar=c(1,3.5,5,1) )
 title("Teasel elasticity matrix", line=2.5)
# Summed elasticities for teasel.
# fertility in last column, stasis P on diagonal, and growth in bottom-left triangle
c(F=sum(elas[,6]), P=sum(diag(elas)), G=sum(elas[row(elas)&gt;col(elas)]))

elas &lt;- elasticity(tortoise[["med.high"]])
image2(elas, mar=c(1,3.5,5,1),  log=FALSE)
 title("Tortoise elasticity matrix", line=2.5)
# Summed elasticities for tortoise (see example 9.4)
# fertility in top row, stasis on diagonal, and growth on subdiagonal
c(F=sum(elas[1,]), P=sum(diag(elas)), G=sum(elas[row(elas)==col(elas)+1]))

</code></pre>

<hr>
<h2 id='extCDF'>Count-based extinction time cumulative distribution function</h2><span id='topic+extCDF'></span>

<h3>Description</h3>

<p>Returns the extinction time cumulative distribution function using
parameters derived from population counts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extCDF(mu, sig2, Nc, Ne, tmax = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extCDF_+3A_mu">mu</code></td>
<td>
<p>estimated value of mean mu</p>
</td></tr>
<tr><td><code id="extCDF_+3A_sig2">sig2</code></td>
<td>
<p>estimated value of sample variance</p>
</td></tr>
<tr><td><code id="extCDF_+3A_nc">Nc</code></td>
<td>
<p>current population size</p>
</td></tr>
<tr><td><code id="extCDF_+3A_ne">Ne</code></td>
<td>
<p>quasi-extinction threshold</p>
</td></tr>
<tr><td><code id="extCDF_+3A_tmax">tmax</code></td>
<td>
<p>latest time to calculate extinction probability, default 50</p>
</td></tr>
</table>


<h3>Details</h3>

<p>converted Matlab code from Box 3.3 and equation 3.5 in Morris and Doak 2002
</p>


<h3>Value</h3>

<p>A vector with the cumulative probabilities of quasi-extinction from
t=0 to t=tmax.
</p>


<h3>Author(s)</h3>

<p>Chris Stubben
</p>


<h3>References</h3>

<p>Morris, W. F., and D. F. Doak. 2002. Quantitative conservation
biology: Theory and practice of population viability analysis. Sinauer,
Sunderland, Massachusetts, USA.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+countCDFxt">countCDFxt</a></code> for bootstrap confidence intervals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>logN &lt;- log(grizzly$N[-1]/grizzly$N[-39])
mu &lt;- mean(logN)
sig2 &lt;- var(logN)
## grizzly cdf (log scale)
ex &lt;- extCDF(mu, sig2, Nc=99, Ne=20)
plot(ex, log='y', type='l', pch=16, col="blue", yaxt='n',
xlab="Years", ylab="Quasi-extinction probability",
main="Yellowstone Grizzly bears")
pwrs &lt;- seq(-15,-5,5)
axis(2, at = 10^pwrs, labels=parse(text=paste("10^", pwrs, sep = "")), las=1)
##plot like fig 3.10  (p 90)
n &lt;- seq(20, 100, 2)
exts &lt;- numeric(length(n))
for (i in 1:length(n) ){
   ex &lt;- extCDF(mu, sig2, Nc=n[i], Ne=20)
   exts[i] &lt;- ex[50]
}
plot(n, exts, type='l', las=1,
xlab="Current population size",
ylab="Probability of quasi-extinction by year 50")

</code></pre>

<hr>
<h2 id='fundamental.matrix'>Fundamental matrix and age-specific survival</h2><span id='topic+fundamental.matrix'></span>

<h3>Description</h3>

<p>Age-specific survival calculations from stage-classified matrices.  Includes
the mean, variance and coefficient of variation (cv) of the time spent in
each stage class and the mean and variance of the time to death
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fundamental.matrix(A, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fundamental.matrix_+3A_a">A</code></td>
<td>
<p>projection matrix</p>
</td></tr>
<tr><td><code id="fundamental.matrix_+3A_...">...</code></td>
<td>
<p>additional items are passed to <code><a href="#topic+splitA">splitA</a></code> and are
used to split A into T and F matrices</p>
</td></tr>
</table>


<h3>Details</h3>

<p>see section 5.3.1 in Caswell (2001).
</p>


<h3>Value</h3>

<p>A list with 5 items
</p>
<table>
<tr><td><code>N</code></td>
<td>
<p> fundamental matrix or mean of the time spent in each stage class</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p> variance of the time spent in each stage class</p>
</td></tr>
<tr><td><code>cv</code></td>
<td>
<p> coefficient of variation (sd/mean) </p>
</td></tr>
<tr><td><code>meaneta</code></td>
<td>
<p> mean of time to death</p>
</td></tr>
<tr><td><code>vareta</code></td>
<td>
<p> variance of time to death </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Chris Stubben
</p>


<h3>References</h3>

<p>Caswell, H. 2001. Matrix population models: construction,
analysis, and interpretation, Second edition. Sinauer, Sunderland,
Massachusetts, USA.
</p>


<h3>See Also</h3>

<p>see <code><a href="#topic+generation.time">generation.time</a></code> and <code><a href="#topic+net.reproductive.rate">net.reproductive.rate</a></code>
for other age-specific traits
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fundamental.matrix(whale)

</code></pre>

<hr>
<h2 id='generation.time'>Generation time</h2><span id='topic+generation.time'></span>

<h3>Description</h3>

<p>Calculates the generation time of a stage-classified matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generation.time(A, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generation.time_+3A_a">A</code></td>
<td>
<p>projection matrix</p>
</td></tr>
<tr><td><code id="generation.time_+3A_...">...</code></td>
<td>
<p>additional items are passed to <code><a href="#topic+splitA">splitA</a></code> and are
used to split A into T and F matrices</p>
</td></tr>
</table>


<h3>Details</h3>

<p>see section 5.3.5 in Caswell (2001).
</p>


<h3>Value</h3>

<p>Generation time. If the transition matrix is singular, then NA is returned.
</p>


<h3>Author(s)</h3>

<p>Chris Stubben
</p>


<h3>References</h3>

<p>Caswell, H. 2001. Matrix population models: construction,
analysis, and interpretation, Second edition. Sinauer, Sunderland,
Massachusetts, USA.
</p>


<h3>See Also</h3>

<p>see <code><a href="#topic+fundamental.matrix">fundamental.matrix</a></code> and <code><a href="#topic+net.reproductive.rate">net.reproductive.rate</a></code>
for other age-specific traits
</p>


<h3>Examples</h3>

<pre><code class='language-R'>generation.time(whale)
## fertilities in last column
generation.time(teasel, r=1:6, c=6)
## Plot 3 from Calathea
sapply(calathea[9:12], generation.time)

</code></pre>

<hr>
<h2 id='grizzly'>Population sizes of grizzly bears in Yellowstone from 1959-1997</h2><span id='topic+grizzly'></span>

<h3>Description</h3>

<p>Estimated number of adult female grizzly bears in the Greater Yellowstone
population from 1959-1997.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grizzly
</code></pre>


<h3>Format</h3>

<p>A data frame with 39 rows on the following 2 variables.
</p>

<dl>
<dt><code>year</code></dt><dd><p> Year of census</p>
</dd>
<dt><code>N</code></dt><dd><p> Estimated number of female grizzlies</p>
</dd>
</dl>



<h3>Source</h3>

<p>Table 3.1 in Morris and Doak 2002. Original data from Eberhardt et
al. 1986 and Haroldson 1999.
</p>


<h3>References</h3>

<p>Morris, W. F., and D. F. Doak. 2002. Quantitative conservation
biology: Theory and practice of population viability analysis. Sinauer,
Sunderland, Massachusetts, USA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grizzly
## plot like Fig 3.6 (p. 66)
plot(grizzly$year, grizzly$N,
  type = "o", pch = 16, las = 1, xlab = "Year",
  ylab = "Adult females", main = "Yellowstone grizzly bears"
)
## calcualte  log(Nt+1/Nt)
nt &lt;- length(grizzly$N) ## number transitions
logN &lt;- log(grizzly$N[-1] / grizzly$N[-nt])
## Mean and var
c(mean = mean(logN), var = var(logN))
## or using linear regression
## transformation for unequal variances (p. 68)
x &lt;- sqrt(grizzly$year[-1] - grizzly$year[-length(grizzly$year)])
y &lt;- logN / x
mod &lt;- lm(y ~ 0 + x)
summary(mod)
## plot like Fig 3.7
plot(x, y,
  xlim = c(0, 1.2), ylim = c(-.3, .3), pch = 16, las = 1,
  xlab = expression(paste("Sqrt time between censuses ", (t[t + 1] - t[i])^{
    1 / 2
  })),
  ylab = expression(log(N[t + 1] / N[t]) / (t[t + 1] - t[i])^{
    1 / 2
  }),
  main = expression(paste("Estimating ", mu, " and ", sigma^2, " using regression"))
)
abline(mod)
## MEAN (slope)
mu &lt;- coef(mod)
## VAR (mean square in analysis of variance table)
sig2 &lt;- anova(mod)[["Mean Sq"]][2]
c(mean = mu, var = sig2)
## Confidence interval for mean  (page 72)
confint(mod, 1)
## Confidence interval for sigma 2  (equation 3.13)
df1 &lt;- length(logN) - 1
df1 * sig2 / qchisq(c(.975, .025), df = df1)
## test for outliers using dffits (p.74)
dffits(mod)[dffits(mod) &gt; 2 * sqrt(1 / 38) ]
## plot like  fig 3.11
plot(grizzly$N[-nt], logN,
  pch = 16, xlim = c(20, 100), ylim = c(-.3, .3), las = 1,
  xlab = "Number of females in year T",
  ylab = expression(log(N[t + 1] / N[t])),
  main = "Grizzly log population growth rates"
)
cor(grizzly$N[-nt], logN)
abline(lm(logN ~ grizzly$N[-nt]), lty = 3)
</code></pre>

<hr>
<h2 id='head2'>Return the first and last part of a matrix or dataframe</h2><span id='topic+head2'></span>

<h3>Description</h3>

<p>Returns the first and last rows using output from both <code><a href="utils.html#topic+head">head</a></code> and
<code><a href="utils.html#topic+tail">tail</a></code> and separates the two parts with dots. Useful for viewing
ordered datasets such as longitudinal census data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>head2(x, head = 3, tail = 1, dotrows = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="head2_+3A_x">x</code></td>
<td>
<p>A matrix or dataframe</p>
</td></tr>
<tr><td><code id="head2_+3A_head">head</code></td>
<td>
<p>The number of first rows</p>
</td></tr>
<tr><td><code id="head2_+3A_tail">tail</code></td>
<td>
<p>The number of last rows</p>
</td></tr>
<tr><td><code id="head2_+3A_dotrows">dotrows</code></td>
<td>
<p>The number of rows of dots</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A smaller object with first and last rows only
</p>


<h3>Author(s)</h3>

<p>Chris Stubben
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head2(aq.trans)

</code></pre>

<hr>
<h2 id='hudcorrs'>Correlation matrices for Hudsonia vital rates</h2><span id='topic+hudcorrs'></span>

<h3>Description</h3>

<p>Within year and between year correlation matrices from <em>Hudsonia
montana</em> vital rates.  Correlations were calculated from first 13 growth and
survival rates only, since fertility rates vary little.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hudcorrs
</code></pre>


<h3>Format</h3>

<p>A list with 2 correlation matrices, corrin (within year correlation)
and corrout (between year correlation).
</p>


<h3>Source</h3>

<p>The correlation matrices in Morris and Doak 2002 include some
correlations &gt; 1.  A corrected set of correlations was sent by the D. Doak on
8/4/2007.
</p>


<h3>References</h3>

<p>Morris, W. F., and D. F. Doak. 2002. Quantitative conservation
biology: Theory and practice of population viability analysis. Sinauer,
Sunderland, Massachusetts, USA.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vitalsim">vitalsim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hudcorrs
</code></pre>

<hr>
<h2 id='hudmxdef'>Matrix definition program for Hudsonia vital rates</h2><span id='topic+hudmxdef'></span>

<h3>Description</h3>

<p>Creates a projection matrix from <em>Hudsonia</em> vital rates (survival,
growth, and reproduction). Growth rates are defined as a set of binomial
choices as in Table 8.4 B in Morris and Doak (2002).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hudmxdef(vrs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hudmxdef_+3A_vrs">vrs</code></td>
<td>
<p>Vital rate means in <code><a href="#topic+hudvrs">hudvrs</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A  projection matrix
</p>


<h3>Author(s)</h3>

<p>Chris Stubben
</p>


<h3>References</h3>

<p>Morris, W. F., and D. F. Doak. 2002. Quantitative conservation
biology: Theory and practice of population viability analysis. Sinauer,
Sunderland, Massachusetts, USA.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vitalsim">vitalsim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hudmxdef(hudvrs$mean)

</code></pre>

<hr>
<h2 id='hudsonia'>Projection matrices for mountain golden heather</h2><span id='topic+hudsonia'></span>

<h3>Description</h3>

<p>Projection matrices for the mountain golden heather (<em>Hudsonia montana</em>)
for years 1985 through 1988 with 6 size classes: seeds, seedlings, and 4 size
classes divided by plant area.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hudsonia
</code></pre>


<h3>Format</h3>

<p>A list of 4 matrices from 1985-1988
</p>


<h3>Source</h3>

<p>Table 6.7 in Morris and Doak 2002.  The original data is from Frost
1990.
</p>


<h3>References</h3>

<p>Morris, W. F., and D. F. Doak. 2002. Quantitative conservation
biology: Theory and practice of population viability analysis. Sinauer,
Sunderland, Massachusetts, USA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hudsonia
sapply(hudsonia, lambda)
## mean matrix
x &lt;- mean(hudsonia)
image2(x, mar = c(1, 4, 5.5, 1))
title("Hudsonia mean matrix", line = 2.5)
lambda(x)
# variance
var2(hudsonia)
</code></pre>

<hr>
<h2 id='hudvrs'>Best Kendall estimates of Hudsonia vital rate means and variances</h2><span id='topic+hudvrs'></span>

<h3>Description</h3>

<p>Best Kendall estimates of vital rate means (9 growth, 4 survival, and 11
fertility rates) for <em>Hudsonia montana</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hudvrs
</code></pre>


<h3>Format</h3>

<p>A data frame with 24 rows and 2 columns:
</p>

<dl>
<dt><code>mean</code></dt><dd><p> vital rate means</p>
</dd>
<dt><code>var</code></dt><dd><p> vital rate variances</p>
</dd>
</dl>



<h3>Source</h3>

<p>Data  listed in Box 8.10 for the <code><a href="#topic+vitalsim">vitalsim</a></code> function.
See also Table 8.5 in Morris and Doak (2002).
</p>


<h3>References</h3>

<p>Morris, W. F., and D. F. Doak. 2002. Quantitative conservation
biology: Theory and practice of population viability analysis. Sinauer,
Sunderland, Massachusetts, USA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hudvrs
hudmxdef(hudvrs$mean)
</code></pre>

<hr>
<h2 id='image2'>Display a matrix image</h2><span id='topic+image2'></span>

<h3>Description</h3>

<p>Creates a grid of colored rectangles to display a projection, elasticity,
sensitivity or other matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>image2(
  x,
  col = c("white", rev(heat.colors(23))),
  breaks,
  log = TRUE,
  border = NA,
  box.offset = 0.1,
  round = 3,
  cex,
  text.cex = 1,
  text.col = "black",
  mar = c(1, 3, 3, 1),
  labels = 2:3,
  label.offset = 0.1,
  label.cex = 1,
  srt = 90
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image2_+3A_x">x</code></td>
<td>
<p>A numeric matrix with row and column names</p>
</td></tr>
<tr><td><code id="image2_+3A_col">col</code></td>
<td>
<p>A vector of colors for boxes</p>
</td></tr>
<tr><td><code id="image2_+3A_breaks">breaks</code></td>
<td>
<p>A numeric vector of break points or number of intervals into
which <code>x</code> is to be <code><a href="base.html#topic+cut">cut</a></code>. Default is the length of <code>col</code></p>
</td></tr>
<tr><td><code id="image2_+3A_log">log</code></td>
<td>
<p>Cut values in <code>x</code> using a log scale, default TRUE</p>
</td></tr>
<tr><td><code id="image2_+3A_border">border</code></td>
<td>
<p>The border color for boxes, default is no borders</p>
</td></tr>
<tr><td><code id="image2_+3A_box.offset">box.offset</code></td>
<td>
<p>Percent reduction in box size (a number between 0 and 1),
default is 10% reduction</p>
</td></tr>
<tr><td><code id="image2_+3A_round">round</code></td>
<td>
<p>Number of decimal places to display values of <code>x</code> in each box</p>
</td></tr>
<tr><td><code id="image2_+3A_cex">cex</code></td>
<td>
<p>Magnification size of text and labels, if specified this will
replace values in both text.cex and label.cex</p>
</td></tr>
<tr><td><code id="image2_+3A_text.cex">text.cex</code></td>
<td>
<p>Magnification size of text in cells only</p>
</td></tr>
<tr><td><code id="image2_+3A_text.col">text.col</code></td>
<td>
<p>Color of text in cells, use NA to skip text labels</p>
</td></tr>
<tr><td><code id="image2_+3A_mar">mar</code></td>
<td>
<p>Margins on four sides of plot</p>
</td></tr>
<tr><td><code id="image2_+3A_labels">labels</code></td>
<td>
<p>A vector giving sides of the plot (1=bottom, 2=left, 3=top,
4=right) for row and column labels</p>
</td></tr>
<tr><td><code id="image2_+3A_label.offset">label.offset</code></td>
<td>
<p>Amount of space between label and boxes</p>
</td></tr>
<tr><td><code id="image2_+3A_label.cex">label.cex</code></td>
<td>
<p>Magnification size of labels</p>
</td></tr>
<tr><td><code id="image2_+3A_srt">srt</code></td>
<td>
<p>String rotation for labels on top and bottom of matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A image plot of the matrix
</p>


<h3>Note</h3>

<p>#' The minimum value in <code>x</code> is usually assigned to the first color
category and the rest of the values are then cut into equally spaced
intervals.  This was added to show transitions with very low probabilities in
a new color category, eg, 2e-06 would usually be grouped with 0 using
<code><a href="Matrix.html#topic+image">image</a></code>. Note if all elements &gt; 0, then the first color will not
be used.
</p>


<h3>Author(s)</h3>

<p>Chris Stubben
</p>


<h3>See Also</h3>

<p><code><a href="Matrix.html#topic+image">image</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- calathea[[11]]
op &lt;- par(mfrow=c(2,2))
image2(A, text.cex=.8)
## with  gray border and labels on bottom right
image2( A, text.cex=.8, border="gray70", labels=c(1,4), mar=c(3,1,1,3))
## no text or box offset
image2( A, box.offset=0, text.col=NA)
# set zeros to NA to print everything but zero
A[A == 0] &lt;- NA
image2( A, box.offset=0 , text.cex=.8)
## if comparing two or more matrices, get the log10 range
## of values (not including zero) and pass to breaks
x &lt;- unlist(calathea[-17])
x &lt;- log10(range(x[x!=0]))
par(mfrow=c(4,4))
for(i in 1:16){
  A &lt;- calathea[[i]]
  A[A == 0] &lt;- NA
  image2(A, cex=.7, box.offset=0, breaks=seq(x[1], x[2], len=24))
    title(names(calathea[i]), line=3)
}
par(op)

</code></pre>

<hr>
<h2 id='Kendall'>Find the best Kendall's estimates of mean and environmental variance for
beta-binomial vital rates</h2><span id='topic+Kendall'></span>

<h3>Description</h3>

<p>Finds the best estimates of mean and environmental variance for beta-binomial
vital rates, using a brute force search for the best adjusted estimates from
a very large number of combinations of different possible mean and variance
values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Kendall(
  rates,
  grades = 1000,
  maxvar = 0.2,
  minvar = 1e-05,
  maxmean = 1,
  minmean = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Kendall_+3A_rates">rates</code></td>
<td>
<p>a matrix or dataframe with four columns: Rate identifier, Year,
Total number of starting individuals, Number growing (or surviving).</p>
</td></tr>
<tr><td><code id="Kendall_+3A_grades">grades</code></td>
<td>
<p>number of different levels of means and variances to try, default is 1000</p>
</td></tr>
<tr><td><code id="Kendall_+3A_maxvar">maxvar</code></td>
<td>
<p>maximum variance to search over, default is 0.20. The maximum
possible is 0.25 and searching a narrower range will improve the accuracy of the answer.</p>
</td></tr>
<tr><td><code id="Kendall_+3A_minvar">minvar</code></td>
<td>
<p>minimum variance to search, default is 0.00001</p>
</td></tr>
<tr><td><code id="Kendall_+3A_maxmean">maxmean</code></td>
<td>
<p>maximum limit on the mean values to search, default 1</p>
</td></tr>
<tr><td><code id="Kendall_+3A_minmean">minmean</code></td>
<td>
<p>minimum limit on the mean values to search, default 0.01</p>
</td></tr>
</table>


<h3>Details</h3>

<p>converted Matlab code from  Box 8.2 in Morris and Doak (2002)
</p>


<h3>Value</h3>

<p>A list with estimates and confidence intervals
</p>
<table>
<tr><td><code>est</code></td>
<td>
<p>a matrix with 5 columns: (1) estimated mean, (2) Kendall's MLE mean,
(3) estimated variance, (4) Kendall's MLE variance, (5) Kendall's unbiased MLE variance.</p>
</td></tr>
<tr><td><code>ci</code></td>
<td>
<p> a matrix with  95% confidence limits for the Kendall's mean and
unbiased variance estimates with 4 columns: (1) low and (3) high mean limits,
(3) low and (4) high variance limits.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>may deliver warning messages of: 'no finite arguments to min; returning Inf',
indicating use of very low values for variance, but this is not a malfunction.
</p>


<h3>Author(s)</h3>

<p>Adapted to R from Morris and Doak (2002: 267-270) by Patrick Nantel.
</p>


<h3>References</h3>

<p>Kendall, B. E. 1998. Estimating the magnitude of environmental
stochasticity  in survivorship data. Ecological Applications 8(1): 184-193.
</p>
<p>Morris, W. F., and D. F. Doak. 2002. Quantitative conservation
biology: Theory and practice of population viability analysis. Sinauer,
Sunderland, Massachusetts, USA.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+varEst">varEst</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## desert tortoise input from Box 8.2 - compare results to Table 8.3
tor &lt;- data.frame(rate=rep(c("g4","g5","g6"), each=3),
   year=rep(1:3,3),      ## representing 70s, early 80s, late 80s
   start=c(17,15,7,22,19,4,32,31,10),
   grow=c(8,1,0,5,5,0,2,1,0)
)
## use fewer grades for faster loop
tor.est&lt;-Kendall(tor, grades=200)
tor.est
wp.est &lt;- Kendall(woodpecker, grades=200)
wp.est

</code></pre>

<hr>
<h2 id='lambda'>Population growth rate</h2><span id='topic+lambda'></span>

<h3>Description</h3>

<p>Calculates the population growth rate of a projection matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambda(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lambda_+3A_a">A</code></td>
<td>
<p>A projection matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>see section 4.4 in Caswell (2001)
</p>


<h3>Value</h3>

<p>The dominant eigenvalue
</p>


<h3>Note</h3>

<p>The built-in <code><a href="base.html#topic+eigen">eigen</a></code> function returns eigenvalues in
descreasing order of magnitude or modulus.  The dominant eigenvalue of
imprimitive matrices with <em>d</em> eigenvalues of equal modulus is the one
with the largest real part (<code>which.max(Re(eigen(A)$values))</code>).
</p>


<h3>Author(s)</h3>

<p>Chris Stubben
</p>


<h3>References</h3>

<p>Caswell, H. 2001. Matrix population models: construction,
analysis, and interpretation, Second edition. Sinauer, Sunderland,
Massachusetts, USA.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+eigen">eigen</a></code> and <code><a href="#topic+pop.projection">pop.projection</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(c(0,0,2,.3,0,0,0,.6,0), nrow=3,byrow=TRUE)
lambda(A)
Re(eigen(A)$values)
sapply(hudsonia, lambda)

</code></pre>

<hr>
<h2 id='lnorms'>Generate random lognormal values for fertility rates</h2><span id='topic+lnorms'></span>

<h3>Description</h3>

<p>Converts standard normal random values to lognormals with defined means and variances
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lnorms(n, mean = 2, var = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lnorms_+3A_n">n</code></td>
<td>
<p>number of observations</p>
</td></tr>
<tr><td><code id="lnorms_+3A_mean">mean</code></td>
<td>
<p>mean value of the fertility rate, default 2</p>
</td></tr>
<tr><td><code id="lnorms_+3A_var">var</code></td>
<td>
<p>variance of the vital rate (not standard deviation), default 1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>converted Matlab code from  Box 8.4 in Morris and Doak (2002)
</p>


<h3>Value</h3>

<p>A vector of random lognormal values
</p>


<h3>Note</h3>

<p>This function could probably be replaced with built-in functions
for the Log Normal Distribution <code><a href="stats.html#topic+rlnorm">rlnorm</a> </code>
</p>


<h3>Author(s)</h3>

<p>Original Matlab code by Morris and Doak (2002: 281). Adapted to R by
Patrick Nantel, 20 June 2005.
</p>


<h3>References</h3>

<p>Morris, W. F., and D. F. Doak. 2002. Quantitative conservation
biology: Theory and practice of population viability analysis. Sinauer,
Sunderland, Massachusetts, USA.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stretchbetaval">stretchbetaval</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lnorms(1)
# Generate lognormal random fertilities
# for a population of 1000 mature individuals with mean fertility of
# 3 and inter-individual variance in fertility of 1.5.
rndfert  &lt;- lnorms(1000, 3,1.5)
summary(rndfert)
hist(rndfert,40, main="Lognormal random fertilities",
xlab="Fertility rate", col="blue")

</code></pre>

<hr>
<h2 id='logi.hist.plot'>Plot logistic regression</h2><span id='topic+logi.hist.plot'></span>

<h3>Description</h3>

<p>Plot combined graphs for logistic regressions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logi.hist.plot(
  independ,
  depend,
  logi.mod = 1,
  type = "dit",
  boxp = TRUE,
  rug = FALSE,
  ylabel = "Probability",
  ylabel2 = "Frequency",
  xlabel = "",
  mainlabel = "",
  las.h = 1,
  counts = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logi.hist.plot_+3A_independ">independ</code></td>
<td>
<p>explanatory variable</p>
</td></tr>
<tr><td><code id="logi.hist.plot_+3A_depend">depend</code></td>
<td>
<p>dependent variable, typically a logical vector</p>
</td></tr>
<tr><td><code id="logi.hist.plot_+3A_logi.mod">logi.mod</code></td>
<td>
<p>type of fitting, 1 = logistic; 2 = &quot;gaussian&quot; logistic</p>
</td></tr>
<tr><td><code id="logi.hist.plot_+3A_type">type</code></td>
<td>
<p>type of representation, &quot;dit&quot; = dit plot; &quot;hist&quot; = histogram</p>
</td></tr>
<tr><td><code id="logi.hist.plot_+3A_boxp">boxp</code></td>
<td>
<p>TRUE = with box plots, FALSE = without</p>
</td></tr>
<tr><td><code id="logi.hist.plot_+3A_rug">rug</code></td>
<td>
<p>TRUE = with rug plots, FALSE = without</p>
</td></tr>
<tr><td><code id="logi.hist.plot_+3A_ylabel">ylabel</code></td>
<td>
<p>y-axis label</p>
</td></tr>
<tr><td><code id="logi.hist.plot_+3A_ylabel2">ylabel2</code></td>
<td>
<p>2nd y-axis label</p>
</td></tr>
<tr><td><code id="logi.hist.plot_+3A_xlabel">xlabel</code></td>
<td>
<p>x-axix label</p>
</td></tr>
<tr><td><code id="logi.hist.plot_+3A_mainlabel">mainlabel</code></td>
<td>
<p>overall title for plot</p>
</td></tr>
<tr><td><code id="logi.hist.plot_+3A_las.h">las.h</code></td>
<td>
<p>orientation of axes labels (0 = vertical, 1 = horizontal</p>
</td></tr>
<tr><td><code id="logi.hist.plot_+3A_counts">counts</code></td>
<td>
<p>add counts above histogram bars</p>
</td></tr>
<tr><td><code id="logi.hist.plot_+3A_...">...</code></td>
<td>
<p>additional options passed to logi.hist</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logistic regression plot
</p>


<h3>Author(s)</h3>

<p>M. de la Cruz Rot
</p>


<h3>References</h3>

<p>de la Cruz Rot, M. 2005. Improving the Presentation of Results of
Logistic Regression with R.  ESA Bulletin 86:41-48.
<a href="http://esapubs.org/bulletin/backissues/086-1/bulletinjan2005.htm">http://esapubs.org/bulletin/backissues/086-1/bulletinjan2005.htm</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>aq.trans$survived &lt;- aq.trans$fate!="dead"
a &lt;- subset(aq.trans, leaf&lt;50 &amp; stage!="recruit", c(leaf,survived))
logi.hist.plot(a$leaf,  a$survived,
  type="hist", boxp=FALSE, counts=TRUE, int=10,
  ylabel="Survival probability", ylabel2="Number of plants",
  xlab="Number of leaves")
b &lt;- glm(survived ~ leaf, binomial, data=a)
summary(b)

</code></pre>

<hr>
<h2 id='LTRE'>Life Table Response Experiment</h2><span id='topic+LTRE'></span>

<h3>Description</h3>

<p>Evaluate sensitivities in a fixed Life Table Response Experiment (LTRE)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LTRE(trts, ref)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LTRE_+3A_trts">trts</code></td>
<td>
<p>A treatment matrix or a list of two or more treatment matrices</p>
</td></tr>
<tr><td><code id="LTRE_+3A_ref">ref</code></td>
<td>
<p>A reference matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sensitivities are evaluated midway between the treatment and reference
matrices as described in section 10.1.1 in Caswell (2001).
</p>


<h3>Value</h3>

<p>A matrix of contributions (equation 10.4 in Caswell) or a list of
matrices with one matrix of contributions per treatment
</p>


<h3>Note</h3>

<p>The examples of a fixed LTRE are from
Horvitz, C. C., D. W. Schemske, and H. Caswell. 1997. The relative importance
of life-history stages to population growth: prospective and retrospective
analyses. Pages 247-271 in S. Tuljapurkar and H. Caswell, editors. Structured
population models in marine, terrestrial and freshwater systems. Chapman and
Hall, New York.
A.L. Angert. 2006. Demography of central and marginal populations of
monkeyflowers (Mimulus cardinalis and M. lewisii). Ecology 87:2014-2025.
</p>


<h3>Author(s)</h3>

<p>Chris Stubben
</p>


<h3>See Also</h3>

<p>Check the <code>demo(Caswell)</code> for variance decomposition in a
random design using killer whale.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#######  Calathea ovandensis
calathea_pool &lt;- calathea[['pooled']]
## Create plots like FIGURE 7 in Horvitz et al 1997
plots &lt;- split(calathea[-17], rep(1:4,each=4))
## use Mean matrix since pooled not available by plot
plots &lt;- lapply(plots, mean)
Cm &lt;- LTRE(plots, calathea_pool)
pe &lt;- sapply(Cm, sum)
barplot(pe, xlab="Plot", ylab="Plot effect" , ylim=c(-.25, .25),
col="blue", las=1)
abline(h=0)
box()
title(expression(italic("Calathea ovandensis")))

##YEARS -- split recycles vector
yrs &lt;- split(calathea[-17], 1:4)
yrs &lt;- lapply(yrs, mean)
names(yrs) &lt;- 1982:1985
Cm &lt;- LTRE(yrs, calathea_pool)
ye &lt;- sapply(Cm, sum)
barplot(ye, xlab="Year", ylab="Year effect" , ylim=c(-.25, .25), col="blue", las=1)
abline(h=0)
box()
title(expression(italic("Calathea ovandensis")))
## INTERACTION
Cm &lt;- LTRE(calathea[-17], calathea_pool)
ie &lt;- sapply(Cm, sum)
## minus plot, year effects
ie&lt;- ie - rep(pe, each=4) - rep(ye, 4)
names(ie) &lt;- NULL
names(ie)[seq(1,16,4)] &lt;- 1:4
barplot(ie, xlab="Plot (years 82-83 to 85-86)", ylab="Interaction effect" ,
  ylim=c(-.25, .25), col="blue", las=1)
abline(h=0)
box()
title(expression(italic("Calathea ovandensis")))

#######  Mimulus
## Pooled M. cardinalis reference matrix kindly provided by Amy Angert 1/2/2008.
m_card_pool &lt;- matrix( c(
1.99e-01, 8.02e+02, 5.82e+03, 3.05e+04,
2.66e-05, 7.76e-02, 2.31e-02, 1.13e-03,
7.94e-06, 8.07e-02, 3.22e-01, 2.16e-01,
2.91e-07, 1.58e-02, 1.15e-01, 6.01e-01), byrow=TRUE, nrow=4)
## Population effects using pooled population matrices
card &lt;- subset(monkeyflower,  species=="cardinalis" &amp; year=="pooled")
## split rows into list of 4 matrices
Atrt &lt;- lapply(split(as.matrix(card[,4:19]), 1:4),  matrix, nrow=4, byrow=TRUE)
names(Atrt) &lt;- card$site
Cm &lt;- LTRE(Atrt, m_card_pool)
x &lt;- sapply(Cm, sum)
x
names(x) &lt;- c("BU", "RP", "WA", "CA")
## Plot like Figure 2A in Angert (2006)
op &lt;- par(mar=c(5,5,4,1))
barplot(x, xlab="Population", ylab="", xlim=c(0,6.5), ylim=c(-.4, .4),
  las=1, space=.5, col="blue")
abline(h=0)
mtext(expression(paste(sum(a[ij]), " contributions")), 2, 3.5)
title(expression(paste(italic("M. cardinalis"), " Population effects")))
box()
## and Plot like Figure 3A
x &lt;- matrix(unlist(Cm), nrow=4, byrow=TRUE)
colnames(x) &lt;- paste("a", rep(1:4, each=4), 1:4, sep="")
bp &lt;- barplot(x[1:2,], beside=TRUE, ylim=c(-.2,.2), las=1,
xlab="Transition", ylab="", xaxt='n')
mtext(expression(paste("Contribution of ", a[ij], "to variation in ", lambda)), 2, 3.5)
## rotate labels
text(bp[1,]-0.5, -.22, labels=colnames(x), srt=45, xpd=TRUE)
title(expression(paste(italic("M. cardinalis"), " Range center")))
box()
par(op)

</code></pre>

<hr>
<h2 id='matplot2'>Plot a matrix</h2><span id='topic+matplot2'></span>

<h3>Description</h3>

<p>Plot the rows of a matrix.  Useful for displaying a matrix of stage vectors,
survival rates and sensitivities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matplot2(
  x,
  proportions = FALSE,
  legend = "topright",
  xlab = NULL,
  ylab = NULL,
  type = "l",
  las = 1,
  pch = c(15:18, 1:3),
  lwd = 1,
  lty = 1:nrow(x),
  col = 1:nrow(x),
  lcex = 1,
  lbty = "o",
  lcol = 1,
  ltitle = NULL,
  lsort = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matplot2_+3A_x">x</code></td>
<td>
<p>a matrix</p>
</td></tr>
<tr><td><code id="matplot2_+3A_proportions">proportions</code></td>
<td>
<p>If TRUE, then  plot proportional changes</p>
</td></tr>
<tr><td><code id="matplot2_+3A_legend">legend</code></td>
<td>
<p>a <code><a href="graphics.html#topic+legend">legend</a></code> keyword or vector of x,y coordinates,
defaults to top-right corner</p>
</td></tr>
<tr><td><code id="matplot2_+3A_xlab">xlab</code></td>
<td>
<p>a label for the x axis</p>
</td></tr>
<tr><td><code id="matplot2_+3A_ylab">ylab</code></td>
<td>
<p>a label for the y axis</p>
</td></tr>
<tr><td><code id="matplot2_+3A_type">type</code></td>
<td>
<p>plot type, default line</p>
</td></tr>
<tr><td><code id="matplot2_+3A_las">las</code></td>
<td>
<p>style of axis labels, default horizontal</p>
</td></tr>
<tr><td><code id="matplot2_+3A_pch">pch</code></td>
<td>
<p>point types</p>
</td></tr>
<tr><td><code id="matplot2_+3A_lwd">lwd</code></td>
<td>
<p>line width</p>
</td></tr>
<tr><td><code id="matplot2_+3A_lty">lty</code></td>
<td>
<p>line type</p>
</td></tr>
<tr><td><code id="matplot2_+3A_col">col</code></td>
<td>
<p>color</p>
</td></tr>
<tr><td><code id="matplot2_+3A_lcex">lcex</code></td>
<td>
<p>legend size expansion</p>
</td></tr>
<tr><td><code id="matplot2_+3A_lbty">lbty</code></td>
<td>
<p>legend box type</p>
</td></tr>
<tr><td><code id="matplot2_+3A_lcol">lcol</code></td>
<td>
<p>number of columns in legend</p>
</td></tr>
<tr><td><code id="matplot2_+3A_ltitle">ltitle</code></td>
<td>
<p>legend title</p>
</td></tr>
<tr><td><code id="matplot2_+3A_lsort">lsort</code></td>
<td>
<p>sort  legend by decreasing order of mean number in row</p>
</td></tr>
<tr><td><code id="matplot2_+3A_...">...</code></td>
<td>
<p>additional options are passed to <code><a href="graphics.html#topic+plot">plot</a></code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix plot
</p>


<h3>Note</h3>

<p>Only a few basic legend options are available.  For more control, set
legend=NA and run separately
</p>


<h3>Author(s)</h3>

<p>Chris Stubben
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+matplot">matplot</a></code> and <code><a href="#topic+stage.vector.plot">stage.vector.plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># survival rates
x &lt;- calathea[9:12]
x &lt;- sapply(x, function(x) colSums(splitA(x, r=1:2)$T))
matplot2(t(x), legend="bottomright", ylab="Survival",
 main="Calathea survival curves")
# Growth rates - do not sort legend
x &lt;- sapply(calathea[-17], lambda)
x &lt;- matrix(x, nrow=4, byrow=TRUE, dimnames= list(paste("plot", 1:4), 1982:1985))
matplot2(x, type='b', lsort=FALSE, ylab="Growth rate", main="Calathea growth rates")
# Convergence to stable stage (excluding seeds)
x &lt;- pop.projection(calathea[[7]], rep(1,8), 10)
matplot2(x$stage.vectors[-1,], prop=TRUE,
  main="Calathea stage vectors", lcex=.7)

</code></pre>

<hr>
<h2 id='matrix2'>Square matrices</h2><span id='topic+matrix2'></span>

<h3>Description</h3>

<p>Create a square matrix from a given set of values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix2(x, stages, byrow = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix2_+3A_x">x</code></td>
<td>
<p>a vector of matrix elements</p>
</td></tr>
<tr><td><code id="matrix2_+3A_stages">stages</code></td>
<td>
<p>a vector of row names (also  assigned to columns)</p>
</td></tr>
<tr><td><code id="matrix2_+3A_byrow">byrow</code></td>
<td>
<p>fill matrix by rows , default TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a square matri
</p>


<h3>Author(s)</h3>

<p>Chris Stubben
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+matrix">matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Centaurea corymbosa from Freville 2004
ceco &lt;- c(0,0,5.905,0.368,0.639, 0.025, 0.001, 0.152, 0.051)
stages &lt;- c("seedling", "vegetative", "flowering")
# shortcut for
matrix(ceco, nrow=3, byrow=TRUE, dimnames=list(stages,stages))
matrix2(ceco, stages)

</code></pre>

<hr>
<h2 id='mean.list'>Mean matrix</h2><span id='topic+mean.list'></span>

<h3>Description</h3>

<p>Calculates mean matrix from a list of matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'list'
mean(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean.list_+3A_x">x</code></td>
<td>
<p>A list of two or more matrices</p>
</td></tr>
<tr><td><code id="mean.list_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="Matrix.html#topic+rowMeans">rowMeans</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns the mean matrix from a list of matrices using a combination of
<code><a href="base.html#topic+unlist">unlist</a></code> and <code><a href="Matrix.html#topic+rowMeans">rowMeans</a></code>.  See example for details.
</p>


<h3>Value</h3>

<p>The mean matrix
</p>


<h3>Note</h3>

<p>S3 method for the <code><a href="base.html#topic+mean">mean</a></code> of a list of matrices
</p>


<h3>Author(s)</h3>

<p>Chris Stubben
</p>


<h3>See Also</h3>

<p><code><a href="#topic+var2">var2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mean(hudsonia)
# or
x &lt;- matrix(unlist(hudsonia), ncol=length(hudsonia) )
matrix2(rowMeans(x), colnames(hudsonia[[1]]))

</code></pre>

<hr>
<h2 id='monkeyflower'>Projection matrices for monkeyflower</h2><span id='topic+monkeyflower'></span>

<h3>Description</h3>

<p>Pooled and annual projection matrices of central and marginal populations of
monkeyflowers (<em>Mimulus cardinalis</em> and <em>M. lewisii</em>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>monkeyflower
</code></pre>


<h3>Format</h3>

<p>A data frame with 32 matrices, arranged with one matrix per row
</p>

<dl>
<dt><code>species</code></dt><dd><p>M. cardinalis or M. lewisii</p>
</dd>
<dt><code>site</code></dt><dd><p>Study site</p>
</dd>
<dt><code>year</code></dt><dd><p>Start year of projection interval or pooled for all three years</p>
</dd>
<dt><code>a11</code></dt><dd><p>matrix element a11;  seed to seed transition or seed bank survival</p>
</dd>
<dt><code>a12</code></dt><dd><p>matrix element a12;  small nr to seed - fertility</p>
</dd>
<dt><code>a13</code></dt><dd><p>matrix element a13;  large nr to seed - fertility</p>
</dd>
<dt><code>a14</code></dt><dd><p>matrix element a14;  reprod to seed - fertility</p>
</dd>
<dt><code>a21</code></dt><dd><p>matrix element a21;  seed to small nr - growth</p>
</dd>
<dt><code>a22</code></dt><dd><p>matrix element a22;  small nr to small nr -stasis</p>
</dd>
<dt><code>a23</code></dt><dd><p>matrix element a23;  large nr to small nr - regress</p>
</dd>
<dt><code>a24</code></dt><dd><p>matrix element a24;  reprod to small nr - regress</p>
</dd>
<dt><code>a31</code></dt><dd><p>matrix element a31;  seed to large nr - growth  </p>
</dd>
<dt><code>a32</code></dt><dd><p>matrix element a32;  small nr to large nr - growth  </p>
</dd>
<dt><code>a33</code></dt><dd><p>matrix element a33;  large nr to large nr - stasis  </p>
</dd>
<dt><code>a34</code></dt><dd><p>matrix element a34;  reprod to large nr - regress  </p>
</dd>
<dt><code>a41</code></dt><dd><p>matrix element a41;  seed to reprod - growth  </p>
</dd>
<dt><code>a42</code></dt><dd><p>matrix element a42;  small nr to reprod - growth  </p>
</dd>
<dt><code>a43</code></dt><dd><p>matrix element a43;  large nr to reprod - growth  </p>
</dd>
<dt><code>a44</code></dt><dd><p>matrix element a44;  reprod to reprod - stasis  </p>
</dd>
</dl>



<h3>Details</h3>

<p>Matrix constructed using a post-breeding census with four stage classes:
Seeds, small non-reproductive, large non-reproductive, and reproductive.
</p>


<h3>Source</h3>

<p><a href="http://www.esapubs.org/archive/ecol/E087/126/appendix-E.htm">http://www.esapubs.org/archive/ecol/E087/126/appendix-E.htm</a>
</p>


<h3>References</h3>

<p>Amy Lauren Angert. 2006. Demography of central and marginal
populations of monkeyflowers (<em>Mimulus cardinalis</em> and <em>M.
lewisii</em>). Ecology 87:2014-2025.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>monkeyflower
## convert M. cardinalis rows to list of 16 matrices
A &lt;- subset(monkeyflower, species == "cardinalis")
# use as.matrix to convert data.frame to numeric matrix
A &lt;- split(as.matrix(A[, 4:19]), paste(A$site, A$year))
stages &lt;- c("seed", "sm.nr", "lg.nr", "repro")
## convert to list of 16 matrices
A &lt;- lapply(A, matrix, nrow = 4, byrow = TRUE, dimnames = list(stages, stages))
A[8]
image2(A[[8]], round = 8, mar = c(1, 3, 4.5, 1))
title(paste("M. cardinalis - ", names(A[8])), line = 2.5)
## plot like figure 1A
x &lt;- matrix(sapply(A, lambda), ncol = 4)
colnames(x) &lt;- c("BU", "CA", "RP", "WA")
rownames(x) &lt;- c(2000:2002, "pooled")
x &lt;- x[, c(1, 3, 4, 2)]
colrs &lt;- gray(0:3 / 3)[c(1, 3, 2, 4)]
barplot(x, beside = TRUE, las = 1, col = colrs, ylim = c(0, 2),
  ylab = "Population growth rate", main = "Mimulus cardinalis")
box()
abline(h = 1, lwd = .5)
legend(1, 1.95, rownames(x), fill = colrs, bty = "n")
</code></pre>

<hr>
<h2 id='multiresultm'>Incorporate demographic stochasticity into population projections</h2><span id='topic+multiresultm'></span>

<h3>Description</h3>

<p>Generates multinomial random numbers for state transitions and lognormal or
binomial (for clutch size=1) random numbers for fertilities  and returns a
vector of the number of individuals per stage class at <em>t+1</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiresultm(n, T, F, varF = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiresultm_+3A_n">n</code></td>
<td>
<p>the vector of numbers of individuals per class at t</p>
</td></tr>
<tr><td><code id="multiresultm_+3A_t">T</code></td>
<td>
<p>a transition T matrix</p>
</td></tr>
<tr><td><code id="multiresultm_+3A_f">F</code></td>
<td>
<p>a fertility F matrix</p>
</td></tr>
<tr><td><code id="multiresultm_+3A_varf">varF</code></td>
<td>
<p>a matrix of inter-individual variance in fertilities, default is
NULL for simulating population where clutch size = 1, so that fertilities
give the probabilities of birth</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Adapted from Matlab code in Box 8.11 in Morris and Doak (2002) and section
15.1.3 in Caswell (2001)
</p>


<h3>Value</h3>

<p>a vector of the number of individuals per class at t+1.
</p>


<h3>Author(s)</h3>

<p>Patrick Nantel
</p>


<h3>References</h3>

<p>Caswell, H. 2001. Matrix population models: construction,
analysis, and interpretation, Second edition. Sinauer, Sunderland,
Massachusetts, USA.
</p>
<p>Morris, W. F., and D. F. Doak. 2002. Quantitative conservation
biology: Theory and practice of population viability analysis. Sinauer,
Sunderland, Massachusetts, USA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- splitA(whale)
whaleT &lt;- x$T
whaleF &lt;- x$F
multiresultm(c(1,9,9,9),whaleT, whaleF)
multiresultm(c(1,9,9,9),whaleT, whaleF)
## create graph similar to Fig 15.3 a
reps &lt;- 10    # number of trajectories
tmax &lt;- 200   # length of the trajectories
totalpop &lt;- matrix(0,tmax,reps)  # initializes totalpop matrix to store trajectories
nzero &lt;- c(1,1,1,1) # starting population size
for (j in 1:reps) {
   n &lt;- nzero
   for (i in 1:tmax) {
      n &lt;- multiresultm(n,whaleT,whaleF)
      totalpop[i,j] &lt;- sum(n)
   }
}
matplot(totalpop, type = 'l', log="y",
        xlab = 'Time (years)', ylab = 'Total population')

</code></pre>

<hr>
<h2 id='nematode'>Population densities for the sugarbeet cyst nematode</h2><span id='topic+nematode'></span>

<h3>Description</h3>

<p>A time-series of population vectors for the sugarbeet cyst nematode
<em>Heterodera schachtii</em>. Individuals were classified into three stages
(J2, J3+J4, and adult) and densities (per 60 cc of soil) were averaged over
four replicates, measured every two days, for 10 days. .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nematode
</code></pre>


<h3>Format</h3>

<p>A matrix listing densities from  3 stage classes over 6 time periods
</p>


<h3>Source</h3>

<p>Example 6.3 in Caswell (2001).
</p>


<h3>References</h3>

<p>Caswell, H. 2001. Matrix population models. Construction,
Analysis and interpretation. 2nd ed. Sinauer, Sunderland, Massachusetts.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+QPmat">QPmat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nematode
stage.vector.plot(nematode,
  prop = FALSE, log = "y", ylim = c(.3, 200),
  xlab = "Time", ylab = "Nematode density"
)
</code></pre>

<hr>
<h2 id='net.reproductive.rate'>Net reproductive rate</h2><span id='topic+net.reproductive.rate'></span>

<h3>Description</h3>

<p>Calculates the net reproductive rate of a stage classified matrix using the
dominant eigenvalue of the matrix R
</p>


<h3>Usage</h3>

<pre><code class='language-R'>net.reproductive.rate(A, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="net.reproductive.rate_+3A_a">A</code></td>
<td>
<p>projection matrix</p>
</td></tr>
<tr><td><code id="net.reproductive.rate_+3A_...">...</code></td>
<td>
<p>additional items are passed to <code><a href="#topic+splitA">splitA</a></code> and are
used to split A into T and F matrices</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Net reproductive rate.  If the transition matrix is singular, then
NA is returned.
</p>


<h3>Author(s)</h3>

<p>Chris Stubben
</p>


<h3>References</h3>

<p>Caswell, H. 2001. Matrix population models: construction,
analysis, and interpretation, Second edition. Sinauer, Sunderland,
Massachusetts, USA.
</p>


<h3>See Also</h3>

<p>see <code><a href="#topic+fundamental.matrix">fundamental.matrix</a></code> and <code><a href="#topic+generation.time">generation.time</a></code>
for other age-specific traits
</p>


<h3>Examples</h3>

<pre><code class='language-R'>net.reproductive.rate(whale)
## fertilities in last column
net.reproductive.rate(teasel, r=1:6, c=6)
## Plot 3 from Calathea - values are not the same as p. 105 in Caswell.
sapply(calathea[9:12], net.reproductive.rate)

</code></pre>

<hr>
<h2 id='pfister.plot'>Create log-log plots of variance vs. sensitivity and CV vs. elasticity</h2><span id='topic+pfister.plot'></span>

<h3>Description</h3>

<p>Create log-log plots of both variance vs. sensitivity and CV vs. elasticity
in matrix elements.  Plots are based on Figure 2 in Pfister(1998)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pfister.plot(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pfister.plot_+3A_a">A</code></td>
<td>
<p>A list of two or more projection matrices</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates mean, variance and coefficient of variation (CV) of matrix
elements from a list of two or more projection matrices.  The sensitivity and
elasticity matrices are then calculated from the mean matrix using
<code><a href="#topic+eigen.analysis">eigen.analysis</a></code>
</p>


<h3>Value</h3>

<p>Creates two log-log plots similar to Figure 2 in Pfister(1998) and
outputs a data.frame with 5 columns listing mean, variance, CV, sensitivity
and elasticity for matrix elements with a mean and variance &gt; 0
</p>


<h3>Author(s)</h3>

<p>Chris Stubben
</p>


<h3>References</h3>

<p>Pfister, CA.  1998. Patterns of variance in stage-structured
populations: Evolutionary predictions and ecological implications. PNAS 95:213-218.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 4 Hudsonia matrices
pfister.plot(hudsonia)
## 3 Mimulus cardinalis matrices at Carlon
mim &lt;- subset(monkeyflower, species == "cardinalis" &amp;
    site == "Carlon" &amp; year != "pooled", select = c(4:19))
## convert data frame to list of matrices using split
mim1 &lt;-split(mim, 2000:2002)
mim2 &lt;-lapply(mim1, matrix, nrow=4, byrow=TRUE)
vr1 &lt;- pfister.plot(mim2)
vr1
## PLOT using labels
plot(vr1$cv, vr1$elas, xlab="CV", ylab="Elasticity", log="xy", type='n')
# Split matrix elements into transitions representing F (fertility),
# S (survival), G (growth), and R (retrogression).
# Fertility on top row, survival on diagonal, growth is above diagonal
# and retrogression below diagonal.
rownames(vr1)
y2 &lt;- expression(S[11],G[21],G[31],G[41],
                 F[12],S[22],G[32],G[42],
                 F[13],R[23],S[33],G[43],
                 F[14],R[34],S[44])
text(vr1$cv, vr1$elas, y2)
### add trend line
 abline(lm(log10(vr1$elas)~log10(vr1$cv)), col="red")
## include Spearman's rank correlation
a &lt;- cor.test(vr1$cv, vr1$elas, method="spearman")
a
text(10, .0015, substitute(rho == x, list(x=round(a$estimate,2))), col="blue")

</code></pre>

<hr>
<h2 id='pop.projection'>Calculate population growth rates by projection</h2><span id='topic+pop.projection'></span>

<h3>Description</h3>

<p>Calculates the population growth rate and stable stage distribution by
repeated projections of the equation <code class="reqn">n(t+1)=An(t)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pop.projection(A, n, iterations = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pop.projection_+3A_a">A</code></td>
<td>
<p>A projection matrix</p>
</td></tr>
<tr><td><code id="pop.projection_+3A_n">n</code></td>
<td>
<p>An initial age or stage vector</p>
</td></tr>
<tr><td><code id="pop.projection_+3A_iterations">iterations</code></td>
<td>
<p>Number of iterations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Eventually, structured populations will convergence to a stable stage
distribution where each new stage vector is changing by the same proportion (lambda).
</p>


<h3>Value</h3>

<p>A list with 5 items
</p>
<table>
<tr><td><code>lambda</code></td>
<td>
<p>Estimate of lambda using change between the last two population counts</p>
</td></tr>
<tr><td><code>stable.stage</code></td>
<td>
<p>Estimate of stable stage distribution using proportions in last stage vector</p>
</td></tr>
<tr><td><code>stage.vector</code></td>
<td>
<p>A matrix with the number of projected individuals in each stage class</p>
</td></tr>
<tr><td><code>pop.sizes</code></td>
<td>
<p>Total number of projected individuals</p>
</td></tr>
<tr><td><code>pop.changes</code></td>
<td>
<p>Proportional change in population size</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Chris Stubben
</p>


<h3>References</h3>

<p>see section 2.2 in Caswell 2001
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stage.vector.plot">stage.vector.plot</a></code> to plot stage vectors
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## mean matrix from Freville et al 2004
stages &lt;- c("seedling", "vegetative", "flowering")
A &lt;- matrix(c(
    0,     0,  5.905,
0.368, 0.639,  0.025,
0.001, 0.152,  0.051
), nrow=3, byrow=TRUE,
    dimnames=list(stages,stages))
n &lt;- c(5,5,5)
p &lt;- pop.projection(A,n, 15)
p
damping.ratio(A)
stage.vector.plot(p$stage.vectors, col=2:4)
A &lt;- whale
#n &lt;- c(4,38,36,22)
n &lt;- c(5,5,5,5)
p &lt;- pop.projection(A,n, 15)
p
stage.vector.plot(p$stage.vectors, col=2:4, ylim=c(0, 0.6))
## convergence is slow with damping ratio close to 1
damping.ratio(A)
pop.projection(A, n, 100)$pop.changes

</code></pre>

<hr>
<h2 id='projection.matrix'>Construct projection matrix models using transition frequency tables</h2><span id='topic+projection.matrix'></span>

<h3>Description</h3>

<p>Construct an age or stage-structure projection model from a transition table
listing stage in time <em>t</em>, fate in time <em>t+1</em>, and one or more
individual fertility columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>projection.matrix(
  transitions,
  stage = NULL,
  fate = NULL,
  fertility = NULL,
  sort = NULL,
  add = NULL,
  TF = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="projection.matrix_+3A_transitions">transitions</code></td>
<td>
<p>a stage-fate data frame with stage or age class in the
current census,  fate in the subsequent census, and one or more fertility columns</p>
</td></tr>
<tr><td><code id="projection.matrix_+3A_stage">stage</code></td>
<td>
<p>a column name or position of the stage column in the stage-fate
data frame.  Defaults to &quot;stage&quot;.</p>
</td></tr>
<tr><td><code id="projection.matrix_+3A_fate">fate</code></td>
<td>
<p>name of the fate column in the stage-fate data frame. Defaults to &quot;fate&quot;</p>
</td></tr>
<tr><td><code id="projection.matrix_+3A_fertility">fertility</code></td>
<td>
<p>one or more names of fertility columns in the stage-fate
data frame.  By default, any column names matching stage class names are
assumed to contain individual fertilities</p>
</td></tr>
<tr><td><code id="projection.matrix_+3A_sort">sort</code></td>
<td>
<p>a vector listing stage classes that correspond to the rows and
columns of the desired projection matrix.  Currently, names in this vector
must match a level in the stage column.  Also, this option should only be
used if stages are not <code><a href="base.html#topic+ordered">ordered</a></code>, since the default is to sort by
<code><a href="base.html#topic+levels">levels</a></code> in the stage column.</p>
</td></tr>
<tr><td><code id="projection.matrix_+3A_add">add</code></td>
<td>
<p>a vector listing row, column and value, used to add
<em>estimated</em>  transtions to the transition matrix (e.g., a transition
from seed bank to  seedling).  May be repeated.</p>
</td></tr>
<tr><td><code id="projection.matrix_+3A_tf">TF</code></td>
<td>
<p>output separate transition (T) and fertility (F) matrices.  Default
is FALSE and outputs a single projection matrix A</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The state transition rates are estimated using transition frequency tables
(see section 6.1.1, Caswell 2001), so this technique will most likely apply
to demographic studies of plants or other sessile organisms where individuals
are tagged and then consistently relocated in annual censuses.  The fertility
rates are calculated by averaging individuals fertilities by stage class;
therefore, some care should be taken to correctly estimate individual
fertilities based on the timing of the census.
</p>


<h3>Value</h3>

<p>The default output is a single projection matrix A. If the TF flag is
true, then a list with 2 items where A=T+F
</p>


<h3>Note</h3>

<p>Individual fertilities should be the total number of offspring at the
end of the census interval.  Therefore, fertilites should include offspring
survival in a prebreeding censuses (and more than one offspring class may be
present).  In a postbreeding census, new offspring were born just before the
census, so the fertility rate is just the number of offspring in this case.
</p>


<h3>Author(s)</h3>

<p>Chris Stubben
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trans01 &lt;- subset(merge(test.census, test.census, by = "plant", sort =FALSE),
                    year.x==2001 &amp; year.y==2002 )
## Add individual fertilities using "anonymous reproduction"  based on the
## proportional reproductive outputs of flowering plants and the total number
## of seedlings at the end of the projection interval
trans01$seedferts &lt;- trans01$fruits.x/sum(trans01$fruits.x) * 5
trans01
stages &lt;- c("seedling", "vegetative", "reproductive")
## three ways to specify columns
projection.matrix(trans01, stage.x, stage.y, seedferts, stages)
projection.matrix(trans01, 3, 6, 8, c(3,4,2))
projection.matrix(trans01, "stage.x", "stage.y", "seedferts", stages)
## BEST to use column default (fertility column (seedling) now matches stage class name)
names(trans01)[c(3, 6, 8)] &lt;- c("stage", "fate", "seedling")
# AND order stages in dataframe
trans01$stage &lt;- ordered(trans01$stage, stages)
projection.matrix(trans01)
projection.matrix(trans01, TF=TRUE)
## Example using Aquilegia data
sf &lt;- subset(aq.trans, year==1998 &amp; plot==909, c(year, plant, stage, fruits, fate))
## rows and columns of final matrix
levels(sf$stage)
## seedlings next year
seedlings &lt;- nrow(subset(aq.trans, plot==909 &amp; year==1999 &amp; stage=="recruit"))
## ADD individual fertility estimates for recruits and seeds assuming seed bank and
## new seeds contribute to a common germinant pool with equal chance of recruitment
seed.survival &lt;- .4
seed.bank.size &lt;- 1000
seeds.per.fruit &lt;- 50
seeds.from.plants &lt;- sum(sf$fruits)*seeds.per.fruit
recruitment.rate &lt;- seedlings/(seed.bank.size + seeds.from.plants)
## add two fertility columns
sf$recruit &lt;- sf$fruits/sum(sf$fruits) * seeds.from.plants * recruitment.rate
sf$seed &lt;- sf$fruits * seeds.per.fruit * seed.survival
## add seed bank survival and seed bank recruitment rate to transition matrix
A &lt;- projection.matrix(sf, add=c(1,1, seed.survival, 2,1, recruitment.rate ))
A
max(Re(eigen(A)$values))

</code></pre>

<hr>
<h2 id='QPmat'>Build a projection matrix from a time series of individuals (or densities) per stage</h2><span id='topic+QPmat'></span>

<h3>Description</h3>

<p>Builds one projection matrix from a time series of number (or densities) of
individuals per stage (size classes or life stages) using Wood's quadratic
programming method. The matrix model also requires a constraint matrix C,
vector b, and vector listing nonzero elements of desired projection matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QPmat(nout, C, b, nonzero)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QPmat_+3A_nout">nout</code></td>
<td>
<p>A time series of population vectors</p>
</td></tr>
<tr><td><code id="QPmat_+3A_c">C</code></td>
<td>
<p>constraint matrix</p>
</td></tr>
<tr><td><code id="QPmat_+3A_b">b</code></td>
<td>
<p>b vector</p>
</td></tr>
<tr><td><code id="QPmat_+3A_nonzero">nonzero</code></td>
<td>
<p>indices of the non-zero elements of the transition matrix (counting by column)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>converted Matlab code from Example 6.3 in Caswell (2001)
</p>


<h3>Value</h3>

<p>A projection matrix.
</p>


<h3>Note</h3>

<p>This function requires <code>solve.QP</code> in the <code>quadprog</code> package.
</p>


<h3>Author(s)</h3>

<p>Adapted to R by Patrick Nantel
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## list nonzero elements
nonzero &lt;- c( 1, 2, 5, 6, 7, 9)
## create C matrix
C &lt;- rbind(diag(-1,6), c(1,1,0,0,0,0), c(0,0,1,1,0,0), c(0,0,0,0,0,1))
## calculate b (transpose is not necessary - either way works)
b &lt;- apply(C, 1, max)
QPmat(nematode, C,b,nonzero)

## End(Not run)

</code></pre>

<hr>
<h2 id='reproductive.value'>Reproductive value</h2><span id='topic+reproductive.value'></span>

<h3>Description</h3>

<p>Calculates the reproductive values of a projection matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reproductive.value(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reproductive.value_+3A_a">A</code></td>
<td>
<p>A projection matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>see section 4.5 in Caswell (2001)
</p>


<h3>Value</h3>

<p>A vector containing the scaled reproductive values so v[1]=1
</p>


<h3>Author(s)</h3>

<p>Chris Stubben
</p>


<h3>References</h3>

<p>Caswell, H. 2001. Matrix population models: construction,
analysis, and interpretation, Second edition. Sinauer, Sunderland,
Massachusetts, USA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- reproductive.value(teasel)
v
dotchart(log10(v), pch=16, xlab="Reproductive value (log10)")

</code></pre>

<hr>
<h2 id='resample'>Resample a projection matrix</h2><span id='topic+resample'></span>

<h3>Description</h3>

<p>Resample a projection matrix using  a multinomial distribution for
transitions and a log normal distribution for fertilities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample(A, n, fvar = 1.5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_+3A_a">A</code></td>
<td>
<p>a projection matrix</p>
</td></tr>
<tr><td><code id="resample_+3A_n">n</code></td>
<td>
<p>either a stage vector with the number of transitions to sample
in each column or a single value  that is applied to all columns</p>
</td></tr>
<tr><td><code id="resample_+3A_fvar">fvar</code></td>
<td>
<p>either a vector of different fertility variances or a single
variance of fertility (default 1.5) that is applied to all rates</p>
</td></tr>
<tr><td><code id="resample_+3A_...">...</code></td>
<td>
<p>additional items are passed to <code><a href="#topic+splitA">splitA</a></code>
and are used to split A into T and F matrices</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The projection matrix A is first split into separate transition and fertility
matrices.  Dead fates are added to the transtion matrix and the columns are
then sampled from a <code><a href="stats.html#topic+Multinomial">Multinomial</a></code> distribution based on the size
in each corresponding stage class in <code>n</code>. The fertility rates are
sampled from a Log Normal distribution using the <code><a href="#topic+lnorms">lnorms</a></code>
function. The variance can be a single value which is applied to all rates,
or vector of different values to apply to each rate.  In this case, the
values are recycled to match the number of non-zero fertilities.
</p>


<h3>Value</h3>

<p>A resampled projection matrix
</p>


<h3>Note</h3>

<p>see section 12.1.5.2 on parametric bootsrap in Caswell (2001)
</p>


<h3>Author(s)</h3>

<p>Chris Stubben
</p>


<h3>See Also</h3>

<p><code><a href="#topic+boot.transitions">boot.transitions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- hudsonia[[1]]
lambda(A)
## NOTE fertilities are in first two rows, so use r=1:2 for splitting this matrix
## resample transitions 100 times each
resample(A, 100, r=1:2)
## set higher fvar in stage 4 and 6
## because there are two fertilities per stage (8 total), need to repeat values
resample(A,1000, fvar=c(1.5, 1.5, 3, 3), r=1:2)
## OR resample based on number of plants surveyed
# data from table 6.4 and  box 7.3)
n &lt;- c(4264,3, 30, 16, 24,5)
## create a list with 1000 resampled matrices
x &lt;- lapply(1:1000, function(x) resample(A,n, r=1:2))
mean(x)
## use var2 to check variances, especially if  using differnt fvar values
var2(x)
## growth rates
y &lt;- sapply(x, lambda)
quantile( y, c(0.025, .975) )
hist(y, br=30, col="palegreen", xlab="Lambda", main="1985 Hudsonia growth rates")
abline(v=quantile(y, c(0.025, .975)), lty=3)
## double the sample size (and quadruple seedlings) and you may be able to detect a decline
n &lt;- n * 2
n[2] &lt;- n[2] * 2
x &lt;- lapply(1:1000, function(x) resample(A, n * 2, r=1:2))
quantile( sapply(x, lambda), c(0.025, .975) )

</code></pre>

<hr>
<h2 id='secder'>Second derivatives of the dominant eigenvalue</h2><span id='topic+secder'></span>

<h3>Description</h3>

<p>Calculates the second derivatives of the dominant eigenvalue of the
demographic projection matrix for all non-zero transitions with respect to
one specified transition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>secder(A, k, l)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="secder_+3A_a">A</code></td>
<td>
<p>projection matrix</p>
</td></tr>
<tr><td><code id="secder_+3A_k">k</code></td>
<td>
<p>row index for the specified transition</p>
</td></tr>
<tr><td><code id="secder_+3A_l">l</code></td>
<td>
<p>column index for the specified transition</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function copied from demogR package after it was removed from CRAN.
See section 9.7 in Caswell 2001.
</p>


<h3>Value</h3>

<p>A square matrix of the same rank as A where each element <code class="reqn">s_ij</code>
is the second derivative of the dominant eigenvalue of A.
</p>


<h3>Note</h3>

<p>The eigenvalue second derivatives are essential for calculating both
perturbation analyses of the eigenvalue elasticities and stochastic
sensitivities.
</p>


<h3>Author(s)</h3>

<p>James Holland Jones
</p>


<h3>References</h3>

<p>Caswell, H. 2001. Matrix population models: construction,
analysis, and interpretation, Second edition. Sinauer, Sunderland,
Massachusetts, USA.
</p>
<p>Caswell, H. 1996. Second derivatives of population growth rate:
Calculation and applications. Ecology 77 (3):870-879.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eigen.analysis">eigen.analysis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## eigenvalue second derivatives of the US projection matrix from 1967
## with respect to infant survival
x1 &lt;-   c(0, 0.0010478, 0.0820086, 0.2884376, 0.3777064,
  0.2647110, 0.1405144, 0.0585568, 0.0134388, 0.0003327)
x2 &lt;- diag(c(0.9972036, 0.9983625, 0.9978063, 0.9967535,
  0.9961039, 0.9948677, 0.9923658, 0.9885968, 0.9828676))
usa &lt;- rbind(x1, cbind(x2,0))
sd21 &lt;- secder(usa,2,1)
sd21

</code></pre>

<hr>
<h2 id='sensitivity'>Sensitivity analysis of a projection matrix</h2><span id='topic+sensitivity'></span>

<h3>Description</h3>

<p>Calculate the sensitivities of eigenvalues to changes in the projection
matrix elements
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sensitivity(A, zero = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sensitivity_+3A_a">A</code></td>
<td>
<p>A projection matrix</p>
</td></tr>
<tr><td><code id="sensitivity_+3A_zero">zero</code></td>
<td>
<p>Set sensitivities for unobserved transitions to zero, default is FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>see section 9.1 in Caswell (2001)
</p>


<h3>Value</h3>

<p>A sensitivity matrix
</p>


<h3>Author(s)</h3>

<p>Chris Stubben
</p>


<h3>References</h3>

<p>Caswell, H. 2001. Matrix population models: construction,
analysis, and interpretation, Second edition. Sinauer, Sunderland,
Massachusetts, USA.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+elasticity">elasticity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sens &lt;- sensitivity(teasel)
## IMAGE plot with smaller boxes
image2(sens, mar=c(1,3.5,5,1), box.offset=.1)
 title("Sensitivity matrix using image2", line=2.5)
## MATPLOT
matplot2(sens, log='y', type='b', yaxt='n', ltitle="Fate",
 ylab=expression(paste("Sensitivity of ",lambda)),
 main="Sensitivity matrix using matplot2")
pwrs &lt;- -4:1
axis(2, 10^pwrs, parse(text=paste("10^", pwrs, sep = "")), las=1)

</code></pre>

<hr>
<h2 id='splitA'>Split a projection matrix into separate T and F matrices</h2><span id='topic+splitA'></span>

<h3>Description</h3>

<p>Splits a projection matrix into transition and fertility matrices where
<code>A = T + F</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitA(A, r = 1, c = -1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitA_+3A_a">A</code></td>
<td>
<p>a projection matrix</p>
</td></tr>
<tr><td><code id="splitA_+3A_r">r</code></td>
<td>
<p>rows containing fertilities (default is first row) OR a logical
matrix where TRUE is the location of a fertility value OR a complete
fertility matrix</p>
</td></tr>
<tr><td><code id="splitA_+3A_c">c</code></td>
<td>
<p>columns containing fertilities, default is all columns except first</p>
</td></tr>
</table>


<h3>Details</h3>

<p>see section 5.1 in Caswell (2001)
</p>


<h3>Value</h3>

<p>A list with T and F matrices
</p>


<h3>Note</h3>

<p>By default, the fertility matrix will include elements in the first row
(except first element). In some cases, it is not possible to split a
projection matrix using only row and column indexes. Therefore,  a logical
matrix (where TRUE is the location of a fertility value) or the complete
fertility matrix is also accepted.
</p>


<h3>Author(s)</h3>

<p>Chris Stubben
</p>


<h3>References</h3>

<p>Caswell, H. 2001. Matrix population models: construction,
analysis, and interpretation, Second edition. Sinauer, Sunderland,
Massachusetts, USA.
</p>


<h3>See Also</h3>

<p>functions like  <code><a href="#topic+generation.time">generation.time</a></code> and
<code><a href="#topic+net.reproductive.rate">net.reproductive.rate</a></code> use <code>splitA</code> to split the matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>splitA(whale)
# teasel -fertilitiles in last column
splitA(teasel, r=1:6, c=6)
# hudsonia - fertilities in first two columns
A &lt;- hudsonia[[1]]
splitA(A, r=1:2)
## example using a logical matrix (if fertilities were in the upper diagonal)
splitA(A, row(A)&lt;col(A))
# survival curves
x &lt;- sapply(hudsonia, function(x) colSums(splitA(x, r=1:2)$T))
matplot2(t(x), legend="bottomright", ylab="Survival",
 main="Hudsonia survival curves")

</code></pre>

<hr>
<h2 id='stable.stage'>Stable stage distribution</h2><span id='topic+stable.stage'></span>

<h3>Description</h3>

<p>Calculates the stable stage distribution of a projection matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stable.stage(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stable.stage_+3A_a">A</code></td>
<td>
<p>A projection matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>see section 4.5 in Caswell (2001)
</p>


<h3>Value</h3>

<p>A vector containing the stable stage distribution
</p>


<h3>Author(s)</h3>

<p>Chris Stubben
</p>


<h3>References</h3>

<p>Caswell, H. 2001. Matrix population models: construction,
analysis, and interpretation, Second edition. Sinauer, Sunderland,
Massachusetts, USA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>w &lt;- stable.stage(teasel)
w
barplot(w, col="green", ylim=c(0,1), las=1, main="Teasel",
     ylab="Stable stage proportion", xlab="Stage class")
box()

</code></pre>

<hr>
<h2 id='stage.vector.plot'>Plot stage vector projections</h2><span id='topic+stage.vector.plot'></span>

<h3>Description</h3>

<p>Plots short-term dynamics and convergence to stage stage distribution using
stage vector projections
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stage.vector.plot(
  stage.vectors,
  proportions = TRUE,
  legend.coords = "topright",
  ylim = NULL,
  xlab = "Years",
  ylab = NULL,
  col = 1:8,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stage.vector.plot_+3A_stage.vectors">stage.vectors</code></td>
<td>
<p>a matrix listing stage class vectors in columns</p>
</td></tr>
<tr><td><code id="stage.vector.plot_+3A_proportions">proportions</code></td>
<td>
<p>plot proportional changes or total numbers, defaults to proportions</p>
</td></tr>
<tr><td><code id="stage.vector.plot_+3A_legend.coords">legend.coords</code></td>
<td>
<p>a <code><a href="graphics.html#topic+legend">legend</a></code> keyword or vector of x,y coordinates,
defaults to top-right corner</p>
</td></tr>
<tr><td><code id="stage.vector.plot_+3A_ylim">ylim</code></td>
<td>
<p>the y limits of the plot, defaults to min and max values in stage.vectors</p>
</td></tr>
<tr><td><code id="stage.vector.plot_+3A_xlab">xlab</code></td>
<td>
<p>a label for the x axis</p>
</td></tr>
<tr><td><code id="stage.vector.plot_+3A_ylab">ylab</code></td>
<td>
<p>a label for the y axis</p>
</td></tr>
<tr><td><code id="stage.vector.plot_+3A_col">col</code></td>
<td>
<p>vector of line colors</p>
</td></tr>
<tr><td><code id="stage.vector.plot_+3A_...">...</code></td>
<td>
<p>additional options are passed to <code><a href="graphics.html#topic+plot">plot</a></code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>see section 2.2 in Caswell 2001
</p>


<h3>Value</h3>

<p>A plot of stage or age class projections
</p>


<h3>Author(s)</h3>

<p>Chris Stubben
</p>


<h3>See Also</h3>

<p>see <code><a href="#topic+pop.projection">pop.projection</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## matrix from Example 2.1 in Caswell
A &lt;- matrix2(c(
0, 0.3,   0,
1,   0, 0.5,
5,   0,   0
), 1:3)
n &lt;- c(1,0,0)
p &lt;- pop.projection(A,n,60)
## Plots in Figure 2.3
stage.vector.plot(p$stage.vector[,1:15], col='black', las=1, prop=FALSE)
stage.vector.plot(p$stage.vector[,1:40], col=2:4, las=1)
## log-scale with custom y-axis
stage.vector.plot(p$stage.vector, col=2:4, prop=FALSE,
ylim=c(.01, 10), log='y', legend="bottomright", yaxt='n')
pwrs &lt;- -2:1
# major ticks
axis(2, at = 10^pwrs, labels=parse(text=paste("10^", pwrs, sep = "")),
las=1, tcl= -.6)
# minor ticks
axis(2, at = 1:9 * rep(10^pwrs[-1] / 10, each = 9),
    tcl = -0.3, labels = FALSE)

</code></pre>

<hr>
<h2 id='stoch.growth.rate'>Log stochastic growth rate</h2><span id='topic+stoch.growth.rate'></span>

<h3>Description</h3>

<p>Calculates the log stochastic growth rate by Tuljapukar's approximation and by simulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stoch.growth.rate(matrices, prob = NULL, maxt = 50000, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stoch.growth.rate_+3A_matrices">matrices</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> with two or more projection matrices, or
a matrix with one projection matrix per column, with elements filled by columns</p>
</td></tr>
<tr><td><code id="stoch.growth.rate_+3A_prob">prob</code></td>
<td>
<p>a vector of probability weights used by <code><a href="base.html#topic+sample">sample</a></code> for
selecting the projection matrices, defaults to equal probabilities</p>
</td></tr>
<tr><td><code id="stoch.growth.rate_+3A_maxt">maxt</code></td>
<td>
<p>number of time intervals, default 50000</p>
</td></tr>
<tr><td><code id="stoch.growth.rate_+3A_verbose">verbose</code></td>
<td>
<p>Print comment at start of time 1, 10000, 20000, etc.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>converted Matlab code from  Box 7.4 in Morris and Doak (2002)
</p>


<h3>Value</h3>

<p>A list with 3 items
</p>
<table>
<tr><td><code>approx</code></td>
<td>
<p> log stochastic growth rate by  Tuljapukar's approximation </p>
</td></tr>
<tr><td><code>sim</code></td>
<td>
<p> log stochastic growth rate by simulation </p>
</td></tr>
<tr><td><code>sim.CI</code></td>
<td>
<p> confindence interval for simulation</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Chris Stubben
</p>


<h3>References</h3>

<p>Morris, W. F., and D. F. Doak. 2002. Quantitative conservation
biology: Theory and practice of population viability analysis. Sinauer,
Sunderland, Massachusetts, USA.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stoch.projection">stoch.projection</a></code> to output population sizes from simulation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sgr &lt;- stoch.growth.rate(hudsonia)
sgr
exp(sgr$approx)

</code></pre>

<hr>
<h2 id='stoch.projection'>Project stochastic growth from a sequence of matrices</h2><span id='topic+stoch.projection'></span>

<h3>Description</h3>

<p>Projects stochastic growth using whole matrix selection techniques in an
independently and identically distributed (iid) environment from a set of two
or more projection matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stoch.projection(
  matrices,
  n0,
  tmax = 50,
  nreps = 5000,
  prob = NULL,
  nmax = NULL,
  sumweight = rep(1, length(n0)),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stoch.projection_+3A_matrices">matrices</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> with two or more projection matrices</p>
</td></tr>
<tr><td><code id="stoch.projection_+3A_n0">n0</code></td>
<td>
<p>initial population vector</p>
</td></tr>
<tr><td><code id="stoch.projection_+3A_tmax">tmax</code></td>
<td>
<p>number of time steps or projection intervals to predict future population size</p>
</td></tr>
<tr><td><code id="stoch.projection_+3A_nreps">nreps</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="stoch.projection_+3A_prob">prob</code></td>
<td>
<p>a vector of probability weights used by <code><a href="base.html#topic+sample">sample</a></code> for
selecting the projection matrices, defaults  to equal probabilities</p>
</td></tr>
<tr><td><code id="stoch.projection_+3A_nmax">nmax</code></td>
<td>
<p>a maximum number of individuals beyond which population projections
cannot exceed. Default is no density dependence</p>
</td></tr>
<tr><td><code id="stoch.projection_+3A_sumweight">sumweight</code></td>
<td>
<p>A vector of ones and zeros used to omit stage classes when
checking density threshold. Default is to sum across all stage classes</p>
</td></tr>
<tr><td><code id="stoch.projection_+3A_verbose">verbose</code></td>
<td>
<p>Print comments at start of  iteration 1, 100, 200, 300, etc.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>converted Matlab code from  Box 7.3 in Morris and Doak (2002) with nmax option
added to introduce simple density dependence
</p>


<h3>Value</h3>

<p>A matrix listing final population sizes by stage class with one iteration per row.
</p>


<h3>Author(s)</h3>

<p>Chris Stubben
</p>


<h3>References</h3>

<p>Morris, W. F., and D. F. Doak. 2002. Quantitative conservation
biology: Theory and practice of population viability analysis. Sinauer,
Sunderland, Massachusetts, USA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- c(4264, 3,30,16,25,5)
names(n) &lt;- c("seed",  "seedlings", "tiny", "small", "medium" , "large")
## use equal and unequal probabilities for matrix selection
x.eq   &lt;- stoch.projection(hudsonia, n, nreps=1000)
x.uneq &lt;- stoch.projection(hudsonia, n, nreps=1000, prob=c(.2,.2,.2,.4))
hist(apply(x.eq, 1, sum), xlim=c(0,5000), ylim=c(0,200), col="green",
breaks=seq(0,5000, 100), xlab="Final population size at t=50", main='')
par(new=TRUE)
## use transparency for overlapping distributions - may not work on all systems
hist(apply(x.uneq, 1, sum), xlim=c(0,5000), ylim=c(0,200), col=rgb(0, 0, 1, 0.2),
 xaxt='n', yaxt='n', ylab='', xlab='', breaks=seq(0,10000, 100), main='')
legend(2500,200,  c("equal", "unequal"),fill=c("green", rgb(0, 0, 1, 0.2)))
title(paste("Projection of stochastic growth for Hudsonia
using equal and unequal probabilities"), cex.main=1)
## initial pop size
sum(n)
abline(v=sum(n), lty=3)

</code></pre>

<hr>
<h2 id='stoch.quasi.ext'>Quasi-extinction threshold</h2><span id='topic+stoch.quasi.ext'></span>

<h3>Description</h3>

<p>Estimate the quasi-extinction probability by simulation for a structured
population in an an independently and identically distributed stochastic
environment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stoch.quasi.ext(
  matrices,
  n0,
  Nx,
  tmax = 50,
  maxruns = 10,
  nreps = 5000,
  prob = NULL,
  sumweight = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stoch.quasi.ext_+3A_matrices">matrices</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> with two or more projection matrices, or
a matrix with one projection matrix per column, with elements filled by columns</p>
</td></tr>
<tr><td><code id="stoch.quasi.ext_+3A_n0">n0</code></td>
<td>
<p>initial population vector</p>
</td></tr>
<tr><td><code id="stoch.quasi.ext_+3A_nx">Nx</code></td>
<td>
<p>quasi-extinction threshold</p>
</td></tr>
<tr><td><code id="stoch.quasi.ext_+3A_tmax">tmax</code></td>
<td>
<p>number of time steps or projection intervals</p>
</td></tr>
<tr><td><code id="stoch.quasi.ext_+3A_maxruns">maxruns</code></td>
<td>
<p>number of times to simulate cumulative distribution function</p>
</td></tr>
<tr><td><code id="stoch.quasi.ext_+3A_nreps">nreps</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="stoch.quasi.ext_+3A_prob">prob</code></td>
<td>
<p>a vector of probability weights used by <code><a href="base.html#topic+sample">sample</a></code> for
selecting the projection matrices</p>
</td></tr>
<tr><td><code id="stoch.quasi.ext_+3A_sumweight">sumweight</code></td>
<td>
<p>A vector of ones and zeros used to omit stage classes when
checking quasi-extinction threshold.  Default is to sum across all stage classes</p>
</td></tr>
<tr><td><code id="stoch.quasi.ext_+3A_verbose">verbose</code></td>
<td>
<p>Print comment at start of run 1,2,3,etc.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>converted Matlab code from  Box 7.5 in Morris and Doak (2002)
</p>


<h3>Value</h3>

<p>A matrix with quasi-extinction probabilities for each run by columns
</p>


<h3>Author(s)</h3>

<p>Chris Stubben
</p>


<h3>References</h3>

<p>Morris, W. F., and D. F. Doak. 2002. Quantitative conservation
biology: Theory and practice of population viability analysis. Sinauer,
Sunderland, Massachusetts, USA.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stoch.projection">stoch.projection</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- c(4264, 3,30,16,25,5)
names(n) &lt;- c("seed",  "seedlings", "tiny", "small", "medium" , "large")
## exclude seeds using sumweight.  Using 100 nreps for speed
x &lt;- stoch.quasi.ext(hudsonia, n, Nx=10, nreps=100, sumweight=c(0,1,1,1,1,1))
matplot(x, xlab="Years", ylab="Quasi-extinction probability",
 type='l', lty=1, las=1,
 main="Time to reach a quasi-extinction threshold
of 10 above-ground individuals")

</code></pre>

<hr>
<h2 id='stoch.sens'>Stochastic growth rate sensitivity</h2><span id='topic+stoch.sens'></span>

<h3>Description</h3>

<p>Calculates the sensitivity of the stochastic growth rate to perturbations in
the mean demographic projection matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stoch.sens(A, tlimit = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stoch.sens_+3A_a">A</code></td>
<td>
<p>a list of matrices</p>
</td></tr>
<tr><td><code id="stoch.sens_+3A_tlimit">tlimit</code></td>
<td>
<p>time limit, default 100</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function copied from demogR package after it was removed from CRAN.
See section 14.4.1 in Caswell 2001.
</p>


<h3>Value</h3>

<p>A list with two elements:
</p>
<table>
<tr><td><code>sensitivities</code></td>
<td>
<p> sensitivities of the stochastic growth rate </p>
</td></tr>
<tr><td><code>elasticities</code></td>
<td>
<p> elasticities of the stochastic growth rate </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>James Holland Jones
</p>


<h3>References</h3>

<p>Caswell, H. 2001. Matrix population models: construction,
analysis, and interpretation, Second edition. Sinauer, Sunderland,
Massachusetts, USA.
</p>
<p>Haridas, C. V., and S. Tuljapurkar. 2005. Elasticities in variable
environments: Properties and implications. American Naturalist 166
(4):481-495.
</p>
<p>Tuljapurkar, S. 1990. Population dynamics in variable environments.
Vol. 85, Lecture notes in biomathematics. Berlin: Springer-Veralg.
</p>
<p>Tuljapurkar, S., and C. V. Haridas. 2006. Temporal autocorrelation and
stochastic population growth. Ecology Letters 9 (3):324-334.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eigen.analysis">eigen.analysis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stoch.sens(hudsonia)

</code></pre>

<hr>
<h2 id='stretchbetaval'>Stretched beta-distributed random numbers</h2><span id='topic+stretchbetaval'></span>

<h3>Description</h3>

<p>Generate a stretched beta number with mean, standard deviation, minimum and
maximum values and CDF value for bounded fertility estimates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stretchbetaval(mn, std, minb, maxb, fx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stretchbetaval_+3A_mn">mn</code></td>
<td>
<p>mean of a fertility rate</p>
</td></tr>
<tr><td><code id="stretchbetaval_+3A_std">std</code></td>
<td>
<p>standard deviation</p>
</td></tr>
<tr><td><code id="stretchbetaval_+3A_minb">minb</code></td>
<td>
<p>minimum value</p>
</td></tr>
<tr><td><code id="stretchbetaval_+3A_maxb">maxb</code></td>
<td>
<p>maximum value</p>
</td></tr>
<tr><td><code id="stretchbetaval_+3A_fx">fx</code></td>
<td>
<p>Cumulative Distribution Function value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>converted Matlab code from Box 8.5 in Morris and Doak (2002)
</p>


<h3>Value</h3>

<p>Returns a stretched beta number with mean mn, standard deviation std,
minimum and maximum values (minb, maxb) and CDF value fx.
</p>


<h3>Author(s)</h3>

<p>Adapted to R by Patrick Nantel, 11 July 2005.
</p>


<h3>References</h3>

<p>Morris, W. F., and D. F. Doak. 2002. Quantitative conservation
biology: Theory and practice of population viability analysis. Sinauer,
Sunderland, Massachusetts, USA.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+betaval">betaval</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stretchbetaval(3, 1.2, 1, 20, runif(1))
# Generates stretchbeta random
# fertilities for a population of 1000 mature individuals (Ni) with mean
# fertility (f) of 3.0 and inter-individual variance in fertility (varF) of 1.5.
Ni   &lt;- 1000
f    &lt;- 2.5
varF &lt;- 1
fmin &lt;- 1
fmax &lt;- 5
rndfert&lt;-numeric(Ni)
for(i in 1:Ni) rndfert[i] &lt;- stretchbetaval(f, sqrt(varF), fmin, fmax, runif(1)) 
hist(rndfert,20, main="Stretched beta-distributed random fertilities",
 xlab="Fertility rate", , col="blue")

</code></pre>

<hr>
<h2 id='teasel'>Projection matrix for teasel</h2><span id='topic+teasel'></span>

<h3>Description</h3>

<p>Projection matrix with six stage classes for the plant teasel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>teasel
</code></pre>


<h3>Format</h3>

<p>A 6 x 6 matrix
</p>


<h3>Source</h3>

<p>Example 5.2 in Caswell 2001.
</p>


<h3>References</h3>

<p>Caswell, H. 2001. Matrix population models. Construction,
Analysis and interpretation. 2nd ed. Sinauer, Sunderland, Massachusetts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>teasel
image2(teasel, mar = c(1, 3.5, 5, 1), box.offset = .1)
title("Teasel projection matrix", line = 2.5)
# fertilities for a monocarpic plant in a prebreeding census in last column
splitA(teasel, r = 1:6, c = 6)
lambda(teasel)
</code></pre>

<hr>
<h2 id='test.census'>Census data for hypothetical plant</h2><span id='topic+test.census'></span>

<h3>Description</h3>

<p>Three years of census data for a hypothetical plant with three stage classes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.census
</code></pre>


<h3>Format</h3>

<p>A data frame with 41 census rows and 4 columns:
</p>

<dl>
<dt><code>plant</code></dt><dd><p>Plant id number</p>
</dd>
<dt><code>year</code></dt><dd><p>Year of census</p>
</dd>
<dt><code>stage</code></dt><dd><p>Stage class: seedling, vegetative, or reproductive</p>
</dd>
<dt><code>fruits</code></dt><dd><p>Total number of fruits</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>test.census
stages &lt;- c("seedling", "vegetative", "reproductive")
## Cross-tabulate stage vectors and order rows by stage
sv &lt;- table(test.census$stage, test.census$year)[stages, ]
sv
stage.vector.plot(sv)
## set xaxt='n' to avoid fractions of a year (2002.5)
stage.vector.plot(sv, prop = FALSE, xaxt = "n", las = 1)
axis(1, 2001:2003, c(2001, 2002, 2003))
## Convert census data to state-fate transition table using reshape
reshape(test.census, direction = "wide", idvar = "plant", timevar = "year")
## Convert census data  to state-fate transition table using merge
trans &lt;- subset(
  merge(test.census, test.census, by = "plant", sort = FALSE),
  year.x == year.y - 1
)
trans
## Format column and row names
trans &lt;- trans[, c(1:4, 6)]
colnames(trans)[2:5] &lt;- c("year", "stage", "fruits", "fate")
rownames(trans) &lt;- 1:nrow(trans)
## Order stage and fate columns
trans$stage &lt;- ordered(trans$stage, levels = stages)
trans$fate &lt;- ordered(trans$fate, levels = c(stages, "dead"))
## Select transitions for 2001-2002 and count offspring (seedlings)
trans01 &lt;- subset(trans, year == 2001)
seedlings &lt;- nrow(subset(test.census, year == 2002 &amp; stage == "seedling"))
## Add individual fertilities using "anonymous reproduction"  based on the
## proportional reproductive outputs of flowering plants and the total number
## of seedlings at the end of the projection interval
trans01$seedling &lt;- trans01$fruits / sum(trans01$fruits) * seedlings
trans01
##  Create transition frequency table  and build T matrix
tf &lt;- table(trans01$fate, trans01$stage)
tf
## remove "dead" fate from matrix
## T.mat&lt;-prop.table(tf,2)[-4,]
T.mat &lt;- prop.table(tf, 2)[stages, ]
T.mat
## Summarize stage-specific fertility rates and build F matrix
fert &lt;- tapply(trans01$seedling, trans01$stage, mean)
fert
F.mat &lt;- T.mat * 0
F.mat[1, ] &lt;- fert
F.mat
## The final projection matrix is just
T.mat + F.mat
## OR use projection matrix function -
projection.matrix(trans01)
</code></pre>

<hr>
<h2 id='tortoise'>Projection matrices for desert tortoise</h2><span id='topic+tortoise'></span>

<h3>Description</h3>

<p>Projection matrices for the desert tortoise <em>Gopherus agassizii</em> with 4
different fertility estimates (low, medium low, medium high, and high)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tortoise
</code></pre>


<h3>Format</h3>

<p>A list of 4 matrices
</p>


<h3>Source</h3>

<p>Table 5 in Doak et al (1994).  Used by Caswell (2001) in chapter 9 on
sensitivity analysis.
</p>


<h3>References</h3>

<p>Morris, W. F., and D. F. Doak. 2002. Quantitative conservation
biology: Theory and practice of population viability analysis. Sinauer,
Sunderland, Massachusetts, USA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tortoise
A &lt;- tortoise[["med.high"]]
# log color scale not needed
image2(A, mar = c(1, 3.5, 5, 1), log = FALSE, box.off = .1)
title("Tortoise projection matrix", line = 3)
splitA(A)
lambda(A)
sapply(tortoise, lambda)
</code></pre>

<hr>
<h2 id='var2'>Variance matrix</h2><span id='topic+var2'></span>

<h3>Description</h3>

<p>Calculates the variances from a list of matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var2(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var2_+3A_x">x</code></td>
<td>
<p>A list of two or more matrices</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing variances
</p>


<h3>Author(s)</h3>

<p>Chris Stubben
</p>


<h3>Examples</h3>

<pre><code class='language-R'>var2(hudsonia)

</code></pre>

<hr>
<h2 id='varEst'>Estimate the variance of beta-binomial vital rates</h2><span id='topic+varEst'></span>

<h3>Description</h3>

<p>Finds the best estimates of mean and environmental variance for beta-binomial
vital rates using the approximation method of Akcakaya (2002)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varEst(rates, weighted = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varEst_+3A_rates">rates</code></td>
<td>
<p>a matrix or dataframe with four columns: Rate identifier, Year,
Total number of starting individuals, Number surviving (or growing)</p>
</td></tr>
<tr><td><code id="varEst_+3A_weighted">weighted</code></td>
<td>
<p>either 1 for weighted average demographic variance, or 0 for
unweighted average, default is 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with 3 columns: (1) total observed variance, (2) estimate of
variance due to demographic stochasticity, and (3) estimate of variance due
to environmental stochasticity.
</p>


<h3>Author(s)</h3>

<p>Patrick Nantel, 20 June 2005. Last modified May 1st 2007.
</p>


<h3>References</h3>

<p>Akcakaya, H. R. 2002. Estimating the variance of survival rates
and fecundities. Animal Conservation 5: 333-336.
</p>
<p>Kendall, B. E. 1998. Estimating the magnitude of environmental stochasticity
in survivorship data. Ecological Applications 8(1): 184-193.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Kendall">Kendall</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>varEst(woodpecker)

</code></pre>

<hr>
<h2 id='vitalsens'>Vital rate sensitivities and elasticities</h2><span id='topic+vitalsens'></span>

<h3>Description</h3>

<p>Calculates deterministic sensitivities and elasticities of lambda to
lower-level vital rates using partial derivatives
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vitalsens(elements, vitalrates)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vitalsens_+3A_elements">elements</code></td>
<td>
<p>An object of mode <code><a href="base.html#topic+expression">expression</a></code> with all matrix
elements represented by zeros or symbolic vital rates</p>
</td></tr>
<tr><td><code id="vitalsens_+3A_vitalrates">vitalrates</code></td>
<td>
<p>A list of vital rates with <code><a href="base.html#topic+names">names</a></code> matching
expressions in elements above</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vital rate sensitivities and elasticities are discussed in example 9.3 and
9.6 in Caswell (2001). Also see Chapter 9 and Box 9.1 for Matlab code in
Morris and Doak (2002).
</p>


<h3>Value</h3>

<p>A dataframe with vital rate estimates, sensitivities, and elasticities
</p>


<h3>Note</h3>

<p>The element expressions should return the actual matrix element estimates
after evaluating the variables using <code><a href="base.html#topic+eval">eval</a></code> below.
</p>
<p><code>A&lt;-sapply(elements, eval, vitalrates, NULL)</code>
</p>
<p>In addition, these expressions should be arranged by rows so the
following returns the projection matrix.
</p>
<p><code>matrix(A, nrow=sqrt(length(elements)), byrow=TRUE)</code>
</p>


<h3>Author(s)</h3>

<p>Chris Stubben. Based on code posted by Simon Blomberg to R-help mailing list
</p>


<h3>References</h3>

<p>Caswell, H. 2001. Matrix population models: construction,
analysis, and interpretation, Second edition. Sinauer, Sunderland,
Massachusetts, USA.
</p>
<p>Morris, W. F., and D. F. Doak. 2002. Quantitative conservation biology:
Theory and practice of population viability analysis. Sinauer, Sunderland,
Massachusetts, USA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## emperor goose in Morris and Doak 2002.
goose.vr &lt;- list( Ss0=0.1357,  Ss1=0.8926,  Sf2=0.6388,  Sf3= 0.8943)
goose.el &lt;- expression(
0,  0,  Sf2*Ss1,Sf3*Ss1,
Ss0,0,  0,      0,
0,  Ss1,0,      0,
0,  0,  Ss1,    Ss1)
## first plot effects of changing vital rates -- Figure 9.1
n &lt;- length(goose.vr)
vr &lt;- seq(0,1,.1)
vrsen &lt;- matrix(numeric(n*length(vr)), ncol=n, dimnames=list(vr, names(goose.vr)))
for (h in 1:n) {
   goose.vr2 &lt;- list(  Ss0=0.1357,  Ss1=0.8926,  Sf2=0.6388,  Sf3= 0.8943)
   for (i in 1:length(vr))
   {
      goose.vr2[[h]] &lt;- vr[i]
      A &lt;- matrix(sapply(goose.el, eval,goose.vr2 , NULL), nrow=sqrt(length(goose.el)), byrow=TRUE)
      vrsen[i,h] &lt;- max(Re(eigen(A)$values))
   }
}
matplot(rownames(vrsen), vrsen, type='l', lwd=2, las=1,
ylab="Goose population growth", xlab="Value of vital rate",
main="Effects of changing goose vital rates")
vrn &lt;- expression(s[0], s[""&gt;=1], f[2], f[""&gt;=3])
legend(.8, .4, vrn, lty=1:4, lwd=2, col=1:4, cex=1.2)
## then calculate sensitivities  -- Table 9.1
x &lt;- vitalsens(goose.el, goose.vr)
x
sum(x$elasticity)
barplot(t(x[,2:3]), beside=TRUE, legend=TRUE, las=1, xlab="Vital rate",
main="Goose vital rate sensitivity and elasticity")
abline(h=0)
## Table 7 endangered lesser kestral in Hiraldo et al 1996
kest.vr &lt;-  list(b = 0.9321, co = 0.3847, ca = 0.925, so = 0.3409, sa = 0.7107)
kest.el &lt;- expression( co*b*so, ca*b*so, sa, sa)
x &lt;- vitalsens(kest.el, kest.vr)
x
sum(x$elasticity)
barplot(t(x[,2:3]), beside=TRUE, las=1, xlab="Vital rate",
main="Kestral vital rate sensitivity and elasticity")
legend(1,1, rownames(t(x[,2:3])), fill=grey.colors(2))
abline(h=0)

</code></pre>

<hr>
<h2 id='vitalsim'>Stochastic vital rate simulations</h2><span id='topic+vitalsim'></span>

<h3>Description</h3>

<p>Calculates the extinction time CDF and stochastic growth rate by sampling vital
rates from a beta, stretched beta, or lognormal distribution and includes
within-year, auto- and cross-correlations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vitalsim(
  vrmeans,
  vrvars,
  corrin,
  corrout,
  makemx,
  n0,
  yrspan,
  Ne = 500,
  tmax = 50,
  runs = 500,
  vrtypes = NULL,
  vrmins = NULL,
  vrmaxs = NULL,
  sumweight = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vitalsim_+3A_vrmeans">vrmeans</code></td>
<td>
<p>means of vital rates</p>
</td></tr>
<tr><td><code id="vitalsim_+3A_vrvars">vrvars</code></td>
<td>
<p>variance of vital rates</p>
</td></tr>
<tr><td><code id="vitalsim_+3A_corrin">corrin</code></td>
<td>
<p>within year correlation</p>
</td></tr>
<tr><td><code id="vitalsim_+3A_corrout">corrout</code></td>
<td>
<p>between year correlations</p>
</td></tr>
<tr><td><code id="vitalsim_+3A_makemx">makemx</code></td>
<td>
<p>a function that creates a square projection matrix from a
vector of <code>vrmeans</code></p>
</td></tr>
<tr><td><code id="vitalsim_+3A_n0">n0</code></td>
<td>
<p>initial population vector</p>
</td></tr>
<tr><td><code id="vitalsim_+3A_yrspan">yrspan</code></td>
<td>
<p>the number of years of correlations to build into the M12 matrix</p>
</td></tr>
<tr><td><code id="vitalsim_+3A_ne">Ne</code></td>
<td>
<p>quasi-extinction threshold</p>
</td></tr>
<tr><td><code id="vitalsim_+3A_tmax">tmax</code></td>
<td>
<p>latest time to calculate extinction probability, default 50</p>
</td></tr>
<tr><td><code id="vitalsim_+3A_runs">runs</code></td>
<td>
<p>the number of trajectories, default is 500.  1000 is recommended</p>
</td></tr>
<tr><td><code id="vitalsim_+3A_vrtypes">vrtypes</code></td>
<td>
<p>identifies the distribution for each rate in vrmeans where
1 =beta, 2 = stretched beta, 3 = lognormal, default is all ones</p>
</td></tr>
<tr><td><code id="vitalsim_+3A_vrmins">vrmins</code></td>
<td>
<p>minimum value for each vital rate; use zeros for rates that are
not stretched betas, default is all zeros</p>
</td></tr>
<tr><td><code id="vitalsim_+3A_vrmaxs">vrmaxs</code></td>
<td>
<p>maximum value for each vital rate; use zeros for rates that are
not stretched betas, default is all zeros</p>
</td></tr>
<tr><td><code id="vitalsim_+3A_sumweight">sumweight</code></td>
<td>
<p>a vector of weights, with 0 to omit a class and 1 to include
it when computing the summed density to compare to the quasi-extinction
threshold, default is to include all classes</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vital rates used must be either fertility values or binomial probabilities,
i.e., probabilities for events with only two possible outcomes (such as
survival). Means and variances of the vital rates should preferably be
corrected to remove sampling errors and demographic stochasticity.  Note that
this version of the function does not simulate demographic stochasticity and
is density-independent.
</p>


<h3>Value</h3>

<p>Plots a histogram of log stochastic growth rates and the cumulative
probability of quasi-extinction and returns a list with 4 items:
</p>
<table>
<tr><td><code>detLambda</code></td>
<td>
<p>the deterministic population growth rate computed from
the mean matrix</p>
</td></tr>
<tr><td><code>stochlambda</code></td>
<td>
<p>the mean stochastic growth rate with 95% confidence intervals.</p>
</td></tr>
<tr><td><code>logLambdas</code></td>
<td>
<p> a vector of all log stochastic growth rates in first plot</p>
</td></tr>
<tr><td><code>CDFExt</code></td>
<td>
<p>a vector of cumulative probabilities of quasi-extinction in second plot</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The correlation matrices for <em>Hudsonia</em> in Morris and Doak 2002
include some correlations &gt; 1.  A corrected set of correlations was sent by
D. Doak on 8/4/2007.  Therefore the results from the simulation below are
different than the book.
</p>


<h3>Author(s)</h3>

<p>Original MATLAB code from Box 8.10 in Morris and Doak (2002).
Adapted to R by Patrick Nantel, 12 July 2005
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hudmxdef">hudmxdef</a></code>, <code><a href="#topic+hudvrs">hudvrs</a></code> and <code><a href="#topic+hudcorrs">hudcorrs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## set vrtypes
hudvrtypes &lt;- c(rep(1,13), rep(3,5), rep(1,6))
## run Full model- using 100 runs here for speed
full &lt;- vitalsim(hudvrs$mean, hudvrs$var, hudcorrs$corrin,
 hudcorrs$corrout, hudmxdef, vrtypes=hudvrtypes,
 n0=c(4264,3,30,16,25,5), yrspan=20 , runs=100)
## deterministic and stochastic lambda
full[1:2]
## log stochastic lambda
log(full$stochLambda)
sd(full$logLambdas)
## SKIP the next two simulations- however, sample output is included for plotting
#NO between year correlations so corrout = diag(0,13)  - all zeros
# no.between &lt;- vitalsim(hudvrs$mean, hudvrs$var, hudcorrs$corrin,
# diag(0,13), hudmxdef, vrtypes=hudvrtypes,
# n0=c(4264,3,30,16,25,5), yrspan=20 )
no.between &lt;- list(CDFExt=c(rep(0,40),0.01,0.04,0.12,0.15,
0.20,0.31,0.49,0.58,0.72,0.78))
#NO correlations so corrout = diag(0,13) AND corrin=diag(13) - ones on diagonal
# no.corr&lt;-vitalsim(hudvrs$mean, hudvrs$var, diag(13),
# diag(0,13), hudmxdef, vrtypes=hudvrtypes,
# n0=c(4264,3,30,16,25,5), yrspan=20 )
no.corr &lt;- list(CDFExt=c(rep(0,39),0.03,0.03,0.06,0.12,0.20,
0.30,0.42,0.52,0.65,0.76,0.83))
## Figure 8.3 with corrected correlation matrices for full model
matplot(cbind(a=full$CDFExt, no.between$CDFExt, no.corr$CDFExt), type='l',
 ylim=c(0,1), lty=1:3, col=2:4, lwd=2, las=1,
 xlab="Years into the future", ylab="Cumulative probability of quasi-extinction")
legend(2,1, c("Full model", "No between-year correlations", "No correlations"),
 lty=1:3, col=2:4, lwd=2)

</code></pre>

<hr>
<h2 id='whale'>Projection matrix for killer whale</h2><span id='topic+whale'></span>

<h3>Description</h3>

<p>Projection matrix for killer whales with 4 size classes: yearling, juvenile,
mature and post-reproductive
</p>


<h3>Usage</h3>

<pre><code class='language-R'>whale
</code></pre>


<h3>Format</h3>

<p>A 4 x 4 matrix
</p>


<h3>Source</h3>

<p>Example 5.1 in Caswell (2001)
</p>


<h3>References</h3>

<p>Caswell, H. 2001. Matrix population models. Construction,
Analysis and interpretation. 2nd ed. Sinauer, Sunderland, Massachusetts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>whale
splitA(whale)
lambda(whale)
sensitivity(whale)
# plot sensitivity
matplot2(sensitivity(whale),
  type = "b", legend = "topleft", ltitle = "Fate",
  main = "Killer Whale sensitivity"
)
</code></pre>

<hr>
<h2 id='woodpecker'>Survirvorship data for adult and juvenile Acorn Woodpeckers</h2><span id='topic+woodpecker'></span>

<h3>Description</h3>

<p>Number of juvenile and adult Acorn Woodpeckers and survival in the Water
Canyon, New Mexico population, reconstructed from Stacey and Taper (1992).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>woodpecker
</code></pre>


<h3>Format</h3>

<p>A data frame with 18 rows and 4 columns
</p>

<dl>
<dt><code>rate</code></dt><dd><p> Adult or juvenile stage</p>
</dd>
<dt><code>year</code></dt><dd><p> Year</p>
</dd>
<dt><code>start</code></dt><dd><p> Total number of starting individuals</p>
</dd>
<dt><code>surv</code></dt><dd><p> Number surviving to spring</p>
</dd>
</dl>



<h3>Source</h3>

<p>Stacey, P.B., and M. Taper. 1992. Environmental variation and the
persistence of small populations. Ecological Applications 2: 18-29.
</p>


<h3>References</h3>

<p>Akcakaya, H. R. 2002. Estimating the variance of survival rates
and fecundities. Animal Conservation 5: 333-336.
Kendall, B. E. 1998. Estimating the magnitude of environmental stochasticity
in survivorship data. Ecological Applications 8(1): 184-193.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Kendall">Kendall</a></code> and <code><a href="#topic+varEst">varEst</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>woodpecker
x &lt;- subset(woodpecker, rate == "adult")
plot(x$year, x$start,
  type = "o", pch = 16,
  ylab = "Number of adults", xlab = "Year",
  main = "Acorn Woodpeckers in Water Canyon"
)
## stage-specific survival rate
x &lt;- aggregate(
  list(Nstart = woodpecker$start, Nsurv = woodpecker$surv),
  list(stage = woodpecker$rate), sum
)
x$survival &lt;- x[, 3] / x[, 2]
x
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
