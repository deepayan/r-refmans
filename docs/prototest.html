<!DOCTYPE html><html lang="en"><head><title>Help for package prototest</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {prototest}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#prototest-package'>
<p>Inference on Prototypes from Clusters of Features</p></a></li>
<li><a href='#print.prototest'>
<p>Print <code>prototest</code> object</p></a></li>
<li><a href='#prototest.multivariate'>
<p>Perform Prototype or F tests for Significance of Groups of Predictors in the Multivariate Model</p></a></li>
<li><a href='#prototest.univariate'>
<p>Perform Prototype or F Tests for Significance of Groups of Predictors in the Univariate Model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Inference on Prototypes from Clusters of Features</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-02-02</td>
</tr>
<tr>
<td>Author:</td>
<td>Stephen Reid</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stephen Reid &lt;sreid1652@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>intervals, MASS, glmnet</td>
</tr>
<tr>
<td>Description:</td>
<td>Procedures for testing for group-wide signal in clusters of variables. Tests can be performed for single groups in isolation (univariate) or multiple groups together (multivariate). Specific tests include the exact and approximate (un)selective likelihood ratio tests described in Reid et al (2015), the selective F test and marginal screening prototype test of Reid and Tibshirani (2015). User may pre-specify columns to be included in prototype formation, or allow the function to select them itself. A mixture of these two is also possible. Any variable selection is accounted for using the selective inference framework. Options for non-sampling and hit-and-run null reference distributions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.1)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://arxiv.org/abs/1511.07839">http://arxiv.org/abs/1511.07839</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-02-02 21:24:48 UTC; stephen</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-02-03 11:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='prototest-package'>
Inference on Prototypes from Clusters of Features
</h2><span id='topic+prototest-package'></span><span id='topic+prototest'></span>

<h3>Description</h3>

<p>Procedures for testing for group-wide signal in clusters of variables. Tests can be perfromed for single groups in isolation (univariate) or multiple groups together (multivariate). Specific tests include the exact and approximate (un)selective likelihood ratio (ELR, ALR) tests described in Reid et al (2015), the selective F test and marginal screening prototype test of Reid and Tibshirani (2015). User may prespecify columns to be included in prototype formation, or allow the function to select them itself. A mixture of these two is also possible. Any variable selection is accounted for using the selective inference framework introduced in Lee et al (2013) and further developed in Lee and Taylor (2014). Options for non-sampling and hit-and-run null reference distrbutions. Tests are examples of selected model tests, a notion introduced in Fithian et al (2015).
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> prototest</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2015-11-12</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Only two functions provided: <code>prototest.univariate</code> (for tests with a single group in isolation) and <code>prototest.multivariate</code> (for tests with multiple groups simultaneously). Each function provides options to perform one of the ELR, ALR, F or marginal screening prototype tests. User may specify which columns are to be used in prototype construction, or leave it for the function to select. Valid tests are performed in the event of variable selection. User has option to use non-sampling null reference distributions (where available) or hit-and-run references.
</p>


<h3>Author(s)</h3>

<p>Stephen Reid
</p>
<p>Maintainer: Stephen Reid &lt;sreid@stanford.edu&gt;
</p>


<h3>References</h3>

<p>Reid, S. and Tibshirani, R. (2015) <em>Sparse regression and marginal testing using cluster prototypes</em>. <a href="http://arxiv.org/pdf/1503.00334v2.pdf">http://arxiv.org/pdf/1503.00334v2.pdf</a>. <em>Biostatistics <a href="http://doi.org/10.1093/biostatistics/kxv049">doi: 10.1093/biostatistics/kxv049</a></em><br />
Reid, S., Taylor, J. and Tibshirani, R. (2015) <em>A general framework for estimation and inference from clusters of features</em>. Available online: <a href="http://arxiv.org/abs/1511.07839">http://arxiv.org/abs/1511.07839</a><br />
Lee, J.D., Sun, D.L., Sun, Y. and Taylor, J.E. (2013) <em>Exact post-selection inference, with application to the lasso</em>. <a href="http://arxiv.org/pdf/1311.6238v6.pdf">http://arxiv.org/pdf/1311.6238v6.pdf</a>. <em>Annals of Statistics (to appear)</em><br />
Lee, J.D. and Taylor, J.E. (2014) <em>Exact Post Model Selection Inference for Marginal Screening</em>. <a href="http://arxiv.org/pdf/1402.5596v2.pdf">http://arxiv.org/pdf/1402.5596v2.pdf</a><br />
Fithian, W., Sun, D.L. and Taylor, J.E. (2015) <em>Optimal Inference After Model Selection</em>. <a href="http://arxiv.org/pdf/1410.2597v2.pdf">http://arxiv.org/pdf/1410.2597v2.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require (prototest)

### generate data
set.seed (12345)
n = 100
p = 80

X = matrix (rnorm(n*p, 0, 1), ncol=p)


beta = rep(0, p)
beta[1:3] = 0.1 # three signal variables: number 1, 2, 3
signal = apply(X, 1, function(col){sum(beta*col)})
intercept = 3

y = intercept + signal + rnorm (n, 0, 1)

### treat all columns as if in same group and test for signal

# non-selective ELR test with nuisance intercept
elr = prototest.univariate (X, y, "ELR", selected.col=1:5)
# selective F test with nuisance intercept; non-sampling
f.test = prototest.univariate (X, y, "F", lambda=0.01, hr.iter=0) 
print (elr)
print (f.test)

### assume variables occur in 4 equally sized groups
num.groups = 4
groups = rep (1:num.groups, each=p/num.groups)

# selective ALR test -- select columns 21-25 in 2nd group; test for signal in 1st; hit-and-run
alr = prototest.multivariate(X, y, groups, 1, "ALR", 21:25, lambda=0.005, hr.iter=20000)
# non-selective MS test -- specify first column in each group; test for signal in 1st
ms = prototest.multivariate(X, y, groups, 1, "MS", c(1,21,41,61)) 
print (alr)
print (ms)
</code></pre>

<hr>
<h2 id='print.prototest'>
Print <code>prototest</code> object
</h2><span id='topic+print.prototest'></span>

<h3>Description</h3>

<p>Generic <code>print</code> method for <code>prototest</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'prototest'
 print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.prototest_+3A_x">x</code></td>
<td>
<p>object of type <code>prototest</code>.</p>
</td></tr>
<tr><td><code id="print.prototest_+3A_...">...</code></td>
<td>
<p>other parameters passed to <code>print</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints the test statistic and p-value associated with the <code>prototest</code> object <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Stephen Reid
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prototest.univariate">prototest.univariate</a></code>, <code><a href="#topic+prototest.multivariate">prototest.multivariate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require (prototest)

### generate data
set.seed (12345)
n = 100
p = 80

X = matrix (rnorm(n*p, 0, 1), ncol=p)


beta = rep(0, p)
beta[1:3] = 2 # three signal variables: number 1, 2, 3
signal = apply(X, 1, function(col){sum(beta*col)})
intercept = 3

y = intercept + signal + rnorm (n, 0, 1)

### treat all columns as if in same group and test for signal

# non-selective ELR test with nuisance intercept
elr = prototest.univariate (X, y, "ELR", selected.col=1:5) 
print (elr)
</code></pre>

<hr>
<h2 id='prototest.multivariate'>
Perform Prototype or F tests for Significance of Groups of Predictors in the Multivariate Model
</h2><span id='topic+prototest.multivariate'></span>

<h3>Description</h3>

<p>Perform prototype or F tests for significance of groups of predictors in the multivariate model. Choose either exact or approximate likelihood ratio prototype tests (ELR) or (ALR) or F test or marginal screening prototype test. Options for selective or non-selective tests. Further options for non-sampling or hit-and-run reference distributions for selective tests. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prototest.multivariate(x, y, groups, test.group, type = c("ELR", "ALR", "F", "MS"), 
selected.col = NULL, lambda, mu = NULL, sigma = 1, 
hr.iter = 50000, hr.burn.in = 5000, verbose = FALSE, tol = 10^-8)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prototest.multivariate_+3A_x">x</code></td>
<td>

<p>input matrix of dimension <em>n</em>-by-<em>p</em>, where <em>p</em> is the number of predictors over all predictor groups of interest. Will be mean centered and standardised before tests are performed.
</p>
</td></tr>
<tr><td><code id="prototest.multivariate_+3A_y">y</code></td>
<td>

<p>response variable. Vector of length <em>n</em>, assumed to be quantitative.
</p>
</td></tr>
<tr><td><code id="prototest.multivariate_+3A_groups">groups</code></td>
<td>

<p>group membership of the columns of <code>x</code>. Vector of length <em>p</em>, which each element containing the goup label of the corresponding column in <code>x</code>.
</p>
</td></tr>
<tr><td><code id="prototest.multivariate_+3A_test.group">test.group</code></td>
<td>

<p>group label for which we test nullity. Should be one of the values seen in <code>groups</code>. See Details for further explanation.
</p>
</td></tr>
<tr><td><code id="prototest.multivariate_+3A_type">type</code></td>
<td>

<p>type of test to be performed. Can select one at a time. Options include the exact and approximate likelihood ratio prototype tests of Reid et al (2015) (ELR, ALR), the F test and the marginal screening prototype test of Reid and Tibshirani (2015) (MS). Default is ELR.
</p>
</td></tr>
<tr><td><code id="prototest.multivariate_+3A_selected.col">selected.col</code></td>
<td>

<p>preselected columns selected by the user. Vector of indices in the set {1, 2, ... <em>p</em>}. Used in conjunction with <code>groups</code> to ascertain for which groups the user has specified selected columns. Should it find any selected columns within a group, no further action is taken to select columns. Should no columns within a group be specified, columns are selected using either lasso or the marginal screening procedure, depending on the test. If all groups have prespecified columns, a non-selective test is performed, using the classical distributional assumptions (exact and/or asymptotic) for the test in question. If any selection is performed, selective tests are performed. Default is <code>NULL</code>, requiring the selection of columns in all the groups. 
</p>
</td></tr>
<tr><td><code id="prototest.multivariate_+3A_lambda">lambda</code></td>
<td>

<p>regularisation parameter for the lasso fit. Same for each group. Must be supplied when at least one group has unspecified columns in <code>selected.col</code>. Will be supplied to <code>glmnet</code>. This is the unstandardised version, equivalent to <code>lambda</code>/<code>n</code> supplied to <code>glmnet</code>.
</p>
</td></tr>
<tr><td><code id="prototest.multivariate_+3A_mu">mu</code></td>
<td>

<p>mean parameter for the response. See Details below. If supplied, it is first subtracted from the response to yield a zero-mean (at the population level) vector for which we proceed with testing. If <code>NULL</code> (the default), this parameter is treated as nuisance parameter and accounted for as such in testing.
</p>
</td></tr>
<tr><td><code id="prototest.multivariate_+3A_sigma">sigma</code></td>
<td>

<p>error standard deviation for the response. See Details below. Must be supplied. If not, it is assumed to be 1. Required for computation of some of the test statistics.
</p>
</td></tr>
<tr><td><code id="prototest.multivariate_+3A_hr.iter">hr.iter</code></td>
<td>

<p>number of hit-and-run samples required in the reference distribution of the a selective test. Applies only if <code>selected.col</code> is <code>NULL</code>. Default is 50000. Since dependent samples are generated, large values are required to generate good reference distributions. If set to 0, the function tries to applu a non-sampling selective test (provided <code>selected.col</code> is <code>NULL</code>), if possible. If non-sampling test is not possible, the function exits with a message.
</p>
</td></tr>
<tr><td><code id="prototest.multivariate_+3A_hr.burn.in">hr.burn.in</code></td>
<td>

<p>number of burn-in hit-and-run samples. These are generated first so as to make subsequent hit-and-run realisations less dependent on the observed response. Samples are then discarded and do not inform the null reference distribution.
</p>
</td></tr>
<tr><td><code id="prototest.multivariate_+3A_verbose">verbose</code></td>
<td>

<p>should progress be printed?
</p>
</td></tr>
<tr><td><code id="prototest.multivariate_+3A_tol">tol</code></td>
<td>

<p>convergence threshold for iterative optimisation procedures.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model underpinning each of the tests is </p>
<p style="text-align: center;"><code class="reqn">
	y = \mu + \sum_{k = 1}^K \theta_k\cdot\hat{y}_k + \epsilon</code>
</p>

<p>where <code class="reqn">\epsilon \sim N(0, \sigma^2I)</code> and <em>K</em> is the number of predictor groups. <code class="reqn">\hat{y}_k</code> depends on the particular test considered.
</p>
<p>In particular, for the ELR, ALR and F tests, we have <code class="reqn">\hat{y}_k = P_{M_k}\left(y-\mu\right)</code>, where <code class="reqn">P_{M_k} = X_{M_k}\left(X_{M_k}^\top X_{M_k}\right)^{-1}X_{M_k}^\top</code>. <code class="reqn">X_M</code> is the input matrix reduced to the columns with indices in the set <em>M</em>. <code class="reqn">M_k</code> is the set of indices selected from considering group <em>k</em> of predictors in isolation. This set is either provided by the user (via <code>selected.col</code>) or is selected automatically (if <code>selected.col</code> is <code>NULL</code>). If the former, a non-selective test is performed; if the latter, a selective test is performed, with the restrictions <code class="reqn">Ay \leq b</code>, as set out in Lee et al (2015) and stacked as in Reid and Tibshirani (2015). 
</p>
<p>For the marginal screening prototype (MS) test, <code class="reqn">\hat{y}_k = x_{j^*}</code> where <code class="reqn">x_j</code> is the <code class="reqn">j^{th}</code> column of <code>x</code> and <code class="reqn">j^* = {\rm argmax}_{j \in C_k} |x_j^\top y|</code>, where <code class="reqn">C_k</code> is the set of indices in the overall predictor set corresponding to predictors in the <code class="reqn">k^{th}</code> group.
</p>
<p>All tests test the null hypothesis <code class="reqn">H_0: \theta_{k^*} = 0</code>, where <code class="reqn">k^*</code> is supplied by the user via <code>test.group</code>. Details of each are described in Reid et al (2015). 
</p>


<h3>Value</h3>

<p>A list with the following four components:
</p>
<table role = "presentation">
<tr><td><code>ts</code></td>
<td>
<p>The value of the test statistic on the observed data.</p>
</td></tr>
<tr><td><code>p.val</code></td>
<td>
<p>Valid p-value of the test.</p>
</td></tr>
<tr><td><code>selected.col</code></td>
<td>
<p>Vector with columns selected for prototype formation in the test. If initially <code>NULL</code>, this will now contain indices of columns selected by the automatic column selection procedures of the test.</p>
</td></tr>
<tr><td><code>y.hr</code></td>
<td>
<p>Matrix with hit-and-run replications of the response. If sampled selective test was not performed, this will be <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stephen Reid
</p>


<h3>References</h3>

<p>Reid, S. and Tibshirani, R. (2015) <em>Sparse regression and marginal testing using cluster prototypes</em>. <a href="http://arxiv.org/pdf/1503.00334v2.pdf">http://arxiv.org/pdf/1503.00334v2.pdf</a>. <em>Biostatistics <a href="http://doi.org/10.1093/biostatistics/kxv049">doi: 10.1093/biostatistics/kxv049</a></em><br />
Reid, S., Taylor, J. and Tibshirani, R. (2015) <em>A general framework for estimation and inference from clusters of features</em>. Available online: <a href="http://arxiv.org/abs/1511.07839">http://arxiv.org/abs/1511.07839</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prototest.univariate">prototest.univariate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require (prototest)

### generate data
set.seed (12345)
n = 100
p = 80

X = matrix (rnorm(n*p, 0, 1), ncol=p)


beta = rep(0, p)
beta[1:3] = 0.1 # three signal variables: number 1, 2, 3
signal = apply(X, 1, function(col){sum(beta*col)})
intercept = 3

y = intercept + signal + rnorm (n, 0, 1)

### treat all columns as if in same group and test for signal

# non-selective ELR test with nuisance intercept
elr = prototest.univariate (X, y, "ELR", selected.col=1:5)
# selective F test with nuisance intercept; non-sampling
f.test = prototest.univariate (X, y, "F", lambda=0.01, hr.iter=0) 
print (elr)
print (f.test)

### assume variables occur in 4 equally sized groups
num.groups = 4
groups = rep (1:num.groups, each=p/num.groups)

# selective ALR test -- select columns 21-25 in 2nd group; test for signal in 1st; hit-and-run
alr = prototest.multivariate(X, y, groups, 1, "ALR", 21:25, lambda=0.005, hr.iter=20000)
# non-selective MS test -- specify first column in each group; test for signal in 1st
ms = prototest.multivariate(X, y, groups, 1, "MS", c(1,21,41,61)) 
print (alr)
print (ms)
</code></pre>

<hr>
<h2 id='prototest.univariate'>
Perform Prototype or F Tests for Significance of Groups of Predictors in the Univariate Model
</h2><span id='topic+prototest.univariate'></span>

<h3>Description</h3>

<p>Perform prototype or F tests for significance of groups of predictors in the univariate model. Choose either exact or approximate likelihood ratio prototype tests (ELR) or (ALR) or F test or marginal screening prototype test. Options for selective or non-selective tests. Further options for non-sampling or hit-and-run null reference distributions for selective tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prototest.univariate(x, y, type = c("ALR", "ELR", "MS", "F"), 
selected.col = NULL, lambda, mu = NULL, sigma = 1, hr.iter = 50000, 
hr.burn.in = 5000, verbose = FALSE, tol = 10^-8)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prototest.univariate_+3A_x">x</code></td>
<td>

<p>input matrix of dimension <em>n</em>-by-<em>p</em>, where <em>p</em> is the number of predictors in a single predetermined group of predictors. Will be mean centered and standardised before tests are performed. 
</p>
</td></tr>
<tr><td><code id="prototest.univariate_+3A_y">y</code></td>
<td>

<p>response variable. Vector of length emphn, assumed to be quantitative.
</p>
</td></tr>
<tr><td><code id="prototest.univariate_+3A_type">type</code></td>
<td>

<p>type of test to be performed. Can only select one at a time. Options include the exact and approximate likelihood ratio prototype tests of Reid et al (2015) (ELR, ALR), the F test and the marginal screening prototype test of Reid and Tibshirani (2015) (MS). Default is ELR.
</p>
</td></tr>
<tr><td><code id="prototest.univariate_+3A_selected.col">selected.col</code></td>
<td>

<p>preselected columns specified by user. Vector of indices in the set {1, 2, ..., <em>p</em>}. If specified, a <em>non-selective</em> (classical) version of the chosen test it performed. In particular, this means the classicial <code class="reqn">\chi^2_1</code> reference distribution for the likelihood ratio tests and the F reference for the F test. Default is <code>NULL</code>, which directs the function to estimate the selected set with the lasso or the marginal screening procedure, depending on the test.
</p>
</td></tr>
<tr><td><code id="prototest.univariate_+3A_lambda">lambda</code></td>
<td>

<p>regularisation parameter for the lasso fit. Must be supplied when <code>selected.col</code> is <code>NULL</code>. Will be supplied to <code>glmnet</code>. This is the unstandardised version, equivalent to <code>lambda</code>/<em>n</em> supplied to <code>glmnet</code>.
</p>
</td></tr>
<tr><td><code id="prototest.univariate_+3A_mu">mu</code></td>
<td>

<p>mean parameter for the response. See Details below. If supplied, it is first subtracted from the response to yield a mean-zero (at the population level) vector for which we proceed with testing. If <code>NULL</code> (the default), this parameter is treated as nuisance parameter and accounted for as such in testing.
</p>
</td></tr>
<tr><td><code id="prototest.univariate_+3A_sigma">sigma</code></td>
<td>

<p>error standard deviation for the response. See Details below. Must be supplied. If not, it is assumed to be 1. Required for the computation of some of the test statistics.
</p>
</td></tr>
<tr><td><code id="prototest.univariate_+3A_hr.iter">hr.iter</code></td>
<td>

<p>number of hit-and-run samples required in the reference distrbution of a selective test. Applies only if <code>selected.col</code> is <code>NULL</code>. Default is 50000. Since dependent samples are generated, large values are required to generate good reference distributions. If set to 0, the function tries to apply a non-sampling selective test (provided <code>selected.col</code> is <code>NULL</code>), if possible. If non-sampling test is not possible, the function exits with a message.
</p>
</td></tr>
<tr><td><code id="prototest.univariate_+3A_hr.burn.in">hr.burn.in</code></td>
<td>

<p>number of burn-in hit-and-run samples. These are generated first so as to make subsequent hit-and-run realisations less dependent on the observed response. Samples are then discarded and do not inform the null reference distribution.
</p>
</td></tr>
<tr><td><code id="prototest.univariate_+3A_verbose">verbose</code></td>
<td>

<p>should progress be printed?
</p>
</td></tr>
<tr><td><code id="prototest.univariate_+3A_tol">tol</code></td>
<td>

<p>convergence threshold for iterative optimisation procedures.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model underpinning each of the tests is
</p>
<p style="text-align: center;"><code class="reqn">
	y = \mu + \theta\cdot\hat{y} + \epsilon
</code>
</p>

<p>where <code class="reqn">\epsilon \sim N(0, \sigma^2I)</code> and <code class="reqn">\hat{y}</code> depends on the particular test considered. 
</p>
<p>In particular, for the ELR, ALR and F tests, we have <code class="reqn">\hat{y} = P_M\left(y - \mu\right)</code>, where <code class="reqn">P_M = X_M\left(X_M^\top X_M\right)^{-1}X_M^\top</code>. <code class="reqn">X_M</code> is the input matrix reduced to the columns in the set <em>M</em>, which, in turn, is either provided by the user (via <code>selected.col</code>) or selected by the lasso (if <code>selected.col</code> is <code>NULL</code>). If the former, a non-selective test is performed; if the latter, a selective test is performed, with the restrictions <code class="reqn">Ay\leq b</code>, as set out in Lee et al (2015). 
</p>
<p>For the marginal screening prototype (MS) test, <code class="reqn">\hat{y} = x_{j^*}</code> where <code class="reqn">x_j</code> is the <code class="reqn">j^{th}</code> column of <code>x</code> and <code class="reqn">j^* = {\rm argmax}_j |x_j^\top y|</code>.
</p>
<p>All tests test the null hypothesis <code class="reqn">H_0: \theta = 0</code>. Details of each are described in Reid et al (2015).
</p>


<h3>Value</h3>

<p>A list with the following four components:
</p>
<table role = "presentation">
<tr><td><code>ts</code></td>
<td>
<p>The value of the test statistic on the observed data.</p>
</td></tr>
<tr><td><code>p.val</code></td>
<td>
<p>Valid p-value of the test.</p>
</td></tr>
<tr><td><code>selected.col</code></td>
<td>
<p>Vector with columns selected. If initially <code>NULL</code>, this will now contain indices of columns selected by the automatic column selection procedures of the test.</p>
</td></tr>
<tr><td><code>y.hr</code></td>
<td>
<p>Matrix with hit-and-run replications of the response. If sampled selective test was not performed, this will be <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stephen Reid
</p>


<h3>References</h3>

<p>Reid, S. and Tibshirani, R. (2015) <em>Sparse regression and marginal testing using cluster prototypes</em>. <a href="http://arxiv.org/pdf/1503.00334v2.pdf">http://arxiv.org/pdf/1503.00334v2.pdf</a>. <em>Biostatistics <a href="http://doi.org/10.1093/biostatistics/kxv049">doi: 10.1093/biostatistics/kxv049</a></em><br />
Reid, S., Taylor, J. and Tibshirani, R. (2015) <em>A general framework for estimation and inference from clusters of features</em>. Available online: <a href="http://arxiv.org/abs/1511.07839">http://arxiv.org/abs/1511.07839</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prototest.multivariate">prototest.multivariate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require (prototest)

### generate data
set.seed (12345)
n = 100
p = 80

X = matrix (rnorm(n*p, 0, 1), ncol=p)


beta = rep(0, p)
beta[1:3] = 0.1 # three signal variables: number 1, 2, 3
signal = apply(X, 1, function(col){sum(beta*col)})
intercept = 3

y = intercept + signal + rnorm (n, 0, 1)

### treat all columns as if in same group and test for signal

# non-selective ELR test with nuisance intercept
elr = prototest.univariate (X, y, "ELR", selected.col=1:5)
# selective F test with nuisance intercept; non-sampling
f.test = prototest.univariate (X, y, "F", lambda=0.01, hr.iter=0) 
print (elr)
print (f.test)

### assume variables occur in 4 equally sized groups
num.groups = 4
groups = rep (1:num.groups, each=p/num.groups)

# selective ALR test -- select columns 21-25 in 2nd group; test for signal in 1st; hit-and-run
alr = prototest.multivariate(X, y, groups, 1, "ALR", 21:25, lambda=0.005, hr.iter=20000)
# non-selective MS test -- specify first column in each group; test for signal in 1st
ms = prototest.multivariate(X, y, groups, 1, "MS", c(1,21,41,61)) 
print (alr)
print (ms)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
