<!DOCTYPE html><html><head><title>Help for package TSP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TSP}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ATSP'><p>Class ATSP &ndash; Asymmetric traveling salesperson problem</p></a></li>
<li><a href='#Concorde'><p>Using the Concorde TSP Solver</p></a></li>
<li><a href='#cut_tour'><p>Cut a tour to form a path</p></a></li>
<li><a href='#ETSP'><p>Class ETSP &ndash; Euclidean traveling salesperson problem</p></a></li>
<li><a href='#insert_dummy'><p>Insert dummy cities into a distance matrix</p></a></li>
<li><a href='#reformulate_ATSP_as_TSP'><p>Reformulate a ATSP as a symmetric TSP</p></a></li>
<li><a href='#solve_TSP'><p>TSP solver interface</p></a></li>
<li><a href='#TOUR'><p>Class TOUR &ndash; Solution to a traveling salesperson problem</p></a></li>
<li><a href='#tour_length'><p>Calculate the length of a tour</p></a></li>
<li><a href='#TSP'><p>Class TSP &ndash; Symmetric traveling salesperson problem</p></a></li>
<li><a href='#TSP-package'><p>TSP: Traveling Salesperson Problem (TSP)</p></a></li>
<li><a href='#TSPLIB'><p>Read and write TSPLIB files</p></a></li>
<li><a href='#USCA'><p>USCA312/USCA50 &ndash; 312/50 cities in the US and Canada</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Traveling Salesperson Problem (TSP)</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2-4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-04-03</td>
</tr>
<tr>
<td>Description:</td>
<td>Basic infrastructure and some algorithms for the traveling
    salesperson problem (also traveling salesman problem; TSP).
    The package provides some simple algorithms and
    an interface to the Concorde TSP solver and its implementation of the
    Chained-Lin-Kernighan heuristic. The code for Concorde
    itself is not included in the package and has to be obtained separately.
    Hahsler and Hornik (2007) &lt;<a href="https://doi.org/10.18637%2Fjss.v023.i02">doi:10.18637/jss.v023.i02</a>&gt;.</td>
</tr>
<tr>
<td>Classification/ACM:</td>
<td>G.1.6, G.2.1, G.4</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mhahsler/TSP">https://github.com/mhahsler/TSP</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mhahsler/TSP/issues">https://github.com/mhahsler/TSP/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, foreach, utils, stats, grDevices</td>
</tr>
<tr>
<td>Suggests:</td>
<td>maps, doParallel, testthat</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Copyright:</td>
<td>All code is Copyright (C) Michael Hahsler and Kurt Hornik.</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-04 01:12:42 UTC; hahsler</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Hahsler <a href="https://orcid.org/0000-0003-2716-1405"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Kurt Hornik <a href="https://orcid.org/0000-0003-4198-9911"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Hahsler &lt;mhahsler@lyle.smu.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-04 15:30:12 UTC</td>
</tr>
</table>
<hr>
<h2 id='ATSP'>Class ATSP &ndash; Asymmetric traveling salesperson problem</h2><span id='topic+ATSP'></span><span id='topic+as.ATSP'></span><span id='topic+as.ATSP.matrix'></span><span id='topic+as.ATSP.dist'></span><span id='topic+print.ATSP'></span><span id='topic+n_of_cities.ATSP'></span><span id='topic+labels.ATSP'></span><span id='topic+image.ATSP'></span><span id='topic+as.matrix.ATSP'></span>

<h3>Description</h3>

<p>Constructor to create an instance of the asymmetric traveling salesperson
problem (ATSP) and some auxiliary methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ATSP(x, labels = NULL, method = NULL)

as.ATSP(x)

## S3 method for class 'matrix'
as.ATSP(x)

## S3 method for class 'dist'
as.ATSP(x)

## S3 method for class 'ATSP'
print(x, ...)

## S3 method for class 'ATSP'
n_of_cities(x)

## S3 method for class 'ATSP'
labels(object, ...)

## S3 method for class 'ATSP'
image(x, order, col = gray.colors(64), ...)

## S3 method for class 'ATSP'
as.matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ATSP_+3A_x">x</code>, <code id="ATSP_+3A_object">object</code></td>
<td>
<p>an object (a square matrix) to be converted into an
<code>ATSP</code> or, for the methods, an object of class <code>ATSP</code>.</p>
</td></tr>
<tr><td><code id="ATSP_+3A_labels">labels</code></td>
<td>
<p>optional city labels. If not given, labels are taken from
<code>x</code>.</p>
</td></tr>
<tr><td><code id="ATSP_+3A_method">method</code></td>
<td>
<p>optional name of the distance metric.</p>
</td></tr>
<tr><td><code id="ATSP_+3A_...">...</code></td>
<td>
<p>further arguments are passed on.</p>
</td></tr>
<tr><td><code id="ATSP_+3A_order">order</code></td>
<td>
<p>order of cities as an integer vector or an object of class
<code>TOUR</code>.</p>
</td></tr>
<tr><td><code id="ATSP_+3A_col">col</code></td>
<td>
<p>color scheme for image.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Objects of class <code>ATSP</code> are internally represented by a matrix (use
<code>as.matrix()</code> to get just the matrix).
</p>
<p>ATSPs can be transformed into (larger) symmetric TSPs using
<code><a href="#topic+reformulate_ATSP_as_TSP">reformulate_ATSP_as_TSP()</a></code>.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>ATSP()</code> returns <code>x</code> as an object of class <code>ATSP</code>.
</p>
</li>
<li> <p><code>n_of_cities()</code> returns the number of cities in <code>x</code>.
</p>
</li>
<li> <p><code>labels()</code> returns a vector with the names of the cities in <code>x</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other TSP: 
<code><a href="#topic+Concorde">Concorde</a></code>,
<code><a href="#topic+ETSP">ETSP</a>()</code>,
<code><a href="#topic+TSPLIB">TSPLIB</a></code>,
<code><a href="#topic+TSP">TSP</a>()</code>,
<code><a href="#topic+insert_dummy">insert_dummy</a>()</code>,
<code><a href="#topic+reformulate_ATSP_as_TSP">reformulate_ATSP_as_TSP</a>()</code>,
<code><a href="#topic+solve_TSP">solve_TSP</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- matrix(runif(10^2), ncol = 10, dimnames = list(1:10, 1:10))

atsp &lt;- ATSP(data)
atsp

## use some methods
n_of_cities(atsp)
labels(atsp)

## calculate a tour
tour &lt;- solve_TSP(atsp, method = "nn")
tour

tour_length(tour)

image(atsp, tour)
</code></pre>

<hr>
<h2 id='Concorde'>Using the Concorde TSP Solver</h2><span id='topic+Concorde'></span><span id='topic+concorde'></span><span id='topic+concorde_path'></span><span id='topic+concorde_help'></span><span id='topic+linkern_help'></span>

<h3>Description</h3>

<p>The Concorde TSP Solver package contains several solvers.  Currently,
interfaces to the Concorde solver (Applegate et al. 2001), one of the most
advanced and fastest TSP solvers using branch-and-cut, and the Chained
Lin-Kernighan (Applegate et al. 2003) implementation are provided in
<span class="pkg">TSP</span>. Concorde can solve <a href="#topic+TSP">TSP</a>s and <a href="#topic+ETSP">ETSP</a>s directly. <a href="#topic+ATSP">ATSP</a>s are
reformulated as larger TSP's and then solved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>concorde_path(path)

concorde_help()

linkern_help()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Concorde_+3A_path">path</code></td>
<td>
<p>a character string with the path to the directory where the
executables are installed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Installation of Concorde</strong>
</p>
<p>The Concorde TSP Solver is freely available for academic research.
It is not included in the <span class="pkg">TSP</span> R package and has
to be obtained separately from the
<a href="http://www.math.uwaterloo.ca/tsp/concorde/downloads/downloads.htm">Concorde download page</a>.
Either download the precompiled executables and place them in a suitable
directory (make sure they are executable), or you can get the source code and
compile the program on your own. <span class="pkg">TSP</span> needs to know where the executables are.
There are two options:
</p>

<ol>
<li><p> use <code>concorde_path()</code> to set the path to the
directory containing the executables for concorde and linkern, or
</p>
</li>
<li><p> make
sure that the executables are in the search path stored in the <code>PATH</code>
environment variable (see <code><a href="base.html#topic+Sys.setenv">Sys.setenv()</a></code>).
</p>
</li></ol>

<p><strong>Using Concorde for <code>solve_TSP()</code></strong>
</p>
<p><code><a href="#topic+solve_TSP">solve_TSP()</a></code> uses <code><a href="#topic+write_TSPLIB">write_TSPLIB()</a></code> to write the TSP for
Concorde and tries to find the appropriate <code>precision</code> value (digits
after the decimal point) to convert the provided distances into the needed
integer value range. The <code>precision</code> value can also be specified in
<code>control</code> in <code><a href="#topic+solve_TSP">solve_TSP()</a></code> with method Concorde. Warning
messages will alert the user if the conversion to integer values results
into rounding errors that are worse then what is specified in the
<code>precision</code> control parameter.
</p>
<p>To get a list of all available command line options which can be used via
the <code>clo</code> option for <code>solve_TSP</code> use <code>concorde_help()</code> and
<code>linkern_help()</code>.  Several options (<span class="option">-x</span>, <span class="option">-o</span>,
<span class="option">-N</span>, <span class="option">-Q</span>) are not available via <code><a href="#topic+solve_TSP">solve_TSP()</a></code> since they
are used by the interface.
</p>
<p>If Concorde takes too long, then you can kill the 'concorde' process via your
operating system and you can continue with R.
</p>


<h3>Value</h3>

<p>Nothing.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>References</h3>

<p>Concorde home page,
<a href="http://www.math.uwaterloo.ca/tsp/concorde/">http://www.math.uwaterloo.ca/tsp/concorde/</a>
</p>
<p>David Applegate, Robert Bixby, Vasek Chvatal, William Cook (2001): TSP cuts
which do not conform to the template paradigm, Computational Combinatorial
Optimization, M. Junger and D. Naddef (editors), Springer-Verlag.
</p>
<p>David Applegate and William Cook and Andre Rohe (2003): Chained
Lin-Kernighan for Large Traveling Salesman Problems, <em>INFORMS Journal
on Computing</em>, <b>15</b>, 82&ndash;92.
</p>


<h3>See Also</h3>

<p>Other TSP: 
<code><a href="#topic+ATSP">ATSP</a>()</code>,
<code><a href="#topic+ETSP">ETSP</a>()</code>,
<code><a href="#topic+TSPLIB">TSPLIB</a></code>,
<code><a href="#topic+TSP">TSP</a>()</code>,
<code><a href="#topic+insert_dummy">insert_dummy</a>()</code>,
<code><a href="#topic+reformulate_ATSP_as_TSP">reformulate_ATSP_as_TSP</a>()</code>,
<code><a href="#topic+solve_TSP">solve_TSP</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
## see if Concorde is correctly installed
concorde_path()


## set path to the Concorde executible if it is not in the search PATH
## Example:
## concorde_path("~/concorde/")

concorde_help()

data("USCA312")

## run concorde in verbose mode (-v) with fast cuts only (-V)
solve_TSP(USCA312, method = "concorde", control = list(clo = "-v -V"))

## End(Not run)

</code></pre>

<hr>
<h2 id='cut_tour'>Cut a tour to form a path</h2><span id='topic+cut_tour'></span><span id='topic+cut_tour.TOUR'></span>

<h3>Description</h3>

<p>Cuts a tour at a specified city to form a path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cut_tour(x, cut, exclude_cut = TRUE)

## S3 method for class 'TOUR'
cut_tour(x, cut, exclude_cut = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cut_tour_+3A_x">x</code></td>
<td>
<p>an object of class <a href="#topic+TOUR">TOUR</a>.</p>
</td></tr>
<tr><td><code id="cut_tour_+3A_cut">cut</code></td>
<td>
<p>the index or label of the city/cities to cut the tour.</p>
</td></tr>
<tr><td><code id="cut_tour_+3A_exclude_cut">exclude_cut</code></td>
<td>
<p>exclude the city where we cut? If <code>FALSE</code>, the city
at the cut is included in the path as the first city.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a named vector with city ids forming the path. If multiple
cuts are used then a list with paths is returned.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other TOUR: 
<code><a href="#topic+TOUR">TOUR</a>()</code>,
<code><a href="#topic+solve_TSP">solve_TSP</a>()</code>,
<code><a href="#topic+tour_length">tour_length</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("USCA50")

## find a path starting at Austin, TX
tour &lt;- solve_TSP(USCA50)
path &lt;- cut_tour(tour, cut = "Austin, TX", exclude_cut = FALSE)
path

## cut the tours at two cities
tour &lt;- solve_TSP(USCA50)
path &lt;- cut_tour(tour, cut = c("Austin, TX", "Cambridge, MA"), exclude_cut = FALSE)
path

## cut a tour at the largest gap using a dummy city
tsp &lt;- insert_dummy(USCA50, label = "cut")
tour &lt;- solve_TSP(tsp)

## cut tour into path at the dummy city
path &lt;- cut_tour(tour, "cut")
path
</code></pre>

<hr>
<h2 id='ETSP'>Class ETSP &ndash; Euclidean traveling salesperson problem</h2><span id='topic+ETSP'></span><span id='topic+as.ETSP'></span><span id='topic+as.ETSP.matrix'></span><span id='topic+as.ETSP.data.frame'></span><span id='topic+as.TSP.ETSP'></span><span id='topic+as.matrix.ETSP'></span><span id='topic+print.ETSP'></span><span id='topic+n_of_cities.ETSP'></span><span id='topic+labels.ETSP'></span><span id='topic+image.ETSP'></span><span id='topic+plot.ETSP'></span>

<h3>Description</h3>

<p>Constructor to create an instance of a Euclidean traveling salesperson
problem (TSP) represented by city coordinates and some auxiliary methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ETSP(x, labels = NULL)

as.ETSP(x)

## S3 method for class 'matrix'
as.ETSP(x)

## S3 method for class 'data.frame'
as.ETSP(x)

## S3 method for class 'ETSP'
as.TSP(x)

## S3 method for class 'ETSP'
as.matrix(x, ...)

## S3 method for class 'ETSP'
print(x, ...)

## S3 method for class 'ETSP'
n_of_cities(x)

## S3 method for class 'ETSP'
labels(object, ...)

## S3 method for class 'ETSP'
image(x, order, col = gray.colors(64), ...)

## S3 method for class 'ETSP'
plot(x, y = NULL, tour = NULL, tour_lty = 2, tour_col = 2, labels = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ETSP_+3A_x">x</code>, <code id="ETSP_+3A_object">object</code></td>
<td>
<p>an object (data.frame or matrix) to be converted into a
<code>ETSP</code> or, for the methods, an object of class <code>ETSP</code>.</p>
</td></tr>
<tr><td><code id="ETSP_+3A_labels">labels</code></td>
<td>
<p>logical; plot city labels.</p>
</td></tr>
<tr><td><code id="ETSP_+3A_...">...</code></td>
<td>
<p>further arguments are passed on.</p>
</td></tr>
<tr><td><code id="ETSP_+3A_order">order</code></td>
<td>
<p>order of cities for the image as an integer vector or an object
of class <a href="#topic+TOUR">TOUR</a>.</p>
</td></tr>
<tr><td><code id="ETSP_+3A_col">col</code></td>
<td>
<p>color scheme for image.</p>
</td></tr>
<tr><td><code id="ETSP_+3A_tour">tour</code>, <code id="ETSP_+3A_y">y</code></td>
<td>
<p>a tour to be visualized.</p>
</td></tr>
<tr><td><code id="ETSP_+3A_tour_lty">tour_lty</code>, <code id="ETSP_+3A_tour_col">tour_col</code></td>
<td>
<p>line type and color for tour.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Objects of class <code>ETSP</code> are internally represented as a <code>matrix</code>
objects (use <code>as.matrix()</code> to get the <code>matrix</code> object).
</p>


<h3>Value</h3>


<ul>
<li> <p><code>ETSP()</code> returns <code>x</code> as an object of class <code>ETSP</code>.
</p>
</li>
<li> <p><code>n_of_cities()</code> returns the number of cities in <code>x</code>.
</p>
</li>
<li> <p><code>labels()</code> returns a vector with the names of the cities in <code>x</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other TSP: 
<code><a href="#topic+ATSP">ATSP</a>()</code>,
<code><a href="#topic+Concorde">Concorde</a></code>,
<code><a href="#topic+TSPLIB">TSPLIB</a></code>,
<code><a href="#topic+TSP">TSP</a>()</code>,
<code><a href="#topic+insert_dummy">insert_dummy</a>()</code>,
<code><a href="#topic+reformulate_ATSP_as_TSP">reformulate_ATSP_as_TSP</a>()</code>,
<code><a href="#topic+solve_TSP">solve_TSP</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create a random ETSP
n &lt;- 20
x &lt;- data.frame(x = runif(n), y = runif(n), row.names = LETTERS[1:n])
etsp &lt;- ETSP(x)
etsp

## use some methods
n_of_cities(etsp)
labels(etsp)

## plot ETSP and solution
tour &lt;- solve_TSP(etsp)
tour

plot(etsp, tour, tour_col = "red")
</code></pre>

<hr>
<h2 id='insert_dummy'>Insert dummy cities into a distance matrix</h2><span id='topic+insert_dummy'></span><span id='topic+insert_dummy.TSP'></span><span id='topic+insert_dummy.ATSP'></span><span id='topic+insert_dummy.ETSP'></span>

<h3>Description</h3>

<p>Inserts dummy cities into a TSP problem.  A
dummy city has the same, constant distance (0) to all other cities and is
infinitely far from other dummy cities. A dummy city can be used to
transform a shortest Hamiltonian path problem (i.e., finding an optimal
linear order) into a shortest Hamiltonian cycle problem which can be solved
by a TSP solvers (Garfinkel 1985).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>insert_dummy(x, n = 1, const = 0, inf = Inf, label = "dummy")

## S3 method for class 'TSP'
insert_dummy(x, n = 1, const = 0, inf = Inf, label = "dummy")

## S3 method for class 'ATSP'
insert_dummy(x, n = 1, const = 0, inf = Inf, label = "dummy")

## S3 method for class 'ETSP'
insert_dummy(x, n = 1, const = 0, inf = Inf, label = "dummy")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="insert_dummy_+3A_x">x</code></td>
<td>
<p>an object with a TSP problem.</p>
</td></tr>
<tr><td><code id="insert_dummy_+3A_n">n</code></td>
<td>
<p>number of dummy cities.</p>
</td></tr>
<tr><td><code id="insert_dummy_+3A_const">const</code></td>
<td>
<p>distance of the dummy cities to all other cities.</p>
</td></tr>
<tr><td><code id="insert_dummy_+3A_inf">inf</code></td>
<td>
<p>distance between dummy cities.</p>
</td></tr>
<tr><td><code id="insert_dummy_+3A_label">label</code></td>
<td>
<p>labels for the dummy cities. If only one label is given, it is
reused for all dummy cities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Several dummy cities can be used together with a TSP solvers to perform
rearrangement clustering (Climer and Zhang 2006).
</p>
<p>The dummy cities are inserted after the other cities in <code>x</code>.
</p>
<p>A <code>const</code> of 0 is guaranteed to work if the TSP finds the optimal
solution. For heuristics returning suboptimal solutions, a higher
<code>const</code> (e.g., <code>2 * max(x)</code>) might provide better results.
</p>


<h3>Value</h3>

<p>returns an object of the same class as <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>References</h3>

<p>Sharlee Climer, Weixiong Zhang (2006): Rearrangement Clustering:
Pitfalls, Remedies, and Applications, <em>Journal of Machine Learning
Research</em> <b>7</b>(Jun), pp. 919&ndash;943.
</p>
<p>R.S. Garfinkel (1985): Motivation and modelling (chapter 2). In: E. L.
Lawler, J. K. Lenstra, A.H.G. Rinnooy Kan, D.  B. Shmoys (eds.) The
traveling salesman problem - A guided tour of combinatorial optimization,
Wiley &amp; Sons.
</p>


<h3>See Also</h3>

<p>Other TSP: 
<code><a href="#topic+ATSP">ATSP</a>()</code>,
<code><a href="#topic+Concorde">Concorde</a></code>,
<code><a href="#topic+ETSP">ETSP</a>()</code>,
<code><a href="#topic+TSPLIB">TSPLIB</a></code>,
<code><a href="#topic+TSP">TSP</a>()</code>,
<code><a href="#topic+reformulate_ATSP_as_TSP">reformulate_ATSP_as_TSP</a>()</code>,
<code><a href="#topic+solve_TSP">solve_TSP</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example 1: Find a short Hamiltonian path
set.seed(1000)
x &lt;- data.frame(x = runif(20), y = runif(20), row.names = LETTERS[1:20])

tsp &lt;- TSP(dist(x))

## add a dummy city to cut the tour into a path
tsp &lt;- insert_dummy(tsp, label = "cut")
tour &lt;- solve_TSP(tsp)
tour

plot(x)
lines(x[cut_tour(tour, cut = "cut"),])


## Example 2: Rearrangement clustering of the iris dataset
set.seed(1000)
data("iris")
tsp &lt;- TSP(dist(iris[-5]))

## insert 2 dummy cities to creates 2 clusters
tsp_dummy &lt;- insert_dummy(tsp, n = 3, label = "boundary")

## get a solution for the TSP
tour &lt;- solve_TSP(tsp_dummy)

## plot the reordered distance matrix with the dummy cities as lines separating
## the clusters
image(tsp_dummy, tour)
abline(h = which(labels(tour)=="boundary"), col = "red")
abline(v = which(labels(tour)=="boundary"), col = "red")

## plot the original data with paths connecting the points in each cluster
plot(iris[,c(2,3)], col = iris[,5])
paths &lt;- cut_tour(tour, cut = "boundary")
for(p in paths) lines(iris[p, c(2,3)])

## Note: The clustering is not perfect!
</code></pre>

<hr>
<h2 id='reformulate_ATSP_as_TSP'>Reformulate a ATSP as a symmetric TSP</h2><span id='topic+reformulate_ATSP_as_TSP'></span><span id='topic+filter_ATSP_as_TSP_dummies'></span>

<h3>Description</h3>

<p>A ATSP can be formulated as a symmetric TSP by doubling the number of cities
(Jonker and Volgenant 1983). The solution of the TSP also represents the
solution of the original ATSP.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reformulate_ATSP_as_TSP(x, infeasible = Inf, cheap = -Inf)

filter_ATSP_as_TSP_dummies(tour, atsp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reformulate_ATSP_as_TSP_+3A_x">x</code></td>
<td>
<p>an <a href="#topic+ATSP">ATSP</a>.</p>
</td></tr>
<tr><td><code id="reformulate_ATSP_as_TSP_+3A_infeasible">infeasible</code></td>
<td>
<p>value for infeasible connections.</p>
</td></tr>
<tr><td><code id="reformulate_ATSP_as_TSP_+3A_cheap">cheap</code></td>
<td>
<p>value for distance between a city and its corresponding dummy
city.</p>
</td></tr>
<tr><td><code id="reformulate_ATSP_as_TSP_+3A_tour">tour</code></td>
<td>
<p>a <a href="#topic+TOUR">TOUR</a> created for a ATSP reformulated as a TSP.</p>
</td></tr>
<tr><td><code id="reformulate_ATSP_as_TSP_+3A_atsp">atsp</code></td>
<td>
<p>the original <a href="#topic+ATSP">ATSP</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To reformulate a <a href="#topic+ATSP">ATSP</a> as a <a href="#topic+TSP">TSP</a>, for each city a dummy city (e.g, for 'New
York' a dummy city 'New York*') is added. Between each city and its
corresponding dummy city a very small (or negative) distance with value
<code>cheap</code> is used.
To ensure that the solver places each cities always occurs in the
solution together with its dummy city, this cost has to be much smaller than
the distances in the TSP.
The original distances are used
between the cities and the dummy cities, where each city is responsible for
the distance going to the city and the dummy city is responsible for the
distance coming from the city. The distances between all cities and the
distances between all dummy cities are set to <code>infeasible</code>, a very
large value which prevents the solver from using these links.
We use infinite values here and <code><a href="#topic+solve_TSP">solve_TSP()</a></code> treats them appropriately.
</p>
<p><code>filter_ATSP_as_TSP_dummies()</code> can be used to extract the solution for the original
ATSP from the tour found for an ATSP reformulated as a TSP. Note that the symmetric TSP
tour does not reveal the direction for the ATSP. The filter function computed the
tour length for both directions and returns the shorter tour.
</p>
<p><code><a href="#topic+solve_TSP">solve_TSP()</a></code> has a parameter <code>as_TSP</code> which preforms the reformulation and
filtering the dummy cities automatically.
</p>
<p><strong>Note on performance:</strong> Doubling the problem size is a performance issue especially
has a negative impact on solution quality for heuristics. It should only be used
together with Concorde when the optimal solution is required. Most heuristics can solve
ATSPs directly with good solution quality.
</p>


<h3>Value</h3>

<p><code>reformulate_ATSP_as_TSP()</code> returns a <a href="#topic+TSP">TSP</a> object.
<code>filter_ATSP_as_TSP_dummies()</code> returns a <a href="#topic+TOUR">TOUR</a> object.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>References</h3>

<p>Jonker, R. and Volgenant, T. (1983): Transforming asymmetric
into symmetric traveling salesman problems, <em>Operations Research
Letters,</em> 2, 161&ndash;163.
</p>


<h3>See Also</h3>

<p>Other TSP: 
<code><a href="#topic+ATSP">ATSP</a>()</code>,
<code><a href="#topic+Concorde">Concorde</a></code>,
<code><a href="#topic+ETSP">ETSP</a>()</code>,
<code><a href="#topic+TSPLIB">TSPLIB</a></code>,
<code><a href="#topic+TSP">TSP</a>()</code>,
<code><a href="#topic+insert_dummy">insert_dummy</a>()</code>,
<code><a href="#topic+solve_TSP">solve_TSP</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("USCA50")

## set the distances from anywhere to Austin to zero which makes it an ATSP
austin &lt;- which(labels(USCA50) == "Austin, TX")
atsp &lt;- as.ATSP(USCA50)
atsp[, austin] &lt;- 0
atsp

## reformulate as a TSP (by doubling the number of cities with dummy cities marked with *)
tsp &lt;- reformulate_ATSP_as_TSP(atsp)
tsp

## create tour for the TSP. You should use Concorde to find the optimal solution.
# tour_tsp &lt;- solve_TSP(tsp, method = "concorde")
# The standard heuristic is bad for this problem. We use it here because
#   Concord may not be installed.
tour_tsp &lt;- solve_TSP(tsp)
head(labels(tour_tsp), n = 10)
tour_tsp
# The tour length is -Inf since it includes cheap links
#  from a city to its dummy city.

## get the solution for the original ATSP by filtering out the dummy cities.
tour_atsp &lt;- filter_ATSP_as_TSP_dummies(tour_tsp, atsp = atsp)
tour_atsp
head(labels(tour_atsp), n = 10)

## This process can also be done automatically by using as_TSP = TRUE:
# solve_TSP(atsp, method = "concorde", as_TSP = TRUE)

## The default heuristic can directly solve ATSPs with results close to the
#  optimal solution of 12715.
solve_TSP(atsp, control = list(rep = 10))
</code></pre>

<hr>
<h2 id='solve_TSP'>TSP solver interface</h2><span id='topic+solve_TSP'></span><span id='topic+solve_TSP.TSP'></span><span id='topic+solve_TSP.ATSP'></span><span id='topic+solve_TSP.ETSP'></span>

<h3>Description</h3>

<p>Common interface to all TSP solvers in this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solve_TSP(x, method = NULL, control = NULL, ...)

## S3 method for class 'TSP'
solve_TSP(x, method = NULL, control = NULL, ...)

## S3 method for class 'ATSP'
solve_TSP(x, method = NULL, control = NULL, as_TSP = FALSE, ...)

## S3 method for class 'ETSP'
solve_TSP(x, method = NULL, control = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solve_TSP_+3A_x">x</code></td>
<td>
<p>a TSP problem.</p>
</td></tr>
<tr><td><code id="solve_TSP_+3A_method">method</code></td>
<td>
<p>method to solve the TSP (default: &quot;arbitrary insertion&quot;
algorithm with two_opt refinement.</p>
</td></tr>
<tr><td><code id="solve_TSP_+3A_control">control</code></td>
<td>
<p>a list of arguments passed on to the TSP solver selected by
<code>method</code>.</p>
</td></tr>
<tr><td><code id="solve_TSP_+3A_...">...</code></td>
<td>
<p>additional arguments are added to <code>control</code>.</p>
</td></tr>
<tr><td><code id="solve_TSP_+3A_as_tsp">as_TSP</code></td>
<td>
<p>should the ATSP reformulated as a TSP for the solver?</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>TSP Methods</strong>
</p>
<p>Currently the following methods are available:
</p>

<ul>
<li><p> &quot;identity&quot;, &quot;random&quot; return a tour representing the order in the data
(identity order) or a random order. [TSP, ATSP]
</p>
</li>
<li><p> &quot;nearest_insertion&quot;, &quot;farthest_insertion&quot;, &quot;cheapest_insertion&quot;, &quot;arbitrary_insertion&quot;
Nearest, farthest, cheapest and
arbitrary insertion algorithms for a symmetric and asymmetric TSP
(Rosenkrantz et al. 1977). [TSP, ATSP]
</p>
<p>The distances between cities are stored in a distance matrix <code class="reqn">D</code> with
elements <code class="reqn">d(i,j)</code>.  All insertion algorithms start with a tour
consisting of an arbitrary city and choose in each step a city <code class="reqn">k</code> not
yet on the tour. This city is inserted into the existing tour between two
consecutive cities <code class="reqn">i</code> and <code class="reqn">j</code>, such that </p>
<p style="text-align: center;"><code class="reqn">d(i,k) + d(k,j) -
  d(i,j)</code>
</p>
<p> is minimized. The algorithms stops when all cities are on the tour.
</p>
<p>The nearest insertion algorithm chooses city <code class="reqn">k</code> in each step as the
city which is <em>nearest</em> to a city on the tour.
</p>
<p>For farthest insertion, the city <code class="reqn">k</code> is chosen in each step as the city
which is <em>farthest</em> to any city on the tour.
</p>
<p>Cheapest insertion chooses the city <code class="reqn">k</code> such that the cost of inserting
the new city (i.e., the increase in the tour's length) is minimal.
</p>
<p>Arbitrary insertion chooses the city <code class="reqn">k</code> randomly from all cities not
yet on the tour.
</p>
<p>Nearest and cheapest insertion tries to build the tour using cities which
fit well into the partial tour constructed so far.  The idea behind behind
farthest insertion is to link cities far away into the tour fist to
establish an outline of the whole tour early.
</p>
<p>Additional control options:
</p>

<ul>
<li><p> &quot;start&quot; index of the first city (default: a random city).
</p>
</li></ul>

</li>
<li><p> &quot;nn&quot;, &quot;repetitive_nn&quot; Nearest neighbor and repetitive
nearest neighbor algorithms for symmetric and asymmetric TSPs (Rosenkrantz
et al. 1977). [TSP, ATSP]
</p>
<p>The algorithm starts with a tour containing a random city. Then the
algorithm always adds to the last city on the tour the nearest not yet
visited city. The algorithm stops when all cities are on the tour.
</p>
<p>Repetitive nearest neighbor constructs a nearest neighbor tour for each city
as the starting point and returns the shortest tour found.
</p>
<p>Additional control options:
</p>

<ul>
<li><p> &quot;start&quot; index of the first city (default: a random city).
</p>
</li></ul>

</li>
<li><p> &quot;two_opt&quot; Two edge exchange improvement procedure (Croes 1958). [TSP, ATSP]
</p>
<p>This is a tour refinement procedure which systematically exchanges two edges
in the graph represented by the distance matrix till no improvements are
possible. Exchanging two edges is equal to reversing part of the tour. The
resulting tour is called <em>2-optimal.</em>
</p>
<p>This method can be applied to tours created by other methods or used as its
own method. In this case improvement starts with a random tour.
</p>
<p>Additional control options:
</p>

<ul>
<li><p> &quot;tour&quot; an existing tour which should be improved.
If no tour is given, a random tour is used.
</p>
</li>
<li><p> &quot;two_opt_repetitions&quot; number of times to try two_opt with a
different initial random tour (default: 1).
</p>
</li></ul>

</li>
<li><p> &quot;concorde&quot; Concorde algorithm (Applegate et al. 2001). [TSP, ETSP]
</p>
<p>Concorde is an advanced exact TSP solver for <em>symmetric</em> TSPs
based on branch-and-cut.
ATSPs can be solved using <code><a href="#topic+reformulate_ATSP_as_TSP">reformulate_ATSP_as_TSP()</a></code> done automatically
with <code>as_TSP = TRUE</code>.
The program is not included in this package and
has to be obtained and installed separately.
</p>
<p>Additional control options:
</p>

<ul>
<li><p> &quot;exe&quot; a character string containing the path to the executable (see <a href="#topic+Concorde">Concorde</a>).
</p>
</li>
<li><p> &quot;clo&quot; a character string containing command line options for
Concorde, e.g., <code>control = list(clo = "-B -v")</code>. See
<code><a href="#topic+concorde_help">concorde_help()</a></code> on how to obtain a complete list of available command
line options.
</p>
</li>
<li><p> &quot;precision&quot; an integer which controls the number of decimal
places used for the internal representation of distances in Concorde. The
values given in <code>x</code> are multiplied by <code class="reqn">10^{precision}</code> before being
passed on to Concorde. Note that therefore the results produced by Concorde
(especially lower and upper bounds) need to be divided by
<code class="reqn">10^{precision}</code> (i.e., the decimal point has to be shifted
<code>precision</code> placed to the left). The interface to Concorde uses
<code><a href="#topic+write_TSPLIB">write_TSPLIB()</a></code>.
</p>
</li></ul>

</li>
<li><p> &quot;linkern&quot; Concorde's Chained Lin-Kernighan heuristic (Applegate et al. 2003). [TSP, ETSP]
</p>
<p>The Lin-Kernighan (Lin and Kernighan 1973) heuristic uses variable <code class="reqn">k</code>
edge exchanges to improve an initial tour.  The program is not included in
this package and has to be obtained and installed separately (see <a href="#topic+Concorde">Concorde</a>).
</p>
<p>Additional control options: see Concorde above.
</p>
</li></ul>

<p><strong>Treatment of <code>NA</code>s and infinite values in <code>x</code></strong>
</p>
<p><a href="#topic+TSP">TSP</a> and <a href="#topic+ATSP">ATSP</a> need to contain valid distances. <code>NA</code>s are not allowed. <code>Inf</code> is
allowed and can be used to model the missing edges in incomplete graphs
(i.e., the distance between the two objects is infinite) or unfeasable connections.
Internally, <code>Inf</code> is replaced by a large value given by <code class="reqn">max(x) + 2 range(x)</code>.
Note that the solution might still place the two objects next to each other
(e.g., if <code>x</code> contains several unconnected subgraphs) which results in
a path length of <code>Inf</code>. <code>-Inf</code> is replaced by <code class="reqn">min(x) - 2 range(x)</code> and
can be used to encourage the solver to place two objects next to each other.
</p>
<p><strong>Parallel execution support</strong>
</p>
<p>All heuristics can be used with the control arguments <code>repetitions</code>
(uses the best from that many repetitions with random starts) and
<code>two_opt</code> (a logical indicating if two_opt refinement should be
performed). If several repetitions are done (this includes method
<code>"repetitive_nn"</code>) then <span class="pkg">foreach</span> is used so they can be performed
in parallel on multiple cores/machines. To enable parallel execution an
appropriate parallel backend needs to be registered (e.g., load
<span class="pkg">doParallel</span> and register it with <code><a href="doParallel.html#topic+registerDoParallel">doParallel::registerDoParallel()</a></code>).
</p>
<p><strong>Solving ATSP and ETSP</strong>
</p>
<p>Some solvers (including Concorde) cannot directly solve <a href="#topic+ATSP">ATSP</a>
directly. <code>ATSP</code> can be reformulated as larger <code>TSP</code> and solved
this way. For convenience, <code>solve_TSP()</code> has an extra argument
<code>as_TSP</code> which can be set to <code>TRUE</code> to automatically solve the
<code>ATSP</code> reformulated as a <code>TSP</code> (see <code><a href="#topic+reformulate_ATSP_as_TSP">reformulate_ATSP_as_TSP()</a></code>).
</p>
<p>Only methods &quot;concorde&quot; and &quot;linkern&quot; can solve <a href="#topic+ETSP">ETSP</a>s directly.
For all other methods, ETSPs are currently converted into TSPs by creating a
distance matrix and then solved.
</p>


<h3>Value</h3>

<p>An object of class <a href="#topic+TOUR">TOUR</a>.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>References</h3>

<p>David Applegate, Robert Bixby, Vasek Chvatal, William Cook
(2001): TSP cuts which do not conform to the template paradigm,
Computational Combinatorial Optimization, M. Junger and D. Naddef (editors),
Springer.
</p>
<p>D. Applegate, W. Cook and A. Rohe (2003): Chained Lin-Kernighan for Large
Traveling Salesman Problems.  <em>INFORMS Journal on Computing,
15(1):82&ndash;92.</em>
</p>
<p>G.A. Croes (1958): A method for solving traveling-salesman problems.
<em>Operations Research, 6(6):791&ndash;812.</em>
</p>
<p>S. Lin and B. Kernighan (1973): An effective heuristic algorithm for the
traveling-salesman problem. <em>Operations Research, 21(2): 498&ndash;516.</em>
</p>
<p>D.J. Rosenkrantz, R. E. Stearns, and Philip M. Lewis II (1977): An analysis
of several heuristics for the traveling salesman problem.  <em>SIAM
Journal on Computing, 6(3):563&ndash;581.</em>
</p>


<h3>See Also</h3>

<p>Other TSP: 
<code><a href="#topic+ATSP">ATSP</a>()</code>,
<code><a href="#topic+Concorde">Concorde</a></code>,
<code><a href="#topic+ETSP">ETSP</a>()</code>,
<code><a href="#topic+TSPLIB">TSPLIB</a></code>,
<code><a href="#topic+TSP">TSP</a>()</code>,
<code><a href="#topic+insert_dummy">insert_dummy</a>()</code>,
<code><a href="#topic+reformulate_ATSP_as_TSP">reformulate_ATSP_as_TSP</a>()</code>
</p>
<p>Other TOUR: 
<code><a href="#topic+TOUR">TOUR</a>()</code>,
<code><a href="#topic+cut_tour">cut_tour</a>()</code>,
<code><a href="#topic+tour_length">tour_length</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## solve a simple Euclidean TSP (using the default method)
etsp &lt;- ETSP(data.frame(x = runif(20), y = runif(20)))
tour &lt;- solve_TSP(etsp)
tour
tour_length(tour)
plot(etsp, tour)


## compare methods
data("USCA50")
USCA50
methods &lt;- c("identity", "random", "nearest_insertion",
  "cheapest_insertion", "farthest_insertion", "arbitrary_insertion",
  "nn", "repetitive_nn", "two_opt")

## calculate tours
tours &lt;- lapply(methods, FUN = function(m) solve_TSP(USCA50, method = m))
names(tours) &lt;- methods

## use the external solver which has to be installed separately
## Not run: 
tours$concorde  &lt;- solve_TSP(USCA50, method = "concorde")
tours$linkern  &lt;- solve_TSP(USCA50, method = "linkern")

## End(Not run)

## register a parallel backend to perform repetitions in parallel
## Not run: 
library(doParallel)
registerDoParallel()

## End(Not run)

## add some tours using repetition and two_opt refinements
tours$'nn+two_opt' &lt;- solve_TSP(USCA50, method = "nn", two_opt = TRUE)
tours$'nn+rep_10' &lt;- solve_TSP(USCA50, method = "nn", rep = 10)
tours$'nn+two_opt+rep_10' &lt;- solve_TSP(USCA50, method = "nn", two_opt = TRUE, rep = 10)
tours$'arbitrary_insertion+two_opt' &lt;- solve_TSP(USCA50)

## show first tour
tours[[1]]

## compare tour lengths
opt &lt;- 14497 # obtained by Concorde
tour_lengths &lt;- c(sort(sapply(tours, tour_length), decreasing = TRUE),
  optimal = opt)
dotchart(tour_lengths / opt * 100 - 100, xlab = "percent excess over optimum")
</code></pre>

<hr>
<h2 id='TOUR'>Class TOUR &ndash; Solution to a traveling salesperson problem</h2><span id='topic+TOUR'></span><span id='topic+as.TOUR'></span><span id='topic+as.TOUR.numeric'></span><span id='topic+as.TOUR.integer'></span><span id='topic+print.TOUR'></span>

<h3>Description</h3>

<p>Class to store the solution of a TSP. Objects of this class are returned by
TSP solvers in this package.  Essentially, an object of class <code>TOUR</code> is
a permutation vector containing the order of cities to visit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TOUR(x, method = NA, tsp = NULL)

as.TOUR(object)

## S3 method for class 'numeric'
as.TOUR(object)

## S3 method for class 'integer'
as.TOUR(object)

## S3 method for class 'TOUR'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TOUR_+3A_x">x</code></td>
<td>
<p>an integer permutation vector or, for the methods an object of
class <a href="#topic+TOUR">TOUR</a>.</p>
</td></tr>
<tr><td><code id="TOUR_+3A_method">method</code></td>
<td>
<p>character string; method used to create the tour.</p>
</td></tr>
<tr><td><code id="TOUR_+3A_tsp">tsp</code></td>
<td>
<p><code>TSP</code> object the tour applies to. If available then the tour
will include the tour length. Also the labels of the cities will be
available in the tour (otherwise the labels of <code>x</code> are used).</p>
</td></tr>
<tr><td><code id="TOUR_+3A_object">object</code></td>
<td>
<p>data (an integer vector) which can be coerced to <code>TOUR</code>.</p>
</td></tr>
<tr><td><code id="TOUR_+3A_...">...</code></td>
<td>
<p>further arguments are passed on.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since an object of class <code>TOUR</code> is an integer vector, it can be
subsetted as an ordinary vector or coerced to an integer vector using
<code>as.integer()</code>. It also contains the names of the objects as labels.
Additionally, <code>TOUR</code> has the following attributes: <code>"method"</code>,
<code>"tour_length"</code>.
</p>
<p>For most functions, e.g., <code><a href="#topic+tour_length">tour_length()</a></code> or <code><a href="#topic+image.TSP">image.TSP()</a></code>, the
<code>TSP/ATSP</code> object used to find the tour is still needed, since the tour
does not contain the distance information.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other TOUR: 
<code><a href="#topic+cut_tour">cut_tour</a>()</code>,
<code><a href="#topic+solve_TSP">solve_TSP</a>()</code>,
<code><a href="#topic+tour_length">tour_length</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TOUR(1:10)

## calculate a tour
data("USCA50")
tour &lt;- solve_TSP(USCA50)
tour

## get tour length directly from tour
tour_length(tour)

## get permutation vector
as.integer(tour)

## show labels
labels(tour)
</code></pre>

<hr>
<h2 id='tour_length'>Calculate the length of a tour</h2><span id='topic+tour_length'></span><span id='topic+tour_length.TSP'></span><span id='topic+tour_length.ATSP'></span><span id='topic+tour_length.ETSP'></span><span id='topic+tour_length.TOUR'></span><span id='topic+tour_length.integer'></span>

<h3>Description</h3>

<p>Calculate the length of a <a href="#topic+TOUR">TOUR</a> for a <a href="#topic+TSP">TSP</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tour_length(x, ...)

## S3 method for class 'TSP'
tour_length(x, order, ...)

## S3 method for class 'ATSP'
tour_length(x, order, ...)

## S3 method for class 'ETSP'
tour_length(x, order, ...)

## S3 method for class 'TOUR'
tour_length(x, tsp = NULL, ...)

## S3 method for class 'integer'
tour_length(x, tsp = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tour_length_+3A_x">x</code></td>
<td>
<p>a TSP problem or a <a href="#topic+TOUR">TOUR</a>.</p>
</td></tr>
<tr><td><code id="tour_length_+3A_...">...</code></td>
<td>
<p>further arguments are currently unused.</p>
</td></tr>
<tr><td><code id="tour_length_+3A_order">order</code></td>
<td>
<p>an object of class <code>TOUR</code></p>
</td></tr>
<tr><td><code id="tour_length_+3A_tsp">tsp</code></td>
<td>
<p>as TSP object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no <code>tsp</code> is specified, then the tour length stored in <code>x</code> as
attribute <code>"tour_length"</code> is returned.  If <code>tsp</code> is given then the
tour length is recalculated using the specified TSP problem.
</p>
<p>If a distance in the tour is infinite, the result is also infinite. If the
tour contains positive and negative infinite distances then the method
returns <code>NA</code>.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other TOUR: 
<code><a href="#topic+TOUR">TOUR</a>()</code>,
<code><a href="#topic+cut_tour">cut_tour</a>()</code>,
<code><a href="#topic+solve_TSP">solve_TSP</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("USCA50")

## original order
tour_length(solve_TSP(USCA50, method="identity"))

## length of a manually created (random) tour
tour &lt;- TOUR(sample(seq(n_of_cities(USCA50))))
tour
tour_length(tour)
tour_length(tour, USCA50)
</code></pre>

<hr>
<h2 id='TSP'>Class TSP &ndash; Symmetric traveling salesperson problem</h2><span id='topic+TSP'></span><span id='topic+as.TSP'></span><span id='topic+as.TSP.dist'></span><span id='topic+as.TSP.matrix'></span><span id='topic+as.dist.TSP'></span><span id='topic+print.TSP'></span><span id='topic+n_of_cities'></span><span id='topic+n_of_cities.TSP'></span><span id='topic+labels.TSP'></span><span id='topic+image.TSP'></span>

<h3>Description</h3>

<p>Constructor to create an instance of a symmetric traveling salesperson
problem (TSP) and some auxiliary methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TSP(x, labels = NULL, method = NULL)

as.TSP(x)

## S3 method for class 'dist'
as.TSP(x)

## S3 method for class 'matrix'
as.TSP(x)

## S3 method for class 'TSP'
as.dist(m, ...)

## S3 method for class 'TSP'
print(x, ...)

n_of_cities(x)

## S3 method for class 'TSP'
n_of_cities(x)

## S3 method for class 'TSP'
labels(object, ...)

## S3 method for class 'TSP'
image(x, order, col = gray.colors(64), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TSP_+3A_x">x</code>, <code id="TSP_+3A_object">object</code></td>
<td>
<p>an object (currently <code>dist</code> or a symmetric matrix) to
be converted into a <code>TSP</code> or, for the methods, an object of class
<code>TSP</code>.</p>
</td></tr>
<tr><td><code id="TSP_+3A_labels">labels</code></td>
<td>
<p>optional city labels. If not given, labels are taken from
<code>x</code>.</p>
</td></tr>
<tr><td><code id="TSP_+3A_method">method</code></td>
<td>
<p>optional name of the distance metric. If <code>x</code> is a
<code>dist</code> object, then the method is taken from that object.</p>
</td></tr>
<tr><td><code id="TSP_+3A_m">m</code></td>
<td>
<p>a TSP object to be converted to a <a href="stats.html#topic+dist">dist</a> object.</p>
</td></tr>
<tr><td><code id="TSP_+3A_...">...</code></td>
<td>
<p>further arguments are passed on.</p>
</td></tr>
<tr><td><code id="TSP_+3A_order">order</code></td>
<td>
<p>order of cities for the image as an integer vector or an object
of class <a href="#topic+TOUR">TOUR</a>.</p>
</td></tr>
<tr><td><code id="TSP_+3A_col">col</code></td>
<td>
<p>color scheme for image.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Objects of class <code>TSP</code> are internally represented as <code>dist</code>
objects (use <code><a href="stats.html#topic+as.dist">as.dist()</a></code> to get the <code>dist</code> object).
</p>
<p>Not permissible paths can be set to a distance of <code>+Inf</code>. <code>NA</code>s are not allowed and <code>-Inf</code> will lead
to the algorithm only being able to find an admissible tour, but not the best one.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>TSP()</code> returns <code>x</code> as an object of class <code>TSP</code>.
</p>
</li>
<li> <p><code>n_of_cities()</code> returns the number of cities in <code>x</code>.
</p>
</li>
<li> <p><code>labels()</code> returns a vector with the names of the cities in <code>x</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other TSP: 
<code><a href="#topic+ATSP">ATSP</a>()</code>,
<code><a href="#topic+Concorde">Concorde</a></code>,
<code><a href="#topic+ETSP">ETSP</a>()</code>,
<code><a href="#topic+TSPLIB">TSPLIB</a></code>,
<code><a href="#topic+insert_dummy">insert_dummy</a>()</code>,
<code><a href="#topic+reformulate_ATSP_as_TSP">reformulate_ATSP_as_TSP</a>()</code>,
<code><a href="#topic+solve_TSP">solve_TSP</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("iris")
d &lt;- dist(iris[-5])

## create a TSP
tsp &lt;- TSP(d)
tsp

## use some methods
n_of_cities(tsp)
labels(tsp)
image(tsp)
</code></pre>

<hr>
<h2 id='TSP-package'>TSP: Traveling Salesperson Problem (TSP)</h2><span id='topic+TSP-package'></span>

<h3>Description</h3>

<p>Basic infrastructure and some algorithms for the traveling salesperson problem (also traveling salesman problem; TSP). The package provides some simple algorithms and an interface to the Concorde TSP solver and its implementation of the Chained-Lin-Kernighan heuristic. The code for <a href="https://www.math.uwaterloo.ca/tsp/concorde/">Concorde</a> itself is not included in the package and has to be obtained separately.
</p>


<h3>Key functions</h3>


<ul>
<li> <p><code><a href="#topic+solve_TSP">solve_TSP()</a></code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>References</h3>

<p>Michael Hahsler and Kurt Hornik. TSP &ndash; Infrastructure for the traveling salesperson problem. Journal of Statistical Software, 23(2):1&ndash;21, December 2007. <a href="https://doi.org/10.18637/jss.v023.i02">doi:10.18637/jss.v023.i02</a>
</p>

<hr>
<h2 id='TSPLIB'>Read and write TSPLIB files</h2><span id='topic+TSPLIB'></span><span id='topic+read_TSPLIB'></span><span id='topic+write_TSPLIB'></span><span id='topic+write_TSPLIB.TSP'></span><span id='topic+write_TSPLIB.ATSP'></span><span id='topic+write_TSPLIB.ETSP'></span>

<h3>Description</h3>

<p>Reads and writes TSPLIB format files. TSPLIB files can be used by most TSP
solvers. Sample instances for the TSP in TSPLIB format are available on the
TSPLIB homepage (see references).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_TSPLIB(file, precision = 0)

write_TSPLIB(x, file, precision = 6, inf = NULL, neg_inf = NULL)

## S3 method for class 'TSP'
write_TSPLIB(x, file, precision = 6, inf = NULL, neg_inf = NULL)

## S3 method for class 'ATSP'
write_TSPLIB(x, file, precision = 6, inf = NULL, neg_inf = NULL)

## S3 method for class 'ETSP'
write_TSPLIB(x, file, precision = 6, inf = NULL, neg_inf = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TSPLIB_+3A_file">file</code></td>
<td>
<p>file name or a <a href="base.html#topic+connection">connection</a>.</p>
</td></tr>
<tr><td><code id="TSPLIB_+3A_precision">precision</code></td>
<td>
<p>controls the number of decimal places used to represent
distances (see details).  If <code>x</code> already is <code>integer</code>, this
argument is ignored and <code>x</code> is used as is.</p>
</td></tr>
<tr><td><code id="TSPLIB_+3A_x">x</code></td>
<td>
<p>an object with a TSP problem.
<code>NA</code>s are not allowed.</p>
</td></tr>
<tr><td><code id="TSPLIB_+3A_inf">inf</code></td>
<td>
<p>replacement value for <code>Inf</code> (TSPLIB format cannot handle
<code>Inf</code>). If <code>inf</code> is <code>NULL</code>, a large value of <code class="reqn">max(x) + 2
range(x)</code> (ignoring infinite entries) is used.</p>
</td></tr>
<tr><td><code id="TSPLIB_+3A_neg_inf">neg_inf</code></td>
<td>
<p>replacement value for <code>-Inf</code>.  If no value is specified,
a small value of <code class="reqn">min(x) - 2 range(x)</code> (ignoring infinite entries) is
used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the TSPLIB format distances are represented by integer values. Therefore,
if <code>x</code> contains <code>double</code> values (which is normal in R) the values
given in <code>x</code> are multiplied by <code class="reqn">10^{precision}</code> before coercion to
<code>integer</code>. Note that therefore all results produced by programs using
the TSPLIB file as input need to be divided by <code class="reqn">10^{precision}</code> (i.e.,
the decimal point has to be shifted <code>precision</code> placed to the left).
</p>
<p>Currently only the following <code>EDGE_WEIGHT_TYPE</code>s are implemented:
<code>EXPLICIT</code>, <code>EUC_2D</code> and <code>EUC_3D</code>.
</p>


<h3>Value</h3>

<p>returns an object of class <code>TSP</code> or
<code>ATSP</code>.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>References</h3>

<p>TSPLIB home page,
<a href="http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/">http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/</a>
</p>


<h3>See Also</h3>

<p>Other TSP: 
<code><a href="#topic+ATSP">ATSP</a>()</code>,
<code><a href="#topic+Concorde">Concorde</a></code>,
<code><a href="#topic+ETSP">ETSP</a>()</code>,
<code><a href="#topic+TSP">TSP</a>()</code>,
<code><a href="#topic+insert_dummy">insert_dummy</a>()</code>,
<code><a href="#topic+reformulate_ATSP_as_TSP">reformulate_ATSP_as_TSP</a>()</code>,
<code><a href="#topic+solve_TSP">solve_TSP</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Drilling problem from TSP
drill &lt;- read_TSPLIB(system.file("examples/d493.tsp", package = "TSP"))
drill
tour &lt;- solve_TSP(drill, method = "nn", two_opt = TRUE)
tour
plot(drill, tour, cex=.6, col = "red", pch= 3, main = "TSPLIB: d493")


## Write and read data in TSPLIB format
x &lt;- data.frame(x=runif(5), y=runif(5))

## create TSP, ATSP and ETSP (2D)
tsp &lt;- TSP(dist(x))
atsp &lt;- ATSP(dist(x))
etsp &lt;- ETSP(x[,1:2])

write_TSPLIB(tsp, file="example.tsp")
#file.show("example.tsp")
r &lt;- read_TSPLIB("example.tsp")
r

write_TSPLIB(atsp, file="example.tsp")
#file.show("example.tsp")
r &lt;- read_TSPLIB("example.tsp")
r

write_TSPLIB(etsp, file="example.tsp")
#file.show("example.tsp")
r &lt;- read_TSPLIB("example.tsp")
r

## clean up
unlink("example.tsp")
</code></pre>

<hr>
<h2 id='USCA'>USCA312/USCA50 &ndash; 312/50 cities in the US and Canada</h2><span id='topic+USCA'></span><span id='topic+USCA312'></span><span id='topic+USCA312_GPS'></span><span id='topic+USCA50'></span>

<h3>Description</h3>

<p>The <code>USCA312</code> dataset contains the distances between 312 cities in the
US and Canada as an object of class <code>TSP</code>.  <code>USCA50</code> is a subset
of <code>USCA312</code> containing only the first 50 cities.
</p>


<h3>Format</h3>

<p><code>USCA312</code> and <code>USCA50</code> are objects of class <code>TSP</code>.
<code>USCA312_GPS</code> is a data.frame with city name, long and lat.
</p>


<h3>Details</h3>

<p>The <code>USCA312_GPS</code> dataset contains the location (long/lat) of the 312
cities.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>Source</h3>

<p>John Burkardt, CITIES &ndash; City Distance Datasets, Florida State
University, Department of Scientific Computing
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("USCA312")

## calculate a tour
tour &lt;- solve_TSP(USCA312)
tour

# Visualize the tour if package maps is installed
if(require("maps")) {

  library(maps)
  data("USCA312_GPS")
  head(USCA312_GPS)

  plot((USCA312_GPS[, c("long", "lat")]), cex = .3)
  map("world", col = "gray", add = TRUE)
  polygon(USCA312_GPS[, c("long", "lat")][tour,], border = "red")
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
