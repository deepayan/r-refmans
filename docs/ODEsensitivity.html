<!DOCTYPE html><html><head><title>Help for package ODEsensitivity</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ODEsensitivity}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ODEsensitivity'><p>Performing Sensitivity Analysis in ODE Models</p></a></li>
<li><a href='#ODEmorris'><p>Morris Screening for ODE Models</p></a></li>
<li><a href='#ODEmorris.default'><p>Morris Screening for General ODE Models</p></a></li>
<li><a href='#ODEmorris.ODEnetwork'><p>Morris Screening for Objects of Class <code>ODEnetwork</code></p></a></li>
<li><a href='#ODEsobol'><p>Sobol' Sensitivity Analysis for ODE Models</p></a></li>
<li><a href='#ODEsobol.default'><p>Sobol' Sensitivity Analysis for General ODE Models</p></a></li>
<li><a href='#ODEsobol.ODEnetwork'><p>Sobol' Sensitivity Analysis for Objects of Class <code>ODEnetwork</code></p></a></li>
<li><a href='#plot.ODEmorris'><p>Plot of the Results of Morris Screening for Objects of Class <code>ODEmorris</code></p></a></li>
<li><a href='#plot.ODEsobol'><p>Plot of the Results of Sobol' Sensitivity Analysis for Objects of Class</p>
<code>ODEsobol</code></a></li>
<li><a href='#tdcc'><p>A Measure of Top-Down Correlation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.1.2</td>
</tr>
<tr>
<td>Title:</td>
<td>Sensitivity Analysis of Ordinary Differential Equations</td>
</tr>
<tr>
<td>Description:</td>
<td>Performs sensitivity analysis in ordinary differential equation (ode) models.
    The package utilize the ode interface from 'deSolve' and connects it with the 
    sensitivity analysis from 'sensitivity'. Additionally we add a method to
    run the sensitivity analysis on variables with class 'ODEnetwork'. A detailed
    plotting function provides outputs on the calculations.
    The method is described by Weber, Theers, Surmann, Ligges, and Weihs (2018) &lt;<a href="https://doi.org/10.17877%2FDE290R-18874">doi:10.17877/DE290R-18874</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/surmann/ODEsensitivity">https://github.com/surmann/ODEsensitivity</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/surmann/ODEsensitivity/issues">https://github.com/surmann/ODEsensitivity/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.1), checkmate, deSolve, ODEnetwork (&ge; 1.3.0),
sensitivity (&ge; 1.12.1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, knitr, parallel, rmarkdown, testthat</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-01-09 08:50:48 UTC; Dirk</td>
</tr>
<tr>
<td>Author:</td>
<td>Frank Weber [aut],
  Stefan Theers [aut],
  Dirk Surmann <a href="https://orcid.org/0000-0003-0873-137X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dirk Surmann &lt;surmann@statistik.tu-dortmund.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-01-09 09:10:04 UTC</td>
</tr>
</table>
<hr>
<h2 id='ODEsensitivity'>Performing Sensitivity Analysis in ODE Models</h2><span id='topic+ODEsensitivity'></span><span id='topic+ODEsensitivity-package'></span>

<h3>Description</h3>

<p><code>ODEsensitivity</code> provides methods to perform sensitivity analysis (SA)
in ordinary differential equation (ODE) models. Its functions are based on 
the implementations of Morris and Sobol' SA in the
<code><a href="sensitivity.html#topic+sensitivity">sensitivity</a></code> package (Pujol et al., 2015). However, a modified 
version of the <code><a href="sensitivity.html#topic+sensitivity">sensitivity</a></code>-package is required that enables 
<code><a href="sensitivity.html#topic+morris">morris</a></code>, 
<code><a href="sensitivity.html#topic+soboljansen">soboljansen</a></code> and
<code><a href="sensitivity.html#topic+sobolmartinez">sobolmartinez</a></code> to handle three-dimensional
arrays as model outputs. Each element of the third dimension of the output 
array is then used to contain the results for one state variable of the ODE 
model. Each element of the second dimension of the output array is used for 
one timepoint.
</p>


<h3>Details</h3>

<p>The main functions are <code><a href="#topic+ODEmorris">ODEmorris</a></code> and <code><a href="#topic+ODEsobol">ODEsobol</a></code>,
which are generic functions. They have default methods for general ODE models
(<code><a href="#topic+ODEmorris.default">ODEmorris.default</a>, <a href="#topic+ODEsobol.default">ODEsobol.default</a></code>) as well as methods
for objects of class <code>ODEnetwork</code> (<code><a href="#topic+ODEmorris.ODEnetwork">ODEmorris.ODEnetwork</a>, 
<a href="#topic+ODEsobol.ODEnetwork">ODEsobol.ODEnetwork</a></code>). For the latter two methods, the package 
<code>ODEnetwork</code> is required.
</p>
<p>See the <code><a href="sensitivity.html#topic+sensitivity">sensitivity</a></code> package and its 
<code><a href="sensitivity.html#topic+morris">morris</a>, <a href="sensitivity.html#topic+soboljansen">soboljansen</a></code> and 
<code><a href="sensitivity.html#topic+sobolmartinez">sobolmartinez</a></code> implementations for further 
information on sensitivity analysis in <code>R</code>.
</p>

<hr>
<h2 id='ODEmorris'>Morris Screening for ODE Models</h2><span id='topic+ODEmorris'></span>

<h3>Description</h3>

<p><code>ODEmorris</code> is the generic function for performing a sensitivity 
analysis of ODE models using Morris's elementary effects screening method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ODEmorris(mod, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ODEmorris_+3A_mod">mod</code></td>
<td>
<p>either a model function supplied in the manner as needed for 
<code><a href="deSolve.html#topic+ode">ode</a></code> (for <code><a href="#topic+ODEmorris.default">ODEmorris.default</a></code>) or an 
object of class <code>ODEnetwork</code> (for <code><a href="#topic+ODEmorris.ODEnetwork">ODEmorris.ODEnetwork</a></code>).</p>
</td></tr>
<tr><td><code id="ODEmorris_+3A_...">...</code></td>
<td>
<p>further arguments passed to methods, see <code><a href="#topic+ODEmorris.default">ODEmorris.default</a></code> 
and <code><a href="#topic+ODEmorris.ODEnetwork">ODEmorris.ODEnetwork</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two methods for this generic function: 
<code><a href="#topic+ODEmorris.default">ODEmorris.default</a></code> (for general ODE models) and
<code><a href="#topic+ODEmorris.ODEnetwork">ODEmorris.ODEnetwork</a></code> (for objects of class <code>ODEnetwork</code>,
see package <code>ODEnetwork</code>).
</p>


<h3>Author(s)</h3>

<p>Frank Weber
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ODEmorris.default">ODEmorris.default</a>, <a href="#topic+ODEmorris.ODEnetwork">ODEmorris.ODEnetwork</a></code>
</p>

<hr>
<h2 id='ODEmorris.default'>Morris Screening for General ODE Models</h2><span id='topic+ODEmorris.default'></span>

<h3>Description</h3>

<p><code>ODEmorris.default</code> is the default method of <code><a href="#topic+ODEmorris">ODEmorris</a></code>. It
performs a sensitivity analysis for general ODE models using the Morris 
screening method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
ODEmorris(mod, pars, state_init, times, binf = 0,
  bsup = 1, r = 500, design = list(type = "oat", levels = 10, grid.jump =
  1), scale = TRUE, ode_method = "lsoda", parallel_eval = FALSE,
  parallel_eval_ncores = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ODEmorris.default_+3A_mod">mod</code></td>
<td>
<p>[<code>function(Time, State, Pars)</code>]<br />
model to examine, supplied in the manner as needed for 
<code><a href="deSolve.html#topic+ode">ode</a></code> (see example below).</p>
</td></tr>
<tr><td><code id="ODEmorris.default_+3A_pars">pars</code></td>
<td>
<p>[<code>character(k)</code>]<br />
names of the parameters to be included as input variables in Morris 
screening.</p>
</td></tr>
<tr><td><code id="ODEmorris.default_+3A_state_init">state_init</code></td>
<td>
<p>[<code>numeric(z)</code>]<br />
vector of <code>z</code> initial values. Must be named (with unique names).</p>
</td></tr>
<tr><td><code id="ODEmorris.default_+3A_times">times</code></td>
<td>
<p>[<code>numeric</code>]<br />
points of time at which the sensitivity analysis should be executed (vector
of arbitrary length). The first point of time must be greater than zero.</p>
</td></tr>
<tr><td><code id="ODEmorris.default_+3A_binf">binf</code></td>
<td>
<p>[<code>character(1</code> or <code>k)</code>]<br />
vector of lower borders of possible input parameter values.
If they are all equal, a single value can be set.</p>
</td></tr>
<tr><td><code id="ODEmorris.default_+3A_bsup">bsup</code></td>
<td>
<p>[<code>character(1</code> or <code>k)</code>]<br />
vector of upper borders of possible input parameter values.
If they are all equal, a single value can be set.</p>
</td></tr>
<tr><td><code id="ODEmorris.default_+3A_r">r</code></td>
<td>
<p>[<code>integer(1 or 2)</code>]<br />
if of length 1, the number of repetitions of the <code>design</code>. If of 
length 2, a space-filling optimization of the sampling design is used, see 
<code><a href="sensitivity.html#topic+morris">morris</a></code>. However, this space-filling optimization
might lead to long runtimes, so length 1 is recommended for <code>r</code>. 
Defaults to 500.</p>
</td></tr>
<tr><td><code id="ODEmorris.default_+3A_design">design</code></td>
<td>
<p>[<code>list</code>]<br />
a list specifying the design type and its parameters,
cf. <code><a href="sensitivity.html#topic+morris">morris</a></code>.</p>
</td></tr>
<tr><td><code id="ODEmorris.default_+3A_scale">scale</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
if <code>TRUE</code>, scaling is done for the input design of experiments after 
building the design and before calculating the elementary effects,
cf. <code><a href="sensitivity.html#topic+morris">morris</a></code>. Defaults to <code>TRUE</code>, which is
highly recommended if the factors have different orders of magnitude, see
<code><a href="sensitivity.html#topic+morris">morris</a></code>.</p>
</td></tr>
<tr><td><code id="ODEmorris.default_+3A_ode_method">ode_method</code></td>
<td>
<p>[<code>character(1)</code>]<br />
method to be used for solving the differential equations, see 
<code><a href="deSolve.html#topic+ode">ode</a></code>. Defaults to <code>"lsoda"</code>.</p>
</td></tr>
<tr><td><code id="ODEmorris.default_+3A_parallel_eval">parallel_eval</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
logical indicating if the evaluation of the ODE model shall be performed
parallelized.</p>
</td></tr>
<tr><td><code id="ODEmorris.default_+3A_parallel_eval_ncores">parallel_eval_ncores</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
number of processor cores to be used for parallelization. Only applies if
<code>parallel_eval = TRUE</code>. If set to <code>NA</code> (as per default) and 
<code>parallel_eval = TRUE</code>, 1 processor core is used.</p>
</td></tr>
<tr><td><code id="ODEmorris.default_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code><a href="deSolve.html#topic+ode">ode</a></code> from <code><a href="deSolve.html#topic+deSolve">deSolve</a></code> is 
used to solve the ODE system.
</p>
<p>The sensitivity analysis is done for all state variables and all
timepoints simultaneously using <code><a href="sensitivity.html#topic+morris">morris</a></code> from the 
package <code><a href="sensitivity.html#topic+sensitivity">sensitivity</a></code>.
</p>
<p>For non-ODE models, values for <code>r</code> are typically between 10 and 50.
However, much higher values are recommended for ODE models (the default is
<code>r = 500</code>).
</p>


<h3>Value</h3>

<p>List of class <code>ODEmorris</code> of length <code>length(state_init)</code> 
containing in each element a matrix for one state variable. The
matrices themselves contain the Morris screening results for all timepoints 
(rows: <code>mu, mu.star</code> and <code>sigma</code> for every parameter; columns: 
timepoints).
</p>


<h3>Note</h3>

<p>If the evaluation of the model function takes too long, it might be helpful 
to try another ODE-solver (argument <code>ode_method</code>). The 
<code>ode_method</code>s <code>"vode"</code>, <code>"bdf"</code>, <code>"bdf_d"</code>, 
<code>"adams"</code>, <code>"impAdams"</code> and <code>"impAdams_d"</code> might be faster 
than the default <code>"lsoda"</code>.
</p>
<p>If <code><a href="sensitivity.html#topic+morris">morris</a></code> throws a warning message stating
&quot;In ... keeping ... repetitions out of ...&quot;, try using a bigger number of 
<code>levels</code> in the <code>design</code> argument (only possible for OAT design).
</p>


<h3>Author(s)</h3>

<p>Stefan Theers, Frank Weber
</p>


<h3>References</h3>

<p>J. O. Ramsay, G. Hooker, D. Campbell and J. Cao, 2007,
<em>Parameter estimation for differential equations: a generalized 
smoothing approach</em>, Journal of the Royal Statistical Society, Series B, 
69, Part 5, 741&ndash;796.
</p>


<h3>See Also</h3>

<p><code><a href="sensitivity.html#topic+morris">morris</a>, <a href="#topic+plot.ODEmorris">plot.ODEmorris</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##### Lotka-Volterra equations #####
# The model function:
LVmod &lt;- function(Time, State, Pars) {
  with(as.list(c(State, Pars)), {
    Ingestion    &lt;- rIng  * Prey * Predator
    GrowthPrey   &lt;- rGrow * Prey * (1 - Prey/K)
    MortPredator &lt;- rMort * Predator
    
    dPrey        &lt;- GrowthPrey - Ingestion
    dPredator    &lt;- Ingestion * assEff - MortPredator
    
    return(list(c(dPrey, dPredator)))
  })
}
# The parameters to be included in the sensitivity analysis and their lower 
# and upper boundaries:
LVpars  &lt;- c("rIng", "rGrow", "rMort", "assEff", "K")
LVbinf &lt;- c(0.05, 0.05, 0.05, 0.05, 1)
LVbsup &lt;- c(1.00, 3.00, 0.95, 0.95, 20)
# The initial values of the state variables:
LVinit  &lt;- c(Prey = 1, Predator = 2)
# The timepoints of interest:
LVtimes &lt;- c(0.01, seq(1, 50, by = 1))
# Morris screening:
set.seed(7292)
# Warning: The following code might take very long!

LVres_morris &lt;- ODEmorris(mod = LVmod,
                          pars = LVpars,
                          state_init = LVinit,
                          times = LVtimes,
                          binf = LVbinf,
                          bsup = LVbsup,
                          r = 500,
                          design = list(type = "oat", 
                                        levels = 10, grid.jump = 1),
                          scale = TRUE,
                          ode_method = "lsoda",
                          parallel_eval = TRUE,
                          parallel_eval_ncores = 2)


##### FitzHugh-Nagumo equations (Ramsay et al., 2007) #####
FHNmod &lt;- function(Time, State, Pars) {
  with(as.list(c(State, Pars)), {
    
    dVoltage &lt;- s * (Voltage - Voltage^3 / 3 + Current)
    dCurrent &lt;- - 1 / s *(Voltage - a + b * Current)
    
    return(list(c(dVoltage, dCurrent)))
  })
}
# Warning: The following code might take very long!

FHNres_morris &lt;- ODEmorris(mod = FHNmod,
                           pars = c("a", "b", "s"),
                           state_init = c(Voltage = -1, Current = 1),
                           times = seq(0.1, 50, by = 5),
                           binf = c(0.18, 0.18, 2.8),
                           bsup = c(0.22, 0.22, 3.2),
                           r = 500,
                           design = list(type = "oat", 
                                         levels = 50, grid.jump = 1),
                           scale = TRUE,
                           ode_method = "adams",
                           parallel_eval = TRUE,
                           parallel_eval_ncores = 2)


</code></pre>

<hr>
<h2 id='ODEmorris.ODEnetwork'>Morris Screening for Objects of Class <code>ODEnetwork</code></h2><span id='topic+ODEmorris.ODEnetwork'></span>

<h3>Description</h3>

<p><code>ODEmorris.ODEnetwork</code> performs a sensitivity analysis for objects of 
class <code>ODEnetwork</code> using the Morris screening method.
Package <code>ODEnetwork</code> is required for this function to work.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ODEnetwork'
ODEmorris(mod, pars, times, binf = 0, bsup = 1,
  r = 500, design = list(type = "oat", levels = 10, grid.jump = 1),
  scale = TRUE, ode_method = "lsoda", parallel_eval = FALSE,
  parallel_eval_ncores = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ODEmorris.ODEnetwork_+3A_mod">mod</code></td>
<td>
<p>[<code>ODEnetwork</code>]<br />
list of class <code>ODEnetwork</code>.</p>
</td></tr>
<tr><td><code id="ODEmorris.ODEnetwork_+3A_pars">pars</code></td>
<td>
<p>[<code>character(k)</code>]<br />
names of the parameters to be included as input variables in Morris 
screening. All parameter names must be contained in 
<code>names(ODEnetwork::createParamVec(mod))</code> and must not be derivable 
from other parameters supplied (e.g. <code>"k.2.1"</code> can be derived from 
<code>"k.1.2"</code>, so supplying <code>"k.1.2"</code> suffices).</p>
</td></tr>
<tr><td><code id="ODEmorris.ODEnetwork_+3A_times">times</code></td>
<td>
<p>[<code>numeric</code>]<br />
points of time at which the sensitivity analysis should be executed (vector
of arbitrary length). The first point of time must be greater than zero.</p>
</td></tr>
<tr><td><code id="ODEmorris.ODEnetwork_+3A_binf">binf</code></td>
<td>
<p>[<code>character(1</code> or <code>k)</code>]<br />
vector of lower borders of possible values for the <code>k</code> input 
parameters. If they are all equal, a single value can be set.</p>
</td></tr>
<tr><td><code id="ODEmorris.ODEnetwork_+3A_bsup">bsup</code></td>
<td>
<p>[<code>character(1</code> or <code>k)</code>]<br />
vector of upper borders of possible values for the <code>k</code> input 
parameters. If they are all equal, a single value can be set.</p>
</td></tr>
<tr><td><code id="ODEmorris.ODEnetwork_+3A_r">r</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
if of length 1, the number of repetitions of the <code>design</code>. If of 
length 2, a space-filling optimization of the sampling design is used, see 
<code><a href="sensitivity.html#topic+morris">morris</a></code>. However, this space-filling optimization
might lead to long runtimes, so length 1 is recommended for <code>r</code>. 
Defaults to 500.</p>
</td></tr>
<tr><td><code id="ODEmorris.ODEnetwork_+3A_design">design</code></td>
<td>
<p>[<code>list</code>]<br />
a list specifying the design type and its parameters,
cf. <code><a href="sensitivity.html#topic+morris">morris</a></code>.</p>
</td></tr>
<tr><td><code id="ODEmorris.ODEnetwork_+3A_scale">scale</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
if <code>TRUE</code>, scaling is done for the input design of experiments after 
building the design and before calculating the elementary effects,
cf. <code><a href="sensitivity.html#topic+morris">morris</a></code>. Defaults to <code>TRUE</code>, which is
highly recommended if the factors have different orders of magnitude, see
<code><a href="sensitivity.html#topic+morris">morris</a></code>.</p>
</td></tr>
<tr><td><code id="ODEmorris.ODEnetwork_+3A_ode_method">ode_method</code></td>
<td>
<p>[<code>character(1)</code>]<br />
method to be used for solving the ODEs in situations where the solution has
to be determined numerically, see <code><a href="deSolve.html#topic+ode">ode</a></code> for details.
Defaults to <code>"lsoda"</code>.</p>
</td></tr>
<tr><td><code id="ODEmorris.ODEnetwork_+3A_parallel_eval">parallel_eval</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
logical indicating if the evaluation of the ODE model shall be performed
parallelized.</p>
</td></tr>
<tr><td><code id="ODEmorris.ODEnetwork_+3A_parallel_eval_ncores">parallel_eval_ncores</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
number of processor cores to be used for parallelization. Only applies if
<code>parallel_eval = TRUE</code>. If set to <code>NA</code> (as per default) and 
<code>parallel_eval = TRUE</code>, 1 processor core is used.</p>
</td></tr>
<tr><td><code id="ODEmorris.ODEnetwork_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the object of class <code>ODEnetwork</code> supplied for <code>mod</code> doesn't
include any events, the solution of the ODE network is determined 
analytically using <code><a href="ODEnetwork.html#topic+simuNetwork">simuNetwork</a></code>. In the presence
of events, <code><a href="ODEnetwork.html#topic+simuNetwork">simuNetwork</a></code> uses 
<code><a href="deSolve.html#topic+ode">ode</a></code> to solve the ODE network numerically.
</p>
<p>The sensitivity analysis is done for all state variables and all
timepoints simultaneously using <code><a href="sensitivity.html#topic+morris">morris</a></code> from the 
package <code>sensitivity</code>.
</p>
<p>For non-ODE models, values for <code>r</code> are typically between 10 and 50.
However, much higher values are recommended for ODE models (the default is
<code>r = 500</code>).
</p>


<h3>Value</h3>

<p>List of class <code>ODEmorris</code> of length <code>2 * nrow(mod$state)</code> 
containing in each element a matrix for one state variable (all components 
of the 2 state variables are analyzed independently). The matrices 
themselves contain the Morris screening results for all timepoints (rows: 
<code>mu, mu.star</code> and <code>sigma</code> for every parameter; columns: 
timepoints).
</p>


<h3>Note</h3>

<p>In situations where the solution of the ODE model has to be determined 
numerically, it might be helpful to try another ODE-solver if the 
evaluation of the model function takes too long, (argument 
<code>ode_method</code>). The <code>ode_method</code>s <code>"vode"</code>, <code>"bdf"</code>, 
<code>"bdf_d"</code>, <code>"adams"</code>, <code>"impAdams"</code> and <code>"impAdams_d"</code> 
might be faster than the default <code>"lsoda"</code>.
</p>
<p>If <code><a href="sensitivity.html#topic+morris">morris</a></code> throws a warning message stating
&quot;In ... keeping ... repetitions out of ...&quot;, try using a bigger number of 
<code>levels</code> in the <code>design</code> argument (only possible for OAT design).
</p>


<h3>Author(s)</h3>

<p>Frank Weber
</p>


<h3>See Also</h3>

<p><code><a href="sensitivity.html#topic+morris">morris</a>, <a href="#topic+plot.ODEmorris">plot.ODEmorris</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##### A network of 4 mechanical oscillators connected in a circle #####
# Definition of the network using the package "ODEnetwork":
M_mat &lt;- rep(2, 4)
K_mat &lt;- diag(rep(2 * (2*pi*0.17)^2, 4))
K_mat[1, 2] &lt;- K_mat[2, 3] &lt;- 
  K_mat[3, 4] &lt;- K_mat[1, 4] &lt;- 2 * (2*pi*0.17)^2 / 10
D_mat &lt;- diag(rep(0.05, 4))
library("ODEnetwork")
lfonet &lt;- ODEnetwork(masses = M_mat, dampers = D_mat, springs = K_mat)
# The parameters to be included in the sensitivity analysis and their lower
# and upper boundaries:
LFOpars &lt;- c("k.1", "k.2", "k.3", "k.4",
             "d.1", "d.2", "d.3", "d.4")
LFObinf &lt;- c(rep(0.2, 4), rep(0.01, 4))
LFObsup &lt;- c(rep(20, 4), rep(0.1, 4))
# Setting of the initial values of the state variables:
lfonet &lt;- setState(lfonet, state1 = rep(2, 4), state2 = rep(0, 4))
# The timepoints of interest:
LFOtimes &lt;- seq(25, 150, by = 2.5)
# Morris screening:
set.seed(283)
# Warning: The following code might take very long!

LFOres_morris &lt;- ODEmorris(mod = lfonet,
                           pars = LFOpars,
                           times = LFOtimes,
                           binf = LFObinf,
                           bsup = LFObsup,
                           r = 500,
                           design = list(type = "oat", 
                                         levels = 10, grid.jump = 1),
                           scale = TRUE,
                           parallel_eval = TRUE,
                           parallel_eval_ncores = 2)


</code></pre>

<hr>
<h2 id='ODEsobol'>Sobol' Sensitivity Analysis for ODE Models</h2><span id='topic+ODEsobol'></span>

<h3>Description</h3>

<p><code>ODEsobol</code> is the generic function for performing a Sobol' sensitivity
analysis of ODE models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ODEsobol(mod, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ODEsobol_+3A_mod">mod</code></td>
<td>
<p>either a model function supplied in the manner as needed for 
<code><a href="deSolve.html#topic+ode">ode</a></code> (for <code><a href="#topic+ODEsobol.default">ODEsobol.default</a></code>) or an 
object of class <code>ODEnetwork</code> (for <code><a href="#topic+ODEsobol.ODEnetwork">ODEsobol.ODEnetwork</a></code>).</p>
</td></tr>
<tr><td><code id="ODEsobol_+3A_...">...</code></td>
<td>
<p>further arguments passed to methods, see <code><a href="#topic+ODEsobol.default">ODEsobol.default</a></code> and
<code><a href="#topic+ODEsobol.ODEnetwork">ODEsobol.ODEnetwork</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two methods for this generic function: 
<code><a href="#topic+ODEsobol.default">ODEsobol.default</a></code> (for general ODE models) and
<code><a href="#topic+ODEsobol.ODEnetwork">ODEsobol.ODEnetwork</a></code> (for objects of class <code>ODEnetwork</code>,
see package <code>ODEnetwork</code>).
</p>


<h3>Author(s)</h3>

<p>Frank Weber
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ODEsobol.default">ODEsobol.default</a>, <a href="#topic+ODEsobol.ODEnetwork">ODEsobol.ODEnetwork</a></code>
</p>

<hr>
<h2 id='ODEsobol.default'>Sobol' Sensitivity Analysis for General ODE Models</h2><span id='topic+ODEsobol.default'></span>

<h3>Description</h3>

<p><code>ODEsobol.default</code> is the default method of <code><a href="#topic+ODEsobol">ODEsobol</a></code>. It
performs the variance-based Sobol' sensitivity analysis for general ODE 
models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
ODEsobol(mod, pars, state_init, times, n = 1000,
  rfuncs = "runif", rargs = "min = 0, max = 1", sobol_method = "Martinez",
  ode_method = "lsoda", parallel_eval = FALSE, parallel_eval_ncores = NA,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ODEsobol.default_+3A_mod">mod</code></td>
<td>
<p>[<code>function(Time, State, Pars)</code>]<br />
model to examine, supplied in the manner as needed for 
<code><a href="deSolve.html#topic+ode">ode</a></code> (see example below).</p>
</td></tr>
<tr><td><code id="ODEsobol.default_+3A_pars">pars</code></td>
<td>
<p>[<code>character(k)</code>]<br />
names of the parameters to be included as input variables in the Sobol'
sensitivity analysis.</p>
</td></tr>
<tr><td><code id="ODEsobol.default_+3A_state_init">state_init</code></td>
<td>
<p>[<code>numeric(z)</code>]<br />
vector of <code>z</code> initial values. Must be named (with unique names).</p>
</td></tr>
<tr><td><code id="ODEsobol.default_+3A_times">times</code></td>
<td>
<p>[<code>numeric</code>]<br />
points of time at which the sensitivity analysis should be executed (vector
of arbitrary length). The first point of time must be greater than zero.</p>
</td></tr>
<tr><td><code id="ODEsobol.default_+3A_n">n</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
number of random parameter values used to estimate the Sobol' sensitivity 
indices by Monte Carlo simulation. Defaults to 1000.</p>
</td></tr>
<tr><td><code id="ODEsobol.default_+3A_rfuncs">rfuncs</code></td>
<td>
<p>[<code>character(1</code> or <code>k)</code>]<br />
names of the functions used to generate the <code>n</code> random values
for the <code>k</code> parameters. Can be of length 1 or <code>k</code>. If of length 
1, the same function is used for all parameters. Defaults to 
<code>"runif"</code>, so a uniform distribution is assumed for all parameters.</p>
</td></tr>
<tr><td><code id="ODEsobol.default_+3A_rargs">rargs</code></td>
<td>
<p>[<code>character(1</code> or <code>k)</code>]<br />
arguments to be passed to the functions in <code>rfuncs</code>. Can be of length 
1 or <code>k</code>. If of length 1, the same arguments are used for all 
parameters. Each element of <code>rargs</code> has to be a string of the form 
<code>"tag1 = value1, tag2 = value2, ..."</code>, see example below. Default is 
<code>"min = 0, max = 1"</code>, so (together with the default value of 
<code>rfuncs</code>) a uniform distribution on [0, 1] is assumed for all 
parameters.</p>
</td></tr>
<tr><td><code id="ODEsobol.default_+3A_sobol_method">sobol_method</code></td>
<td>
<p>[<code>character(1)</code>]<br />
either <code>"Jansen"</code> or <code>"Martinez"</code>, specifying which modification
of the variance-based Sobol' method shall be used. Defaults to 
<code>"Martinez"</code>.</p>
</td></tr>
<tr><td><code id="ODEsobol.default_+3A_ode_method">ode_method</code></td>
<td>
<p>[<code>character(1)</code>]<br />
method to be used for solving the differential equations, see 
<code><a href="deSolve.html#topic+ode">ode</a></code>. Defaults to <code>"lsoda"</code>.</p>
</td></tr>
<tr><td><code id="ODEsobol.default_+3A_parallel_eval">parallel_eval</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
logical indicating if the evaluation of the ODE model shall be performed
parallelized.</p>
</td></tr>
<tr><td><code id="ODEsobol.default_+3A_parallel_eval_ncores">parallel_eval_ncores</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
number of processor cores to be used for parallelization. Only applies if
<code>parallel_eval = TRUE</code>. If set to <code>NA</code> (as per default) and 
<code>parallel_eval = TRUE</code>, 1 processor core is used.</p>
</td></tr>
<tr><td><code id="ODEsobol.default_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code><a href="deSolve.html#topic+ode">ode</a></code> from <code><a href="deSolve.html#topic+deSolve">deSolve</a></code> is 
used to solve the ODE system.
</p>
<p>The sensitivity analysis is done for all state variables and all
timepoints simultaneously. If <code>sobol_method = "Jansen"</code>,
<code><a href="sensitivity.html#topic+soboljansen">soboljansen</a></code> from the package 
<code><a href="sensitivity.html#topic+sensitivity">sensitivity</a></code>
is used to estimate the Sobol' sensitivity indices and if 
<code>sobol_method = "Martinez"</code>, <code><a href="sensitivity.html#topic+sobolmartinez">sobolmartinez</a></code>
is used (also from the package <code><a href="sensitivity.html#topic+sensitivity">sensitivity</a></code>).
</p>


<h3>Value</h3>

<p>List of length <code>length(state_init)</code> and of class <code>ODEsobol</code> 
containing in each element a list of the Sobol' sensitivity analysis 
results for the corresponding <code>state_init</code>-variable (i.e. first order 
sensitivity indices <code>S</code> and total sensitivity indices <code>T</code>) for 
every point of time in the <code>times</code> vector. This list has an extra 
attribute <code>"sobol_method"</code> where the value of argument 
<code>sobol_method</code> is stored (either <code>"Jansen"</code> or 
<code>"Martinez"</code>).
</p>


<h3>Note</h3>

<p>If the evaluation of the model function takes too long, it might be 
helpful to try a different type of ODE-solver (argument <code>ode_method</code>). 
The <code>ode_method</code>s <code>"vode"</code>, <code>"bdf"</code>, <code>"bdf_d"</code>, 
<code>"adams"</code>, <code>"impAdams"</code> and <code>"impAdams_d"</code> 
might be faster than the standard <code>ode_method</code> <code>"lsoda"</code>.
</p>
<p>If <code>n</code> is too low, the Monte Carlo estimation of the sensitivity 
indices might be very bad and even produce first order indices &lt; 0 or
total indices &gt; 1. First order indices in the interval [-0.05, 0) and total 
indices in (1, 1.05] are considered as minor deviations and set to 0 
resp. 1 without a warning. First order indices &lt; -0.05 or total indices 
&gt; 1.05 are considered as major deviations. They remain unchanged and a 
warning is thrown. Up to now, first order indices &gt; 1 or total indices &lt; 0
haven't occured yet. If this should be the case, please contact the package
author.
</p>


<h3>Author(s)</h3>

<p>Stefan Theers, Frank Weber
</p>


<h3>References</h3>

<p>J. O. Ramsay, G. Hooker, D. Campbell and J. Cao, 2007,
<em>Parameter estimation for differential equations: a generalized 
smoothing approach</em>, Journal of the Royal Statistical Society, Series B, 
69, Part 5, 741&ndash;796.
</p>


<h3>See Also</h3>

<p><code><a href="sensitivity.html#topic+soboljansen">soboljansen</a>,
  <a href="sensitivity.html#topic+sobolmartinez">sobolmartinez</a>,
  <a href="#topic+plot.ODEsobol">plot.ODEsobol</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##### Lotka-Volterra equations #####
# The model function:
LVmod &lt;- function(Time, State, Pars) {
  with(as.list(c(State, Pars)), {
    Ingestion    &lt;- rIng  * Prey * Predator
    GrowthPrey   &lt;- rGrow * Prey * (1 - Prey/K)
    MortPredator &lt;- rMort * Predator
    
    dPrey        &lt;- GrowthPrey - Ingestion
    dPredator    &lt;- Ingestion * assEff - MortPredator
    
    return(list(c(dPrey, dPredator)))
  })
}
# The parameters to be included in the sensitivity analysis and their lower 
# and upper boundaries:
LVpars  &lt;- c("rIng", "rGrow", "rMort", "assEff", "K")
LVbinf &lt;- c(0.05, 0.05, 0.05, 0.05, 1)
LVbsup &lt;- c(1.00, 3.00, 0.95, 0.95, 20)
# The initial values of the state variables:
LVinit  &lt;- c(Prey = 1, Predator = 2)
# The timepoints of interest:
LVtimes &lt;- c(0.01, seq(1, 50, by = 1))
set.seed(59281)
# Sobol' sensitivity analysis (here only with n = 500, but n = 1000 is
# recommended):
# Warning: The following code might take very long!

LVres_sobol &lt;- ODEsobol(mod = LVmod,
                        pars = LVpars,
                        state_init = LVinit,
                        times = LVtimes,
                        n = 500,
                        rfuncs = "runif",
                        rargs = paste0("min = ", LVbinf,
                                       ", max = ", LVbsup),
                        sobol_method = "Martinez",
                        ode_method = "lsoda",
                        parallel_eval = TRUE,
                        parallel_eval_ncores = 2)


##### FitzHugh-Nagumo equations (Ramsay et al., 2007) #####
FHNmod &lt;- function(Time, State, Pars) {
  with(as.list(c(State, Pars)), {
    
    dVoltage &lt;- s * (Voltage - Voltage^3 / 3 + Current)
    dCurrent &lt;- - 1 / s *(Voltage - a + b * Current)
    
    return(list(c(dVoltage, dCurrent)))
  })
}
# Warning: The following code might take very long!

FHNres_sobol &lt;- ODEsobol(mod = FHNmod,
                         pars = c("a", "b", "s"),
                         state_init = c(Voltage = -1, Current = 1),
                         times = seq(0.1, 50, by = 5),
                         n = 500,
                         rfuncs = "runif",
                         rargs = c(rep("min = 0.18, max = 0.22", 2),
                                   "min = 2.8, max = 3.2"),
                         sobol_method = "Martinez",
                         ode_method = "adams",
                         parallel_eval = TRUE,
                         parallel_eval_ncores = 2)

# Just for demonstration purposes: The use of different distributions for the 
# parameters (here, the distributions and their arguments are chosen 
# completely arbitrarily):
# Warning: The following code might take very long!

demo_dists &lt;- ODEsobol(mod = FHNmod,
                       pars = c("a", "b", "s"),
                       state_init = c(Voltage = -1, Current = 1),
                       times = seq(0.1, 50, by = 5),
                       n = 500,
                       rfuncs = c("runif", "rnorm", "rexp"),
                       rargs = c("min = 0.18, max = 0.22",
                                 "mean = 0.2, sd = 0.2 / 3",
                                 "rate = 1 / 3"),
                       sobol_method = "Martinez",
                       ode_method = "adams",
                       parallel_eval = TRUE,
                       parallel_eval_ncores = 2)


</code></pre>

<hr>
<h2 id='ODEsobol.ODEnetwork'>Sobol' Sensitivity Analysis for Objects of Class <code>ODEnetwork</code></h2><span id='topic+ODEsobol.ODEnetwork'></span>

<h3>Description</h3>

<p><code>ODEsobol.ODEnetwork</code> performs the variance-based Sobol' sensitivity 
analysis for objects of class <code>ODEnetwork</code>. Package 
<code>ODEnetwork</code> is required for this function to work.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ODEnetwork'
ODEsobol(mod, pars, times, n = 1000, rfuncs = "runif",
  rargs = "min = 0, max = 1", sobol_method = "Martinez",
  ode_method = "lsoda", parallel_eval = FALSE, parallel_eval_ncores = NA,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ODEsobol.ODEnetwork_+3A_mod">mod</code></td>
<td>
<p>[<code>ODEnetwork</code>]<br />
list of class <code>ODEnetwork</code>.</p>
</td></tr>
<tr><td><code id="ODEsobol.ODEnetwork_+3A_pars">pars</code></td>
<td>
<p>[<code>character(k)</code>]<br />
names of the parameters to be included as input variables in the Sobol'
sensitivity analysis. All parameters must be contained in 
<code>names(ODEnetwork::createParamVec(mod))</code> and must not be derivable 
from other parameters supplied (e.g. <code>"k.2.1"</code> can be derived from 
<code>"k.1.2"</code>, so supplying <code>"k.1.2"</code> suffices).</p>
</td></tr>
<tr><td><code id="ODEsobol.ODEnetwork_+3A_times">times</code></td>
<td>
<p>[<code>numeric</code>]<br />
points of time at which the sensitivity analysis should be executed (vector
of arbitrary length). The first point of time must be greater than zero.</p>
</td></tr>
<tr><td><code id="ODEsobol.ODEnetwork_+3A_n">n</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
number of random parameter values used to estimate the Sobol' sensitivity 
indices by Monte Carlo simulation. Defaults to 1000.</p>
</td></tr>
<tr><td><code id="ODEsobol.ODEnetwork_+3A_rfuncs">rfuncs</code></td>
<td>
<p>[<code>character(1</code> or <code>k)</code>]<br />
names of the functions used to generate the <code>n</code> random values
for the <code>k</code> parameters. Can be of length 1 or <code>k</code>. If of length 
1, the same function is used for all parameters. Defaults to 
<code>"runif"</code>, so a uniform distribution is assumed for all parameters.</p>
</td></tr>
<tr><td><code id="ODEsobol.ODEnetwork_+3A_rargs">rargs</code></td>
<td>
<p>[<code>character(1</code> or <code>k)</code>]<br />
arguments to be passed to the functions in <code>rfuncs</code>. Can be of length 
1 or <code>k</code>. If of length 1, the same arguments are used for all 
parameters. Each element of <code>rargs</code> has to be a string of the form 
<code>"tag1 = value1, tag2 = value2, ..."</code>, see example below. Default is 
<code>"min = 0, max = 1"</code>, so (together with the default value of 
<code>rfuncs</code>) a uniform distribution on [0, 1] is assumed for all 
parameters.</p>
</td></tr>
<tr><td><code id="ODEsobol.ODEnetwork_+3A_sobol_method">sobol_method</code></td>
<td>
<p>[<code>character(1)</code>]<br />
either <code>"Jansen"</code> or <code>"Martinez"</code>, specifying which modification
of the variance-based Sobol' method shall be used. Defaults to 
<code>"Martinez"</code>.</p>
</td></tr>
<tr><td><code id="ODEsobol.ODEnetwork_+3A_ode_method">ode_method</code></td>
<td>
<p>[<code>character(1)</code>]<br />
method to be used for solving the ODEs in situations where the solution has
to be determined numerically, see <code><a href="deSolve.html#topic+ode">ode</a></code> for details.
Defaults to <code>"lsoda"</code>.</p>
</td></tr>
<tr><td><code id="ODEsobol.ODEnetwork_+3A_parallel_eval">parallel_eval</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
logical indicating if the evaluation of the ODE model shall be performed
parallelized.</p>
</td></tr>
<tr><td><code id="ODEsobol.ODEnetwork_+3A_parallel_eval_ncores">parallel_eval_ncores</code></td>
<td>
<p>[<code>integer(1)</code>]<br />
number of processor cores to be used for parallelization. Only applies if
<code>parallel_eval = TRUE</code>. If set to <code>NA</code> (as per default) and 
<code>parallel_eval = TRUE</code>, 1 processor core is used.</p>
</td></tr>
<tr><td><code id="ODEsobol.ODEnetwork_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the object of class <code>ODEnetwork</code> supplied for <code>mod</code> doesn't
include any events, the solution of the ODE network is determined 
analytically using <code><a href="ODEnetwork.html#topic+simuNetwork">simuNetwork</a></code>. In the presence
of events, <code><a href="ODEnetwork.html#topic+simuNetwork">simuNetwork</a></code> uses 
<code><a href="deSolve.html#topic+ode">ode</a></code> to solve the ODE network numerically.
</p>
<p>The sensitivity analysis is done for all state variables and all
timepoints simultaneously. If <code>sobol_method = "Jansen"</code>,
<code><a href="sensitivity.html#topic+soboljansen">soboljansen</a></code> from the package <code>sensitivity</code>
is used to estimate the Sobol' sensitivity indices and if 
<code>sobol_method = "Martinez"</code>, <code><a href="sensitivity.html#topic+sobolmartinez">sobolmartinez</a></code>
is used (also from the package <code>sensitivity</code>).
</p>


<h3>Value</h3>

<p>List of length <code>2 * nrow(mod$state)</code> and of class 
<code>ODEsobol</code> containing in each element a list of the Sobol' sensitivity
analysis results for the corresponding state variable (i.e. first order 
sensitivity indices <code>S</code> and total sensitivity indices <code>T</code>) for 
every point of time in the <code>times</code> vector. This list has an extra 
attribute <code>"sobol_method"</code> where the value of argument 
<code>sobol_method</code> is stored (either <code>"Jansen"</code> or 
<code>"Martinez"</code>).
</p>


<h3>Note</h3>

<p>In situations where the solution of the ODE model has to be determined 
numerically, it might be helpful to try a different type of ODE-solver 
(argument <code>ode_method</code>) if the simulation of the model takes too long.
The <code>ode_method</code>s <code>"vode"</code>, <code>"bdf"</code>, <code>"bdf_d"</code>, 
<code>"adams"</code>, <code>"impAdams"</code> and <code>"impAdams_d"</code> 
might be faster than the standard <code>ode_method</code> <code>"lsoda"</code>.
</p>
<p>If <code>n</code> is too low, the Monte Carlo estimation of the sensitivity 
indices might be very bad and even produce first order indices &lt; 0 or
total indices &gt; 1. First order indices in the interval [-0.05, 0) and total 
indices in (1, 1.05] are considered as minor deviations and set to 0 
resp. 1 without a warning. First order indices &lt; -0.05 or total indices 
&gt; 1.05 are considered as major deviations. They remain unchanged and a 
warning is thrown. Up to now, first order indices &gt; 1 or total indices &lt; 0
haven't occured yet. If this should be the case, please contact the package
author.
</p>


<h3>Author(s)</h3>

<p>Frank Weber
</p>


<h3>See Also</h3>

<p><code><a href="sensitivity.html#topic+soboljansen">soboljansen</a>, 
  <a href="sensitivity.html#topic+sobolmartinez">sobolmartinez</a>,
  <a href="#topic+plot.ODEsobol">plot.ODEsobol</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##### A network of 4 mechanical oscillators connected in a circle #####
# Definition of the network using the package "ODEnetwork":
M_mat &lt;- rep(2, 4)
K_mat &lt;- diag(rep(2 * (2*pi*0.17)^2, 4))
K_mat[1, 2] &lt;- K_mat[2, 3] &lt;- 
  K_mat[3, 4] &lt;- K_mat[1, 4] &lt;- 2 * (2*pi*0.17)^2 / 10
D_mat &lt;- diag(rep(0.05, 4))
library("ODEnetwork")
lfonet &lt;- ODEnetwork(masses = M_mat, dampers = D_mat, springs = K_mat)
# The parameters to be included in the sensitivity analysis and their lower
# and upper boundaries:
LFOpars &lt;- c("k.1", "k.2", "k.3", "k.4",
             "d.1", "d.2", "d.3", "d.4")
LFObinf &lt;- c(rep(0.2, 4), rep(0.01, 4))
LFObsup &lt;- c(rep(20, 4), rep(0.1, 4))
# Setting of the initial values of the state variables:
lfonet &lt;- setState(lfonet, state1 = rep(2, 4), state2 = rep(0, 4))
# The timepoints of interest:
LFOtimes &lt;- seq(25, 150, by = 2.5)
# Sobol' sensitivity analysis (here only with n = 500, but n = 1000 is
# recommended):
set.seed(1739)
# Warning: The following code might take very long! There are warnings
# occurring which might be due to "n" being too low.

suppressWarnings(
  LFOres_sobol &lt;- ODEsobol(mod = lfonet,
                           pars = LFOpars,
                           times = LFOtimes,
                           n = 500,
                           rfuncs = "runif",
                           rargs = paste0("min = ", LFObinf,
                                          ", max = ", LFObsup),
                           sobol_method = "Martinez",
                           parallel_eval = TRUE,
                           parallel_eval_ncores = 2)
)


</code></pre>

<hr>
<h2 id='plot.ODEmorris'>Plot of the Results of Morris Screening for Objects of Class <code>ODEmorris</code></h2><span id='topic+plot.ODEmorris'></span>

<h3>Description</h3>

<p><code>plot.ODEmorris</code> plots the results of Morris screening for objects of 
class <code>ODEmorris</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ODEmorris'
plot(x, pars_plot = NULL, state_plot = names(x)[1],
  kind = "sep", colors_pars = NULL, main_title = NULL,
  legendPos = "outside", type = "l", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ODEmorris_+3A_x">x</code></td>
<td>
<p>[<code>ODEmorris</code>]<br />
output of <code><a href="#topic+ODEmorris">ODEmorris</a></code> (of class <code>ODEmorris</code>).</p>
</td></tr>
<tr><td><code id="plot.ODEmorris_+3A_pars_plot">pars_plot</code></td>
<td>
<p>[<code>character(k)</code>]<br />
names of the <code>k</code> parameters to be plotted. If <code>NULL</code> (the 
default), all parameters are plotted.</p>
</td></tr>
<tr><td><code id="plot.ODEmorris_+3A_state_plot">state_plot</code></td>
<td>
<p>[<code>character(1)</code>]<br />
name of the state variable to be plotted. Defaults to the name of the
first state variable.</p>
</td></tr>
<tr><td><code id="plot.ODEmorris_+3A_kind">kind</code></td>
<td>
<p>[<code>character(1)</code>]<br />
kind of the plot, choose between <code>"sep"</code> and <code>"trajec"</code> (see 
details).</p>
</td></tr>
<tr><td><code id="plot.ODEmorris_+3A_colors_pars">colors_pars</code></td>
<td>
<p>[<code>character(&gt;= k)</code>]<br />
vector of the colors to be used for the <code>k</code> different parameters. Must
be at least of length <code>k</code> (only the first <code>k</code> elements will be
used, though). If <code>NULL</code> (the default), <code>rainbow(k)</code> is used.</p>
</td></tr>
<tr><td><code id="plot.ODEmorris_+3A_main_title">main_title</code></td>
<td>
<p>[<code>character(1)</code>]<br />
title for the plot. If <code>kind = "sep"</code>, this is the overall title for
the two separate plots. If <code>NULL</code> (the default), a standard title is 
generated.</p>
</td></tr>
<tr><td><code id="plot.ODEmorris_+3A_legendpos">legendPos</code></td>
<td>
<p>[<code>character(1)</code>]<br />
keyword for the legend position, either one of those specified in
<code><a href="graphics.html#topic+legend">legend</a></code> or <code>"outside"</code> (the default), which means the 
legend is placed under the plot (useful, if there are many parameters in 
the model).</p>
</td></tr>
<tr><td><code id="plot.ODEmorris_+3A_type">type</code></td>
<td>
<p>[<code>character(1)</code>]<br />
plot type, i.e. <code>"p", "l", "b", "c", "o", "s", "h"</code> or <code>"n"</code>. 
Defaults to <code>"l"</code>.</p>
</td></tr>
<tr><td><code id="plot.ODEmorris_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Morris sensitivity indices are plotted for one state variable (chosen by 
argument <code>state_plot</code>) and the parameters named in <code>pars_plot</code>. 
If no parameters are named in <code>pars_plot</code>, the sensitivity indices for
all parameters are plotted. There are two kinds of plots:
</p>

<ul>
<li><p><code>kind = "sep"</code>: separate plots of the Morris sensitivity 
indices <code class="reqn">\mu^*</code> and <code class="reqn">\sigma</code> against time
</p>
</li>
<li><p><code>kind = "trajec"</code>: plot of <code class="reqn">\mu^*</code> against 
<code class="reqn">\sigma</code>
</p>
</li></ul>



<h3>Value</h3>

<p><code>TRUE</code> (invisible; for testing purposes).
</p>


<h3>Note</h3>

<p>Not all plotting arguments can be passed by <code>...</code>, for example
<code>xlab</code> and <code>ylab</code> are fixed.
</p>


<h3>Author(s)</h3>

<p>Stefan Theers, Frank Weber
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ODEmorris">ODEmorris</a>, <a href="sensitivity.html#topic+morris">morris</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##### Lotka-Volterra equations #####
LVmod &lt;- function(Time, State, Pars) {
  with(as.list(c(State, Pars)), {
    Ingestion    &lt;- rIng  * Prey * Predator
    GrowthPrey   &lt;- rGrow * Prey * (1 - Prey/K)
    MortPredator &lt;- rMort * Predator
    
    dPrey        &lt;- GrowthPrey - Ingestion
    dPredator    &lt;- Ingestion * assEff - MortPredator
    
    return(list(c(dPrey, dPredator)))
  })
}
LVpars  &lt;- c("rIng", "rGrow", "rMort", "assEff", "K")
LVbinf &lt;- c(0.05, 0.05, 0.05, 0.05, 1)
LVbsup &lt;- c(1.00, 3.00, 0.95, 0.95, 20)
LVinit  &lt;- c(Prey = 1, Predator = 2)
LVtimes &lt;- c(0.01, seq(1, 50, by = 1))
set.seed(7292)
# Warning: The following code might take very long!

LVres_morris &lt;- ODEmorris(mod = LVmod,
                          pars = LVpars,
                          state_init = LVinit,
                          times = LVtimes,
                          binf = LVbinf,
                          bsup = LVbsup,
                          r = 500,
                          design = list(type = "oat", 
                                        levels = 10, grid.jump = 1),
                          scale = TRUE,
                          ode_method = "lsoda",
                          parallel_eval = TRUE,
                          parallel_eval_ncores = 2)
my_cols &lt;- c("firebrick", "orange2", "dodgerblue", 
             "forestgreen", "black")
plot(LVres_morris, kind = "sep", colors_pars = my_cols)
plot(LVres_morris, pars_plot = c("rGrow", "rMort"), state_plot = "Predator", 
     kind = "trajec", colors_pars = my_cols[2:3])


##### A network of 4 mechanical oscillators connected in a circle #####
M_mat &lt;- rep(2, 4)
K_mat &lt;- diag(rep(2 * (2*pi*0.17)^2, 4))
K_mat[1, 2] &lt;- K_mat[2, 3] &lt;- 
  K_mat[3, 4] &lt;- K_mat[1, 4] &lt;- 2 * (2*pi*0.17)^2 / 10
D_mat &lt;- diag(rep(0.05, 4))
library("ODEnetwork")
lfonet &lt;- ODEnetwork(masses = M_mat, dampers = D_mat, springs = K_mat)
LFOpars &lt;- c("k.1", "k.2", "k.3", "k.4",
             "d.1", "d.2", "d.3", "d.4")
LFObinf &lt;- c(rep(0.2, 4), rep(0.01, 4))
LFObsup &lt;- c(rep(20, 4), rep(0.1, 4))
lfonet &lt;- setState(lfonet, state1 = rep(2, 4), state2 = rep(0, 4))
LFOtimes &lt;- seq(25, 150, by = 2.5)
set.seed(283)
# Warning: The following code might take very long!

LFOres_morris &lt;- ODEmorris(mod = lfonet,
                           pars = LFOpars,
                           times = LFOtimes,
                           binf = LFObinf,
                           bsup = LFObsup,
                           r = 500,
                           design = list(type = "oat", 
                                         levels = 10, grid.jump = 1),
                           scale = TRUE,
                           parallel_eval = TRUE,
                           parallel_eval_ncores = 2)
plot(LFOres_morris, pars_plot = paste0("k.", 1:4), state_plot = "x.2",
     kind = "sep", colors_pars = my_cols)


</code></pre>

<hr>
<h2 id='plot.ODEsobol'>Plot of the Results of Sobol' Sensitivity Analysis for Objects of Class 
<code>ODEsobol</code></h2><span id='topic+plot.ODEsobol'></span>

<h3>Description</h3>

<p><code>plot.ODEsobol</code> plots the results of Sobol' SA for objects of class 
<code>ODEsobol</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ODEsobol'
plot(x, pars_plot = NULL, state_plot = names(x)[1],
  colors_pars = NULL, main_title = NULL, legendPos = "outside",
  type = "l", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ODEsobol_+3A_x">x</code></td>
<td>
<p>[<code>ODEsobol</code>]<br />
output of <code><a href="#topic+ODEsobol">ODEsobol</a></code> (of class <code>ODEsobol</code>).</p>
</td></tr>
<tr><td><code id="plot.ODEsobol_+3A_pars_plot">pars_plot</code></td>
<td>
<p>[<code>character(k)</code>]<br />
names of the <code>k</code> parameters to be plotted. If <code>NULL</code> (the 
default), all parameters are plotted.</p>
</td></tr>
<tr><td><code id="plot.ODEsobol_+3A_state_plot">state_plot</code></td>
<td>
<p>[<code>character(1)</code>]<br />
name of the state variable to be plotted. Defaults to the name of the
first state variable.</p>
</td></tr>
<tr><td><code id="plot.ODEsobol_+3A_colors_pars">colors_pars</code></td>
<td>
<p>[<code>character(&gt;= k)</code>]<br />
vector of the colors to be used for the <code>k</code> different parameters. Must
be at least of length <code>k</code> (only the first <code>k</code> elements will be
used, though). If <code>NULL</code> (the default), <code>rainbow(k)</code> is used.</p>
</td></tr>
<tr><td><code id="plot.ODEsobol_+3A_main_title">main_title</code></td>
<td>
<p>[<code>character(1)</code>]<br />
common title for the two graphics. Default is <code>NULL</code>, which means
an automatic title is generated.</p>
</td></tr>
<tr><td><code id="plot.ODEsobol_+3A_legendpos">legendPos</code></td>
<td>
<p>[<code>character(1)</code>]<br />
keyword for the legend position, either one of those specified in
<code><a href="graphics.html#topic+legend">legend</a></code> or <code>"outside"</code> (the default), which means the 
legend is placed under the plot (useful, if there are many parameters in 
the model).</p>
</td></tr>
<tr><td><code id="plot.ODEsobol_+3A_type">type</code></td>
<td>
<p>[<code>character(1)</code>]<br />
plot type, i.e. <code>"p", "l", "b", "c", "o", "s", "h"</code> or <code>"n"</code>. 
Defaults to <code>"l"</code>.</p>
</td></tr>
<tr><td><code id="plot.ODEsobol_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First order and total Sobol' sensitivity indices are plotted for one state 
variable (chosen by argument <code>state_plot</code>) and the parameters named
in <code>pars_plot</code> against time. If no parameters are named in 
<code>pars_plot</code>, the sensitivity indices for all parameters are plotted.
</p>


<h3>Value</h3>

<p>TRUE (invisible; for testing purposes).
</p>


<h3>Note</h3>

<p>Not all arguments of <code><a href="graphics.html#topic+plot.default">plot.default</a></code> can be passed by 
<code>...</code>, for example <code>xlab</code> and <code>ylab</code> are fixed.
</p>


<h3>Author(s)</h3>

<p>Stefan Theers, Frank Weber
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ODEsobol">ODEsobol</a>, <a href="sensitivity.html#topic+soboljansen">soboljansen</a>,
<a href="sensitivity.html#topic+sobolmartinez">sobolmartinez</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##### Lotka-Volterra equations #####
LVmod &lt;- function(Time, State, Pars) {
  with(as.list(c(State, Pars)), {
    Ingestion    &lt;- rIng  * Prey * Predator
    GrowthPrey   &lt;- rGrow * Prey * (1 - Prey/K)
    MortPredator &lt;- rMort * Predator
    
    dPrey        &lt;- GrowthPrey - Ingestion
    dPredator    &lt;- Ingestion * assEff - MortPredator
    
    return(list(c(dPrey, dPredator)))
  })
}
LVpars  &lt;- c("rIng", "rGrow", "rMort", "assEff", "K")
LVbinf &lt;- c(0.05, 0.05, 0.05, 0.05, 1)
LVbsup &lt;- c(1.00, 3.00, 0.95, 0.95, 20)
LVinit  &lt;- c(Prey = 1, Predator = 2)
LVtimes &lt;- c(0.01, seq(1, 50, by = 1))
set.seed(59281)
# Warning: The following code might take very long!

LVres_sobol &lt;- ODEsobol(mod = LVmod,
                        pars = LVpars,
                        state_init = LVinit,
                        times = LVtimes,
                        n = 500,
                        rfuncs = "runif",
                        rargs = paste0("min = ", LVbinf,
                                       ", max = ", LVbsup),
                        sobol_method = "Martinez",
                        ode_method = "lsoda",
                        parallel_eval = TRUE,
                        parallel_eval_ncores = 2)
my_cols &lt;- c("firebrick", "orange2", "dodgerblue", 
             "forestgreen", "black")
plot(LVres_sobol, colors_pars = my_cols)
plot(LVres_sobol, pars_plot = c("rGrow", "rMort"), state_plot = "Predator", 
     colors_pars = my_cols[2:3])


##### A network of 4 mechanical oscillators connected in a circle #####
M_mat &lt;- rep(2, 4)
K_mat &lt;- diag(rep(2 * (2*pi*0.17)^2, 4))
K_mat[1, 2] &lt;- K_mat[2, 3] &lt;- 
  K_mat[3, 4] &lt;- K_mat[1, 4] &lt;- 2 * (2*pi*0.17)^2 / 10
D_mat &lt;- diag(rep(0.05, 4))
library("ODEnetwork")
lfonet &lt;- ODEnetwork(masses = M_mat, dampers = D_mat, springs = K_mat)
LFOpars &lt;- c("k.1", "k.2", "k.3", "k.4",
             "d.1", "d.2", "d.3", "d.4")
LFObinf &lt;- c(rep(0.2, 4), rep(0.01, 4))
LFObsup &lt;- c(rep(20, 4), rep(0.1, 4))
lfonet &lt;- setState(lfonet, state1 = rep(2, 4), state2 = rep(0, 4))
LFOtimes &lt;- seq(25, 150, by = 2.5)
set.seed(1739)
# Warning: The following code might take very long!

suppressWarnings(
  LFOres_sobol &lt;- ODEsobol(mod = lfonet,
                           pars = LFOpars,
                           times = LFOtimes,
                           n = 500,
                           rfuncs = "runif",
                           rargs = paste0("min = ", LFObinf,
                                          ", max = ", LFObsup),
                           sobol_method = "Martinez",
                           parallel_eval = TRUE,
                           parallel_eval_ncores = 2)
)
plot(LFOres_sobol, pars_plot = paste0("k.", 1:4), state_plot = "x.2",
     colors_pars = my_cols)


</code></pre>

<hr>
<h2 id='tdcc'>A Measure of Top-Down Correlation</h2><span id='topic+tdcc'></span>

<h3>Description</h3>

<p>With the use of Savage scores, the Top-Down Correlation Coefficient TDCC 
compares <code>b</code> rankings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tdcc(ranks, pearson = FALSE, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tdcc_+3A_ranks">ranks</code></td>
<td>
<p>[<code>matrix(nrow = b, ncol = k)</code>]<br />
<code>(bxk)</code>-matrix of the ranks of the <code>k</code>
variables for each of the <code>b</code> sensitivity analyses, ties are neglected,
must be integers.</p>
</td></tr>
<tr><td><code id="tdcc_+3A_pearson">pearson</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should the ordinary Pearson coefficient with
Savage scores be computed (<code>b = 2</code>)? Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tdcc_+3A_plot">plot</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
Should scatter plots showing rankings and Savage scores be created
(<code>b = 2</code>)? Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NOTE: As the implementation of the coefficient of concordance is still defective,
please use the Pearson coefficient!
</p>


<h3>Value</h3>

<p>A named vector with components:
</p>

<ul>
<li><p><code>kendall</code>: Coefficient of concordance.
</p>
</li>
<li><p><code>pearson</code>: Pearson coefficient (only if <code>pearson = TRUE</code>).
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Stefan Theers
</p>


<h3>References</h3>

<p>R. L. Iman and W. J. Conover, 
<em>A Measure of Top-Down Correlation</em>, 
Technometrics, Vol. 29, No. 3 (Aug., 1987), pp. 351&ndash;357.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># b=2 sensitivity analysis techniques A and B that rate the influence of 
# k=20 variables/ input parameters (example taken from Iman and Conover, 1987):
ranking &lt;- rbind(A = 1:20,
                 B = c(1,3,2,4,16,10,19,12,18,17,
                       20,5,14,7,8,11,6,15,9,13))
tdcc(ranking, pearson = TRUE, plot = TRUE)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
