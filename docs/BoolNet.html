<!DOCTYPE html><html><head><title>Help for package BoolNet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BoolNet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#attractorsToLaTeX'>
<p>Create LaTeX state table of attractors</p></a></li>
<li><a href='#binarizeTimeSeries'>
<p>Binarize a set of real-valued time series</p></a></li>
<li><a href='#cellcycle'>
<p>Mammalian cell cycle network</p></a></li>
<li><a href='#chooseNetwork'>
<p>Extract a single Boolean network from a probabilistic Boolean network</p></a></li>
<li><a href='#examplePBN'>
<p>An artificial probabilistic Boolean network</p></a></li>
<li><a href='#fixGenes'>
<p>Simulate knocked-out or over-expressed genes</p></a></li>
<li><a href='#generateRandomNKNetwork'>
<p>Generate a random N-K Boolean network</p></a></li>
<li><a href='#generateState'>
<p>Generate a state vector from single gene values</p></a></li>
<li><a href='#generateTimeSeries'>
<p>Generate time series from a network</p></a></li>
<li><a href='#generationFunctions'>
<p>Generation functions for biologically relevant function classes</p></a></li>
<li><a href='#getAttractors'><p>Identify attractors in a Boolean network</p></a></li>
<li><a href='#getAttractorSequence'>
<p>Decode the state sequence of a synchronous attractor</p></a></li>
<li><a href='#getBasinOfAttraction'>
<p>Get states in basin of attraction</p></a></li>
<li><a href='#getPathToAttractor'>
<p>Get state transitions between a state and its attractor</p></a></li>
<li><a href='#getStateSummary'>
<p>Retrieve summary information on a state</p></a></li>
<li><a href='#getTransitionProbabilities'>
<p>Get a matrix of transitions and their probabilities in probabilistic Boolean networks</p></a></li>
<li><a href='#getTransitionTable'>
<p>Retrieve the transition table of a network</p></a></li>
<li><a href='#igf'>
<p>Boolean model of the IGF pathway</p></a></li>
<li><a href='#loadBioTapestry'>
<p>Import a network from BioTapestry</p></a></li>
<li><a href='#loadNetwork'>
<p>Load a Boolean network from a file</p></a></li>
<li><a href='#loadSBML'>
<p>Load an SBML document</p></a></li>
<li><a href='#markovSimulation'>
<p>Identify important states in probabilistic Boolean networks</p></a></li>
<li><a href='#perturbNetwork'>
<p>Perturb a Boolean network randomly</p></a></li>
<li><a href='#perturbTrajectories'>
<p>Perturb the state trajectories and calculate robustness measures</p></a></li>
<li><a href='#plotAttractors'>
<p>Plot state tables or transition graphs of attractors</p></a></li>
<li><a href='#plotNetworkWiring'>
<p>Plot the wiring of a Boolean network</p></a></li>
<li><a href='#plotPBNTransitions'>
<p>Visualize the transitions in a probabilistic Boolean network</p></a></li>
<li><a href='#plotSequence'>
<p>Plot a sequence of states</p></a></li>
<li><a href='#plotStateGraph'>
<p>Visualize state transitions and attractor basins</p></a></li>
<li><a href='#print.AttractorInfo'>
<p>Print attractor cycles</p></a></li>
<li><a href='#print.BooleanNetwork'>
<p>Print a Boolean network</p></a></li>
<li><a href='#print.MarkovSimulation'>
<p>Print the results of a Markov chain simulation</p></a></li>
<li><a href='#print.ProbabilisticBooleanNetwork'>
<p>Print a probabilistic Boolean network</p></a></li>
<li><a href='#print.SymbolicSimulation'>
<p>Print simulation results</p></a></li>
<li><a href='#print.TransitionTable'>
<p>Print a transition table</p></a></li>
<li><a href='#reconstructNetwork'>
<p>Reconstruct a Boolean network from time series of measurements</p></a></li>
<li><a href='#saveNetwork'>
<p>Save a network</p></a></li>
<li><a href='#sequenceToLaTeX'>
<p>Create LaTeX table of state sequences</p></a></li>
<li><a href='#simplifyNetwork'>
<p>Simplify the functions of a synchronous, asynchronous, or probabilistic Boolean network</p></a></li>
<li><a href='#simulateSymbolicModel'>
<p>Simulate a symbolic Boolean network</p></a></li>
<li><a href='#stateTransition'>
<p>Perform a transition to the next state</p></a></li>
<li><a href='#symbolicToTruthTable'>
<p>Convert a symbolic network into a truth table representation</p></a></li>
<li><a href='#testNetworkProperties'>
<p>Test properties of networks by comparing them to random networks</p></a></li>
<li><a href='#toPajek'>
<p>Export a network to the Pajek file format</p></a></li>
<li><a href='#toSBML'>
<p>Export a network to SBML</p></a></li>
<li><a href='#truthTableToSymbolic'>
<p>Convert a network in truth table representation into a symbolic representation</p></a></li>
<li><a href='#yeastTimeSeries'>
<p>Yeast cell cycle time series data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Construction, Simulation and Analysis of Boolean Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.9</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-02</td>
</tr>
<tr>
<td>Imports:</td>
<td>igraph (&ge; 0.6), XML</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to reconstruct, generate, and simulate synchronous, asynchronous, probabilistic, and temporal Boolean networks. Provides also functions to analyze and visualize attractors in Boolean networks &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtq124">doi:10.1093/bioinformatics/btq124</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/Artistic-2.0">Artistic-2.0</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-02 08:56:07 UTC; julian_schwab</td>
</tr>
<tr>
<td>Author:</td>
<td>Christoph MÃ¼ssel [aut],
  Martin Hopfensitz [aut],
  Dao Zhou [aut],
  Hans A. Kestler [aut, cre],
  Armin Biere [ctb] (contributed PicoSAT code),
  Troy D. Hanson [ctb] (contributed uthash macros)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hans A. Kestler &lt;hans.kestler@uni-ulm.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-02 14:30:04 UTC</td>
</tr>
</table>
<hr>
<h2 id='attractorsToLaTeX'>
Create LaTeX state table of attractors
</h2><span id='topic+attractorsToLaTeX'></span>

<h3>Description</h3>

<p>Exports state tables of attractors (corresponding to the plot generated by <code><a href="#topic+plotAttractors">plotAttractors</a></code> with <code>mode="table"</code>) to a LaTeX document.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>attractorsToLaTeX(attractorInfo, 
                  subset, 
                  title = "", 
                  grouping = list(), 
                  plotFixed = TRUE,
                  onColor = "[gray]{0.9}",
                  offColor = "[gray]{0.6}",
                  reverse = FALSE, 
                  file = "attractors.tex")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="attractorsToLaTeX_+3A_attractorinfo">attractorInfo</code></td>
<td>

<p>An object of class <code>AttractorInfo</code>, as returned by <code><a href="#topic+getAttractors">getAttractors</a></code>, or an object of class <code>SymbolicSimulation</code>, as returned by <code><a href="#topic+simulateSymbolicModel">simulateSymbolicModel</a></code>.
</p>
</td></tr>
<tr><td><code id="attractorsToLaTeX_+3A_subset">subset</code></td>
<td>
<p>An subset of attractors to be exported. This is a vector of attractor indices in <code>attractorInfo</code>.</p>
</td></tr>
<tr><td><code id="attractorsToLaTeX_+3A_grouping">grouping</code></td>
<td>
<p>An optional structure to form groups of genes in the plot. This is a list with the following elements: 
</p>

<dl>
<dt>class</dt><dd><p>A vector of names for the groups. These names will be printed in the region belonging to the group in the table.</p>
</dd>
<dt>index</dt><dd><p>A list with the same length as <code>class</code>. Each element is a vector of gene indices belonging to the group.</p>
</dd></dl>

</td></tr>
<tr><td><code id="attractorsToLaTeX_+3A_title">title</code></td>
<td>

<p>An optional title for the plot
</p>
</td></tr>
<tr><td><code id="attractorsToLaTeX_+3A_plotfixed">plotFixed</code></td>
<td>

<p>If this is true, genes with fixed values are included in the plot. Otherwise, these genes are not shown.
</p>
</td></tr>
<tr><td><code id="attractorsToLaTeX_+3A_oncolor">onColor</code></td>
<td>

<p>An optional color value for the 1/ON values in the table. Defaults to dark grey.
</p>
</td></tr>
<tr><td><code id="attractorsToLaTeX_+3A_offcolor">offColor</code></td>
<td>

<p>An optional color value for the 0/OFF values in the table. Defaults to light grey.	
</p>
</td></tr>
<tr><td><code id="attractorsToLaTeX_+3A_reverse">reverse</code></td>
<td>

<p>Specifies the order of the genes in the plot. By default, the first gene is placed in the first row of the table. If <code>reverse=TRUE</code>, the first gene in the network is placed in the bottom row of the table. 
</p>
</td></tr>
<tr><td><code id="attractorsToLaTeX_+3A_file">file</code></td>
<td>

<p>The file to which the LaTeX document is written. Defaults to &quot;attractors.tex&quot;.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates LaTeX tables that visualize the states of synchronous attractors. Asynchronous attractors are ignored.
Attractors in <code>attractorInfo</code> are first grouped by length. Then, a LaTeX table environment is created for each attractor length (i.e. one plot with all attractors consisting of 1 state, one plot with all attractors consisting of 2 states, etc.).
The output file does not contain a document header and requires the inclusion of the packages <code>tabularx</code> and <code>colortbl</code>. The tables have the genes in the rows and the states of the attractors in the columns. If not specified otherwise, cells of the table are light grey for 0/OFF values and dark grey for 1/ON values. If <code>grouping</code> is set, the genes are rearranged according to the indices in the group, horizontal separation lines are plotted between the groups, and the group names are printed.
</p>


<h3>Value</h3>

<p>A list of matrices corresponding to the plots is returned. Each of these matrices has the genes in the rows and the states of the attractors in the columns.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getAttractors">getAttractors</a></code>, <code><a href="#topic+plotAttractors">plotAttractors</a></code>, <code><a href="#topic+sequenceToLaTeX">sequenceToLaTeX</a></code>, <code><a href="#topic+plotSequence">plotSequence</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load example data
data(cellcycle)

# get attractors
attractors &lt;- getAttractors(cellcycle)

# output LaTeX document
attractorsToLaTeX(attractors, file="attractors.tex")

## End(Not run)
</code></pre>

<hr>
<h2 id='binarizeTimeSeries'>
Binarize a set of real-valued time series
</h2><span id='topic+binarizeTimeSeries'></span>

<h3>Description</h3>

<p>Binarizes a set of real-valued time series using k-means clustering, edge detection, or scan statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binarizeTimeSeries(measurements, 
                   method = c("kmeans","edgeDetector","scanStatistic"), 
                   nstart = 100, 
                   iter.max = 1000, 
                   edge = c("firstEdge","maxEdge"),                    
                   scaling = 1, 
                   windowSize = 0.25, 
                   sign.level = 0.1,
                   dropInsignificant = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binarizeTimeSeries_+3A_measurements">measurements</code></td>
<td>

<p>A list of matrices, each corresponding to one time series. Each row of these matrices contains real-valued measurements for one gene on a time line, i. e. column <code>i+1</code> contains the successor states of column <code>i+1</code>. The genes must be the same for all matrices in the list. 
</p>
</td></tr>
<tr><td><code id="binarizeTimeSeries_+3A_method">method</code></td>
<td>
<p>The employed binarization technique. &quot;kmeans&quot; uses k-means clustering for binarization. &quot;edgeDetector&quot; searches for a large gradient in the sorted measurements. &quot;scanStatistic&quot; searches for accumulations in the measurements. See Details for descriptions of the techniques.</p>
</td></tr>
<tr><td><code id="binarizeTimeSeries_+3A_nstart">nstart</code></td>
<td>

<p>If <code>method="kmeans"</code>, this is the number of restarts for k-means. See <code><a href="stats.html#topic+kmeans">kmeans</a></code> for details.
</p>
</td></tr>
<tr><td><code id="binarizeTimeSeries_+3A_iter.max">iter.max</code></td>
<td>

<p>If <code>method="kmeans"</code>, the maximum number of iterations for k-means. See <code><a href="stats.html#topic+kmeans">kmeans</a></code> for details.
</p>
</td></tr>
<tr><td><code id="binarizeTimeSeries_+3A_edge">edge</code></td>
<td>
<p>If <code>method="edgeDetector"</code>, this decides which of the edges is used as a threshold for binarization. If set to &quot;firstEdge&quot;,the binarization threshold is the first combination of two successive sorted values whose difference exceeds a predefined value (average gradient * <code>scaling</code>). The parameter <code>scaling</code> can be used to adjust this value. 
</p>
<p>If set to &quot;maxEdge&quot;, the binarization threshold is the position of the edge with the overall highest gradient.</p>
</td></tr>
<tr><td><code id="binarizeTimeSeries_+3A_scaling">scaling</code></td>
<td>
<p>If <code>method="edgeDetector"</code> and <code>edge="firstEdge"</code>, this holds the scaling factor used for adjustment of the average gradient.</p>
</td></tr>
<tr><td><code id="binarizeTimeSeries_+3A_windowsize">windowSize</code></td>
<td>
<p>If <code>method="scanStatistic"</code>, this specifies the size of the scanning window (see Details). The size is given as a fraction of the whole range of input values for a gene. Default is 0.25.</p>
</td></tr>
<tr><td><code id="binarizeTimeSeries_+3A_sign.level">sign.level</code></td>
<td>
<p>If <code>method="scanStatistic"</code>, the significance level used for the scan statistic (see Details).
</p>
</td></tr>
<tr><td><code id="binarizeTimeSeries_+3A_dropinsignificant">dropInsignificant</code></td>
<td>

<p>If this is set to true, genes whose binarizations are insignificant in the scan statistic (see Details) are removed from the binarized time series. Otherwise, a warning is printed if such genes exist.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method supports three binarization techniques:
</p>

<dl>
<dt>k-means clustering</dt><dd><p>For each gene, k-means clusterings are performed to determine a good separation of groups. The values belonging to the cluster with the smaller centroid are set to 0, and the values belonging to the greater centroid are set to 1.</p>
</dd> 
<dt>Edge detector</dt><dd><p>This approach first sorts the measurements for each gene. In the sorted measurements, the algorithm searches for differences of two successive values that satisfy a predefined condition: If the &quot;firstEdge&quot; method was chosen, the pair of values whose difference exceeds the scaled average gradient of all values is chosen and used as maximum and minimum value of the two groups. If the &quot;maxEdge&quot; method was chosen, the largest difference between two successive values is taken. For details, see Shmulevich et al.</p>
</dd>
<dt>Scan statistic</dt><dd><p>The scan statistic assumes that the measurements for each gene are uniformly and independently distributed independently over a certain range. The scan statistic shifts a scanning window across the data and decides for each window position whether there is an unusual accumulation of data points based on an approximated test statistic (see Glaz et al.). The window with the smallest p-value is remembered. The boundaries of this window form two thresholds, from which the value that results in more balanced groups is taken for binarization. Depending on the supplied significance level, gene binarizations are rated according to the p-value of the chosen window.</p>
</dd>
</dl>



<h3>Value</h3>

<p>Returns a list with the following elements:
</p>
<table>
<tr><td><code>binarizedMeasurements</code></td>
<td>
<p>A list of matrices with the same structure as <code>measurements</code> containing the binarized time series measurements</p>
</td></tr>
<tr><td><code>reject</code></td>
<td>
<p>If <code>method="scanStatistic"</code>, a Boolean vector indicating for each gene whether the scan statistic algorithm was able to find a significant binarization window (FALSE) or not (TRUE). Rejected genes should probably be excluded from the data.</p>
</td></tr>
<tr><td><code>thresholds</code></td>
<td>
<p>The thresholds used for binarization</p>
</td></tr>
</table>


<h3>References</h3>

<p>I. Shmulevich and W. Zhang (2002), Binary analysis and optimization-based normalization of gene expression data. Bioinformatics 18(4):555&ndash;565.
</p>
<p>J. Glaz, J. Naus, S. Wallenstein (2001), Scan Statistics. New York: Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reconstructNetwork">reconstructNetwork</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load test data
data(yeastTimeSeries)
			
# perform binarization with k-means
bin &lt;- binarizeTimeSeries(yeastTimeSeries)
print(bin)

# perform binarization with scan statistic
# - will find and remove 2 insignificant genes!
bin &lt;- binarizeTimeSeries(yeastTimeSeries, method="scanStatistic",
                          dropInsignificant=TRUE, sign.level=0.2)
print(bin)

# perform binarization with edge detector
bin &lt;- binarizeTimeSeries(yeastTimeSeries, method="edgeDetector")
print(bin)

# reconstruct a network from the data
reconstructed &lt;- reconstructNetwork(bin$binarizedMeasurements,
                                    method="bestfit", maxK=4)
print(reconstructed)
</code></pre>

<hr>
<h2 id='cellcycle'>
Mammalian cell cycle network
</h2><span id='topic+cellcycle'></span>

<h3>Description</h3>

<p>The mammalian cell cycle network as described by Faure et al.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cellcycle)</code></pre>


<h3>Details</h3>

<p>The data consists of a variable <code>cellcycle</code> of class <code>BooleanNetwork</code> with 10 genes describing the four phases of the mammalian cell cycle. The network has one steady-state attractor. Furthermore, it has one synchronous attractor with 7 states and one asynchronous complex/loose attractor with 112 states. The class <code>BooleanNetwork</code> is described in more detail in <code><a href="#topic+loadNetwork">loadNetwork</a></code>.
</p>


<h3>Source</h3>

<p>A. Faure, A. Naldi, C. Chaouiya and D. Thieffry (2006), Dynamical analysis of a generic Boolean model for the control of the mammalian cell cycle. Bioinformatics 22(14):e124&ndash;e131.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cellcycle)

# the network is stored in a variable called 'cellcycle'
print(cellcycle)

</code></pre>

<hr>
<h2 id='chooseNetwork'>
Extract a single Boolean network from a probabilistic Boolean network
</h2><span id='topic+chooseNetwork'></span>

<h3>Description</h3>

<p>Creates a <code>BooleanNetwork</code> object with exactly one function per gene by extracting a specified set of transition functions from a <code>ProbabilisticBooleanNetwork</code> or <code>BooleanNetworkCollection</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chooseNetwork(probabilisticNetwork, 
              functionIndices, 
              dontCareValues=NULL, 
              readableFunctions=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chooseNetwork_+3A_probabilisticnetwork">probabilisticNetwork</code></td>
<td>

<p>A <code>ProbabilisticBooleanNetwork</code> or <code>BooleanNetworkCollection</code> object as returned by <code><a href="#topic+reconstructNetwork">reconstructNetwork</a></code> or <code><a href="#topic+loadNetwork">loadNetwork</a></code>
</p>
</td></tr>
<tr><td><code id="chooseNetwork_+3A_functionindices">functionIndices</code></td>
<td>

<p>A vector of function indices with one entry for each gene
</p>
</td></tr>
<tr><td><code id="chooseNetwork_+3A_dontcarevalues">dontCareValues</code></td>
<td>

<p>If <code>probabilisticNetwork</code> is of class <code>BooleanNetworkCollection</code>, this specifies the values to fill in for &quot;don't care&quot; (*) values in the truth tables of the transition functions. This is a list containing one vector of Boolean values for each gene. The lengths of the vectors must coincide with the numbers of &quot;don't care&quot; values in the functions.
</p>
</td></tr>
<tr><td><code id="chooseNetwork_+3A_readablefunctions">readableFunctions</code></td>
<td>

<p>If <code>probabilisticNetwork</code> is of class <code>BooleanNetworkCollection</code>, the string representations of the transition functions must be refreshed after filling in values for the &quot;don't care&quot; entries. 
This parameter specifies if readable DNF representations of the transition function truth tables are generated and displayed when the network is printed. If set to FALSE, the truth table result column is displayed. If set to &quot;canonical&quot;, a canonical Disjunctive Normal Form is generated from each truth table. If set to &quot;short&quot;, the canonical DNF is minimized by joining terms (which can be time-consuming for functions with many inputs). If set to TRUE, a short DNF is generated for functions with up to 12 inputs, and a canonical DNF is generated for functions with more than 12 inputs.
</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>Returns an object of class <code>BooleanNetwork</code> consisting of the transition functions whose indices were specified in <code>functionIndices</code>. The class <code>BooleanNetwork</code> is described in more detail in <code><a href="#topic+loadNetwork">loadNetwork</a></code>.
</p>
<p>Constant genes are automatically fixed (e.g. knocked-out or over-expressed). This means that they are always set to the constant value, and states with the complementary value are not considered in transition tables etc. If you would like to change this behaviour, use <code><a href="#topic+fixGenes">fixGenes</a></code> to reset the fixing.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reconstructNetwork">reconstructNetwork</a></code>, <code><a href="#topic+loadNetwork">loadNetwork</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
# load example data
data(examplePBN)

# extract a unique network
# - always use the first function
net &lt;- chooseNetwork(examplePBN, rep(1, length(examplePBN$genes)))

# get attractors from this network
print(getAttractors(net))

## End(Not run)
</code></pre>

<hr>
<h2 id='examplePBN'>
An artificial probabilistic Boolean network
</h2><span id='topic+examplePBN'></span>

<h3>Description</h3>

<p>An artificial probabilistic Boolean network example introduced by Shmulevich et al.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(examplePBN)</code></pre>


<h3>Details</h3>

<p>This artificial network is introduced by Shmulevich et al. for a step-by-step description of their Markov chain algorithm. It is included as a general example for a probabilistic Boolean network. The network consists of 3 genes, where gene 1 and gene 3 have two alternative transition functions, and gene 1 has a unique transition function.
</p>


<h3>Source</h3>

<p>I. Shmulevich, E. R. Dougherty, S. Kim, W. Zhang (2002), Probabilistic Boolean networks: a rule-based uncertainty model for gene regulatory networks. Bioinformatics 18(2):261&ndash;274.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(examplePBN)

# the network is stored in a variable called 'examplePBN'
print(examplePBN)
</code></pre>

<hr>
<h2 id='fixGenes'>
Simulate knocked-out or over-expressed genes
</h2><span id='topic+fixGenes'></span>

<h3>Description</h3>

<p>Simulates knocked-out or over-expressed genes by fixing the values of genes to 0 or 1, or turn off knock-out or over-expression of genes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixGenes(network, fixIndices, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixGenes_+3A_network">network</code></td>
<td>

<p>The original network of class <code>BooleanNetwork</code>,  <code>SymbolicBooleanNetwork</code> or <code>ProbabilisticBooleanNetwork</code> containing the genes to be fixed
</p>
</td></tr>
<tr><td><code id="fixGenes_+3A_fixindices">fixIndices</code></td>
<td>

<p>A vector of names or indices of the genes to be fixed
</p>
</td></tr>
<tr><td><code id="fixGenes_+3A_values">values</code></td>
<td>

<p>Either one single value, or a vector with the same length as <code>fixIndices</code>. For each gene, a value of 1 means that the gene is always turned on (over-expressed), a value of 0 means that the gene is always turned off (knocked-out), and a value of -1 means that the gene is not fixed.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the input, an object of class <code>BooleanNetwork</code>, <code>SymbolicBooleanNetwork</code> or <code>ProbabilisticBooleanNetwork</code> containing the fixed genes is returned. These classes are described in more detail in <code><a href="#topic+loadNetwork">loadNetwork</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loadNetwork">loadNetwork</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load example data
data(cellcycle)

# knock out gene CycD (index 1)
net &lt;- fixGenes(cellcycle, 1, 0)
# or
net &lt;- fixGenes(cellcycle, "CycD", 0)

# get attractors by exhaustive search
attractors &lt;- getAttractors(net)

print(attractors)

## End(Not run)
</code></pre>

<hr>
<h2 id='generateRandomNKNetwork'>
Generate a random N-K Boolean network
</h2><span id='topic+generateRandomNKNetwork'></span>

<h3>Description</h3>

<p>Generates a random N-K Boolean network (see Kauffman, 1969) using different configurations for the topology, the linkage, and the functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateRandomNKNetwork(n, k, 
                        topology = c("fixed", "homogeneous", "scale_free"), 
                        linkage = c("uniform", "lattice"), 
                        functionGeneration = c("uniform", "biased"), 
                        validationFunction, failureIterations=10000,
                        simplify = FALSE, noIrrelevantGenes=TRUE, 
                        readableFunctions = FALSE, 
                        d_lattice = 1, zeroBias = 0.5, 
                        gamma = 2.5, approx_cutoff = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateRandomNKNetwork_+3A_n">n</code></td>
<td>

<p>The total number of genes in the network
</p>
</td></tr>
<tr><td><code id="generateRandomNKNetwork_+3A_k">k</code></td>
<td>

<p>If this is a single number, this is either the maximum number of genes in the input of a transition function (for <code>topology="fixed"</code> and <code>topology="scale_free"</code>) or the mean number of genes in the input of a function (for <code>topology="homogeneous"</code>). If <code>topology="fixed"</code>, this can also be a vector with <code>n</code> elements specifying the number of input genes for each gene separately.
</p>
</td></tr>
<tr><td><code id="generateRandomNKNetwork_+3A_topology">topology</code></td>
<td>

<p>If set to &quot;fixed&quot;, all transition functions of the network depend on exactly <code>k</code> input genes (unless there are irrelevant input genes to be removed if <code>simplify=TRUE</code> and <code>noIrrelevantGenes=FALSE</code>).
</p>
<p>If set to &quot;homogeneous&quot;, the number of input genes is drawn independently at random from a Poisson distribution with lambda = k.
</p>
<p>If set to &quot;scale_free&quot;, the number of input genes of each function is drawn from a Zeta distribution with parameter <code>gamma</code>.
</p>
</td></tr>
<tr><td><code id="generateRandomNKNetwork_+3A_linkage">linkage</code></td>
<td>

<p>If this parameter is &quot;uniform&quot;, the actual input genes are drawn uniformly at random from the total <code>k</code> genes.
</p>
<p>If set to &quot;lattice&quot;, only genes from the neighbourhood <code>(i - d_lattice * k_i):(i + d_lattice * k_i)</code> are taken, which means that all genes are dependent from other genes in the direct neighbourhood.
</p>
</td></tr>
<tr><td><code id="generateRandomNKNetwork_+3A_functiongeneration">functionGeneration</code></td>
<td>

<p>This parameter specifies how the truth tables of the transition functions are generated. 
If set to &quot;uniform&quot;, the truth table result column of the function is filled uniformly at random with 0 and 1. If set to &quot;biased&quot;, a bias is introduced, where the probability of drawing a 0 is determined by the parameter <code>zeroBias</code>.
</p>
<p>As a third option, <code>functionGeneration</code> can be set to a user-defined function that generates the truth tables. This function must have a single parameter <code>input</code> that is supplied with a vector of input gene indices. It must return a binary vector of size <code>2^length(input)</code> corresponding to the result column of the truth table. For the generation of canalyzing and nested canalyzing functions that are often assumed to be biologically plausible, the generation functions <code><a href="#topic+generateCanalyzing">generateCanalyzing</a></code> and <code><a href="#topic+generateNestedCanalyzing">generateNestedCanalyzing</a></code> are included in <span class="pkg">BoolNet</span>.
</p>
</td></tr>
<tr><td><code id="generateRandomNKNetwork_+3A_validationfunction">validationFunction</code></td>
<td>

<p>An optional function that restricts the generated Boolean functions to certain classes. This can be used if no explicit generation function can be specified in <code>functionGeneration</code>, but it is nevertheless possible to check whether a generated function belongs to that class or not. The function should have two input parameter <code>input</code> and <code>func</code> that receive a candidate function. <code>input</code> is a matrix of 0/1 integer values specifying the input part of the truth table of the candidate function, with the input genes in the columns. Each of the 2^k rows of <code>input</code>  (where k is the number of input genes) corresponds to one entry of <code>func</code>, which is an integer vector of 0/1 values corresponding to the output of the candidate function. The validation function should return <code>TRUE</code> if the candidate function is accepted or <code>FALSE</code> if it is rejected.
</p>
</td></tr>
<tr><td><code id="generateRandomNKNetwork_+3A_failureiterations">failureIterations</code></td>
<td>

<p>The maximum number of iterations the generator tries to generate a function that is accepted by <code>validationFunction</code> before it gives up and throws an error. Defaults to 10000.  
</p>
</td></tr>
<tr><td><code id="generateRandomNKNetwork_+3A_simplify">simplify</code></td>
<td>

<p>If this is true, <code><a href="#topic+simplifyNetwork">simplifyNetwork</a></code> is called to simplify the gene transition functions after the perturbation. This removes irrelevant input genes. Should not be used together with <code>noIrrelevantGenes=TRUE</code>, as this automatically generates a network that cannot be simplified any further. Defaults to FALSE.
</p>
</td></tr>
<tr><td><code id="generateRandomNKNetwork_+3A_noirrelevantgenes">noIrrelevantGenes</code></td>
<td>

<p>If set to true, gene transition functions are not allowed to contain irrelevant genes, i.e. the functions have exactly the number of input genes determined by the <code>topology</code> method. This means that the network cannot be simplified any further, and <code>simplify</code> should be turned off. The default value is TRUE.
</p>
</td></tr>
<tr><td><code id="generateRandomNKNetwork_+3A_readablefunctions">readableFunctions</code></td>
<td>

<p>This parameter specifies if readable DNF representations of the transition function truth tables are generated and displayed when the network is printed. If set to FALSE, the truth table result column is displayed. If set to &quot;canonical&quot;, a canonical Disjunctive Normal Form is generated from each truth table. If set to &quot;short&quot;, the canonical DNF is minimized by joining terms (which can be time-consuming for functions with many inputs). If set to TRUE, a short DNF is generated for functions with up to 12 inputs, and a canonical DNF is generated for functions with more than 12 inputs.
</p>
</td></tr>
<tr><td><code id="generateRandomNKNetwork_+3A_d_lattice">d_lattice</code></td>
<td>

<p>The dimension parameter for the lattice if <code>linkage="lattice"</code>. Defaults to 1.
</p>
</td></tr>
<tr><td><code id="generateRandomNKNetwork_+3A_zerobias">zeroBias</code></td>
<td>

<p>The bias parameter for biased functions for <code>functionGeneration="biased"</code>. Defaults to 0.5 (no bias).
</p>
</td></tr>
<tr><td><code id="generateRandomNKNetwork_+3A_gamma">gamma</code></td>
<td>

<p>The Gamma parameter of the Zeta distribution for <code>topology="scale_free"</code>. Default is 2.5.
</p>
</td></tr>
<tr><td><code id="generateRandomNKNetwork_+3A_approx_cutoff">approx_cutoff</code></td>
<td>

<p>This parameter is only used with <code>topology="scale_free"</code>. It sets the number of iterations in the sum used to approximate the Riemann Zeta function. Defaults to 100.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function supports a high number of different configurations to generate random networks. Several of the parameters are only needed for special configurations. The generated networks have different structural properties. Refer to the literature for more details.
</p>
<p>Constant genes are automatically fixed (e.g. knocked-out or over-expressed). This means that they are always set to the constant value, and states with the complementary value are not considered in transition tables etc. If you would like to change this behaviour, use <code><a href="#topic+fixGenes">fixGenes</a></code> to reset the fixing.
</p>


<h3>Value</h3>

<p>An object of class <code>BooleanNetwork</code> containing the generated random network. The class <code>BooleanNetwork</code> is described in more detail in <code><a href="#topic+loadNetwork">loadNetwork</a></code>.
</p>


<h3>References</h3>

<p>S. A. Kauffman (1969), Metabolic stability and epigenesis in randomly constructed nets. J. Theor. Biol. 22:437&ndash;467.
</p>
<p>S. A. Kauffman (1993), The Origins of Order. Oxford University Press.
</p>
<p>M. Aldana (2003), Boolean dynamics of networks with scale-free topology. Physica D 185: 45&ndash;66.
</p>
<p>M. Aldana and S. Coppersmith and L. P. Kadanoff (2003), Boolean dynamics with random coupling. In E. Kaplan, J. E. Marsden  and K. R. Sreenivasan (editors): Perspectives and Problems in Nonlinear Science, Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+perturbNetwork">perturbNetwork</a></code>,<code><a href="#topic+loadNetwork">loadNetwork</a></code>, <code><a href="#topic+simplifyNetwork">simplifyNetwork</a></code>, <code><a href="#topic+fixGenes">fixGenes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# generate different random networks
net1 &lt;- generateRandomNKNetwork(n=10, k=10, 
                                topology="scale_free", 
                                linkage="uniform", 
                                functionGeneration="uniform",
                                noIrrelevantGenes=FALSE, 
                                simplify=TRUE)
                                
net2 &lt;- generateRandomNKNetwork(n=10, k=3, 
                                topology="homogeneous", 
                                linkage="lattice", 
                                functionGeneration="uniform", 
                                d_lattice=1.5, 
                                simplify=TRUE)
                                
net3 &lt;- generateRandomNKNetwork(n=10, k=2, 
                                topology="fixed", 
                                linkage="uniform", 
                                functionGeneration="biased", 
                                noIrrelevantGenes=FALSE,                                
                                zeroBias=0.6)

# get attractors
print(getAttractors(net1))
print(getAttractors(net2))
print(getAttractors(net3))

## End(Not run)
</code></pre>

<hr>
<h2 id='generateState'>
Generate a state vector from single gene values
</h2><span id='topic+generateState'></span>

<h3>Description</h3>

<p>This function provides a simple interface to generate full state vectors by specifying only the genes of interest. For example, only those genes that are active can be specified, while the others are set to a default value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateState(network, 
              specs, 
              default = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateState_+3A_network">network</code></td>
<td>

<p>An network of class <code>BooleanNetwork</code>, <code>SymbolicBooleanNetwork</code> or <code>ProbabilisticBooleanNetwork</code> for which a state is generated.
</p>
</td></tr>
<tr><td><code id="generateState_+3A_specs">specs</code></td>
<td>

<p>A named vector or list specifying the genes to be set. Here, the names of the elements correspond to the gene names, and the elements correspond to the gene values. The function can also generate a matrix of states if the elements of <code>specs</code> are vectors of values (of the same length).
</p>
</td></tr>
<tr><td><code id="generateState_+3A_default">default</code></td>
<td>

<p>The default value used for the unspecified genes (usually 0).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a full state vector with one entry for each gene of the network, or a matrix with one state in each row if <code>specs</code> contains vectors of state values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getAttractors">getAttractors</a></code>, <code><a href="#topic+simulateSymbolicModel">simulateSymbolicModel</a></code>, <code><a href="#topic+stateTransition">stateTransition</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load cell cycle network
data(cellcycle)

# generate a state in which only CycD and CycA are active
state &lt;- generateState(cellcycle, c("CycD"=1, "CycA"=1))
print(state)

# use the state as a start state for attractor search
print(getAttractors(cellcycle, startStates=list(state)))

## End(Not run)
</code></pre>

<hr>
<h2 id='generateTimeSeries'>
Generate time series from a network
</h2><span id='topic+generateTimeSeries'></span>

<h3>Description</h3>

<p>Generates time series by simulating successive state transitions from random start states. In addition, the resulting matrices can be perturbed by Gaussian noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateTimeSeries(network, 
                   numSeries, 
                   numMeasurements, 
                   type = c("synchronous","asynchronous","probabilistic"),
                   geneProbabilities, 
                   perturbations = 0,
                   noiseLevel = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateTimeSeries_+3A_network">network</code></td>
<td>

<p>An object of class <code>BooleanNetwork</code> or <code>SymbolicBooleanNetwork</code> that contains the network for which time series are generated
</p>
</td></tr>
<tr><td><code id="generateTimeSeries_+3A_numseries">numSeries</code></td>
<td>

<p>The number of random start states used to generate successive series of states, that is, the number of time series matrices to generate
</p>
</td></tr>
<tr><td><code id="generateTimeSeries_+3A_nummeasurements">numMeasurements</code></td>
<td>

<p>The number of states in each of the time series matrices. The first state of each time series is the randomly generated start state. The remaining <code>numMeasurements - 1</code> states are obtained by successive state transitions.
</p>
</td></tr>
<tr><td><code id="generateTimeSeries_+3A_type">type</code></td>
<td>

<p>The type of state transitions to be performed (see <code><a href="#topic+stateTransition">stateTransition</a></code>)
</p>
</td></tr>
<tr><td><code id="generateTimeSeries_+3A_geneprobabilities">geneProbabilities</code></td>
<td>

<p>An optional vector of probabilities for the genes if <code>type="asynchronous"</code>. By default, each gene has the same probability to be chosen for the next state transition. These probabilities can be modified by supplying a vector of probabilities for the genes which sums up to one.
</p>
</td></tr>
<tr><td><code id="generateTimeSeries_+3A_perturbations">perturbations</code></td>
<td>

<p>If this argument has a value greater than 0, artificial perturbation experiments are generated. That is, <code>perturbations</code> genes in each time series are knocked out or overexpressed artificially using the <code><a href="#topic+fixGenes">fixGenes</a></code> function.   
</p>
</td></tr>
<tr><td><code id="generateTimeSeries_+3A_noiselevel">noiseLevel</code></td>
<td>

<p>If this is non-zero, it specifies the standard deviation of the Gaussian noise which is added to all entries of the time series matrices. By default, no noise is added to the time series.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of matrices, each corresponding to one time series. Each row of these matrices contains measurements for one gene on a time line, i. e. column <code>i+1</code> contains the successor states of column <code>i+1</code>. If <code>noiseLevel</code> is non-zero, the matrices contain real values, otherwise they contain only 0 and 1. 
</p>
<p>If <code>perturbations&gt;0</code>, the result list contains an additional matrix <code>perturbations</code> specifying the artificial perturbations applied to the different time series. This matrix has <code>numSeries</code> columns and one row for each gene in the network. A matrix entry is 0 for a knock-out of the corresponding gene in the corresponding time series, 1 for overexpression, and NA for no perturbation.
</p>
<p>The result format is compatible with the input parameters of <code><a href="#topic+binarizeTimeSeries">binarizeTimeSeries</a></code>  and <code><a href="#topic+reconstructNetwork">reconstructNetwork</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stateTransition">stateTransition</a></code>, <code><a href="#topic+binarizeTimeSeries">binarizeTimeSeries</a></code>, <code><a href="#topic+reconstructNetwork">reconstructNetwork</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# generate noisy time series from the cell cycle network
data(cellcycle)
ts &lt;- generateTimeSeries(cellcycle, numSeries=50, numMeasurements=10, noiseLevel=0.1)

# binarize the noisy time series
bin &lt;- binarizeTimeSeries(ts, method="kmeans")$binarizedMeasurements

# reconstruct the network
print(reconstructNetwork(bin, method="bestfit"))

## End(Not run)
</code></pre>

<hr>
<h2 id='generationFunctions'>
Generation functions for biologically relevant function classes
</h2><span id='topic+generateCanalyzing'></span><span id='topic+generateNestedCanalyzing'></span>

<h3>Description</h3>

<p>These generation functions randomly generate canalyzing or nested canalyzing Boolean functions. These functions are usually not called directly, but are supplied to the <code>functionGeneration</code> parameter of <code><a href="#topic+generateRandomNKNetwork">generateRandomNKNetwork</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateCanalyzing(input)
generateNestedCanalyzing(input)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generationFunctions_+3A_input">input</code></td>
<td>

<p>A vector of input gene indices for the Boolean function
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A binary vector corresponding to the result column of the truth table that represents the canalyzing/nested canalyzing function.
</p>


<h3>References</h3>

<p>S. Kauffman and C. Peterson and B. Samuelsson and C. Troein (2004), Genetic networks with canalyzing Boolean rules are always stable. PNAS 101(49):7102&ndash;17107.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generateRandomNKNetwork">generateRandomNKNetwork</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  # generate a random network with canalyzing functions
  net1 &lt;- generateRandomNKNetwork(n=10, k=5, 
                                  functionGeneration="generateCanalyzing")
  print(net1)
                                  
  # generate a random network with nested canalyzing functions
  net2 &lt;- generateRandomNKNetwork(n=10, k=5, 
                                  functionGeneration="generateNestedCanalyzing")
  print(net2)                                  

## End(Not run)  
</code></pre>

<hr>
<h2 id='getAttractors'>Identify attractors in a Boolean network</h2><span id='topic+getAttractors'></span>

<h3>Description</h3>

<p>Identifies attractors (cycles) in a supplied Boolean network using synchronous or asynchronous state transitions</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAttractors(network, 
              type = c("synchronous","asynchronous"), 
              method = c("exhaustive",
                         "sat.exhaustive",
                         "sat.restricted",
                         "random",
                         "chosen"), 
              startStates = list(),
              genesON = c(), genesOFF = c(), 
              canonical = TRUE,
              randomChainLength = 10000, 
              avoidSelfLoops = TRUE, 
              geneProbabilities = NULL, 
              maxAttractorLength = Inf,
              returnTable = TRUE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAttractors_+3A_network">network</code></td>
<td>

<p>A network structure of class <code>BooleanNetwork</code> or <code>SymbolicBooleanNetwork</code>. These networks can be read from files by <code><a href="#topic+loadNetwork">loadNetwork</a></code>, generated by <code><a href="#topic+generateRandomNKNetwork">generateRandomNKNetwork</a></code>, or reconstructed by <code><a href="#topic+reconstructNetwork">reconstructNetwork</a></code>.
</p>
</td></tr>
<tr><td><code id="getAttractors_+3A_type">type</code></td>
<td>

<p>If <code>type="synchronous"</code>, synchronous state transitions are used, i.e. all genes are updated at the same time. Synchronous attractor search can be performed in an exhaustive manner or using a heuristic that starts from predefined states. For symbolic networks, only synchronous updates are possible.
</p>
<p>If <code>type="asynchronous"</code>, asynchronous state transitions are performed, i.e. one (randomly chosen) gene is updated in each transition. Steady-state attractors are the same in asynchronous and synchronous networks, but the asynchronous search is also able to identify complex/loose attractors. Asynchronous search relies on a heuristic algorithm that starts from predefined states.
</p>
<p>See Details for more information on the algorithms.
</p>
</td></tr>
<tr><td><code id="getAttractors_+3A_method">method</code></td>
<td>

<p>The search method to be used. If &quot;exhaustive&quot;, attractors are identified by exhaustive state space search, i.e. by calculating the sucessors of all 2^n states (where n is the number of genes that are not set to a fixed value). This kind of search is only available for synchronous attractor search, and the maximum number of genes allowed for exhaustive search is 29. Apart from the attractors, this method generates the full state transition graph.
</p>
<p>If <code>method</code> is &quot;sat.exhaustive&quot; or &quot;sat.restricted&quot;, attractors are identified using algorithms based on the satisfiability problem. This search type is also restricted to synchronous networks. It can be used to identify attractors in much larger networks than with <code>method="exhaustive"</code>, but does not return the state transition graph. For <code>method="sat.exhaustive"</code>, an exhaustive attractor search is performed, while <code>method="sat.restricted"</code> only searches for attractors of a specified maximum length <code>maxAttractorLength</code>.
</p>
<p>If <code>method</code> is &quot;random&quot;, <code>startStates</code> is interpreted as an integer value specifying the number of states to be generated randomly. The algorithm is then initialized with these random states and identifies the attractors to which these states lead.
</p>
<p>If <code>method</code> is &quot;chosen&quot;, <code>startStates</code> is interpreted as a list of binary vectors, each specifying one input state. Each vector must have <code>length(network$genes)</code> elements with 0 or 1 values. The algorithm identifies the attractors to which the supplied states lead. If <code>network</code> is of class <code>SymbolicBooleanNetwork</code> and makes use of more than one predecessor state, this can also be a list of matrices with the genes in the columns and multiple predecessor states in the rows.
</p>
<p>If <code>method</code> is not supplied, the desired method is inferred from the type of <code>startStates</code>. By default, if neither <code>method</code> nor <code>startStates</code> are provided, an exhaustive search is performed.
</p>
</td></tr>
<tr><td><code id="getAttractors_+3A_startstates">startStates</code></td>
<td>

<p>The value of <code>startStates</code> depends on the chosen method. See <code>method</code> for more details.
</p>
</td></tr>  
<tr><td><code id="getAttractors_+3A_geneson">genesON</code></td>
<td>

<p>A vector of genes whose values are fixed to 1, which reduces the complexity of the search. This is equivalent to a preceding call of <code><a href="#topic+fixGenes">fixGenes</a></code>.
</p>
</td></tr>
<tr><td><code id="getAttractors_+3A_genesoff">genesOFF</code></td>
<td>

<p>A vector of genes whose values are fixed to 0, which reduces the complexity of the search. This is equivalent to a preceding call of <code><a href="#topic+fixGenes">fixGenes</a></code>.
</p>
</td></tr>
<tr><td><code id="getAttractors_+3A_canonical">canonical</code></td>
<td>

<p>If set to true, the states in the attractors are rearranged such that the state whose binary encoding
makes up the smallest number is the first element of the vector. This ensures that attractors found by different heuristic runs of <code>getAttractors</code> are comparable, as the cycles may have been entered at different states in different runs of the algorithm.
</p>
</td></tr>
<tr><td><code id="getAttractors_+3A_randomchainlength">randomChainLength</code></td>
<td>

<p>If <code>type="asynchronous"</code>, this parameter specifies the number of random transitions performed by the search to enter a potential attractor (see Details). Defaults to 10000.
</p>
</td></tr>
<tr><td><code id="getAttractors_+3A_avoidselfloops">avoidSelfLoops</code></td>
<td>

<p>If <code>type="asynchronous"</code> and <code>avoidSelfLoops=TRUE</code>, the asynchronous attractor search only enters self loops (i.e. transitions that result in the same state) if none of the possible transitions can leave the state. This results in attractors with fewer edges. Otherwise, self loops are included in the attractors. By default, self loops are avoided.
</p>
</td></tr>
<tr><td><code id="getAttractors_+3A_geneprobabilities">geneProbabilities</code></td>
<td>

<p>If <code>type="asynchronous"</code>, this allows to specify probabilities for the genes. By default, each gene has the same probability to be chosen for the next state transition. You can supply a vector of probabilities for each of the genes which sums up to one.
</p>
</td></tr>
<tr><td><code id="getAttractors_+3A_maxattractorlength">maxAttractorLength</code></td>
<td>
<p>If <code>method="sat.restricted"</code>, this required parameter specifies the maximum size of attractors (i.e. the number of states in the loop) to be searched. For <code>method="sat.exhaustive"</code>, this parameter is optional and specifies the maximum attractor length for the initial length-restricted search phase that is performed to speed up the subsequent exhaustive search. In this case, changing this value might bring performance benefits, but does not change the results.</p>
</td></tr>
<tr><td><code id="getAttractors_+3A_returntable">returnTable</code></td>
<td>

<p>Specifies whether a transition table is included in the returned <code>AttractorInfo</code> structure. If <code>type="asynchronous"</code> or <code>method="sat"</code>, this parameter is ignored, as the corresponding algorithms never return a transition table.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on the type of network and the chosen parameters, different search algorithms are started.
</p>
<p>For <code>BooleanNetwork</code> networks, there are three different modes of attractor search:
</p>

<dl>
<dt>Exhaustive synchronous state space search</dt><dd>
<p>In this mode, synchronous state transitions are carried out from each of the possible states until an attractor is reached. This identifies all synchronous attractors.
</p>
</dd>
<dt>Heuristic synchronous state space search</dt><dd>
<p>In contrast to exhaustive synchronous search, only a subset of the possible states is used. From these states, synchronous transitions are carried out until an attractor is reached. This subset is specified in <code>startStates</code>.
</p>
</dd>
<dt>Exhaustive synchronous SAT-based search</dt><dd>
<p>Here, the attractor search problem is formulated as a satisfiability problem and solved using Armin Biere's PicoSAT solver. The algorithm is a variant of the method by Dubrova and Teslenko which searches for a satisfying assignment of a chain constructed by unfolding the transition relation. Depending on <code>maxAttractorLength</code>, it additionally applies an initial size-restricted SAT-based search (see below) to increase overall search speed. This method is suitable for larger networks of up to several hundreds of genes and exhaustively identifies all attractors in these networks. In contrast to the state space search, it does not construct and return a state transition table.
</p>
</dd>
<dt>Size-restricted synchronous SAT-based search</dt><dd>
<p>Here, the SAT solver directly looks for satisfying assignments for loops of a specific size. This may be more efficient for large networks and is guaranteed to find all attractors that comprise up to <code>maxAttractorLength</code> states (e.g. all steady states for <code>maxAttractorLength=1</code>) , but does not find any larger attractors. As for the exhaustive SAT-based method, no transition table is returned.
</p>
</dd>
<dt>Heuristic asynchronous search</dt><dd>
<p>This algorithm uses asynchronous state transitions and is able to identify steady-state and complex/loose attractors (see Harvey and Bossomaier, Garg et al.). These attractors are sets of states from which all possible asynchronous transitions lead into a state that is member of the set as well.
The heuristic algorithm does the following for each of the input state specified by <code>startStates</code>:
</p>

<ol>
<li><p> Perform <code>randomChainLength</code> random asynchronous transitions. After these transitions, the network state is expected to be located in an attractor with a high probability.
</p>
</li>
<li><p> Calculate the forward reachable set of the current state. Then, compare this set to the forward reachable set of all states in the set. If all sets are equal, a complex attractor is found.
</p>
</li></ol>

</dd>
</dl>
<p>For <code>SymbolicBooleanNetwork</code> networks, <code>getAttractors</code> is simply a wrapper for <code><a href="#topic+simulateSymbolicModel">simulateSymbolicModel</a></code> with preset parameters. 

</p>
<p>Printing the return value of <code>getAttractors</code> using <code><a href="base.html#topic+print">print</a></code> visualizes the identified attractors.</p>


<h3>Value</h3>

<p>For <code>BooleanNetwork</code> networks, this returns a list of class <code>AttractorInfo</code> with components
</p>
<table>
<tr><td><code>attractors</code></td>
<td>
<p>A list of attractors. Each element is a 2-element list with the following components:
</p>

<dl>
<dt>involvedStates</dt><dd><p>A matrix containing the states that make up the attractor. Each column represents one state. The entries are decimal numbers that internally represent the states of the genes. The number of rows depends on the number of genes in the network: The first 32 genes are encoded in the first row, genes 33-64 are encoded in the second row, etc.</p>
</dd>
<dt>initialStates</dt><dd><p>This element is only available if an asynchronous search was carried out and this is a complex attractor. In this case, it holds the encoded start states of the transitions in the complex attractor</p>
</dd>
<dt>nextStates</dt><dd><p>This element is only available if an asynchronous search was carried out and this is a complex attractor. In this case, it holds the encoded successor states of the transitions in the complex attractor</p>
</dd>
<dt>basinSize</dt><dd><p>The number of states in the basin of attraction. Details on the states in the basin can be retrieved via <code><a href="#topic+getBasinOfAttraction">getBasinOfAttraction</a></code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code>stateInfo</code></td>
<td>
<p>A summary structure of class <code>BooleanStateInfo</code> containing information on the transition table. It has the following components:
</p>

<dl>
<dt>initialStates</dt><dd><p>This element is only available if <code>type="synchronous"</code>, <code>method</code> is &quot;random&quot; or &quot;chosen&quot;, and <code>returnTable=TRUE</code>. This is a matrix describing the initial states that lead to the states in <code>table</code> after a state transition.	If <code>method</code> is &quot;exhaustive&quot;, this component is <code>NULL</code>. In this case, the initial states can be inferred, as all states are used. The format of the matrix is described in <code>involvedStates</code>.</p>
</dd>
<dt>table</dt><dd><p>This element is only available if <code>type="synchronous"</code> and <code>returnTable=TRUE</code>. It holds result vector of the transition table as a matrix with one column for each state. These are encoded bit vectors in decimal numbers as described above.</p>
</dd>
<dt>attractorAssignment</dt><dd><p>This element is only available if <code>type="synchronous"</code> and <code>returnTable=TRUE</code>. It contains a vector that corresponds to the entries in <code>table</code> and describes the attractor index in <code>attractors</code> to which successive transitions from the described state finally lead.</p>
</dd>
<dt>stepsToAttractor</dt><dd><p>This element is only available if <code>type="synchronous"</code> and <code>returnTable=TRUE</code>. Referring to <code>attractorAssignment</code>, this is the number of transitions needed to reach the attractor.</p>
</dd>
<dt>genes</dt><dd><p>A list of names of the genes in <code>network</code>.</p>
</dd>
<dt>fixedGenes</dt><dd><p>Specifies the fixed genes as in the <code>fixed</code> component of <code>network</code>.</p>
</dd>
</dl>

<p>The structure supports pretty printing using the <code><a href="base.html#topic+print">print</a></code> method.</p>
</td></tr>
</table>
<p>For <code>SymbolicBooleanNetwork</code> networks, <code>getAttractors</code> redirects the call to <code><a href="#topic+simulateSymbolicModel">simulateSymbolicModel</a></code> and returns an object of class <code>SymbolicSimulation</code> containing the attractors and (if <code>returnTable=TRUE</code>) the transition graph.  
</p>


<h3>References</h3>

<p>S. A. Kauffman (1969), Metabolic stability and epigenesis in randomly constructed nets. J. Theor. Biol. 22:437&ndash;467.
</p>
<p>S. A. Kauffman (1993), The Origins of Order. Oxford University Press.
</p>
<p>I. Harvey, T. Bossomaier (1997), Time out of joint: Attractors in asynchronous random Boolean networks. Proc. of the Fourth European Conference on
Artificial Life, 67&ndash;75.
</p>
<p>A. Garg, A. Di Cara, I. Xenarios, L. Mendoza, G. De Micheli (2008), Synchronous versus asynchronous modeling of gene regulatory networks. Bioinformatics 24(17):1917&ndash;1925. 
</p>
<p>E. Dubrova, M. Teslenko (2011), A SAT-based algorithm for finding attractors in synchronous Boolean networks. IEEE/ACM Transactions on Computational Biology and Bioinformatics 8(5):1393&ndash;1399.
</p>
<p>A. Biere (2008), PicoSAT Essentials. Journal on Satisfiability, Boolean Modeling and Computation 4:75-97.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loadNetwork">loadNetwork</a></code>, <code><a href="#topic+generateRandomNKNetwork">generateRandomNKNetwork</a></code>, <code><a href="#topic+simulateSymbolicModel">simulateSymbolicModel</a></code>, <code><a href="#topic+plotAttractors">plotAttractors</a></code>, <code><a href="#topic+attractorsToLaTeX">attractorsToLaTeX</a></code>, <code><a href="#topic+getTransitionTable">getTransitionTable</a></code>, <code><a href="#topic+getBasinOfAttraction">getBasinOfAttraction</a></code>, <code><a href="#topic+getAttractorSequence">getAttractorSequence</a></code>, <code><a href="#topic+getStateSummary">getStateSummary</a></code>, <code><a href="#topic+getPathToAttractor">getPathToAttractor</a></code>, <code><a href="#topic+fixGenes">fixGenes</a></code>, <code><a href="#topic+generateState">generateState</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load example data
data(cellcycle)

# get all synchronous attractors by exhaustive search
attractors &lt;- getAttractors(cellcycle)

# plot attractors side by side
par(mfrow=c(2, length(attractors$attractors)))
plotAttractors(attractors)

# finds the synchronous attractor with 7 states
attractors &lt;- getAttractors(cellcycle, method="chosen",
                            startStates=list(rep(1, length(cellcycle$genes))))
plotAttractors(attractors)

# finds the attractor with 1 state
attractors &lt;- getAttractors(cellcycle, method="chosen",
                            startStates=list(rep(0, length(cellcycle$genes))))
plotAttractors(attractors)

# also finds the attractor with 1 state by restricting the attractor length
attractors &lt;- getAttractors(cellcycle, method="sat.restricted",
                            maxAttractorLength=1)
plotAttractors(attractors)

# identifies asynchronous attractors
attractors &lt;- getAttractors(cellcycle, type="asynchronous", startStates=100)
plotAttractors(attractors, mode="graph")

## End(Not run)
</code></pre>

<hr>
<h2 id='getAttractorSequence'>
Decode the state sequence of a synchronous attractor
</h2><span id='topic+getAttractorSequence'></span>

<h3>Description</h3>

<p>Obtains the sequence of states belonging to a single synchronous attractor from the encoded data in an <code>AttractorInfo</code> structure or in a <code>SymbolicSimulation</code> structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAttractorSequence(attractorInfo, attractorNo)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAttractorSequence_+3A_attractorinfo">attractorInfo</code></td>
<td>

<p>An object of class <code>AttractorInfo</code>, as returned by <code><a href="#topic+getAttractors">getAttractors</a></code>, or of class <code>SymbolicSimulation</code>, as returned by <code><a href="#topic+simulateSymbolicModel">simulateSymbolicModel</a></code>. As the transition table information in this structure is required, <code>getAttractors</code> must be called in synchronous mode and with <code>returnTable</code> set to TRUE. Similarly, <code>simulateSymbolicModel</code> must be called with <code>returnGraph=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="getAttractorSequence_+3A_attractorno">attractorNo</code></td>
<td>

<p>The index of the attractor in <code>attractorInfo</code> whose state sequence should be obtained
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame with the genes in the columns. The rows are the successive states of the attractor. The successor state of the last state (i.e. the last row) is the first state (i.e. the first row). 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getAttractors">getAttractors</a></code>, <code><a href="#topic+simulateSymbolicModel">simulateSymbolicModel</a></code>, <code><a href="#topic+getPathToAttractor">getPathToAttractor</a></code>, <code><a href="#topic+plotSequence">plotSequence</a></code>, <code><a href="#topic+sequenceToLaTeX">sequenceToLaTeX</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load example data
data(cellcycle)

# get attractors
attractors &lt;- getAttractors(cellcycle)

# print basin of 7-state attractor
print(getAttractorSequence(attractors, 2))

## End(Not run)
</code></pre>

<hr>
<h2 id='getBasinOfAttraction'>
Get states in basin of attraction
</h2><span id='topic+getBasinOfAttraction'></span>

<h3>Description</h3>

<p>Extracts information on all states in the basin of a supplied attractor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBasinOfAttraction(attractorInfo, attractorNo)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getBasinOfAttraction_+3A_attractorinfo">attractorInfo</code></td>
<td>

<p>An object of class <code>AttractorInfo</code>, as returned by <code><a href="#topic+getAttractors">getAttractors</a></code>, or of class <code>SymbolicSimulation</code>, as returned by <code><a href="#topic+simulateSymbolicModel">simulateSymbolicModel</a></code>. As the transition table information in this structure is required, <code>getAttractors</code> must be called in synchronous mode and with <code>returnTable</code> set to TRUE. Similarly, <code>simulateSymbolicModel</code> must be called with <code>returnGraph=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="getBasinOfAttraction_+3A_attractorno">attractorNo</code></td>
<td>

<p>The index of the attractor in <code>attractorInfo</code> whose basin should be identified
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function outputs a transition table containing only the states that are contained in the basin of attraction, and displays additional information on these states. If <code>attractorInfo</code> is the result of an exhaustive synchronous attractor search, the complete basin of attraction is returned. If <code>attractorInfo</code> is the result of a heuristic synchronous search, there is no guarantee that the complete basin of attraction is returned, as only the calculated states are included. Asynchronous search results are not supported, as no transition table is calculated.
</p>


<h3>Value</h3>

<p>Returns a generic dataframe of the class <code>TransitionTable</code>. For n genes, the first n columns code for the original state, i.e. each column represents the value of one gene. The next n columns code for the successive state after a transition. The column <code>attractorAssignment</code> indicates the attractor to the state is assigned (in this case, <code>attractorNo</code>). If this information is available, the column <code>stepsToAttractor</code> indicates how many transitions are needed from the original state to the attractor.
The <code>TransitionTable</code> class supports pretty printing using the <code><a href="base.html#topic+print">print</a></code> method.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getStateSummary">getStateSummary</a></code>, <code><a href="#topic+getTransitionTable">getTransitionTable</a></code>, <code><a href="#topic+getAttractors">getAttractors</a></code>, <code><a href="#topic+simulateSymbolicModel">simulateSymbolicModel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load example data
data(cellcycle)

# get attractors
attractors &lt;- getAttractors(cellcycle)

# print basin of first attractor
print(getBasinOfAttraction(attractors, 1))

## End(Not run)
</code></pre>

<hr>
<h2 id='getPathToAttractor'>
Get state transitions between a state and its attractor
</h2><span id='topic+getPathToAttractor'></span>

<h3>Description</h3>

<p>Lists the states in the path from a specified state to the corresponding synchronous attractor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPathToAttractor(network, 
                   state,
                   includeAttractorStates = c("all","first","none"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPathToAttractor_+3A_network">network</code></td>
<td>
<p>Either a network structure of class <code>BooleanNetwork</code> or <code>SymbolicBooleanNetwork</code> , or an attractor search result of class <code>AttractorInfo</code>. In the former case, a synchronous attractor search starting from <code>state</code> is conducted. In the latter case, <code>network</code> must be the result of a call to <code><a href="#topic+getAttractors">getAttractors</a></code> with <code>returnTable=TRUE</code>, and its transition table must include <code>state</code>.    
</p>
</td></tr>
<tr><td><code id="getPathToAttractor_+3A_state">state</code></td>
<td>

<p>A binary vector with exactly one entry per gene in the network. If <code>network</code> is of class <code>SymbolicBooleanNetwork</code> and makes use of more than one predecessor state, this can also be a matrix with the genes in the columns and multiple predecessor states in the rows.
</p>
</td></tr>
<tr><td><code id="getPathToAttractor_+3A_includeattractorstates">includeAttractorStates</code></td>
<td>

<p>Specifies whether the actual attractor states are included in the resulting table or not. If <code>includeAttractorStates = "all"</code> (which is the default behaviour), the sequence ends when the attractor was traversed once. If <code>includeAttractorStates = "first"</code>, only the first state of attractor is added to the sequence. This corresponds to the behaviour prior to <span class="pkg">BoolNet</span> version 1.5. If includeAttractorStates = &quot;none&quot;, the sequence ends with the last non-attractor state. In this case, the sequence can be empty if the start state is an attractor state.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame with the genes in the columns. The rows are the successive states from <code>state</code> to the  the corresponding attractor. Depending on <code>includeAttractorStates</code>, attractor states are included or not. The data frame has an attribute <code>attractor</code> specifying the indices of the states that belong to the attractor. If <code>includeAttractorStates</code> is <code>"first"</code> or <code>"none"</code>, these indices may correspond to states that are not included in the sequence itself. This attribute is used by <code><a href="#topic+plotSequence">plotSequence</a></code> to highlight the attractor states.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getAttractors">getAttractors</a></code>, <code><a href="#topic+simulateSymbolicModel">simulateSymbolicModel</a></code>, <code><a href="#topic+getTransitionTable">getTransitionTable</a></code>, <code><a href="#topic+getBasinOfAttraction">getBasinOfAttraction</a></code>, <code><a href="#topic+plotSequence">plotSequence</a></code>, <code><a href="base.html#topic+attributes">attributes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load example network
data(cellcycle)

# get path from a state to its attractor
# include all attractor states
path &lt;- getPathToAttractor(cellcycle, rep(1,10), 
                           includeAttractorStates="all")
print(path)

# include only the first attractor state
path &lt;- getPathToAttractor(cellcycle, rep(1,10), 
                           includeAttractorStates="first")
print(path)

# exclude attractor states
path &lt;- getPathToAttractor(cellcycle, rep(1,10), 
                           includeAttractorStates="none")
print(path)

## End(Not run)
</code></pre>

<hr>
<h2 id='getStateSummary'>
Retrieve summary information on a state
</h2><span id='topic+getStateSummary'></span>

<h3>Description</h3>

<p>Returns information on the supplied state, i.e. the successive state after a transition, the (synchronous) attractor to which the state leads, and the distance to this attractor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getStateSummary(attractorInfo, state)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getStateSummary_+3A_attractorinfo">attractorInfo</code></td>
<td>

<p>An object of class <code>AttractorInfo</code>, as returned by <code><a href="#topic+getAttractors">getAttractors</a></code>, or of class <code>SymbolicSimulation</code>, as returned by <code><a href="#topic+simulateSymbolicModel">simulateSymbolicModel</a></code>. As the transition table information in this structure is required, <code>getAttractors</code> must be called in synchronous mode and with <code>returnTable</code> set to TRUE. Similarly, <code>simulateSymbolicModel</code> must be called with <code>returnGraph=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="getStateSummary_+3A_state">state</code></td>
<td>

<p>A 0-1 vector with n elements (where n is the number of genes in the underlying networks) describing the state.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a generic dataframe of the class <code>TransitionTable</code>. For n genes, the first n columns code for the original state (in this case, the <code>state</code> parameter), i.e. each column represents the value of one gene. The next n columns code for the successive state after a transition. The column <code>attractorAssignment</code> indicates the attractor to the state is assigned. If this information is available,  the column <code>stepsToAttractor</code> indicates how many transitions are needed from the original state to the attractor. In this case, the table has only one row describing the supplied state.
The <code>TransitionTable</code> class supports pretty printing using the <code><a href="base.html#topic+print">print</a></code> method.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getBasinOfAttraction">getBasinOfAttraction</a></code>, <code><a href="#topic+getTransitionTable">getTransitionTable</a></code>, <code><a href="#topic+getAttractors">getAttractors</a></code>, <code><a href="#topic+simulateSymbolicModel">simulateSymbolicModel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load example data
data(cellcycle)

# get attractors
attractors &lt;- getAttractors(cellcycle)

# print information for an arbitrary state
print(getStateSummary(attractors, c(1,1,1,1,1,1,1,1,1,1)))

## End(Not run)
</code></pre>

<hr>
<h2 id='getTransitionProbabilities'>
Get a matrix of transitions and their probabilities in probabilistic Boolean networks
</h2><span id='topic+getTransitionProbabilities'></span>

<h3>Description</h3>

<p>Retrieves the state transitions and their probabilities in a probabilistic Boolean network. This takes the transition table information calculated by the <code><a href="#topic+markovSimulation">markovSimulation</a></code> method. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTransitionProbabilities(markovSimulation)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTransitionProbabilities_+3A_markovsimulation">markovSimulation</code></td>
<td>

<p>An object of class <code>MarkovSimulation</code>, as returned by <code><a href="#topic+markovSimulation">markovSimulation</a></code>. As the transition table information in this structure is required, <code><a href="#topic+markovSimulation">markovSimulation</a></code> must be called with <code>returnTable</code> set to TRUE.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame with the first <code>n</code> columns describing the values of the genes before the transition, the next <code>n</code> columns describing the values of the genes after the transition, and the last column containing the probability of the transition. Here, <code>n</code> is the number of genes in the underlying network. Only transitions with non-zero probability are included.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+markovSimulation">markovSimulation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load example network
data(examplePBN)

# perform a Markov chain simulation
sim &lt;- markovSimulation(examplePBN)

# print out the probability table
print(getTransitionProbabilities(sim))

## End(Not run)
</code></pre>

<hr>
<h2 id='getTransitionTable'>
Retrieve the transition table of a network
</h2><span id='topic+getTransitionTable'></span>

<h3>Description</h3>

<p>Retrieves the transition table and additional attractor information of a network. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTransitionTable(attractorInfo)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTransitionTable_+3A_attractorinfo">attractorInfo</code></td>
<td>

<p>An object of class <code>AttractorInfo</code>, as returned by <code><a href="#topic+getAttractors">getAttractors</a></code>, or of class <code>SymbolicSimulation</code>, as returned by <code><a href="#topic+simulateSymbolicModel">simulateSymbolicModel</a></code>. As the transition table information in this structure is required, <code>getAttractors</code> must be called in synchronous mode and with <code>returnTable</code> set to TRUE. Similarly, <code>simulateSymbolicModel</code> must be called with <code>returnGraph=TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on the configuration of the call to <code>getAttractors</code> or <code>simulateSymbolicModel</code> that returned <code>attractorInfo</code>, this function either returns the complete transition table (for exhaustive synchronous search) or the part of the transition table calculated in a heuristic synchronous search. Asynchronous search is not supported, as no transition table is calculated.
</p>


<h3>Value</h3>

<p>Returns a generic dataframe of the class <code>TransitionTable</code>. For n genes, the first n columns code for the original state (in this case, the <code>state</code> parameter), i.e. each column represents the value of one gene. The next n columns code for the successive state after a transition. The column <code>attractorAssignment</code> indicates the attractor to the state is assigned. If this information is available,  the column <code>stepsToAttractor</code> indicates how many transitions are needed from the original state to the attractor. The table has a row for each possible input state.
The <code>TransitionTable</code> class supports pretty printing using the <code><a href="base.html#topic+print">print</a></code> method.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getStateSummary">getStateSummary</a></code>, <code><a href="#topic+getBasinOfAttraction">getBasinOfAttraction</a></code>, <code><a href="#topic+getAttractors">getAttractors</a></code>, <code><a href="#topic+simulateSymbolicModel">simulateSymbolicModel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load example data
data(cellcycle)

# get attractors
attractors &lt;- getAttractors(cellcycle)

# print the transition table
print(getTransitionTable(attractors))

## End(Not run)
</code></pre>

<hr>
<h2 id='igf'>
Boolean model of the IGF pathway
</h2><span id='topic+igf'></span>

<h3>Description</h3>

<p>A small Boolean model of major components of the IGF (Insuline-like growth receptor) pathway. Through IRS, IGF activates the well-known PI3K-Akt-mTOR signalling cascade. This cascade is finally inactivated by a feedback inhibion of IRS.
</p>
<p>The model simplifies several complex formations and cascades by representing them as single nodes and specifying time delays instead. It therefore demonstrates the usage of temporal Boolean networks in <span class="pkg">BoolNet</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(igf)</code></pre>


<h3>Format</h3>

<p>This data set consists of a variable <code>igf</code> of class <code>SymbolicBooleanNetwork</code> with 5 genes. The class <code>SymbolicBooleanNetwork</code> is described in more detail in <code><a href="#topic+loadNetwork">loadNetwork</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(igf)

sim &lt;- simulateSymbolicModel(igf)
plotAttractors(sim)
</code></pre>

<hr>
<h2 id='loadBioTapestry'>
Import a network from BioTapestry
</h2><span id='topic+loadBioTapestry'></span>

<h3>Description</h3>

<p>Imports a Boolean network from a BioTapestry file (*.btp). BioTapestry is an interactive tool for building, visualizing, and simulating gene-regulatory networks, and can be accessed at <a href="https://biotapestry.systemsbiology.net">https://biotapestry.systemsbiology.net</a>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadBioTapestry(file,
                symbolic = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadBioTapestry_+3A_file">file</code></td>
<td>

<p>The name of the file to import. This must be a BioTapestry XML file (*.btp).
</p>
</td></tr>
<tr><td><code id="loadBioTapestry_+3A_symbolic">symbolic</code></td>
<td>

<p>If set to <code>TRUE</code>, the function returns an object of class <code>SymbolicBooleanNetwork</code> with an expression tree representation. Otherwise, it returns an object of class <code>BooleanNetwork</code> with a truth table representation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function builds up a Boolean network by importing the nodes, the links between these nodes, and the simulation parameters of the top-level plot of a BioTapestry file. The BioTapestry network should have the following properties:
</p>

<ul>
<li><p> All links should be either enhancers or repressors. Unspecified (&quot;neutral&quot;) links are ignored.
</p>
</li>
<li><p> In the simulation parameters, each node should specify the correct logical function (AND, OR, XOR) for its inputs.
</p>
</li>
<li><p> Constant genes can be generated by modeling a gene without any input link and setting the simulation parameter <code>initVal</code> to 0 or 1.
</p>
</li></ul>



<h3>Value</h3>

<p>A network of class <code>BooleanNetwork</code> or <code>SymbolicBooleanNetwork</code>, as described in <code><a href="#topic+loadNetwork">loadNetwork</a></code>.
</p>


<h3>References</h3>

<p>W. J. R. Longabaugh, E. H. Davidson, H. Bolour (2005), Computational representation of developmental genetic regulatory networks. Developmental Biology 283(1):1&ndash;16.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loadNetwork">loadNetwork</a></code>, <code><a href="#topic+loadSBML">loadSBML</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import the example BioTapestry file
# included in the package vignette
exampleFile &lt;- system.file("doc/example.btp",
                           package="BoolNet")
net &lt;- loadBioTapestry(exampleFile)

# print the imported network
print(net)
</code></pre>

<hr>
<h2 id='loadNetwork'>
Load a Boolean network from a file
</h2><span id='topic+loadNetwork'></span>

<h3>Description</h3>

<p>Loads a Boolean network or probabilistic Boolean network from a file and converts it to an internal transition table representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadNetwork(file, 
            bodySeparator = ",",
            lowercaseGenes = FALSE,
            symbolic = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadNetwork_+3A_file">file</code></td>
<td>

<p>The name of the file to be read
</p>
</td></tr>
<tr><td><code id="loadNetwork_+3A_bodyseparator">bodySeparator</code></td>
<td>

<p>An optional separation character to divide the target factors and the formulas. Default is &quot;,&quot;.
</p>
</td></tr>
<tr><td><code id="loadNetwork_+3A_lowercasegenes">lowercaseGenes</code></td>
<td>

<p>If set to <code>TRUE</code>, all gene names are converted to lower case, i.e. the gene names are case-insensitive. This corresponds to the behaviour of <span class="pkg">BoolNet</span> versions prior to 1.5. Defaults to <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="loadNetwork_+3A_symbolic">symbolic</code></td>
<td>

<p>If set to <code>TRUE</code>, a symbolic representation of class <code>SymbolicBooleanNetwork</code> is returned. This is not available for asynchronous or probabilistic Boolean networks, but is required for the simulation of networks with extended temporal predicates and time delays (see <code><a href="#topic+simulateSymbolicModel">simulateSymbolicModel</a></code>). If such predicates are detected, the switch is activated by default. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on whether the network is loaded in truth table representation or not, the supported network file formats differ slightly.
</p>
<p>For the truth table representation (<code>symbolic=FALSE</code>), the language basically consists of expressions based on the Boolean operators AND (&amp;), or (|), and NOT (!). In addition, some convenience operators are included (see EBNF and operator description below).
The first line contains a header. In case of a Boolean network with only one function per gene, the header is &quot;targets, functions&quot;; in a probabilistic network, there is an optional third column &quot;probabilities&quot;. All subsequent lines contain Boolean rules or comment lines that are omitted by the parser.
A rule consists of a target gene, a separator, a Boolean expression to calculate a transition step for the target gene, and an optional probability for the rule (for probabilistic Boolean networks only &ndash; see below). 
</p>
<p>The EBNF description of the network file format is as follows:
</p>
<pre>
Network           = Header Newline {Rule Newline | Comment Newline};
Header            = "targets" Separator "factors";
Rule              = GeneName Separator BooleanExpression [Separator Probability];
Comment           = "#" String;
BooleanExpression = GeneName 
                    | "!" BooleanExpression 
                    | "(" BooleanExpression ")" 
                    | BooleanExpression " &amp; " BooleanExpression  
                    | BooleanExpression " | " BooleanExpression;
                    | "all(" BooleanExpression {"," BooleanExpression} ")"
                    | "any(" BooleanExpression {"," BooleanExpression} ")"
                    | "maj(" BooleanExpression {"," BooleanExpression} ")"
                    | "sumgt(" BooleanExpression {"," BooleanExpression} "," Integer ")"
                    | "sumlt(" BooleanExpression {"," BooleanExpression} "," Integer ")";
GeneName          = ? A gene name from the list of involved genes ?;
Separator         = ",";
Integer           = ? An integer value?;
Probability       = ? A floating-point number ?;
String            = ? Any sequence of characters (except a line break) ?;
Newline           = ? A line break character ?;
</pre>
<p>The extended format for Boolean networks with temporal elements that can be loaded if <code>symbolic=TRUE</code> additionally allows for a specification of time steps. Furthermore, the operators can be extended with iterators that evaluate their arguments over multiple time steps.
</p>
<pre>
Network               = Header Newline
                        {Function Newline | Comment Newline};
Header                = "targets" Separator "factors";
Function              = GeneName Separator BooleanExpression;
Comment               = "#" String;
BooleanExpression     = GeneName | GeneName TemporalSpecification | BooleanOperator | TemporalOperator
BooleanOperator       =   BooleanExpression 
                        | "!" BooleanExpression 
                        | "(" BooleanExpression ")" 
                        | BooleanExpression " &amp; " BooleanExpression  
                        | BooleanExpression " | " BooleanExpression;
TemporalOperator      =   "all" [TemporalIteratorDef] 
                                "(" BooleanExpression {"," BooleanExpression} ")"
                        | "any" [TemporalIteratorDef] 
                                "(" BooleanExpression {"," BooleanExpression} ")"
                        | "maj" [TemporalIteratorDef] 
                                "(" BooleanExpression {"," BooleanExpression} ")"
                        | "sumgt" [TemporalIteratorDef] 
                                  "(" BooleanExpression {"," BooleanExpression} "," Integer ")"
                        | "sumlt" [TemporalIteratorDef] 
                                  "(" BooleanExpression {"," BooleanExpression} "," Integer ")"
                        | "timeis" "(" Integer ")"
                        | "timegt" "(" Integer ")"
                        | "timelt" "(" Integer ")";
TemporalIteratorDef   = "[" TemporalIterator "=" Integer ".." Integer "]";
TemporalSpecification = "[" TemporalOperand {"+" TemporalOperand | "-" TemporalOperand} "]";
TemporalOperand       = TemporalIterator | Integer
TemporalIterator      = ? An alphanumeric string ?;
GeneName              = ? A gene name from the list of involved genes ?;
Separator             = ",";
Integer               = ? An integer value?;
String                = ? Any sequence of characters (except a line break) ?;
Newline               = ? A line break character ?;
</pre>
<p>The meaning of the operators is as follows:
</p>

<dl>
<dt><code>all</code></dt><dd><p>Equivalent to a conjunction of all arguments. For symbolic networks, the operator can have a time range, in which case the arguments are evaluated for each time point specified in the iterator.</p>
</dd>
<dt><code>any</code></dt><dd><p>Equivalent to a disjunction of all arguments. For symbolic networks, the operator can have a time range, in which case the arguments are evaluated for each time point specified in the iterator.</p>
</dd>
<dt><code>maj</code></dt><dd><p>Evaluates to true if the majority of the arguments evaluate to true. For symbolic networks, the operator can have a time range, in which case the arguments are evaluated for each time point specified in the iterator.</p>
</dd>
<dt><code>sumgt</code></dt><dd><p>Evaluates to true if the number of arguments (except the last) that evaluate to true is greater than the number specified in the last argument. For symbolic networks, the operator can have a time range, in which case the arguments are evaluated for each time point specified in the iterator.</p>
</dd>
<dt><code>sumlt</code></dt><dd><p>Evaluates to true if the number of arguments (except the last) that evaluate to true is less than the number specified in the last argument. For symbolic networks, the operator can have a time range, in which case the arguments are evaluated for each time point specified in the iterator.</p>
</dd>
<dt><code>timeis</code></dt><dd><p>Evaluates to true if the current absolute time step (i.e. number of state transitions performed from the current start state) is the same as the argument.</p>
</dd>
<dt><code>timelt</code></dt><dd><p>Evaluates to true if the current absolute time step (i.e. number of state transitions performed from the current start state) is the less than the argument.</p>
</dd>
<dt><code>timegt</code></dt><dd><p>Evaluates to true if the current absolute time step (i.e. number of state transitions performed from the current start state) is greater than the argument.</p>
</dd>
</dl>

<p>If <code>symbolic=FALSE</code> and there is exactly one rule for each gene, a Boolean network of class <code>BooleanNetwork</code> is created. In these networks, constant genes are automatically fixed (e.g. knocked-out or over-expressed). This means that they are always set to the constant value, and states with the complementary value are not considered in transition tables etc. If you would like to change this behaviour, use <code><a href="#topic+fixGenes">fixGenes</a></code> to reset the fixing.
</p>
<p>If <code>symbolic=FALSE</code> and two or more rules exist for the same gene, the function returns a probabilistic network of class <code>ProbabilisticBooleanNetwork</code>. In this case, alternative rules may be annotated with probabilities, which must sum up to 1 for all rules that belong to the same gene. If no probabilities are supplied, uniform distribution is assumed.
</p>
<p>If <code>symbolic=TRUE</code>, a symbolic representation of a (possibly temporal) Boolean network of class <code>SymbolicBooleanNetwork</code> is created.
</p>


<h3>Value</h3>

<p>If <code>symbolic=FALSE</code> and only one function per gene is specified, a structure of class <code>BooleanNetwork</code> representing the network is returned. It has the following components:
</p>
<table>
<tr><td><code>genes</code></td>
<td>
<p>A vector of gene names involved in the network. This list determines the indices of genes in inputs of functions or in state bit vectors.</p>
</td></tr>
<tr><td><code>interactions</code></td>
<td>
<p>A list with <code>length(genes)</code> elements, where the i-th element describes the transition function for the i-th gene. Each element has the following sub-components:
</p>

<dl>
<dt>input</dt><dd><p>A vector of indices of the genes that serve as the input of the Boolean transition function. If the function has no input (i.e. the gene is constant), the vector consists of a zero element.</p>
</dd>
<dt>func</dt><dd><p>The transition function in truth table representation. This vector has <code>2^length(input)</code> entries, one for each combination of input variables. If the gene is constant, the function is 1 or 0.</p>
</dd>
<dt>expression</dt><dd><p>A string representation of the Boolean expression from which the truth table was generated</p>
</dd>
</dl>
</td></tr>
<tr><td><code>fixed</code></td>
<td>
<p>A vector specifying which genes are knocked-out or over-expressed. For each gene, there is one element which is set to 0 if the gene is knocked-out, to 1 if the gene is over-expressed, and to -1 if the gene is not fixed at all, i. e. can change its value according to the supplied transition function. Constant genes are automatically set to fixed values.</p>
</td></tr>
</table>
<p>If <code>symbolic=FALSE</code> and there is at least one gene with two or more alternative transition functions, a structure of class <code>ProbabilisticBooleanNetwork</code> is returned. This structure is similar to <code>BooleanNetwork</code>, but allows for storing more than one function in an interaction. It consists of the following components:
</p>
<table>
<tr><td><code>genes</code></td>
<td>
<p>A vector of gene names involved in the network. This list determines the indices of genes in inputs of functions or in state bit vectors.</p>
</td></tr>
<tr><td><code>interactions</code></td>
<td>
<p>A list with <code>length(genes)</code> elements, where the i-th element describes the alternative transition functions for the i-th gene. Each element is a list of transition functions. In this second-level list, each element has the the following sub-components:
</p>

<dl>
<dt>input</dt><dd><p>A vector of indices of the genes that serve as the input of the Boolean transition function. If the function has no input (i.e. the gene is constant), the vector consists of a zero element.</p>
</dd>
<dt>func</dt><dd><p>The transition function in truth table representation. This vector has <code>2^length(input)</code> entries, one for each combination of input variables. If the gene is constant, the function is -1.</p>
</dd>
<dt>expression</dt><dd><p>A string representation of the underlying Boolean expression</p>
</dd>
<dt>probability</dt><dd><p>The probability that the corresponding transition function is chosen</p>
</dd>	  
</dl>
</td></tr>
<tr><td><code>fixed</code></td>
<td>
<p>A vector specifying which genes are knocked-out or over-expressed. For each gene, there is one element which is set to 0 if the gene is knocked-out, to 1 if the gene is over-expressed, and to -1 if the gene is not fixed at all, i. e. can change its value according to the supplied transition function. You can knock-out and over-express genes using <code><a href="#topic+fixGenes">fixGenes</a></code>.</p>
</td></tr>
</table>
<p>If <code>symbolic=TRUE</code>, a structure of class <code>SymbolicBooleanNetwork</code> that represents the network as expression trees is returned. It has the following components:
</p>
<table>
<tr><td><code>genes</code></td>
<td>
<p>A vector of gene names involved in the network. This list determines the indices of genes in inputs of functions or in state bit vectors.</p>
</td></tr>
<tr><td><code>interactions</code></td>
<td>
<p>A list with <code>length(genes)</code> elements, where the i-th element describes the transition function for the i-th gene in a symbolic representation. Each such element is a list that represents a recursive expression tree, possibly consisting of sub-elements (operands) that are expression trees themselves. Each element in an expression tree can be a Boolean/temporal operator, a literal (&quot;atom&quot;) or a numeric constant.</p>
</td></tr>
<tr><td><code>internalStructs</code></td>
<td>
<p>A pointer referencing an internal representation of the expression trees as raw C objects. This is used for simulations and must be set to NULL if <code>interactions</code> are changed to force a refreshment.
</p>
</td></tr>
<tr><td><code>timeDelays</code></td>
<td>
<p>An integer vector storing the temporal memory sizes required for each of the genes in the network. That is, the vector stores the minimum number of predecessor states of each gene that need to be saved to determine the successor state of the network.</p>
</td></tr>
<tr><td><code>fixed</code></td>
<td>
<p>A vector specifying which genes are knocked-out or over-expressed. For each gene, there is one element which is set to 0 if the gene is knocked-out, to 1 if the gene is over-expressed, and to -1 if the gene is not fixed at all, i. e. can change its value according to the supplied transition function. Constant genes are automatically set to fixed values.</p>
</td></tr>  
</table>


<h3>See Also</h3>

<p><code><a href="#topic+getAttractors">getAttractors</a></code>, <code><a href="#topic+simulateSymbolicModel">simulateSymbolicModel</a></code>, <code><a href="#topic+markovSimulation">markovSimulation</a></code>, <code><a href="#topic+stateTransition">stateTransition</a></code>, <code><a href="#topic+fixGenes">fixGenes</a></code>, <code><a href="#topic+loadSBML">loadSBML</a></code>, <code><a href="#topic+loadBioTapestry">loadBioTapestry</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# write example network to file
fil &lt;- tempfile(pattern = "testNet")
sink(fil)
cat("targets, factors\n")
cat("Gene1, !Gene2 | !Gene3\n")
cat("Gene2, Gene3 &amp; Gene4\n")
cat("Gene3, Gene2 &amp; !Gene1\n")
cat("Gene4, 1\n")
sink()

# read file
net &lt;- loadNetwork(fil)
print(net)

## End(Not run)
</code></pre>

<hr>
<h2 id='loadSBML'>
Load an SBML document
</h2><span id='topic+loadSBML'></span>

<h3>Description</h3>

<p>Loads an SBML document that specifies a qualitative model using the <code>sbml-qual</code> extension package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadSBML(file, symbolic=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadSBML_+3A_file">file</code></td>
<td>

<p>The SBML document to be imported
</p>
</td></tr>
<tr><td><code id="loadSBML_+3A_symbolic">symbolic</code></td>
<td>

<p>If set to <code>TRUE</code>, the function returns an object of class <code>SymbolicBooleanNetwork</code> with an expression tree representation. Otherwise, it returns an object of class <code>BooleanNetwork</code> with a truth table representation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The import assumes an SBML level 3 version 1 document with the <code>sbml-qual</code> extension package version 1.0.
<span class="pkg">BoolNet</span> only supports a subset of the <code>sbml-qual</code> standard. The function tries to import those documents that describe a logical model with two possible values per species. It does not support general logical models with more than two values per species or Petri nets. 
</p>
<p>Further details on the import:
</p>

<ul>
<li><p>The import supports multiple function terms with the same output for a transition and interprets them as a disjunction, as proposed in the specification.
</p>
</li>
<li><p>Comparison operators are converted to the corresponding Boolean expressions.
</p>
</li>
<li><p>Compartments are ignored.
</p>
</li></ul>

<p>For the import, the <span class="pkg">XML</span> package is required.
</p>


<h3>Value</h3>

<p>Returns a structure of class <code>BooleanNetwork</code> or <code>SymbolicBooleanNetwork</code>, as described in <code><a href="#topic+loadNetwork">loadNetwork</a></code>.
</p>


<h3>References</h3>

<p><a href="http://sbml.org/Documents/Specifications/SBML_Level_3/Packages/Qualitative_Models_(qual)">http://sbml.org/Documents/Specifications/SBML_Level_3/Packages/Qualitative_Models_(qual)</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+toSBML">toSBML</a></code>, <code><a href="#topic+loadNetwork">loadNetwork</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load the cell cycle network
data(cellcycle)

fil &lt;- tempfile()
# export the network to SBML
toSBML(cellcycle, fil)

# reimport the model
print(loadSBML(fil))

## End(Not run)
</code></pre>

<hr>
<h2 id='markovSimulation'>
Identify important states in probabilistic Boolean networks
</h2><span id='topic+markovSimulation'></span>

<h3>Description</h3>

<p>Identifies important states in probabilistic Boolean networks (PBN) using a Markov chain simulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>markovSimulation(network, 
                 numIterations = 1000, 
                 startStates = list(), 
                 cutoff = 0.001, 
                 returnTable = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="markovSimulation_+3A_network">network</code></td>
<td>

<p>An object of class <code>ProbabilisticBooleanNetwork</code> or <code>BooleanNetwork</code> whose transitions are simulated
</p>
</td></tr>
<tr><td><code id="markovSimulation_+3A_numiterations">numIterations</code></td>
<td>

<p>The number of iterations for the matrix multiplication, which corresponds to the number of state transitions to simulate
</p>
</td></tr>
<tr><td><code id="markovSimulation_+3A_startstates">startStates</code></td>
<td>

<p>An optional list of start states. Each entry of the list must be a vector with a 0/1 value for each gene. If specified, the simulation is restricted to the states reachable from the supplied start states. Otherwise, all states are considered.
</p>
</td></tr>
<tr><td><code id="markovSimulation_+3A_cutoff">cutoff</code></td>
<td>

<p>The cutoff value used to determine if a probability is 0. All output probabilities less than or equal to this value are set to 0.
</p>
</td></tr>
<tr><td><code id="markovSimulation_+3A_returntable">returnTable</code></td>
<td>

<p>If set to true, a transition table annotated with the probabilities for the transitions is included in the results. This is required by <code><a href="#topic+plotPBNTransitions">plotPBNTransitions</a></code> and <code><a href="#topic+getTransitionProbabilities">getTransitionProbabilities</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm identifies important states by performing the following steps: First, a Markov matrix is calculated from the set of transition functions, where each entry of the matrix specifies the probability of a state transition from the state belonging to the corresponding row to the state belonging to the corresponding column. A vector is initialized with uniform probability for all states (or &ndash; if specified &ndash; uniform probability for all start states) and repeatedly multiplied with the Markov matrix. The method returns all states with non-zero probability in this vector.
See the references for more details.
</p>


<h3>Value</h3>

<p>An object of class <code>MarkovSimulation</code> with the following components:
</p>
<table>
<tr><td><code>reachedStates</code></td>
<td>
<p>A data frame with one state in each row. The first columns specify the gene values of the state, and the last column holds the probability that the corresponding state is reached after <code>numIterations</code> transitions. Only states with a probability greater than <code>cutoff</code> are included in this table.</p>
</td></tr>
<tr><td><code>genes</code></td>
<td>
<p>A vector of gene names of the input network</p>
</td></tr>
<tr><td><code>table</code></td>
<td>
<p>If <code>returnTable=TRUE</code>, this structure holds a table of transitions with the corresponding probabilities that transitions are chosen. This is a list with the following components:
</p>

<dl>
<dt>initialStates</dt><dd><p>A matrix of encoded start states of the transitions</p>
</dd>
<dt>nextStates</dt><dd><p>The encoded successor states of the transitions</p>
</dd>
<dt>probabilities</dt><dd><p>The probabilities that the transitions are chosen in a single step</p>
</dd>
</dl>
</td></tr>
</table>


<h3>References</h3>

<p>I. Shmulevich, E. R. Dougherty, S. Kim, W. Zhang (2002), Probabilistic Boolean networks: a rule-based uncertainty model for gene regulatory networks. Bioinformatics 18(2):261&ndash;274.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reconstructNetwork">reconstructNetwork</a></code>, <code><a href="#topic+plotPBNTransitions">plotPBNTransitions</a></code>, <code><a href="#topic+getTransitionProbabilities">getTransitionProbabilities</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
# load example network
data(examplePBN)

# perform a Markov chain simulation
sim &lt;- markovSimulation(examplePBN)

# print the relevant states and transition probabilities
print(sim)

# plot the transitions and their probabilities
plotPBNTransitions(sim)

## End(Not run)
</code></pre>

<hr>
<h2 id='perturbNetwork'>
Perturb a Boolean network randomly
</h2><span id='topic+perturbNetwork'></span>

<h3>Description</h3>

<p>Modifies a synchronous, asynchronous, or probabilistic Boolean network by randomly perturbing  either the functions for single genes or the state transitions. Random perturbations can be employed to assess the stability of the network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perturbNetwork(network, 
               perturb = c("functions","transitions"), 
               method = c("bitflip","shuffle"), 
               simplify = (perturb[1]!="functions"), 
               readableFunctions = FALSE, 
               excludeFixed = TRUE, 
               maxNumBits = 1, 
               numStates = max(1,2^length(network$genes)/100))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perturbNetwork_+3A_network">network</code></td>
<td>

<p>A network structure of class <code>BooleanNetwork</code> or <code>ProbabilisticBooleanNetwork</code>. These networks can be read from files by <code><a href="#topic+loadNetwork">loadNetwork</a></code>, generated by <code><a href="#topic+generateRandomNKNetwork">generateRandomNKNetwork</a></code>, or reconstructed by <code><a href="#topic+reconstructNetwork">reconstructNetwork</a></code>.
</p>
</td></tr>
<tr><td><code id="perturbNetwork_+3A_perturb">perturb</code></td>
<td>

<p>If set to &quot;functions&quot;, a transition function of a single gene is chosen at random and perturbed directly. This is the default mode. If set to &quot;transitions&quot;, the transition table is generated, one or several state transitions are perturbed randomly, and the gene transition functions are rebuilt from the modified transition table. <code>perturb="transitions"</code> is only allowed for non-probabilistic networks of class <code>BooleanNetworks</code>.
</p>
</td></tr>
<tr><td><code id="perturbNetwork_+3A_method">method</code></td>
<td>

<p>The perturbation method to be applied to the functions or transitions. &quot;bitflip&quot; randomly inverts one or several bits (depending on the value of <code>maxNumBits</code>). &quot;shuffle&quot; generates a random permutation of the positions in the function or state and rearranges the bits according to this permutation.
</p>
</td></tr>
<tr><td><code id="perturbNetwork_+3A_simplify">simplify</code></td>
<td>

<p>If this is true, <code><a href="#topic+simplifyNetwork">simplifyNetwork</a></code> is called to simplify the gene transition functions after the perturbation. This removes irrelevant input genes. Defaults to TRUE if <code>perturb</code> is &quot;transitions&quot;, and to FALSE otherwise.
</p>
</td></tr>
<tr><td><code id="perturbNetwork_+3A_readablefunctions">readableFunctions</code></td>
<td>

<p>If this is true, readable DNF representations of the truth tables of the functions are generated. These DNF are displayed when the network is printed. The DNF representations are not minimized and can thus be very long. If set to FALSE, the truth table result column is displayed.	
</p>
</td></tr>
<tr><td><code id="perturbNetwork_+3A_excludefixed">excludeFixed</code></td>
<td>

<p>Determines whether fixed variables can also be perturbed (if set to FALSE) or if they are excluded from the perturbation (if set to TRUE). Default is TRUE.
</p>
</td></tr>
<tr><td><code id="perturbNetwork_+3A_maxnumbits">maxNumBits</code></td>
<td>

<p>The maximum number of bits to be perturbed in one function or state. Defaults to 1.
</p>
</td></tr>
<tr><td><code id="perturbNetwork_+3A_numstates">numStates</code></td>
<td>

<p>The number of state transitions to be perturbed if <code>perturb</code> is &quot;transitions&quot;. Defaults to 1
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the input, an object of class <code>BooleanNetwork</code> or <code>ProbabilisticBooleanNetwork</code> containing the perturbed copy of the original network is returned. The classes <code>BooleanNetwork</code> and <code>ProbabilisticBooleanNetwork</code> are described in more detail in <code><a href="#topic+loadNetwork">loadNetwork</a></code>.
</p>


<h3>References</h3>

<p>Y. Xiao and E. R. Dougherty (2007), The impact of function perturbations in Boolean networks. Bioinformatics 23(10):1265&ndash;1273.
</p>
<p>I. Shmulevich, E. R. Dougherty, W. Zhang (2002), Control of stationary behavior in probabilistic Boolean networks by means of structural intervention. Journal of Biological Systems 10(4):431&ndash;445.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loadNetwork">loadNetwork</a></code>, <code><a href="#topic+generateRandomNKNetwork">generateRandomNKNetwork</a></code>, <code><a href="#topic+reconstructNetwork">reconstructNetwork</a></code>, <code><a href="#topic+simplifyNetwork">simplifyNetwork</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load example data
data(cellcycle)

# perturb the network
perturbedNet1 &lt;- perturbNetwork(cellcycle, perturb="functions", method="shuffle")
perturbedNet2 &lt;- perturbNetwork(cellcycle, perturb="transitions", method="bitflip")

# get attractors
print(getAttractors(perturbedNet1))
print(getAttractors(perturbedNet2))

## End(Not run)
</code></pre>

<hr>
<h2 id='perturbTrajectories'>
Perturb the state trajectories and calculate robustness measures
</h2><span id='topic+perturbTrajectories'></span>

<h3>Description</h3>

<p>Perturbs the state trajectories of a network and assesses the robustness by comparing the successor states or the attractors of a set of initial states and a set of perturbed copies of these initial states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perturbTrajectories(network, 
                    measure = c("hamming", "sensitivity", "attractor"), 
                    numSamples = 1000, 
                    flipBits = 1, 
                    updateType = c("synchronous", "asynchronous", "probabilistic"), 
                    gene, 
                    ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perturbTrajectories_+3A_network">network</code></td>
<td>

<p>A network structure of class <code>BooleanNetwork</code>, <code>SymbolicBooleanNetwork</code> or <code>ProbabilisticBooleanNetwork</code> whose robustness is measured.
</p>
</td></tr>
<tr><td><code id="perturbTrajectories_+3A_measure">measure</code></td>
<td>

<p>Defines the way the robustness is measured (see Details).
</p>
</td></tr>
<tr><td><code id="perturbTrajectories_+3A_numsamples">numSamples</code></td>
<td>

<p>The number of randomly generated pairs of initial states and perturbed copies. Defaults to 1000.
</p>
</td></tr>
<tr><td><code id="perturbTrajectories_+3A_flipbits">flipBits</code></td>
<td>

<p>The number of bits that are flipped to generate a perturbed copy of an initial state. Defaults to 1.
</p>
</td></tr>
<tr><td><code id="perturbTrajectories_+3A_updatetype">updateType</code></td>
<td>

<p>If <code>measure="hamming"</code>, the type of update that is performed to calculate successor states.
</p>
</td></tr>
<tr><td><code id="perturbTrajectories_+3A_gene">gene</code></td>
<td>

<p>If <code>measure="sensitivity"</code>, the name or index of the gene for whose transition function the average sensitivity is calculated.
</p>
</td></tr>
<tr><td><code id="perturbTrajectories_+3A_...">...</code></td>
<td>

<p>Further parameters to <code><a href="#topic+stateTransition">stateTransition</a></code> and <code><a href="#topic+getAttractors">getAttractors</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function generates a set of <code>numSamples</code> initial states and then applies <code>flipBits</code> random bit flips to each initial state to generate a perturbed copy of each initial state. For each pair of initial state and perturbed state, a robustness statistic is calculated depending <code>measure</code>:
</p>
<p>If <code>measure="hamming"</code>, the normalized Hamming distances between the successor states of each initial state and the corresponding perturbed state are calculated. 
</p>
<p>If <code>measure="sensitivity"</code>, the average sensitivity of a specific transition function (specified in the <code>gene</code> parameter) is approximated: The statistic is a logical vector that is <code>TRUE</code> if <code>gene</code> differs in the successor states of each initial state and the corresponding perturbed state.
</p>
<p>If <code>measure="attractor"</code>, the attractors of all initial states and all perturbed states are identified. The statistic is a logical vector specifying whether the attractors are identical in each pair of initial state and perturbed initial state.
</p>


<h3>Value</h3>

<p>A list with the following items:
</p>
<table>
<tr><td><code>stat</code></td>
<td>
<p>A vector of size <code>numSamples</code> containing the robustness statistic for each pair of initial state and perturbed copy.</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>The summarized statistic (i.e. the mean value) over all state pairs.</p>
</td></tr>
</table>


<h3>References</h3>

<p>I. Shmulevich and S. A. Kauffman (2004), Activities and Sensitivities in Boolean Network Models. Physical Review Letters 93(4):048701.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+testNetworkProperties">testNetworkProperties</a></code>, <code><a href="#topic+perturbNetwork">perturbNetwork</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(cellcycle)

# calculate average normalized Hamming distance of successor states
hamming &lt;- perturbTrajectories(cellcycle, measure="hamming", numSamples=100)
print(hamming$value)

# calculate average sensitivity of transition function for gene "Cdh1"
sensitivity &lt;- perturbTrajectories(cellcycle, measure="sensitivity", numSamples=100, gene="Cdh1")
print(sensitivity$value)

# calculate percentage of equal attractors for state pairs
attrEqual &lt;- perturbTrajectories(cellcycle, measure="attractor", numSamples=100)
print(attrEqual$value)

## End(Not run)
</code></pre>

<hr>
<h2 id='plotAttractors'>
Plot state tables or transition graphs of attractors
</h2><span id='topic+plotAttractors'></span>

<h3>Description</h3>

<p>Visualizes attractors, either by drawing a table of the involved states in two colors, or by drawing a graph of transitions between the states of the attractor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotAttractors(attractorInfo, 
               subset, 
               title = "", 
               mode = c("table","graph"),
               grouping = list(), 
               plotFixed = TRUE, 
               onColor = "#4daf4a",
               offColor = "#e41a1c",
               layout = layout.circle, 
               drawLabels = TRUE,
               drawLegend = TRUE,
               ask = TRUE,
               reverse = FALSE,
               borderColor = "black",
               eps = 0.1, 
               allInOnePlot = FALSE,
               ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotAttractors_+3A_attractorinfo">attractorInfo</code></td>
<td>

<p>An object of class <code>AttractorInfo</code>, as returned by <code><a href="#topic+getAttractors">getAttractors</a></code>, or an object of class <code>SymbolicSimulation</code>, as returned by <code><a href="#topic+simulateSymbolicModel">simulateSymbolicModel</a></code>.
</p>
</td></tr>
<tr><td><code id="plotAttractors_+3A_subset">subset</code></td>
<td>
<p>An subset of attractors to be plotted. This is a vector of attractor indices in <code>attractorInfo</code>.</p>
</td></tr>
<tr><td><code id="plotAttractors_+3A_title">title</code></td>
<td>

<p>An optional title for the plot
</p>
</td></tr>
<tr><td><code id="plotAttractors_+3A_mode">mode</code></td>
<td>
<p>Switches between two kinds of attractor plots. See Details for more information. Default is &quot;table&quot;.</p>
</td></tr>
<tr><td><code id="plotAttractors_+3A_grouping">grouping</code></td>
<td>
<p>This optional parameter is only used if <code>mode="table"</code> and specifies a structure to form groups of genes in the plot. This is a list with the following elements: 
</p>

<dl>
<dt>class</dt><dd><p>A vector of names for the groups. These names will be printed in the region belonging to the group in the plot.</p>
</dd>  	
<dt>index</dt><dd><p>A list with the same length as <code>class</code>. Each element is a vector of gene names or gene indices belonging to the group.</p>
</dd></dl>

</td></tr>
<tr><td><code id="plotAttractors_+3A_plotfixed">plotFixed</code></td>
<td>
<p>This optional parameter is only used if <code>mode="table"</code>.
If this is true, genes with fixed values are included in the plot. Otherwise, these genes are not drawn.
</p>
</td></tr>
<tr><td><code id="plotAttractors_+3A_oncolor">onColor</code></td>
<td>
<p>This optional parameter is only used if <code>mode="table"</code> and specifies the color value for the 1/ON values in the table. Defaults to green.
</p>
</td></tr>
<tr><td><code id="plotAttractors_+3A_offcolor">offColor</code></td>
<td>
<p>This optional parameter is only used if <code>mode="table"</code> and specifies the color value for the 0/OFF values in the table. Defaults to red.
</p>
</td></tr>
<tr><td><code id="plotAttractors_+3A_layout">layout</code></td>
<td>
<p>If <code>mode="graph"</code>, this parameter specifies a layouting function that determines the placement of the nodes in the graph. Please refer to the <code><a href="igraph.html#topic+layout">layout</a></code> manual entry in the <span class="pkg">igraph</span> package for further details. By default, the circle layout is used.
</p>
</td></tr>
<tr><td><code id="plotAttractors_+3A_drawlabels">drawLabels</code></td>
<td>
<p>This parameter is only relevant if <code>mode="graph"</code>. It determines whether the nodes of the graph are annotated with the corresponding values of the genes in the attractor states.
</p>
</td></tr>
<tr><td><code id="plotAttractors_+3A_drawlegend">drawLegend</code></td>
<td>
<p>Specifies whether a color key for the ON/OFF states is drawn if <code>mode="table"</code>. Defaults to <code>TRUE</code>.
</p>
</td></tr> 
<tr><td><code id="plotAttractors_+3A_ask">ask</code></td>
<td>

<p>If set to true, the plot function will prompt for a user input for each new plot that is shown on an interactive device (see <code>link{par("ask")}</code>). 
</p>
</td></tr>
<tr><td><code id="plotAttractors_+3A_reverse">reverse</code></td>
<td>

<p>Specifies the order of the genes in the plot. By default, the first gene is placed in the first row of the plot. If <code>reverse=TRUE</code> (which was the default until <span class="pkg">BoolNet</span> version 2.0.2), the first gene in the network is placed in the bottom row of the plot. 
</p>
</td></tr>
<tr><td><code id="plotAttractors_+3A_bordercolor">borderColor</code></td>
<td>

<p>Specifies the border or seprating color of states in an attractor. Defaults to <code>"black"</code>.
</p>
</td></tr>
<tr><td><code id="plotAttractors_+3A_eps">eps</code></td>
<td>

<p>Specifies plotting margin for the sequence of states. Defaults to <code>0.1</code>.
</p>
</td></tr>
<tr><td><code id="plotAttractors_+3A_allinoneplot">allInOnePlot</code></td>
<td>

<p>If this is <code>TRUE</code> then all attractors, with <code>mode = "table"</code>, are plotted in one plot as specified internally by <code>par$mfrow</code> parameter. Previous value of the <code>par$mfrow</code> parameter is preserved. Defaults to <code>FALSE</code>, meaning the plots for more than one attractor will be switched interactively or all plotted in an non-interactive graphical device.
</p>
</td></tr>
<tr><td><code id="plotAttractors_+3A_...">...</code></td>
<td>

<p>Further graphical parameters to be passed to <code><a href="igraph.html#topic+plot.graph">plot.igraph</a></code> if <code>mode="graph"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function comprises two different types of plots: 
</p>
<p>The &quot;table&quot; mode visualizes the gene values of the states in the attractor and is only suited for synchronous or steady-state attractors. Complex asynchronous attractors are omitted in this mode. Attractors in <code>attractorInfo</code> are first grouped by length. Then, a figure is plotted to the currently selected device for each attractor length (i.e. one plot with all attractors consisting of 1 state, one plot with all attractors consisting of 2 states, etc.). If <code>ask=TRUE</code> and the standard X11 output device is used, the user must confirm that the next plot for the next attractor size should be shown.
The figure is a table with the genes in the rows and the states of the attractors in the columns. Cells of the table are (by default) red for 0/OFF values and green for 1/ON values. If <code>grouping</code> is set, the genes are rearranged according to the indices in the group, horizontal separation lines are plotted between the groups, and the group names are printed.
</p>
<p>The &quot;graph&quot; mode visualizes the transitions between different states. It creates a graph in which the vertices are the states in the attractor and the edges are state transitions among these states. This mode can visualize all kinds of attractors, including complex/loose attractors. One plot is drawn for each attractor. As before, this means that on the standard output device, only the last plot is displayed unless you set <code>par(mfrow=c(...))</code> accordingly.
</p>


<h3>Value</h3>

<p>If <code>mode="table"</code>, a list of matrices corresponding to the tables is returned. Each of these matrices has the genes in the rows and the states of the attractors in the columns.
</p>
<p>If <code>mode="graph"</code>, a list of objects of class <code>igraph</code> is returned. Each of these objects describes the graph for one attractor.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getAttractors">getAttractors</a></code>, <code><a href="#topic+simulateSymbolicModel">simulateSymbolicModel</a></code>, <code><a href="#topic+attractorsToLaTeX">attractorsToLaTeX</a></code>, <code><a href="#topic+plotSequence">plotSequence</a></code>, <code><a href="#topic+sequenceToLaTeX">sequenceToLaTeX</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load example data
data(cellcycle)

# get attractors
attractors &lt;- getAttractors(cellcycle)

# calculate number of different attractor lengths, 
# and plot attractors side by side in "table" mode
par(mfrow=c(1, length(table(sapply(attractors$attractors,
                          function(attractor)
                          {
                            length(attractor$involvedStates)
                          })))))
plotAttractors(attractors)

# plot attractors in "graph" mode
par(mfrow=c(1, length(attractors$attractors)))
plotAttractors(attractors, mode="graph")

# identify asynchronous attractors
attractors &lt;- getAttractors(cellcycle, type="asynchronous")

# plot attractors in "graph" mode
par(mfrow=c(1, length(attractors$attractors)))
plotAttractors(attractors, mode="graph")

## End(Not run)
</code></pre>

<hr>
<h2 id='plotNetworkWiring'>
Plot the wiring of a Boolean network
</h2><span id='topic+plotNetworkWiring'></span>

<h3>Description</h3>

<p>Plots the wiring of genes (i.e. the gene dependencies) of a synchronous or probabilistic Boolean network. The nodes of the graph are the genes, and the directed edges show the dependencies of the genes. This requires the <span class="pkg">igraph</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotNetworkWiring(network, 
                  layout = layout.fruchterman.reingold, 
                  plotIt = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotNetworkWiring_+3A_network">network</code></td>
<td>

<p>A network structure of class <code>BooleanNetwork</code>, <code>SymbolicBooleanNetwork</code> or <code>ProbabilisticBooleanNetwork</code>. These networks can be read from files by <code><a href="#topic+loadNetwork">loadNetwork</a></code>, generated by <code><a href="#topic+generateRandomNKNetwork">generateRandomNKNetwork</a></code>, or reconstructed by <code><a href="#topic+reconstructNetwork">reconstructNetwork</a></code>.
</p>
</td></tr>
<tr><td><code id="plotNetworkWiring_+3A_layout">layout</code></td>
<td>

<p>A layouting function that determines the placement of the nodes in the graph. Please refer to the <code><a href="igraph.html#topic+layout">layout</a></code> manual entry in the <span class="pkg">igraph</span> package for further details. By default, the Fruchterman-Reingold algorithm is used.
</p>
</td></tr>
<tr><td><code id="plotNetworkWiring_+3A_plotit">plotIt</code></td>
<td>

<p>If this is true, a plot is generated. Otherwise, only an object of class <code>igraph</code> is returned, but no plot is drawn.
</p>
</td></tr>
<tr><td><code id="plotNetworkWiring_+3A_...">...</code></td>
<td>

<p>Further graphical parameters to be passed to <code><a href="igraph.html#topic+plot.graph">plot.igraph</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the <code><a href="igraph.html#topic+plot.graph">plot.igraph</a></code> function from the <span class="pkg">igraph</span> package. The plots are customizeable using the <code>...</code> argument. For details on possible parameters, please refer to <code><a href="igraph.html#topic+plot.common">igraph.plotting</a></code>.
</p>


<h3>Value</h3>

<p>Returns an invisible object of class <code>igraph</code> containing the wiring graph.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loadNetwork">loadNetwork</a></code>, <code><a href="#topic+generateRandomNKNetwork">generateRandomNKNetwork</a></code>, <code><a href="#topic+reconstructNetwork">reconstructNetwork</a></code>, <code><a href="#topic+plotStateGraph">plotStateGraph</a></code>, <code><a href="igraph.html#topic+plot.graph">igraph.plotting</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load example data
data(cellcycle)

# plot wiring graph
plotNetworkWiring(cellcycle)

## End(Not run)
</code></pre>

<hr>
<h2 id='plotPBNTransitions'>
Visualize the transitions in a probabilistic Boolean network
</h2><span id='topic+plotPBNTransitions'></span>

<h3>Description</h3>

<p>Visualizes the state transitions and their probabilities in a probabilistic Boolean network. This takes the transition table information calculated by the <code><a href="#topic+markovSimulation">markovSimulation</a></code> method. Only transitions with non-zero probability are included in the plot. The function requires the <span class="pkg">igraph</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPBNTransitions(markovSimulation, 
                   stateSubset, 
                   drawProbabilities = TRUE, 
                   drawStateLabels = TRUE, 
                   layout = layout.fruchterman.reingold, 
                   plotIt = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPBNTransitions_+3A_markovsimulation">markovSimulation</code></td>
<td>

<p>An object of class <code>MarkovSimulation</code>, as returned by <code><a href="#topic+markovSimulation">markovSimulation</a></code>. As the transition table information in this structure is required, <code><a href="#topic+markovSimulation">markovSimulation</a></code> must be called with <code>returnTable</code> set to TRUE.
</p>
</td></tr>
<tr><td><code id="plotPBNTransitions_+3A_statesubset">stateSubset</code></td>
<td>

<p>An optional list of states, where each element of the list must be a vector with a 0/1 entry for each gene. If this argument is supplied, the graph only contains the specified states and transitions between these states.
</p>
</td></tr>
<tr><td><code id="plotPBNTransitions_+3A_drawprobabilities">drawProbabilities</code></td>
<td>

<p>If set to true, the edges of the graph are annotated with the probabilities of the corresponding transitions. Default is TRUE.
</p>
</td></tr>
<tr><td><code id="plotPBNTransitions_+3A_drawstatelabels">drawStateLabels</code></td>
<td>

<p>If set to true, the vertices of the graph are annotated with the gene values of the corresponding states. Defaults to TRUE.
</p>
</td></tr>
<tr><td><code id="plotPBNTransitions_+3A_layout">layout</code></td>
<td>

<p>A layouting function that determines the placement of the nodes in the graph. Please refer to the <code><a href="igraph.html#topic+layout">layout</a></code> manual entry in the <span class="pkg">igraph</span> package for further details. By default, the Fruchterman-Reingold algorithm is used.
</p>
</td></tr>
<tr><td><code id="plotPBNTransitions_+3A_plotit">plotIt</code></td>
<td>

<p>If this is true, a plot is generated. Otherwise, only an object of class <code>igraph</code> is returned, but no plot is drawn.
</p>
</td></tr>
<tr><td><code id="plotPBNTransitions_+3A_...">...</code></td>
<td>

<p>Further graphical parameters to be passed to <code><a href="igraph.html#topic+plot.graph">plot.igraph</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the <code><a href="igraph.html#topic+plot.graph">plot.igraph</a></code> function from the <span class="pkg">igraph</span> package. The plots are customizeable using the <code>...</code> argument. For details on possible parameters, please refer to <code><a href="igraph.html#topic+plot.common">igraph.plotting</a></code>.
</p>


<h3>Value</h3>

<p>Returns an invisible object of class <code>igraph</code> containing the wiring graph.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+markovSimulation">markovSimulation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load example network
data(examplePBN)

# perform a Markov chain simulation
sim &lt;- markovSimulation(examplePBN)

# plot the transitions and their probabilities
plotPBNTransitions(sim)

## End(Not run)
</code></pre>

<hr>
<h2 id='plotSequence'>
Plot a sequence of states
</h2><span id='topic+plotSequence'></span>

<h3>Description</h3>

<p>Visualizes sequences of states in synchronous Boolean networks, either by drawing a table of the involved states in two colors, or by drawing a graph of transitions between the successive states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSequence(network, 
             startState, 
             includeAttractorStates = c("all","first","none"), 
             sequence,
             title = "", 
             mode=c("table","graph"),
             plotFixed = TRUE, grouping = list(),
             onColor="#4daf4a", 
             offColor = "#e41a1c",
             layout, 
             drawLabels=TRUE, 
             drawLegend=TRUE, 
             highlightAttractor=TRUE,
             reverse = FALSE,
             borderColor = "black", 
             eps=0.1,
             attractor.sep.lwd = 2, 
             attractor.sep.col = "blue",
             ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSequence_+3A_network">network</code></td>
<td>

<p>An object of class <code>BooleanNetwork</code> or <code>SymbolicBooleanNetwork</code> for which a sequence of state transitions is calculated
</p>
</td></tr>
<tr><td><code id="plotSequence_+3A_startstate">startState</code></td>
<td>

<p>The start state of the sequence
</p>
</td></tr>
<tr><td><code id="plotSequence_+3A_includeattractorstates">includeAttractorStates</code></td>
<td>

<p>Specifies whether the actual attractor states are included in the plot or not (see also <code><a href="#topic+getPathToAttractor">getPathToAttractor</a></code>). If <code>includeAttractorStates = "all"</code> (which is the default behaviour), the sequence ends when the attractor was traversed once. If <code>includeAttractorStates = "first"</code>, only the first state of attractor is added to the sequence. If includeAttractorStates = &quot;none&quot;, the sequence ends with the last non-attractor state. 
</p>
</td></tr>
<tr><td><code id="plotSequence_+3A_sequence">sequence</code></td>
<td>

<p>The alternative call to <code>plotSequence</code> requires the specification of the sequence itself instead of the network and the start state. The sequence must be provided as a data frame with the genes in the columns and the successive states in the rows. For example, sequences can be obtained using <code><a href="#topic+getPathToAttractor">getPathToAttractor</a></code> or <code><a href="#topic+getAttractorSequence">getAttractorSequence</a></code> (however, the specialized plot <code><a href="#topic+plotAttractors">plotAttractors</a></code> exists for attractors).</p>
</td></tr>
<tr><td><code id="plotSequence_+3A_title">title</code></td>
<td>

<p>An optional title for the plot
</p>
</td></tr>
<tr><td><code id="plotSequence_+3A_mode">mode</code></td>
<td>
<p>Switches between two kinds of attractor plots. See Details for more information. Default is &quot;table&quot;.</p>
</td></tr>
<tr><td><code id="plotSequence_+3A_plotfixed">plotFixed</code></td>
<td>
<p>This optional parameter is only used if <code>mode="table"</code>.
If this is true, genes with fixed values are included in the plot. Otherwise, these genes are not drawn.
</p>
</td></tr>
<tr><td><code id="plotSequence_+3A_grouping">grouping</code></td>
<td>
<p>This optional parameter is only used if <code>mode="table"</code> and specifies a structure to form groups of genes in the plot. This is a list with the following elements: 
</p>

<dl>
<dt>class</dt><dd><p>A vector of names for the groups. These names will be printed in the region belonging to the group in the plot.</p>
</dd>  	
<dt>index</dt><dd><p>A list with the same length as <code>class</code>. Each element is a vector of gene names or gene indices belonging to the group.</p>
</dd></dl>

</td></tr>
<tr><td><code id="plotSequence_+3A_oncolor">onColor</code></td>
<td>
<p>This optional parameter is only used if <code>mode="table"</code> and specifies the color value for the 1/ON values in the table. Defaults to green.
</p>
</td></tr>
<tr><td><code id="plotSequence_+3A_offcolor">offColor</code></td>
<td>
<p>This optional parameter is only used if <code>mode="table"</code> and specifies the color value for the 0/OFF values in the table. Defaults to red.
</p>
</td></tr>
<tr><td><code id="plotSequence_+3A_layout">layout</code></td>
<td>
<p>If <code>mode="graph"</code>, this parameter specifies a layouting function that determines the placement of the nodes in the graph. Please refer to the <code><a href="igraph.html#topic+layout">layout</a></code> manual entry in the <span class="pkg">igraph</span> package for further details. By default, the nodes are placed in a horizontal line.
</p>
</td></tr>
<tr><td><code id="plotSequence_+3A_drawlabels">drawLabels</code></td>
<td>
<p>This parameter is only relevant if <code>mode="graph"</code>. It determines whether the nodes of the graph are annotated with the corresponding values of the genes in the attractor states.
</p>
</td></tr>
<tr><td><code id="plotSequence_+3A_drawlegend">drawLegend</code></td>
<td>
<p>Specifies whether a color key for the ON/OFF states is drawn if <code>mode="table"</code>. Defaults to <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="plotSequence_+3A_highlightattractor">highlightAttractor</code></td>
<td>

<p>If set to true, the attractor states are highlighted in the plot. If <code>mode="table"</code>, a line is drawn at the begin of the attractor, and the states are labeled correspondingly. If <code>mode="graph"</code>, the attractor transitions are drawn as bold lines. Information on the attractor must be supplied in the attribute <code>attractor</code> of the sequence, which is a vector of indices of the states that belong to the attractor. This attribute is usually present if the sequence was obtained using <code><a href="#topic+getPathToAttractor">getPathToAttractor</a></code>.
</p>
</td></tr>
<tr><td><code id="plotSequence_+3A_reverse">reverse</code></td>
<td>

<p>Specifies the order of the genes in the plot. By default, the first gene is placed in the first row of the plot. If <code>reverse=TRUE</code> (which was the default until <span class="pkg">BoolNet</span> version 2.0.2), the first gene in the network is placed in the bottom row of the plot. 
</p>
</td></tr>
<tr><td><code id="plotSequence_+3A_bordercolor">borderColor</code></td>
<td>

<p>Specifies the border or seprating color of states in an attractor. Defaults to <code>"black"</code>.
</p>
</td></tr>
<tr><td><code id="plotSequence_+3A_eps">eps</code></td>
<td>

<p>Specifies plotting margin for the sequence of states. Defaults to <code>0.1</code>.
</p>
</td></tr>
<tr><td><code id="plotSequence_+3A_attractor.sep.lwd">attractor.sep.lwd</code></td>
<td>

<p>Specifies the line width of the attractor separator. Defaults to <code>2</code>.
</p>
</td></tr>
<tr><td><code id="plotSequence_+3A_attractor.sep.col">attractor.sep.col</code></td>
<td>

<p>Specifies the line color of the attractor separator. Defaults to <code>"blue"</code>.
</p>
</td></tr>
<tr><td><code id="plotSequence_+3A_...">...</code></td>
<td>

<p>Further graphical parameters to be passed to <code><a href="igraph.html#topic+plot.graph">plot.igraph</a></code> if <code>mode="graph"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function comprises two different types of plots: 
</p>
<p>The &quot;table&quot; mode visualizes the gene values of the states in the sequence. The figure is a table with the genes in the rows and the successive states of the sequence in the columns. Cells of the table are (by default) red for 0/OFF values and green for 1/ON values. If <code>grouping</code> is set, the genes are rearranged according to the indices in the group, horizontal separation lines are plotted between the groups, and the group names are printed.
</p>
<p>The &quot;graph&quot; mode visualizes the transitions between different states. It creates a graph in which the vertices are the states in the sequence and the edges are state transitions among these states.
</p>
<p>The function can be called with different types of inputs: The user can specify the parameters <code>network</code>, <code>startState</code> and <code>includeAttractorStates</code>), in which case <code><a href="#topic+getPathToAttractor">getPathToAttractor</a></code> is called to obtain the sequence. Alternatively, the sequence can be supplied directly as a data frame in the <code>sequence</code> parameter.
</p>


<h3>Value</h3>

<p>If <code>mode="table"</code>, a matrix corresponding to the table is returned. The matrix has the genes in the rows and the states of the attractors in the columns. If <code>sequence</code> was supplied, this corresponds to the transposed input whose rows may be rearranged if <code>grouping</code> was set.
</p>
<p>If <code>mode="graph"</code>, an object of class <code>igraph</code> describing the graph for the sequence is returned.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sequenceToLaTeX">sequenceToLaTeX</a></code>, <code><a href="#topic+plotAttractors">plotAttractors</a></code>, <code><a href="#topic+attractorsToLaTeX">attractorsToLaTeX</a></code>, <code><a href="#topic+getPathToAttractor">getPathToAttractor</a></code>, <code><a href="#topic+getAttractorSequence">getAttractorSequence</a></code>, <code><a href="#topic+simulateSymbolicModel">simulateSymbolicModel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load example data
data(cellcycle)

# alternative 1: supply network and start state
# and plot sequence as a table
plotSequence(network=cellcycle, 
             startState=rep(1,10), 
             includeAttractorStates="all")

# alternative 2: calculate sequence in advance
sequence &lt;- getPathToAttractor(cellcycle, 
                               state=rep(1,10), 
                               includeAttractorStates="all")

# plot sequence as a graph
plotSequence(sequence=sequence, 
             mode="graph")

## End(Not run)
</code></pre>

<hr>
<h2 id='plotStateGraph'>
Visualize state transitions and attractor basins
</h2><span id='topic+plotStateGraph'></span>

<h3>Description</h3>

<p>Plots a graph containing all states visited in <code>stateGraph</code>, and optionally highlights attractors and basins of attraction. This requires the <span class="pkg">igraph</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotStateGraph(stateGraph, highlightAttractors = TRUE, 
               colorBasins = TRUE, colorSet, 
               drawLegend = TRUE, drawLabels = FALSE, 
               layout = layout.kamada.kawai,
               piecewise = FALSE,  
               basin.lty = 2, attractor.lty = 1,
               plotIt = TRUE, 
               colorsAlpha = c(colorBasinsNodeAlpha    = .3,
                               colorBasinsEdgeAlpha    = .3,
                               colorAttractorNodeAlpha = 1,
                               colorAttractorEdgeAlpha = 1),
               ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotStateGraph_+3A_stategraph">stateGraph</code></td>
<td>
<p>An object of class <code>AttractorInfo</code> or <code>SymbolicSimulation</code>, as returned by <code><a href="#topic+getAttractors">getAttractors</a></code> and <code><a href="#topic+simulateSymbolicModel">simulateSymbolicModel</a></code> respectively. As the transition table information in this structure is required, <code>getAttractors</code> must be called in synchronous mode and with <code>returnTable</code> set to TRUE. Similarly, <code>simulateSymbolicModel</code> must be called with <code>returnGraph=TRUE</code>. Alternatively, <code>stateGraph</code> can be an object of class <code>TransitionTable</code>, which can be extracted using the functions <code><a href="#topic+getTransitionTable">getTransitionTable</a></code>, <code><a href="#topic+getBasinOfAttraction">getBasinOfAttraction</a></code>, or <code><a href="#topic+getStateSummary">getStateSummary</a></code>
</p>
</td></tr> 
<tr><td><code id="plotStateGraph_+3A_highlightattractors">highlightAttractors</code></td>
<td>

<p>If this parameter is true, edges in attractors are drawn bold and with a different line type (which can be specified in <code>attractor.lty</code>). Defaults to TRUE.
</p>
</td></tr>
<tr><td><code id="plotStateGraph_+3A_colorbasins">colorBasins</code></td>
<td>

<p>If set to true, each basin of attraction is drawn in a different color. Colors can be specified in <code>colorSet</code>. Defaults to TRUE.
</p>
</td></tr>
<tr><td><code id="plotStateGraph_+3A_colorset">colorSet</code></td>
<td>

<p>An optional vector specifying the colors to be used for the different attractor basins. If not supplied, a default color set is used.
</p>
</td></tr>
<tr><td><code id="plotStateGraph_+3A_drawlegend">drawLegend</code></td>
<td>

<p>If set to true and <code>colorBasins</code> is true, a legend for the colors of the basins of attraction is drawn. Defaults to TRUE.
</p>
</td></tr>
<tr><td><code id="plotStateGraph_+3A_drawlabels">drawLabels</code></td>
<td>

<p>If set to true, the binary encodings of the states are drawn beside the vertices of the graph. As this can be confusing for large graphs, the default value is FALSE.
</p>
</td></tr>
<tr><td><code id="plotStateGraph_+3A_layout">layout</code></td>
<td>

<p>A layouting function that determines the placement of the nodes in the graph. Please refer to the <code><a href="igraph.html#topic+layout">layout</a></code> manual entry in the <span class="pkg">igraph</span> package for further details. By default, the Fruchterman-Reingold algorithm is used.
</p>
</td></tr>
<tr><td><code id="plotStateGraph_+3A_piecewise">piecewise</code></td>
<td>

<p>If set to true, a piecewise layout is used, i.e. the subgraphs corresponding to different basins of attraction are separated and layouted separately.  
</p>
</td></tr>
<tr><td><code id="plotStateGraph_+3A_basin.lty">basin.lty</code></td>
<td>

<p>The line type used for edges in a basin of attraction. Defaults to 2 (dashed).
</p>
</td></tr>
<tr><td><code id="plotStateGraph_+3A_attractor.lty">attractor.lty</code></td>
<td>

<p>If <code>highlightAttractors</code> is true, this specifies the line type for edges in an attractor. Defaults to 1 (straight).
</p>
</td></tr>
<tr><td><code id="plotStateGraph_+3A_plotit">plotIt</code></td>
<td>

<p>If this is true, a plot is generated. Otherwise, only an object of class <code>igraph</code> is returned, but no plot is drawn.
</p>
</td></tr>
<tr><td><code id="plotStateGraph_+3A_colorsalpha">colorsAlpha</code></td>
<td>

<p>These parameters apply alpha correction to the colors of basins and attractors in the following order: basin node, basin edge, attractor node, attractor edge. Defaults to a vector of length 4 with settings <code>alpha = 0.3</code> for basins and <code>alpha = 1</code> for attractors.
</p>
</td></tr>
<tr><td><code id="plotStateGraph_+3A_...">...</code></td>
<td>

<p>Further graphical parameters to be passed to <code><a href="igraph.html#topic+plot.graph">plot.igraph</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the <code><a href="igraph.html#topic+plot.graph">plot.igraph</a></code> function from the <span class="pkg">igraph</span> package. The plots are customizeable using the <code>...</code> argument. For details on possible parameters, please refer to <code><a href="igraph.html#topic+plot.common">igraph.plotting</a></code>.
</p>


<h3>Value</h3>

<p>Returns an invisible object of class <code>igraph</code> containing the state graph, including color and line attributes.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getAttractors">getAttractors</a></code>, <code><a href="#topic+simulateSymbolicModel">simulateSymbolicModel</a></code>, <code><a href="#topic+getTransitionTable">getTransitionTable</a></code>, <code><a href="#topic+getBasinOfAttraction">getBasinOfAttraction</a></code>, <code><a href="#topic+getStateSummary">getStateSummary</a></code>, <code><a href="#topic+plotNetworkWiring">plotNetworkWiring</a></code>, <code><a href="igraph.html#topic+plot.common">igraph.plotting</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load example data
data(cellcycle)

# get attractors
attractors &lt;- getAttractors(cellcycle)

# plot state graph
## Not run: 
plotStateGraph(attractors, main = "Cell cycle network", layout = layout.fruchterman.reingold)

## End(Not run)
</code></pre>

<hr>
<h2 id='print.AttractorInfo'>
Print attractor cycles
</h2><span id='topic+print.AttractorInfo'></span>

<h3>Description</h3>

<p>Specialized print method to print the attractor cycles stored in an <code>AttractorInfo</code> object. For simple or steady-state attractors, the states of the attractors are printed in binary encoding in the order they are reached. For asynchronous complex/loose attractors, the possible transitions of the states in the attractor are printed. The method can print either the full states, or only the active genes of the states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AttractorInfo'
print(x,
      activeOnly = FALSE, 
      ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.AttractorInfo_+3A_x">x</code></td>
<td>

<p>An object of class <code>AttractorInfo</code> to be printed
</p>
</td></tr>
<tr><td><code id="print.AttractorInfo_+3A_activeonly">activeOnly</code></td>
<td>

<p>If set to true, a state is represented by a list of active genes (i.e., genes which are set to 1). If set to false, a state is represented by a binary vector with one entry for each gene, specifying whether the gene is active or not. Defaults to <code>FALSE</code>. 
</p>
</td></tr>
<tr><td><code id="print.AttractorInfo_+3A_...">...</code></td>
<td>

<p>Further parameters for the <code><a href="base.html#topic+print">print</a></code> method. Currently not used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the printed object
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+print">print</a></code>, <code><a href="#topic+getAttractors">getAttractors</a></code>
</p>

<hr>
<h2 id='print.BooleanNetwork'>
Print a Boolean network
</h2><span id='topic+print.BooleanNetwork'></span>

<h3>Description</h3>

<p>A specialized method to print an object of class <code>BooleanNetwork</code>. This prints the transition functions of all genes. If genes are knocked-out or over-expressed, these genes are listed below the functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BooleanNetwork'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.BooleanNetwork_+3A_x">x</code></td>
<td>

<p>An object of class <code>BooleanNetwork</code> to be printed
</p>
</td></tr>
<tr><td><code id="print.BooleanNetwork_+3A_...">...</code></td>
<td>

<p>Further parameters for the <code><a href="base.html#topic+print">print</a></code> method. Currently not used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the printed object
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+print">print</a></code>, <code><a href="#topic+loadNetwork">loadNetwork</a></code>
</p>

<hr>
<h2 id='print.MarkovSimulation'>
Print the results of a Markov chain simulation
</h2><span id='topic+print.MarkovSimulation'></span>

<h3>Description</h3>

<p>A specialized method to print an object of class <code>MarkovSimulation</code>. This prints all states that have a non-zero probability to be reached after the number of iterations in the Markov simulation. If the simulation was run with <code>returnTable=TRUE</code>, it also prints a table of state transitions and their probabilities to be chosen in a single step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MarkovSimulation'
print(x,
      activeOnly = FALSE,
      ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.MarkovSimulation_+3A_x">x</code></td>
<td>

<p>An object of class <code>MarkovSimulation</code> to be printed
</p>
</td></tr>
<tr><td><code id="print.MarkovSimulation_+3A_activeonly">activeOnly</code></td>
<td>

<p>If set to true, a state is represented by a list of active genes (i.e., genes which are set to 1). If set to false, a state is represented by a binary vector with one entry for each gene, specifying whether the gene is active or not. Defaults to <code>FALSE</code>. 
</p>
</td></tr>
<tr><td><code id="print.MarkovSimulation_+3A_...">...</code></td>
<td>

<p>Further parameters for the <code><a href="base.html#topic+print">print</a></code> method. Currently not used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the printed object
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+print">print</a></code>, <code><a href="#topic+markovSimulation">markovSimulation</a></code>
</p>

<hr>
<h2 id='print.ProbabilisticBooleanNetwork'>
Print a probabilistic Boolean network
</h2><span id='topic+print.ProbabilisticBooleanNetwork'></span><span id='topic+print.BooleanNetworkCollection'></span>

<h3>Description</h3>

<p>A specialized method to print an object of class <code>ProbabilisticBooleanNetwork</code>. For backward compatibility, this method also prints objects of class <code>BooleanNetworkCollection</code>, which have been replaced by <code>ProbabilisticBooleanNetwork</code>.
This prints all alternative transition functions and their probabilities. If the network is the result of a reconstruction from time series measurements, it also outputs the error the functions make on the time series. If genes are knocked-out or over-expressed, these genes are listed below the functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ProbabilisticBooleanNetwork'
print(x, ...)
                               
## S3 method for class 'BooleanNetworkCollection'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.ProbabilisticBooleanNetwork_+3A_x">x</code></td>
<td>

<p>An object of class <code>ProbabilisticBooleanNetwork</code> or <code>BooleanNetworkCollection</code> to be printed
</p>
</td></tr>
<tr><td><code id="print.ProbabilisticBooleanNetwork_+3A_...">...</code></td>
<td>

<p>Further parameters for the <code><a href="base.html#topic+print">print</a></code> method. Currently not used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the printed object
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+print">print</a></code>, <code><a href="#topic+reconstructNetwork">reconstructNetwork</a></code>, <code><a href="#topic+loadNetwork">loadNetwork</a></code>
</p>

<hr>
<h2 id='print.SymbolicSimulation'>
Print simulation results
</h2><span id='topic+print.SymbolicSimulation'></span>

<h3>Description</h3>

<p>Specialized print method to print the information stored in an <code>AttractorInfo</code> object. By default, the states of the identified attractors are printed in a binary encoding. Furthermore, the state transition graph and the sequences from the start states to the attractors can be printed. The method can print either the full states, or only the active genes of the states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SymbolicSimulation'
print(x, 
                                   activeOnly = FALSE, 
                                   sequences = FALSE, 
                                   graph = FALSE, 
                                   attractors = TRUE, 
                                   ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.SymbolicSimulation_+3A_x">x</code></td>
<td>

<p>An object of class <code>SymbolicSimulation</code> to be printed.
</p>
</td></tr>
<tr><td><code id="print.SymbolicSimulation_+3A_activeonly">activeOnly</code></td>
<td>

<p>If set to true, a state is represented by a list of active genes (i.e., genes which are set to 1). If set to false, a state is represented by a binary vector with one entry for each gene, specifying whether the gene is active or not. Defaults to <code>FALSE</code>. 
</p>
</td></tr>
<tr><td><code id="print.SymbolicSimulation_+3A_sequences">sequences</code></td>
<td>

<p>If set to true and if <code><a href="#topic+simulateSymbolicModel">simulateSymbolicModel</a></code> has been started with <code>returnSequences=TRUE</code>, the sequences from the start states to the attractors are printed. Defaults to <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="print.SymbolicSimulation_+3A_graph">graph</code></td>
<td>

<p>If set to true if <code><a href="#topic+simulateSymbolicModel">simulateSymbolicModel</a></code> has been started with <code>returnGraph=TRUE</code>, the state transition table is printed. Defaults to <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="print.SymbolicSimulation_+3A_attractors">attractors</code></td>
<td>

<p>If set to true if <code><a href="#topic+simulateSymbolicModel">simulateSymbolicModel</a></code> has been started with <code>returnAttractor=TRUE</code>, the state transition table is printed. Defaults to <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="print.SymbolicSimulation_+3A_...">...</code></td>
<td>

<p>Further parameters for the <code><a href="base.html#topic+print">print</a></code> method. Currently not used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the printed object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulateSymbolicModel">simulateSymbolicModel</a></code>
</p>

<hr>
<h2 id='print.TransitionTable'>
Print a transition table
</h2><span id='topic+print.TransitionTable'></span><span id='topic+print.BooleanStateInfo'></span>

<h3>Description</h3>

<p>Specialized print method to print a transition table with the initial state in the first column, the successor state in the second column, the basin of attraction to which the state leads in the third column, and the number of transitions to the attractor in the fourth column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TransitionTable'
print(x,
      activeOnly = FALSE, 
      ...)

## S3 method for class 'BooleanStateInfo'
print(x,
      activeOnly=FALSE, 
      ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.TransitionTable_+3A_x">x</code></td>
<td>

<p>An object of class <code>TransitionTable</code> or <code>BooleanStateInfo</code> to be printed
</p>
</td></tr>
<tr><td><code id="print.TransitionTable_+3A_activeonly">activeOnly</code></td>
<td>

<p>If set to true, a state is represented by a list of active genes (i.e., genes which are set to 1). If set to false, a state is represented by a binary vector with one entry for each gene, specifying whether the gene is active or not. Defaults to <code>FALSE</code>. 
</p>
</td></tr>
<tr><td><code id="print.TransitionTable_+3A_...">...</code></td>
<td>

<p>Further parameters for the <code><a href="base.html#topic+print">print</a></code> method. Currently not used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the printed object
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+print">print</a></code>, <code><a href="#topic+getTransitionTable">getTransitionTable</a></code>, <code><a href="#topic+getBasinOfAttraction">getBasinOfAttraction</a></code>, <code><a href="#topic+getStateSummary">getStateSummary</a></code>
</p>

<hr>
<h2 id='reconstructNetwork'>
Reconstruct a Boolean network from time series of measurements
</h2><span id='topic+reconstructNetwork'></span>

<h3>Description</h3>

<p>Reconstructs a Boolean network from a set of time series or from a transition table using the best-fit extension algorithm or the REVEAL algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reconstructNetwork(measurements, 
                   method = c("bestfit", "reveal"), 
                   maxK = 5, 
                   requiredDependencies = NULL, 
                   excludedDependencies = NULL, 
                   perturbations=NULL,
                   readableFunctions=FALSE, 
                   allSolutions=FALSE, 
                   returnPBN=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reconstructNetwork_+3A_measurements">measurements</code></td>
<td>

<p>This can either be an object of class <code>TransitionTable</code> as returned by <code><a href="#topic+getTransitionTable">getTransitionTable</a></code>, or a set of time series of measurements. In this case, <code>measurements</code> must be a list of matrices, each corresponding to one time series. Each row of these matrices contains measurements for one gene on a time line, i. e. column <code>i+1</code> contains the successor states of column <code>i</code>. The genes must be the same for all matrices in the list. Real-valued time series can be binarized using <code><a href="#topic+binarizeTimeSeries">binarizeTimeSeries</a></code>.
</p>
</td></tr>
<tr><td><code id="reconstructNetwork_+3A_method">method</code></td>
<td>

<p>This specifies the reconstruction algorithm to be used. If set to &quot;bestfit&quot;, Laehdesmaeki's Best-Fit Extension algorithm is employed. This algorithm is an improvement of the algorithm by Akutsu et al. with a lower runtime complexity. It determines the functions with a minimal error for each gene. If set to &quot;reveal&quot;, Liang's REVEAL algorithm is used. This algorithm searches for relevant input genes using the mutual information between the input genes and the output gene. 
</p>
</td></tr>
<tr><td><code id="reconstructNetwork_+3A_maxk">maxK</code></td>
<td>

<p>The maximum number of input genes for one gene to be tested. Defaults to 5.
</p>
</td></tr>
<tr><td><code id="reconstructNetwork_+3A_requireddependencies">requiredDependencies</code></td>
<td>
<p>An optional specification of known dependencies that must be included in reconstructed networks. This is a named list containing a vector of gene names (regulators) for each target.</p>
</td></tr>
<tr><td><code id="reconstructNetwork_+3A_excludeddependencies">excludedDependencies</code></td>
<td>
<p>Analogous to <code>requiredDependencies</code>, this is an optional specification of dependencies that must not be included in reconstructed networks. This is a named list containing a vector of gene names (prohibited regulators) for each target.</p>
</td></tr>
<tr><td><code id="reconstructNetwork_+3A_perturbations">perturbations</code></td>
<td>
<p>If <code>measurements</code> contains data obtained from perturbation experiments (i.e. different targeted knock-outs and overexpressions), this optional parameter is a matrix with one column for each entry in <code>measurements</code> and a row for each gene. A matrix entry is 0 for a knock-out of the corresponding gene in the corresponding time series, 1 for overexpression, and NA or -1 for no perturbation. If <code>measurements</code> has an element <code>perturbations</code> and this argument is not specified, the element of <code>measurements</code> is taken. 
</p>
</td></tr>  
<tr><td><code id="reconstructNetwork_+3A_readablefunctions">readableFunctions</code></td>
<td>

<p>If this is true, readable DNF representations of the truth tables of the functions are generated. These DNF are displayed when the network is printed. The DNF representations are not minimized and can thus be very long. If set to FALSE, the truth table result column is displayed.
</p>
</td></tr>
<tr><td><code id="reconstructNetwork_+3A_allsolutions">allSolutions</code></td>
<td>

<p>If this is true, all solutions with the minimum error and up to <code>maxK</code> inputs are returned. By default, <code>allSolutions=FALSE</code>, which means that only the solutions with both minimum error and minimum <code>k</code> are returned.
</p>
</td></tr>
<tr><td><code id="reconstructNetwork_+3A_returnpbn">returnPBN</code></td>
<td>
<p>Specifies the way unknown values in the truth tables of the transition functions (&quot;don't care&quot; values) are processed. If <code>returnPBN=TRUE</code>, all possible functions are enumerated recursively, and an object of class <code>ProbabilisticBooleanNetwork</code> is returned. This can consume a high amount of memory and computation time. If <code>returnPBN=FALSE</code>, the transition functions may contain &quot;don't care&quot; (*) values, and an object of class <code>BooleanNetworkCollection</code> is returned. <code>returnPBN=TRUE</code> corresponds to the behaviour prior to version 2.0. The default value is <code>returnPBN=FALSE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both algorithms iterate over all possible input combinations. While Best-Fit Extension is capable of returning functions that do not perfectly explain the measurements (for example, if there are inconsistent measurements or if <code>maxK</code> was specified too small), REVEAL only finds functions that explain all measurements. For more information, please refer to the cited publications.
</p>


<h3>Value</h3>

<p>If <code>returnPBN=TRUE</code>, the function returns an object of class <code>ProbabilisticBooleanNetwork</code>, with each alternative function of a gene having the same probability. The structure is described in detail in <code><a href="#topic+loadNetwork">loadNetwork</a></code>. In addition to the standard components, each alternative transition function has a component <code>error</code> which stores the error of the function on the input time series data.
If <code>returnPBN=FALSE</code>, the function returns an object of class <code>BooleanNetworkCollection</code> that has essentially the same structure as <code>ProbabilisticBooleanNetwork</code>, but does not store probabilities and keeps &quot;don't care&quot; values in the functions. Due to the &quot;don't care&quot; (*) values, this collection cannot be simulated directly. However, a specific Boolean network of class <code>BooleanNetwork</code> can be extracted from both <code>BooleanNetworkCollection</code> and <code>ProbabilisticBooleanNetwork</code> structures using <code><a href="#topic+chooseNetwork">chooseNetwork</a></code>.
</p>


<h3>References</h3>

<p>H. Laehdesmaeki, I. Shmulevich and O. Yli-Harja (2003), On Learning Gene-Regulatory Networks Under the Boolean Network Model. Machine Learning 52:147&ndash;167.
</p>
<p>T. Akutsu, S. Miyano and S. Kuhara (2000). Inferring qualitative relations in genetic networks and metabolic pathways. Bioinformatics 16(8):727&ndash;734.
</p>
<p>S. Liang, S. Fuhrman and R. Somogyi (1998), REVEAL, a general reverse engineering algorithm for inference of genetic network architectures. Pacific Symposium on Biocomputing 3:18&ndash;29.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generateTimeSeries">generateTimeSeries</a></code>, <code><a href="#topic+binarizeTimeSeries">binarizeTimeSeries</a></code>, <code><a href="#topic+chooseNetwork">chooseNetwork</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load example data
data(yeastTimeSeries)

# perform binarization with k-means
bin &lt;- binarizeTimeSeries(yeastTimeSeries)

# reconstruct networks from binarized measurements
net &lt;- reconstructNetwork(bin$binarizedMeasurements, method="bestfit", maxK=3, returnPBN=TRUE)

# print reconstructed net
print(net)

# plot reconstructed net
plotNetworkWiring(net)

## End(Not run)
</code></pre>

<hr>
<h2 id='saveNetwork'>
Save a network
</h2><span id='topic+saveNetwork'></span>

<h3>Description</h3>

<p>Saves synchronous, asynchronous, probabilistic and temporal networks in the <span class="pkg">BoolNet</span> network file format .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveNetwork(network, 
            file, 
            generateDNFs = FALSE,
            saveFixed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saveNetwork_+3A_network">network</code></td>
<td>

<p>An object of class <code>BooleanNetwork</code> or <code>SymbolicBooleanNetwork</code> to be exported
</p>
</td></tr>
<tr><td><code id="saveNetwork_+3A_file">file</code></td>
<td>

<p>The name of the network file to be created
</p>
</td></tr>
<tr><td><code id="saveNetwork_+3A_generatednfs">generateDNFs</code></td>
<td>

<p>If <code>network</code> is a <code>BooleanNetwork</code> object, this parameter specifies whether formulae in Disjunctive Normal Form are exported instead of the expressions that describe the transition functions. If set to FALSE, the original expressions are exported. If set to &quot;canonical&quot;, a canonical Disjunctive Normal Form is generated from each truth table. If set to &quot;short&quot;, the canonical DNF is minimized by joining terms (which can be time-consuming for functions with many inputs). If set to TRUE, a short DNF is generated for functions with up to 12 inputs, and a canonical DNF is generated for functions with more than 12 inputs.
For objects of class <code>SymbolicBooleanNetwork</code>, this parameter is ignored.
</p>
</td></tr>
<tr><td><code id="saveNetwork_+3A_savefixed">saveFixed</code></td>
<td>

<p>If set to TRUE, knock-outs and overexpression of genes override their transition functions. That is, if a gene in the network is fixed to 0 or 1, this value is saved, regardless of the transition function. If set to FALSE, the transition function is saved. Defaults to TRUE.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The network is saved in the <span class="pkg">BoolNet</span> file format (see <code><a href="#topic+loadNetwork">loadNetwork</a></code> for details).
</p>
<p>If the expressions in the transition functions cannot be parsed or <code>generateDNFs</code> is true, a DNF representation of the transition functions is generated.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loadNetwork">loadNetwork</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load the cell cycle network
data(cellcycle)

# save it to a file
saveNetwork(cellcycle, file="cellcycle.txt")

# reload the model
print(loadNetwork("cellcycle.txt"))

## End(Not run)
</code></pre>

<hr>
<h2 id='sequenceToLaTeX'>
Create LaTeX table of state sequences
</h2><span id='topic+sequenceToLaTeX'></span><span id='topic+sequenceToLaTeX.BooleanNetwork'></span><span id='topic+sequenceToLaTeX.data.frame'></span>

<h3>Description</h3>

<p>Exports tables of state sequences (corresponding to the plot generated by <code><a href="#topic+plotSequence">plotSequence</a></code> with <code>mode="table"</code>) to a LaTeX document.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sequenceToLaTeX(network, 
                startState,
                includeAttractorStates = c("all","first","none"),
                sequence,
                title = "",
                grouping = list(), 
                plotFixed = TRUE,
                onColor="[gray]{0.9}",
                offColor="[gray]{0.6}", 
                highlightAttractor=TRUE,
                reverse = FALSE,                
                file="sequence.tex")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sequenceToLaTeX_+3A_network">network</code></td>
<td>

<p>An object of class <code>BooleanNetwork</code> or <code>SymbolicBooleanNetwork</code> for which a sequence of state transitions is calculated
</p>
</td></tr>
<tr><td><code id="sequenceToLaTeX_+3A_startstate">startState</code></td>
<td>

<p>The start state of the sequence
</p>
</td></tr>
<tr><td><code id="sequenceToLaTeX_+3A_includeattractorstates">includeAttractorStates</code></td>
<td>

<p>Specifies whether the actual attractor states are included in the table or not (see also <code><a href="#topic+getPathToAttractor">getPathToAttractor</a></code>). If <code>includeAttractorStates = "all"</code> (which is the default behaviour), the sequence ends when the attractor was traversed once. If <code>includeAttractorStates = "first"</code>, only the first state of attractor is added to the sequence. If includeAttractorStates = &quot;none&quot;, the sequence ends with the last non-attractor state. 
</p>
</td></tr>
<tr><td><code id="sequenceToLaTeX_+3A_sequence">sequence</code></td>
<td>

<p>The alternative call to <code>sequenceToLaTeX</code> requires the specification of the sequence itself instead of the network and the start state. The sequence must be provided as a data frame with the genes in the columns and the successive states in the rows. For example, sequences can be obtained using <code><a href="#topic+getPathToAttractor">getPathToAttractor</a></code> or <code><a href="#topic+getAttractorSequence">getAttractorSequence</a></code> (however, the specialized function <code><a href="#topic+attractorsToLaTeX">attractorsToLaTeX</a></code> exists for attractors).
</p>
</td></tr>
<tr><td><code id="sequenceToLaTeX_+3A_title">title</code></td>
<td>

<p>An optional title for the table
</p>
</td></tr>
<tr><td><code id="sequenceToLaTeX_+3A_plotfixed">plotFixed</code></td>
<td>
<p>If this is true, genes with fixed values are included in the plot. Otherwise, these genes are not shown.
</p>
</td></tr>
<tr><td><code id="sequenceToLaTeX_+3A_grouping">grouping</code></td>
<td>
<p>This optional parameter specifies a structure to form groups of genes in the table. This is a list with the following elements: 
</p>

<dl>
<dt>class</dt><dd><p>A vector of names for the groups. These names will be printed in the region belonging to the group in the tabke.</p>
</dd>  	
<dt>index</dt><dd><p>A list with the same length as <code>class</code>. Each element is a vector of gene names or gene indices belonging to the group.</p>
</dd></dl>

</td></tr>
<tr><td><code id="sequenceToLaTeX_+3A_oncolor">onColor</code></td>
<td>

<p>An optional color value for the 1/ON values in the table. Defaults to dark grey.
</p>
</td></tr>
<tr><td><code id="sequenceToLaTeX_+3A_offcolor">offColor</code></td>
<td>

<p>An optional color value for the 0/OFF values in the table. Defaults to light grey.	
</p>
</td></tr>
<tr><td><code id="sequenceToLaTeX_+3A_highlightattractor">highlightAttractor</code></td>
<td>

<p>If set to true, the attractor states are highlighted in the plot by drawing a line at the begin of the attractor and labeling the states correspondingly. Information on the attractor must be supplied in the attribute <code>attractor</code> of the sequence, which is a vector of indices of the states that belong to the attractor. This attribute is usually present if the sequence was obtained using <code><a href="#topic+getPathToAttractor">getPathToAttractor</a></code>.
</p>
</td></tr>
<tr><td><code id="sequenceToLaTeX_+3A_reverse">reverse</code></td>
<td>

<p>Specifies the order of the genes in the plot. By default, the first gene is placed in the first row of the table. If <code>reverse=TRUE</code>, the first gene in the network is placed in the bottom row of the table. 
</p>
</td></tr>
<tr><td><code id="sequenceToLaTeX_+3A_file">file</code></td>
<td>

<p>The file to which the LaTeX document is written. Defaults to &quot;sequence.tex&quot;.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a LaTeX table that visualizes a sequence of states in a synchronous network. 
The output file does not contain a document header and requires the inclusion of the packages <code>tabularx</code> and <code>colortbl</code>. The tables have the genes in the rows and the successive states of the sequence in the columns. If not specified otherwise, cells of the table are light grey for 0/OFF values and dark grey for 1/ON values. If <code>grouping</code> is set, the genes are rearranged according to the indices in the group, horizontal separation lines are plotted between the groups, and the group names are printed.
</p>
<p>The function can be called with different types of inputs: The user can specify the parameters <code>network</code>, <code>startState</code> and <code>includeAttractorStates</code>), in which case <code><a href="#topic+getPathToAttractor">getPathToAttractor</a></code> is called to obtain the sequence. Alternatively, the sequence can be supplied directly as a data frame in the <code>sequence</code> parameter.
</p>


<h3>Value</h3>

<p>Returns a matrix corresponding to the table. The matrix has the genes in the rows and the states of the attractors in the columns. If <code>sequence</code> was supplied, this corresponds to the transposed input whose rows may be rearranged if <code>grouping</code> was set.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+attractorsToLaTeX">attractorsToLaTeX</a></code>, <code><a href="#topic+plotSequence">plotSequence</a></code>, <code><a href="#topic+plotAttractors">plotAttractors</a></code>, <code><a href="#topic+getPathToAttractor">getPathToAttractor</a></code>, <code><a href="#topic+getAttractorSequence">getAttractorSequence</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load example data
data(cellcycle)

# alternative 1: supply network and start state
# and export sequence to LaTeX
sequenceToLaTeX(network=cellcycle, 
                startState=rep(1,10), 
                includeAttractorStates="all",
                file="sequence.txt")

# alternative 2: calculate sequence in advance
sequence &lt;- getPathToAttractor(cellcycle, 
                               state=rep(1,10), 
                               includeAttractorStates="all")

sequenceToLaTeX(sequence=sequence, 
                file="sequence.txt")

## End(Not run)
</code></pre>

<hr>
<h2 id='simplifyNetwork'>
Simplify the functions of a synchronous, asynchronous, or probabilistic Boolean network
</h2><span id='topic+simplifyNetwork'></span>

<h3>Description</h3>

<p>Eliminates irrelevant variables from the inputs of the gene transition functions. This can be useful if the network was generated randomly via <code><a href="#topic+generateRandomNKNetwork">generateRandomNKNetwork</a></code> or if it was perturbed via <code><a href="#topic+perturbNetwork">perturbNetwork</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simplifyNetwork(network, readableFunctions = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simplifyNetwork_+3A_network">network</code></td>
<td>

<p>A network structure of class <code>BooleanNetwork</code>, <code>ProbabilisticBooleanNetwork</code> or <code>BooleanNetworkCollection</code>. These networks can be read from files by <code><a href="#topic+loadNetwork">loadNetwork</a></code>, generated by <code><a href="#topic+generateRandomNKNetwork">generateRandomNKNetwork</a></code>, or reconstructed by <code><a href="#topic+reconstructNetwork">reconstructNetwork</a></code>.
</p>
</td></tr>
<tr><td><code id="simplifyNetwork_+3A_readablefunctions">readableFunctions</code></td>
<td>

<p>This parameter specifies if readable DNF representations of the transition function truth tables are generated and displayed when the network is printed. If set to FALSE, the truth table result column is displayed. If set to &quot;canonical&quot;, a canonical Disjunctive Normal Form is generated from each truth table. If set to &quot;short&quot;, the canonical DNF is minimized by joining terms (which can be time-consuming for functions with many inputs). If set to TRUE, a short DNF is generated for functions with up to 12 inputs, and a canonical DNF is generated for functions with more than 12 inputs.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function checks whether the output of a gene transition function is independent from the states of any of the input variables. If this is the case, these input variables are dropped, and the transition function is shortened accordingly. 
</p>
<p>In non-probabilistic Boolean networks (class <code>BooleanNetwork</code>), constant genes are automatically fixed (e.g. knocked-out or over-expressed). This means that they are always set to the constant value, and states with the complementary value are not considered in transition tables etc. If you would like to change this behaviour, use <code><a href="#topic+fixGenes">fixGenes</a></code> to reset the fixing.
</p>


<h3>Value</h3>

<p>The simplified network of class <code>BooleanNetwork</code>, <code>ProbabilisticBooleanNetwork</code> or <code>BooleanNetworkCollection</code>. These classes are described in more detail in <code><a href="#topic+loadNetwork">loadNetwork</a></code> and  <code><a href="#topic+reconstructNetwork">reconstructNetwork</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loadNetwork">loadNetwork</a></code>,<code><a href="#topic+generateRandomNKNetwork">generateRandomNKNetwork</a></code>, <code><a href="#topic+perturbNetwork">perturbNetwork</a></code>, <code><a href="#topic+reconstructNetwork">reconstructNetwork</a></code>, <code><a href="#topic+fixGenes">fixGenes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load example data
data(cellcycle)

# perturb the network
perturbedNet &lt;- perturbNetwork(cellcycle, perturb="functions", method="shuffle")
print(perturbedNet$interactions)

# simplify the network
perturbedNet &lt;- simplifyNetwork(perturbedNet)
print(perturbedNet$interactions)

## End(Not run)
</code></pre>

<hr>
<h2 id='simulateSymbolicModel'>
Simulate a symbolic Boolean network
</h2><span id='topic+simulateSymbolicModel'></span>

<h3>Description</h3>

<p>This function simulates Boolean networks in a symbolic representation, possibly with additional temporal qualifiers. The function can identify attractors, determine the state transition graph, and generate sequences of successive states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateSymbolicModel(network, 
              method = c("exhaustive", 
                         "random", 
                         "chosen", 
                         "sat.exhaustive", 
                         "sat.restricted"), 
              startStates = NULL,               
              returnSequences = 
                (!(match.arg(method) %in% 
              	  c("sat.exhaustive", "sat.restricted"))), 
              returnGraph = 
                  (!(match.arg(method) %in% 
              	    c("sat.exhaustive", "sat.restricted"))), 
              returnAttractors = TRUE, 
              maxTransitions = Inf,
              maxAttractorLength = Inf,
              canonical = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulateSymbolicModel_+3A_network">network</code></td>
<td>

<p>A network structure of class <code>SymbolicBooleanNetwork</code>. These networks can be read from files by <code><a href="#topic+loadNetwork">loadNetwork</a></code>, <code><a href="#topic+loadBioTapestry">loadBioTapestry</a></code> or <code><a href="#topic+loadSBML">loadSBML</a></code> with the <code>symbolic=TRUE</code> flag.
</p>
</td></tr>
<tr><td><code id="simulateSymbolicModel_+3A_startstates">startStates</code></td>
<td>

<p>An optional parameter specifying the start states. If this is an integer value, it denotes the number of random start states to generate. Otherwise, it has to be a list of states. The list elements must either be vectors with one value for each gene in the network, or matrices with the genes in the columns and multiple predecessor states in the rows. These predecessor states may be evaluated if temporal predicates in the network have a time delay of more than one. If the number of supplied predecessor states is smaller than the maximum time delay in the network, genes are assumed to have had the same value as in the first supplied state prior to this state. In particular, if only a single state is supplied, it is assumed that the network always resided in this state prior to starting the simulation.
</p>
</td></tr>
<tr><td><code id="simulateSymbolicModel_+3A_method">method</code></td>
<td>

<p>The simulation method to be used (see details). If <code>method</code> is not specified, the desired method is inferred from the type of <code>startStates</code>.
</p>
</td></tr>
<tr><td><code id="simulateSymbolicModel_+3A_returnsequences">returnSequences</code></td>
<td>

<p>If set to true (and no SAT-based method is chosen), the return value has an element <code>sequences</code> specifying the sequences of states to the attractor.
</p>
</td></tr>
<tr><td><code id="simulateSymbolicModel_+3A_returngraph">returnGraph</code></td>
<td>

<p>If set to true (and no SAT-based method is chosen), the return value has an element <code>graph</code> specifying the state transition graph of the network.
</p>
</td></tr>
<tr><td><code id="simulateSymbolicModel_+3A_returnattractors">returnAttractors</code></td>
<td>

<p>If set to true, the return value has an element <code>attractors</code> containing a list of identified attractors.
</p>
</td></tr>
<tr><td><code id="simulateSymbolicModel_+3A_maxtransitions">maxTransitions</code></td>
<td>

<p>The maximum number of state transitions to be performed for each start state (defaults to <code>Inf</code>).
</p>
</td></tr>
<tr><td><code id="simulateSymbolicModel_+3A_maxattractorlength">maxAttractorLength</code></td>
<td>
<p>If <code>method="sat.restricted"</code>, this required parameter specifies the maximum size of attractors (i.e. the number of states in the loop) to be searched. For <code>method="sat.exhaustive"</code>, this parameter is optional and specifies the maximum attractor length for the initial length-restricted search phase that is performed to speed up the subsequent exhaustive search. In this case, changing this value might bring performance benefits, but does not change the results.</p>
</td></tr>
<tr><td><code id="simulateSymbolicModel_+3A_canonical">canonical</code></td>
<td>

<p>If set to true and <code>returnAttractors=TRUE</code>, the states in the attractors are rearranged such that the state whose binary encoding
makes up the smallest number is the first element of the vector. This ensures that attractors determined in runs with different start states are comparable, as the cycles may have been entered at different states.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Similarly to <code><a href="#topic+getAttractors">getAttractors</a></code>, the symbolic simulator supports different simulation modes which can be specified in the <code>method</code> parameter:
</p>

<ul>
<li><p>Exhaustive search If <code>method="exhaustive"</code>, all possible states in the network are used as start states. If the network has time delays greater than one (temporal network), this means that exhaustive search does not only cover all 2^n possible states for a network with n genes, but also all possible state histories of those genes for which longer delays are required.
</p>
</li>
<li><p>Heuristic search For <code>method="random"</code> or <code>method="chosen"</code>, a subset of states is used as start states for the simulation.
</p>
<p>If <code>method="random"</code>, <code>startStates</code> is interpreted as an integer value specifying the number of states to be generated randomly. The algorithm is then initialized with these random start states.
</p>
<p>If <code>method="chosen"</code>, <code>startStates</code> is interpreted as a list of binary vectors, each specifying one start state (see also parameter description above for details). 
</p>
</li>
<li><p>SAT-based attractor search  	
If <code>method</code> is &quot;sat.exhaustive&quot; or &quot;sat.restricted&quot;, the simulator transforms the network into a satisfiability problem and solves it using Armin Biere's PicoSAT solver (see also <code><a href="#topic+getAttractors">getAttractors</a></code> for more details). If <code>method="sat.restricted"</code>, only attractors comprising up to <code>maxAttractorLength</code> states are identified. Otherwise, the algorithm by Dubrova and Teslenko is applied to identify all attractors. As the SAT-based approaches identify attractors directly, no state sequences and no transition graph are returned.
</p>
</li></ul>



<h3>Value</h3>

<p>Returns a list of class <code>SymbolicSimulation</code> containing the simulation results:
</p>
<p>If <code>returnSequences</code> is true and no SAT-based method was chosen, the list contains an element <code>sequences</code> consisting of a list of data frames, each representing the state transitions performed from one start state (denoted as time step 0) to the attractor. Here, the columns correspond to the genes in the network, and the rows correspond to the states. Apart from the immediate start state, the sequences may also contain the supplied or assumed predecessor states of the start state (marked by a negative time step t) if the network contains time delays greater than one. 
</p>
<p>If <code>returnGraph</code> is true and no SAT-based method was chosen, the list contains an element <code>graph</code> of class <code>TransitionTable</code>. Each row of the table corresponds to one state transition from an initial state to a successor state, i.e. an edge in the state transition graph.
</p>
<p>If <code>returnAttractors</code> is true, the list contains an element <code>attractors</code>, which itself is a list of data frames. Each data frame represents one unique attractor, where each column corresponds to a gene, and each row corresponds to one state in the attractor.
</p>
<p>If both <code>returnSequences</code> and <code>returnAttractors</code> are true, there is an additional element <code>attractorAssignment</code>. This integer vector specifies the indices of the attractors to which the sequences lead.
</p>
<p>The structure supports pretty printing using the <code><a href="base.html#topic+print">print</a></code> method.</p>


<h3>References</h3>

<p>E. Dubrova, M. Teslenko (2011), A SAT-based algorithm for finding attractors in synchronous Boolean networks. IEEE/ACM Transactions on Computational Biology and Bioinformatics 8(5):1393&ndash;1399.
</p>
<p>A. Biere (2008), PicoSAT Essentials. Journal on Satisfiability, Boolean Modeling and Computation 4:75-97.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loadNetwork">loadNetwork</a></code>, <code><a href="#topic+loadBioTapestry">loadBioTapestry</a></code>, <code><a href="#topic+loadSBML">loadSBML</a></code>, <code><a href="#topic+getAttractors">getAttractors</a></code>, <code><a href="#topic+plotAttractors">plotAttractors</a></code>, <code><a href="#topic+attractorsToLaTeX">attractorsToLaTeX</a></code>, <code><a href="#topic+getTransitionTable">getTransitionTable</a></code>, <code><a href="#topic+getBasinOfAttraction">getBasinOfAttraction</a></code>, <code><a href="#topic+getAttractorSequence">getAttractorSequence</a></code>, <code><a href="#topic+getStateSummary">getStateSummary</a></code>, <code><a href="#topic+getPathToAttractor">getPathToAttractor</a></code>, <code><a href="#topic+fixGenes">fixGenes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(igf)

# exhaustive state space simulation
sim &lt;- simulateSymbolicModel(igf)
plotAttractors(sim)

# exhaustive attractor search using SAT solver
sim &lt;- simulateSymbolicModel(igf, method="sat.exhaustive")
plotAttractors(sim)

## End(Not run)
</code></pre>

<hr>
<h2 id='stateTransition'>
Perform a transition to the next state
</h2><span id='topic+stateTransition'></span>

<h3>Description</h3>

<p>Calculates the next state in a supplied network for a given current state
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stateTransition(network,
                state,
                type = c("synchronous","asynchronous","probabilistic"),
                geneProbabilities, 
                chosenGene, 
                chosenFunctions,
                timeStep = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stateTransition_+3A_network">network</code></td>
<td>

<p>A network structure of class <code>BooleanNetwork</code>, <code>SymbolicBooleanNetwork</code> or <code>ProbabilisticBooleanNetwork</code>. These networks can be read from files by <code><a href="#topic+loadNetwork">loadNetwork</a></code>, generated by <code><a href="#topic+generateRandomNKNetwork">generateRandomNKNetwork</a></code>, or reconstructed by <code><a href="#topic+reconstructNetwork">reconstructNetwork</a></code>.
</p>
</td></tr>
<tr><td><code id="stateTransition_+3A_state">state</code></td>
<td>

<p>The current state of the network, encoded as a vector with one 0-1 element for each gene. If <code>network</code> is of class <code>SymbolicBooleanNetwork</code> and makes use of more than one predecessor state, this can also be a matrix with the genes in the columns and multiple predecessor states in the rows.
</p>
</td></tr>
<tr><td><code id="stateTransition_+3A_type">type</code></td>
<td>
<p>The type of transition to be performed. 
</p>
<p>If set to &quot;synchronous&quot;, all genes are updated using the corresponding transition functions. 
</p>
<p>If set to &quot;asynchronous&quot;, only one gene is updated. This gene is either chosen randomly or supplied in parameter <code>chosenGene</code>. 
</p>
<p>If set to &quot;probabilistic&quot;, one transition function is chosen for each gene, and the genes are updated synchronously. The functions are either chosen randomly depending on their probabilities, or they are supplied in parameter <code>chosenFunctions</code>.
</p>
<p>Default is &quot;synchronous&quot; for objects of class <code>BooleanNetwork</code> and <code>SymbolicBooleanNetwork</code>, and &quot;probabilistic&quot; for objects of class <code>ProbabilisticBooleanNetwork</code>.</p>
</td></tr>
<tr><td><code id="stateTransition_+3A_geneprobabilities">geneProbabilities</code></td>
<td>
<p>An optional vector of probabilities for the genes if <code>type="asynchronous"</code>. By default, each gene has the same probability to be chosen for the next state transition. These probabilities can be modified by supplying a vector of probabilities for the genes which sums up to one.</p>
</td></tr>
<tr><td><code id="stateTransition_+3A_chosengene">chosenGene</code></td>
<td>
<p>If <code>type="asynchronous"</code> and this parameter is supplied, no random update is performed. Instead, the gene with the supplied name or index is chosen for the next transition.</p>
</td></tr>
<tr><td><code id="stateTransition_+3A_chosenfunctions">chosenFunctions</code></td>
<td>
<p>If <code>type="probabilistic"</code>, this parameter can contain a set of function indices for each gene. In this case, transition functions are not chosen randomly, but the provided functions are used in the state transition.</p>
</td></tr>
<tr><td><code id="stateTransition_+3A_timestep">timeStep</code></td>
<td>
<p>An optional parameter that specifies the current time step associated with <code>state</code>. This is only relevant for networks of class <code>SymbolicBooleanNetwork</code> that make use of time-dependent predicates (<code>timelt, timeis, timegt</code>). Otherwise, this parameter is ignored.  
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The subsequent state of the network, encoded as a vector with one 0-1 element for each gene.</p>


<h3>See Also</h3>

<p><code><a href="#topic+loadNetwork">loadNetwork</a></code>, <code><a href="#topic+generateRandomNKNetwork">generateRandomNKNetwork</a></code>, <code><a href="#topic+generateState">generateState</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load example network
data(cellcycle)

# calculate a synchronous state transition
print(stateTransition(cellcycle, c(1,1,1,1,1,1,1,1,1,1)))

# calculate an asynchronous state transition of gene CycA
print(stateTransition(cellcycle, c(1,1,1,1,1,1,1,1,1,1),
                      type="asynchronous", chosenGene="CycA"))
                      
# load probabilistic network
data(examplePBN)

# perform a probabilistic state transition
print(stateTransition(examplePBN, c(0,1,1),
                      type="probabilistic"))       

## End(Not run)
</code></pre>

<hr>
<h2 id='symbolicToTruthTable'>
Convert a symbolic network into a truth table representation
</h2><span id='topic+symbolicToTruthTable'></span>

<h3>Description</h3>

<p>Converts an object of class <code>SymbolicBooleanNetwork</code> into an object of class <code>BooleanNetwork</code> by generating truth tables from the symbolic expression trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symbolicToTruthTable(network)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="symbolicToTruthTable_+3A_network">network</code></td>
<td>

<p>An object of class <code>SymbolicBooleanNetwork</code> to be converted.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The symbolic network <code>network</code> must not contain temporal operators, as these are not compatible with the truth table representation in <code>BooleanNetwork</code> objects.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>BooleanNetwork</code>, as described in <code><a href="#topic+loadNetwork">loadNetwork</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+truthTableToSymbolic">truthTableToSymbolic</a></code>, <code><a href="#topic+loadNetwork">loadNetwork</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Convert a truth table representation into a 
# symbolic representation and back
data(cellcycle)

symbolicNet &lt;- truthTableToSymbolic(cellcycle)
print(symbolicNet)

ttNet &lt;- symbolicToTruthTable(symbolicNet)
print(cellcycle)

## End(Not run)
</code></pre>

<hr>
<h2 id='testNetworkProperties'>
Test properties of networks by comparing them to random networks
</h2><span id='topic+testNetworkProperties'></span><span id='topic+testIndegree'></span><span id='topic+testAttractorRobustness'></span><span id='topic+testTransitionRobustness'></span>

<h3>Description</h3>

<p>This is a general function designed to determine unique properties of biological networks by comparing them to a set of randomly generated networks with similar structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testNetworkProperties(network, 
                      numRandomNets = 100, 
                      testFunction = "testIndegree", 
                      testFunctionParams = list(), 
                      accumulation = c("characteristic", "kullback_leibler"), 
                      alternative=c("greater","less"),
                      sign.level = 0.05, 
                      drawSignificanceLevel = TRUE, 
                      klBins, 
                      klMinVal = 1e-05, 
                      linkage = c("uniform", "lattice"), 
                      functionGeneration = c("uniform", "biased"), 
                      validationFunction, failureIterations=10000,
                      simplify = FALSE, 
                      noIrrelevantGenes = TRUE, 
                      d_lattice = 1, 
                      zeroBias = 0.5, 
                      title = "", 
                      xlab, 
                      xlim, 
                      breaks = 30, 
                      ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testNetworkProperties_+3A_network">network</code></td>
<td>

<p>A network structure of class <code>BooleanNetwork</code> or <code>SymbolicBooleanNetwork</code>
</p>
</td></tr>
<tr><td><code id="testNetworkProperties_+3A_numrandomnets">numRandomNets</code></td>
<td>

<p>The number of random networks to generate for comparison
</p>
</td></tr>
<tr><td><code id="testNetworkProperties_+3A_testfunction">testFunction</code></td>
<td>

<p>The name of a function that calculates characteristic values that describe properties of the network. There are two built-in functions: &quot;testIndegree&quot; calculates the in-degrees of states in the network, and &quot;testAttractorRobustness&quot; counts the occurrences of attractors in perturbed copies. It is possible to supply user-defined functions here. See Details.
</p>
</td></tr>
<tr><td><code id="testNetworkProperties_+3A_testfunctionparams">testFunctionParams</code></td>
<td>

<p>A list of parameters to <code>testFunction</code>. The elements of the list depend on the chosen function.
</p>
</td></tr>
<tr><td><code id="testNetworkProperties_+3A_accumulation">accumulation</code></td>
<td>

<p>If &quot;characteristic&quot; is chosen, the test function is required to return a single value that describes the network. In this case, a histogram of these values in random networks is plotted, and the value of the original network is inserted as a vertical line.
</p>
<p>If &quot;kullback_leibler&quot; is chosen, the test function can return a vector of values which is regarded as a sample from a probability distribution. In this case, the Kullback-Leibler distances of the distributions from the original network and each of the random networks are calculated and plotted in a histogram. The Kullback-Leibler distance measures the difference between two probability distributions. In this case, the resulting histogram shows the distribution of differences between the original network and randomly generated networks.
</p>
</td></tr>
<tr><td><code id="testNetworkProperties_+3A_alternative">alternative</code></td>
<td>

<p>If <code>accumulation="characteristic"</code>, this specifies whether the characteristic value is expected to be greater or less than the random results under the alternative hypothesis.  
</p>
</td></tr>  
<tr><td><code id="testNetworkProperties_+3A_sign.level">sign.level</code></td>
<td>

<p>If <code>accumulation="characteristic"</code>, this specifies a significance level for a computer-intensive test.
</p>
<p>If <code>alternative="greater"</code>, the test is significant if the characteristic value is greater than at least <code>(1-sign.level)*100</code>% of the characteristic values of the random networks. 
</p>
<p>If <code>alternative="less"</code>, the test is significant if the characteristic value is less than at most <code>sign.level*100</code>% of the characteristic values of the random networks.
</p>
</td></tr>
<tr><td><code id="testNetworkProperties_+3A_drawsignificancelevel">drawSignificanceLevel</code></td>
<td>

<p>If <code>accumulation="characteristic"</code> and this is true, a vertical line is plotted for the significance level in the histogram.
</p>
</td></tr>
<tr><td><code id="testNetworkProperties_+3A_linkage">linkage</code>, <code id="testNetworkProperties_+3A_functiongeneration">functionGeneration</code>, <code id="testNetworkProperties_+3A_validationfunction">validationFunction</code>, <code id="testNetworkProperties_+3A_failureiterations">failureIterations</code>, <code id="testNetworkProperties_+3A_simplify">simplify</code>, <code id="testNetworkProperties_+3A_noirrelevantgenes">noIrrelevantGenes</code>, <code id="testNetworkProperties_+3A_d_lattice">d_lattice</code>, <code id="testNetworkProperties_+3A_zerobias">zeroBias</code></td>
<td>

<p>The corresponding parameters of <code><a href="#topic+generateRandomNKNetwork">generateRandomNKNetwork</a></code> used to generate the random networks. This allows for customization of the network generation process. The three remaining parameters of <code><a href="#topic+generateRandomNKNetwork">generateRandomNKNetwork</a></code> are set to values that ensure structural similarity to the original network: The parameters <code>n</code> and <code>k</code> are set to the corresponding values of the original network, and <code>topology="fixed"</code>. 
</p>
</td></tr>
<tr><td><code id="testNetworkProperties_+3A_klbins">klBins</code></td>
<td>

<p>If <code>accumulation="kullback_leibler"</code>, the number of bins used to discretize the samples for the Kullback-Leibler distance calculations. By default, each unique value in the samples has its own bin, i.e. no further discretization is performed. The influence of discretization on the resulting histogram may be high.
</p>
</td></tr>
<tr><td><code id="testNetworkProperties_+3A_klminval">klMinVal</code></td>
<td>

<p>If <code>accumulation="kullback_leibler"</code>, this defines the minimum probability for the calculation of the Kullback-Leibler distance to ensure stability of the results.  
</p>
</td></tr>
<tr><td><code id="testNetworkProperties_+3A_title">title</code></td>
<td>

<p>The title of the plots. This is empty by default.
</p>
</td></tr>
<tr><td><code id="testNetworkProperties_+3A_xlab">xlab</code></td>
<td>

<p>Customizes label of the x axis of the histogram. For the built-in test functions, the x axis label is set automatically.
</p>
</td></tr>
<tr><td><code id="testNetworkProperties_+3A_xlim">xlim</code></td>
<td>

<p>Customizes the limits of the x axis of the histogram. For the built-in test functions, suitable values are chosen automatically. 
</p>
</td></tr>
<tr><td><code id="testNetworkProperties_+3A_breaks">breaks</code></td>
<td>

<p>Customizes the number of breaks in the 
</p>
</td></tr>
<tr><td><code id="testNetworkProperties_+3A_...">...</code></td>
<td>

<p>Further graphical parameters for <code><a href="graphics.html#topic+hist">hist</a></code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generically compares properties of biological networks to a set of random networks. It can be extended by supplying custom functions to the parameter <code>testFunction</code>. Such a function must have the signature
</p>
<p><code>function(network,
               accumulate=TRUE,
               params)</code>
</p>

<dl>
<dt>network</dt><dd><p>This is the network to test. In the process of the comparison, both the original network and the random networks are passed to the function</p>
</dd>
<dt>accumulate</dt><dd><p>If <code>accumulate=TRUE</code>, the function must return a single value quantifying the examined property of the network. If <code>accumulate=FALSE</code>, the function can return a vector of values (e.g., one value for each gene/state etc.)</p>
</dd>
<dt>params</dt><dd><p>A list of further parameters for the function supplied by the user in <code>testFunctionParams</code> (see above). This can contain any type of information your test function needs.</p>
</dd>
</dl>

<p>Three built-in functions for synchronous Boolean networks already exist:
</p>

<dl>
<dt>testIndegree</dt><dd><p>This function is based on the observation that, often, in biological networks, many state transitions lead to the same states. In other words, there is a small number of &quot;hub&quot; states. In the state graph, this means that the in-degree of some states (i.e., the number of transitions leading to it) is high, while the in-degree of many other states is 0. We observed that random networks do not show this behaviour, thus it may be a distinct property of biological networks. For this function, the parameter <code>alternative</code> of <code>testNetworkProperties</code> should be set to &quot;greater&quot;.
</p>
<p>The function does not require any parameter entries in <code>params</code>. If <code>accumulate=FALSE</code>, it returns the in-degrees of all synchronous states in the network. If <code>accumulate=TRUE</code>, the Gini index of the in-degrees is returned as a characteristic value of the network. The Gini index is a measure of inequality. If all states have an in-degree of 1, the Gini index is 0. If all state transitions lead to one single state, the Gini index is 1.
</p>
<p>This function requires the <span class="pkg">igraph</span> package for the analysis of the in-degrees.
</p>
</dd>
<dt>testAttractorRobustness</dt><dd><p>This function tests the robustness of attractors in a network to noise. We expect attractors in a real network to be less susceptible to noise than attractors in randomly generated networks, as biological processes can be assumed to be comparatively stable. There are modes of generating noise: Either the functions of the network can be perturbed, or the state trajectories can be perturbed in a simulation of the network. If <code>perturb="functions"</code> or <code>perturb="transitions"</code>, the function generates a number of perturbed copies of the network using <code><a href="#topic+perturbNetwork">perturbNetwork</a></code> and checks whether the original attractors can still be found in the network.
If <code>perturb="trajectories"</code>, the network itself is not perturbed. Instead, a set of random initial states is generated, and a set of perturbed states is generated from these initial states by flipping one or more bits. Then, the function tests whether the attractors are the same for the initial states and the corresponding perturbed states. This corresponds to calling <code><a href="#topic+perturbTrajectories">perturbTrajectories</a></code> with <code>measure="attractor"</code>. 
</p>
<p><code>params</code> can hold a number of parameters:
</p>

<dl>
<dt>numSamples</dt><dd><p>If <code>perturb="trajectories"</code>, the number of randomly generated state pairs to generate. Otherwise the number of perturbed networks that are generated.</p>
</dd>
<dt>perturb</dt><dd><p>Specifies the type of perturbation to be applied (possible values: <code>"functions"</code>, <code>"transitions"</code> and <code>"trajectories"</code> &ndash; see above).</p>
</dd>
<dt>method, simplify, readableFunctions, excludeFixed, maxNumBits, numStates</dt><dd><p> If <code>perturb="functions"</code> or <code>perturb="transitions"</code>, these are the corresponding parameters of <code><a href="#topic+perturbNetwork">perturbNetwork</a></code> that influence the way the network is perturbed.</p>
</dd>
<dt>flipBits</dt><dd><p> If <code>perturb="trajectories"</code>, the are the corresponding parameters of <code><a href="#topic+perturbTrajectories">perturbTrajectories</a></code> that defines how many bits are flipped.</p>
</dd>
</dl>

<p>If perturb=&quot;functions&quot; or <code>perturb="transitions"</code> and <code>accumulate=FALSE</code>, the function returns a vector of percentages of original attractors found in each of the perturbed copies of the original network. If <code>accumulate=TRUE</code>, the function returns the overall percentage of original attractors found in all perturbed copies.
</p>
<p>If <code>perturb="trajectories"</code> and <code>accumulate=FALSE</code>, the function returns a logical vector of length <code>numSamples</code> specifying whether the attractor was the same for each initial state and the corresponding perturbed state. If <code>accumulate=TRUE</code>, the function returns the percentage of pairs of initial states and perturbed states for which the attractors were the same.
</p>
<p>For this function, the parameter <code>alternative</code> of <code>testNetworkProperties</code> should be set to &quot;greater&quot;.
</p>
</dd>
<dt>testTransitionRobustness</dt><dd><p>This function calls <code>perturbTrajectories</code> with <code>measure="hamming"</code> to measure the average Hamming distance between successor states of randomly generated initial states and perturbed copies of these states.
</p>
<p>codeparams can hold parameters <code>numSamples, flipBits</code> corresponding to the parameters of <code><a href="#topic+perturbTrajectories">perturbTrajectories</a></code> that define how many initial states are drawn and how many bits are flipped.
</p>
<p>If <code>accumulate=FALSE</code>, the function returns a numeric vector of length <code>numSamples</code> with the normalized Hamming distances of all pairs of initial states and perturbed copies. If <code>accumulate=TRUE</code>, the mean normalized Hamming distance over all pairs is returned.
</p>
<p>For this function, the parameter <code>alternative</code> of <code>testNetworkProperties</code> should be set to &quot;less&quot;.
</p>
</dd>
</dl>
 


<h3>Value</h3>

<p>The function returns a list with the following elements
</p>
<table>
<tr><td><code>hist</code></td>
<td>
<p>The histogram that was plotted. The type of histogram depends on the parameter <code>accumulation</code>.</p>
</td></tr>
<tr><td><code>pval</code></td>
<td>
<p>If <code>accumulation="characteristic"</code>, a p-value for the alternative hypothesis that the test statistic value of the supplied network is greater than the value of a randomly generated network is supplied.</p>
</td></tr>
<tr><td><code>significant</code></td>
<td>
<p>If <code>accumulation="characteristic"</code>, this is true for <code>pval &lt; sign.level</code>.</p>
</td></tr> 
</table>


<h3>See Also</h3>

<p><code><a href="#topic+generateRandomNKNetwork">generateRandomNKNetwork</a></code>, <code><a href="#topic+perturbNetwork">perturbNetwork</a></code>, <code><a href="#topic+perturbTrajectories">perturbTrajectories</a></code>, <code><a href="#topic+plotStateGraph">plotStateGraph</a></code>, <code><a href="#topic+getAttractors">getAttractors</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load mammalian cell cycle network
data(cellcycle)

if (interactive())
# do not run these examples in the package check, as they take some time
{
  # compare the in-degrees of the states in the
  # cell cycle network to random networks
  testNetworkProperties(cellcycle, testFunction="testIndegree", alternative="greater")

  # compare the in-degrees of the states in the
  # cell cycle network to random networks,
  # and plot the Kullback-Leibler distances of the 100 experiments
  testNetworkProperties(cellcycle, testFunction="testIndegree",
                        accumulation = "kullback_leibler")

  # compare the robustness of attractors in the cell cycle network
  # to random networks by perturbing the networks
  testNetworkProperties(cellcycle, testFunction="testAttractorRobustness",
                        testFunctionParams=list(perturb="functions", numSamples=10),
                        alternative="greater")

  # compare the robustness of attractors in the cell cycle network
  # to random networks by perturbing the state trajectories
  testNetworkProperties(cellcycle, testFunction="testAttractorRobustness",
                        testFunctionParams=list(perturb="trajectories", numSamples=10),
                        alternative="greater")
                      
  # compare the robustness of single state transitions in the cell cycle network
  testNetworkProperties(cellcycle, testFunction="testTransitionRobustness",
                        testFunctionParams=list(numSamples=10),
                        alternative="less")
}                     

## End(Not run)
</code></pre>

<hr>
<h2 id='toPajek'>
Export a network to the Pajek file format
</h2><span id='topic+toPajek'></span>

<h3>Description</h3>

<p>Exports a network to the Pajek file format to visualize transition trajectories. For more information on Pajek, please refer to <a href="http://mrvar.fdv.uni-lj.si/pajek/">http://mrvar.fdv.uni-lj.si/pajek/</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toPajek(stateGraph, file = "boolean.net", includeLabels=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toPajek_+3A_stategraph">stateGraph</code></td>
<td>

<p>An object of class <code>AttractorInfo</code> or <code>SymbolicSimulation</code>, as returned by <code><a href="#topic+getAttractors">getAttractors</a></code> and <code><a href="#topic+simulateSymbolicModel">simulateSymbolicModel</a></code> respectively. As the transition table information in this structure is required, <code>getAttractors</code> must be called in synchronous mode and with <code>returnTable</code> set to TRUE. Similarly, <code>simulateSymbolicModel</code> must be called with <code>returnGraph=TRUE</code>. Alternatively, <code>stateGraph</code> can be an object of class <code>TransitionTable</code>, which can be extracted using the functions <code><a href="#topic+getTransitionTable">getTransitionTable</a></code>, <code><a href="#topic+getBasinOfAttraction">getBasinOfAttraction</a></code>, or <code><a href="#topic+getStateSummary">getStateSummary</a></code> .
</p>
</td></tr>
<tr><td><code id="toPajek_+3A_file">file</code></td>
<td>

<p>The name of the output file for Pajek. Defaults to &quot;boolean.net&quot;.
</p>
</td></tr>
<tr><td><code id="toPajek_+3A_includelabels">includeLabels</code></td>
<td>

<p>If set to true, the vertices of the graph in the output file are labeled with the binary encodings of the states. Defaults to FALSE.
</p>
</td></tr>
<tr><td><code id="toPajek_+3A_...">...</code></td>
<td>

<p>This is only for compatibility with previous versions and should not be used. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function has no return value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getAttractors">getAttractors</a></code>, <code><a href="#topic+simulateSymbolicModel">simulateSymbolicModel</a></code>, <code><a href="#topic+getTransitionTable">getTransitionTable</a></code>, <code><a href="#topic+getBasinOfAttraction">getBasinOfAttraction</a></code>, <code><a href="#topic+getStateSummary">getStateSummary</a></code>, <code><a href="#topic+toSBML">toSBML</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load example data
data(cellcycle)

# get attractors
attractors &lt;- getAttractors(cellcycle)

# export to Pajek
toPajek(attractors, file="pajek_export.net")

## End(Not run)
</code></pre>

<hr>
<h2 id='toSBML'>
Export a network to SBML
</h2><span id='topic+toSBML'></span>

<h3>Description</h3>

<p>Exports a synchronous or asynchronous Boolean network to SBML with the <code>sbml-qual</code> extension package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toSBML(network, 
       file,
       generateDNFs = FALSE,
       saveFixed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toSBML_+3A_network">network</code></td>
<td>

<p>An object of class <code>BooleanNetwork</code> or <code>SymbolicBooleanNetwork</code> to be exported
</p>
</td></tr>
<tr><td><code id="toSBML_+3A_file">file</code></td>
<td>

<p>The name of the SBML file to be created
</p>
</td></tr>
<tr><td><code id="toSBML_+3A_generatednfs">generateDNFs</code></td>
<td>

<p>If <code>network</code> is a <code>BooleanNetwork</code> object, this parameter specifies whether formulae in Disjunctive Normal Form are exported instead of the expressions that describe the transition functions. If set to FALSE, the original expressions are exported. If set to &quot;canonical&quot;, a canonical Disjunctive Normal Form is generated from each truth table. If set to &quot;short&quot;, the canonical DNF is minimized by joining terms (which can be time-consuming for functions with many inputs). If set to TRUE, a short DNF is generated for functions with up to 12 inputs, and a canonical DNF is generated for functions with more than 12 inputs.
For objects of class <code>SymbolicBooleanNetwork</code>, this parameter is ignored.
</p>
</td></tr>
<tr><td><code id="toSBML_+3A_savefixed">saveFixed</code></td>
<td>

<p>If set to TRUE, knock-outs and overexpression of genes override their transition functions. That is, if a gene in the network is fixed to 0 or 1, this value is exported, regardless of the transition function. If set to FALSE, the transition function is exported. Defaults to TRUE.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The export creates an SBML file describing a general logical model that corresponds to the Boolean network. Importing tools must support the <code>sbml-qual</code> extension package version 1.0.
</p>
<p>The export translates the expressions that describe the network transition functions to a MathML description. If these expressions cannot be parsed or <code>generateDNFs</code> is true, a DNF representation of the transition functions is generated and exported.
</p>
<p>For symbolic networks, temporal operators and delays of more than one time step are not allowed, as they are not compatible with SBML.
</p>


<h3>References</h3>

<p><a href="http://sbml.org/Documents/Specifications/SBML_Level_3/Packages/Qualitative_Models_(qual)">http://sbml.org/Documents/Specifications/SBML_Level_3/Packages/Qualitative_Models_(qual)</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loadSBML">loadSBML</a></code>, <code><a href="#topic+loadNetwork">loadNetwork</a></code>, <code><a href="#topic+saveNetwork">saveNetwork</a></code>, <code><a href="#topic+toPajek">toPajek</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load the cell cycle network
data(cellcycle)

# export the network to SBML
toSBML(cellcycle, file="cellcycle.sbml")

# reimport the model
print(loadSBML("cellcycle.sbml"))

## End(Not run)
</code></pre>

<hr>
<h2 id='truthTableToSymbolic'>
Convert a network in truth table representation into a symbolic representation
</h2><span id='topic+truthTableToSymbolic'></span>

<h3>Description</h3>

<p>Converts an object of class <code>BooleanNetwork</code> into an object of class <code>SymbolicBooleanNetwork</code> by generating symbolic expression trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>truthTableToSymbolic(network, generateDNFs = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="truthTableToSymbolic_+3A_network">network</code></td>
<td>

<p>An object of class <code>BooleanNetwork</code> to be converted.
</p>
</td></tr>
<tr><td><code id="truthTableToSymbolic_+3A_generatednfs">generateDNFs</code></td>
<td>

<p>This parameter specifies whether formulae in Disjunctive Normal Form are generated instead of the parsing the string expressions that describe the transition functions. If set to FALSE, the original expressions are parsed. If set to &quot;canonical&quot;, a canonical Disjunctive Normal Form is generated from each truth table. If set to &quot;short&quot;, the canonical DNF is minimized by joining terms (which can be time-consuming for functions with many inputs). If set to TRUE, a short DNF is generated for functions with up to 12 inputs, and a canonical DNF is generated for functions with more than 12 inputs.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>SymbolicBooleanNetwork</code>, as described in <code><a href="#topic+loadNetwork">loadNetwork</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+truthTableToSymbolic">truthTableToSymbolic</a></code>, <code><a href="#topic+loadNetwork">loadNetwork</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Convert a truth table representation into a 
# symbolic representation and back
data(cellcycle)

symbolicNet &lt;- truthTableToSymbolic(cellcycle)
print(symbolicNet)

ttNet &lt;- symbolicToTruthTable(symbolicNet)
print(cellcycle)

## End(Not run)
</code></pre>

<hr>
<h2 id='yeastTimeSeries'>
Yeast cell cycle time series data
</h2><span id='topic+yeastTimeSeries'></span>

<h3>Description</h3>

<p>Preprocessed time series measurements of four genes from the yeast cell cycle data by Spellman et al.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(yeastTimeSeries)</code></pre>


<h3>Format</h3>

<p>A matrix with 14 measurements for the genes Fhk2, Swi5, Sic1, and Clb1. Each gene is a row of the matrix, and each column is a measurement.
</p>


<h3>Details</h3>

<p>The data were obtained from the web site of the yeast cell cycle analysis project. The time series synchronized with the elutriation method were extracted for the genes Fhk2, Swi5, SIC1, and Clb1. In a preprocessing step, missing values were imputed by taking the means of the measurements of the same genes at neighbouring time points.
</p>


<h3>Source</h3>

<p>P. T. Spellman, G. Sherlock, M. Q. Zhang, V. R. Iyer, K. Anders, M. B. Eisen, P. O. Brown, D. Botstein, B. Futcher (1998), Comprehensive Identification of Cell Cycle-regulated Genes of the Yeast Saccharomyces cerevisiae by Microarray Hybridization. Molecular Biology of the Cell 9(12):3273&ndash;3297.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(yeastTimeSeries)

# the data set is stored in a variable called 'yeastTimeSeries'
print(yeastTimeSeries)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
