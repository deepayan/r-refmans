<!DOCTYPE html><html><head><title>Help for package telefit</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {telefit}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#abind3'><p>Convenience function for stacking matrices into an array.</p></a></li>
<li><a href='#arrayToLong'><p>Reshape array of data matrices into long format</p></a></li>
<li><a href='#cca.predict'><p>Make predictions using canonical correlation analysis (CCA)</p></a></li>
<li><a href='#coef.stFit'><p>Compute point estimates for parameters from posterior samples</p></a></li>
<li><a href='#coef.stPredict'><p>Compute point estimates for parameters from posterior samples</p></a></li>
<li><a href='#coprecip'><p>Standardized anomalies of CO Precipitation</p></a></li>
<li><a href='#coprecip.fit'><p>Sample MCMC output for the RESP model</p></a></li>
<li><a href='#coprecip.predict'><p>Sample composition sampling output for the RESP model</p></a></li>
<li><a href='#dgemkmm'><p>Evaluate kron(A,B) * C without storing kron(A,B)</p></a></li>
<li><a href='#eof'><p>Performs an EOF decomposition of the data</p></a></li>
<li><a href='#errDump'><p>Wrapper for a function to dump errors from C++</p></a></li>
<li><a href='#extractRegion'><p>Extract region from a SpatialGridDataFrame</p></a></li>
<li><a href='#extractStData'><p>Basic extraction of SpatialGridDataFrame data for teleconnection analysis</p></a></li>
<li><a href='#forwardsolve.kron'><p>Solves a triangular system with a Kronecker product structure</p></a></li>
<li><a href='#HPDinterval.stFit'><p>Compute Highest posterior density intervals from posterior samples</p></a></li>
<li><a href='#invWSamp'><p>Samples an Inverse-Wishart matrix</p></a></li>
<li><a href='#kronSamp'><p>Samples a multivariate normal with a Kronecker product covariance structure</p></a></li>
<li><a href='#lat_trans'><p>Formatting for longitude scales in ggplot spatial maps</p></a></li>
<li><a href='#lon_trans'><p>Formatting for longitude scales in ggplot spatial maps</p></a></li>
<li><a href='#maternArray'><p>Matern covariance</p></a></li>
<li><a href='#maternCov'><p>Matern covariance</p></a></li>
<li><a href='#maternEffectiveRange'><p>Compute effective range for Matern correlation to drop to a specified level</p></a></li>
<li><a href='#mergeComposition'><p>Combine results from composition sampler</p></a></li>
<li><a href='#mergeCovmat'><p>Combine sample covariance matrices from two samples</p></a></li>
<li><a href='#mergeMean'><p>Combine sample means from two samples</p></a></li>
<li><a href='#mergeVar'><p>Combine sample variances from two samples</p></a></li>
<li><a href='#plot.stData'><p>Plot stData objects</p></a></li>
<li><a href='#plot.stFit'><p>Plot stFit objects</p></a></li>
<li><a href='#plot.stPredict'><p>Plot stPredict objects</p></a></li>
<li><a href='#plot.teleCor'><p>Plots teleconnection correlation maps</p></a></li>
<li><a href='#rmatnorm'><p>Simulate matrices from matrix normal distributions</p></a></li>
<li><a href='#rwishart'><p>Random wishart matrix</p></a></li>
<li><a href='#stEval'><p>Basic evaluation of fit</p></a></li>
<li><a href='#stFit'><p>Fit the remote effects spatial process (RESP) model</p></a></li>
<li><a href='#stLL'><p>Compute log likelihood for model</p></a></li>
<li><a href='#stPredict'><p>Compute forecasts based on posterior samples</p></a></li>
<li><a href='#stSimulate'><p>Simulate responses from the spatio-temporal teleconnection model</p></a></li>
<li><a href='#stVIF'><p>Computes variance inflation factors for fixed effects of the teleconnection model</p></a></li>
<li><a href='#summariseAlpha'><p>Summarize alphas</p></a></li>
<li><a href='#summariseEOFAlpha'><p>Summarize eof-mapped alphas</p></a></li>
<li><a href='#summary.stPredict'><p>Plot stPredict objects</p></a></li>
<li><a href='#svcFit'><p>Fit a spatially varying coefficient model</p></a></li>
<li><a href='#svcPredict'><p>Make predictions using a fitted varying coefficient model</p></a></li>
<li><a href='#teleCor'><p>Pointwise correlations for an exploratory teleconnection analysis</p></a></li>
<li><a href='#telefit'><p>Tools for modeling teleconnections</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Estimation and Prediction for Remote Effects Spatial Process
Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-02-03</td>
</tr>
<tr>
<td>Author:</td>
<td>Joshua Hewitt</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joshua Hewitt &lt;joshua.hewitt@duke.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of the remote effects spatial process (RESP) model for teleconnection.  The RESP model is a geostatistical model that allows a spatially-referenced variable (like average precipitation) to be influenced by covariates defined on a remote domain (like sea surface temperatures).  The RESP model is introduced in Hewitt et al. (2018) &lt;<a href="https://doi.org/10.1002%2Fenv.2523">doi:10.1002/env.2523</a>&gt;.  Sample code for working with the RESP model is available at <a href="https://jmhewitt.github.io/research/resp_example">https://jmhewitt.github.io/research/resp_example</a>. This material is based upon work supported by the National Science Foundation under grant number AGS 1419558. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of the National Science Foundation.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>abind, coda, cowplot, dplyr, fields, itertools, mvtnorm,
raster, scoringRules, stringr, foreach, ggplot2, gtable,
reshape2, scales, sp</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 0.12.4), RcppArmadillo, RcppEigen (&ge; 0.3.3.3.1)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>A system with a recent-enough C++11 compiler (such
as g++-4.8 or later).</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-02-03 19:08:44 UTC; pointdex</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-02-03 21:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='abind3'>Convenience function for stacking matrices into an array.</h2><span id='topic+abind3'></span>

<h3>Description</h3>

<p>This function extends the abind function from the abind package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abind3(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abind3_+3A_...">...</code></td>
<td>
<p>Any number of matrices of equal dimension to stack together into
a 3d matrix</p>
</td></tr>
</table>

<hr>
<h2 id='arrayToLong'>Reshape array of data matrices into long format</h2><span id='topic+arrayToLong'></span>

<h3>Description</h3>

<p>Reshape array of data matrices into long format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arrayToLong(X, coords, yrs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arrayToLong_+3A_x">X</code></td>
<td>
<p>3 dimensional array of matrices to extract to long format</p>
</td></tr>
<tr><td><code id="arrayToLong_+3A_coords">coords</code></td>
<td>
<p>Spatial coordinates associated with the data (longitude in first column)</p>
</td></tr>
<tr><td><code id="arrayToLong_+3A_yrs">yrs</code></td>
<td>
<p>Vector with labels for the years</p>
</td></tr>
</table>

<hr>
<h2 id='cca.predict'>Make predictions using canonical correlation analysis (CCA)</h2><span id='topic+cca.predict'></span>

<h3>Description</h3>

<p>Canonical correlation analysis (CCA) is sometimes referred to as a 
double-barreled principal component analysis.  Loosely, it fits a linear 
regression model to the scores of principal component decompositions for
of the predictors <code>X</code> and responses <code>Y</code>.  Oftentimes, only the 
largest <code class="reqn">k</code> principal components are used to make predictions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cca.predict(X, Y, X.new, k.x, k.y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cca.predict_+3A_x">X</code></td>
<td>
<p>An <code>(nvars x nobs)</code> data frame or matrix in which each column
contains all observations of measured (predictor) variables for a given 
timepoint or sample.  For example, if X represents a spatial variable that
was recorded at several timepoints, then each row of X should contain the
variable's measurement for all timepoints at a single location.</p>
</td></tr>
<tr><td><code id="cca.predict_+3A_y">Y</code></td>
<td>
<p>An <code>(nvars x nobs)</code> data frame or matrix in which each column
contains all observations of measured (response) variables for a given
timepoint or sample.</p>
</td></tr>
<tr><td><code id="cca.predict_+3A_x.new">X.new</code></td>
<td>
<p>An <code>(nvars x nobs.new)</code> data frame or matrix of values to
use to predict Y.new using CCA.</p>
</td></tr>
<tr><td><code id="cca.predict_+3A_k.x">k.x</code></td>
<td>
<p>An integer less than <code>(nobs)</code> indicating how many eigenvectors
of <code>(X)</code> to use in the CCA.</p>
</td></tr>
<tr><td><code id="cca.predict_+3A_k.y">k.y</code></td>
<td>
<p>An integer less than <code>(nobs)</code> indicating how many eigenvectors
of <code>(Y)</code> to use in the CCA.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>CCA has been used to predict a teleconnected response (like precipitation) 
using the remote field generating the teleconnection 
(like ocean temperatures).  In this application, principal components are 
often referred to as empirical orthogonal functions (EOFs).
</p>


<h3>Value</h3>

<p>Y.new Predicted values for Y.new
</p>


<h3>References</h3>

<p>Cook, E.R., Briffa, K.R., and Jones, P.D., 1994, Spatial regression methods in dendroclimatology: A review and comparison of two techniques: International Journal of Climatology, v. 14, p. 379-402.
</p>
<p>Glahn, H.R., 1968, Canonical Correlation and Its Relationship to Discriminant Analysis and Multiple Regression: Journal of the Atmospheric Sciences, v. 25, p. 23-31.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("coprecip")
attach(coprecip)

# compute CCA predictions of Y (CO precipitation) given Z (Pacific ocean SSTs)
# using 2 principal components (aka. EOFs)
preds = cca.predict(X = Z, Y = Y, X.new = Z, k.x = 2, k.y = 2)

# compute R^2
1 - var(as.numeric(preds-Y)) / var(as.numeric(Y))

</code></pre>

<hr>
<h2 id='coef.stFit'>Compute point estimates for parameters from posterior samples</h2><span id='topic+coef.stFit'></span>

<h3>Description</h3>

<p>Compute point estimates for parameters from posterior samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stFit'
coef(object, burn = 1, fun = mean, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.stFit_+3A_object">object</code></td>
<td>
<p>stFit object containing posterior samples for model</p>
</td></tr>
<tr><td><code id="coef.stFit_+3A_burn">burn</code></td>
<td>
<p>number of posterior samples to reject before computing estimates</p>
</td></tr>
<tr><td><code id="coef.stFit_+3A_fun">fun</code></td>
<td>
<p>function for computing point estimates</p>
</td></tr>
<tr><td><code id="coef.stFit_+3A_...">...</code></td>
<td>
<p>S3 generic/method consistency</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data("coprecip.fit")
coef(coprecip.fit, burn = 50)

</code></pre>

<hr>
<h2 id='coef.stPredict'>Compute point estimates for parameters from posterior samples</h2><span id='topic+coef.stPredict'></span>

<h3>Description</h3>

<p>Compute point estimates for parameters from posterior samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stPredict'
coef(object, stFit, stData, burn = 1, type = "eof-alpha_knots", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.stPredict_+3A_object">object</code></td>
<td>
<p>stPredict object containing posterior estimates of alphas</p>
</td></tr>
<tr><td><code id="coef.stPredict_+3A_stfit">stFit</code></td>
<td>
<p>stFit object containing posterior samples for model</p>
</td></tr>
<tr><td><code id="coef.stPredict_+3A_stdata">stData</code></td>
<td>
<p>stData object containing spatial information for dataset</p>
</td></tr>
<tr><td><code id="coef.stPredict_+3A_burn">burn</code></td>
<td>
<p>number of posterior samples to reject before computing estimates</p>
</td></tr>
<tr><td><code id="coef.stPredict_+3A_type">type</code></td>
<td>
<p>One of the following options to specify what point estimates to return
</p>

<dl>
<dt>eof-alpha_knots</dt><dd><p> Remote coefficient estimates (alpha_knots) 
mapped onto the eof patterns of the remote covariates.   </p>
</dd>
</dl>
</td></tr>
<tr><td><code id="coef.stPredict_+3A_...">...</code></td>
<td>
<p>S3 generic/method consistency</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data("coprecip")
data("coprecip.fit")
data("coprecip.predict")

coef(coprecip.predict, stFit = coprecip.fit, stData = coprecip, burn = 50)
 
</code></pre>

<hr>
<h2 id='coprecip'>Standardized anomalies of CO Precipitation</h2><span id='topic+coprecip'></span>

<h3>Description</h3>

<p>A dataset containing sample spatially-aggregated climate data from the 
ERA-Interim and PRISM datasets.  The response comes from PRISM, average 
monthly precipitation in a DJF winter.  The covariates come from ERA-Interim, 
Colorado and Pacific Ocean (sea) surface temperatures.  All data has been
converted to standardized anomalies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coprecip
</code></pre>


<h3>Format</h3>

<p>A stData object with 3 years of observations
</p>

<dl>
<dt>tLabs</dt><dd><p>year labels for data columns</p>
</dd>
<dt>coords.s</dt><dd><p>centers of grid cells for Colorado data</p>
</dd>
<dt>coords.r</dt><dd><p>centers of grid cells for Pacific Ocean data</p>
</dd>
<dt>X</dt><dd><p>Array of design matrices for Colorado covariates</p>
</dd>
<dt>Y</dt><dd><p>Matrix of precipitation observations</p>
</dd>
<dt>Z</dt><dd><p>Matrix of Pacific Ocean data</p>
</dd>
<dt>X.lab</dt><dd><p>Label for covariate data, used by plotting functions</p>
</dd>
<dt>Y.lab</dt><dd><p>Label for response data, used by plotting functions</p>
</dd>
<dt>Z.lab</dt><dd><p>Label for covariate data, used by plotting functions</p>
</dd>
</dl>


<h3>Source</h3>

<p><a href="http://prism.oregonstate.edu">http://prism.oregonstate.edu</a>
</p>
<p><a href="https://rda.ucar.edu/datasets/ds627.0/">https://rda.ucar.edu/datasets/ds627.0/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("coprecip")
str(coprecip)

</code></pre>

<hr>
<h2 id='coprecip.fit'>Sample MCMC output for the RESP model</h2><span id='topic+coprecip.fit'></span>

<h3>Description</h3>

<p>An example stFit object containing output from a short run of the MCMC 
sampler that fits the RESP model to data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coprecip.fit
</code></pre>


<h3>Format</h3>

<p>An stFit object, which is a list of several objects
</p>

<dl>
<dt>parameters</dt><dd><p>MCMC samples of model parameters</p>
</dd>
<dt>priors</dt><dd><p>description of priors used to fit model</p>
</dd>
<dt>miles</dt><dd><p>TRUE or FALSE to specify whether the spatial distances 
used to estimate spatial covariance parameters were in units of miles 
(TRUE) or kilometers (FALSE)</p>
</dd>
<dt>localOnly</dt><dd><p>TRUE if remote covariates were not estimated</p>
</dd>
<dt>remoteOnly</dt><dd><p>TRUE if local covariates were not estimated</p>
</dd>
<dt>varying</dt><dd><p>(deprecated) TRUE if local covariates were estimated as a 
spatially-varying field</p>
</dd>
<dt>coords.knots</dt><dd><p>coordinates of remote knot locations</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>
data("coprecip.fit")
str(coprecip.fit)

</code></pre>

<hr>
<h2 id='coprecip.predict'>Sample composition sampling output for the RESP model</h2><span id='topic+coprecip.predict'></span>

<h3>Description</h3>

<p>An example stPredict object containing predictions from a short run of the 
MCMC composition sampler.  The output also contains teleconnection estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coprecip.predict
</code></pre>


<h3>Format</h3>

<p>An stPredict object, which is a list of several objects
</p>

<dl>
<dt>pred</dt><dd><p>A list containing summaries of posterior predictions</p>
</dd>
<dt>samples</dt><dd><p>Posterior samples for predictions</p>
</dd>
<dt>coords.s</dt><dd><p>centers of grid cells for Colorado data</p>
</dd>
<dt>localOnly</dt><dd><p>TRUE if remote covariates were not estimated</p>
</dd>
<dt>varying</dt><dd><p>(deprecated) TRUE if local covariates were estimated as a 
spatially-varying field</p>
</dd>
<dt>tLabs</dt><dd><p>year labels for prediction timepoints</p>
</dd>
<dt>Y.lab</dt><dd><p>Label for response data, used by plotting functions</p>
</dd>
<dt>cat.probs</dt><dd><p>vector of probabilities for using posterior samples to 
return categorical predictions from the posterior prediction samples</p>
</dd>
<dt>category.breaks</dt><dd><p>Breakpoints used to discretize posterior predictive
distribution at each coordinate in coords.s during composition sampling.</p>
</dd>
<dt>alpha_knots</dt><dd><p>Summaries of posterior estimates of teleconnection 
effects</p>
</dd>
<dt>eof_alpha_knots</dt><dd><p>Summaries of posterior estimates of teleconnection 
effects after spatial basis function transformation</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>
data("coprecip.predict")
str(coprecip.predict)

</code></pre>

<hr>
<h2 id='dgemkmm'>Evaluate kron(A,B) * C without storing kron(A,B)</h2><span id='topic+dgemkmm'></span>

<h3>Description</h3>

<p>Evaluate kron(A,B) * C without storing kron(A,B)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgemkmm(A, B, C)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dgemkmm_+3A_a">A</code></td>
<td>
<p>(m x n) matrix</p>
</td></tr>
<tr><td><code id="dgemkmm_+3A_b">B</code></td>
<td>
<p>(p x q) matrix</p>
</td></tr>
<tr><td><code id="dgemkmm_+3A_c">C</code></td>
<td>
<p>(nq x r) matrix</p>
</td></tr>
</table>

<hr>
<h2 id='eof'>Performs an EOF decomposition of the data</h2><span id='topic+eof'></span>

<h3>Description</h3>

<p>Uses the stats::prcomp function to implement EOF decompositions of data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eof(X, center = F, scale = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eof_+3A_x">X</code></td>
<td>
<p>[variable x observation] matrix of data for which to compute EOFs</p>
</td></tr>
<tr><td><code id="eof_+3A_center">center</code></td>
<td>
<p>TRUE/FALSE to center columns of X in call to prcomp</p>
</td></tr>
<tr><td><code id="eof_+3A_scale">scale</code></td>
<td>
<p>TRUE/FALSE to scale columns of X in call to prcomp</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing EOF patterns as columns, and their scores
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("coprecip")
attach(coprecip)

# compute ocean surface temperature eofs
eofs = eof(Z)

# view first EOF, which corresponds to the El-Nino pattern
coords.r.mod = coords.r
coords.r.mod[,1][coords.r.mod[,1]&gt;0] =
  coords.r.mod[,1][coords.r.mod[,1]&gt;0] - 360
fields::quilt.plot(coords.r.mod, eofs$patterns[,1])

# alternatively, the plot.stData function can directly compute and plot EOFs
plot(coprecip, type='eof', pattern=1)

</code></pre>

<hr>
<h2 id='errDump'>Wrapper for a function to dump errors from C++</h2><span id='topic+errDump'></span>

<h3>Description</h3>

<p>Wrapper for a function to dump errors from C++
</p>


<h3>Usage</h3>

<pre><code class='language-R'>errDump(x, fname = file.path(tempdir(), "error_samplerState.RData"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="errDump_+3A_x">x</code></td>
<td>
<p>Data to save</p>
</td></tr>
<tr><td><code id="errDump_+3A_fname">fname</code></td>
<td>
<p>Path/name to save data to</p>
</td></tr>
</table>

<hr>
<h2 id='extractRegion'>Extract region from a SpatialGridDataFrame</h2><span id='topic+extractRegion'></span>

<h3>Description</h3>

<p>This method is intended for use as the main helper function for 
extractStData.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractRegion(
  sgdf,
  extent,
  type = "response",
  aggfact = NULL,
  mask = NULL,
  aspect = F,
  aspect.categories = NULL,
  slope = F
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractRegion_+3A_sgdf">sgdf</code></td>
<td>
<p>SpatialGridDataFrame containing data to extract</p>
</td></tr>
<tr><td><code id="extractRegion_+3A_extent">extent</code></td>
<td>
<p>raster::extent object featuring region to extract, or a 
SpatialPolygonsXXX object used for extracting areal data</p>
</td></tr>
<tr><td><code id="extractRegion_+3A_type">type</code></td>
<td>
<p>whether to return the raw data, anomalies (data minus temporal 
average at each location), standardized anomalies (anomalies divided by
temporal standard deviation at each location), or spatially standardized
data (data minus overall spatial average divided by spatial std. dev.; each
year gets its own spatial standardization )</p>
</td></tr>
<tr><td><code id="extractRegion_+3A_aggfact">aggfact</code></td>
<td>
<p>if provided, will spatially average the data</p>
</td></tr>
<tr><td><code id="extractRegion_+3A_mask">mask</code></td>
<td>
<p>if an sgdf is provided, the data will be masked before
extraction, aggregation, and anomaly computation</p>
</td></tr>
<tr><td><code id="extractRegion_+3A_aspect">aspect</code></td>
<td>
<p>TRUE to return the aspect of the surface at each location 
instead of the value of the surface itself</p>
</td></tr>
<tr><td><code id="extractRegion_+3A_aspect.categories">aspect.categories</code></td>
<td>
<p>if aspect==TRUE, this specifies the number of 
discrete categories to divide aspect numbers (0-360) into.  NULL if the
original scale (0-360) should be kept. By design, the aspect categories
will be centered on north in the first category.</p>
</td></tr>
<tr><td><code id="extractRegion_+3A_slope">slope</code></td>
<td>
<p>TRUE to return the slope of the surface at each location instead
of the value of the surface itself</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a modified SpatialGridDataFrame, sgdf, with the climatology for each
location accessible via attr(sgdf@data@values, 'scaled:center') if anomalies
were computed
</p>

<hr>
<h2 id='extractStData'>Basic extraction of SpatialGridDataFrame data for teleconnection analysis</h2><span id='topic+extractStData'></span>

<h3>Description</h3>

<p>Basic extraction of SpatialGridDataFrame data for teleconnection analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractStData(
  X,
  Y,
  Z,
  t = NULL,
  D.s,
  D.r,
  mask.s = NULL,
  mask.r = NULL,
  aggfact.s = NULL,
  aggfact.r = NULL,
  intercept = T,
  type.s = "response",
  type.r = "response",
  type.s.y = "response",
  X.lab = NULL,
  Y.lab = NULL,
  Z.lab = NULL,
  aspect = F,
  aspect.categories = 4,
  slope = F,
  colnames.X = NULL,
  formula = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractStData_+3A_x">X</code></td>
<td>
<p>SpatialGridDataFrame with local covariates.  If X is a list, each
SpatialGridDataFrame will be included as one covariate.</p>
</td></tr>
<tr><td><code id="extractStData_+3A_y">Y</code></td>
<td>
<p>SpatialGridDataFrame with response data</p>
</td></tr>
<tr><td><code id="extractStData_+3A_z">Z</code></td>
<td>
<p>SpatialGridDataFrame with remote covariates. If Z is a list, this 
function assumes each element of the list contains observations for the same
covariate, but from different spatial regions.  If Z is a list, D.r and 
mask.r must
also be lists so that this function can know which regions to extract from
each SpatialGridDataFrame</p>
</td></tr>
<tr><td><code id="extractStData_+3A_t">t</code></td>
<td>
<p>Timepoint from which to extract data from X, Y, and Z.  If NULL,
then all timepoints will be used.</p>
</td></tr>
<tr><td><code id="extractStData_+3A_d.s">D.s</code></td>
<td>
<p>c(xmin, xmax, ymin, ymax) region from which to extract data from 
X and Y, or a SpatialPolygonsXXX object containing boundaries of regions to
extract areal data from.</p>
</td></tr>
<tr><td><code id="extractStData_+3A_d.r">D.r</code></td>
<td>
<p>c(xmin, xmax, ymin, ymax) region from which to extract data from Z</p>
</td></tr>
<tr><td><code id="extractStData_+3A_mask.s">mask.s</code></td>
<td>
<p>SpatialGridDataFrame to be used as a mask when extracting data
from X and Y.  Locations in mask.s with NA values will be ignored when 
extracting data from X and Y.</p>
</td></tr>
<tr><td><code id="extractStData_+3A_mask.r">mask.r</code></td>
<td>
<p>SpatialGridDataFrame to be used as a mask when extracting data
from Z.  Locations in mask.s with NA values will be ignored when 
extracting data from Z.</p>
</td></tr>
<tr><td><code id="extractStData_+3A_aggfact.s">aggfact.s</code></td>
<td>
<p>If provided, will spatially average Y and X data</p>
</td></tr>
<tr><td><code id="extractStData_+3A_aggfact.r">aggfact.r</code></td>
<td>
<p>If provided, will spatially average Z data</p>
</td></tr>
<tr><td><code id="extractStData_+3A_intercept">intercept</code></td>
<td>
<p>If TRUE, an intercept will be added to the design matrix</p>
</td></tr>
<tr><td><code id="extractStData_+3A_type.s">type.s</code></td>
<td>
<p>'response' 'anomaly' or 'std.anomaly' or a vector of these
options depending on whether
data extracted from X should be the observed data, anomalies, or
standardized anomalies (where the climatology is computed from the 
observations as the pointwise temporal average)</p>
</td></tr>
<tr><td><code id="extractStData_+3A_type.r">type.r</code></td>
<td>
<p>'response' 'anomaly' or 'std.anomaly' or a vector of these
options depending on whether
data extracted from Z should be the observed data, anomalies, or
standardized anomalies (where the climatology is computed from the 
observations as the pointwise temporal average)</p>
</td></tr>
<tr><td><code id="extractStData_+3A_type.s.y">type.s.y</code></td>
<td>
<p>'response' 'anomaly' or 'std.anomaly' depending on whether
data extracted from Y should be the observed data, anomalies, or
standardized anomalies (where the climatology is computed from the 
observations as the pointwise temporal average)</p>
</td></tr>
<tr><td><code id="extractStData_+3A_x.lab">X.lab</code></td>
<td>
<p>name for X data (optional)</p>
</td></tr>
<tr><td><code id="extractStData_+3A_y.lab">Y.lab</code></td>
<td>
<p>name for Y data (optional)</p>
</td></tr>
<tr><td><code id="extractStData_+3A_z.lab">Z.lab</code></td>
<td>
<p>name for Z data (optional)</p>
</td></tr>
<tr><td><code id="extractStData_+3A_aspect">aspect</code></td>
<td>
<p>TRUE or vector of logicals (one for each X object)
to return the aspect of the surface at each location 
instead of the value of the surface itself</p>
</td></tr>
<tr><td><code id="extractStData_+3A_aspect.categories">aspect.categories</code></td>
<td>
<p>if aspect==TRUE, this specifies the number of 
discrete categories to divide aspect numbers (0-360) into.  NULL if the
original scale (0-360) should be kept. By design, the aspect categories
will be centered on north in the first category.</p>
</td></tr>
<tr><td><code id="extractStData_+3A_slope">slope</code></td>
<td>
<p>TRUE or vector of logicals (one for each X object)
to return the slope of the surface at each location 
instead of the value of the surface itself</p>
</td></tr>
<tr><td><code id="extractStData_+3A_colnames.x">colnames.X</code></td>
<td>
<p>names of columns of X</p>
</td></tr>
<tr><td><code id="extractStData_+3A_formula">formula</code></td>
<td>
<p>formula object to specify how to create the design matrix</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># the extractRegion and extractStData methods create data matrices from 
# SpatialGridDataFrame objects

library(sp)

data("coprecip")
attach(coprecip)


#
# build SpatialGridDataFrame objects containing some of the coprecip data
#

gt = GridTopology(cellcentre.offset = apply(coords.s, 2, min),
                  cellsize = c(.5, .5), 
                  cells.dim = c(20, 12))

# Note: This is an example only; this grid will not match coprecip$coords.r
gt.Z = GridTopology(cellcentre.offset = apply(coords.r, 2, min),
                    cellsize = c(1.4, 1.4),
                    cells.dim = c(101, 52))

Xd = data.frame(`1981` = X[,2,1], `1982` = X[,2,2])
colnames(Xd) = gsub('X','', colnames(Xd))
sgdf.x = SpatialGridDataFrame(gt, Xd)


Yd = data.frame(`1981` = Y[,1], `1982` = Y[,2])
colnames(Yd) = gsub('X','', colnames(Yd))
sgdf.y = SpatialGridDataFrame(gt, Yd)


Zd = data.frame(`1981` = Z[,1], `1982` = Z[,2])
colnames(Zd) = gsub('X','', colnames(Zd))
sgdf.z = SpatialGridDataFrame(gt.Z, Zd)

# only extract a region of the coordinates
coprecip2 = extractStData(sgdf.x, sgdf.y, sgdf.z, 
                    D.s = c(-105, -103, 37, 41),
                    D.r = c(-160, -100, -15, 0))
</code></pre>

<hr>
<h2 id='forwardsolve.kron'>Solves a triangular system with a Kronecker product structure</h2><span id='topic+forwardsolve.kron'></span>

<h3>Description</h3>

<p>Solves <code class="reqn">kron(A, B) x = y</code> where <code class="reqn">A</code> and <code class="reqn">B</code> are lower triangular
matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forwardsolve.kron(A, B, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forwardsolve.kron_+3A_a">A</code></td>
<td>
<p>an <code class="reqn">m x n</code> matrix</p>
</td></tr>
<tr><td><code id="forwardsolve.kron_+3A_b">B</code></td>
<td>
<p>an <code class="reqn">p x q</code> matrix</p>
</td></tr>
<tr><td><code id="forwardsolve.kron_+3A_y">y</code></td>
<td>
<p>an <code class="reqn">mp x s</code> matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2018)

coord.s = matrix(runif(100), ncol=2)
coord.r = matrix(runif(50), ncol=2)

d.s = as.matrix(dist(coord.s))
d.r = as.matrix(dist(coord.r))

S1 = exp(-d.s)
S2 = exp(-d.r)

A = t(chol(S1))
B = t(chol(S2))

s = 15
  
x = matrix(runif(nrow(S1)*nrow(S2)*s), ncol=s)

y = kronecker(A,B) %*% x

x.solved = forwardsolve.kron(A, B, y)

max(abs(x - x.solved))
</code></pre>

<hr>
<h2 id='HPDinterval.stFit'>Compute Highest posterior density intervals from posterior samples</h2><span id='topic+HPDinterval.stFit'></span>

<h3>Description</h3>

<p>Compute Highest posterior density intervals from posterior samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stFit'
HPDinterval(stFit, burn = 1, prob = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HPDinterval.stFit_+3A_stfit">stFit</code></td>
<td>
<p>stFit object containing posterior samples for model</p>
</td></tr>
<tr><td><code id="HPDinterval.stFit_+3A_burn">burn</code></td>
<td>
<p>number of posterior samples to reject before computing estimates</p>
</td></tr>
<tr><td><code id="HPDinterval.stFit_+3A_prob">prob</code></td>
<td>
<p>The target probability content of the intervals</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data("coprecip.fit")
HPDinterval.stFit(coprecip.fit, burn = 50)

</code></pre>

<hr>
<h2 id='invWSamp'>Samples an Inverse-Wishart matrix</h2><span id='topic+invWSamp'></span>

<h3>Description</h3>

<p>Samples <code class="reqn">W ~ IW(Psi, n)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invWSamp(Psi, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invWSamp_+3A_psi">Psi</code></td>
<td>
<p>an <code class="reqn">n x n</code> scale matrix</p>
</td></tr>
<tr><td><code id="invWSamp_+3A_n">n</code></td>
<td>
<p>degrees of freedom parameter</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
A = matrix(c(1,.5,.5,1), ncol=2)
W = invWSamp(A, 3)

</code></pre>

<hr>
<h2 id='kronSamp'>Samples a multivariate normal with a Kronecker product covariance structure</h2><span id='topic+kronSamp'></span>

<h3>Description</h3>

<p>Samples <code class="reqn">x ~ N(0, AxB)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kronSamp(A, B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kronSamp_+3A_a">A</code></td>
<td>
<p>an <code class="reqn">m x n</code> matrix</p>
</td></tr>
<tr><td><code id="kronSamp_+3A_b">B</code></td>
<td>
<p>an <code class="reqn">p x q</code> matrix</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
A = matrix(c(1,.5,.5,1), ncol=2)
B = diag(2)
x = kronSamp(A, B)

</code></pre>

<hr>
<h2 id='lat_trans'>Formatting for longitude scales in ggplot spatial maps</h2><span id='topic+lat_trans'></span>

<h3>Description</h3>

<p>Formatting for longitude scales in ggplot spatial maps
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lat_trans()
</code></pre>

<hr>
<h2 id='lon_trans'>Formatting for longitude scales in ggplot spatial maps</h2><span id='topic+lon_trans'></span>

<h3>Description</h3>

<p>Formatting for longitude scales in ggplot spatial maps
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lon_trans()
</code></pre>

<hr>
<h2 id='maternArray'>Matern covariance</h2><span id='topic+maternArray'></span>

<h3>Description</h3>

<p>This function evaluates the Matern covariance function for the elements of 
a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maternArray(d, scale = 1, range = 1, smoothness = 0.5, nugget = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maternArray_+3A_d">d</code></td>
<td>
<p>A numeric vector of distances at which the Matern 
correlation function should be evaluated.</p>
</td></tr>
<tr><td><code id="maternArray_+3A_scale">scale</code></td>
<td>
<p>Scales correlations to covariances.</p>
</td></tr>
<tr><td><code id="maternArray_+3A_range">range</code></td>
<td>
<p>Matern range parameter.  Controls the decay of pointwise 
correlations as a function of distance.</p>
</td></tr>
<tr><td><code id="maternArray_+3A_smoothness">smoothness</code></td>
<td>
<p>Matern smoothness parameter.  Controls the number of 
process derivatives.</p>
</td></tr>
<tr><td><code id="maternArray_+3A_nugget">nugget</code></td>
<td>
<p>Spatial covariance nugget.</p>
</td></tr>
</table>

<hr>
<h2 id='maternCov'>Matern covariance</h2><span id='topic+maternCov'></span>

<h3>Description</h3>

<p>This function evaluates the Matern covariance function for the elements of 
a (potentially non-square) spatial distance matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maternCov(d, scale = 1, range = 1, smoothness = 0.5, nugget = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maternCov_+3A_d">d</code></td>
<td>
<p>A numeric vector or matrix of distances at which the Matern 
correlation function should be evaluated.</p>
</td></tr>
<tr><td><code id="maternCov_+3A_scale">scale</code></td>
<td>
<p>Scales correlations to covariances.</p>
</td></tr>
<tr><td><code id="maternCov_+3A_range">range</code></td>
<td>
<p>Matern range parameter.  Controls the decay of pointwise 
correlations as a function of distance.</p>
</td></tr>
<tr><td><code id="maternCov_+3A_smoothness">smoothness</code></td>
<td>
<p>Matern smoothness parameter.  Controls the number of 
process derivatives.</p>
</td></tr>
<tr><td><code id="maternCov_+3A_nugget">nugget</code></td>
<td>
<p>Spatial covariance nugget.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("coprecip")
attach(coprecip)

# compute spatial covariance matrix for an exponential covariance function
# using Colorado coordinates
Sigma = maternCov(fields::rdist.earth(coords.s), scale = 1, range = 250,
  smoothness = .5, nugget = 0)

</code></pre>

<hr>
<h2 id='maternEffectiveRange'>Compute effective range for Matern correlation to drop to a specified level</h2><span id='topic+maternEffectiveRange'></span>

<h3>Description</h3>

<p>The effective range for an isotropic spatial correlation function is 
commonly defined to be the distance beyond which the correlation becomes 
small, typically below .05.  Given range and smoothness parameters for a 
Matern covariance function, this function numerically searches for this 
distance.  Note that the scale is not important for this calculation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maternEffectiveRange(cor = 0.05, range = 1, smoothness = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maternEffectiveRange_+3A_cor">cor</code></td>
<td>
<p>Effective correlation to check for</p>
</td></tr>
<tr><td><code id="maternEffectiveRange_+3A_range">range</code></td>
<td>
<p>Matern range parameter.  Controls the decay of pointwise 
correlations as a function of distance.</p>
</td></tr>
<tr><td><code id="maternEffectiveRange_+3A_smoothness">smoothness</code></td>
<td>
<p>Matern smoothness parameter.  Controls the number of 
process derivatives.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# effective range for exponential covariance function with range = 1,
# which is theoretically known to equal -ln(.05)
maternEffectiveRange(cor = .05, range = 1, smoothness = .5)

</code></pre>

<hr>
<h2 id='mergeComposition'>Combine results from composition sampler</h2><span id='topic+mergeComposition'></span>

<h3>Description</h3>

<p>Combine results from composition sampler
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeComposition(xfull, yfull)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeComposition_+3A_xfull">xfull</code></td>
<td>
<p>Raw output from one run of the Rcpp/Armadillo composition sampler</p>
</td></tr>
<tr><td><code id="mergeComposition_+3A_yfull">yfull</code></td>
<td>
<p>Raw output from another run of the Rcpp/Armadillo composition sampler</p>
</td></tr>
</table>

<hr>
<h2 id='mergeCovmat'>Combine sample covariance matrices from two samples</h2><span id='topic+mergeCovmat'></span>

<h3>Description</h3>

<p>This function combines the sample covariance information from two samples (of 
the same phenomena) to return the sample covariance matric of the union of 
the two samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeCovmat(
  A.cov.xy,
  B.cov.xy,
  A.mean.x,
  A.mean.y,
  B.mean.x,
  B.mean.y,
  A.n,
  B.n
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeCovmat_+3A_a.cov.xy">A.cov.xy</code></td>
<td>
<p>sample covariance matrix from the first sample, 'A'</p>
</td></tr>
<tr><td><code id="mergeCovmat_+3A_b.cov.xy">B.cov.xy</code></td>
<td>
<p>sample covariance matrix from the second sample, 'B'</p>
</td></tr>
<tr><td><code id="mergeCovmat_+3A_a.mean.x">A.mean.x</code></td>
<td>
<p>sample mean from the first sample, 'A'</p>
</td></tr>
<tr><td><code id="mergeCovmat_+3A_a.mean.y">A.mean.y</code></td>
<td>
<p>sample mean from the first sample, 'A'</p>
</td></tr>
<tr><td><code id="mergeCovmat_+3A_b.mean.x">B.mean.x</code></td>
<td>
<p>sample mean from the second sample, 'B'</p>
</td></tr>
<tr><td><code id="mergeCovmat_+3A_b.mean.y">B.mean.y</code></td>
<td>
<p>sample mean from the second sample, 'B'</p>
</td></tr>
<tr><td><code id="mergeCovmat_+3A_a.n">A.n</code></td>
<td>
<p>sample size from the first sample, 'A'</p>
</td></tr>
<tr><td><code id="mergeCovmat_+3A_b.n">B.n</code></td>
<td>
<p>sample size from the second sample, 'B'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function assumes the data is normalized by n (the MLE estimator) 
instead of n-1 (the unbiased estimator).
</p>


<h3>References</h3>

<p>Pebay, P., 2008, Formulas for Robust, One-Pass Parallel Computation of Covariances and Arbitrary-Order Statistical Moments: Sandia Report.
</p>

<hr>
<h2 id='mergeMean'>Combine sample means from two samples</h2><span id='topic+mergeMean'></span>

<h3>Description</h3>

<p>This function combines the sample mean information from two samples (of 
the same phenomena) to return the sample mean of the union of the two 
samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeMean(x.mean, y.mean, x.n, y.n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeMean_+3A_x.mean">x.mean</code></td>
<td>
<p>sample mean from the first sample, 'x'</p>
</td></tr>
<tr><td><code id="mergeMean_+3A_y.mean">y.mean</code></td>
<td>
<p>sample mean from the second sample, 'y'</p>
</td></tr>
<tr><td><code id="mergeMean_+3A_x.n">x.n</code></td>
<td>
<p>sample size from the first sample, 'x'</p>
</td></tr>
<tr><td><code id="mergeMean_+3A_y.n">y.n</code></td>
<td>
<p>sample size from the second sample, 'y'</p>
</td></tr>
</table>

<hr>
<h2 id='mergeVar'>Combine sample variances from two samples</h2><span id='topic+mergeVar'></span>

<h3>Description</h3>

<p>This function combines the sample variance information from two samples (of 
the same phenomena) to return the sample variance of the union of the two 
samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeVar(x.var, y.var, x.mean, y.mean, x.n, y.n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeVar_+3A_x.var">x.var</code></td>
<td>
<p>sample variance from the first sample, 'x'</p>
</td></tr>
<tr><td><code id="mergeVar_+3A_y.var">y.var</code></td>
<td>
<p>sample variance from the second sample, 'y'</p>
</td></tr>
<tr><td><code id="mergeVar_+3A_x.mean">x.mean</code></td>
<td>
<p>sample mean from the first sample, 'x'</p>
</td></tr>
<tr><td><code id="mergeVar_+3A_y.mean">y.mean</code></td>
<td>
<p>sample mean from the second sample, 'y'</p>
</td></tr>
<tr><td><code id="mergeVar_+3A_x.n">x.n</code></td>
<td>
<p>sample size from the first sample, 'x'</p>
</td></tr>
<tr><td><code id="mergeVar_+3A_y.n">y.n</code></td>
<td>
<p>sample size from the second sample, 'y'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function assumes the data is normalized by n (the MLE estimator) 
instead of n-1 (the unbiased estimator).
</p>


<h3>References</h3>

<p>Chan, T.F., Golub, G.H., and LeVeque, R.J., 1979, Updating formulae and a pairwise algorithm for computing sample variances: Technical Report, Stanford University .
</p>

<hr>
<h2 id='plot.stData'>Plot stData objects</h2><span id='topic+plot.stData'></span>

<h3>Description</h3>

<p>This function provides basic plotting for telefit package data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stData'
plot(
  x,
  type = "response",
  t = NULL,
  p = NULL,
  map = "world",
  region = ".",
  coord.s = NULL,
  coord.r = NULL,
  zlim = NULL,
  fill.lab = NULL,
  lab.teleconnection = expression(alpha),
  fill.lab.width = 20,
  category.breaks = NULL,
  coords.knots = NULL,
  signif.telecon = F,
  dots = NULL,
  pattern = 1,
  lwd = 1.75,
  cutoff = 0.9,
  signif.level = 0.05,
  alpha = 0.2,
  zmid = 0,
  contour = c(F, F),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.stData_+3A_x">x</code></td>
<td>
<p>Object of class stData to plot.</p>
</td></tr>
<tr><td><code id="plot.stData_+3A_type">type</code></td>
<td>
<p>One of the following options to specify what type of plot to build
</p>

<dl>
<dt>response</dt><dd>  </dd>
<dt>sd.response</dt><dd><p> Plot standard deviation of response variable at each location. </p>
</dd>
<dt>cat.response</dt><dd>  </dd>
<dt>covariate</dt><dd>  </dd>
<dt>remote</dt><dd>  </dd>
<dt>teleconnection</dt><dd><p> This plot only applies if the stData object 
contains information about teleconnection effects,
i.e., if it is a simulated dataset or otherwise modified to include 
estimates of teleconnection effects. </p>
</dd>
<dt>remote_cor</dt><dd><p> This plot shows pointwise correlations between a local
coordinate and the remote covariates.  </p>
</dd>
<dt>eof</dt><dd>  </dd>
<dt>eof_scores</dt><dd>  </dd>
<dt>eof_scree</dt><dd> </dd>
<dt>eof_cor</dt><dd><p> This plot shows pointwise correlations with EOF patterns. </p>
</dd>
<dt>local_cor</dt><dd><p> This plot shows pointwise correlations with local covariates. </p>
</dd>
<dt>teleconnection_knot_local</dt><dd> </dd>
</dl>
</td></tr>
<tr><td><code id="plot.stData_+3A_t">t</code></td>
<td>
<p>timepoint to plot.  Will automatically plot the first timepoint if
t=NULL.</p>
</td></tr>
<tr><td><code id="plot.stData_+3A_p">p</code></td>
<td>
<p>column index of local covariate to plot if type='covariate'. Will 
automatically assume the local covariate data includes an intercept and will
plot the second column if p=NULL.</p>
</td></tr>
<tr><td><code id="plot.stData_+3A_map">map</code></td>
<td>
<p>name of map provided by the maps package. These include county, 
france, italy, nz, state, usa, world, world2.  By default, all stData plots
will include us state outlines.</p>
</td></tr>
<tr><td><code id="plot.stData_+3A_region">region</code></td>
<td>
<p>name of subregions to include. Defaults to . which includes 
all subregions. See documentation for map for more details.</p>
</td></tr>
<tr><td><code id="plot.stData_+3A_coord.s">coord.s</code></td>
<td>
<p>if plot type is 'teleconnection', specifies the longitude and 
latitude of local coordinate for which to plot teleconnection effects. if 
NULL, the middle local coordinate will be plotted.</p>
</td></tr>
<tr><td><code id="plot.stData_+3A_coord.r">coord.r</code></td>
<td>
<p>if plot type is 'teleconnection_local', specifes the longitude
and latitude of remote coordinate for which to plot associated teleconnection
effects.  if NULL, the middle remote coordinate will be plotted.</p>
</td></tr>
<tr><td><code id="plot.stData_+3A_zlim">zlim</code></td>
<td>
<p>c(min, max) vector that specifies the colorscale limits</p>
</td></tr>
<tr><td><code id="plot.stData_+3A_fill.lab">fill.lab</code></td>
<td>
<p>Optional label to override the default fill scale labels</p>
</td></tr>
<tr><td><code id="plot.stData_+3A_lab.teleconnection">lab.teleconnection</code></td>
<td>
<p>label used for fill scale in teleconnection plot</p>
</td></tr>
<tr><td><code id="plot.stData_+3A_fill.lab.width">fill.lab.width</code></td>
<td>
<p>line width for fill scale label</p>
</td></tr>
<tr><td><code id="plot.stData_+3A_category.breaks">category.breaks</code></td>
<td>
<p>[ncoords x ncats] list of breakpoints used for binning
responses into categories</p>
</td></tr>
<tr><td><code id="plot.stData_+3A_coords.knots">coords.knots</code></td>
<td>
<p>if plot type is 'remote', specifies the longitude and
latitude of knot locations to overlay on the 'remote' plot</p>
</td></tr>
<tr><td><code id="plot.stData_+3A_signif.telecon">signif.telecon</code></td>
<td>
<p>if TRUE, will highlight significant grid cells if the
plotting data contain a signif column</p>
</td></tr>
<tr><td><code id="plot.stData_+3A_dots">dots</code></td>
<td>
<p>additional named arguments with defaults to pass to additional 
functions</p>
</td></tr>
<tr><td><code id="plot.stData_+3A_pattern">pattern</code></td>
<td>
<p>if type=='eof' this specifies which (remote) EOF pattern to plot
or if type=='eof_scores' this (vector) specifies which (remote) EOF pattern
scores to plot</p>
</td></tr>
<tr><td><code id="plot.stData_+3A_lwd">lwd</code></td>
<td>
<p>line width for when plotting with signif.telecon==T</p>
</td></tr>
<tr><td><code id="plot.stData_+3A_cutoff">cutoff</code></td>
<td>
<p>Used to denote where this proportion of variance is achieved in
the eof_scree plots</p>
</td></tr>
<tr><td><code id="plot.stData_+3A_signif.level">signif.level</code></td>
<td>
<p>significance level for eof_cor significance highlighting</p>
</td></tr>
<tr><td><code id="plot.stData_+3A_alpha">alpha</code></td>
<td>
<p>the level of fading that should be applied to insignificant
grid boxes when plotting significant effects</p>
</td></tr>
<tr><td><code id="plot.stData_+3A_zmid">zmid</code></td>
<td>
<p>number that specifies the midpoint of the colorscale</p>
</td></tr>
<tr><td><code id="plot.stData_+3A_contour">contour</code></td>
<td>
<p>c(TRUE, TRUE) to plot local and remote responses as contours
vs. observations</p>
</td></tr>
<tr><td><code id="plot.stData_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object with the specified map
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("coprecip")
p = plot(coprecip)

</code></pre>

<hr>
<h2 id='plot.stFit'>Plot stFit objects</h2><span id='topic+plot.stFit'></span>

<h3>Description</h3>

<p>This function provides basic plotting for telefit package data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stFit'
plot(
  x,
  type = "density",
  stData = NULL,
  coord.s = NULL,
  coord.knot = NULL,
  text.size = NULL,
  axis.text.size = NULL,
  title.text.size = NULL,
  burn = 1,
  signif.telecon = F,
  p = 1,
  local.covariate = NULL,
  lwd = NULL,
  facet.signif = 3,
  stat.smooth.bw = NULL,
  stat.smooth.degree = NULL,
  dots = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.stFit_+3A_x">x</code></td>
<td>
<p>Object of class stFit to plot.</p>
</td></tr>
<tr><td><code id="plot.stFit_+3A_type">type</code></td>
<td>
<p>One of the following options to specify what type of plot to build
</p>

<dl>
<dt>traceplot</dt><dd>  </dd>
<dt>density</dt><dd>  </dd>
<dt>pairs</dt><dd>  </dd>
<dt>teleconnection</dt><dd>  </dd>
<dt>teleconnection_local</dt><dd>  </dd>
<dt>teleconnection_knot</dt><dd>  </dd>
<dt>teleconnection_knot_transect</dt><dd>  </dd>
<dt>teleconnection_knot_influence</dt><dd>  </dd>
<dt>beta</dt><dd> </dd>
</dl>
</td></tr>
<tr><td><code id="plot.stFit_+3A_stdata">stData</code></td>
<td>
<p>Object of class stData to provide coordinate and related
information for plotting estimated teleconnection effects</p>
</td></tr>
<tr><td><code id="plot.stFit_+3A_coord.s">coord.s</code></td>
<td>
<p>if plot type is 'teleconnection', specifies the longitude and 
latitude of local coordinate for which to plot estimated teleconnection 
effects. if NULL, the middle local coordinate will be plotted.</p>
</td></tr>
<tr><td><code id="plot.stFit_+3A_coord.knot">coord.knot</code></td>
<td>
<p>if plot type is 'teleconnection_knot_influence' or 
'teleconnection_knot_local', 
specifies the longitude and latitude of knot coordinate 
for which to plot influence of remote coefficient on remote covariates, or
the teleconnection coefficients associated with coord.knot</p>
</td></tr>
<tr><td><code id="plot.stFit_+3A_text.size">text.size</code></td>
<td>
<p>number specifying the size of text labels</p>
</td></tr>
<tr><td><code id="plot.stFit_+3A_axis.text.size">axis.text.size</code></td>
<td>
<p>number specifying the size of axis text labels</p>
</td></tr>
<tr><td><code id="plot.stFit_+3A_title.text.size">title.text.size</code></td>
<td>
<p>number specifying the size of title</p>
</td></tr>
<tr><td><code id="plot.stFit_+3A_burn">burn</code></td>
<td>
<p>number of observations to exclude from graph</p>
</td></tr>
<tr><td><code id="plot.stFit_+3A_signif.telecon">signif.telecon</code></td>
<td>
<p>if TRUE, will highlight significant teleconnection
effects when type=='teleconnection'</p>
</td></tr>
<tr><td><code id="plot.stFit_+3A_p">p</code></td>
<td>
<p>If stFit was fit with spatially varying coefficients, p specifies 
the index of the spatially varying coefficient to plot</p>
</td></tr>
<tr><td><code id="plot.stFit_+3A_local.covariate">local.covariate</code></td>
<td>
<p>data.frame with variables, 'lon.Y', 'lat.Y', 'x'
that will be plotted against teleconnection effects if 
type=='teleconnection_knot_transect'</p>
</td></tr>
<tr><td><code id="plot.stFit_+3A_lwd">lwd</code></td>
<td>
<p>specifies linewidth for plots that include reference lines</p>
</td></tr>
<tr><td><code id="plot.stFit_+3A_facet.signif">facet.signif</code></td>
<td>
<p>number of significant figures to round facet latitudes 
and longitudes for if type=='teleconnection_knot_transect'</p>
</td></tr>
<tr><td><code id="plot.stFit_+3A_stat.smooth.bw">stat.smooth.bw</code></td>
<td>
<p>if type=='teleconnection_knot_transect' this specifies
the bandwith of the non-parametric smooth of the estimates</p>
</td></tr>
<tr><td><code id="plot.stFit_+3A_stat.smooth.degree">stat.smooth.degree</code></td>
<td>
<p>if type=='teleconnection_knot_transect' this 
specifies the degree of the non-parametric smooth of the estimates</p>
</td></tr>
<tr><td><code id="plot.stFit_+3A_dots">dots</code></td>
<td>
<p>additional named arguments with defaults to pass to additional 
functions</p>
</td></tr>
<tr><td><code id="plot.stFit_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object with the specified map
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("coprecip.fit")
plot(coprecip.fit, burn = 50, type = 'trace')

</code></pre>

<hr>
<h2 id='plot.stPredict'>Plot stPredict objects</h2><span id='topic+plot.stPredict'></span>

<h3>Description</h3>

<p>This function provides basic plotting for telefit package data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stPredict'
plot(
  x,
  type = "prediction",
  t = NULL,
  stFit = NULL,
  stData = NULL,
  err.comparison = NULL,
  err.var = NULL,
  err.lab = err.var,
  pattern = 1,
  dots = NULL,
  burn = 1,
  signif.telecon = F,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.stPredict_+3A_x">x</code></td>
<td>
<p>Object of class stPredict to plot.</p>
</td></tr>
<tr><td><code id="plot.stPredict_+3A_type">type</code></td>
<td>
<p>One of the following options to specify what type of plot to build
</p>

<dl>
<dt>prediction</dt><dd><p> Spatial plot of predicted response variable for 
a given timepoint t. </p>
</dd>
<dt>residual</dt><dd><p> Spatial plot of residual for a given timepoint t.  
Note, this plot is only available if the model has been
evaluated and the predictions have been compared to another response
dataset. </p>
</dd>
<dt>observed</dt><dd><p> Spatial plot of observed response variable for a given
timepoint t. Note, this plot is only available if the model has been
evaluated and the predictions have been compared to another response
dataset.  </p>
</dd>
<dt>standard_error (or 'se')</dt><dd><p> Spatial plot of prediction standard 
errors for a given timepoint t.</p>
</dd>
<dt>local</dt><dd><p> Spatial plot of the local components of the
response variable for a given timepoint t.</p>
</dd>
<dt>remote</dt><dd><p> Spatial plot of the remote components of the 
response variable for a given timepoint t.</p>
</dd>
<dt>w</dt><dd><p> Spatial plot of the spatial noise component of the reponse 
variable for a given timepoint t.</p>
</dd>
<dt>correlation</dt><dd><p> Scatterplot of observed vs. predicted response 
variables for a given timepoint t.  Note, this plot is only available 
if the model has been evaluated and the predictions have been compared 
to another response dataset.   </p>
</dd>
<dt>teleconnection</dt><dd><p> Spatial plot of remote coefficients associated
with a location coord.s in the spatial response domain. </p>
</dd>
<dt>teleconnection_knot</dt><dd><p> Spatial plot of remote knot coefficients 
associated with a location coord.s in the spatial response domain. </p>
</dd>
<dt>teleconnection_knot_transect</dt><dd> </dd>
<dt>errors</dt><dd><p> Series of plots that measure overall prediction error 
across prediction timepoints. </p>
</dd>
<dt>cat.prediction</dt><dd><p> Spatial plot of the predicted response variable
category (i.e., above/below average) for a given timepoint t. </p>
</dd>
<dt>truth</dt><dd><p> Note, this plot is only available if the model has been
evaluated and the predictions have been compared to another response
dataset. </p>
</dd>
<dt>residual</dt><dd><p> Note, this plot is only available if the model has been
evaluated and the predictions have been compared to another response
dataset. </p>
</dd>
<dt>eof_alpha_knots</dt><dd><p> A map of the local domain where the plotted colors
show the remote influence coefficients mapped onto the eof pattern
specified by the &quot;pattern&quot; argument.   </p>
</dd>
</dl>
</td></tr>
<tr><td><code id="plot.stPredict_+3A_t">t</code></td>
<td>
<p>timepoint to plot.  Will automatically plot the first timepoint if
t=NULL.</p>
</td></tr>
<tr><td><code id="plot.stPredict_+3A_stfit">stFit</code></td>
<td>
<p>Object of class stFit to provide related
information and structures for plotting estimated teleconnection effects</p>
</td></tr>
<tr><td><code id="plot.stPredict_+3A_stdata">stData</code></td>
<td>
<p>Object of class stData to provide coordinate and related
information for plotting estimated teleconnection effects</p>
</td></tr>
<tr><td><code id="plot.stPredict_+3A_err.comparison">err.comparison</code></td>
<td>
<p>data.frame with Year column  and a column for a variable
that will be used to plot annual errors against</p>
</td></tr>
<tr><td><code id="plot.stPredict_+3A_err.var">err.var</code></td>
<td>
<p>name of variable in err.comparison for plotting against</p>
</td></tr>
<tr><td><code id="plot.stPredict_+3A_err.lab">err.lab</code></td>
<td>
<p>label for name of variable in err.comparison for plotting against</p>
</td></tr>
<tr><td><code id="plot.stPredict_+3A_pattern">pattern</code></td>
<td>
<p>if type=='eof_alpha_knots', this specified which eof the remote 
coefficients should be mapped onto and then plotted over the local domain</p>
</td></tr>
<tr><td><code id="plot.stPredict_+3A_dots">dots</code></td>
<td>
<p>additional named arguments with defaults to pass to additional 
functions</p>
</td></tr>
<tr><td><code id="plot.stPredict_+3A_burn">burn</code></td>
<td>
<p>number of observations to exclude from graph</p>
</td></tr>
<tr><td><code id="plot.stPredict_+3A_signif.telecon">signif.telecon</code></td>
<td>
<p>TRUE to highlight significant teleconnection effects</p>
</td></tr>
<tr><td><code id="plot.stPredict_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to lower-level plotting functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object with the specified map
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("coprecip.predict")
p = plot(coprecip.predict, t=1981)

</code></pre>

<hr>
<h2 id='plot.teleCor'>Plots teleconnection correlation maps</h2><span id='topic+plot.teleCor'></span>

<h3>Description</h3>

<p>This function provides basic plotting for analyses returned from cor.tel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'teleCor'
plot(
  x,
  signif = F,
  coord.s = NULL,
  map = "world",
  region = ".",
  zlim = NULL,
  dots = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.teleCor_+3A_x">x</code></td>
<td>
<p>object of class teleCor, containing pointwise correlations</p>
</td></tr>
<tr><td><code id="plot.teleCor_+3A_signif">signif</code></td>
<td>
<p>if TRUE, then teleCor must have a column labeled 'signif' that
indicates which correlations are significant.  These correlations will be
printed in bold, and the rest will be printed more lightly</p>
</td></tr>
<tr><td><code id="plot.teleCor_+3A_coord.s">coord.s</code></td>
<td>
<p>specifies the longitude and 
latitude of local coordinate for which to plot pointwise correlations 
(if type=='remote'). if 
NULL, the middle local coordinate will be plotted.</p>
</td></tr>
<tr><td><code id="plot.teleCor_+3A_map">map</code></td>
<td>
<p>name of map provided by the maps package. These include county, 
france, italy, nz, state, usa, world, world2.  By default, all stData plots
will include us state outlines.</p>
</td></tr>
<tr><td><code id="plot.teleCor_+3A_region">region</code></td>
<td>
<p>name of subregions to include. Defaults to . which includes 
all subregions. See documentation for map for more details.</p>
</td></tr>
<tr><td><code id="plot.teleCor_+3A_zlim">zlim</code></td>
<td>
<p>c(min, max) vector that specifies the colorscale limits</p>
</td></tr>
<tr><td><code id="plot.teleCor_+3A_dots">dots</code></td>
<td>
<p>additional named arguments with defaults to pass to additional 
functions</p>
</td></tr>
<tr><td><code id="plot.teleCor_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to lower-level plotting functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object with the specified map
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("coprecip")

cors = teleCor(coprecip)
p = plot(cors, coords.s = c(-105, 39.73))

</code></pre>

<hr>
<h2 id='rmatnorm'>Simulate matrices from matrix normal distributions</h2><span id='topic+rmatnorm'></span>

<h3>Description</h3>

<p>Draw random matrices from the matrix normal distribution </p>
<p style="text-align: center;"><code class="reqn">MN(M, U, V)</code>
</p>
  
<p>Note that an observation, <code class="reqn">X</code>, from this equation has the following 
distribution when vectorized </p>
<p style="text-align: center;"><code class="reqn">vec(X) ~ N(vec(M), kron(V, U) )</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>rmatnorm(n, U, V, M = matrix(0, nrow = nrow(U), ncol = nrow(V)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmatnorm_+3A_n">n</code></td>
<td>
<p>Number of random matrices to simulate</p>
</td></tr>
<tr><td><code id="rmatnorm_+3A_u">U</code></td>
<td>
<p>Covariance matrix defining dependence between rows</p>
</td></tr>
<tr><td><code id="rmatnorm_+3A_v">V</code></td>
<td>
<p>Covariance matrix defining dependence between columns</p>
</td></tr>
<tr><td><code id="rmatnorm_+3A_m">M</code></td>
<td>
<p>average value of each entry in the sampled matrices</p>
</td></tr>
</table>

<hr>
<h2 id='rwishart'>Random wishart matrix</h2><span id='topic+rwishart'></span>

<h3>Description</h3>

<p>Random wishart matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rwishart(V, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rwishart_+3A_v">V</code></td>
<td>
<p>symmetric positive definite p x p scale matrix</p>
</td></tr>
<tr><td><code id="rwishart_+3A_n">n</code></td>
<td>
<p>degrees of freedom (greater than p-1)</p>
</td></tr>
</table>

<hr>
<h2 id='stEval'>Basic evaluation of fit</h2><span id='topic+stEval'></span>

<h3>Description</h3>

<p>Provides basic measures for evalutating the fit.  Includes Brier skill score
against the climatology, MSPE, PPL, overall correlation, and a computation
of the coverage probabilities for confidence intervals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stEval(forecast, Y, clim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stEval_+3A_forecast">forecast</code></td>
<td>
<p>stPredict object containing predictions for Y</p>
</td></tr>
<tr><td><code id="stEval_+3A_y">Y</code></td>
<td>
<p>observed values of the response</p>
</td></tr>
<tr><td><code id="stEval_+3A_clim">clim</code></td>
<td>
<p>the climatology for the location in Y</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data("coprecip")
data("coprecip.predict")

clim = rowMeans(coprecip$Y)
coprecip.predict = stEval(coprecip.predict, coprecip$Y, clim)

</code></pre>

<hr>
<h2 id='stFit'>Fit the remote effects spatial process (RESP) model</h2><span id='topic+stFit'></span>

<h3>Description</h3>

<p>Fit the remote effects spatial process (RESP) model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stFit(
  stData = NULL,
  priors,
  maxIt,
  X = stData$X,
  Y = stData$Y,
  Z = stData$Z,
  coords.s = stData$coords.s,
  coords.r = stData$coords.r,
  rw.initsd = NULL,
  returnll = T,
  miles = T,
  C = 1,
  alpha = 0.44,
  localOnly = F,
  varying = F,
  remoteOnly = F,
  coords.knots
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stFit_+3A_stdata">stData</code></td>
<td>
<p>Object with class 'stData' containing data needed to fit this 
model. The data need only be manually entered if not using a stData object.</p>
</td></tr>
<tr><td><code id="stFit_+3A_priors">priors</code></td>
<td>
<p>A list containing parameters for the prior distributions. The
list needs to contain the following values
</p>

<dl>
<dt>beta</dt><dd><p> list(Lambda=matrix) specifying the prior covariance matrix
for the local effects if varying==F, otherwise 
list(Psi=matrix, nu=double) specifying the Inverse wishart prior 
distribution for the spatially varying coefficient process if 
varying==T. </p>
</dd>
<dt>cov.s</dt><dd><p> list(smoothness=double, range=c(min, max), 
variance=c(shape, rate), nugget=c(shape, rate)) </p>
</dd>
<dt>cov.r</dt><dd><p> list(smoothness=double, range=c(min, max), 
variance=c(shape, rate), nugget=c(shape, rate)) </p>
</dd>
</dl>
</td></tr>
<tr><td><code id="stFit_+3A_maxit">maxIt</code></td>
<td>
<p>number of iterations to run the MCMC chain for</p>
</td></tr>
<tr><td><code id="stFit_+3A_x">X</code></td>
<td>
<p>[ns, p, nt] array of design matrices with local covariates</p>
</td></tr>
<tr><td><code id="stFit_+3A_y">Y</code></td>
<td>
<p>[ns, nt] matrix with response data</p>
</td></tr>
<tr><td><code id="stFit_+3A_z">Z</code></td>
<td>
<p>[nr, nt] matrix with remote covariates</p>
</td></tr>
<tr><td><code id="stFit_+3A_coords.s">coords.s</code></td>
<td>
<p>matrix with coordinates where responses were 
observed (lon, lat)</p>
</td></tr>
<tr><td><code id="stFit_+3A_coords.r">coords.r</code></td>
<td>
<p>matrix with coordinates where remote covariates
were observed (lon, lat)</p>
</td></tr>
<tr><td><code id="stFit_+3A_rw.initsd">rw.initsd</code></td>
<td>
<p>A list containing initial standard deviation parameters for
the MCMC parameters requiring random walk updates
</p>

<dl>
<dt>cov.s</dt><dd><p> list(range=double, nugget=double) </p>
</dd>
<dt>cov.r</dt><dd><p> list(range=double, variance=double, nugget=double) </p>
</dd>
</dl>
</td></tr>
<tr><td><code id="stFit_+3A_returnll">returnll</code></td>
<td>
<p>TRUE to compute the model log-likelihood at each iteration</p>
</td></tr>
<tr><td><code id="stFit_+3A_miles">miles</code></td>
<td>
<p>TRUE if covariance matrix distances should be in miles, FALSE 
for kilometers</p>
</td></tr>
<tr><td><code id="stFit_+3A_c">C</code></td>
<td>
<p>scaling factor used in adapting random walk proposal variances.</p>
</td></tr>
<tr><td><code id="stFit_+3A_alpha">alpha</code></td>
<td>
<p>target acceptance rate for random walk proposals.</p>
</td></tr>
<tr><td><code id="stFit_+3A_localonly">localOnly</code></td>
<td>
<p>TRUE to fit the model without the teleconnection effects
(typically for evaluating impact of teleconnection effects)</p>
</td></tr>
<tr><td><code id="stFit_+3A_varying">varying</code></td>
<td>
<p>(depreceated) TRUE to fit the model with spatially varying local coefficients</p>
</td></tr>
<tr><td><code id="stFit_+3A_remoteonly">remoteOnly</code></td>
<td>
<p>TRUE to fit the model without local effects.  This will 
fit a local intercept, but will not incorporate local covariates.</p>
</td></tr>
<tr><td><code id="stFit_+3A_coords.knots">coords.knots</code></td>
<td>
<p>matrix with coordinates where remote teleconnections
will be based (lon, lat)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(foreach)
library(itertools)

set.seed(2018)

data("coprecip")
data("coprecip.fit")
attach(coprecip)

coprecip.fit = stFit(stData = coprecip, priors = coprecip.fit$priors, 
                     maxIt = 10, coords.knots = coprecip.fit$coords.knots)
</code></pre>

<hr>
<h2 id='stLL'>Compute log likelihood for model</h2><span id='topic+stLL'></span>

<h3>Description</h3>

<p>Compute log likelihood for model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stLL(
  stData,
  stFit,
  beta,
  sigmasq_y,
  sigmasq_r,
  sigmasq_eps,
  rho_y,
  rho_r,
  X = stData$X,
  Y = stData$Y,
  Z = stData$Z,
  coords.s = stData$coords.s,
  coords.r = stData$coords.r,
  coords.knots = stFit$coords.knots,
  miles = TRUE,
  sigmasq_r_eps
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stLL_+3A_stdata">stData</code></td>
<td>
<p>Object with class 'stData' containing data needed to fit this 
model. The data need only be manually entered if not using a stData object.</p>
</td></tr>
<tr><td><code id="stLL_+3A_stfit">stFit</code></td>
<td>
<p>Object with class 'stFit' containing posterior parameter samples
needed to composition sample the teleconnection effects and generate 
posterior predictions. The data needed from stFit need only be manually 
entered if not using a stData object.</p>
</td></tr>
<tr><td><code id="stLL_+3A_beta">beta</code></td>
<td>
<p>values of <code class="reqn">\beta</code> at which to evaluate the likelihood</p>
</td></tr>
<tr><td><code id="stLL_+3A_sigmasq_y">sigmasq_y</code></td>
<td>
<p>values of <code class="reqn">\sigma^2_w</code> at which to evaluate the
likelihood</p>
</td></tr>
<tr><td><code id="stLL_+3A_sigmasq_r">sigmasq_r</code></td>
<td>
<p>values of <code class="reqn">\sigma^2_\alpha</code> at which to evaluate the
likelihood</p>
</td></tr>
<tr><td><code id="stLL_+3A_sigmasq_eps">sigmasq_eps</code></td>
<td>
<p>values of <code class="reqn">\sigma^2_\varepsilon</code> at which to evaluate 
the likelihood</p>
</td></tr>
<tr><td><code id="stLL_+3A_rho_y">rho_y</code></td>
<td>
<p>values of <code class="reqn">\rho_w</code> at which to evaluate  the likelihood</p>
</td></tr>
<tr><td><code id="stLL_+3A_rho_r">rho_r</code></td>
<td>
<p>values of <code class="reqn">\rho_\alpha</code> at which to evaluate the likelihood</p>
</td></tr>
<tr><td><code id="stLL_+3A_x">X</code></td>
<td>
<p>[ns, p, nt] array of design matrices with local covariates</p>
</td></tr>
<tr><td><code id="stLL_+3A_y">Y</code></td>
<td>
<p>[ns, nt] matrix with response data</p>
</td></tr>
<tr><td><code id="stLL_+3A_z">Z</code></td>
<td>
<p>[nr, nt] matrix with remote covariates</p>
</td></tr>
<tr><td><code id="stLL_+3A_coords.s">coords.s</code></td>
<td>
<p>matrix with coordinates where responses were 
observed (lon, lat)</p>
</td></tr>
<tr><td><code id="stLL_+3A_coords.r">coords.r</code></td>
<td>
<p>matrix with coordinates where remote covariates
were observed (lon, lat)</p>
</td></tr>
<tr><td><code id="stLL_+3A_coords.knots">coords.knots</code></td>
<td>
<p>matrix with coordinates of knots for remote covariates
(lon, lat)</p>
</td></tr>
<tr><td><code id="stLL_+3A_miles">miles</code></td>
<td>
<p>TRUE if distances should be computed in miles (kilometers otherwise)</p>
</td></tr>
<tr><td><code id="stLL_+3A_sigmasq_r_eps">sigmasq_r_eps</code></td>
<td>
<p>values of <code class="reqn">\sigma^2_{\alpha_\varepsilon}</code> at which 
to evaluate the likelihood</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(foreach)
library(itertools)

set.seed(2018)

data("coprecip")
data("coprecip.fit")
attach(coprecip)

ests = coef(coprecip.fit, burn = 50)

ll = stLL(stData = coprecip, stFit = coprecip.fit, 
          beta = matrix(ests$beta, ncol = 2), 
          sigmasq_y = ests$sigmasq_y, sigmasq_r = ests$sigmasq_r, 
          sigmasq_eps = ests$sigmasq_eps,
          rho_y = ests$rho_y, rho_r = ests$rho_r, 
          sigmasq_r_eps = 0)
</code></pre>

<hr>
<h2 id='stPredict'>Compute forecasts based on posterior samples</h2><span id='topic+stPredict'></span>

<h3>Description</h3>

<p>Predict response at new timepoints by drawing samples of the response from
the posterior predictive distribution.  Since this requires sampling 
teleconnection effects, this method can return estimates of the 
teleconnection effects as a by-product.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stPredict(
  stFit,
  stData,
  stDataNew,
  burn = 1,
  prob = 0.95,
  ncores = 1,
  conf = 0.95,
  tLabs = stDataNew$tLabs,
  X = stData$X,
  Y = stData$Y,
  Z = stData$Z,
  Xnew = stDataNew$X,
  Znew = stDataNew$Z,
  coords.s = stData$coords.s,
  coords.r = stData$coords.r,
  returnAlphas = T,
  cat.probs = c(1/3, 2/3),
  returnFullAlphas = F
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stPredict_+3A_stfit">stFit</code></td>
<td>
<p>Object with class 'stFit' containing posterior parameter samples
needed to composition sample the teleconnection effects and generate 
posterior predictions. The data needed from stFit need only be manually 
entered if not using a stData object.</p>
</td></tr>
<tr><td><code id="stPredict_+3A_stdata">stData</code></td>
<td>
<p>Object with class 'stData' containing data needed to fit this 
model. The data need only be manually entered if not using a stData object.</p>
</td></tr>
<tr><td><code id="stPredict_+3A_stdatanew">stDataNew</code></td>
<td>
<p>object of class stData that includes information needed for 
making forecasts.  If response data is included, this function will 
automatically run stEval using the empirical climatology as the reference
forecast</p>
</td></tr>
<tr><td><code id="stPredict_+3A_burn">burn</code></td>
<td>
<p>number of posterior samples to burn before drawing composition
samples</p>
</td></tr>
<tr><td><code id="stPredict_+3A_prob">prob</code></td>
<td>
<p>confidence level for approximate confidence intervals of 
teleconnection effects (only needed if returnAlphas==TRUE)</p>
</td></tr>
<tr><td><code id="stPredict_+3A_ncores">ncores</code></td>
<td>
<p>Since the teleconnection effects and posterior predictions can 
be sampled in parallel, this parameter lets users specify the number of 
cores to use to draw teleconnection and prediction samples</p>
</td></tr>
<tr><td><code id="stPredict_+3A_conf">conf</code></td>
<td>
<p>Parameter specifying the HPD level to compute for posterior 
predictive samples</p>
</td></tr>
<tr><td><code id="stPredict_+3A_tlabs">tLabs</code></td>
<td>
<p>Forecast timepoint labels</p>
</td></tr>
<tr><td><code id="stPredict_+3A_x">X</code></td>
<td>
<p>[ns, p, nt] array of design matrices with local covariates</p>
</td></tr>
<tr><td><code id="stPredict_+3A_y">Y</code></td>
<td>
<p>[ns, nt] matrix with response data</p>
</td></tr>
<tr><td><code id="stPredict_+3A_z">Z</code></td>
<td>
<p>[nr, nt] matrix with remote covariates</p>
</td></tr>
<tr><td><code id="stPredict_+3A_xnew">Xnew</code></td>
<td>
<p>[ns, p, nt0] array of design matrices with local covariates 
at forecast timepoints</p>
</td></tr>
<tr><td><code id="stPredict_+3A_znew">Znew</code></td>
<td>
<p>[nr, nt0] matrix with remote covariates at forecast timepoints</p>
</td></tr>
<tr><td><code id="stPredict_+3A_coords.s">coords.s</code></td>
<td>
<p>matrix with coordinates where responses were 
observed (lon, lat)</p>
</td></tr>
<tr><td><code id="stPredict_+3A_coords.r">coords.r</code></td>
<td>
<p>matrix with coordinates where remote covariates
were observed (lon, lat)</p>
</td></tr>
<tr><td><code id="stPredict_+3A_returnalphas">returnAlphas</code></td>
<td>
<p>TRUE to return the teleconnection effects sampled 
at knot locations.  Note that only basic summary information about the 
teleconnection effects will be returned.</p>
</td></tr>
<tr><td><code id="stPredict_+3A_cat.probs">cat.probs</code></td>
<td>
<p>vector of probabilities for also returning categorical 
predictions from the posterior prediction samples; NULL otherwise</p>
</td></tr>
<tr><td><code id="stPredict_+3A_returnfullalphas">returnFullAlphas</code></td>
<td>
<p>TRUE to return the teleconnection effects.
Note that only basic summary information about the 
teleconnection effects will be returned.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2018)
  
data("coprecip")
data("coprecip.fit")

coprecip.predict = stPredict(stFit = coprecip.fit, stData = coprecip, 
                             stDataNew = coprecip, burn = 90, 
                             returnFullAlphas = FALSE)
</code></pre>

<hr>
<h2 id='stSimulate'>Simulate responses from the spatio-temporal teleconnection model</h2><span id='topic+stSimulate'></span>

<h3>Description</h3>

<p>This function simulates spatio-temporal data. The intention is that data Y and latent 
parameters alpha will be generated using provided covariates X and Z; 
spatial domains coords.s, coords.r, and coords.knots; and model parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stSimulate(dat.train, dat.test, coords.knots, params, miles = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stSimulate_+3A_dat.train">dat.train</code></td>
<td>
<p>stData object with training data to simulate new Y values for</p>
</td></tr>
<tr><td><code id="stSimulate_+3A_dat.test">dat.test</code></td>
<td>
<p>stData object with test data to simulate new Y values for</p>
</td></tr>
<tr><td><code id="stSimulate_+3A_coords.knots">coords.knots</code></td>
<td>
<p>matrix with coordinates of knots for remote covariates
(lon, lat)</p>
</td></tr>
<tr><td><code id="stSimulate_+3A_params">params</code></td>
<td>
<p>A list containing model parameters for use in simulation
</p>

<dl>
<dt>beta</dt><dd><p> vector with fixed effect coefficients </p>
</dd>
<dt>cov.s</dt><dd><p> list(smoothness=double, range=double, variance=double, nugget=double) </p>
</dd>
<dt>cov.r</dt><dd><p> list(smoothness=double, range=double, variance=double, nugget=double) </p>
</dd>
</dl>
</td></tr>
<tr><td><code id="stSimulate_+3A_miles">miles</code></td>
<td>
<p>TRUE to compute distances for evaluating covariance functions 
in miles.  This is important since the interpretations of the cov.r and 
cov.s parameters depend on the units with which distance is measured.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2018)
  
data("coprecip")
data("coprecip.fit")

coprecip.predict = stPredict(stFit = coprecip.fit, stData = coprecip, 
                             stDataNew = coprecip, burn = 90, 
                             returnFullAlphas = FALSE)
</code></pre>

<hr>
<h2 id='stVIF'>Computes variance inflation factors for fixed effects of the teleconnection model</h2><span id='topic+stVIF'></span>

<h3>Description</h3>

<p>VIFs will be computed at the posterior mean of all covariance parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stVIF(stData, stFit, burn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stVIF_+3A_stdata">stData</code></td>
<td>
<p>Object with class 'stData' containing data needed to fit this 
model.</p>
</td></tr>
<tr><td><code id="stVIF_+3A_stfit">stFit</code></td>
<td>
<p>Object with class 'stFit' containing posterior parameter samples
needed to composition sample the teleconnection effects and generate 
posterior predictions.</p>
</td></tr>
<tr><td><code id="stVIF_+3A_burn">burn</code></td>
<td>
<p>number of posterior samples to burn before drawing composition
samples</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data("coprecip")
data("coprecip.fit")

stVIF(stData = coprecip, stFit = coprecip.fit, burn = 50)

</code></pre>

<hr>
<h2 id='summariseAlpha'>Summarize alphas</h2><span id='topic+summariseAlpha'></span>

<h3>Description</h3>

<p>This function computes approximate normal intervals, etc. for fitted alphas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summariseAlpha(alpha, prob = 0.95, coords.s, coords.r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summariseAlpha_+3A_alpha">alpha</code></td>
<td>
<p>structure containing posterior inference for remote coefficients</p>
</td></tr>
<tr><td><code id="summariseAlpha_+3A_prob">prob</code></td>
<td>
<p>confidence level for confidence intervals and significance</p>
</td></tr>
<tr><td><code id="summariseAlpha_+3A_coords.s">coords.s</code></td>
<td>
<p>matrix with coordinates where responses were 
observed (lon, lat)</p>
</td></tr>
<tr><td><code id="summariseAlpha_+3A_coords.r">coords.r</code></td>
<td>
<p>matrix with coordinates where remote covariates
were observed (lon, lat)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("coprecip")
data("coprecip.fit")
attach(coprecip)

# sample posterior predictive distributions AND estimate teleconnection effects
coprecip.precict = stPredict(stFit = coprecip.fit, stData = coprecip, 
                             stDataNew = coprecip, burn = 90, 
                             returnFullAlphas = TRUE)

alpha.90 = summariseAlpha(alpha = coprecip.precict$alpha, prob = .9, 
                          coords.s = coords.s, coords.r = coords.r)

## End(Not run)
</code></pre>

<hr>
<h2 id='summariseEOFAlpha'>Summarize eof-mapped alphas</h2><span id='topic+summariseEOFAlpha'></span>

<h3>Description</h3>

<p>This function computes approximate normal intervals, etc. for fitted 
eof-mapped alphas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summariseEOFAlpha(eof_alpha, prob = 0.95, coords.s)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summariseEOFAlpha_+3A_eof_alpha">eof_alpha</code></td>
<td>
<p>structure containing posterior inference for transformed 
remote coefficients</p>
</td></tr>
<tr><td><code id="summariseEOFAlpha_+3A_prob">prob</code></td>
<td>
<p>confidence level for confidence intervals and significance</p>
</td></tr>
<tr><td><code id="summariseEOFAlpha_+3A_coords.s">coords.s</code></td>
<td>
<p>matrix with coordinates where responses were 
observed (lon, lat)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data("coprecip.predict")
attach(coprecip.predict)

alpha.eof.90 = summariseEOFAlpha(eof_alpha = eof_alpha_knots, prob = .9, 
  coords.s = coords.s)

</code></pre>

<hr>
<h2 id='summary.stPredict'>Plot stPredict objects</h2><span id='topic+summary.stPredict'></span>

<h3>Description</h3>

<p>This function prints basic summary info for telefit stPredict objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stPredict'
summary(object, t = NULL, digits = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.stPredict_+3A_object">object</code></td>
<td>
<p>Object of class stPredict to summarise</p>
</td></tr>
<tr><td><code id="summary.stPredict_+3A_t">t</code></td>
<td>
<p>timepoint to plot.  Will automatically plot all timepoints and overall
summary if NULL.</p>
</td></tr>
<tr><td><code id="summary.stPredict_+3A_digits">digits</code></td>
<td>
<p>Number of digits to pass to signif, if not NULL.</p>
</td></tr>
<tr><td><code id="summary.stPredict_+3A_...">...</code></td>
<td>
<p>S3 generic/method consistency</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data("coprecip.predict")
summary(coprecip.predict)

</code></pre>

<hr>
<h2 id='svcFit'>Fit a spatially varying coefficient model</h2><span id='topic+svcFit'></span>

<h3>Description</h3>

<p>Fit a spatially varying coefficient model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svcFit(
  y,
  X,
  z,
  coords,
  miles = T,
  priors,
  nSamples,
  thin = 1,
  rw.initsd = 0.1,
  inits = list(),
  C = 1,
  alpha = 0.44
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svcFit_+3A_y">y</code></td>
<td>
<p>vector containing responses for each timepoint.  vector is blocked
by timepoint.</p>
</td></tr>
<tr><td><code id="svcFit_+3A_x">X</code></td>
<td>
<p>matrix containing local covariates for each timepoint.  each row
are the covariates for one location and timepoint.  matrix is blocked by
timepoint.</p>
</td></tr>
<tr><td><code id="svcFit_+3A_z">z</code></td>
<td>
<p>matrix containing remote covariates.  each column has remote 
covariates for one timepoint.</p>
</td></tr>
<tr><td><code id="svcFit_+3A_coords">coords</code></td>
<td>
<p>n x 2 matrix containing lon-lat coordinates for locations.</p>
</td></tr>
<tr><td><code id="svcFit_+3A_miles">miles</code></td>
<td>
<p>T/F for whether to compute great circle distances in miles (T)
or km (F)</p>
</td></tr>
<tr><td><code id="svcFit_+3A_priors">priors</code></td>
<td>
<p>A list containing parameters for the prior distributions. The
list needs to contain the following values
</p>

<dl>
<dt>T</dt><dd><p> list(Psi=matrix, nu=double) specifying the Inverse wishart 
prior distribution for the spatially varying coefficient 
process. </p>
</dd>
<dt>beta</dt><dd><p> list(Linv=matrix) specifying the prior precision matrix 
for the fixed local covariates. </p>
</dd>
<dt>sigmasq</dt><dd><p> list(a=double, b=double) specifying the prior shape and
scale parameters for the covariance scale and nugget 
parameters. </p>
</dd>
<dt>rho</dt><dd><p> list(L=double, U=double) specifying the lower and upper 
bounds for the spatial range parameter. </p>
</dd>
<dt>cov</dt><dd><p> list(nu=double) specifying the smoothness for the 
matern covariance.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="svcFit_+3A_nsamples">nSamples</code></td>
<td>
<p>number of MCMC iterations to run</p>
</td></tr>
<tr><td><code id="svcFit_+3A_thin">thin</code></td>
<td>
<p>MCMC thinning; defaults to no thinning (thin=1)</p>
</td></tr>
<tr><td><code id="svcFit_+3A_rw.initsd">rw.initsd</code></td>
<td>
<p>Initial proposal standard deviation for RW samplers</p>
</td></tr>
<tr><td><code id="svcFit_+3A_inits">inits</code></td>
<td>
<p>optional list containing starting parameters for MCMC sampler</p>
</td></tr>
<tr><td><code id="svcFit_+3A_c">C</code></td>
<td>
<p>scaling factor used in adapting random walk proposal variances.</p>
</td></tr>
<tr><td><code id="svcFit_+3A_alpha">alpha</code></td>
<td>
<p>target acceptance rate for random walk proposals.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(fields)
library(mvtnorm)

set.seed(2018)

# set key parameters
dims = list(N=100, nt=3, k=2, p=2)
params = list(sigmasq=.2, rho=.3, eps=.5, nu=.5)

# generate parameters and data
coords = matrix( runif(2 * dims$N), ncol = 2 )
X = matrix( rnorm(dims$p * dims$N * dims$nt), ncol = dims$p )
beta = c(-1, .5)
z = matrix( rnorm(dims$k * dims$nt), ncol = dims$nt)
H = maternCov(rdist.earth(coords), scale = params$sigmasq, range = params$rho,
              smoothness = params$nu, nugget = params$sigmasq * params$eps)
Hinv = solve(H)
Tm = matrix(c(.5,.2, .2, .5), ncol=2)/2
theta = kronSamp(Hinv, Tm)


# generate response
xb = X %*% beta
zt = as.numeric(apply(z, 2, function(d) { 
  kronecker(diag(dims$N), t(d)) %*% theta }))
w = kronSamp(diag(dims$nt), H)
y =  xb + zt + w


# fit model
it = 100
priors = list(
  T = list(Psi = .1*diag(dims$k), nu = dims$k),
  beta = list(Linv = diag(dims$p) * 1e-2),
  sigmasq = list(a=2, b=1),
  rho = list(L=0, U=1),
  cov = list(nu=.5)
)

fit = svcFit(y=y, X=X, z=z, coords=coords, priors=priors, nSamples=it)


#
# predict at new timepoints
#

# generate parameters and data
nt0 = 3
Xn = matrix( rnorm(dims$p * dims$N * nt0), ncol = dims$p )
zn = matrix( rnorm(dims$k * nt0), ncol = nt0)

# generate response
xbn = Xn %*% beta
ztn = as.numeric(apply(zn, 2, function(d) { 
  kronecker(diag(dims$N), t(d)) %*% theta }))
wn = kronSamp(diag(nt0), H)
yn =  xbn + ztn + wn

# predict responses
pred = svcPredict(fit, Xn, zn, burn = 50)

</code></pre>

<hr>
<h2 id='svcPredict'>Make predictions using a fitted varying coefficient model</h2><span id='topic+svcPredict'></span>

<h3>Description</h3>

<p>Make predictions using a fitted varying coefficient model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svcPredict(
  fit,
  Xn = NULL,
  Zn = NULL,
  stData = NULL,
  stDataNew = NULL,
  burn = 0,
  cat.probs = c(1/3, 2/3),
  conf = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svcPredict_+3A_fit">fit</code></td>
<td>
<p>svcFit object containing posterior samples</p>
</td></tr>
<tr><td><code id="svcPredict_+3A_xn">Xn</code></td>
<td>
<p>[nr*nt, p] matrix of local covariates at new timepoint</p>
</td></tr>
<tr><td><code id="svcPredict_+3A_zn">Zn</code></td>
<td>
<p>[nr, nt] matrix of remote covariates at new timepoints</p>
</td></tr>
<tr><td><code id="svcPredict_+3A_stdata">stData</code></td>
<td>
<p>Object with class 'stData' containing data needed to fit this 
model. The data is used to compute empirical quantiles for making 
categorical predictions.</p>
</td></tr>
<tr><td><code id="svcPredict_+3A_stdatanew">stDataNew</code></td>
<td>
<p>object of class stData that includes information needed for 
making forecasts.</p>
</td></tr>
<tr><td><code id="svcPredict_+3A_burn">burn</code></td>
<td>
<p>number of posterior samples to burn from fit</p>
</td></tr>
<tr><td><code id="svcPredict_+3A_cat.probs">cat.probs</code></td>
<td>
<p>vector of probabilities for also returning categorical 
predictions from the posterior prediction samples; NULL otherwise</p>
</td></tr>
<tr><td><code id="svcPredict_+3A_conf">conf</code></td>
<td>
<p>Parameter specifying the HPD level to compute for posterior 
predictive samples</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(fields)
library(mvtnorm)

set.seed(2018)

# set key parameters
dims = list(N=100, nt=3, k=2, p=2)
params = list(sigmasq=.2, rho=.3, eps=.5, nu=.5)

# generate parameters and data
coords = matrix( runif(2 * dims$N), ncol = 2 )
X = matrix( rnorm(dims$p * dims$N * dims$nt), ncol = dims$p )
beta = c(-1, .5)
z = matrix( rnorm(dims$k * dims$nt), ncol = dims$nt)
H = maternCov(rdist.earth(coords), scale = params$sigmasq, range = params$rho,
              smoothness = params$nu, nugget = params$sigmasq * params$eps)
Hinv = solve(H)
Tm = matrix(c(.5,.2, .2, .5), ncol=2)/2
theta = kronSamp(Hinv, Tm)


# generate response
xb = X %*% beta
zt = as.numeric(apply(z, 2, function(d) { 
  kronecker(diag(dims$N), t(d)) %*% theta }))
w = kronSamp(diag(dims$nt), H)
y =  xb + zt + w


# fit model
it = 100
priors = list(
  T = list(Psi = .1*diag(dims$k), nu = dims$k),
  beta = list(Linv = diag(dims$p) * 1e-2),
  sigmasq = list(a=2, b=1),
  rho = list(L=0, U=1),
  cov = list(nu=.5)
)

fit = svcFit(y=y, X=X, z=z, coords=coords, priors=priors, nSamples=it)


#
# predict at new timepoints
#

# generate parameters and data
nt0 = 3
Xn = matrix( rnorm(dims$p * dims$N * nt0), ncol = dims$p )
zn = matrix( rnorm(dims$k * nt0), ncol = nt0)

# generate response
xbn = Xn %*% beta
ztn = as.numeric(apply(zn, 2, function(d) { 
  kronecker(diag(dims$N), t(d)) %*% theta }))
wn = kronSamp(diag(nt0), H)
yn =  xbn + ztn + wn

# predict responses
pred = svcPredict(fit, Xn, zn, burn = 50)

</code></pre>

<hr>
<h2 id='teleCor'>Pointwise correlations for an exploratory teleconnection analysis</h2><span id='topic+teleCor'></span>

<h3>Description</h3>

<p>Computes empirical correlations between rows of <code>Y</code> and <code>Z</code>, 
for use as exploratory analysis of teleconnection patterns between locations 
indexed by <code>coords.s</code> and <code>coords.r</code>.  Optionally, an <code>stData</code>
object containing <code>Y</code> and <code>Z</code> can be passed instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>teleCor(
  stData = NULL,
  Y = stData$Y,
  Z = stData$Z,
  coords.s = stData$coords.s,
  coords.r = stData$coords.r
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="teleCor_+3A_stdata">stData</code></td>
<td>
<p>stData object containing data to analyze</p>
</td></tr>
<tr><td><code id="teleCor_+3A_y">Y</code></td>
<td>
<p>[ny x nt] a matrix composed of <code class="reqn">ny</code> row vectors, each of which 
contains <code class="reqn">nt</code> observations fom a different spatial location.  Spatial 
locations for <code>Y</code> are indexed by <code>coords.s</code>.</p>
</td></tr>
<tr><td><code id="teleCor_+3A_z">Z</code></td>
<td>
<p>[nz x nt] a matrix composed of <code class="reqn">nz</code> row vectors each of which
contains <code class="reqn">nt</code> observations from a different spatial location.  Spatial
locations for <code>Z</code> are indexed by <code>coords.r</code>.</p>
</td></tr>
<tr><td><code id="teleCor_+3A_coords.s">coords.s</code></td>
<td>
<p>coordinates of locations in Y</p>
</td></tr>
<tr><td><code id="teleCor_+3A_coords.r">coords.r</code></td>
<td>
<p>coordinates of locations in Z</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with a matrix 'cor' containing correlations.  The columns index
remote coordinates, while the rows index the local coordinates.  The 
returned list also includes the coordinates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("coprecip")

cors = teleCor(coprecip)

</code></pre>

<hr>
<h2 id='telefit'>Tools for modeling teleconnections</h2><span id='topic+telefit'></span>

<h3>Description</h3>

<p>The package <span class="pkg">telefit</span> provides functions for fitting the remote 
effects spatial process (RESP) model.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
