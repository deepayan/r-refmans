<!DOCTYPE html><html><head><title>Help for package spatstat.local</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spatstat.local}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bw.loccit'>
<p>Cross Validated Bandwidth Selection for Locally Fitted Point Process Model</p></a></li>
<li><a href='#bw.locppm'>
<p>Cross Validated Bandwidth Selection for Locally Fitted Point Process Model</p></a></li>
<li><a href='#homtest'>
<p>Homogeneity Test for Local Poisson or Gibbs Model</p></a></li>
<li><a href='#homtestmap'>
<p>Test Statistic for Homogeneity Test</p></a></li>
<li><a href='#loccit'>
<p>Locally Fitted Cluster or Cox Point Process Model</p></a></li>
<li><a href='#locmincon'>
<p>Locally Fitted Cluster or Cox Point Process Model</p></a></li>
<li><a href='#locppm'>
<p>Locally Fitted Poisson or Gibbs Point Process Model</p></a></li>
<li><a href='#methods.locmincon'><p>Methods for Local Cluster or Cox Models</p></a></li>
<li><a href='#methods.locppm'><p>Methods for Local Gibbs Models</p></a></li>
<li><a href='#plot.loccit'>
<p>Plot a Locally Fitted Cluster or Cox Point Process Model</p></a></li>
<li><a href='#plot.locmincon'>
<p>Plot a Locally Fitted Cluster or Cox Point Process Model</p></a></li>
<li><a href='#plot.locppm'>
<p>Plot a Locally Fitted Poisson or Gibbs Model</p></a></li>
<li><a href='#predict.loccit'>
<p>Prediction for Locally-Fitted Cox or Cluster Model</p></a></li>
<li><a href='#predict.locppm'>
<p>Prediction of a Locally Fitted Poisson or Gibbs Point Process Model</p></a></li>
<li><a href='#psib.loccit'>
<p>Sibling Probability of Locally Fitted Cluster Point Process</p></a></li>
<li><a href='#Smooth.locmincon'>
<p>Smooth a Locally Fitted Cluster or Cox Point Process Model</p></a></li>
<li><a href='#Smooth.locppm'>
<p>Smooth a locally fitted Gibbs model</p></a></li>
<li><a href='#spatstat.local-internal'><p>Internal Functions of the spatstat.local Package</p></a></li>
<li><a href='#spatstat.local-package'>
<p>Local Composite Likelihood</p></a></li>
<li><a href='#ttestmap'>
<p>Test of Effect in Locally Fitted Point Process Model</p></a></li>
<li><a href='#with.locmincon'>
<p>Evaluate an Expression for a Locally Fitted Model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Extension to 'spatstat' for Local Composite Likelihood</td>
</tr>
<tr>
<td>Version:</td>
<td>5.0-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-11-12</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), spatstat.data (&ge; 3.0), spatstat.sparse (&ge;
3.0), spatstat.geom (&ge; 3.0), spatstat.random (&ge; 3.0),
spatstat.explore, spatstat.model (&ge; 3.0), spatstat (&ge; 3.0),
stats, graphics</td>
</tr>
<tr>
<td>Imports:</td>
<td>tensor, spatstat.utils (&ge; 3.0)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Adrian Baddeley &lt;Adrian.Baddeley@curtin.edu.au&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Extension to the 'spatstat' package, enabling the user
	     to fit point process models to point pattern data
	     by local composite likelihood ('geographically weighted
	     regression').</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-12 10:13:24 UTC; adrian</td>
</tr>
<tr>
<td>Author:</td>
<td>Adrian Baddeley [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-13 05:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bw.loccit'>
Cross Validated Bandwidth Selection for Locally Fitted Point Process Model
</h2><span id='topic+bw.loccit'></span>

<h3>Description</h3>

<p>Uses cross-validation to select a smoothing bandwidth
for locally fitting a Cox or cluster point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw.loccit(..., use.fft=TRUE, 
               srange = NULL, ns = 9, sigma = NULL,
               fftopt=list(), 
               verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw.loccit_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="spatstat.model.html#topic+kppm">kppm</a></code> to fit the homogeneous
version of the model.
</p>
</td></tr>
<tr><td><code id="bw.loccit_+3A_use.fft">use.fft</code></td>
<td>

<p>Logical value indicating whether to use a quick-and-dirty
approximation based on a first order Taylor expansion.
</p>
</td></tr>
<tr><td><code id="bw.loccit_+3A_srange">srange</code></td>
<td>

<p>Range of values of the smoothing parameter <code>sigma</code>
to be searched. A numeric vector of length 2 giving the minimum
and maximum values of <code>sigma</code>.
</p>
</td></tr>
<tr><td><code id="bw.loccit_+3A_ns">ns</code></td>
<td>

<p>Number of values of the smoothing parameter <code>sigma</code>
in the range <code>srange</code> to be searched. A positive integer.
</p>
</td></tr>
<tr><td><code id="bw.loccit_+3A_sigma">sigma</code></td>
<td>

<p>Vector of values of the smoothing parameter to be searched.
</p>
</td></tr>
<tr><td><code id="bw.loccit_+3A_fftopt">fftopt</code></td>
<td>
<p>Developer use only.</p>
</td></tr>
<tr><td><code id="bw.loccit_+3A_verbose">verbose</code></td>
<td>

<p>Logical value indicating whether to display progress reports.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function determines the optimal value of the smoothing
parameter <code>sigma</code> to be used in a call to <code><a href="#topic+loccit">loccit</a></code>.
</p>
<p>The function <code><a href="#topic+loccit">loccit</a></code> fits
a Cox or cluster point process model
to point pattern data by local composite likelihood.
The degree of local smoothing is controlled by a smoothing parameter
<code>sigma</code> which is an argument to <code><a href="#topic+loccit">loccit</a></code>.
</p>
<p>For each value of <code>sigma</code> in a search interval,
the function <code>bw.loccit</code> fits the model locally
and evaluates a cross-validation criterion. The optimal value of
<code>sigma</code> is returned. 
</p>


<h3>Value</h3>

<p>A numerical value giving the selected bandwidth.
The result also belongs to the class <code>"bw.optim"</code>
which can be plotted.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Baddeley, A. (2017) Local composite likelihood
  for spatial point patterns. <em>Spatial Statistics</em> <b>22</b>, 261&ndash;295. DOI: 10.1016/j.spasta.2017.03.001
</p>
<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>. Chapman and Hall/CRC Press. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loccit">loccit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- redwood[owin(c(0,1), c(-1,-1/2))]
  Ns &lt;- if(interactive()) 16 else 2
  b &lt;- bw.loccit(X, ~1, "Thomas", srange=c(0.07, 0.14), ns=Ns)
  b
  plot(b)
</code></pre>

<hr>
<h2 id='bw.locppm'>
Cross Validated Bandwidth Selection for Locally Fitted Point Process Model
</h2><span id='topic+bw.locppm'></span>

<h3>Description</h3>

<p>Uses cross-validation to select a smoothing bandwidth
for locally fitting a Poisson or Gibbs point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw.locppm(...,
          method = c("fft", "exact", "taylor"), 
          srange = NULL, ns = 9, sigma = NULL,
          additive = TRUE, 
          verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw.locppm_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="spatstat.model.html#topic+ppm">ppm</a></code> to fit the homogeneous
version of the model.
</p>
</td></tr>
<tr><td><code id="bw.locppm_+3A_method">method</code></td>
<td>

<p>Method of calculation. The default <code>method="fft"</code> is much
faster than the other choices. 
</p>
</td></tr>
<tr><td><code id="bw.locppm_+3A_srange">srange</code></td>
<td>

<p>Range of values of the smoothing parameter <code>sigma</code>
to be searched. A numeric vector of length 2 giving the minimum
and maximum values of <code>sigma</code>.
</p>
</td></tr>
<tr><td><code id="bw.locppm_+3A_ns">ns</code></td>
<td>

<p>Number of values of the smoothing parameter <code>sigma</code>
in the range <code>srange</code> to be searched. A positive integer.
</p>
</td></tr>
<tr><td><code id="bw.locppm_+3A_sigma">sigma</code></td>
<td>

<p>Vector of values of the smoothing parameter to be searched.
Overrides the values of <code>ns</code> and <code>srange</code>.
</p>
</td></tr>
<tr><td><code id="bw.locppm_+3A_additive">additive</code></td>
<td>

<p>Logical value indicating whether to calculate the leverage
approximation on the scale of the intensity (<code>additive=TRUE</code>)
or the log intensity (<code>additive=FALSE</code>).
Applies only when <code>method = "taylor"</code>.
</p>
</td></tr>
<tr><td><code id="bw.locppm_+3A_verbose">verbose</code></td>
<td>

<p>Logical value indicating whether to display progress reports.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function determines the optimal value of the smoothing
parameter <code>sigma</code> to be used in a call to <code><a href="#topic+locppm">locppm</a></code>.
</p>
<p>The function <code><a href="#topic+locppm">locppm</a></code> fits
a Poisson or Gibbs point process model
to point pattern data by local composite likelihood.
The degree of local smoothing is controlled by a smoothing parameter
<code>sigma</code> which is an argument to <code><a href="#topic+locppm">locppm</a></code>.
</p>
<p>This function <code>bw.locppm</code> determines the optimal value of
<code>sigma</code> by cross-validation.
For each value of <code>sigma</code> in a search interval,
the function <code>bw.locppm</code> fits the model locally
with smoothing bandwidth <code>sigma</code>, 
and evaluates the composite likelihood cross-validation criterion
<code>LCV(sigma)</code> defined in Baddeley (2016), section 3.2.
The value of <code>sigma</code> which maximises <code>LCV(sigma)</code> is returned.
</p>


<h3>Value</h3>

<p>A numerical value giving the selected bandwidth.
The result also belongs to the class <code>"bw.optim"</code>
which can be plotted.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Baddeley, A. (2017) Local composite likelihood
  for spatial point patterns. <em>Spatial Statistics</em> <b>22</b>, 261&ndash;295. DOI: 10.1016/j.spasta.2017.03.001
</p>
<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>. Chapman and Hall/CRC Press. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+locppm">locppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  Ns &lt;- if(interactive()) 16 else 2
  b &lt;- bw.locppm(swedishpines, ~1, srange=c(2.5,4.5), ns=Ns)
  b
  plot(b)
</code></pre>

<hr>
<h2 id='homtest'>
Homogeneity Test for Local Poisson or Gibbs Model
</h2><span id='topic+homtest'></span>

<h3>Description</h3>

<p>Conducts a Monte Carlo test of homogeneity for a locally-fitted
Poisson or Gibbs point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   homtest(X, ..., nsim = 19,
           test = c("residuals", "score", "taylor", "likelihood"),
           locations = c("coarse", "fine", "split"),
           ladjust = NULL,
           use.fft = NULL,
           simul = NULL,
           verbose = TRUE, Xname = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="homtest_+3A_x">X</code></td>
<td>

<p>A point pattern (object of class <code>"ppp"</code>).
</p>
</td></tr>
<tr><td><code id="homtest_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code><a href="#topic+locppm">locppm</a></code> to determine the
locally fitted model, and passed to <code><a href="spatstat.model.html#topic+ppm">ppm</a></code> to
determine the homogeneous model.
</p>
</td></tr>
<tr><td><code id="homtest_+3A_nsim">nsim</code></td>
<td>

<p>Number of simulations for the Monte Carlo test.
</p>
</td></tr>
<tr><td><code id="homtest_+3A_test">test</code></td>
<td>

<p>The local test statistic to be used:
either <code>"likelihood"</code> for the local likelihood ratio test
statistic, <code>"taylor"</code> for the Taylor approximation
to the local likelihood ratio test statistic,
<code>"score"</code> for the local score test statistic,
or <code>"residuals"</code> for the squared local residuals.
</p>
</td></tr>
<tr><td><code id="homtest_+3A_locations">locations</code>, <code id="homtest_+3A_use.fft">use.fft</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+locppm">locppm</a></code> to control the
calculation of variances (if <code>method="local"</code>). See Details.
</p>
</td></tr>
<tr><td><code id="homtest_+3A_ladjust">ladjust</code></td>
<td>

<p>Optional argument passed to <code><a href="#topic+homtestmap">homtestmap</a></code> specifying a
data-dependent adjustment of the test statistic.
</p>
</td></tr>
<tr><td><code id="homtest_+3A_simul">simul</code></td>
<td>

<p>Optional information that determines 
how to simulate the realisations from the null hypothesis.
An expression in the <span class="rlang"><b>R</b></span> language (that will be evaluated
<code>nsim</code> times to obtain the simulated patterns), or a list
that contains the simulated point patterns.
</p>
</td></tr>
<tr><td><code id="homtest_+3A_verbose">verbose</code></td>
<td>

<p>Logical value indicating whether to print progress reports.
</p>
</td></tr>
<tr><td><code id="homtest_+3A_xname">Xname</code></td>
<td>

<p>Optional character string name for the dataset <code>X</code>,
to be printed in the test output.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs a Monte Carlo test of the null hypothesis of
homogeneity (i.e.\ constant parameter values) for the locally-fitted
Poisson point process or Gibbs point process specified by the
arguments.
</p>
<p>The type of test is controlled by the argument <code>test</code>.
</p>

<ul>
<li>
<p><code>test="likelihood"</code>:
the locally fitted model is computed as <code>locppm(X, ...)</code>.
The local composite likelihood ratio test statistic of this model
is computed at each location,
and the mean of this statistic over the window is computed.
</p>
</li>
<li>
<p><code>test="taylor"</code>:
the locally fitted model is computed as <code>locppm(X, ...)</code>.
The Taylor approximation to the
local composite likelihood ratio test statistic of this model
is computed at each location,
and the mean of this statistic over the window is computed.
</p>
</li>
<li>
<p><code>test="score"</code>:
the locally fitted model is computed as <code>locppm(X, ...)</code>.
The local score test statistic of this model is computed at each location,
and the mean of this statistic over the window is computed.
</p>
</li>
<li>
<p><code>method="residuals"</code>:
the homogeneous model is fitted as <code>ppm(X, ...)</code>.
The smoothed score residuals of this model are computed at each
location, and the mean of the squared norm over the window
is computed.
</p>
</li></ul>

<p>The test statistic is computed for the data pattern <code>X</code>
and for each of <code>nsim</code> simulated realisations from the
homogeneous model. The Monte Carlo <code class="reqn">p</code>-value is computed.
</p>


<h3>Value</h3>

<p>An object of class <code>"htest"</code> containing the test outcome.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Baddeley, A. (2017) Local composite likelihood
  for spatial point patterns. <em>Spatial Statistics</em> <b>22</b>, 261&ndash;295. DOI: 10.1016/j.spasta.2017.03.001
</p>
<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>. Chapman and Hall/CRC Press. 
</p>


<h3>See Also</h3>

<p>To compute the test statistic only, see
<code><a href="#topic+homtestmap">homtestmap</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   ## Not run: 
   homtest(swedishpines)
   
## End(Not run)
   
</code></pre>

<hr>
<h2 id='homtestmap'>
Test Statistic for Homogeneity Test
</h2><span id='topic+homteststat'></span><span id='topic+homtestmap'></span><span id='topic+update.homtestmap'></span>

<h3>Description</h3>

<p>Compute the test statistic for the test of homogeneity
of a locally-fitted Poisson or Gibbs point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>homteststat(object, ..., verbose = FALSE)

homtestmap(object, ...,
           what=c("components", "statistic", "pvalue"),
           test = c("score", "taylor", "likelihood"),
           ladjust=c("none", "moment", "PSS"),
           calibrate=c("chisq", "Satterthwaite", "firstmoment"),
           simple = !is.null(theta0),
           theta0 = NULL,
           poolmoments=NULL,
           sigma = NULL, 
           saveall = FALSE, 
           use.fft = TRUE,
           verbose = TRUE)

## S3 method for class 'homtestmap'
update(object, ..., 
           what=NULL, test=NULL, ladjust=NULL,
           calibrate=NULL, saveall=FALSE, poolmoments=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="homtestmap_+3A_object">object</code></td>
<td>

<p>Locally-fitted point process (object of class <code>"locppm"</code>)
or an object previously computed by <code>homtestmap</code>.
</p>
</td></tr>
<tr><td><code id="homtestmap_+3A_...">...</code></td>
<td>

<p>For <code>homteststat</code>, arguments passed to <code>homtestmap</code>.
For <code>homtestmap</code>, additional unmatched arguments are ignored.
</p>
</td></tr>
<tr><td><code id="homtestmap_+3A_what">what</code></td>
<td>

<p>Character string (partially matched)
indicating whether to return the vector components
of the local test statistic, or the value of the local test statistic, or
the local <code class="reqn">p</code>-values.
</p>
</td></tr>
<tr><td><code id="homtestmap_+3A_test">test</code></td>
<td>

<p>Character string (partially matched)
indicating whether to perform
the local score test (<code>test="score"</code>),
or the local composite likelihood ratio test
approximately (<code>test="taylor"</code>) or exactly 
(<code>test="likelihood"</code>).
</p>
</td></tr>
<tr><td><code id="homtestmap_+3A_ladjust">ladjust</code></td>
<td>

<p>Character string (partially matched)
specifying an adjustment to the composite likelihood ratio test statistic.
</p>
</td></tr>
<tr><td><code id="homtestmap_+3A_calibrate">calibrate</code></td>
<td>

<p>Character string (partially matched)
specifying how to calculate <code class="reqn">p</code>-values
from the test statistic.
</p>
</td></tr>
<tr><td><code id="homtestmap_+3A_simple">simple</code></td>
<td>

<p>Logical value indicating whether to treat the fitted model
as a simple null hypothesis (<code>simple=TRUE</code>) or as an estimate
of the parameters in a composite null hypothesis
(<code>simple=FALSE</code>, the default).
</p>
</td></tr>
<tr><td><code id="homtestmap_+3A_theta0">theta0</code></td>
<td>

<p>Coefficient vector specifying a simple null hypothesis.
</p>
</td></tr>
<tr><td><code id="homtestmap_+3A_poolmoments">poolmoments</code></td>
<td>

<p>Logical value indicating how to calculate the reference distribution
for the likelihood ratio test statistic (and thus how to
calculate <code class="reqn">p</code>-values). See Details.
</p>
</td></tr>
<tr><td><code id="homtestmap_+3A_sigma">sigma</code></td>
<td>

<p>Smoothing bandwidth.
</p>
</td></tr>
<tr><td><code id="homtestmap_+3A_saveall">saveall</code></td>
<td>

<p>Logical value indicating whether to compute a complete set of
sufficient statistics and save them as an attribute of the result.
See Details.
</p>
</td></tr>
<tr><td><code id="homtestmap_+3A_use.fft">use.fft</code></td>
<td>

<p>For software testing purposes only.
Logical value indicating whether to use
data computed by the Fast Fourier Transform.
</p>
</td></tr>
<tr><td><code id="homtestmap_+3A_verbose">verbose</code></td>
<td>

<p>Logical value indicating whether to print progress reports.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are used by <code><a href="#topic+homtest">homtest</a></code> to
perform a Monte Carlo test of the null hypothesis of
homogeneity (i.e.\ constant parameter values) for the locally-fitted
Poisson point process or Gibbs point process <code>object</code>.
</p>
<p>The function <code>homtestmap</code> computes
either the local likelihood ratio test statistic
or the local score test statistic.
If <code>what="statistic"</code>, then the result is a scalar-valued
function giving the local values of the test statistic.
If <code>what="pvalue"</code>, the result is a scalar-valued function <code class="reqn">p(v)</code>
giving the local <code class="reqn">p</code>-value at each location <code class="reqn">v</code>.
If <code>what="components"</code>, the result is a vector-valued
function <code class="reqn">T(v)</code> containing the components of the quadratic form;
the squared norm of <code class="reqn">T(v)</code> is
equal to the desired test statistic at each location <code class="reqn">v</code>.
</p>
<p>If <code>saveall=TRUE</code>, then a complete set of sufficient statistics is
calculated and stored as an attribute of the result. This makes it
possible to compute all of the statistics and <code class="reqn">p</code> values
described above. 
</p>
<p>The function <code>update.homtestmap</code>, a method for the
generic function <code><a href="stats.html#topic+update">update</a></code>, converts
an object of class <code>"homtestmap"</code> from one of these formats to
another, where possible. Except in trivial cases, this requires that
the <code>"homtestmap"</code> object was computed with <code>saveall=TRUE</code>.
</p>
<p>The function <code>homteststat</code> computes the mean of
the local test statistic or the mean
of the local <code class="reqn">p</code>-values over the
observation window.
</p>
<p>To compute the <code class="reqn">p</code>-values when <code>test="likelihood"</code>
or <code>test="taylor"</code>, the values of the local likelihood ratio
test statistic are referred to a gamma distribution whose first two
moments are estimated from the data. If <code>poolmoments=FALSE</code>,
the local estimates of the moments are used; if
<code>poolmoments=TRUE</code>, the spatial average of these estimates
is used. The default is to use pooling whenever it is
theoretically justified, namely when the template
model is a stationary point process.
</p>
<p>Finer control over the computation is possible
using the arguments <code>...</code> passed to <code><a href="#topic+locppm">locppm</a></code>.
</p>


<h3>Value</h3>

<p>For <code>homteststat</code>, a numeric value giving the test statistic.
</p>
<p>For <code>homtestmap</code> and <code>update.homtestmap</code>,
a spatially-sampled function object (class <code>"ssf"</code>; see
<code><a href="spatstat.explore.html#topic+ssf">ssf</a></code>).
This object also belongs to the special class
<code>"homtestmap"</code> which has a print method.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Baddeley, A. (2017) Local composite likelihood
  for spatial point patterns. <em>Spatial Statistics</em> <b>22</b>, 261&ndash;295. DOI: 10.1016/j.spasta.2017.03.001
</p>
<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>. Chapman and Hall/CRC Press. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+homtest">homtest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   example(locppm)
   plot(H &lt;- homtestmap(fit))
   H
</code></pre>

<hr>
<h2 id='loccit'>
Locally Fitted Cluster or Cox Point Process Model
</h2><span id='topic+loccit'></span>

<h3>Description</h3>

<p>Fits a Neyman-Scott cluster process or Cox point process model
using a locally-weighted composite likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loccit(X, trend = ~1,
       clusters = c("Thomas", "MatClust", "Cauchy", "VarGamma", "LGCP"),
       covariates = NULL,
       ...,
       diagnostics = FALSE,
       taylor = FALSE,
       sigma = NULL, f = 1/4,
       clustargs = list(), control = list(), 
       rmax,
       covfunargs=NULL, use.gam=FALSE, nd=NULL, eps=NULL,
       niter=3,
       fftopt = list(),
       verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loccit_+3A_x">X</code></td>
<td>

<p>Point pattern.
</p>
</td></tr>
<tr><td><code id="loccit_+3A_trend">trend</code></td>
<td>

<p>Formula (without a left hand side) specifying the form of the
logarithm of the intensity.
</p>
</td></tr>
<tr><td><code id="loccit_+3A_clusters">clusters</code></td>
<td>

<p>Character string determining the cluster model.
Partially matched.
</p>
</td></tr>
<tr><td><code id="loccit_+3A_covariates">covariates</code></td>
<td>

<p>The values of any spatial covariates (other than the Cartesian
coordinates) required by the model.
A named list of pixel images, functions, windows or numeric constants.
</p>
</td></tr>
<tr><td><code id="loccit_+3A_diagnostics">diagnostics</code></td>
<td>

<p>Whether to perform auxiliary calculations
in addition to the local estimates of the model parameters.
</p>
</td></tr>
<tr><td><code id="loccit_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to
<code><a href="spatstat.geom.html#topic+as.mask">as.mask</a></code> to control the spatial resolution
in the Fast Fourier Transform.
</p>
</td></tr>
<tr><td><code id="loccit_+3A_taylor">taylor</code></td>
<td>

<p>Logical value indicating whether to fit the model
exactly at each spatial location (<code>taylor=FALSE</code>, the default)
or to compute a first-order Taylor approximation to the
fitted parameters (<code>taylor=TRUE</code>). The Taylor approximation
is much faster.
</p>
</td></tr>
<tr><td><code id="loccit_+3A_sigma">sigma</code></td>
<td>

<p>Standard deviation of Gaussian kernel for local likelihood.
</p>
</td></tr>
<tr><td><code id="loccit_+3A_f">f</code></td>
<td>

<p>Argument passed to <code><a href="spatstat.explore.html#topic+bw.frac">bw.frac</a></code> to
compute a value for <code>sigma</code> if it is missing or <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="loccit_+3A_clustargs">clustargs</code></td>
<td>

<p>List of additional parameters for the cluster model,
passed to the function <code>RFcov</code> in the
<code>RandomFields</code> package.
</p>
</td></tr>
<tr><td><code id="loccit_+3A_control">control</code></td>
<td>

<p>List of control arguments passed to the generic optimisation
function <code><a href="stats.html#topic+optim">optim</a></code>.
</p>
</td></tr>
<tr><td><code id="loccit_+3A_rmax">rmax</code></td>
<td>

<p>Maximum distance between pairs of points that will contribute
to the composite likelihood.
</p>
</td></tr>
<tr><td><code id="loccit_+3A_covfunargs">covfunargs</code>, <code id="loccit_+3A_use.gam">use.gam</code>, <code id="loccit_+3A_nd">nd</code>, <code id="loccit_+3A_eps">eps</code></td>
<td>

<p>Arguments passed to <code><a href="spatstat.model.html#topic+ppm">ppm</a></code>
to control the intensity model and intensity fitting.
</p>
</td></tr>
<tr><td><code id="loccit_+3A_niter">niter</code></td>
<td>

<p>Number of iterations in algorithm if <code>taylor=FALSE</code>.
</p>
</td></tr>
<tr><td><code id="loccit_+3A_fftopt">fftopt</code></td>
<td>
<p>Developer use only.</p>
</td></tr>
<tr><td><code id="loccit_+3A_verbose">verbose</code></td>
<td>

<p>Logical. If <code>TRUE</code>, print progress reports. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits a Cox or cluster process model to point pattern
data locally, using the local Palm likelihood technique
(Baddeley, 2016, section 8).
</p>
<p>It can be used in the same way as <code><a href="spatstat.model.html#topic+kppm">kppm</a></code>
and effectively performs local fitting of the same model.
</p>


<h3>Value</h3>

<p>An object of class <code>"loccit"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Baddeley, A. (2017) Local composite likelihood
  for spatial point patterns. <em>Spatial Statistics</em> <b>22</b>, 261&ndash;295. DOI: 10.1016/j.spasta.2017.03.001
</p>
<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>. Chapman and Hall/CRC Press. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+locppm">locppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- redwood[owin(c(0,1), c(-1,-1/2))]
   fit &lt;- loccit(X, ~1, "Thomas", nd=5, control=list(maxit=20))
   fit
</code></pre>

<hr>
<h2 id='locmincon'>
Locally Fitted Cluster or Cox Point Process Model
</h2><span id='topic+locmincon'></span>

<h3>Description</h3>

<p>Fits a Neyman-Scott cluster process or Cox point process model
using local minimum contrast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locmincon(..., sigma = NULL, f = 1/4, verbose = TRUE,
                 localstatargs = list(), LocalStats = NULL,
                 tau = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="locmincon_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="spatstat.model.html#topic+kppm">kppm</a></code>
to determine the template homogeneous model.
</p>
</td></tr>
<tr><td><code id="locmincon_+3A_sigma">sigma</code></td>
<td>

<p>Standard deviation of Gaussian kernel for local likelihood.
</p>
</td></tr>
<tr><td><code id="locmincon_+3A_f">f</code></td>
<td>

<p>Argument passed to <code><a href="spatstat.explore.html#topic+bw.frac">bw.frac</a></code> to
compute a value for <code>sigma</code> if it is missing or <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="locmincon_+3A_verbose">verbose</code></td>
<td>

<p>Logical. If <code>TRUE</code>, print progress reports. 
</p>
</td></tr>
<tr><td><code id="locmincon_+3A_localstatargs">localstatargs</code></td>
<td>

<p>Optional. List of arguments to be passed to the local statistic
<code><a href="spatstat.explore.html#topic+localK">localK</a></code>,
<code><a href="spatstat.explore.html#topic+localKinhom">localKinhom</a></code>,
<code><a href="spatstat.explore.html#topic+localpcf">localpcf</a></code> or 
<code><a href="spatstat.explore.html#topic+localpcf">localpcfinhom</a></code>.
</p>
</td></tr>
<tr><td><code id="locmincon_+3A_localstats">LocalStats</code></td>
<td>

<p>Optional.
Values of the local statistics, if they have already been computed.
</p>
</td></tr>
<tr><td><code id="locmincon_+3A_tau">tau</code></td>
<td>

<p>Optional. Bandwidth for smoothing the fitted cluster parameters.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The template or homogeneous model is first fitted by
<code><a href="spatstat.model.html#topic+kppm">kppm</a></code>. 
The statistic used to fit the template model is determined
(as explained in the help for <code><a href="spatstat.model.html#topic+kppm">kppm</a></code>)
by the arguments <code>statistic</code> and <code>trend</code>.
</p>
<p>The <em>local</em> version of this statistic is then computed.
If <code>statistic="K"</code> and <code>trend=~1</code>
for example, the template model is fitted
using the <code class="reqn">K</code> function <code><a href="spatstat.explore.html#topic+Kest">Kest</a></code>,
and the local version is the local <code class="reqn">K</code> function
<code><a href="spatstat.explore.html#topic+localK">localK</a></code>. The possibilities are:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>statistic</code> </td><td style="text-align: left;"> stationary? </td><td style="text-align: left;">
    <em>template</em> </td><td style="text-align: left;"> <em>local</em> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"K"</code> </td><td style="text-align: left;"> yes
    </td><td style="text-align: left;"> <code><a href="spatstat.explore.html#topic+Kest">Kest</a></code>
    </td><td style="text-align: left;"> <code><a href="spatstat.explore.html#topic+localK">localK</a></code>
    </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"K"</code> </td><td style="text-align: left;"> no
    </td><td style="text-align: left;"> <code><a href="spatstat.explore.html#topic+Kinhom">Kinhom</a></code>
    </td><td style="text-align: left;"> <code><a href="spatstat.explore.html#topic+localKinhom">localKinhom</a></code>
    </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"pcf"</code> </td><td style="text-align: left;"> yes
    </td><td style="text-align: left;"> <code><a href="spatstat.explore.html#topic+pcf">pcf</a></code>
    </td><td style="text-align: left;"> <code><a href="spatstat.explore.html#topic+localpcf">localpcf</a></code>
    </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"pcf"</code> </td><td style="text-align: left;"> no
    </td><td style="text-align: left;"> <code><a href="spatstat.explore.html#topic+pcfinhom">pcfinhom</a></code>
    </td><td style="text-align: left;"> <code><a href="spatstat.explore.html#topic+localpcfinhom">localpcfinhom</a></code>
  </td>
</tr>

</table>

<p>These local functions, one for each data point, are then spatially
averaged, using a Gaussian kernel with standard deviation <code>sigma</code>.
Finally the model is fitted to each of the averaged local functions
to obtain a local fit at each data point.
</p>


<h3>Value</h3>

<p>Object of class <code>"locmincon"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Baddeley, A. (2017) Local composite likelihood
  for spatial point patterns. <em>Spatial Statistics</em> <b>22</b>, 261&ndash;295. DOI: 10.1016/j.spasta.2017.03.001
</p>
<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>. Chapman and Hall/CRC Press. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loccit">loccit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- redwood[owin(c(0,1), c(-1,-1/2))]
   fit &lt;- locmincon(X, ~1, "Thomas", sigma=0.07)
   fit
</code></pre>

<hr>
<h2 id='locppm'>
Locally Fitted Poisson or Gibbs Point Process Model
</h2><span id='topic+locppm'></span>

<h3>Description</h3>

<p>Fits Poisson or Gibbs point process model
using local likelihood or pseudolikelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locppm(..., sigma = NULL, f = 1/4,
       vcalc = c("none", "t", "hessian", "hom", "lik", "full"),
       locations=c("split", "fine", "coarse"),
       ngrid = NULL, grideps = NULL, verbose = TRUE,
       use.fft=FALSE, fft.algorithm="closepairs")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="locppm_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="spatstat.model.html#topic+ppm">ppm</a></code>
to fit the homogeneous model.
</p>
</td></tr>
<tr><td><code id="locppm_+3A_sigma">sigma</code></td>
<td>

<p>Standard deviation of Gaussian kernel for local likelihood.
</p>
</td></tr>
<tr><td><code id="locppm_+3A_f">f</code></td>
<td>

<p>Argument passed to <code><a href="spatstat.explore.html#topic+bw.frac">bw.frac</a></code> to
compute a value for <code>sigma</code> if it is missing or <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="locppm_+3A_vcalc">vcalc</code></td>
<td>

<p>Type of variance calculation to be performed. See Details.
</p>
</td></tr>
<tr><td><code id="locppm_+3A_locations">locations</code></td>
<td>

<p>Spatial locations for local calculations. See Details.
</p>
</td></tr>
<tr><td><code id="locppm_+3A_ngrid">ngrid</code></td>
<td>

<p>Dimensions of coarse grid, if used. See Details.
Incompatible with <code>grideps</code>.
</p>
</td></tr>
<tr><td><code id="locppm_+3A_grideps">grideps</code></td>
<td>

<p>Grid spacing of  coarse grid, if used. See Details.
Incompatible with <code>ngrid</code>.
</p>
</td></tr>
<tr><td><code id="locppm_+3A_verbose">verbose</code></td>
<td>

<p>Logical. If <code>TRUE</code>, print progress reports.
</p>
</td></tr>
<tr><td><code id="locppm_+3A_use.fft">use.fft</code></td>
<td>

<p>Logical value indicating whether to perform
computations using the Fast Fourier Transform.
With <code>use.fft = TRUE</code> the code runs much faster
but some quantities are not computed exactly.
See Details.
</p>
</td></tr>
<tr><td><code id="locppm_+3A_fft.algorithm">fft.algorithm</code></td>
<td>

<p>Developer use only.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits a Poisson or Gibbs point process model
to point pattern data by local likelihood or local pseudolikelihood
respectively.
</p>
<p>This command should be used in the same way as
<code><a href="spatstat.model.html#topic+ppm">ppm</a></code>. 
The point pattern data and the specification of the model
are given in the leading arguments <code>...</code> which are passed
directly to <code><a href="spatstat.model.html#topic+ppm">ppm</a></code>.
</p>
<p>In all cases, the local estimates of the coefficients are
computed. However, because the variance calculations are
time-consuming, the default is not to perform them.
This is controlled by the argument <code>vcalc</code>.
</p>

<dl>
<dt><code>vcalc = "none"</code>:</dt><dd>
<p>no variance calculations are performed.
</p>
</dd>
<dt><code>vcalc = "t"</code>:</dt><dd>
<p>the <code class="reqn">t</code> statistic for each parameter is computed
for the local model.
</p>
</dd>
<dt><code>vcalc = "hessian"</code>:</dt><dd>
<p>the local Hessian matrix is computed,
and its negative inverse is used as a surrogate for the local variance.
</p>
</dd>
<dt><code>vcalc = "hom"</code>:</dt><dd>
<p>No local fitting is performed.
Calculations are performed only for the homogeneous (template)
model. The variance of the local parameter estimates
<em>under the homogeneous model</em> is computed.
</p>
</dd>
<dt><code>vcalc = "lik"</code>:</dt><dd>
<p>In addition to the calculations for <code>vcalc="hom"</code> described
above, if <code>use.fft=FALSE</code>
the algorithm also computes the local composite likelihood
ratio test statistic for the test of homogeneity.
If <code>use.fft=TRUE</code> then <code>vcalc="lik"</code> is equivalent to
<code>vcalc="hom"</code>.
</p>
</dd>
<dt><code>vcalc = "full"</code>:</dt><dd>
<p>all variance calculations are performed for the local model.
</p>
</dd>
</dl>

<p>The spatial locations, where the model fits and variance calculations
are performed, are determined by the argument <code>locations</code>.
</p>

<dl>
<dt><code>locations = "fine"</code>:</dt><dd>
<p>The calculations are performed at every quadrature point
of the model. This can take a very long time.
</p>
</dd>
<dt><code>locations = "coarse"</code>:</dt><dd>
<p>The calculations are performed at the points of a coarse grid
with dimensions specified by <code>ngrid</code> or <code>grideps</code>.
</p>
</dd>
<dt><code>locations = "split"</code>:</dt><dd>
<p>The fitted coefficients are computed at every quadrature point
of the model, but the variance calculations (if any) are
performed at a coarse grid of locations,
specified by <code>ngrid</code> or <code>grideps</code>.
If neither <code>ngrid</code> nor <code>grideps</code> is specified,
the default is <code>ngrid=10</code>.
</p>
</dd>
</dl>

<p>If <code>use.fft=FALSE</code> (the default), all desired quantities are
computed exactly, by an iterative algorithm that 
fits a separate model at each spatial location. This can be quite
slow.
</p>
<p>If <code>use.fft=TRUE</code>, we only compute quantities that can be
obtained using the Fast Fourier Transform, resulting in much faster
calculations (sometimes 3 orders of magnitude faster) when
<code>locations="fine"</code>.
Properties of the homogeneous model are
computed accurately. Properties of the locally-fitted model are
approximated by a first order Taylor expansion. 
</p>


<h3>Value</h3>

<p>An object of class <code>"locppm"</code> representing the fitted model.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Baddeley, A. (2017) Local composite likelihood
  for spatial point patterns. <em>Spatial Statistics</em> <b>22</b>, 261&ndash;295. DOI: 10.1016/j.spasta.2017.03.001
</p>
<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>. Chapman and Hall/CRC Press. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+methods.locppm">methods.locppm</a></code>, 
<code><a href="#topic+plot.locppm">plot.locppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   fit &lt;- locppm(swedishpines, ~1, sigma=9, nd=20)
   fit
</code></pre>

<hr>
<h2 id='methods.locmincon'>Methods for Local Cluster or Cox Models</h2><span id='topic+methods.locmincon'></span><span id='topic+as.ppp.locmincon'></span><span id='topic+print.locmincon'></span>

<h3>Description</h3>

<p>Methods for various generic functions, for the class
<code>"locmincon"</code> of locally fitted cluster or Cox point process models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'locmincon'
as.ppp(X, ...)

  ## S3 method for class 'locmincon'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methods.locmincon_+3A_x">x</code>, <code id="methods.locmincon_+3A_x">X</code></td>
<td>

<p>A locally-fitted Cox or cluster point process model (object of class
<code>"locmincon"</code>). 
</p>
</td></tr>
<tr><td><code id="methods.locmincon_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Objects of class <code>"locmincon"</code> represent locally fitted
cluster or Cox point process models.
</p>
<p>The functions documented here provided methods for this class,
for the generic functions
<code><a href="spatstat.geom.html#topic+as.ppp">as.ppp</a></code>
and
<code><a href="base.html#topic+print">print</a></code>.
</p>


<h3>Value</h3>

<p><code>as.ppp</code> returns an object of class <code>"ppp"</code>.
</p>
<p><code>print</code> returns <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley</p>


<h3>References</h3>

<p>Baddeley, A. (2017) Local composite likelihood
  for spatial point patterns. <em>Spatial Statistics</em> <b>22</b>, 261&ndash;295. DOI: 10.1016/j.spasta.2017.03.001
</p>
<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>. Chapman and Hall/CRC Press. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+locmincon">locmincon</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  example(locmincon)
  fit
  as.ppp(fit)  
</code></pre>

<hr>
<h2 id='methods.locppm'>Methods for Local Gibbs Models</h2><span id='topic+methods.locppm'></span><span id='topic+as.interact.locppm'></span><span id='topic+as.ppm.locppm'></span><span id='topic+coef.locppm'></span><span id='topic+confint.locppm'></span><span id='topic+is.poisson.locppm'></span><span id='topic+print.locppm'></span>

<h3>Description</h3>

<p>Methods for various generic functions, for the class
<code>"locppm"</code> of locally fitted Gibbs point process models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'locppm'
as.interact(object)

  ## S3 method for class 'locppm'
as.ppm(object)

  ## S3 method for class 'locppm'
coef(object, ..., which = c("local", "homogeneous"))

  ## S3 method for class 'locppm'
confint(object, parm, level = 0.95, ..., which = c("local", "homogeneous"))

  ## S3 method for class 'locppm'
is.poisson(x)

  ## S3 method for class 'locppm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methods.locppm_+3A_object">object</code>, <code id="methods.locppm_+3A_x">x</code></td>
<td>

<p>A locally-fitted  Gibbs point process model (object of class
<code>"locppm"</code>). 
</p>
</td></tr>
<tr><td><code id="methods.locppm_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to the default method
(for <code>confint.locppm</code>) or ignored (by <code>coef.locppm</code>).
</p>
</td></tr>
<tr><td><code id="methods.locppm_+3A_which">which</code></td>
<td>

<p>Character string determining whether to perform calculations
for the local Gibbs model (<code>which="local"</code>, the default) or the
corresponding homogeneous Gibbs model (<code>which="homogeneous"</code>).
</p>
</td></tr>
<tr><td><code id="methods.locppm_+3A_parm">parm</code></td>
<td>

<p>The parameter or parameters for which a confidence interval is
desired. A character string or character vector matching the names 
of <code>coef(object)</code>, or an index or index vector that can be
applied to <code>coef(object)</code>.
</p>
</td></tr>
<tr><td><code id="methods.locppm_+3A_level">level</code></td>
<td>

<p>Confidence level: a number between 0 and 1.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Objects of class <code>"locppm"</code> represent locally fitted Gibbs
point process models.
</p>
<p>The functions documented here provided methods for this class,
for the generic functions
<code><a href="spatstat.model.html#topic+as.interact">as.interact</a></code>,
<code><a href="spatstat.model.html#topic+as.ppm">as.ppm</a></code>,
<code><a href="stats.html#topic+coef">coef</a></code>,
<code><a href="stats.html#topic+confint">confint</a></code>,
<code><a href="spatstat.random.html#topic+is.stationary">is.poisson</a></code>
and
<code><a href="base.html#topic+print">print</a></code>.
</p>
<p>For the <code>coef</code> and <code>confint</code> methods, the calculations
can be performed either on the locally fitted model or
on its homogeneous equivalent, by changing the argument <code>which</code>.
</p>


<h3>Value</h3>

<p><code>as.interact</code> returns an interaction structure (object of class
<code>"interact"</code>). 
</p>
<p><code>as.ppm</code> returns a fitted Gibbs model (object of class
<code>"ppm"</code>).
</p>
<p><code>coef</code> and <code>confint</code>
return a numeric vector if <code>which="homogeneous"</code>
and an object of class <code>"ssf"</code> if <code>which="local"</code>.
</p>
<p><code>is.poisson</code> returns a logical value.
</p>
<p><code>print</code> returns <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley</p>


<h3>References</h3>

<p>Baddeley, A. (2017) Local composite likelihood
  for spatial point patterns. <em>Spatial Statistics</em> <b>22</b>, 261&ndash;295. DOI: 10.1016/j.spasta.2017.03.001
</p>
<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>. Chapman and Hall/CRC Press. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+locppm">locppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   fit &lt;- locppm(swedishpines, ~1, sigma=9, nd=20,
                 vcalc="full", locations="coarse")
   fit
   is.poisson(fit)
   coef(fit)
   coef(fit, which="homogeneous")
   confint(fit)
   confint(fit, which="homogeneous")
   as.ppm(fit)
   as.interact(fit)
</code></pre>

<hr>
<h2 id='plot.loccit'>
Plot a Locally Fitted Cluster or Cox Point Process Model
</h2><span id='topic+plot.loccit'></span>

<h3>Description</h3>

<p>Plot an object of class <code>"loccit"</code>
representing a locally-fitted cluster or Cox point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'loccit'
plot(x, ...,
               what = c("modelpar", "coefs", "lambda"),
               how = c("smoothed", "exact"), which = NULL,
               pre=NULL, post=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.loccit_+3A_x">x</code></td>
<td>

<p>The model to be plotted.
A locally-fitted cluster or Cox point process model (object of class
<code>"loccit"</code>).
</p>
</td></tr>
<tr><td><code id="plot.loccit_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="spatstat.geom.html#topic+plot.ppp">plot.ppp</a></code>
or <code><a href="spatstat.geom.html#topic+plot.im">plot.im</a></code> to control the plot.
</p>
</td></tr>
<tr><td><code id="plot.loccit_+3A_what">what</code></td>
<td>

<p>Character string determining which quantities to display:
<code>"modelpar"</code> for the cluster model parameters,
<code>"coefs"</code> for the trend coefficients,
or <code>"lambda"</code> for the fitted intensity.
</p>
</td></tr>
<tr><td><code id="plot.loccit_+3A_how">how</code></td>
<td>

<p>Character string determining whether to display the
fitted parameter values at the data points (<code>how="exact"</code>)
or the smoothed fitted parameters as pixel images (<code>how="smoothed"</code>).
</p>
</td></tr>
<tr><td><code id="plot.loccit_+3A_which">which</code></td>
<td>

<p>Optional. Which component(s) of the vector-valued quantity to display.
An index or index vector. Default is to plot all components.
</p>
</td></tr>
<tr><td><code id="plot.loccit_+3A_pre">pre</code>, <code id="plot.loccit_+3A_post">post</code></td>
<td>

<p>Transformations to apply before and after smoothing.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic command <code><a href="base.html#topic+plot">plot</a></code>
for the class <code>"loccit"</code>.
</p>
<p>The argument <code>which</code>, if present, specifies
which fitted parameters are displayed. It may be any kind of
index for a numeric vector.
</p>
<p>The quantities are computed at irregularly-placed points.
If <code>how="exact"</code> the exact computed values
will be displayed as circles centred at the locations where they
were computed. If <code>how="smoothed"</code> these
values will be kernel-smoothed using <code><a href="spatstat.explore.html#topic+Smooth.ppp">Smooth.ppp</a></code>
and displayed as a pixel image.  
</p>


<h3>Value</h3>

<p><code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Baddeley, A. (2017) Local composite likelihood
  for spatial point patterns. <em>Spatial Statistics</em> <b>22</b>, 261&ndash;295. DOI: 10.1016/j.spasta.2017.03.001
</p>
<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>. Chapman and Hall/CRC Press. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loccit">loccit</a></code>,
<code><a href="base.html#topic+plot">plot</a></code>, <code><a href="graphics.html#topic+plot.default">plot.default</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- redwood[owin(c(0,1), c(-1,-1/2))]
   fitc &lt;- loccit(X, ~1, "Thomas", nd=5, control=list(maxit=20))
   plot(fitc, how="exact")  
   plot(fitc, how="smoothed")  
</code></pre>

<hr>
<h2 id='plot.locmincon'>
Plot a Locally Fitted Cluster or Cox Point Process Model
</h2><span id='topic+plot.locmincon'></span>

<h3>Description</h3>

<p>Plot an object of class <code>"locmincon"</code>
representing a locally-fitted cluster or Cox point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'locmincon'
plot(x, ...,
               how = c("exact", "smoothed"),
               which = NULL, sigma = NULL, do.points = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.locmincon_+3A_x">x</code></td>
<td>

<p>The model to be plotted.
A locally-fitted cluster or Cox point process model (object of class
<code>"locmincon"</code> or <code>"loccit"</code>).
</p>
</td></tr>
<tr><td><code id="plot.locmincon_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="spatstat.geom.html#topic+plot.ppp">plot.ppp</a></code>
or <code><a href="spatstat.geom.html#topic+plot.im">plot.im</a></code> to control the plot.
</p>
</td></tr>
<tr><td><code id="plot.locmincon_+3A_how">how</code></td>
<td>

<p>Character string determining whether to display the
fitted parameter values at the data points (<code>how="exact"</code>)
or the smoothed fitted parameters as pixel images (<code>how="smoothed"</code>).
</p>
</td></tr>
<tr><td><code id="plot.locmincon_+3A_which">which</code></td>
<td>

<p>Optional. Which component(s) of the vector-valued quantity to display.
An index or index vector. Default is to plot all components.
</p>
</td></tr>
<tr><td><code id="plot.locmincon_+3A_sigma">sigma</code></td>
<td>

<p>Numeric. Smoothing bandwidth to be used if <code>how="smoothed"</code>.
</p>
</td></tr>
<tr><td><code id="plot.locmincon_+3A_do.points">do.points</code></td>
<td>

<p>Logical. Whether to display the original point data
as well.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic command <code><a href="base.html#topic+plot">plot</a></code>
for the class <code>"locmincon"</code>.
</p>
<p>The argument <code>which</code>, if present, specifies
which fitted parameters are displayed. It may be any kind of
index for a numeric vector.
</p>
<p>The quantities are computed at irregularly-placed points.
If <code>how="exact"</code> the exact computed values
will be displayed as circles centred at the locations where they
were computed. If <code>how="smoothed"</code> these
values will be kernel-smoothed using <code><a href="spatstat.explore.html#topic+Smooth.ppp">Smooth.ppp</a></code>
and displayed as a pixel image.  
</p>


<h3>Value</h3>

<p><code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Baddeley, A. (2017) Local composite likelihood
  for spatial point patterns. <em>Spatial Statistics</em> <b>22</b>, 261&ndash;295. DOI: 10.1016/j.spasta.2017.03.001
</p>
<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>. Chapman and Hall/CRC Press. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+locmincon">locmincon</a></code>, 
<code><a href="#topic+methods.locmincon">methods.locmincon</a></code>,
<code><a href="base.html#topic+plot">plot</a></code>, <code><a href="graphics.html#topic+plot.default">plot.default</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X &lt;- redwood[owin(c(0,1), c(-1,-1/2))]
   fitm &lt;- locmincon(X, ~1, "Thomas", sigma=0.07)
   plot(fitm, how="smoothed")  
   plot(fitm, how="exact")  
</code></pre>

<hr>
<h2 id='plot.locppm'>
Plot a Locally Fitted Poisson or Gibbs Model
</h2><span id='topic+plot.locppm'></span><span id='topic+contour.locppm'></span>

<h3>Description</h3>

<p>Plot an object of class <code>"locppm"</code>
representing a locally-fitted Poisson or Gibbs point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'locppm'
plot(x, ..., what = "cg", which = NULL)

## S3 method for class 'locppm'
contour(x, ..., what = "cg", which = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.locppm_+3A_x">x</code></td>
<td>

<p>A locally-fitted Poisson or Gibbs point process model (object of class
<code>"locppm"</code>).
</p>
</td></tr>
<tr><td><code id="plot.locppm_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="spatstat.explore.html#topic+plot.ssf">plot.ssf</a></code>
to control the plot. 
</p>
</td></tr>
<tr><td><code id="plot.locppm_+3A_what">what</code></td>
<td>

<p>What quantity to display. A character string.
The default is to display the fitted coefficient vectors.
</p>
</td></tr>
<tr><td><code id="plot.locppm_+3A_which">which</code></td>
<td>

<p>Which component(s) of the vector-valued quantity to display.
An index or index vector.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are methods for the generic commands <code><a href="base.html#topic+plot">plot</a></code>
and <code><a href="graphics.html#topic+contour">contour</a></code>, for the class <code>"locppm"</code>.
</p>
<p>The argument <code>what</code> specifies what quantity will be displayed:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>"cg"</code> </td><td style="text-align: left;"> Fitted coefficients of local model </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"vg"</code> </td><td style="text-align: left;"> Local variance matrix for Gibbs model </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"vh"</code> </td><td style="text-align: left;"> Local variance matrix for homogeneous model </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>"tg"</code> </td><td style="text-align: left;"> <code class="reqn">t</code>-statistics based on <code>"coefs"</code> and <code>"vg"</code>
  </td>
</tr>

</table>

<p>Typically these quantities are vector-valued (matrices are converted
to vectors). The argument <code>which</code>, if present, specifies
which elements of the vector are displayed. It may be any kind of
index for a numeric vector.
</p>
<p>The plotting is performed by <code><a href="spatstat.explore.html#topic+plot.ssf">plot.ssf</a></code>.
</p>


<h3>Value</h3>

<p><code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Baddeley, A. (2017) Local composite likelihood
  for spatial point patterns. <em>Spatial Statistics</em> <b>22</b>, 261&ndash;295. DOI: 10.1016/j.spasta.2017.03.001
</p>
<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>. Chapman and Hall/CRC Press. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+locppm">locppm</a></code>, 
<code><a href="#topic+methods.locppm">methods.locppm</a></code>,
<code><a href="base.html#topic+plot">plot</a></code>, <code><a href="graphics.html#topic+plot.default">plot.default</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   fit &lt;- locppm(swedishpines, ~1, sigma=9, nd=20,
             vcalc="hessian", locations="coarse")
   plot(fit)  
   plot(fit, what="Vg")  
</code></pre>

<hr>
<h2 id='predict.loccit'>
Prediction for Locally-Fitted Cox or Cluster Model
</h2><span id='topic+predict.loccit'></span><span id='topic+fitted.loccit'></span>

<h3>Description</h3>

<p>Computes the fitted intensity of a locally-fitted Cox process
or cluster process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'loccit'
predict(object, ...)

  ## S3 method for class 'loccit'
fitted(object, ..., new.coef=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.loccit_+3A_object">object</code></td>
<td>

<p>Locally fitted point process model (object of class <code>"loccit"</code>
fitted by <code><a href="#topic+loccit">loccit</a></code>).
</p>
</td></tr>
<tr><td><code id="predict.loccit_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="#topic+predict.locppm">predict.locppm</a></code>.
</p>
</td></tr>
<tr><td><code id="predict.loccit_+3A_new.coef">new.coef</code></td>
<td>

<p>New values for the fitted coefficients. A matrix
in which each row gives the fitted coefficients at one of the
quadrature points of the model.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fitted intensity is computed.  
</p>


<h3>Value</h3>

<p>An object of class <code>"ssf"</code> as described in <code><a href="spatstat.explore.html#topic+ssf">ssf</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Baddeley, A. (2017) Local composite likelihood
  for spatial point patterns. <em>Spatial Statistics</em> <b>22</b>, 261&ndash;295. DOI: 10.1016/j.spasta.2017.03.001
</p>
<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>. Chapman and Hall/CRC Press. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loccit">loccit</a></code>, <code><a href="#topic+predict.locppm">predict.locppm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  X &lt;- redwood[owin(c(0,1), c(-1,-1/2))]
  fit &lt;- loccit(X, ~1, "Thomas", nd=5, control=list(maxit=20))
  lam &lt;- predict(fit)
</code></pre>

<hr>
<h2 id='predict.locppm'>
Prediction of a Locally Fitted Poisson or Gibbs Point Process Model
</h2><span id='topic+predict.locppm'></span><span id='topic+fitted.locppm'></span>

<h3>Description</h3>

<p>Computes the fitted intensity of a locally-fitted Poisson point process
model, or the fitted intensity, trend or conditional intensity
of a locally-fitted Gibbs point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'locppm'
fitted(object, ...,
                        type = c("cif", "trend", "intensity"),
                        new.coef=NULL)

## S3 method for class 'locppm'
predict(object, ...,
                         type = c("cif", "trend", "intensity"),
                         locations=NULL, new.coef=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.locppm_+3A_object">object</code></td>
<td>

<p>A locally-fitted Poisson or Gibbs point process model (object of class
<code>"locppm"</code>). 
</p>
</td></tr>
<tr><td><code id="predict.locppm_+3A_...">...</code></td>
<td>

<p>Currently ignored.
</p>
</td></tr>
<tr><td><code id="predict.locppm_+3A_new.coef">new.coef</code></td>
<td>

<p>New vector or matrix of values for the
model coefficients.
</p>
</td></tr>
<tr><td><code id="predict.locppm_+3A_locations">locations</code></td>
<td>

<p>Point pattern of locations where prediction should be computed.
</p>
</td></tr>
<tr><td><code id="predict.locppm_+3A_type">type</code></td>
<td>

<p>Character string (partially matched) specifying the type of
predicted value: the conditional intensity <code>"cif"</code> (the
default), or the first order trend, or the intensity.
For Poisson models all three options are equivalent.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are methods for the generic functions
<code><a href="stats.html#topic+fitted">fitted</a></code>
and 
<code><a href="stats.html#topic+predict">predict</a></code>
for the class <code>"locppm"</code> of  locally-fitted  Gibbs point process
models.
</p>
<p>The <code>fitted</code> method computes,
for each quadrature point <code>v</code>
(or in general, at each point <code>v</code> where a local model was fitted),
the intensity of the locally-fitted model at <code>v</code>.
The result is a numeric vector.
</p>
<p>The <code>predict</code> computes the fitted intensity at any specified
set of <code>locations</code>, and returns the result as an <code>ssf</code> object.
</p>


<h3>Value</h3>

<p>For <code>fitted.locppm</code>, a numeric vector.
</p>
<p>For <code>predict.locppm</code>, an object of class <code>"ssf"</code>
as described in <code><a href="spatstat.explore.html#topic+ssf">ssf</a></code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Baddeley, A. (2017) Local composite likelihood
  for spatial point patterns. <em>Spatial Statistics</em> <b>22</b>, 261&ndash;295. DOI: 10.1016/j.spasta.2017.03.001
</p>
<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>. Chapman and Hall/CRC Press. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+locppm">locppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fit &lt;- locppm(cells, sigma=0.1, use.fft=TRUE)
  lam &lt;- predict(fit)
</code></pre>

<hr>
<h2 id='psib.loccit'>
Sibling Probability of Locally Fitted Cluster Point Process
</h2><span id='topic+psib.loccit'></span><span id='topic+psib.locmincon'></span>

<h3>Description</h3>

<p>Computes the sibling probability of a locally fitted
cluster point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'loccit'
psib(object)

  ## S3 method for class 'locmincon'
psib(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psib.loccit_+3A_object">object</code></td>
<td>

<p>Fitted cluster point process model
(object of class <code>"loccit"</code> or <code>"locmincon"</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In a Poisson cluster process, two points are called <em>siblings</em>
if they belong to the same cluster, that is, if they had the same
parent point. If two points of the process are
separated by a distance <code class="reqn">r</code>, the probability that
they are siblings is <code class="reqn">p(r) = 1 - 1/g(r)</code> where <code class="reqn">g</code> is the
pair correlation function of the process.
</p>
<p>The value <code class="reqn">p(0) = 1 - 1/g(0)</code> is the probability that,
if two points of the process are situated very close to each other,
they came from the same cluster. This probability
is an index of the strength of clustering, with high values
suggesting strong clustering.
</p>
<p>This concept was proposed in Baddeley, Rubak and Turner (2015, page 479)
and Baddeley (2016).
</p>
<p>The function <code><a href="spatstat.model.html#topic+psib">psib</a></code> is generic, with methods for
<code>"kppm"</code>, <code>"loccit"</code> and <code>"locmincon"</code>.
</p>
<p>The functions described here are the methods for
locally-fitted cluster models of class <code>"loccit"</code> and <code>"locmincon"</code>.
They compute the spatially-varying sibling probability of the
locally-fitted model.
</p>


<h3>Value</h3>

<p>A spatially sampled function (object of class
<code>"ssf"</code>) giving the spatially-varying sibling probability.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Baddeley, A. (2017) Local composite likelihood
  for spatial point patterns. <em>Spatial Statistics</em> <b>22</b>, 261&ndash;295. DOI: 10.1016/j.spasta.2017.03.001
</p>
<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>. Chapman and Hall/CRC Press. 
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.model.html#topic+psib">psib</a></code>,
<code><a href="spatstat.model.html#topic+kppm">kppm</a></code>,
<code><a href="#topic+loccit">loccit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   ## Not run: 
   fit &lt;- loccit(redwood, ~1, "Thomas")
   
## End(Not run)
   
   fit
   plot(psib(fit))
</code></pre>

<hr>
<h2 id='Smooth.locmincon'>
Smooth a Locally Fitted Cluster or Cox Point Process Model
</h2><span id='topic+Smooth.locmincon'></span>

<h3>Description</h3>

<p>Applies kernel smoothing to the fitted cluster parameters of a locally-fitted
cluster or Cox point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'locmincon'
Smooth(X, tau = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Smooth.locmincon_+3A_x">X</code></td>
<td>

<p>Object of class <code>"locmincon"</code>.
</p>
</td></tr>
<tr><td><code id="Smooth.locmincon_+3A_tau">tau</code></td>
<td>

<p>Smoothing bandwidth.
</p>
</td></tr>
<tr><td><code id="Smooth.locmincon_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code><a href="spatstat.explore.html#topic+Smooth.ppp">Smooth.ppp</a></code>
controlling the smoothing and the pixel resolution.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class <code>"locmincon"</code> represents
a locally-fitted Cox or cluster point process model.
It provides estimates of the cluster parameters at each of the
data points of the original point pattern dataset.
</p>
<p>The parameter estimates will be smoothed using a Gaussian
kernel with standard deviation <code>tau</code>.
</p>


<h3>Value</h3>

<p>A pixel image or a list of pixel images.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Baddeley, A. (2017) Local composite likelihood
  for spatial point patterns. <em>Spatial Statistics</em> <b>22</b>, 261&ndash;295. DOI: 10.1016/j.spasta.2017.03.001
</p>
<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>. Chapman and Hall/CRC Press. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+locmincon">locmincon</a></code>,
<code><a href="spatstat.explore.html#topic+Smooth.ppp">Smooth.ppp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   fit &lt;- locmincon(redwood)
   Smooth(fit, tau=0.1)
</code></pre>

<hr>
<h2 id='Smooth.locppm'>
Smooth a locally fitted Gibbs model
</h2><span id='topic+Smooth.locppm'></span>

<h3>Description</h3>

<p>Applies kernel smoothing to one of the components of a locally-fitted
Gibbs point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'locppm'
Smooth(X, ..., what = "cg")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Smooth.locppm_+3A_x">X</code></td>
<td>

<p>A locally-fitted  Gibbs point process model (object of class
<code>"locppm"</code>). 
</p>
</td></tr>
<tr><td><code id="Smooth.locppm_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="spatstat.explore.html#topic+Smooth.ppp">Smooth.ppp</a></code>
to control the smoothing.
</p>
</td></tr>
<tr><td><code id="Smooth.locppm_+3A_what">what</code></td>
<td>

<p>Component to be smoothed. A character string.
The default is to smooth the fitted coefficient vectors.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extracts the selected quantity from the fitted object
and spatially smooths it using <code><a href="spatstat.explore.html#topic+Smooth.ppp">Smooth.ppp</a></code>.
The result is a pixel image or a list of pixel images.
</p>


<h3>Value</h3>

<p>A pixel image or a list of pixel images.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Baddeley, A. (2017) Local composite likelihood
  for spatial point patterns. <em>Spatial Statistics</em> <b>22</b>, 261&ndash;295. DOI: 10.1016/j.spasta.2017.03.001
</p>
<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>. Chapman and Hall/CRC Press. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+locppm">locppm</a></code>,
<code><a href="spatstat.explore.html#topic+Smooth.ppp">Smooth.ppp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fit &lt;- locppm(cells, sigma=0.1, use.fft=TRUE)
  plot(Smooth(fit))
</code></pre>

<hr>
<h2 id='spatstat.local-internal'>Internal Functions of the spatstat.local Package</h2><span id='topic+print.loccit'></span><span id='topic+locppmEngine'></span><span id='topic+locppmFFT'></span><span id='topic+vcovlocEngine'></span><span id='topic+getvcinternals'></span><span id='topic+sqmag'></span><span id='topic+sqrtmat'></span><span id='topic+invsqrtmat'></span><span id='topic+gridproxy'></span><span id='topic+locppmOptions'></span><span id='topic+print.locppmOptions'></span><span id='topic+FirstExtantEntry'></span><span id='topic+sample.imagelist'></span><span id='topic+locppmPredict'></span><span id='topic+check.flat.matrix'></span><span id='topic+as.flat.matrix'></span><span id='topic+handle.flat.matrix'></span><span id='topic+invert.flat.matrix'></span><span id='topic+trace.flat.matrix'></span><span id='topic+transpose.flat.matrix'></span><span id='topic+eigenvalues.flat.matrix'></span><span id='topic+average.flat.matrix'></span><span id='topic+invert.slice'></span><span id='topic+outersquare.flat.vector'></span><span id='topic+check2.flat.matrices'></span><span id='topic+handle2.flat.matrices'></span><span id='topic+multiply2.flat.matrices'></span><span id='topic+multiply2.slice'></span><span id='topic+solve2.flat.matrices'></span><span id='topic+solve2.slice'></span><span id='topic+outer2.flat.vectors'></span><span id='topic+quadform2.flat.matrices'></span><span id='topic+quadform2.slice'></span><span id='topic+quadform2symm.slice'></span><span id='topic+check3.flat.matrices'></span><span id='topic+handle3.flat.matrices'></span><span id='topic+bilinear3.slice'></span><span id='topic+bilinear3.flat.matrices'></span><span id='topic+multiply3.slice'></span><span id='topic+multiply3.flat.matrices'></span><span id='topic+matrix2imagelist'></span><span id='topic+imagelist2matrix'></span><span id='topic+loccitFFT'></span><span id='topic+extraClusterModelInfo'></span><span id='topic+applymaps'></span><span id='topic+accumulateStatusList'></span><span id='topic+HomTestMapEngine'></span><span id='topic+print.homtestmap'></span>

<h3>Description</h3>

<p>Internal functions of the <span class="pkg">spatstat.local</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> sqmag(x)
 invsqrtmat(M)
 sqrtmat(M)
 gridproxy(P, ..., dimyx = NULL, eps = NULL, xy = NULL, weights=NULL)
 ## S3 method for class 'loccit'
print(x, ...)
 locppmEngine(model, sigma, V, ..., weights,
               verbose, scopename, scopeindex,
               opt, dropterm, matrices, fastRCinloop, internals,
               fft.algorithm)
 locppmFFT(model, sigma, ..., lambda, new.coef, what, internals,
  algorithm, verbose)
 vcovlocEngine(internals, localwt=NULL, ...,
               A1dummy=FALSE, new.coef=NULL, bananas=FALSE)
 getvcinternals(model, verbose)
 locppmOptions(other, ..., other1)
 ## S3 method for class 'locppmOptions'
print(x, ...)
 FirstExtantEntry(xlist, tags, whinge)
 sample.imagelist(X,V)
 locppmPredict(homfit, coefs, type, locations, precomputed, details, index)
 check.flat.matrix(A, dimA)
 as.flat.matrix(X, ncopies)
 handle.flat.matrix(A, dimA, matrixop, ...)
 invert.flat.matrix(X,p,special)
 trace.flat.matrix(X,p)
 transpose.flat.matrix(X,dimX)
 eigenvalues.flat.matrix(X,p)
 average.flat.matrix(X,dimX,weights)
 invert.slice(x,p)
 outersquare.flat.vector(A)
 check2.flat.matrices(A, B, dimA, dimB)
 handle2.flat.matrices(A, B, dimA, dimB, operation)
 multiply2.flat.matrices(A, B, dimA, dimB)
 multiply2.slice(x, dimA, dimB, indA, indB)
 solve2.flat.matrices(A, B, dimA, dimB)
 solve2.slice(x, dimA, dimB, indA, indB)
 outer2.flat.vectors(A,B)
 quadform2.flat.matrices(A, B, dimA, dimB, Bsymmetric)
 quadform2.slice(x, dimA, dimB, indA, indB)
 quadform2symm.slice(x, dimA, dimB, indA, indB)
 check3.flat.matrices(X, Y, Z, dimX, dimY, dimZ)
 handle3.flat.matrices(X, Y, Z, dimX, dimY, dimZ, operation)
 bilinear3.slice(x, dimX, dimY, dimZ, indX, indY, indZ)
 bilinear3.flat.matrices(X, Y, Z, dimX, dimY, dimZ)
 multiply3.slice(x, dimX, dimY, dimZ, indX, indY, indZ)
 multiply3.flat.matrices(X, Y, Z, dimX, dimY, dimZ)
 matrix2imagelist(mat, W)
 imagelist2matrix(x)
 loccitFFT(fit0, sigma, rmax, ...,
           base.trendcoef, base.cluspar, base.lambda, base.lambdaim,
           clusters, hompoisfit,
           what, do.trend, do.clusters, calcopt, verbose)
 extraClusterModelInfo(name, warn)
 applymaps(maplist, x)
 accumulateStatusList(x, stats, stoponerror)
 HomTestMapEngine(x, info)
 ## S3 method for class 'homtestmap'
print(x, ...)
</code></pre>


<h3>Details</h3>

<p>These internal functions should not be called directly by the user.
They may change at any time.
</p>

<hr>
<h2 id='spatstat.local-package'>
Local Composite Likelihood
</h2><span id='topic+spatstat.local-package'></span><span id='topic+spatstat.local'></span>

<h3>Description</h3>

<p>Extension of the spatstat package, for fitting
spatial point process models by
local composite likelihood.
</p>


<h3>Details</h3>

<p>The main functions are
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+locppm">locppm</a></code> </td><td style="text-align: left;"> Local likelihood fit of Poisson model </td>
</tr>
<tr>
 <td style="text-align: left;">
                         </td><td style="text-align: left;"> Local pseudolikelihood fit of Gibbs model </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+locmincon">locmincon</a></code> </td><td style="text-align: left;"> Local minimum contrast fit</td>
</tr>
<tr>
 <td style="text-align: left;">
		          </td><td style="text-align: left;"> of Neyman-Scott or Cox model </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+loccit">loccit</a></code> </td><td style="text-align: left;"> Local composite likelihood fit</td>
</tr>
<tr>
 <td style="text-align: left;">
                          </td><td style="text-align: left;"> of Neyman-Scott or Cox model
  </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Baddeley, A. (2017) Local composite likelihood
  for spatial point patterns. <em>Spatial Statistics</em> <b>22</b>, 261&ndash;295. DOI: 10.1016/j.spasta.2017.03.001
</p>
<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>. Chapman and Hall/CRC Press. 
</p>

<hr>
<h2 id='ttestmap'>
Test of Effect in Locally Fitted Point Process Model
</h2><span id='topic+ttestmap'></span>

<h3>Description</h3>

<p>Perform a local <code class="reqn">t</code>-test for the presence of a covariate effect
in a locally fitted Poisson or Gibbs point process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ttestmap(object, term, ...,
         method = c("exact", "hessian", "taylor"),
         grid = FALSE, 
         ngrid = NULL, grideps = NULL,
         verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ttestmap_+3A_object">object</code></td>
<td>

<p>Locally fitted Poisson or Gibbs point process model
(object of class <code>"locppm"</code>).
</p>
</td></tr>
<tr><td><code id="ttestmap_+3A_term">term</code></td>
<td>

<p>Term to be dropped from the model.
A character string matching a term in the model formula
</p>
</td></tr>
<tr><td><code id="ttestmap_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
<tr><td><code id="ttestmap_+3A_method">method</code></td>
<td>

<p>Choice of method to be used to evaluate the <code class="reqn">t</code> statistic.
See Details.
</p>
</td></tr>
<tr><td><code id="ttestmap_+3A_grid">grid</code></td>
<td>

<p>Logical. If <code>FALSE</code>, compute the test statistic at all
quadrature points of the model. If <code>TRUE</code>, compute 
at a coarse grid of locations.
</p>
</td></tr>
<tr><td><code id="ttestmap_+3A_ngrid">ngrid</code></td>
<td>

<p>Number of grid points (in each axis direction)
for the coarse grid. Incompatible with <code>grideps</code>.
</p>
</td></tr>
<tr><td><code id="ttestmap_+3A_grideps">grideps</code></td>
<td>

<p>Spacing (horizontal and vertical) between grid points
for the coarse grid. Incompatible with <code>ngrid</code>.
</p>
</td></tr>
<tr><td><code id="ttestmap_+3A_verbose">verbose</code></td>
<td>

<p>Logical value indicating whether to print progress reports.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>object</code> should be a locally-fitted
Poisson or Gibbs point process model (object of class
<code>"locppm"</code> created by <code><a href="#topic+locppm">locppm</a></code>).
</p>
<p>This function computes the local <code class="reqn">t</code> test statistic
for the test that a particular covariate effect in the model is zero.
This is described in Baddeley (2016, sections 3 and 5).
</p>


<h3>Value</h3>

<p>Object of class <code>"ssf"</code>.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>References</h3>

<p>Baddeley, A. (2017) Local composite likelihood
  for spatial point patterns. <em>Spatial Statistics</em> <b>22</b>, 261&ndash;295. DOI: 10.1016/j.spasta.2017.03.001
</p>
<p>Baddeley, A., Rubak, E. and Turner, R. (2015) <em>Spatial Point Patterns: Methodology and Applications with R</em>. Chapman and Hall/CRC Press. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+locppm">locppm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> fit &lt;- with(copper,
        locppm(Points, ~D, covariates=list(D=distfun(Lines)), nd=c(7,15)))
 plot(ttestmap(fit, "D"))
</code></pre>

<hr>
<h2 id='with.locmincon'>
Evaluate an Expression for a Locally Fitted Model
</h2><span id='topic+with.locmincon'></span><span id='topic+with.loccit'></span>

<h3>Description</h3>

<p>Given a locally-fitted Cox or cluster point process model,
evaluate an expression involving the fitted cluster parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'locmincon'
with(data, ...)

  ## S3 method for class 'loccit'
with(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with.locmincon_+3A_data">data</code></td>
<td>

<p>An object of class <code>"locmincon"</code> or <code>"loccit"</code>
representing a locally-fitted Cox or cluster point process model.
</p>
</td></tr>
<tr><td><code id="with.locmincon_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code>with.default</code> specifying the
expression to be evaluated.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are method for the generic function <code><a href="base.html#topic+with">with</a></code> for
the classes <code>"locmincon"</code> and <code>"loccit"</code>.
</p>
<p>An object of class <code>"locmincon"</code> or <code>"loccit"</code> represents
a locally-fitted Cox or cluster point process model.
It contains a data frame
which provides estimates of the cluster parameters at each of the
data points of the original point pattern dataset.
</p>
<p>The expression specified by <code>...</code> will be evaluated
in this dataframe. If the result of evaluation
is a data frame with one row for each data point,
or a numeric vector with one entry for each data point,
then the result will be an object of class <code>"ssf"</code>
containing this information. Otherwise, the result will be
a numeric vector.
</p>


<h3>Value</h3>

<p>An object of class <code>"ssf"</code> or a numeric vector.
</p>


<h3>Author(s)</h3>

<p>Adrian Baddeley <a href="mailto:Adrian.Baddeley@curtin.edu.au">Adrian.Baddeley@curtin.edu.au</a>.
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.explore.html#topic+ssf">ssf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  example(locmincon)
  with(fit, kappa * sigma2)
  example(locmincon)
  with(fit, kappa * sigma2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
