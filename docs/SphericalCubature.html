<!DOCTYPE html><html><head><title>Help for package SphericalCubature</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SphericalCubature}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adaptIntegrateBallTri'><p>Adaptive integration over the unit ball</p></a></li>
<li><a href='#adaptIntegrateSpherePolar'><p>Adaptive integration over sphere or ball in n-dimensions</p></a></li>
<li><a href='#adaptIntegrateSphereTri'><p>Adaptive integration over spherical triangles</p></a></li>
<li><a href='#integrateSpherePolynomial'><p>Integration of polynomials over sphere or ball.</p></a></li>
<li><a href='#integrateSphereStroud11'><p>Integrate a function over the sphere in n-dimensions.</p></a></li>
<li><a href='#rect2polar'><p>n-dimensional polar coordinate transformations</p></a></li>
<li><a href='#sphereArea'><p>Surface area of spheres, volumes of balls in n-dimensions.</p></a></li>
<li><a href='#SphericalCubature-package'>
<p>Numerical integration over spheres and balls in n-dimensions; multivariate polar/spherical coordinates</p></a></li>
<li><a href='#SphericalMisc'><p>Miscellaneous internal functions used by SphericalCubature package.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Numerical Integration over Spheres and Balls in n-Dimensions;
Multivariate Polar Coordinates</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-01-09</td>
</tr>
<tr>
<td>Author:</td>
<td>John P. Nolan, American University</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>John P. Nolan &lt;jpnolan@american.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0), cubature, SimplicialCubature (&ge; 1.3), mvmesh,
abind</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides several methods to integrate functions over the unit
 sphere and ball in n-dimensional Euclidean space.  Routines for converting to/from
 multivariate polar/spherical coordinates are also provided.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-01-09 19:56:05 UTC; John</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-01-10 17:10:35 UTC</td>
</tr>
</table>
<hr>
<h2 id='adaptIntegrateBallTri'>Adaptive integration over the unit ball</h2><span id='topic+adaptIntegrateBallTri'></span><span id='topic+adaptIntegrateBallRadial'></span>

<h3>Description</h3>

<p>Adaptively integrate a function over the ball, specified by a set of spherical triangles
to define a ball (or a part of a ball).
Function <code>adaptIntegrateBallTri()</code> uses spherical triangles and 
works in n-dimensions; it uses function <code>adaptIntegrateSimplex()</code> in <span class="rlang"><b>R</b></span> package <code>SimplicialCubature</code>, which is 
based on code of Alan Genz.  <code>adaptIntegrateBallRadial()</code> integrates radial functions of the form 
f(x) = g(|x|) over the unit ball.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adaptIntegrateBallTri( f, n, S=Orthants(n), fDim=1L, maxEvals=20000L, absError=0.0, 
    tol=1.0e-5, integRule=3L, partitionInfo=FALSE, ...  ) 
adaptIntegrateBallRadial( g, n, fDim=1, maxEvals=20000L, absError=0.0, 
    tol=1e-05, integRule=3L, partitionInfo=FALSE, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adaptIntegrateBallTri_+3A_f">f</code></td>
<td>
<p>integrand function f defined on the sphere in R^n</p>
</td></tr>
<tr><td><code id="adaptIntegrateBallTri_+3A_g">g</code></td>
<td>
<p>inegrand function g defined on the real line</p>
</td></tr>
<tr><td><code id="adaptIntegrateBallTri_+3A_n">n</code></td>
<td>
<p>dimension of the space</p>
</td></tr>
<tr><td><code id="adaptIntegrateBallTri_+3A_s">S</code></td>
<td>
<p>array of spherical triangles, dim(S)=c(n,n,nS).  Columns of S should be points on the unit sphere: sum(S[,i,j]^2)=1. Execution will be faster if every simplex S[,,j] is 
contained within any single orthant.  This will happend automatically if function <code>Orthants</code>  is 
used to generate orthants, or if S is a tessellation coming from function <code>UnitSphere</code> in package <code>mvmesh</code>. If one or more simplices
interect multiple orthants, the simplices will automatically be subdivided so that each subsimplex is in a single orthant.</p>
</td></tr>
<tr><td><code id="adaptIntegrateBallTri_+3A_fdim">fDim</code></td>
<td>
<p>integer dimension of the integrand function</p>
</td></tr>
<tr><td><code id="adaptIntegrateBallTri_+3A_maxevals">maxEvals</code></td>
<td>
<p>maximum number of evaluations allowed</p>
</td></tr>
<tr><td><code id="adaptIntegrateBallTri_+3A_abserror">absError</code></td>
<td>
<p>desired absolute error</p>
</td></tr>
<tr><td><code id="adaptIntegrateBallTri_+3A_tol">tol</code></td>
<td>
<p>desired relative tolerance</p>
</td></tr>
<tr><td><code id="adaptIntegrateBallTri_+3A_integrule">integRule</code></td>
<td>
<p>integration rule to use in call to function <code>adsimp</code></p>
</td></tr>
<tr><td><code id="adaptIntegrateBallTri_+3A_partitioninfo">partitionInfo</code></td>
<td>
<p>if TRUE, return the final partition after subdivision</p>
</td></tr>
<tr><td><code id="adaptIntegrateBallTri_+3A_...">...</code></td>
<td>
<p>optional arguments to function f(x,...) or g(x,...)</p>
</td></tr>  
</table>


<h3>Details</h3>

<p><code>adaptIntegrateBallTri()</code>  takes as input a function 
f defined on the unit sphere in n-dimensions and a list of spherical triangles S and attempts to 
integrate f over (part of) the unit sphere described by S.  It uses the <span class="rlang"><b>R</b></span> package <code>SimplicialCubature</code> to
evaluate the integrals.  The spherical triangles in S should individually be contained 
in an orthant.   
</p>
<p>If the integrand is nonsmooth, you can specify a set of spherical triangles that focus the cubature routines 
on that region.  See the example below with integrand function <code>f3</code>.
</p>


<h3>Value</h3>

<p>A list containing 
</p>
<table>
<tr><td><code>status</code></td>
<td>
<p>a string describing result, ideally it should be &quot;success&quot;, otherwise it is an error/warning message.</p>
</td></tr>
<tr><td><code>integral</code></td>
<td>
<p>approximation to the value of the integral</p>
</td></tr>
<tr><td><code>I0</code></td>
<td>
<p>vector of approximate integral over each triangle in K</p>
</td></tr>
<tr><td><code>numRef</code></td>
<td>
<p>number of refinements</p>
</td></tr>
<tr><td><code>nk</code></td>
<td>
<p>number of triangles in K</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>array of spherical triangles after subdivision, dim(K)=c(3,3,nk)</p>
</td></tr>
<tr><td><code>est.error</code></td>
<td>
<p>estimated error</p>
</td></tr>
<tr><td><code>subsimplices</code></td>
<td>

<p>if partitionInfo=TRUE, this gives an array of subsimplices, see function adsimp for more details.</p>
</td></tr>
<tr><td><code>subsimplicesIntegral</code></td>
<td>

<p>if partitionInfo=TRUE, this array gives estimated values of each component of the integral on each 
subsimplex, see function adsimp for more details.</p>
</td></tr>
<tr><td><code>subsimplicesAbsError</code></td>
<td>

<p>if partitionInfo=TRUE, this array gives estimated values of the absolute error of each component of the integral on each 
subsimplex, see function adsimp for more details.</p>
</td></tr>
<tr><td><code>subsimplicesVolume</code></td>
<td>

<p>if partitionInfo=TRUE, vector of m-dim. volumes of subsimplices; this is not d-dim. volume if m &lt; n.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># integrate over ball in R^3
n &lt;- 3
f &lt;- function( x ) { x[1]^2  }
adaptIntegrateBallTri( f, n )

# integrate over first orthant only
S &lt;- Orthants( n, positive.only=TRUE ) 
a &lt;- adaptIntegrateSphereTri( f, n, S )
b &lt;- adaptIntegrateSphereTri3d( f, S )
# exact answer, adaptIntegrateSphereTri approximation, adaptIntegrateSphereTri3d approximation
sphereArea(n)/(8*n); a$integral; b$integral

# integrate a vector valued function
f2 &lt;- function( x ) { c(x[1]^2,x[2]^3) }
adaptIntegrateBallTri( f2, n=2, fDim=2 )

# example of specifiying spherical triangles that make the integration easier
f3 &lt;- function( x ) { sqrt( abs( x[1]-3*x[2] ) ) } # has a cusp along the line x[1]=3*x[2]
a &lt;- adaptIntegrateBallTri( f3, n=2, absError=0.0001, partitionInfo=TRUE )
str(a) # note that returnCode = 1, e.g. maxEvals exceeded

# define problem specific spherical triangles, using direction of the cusp
phi &lt;- atan(1/3); c1 &lt;- cos(phi); s1 &lt;- sin(phi)
S &lt;- array( c(1,0,c1,s1,  c1,s1,0,1,    0,1,-1,0,   -1,0,-c1,-s1,  
            -c1,-s1,0,-1, 0,-1,1,0), dim=c(2,2,6) )
b &lt;- adaptIntegrateBallTri( f3, n=2, S, absError=0.0001, partitionInfo=TRUE )
str(b) # here returnCode=0, less than 1/2 the function evaluations and smaller estAbsError

# integrate x[1]^2 over nested balls of radius 2 and 5 (see discussion in ?SphericalCubature)
f4 &lt;- function( x ) { c( 2^2 * (2*x[1])^2, 5^2 * (5*x[1])^2 ) }
bb &lt;- adaptIntegrateBallTri( f4, n=2, fDim=2 )
str(bb)
bb$integral[2]-bb$integral[1] # = integral of x[1]^2 over the annulus 2 &lt;= |x| &lt;= 5

</code></pre>

<hr>
<h2 id='adaptIntegrateSpherePolar'>Adaptive integration over sphere or ball in n-dimensions</h2><span id='topic+adaptIntegrateSpherePolar'></span><span id='topic+adaptIntegrateSpherePolarSplit'></span><span id='topic+adaptIntegrateBallPolar'></span><span id='topic+adaptIntegrateBallPolarSplit'></span>

<h3>Description</h3>

<p>Approximate the integral over the sphere or ball in n-dimensions using polar 
coordinates.  Can also integrate over sectors of the sphere/ball, see details.  These functions
will be slow, but may be necessary to get accurate answers if the integrand
function f(x) is not smooth.  If the integrand changes rapidly
in certain regions, the basic routines <code>adaptIntegrateSpherePolar()</code> and 
codeadaptIntegrateBallPolar() will likely miss these abrupt changes and give
inaccurate results.  For cases where the location of the rapid changes are known,
the functions <code>adaptIntegrateSpherePolarSplit()</code> and
<code>adaptIntegrateBallPolarSplit()</code> allow you to split the region of integration
and capture those changes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adaptIntegrateSpherePolar(f, n, lowerLimit = rep(0, n - 1), 
    upperLimit = c(rep(pi, n - 2), 2 * pi), tol = 1e-05, ...) 
adaptIntegrateSpherePolarSplit(f, n, xstar, width = 0, lowerLimit = rep(0, n - 1), 
    upperLimit = c(rep(pi, n - 2), 2 * pi), tol = 1e-05, ...)

adaptIntegrateBallPolar(f, n, lowerLimit = rep(0, n - 1), 
    upperLimit = c(rep(pi, n - 2), 2 * pi), R = c(0, 1), tol = 1e-05, ...)
adaptIntegrateBallPolarSplit(f, n, xstar, width = 0, lowerLimit = rep(0, n - 1), 
    upperLimit = c(rep(pi, n - 2), 2 * pi), R = c(0, 1), tol = 1e-05, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adaptIntegrateSpherePolar_+3A_f">f</code></td>
<td>
<p>Integrand function f(x)=f(x[1],...,x[n]).
</p>
</td></tr>
<tr><td><code id="adaptIntegrateSpherePolar_+3A_n">n</code></td>
<td>
<p>dimension of the space.  The sphere is an (n-1) dimensional
manifold inside n-space, the ball is an n-dimensional solid.
</p>
</td></tr>
<tr><td><code id="adaptIntegrateSpherePolar_+3A_lowerlimit">lowerLimit</code></td>
<td>
<p>Polar angular coordinates of lower limit
</p>
</td></tr>
<tr><td><code id="adaptIntegrateSpherePolar_+3A_upperlimit">upperLimit</code></td>
<td>
<p>Polar angular coordinates of upper limit
</p>
</td></tr>
<tr><td><code id="adaptIntegrateSpherePolar_+3A_tol">tol</code></td>
<td>
<p>tolerance, the desired accuracy of the result.  The functions try to get abs(exact-integral) &lt; tol
</p>
</td></tr>
<tr><td><code id="adaptIntegrateSpherePolar_+3A_...">...</code></td>
<td>
<p>optional arguments passed to f.  If used, these should be specified with a tag, e. g. param1=7
</p>
</td></tr>
<tr><td><code id="adaptIntegrateSpherePolar_+3A_r">R</code></td>
<td>
<p>a numeric vector of length 2, integration is performed over the region with R[1] &lt; radius &lt; R[2].
</p>
</td></tr>
<tr><td><code id="adaptIntegrateSpherePolar_+3A_xstar">xstar</code></td>
<td>
<p>(n x m) matrix whose columns give the directions where the integrand changes quickly, where the 
region will be subdivided to focus on that region.  (The length of a column vector is not used, just it's direction.)
</p>
</td></tr>
<tr><td><code id="adaptIntegrateSpherePolar_+3A_width">width</code></td>
<td>
<p>width of 'splitting regions', a vector of length m. If it is of length 1, 
then that value is repeated for each j in 1:m.
If width[j]=0, the angular region is split just at the points given by the columns xstar[ ,j].
If width[j] &gt; 0, then angular region is split at an angle plus and minus width[j].
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Approximate the integral of f(x) over all/part of the sphere or ball in n-space.
The approach is simplistic: reparameterize the
region in polar coordinates.  For the sphere, this makes the region of integration a rectangle
in dimension (n-1) in the angle space (here the radius is fixed: R=1).  For the ball, the polar representation in terms
of angles and radius gives an region of integration that is an n dimensional rectangle.
The <span class="rlang"><b>R</b></span> package <code>cubature</code> is used to evaluate the transformed integral.  
</p>
<p>The region of integration can be a subset of the sphere/ball by specifying a
patch/sector in polar coordinates.  
To integrate over a subregion, bounds for the polar integration have be specified.  For example,
in two dimensions, you can integrate over the top half of the circle by specifying lowerLimit=0.0
and upperLimit=pi to <code>adaptIntegrateSpherePolar()</code>.  Likewise for the ball, to integrate over the part of the annulus
with inner radius .2 and outer radius .7 that is in the first quadrant, specify
lowerLimit=0.0, upperLimit=pi/2, R=c(.2,.7).
</p>


<h3>Value</h3>

<p>For <code>adaptIntegrateSpherePolar()</code> and <code>adaptIntegrateBallPolar()</code>, the function returns a
list containing several fields.  There is always a field
</p>
<table>
<tr><td><code>integral</code></td>
<td>
<p>Giving the approximate value of the integral.</p>
</td></tr>
</table>
<p>The other fields depend on the dimension: when n=2, the other fields are
what is returned by the function <code>integrate()</code> in base <span class="rlang"><b>R</b></span>;
when n &gt; 2, the other fields are the fields returned by package <code>cubature</code>.
</p>
<p>For <code>adaptIntegrateSpherePolarSplit()</code> and <code>adaptIntegrateBallPolarSplit()</code>, a single value is returned.  (This is 
because these functions make multiple calls to the adaptive integration routine and the 
results of each call are not saved.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+polar2rect">polar2rect</a></code>, <code><a href="#topic+rect2polar">rect2polar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f1 &lt;- function( x ) { return(x[1]^2+3*x[2]+exp(x[3])) }
n &lt;- 3
adaptIntegrateSpherePolar( f1, n )
adaptIntegrateSpherePolarSplit( f1, n, xstar=matrix(c(1,1,1),nrow=3) )
adaptIntegrateBallPolar( f1, n )
adaptIntegrateBallPolarSplit( f1, n, xstar=matrix(c(1,1,1),nrow=3) )

# test of adaptive integration with deliberate splitting
# function f3 has a sharp spike in the direction (1,2),
# elsewhere it has value 1
f3 &lt;- function( x ) {
  x0 &lt;- c(1.0,2.0)/sqrt(5.0)
  dist &lt;- sqrt(sum( (x-x0)^2) )
  y &lt;- 10-5000*dist
  y &lt;- 1 + max(y,0)
  return(y)  }

# no splitting: this straightforward attempt at integration misses
# the spike and sees the integrand as =1 everywhere, so returns 2*pi
n &lt;- 2
adaptIntegrateSpherePolar( f3, n ) 

# deliberate splitting at specified points, but still misses spike
# default width=0 splits the region of integration from [0,2*pi] to [0,a] union [a,2*pi],
# where tan(a)=2/1.
xstar &lt;- matrix( c(1.0,2.0,-1.0,1.0), nrow=2 )
adaptIntegrateSpherePolarSplit( f3, n, xstar=xstar )

# deliberate splitting around specified points, 'smart' choice of width gets the spike
# Here the region of integration is split into [0,a-.01] U [a-.01,a+.01] U [a+.01,2*pi]
adaptIntegrateSpherePolarSplit( f3, n, xstar=xstar, width=c(0.01,0.01) )
</code></pre>

<hr>
<h2 id='adaptIntegrateSphereTri'>Adaptive integration over spherical triangles</h2><span id='topic+adaptIntegrateSphereTri'></span><span id='topic+adaptIntegrateSphereTri3d'></span><span id='topic+adaptIntegrateSphereTriI0'></span><span id='topic+adaptIntegrateSphereTriI1'></span><span id='topic+adaptIntegrateSphereTriSubdivideK'></span>

<h3>Description</h3>

<p>Adaptively integrate a function over a set of spherical triangles.
Function <code>adaptIntegrateSphereTri()</code> uses spherical triangles and 
works in n-dimensions; it uses function <code>adaptIntegrateSimplex()</code> in package SimplicialCubature, which is 
based on code of Alan Genz.  <code>adaptIntegrateSphereTri3d()</code> works only in 3-dimensions and is 
described in the paper by N. Boal and F-J. Sayas; it is not as sophisticated and is slower than <code>adaptIntegrateSphereTri()</code>, but can be useful and is self contained.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adaptIntegrateSphereTri( f, n, S, fDim=1L, maxEvals=20000L, absError=0.0, 
    tol=1.0e-5, integRule=3L, partitionInfo=FALSE, ...  ) 
adaptIntegrateSphereTri3d( f, S, maxRef=50, relTol=0.001, maxTri=50000, gamma=1.5 ) 
adaptIntegrateSphereTriI0( f, K )
adaptIntegrateSphereTriI1( f, K )
adaptIntegrateSphereTriSubdivideK( K ) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adaptIntegrateSphereTri_+3A_f">f</code></td>
<td>
<p>function f defined on the sphere</p>
</td></tr>
<tr><td><code id="adaptIntegrateSphereTri_+3A_s">S</code></td>
<td>
<p>array of spherical triangles, dim(S)=c(n,n,nS).  Columns of S should be points on the unit sphere: sum(S[,i,j]^2)=1. Execution will be faster if every simplex S[,,j] is 
contained within any single orthant.  This will happend automatically if function <code>Orthants()</code>  is 
used to generate orthants, or if S is a tessellation coming from function <code>UnitSphere()</code> in package <code>mvmesh</code>. If one or more simplices
interect multiple orthants, the simplices will automatically be subdivided so that each subsimplex is in a single orthant.</p>
</td></tr>
<tr><td><code id="adaptIntegrateSphereTri_+3A_n">n</code></td>
<td>
<p>dimension of the ball</p>
</td></tr>
<tr><td><code id="adaptIntegrateSphereTri_+3A_fdim">fDim</code></td>
<td>
<p>integer dimension of the integrand function</p>
</td></tr>
<tr><td><code id="adaptIntegrateSphereTri_+3A_maxevals">maxEvals</code></td>
<td>
<p>maximum number of evaluations allowed</p>
</td></tr>
<tr><td><code id="adaptIntegrateSphereTri_+3A_abserror">absError</code></td>
<td>
<p>desired absolute error</p>
</td></tr>
<tr><td><code id="adaptIntegrateSphereTri_+3A_tol">tol</code></td>
<td>
<p>desired relative tolerance</p>
</td></tr>
<tr><td><code id="adaptIntegrateSphereTri_+3A_integrule">integRule</code></td>
<td>
<p>integration rule to use in call to function <code>adsimp</code></p>
</td></tr>
<tr><td><code id="adaptIntegrateSphereTri_+3A_partitioninfo">partitionInfo</code></td>
<td>
<p>if TRUE, return the final partition after subdivision</p>
</td></tr>
<tr><td><code id="adaptIntegrateSphereTri_+3A_...">...</code></td>
<td>
<p>optional arguments to function f(x,...)</p>
</td></tr>  
<tr><td><code id="adaptIntegrateSphereTri_+3A_maxref">maxRef</code></td>
<td>
<p>maximum number of refinements allowed</p>
</td></tr>
<tr><td><code id="adaptIntegrateSphereTri_+3A_reltol">relTol</code></td>
<td>
<p>desired relative tolerance</p>
</td></tr>
<tr><td><code id="adaptIntegrateSphereTri_+3A_maxtri">maxTri</code></td>
<td>
<p>maximum number of triangles allowed while refining</p>
</td></tr>
<tr><td><code id="adaptIntegrateSphereTri_+3A_gamma">gamma</code></td>
<td>
<p>threshold parameter for when a triangle is subdivided, should be &gt;= 1</p>
</td></tr>
<tr><td><code id="adaptIntegrateSphereTri_+3A_k">K</code></td>
<td>
<p>a single spherical triangle in 3 space, dim(K)=c(3,3)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>adaptIntegrateSphereTri3d()</code> takes as input a function 
f defined on the unit sphere in 3-dimensions and a list of spherical triangles K0 and attempts to 
integrate f over the part of the unit sphere described by K0.  The triangles in K0 should individually contained 
in an orthant. The algorithm estimates the integral over each triangle, then estimates error on each triangle, 
and subdivides triangles with large errors.  This is repeated until either the desired accuracy is achieved, 
or there are too many subdivisions.
</p>
<p>Functions <code>adaptIntegrateSphereI0()</code>, <code>adaptIntegrateSphereI1()</code>, and <code>adaptIntegrateSphereSubdivideK()</code> are internal 
functions that compute the integral I0 for a spherical triangle, integral I1 for a spherical triangle, and subdivide
spherical triangle K into 4 smaller spherical triangles (using midpoints of each side).
</p>
<p><code>adaptIntegrateSphereTri()</code>  takes as input a function 
f defined on the unit sphere in n-dimensions and a list of spherical triangles S and attempts to 
integrate f over (part of) the unit sphere described by S.  It uses the <span class="rlang"><b>R</b></span> package <code>SimplicialCubature</code> to
evaluate the integrals.  The spherical triangles in S should individually be contained 
in an orthant. The algorithm estimates the integral over each triangle, then estimates error on each triangle, 
and subdivides triangles with large errors.  This is repeated until either the desired accuracy is achieved, 
or there are too many subdivisions.  This function is more general than <code>adaptIntegrateSphereTri3d</code> in two 
ways: (1) it works in dimension n &gt;= 2, and (2) it allows vector integrands f.  It also is generaly faster
than <code>adaptIntegrateSphereTri()</code>. Use the function <code>Orthants()</code> to get a rough triangulation of
the sphere; see the examples below.  For finer resolution triangulation can be obtained from 
<code>UnitSphere()</code> in <span class="rlang"><b>R</b></span> package <code>mvmesh</code>.    
For description of <code>adaptIntegrateSphereTri3d()</code> see www.unizar.es/galdeano/actas_pau/PDFVIII/pp61-69.pdf. 
</p>
<p>Thoughtful choice of the spherical trianges can result in faster and more accurate results, see the example below with
function <code>f3()</code>.
</p>


<h3>Value</h3>

<p>A list containing 
</p>
<table>
<tr><td><code>status</code></td>
<td>
<p>a string describing result, ideally it should be &quot;success&quot;, otherwise it is an error/warning message.</p>
</td></tr>
<tr><td><code>integral</code></td>
<td>
<p>approximation to the value of the integral</p>
</td></tr>
<tr><td><code>I0</code></td>
<td>
<p>vector of approximate integral over each triangle in K</p>
</td></tr>
<tr><td><code>numRef</code></td>
<td>
<p>number of refinements</p>
</td></tr>
<tr><td><code>nk</code></td>
<td>
<p>number of triangles in K</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>array of spherical triangles after subdivision, dim(K)=c(3,3,nk)</p>
</td></tr>
<tr><td><code>est.error</code></td>
<td>
<p>estimated error</p>
</td></tr>
<tr><td><code>subsimplices</code></td>
<td>

<p>if partitionInfo=TRUE, this gives an array of subsimplices, see function adsimp for more details.</p>
</td></tr>
<tr><td><code>subsimplicesIntegral</code></td>
<td>

<p>if partitionInfo=TRUE, this array gives estimated values of each component of the integral on each 
subsimplex, see function adsimp for more details.</p>
</td></tr>
<tr><td><code>subsimplicesAbsError</code></td>
<td>

<p>if partitionInfo=TRUE, this array gives estimated values of the absolute error of each component of the integral on each 
subsimplex, see function adsimp for more details.</p>
</td></tr>
<tr><td><code>subsimplicesVolume</code></td>
<td>

<p>if partitionInfo=TRUE, vector of m-dim. volumes of subsimplices; this is not d-dim. volume if m &lt; n.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># test of polynomial integration f(s)=s[1]^2
f &lt;- function( s ) { return( s[1]^2 ) }
n &lt;- 3

# integrate over whole sphere
S &lt;- Orthants( n )
a &lt;- adaptIntegrateSphereTri( f, n, S )
b &lt;- adaptIntegrateSphereTri3d( f, S )
# exact answer, adaptIntegrateSphereTri approximation, adaptIntegrateSphereTri3d approximation
sphereArea(n)/n; a$integral; b$integral

# integrate over first orthant only
S &lt;- Orthants( n, positive.only=TRUE ) 
a &lt;- adaptIntegrateSphereTri( f, n, S )
b &lt;- adaptIntegrateSphereTri3d( f, S )
# exact answer, adaptIntegrateSphereTri approximation, adaptIntegrateSphereTri3d approximation
sphereArea(n)/(8*n); a$integral; b$integral

# example of specifiying spherical triangles that make the integration easier
f3 &lt;- function( x ) { sqrt( abs( x[1]-3*x[2] ) ) } # has a cusp along the line x[1]=3*x[2]
a &lt;- adaptIntegrateSphereTri( f3, n=2, partitionInfo=TRUE )
str(a)

# define problem specific spherical triangles, using direction of the cusp
phi &lt;- atan(1/3); c1 &lt;- cos(phi); s1 &lt;- sin(phi)
S &lt;- array( c(1,0,c1,s1,  c1,s1,0,1,    0,1,-1,0,   -1,0,-c1,-s1,  
            -c1,-s1,0,-1, 0,-1,1,0), dim=c(2,2,6) )
b &lt;- adaptIntegrateSphereTri( f3, n=2, S, partitionInfo=TRUE )
str(b) # estAbsError here is 1/6 of above with approx. the same number of function evaluations
</code></pre>

<hr>
<h2 id='integrateSpherePolynomial'>Integration of polynomials over sphere or ball.</h2><span id='topic+integrateSpherePolynomial'></span><span id='topic+integrateBallPolynomial'></span>

<h3>Description</h3>

<p>Exact integration of polynomial over sphere or ball in n-dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integrateSpherePolynomial(p, valueOnly = TRUE)
integrateBallPolynomial(p, R = c(0, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="integrateSpherePolynomial_+3A_p">p</code></td>
<td>
<p>a list specifying the coefficients and powers of the polynomial.  See details below
</p>
</td></tr>
<tr><td><code id="integrateSpherePolynomial_+3A_valueonly">valueOnly</code></td>
<td>
<p>boolean saying whether to return only the value of the integral, or return both
the value and a intermediate terms.  These intermediate terms are used by integrateBallPolynomial( ).
</p>
</td></tr>
<tr><td><code id="integrateSpherePolynomial_+3A_r">R</code></td>
<td>
<p>inner and outer radius of the annular region: R[1] &lt;= radius &lt;= R[2].
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute the exact integral over the sphere in n dimensions of
a polynomial <br />
p(x[1],...,x[n])=sum (coef[i] * x[1]^k[i,1] * ... * x[n]^k[i,n]), <br />
where the sum is over i=1,...,m.  The polynomial is specified as a list <code>p</code>
with fields
</p>

<ul>
<li><p>coef, an m-vector of doubles
</p>
</li>
<li><p>k, an (m x n) matrix of integers</p>
</li></ul>

<p>m and n are given implicitly in the sizes of these arrays
output is normally just a number, the value of the integral.  If  
integrateSpherePolynomial is called with valueOnly=FALSE, a list with two fields:
</p>
  <ul>
<li><p>integral, a double containing the value of the integral
</p>
</li>
<li><p>term, a vector of length m of values used in function IntegratePolynomialBall( )</p>
</li></ul>



<h3>Value</h3>

<p><code>integrateSpherePolynomial()</code>  normally just returns a value of the integral, but if 
valueOnly=FALSE, it will return a list containing the value and intermediate terms.  These
intermediate terms correspond to the integral of each monomial term in the polynomial; they
are used by <code>integrateBallPolynomial()</code>.  
</p>
<p>integrateBallPolynomial( ) returns just the value of the integral.
</p>


<h3>References</h3>

<p>Method is from How to Integrate a Polynomial over a Sphere, 
by G. Folland (2001), MAA Monthly 108, pg. 446-448.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 3
# specify the polynomial p(x) = 1.0 * x[1]^2 * x[2]^0 * x[3]^0 + 7.0 * x[1]^0 * x[2]^3 * x[3]
p &lt;- list(coef=c(1.0,7.0),k=matrix( c(2L,0L,0L,0L,3L,0L), byrow=TRUE, nrow=2) )
integrateSpherePolynomial( p )
integrateBallPolynomial( p )

# compare to adaptive integration
f4 &lt;- function( x ) { return( x[1]^2 + 7*x[2]^2*x[3] ) }
adaptIntegrateSpherePolar( f4, n )$integral
adaptIntegrateBallPolar( f4, n )$integral
</code></pre>

<hr>
<h2 id='integrateSphereStroud11'>Integrate a function over the sphere in n-dimensions.
</h2><span id='topic+integrateSphereStroud11'></span>

<h3>Description</h3>

<p>Approximate the integral of a function f(x)=f(x[1],...,x[n])
over the unit sphere in n-space using Stroud's method of degree 11.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integrateSphereStroud11(f, n, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="integrateSphereStroud11_+3A_f">f</code></td>
<td>
<p>function f(x)=f(x[1],...,x[n]) to integrate
</p>
</td></tr>
<tr><td><code id="integrateSphereStroud11_+3A_n">n</code></td>
<td>
<p>dimension of the space, implemented for n in the range 3:16.
</p>
</td></tr>
<tr><td><code id="integrateSphereStroud11_+3A_...">...</code></td>
<td>
<p>optional arguments passed to f( ).  If these are specified, they should be labeled with a tag, 
e.g. param1=3.4
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method works if the integrand is smooth.
If the function changes rapidly, adaptive integration can be tried as described in 'See Also' below.
</p>


<h3>Value</h3>

<p>A single number, the approximation to the integral.
</p>


<h3>References</h3>

<p>Stroud integration and related functions, adapted from fortran code by John Burkhart found at <br />
http://people.sc.fsu.edu/~jburkardt/f77_src/stroud/stroud.html <br />
Based on the book by A. H. Stroud, Approximate Calculation of
multiple integrals, 1971, page 296-297.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+adaptIntegrateSpherePolar">adaptIntegrateSpherePolar</a></code>, <code><a href="#topic+adaptIntegrateBallPolar">adaptIntegrateBallPolar</a></code>, <code><a href="#topic+adaptIntegrateSphereTri">adaptIntegrateSphereTri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f2 &lt;- function( x ) { return(x[1]^2) }
integrateSphereStroud11( f2, n=3 )
</code></pre>

<hr>
<h2 id='rect2polar'>n-dimensional polar coordinate transformations</h2><span id='topic+rect2polar'></span><span id='topic+polar2rect'></span>

<h3>Description</h3>

<p>Convert between polar and rectangular coordinates in n-dimensions.
The point  (x[1],...,x[n]) in rectangular coordinates corresponds to the point  (r,phi[1],...,phi[n-1])
in polar coordinates.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polar2rect(r, phi)
rect2polar(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rect2polar_+3A_r">r</code></td>
<td>
<p>a vector of radii of length m.
</p>
</td></tr>
<tr><td><code id="rect2polar_+3A_phi">phi</code></td>
<td>
<p>angles, a matrix of size (n-1) x m.
</p>
</td></tr>
<tr><td><code id="rect2polar_+3A_x">x</code></td>
<td>
<p> (n x m) matrix, with column j being the point in n-dimensional space.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>n dimensional polar coordinates are given by the following: <br />
rectangular x=(x[1],...,x[n])  corresponds to
polar  (r,phi[1],...,phi[n-1]) by <br />
x[1]  = r*cos(phi[1]) <br />
x[j]  = r*prod(sin(phi[1:(j-1)]))*cos(phi[j]), 2 &lt;= j &lt;= n-1 <br />
... <br />
x[n]  = r*sin(phi[1])*sin(phi[2])*...*sin(phi[n-2])*sin(phi[n-1]) <br />
</p>
<p>This is the defintion used in Wikipedia under the topic 'n-sphere'.
There are variations of   this definition in use.
Here phi[1],...,phi[n-2] are in [0,pi), and phi[n-1] is in [0,2*pi).
For multivariate integration, the determinant of the Jacobian of the above tranformation
is J(r,phi) = r^(n-1) * prod( sin(phi[1:(n-2)])^((n-2):1) );
note that phi[n-1] does not appear in the Jacobian.  
</p>


<h3>Value</h3>

<p>For polar2rect( ), an (n x m) matrix of rectangular coordinates.
</p>
<p>For rect2polar( ), a list with fields:
</p>
<table>
<tr><td><code>r</code></td>
<td>
<p>a vector of length m containing the radii</p>
</td></tr>
<tr><td><code>phi</code></td>
<td>
<p>angles, a matrix of size (n x m)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix( 1:9, nrow=3 )
x
a &lt;- rect2polar( x )
a
polar2rect( a$r, a$phi )
</code></pre>

<hr>
<h2 id='sphereArea'>Surface area of spheres, volumes of balls in n-dimensions.
</h2><span id='topic+sphereArea'></span><span id='topic+ballVolume'></span>

<h3>Description</h3>

<p>Calculates the (n-1) dimensional surface area 
of a sphere and the n dimensional volume of a ball in n-space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sphereArea(n, R = 1)
ballVolume(n, R = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sphereArea_+3A_n">n</code></td>
<td>
<p>Dimension of the space.
</p>
</td></tr>
<tr><td><code id="sphereArea_+3A_r">R</code></td>
<td>
<p>Radius of the sphere/ball.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Single number that is the area of the sphere/volume of the ball.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sphereArea(n=5)
ballVolume(n=5)
</code></pre>

<hr>
<h2 id='SphericalCubature-package'>
Numerical integration over spheres and balls in n-dimensions; multivariate polar/spherical coordinates</h2><span id='topic+SphericalCubature-package'></span><span id='topic+SphericalCubature'></span>

<h3>Description</h3>

<p>Provides functions to integrate a function f(x)=f(x[1],...,x[n])
over the unit sphere and unit ball in n-dimensional Euclidean space:
</p>
<p style="text-align: center;"><code class="reqn">\int_S f(s) ds \quad \quad \quad \quad \mathrm{and} \quad \quad \quad \int_B f(x) dx,</code>
</p>

<p>where the first integral is over the unit sphere S, an (n-1) dimensional surface,
and the second integral is over the unit ball B, an n dimensional solid.
Vector valued integrands are allowed in some functions; see functions with an argument named <code>fDim</code>.
</p>
<p>Integration over general sphers and balls can be done by adjusting the integrand function: if S2 is sphere with center x0 and radius R and B2 is a ball with
same center and radius, a simple change of variable shows that 
</p>
<p style="text-align: center;"><code class="reqn">\int_{S2} f(t) dt = \int_S R^{n-1} f(x0+R s) ds  \quad \quad \quad \mathrm{and}  \quad \quad \int_{B2} f(y) dy = \int_B R^n f(x0+R x) dx.</code>
</p>

<p>See the example in <code><a href="#topic+adaptIntegrateBallTri">adaptIntegrateBallTri</a></code>.
</p>
<p>The package also includes functions to convert to/from polar coordinates in higher dimensions.
</p>
<p>There are three cubature methods:
</p>

<ol>
<li><p> exact methods for polynomials in any dimension (fast)
</p>
</li>
<li><p> a method due to Stroud for smooth integrands  on the sphere (in 
dimensions n=3,4,...,16) (slower)
</p>
</li>
<li><p> adaptive methods for integrands with different behavior in different regions (slowest) 
</p>
</li></ol>

<p>Methods 2 and 3 are approximations: like any numerical quadrature
algorithm, they may give inaccurate results if the integrand changes abruptly on a small region.
This happens even in one dimension, and is more difficult to find and deal with
in higher dimensions.  (One attempt to handle this difficulty is the 'split' versions of the adaptive methods,
functions <code>adaptIntegrateSpherePolarSplit()</code> and <code>adaptIntegrateBallPolarSplit()</code>,
where one can split the region of integration based on knowledge of the integrand.
This can also be done in functions <code>adaptIntegrateSphereTri()</code> and <code>adaptIntegrateBallTri()</code>
by specifying an appropriate partition in the simplices.)
</p>
<p>It is expected that these methods will yield several significant digits, but not
many digits of precision.  This seems to be the state of the art in multivariate integration.
</p>
<p>Version 1.1 of this package introduces new methods to integrate over spheres.  
Earlier versions used only polar coordinate representations of the sphere.  Now one
can use both polar representaions and triangulations of the sphere.  The latter has advantages in
some cases: it avoids the problems with polar coordinates giving regions that are sometimes
rectangles and sometimes triangles (which occurs at the poles), triangles can be approximately
equal area in any dimension, etc.  While adding these new routines,
names became confusing.  Apologies to anyone who has trouble because of this, but it seems
better in the long run to explicitly name functions based on their approach.  Hence
<code>adaptIntegrateSphere()</code> has been renamed <code>adaptIntegrateSpherePolar()</code> to indicate
that it uses polar coordinates, while the functions <code>adaptIntegrateSphereTri()</code> and 
<code>adaptIntegrateBallTri()</code> uses spherical triangles. 
</p>
<p>An explicit goal was to get beyond the cases where n=2, so some 
efficiency has been sacrificed. In all the methods, the higher the 
dimension n, the longer the compute time.  For methods 2 and 3, compute
times get noticeable when n &gt; 5.  One application 
that motivated this package required the ability to work reliably with integrands that have 
spikes. That requires some sort of adaptive technique, with the possibility of telling
the integration algorithm where the spikes are.
</p>
<p>This package is an attempt to provide methods for integrating
over spheres and balls in multiple dimensions, not a final answer.  One possible improvement is speed:
coding routines in C would give a significant increase in speed.  
Another possible extension is to include other multivariate integration
methods,  e.g. the package R2cuba.  This may provide a way to approximate 
higher dimensional integrals in some cases, if the integrand is well behaved.

</p>
<p>Please let me know if you find any mistakes. Constructive comments for improvements are welcome.  
Fixing bugs or implementing suggestions will be dependent on my workload.
</p>
<p>Version history: 
</p>

<ul>
<li><p> 1.0.0 (2013-05-16) original package
</p>
</li>
<li><p> 1.0.1 (2013-05-24) fix mistake in <code>adaptIntegrateBallPolarSplit</code>, fix example in <code>integratePolynomialSphere</code>, add more documentation
</p>
</li>
<li><p> 1.0.2 (2013-12-18) add function <code>adaptIntegrateSphereTri3d</code> to integrate over spherical triangles in 3-dimensions
</p>
</li>
<li><p> 1.1 (2016-05-14) add function <code>adaptIntegrateSphereTri</code> to integrate over spherical triangles in n-dimensions. 
</p>
</li>
<li><p> 1.2 (2016-07-23) improve <code>adaptIntegrateSphereTri</code> where the integration over octants worked, but integrals over other subdivisions did not.
New version works over any subdivision that doesn't cross into different octants (this is checked). 
Minor changes to documentation were made and more checks on input values were added.
</p>
</li>
<li><p> 1.3 (2017-09-16)  Improve changes in version 1.2: remove the restricition on simplices in <code>adaptIntegrateSphereTri</code>:  
the input simplices are analyzed and if a simplex is in more than one orthant, it is automatically subdivided, giving a 
list of simplices that exactly cover the same part of the sphere and respect each orthant.
Fix adaptIntegrateSphericalCubatureTri to correctly pass optional arguments to the integrand function. 
Change the word &quot;octant&quot; to &quot;orthant&quot; throughout the code to stress that the code works in higher dimensions.
</p>
</li>
<li><p> 1.4 (2017-09-16) minor tweaks
</p>
</li>
<li><p> 1.5 (2021-01-04) (a) Fix bug in function <code>rect2polar()</code> (conversion from rectangular to 
polar coordinates) that occurred along an axis.  Thanks to Prof. Eckard Liebscher for 
finding this mistake. (b) Add function <code>adaptIntegrateBallSimplices()</code>.  
(c) Use the new function <code>adaptIntegrateVectorFunc()</code> from package
SimplicialCubature to handle the 2-dimensional case of integrating over a sphere. 
(d) Add a required argument to function <code>adaptIntegrateSphereTri()</code>.
(e) Add function <code>adaptIntegrateBallRadial()</code> to integrate a radial function over the unit ball. 
(f) Recode function <code>Orthants()</code> to be a standalone
function, not requiring package <code>mvmesh</code>. (g) add to documentation.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>John P. Nolan
</p>
<p>Maintainer: John P. Nolan &lt;jpnolan@american.edu&gt;
</p>
<p>This research was supported by an agreement with Cornell University, Operations 
Research &amp; Information Engineering, under contract W911NF-12-1-0385 from the Army 
Research Development and Engineering Command.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+integrateSpherePolynomial">integrateSpherePolynomial</a></code>, <code><a href="#topic+integrateBallPolynomial">integrateBallPolynomial</a></code>, 
<code><a href="#topic+integrateSphereStroud11">integrateSphereStroud11</a></code>, <code><a href="#topic+sphereArea">sphereArea</a></code>, <code><a href="#topic+ballVolume">ballVolume</a></code>,
<code><a href="#topic+polar2rect">polar2rect</a></code>, <code><a href="#topic+rect2polar">rect2polar</a></code>, 
<code><a href="#topic+adaptIntegrateSpherePolar">adaptIntegrateSpherePolar</a></code>, <code><a href="#topic+adaptIntegrateSpherePolarSplit">adaptIntegrateSpherePolarSplit</a></code>, 
<code><a href="#topic+adaptIntegrateSphereTri">adaptIntegrateSphereTri</a></code>, <code><a href="#topic+adaptIntegrateSphereTri3d">adaptIntegrateSphereTri3d</a></code>,
<code><a href="#topic+adaptIntegrateBallPolar">adaptIntegrateBallPolar</a></code>, <code><a href="#topic+adaptIntegrateBallPolarSplit">adaptIntegrateBallPolarSplit</a></code>,
<code><a href="#topic+adaptIntegrateBallTri">adaptIntegrateBallTri</a></code>, 
<code><a href="#topic+adaptIntegrateBallRadial">adaptIntegrateBallRadial</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#  integral should just be the area of sphere in n dimensions
f1 &lt;- function( x ) { return(1.0) }
n &lt;- 3
adaptIntegrateBallTri( f1, n )   # exact answer = volume of ball = (4/3)*pi = 4.18879

# other methods
integrateSphereStroud11( f1, n )
adaptIntegrateSpherePolar( f1, n )$integral 
# exact value for a polynomial
p &lt;- list(coef=1.0,k=matrix( rep(0L,n), nrow=1,ncol=n))
integrateSpherePolynomial( p )

# test of exact polynomial integration
f2 &lt;- function( x ) { return(x[1]^2) }
sphereArea(n)/n # exact answer
integrateSphereStroud11( f2, n )
p &lt;- list(coef=1.0,k=matrix( c(2L,rep(0L,n-1)), nrow=1) )
integrateSpherePolynomial( p )
adaptIntegrateSpherePolar( f2, n )$integral

# integration over a ball
adaptIntegrateSphereTri( f1, n ) # exact answer = surface area of sphere = 4*pi = 12.56637

# vector valued integrands
f3 &lt;- function( x ) { c( x[1]^2, x[2]^3 ) }
adaptIntegrateBallTri( f3, n, fDim=2 )
adaptIntegrateSphereTri( f3, n, fDim=2 )

# radial function
g &lt;- function( x ) { sum(x^2) }
adaptIntegrateBallRadial( g, n=3 )

# for more examples enter:   demo(SphericalCubature)
</code></pre>

<hr>
<h2 id='SphericalMisc'>Miscellaneous internal functions used by SphericalCubature package. 
</h2><span id='topic+SphericalMisc'></span><span id='topic+adaptIntegrateSphereCheck'></span><span id='topic+nextGraySubset'></span><span id='topic+nextMultiIndex'></span><span id='topic+partitionRegion'></span><span id='topic+CheckUnitVectors'></span><span id='topic+Orthants'></span><span id='topic+SubdivideSphereTriByOrthant'></span><span id='topic+nextBinary'></span>

<h3>Description</h3>

<p>These functions are not intended for general use, they are
only listed here to document their existence.
</p>
<p>adaptIntegrateCheck is used by the adaptive integration functions
to check input parameters,
partitionRegion is used by the 'split' versions of the the adaptive
integration functions,  nextGraySubset is used by IntegrateSphereStroud11,
nextMultiIndex is used by adaptive integration functions, nextBinary
is used by Orthants.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adaptIntegrateSphereCheck( n, lowerLimit, upperLimit, R, xstar, width )
partitionRegion( xstar, width, lowerLimit, upperLimit )
nextGraySubset( gray.list )
nextMultiIndex( j, size )
CheckUnitVectors( S, eps=1.0e-14 )
Orthants( n, positive.only=FALSE )
SubdivideSphereTriByOrthant( S, eps=1.0e-14 )
nextBinary( b )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SphericalMisc_+3A_n">n</code></td>
<td>
<p>dimension of the space</p>
</td></tr>
<tr><td><code id="SphericalMisc_+3A_lowerlimit">lowerLimit</code></td>
<td>
<p>lower angular limit for integration region</p>
</td></tr>
<tr><td><code id="SphericalMisc_+3A_upperlimit">upperLimit</code></td>
<td>
<p>upper angular limit for integration region</p>
</td></tr>
<tr><td><code id="SphericalMisc_+3A_r">R</code></td>
<td>
<p>inner and outer radii for integration region</p>
</td></tr>
<tr><td><code id="SphericalMisc_+3A_xstar">xstar</code></td>
<td>
<p>directions where function changes rapidly</p>
</td></tr>
<tr><td><code id="SphericalMisc_+3A_width">width</code></td>
<td>
<p>width of subdivisions</p>
</td></tr>  
<tr><td><code id="SphericalMisc_+3A_gray.list">gray.list</code></td>
<td>
<p>list used by Stroud integration</p>
</td></tr>
<tr><td><code id="SphericalMisc_+3A_j">j</code></td>
<td>
<p>current multi-index</p>
</td></tr>
<tr><td><code id="SphericalMisc_+3A_size">size</code></td>
<td>
<p>length of multi-index</p>
</td></tr>
<tr><td><code id="SphericalMisc_+3A_s">S</code></td>
<td>
<p>a matrix or array specifying simplices</p>
</td></tr>
<tr><td><code id="SphericalMisc_+3A_eps">eps</code></td>
<td>
<p>tolerance used in test for unit vectors</p>
</td></tr>
<tr><td><code id="SphericalMisc_+3A_positive.only">positive.only</code></td>
<td>
<p>logical; if TRUE, only the first orthant is returned, if FALSE, all 2^n orthants are returned </p>
</td></tr>
<tr><td><code id="SphericalMisc_+3A_b">b</code></td>
<td>
<p>a vector of integers, representing a number in base 2</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>Orthant()</code> returns an array of simplices in the V representation; each one gives the points on the axes that are on the boundary of one orthant.
<code>CheckSphereTri()</code> performs validity checks on the simplices in S.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
