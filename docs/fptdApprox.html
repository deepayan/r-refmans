<!DOCTYPE html><html><head><title>Help for package fptdApprox</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fptdApprox}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Approx.cfpt.density'><p>Approximating First-Passage-Time Densities for Conditioned Problems</p></a></li>
<li><a href='#Approx.fpt.density'><p>Approximating First-Passage-Time Densities</p></a></li>
<li><a href='#diffproc'><p>Diffusion Processes</p></a></li>
<li><a href='#fptdApprox-package'>
<p>Approximation of First-Passage-Time Densities for Diffusion Processes</p></a></li>
<li><a href='#FPTL'><p>First-Passage-Time Location Function</p></a></li>
<li><a href='#growth.intervals'><p>Studying the Growth of a Vector</p></a></li>
<li><a href='#Integration.Steps'><p>Subintervals and Integration Steps To Approximate First-Passage-Time Densities</p></a></li>
<li><a href='#is.fpt.density'><p>Testing for objects of class &ldquo;fpt.density&rdquo;</p></a></li>
<li><a href='#plot.fpt.density'><p>Plotting Method for fpt.density Objects</p></a></li>
<li><a href='#plot.fptl'><p>Plotting Method for fptl Objects</p></a></li>
<li><a href='#print.fpt.density'><p>Printing First-Passage-Time Densities</p></a></li>
<li><a href='#report'><p>Writing a Report of an Object</p></a></li>
<li><a href='#report.fpt.density'><p>Writing a Report of a fpt.density Object</p></a></li>
<li><a href='#report.summary.fptl'><p>Writing a Report of a summary.fptl Object</p></a></li>
<li><a href='#summary.fptl'><p>Locating a Conditioned First-Passage-Time Variable</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Approximation of First-Passage-Time Densities for Diffusion
Processes</td>
</tr>
<tr>
<td>Version:</td>
<td>2.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-29</td>
</tr>
<tr>
<td>Author:</td>
<td>Patricia Roman-Roman, Juan J. Serrano-Perez and Francisco Torres-Ruiz.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Juan J. Serrano-Perez &lt;jjserra@ugr.es&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Efficient approximation of first passage time densities for diffusion processes based on the First Passage Time Location (FPTL) function.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-29 18:19:30 UTC; JUANJO</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-29 20:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Approx.cfpt.density'>Approximating First-Passage-Time Densities for Conditioned Problems</h2><span id='topic+Approx.cfpt.density'></span>

<h3>Description</h3>

<p><code>Approx.cfpt.density</code> computes values of the approximate first-passage-time (f.p.t.) density, for a conditioned problem, 
from an object of class &ldquo;summary.fptl&rdquo; that contains the information provided by First-Passage-Time Location (FPTL) function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Approx.cfpt.density(sfptl, variableStep = TRUE, from.t0 = FALSE, 
                   to.T = FALSE, skip = TRUE, n = 250, p = 0.2, 
                   alpha = 1, tol = 1e-03, it.max = 50000L)                      
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Approx.cfpt.density_+3A_sfptl">sfptl</code></td>
<td>
<p>an object of class &ldquo;summary.fptl&rdquo;, a result of applying the <code><a href="#topic+summary.fptl">summary.fptl</a></code> method to an object
of class &ldquo;fptl&rdquo;.</p>
</td></tr>
<tr><td><code id="Approx.cfpt.density_+3A_variablestep">variableStep</code></td>
<td>
<p>a logical value indicating whether a variable integration step is used.</p>
</td></tr>
<tr><td><code id="Approx.cfpt.density_+3A_from.t0">from.t0</code></td>
<td>
<p>a logical value indicating whether the approximation should be calculated from the lower end of the
interval considered, <code class="reqn">t_0</code>, specified in the <code>sfptl</code> object.</p>
</td></tr>
<tr><td><code id="Approx.cfpt.density_+3A_to.t">to.T</code></td>
<td>
<p>a logical value indicating whether the approximation should be calculated to the upper end of the
interval considered, <code class="reqn">T</code>, specified in the <code>sfptl</code> object.</p>
</td></tr>
<tr><td><code id="Approx.cfpt.density_+3A_skip">skip</code></td>
<td>
<p>a logical value indicating whether the intervals at which the FPTL function is near zero could be
avoided.</p>
</td></tr>
<tr><td><code id="Approx.cfpt.density_+3A_n">n</code></td>
<td>
<p>Number of points used to determine the integration step in subintervals <code class="reqn">[t_i^*, t_{max,i}^+]</code> 
<code class="reqn">i=1, \ldots, m</code>, from interesting instants provided by the FPTL function.</p>
</td></tr>
<tr><td><code id="Approx.cfpt.density_+3A_p">p</code></td>
<td>
<p>Ratio of n used to determine the integration step in subintervals  
<code class="reqn">[t_{max,i}^+, t_{i+1}^*]</code>, <code class="reqn">i=1, \ldots, m</code>, <code class="reqn">[t_0, t_1^*]</code> and 
<code class="reqn">[t_{max,m}^{+}, T]</code>.</p>
</td></tr>
<tr><td><code id="Approx.cfpt.density_+3A_alpha">alpha</code></td>
<td>
<p>Parameter used to determine the integration step in subintervals 
<code class="reqn">[t_{max,i}^+, t_{i+1}^*]</code>, <code class="reqn">i=1, \ldots, m</code>, <code class="reqn">[t_0, t_1^*]</code> and 
<code class="reqn">[t_{max,m}^{+}, T]</code>, in order to reduce the computational cost of approximating the f.p.t. density function 
in those cases where <code class="reqn">t_{i+1}^* - t_{max,i}^+ &gt;&gt; t_{max,i}^{-} - \thinspace t_i^*</code>, 
for some <code class="reqn">i</code>, <code class="reqn">t_1^* - t_0 &gt;&gt; t_{max,1}^{-} - \thinspace t_1^*</code> or 
<code class="reqn">T - t_{max,m}^+ &gt;&gt; t_{max,m}^{-} - \thinspace t_m^*</code>, respectively.</p>
</td></tr>  
<tr><td><code id="Approx.cfpt.density_+3A_tol">tol</code></td>
<td>
<p>If the cumulative integral of the approximation is greater than or equal to 1 - tol the algorithm is stopped.</p>
</td></tr>
<tr><td><code id="Approx.cfpt.density_+3A_it.max">it.max</code></td>
<td>
<p>If the number of iterations required for the approximation process is greater than it.max, the function asks for permission to continue.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a diffusion process <code class="reqn">\{X(t), t_0 \leq t \leq T \}</code>, the f.p.t. variable,   
conditioned to <code class="reqn">X(t_0) = x_0</code>, through a continuous boundary <code class="reqn">S(t)</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">T_{S(t), x_0} = \left\{
\begin{array}{lll}
Inf \ \{ t \geq t_0 \ : \ X(t) &gt; S(t) \mid X(t_0)=x_0 \} &amp; &amp; if \ x_0 &lt; S(t_0) \\[7pt]
Inf \ \{ t \geq t_0 \ : \ X(t) &lt; S(t) \mid X(t_0)=x_0 \} &amp; &amp; if \ x_0 &gt; S(t_0)
\end{array}
 \right. .</code>
</p>

<p>Its density function is the solution to a Volterra integral equation of the second kind. The kernel of this equation depends
on the infinitesimal moments of the process, the transition probability density function and the boundary. 
</p>
<p>Nevertheless, and apart from some particular processes and boundaries,
closed-form solutions for the integral equation are not available. For this reason, 
in the cases without explicit solutions, numerical procedures are required. That is the situation 
considered here and the numerical procedure implemented by the <code>Approx.fpt.density</code> function is the one 
proposed by Buonocore et al. (1987), based on the composite trapezoid method. <br />
</p>
<p>The <code>Approx.cfpt.density</code> function computes efficiently the approximate f.p.t. density by
using the information provided by the FPTL function contained in the 
<code>sfptl</code> object. See the function <code><a href="#topic+summary.fptl">summary.fptl</a></code> for details. <br />
</p>
<p>By default the function does not compute the approximate f.p.t. density 
from the time instant <code class="reqn">t_0</code>, but from a more suitable time instant <code class="reqn">t_1^*</code>
provided by the FPTL function. It also uses a variable integration step. <br />
</p>
<p>The function makes an internal call to <code><a href="#topic+Integration.Steps">Integration.Steps</a></code> function in order to determine the subintervals and 
integration steps to be used in the application of the numerical algorithm according to the <code>variableStep</code>, 
<code>from.t0</code>, <code>to.T</code>, <code>n</code>, <code>p</code> and <code>alpha</code> arguments. <br />
</p>
<p>In addition, if <code>skip = TRUE</code>, the function checks the approximate density value for each <code class="reqn">t_{max,i}^+</code>, 
and, if it is almost 0, the application of the numerical algorithm in the subinterval <code class="reqn">[t_{max,i}^+, t_{i+1}^*]</code> 
is avoided, and then continued from instant <code class="reqn">t_{i+1}^*</code> considering a zero value of the approximate 
density. <br />
</p>
<p>Similarly, if <code>to.T = FALSE</code>, the function checks the cumulative value of the integral for each <code class="reqn">t_{max,i}^+</code> 
provided by the FPTL function and, if it is greater than or equal to 1 - tol, the numerical algorithm is stopped. In any case, 
the algorithm is stopped in the final <code class="reqn">t_{max,i}^+</code>, and if the cumulative value of the integral is less than 1 - tol
the function issues a warning. <br />
</p>


<h3>Value</h3>

<p>The <code>Approx.cfpt.density</code> function computes and returns an object of class &ldquo;fpt.density&rdquo;. It 
is a three-component list:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>a sequence of suitable time instants in <code class="reqn">[t_0, \ T]</code> according to the arguments in the function call.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the approximate conditioned f.p.t. density function values on the x sequence.</p>
</td></tr> </table>
<p><br />
</p>
<table>
<tr><td><code>y.x0</code></td>
<td>
<p>NULL (for consistency with the object of class &ldquo;fpt.density&rdquo; that produces the <code>Approx.fpt.density</code> function).</p>
</td></tr>
</table>
<p>It also includes six additional attributes: 
</p>

<table>
<tr>
 <td style="text-align: right;">
<code>Call</code> </td><td style="text-align: left;"> the unevaluated function call, substituting each name in this call by its value when </td>
</tr>
<tr>
 <td style="text-align: right;"> 
 </td><td style="text-align: left;"> the latter has length 1. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>Steps</code> </td><td style="text-align: left;"> matrix of subintervals and integration steps to consider for computing </td>
</tr>
<tr>
 <td style="text-align: right;"> 
 </td><td style="text-align: left;"> the approximate conditioned f.p.t. density. </td>
</tr>
<tr>
 <td style="text-align: right;"> 
<code>cumIntegral</code> </td><td style="text-align: left;"> vector of the values of the cumulative integral of the </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> approximation for each subinterval considered. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>skips</code> </td><td style="text-align: left;"> a list that contains, for each subinterval, the value 1 if the application of the </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> numerical algorithm has been avoided or integer(0) otherwise. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>CPUTime</code> </td><td style="text-align: left;"> matrix of user and system times, by columns, required to approximate </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> the density for each subinterval considered, by rows. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>summary.fptl</code> </td><td style="text-align: left;"> the object used as <code>sfptl</code> argument in the function call. </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>
                                                                                          
<p><code>x</code> is the vector result of the concatenation of the sequences of equally spaced values in the suitable subintervals 
determined by the <code><a href="#topic+Integration.Steps">Integration.Steps</a></code> function. 
</p>


<h3>Author(s)</h3>

<p>Patricia Román-Román, Juan J. Serrano-Pérez and Francisco Torres-Ruiz.</p>


<h3>References</h3>

<p>Buonocore, A., Nobile, A.G. and Ricciardi, L.M. (1987) A new integral equation for the evaluation of
first-passage-time probability densities. <em>Adv. Appl. Probab.</em>, <b>19</b>, 784&ndash;800.
</p>
<p>Román, P., Serrano, J. J., Torres, F. (2008) First-passage-time location function: Application to determine first-passage-time densities in diffusion processes. <em>Comput. Stat. Data Anal.</em>, <b>52</b>, 4132&ndash;4146.
</p>
<p>P. Román-Román, J.J. Serrano-Pérez, F. Torres-Ruiz. (2012) An R package for an efficient approximation of first-passage-time densities for diffusion processes based on the FPTL function. <em>Applied Mathematics and Computation</em>, <b>218</b>, 8408&ndash;8428.
</p>
<p>P. Román-Román, J.J. Serrano-Pérez, F. Torres-Ruiz. (2014) More general problems on first-passage times for diffusion processes: A new version of the fptdApprox R package. <em>Applied Mathematics and Computation</em>, <b>244</b>, 432&ndash;446.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.fptl">summary.fptl</a></code> to locate the f.p.t. variable and create objects of class &ldquo;summary.fptl&rdquo;.
</p>
<p><code><a href="#topic+is.fpt.density">is.fpt.density</a></code> to test for objects of class &ldquo;fpt.density&rdquo;.
</p>
<p><code><a href="#topic+print.fpt.density">print.fpt.density</a></code> to show objects of class &ldquo;fpt.density&rdquo;. 
</p>
<p><code><a href="#topic+report.fpt.density">report.fpt.density</a></code> to generate a report.
</p>
<p><code><a href="#topic+plot.fpt.density">plot.fpt.density</a></code> for graphical display.
</p>
<p><code><a href="#topic+FPTL">FPTL</a></code> to evaluate the FPTL function and create objects of class &ldquo;fptl&rdquo;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Continuing the summary.fptl(.) example:

## Making an efficient approximation of the f.p.t. density 
## (optimal variable integration steps and small computational cost)
yyy &lt;- Approx.cfpt.density(yy)
yyy

zzz &lt;- Approx.cfpt.density(zz)
zzz

## Making a less efficient approximation of the f.p.t. density 
## (optimal fixed integration step but high computational cost related to 
##  the efficient approximation)
## Not run: 
yyy1 &lt;- Approx.cfpt.density(yy, variableStep = FALSE, from.t0 = TRUE, to.T = 
                         TRUE, skip = FALSE)
yyy1
## End(Not run)
</code></pre>

<hr>
<h2 id='Approx.fpt.density'>Approximating First-Passage-Time Densities</h2><span id='topic+Approx.fpt.density'></span>

<h3>Description</h3>

<p><code>Approx.fpt.density</code> computes values of the approximate first-passage-time (f.p.t.) density, for conditioned and unconditioned problems. <br />
</p>
<p>For the unconditioned case, values of the approximate densities for f.p.t. problems conditioned to suitable values of the initial distribution 
are also calculated. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Approx.fpt.density(dp, t0, T, id, S, env = NULL, variableStep = TRUE, 
                   from.t0 = FALSE, to.T = FALSE, r = 4000, zeroSlope = 0.01, 
                   p0.tol = 8, k = 3, m = 100, n = 250, p = 0.2, alpha = 1, 
                   skip = TRUE, tol = 0.001, it.max)               
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Approx.fpt.density_+3A_dp">dp</code></td>
<td>
<p>an object of class &ldquo;diffproc&rdquo; defining a family of diffusion processes.</p>
</td></tr>
<tr><td><code id="Approx.fpt.density_+3A_t0">t0</code>, <code id="Approx.fpt.density_+3A_t">T</code></td>
<td>
<p>lower and upper limits of the considered time interval. Must be finite.</p>
</td></tr>
<tr><td><code id="Approx.fpt.density_+3A_id">id</code></td>
<td>
<p>a numerical value specifying a fixed initial value of the process in the time instant specified in the <code>t0</code> argument
(for a conditioned f.p.t. problem), or a four-component list specifying the initial distribution of the process (for an unconditioned f.p.t. problem).
In the last case the first component is the <span class="rlang"><b>R</b></span> mathematical expression of the density as a character string, the second
one is a label to denote the distribution in the reports generated by the <code>report</code> method, the third one is the label to
denote the distribution for LaTeX, and the four one is a label to denote the distribution in the graphs generated by the <code>plot</code> method.</p>
</td></tr>
<tr><td><code id="Approx.fpt.density_+3A_s">S</code></td>
<td>
<p>numerical value of a constant boundary or character string with the mathematical expression of a time 
dependent boundary.</p>
</td></tr>
<tr><td><code id="Approx.fpt.density_+3A_env">env</code></td>
<td>
<p>a named list of objects of numeric or character type specifying the values of names which occur in
the mathematical expressions in objects <code>dp</code> and <code>S</code>, or of names which occur in the specification of the previous values.
Defaults to NULL, interpreted as an empty list. It is copied into a temporary environment for evaluating the mathematical expressions 
in the <code>dp</code> object and <code>S</code>.</p>
</td></tr> 
<tr><td><code id="Approx.fpt.density_+3A_variablestep">variableStep</code></td>
<td>
<p>a logical value indicating whether a variable integration step is used.</p>
</td></tr>
<tr><td><code id="Approx.fpt.density_+3A_from.t0">from.t0</code></td>
<td>
<p>a logical value indicating whether the approximation should be calculated from the lower end of the
interval considered, <code class="reqn">t_0</code>.</p>
</td></tr>
<tr><td><code id="Approx.fpt.density_+3A_to.t">to.T</code></td>
<td>
<p>a logical value indicating whether the approximation should be calculated to the upper end of the
interval considered, <code class="reqn">T</code>.</p>
</td></tr>
<tr><td><code id="Approx.fpt.density_+3A_r">r</code></td>
<td>
<p>number of points at which the FPTL function is evaluated.</p>
</td></tr>
<tr><td><code id="Approx.fpt.density_+3A_zeroslope">zeroSlope</code></td>
<td>
<p>maximum slope required to consider that a growing function is constant.</p>
</td></tr>
<tr><td><code id="Approx.fpt.density_+3A_p0.tol">p0.tol</code></td>
<td>
<p>controls where the First-Passage-Time Location function begins to increase significantly.</p>
</td></tr>
<tr><td><code id="Approx.fpt.density_+3A_k">k</code></td>
<td>
<p>controls whether the First-Passage-Time Location function decreases very slowly.</p>
</td></tr>
<tr><td><code id="Approx.fpt.density_+3A_m">m</code></td>
<td>
<p>Number of equally spaced values to select from the specified initial distribution in the case of an unconditioned f.p.t. problem.</p>
</td></tr> 
<tr><td><code id="Approx.fpt.density_+3A_n">n</code></td>
<td>
<p>Number of points used to determine the integration step in subintervals <code class="reqn">[t_i^*, t_{max,i}^+]</code> 
<code class="reqn">i=1, \ldots, m</code>, from interesting instants provided by the FPTL function.</p>
</td></tr>
<tr><td><code id="Approx.fpt.density_+3A_p">p</code></td>
<td>
<p>Ratio of n used to determine the integration step in subintervals  
<code class="reqn">[t_{max,i}^+, t_{i+1}^*]</code>, <code class="reqn">i=1, \ldots, m</code>, <code class="reqn">[t_0, t_1^*]</code> and 
<code class="reqn">[t_{max,m}^{+}, T]</code>.</p>
</td></tr>
<tr><td><code id="Approx.fpt.density_+3A_alpha">alpha</code></td>
<td>
<p>Parameter used to determine the integration step in subintervals 
<code class="reqn">[t_{max,i}^+, t_{i+1}^*]</code>, <code class="reqn">i=1, \ldots, m</code>, <code class="reqn">[t_0, t_1^*]</code> and 
<code class="reqn">[t_{max,m}^{+}, T]</code>, in order to reduce the computational cost of approximating the f.p.t. density function 
in those cases where <code class="reqn">t_{i+1}^* - t_{max,i}^+ &gt;&gt; t_{max,i}^{-} - \thinspace t_i^*</code>, 
for some <code class="reqn">i</code>, <code class="reqn">t_1^* - t_0 &gt;&gt; t_{max,1}^{-} - \thinspace t_1^*</code> or 
<code class="reqn">T - t_{max,m}^+ &gt;&gt; t_{max,m}^{-} - \thinspace t_m^*</code>, respectively.</p>
</td></tr> 
<tr><td><code id="Approx.fpt.density_+3A_skip">skip</code></td>
<td>
<p>a logical value indicating whether the intervals at which the FPTL function is near zero could be
avoided.</p>
</td></tr> 
<tr><td><code id="Approx.fpt.density_+3A_tol">tol</code></td>
<td>
<p>If the cumulative integral of the approximation is greater than or equal to 1 - tol the algorithm is stopped.</p>
</td></tr>
<tr><td><code id="Approx.fpt.density_+3A_it.max">it.max</code></td>
<td>
<p>If the number of iterations required for the approximation process is greater than it.max, the function asks for permission to continue.
Defaults to 50000 for a conditioned f.p.t. problem, and 1000000 for an unconditioned f.p.t. problem.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For an unconditioned f.p.t. problem, this function allows to compute directly the approximate f.p.t. density from an object of class &ldquo;diffproc&rdquo;. 
In contrast to the approximation of a conditioned f.p.t. density by using the <code>Approx.cfpt.density</code> function, in this case it is not necessary for users to make 
previous calls to the functions <code>FPTL</code> and <code>summary.FPTL</code>. <br />
</p>
<p>For a diffusion process <code class="reqn">\{X(t), t_0 \leq t \leq T \}</code> with non-degenerate initial distribution 
the unconditioned f.p.t. variable, through a continuous boundary <code class="reqn">S(t)</code>, is defined as
</p>
<p style="text-align: center;"><code class="reqn">T_{S(t), X(t_0)} = \left\{
\begin{array}{lll}
Inf \ \{ t \geq t_0 \ : \ X(t) &gt; S(t) \} &amp; &amp; if \ X(t_0) &lt; S(t_0) \\[7pt]
Inf \ \{ t \geq t_0 \ : \ X(t) &lt; S(t) \} &amp; &amp; if \ X(t_0) &gt; S(t_0)
\end{array}
 \right. ,</code>
</p>

<p>Its density function can be obtained by means of the numerical integration, in the range of variation of <code class="reqn">X(t_0)</code>, 
of the corresponding f.p.t. densities conditioned to values of <code class="reqn">X(t_0)</code>, weighted by the initial density function. <br />
</p>
<p>For each conditioned problem related to an unconditioned f.p.t. problem, the <code>Approx.fpt.density</code> function makes internal calls to  
<code><a href="#topic+FPTL">FPTL</a></code> and <code><a href="#topic+summary.fptl">summary.fptl</a></code> functions, in order to localize each conditioned f.p.t. variable, according to the 
<code>zeroSlope</code>, <code>p0.tol</code> and <code>k</code> arguments. Then, the function makes a internall
call to <code><a href="#topic+Integration.Steps">Integration.Steps</a></code> function, in order to determine the suitable subintervals and 
integration steps to be used to approximate the unconditioned f.p.t. density and conditioned f.p.t. densities according to the <code>variableStep</code>, 
<code>from.t0</code>, <code>to.T</code>, <code>n</code>, <code>p</code> and <code>alpha</code> arguments. <br />
</p>
<p>From this information, a suitable sequence of time instants in <code class="reqn">[t_0, T]</code> for the approximation of the f.p.t. densities is available.
For each time instant t in such sequence, the <code>Approx.fpt.density</code> function computes the value of the f.p.t. density conditioned to 
<code>m</code> values of the initial distribution (equally spaced in its range of variation), and then it computes the value of the unconditioned f.p.t density. <br />
</p>
<p>For the approximation of each conditioned f.p.t density, the numerical procedure proposed by Buonocore et al. (1987), 
based on the composite trapezoid method, has been implemented. This method has also been used in the numerical integration for obtaining
the unconditioned f.p.t. density. <br />
</p>
<p>The mathematical expression of the boundary <code>S</code> should be a function of <code class="reqn">t</code> and may include the argument <code>t0</code>,
the name <code>x0</code>, to refer to an initial value of the process, and the parameters specified in the <code>env</code> argument. 
The function checks if the mathematical expression shows syntax errors and if <span class="rlang"><b>R</b></span> can compute its symbolic derivative with respect to <code class="reqn">t</code>. <br />
</p>
<p>The <code>env</code> argument is a list of tagged values in <code>name = value</code> form with <code>name</code> other than <code class="reqn">x</code>, <code class="reqn">t</code>, <code class="reqn">y</code> and <code class="reqn">s</code>.
To name the expression of a function <code class="reqn">h(u)</code> as a character string we can use <code>`h(u)` = value</code> if we want to show its dependence on <code class="reqn">u</code>, or <code>h = value</code> otherwise. <br />
</p>
<p>The <code>env</code> argument is copied into a temporary environment for evaluating the mathematical expressions in objects <code>dp</code> and <code>S</code>. 
<span class="rlang"><b>R</b></span> looks for the objects not found into this temporary environment in the parent.frame() environment. <br />
</p>
<p>By default the function does not compute the approximate f.p.t. density from the time instant <code class="reqn">t_0</code>, but from a more suitable time instant 
provided by the First-Passage-Time Location (FPTL) function. It also uses a variable integration step. <br />
</p>
<p>If <code>skip = TRUE</code>, for each subinterval in which it could be possible to avoid calculating all the conditioned f.p.t. densities,
the function checks the value of the approximate unconditioned f.p.t. density
at the lower end of such subinterval. If it is almost 0, the approximate unconditioned f.p.t. density
calculation is avoided in the subinterval, and it continues from the upper end of the subinterval
considering a zero value of the approximate unconditioned f.p.t. density. <br />
</p>
<p>Similarly, if <code>to.T = FALSE</code>, the function checks the cumulative value of the integral for each upper end of the
subintervals for which it is not possible to avoid the application of the numerical algorithm for each conditioned problem. 
If it is greater than or equal to 1 - <code>tol</code>, the approximation procedure
is stopped. In any case, the procedure is stopped at the upper end of the last subinterval,
and if the cumulative value of the integral is less than 1 - <code>tol</code> the function issues a warning. <br />
</p>


<h3>Value</h3>

<p>The <code>Approx.fpt.density</code> function computes and returns an object of class &ldquo;fpt.density&rdquo;. This object 
is a three-component list:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>a sequence of suitable time instants in <code class="reqn">[t_0, \ T]</code> according to the arguments in the function call.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the approximate f.p.t. density function values on the x sequence for the unconditioned or conditioned problem at hand.</p>
</td></tr>
<tr><td><code>y.x0</code></td>
<td>
<p>NULL for a conditioned f.p.t. problem or a matrix with the values, by columns, of the approximate f.p.t. 
densities conditioned to each considered value <code class="reqn">x_0</code> selected from the initial distribution for an unconditioned f.p.t. problem.</p>
</td></tr> </table>
<p><br />
</p>
<p>It also includes six additional attributes:
</p>

<table>
<tr>
 <td style="text-align: right;">
<code>Call</code> </td><td style="text-align: left;"> the unevaluated function call, substituting each object of length 1 (referred </td>
</tr>
<tr>
 <td style="text-align: right;"> 
 </td><td style="text-align: left;"> by name in call) by its value. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>Steps</code> </td><td style="text-align: left;"> matrix of subintervals and integration steps to consider for computing the </td>
</tr>
<tr>
 <td style="text-align: right;"> 
 </td><td style="text-align: left;"> approximate f.p.t. density. </td>
</tr>
<tr>
 <td style="text-align: right;"> 
<code>cumIntegral</code> </td><td style="text-align: left;"> vector of the values of the cumulative integral of the approximation for </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> each subinterval considered. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>skips</code> </td><td style="text-align: left;"> a list that contains, for each subinterval, the indexes of the initial values </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> for which the calculation of the approximate conditioned f.p.t. densities </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> has been avoided. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>CPUTime</code> </td><td style="text-align: left;"> matrix of user and system times, by columns, required to approximate </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> the density for each subinterval considered, by rows. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>summary.fptl</code> </td><td style="text-align: left;"> the object of class &ldquo;summary.fptl&rdquo; that results in the internal calls to the </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code>summary.fptl</code> function which is used as <code>sfptl</code> argument in the internal </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> call to the <code>Integration.Steps</code> function. </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>

<p><code>x</code> is the vector result of the concatenation of the sequences of equally spaced values in the suitable subintervals 
determined by the <code><a href="#topic+Integration.Steps">Integration.Steps</a></code> function.                                                                                          
</p>


<h3>Author(s)</h3>

<p>Patricia Román-Román, Juan J. Serrano-Pérez and Francisco Torres-Ruiz.</p>


<h3>References</h3>

<p>Buonocore, A., Nobile, A.G. and Ricciardi, L.M. (1987) A new integral equation for the evaluation of
first-passage-time probability densities. <em>Adv. Appl. Probab.</em>, <b>19</b>, 784&ndash;800.
</p>
<p>Román, P., Serrano, J. J., Torres, F. (2008) First-passage-time location function: Application to determine first-passage-time densities in diffusion processes. <em>Comput. Stat. Data Anal.</em>, <b>52</b>, 4132&ndash;4146.
</p>
<p>P. Román-Román, J.J. Serrano-Pérez, F. Torres-Ruiz. (2012) An R package for an efficient approximation of first-passage-time densities for diffusion processes based on the FPTL function. <em>Applied Mathematics and Computation</em>, <b>218</b>, 8408&ndash;8428.
</p>
<p>P. Román-Román, J.J. Serrano-Pérez, F. Torres-Ruiz. (2014) More general problems on first-passage times for diffusion processes: A new version of the fptdApprox R package. <em>Applied Mathematics and Computation</em>, <b>244</b>, 432&ndash;446.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diffproc">diffproc</a></code> about creation of class &ldquo;diffproc&rdquo; objects.
</p>
<p><code><a href="#topic+is.fpt.density">is.fpt.density</a></code> to test for objects of class &ldquo;fpt.density&rdquo;.
</p>
<p><code><a href="#topic+print.fpt.density">print.fpt.density</a></code> to show objects of class &ldquo;fpt.density&rdquo;. 
</p>
<p><code><a href="#topic+report.fpt.density">report.fpt.density</a></code> to generate a report.
</p>
<p><code><a href="#topic+plot.fpt.density">plot.fpt.density</a></code> for graphical display.
</p>
<p><code><a href="#topic+FPTL">FPTL</a></code> to evaluate the FPTL function and create objects of class &ldquo;fptl&rdquo;.
</p>
<p><code><a href="#topic+summary.fptl">summary.fptl</a></code> to locate the f.p.t. variable and create objects of class &ldquo;summary.fptl&rdquo;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Continuing the diffproc(.) example:

## Making an efficient approximation of the f.p.t. density
## in the case of a conditioned f.p.t. problem. (optimal 
## variable integration steps and small computational cost)
yyy.cp &lt;- Approx.fpt.density(dp = Lognormal, t0 = 0, T = 18, id = 1, S = 
                        "4.5 + 4*t^2 + 7*t*sqrt(t)*sin(6*sqrt(t))", 
                        env = list(m = 0.48, sigma = 0.07))
yyy.cp

## Not run: 
## Making a less efficient approximation of the f.p.t. density 
## (optimal fixed integration step but high computational cost related to 
##  the efficient approximation)
yyy1.cp &lt;- Approx.fpt.density(dp = Lognormal, t0 = 0, T = 18, id = 1, S = 
                        "4.5 + 4*t^2 + 7*t*sqrt(t)*sin(6*sqrt(t))", 
                        env = list(m = 0.48, sigma = 0.07), 
                        variableStep = FALSE, from.t0 = TRUE, to.T = 
                        TRUE, skip = FALSE)
yyy1.cp

## Making an efficient approximation of the f.p.t. density 
## in the case of an unconditioned f.p.t. problem.
yyy.ucp &lt;- Approx.fpt.density(dp = Lognormal, t0 = 0, T = 18, id = 
                list("dlnorm(x,-0.005,0.1)", "Lambda(-0.005,0.1)", 
                "\\Lambda(-0.005,0.1)", "Lognormal(-0.005,0.1)"),
                S = "4.5 + 4*t^2 + 7*t*sqrt(t)*sin(6*sqrt(t))", 
                env = list(m = 0.48, sigma = 0.07), m=25)                 
yyy.ucp
## End(Not run)
</code></pre>

<hr>
<h2 id='diffproc'>Diffusion Processes</h2><span id='topic+diffproc'></span><span id='topic+is.diffproc'></span><span id='topic+as.diffproc'></span><span id='topic+print.diffproc'></span>

<h3>Description</h3>

<p><code>diffproc</code> creates an object of class &ldquo;diffproc&rdquo; from the given set of values.
</p>
<p><code>as.diffproc</code> attempts to turn its argument into an object of class &ldquo;diffproc&rdquo;. 
</p>
<p><code>is.diffproc</code> tests if its argument is an object of class &ldquo;diffproc&rdquo;.
</p>
<p><code>print</code> shows an object of class &ldquo;diffproc&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffproc(text)
as.diffproc(text)
is.diffproc(obj)

## S3 method for class 'diffproc'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diffproc_+3A_text">text</code></td>
<td>
<p>a character vector or list of length four to be coerced, containing the infinitesimal mean, infinitesimal variance, 
transition probability density function and transition probability distribution function of a diffusion process.</p>
</td></tr>
<tr><td><code id="diffproc_+3A_obj">obj</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object to be tested.</p>
</td></tr>
<tr><td><code id="diffproc_+3A_x">x</code></td>
<td>
<p>an object of class &ldquo;diffproc&rdquo;.</p>
</td></tr>
<tr><td><code id="diffproc_+3A_...">...</code></td>
<td>
<p>additional arguments potentially passed (currently none is considered).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main goal of the <code>diffproc</code> function is to validate the mathematical expressions in the given character string vector or list.
If no errors happen, the function converts the input into an object of class &ldquo;diffproc&rdquo;. Otherwise, the function reports the errors.
</p>
<p>The mathematical expressions of the infinitesimal mean and variance should be expressions in <code class="reqn">x</code> and <code class="reqn">t</code>, <code class="reqn">A_1(x,t)</code> 
and <code class="reqn">A_2(x,t)</code>, respectively.
</p>
<p>The mathematical expressions of the transition probability density and distribution functions should be expressions in <code class="reqn">x</code>, <code class="reqn">t</code>, <code class="reqn">y</code> 
and <code class="reqn">s</code>, <code class="reqn">f(x,t|y,s)</code> and <code class="reqn">F(x,t|y,s)</code>, respectively.
</p>
<p>In addition, all mathematical expressions may depend on generic parameters and functions of <code class="reqn">t</code>, or <code class="reqn">s</code> and <code class="reqn">t</code>,
referred by name. To name the expression of a function <code class="reqn">h(u)</code> we can use <code>`h(u)` = value</code> if we want to show its dependence on <code class="reqn">u</code>, or <code>h</code> otherwise. <br />
</p>
<p>The function checks if the mathematical expressions show syntax errors and if <span class="rlang"><b>R</b></span> can compute the symbolic derivative with respect 
to <code class="reqn">x</code> for the infinitesimal variance and transition probability density function. 
</p>


<h3>Value</h3>

<p>If possible, this function returns an object of class &ldquo;diffproc&rdquo; that defines a family of diffusion processes.
It is a four-component list:
</p>
<table>
<tr><td><code>mean</code></td>
<td>
<p>character of length 1 with the mathematical expression of the infinitesimal mean of the process.</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>character of length 1 with the mathematical expression of the infinitesimal variance of the process.</p>
</td></tr>
<tr><td><code>tpdf</code></td>
<td>
<p>character of length 1 with the mathematical expression of the transition probability density function of the process.</p>
</td></tr>
<tr><td><code>tpdF</code></td>
<td>
<p>character of length 1 with the mathematical expression of the transition probability distribution function of the process.</p>
</td></tr> 
</table>
<p><code>is.diffproc</code> returns <code>TRUE</code> or <code>FALSE</code> depending on whether its argument is an object of class &ldquo;diffproc&rdquo; or not.
</p>


<h3>Note</h3>

<p>The transition probability density functions specified by the <code>dnorm</code> function should be expressed in terms of the standard 
normal distribution, since only its derivative is considered in <span class="rlang"><b>R</b></span>. 
</p>


<h3>Author(s)</h3>

<p>Patricia Román-Román, Juan J. Serrano-Pérez and Francisco Torres-Ruiz.</p>


<h3>References</h3>

<p>P. Román-Román, J.J. Serrano-Pérez, F. Torres-Ruiz. (2012) An R package for an efficient approximation of first-passage-time densities for diffusion processes based on the FPTL function. <em>Applied Mathematics and Computation</em>, <b>218</b>, 8408&ndash;8428.
</p>
<p>P. Román-Román, J.J. Serrano-Pérez, F. Torres-Ruiz. (2014) More general problems on first-passage times for diffusion processes: A new version of the fptdApprox R package. <em>Applied Mathematics and Computation</em>, <b>244</b>, 432&ndash;446.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+D">D</a></code> to know more about the simple functions and expressions that support symbolic derivative in <span class="rlang"><b>R</b></span>, and in 
particular about the functions provided in <span class="rlang"><b>R</b></span> to evaluate probability density functions. 
</p>
<p><code><a href="#topic+FPTL">FPTL</a></code> to locate the first-passage-time of a diffusion process through a continuous boundary.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Creating a diffproc object for the lognormal diffusion process
x &lt;- c("m*x", "sigma^2*x^2",
       "dnorm((log(x)-(log(y)+(m-sigma^2/2)*(t-s)))/(sigma*sqrt(t-s)),0,1)/
       (sigma*sqrt(t-s)*x)", "plnorm(x,log(y)+(m-sigma^2/2)*(t-s),
       sigma*sqrt(t-s))") 

Lognormal &lt;- diffproc(x)
Lognormal

## Creating a diffproc object for the Ornstein Uhlenbeck diffusion process
x &lt;- c("alpha*x + beta", "sigma^2", "dnorm((x-(y*exp(alpha*(t-s))-beta*
       (1-exp(alpha*(t-s)))/alpha))/(sigma*sqrt((exp(2*alpha*(t-s)) - 1)/
       (2*alpha))),0,1)/(sigma*sqrt((exp(2*alpha*(t-s)) - 1)/(2*alpha)))",
       "pnorm(x, y*exp(alpha*(t-s)) - beta*(1 - exp(alpha*(t-s)))/alpha,
       sigma*sqrt((exp(2*alpha*(t-s)) - 1)/(2*alpha)))")
			 
OU &lt;- diffproc(x)
OU

## Creating a diffproc object for the lognormal diffusion process with exogenous factors
x &lt;- c("`h(t)`*x", "sigma^2*x^2", "dnorm((log(x)-(log(y)+`H(s,t)`-(sigma^2/2)*
       (t - s)))/(sigma*sqrt(t-s)),0,1)/(sigma*sqrt(t-s)*x)", "plnorm(x,log(y)+
       `H(s,t)`-(sigma^2/2)*(t-s),sigma*sqrt(t-s))")
    
LognormalFEx &lt;- diffproc(x)
LognormalFEx

## Testing diffproc objects
is.diffproc(Lognormal)
is.diffproc(OU)
is.diffproc(LognormalFEx)
</code></pre>

<hr>
<h2 id='fptdApprox-package'>
Approximation of First-Passage-Time Densities for Diffusion Processes
</h2><span id='topic+fptdApprox-package'></span><span id='topic+fptdApprox'></span>

<h3>Description</h3>

<p>Efficient approximation of first-passage-time (f.p.t.) densities for diffusion processes based on the First-Passage-Time Location (FPTL) function.
</p>
<p>For a complete list of functions, use library(help=&ldquo;fptdApprox&rdquo;).
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> fptdApprox</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.4</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2022-08-21</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2 </td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The <span class="pkg">fptdApprox</span> package allows to approximate efficiently the f.p.t. density for a diffusion process
through a continuous time-dependent boundary in the cases of conditioned and unconditioned f.p.t. problems.
</p>
<p>For an unconditioned f.p.t. problem, a step by step study can be performed.
First, the diffusion process under consideration must be defined by using the function 
<code><a href="#topic+diffproc">diffproc</a></code>. Then, the <code><a href="#topic+FPTL">FPTL</a></code> function will be used to calculate the FPTL function for the specified 
process and boundary. The information provided by the function is then extracted by the method <code><a href="#topic+summary.fptl">summary.fptl</a></code> and used to find the range of 
variation of the f.p.t. variable. Finally, such information is used by the function <code><a href="#topic+Approx.cfpt.density">Approx.cfpt.density</a></code>
to obtain the approximation of the f.p.t. density.
</p>
<p>In the general case (conditioned and unconditioned f.p.t. problems) the function <code><a href="#topic+Approx.fpt.density">Approx.fpt.density</a></code>
allows to obtain directly the approximate f.p.t. density.
</p>


<h3>Author(s)</h3>

<p>Patricia Román-Román, Juan J. Serrano-Pérez and Francisco Torres-Ruiz.
</p>
<p>Maintainer: Juan J. Serrano-Pérez, <a href="mailto:jjserra@ugr.es">jjserra@ugr.es</a>
</p>


<h3>References</h3>

<p>Buonocore, A., Nobile, A.G. and Ricciardi, L.M. (1987) A new integral equation for the evaluation of
first-passage-time probability densities. <em>Adv. Appl. Probab.</em>, <b>19</b>, 784&ndash;800.
</p>
<p>Román, P., Serrano, J. J., Torres, F. (2008) First-passage-time location function: Application to determine
first-passage-time densities in diffusion processes. <em>Comput. Stat. Data Anal.</em>, <b>52</b>, 4132&ndash;4146.
</p>
<p>P. Román-Román, J.J. Serrano-Pérez, F. Torres-Ruiz. (2012) An R package for an efficient approximation of first-passage-time densities for diffusion processes based on the FPTL function. <em>Applied Mathematics and Computation</em>, <b>218</b>, 8408&ndash;8428.
</p>
<p>P. Román-Román, J.J. Serrano-Pérez, F. Torres-Ruiz. (2014) More general problems on first-passage times for diffusion processes: A new version of the fptdApprox R package. <em>Applied Mathematics and Computation</em>, <b>244</b>, 432&ndash;446.
</p>

<hr>
<h2 id='FPTL'>First-Passage-Time Location Function</h2><span id='topic+FPTL'></span><span id='topic+is.fptl'></span><span id='topic+print.fptl'></span>

<h3>Description</h3>

<p><code>FPTL</code> computes values of the First-Passage-Time Location (FPTL) function of a diffusion process for a continuous boundary.
</p>
<p><code>is.fptl</code> tests if its argument is an object of class &ldquo;fptl&rdquo;.
</p>
<p><code>print.fptl</code> shows an object of class &ldquo;fptl&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FPTL(dp, t0, T, x0, S, env = NULL, n = 4000)

is.fptl(obj)

## S3 method for class 'fptl'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FPTL_+3A_dp">dp</code></td>
<td>
<p>an object of class &ldquo;diffproc&rdquo; defining a family of diffusion processes.</p>
</td></tr>
<tr><td><code id="FPTL_+3A_obj">obj</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object to be tested.</p>
</td></tr>
<tr><td><code id="FPTL_+3A_x">x</code></td>
<td>
<p>an object of class &ldquo;fptl&rdquo;, a result of a call to this function.</p>
</td></tr>
<tr><td><code id="FPTL_+3A_t0">t0</code>, <code id="FPTL_+3A_t">T</code></td>
<td>
<p>lower and upper limits of the considered time interval. Must be finite.</p>
</td></tr>
<tr><td><code id="FPTL_+3A_x0">x0</code></td>
<td>
<p>fixed initial value of process in the time instant specified in the <code>t0</code> argument.</p>
</td></tr>
<tr><td><code id="FPTL_+3A_s">S</code></td>
<td>
<p>numerical value of a constant boundary or character string with the mathematical expression of a time-dependent boundary.</p>
</td></tr>
<tr><td><code id="FPTL_+3A_env">env</code></td>
<td>
<p>a named list of objects of numeric or character type specifying the values of names which occur in
the mathematical expressions in objects <code>dp</code> and <code>S</code>, or of names which occur in the specification of the previous values.
Defaults to NULL, interpreted as an empty list.</p>
</td></tr> 
<tr><td><code id="FPTL_+3A_n">n</code></td>
<td>
<p>number of points at which the FPTL function is evaluated.</p>
</td></tr>
<tr><td><code id="FPTL_+3A_...">...</code></td>
<td>
<p>additional arguments potentially passed (currently none is considered).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The FPTL function for the problem of the first-passage-time of a diffusion process <code class="reqn">\{X(t), t_0 \leq t \leq T \}</code>,  
conditioned to <code class="reqn">X(t_0) = x_0</code>, through a continuous boundary <code class="reqn">S(t)</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">FPTL(t) = \left\{
\begin{array}{lll}
P[ X(t)&gt;S(t) \, | \, X(t_0)=x_0] = 1 - F(S(t),t \, | \, x_0,t_0) &amp; &amp; if \ x_0 &lt; S(t_0) \\[7pt]
P[ X(t)&lt;S(t) \, | \, X(t_0)=x_0] = F(S(t),t \, | \, x_0,t_0) &amp; &amp; if \ x_0 &gt; S(t_0)
\end{array}
 \right. ,</code>
</p>

<p>where <code class="reqn">F(x,t|y,s)</code> is the transition probability distribution function of the process.  <br />
</p>
<p>Initially, the FPTL function is evaluated at a sequence of n equally spaced values from <code>t0</code> to <code>T</code>. 
Then the <code>FPTL</code> function makes an internal call to the <code><a href="#topic+growth.intervals">growth.intervals</a></code> function in order to study the growth
of the evaluation vector. Finally, the FPTL function is evaluated at a more adequate sequence of values from <code>t0</code> to <code>T</code> according 
to the abovementioned study. <br />
</p>
<p>The mathematical expression of the boundary <code>S</code> should be a function of <code class="reqn">t</code> and may include arguments <code>t0</code>,
<code>x0</code> and the parameters specified in the <code>env</code> argument. The <code>FPTL</code> function checks if the mathematical expression 
shows syntax errors and if <span class="rlang"><b>R</b></span> can compute its symbolic derivative with respect to <code class="reqn">t</code>. <br />
</p>
<p>The <code>env</code> argument is a list of tagged values in <code>name = value</code> form with <code>name</code> other than <code class="reqn">x</code>, <code class="reqn">t</code>, <code class="reqn">y</code> and <code class="reqn">s</code>.
To name the expression of a function <code class="reqn">h(u)</code> as a character string we can use <code>`h(u)` = value</code> if we want to show its dependence on <code class="reqn">u</code>, or <code>h = value</code> otherwise. <br />
</p>
<p>The <code>env</code> argument is copied into a temporary environment for evaluating the mathematical expressions in objects <code>dp</code> and <code>S</code>. 
<span class="rlang"><b>R</b></span> looks for the objects not found into this temporary environment in the parent.frame() environment. 
</p>


<h3>Value</h3>

<p>The function <code>FPTL</code> computes and returns an object of class &ldquo;fptl&rdquo;. It is a two-component list: 
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>a sequence of n values from <code>t0</code> to <code>T</code>.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the corresponding values of the FPTL function for the <code>x</code> sequence.</p>
</td></tr> </table>
<p><br />
It also includes three additional attributes:
</p>

<table>
<tr>
 <td style="text-align: right;">
<code>Call</code> </td><td style="text-align: left;"> the unevaluated function call, substituting each name in this call for its value when </td>
</tr>
<tr>
 <td style="text-align: right;"> 
 </td><td style="text-align: left;"> the latter has length 1. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>dp</code> </td><td style="text-align: left;"> the object used as <code>dp</code> argument in the function call. </td>
</tr>
<tr>
 <td style="text-align: right;"> 
<code>vars</code> </td><td style="text-align: left;"> NULL or a list containing the values of names in the function call for those names </td>
</tr>
<tr>
 <td style="text-align: right;"> 
 </td><td style="text-align: left;"> with values of length greater than 1. </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>

<p><code>is.fptl</code> returns <code>TRUE</code> or <code>FALSE</code> depending on whether its argument is an object of class &ldquo;fptl&rdquo; or not. <br />
</p>
<p>Since n is usually large, the <code>print.fptl</code> function does not display an object of class &ldquo;fptl&rdquo; as a list, but in its &lsquo;basic&rsquo;
structure instead. However, each component can be displayed separately in the usual way.
</p>


<h3>Author(s)</h3>

<p>Patricia Román-Román, Juan J. Serrano-Pérez and Francisco Torres-Ruiz.</p>


<h3>References</h3>

<p>Román, P., Serrano, J. J., Torres, F. (2008) First-passage-time location function: Application to determine first-passage-time densities in diffusion processes. <em>Comput. Stat. Data Anal.</em>, <b>52</b>, 4132&ndash;4146.
</p>
<p>P. Román-Román, J.J. Serrano-Pérez, F. Torres-Ruiz. (2012) An R package for an efficient approximation of first-passage-time densities for diffusion processes based on the FPTL function. <em>Applied Mathematics and Computation</em>, <b>218</b>, 8408&ndash;8428.
</p>
<p>P. Román-Román, J.J. Serrano-Pérez, F. Torres-Ruiz. (2014) More general problems on first-passage times for diffusion processes: A new version of the fptdApprox R package. <em>Applied Mathematics and Computation</em>, <b>244</b>, 432&ndash;446.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diffproc">diffproc</a></code> about creation of class &ldquo;diffproc&rdquo; objects.
</p>
<p><code><a href="#topic+summary.fptl">summary.fptl</a></code> for summaries and <code><a href="#topic+plot.fptl">plot.fptl</a></code> for graphical display.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Continuing the diffproc(.) examples:

## Specifying a boundary
b &lt;- "4.5 + 4*t^2 + 7*t*sqrt(t)*sin(6*sqrt(t))"

## Computing FPTL functions and creating objects of class fptl
y &lt;- FPTL(dp = Lognormal, t0 = 0, T = 18, x0 = 1, S = b, env = list(m = 0.48,
          sigma = 0.07))
y

z &lt;- FPTL(dp = LognormalFEx, t0 = 1, T = 10, x0 = 1, S = 15, env = list(sigma=0.1, 
          `h(t)` = "t/4", `H(s,t)` = "(t^2-s^2)/8"))
z
          
## Testing fptl objects
is.fptl(y)
is.fptl(z)
</code></pre>

<hr>
<h2 id='growth.intervals'>Studying the Growth of a Vector</h2><span id='topic+growth.intervals'></span>

<h3>Description</h3>

<p>For the vector of values resulting from the evaluation of a function, this function determines the positions of the values between which the vector grows. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>growth.intervals(x, y, zeroSlope = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="growth.intervals_+3A_x">x</code></td>
<td>
<p>a vector of values.</p>
</td></tr>
<tr><td><code id="growth.intervals_+3A_y">y</code></td>
<td>
<p>the vector of the corresponding values of a function for the <code>x</code> vector.</p>
</td></tr>
<tr><td><code id="growth.intervals_+3A_zeroslope">zeroSlope</code></td>
<td>
<p>maximum slope (in degrees) required to consider that a growing function is constant.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>growth.intervals</code> function ignores the pairs of values between which the vector <code>y</code> starts and stops growing if the slope is less than <code>zeroSlope</code>. 
</p>


<h3>Value</h3>

<p>This function returns NULL if the vector <code>y</code> is not growing. Otherwise, the
function computes a matrix of indexes with two columns. The first column 
contains the positions of the values from which the vector <code>y</code> starts growing and the	
second column those at which the vector <code>y</code> stops growing.
</p>


<h3>Author(s)</h3>

<p>Patricia Román-Román, Juan J. Serrano-Pérez and Francisco Torres-Ruiz.</p>


<h3>Examples</h3>

<pre><code class='language-R'>u &lt;- seq(0, 5, length = 200)
v &lt;- sin(u)
w &lt;- growth.intervals(u, v)
w

plot(u, v, type = "l", las = 1)
abline(v = u[as.vector(w)])

## Continuing the FPTL(.) examples:

growth.intervals(y$x, y$y)
growth.intervals(y$x, y$y, zeroSlope = 0.001)
</code></pre>

<hr>
<h2 id='Integration.Steps'>Subintervals and Integration Steps To Approximate First-Passage-Time Densities</h2><span id='topic+Integration.Steps'></span>

<h3>Description</h3>

<p>According to the First-Passage-Time Location (FPTL) function and the arguments in the function call, this function  
calculates suitable subintervals and integration steps in order to approximate the first-passage-time (f.p.t.) density. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Integration.Steps(sfptl, variableStep = TRUE, from.t0 = FALSE,
                  to.T = FALSE, n = 250, p = 0.2, alpha = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Integration.Steps_+3A_sfptl">sfptl</code></td>
<td>
<p>an object of class &ldquo;summary.fptl&rdquo;.</p>
</td></tr>
<tr><td><code id="Integration.Steps_+3A_variablestep">variableStep</code></td>
<td>
<p>a logical value indicating whether a variable integration step is used.</p>
</td></tr>
<tr><td><code id="Integration.Steps_+3A_from.t0">from.t0</code></td>
<td>
<p>a logical value indicating whether the approximation should be calculated from the lower end of the
interval considered, <code class="reqn">t_0</code>, specified in the object used as <code>sfptl</code> argument.</p>
</td></tr>
<tr><td><code id="Integration.Steps_+3A_to.t">to.T</code></td>
<td>
<p>a logical value indicating whether the approximation should be calculated to the upper end of the
interval considered, <code class="reqn">T</code>, specified in the object used as <code>sfptl</code> argument.</p>
</td></tr>
<tr><td><code id="Integration.Steps_+3A_n">n</code></td>
<td>
<p>Number of points used to determine the integration step in subintervals <code class="reqn">[t_i^*, t_{max,i}^+]</code>, 
<code class="reqn">i=1, \ldots, m</code>, from interesting instants provided by the FPTL function.</p>
</td></tr>
<tr><td><code id="Integration.Steps_+3A_p">p</code></td>
<td>
<p>Ratio of n used to determine the integration step in subintervals <code class="reqn">[t_{max,i}^+, t_{i+1}^*]</code>, 
<code class="reqn">i=1, \ldots, m</code>, <code class="reqn">[t_0, t_1^*]</code> and <code class="reqn">[t_{max,m}^{+}, T]</code>.</p>
</td></tr>
<tr><td><code id="Integration.Steps_+3A_alpha">alpha</code></td>
<td>
<p>Parameter used to determine the integration step in subintervals 
<code class="reqn">[t_{max,i}^+, t_{i+1}^*]</code>, <code class="reqn">i=1, \ldots, m</code>, <code class="reqn">[t_0, t_1^*]</code> and 
<code class="reqn">[t_{max,m}^{+}, T]</code>, in order to reduce the computational cost of approximating the f.p.t. density function 
in those cases where <code class="reqn">t_{i+1}^* - t_{max,i}^+ &gt;&gt; t_{max,i}^{-} - \, t_i^*</code>, 
for some <code class="reqn">i</code>, <code class="reqn">t_1^* - t_0 &gt;&gt; t_{max,1}^{-} - \thinspace t_1^*</code> or 
<code class="reqn">T - t_{max,m}^+ &gt;&gt; t_{max,m}^{-} - \, t_m^*</code>, respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on the information provided by the FPTL function contained in the <code>sfptl</code> object, this function computes and returns 
suitable subintervals and integration steps in order to approximate the density 
function of the f.p.t. variable according to the other arguments in the function call. <br />
</p>
<p>When the <code>sfptl</code> object is of length greater than 1, it comes from an unconditioned f.p.t. problem. Each component is associated with 
the same f.p.t. problem conditioned on different values of the initial distribution
(equally spaced in the range of the distribution). Let <code class="reqn">x_{0,j}</code>, <code class="reqn">j=1, \ldots, N</code>, these values. For each initial value
<code class="reqn">x_{0,j}</code> let <code class="reqn">t_{i,j}^*</code>, <code class="reqn">t_{max,i,j}^-</code> and <code class="reqn">t_{max,i,j}^+</code>, <code class="reqn">i=1,\ldots \ m_j</code>, 
the interesting time instants provided by the FPTL function and stored in the <code>instants</code> component of the j-th list in the <code>sfptl</code> object.
Then, the time instants <code class="reqn">\{t_{i,j}, i=1, 2, \ldots, 2m_j \}</code>, where 
</p>
<p style="text-align: center;"><code class="reqn">t_{i,j} = \left\{ \begin{array}{ll} t_{(i+1)/2, \, j}^* &amp; for \ i \ odd \\[7pt] t_{max, \, i/2, \thinspace j}^+ &amp; for \ i \ even \end{array} 
\right. ,</code>
</p>

<p>provide a suitable partition of interval <code class="reqn">[t_0, T]</code> to approximate the f.p.t density
for the fixed value <code class="reqn">x_{0,j}</code> of the initial distribution. <br />
</p>
<p>If the <code>sfptl</code> object is of length 1, it comes from a conditioned f.p.t. problem. In this case we denote the interesting time 
instants provided by the FPTL function and stored in the <code>sfptl</code> object by <code class="reqn">t_{i,1}^*</code>, <code class="reqn">t_{max,i,1}^-</code> 
and <code class="reqn">t_{max,i,1}^+</code>. <br />
</p>
<p>In what follows, <code class="reqn">\lceil x \rceil</code> is the integer part of <code class="reqn">x</code>.
</p>
<p>For each list in the <code>sfptl</code> object the function computes
</p>
<p style="text-align: center;"><code class="reqn">h_{i,j} = \displaystyle{\frac{t_{max,i,j}^{+} - \, t_{i,j}^*}{n_{i,j}}} , i=1, \ldots, m_j,</code>
</p>
 
<p>where
</p>
<p style="text-align: center;"><code class="reqn">n_{i,j} = \lceil n \, k_{i,j} \rceil</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">k_{i,j} = \displaystyle{\frac{t_{max,i,j}^+ - t_{i,j}^{*}}{t_{max,i,j}^{-} - \, t_{i,j}^*}} \ .</code>
</p>
 <p><br /> 
</p>
<p>If <code>variableStep = TRUE</code>, for <code class="reqn">0 &lt; p</code> and <code class="reqn">\alpha \leq 1</code>, also computes
</p>

<ul>
<li> <p><code class="reqn">h_{i,j}^* = \displaystyle{\frac{t_{i+1,j}^* - t_{max,i,j}^+}{n_{i,j}^*}} , i=1, \ldots, m_j-1,</code>
where
</p>
<p style="text-align: center;"><code class="reqn">n_{i,j}^* = \left\{ \begin{array}{cc}
          \lceil n \, p \, k_{i,j}^* \rceil &amp; if \ k_{i,j}^* \leq 1 \\[7pt]
          \lceil n \, p \, {k_{i,j}^{*}}^{\alpha} \rceil &amp; if \ k_{i,j}^* &gt; 1
        \end{array}
\right.</code>
</p>

<p>with
</p>
<p style="text-align: center;"><code class="reqn">k_{i,j}^* = \displaystyle{\frac{t_{i+1,j}^* - \, t_{max,i,j}^+}{t_{max,i,j}^{-} - \, t_{i,j}^*}} \ .</code>
</p>

<p>If <code class="reqn">h_{i,j}^* &lt; h_{i,j}</code>, we then set <code class="reqn">t_{max,i,j}^+</code> equal to <code class="reqn">t_{i+1,j}^*</code> and <code class="reqn">h_{i,j}</code> is recalculated.
</p>
</li>
<li> <p><code class="reqn">h_{0,j}^* = \displaystyle{\frac{t_{1,j}^* - t_0}{n_{0,j}^*}} , </code>
where
</p>
<p style="text-align: center;"><code class="reqn">n_{0,j}^* = \left\{ \begin{array}{cc}
          \lceil n \, p \, k_{0,j}^* \rceil &amp;  if \ k_{0,j}^* \leq 1 \\[7pt]
          \lceil n \, p \, {k_{0,j}^{*}}^{\alpha} \rceil &amp; if \ k_{0,j}^* &gt; 1
        \end{array}
 \right.</code>
</p>

<p>with
</p>
<p style="text-align: center;"><code class="reqn">k_{0,j}^* = \displaystyle{\frac{t_{1,j}^* - \, t_0}{t_{max,1,j}^{-} - \, t_{1,j}^*}} \ ,</code>
</p>
 
<p>when the <code>sfptl</code> object is of length 1 and <code>from.t0 = TRUE</code>, or the <code>sfptl</code> object is of length greater than 1.
</p>
<p>If <code class="reqn">h_{0,j}^* &lt; h_{1,j}</code>, we then set <code class="reqn">t_{1,j}^*</code> equal to  <code class="reqn">t_0</code>  and <code class="reqn">h_{1,j}</code> is recalculated.
</p>
</li>
<li> <p><code class="reqn">h_{m_j,j}^* = \displaystyle{\frac{T - \, t_{max,m_j,j}^+}{n_{m_j,j}^*}} , </code>
where
</p>
<p style="text-align: center;"><code class="reqn">n_{m_j,j}^* = \left\{ \begin{array}{cc}
          \lceil n \, p \, k_{m_j,j}^* \rceil &amp; if \ k_{m_j,j}^* \leq 1 \\[7pt]
          \lceil n \, p \, {k_{m_j,j}^{*}}^{\alpha} \rceil &amp; if \ k_{m_j,j}^* &gt; 1
        \end{array}
 \right.</code>
</p>

<p>with
</p>
<p style="text-align: center;"><code class="reqn">k_{m_j,j}^* = \displaystyle{\frac{T - \, t_{max,m_j,j}^+}{t_{max,m_j,j}^{-} - \, t_{m_j,j}^*}} \ ,</code>
</p>
 
<p>when the <code>sfptl</code> object is of length 1 and <code>to.T = TRUE</code>, or the <code>sfptl</code> object is of length greater than 1.
</p>
<p>If <code class="reqn">h_{m_j,j}^* &lt; h_{m_j,j}</code>, we then set <code class="reqn">t_{max,m_j,j}^+</code> equal to <code class="reqn">T</code> and <code class="reqn">h_{m_j,j}</code> is recalculated. <br />
</p>
</li></ul>

<p><code class="reqn">p \geq 0.1</code> and <code class="reqn">0.75 \leq \alpha \leq 1</code> are recommended; otherwise, some integration steps can be excessively large. <br />
</p>
<p>If the <code>sfptl</code> object is of length 1 (conditioned f.p.t. problem), the suitable subintervals and integration steps that the function provides are:
</p>

<ul>
<li><p> If <code>variableStep = TRUE</code>,
</p>

<ul>
<li> <p><code class="reqn">h_{i,1}</code> in subintervals <code class="reqn">[t_{i,1}^*, t_{max,i,1}^+]</code>, <code class="reqn">i=1, \ldots, m_1</code>.
</p>
</li>
<li> <p><code class="reqn">h_{i,1}^*</code> in subintervals <code class="reqn">[t_{max,i,1}^+, t_{i+1,1}^*]</code>, 
<code class="reqn">i=1, \ldots, m_1-1</code>. 
In these subintervals is possible to avoid applying the numerical algorithm to approximate the f.p.t. density provided that the
value of the approximate density at the time instant <code class="reqn">t_{max,i,1}^+</code> is almost 0.
</p>
</li>
<li> <p><code class="reqn">h_{0,1}^*</code> in subinterval <code class="reqn">[t_0, t_{1,1}^*]</code>, if <code>from.t0 = TRUE</code>.
</p>
</li>
<li> <p><code class="reqn">h_{m_1,1}^*</code> in subinterval <code class="reqn">[t_{max,m_1,1}^{+}, T]</code>, if <code>to.T = TRUE</code>. <br />
</p>
</li></ul>

</li>
<li><p> If <code>variableStep = FALSE</code> the function computes 
</p>
<p style="text-align: center;"><code class="reqn">h = min \left\{ h_{i,1} \ , \ i=1, \ldots, m_1 \right\} \thinspace .</code>
</p>

<p>Then
</p>

<ul>
<li><p> If <code>from.t0 = FALSE</code> and <code>to.T = FALSE</code>, <code class="reqn">h</code> is readjusted to exactly split the interval <code class="reqn">[t_{1,1}^*, t_{max,m_1,1}^+]</code>.
</p>
</li>
<li><p> If <code>from.t0 = TRUE</code> and <code>to.T = FALSE</code>, <code class="reqn">h</code> is readjusted to exactly split the interval <code class="reqn">[t_0, t_{max,m_1,1}^+]</code>.
</p>
</li>
<li><p> If <code>from.t0 = FALSE</code> and <code>to.T = TRUE</code>, <code class="reqn">h</code> is readjusted to exactly split the interval <code class="reqn">[t_{1,1}^*, T]</code>.
</p>
</li>
<li><p> If <code>from.t0 = TRUE</code> and <code>to.T = TRUE</code>, <code class="reqn">h</code> is readjusted to exactly split the interval <code class="reqn">[t_0, T]</code>.
</p>
</li></ul>

<p><code class="reqn">h</code> is a suitable fixed integration step in subintervals <code class="reqn">[t_{i,1}^*, t_{max,i,1}^+]</code>, <code class="reqn">i=1, \ldots, m_1</code>, and 
<code class="reqn">[t_{max,i,1}^+,</code> <code class="reqn">t_{i+1,1}^*]</code>, <code class="reqn">i=1, \ldots, m_1-1</code>; 
in subintervals <code class="reqn">[t_0, t_{1,1}^*]</code> if <code>from.t0 = TRUE</code>, and in
<code class="reqn">[t_{max,m_1,1}^{+}, T]</code> if <code>to.T = TRUE</code>. The endpoints of such subintervals 
are readjusted according to this integration step. <br />
</p>
</li></ul>

<p>If the <code>sfptl</code> object is a list of length greater than 1 (unconditioned f.p.t problem), a common partition of 
the interval <code class="reqn">[t_0, T]</code> is calculated from the suitable partitions of this interval for each 
fixed value of the initial distribution. <br />
</p>
<p>Let, in unified form, <code class="reqn">H_{r,j}</code>, <code class="reqn">r=1, \ldots, 2m_j+1</code>, the suitable integration steps
(calculated for each <code class="reqn">j</code> in similar manner to the case of the <code>sfptl</code> object is of length 1) in 
subintervals <code class="reqn">I_{r,j} = [t_{r-1,j}, t_{r,j}]</code>, with <code class="reqn">t_{0,j}=t_0</code> and 
<code class="reqn">t_{2m_j+1,j} = T</code>, <code class="reqn">j=1, \ldots, N</code>. 
Then, the ordered values of all time instants in the suitable partitions,
<code class="reqn">t_{(1)}, \ldots, t_{(M)}</code>, provide a common suitable partition of the interval <code class="reqn">[t_0, T]</code> 
in subintervals <code class="reqn">[t_{(i-1)}, t_{(i)}]</code>, <code class="reqn">i=1, \ldots, M \negthinspace + \negthinspace 1</code>,
where <code class="reqn">t_{(0)} = t_0</code> and <code class="reqn">t_{(M \negthinspace + \negthinspace 1)} = T</code>. <br />
</p>
<p>For this partition, the function computes
</p>
 
<ul>
<li> <p><code class="reqn">H_{i} = min \, \{ H_{r,j} : j=1, \ldots, N, \ and \ [t_{(i-1)}, t_{(i)}] \subseteq I_{r,j} \} , \ i=2, \ldots, M.</code>
</p>
</li>
<li> <p><code class="reqn">H_{1} = min \, \{ H_{r,j} : j=1, \ldots, N, \ and \ [t_0, t_{(1)}] \subseteq I_{r,j} \}</code>, if <code>from.t0 = TRUE</code>.
</p>
</li>
<li> <p><code class="reqn">H_{M \negthinspace + \negthinspace 1} = min \, \{ H_{r,j} : j=1, \ldots, N, \ and \ [t_{(M)}, T] \subseteq I_{r,j} \}</code>, if <code>to.T = TRUE</code>. <br />
</p>
</li></ul>

<p>Thus, 
</p>

<ul>
<li><p> If <code>variableStep = TRUE</code>, the suitable subintervals and integrations steps that the function provides are
</p>

<ul>
<li> <p><code class="reqn">H_i</code> in subintervals <code class="reqn">[t_{(i-1)}, t_{(i)}]</code>, <code class="reqn">i=2, \ldots, M</code>. 
</p>
</li>
<li> <p><code class="reqn">H_1</code> in subinterval <code class="reqn">[t_0, t_{(1)}]</code>, if <code>from.t0 = TRUE</code>.
</p>
</li>
<li> <p><code class="reqn">H_{M \negthinspace + \negthinspace 1}</code> in subinterval <code class="reqn">[t_{(M)}, T]</code>, if <code>to.T = TRUE</code>.
</p>
</li></ul>

<p>Each integration step is readjusted to exactly split the corresponding subinterval. <br />
</p>
</li>
<li><p> If <code>variableStep = FALSE</code>, a suitable fixed integration step for any subinterval <code class="reqn">[t_{(i-1)}, t_{(i)}]</code> is
</p>
<p style="text-align: center;"><code class="reqn">h = min \left\{ H_{i} : i=1, \ldots, M \negthinspace + \negthinspace 1 \right\}.</code>
</p>
 
<p>In this case it is not possible to avoid applying the approximation algorithm in <code class="reqn">[t_{(i-1)}, t_{(i)}] \ \forall \ i=1, \ldots, M \negthinspace + \negthinspace 1 </code>. <br />
</p>
<p>Then
</p>

<ul>
<li><p> If <code>from.t0 = FALSE</code> and <code>to.T = FALSE</code>, <code class="reqn">h</code> is readjusted to exactly split the interval <code class="reqn">[t_{(1)}, t_{(M)}]</code>.
</p>
</li>
<li><p> If <code>from.t0 = TRUE</code> and <code>to.T = FALSE</code>, <code class="reqn">h</code> is readjusted to exactly split the interval <code class="reqn">[t_0, t_{(M)}]</code>.
</p>
</li>
<li><p> If <code>from.t0 = FALSE</code> and <code>to.T = TRUE</code>, <code class="reqn">h</code> is readjusted to exactly split the interval <code class="reqn">[t_{(1)}, T]</code>.
</p>
</li>
<li><p> If <code>from.t0 = TRUE</code> and <code>to.T = TRUE</code>, <code class="reqn">h</code> is readjusted to exactly split the interval <code class="reqn">[t_0, T]</code>.
</p>
</li></ul>

<p><code class="reqn">h</code> is a suitable fixed integration step in subintervals <code class="reqn">[t_{(i-1)}, t_{(i)}]</code>, <code class="reqn">i=2, \ldots, M</code>,  
in subintervals <code class="reqn">[t_0, t_{(1)}]</code> if <code>from.t0 = TRUE</code>, and in
<code class="reqn">[t_{(M)}, T]</code> if <code>to.T = TRUE</code>. The endpoints of such subintervals 
are readjusted according to this integration step. <br />
</p>
</li></ul>



<h3>Value</h3>

<p>A two-component list:
</p>
<table>
<tr><td><code>H</code></td>
<td>
<p>A matrix of subintervals and integrations steps that we must consider in order to approximate the f.p.t. 
density according to the information contained in the <code>sfptl</code> object and the arguments in the function call.</p>
</td></tr>
<tr><td><code>skip</code></td>
<td>
<p>A list of logical vectors indicating, for each subinterval, the values of the initial distribution for which 
we must check whether it is possible to avoid applying the numerical algorithm.
</p>
</td></tr>  
</table>


<h3>Author(s)</h3>

<p>Patricia Román-Román, Juan J. Serrano-Pérez and Francisco Torres-Ruiz.</p>


<h3>References</h3>

<p>Román, P., Serrano, J. J., Torres, F. (2008) First-passage-time location function: Application to determine first-passage-time densities in diffusion processes. <em>Comput. Stat. Data Anal.</em>, <b>52</b>, 4132&ndash;4146.
</p>
<p>P. Román-Román, J.J. Serrano-Pérez, F. Torres-Ruiz. (2012) An R package for an efficient approximation of first-passage-time densities for diffusion processes based on the FPTL function. <em>Applied Mathematics and Computation</em>, <b>218</b>, 8408&ndash;8428.
</p>
<p>P. Román-Román, J.J. Serrano-Pérez, F. Torres-Ruiz. (2014) More general problems on first-passage times for diffusion processes: A new version of the fptdApprox R package. <em>Applied Mathematics and Computation</em>, <b>244</b>, 432&ndash;446.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Approx.fpt.density">Approx.fpt.density</a></code> to approximate f.p.t. densities from objects of class &ldquo;summary.fptl&rdquo; and create objects of class &ldquo;fpt.density&rdquo;.
</p>
<p><code><a href="#topic+summary.fptl">summary.fptl</a></code> to locate the f.p.t. variable and create objects of class &ldquo;summary.fptl&rdquo; from objects of class 
&ldquo;fptl&rdquo;.
</p>
<p><code><a href="#topic+FPTL">FPTL</a></code> to evaluate the FPTL function and create objects of class &ldquo;fptl&rdquo;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Continuing the summary.fptl(.) example:

Integration.Steps(yy)
Integration.Steps(yy, from.t0 = TRUE)
Integration.Steps(yy, to.T = TRUE, n = 100, p = 0.25)

Integration.Steps(zz)
</code></pre>

<hr>
<h2 id='is.fpt.density'>Testing for objects of class &ldquo;fpt.density&rdquo;</h2><span id='topic+is.fpt.density'></span>

<h3>Description</h3>

<p><code>is.fpt.density</code> tests if its argument is an object of class &ldquo;fpt.density&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.fpt.density(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.fpt.density_+3A_obj">obj</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object to be tested.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>is.fpt.density</code> returns <code>TRUE</code> or <code>FALSE</code> depending on whether its argument is an object of class &ldquo;fpt.density&rdquo; or not.
</p>
<p>An object of class &ldquo;fpt.density&rdquo; is a three-component list:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>a sequence of suitable time instants in <code class="reqn">[t_0, \ T]</code> according to the arguments in the function call.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the approximate f.p.t. density function values on the x sequence for the unconditioned or conditioned problem at hand.</p>
</td></tr>
<tr><td><code>y.x0</code></td>
<td>
<p>NULL for a conditioned f.p.t. problem or a matrix with the values, by columns, of the approximate f.p.t. densities conditioned to each considered value
<code class="reqn">x_0</code> of the initial ditribution for an unconditioned f.p.t. problem.</p>
</td></tr> </table>
<p><br />
</p>
<p>It also includes six additional attributes. For more details, see the values of <code><a href="#topic+Approx.cfpt.density">Approx.cfpt.density</a></code> and <code><a href="#topic+Approx.fpt.density">Approx.fpt.density</a></code> functions.
</p>


<h3>Author(s)</h3>

<p>Patricia Román-Román, Juan J. Serrano-Pérez and Francisco Torres-Ruiz.</p>


<h3>References</h3>

<p>P. Román-Román, J.J. Serrano-Pérez, F. Torres-Ruiz. (2012) An R package for an efficient approximation of first-passage-time densities for diffusion processes based on the FPTL function. <em>Applied Mathematics and Computation</em>, <b>218</b>, 8408&ndash;8428.
</p>
<p>P. Román-Román, J.J. Serrano-Pérez, F. Torres-Ruiz. (2014) More general problems on first-passage times for diffusion processes: A new version of the fptdApprox R package. <em>Applied Mathematics and Computation</em>, <b>244</b>, 432&ndash;446.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Testing fpt.density objects

## Continuing the Approx.cfpt.density example:
is.fpt.density(yyy)

## Continuing the Approx.fpt.density example:
is.fpt.density(yyy.cp)
## Not run: 
is.fpt.density(yyy.ucp)
## End(Not run)
</code></pre>

<hr>
<h2 id='plot.fpt.density'>Plotting Method for fpt.density Objects</h2><span id='topic+plot.fpt.density'></span>

<h3>Description</h3>

<p>This function creates a plot of the approximate density function for the conditioned or unconditioned f.p.t. problem at hand. 
Optionally, it displays the information provided by the First-Passage-Time Location (FPTL) function for a conditioned problem.
Moreover, for an unconditioned problem creates an additional plot with all the approximate f.p.t. 
densities conditioned to each value <code class="reqn">x_0</code> selected from the initial ditribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fpt.density'
plot(x, from.t0, to.T, dp.legend = TRUE, dp.legend.cex = 1,  
     ylab = TRUE, growth.points = FALSE, instants = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fpt.density_+3A_x">x</code></td>
<td>
<p>an object of class &ldquo;fpt.density&rdquo;, a result of a call to <code><a href="#topic+Approx.cfpt.density">Approx.cfpt.density</a></code> or <code><a href="#topic+Approx.fpt.density">Approx.fpt.density</a></code> functions.</p>
</td></tr>
<tr><td><code id="plot.fpt.density_+3A_from.t0">from.t0</code></td>
<td>
<p>a logical value indicating whether the approximation should be plotted from the lower end of the
interval considered, <code class="reqn">t_0</code>, specified in the <code>x</code> object.</p>
</td></tr>
<tr><td><code id="plot.fpt.density_+3A_to.t">to.T</code></td>
<td>
<p>a logical value indicating whether the approximation should be plotted to the upper end of the
interval considered, <code class="reqn">T</code>, specified in the <code>x</code> object.</p>
</td></tr>
<tr><td><code id="plot.fpt.density_+3A_dp.legend">dp.legend</code></td>
<td>
<p>logical. If TRUE, adds a legend to the plot for identifying the diffusion process and 
boundary.</p>
</td></tr>
<tr><td><code id="plot.fpt.density_+3A_dp.legend.cex">dp.legend.cex</code></td>
<td>
<p>the magnification to be used for legend relative to the current setting of <code>cex</code>.</p>
</td></tr>
<tr><td><code id="plot.fpt.density_+3A_ylab">ylab</code></td>
<td>
<p>logical. If TRUE, adds a title for the y axis.</p>
</td></tr>
<tr><td><code id="plot.fpt.density_+3A_growth.points">growth.points</code></td>
<td>
<p>logical. If TRUE, for a conditioned f.p.t. problem adds one or more vertical lines and labels to the plot of the approximate 
density function in order to identify the time instants from which the FPTL function starts growing.</p>
</td></tr>
<tr><td><code id="plot.fpt.density_+3A_instants">instants</code></td>
<td>
<p>logical. If TRUE, for a conditioned f.p.t. problem adds vertical lines and labels to the plot of the approximate density function 
in order to identify the other points of interest provided by the FPTL function.</p>
</td></tr>
<tr><td><code id="plot.fpt.density_+3A_...">...</code></td>
<td>
<p>graphical parameters to set before generating the plot, see <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>from.t0</code> or <code>to.T</code> arguments are missing the function considers the corresponding arguments used in the call to <code><a href="#topic+Approx.cfpt.density">Approx.cfpt.density</a></code> or <code><a href="#topic+Approx.fpt.density">Approx.fpt.density</a></code> functions, which in turn generated the <code>x</code> object. 
</p>
<p>If the approximate density functions were calculated from the lower end of the interval considered and <code>from.t0 = FALSE</code>, the approximate density functions should be plotted from the lower endlimit of the first subinterval in the attribute <code>Steps</code> 
of the <code>x</code> object.
</p>
<p>If the approximate density functions were calculated to the upper end of the interval considered and <code>to.T = FALSE</code>, the approximate density functions should be plotted to the upper endlimit of last subinterval in the attribute <code>Steps</code> of the <code>x</code> object.
</p>
<p>If <code>dp.legend = TRUE</code>, a legend is placed in the top inside of each plot frame.
</p>
<p>Additional graphical arguments as <code>cex</code>, <code>lwd</code> and <code>ps</code> can be specified.
</p>


<h3>Author(s)</h3>

<p>Patricia Román-Román, Juan J. Serrano-Pérez and Francisco Torres-Ruiz</p>


<h3>References</h3>

<p>P. Román-Román, J.J. Serrano-Pérez, F. Torres-Ruiz. (2012) An R package for an efficient approximation of first-passage-time densities for diffusion processes based on the FPTL function. <em>Applied Mathematics and Computation</em>, <b>218</b>, 8408&ndash;8428.
</p>
<p>P. Román-Román, J.J. Serrano-Pérez, F. Torres-Ruiz. (2014) More general problems on first-passage times for diffusion processes: A new version of the fptdApprox R package. <em>Applied Mathematics and Computation</em>, <b>244</b>, 432&ndash;446.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FPTL">FPTL</a></code> to know more about the FPTL function and objects of class &ldquo;fptl&rdquo;.
</p>
<p><code><a href="#topic+summary.fptl">summary.fptl</a></code> to extract the information contained in objects of class &ldquo;fptl&rdquo; and create objects of class &ldquo;summary.fptl&rdquo;.
</p>
<p><code><a href="#topic+Approx.cfpt.density">Approx.cfpt.density</a></code> to approximate the f.p.t. density from objects of class &ldquo;summary.fptl&rdquo; and create objects of class &ldquo;fpt.density&rdquo;.
</p>
<p><code><a href="#topic+Approx.fpt.density">Approx.fpt.density</a></code> to approximate the f.p.t. density from objects of class &ldquo;dp&rdquo; and create objects of class &ldquo;fpt.density&rdquo;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Continuing the Approx.cfpt.density(.) example:
plot(yyy)
plot(yyy, from.t0 = TRUE)
plot(yyy, growth.points = TRUE)
plot(yyy, growth.points = TRUE, instants = TRUE)
plot(yyy, dp.legend = FALSE, growth.points = TRUE, instants = TRUE)
plot(yyy, cex = 1.25, cex.main = 1.15)
plot(yyy, cex = 1.25, cex.main = 1.15, dp.legend.cex = 0.8, growth.points = TRUE, instants = TRUE)

## Continuing the Approx.fpt.density example:
plot(yyy.cp)
## Not run: 
plot(yyy.ucp)
## End(Not run)

</code></pre>

<hr>
<h2 id='plot.fptl'>Plotting Method for fptl Objects</h2><span id='topic+plot.fptl'></span>

<h3>Description</h3>

<p>This function creates a plot of the First-Passage-Time Location (FPTL) function for a first-passage-time problem, displaying the information of interest contained in an object of class &ldquo;fptl&rdquo; and a corresponding object of class &ldquo;summary.fptl&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fptl'
plot(x, sfptl, from.t0 = TRUE, to.T = TRUE, dp.legend = TRUE,  
     dp.legend.cex = 1, ylab = TRUE, growth.points = TRUE, 
     instants = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fptl_+3A_x">x</code></td>
<td>
<p>an object of class &ldquo;fptl&rdquo;, a result of a call to <code><a href="#topic+FPTL">FPTL</a></code>.</p>
</td></tr>
<tr><td><code id="plot.fptl_+3A_sfptl">sfptl</code></td>
<td>
<p>an object of class &ldquo;summary.fptl&rdquo;, a result of applying the <code><a href="base.html#topic+summary">summary</a></code> method to the  <code>x</code>
object.</p>
</td></tr>
<tr><td><code id="plot.fptl_+3A_from.t0">from.t0</code></td>
<td>
<p>a logical value indicating whether the FPTL function should be plotted from the lower end of the
interval considered, <code class="reqn">t_0</code>, specified in the <code>x</code> object.</p>
</td></tr>
<tr><td><code id="plot.fptl_+3A_to.t">to.T</code></td>
<td>
<p>a logical value indicating whether the approximation should be plotted to the upper end of the
interval considered, <code class="reqn">T</code>, specified in the <code>x</code> object.</p>
</td></tr>
<tr><td><code id="plot.fptl_+3A_dp.legend">dp.legend</code></td>
<td>
<p>logical. If TRUE, adds a legend to the plot in order to identify the diffusion process 
and boundary used in the call to <code>FPTL</code> function which in turn generated the <code>x</code> object.</p>
</td></tr>
<tr><td><code id="plot.fptl_+3A_dp.legend.cex">dp.legend.cex</code></td>
<td>
<p>the magnification to be used for legend relative to the current setting of <code>cex</code>.</p>
</td></tr>
<tr><td><code id="plot.fptl_+3A_ylab">ylab</code></td>
<td>
<p>logical. If TRUE, adds a title for the y axis.</p>
</td></tr>
<tr><td><code id="plot.fptl_+3A_growth.points">growth.points</code></td>
<td>
<p>logical. If TRUE, adds one or more vertical lines and labels to the plot in order to identify 
the time instants from which the FPTL function starts growing.</p>
</td></tr>
<tr><td><code id="plot.fptl_+3A_instants">instants</code></td>
<td>
<p>logical. If TRUE, draws and identify the other points of interest provided by the FPTL function.</p>
</td></tr>
<tr><td><code id="plot.fptl_+3A_...">...</code></td>
<td>
<p>graphical parameters to set before generating the plot, see <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the <code>sfptl</code> object is missing, the function makes an internal call to the <code>summary.fptl</code> function in order to identify the points of interest provided by the FPTL function.
</p>
<p>If the FPTL function shows at least a local maximum and <code>from.t0 = FALSE</code>, the FPTL function should be plotted from the first time instant from which the function starts growing.
</p>
<p>If the FPTL function shows at least a local maximum and <code>to.T = FALSE</code>, the FPTL function should be plotted to the <code class="reqn">t_{max,m}^{+}</code> value related to the last local maximum <code class="reqn">t_{max,m}</code> if the function does not decrease subsequently, or to the local minimum following the last local maximum <code class="reqn">t_{max,m}</code> if the function decreases subsequently.
</p>
<p>If <code>dp.legend = TRUE</code>, a legend is placed in the top inside of the plot frame.
</p>
<p>Additional graphical arguments as <code>cex</code>, <code>lwd</code> and <code>ps</code> can be specified.
</p>


<h3>Author(s)</h3>

<p>Patricia Román-Román, Juan J. Serrano-Pérez and Francisco Torres-Ruiz.</p>


<h3>References</h3>

<p>P. Román-Román, J.J. Serrano-Pérez, F. Torres-Ruiz. (2012) An R package for an efficient approximation of first-passage-time densities for diffusion processes based on the FPTL function. <em>Applied Mathematics and Computation</em>, <b>218</b>, 8408&ndash;8428.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FPTL">FPTL</a></code> to know more about the FPTL function and objects of class &ldquo;fptl&rdquo;.
</p>
<p><code><a href="#topic+summary.fptl">summary.fptl</a></code> for extract the information of interest in an object of class &ldquo;fptl&rdquo;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Continuing the FPTL(.) example:

plot(y)
plot(y, cex.main = 1.4, growth.points = FALSE)
plot(y, cex.main = 1.4, growth.points = FALSE, instants = FALSE)
plot(y, cex.main = 1.4, dp.legend = FALSE, growth.points = FALSE, instants = FALSE)
plot(y, cex = 1.25, cex.main = 1.25)
plot(y, cex = 1.25, cex.main = 1.25, dp.legend.cex = 0.8)

plot(z)
plot(z, from.t0 = FALSE)
plot(z, to.T = FALSE)
plot(z, from.t0 = FALSE, to.T = FALSE)
</code></pre>

<hr>
<h2 id='print.fpt.density'>Printing First-Passage-Time Densities</h2><span id='topic+print.fpt.density'></span>

<h3>Description</h3>

<p><code>print.fpt.density</code> shows an object of class &ldquo;fpt.density&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fpt.density'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.fpt.density_+3A_x">x</code></td>
<td>
<p>an object of class &ldquo;fpt.density&rdquo;.</p>
</td></tr>
<tr><td><code id="print.fpt.density_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="base.html#topic+print">print</a></code> and <code><a href="base.html#topic+format">format</a></code> methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Since the length of components of an object of class &ldquo;fpt.density&rdquo; is usually large, the <code>print.fpt.density</code> function does not display such object as a list, but in its &lsquo;basic&rsquo; structure instead. However, each component can be displayed separately in the usual way.
</p>


<h3>Author(s)</h3>

<p>Patricia Román-Román, Juan J. Serrano-Pérez and Francisco Torres-Ruiz.</p>


<h3>References</h3>

<p>P. Román-Román, J.J. Serrano-Pérez, F. Torres-Ruiz. (2012) An R package for an efficient approximation of first-passage-time densities for diffusion processes based on the FPTL function. <em>Applied Mathematics and Computation</em>, <b>218</b>, 8408&ndash;8428.
</p>
<p>P. Román-Román, J.J. Serrano-Pérez, F. Torres-Ruiz. (2014) More general problems on first-passage times for diffusion processes: A new version of the fptdApprox R package. <em>Applied Mathematics and Computation</em>, <b>244</b>, 432&ndash;446.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Continuing the Approx.cfpt.density example:
yyy
print(yyy, digits=10)

## Continuing the Approx.fpt.density example:
yyy.cp
## Not run: 
yyy.ucp
## End(Not run)
</code></pre>

<hr>
<h2 id='report'>Writing a Report of an Object</h2><span id='topic+report'></span>

<h3>Description</h3>

<p><code>report</code> is a function used to generate a report of the results of various statistical methods.  
The function invokes particular &lsquo;methods&rsquo; which depend on the &lsquo;class&rsquo; of the first argument.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>report(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="report_+3A_obj">obj</code></td>
<td>
<p>an object for which a report is desired.</p>
</td></tr>
<tr><td><code id="report_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the report generated.</p>
</td></tr>  
</table>


<h3>Details</h3>

  
<p>The functions <code><a href="#topic+report.summary.fptl">report.summary.fptl</a></code> and <code><a href="#topic+report.fpt.density">report.fpt.density</a></code> are examples
of particular methods which report objects of class &ldquo;summary.fptl&rdquo; and &ldquo;fpt.density&rdquo;.
</p>


<h3>Value</h3>

<p>The form of the value returned by <code>report</code> depends on the class of its argument.  
</p>


<h3>Author(s)</h3>

<p>Patricia Román-Román, Juan J. Serrano-Pérez and Francisco Torres-Ruiz.</p>


<h3>See Also</h3>

<p><code><a href="#topic+report.summary.fptl">report.summary.fptl</a></code>
</p>
<p><code><a href="#topic+report.fpt.density">report.fpt.density</a></code> 
</p>

<hr>
<h2 id='report.fpt.density'>Writing a Report of a fpt.density Object</h2><span id='topic+report.fpt.density'></span>

<h3>Description</h3>

<p>A report is generated with the information contained in an object of class &ldquo;fpt.density&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fpt.density'
report(obj, report.sfptl = FALSE, tex = FALSE, digits = 8, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="report.fpt.density_+3A_obj">obj</code></td>
<td>
<p>an object of class &ldquo;fpt.density&rdquo;, a result of a call to <code><a href="#topic+Approx.cfpt.density">Approx.cfpt.density</a></code> or <code><a href="#topic+Approx.fpt.density">Approx.fpt.density</a></code> functions.</p>
</td></tr>
<tr><td><code id="report.fpt.density_+3A_report.sfptl">report.sfptl</code></td>
<td>
<p>logical. If TRUE, also writes a report with the information contained in the object of class &ldquo;summary.fptl&rdquo; 
from which the <code>obj</code> object was created.</p>
</td></tr> 
<tr><td><code id="report.fpt.density_+3A_tex">tex</code></td>
<td>
<p>logical, specifies whether to generate formatted LaTeX output (<code>TRUE</code>) or plain text file (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="report.fpt.density_+3A_digits">digits</code></td>
<td>
<p>integer indicating the significant digits to be used.</p>
</td></tr>
<tr><td><code id="report.fpt.density_+3A_...">...</code></td>
<td>
<p>additional arguments potentially passed (currently none is considered).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The resulting report can be recicled by copy-and-pasting into a document (if <code>tex = FALSE</code>) 
or directly included into a LaTeX file (if <code>tex = TRUE</code>).
</p>


<h3>Value</h3>

<p>Send the report to the command windows.
</p>


<h3>Author(s)</h3>

<p>Patricia Román-Román, Juan J. Serrano-Pérez and Francisco Torres-Ruiz.</p>


<h3>References</h3>

<p>P. Román-Román, J.J. Serrano-Pérez, F. Torres-Ruiz. (2012) An R package for an efficient approximation of first-passage-time densities for diffusion processes based on the FPTL function. <em>Applied Mathematics and Computation</em>, <b>218</b>, 8408&ndash;8428.
</p>
<p>P. Román-Román, J.J. Serrano-Pérez, F. Torres-Ruiz. (2014) More general problems on first-passage times for diffusion processes: A new version of the fptdApprox R package. <em>Applied Mathematics and Computation</em>, <b>244</b>, 432&ndash;446.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Approx.cfpt.density">Approx.cfpt.density</a></code> to approximate the f.p.t. density from objects of class &ldquo;summary.fptl&rdquo; and to create objects of class &ldquo;fpt.density&rdquo;.
</p>
<p><code><a href="#topic+Approx.fpt.density">Approx.fpt.density</a></code> to approximate the f.p.t. density from objects of class &ldquo;dp&rdquo; and to create objects of class &ldquo;fpt.density&rdquo;.
</p>
<p><code><a href="#topic+is.fpt.density">is.fpt.density</a></code> to test whether an object is an object of class &ldquo;fpt.density&rdquo;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Continuing the Approx.cfpt.density(.) example:
report(yyy, digits = 4)
report(yyy, report.sfptl = TRUE, digits = 4)
report(yyy, tex = TRUE, digits = 4)
report(yyy, report.sfptl = TRUE, tex = TRUE, digits = 4)

## Continuing the Approx.fpt.density(.) example:
report(yyy.cp)
## Not run: 
report(yyy.ucp)
## End(Not run)
</code></pre>

<hr>
<h2 id='report.summary.fptl'>Writing a Report of a summary.fptl Object</h2><span id='topic+report.summary.fptl'></span>

<h3>Description</h3>

<p>A report is generated with the information contained in an object of class 
&ldquo;summary.fptl&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.fptl'
report(obj, tex = FALSE, digits = 8, heading = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="report.summary.fptl_+3A_obj">obj</code></td>
<td>
<p>an object of class &ldquo;summary.fptl&rdquo;, a result of a call to <code><a href="#topic+summary.fptl">summary.fptl</a></code> function or the attribute <code>summary.fptl</code>
of the value (of class &ldquo;fpt.density&rdquo;) of the <code><a href="#topic+Approx.fpt.density">Approx.fpt.density</a></code> function (created through one or several successive internal calls to the 
<code>summary.fptl</code> function).</p>
</td></tr>
<tr><td><code id="report.summary.fptl_+3A_tex">tex</code></td>
<td>
<p>logical, specifies whether to generate formatted LaTeX output (<code>TRUE</code>) or plain text file (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="report.summary.fptl_+3A_digits">digits</code></td>
<td>
<p>integer indicating the significant digits to be used.</p>
</td></tr>
<tr><td><code id="report.summary.fptl_+3A_heading">heading</code></td>
<td>
<p>logical, specifies whether to include information about the diffusion process and the boundary (<code>TRUE</code>) 
or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="report.summary.fptl_+3A_...">...</code></td>
<td>
<p>additional arguments potentially passed (currently none is considered).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The resulting report can be recicled by copy-and-pasting into a document (if <code>tex = FALSE</code>) 
or directly included into a LaTeX file (if <code>tex = TRUE</code>).
</p>


<h3>Value</h3>

<p>Send the report to the command windows.
</p>


<h3>Author(s)</h3>

<p>Patricia Román-Román, Juan J. Serrano-Pérez and Francisco Torres-Ruiz.</p>


<h3>References</h3>

<p>P. Román-Román, J.J. Serrano-Pérez, F. Torres-Ruiz. (2012) An R package for an efficient approximation of first-passage-time densities for diffusion processes based on the FPTL function. <em>Applied Mathematics and Computation</em>, <b>218</b>, 8408&ndash;8428.
</p>
<p>P. Román-Román, J.J. Serrano-Pérez, F. Torres-Ruiz. (2014) More general problems on first-passage times for diffusion processes: A new version of the fptdApprox R package. <em>Applied Mathematics and Computation</em>, <b>244</b>, 432&ndash;446.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.fptl">summary.fptl</a></code> to create objects of class &ldquo;summary.fptl&rdquo; from objects of class 
&ldquo;fptl&rdquo;.
</p>
<p><code><a href="#topic+Approx.fpt.density">Approx.fpt.density</a></code> to create objects of class &ldquo;fpt.density&rdquo; with the attribute <code>summary.fptl</code> of class &ldquo;summary.fptl&rdquo;
</p>
<p><code><a href="#topic+is.summary.fptl">is.summary.fptl</a></code> to test whether an object is of class &ldquo;summary.fptl&rdquo;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Continuing the summary.fptl(.) example:

report(yy, digits = 4)
report(yy, tex = TRUE, digits = 4)

report(zz)
report(zz, tex = TRUE)
</code></pre>

<hr>
<h2 id='summary.fptl'>Locating a Conditioned First-Passage-Time Variable</h2><span id='topic+summary.fptl'></span><span id='topic+is.summary.fptl'></span><span id='topic+print.summary.fptl'></span>

<h3>Description</h3>

<p><code>summary.fptl</code> summary method for class &ldquo;fptl&rdquo;.
</p>
<p><code>is.summary.fptl</code> tests if its argument is an object of class &ldquo;summary.fptl&rdquo;.
</p>
<p><code>print.summary.fptl</code> shows an object of class &ldquo;summary.fptl&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fptl'
summary(object, zeroSlope = 0.01, p0.tol = 8, k = 3, ...)

is.summary.fptl(obj)

## S3 method for class 'summary.fptl'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.fptl_+3A_object">object</code></td>
<td>
<p>an object of class &lsquo;fptl&rsquo;, a result of a call to <code><a href="#topic+FPTL">FPTL</a></code>.</p>
</td></tr>
<tr><td><code id="summary.fptl_+3A_obj">obj</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object to be tested.</p>
</td></tr>
<tr><td><code id="summary.fptl_+3A_x">x</code></td>
<td>
<p>an object of class &lsquo;summary.fptl&rsquo;, a result of a call to <code>summary.fptl</code>.</p>
</td></tr>
<tr><td><code id="summary.fptl_+3A_zeroslope">zeroSlope</code></td>
<td>
<p>maximum slope required to consider that a growing function is constant.</p>
</td></tr>
<tr><td><code id="summary.fptl_+3A_p0.tol">p0.tol</code></td>
<td>
<p>controls where the First-Passage-Time Location function begins to increase significantly.</p>
</td></tr>
<tr><td><code id="summary.fptl_+3A_k">k</code></td>
<td>
<p>controls whether the First-Passage-Time Location function decreases very slowly.</p>
</td></tr>
<tr><td><code id="summary.fptl_+3A_...">...</code></td>
<td>
<p>other arguments passed to functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>summary.fptl</code> function extracts the information contained in <code>object</code> about the
location of the variation range of a conditioned first-passage-time (f.p.t.) variable. <br />
</p>
<p>It makes an internal call to <code><a href="#topic+growth.intervals">growth.intervals</a></code> function in order to determine the time instants 
<code class="reqn">t_i, \ i=1, \ldots, m</code>, from which the First-Passage-Time Location (FPTL)
function starts growing, and its local maximums <code class="reqn">t_{max,i}</code>. For this, <code>zeroSlope</code> argument
is considered. <br />
</p>
<p>If there is no growth subinterval, the execution of the function <code>summary.fptl</code> is stopped and an error is reported.
Otherwise, for each of the subintervals <code class="reqn">I_{i} = [t_{i},t_{i+1}]</code> the function determines:
</p>

<ul>
<li><p> The first time instant <code class="reqn">t_i^* \in [t_i, t_{max,i}]</code> at which the function is bigger than
or equal to </p>
<p style="text-align: center;"><code class="reqn">p_i^* = p_i + 10^{-p0.tol}(p_{max,i} - p_i) \ ,</code>
</p>

<p>where <code class="reqn">p_i = FPTL(t_i)</code> and <code class="reqn">p_{max,i} = FPTL(t_{max,i}) \ . </code> <br /> <br />
<code class="reqn">10^{-p0.tol}</code> is the ratio of the global increase of the function in the growth subinterval <code class="reqn">[t_i, t_{max,i}]</code> that
should be reached to consider that it begins to increase significantly.
</p>
</li>
<li><p> The first time instant <code class="reqn">t_{max,i}^{-} \in [t_i, t_{max,i}]</code> at which the FPTL function is
bigger than or equal to </p>
<p style="text-align: center;"><code class="reqn">p_{max,i}^{-} = p_{max,i} \big( 1 - 0.05(p_{max,i} - p_i) \big) \ .</code>
</p>

</li>
<li><p> The last time instant <code class="reqn">t_{max,i}^{+} \in \big[ t_{max,i}, \thinspace T_i \big]</code> at which the FPTL function is bigger
than or equal to </p>
<p style="text-align: center;"><code class="reqn">p_{max,i}^{+} = max \left\{ 1 - (1 - p_{max,i}^2)^{(1+q)/2}, FPTL(T_i) \right\},</code>
</p>

<p>where </p>
<p style="text-align: center;"><code class="reqn">T_i = min \big\{ t_{max,i} + k \thinspace (t_{max,i}-t_i^*)(1 - p_{max,i}),
\thinspace t_{i+1} \big\}</code>
</p>
<p> and
</p>
<p style="text-align: center;"><code class="reqn">q = \displaystyle{\frac{p_{max,i} - p_i}{p_{max,i}}} \ . </code>
</p>

</li></ul>

<p><code>print.summary.fptl</code> displays an object of class &ldquo;summary.fptl&rdquo; for immediate understanding of the information it contains.
</p>


<h3>Value</h3>

<p>The <code>summary.fptl</code> function computes and returns an object of class &ldquo;summary.fptl&rdquo; and length 1. <br />
</p>
<p>An object of class &ldquo;summary.fptl&rdquo; is a list of length 1 for a conditioned f.p.t problem, or of the same length as the number of 
values selected from the non-degenerate initial distribution for an unconditioned f.p.t problem. 
Each component of the list is again a named list with two components: <br />
</p>
<table>
<tr><td><code>instants</code></td>
<td>
<p>a matrix whose columns correspond to <code class="reqn">t_i</code>, <code class="reqn">t_i^*</code>, 
<code class="reqn">t_{max,i}^{-}</code>, <code class="reqn">t_{max,i}</code>and <code class="reqn">t_{max,i}^{+}</code> values for each conditioned f.p.t problem.</p>
</td></tr> </table>
<p><br /> 
</p>
<table>
<tr><td><code>FPTLValues</code></td>
<td>
<p>the matrix of values of the FPTL function on <code>instants</code>.</p>
</td></tr> </table>
<p><br />
</p>
<p>It also includes four additional attributes:
</p>

<table>
<tr>
 <td style="text-align: right;">
<code>Call</code> </td><td style="text-align: left;"> a list of the unevaluated calls to the <code>summary.fptl</code> function, substituting each name </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> in these calls by its value when the latter has length 1. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>FPTLCall</code> </td><td style="text-align: left;"> a list of the unevaluated calls to the <code>FPTL</code> function that resulted in the objects  </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> used as <code>object</code> argument in <code>Call</code>. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>dp</code> </td><td style="text-align: left;"> the common object used as <code>dp</code> argument in the unevaluated calls to the <code>FPTL</code> </td>
</tr>
<tr>
 <td style="text-align: right;"> 
 </td><td style="text-align: left;"> function in <code>FPTLCall</code>. </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>vars</code> </td><td style="text-align: left;"> NULL or a list containing the common values of names in <code>FPTLCall</code> for those names </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> with values of length greater than 1. </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>

<p>For an unconditioned f.p.t problem, the object includes the additional attribute <code>id</code> specifying the non-degenerate initial distribution. <br /> 
</p>
<p>The attribute &ldquo;<code>summary.fptl</code>&rdquo; of the value (of class &ldquo;fpt.density&rdquo;) of the <code>Approx.fpt.density</code> function is 
an object of class <code>summary.fptl</code> of length 1 for a conditioned problem, and of length greather than 1 for an unconditioned problem. 
It is created from one or successive internal calls to the <code>summary.fptl</code> function. <br />
</p>
<p><code>is.summary.fptl</code> returns <code>TRUE</code> or <code>FALSE</code> depending on whether its argument is an object of class
&ldquo;summary.fptl&rdquo; or not. <br />
</p>


<h3>Author(s)</h3>

<p>Patricia Román-Román, Juan J. Serrano-Pérez and Francisco Torres-Ruiz.</p>


<h3>References</h3>

<p>Román, P., Serrano, J. J., Torres, F. (2008) First-passage-time location function: Application to determine first-passage-time densities in diffusion processes. <em>Comput. Stat. Data Anal.</em>, <b>52</b>, 4132&ndash;4146.
</p>
<p>P. Román-Román, J.J. Serrano-Pérez, F. Torres-Ruiz. (2012) An R package for an efficient approximation of first-passage-time densities for diffusion processes based on the FPTL function. <em>Applied Mathematics and Computation</em>, <b>218</b>, 8408&ndash;8428.
</p>
<p>P. Román-Román, J.J. Serrano-Pérez, F. Torres-Ruiz. (2014) More general problems on first-passage times for diffusion processes: A new version of the fptdApprox R package. <em>Applied Mathematics and Computation</em>, <b>244</b>, 432&ndash;446.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Approx.cfpt.density">Approx.cfpt.density</a></code> to approximate densities of f.p.t. variables conditioned to a fixed initial value
from objects of class &ldquo;summary.fptl&rdquo; and create objects of class &ldquo;fpt.density&rdquo;.
</p>
<p><code><a href="#topic+Approx.fpt.density">Approx.fpt.density</a></code> to approximate densities of conditioned or unconditioned f.p.t. variables and create objects of 
class &ldquo;fpt.density&rdquo; from objects of class &ldquo;dp&rdquo;.
</p>
<p><code><a href="#topic+FPTL">FPTL</a></code> to evaluate the FPTL function and create objects of class &ldquo;fptl&rdquo;.
</p>
<p><code><a href="#topic+report.summary.fptl">report.summary.fptl</a></code> to generate a report.
</p>
<p><code><a href="#topic+growth.intervals">growth.intervals</a></code> to study the growth of the vector of values resulting from the evaluation of a function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Continuing the FPTL(.) example:

## Summarizing an object of class fptl
yy &lt;- summary(y)
yy
print(yy, digits=10)
yy1 &lt;- summary(y, zeroSlope = 0.001)
yy1
yy2 &lt;- summary(y, zeroSlope = 0.001, p0.tol = 10)
yy2

zz &lt;- summary(z)
zz

## Testing summary.fptl objects
is.summary.fptl(yy)
is.summary.fptl(zz)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
