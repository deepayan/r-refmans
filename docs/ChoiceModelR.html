<!DOCTYPE html><html lang="en"><head><title>Help for package ChoiceModelR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ChoiceModelR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ChoiceModelR-package'><p>Choice Modeling in R</p></a></li>
<li><a href='#choicemodelr'><p>Choice Modeling in R</p></a></li>
<li><a href='#datar'>
<p>Arificial (Simulated) Choice Data for choicemodelr</p></a></li>
<li><a href='#sharedatar'>
<p>Arificial (Simulated) Fractional Choice Data for choicemodelr</p></a></li>
<li><a href='#truebetas'>
<p>True betas used to simulate data in the choice data set named datar, which is used in the example.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Choice Modeling in R</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bayesm, MASS, lattice, Matrix, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements an MCMC algorithm to estimate a hierarchical multinomial logit model with a normal heterogeneity distribution. The algorithm uses a hybrid Gibbs Sampler with a random walk metropolis step for the MNL coefficients for each unit. Dependent variable may be discrete or continuous. Independent variables may be discrete or continuous with optional order constraints. Means of the distribution of heterogeneity can optionally be modeled as a linear function of unit characteristics variables.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Copyright:</td>
<td>Copyright (C) 2012 Decision Analyst, Inc.; 604 Avenue H
East, Arlington, Texas 76011; www.decisionanalyst.com;
817-640-6166 (ChoiceModelR is a trademark of Decision Analyst,
Inc.)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.decisionanalyst.com/">https://www.decisionanalyst.com/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-10 15:24:31 UTC; jcolias</td>
</tr>
<tr>
<td>Author:</td>
<td>Ryan Sermas [aut],
  John V Colias [ctb, cre],
  Decision Analyst, Inc. [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>John V Colias &lt;jcolias@decisionanalyst.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-10 16:30:16 UTC</td>
</tr>
</table>
<hr>
<h2 id='ChoiceModelR-package'>Choice Modeling in R</h2><span id='topic+ChoiceModelR-package'></span>

<h3>Description</h3>

<p>Estimates coefficients of a Hierarchical Bayes Multinomial Logit Model
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> ChoiceModelR</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.3.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-10-08</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;=3)</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The ChoiceModelR package includes the function choicemodelr that implements an MCMC algorithm to estimate a hierarchical multinomial logit model with a normal heterogeneity distribution.  The algorithm uses a hybrid Gibbs Sampler with a random walk metropolis step for the multinomial logit (MNL) coefficients for each unit.  Means of the distribution of heterogeneity can optionally be modeled as a linear function of unit descriptor variables.
</p>
<p>The dependent variable can be either discrete or a share.  If the dependent variable y_i is a share (0 to 1 inclusive), instead of discrete (1 ,..., nalt; where nalt is the number of alternatives in choice set), then each choice observation is replicated wgt times with alternative i chosen in wgt*y_i observations.  Independent variables can be continuous or discrete, with order constraints imposed on estimated coefficients.
</p>
<p>The basic structure of the code for this algorithm was derived from the rhierMnlRwMixture program of the bayesm package available at cran.r-project.org.  Significant modifications were made to greatly reduce the run time, to allow constraints on estimated parameters, handle varying number of choice observations, handle varying number of choice alternatives within each choice scenario, and to optionally allow the dependent variable to be a share (between 0 and 1) instead of discrete (1 ,..., nalt; where nalt is the number of alternatives in choice set).
</p>
<p>Note: Version 1.3.1 fixes a bug in version 1.3.0:
(1) When restart=TRUE, demos were included and no constraints were included, an error prevented estimation.  This bug was fixed.
</p>


<h3>Author(s)</h3>

<p>Ryan Sermas, assisted by John V. Colias Ph.D., at Decision Analyst, Inc.
<a href="mailto:DecisionAnalystR@decisionanalyst.com">DecisionAnalystR@decisionanalyst.com</a>
</p>
<p>Maintainer: John V. Colias &lt;jcolias@decisionanalyst.com&gt;</p>


<h3>References</h3>

<p>Rossi, Peter; Allenby, Greg M.; and McCulloch, Robert (2005), Bayesian Statistics and Marketing, John Wiley and Sons.
</p>

<hr>
<h2 id='choicemodelr'>Choice Modeling in R</h2><span id='topic+choicemodelr'></span>

<h3>Description</h3>

<p>Estimates coefficients of a Hierarchical Bayes Multinomial Logit Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>choicemodelr(data, xcoding, demos, prior, mcmc, constraints, options, directory)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="choicemodelr_+3A_data">data</code></td>
<td>

<p>Required.  A data frame.  The column variables of the data frame are as follows, where natts is the number of attributes; i.e., independent variables:
</p>
<p>UnitID     Set    Alt    X_1 ... X_natts    y<br />
</p>
<p>The first column contains the ID of the unit (e.g. customer or survey respondent).  The second column contains the choice set number for the unit, where each choice set is an observation for the unit.  The third column contains the alternative number within the choice set.  The last column contains the dependent variable.<br />
</p>
<p>If the dependent variable y is discrete, then the dependent variable takes a non-zero value only in the first row of the choice set data, and takes a value from 1 to the number of alternatives in the choice set.<br />
</p>
<p>For example, the following 4 rows of the data frame &ldquo;data&rdquo; shows 2 choice sets for unitID=103322 , 3 alternatives per choice set (note that the &ldquo;none&rdquo; alternative is excluded in this example), 3 independent variables X1 to X3, and a dependent variable y indicating choice of alternative 2 in the first choice set and alternative 3 in the second choice set.<br />
</p>

<table>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> 103322  1  1  4  6  1  2</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> 103322  1  2  1  1  1  0</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> 103322  2  1  3  6  1  3</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> 103322  2  2  4  8  1  0</td>
</tr>

</table>

<p>The next example is identical to the first example, except that the dependent variable is a share, indicating 30 percent and 40 percent for alternatives 1 and 2 of choice set 1.<br />
</p>
<p>For a share dependent variable, the &ldquo;none&rdquo; alternative must be explicitly included in the data.<br />
</p>

<table>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> 103322  1  1  4  6  1  0.3</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> 103322  1  2  1  1  1  0.4</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> 103322  1  0  0  0  0  0.3</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> 103322  2  1  3  6  1  0.5</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> 103322  2  2  4  8  1  0.5</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> 103322  2  0  0  0  0  0.0</td>
</tr>

</table>

<p>If the dependent variable is a share, then the dependent variable must have a nonzero value in at least one row for each choice set.<br />
</p>
<p>If the dependent variable is a share and there is a &ldquo;none&rdquo; alternative, then set none=FALSE in the options list (see options below). Do not specify none=TRUE for share data.<br />
</p>
<p>If the dependent variable is a share, the values of the dependent variable need not sum to one as choicemodeler automatically renormalizes the values of the dependent variable to one and then multiplies by wgt (see options below).</p>
</td></tr>
<tr><td><code id="choicemodelr_+3A_xcoding">xcoding</code></td>
<td>
<p>Required.  A vector that specifies the way in which each attribute will be coded:
</p>
<p>0 = categorical (effects coded; a value of zero for a categorical attribute is ignored, i.e. is not used in coefficient estimation)<br />
1 = continuous (the program mean centers the variable across the levels appearing in the data)
</p>
<p>The order of attributes in xcoding must match the order of the attributes appearing in the data file.</p>
</td></tr>
<tr><td><code id="choicemodelr_+3A_demos">demos</code></td>
<td>
<p>An &ldquo;ni by nz&rdquo; matrix of demographic variables or unit characteristics, where &ldquo;ni&rdquo; is the number of units and &ldquo;nz&rdquo; is the number of unit-level demographic or descriptor variables.</p>
</td></tr>
<tr><td><code id="choicemodelr_+3A_prior">prior</code></td>
<td>
<p>list(mubar, Amu, df, v, deltabar, Ad)
</p>
<p>mubar = prior mean of the distribution of mu; must be a vector of length equal to the number of attributes (default is a vector of zeros)
</p>
<p>Amu  =  precision parameter (default is 0.01)
</p>
<p>df = prior degrees of freedom (default is 5, must be <code class="reqn">\ge</code> 2)
</p>
<p>v = prior variance (default is 2, must be  <code class="reqn">\ge</code> 0)
</p>
<p>deltabar = prior mean of the distribution of delta; must be a vector of length equal to the number (nz) of unit descriptor variables in the upper level model (default is a vector of zeros with length nz)
</p>
<p>Ad = precision parameter; a scalar that is inserted into a diagonal matrix with row and column dimensions equal to natts * nz (default is 0.01)</p>
</td></tr>
<tr><td><code id="choicemodelr_+3A_mcmc">mcmc</code></td>
<td>
<p>Required.  A list with 3 arguments: list(R, use, s).
</p>
<p>R = total number of iterations of the Markov chain Monte Carlo (MCMC chain) to be performed (R is required).
</p>
<p>use = the number of iterations to be used in parameter estimation (use is required).
</p>
<p>s = a scaling parameter that is used to adjust the standard deviation of random draws of unit-level parameters during the random walk metropolis step of the MCMC chain.  Only specify s if you wish to keep a constant scaling parameter.  (By default, s = 0.1 and is adjusted at each iteration to keep acceptance of random draws of unit parameters at approximately 30 percent.)</p>
</td></tr>
<tr><td><code id="choicemodelr_+3A_constraints">constraints</code></td>
<td>

<p>A list of matrices containing the values 0, 1, and -1.  If specifying constraints, a constraints matrix must be specified for EVERY attribute. Simply declare a matrix of 0s for an unconstrained attribute.
</p>
<p>Each matrix must be square with dimensions equal to the number of levels of the attribute it represents.  For a continuous attribute declare a 1 x 1 matrix containing the appropriate value.  The matrices for categorical variables are interpreted as follows:
</p>

<ul>
<li><p> c1[i, j] = 1,  beta_i &gt; beta_j
</p>
</li>
<li><p> c1[i, j] = -1,  beta_i &lt; beta_j
</p>
</li>
<li><p> c1[i, j] = 0,  no constraint</p>
</li></ul>

<p>The lower-triangular and diagonal portions of the matrix have no meaning and values in these positions are ignored.<br />
</p>
<p>For example, for a model with 3 attributes, set constraints = list(c1, c2, c3).
</p>

<table>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> c1 = matrix(c(0,-1,-1,-1,</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> 0,0,-1,-1,</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> 0,0,0,-1,</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> 0,0,0,0), ncol = 4, byrow = TRUE)</td>
</tr>

</table>


<table>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> c2 = matrix(c(0,1,1,1,1,1,1,1,1,</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> 0,0,1,1,1,1,1,1,1,</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> 0,0,0,1,1,1,1,1,1,</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> 0,0,0,0,1,1,1,1,1,</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> 0,0,0,0,0,1,1,1,1,</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> 0,0,0,0,0,0,1,1,1,</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> 0,0,0,0,0,0,0,1,1,</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> 0,0,0,0,0,0,0,0,1,</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> 0,0,0,0,0,0,0,0,0), ncol = 9, byrow = TRUE)</td>
</tr>

</table>


<table>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> c3 = matrix(c(0,1,1,1,</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> 0,0,1,1,</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> 0,0,0,1,</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> 0,0,0,0), ncol = 4, byrow = TRUE)</td>
</tr>

</table>

<p>The 1 x 1 matrices for continuous variables are interpreted as follows:
</p>

<ul>
<li><p> c4[1, 1] = 1,  beta &gt; 0
</p>
</li>
<li><p> c4[1, 1] = -1,  beta &lt; 0
</p>
</li>
<li><p> c4[1, 1] = 0,  no constraint</p>
</li></ul>
</td></tr>
<tr><td><code id="choicemodelr_+3A_options">options</code></td>
<td>
<p>A list with 5 possible arguments:  list(none, save, keep, wgt, restart).
</p>
<p><b>none</b>:  set to TRUE to estimate a none parameter, and the data does not include a row for &ldquo;none&rdquo; (i.e., no choice)  (default is FALSE). If keep&gt;1, the betas (within the choicemodelr output object) will not include those from every iteration of the Markov chain. If keep&gt;1, then the average of the saved betas, for each unit, will not necessarily equal the unit-level betas output to RBetas.csv, since the latter is an average across ALL betas after &ldquo;burn in&rdquo;, even when keep&gt;1.
</p>
<p><b>save</b>:  set to TRUE to save draws of betas, deltas, mu, rooti, and the log likelihood (default is FALSE).
</p>
<p><b>keep</b> = the thinning parameter defining the number of random draws to save (default is 10).
</p>
<p><b>wgt</b> = the choice-set weight parameter; possible values are 1 to 10.  This parameter only needs to be specified if estimating a model using a share dependent variable (default is 5).
</p>
<p><b>restart</b>:  Set to TRUE if restarting from a previous model estimation.  To use this option, a model estimation must have been completed prior to the current run, and the restart.txt file must be in the directory specified in the directory argument of the choicemodelr function.  All iterations from the previous run are treated as burn-in.  When restarting, keep all arguments (except for R and use) identical to those of the previous run to avoid errors.</p>
</td></tr>
<tr><td><code id="choicemodelr_+3A_directory">directory</code></td>
<td>
<p>The directory where RBetas.csv, RLH.csv, RLog.txt, and restart.txt will be saved.  This is also the directory from which restart.txt will be read if restart = TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Model:<br />
</p>

<table>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> Y_ij </td><td style="text-align: left;"> ~ MNL(beta_i*X_ij) for all  i units and choice sets j</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td><td style="text-align: left;"> (X_ij is nvar by 1, where nvar is the number of independent variables)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> beta_i </td><td style="text-align: left;"> = Z_i'delta + u_i</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td><td style="text-align: left;"> (beta_i is 1 by nvar)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> Z_i </td><td style="text-align: left;"> = a column vector (nz by 1) of unit characteristics variables</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> delta </td><td style="text-align: left;"> = a matrix (nz by nvar) of parameters where each column corresponds</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td><td style="text-align: left;"> to a column of beta_i</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> u_i </td><td style="text-align: left;"> ~ N(mu,Sigma), a multivariate normal distribution</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> mu </td><td style="text-align: left;"> = a vector of means of the distribution of heterogeneity of length nvar</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> Sigma </td><td style="text-align: left;"> = Covariance matrix of the distribution of heterogeneity</td>
</tr>

</table>

<p>Priors:<br />
</p>

<table>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> delta </td><td style="text-align: left;"> ~ N(deltabar, inverse(A_d))</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> mu </td><td style="text-align: left;"> ~ N(mubar, inverse(SigmaAmu)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> Sigma_j </td><td style="text-align: left;"> ~ IW(nu,V)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> deltabar </td><td style="text-align: left;"> = nz by nvar vector of prior means = 0</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> Ad </td><td style="text-align: left;"> = prior precision matrix for deltabar = .01I</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> mubar </td><td style="text-align: left;"> = nvar by 1 prior mean vector for mu = vector of zeros</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> V </td><td style="text-align: left;"> = location parameter for IW prior for Sigma (choicemodelr calculates V = V0 * nu * v)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> nu </td><td style="text-align: left;"> = the degrees of freedom parameter for IW prior for Sigma (nu = df + npar, where npar = number of coefficients to estimate)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> V0 </td><td style="text-align: left;"> = an npar by npar block diagonal matrix, such that each block is:</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td><td style="text-align: left;"> Of dimension 1 for continuous attributes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td><td style="text-align: left;"> Of dimension (nlev-1) by (nlev-1) for categorical attributes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td><td style="text-align: left;"> where</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td><td style="text-align: left;"> nlev = number of levels of the categorical attribute</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td><td style="text-align: left;"> diagonal elements of each block = (nlev-1)/nlev</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td><td style="text-align: left;"> off-diagonal elements of each block = -1/nlev</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> Amu </td><td style="text-align: left;"> = prior precision for normal mean = .01</td>
</tr>

</table>



<h3>Value</h3>

<table role = "presentation">
<tr><td><code>betadraw</code></td>
<td>
<p>An ni by natt by floor(use/keep) array of MCMC random draws of unit-level multinomial logit model parameter estimates.</p>
</td></tr>
<tr><td><code>betadraw.c</code></td>
<td>
<p>An ni by natt by floor(use/keep) array of constrained MCMC random draws of unit-level multinomial logit model parameter estimates.</p>
</td></tr>
<tr><td><code>deltadraw</code></td>
<td>
<p>A floor(use/keep) by nz*natt array of MCMC random draws of parameter estimates on covariates to the distribution of heterogeneity.</p>
</td></tr>
<tr><td><code>compdraw</code></td>
<td>
<p>A list of floor(use/keep) MCMC random draws of estimates of means and roots for the multivariate normal distribution of heterogeneity.</p>
</td></tr>
<tr><td><code>loglike</code></td>
<td>
<p>A floor(use/keep) vector of likelihoods for the MCMC draws of multinomial logit parameters.</p>
</td></tr>
<tr><td><code>RLH</code></td>
<td>
<p>An ni-length vector of the average of floor((R-use)/keep) RLH's (geometric mean of the likelihood of the choices made across the choice sets of the unit, given the randomly drawn unit-level multinomial logit model parameter estimates)</p>
</td></tr>
<tr><td><code>Written to Console During Model Estimation</code></td>
<td>
<p>During model estimation, the following statistics are written to the screen after each 100 iterations.  The selection of these particular statistics was suggested by Sawtooth Software's technical paper, &ldquo;The CBC/HB System for Hierarchical Bayes Estimation,&rdquo; Version 5.0 Technical Paper (2009).  Following Sawtooth Software's approach for certain statistics, we use a weighted average with a weight of 0.01 for the last 100 iterations and 0.99 for previous iterations.</p>
</td></tr>
<tr><td><code>Acceptance</code></td>
<td>
<p>Percent of MCMC draws accepted in the Metropolis Hastings step.</p>
</td></tr>
<tr><td><code>RLH</code></td>
<td>
<p>nth root of the likelihood, where n is the average number of choice tasks (weighted average).</p>
</td></tr>
<tr><td><code>Percent Certainty</code></td>
<td>
<p>Percent difference between log likelihood and log likelihood of a chance model (weighted average).</p>
</td></tr>
<tr><td><code>Average Variance</code></td>
<td>
<p>Average variance of latest estimates of model coefficients across all units (weighted average).</p>
</td></tr>
<tr><td><code>RMS</code></td>
<td>
<p>Root mean squared of latest estimates of model coefficients across all units (weighted average).</p>
</td></tr>
<tr><td><code>Graphic Output</code></td>
<td>
<p>During model estimation, estimates of mu (mean of model coefficients from the distribution of heterogeneity) are plotted in the graphics window.</p>
</td></tr>
<tr><td><code>Written to Disk</code></td>
<td>
<p>At the end of model estimation, the average of MCMC draws of unit-level model coefficients are written to RBetas.csv, and the average of each unit's RLH (the geometric mean of the likelihood of the choices made across the choice sets of the unit) are written to RLH.csv. The estimated coefficients in RBetas.csv (and the RLH's in RLH.csv) are the average across all iterations of the Markov chain, excluding the first R - use &ldquo;burn in&rdquo; iterations. A log file, documenting run-time output is written to Rlog.txt. Latest MCMC draws are written to restart.txt. When using estimated coefficients of continuous variables in subsequent simulations, remember that choicemodelr mean centers data for continuous attributes before estimating the coefficient. That is, the mean across all of the unique values of the continuous variable is subtracted from the value found in &ldquo;data&rdquo;.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>For further explanation of model and priors, see rhierMnlRwMixture of the bayesm package, authored by Peter Rossi, Ph.D., Anderson School, UCLA.  For further discussion, see Rossi, Allenby and McCulloch (2005).  The model specification is identical to that in bayesm, except that (a) the step length of the random walk metropolis algorithm was simplified to use increments of covariance (s**2)(Sigma), where &ldquo;s&rdquo; is a scaling parameter mentioned above and &ldquo;Sigma&rdquo; is the current draw of the covariance matrix of the distribution of heterogeneity and (b) the distribution of heterogeneity was simplified to a normal vs. a mixture of normals.
</p>


<h3>Author(s)</h3>

<p>Ryan Sermas, assisted by John V. Colias Ph.D., at Decision Analyst, Inc.
<a href="mailto:DecisionAnalystR@decisionanalyst.com">DecisionAnalystR@decisionanalyst.com</a>
</p>


<h3>References</h3>

<p>Rossi, Peter; Allenby, Greg M.; and McCulloch, Robert (2005), <em>Bayesian Statistics and Marketing</em>, John Wiley and Sons.
</p>
<p>Sawtooth Software (2009), &ldquo;The CBC/HB System for Hierarchical Bayes Estimation&rdquo;, Version 5.0 Technical Paper, www.sawtoothsoftware.com.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# EXAMPLE 1: MULTINOMIAL LOGIT

# LOAD ARTIFICIAL (SIMULATED) DATA THAT WAS CREATED
# BY R CODE FOUND IN datar SECTION OF THE HELP FILES.

data(datar)
data(truebetas)

# USE choicemodelr TO ESTIMATE THE PARAMETERS OF THE CHOICE MODEL.
# FOR CONVERGENCE OF MCMC CHAIN, SET R = 4000 AND use = 2000.

xcoding = c(0, 0)
mcmc = list(R = 10, use = 10)

options = list(none=FALSE, save=TRUE, keep=1)

attlevels = c(5, 3)
constype =  c(0, 1)
constraints = vector("list", 2)

for (i in 1:length(attlevels)) {
	constraints[[i]] = diag(0, attlevels[i])
	if (constype[i] == 1) {
		constraints[[i]][upper.tri(constraints[[i]])] = -1
	}
	else if (constype[i] == 2) {
		constraints[[i]][upper.tri(constraints[[i]])] = 1
	}
}

pth = tempdir()
out = choicemodelr(datar, xcoding, mcmc = mcmc, options = options,
                   constraints = constraints, directory= pth)

# CALCULATE MEAN ABSOLUTE ERROR BETWEEN ESTIMATED AND TRUE BETAS.
estbetas = apply(out$betadraw.c,c(1,2),mean)
estbetas = cbind(estbetas[,1:4],0-apply(estbetas[,1:4],1,sum),
                 estbetas[,5:6],0-apply(estbetas[,5:6],1,sum))
colnames(estbetas) = c("A1B1", "A1B2", "A1B3", "A1B4", "A1B5", "A2B1", "A2B2", "A2B3")

MAE = mean(abs(estbetas - truebetas))
print(MAE)

# CALCULATE MEAN ABSOLUTE ERROR BETWEEN PROBABILITY
# DIFFERENCES USING ESTIMATED AND TRUE BETAS.

TrueProb = cbind(exp(truebetas[,1:5]) / apply(exp(truebetas[,1:5]),1,sum),
                 exp(truebetas[,6:8]) / apply(exp(truebetas[,6:8]),1,sum))
EstProb = cbind(exp(estbetas[,1:5]) / apply(exp(estbetas[,1:5]),1,sum),
                exp(estbetas[,6:8]) / apply(exp(estbetas[,6:8]),1,sum))
MAEProb = mean(abs(TrueProb - EstProb))

print(MAEProb)


# EXAMPLE 2: FRACTIONAL MULTINOMIAL LOGIT

# LOAD ARTIFICIAL (SIMULATED) FRACTIONAL MULTINOMIAL LOGIT DATA CREATED
# BY R CODE FOUND IN sharedatar SECTION OF THE HELP FILES.

data(sharedatar)
data(truebetas)

# USE choicemodelr TO ESTIMATE THE PARAMETERS OF THE CHOICE MODEL.
# FOR CONVERGENCE OF MCMC CHAIN, SET R = 2000 AND use = 1000.

xcoding = c(0, 0)
mcmc = list(R = 10, use = 10)

options = list(none=FALSE, save=TRUE, keep=1)

attlevels = c(5, 3)
constype =  c(0, 1)
constraints = vector("list", 2)

for (i in 1:length(attlevels)) {
	constraints[[i]] = diag(0, attlevels[i])
	if (constype[i] == 1) {
		constraints[[i]][upper.tri(constraints[[i]])] = -1
	}
	else if (constype[i] == 2) {
		constraints[[i]][upper.tri(constraints[[i]])] = 1
	}
}

pth = tempdir()
out = choicemodelr(sharedatar, xcoding, mcmc = mcmc, options = options,
                   constraints = constraints, directory=pth)

# CALCULATE MEAN ABSOLUTE ERROR BETWEEN ESTIMATED AND TRUE BETAS.
estbetas = apply(out$betadraw.c,c(1,2),mean)
estbetas = cbind(estbetas[,1:4],0-apply(estbetas[,1:4],1,sum),
                 estbetas[,5:6],0-apply(estbetas[,5:6],1,sum))
colnames(estbetas) = c("A1B1", "A1B2", "A1B3", "A1B4", "A1B5", "A2B1", "A2B2", "A2B3")

MAE = mean(abs(estbetas - truebetas))
print(MAE)

# CALCULATE MEAN ABSOLUTE ERROR BETWEEN PROBABILITY
# DIFFERENCES USING ESTIMATED AND TRUE BETAS.

TrueProb = cbind(exp(truebetas[,1:5]) / apply(exp(truebetas[,1:5]),1,sum),
                 exp(truebetas[,6:8]) / apply(exp(truebetas[,6:8]),1,sum))
EstProb = cbind(exp(estbetas[,1:5]) / apply(exp(estbetas[,1:5]),1,sum),
                exp(estbetas[,6:8]) / apply(exp(estbetas[,6:8]),1,sum))
MAEProb = mean(abs(TrueProb - EstProb))

print(MAEProb)

</code></pre>

<hr>
<h2 id='datar'>
Arificial (Simulated) Choice Data for choicemodelr 
</h2><span id='topic+datar'></span>

<h3>Description</h3>

<p>Artificial (simulated) choice data for 300 units with a discrete dependent variable.  The choice data has a maximum of 50 choice sets per unit (varies from unit to unit). The choice sets have a maximum of 5 alternatives per choice set (varies from choice set to choice set).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(datar)</code></pre>


<h3>Format</h3>

<p>The format is:
num [1:61342, 1:6] 1 1 1 1 1 1 1 1 1 1 ...
- attr(*, &quot;dimnames&quot;)=List of 2
..$ : NULL
..$ : chr [1:6] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ...
</p>


<h3>Source</h3>

<p>Choice data was simulated using the code in the example.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(datar)
head(datar)

# datar DATA SET WAS CREATED USING THE FOLLOWING CODE.

if (0) {

# LOAD LIBRARIES REQUIRED TO CREATE THE SIMULATED DATA.  YOU MAY NEED TO INSTALL THESE PACKAGES.
library(MASS)
library(lattice)
library(Matrix)
library(bayesm)

set.seed(88)

# CREATE FUNCTION TO SIMULATE ARTIFICIAL MULTINOMIAL CHOICE DATA BASED SIMULATED TRUE BETAS.

simmnlv2 = function(p,n,beta) 
{
#
#   p. rossi 2004
#   Modified by John Colias 2011
#
# Purpose: simulate from MNL (including X values)
#
# Arguments:
#   p is number of alternatives
#   n is number of obs
#   beta is true parm value
#
# Output:
#   list of X  (note: we include full set of intercepts and 2 unif(-1,1) X vars)
#   y  (indicator of choice-- 1, ...,p
#   prob is a n x p matrix of choice probs
#
#   note: first choice alternative has intercept set to zero
#
k=length(beta)
x1=runif(n*p,min=-1,max=1)
x2=runif(n*p,min=-1,max=1)
x3=runif(n*p,min=-1,max=1)
I2=diag(rep(1,p-1))
zero=rep(0,p-1)
xadd=rbind(zero,I2)
for(i in 2:n) {
        xadd=rbind(xadd,zero,I2)
}

xlast3 = cbind(x1,x2,x3)
xmax = apply(xlast3,1,max)
xcat = (xlast3 == xmax)*1
X=cbind(xadd,xcat)

# now construct probabilities
Xbeta=X%*%beta
p=nrow(Xbeta)/n
Xbeta=matrix(Xbeta,byrow=TRUE,ncol=p)
Prob=exp(Xbeta)
iota=c(rep(1,p))
denom=Prob%*%iota
Prob=Prob/as.vector(denom)
# draw y
y=vector("double",n)
ind=1:p
for (i in 1:n) 
        {
        yvec=rmultinom(1,1,Prob[i,])
        y[i]=ind%*%yvec
        }

return(list(y=y,X=X,beta=beta,prob=Prob))
}

# DEFINE DIMENSIONS OF ARTIFICIAL DATA.

nunits = 300     # number of units
cmax = 50        # maximum number of cards per unit
amax = 5         # maximum number of alternatives per card

# CREATE SIGMA FOR MULTIVARIATE NORMAL DISTRIBUTION OF HETEROGENEITY.
sigma = 0.2*matrix(runif(49),7,7)
tsigma = t(sigma)
sigma[lower.tri(sigma)] = tsigma[lower.tri(tsigma)]
sigma = nearPD(sigma)$mat

# DEFINE MEANS FOR MULTIVARIATE NORMAL DISTRIBUTION OF HETEROGENEITY.
avgbeta = c(.5,-1.5,.9,1.0,-1, -0.5, 1.5)

# DRAW BETAS FOR EACH UNIT.
# LAST THREE BETAS ARE 3 LEVELS OF ONE ATTRIBUTE
# THAT IS NON-DECREASING IN VALUE.

betatemp = mvrnorm(n=nunits, avgbeta, sigma)
beta = betatemp[,1:5]
beta = cbind(beta,beta[,5]+exp(betatemp[,6]))
beta = cbind(beta,beta[,6]+exp(betatemp[,7]))
tbeta = cbind(beta[,1:4],0) - apply(cbind(beta[,1:4],0),1,mean)
beta[,1:4] = tbeta[,1:4]
tbeta = beta[,5:7] - apply(beta[,5:7],1,mean)
beta[,5:7] = tbeta

# CREATE MULTINOMIAL LOGIT y AND X FOR EACH UNIT ASSUMING beta IS "TRUE".
datah=NULL
for (i in 1:nunits) {
datah[[i]] = simmnlv2(amax,cmax,beta[i,])
}

# SAMPLE cmax-2, cmax-1, or cmax CARDS 
# FOR EACH UNIT TO CREATE DATA WITH VARYING 
# NUMBER OF CHOICE CARDS PER UNIT.
# SAMPLE amax-2, amax-1, or amax ALTERNATIVES
# FOR EACH CHOICE CARD OF EACH UNIT 
# TO CREATE DATA WITH VARYING NUMBER OF 
# ALTERNATIVES PER CHOICE CARD.
ny = NULL
datar = NULL
for (i in 1:nunits) {
      if (i == 1) { 
         cat("Please wait ... this may take a few minutes.", fill = TRUE)
         cat("", fill = TRUE) }

# SAMPLE CHOICE CARDS.
cards = sample(c(1:cmax),sample(c(cmax-2,cmax-1,cmax),1))
cnum = 0
for (c in cards) {
    cnum = cnum + 1
    cond = 0
# KEEP SAMPLING ALTERNATIVES UNTIL THE CHOSEN ALTERNATIVE IS WITHIN THE SAMPLED ALTERNATIVES.
    while (cond==0) {
        alts = sample(c(1:amax),sample(c(amax-2,amax-1,amax),1))
        depvar = datah[[i]]$y[c]
        if (is.element(depvar,alts)) { 
            cond = 1
            depvar = sum((depvar==alts)*c(1:length(alts))) } }
    anum = 0
    for (a in alts) {
        anum = anum + 1
        if (anum &gt; 1) {depvar = 0}
        xx = datah[[i]]$X[(c-1)*amax+a,]
        xa = xx[1:(length(xx)-3)]%*%c(1:(length(xx)-3))
        if (sum(xa)==0) {xa = length(xx) - 2}
        xb = which.max(xx[(length(xx)-2):length(xx)])
        datar = rbind(datar,c(i,cnum,anum,xa,xb,depvar)) } } }

truebetas = cbind(beta[,1:4],0-apply(beta[,1:4],1,sum),beta[,5:7])
colnames(truebetas) = c("A1B1", "A1B2", "A1B3", "A1B4", "A1B5", "A2B1", "A2B2", "A2B3")

# END OF CODE TO CREATE ARTIFICIAL DATA.
}

</code></pre>

<hr>
<h2 id='sharedatar'>
Arificial (Simulated) Fractional Choice Data for choicemodelr 
</h2><span id='topic+sharedatar'></span>

<h3>Description</h3>

<p>Artificial (simulated) fractional choice data for 300 units with a share dependent variable.  The choice data has 50 choice sets per unit. The choice sets have 5 alternatives per choice set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sharedatar)</code></pre>


<h3>Format</h3>

<p>The format is:
num [1:75000, 1:6] 1 1 1 1 1 1 1 1 1 1 ...
- attr(*, &quot;dimnames&quot;)=List of 2
..$ : NULL
..$ : chr [1:6] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ...
</p>


<h3>Source</h3>

<p>Fractional choice data was simulated using the code in the example.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sharedatar)
head(sharedatar)

#  sharedatar WAS CREATED USING THE FOLLOWING CODE.

if (0) {

# LOAD LIBRARIES REQUIRED TO CREATE THE SIMULATED DATA.  
# YOU MAY NEED TO INSTALL THESE PACKAGES.
library(MASS)
library(lattice)
library(Matrix)
library(bayesm)

set.seed(88)

# CREATE FUNCTION TO SIMULATE ARTIFICIAL MULTINOMIAL 
# FRACTIONAL CHOICE DATA BASED SIMULATED TRUE BETAS.

simmnlv3 = function(p,n,l,beta) 
{
#
#   p. rossi 2004
#   Modified by John Colias 2011
#
# Purpose: simulate from Fractional MNL (including X values)
#
# Arguments:
#   p is number of alternatives
#   n is number of obs
#   l is number of draws to construct the share
#   beta is true parm value
#
# Output:
#   list of X  (note: we include full set of intercepts and 2 unif(-1,1) X vars)
#   y  (indicator of choice-- 1, ...,p
#   prob is a n x p matrix of choice probs
#
#   note: first choice alternative has intercept set to zero
#
k=length(beta)
x1=runif(n*p,min=-1,max=1)
x2=runif(n*p,min=-1,max=1)
x3=runif(n*p,min=-1,max=1)
I2=diag(rep(1,p-1))
zero=rep(0,p-1)
xadd=rbind(zero,I2)
for(i in 2:n) {
        xadd=rbind(xadd,zero,I2)
}

xlast3 = cbind(x1,x2,x3)
xmax = apply(xlast3,1,max)
xcat = (xlast3 == xmax)*1
X=cbind(xadd,xcat)

# now construct probabilities
Xbeta=X%*%beta
p=nrow(Xbeta)/n
Xbeta=matrix(Xbeta,byrow=T,ncol=p)
Prob=exp(Xbeta)
iota=c(rep(1,p))
denom=Prob%*%iota
Prob=Prob/as.vector(denom)
# draw y
y=array(double(1),dim=c(n,p,l))
for (i in 1:n) 
        {
        for (l in 1:l) {
        yvec=rmultinom(1,1,Prob[i,])
        y[i,,l] = yvec
        }
        }
return(list(y=apply(y,c(1,2),mean),X=X,beta=beta,prob=Prob))
}

# DEFINE DIMENSIONS OF ARTIFICIAL DATA.

nunits = 300     # number of units
cnum = 50        # number of cards per unit
anum = 5         # number of alternatives per card
lnum = 50        # number of draws to construct the shares for each card

# CREATE SIGMA FOR MULTIVARIATE NORMAL DISTRIBUTION OF HETEROGENEITY.
sigma = 0.2*matrix(runif(49),7,7)
tsigma = t(sigma)
sigma[lower.tri(sigma)] = tsigma[lower.tri(tsigma)]
sigma = nearPD(sigma)$mat

# DEFINE MEANS FOR MULTIVARIATE NORMAL DISTRIBUTION OF HETEROGENEITY.
avgbeta = c(.5,-1.5,.9,1.0,-1, -0.5, 1.5)

# DRAW BETAS FOR EACH UNIT.
# LAST THREE BETAS ARE 3 LEVELS OF ONE ATTRIBUTE
# THAT IS NON-DECREASING IN VALUE.

betatemp = mvrnorm(n=nunits, avgbeta, sigma)
beta = betatemp[,1:5]
beta = cbind(beta,beta[,5]+exp(betatemp[,6]))
beta = cbind(beta,beta[,6]+exp(betatemp[,7]))
tbeta = cbind(beta[,1:4],0) - apply(cbind(beta[,1:4],0),1,mean)
beta[,1:4] = tbeta[,1:4]
tbeta = beta[,5:7] - apply(beta[,5:7],1,mean)
beta[,5:7] = tbeta

# CREATE MULTINOMIAL LOGIT y AND X FOR EACH UNIT ASSUMING beta IS "TRUE".
datah=NULL
for (i in 1:nunits) {
datah[[i]] = simmnlv3(anum,cnum,lnum,beta[i,])
}

sharedatar = NULL
for (i in 1:nunits) {
    if (i == 1) { 
        cat("Please wait ... this may take a few minutes.", fill = TRUE)
        cat("", fill = TRUE) }
    for (c in 1:cnum) {
        depvar = datah[[i]]$y[c,]
            for (a in 1:anum) {
            xx = datah[[i]]$X[(c-1)*anum+a,]
            xa = xx[1:(length(xx)-3)]%*%c(1:(length(xx)-3))
            if (sum(xa)==0) {xa = length(xx) - 2}
            xb = which.max(xx[(length(xx)-2):length(xx)])
            sharedatar = rbind(sharedatar,c(i,c,a,xa,xb,depvar[a])) } } }

# END OF CODE TO CREATE ARTIFICIAL DATA.
}

</code></pre>

<hr>
<h2 id='truebetas'>
True betas used to simulate data in the choice data set named datar, which is used in the example.
</h2><span id='topic+truebetas'></span>

<h3>Description</h3>

<p>True betas are effects-coded betas for two variables for 300 units.  The first variable is a four-level categorical and the second variable is a three-level categorical variable.  The latter is constrained to be non-decreasing.  These betas were used to simulate the choice data in the example data set named datar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(truebetas)</code></pre>


<h3>Format</h3>

<p>The format is:
num [1:300, 1:8] 0.7314 0.0484 0.1874 0.3961 0.5678 ...
- attr(*, &quot;dimnames&quot;)=List of 2
..$ : NULL
..$ : chr [1:8] &quot;A1B1&quot; &quot;A1B2&quot; &quot;A1B3&quot; &quot;A1B4&quot; ...
</p>


<h3>Source</h3>

<p>The true betas were created using the code in the example.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(truebetas)
head(truebetas)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
