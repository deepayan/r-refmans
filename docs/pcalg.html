<!DOCTYPE html><html><head><title>Help for package pcalg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pcalg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#addBgKnowledge'>
<p>Add background knowledge to a CPDAG or PDAG</p></a></li>
<li><a href='#adjustment'>
<p>Compute adjustment sets for covariate adjustment.</p></a></li>
<li><a href='#ages'>
<p>Estimate an APDAG within the Markov equivalence class of a DAG using AGES</p></a></li>
<li><a href='#amatType'><p>Types and Display of Adjacency Matrices in Package 'pcalg'</p></a></li>
<li><a href='#backdoor'><p>Find Set Satisfying the Generalized Backdoor Criterion (GBC)</p></a></li>
<li><a href='#beta.special'><p>Compute set of intervention effects</p></a></li>
<li><a href='#beta.special.pcObj'><p>Compute set of intervention effects in a fast way</p></a></li>
<li><a href='#binCItest'><p>G square Test for (Conditional) Independence of Binary Variables</p></a></li>
<li><a href='#checkTriple'><p>Check Consistency of Conditional Independence for a Triple of Nodes</p></a></li>
<li><a href='#compareGraphs'><p>Compare two graphs in terms of TPR, FPR and TDR</p></a></li>
<li><a href='#condIndFisherZ'><p>Test Conditional Independence of Gaussians via Fisher's Z</p></a></li>
<li><a href='#corGraph'><p>Computing the correlation graph</p></a></li>
<li><a href='#dag2cpdag'><p>Convert a DAG to a CPDAG</p></a></li>
<li><a href='#dag2essgraph'><p>Convert a DAG to an Essential Graph</p></a></li>
<li><a href='#dag2pag'><p>Convert a DAG with latent variables into a PAG</p></a></li>
<li><a href='#disCItest'><p>G square Test for (Conditional) Independence of Discrete Variables</p></a></li>
<li><a href='#dreach'><p>Compute D-SEP(x,y,G)</p></a></li>
<li><a href='#dsep'><p>Test for d-separation in a DAG</p></a></li>
<li><a href='#dsepAM'><p>Test for d-separation in a MAG</p></a></li>
<li><a href='#dsepAMTest'><p>Test for d-separation in a MAG</p></a></li>
<li><a href='#dsepTest'><p>Test for d-separation in a DAG</p></a></li>
<li><a href='#EssGraph-class'><p>Class <code>"EssGraph"</code></p></a></li>
<li><a href='#fci'><p>Estimate a PAG with the FCI Algorithm</p></a></li>
<li><a href='#fciAlgo-class'><p>Class &quot;fciAlgo&quot; of FCI Algorithm Results</p></a></li>
<li><a href='#fciPlus'><p>Estimate a PAG with the FCI+ Algorithm</p></a></li>
<li><a href='#find.unsh.triple'><p>Find all Unshielded Triples in an Undirected Graph</p></a></li>
<li><a href='#gac'><p>Test If Set Satisfies Generalized Adjustment Criterion (GAC)</p></a></li>
<li><a href='#gAlgo-class'><p>Class <code>"gAlgo"</code></p></a></li>
<li><a href='#GaussL0penIntScore-class'><p>Class <code>"GaussL0penIntScore"</code></p></a></li>
<li><a href='#GaussL0penObsScore-class'><p>Class <code>"GaussL0penObsScore"</code></p></a></li>
<li><a href='#GaussParDAG-class'><p>Class <code>"GaussParDAG"</code> of Gaussian Causal Models</p></a></li>
<li><a href='#gds'><p>Greedy DAG Search to Estimate Markov Equivalence Class of DAG</p></a></li>
<li><a href='#ges'><p>Estimate the Markov equivalence class of a DAG using GES</p></a></li>
<li><a href='#getGraph'><p>Get the &quot;graph&quot; Part or Aspect of R Object</p></a></li>
<li><a href='#getNextSet'><p>Iteration through a list of all combinations of choose(n,k)</p></a></li>
<li><a href='#gies'><p>Estimate Interventional Markov Equivalence Class of a DAG by GIES</p></a></li>
<li><a href='#gmB'><p>Graphical Model 5-Dim Binary Example Data</p></a></li>
<li><a href='#gmD'><p>Graphical Model Discrete 5-Dim Example Data</p></a></li>
<li><a href='#gmG'><p>Graphical Model 8-Dimensional Gaussian Example Data</p></a></li>
<li><a href='#gmI'><p>Graphical Model 7-dim IDA Data Examples</p></a></li>
<li><a href='#gmInt'><p>Graphical Model 8-Dimensional Interventional Gaussian Example Data</p></a></li>
<li><a href='#gmL'><p>Latent Variable 4-Dim Graphical Model Data Example</p></a></li>
<li><a href='#ida'><p>Estimate Multiset of Possible Joint Total Causal Effects</p></a></li>
<li><a href='#idaFast'><p>Multiset of Possible Total Causal Effects for Several Target Var.s</p></a></li>
<li><a href='#iplotPC'><p>Plotting a pcAlgo object using the package igraph</p></a></li>
<li><a href='#isValidGraph'>
<p>Check for a DAG, CPDAG or a maximally oriented PDAG</p>
</a></li>
<li><a href='#jointIda'><p>Estimate Multiset of Possible Total Joint Effects</p></a></li>
<li><a href='#legal.path'><p>Check if a 3-node-path is Legal</p></a></li>
<li><a href='#LINGAM'><p>Linear non-Gaussian Acyclic Models (LiNGAM)</p></a></li>
<li><a href='#mat2targets'><p>Conversion between an intervention matrix and a list of intervention</p>
targets</a></li>
<li><a href='#mcor'><p>Compute (Large) Correlation Matrix</p></a></li>
<li><a href='#opt.target'><p>Get an optimal intervention target</p></a></li>
<li><a href='#optAdjSet'><p>Compute the optimal adjustment set</p></a></li>
<li><a href='#pag2anc'><p>Reads off identifiable ancestors and non-ancestors from a directed PAG</p></a></li>
<li><a href='#pag2conf'><p>Reads off identifiable unconfounded node pairs from a directed PAG</p></a></li>
<li><a href='#pag2edge'><p>Reads off identifiable parents and non-parents from a directed PAG</p></a></li>
<li><a href='#pag2mag'><p>Transform a PAG into a MAG in the Corresponding Markov Equivalence Class</p></a></li>
<li><a href='#ParDAG-class'><p>Class <code>"ParDAG"</code> of Parametric Causal Models</p></a></li>
<li><a href='#pc'><p>Estimate the Equivalence Class of a DAG using the PC Algorithm</p></a></li>
<li><a href='#pc.cons.intern'><p>Utility for conservative and majority rule in PC and FCI</p></a></li>
<li><a href='#pcalg-internal'><p>Internal Pcalg Functions</p></a></li>
<li><a href='#pcalg2dagitty'>

<p>Transform the adjacency matrix from <span class="pkg">pcalg</span> into a <span class="pkg">dagitty</span> object</p></a></li>
<li><a href='#pcAlgo'><p>PC-Algorithm [OLD]: Estimate Skeleton or Equivalence Class of a DAG</p></a></li>
<li><a href='#pcAlgo-class'><p>Class &quot;pcAlgo&quot; of PC Algorithm Results, incl. Skeleton</p></a></li>
<li><a href='#pcorOrder'><p>Compute Partial Correlations</p></a></li>
<li><a href='#pcSelect'><p>PC-Select: Estimate subgraph around a response variable</p></a></li>
<li><a href='#pcSelect.presel'><p>Estimate Subgraph around a Response Variable using Preselection</p></a></li>
<li><a href='#pdag2allDags'><p>Enumerate All DAGs in a Markov Equivalence Class</p></a></li>
<li><a href='#pdag2dag'><p>Extend a Partially Directed Acyclic Graph (PDAG) to a DAG</p></a></li>
<li><a href='#pdsep'><p>Estimate Final Skeleton in the FCI algorithm</p></a></li>
<li><a href='#plotAG'><p>Plot partial ancestral graphs (PAG)</p></a></li>
<li><a href='#plotSG'><p>Plot the subgraph around a Specific Node in a Graph Object</p></a></li>
<li><a href='#possAn'>
<p>Find possible ancestors of given node(s).</p></a></li>
<li><a href='#possDe'>
<p>Find possible descendants of given node(s).</p></a></li>
<li><a href='#possibleDe'>
<p>[DEPRECATED] Find possible descendants on definite status paths.</p></a></li>
<li><a href='#qreach'><p>Compute Possible-D-SEP(x,G) of a node x in a PDAG G</p></a></li>
<li><a href='#r.gauss.pardag'><p>Generate a Gaussian Causal Model Randomly</p></a></li>
<li><a href='#randDAG'><p>Random DAG Generation</p></a></li>
<li><a href='#randomDAG'><p>Generate a Directed Acyclic Graph (DAG) randomly</p></a></li>
<li><a href='#rfci'><p>Estimate an RFCI-PAG using the RFCI Algorithm</p></a></li>
<li><a href='#rmvDAG'><p>Generate Multivariate Data according to a DAG</p></a></li>
<li><a href='#rmvnorm.ivent'><p>Simulate from a Gaussian Causal Model</p></a></li>
<li><a href='#Score-class'><p>Virtual Class &quot;Score&quot;</p></a></li>
<li><a href='#searchAM'><p>Search for certain nodes in a DAG/CPDAG/MAG/PAG</p></a></li>
<li><a href='#shd'><p>Compute Structural Hamming Distance (SHD)</p></a></li>
<li><a href='#showAmat'><p>Show Adjacency Matrix of pcAlgo object</p></a></li>
<li><a href='#showEdgeList'><p>Show Edge List of pcAlgo object</p></a></li>
<li><a href='#simy'><p>Estimate Interventional Markov Equivalence Class of a DAG</p></a></li>
<li><a href='#skeleton'><p>Estimate (Initial) Skeleton of a DAG using the PC / PC-Stable Algorithm</p></a></li>
<li><a href='#trueCov'>
<p>Covariance matrix of a DAG.</p></a></li>
<li><a href='#udag2apag'><p>Last step of RFCI algorithm: Transform partially oriented graph into RFCI-PAG</p></a></li>
<li><a href='#udag2pag'><p>Last steps of FCI algorithm: Transform Final Skeleton into FCI-PAG</p></a></li>
<li><a href='#udag2pdag'><p>Last PC Algorithm Step: Extend Object with Skeleton to Completed PDAG</p></a></li>
<li><a href='#visibleEdge'>
<p>Check visible edge.</p></a></li>
<li><a href='#wgtMatrix'><p>Weight Matrix of a Graph, e.g., a simulated DAG</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.7-11</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-12</td>
</tr>
<tr>
<td>Title:</td>
<td>Methods for Graphical Models and Causal Inference</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for causal structure
  learning and causal inference using graphical models. The main algorithms
  for causal structure learning are PC (for observational data without hidden
  variables), FCI and RFCI (for observational data with hidden variables),
  and GIES (for a mix of data from observational studies
  (i.e. observational data) and data from experiments
  involving interventions (i.e. interventional data) without hidden
  variables). For causal inference the IDA algorithm, the Generalized
  Backdoor Criterion (GBC), the Generalized Adjustment Criterion (GAC)
  and some related functions are implemented. Functions for incorporating
  background knowledge are provided.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Markus Kalisch &lt;kalisch@stat.math.ethz.ch&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 0.11.0), RcppArmadillo, BH</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, utils, methods, abind, graph, RBGL, igraph,
ggm, corpcor, robustbase, vcd, Rcpp, bdsmatrix, sfsmisc (&ge;
1.0-26), fastICA, clue</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS, Matrix, Rgraphviz, mvtnorm, huge, ggplot2, dagitty</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://pcalg.r-forge.r-project.org/">https://pcalg.r-forge.r-project.org/</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-12 10:30:09 UTC; kalischm</td>
</tr>
<tr>
<td>Author:</td>
<td>Markus Kalisch [aut, cre],
  Alain Hauser [aut],
  Martin Maechler [aut],
  Diego Colombo [ctb],
  Doris Entner [ctb],
  Patrik Hoyer [ctb],
  Antti Hyttinen [ctb],
  Jonas Peters [ctb],
  Nicoletta Andri [ctb],
  Emilija Perkovic [ctb],
  Preetam Nandy [ctb],
  Philipp Ruetimann [ctb],
  Daniel Stekhoven [ctb],
  Manuel Schuerch [ctb],
  Marco Eigenmann [ctb],
  Leonard Henckel [ctb],
  Joris Mooij [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-12 12:00:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='addBgKnowledge'>
Add background knowledge to a CPDAG or PDAG
</h2><span id='topic+addBgKnowledge'></span>

<h3>Description</h3>

<p>Add background knowledge x -&gt; y to an adjacency matrix and complete the orientation rules from Meek (1995).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addBgKnowledge(gInput, x = c(), y = c(), verbose = FALSE, checkInput = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addBgKnowledge_+3A_ginput">gInput</code></td>
<td>
<p><code>graphNEL</code> object or adjacency matrix of type <code>amat.cpdag</code> (see <code><a href="#topic+amatType">amatType</a></code>)</p>
</td></tr>
<tr><td><code id="addBgKnowledge_+3A_x">x</code>, <code id="addBgKnowledge_+3A_y">y</code></td>
<td>
<p>node labels of <code>x</code> or <code>y</code> in the adjacency matrix. <code>x</code> and <code>y</code> can be vectors representing several nodes (see details below).</p>
</td></tr>
<tr><td><code id="addBgKnowledge_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, detailed output is provided.</p>
</td></tr>
<tr><td><code id="addBgKnowledge_+3A_checkinput">checkInput</code></td>
<td>
<p>If TRUE, the input adjacency matrix is carefully
checked to see if it is a valid graph using function <code><a href="#topic+isValidGraph">isValidGraph</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the input is a <code>graphNEL</code> object, it will be converted into an adjacency matrix of type <code>amat.cpdag</code>.
If <code>x</code> and <code>y</code> are given and if <code>amat[y,x] != 0</code>, this function adds orientation x -&gt; y to the adjacency matrix <code>amat</code> and completes the orientation rules from Meek (1995).
If <code>x</code> and <code>y</code> are not specified (or empty vectors) this function simply completes the orientation rules from Meek (1995). If <code>x</code> and <code>y</code> are vectors of length k, k&gt;1, this function tries to add <code>x[i] -&gt; y[i]</code> to the adjacency matrix amat and complete the orientation rules from Meek (1995) for every <code class="reqn">i \in \{1, \ldots, k\}</code> (see Algorithm 1 in Perkovic et. al, 2017). 
</p>


<h3>Value</h3>

<p>An adjacency matrix of type <code>amat.cpdag</code> of the maximally oriented pdag with added background knowledge <code>x -&gt; y</code> or <code>NULL</code>, if the backgound knowledge is not consistent with any DAG represented by the PDAG with the adjacency matrix <code>amat</code>.
</p>


<h3>Author(s)</h3>

<p>Emilija Perkovic and Markus Kalisch
</p>


<h3>References</h3>

<p>C. Meek (1995). Causal inference and causal explanation with background knowledge, In Proceedings of UAI 1995, 403-410.
</p>
<p>E. Perkovic, M. Kalisch and M.H. Maathuis (2017). Interpreting and using CPDAGs with background knowledge. In Proceedings of UAI 2017. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a -- b -- c
amat &lt;- matrix(c(0,1,0, 1,0,1, 0,1,0), 3,3)
colnames(amat) &lt;- rownames(amat) &lt;- letters[1:3]
## plot(as(t(amat), "graphNEL"))             
addBgKnowledge(gInput = amat) ## amat is a valid CPDAG
## b -&gt; c is directed; a -- b is not directed by applying
## Meek's orientation rules
bg1 &lt;- addBgKnowledge(gInput = amat, x = "b", y = "c") 
## plot(as(t(bg1), "graphNEL"))
## b -&gt; c and b -&gt; a are directed
bg2 &lt;- addBgKnowledge(gInput = amat, x = c("b","b"), y = c("c","a")) 
## plot(as(t(bg2), "graphNEL")) 

## c -&gt; b is directed; as a consequence of Meek's orientation rules,
## b -&gt; a is directed as well
bg3 &lt;- addBgKnowledge(gInput = amat, x = "c", y = "b") 
## plot(as(t(bg3), "graphNEL")) 

amat2 &lt;- matrix(c(0,1,0, 1,0,1, 0,1,0), 3,3)
colnames(amat2) &lt;- rownames(amat2) &lt;- letters[1:3]
## new collider is inconsistent with original CPDAG; thus, NULL is returned
addBgKnowledge(gInput = amat2, x = c("c", "a"), y = c("b", "b"))

</code></pre>

<hr>
<h2 id='adjustment'>
Compute adjustment sets for covariate adjustment.
</h2><span id='topic+adjustment'></span>

<h3>Description</h3>

<p>This function is a wrapper for convenience to the function <code>adjustmentSet</code> from package <span class="pkg">dagitty</span>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjustment(amat, amat.type, x, y, set.type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjustment_+3A_amat">amat</code></td>
<td>

<p>adjacency matrix of type <code>amat.cpdag</code> or <code>amat.pag</code>.
</p>
</td></tr>
<tr><td><code id="adjustment_+3A_amat.type">amat.type</code></td>
<td>

<p>string specifying the type of graph of the adjacency matrix amat. It can be a DAG (type=&quot;dag&quot;), a CPDAG (type=&quot;cpdag&quot;) or a maximally oriented PDAG (type=&quot;pdag&quot;) from Meek (1995); then the type of adjacency matrix is assumed to be amat.cpdag. It can also be a MAG (type = &quot;mag&quot;) or a PAG (type=&quot;pag&quot;); then the type of the adjacency matrix is assumed to be amat.pag.
</p>
</td></tr>
<tr><td><code id="adjustment_+3A_x">x</code></td>
<td>

<p>(integer) position of variable x in the adjacency matrix.
</p>
</td></tr>
<tr><td><code id="adjustment_+3A_y">y</code></td>
<td>

<p>(integer) position of variable y in the adjacency matrix.
</p>
</td></tr>
<tr><td><code id="adjustment_+3A_set.type">set.type</code></td>
<td>

<p>string specifying the type of adjustment set that should be computed. It can be &quot;minimal&quot; ,&quot;all&quot; and &quot;canonical&quot;. See Details explanations.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>set.type</code> is &quot;minimal&quot;, then only minimal sufficient adjustment sets are returned. If <code>set.type</code> is &quot;all&quot;, all valid
adjustment sets are returned. If <code>set.type</code> is &quot;canonical&quot;, a single adjustment set
is returned that consists of all (possible) ancestors of <code>x</code> and <code>y</code>,
minus (possible) descendants of nodes on proper causal paths.  This canonical adjustment set is always valid if any valid set exists at all.
</p>


<h3>Value</h3>

<p>If adjustment sets exist, list of length at least one (list elements might be empty vectors, if the empty set is an adjustment set). If no adjustment set exists, an empty list is returned.
</p>


<h3>Author(s)</h3>

<p>Emilija Perkovic and Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>)
</p>


<h3>References</h3>

<p>E. Perkovic, J. Textor, M. Kalisch and M.H. Maathuis (2015). A
Complete Generalized Adjustment Criterion. In <em>Proceedings of UAI
2015.</em>
</p>
<p>E. Perkovic, J. Textor, M. Kalisch and M.H. Maathuis (2017). Complete graphical characterization and construction of adjustment sets in Markov equivalence classes of ancestral graphs. To appear in <em>Journal of Machine Learning Research.</em>
</p>
<p>B. van der Zander, M. Liskiewicz and J. Textor (2014). Constructing
separators and adjustment sets in ancestral graphs. In
<em>Proceedings of UAI 2014.</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gac">gac</a></code> for testing if a set satisfies the Generalized Adjustment Criterion.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example 4.1 in Perkovic et. al (2015), Example 2 in Perkovic et. al (2017)
mFig1 &lt;- matrix(c(0,1,1,0,0,0, 1,0,1,1,1,0, 0,0,0,0,0,1,
                  0,1,1,0,1,1, 0,1,0,1,0,1, 0,0,0,0,0,0), 6,6)
type &lt;- "cpdag"
x &lt;- 3; y &lt;- 6
## plot(as(t(mFig1), "graphNEL"))

## all
if(requireNamespace("dagitty", quietly = TRUE)) {
adjustment(amat = mFig1, amat.type = type, x = x, y = y, set.type =
"all")
}
## finds adjustment sets: (2,4), (1,2,4), (4,5), (1,4,5), (2,4,5), (1,2,4,5)

## minimal
if(requireNamespace("dagitty", quietly = TRUE)) {
adjustment(amat = mFig1, amat.type = type, x = x, y = y, set.type =
"minimal")
}
## finds adjustment sets: (2,4), (4,5), i.e., the valid sets with the fewest elements

## canonical
if(requireNamespace("dagitty", quietly = TRUE)) {
adjustment(amat = mFig1, amat.type = type, x = x, y = y, set.type =
"canonical")
}
## finds adjustment set: (1,2,4,5)
</code></pre>

<hr>
<h2 id='ages'>
Estimate an APDAG within the Markov equivalence class of a DAG using AGES
</h2><span id='topic+ages'></span>

<h3>Description</h3>

<p>Estimate an APDAG (a particular PDAG) using the aggregative greedy equivalence search (AGES) algorithm, which uses the solution path of the greedy equivalence search (GES) algorithm of Chickering (2002).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ages(data, lambda_min = 0.5 * log(nrow(data)), labels = NULL,
     fixedGaps = NULL, adaptive = c("none", "vstructures", "triples"),
     maxDegree = integer(0), verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ages_+3A_data">data</code></td>
<td>

<p>A <code class="reqn">n*p</code> matrix (or data frame) containing the observational data.
</p>
</td></tr>
<tr><td><code id="ages_+3A_lambda_min">lambda_min</code></td>
<td>

<p>The smallest penalty parameter value used when computing the solution path of GES.
</p>
</td></tr>
<tr><td><code id="ages_+3A_labels">labels</code></td>
<td>

<p>Node labels; if NULL the names of the columns of the data matrix (or the names in the data frame) are used. If these are not specified the sequence 1 to p is used.
</p>
</td></tr>
<tr><td><code id="ages_+3A_fixedgaps">fixedGaps</code></td>
<td>

<p>logical <em>symmetric</em> matrix of dimension p*p.  If entry
<code>[i, j]</code> is <code>TRUE</code>, the result is guaranteed to have no edge
between nodes <code class="reqn">i</code> and <code class="reqn">j</code>.
</p>
</td></tr>
<tr><td><code id="ages_+3A_adaptive">adaptive</code></td>
<td>

<p>indicating whether constraints should be adapted to
newly detected v-structures or unshielded triples (cf. details).
</p>
</td></tr>
<tr><td><code id="ages_+3A_maxdegree">maxDegree</code></td>
<td>

<p>Parameter used to limit the vertex degree of the estimated
graph.  Valid arguments:
</p>

<ol>
<li><p> Vector of length 0 (default): vertex degree is not limited.
</p>
</li>
<li><p> Real number <code class="reqn">r</code>, <code class="reqn">0 &lt; r &lt; 1</code>: degree of vertex <code class="reqn">v</code> is
limited to <code class="reqn">r \cdot n_v</code>, where <code class="reqn">n_v</code> denotes the number of
data points where <code class="reqn">v</code> was not intervened.
</p>
</li>
<li><p> Single integer: uniform bound of vertex degree for all vertices
of the graph.
</p>
</li>
<li><p> Integer vector of length <code>p</code>: vector of individual bounds
for the vertex degrees.
</p>
</li></ol>


</td></tr>
<tr><td><code id="ages_+3A_verbose">verbose</code></td>
<td>

<p>If <code>TRUE</code>, detailed output is provided.
</p>
</td></tr>
<tr><td><code id="ages_+3A_...">...</code></td>
<td>

<p>Additional arguments for debugging purposes and fine tuning.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function tries to add orientations to the essential graph (CPDAG) found by <code><a href="#topic+ges">ges</a></code> (ran with lambda=lambda_min). It does it aggregating several CPDAGs present in the solution path of GES. Conceptually, AGES starts with the essential graph found by GES ran with <code>lambda = lambda_min</code>. Then, it checks for further (compatible) orientation information in other essential graphs present in the solution path of GES, i.e., in essential graphs outputted by GES for larger penalty parameters. With compatible we mean that the aggregation process is done such that the final APDAG is still within the Markov equivalence graph represented by the essential graph found by GES in the following sense: an APDAG can always be extended to a DAG without creating new v-structures. This DAG lies in the Markov equivalence class represented by the essential graph found by GES. The algorithm is explained in detail in Eigenmann, Nandy, and Maathuis (2017).
</p>
<p>The arguments <code>fixedgaps</code> and <code>adaptive</code> work also with AGES. However, they have not been studied in Eigenmann, Nandy, and Maathuis (2017).
Using the argument <code>fixedGaps</code>, one can make sure that certain edges
will <em>not</em> be present in the resulting essential graph: if the entry
<code>[i, j]</code> of the matrix passed to <code>fixedGaps</code> is <code>TRUE</code>, there
will be no edge between nodes <code class="reqn">i</code> and <code class="reqn">j</code>. The argument <code>adaptive</code> can be
used to relax the constraints encoded by <code>fixedGaps</code> according to a 
modification of GES called ARGES (adaptively restricted greedy 
equivalence search) which has been presented in Nandy, Hauser and Maathuis
(2018):
</p>

<ul>
<li><p> When <code>adaptive = "vstructures"</code> and the algorithm introduces a 
new v-structure <code class="reqn">a \longrightarrow b \longleftarrow c</code> in the 
forward phase, then the edge <code class="reqn">a - c</code> is removed from the list of fixed 
gaps, meaning that the insertion of an edge between <code class="reqn">a</code> and <code class="reqn">c</code> 
becomes possible even if it was forbidden by the initial matrix passed to 
<code>fixedGaps</code>.
</p>
</li>
<li><p> When <code>adaptive = "triples"</code> and the algorithm introduces a new
unshielded triple in the forward phase (i.e., a subgraph of three nodes
<code class="reqn">a</code>, <code class="reqn">b</code> and <code class="reqn">c</code> where <code class="reqn">a</code> and <code class="reqn">b</code> as well as <code class="reqn">b</code>
and <code class="reqn">c</code> are adjacent, but <code class="reqn">a</code> and <code class="reqn">c</code> are not), then the edge
<code class="reqn">a - c</code> is removed from the list of fixed gaps.
</p>
</li></ul>

<p>With one of the adaptive modifications, the successive application of a 
skeleton estimation method and GES restricted to an estimated skeleton still
gives a <em>consistent</em> estimator of the DAG, which is not the case without
the adaptive modification.
</p>
<p>For a detailed explanation of the GES function as well as its related object like essential graphs, we refer to the <code><a href="#topic+ges">ges</a></code> function.
</p>
<p>Differences in the arguments with respect to GES: AGES uses <code>data</code> to initialize several scores taken as argument by GES. AGES modifies the forward and backward phases of GES performing single steps in either directions. For this reason, <code>phase</code>, <code>iterate</code>, and <code>turning</code> are not available arguments.
</p>


<h3>Value</h3>

<p><code>ages</code> returns a list with the following four components:
</p>
<table>
<tr><td><code>essgraph</code></td>
<td>
<p>An object of class <code><a href="#topic+EssGraph-class">EssGraph</a></code> containing an
estimate of the equivalence class of the underlying DAG.</p>
</td></tr>
<tr><td><code>repr</code></td>
<td>
<p>An object of a class derived from <code><a href="#topic+ParDAG-class">ParDAG</a></code>
containing a (random) representative of the estimated equivalence class.</p>
</td></tr>
<tr><td><code>CPDAGsList</code></td>
<td>
<p>A list of p*p matrices containing all CPDAGs considered by AGES in the aggregation processes</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>A vector containing the penalty parameter used to obtain the list of CPDAGs mentioned above. GES returns the list of CPDAGs when used with this vector of penalty parameters if used with phases = c(&quot;forward&quot;, &quot;backward&quot;) and iterate = FALSE.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marco Eigenmann (<a href="mailto:eigenmann@stat.math.ethz.ch">eigenmann@stat.math.ethz.ch</a>)
</p>


<h3>References</h3>

<p>D.M. Chickering (2002).  Optimal structure identification with greedy search.
<em>Journal of Machine Learning Research</em> <b>3</b>, 507&ndash;554
</p>
<p>M.F. Eigenmann, P. Nandy, and M.H. Maathuis (2017). Structure learning of linear Gaussian structural equation models with weak edges. In <em>Proceedings of UAI 2017</em>
</p>
<p>P. Nandy, A. Hauser and M.H. Maathuis (2018). High-dimensional consistency in score-based and hybrid structure learning. <em>Annals of Statistics</em>, to appear.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ges">ges</a></code>, <code><a href="#topic+EssGraph-class">EssGraph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example 1: ages adds correct orientations: Bar --&gt; V6 and Bar --&gt; V8

set.seed(77)

p &lt;- 8
n &lt;- 5000
## true DAG:
vars &lt;- c("Author", "Bar", "Ctrl", "Goal", paste0("V",5:8))
gGtrue &lt;- randomDAG(p, prob = 0.3, V = vars)
data = rmvDAG(n, gGtrue)


## Estimate the aggregated PDAG with ages
ages.fit &lt;- ages(data = data)


## Estimate the essential graph with ges
## We specify the phases in order to have a fair comparison of the algorithms
## Without the phases specified it would be easy to find examples
## where each algorithm outperforms the other
score &lt;- new("GaussL0penObsScore", data)
ges.fit &lt;- ges(score, phase = c("forward","backward"), iterate = FALSE)

## Plots
par(mfrow=c(1,3))
plot(ges.fit$essgraph, main="Estimated CPDAG with GES")
plot(ages.fit$essgraph, main="Estimated APDAG with AGES")
plot(gGtrue, main="TrueDAG")



## Example 2: ages adds correct orientations: Author --&gt; Goal and Author --&gt; V5

set.seed(50)

p &lt;- 9
n &lt;- 5000
## true DAG:
vars &lt;- c("Author", "Bar", "Ctrl", "Goal", paste0("V",5:9))
gGtrue &lt;- randomDAG(p, prob = 0.5, V = vars)
data = rmvDAG(n, gGtrue)


## Estimate the aggregated PDAG with ages
ages.fit &lt;- ages(data = data)


## Estimate the essential graph with ges
## We specify the phases in order to have a fair comparison of the algorithms
## Without the phases specified it would be easy to find examples
## where each algorithm outperforms the other
score &lt;- new("GaussL0penObsScore", data)
ges.fit &lt;- ges(score, phase = c("forward","backward"), iterate = FALSE)

## Plots
par(mfrow=c(1,3))
plot(ges.fit$essgraph, main="Estimated CPDAG with GES")
plot(ages.fit$essgraph, main="Estimated APDAG with AGES")
plot(gGtrue, main="TrueDAG")


## Example 3: ges and ages return the same graph

data(gmG)

data &lt;- gmG8$x

## Estimate the aggregated PDAG with ages
ages.fit &lt;- ages(data = data)


## Estimate the essential graph with ges
score &lt;- new("GaussL0penObsScore", data)
ges.fit &lt;- ges(score)


## Plots
par(mfrow=c(1,3))
plot(ges.fit$essgraph, main="Estimated CPDAG with GES")
plot(ages.fit$essgraph, main="Estimated APDAG with AGES")
plot(gmG8$g, main="TrueDAG")
</code></pre>

<hr>
<h2 id='amatType'>Types and Display of Adjacency Matrices in Package 'pcalg'</h2><span id='topic+amatType'></span><span id='topic+amat.cpdag'></span><span id='topic+amat.pag'></span><span id='topic+coerce+2CLINGAM+2Camat-method'></span><span id='topic+coerce+2CpcAlgo+2Camat-method'></span><span id='topic+coerce+2CfciAlgo+2Camat-method'></span><span id='topic+coerce+2CpcAlgo+2Cmatrix-method'></span><span id='topic+coerce+2CfciAlgo+2Cmatrix-method'></span><span id='topic+show.pc.amat'></span><span id='topic+show.fci.amat'></span>

<h3>Description</h3>

<p>Two types of adjacency matrices are used in package <span class="pkg">pcalg</span>: Type
<code>amat.cpdag</code> for DAGs and CPDAGs and type <code>amat.pag</code> for
MAGs and PAGs.  The required type of adjacency matrix is documented
in the help files of the respective functions or classes.  If in some
functions more detailed information on the graph type is needed
(i.e. DAG or CPDAG; MAG or PAG) this information will be passed in a
separate argument (see e.g. <code><a href="#topic+gac">gac</a></code> and the examples below).
</p>
<p>Note that you get (&lsquo;extract&rsquo;) such adjacency matrices as (S3)
objects of <code><a href="base.html#topic+class">class</a></code> <code>"amat"</code> via the usual
<code><a href="methods.html#topic+as">as</a>(., "&lt;class&gt;")</code> coercion, </p>
<pre>  as(from, "amat")
</pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="amatType_+3A_from">from</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object of
</p>
<p>class <code><a href="#topic+pcAlgo-class">pcAlgo</a></code>, as returned from
<code><a href="#topic+skeleton">skeleton</a>()</code> or <code><a href="#topic+pc">pc</a>()</code> or an object of
</p>
<p>class <code><a href="#topic+fciAlgo-class">fciAlgo</a></code>, as from <code><a href="#topic+fci">fci</a>()</code>
(or <code><a href="#topic+rfci">rfci</a></code>, <code><a href="#topic+fciPlus">fciPlus</a></code>, and
<code><a href="#topic+dag2pag">dag2pag</a></code>), or an object of
</p>
<p>class <code>"LINGAM"</code> as returned from <code><a href="#topic+lingam">lingam</a>()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Adjacency matrices are integer valued square matrices with zeros on the
diagonal.  They can have row- and columnnames; however, most functions
will work on the (integer) column positions in the adjacency matrix.
</p>
<p><b>Coding for type <code>amat.cpdag</code>:</b>
</p>

<dl>
<dt><code>0</code>:</dt><dd><p>No edge or tail</p>
</dd>
<dt><code>1</code>:</dt><dd><p>Arrowhead</p>
</dd>
</dl>

<p>Note that the edgemark-code refers to the <em>row</em> index (as opposed
adjacency matrices of type mag or pag).  E.g.:</p>
<pre>
    amat[a,b] = 0  and  amat[b,a] = 1   implies a --&gt; b.
    amat[a,b] = 1  and  amat[b,a] = 0   implies a &lt;-- b.
    amat[a,b] = 0  and  amat[b,a] = 0   implies a     b.
    amat[a,b] = 1  and  amat[b,a] = 1   implies a --- b.</pre>
<p><b>Coding for type <code>amat.pag</code>:</b>
</p>

<dl>
<dt><code>0</code>:</dt><dd><p>No edge</p>
</dd>
<dt><code>1</code>:</dt><dd><p>Circle</p>
</dd>
<dt><code>2</code>:</dt><dd><p>Arrowhead</p>
</dd>
<dt><code>3</code>:</dt><dd><p>Tail</p>
</dd>
</dl>

<p>Note that the edgemark-code refers to the <em>column</em> index (as
opposed adjacency matrices of type dag or cpdag).  E.g.:</p>
<pre>
  amat[a,b] = 2  and  amat[b,a] = 3   implies   a --&gt; b.
  amat[a,b] = 3  and  amat[b,a] = 2   implies   a &lt;-- b.
  amat[a,b] = 2  and  amat[b,a] = 2   implies   a &lt;-&gt; b.
  amat[a,b] = 1  and  amat[b,a] = 3   implies   a --o b.
  amat[a,b] = 0  and  amat[b,a] = 0   implies   a     b.</pre>


<h3>See Also</h3>

<p>E.g. <code><a href="#topic+gac">gac</a></code> for a function which takes an
adjacency matrix as input; <code><a href="#topic+fciAlgo-class">fciAlgo</a></code> for a class
which has an adjacency matrix in one slot.
</p>
<p><code><a href="#topic+getGraph">getGraph</a>(x)</code> extracts the <code>graph</code>
object from <code>x</code>, whereas <code>as(*, "amat")</code> gets the
corresponding adjacency matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################################################
## Function gac() takes an adjecency matrix of
## any kind as input.  In addition to that, the
## precise type of graph (DAG/CPDAG/MAG/PAG) needs
## to be passed as a different argument
##################################################
## Adjacency matrix of type 'amat.cpdag'
m1 &lt;- matrix(c(0,1,0,1,0,0, 0,0,1,0,1,0, 0,0,0,0,0,1,
               0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0), 6,6)
## more detailed information on the graph type needed by gac()
gac(m1, x=1,y=3, z=NULL, type = "dag")

## Adjacency matrix of type 'amat.cpdag'
m2 &lt;- matrix(c(0,1,1,0,0,0, 1,0,1,1,1,0, 0,0,0,0,0,1,
               0,1,1,0,1,1, 0,1,0,1,0,1, 0,0,0,0,0,0), 6,6)
## more detailed information on the graph type needed by gac()
gac(m2, x=3, y=6, z=c(2,4), type = "cpdag")

## Adjacency matrix of type 'amat.pag'
m3 &lt;- matrix(c(0,2,0,0, 3,0,3,3, 0,2,0,3, 0,2,2,0), 4,4)
## more detailed information on the graph type needed by gac()
mg3 &lt;- gac(m3, x=2, y=4, z=NULL, type = "mag")
pg3 &lt;- gac(m3, x=2, y=4, z=NULL, type = "pag")


############################################################
## as(*, "amat") returns an adjacency matrix incl. its type
############################################################
## Load predefined data
data(gmG)
n &lt;- nrow    (gmG8$x)
V &lt;- colnames(gmG8$x)

## define sufficient statistics
suffStat &lt;- list(C = cor(gmG8$x), n = n)
## estimate CPDAG
skel.fit &lt;- skeleton(suffStat, indepTest = gaussCItest,
                     alpha = 0.01, labels = V)
## Extract the "amat" [and show nicely via  'print()' method]:
as(skel.fit, "amat")

##################################################
## Function fci() returns an adjacency matrix
## of type amat.pag as one slot.
##################################################
set.seed(42)
p &lt;- 7
## generate and draw random DAG :
myDAG &lt;- randomDAG(p, prob = 0.4)

## find skeleton and PAG using the FCI algorithm
suffStat &lt;- list(C = cov2cor(trueCov(myDAG)), n = 10^9)
res &lt;- fci(suffStat, indepTest=gaussCItest,
           alpha = 0.9999, p=p, doPdsep = FALSE)
str(res)
## get the a(djacency) mat(rix)  and nicely print() it:
as(res, "amat")

##################################################
## pcAlgo object
##################################################
## Load predefined data
data(gmG)
n &lt;- nrow    (gmG8$x)
V &lt;- colnames(gmG8$x)

## define sufficient statistics
suffStat &lt;- list(C = cor(gmG8$x), n = n)
## estimate CPDAG
skel.fit &lt;- skeleton(suffStat, indepTest = gaussCItest,
                     alpha = 0.01, labels = V)
## Extract Adjacency Matrix - and print (via method 'print.amat'):
as(skel.fit, "amat")

pc.fit &lt;- pc(suffStat, indepTest = gaussCItest,
             alpha = 0.01, labels = V)
pc.fit # (using its own print() method 'print.pcAlgo')

as(pc.fit, "amat")
</code></pre>

<hr>
<h2 id='backdoor'>Find Set Satisfying the Generalized Backdoor Criterion (GBC)</h2><span id='topic+backdoor'></span>

<h3>Description</h3>

<p>This function first checks if the total causal effect of
one variable (<code>x</code>) onto another variable (<code>y</code>) is
identifiable via the GBC, and if this is
the case it explicitly gives a set of variables that satisfies the
GBC with respect to <code>x</code> and <code>y</code>
in the given graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>backdoor(amat, x, y, type = "pag", max.chordal = 10, verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="backdoor_+3A_amat">amat</code></td>
<td>
<p>adjacency matrix of type <code><a href="#topic+amat.cpdag">amat.cpdag</a></code> or
<code><a href="#topic+amat.pag">amat.pag</a></code>.</p>
</td></tr>
<tr><td><code id="backdoor_+3A_x">x</code>, <code id="backdoor_+3A_y">y</code></td>
<td>
<p>(integer) position of variable <code class="reqn">X</code> and <code class="reqn">Y</code>,
respectively, in the adjacency matrix.</p>
</td></tr>
<tr><td><code id="backdoor_+3A_type">type</code></td>
<td>
<p>string specifying the type of graph of the adjacency matrix
<code>amat</code>.  It can be a DAG (type=&quot;dag&quot;), a CPDAG (type=&quot;cpdag&quot;);
then the type of the adjacency matrix is assumed to be
<a href="#topic+amat.cpdag">amat.cpdag</a>.  It can also be a MAG (type=&quot;mag&quot;), or a PAG
(type=&quot;pag&quot;); then the type of the adjacency matrix is assumed to be
<a href="#topic+amat.pag">amat.pag</a>.</p>
</td></tr>
<tr><td><code id="backdoor_+3A_max.chordal">max.chordal</code></td>
<td>
<p>only if <code>type = "mag"</code>, is used in
<code><a href="#topic+pag2magAM">pag2magAM</a></code> to determine paths too large to be checked
for chordality.</p>
</td></tr>
<tr><td><code id="backdoor_+3A_verbose">verbose</code></td>
<td>
<p>logical; if true, some output is produced during
computation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a generalization of Pearl's backdoor criterion, see
Pearl (1993), defined for directed acyclic graphs (DAGs), for single
interventions and single outcome variable to more general types of
graphs (CPDAGs, MAGs, and PAGs) that describe Markov equivalence
classes of DAGs with and without latent variables but without
selection variables. For more details see Maathuis and Colombo (2015).
</p>
<p>The motivation to find a set W that satisfies the GBC with respect to
<code>x</code> and <code>y</code>
in the given graph relies on the result of the generalized backdoor adjustment:
</p>
<p><em>If a set of variables W satisfies the GBC relative to <code>x</code>
and <code>y</code> in the given graph, then
the causal effect of <code>x</code> on <code>y</code> is identifiable and is given
by</em> </p>
<p style="text-align: center;"><code class="reqn">%
    P(Y|do(X = x)) = \sum_W P(Y|X,W) \cdot P(W).</code>
</p>

<p>This result allows to write post-intervention densities (the one
written using Pearl's do-calculus) using only observational densities
estimated from the data.
</p>
<p>If the input graph is a DAG (<code>type="dag"</code>), this function reduces
to Pearl's backdoor criterion for single interventions and single
outcome variable, and the parents of <code>x</code> in the DAG satisfy the
backdoor criterion unless <code>y</code> is a parent of <code>x</code>.
</p>
<p>If the input graph is a CPDAG C (<code>type="cpdag"</code>), a MAG M
(<code>type="mag"</code>), or a PAG P (<code>type="pag"</code>) (with both M and P
not allowing selection variables), this function first checks if the
total causal effect of <code>x</code> on <code>y</code> is identifiable via the
GBC (see Maathuis and Colombo, 2015). If
the effect is not identifiable in this way, the output is
NA. Otherwise, an explicit set W that satisfies the GBC with respect
to <code>x</code> and <code>y</code> in the given graph is found.
</p>
<p>At this moment this function is not able to work with an RFCI-PAG.
</p>
<p>It is important to note that there can be pair of nodes <code>x</code> and
<code>y</code> for which there is no set W that satisfies the GBC, but the
total causal effect might be identifiable via some other technique.
</p>
<p>For the coding of the adjacency matrix see <a href="#topic+amatType">amatType</a>.
</p>


<h3>Value</h3>

<p>Either NA if the total causal effect is not identifiable via the
GBC, or a set if the effect is identifiable
via the GBC. Note that if the set W is
equal to the empty set, the output is NULL.
</p>


<h3>Author(s)</h3>

<p>Diego Colombo and Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>)</p>


<h3>References</h3>

<p>M.H. Maathuis and D. Colombo (2015). A generalized backdoor
criterion. Annals of Statistics 43 1060-1088.
</p>
<p>J. Pearl (1993). Comment: Graphical models, causality and intervention.
<em>Statistical Science</em> <b>8</b>, 266&ndash;269.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gac">gac</a></code> for the Generalized Adjustment Criterion
(GAC), which is a generalization of GBC; <code><a href="#topic+pc">pc</a></code> for
estimating a CPDAG, <code><a href="#topic+dag2pag">dag2pag</a></code>
and <code><a href="#topic+fci">fci</a></code> for estimating a PAG, and
<code><a href="#topic+pag2magAM">pag2magAM</a></code> for estimating a MAG.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#####################################################################
##DAG
#####################################################################
## Simulate the true DAG
suppressWarnings(RNGversion("3.5.0"))
set.seed(123)
p &lt;- 7
myDAG &lt;- randomDAG(p, prob = 0.2) ## true DAG

## Extract the adjacency matrix of the true DAG
true.amat &lt;- (amat &lt;- as(myDAG, "matrix")) != 0 # TRUE/FALSE &lt;==&gt; 1/0
print.table(1*true.amat, zero.=".") # "visualization"

## Compute set satisfying the GBC:
backdoor(true.amat, 5, 7, type="dag")

#####################################################################
##CPDAG
#####################################################################
##################################################
## Example not identifiable
## Maathuis and Colombo (2015), Fig. 3a, p.1072
##################################################
## create the graph
p &lt;- 5
. &lt;- 0
amat &lt;- rbind(c(.,.,1,1,1),
              c(.,.,1,1,1),
              c(.,.,.,1,.),
              c(.,.,.,.,1),
              c(.,.,.,.,.))
colnames(amat) &lt;- rownames(amat) &lt;- as.character(1:5)
V &lt;- as.character(1:5)
edL &lt;- vector("list",length=5)
names(edL) &lt;- V
edL[[1]] &lt;- list(edges=c(3,4,5),weights=c(1,1,1))
edL[[2]] &lt;- list(edges=c(3,4,5),weights=c(1,1,1))
edL[[3]] &lt;- list(edges=4,weights=c(1))
edL[[4]] &lt;- list(edges=5,weights=c(1))
g &lt;- new("graphNEL", nodes=V, edgeL=edL, edgemode="directed")

## estimate the true CPDAG
myCPDAG &lt;- dag2cpdag(g)
## Extract the adjacency matrix of the true CPDAG
true.amat &lt;- (as(myCPDAG, "matrix") != 0) # 1/0 &lt;==&gt; TRUE/FALSE

## The effect is not identifiable, in fact:
backdoor(true.amat, 3, 5, type="cpdag")


##################################################
## Example identifiable
## Maathuis and Colombo (2015), Fig. 3b, p.1072
##################################################

## create the graph
p &lt;- 6
amat &lt;- rbind(c(0,0,1,1,0,1), c(0,0,1,1,0,1), c(0,0,0,0,1,0),
              c(0,0,0,0,1,1), c(0,0,0,0,0,0), c(0,0,0,0,0,0))
colnames(amat) &lt;- rownames(amat) &lt;- as.character(1:6)
V &lt;- as.character(1:6)
edL &lt;- vector("list",length=6)
names(edL) &lt;- V
edL[[1]] &lt;- list(edges=c(3,4,6),weights=c(1,1,1))
edL[[2]] &lt;- list(edges=c(3,4,6),weights=c(1,1,1))
edL[[3]] &lt;- list(edges=5,weights=c(1))
edL[[4]] &lt;- list(edges=c(5,6),weights=c(1,1))
g &lt;- new("graphNEL", nodes=V, edgeL=edL, edgemode="directed")

## estimate the true CPDAG
myCPDAG &lt;- dag2cpdag(g)
## Extract the adjacency matrix of the true CPDAG
true.amat &lt;- as(myCPDAG, "matrix") != 0

## The effect is identifiable and the set satisfying GBC is:
backdoor(true.amat, 6, 3, type="cpdag")


##################################################################
##PAG
##################################################################
##################################################
## Example identifiable
## Maathuis and Colombo (2015), Fig. 5a, p.1075
##################################################

## create the graph
p &lt;- 7
amat &lt;- t(matrix(c(0,0,1,1,0,0,0, 0,0,1,1,0,0,0, 0,0,0,1,0,1,0,
                   0,0,0,0,0,0,1, 0,0,0,0,0,1,1, 0,0,0,0,0,0,0,
                   0,0,0,0,0,0,0),  7, 7))
colnames(amat) &lt;- rownames(amat) &lt;- as.character(1:7)
V &lt;- as.character(1:7)
edL &lt;- vector("list",length=7)
names(edL) &lt;- V
edL[[1]] &lt;- list(edges=c(3,4),weights=c(1,1))
edL[[2]] &lt;- list(edges=c(3,4),weights=c(1,1))
edL[[3]] &lt;- list(edges=c(4,6),weights=c(1,1))
edL[[4]] &lt;- list(edges=7,weights=c(1))
edL[[5]] &lt;- list(edges=c(6,7),weights=c(1,1))
g &lt;- new("graphNEL", nodes=V, edgeL=edL, edgemode="directed")
L &lt;- 5

## compute the true covariance matrix of g
cov.mat &lt;- trueCov(g)

## transform covariance matrix into a correlation matrix
true.corr &lt;- cov2cor(cov.mat)
suffStat &lt;- list(C=true.corr, n=10^9)
indepTest &lt;- gaussCItest

## estimate the true PAG
true.pag &lt;- dag2pag(suffStat, indepTest, g, L, alpha = 0.9999)@amat

## The effect is identifiable  and the backdoor set is:
backdoor(true.pag, 3, 5, type="pag")

</code></pre>

<hr>
<h2 id='beta.special'>Compute set of intervention effects</h2><span id='topic+beta.special'></span>

<h3>Description</h3>

<p>This function is DEPRECATED! Use <code><a href="#topic+ida">ida</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta.special(dat=NA, x.pos, y.pos, verbose=0, a=0.01, myDAG=NA,
             myplot=FALSE, perfect=FALSE, method="local", collTest=TRUE,
             pcObj=NA, all.dags=NA, u2pd="rand")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beta.special_+3A_dat">dat</code></td>
<td>
<p>Data matrix</p>
</td></tr>
<tr><td><code id="beta.special_+3A_x.pos">x.pos</code>, <code id="beta.special_+3A_y.pos">y.pos</code></td>
<td>
<p>integer column positions of <code class="reqn">x</code> and <code class="reqn">y</code> in <code>dat</code>.</p>
</td></tr>
<tr><td><code id="beta.special_+3A_verbose">verbose</code></td>
<td>
<p>0=no comments, 2=detail on estimates</p>
</td></tr>
<tr><td><code id="beta.special_+3A_a">a</code></td>
<td>
<p>Significance level of tests for finding CPDAG</p>
</td></tr>
<tr><td><code id="beta.special_+3A_mydag">myDAG</code></td>
<td>
<p>Needed if true correlation matrix shall be computed</p>
</td></tr>
<tr><td><code id="beta.special_+3A_myplot">myplot</code></td>
<td>
<p>Plot estimated graph</p>
</td></tr>
<tr><td><code id="beta.special_+3A_perfect">perfect</code></td>
<td>
<p>True cor matrix is calculated from myDAG</p>
</td></tr>
<tr><td><code id="beta.special_+3A_method">method</code></td>
<td>
<p>&quot;local&quot; - local (all combinations of parents in regr.);
&quot;global&quot; - all DAGs</p>
</td></tr>
<tr><td><code id="beta.special_+3A_colltest">collTest</code></td>
<td>
<p>True - Exclude orientations of undirected edges that
introduce a new collider</p>
</td></tr>
<tr><td><code id="beta.special_+3A_pcobj">pcObj</code></td>
<td>
<p>Fit of PC Algorithm (CPDAG); if this is available, no
new fit is done</p>
</td></tr>
<tr><td><code id="beta.special_+3A_all.dags">all.dags</code></td>
<td>
<p>All DAGs in the format of function allDags; if this is
available, no new function call allDags is done</p>
</td></tr>
<tr><td><code id="beta.special_+3A_u2pd">u2pd</code></td>
<td>
<p>function for converting a  UDAG to a PDAG;
&quot;rand&quot;: <code><a href="#topic+udag2pdag">udag2pdag</a></code>;
&quot;relaxed&quot;: <code><a href="#topic+udag2pdagRelaxed">udag2pdagRelaxed</a></code>;
&quot;retry&quot;: <code><a href="#topic+udag2pdagSpecial">udag2pdagSpecial</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>estimates of intervention effects
</p>


<h3>Author(s)</h3>

<p>Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>)</p>


<h3>See Also</h3>

<p><code><a href="#topic+pcAlgo">pcAlgo</a></code>, <code><a href="#topic+dag2cpdag">dag2cpdag</a></code>;
<code><a href="#topic+beta.special.pcObj">beta.special.pcObj</a></code> for a <em>fast</em> version of
<code>beta.special()</code>, using a precomputed pc-object.
</p>

<hr>
<h2 id='beta.special.pcObj'>Compute set of intervention effects in a fast way</h2><span id='topic+beta.special.pcObj'></span>

<h3>Description</h3>

<p>This function is DEPRECATED! Use <code><a href="#topic+ida">ida</a></code> or
<code><a href="#topic+idaFast">idaFast</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta.special.pcObj(x.pos, y.pos, pcObj, mcov=NA, amat=NA, amatSkel=NA, t.amat=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beta.special.pcObj_+3A_x.pos">x.pos</code></td>
<td>
<p>Column of x in dat</p>
</td></tr>
<tr><td><code id="beta.special.pcObj_+3A_y.pos">y.pos</code></td>
<td>
<p>Column of y in dat</p>
</td></tr>
<tr><td><code id="beta.special.pcObj_+3A_pcobj">pcObj</code></td>
<td>
<p>Precomputed pc-object</p>
</td></tr>
<tr><td><code id="beta.special.pcObj_+3A_mcov">mcov</code></td>
<td>
<p>Covariance that was used in the pc-object fit</p>
</td></tr>
<tr><td><code id="beta.special.pcObj_+3A_amat">amat</code>, <code id="beta.special.pcObj_+3A_amatskel">amatSkel</code>, <code id="beta.special.pcObj_+3A_t.amat">t.amat</code></td>
<td>
<p>Matrices that can be precomputed,  if
needed (see code for details on how to precompute)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>estimates of intervention effects
</p>


<h3>Author(s)</h3>

<p>Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>)</p>


<h3>See Also</h3>

<p><code><a href="#topic+pcAlgo">pcAlgo</a></code>, <code><a href="#topic+dag2cpdag">dag2cpdag</a></code>,
<code><a href="#topic+beta.special">beta.special</a></code></p>

<hr>
<h2 id='binCItest'>G square Test for (Conditional) Independence of Binary Variables</h2><span id='topic+gSquareBin'></span><span id='topic+binCItest'></span>

<h3>Description</h3>

<p><code class="reqn">G^2</code> test for (conditional) independence of
<em>binary</em> variables <code class="reqn">X</code> and <code class="reqn">Y</code> given the (possibly empty)
set of binary variables <code class="reqn">S</code>.
</p>
<p><code>binCItest()</code> is a wrapper of <code>gSquareBin()</code>, to be easily
used in <code><a href="#topic+skeleton">skeleton</a></code>, <code><a href="#topic+pc">pc</a></code> and
<code><a href="#topic+fci">fci</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gSquareBin(x, y, S, dm, adaptDF = FALSE, n.min = 10*df, verbose = FALSE)
binCItest (x, y, S, suffStat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binCItest_+3A_x">x</code>, <code id="binCItest_+3A_y">y</code></td>
<td>
<p>(integer) position of variable <code class="reqn">X</code> and <code class="reqn">Y</code>,
respectively, in the adjacency matrix.</p>
</td></tr>
<tr><td><code id="binCItest_+3A_s">S</code></td>
<td>
<p>(integer) positions of zero or more conditioning variables in the
adjacency matrix.</p>
</td></tr>
<tr><td><code id="binCItest_+3A_dm">dm</code></td>
<td>
<p>data matrix (with <code class="reqn">\{0,1\}</code> entries).</p>
</td></tr>
<tr><td><code id="binCItest_+3A_adaptdf">adaptDF</code></td>
<td>
<p>logical specifying if the degrees of freedom should be
lowered by one for each zero count.  The value for the degrees of
freedom cannot go below 1.</p>
</td></tr>
<tr><td><code id="binCItest_+3A_n.min">n.min</code></td>
<td>
<p>the smallest <code class="reqn">n</code> (number of observations,
<code>nrow(dm)</code>) for which the G^2 test is computed; for smaller
<code class="reqn">n</code>, independence is assumed (<code class="reqn">G^2 := 1</code>) with a warning.  The
default is <code class="reqn">10 m</code>, where <code class="reqn">m</code> is the degrees of freedom
assuming no structural zeros, <code class="reqn">2^{|S|}</code>.</p>
</td></tr>
<tr><td><code id="binCItest_+3A_verbose">verbose</code></td>
<td>
<p>logical or integer indicating that increased diagnostic output is to
be provided.</p>
</td></tr>
<tr><td><code id="binCItest_+3A_suffstat">suffStat</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> with two elements,
<code>"dm"</code>, and <code>"adaptDF"</code> corresponding to the above two
arguments of <code>gSquareBin()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code class="reqn">G^2</code> statistic is used to test for (conditional)
independence of X and Y given a set S (can be <code>NULL</code>).  This
function is a specialized version of <code><a href="#topic+gSquareDis">gSquareDis</a></code> which is
for discrete variables with more than two levels.
</p>


<h3>Value</h3>

<p>The p-value of the test.
</p>


<h3>Author(s)</h3>

<p>Nicoletta Andri and Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>)
</p>


<h3>References</h3>

<p>R.E. Neapolitan (2004).
Learning Bayesian Networks. <em>Prentice Hall Series in Artificial
Intelligence</em>. Chapter 10.3.1
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gSquareDis">gSquareDis</a></code> for a (conditional) independence test
for discrete variables with more than two levels.
</p>
<p><code><a href="#topic+dsepTest">dsepTest</a></code>, <code><a href="#topic+gaussCItest">gaussCItest</a></code> and
<code><a href="#topic+disCItest">disCItest</a></code> for similar functions for a d-separation
oracle, a conditional independence test for Gaussian variables and
a conditional independence test for discrete variables, respectively.
</p>
<p><code><a href="#topic+skeleton">skeleton</a></code>, <code><a href="#topic+pc">pc</a></code> or <code><a href="#topic+fci">fci</a></code> which
need a testing function such as <code>binCItest</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
set.seed(123)
## Simulate *independent data of {0,1}-variables:
x &lt;- rbinom(n, 1, pr=1/2)
y &lt;- rbinom(n, 1, pr=1/2)
z &lt;- rbinom(n, 1, pr=1/2)
dat &lt;- cbind(x,y,z)

binCItest(1,3,2, list(dm = dat, adaptDF = FALSE)) # 0.36, not signif.
binCItest(1,3,2, list(dm = dat, adaptDF = TRUE )) # the same, here

## Simulate data from a chain of 3 variables: x1 -&gt; x2 -&gt; x3
set.seed(12)
b0 &lt;- 0
b1 &lt;- 1
b2 &lt;- 1
n &lt;- 10000
x1 &lt;- rbinom(n, size=1, prob=1/2) ## = sample(c(0,1), n, replace=TRUE)

## NB:  plogis(u) := "expit(u)" := exp(u) / (1 + exp(u))
p2 &lt;- plogis(b0 + b1*x1) ; x2 &lt;- rbinom(n, 1, prob = p2) # {0,1}
p3 &lt;- plogis(b0 + b2*x2) ; x3 &lt;- rbinom(n, 1, prob = p2) # {0,1}

ftable(xtabs(~ x1+x2+x3))
dat &lt;- cbind(x1,x2,x3)

## Test marginal and conditional independencies
gSquareBin(3,1,NULL,dat, verbose=TRUE)
gSquareBin(3,1, 2,  dat)
gSquareBin(1,3, 2,  dat) # the same
gSquareBin(1,3, 2,  dat, adaptDF=TRUE, verbose = 2)

</code></pre>

<hr>
<h2 id='checkTriple'>Check Consistency of Conditional Independence for a Triple of Nodes</h2><span id='topic+checkTriple'></span>

<h3>Description</h3>

<p>For each subset of <code>nbrsA</code> and <code>nbrsC</code> where <code>a</code> and
<code>c</code> are conditionally independent, it is checked if <code>b</code> is in the
conditioning set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkTriple(a, b, c, nbrsA, nbrsC,
            sepsetA, sepsetC,
            suffStat, indepTest, alpha, version.unf = c(NA, NA),
            maj.rule = FALSE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkTriple_+3A_a">a</code>, <code id="checkTriple_+3A_b">b</code>, <code id="checkTriple_+3A_c">c</code></td>
<td>
<p>(integer) positions in adjacency matrix for nodes
<code class="reqn">a</code>, <code class="reqn">b</code>, and <code class="reqn">c</code>, respectively.</p>
</td></tr>
<tr><td><code id="checkTriple_+3A_nbrsa">nbrsA</code>, <code id="checkTriple_+3A_nbrsc">nbrsC</code></td>
<td>
<p>(integer) position in adjacency matrix for
neighbors of <code class="reqn">a</code> and <code class="reqn">c</code>, respectively.</p>
</td></tr> 
<tr><td><code id="checkTriple_+3A_sepseta">sepsetA</code></td>
<td>
<p>vector containing <code class="reqn">Sepset(a,c)</code>.</p>
</td></tr>
<tr><td><code id="checkTriple_+3A_sepsetc">sepsetC</code></td>
<td>
<p>vector containing <code class="reqn">Sepset(c,a)</code>.</p>
</td></tr>
<tr><td><code id="checkTriple_+3A_suffstat">suffStat</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> of sufficient statistics for
independent tests; see, e.g., <code><a href="#topic+pc">pc</a></code>.</p>
</td></tr>
<tr><td><code id="checkTriple_+3A_indeptest">indepTest</code></td>
<td>
<p>a <code><a href="base.html#topic+function">function</a></code> for the independence test,
see, e.g., <code><a href="#topic+pc">pc</a></code>.</p>
</td></tr>
<tr><td><code id="checkTriple_+3A_alpha">alpha</code></td>
<td>
<p>significance level of test.</p>
</td></tr>
<tr><td><code id="checkTriple_+3A_version.unf">version.unf</code></td>
<td>
<p>(integer) vector of length two: </p>

<dl>
<dt><code>version.unf[1]</code>:</dt><dd><p>1 - check for all separating subsets of
<code>nbrsA</code> and <code>nbrsC</code> if <code>b</code> is in that set,<br />
2 - it also checks if there at all exists any sepset which is a
subset of the neighbours (there might be none, although <code>b</code>
is in the sepset, which indicates an ambiguous situation);</p>
</dd>
<dt><code>version.unf[2]</code>:</dt><dd><p>1 - do not consider the initial sepsets
<code>sepsetA</code> and <code>sepsetC</code> (same as Tetrad),<br />
2 - consider if <code>b</code> is in <code>sepsetA</code> or
<code>sepsetC</code>.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="checkTriple_+3A_maj.rule">maj.rule</code></td>
<td>
<p>logical indicating that the following majority rule
is applied: if <code>b</code> is in less than
50% of the checked sepsets, we say that <code>b</code> is in <b>no</b> sepset.  If
<code>b</code> is in more than 50% of the checked sepsets, we say that 
<code>b</code> is in <b>all</b> sepsets.  If <code>b</code> is in exactly 50% of the
checked sepsets, the triple is considered &lsquo;ambiguous&rsquo;.</p>
</td></tr>
<tr><td><code id="checkTriple_+3A_verbose">verbose</code></td>
<td>
<p>Logical asking for detailed output of intermediate steps.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used in the conservative versions of structure
learning algorithms.
</p>


<h3>Value</h3>

<table>
<tr><td><code>decision</code></td>
<td>
<p>Decision on possibly ambiguous triple, an integer code,
</p>

<dl>
<dt>1</dt><dd><p><code>b</code> is in NO sepset (make v-structure);</p>
</dd>
<dt>2</dt><dd><p><code>b</code> is in ALL sepsets (make no v-structure);</p>
</dd>
<dt>3</dt><dd><p><code>b</code> is in SOME but not all sepsets (ambiguous triple)</p>
</dd>
</dl>
</td></tr>
<tr><td><code>vers</code></td>
<td>
<p>Version (1 or 2) of the ambiguous triple
(1=normal ambiguous triple that is <code>b</code> is in some sepsets;
2=triple coming from <code>version.unf[1]==2</code>, that is, <code>a</code> and
<code>c</code> are indep given the initial sepset but there doesn't exist a
subset of the neighbours that d-separates them.)</p>
</td></tr>
<tr><td><code>sepsetA</code></td>
<td>
<p>Updated version of <code>sepsetA</code></p>
</td></tr>
<tr><td><code>sepsetC</code></td>
<td>
<p>Updated version of <code>sepsetC</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>) and Diego Colombo.
</p>


<h3>References</h3>

<p>D. Colombo and M.H. Maathuis (2014).Order-independent constraint-based
causal structure learning. <em>Journal of Machine Learning Research</em>
<b>15</b> 3741-3782. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################################################
## Using Gaussian Data
##################################################
## Load predefined data
data(gmG)
n &lt;- nrow    (gmG8$x)
V &lt;- colnames(gmG8$x)


## define independence test (partial correlations), and test level
indepTest &lt;- gaussCItest
alpha &lt;- 0.01
## define sufficient statistics
suffStat &lt;- list(C = cor(gmG8$x), n = n)

## estimate CPDAG
pc.fit &lt;- pc(suffStat, indepTest, alpha=alpha, labels = V, verbose = TRUE)

if (require(Rgraphviz)) {
  ## show estimated CPDAG
  par(mfrow=c(1,2))
  plot(pc.fit, main = "Estimated CPDAG")
  plot(gmG8$g, main = "True DAG")
}

a &lt;- 6
b &lt;- 1
c &lt;- 8
checkTriple(a, b, c,
            nbrsA = c(1,5,7),
            nbrsC = c(1,5),
            sepsetA = pc.fit@sepset[[a]][[c]],
            sepsetC = pc.fit@sepset[[c]][[a]],
            suffStat=suffStat, indepTest=indepTest, alpha=alpha,
            version.unf = c(2,2),
            verbose = TRUE) -&gt; ct
str(ct)
## List of 4
## $ decision: int 2
## $ version : int 1
## $ SepsetA : int [1:2] 1 5
## $ SepsetC : int 1

checkTriple(a, b, c,
            nbrsA = c(1,5,7),
            nbrsC = c(1,5),
            sepsetA = pc.fit@sepset[[a]][[c]],
            sepsetC = pc.fit@sepset[[c]][[a]],
            version.unf = c(1,1),
            suffStat=suffStat, indepTest=indepTest, alpha=alpha) -&gt; c2
stopifnot(identical(ct, c2)) ## in this case,  'version.unf' had no effect
</code></pre>

<hr>
<h2 id='compareGraphs'>Compare two graphs in terms of TPR, FPR and TDR</h2><span id='topic+compareGraphs'></span>

<h3>Description</h3>

<p>Compares the true undirected graph with an estimated
undirected graph in terms of True Positive Rate (TPR), False Positive
Rate (FPR) and True Discovery Rate (TDR).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareGraphs(gl, gt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compareGraphs_+3A_gl">gl</code></td>
<td>
<p>Estimated graph (graph object)</p>
</td></tr>
<tr><td><code id="compareGraphs_+3A_gt">gt</code></td>
<td>
<p>True graph (graph object)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the input graph is directed, the directions are omitted.
Special cases:
</p>

<ul>
<li><p> If the true graph contains no edges, the tpr is defined to be
zero.
</p>
</li>
<li><p> Similarly, if the true graph contains no gaps, the fpr is
defined to be one.
</p>
</li>
<li>
<p>If there are no edges in the true graph and there are none in
the estimated graph, tdr is one. If there are none in the true graph but
there are some in the estimated graph, tdr is zero.
</p>
</li></ul>



<h3>Value</h3>

<p>A named numeric vector with three numbers:
</p>
<table>
<tr><td><code>tpr</code></td>
<td>
<p>True Positive Rate: Number of correctly found edges (in
estimated graph) divided by number of true edges (in true graph)</p>
</td></tr>
<tr><td><code>fpr</code></td>
<td>
<p>False Positive Rate: Number of incorrectly found edges
divided by number of true gaps (in true graph)</p>
</td></tr>
<tr><td><code>tdr</code></td>
<td>
<p>True Discovery Rate: Number of correctly found edges divided
by number of found edges (both in estimated graph)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>) and Martin Maechler
</p>


<h3>See Also</h3>

<p><code><a href="#topic+randomDAG">randomDAG</a></code> for generating a random DAG.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a graph with 4 nodes
V &lt;- LETTERS[1:4]
edL2 &lt;- vector("list", length=4)
names(edL2) &lt;- V
edL2[[1]] &lt;- list(edges= 2)
edL2[[2]] &lt;- list(edges= c(1,3,4))
edL2[[3]] &lt;- list(edges= c(2,4))
edL2[[4]] &lt;- list(edges= c(2,3))
gt &lt;- new("graphNEL", nodes=V, edgeL=edL2, edgemode="undirected")

## change graph
gl &lt;- graph::addEdge("A","C", gt,1)

## compare the two graphs
if (require(Rgraphviz)) {
par(mfrow=c(2,1))
plot(gt) ; title("True graph")
plot(gl) ; title("Estimated graph")
(cg &lt;- compareGraphs(gl,gt))

}

</code></pre>

<hr>
<h2 id='condIndFisherZ'>Test Conditional Independence of Gaussians via Fisher's Z</h2><span id='topic+condIndFisherZ'></span><span id='topic+zStat'></span><span id='topic+gaussCItest'></span>

<h3>Description</h3>

<p>Using Fisher's z-transformation of the partial correlation,
test for zero partial correlation of sets of normally / Gaussian
distributed random variables.
</p>
<p>The <code>gaussCItest()</code> function, using <code>zStat()</code> to test for
(conditional) independence between gaussian random variables, with an
interface that can easily be used in <code><a href="#topic+skeleton">skeleton</a></code>,
<code><a href="#topic+pc">pc</a></code> and <code><a href="#topic+fci">fci</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>condIndFisherZ(x, y, S, C, n, cutoff, verbose= )
zStat         (x, y, S, C, n)
gaussCItest   (x, y, S, suffStat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="condIndFisherZ_+3A_x">x</code>, <code id="condIndFisherZ_+3A_y">y</code>, <code id="condIndFisherZ_+3A_s">S</code></td>
<td>
<p>(integer) position of variable <code class="reqn">X</code>, <code class="reqn">Y</code> and set
of variables <code class="reqn">S</code>, respectively, in the adjacency matrix. It is
tested, whether <code>X</code> and <code>Y</code> are conditionally 
independent given the subset <code>S</code> of the remaining nodes.</p>
</td></tr>
<tr><td><code id="condIndFisherZ_+3A_c">C</code></td>
<td>
<p>Correlation matrix of nodes</p>
</td></tr>
<tr><td><code id="condIndFisherZ_+3A_n">n</code></td>
<td>
<p>Integer specifying the number of observations
(&ldquo;samples&rdquo;) used to estimate the correlation matrix <code>C</code>.</p>
</td></tr>
<tr><td><code id="condIndFisherZ_+3A_cutoff">cutoff</code></td>
<td>
<p>Numeric cutoff for significance level of individual partial
correlation tests.  Must be set to <code><a href="stats.html#topic+qnorm">qnorm</a>(1 - alpha/2)</code>
for a test significance level of <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="condIndFisherZ_+3A_verbose">verbose</code></td>
<td>
<p>Logical indicating whether some intermediate output should be
shown; currently not used.</p>
</td></tr>
<tr><td><code id="condIndFisherZ_+3A_suffstat">suffStat</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code> with two elements, <code>"C"</code>
and <code>"n"</code>, corresponding to the above arguments with the same name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For gaussian random variables and after performing Fisher's
z-transformation of the partial correlation, the test statistic
<code>zStat()</code> is (asymptotically for large enough <code>n</code>) standard
normally distributed.
</p>
<p>Partial correlation is tested in a two-sided hypothesis test, i.e.,
basically, <code>condIndFisherZ(*) == abs(zStat(*)) &gt; qnorm(1 - alpha/2)</code>.
In a multivariate normal distribution, zero partial correlation is
equivalent to conditional independence.
</p>


<h3>Value</h3>

<p><code>zStat()</code> gives a number
</p>
<p style="text-align: center;"><code class="reqn">Z = \sqrt{n - \left|S\right| - 3} \cdot \log((1+r)/(1-r))/2</code>
</p>

<p>which is asymptotically normally distributed under the null hypothesis
of correlation 0.
</p>
<p><code>condIndFisherZ()</code> returns a <code><a href="base.html#topic+logical">logical</a></code>
<code class="reqn">L</code> indicating whether the <em>&ldquo;partial correlation of x
and y given S is zero&rdquo;</em> could not be rejected on the given
significance level.  More intuitively and for multivariate normal
data, this means:  If <code>TRUE</code> then it seems plausible, that x and
y are conditionally independent given S.  If <code>FALSE</code> then there
was strong evidence found against this conditional independence
statement.
</p>
<p><code>gaussCItest()</code> returns the p-value of the test.
</p>


<h3>Author(s)</h3>

<p>Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>) and Martin Maechler
</p>


<h3>References</h3>

<p>M. Kalisch and P. Buehlmann (2007).
Estimating high-dimensional directed acyclic graphs with the PC-algorithm.
<em>JMLR</em> <b>8</b> 613-636.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pcorOrder">pcorOrder</a></code> for computing a partial correlation
given the correlation matrix in a recursive way.
</p>
<p><code><a href="#topic+dsepTest">dsepTest</a></code>, <code><a href="#topic+disCItest">disCItest</a></code> and
<code><a href="#topic+binCItest">binCItest</a></code> for similar functions for a d-separation
oracle, a conditional independence test for discrete variables and a
conditional independence test for binary variables, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
## Generate four independent normal random variables
n &lt;- 20
data &lt;- matrix(rnorm(n*4),n,4)
## Compute corresponding correlation matrix
corMatrix &lt;- cor(data)
## Test, whether variable 1 (col 1) and variable 2 (col 2) are
## independent given variable 3 (col 3) and variable 4 (col 4) on 0.05
## significance level
x &lt;- 1
y &lt;- 2
S &lt;- c(3,4)
n &lt;- 20
alpha &lt;- 0.05
cutoff &lt;- qnorm(1-alpha/2)
(b1 &lt;- condIndFisherZ(x,y,S,corMatrix,n,cutoff))
   # -&gt; 1 and 2 seem to be conditionally independent given 3,4

## Now an example with conditional dependence
data &lt;- matrix(rnorm(n*3),n,3)
data[,3] &lt;- 2*data[,1]
corMatrix &lt;- cor(data)
(b2 &lt;- condIndFisherZ(1,3,2,corMatrix,n,cutoff))
   # -&gt; 1 and 3 seem to be conditionally dependent given 2

## simulate another dep.case: x -&gt; y -&gt; z
set.seed(29)
x &lt;- rnorm(100)
y &lt;- 3*x + rnorm(100)
z &lt;- 2*y + rnorm(100)
dat &lt;- cbind(x,y,z)

## analyze data
suffStat &lt;- list(C = cor(dat), n = nrow(dat))
gaussCItest(1,3,NULL, suffStat) ## dependent [highly signif.]
gaussCItest(1,3,  2,  suffStat) ## independent | S
</code></pre>

<hr>
<h2 id='corGraph'>Computing the correlation graph</h2><span id='topic+corGraph'></span>

<h3>Description</h3>

<p>Computes the correlation graph.  This is the graph in which an edge is
drawn between node i and node j, if the null hypothesis &ldquo;<em>Correlation
between <code class="reqn">X_i</code> and <code class="reqn">X_j</code> is zero</em>&rdquo; can be rejected at the
given significance level <code class="reqn">\alpha (alpha)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corGraph(dm, alpha=0.05, Cmethod="pearson")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corGraph_+3A_dm">dm</code></td>
<td>
<p>numeric matrix with rows as samples and columns as variables.</p>
</td></tr>
<tr><td><code id="corGraph_+3A_alpha">alpha</code></td>
<td>
<p>significance level for correlation test (numeric)</p>
</td></tr>
<tr><td><code id="corGraph_+3A_cmethod">Cmethod</code></td>
<td>
<p>a <code><a href="base.html#topic+character">character</a></code> string indicating which
correlation coefficient is to be used for the test.  One of
<code>"pearson"</code>, <code>"kendall"</code>, or <code>"spearman"</code>, can be
abbreviated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Undirected correlation graph, a <code>graph</code> object
(package <span class="pkg">graph</span>);  <code><a href="#topic+getGraph">getGraph</a></code> for the &ldquo;fitted&rdquo;
graph.
</p>


<h3>Author(s)</h3>

<p>Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>) and Martin Maechler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create correlated samples
x1 &lt;- rnorm(100)
x2 &lt;- rnorm(100)
mat &lt;- cbind(x1,x2, x3 = x1+x2)

if (require(Rgraphviz)) {
## ``analyze the data''
(g &lt;- corGraph(mat)) # a 'graphNEL' graph, undirected
plot(g) # ==&gt; (1) and (2) are each linked to (3)

## use different significance level and different method
(g2 &lt;- corGraph(mat, alpha=0.01, Cmethod="kendall"))
plot(g2) ## same edges as 'g'
}
</code></pre>

<hr>
<h2 id='dag2cpdag'>Convert a DAG to a CPDAG</h2><span id='topic+dag2cpdag'></span>

<h3>Description</h3>

<p>Convert a DAG (Directed Acyclic Graph) to a Completed Partially
Directed Acyclic Graph (CPDAG).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dag2cpdag(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dag2cpdag_+3A_g">g</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object of class <code>"graph"</code> (package <span class="pkg">graph</span>),
representing a DAG.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts a DAG into its corresponding
(unique) CPDAG as follows.  Because every DAG in the
Markov equivalence class described by a CPDAG shares the same skeleton
and the same v-structures, this function takes the skeleton and the
v-structures of the given DAG <code>g</code>.  Afterwards it simply uses the
3 orientation rules of the PC algorithm (see references) to orient as
many of the remaining undirected edges as possible.
</p>
<p>The function is a simple wrapper function for <code><a href="#topic+dag2essgraph">dag2essgraph</a></code>
which is more powerfull since it also allows the calculation of the 
Markov equivalence class in the presence of interventional data.
</p>
<p>The output of this function is exactly the same as the one using
</p>
<pre>pc(suffStat, indepTest, alpha, labels)</pre>
<p>using the true correlation matrix in the function <code>gaussCItest</code>
with a large virtual sample size and a large alpha, but it is much
faster.
</p>


<h3>Value</h3>

<p>A graph object containing the CPDAG.
</p>


<h3>Author(s)</h3>

<p>Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>) and 
Alain Hauser(<a href="mailto:alain.hauser@bfh.ch">alain.hauser@bfh.ch</a>)</p>


<h3>References</h3>

<p>C. Meek (1995). Causal inference and causal explanation with
background knowledge. In <em>Proceedings of the Eleventh Conference on
Uncertainty in Artificial Intelligence (UAI-95)</em>, pp. 403-411. Morgan
Kaufmann Publishers, Inc.
</p>
<p>P. Spirtes, C. Glymour and R. Scheines (2000)
<em>Causation, Prediction, and Search</em>, 2nd edition, The MIT Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dag2essgraph">dag2essgraph</a></code>, <code><a href="#topic+randomDAG">randomDAG</a></code>, <code><a href="#topic+pc">pc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## A -&gt; B &lt;- C
am1 &lt;- matrix(c(0,1,0, 0,0,0, 0,1,0), 3,3)
colnames(am1) &lt;- rownames(am1) &lt;- LETTERS[1:3]
g1 &lt;- as(t(am1), "graphNEL") ## convert to graph
cpdag1 &lt;- dag2cpdag(g1)

if(requireNamespace("Rgraphviz")) {
    par(mfrow = c(1,2))
    plot(g1)
    plot(cpdag1)
}

## A -&gt; B -&gt; C
am2 &lt;- matrix(c(0,1,0, 0,0,1, 0,0,0), 3,3)
colnames(am2) &lt;- rownames(am2) &lt;- LETTERS[1:3]
g2 &lt;- as(t(am2), "graphNEL") ## convert to graph
cpdag2 &lt;- dag2cpdag(g2)

if(requireNamespace("Rgraphviz")) {
    par(mfrow = c(1,2))
    plot(g2)
    plot(cpdag2)
}
</code></pre>

<hr>
<h2 id='dag2essgraph'>Convert a DAG to an Essential Graph</h2><span id='topic+dag2essgraph'></span>

<h3>Description</h3>

<p>Convert a DAG to an (interventional or observational) essential graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dag2essgraph(dag, targets = list(integer(0)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dag2essgraph_+3A_dag">dag</code></td>
<td>
<p>The DAG whose essential graph has to be calculated.  Different
representations are possible: <code>dag</code> can be an 
object of <code>graphNEL</code> (package <span class="pkg">graph</span>) or 
an instance of a class derived from <code><a href="#topic+ParDAG-class">ParDAG</a></code>.</p>
</td></tr>
<tr><td><code id="dag2essgraph_+3A_targets">targets</code></td>
<td>
<p>List of intervention targets with respect to which the 
essential graph has to be calculated.  An observational setting is
represented by one single empty target (<code>list(integer(0))</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts a DAG to its corresponding (interventional or 
observational) essential graph, using the algorithm of Hauser and Bühlmann
(2012).
</p>
<p>The essential graph is a partially directed graph that represents the
(interventional or observational) Markov equivalence class of a DAG.  It has
the same has the same skeleton as the DAG; a directed edge represents an
arrow that has a common orientation in all representatives of the 
(interventional or observational) Markov equivalence class, whereas an
undirected edge represents an arrow that has different orientations in
different representatives of the equivalence class.  In the observational 
case, the essential graph is also known as &ldquo;CPDAG&rdquo; (Spirtes <em>et al.</em>,
2000).
</p>
<p>In a purely observational setting (<em>i.e.</em>, if <code>targets = 
  list(integer(0))</code>), the function yields the same graph as 
<code><a href="#topic+dag2cpdag">dag2cpdag</a></code>.
</p>


<h3>Value</h3>

<p>Depending on the class of <code>dag</code>, the essential graph is returned as
</p>

<ul>
<li><p>an instance of <code>graphNEL</code>, if <code>dag</code> is an 
instance of <code>graphNEL</code>,
</p>
</li>
<li><p>an instance of <code><a href="#topic+EssGraph-class">EssGraph</a></code>, if <code>dag</code> is
an instance of a class derived from <code><a href="#topic+ParDAG-class">ParDAG</a></code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Alain Hauser (<a href="mailto:alain.hauser@bfh.ch">alain.hauser@bfh.ch</a>)
</p>


<h3>References</h3>

<p>A. Hauser and P. Bühlmann (2012).  Characterization and greedy learning of 
interventional Markov equivalence classes of directed acyclic graphs.
<em>Journal of Machine Learning Research</em> <b>13</b>, 2409&ndash;2464.
</p>
<p>P. Spirtes, C.N. Glymour, and R. Scheines (2000).  <em>Causation,
Prediction, and Search</em>, MIT Press, Cambridge (MA).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dag2cpdag">dag2cpdag</a></code>, <code><a href="#topic+Score-class">Score</a></code>, <code><a href="#topic+EssGraph-class">EssGraph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- 10     # Number of random variables
s &lt;- 0.4    # Sparseness of the DAG

## Generate a random DAG
set.seed(42)
require(graph)
dag &lt;- randomDAG(p, s)
nodes(dag) &lt;- sprintf("V%d", 1:p)

## Calculate observational essential graph
res.obs &lt;- dag2essgraph(dag)

## Different argument classes
res2 &lt;- dag2essgraph(as(dag, "GaussParDAG"))
str(res2)

## Calculate interventional essential graph for intervention targets
## {1} and {3}
res.int &lt;- dag2essgraph(dag, as.list(c(1, 3)))
</code></pre>

<hr>
<h2 id='dag2pag'>Convert a DAG with latent variables into a PAG</h2><span id='topic+dag2pag'></span>

<h3>Description</h3>

<p>Convert a DAG with latent variables into its corresponding (unique)
Partial Ancestral Graph (PAG).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dag2pag(suffStat, indepTest, graph, L, alpha, rules = rep(TRUE,10),
        verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dag2pag_+3A_suffstat">suffStat</code></td>
<td>
<p>the sufficient statistics, a <code><a href="base.html#topic+list">list</a></code>
containing all necessary elements for the conditional independence
decisions in the function <code>indepTest</code>.</p>
</td></tr>
<tr><td><code id="dag2pag_+3A_indeptest">indepTest</code></td>
<td>
<p>a <code><a href="base.html#topic+function">function</a></code> for testing conditional
independence.  The function is internally called as
<code>indepTest(x,y,S,suffStat)</code>, and tests conditional independence
of <code>x</code> and <code>y</code> given <code>S</code>.  Here, <code>x</code> and
<code>y</code> are variables, and <code>S</code> is a (possibly empty) vector of
variables (all variables are denoted by their column numbers
in the adjacency matrix).  <code>suffStat</code> is a list containing
all relevant elements for the conditional independence
decisions.  The return value of <code>indepTest()</code> is the p-value of
the test for conditional independence.</p>
</td></tr>
<tr><td><code id="dag2pag_+3A_graph">graph</code></td>
<td>
<p>a DAG with <code>p</code> nodes, a <span class="pkg">graph</span> object.  The
graph must be topological sorted (for example produced using
<code><a href="#topic+randomDAG">randomDAG</a></code>).</p>
</td></tr>
<tr><td><code id="dag2pag_+3A_l">L</code></td>
<td>
<p>array containing the labels of the nodes in the <code>graph</code>
corresponding to the latent variables.</p>
</td></tr>
<tr><td><code id="dag2pag_+3A_alpha">alpha</code></td>
<td>
<p>significance level in <code class="reqn">(0,1)</code> for the individual
conditional independence tests.</p>
</td></tr>
<tr><td><code id="dag2pag_+3A_rules">rules</code></td>
<td>
<p>logical vector of length 10 indicating which rules
should be used when directing edges.  The order of the rules is
taken from Zhang (2009).</p>
</td></tr>
<tr><td><code id="dag2pag_+3A_verbose">verbose</code></td>
<td>
<p>logical; if <code>TRUE</code>, detailed output is provided.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts a DAG (graph object) with latent variables into
its corresponding (unique) PAG, an <code><a href="#topic+fciAlgo-class">fciAlgo</a></code> class
object, using the ancestor information and conditional independence
tests entailed in the true DAG.  The output of this function is
exactly the same as the one using
</p>
<pre>fci(suffStat, gaussCItest, p, alpha, rules = rep(TRUE, 10))
</pre>
<p>using the true correlation matrix in <code>gaussCItest()</code> with a large
&ldquo;virtual sample size&rdquo; and a large alpha, but it is much faster,
see the example.
</p>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> <code><a href="#topic+fciAlgo-class">fciAlgo</a></code>,
containing the estimated graph (in the form of an adjacency matrix
with various possible edge marks), the conditioning sets that lead to
edge removals (sepset) and several other parameters.
</p>


<h3>Author(s)</h3>

<p>Diego Colombo and
Markus Kalisch <a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>.
</p>


<h3>References</h3>

<p>Richardson, T. and Spirtes, P. (2002).
Ancestral graph Markov models.
<em>Ann. Statist.</em> <b>30</b>, 962&ndash;1030; Theorem 4.2., page 983.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fci">fci</a></code>, <code><a href="#topic+pc">pc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create the graph
set.seed(78)
g &lt;- randomDAG(10, prob = 0.25)
graph::nodes(g) # "1" "2" ... "10" % FIXME: should be kept in result!

## define nodes 2 and 6 to be latent variables
L &lt;- c(2,6)

## compute the true covariance matrix of g
cov.mat &lt;- trueCov(g)
## transform covariance matrix into a correlation matrix
true.corr &lt;- cov2cor(cov.mat)

## Find PAG
## as dependence "oracle", we use the true correlation matrix in
## gaussCItest() with a large "virtual sample size" and a large alpha:
system.time(
true.pag &lt;- dag2pag(suffStat = list(C = true.corr, n = 10^9),
                    indepTest = gaussCItest,
                    graph=g, L=L, alpha = 0.9999) )

### ---- Find PAG using fci-function --------------------------

## From trueCov(g), delete rows and columns belonging to latent variable L
true.cov1 &lt;- cov.mat[-L,-L]
## transform covariance matrix into a correlation matrix
true.corr1 &lt;- cov2cor(true.cov1)

## Find PAG with FCI algorithm
## as dependence "oracle", we use the true correlation matrix in
## gaussCItest() with a large "virtual sample size" and a large alpha:
system.time(
true.pag1 &lt;- fci(suffStat = list(C = true.corr1, n = 10^9),
                 indepTest = gaussCItest,
                 p = ncol(true.corr1), alpha = 0.9999) )

## confirm that the outputs are equal
stopifnot(true.pag@amat == true.pag1@amat)
</code></pre>

<hr>
<h2 id='disCItest'>G square Test for (Conditional) Independence of Discrete Variables</h2><span id='topic+disCItest'></span><span id='topic+gSquareDis'></span>

<h3>Description</h3>

<p><code class="reqn">G^2</code> test for (conditional) independence of <em>discrete</em>
(each with a <em>finite</em> number of &ldquo;levels&rdquo;)
variables <code class="reqn">X</code> and <code class="reqn">Y</code> given the (possibly empty) set of
discrete variables <code class="reqn">S</code>.
</p>
<p><code>disCItest()</code> is a wrapper of <code>gSquareDis()</code>, to be easily
used in <code><a href="#topic+skeleton">skeleton</a></code>, <code><a href="#topic+pc">pc</a></code> and <code><a href="#topic+fci">fci</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gSquareDis(x, y, S, dm, nlev, adaptDF = FALSE, n.min = 10*df, verbose = FALSE)
disCItest (x, y, S, suffStat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="disCItest_+3A_x">x</code>, <code id="disCItest_+3A_y">y</code></td>
<td>
<p>(integer) position of variable <code class="reqn">X</code> and <code class="reqn">Y</code>,
respectively, in the adjacency matrix.</p>
</td></tr>
<tr><td><code id="disCItest_+3A_s">S</code></td>
<td>
<p>(integer) positions of zero or more conditioning variables in the
adjacency matrix.</p>
</td></tr>
<tr><td><code id="disCItest_+3A_dm">dm</code></td>
<td>
<p>data matrix (rows: samples, columns: variables) with integer
entries; the k levels for a given column must be coded by the integers
0,1,...,k-1. (see example)</p>
</td></tr>
<tr><td><code id="disCItest_+3A_nlev">nlev</code></td>
<td>
<p>optional vector with numbers of levels for each variable
in <code>dm</code>.</p>
</td></tr>
<tr><td><code id="disCItest_+3A_adaptdf">adaptDF</code></td>
<td>
<p>logical specifying if the degrees of freedom should be
lowered by one for each zero count.  The value for the degrees of
freedom cannot go below 1.</p>
</td></tr>
<tr><td><code id="disCItest_+3A_n.min">n.min</code></td>
<td>
<p>the smallest <code class="reqn">n</code> (number of observations,
<code>nrow(dm)</code>) for which the G^2 test is computed; for smaller
<code class="reqn">n</code>, independence is assumed (<code class="reqn">G^2 := 1</code>) with a warning.  The
default is <code class="reqn">10 m</code>, where <code class="reqn">m</code> is the degrees of freedom
assuming no structural zeros, here, the product of all the number of
levels <code>(nlev[x]-1) * (nlev[y]-1) * prod(nlev[S])</code>.</p>
</td></tr>
<tr><td><code id="disCItest_+3A_verbose">verbose</code></td>
<td>
<p>logical or integer indicating that increased diagnostic output is to
be provided.</p>
</td></tr>
<tr><td><code id="disCItest_+3A_suffstat">suffStat</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> with three elements, <code>"dm"</code>,
<code>"nlev"</code>, <code>"adaptDF"</code>; each corresponding to the above
arguments of <code>gSquareDis()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code class="reqn">G^2</code> statistic is used to test for (conditional) independence
of X and Y given a set S (can be <code>NULL</code>).  If only binary
variables are involved, <code><a href="#topic+gSquareBin">gSquareBin</a></code> is a specialized
(a bit more efficient) alternative to <code>gSquareDis()</code>.
</p>


<h3>Value</h3>

<p>The p-value of the test.
</p>


<h3>Author(s)</h3>

<p>Nicoletta Andri and Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>).
</p>


<h3>References</h3>

<p>R.E. Neapolitan (2004).
Learning Bayesian Networks. <em>Prentice Hall Series in Artificial
Intelligence</em>. Chapter 10.3.1
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gSquareBin">gSquareBin</a></code> for a (conditional) independence test
for binary variables.
</p>
<p><code><a href="#topic+dsepTest">dsepTest</a></code>, <code><a href="#topic+gaussCItest">gaussCItest</a></code> and
<code><a href="#topic+binCItest">binCItest</a></code> for similar functions for a d-separation
oracle, a conditional independence test for gaussian variables and a
conditional independence test for binary variables, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate data
n &lt;- 100
set.seed(123)
x &lt;- sample(0:2, n, TRUE) ## three levels
y &lt;- sample(0:3, n, TRUE) ## four levels
z &lt;- sample(0:1, n, TRUE) ## two levels
dat &lt;- cbind(x,y,z)

## Analyze data
gSquareDis(1,3, S=2, dat, nlev = c(3,4,2)) # but nlev is optional:
gSquareDis(1,3, S=2, dat, verbose=TRUE, adaptDF=TRUE)
## with too little data, gives a warning (and p-value 1):
gSquareDis(1,3, S=2, dat[1:60,], nlev = c(3,4,2))

suffStat &lt;- list(dm = dat, nlev = c(3,4,2), adaptDF = FALSE)
disCItest(1,3,2,suffStat)
</code></pre>

<hr>
<h2 id='dreach'>Compute D-SEP(x,y,G)</h2><span id='topic+dreach'></span>

<h3>Description</h3>

<p>Let x and y be two distinct vertices in a mixed graph G.  This
function computes D-SEP(x,y,G), which is defined as follows:
</p>
<p>A node v is in D-SEP(x,y,G) iff v is not equal to x and there is a collider
path between x and v in G such that every vertex on this path is an
ancestor of x or y in G.
</p>
<p>See p.136 of Sprirtes et al (2000) or Definition 4.1 of Maathuis and
Colombo (2015). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  dreach(x, y, amat, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dreach_+3A_x">x</code></td>
<td>
<p>First argument of D-SEP, given as the column number of the
node in the adjacency matrix.</p>
</td></tr> 
<tr><td><code id="dreach_+3A_y">y</code></td>
<td>
<p>Second argument of D-SEP, given as the column number of the
node in the adjacency matrix (<code>y</code> must be different from <code>x</code>).</p>
</td></tr> 
<tr><td><code id="dreach_+3A_amat">amat</code></td>
<td>
<p>Adjacency matrix of type <a href="#topic+amat.pag">amat.pag</a>.</p>
</td></tr>
<tr><td><code id="dreach_+3A_verbose">verbose</code></td>
<td>
<p>Logical specifying details should be on output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of column positions indicating the nodes in D-SEP(x,y,G).
</p>


<h3>Author(s)</h3>

<p>Diego Colombo and Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>)</p>


<h3>References</h3>

<p>P. Spirtes, C. Glymour and R. Scheines (2000)
<em>Causation, Prediction, and Search</em>, 2nd edition, The MIT Press.
</p>
<p>M.H. Maathuis and D. Colombo (2015). A generalized back-door
criterion. <em>Annals of Statistics</em> <b>43</b> 1060-1088.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+backdoor">backdoor</a></code> uses this function;
<code><a href="#topic+pag2magAM">pag2magAM</a></code>.
</p>

<hr>
<h2 id='dsep'>Test for d-separation in a DAG</h2><span id='topic+dsep'></span>

<h3>Description</h3>

<p>This function tests for d-separation of nodes in a DAG.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsep(a, b, S=NULL, g, john.pairs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dsep_+3A_a">a</code></td>
<td>
<p>Label (sic!) of node A</p>
</td></tr>
<tr><td><code id="dsep_+3A_b">b</code></td>
<td>
<p>Label (sic!) of node B</p>
</td></tr>
<tr><td><code id="dsep_+3A_s">S</code></td>
<td>
<p>Labels (sic!) of set of nodes on which it is conditioned,
maybe empty</p>
</td></tr>
<tr><td><code id="dsep_+3A_g">g</code></td>
<td>
<p>The Directed Acyclic Graph (object of <code><a href="base.html#topic+class">class</a></code>
&quot;graph&quot;, see <code><a href="graph.html#topic+graph-class">graph-class</a></code> from the
package <span class="pkg">graph</span>)</p>
</td></tr>
<tr><td><code id="dsep_+3A_john.pairs">john.pairs</code></td>
<td>
<p>The shortest path distance matrix for all pairs of
nodes as computed (also by default) in
<code><a href="RBGL.html#topic+johnson.all.pairs.sp">johnson.all.pairs.sp</a></code> from package <span class="pkg">RBGL</span>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function checks separation in the moralized graph as
explained in Lauritzen (2004).</p>


<h3>Value</h3>

<p>TRUE if a and b are d-separated by S in G, otherwise FALSE.
</p>


<h3>Author(s)</h3>

<p>Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>)
</p>


<h3>References</h3>

<p>S.L. Lauritzen (2004),
Graphical Models, <em>Oxford University Press</em>, Chapter 3.2.2
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dsepTest">dsepTest</a></code> for a wrapper of this function that can
easily be included into <code><a href="#topic+skeleton">skeleton</a></code>, <code><a href="#topic+pc">pc</a></code>,
<code><a href="#topic+fci">fci</a></code> or <code><a href="#topic+fciPlus">fciPlus</a></code>. 
<code><a href="#topic+dsepAM">dsepAM</a></code> for a similar function for MAGs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate random DAG
p &lt;- 8
set.seed(45)
myDAG &lt;- randomDAG(p, prob = 0.3)
if (require(Rgraphviz)) {
plot(myDAG)
}

## Examples for d-separation
dsep("1","7",NULL,myDAG)
dsep("4","5",NULL,myDAG)
dsep("4","5","2",myDAG)
dsep("4","5",c("2","3"),myDAG)

## Examples for d-connection
dsep("1","3",NULL,myDAG)
dsep("1","6","3",myDAG)
dsep("4","5","8",myDAG)
</code></pre>

<hr>
<h2 id='dsepAM'>Test for d-separation in a MAG</h2><span id='topic+dsepAM'></span>

<h3>Description</h3>

<p>This function tests for d-separation (also known as m-separation) of nodes <code>X</code> and nodes <code>Y</code> given nodes <code>S</code> in a MAG.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsepAM(X, Y, S = NULL, amat, verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dsepAM_+3A_x">X</code></td>
<td>
<p>Vector of column numbers of nodes <code>X</code> in the adjacency matrix</p>
</td></tr>
<tr><td><code id="dsepAM_+3A_y">Y</code></td>
<td>
<p>Vector of column numbers of nodes <code>Y</code> in the adjacency matrix</p>
</td></tr>
<tr><td><code id="dsepAM_+3A_s">S</code></td>
<td>
<p>Vector of column numbers of nodes <code>S</code> in the adjacency matrix (may be empty)</p>
</td></tr>
<tr><td><code id="dsepAM_+3A_amat">amat</code></td>
<td>
<p>The Maximal Ancestral Graph encoded as adjacency matrix 
of type <a href="#topic+amatType">amatType</a></p>
</td></tr>
<tr><td><code id="dsepAM_+3A_verbose">verbose</code></td>
<td>
<p>If true, more detailed output is provided.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function checks separation in the moralized graph as
explained in Richardson and Spirtes (2002).</p>


<h3>Value</h3>

<p>TRUE if <code>X</code> and <code>Y</code> are d-separated by <code>S</code> in the 
MAG encoded by <code>amat</code>, otherwise FALSE.
</p>


<h3>Author(s)</h3>

<p>Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>), Joris Mooij
</p>


<h3>References</h3>

<p>T.S. Richardson and P. Spirtes (2002). Ancestral graph Markov models.
<em>Annals of Statistics</em> <b>30</b> 962-1030.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dsepAMTest">dsepAMTest</a></code> for a wrapper of this function that can
easily be included into <code><a href="#topic+skeleton">skeleton</a></code>, <code><a href="#topic+fci">fci</a></code> or
<code><a href="#topic+fciPlus">fciPlus</a></code>. <code><a href="#topic+dsep">dsep</a></code> for a similar function for DAGs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Y-structure MAG
# Encode as adjacency matrix
p &lt;- 4 # total number of variables
V &lt;- c("X1","X2","X3","X4") # variable labels
# amat[i,j] = 0 iff no edge btw i,j
# amat[i,j] = 1 iff i *-o j
# amat[i,j] = 2 iff i *-&gt; j
# amat[i,j] = 3 iff i *-- j
amat &lt;- rbind(c(0,0,2,0),
              c(0,0,2,0),
              c(3,3,0,2),
              c(0,0,3,0))
rownames(amat)&lt;-V
colnames(amat)&lt;-V

## d-separated
cat('X1 d-separated from X2? ', dsepAM(1,2,S=NULL,amat),'\n')
## not d-separated given node 3
cat('X1 d-separated from X2 given X4? ', dsepAM(1,2,S=4,amat),'\n')
## not d-separated by node 3 and 4
cat('X1 d-separated from X2 given X3 and X4? ', dsepAM(1,2,S=c(3,4),amat),'\n') 
</code></pre>

<hr>
<h2 id='dsepAMTest'>Test for d-separation in a MAG</h2><span id='topic+dsepAMTest'></span>

<h3>Description</h3>

<p>This function tests for d-separation (also known as m-separation) of node <code>x</code> and node <code>y</code> given nodes <code>S</code> in a MAG.
<code>dsepAMTest()</code> is written to be easily used in <code><a href="#topic+skeleton">skeleton</a></code>, <code><a href="#topic+fci">fci</a></code>,
<code><a href="#topic+fciPlus">fciPlus</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsepAMTest(x, y, S = NULL, suffStat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dsepAMTest_+3A_x">x</code></td>
<td>
<p>Column number of node <code>x</code> in the adjacency matrix</p>
</td></tr>
<tr><td><code id="dsepAMTest_+3A_y">y</code></td>
<td>
<p>Column number of node <code>y</code> in the adjacency matrix</p>
</td></tr>
<tr><td><code id="dsepAMTest_+3A_s">S</code></td>
<td>
<p>Vector of column numbers of nodes <code>S</code> in the adjacency
matrix, may be empty</p>
</td></tr>
<tr><td><code id="dsepAMTest_+3A_suffstat">suffStat</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> with two elements,
</p>

<dl>
<dt>amat</dt><dd><p>The Maximal Ancestral Graph encoded as adjacency matrix 
of type <a href="#topic+amatType">amatType</a></p>
</dd>
<dt>verbose</dt><dd><p>If true, more detailed output is provided.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is a wrapper for <code><a href="#topic+dsepAM">dsepAM</a></code>, which checks
separation in the moralized graph as explained in Richardson and Spirtes (2002).
</p>


<h3>Value</h3>

<p>Returns 1 if <code>x</code> and <code>y</code> are d-separated by <code>S</code> in the 
MAG encoded by <code>amat</code>, otherwise 0.
</p>
<p>This is analogous to the p-value of an ideal
(without sampling error) conditional independence test on any
distribution that is faithful to the MAG.
</p>


<h3>Author(s)</h3>

<p>Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>), Joris Mooij
</p>


<h3>References</h3>

<p>T.S. Richardson and P. Spirtes (2002). Ancestral graph Markov models.
<em>Annals of Statistics</em> <b>30</b> 962-1030.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dsepTest">dsepTest</a></code> for a similar function for DAGs.
<code><a href="#topic+gaussCItest">gaussCItest</a></code>, <code><a href="#topic+disCItest">disCItest</a></code> and
<code><a href="#topic+binCItest">binCItest</a></code> for similar functions for a conditional
independence test for gaussian, discrete and
binary variables, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Y-structure MAG
# Encode as adjacency matrix
p &lt;- 4 # total number of variables
V &lt;- c("X1","X2","X3","X4") # variable labels
# amat[i,j] = 0 iff no edge btw i,j
# amat[i,j] = 1 iff i *-o j
# amat[i,j] = 2 iff i *-&gt; j
# amat[i,j] = 3 iff i *-- j
amat &lt;- rbind(c(0,0,2,0),
              c(0,0,2,0),
              c(3,3,0,2),
              c(0,0,3,0))
rownames(amat)&lt;-V
colnames(amat)&lt;-V

suffStat&lt;-list(g=amat,verbose=FALSE)
## d-separated
cat('X1 d-separated from X2? ', dsepAMTest(1,2,S=NULL,suffStat),'\n')
## not d-separated given node 3
cat('X1 d-separated from X2 given X4? ',
dsepAMTest(1,2,S=4,suffStat),'\n')
## not d-separated by node 3 and 4
cat('X1 d-separated from X2 given X3 and X4? ', dsepAMTest(1,2,S=c(3,4),
suffStat),'\n')

# Derive PAG that represents the Markov equivalence class of the MAG with the FCI algorithm
# Make use of d-separation oracle as "independence test"
indepTest &lt;- dsepAMTest
fci.pag &lt;- fci(suffStat,indepTest,alpha = 0.5,labels = V,verbose=FALSE)
cat('True MAG:\n')
print(amat)
cat('PAG output by FCI:\n')
print(fci.pag@amat)
</code></pre>

<hr>
<h2 id='dsepTest'>Test for d-separation in a DAG</h2><span id='topic+dsepTest'></span>

<h3>Description</h3>

<p>Tests for d-separation of nodes in a DAG.  <code>dsepTest()</code> is
written to be easily used in <code><a href="#topic+skeleton">skeleton</a></code>, <code><a href="#topic+pc">pc</a></code>,
<code><a href="#topic+fci">fci</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsepTest(x, y, S=NULL, suffStat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dsepTest_+3A_x">x</code>, <code id="dsepTest_+3A_y">y</code></td>
<td>
<p>(integer) position of variable <code class="reqn">X</code> and <code class="reqn">Y</code>,
respectively, in the adjacency matrix.</p>
</td></tr>
<tr><td><code id="dsepTest_+3A_s">S</code></td>
<td>
<p>(integer) positions of zero or more conditioning variables in the
adjacency matrix.</p>
</td></tr>
<tr><td><code id="dsepTest_+3A_suffstat">suffStat</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> with two elements,
</p>

<dl>
<dt><code>"g"</code></dt><dd><p>Containing the Directed Acyclic Graph (object of
<code><a href="base.html#topic+class">class</a></code> <code>"graph"</code>, see
<code><a href="graph.html#topic+graph-class">graph-class</a></code> from the package <span class="pkg">graph</span>), and</p>
</dd>
<dt><code>"jp"</code></dt><dd><p>Containing the shortest path distance
matrix for all pairs of nodes as computed by
<code><a href="RBGL.html#topic+johnson.all.pairs.sp">johnson.all.pairs.sp</a></code> from package
<span class="pkg">RBGL</span>.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is based on <code><a href="#topic+dsep">dsep</a></code>.  For details on
d-separation see the reference Lauritzen (2004).
</p>


<h3>Value</h3>

<p>If x and y are d-separated by S in DAG G the result is 1,
otherwise it is 0.  This is analogous to the p-value of an ideal
(without sampling error) conditional independence test on any
distribution that is faithful to the DAG G.
</p>


<h3>Author(s)</h3>

<p>Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>)
</p>


<h3>References</h3>

<p>S.L. Lauritzen (2004),
Graphical Models, <em>Oxford University Press</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dsepAMTest">dsepAMTest</a></code> for a similar function for MAGs.
<code><a href="#topic+gaussCItest">gaussCItest</a></code>, <code><a href="#topic+disCItest">disCItest</a></code> and
<code><a href="#topic+binCItest">binCItest</a></code> for similar functions for a conditional
independence test for gaussian, discrete and
binary variables, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- 8
set.seed(45)
myDAG &lt;- randomDAG(p, prob = 0.3)

if (require(Rgraphviz)) {
## plot the DAG
plot(myDAG, main = "randomDAG(10, prob = 0.2)")
}

## define sufficient statistics (d-separation oracle)
suffStat &lt;- list(g = myDAG, jp = RBGL::johnson.all.pairs.sp(myDAG))

dsepTest(1,6, S= NULL,  suffStat) ## not d-separated
dsepTest(1,6, S= 3,     suffStat) ## not d-separated by node 3
dsepTest(1,6, S= c(3,4),suffStat) ## d-separated by node 3 and 4
</code></pre>

<hr>
<h2 id='EssGraph-class'>Class <code>"EssGraph"</code></h2><span id='topic+EssGraph-class'></span><span id='topic+plot+2CEssGraph+2CANY-method'></span>

<h3>Description</h3>

<p>This class represents an (observentional or interventional) essential graph.
</p>


<h3>Details</h3>

<p>An observational or interventional Markov equivalence class of DAGs can be
uniquely represented by a partially directed graph, the essential
graph.  Its edges have the following interpretation:
</p>

<ol>
<li><p> a directed edge <code class="reqn">a \longrightarrow b</code> stands for an arrow
that has the same orientation in all representatives of the
Markov equivalence class;
</p>
</li>
<li><p> an undirected edge <code class="reqn">a - b</code> stands for an arrow that is oriented in one
way in some representatives of the equivalence class and in the other way
in other representatives of the equivalence class.
</p>
</li></ol>



<h3>Extends</h3>

<p>All reference classes extend and inherit methods from
<code>"<a href="methods.html#topic+envRefClass-class">envRefClass</a>"</code>.
</p>


<h3>Constructor</h3>

<p><code>new("EssGraph", nodes, in.edges, ...)</code>
</p>

<dl>
<dt><code>nodes</code></dt><dd><p>Vector of node names; cf. also field <code>.nodes</code>.</p>
</dd>
<dt><code>in.edges</code></dt><dd><p>A list of length <code>p</code> consisting of index
vectors indicating the edges pointing into the nodes of the DAG.</p>
</dd>
</dl>



<h3>Fields</h3>


<dl>
<dt><code>.nodes</code>:</dt><dd><p>Vector of node names; defaults to <code>as.character(1:p)</code>,
where <code>p</code> denotes the number of nodes (variables) of the model.</p>
</dd>
<dt><code>.in.edges</code>:</dt><dd><p>A list of length <code>p</code> consisting of index
vectors indicating the edges pointing into the nodes of the DAG.</p>
</dd>
<dt><code>targets</code></dt><dd><p>List of mutually exclusive intervention targets
with respect to which Markov equivalence is defined.</p>
</dd>
<dt><code>score</code>:</dt><dd><p>Object of class <code><a href="#topic+Score-class">Score</a></code>; used
internally for score-based causal inference.</p>
</dd>
</dl>



<h3>Class-Based Methods</h3>

<p>Most class-based methods are only for internal use.  Methods of interest for
the user are:
</p>

<dl>
<dt><code>repr()</code>:</dt><dd><p>Yields a representative causal model of the
equivalence class, an object of a class derived from
<code><a href="#topic+Score-class">Score</a></code>.  Since the representative is not only
characterized by the DAG, but also by appropriate parameters, the field
<code>score</code> must be assigned for this method to work.  The DAG is
drawn at random; note that all representatives are statistically
indistinguishable under a given set of intervention targets.</p>
</dd>
<dt><code>node.count()</code>:</dt><dd><p>Yields the number of nodes of the essential
graph.</p>
</dd>
<dt><code>edge.count()</code>:</dt><dd><p>Yields the number of edges of the essential
graph.  Note that <em>unoriented</em> edges count as 2, whereas
<em>oriented</em> edges count as 1 due to the internal representation.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>plot</dt><dd><p><code>signature(x = "EssGraph", y = "ANY")</code>: plots the
essential graph.  In the plot, undirected and bidirected edges are equivalent.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Alain Hauser (<a href="mailto:alain.hauser@bfh.ch">alain.hauser@bfh.ch</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ParDAG-class">ParDAG</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("EssGraph")
</code></pre>

<hr>
<h2 id='fci'>Estimate a PAG with the FCI Algorithm</h2><span id='topic+fci'></span>

<h3>Description</h3>

<p>Estimate a Partial Ancestral Graph (PAG) from observational data, using
the FCI (Fast Causal Inference) algorithm, or from a combination of 
data from different (e.g., observational and interventional) contexts, 
using the FCI-JCI (Joint Causal Inference) extension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fci(suffStat, indepTest, alpha, labels, p,
    skel.method = c("stable", "original", "stable.fast"),
    type = c("normal", "anytime", "adaptive"),
    fixedGaps = NULL, fixedEdges = NULL,
    NAdelete = TRUE, m.max = Inf, pdsep.max = Inf,
    rules = rep(TRUE, 10), doPdsep = TRUE, biCC = FALSE,
    conservative = FALSE, maj.rule = FALSE,
    numCores = 1, selectionBias = TRUE,
    jci = c("0","1","12","123"), contextVars = NULL, 
    verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fci_+3A_suffstat">suffStat</code></td>
<td>
<p>sufficient statistics: A named <code><a href="base.html#topic+list">list</a></code>
containing all necessary elements for the conditional independence
decisions in the function <code>indepTest</code>.</p>
</td></tr>
<tr><td><code id="fci_+3A_indeptest">indepTest</code></td>
<td>
<p>a <code><a href="base.html#topic+function">function</a></code> for testing conditional
independence.  The function is internally called as
<code>indepTest(x,y, S, suffStat)</code>, and tests conditional independence
of <code>x</code> and <code>y</code> given <code>S</code>.  Here, <code>x</code> and
<code>y</code> are variables, and <code>S</code> is a (possibly empty) vector of
variables (all variables are denoted by their column numbers
in the adjacency matrix). <code>suffStat</code> is a list with all
relevant information, see above.  The return value of
<code>indepTest()</code> is the p-value of the test for conditional
independence.</p>
</td></tr>
<tr><td><code id="fci_+3A_alpha">alpha</code></td>
<td>
<p>numeric significance level (in <code class="reqn">(0, 1)</code>) for the
individual conditional independence tests.</p>
</td></tr>
<tr><td><code id="fci_+3A_labels">labels</code></td>
<td>
<p>(optional) <code><a href="base.html#topic+character">character</a></code> vector of variable (or
&ldquo;node&rdquo;) names.  Typically preferred to specifying <code>p</code>.</p>
</td></tr>
<tr><td><code id="fci_+3A_p">p</code></td>
<td>
<p>(optional) number of variables (or nodes).  May be specified
if <code>labels</code> are not, in which case <code>labels</code> is set to
<code>1:p</code>.</p>
</td></tr>
<tr><td><code id="fci_+3A_skel.method">skel.method</code></td>
<td>
<p>character string specifying method; the default,
<code>"stable"</code> provides an <em>order-independent</em> skeleton, see
<code><a href="#topic+skeleton">skeleton</a></code>.</p>
</td></tr>
<tr><td><code id="fci_+3A_type">type</code></td>
<td>
<p>character string specifying the version of the FCI
algorithm to be used.  By default, it is <code>"normal"</code>, and so the
normal FCI algorithm is called.  If set to <code>"anytime"</code>, the
&lsquo;Anytime FCI&rsquo; is called and <code>m.max</code> needs to be specified.
If set to <code>"adaptive"</code>, the &lsquo;Adaptive Anytime FCI&rsquo; is
called and <code>m.max</code> is not used.  For more information, see Details.</p>
</td></tr>
<tr><td><code id="fci_+3A_fixedgaps">fixedGaps</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> matrix of dimension p*p. If entry
<code>[i,j]</code> or <code>[j,i]</code> (or both) are TRUE, the edge i-j is
removed before starting the algorithm. Therefore, this edge is
guaranteed to be absent in the resulting graph.</p>
</td></tr>
<tr><td><code id="fci_+3A_fixededges">fixedEdges</code></td>
<td>
<p>logical matrix of dimension p*p. If entry
<code>[i,j]</code> or <code>[j,i]</code> (or both) are TRUE, the edge i-j is
never considered for removal. Therefore, this edge is
guaranteed to be present in the resulting graph.</p>
</td></tr>
<tr><td><code id="fci_+3A_nadelete">NAdelete</code></td>
<td>
<p>If indepTest returns <code>NA</code> and this option is
<code>TRUE</code>, the corresponding edge is deleted. If this option is
<code>FALSE</code>, the edge is not deleted.</p>
</td></tr>
<tr><td><code id="fci_+3A_m.max">m.max</code></td>
<td>
<p>Maximum size of the conditioning sets that are considered in the
conditional independence tests.</p>
</td></tr>
<tr><td><code id="fci_+3A_pdsep.max">pdsep.max</code></td>
<td>
<p>Maximum size of Possible-D-SEP for which subsets are
considered as conditioning sets in the conditional independence
tests. If the nodes <code>x</code> and <code>y</code> are adjacent in the graph
and the size of <code class="reqn">\textrm{Possible-D-SEP}(x) \setminus \{x, y\}</code> 
is
bigger than pdsep.max, the edge is simply left in the graph.
Note that if pdsep.max is less than Inf, the final PAG
may be a supergraph of the one computed with pdsep.max = Inf,
because fewer tests may have been performed in the former.</p>
</td></tr>
<tr><td><code id="fci_+3A_rules">rules</code></td>
<td>
<p>Logical vector of length 10 indicating which rules
should be used when directing edges. The order of the rules is taken
from Zhang (2008).</p>
</td></tr>
<tr><td><code id="fci_+3A_dopdsep">doPdsep</code></td>
<td>
<p>If <code>TRUE</code>, Possible-D-SEP is computed for all nodes,
and all subsets of Possible-D-SEP are considered as conditioning
sets in the conditional independence tests, if not defined otherwise
in <code>pdsep.max</code>. If <code>FALSE</code>, Possible-D-SEP
is not computed, so that the algorithm simplifies to the
Modified PC algorithm of Spirtes, Glymour and Scheines (2000, p.84).</p>
</td></tr>
<tr><td><code id="fci_+3A_bicc">biCC</code></td>
<td>
<p>If <code>TRUE</code>, only nodes on paths between nodes <code>x</code>
and <code>y</code> are considered to be in Possible-D-SEP(<code>x</code>) when
testing independence between <code>x</code> and <code>y</code>. Uses
biconnected components, <code><a href="RBGL.html#topic+biConnComp">biConnComp</a></code> from <span class="pkg">RBGL</span>.</p>
</td></tr>
<tr><td><code id="fci_+3A_conservative">conservative</code></td>
<td>
<p>Logical indicating if the unshielded triples
should be checked for ambiguity the second time when v-structures
are determined.  For more information, see details.</p>
</td></tr>
<tr><td><code id="fci_+3A_maj.rule">maj.rule</code></td>
<td>
<p>Logical indicating if the unshielded triples should
be checked for ambiguity the second time when v-structures are
determined using a majority rule idea, which is less strict than the
standard conservative.  For more information, see details.</p>
</td></tr>
<tr><td><code id="fci_+3A_numcores">numCores</code></td>
<td>
<p>Specifies the number of cores to be used for parallel
estimation of <code><a href="#topic+skeleton">skeleton</a></code>.</p>
</td></tr>
<tr><td><code id="fci_+3A_selectionbias">selectionBias</code></td>
<td>
<p>If <code>TRUE</code>, allow for selection bias. 
If <code>FALSE</code>, selection bias is excluded by assumption and hence 
rules R5-R7, as in Zhang (2008), are disabled.</p>
</td></tr>
<tr><td><code id="fci_+3A_jci">jci</code></td>
<td>
<p>String specifying the JCI assumptions that are used. 
It can be one of:
</p>

<dl>
<dt>&quot;0&quot;</dt><dd><p>No JCI assumption is made (default),</p>
</dd>
<dt>&quot;1&quot;</dt><dd><p>JCI assumption 1 (no system variable causes any context 
variable),</p>
</dd>
<dt>&quot;12&quot;</dt><dd><p>JCI assumptions 1 and 2 (no system variable causes any 
context variable, and no system variable is confounded with any 
context variable),</p>
</dd>
<dt>&quot;123&quot;</dt><dd><p>JCI assumptions 1, 2 and 3 (no system variable causes
any context variable, no system variable is confounded with any 
context variable, and all context variables are confounded but 
are not direct causes of each other).</p>
</dd>
</dl>

<p>For more information, see Mooij et al. (2020).
</p>
</td></tr>
<tr><td><code id="fci_+3A_contextvars">contextVars</code></td>
<td>
<p>Subset of variable indices {1,...,p} that will be 
treated as context variables in the JCI extension of FCI.</p>
</td></tr>
<tr><td><code id="fci_+3A_verbose">verbose</code></td>
<td>
<p>If true, more detailed output is provided.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a generalization of the PC algorithm (see <code><a href="#topic+pc">pc</a></code>),
in the sense that it allows arbitrarily many latent and selection variables.
Under the assumption that the data are faithful to a DAG that includes all
latent and selection variables, the FCI algorithm (Fast Causal Inference
algorithm) (Spirtes, Glymour and Scheines, 2000) estimates the Markov
equivalence class of MAGs that describe the conditional independence
relationships between the observed variables. Under the assumption that the
data are <code class="reqn">\sigma</code>-faithful to a simple (possibly cyclic) SCM that allows
for latent confounding (but selection bias is absent), the FCI algorithm
estimates the <code class="reqn">\sigma</code>-Markov equivalence class of the DMGs (directed
mixed graphs) that describe the causal relations between the observed
variables and the conditional independence relationships in the observed
distribution through <code class="reqn">\sigma</code>-separation (Mooij and Claassen, 2020).  The
FCI-JCI (Joint Causal Inference) extension allows the algorithm to combine
data from different contexts, for example, observational and different types
of interventional data (Mooij et al., 2020).
</p>
<p>FCI estimates a <b>partial ancestral graph</b> (<b>PAG</b>). The PAG
represents a Markov equivalence class of DAGs with latent and selection
variables in the acyclic case (Zhang, 2008), and a Markov equivalence class
of directed graphs with latent variables (but without selection variables) 
in the cyclic <code class="reqn">\sigma</code>-separation case. 
A PAG contains the following types of edges: o-o, o&ndash;, o-&gt;, &ndash;&gt;, &lt;-&gt;, &mdash;. 
The bidirected edges come from latent confounders,
and the undirected edges come from latent selection variables. The edges have
the following interpretation: (i) there is an edge between <code>x</code>
and <code>y</code> if and only if variables <code>x</code> and <code>y</code> are conditionally dependent
given S for all sets S consisting of all selection variables
and a subset of the observed variables (assuming the Markov property and
faithfulness); (ii) a tail <code>x --* y</code> at x on an edge between x and y means that
x is an ancestor of y or S; (iii) an arrowhead <code>x &lt;-* y</code> at x on an edge between 
x and y means that x is not an ancestor of y, nor of S;
(iv) a circle mark <code>x o-* y</code> at x on an edge between x and y means that there
exists both a graph in the Markov equivalence class where x is ancestor of
y or S, and one where x is not ancestor of y, nor of S. For further information 
on the interpretation of PAGs see e.g. (Zhang, 2008) and (Mooij and Claassen, 2020).
</p>
<p>The first part of the FCI algorithm is analogous to the PC algorithm. It
starts with a complete undirected graph and estimates an initial skeleton
using <code><a href="#topic+skeleton">skeleton</a>(*, method="stable")</code> which produces an
initial order-independent skeleton, see <code><a href="#topic+skeleton">skeleton</a></code> for
more details.  All edges of this skeleton are of
the form o-o.  Due to the presence of hidden variables, it is no longer
sufficient to consider only subsets of the neighborhoods of nodes <code>x</code>
and <code>y</code> to decide whether the edge <code>x o-o y</code> should be removed.
Therefore, the initial skeleton may contain some superfluous edges.
These edges are removed in the next step of the algorithm which
requires some orientations.  Therefore, the v-structures
are determined using the conservative method (see discussion on
<code>conservative</code> below).
</p>
<p>After the v-structures have been oriented, Possible-D-SEP sets for each
node in the graph are computed at once. To decide whether edge
<code>x o-o y</code> should be removed, one performs conditional indepedence
tests of x and y given all possible subsets of Possible-D-SEP(x) and
of Possible-D-SEP(y). The edge is removed if a conditional
independence is found. This produces a fully order-independent final
skeleton as explained in Colombo and Maathuis (2014). Subsequently,
the v-structures are newly determined on the final skeleton (using
information in sepset). Finally, as many as possible undetermined edge
marks (o) are determined using (a subset of) the 10 orientation rules
given by Zhang (2008).
</p>
<p>The &ldquo;Anytime FCI&rdquo; algorithm was introduced by Spirtes (2001).  It
can be viewed as a modification of the FCI algorithm that only performs
conditional independence tests up to and including order m.max when
finding the initial skeleton, using the function <code>skeleton</code>, and
the final skeleton, using the function <code>pdsep</code>.  Thus, Anytime FCI
performs fewer conditional independence tests than FCI.  To use the
Anytime algorithm, one sets <code>type = "anytime"</code> and needs to
specify <code>m.max</code>, the maximum size of the conditioning sets.
</p>
<p>The &ldquo;Adaptive Anytime FCI&rdquo; algorithm was introduced by Colombo
et. al (2012).  The first part of the algorithm is identical to the normal
FCI described above.  But in the second part when the final skeleton is
estimated using the function <code><a href="#topic+pdsep">pdsep</a></code>, the Adaptive Anytime
FCI algorithm only performs conditional independence tests up to and
including order <code>m.max</code>, where m.max is the maximum size of the
conditioning sets that were considered to determine the initial
skeleton using the function <code>skeleton</code>.  Thus, m.max is chosen
adaptively and does not have to be specified by the user.
</p>
<p><em>Conservative</em> versions of FCI, Anytime FCI, and Adaptive Anytime FCI
are computed if <code>conservative = TRUE</code> is specified.  After the
final skeleton is computed, all potential
v-structures a-b-c are checked in the following way. We test whether a
and c are independent conditioning on any subset of the neighbors of a
or any subset of the neighbors of c. When a subset makes a and c
conditionally independent, we call it a separating set. If b is in no
such separating set or in all such separating sets, no further action
is taken and the normal version of the FCI, Anytime FCI, or Adaptive
Anytime FCI algorithm is continued. If, however, b is in only some
separating sets, the triple a-b-c is marked &lsquo;ambiguous&rsquo;. If a is
independent of c given some S in the skeleton (i.e., the edge a-c
dropped out), but a and c remain dependent given all subsets of
neighbors of either a or c, we will call all triples a-b-c
&lsquo;unambiguous&rsquo;. This is because in the FCI algorithm, the true separating set
might be outside the neighborhood of either a or c. An ambiguous
triple is not oriented as a v-structure. Furthermore, no further
orientation rule that needs to know whether a-b-c is a v-structure or
not is applied. Instead of using the conservative version, which is
quite strict towards the v-structures, Colombo and Maathuis (2014)
introduced a less strict version for the v-structures called majority
rule. This adaptation can be called using <code>maj.rule = TRUE</code>. In
this case, the triple a-b-c is marked as &lsquo;ambiguous&rsquo; if and only if b
is in exactly 50 percent of such separating sets or no separating set
was found. If b is in less than 50 percent of the separating sets it
is set as a v-structure, and if in more than 50 percent it is set as a
non v-structure (for more details see Colombo and Maathuis,
2014). Colombo and Maathuis (2014) showed that with both these
modifications, the final skeleton and the decisions about the
v-structures of the FCI algorithm are fully order-independent.
Note that the order-dependence issues on the 10 orientation rules are
still present, see Colombo and Maathuis (2014) for more details.
</p>
<p>The FCI-JCI extension of FCI was introduced by Mooij et. al (2020).  It is an
implementation of the <em>Joint Causal Inference</em> (JCI) framework that
reduces causal discovery from several data sets corresponding to different
contexts (e.g., observational and different interventional settings, or data
measured in different labs or in different countries) to causal discovery
from the pooled data (treated as a single 'observational' data set). Two
types of variables are distinguished in the JCI framework: system variables
(describing aspects of the system in some environment) and context variables
(describing aspects of the environment of the system). Different 
assumptions regarding the causal relations between context variables and
system variables can be made. The most common assumption (JCI Assumption 1:
'exogeneity') is that no system variable can affect any context variable.
The second, less common, assumption (JCI Assumption 2: 'complete randomized
context') is that there is no latent confounding between system and context.
The third assumption (JCI Assumption 3: 'generic context model') is in fact
a faithfulness assumption on the context distribution. The FCI-JCI extension
can be used by specifying the subset of the variables that are designated as
context variables with the <code>contextVars</code> argument, and by specifying
the combination of JCI assumptions that is used with the <code>jci</code> argument.
For the default values of these arguments, the JCI extension is not used.
The only difference between the FCI-JCI extension and the standard FCI 
algorithm is that the background knowledge about the PAG implied by the
JCI assumptions is exploited at several points in the FCI-JCI algorithm to
enforce adjacencies between context variables (in case of JCI Assumption 3) 
and to orient certain edges adjacent to context variables (in case of JCI
Assumptions 1, 2 or 3).
The current JCI framework assumes that no selection bias is present, and
therefore the FCI-JCI extension should be called with 
<code>selectionBias = FALSE</code>. For more details on FCI-JCI, and the general
JCI framework, see Mooij et al. (2020).
</p>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> <code>fciAlgo</code> (see
<code><a href="#topic+fciAlgo-class">fciAlgo</a></code>) containing the estimated graph
(in the form of an adjacency matrix with various possible edge marks),
the conditioning sets that lead to edge removals (sepset) and several other
parameters.
</p>


<h3>Author(s)</h3>

<p>Diego Colombo, Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>)
and Joris Mooij.
</p>


<h3>References</h3>

<p>D. Colombo and M.H. Maathuis (2014). Order-independent
constraint-based causal structure learning. <em>Journal of Machine
Learning Research</em> 15 3741-3782. 
</p>
<p>D. Colombo, M. H. Maathuis, M. Kalisch, T. S. Richardson
(2012). Learning high-dimensional directed acyclic graphs with latent
and selection variables. <em>Ann. Statist.</em> <b>40</b>, 294-321.
</p>
<p>M.Kalisch, M. Maechler, D. Colombo, M. H. Maathuis,
P. Buehlmann (2012). Causal Inference Using Graphical Models with
the R Package pcalg. <em>Journal of Statistical Software</em>
<b>47(11)</b> 1&ndash;26, <a href="https://doi.org/10.18637/jss.v047.i11">doi:10.18637/jss.v047.i11</a>.
</p>
<p>J. M. Mooij, S. Magliacane, T. Claassen (2020).
Joint Causal Inference from Multiple Contexts.
<em>Journal of Machine Learning Research</em> <b>21</b>(99), 1-108.
</p>
<p>J. M. Mooij and T. Claassen (2020).
Constraint-Based Causal Discovery using Partial Ancestral Graphs in the presence of Cycles.
<em>In Proc. of the 36th Conference on Uncertainty in Artificial Intelligence (UAI-20)</em>, 1159-1168.
</p>
<p>P. Spirtes (2001). An anytime algorithm for causal inference. <em>In
Proc. of the Eighth International Workshop on Artificial Intelligence
and Statistics</em> 213-221. Morgan Kaufmann, San Francisco.
</p>
<p>P. Spirtes, C. Glymour and R. Scheines (2000).
<em>Causation, Prediction, and Search</em>, 2nd edition, MIT Press,
Cambridge (MA).
</p>
<p>P. Spirtes, C. Meek, T.S. Richardson (1999). In: <em>Computation,
Causation and Discovery</em>. An algorithm for causal
inference in the presence of latent variables and selection bias.
Pages 211-252. MIT Press.
</p>
<p>T.S. Richardson and P. Spirtes (2002). Ancestral graph Markov models.
<em>Annals of Statistics</em> <b>30</b> 962-1030.
</p>
<p>J. Zhang (2008). On the completeness of orientation rules for
causal discovery in the presence of latent confounders and selection bias.
<em>Artificial Intelligence</em> <b>172</b> 1873-1896.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fciPlus">fciPlus</a></code> for a more efficient variation of FCI;
<code><a href="#topic+skeleton">skeleton</a></code> for estimating a skeleton 
using the PC algorithm; <code><a href="#topic+pc">pc</a></code> for estimating a CPDAG using
the PC algorithm; <code><a href="#topic+pdsep">pdsep</a></code> for computing
Possible-D-SEP for each node and testing and adapting the graph
accordingly; <code><a href="#topic+qreach">qreach</a></code> for a fast way of finding Possible-D-SEP
for a given node.
</p>
<p><code><a href="#topic+gaussCItest">gaussCItest</a></code>, <code><a href="#topic+disCItest">disCItest</a></code>,
<code><a href="#topic+binCItest">binCItest</a></code>, <code><a href="#topic+dsepTest">dsepTest</a></code> and <code><a href="#topic+dsepAMTest">dsepAMTest</a></code> 
as examples for <code>indepTest</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################################################
## Example without latent variables
##################################################

set.seed(42)
p &lt;- 7
## generate and draw random DAG :
myDAG &lt;- randomDAG(p, prob = 0.4)

## find skeleton and PAG using the FCI algorithm
suffStat &lt;- list(C = cov2cor(trueCov(myDAG)), n = 10^9)
res &lt;- fci(suffStat, indepTest=gaussCItest,
           alpha = 0.9999, p=p, doPdsep = FALSE)


##################################################
## Example with hidden variables
## Zhang (2008), Fig. 6, p.1882
##################################################

## create the graph g
p &lt;- 4
L &lt;- 1 # '1' is latent
V &lt;- c("Ghost", "Max","Urs","Anna","Eva")
edL &lt;- setNames(vector("list", length=length(V)), V)
edL[[1]] &lt;- list(edges=c(2,4),weights=c(1,1))
edL[[2]] &lt;- list(edges=3,weights=c(1))
edL[[3]] &lt;- list(edges=5,weights=c(1))
edL[[4]] &lt;- list(edges=5,weights=c(1))
g &lt;- new("graphNEL", nodes=V, edgeL=edL, edgemode="directed")

## compute the true covariance matrix of g
cov.mat &lt;- trueCov(g)

## delete rows and columns belonging to latent variable L
true.cov &lt;- cov.mat[-L,-L]
## transform covariance matrix into a correlation matrix
true.corr &lt;- cov2cor(true.cov)

## The same, for the following three examples
indepTest &lt;- gaussCItest
suffStat &lt;- list(C = true.corr, n = 10^9)

## find PAG with FCI algorithm.
## As dependence "oracle", we use the true correlation matrix in
## gaussCItest() with a large "virtual sample size" and a large alpha:

normal.pag &lt;- fci(suffStat, indepTest, alpha = 0.9999, labels = V[-L],
                  verbose=TRUE)


## find PAG with Anytime FCI algorithm with m.max = 1
## This means that only conditioning sets of size 0 and 1 are considered.
## As dependence "oracle", we use the true correlation matrix in the
## function gaussCItest with a large "virtual sample size" and a large
## alpha
anytime.pag &lt;- fci(suffStat, indepTest, alpha = 0.9999, labels = V[-L],
                   type = "anytime", m.max = 1,
                   verbose=TRUE)

## find PAG with Adaptive Anytime FCI algorithm.
## This means that only conditining sets up to size K are considered
## in estimating the final skeleton, where K is the maximal size of a
## conditioning set found while estimating the initial skeleton.
## As dependence "oracle", we use the true correlation matrix in the
## function gaussCItest with a large "virtual sample size" and a large
## alpha
adaptive.pag &lt;- fci(suffStat, indepTest, alpha = 0.9999, labels = V[-L],
                    type = "adaptive",
                    verbose=TRUE)

## define PAG given in Zhang (2008), Fig. 6, p.1882
corr.pag &lt;- rbind(c(0,1,1,0),
                  c(1,0,0,2),
                  c(1,0,0,2),
                  c(0,3,3,0))

## check if estimated and correct PAG are in agreement
all(corr.pag == normal.pag  @ amat) # TRUE
all(corr.pag == anytime.pag @ amat) # FALSE
all(corr.pag == adaptive.pag@ amat) # TRUE
ij &lt;- rbind(cbind(1:4,1:4), c(2,3), c(3,2))
all(corr.pag[ij] == anytime.pag @ amat[ij]) # TRUE



##################################################
## Joint Causal Inference Example
## Mooij et al. (2020), Fig. 43(a), p. 97
##################################################

# Encode MAG as adjacency matrix
p &lt;- 8 # total number of variables
V &lt;- c("Ca","Cb","Cc","X0","X1","X2","X3","X4") # 3 context variables, 5 system variables
# amat[i,j] = 0 iff no edge btw i,j
# amat[i,j] = 1 iff i *-o j
# amat[i,j] = 2 iff i *-&gt; j
# amat[i,j] = 3 iff i *-- j
amat &lt;- rbind(c(0,2,2,2,0,0,0,0),
              c(2,0,2,0,2,0,0,0),
              c(2,2,0,0,2,2,0,0),
              c(3,0,0,0,0,0,2,0),
              c(0,3,3,0,0,3,0,2),
              c(0,0,3,0,2,0,0,0),
              c(0,0,0,3,0,0,0,2),
              c(0,0,0,0,2,0,3,0))
rownames(amat)&lt;-V
colnames(amat)&lt;-V

# Make use of d-separation oracle as "independence test"
indepTest &lt;- dsepAMTest
suffStat&lt;-list(g=amat,verbose=FALSE)

# Derive PAG that represents the Markov equivalence class of the MAG with the FCI algorithm
# (assuming no selection bias)
fci.pag &lt;- fci(suffStat, indepTest, alpha = 0.5, labels = V,
verbose=TRUE, selectionBias=FALSE)

# Derive PAG with FCI-JCI, the Joint Causal Inference extension of FCI
# (assuming no selection bias, and all three JCI assumptions)
fcijci.pag &lt;- fci(suffStat, indepTest, alpha = 0.5, labels = V,
verbose=TRUE, contextVars=c(1,2,3), jci="123", selectionBias=FALSE)

# Report results
cat('True MAG:\n')
print(amat)
cat('PAG output by FCI:\n')
print(fci.pag@amat)
cat('PAG output by FCI-JCI:\n')
print(fcijci.pag@amat)

# Read off causal features from the FCI PAG
cat('Identified absence (-1) and presence (+1) of ancestral causal relations from FCI PAG:\n')
print(pag2anc(fci.pag@amat))
cat('Identified absence (-1) and presence (+1) of direct causal relations from FCI PAG:\n')
print(pag2edge(fci.pag@amat))
cat('Identified absence (-1) and presence (+1) of pairwise latent confounding from FCI PAG:\n')
print(pag2conf(fci.pag@amat))

# Read off causal features from the FCI-JCI PAG
cat('Identified absence (-1) and presence (+1) of ancestral causal relations from FCI-JCI PAG:\n')
print(pag2anc(fcijci.pag@amat))
cat('Identified absence (-1) and presence (+1) of direct causal relations from FCI-JCI PAG:\n')
print(pag2edge(fcijci.pag@amat))
cat('Identified absence (-1) and presence (+1) of pairwise latent confounding from FCI-JCI PAG:\n')
print(pag2conf(fcijci.pag@amat))

</code></pre>

<hr>
<h2 id='fciAlgo-class'>Class &quot;fciAlgo&quot; of FCI Algorithm Results</h2><span id='topic+fciAlgo-class'></span><span id='topic+plot+2CfciAlgo+2CANY-method'></span><span id='topic+show+2CfciAlgo-method'></span><span id='topic+summary+2CfciAlgo-method'></span><span id='topic+print.fciAlgo'></span>

<h3>Description</h3>

<p>This class of objects is returned by functions
<code><a href="#topic+fci">fci</a>()</code>, <code><a href="#topic+rfci">rfci</a>()</code>, <code><a href="#topic+fciPlus">fciPlus</a></code>, and
<code><a href="#topic+dag2pag">dag2pag</a></code> and represent the estimated PAG (and sometimes
properties of the algorithm).
Objects of this class have methods for the functions
<code><a href="graphics.html#topic+plot">plot</a></code>, <code><a href="methods.html#topic+show">show</a></code> and <code><a href="base.html#topic+summary">summary</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S4 method for signature 'fciAlgo'
show(object)
## S3 method for class 'fciAlgo'
print(x, amat = FALSE, zero.print = ".", ...)

## S4 method for signature 'fciAlgo'
summary(object, amat = TRUE, zero.print = ".", ...)
## S4 method for signature 'fciAlgo,ANY'
plot(x, y, main = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fciAlgo-class_+3A_x">x</code>, <code id="fciAlgo-class_+3A_object">object</code></td>
<td>
<p>a <code>"fciAlgo"</code> object.</p>
</td></tr>
<tr><td><code id="fciAlgo-class_+3A_amat">amat</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating if the adjacency matrix
should be shown (printed) as well.</p>
</td></tr>
<tr><td><code id="fciAlgo-class_+3A_zero.print">zero.print</code></td>
<td>
<p>string for printing <code>0</code> (&lsquo;zero&rsquo;) entries
in the adjacency matrix.</p>
</td></tr>
<tr><td><code id="fciAlgo-class_+3A_y">y</code></td>
<td>
<p>(generic <code>plot()</code> argument; unused).</p>
</td></tr>
<tr><td><code id="fciAlgo-class_+3A_main">main</code></td>
<td>
<p>main title, not yet supported.</p>
</td></tr>
<tr><td><code id="fciAlgo-class_+3A_...">...</code></td>
<td>
<p>optional further arguments (passed from and to methods).</p>
</td></tr>
</table>


<h3>Slots</h3>

<p>The slots <code>call</code>, <code>n</code>, <code>max.ord</code>, <code>n.edgetests</code>,
<code>sepset</code>, and <code>pMax</code> are inherited from class
<code>"<a href="#topic+gAlgo-class">gAlgo</a>"</code>, see there.
</p>
<p>In addition, <code>"fciAlgo"</code> has slots
</p>

<dl>
<dt><code>amat</code>:</dt><dd><p>adjacency matrix; for the coding of the
adjacency matrix see <a href="#topic+amatType">amatType</a></p>
</dd>
<dt><code>allPdsep</code></dt><dd><p>a <code><a href="base.html#topic+list">list</a></code>: the ith entry of
this list contains Possible D-SEP of node number <code>i</code>.</p>
</dd>
<dt><code>n.edgetestsPDSEP</code></dt><dd><p>the number of new conditional
independence tests (i.e., tests that were not done in the first
part of the algorithm) that were performed while checking subsets
of Possible D-SEP.</p>
</dd>
<dt><code>max.ordPDSEP</code></dt><dd><p>an <code><a href="base.html#topic+integer">integer</a></code>: the maximum
size of the conditioning sets used in the new conditional independence
that were performed when checking subsets of Possible D-SEP.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+gAlgo-class">gAlgo</a>"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>plot</dt><dd><p><code>signature(x = "fciAlgo")</code>: Plot the resulting graph</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "fciAlgo")</code>: Show basic properties of
the fitted object</p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "fciAlgo")</code>: Show details of
the fitted object </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Markus Kalisch and Martin Maechler</p>


<h3>See Also</h3>

<p><code><a href="#topic+fci">fci</a></code>, <code><a href="#topic+fciPlus">fciPlus</a></code>, etc (see above);
<code><a href="#topic+pcAlgo-class">pcAlgo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## look at slots of the class
showClass("fciAlgo")

## Also look at the extensive examples in ?fci , ?fciPlus, etc !

## Not run: 
## Suppose, fciObj is an object of class fciAlgo
## access slots by using the @ symbol
fciObj@amat   ## adjacency matrix
fciObj@sepset ## separation sets

## use show, summary and plot method
fciObj ## same as  show(fciObj)
show(fciObj)
summary(fciObj)
plot(fciObj)

## End(Not run)
</code></pre>

<hr>
<h2 id='fciPlus'>Estimate a PAG with the FCI+ Algorithm</h2><span id='topic+fciPlus'></span>

<h3>Description</h3>

<p>Estimate a Partial Ancestral Graph (PAG) from observational data, using
the FCI+ (Fast Causal Inference) algorithm, or from a combination of
data from different (e.g., observational and interventional) contexts, 
using the FCI+-JCI (Joint Causal Inference) extension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fciPlus(suffStat, indepTest, alpha, labels, p, verbose=TRUE,
	selectionBias = TRUE, jci = c("0","1","12","123"), contextVars = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fciPlus_+3A_suffstat">suffStat</code></td>
<td>
<p>sufficient statistics: A named <code><a href="base.html#topic+list">list</a></code>
containing all necessary elements for the conditional independence
decisions in the function <code>indepTest</code>.</p>
</td></tr>
<tr><td><code id="fciPlus_+3A_indeptest">indepTest</code></td>
<td>
<p>a <code><a href="base.html#topic+function">function</a></code> for testing conditional
independence.  The function is internally called as
<code>indepTest(x,y, S, suffStat)</code>, and tests conditional independence
of <code>x</code> and <code>y</code> given <code>S</code>.  Here, <code>x</code> and
<code>y</code> are variables, and <code>S</code> is a (possibly empty) vector of
variables (all variables are denoted by their column numbers
in the adjacency matrix). <code>suffStat</code> is a list with all
relevant information, see above.  The return value of
<code>indepTest()</code> is the p-value of the test for conditional
independence.</p>
</td></tr>
<tr><td><code id="fciPlus_+3A_alpha">alpha</code></td>
<td>
<p>numeric significance level (in <code class="reqn">(0, 1)</code>) for the
individual conditional independence tests.</p>
</td></tr>
<tr><td><code id="fciPlus_+3A_labels">labels</code></td>
<td>
<p>(optional) <code><a href="base.html#topic+character">character</a></code> vector of variable (or
&ldquo;node&rdquo;) names.  Typically preferred to specifying <code>p</code>.</p>
</td></tr>
<tr><td><code id="fciPlus_+3A_p">p</code></td>
<td>
<p>(optional) number of variables (or nodes).  May be specified
if <code>labels</code> are not, in which case <code>labels</code> is set to
<code>1:p</code>.</p>
</td></tr>
<tr><td><code id="fciPlus_+3A_selectionbias">selectionBias</code></td>
<td>
<p>If <code>TRUE</code>, allow for selection bias. 
If <code>FALSE</code>, selection bias is excluded by assumption and hence 
rules R5-R7, as in Zhang (2008), are disabled.</p>
</td></tr>
<tr><td><code id="fciPlus_+3A_jci">jci</code></td>
<td>
<p>String specifying the JCI assumptions that are used. 
It can be one of:
</p>

<dl>
<dt>&quot;0&quot;</dt><dd><p>No JCI assumption is made (default),</p>
</dd>
<dt>&quot;1&quot;</dt><dd><p>JCI assumption 1 (no system variable causes any context 
variable),</p>
</dd>
<dt>&quot;12&quot;</dt><dd><p>JCI assumptions 1 and 2 (no system variable causes any 
context variable, and no system variable is confounded with any 
context variable),</p>
</dd>
<dt>&quot;123&quot;</dt><dd><p>JCI assumptions 1, 2 and 3 (no system variable causes
any context variable, no system variable is confounded with any 
context variable, and all context variables are confounded but 
are not direct causes of each other).</p>
</dd>
</dl>

<p>For more information, see Mooij et al. (2020).
</p>
</td></tr>
<tr><td><code id="fciPlus_+3A_contextvars">contextVars</code></td>
<td>
<p>Subset of variable indices {1,...,p} that will be 
treated as context variables in the JCI extension of FCI+.</p>
</td></tr>
<tr><td><code id="fciPlus_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating if progress of the algorithm should
be printed.  The default is true, which used to be hard coded previously.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A (possibly much faster) variation of FCI (Fast Causal Inference).  
For details, please see the references, and also <code><a href="#topic+fci">fci</a></code>.
</p>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> <code>fciAlgo</code> (see
<code><a href="#topic+fciAlgo-class">fciAlgo</a></code>) containing the estimated graph
(in the form of an adjacency matrix with various possible edge marks),
the conditioning sets that lead to edge removals (sepset) and several other
parameters.
</p>


<h3>Author(s)</h3>

<p>Emilija Perkovic, Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>)
and Joris Mooij.
</p>


<h3>References</h3>

<p>T. Claassen, J. Mooij, and T. Heskes (2013).
Learning Sparse Causal Models is not NP-hard.
In <em>UAI 2013, Proceedings of the 29th Conference on Uncertainty in Artificial Intelligence</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fci">fci</a></code> for estimating a PAG using the FCI algorithm.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################################################
## Example without latent variables
##################################################

## generate a random DAG ( p = 7 )
set.seed(42)
p &lt;- 7
myDAG &lt;- randomDAG(p, prob = 0.4)

## find PAG using the FCI+ algorithm on "Oracle"
suffStat &lt;- list(C = cov2cor(trueCov(myDAG)), n = 10^9)
m.fci &lt;- fciPlus(suffStat, indepTest=gaussCItest,
                 alpha = 0.9999, p=p)
summary(m.fci)

## require("Rgraphviz")
sfsmisc::mult.fig(2, main="True DAG  //  fciPlus(.) \"oracle\" estimate")
plot(myDAG)
plot(m.fci)

##################################################
## Joint Causal Inference Example
## Mooij et al. (2020), Fig. 43(a), p. 97
##################################################

# Encode MAG as adjacency matrix
p &lt;- 8 # total number of variables
V &lt;- c("Ca","Cb","Cc","X0","X1","X2","X3","X4") # 3 context variables, 5 system variables
# amat[i,j] = 0 iff no edge btw i,j
# amat[i,j] = 1 iff i *-o j
# amat[i,j] = 2 iff i *-&gt; j
# amat[i,j] = 3 iff i *-- j
amat &lt;- rbind(c(0,2,2,2,0,0,0,0),
              c(2,0,2,0,2,0,0,0),
              c(2,2,0,0,2,2,0,0),
              c(3,0,0,0,0,0,2,0),
              c(0,3,3,0,0,3,0,2),
              c(0,0,3,0,2,0,0,0),
              c(0,0,0,3,0,0,0,2),
              c(0,0,0,0,2,0,3,0))
rownames(amat)&lt;-V
colnames(amat)&lt;-V

# Make use of d-separation oracle as "independence test"
indepTest &lt;- dsepAMTest
suffStat&lt;-list(g=amat,verbose=FALSE)

# Derive PAG that represents the Markov equivalence class of the MAG with the FCI+ algorithm
# (assuming no selection bias)
# fci.pag &lt;- fciPlus(suffStat, indepTest, alpha = 0.5, labels = V,
# selectionBias=FALSE,verbose=TRUE)

# Derive PAG with FCI+-JCI, the Joint Causal Inference extension of FCI
# (assuming no selection bias, and all three JCI assumptions)
# fcijci.pag &lt;- fciPlus(suffStat, indepTest, alpha = 0.5, labels = V,
# selectionBias=FALSE, contextVars=c(1,2,3), jci="123", verbose=TRUE)

# Report results
# cat('True MAG:\n')
# print(amat)
# cat('PAG output by FCI+:\n')
# print(fci.pag@amat)
# cat('PAG output by FCI+-JCI:\n')
# print(fcijci.pag@amat)

# Read off causal features from the FCI PAG
#cat('Identified absence (-1) and presence (+1) of ancestral causal relations from FCI+ PAG:\n')
#print(pag2anc(fci.pag@amat))
#cat('Identified absence (-1) and presence (+1) of direct causal relations from FCI+ PAG:\n')
#print(pag2edge(fci.pag@amat))
#cat('Identified absence (-1) and presence (+1) of pairwise latent confounding from FCI+ PAG:\n')
#print(pag2conf(fci.pag@amat))

# Read off causal features from the FCI-JCI PAG
#cat('Identified absence (-1) and presence (+1) of ancestral causal relations from FCI+-JCI PAG:\n')
#print(pag2anc(fcijci.pag@amat))
#cat('Identified absence (-1) and presence (+1) of direct causal relations from FCI+-JCI PAG:\n')
#print(pag2edge(fcijci.pag@amat))
#cat('Ident. absence (-1) and presence (+1) of pairwise latent confounding from FCI+-JCI PAG:\n')
#print(pag2conf(fcijci.pag@amat))
</code></pre>

<hr>
<h2 id='find.unsh.triple'>Find all Unshielded Triples in an Undirected Graph</h2><span id='topic+find.unsh.triple'></span>

<h3>Description</h3>

<p>Find all unshielded triples in an undirected graph, <code class="reqn">q</code>, i.e.,
the ordered (<code class="reqn">(x,y,z)</code> with <code class="reqn">x &lt; z</code>) list of all the triples
in the graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.unsh.triple(g, check=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find.unsh.triple_+3A_g">g</code></td>
<td>
<p>adjacency matrix of type <a href="#topic+amat.cpdag">amat.cpdag</a> representing the
skeleton; since a skeleton consists only of undirected edges, 
<code>g</code> must be symmetric.</p>
</td></tr>
<tr><td><code id="find.unsh.triple_+3A_check">check</code></td>
<td>
<p>logical indicating that the symmetry of <code>g</code> should
be checked.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A triple of nodes <code>x</code>, <code>y</code> and <code>z</code> is
&ldquo;unshielded&rdquo;, if (all of these are true): </p>

<dl>
<dt>(i)</dt><dd><p><code>x</code> and <code>y</code> are connected;</p>
</dd>
<dt>(ii)</dt><dd><p><code>y</code> and <code>z</code> are connected;</p>
</dd>
<dt>(iii)</dt><dd><p><code>x</code> and <code>z</code> are <b>not</b> connected.</p>
</dd>
</dl>



<h3>Value</h3>

<table>
<tr><td><code>unshTripl</code></td>
<td>
<p>Matrix with 3 rows containing in each column
an unshielded triple</p>
</td></tr>
<tr><td><code>unshVect</code></td>
<td>
<p>Vector containing the unique number  for
each column in unshTripl (for internal use only)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Diego Colombo, Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>), and
Martin Maechler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gmG)
if (require(Rgraphviz)) {
  ## show graph
  plot(gmG$g, main = "True DAG")
}

## prepare skeleton use in example
g &lt;- wgtMatrix(gmG$g) ## compute weight matrix
g &lt;- 1*(g != 0) # wgts --&gt; 0/1; still lower triangular
print.table(g, zero.print=".")
skel &lt;- g + t(g) ## adjacency matrix of skeleton

## estimate unshielded triples -- there are  13 :
(uTr &lt;- find.unsh.triple(skel))

</code></pre>

<hr>
<h2 id='gac'>Test If Set Satisfies Generalized Adjustment Criterion (GAC)</h2><span id='topic+gac'></span>

<h3>Description</h3>

<p>This function tests if <code>z</code> satisfies  the Generalized Adjustment
Criterion (GAC) relative to <code>(x,y)</code> in the graph represented by
adjacency matrix <code>amat</code> and interpreted as <code>type</code> (DAG,
maximal PDAG, CPDAG, MAG, PAG). If yes, <code>z</code> can be used in covariate adjustment
for estimating causal effects of <code>x</code> on <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gac(amat, x, y, z, type = "pag")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gac_+3A_amat">amat</code></td>
<td>
<p>adjacency matrix of type <a href="#topic+amat.cpdag">amat.cpdag</a> or <a href="#topic+amat.pag">amat.pag</a></p>
</td></tr>
<tr><td><code id="gac_+3A_x">x</code>, <code id="gac_+3A_y">y</code>, <code id="gac_+3A_z">z</code></td>
<td>
<p>(integer) positions of variables in <code>x</code>,
<code>y</code> or <code>z</code> in the adjacency matrix. <code>x</code>, <code>y</code> and
<code>z</code> can be vectors representing several nodes.</p>
</td></tr>
<tr><td><code id="gac_+3A_type">type</code></td>
<td>
<p>string specifying the type of graph of the adjacency matrix
<code>amat</code>.  It can be a DAG (type=&quot;dag&quot;), a PDAG (type=&quot;pdag&quot;) or a CPDAG (type=&quot;cpdag&quot;);
then the type of the adjacency matrix is assumed to be
<a href="#topic+amat.cpdag">amat.cpdag</a>. It can also be a MAG (type=&quot;mag&quot;), or a PAG
(type=&quot;pag&quot;); then the type of the adjacency matrix is assumed to be
<a href="#topic+amat.pag">amat.pag</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This work is a generalization of the work of Shpitser et al. (2012)
(necessary and sufficient criterion in DAGs/ADMGs)
and van der Zander et al. (2014) (necessary and sufficient criterion
in MAGs). Moreover, it is a generalization of the
Generalized Backdoor Criterion (GBC) of Maathuis and Colombo (2013):
While GBC is sufficient but not necessary, GAC is both sufficient and
necessary for DAGs, CPDAGs, MAGs and PAGs. For more details see
Perkovic et al. (2015, 2017a, 2017b).
</p>
<p>The motivation to find a set <code>z</code> that satisfies the GAC with
respect to <code>(x,y)</code> is the following:
</p>
<p><em>A set of variables <code>z</code> satisfies the GAC relative to
<code>(x,y)</code> in the given graph, if and only if
the causal effect of <code>x</code> on <code>y</code> is identifiable by
covariate adjustment and is given by</em>
</p>
<p style="text-align: center;"><code class="reqn">%
    P(Y|do(X = x)) = \sum_Z P(Y|X,Z) \cdot P(Z),</code>
</p>

<p>(for any joint distribution &ldquo;compatible&rdquo; with the graph; the formula
is for discrete variables with straightforward modifications for
continuous variables).
This result allows to write post-intervention densities (the one
written using Pearl's do-calculus) using only observational densities
estimated from the data.
</p>
<p>For <code>z</code> to satisfy the GAC relative to <code>(x,y)</code> and the graph, the
following three conditions must hold:
</p>

<dl>
<dt>(0)</dt><dd><p> The graph is adjustment amenable relative to <code>(x,y)</code>.</p>
</dd>
<dt>(1)</dt><dd><p> The intersection of <code>z</code> and the forbidden set
(explained in Perkovic et al. (2015, 2017b) is empty.</p>
</dd>
<dt>(2)</dt><dd><p> All proper definite status non-causal paths in the graph from
<code>x</code> to <code>y</code> are blocked by <code>z</code>.</p>
</dd>
</dl>

<p>It is important to note that there can be <code>x</code> and
<code>y</code> for which there is no set Z that satisfies the GAC, but the
total causal effect might be identifiable via some technique other
than covariate adjustment.
</p>
<p>For details on the GAC for DAGs, CPDAGs, PAGs see Perkovic et. al (2015,2017a). For details on the GAC for MAGs see van der Zander et. al (2014) and for details on the GAC for maximal PDAGs see Perkovic et. al (2017b).
</p>
<p>For the coding of the adjacency matrix see <a href="#topic+amatType">amatType</a>. The input
matrix can either be of class <code>matrix</code> or of class <code>amat</code>.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+list">list</a></code> with three components:
</p>
<table>
<tr><td><code>gac</code></td>
<td>
<p>logical; TRUE if <code>z</code> satisfies the GAC relative to
<code>(x,y)</code> in the graph represented by <code>amat</code> and <code>type</code></p>
</td></tr>
<tr><td><code>res</code></td>
<td>
<p>logical vector of length three indicating if each of the three
conditions (0), (1) and (2) are true</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>node positions of nodes in the forbidden set (see Perkovic
et al. (2015, 2017b)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Emilija Perkovic and Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>)</p>


<h3>References</h3>

<p>E. Perkovic, J. Textor, M. Kalisch and M.H. Maathuis (2015). A
Complete Generalized Adjustment Criterion. In <em>Proceedings of UAI
2015.</em>
</p>
<p>E. Perkovic, J. Textor, M. Kalisch and M.H. Maathuis (2017a). Complete graphical characterization and construction of adjustment sets in Markov equivalence classes of ancestral graphs. To appear in <em>Journal of Machine Learning Research.</em>
</p>
<p>E. Perkovic, M. Kalisch and M.H. Maathuis (2017b). Interpreting and using CPDAGs with background knowledge. In <em>Proceedings of UAI 2017.</em>
</p>
<p>I. Shpitser, T. VanderWeele and J.M. Robins (2012). On the validity of
covariate adjustment for estimating causal effects. In
<em>Proceedings of UAI 2010.</em>
</p>
<p>B. van der Zander, M. Liskiewicz and J. Textor (2014). Constructing
separators and adjustment sets in ancestral graphs. In
<em>Proceedings of UAI 2014.</em>
</p>
<p>M.H. Maathuis and D. Colombo (2013). A generalized backdoor
criterion. <em>Annals of Statistics</em> 43 1060-1088.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+backdoor">backdoor</a></code> for the Generalized Backdoor Criterion,
<code><a href="#topic+pc">pc</a></code> for estimating a CPDAG and <code><a href="#topic+fci">fci</a></code> and
<code><a href="#topic+fciPlus">fciPlus</a></code> for estimating a PAG.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## We reproduce the four examples in Perkovic et. al (2015, 2017a)

##############################
## Example 4.1 in Perkovic et. al (2015), Example 2 in Perkovic et. al (2017a)
##############################
mFig1 &lt;- matrix(c(0,1,1,0,0,0, 1,0,1,1,1,0, 0,0,0,0,0,1,
                  0,1,1,0,1,1, 0,1,0,1,0,1, 0,0,0,0,0,0), 6,6)
type &lt;- "cpdag"
x &lt;- 3; y &lt;- 6
## Z satisfies GAC :
gac(mFig1, x,y, z=c(2,4),    type)
gac(mFig1, x,y, z=c(4,5),    type)
gac(mFig1, x,y, z=c(4,2,1),  type)
gac(mFig1, x,y, z=c(4,5,1),  type)
gac(mFig1, x,y, z=c(4,2,5),  type)
gac(mFig1, x,y, z=c(4,2,5,1),type)
## Z does not satisfy GAC :
gac(mFig1,x,y, z=2,    type)
gac(mFig1,x,y, z=NULL, type)

##############################
## Example 4.2 in Perkovic et. al (2015), Example 3 in Perkovic et. al (2017a)
##############################
mFig3a &lt;- matrix(c(0,1,0,0, 1,0,1,1, 0,1,0,1, 0,1,1,0), 4,4)
mFig3b &lt;- matrix(c(0,2,0,0, 3,0,3,3, 0,2,0,3, 0,2,2,0), 4,4)
mFig3c &lt;- matrix(c(0,3,0,0, 2,0,3,3, 0,2,0,3, 0,2,2,0), 4,4)
type &lt;- "pag"
x &lt;- 2; y &lt;- 4
## Z does not satisfy GAC
gac(mFig3a,x,y, z=NULL, type) ## not amenable rel. to (X,Y)
gac(mFig3b,x,y, z=NULL, type) ## not amenable rel. to (X,Y)
## Z satisfies GAC
gac(mFig3c,x,y, z=NULL, type) ## amenable rel. to (X,Y)

##############################
## Example 4.3 in Perkovic et. al (2015), Example 4 in Perkovic et. al (2017a)
##############################
mFig4a &lt;- matrix(c(0,0,1,0,0,0, 0,0,1,0,0,0, 2,2,0,3,3,2,
                   0,0,2,0,2,2, 0,0,2,1,0,2, 0,0,1,3,3,0), 6,6)
mFig4b &lt;- matrix(c(0,0,1,0,0,0, 0,0,1,0,0,0, 2,2,0,0,3,2,
                   0,0,0,0,2,2, 0,0,2,3,0,2, 0,0,2,3,2,0), 6,6)
type &lt;- "pag"
x &lt;- 3; y &lt;- 4
## both PAGs are amenable rel. to (X,Y)
## Z satisfies GAC in Fig. 4a
gac(mFig4a,x,y, z=6, type)
gac(mFig4a,x,y, z=c(1,6), type)
gac(mFig4a,x,y, z=c(2,6), type)
gac(mFig4a,x,y, z=c(1,2,6), type)
## no Z satisfies GAC in Fig. 4b
gac(mFig4b,x,y, z=NULL, type)
gac(mFig4b,x,y, z=6, type)
gac(mFig4b,x,y, z=c(5,6), type)

##############################
## Example 4.4 in Perkovic et. al (2015), Example 8 in Perkovic et. al (2017a)
##############################
mFig5a &lt;- matrix(c(0,1,0,0,0, 1,0,1,0,0, 0,0,0,0,1, 0,0,1,0,0, 0,0,0,0,0), 5,5)
type &lt;- "cpdag"
x &lt;- c(1,5); y &lt;- 4
## Z satisfies GAC
gac(mFig5a,x,y, z=c(2,3), type)
## Z does not satisfy GAC
gac(mFig5a,x,y, z=2, type)

mFig5b &lt;- matrix(c(0,1,0,0,0,0,0, 2,0,2,3,0,3,0, 0,1,0,0,0,0,0,
0,2,0,0,3,0,0, 0,0,0,2,0,2,3, 0,2,0,0,2,0,0, 0,0,0,0,2,0,0), 7,7)
type &lt;- "pag"
x&lt;-c(2,7); y&lt;-6
## Z satisfies GAC
gac(mFig5b,x,y, z=c(4,5), type)
gac(mFig5b,x,y, z=c(4,5,1), type)
gac(mFig5b,x,y, z=c(4,5,3), type)
gac(mFig5b,x,y, z=c(1,3,4,5), type)
## Z does not satisfy GAC
gac(mFig5b,x,y, z=NULL, type)

##############################
## Example 4.7 in Perkovic et. al (2017b)
##############################
mFig3a &lt;- matrix(c(0,1,0,0, 1,0,1,1, 0,1,0,1, 0,1,1,0), 4,4)
mFig3b &lt;- matrix(c(0,1,0,0, 0,0,1,1, 0,0,0,1, 0,0,1,0), 4,4)
mFig3c &lt;- matrix(c(0,0,0,0, 1,0,1,0, 0,1,0,1, 0,1,1,0), 4,4)
type &lt;- "pdag"
x &lt;- 2; y &lt;- 4
## Z does not satisfy GAC
gac(mFig3a,x,y, z=NULL, type) ## not amenable rel. to (X,Y)
gac(mFig3c,x,y, z=NULL, type) ## amenable rel. to (X,Y), but no set can block X &lt;- Y
## Z satisfies GAC
gac(mFig3b,x,y, z=NULL, type) ## amenable rel. to (X,Y)


</code></pre>

<hr>
<h2 id='gAlgo-class'>Class <code>"gAlgo"</code></h2><span id='topic+gAlgo-class'></span>

<h3>Description</h3>

<p><code>"gAlgo"</code> is a <code>"VIRTUAL"</code> class, the common basis of classes
<code>"<a href="#topic+pcAlgo-class">pcAlgo</a>"</code> and <code>"<a href="#topic+fciAlgo-class">fciAlgo</a>"</code>.
</p>
<p>We describe the common slots here; for more see the help pages of the
specific classes.
</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code>:</dt><dd><p>a <code><a href="base.html#topic+call">call</a></code> object: the original function call.</p>
</dd>
<dt><code>n</code>:</dt><dd><p>an <code>"integer"</code>, the sample size used to estimate the graph.</p>
</dd>
<dt><code>max.ord</code>:</dt><dd><p>an <code><a href="base.html#topic+integer">integer</a></code>, the maximum size of
the conditioning set used in the conditional independence tests of
the (first part of the algorithm), in function <code><a href="#topic+skeleton">skeleton</a></code>.</p>
</dd>
<dt><code>n.edgetests</code>:</dt><dd><p>the number of conditional independence
tests performed by the (first part of the) algorithm.</p>
</dd>
<dt><code>sepset</code>:</dt><dd><p>a <code><a href="base.html#topic+list">list</a></code>, the conditioning sets
that led to edge deletions.  The set that led to the removal of
the edge <code>i -- j</code> is saved in either <code>sepset[[i]][[j]]</code> or
in <code>sepset[[j]][[i]]</code>.</p>
</dd>
<dt><code>pMax</code>:</dt><dd><p>a numeric square <code><a href="base.html#topic+matrix">matrix</a></code>, where the
<code class="reqn">(i,j)</code>th entry contains the maximal p-value of all conditional
independence tests for edge <code class="reqn">i -- j</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>See Also</h3>

<p><code>"<a href="#topic+pcAlgo-class">pcAlgo</a>"</code> and <code>"<a href="#topic+fciAlgo-class">fciAlgo</a>"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("gAlgo")
</code></pre>

<hr>
<h2 id='GaussL0penIntScore-class'>Class <code>"GaussL0penIntScore"</code></h2><span id='topic+GaussL0penIntScore-class'></span><span id='topic+local.score+2CGaussL0penIntScore-method'></span><span id='topic+global.score+2CGaussL0penIntScore-method'></span><span id='topic+local.mle+2CGaussL0penIntScore-method'></span><span id='topic+global.mle+2CGaussL0penIntScore-method'></span>

<h3>Description</h3>

<p>This class represents a score for causal inference from jointly interventional
and observational Gaussian data; it is used in the causal inference functions 
<code><a href="#topic+gies">gies</a></code> and <code><a href="#topic+simy">simy</a></code>. 
</p>


<h3>Details</h3>

<p>The class implements an <code class="reqn">\ell_0</code>-penalized Gaussian maximum 
likelihood estimator.  The penalization is a constant (specified by
the argument <code>lambda</code> in the constructor) times the number of 
parameters of the DAG model.  By default, the constant <code class="reqn">\lambda</code> is 
chosen as <code class="reqn">\log(n)/2</code>, which corresponds to the BIC score.
</p>


<h3>Extends</h3>

<p>Class <code>"<a href="#topic+Score-class">Score</a>"</code>, directly.
</p>
<p>All reference classes extend and inherit methods from <code>"<a href="methods.html#topic+envRefClass-class">envRefClass</a>"</code>.
</p>


<h3>Fields</h3>

<p>The class <code>GaussL0penIntScore</code> has the same fields as <code><a href="#topic+Score-class">Score</a></code>.   
They need not be accessed by the user.
</p>


<h3>Constructor</h3>

<pre>
new("GaussL0penIntScore",
  data = matrix(1, 1, 1),
  targets = list(integer(0)), 
  target.index = rep(as.integer(1), nrow(data)), 
  lambda = 0.5*log(nrow(data)), 
  intercept = FALSE, 
  use.cpp = TRUE, 
  ...)
</pre>

<dl>
<dt><code>data</code></dt><dd><p>Data matrix with <code class="reqn">n</code> rows and <code class="reqn">p</code> columns.  Each 
row corresponds to one realization, either interventional or 
observational.</p>
</dd>
<dt><code>targets</code></dt><dd><p>List of mutually exclusive intervention targets
that have been used for data generation.</p>
</dd>
<dt><code>target.index</code></dt><dd><p>Vector of length <code class="reqn">n</code>; the <code class="reqn">i</code>-th entry 
specifies the index of the intervention
target in <code>targets</code> under which the <code class="reqn">i</code>-th row of <code>data</code>
was measured.</p>
</dd>
<dt><code>lambda</code></dt><dd><p>Penalization constant (cf. details)</p>
</dd>
<dt><code>intercept</code></dt><dd><p>Indicates whether an intercept is allowed in the linear
structural equations, or, equivalently, if a mean different from zero is
allowed for the observational distribution.</p>
</dd>
<dt><code>use.cpp</code></dt><dd><p>Indicates whether the calculation of the score should be done
by the C++ library of the package, which speeds up calculation.  This
parameter should only be set to <code>FALSE</code> in the case of problems.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt><code>local.score(vertex, parents, ...)</code></dt><dd><p>Calculates the local score 
of a vertex and its parents.  Since this score has no obvious 
interpretation, it is rather for internal use.</p>
</dd>
<dt><code>global.score.int(edges, ...)</code></dt><dd><p>Calculates the global score of
a DAG, represented as a list of in-edges: for each vertex in the DAG,
this list contains a vector of parents.</p>
</dd>
<dt><code>global.score(dag, ...)</code></dt><dd><p>Calculates the global score of a DAG,
represented as an object of a class derived from
<code><a href="#topic+ParDAG-class">ParDAG</a></code>.</p>
</dd> 
<dt><code>local.mle(vertex, parents, ...)</code></dt><dd><p>Calculates the local MLE of 
a vertex and its parents.  The result is a vector of parameters encoded
as follows:
</p>

<ul>
<li><p> First element: variance of the Gaussian error term
</p>
</li>
<li><p> Second element: intercept
</p>
</li>
<li><p> Following elements: regression coefficients; one per parent vertex
</p>
</li></ul>

</dd>
<dt><code>global.mle(dag, ...)</code></dt><dd><p>Calculates the global MLE of a DAG,
represented by an object of a class derived from
<code><a href="#topic+ParDAG-class">ParDAG</a></code>. 
The result is a list of vectors, one per vertex, each in the same format
as the result vector of <code>local.mle</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Alain Hauser (<a href="mailto:alain.hauser@bfh.ch">alain.hauser@bfh.ch</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gies">gies</a></code>, <code><a href="#topic+simy">simy</a></code>, 
<code><a href="#topic+GaussL0penObsScore-class">GaussL0penObsScore</a></code>, 
<code><a href="#topic+Score-class">Score</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################################################
## Using Gaussian Data
##################################################
## Load predefined data
data(gmInt)

## Define the score object
score &lt;- new("GaussL0penIntScore", gmInt$x, gmInt$targets, gmInt$target.index) 

## Score of the true underlying DAG
score$global.score(as(gmInt$g, "GaussParDAG"))

## Score of the DAG that has only one edge from 1 to 2
A &lt;- matrix(0, ncol(gmInt$x), ncol(gmInt$x))
A[1, 2] &lt;- 1
score$global.score(as(A, "GaussParDAG"))
## (Note: this is lower than the score of the true DAG.)
</code></pre>

<hr>
<h2 id='GaussL0penObsScore-class'>Class <code>"GaussL0penObsScore"</code></h2><span id='topic+GaussL0penObsScore-class'></span><span id='topic+local.score+2CGaussL0penObsScore-method'></span><span id='topic+global.score+2CGaussL0penObsScore-method'></span><span id='topic+local.mle+2CGaussL0penObsScore-method'></span><span id='topic+global.mle+2CGaussL0penObsScore-method'></span>

<h3>Description</h3>

<p>This class represents a score for causal inference from observational Gaussian
data; it is used in the causal inference function <code><a href="#topic+ges">ges</a></code>. 
</p>


<h3>Details</h3>

<p>The class implements an <code class="reqn">\ell_0</code>-penalized Gaussian maximum 
likelihood estimator.  The penalization is a constant (specified by
the argument <code>lambda</code> in the constructor) times the number of 
parameters of the DAG model.  By default, the constant <code class="reqn">\lambda</code> is
chosen as <code class="reqn">\log(n)/2</code>, which corresponds to the BIC score.
</p>


<h3>Extends</h3>

<p>Class <code>"<a href="#topic+Score-class">Score</a>"</code>, directly.
</p>
<p>All reference classes extend and inherit methods from <code>"<a href="methods.html#topic+envRefClass-class">envRefClass</a>"</code>.
</p>


<h3>Fields</h3>

<p>The class <code>GaussL0penObsScore</code> has the same fields as 
<code><a href="#topic+Score-class">Score</a></code>.  They need not be accessed by the user.
</p>


<h3>Constructor</h3>

<pre>
new("GaussL0penObsScore",
  data = matrix(1, 1, 1),
  lambda = 0.5*log(nrow(data)), 
  intercept = TRUE, 
  use.cpp = TRUE, 
  ...)
</pre>

<dl>
<dt><code>data</code></dt><dd><p>Data matrix with <code class="reqn">n</code> rows and <code class="reqn">p</code> columns.  Each row
corresponds to one observational realization.</p>
</dd>
<dt><code>lambda</code></dt><dd><p>Penalization constant (cf. details)</p>
</dd>
<dt><code>intercept</code></dt><dd><p>Indicates whether an intercept is allowed in the linear
structural equations, or, equivalently, if a mean different from zero is
allowed for the observational distribution.</p>
</dd>
<dt><code>use.cpp</code></dt><dd><p>Indicates whether the calculation of the score should be done
by the C++ library of the package, which speeds up calculation.  This
parameter should only be set to <code>FALSE</code> in the case of problems.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt><code>local.score(vertex, parents, ...)</code></dt><dd><p>Calculates the local score 
of a vertex and its parents.  Since this score has no obvious 
interpretation, it is rather for internal use.</p>
</dd>
<dt><code>global.score.int(edges, ...)</code></dt><dd><p>Calculates the global score of
a DAG, represented as a list of in-edges: for each vertex in the DAG,
this list contains a vector of parents.</p>
</dd>
<dt><code>global.score(dag, ...)</code></dt><dd><p>Calculates the global score of a DAG,
represented as an object of a class derived from
<code><a href="#topic+ParDAG-class">ParDAG</a></code>.</p>
</dd> 
<dt><code>local.mle(vertex, parents, ...)</code></dt><dd><p>Calculates the local MLE of 
a vertex and its parents.  The result is a vector of parameters encoded
as follows:
</p>

<ul>
<li><p> First element: variance of the Gaussian error term
</p>
</li>
<li><p> Second element: intercept
</p>
</li>
<li><p> Following elements: regression coefficients; one per parent vertex
</p>
</li></ul>

</dd>
<dt><code>global.mle(dag, ...)</code></dt><dd><p>Calculates the global MLE of a DAG,
represented by an object of a class derived from
<code><a href="#topic+ParDAG-class">ParDAG</a></code>. 
The result is a list of vectors, one per vertex, each in the same format
as the result vector of <code>local.mle</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Alain Hauser (<a href="mailto:alain.hauser@bfh.ch">alain.hauser@bfh.ch</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ges">ges</a></code>,
<code><a href="#topic+GaussL0penIntScore-class">GaussL0penIntScore</a></code>, 
<code><a href="#topic+Score-class">Score</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################################################
## Using Gaussian Data
##################################################
## Load predefined data
data(gmG)

## Define the score object
score &lt;- new("GaussL0penObsScore", gmG$x) 

## Score of the true underlying DAG
score$global.score(as(gmG$g, "GaussParDAG"))

## Score of the DAG that has only one edge from 1 to 2
A &lt;- matrix(0, ncol(gmG$x), ncol(gmG$x))
A[1, 2] &lt;- 1
score$global.score(as(A, "GaussParDAG"))
## (Note: this is lower than the score of the true DAG.)
</code></pre>

<hr>
<h2 id='GaussParDAG-class'>Class <code>"GaussParDAG"</code> of Gaussian Causal Models</h2><span id='topic+GaussParDAG-class'></span>

<h3>Description</h3>

<p>The <code>"GaussParDAG"</code> class represents a Gaussian causal model.
</p>


<h3>Details</h3>

<p>The class <code>"GaussParDAG"</code> is used to simulate observational
and/or interventional data from Gaussian causal models as well as for parameter
estimation (maximum-likelihood estimation) for a given DAG structure in the
presence of a data set with jointly observational and interventional data.
</p>
<p>A Gaussian causal model can be represented as a set of <code class="reqn">p</code> linear
structural equations with Gaussian noise variables.  Those equations are
fully specified by indicating the regression parameters, the intercept
and the variance of the noise or error terms.  More details can be found e.g.
in Kalisch and Bühlmann (2007) or Hauser and Bühlmann (2012).
</p>


<h3>Extends</h3>

<p>Class <code>"<a href="#topic+ParDAG-class">ParDAG</a>"</code>, directly.
</p>
<p>All reference classes extend and inherit methods from
<code>"<a href="methods.html#topic+envRefClass-class">envRefClass</a>"</code>.
</p>


<h3>Constructor</h3>

<p><code>new("GaussParDAG", nodes, in.edges, params)</code>
</p>

<dl>
<dt><code>nodes</code></dt><dd><p>Vector of node names; cf. also field <code>.nodes</code>.</p>
</dd>
<dt><code>in.edges</code></dt><dd><p>A list of length <code>p</code> consisting of index
vectors indicating the edges pointing into the nodes of the DAG.</p>
</dd>
<dt><code>params</code></dt><dd><p>A list of length <code>p</code> consisting of parameter
vectors modeling the conditional distribution of a node given its
parents; cf. also field <code>.params</code> for the meaning of the
parameters.</p>
</dd>
</dl>



<h3>Fields</h3>


<dl>
<dt><code>.nodes</code>:</dt><dd><p>Vector of node names; defaults to <code>as.character(1:p)</code>,
where <code>p</code> denotes the number of nodes (variables) of the model.</p>
</dd>
<dt><code>.in.edges</code>:</dt><dd><p>A list of length <code>p</code> consisting of index
vectors indicating the edges pointing into the nodes of the DAG.  The
<code class="reqn">i</code>-th entry lists the indices of the parents of the <code class="reqn">i</code>-th node.</p>
</dd>
<dt><code>.params</code>:</dt><dd><p>A list of length <code>p</code> consisting of parameter
vectors modeling the conditional distribution of a node given its
parents.  The <code class="reqn">i</code>-th entry models the conditional (normal)
distribution of the <code class="reqn">i</code>-th variable in the model given its parents.
It is a vector of length <code class="reqn">k + 2</code>, where <code class="reqn">k</code> is the number of
parents of node <code class="reqn">i</code>; the first entry encodes the error variance of
node <code class="reqn">i</code>, the second entry the intercept, and the remaining entries
the regression coefficients (see above).  In most cases, it is easier
to access the parameters via the wrapper functions <code>err.var</code>,
<code>intercept</code> and <code>weight.mat</code>.</p>
</dd>
</dl>



<h3>Class-Based Methods</h3>


<dl>
<dt><code>set.err.var(value)</code>:</dt><dd><p>Sets the error variances.  The argument
must be a vector of length <code class="reqn">p</code>, where <code class="reqn">p</code> denotes the number
of nodes in the model.</p>
</dd>
<dt><code>err.var()</code>:</dt><dd><p>Yields the vector of error variances.</p>
</dd>
<dt><code>intercept()</code>:</dt><dd><p>Yields the vector of intercepts.</p>
</dd>
<dt><code>set.intercept(value)</code>:</dt><dd><p>Sets the intercepts.  The argument
must be a vector of length <code class="reqn">p</code>, where <code class="reqn">p</code> denotes the number
of nodes in the model.</p>
</dd>
<dt><code>weight.mat(target)</code>:</dt><dd><p>Yields the (observational or
interventional) weight matrix of the model. The weight matrix is an
<code class="reqn">p \times p</code> matrix whose <code class="reqn">i</code>-th columns contains the
regression coefficients of the <code class="reqn">i</code>-th structural equation, if node
<code class="reqn">i</code> is not intervened (i.e., if <code>i</code> is not contained in the
vector <code>target</code>), and is empty otherwise.</p>
</dd>
<dt><code>cov.mat(target, ivent.var)</code>:</dt><dd><p>Yields the covariance matrix
of the observational or an interventional distribution of the causal
model.  If <code>target</code> has length 0, the covariance matrix of the
observational distribution is returned; otherwise <code>target</code> is a
vector of the intervened nodes, and <code>ivent.var</code> is a vector of the
same length indicating the variances of the intervention levels.
Deterministic interventions with fix intervention levels would correspond
to vanishing intervention variances; with non-zero intervention variances,
stochastic interventions are considered in which intervention values are
realizations of Gaussian variables (Korb et al., 2004).</p>
</dd>
</dl>

<p>The following methods are inherited (from the corresponding class):
<code>node.count</code> (&quot;ParDAG&quot;), <code>edge.count</code> (&quot;ParDAG&quot;), <code>simulate</code> (&quot;ParDAG&quot;)
</p>


<h3>Author(s)</h3>

<p>Alain Hauser (<a href="mailto:alain.hauser@bfh.ch">alain.hauser@bfh.ch</a>)
</p>


<h3>References</h3>

<p>A. Hauser and P. Bühlmann (2012).  Characterization and greedy learning of
interventional Markov equivalence classes of directed acyclic graphs.
<em>Journal of Machine Learning Research</em> <b>13</b>, 2409&ndash;2464.
</p>
<p>M. Kalisch and P. Buehlmann (2007).  Estimating high-dimensional directed
acyclic graphs with the PC-algorithm. <em>Journal of Machine Learning
Research</em> <b>8</b>, 613&ndash;636.
</p>
<p>K.B. Korb, L.R. Hope, A.E. Nicholson, and K. Axnick (2004).  Varieties of
causal intervention.  <em>Proc. of the Pacific Rim International Conference
on Artificial Intelligence (PRICAI 2004)</em>, 322&ndash;331
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ParDAG-class">ParDAG</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(307)
myDAG &lt;- r.gauss.pardag(p = 5, prob = 0.4)
(wm &lt;- myDAG$weight.mat())
m &lt;- as(myDAG, "matrix") # TRUE/FALSE adjacency matrix
symnum(m)
stopifnot(identical(unname( m ),
                    unname(wm != 0)))
myDAG$err.var()
myDAG$intercept()
myDAG$set.intercept(runif(5, min=3, max=4))
myDAG$intercept()
if (require(Rgraphviz)) plot(myDAG)
</code></pre>

<hr>
<h2 id='gds'>Greedy DAG Search to Estimate Markov Equivalence Class of DAG</h2><span id='topic+gds'></span>

<h3>Description</h3>

<p>Estimate the observational or interventional essential graph representing the 
Markov equivalence class of a DAG by greedily optimizing a score function in 
the space of DAGs.  In practice, greedy search should always be done in the 
space of equivalence classes instead of DAGs, giving the functions
<code><a href="#topic+gies">gies</a></code> or <code><a href="#topic+ges">ges</a></code> the preference over <code>gds</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gds(score, labels = score$getNodes(), targets = score$getTargets(),
    fixedGaps = NULL, phase = c("forward", "backward", "turning"), 
    iterate = length(phase) &gt; 1, turning = TRUE, maxDegree = integer(0), 
    verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gds_+3A_score">score</code></td>
<td>
<p>An instance of a class derived from <code><a href="#topic+Score-class">Score</a></code>.</p>
</td></tr>
<tr><td><code id="gds_+3A_labels">labels</code></td>
<td>
<p>Node labels; by default, they are determined from the scoring
object.</p>
</td></tr>  
<tr><td><code id="gds_+3A_targets">targets</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code> of intervention targets
(cf. details).  A list of vectors, each vector listing the vertices
of one intervention target.</p>
</td></tr>
<tr><td><code id="gds_+3A_fixedgaps">fixedGaps</code></td>
<td>
<p>Logical <em>symmetric</em> matrix of dimension p*p.  If entry
<code>[i, j]</code> is <code>TRUE</code>, the result is guaranteed to have no edge
between nodes <code class="reqn">i</code> and <code class="reqn">j</code>.</p>
</td></tr>
<tr><td><code id="gds_+3A_phase">phase</code></td>
<td>
<p>Character vector listing the phases that should be used; possible
values: <code>forward</code>, <code>backward</code>, and <code>turning</code> (cf. details).</p>
</td></tr>
<tr><td><code id="gds_+3A_iterate">iterate</code></td>
<td>
<p>Logical indicating whether the phases listed in the argument
<code>phase</code> should be iterated more than once (<code>iterate = TRUE</code>) or
not.</p>
</td></tr>
<tr><td><code id="gds_+3A_turning">turning</code></td>
<td>
<p>Setting <code>turning = TRUE</code> is equivalent to setting
<code>phases = c("forward", "backward")</code> and <code>iterate = FALSE</code>; the
use of the argument <code>turning</code> is deprecated.</p>
</td></tr>
<tr><td><code id="gds_+3A_maxdegree">maxDegree</code></td>
<td>
<p>Parameter used to limit the vertex degree of the estimated
graph.  Valid arguments:
</p>

<ol>
<li><p> Vector of length 0 (default): vertex degree is not limited.
</p>
</li>
<li><p> Real number <code class="reqn">r</code>, <code class="reqn">0 &lt; r &lt; 1</code>: degree of vertex <code class="reqn">v</code> is
limited to <code class="reqn">r \cdot n_v</code>, where <code class="reqn">n_v</code> denotes the number of
data points where <code class="reqn">v</code> was not intervened.
</p>
</li>
<li><p> Single integer: uniform bound of vertex degree for all vertices
of the graph.
</p>
</li>
<li><p> Integer vector of length <code>p</code>: vector of individual bounds
for the vertex degrees.
</p>
</li></ol>

</td></tr>
<tr><td><code id="gds_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, detailed output is provided.</p>
</td></tr>
<tr><td><code id="gds_+3A_...">...</code></td>
<td>
<p>additional arguments for debugging purposes and fine tuning.</p>
</td></tr>

</table>


<h3>Details</h3>

<p>This function estimates the observational or interventional Markov 
equivalence class of a DAG
based on a data sample with interventional data originating from various
interventions and possibly observational data. The intervention targets used
for data generation must be specified by the argument <code>targets</code> as a
list of (integer) vectors listing the intervened vertices; observational
data is specified by an empty set, i.e. a vector of the form
<code>integer(0)</code>.  As an example, if data contains observational samples
as well as samples originating from an intervention at vertices 1 and 4,
the intervention targets must be specified as <code>list(integer(0), 
  as.integer(1), as.integer(c(1, 4)))</code>.  
</p>
<p>An interventional Markov equivalence class of DAGs can be uniquely
represented by a partially directed graph called interventional essential 
graph.  Its edges have the following interpretation:
</p>

<ol>
<li><p> a directed edge <code class="reqn">a \longrightarrow b</code> stands for an arrow
that has the same orientation in all representatives of the 
interventional Markov equivalence class;
</p>
</li>
<li><p> an undirected edge a &ndash; b stands for an arrow that is oriented in one 
way in some representatives of the equivalence class and in the other way 
in other representatives of the equivalence class.
</p>
</li></ol>

<p>Note that when plotting the object, undirected and bidirected edges are 
equivalent.
</p>
<p>Greedy DAG search (GDS) maximizes a score function (typically the BIC, passed
to the function via the argument <code>score</code>) of a DAG in three phases, 
starting from the empty DAG:
</p>

<dl>
<dt>Forward phase</dt><dd><p>In the forward phase, GDS adds single arrows to the 
DAG as long as this augments the score.</p>
</dd>
<dt>Backward phase</dt><dd><p>In the backward phase, the algorithm removes arrows
from the DAG as long as this augments the score.</p>
</dd>
<dt>Turning phase</dt><dd><p>In the turning phase, the algorithm reverts arrows of
the DAG as long as this augments the score.</p>
</dd>
</dl>

<p>The phases that are actually run are specified with the argument 
<code>phase</code>.  GDS cycles through the specified phases until no augmentation 
of the score is possible any more if <code>iterate = TRUE</code>.  In the end, 
<code>gds</code> returns the (interventional or observational) essential graph of 
the last visited DAG.
</p>
<p>It is well-known that a greedy search in the space of DAGs instead of 
essential graphs is more prone to be stuck in local optima of the score
function and hence expected to yield worse estimation results than GIES
(function <code><a href="#topic+gies">gies</a></code>) or GES (function <code><a href="#topic+ges">ges</a></code>) (Chickering,
2002; Hauser and Bühlmann, 2012).  The 
function <code>gds</code> is therefore not of practical use, but can be used
to compare causal inference algorithms to an elementary and straight-forward
approach.
</p>


<h3>Value</h3>

<p><code>gds</code> returns a list with the following two components:
</p>
<table>
<tr><td><code>essgraph</code></td>
<td>
<p>An object of class <code><a href="#topic+EssGraph-class">EssGraph</a></code> containing an 
estimate of the equivalence class of the underlying DAG.</p>
</td></tr>
<tr><td><code>repr</code></td>
<td>
<p>An object of a class derived from <code><a href="#topic+ParDAG-class">ParDAG</a></code>
containing a (random) representative of the estimated equivalence class.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alain Hauser (<a href="mailto:alain.hauser@bfh.ch">alain.hauser@bfh.ch</a>)
</p>


<h3>References</h3>

<p>D.M. Chickering (2002).  Optimal structure identification with greedy search.
<em>Journal of Machine Learning Research</em> <b>3</b>, 507&ndash;554
</p>
<p>A. Hauser and P. Bühlmann (2012).  Characterization and greedy learning of 
interventional Markov equivalence classes of directed acyclic graphs.
<em>Journal of Machine Learning Research</em> <b>13</b>, 2409&ndash;2464.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gies">gies</a></code>, <code><a href="#topic+ges">ges</a></code>, <code><a href="#topic+Score-class">Score</a></code>, 
<code><a href="#topic+EssGraph-class">EssGraph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load predefined data
data(gmInt)

## Define the score (BIC)
score &lt;- new("GaussL0penIntScore", gmInt$x, gmInt$targets, gmInt$target.index) 

## Estimate the essential graph
gds.fit &lt;- gds(score) 

## Plot the estimated essential graph and the true DAG
if (require(Rgraphviz)) {
  par(mfrow=c(1,2))
  plot(gds.fit$essgraph, main = "Estimated ess. graph")
  plot(gmInt$g, main = "True DAG")
}
</code></pre>

<hr>
<h2 id='ges'>Estimate the Markov equivalence class of a DAG using GES</h2><span id='topic+ges'></span>

<h3>Description</h3>

<p>Estimate the observational essential graph representing the Markov
equivalence class of a DAG using the greedy equivalence search (GES)
algorithm of Chickering (2002).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ges(score, labels = score$getNodes(),
    fixedGaps = NULL, adaptive = c("none", "vstructures", "triples"), 
    phase = c("forward", "backward", "turning"), iterate = length(phase) &gt; 1,
    turning = NULL, maxDegree = integer(0), verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ges_+3A_score">score</code></td>
<td>
<p>An instance of a class derived from <code><a href="#topic+Score-class">Score</a></code>
which only accounts for observational data. If the
dataset is high-dimensional (p&gt;=n) <code>ges</code> might not be able to terminate.</p>
</td></tr>
<tr><td><code id="ges_+3A_labels">labels</code></td>
<td>
<p>Node labels; by default, they are determined from the scoring
object.</p>
</td></tr>
<tr><td><code id="ges_+3A_fixedgaps">fixedGaps</code></td>
<td>
<p>logical <em>symmetric</em> matrix of dimension p*p.  If entry
<code>[i, j]</code> is <code>TRUE</code>, the result is guaranteed to have no edge
between nodes <code class="reqn">i</code> and <code class="reqn">j</code>.</p>
</td></tr>
<tr><td><code id="ges_+3A_adaptive">adaptive</code></td>
<td>
<p>indicating whether constraints should be adapted to
newly detected v-structures or unshielded triples (cf. details).</p>
</td></tr>
<tr><td><code id="ges_+3A_phase">phase</code></td>
<td>
<p>Character vector listing the phases that should be used; possible
values: <code>forward</code>, <code>backward</code>, and <code>turning</code> (cf. details).</p>
</td></tr>
<tr><td><code id="ges_+3A_iterate">iterate</code></td>
<td>
<p>Logical indicating whether the phases listed in the argument
<code>phase</code> should be iterated more than once (<code>iterate = TRUE</code>) or
not.</p>
</td></tr>
<tr><td><code id="ges_+3A_turning">turning</code></td>
<td>
<p>Setting <code>turning = TRUE</code> is equivalent to setting
<code>phases = c("forward", "backward")</code> and <code>iterate = FALSE</code>; the
use of the argument <code>turning</code> is deprecated.</p>
</td></tr>
<tr><td><code id="ges_+3A_maxdegree">maxDegree</code></td>
<td>
<p>Parameter used to limit the vertex degree of the estimated
graph.  Valid arguments:
</p>

<ol>
<li><p> Vector of length 0 (default): vertex degree is not limited.
</p>
</li>
<li><p> Real number <code class="reqn">r</code>, <code class="reqn">0 &lt; r &lt; 1</code>: degree of vertex <code class="reqn">v</code> is
limited to <code class="reqn">r \cdot n_v</code>, where <code class="reqn">n_v</code> denotes the number of
data points where <code class="reqn">v</code> was not intervened.
</p>
</li>
<li><p> Single integer: uniform bound of vertex degree for all vertices
of the graph.
</p>
</li>
<li><p> Integer vector of length <code>p</code>: vector of individual bounds
for the vertex degrees.
</p>
</li></ol>

</td></tr>
<tr><td><code id="ges_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, detailed output is provided.</p>
</td></tr>
<tr><td><code id="ges_+3A_...">...</code></td>
<td>
<p>Additional arguments for debugging purposes and fine tuning.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Under the assumption that the distribution of the observed variables is
faithful to a DAG, this function estimates the Markov equivalence class of
the DAG. It does not estimate the DAG itself, because this is typically
impossible (even with an infinite amount of data): different DAGs (forming a
Markov equivalence class) can describe the same conditional independence
relationships and be statistically indistinguishable from observational data
alone.
</p>
<p>All DAGs in an equivalence class have the same skeleton (i.e., the same
adjacency information) and the same v-structures (i.e., the same induced
subgraphs of the form <code class="reqn">a \longrightarrow b \longleftarrow c</code>).
However, the direction of some edges may be undetermined, in the sense that
they point one way in one DAG in the equivalence class, while they point the
other way in another DAG in the equivalence class.
</p>
<p>An equivalence class can be uniquely represented by a partially directed graph
called (observational) essential graph or CPDAG (completed partially directed
acyclic graph).  Its edges have the following interpretation:
</p>

<ol>
<li><p> a directed edge <code class="reqn">a \longrightarrow b</code> stands for an arrow
that has the same orientation in all representatives of the Markov
equivalence class;
</p>
</li>
<li><p> an undirected edge a &ndash; b stands for an arrow that is oriented in one
way in some representatives of the equivalence class and in the other way
in other representatives of the equivalence class.
</p>
</li></ol>

<p>Note that when plotting the object, undirected and bidirected edges are
equivalent.
</p>
<p>GES (greedy equivalence search) is a score-based algorithm that greedily
maximizes a score function (typically the BIC, passed to the function via the
argument <code>score</code>) in the space of (observational) essential graphs in
three phases, starting from the empty graph:
</p>

<dl>
<dt>Forward phase</dt><dd><p>In the forward phase, GES moves through the space of
essential graphs in steps that correspond to the addition of a single edge
in the space of DAGs; the phase is aborted as soon as the score cannot be
augmented any more.</p>
</dd>
<dt>Backward phase</dt><dd><p>In the backward phase, the algorithm performs moves
that correspond to the removal of a single edge in the space of DAGs until
the score cannot be augmented any more.</p>
</dd>
<dt>Turning phase</dt><dd><p>In the turning phase, the algorithm performs moves
that correspond to the reversal of a single arrow in the space of DAGs
until the score cannot be augmented any more.</p>
</dd>
</dl>

<p>GES cycles through these three phases until no augmentation of the score is
possible any more if <code>iterate = TRUE</code>.  Note that the turning phase 
was not part of the original implementation of Chickering (2002), but was 
introduced by Hauser and Bühlmann (2012) and shown to improve the overall 
estimation performance.  The original algorithm of Chickering (2002) is 
reproduced with <code>phase = c("forward", "backward")</code> and 
<code>iterate = FALSE</code>.
</p>
<p>GES has the same purpose as the PC algorithm (see <code><a href="#topic+pc">pc</a></code>).  While
the PC algorithm is based on conditional independence tests (requiring the
choice of an independence test and a significance level, see
<code><a href="#topic+pc">pc</a></code>), the GES algorithm is a score-based method (requiring the
choice of a score function) and does not depend on conditional independence
tests.  Since GES always operates in the space of essential graphs, it
returns a valid essential graph (or CPDAG) in any case.
</p>
<p>Using the argument <code>fixedGaps</code>, one can make sure that certain edges
will <em>not</em> be present in the resulting essential graph: if the entry
<code>[i, j]</code> of the matrix passed to <code>fixedGaps</code> is <code>TRUE</code>, there
will be no edge between nodes <code class="reqn">i</code> and <code class="reqn">j</code>.  Using this argument 
can speed up the execution of GIES and allows the user to account for
previous knowledge or other constraints.  The argument <code>adaptive</code> can be
used to relax the constraints encoded by <code>fixedGaps</code> according to a 
modification of GES called ARGES (adaptively restricted greedy 
equivalence search) which has been presented in Nandy, Hauser and Maathuis
(2015):
</p>

<ul>
<li><p> When <code>adaptive = "vstructures"</code> and the algorithm introduces a 
new v-structure <code class="reqn">a \longrightarrow b \longleftarrow c</code> in the 
forward phase, then the edge <code class="reqn">a - c</code> is removed from the list of fixed 
gaps, meaning that the insertion of an edge between <code class="reqn">a</code> and <code class="reqn">c</code> 
becomes possible even if it was forbidden by the initial matrix passed to 
<code>fixedGaps</code>.
</p>
</li>
<li><p> When <code>adaptive = "triples"</code> and the algorithm introduces a new
unshielded triple in the forward phase (i.e., a subgraph of three nodes
<code class="reqn">a</code>, <code class="reqn">b</code> and <code class="reqn">c</code> where <code class="reqn">a</code> and <code class="reqn">b</code> as well as <code class="reqn">b</code>
and <code class="reqn">c</code> are adjacent, but <code class="reqn">a</code> and <code class="reqn">c</code> are not), then the edge
<code class="reqn">a - c</code> is removed from the list of fixed gaps.
</p>
</li></ul>

<p>With one of the adaptive modifications, the successive application of a 
skeleton estimation method and GES restricted to an estimated skeleton still
gives a <em>consistent</em> estimator of the DAG, which is not the case without
the adaptive modification.


</p>


<h3>Value</h3>

<p><code>ges</code> returns a list with the following two components:
</p>
<table>
<tr><td><code>essgraph</code></td>
<td>
<p>An object of class <code><a href="#topic+EssGraph-class">EssGraph</a></code> containing an
estimate of the equivalence class of the underlying DAG.</p>
</td></tr>
<tr><td><code>repr</code></td>
<td>
<p>An object of a class derived from <code><a href="#topic+ParDAG-class">ParDAG</a></code>
containing a (random) representative of the estimated equivalence class.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alain Hauser (<a href="mailto:alain.hauser@bfh.ch">alain.hauser@bfh.ch</a>)
</p>


<h3>References</h3>

<p>D.M. Chickering (2002).  Optimal structure identification with greedy search.
<em>Journal of Machine Learning Research</em> <b>3</b>, 507&ndash;554
</p>
<p>A. Hauser and P. Bühlmann (2012).  Characterization and greedy learning of
interventional Markov equivalence classes of directed acyclic graphs.
<em>Journal of Machine Learning Research</em> <b>13</b>, 2409&ndash;2464.
</p>
<p>P. Nandy, A. Hauser and M. Maathuis (2015).  Understanding consistency in 
hybrid causal structure learning.  <em>arXiv preprint</em> 1507.02608
</p>
<p>P. Spirtes, C.N. Glymour, and R. Scheines (2000).  <em>Causation,
Prediction, and Search</em>, MIT Press, Cambridge (MA).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pc">pc</a></code>, <code><a href="#topic+Score-class">Score</a></code>, <code><a href="#topic+EssGraph-class">EssGraph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load predefined data
data(gmG)

## Define the score (BIC)
score &lt;- new("GaussL0penObsScore", gmG8$x)

## Estimate the essential graph
ges.fit &lt;- ges(score)

## Plot the estimated essential graph and the true DAG
if (require(Rgraphviz)) {
  par(mfrow=c(1,2))
  plot(ges.fit$essgraph, main = "Estimated CPDAG")
  plot(gmG8$g, main = "True DAG")
} else { ## alternative:
  str(ges.fit, max=2)
  as(as(ges.fit$essgraph,"graphNEL"),"Matrix")
}
</code></pre>

<hr>
<h2 id='getGraph'>Get the &quot;graph&quot; Part or Aspect of R Object</h2><span id='topic+getGraph'></span><span id='topic+getGraph-methods'></span><span id='topic+getGraph+2CANY-method'></span><span id='topic+getGraph+2CfciAlgo-method'></span><span id='topic+getGraph+2Cmatrix-method'></span><span id='topic+getGraph+2CpcAlgo-method'></span>

<h3>Description</h3>

<p>Get the <code>graph</code>  part or &ldquo;aspect&rdquo; of an <span class="rlang"><b>R</b></span>
object, notably from our <code><a href="#topic+pc">pc</a>()</code>, <code><a href="#topic+skeleton">skeleton</a>()</code>,
<code><a href="#topic+fci">fci</a>()</code>, etc, results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGraph(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getGraph_+3A_x">x</code></td>
<td>
<p>potentially any <span class="rlang"><b>R</b></span> object which can be interpreted as a graph
(with nodes and edges).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>graph</code> object, i.e., one inheriting from (the
virtual) class <code>"graph"</code>, package <span class="pkg">graph</span>.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "ANY")</code></dt><dd><p>the default method just tries
<code>as(x, "graph")</code>,  so works when a <code><a href="methods.html#topic+coerce">coerce</a></code> (S4)
method is defined for <code>x</code>.</p>
</dd>
<dt><code>signature(x = "pcAlgo")</code></dt><dd><p>and</p>
</dd>
<dt><code>signature(x = "fciAlgo")</code></dt><dd><p>extract the graph part
explicitly.</p>
</dd>
<dt><code>signature(x = "matrix")</code></dt><dd><p>interpret <code>x</code> as adjacency
matrix and return the corresponding <code>"graphAM"</code>
object.</p>
</dd>
</dl>

<p>For sparseMatrix methods, see the &lsquo;Note&rsquo;.
</p>


<h3>Note</h3>

<p>For large graphs, it may be attractive to work with <b>sparse
matrices</b> from the <span class="pkg">Matrix</span> package.
If desired, you can activate this by </p>
<pre>
 require(Matrix)
 setMethod("getGraph", "sparseMatrix", function(x) as(x, "graphNEL"))
 setMethod("getGraph", "Matrix",       function(x) as(x, "graphAM"))
  </pre>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>See Also</h3>

<p><code><a href="#topic+fci">fci</a></code>, etc.
The <code>graph</code> class description in package <span class="pkg">graph</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- rbind(c(0,1,0,0,1),
           c(0,0,0,1,1),
           c(1,0,0,1,0),
           c(1,0,0,0,1),
           c(0,0,0,1,0))
sum(A) # 9
getGraph(A) ## a graph with 5 nodes and  'sum(A)' edges
</code></pre>

<hr>
<h2 id='getNextSet'>Iteration through a list of all combinations of choose(n,k)</h2><span id='topic+getNextSet'></span>

<h3>Description</h3>

<p>Given a combination of <code class="reqn">k</code> elements out of the elements
<code class="reqn">1,\dots,n</code>, the next 
set of size <code>k</code> in a specified sequence is computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNextSet(n,k,set)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getNextSet_+3A_n">n</code></td>
<td>
<p>Number of elements to choose from (integer)</p>
</td></tr>
<tr><td><code id="getNextSet_+3A_k">k</code></td>
<td>
<p>Size of chosen set (integer)</p>
</td></tr>
<tr><td><code id="getNextSet_+3A_set">set</code></td>
<td>
<p>Previous set in list (numeric vector)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The initial set is <code>1:k</code>.  Last index varies quickest.  Using the
dynamic creation of sets reduces the memory demands dramatically for
large sets.  If complete lists of combination sets have to be produced
and memory is no problem, the function <code><a href="combinat.html#topic+combn">combn</a></code>
from package <span class="pkg">combinat</span> is an alternative.
</p>


<h3>Value</h3>

<p>List with two elements:
</p>
<table>
<tr><td><code>nextSet</code></td>
<td>
<p>Next set in list (numeric vector)</p>
</td></tr>
<tr><td><code>wasLast</code></td>
<td>
<p>Logical indicating whether the end of the specified sequence is reached.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Markus Kalisch <a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a> and Martin Maechler
</p>


<h3>See Also</h3>

<p>This function is used in <code><a href="#topic+skeleton">skeleton</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## start from first set (1,2) and get the next set of size 2 out of 1:5
## notice that res$wasLast is FALSE :
str(r &lt;- getNextSet(5,2,c(1,2)))

## input is the last set; notice that res$wasLast now is TRUE:
str(r2 &lt;- getNextSet(5,2,c(4,5)))

## Show all sets of size k out of 1:n :
## {if you really want this in practice, use something like combn() !}
n &lt;- 5
k &lt;- 3
currentSet &lt;- 1:k
(res &lt;- rbind(currentSet, deparse.level = 0))
repeat {
  newEl &lt;- getNextSet(n,k,currentSet)
  if (newEl$wasLast)
     break
  ## otherwise continue:
  currentSet &lt;- newEl$nextSet
  res &lt;- rbind(res, currentSet, deparse.level = 0)
}
res
stopifnot(choose(n,k) == nrow(res)) ## must be identical
</code></pre>

<hr>
<h2 id='gies'>Estimate Interventional Markov Equivalence Class of a DAG by GIES</h2><span id='topic+gies'></span>

<h3>Description</h3>

<p>Estimate the interventional essential graph representing the Markov
equivalence class of a DAG using the greedy interventional equivalence search
(GIES) algorithm of Hauser and Bühlmann (2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gies(score, labels = score$getNodes(), targets = score$getTargets(),
     fixedGaps = NULL, adaptive = c("none", "vstructures", "triples"), 
     phase = c("forward", "backward", "turning"), iterate = length(phase) &gt; 1,
     turning = NULL, maxDegree = integer(0), verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gies_+3A_score">score</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object inheriting from <code><a href="#topic+Score-class">Score</a></code>.</p>
</td></tr>
<tr><td><code id="gies_+3A_labels">labels</code></td>
<td>
<p>Node labels; by default, they are determined from the scoring
object.</p>
</td></tr>
<tr><td><code id="gies_+3A_targets">targets</code></td>
<td>
<p>A list of intervention targets (cf. details).  A list of
vectors, each vector listing the vertices of one intervention target.</p>
</td></tr>
<tr><td><code id="gies_+3A_fixedgaps">fixedGaps</code></td>
<td>
<p>Logical <em>symmetric</em> matrix of dimension p*p.  If entry
<code>[i, j]</code> is <code>TRUE</code>, the result is guaranteed to have no edge
between nodes <code class="reqn">i</code> and <code class="reqn">j</code>.</p>
</td></tr>
<tr><td><code id="gies_+3A_adaptive">adaptive</code></td>
<td>
<p>indicating whether constraints should be adapted to
newly detected v-structures or unshielded triples (cf. details).</p>
</td></tr>
<tr><td><code id="gies_+3A_phase">phase</code></td>
<td>
<p>Character vector listing the phases that should be used; possible
values: <code>forward</code>, <code>backward</code>, and <code>turning</code> (cf. details).</p>
</td></tr>
<tr><td><code id="gies_+3A_iterate">iterate</code></td>
<td>
<p>Logical indicating whether the phases listed in the argument
<code>phase</code> should be iterated more than once (<code>iterate = TRUE</code>) or
not.</p>
</td></tr>
<tr><td><code id="gies_+3A_turning">turning</code></td>
<td>
<p>Setting <code>turning = TRUE</code> is equivalent to setting
<code>phases = c("forward", "backward")</code> and <code>iterate = FALSE</code>; the
use of the argument <code>turning</code> is deprecated.</p>
</td></tr>
<tr><td><code id="gies_+3A_maxdegree">maxDegree</code></td>
<td>
<p>Parameter used to limit the vertex degree of the estimated
graph.  Possible values:
</p>

<ol>
<li><p> Vector of length 0 (default): vertex degree is not limited.
</p>
</li>
<li><p> Real number <code class="reqn">r</code>, <code class="reqn">0 &lt; r &lt; 1</code>: degree of vertex <code class="reqn">v</code> is
limited to <code class="reqn">r \cdot n_v</code>, where <code class="reqn">n_v</code> denotes
the number of data points where <code class="reqn">v</code> was not intervened.
</p>
</li>
<li><p> Single integer: uniform bound of vertex degree for all vertices
of the graph.
</p>
</li>
<li><p> Integer vector of length <code>p</code>: vector of individual bounds
for the vertex degrees.
</p>
</li></ol>

</td></tr>
<tr><td><code id="gies_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, detailed output is provided.</p>
</td></tr>
<tr><td><code id="gies_+3A_...">...</code></td>
<td>
<p>Additional arguments for debugging purposes and fine tuning.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function estimates the interventional Markov equivalence class of a DAG
based on a data sample with interventional data originating from various
interventions and possibly observational data. The intervention targets used
for data generation must be specified by the argument <code>targets</code> as a
list of (integer) vectors listing the intervened vertices; observational
data is specified by an empty set, i.e. a vector of the form
<code>integer(0)</code>.  As an example, if data contains observational samples
as well as samples originating from an intervention at vertices 1 and 4,
the intervention targets must be specified as <code>list(integer(0),
  as.integer(1), as.integer(c(1, 4)))</code>.
</p>
<p>An interventional Markov equivalence class of DAGs can be uniquely
represented by a partially directed graph called interventional essential
graph.  Its edges have the following interpretation:
</p>

<ol>
<li><p> a directed edge <code class="reqn">a \longrightarrow b</code> stands for an arrow
that has the same orientation in all representatives of the
interventional Markov equivalence class;
</p>
</li>
<li><p> an undirected edge <code class="reqn">a</code> &ndash; <code class="reqn">b</code> stands for an arrow that is
oriented in one  way in some representatives of the equivalence class and
in the other way in other representatives of the equivalence class.
</p>
</li></ol>

<p>Note that when plotting the object, undirected and bidirected edges are
equivalent.
</p>
<p>GIES (greedy interventional equivalence search) is a score-based algorithm
that greedily maximizes a score function (typically the BIC, passed to the
function via the argument <code>score</code>) in the space of interventional
essential graphs in three phases, starting from the empty graph:
</p>

<dl>
<dt>Forward phase</dt><dd><p>In the forward phase, GIES moves through the space of
interventional essential graphs in steps that correspond to the addition
of a single edge in the space of DAGs; the phase is aborted as soon as
the score cannot be augmented any more.</p>
</dd>
<dt>Backward phase</dt><dd><p>In the backward phase, the algorithm performs moves
that correspond to the removal of a single edge in the space of DAGs
until the score cannot be augmented any more.</p>
</dd>
<dt>Turning phase</dt><dd><p>In the turning phase, the algorithm performs moves
that correspond to the reversal of a single arrow in the space of DAGs
until the score cannot be augmented any more.</p>
</dd>
</dl>

<p>The phases that are actually run are specified with the argument 
<code>phase</code>.  GIES cycles through the specified phases until no augmentation 
of the score is possible any more if <code>iterate = TRUE</code>.  GIES is an 
interventional extension of the GES (greedy equivalence search) algorithm of 
Chickering (2002) which is limited to observational data and hence operates 
on the space of observational instead of interventional Markov equivalence 
classes.
</p>
<p>Using the argument <code>fixedGaps</code>, one can make sure that certain edges
will <em>not</em> be present in the resulting essential graph: if the entry
<code>[i, j]</code> of the matrix passed to <code>fixedGaps</code> is <code>TRUE</code>, there
will be no edge between nodes <code class="reqn">i</code> and <code class="reqn">j</code>.  Using this argument 
can speed up the execution of GIES and allows the user to account for
previous knowledge or other constraints.  The argument <code>adaptive</code> can be
used to relax the constraints encoded by <code>fixedGaps</code> as follows:
</p>

<ul>
<li><p> When <code>adaptive = "vstructures"</code> and the algorithm introduces a 
new v-structure <code class="reqn">a \longrightarrow b \longleftarrow c</code> in the 
forward phase, then the edge <code class="reqn">a - c</code> is removed from the list of fixed 
gaps, meaning that the insertion of an edge between <code class="reqn">a</code> and <code class="reqn">c</code> 
becomes possible even if it was forbidden by the initial matrix passed to 
<code>fixedGaps</code>.
</p>
</li>
<li><p> When <code>adaptive = "triples"</code> and the algorithm introduces a new
unshielded triple in the forward phase (i.e., a subgraph of three nodes
<code class="reqn">a</code>, <code class="reqn">b</code> and <code class="reqn">c</code> where <code class="reqn">a</code> and <code class="reqn">b</code> as well as <code class="reqn">b</code>
and <code class="reqn">c</code> are adjacent, but <code class="reqn">a</code> and <code class="reqn">c</code> are not), then the edge
<code class="reqn">a - c</code> is removed from the list of fixed gaps.
</p>
</li></ul>

<p>This modifications of the forward phase of GIES are inspired by the 
analog modifications in the forward phase of GES, which makes the successive
application of a skeleton estimation method and GES restricted to an 
estimated skeleton a <em>consistent</em> estimator of the DAG (cf. Nandy,
Hauser and Maathuis, 2015). 
</p>


<h3>Value</h3>

<p><code>gies</code> returns a list with the following two components:
</p>
<table>
<tr><td><code>essgraph</code></td>
<td>
<p>An object of class <code><a href="#topic+EssGraph-class">EssGraph</a></code> containing an
estimate of the equivalence class of the underlying DAG.</p>
</td></tr>
<tr><td><code>repr</code></td>
<td>
<p>An object of a class derived from <code><a href="#topic+ParDAG-class">ParDAG</a></code>
containing a (random) representative of the estimated equivalence class.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alain Hauser (<a href="mailto:alain.hauser@bfh.ch">alain.hauser@bfh.ch</a>)
</p>


<h3>References</h3>

<p>D.M. Chickering (2002).  Optimal structure identification with greedy search.
<em>Journal of Machine Learning Research</em> <b>3</b>, 507&ndash;554
</p>
<p>A. Hauser and P. Bühlmann (2012).  Characterization and greedy learning of
interventional Markov equivalence classes of directed acyclic graphs.
<em>Journal of Machine Learning Research</em> <b>13</b>, 2409&ndash;2464.
</p>
<p>P. Nandy, A. Hauser and M. Maathuis (2015).  Understanding consistency in 
hybrid causal structure learning.  <em>arXiv preprint</em> 1507.02608
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ges">ges</a></code>, <code><a href="#topic+Score-class">Score</a></code>, <code><a href="#topic+EssGraph-class">EssGraph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load predefined data
data(gmInt)

## Define the score (BIC)
score &lt;- new("GaussL0penIntScore", gmInt$x, gmInt$targets, gmInt$target.index)

## Estimate the essential graph
gies.fit &lt;- gies(score)

## Plot the estimated essential graph and the true DAG
if (require(Rgraphviz)) {
  par(mfrow=c(1,2))
  plot(gies.fit$essgraph, main = "Estimated ess. graph")
  plot(gmInt$g, main = "True DAG")
}
</code></pre>

<hr>
<h2 id='gmB'>Graphical Model 5-Dim Binary Example Data</h2><span id='topic+gmB'></span>

<h3>Description</h3>

<p>This data set contains a matrix containing information on five binary
variables (coded as 0/1) and the corresonding DAG model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(gmB)</code></pre>


<h3>Format</h3>

<p>The format is a list of two components
</p>

<dl>
<dt>x:</dt><dd><p>Int [1:5000, 1:5] 0 1 1 0 0 1 1 0 1 1 ...</p>
</dd>
<dt>g:</dt><dd><p>Formal class 'graphNEL' [package &quot;graph&quot;] with 6 slots<br />
.. ..@ nodes     : chr [1:5] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ...<br />
.. ..@ edgeL     :List of 5<br />
........      
</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data was generated using Tetrad in the following way. A random DAG
on five nodes was generated; binary variables were assigned to each
node; then conditional probability tables corresponding
to the structure of the generated DAG were constructed. Finally, 5000
samples were drawn using the conditional probability tables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gmB)
## maybe str(gmB) ; plot(gmB) ...
</code></pre>

<hr>
<h2 id='gmD'>Graphical Model Discrete 5-Dim Example Data</h2><span id='topic+gmD'></span>

<h3>Description</h3>

<p>This data set contains a matrix containing information on five
discrete variables (levels are coded as numbers) and the corresonding
DAG model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(gmD)</code></pre>


<h3>Format</h3>

<p>A <code><a href="base.html#topic+list">list</a></code> of two components
</p>

<dl>
<dt>x:</dt><dd><p>a <code><a href="base.html#topic+data.frame">data.frame</a></code> with 5 columns <code>X1</code>
.. <code>X5</code> each coding a discrete variable (aka
<code><a href="base.html#topic+factor">factor</a></code>) with interagesInt [1:10000, 1:5] 2 2 1 1 1 2 2 0 2 0 ...</p>
</dd>
<dt>g:</dt><dd><p>Formal class 'graphNEL' [package &quot;graph&quot;] with 6 slots<br />
.. ..@ nodes     : chr [1:5] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ...<br />
.. ..@ edgeL     :List of 5<br />
........
</p>
</dd>
</dl>

<p>where <code>x</code> is the data matrix and <code>g</code> is the DAG from which
the data were generated.
</p>


<h3>Details</h3>

<p>The data was generated using Tetrad in the following way. A random DAG
on five nodes was generated; discrete variables were assigned to each
node (with 3, 2, 3, 4 and 2 levels); then conditional probability tables
corresponding
to the structure of the generated DAG were constructed. Finally, 10000
samples were drawn using the conditional probability tables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gmD)
str(gmD, max=1)
if(require("Rgraphviz"))
  plot(gmD$ g, main = "gmD $ g --- the DAG of the gmD (10'000 x 5 discrete data)")
## &gt;&gt;&gt;  1 --&gt; 3 &lt;-- 2 --&gt; 4 --&gt; 5
str(gmD$x)
## The number of unique values of each variable:
sapply(gmD$x, function(v) nlevels(as.factor(v)))
## X1 X2 X3 X4 X5
##  3  2  3  4  2
lapply(gmD$x, table) ## the (marginal) empirical distributions
## $X1
##    0    1    2
## 1933 3059 5008
##
## $X2
##    0    1
## 8008 1992
##
## $X3
## .....
</code></pre>

<hr>
<h2 id='gmG'>Graphical Model 8-Dimensional Gaussian Example Data</h2><span id='topic+gmG'></span><span id='topic+gmG8'></span>

<h3>Description</h3>

<p>These two data sets contain a matrix containing information on eight gaussian
variables and the corresonding DAG model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(gmG)</code></pre>


<h3>Format</h3>

<p><code>gmG</code> and <code>gmG8</code> are each a <code><a href="base.html#topic+list">list</a></code> of two components
</p>

<dl>
<dt>x:</dt><dd><p>a numeric matrix <code class="reqn">5000 \times 8</code>.</p>
</dd>
<dt>g:</dt><dd><p>a graph, i.e., of formal <code><a href="base.html#topic+class">class</a></code>
<code>"graphNEL"</code> from package <span class="pkg">graph</span> with 6 slots<br />
.. ..@ nodes     : chr [1:8] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ...<br />
.. ..@ edgeL     :List of 8<br />
........
</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data was generated as indicated below.  First, a random DAG model was
generated, then 5000 samples were drawn from &ldquo;almost&rdquo; this
model, for <code>gmG</code>:  In the previous version, the data generation
<code><a href="#topic+wgtMatrix">wgtMatrix</a></code> had the non-zero weights in reversed order for
each node.  On the other hand, for <code>gmG8</code>, the correct weights
were used in all cases
</p>


<h3>Source</h3>

<p>The data set is <code><a href="base.html#topic+identical">identical</a></code> to the one generated by
</p>
<pre>
    ## Used to generate "gmG"
    set.seed(40)
    p &lt;- 8
    n &lt;- 5000
    ## true DAG:
    vars &lt;- c("Author", "Bar", "Ctrl", "Goal", paste0("V",5:8))
    gGtrue &lt;- randomDAG(p, prob = 0.3, V = vars)
    gmG  &lt;- list(x = rmvDAG(n, gGtrue, back.compatible=TRUE), g = gGtrue)
    gmG8 &lt;- list(x = rmvDAG(n, gGtrue),                       g = gGtrue)
  </pre>


<h3>Examples</h3>

<pre><code class='language-R'>data(gmG)
str(gmG, max=3)
stopifnot(identical(gmG $ g, gmG8 $ g))
if(dev.interactive()) { ## to save time in tests
  round(as(gmG $ g, "Matrix"), 2) # weight ("adjacency") matrix
  plot(gmG $ g)
  pairs(gmG$x, gap = 0,
	panel=function(...) smoothScatter(..., add=TRUE))
}
</code></pre>

<hr>
<h2 id='gmI'>Graphical Model 7-dim IDA Data Examples</h2><span id='topic+gmI'></span><span id='topic+gmI7'></span>

<h3>Description</h3>

<p>This data set contains a matrix containing information on seven gaussian
variables and the corresonding DAG model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(gmI)</code></pre>


<h3>Format</h3>

<p>The two <code>gmI*</code> objects are each a <code><a href="base.html#topic+list">list</a></code> of two components
<code>x</code>, an <code class="reqn">n \times 7</code> numeric matrix, and
<code>g</code>, a DAG, a graph generated by <code><a href="#topic+randomDAG">randomDAG</a></code>.
</p>
<p>See <code><a href="#topic+gmG">gmG</a></code> for more
</p>


<h3>Details</h3>

<p>The data was generated as indicated below.  First, a random DAG was
generated, then samples were drawn from this model, strictly
speaking for <code>gmI7</code> only.
</p>


<h3>Source</h3>

<p>The data sets are <code><a href="base.html#topic+identical">identical</a></code> to those generated by
</p>
<pre>
   ## Used to generate "gmI"
   set.seed(123)
   p &lt;- 7
   myDAG &lt;- randomDAG(p, prob = 0.2) ## true DAG
   gmI  &lt;- list(x = rmvDAG(10000, myDAG, back.compatible=TRUE), g = myDAG)
   gmI7 &lt;- list(x = rmvDAG( 8000, myDAG),                       g = myDAG)
 </pre>


<h3>Examples</h3>

<pre><code class='language-R'>data(gmI)
str(gmI, max=3)
stopifnot(identical(gmI $ g, gmI7 $ g))
if(dev.interactive()) { ## to save time in tests
  round(as(gmI $ g, "Matrix"), 2) # weight ("adjacency") matrix
  plot(gmI $ g)
  pairs(gmI$x, gap = 0,
        panel=function(...) smoothScatter(..., add=TRUE))
}
</code></pre>

<hr>
<h2 id='gmInt'>Graphical Model 8-Dimensional Interventional Gaussian Example Data</h2><span id='topic+gmInt'></span>

<h3>Description</h3>

<p>This data set contains a matrix with an ensemble of observational and
interventional data from eight Gaussian variables.  The corresponding
(data generating) DAG model is also stored. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(gmInt)
</code></pre>


<h3>Format</h3>

<p>The format is a list of four components
</p>

<dl>
<dt>x:</dt><dd><p>Matrix with 5000 rows (one row a measurement) and 8 columns
(corresponding to the 8 variables</p>
</dd>
<dt>targets:</dt><dd><p>List of (mutually exclusive) intervention targets. In this
example, the three entries <code>integer(0)</code>, <code>3</code> and <code>5</code> 
indicate that the data set consists of observational data, interventional
data originating from an intervention at vertex 3, and interventional data
originating from an intervention at vertex 5.</p>
</dd>
<dt>target.index:</dt><dd><p>Vector with 5000 elements. Each entry maps a row of 
<code>x</code> to the corresponding intervention target.  Example:
<code>gmInt$target.index[3322] == 2</code> means that <code>x[3322, ]</code> was 
simulated from an intervention at <code>gmInt$targets[[2]]</code>, i.e. at 
vertex 3.</p>
</dd>
<dt>g:</dt><dd><p>Formal class 'graphNEL' [package &quot;graph&quot;] with 6 slots, 
representing the true DAG from which observational and interventional
data was sampled.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data was generated as indicated below. First, a random DAG model was
generated, then 5000 samples were drawn from this model: 3000 observational
ones, and 1000 each from an intervention at vertex 3 and 5, respectively
(see <code>gmInt$target.index</code>).
</p>


<h3>Source</h3>

<p>The data set is <code><a href="base.html#topic+identical">identical</a></code> to the one generated by </p>
<pre>
  set.seed(40)
  p &lt;- 8
  n &lt;- 5000
  gGtrue &lt;- randomDAG(p, prob = 0.3)
  pardag &lt;- as(gGtrue, "GaussParDAG")
  pardag$set.err.var(rep(1, p))
  targets &lt;- list(integer(0), 3, 5)
  target.index &lt;- c(rep(1, 0.6*n), rep(2, n/5), rep(3, n/5))
  
  x1 &lt;- rmvnorm.ivent(0.6*n, pardag)
  x2 &lt;- rmvnorm.ivent(n/5, pardag, targets[[2]], 
                      matrix(rnorm(n/5, mean = 4, sd = 0.02), ncol = 1))
  x3 &lt;- rmvnorm.ivent(n/5, pardag, targets[[3]], 
                      matrix(rnorm(n/5, mean = 4, sd = 0.02), ncol = 1))
  gmInt &lt;- list(x = rbind(x1, x2, x3), 
                targets = targets, 
                target.index = target.index, 
                g = gGtrue)
  </pre>


<h3>Examples</h3>

<pre><code class='language-R'>data(gmInt)
str(gmInt, max = 3)
pairs(gmInt$x, gap = 0, pch = ".")
</code></pre>

<hr>
<h2 id='gmL'>Latent Variable 4-Dim Graphical Model Data Example</h2><span id='topic+gmL'></span>

<h3>Description</h3>

<p>This data set contains a matrix containing information on four gaussian
variables and the corresonding DAG model containing four observed and
one latent variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(gmL)</code></pre>


<h3>Format</h3>

<p>The format is a list of 2 components
</p>

<dl>
<dt>x:</dt><dd><p> $ x: num [1:10000, 1:4] 0.924 -0.189 1.016 0.363 0.497 ...
..- attr(*, &quot;dimnames&quot;)=List of 2
.. ..$ : NULL
.. ..$ : chr [1:4] &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot;</p>
</dd>
<dt>g:</dt><dd><p> $ g:Formal class 'graphNEL' [package &quot;graph&quot;] with 6 slots
.. ..@ nodes     : chr [1:5] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ...
.. ..@ edgeL     :List of 5
........
</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data was generated as indicated below. First, a random DAG model was
generated with five nodes; then 10000 samples were drawn from this
model; finally, variable one was declared to be latent and
the corresponding column was deleted from the simulated data set.
</p>


<h3>Source</h3>

<pre>
    ## Used to generate "gmL"
    set.seed(47)
    p &lt;- 5
    n &lt;- 10000
    gGtrue &lt;- randomDAG(p, prob = 0.3) ## true DAG
    myX &lt;- rmvDAG(n, gGtrue)
    colnames(myX) &lt;- as.character(1:5)
    gmL &lt;- list(x = myX[,-1], g = gGtrue)
  </pre>


<h3>Examples</h3>

<pre><code class='language-R'>data(gmL)
str(gmL, max=3)

## the graph:
gmL$g
graph::nodes(gmL$g) ; str(graph::edges(gmL$g))
if(require("Rgraphviz"))
  plot(gmL$g, main = "gmL $ g -- latent variable example data")

pairs(gmL $x) # the data
</code></pre>

<hr>
<h2 id='ida'>Estimate Multiset of Possible Joint Total Causal Effects</h2><span id='topic+ida'></span><span id='topic+causalEffect'></span>

<h3>Description</h3>

<p><code>ida()</code> estimates the multiset of possible joint total causal effects
of variables (<code>X</code>) onto variables (<code>Y</code>)
from observational data via adjustment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ida(x.pos, y.pos, mcov, graphEst, method = c("local","optimal","global"),
    y.notparent = FALSE, verbose = FALSE, all.dags = NA, type = c("cpdag", "pdag"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ida_+3A_x.pos">x.pos</code>, <code id="ida_+3A_x">x</code></td>
<td>
<p>Positions of variables <code>X</code> in the covariance matrix.</p>
</td></tr>
<tr><td><code id="ida_+3A_y.pos">y.pos</code>, <code id="ida_+3A_y">y</code></td>
<td>
<p>Positions of variables <code>Y</code> in the covariance matrix.</p>
</td></tr>
<tr><td><code id="ida_+3A_mcov">mcov</code></td>
<td>
<p>Covariance matrix that was used to estimate <code>graphEst</code>.</p>
</td></tr>
<tr><td><code id="ida_+3A_graphest">graphEst</code></td>
<td>
<p>Estimated CPDAG or PDAG. The CPDAG is typically from <code><a href="#topic+pc">pc</a>()</code>: If
the result of <code><a href="#topic+pc">pc</a></code> is <code>pc.fit</code>, the estimated CPDAG
can be obtained by <code>pc.fit@graph</code>. A PDAG can be obtained from the CPDAG by adding background knowledge using <code>addBgKnowledge()</code>.</p>
</td></tr>
<tr><td><code id="ida_+3A_method">method</code></td>
<td>
<p>Character string specifying the method with default <code>"local"</code>.
</p>

<dl>
<dt><code>"global"</code>:</dt><dd><p>The algorithm considers all undirected edges 
in the CPDAG or PDAG, using the possible parents as adjustment sets 
to estimate <em>all</em> possible causal effects. It is hence <em>slow</em>
and can only be applied to singleton <code>X</code>.</p>
</dd> 
<dt><code>"local"</code>:</dt><dd><p>The algorithm only considers edges in the
neighborhood of <code>X</code> in the CPDAG or PDAG, 
using the possible parents as adjustment sets 
to estimate the <em>unique</em> possible causal effects. 
It is hence much <em>faster</em> than <code>"global"</code> 
and can only be applied to singleton <code>X</code>.</p>
</dd>
<dt><code>"optimal"</code>:</dt><dd><p>The algorithm considers only those edges necessary to compute
the possible optimal valid adjustment sets, using these as adjustment sets to estimate 
the <em>unique</em> possible causal effects. It is
hence <em>faster</em> than the <code>"global"</code> option but also slower than <code>"local"</code>. 
It provides more efficient estimates than both alternatives but is also more sensitive to faulty graph estimates. 
Can be applied to sets <code>X</code>.</p>
</dd>
</dl>

<p>See details below.</p>
</td></tr>
<tr><td><code id="ida_+3A_y.notparent">y.notparent</code></td>
<td>
<p>Logical; for singleton <code>X</code> and <code>Y</code>. 
If true, any edge between <code>X</code> and
<code>Y</code> is assumed to be of the form <code>X-&gt;Y</code>. Not implemented for the <code>method="optimal"</code></p>
</td></tr>
<tr><td><code id="ida_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, details on the regressions are printed.</p>
</td></tr>
<tr><td><code id="ida_+3A_all.dags">all.dags</code></td>
<td>
<p>All DAGs in the equivalence class represented by the CPDAG or PDAG 
can be precomputed by <code><a href="#topic+pdag2allDags">pdag2allDags</a>()</code> and passed via
this argument.  In that case, <code><a href="#topic+pdag2allDags">pdag2allDags</a>(..)</code> is not called
internally.
This option is only relevant when using <code>method="global"</code>.</p>
</td></tr>
<tr><td><code id="ida_+3A_type">type</code></td>
<td>
<p>Type of graph <code>"graphEst"</code>; can be of type <code>"cpdag"</code> or <code>"pdag"</code> (e.g. a CPDAG with background knowledge from Meek, 1995)</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>It is assumed that we have observational data from a multivariate Gaussian distribution
faithful to the true (but unknown) underlying causal DAG (without hidden variables). 
Under these assumptions, this function estimates the multiset of possible total joint effects of <code>X</code> on <code>Y</code>. 
Here the total joint effect of <code>X</code> <code class="reqn">= (X_1,X_2)</code> on <code>Y</code> is defined via Pearl's do-calculus as the vector 
<code class="reqn">(E[Y|do(X_1=x_1+1,X_2=x_2)]-E[Y|do(X_1=x_1,X_2=x_2)], E[Y|do(X_1=x_1,X_2=x_2+1)]-E[Y|do(X_1=x_1,X_2=x_2)])</code>, 
with a similar definition for more than two variables. These values are equal to the partial derivatives 
(evaluated at <code class="reqn">x_1,x_2</code>) of <code class="reqn">E[Y|do(X=x_1',X_2=x_2')]</code> with respect to <code class="reqn">x_1</code>' and <code class="reqn">x_2</code>'. 
Moreover, under the Gaussian assumption, these partial derivatives do not depend on the values at which they are evaluated.
</p>
<p>We estimate a <em>set</em> of possible joint total causal effects instead of
the unique joint total causal effect, since it is typically impossible to
identify the latter when the true underlying causal DAG is unknown
(even with an infinite amount of data).  Conceptually, the method
works as follows.  First, we estimate the equivalence class of DAGs
that describe the conditional independence relationships in the data,
using the function <code><a href="#topic+pc">pc</a></code> (see the help file of this
function). For each DAG G in the equivalence class, we apply Pearl's
do-calculus to estimate the total causal effect of <code>X</code> on
<code>Y</code>.  This can be done via a simple linear regression
adjusting for a valid adjustment set. 
</p>
<p>For example, if <code>X</code> and <code>Y</code> are singleton and <code>Y</code> 
is not a parent of <code>X</code>, we can take the regression coefficient of
<code>X</code> in the regression <code>lm(Y ~ X + pa(X,G))</code>, where
<code>pa(X,G)</code> denotes the parents of <code>X</code> in the DAG G; if <code>Y</code>
is a parent of <code>X</code> in G, we can set the estimated causal effect to
zero. 
</p>
<p>If the equivalence class contains <code>k</code> DAGs, this will yield
<code>k</code> estimated total causal effects.  Since we do not know which DAG
is the true causal DAG, we do not know which estimated possible total joint causal
effect of <code>X</code> on <code>Y</code> is the correct one.  Therefore, we return
the entire multiset of <code>k</code> estimated effects (it is a multiset
rather than a set because it can contain duplicate values).
</p>
<p>One can take summary measures of the multiset.  For example, the
minimum absolute value provides a lower bound on the size of the true
causal effect: If the minimum absolute value of all values in the
multiset is larger than one, then we know that the size of the true
causal effect (up to sampling error) must be larger than one.
</p>
<p>If <code>method="global"</code>, the method as described above is carried
out, where all DAGs in the equivalene class of the estimated CPDAG or PDAG
<code>graphEst</code> are computed using the function <code><a href="#topic+pdag2allDags">pdag2allDags</a></code>.
The parent set for each DAG is then used to estimate the corresponding possible
total causal effect. This method is suitable for small graphs (say, up to 10 nodes) and can
only be used for singleton <code>X</code>.
</p>
<p>If <code>method="local"</code>, we only consider all valid possible directions of undirected edges 
that have <code>X</code> as an endpoint.
</p>
<p>In the case of a CPDAG, we consider all
possible directions of undirected edges that have <code>X</code> as an
endpoint, such that no new v-structure is created. 
Maathuis, Kalisch and Buehlmann (2009) showed that there is at least one DAG in
the equivalence class for each such local configuration. Hence, the 
procedure is truly local in this setting.
</p>
<p>In the case of a PDAG, we need to verify for all possible directions whether they lead to an 
amenable max. PDAG if we apply Meek's orientation rules. 
In this setting the complexity of the <code>"local"</code> method is similar to the <code>"optimal"</code> one and it is not truly local.
For details see Section 4.2 in Perkovic, Kalisch and Maathuis (2017).  
</p>
<p>We estimate the total causal effect of <code>X</code> on <code>Y</code> for each
valid configuration as above, using linear regression adjusting for the correspoding possible parents.
As we adjust for the same sets as in the <code>"global"</code> method, it follows that the multisets of total causal effects of
the two methods have the same unique values. They may, however, have different multiplicities.
</p>
<p>Since the parents of <code>X</code> are usually an inefficient valid adjustment set we provide a third method, that uses 
different adjustment sets.  
</p>
<p>If <code>method="optimal"</code>, we do not determine all DAGs in the
equivalence class of the CPDAG or PDAG.  Instead, we only direct edges until
obtaining an amenable PDAG, which is sufficient for computing the optimal 
valid adjustment set. Each amenable PDAG can be obtained by 
orienting the neighborhood of <code>X</code> and then applying Meek's orientation rules, similar to the <code>"local"</code> method 
for PDAGs. This can be done faster than the <code>"global"</code> method but is slower than the <code>"local"</code> method, especially for    CPDAGs. For details see Witte, Henckel, Maathuis and Didelez (2019).
</p>
<p>For each amenable PDAG the corresponding optimal valid adjustment set is computed. 
The optimal set is a valid adjustment set irrespectively of whether <code>X</code> is a singleton.
Hence, as opposed to the other two, this method can be applied to sets <code>X</code>. Sometimes, however, 
a joint total causal effect cannot be estimated via adjustment. In these cases we recommend use of the pcalg function <code><a href="#topic+jointIda">jointIda</a></code>.
</p>
<p>We then estimate the joint total causal effect of <code>X</code> on <code>Y</code> for each
valid configuration with linear regression, adjusting for the possible optimal sets. 
If the estimated graph is correct, each of these regressions is guaranteed 
to be more efficient than the corresponding linear regression with any other valid adjustment set
(see Henckel, Perkovic and Maathuis (2019) for more details). The estimates are, however, more sensitive to graph estimation errors than the ones obtained with the other two methods. 
If <code>X</code> is a singleton, the output of this method is a multiset of the same size as the output of the <code>"local"</code> method. 
</p>
<p>For example, a CPDAG may represent eight DAGs, and the <code>"global"</code> method
may produce an estimate of the multiset of possible total effects
{1.3, -0.5, 0.7, 1.3, 1.3, -0.5, 0.7, 0.7}.
The unique values in this set are -0.5, 0.7 and 1.3, and the
multiplicities are 2, 3 and 3.  The <code>"local"</code> and <code>"optimal"</code> methods, on the other hand,
may prodcue estimates of the set {1.3, -0.5, -0.5, 0.7}.  The unique values are again -0.5,
0.7 and 1.3, but the multiplicities are now 2, 1 and 1.  The fact that
the unique values of the multisets for all three methods
are identical implies that summary measures of the multiset that only
depend on the unique values (such as the minimum absolute value) can
be estimated with all three.
</p>


<h3>Value</h3>

<p>A list of length |<code>Y</code>| of matrices, each containing the possible joint total causal effect of <code>X</code> on one node in <code>Y</code>.
</p>


<h3>Author(s)</h3>

<p>Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>), Emilija Perkovic and Leonard Henckel</p>


<h3>References</h3>

<p>M.H. Maathuis, M. Kalisch, P. Buehlmann (2009).
Estimating high-dimensional intervention effects from observational data.
<em>Annals of Statistics</em> <b>37</b>, 3133&ndash;3164.
</p>
<p>M.H. Maathuis, D. Colombo, M. Kalisch, P. Bühlmann (2010).
Predicting causal effects in large-scale systems from observational data.
<em>Nature Methods</em> <b>7</b>, 247&ndash;248.
</p>
<p>C. Meek (1995). Causal inference and causal explanation with background knowledge,
In <em>Proceedings of UAI 1995</em>, 403-410.
</p>
<p>Markus Kalisch, Martin Maechler, Diego Colombo, Marloes H. Maathuis,
Peter Buehlmann (2012).
Causal inference using graphical models with the R-package pcalg.
<em>Journal of Statistical Software</em> <b>47</b>(11) 1&ndash;26,
<a href="https://doi.org/10.18637/jss.v047.i11">doi:10.18637/jss.v047.i11</a>.
</p>
<p>Pearl (2005). <em>Causality. Models, reasoning and inference</em>.
Cambridge University Press, New York.
</p>
<p>E. Perkovic, M. Kalisch and M.H. Maathuis (2017). Interpreting and using 
CPDAGs with background knowledge. In <em>Proceedings of UAI 2017.</em>
</p>
<p>L. Henckel, E. Perkovic and M.H. Maathuis (2019). Graphical criteria for efficient total 
effect estimation via adjustment in causal linear models.
<em>Working Paper.</em>
</p>
<p>J. Witte, L. Henckel, M.H Maathuis and V. Didelez (2019). On efficient adjustment in causal graphs. 
<em>Working Paper.</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jointIda">jointIda</a></code> for estimating the multiset of possible total
<em>joint</em> effects; <code><a href="#topic+idaFast">idaFast</a></code> for faster estimation of the multiset of
possible total causal effects for several target variables. 
</p>
<p><code><a href="#topic+pc">pc</a></code> for estimating a CPDAG. <code><a href="#topic+addBgKnowledge">addBgKnowledge</a></code> for obtaining a PDAG from CPDAG and background knowledge.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate the true DAG
suppressWarnings(RNGversion("3.5.0"))
set.seed(123)
p &lt;- 10
myDAG &lt;- randomDAG(p, prob = 0.2) ## true DAG
myCPDAG &lt;- dag2cpdag(myDAG) ## true CPDAG
myPDAG &lt;- addBgKnowledge(myCPDAG,2,3) ## true PDAG with background knowledge 2 -&gt; 3
covTrue &lt;- trueCov(myDAG) ## true covariance matrix

## simulate Gaussian data from the true DAG
n &lt;- 10000
dat &lt;- rmvDAG(n, myDAG)

## estimate CPDAG and PDAG -- see  help(pc)
suffStat &lt;- list(C = cor(dat), n = n)
pc.fit &lt;- pc(suffStat, indepTest = gaussCItest, p=p, alpha = 0.01)
pc.fit.pdag &lt;- addBgKnowledge(pc.fit@graph,2,3)

if (require(Rgraphviz)) {
  ## plot the true and estimated graphs
  par(mfrow = c(1,3))
  plot(myDAG, main = "True DAG")
  plot(pc.fit, main = "Estimated CPDAG")
  plot(pc.fit.pdag, main = "Max. PDAG")
}

## Supppose that we know the true CPDAG and covariance matrix
(l.ida.cpdag &lt;- ida(3,10, covTrue, myCPDAG, method = "local", type = "cpdag"))
(o.ida.cpdag &lt;- ida(3,10, covTrue, myCPDAG, method = "optimal", type = "cpdag"))
## Not run: (g.ida.cpdag &lt;- ida(3,10, covTrue, myCPDAG, method = "global", type = "cpdag"))
## All three methods produce the same unique values. 

## Supppose that we know the true PDAG and covariance matrix
(l.ida.pdag &lt;- ida(3,10, covTrue, myPDAG, method = "local", type = "pdag"))
(o.ida.pdag &lt;- ida(3,10, covTrue, myPDAG, method = "optimal", type = "pdag"))
## Not run: (g.ida.pdag &lt;- ida(3,10, covTrue, myPDAG, method = "global", type = "pdag"))
## All three methods produce the same unique values.

## From the true DAG, we can compute the true causal effect of 3 on 10
(ce.3.10 &lt;- causalEffect(myDAG, 10, 3))
## Indeed, this value is contained in the values found by all methods

## When working with data we have to use the estimated CPDAG and
## the sample covariance matrix
(l.ida.est.cpdag &lt;- ida(3,10, cov(dat), pc.fit@graph, method = "local", type = "cpdag"))
(o.ida.est.cpdag &lt;- ida(3,10, cov(dat), pc.fit@graph, method = "optimal", type = "cpdag"))
## Not run: (g.ida.est.cpdag &lt;- ida(3,10, cov(dat), pc.fit@graph,
method = "global", type = "cpdag"))
## End(Not run)
## The unique values of the local and the global method are still identical.
## While not identical, the values of the optimal method are very similar.
## The true causal effect is contained in all three sets, up to a small
## estimation error (0.118 vs. 0.112 with true value 0.114) 

## Similarly, when working with data and background knowledge we have to use the estimated PDAG and
## the sample covariance matrix
(l.ida.est.pdag &lt;- ida(3,10, cov(dat), pc.fit.pdag, method = "local", type = "pdag"))
(o.ida.est.pdag &lt;- ida(3,10, cov(dat), pc.fit.pdag, method = "optimal", type = "pdag"))
## Not run: (g.ida.est.pdag &lt;- ida(3,10, cov(dat), pc.fit.pdag, method = "global", type = "pdag"))
## The unique values of the local and the global method are still identical.
## While not necessarily identical, the values of the optimal method will be similar.

## The true causal effect is contained in both sets, up to a small estimation error

## All three can also be applied to sets y.
(l.ida.cpdag.2 &lt;- ida(3,c(6,10), cov(dat), pc.fit@graph, method = "local", type = "cpdag"))
(o.ida.cpdag.2 &lt;- ida(3,c(6,10), cov(dat), pc.fit@graph, method = "optimal", type = "cpdag"))
## Not run: (g.ida.cpdag.2 &lt;- ida(3,c(6,10), cov(dat), pc.fit@graph,
method = "global", type = "cpdag"))
## End(Not run)
## For the methods local and global we recommend use of idaFast in this case for better performance.

## Note that only the optimal method can be appplied to sets x.
(o.ida.cpdag.2 &lt;- ida(c(2,3),10, cov(dat), pc.fit@graph, method = "optimal", type = "cpdag"))

</code></pre>

<hr>
<h2 id='idaFast'>Multiset of Possible Total Causal Effects for Several Target Var.s</h2><span id='topic+idaFast'></span>

<h3>Description</h3>

<p>This function estimates the multiset of possible total causal effects of
one variable (<code>x</code>) on a <em>several</em> (i.e., a vector of) target
variables (<code>y</code>) from observational data.
</p>
<p><code>idaFast()</code> is more efficient than looping over
<code><a href="#topic+ida">ida</a></code>.  Only <code>method="local"</code> (see <code><a href="#topic+ida">ida</a></code>)
is available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idaFast(x.pos, y.pos.set, mcov, graphEst)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idaFast_+3A_x.pos">x.pos</code></td>
<td>
<p>(integer) position of variable <code>x</code> in the covariance matrix.</p>
</td></tr>
<tr><td><code id="idaFast_+3A_y.pos.set">y.pos.set</code></td>
<td>
<p>integer vector of positions of the target variables
<code>y</code> in the covariance matrix.</p>
</td></tr>
<tr><td><code id="idaFast_+3A_mcov">mcov</code></td>
<td>
<p>covariance matrix that was used to estimate <code>graphEst</code></p>
</td></tr>
<tr><td><code id="idaFast_+3A_graphest">graphEst</code></td>
<td>
<p>estimated CPDAG from the function
<code><a href="#topic+pc">pc</a></code>.  If the output of <code><a href="#topic+pc">pc</a></code> is <code>pc.fit</code>,
then the estimated CPDAG can be obtained by <code>pc.fit@graph</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs
<code><a href="#topic+ida">ida</a>(x.pos, y.pos, mcov, graphEst, method="local",
    y.notparent=FALSE, verbose=FALSE)</code> for all values of <code>y.pos</code> in
<code>y.pos.set</code> simultaneously, in an efficient way.
See (the help about) <code><a href="#topic+ida">ida</a></code> for more details.  Note that the
option <code>y.notparent = TRUE</code> is not implemented, since it is not
clear how to do that efficiently without orienting all edges away from
<code>y.pos.set</code> at the same time, which seems not to be
desirable.  Suggestions are welcome.
</p>


<h3>Value</h3>

<p>Matrix with <code>length(y.pos.set)</code> rows.  Row <code class="reqn">i</code> contains the multiset
of estimated possible total causal effects of <code>x</code> on
<code>y.pos.set[i]</code>.  Note that all multisets in the matrix have the
same length, since the parents of <code>x</code> are the same for all elements
of <code>y.pos.set</code>.
</p>


<h3>Author(s)</h3>

<p>Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>)</p>


<h3>References</h3>

<p>see the list in <code><a href="#topic+ida">ida</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pc">pc</a></code> for estimating a CPDAG, and
<code><a href="#topic+ida">ida</a></code> for estimating the multiset of possible total causal
effects from observational data on only one target variable but with many more
options (than here in <code>idaFast</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate the true DAG
set.seed(123)
p &lt;- 7
myDAG &lt;- randomDAG(p, prob = 0.2) ## true DAG
myCPDAG &lt;- dag2cpdag(myDAG) ## true CPDAG
covTrue &lt;- trueCov(myDAG) ## true covariance matrix

## simulate data from the true DAG
n &lt;- 10000
dat &lt;- rmvDAG(n, myDAG)
cov.d &lt;- cov(dat)

## estimate CPDAG (see help on the function "pc")
suffStat &lt;- list(C = cor(dat), n = n)
pc.fit &lt;- pc(suffStat, indepTest = gaussCItest, alpha = 0.01, p=p)

if(require(Rgraphviz)) {
  op &lt;- par(mfrow=c(1,3))
  plot(myDAG,        main="true DAG")
  plot(myCPDAG,      main="true CPDAG")
  plot(pc.fit@graph, main="pc()-estimated CPDAG")
  par(op)
}

(eff.est1 &lt;- ida(2,5, cov.d, pc.fit@graph))## method = "local" is default
(eff.est2 &lt;- ida(2,6, cov.d, pc.fit@graph))
(eff.est3 &lt;- ida(2,7, cov.d, pc.fit@graph))
## These three computations can be combinded in an efficient way
## by using idaFast :
(eff.estF &lt;- idaFast(2, c(5,6,7), cov.d, pc.fit@graph))

</code></pre>

<hr>
<h2 id='iplotPC'>Plotting a pcAlgo object using the package igraph</h2><span id='topic+iplotPC'></span>

<h3>Description</h3>

<p>Notably, when the <span class="pkg">Rgraphviz</span> package is not easily available,
<code>iplotPC()</code> is an alternative for plotting a <code>"<a href="#topic+pcAlgo-class">pcAlgo</a>"</code> object,
making use of package <span class="pkg">igraph</span>.
</p>
<p>It extracts the adjacency matrix and converts it into an
object from package <span class="pkg">igraph</span> which is then plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iplotPC(pc.fit, labels = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iplotPC_+3A_pc.fit">pc.fit</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object of class <code><a href="#topic+pcAlgo-class">pcAlgo</a></code>, as returned
from <code><a href="#topic+skeleton">skeleton</a>()</code> or <code><a href="#topic+pc">pc</a>()</code>.</p>
</td></tr>
<tr><td><code id="iplotPC_+3A_labels">labels</code></td>
<td>
<p>optional labels for nodes; by default, the labels from
the <code>pc.fit</code> object are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing.  As side effect, the plot of pcAlgo object <code>pc.fit</code>.
</p>


<h3>Note</h3>

<p>Note that this function does not work on <code><a href="#topic+fciAlgo-class">fciAlgo</a></code>
objects, as those need different edge marks.
</p>


<h3>Author(s)</h3>

<p>Markus Kalisch <a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+showEdgeList">showEdgeList</a></code> for printing the edge list of a
<code><a href="#topic+pcAlgo-class">pcAlgo</a></code> object; <code><a href="#topic+showAmat">showAmat</a></code> for
printing the adjacency matrix of a pcAlgo object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load predefined data
data(gmG)
n &lt;- nrow    (gmG8$x)
V &lt;- colnames(gmG8$x)

## define sufficient statistics
suffStat &lt;- list(C = cor(gmG8$x), n = n)
## estimate CPDAG
pc.fit &lt;- pc(suffStat, indepTest = gaussCItest,
             alpha = 0.01, labels = V, verbose = TRUE)

## Edge list
showEdgeList(pc.fit)

## Adjacency matrix
showAmat(pc.fit)

## Plot using package igraph; show estimated CPDAG:
iplotPC(pc.fit)
</code></pre>

<hr>
<h2 id='isValidGraph'>
Check for a DAG, CPDAG or a maximally oriented PDAG

</h2><span id='topic+isValidGraph'></span>

<h3>Description</h3>

<p>Check whether the adjacency matrix <code>amat</code> matches the specified <code>type</code>.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>isValidGraph(amat, type = c("pdag", "cpdag", "dag"), verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isValidGraph_+3A_amat">amat</code></td>
<td>

<p>adjacency matrix of type <code>amat.cpdag</code> (see <code><a href="#topic+amatType">amatType</a></code>)
</p>
</td></tr>
<tr><td><code id="isValidGraph_+3A_type">type</code></td>
<td>

<p>string specifying the type of graph of the adjacency matrix amat. It
can be a DAG (<code>type="dag"</code>), a CPDAG (<code>type="cpdag"</code>) or a
maximally oriented PDAG (<code>type="pdag"</code>) from Meek (1995). 
</p>
</td></tr>
<tr><td><code id="isValidGraph_+3A_verbose">verbose</code></td>
<td>

<p>If TRUE, detailed output on why the graph might not be valid is provided.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a given adjacency matrix <code>amat</code> and graph <code>type</code>, this
function checks whether the two match. 
</p>
<p>For <code>type = "dag"</code> we require that <code>amat</code> does NOT contain
directed cycles. 
</p>
<p>For <code>type = "cpdag"</code> we require that <code>amat</code> does NOT contain
directed or partially directed cycles. We also require that the
undirected part of the CPDAG (represented by <code>amat</code>) is made up of
chordal components and that our graph is maximally oriented according to
rules from Meek (1995). 
</p>
<p>For <code>type = "pdag"</code> we require that <code>amat</code> does NOT contain
directed cycles. We also require that the PDAG is maximally oriented
according to rules from Meek (1995). Additionally, we require that the
adjacency matrix <code>amat1</code> of the CPDAG corresponding to our PDAG
(represented by <code>amat</code>), satisfies <code>isValidGraph(amat =
  amat1,type = "cpdag") == TRUE</code> and that there is no mismatch in the
orientations implied by <code>amat</code> and <code>amat1</code>. We obtain
<code>amat1</code> by extracting the skeleton and v-structures from
<code>amat</code> and then closing the orientation rules from Meek (1995). 
</p>


<h3>Value</h3>

<p>TRUE, if the adjacency matrix <code>amat</code> is of the <code>type</code> specified and FALSE, otherwise.
</p>


<h3>Author(s)</h3>

<p>Emilija Perkovic and Markus Kalisch
</p>


<h3>References</h3>

<p>C. Meek (1995). Causal inference and causal explanation with background knowledge, In Proceedings of UAI 1995, 403-410.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a -&gt; b -&gt; c
amat &lt;- matrix(c(0,1,0, 0,0,1, 0,0,0), 3,3)
colnames(amat) &lt;- rownames(amat) &lt;- letters[1:3]
## graph::plot(as(t(amat), "graphNEL"))             
isValidGraph(amat = amat, type = "dag") ## is a valid DAG
isValidGraph(amat = amat, type = "cpdag") ## not a valid CPDAG 
isValidGraph(amat = amat, type = "pdag") ## is a valid PDAG

## a -- b -- c
amat &lt;- matrix(c(0,1,0, 1,0,1, 0,1,0), 3,3)
colnames(amat) &lt;- rownames(amat) &lt;- letters[1:3]
## plot(as(t(amat), "graphNEL"))             
isValidGraph(amat = amat, type = "dag") ## not a valid DAG
isValidGraph(amat = amat, type = "cpdag") ## is a valid CPDAG
isValidGraph(amat = amat, type = "pdag") ## is a valid PDAG

## a -- b -- c -- d -- a
amat &lt;- matrix(c(0,1,0,1, 1,0,1,0, 0,1,0,1, 1,0,1,0), 4,4)
colnames(amat) &lt;- rownames(amat) &lt;- letters[1:4]
## plot(as(t(amat), "graphNEL"))             
isValidGraph(amat = amat, type = "dag") ## not a valid DAG
isValidGraph(amat = amat, type = "cpdag") ## not a valid CPDAG
isValidGraph(amat = amat, type = "pdag") ## not a valid PDAG
</code></pre>

<hr>
<h2 id='jointIda'>Estimate Multiset of Possible Total Joint Effects</h2><span id='topic+jointIda'></span>

<h3>Description</h3>

<p><code>jointIda()</code> estimates the multiset of possible total joint effects
of a set of intervention variables (<code>X</code>) on another variable (<code>Y</code>)
from observational data.  This is a version of <code><a href="#topic+ida">ida</a></code> that
allows multiple simultaneous interventions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jointIda(x.pos, y.pos, mcov, graphEst = NULL, all.pasets = NULL,
         technique = c("RRC", "MCD"), type = c("pdag", "cpdag", "dag"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jointIda_+3A_x.pos">x.pos</code></td>
<td>
<p>(integer vector) positions of the intervention variables
<code>X</code> in the covariance matrix.</p>
</td></tr>
<tr><td><code id="jointIda_+3A_y.pos">y.pos</code></td>
<td>
<p>(integer) position of variable <code>Y</code> in the covariance
matrix. (<code>y.pos</code> can also be an integer vector, see Note.)</p>
</td></tr>
<tr><td><code id="jointIda_+3A_mcov">mcov</code></td>
<td>
<p>(estimated) covariance matrix.</p>
</td></tr>
<tr><td><code id="jointIda_+3A_graphest">graphEst</code></td>
<td>
<p>(graphNEL object) Estimated CPDAG or PDAG. The CPDAG is typically from <code><a href="#topic+pc">pc</a>()</code>: If
the result of <code><a href="#topic+pc">pc</a></code> is <code>pc.fit</code>, the estimated CPDAG
can be obtained by <code>pc.fit@graph</code>. The PDAG can be obtained from CPDAG by adding bacground knowledge using <code>addBgKnowledge()</code>.  <code>graphEst</code> can only be considered if
<code>all.pasets</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="jointIda_+3A_all.pasets">all.pasets</code></td>
<td>
<p>(an optional argument and the default is
<code>NULL</code>) A list where each element is a list of size
<code>length(x.pos)</code>.  Each sub-list <code>all.pasets[[i]]</code> contains
possible parent sets of <code>x.pos</code> in the same order, i.e.,
<code>all.pasets[[i]][[j]]</code> is a possible parent set of
<code>x.pos[j]</code>.  This option can be used if possible parent sets of
the intervention variables are known.</p>
</td></tr>
<tr><td><code id="jointIda_+3A_technique">technique</code></td>
<td>
<p>character string specifying the technique that will
be used to estimate the total joint causal effects (given the parent
sets), see details below.
</p>

<dl>
<dt><code>"RRC"</code>:</dt><dd><p>Recursive regressions for causal effects.</p>
</dd>
<dt><code>"MCD"</code>:</dt><dd><p>Modifying the Cholesky decomposition.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="jointIda_+3A_type">type</code></td>
<td>
<p>Type of graph <code>"graphEst"</code>; can be of type <code>"cpdag"</code>, <code>"pdag"</code> (e.g. a CPDAG with background knowledge from Meek, 1995) or <code>"dag"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is assumed that we have observational data that are multivariate
Gaussian and faithful to the true (but unknown) underlying causal DAG
(without hidden variables).  Under these assumptions, this function
estimates the multiset of possible total joint effects of <code>X</code> on
<code>Y</code>. Here the total joint effect of <code class="reqn">X = (X_1,X_2)</code> on
<code class="reqn">Y</code> is defined via Pearl's do-calculus as the vector
<code class="reqn">(E[Y|do(X_1=x_1+1,X_2=x_2)]-E[Y|do(X_1=x_1,X_2=x_2)], E[Y|do(X_1=x_1,X_2=x_2+1)]-E[Y|do(X_1=x_1,X_2=x_2)])</code>,
with a similar definition for more than two variables.  These values
are equal to the partial derivatives (evaluated at <code class="reqn">(x_1,x_2)</code>) of
<code class="reqn">E[Y|do(X=x_1',X_2=x_2')]</code> with respect to <code class="reqn">x_1'</code> and
<code class="reqn">x_2'</code>.  Moreover, under the Gaussian assumption, these partial
derivatives do not depend on the values at which they are evaluated.
</p>
<p>We estimate a <em>multiset</em> of possible total joint effects instead of
the unique total joint effect, since it is typically impossible to
identify the latter when the true underlying causal DAG is unknown
(even with an infinite amount of data).  
</p>
<p>Conceptually, the method
works as follows.  First, we estimate the CPDAG or PDAG based on the data.
The CPDAG represents the equivalence class of DAGs and can be estimated 
from observational data with the function <code><a href="#topic+pc">pc</a></code> (see the help file of this function). 
</p>
<p>The PDAG contains more orientations than the CPDAG and thus, represents a 
smaller equivalence class of DAGs, compared to the CPDAG. We can obtain a PDAG if
we have background knowledge of, for example, certain edge orientations of
undirected edges in the CPDAG. We obtain the PDAG by adding these
orientations to the CPDAG using the function <code><a href="#topic+addBgKnowledge">addBgKnowledge</a></code> 
(see the help file of this function). 
</p>
<p>Then using the CPDAG or PDAG we extract a collection of  &quot;jointly valid&quot; parent sets of the intervention variables from the
estimated CPDAG. For each set of jointly valid parent sets we apply
RRC (recursive regressions for causal effects) or MCD (modifying the
Cholesky decomposition) to estimate the total joint effect of <code>X</code>
on <code>Y</code> from the sample covariance matrix (see Section 3 of Nandy et. al, 2015).
</p>


<h3>Value</h3>

<p>A matrix representing the multiset containing the estimated
possible total joint effects of <code>X</code> on <code>Y</code>.  The number of
rows is equal to <code>length(x.pos)</code>, i.e., each column represents a
vector of possible joint causal effects.
</p>


<h3>Note</h3>

<p>For a single variable <code>X</code>, <code>jointIda()</code> estimates the
same quantities as <code>ida()</code>. 
If <code>graphEst</code> is of <code>type = "cpdag"</code>, <code>jointIda()</code> obtains 
<code>all.pasets</code> by using the semi-local approach described in Section 5 in Nandy et. al, (2015).
Nandy et. al, (2015) show that <code>jointIda()</code> yields 
correct multiplicities of the distinct elements of the resulting multiset (in the sense that it matches
<code>ida()</code> with <code>method="global"</code> up to a constant factor).
</p>
<p>If <code>graphEst</code> is of <code>type = "pdag"</code>,  <code>jointIda()</code> obtains 
<code>all.pasets</code> by using the semi-local approach described in Algorithm 2, 
Section 4.2 in Perkovic et. al (2017). For this case, <code>jointIda()</code> does not necessarily yield 
the correct multiplicities of the distinct elements of the resulting multiset (it behaves similarly to
<code>ida()</code> with <code>method="local"</code>).
</p>
<p><code>jointIda()</code> (like <code><a href="#topic+idaFast">idaFast</a></code>) also allows direct
computation of the total joint effect of a set of intervention
variables <code>X</code> on another set of target variables <code>Y</code>. In
this case, <code>y.pos</code> must be an integer vector containing positions
of the target variables <code>Y</code> in the covariance matrix and the
output is a list of matrices that correspond to the variables in
<code>Y</code> in the same order. This method is slightly more efficient
than looping over <code>jointIda()</code> with single target variables, if
<code>all.pasets</code> is not specified.
</p>


<h3>Author(s)</h3>

<p>Preetam Nandy, Emilija Perkovic
</p>


<h3>References</h3>

<p>P. Nandy, M.H. Maathuis and T.S. Richardson (2017).
Estimating the effect of joint interventions from observational data
in sparse high-dimensional settings. In <em>Annals of Statistics</em>.
</p>
<p>E. Perkovic, M. Kalisch and M.H. Maathuis (2017). Interpreting and using 
CPDAGs with background knowledge. In <em>Proceedings of UAI 2017</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ida">ida</a></code>, the simple version;
<code><a href="#topic+pc">pc</a></code> for estimating a CPDAG.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create a weighted DAG
p &lt;- 6
V &lt;- as.character(1:p)
edL &lt;- list(
  "1" = list(edges=c(3,4), weights=c(1.1,0.3)),
  "2" = list(edges=c(6),  weights=c(0.4)),
  "3" = list(edges=c(2,4,6),weights=c(0.6,0.8,0.9)),
  "4" = list(edges=c(2),weights=c(0.5)),
  "5" = list(edges=c(1,4),weights=c(0.2,0.7)),
  "6" = NULL)
myDAG &lt;- new("graphNEL", nodes=V, edgeL=edL, edgemode="directed") ## true DAG
myCPDAG &lt;- dag2cpdag(myDAG) ## true CPDAG
myPDAG &lt;- addBgKnowledge(myCPDAG,1,3) ## true PDAG with background knowledge 1 -&gt; 3
covTrue &lt;- trueCov(myDAG) ## true covariance matrix

n &lt;- 1000
## simulate Gaussian data from the true DAG
dat &lt;- if (require("mvtnorm")) {
  set.seed(123)
  rmvnorm(n, mean=rep(0,p), sigma=covTrue)
} else readRDS(system.file(package="pcalg", "external", "N_6_1000.rds"))

## estimate CPDAG and PDAG -- see  help(pc), help(addBgKnoweldge)
suffStat &lt;- list(C = cor(dat), n = n)
pc.fit &lt;- pc(suffStat, indepTest = gaussCItest, p = p, alpha = 0.01, u2pd="relaxed")
pc.fit.pdag &lt;- addBgKnowledge(pc.fit@graph,1,3)

if (require(Rgraphviz)) {
  ## plot the true and estimated graphs
  par(mfrow = c(1,3))
  plot(myDAG, main = "True DAG")
  plot(pc.fit, main = "Estimated CPDAG")
  plot(pc.fit.pdag, main = "Estimated PDAG")
}

## Suppose that we know the true CPDAG and covariance matrix
jointIda(x.pos=c(1,2), y.pos=6, covTrue, graphEst=myCPDAG, technique="RRC", type = "cpdag")
jointIda(x.pos=c(1,2), y.pos=6, covTrue, graphEst=myCPDAG, technique="MCD", type = "cpdag")

## Suppose that we know the true PDAG and covariance matrix
jointIda(x.pos=c(1,2), y.pos=6, covTrue, graphEst=myPDAG, technique="RRC", type = "pdag")
jointIda(x.pos=c(1,2), y.pos=6, covTrue, graphEst=myPDAG, technique="MCD", type = "pdag")

## Instead of knowing the true CPDAG or PDAG, it is enough to know only
## the jointly valid parent sets of the intervention variables
## to use RRC or MCD
## all.jointly.valid.pasets:
ajv.pasets &lt;- list(list(5,c(3,4)),list(integer(0),c(3,4)),list(3,c(3,4)))
jointIda(x.pos=c(1,2), y.pos=6, covTrue, all.pasets=ajv.pasets, technique="RRC")
jointIda(x.pos=c(1,2), y.pos=6, covTrue, all.pasets=ajv.pasets, technique="MCD")

## From the true DAG, we can compute the true total joint effects
## using RRC or MCD
cat("Dim covTrue: ", dim(covTrue),"\n")
jointIda(x.pos=c(1,2), y.pos=6, covTrue, graphEst=myDAG, technique="RRC", type = "dag")
jointIda(x.pos=c(1,2), y.pos=6, covTrue, graphEst=myDAG, technique="MCD", type = "dag")


## When working with data, we have to use the estimated CPDAG or PDAG
## and the sample covariance matrix
jointIda(x.pos=c(1,2), y.pos=6, cov(dat), graphEst=pc.fit@graph, technique="RRC", type = "cpdag")
jointIda(x.pos=c(1,2), y.pos=6, cov(dat), graphEst=pc.fit@graph, technique="MCD", type = "cpdag")

jointIda(x.pos=c(1,2), y.pos=6, cov(dat), graphEst=pc.fit.pdag, technique="RRC", type = "pdag")
jointIda(x.pos=c(1,2), y.pos=6, cov(dat), graphEst=pc.fit.pdag, technique="MCD", type = "pdag")
## RRC and MCD can produce different results when working with data

## jointIda also works when x.pos has length 1 and in the following example
## it gives the same result as ida() (see Note)
##
## When the CPDAG is known
jointIda(x.pos=1, y.pos=6, covTrue, graphEst=myCPDAG, technique="RRC", type = "cpdag")
ida(x.pos=1, y.pos=6, covTrue, graphEst=myCPDAG, method="global", type = "cpdag")

## When the PDAG is known
jointIda(x.pos=1, y.pos=6, covTrue, graphEst=myPDAG, technique="RRC", type = "pdag")
ida(x.pos=1, y.pos=6, covTrue, graphEst=myPDAG, method="global", type = "pdag")

## When the DAG is known
jointIda(x.pos=1, y.pos=6, covTrue, graphEst=myDAG, technique="RRC", type = "dag")
ida(x.pos=1, y.pos=6, covTrue, graphEst=myDAG, method="global")
## Note that, causalEffect(myDAG,y=6,x=1) does not give the correct value in this case,
## since this function requires that the variables are in a causal order.

</code></pre>

<hr>
<h2 id='legal.path'>Check if a 3-node-path is Legal</h2><span id='topic+legal.path'></span>

<h3>Description</h3>

<p>Check if the path <code class="reqn">a--b--c</code> is legal.
</p>
<p>A 3-node path <code class="reqn">a--b--c</code>  is &ldquo;legal&rdquo; iff either
<code class="reqn">b</code> is a collider or <code class="reqn">a--b--c</code> is a triangle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>legal.path(a, b, c, amat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="legal.path_+3A_a">a</code>, <code id="legal.path_+3A_b">b</code>, <code id="legal.path_+3A_c">c</code></td>
<td>
<p>(integer) positions in adjacency matrix of nodes <code class="reqn">a</code>,
<code class="reqn">b</code>, and <code class="reqn">c</code>, respectively.</p>
</td></tr>
<tr><td><code id="legal.path_+3A_amat">amat</code></td>
<td>
<p>Adjacency matrix (coding 0,1,2,3 for no edge, circle,
arrowhead, tail; e.g., <code>amat[a,b] = 2</code> and <code>amat[b,a] = 3</code>
implies a -&gt; b)</p>
</td></tr> 
</table>


<h3>Value</h3>

<p><code>TRUE</code> if path is legal, otherwise <code>FALSE</code>.
</p>


<h3>Note</h3>

<p>Prerequisite: <code class="reqn">a--b--c</code> <em>must</em> be in a path (and
this is <em>not</em> checked by <code>legal.path()</code>).
</p>


<h3>Author(s)</h3>

<p>Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>amat &lt;- matrix( c(0,1,1,0,0, 2,0,1,0,0, 2,2,0,2,1,
                  0,0,1,0,0, 0,0,2,0,0), 5,5)
legal.path(1,3,5, amat)
legal.path(1,2,3, amat)
legal.path(2,3,4, amat)
</code></pre>

<hr>
<h2 id='LINGAM'>Linear non-Gaussian Acyclic Models (LiNGAM)</h2><span id='topic+lingam'></span><span id='topic+LINGAM'></span>

<h3>Description</h3>

<p>Fits a Linear non-Gaussian Acyclic Model (LiNGAM) to the data and
returns the corresponding DAG.
</p>
<p>For details, see the reference below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lingam(X, verbose = FALSE)

## For back-compatibility; this is *deprecated*
LINGAM(X, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LINGAM_+3A_x">X</code></td>
<td>
<p>n x p data matrix (n: sample size, p: number of variables).</p>
</td></tr>
<tr><td><code id="LINGAM_+3A_verbose">verbose</code></td>
<td>
<p>logical or integer indicating that increased diagnostic output is to
be provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>lingam()</code> returns an <span class="rlang"><b>R</b></span> object of (S3) class <code>"LINGAM"</code>,
basically a <code><a href="base.html#topic+list">list</a></code> with components
</p>
<table>
<tr><td><code>Bpruned</code></td>
<td>
<p>a <code class="reqn">p \times p</code> matrix <code class="reqn">B</code> of linear
coefficients, where <code class="reqn">B_{i,j}</code> corresponds to a directed edge
from <code class="reqn">j</code> to <code class="reqn">i</code>.


</p>
</td></tr>
<tr><td><code>stde</code></td>
<td>
<p>a vector of length <code class="reqn">p</code> with the standard deviations of
the estimated residuals</p>
</td></tr>
<tr><td><code>ci</code></td>
<td>
<p>a vector of length <code class="reqn">p</code> with the intercepts of each
equation
<br /> ..................
<br /> </p>
</td></tr>
</table>
<p><code>LINGAM()</code> &mdash; <em>deprecated now</em> &mdash; returns a <code><a href="base.html#topic+list">list</a></code> with components
</p>
<table>
<tr><td><code>Adj</code></td>
<td>
<p>a <code class="reqn">p \times p</code> 0/1 adjacency matrix <code class="reqn">A</code>.
<code>A[i,j] == 1</code> corresponds to a directed edge from i to j.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p><code class="reqn">p \times p</code> matrix of corresponding linear
coefficients.  Note it corresponds to the <em>transpose</em> of
<code>Adj</code>, i.e., <code>identical( Adj, t(B) != 0 )</code> is true.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Of <code>LINGAM()</code> and the underlying functionality,

Patrik Hoyer &lt;patrik.hoyer@helsinki.fi&gt;, Doris Entner
&lt;entnerd@hotmail.com&gt;, Antti Hyttinen &lt;antti.hyttinen@cs.helsinki.fi&gt;
and Jonas Peters &lt;jonas.peters@tuebingen.mpg.de&gt;.
</p>


<h3>References</h3>

<p>S. Shimizu, P.O. Hoyer, A. Hyv\&quot;arinen, A. Kerminen (2006)
A Linear Non-Gaussian Acyclic Model for Causal Discovery;
<em>Journal of Machine Learning Research</em> <b>7</b>, 2003&ndash;2030.
</p>


<h3>See Also</h3>

<p><code>fastICA</code> from package <span class="pkg">fastICA</span> is used.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################################################
## Exp 1
##################################################
set.seed(1234)
n &lt;- 500
eps1 &lt;- sign(rnorm(n)) * sqrt(abs(rnorm(n)))
eps2 &lt;- runif(n) - 0.5

x2 &lt;- 3 + eps2
x1 &lt;- 0.9*x2 + 7 + eps1

#truth: x1 &lt;- x2
trueDAG &lt;- cbind(c(0,1),c(0,0))

X &lt;- cbind(x1,x2)
res &lt;- lingam(X)

cat("true DAG:\n")
show(trueDAG)

cat("estimated DAG:\n")
as(res, "amat")

cat("\n true constants:\n")
show(c(7,3))
cat("estimated constants:\n")
show(res$ci)

cat("\n true (sample) noise standard deviations:\n")
show(c(sd(eps1), sd(eps2)))
cat("estimated noise standard deviations:\n")
show(res$stde)


##################################################
## Exp 2
##################################################
set.seed(123)
n &lt;- 500
eps1 &lt;- sign(rnorm(n)) * sqrt(abs(rnorm(n)))
eps2 &lt;- runif(n) - 0.5
eps3 &lt;- sign(rnorm(n)) * abs(rnorm(n))^(1/3)
eps4 &lt;- rnorm(n)^2

x2 &lt;-                eps2
x1 &lt;-   0.9*x2     + eps1
x3 &lt;-   0.8*x2     + eps3
x4 &lt;- -x1  -0.9*x3 + eps4

X &lt;- cbind(x1,x2,x3,x4)

trueDAG &lt;- cbind(x1 = c(0,1,0,0),
                 x2 = c(0,0,0,0),
                 x3 = c(0,1,0,0),
                 x4 = c(1,0,1,0))
## x4 &lt;- x3 &lt;- x2 -&gt; x1 -&gt; x4
## adjacency matrix:
## 0 0 0 1
## 1 0 1 0
## 0 0 0 1
## 0 0 0 0

res1 &lt;- lingam(X, verbose = TRUE)# details on LINGAM
res2 &lt;- lingam(X, verbose = 2)   # details on LINGAM and fastICA
## results are the same, of course:
stopifnot(identical(res1, res2))
cat("true DAG:\n")
show(trueDAG)

cat("estimated DAG:\n")
as(res1, "amat")
</code></pre>

<hr>
<h2 id='mat2targets'>Conversion between an intervention matrix and a list of intervention 
targets</h2><span id='topic+mat2targets'></span><span id='topic+targets2mat'></span>

<h3>Description</h3>

<p>In a data set with <code class="reqn">n</code> measurements of <code class="reqn">p</code> variables, intervened
variables can be specified in two ways:
</p>

<ul>
<li><p> with a <code><a href="base.html#topic+logical">logical</a></code> intervention matrix of dimension
<code class="reqn">n \times p</code>, where the entry <code>[i, j]</code> indicates whether 
variable <code class="reqn">j</code> has been intervened in measurement <code class="reqn">i</code>; or
</p>
</li>
<li><p> with a list of (unique) intervention targets and a 
<code class="reqn">p</code>-dimensional vector indicating the indices of the intervention
targets of the <code class="reqn">p</code> measurements.
</p>
</li></ul>

<p>The function <code>mat2targets</code> converts the first representation to the
second one, the function <code>targets2mat</code> does the reverse conversion.  The
second representation can be used to create scoring objects (see 
<code><a href="#topic+Score-class">Score</a></code>) and to run causal inference methods based on 
interventional data such as <code><a href="#topic+gies">gies</a></code> or <code><a href="#topic+simy">simy</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat2targets(A)
targets2mat(p, targets, target.index)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat2targets_+3A_a">A</code></td>
<td>
<p>Logical matrix with <code class="reqn">n</code> rows and <code class="reqn">p</code> columns, where <code class="reqn">n</code>
is the sample size of a data set with jointly interventional and 
observational data, and <code class="reqn">p</code> is the number of variables.  <code>A[i, j]</code>
is <code>TRUE</code> iff variable <code>j</code> is intervened in data point <code>i</code>.</p>
</td></tr>
<tr><td><code id="mat2targets_+3A_p">p</code></td>
<td>
<p>Number of variables</p>
</td></tr>
<tr><td><code id="mat2targets_+3A_targets">targets</code></td>
<td>
<p>List of unique intervention targets</p>
</td></tr>
<tr><td><code id="mat2targets_+3A_target.index">target.index</code></td>
<td>
<p>Vector of intervention target indices.  The intervention
target of data point <code>i</code> is encoded as 
<code>targets[[target.index[i]]]</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>mat2targets</code> returns a list with two components:
</p>
<table>
<tr><td><code>targets</code></td>
<td>
<p>A list of unique intervention targets.</p>
</td></tr>
<tr><td><code>target.index</code></td>
<td>
<p>A vector of intervention target indices. The intervention
target of data point <code>i</code> is encoded as 
<code>targets[[target.index[i]]]</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alain Hauser (<a href="mailto:alain.hauser@bfh.ch">alain.hauser@bfh.ch</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Score-class">Score</a></code>, <code><a href="#topic+gies">gies</a></code>, <code><a href="#topic+simy">simy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Specify interventions using a matrix
p &lt;- 5
n &lt;- 10
A &lt;- matrix(FALSE, nrow = n, ncol = p)
for (i in 1:n) A[i, (i-1) %% p + 1] &lt;- TRUE

## Generate list of intervention targets and corresponding indices
target.list &lt;- mat2targets(A)

for (i in 1:length(target.list$target.index))
  sprintf("Intervention target of %d-th data point: %d", 
    i, target.list$targets[[target.list$target.index[i]]]) 

## Convert back to matrix representation
all(A == targets2mat(p, target.list$targets, target.list$target.index))
</code></pre>

<hr>
<h2 id='mcor'>Compute (Large) Correlation Matrix</h2><span id='topic+mcor'></span>

<h3>Description</h3>

<p>Compute a correlation matrix, possibly by robust methods, applicable also
for the case of a large number of variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcor(dm, method = c("standard", "Qn", "QnStable",
                    "ogkScaleTau2",  "ogkQn", "shrink"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcor_+3A_dm">dm</code></td>
<td>
<p>numeric data matrix; rows are observiations
(&ldquo;samples&rdquo;), columns are variables.</p>
</td></tr>
<tr><td><code id="mcor_+3A_method">method</code></td>
<td>
<p>a string; <code>"standard"</code> (default), <code>"Qn"</code>,
<code>"QnStable"</code>, <code>"ogkQn"</code> and <code>"shrink"</code> envokes standard,
elementwise robust (based on <code class="reqn">Q_n</code> scale estimator, see
<code><a href="robustbase.html#topic+Qn">Qn</a></code>), robust (<code class="reqn">Q_n</code> using OGK, see
<code><a href="robustbase.html#topic+covOGK">covOGK</a></code>) or shrinked 
correlation estimate respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>"standard"</code> method envokes a standard correlation estimator. <code>"Qn"</code>
envokes a robust, elementwise correlation estimator based on the Qn scale
estimte. <code>"QnStable"</code> also uses the Qn scale estimator, but uses an
improved way of transforming that into the correlation
estimator. <code>"ogkQn"</code> envokes a correlation estimator based on Qn using
OGK. <code>"shrink"</code> is only useful when used with pcSelect. An optimal
shrinkage parameter is used. Only correlation between response and
covariates is shrinked.
</p>


<h3>Value</h3>

<p>A correlation matrix estimated by the specified method.
</p>


<h3>Author(s)</h3>

<p>Markus Kalisch <a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a> and Martin Maechler
</p>


<h3>References</h3>

<p>See those in the help pages for <code><a href="robustbase.html#topic+Qn">Qn</a></code> and
<code><a href="robustbase.html#topic+covOGK">covOGK</a></code> from package <span class="pkg">robustbase</span>.






</p>


<h3>See Also</h3>

<p><code><a href="robustbase.html#topic+Qn">Qn</a></code> and <code><a href="robustbase.html#topic+covOGK">covOGK</a></code>
from package <span class="pkg">robustbase</span>.
<code><a href="#topic+pcorOrder">pcorOrder</a></code> for computing partial correlations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## produce uncorrelated normal random variables
set.seed(42)
x &lt;- rnorm(100)
y &lt;- 2*x + rnorm(100)
## compute correlation of var1 and var2
mcor(cbind(x,y), method="standard")

## repeat but this time with heavy-tailed noise
yNoise &lt;- 2*x + rcauchy(100)
mcor(cbind(x,yNoise), method="standard") ## shows almost no correlation
mcor(cbind(x,yNoise), method="Qn")       ## shows a lot correlation
mcor(cbind(x,yNoise), method="QnStable") ## shows still much correlation
mcor(cbind(x,yNoise), method="ogkQn")    ## ditto
</code></pre>

<hr>
<h2 id='opt.target'>Get an optimal intervention target</h2><span id='topic+opt.target'></span>

<h3>Description</h3>

<p>Given a (observational or interventional) essential graph (or &quot;CPDAG&quot;), find
the optimal intervention target that maximizes the number of edges that can
be oriented after the intervention.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opt.target(essgraph, max.size, use.node.names = TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opt.target_+3A_essgraph">essgraph</code></td>
<td>
<p>An <code><a href="#topic+EssGraph-class">EssGraph</a></code> or
<code>graphNEL</code> object representing a (observational or
interventional) essential graph (or &quot;CPDAG&quot;).</p>
</td></tr>
<tr><td><code id="opt.target_+3A_max.size">max.size</code></td>
<td>
<p>Maximum size of the intervention target. Only 1 and the
number of vertices of <code>essgraph</code> are allowed; the latter means no size
limit is applied (the default if the parameter is missing).</p>
</td></tr>
<tr><td><code id="opt.target_+3A_use.node.names">use.node.names</code></td>
<td>
<p>Indicates if the intervention target should be
returned as a list of node names (if <code>TRUE</code>) or indices (if
<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements active learning strategies for structure learning
from interventional data, one that calculates an optimal single-vertex
intervention target, and one that calculates an optimal intervention target
of arbitrary size. &quot;Optimal&quot; means the proposed intervention target guarantees
the highest number of edges that can be oriented after performing the
intervention, assuming the essential graph provided as input is the true
essential graph under the currently available interventional data (i.e.,
neglecting possible estimation errors).
</p>
<p>Implementation corresponds to algorithms &quot;OptSingle&quot; and &quot;OptUnb&quot; published
in Hauser and Bühlmann (2012).
</p>


<h3>Value</h3>

<p>A character vector of node names (if <code>use.node.names = TRUE</code>), or an
integer vector of node indices (if <code>use.node.names = FALSE</code>) indicating
the optimal intervention target.
</p>


<h3>Author(s)</h3>

<p>Alain Hauser (<a href="mailto:alain.hauser@math.ethz.ch">alain.hauser@math.ethz.ch</a>)
</p>


<h3>References</h3>

<p>A. Hauser and P. Bühlmann (2012). Two optimal strategies for active learning
of causal models from interventions. <em>Proceedings of the 6th European
Workshop on Probabilistic Graphical Models (PGM-2012)</em>, 123&ndash;130
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EssGraph-class">EssGraph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load predefined data
data(gmG)

## Define the score (BIC)
score &lt;- new("GaussL0penObsScore", gmG8$x)

## Estimate the essential graph using GES
ges.fit &lt;- ges(score)
essgraph &lt;- ges.fit$essgraph

## Plot the estimated essential graph
if (require(Rgraphviz)) {
  plot(essgraph, main = "Estimated CPDAG")
}
## The CPDAG has 1 unoriented component with 3 edges (Author &lt;-&gt; Bar, Bar &lt;-&gt;
## Ctrl, Bar &lt;-&gt; V5)

## Get optimal single-vertex and unbounded intervention target
opt.target(essgraph, max.size = 1)
opt.target(essgraph, max.size = essgraph$node.count())
</code></pre>

<hr>
<h2 id='optAdjSet'>Compute the optimal adjustment set</h2><span id='topic+optAdjSet'></span>

<h3>Description</h3>

<p><code>optAdjSet</code> computes the optimal valid adjustment set relative to the variables (<code>X</code>,<code>Y</code>) in the given graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optAdjSet(graphEst,x.pos,y.pos)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optAdjSet_+3A_graphest">graphEst</code></td>
<td>
<p>graphNel object or adjacency matrix of type amat.cpdag.</p>
</td></tr>
<tr><td><code id="optAdjSet_+3A_x.pos">x.pos</code>, <code id="optAdjSet_+3A_x">x</code></td>
<td>
<p>Positions of variables <code>X</code> in the covariance matrix.</p>
</td></tr>
<tr><td><code id="optAdjSet_+3A_y.pos">y.pos</code>, <code id="optAdjSet_+3A_y">y</code></td>
<td>
<p>Positions of variables <code>Y</code> in the covariance matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose we have data from a linear SEM compatible with a known causal graph <code>G</code> and our aim is to estimate the total joint effect of <code>X</code> on <code>Y</code>. Here the total joint effect of <code>X</code> <code class="reqn">= (X_1,X_2)</code> on <code>Y</code> is defined via Pearl's do-calculus as the vector <code class="reqn">(E[Y|do(X_1=x_1+1,X_2=x_2)]-E[Y|do(X_1=x_1,X_2=x_2)], E[Y|do(X_1=x_1,X_2=x_2+1)]-E[Y|do(X_1=x_1,X_2=x_2)])</code>, with a similar definition for more than two variables. These values are equal to the partial derivatives (evaluated at <code class="reqn">x_1,x_2</code>) of <code class="reqn">E[Y|do(X=x_1',X_2=x_2')]</code> with respect to <code class="reqn">x_1</code>' and <code class="reqn">x_2</code>'. Moreover, under the linearity assumption, these partial derivatives do not depend on the values at which they are evaluated.
</p>
<p>It is possible to estimate the total joint effect of <code>X</code> on <code>Y</code> with a simple linear regression of the form <code>lm(Y ~ X + Z)</code>, if and only if the covariate set <code>Z</code> is a valid adjustment set (see Perkovic et al. (2018)). Often, however, there are multiple such valid adjustment sets, providing total effect estimates with varying accuracies. Suppose that there exists a valid adjustment set relative to (<code>X</code>,<code>Y</code>) in causal graph <code>G</code>, and each node in Y is a descendant of X, then there exists a valid adjustment which provides the total effect estimate with the optimal asymptotic variance, which we will refer to as <code>O(X,Y,G)</code> (Henckel et al., 2019). This function returns this optimal valid adjustment set <code>O(X,Y,G)</code>. 
</p>
<p>The restriction that each node in <code>Y</code> be a descendant of the node set <code>X</code> is not notable, as the total effect of the node set <code>X</code> on a non-descendant is always 0. If provided with a node set <code>Y</code> that does not fulfill this condition this function computes a pruned node set <code>Y2</code> by removing all nodes from <code>Y</code> that are not descendants of <code>X</code> and returns <code>O(X,Y2,G)</code> instead. The user will be alerted to this and given the pruned set <code>Y2</code>.
</p>


<h3>Value</h3>

<p>A vector with the positions of the nodes of the optimal set O(<code>X</code>,<code>Y</code>,<code>G</code>).
</p>


<h3>Author(s)</h3>

<p>Leonard Henckel
</p>


<h3>References</h3>

<p>E. Perković, J. Textor, M. Kalisch and M.H. Maathuis (2018). Complete graphical characterization and construction of adjustment   sets in Markov equivalence classes of ancestral graphs. <em>Journal of Machine Learning Research.</em> <b>18</b>(220) 1&ndash;62,
</p>
<p>L. Henckel, E. Perkovic and M.H. Maathuis (2019). Graphical criteria for efficient total 
effect estimation via adjustment in causal linear models.
<em>Working Paper.</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate a true DAG, its CPDAG and an intermediate max. PDAG
suppressWarnings(RNGversion("3.5.0"))
set.seed(123)
p &lt;- 10
## true DAG
myDAG &lt;- randomDAG(p, prob = 0.3) 
## true CPDAG
myCPDAG &lt;- dag2cpdag(myDAG) 
## true PDAG with added background knowledge 5 -&gt; 6
myPDAG &lt;- addBgKnowledge(myCPDAG,5,6) 
par(mfrow = c(1,3))
plot(myDAG)
plot(myPDAG)
plot(myCPDAG) ## plot of the graphs

## if the CPDAG C is amenable relative to (X,Y),
## the optimal set will be the same for all DAGs 
## and any max. PDAGs obtained by adding background knowledge to C 
(optAdjSet(myDAG,3,10))
(optAdjSet(myPDAG,3,10))
(optAdjSet(myCPDAG,3,10))


## the optimal adjustment set can also be compute for sets X and Y
(optAdjSet(myDAG,c(3,4),c(9,10)))
(optAdjSet(myPDAG,c(3,4),c(9,10)))
(optAdjSet(myCPDAG,c(3,4),c(9,10)))

## The only restriction is that it requires all nodes in Y to be
## descendants of X.
## However, if a node in Y is non-descendant of X the lowest variance
## partial total effect estimate is simply 0.
## Hence, we can proceed with a pruned Y. This function does this automatically!
optAdjSet(myDAG,1,c(3,9))

## Note that for sets X there may be no valid adjustment set even
## if the PDAG is is amenable relative to (X,Y).
## Not run: optAdjSet(myPDAG,c(4,9),7)

</code></pre>

<hr>
<h2 id='pag2anc'>Reads off identifiable ancestors and non-ancestors from a directed PAG</h2><span id='topic+pag2anc'></span>

<h3>Description</h3>

<p>Constructs a matrix which contains identifiable ancestral and
non-ancestral relations in the Markov equivalence class represented
by a directed partial ancestral graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pag2anc(P,verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pag2anc_+3A_p">P</code></td>
<td>
<p>Adjacency matrix of type <a href="#topic+amat.pag">amat.pag</a>, which should encode
a directed PAG (i.e., it should not contain any undirected edges of the
form <code>x --- y</code> or any circle-tail edges of the form <code>x o-- y</code>).</p>
</td></tr>
<tr><td><code id="pag2anc_+3A_verbose">verbose</code></td>
<td>
<p>If true, more detailed output is provided.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We say that node <code>i</code> is ancestor of node <code>j</code> in a directed mixed graph (DMG) iff there
exists a directed path from <code>i</code> to <code>j</code> in that graph. If the directed mixed graph
has a causal interpretation (for example, if it is the graph of a simple SCM) then ancestral
relations coincide (generically) with causal relations.
</p>
<p>This function implements the sufficient conditions (Propositions 4 and 5) in Mooij and Claassen (2020) 
for concluding whether an ancestral relation between two nodes must be present or absent
in all directed mixed graphs in the Markov equivalence class represented by the directed PAG <code>P</code>.
It applies to both the
acyclic case as well as the cyclic (simple SCM) case, assuming the d-separation resp. <code class="reqn">\sigma</code>-separation
Markov property.
</p>
<p>The output is a matrix containing for each ordered pair of nodes whether
the presence of an ancestral relation was identified, or the absence, or neither.
</p>
<p>It is not known whether these sufficient conditions for identifiability are complete. 
Hence, zero entries in the result indicate that the sufficient condition gives no 
conclusion, rather than that the Markov equivalence class represented by the directed PAG 
necessarily contains DMGs where an ancestral relation is present as well as DMGs where it is absent.
</p>
<p><code>P</code> should be an adjacency matrix of type <a href="#topic+amat.pag">amat.pag</a> that contains no undirected
and circle-tail edges.
</p>


<h3>Value</h3>

<p>Matrix <code>A</code>, where entry <code>A[i,j]</code> equals </p>

<dl>
<dt>1</dt><dd><p>if node <code>i</code> is an identifiable ancestor of node <code>j</code>,</p>
</dd>
<dt>-1</dt><dd><p>if node <code>i</code> is an identifiable non-ancestor of node <code>j</code>,</p>
</dd>
<dt>0</dt><dd><p>in case the ancestral relationship between nodes <code>i</code> and <code>j</code> is unknown.</p>
</dd></dl>



<h3>Author(s)</h3>

<p>Joris Mooij.
</p>


<h3>References</h3>

<p>J. M. Mooij and T. Claassen (2020).
Constraint-Based Causal Discovery using Partial Ancestral Graphs in the presence of Cycles.
<em>In Proc. of the 36th Conference on Uncertainty in Artificial Intelligence (UAI-20)</em>, 1159-1168.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################################################
## Mooij et al. (2020), Fig. 43(a), p. 97
##################################################

# Encode ADMG as adjacency matrix
p &lt;- 8 # total number of variables
V &lt;- c("Ca","Cb","Cc","X0","X1","X2","X3","X4") # 3 context variables, 5 system variables
# amat[i,j] = 0 iff no edge btw i,j
# amat[i,j] = 1 iff i *-o j
# amat[i,j] = 2 iff i *-&gt; j
# amat[i,j] = 3 iff i *-- j
amat &lt;- rbind(c(0,2,2,2,0,0,0,0),
              c(2,0,2,0,2,0,0,0),
              c(2,2,0,0,2,2,0,0),
              c(3,0,0,0,0,0,2,0),
              c(0,3,3,0,0,3,0,2),
              c(0,0,3,0,2,0,0,0),
              c(0,0,0,3,0,0,0,2),
              c(0,0,0,0,2,0,3,0))
rownames(amat)&lt;-V
colnames(amat)&lt;-V

# Make use of d-separation oracle as "independence test"
indepTest &lt;- dsepAMTest
suffStat&lt;-list(g=amat,verbose=FALSE)

# Derive PAG that represents the Markov equivalence class of the ADMG with the FCI algorithm
# (assuming no selection bias)
fci.pag &lt;- fci(suffStat,indepTest,alpha = 0.5,labels = V,verbose=TRUE,selectionBias=FALSE)

# Read off causal features from the FCI PAG
cat('Identified absence (-1) and presence (+1) of ancestral causal relations from FCI PAG:\n')
print(pag2anc(fci.pag@amat))

</code></pre>

<hr>
<h2 id='pag2conf'>Reads off identifiable unconfounded node pairs from a directed PAG</h2><span id='topic+pag2conf'></span>

<h3>Description</h3>

<p>Constructs a matrix which contains identifiably unconfounded node pairs 
in the Markov equivalence class represented by a directed partial ancestral graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pag2conf(P)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pag2conf_+3A_p">P</code></td>
<td>
<p>Adjacency matrix of type <a href="#topic+amat.pag">amat.pag</a>, which should encode
a directed PAG (i.e., it should not contain any undirected edges of the
form <code>x --- y</code> or any circle-tail edges of the form <code>x o-- y</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We say that nodes <code>i</code> and <code>j</code> are confounded in a directed mixed graph (DMG) iff there
exists a bidirected edge <code>i&lt;-&gt;j</code> in that graph. If the directed mixed graph
has a causal interpretation (for example, if it is the graph of a simple SCM) then the presence
of a bidirected edge coincides (generically) with the presence of a confounder, i.e., a 
latent common cause (relative to the variables in the graph).
</p>
<p>This function implements the sufficient condition (Proposition 6) in Mooij and Claassen (2020) 
for concluding whether two nodes are unconfounded in all directed mixed graphs in the Markov 
equivalence class represented by the directed PAG <code>P</code>.
It applies to both the
acyclic case as well as the cyclic (simple SCM) case, assuming the d-separation resp. <code class="reqn">\sigma</code>-separation
Markov property.
</p>
<p>The output is a (symmetric) matrix containing for each ordered pair of nodes whether
the two nodes are identifiably unconfounded.
</p>
<p>It is not known whether these sufficient conditions for identifiability are complete. 
Hence, zero entries in the result indicate that the sufficient condition gives no 
conclusion, rather than that the Markov equivalence class represented by the directed PAG 
necessarily contains DMGs where a bidirected edge is present.
</p>
<p><code>P</code> should be an adjacency matrix of type <a href="#topic+amat.pag">amat.pag</a> that contains no undirected
and circle-tail edges.
</p>


<h3>Value</h3>

<p>Matrix <code>A</code>, where entry <code>A[i,j]</code> equals </p>


<dl>
<dt>-1</dt><dd><p>if nodes <code>i</code> and <code>j</code> are identifiably unconfounded,</p>
</dd>
<dt>0</dt><dd><p>in case it is unknown whether nodes <code>i</code> and <code>j</code> are confounded or not.</p>
</dd></dl>



<h3>Author(s)</h3>

<p>Joris Mooij.
</p>


<h3>References</h3>

<p>J. M. Mooij and T. Claassen (2020).
Constraint-Based Causal Discovery using Partial Ancestral Graphs in the presence of Cycles.
<em>In Proc. of the 36th Conference on Uncertainty in Artificial Intelligence (UAI-20)</em>, 1159-1168.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################################################
## Mooij et al. (2020), Fig. 43(a), p. 97
##################################################

# Encode ADMG as adjacency matrix
p &lt;- 8 # total number of variables
V &lt;- c("Ca","Cb","Cc","X0","X1","X2","X3","X4") # 3 context variables, 5 system variables
# amat[i,j] = 0 iff no edge btw i,j
# amat[i,j] = 1 iff i *-o j
# amat[i,j] = 2 iff i *-&gt; j
# amat[i,j] = 3 iff i *-- j
amat &lt;- rbind(c(0,2,2,2,0,0,0,0),
              c(2,0,2,0,2,0,0,0),
              c(2,2,0,0,2,2,0,0),
              c(3,0,0,0,0,0,2,0),
              c(0,3,3,0,0,3,0,2),
              c(0,0,3,0,2,0,0,0),
              c(0,0,0,3,0,0,0,2),
              c(0,0,0,0,2,0,3,0))
rownames(amat)&lt;-V
colnames(amat)&lt;-V

# Make use of d-separation oracle as "independence test"
indepTest &lt;- dsepAMTest
suffStat&lt;-list(g=amat,verbose=FALSE)


# Derive PAG that represents the Markov equivalence class of the ADMG with the FCI algorithm
# (assuming no selection bias)
fci.pag &lt;- fci(suffStat,indepTest,alpha = 0.5,labels = V,verbose=TRUE,selectionBias=FALSE)

# Read off causal features from the FCI PAG
cat('Identified absence (-1) and presence (+1) of pairwise latent confounding from FCI PAG:\n')
print(pag2conf(fci.pag@amat))

</code></pre>

<hr>
<h2 id='pag2edge'>Reads off identifiable parents and non-parents from a directed PAG</h2><span id='topic+pag2edge'></span>

<h3>Description</h3>

<p>Constructs a matrix which contains identifiable parental and
non-parental relations in the Markov equivalence class represented
by a directed partial ancestral graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pag2edge(P)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pag2edge_+3A_p">P</code></td>
<td>
<p>Adjacency matrix of type <a href="#topic+amat.pag">amat.pag</a>, which should encode
a directed PAG (i.e., it should not contain any undirected edges of the
form <code>x --- y</code> or any circle-tail edges of the form <code>x o-- y</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We say that node <code>i</code> is parent of node <code>j</code> in a directed mixed graph (DMG) iff there
exists a directed edge <code>i--&gt;j</code> in that graph. If the directed mixed graph
has a causal interpretation (for example, if it is the graph of a simple SCM) then parental
relations coincide (generically) with direct causal relations (relative to the variables in the graph).
</p>
<p>This function implements the sufficient conditions (Propositions 7 and 8) in Mooij and Claassen (2020) 
for concluding whether a parental relation between two nodes must be present or absent
in all directed mixed graphs in the Markov equivalence class represented by the directed PAG <code>P</code>.
It applies to both the
acyclic case as well as the cyclic (simple SCM) case, assuming the d-separation resp. <code class="reqn">\sigma</code>-separation
Markov property.
</p>
<p>The output is a matrix containing for each ordered pair of nodes whether
the presence of a parental relation was identified, or the absence, or neither.
</p>
<p>It is not known whether these sufficient conditions for identifiability are complete. 
Hence, zero entries in the result indicate that the sufficient condition gives no 
conclusion, rather than that the Markov equivalence class represented by the directed PAG 
necessarily contains DMGs where a parental relation is present as well as DMGs where it is absent.
</p>
<p><code>P</code> should be an adjacency matrix of type <a href="#topic+amat.pag">amat.pag</a> that contains no undirected
and circle-tail edges.
</p>


<h3>Value</h3>

<p>Matrix <code>A</code>, where entry <code>A[i,j]</code> equals </p>

<dl>
<dt>1</dt><dd><p>if node <code>i</code> is an identifiable parent of node <code>j</code>,</p>
</dd>
<dt>-1</dt><dd><p>if node <code>i</code> is an identifiable non-parent of node <code>j</code>,</p>
</dd>
<dt>0</dt><dd><p>in case the parental relationship between nodes <code>i</code> and <code>j</code> is unknown.</p>
</dd></dl>



<h3>Author(s)</h3>

<p>Joris Mooij.
</p>


<h3>References</h3>

<p>J. M. Mooij and T. Claassen (2020).
Constraint-Based Causal Discovery using Partial Ancestral Graphs in the presence of Cycles.
<em>In Proc. of the 36th Conference on Uncertainty in Artificial Intelligence (UAI-20)</em>, 1159-1168.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################################################
## Mooij et al. (2020), Fig. 43(a), p. 97
##################################################

# Encode ADMG as adjacency matrix
p &lt;- 8 # total number of variables
V &lt;- c("Ca","Cb","Cc","X0","X1","X2","X3","X4") # 3 context variables, 5 system variables
# amat[i,j] = 0 iff no edge btw i,j
# amat[i,j] = 1 iff i *-o j
# amat[i,j] = 2 iff i *-&gt; j
# amat[i,j] = 3 iff i *-- j
amat &lt;- rbind(c(0,2,2,2,0,0,0,0),
              c(2,0,2,0,2,0,0,0),
              c(2,2,0,0,2,2,0,0),
              c(3,0,0,0,0,0,2,0),
              c(0,3,3,0,0,3,0,2),
              c(0,0,3,0,2,0,0,0),
              c(0,0,0,3,0,0,0,2),
              c(0,0,0,0,2,0,3,0))
rownames(amat)&lt;-V
colnames(amat)&lt;-V

# Make use of d-separation oracle as "independence test"
indepTest &lt;- dsepAMTest
suffStat&lt;-list(g=amat,verbose=FALSE)


# Derive PAG that represents the Markov equivalence class of the ADMG with the FCI algorithm
# (assuming no selection bias)
fci.pag &lt;- fci(suffStat,indepTest,alpha = 0.5,labels = V,verbose=TRUE,selectionBias=FALSE)

# Read off causal features from the FCI PAG
cat('Identified absence (-1) and presence (+1) of direct causal relations from FCI PAG:\n')
print(pag2edge(fci.pag@amat))

</code></pre>

<hr>
<h2 id='pag2mag'>Transform a PAG into a MAG in the Corresponding Markov Equivalence Class</h2><span id='topic+pag2magAM'></span>

<h3>Description</h3>

<p>Transform a Partial Ancestral Graph (PAG) into a valid
Maximal Ancestral Graph (MAG) that belongs to the Markov equivalence class
represented by the given PAG, with no additional edges into node <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pag2magAM(amat.pag, x, max.chordal = 10, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pag2mag_+3A_amat.pag">amat.pag</code></td>
<td>
<p>Adjacency matrix of type <a href="#topic+amat.pag">amat.pag</a></p>
</td></tr> 
<tr><td><code id="pag2mag_+3A_x">x</code></td>
<td>
<p>(integer) position in adjacency matrix of node in the PAG into which no additional edges are oriented.</p>
</td></tr>
<tr><td><code id="pag2mag_+3A_max.chordal">max.chordal</code></td>
<td>
<p>Positive integer: graph paths larger than
<code>max.chordal</code> are considered to be too large to be checked for
chordality.</p>
</td></tr>
<tr><td><code id="pag2mag_+3A_verbose">verbose</code></td>
<td>
<p>Logical; if true, some output is produced during
computation.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>This function converts a PAG (adjacency matrix) to a valid MAG
(adjacency matrix) that belongs to the Markov equivalence class
represented by the given PAG.  Note that we assume that there are no
selection variables, meaning that the edges in the PAG can be of the
following types: -&gt;, &lt;-&gt;, o-&gt;, and o-o.  In a first step, it uses the
Arrowhead Augmentation of Zhang (2006), i.e., any o-&gt; edge is oriented
into -&gt;.  Afterwards, it orients each chordal component into a valid DAG
without orienting any additional edges into x.
</p>
<p>This function is used in the Generalized Backdoor Criterion
<code><a href="#topic+backdoor">backdoor</a></code> with <code>type="pag"</code>, see Maathuis and Colombo
(2015) for details.
</p>


<h3>Value</h3>

<p>The output is an adjacency matrix of type <a href="#topic+amat.pag">amat.pag</a> representing
a valid MAG that belongs to the Markov equivalence class
represented by the given PAG.
</p>


<h3>Author(s)</h3>

<p>Diego Colombo, Markus Kalisch and Martin Maechler.
</p>


<h3>References</h3>

<p>M.H. Maathuis and D. Colombo (2015). A generalized back-door
criterion. <em>Annals of Statistics</em> <b>43</b> 1060-1088.
</p>
<p>Zhang, J. (2006). Causal Inference and Reasoning in Causally
Insufficient Systems. Ph. D. thesis, Carnegie Mellon University.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fci">fci</a></code>, <code><a href="#topic+dag2pag">dag2pag</a></code>, <code><a href="#topic+backdoor">backdoor</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## create the graph
set.seed(78)
p &lt;- 12
g &lt;- randomDAG(p, prob = 0.4)
## Compute the true covariance and then correlation matrix of g:
true.corr &lt;- cov2cor(trueCov(g))

## define nodes 2 and 6 to be latent variables
L &lt;- c(2,6)

## Find PAG
## As dependence "oracle", we use the true correlation matrix in
## gaussCItest() with a large "virtual sample size" and a large alpha:
true.pag &lt;- dag2pag(suffStat = list(C= true.corr, n= 10^9),
                    indepTest= gaussCItest, graph=g, L=L, alpha= 0.9999)

## find a valid MAG such that no additional edges are directed into
(amat.mag &lt;- pag2magAM(true.pag@amat, 4)) # -&gt; the adj.matrix of the MAG
</code></pre>

<hr>
<h2 id='ParDAG-class'>Class <code>"ParDAG"</code> of Parametric Causal Models</h2><span id='topic+ParDAG-class'></span><span id='topic+plot+2CParDAG+2CANY-method'></span>

<h3>Description</h3>

<p>This virtual base class represents a parametric causal model.
</p>


<h3>Details</h3>

<p>The class <code>"ParDAG"</code> serves as a basis for simulating observational
and/or interventional data from causal models as well as for parameter
estimation (maximum-likelihood estimation) for a given causal model in the
presence of a data set with jointly observational and interventional data.
</p>
<p>The virtual base class <code>"ParDAG"</code> provides a &ldquo;skeleton&rdquo; for all
functions relied to the aforementioned task.  In practical cases, a user may
always choose an appropriate class derived from <code>ParDAG</code> which
represents a specific parametric model class.  The base class itself does
<em>not</em> represent such a model class.
</p>


<h3>Constructor</h3>

<p><code>new("ParDAG", nodes, in.edges, params)</code>
</p>

<dl>
<dt><code>nodes</code></dt><dd><p>Vector of node names; cf. also field <code>.nodes</code>.</p>
</dd>
<dt><code>in.edges</code></dt><dd><p>A list of length <code>p</code> consisting of index
vectors indicating the edges pointing into the nodes of the DAG.</p>
</dd>
<dt><code>params</code></dt><dd><p>A list of length <code>p</code> consisting of parameter
vectors modeling the conditional distribution of a node given its
parents; cf. also field <code>.params</code>.</p>
</dd>
</dl>



<h3>Fields</h3>


<dl>
<dt><code>.nodes</code>:</dt><dd><p>Vector of node names; defaults to <code>as.character(1:p)</code>,
where <code>p</code> denotes the number of nodes (variables) of the model.</p>
</dd>
<dt><code>.in.edges</code>:</dt><dd><p>A list of length <code>p</code> consisting of index
vectors indicating the edges pointing into the nodes of the DAG.</p>
</dd>
<dt><code>.params</code>:</dt><dd><p>A list of length <code>p</code> consisting of parameter
vectors modeling the conditional distribution of a node given its
parents.  The entries of the parameter vectors only get a concrete
meaning in derived classes belonging to specific parametric model classes.</p>
</dd>
</dl>



<h3>Class-Based Methods</h3>


<dl>
<dt><code>node.count()</code>:</dt><dd><p>Yields the number of nodes (variables) of the
model.</p>
</dd>
<dt><code>simulate(n, target, int.level)</code>:</dt><dd><p>Generates <code class="reqn">n</code>
(observational or interventional) samples from the parametric causal
model.  The intervention target to be used is specified by the parameter
<code>target</code>; if the target is empty (<code>target = integer(0)</code>),
observational samples are generated.  <code>int.level</code> indicates
the values of the intervened variables; if it is a vector of the same
length as <code>target</code>, all samples are drawn from the same intervention
levels; if it is a matrix with <code class="reqn">n</code> rows and as many columns as
<code>target</code> has entries, its rows are interpreted as individual
intervention levels for each sample.</p>
</dd>
<dt><code>edge.count()</code>:</dt><dd><p>Yields the number of edges (arrows) in the DAG.</p>
</dd>
<dt><code>mle.fit(score)</code>:</dt><dd><p>Fits the parameters using an appropriate
<code><a href="#topic+Score-class">Score</a></code> object.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>plot</dt><dd><p><code>signature(x = "ParDAG", y = "ANY")</code>: plots the underlying
DAG of the causal model.  Parameters are not visualized.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Alain Hauser (<a href="mailto:alain.hauser@bfh.ch">alain.hauser@bfh.ch</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GaussParDAG-class">GaussParDAG</a></code>
</p>

<hr>
<h2 id='pc'>Estimate the Equivalence Class of a DAG using the PC Algorithm</h2><span id='topic+pc'></span>

<h3>Description</h3>

<p>Estimate the equivalence class of a directed acyclic
graph (DAG) from observational data, using the PC-algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pc(suffStat, indepTest, alpha, labels, p,
   fixedGaps = NULL, fixedEdges = NULL, NAdelete = TRUE, m.max = Inf,
   u2pd = c("relaxed", "rand", "retry"),
   skel.method = c("stable", "original", "stable.fast"),
   conservative = FALSE, maj.rule = FALSE, solve.confl = FALSE, 
   numCores = 1, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pc_+3A_suffstat">suffStat</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code> of sufficient statistics,
containing all necessary elements for the conditional independence
decisions in the function <code>indepTest</code>.</p>
</td></tr>
<tr><td><code id="pc_+3A_indeptest">indepTest</code></td>
<td>
<p>A <code><a href="base.html#topic+function">function</a></code> for testing conditional
independence.  It is internally called as
<code>indepTest(x,y,S,suffStat)</code>, and tests conditional independence
of <code>x</code> and <code>y</code> given <code>S</code>.  Here, <code>x</code> and
<code>y</code> are variables, and <code>S</code> is a (possibly empty) vector of
variables (all variables are denoted by their (integer) column positions
in the adjacency matrix).  <code>suffStat</code> is a list, see the
argument above.  The return value of <code>indepTest</code> is the p-value
of the test for conditional independence.</p>
</td></tr>
<tr><td><code id="pc_+3A_alpha">alpha</code></td>
<td>
<p>significance level (number in <code class="reqn">(0,1)</code> for the
individual conditional independence tests.</p>
</td></tr>
<tr><td><code id="pc_+3A_labels">labels</code></td>
<td>
<p>(optional) character vector of variable (or
&ldquo;node&rdquo;) names.  Typically preferred to specifying <code>p</code>.</p>
</td></tr>
<tr><td><code id="pc_+3A_p">p</code></td>
<td>
<p>(optional) number of variables (or nodes).  May be specified
if <code>labels</code> are not, in which case <code>labels</code> is set to
<code>1:p</code>.</p>
</td></tr>
<tr><td><code id="pc_+3A_numcores">numCores</code></td>
<td>
<p>Specifies the number of cores to be used for parallel
estimation of <code><a href="#topic+skeleton">skeleton</a></code>.</p>
</td></tr>
<tr><td><code id="pc_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, detailed output is provided.</p>
</td></tr>
<tr><td><code id="pc_+3A_fixedgaps">fixedGaps</code></td>
<td>
<p>A logical matrix of dimension p*p. If entry
<code>[i,j]</code> or <code>[j,i]</code> (or both) are TRUE, the edge i-j is
removed before starting the algorithm. Therefore, this edge is
guaranteed to be absent in the resulting graph.</p>
</td></tr>
<tr><td><code id="pc_+3A_fixededges">fixedEdges</code></td>
<td>
<p>A logical matrix of dimension p*p. If entry
<code>[i,j]</code> or <code>[j,i]</code> (or both) are TRUE, the edge i-j is
never considered for removal. Therefore, this edge is
guaranteed to be present in the resulting graph.</p>
</td></tr>
<tr><td><code id="pc_+3A_nadelete">NAdelete</code></td>
<td>
<p>If indepTest returns <code>NA</code> and this option is
<code>TRUE</code>, the corresponding edge is deleted. If this option is
<code>FALSE</code>, the edge is not deleted.</p>
</td></tr>
<tr><td><code id="pc_+3A_m.max">m.max</code></td>
<td>
<p>Maximal size of the conditioning sets that are considered in the
conditional independence tests.</p>
</td></tr>
<tr><td><code id="pc_+3A_u2pd">u2pd</code></td>
<td>
<p>String specifying the method for dealing with conflicting
information when trying to orient edges (see details below).</p>
</td></tr>
<tr><td><code id="pc_+3A_skel.method">skel.method</code></td>
<td>
<p>Character string specifying method; the default,
<code>"stable"</code> provides an <em>order-independent</em> skeleton, see
<code><a href="#topic+skeleton">skeleton</a></code>.</p>
</td></tr>
<tr><td><code id="pc_+3A_conservative">conservative</code></td>
<td>
<p>Logical indicating if the conservative PC is used.
In this case, only option <code>u2pd = "relaxed"</code> is supported.
Note that therefore the resulting object might not be extendable to
a DAG.  See details for more information.</p>
</td></tr>
<tr><td><code id="pc_+3A_maj.rule">maj.rule</code></td>
<td>
<p>Logical indicating that the triples shall be checked
for ambiguity using a majority rule idea, which is less strict than the
conservative PC algorithm.  For more information, see details.</p>
</td></tr>
<tr><td><code id="pc_+3A_solve.confl">solve.confl</code></td>
<td>
<p>If <code>TRUE</code>, the orientation of the v-structures and the
orientation rules work with lists for candidate sets and allow
bi-directed edges to resolve conflicting edge orientations. In this
case, only option <code>u2pd = relaxed</code> is supported. Note, that
therefore the resulting object might not be a CPDAG because
bi-directed edges might be present. See details
for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Under the assumption that the distribution of the observed variables
is faithful to a DAG, this function estimates the Markov equivalence class of
the DAG. We do not estimate the DAG itself, because this is typically
impossible (even with an infinite amount of data), since different
DAGs can describe the same conditional independence relationships.
Since all DAGs in an equivalence class describe the same conditional
independence relationships, they are equally valid ways to
describe the conditional dependence structure that was given as
input.
</p>
<p>All DAGs in a Markov equivalence class have the same skeleton (i.e.,
the same adjacency information) and the same v-structures (see
definition below). However, the direction of some edges may be
undetermined, in the sense that they point one way in one DAG in the
equivalence class, while they point the other way in another DAG in
the equivalence class.
</p>
<p>A Markov equivalence class can be uniquely represented by a completed
partially directed acyclic graph (CPDAG). A CPDAG
contains undirected and directed edges. The edges have the following
interpretation: (i) there is a (directed or undirected) edge between i
and j if and only if variables i and j are conditionally dependent
given S for all possible subsets S of the remaining nodes; (ii) a directed
edge <code class="reqn">i \longrightarrow j</code> means that this directed edge is 
present in all DAGs in the Markov equivalence class; (iii) an undirected 
edge <code class="reqn">i - j</code> means that there is at least one DAG in the Markov 
equivalence class with edge <code class="reqn">i \longrightarrow j</code> and
there is at least one DAG in the Markov equivalence class with edge 
<code class="reqn">i \longleftarrow j</code>.
</p>
<p>The CPDAG is estimated using the PC algorithm (named after its inventors
<b>P</b>eter Spirtes and <b>C</b>lark Glymour). The skeleton is
estimated by the function <code><a href="#topic+skeleton">skeleton</a></code> which uses a modified
version of the original PC algorithm (see Colombo and Maathuis (2014) for
details). The original PC algorithm is known to be
order-dependent, in the sense that the output depends on the order in
which the variables are given. Therefore, Colombo and Maathuis (2014)
proposed a simple modification, called PC-stable, that yields
order-independent adjacencies in the skeleton (see the help file
of this function for details). Subsequently, as many edges as possible
are oriented. This is done in two steps. It is important to note that
if no further actions are taken (see below) these two steps still
remain order-dependent.
</p>
<p>The edges are oriented as follows. First, the algorithm considers all
triples <code>(a,b,c)</code>, where <code class="reqn">a</code> and <code class="reqn">b</code> are adjacent, <code class="reqn">b</code> and 
<code class="reqn">c</code> are adjacent, but <code class="reqn">a</code> and <code class="reqn">c</code> are not adjacent. For all such 
triples, we direct both edges towards <code class="reqn">b</code> 
(<code class="reqn">a \longrightarrow b \longleftarrow c</code>) if and only if 
<code class="reqn">b</code> was not part of the conditioning set that made the edge between 
<code class="reqn">a</code> and <code class="reqn">c</code> drop out. These conditioning sets were saved in
<code>sepset</code>. The structure 
<code class="reqn">a \longrightarrow b \longleftarrow c</code> is called a 
v-structure.
</p>
<p>After determining all v-structures, there may still
be undirected edges. It may be possible to direct some of these edges, since
one can deduce that one of the two possible directions of the edge is
invalid because it introduces
a new v-structure or a directed cycle. Such edges are found by
repeatedly applying rules R1-R3 of the PC algorithm as given in
Algorithm 2 of Kalisch and Bühlmann (2007). The algorithm stops if
none of the rules is applicable to the graph.
</p>
<p>The conservative PC algorithm (<code>conservative = TRUE</code>) is a
slight variation of the PC algorithm (see Ramsey et al. 2006). After
the skeleton is computed, all potential v-structures <code class="reqn">a - b - c</code> are 
checked in the following way. We test whether a and c are independent
conditioning on all subsets of the neighbors of <code class="reqn">a</code> and all subsets of 
the neighbors of <code class="reqn">c</code>. When a subset makes <code class="reqn">a</code> and <code class="reqn">c</code> 
conditionally independent, we call it a separating set. If <code class="reqn">b</code> is in no 
such separating set or in all such separating sets, no further action is 
taken and the usual PC is continued. If, however, <code class="reqn">b</code> is in only some 
separating sets, the triple <code class="reqn">a - b - c</code> is marked as 'ambiguous'.
Moreover, if no separating set is found among the neighbors, the triple is 
also marked as 'ambiguous'. An ambiguous triple is not oriented as a
v-structure. Furthermore, no further orientation rule that needs to
know whether <code class="reqn">a - b - c</code> is a v-structure or not is applied. Instead of
using the conservative version, which is quite strict towards the
v-structures, Colombo and Maathuis (2014) introduced a less strict
version for the v-structures called majority rule. This adaptation can
be called using <code>maj.rule = TRUE</code>. In this case, the triple 
<code class="reqn">a - b - c</code> is marked as 'ambiguous' if and only if <code class="reqn">b</code> is in 
exactly 50 percent of such separating sets or no separating set was found. 
If <code class="reqn">b</code> is in less than 50 percent of the separating sets it is set as a 
v-structure, and if in more than 50 percent it is set as a non v-structure 
(for more details see Colombo and Maathuis, 2014). The usage of both the
conservative and the majority rule versions resolve the
order-dependence issues of the determination of the v-structures.
</p>
<p>Sampling errors (or hidden variables) can lead to conflicting
information about edge directions. For example, one may find that
<code class="reqn">a - b - c</code> and <code class="reqn">b - c - d</code> should both be directed as v-structures. 
This gives conflicting information about the edge <code class="reqn">b - c</code>, since it should 
be directed as <code class="reqn">b \longleftarrow c</code> in v-structure 
<code class="reqn">a \longrightarrow b \longleftarrow c</code>, while it should be 
directed as <code class="reqn">b \longrightarrow c</code> in v-structure 
<code class="reqn">b \longrightarrow c \longleftarrow d</code>. With the option 
<code>solve.confl = FALSE</code>, in such cases, we simply overwrite the
directions of the conflicting edge. In the example above this means
that we obtain 
<code class="reqn">a \longrightarrow b \longrightarrow c \longleftarrow d</code> 
if <code class="reqn">a - b - c</code> was visited first, and 
<code class="reqn">a \longrightarrow b \longleftarrow c \longleftarrow d</code>
if <code class="reqn">b - c - d</code> was visited first, meaning that the final orientation on 
the edge depends on the ordering in which the v-structures were
considered. With the option <code>solve.confl = TRUE</code> (which is only
supported with option <code>u2pd = "relaxed"</code>), we first generate a list
of all (unambiguous) v-structures (in the example above <code class="reqn">a - b - c</code> and
<code class="reqn">b - c - d</code>), and then we simply orient them allowing both directions on 
the edge <code class="reqn">b - c</code>, namely we allow the bi-directed edge 
<code class="reqn">b \leftrightarrow c</code> resolving the order-dependence issues on the 
edge orientations. We denote bi-directed edges in the adjacency matrix 
<code class="reqn">M</code> of the graph as <code>M[b,c] = 2</code> and <code>M[c,b] = 2</code>. In a similar 
way, using lists for the candidate edges for each orientation rule and 
allowing bi-directed edges, the order-dependence issues in the orientation 
rules can be resolved. Note that bi-directed edges merely represent a 
conflicting orientation and they should not to be interpreted causally. The 
useage of these lists for the candidate edges and allowing bi-directed edges 
resolves the order-dependence issues on the orientation of the v-structures 
and on the orientation rules, see Colombo and Maathuis (2014) for
more details.
</p>
<p>Note that calling (<code>conservative = TRUE</code>), or <code>maj.rule =
  TRUE</code>, together with <code>solve.confl = TRUE</code> produces a fully
order-independent output, see Colombo and Maathuis (2014).
</p>
<p>Sampling errors, non faithfulness, or hidden variables can also lead
to non-extendable CPDAGs, meaning that there does not exist a DAG that
has the same skeleton and v-structures as the graph found by the
algorithm. An example of this is an undirected cycle consisting of the
edges <code class="reqn">a - b - c - d</code> and <code class="reqn">d - a</code>. In this case it is impossible to 
direct the edges without creating a cycle or a new v-structure. The option
<code>u2pd</code> specifies what should be done in such a situation. If the
option is set to <code>"relaxed"</code>, the algorithm simply outputs the
invalid CPDAG. If the option is set to <code>"rand"</code>, all direction
information is discarded and a random DAG is generated on the
skeleton, which is then converted into its CPDAG. If the option is set
to <code>"retry"</code>, up to 100 combinations of possible directions of
the ambiguous edges are tried, and the first combination that results
in an extendable CPDAG is chosen. If no valid combination is found, an
arbitrary DAG is generated on the skeleton as in the option &quot;rand&quot;,
and then converted into its CPDAG. Note that the output can also be an
invalid CPDAG, in the sense that it cannot arise from the oracle PC
algorithm, but be extendible to a DAG, for example 
<code class="reqn">a \longrightarrow b \longleftarrow c \longleftarrow d</code>. 
In this case, <code>u2pd</code> is not used.
</p>
<p>Using the function <code><a href="#topic+isValidGraph">isValidGraph</a></code> one can check if the final output is indeed a valid CPDAG.
</p>
<p>Notes: (1) Throughout, the algorithm works with the column positions
of the variables in the adjacency matrix, and not with the names of
the variables. (2) When plotting the object, undirected and bidirected
edges are equivalent.</p>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> <code>"pcAlgo"</code> (see
<code><a href="#topic+pcAlgo-class">pcAlgo</a></code>) containing an estimate of the equivalence
class of the underlying DAG.
</p>


<h3>Author(s)</h3>

<p>Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>), Martin Maechler,
and Diego Colombo.
</p>


<h3>References</h3>

<p>D. Colombo and M.H. Maathuis (2014).Order-independent constraint-based
causal structure learning. <em>Journal of Machine Learning Research</em>
<b>15</b> 3741-3782. 
</p>
<p>M. Kalisch, M. Maechler, D. Colombo, M.H. Maathuis and P. Buehlmann
(2012). Causal Inference Using Graphical Models with the R Package
pcalg. <em>Journal of Statistical Software</em> <b>47(11)</b> 1&ndash;26,
<a href="https://doi.org/10.18637/jss.v047.i11">doi:10.18637/jss.v047.i11</a>.
</p>
<p>M. Kalisch and P. Buehlmann (2007).
Estimating high-dimensional directed acyclic graphs with the PC-algorithm.
<em>JMLR</em> <b>8</b> 613-636.
</p>
<p>J. Ramsey, J. Zhang and P. Spirtes (2006).
Adjacency-faithfulness and conservative causal inference. In
<em>Proceedings of the 22nd Annual Conference on Uncertainty in
Artificial Intelligence</em>. AUAI Press, Arlington, VA.
</p>
<p>P. Spirtes, C. Glymour and R. Scheines (2000).
<em>Causation, Prediction, and Search</em>, 2nd edition. The MIT Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+skeleton">skeleton</a></code> for estimating a skeleton of a DAG;
<code><a href="#topic+udag2pdag">udag2pdag</a></code> for converting the
skeleton to a CPDAG; <code><a href="#topic+gaussCItest">gaussCItest</a></code>,
<code><a href="#topic+disCItest">disCItest</a></code>, <code><a href="#topic+binCItest">binCItest</a></code> and
<code><a href="#topic+dsepTest">dsepTest</a></code> as examples for <code>indepTest</code>. <code><a href="#topic+isValidGraph">isValidGraph</a></code> for testing whether the output is a valid CPDAG.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################################################
## Using Gaussian Data
##################################################
## Load predefined data
data(gmG)
n &lt;- nrow    (gmG8$ x)
V &lt;- colnames(gmG8$ x) # labels aka node names

## estimate CPDAG
pc.fit &lt;- pc(suffStat = list(C = cor(gmG8$x), n = n),
             indepTest = gaussCItest, ## indep.test: partial correlations
             alpha=0.01, labels = V, verbose = TRUE)
if (require(Rgraphviz)) {
  ## show estimated CPDAG
  par(mfrow=c(1,2))
  plot(pc.fit, main = "Estimated CPDAG")
  plot(gmG8$g, main = "True DAG")
}
##################################################
## Using d-separation oracle
##################################################
## define sufficient statistics (d-separation oracle)
suffStat &lt;- list(g = gmG8$g, jp = RBGL::johnson.all.pairs.sp(gmG8$g))
## estimate CPDAG
fit &lt;- pc(suffStat, indepTest = dsepTest, labels = V,
          alpha= 0.01) ## value is irrelevant as dsepTest returns either 0 or 1
if (require(Rgraphviz)) {
  ## show estimated CPDAG
  plot(fit, main = "Estimated CPDAG")
  plot(gmG8$g, main = "True DAG")
}

##################################################
## Using discrete data
##################################################
## Load data
data(gmD)
V &lt;- colnames(gmD$x)
## define sufficient statistics
suffStat &lt;- list(dm = gmD$x, nlev = c(3,2,3,4,2), adaptDF = FALSE)
## estimate CPDAG
pc.D &lt;- pc(suffStat,
           ## independence test: G^2 statistic
           indepTest = disCItest, alpha = 0.01, labels = V, verbose = TRUE)
if (require(Rgraphviz)) {
  ## show estimated CPDAG
  par(mfrow = c(1,2))
  plot(pc.D, main = "Estimated CPDAG")
  plot(gmD$g, main = "True DAG")
}

##################################################
## Using binary data
##################################################
## Load binary data
data(gmB)
V &lt;- colnames(gmB$x)
## estimate CPDAG
pc.B &lt;- pc(suffStat = list(dm = gmB$x, adaptDF = FALSE),
           indepTest = binCItest, alpha = 0.01, labels = V, verbose = TRUE)
pc.B
if (require(Rgraphviz)) {
  ## show estimated CPDAG
  plot(pc.B, main = "Estimated CPDAG")
  plot(gmB$g, main = "True DAG")
}

##################################################
## Detecting ambiguities due to sampling error
##################################################
## Load predefined data
data(gmG)
n &lt;- nrow    (gmG8$ x)
V &lt;- colnames(gmG8$ x) # labels aka node names

## estimate CPDAG
pc.fit &lt;- pc(suffStat = list(C = cor(gmG8$x), n = n),
             indepTest = gaussCItest, ## indep.test: partial correlations
             alpha=0.01, labels = V, verbose = TRUE)

## due to sampling error, some edges were overwritten:
isValidGraph(as(pc.fit, "amat"), type = "cpdag")

## re-fit with solve.confl = TRUE
pc.fit2 &lt;- pc(suffStat = list(C = cor(gmG8$x), n = n),
             indepTest = gaussCItest, ## indep.test: partial correlations
             alpha=0.01, labels = V, verbose = TRUE,
             solve.confl = TRUE)

## conflicting edge is V5 - V6
as(pc.fit2, "amat")
</code></pre>

<hr>
<h2 id='pc.cons.intern'>Utility for conservative and majority rule in PC and FCI</h2><span id='topic+pc.cons.intern'></span><span id='topic+triple2numb'></span>

<h3>Description</h3>

<p>The <code>pc.cons.intern()</code> function is used in <code><a href="#topic+pc">pc</a></code> and 
<code><a href="#topic+fci">fci</a></code>, notably when
<code>conservative = TRUE</code> (conservative orientation of v-structures) or
<code>maj.rule = TRUE</code> (majority rule orientation of v-structures). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pc.cons.intern(sk, suffStat, indepTest, alpha, version.unf = c(NA, NA),
               maj.rule = FALSE, verbose = FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pc.cons.intern_+3A_sk">sk</code></td>
<td>
<p>A skeleton object as returned from <code><a href="#topic+skeleton">skeleton</a>()</code>.</p>
</td></tr>
<tr><td><code id="pc.cons.intern_+3A_suffstat">suffStat</code></td>
<td>
<p>Sufficient statistic: List containing all necessary
elements for the conditional independence decisions in the
function <code>indepTest</code>.</p>
</td></tr>
<tr><td><code id="pc.cons.intern_+3A_indeptest">indepTest</code></td>
<td>
<p>Pre-defined function for testing conditional independence. The
function is internally called as <code>indepTest(x,y,S,suffStat)</code>, and
tests conditional independence of <code>x</code> and <code>y</code> given
<code>S</code>. Here, <code>x</code> and <code>y</code> are variables, and <code>S</code> is
a (possibly empty) vector of variables (all variables are denoted
by their column numbers
in the adjacency matrix). <code>suffStat</code> is a list containing
all relevant elements for the conditional independence
decisions. The return value of <code>indepTest</code> is the p-value of
the test for conditional independence.</p>
</td></tr>
<tr><td><code id="pc.cons.intern_+3A_alpha">alpha</code></td>
<td>
<p>Significance level for the individual conditional
independence tests.</p>
</td></tr>
<tr><td><code id="pc.cons.intern_+3A_version.unf">version.unf</code></td>
<td>
<p>Vector of length two.  If <code>version.unf</code>[2]==1,
the intitial separating set found by the PC/FCI algorithm is
added to the set of separating sets; if <code>version.unf[2]==</code>2, it
is not added.  In the latter case, if the set of separating sets is
empty, the triple is marked as unambiguous if
<code>version.unf</code>[1]==1, and as ambiguous if
<code>version.unf</code>[1]==2.</p>
</td></tr>
<tr><td><code id="pc.cons.intern_+3A_maj.rule">maj.rule</code></td>
<td>
<p>Logical indicatin if the triples are checked for
ambiguity using the majority rule idea, which is less strict than
the standard conservative method.</p>
</td></tr>
<tr><td><code id="pc.cons.intern_+3A_verbose">verbose</code></td>
<td>
<p>Logical asking for detailed output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For any unshielded triple A-B-C, consider all subsets of the neighbors
of A and of the neighbors of C, and record all such sets D for which A and C
are conditionally independent given D.  We call such sets
&ldquo;separating sets&rdquo;. 
</p>
<p>If <code>version.unf</code>[2]==1, the initial separating set found in the
PC/FCI algorithm is added to this set of separating sets.  
If <code>version.unf</code>[2]==2, the initial separating set is not added (as in Tetrad). 
</p>
<p>In the latter case, if the set of separating sets is empty, then the
triple is marked as &lsquo;ambiguous&rsquo; if <code>version.unf</code>[1]==2, for
example in <code><a href="#topic+pc">pc</a></code>, or as &lsquo;unambiguous&rsquo; if
<code>version.unf</code>[1]==1, for example in <code><a href="#topic+fci">fci</a></code>.
Otherwise, there is at least one separating set.
If <code>maj.rule=FALSE</code>, the conservative PC algorithm is used
(Ramsey et al., 2006): If B is in some but not all separating sets,
the triple is marked as ambiguous.  Otherwise it is treated as in the
standard PC algorithm.  If <code>maj.rule=TRUE</code>, the majority rule is
applied (Colombo and Maathuis, 2014): The triple is marked as
&lsquo;ambiguous&rsquo; if B is in exactly 50 percent of the separating sets.  If
it is in less than 50 percent it is marked as a v-structure, and if it
is in more than 50 percent it is marked as a non v-structure.
</p>
<p>Note: This function modifies the separating sets for unambiguous
triples in the skeleton object (adding or removing B) to ensure that
the usual orientations rules later on lead to the correct
v-structures/non v-structures. 
</p>


<h3>Value</h3>

<table>
<tr><td><code>unfTripl</code></td>
<td>
<p>numeric vector of triples coded as numbers (via
<code>triple2numb()</code>) that were marked as ambiguous.</p>
</td></tr>
<tr><td><code>vers</code></td>
<td>

<p>Vector containing the version (1 or 2) of the corresponding triple
saved in unfTripl (1=normal ambiguous triple, i.e., B is in some
sepsets but not all or none; 2=triple coming from version.unf[1]==2,
i.e., a and c are indep given the initial sepset but there does not
exist a subset of the neighbours of a or of c that d-separates
them.)</p>
</td></tr>
<tr><td><code>sk</code></td>
<td>
<p>The updated skeleton-object (separating sets might have been updated).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>) and Diego Colombo.
</p>


<h3>References</h3>

<p>D. Colombo and M.H. Maathuis (2014).Order-independent constraint-based
causal structure learning. <em>Journal of Machine Learning Research</em>
<b>15</b> 3741-3782.
</p>
<p>J. Ramsey, J. Zhang and P. Spirtes (2006).
Adjacency-faithfulness and conservative causal inference. In
<em>Proceedings of the 22nd Annual Conference on Uncertainty in
Artificial Intelligence</em>, Arlington, VA. AUAI Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+skeleton">skeleton</a></code>, <code><a href="#topic+pc">pc</a></code>, <code><a href="#topic+fci">fci</a></code>
</p>

<hr>
<h2 id='pcalg-internal'>Internal Pcalg Functions</h2><span id='topic+rfci.vStruc'></span><span id='topic+allDags'></span><span id='topic+amat2dag'></span><span id='topic+gaussCItest.fast'></span>

<h3>Description</h3>

<p>Internal functions of package <span class="pkg">pcalg</span>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>amat2dag(amat)
</code></pre>


<h3>Details</h3>

<p>These are not to be called by the user.

</p>

<hr>
<h2 id='pcalg2dagitty'>

Transform the adjacency matrix from <span class="pkg">pcalg</span> into a <span class="pkg">dagitty</span> object
</h2><span id='topic+pcalg2dagitty'></span>

<h3>Description</h3>

<p>Transform the adjacency matrix of type <code>amat.cpdag</code> or
<code>amat.pag</code> (for details on coding see <code><a href="#topic+amatType">amatType</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcalg2dagitty(amat, labels, type = "cpdag")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcalg2dagitty_+3A_amat">amat</code></td>
<td>
<p>adjacency matrix of type <code>amat.cpdag</code> or <code>amat.pag</code></p>
</td></tr>
<tr><td><code id="pcalg2dagitty_+3A_labels">labels</code></td>
<td>
<p><code>character</code> vector of variable (or “node”) names.</p>
</td></tr>
<tr><td><code id="pcalg2dagitty_+3A_type">type</code></td>
<td>
<p>string specifying the type of graph of the adjacency matrix <code>amat</code>. It can be a DAG (<code>type="dag"</code>), a CPDAG (<code>type="cpdag"</code>) or a maximally oriented PDAG (<code>type="pdag"</code>) from Meek (1995); then the type of adjacency matrix is assumed to be <code>amat.cpdag</code>. It can also be a MAG (<code>type = "mag"</code>) or a PAG (<code>type="pag"</code>); then the type of the adjacency matrix is assumed to be <code>amat.pag</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a given adjacency matrix <code>amat</code> the form <code>amat.cpdag</code> or <code>amat.pag</code> and a specified graph <code>type</code>, this function returns a dagitty object corresponding to the graph structure specified by <code>amat</code>, <code>labels</code> and <code>type</code>.
The resulting object is compatible with the <span class="pkg">dagitty</span> package.
</p>


<h3>Value</h3>

<p>A dagitty graph (see the <span class="pkg">dagitty</span> package).
</p>


<h3>Author(s)</h3>


<p>Emilija Perkovic and Markus Kalisch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gmG)
n &lt;- nrow    (gmG8$x)
V &lt;- colnames(gmG8$x) # labels aka node names

amat &lt;- wgtMatrix(gmG8$g)
amat[amat != 0] &lt;- 1
if(requireNamespace("dagitty", quietly = TRUE)) {
dagitty_dag1 &lt;- pcalg2dagitty(amat,V,type="dag")
}
</code></pre>

<hr>
<h2 id='pcAlgo'>PC-Algorithm [OLD]: Estimate Skeleton or Equivalence Class of a DAG</h2><span id='topic+pcAlgo'></span><span id='topic+pcAlgo.Perfect'></span>

<h3>Description</h3>

<p>This function is DEPRECATED! Use <code><a href="#topic+skeleton">skeleton</a></code>, <code><a href="#topic+pc">pc</a></code> or
<code><a href="#topic+fci">fci</a></code> instead.
</p>
<p>Use the PC-algorithm to estimate the underlying graph
(&ldquo;skeleton&rdquo;) or the equivalence class (CPDAG) of a DAG.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcAlgo(dm = NA, C = NA, n=NA, alpha, corMethod = "standard",
       verbose=FALSE, directed=FALSE, G=NULL, datatype = "continuous",
       NAdelete=TRUE, m.max=Inf, u2pd = "rand", psepset=FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcAlgo_+3A_dm">dm</code></td>
<td>
<p>Data matrix; rows correspond to samples, cols correspond to
nodes.</p>
</td></tr>
<tr><td><code id="pcAlgo_+3A_c">C</code></td>
<td>
<p>Correlation matrix; this is an alternative for specifying the
data matrix.</p>
</td></tr>
<tr><td><code id="pcAlgo_+3A_n">n</code></td>
<td>
<p>Sample size; this is only needed if the data matrix is not
provided.</p>
</td></tr>
<tr><td><code id="pcAlgo_+3A_alpha">alpha</code></td>
<td>
<p>Significance level for the individual partial correlation tests.</p>
</td></tr>
<tr><td><code id="pcAlgo_+3A_cormethod">corMethod</code></td>
<td>
<p>A character string speciyfing the method for
(partial) correlation estimation.
&quot;standard&quot;, &quot;QnStable&quot;, &quot;Qn&quot; or &quot;ogkQn&quot; for standard and robust (based on
the Qn scale estimator without and with OGK) correlation
estimation.  For robust estimation, we recommend <code>"QnStable"</code>.</p>
</td></tr>
<tr><td><code id="pcAlgo_+3A_verbose">verbose</code></td>
<td>
<p>0-no output, 1-small output, 2-details;using 1 and 2
makes the function very much slower</p>
</td></tr>
<tr><td><code id="pcAlgo_+3A_directed">directed</code></td>
<td>
<p>If <code>FALSE</code>, the underlying skeleton is computed;
if <code>TRUE</code>, the underlying CPDAG is computed</p>
</td></tr>
<tr><td><code id="pcAlgo_+3A_g">G</code></td>
<td>
<p>The adjacency matrix of the graph from which the algorithm
should start (logical)</p>
</td></tr>
<tr><td><code id="pcAlgo_+3A_datatype">datatype</code></td>
<td>
<p>Distinguish between discrete and continuous data</p>
</td></tr>
<tr><td><code id="pcAlgo_+3A_nadelete">NAdelete</code></td>
<td>
<p>Delete edge if pval=NA (for discrete data)</p>
</td></tr>
<tr><td><code id="pcAlgo_+3A_m.max">m.max</code></td>
<td>
<p>Maximal size of conditioning set</p>
</td></tr>
<tr><td><code id="pcAlgo_+3A_u2pd">u2pd</code></td>
<td>
<p>Function used for converting skeleton to cpdag. &quot;rand&quot;
(use udag2pdag); &quot;relaxed&quot; (use udag2pdagRelaxed); &quot;retry&quot; (use
udag2pdagSpecial)</p>
</td></tr>
<tr><td><code id="pcAlgo_+3A_psepset">psepset</code></td>
<td>
<p>If true, also possible separation sets are tested.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> <code>"pcAlgo"</code> (see
<code><a href="#topic+pcAlgo-class">pcAlgo</a></code>) containing an undirected graph
(object of <code><a href="base.html#topic+class">class</a></code> <code>"graph"</code>, see
<code><a href="graph.html#topic+graph-class">graph-class</a></code> from the package <span class="pkg">graph</span>)
(without weigths) as estimate of the skeleton or the CPDAG of the
underlying DAG.
</p>


<h3>Author(s)</h3>

<p>Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>) and Martin Maechler.
</p>


<h3>References</h3>

<p>P. Spirtes, C. Glymour and R. Scheines (2000)
<em>Causation, Prediction, and Search</em>, 2nd edition, The MIT Press.
</p>
<p>Kalisch M. and P. B\&quot;uhlmann (2007)
<em>Estimating high-dimensional
directed acyclic graphs with the PC-algorithm</em>;
JMLR, Vol. 8, 613-636, 2007.
</p>

<hr>
<h2 id='pcAlgo-class'>Class &quot;pcAlgo&quot; of PC Algorithm Results, incl. Skeleton</h2><span id='topic+pcAlgo-class'></span><span id='topic+plot+2CpcAlgo+2CANY-method'></span><span id='topic+show+2CpcAlgo-method'></span><span id='topic+summary+2CpcAlgo-method'></span><span id='topic+print.pcAlgo'></span>

<h3>Description</h3>

<p>This class of objects is returned by the functions
<code><a href="#topic+skeleton">skeleton</a></code> and <code><a href="#topic+pc">pc</a></code> to represent the
(skeleton) of an estimated CPDAG.
Objects of this class have methods for the functions plot, show and
summary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S4 method for signature 'pcAlgo,ANY'
plot(x, y, main = NULL,
     zvalue.lwd = FALSE, lwd.max = 7, labels = NULL, ...)
## S3 method for class 'pcAlgo'
print(x, amat = FALSE, zero.print = ".", ...)

## S4 method for signature 'pcAlgo'
summary(object, amat = TRUE, zero.print = ".", ...)
## S4 method for signature 'pcAlgo'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcAlgo-class_+3A_x">x</code>, <code id="pcAlgo-class_+3A_object">object</code></td>
<td>
<p>a <code>"pcAlgo"</code> object.</p>
</td></tr>
<tr><td><code id="pcAlgo-class_+3A_y">y</code></td>
<td>
<p>(generic <code>plot()</code> argument; unused).</p>
</td></tr>
<tr><td><code id="pcAlgo-class_+3A_main">main</code></td>
<td>
<p>main title for the plot (with an automatic default).</p>
</td></tr>
<tr><td><code id="pcAlgo-class_+3A_zvalue.lwd">zvalue.lwd</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating if the line width
(<code>lwd</code>) of the edges should be made proportional to the entries
of matrix <code>zMin</code> (originally) or derived from matrix <code>pMax</code>.</p>
</td></tr>
<tr><td><code id="pcAlgo-class_+3A_lwd.max">lwd.max</code></td>
<td>
<p>maximal <code>lwd</code> to be used, if <code>zvalue.lwd</code> is true.</p>
</td></tr>
<tr><td><code id="pcAlgo-class_+3A_labels">labels</code></td>
<td>
<p>if non-<code>NULL</code>, these are used to define node attributes
<code>nodeAttrs</code> and <code>attrs</code>, passed to <code><a href="Rgraphviz.html#topic+agopen">agopen</a>()</code>
from package <span class="pkg">Rgraphviz</span>.</p>
</td></tr>
<tr><td><code id="pcAlgo-class_+3A_amat">amat</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating if the adjacency matrix
should be shown (printed) as well.</p>
</td></tr>
<tr><td><code id="pcAlgo-class_+3A_zero.print">zero.print</code></td>
<td>
<p>string for printing <code>0</code> (&lsquo;zero&rsquo;) entries
in the adjacency matrix.</p>
</td></tr>
<tr><td><code id="pcAlgo-class_+3A_...">...</code></td>
<td>
<p>optional further arguments (passed from and to methods).</p>
</td></tr>
</table>


<h3>Creation of objects</h3>

<p>Objects are typically created as result from
<code><a href="#topic+skeleton">skeleton</a>()</code> or <code><a href="#topic+pc">pc</a>()</code>, but could be
be created by calls of the form <code>new("pcAlgo", ...)</code>.
</p>


<h3>Slots</h3>

<p>The slots <code>call</code>, <code>n</code>, <code>max.ord</code>, <code>n.edgetests</code>,
<code>sepset</code>, and <code>pMax</code> are inherited from class
<code>"<a href="#topic+gAlgo-class">gAlgo</a>"</code>, see there.
</p>
<p>In addition, <code>"pcAlgo"</code> has slots
</p>

<dl>
<dt><code>graph</code>:</dt><dd><p>Object of class <code>"graph"</code>:
the undirected or partially directed graph that was estimated.</p>
</dd>
<dt><code>zMin</code>:</dt><dd><p>Deprecated.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+gAlgo-class">gAlgo</a>"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>plot</dt><dd><p><code>signature(x = "pcAlgo")</code>: Plot the resulting
graph. If argument <code>"zvalue.lwd"</code> is true, the
linewidth an edge reflects <code>zMin</code>, so that
thicker lines indicate more reliable dependencies. The argument
<code>"lwd.max"</code> controls the maximum linewidth.</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "pcAlgo")</code>: Show basic properties of
the fitted object</p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "pcAlgo")</code>: Show details of
the fitted object </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Markus Kalisch and Martin Maechler</p>


<h3>See Also</h3>

<p><code><a href="#topic+pc">pc</a></code>, <code><a href="#topic+skeleton">skeleton</a></code>,
<code><a href="#topic+fciAlgo-class">fciAlgo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  showClass("pcAlgo")

## generate a pcAlgo object
p &lt;- 8
set.seed(45)
myDAG &lt;- randomDAG(p, prob = 0.3)
n &lt;- 10000
d.mat &lt;- rmvDAG(n, myDAG, errDist = "normal")
suffStat &lt;- list(C = cor(d.mat), n = n)
pc.fit &lt;- pc(suffStat, indepTest = gaussCItest, alpha = 0.01, p = p)

## use methods of class pcAlgo
show(pc.fit)
if(require(Rgraphviz))
  plot(pc.fit, main = "Fitted graph")
summary(pc.fit)

## access slots of this object
(g  &lt;- pc.fit@graph)
str(ss &lt;- pc.fit@sepset, max=1)
</code></pre>

<hr>
<h2 id='pcorOrder'>Compute Partial Correlations</h2><span id='topic+pcorOrder'></span>

<h3>Description</h3>

<p>This function computes partial correlations given a correlation matrix
using a recursive algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcorOrder(i,j, k, C, cut.at = 0.9999999)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcorOrder_+3A_i">i</code>, <code id="pcorOrder_+3A_j">j</code></td>
<td>
<p>(integer) position of variable <code class="reqn">i</code> and <code class="reqn">j</code>,
respectively, in correlation matrix.</p>
</td></tr>
<tr><td><code id="pcorOrder_+3A_k">k</code></td>
<td>
<p>(integer) positions of zero or more conditioning variables in the
correlation matrix.</p>
</td></tr>
<tr><td><code id="pcorOrder_+3A_c">C</code></td>
<td>
<p>Correlation matrix (matrix)</p>
</td></tr>
<tr><td><code id="pcorOrder_+3A_cut.at">cut.at</code></td>
<td>
<p>Number slightly smaller than one; if <code class="reqn">c</code> is
<code>cut.at</code>, values outside of <code class="reqn">[-c,c]</code> are set to <code class="reqn">-c</code> or
<code class="reqn">c</code> respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The partial correlations are computed using a recusive formula
if the size of the conditioning set is one. For larger conditioning
sets, the pseudoinverse of parts of the correlation matrix is
computed (by <code><a href="corpcor.html#topic+pseudoinverse">pseudoinverse</a>()</code> from package
<span class="pkg">corpcor</span>).  The pseudoinverse instead of the inverse is used in
order to avoid numerical problems.
</p>


<h3>Value</h3>

<p>The partial correlation of i and j given the set k.
</p>


<h3>Author(s)</h3>

<p>Markus Kalisch <a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a> and Martin Maechler
</p>


<h3>See Also</h3>

<p><code><a href="#topic+condIndFisherZ">condIndFisherZ</a></code> for testing zero partial correlation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## produce uncorrelated normal random variables
mat &lt;- matrix(rnorm(3*20),20,3)
## compute partial correlation of var1 and var2 given var3
pcorOrder(1,2, 3, cor(mat))

## define graphical model, simulate data and compute
## partial correlation with bigger conditional set
genDAG &lt;- randomDAG(20, prob = 0.2)
dat &lt;- rmvDAG(1000, genDAG)
C &lt;- cor(dat)
pcorOrder(2,5, k = c(3,7,8,14,19), C)
</code></pre>

<hr>
<h2 id='pcSelect'>PC-Select: Estimate subgraph around a response variable</h2><span id='topic+pcSelect'></span>

<h3>Description</h3>

<p> The goal is feature selection: If you
have a response variable <code class="reqn">y</code> and a data matrix <code class="reqn">dm</code>, we want
to know which variables are &ldquo;strongly influential&rdquo; on <code class="reqn">y</code>. The
type of influence is the same as in the PC-Algorithm, i.e., <code class="reqn">y</code>
and <code class="reqn">x</code> (a column of <code class="reqn">dm</code>) are associated if they are
correlated even when conditioning on any subset of the remaining
columns in <code class="reqn">dm</code>. Therefore, only very strong relations will be
found and the result is typically a subset of other feature selection
techniques. Note that there are also robust correlation methods
available which render this method robust.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcSelect(y, dm, alpha, corMethod = "standard",
         verbose = FALSE, directed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcSelect_+3A_y">y</code></td>
<td>
<p>response vector.</p>
</td></tr>
<tr><td><code id="pcSelect_+3A_dm">dm</code></td>
<td>
<p>data matrix (rows: samples/observations, columns: variables);
<code>nrow(dm) == length(y)</code>.</p>
</td></tr>
<tr><td><code id="pcSelect_+3A_alpha">alpha</code></td>
<td>
<p>significance level of individual partial correlation tests.</p>
</td></tr>
<tr><td><code id="pcSelect_+3A_cormethod">corMethod</code></td>
<td>
<p>a string determining the method for correlation
estimation via <code><a href="#topic+mcor">mcor</a>()</code>; specifically any of the
<code>mcor(*, method = "..")</code> can be used, e.g., <code>"Qn"</code> for
one kind of robust correlation estimate.</p>
</td></tr>
<tr><td><code id="pcSelect_+3A_verbose">verbose</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> or in <code class="reqn">\{0,1,2\}</code>;
</p>

<dl>
<dt>FALSE, 0:</dt><dd><p>No output,</p>
</dd>
<dt>TRUE, 1:</dt><dd><p>Little output,</p>
</dd>
<dt>2:</dt><dd><p>Detailed output.</p>
</dd>
</dl>

<p>Note that such diagnostic output may make the function considerably slower.
</p>
</td></tr>
<tr><td><code id="pcSelect_+3A_directed">directed</code></td>
<td>
<p>logical; should the output graph be directed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function basically applies <code><a href="#topic+pc">pc</a></code> on the data
matrix obtained by joining <code>y</code> and <code>dm</code>.  Since the output is
not concerned with the edges found within the columns of <code>dm</code>,
the algorithm is adapted accordingly.  Therefore, the runtime and the
ability to deal with large datasets is typically increased
substantially.
</p>


<h3>Value</h3>

<table>
<tr><td><code>G</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> vector indicating which column of
<code>dm</code> is associated with <code>y</code>.</p>
</td></tr>
<tr><td><code>zMin</code></td>
<td>
<p>The minimal z-values when testing partial correlations
between <code>y</code> and each column of <code>dm</code>.  The larger the
number, the more consistent is the edge with the data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>) and Martin Maechler.
</p>


<h3>References</h3>

<p>Buehlmann, P., Kalisch, M. and Maathuis, M.H. (2010).
Variable selection for high-dimensional linear models:
partially faithful distributions and the PC-simple algorithm.
<em>Biometrika</em> <b>97</b>, 261&ndash;278.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pc">pc</a></code> which is the more general version of this function;
<code><a href="#topic+pcSelect.presel">pcSelect.presel</a></code> which applies <code>pcSelect()</code> twice.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- 10
## generate and draw random DAG :
suppressWarnings(RNGversion("3.5.0"))
set.seed(101)
myDAG &lt;- randomDAG(p, prob = 0.2)
if (require(Rgraphviz)) {
  plot(myDAG, main = "randomDAG(10, prob = 0.2)")
}
## generate 1000 samples of DAG using standard normal error distribution
n &lt;- 1000
d.mat &lt;- rmvDAG(n, myDAG, errDist = "normal")

## let's pretend that the 10th column is the response and the first 9
## columns are explanatory variable. Which of the first 9 variables
## "cause" the tenth variable?
y &lt;- d.mat[,10]
dm &lt;- d.mat[,-10]
(pcS &lt;- pcSelect(d.mat[,10], d.mat[,-10], alpha=0.05))
## You see, that variable 4,5,6 are considered as important
## By inspecting zMin,
with(pcS, zMin[G])
## you can also see that the influence of variable 6
## is most evident from the data (its zMin is 18.64, so quite large - as
## a rule of thumb for judging what is large, you could use quantiles
## of the Standard Normal Distribution)
</code></pre>

<hr>
<h2 id='pcSelect.presel'>Estimate Subgraph around a Response Variable using Preselection</h2><span id='topic+pcSelect.presel'></span>

<h3>Description</h3>

<p>This function uses <code><a href="#topic+pcSelect">pcSelect</a></code> to preselect some covariates
and then runs <code><a href="#topic+pcSelect">pcSelect</a></code> again on the reduced data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcSelect.presel(y, dm, alpha, alphapre, corMethod = "standard",
                verbose = 0, directed=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcSelect.presel_+3A_y">y</code></td>
<td>
<p>Response vector.</p>
</td></tr>
<tr><td><code id="pcSelect.presel_+3A_dm">dm</code></td>
<td>
<p>Data matrix (rows: samples, cols: nodes; i.e.,
<code>length(y) == nrow(dm)</code>).</p>
</td></tr>
<tr><td><code id="pcSelect.presel_+3A_alpha">alpha</code></td>
<td>
<p>Significance level of individual partial correlation
tests.  </p>
</td></tr>
<tr><td><code id="pcSelect.presel_+3A_alphapre">alphapre</code></td>
<td>
<p>Significance level for pcSelect in preselection</p>
</td></tr>
<tr><td><code id="pcSelect.presel_+3A_cormethod">corMethod</code></td>
<td>
<p>&quot;standard&quot; or &quot;Qn&quot; for standard or robust correlation
estimation</p>
</td></tr>
<tr><td><code id="pcSelect.presel_+3A_verbose">verbose</code></td>
<td>
<p>0-no output, 1-small output, 2-details (using 1 and 2
makes the function very much slower)</p>
</td></tr>
<tr><td><code id="pcSelect.presel_+3A_directed">directed</code></td>
<td>
<p>Logical; should the output graph be directed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First, <code>pcSelect</code> is run using <code>alphapre</code>. Then,
only the important variables are kept and <code>pcSelect</code> is run on
them again.
</p>


<h3>Value</h3>

<table>
<tr><td><code>pcs</code></td>
<td>
<p>Logical vector indicating which column of <code>dm</code> is
associated with <code>y</code></p>
</td></tr>
<tr><td><code>zMin</code></td>
<td>
<p>The minimal z-values when testing partial correlations
between <code>y</code> and each column of <code>dm</code>. The larger the number,
the more consistent is the edge with the data.</p>
</td></tr>
<tr><td><code>Xnew</code></td>
<td>
<p>Preselected Variables.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Philipp Ruetimann</p>


<h3>See Also</h3>

<p><code><a href="#topic+pcSelect">pcSelect</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- 10
## generate and draw random DAG :
set.seed(101)
myDAG &lt;- randomDAG(p, prob = 0.2)
if(require(Rgraphviz))
   plot(myDAG, main = "randomDAG(10, prob = 0.2)")

## generate 1000 samples of DAG using standard normal error distribution
n &lt;- 1000
d.mat &lt;- rmvDAG(n, myDAG, errDist = "normal")

## let's pretend that the 10th column is the response and the first 9
## columns are explanatory variable. Which of the first 9 variables
## "cause" the tenth variable?
y &lt;- d.mat[,10]
dm &lt;- d.mat[,-10]
res &lt;- pcSelect.presel(d.mat[,10], d.mat[,-10], alpha=0.05, alphapre=0.6)
</code></pre>

<hr>
<h2 id='pdag2allDags'>Enumerate All DAGs in a Markov Equivalence Class</h2><span id='topic+pdag2allDags'></span>

<h3>Description</h3>

<p><code>pdag2allDags</code> computes all DAGs in the Markov Equivalence Class
Represented by a Given Partially Directed Acyclic Graph (PDAG).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdag2allDags(gm, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdag2allDags_+3A_gm">gm</code></td>
<td>
<p>adjacency matrix of type <a href="#topic+amat.cpdag">amat.cpdag</a></p>
</td></tr>
<tr><td><code id="pdag2allDags_+3A_verbose">verbose</code></td>
<td>
<p>logical; if true, some output is produced during
computation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All DAGs extending the given PDAG are computing while avoiding new
v-structures and cycles. If no DAG is found, the function returns <code>NULL</code>.
</p>


<h3>Value</h3>

<p>List with two elements:
</p>
<table>
<tr><td><code>dags:</code></td>
<td>
<p>Matrix; every row corresponds to a DAG; every column
corresponds to an entry in the adjacency matrix of this DAG. Thus, the
adjacency matrix (of type <a href="#topic+amat.cpdag">amat.cpdag</a>) contained in the i-th row
of matrix <code>dags</code> can be obtained by calling
<code>matrix(dags[i,],p,p, byrow = TRUE)</code> (assuming the input PDAG has
<code>p</code> nodes).</p>
</td></tr> 
<tr><td><code>nodeNms</code></td>
<td>
<p>Node labels of the input PDAG.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>)</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example 1
gm &lt;- rbind(c(0,1),
            c(1,0))
colnames(gm) &lt;- rownames(gm) &lt;- LETTERS[1:2]
res1 &lt;- pdag2allDags(gm)
## adjacency matrix of first DAG in output
amat1 &lt;- matrix(res1$dags[1,],2,2, byrow = TRUE)
colnames(amat1) &lt;- rownames(amat1) &lt;- res1$nodeNms
amat1 ## A --&gt; B

## Example 2
gm &lt;- rbind(c(0,1,1),
            c(1,0,1),
            c(1,1,0))
colnames(gm) &lt;- rownames(gm) &lt;- LETTERS[1:ncol(gm)]
res2 &lt;- pdag2allDags(gm)
## adjacency matrix of first DAG in output
amat2 &lt;- matrix(res2$dags[1,],3,3, byrow = TRUE)
colnames(amat2) &lt;- rownames(amat2) &lt;- res2$nodeNms
amat2

## Example 3
gm &lt;- rbind(c(0,1,1,0,0),
            c(1,0,0,0,0),
            c(1,0,0,0,0),
            c(0,1,1,0,1),
            c(0,0,0,1,0))
colnames(gm) &lt;- rownames(gm) &lt;- LETTERS[1:ncol(gm)]
res3 &lt;- pdag2allDags(gm)
## adjacency matrix of first DAG in output
amat3 &lt;- matrix(res3$dags[1,],5,5, byrow = TRUE)
colnames(amat3) &lt;- rownames(amat3) &lt;- res3$nodeNms
amat3

## for convenience a simple plotting function
## for the function output
plotAllDags &lt;- function(res) {
    require(graph)
    p &lt;- sqrt(ncol(res$dags))
    nDags &lt;- ceiling(sqrt(nrow(res$dags)))
    par(mfrow = c(nDags, nDags))
    for (i in 1:nrow(res$dags)) {
        tmp &lt;- matrix(res$dags[i,],p,p)
        colnames(tmp) &lt;- rownames(tmp) &lt;- res$nodeNms
        plot(as(tmp, "graphNEL"))
    }
}
plotAllDags(res1)
amat1 ## adj.matrix corresponding to the first plot for expl 1
plotAllDags(res2)
amat2 ## adj.matrix corresponding to the first plot for expl 2
plotAllDags(res3)
amat3 ## adj.matrix corresponding to the first plot for expl 3
</code></pre>

<hr>
<h2 id='pdag2dag'>Extend a Partially Directed Acyclic Graph (PDAG) to a DAG</h2><span id='topic+pdag2dag'></span>

<h3>Description</h3>

<p>This function extends a PDAG (Partially Directed Acyclic Graph) to a
DAG, if this is possible. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdag2dag(g, keepVstruct=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdag2dag_+3A_g">g</code></td>
<td>
<p>Input PDAG (graph object)</p>
</td></tr>
<tr><td><code id="pdag2dag_+3A_keepvstruct">keepVstruct</code></td>
<td>
<p>Logical indicating if the v-structures in g are
kept.  Otherwise they are ignored and an arbitrary extension is
generated.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Direct undirected edges without creating directed cycles or additional
v-structures. 
The PDAG is consistently extended to a DAG using the algorithm by Dor and Tarsi
(1992).  If no extension is possible, a DAG corresponding to
the skeleton of the PDAG is generated and a warning message is produced.
</p>


<h3>Value</h3>

<p>List with entries
</p>
<table>
<tr><td><code>graph</code></td>
<td>
<p>Contains a consistent DAG extension (graph object),</p>
</td></tr>
<tr><td><code>success</code></td>
<td>
<p>Is <code>TRUE</code> iff the extension was possible.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Markus Kalisch <a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a></p>


<h3>References</h3>

<p>D.Dor, M.Tarsi (1992). A simple algorithm to construct a
consistent extension of a partially oriented graph.
Technicial Report R-185, Cognitive Systems Laboratory, UCLA
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- 10 # number of random variables
n &lt;- 10000 # number of samples
s &lt;- 0.4 # sparsness of the graph

## generate random data
set.seed(42)
g &lt;- randomDAG(p, prob = s) # generate a random DAG
d &lt;- rmvDAG(n,g) # generate random samples

gSkel &lt;- pcAlgo(d,alpha=0.05) # estimate of the skeleton

(gPDAG &lt;- udag2pdag(gSkel))

(gDAG &lt;- pdag2dag(gPDAG@graph))
</code></pre>

<hr>
<h2 id='pdsep'>Estimate Final Skeleton in the FCI algorithm</h2><span id='topic+pdsep'></span>

<h3>Description</h3>

<p>Estimate the final skeleton in the FCI algorithm (Spirtes et al, 2000),
as described in Steps 2 and 3 of Algorithm 3.1 in Colombo et
al. (2012).  The input of this function consists of an initial
skeleton that was estimated by the PC algorithm (Step 1 of Algorithm
3.1 in Colombo et al. (2012)).
</p>
<p>Given the initial skeleton, all unshielded triples are considered and
oriented as colliders when appropriate.  Then, for all nodes x in the
resulting partially directed graph G, Possible-D-SEP(x,G) is computed,
using the function <code>qreach</code>.  Finally, for any edge y-z that is
present in G and that is not flagged as fixed by the <code>fixedEdges</code>
argument, conditional independence between Y and Z is tested given
all subsets of Possible-D-SEP(y,G) and all subsets of
Possible-D-SEP(z,G).  These tests are done at level alpha, using
<code>indepTest</code>.  If the pair of nodes is judged to be independent
given some set S, then S is recorded in sepset(y,z) and sepset(z,y)
and the edge y-z is deleted.  Otherwise, the edge remains and there is
no change to sepset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdsep(skel, suffStat, indepTest, p, sepset, alpha, pMax, m.max = Inf,
      pdsep.max = Inf, NAdelete = TRUE, unfVect = NULL,
      biCC = FALSE, fixedEdges = NULL, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdsep_+3A_skel">skel</code></td>
<td>
<p>Graph object returned by <code><a href="#topic+skeleton">skeleton</a></code>.</p>
</td></tr>
<tr><td><code id="pdsep_+3A_suffstat">suffStat</code></td>
<td>
<p>Sufficient statistic: A list containing all necessary
elements for making conditional independence decisions using
function <code>indepTest</code>.</p>
</td></tr>
<tr><td><code id="pdsep_+3A_indeptest">indepTest</code></td>
<td>
<p>Predefined function for testing conditional independence. The
function is internally called as <code>indepTest(x,y,S,suffStat)</code> for
testing conditional independence of <code>x</code> and <code>y</code> given
<code>S</code>. Here, <code>x</code> and <code>y</code> are node numbers of the
adjacency matrix, <code>S</code> is a (possibly empty) vector of node
numbers of the adjacency matrix and <code>suffStat</code> is a list
containing all relevant elements for making conditional independence
decisions. The return value of <code>indepTest</code> is the p-value of
the test for conditional independence.</p>
</td></tr>
<tr><td><code id="pdsep_+3A_p">p</code></td>
<td>
<p>Number of variables.</p>
</td></tr>
<tr><td><code id="pdsep_+3A_sepset">sepset</code></td>
<td>
<p>List of length <code>p</code>; each element of the list
contains another list of length <code>p</code>.  The element
<code>sepset[[x]][[y]]</code> contains the separation set that made the edge
between <code>x</code> and <code>y</code> drop out.  This object is thought to be
obtained from a <code>pcAlgo</code>-object or <code>fciAlgo</code>-object.</p>
</td></tr>
<tr><td><code id="pdsep_+3A_alpha">alpha</code></td>
<td>
<p>Significance level for the individual conditional
independence tests.</p>
</td></tr>
<tr><td><code id="pdsep_+3A_pmax">pMax</code></td>
<td>
<p>Matrix with the maximal p-values of conditional
independence tests in a previous call of <code><a href="#topic+skeleton">skeleton</a></code>,
<code><a href="#topic+pc">pc</a></code> or <code><a href="#topic+fci">fci</a></code> which produced <code>G</code>. This
object is thought to be obtained from a <code>pcAlgo</code>-object or
<code>fciAlgo</code>-object.</p>
</td></tr>
<tr><td><code id="pdsep_+3A_m.max">m.max</code></td>
<td>
<p>Maximum size of the conditioning sets that are considered in the
conditional independence tests.</p>
</td></tr>
<tr><td><code id="pdsep_+3A_pdsep.max">pdsep.max</code></td>
<td>
<p>Maximum size of Possible-D-SEP for which subsets are
considered as conditioning sets in the conditional independence
tests. If the nodes <code>x</code> and <code>y</code> are adjacent in the graph
and the size of <code class="reqn">\textrm{Possible-D-SEP}(x,G) \setminus \{x, y\}</code>, is
bigger than pdsep.max, the edge is simply left in the graph.
Note that if pdsep.max is less than Inf, the final PAG
is typically a supergraph of the one computed with pdsep.max = Inf,
because fewer tests may have been performed in the former.</p>
</td></tr>
<tr><td><code id="pdsep_+3A_nadelete">NAdelete</code></td>
<td>
<p>If indepTest returns <code>NA</code> and this option is
<code>TRUE</code>, the corresponding edge is deleted. If this option is
<code>FALSE</code>, the edge is not deleted.</p>
</td></tr>
<tr><td><code id="pdsep_+3A_unfvect">unfVect</code></td>
<td>
<p>Vector containing numbers that encode the unfaithful
triple (as returned by <code><a href="#topic+pc.cons.intern">pc.cons.intern</a></code>). This is
needed in the conservative FCI.</p>
</td></tr>
<tr><td><code id="pdsep_+3A_bicc">biCC</code></td>
<td>
<p>Logical; if <code>TRUE</code>, only nodes on paths between nodes
a and c are considered to be in sepset(a,c).  This uses biconnected
components, see <code><a href="RBGL.html#topic+biConnComp">biConnComp</a></code> from <span class="pkg">RBGL</span>.</p>
</td></tr>
<tr><td><code id="pdsep_+3A_fixededges">fixedEdges</code></td>
<td>
<p>a logical <em>symmetric</em> matrix of dimension p*p.  If entry
<code>[i,j]</code> is true, the edge <code class="reqn">i--j</code> is never considered
for removal. Therefore, this edge is guaranteed to be <em>present</em> in
the resulting graph.</p>
</td></tr>
<tr><td><code id="pdsep_+3A_verbose">verbose</code></td>
<td>
<p>Logical indicating that detailed output is to be provided.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To make the code more efficient, we only perform tests that were not
performed in the estimation of the initial skeleton.
</p>
<p>Note that the Possible-D-SEP sets are computed once in the beginning. They are  not updated after edge deletions, in order to make sure that the output of the algorithm does not depend on the ordering of the variables (see also Colombo and Maathuis (2014)).
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>G</code></td>
<td>
<p>Updated adjacency matrix representing the final skeleton</p>
</td></tr>
<tr><td><code>sepset</code></td>
<td>
<p>Updated sepsets</p>
</td></tr>
<tr><td><code>pMax</code></td>
<td>
<p>Updated matrix containing maximal p-values</p>
</td></tr>
<tr><td><code>allPdsep</code></td>
<td>
<p>Possible-D-Sep for each node</p>
</td></tr>
<tr><td><code>max.ord</code></td>
<td>
<p>Maximal order of conditioning sets during independence
tests</p>
</td></tr>
<tr><td><code>n.edgetests</code></td>
<td>
<p>Number of conditional edgetests performed, grouped
by the size of the conditioning set.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>) and Diego Colombo.
</p>


<h3>References</h3>

<p>P. Spirtes, C. Glymour and R. Scheines (2000).
<em>Causation, Prediction, and Search</em>, 2nd edition. The MIT Press.
</p>
<p>D. Colombo, M.H. Maathuis, M. Kalisch and T.S. Richardson (2012).
Learning high-dimensional directed acyclic graphs with latent and
selection variables.
<em>Annals of Statistics</em> <b>40</b>, 294&ndash;321.
</p>
<p>D. Colombo and M.H. Maathuis (2014). Order-independent constraint-based
causal structure learning. <em>Journal of Machine Learning Research</em>
<b>15</b> 3741-3782. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qreach">qreach</a></code> to find Possible-D-SEP(x,G);
<code><a href="#topic+fci">fci</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- 10
## generate and draw random DAG:
set.seed(44)
myDAG &lt;- randomDAG(p, prob = 0.2)

## generate 10000 samples of DAG using gaussian distribution
library(RBGL)
n &lt;- 10000
d.mat &lt;- rmvDAG(n, myDAG, errDist = "normal")

## estimate skeleton
indepTest &lt;- gaussCItest
suffStat &lt;- list(C = cor(d.mat), n = n)
alpha &lt;- 0.01
skel &lt;- skeleton(suffStat, indepTest, alpha=alpha, p=p)

## prepare input for pdsep
sepset &lt;- skel@sepset
pMax &lt;- skel@pMax

## call pdsep to find Possible-D-Sep and enhance the skeleton
pdsepRes &lt;- pdsep(skel@graph, suffStat, indepTest, p, sepset, alpha,
                  pMax, verbose = TRUE)
## call pdsep with biconnected components to find Possible-D-Sep and enhance the skeleton
pdsepResBicc &lt;- pdsep(skel@graph, suffStat, indepTest, p, sepset, alpha,
                      pMax, biCC= TRUE, verbose = TRUE)
</code></pre>

<hr>
<h2 id='plotAG'>Plot partial ancestral graphs (PAG)</h2><span id='topic+plotAG'></span>

<h3>Description</h3>

<p>This function is DEPRECATED! Use the <code>plot</code> method of the
<code><a href="#topic+fciAlgo-class">fciAlgo</a></code> class instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotAG(amat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotAG_+3A_amat">amat</code></td>
<td>
<p>Adjacency matrix (coding 0,1,2,3 for no edge, circle,
arrowhead, tail; e.g., <code>amat[a,b] = 2</code> and <code>amat[b,a] = 3</code>
implies a -&gt; b)</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>)</p>


<h3>See Also</h3>

<p><code><a href="#topic+fci">fci</a></code></p>

<hr>
<h2 id='plotSG'>Plot the subgraph around a Specific Node in a Graph Object</h2><span id='topic+plotSG'></span>

<h3>Description</h3>

<p>Plots a subgraph for a specified starting node and a given graph.  The
subgraph consists of those nodes that can be reached from the starting
node by passing no more than a specified number of edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSG(graphObj, y, dist, amat = NA, directed = TRUE,
       plot = requireNamespace("Rgraphviz"), main = ,
       cex.main = 1.25, font.main = par("font.main"), col.main=par("col.main"),
       ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSG_+3A_graphobj">graphObj</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object of class <code><a href="graph.html#topic+graph-class">graph</a></code>.</p>
</td></tr>
<tr><td><code id="plotSG_+3A_y">y</code></td>
<td>
<p>(integer) position of the starting node in the adjacency matrix.</p>
</td></tr>
<tr><td><code id="plotSG_+3A_dist">dist</code></td>
<td>
<p>Distance of nodes included in subgraph from starting node <code>y</code>.</p>
</td></tr>
<tr><td><code id="plotSG_+3A_amat">amat</code></td>
<td>
<p>Precomputed adjacency matrix of type <a href="#topic+amat.cpdag">amat.cpdag</a> (optional)</p>
</td></tr>
<tr><td><code id="plotSG_+3A_directed">directed</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating if the subgraph
should be directed.</p>
</td></tr>
<tr><td><code id="plotSG_+3A_plot">plot</code></td>
<td>
<p>logical indicating if the subgraph should be plotted (or
just returned).  Defaults to true when <span class="pkg">Rgraphviz</span> is installed.</p>
</td></tr>
<tr><td><code id="plotSG_+3A_main">main</code></td>
<td>
<p>title to be used, with a sensible default; see
<code><a href="graphics.html#topic+title">title</a></code>.</p>
</td></tr>
<tr><td><code id="plotSG_+3A_cex.main">cex.main</code>, <code id="plotSG_+3A_font.main">font.main</code>, <code id="plotSG_+3A_col.main">col.main</code></td>
<td>
<p>optional settings for the
<code>main</code> title; see <code><a href="graphics.html#topic+title">title</a></code>.</p>
</td></tr>
<tr><td><code id="plotSG_+3A_...">...</code></td>
<td>
<p>optional arguments passed to the <code>plot()</code>
from package <span class="pkg">Rgraphviz</span>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Commencing at the starting point <code>y</code> the function looks for the
neighbouring nodes.  Beginning with direct parents and children it
will continue hierarchically through the distances to <code>y</code>.  Note
that the neighbourhood does <em>not</em> depend on edge directions.  If
<code>directed</code> is true (as per default), the orientation of the edges
is taken from the initial graph.
</p>
<p>For the plotting, the package <span class="pkg">Rgraphviz</span> must be installed.
</p>


<h3>Value</h3>

<p>the desired subgraph is returned; invisibly, i.e., via
<code><a href="base.html#topic+invisible">invisible</a></code>, if <code>plot</code> is true.
</p>


<h3>Author(s)</h3>

<p>Daniel Stekhoven, then Martin Maechler.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a random DAG:
p &lt;- 10
set.seed(45)
myDAG &lt;- randomDAG(p, prob = 0.3)

if(requireNamespace("Rgraphviz")) {
  ## plot whole the DAG
  plot(myDAG, main = "randomDAG(10, prob = 0.3)")

  op &lt;- par(mfrow = c(3,2))
  ## plot the neighbours of node number 8 up to distance 1
  plotSG(myDAG, 8, 1, directed = TRUE)
  plotSG(myDAG, 8, 1, directed = FALSE)

  ## plot the neighbours of node number 8 up to distance 2
  plotSG(myDAG, 8, 2, directed = TRUE)
  plotSG(myDAG, 8, 2, directed = FALSE)

  ## plot the neighbours of node number 8 up to distance 3
  plotSG(myDAG, 8, 3, directed = TRUE)
  plotSG(myDAG, 8, 3, directed = FALSE)

  ## Note that the layout of the subgraph might be different than in the
  ## original graph, but the graph structure is identical
  par(op)
} else { ## without 'Rgraphviz'
  sg2d &lt;- plotSG(myDAG, 8, 2, directed = TRUE,  plot=FALSE)
  sg2u &lt;- plotSG(myDAG, 8, 2, directed = FALSE, plot=FALSE)
}
</code></pre>

<hr>
<h2 id='possAn'>
Find possible ancestors of given node(s).
</h2><span id='topic+possAn'></span>

<h3>Description</h3>

<p>In a DAG, CPDAG, MAG or PAG determine which nodes are (possible) ancestors of x on definite status or just any paths potentially avoiding given nodes on the paths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>possAn(m, x, y = NULL, possible = TRUE, ds = TRUE,
type = c("cpdag", "pdag", "dag", "mag", "pag"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="possAn_+3A_m">m</code></td>
<td>

<p>Adjacency matrix in coding according to type.
</p>
</td></tr>
<tr><td><code id="possAn_+3A_x">x</code></td>
<td>

<p>Node positions of starting nodes.
</p>
</td></tr>
<tr><td><code id="possAn_+3A_y">y</code></td>
<td>

<p>Node positions of nodes through which a path must not go.
</p>
</td></tr>
<tr><td><code id="possAn_+3A_possible">possible</code></td>
<td>

<p>If <code>TRUE</code>, possible ancestors are returned.
</p>
</td></tr>
<tr><td><code id="possAn_+3A_ds">ds</code></td>
<td>

<p>If <code>TRUE</code>, only paths of definite status are considered.
</p>
</td></tr>
<tr><td><code id="possAn_+3A_type">type</code></td>
<td>

<p>Type of adjacency matrix in <code>m</code>. The coding is according to <code><a href="#topic+amatType">amatType</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Not all possible combinations of the arguments are currently implemented and will issue an error if called.
</p>


<h3>Value</h3>

<p>Vector of all node positions found as (possible) ancestors of the nodes in <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Markus Kalisch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+amatType">amatType</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a -- b -&gt; c
amat &lt;- matrix(c(0,1,0, 1,0,1, 0,0,0), 3,3)
colnames(amat) &lt;- rownames(amat) &lt;- letters[1:3]
plot(as(t(amat), "graphNEL"))

possAn(m = amat, x = 3, possible = TRUE, ds = FALSE, type = "pdag") ## all nodes
possAn(m = amat, x = 3, y = 2, possible = TRUE, ds = FALSE, type = "pdag") ## only node 1
</code></pre>

<hr>
<h2 id='possDe'>
Find possible descendants of given node(s).
</h2><span id='topic+possDe'></span>

<h3>Description</h3>

<p>In a DAG, CPDAG, MAG or PAG determine which nodes are (possible) descendants of x on definite status or just any paths potentially avoiding given nodes on the paths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>possDe(m, x, y = NULL, possible = TRUE, ds = TRUE,
type = c("cpdag", "pdag", "dag", "mag", "pag"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="possDe_+3A_m">m</code></td>
<td>

<p>Adjacency matrix in coding according to type.
</p>
</td></tr>
<tr><td><code id="possDe_+3A_x">x</code></td>
<td>

<p>Node positions of starting nodes.
</p>
</td></tr>
<tr><td><code id="possDe_+3A_y">y</code></td>
<td>

<p>Node positions of nodes through which a path must not go.
</p>
</td></tr>
<tr><td><code id="possDe_+3A_possible">possible</code></td>
<td>

<p>If <code>TRUE</code>, possible descendents are returned.
</p>
</td></tr>
<tr><td><code id="possDe_+3A_ds">ds</code></td>
<td>

<p>If <code>TRUE</code>, only paths of definite status are considered.
</p>
</td></tr>
<tr><td><code id="possDe_+3A_type">type</code></td>
<td>

<p>Type of adjacency matrix in <code>m</code>. The coding is according to <code><a href="#topic+amatType">amatType</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Not all possible combinations of the arguments are currently implemented and will issue an error if called.
</p>


<h3>Value</h3>

<p>Vector of all node positions found as (possible) descendents of the nodes in <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Markus Kalisch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+amatType">amatType</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a -&gt; b -- c
amat &lt;- matrix(c(0,1,0, 0,0,1, 0,1,0), 3,3)
colnames(amat) &lt;- rownames(amat) &lt;- letters[1:3]
plot(as(t(amat), "graphNEL"))

possDe(m = amat, x = 1, possible = TRUE, ds = FALSE, type = "pdag") ## all nodes
possDe(m = amat, x = 1, possible = FALSE, ds = FALSE, type = "pdag") ## only nodes 1 and 2
possDe(m = amat, x = 1, y = 2, possible = TRUE, ds = FALSE, type = "pdag") ## only node 1
</code></pre>

<hr>
<h2 id='possibleDe'>
[DEPRECATED] Find possible descendants on definite status paths.
</h2><span id='topic+possibleDe'></span>

<h3>Description</h3>

<p>This function is DEPRECATED! Use <code><a href="#topic+possDe">possDe</a></code> instead.
</p>
<p>In a DAG, CPDAG, MAG or PAG determine which nodes are possible descendants
of x on definite status paths. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>possibleDe(amat, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="possibleDe_+3A_amat">amat</code></td>
<td>
<p>adjacency matrix of type <a href="#topic+amat.pag">amat.pag</a></p>
</td></tr>
<tr><td><code id="possibleDe_+3A_x">x</code></td>
<td>
<p>(integer) position of node <code class="reqn">x</code> (node of interest) in the
adjacency matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A non-endpoint vertex <code>X</code> on a path <code>p</code> in a partial mixed
graph is said to be of a <em>definite status</em> if it is either a collider or a
definite non-collider on <code>p</code>. The path <code>p</code> is said to be of a
<em>definite status</em> if all non-endpoint vertices on the path are of a
definite status (see e.g. Maathuis and Colombo (2015), Def. 3.4).
</p>
<p>A possible descendent of x can be reached moving to adjacent nodes of x
but never going against an arrowhead. 
</p>


<h3>Value</h3>

<p>Vector with possible descendents.
</p>


<h3>Author(s)</h3>

<p>Diego Colombo
</p>


<h3>References</h3>

<p>M.H. Maathuis and D. Colombo (2015). A generalized back-door
criterion. <em>Annals of Statistics</em> <b>43</b> 1060-1088.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+backdoor">backdoor</a></code>, <a href="#topic+amatType">amatType</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>amat &lt;- matrix( c(0,3,0,0,0,0, 2,0,2,0,0,0, 0,3,0,0,0,0, 0,0,0,0,1,0,
0,0,0,1,0,1, 0,0,0,0,1,0), 6,6)
colnames(amat) &lt;- rownames(amat) &lt;- letters[1:6]
if(require(Rgraphviz)) {
plotAG(amat)
}

possibleDe(amat, 1) ## a, b are poss. desc. of a
possibleDe(amat, 4) ## d, e, f are poss. desc. of d
</code></pre>

<hr>
<h2 id='qreach'>Compute Possible-D-SEP(x,G) of a node x in a PDAG G</h2><span id='topic+qreach'></span>

<h3>Description</h3>

<p>Let G be a graph with the following edge types: o-o, o-&gt; or &lt;-&gt;, and
let x be a vertex in the graph.  Then this function computes
Possible-D-SEP(x,G), which is defined as follows: 
</p>
<p>v is in Possible-D-SEP(x,G) iff there is a path p between x and v in G
such that for every subpath &lt;s,t,u&gt; of p, t is a collider on this
subpath or &lt;s,t,u&gt; is a triangle in G.
</p>
<p>See Spirtes et al (2000) or Definition 3.3 of Colombo et al (2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  qreach(x, amat, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qreach_+3A_x">x</code></td>
<td>
<p>(integer) position of vertex <code class="reqn">x</code> in the adjacency matrix of
which Possible-D-SEP set is to be computed.</p>
</td></tr>
<tr><td><code id="qreach_+3A_amat">amat</code></td>
<td>
<p>Adjacency matrix of type <a href="#topic+amat.pag">amat.pag</a>.
</p>
</td></tr>
<tr><td><code id="qreach_+3A_verbose">verbose</code></td>
<td>
<p>Logical, asking for details on output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of column positions indicating the nodes in Possible-D-SEP of x.
</p>


<h3>Author(s)</h3>

<p>Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>)</p>


<h3>References</h3>

<p>P. Spirtes, C. Glymour and R. Scheines (2000).
<em>Causation, Prediction, and Search</em>, 2nd edition, The MIT Press.
</p>
<p>D. Colombo, M.H. Maathuis, M. Kalisch, T.S. Richardson (2012).
Learning high-dimensional directed acyclic graphs with latent and
selection variables. 
<em>Annals of Statistics</em> <b>40</b>, 294&ndash;321.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fci">fci</a></code> and <code><a href="#topic+pdsep">pdsep</a></code> which both use
this function.
</p>

<hr>
<h2 id='r.gauss.pardag'>Generate a Gaussian Causal Model Randomly</h2><span id='topic+r.gauss.pardag'></span>

<h3>Description</h3>

<p>Generate a random Gaussian causal model.  Parameters specifying the
connectivity as well as coefficients and error terms of the corresponding
linear structural equation model can be specified.  The observational
expectation value of the generated model is always 0, meaning that no
interception terms are drawn.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r.gauss.pardag(p, prob, top.sort = FALSE, normalize = FALSE,
               lbe = 0.1, ube = 1, neg.coef = TRUE, labels = as.character(1:p),
               lbv = 0.5, ubv = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="r.gauss.pardag_+3A_p">p</code></td>
<td>
<p>the number of nodes.</p>
</td></tr>
<tr><td><code id="r.gauss.pardag_+3A_prob">prob</code></td>
<td>
<p>probability of connecting a node to another node.</p>
</td></tr>
<tr><td><code id="r.gauss.pardag_+3A_top.sort">top.sort</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating whether the output graph should be
topologically sorted, meaning that arrows always point from lower
to higher node indices.</p>
</td></tr>
<tr><td><code id="r.gauss.pardag_+3A_normalize">normalize</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating whether weights and error variances
should be normalized such that the diagonal of the corresponding
observational covariance matrix is 1.</p>
</td></tr>
<tr><td><code id="r.gauss.pardag_+3A_lbe">lbe</code>, <code id="r.gauss.pardag_+3A_ube">ube</code></td>
<td>
<p>lower and upper bounds of the absolute values of edge
weights.</p>
</td></tr>
<tr><td><code id="r.gauss.pardag_+3A_neg.coef">neg.coef</code></td>
<td>
<p>logical indicating whether negative edge weights are also
admissible.</p>
</td></tr>
<tr><td><code id="r.gauss.pardag_+3A_labels">labels</code></td>
<td>
<p>(optional) character vector of variable (or &ldquo;node&rdquo;) names.</p>
</td></tr>
<tr><td><code id="r.gauss.pardag_+3A_lbv">lbv</code>, <code id="r.gauss.pardag_+3A_ubv">ubv</code></td>
<td>
<p>lower and upper bound on error variances of the noise terms
in the structural equations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The underlying directed acyclic
graph (DAG) is generated by drawing an undirected graph from an Erdős-Rényi
model orienting the edges according to a random topological ordering drawn
uniformly from the set of permutations of <code>p</code> variables. This means that
any two nodes are connected with (the same) probability <code>prob</code>, and that
the connectivity of different pairs of nodes is independent.
</p>
<p>A Gaussian causal model can be represented as a set of linear structural
equations.  The regression coefficients of the model can be represented as
&quot;edge weights&quot; of the DAG.  Edge weights are drawn uniformly and
independently from the interval between <code>lbe</code> and <code>ube</code>; if
<code>neg.coef = TRUE</code>, their sign is flipped with probability 0.5.  Error
variances are drawn uniformly and independently from the interval between
<code>lbv</code> and <code>ubv</code>.
</p>
<p>If <code>normalize = TRUE</code>, the edge weights and error variances are
normalized <em>in the end</em> to ensure that the diagonal elements of the
observational covariance matrix are all 1; the procedure used is described in
Hauser and Bühlmann (2012).  Note that in this case the error variances and
edge weights are no longer guaranteed to lie in the specified intervals
<em>after normalization</em>.
</p>


<h3>Value</h3>

<p>An object of class <code>"<a href="#topic+GaussParDAG-class">GaussParDAG</a>"</code>.
</p>


<h3>Author(s)</h3>

<p>Alain Hauser (<a href="mailto:alain.hauser@bfh.ch">alain.hauser@bfh.ch</a>)
</p>


<h3>References</h3>

<p>P. Erdős and A. Rényi (1960).  On the evolution of random graphs.
<em>Publications of the Mathematical Institute of the Hungarian Academy of
Sciences</em> <b>5</b>, 17&ndash;61.
</p>
<p>A. Hauser and P. Bühlmann (2012).  Characterization and greedy learning of
interventional Markov equivalence classes of directed acyclic graphs.
<em>Journal of Machine Learning Research</em> <b>13</b>, 2409&ndash;2464.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GaussParDAG-class">GaussParDAG</a></code>, <code><a href="#topic+randomDAG">randomDAG</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(307)

## Plot some random DAGs
if (require(Rgraphviz)) {
  ## Topologically sorted random DAG
  myDAG &lt;- r.gauss.pardag(p = 10, prob = 0.2, top.sort = TRUE)
  plot(myDAG)

  ## Unsorted DAG
  myDAG &lt;- r.gauss.pardag(p = 10, prob = 0.2, top.sort = FALSE)
  plot(myDAG)
}

## Without normalization, edge weigths and error variances lie within the
## specified borders
set.seed(307)
myDAG &lt;- r.gauss.pardag(p = 10, prob = 0.4,
  lbe = 0.1, ube = 1, lbv = 0.5, ubv = 1.5, neg.coef = FALSE)
B &lt;- myDAG$weight.mat()
V &lt;- myDAG$err.var()
any((B &gt; 0 &amp; B &lt; 0.1) | B &gt; 1)
any(V &lt; 0.5 | V &gt; 1.5)

## After normalization, edge weights and error variances are not necessarily
## within the specified range, but the diagonal of the observational covariance
## matrix consists of ones only
set.seed(308)
myDAG &lt;- r.gauss.pardag(p = 10, prob = 0.4, normalize = TRUE,
  lbe = 0.1, ube = 1, lbv = 0.5, ubv = 1.5, neg.coef = FALSE)
B &lt;- myDAG$weight.mat()
V &lt;- myDAG$err.var()
any((B &gt; 0 &amp; B &lt; 0.1) | B &gt; 1)
any(V &lt; 0.5 | V &gt; 1.5)
diag(myDAG$cov.mat())
</code></pre>

<hr>
<h2 id='randDAG'>Random DAG Generation</h2><span id='topic+randDAG'></span>

<h3>Description</h3>

<p>Generating random directed acyclic graphs (DAGs) with fixed expected
number of neighbours.  Several different methods are provided, each
intentionally biased towards certain properties.  The methods are based
on the analogue <code>*.game</code> functions in the <span class="pkg">igraph</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randDAG(n, d, method ="er", par1=NULL, par2=NULL,
        DAG = TRUE, weighted = TRUE, wFUN = list(runif, min=0.1, max=1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randDAG_+3A_n">n</code></td>
<td>
<p>integer, at least <code>2</code>, indicating the number of nodes in
the DAG.</p>
</td></tr> 
<tr><td><code id="randDAG_+3A_d">d</code></td>
<td>
<p>a positive number, corresponding to the expected number of
neighbours per node, more precisely the expected sum of the in- and
out-degree.</p>
</td></tr> 
<tr><td><code id="randDAG_+3A_method">method</code></td>
<td>
<p>a string, specifying the method used for generating the
random graph.  See details below.</p>
</td></tr>
<tr><td><code id="randDAG_+3A_par1">par1</code>, <code id="randDAG_+3A_par2">par2</code></td>
<td>
<p>optional additional arguments, dependent on the
method.  See details.</p>
</td></tr>
<tr><td><code id="randDAG_+3A_dag">DAG</code></td>
<td>
<p>logical, if <code>TRUE</code>, labelled graph is directed to a labelled acyclic graph.</p>
</td></tr>
<tr><td><code id="randDAG_+3A_weighted">weighted</code></td>
<td>
<p>logical indicating if edge weights are computed according to <code>wFUN</code>.</p>
</td></tr>
<tr><td><code id="randDAG_+3A_wfun">wFUN</code></td>
<td>
<p>a <code><a href="base.html#topic+function">function</a></code> for computing the edge weights in
the DAG.  It takes as first argument a number of edges <code>m</code> for
which it returns a vector of length <code>m</code> containing the
weights.  Alternatively, <code>wFUN</code> can be a <code><a href="base.html#topic+list">list</a></code>
consisting of the function in the first entry and of further
arguments of the function in the additional entries.  The default
(only if <code>weighted</code> is true) is a uniform weight in <code class="reqn">[0.1,
      1]</code>.  See the examples for more.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A (weighted) random graph with <code>n</code> nodes and expected number of
neighbours <code>d</code> is constructed.  For <code>DAG=TRUE</code>, the graph is
oriented to a DAG.  There are eight different random graph models
provided, each selectable by the parameters <code>method</code>,
<code>par1</code> and <code>par2</code>, with <code>method</code>, a string,
taking one of the following values:
</p>

<dl>
<dt><code>regular</code>:</dt><dd><p>Graph where every node has exactly <code>d</code>
incident edges. <code>par1</code> and <code>par2</code> are not used.</p>
</dd>
<dt><code>watts</code>:</dt><dd><p>Watts-Strogatz graph that interpolates between
the regular (<code>par1-&gt;0</code>) and Erdoes-Renyi graph
(<code>par1-&gt;1</code>).  The parameter <code>par1</code> is per default
<code>0.5</code> and has to be in <code>(0,1)</code>. <code>par2</code> is not used.</p>
</dd>
<dt><code>er</code>:</dt><dd><p>Erdoes-Renyi graph where every edge is present
independently. <code>par1</code> and <code>par2</code> are not used.</p>
</dd>
<dt><code>power</code>:</dt><dd><p>A graph with power-law degree distribution with
expectation <code>d</code>.<code>par1</code> and <code>par2</code> are not used.</p>
</dd> 
<dt><code>bipartite</code>:</dt><dd><p>Bipartite graph with at least <code>par1*n</code>
nodes in group 1 and at most <code>(1-par1)*n</code> nodes in group 2.
The argument <code>par1</code> has to be in <code>[0,1]</code> and is per
default <code>0.5</code>. <code>par2</code> is not used.</p>
</dd>
<dt><code>barabasi</code>:</dt><dd><p>A graph with power-law degree distribution
and preferential attachement according to parameter <code>par1</code>.  It
must hold that <code>par1 &gt;= 1</code> and the default is
<code>par1=1</code>. <code>par2</code> is not used.</p>
</dd>
<dt><code>geometric</code>:</dt><dd><p>A geometric random graph in dimension
<code>par1</code>, where  <code>par1</code> can take values from
<code>{2,3,4,5}</code> and is per default <code>2</code>.  If <code>par2="geo"</code>
and <code>weighted=TRUE</code>, then the weights are computed according to
the Euclidean distance. There are currently no other option for
<code>par2</code> implemented.</p>
</dd>
<dt><code>interEr</code>:</dt><dd><p>A graph with <code>par1</code> islands of
Erdoes-Renyi graphs, every pair of those connected by a certain
number of edges proportional to <code>par2</code> (fraction of
inter-connectivity).  It is required that
<code class="reqn">n/s</code> be integer and <code>par2</code> in <code class="reqn">(0,1)</code>.  Defaults are
<code>par1=2</code> and <code>par2=0.25</code>, respectively.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A graph object of class <code><a href="graph.html#topic+graphNEL">graphNEL</a></code>.
</p>


<h3>Note</h3>

<p>The output is <em>not</em> topologically sorted (as opposed to the
output of <code><a href="#topic+randomDAG">randomDAG</a></code>).
</p>


<h3>Author(s)</h3>

<p>Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>) and Manuel Schuerch.</p>


<h3>References</h3>

<p>These methods are mainly based on the analogue functions in the <span class="pkg">igraph</span> package.
</p>


<h3>See Also</h3>

<p>the package <code><a href="igraph.html#topic+igraph">igraph</a></code>, notably help pages such as
<code><a href="igraph.html#topic+sample_k_regular">sample_k_regular</a></code> or <code><a href="igraph.html#topic+sample_smallworld">sample_smallworld</a></code>;
</p>
<p><code><a href="unifDAG.html#topic+unifDAG">unifDAG</a></code> from package <span class="pkg">unifDAG</span> for generating uniform random DAGs.
</p>
<p><code><a href="#topic+randomDAG">randomDAG</a></code> a limited and soon deprecated version of <code><a href="#topic+randDAG">randDAG</a></code>;
<code><a href="#topic+rmvDAG">rmvDAG</a></code> for generating multivariate data according to a DAG.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(37)
dag1 &lt;- randDAG(10, 4, "regular")
dag2 &lt;- randDAG(10, 4, "watts")
dag3 &lt;- randDAG(10, 4, "er")
dag4 &lt;- randDAG(10, 4, "power")
dag5 &lt;- randDAG(10, 4, "bipartite")
dag6 &lt;- randDAG(10, 4, "barabasi")
dag7 &lt;- randDAG(10, 4, "geometric")
dag8 &lt;- randDAG(10, 4, "interEr", par2 = 0.5)

## require("Rgraphviz")
par(mfrow=c(4,2))
plot(dag1,main="Regular graph")
plot(dag2,main="Watts-Strogatz graph")
plot(dag3,main="Erdoes-Renyi graph")
plot(dag4,main="Power-law graph")
plot(dag5,main="Bipartite graph")
plot(dag6,main="Barabasi graph")
plot(dag7,main="Geometric random graph")
plot(dag8,main="Interconnected island graph")

set.seed(45)
dag0 &lt;- randDAG(6,3)
dag1 &lt;- randDAG(6,3, weighted=FALSE)
dag2 &lt;- randDAG(6,3, DAG=FALSE)
par(mfrow=c(1,2))
plot(dag1)
plot(dag2)      ## undirected graph
dag0@edgeData   ## note the uniform weights between 0.1 and 1
dag1@edgeData   ## note the constant weights

wFUN &lt;- function(m,lB,uB) { runif(m,lB,uB) }
dag &lt;- randDAG(6,3,wFUN=list(wFUN,1,4))
dag@edgeData   ## note the uniform weights between 1 and 4
</code></pre>

<hr>
<h2 id='randomDAG'>Generate a Directed Acyclic Graph (DAG) randomly</h2><span id='topic+randomDAG'></span>

<h3>Description</h3>

<p>Generate a random Directed Acyclic Graph (DAG).  The resulting graph
is topologically ordered from low to high node numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomDAG(n, prob, lB = 0.1, uB = 1, V = as.character(1:n))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randomDAG_+3A_n">n</code></td>
<td>
<p>Number of nodes, <code class="reqn">n \ge 2</code>.</p>
</td></tr>
<tr><td><code id="randomDAG_+3A_prob">prob</code></td>
<td>
<p>Probability of connecting a node to another node with
higher topological ordering.</p>
</td></tr>
<tr><td><code id="randomDAG_+3A_lb">lB</code>, <code id="randomDAG_+3A_ub">uB</code></td>
<td>
<p>Lower and upper limit of edge weights, chosen uniformly
at random, i.e., by <code><a href="stats.html#topic+runif">runif</a>(., min=lB, max=uB)</code>.</p>
</td></tr>
<tr><td><code id="randomDAG_+3A_v">V</code></td>
<td>
<p><code><a href="base.html#topic+character">character</a></code> vector length <code>n</code> of node names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>n</code> nodes are ordered.  Start with first node.  Let the
number of nodes with higher order be k.  Then, the number of
neighbouring nodes is drawn as Bin(k, <code>prob</code>).  The neighbours are
then drawn without replacement from the nodes with higher order.  For
each node, a weight is uniformly sampled from <code>lB</code> to <code>uB</code>.
This procedure is repeated for the next node in the original ordering
and so on.
</p>


<h3>Value</h3>

<p>An object of class <code>"graphNEL"</code>, see
<code><a href="graph.html#topic+graph-class">graph-class</a></code> from package <span class="pkg">graph</span>, with <code>n</code>
named (&quot;1&quot; to &quot;n&quot;) nodes and directed edges.  The graph is
topologically ordered.
Each edge has a weight between <code>lB</code> and <code>uB</code>.
</p>


<h3>Author(s)</h3>

<p>Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>) and Martin Maechler
</p>


<h3>See Also</h3>

<p><code><a href="#topic+randDAG">randDAG</a></code> for a more elaborate version of this
function; <code><a href="#topic+rmvDAG">rmvDAG</a></code> for generating data according to a
DAG; <code><a href="#topic+compareGraphs">compareGraphs</a></code> for comparing the skeleton of a DAG
with some other undirected graph (in terms of TPR, FPR and TDR).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(101)
myDAG &lt;- randomDAG(n = 20, prob= 0.2, lB = 0.1, uB = 1)
## require(Rgraphviz)
plot(myDAG)
</code></pre>

<hr>
<h2 id='rfci'>Estimate an RFCI-PAG using the RFCI Algorithm</h2><span id='topic+rfci'></span>

<h3>Description</h3>

<p>Estimate an RFCI-PAG from observational data, using the RFCI-algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rfci(suffStat, indepTest, alpha, labels, p,
     skel.method = c("stable", "original", "stable.fast"),
     fixedGaps = NULL, fixedEdges = NULL, NAdelete = TRUE,
     m.max = Inf, rules = rep(TRUE, 10),
     conservative = FALSE, maj.rule = FALSE, 
     numCores = 1, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rfci_+3A_suffstat">suffStat</code></td>
<td>
<p>Sufficient statistics: List containing all necessary
elements for the conditional independence decisions in the
function <code>indepTest</code>.</p>
</td></tr>
<tr><td><code id="rfci_+3A_indeptest">indepTest</code></td>
<td>
<p>Predefined function for testing conditional independence. The
function is internally called as <code>indepTest(x,y,S,suffStat)</code>, and
tests conditional independence of <code>x</code> and <code>y</code> given
<code>S</code>. Here, <code>x</code> and <code>y</code> are variables, and <code>S</code> is
a (possibly empty) vector of variables (all variables are denoted
by their column numbers
in the adjacency matrix). <code>suffStat</code> is a list containing
all relevant elements for the conditional independence
decisions. The return value of <code>indepTest</code> is the p-value of
the test for conditional independence.</p>
</td></tr>
<tr><td><code id="rfci_+3A_alpha">alpha</code></td>
<td>
<p>significance level (number in <code class="reqn">(0,1)</code> for the
individual conditional independence tests.</p>
</td></tr>
<tr><td><code id="rfci_+3A_labels">labels</code></td>
<td>
<p>(optional) character vector of variable (or
&ldquo;node&rdquo;) names.  Typically preferred to specifying <code>p</code>.</p>
</td></tr>
<tr><td><code id="rfci_+3A_p">p</code></td>
<td>
<p>(optional) number of variables (or nodes).  May be specified
if <code>labels</code> are not, in which case <code>labels</code> is set to
<code>1:p</code>.</p>
</td></tr>
<tr><td><code id="rfci_+3A_skel.method">skel.method</code></td>
<td>
<p>Character string specifying method; the default,
<code>"stable"</code> provides an <em>order-independent</em> skeleton, see
<code><a href="#topic+skeleton">skeleton</a></code>.</p>
</td></tr>
<tr><td><code id="rfci_+3A_fixedgaps">fixedGaps</code></td>
<td>
<p>A logical matrix of dimension p*p. If entry
<code>[i,j]</code> or <code>[j,i]</code> (or both) are TRUE, the edge i-j is
removed before starting the algorithm. Therefore, this edge is
guaranteed to be absent in the resulting graph.</p>
</td></tr>
<tr><td><code id="rfci_+3A_fixededges">fixedEdges</code></td>
<td>
<p>A logical matrix of dimension p*p. If entry
<code>[i,j]</code> or <code>[j,i]</code> (or both) are TRUE, the edge i-j is
never considered for removal. Therefore, this edge is
guaranteed to be present in the resulting graph.</p>
</td></tr>
<tr><td><code id="rfci_+3A_nadelete">NAdelete</code></td>
<td>
<p>If indepTest returns <code>NA</code> and this option is
<code>TRUE</code>, the corresponding edge is deleted. If this option is
<code>FALSE</code>, the edge is not deleted.</p>
</td></tr>
<tr><td><code id="rfci_+3A_m.max">m.max</code></td>
<td>
<p>Maximum size of the conditioning sets that are considered in the
conditional independence tests.</p>
</td></tr>
<tr><td><code id="rfci_+3A_rules">rules</code></td>
<td>
<p>Logical vector of length 10 indicating which rules
should be used when directing edges. The order of the rules is taken
from Zhang (2009).</p>
</td></tr>
<tr><td><code id="rfci_+3A_conservative">conservative</code></td>
<td>
<p>Logical indicating if the unshielded triples
should be checked for ambiguity after the skeleton has been found,
similar to the conservative PC algorithm.</p>
</td></tr>
<tr><td><code id="rfci_+3A_maj.rule">maj.rule</code></td>
<td>
<p>Logical indicating if the unshielded triples should be
checked for ambiguity after the skeleton has been found using a
majority rule idea, which is less strict than the conservative.</p>
</td></tr>
<tr><td><code id="rfci_+3A_numcores">numCores</code></td>
<td>
<p>Specifies the number of cores to be used for parallel
estimation of <code><a href="#topic+skeleton">skeleton</a></code>.</p>
</td></tr>
<tr><td><code id="rfci_+3A_verbose">verbose</code></td>
<td>
<p>If true, more detailed output is provided.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is rather similar to <a href="#topic+fci">fci</a>. However, it does not
compute any Possible-D-SEP sets and thus does not make tests
conditioning on subsets of Possible-D-SEP. This makes RFCI much faster
than FCI. The orientation rules for v-structures and rule 4 were
modified in order to produce an RFCI-PAG which, in the oracle version,
is guaranteed to have the correct ancestral relationships.
</p>
<p>The first part of the RFCI algorithm is analogous to the PC and FCI
algorithm. It starts with a complete undirected graph and estimates an
initial skeleton using the function <code><a href="#topic+skeleton">skeleton</a></code>, which
produces an initial order-independent skeleton, see
<code><a href="#topic+skeleton">skeleton</a></code> for more details. All edges
of this skeleton are of the form o-o. Due to the presence of hidden
variables, it is no longer sufficient to consider only subsets of the
neighborhoods of nodes <code>x</code> and <code>y</code> to decide whether the
edge <code>x o-o y</code> should be removed. The FCI algorithm performs
independence tests conditioning on subsets of Possible-D-SEP to remove
those edges. Since this procedure is computationally infeasible, the
RFCI algorithm uses a different approach to remove some of those
superfluous edges before orienting the v-structures and the
discriminating paths in orientation rule 4.
</p>
<p>Before orienting the v-structures, we perform the following additional
conditional independence tests. For each unshielded triple a-b-c in
the initial skeleton, we check if both a and b and b and c are
conditionally dependent given the separating of a and c
(sepset(a,c)). These conditional dependencies may not have been
checked while estimating the initial skeleton, since sepset(a,c) does
not need to be a subset of the neighbors of a nor of the neighbors of
c. If both conditional dependencies hold and b is not in the
sepset(a,c), the triple is oriented as a v-structure a-&gt;b&lt;-c. On the
other hand, if an additional conditional independence relationship may
be detected, say a is independent from b given the sepset(a,c), the
edge between a and c is removed from the graph and the set responsible
for that is saved in sepset(a,b). The removal of an edge can destroy
or create new unshielded triples in the graph. To solve this problem
we work with lists (for details see Colombo et al., 2012).
</p>
<p>Before orienting discriminating paths, we perform the following additional
conditional independence tests. For each triple a &lt;-* b o- *c with a
-&gt; c,  the algorithm searches for a discriminating path p = &lt;d,
. . . , a,b,c&gt; for b of minimal length, and checks that the vertices
in every consecutive pair (f1,f2) on p are conditionally dependent
given all subsets of 
<code class="reqn">\textrm{sepset}(d,c) \setminus \{f1, f2\}</code>
. If we do not find any
conditional independence relationship, the path is oriented as in rule
(R4). If one or more conditional independence relationships are found,
the corresponding edges are removed, their minimal separating sets are
stored.
</p>
<p>Conservative RFCI can be computed if the argument of <code>conservative</code> is
<code>TRUE</code>. After the final skeleton is computed and the
additional local tests on all unshielded triples, as described above,
have been done, all potential v-structures a-b-c are checked
in the following way. We test whether a and c are independent
conditioning on any subset of the neighbors of a or any subset of the
neighbors of c. When a subset makes a and c conditionally independent,
we call it a separating set. If b is in no such separating set or in
all such separating sets, no further action is taken and the normal
version of the RFCI algorithm is continued. If, however, b is in only
some separating sets, the triple a-b-c is marked 'ambiguous'. If a is
independent of c given some S in the skeleton (i.e., the edge a-c
dropped out), but a and c remain dependent given all subsets of
neighbors of either a or c, we will call all triples a-b-c
'unambiguous'. This is because in the RFCI algorithm, the true
separating set might be outside the neighborhood of either a or c. An
ambiguous triple is not oriented as a v-structure. Furthermore, no further
orientation rule that needs to know whether a-b-c is a v-structure or
not is applied. Instead of using the conservative version, which is
quite strict towards the v-structures, Colombo and Maathuis (2014)
introduced a less strict version for the v-structures called majority
rule. This adaptation can be called using <code>maj.rule = TRUE</code>. In
this case, the triple a-b-c is marked as 'ambiguous' if and only if b
is in exactly 50 percent of such separating sets or no separating set
was found. If b is in less than 50 percent of the separating sets it
is set as a v-structure, and if in more than 50 percent it is set as a
non v-structure (for more details see Colombo and Maathuis,
2014).
</p>
<p>The implementation uses the stabilized skeleton
<code><a href="#topic+skeleton">skeleton</a></code>, which produces an initial order-independent
skeleton. The final skeleton and edge orientations can still be
order-dependent, see Colombo and Maathuis (2014).
</p>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> <code>fciAlgo</code> (see
<code><a href="#topic+fciAlgo-class">fciAlgo</a></code>) containing the estimated graph
(in the form of an adjacency matrix with various possible edge marks),
the conditioning sets that lead to edge removals (sepset) and several other
parameters.
</p>


<h3>Author(s)</h3>

<p>Diego Colombo and Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>).
</p>


<h3>References</h3>

<p>D. Colombo and M.H. Maathuis (2014).Order-independent constraint-based
causal structure learning. <em>Journal of Machine Learning Research</em>
<b>15</b> 3741-3782. 
</p>
<p>D. Colombo, M. H. Maathuis, M. Kalisch, T. S. Richardson (2012).
Learning high-dimensional directed acyclic graphs with latent and
selection variables. <em>Ann. Statist.</em> <b>40</b>, 294-321.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fci">fci</a></code> and <code><a href="#topic+fciPlus">fciPlus</a></code> for estimating a
PAG using the FCI algorithm; 
<code><a href="#topic+skeleton">skeleton</a></code> for estimating an initial skeleton
using the RFCI algorithm; <code><a href="#topic+pc">pc</a></code> for estimating a CPDAG using
the PC algorithm; <code><a href="#topic+gaussCItest">gaussCItest</a></code>,
<code><a href="#topic+disCItest">disCItest</a></code>, <code><a href="#topic+binCItest">binCItest</a></code> and
<code><a href="#topic+dsepTest">dsepTest</a></code> as examples for <code>indepTest</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################################################
## Example without latent variables
##################################################
set.seed(42)
p &lt;- 7
## generate and draw random DAG :
myDAG &lt;- randomDAG(p, prob = 0.4)

## find skeleton and PAG using the RFCI algorithm
suffStat &lt;- list(C = cov2cor(trueCov(myDAG)), n = 10^9)
indepTest &lt;- gaussCItest
res &lt;- rfci(suffStat, indepTest, alpha = 0.9999, p=p, verbose=TRUE)


##################################################%  --------------
## Example with hidden variables
## Zhang (2008), Fig. 6, p.1882
##################################################

## create the DAG :
V &lt;- LETTERS[1:5]
edL &lt;- setNames(vector("list", length = 5), V)
edL[[1]] &lt;- list(edges=c(2,4),weights=c(1,1))
edL[[2]] &lt;- list(edges=3,weights=c(1))
edL[[3]] &lt;- list(edges=5,weights=c(1))
edL[[4]] &lt;- list(edges=5,weights=c(1))
## and leave  edL[[ 5 ]] empty
g &lt;- new("graphNEL", nodes=V, edgeL=edL, edgemode="directed")
if (require(Rgraphviz))
  plot(g)

## define the latent variable
L &lt;- 1

## compute the true covariance matrix of g
cov.mat &lt;- trueCov(g)
## delete rows and columns belonging to latent variable L
true.cov &lt;- cov.mat[-L,-L]
## transform covariance matrix into a correlation matrix
true.corr &lt;- cov2cor(true.cov)

## find PAG with RFCI algorithm
## as dependence "oracle", we use the true correlation matrix in
## gaussCItest() with a large "virtual sample size" and a large alpha :
rfci.pag &lt;- rfci(suffStat = list(C = true.corr, n = 10^9),
                 indepTest = gaussCItest, alpha = 0.9999, labels = V[-L],
                 verbose=TRUE)

## define PAG given in Zhang (2008), Fig. 6, p.1882
corr.pag &lt;- rbind(c(0,1,1,0),
                  c(1,0,0,2),
                  c(1,0,0,2),
                  c(0,3,3,0))
## check that estimated and correct PAG are in agreement:
stopifnot(corr.pag == rfci.pag@amat)
</code></pre>

<hr>
<h2 id='rmvDAG'>Generate Multivariate Data according to a DAG</h2><span id='topic+rmvDAG'></span>

<h3>Description</h3>

<p>Generate multivariate data with dependency structure specified by a
(given) DAG (<b>D</b>irected <b>A</b>cyclic <b>G</b>raph) with nodes
corresponding to random variables.  The DAG has to be
<b>topologically ordered</b>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmvDAG(n, dag,
       errDist = c("normal", "cauchy", "t4", "mix", "mixt3", "mixN100"),
       mix = 0.1, errMat = NULL, back.compatible = FALSE,
       use.node.names = !back.compatible)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmvDAG_+3A_n">n</code></td>
<td>
<p>number of samples that should be drawn. (integer)</p>
</td></tr>
<tr><td><code id="rmvDAG_+3A_dag">dag</code></td>
<td>
<p>a graph object describing the DAG; must contain weights for
all the edges.  The nodes must be topologically sorted. (For
topological sorting use <code><a href="RBGL.html#topic+tsort">tsort</a></code> from the
<span class="pkg">RBGL</span> package.)</p>
</td></tr>
<tr><td><code id="rmvDAG_+3A_errdist">errDist</code></td>
<td>
<p>string specifying the distribution of each node.
Currently, the options &quot;normal&quot;, &quot;t4&quot;, &quot;cauchy&quot;, &quot;mix&quot;, &quot;mixt3&quot; and
&quot;mixN100&quot; are supported.  The first
three generate standard normal-, t(df=4)- and cauchy-random
numbers.  The options containing the word &quot;mix&quot; create standard
normal random variables with a mix of outliers. The outliers for the
options &quot;mix&quot;, &quot;mixt3&quot;, &quot;mixN100&quot; are drawn from a standard cauchy,
t(df=3) and N(0,100) distribution, respectively.  The fraction of
outliers is determined by the <code>mix</code> argument.</p>
</td></tr>
<tr><td><code id="rmvDAG_+3A_mix">mix</code></td>
<td>
<p>for the <code>"mix*"</code> error distributuion, <code>mix</code>
specifies the fraction of &ldquo;outlier&rdquo; samples (i.e., Cauchy, <code class="reqn">t_3</code>
or <code class="reqn">N(0,100)</code>).</p>
</td></tr>
<tr><td><code id="rmvDAG_+3A_errmat">errMat</code></td>
<td>
<p>numeric <code class="reqn">n * p</code> matrix specifiying the error vectors
<code class="reqn">e_i</code> (see Details), instead of specifying <code>errDist</code> (and
maybe <code>mix</code>).</p>
</td></tr>
<tr><td><code id="rmvDAG_+3A_back.compatible">back.compatible</code></td>
<td>
<p>logical indicating if the data generated should
be the same as with <span class="pkg">pcalg</span> version 1.0-6 and earlier (where
<code>wgtMatrix()</code> differed).</p>
</td></tr>
<tr><td><code id="rmvDAG_+3A_use.node.names">use.node.names</code></td>
<td>
<p>logical indicating if the column names of the
result matrix should equal <code>nodes(dag)</code>, very sensibly, but
new, hence the default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each node is visited in the topological order.  For each node <code class="reqn">i</code> we
generate a <code class="reqn">p</code>-dimensional value <code class="reqn">X_i</code> in the following way:
Let <code class="reqn">X_1,\ldots,X_k</code> denote the values of all neighbours of <code class="reqn">i</code>
with lower order.
Let <code class="reqn">w_1,\ldots,w_k</code> be the weights of the corresponding edges.
Furthermore, generate a random vector <code class="reqn">E_i</code> according to the
specified error distribution.  Then, the value of <code class="reqn">X_i</code> is
computed as
</p>
<p style="text-align: center;"><code class="reqn">X_i = w_1*X_1 + \ldots + w_k*X_k + E_i.</code>
</p>

<p>If node <code class="reqn">i</code> has no neighbors with lower order, <code class="reqn">X_i = E_i</code> is set.
</p>


<h3>Value</h3>

<p>A <code class="reqn">n*p</code> matrix with the generated data.  The <code class="reqn">p</code> columns
correspond to the nodes (i.e., random variables) and each of the
<code class="reqn">n</code> rows correspond to a sample.
</p>


<h3>Author(s)</h3>

<p>Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>) and Martin Maechler.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+randomDAG">randomDAG</a></code> for generating a random DAG;
<code><a href="#topic+skeleton">skeleton</a></code> and <code><a href="#topic+pc">pc</a></code> for estimating the
skeleton and the CPDAG of a DAG that
corresponds to the data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate random DAG
p &lt;- 20
rDAG &lt;- randomDAG(p, prob = 0.2, lB=0.1, uB=1)

if (require(Rgraphviz)) {
## plot the DAG
plot(rDAG, main = "randomDAG(20, prob = 0.2, ..)")
}

## generate 1000 samples of DAG using standard normal error distribution
n &lt;- 1000
d.normMat &lt;- rmvDAG(n, rDAG, errDist="normal")

## generate 1000 samples of DAG using standard t(df=4) error distribution
d.t4Mat &lt;- rmvDAG(n, rDAG, errDist="t4")

## generate 1000 samples of DAG using standard normal with a cauchy
## mixture of 30 percent
d.mixMat &lt;- rmvDAG(n, rDAG, errDist="mix",mix=0.3)

require(MASS) ## for mvrnorm()
Sigma &lt;- toeplitz(ARMAacf(0.2, lag.max = p - 1))
dim(Sigma)# p x p
## *Correlated* normal error matrix "e_i" (against model assumption)
eMat &lt;- mvrnorm(n, mu = rep(0, p), Sigma = Sigma)
d.CnormMat &lt;- rmvDAG(n, rDAG, errMat = eMat)
</code></pre>

<hr>
<h2 id='rmvnorm.ivent'>Simulate from a Gaussian Causal Model</h2><span id='topic+rmvnorm.ivent'></span>

<h3>Description</h3>

<p>Produces one or more samples from the observational or an interventional
distribution associated to a Gaussian causal model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmvnorm.ivent(n, object, target = integer(0), target.value = numeric(0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmvnorm.ivent_+3A_n">n</code></td>
<td>
<p>Number of samples required.</p>
</td></tr>
<tr><td><code id="rmvnorm.ivent_+3A_object">object</code></td>
<td>
<p>An instance of <code><a href="#topic+GaussParDAG-class">GaussParDAG</a></code></p>
</td></tr>
<tr><td><code id="rmvnorm.ivent_+3A_target">target</code></td>
<td>
<p>Intervention target: vector of intervened nodes.  If the vector
is empty, samples from the observational distribution are generated.
Otherwise, samples from an interventional distribution are simulated.</p>
</td></tr>
<tr><td><code id="rmvnorm.ivent_+3A_target.value">target.value</code></td>
<td>
<p>Values of the intervened variables.  If 
<code>target.value</code> is a vector of the same length as <code>target</code>, the
indicated intervention levels are used for all <code>n</code> samples.  If
<code>target.value</code> is a matrix of dimension <code>n</code> by 
<code>length(target)</code>, the <code class="reqn">i</code>-th sample is simulated using the
<code class="reqn">i</code>-th row of the matrix as intervention levels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>n = 1</code> a vector of length <code>p</code> is returned, where <code>p</code> 
denotes the number of nodes of <code>object</code>. Otherwise an <code>n</code> by
<code>p</code> matrix is returned with one sample per row.
</p>


<h3>Author(s)</h3>

<p>Alain Hauser (<a href="mailto:alain.hauser@bfh.ch">alain.hauser@bfh.ch</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(307)
myDAG &lt;- r.gauss.pardag(5, 0.5)
var(rmvnorm.ivent(n = 1000, myDAG))
myDAG$cov.mat()
var(rmvnorm.ivent(n = 1000, myDAG, target = 1, target.value = 1))
myDAG$cov.mat(target = 1, ivent.var = 0)
</code></pre>

<hr>
<h2 id='Score-class'>Virtual Class &quot;Score&quot;</h2><span id='topic+Score-class'></span>

<h3>Description</h3>

<p>This virtual base class represents a score for causal inference; it is used
in the causal inference functions <code><a href="#topic+ges">ges</a></code>, <code><a href="#topic+gies">gies</a></code> and
<code><a href="#topic+simy">simy</a></code>. 
</p>


<h3>Details</h3>

<p>Score-based structure learning algorithms for causal inference such as 
Greedy Equivalence Search
(GES, implemented in the function <code><a href="#topic+ges">ges</a></code>), Greedy Interventional
Equivalence Search (GIES, implemented in the function <code><a href="#topic+gies">gies</a></code>) and
the dynamic programming approach of Silander and Myllymäki (2006)
(implemented in the function <code><a href="#topic+simy">simy</a></code>) try to find the DAG model which
maximizes a scoring criterion for a given data set.  A widely-used scoring 
criterion is the Bayesian Information Criterion (BIC).
</p>
<p>The virtual class <code>Score</code> is the base class for providing a scoring
criterion to the mentioned causal inference algorithms.  It does not 
implement a concrete scoring criterion, but it defines the functions that 
must be provided by its descendants (cf. methods).
</p>
<p>Knowledge of this class is only required if you aim to implement an own 
scoring criterion.  At the moment, it is recommended to use the predefined
scoring criteria for multivariate Gaussian data derived from <code>Score</code>, 
<code><a href="#topic+GaussL0penIntScore-class">GaussL0penIntScore</a></code> and
<code><a href="#topic+GaussL0penObsScore-class">GaussL0penObsScore</a></code>. 
</p>


<h3>Fields</h3>

<p>The fields of <code>Score</code> are mainly of interest for users who aim at 
deriving an own class from this virtual base class, i.e., implementing an own
score function.
</p>

<dl>
<dt><code>.nodes</code>:</dt><dd><p>Node labels.  They are passed to causal inference
methods by default to label the nodes of the resulting graph.</p>
</dd>
<dt><code>decomp</code>:</dt><dd><p>Indicates whether the represented score is
decomposable (cf. details).  At the moment, only decomposable scores are 
supported by the implementation of the causal inference algorithms; 
support for non-decomposable scores is planned.</p>
</dd>
<dt><code>pp.dat</code>:</dt><dd><p>List representing the preprocessed input data;
this is typically a statistic which is sufficient for the 
calculation of the score.</p>
</dd>
<dt><code>.pardag.class</code>:</dt><dd><p>Name of the class of the parametric DAG model
corresponding to the score.  This must name a class derived from 
<code>ParDAG</code>.</p>
</dd>
<dt><code>c.fcn</code>:</dt><dd><p>Only used internally; must remain empty for (user
specified) classes derived from <code>Score</code>.</p>
</dd> 
</dl>



<h3>Constructor</h3>

<pre>
new("Score",
  data = matrix(1, 1, 1), 
  targets = list(integer(0)),
  target.index = rep(as.integer(1), nrow(data)), 
  nodes = colnames(data),
  ...)
</pre>

<dl>
<dt><code>data</code></dt><dd><p>Data matrix with <code class="reqn">n</code> rows and <code class="reqn">p</code> columns.  Each 
row corresponds to one realization, either interventional or 
observational.</p>
</dd>
<dt><code>targets</code></dt><dd><p>List of mutually exclusive intervention targets
that have been used for data generation.</p>
</dd>
<dt><code>target.index</code></dt><dd><p>Vector of length <code class="reqn">n</code>; the <code class="reqn">i</code>-th entry 
specifies the index of the intervention
target in <code>targets</code> under which the <code class="reqn">i</code>-th row of <code>data</code>
was measured.</p>
</dd>
<dt><code>nodes</code></dt><dd><p>Node labels</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional parameters used by derived (and non-virtual)
classes.</p>
</dd>
</dl>



<h3>Methods</h3>

<p>Note that since <code>Score</code> is a virtual class, its methods cannot be called
directly, but only on derived classes.
</p>

<dl>
<dt><code>local.score(vertex, parents, ...)</code></dt><dd><p>For decomposable scores,
this function calculates the local score of a vertex and its parents.
Must throw an error in derived classes that do not represent a 
decomposable score.</p>
</dd>
<dt><code>global.score.int(edges, ...)</code></dt><dd><p>Calculates the global score of
a DAG, represented as a list of in-edges: for each vertex in the DAG,
this list contains a vector of parents.</p>
</dd>
<dt><code>global.score(dag, ...)</code></dt><dd><p>Calculates the global score of a DAG,
represented as object of a class derived from <code>ParDAG</code>.</p>
</dd>
<dt><code>local.fit(vertex, parents, ...)</code></dt><dd><p>Calculates a local model fit
of a vertex and its parents, e.g. by MLE. 
The result is a vector of parameters whose 
meaning depends on the model class; it matches the convention used in the
corresponding causal model (cf. <code>.pardag.class</code>).

</p>
</dd>
<dt><code>global.fit(dag, ...)</code></dt><dd><p>Calculates the global MLE of a DAG,
represented by an object of the class specified by <code>.pardag.class</code>.
The result is a list of vectors, one per vertex, each in the same format
as the result vector of <code>local.mle</code>.

</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Alain Hauser (<a href="mailto:alain.hauser@bfh.ch">alain.hauser@bfh.ch</a>)
</p>


<h3>References</h3>

<p>T. Silander and P. Myllymäki (2006).  A simple approach for finding the 
globally optimal Bayesian network structure.  <em>Proceedings of the 22nd 
Conference on Uncertainty in Artificial Intelligence (UAI 2006)</em>, 445&ndash;452
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ges">ges</a></code>, <code><a href="#topic+gies">gies</a></code>, <code><a href="#topic+simy">simy</a></code>, 
<code><a href="#topic+GaussL0penIntScore-class">GaussL0penIntScore</a></code>, 
<code><a href="#topic+GaussL0penObsScore-class">GaussL0penObsScore</a></code>
</p>

<hr>
<h2 id='searchAM'>Search for certain nodes in a DAG/CPDAG/MAG/PAG</h2><span id='topic+searchAM'></span>

<h3>Description</h3>

<p>Searches for all ancestors, descendants, anteriors, spouses, neighbors,
parents, children or possible descendants of a (set of) node(s) 
in a DAG, CPDAG, MAG or PAG.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>searchAM(amat,x,
	 type = c("an", "de", "ant", "sp", "nb", "pa", "ch", "pde"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="searchAM_+3A_amat">amat</code></td>
<td>
<p>Adjacency matrix of type <a href="#topic+amat.pag">amat.pag</a>.</p>
</td></tr>
<tr><td><code id="searchAM_+3A_x">x</code></td>
<td>
<p>Target node(s), given as (a vector of) column number(s) 
of the node(s) in the adjacency matrix.</p>
</td></tr>
<tr><td><code id="searchAM_+3A_type">type</code></td>
<td>
<p>Character string specifying which relation to the
target nodes in <code>x</code> is asked for. It can be one of:
</p>

<dl>
<dt>&quot;an&quot;</dt><dd><p>ancestors: nodes <code>y</code> s.t. <code>y--&gt;...--&gt;x</code>;</p>
</dd>
<dt>&quot;de&quot;</dt><dd><p>descendants: nodes <code>y</code> s.t. <code>y&lt;--...&lt;--x</code>;</p>
</dd>
<dt>&quot;ant&quot;</dt><dd><p>anteriors: nodes <code>y</code> s.t. <code>y---...---z--&gt;...--&gt;x</code>,
i.e. there is an undirected path from <code>y</code> to a node <code>z</code>
followed by a directed path from <code>z</code> to <code>x</code>;</p>
</dd>
<dt>&quot;sp&quot;</dt><dd><p>spouses: nodes <code>y</code> s.t. <code>y&lt;-&gt;x</code>;</p>
</dd>
<dt>&quot;nb&quot;</dt><dd><p>neighbors: nodes <code>y</code> s.t. <code>y---x</code>;</p>
</dd>
<dt>&quot;pa&quot;</dt><dd><p>parents: nodes <code>y</code> s.t. <code>y--&gt;x</code>;</p>
</dd>
<dt>&quot;ch&quot;</dt><dd><p>children: nodes <code>y</code> s.t. <code>y&lt;--x</code>;</p>
</dd>
<dt>&quot;pde&quot;</dt><dd><p>possible descendants: nodes <code>y</code> s.t. there is a possibly
directed path from <code>y</code> to <code>x</code>: <code>y {o,-}--{o,&gt;} ... {o,-}--{o,&gt;} x</code>.</p>
</dd>
</dl>

<p>For the precise definitions of these concepts, see the references.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs a search for nodes related to the set of target nodes <code>x</code> 
in the way specified by <code>type</code> in adjacency matrix <code>amat</code> of type <a href="#topic+amat.pag">amat.pag</a>.
</p>


<h3>Value</h3>

<p>Vector of column numbers of the nodes related to <code>x</code> as specified by <code>type</code>.
</p>


<h3>Author(s)</h3>

<p>Joris Mooij.
</p>


<h3>References</h3>

<p>T.S. Richardson and P. Spirtes (2002). Ancestral graph Markov models.
<em>Annals of Statistics</em> <b>30</b> 962-1030.
</p>
<p>J. Zhang (2008). Causal Reasoning with Ancestral Graphs.
<em>Journal of Machine Learning Research</em> <b>9</b> 1437-1474.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Y-structure MAG
# Encode as adjacency matrix
p &lt;- 10 # total number of variables
V &lt;- c("X1","X2","X3","X4","X5","X6","X7","X8","X9","X10") # variable labels
# amat[i,j] = 0 iff no edge btw i,j
# amat[i,j] = 1 iff i *-o j
# amat[i,j] = 2 iff i *-&gt; j
# amat[i,j] = 3 iff i *-- j
amat &lt;- rbind(c(0,3,0,0,0,0,0,0,0,0),
              c(3,0,3,0,0,0,0,0,0,0),
              c(0,3,0,2,0,0,0,0,0,0),
              c(0,0,3,0,2,0,0,0,0,0),
              c(0,0,0,3,0,2,0,2,2,1),
              c(0,0,0,0,3,0,2,0,0,0),
              c(0,0,0,0,0,3,0,0,0,0),
              c(0,0,0,0,2,0,0,0,0,0),
              c(0,0,0,0,1,0,0,0,0,0),
              c(0,0,0,0,1,0,0,0,0,0))
rownames(amat)&lt;-V
colnames(amat)&lt;-V

stopifnot(all.equal(searchAM(amat,5,type = "an"), c(3,4,5))) # ancestors of X5
stopifnot(all.equal(searchAM(amat,5,type = "de"), c(5,6,7))) # descendants of X5
stopifnot(all.equal(searchAM(amat,5,type = "ant"), c(1,2,3,4,5))) # anteriors of X5
stopifnot(all.equal(searchAM(amat,5,type = "sp"), c(8))) # spouses of X5
stopifnot(all.equal(searchAM(amat,2,type = "nb"), c(1,3))) # neighbors of X2
stopifnot(all.equal(searchAM(amat,c(4,6),type = "pa"), c(3,5))) # parents of {X4,X6}
stopifnot(all.equal(searchAM(amat,c(3,5),type = "ch"), c(4,6))) # children of {X3,X5}
stopifnot(all.equal(searchAM(amat,5,type = "pde"), c(5,6,7,9,10))) # possible descendants of X5
</code></pre>

<hr>
<h2 id='shd'>Compute Structural Hamming Distance (SHD)</h2><span id='topic+shd'></span>

<h3>Description</h3>

<p>Compute the Structural Hamming Distance (SHD) between two graphs.  In
simple terms, this is the number of edge insertions, deletions or
flips in order to transform one graph to another graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shd(g1,g2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shd_+3A_g1">g1</code></td>
<td>
<p>Graph object</p>
</td></tr>
<tr><td><code id="shd_+3A_g2">g2</code></td>
<td>
<p>Graph object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the SHD (numeric).
</p>


<h3>Author(s)</h3>

<p>Markus Kalisch <a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a> and Martin Maechler
</p>


<h3>References</h3>

<p>I. Tsamardinos, L.E. Brown and C.F. Aliferis (2006).
The Max-Min Hill-Climbing Bayesian Network Structure Learning
Algorithm. <em>JMLR</em> <b>65</b>, 31&ndash;78.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate two graphs
g1 &lt;- randomDAG(10, prob = 0.2)
g2 &lt;- randomDAG(10, prob = 0.2)
## compute SHD
(shd.val &lt;- shd(g1,g2))
</code></pre>

<hr>
<h2 id='showAmat'>Show Adjacency Matrix of pcAlgo object</h2><span id='topic+showAmat'></span>

<h3>Description</h3>

<p><b>This function is deprecated - Use <code>as(*, "amat")</code> instead !</b>
</p>
<p>Show the  adjacency matrix of a <code>"pcAlgo"</code> object; this is
intended to be an alternative if the <span class="pkg">Rgraphviz</span> package does not work.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showAmat(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showAmat_+3A_object">object</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object of class <code><a href="#topic+pcAlgo-class">pcAlgo</a></code>, as returned
from <code><a href="#topic+skeleton">skeleton</a>()</code> or <code><a href="#topic+pc">pc</a>()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The adjacency matrix.
</p>


<h3>Note</h3>

<p>For <code>"<a href="#topic+fciAlgo-class">fciAlgo</a>"</code> objects, the show method produces a similar result.
</p>


<h3>Author(s)</h3>

<p>Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+showEdgeList">showEdgeList</a></code> for showing the edge list of a <code><a href="#topic+pcAlgo-class">pcAlgo</a></code> object.
<code><a href="#topic+iplotPC">iplotPC</a></code> for plotting a <code>"pcAlgo"</code> object using the package
<span class="pkg">igraph</span> also for an example of <code>showAmat()</code>.
</p>

<hr>
<h2 id='showEdgeList'>Show Edge List of pcAlgo object</h2><span id='topic+showEdgeList'></span>

<h3>Description</h3>

<p>Show the list of edges (of the graph) of a pcAlgo object; this is
intended to be an alternative if <span class="pkg">Rgraphviz</span> does not work.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showEdgeList(object, labels = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showEdgeList_+3A_object">object</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object of class <code><a href="#topic+pcAlgo-class">pcAlgo</a></code>, as returned
from <code><a href="#topic+skeleton">skeleton</a>()</code> or <code><a href="#topic+pc">pc</a>()</code>.</p>
</td></tr>
<tr><td><code id="showEdgeList_+3A_labels">labels</code></td>
<td>
<p>optional labels for nodes; by default, the labels from
the <code>object</code> are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>none; the purpose is in (the side effect of) printing
the edge list.
</p>


<h3>Note</h3>

<p>This is not quite ok for <code>"<a href="#topic+fciAlgo-class">fciAlgo</a>"</code> objects, yet.
</p>


<h3>Author(s)</h3>

<p>Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>)</p>


<h3>See Also</h3>

<p><code><a href="#topic+showAmat">showAmat</a></code> for the adjacency matrix of a <code><a href="#topic+pcAlgo-class">pcAlgo</a></code> object.
<code><a href="#topic+iplotPC">iplotPC</a></code> for plotting a pcAlgo object using the package
<span class="pkg">igraph</span>, also for an example of <code>showEdgeList()</code>.
</p>

<hr>
<h2 id='simy'>Estimate Interventional Markov Equivalence Class of a DAG</h2><span id='topic+simy'></span>

<h3>Description</h3>

<p>Estimate the interventional essential graph representing the Markov
equivalence class of a DAG using the dynamic programming (DP) approach of
Silander and Myllymäki (2006).  This algorithm maximizes a decomposable
scoring criterion in exponential runtime.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simy(score, labels = score$getNodes(), targets = score$getTargets(),
    verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simy_+3A_score">score</code></td>
<td>
<p>An instance of a class derived from <code><a href="#topic+Score-class">Score</a></code>.</p>
</td></tr>
<tr><td><code id="simy_+3A_labels">labels</code></td>
<td>
<p>Node labels; by default, they are determined from the scoring
object.</p>
</td></tr>
<tr><td><code id="simy_+3A_targets">targets</code></td>
<td>
<p>A list of intervention targets (cf. details).  A list of
vectors, each vector listing the vertices of one intervention target.</p>
</td></tr>
<tr><td><code id="simy_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, detailed output is provided.</p>
</td></tr>
<tr><td><code id="simy_+3A_...">...</code></td>
<td>
<p>Additional arguments for debugging purposes and fine tuning.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function estimates the interventional Markov equivalence class of a DAG
based on a data sample with interventional data originating from various
interventions and possibly observational data. The intervention targets used
for data generation must be specified by the argument <code>targets</code> as a
list of (integer) vectors listing the intervened vertices; observational
data is specified by an empty set, i.e. a vector of the form
<code>integer(0)</code>.  As an example, if data contains observational samples
as well as samples originating from an intervention at vertices 1 and 4,
the intervention targets must be specified as <code>list(integer(0),
  as.integer(1), as.integer(c(1, 4)))</code>.
</p>
<p>An interventional Markov equivalence class of DAGs can be uniquely
represented by a partially directed graph called interventional essential
graph.  Its edges have the following interpretation:
</p>

<ol>
<li><p> a directed edge <code class="reqn">a \longrightarrow b</code> stands for an arrow that has the same
orientation in all representatives of the interventional Markov
equivalence class;
</p>
</li>
<li><p> an undirected edge a &ndash; b stands for an arrow that is oriented in one
way in some representatives of the equivalence class and in the other way
in other representatives of the equivalence class.
</p>
</li></ol>

<p>Note that when plotting the object, undirected and bidirected edges are
equivalent.
</p>
<p>The DP approach of Silander and Myllymäki (2006) is a score-based algorithm
that guarantees to find the optimum of any decomposable scoring criterion.
Its CPU and memory consumption grow exponentially with the number of
variables in the system, irrespective of the sparseness of the true or
estimated DAG.  The implementation in the pcalg package is feasible up to
approximately 20 variables, depending on the user's computer.
</p>


<h3>Value</h3>

<p><code>simy</code> returns a list with the following two components:
</p>
<table>
<tr><td><code>essgraph</code></td>
<td>
<p>An object of class <code><a href="#topic+EssGraph-class">EssGraph</a></code> containing an
estimate of the equivalence class of the underlying DAG.</p>
</td></tr>
<tr><td><code>repr</code></td>
<td>
<p>An object of a class derived from <code><a href="#topic+ParDAG-class">ParDAG</a></code>
containing a (random) representative of the estimated equivalence class.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alain Hauser (<a href="mailto:alain.hauser@bfh.ch">alain.hauser@bfh.ch</a>)
</p>


<h3>References</h3>

<p>T. Silander and P. Myllymäki (2006).  A simple approach for finding the
globally optimal Bayesian network structure.  <em>Proceedings of the 22nd
Conference on Uncertainty in Artificial Intelligence (UAI 2006)</em>, 445&ndash;452
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gies">gies</a></code>, <code><a href="#topic+Score-class">Score</a></code>, <code><a href="#topic+EssGraph-class">EssGraph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################################################
## Using Gaussian Data
##################################################
## Load predefined data
data(gmInt)

## Define the score (BIC)
score &lt;- new("GaussL0penIntScore", gmInt$x, gmInt$targets, gmInt$target.index)

## Estimate the essential graph
simy.fit &lt;- simy(score) 
eDAG &lt;- simy.fit$essgraph
as(eDAG, "graph")

## Look at the graph incidence matrix (a "sparseMatrix"):
if(require(Matrix))
  show( as(as(eDAG, "graphNEL"), "Matrix") )


## Plot the estimated essential graph and the true DAG
if (require(Rgraphviz)) {
  par(mfrow=c(1,2))
  plot(eDAG, main = "Estimated ess. graph")
  plot(gmInt$g, main = "True DAG")
}
</code></pre>

<hr>
<h2 id='skeleton'>Estimate (Initial) Skeleton of a DAG using the PC / PC-Stable Algorithm</h2><span id='topic+skeleton'></span>

<h3>Description</h3>

<p>Estimate the skeleton of a DAG without latent and selection
variables using the PC Algorithm or
estimate an initial skeleton of a DAG with arbitrarily many latent and
selection variables using the FCI and the RFCI algorithms.
</p>
<p>If used in the PC algorithm, it estimates the order-independent
&ldquo;PC-stable&rdquo; (<code>"stable"</code>) or original PC (<code>"original"</code>)
&ldquo;skeleton&rdquo; of a directed acyclic graph (DAG) from observational
data.
</p>
<p>When used in the FCI and RFCI algorithms, this function estimates
only an initial order-independent (or PC original) &ldquo;skeleton&rdquo;.
Because of the presence of latent and selection variables, to find the
final skeleton those algorithms need to perform additional tests later on and
consequently some edges can be further deleted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skeleton(suffStat, indepTest, alpha, labels, p,
         method = c("stable", "original", "stable.fast"), m.max = Inf,
         fixedGaps = NULL, fixedEdges = NULL, NAdelete = TRUE,
         numCores = 1, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skeleton_+3A_suffstat">suffStat</code></td>
<td>
<p>Sufficient statistics: List containing all necessary
elements for the conditional independence decisions in the
function <code>indepTest</code>.</p>
</td></tr>
<tr><td><code id="skeleton_+3A_indeptest">indepTest</code></td>
<td>
<p>Predefined <code><a href="base.html#topic+function">function</a></code> for testing
conditional independence.  The function is internally called as
<code>indepTest(x,y,S,suffStat)</code> and tests conditional independence
of <code>x</code> and <code>y</code> given <code>S</code>.  Here, <code>x</code> and
<code>y</code> are variables, and <code>S</code> is a (possibly empty) vector of
variables (all variables are denoted by their column numbers
in the adjacency matrix). <code>suffStat</code> is a list containing
all relevant elements for the conditional independence decisions.
The return value of <code>indepTest</code> is the p-value of the test for
conditional independence.</p>
</td></tr>
<tr><td><code id="skeleton_+3A_alpha">alpha</code></td>
<td>
<p>significance level (number in <code class="reqn">(0,1)</code> for the
individual conditional independence tests.</p>
</td></tr>
<tr><td><code id="skeleton_+3A_labels">labels</code></td>
<td>
<p>(optional) character vector of variable (or
&ldquo;node&rdquo;) names.  Typically preferred to specifying <code>p</code>.</p>
</td></tr>
<tr><td><code id="skeleton_+3A_p">p</code></td>
<td>
<p>(optional) number of variables (or nodes).  May be specified
if <code>labels</code> are not, in which case <code>labels</code> is set to
<code>1:p</code>.</p>
</td></tr>
<tr><td><code id="skeleton_+3A_method">method</code></td>
<td>
<p>Character string specifying method; the default,
<code>"stable"</code> provides an <em>order-independent</em> skeleton, see
&lsquo;Details&rsquo; below.</p>
</td></tr>
<tr><td><code id="skeleton_+3A_m.max">m.max</code></td>
<td>
<p>Maximal size of the conditioning sets that are considered in the
conditional independence tests.</p>
</td></tr>
<tr><td><code id="skeleton_+3A_fixedgaps">fixedGaps</code></td>
<td>
<p>logical <em>symmetric</em> matrix of dimension p*p.  If entry
<code>[i,j]</code> is true, the edge <code class="reqn">i--j</code> is removed before
starting the algorithm.  Therefore, this edge is guaranteed to be
<em>absent</em> in the resulting graph.</p>
</td></tr>
<tr><td><code id="skeleton_+3A_fixededges">fixedEdges</code></td>
<td>
<p>a logical <em>symmetric</em> matrix of dimension p*p.  If entry
<code>[i,j]</code> is true, the edge <code class="reqn">i--j</code> is never considered
for removal.  Therefore, this edge is guaranteed to be <em>present</em> in
the resulting graph.</p>
</td></tr>
<tr><td><code id="skeleton_+3A_nadelete">NAdelete</code></td>
<td>
<p>logical needed for the case <code>indepTest(*)</code>
returns <code>NA</code>.  If it is true, the corresponding edge is
deleted, otherwise not.</p>
</td></tr>
<tr><td><code id="skeleton_+3A_numcores">numCores</code></td>
<td>
<p>number of processor cores to use for parallel computation.
Only available for <code>method = "stable.fast"</code>.</p>
</td></tr>
<tr><td><code id="skeleton_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, detailed output is provided.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Under the assumption that the distribution of the observed variables
is faithful to a DAG and that there are <b>no</b> latent and selection
variables, this function estimates the skeleton of the DAG.  The
skeleton of a DAG is the undirected graph resulting from removing all
arrowheads from the DAG.  Edges in the skeleton of a DAG have the
following interpretation:
<br />
There is an edge between <code class="reqn">i</code> and <code class="reqn">j</code>, <code class="reqn">i</code> &ndash; <code class="reqn">j</code>,
if and only if variables <code class="reqn">i</code> and <code class="reqn">j</code> are conditionally
dependent given <code class="reqn">S</code> for all possible subsets <code class="reqn">S</code> of the
remaining nodes.
</p>
<p>On the other hand, the distribution of the observed variables
is faithful to a DAG with <b>arbitrarily many</b> latent and selection
variables, <code>skeleton()</code> estimates the initial skeleton of the
DAG.  Edges in this initial skeleton of a DAG have the
following interpretation:
<br />
There is an edge <code class="reqn">i</code> &ndash; <code class="reqn">j</code> if and only if variables <code class="reqn">i</code> and
<code class="reqn">j</code> are conditionally dependent given <code class="reqn">S</code> for all possible
subsets <code class="reqn">S</code> of the neighbours of <code class="reqn">i</code> and the neighbours of
<code class="reqn">j</code>.
</p>
<p>The data are not required to follow a specific distribution,
but one should make sure that the conditional indepedence test used in
<code>indepTest</code> is appropriate for the data.  Pre-programmed versions
of <code>indepTest</code> are available for Gaussian data
(<code><a href="#topic+gaussCItest">gaussCItest</a></code>), discrete data (<code><a href="#topic+disCItest">disCItest</a></code>),
and binary data (see <code><a href="#topic+binCItest">binCItest</a></code>).  Users may also specify
their own <code>indepTest</code> function.
</p>
<p>The PC algorithm (Spirtes, Glymour and Scheines, 2000)
(<code>method = "original"</code>) is known to be order-dependent, in the
sense that the output may depend on the order in which the variables
are given.  Therefore, Colombo and Maathuis (2014) proposed a simple
modification, called &ldquo;PC-stable&rdquo;, which yields
order-independent adjacencies in the skeleton, provided by <code>pc()</code>
with the new default <code>method = "stable"</code>.  This stable variant
of the algorithm is also available with the <code>method = "stable.fast"</code>:
it runs the algorithm of Colombo and Maathuis (2014) faster than
<code>method = "stable"</code> in general, but should be regarded as an
experimental option at the moment.
</p>
<p>The algorithm starts with a complete undirected graph.  In each
step, it visits all pairs <code class="reqn">(i,j)</code> of adjacent nodes in the
current graph, and determines based on conditional independence tests
whether the edge <code class="reqn">i--j</code> should be removed.  In particular, for each step
<code class="reqn">m</code> (<code class="reqn">m=0,1,\dots</code>) of the size of the conditioning sets, the
algorithm at first determines the neighbours <code class="reqn">a(i)</code> of each node
<code class="reqn">i</code> in the graph.  Then, the algorithm visits all pairs <code class="reqn">(i,j)</code>
of adjacent nodes in the current graph, and the edge <code class="reqn">i--j</code> is
kept if and only if the null hypothesis
<br />
<em><code class="reqn">i</code> and <code class="reqn">j</code> are conditionally independent given S</em>
<br />
rejected at significance level <code>alpha</code> for all subsets <code class="reqn">S</code> of size
<code class="reqn">m</code> of <code class="reqn">a(i)</code> and of <code class="reqn">a(j)</code> (as judged by the function
<code>indepTest</code>).  For the <code>"stable"</code> method, the neighborhoods
<code class="reqn">a(i)</code> are kept fixed within each value of <code class="reqn">m</code>, and this
makes the algorithm order-independent.  Method <code>"original"</code>,
the original PC algorithm would update the neighbour list after each
edge change.
</p>
<p>The algorithm stops when <code class="reqn">m</code> is larger than the largest
neighbourhood size of all nodes, or when <code class="reqn">m</code> has reached the limit
<code>m.max</code> which may be set by the user.
</p>
<p>Since the FCI (Spirtes, Glymour and Scheines, 2000) and RFCI (Colombo
et al., 2012) algorithms are built up from the PC algorithm, they are also
order-dependent in the skeleton.  To resolve their order-dependence
issues in the skeleton is more involved, see Colombo and Maathuis
(2014).  However now, with <code>method = "stable"</code>, this function
estimates an initial order-independent skeleton in these algorithms
(for additional details on how to make the final skeleton of FCI fully
order-independent see <code><a href="#topic+fci">fci</a></code> and Colombo and Maathuis (2014)).
</p>
<p>The information in <code>fixedGaps</code> and <code>fixedEdges</code> is used as follows.
The gaps given in <code>fixedGaps</code> are introduced in the very beginning of
the algorithm by removing the corresponding edges from the complete
undirected graph.  Pairs <code class="reqn">(i,j)</code> in <code>fixedEdges</code> are skipped
in all steps of the algorithm, so that these edges remain in the graph.
</p>


<p>Note: Throughout, the algorithm works with the column positions of
the variables in the adjacency matrix, and not with the names of
the variables.
</p>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> <code>"pcAlgo"</code> (see
<code><a href="#topic+pcAlgo-class">pcAlgo</a></code>) containing an estimate of the skeleton of
the underlying DAG, the conditioning sets (<code>sepset</code>) that led to
edge removals and several other parameters.
</p>


<h3>Author(s)</h3>

<p>Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>), Martin Maechler,
Alain Hauser, and Diego Colombo.
</p>


<h3>References</h3>

<p>D. Colombo and M.H. Maathuis (2014).Order-independent constraint-based
causal structure learning. <em>Journal of Machine Learning Research</em>
<b>15</b> 3741-3782. 
</p>
<p>D. Colombo, M. H. Maathuis, M. Kalisch, T. S. Richardson
(2012). Learning high-dimensional directed acyclic graphs with latent
and selection variables. <em>Ann. Statist.</em> <b>40</b>, 294-321.
</p>
<p>M. Kalisch and P. Buehlmann (2007).
<em>Estimating high-dimensional directed acyclic graphs with the
PC-algorithm</em>, JMLR <b>8</b> 613-636.
</p>
<p>P. Spirtes, C. Glymour and R. Scheines (2000).
<em>Causation, Prediction, and Search</em>, 2nd edition, MIT Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pc">pc</a></code> for generating a partially directed graph
using the PC algorithm; <code><a href="#topic+fci">fci</a></code> for generating a partial
ancestral graph using the FCI algorithm; <code><a href="#topic+rfci">rfci</a></code> for
generating a partial ancestral graph using the RFCI algorithm;
<code><a href="#topic+udag2pdag">udag2pdag</a></code> for converting the skeleton to a CPDAG.
</p>
<p>Further, <code><a href="#topic+gaussCItest">gaussCItest</a></code>, <code><a href="#topic+disCItest">disCItest</a></code>,
<code><a href="#topic+binCItest">binCItest</a></code> and <code><a href="#topic+dsepTest">dsepTest</a></code> as examples for
<code>indepTest</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################################################
## Using Gaussian Data
##################################################
## Load predefined data
data(gmG)
n &lt;- nrow    (gmG8$x)
V &lt;- colnames(gmG8$x) # labels aka node names

## estimate Skeleton
skel.fit &lt;- skeleton(suffStat = list(C = cor(gmG8$x), n = n),
                     indepTest = gaussCItest, ## (partial correlations)
                     alpha = 0.01, labels = V, verbose = TRUE)
if (require(Rgraphviz)) {
  ## show estimated Skeleton
  par(mfrow=c(1,2))
  plot(skel.fit, main = "Estimated Skeleton")
  plot(gmG8$g, main = "True DAG")
}

##################################################
## Using d-separation oracle
##################################################

## define sufficient statistics (d-separation oracle)
Ora.stat &lt;- list(g = gmG8$g, jp = RBGL::johnson.all.pairs.sp(gmG8$g))
## estimate Skeleton
fit.Ora &lt;- skeleton(suffStat=Ora.stat, indepTest = dsepTest, labels = V,
                    alpha=0.01) # &lt;- irrelevant as dsepTest returns either 0 or 1

if (require(Rgraphviz)) {
  ## show estimated Skeleton
  plot(fit.Ora, main = "Estimated Skeleton (d-sep oracle)")
  plot(gmG8$g, main = "True DAG")
}
##################################################
## Using discrete data
##################################################
## Load data
data(gmD)
V &lt;- colnames(gmD$x) # labels aka node names

## define sufficient statistics
suffStat &lt;- list(dm = gmD$x, nlev = c(3,2,3,4,2), adaptDF = FALSE)

## estimate Skeleton
skel.fit &lt;- skeleton(suffStat,
                     indepTest = disCItest, ## (G^2 statistics independence test)
                     alpha = 0.01, labels = V, verbose = TRUE)
if (require(Rgraphviz)) {
  ## show estimated Skeleton
  par(mfrow = c(1,2))
  plot(skel.fit, main = "Estimated Skeleton")
  plot(gmD$g, main = "True DAG")
}

##################################################
## Using binary data
##################################################
## Load binary data
data(gmB)
X &lt;- gmB$x

## estimate Skeleton
skel.fm2 &lt;- skeleton(suffStat = list(dm = X, adaptDF = FALSE),
                     indepTest = binCItest, alpha = 0.01,
                     labels = colnames(X), verbose = TRUE)
if (require(Rgraphviz)) {
  ## show estimated Skeleton
  par(mfrow = c(1,2))
  plot(skel.fm2, main = "Binary Data 'gmB': Estimated Skeleton")
  plot(gmB$g, main = "True DAG")
}
</code></pre>

<hr>
<h2 id='trueCov'>
Covariance matrix of a DAG.
</h2><span id='topic+trueCov'></span>

<h3>Description</h3>

<p>Compute the (true) covariance matrix of a generated DAG.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trueCov(dag, back.compatible = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trueCov_+3A_dag">dag</code></td>
<td>
<p>Graph object containing the DAG.</p>
</td></tr>
<tr><td><code id="trueCov_+3A_back.compatible">back.compatible</code></td>
<td>
<p>logical indicating if the data generated should
be the same as with <span class="pkg">pcalg</span> version 1.0-6 and earlier (where
<code>wgtMatrix()</code> differed).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Covariance matrix.
</p>


<h3>Note</h3>

<p>This function can <em>not</em> be used to estimate the covariance matrix
from an estimated DAG or corresponding data.
</p>


<h3>Author(s)</h3>

<p>Markus Kalisch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+randomDAG">randomDAG</a></code> for generating a random DAG
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
g &lt;- randomDAG(n = 5, prob = 0.3) ## generate random DAG
if(require(Rgraphviz)) {
plot(g)
}

## Compute true covariance matrix
trueCov(g)

## For comparison:
## Estimate true covariance matrix after generating data from g
d &lt;- rmvDAG(10000, g)
cov(d)
</code></pre>

<hr>
<h2 id='udag2apag'>Last step of RFCI algorithm: Transform partially oriented graph into RFCI-PAG</h2><span id='topic+udag2apag'></span>

<h3>Description</h3>

<p>This function performs the last step of the RFCI algorithm: It
transforms a partially oriented graph in which
the v-structures have been oriented into an RFCI Partial Ancestral
Graph (PAG) (see Colombo et al (2012)).
</p>
<p>While orienting the edges, this function performs some additional
conditional independence tests in orientation rule 4 to ensure
correctness of the ancestral relationships.  As a result of these
additional tests, some additional edges can be deleted.  The result is
the final adjacency matrix indicating also the edge marks and the
updated sepsets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>udag2apag(apag, suffStat, indepTest, alpha, sepset,
          rules = rep(TRUE, 10), unfVect = NULL, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="udag2apag_+3A_apag">apag</code></td>
<td>
<p>Adjacency matrix of type <a href="#topic+amat.pag">amat.pag</a></p>
</td></tr>
<tr><td><code id="udag2apag_+3A_suffstat">suffStat</code></td>
<td>
<p>Sufficient statistics: A <code><a href="base.html#topic+list">list</a></code> containing
all necessary elements for the conditional independence decisions in the
function <code>indepTest</code>.</p>
</td></tr>
<tr><td><code id="udag2apag_+3A_indeptest">indepTest</code></td>
<td>
<p>Pre-defined function for testing conditional
independence.  The function is internally called as
<code>indepTest(x,y,S,suffStat)</code>, and tests conditional independence
of <code>x</code> and <code>y</code> given <code>S</code>.  Here, <code>x</code> and <code>y</code>
are variables, and <code>S</code> is a (possibly empty) set of variables
(all variables are coded by their column numbers in the adjacency
matrix).  <code>suffStat</code> is a list containing all relevant elements
for the conditional independence decisions.  The return value of
<code>indepTest</code> is the p-value of the test for conditional
independence.</p>
</td></tr>
<tr><td><code id="udag2apag_+3A_alpha">alpha</code></td>
<td>
<p>Significance level for the individual conditional
independence tests.</p>
</td></tr>
<tr><td><code id="udag2apag_+3A_sepset">sepset</code></td>
<td>
<p>List of length p; each element of the list
contains another list of length p.  The element
<code>sepset[[x]][[y]]</code> contains the separation set that made the edge
between <code>x</code> and <code>y</code> drop out. Each separation set is a
vector with (integer) positions of variables in the adjacency
matrix.  This object is thought to be
obtained from a <code>pcAlgo</code>-object.</p>
</td></tr>
<tr><td><code id="udag2apag_+3A_rules">rules</code></td>
<td>
<p>Logical vector of length 10 with <code>TRUE</code> or <code>FALSE</code> for
each rule, where <code>TRUE</code> in position i means that rule i (Ri) will be
applied.  By default, all rules are active.</p>
</td></tr>
<tr><td><code id="udag2apag_+3A_unfvect">unfVect</code></td>
<td>
<p>Vector containing numbers that encode the ambiguous
triples (as returned by <code><a href="#topic+pc.cons.intern">pc.cons.intern</a></code>).  This is
needed in the conservative and in the majority rule versions of RFCI.</p>
</td></tr>
<tr><td><code id="udag2apag_+3A_verbose">verbose</code></td>
<td>
<p>Logical indicating if detailed output is to be given.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The partially oriented graph in which the v-structures have been
oriented is transformed into an RFCI-PAG using adapted rules of Zhang
(2008).  This function is similar to <code><a href="#topic+udag2pag">udag2pag</a></code> used to
orient the skeleton into a PAG in the FCI algorithm.  However, it is
slightly more complicated because we perform additional conditional
independence tests when applying rule 4, to ensure correctness of the
ancestral relationships.  As a result, some additional edges can be
deleted, see Colombo et al. (2012).  Because of these addiitonal
tests, we need to give <code>suffStat</code>, <code>indepTest</code>, and
<code>alpha</code> as inputs. Since edges can be deleted, the input
adjacency matrix <code>apag</code> and the input separating sets
<code>sepset</code> can change in this algorithm.
</p>
<p>If <code>unfVect = NULL</code> (no ambiguous triples), the orientation rules
are applied to each eligible structure until no more edges can be
oriented.  On the other hand, hand, if one uses conservative or
majority rule FCI and ambiguous triples have been found in
<code><a href="#topic+pc.cons.intern">pc.cons.intern</a></code>, <code>unfVect</code> contains the numbers of
all ambiguous triples in the graph.  In this case, the orientation
rules take this information into account.  For example, if a *-&gt; b o-*
c and &lt;a,b,c&gt; is an unambigous unshielded triple and not a
v-structure, then we obtain b -* c (otherwise we would create an
additional v-structure).  On the other hand, if a *-&gt; b o-* c but
&lt;a,b,c&gt; is an ambiguous unshielded triple, then the circle mark at b
is not oriented.
</p>
<p>Note that the algorithm works with columns' position of the adjacency
matrix and not with the names of the variables.
</p>
<p>Note that this function does not resolve possible order-dependence in
the application of the orientation rules, see Colombo and Maathuis (2014).
</p>


<h3>Value</h3>

<table>
<tr><td><code>apag</code></td>
<td>
<p>Final adjacency matrix of type <a href="#topic+amat.pag">amat.pag</a></p>
</td></tr>
<tr><td><code>sepset</code></td>
<td>
<p>Updated list of separating sets</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Diego Colombo and Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>)</p>


<h3>References</h3>

<p>D. Colombo and M.H. Maathuis (2014).Order-independent constraint-based
causal structure learning. <em>Journal of Machine Learning Research</em>
<b>15</b> 3741-3782.
</p>
<p>D. Colombo, M. H. Maathuis, M. Kalisch, T. S. Richardson (2012).
Learning high-dimensional directed acyclic graphs with latent
and selection variables. <em>Ann. Statist.</em> <b>40</b>, 294&ndash;321.
</p>
<p>J. Zhang (2008). On the completeness of orientation rules for causal
discovery in the presence of latent confounders and selection bias.
<em>Artificial Intelligence</em> <b>172</b>, 1873&ndash;1896.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rfci">rfci</a></code>, <code><a href="#topic+udag2pag">udag2pag</a></code>,
<code><a href="#topic+dag2pag">dag2pag</a></code>, <code><a href="#topic+udag2pdag">udag2pdag</a></code>,
<code><a href="#topic+udag2pdagSpecial">udag2pdagSpecial</a></code>, <code><a href="#topic+udag2pdagRelaxed">udag2pdagRelaxed</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##################################################%  --------       -----------
## Example with hidden variables
## Zhang (2008), Fig. 6, p.1882
##################################################

## create the DAG :
amat &lt;- t(matrix(c(0,1,0,0,1, 0,0,1,0,0, 0,0,0,1,0, 0,0,0,0,0, 0,0,0,1,0),5,5))
V &lt;- LETTERS[1:5]
colnames(amat) &lt;- rownames(amat) &lt;- V
edL &lt;- setNames(vector("list",length=5), V) 
edL[[1]] &lt;- list(edges= c(2,4),weights=c(1,1))
edL[[2]] &lt;- list(edges= 3,     weights=c(1))
edL[[3]] &lt;- list(edges= 5,     weights=c(1))
edL[[4]] &lt;- list(edges= 5,     weights=c(1))
## and leave  edL[[ 5 ]] empty
g &lt;- new("graphNEL", nodes=V, edgeL=edL, edgemode="directed")
if (require(Rgraphviz))
  plot(g)

## define the latent variable
L &lt;- 1

## compute the true covariance matrix of g
cov.mat &lt;- trueCov(g)

## delete rows and columns belonging to latent variable L
true.cov &lt;- cov.mat[-L,-L]

## transform covariance matrix into a correlation matrix
true.corr &lt;- cov2cor(true.cov)


n &lt;- 100000
alpha &lt;- 0.01
p &lt;- ncol(true.corr)

if (require("MASS")) {
  ## generate 100000 samples of DAG using standard normal error distribution
  set.seed(289)
  d.mat &lt;- mvrnorm(n, mu = rep(0, p), Sigma = true.cov)

  ## estimate the skeleton of given data
  suffStat &lt;- list(C = cor(d.mat), n = n)
  indepTest &lt;- gaussCItest
  resD &lt;- skeleton(suffStat, indepTest, alpha = alpha, labels=colnames(true.corr))

  ## estimate all ordered unshielded triples
  amat.resD &lt;- as(resD@graph, "matrix")
  print(u.t &lt;- find.unsh.triple(amat.resD)) # four of them

  ## check and orient v-structures
  vstrucs &lt;- rfci.vStruc(suffStat, indepTest, alpha=alpha,
			 sepset = resD@sepset, g.amat = amat.resD,
			 unshTripl= u.t$unshTripl, unshVect = u.t$unshVect,
			 verbose = TRUE)

  ## Estimate the final skeleton and extend it into a PAG
  ## (using all 10 rules, as per default):
  resP &lt;- udag2apag(vstrucs$amat, suffStat, indepTest=indepTest, alpha=alpha,
		    sepset=vstrucs$sepset, verbose = TRUE)
  print(Amat &lt;- resP$graph)
} # only if "MASS" is there

</code></pre>

<hr>
<h2 id='udag2pag'>Last steps of FCI algorithm: Transform Final Skeleton into FCI-PAG</h2><span id='topic+udag2pag'></span>

<h3>Description</h3>

<p>This function performs the last steps of the FCI algorithm, as it
transforms an unoriented final skeleton into a Partial Ancestral
Graph (PAG).  The final skeleton must have been estimated with
<code><a href="#topic+pdsep">pdsep</a>()</code> or <code>fciplus.intern()</code>.
The result is an adjacency matrix indicating also the edge marks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>udag2pag(pag, sepset, rules = rep(TRUE, 10), unfVect = NULL,
  jci = c("0","1","12","123"), contextVars = NULL, verbose = FALSE, 
  orientCollider = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="udag2pag_+3A_pag">pag</code></td>
<td>
<p>Adjacency matrix of type <a href="#topic+amat.pag">amat.pag</a></p>
</td></tr>
<tr><td><code id="udag2pag_+3A_sepset">sepset</code></td>
<td>
<p>List of length p; each element of the list
contains another list of length p. The element
<code>sepset[[x]][[y]]</code> contains the separation set that made the edge
between <code>x</code> and <code>y</code> drop out. Each separation set is a
vector with (integer) positions of variables in the adjacency
matrix. This object is thought to be
obtained from a <code>pcAlgo</code>-object.</p>
</td></tr>
<tr><td><code id="udag2pag_+3A_rules">rules</code></td>
<td>
<p>Array of length 10 containing <code>TRUE</code> or <code>FALSE</code>
for each rule. <code>TRUE</code> in position i means that rule i (Ri) will
be applied.  By default, all rules are used.</p>
</td></tr>
<tr><td><code id="udag2pag_+3A_unfvect">unfVect</code></td>
<td>
<p>Vector containing numbers that encode ambiguous unshielded
triples (as returned by <code><a href="#topic+pc.cons.intern">pc.cons.intern</a></code>).  This is
needed in the conservative and majority rule versions of FCI.</p>
</td></tr>
<tr><td><code id="udag2pag_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, detailed output is provided.</p>
</td></tr>
<tr><td><code id="udag2pag_+3A_orientcollider">orientCollider</code></td>
<td>
<p>if <code>TRUE</code>, colliders are oriented.</p>
</td></tr>
<tr><td><code id="udag2pag_+3A_jci">jci</code></td>
<td>
<p>String specifying the JCI assumptions that are used. It can be one of:
</p>

<dl>
<dt>&quot;0&quot;</dt><dd><p>No JCI assumption is made (default),</p>
</dd>
<dt>&quot;1&quot;</dt><dd><p>JCI assumption 1 (no system variable causes any context variable),</p>
</dd>
<dt>&quot;12&quot;</dt><dd><p>JCI assumptions 1 and 2 (no system variable causes any context variable,
and no system variable is confounded with any context variable),</p>
</dd>
<dt>&quot;123&quot;</dt><dd><p>JCI assumptions 1, 2 and 3 (no system variable causes any context variable,
no system variable is confounded with any context variable, and all context variables are
confounded but are not direct causes of each other).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="udag2pag_+3A_contextvars">contextVars</code></td>
<td>
<p>Subset of variable indices {1,...,p} that will be treated 
as context variables in the JCI extension.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The skeleton is transformed into an FCI-PAG using rules by Zhang (2008).
When using the JCI extension, additional adjacency and orientation rules
incorporate the JCI background knowledge regarding the causal relations 
of the context variables; for details, see Mooij et al. (2020).
</p>
<p>If <code>unfVect = NULL</code> (i.e., one uses standard FCI or one uses
conservative/majority rule FCI but there are no ambiguous triples),
then the orientation rules are applied to each eligible structure
until no more edges can be oriented.  On the other hand, if one uses
conservative or majority rule FCI and ambiguous triples have been
found in <code><a href="#topic+pc.cons.intern">pc.cons.intern</a></code>, <code>unfVect</code> contains the
numbers of all ambiguous triples in the graph.  In this case, the
orientation rules take this information into account.  For example, if
a *-&gt; b o-* c and &lt;a,b,c&gt; is an unambigous unshielded triple and not a
v-structure, then we obtain b -* c (otherwise we would create an
additional v-structure).  On the other hand, if a *-&gt; b o-* c but
&lt;a,b,c&gt; is an ambiguous unshielded triple, then the circle mark at b
is not oriented.
</p>
<p>Note that the algorithm works with columns' position of the adjacency
matrix and not with the names of the variables.
</p>
<p>Note that this function does not resolve possible order-dependence in
the application of the orientation rules, see Colombo and Maathuis (2014).
</p>


<h3>Value</h3>

<p>Adjacency matrix of type <a href="#topic+amat.pag">amat.pag</a>.
</p>


<h3>Author(s)</h3>

<p>Diego Colombo and Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>);
JCI extension by Joris Mooij.</p>


<h3>References</h3>

<p>D. Colombo and M.H. Maathuis (2014).Order-independent constraint-based
causal structure learning. <em>Journal of Machine Learning Research</em>
<b>15</b> 3741-3782. 
</p>
<p>D. Colombo, M. H. Maathuis, M. Kalisch, T. S. Richardson
(2012). Learning high-dimensional directed acyclic graphs with latent
and selection variables. <em>Ann. Statist.</em> <b>40</b>, 294&ndash;321.
</p>
<p>J. M. Mooij, S. Magliacane, T. Claassen (2020).
Joint Causal Inference from Multiple Contexts.
<em>Journal of Machine Learning Research</em> <b>21</b>(99), 1&ndash;108.
</p>
<p>J. Zhang (2008). On the completeness of orientation rules for causal
discovery in the presence of latent confounders and selection bias.
<em>Artificial Intelligence</em> <b>172</b>, 1873&ndash;1896.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fci">fci</a></code>, <code><a href="#topic+fciPlus">fciPlus</a></code>, <code><a href="#topic+udag2apag">udag2apag</a></code>, <code><a href="#topic+dag2pag">dag2pag</a></code>;
further, <code><a href="#topic+udag2pdag">udag2pdag</a></code> (incl. <code>udag2pdagSpecial</code> and
<code>udag2pdagRelaxed</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################################################
## Example with hidden variables
## Zhang (2008), Fig. 6, p.1882
##################################################

## draw a DAG with latent variables
## this example is taken from Zhang (2008), Fig. 6, p.1882 (see references)
amat &lt;- t(matrix(c(0,1,0,0,1, 0,0,1,0,0, 0,0,0,1,0, 0,0,0,0,0, 0,0,0,1,0),5,5))
V &lt;- as.character(1:5)
colnames(amat) &lt;- rownames(amat) &lt;- V
edL &lt;- vector("list",length=5)
names(edL) &lt;- V
edL[[1]] &lt;- list(edges= c(2,4),weights=c(1,1))
edL[[2]] &lt;- list(edges= 3,     weights=c(1))
edL[[3]] &lt;- list(edges= 5,     weights=c(1))
edL[[4]] &lt;- list(edges= 5,     weights=c(1))
g &lt;- new("graphNEL", nodes=V, edgeL=edL,edgemode="directed")

if(require("Rgraphviz"))  plot(g) else print(g)

## define the latent variable
L &lt;- 1

## compute the true covariance matrix of g
cov.mat &lt;- trueCov(g)

## delete rows and columns which belong to L
true.cov &lt;- cov.mat[-L,-L]

## transform it in a correlation matrix
true.corr &lt;- cov2cor(true.cov)

if (require("MASS")) {
  ## generate 100000 samples of DAG using standard normal error distribution
  n &lt;- 100000
  alpha &lt;- 0.01
  set.seed(314)
  d.mat &lt;- mvrnorm(n, mu = rep(0,dim(true.corr)[1]), Sigma = true.cov)

  ## estimate the skeleton of given data
  suffStat &lt;- list(C = cor(d.mat), n = n)
  indepTest &lt;- gaussCItest
  resD &lt;- skeleton(suffStat, indepTest, p=dim(true.corr)[2], alpha = alpha)

  ## estimate v-structures conservatively
  tmp &lt;- pc.cons.intern(resD, suffStat, indepTest, alpha, version.unf = c(1, 1))
  ## tripleList &lt;- tmp$unfTripl
  resD &lt;- tmp$sk

  ## estimate the final skeleton of given data using Possible-D-Sep
  pdsepRes &lt;- pdsep(resD@graph, suffStat, indepTest, p=dim(true.corr)[2],
		    resD@sepset, alpha = alpha, m.max = Inf,
		    pMax = resD@pMax)

  ## extend the skeleton into a PAG using all 10 rules
  resP &lt;- udag2pag(pag = pdsepRes$G, pdsepRes$sepset, rules = rep(TRUE,10),
		   verbose = TRUE)
  colnames(resP) &lt;- rownames(resP) &lt;- as.character(2:5)
  print(resP)

} # only if "MASS" is there

</code></pre>

<hr>
<h2 id='udag2pdag'>Last PC Algorithm Step: Extend Object with Skeleton to Completed PDAG</h2><span id='topic+udag2pdag'></span><span id='topic+udag2pdagRelaxed'></span><span id='topic+udag2pdagSpecial'></span>

<h3>Description</h3>

<p>These functions perform the last step in the PC algorithm:
Transform an object of the class
<code>"<a href="#topic+pcAlgo-class">pcAlgo</a>"</code> containing a skeleton and corresponding
conditional independence information into a completed partially
directed acyclic graph (CPDAG).  The functions first determine the
v-structures, and then apply the three orientation rules as described
in Sprirtes et al (2000) and Meek (1995) to orient as many of the
remaining edges as possible.
</p>
<p>In the oracle version and when all assumptions hold, all three
functions yield the same CPDAG.  In the sample version, however, the
resulting CPDAG may be invalid in the sense that one cannot extend it
a DAG without additional unshielded colliders by orienting the
undirecting edges.  This can for example happen due to errors in the
conditional indepedence tests or violations of the faithfulness
assumption.  The three functions deal with such conflicts in different
ways, as described in Details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>udag2pdag       (gInput, verbose)
udag2pdagRelaxed(gInput, verbose, unfVect=NULL, solve.confl=FALSE,
  orientCollider = TRUE, rules = rep(TRUE, 3))
udag2pdagSpecial(gInput, verbose, n.max=100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="udag2pdag_+3A_ginput">gInput</code></td>
<td>
<p><code>"pcAlgo"</code>-object containing skeleton and
conditional indepedence information.</p>
</td></tr>
<tr><td><code id="udag2pdag_+3A_verbose">verbose</code></td>
<td>
<p>0: No output; 1: Details</p>
</td></tr>
<tr><td><code id="udag2pdag_+3A_unfvect">unfVect</code></td>
<td>
<p>vector containing numbers that encode ambiguous
triples (as returned by <code><a href="#topic+pc.cons.intern">pc.cons.intern</a></code>).  This is
needed in the conservative and majority rule PC algorithms.</p>
</td></tr>
<tr><td><code id="udag2pdag_+3A_solve.confl">solve.confl</code></td>
<td>
<p>if <code>TRUE</code>, the orientation of the v-structures and the
orientation rules work with lists for candidate sets and allow
bi-directed edges to resolve conflicting edge orientations. Note that
therefore the resulting object is order-independent but might not be
a PDAG because bi-directed edges can be present.</p>
</td></tr>
<tr><td><code id="udag2pdag_+3A_n.max">n.max</code></td>
<td>
<p>maximum number of tries for re-orienting doubly visited
edges in <code>udag2pdagSpecial</code>.</p>
</td></tr>
<tr><td><code id="udag2pdag_+3A_orientcollider">orientCollider</code></td>
<td>
<p>if <code>TRUE</code>, collider are oriented.</p>
</td></tr>
<tr><td><code id="udag2pdag_+3A_rules">rules</code></td>
<td>
<p>Array of length 3 containing <code>TRUE</code> or <code>FALSE</code>
for each rule. <code>TRUE</code> in position i means that rule i (Ri) will
be applied.  By default, all rules are used.</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt>for <code><a href="#topic+udag2pdag">udag2pdag</a></code>:</dt><dd>
<p>If there are edges that are part of more than one v-structure
(i.e., the edge b - c in the v-structures a -&gt; b &lt;- c and b -&gt; c
&lt;- d), earlier edge orientations are simply overwritten by later
ones.  Thus, if a -&gt; b &lt;- c is considered first, the edge b - c is
first oriented as b &lt;- c and later overwritten by b -&gt; c.  The
v-structures are considered in lexicographical ordering.
</p>
<p>If the resulting graph is extendable to a DAG without additional
v-structures, then the rules of Meek (1995) and Spirtes et al
(2000) are applied to obtain the corresponding CPDAG.  Otherwise,
the edges are oriented randomly to obtain a DAG that fits on the
skeleton, discarding all information about the v-structures.  The
resulting DAG is then transformed into its CPDAG.  Note that the
output of <code>udag2pdag</code> is random whenever the initial graph
was not extendable. 
</p>
<p>Although the output of <code><a href="#topic+udag2pdag">udag2pdag</a></code> is always
extendable, it is not necessarily a valid CPDAG in the sense that
it describes a Markov equivalence class of DAGs.  For example, two
v-structures a -&gt; b &lt;- c and b -&gt; c &lt;- d (considered in this
order) would yield the output a -&gt; b -&gt; c &lt;- d.  This is
extendable to a DAG (it already <em>is</em> a DAG), but it does not
describe a Markov equivalence class of DAGs, since the DAG a &lt;- b
-&gt; c &lt;- d describes the same conditional independencies.
</p>
</dd>
<dt>for <code><a href="#topic+udag2pdagSpecial">udag2pdagSpecial</a></code>:</dt><dd>
<p>If the graph after orienting the v-structures as in
<code>udag2pdag</code> is extendable to a DAG without additional
v-structures, then the rules of Meek (1995) and Spirtes et al
(2000) are applied to obtain the corresponding CPDAG.  Otherwise,
the algorithm tries at most <code>n.max</code> different random
orderings of the v-structures (hence overwriting orientations in
different orders), until it finds one that yields an extendable
CPDAG.  If this fails, the edges are oriented randomly to obtain a
DAG that fits on the skeleton, discarding all information about
the v-structures.  The resulting DAG is then transformed into its
CPDAG.  Note that the output of <code>udag2pdagSpecial</code> is random
whenever the initial graph was not extendable.
</p>
<p>Although the output of <code><a href="#topic+udag2pdag">udag2pdag</a></code> is always
extendable, it is not necessarily a valid CPDAG in the sense that
it describes a Markov equivalence class of DAGs.  For example, two
v-structures a -&gt; b &lt;- c and b -&gt; c &lt;- d (considered in this
order) would yield the output a -&gt; b -&gt; c &lt;- d.  This is
extendable to a DAG (it already IS a DAG), but it does not
describe a Markov equivalence class of DAGs, since the DAG a &lt;- b
-&gt; c &lt;- d describes the same conditional independencies.
</p>
</dd>
<dt>for <code><a href="#topic+udag2pdagRelaxed">udag2pdagRelaxed</a></code>:</dt><dd>
<p>This is the default version in the PC/RFCI/FCI algorithm.  It does
<b>not</b> test whether the output is extendable to a DAG without
additional v-structures.
</p>
<p>If <code>unfVect = NULL</code> (no ambiguous triples), the three
orientation rules are applied to each eligible structure until no
more edges can be oriented.  Otherwise, <code>unfVect</code> contains
the numbers of all ambiguous triples in the graph as determined by
<code><a href="#topic+pc.cons.intern">pc.cons.intern</a></code>.  Then the orientation rules take
this information into account.  For example, if a -&gt; b - c and
&lt;a,b,c&gt; is an unambigous triple and a non-v-structure, then rule 1
implies b -&gt; c.  On the other hand, if a -&gt; b - c but &lt;a,b,c&gt; is
an ambiguous triple, then the edge b - c is not oriented.
</p>
<p>If <code>solve.confl = FALSE</code>, earlier edge orientations are
overwritten by later ones as in <code>udag2pdag</code> and
<code>udag2pdagSpecial</code>.
</p>
<p>If <code>solv.confl = TRUE</code>, both the v-structures and the
orientation rules work with lists for the candidate edges and
allow bi-directed edges if there are conflicting orientations. For
example, two v-structures a -&gt; b &lt;- c and b -&gt; c &lt;- d then yield a
-&gt; b &lt;-&gt; c &lt;-d.  This option can be used to get an
order-independent version of the PC algorithm (see Colombo and
Maathuis (2014)).
</p>
<p>We denote bi-directed edges, for example between two variables i
and j, in the adjacency matrix M of the graph as M[i,j]=2 and
M[j,i]=2.  Such edges should be interpreted as indications of
conflicts in the algorithm, for example due to errors in the
conditional independence tests or violations of the faithfulness
assumption.
</p>
</dd>
</dl>



<h3>Value</h3>


<dl>
<dt>for <code>udag2pdag()</code> and <code>udag2pdagRelaxed()</code>:</dt><dd>
<p>oriented <code>"pcAlgo"</code>-object.</p>
</dd>
<dt>for <code>udag2pdagSpecial</code>:</dt><dd><p>a <code><a href="base.html#topic+list">list</a></code> with
components </p>

<dl>
<dt>pcObj</dt><dd><p>An oriented <code>"pcAlgo"</code>-object.</p>
</dd>
<dt>evisit</dt><dd><p>Matrix counting the number of orientation attempts per edge</p>
</dd>

<dt>xtbl.orig</dt><dd><p>Logical indicating whether the original graph
with v-structures is extendable.</p>
</dd>
<dt>xtbl</dt><dd><p>Logical indicating whether the final graph with
v-structures is extendable</p>
</dd>
<dt>amat0</dt><dd><p>Adjacency matrix of original graph with
v-structures (type <a href="#topic+amat.cpdag">amat.cpdag</a>) .</p>
</dd>
<dt>amat1</dt><dd><p>Adjacency matrix of final graph with v-structures
after changing the ordering in which the v-structures are
considered (type <a href="#topic+amat.cpdag">amat.cpdag</a>) .</p>
</dd>
<dt>status</dt><dd><p>Integer code with values </p>

<dl>
<dt>0:</dt><dd><p>Original try is extendable;</p>
</dd>
<dt>1:</dt><dd><p>Reorienting double edge visits helps;</p>
</dd>
<dt>2:</dt><dd><p>Original try is not extendable; reorienting double
visits does not help; result is acyclic, has original
v-structures, but perhaps additional v-structures.</p>
</dd>
</dl>

</dd>
<dt>counter</dt><dd><p>Number of orderings of the v-structures until
success or <code>n.max</code>.</p>
</dd>
</dl>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Markus Kalisch (<a href="mailto:kalisch@stat.math.ethz.ch">kalisch@stat.math.ethz.ch</a>)</p>


<h3>References</h3>

<p>C. Meek (1995). Causal inference and causal explanation with
background knowledge. In <em>Proceedings of the Eleventh Conference
on Uncertainty in Artificial Intelligence (UAI-95)</em>,
pp. 403-411. Morgan Kaufmann Publishers, Inc.
</p>
<p>P. Spirtes, C. Glymour and R. Scheines (2000)
<em>Causation, Prediction, and Search</em>, 2nd edition, The MIT Press.
</p>
<p>J. Pearl (2000), <em>Causality</em>, Cambridge University Press.
</p>
<p>D. Colombo and M.H. Maathuis (2014).Order-independent constraint-based
causal structure learning. <em>Journal of Machine Learning Research</em>
<b>15</b> 3741-3782. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pc">pc</a></code>, <code><a href="#topic+pdag2dag">pdag2dag</a></code>,
<code><a href="#topic+dag2cpdag">dag2cpdag</a></code>, <code><a href="#topic+udag2pag">udag2pag</a></code>,
<code><a href="#topic+udag2apag">udag2apag</a></code>, <code><a href="#topic+dag2pag">dag2pag</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simulate data
set.seed(123)
p &lt;- 10
myDAG &lt;- randomDAG(p, prob = 0.2)
trueCPDAG &lt;- dag2cpdag(myDAG)
n &lt;- 1000
d.mat &lt;- rmvDAG(n, myDAG, errDist = "normal")

## estimate skeleton
resU &lt;- skeleton(suffStat = list(C = cor(d.mat), n = n),
                 indepTest = gaussCItest, ## (partial correlations)
                 alpha = 0.05, p=p)

## orient edges using three different methods
resD1 &lt;- udag2pdagRelaxed(resU, verbose=0)
resD2 &lt;- udag2pdagSpecial(resU, verbose=0, n.max=100)
resD3 &lt;- udag2pdag       (resU, verbose=0)

</code></pre>

<hr>
<h2 id='visibleEdge'>
Check visible edge.
</h2><span id='topic+visibleEdge'></span>

<h3>Description</h3>

<p>Check if the directed edge from x to z in a MAG or in a PAG is visible or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>visibleEdge(amat, x, z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="visibleEdge_+3A_amat">amat</code></td>
<td>
<p>Adjacency matrix of type <a href="#topic+amat.pag">amat.pag</a></p>
</td></tr>
<tr><td><code id="visibleEdge_+3A_x">x</code>, <code id="visibleEdge_+3A_z">z</code></td>
<td>
<p>(integer) position of variable <code class="reqn">x</code> and <code class="reqn">z</code>,
respectively, in the adjacency matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All directed edges in DAGs and CPDAGs are said to be visible. Given a
MAG M / PAG P, a directed edge A -&gt; B in M / P is visible if there is a
vertex C not adjacent to B, such that there is an edge between C and A
that is into A, or there is a collider path between C and A that is into
A and every non-endpoint vertex on the path is a parent of B. Otherwise
A -&gt; B is said to be invisible. (see Maathuis and Colombo (2015), Def. 3.1)
</p>


<h3>Value</h3>

<p><code>TRUE</code> if edge is visible, otherwise <code>FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>Diego Colombo
</p>


<h3>References</h3>

<p>M.H. Maathuis and D. Colombo (2015). A generalized backdoor
criterion. Annals of Statistics 43 1060-1088.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+backdoor">backdoor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>amat &lt;- matrix(c(0,3,0,0, 2,0,2,3, 0,2,0,3, 0,2,2,0), 4,4)
colnames(amat) &lt;- rownames(amat) &lt;- letters[1:4]
if(require(Rgraphviz)) {
plotAG(amat)
}

visibleEdge(amat, 3, 4) ## visible
visibleEdge(amat, 2, 4) ## visible
visibleEdge(amat, 1, 2) ## invisible
</code></pre>

<hr>
<h2 id='wgtMatrix'>Weight Matrix of a Graph, e.g., a simulated DAG</h2><span id='topic+wgtMatrix'></span>

<h3>Description</h3>

<p>Given a <code><a href="graph.html#topic+graph-class">graph</a></code> object <code>g</code>, as
generated e.g., by <code><a href="#topic+randomDAG">randomDAG</a></code>, return the matrix of its
edge weights, the &ldquo;weight matrix&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wgtMatrix(g, transpose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wgtMatrix_+3A_g">g</code></td>
<td>
<p><code><a href="graph.html#topic+graph-class">graph</a></code> object (package
<span class="pkg">graph</span>) of, say, <code class="reqn">p</code> nodes, e.g. containing a DAG.</p>
</td></tr>
<tr><td><code id="wgtMatrix_+3A_transpose">transpose</code></td>
<td>
<p>logical indicating if the weight matrix should be
transposed (<code><a href="base.html#topic+t">t</a>(.)</code>, see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When generating a DAG (e.g. using <code><a href="#topic+randomDAG">randomDAG</a></code>), a graph
object is usually generated and edge weights are usually specified.
This function extracts the edge weights and arranges them in a matrix
<code class="reqn">M</code>.
</p>
<p>If <code>transpose</code> is <code>TRUE</code> (default), <code>M[i,j]</code> is the
weight of the edge from j to i. If <code>transpose</code> is false, M[i,j]
is the weight of the edge from i to j.
</p>
<p>Nowadays, this is a trivial wrapper around <code>as(g, "matrix")</code>
using the (<code><a href="methods.html#topic+coerce">coerce</a></code>) method provided by the <span class="pkg">graph</span>
package.
</p>


<h3>Value</h3>

<p>The <code class="reqn">p \times p</code> weight matrix <code>M</code>.
</p>


<h3>Note</h3>

<p>This function can <em>not</em> be used to estimate the edge weights in
an estimated DAG / CPDAG.
</p>


<h3>Author(s)</h3>

<p>Markus Kalisch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+randomDAG">randomDAG</a></code> for generating a random DAG;
<code><a href="#topic+rmvDAG">rmvDAG</a></code> for simulating data from a generated DAG.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
g &lt;- randomDAG(n = 5, prob = 0.3) ## generate random DAG
if(require(Rgraphviz)) {
  plot(g)
}

## edge weights as matrix
wgtMatrix(g)

## for comparison: edge weights in graph object
g@edgeData@data
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
