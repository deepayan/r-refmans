<!DOCTYPE html><html><head><title>Help for package imageData</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {imageData}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#imageData-package'>
<p>Aids in Processing and Plotting Data from a Lemna-Tec Scananalyzer</p></a></li>
<li><a href='#anom'><p>Tests if any values in a vector are anomalous in being outside specified limits</p></a></li>
<li><a href='#anomPlot'><p>Identifies anomalous individuals and produces longitudinal plots without them and with just them</p></a></li>
<li><a href='#calcLagged'><p>Replaces the values in a vector with the result of applying an operation to it</p>
and a lagged value</a></li>
<li><a href='#calcTimes'><p>Calculates for a set of times, the time intervals after an origin time and the position of each with in that time</p></a></li>
<li><a href='#corrPlot'><p>Calculates and plots correlation matrices for a set of responses</p></a></li>
<li><a href='#cumulate'><p>Calculates the cumulative sum, ignoring the first element if exclude.1st is TRUE</p></a></li>
<li><a href='#designFactors'><p>Adds the factors and covariates for a blocked, split-plot design</p></a></li>
<li><a href='#exampleData'><p>A small data set to use in function examples</p></a></li>
<li><a href='#fitSpline'><p>Produce the fits from a natural cubic smoothing spline applied to a response in a <code>data.frame</code></p></a></li>
<li><a href='#getDates'><p>Forms a subset of <code>responses</code> in <code>data</code> that contains their values for the nominated times</p></a></li>
<li><a href='#GrowthRates'><p>Calculates growth rates (AGR, PGR, RGRdiff) between pairs of values in a vector</p></a></li>
<li><a href='#imagetimesPlot'><p>Plots the position of a time within an interval against the interval for each cart</p></a></li>
<li><a href='#importExcel'><p>Imports an Excel imaging file and allows some renaming of variables</p></a></li>
<li><a href='#intervalGRaverage'><p>Calculates the growth rates for a specified time interval by taking weighted averages of growth rates for times within the interval</p></a></li>
<li><a href='#intervalGRdiff'><p>Calculates the growth rates for a specified time interval</p></a></li>
<li><a href='#intervalPVA'><p>Selects a subset of variables observed within a specified time interval using Principal Variable Analysis (PVA)</p></a></li>
<li><a href='#intervalValueCalculate'><p>Calculates a single value that is a function of an individual's values for a response over a specified time interval</p></a></li>
<li><a href='#intervalWUI'><p>Calculates water use indices (WUI) over a specified time interval to a</p>
data.frame</a></li>
<li><a href='#longiPlot'><p>Plots longitudinal data from a Lemna Tec Scananalyzer</p></a></li>
<li><a href='#longitudinalPrime'><p>Selects a set variables to be retained in a data frame of longitudinal data</p></a></li>
<li><a href='#probeDF'><p>Compares, for a set of specified values of df, a response and the smooths of it, possibly along with growth rates calculated from the smooths</p></a></li>
<li><a href='#PVA'><p>Selects a subset of variables using Principal Variable Analysis (PVA)</p></a></li>
<li><a href='#rcontrib'><p>Computes a measure of how correlated each variable in a set is with the other variable,</p>
conditional on a nominated subset of them</a></li>
<li><a href='#RiceRaw.dat'><p>Data for an experiment to investigate a rice germplasm panel</p></a></li>
<li><a href='#splitContGRdiff'><p>Adds the growth rates calculated continuously over time for subsets</p>
of a response to a <code>data.frame</code></a></li>
<li><a href='#splitSplines'><p>Adds the fits after fitting a natural cubic smoothing spline to subsets</p>
of a response to a <code>data.frame</code></a></li>
<li><a href='#splitValueCalculate'><p>Calculates a single value that is a function of an individual's values for a response</p></a></li>
<li><a href='#twoLevelOpcreate'><p>Creates a data.frame formed by applying, for each response, a binary operation</p>
to the paired values of two different treatments</a></li>
<li><a href='#WUI'><p>Calculates the Water Use Index (WUI)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.1-62</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-21</td>
</tr>
<tr>
<td>Title:</td>
<td>Aids in Processing and Plotting Data from a Lemna-Tec
Scananalyzer</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dae, ggplot2, stats, readxl, Hmisc, GGally, RColorBrewer,
reshape, grid</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, R.rsp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>Description:</td>
<td>Note that 'imageData' has been superseded by 'growthPheno'. 
    The package 'growthPheno' incorporates all the functionality of 
    'imageData' and has functionality not available in 'imageData', 
    but some 'imageData' functions have been renamed.  
    The 'imageData' package is no longer maintained, but is retained 
    for legacy purposes. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://chris.brien.name">http://chris.brien.name</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-20 16:53:33 UTC; briencj</td>
</tr>
<tr>
<td>Author:</td>
<td>Chris Brien <a href="https://orcid.org/0000-0003-0581-1817"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Chris Brien &lt;chris.brien@adelaide.edu.au&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-22 12:10:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='imageData-package'>
Aids in Processing and Plotting Data from a Lemna-Tec Scananalyzer
</h2><span id='topic+imageData-package'></span><span id='topic+imageData'></span>

<h3>Description</h3>

<p>Note that 'imageData' has been superseded by 'growthPheno'. 
    The package 'growthPheno' incorporates all the functionality of 
    'imageData' and has functionality not available in 'imageData', 
    but some 'imageData' functions have been renamed.  
    The 'imageData' package is no longer maintained, but is retained 
    for legacy purposes. 
</p>
<p><b>Version:</b> 0.1-62
</p>
<p><b>Date:</b> 2023-08-21
</p>


<h3>Index</h3>

<p>For an overview of the use of these functions and an example see below.
</p>

<table>
<tr>
 <td style="text-align: left;">
(i) Data</td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

<code><a href="#topic+RiceRaw.dat">RiceRaw.dat</a></code> 
  </td><td style="text-align: left;"> Data for an experiment to investigate a rice </td>
</tr>
<tr>
 <td style="text-align: left;">
       germplasm panel.</td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

(ii) Data frame manipulation</td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

<code><a href="#topic+designFactors">designFactors</a></code> 
  </td><td style="text-align: left;"> Adds the factors and covariates for a blocked,</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> split-plot design.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+getDates">getDates</a></code> 
  </td><td style="text-align: left;"> Forms a subset of 'responses' in 'data' that</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> contains their values for the nominated times.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+importExcel">importExcel</a></code> 
  </td><td style="text-align: left;"> Imports an Excel imaging file and allows some</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> renaming of variables.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+longitudinalPrime">longitudinalPrime</a></code> 
  </td><td style="text-align: left;"> Selects a set variables to be retained in a</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> data frame of longitudinal data.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+twoLevelOpcreate">twoLevelOpcreate</a></code> 
  </td><td style="text-align: left;"> Creates a data.frame formed by applying, for</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> each response, abinary operation to the values of </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> two different treatments.</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>
<tr>
 <td style="text-align: left;">
(iii) Plots</td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

<code><a href="#topic+anomPlot">anomPlot</a></code> 
  </td><td style="text-align: left;"> Identifies anomalous individuals and produces</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> longitudinal plots without them and with just them.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+corrPlot">corrPlot</a></code> 
  </td><td style="text-align: left;"> Calculates and plots correlation matrices for a</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> set of responses.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+imagetimesPlot">imagetimesPlot</a></code> 
  </td><td style="text-align: left;"> Plots the time within an interval versus the interval.</td>
</tr>
<tr>
 <td style="text-align: left;"> 
  </td><td style="text-align: left;"> For example, the hour of the day carts are imaged</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> against the days after planting (or some other</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> number of days after an event).</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+longiPlot">longiPlot</a></code> 
  </td><td style="text-align: left;"> Plots longitudinal data from a Lemna Tec </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> Scananalyzer.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+probeDF">probeDF</a></code> 
  </td><td style="text-align: left;"> Compares, for a set of specified values of df,</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> a response and the smooths of it, possibly along</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;">  with growth rates calculated from the smooths.</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>
<tr>
 <td style="text-align: left;">
(iv) Calculations value-by-value</td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

<code><a href="#topic+GrowthRates">GrowthRates</a></code> 
  </td><td style="text-align: left;"> Calculates growth rates (AGR, PGR, RGRdiff) </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> between pairs of values in a vector.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+WUI">WUI</a></code> 
  </td><td style="text-align: left;"> Calculates the Water Use Index (WUI).</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+anom">anom</a></code> 
  </td><td style="text-align: left;"> Tests if any values in a vector are anomalous</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> in being outside specified limits.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+calcTimes">calcTimes</a></code> 
  </td><td style="text-align: left;"> Calculates for a set of times, the time intervals </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> after an origin time and the position of each with </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> in that time.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+calcLagged">calcLagged</a></code> 
  </td><td style="text-align: left;"> Replaces the values in a vector with the result</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> of applying an operation to it and a lagged value.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+cumulate">cumulate</a></code> 
  </td><td style="text-align: left;"> Calculates the cumulative sum, ignoring the</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> first element if exclude.1st is TRUE.</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>
<tr>
 <td style="text-align: left;">
(v) Calculations over multiple values</td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

<code><a href="#topic+fitSpline">fitSpline</a></code> 
  </td><td style="text-align: left;"> Produce the fits from a natural cubic smoothing</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> spline applied to a response in a 'data.frame'.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+intervalGRaverage">intervalGRaverage</a></code> 
  </td><td style="text-align: left;"> Calculates the growth rates for a specified</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> time interval by taking weighted averages of</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> growth rates for times within the interval.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+intervalGRdiff">intervalGRdiff</a></code> 
  </td><td style="text-align: left;"> Calculates the growth rates for a specified</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> time interval.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+intervalValueCalculate">intervalValueCalculate</a></code>
  </td><td style="text-align: left;"> Calculates a single value that is a function of</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> an individual's values for a response over a</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> specified time interval.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+intervalWUI">intervalWUI</a></code> 
  </td><td style="text-align: left;"> Calculates water use indices (WUI) over a</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> specified time interval to a data.frame.</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>
<tr>
 <td style="text-align: left;">
(vi) Caclulations in each split of a 'data.frame' </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+splitContGRdiff">splitContGRdiff</a></code> 
  </td><td style="text-align: left;"> Adds the growth rates calculated continuously</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> over time for subsets of a response to a</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> 'data.frame'.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+splitSplines">splitSplines</a></code> 
  </td><td style="text-align: left;"> Adds the fits after fitting a natural cubic</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> smoothing spline to subsets of a response to a</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> 'data.frame'.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+splitValueCalculate">splitValueCalculate</a></code>   
  </td><td style="text-align: left;"> Calculates a single value that is a function of</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> an individual's values for a response.</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>
<tr>
 <td style="text-align: left;">
(vii) Principal variates analysis (PV A)</td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">

<code><a href="#topic+intervalPVA">intervalPVA</a></code> 
  </td><td style="text-align: left;"> Selects a subset of variables observed within a</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> specified time interval using PVA.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+PVA">PVA</a></code> 
  </td><td style="text-align: left;"> Selects a subset of variables using PVA.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+rcontrib">rcontrib</a></code> 
  </td><td style="text-align: left;"> Computes a measure of how correlated each</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> variable in a set is with the other variable,</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> conditional on a nominated subset of them.</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<h3>Overview</h3>

<p>This package can be used to carry out a full seven-step process to produce phenotypic traits from measurements made in a high-throughput phenotyping facility, such as one based on a Lemna-Tec Scananalyzer 3D system and described by Al-Tamimi et al. (2016). Otherwise, individual functions can be used to carry out parts of the process.
</p>
<p>The basic data consists of imaging data obtained from a set of pots or carts over time. The carts are arranged in a grid of Lanes <code class="reqn">\times</code> Positions. There should be a unique identifier for each cart, which by default is <code>Snapshot.ID.Tag</code>, and variable giving the Days after Planting for each measurement, by default <code>Time.after.Planting..d.</code>. In some cases, it is expected that  there will be a column labelled <code>Snapshot.Time.Stamp</code>, which reflects the time of the imaging from which a particular data value was obtained.
</p>
<p>The full seven-step process is as follows:
</p>

<ol>
<li><p> Use <code><a href="#topic+importExcel">importExcel</a></code> to import the raw data from the Excel file. This step should also involve any editing of the data needed to take account of mishaps during the data collection and the need to remove faulty data (produces <code>raw.dat</code>). Generally, data can be removed by replacing only values for responses with  missing values (<code>NA</code>) for carts whose data is to be removed, leaving the identifying information intact.
</p>
</li>
<li><p> Use <code><a href="#topic+longitudinalPrime">longitudinalPrime</a></code> to select a subset of the imaging variables produced by the Lemna Tec Scanalyzer and, if the design is a blocked, split-plot design, use <code>designFactors</code> to add covariates and factors that might be used in the analysis (produces the data frame <code>longi.prime.dat</code>).
</p>
</li>
<li><p> Add derived traits that result in a value for each observation: use <code><a href="#topic+splitContGRdiff">splitContGRdiff</a></code> to obtain continuous growth rates i.e. a growth rate for each time of observation, except the first; <code><a href="#topic+WUI">WUI</a></code> to produce continuous Water Use Efficiency Indices (WUE) and <code>cumulate</code> to produce cumulative responses. (Produces the data frame <code>longi.dat</code>.)
</p>
</li>
<li><p> Use <code><a href="#topic+splitSplines">splitSplines</a></code> to fit splines to smooth the longitudinal trends in the primary traits and calculate continuous growth rates from the smoothed response (added to the data frame <code>longi.dat</code>). There are two options for calculating continuous smoothed growth rates: (i) by differencing &mdash; use  <code><a href="#topic+splitContGRdiff">splitContGRdiff</a></code>; (ii) from the first derivatives of the splines &mdash; in <code><a href="#topic+splitSplines">splitSplines</a></code> include <code>1</code> in the <code>deriv</code> argument, include <code>"AGR"</code> in <code>suffices.deriv</code> and set the <code>RGR</code> to say <code>"RGR"</code>. Optionally, use <code><a href="#topic+probeDF">probeDF</a></code> to compare the smooths for a number of values of <code>df</code> and, if necessary, re-run <code><a href="#topic+splitSplines">splitSplines</a></code> with a revised value of <code>df</code>.
</p>
</li>
<li><p> Perform an exploratory examination of the unsmoothed data by using <code>longiPlot</code> to produce longitudinal plots of unsmoothed imaging traits and continuous growth rates. Also, use <code><a href="#topic+longiPlot">longiPlot</a></code> to plot the smoothed imaging traits and continuous growth rates and <code><a href="#topic+anomPlot">anomPlot</a></code> to check for anomalies in the data.
</p>
</li>
<li><p> Produce cart data: traits for which there is a single value for each <code>Snapshot.ID.Tag</code> or cart. (produces the data frame <code>cart.dat</code>)
</p>

<ol>
<li><p> Set up a cart data.frame with the factors and covariates for a single observation from all carts. This can be done by subsetting <code>longi.dat</code> so that there is one entry for each cart.
</p>
</li>
<li><p> Use <code><a href="#topic+getDates">getDates</a></code> to add traits at specific times to the cart <code>data.frame</code>, often the first and last day of imaging for each <code>Snapshot.ID.Tag</code>. The times need to be selected so that there is one and only one observation for each cart. Also form traits, such as growth rates over the whole imaging period, based on these values
</p>
</li>
<li><p> Based on the longitudinal plots, decide on the intervals for  which growth rates and WUEs are to be calculated. The growth rates for intervals are calculated from the continuous growth rates, using <code><a href="#topic+intervalGRdiff">intervalGRdiff</a></code>, if the continuous growth rates were calculated by differencing, or <code><a href="#topic+intervalGRaverage">intervalGRaverage</a></code>, if they were calculated from first derivatives. To calculate WUEs for intervals, use <code><a href="#topic+intervalWUI">intervalWUI</a></code>, The interval growth rates and WUEs are added to the cart <code>data.frame</code>.
</p>
</li></ol>

</li>
<li><p> (Optional) There is also the possibility that, for experiments investigating salinity, the Shoot Ion Independent Tolerance (SIIT) index can be calculated using <code><a href="#topic+twoLevelOpcreate">twoLevelOpcreate</a></code>. 
</p>
</li></ol>



<h3>Author(s)</h3>

<p>NA
</p>
<p>Maintainer: NA
</p>


<h3>References</h3>

<p>Al-Tamimi, N, Brien, C.J., Oakey, H., Berger, B., Saade, S., Ho, Y. S., Schmockel, S. M., Tester, M. and Negrao, S. (2016) New salinity tolerance loci revealed in rice using high-throughput non-invasive phenotyping. <em>Nature Communications</em>, <b>7</b>, 13342.
</p>


<h3>See Also</h3>

<p><code><a href="dae.html#topic+dae-package">dae</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### This example can be run because the data.frame RiceRaw.dat is available with the package
#'# Step 1: Import the raw data
data(RiceRaw.dat)

#'# Step 2: Select imaging variables and add covariates and factors (produces longi.dat)
longi.dat &lt;- longitudinalPrime(data=RiceRaw.dat, smarthouse.lev=c("NE","NW"))

longi.dat &lt;- designFactors(longi.dat, insertName = "xDays",
                           designfactorMethod="StandardOrder")

#'## Particular edits to longi.dat
longi.dat &lt;- within(longi.dat, 
                    { 
                      Days.after.Salting &lt;- as.numfac(Days) - 29
                    })
longi.dat &lt;- with(longi.dat, longi.dat[order(Snapshot.ID.Tag,Days), ])

#'# Step 3: Form derived traits that result in a value for each observation
#'### Set responses
responses.image &lt;- c("Area")
responses.smooth &lt;- paste(responses.image, "smooth", sep=".")

#'## Form growth rates for each observation of a subset of responses by differencing
longi.dat &lt;- splitContGRdiff(longi.dat, responses.image, 
                             INDICES="Snapshot.ID.Tag",
                             which.rates = c("AGR","RGR"))

#'## Form Area.WUE 
longi.dat &lt;- within(longi.dat, 
                    { 
                      Area.WUE &lt;- WUI(Area.AGR*Days.diffs, Water.Loss)
                    })

#'## Add cumulative responses 
longi.dat &lt;- within(longi.dat, 
                    { 
                      Water.Loss.Cum &lt;- unlist(by(Water.Loss, Snapshot.ID.Tag, 
                                                  cumulate, exclude.1st=TRUE))
                      WUE.cum &lt;- Area / Water.Loss.Cum 
                    })

#'# Step 4: Fit splines to smooth the longitudinal trends in the primary traits and
#'# calculate their growth rates
#'
#'## Smooth responses
#+
for (response in c(responses.image, "Water.Loss"))
  longi.dat &lt;- splitSplines(longi.dat, response, x="xDays", INDICES = "Snapshot.ID.Tag", 
                            df = 4, na.rm=TRUE)
longi.dat &lt;- with(longi.dat, longi.dat[order(Snapshot.ID.Tag, xDays), ])

#'## Loop over smoothed responses, forming growth rates by differences
#+
responses.GR &lt;- paste(responses.smooth, "AGR", sep=".")
longi.dat &lt;- splitContGRdiff(longi.dat, responses.smooth, 
                             INDICES="Snapshot.ID.Tag",
                             which.rates = c("AGR","RGR"))

#'## Finalize longi.dat
longi.dat &lt;- with(longi.dat, longi.dat[order(Snapshot.ID.Tag, xDays), ])

#'# Step 5: Do exploratory plots on unsmoothed and smoothed longitudinal data
responses.longi &lt;- c("Area","Area.AGR","Area.RGR", "Area.WUE")
responses.smooth.plot &lt;- c("Area.smooth","Area.smooth.AGR","Area.smooth.RGR")
titles &lt;- c("Total area (1000 pixels)", 
            "Total area AGR (1000 pixels per day)", "Total area RGR (per day)",
            "Total area WUE (1000 pixels per mL)")
titles.smooth&lt;-titles
nresp &lt;- length(responses.longi)
limits &lt;- list(c(0,1000), c(-50,125), c(-0.05,0.40), c(0,30))

#' ### Plot unsmoothed profiles for all longitudinal  responses 
#+ "01-ProfilesAll"
klimit &lt;- 0
for (k in 1:nresp)
{ 
  klimit &lt;- klimit + 1
  longiPlot(data = longi.dat, response = responses.longi[k], 
            y.title = titles[k], x="xDays+35.42857143", 
            ggplotFuncs = list(geom_vline(xintercept=29, linetype="longdash", size=1), 
                               scale_x_continuous(breaks=seq(28, 42, by=2)),
                               scale_y_continuous(limits=limits[[klimit]])))
}


#' ### Plot smoothed profiles for all longitudinal responses - GRs by difference
#+ "01-SmoothedProfilesAll"
nresp.smooth &lt;- length(responses.smooth.plot)
limits &lt;- list(c(0,1000), c(0,100), c(0.0,0.40))
for (k in 1:nresp.smooth)
{ 
  longiPlot(data = longi.dat, response = responses.smooth.plot[k], 
            y.title = titles.smooth[k], x="xDays+35.42857143", 
            ggplotFuncs = list(geom_vline(xintercept=29, linetype="longdash", size=1), 
                               scale_x_continuous(breaks=seq(28, 42, by=2)),
                               scale_y_continuous(limits=limits[[klimit]])))
  print(plt)
}


#'### AGR anomalies - plot without anomalous plants followed by plot of anomalous plants
#+ "01-0254-AGRanomalies"
anom.ID &lt;- vector(mode = "character", length = 0L)
response &lt;- "Area.smooth.AGR"
cols.output &lt;- c("Snapshot.ID.Tag", "Smarthouse", "Lane", "Position", 
                 "Treatment.1", "Genotype.ID", "Days")
anomalous &lt;- anomPlot(longi.dat, response=response, lower=2.5, start.time=40, 
                      x = "xDays+35.42857143", vertical.line=29, breaks=seq(28, 42, by=2), 
                      whichPrint=c("innerPlot"), y.title=response)
subs &lt;- subset(anomalous$data, Area.smooth.AGR.anom &amp; Days==42)
if (nrow(subs) == 0)
{ cat("\n#### No anomalous data here\n\n")
} else
{ 
  subs &lt;- subs[order(subs["Smarthouse"],subs["Treatment.1"], subs[response]),]
  print(subs[c(cols.output, response)])
  anom.ID &lt;- unique(c(anom.ID, subs$Snapshot.ID.Tag))
  outerPlot &lt;- anomalous$outerPlot  + geom_text(data=subs,
                                                aes_string(x = "xDays+35.42857143", 
                                                           y = response, 
                                                           label="Snapshot.ID.Tag"), 
                                                size=3, hjust=0.7, vjust=0.5)
  print(outerPlot)
}


#'# Step 6: Form single-value plant responses in Snapshot.ID.Tag order.
#'
#'## 6a) Set up a data frame with factors only
#+
cart.dat &lt;- longi.dat[longi.dat$Days == 31, 
                      c("Smarthouse","Lane","Position","Snapshot.ID.Tag",
                        "xPosn","xMainPosn",
                        "Zones","xZones","SHZones","ZLane","ZMainplots", "Subplots",
                        "Genotype.ID","Treatment.1")]
cart.dat &lt;- cart.dat[do.call(order, cart.dat), ]

#'## 6b) Get responses based on first and last date.
#'
#'### Observation for first and last date
cart.dat &lt;- cbind(cart.dat, getDates(responses.image, data = longi.dat, 
                                     which.times = c(31), suffix = "first"))
cart.dat &lt;- cbind(cart.dat, getDates(responses.image, data = longi.dat, 
                                     which.times = c(42), suffix = "last"))
cart.dat &lt;- cbind(cart.dat, getDates(c("WUE.cum"), 
                                     data = longi.dat, 
                                     which.times = c(42), suffix = "last"))
responses.smooth &lt;- paste(responses.image, "smooth", sep=".")
cart.dat &lt;- cbind(cart.dat, getDates(responses.smooth, data = longi.dat, 
                                     which.times = c(31), suffix = "first"))
cart.dat &lt;- cbind(cart.dat, getDates(responses.smooth, data = longi.dat, 
                                     which.times = c(42), suffix = "last"))

#'### Growth rates over whole period.
#+
tottime &lt;- 42 - 31
cart.dat &lt;- within(cart.dat, 
                   { 
                     Area.AGR &lt;- (Area.last - Area.first)/tottime
                     Area.RGR &lt;- log(Area.last / Area.first)/tottime
                   })

#'### Calculate water index over whole period
cart.dat &lt;- merge(cart.dat, 
                  intervalWUI("Area", water.use = "Water.Loss", 
                              start.times = c(31), 
                              end.times = c(42), 
                              suffix = NULL, 
                              data = longi.dat, include.total.water = TRUE),
                  by = c("Snapshot.ID.Tag"))
names(cart.dat)[match(c("Area.WUI","Water.Loss.Total"),names(cart.dat))] &lt;- 
        c("Area.Overall.WUE", "Water.Loss.Overall")
cart.dat$Water.Loss.rate.Overall &lt;- cart.dat$Water.Loss.Overall / (42 - 31)

#'## 6c) Add growth rates and water indices for intervals
#'### Set up intervals
#+
start.days &lt;- list(31,35,31,38)
end.days &lt;- list(35,38,38,42)
suffices &lt;- list("31to35","35to38","31to38","38to42")

#'### Rates for specific intervals from the smoothed data by differencing
#+
for (r in responses.smooth)
{ for (k in 1:length(suffices))
  { 
    cart.dat &lt;- merge(cart.dat, 
                      intervalGRdiff(r, 
                                     which.rates = c("AGR","RGR"), 
                                     start.times = start.days[k][[1]], 
                                     end.times = end.days[k][[1]], 
                                     suffix.interval = suffices[k][[1]], 
                                     data = longi.dat),
                      by = "Snapshot.ID.Tag")
  }
}

#'### Water indices for specific intervals from the unsmoothed and smoothed data
#+
for (k in 1:length(suffices))
{ 
  cart.dat &lt;- merge(cart.dat, 
                    intervalWUI("Area", water.use = "Water.Loss", 
                                start.times = start.days[k][[1]], 
                                end.times = end.days[k][[1]], 
                                suffix = suffices[k][[1]], 
                                data = longi.dat, include.total.water = TRUE),
                    by = "Snapshot.ID.Tag")
  names(cart.dat)[match(paste("Area.WUI", suffices[k][[1]], sep="."), 
                        names(cart.dat))] &lt;- paste("Area.WUE", suffices[k][[1]], sep=".")
  cart.dat[paste("Water.Loss.rate", suffices[k][[1]], sep=".")] &lt;- 
           cart.dat[[paste("Water.Loss.Total", suffices[k][[1]], sep=".")]] / 
                                           ( end.days[k][[1]] - start.days[k][[1]])
}

cart.dat &lt;- with(cart.dat, cart.dat[order(Snapshot.ID.Tag), ])

#'# Step 7: Form continuous and interval SIITs
#'
#'## 7a) Calculate continuous
#+
cols.retained &lt;-  c("Snapshot.ID.Tag","Smarthouse","Lane","Position",
                    "Days","Snapshot.Time.Stamp", "Hour", "xDays",
                    "Zones","xZones","SHZones","ZLane","ZMainplots",
                    "xMainPosn", "Genotype.ID")
responses.GR &lt;- c("Area.smooth.AGR","Area.smooth.AGR","Area.smooth.RGR")
suffices.results &lt;- c("diff", "SIIT", "SIIT")
responses.SIIT &lt;- unlist(Map(paste, responses.GR, suffices.results,sep="."))

longi.SIIT.dat &lt;- 
  twoLevelOpcreate(responses.GR, longi.dat, suffices.treatment=c("C","S"),
                   operations = c("-", "/", "/"), suffices.results = suffices.results, 
                   columns.retained = cols.retained, 
                   by = c("Smarthouse","Zones","ZMainplots","Days"))
longi.SIIT.dat &lt;- with(longi.SIIT.dat, 
                            longi.SIIT.dat[order(Smarthouse,Zones,ZMainplots,Days),])

#' ### Plot SIIT profiles 
#' 
#+ "03-SIITProfiles"
k &lt;- 2
nresp &lt;- length(responses.SIIT)
limits &lt;- with(longi.SIIT.dat, list(c(min(Area.smooth.AGR.diff, na.rm=TRUE),
                                      max(Area.smooth.AGR.diff, na.rm=TRUE)),
                                    c(0,3),
                                    c(0,1.5)))
#Plots
for (k in 1:nresp)
{ 
  longiPlot(data = longi.SIIT.dat, x="xDays+35.42857143", 
            response = responses.SIIT[k], 
            y.title=responses.SIIT[k], 
            facet.x="Smarthouse", facet.y=".", 
            ggplotFuncs = list(geom_vline(xintercept=29, linetype="longdash", size=1), 
                               scale_x_continuous(breaks=seq(28, 42, by=2)),
                               scale_y_continuous(limits=limits[[klimit]])))
}

#'## 7b) Calculate interval SIITs and check for large values for SIIT for Days 31to35
#+ "01-SIITIntClean"
suffices &lt;- list("31to35","35to38","31to38","38to42")
response &lt;- "Area.smooth.RGR.31to35"
SIIT &lt;- paste(response, "SIIT", sep=".")
responses.SIITinterval &lt;- as.vector(outer("Area.smooth.RGR", suffices, paste, sep="."))

cart.SIIT.dat &lt;- twoLevelOpcreate(responses.SIITinterval, cart.dat, 
                                  suffices.treatment=c("C","S"), 
                                  suffices.results="SIIT", 
                                  columns.suffixed="Snapshot.ID.Tag")
tmp&lt;-na.omit(cart.SIIT.dat)
print(summary(tmp[SIIT]))
big.SIIT &lt;- with(tmp, tmp[tmp[SIIT] &gt; 1.15, c("Snapshot.ID.Tag.C","Genotype.ID",
                                              paste(response,"C",sep="."), 
                                              paste(response,"S",sep="."), SIIT)])
big.SIIT &lt;- big.SIIT[order(big.SIIT[SIIT]),]
print(big.SIIT)
plt &lt;- ggplot(tmp, aes_string(SIIT)) +
           geom_histogram(aes(y = ..density..), binwidth=0.05) +
           geom_vline(xintercept=1.15, linetype="longdash", size=1) +
           theme_bw() + facet_grid(Smarthouse ~.)
print(plt)
plt &lt;- ggplot(tmp, aes_string(x="Smarthouse", y=SIIT)) +
           geom_boxplot() + theme_bw()
print(plt)
remove(tmp)

## End(Not run)</code></pre>

<hr>
<h2 id='anom'>Tests if any values in a vector are anomalous in being outside specified limits</h2><span id='topic+anom'></span>

<h3>Description</h3>

<p>Test whether any values in <code>x</code> are less than the value of 
<code>lower</code>, if it is not <code>NULL</code>, or are greater than the 
value of <code>upper</code>, if it is not <code>NULL</code>, or both.</p>


<h3>Usage</h3>

<pre><code class='language-R'>anom(x, lower=NULL, upper=NULL, na.rm = TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anom_+3A_x">x</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> containing the values to be tested.</p>
</td></tr>
<tr><td><code id="anom_+3A_lower">lower</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> such that values in <code>x</code> below it are  
considered to be anomalous.</p>
</td></tr>
<tr><td><code id="anom_+3A_upper">upper</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> such that values in <code>x</code> above it are  
considered to be anomalous.</p>
</td></tr>
<tr><td><code id="anom_+3A_na.rm">na.rm</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether <code>NA</code> values should 
be stripped before the testing proceeds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether any values have been found to 
be outside the limits specified by <code>lower</code> or <code>upper</code> or both.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(exampleData)
anom.val &lt;- anom(longi.dat$Area.smooth.AGR, lower=2.5)
</code></pre>

<hr>
<h2 id='anomPlot'>Identifies anomalous individuals and produces longitudinal plots without them and with just them</h2><span id='topic+anomPlot'></span>

<h3>Description</h3>

<p>Uses <code><a href="#topic+intervalValueCalculate">intervalValueCalculate</a></code> and the function 
<code><a href="#topic+anom">anom</a></code> to identify anomalous individuals. The user can 
elect to print the anomalous individuals, a longitudinal profile plot 
without the anomalous individuals and/or a longitudinal profile plot 
with only the anomalous individuals. The plots are produced using 
<code>ggplot</code>. The plot can be facetted so that a grid of plots is 
produced.</p>


<h3>Usage</h3>

<pre><code class='language-R'>anomPlot(data, x="xDays+24.16666667", response="Area.smooth.RGR", 
         individuals="Snapshot.ID.Tag", 
         breaks=seq(12, 36, by=2), vertical.line=NULL, 
         groupsFactor=NULL, lower=NULL, upper=NULL, 
         start.time=NULL, end.time=NULL, times.factor = "Days", 
         suffix.interval=NULL, 
         columns.retained=c("Snapshot.ID.Tag", "Smarthouse", "Lane", 
                            "Position", "Treatment.1", "Genotype.ID"),
         whichPrint=c("anomalous","innerPlot","outerPlot"), na.rm=TRUE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anomPlot_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the data to be tested 
and plotted.</p>
</td></tr>
<tr><td><code id="anomPlot_+3A_x">x</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the variable to be plotted on 
the x-axis.</p>
</td></tr>
<tr><td><code id="anomPlot_+3A_response">response</code></td>
<td>
<p>A <code>character</code> specifying the response variable that 
is to be tested and plotted on the y-axis.</p>
</td></tr>
<tr><td><code id="anomPlot_+3A_individuals">individuals</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name(s) of the 
<code>factor</code>(s) that define the subsets of the <code>data</code> for 
which each subset corresponds to the <code>response</code> value for an 
individual.</p>
</td></tr>
<tr><td><code id="anomPlot_+3A_breaks">breaks</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> vector giving the breaks to be plotted on 
the x-axis scale.</p>
</td></tr>
<tr><td><code id="anomPlot_+3A_vertical.line">vertical.line</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving position on the x-axis 
at which a vertical line is to be drawn. If <code>NULL</code>, 
no line is drawn.</p>
</td></tr>
<tr><td><code id="anomPlot_+3A_groupsfactor">groupsFactor</code></td>
<td>
<p>A <code><a href="base.html#topic+factor">factor</a></code> giving the name of a 
<code>factor</code> that defines groups of individuals between which the 
test for anomalous individuals can be varied by setting values for 
one or more of <code>lower</code>, <code>upper</code>, <code>start.time</code> and 
<code>end.time</code> to be <code>NULL</code>, a single value or a set of values whose number 
equals the number of levels of <code>groupsFactor</code>. If <code>NULL</code> or 
only a dingle value is supplied, 
the test is the same for all individuals.</p>
</td></tr>
<tr><td><code id="anomPlot_+3A_lower">lower</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> such that values in <code>response</code> below 
it are  considered to be anomalous. If <code>NULL</code>, there is no 
testing for values below the lower bound.</p>
</td></tr>
<tr><td><code id="anomPlot_+3A_upper">upper</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> such that values in <code>response</code> above 
it are  considered to be anomalous. If <code>NULL</code>, there is no
testing for values above the upper bound.</p>
</td></tr>
<tr><td><code id="anomPlot_+3A_start.time">start.time</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the start of the time interval, 
in terms of a level of <code>times.factor</code>, 
during which testing for anomalous values is to occur. 
If <code>NULL</code>, the interval will start with the first 
observation.</p>
</td></tr>
<tr><td><code id="anomPlot_+3A_end.time">end.time</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the end of the time interval, 
in terms of a level of <code>times.factor</code>, 
during which testing for anomalous values is to occur.
If <code>NULL</code>, the interval will end with the last 
observation.</p>
</td></tr>
<tr><td><code id="anomPlot_+3A_times.factor">times.factor</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of the column in 
<code>data</code> containing the factor for times at which the data was 
collected. Its levels should be numeric values stored as 
characters.</p>
</td></tr>
<tr><td><code id="anomPlot_+3A_suffix.interval">suffix.interval</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the suffix to be 
appended to <code>response</code> to form the 
name of the column containing the calculated values. If it is
<code>NULL</code> then nothing will be appended.</p>
</td></tr>
<tr><td><code id="anomPlot_+3A_columns.retained">columns.retained</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the names of the 
columns in <code>data</code> that are to be retained in the 
<code>data.frame</code> of anomalous individuals.</p>
</td></tr>
<tr><td><code id="anomPlot_+3A_whichprint">whichPrint</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> indicating what is to be printed. 
If <code>anomalous</code> is included, the <code>columns.retained</code> 
are printed for the anomalous individuals.</p>
</td></tr>
<tr><td><code id="anomPlot_+3A_na.rm">na.rm</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether <code>NA</code> values should 
be stripped before the testing proceeds.</p>
</td></tr>
<tr><td><code id="anomPlot_+3A_...">...</code></td>
<td>
<p>allows for arguments to be passed to <code><a href="#topic+longiPlot">longiPlot</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+list">list</a></code> with three components: 
</p>

<ol>
<li> <p><code>data</code>, a data frame resulting from the <code><a href="base.html#topic+merge">merge</a></code> 
of <code>data</code> and the <code><a href="base.html#topic+logical">logical</a></code> identifying whether 
or not an individual is anomalous; 
</p>
</li>
<li> <p><code>innerPlot</code>, an object of class <code>ggplot</code> storing the 
longitudinal plot of the individuals that are not anomalous; 
</p>
</li>
<li> <p><code>outerPlot</code>, an object of class <code>ggplot</code> storing the 
longitudinal plot of only the individuals that are anomalous.</p>
</li></ol>
 
<p>The name of the column indicating anomalous individuals will be result of 
concatenating the <code>response</code>, <code><a href="#topic+anom">anom</a></code> and, if it is not 
<code>NULL</code>,  <code>suffix.interval</code>, each separated by a full stop. 
The <code>ggplot</code> objects can be plotted using <code>print</code> and can be 
modified by adding <code>ggplot</code> functions before printing. If there are 
no observations to plot, <code>NULL</code> will be returned for the plot.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+anom">anom</a></code>, <code><a href="#topic+intervalValueCalculate">intervalValueCalculate</a></code>, <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(exampleData)
anomalous &lt;- anomPlot(longi.dat, response="Area.smooth.AGR", 
                      lower=2.5, start.time=40, 
                      x = "xDays+35.42857143", vertical.line=29, 
                      breaks=seq(28, 42, by=2), 
                      whichPrint=c("innerPlot"), 
                      y.title="Area.smooth.AGR")
</code></pre>

<hr>
<h2 id='calcLagged'>Replaces the values in a vector with the result of applying an operation to it 
and a lagged value</h2><span id='topic+calcLagged'></span>

<h3>Description</h3>

<p>Replaces the values in <code>x</code> with the result of applying an 
<code>operation</code> to it and the value that is <code>lag</code> positions 
either before it or after it in <code>x</code>, depending on whether 
<code>lag</code> is positive or negative. For positive <code>lag</code> 
the first <code>lag</code> values will be <code>NA</code>, while for negative 
<code>lag</code> the last <code>lag</code> values will be <code>NA</code>. 
When <code>operation</code> is <code>NULL</code>, the values are moved 
<code>lag</code> positions down the vector.</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcLagged(x, operation = NULL, lag = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcLagged_+3A_x">x</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> containing the values on which the calculations are to be made.</p>
</td></tr>
<tr><td><code id="calcLagged_+3A_operation">operation</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the operation to be performed on pairs of 
values in <code>x</code>. If <code>operation</code> is <code>NULL</code> then the values are moved 
<code>lag</code> positions down the vector.</p>
</td></tr>
<tr><td><code id="calcLagged_+3A_lag">lag</code></td>
<td>
<p>A <code>integer</code> specifying, for the second value in the pair to be operated on, 
the number positions it is ahead of or behind the current value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+vector">vector</a></code> containing  the result of applying <code>operation</code> to 
values in <code>x</code>. For positive <code>lag</code> the first <code>lag</code> values will 
be <code>NA</code>, while for negative <code>lag</code> the last <code>lag</code> values will be <code>NA</code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+Ops">Ops</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(exampleData)
longi.dat$Days.diffs &lt;- calcLagged(longi.dat$xDays, operation ="-")
</code></pre>

<hr>
<h2 id='calcTimes'>Calculates for a set of times, the time intervals after an origin time and the position of each with in that time</h2><span id='topic+calcTimes'></span>

<h3>Description</h3>

<p>For the column specified in imageTimes, having converted it to <code>POSIXct</code> if not already converted, calculates for each value the number of <code>intervalUnits</code> between the time and the <code>startTime</code>. Then the number of <code>timePositions</code> within the <code>intervals</code> is calculated for the values in <code>imageTimes</code>. The function <code>difftimes</code> is used in doing the calculations, but the results are converted to <code>numeric</code>. For example <code>intervals</code> could correspond to the number of Days after Planting and the <code>timePositions</code> to the hour within each day.</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcTimes(data, imageTimes = NULL, timeFormat = "%Y-%m-%d %H:%M",
          intervals = "Time.after.Planting..d.", startTime = NULL, 
          intervalUnit = "days", timePositions = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcTimes_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing any columns specified by 
<code>imageTimes</code>, <code>intervals</code> and <code>timePositions</code>.</p>
</td></tr>
<tr><td><code id="calcTimes_+3A_imagetimes">imageTimes</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of the column that contains
the time that each cart was imaged. Note that in importing data into R, spaces 
and nonalphanumeric characters in names are converted to full stops. 
If <code>imageTimes</code> is <code>NULL</code> then no calculations are done.</p>
</td></tr>
<tr><td><code id="calcTimes_+3A_timeformat">timeFormat</code></td>
<td>
<p>A <code>character</code> giving the <code>POSIXct</code> format of characters 
containing times, in particular <code>imageTimes</code> and <code>startTime</code>. 
Note that if fractions of seconds are required <code>options(digits.secs)</code> 
must be used to set the number of decimal places and <code>timeFormat</code> must 
use <code>%OS</code> for seconds in <code>timeFormat</code>.</p>
</td></tr> 
<tr><td><code id="calcTimes_+3A_intervals">intervals</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of the column in <code>data</code>
containing, as a <code><a href="base.html#topic+numeric">numeric</a></code> or a <code><a href="base.html#topic+factor">factor</a></code>, 
the calculated times after <code>startTime</code> to be 
plotted on the x-axis.  It is given as the number 
of <code>intervalUnits</code> between the two times. If <code>startTime</code> is 
<code>NULL</code> then <code>intervals</code> is not calculated.</p>
</td></tr>
<tr><td><code id="calcTimes_+3A_starttime">startTime</code></td>
<td>
<p>A <code>character</code> giving the time, in the <code>POSIXct</code> 
format specified by <code>timeFormat</code>, to be subtracted from 
<code>imageTimes</code> to caclualte <code>intervals</code>. For example, it might be the 
day of planting or treatment. If <code>startTime</code> is 
<code>NULL</code> then <code>intervals</code> is not calculated.</p>
</td></tr> 
<tr><td><code id="calcTimes_+3A_intervalunit">intervalUnit</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of the unit in which 
the values of the intervals should be expressed. It must be one of <code>"secs"</code>, 
<code>"mins"</code>, <code>"hours"</code> or <code>"days"</code>.</p>
</td></tr>  
<tr><td><code id="calcTimes_+3A_timepositions">timePositions</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of  the column in 
<code>data</code> containing, as a <code><a href="base.html#topic+numeric">numeric</a></code>, the value of the 
time position within an interval (for example, the time of imaging during the day 
expressed in hours plus a fraction of an hour). If <code>timePositions</code> 
is <code>NULL</code> then it is not calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code>, being the unchaged data <code>data.frame</code> when 
<code>imageTimes</code> is <code>NULL</code> or containing 
either intervals and/or timePositions depending on which is not <code>NULL</code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code>, <code><a href="#topic+imagetimesPlot">imagetimesPlot</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(exampleData)
  raw.dat &lt;- calcTimes(data = raw.dat, 
                       imageTimes = "Snapshot.Time.Stamp", timePositions = "Hour")
</code></pre>

<hr>
<h2 id='corrPlot'>Calculates and plots correlation matrices for a set of responses</h2><span id='topic+corrPlot'></span>

<h3>Description</h3>

<p>Having calculated the correlations a heat map indicating the magnitude of the 
correlations is produced using <code>ggplot</code>. In this heat map, the darker the red in 
a cell then the closer the correlation is to -1, while the deeper the blue in the cell,
then the closer the correlation is to 1. Also produced is a matrix plot of all pairwise 
combinations of the variables. The matrix plot contains a scatter diagram for each pair, 
as well as the value of the correlation coefficient. The argument <code>pairs.sets</code> 
can be used to restrict the pairs in the matrix plot to those combinations within each 
set. </p>


<h3>Usage</h3>

<pre><code class='language-R'>corrPlot(responses, data, which.plots = c("heatmap","matrixplot"), 
                       title = NULL, labels = NULL, labelSize = 4, 
                       show.sig = FALSE, pairs.sets = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corrPlot_+3A_responses">responses</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the names of the columns in 
<code>data</code> containing the variables to be correlated.</p>
</td></tr>
<tr><td><code id="corrPlot_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the columns of variables to be correlated.</p>
</td></tr>
<tr><td><code id="corrPlot_+3A_which.plots">which.plots</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> specifying the plots of the correlations to be 
produced.</p>
</td></tr>
<tr><td><code id="corrPlot_+3A_title">title</code></td>
<td>
<p>Title for the plots.</p>
</td></tr>
<tr><td><code id="corrPlot_+3A_labels">labels</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> specifying the labels to be used in the plots. 
If <code>labels</code> is <code>NULL</code>, <code>responses</code> is used for the <code>labels</code>.</p>
</td></tr>
<tr><td><code id="corrPlot_+3A_labelsize">labelSize</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the size of the <code>labels</code> in the 
<code>matrixplot</code>.</p>
</td></tr>
<tr><td><code id="corrPlot_+3A_show.sig">show.sig</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether or not to give asterisks indicating 
significance on the plot.</p>
</td></tr>
<tr><td><code id="corrPlot_+3A_pairs.sets">pairs.sets</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code> each of whose components is a <code><a href="base.html#topic+numeric">numeric</a></code> giving 
the position of the variable names in <code>responses</code> that are to be included 
in the set. All pairs of variables in this pairs.set will be included in a 
matrix plot.</p>
</td></tr>
<tr><td><code id="corrPlot_+3A_...">...</code></td>
<td>
<p>allows passing of arguments to other functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(exampleData)
responses &lt;- c("Area","Area.SV","Area.TV", "Image.Biomass", "Max.Height","Centre.Mass",
               "Density", "Compactness.TV", "Compactness.SV")
corrPlot(responses, longi.dat, pairs.sets=list(c(1:4),c(5:7)))


## End(Not run)</code></pre>

<hr>
<h2 id='cumulate'>Calculates the cumulative sum, ignoring the first element if exclude.1st is TRUE</h2><span id='topic+cumulate'></span>

<h3>Description</h3>

<p>Uses <code>cumsum</code> to calculate the cumulative sum, ignoring the first element 
if exclude.1st is <code>TRUE</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>cumulate(x, exclude.1st = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cumulate_+3A_x">x</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> containing the values to be cumulated.</p>
</td></tr>
<tr><td><code id="cumulate_+3A_exclude.1st">exclude.1st</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether or not the first value of 
the cumulative sum is to be <code>NA</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+vector">vector</a></code> containing  the cumulative sum.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+cumsum">cumsum</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(exampleData)
Area.cum &lt;- cumulate(longi.dat$Area)
</code></pre>

<hr>
<h2 id='designFactors'>Adds the factors and covariates for a blocked, split-plot design</h2><span id='topic+designFactors'></span>

<h3>Description</h3>

<p>Add the following  factors and covariates to a date frame containing imaging data from the Plant Accelerator: Zones, xZones, SHZones, ZLane, ZMainplots, Subplots and xMainPosn. It checks that the numbers of levels of the factors are consistent with the observed numbers of carts and observations.</p>


<h3>Usage</h3>

<pre><code class='language-R'>designFactors(data, insertName = NULL, designfactorMethod = "LanePosition", 
              nzones = 6, nlanesperzone = 4, nmainplotsperlane = 11, nsubplotspermain = 2)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="designFactors_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> to which are to be added the design factors and covariates and which must contain the following columns: 
</p>
<p>Smarthouse, Snapshot.ID.Tag, XDays, xPosn and, 
</p>
<p>if <code>designfactorMethod = "LanePosition"</code>, Lane and Position.</p>
</td></tr>
<tr><td><code id="designFactors_+3A_insertname">insertName</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of the column in the <code>data.frame</code> after which the new factors and covariates are to be inserted. If <code>NULL</code>, they are added after the last column.</p>
</td></tr> 
<tr><td><code id="designFactors_+3A_designfactormethod">designfactorMethod</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the method to use to obtain the columns for the design factors Zones, ZLane, Mainplots and Subplots. For <code>LanePosition</code>, it is assumed that (i) Lane can be divided into Zones and ZLane, each with nzones and nlanesperzone levels, respectively, and (ii) Position can be divided into Mainplots and Subplots, each with nmainplotsperlane and nmainplotsperlane levels, respectively. The factor SHZones is formed by combining Smarthouse and Zones and ZMainplots is formed by combining ZLane and Mainplots. For <code>StandardOrder</code>, the factors Zones, ZLane, Mainplots, Subplots are generated in standard order, with the levels of Subplots changing for every observation and the levels of subsequent changing only after all combinations of the levels of the factors to its right have been cycled through.</p>
</td></tr> 
<tr><td><code id="designFactors_+3A_nzones">nzones</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the number of zones in a smarthouse.</p>
</td></tr>
<tr><td><code id="designFactors_+3A_nlanesperzone">nlanesperzone</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the number of lanes in each zone.</p>
</td></tr>
<tr><td><code id="designFactors_+3A_nmainplotsperlane">nmainplotsperlane</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the number of mainplots in each lane.</p>
</td></tr>
<tr><td><code id="designFactors_+3A_nsubplotspermain">nsubplotspermain</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the number of subplots in a main plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The factors Zones, ZLane, ZMainplots and Subplots are derived for each Smarthouse based on the values of <code>nzones</code>, <code>nlanesperzone</code>, <code>nmainplotsperlane</code>, <code>nsubplotspermain</code>, Zones being the blocks in the split-plot design. Thus, the number of carts in each Smarthouse must be the product of these values and the number of observations must be the product of the numbers of smarthouse, carts and imagings for each cart. If this is not the case, it may be able to be achieved by including in <code>data</code> rows for extra observations that have values for the Snapshot.ID.Tag, Smarthouse, Lane, Position and Time.after.Planting..d. and the remaining columns for these rows have missing values (<code>NA</code>) Then SHZones is formed by combining Smarthouse and Zones and the covariates xZones and xMainPosn calculated. The covariate xZones is calculated from Zones and xMainPosn is formed from the mean of xPosn for each main plot.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> including the columns:
</p>

<ol>
<li><p> Smarthouse: factor with levels for the Smarthouse
</p>
</li>
<li><p> Zones: factor dividing the Lanes into groups, usually of 4 lanes
</p>
</li>
<li><p> xZones: numeric corresponding to Zones, centred by subtracting the mean of the unique positions
</p>
</li>
<li><p> SHZones: factor for the combinations of Smarthouse and Zones
</p>
</li>
<li><p> ZLane: factor for the lanes within a Zone
</p>
</li>
<li><p> ZMainplots: factor for the main plots within a Zone
</p>
</li>
<li><p> Subplots: factor for the subplots
</p>
</li>
<li><p> xMainPosn: numeric for the main-plot positions within a Lane, centred by subtracting the mean of the unique positions</p>
</li></ol>



<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(exampleData)
longi.dat &lt;- designFactors(longi.prime.dat, insertName = "xDays",
                           nzones = 1, nlanesperzone = 1, nmainplotsperlane = 10, 
                           designfactorMethod="StandardOrder")
</code></pre>

<hr>
<h2 id='exampleData'>A small data set to use in function examples</h2><span id='topic+exampleData'></span><span id='topic+raw.dat'></span><span id='topic+longi.prime.dat'></span><span id='topic+longi.dat'></span><span id='topic+cart.dat'></span>

<h3>Description</h3>

<p>Imaging  data for 20 of the plants from an experiment in a Smarthouse in the Plant Accelerator. It is used as a small example in the documentation for <code>imageData</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(exampleData)</code></pre>


<h3>Format</h3>

<p>Four <code>data.frames</code>: raw.dat (280 rows by 33 columns), longi.prime.dat (280 rows by 45 columns), longi.dat (280 rows by 63 columns), cart.dat (20 rows by 14 columns).</p>

<hr>
<h2 id='fitSpline'>Produce the fits from a natural cubic smoothing spline applied to a response in a <code>data.frame</code></h2><span id='topic+fitSpline'></span>

<h3>Description</h3>

<p>Uses <code>smooth.spline</code> to fit a spline to all the values of 
<code>response</code> stored in <code>data</code>. 
</p>
<p>The amount of smoothing can be controlled by <code>df</code>. 
If <code>df = NULL</code>, the amount of 
smoothing is controlled by the default arguments and those you supply 
for <code>smooth.spline</code>. The method of Huang (2001) for correcting the 
fitted spline for estimation bias at the end-points will be applied if 
<code>correctBoundaries</code> is <code>TRUE</code>.
</p>
<p>The derivatives of the fitted spline can also be obtained, and the 
Relative Growth Rate (RGR) computed using them, provided 
<code>correctBoundaries</code> is <code>FALSE</code>. Otherwise, growth rates can be 
obtained by difference using <code><a href="#topic+splitContGRdiff">splitContGRdiff</a></code>.
</p>
<p>By default, <code>smooth.spline</code> will issue an error if there are not 
at least four distinct x-values. On the other hand, <code>fitSplines</code> 
issues a warning and sets all smoothed values and derivatives to 
<code>NA</code>. The handling of missing values in the observations is 
controlled via <code>na.x.action</code> and <code>na.y.action</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitSpline(data, response, x, df=NULL, smoothing.scale = "identity", 
          correctBoundaries = FALSE, 
          deriv=NULL, suffices.deriv=NULL, RGR=NULL, AGR=NULL, 
          na.x.action="exclude", na.y.action = "exclude", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitSpline_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the column to be smoothed.</p>
</td></tr>
<tr><td><code id="fitSpline_+3A_response">response</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of the column in 
<code>data</code> that is to be smoothed.</p>
</td></tr>
<tr><td><code id="fitSpline_+3A_x">x</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of the column in 
<code>data</code> that contains the values of the predictor variable.</p>
</td></tr>
<tr><td><code id="fitSpline_+3A_df">df</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> specifying the desired equivalent number of degrees 
of freedom of the smooth (trace of the smoother matrix). Lower values 
result in more smoothing. If <code>df = NULL</code>, the amount of smoothing 
is controlled by the default arguments for and those that you supply to 
<code>smooth.spline</code>.</p>
</td></tr>
<tr><td><code id="fitSpline_+3A_smoothing.scale">smoothing.scale</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the scale on which smoothing 
is to be performed. The two possibilites are <code>"identity"</code>, for directly 
smoothing the observed <code>response</code>, and <code>"logarithmic"</code>, for scaling the 
<code>log</code>-transformed <code>response</code>.</p>
</td></tr>
<tr><td><code id="fitSpline_+3A_correctboundaries">correctBoundaries</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether the fitted spline 
values are to have the method of Huang (2001) applied 
to them to correct for estimation bias at the end-points. Note that 
<code>deriv</code> must be <code>NULL</code> for <code>correctBoundaries</code> to be 
set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="fitSpline_+3A_deriv">deriv</code></td>
<td>
<p>A <code>numeric</code> specifying one or more orders of derivatives 
that are required.</p>
</td></tr>
<tr><td><code id="fitSpline_+3A_suffices.deriv">suffices.deriv</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the characters to be 
appended to the names of the derivatives.</p>
</td></tr>
<tr><td><code id="fitSpline_+3A_rgr">RGR</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the character to be appended 
to the smoothed <code>response</code> to create the RGR name, 
but only when <code>smoothing.scale</code> is <code>identity</code>. 
When <code>smoothing.scale</code> is <code>identity</code>: 
(i) if <code>RGR</code> is not <code>NULL</code>  
<code>deriv</code> must include 1 so that the first derivative is 
available for calculating the RGR; (ii) if <code>RGR</code> is <code>NULL</code>, 
the RGR is not calculated from the AGR. 
When <code>smoothing.scale</code> is <code>logarithmic</code>, 
the RGR is the backtransformed first derivative and so, to obtain it, merely 
include <code>1</code> in <code>deriv</code> and any suffix for it in 
<code>suffices.deriv</code>.</p>
</td></tr>
<tr><td><code id="fitSpline_+3A_agr">AGR</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the character to be appended 
to the smoothed <code>response</code> to create the AGR name, 
but only when <code>smoothing.scale</code> is <code>logarithmic</code>. 
When <code>smoothing.scale</code> is <code>logarithmic</code>: (i) 
if <code>AGR</code> is not <code>NULL</code>, 
<code>deriv</code> must include 1 so that the first derivative is 
available for calculating the AGR; (ii) If <code>AGR</code> is <code>NULL</code>, 
the AGR is not calculated from the RGR. When <code>smoothing.scale</code> is <code>identity</code>, 
the AGR is the first derivative and so, to obtain it, merely 
include <code>1</code> in <code>deriv</code> and any suffix for it in 
<code>suffices.deriv</code>.</p>
</td></tr>
<tr><td><code id="fitSpline_+3A_na.x.action">na.x.action</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string that specifies the action to 
be taken when values of <code>x</code> are <code>NA</code>. The possible 
values are <code>fail</code>, <code>exclude</code> or <code>omit</code>. 
For <code>exclude</code> and <code>omit</code>, predictions and derivatives 
will only be obtained for nonmissing values of <code>x</code>. 
The difference between these two codes is that for <code>exclude</code> 
the returned <code>data.frame</code> will have as many rows as 
<code>data</code>, the missing values have been incorporated. </p>
</td></tr>
<tr><td><code id="fitSpline_+3A_na.y.action">na.y.action</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string that specifies the action to 
be taken when values of <code>y</code>, or the <code>response</code>, are 
<code>NA</code>.  The possible values are <code>fail</code>, <code>exclude</code>, 
<code>omit</code>, <code>allx</code>, <code>trimx</code>, <code>ltrimx</code> or 
<code>rtrimx</code>. For  all options, except <code>fail</code>, missing 
values in <code>y</code> will be removed before smoothing. 
For <code>exclude</code> and <code>omit</code>, predictions 
and derivatives will be obtained only for nonmissing values of 
<code>x</code> that do not have missing <code>y</code> values. Again, the 
difference between these two is that, only for <code>exclude</code> 
will the missing values be incorporated into the 
returned <code>data.frame</code>. For <code>allx</code>, predictions and 
derivatives will be obtained for all nonmissing <code>x</code>. 
For <code>trimx</code>, they will be obtained for all nonmissing 
<code>x</code> between the first and last nonmissing <code>y</code> values 
that have been ordered for <code>x</code>; for <code>ltrimx</code> and 
<code>utrimx</code> either the lower or upper missing <code>y</code> 
values, respectively, are trimmed.</p>
</td></tr>
<tr><td><code id="fitSpline_+3A_...">...</code></td>
<td>
<p>allows for arguments to be passed to <code>smooth.spline</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> containing <code>x</code> and the fitted smooth. The names 
of the columns will be the value of <code>x</code> and the value of <code>response</code> 
with <code>.smooth</code> appended. The number of rows in the <code>data.frame</code> 
will be equal to the number of pairs that have neither a missing <code>x</code> or 
<code>response</code> and it will have the same order of codex as <code>data</code>. 
If <code>deriv</code> is not <code>NULL</code>, columns 
containing the values of the derivative(s) will be added to the 
<code>data.frame</code>; the name each of these columns will be the value of 
<code>response</code> with <code>.smooth.dvf</code> appended, where 
<code>f</code> is the order of the derivative, or  the value of <code>response</code> 
with <code>.smooth.</code> and the corresponding element of 
<code>suffices.deriv</code> appended. If <code>RGR</code> is not <code>NULL</code>, the RGR 
is calculated as the ratio of value of the first derivative of the fitted 
spline and the fitted value for the spline.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>Huang, C. (2001). Boundary corrected cubic smoothing splines. <em>Journal of Statistical Computation and Simulation</em>, <b>70</b>, 107-121.</p>


<h3>See Also</h3>

<p><code><a href="#topic+splitSplines">splitSplines</a></code>, <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>,
<code><a href="stats.html#topic+predict.smooth.spline">predict.smooth.spline</a></code>, <code><a href="#topic+splitContGRdiff">splitContGRdiff</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(exampleData)
fit &lt;- fitSpline(longi.dat, response="Area", , x="xDays", df = 4,
                 deriv=c(1,2), suffices.deriv=c("AGRdv","Acc"))
</code></pre>

<hr>
<h2 id='getDates'>Forms a subset of <code>responses</code> in <code>data</code> that contains their values for the nominated times</h2><span id='topic+getDates'></span>

<h3>Description</h3>

<p>Forms a subset of <code>responses</code> in <code>data</code> that contains their values for the 
nominated times.</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDates(responses, times.factor = "Days", data, which.times, 
         suffix = NULL, include.times.factor = FALSE, 
         include.individuals = FALSE, individuals = "Snapshot.ID.Tag")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDates_+3A_responses">responses</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the names of the columns in 
<code>data</code> whose values are to be subsetted.</p>
</td></tr>
<tr><td><code id="getDates_+3A_times.factor">times.factor</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of the column in 
<code>data</code> containing the factor for times at which the data was 
collected. Its levels will be used to identify the subset and 
should be numeric values stored as characters.</p>
</td></tr>
<tr><td><code id="getDates_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the column from which the 
growth rates are to be calculated.</p>
</td></tr>
<tr><td><code id="getDates_+3A_which.times">which.times</code></td>
<td>
<p>A <code><a href="base.html#topic+vector">vector</a></code> giving the times that are to be selected.</p>
</td></tr>
<tr><td><code id="getDates_+3A_suffix">suffix</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the suffix to be appended to 
<code>responses</code> to form the names of the columns containing the 
subset.</p>
</td></tr>
<tr><td><code id="getDates_+3A_include.times.factor">include.times.factor</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether or not 
to include the <code>times.factor</code> in the result, the name in the result 
having the <code>suffix</code> with a separating full appended.</p>
</td></tr>
<tr><td><code id="getDates_+3A_include.individuals">include.individuals</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether or not 
to include the <code>individuals</code> column in the result.</p>
</td></tr>
<tr><td><code id="getDates_+3A_individuals">individuals</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of the column in 
<code>data</code> containing an identifier for each individual.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the subset of <code>responses</code> ordered 
by as many of the initial columns as are required to uniquely identify each row 
(see <code><a href="base.html#topic+order">order</a></code> for more information). The names of the columns for 
<code>responses</code> and <code>times.factor</code> in the subset are the concatenation of   
their names in <code>data</code> and <code>suffix</code> separated by a full stop.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(exampleData)
AreaLast &lt;- getDates("Area.smooth", data = longi.dat, 
                     which.times = c(42), suffix = "last")
</code></pre>

<hr>
<h2 id='GrowthRates'>Calculates growth rates (AGR, PGR, RGRdiff) between pairs of values in a vector</h2><span id='topic+GrowthRates'></span><span id='topic+AGRdiff'></span><span id='topic+PGR'></span><span id='topic+RGRdiff'></span>

<h3>Description</h3>

<p>Calculates either the Absolute Growth Rate (AGR), Proportionate Growth 
Rate (PGR) or Relative Growth Rate (RGR) between pairs of time points, 
the second of which is <code>lag</code> positions before the first 
in <code>x</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>AGRdiff(x, time.diffs, lag=1)
PGR(x, time.diffs, lag=1)
RGRdiff(x, time.diffs, lag=1)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GrowthRates_+3A_x">x</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> from which the growth rates are to 
be calculated.</p>
</td></tr>
<tr><td><code id="GrowthRates_+3A_time.diffs">time.diffs</code></td>
<td>
<p>a <code>numeric</code> giving the time differences between successive 
values in <code>x</code>.</p>
</td></tr>
<tr><td><code id="GrowthRates_+3A_lag">lag</code></td>
<td>
<p>A <code>integer</code> specifying, for the second value in the pair to be operated on, 
the number positions it is ahead of the current value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The AGRdiff is calculated as the difference between a pair of values divided by the <code>time.diffs</code>. 
The PGR is calculated as the ratio of a value to a second value which is <code>lag</code> values 
ahead of the first in <code>x</code> and the ratio raised to the 
power of the reciprocal of <code>time.diffs</code>. 
The RGRdiff is calculated as the <code>log</code> of the PGR and so is equal to the difference between 
the logarithms of a pair of values divided by the <code>time.diffs</code>.
The differences and ratios are obtained using <code>calcLagged</code> with <code>lag = 1</code>.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+numeric">numeric</a></code> containing the growth rates which is the same length as <code>x</code> 
and in which the first <code>lag</code> values <code>NA</code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+intervalGRaverage">intervalGRaverage</a></code>, <code><a href="#topic+intervalGRdiff">intervalGRdiff</a></code>, <code><a href="#topic+splitContGRdiff">splitContGRdiff</a></code>, <code><a href="#topic+splitSplines">splitSplines</a></code>, <code>calcLagged</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(exampleData)
longi.dat$Area.AGR &lt;- with(longi.dat, AGRdiff(Area, time.diffs = Days.diffs))
</code></pre>

<hr>
<h2 id='imagetimesPlot'>Plots the position of a time within an interval against the interval for each cart</h2><span id='topic+imagetimesPlot'></span>

<h3>Description</h3>

<p>Uses <code>ggplot</code> to produce a plot of the time position within an interval
against the interval. For example, one might plot the hour of the day carts 
are imaged against the days after planting (or some other number of 
days after an event). A line is produced for each value of <code>groupVariable</code> 
and the colour is varied according to the value of the <code>colourVariable</code>. 
Each <code>Smarthouse</code> is plotted separately. It aids in checking 
whether delays  occurred in imaging the plants.</p>


<h3>Usage</h3>

<pre><code class='language-R'>imagetimesPlot(data, intervals = "Time.after.Planting..d.", timePositions = "Hour", 
               groupVariable = "Snapshot.ID.Tag", colourVariable = "Lane", 
               ggplotFuncs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imagetimesPlot_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing any columns specified by 
<code>intervals</code>, <code>timePositions</code>, <code>groupVariable</code> and 
<code>colourVariable</code>.</p>
</td></tr>
<tr><td><code id="imagetimesPlot_+3A_intervals">intervals</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of the column in <code>data</code>
containing, as a <code><a href="base.html#topic+numeric">numeric</a></code> or a <code><a href="base.html#topic+factor">factor</a></code>, 
the calculated times to be plotted on the x-axis.  For example, it could be the 
days after planting or treatment.</p>
</td></tr>
<tr><td><code id="imagetimesPlot_+3A_timepositions">timePositions</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of  the column in 
<code>data</code> containing, as a <code><a href="base.html#topic+numeric">numeric</a></code>, the value of the 
time position within an interval (for example, the time of imaging during the day 
expressed in hours plus a fraction of an hour).</p>
</td></tr>
<tr><td><code id="imagetimesPlot_+3A_groupvariable">groupVariable</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of  the column in 
<code>data</code> containing the variable to be used to group the 
plotting.</p>
</td></tr>
<tr><td><code id="imagetimesPlot_+3A_colourvariable">colourVariable</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of  the column 
in <code>data</code> containing the variable to be used to colour 
the plotting.</p>
</td></tr>
<tr><td><code id="imagetimesPlot_+3A_ggplotfuncs">ggplotFuncs</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code>, each element of which contains the 
results of evaluating a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> function. 
It is created by calling the <code><a href="base.html#topic+list">list</a></code> function with 
a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> function call for each element.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;<code>ggplot</code>&quot;, which can be plotted using <code>print</code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>, <code><a href="#topic+calcTimes">calcTimes</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(exampleData)
library(ggplot2)
longi.dat &lt;- calcTimes(longi.dat, imageTimes = "Snapshot.Time.Stamp",
                       timePositions = "Hour")
imagetimesPlot(data = longi.dat, intervals = "Days", timePositions = "Hour",
               ggplotFuncs=list(scale_colour_gradient(low="grey20", high="black"), 
                                geom_line(aes(group=Snapshot.ID.Tag, colour=Lane))))

</code></pre>

<hr>
<h2 id='importExcel'>Imports an Excel imaging file and allows some renaming of variables</h2><span id='topic+importExcel'></span>

<h3>Description</h3>

<p>Uses <code>readxl</code> to import a sheet of imaging data produced by the 
Lemna Tec Scanalyzer. Basically, the data consists of imaging data obtained from a 
set of pots or carts over time. There should be a column, which by default is called 
<code>Snapshot.ID.Tag</code>, containing a unique identifier for each cart and a column, 
which by default is labelled <code>Snapshot.Time.Stamp</code>, containing 
the time of imaging for each observation in a row of the sheet. Also, if 
<code>startTime</code> is not <code>NULL</code>, <code>calcTimes</code> is called to 
calculate, or recalculate if already present, <code>timeAfterStart</code> from 
<code>imageTimes</code> by subtracting a supplied <code>startTime</code>. 
</p>
<p>Using <code>cameraType</code>, <code>keepCameraType</code>, <code>labsCamerasViews</code> and 
<code>prefix2suffix</code>, some flexibility is provided for renaming the columns with 
imaging data. For example, if the column names are prefixed with 'RGB_SV1', 'RGB_SV2' 
or 'RGB_TV', the 'RGB_' can be removed and the 'SV1', 'SV2' or 'TV' become suffices. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>importExcel(file, sheet="raw data", sep = ",", 
            cartId = "Snapshot.ID.Tag", 
            imageTimes = "Snapshot.Time.Stamp", 
            timeAfterStart = "Time.after.Planting..d.", 
            cameraType = "RGB", keepCameraType = FALSE, 
            labsCamerasViews = NULL, prefix2suffix = TRUE, 
            startTime = NULL,
            timeFormat = "%Y-%m-%d %H:%M", 
            imagetimesPlot = TRUE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="importExcel_+3A_file">file</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the path and name of the file containing 
the data.</p>
</td></tr>
<tr><td><code id="importExcel_+3A_sheet">sheet</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of the sheet containing 
the data, that must include columns whose names are as specified by <code>cartId</code>, 
which uniquely indexes the carts in the experiment, and 
<code>imageTimes</code>, which reflects the time of the imaging from 
which a particular data value was obtained. It is also assumed that a 
column whose name is specified by <code>timeAfterStart</code> is in the sheet or that 
it will be calculated from <code>imageTimes</code> using the value of 
<code>startTime</code> supplied in the function call.</p>
</td></tr>
<tr><td><code id="importExcel_+3A_sep">sep</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the separator used in a <code>csv</code> file.</p>
</td></tr>
<tr><td><code id="importExcel_+3A_cartid">cartId</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of the column that contains
the unique Id for each cart. Note that in importing data into R, spaces 
and nonalphanumeric characters in names are converted to full stops.</p>
</td></tr>
<tr><td><code id="importExcel_+3A_imagetimes">imageTimes</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of the column that contains
the time that each cart was imaged. Note that in importing data into R, spaces 
and nonalphanumeric characters in names are converted to full stops.</p>
</td></tr>
<tr><td><code id="importExcel_+3A_timeafterstart">timeAfterStart</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of the column that 
contains or is to contain the difference between <code>imageTimes</code> and 
<code>startTime</code>. The function <code>calcTimes</code> is called to calculate the
differences. For example, it might contain the number of days after 
planting. Note that in importing data into R, spaces 
and nonalphanumeric characters in names are converted to full stops.</p>
</td></tr>
<tr><td><code id="importExcel_+3A_cameratype">cameraType</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string nominating the abbreviation used for the 
cameraType. A warning will be given if no variable names include this cameraType.</p>
</td></tr>
<tr><td><code id="importExcel_+3A_keepcameratype">keepCameraType</code></td>
<td>
<p>A <code>logical</code> specifying whether to retain the <code>cameraType</code> in the 
variables names. It will be the start of the prefix or suffix and separated from 
the remander of the prefix or suffix by an underscore (_).</p>
</td></tr>
<tr><td><code id="importExcel_+3A_labscamerasviews">labsCamerasViews</code></td>
<td>
<p>A named <code><a href="base.html#topic+character">character</a></code> whose elements are new labels for the 
camera-view combinations and the name of each element is the old label for the 
camera-view combination in the data being imported. If <code>labsCamerasViews</code> 
is <code>NULL</code>, all column names beginning with <code>cameraType</code> are classed as 
imaging variables and the unique prefixes amongst them determined. If no imaging 
variables are found then no changes are made. Note that if you want to include a 
recognisable <code>cameraType</code> in a camier-view label, it should be at the start 
of the the label in <code>labsCamerasViews</code> and separated from the rest of the 
label by an underscore (_).</p>
</td></tr>
<tr><td><code id="importExcel_+3A_prefix2suffix">prefix2suffix</code></td>
<td>
<p>A <code>logical</code> specifying whether the variables names with prefixed 
camera-view labels are to have those prefixes transferred to become suffices. 
The prefix is assumed to be all the characters up to the first full stop (.) in the 
variable name and must contain <code>cameraType</code> to be moved. It is generally 
assumed that the characters up to the first underscore (_) are the camera type 
and this is removed if <code>keepCameraType</code> is <code>FALSE</code>. If there is no 
underscore (_), the whole prefix is moved. If <code>labsCamerasViews</code> is 
<code>NULL</code>, all column names beginning with <code>cameraType</code> are classed as 
imaging variables and the unique prefixes amongst them determined. 
If no imaging variables are found then no changes are made.</p>
</td></tr>
<tr><td><code id="importExcel_+3A_starttime">startTime</code></td>
<td>
<p>A <code>character</code> giving the time of planting, in the <code>POSIXct</code> 
format timeFormat, to be subtracted from <code>imageTimes</code> 
in recalculating <code>timeAfterStart</code>. If <code>startTime</code> is 
<code>NULL</code> then <code>timeAfterStart</code> is not recalculated.</p>
</td></tr> 
<tr><td><code id="importExcel_+3A_timeformat">timeFormat</code></td>
<td>
<p>A <code>character</code> giving the <code>POSIXct</code> format of characters 
containing times, in particular <code>imageTimes</code> and <code>startTime</code>.</p>
</td></tr> 
<tr><td><code id="importExcel_+3A_imagetimesplot">imagetimesPlot</code></td>
<td>
<p>A <code>logical</code> indicating whether a plot of the imaging times against 
the recalculated <code>Time.After.Planting..d.</code>. It aids in checking 
<code>Time.After.Planting..d.</code> and what occurred in imaging the plants.</p>
</td></tr>
<tr><td><code id="importExcel_+3A_...">...</code></td>
<td>
<p>allows for arguments to be passed to <code><a href="#topic+imagetimesPlot">imagetimesPlot</a></code>. However, if 
<code>intervals</code> is passed an error will occur; use timeAfterStart instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the data.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code>, <code><a href="#topic+calcTimes">calcTimes</a></code>, <code><a href="#topic+imagetimesPlot">imagetimesPlot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
raw.0169.dat &lt;- importExcel(file = "0169 analysis_20140603.xlsx", 
                            startTime = "2013-05-23 8:00 AM")

camview.labels &lt;- c("SF0", "SL0", "SU0", "TV0")
names(camview.labels) &lt;- c("RGB_Side_Far_0", "RGB_Side_Lower_0", 
                           "RGB_Side_Upper_0", "RGB_TV_0")
raw.19.dat &lt;- suppressWarnings(importExcel(file = "./data/raw19datarow.csv",
                                           cartId = "Snapshot.ID.Tags",
                                           startTime = "06/10/2017 0:00 AM",
                                           timeFormat = "%d/%m/%Y %H:M", 
                                           labsCamerasViews = camview.labels, 
                                           imagetimesPlot = FALSE))

## End(Not run)</code></pre>

<hr>
<h2 id='intervalGRaverage'>Calculates the growth rates for a specified time interval by taking weighted averages of growth rates for times within the interval</h2><span id='topic+intervalGRaverage'></span>

<h3>Description</h3>

<p>Using previously calculated growth rates over time, calculates 
the Absolute Growth Rates for a specified interval 
using the weighted averages of AGRs for each time point in the 
interval (AGR) and the Relative Growth Rates for a specified 
interval using the weighted geometric means of RGRs for each time 
point in the interval (RGR).</p>


<h3>Usage</h3>

<pre><code class='language-R'>intervalGRaverage(responses, individuals = "Snapshot.ID.Tag", 
                  which.rates = c("AGR","RGR"), suffices.rates=c("AGR","RGR"), 
                  start.time, end.time, times.factor = "Days", suffix.interval, 
                  data, sep=".", na.rm=TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intervalGRaverage_+3A_responses">responses</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the names of the 
<code>responses</code> for which there are columns 
in <code>data</code> that contain the growth rates that are to be 
averaged. The names of the growth rates should have 
either <code>AGR</code> or <code>RGR</code> appended to the 
<code>responses</code> names.</p>
</td></tr>
<tr><td><code id="intervalGRaverage_+3A_individuals">individuals</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name(s) of the 
<code>factor</code>(s) that define the subsets of the <code>data</code> 
for which each subset corresponds to the <code>responses</code> 
for an individual.</p>
</td></tr>
<tr><td><code id="intervalGRaverage_+3A_which.rates">which.rates</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the growth rates that are 
to be averaged to obtain growth rates for an interval. 
It should be a combination <code>"AGR"</code> and <code>"RGR"</code>.</p>
</td></tr>
<tr><td><code id="intervalGRaverage_+3A_suffices.rates">suffices.rates</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the suffices to be 
appended to <code>response</code> to form the names of the columns 
containing the calculated the growth rates and in which growth 
rates are to be stored. Their elements will be matched with 
those of <code>which.rates</code>.</p>
</td></tr>
<tr><td><code id="intervalGRaverage_+3A_start.time">start.time</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the times,
in terms of levels of <code>times.factor</code>, that will give a 
single value for each <code>Snapshot.ID.Tag</code> and that will 
be taken as the observation at the start of the interval for 
which the growth rate is to be calculated.</p>
</td></tr>
<tr><td><code id="intervalGRaverage_+3A_end.time">end.time</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the times, 
in terms of levels of <code>times.factor</code>, that will give a 
single value for each <code>Snapshot.ID.Tag</code> and that will be 
taken as the observation at the end of the interval for which 
the growth rate is to be calculated.</p>
</td></tr>
<tr><td><code id="intervalGRaverage_+3A_times.factor">times.factor</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of the column in 
<code>data</code> containing the factor for times at which the data was 
collected. Its levels will be used in calculating growth rates and 
should be numeric values stored as characters.</p>
</td></tr>
<tr><td><code id="intervalGRaverage_+3A_suffix.interval">suffix.interval</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the suffix to be 
appended to <code>response</code>.<code>suffices.rates</code> to form the 
names of the columns containing the calculated the growth rates.</p>
</td></tr>
<tr><td><code id="intervalGRaverage_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the columns from which the 
growth rates are to be calculated.</p>
</td></tr>
<tr><td><code id="intervalGRaverage_+3A_sep">sep</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the separator to use when the 
levels of <code>individuals</code> are combined. This is needed to avoid 
using a <code><a href="base.html#topic+character">character</a></code> that occurs in a factor to delimit 
levels when the levels of <code>individuals</code> are combined to 
identify subsets.</p>
</td></tr>
<tr><td><code id="intervalGRaverage_+3A_na.rm">na.rm</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether <code>NA</code> values should be 
stripped before the calculation of weighted means proceeds.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>AGR</code> for an interval is calculated as the weighted mean of the 
AGRs for times within the interval. The RGR is calculated as the weighted 
geometric mean of the RGRs for times within the interval; in fact the exponential is taken of the weighted means of the logs of the RGRs. The weights are 
obtained from the <code>times.factor</code>. They are taken as the sum of half the time subintervals before and after each time, except for the end points; the end points are taken to be the subintervals at the start and end of the interval.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> with the growth rates. 
The name of each column is the concatenation of (i) one of 
<code>responses</code>, (ii) one of <code>AGR</code>, <code>PGR</code> or <code>RGR</code>,
or the appropriate element of <code>suffices.rates</code>, and (iii) 
<code>suffix.interval</code>, the three components being separated by 
full stops.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+intervalGRdiff">intervalGRdiff</a></code>, <code><a href="#topic+intervalWUI">intervalWUI</a></code>, <code><a href="#topic+splitValueCalculate">splitValueCalculate</a></code>, <code><a href="#topic+getDates">getDates</a></code>, <code><a href="#topic+GrowthRates">GrowthRates</a></code>, <code><a href="#topic+splitSplines">splitSplines</a></code>, <code><a href="#topic+splitContGRdiff">splitContGRdiff</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(exampleData)
longi.dat &lt;- splitSplines(longi.dat, response="Area", x="xDays", 
                          INDICES = "Snapshot.ID.Tag", 
                          df = 4, deriv=1, suffices.deriv="AGRdv", RGR="RGRdv")
Area.smooth.GR &lt;- intervalGRaverage("Area.smooth", which.rates = c("AGR","RGR"), 
                                    suffices.rates = c("AGRdv","RGRdv"), 
                                    start.time = 31, end.time = 35, 
                                    suffix.interval = "31to35",
                                    data = longi.dat)
</code></pre>

<hr>
<h2 id='intervalGRdiff'>Calculates the growth rates for a specified time interval</h2><span id='topic+intervalGRdiff'></span>

<h3>Description</h3>

<p>Using the values of the responses, calculates the specified 
combination of the Absolute Growth Rates 
using differences (AGR), the Proportionate Growth Rates (PGR) 
and Relative Growth Rates using log differences (RGR) between 
two nominated time points.</p>


<h3>Usage</h3>

<pre><code class='language-R'>intervalGRdiff(responses, individuals = "Snapshot.ID.Tag", 
               which.rates = c("AGR","PGR","RGR"), suffices.rates=NULL, 
               times.factor = "Days", start.times, end.times, suffix.interval, 
               data)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intervalGRdiff_+3A_responses">responses</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the names of the columns in 
<code>data</code> from which the growth rates are to be  calculated.</p>
</td></tr>
<tr><td><code id="intervalGRdiff_+3A_individuals">individuals</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name(s) of the 
<code>factor</code>(s) that define the subsets of the <code>data</code> 
for which each subset corresponds to the <code>responses</code> 
for an individual.</p>
</td></tr>
<tr><td><code id="intervalGRdiff_+3A_which.rates">which.rates</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the growth rates that are 
to be calculated. It should be a combination 
<code>"AGR"</code>, <code>"PGR"</code> and <code>"RGR"</code>.</p>
</td></tr>
<tr><td><code id="intervalGRdiff_+3A_suffices.rates">suffices.rates</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the characters to be 
appended to the names of the responses in constructing the 
names of the columns containing the calculated growth rates.            
The order of the suffices in <code>suffices.rates</code> should 
correspond to the order of the elements of 
<code>which.rates</code>.</p>
</td></tr>
<tr><td><code id="intervalGRdiff_+3A_times.factor">times.factor</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of the column in 
<code>data</code> containing the factor for times at which the data was 
collected. Its levels will be used in calculating growth rates and 
should be numeric values stored as characters.</p>
</td></tr>
<tr><td><code id="intervalGRdiff_+3A_start.times">start.times</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the times,
in terms of levels of <code>times.factor</code>, that will give a 
single value for each <code>Snapshot.ID.Tag</code> and that will 
be taken as the observation at the start of the interval for 
which the growth rate is to be calculated.</p>
</td></tr>
<tr><td><code id="intervalGRdiff_+3A_end.times">end.times</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the times, 
in terms of levels of <code>times.factor</code>, that will give a 
single value for each <code>Snapshot.ID.Tag</code> and that will be 
taken as the observation at the end of the interval for which 
the growth rate is to be calculated.</p>
</td></tr>
<tr><td><code id="intervalGRdiff_+3A_suffix.interval">suffix.interval</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the suffix to be 
appended to <code>response</code> to form the names of the columns 
containing the calculated the growth rates.</p>
</td></tr>
<tr><td><code id="intervalGRdiff_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the column from which the 
growth rates are to be calculated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>AGR</code> is calculated as the difference between the values of 
<code>response</code> at the <code>end.times</code>  and <code>start.times</code> divided by the 
difference between <code>end.times</code>  and <code>start.times</code>. 
The PGR is calculated as the ratio of <code>response</code> at the <code>end.times</code> 
to that at <code>start.times</code> and the ratio raised to the power of the 
reciprocal of the difference between <code>end.times</code>  and <code>start.times</code>. 
The <code>RGR</code> is calculated as the <code>log</code> of the PGR and so is equal to 
the difference between the logarithms of <code>response</code> 
at the <code>end.times</code>  and <code>start.times</code> divided by the difference 
between <code>end.times</code>  and <code>start.times</code>.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> with the growth rates. 
The name of each column is the concatenation of (i) one of 
<code>responses</code>, (ii) one of <code>AGR</code>, <code>PGR</code> or <code>RGR</code>,
or the appropriate element of <code>suffices.rates</code>, and (iii) 
<code>suffix.interval</code>, the three components being separated by 
full stops.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+intervalGRaverage">intervalGRaverage</a></code>, <code><a href="#topic+intervalWUI">intervalWUI</a></code>,  <code><a href="#topic+getDates">getDates</a></code>, <code><a href="#topic+GrowthRates">GrowthRates</a></code>, <code><a href="#topic+splitSplines">splitSplines</a></code>, <code><a href="#topic+splitContGRdiff">splitContGRdiff</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(exampleData)
Area.smooth.GR &lt;- intervalGRdiff("Area.smooth", which.rates = c("AGR","RGR"), 
                                 start.times = 31, end.times = 35,
                                 suffix.interval = "31to35",
                                 data = longi.dat)
</code></pre>

<hr>
<h2 id='intervalPVA'>Selects a subset of variables observed within a specified time interval using Principal Variable Analysis (PVA)</h2><span id='topic+intervalPVA'></span>

<h3>Description</h3>

<p>Principal Variable Analysis (PVA) (Cummings, 2007) selects a subset 
from a set of the variables such that the variables in the subset are as 
uncorrelated as possible, in an effort to ensure that all aspects of the variation 
in the data are covered. Here, all observations in a specified time interval are 
used for calculation the correlations on which the selection is based.</p>


<h3>Usage</h3>

<pre><code class='language-R'>intervalPVA(responses, data, times.factor = "Days", start.time, end.time, 
            nvarselect = NULL, p.variance = 1, include = NULL, 
            plot = TRUE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intervalPVA_+3A_responses">responses</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the names of the columns in 
<code>data</code> from which the variables are to be selected.</p>
</td></tr>
<tr><td><code id="intervalPVA_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the columns of variables from which the 
selection is to be made.</p>
</td></tr>
<tr><td><code id="intervalPVA_+3A_times.factor">times.factor</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of the column in 
<code>data</code> containing the factor for times at which the data was 
collected. Its levels will be used to identify the subset and 
should be numeric values stored as characters.</p>
</td></tr>
<tr><td><code id="intervalPVA_+3A_start.time">start.time</code></td>
<td>
<p>A <code>numeric</code> giving the time,
in terms of a level of <code>times.factor</code>, at which the time interval 
begins; observations at this time and up to and including <code>end.time</code>
will be included.</p>
</td></tr>
<tr><td><code id="intervalPVA_+3A_end.time">end.time</code></td>
<td>
<p>A <code>numeric</code> giving the time,
in terms of levels of <code>times.factor</code>, at the end of the interval; 
observations after this time will not be included.</p>
</td></tr>
<tr><td><code id="intervalPVA_+3A_nvarselect">nvarselect</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> specifying the number of variables to be selected, 
which includes those listed in <code>include</code>. If <code>nvarselect = 1</code>, as 
many variables are selected as is need to satisfy <code>p.variance</code>.</p>
</td></tr>
<tr><td><code id="intervalPVA_+3A_p.variance">p.variance</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> specifying the minimum proportion of the variance 
that the selected variables must account for,</p>
</td></tr>
<tr><td><code id="intervalPVA_+3A_include">include</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the names of the columns in 
<code>data</code> for the variables whose selection is mandatory.</p>
</td></tr>
<tr><td><code id="intervalPVA_+3A_plot">plot</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether a plot of the cumulative proportion 
of the variance explained is to be produced.</p>
</td></tr>
<tr><td><code id="intervalPVA_+3A_...">...</code></td>
<td>
<p>allows passing of arguments to other functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The variable that is most correlated with the other variables is selected first for inclusion. The partial correlation for each of the remaining variables, given the first selected variable, is calculated and the most correlated of these variables is selects for inclusion next. Then the partial correlations are adjust for the second included variables. This process is repeated until the specified criteria have been satisfied. The possibilities are to:
</p>

<ol>
<li><p> the default (<code>nvarselect = NULL</code> and <code>p.variance = 1</code>) select all variables in 
increasing order of amount of information they provide;
</p>
</li>
<li><p> select exactly <code>nvarselect</code> variables;
</p>
</li>
<li><p> select just enough variables, up to a maximum of <code>nvarselect</code> variables, to explain 
at least <code>p.variance</code>*100 per cent of the total variance.
</p>
</li></ol>



<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> giving the results of the variable selection. 
It will contain the columns <code>Variable</code>, <code>Selected</code>, 
<code>h.partial</code>, <code>Added.Propn</code> and <code>Cumulative.Propn</code>.
</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>Cumming, J. A. and D. A. Wood (2007) Dimension reduction via principal variables. <em>Computational Statistics
and Data Analysis</em>, <b>52</b>, 550&ndash;565.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PVA">PVA</a></code>, <code><a href="#topic+rcontrib">rcontrib</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(exampleData)
responses &lt;- c("Area","Area.SV","Area.TV", "Image.Biomass", "Max.Height","Centre.Mass",
               "Density", "Compactness.TV", "Compactness.SV")
results &lt;-  intervalPVA(responses, longi.dat, 
                        start.time = "31", end.time = "31",
                        p.variance=0.9, plot = FALSE)
</code></pre>

<hr>
<h2 id='intervalValueCalculate'>Calculates a single value that is a function of an individual's values for a response over a specified time interval</h2><span id='topic+intervalValueCalculate'></span>

<h3>Description</h3>

<p>Splits the values of a response into subsets corresponding 
individuals and applies a function that calculates a single 
value from each individual's observations during a specified 
time interval. It includes the 
ability to calculate the observation that corresponds to 
the calculated value of the function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>intervalValueCalculate(response, weights=NULL, individuals = "Snapshot.ID.Tag",
                       FUN = "max", which.obs = FALSE, which.levels = NULL, 
                       start.time=NULL, end.time=NULL, times.factor = "Days", 
                       suffix.interval=NULL, data, sep=".", na.rm=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intervalValueCalculate_+3A_response">response</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of the column in 
<code>data</code> from which the values of <code>FUN</code> are to be  calculated.</p>
</td></tr>
<tr><td><code id="intervalValueCalculate_+3A_weights">weights</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of the column in 
<code>data</code> containing the weights to be supplied as <code>w</code> 
to <code>FUN</code>.</p>
</td></tr>
<tr><td><code id="intervalValueCalculate_+3A_individuals">individuals</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name(s) of the 
<code>factor</code>(s) that define the subsets of the <code>data</code> for 
which each subset corresponds to the <code>response</code> value for an 
individual.</p>
</td></tr>
<tr><td><code id="intervalValueCalculate_+3A_fun">FUN</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of the <code>function</code> 
that calculates the value for each subset.</p>
</td></tr>
<tr><td><code id="intervalValueCalculate_+3A_which.obs">which.obs</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether or not to determine 
the observation corresponding to the value of the function, 
instead of the value of the function itself.</p>
</td></tr>
<tr><td><code id="intervalValueCalculate_+3A_which.levels">which.levels</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of the 
<code><a href="base.html#topic+factor">factor</a></code> whose levels are to be identified as 
the level of the observation whose value matches the 
value of the function.</p>
</td></tr>
<tr><td><code id="intervalValueCalculate_+3A_start.time">start.time</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the times, 
in terms of levels of <code>times.factor</code>, that will give a 
single value for each <code>Snapshot.ID.Tag</code> and that will 
be taken as the observation at the start of the interval for 
which the growth rate is to be calculated. If 
<code>start.time</code> is <code>NULL</code>, the interval will start 
with the first observation.</p>
</td></tr>
<tr><td><code id="intervalValueCalculate_+3A_end.time">end.time</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the times,
in terms of levels of <code>times.factor</code>, that will give a 
single value for each <code>Snapshot.ID.Tag</code> and that will be 
taken as the observation at the end of the interval for which 
the growth rate is to be calculated. If <code>end.time</code> is 
<code>NULL</code>, the interval will end with the last observation.</p>
</td></tr>
<tr><td><code id="intervalValueCalculate_+3A_times.factor">times.factor</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of the column in 
<code>data</code> containing the factor for times at which the data was 
collected. Its levels should be numeric values stored as 
characters.</p>
</td></tr>
<tr><td><code id="intervalValueCalculate_+3A_suffix.interval">suffix.interval</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the suffix to be 
appended to <code>response</code> to form the 
name of the column containing the calculated values. If it is
<code>NULL</code> then nothing will be appended.</p>
</td></tr>
<tr><td><code id="intervalValueCalculate_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the column from which the 
function is to be calculated.</p>
</td></tr>
<tr><td><code id="intervalValueCalculate_+3A_na.rm">na.rm</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code>  indicating whether <code>NA</code> values 
should be stripped before the calculation proceeds.</p>
</td></tr>
<tr><td><code id="intervalValueCalculate_+3A_sep">sep</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the separator to use when the 
levels of <code>individuals</code> are combined. This is needed to avoid 
using a <code><a href="base.html#topic+character">character</a></code> that occurs in a factor to delimit 
levels when the levels of <code>individuals</code> are combined to 
identify subsets.</p>
</td></tr>
<tr><td><code id="intervalValueCalculate_+3A_...">...</code></td>
<td>
<p>allows for arguments to be passed to <code>FUN</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code>, with the same number of rows as there are 
<code>individuals</code>, containing a column for the <code>individuals</code>, 
a column with the values of the function for the <code>individuals</code>,
and a column with the values of the <code>times.factor</code>. The name of 
the column with the values of the function will be result of 
concatenating the <code>response</code>, <code>FUN</code> and, if it is not 
<code>NULL</code>,  <code>suffix.interval</code>, each separated by a full stop.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+intervalGRaverage">intervalGRaverage</a></code>, <code><a href="#topic+intervalGRdiff">intervalGRdiff</a></code>, <code><a href="#topic+intervalWUI">intervalWUI</a></code>, <code><a href="#topic+splitValueCalculate">splitValueCalculate</a></code>, <code><a href="#topic+getDates">getDates</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(exampleData)
Area.smooth.max &lt;- intervalValueCalculate("Area.smooth", 
                                          start.time = 31, end.time = 35, 
                                          suffix.interval = "31to35",
                                          data = longi.dat)
</code></pre>

<hr>
<h2 id='intervalWUI'>Calculates water use indices (WUI) over a specified time interval to a 
data.frame</h2><span id='topic+intervalWUI'></span>

<h3>Description</h3>

<p>Calculates the Water Use Index (WUI) between two time points 
for a set of responses.</p>


<h3>Usage</h3>

<pre><code class='language-R'>intervalWUI(responses, water.use = "Water.Use", 
            individuals = "Snapshot.ID.Tag", times.factor = "Days", 
            start.times, end.times, suffix.interval = NULL, 
            data, include.total.water = FALSE, na.rm = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intervalWUI_+3A_responses">responses</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the names of the columns in 
<code>data</code> from which the growth rates are to be calculated.</p>
</td></tr>
<tr><td><code id="intervalWUI_+3A_water.use">water.use</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the names of the column in 
<code>data</code> which contains the water use values.</p>
</td></tr>
<tr><td><code id="intervalWUI_+3A_individuals">individuals</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name(s) of the 
<code>factor</code>(s) that define the subsets of the <code>data</code> for 
which each subset corresponds to the <code>responses</code> for an 
individual.</p>
</td></tr>
<tr><td><code id="intervalWUI_+3A_times.factor">times.factor</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of the column in 
<code>data</code> containing the factor for times at which the data was 
collected. Its levels will be used in identifying the intervals and 
should be numeric values stored as characters.</p>
</td></tr>
<tr><td><code id="intervalWUI_+3A_start.times">start.times</code></td>
<td>
<p>A <code>numeric</code> giving the times, 
in terms of levels of <code>times.factor</code>, that will give a single 
value for each <code>Snapshot.ID.Tag</code> and that will be taken 
as the observation at the start of the interval for which 
the growth rate is to be calculated.</p>
</td></tr>
<tr><td><code id="intervalWUI_+3A_end.times">end.times</code></td>
<td>
<p>A <code>numeric</code> giving the times,
in terms of levels of <code>times.factor</code>, that will give a single 
value for each <code>Snapshot.ID.Tag</code> and that will be taken 
as the observation at the end of the interval for which the 
growth rate is to be calculated.</p>
</td></tr>
<tr><td><code id="intervalWUI_+3A_suffix.interval">suffix.interval</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the suffix to be 
appended to <code>response</code> to form the names of the columns 
containing the calculated the growth rates.</p>
</td></tr>
<tr><td><code id="intervalWUI_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the column from which the 
growth rates are to be calculated.</p>
</td></tr>
<tr><td><code id="intervalWUI_+3A_include.total.water">include.total.water</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether or not to 
include a column in the results for the total of <code>water.use</code> 
for the interval for each individual.</p>
</td></tr>
<tr><td><code id="intervalWUI_+3A_na.rm">na.rm</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code>  indicating whether <code>NA</code> values 
should be stripped before the calculation proceeds.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The WUI is calculated as the difference between the values of a <code>response</code> 
at the <code>end.times</code>  and <code>start.times</code> divided by the sum of the water use  
after <code>start.times</code> until <code>end.times</code>. Thus, the water use up to
<code>start.times</code>  is not included.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the WUIs, the name of each 
column being the concatenation of one of <code>responses</code>,  
<code>WUI</code> and, if not <code>NULL</code>, <code>suffix.interval</code>, the three 
components being separated by a full stop. If the total water is to be 
included, the name of the column will be the concatenation of 
<code>water.use</code>, <code>Total</code> and the suffix, each separated by a full
stop(&lsquo;.&rsquo;).</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+intervalGRaverage">intervalGRaverage</a></code>, <code><a href="#topic+intervalGRdiff">intervalGRdiff</a></code>, <code><a href="#topic+splitValueCalculate">splitValueCalculate</a></code>, <code><a href="#topic+getDates">getDates</a></code>, 
<code><a href="#topic+GrowthRates">GrowthRates</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(exampleData)
Area.smooth.WUI &lt;- intervalWUI("Area", water.use = "Water.Loss", 
                               start.times = 31, end.times = 35, 
                               suffix = "31to35", 
                               data = longi.dat, include.total.water = TRUE)
</code></pre>

<hr>
<h2 id='longiPlot'>Plots longitudinal data from a Lemna Tec Scananalyzer</h2><span id='topic+longiPlot'></span>

<h3>Description</h3>

<p>Produce profile or longitudinal plots of the data from a Lemna Tec 
Scananalyzer using <code>ggplot</code>. A line is drawn for the data for 
each <code>Snapshot.ID.Tag</code> and the plot can be facetted so that a 
grid of plots is produced.</p>


<h3>Usage</h3>

<pre><code class='language-R'>longiPlot(data, x = "xDays+44.5", response = "Area", individuals="Snapshot.ID.Tag", 
          x.title = "Days", y.title = "Area (1000 pixels)", title = NULL, 
          facet.x = "Treatment.1", facet.y =   "Smarthouse", labeller = NULL, 
          colour = "black", colour.column=NULL, colour.values=NULL, 
          alpha = 0.1, ggplotFuncs = NULL, printPlot = TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="longiPlot_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the data to be plotted.</p>
</td></tr>
<tr><td><code id="longiPlot_+3A_x">x</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the variable to be plotted on the x-axis.</p>
</td></tr>
<tr><td><code id="longiPlot_+3A_response">response</code></td>
<td>
<p>A <code>character</code> specifying the response variable that 
is to be plotted on the y-axis.</p>
</td></tr>
<tr><td><code id="longiPlot_+3A_individuals">individuals</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name(s) of the 
<code><a href="base.html#topic+factor">factor</a></code>(s) that define the subsets of the 
<code>data</code> for which each subset corresponds to the 
<code>response</code> values for an individual.</p>
</td></tr>
<tr><td><code id="longiPlot_+3A_x.title">x.title</code></td>
<td>
<p>Title for the x-axis.</p>
</td></tr>
<tr><td><code id="longiPlot_+3A_y.title">y.title</code></td>
<td>
<p>Title for the y-axis.</p>
</td></tr>
<tr><td><code id="longiPlot_+3A_title">title</code></td>
<td>
<p>Title for the plot.</p>
</td></tr>
<tr><td><code id="longiPlot_+3A_facet.x">facet.x</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> giving the variable to be used to 
form subsets to be plotted in separate columns of plots. 
Use <code>"."</code> if a split into columns is not wanted.</p>
</td></tr>
<tr><td><code id="longiPlot_+3A_facet.y">facet.y</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> giving the variable to be used to 
form subsets to be plotted in separate rows of plots.
Use <code>"."</code> if a split into columns is not wanted.</p>
</td></tr>
<tr><td><code id="longiPlot_+3A_labeller">labeller</code></td>
<td>
<p>A <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> <code><a href="base.html#topic+function">function</a></code> for labelling the 
facets of a plot produced using the <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> function. 
For more information see <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>.</p>
</td></tr>
<tr><td><code id="longiPlot_+3A_colour">colour</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> specifying a single colour to use in 
drawing the lines for the profiles. If colouring according to the 
values of a variable is required then use <code>colour.column</code>.</p>
</td></tr>
<tr><td><code id="longiPlot_+3A_colour.column">colour.column</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of a column 
in <code>data</code> over whose values the colours of the lines are to be 
varied. The colours can be specified using <code>colour.values</code> .</p>
</td></tr>
<tr><td><code id="longiPlot_+3A_colour.values">colour.values</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> vector specifying the values of 
the colours to use in drawing the lines for the profiles.  
If this is a named vector, then the values will be matched based 
on the names. If unnamed, values will be matched in order 
(usually alphabetical) with the limits of the scale.</p>
</td></tr>
<tr><td><code id="longiPlot_+3A_alpha">alpha</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> specifying the degrees of transparency to 
be used in plotting. It is a ratio in which the denominator 
specifies the number of points (or line) that must be overplotted 
to give a solid cover.</p>
</td></tr>
<tr><td><code id="longiPlot_+3A_ggplotfuncs">ggplotFuncs</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code>, each element of which contains the 
results of evaluating a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> function. 
It is created by calling the <code><a href="base.html#topic+list">list</a></code> function with 
a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> function call for each element.</p>
</td></tr>
<tr><td><code id="longiPlot_+3A_printplot">printPlot</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether or not to print the 
plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;<code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>&quot;, which can be plotted using 
<code>print</code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>, <code><a href="ggplot2.html#topic+labeller">labeller</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(exampleData)
longiPlot(data = longi.dat, response = "Area.smooth")

plt &lt;- longiPlot(data = longi.dat, response = "Area.smooth", x.title = "DAP",  
                 y.title = "Area.smooth", x="xDays+35.42857143", printPlot=FALSE)
plt &lt;- plt + ggplot2::geom_vline(xintercept=29, linetype="longdash", size=1) +
             ggplot2::scale_x_continuous(breaks=seq(28, 42, by=2)) + 
             ggplot2::scale_y_continuous(limits=c(0,750))
print(plt)

longiPlot(data = longi.dat, response = "Area.smooth", x.title = "DAP",  
          y.title = "Area.smooth", x="xDays+35.42857143", 
          ggplotFuncs = list(ggplot2::geom_vline(xintercept=29, linetype="longdash", 
                                                 size=1), 
                             ggplot2::scale_x_continuous(breaks=seq(28, 42, by=2)), 
                             ggplot2::scale_y_continuous(limits=c(0,750))))
</code></pre>

<hr>
<h2 id='longitudinalPrime'>Selects a set variables to be retained in a data frame of longitudinal data</h2><span id='topic+longitudinalPrime'></span>

<h3>Description</h3>

<p>Forms the prime traits by selecting a subset of the traits in a data.frame of 
imaging data produced by the Lemna Tec Scanalyzer. The imaging traits to be retained 
are specified using the <code>traits</code> and <code>labsCamerasViews</code> arguments. Some imaging 
traits are divided by 10000 to convert them from pixels to kilopixels. 
Also added are factors and explanatory variates that might be of use in an analysis.</p>


<h3>Usage</h3>

<pre><code class='language-R'>longitudinalPrime(data, cartId = "Snapshot.ID.Tag", 
                  imageTimes = "Snapshot.Time.Stamp", 
                  timeAfterStart = "Time.after.Planting..d.",
                  idcolumns = c("Genotype.ID","Treatment.1"), 
                  traits = list(all = c("Area", 
                                        "Boundary.Points.To.Area.Ratio", 
                                        "Caliper.Length", "Compactness", 
                                        "Convex.Hull.Area"), 
                                 side = c("Center.Of.Mass.Y", 
                                          "Max.Dist.Above.Horizon.Line")),
                  labsCamerasViews = list(all = c("SV1", "SV2", "TV"),
                                          side = c("SV1", "SV2")), 
                  smarthouse.lev = NULL, 
                  calcWaterLoss = TRUE, pixelsPERcm)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="longitudinalPrime_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the columns specified by <code>cartId</code>, 
<code>imageTimes</code>, <code>timeAfterStart</code>, <code>idcolumns</code>, <code>traits</code> and 
<code>cameras</code> along with  the following columns: 
</p>
<p>Smarthouse, Lane, Position, Weight.Before, Weight.After, Water.Amount, 
</p>
<p>Projected.Shoot.Area..pixels.
</p>
<p>The defaults for the arguments to <code>longitudinalPrime</code> requires a 
<code><a href="base.html#topic+data.frame">data.frame</a></code> containing the following columns, although not necessarily 
in the order given here:
</p>
<p>Smarthouse, Lane, Position, Weight.Before, Weight.After, Water.Amount, 
</p>
<p>Projected.Shoot.Area..pixels., Area.SV1, Area.SV2, Area.TV, 
</p>
<p>Boundary.Points.To.Area.Ratio.SV1, Boundary.Points.To.Area.Ratio.SV2, 
</p>
<p>Boundary.Points.To.Area.Ratio.TV,  Caliper.Length.SV1, 
</p>
<p>Caliper.Length.SV2, Caliper.Length.TV, 
</p>
<p>Compactness.SV1, Compactness.SV2, Compactness.TV, 
</p>
<p>Convex.Hull.Area.SV1, Convex.Hull.Area.SV2, Convex.Hull.Area.TV, 
</p>
<p>Center.Of.Mass.Y.SV1, Center.Of.Mass.Y.SV2, 
</p>
<p>Max.Dist.Above.Horizon.Line.SV1, Max.Dist.Above.Horizon.Line.SV2.</p>
</td></tr>
<tr><td><code id="longitudinalPrime_+3A_cartid">cartId</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of the column that contains
the unique Id for each cart.</p>
</td></tr>
<tr><td><code id="longitudinalPrime_+3A_imagetimes">imageTimes</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of the column that contains
the time that each cart was imaged.</p>
</td></tr>
<tr><td><code id="longitudinalPrime_+3A_timeafterstart">timeAfterStart</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of the column that 
contains the time after some nominated starting time e.g. the number of days 
after planting.</p>
</td></tr>
<tr><td><code id="longitudinalPrime_+3A_idcolumns">idcolumns</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> vector giving the names of the columns that 
identify differences between the plants or carts e.g. Genotype.ID, 
Treatment.1, Treatment.2.</p>
</td></tr>
<tr><td><code id="longitudinalPrime_+3A_traits">traits</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> or a <code><a href="base.html#topic+list">list</a></code> whose components are  
<code><a href="base.html#topic+character">character</a></code>s. Each <code><a href="base.html#topic+character">character</a></code> gives the names of the 
columns for imaging <code>traits</code> whose values are required for each of the 
camera-view combinations given in the corresponding <code><a href="base.html#topic+list">list</a></code> 
component of <code>labsCamerasViews</code>. If <code>labsCamerasViews</code> or a 
component of <code>labsCamerasViews</code> is <code>NULL</code>, then the contents of 
<code>traits</code> or the coresponding component of <code>traits</code> are merely 
treated as the names of columns to be retained.</p>
</td></tr>
<tr><td><code id="longitudinalPrime_+3A_labscamerasviews">labsCamerasViews</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> or a <code><a href="base.html#topic+list">list</a></code> whose components are  
<code><a href="base.html#topic+character">character</a></code>s. Each <code><a href="base.html#topic+character">character</a></code> gives the labels of the  
camera-view combinations for which is required values of each of the imaging 
<code>traits</code> in the corresponding <code><a href="base.html#topic+character">character</a></code> of <code>traits</code>. 
It is assumed that the camera-view labels are appended to the trait names and 
separated from the trait names by a full stop (.). If <code>labsCamerasViews</code> 
or a component of <code>labsCamerasViews</code> is <code>NULL</code>, then the contents 
of the <code>traits</code> or the coresponding component of <code>traits</code> are 
merely treated as the names of columns to be retained.</p>
</td></tr>
<tr><td><code id="longitudinalPrime_+3A_smarthouse.lev">smarthouse.lev</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> vector giving the levels to use 
for the Smarthouse factor. If <code>NULL</code> then the unique values in Smarthouse 
will be used.</p>
</td></tr>
<tr><td><code id="longitudinalPrime_+3A_calcwaterloss">calcWaterLoss</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether to calculate the Water.Loss. If it is 
<code>FALSE</code>, <code>Water.Before</code>, <code>Water.After</code> and <code>Water.Amount</code> will not be in 
the returned <code><a href="base.html#topic+data.frame">data.frame</a></code>. They can be copied across by listing them in a component 
of <code>traits</code> and set the corresponding component of <code>cameras</code> to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="longitudinalPrime_+3A_pixelspercm">pixelsPERcm</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the number of pixels per cm 
for the images. <em>No longer used.</em></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The columns are copied from data, except for those columns in the list under <b>Value</b> that have &lsquo;(calculated)&rsquo; appended.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the columns specified by <code>cartId</code>, 
<code>imageTimes</code>, <code>timeAfterStart</code>, <code>idcolumns</code>, <code>traits</code> and 
<code>cameras</code>. The defaults will result in the following columns:
</p>

<ol>
<li><p> Smarthouse: factor with levels for the Smarthouse
</p>
</li>
<li><p> Lane: factor for lane number in a smarthouse
</p>
</li>
<li><p> Position: factor for east/west position in a lane
</p>
</li>
<li><p> Days: factor for the number of Days After Planting (DAP)
</p>
</li>
<li> <p><code>cartId</code>: unique code for each cart 
</p>
</li>
<li> <p><code>imageTimes</code>: time at which an image was taken in POSIXct format
</p>
</li>
<li><p> Reps: factor indexing the replicates for each combination of the factors in <code>idcolumns</code> (calculated)
</p>
</li>
<li><p> xPosn: numeric for the Positions within a Lane (calculated)
</p>
</li>
<li><p> Hour: hour of the day, to 2 decimal places, at which the image was taken (calculated)
</p>
</li>
<li><p> xDays: numeric for the DAP that is centred by subtracting the mean of the unique days (calculated)
</p>
</li>
<li> <p><code>idcolumns</code>: the columns listed in <code>idcolumns</code> that have been converted to factors
</p>
</li>
<li><p> Weight.Before: weight of the pot before watering (only if <code>calcWaterLoss</code> is <code>TRUE</code>)
</p>
</li>
<li><p> Weight.After: weight of the pot after watering (only if <code>calcWaterLoss</code> is <code>TRUE</code>)
</p>
</li>
<li><p> Water.Amount: the weight of the water added (= Water.After - Water.Before)  (calculated)
</p>
</li>
<li><p> Water.Loss: the difference between Weight.Before for the current imaging and the Weight.After for the previous imaging (calculated unless <code>calcWaterLoss</code> is <code>FALSE</code>)
</p>
</li>
<li><p> Area: the Projected.Shoot.Area..pixels. divided by 1000 (calculated)
</p>
</li>
<li><p> Area.SV1: the Projected.Shoot.Area from Side View 1 divided by 1000 (calculated)
</p>
</li>
<li><p> Area.SV2: the Projected.Shoot.Area from Side View 2 divided by 1000 (calculated)
</p>
</li>
<li><p> Area.TV: the Projected.Shoot.Area from Top View divided by 1000 (calculated)
</p>
</li>
<li><p> Boundary.To.Area.Ratio.SV1 
</p>
</li>
<li><p> Boundary.To.Area.Ratio.SV2 
</p>
</li>
<li><p> Boundary.To.Area.Ratio.TV 
</p>
</li>
<li><p> Caliper.Length.SV1 
</p>
</li>
<li><p> Caliper.Length.SV2 
</p>
</li>
<li><p> Caliper.Length.TV
</p>
</li>
<li><p> Compactness.SV1 from Side View 1
</p>
</li>
<li><p> Compactness.SV2 from Side View 2
</p>
</li>
<li><p> Compactness.TV: from Top View 
</p>
</li>
<li><p> Convex.Hull.Area.SV1: area of Side View 1 Convex Hull divided by 1000 (calculated)
</p>
</li>
<li><p> Convex.Hull.Area.SV2: area of Side View 2 Convex Hull divided by 1000 (calculated)
</p>
</li>
<li><p> Convex.Hull.TV: Convex.Hull.Area.TV divided by 1000 (calculated)
</p>
</li>
<li><p> Center.Of.Mass.Y.SV1: Centre of Mass from Side View 1
</p>
</li>
<li><p> Center.Of.Mass.Y.SV2: Centre of Mass from Side View 2
</p>
</li>
<li><p> Max.Dist.Above.Horizon.Line.SV1: the Max.Dist.Above.Horizon.Line.SV1 converted to cm using <code>pixelsPERcm</code> (calculated)
</p>
</li>
<li><p> Max.Dist.Above.Horizon.Line.SV2: the Max.Dist.Above.Horizon.Line.SV2 converted to cm using <code>pixelsPERcm</code> (calculated)
</p>
</li></ol>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(exampleData)
longiPrime.dat &lt;- longitudinalPrime(data=raw.dat, smarthouse.lev=1)

longiPrime.dat &lt;- longitudinalPrime(data=raw.dat, smarthouse.lev=1, 
                                    traits = list(a = "Area", c = "Compactness"),
                                    labsCamerasViews = list(all = c("SV1", "SV2", "TV"), 
                                                            t = "TV"))

longiPrime.dat &lt;- longitudinalPrime(data=raw.dat, smarthouse.lev=1, 
                                    traits = c("Area.SV1", "Area.SV2", "Area.TV", 
                                               "Compactness.TV"),
                                    labsCamerasViews = NULL)

longiPrime.dat &lt;- longitudinalPrime(data=raw.dat, smarthouse.lev=1, 
                                    calcWaterLoss = FALSE, 
                                    traits = list(img = c("Area", "Compactness"), 
                                                  H20 = c("Weight.Before","Weight.After",
                                                          "Water.Amount")),
                                    labsCamerasViews = list(all = c("SV1", "SV2", "TV"), 
                                                            H2O = NULL))
</code></pre>

<hr>
<h2 id='probeDF'>Compares, for a set of specified values of df, a response and the smooths of it, possibly along with growth rates calculated from the smooths</h2><span id='topic+probeDF'></span>

<h3>Description</h3>

<p>Takes a <code>response</code> and, for each <code>individual</code>, uses 
<code><a href="#topic+splitSplines">splitSplines</a></code> to smooth its values for each individual 
using  the degrees of freedom values in <code>df</code>. 
Provided <code>get.rates</code> is <code>TRUE</code>,
both the Absolute Growth Rates (AGR) and the Relative Growth Rates (RGR) 
are calculated for each smooth, either using differences or first 
derivatives. A combination of the unsmoothed and smoothed 
values, as well as the AGR and RGR, can be plotted for each value in 
<code>df</code>. Note that the arguments that modify the plots apply to all 
plots that are produced. The handling of missing values is controlled 
via <code>na.x.action</code> and <code>na.y.action</code></p>


<h3>Usage</h3>

<pre><code class='language-R'>probeDF(data, response = "Area", xname="xDays", individuals="Snapshot.ID.Tag", 
        na.x.action="exclude", na.y.action = "exclude", 
        df, smoothing.scale = "identity", correctBoundaries = FALSE, 
        get.rates = TRUE, rates.method="differences", 
        times.factor = "Days", x = NULL, x.title = NULL, 
        facet.x = "Treatment.1", facet.y =   "Smarthouse", labeller = NULL, 
        colour = "black", colour.column=NULL, colour.values=NULL, alpha = 0.1, 
        which.traits = c("response", "AGR", "RGR"),
        which.plots = "smoothedonly", 
        deviations.boxplots = "none", 
        ggplotFuncs = NULL, 
        ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="probeDF_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the data.</p>
</td></tr>
<tr><td><code id="probeDF_+3A_response">response</code></td>
<td>
<p>A <code>character</code> specifying the response variable to be 
supplied to <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code> and that 
is to be plotted on the y-axis.</p>
</td></tr>
<tr><td><code id="probeDF_+3A_xname">xname</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of the
<code><a href="base.html#topic+numeric">numeric</a></code> that contains the values of the predictor 
variable to be supplied to <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>.</p>
</td></tr>
<tr><td><code id="probeDF_+3A_individuals">individuals</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name(s) of the 
<code><a href="base.html#topic+factor">factor</a></code>(s) that define the subsets of the <code>data</code> 
for which each subset corresponds to the <code>response</code> values for 
an individual.</p>
</td></tr>
<tr><td><code id="probeDF_+3A_na.x.action">na.x.action</code></td>
<td>
<p>A <code>character</code> string that specifies the action to 
be taken when values of <code>x</code> are <code>NA</code>. The possible 
values are <code>fail</code>, <code>exclude</code> or <code>omit</code>. 
For <code>exclude</code> and <code>omit</code>, predictions and derivatives 
will only be obtained for nonmissing values of <code>x</code>. 
The difference between these two codes is that for <code>exclude</code> the returned 
<code>data.frame</code> will have as many rows as <code>data</code>, the 
missing values have been incorporated. </p>
</td></tr>
<tr><td><code id="probeDF_+3A_na.y.action">na.y.action</code></td>
<td>
<p>A <code>character</code> string that specifies the action to 
be taken when values of <code>y</code>, or the <code>response</code>, are 
<code>NA</code>.  The possible values are <code>fail</code>, <code>exclude</code>, 
<code>omit</code>, <code>allx</code>, <code>trimx</code>, <code>ltrimx</code> or 
<code>rtrimx</code>. For  all options, except <code>fail</code>, missing 
values in <code>y</code> will be removed before smoothing. 
For <code>exclude</code> and <code>omit</code>, predictions 
and derivatives will be obtained only for nonmissing values of 
<code>x</code> that do not have missing <code>y</code> values. Again, the 
difference between these two is that, only for <code>exclude</code> 
will the missing values be incorporated into the 
returned <code>data.frame</code>. For <code>allx</code>, predictions and 
derivatives will be obtained for all nonmissing <code>x</code>. 
For <code>trimx</code>, they will be obtained for all nonmissing 
<code>x</code> between the first and last nonmissing <code>y</code> values 
that have been ordered for <code>x</code>; for <code>ltrimx</code> and 
<code>utrimx</code> either the lower or upper missing <code>y</code> 
values, respectively, are trimmed.</p>
</td></tr>
<tr><td><code id="probeDF_+3A_df">df</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> specifying the set of degrees of freedom to 
be probed.</p>
</td></tr>
<tr><td><code id="probeDF_+3A_smoothing.scale">smoothing.scale</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the scale on which smoothing 
is to be performed. The two possibilites are <code>"identity"</code>, for directly 
smoothing the observed <code>response</code>, and <code>"logarithmic"</code>, for smoothing the 
<code>log</code>-transformed <code>response</code>.</p>
</td></tr>
<tr><td><code id="probeDF_+3A_correctboundaries">correctBoundaries</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether the fitted 
spline values are to have the method of Huang (2001) applied 
to them to correct for estimation bias at the end-points. Note that 
if <code>rates.method</code> is set to <code>"derivatives"</code> then it is not 
possible to have <code>correctBoundaries</code> set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="probeDF_+3A_get.rates">get.rates</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> specifying whether or not the growth 
rates (AGR and RGR) are to be computed and stored.</p>
</td></tr>
<tr><td><code id="probeDF_+3A_rates.method">rates.method</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> specifying the method to use in 
calculating the growth rates. The two possibilities are 
<code>"differences"</code> and <code>"derivates"</code>.</p>
</td></tr>
<tr><td><code id="probeDF_+3A_times.factor">times.factor</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of the column in 
<code>data</code> containing the factor for times at which the data was 
collected. Its levels will be used in calculating growth rates and 
should be numeric values stored as characters.</p>
</td></tr>
<tr><td><code id="probeDF_+3A_x">x</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the variable to be plotted on the 
x-axis. If <code>x</code> is <code>NULL</code> then <code>xname</code> is used.</p>
</td></tr>
<tr><td><code id="probeDF_+3A_x.title">x.title</code></td>
<td>
<p>Title for the x-axis. If <code>NULL</code> then set to <code>times.factor</code>.</p>
</td></tr>
<tr><td><code id="probeDF_+3A_facet.x">facet.x</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> giving the variable to be used to 
form subsets to be plotted in separate columns of plots. 
Use <code>"."</code> if a split into columns is not wanted.</p>
</td></tr>
<tr><td><code id="probeDF_+3A_facet.y">facet.y</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> giving the variable to be used to 
form subsets to be plotted in separate rows of plots.
Use <code>"."</code> if a split into columns is not wanted.</p>
</td></tr>
<tr><td><code id="probeDF_+3A_labeller">labeller</code></td>
<td>
<p>A <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> <code><a href="base.html#topic+function">function</a></code> for labelling the 
facets of a plot produced using the <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> function. 
For more information see <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>.</p>
</td></tr>
<tr><td><code id="probeDF_+3A_colour">colour</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> specifying a single colour to use in 
drawing the lines for the profiles. If colouring according to the 
values of a variable is required then use <code>colour.column</code>.</p>
</td></tr>
<tr><td><code id="probeDF_+3A_colour.column">colour.column</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of a column 
in <code>data</code> over whose values the colours of the lines are to be 
varied. The colours can be specified using <code>colour.values</code> .</p>
</td></tr>
<tr><td><code id="probeDF_+3A_colour.values">colour.values</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> vector specifying the values of 
the colours to use in drawing the lines for the profiles.  
If this is a named vector, then the values will be matched based 
on the names. If unnamed, values will be matched in order 
(usually alphabetical) with the limits of the scale.</p>
</td></tr>
<tr><td><code id="probeDF_+3A_alpha">alpha</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> specifying the degrees of transparency to 
be used in plotting. It is a ratio in which the denominator 
specifies the number of points (or line) that must be overplotted 
to give a solid cover.</p>
</td></tr>
<tr><td><code id="probeDF_+3A_which.traits">which.traits</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the traits that are to be 
produced. One of more of <code>response</code>, <code>AGR</code> and <code>RGR</code>. 
If <code>all</code>, all three traits are produced. The unsmoothed growth 
rates are not calculated if only smoothed plots are requested.</p>
</td></tr>
<tr><td><code id="probeDF_+3A_which.plots">which.plots</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the plots that are to be 
produced. If <code>none</code>, no plots are produced. If <code>smoothedonly</code>, 
plots of the smoothed traits are plotted. If <code>bothseparatetly</code>, 
plots of the unsmoothed trait followed by the smoothed trait are 
produced for each trait. If <code>compare</code>, a combined plot of the 
unsmoothed trait and the smoothed trait is produced for each value 
of <code>df</code>.</p>
</td></tr>
<tr><td><code id="probeDF_+3A_deviations.boxplots">deviations.boxplots</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> specifying whether boxplots of 
the <code>absolute</code> and/or <code>relative</code> deviations of the values of a 
trait from  their smoothed values are to be produced (observed - smoothed). If <code>none</code>, 
no plots are produced. The argument <code>which.traits</code> controls 
the traits for which boxplots are produced.</p>
</td></tr>
<tr><td><code id="probeDF_+3A_ggplotfuncs">ggplotFuncs</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code>, each element of which contains the 
results of evaluating a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> function. 
It is created by calling the <code><a href="base.html#topic+list">list</a></code> function with 
a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> function call for each element. Note that 
these functions are applied to all three plots produced.</p>
</td></tr>
<tr><td><code id="probeDF_+3A_...">...</code></td>
<td>
<p>allows passing of arguments to <code><a href="#topic+longiPlot">longiPlot</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing <code>individuals</code>, 
<code>times.factor</code>, <code>facet.x</code>, <code>facet.y</code>, <code>xname</code>, 
<code>response</code>, and, for each <code>df</code>, the smoothed 
response, the AGR and the RGR. It is returned invisibly. The names of 
the new data are constructed by joining elements separated by full 
stops (<code>.</code>). In all cases, the last element is the value of 
<code>df</code>. For the smoothed response, the other elements are 
<code>response</code> and <code>"smooth"</code>; for AGR and RGR, the other elements 
are the name of the smoothed response and either <code>"AGR"</code> or 
<code>"RGR"</code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+splitSplines">splitSplines</a></code>, <code><a href="#topic+splitContGRdiff">splitContGRdiff</a></code>, <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>, <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(exampleData)
vline &lt;- list(ggplot2::geom_vline(xintercept=20, linetype="longdash", size=1),
              ggplot2::scale_x_continuous(breaks=seq(12, 36, by=2)))
probeDF(data = longi.dat, response = "Area", df = c(4,7), x="xDays+24.16666667", 
        ggplotFuncs=vline)
</code></pre>

<hr>
<h2 id='PVA'>Selects a subset of variables using Principal Variable Analysis (PVA)</h2><span id='topic+PVA'></span>

<h3>Description</h3>

<p>Principal Variable Analysis (PVA) (Cummings, 2007) selects a subset 
from a set of the variables such that the variables in the subset are as 
uncorrelated as possible, in an effort to ensure that all aspects of the 
variation in the data are covered. </p>


<h3>Usage</h3>

<pre><code class='language-R'>PVA(responses, data, nvarselect = NULL, p.variance = 1, include = NULL, 
    plot = TRUE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PVA_+3A_responses">responses</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the names of the columns in 
<code>data</code> from which the variables are to be selected.</p>
</td></tr>
<tr><td><code id="PVA_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the columns of variables from which the 
selection is to be made.</p>
</td></tr>
<tr><td><code id="PVA_+3A_nvarselect">nvarselect</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> specifying the number of variables to be selected, 
which includes those listed in <code>include</code>. If <code>nvarselect = 1</code>, as 
many variables are selected as is need to satisfy <code>p.variance</code>.</p>
</td></tr>
<tr><td><code id="PVA_+3A_p.variance">p.variance</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> specifying the minimum proportion of the variance 
that the selected variables must account for,</p>
</td></tr>
<tr><td><code id="PVA_+3A_include">include</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the names of the columns in 
<code>data</code> for the variables whose selection is mandatory.</p>
</td></tr>
<tr><td><code id="PVA_+3A_plot">plot</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether a plot of the cumulative proportion 
of the variance explained is to be produced.</p>
</td></tr>
<tr><td><code id="PVA_+3A_...">...</code></td>
<td>
<p>allows passing of arguments to other functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The variable that is most correlated with the other variables is selected first for inclusion. The partial correlation for each of the remaining variables, given the first selected variable, is calculated and the most correlated of these variables is selects for inclusion next. Then the partial correlations are adjust for the second included variables. This process is repeated until the specified criteria have been satisfied. The possibilities are:
</p>

<ol>
<li><p> the default (<code>nvarselect = NULL</code> and <code>p.variance = 1</code>), which selects all 
variables in increasing order of amount of information they provide;
</p>
</li>
<li><p> to select exactly <code>nvarselect</code> variables;
</p>
</li>
<li><p> to select just enough variables, up to a maximum of <code>nvarselect</code> variables, to explain 
at least <code>p.variance</code>*100 per cent of the total variance.
</p>
</li></ol>



<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> giving the results of the variable selection. 
It will contain the columns <code>Variable</code>, <code>Selected</code>, 
<code>h.partial</code>, <code>Added.Propn</code> and <code>Cumulative.Propn</code>.
</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>Cumming, J. A. and D. A. Wood (2007) Dimension reduction via principal variables. <em>Computational Statistics
and Data Analysis</em>, <b>52</b>, 550&ndash;565.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+intervalPVA">intervalPVA</a></code>, <code><a href="#topic+rcontrib">rcontrib</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(exampleData)
responses &lt;- c("Area","Area.SV","Area.TV", "Image.Biomass", "Max.Height","Centre.Mass",
               "Density", "Compactness.TV", "Compactness.SV")
results &lt;-  PVA(responses, longi.dat, p.variance=0.9, plot = FALSE)
</code></pre>

<hr>
<h2 id='rcontrib'>Computes a measure of how correlated each variable in a set is with the other variable, 
conditional on a nominated subset of them</h2><span id='topic+rcontrib'></span>

<h3>Description</h3>

<p>A measure of how correlated a variable is with those in a set is given by the 
square root of the sum of squares of the correlation coefficients between the 
variables and the other variables in the set (Cummings, 2007). Here, the partial 
correlation  between the subset of the variables listed in <code>response</code> that 
are not listed in <code>include</code> is calculated from the partial correlation matrix 
for the subset, adjusting for those variables in <code>include</code>. This is useful 
for manually deciding which of the variables not in <code>include</code> should next be 
added to it.</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcontrib(responses, data, include = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcontrib_+3A_responses">responses</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the names of the columns in 
<code>data</code> from which the correlation measure is to be calculated.</p>
</td></tr>
<tr><td><code id="rcontrib_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the columns of variables from which the 
correlation measure is to be calculated.</p>
</td></tr>
<tr><td><code id="rcontrib_+3A_include">include</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the names of the columns in 
<code>data</code> for the variables for which other variables are to be adjusted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the correlation measures.
</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>Cumming, J. A. and D. A. Wood (2007) Dimension reduction via principal variables. <em>Computational Statistics
and Data Analysis</em>, <b>52</b>, 550&ndash;565.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PVA">PVA</a></code>, <code><a href="#topic+intervalPVA">intervalPVA</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(exampleData)
responses &lt;- c("Area","Area.SV","Area.TV", "Image.Biomass", "Max.Height","Centre.Mass",
               "Density", "Compactness.TV", "Compactness.SV")
h &lt;-  rcontrib(responses, longi.dat, include = "Area")
</code></pre>

<hr>
<h2 id='RiceRaw.dat'>Data for an experiment to investigate a rice germplasm panel</h2><span id='topic+RiceRaw.dat'></span>

<h3>Description</h3>

<p>The data is from an experiment in a Smarthouse in the Plant Accelerator. It is described in Al-Tamimi et al. (2016). It is used in <code><a href="#topic+imageData-package">imageData-package</a></code> as an executable example to illustrate the use of <code>imageData</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(RiceRaw.dat)</code></pre>


<h3>Format</h3>

<p>A data.frame containing 14784 observations on 33 variables.</p>


<h3>Source</h3>

<p>It will be made available on Dryad</p>


<h3>References</h3>

<p>Al-Tamimi, N, Brien, C.J., Oakey, H., Berger, B., Saade, S., Ho, Y. S., Schmockel, S. M., Tester, M. and Negrao, S. (2016) New salinity tolerance loci revealed in rice using high-throughput non-invasive phenotyping. <em>Nature Communications</em>, <b>7</b>, 13342.
</p>

<hr>
<h2 id='splitContGRdiff'>Adds the growth rates calculated continuously over time for subsets 
of a response to a <code>data.frame</code></h2><span id='topic+splitContGRdiff'></span>

<h3>Description</h3>

<p>Uses <code><a href="#topic+AGRdiff">AGRdiff</a></code>, <code><a href="#topic+PGR">PGR</a></code> and 
<code><a href="#topic+RGRdiff">RGRdiff</a></code> to calculate growth rates continuously 
over time for a subset of the values of <code>response</code> and 
stores the results in <code>data</code>. The subsets are those values 
with the same levels combinations of the factors listed in 
<code>INDICES</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitContGRdiff(data, responses, INDICES,
                which.rates = c("AGR","PGR","RGR"), suffices.rates=NULL, 
                times.factor = "Days")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitContGRdiff_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the columns for which 
growth rates are to be calculated.</p>
</td></tr>
<tr><td><code id="splitContGRdiff_+3A_responses">responses</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the names of the columns in 
<code>data</code> for which growth rates are to be calculated.</p>
</td></tr>
<tr><td><code id="splitContGRdiff_+3A_indices">INDICES</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name(s) of the 
<code><a href="base.html#topic+factor">factor</a></code>(s) that define the subsets of <code>response</code> 
for which growth rates are to be calculated continuously. 
If the columns corresponding to 
<code>INDICES</code> are not <code><a href="base.html#topic+factor">factor</a></code>(s) then they will be 
coerced to <code><a href="base.html#topic+factor">factor</a></code>(s). The subsets are formed 
using <code><a href="base.html#topic+by">by</a></code>.</p>
</td></tr>
<tr><td><code id="splitContGRdiff_+3A_which.rates">which.rates</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the growth rates that are 
to be calculated. It should be a combination 
<code>"AGR"</code>, <code>"PGR"</code> and <code>"RGR"</code>.</p>
</td></tr>
<tr><td><code id="splitContGRdiff_+3A_times.factor">times.factor</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of the column in 
<code>data</code> containing the factor for times at which the data was 
collected. Its levels will be used in calculating growth rates and 
should be numeric values stored as characters.</p>
</td></tr>
<tr><td><code id="splitContGRdiff_+3A_suffices.rates">suffices.rates</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the characters to be 
appended to the names of the responses to provide the 
names of the columns containing the calculated growth rates.            
The order of the suffices in <code>suffices.rates</code> should 
correspond to the order of the elements of 
<code>which.rates</code>. If <code>NULL</code>, the values of 
<code>which.rates</code> are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing  <code>data</code> to which has been 
added a column for the differences between the <code>times.factor</code>, 
if it is not already in <code>data</code>, and 
columns with growth rates. The name of the column for <code>times.factor</code> 
differences will be the <code>times.factor</code> with <code>".diff"</code> appended and, 
for each of the growth-rate columns will 
be the value of <code>response</code> with one of <code>".AGR"</code>, <code>".PGR"</code> 
or <code>"RGR"</code> or the corresponding value from <code>suffices.GR</code> 
appended.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitSpline">fitSpline</a></code>, <code><a href="#topic+splitSplines">splitSplines</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(exampleData)
longi.dat &lt;- splitContGRdiff(longi.dat, response="Area.smooth", 
                             INDICES = "Snapshot.ID.Tag", which.rates=c("AGR", "RGR"))
</code></pre>

<hr>
<h2 id='splitSplines'>Adds the fits after fitting a natural cubic smoothing spline to subsets 
of a response to a <code>data.frame</code></h2><span id='topic+splitSplines'></span>

<h3>Description</h3>

<p>Uses <code><a href="#topic+fitSpline">fitSpline</a></code> to fit a spline to a subset of the values 
of <code>response</code> and stores the fitted values in <code>data</code>. 
The subsets are those values with the same levels combinations 
of the factors listed in <code>INDICES</code> and the degrees of 
smoothing is controlled by <code>df</code>. The derivatives
of the fitted spline can also be obtained, as can the Relative 
Growth Rates (RGR).
</p>
<p>By default, <code>smooth.spline</code> will issue an error if there are not 
at least four distinct x-values. On the other hand, 
<code><a href="#topic+fitSpline">fitSpline</a></code> issues a warning and sets all smoothed values 
and derivatives to <code>NA</code>. The handling of missing values in the 
observations is controlled via <code>na.x.action</code> and <code>na.y.action</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitSplines(data, response, x, INDICES, df = NULL, smoothing.scale = "identity", 
             correctBoundaries = FALSE, 
             deriv = NULL, suffices.deriv=NULL, RGR=NULL, AGR=NULL, sep=".", 
             na.x.action="exclude", na.y.action = "exclude", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitSplines_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the column to be smoothed.</p>
</td></tr>
<tr><td><code id="splitSplines_+3A_response">response</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of the column in 
<code>data</code> that is to be smoothed.</p>
</td></tr>
<tr><td><code id="splitSplines_+3A_x">x</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of the column in 
<code>data</code> that contains the values of the predictor variable.</p>
</td></tr>
<tr><td><code id="splitSplines_+3A_indices">INDICES</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name(s) of the 
<code><a href="base.html#topic+factor">factor</a></code>(s) that define the subsets of <code>response</code> 
that are to be smoothed separately. If the columns corresponding to 
<code>INDICES</code> are not <code><a href="base.html#topic+factor">factor</a></code>(s) then they will be 
coerced to <code><a href="base.html#topic+factor">factor</a></code>(s). The subsets are formed 
using <code><a href="base.html#topic+split">split</a></code>.</p>
</td></tr>
<tr><td><code id="splitSplines_+3A_df">df</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> specifying the desired equivalent number of degrees 
of freedom of the smooth (trace of the smoother matrix). Lower values 
result in more smoothing. If <code>df = NULL</code>, ordinary leave-one-out 
cross-validation is used to determine the amount of smooth.</p>
</td></tr>
<tr><td><code id="splitSplines_+3A_smoothing.scale">smoothing.scale</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the scale on which smoothing 
is to be performed. The two possibilites are <code>"identity"</code>, for directly 
smoothing the observed <code>response</code>, and <code>"logarithmic"</code>, for scaling the 
<code>log</code>-transformed <code>response</code>.</p>
</td></tr>
<tr><td><code id="splitSplines_+3A_correctboundaries">correctBoundaries</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether the fitted 
spline values are to have the method of Huang (2001) applied 
to them to correct for estimation bias at the end-points. Note that 
<code>deriv</code> must be <code>NULL</code> for <code>correctBoundaries</code> to be 
set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="splitSplines_+3A_deriv">deriv</code></td>
<td>
<p>A <code>numeric</code> specifying one or more orders of derivatives 
that are required.</p>
</td></tr>
<tr><td><code id="splitSplines_+3A_suffices.deriv">suffices.deriv</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the characters to be 
appended to the names of the derivatives.</p>
</td></tr>
<tr><td><code id="splitSplines_+3A_rgr">RGR</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the character to be appended 
to the smoothed <code>response</code> to create the RGR name, 
but only when <code>smoothing.scale</code> is <code>identity</code>. 
When <code>smoothing.scale</code> is <code>identity</code>: 
(i) if <code>RGR</code> is not <code>NULL</code>  
<code>deriv</code> must include 1 so that the first derivative is 
available for calculating the RGR; (ii) if <code>RGR</code> is <code>NULL</code>, 
the RGR is not calculated from the AGR. 
When <code>smoothing.scale</code> is <code>logarithmic</code>, 
the RGR is the backtransformed first derivative and so, to obtain it, merely 
include <code>1</code> in <code>deriv</code> and any suffix for it in 
<code>suffices.deriv</code>.</p>
</td></tr>
<tr><td><code id="splitSplines_+3A_agr">AGR</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the character to be appended 
to the smoothed <code>response</code> to create the AGR name, 
but only when <code>smoothing.scale</code> is <code>logarithmic</code>. 
When <code>smoothing.scale</code> is <code>logarithmic</code>: (i) 
if <code>AGR</code> is not <code>NULL</code>, 
<code>deriv</code> must include 1 so that the first derivative is 
available for calculating the AGR; (ii) If <code>AGR</code> is <code>NULL</code>, 
the AGR is not calculated from the RGR. When <code>smoothing.scale</code> is <code>identity</code>, 
the AGR is the first derivative and so, to obtain it, merely 
include <code>1</code> in <code>deriv</code> and any suffix for it in 
<code>suffices.deriv</code>.</p>
</td></tr>
<tr><td><code id="splitSplines_+3A_sep">sep</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the separator to use when the 
levels of <code>INDICES</code> are combined. This is needed to avoid 
using a <code><a href="base.html#topic+character">character</a></code> that occurs in a factor to delimit 
levels when the levels of <code>INDICES</code> are combined to identify 
subsets.</p>
</td></tr>
<tr><td><code id="splitSplines_+3A_na.x.action">na.x.action</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string that specifies the action to 
be taken when values of <code>x</code> are <code>NA</code>. The possible 
values are <code>fail</code>, <code>exclude</code> or <code>omit</code>. 
For <code>exclude</code> and <code>omit</code>, predictions and derivatives 
will only be obtained for nonmissing values of <code>x</code>. 
The difference between these two codes is that for <code>exclude</code> the returned 
<code>data.frame</code> will have as many rows as <code>data</code>, the 
missing values have been incorporated. </p>
</td></tr>
<tr><td><code id="splitSplines_+3A_na.y.action">na.y.action</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string that specifies the action to 
be taken when values of <code>y</code>, or the <code>response</code>, are 
<code>NA</code>.  The possible values are <code>fail</code>, <code>exclude</code>, 
<code>omit</code>, <code>allx</code>, <code>trimx</code>, <code>ltrimx</code> or 
<code>rtrimx</code>. For  all options, except <code>fail</code>, missing 
values in <code>y</code> will be removed before smoothing. 
For <code>exclude</code> and <code>omit</code>, predictions 
and derivatives will be obtained only for nonmissing values of 
<code>x</code> that do not have missing <code>y</code> values. Again, the 
difference between these two is that, only for <code>exclude</code> 
will the missing values be incorporated into the 
returned <code>data.frame</code>. For <code>allx</code>, predictions and 
derivatives will be obtained for all nonmissing <code>x</code>. 
For <code>trimx</code>, they will be obtained for all nonmissing 
<code>x</code> between the first and last nonmissing <code>y</code> values 
that have been ordered for <code>x</code>; for <code>ltrimx</code> and 
<code>utrimx</code> either the lower or upper missing <code>y</code> 
values, respectively, are trimmed.</p>
</td></tr>
<tr><td><code id="splitSplines_+3A_...">...</code></td>
<td>
<p>allows for arguments to be passed to <code>smooth.spline</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing  <code>data</code> to which has been 
added a column with the fitted smooth, the name of the column being 
<code>response</code> with <code>.smooth</code> appended to it. If <code>deriv</code> is 
not <code>NULL</code>, columns containing the values of the derivative(s) 
will be added to <code>data</code>; the name each of these columns will 
be the value of <code>response</code> with <code>.smooth.dvf</code> appended, 
where <code>f</code> is the order of the derivative, or  the value of 
<code>response</code> with <code>.smooth.</code> and the corresponding 
element of <code>suffices.deriv</code> appended. If <code>RGR</code> is not 
<code>NULL</code>, the RGR is calculated as the ratio of value of the first 
derivative of the fitted spline and the fitted value for the spline. 
Any pre-existing smoothed and derivative columns in <code>data</code> will be 
replaced. The ordering of the <code>data.frame</code> for the <code>x</code> 
values will be preserved as far as is possible; the main difficulty 
is with the handling of missing values by the function <code>merge</code>. 
Thus, if missing values in <code>x</code> are retained, they will occur at 
the bottom of each subset of <code>INDICES</code> and the order will be 
problematic when there are missing values in <code>y</code> and 
<code>na.y.action</code> is set to <code>omit</code>.
</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>References</h3>

<p>Huang, C. (2001). Boundary corrected cubic smoothing splines. <em>Journal of Statistical Computation and Simulation</em>, <b>70</b>, 107-121.</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitSpline">fitSpline</a></code>, <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>, 
<code><a href="stats.html#topic+predict.smooth.spline">predict.smooth.spline</a></code>, <code><a href="#topic+splitContGRdiff">splitContGRdiff</a></code>, <code><a href="base.html#topic+split">split</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(exampleData)
longi.dat &lt;- splitSplines(longi.dat, response="Area", x="xDays", 
                          INDICES = "Snapshot.ID.Tag", 
                          df = 4, deriv=1, suffices.deriv="AGRdv", RGR="RGRdv")
</code></pre>

<hr>
<h2 id='splitValueCalculate'>Calculates a single value that is a function of an individual's values for a response</h2><span id='topic+splitValueCalculate'></span>

<h3>Description</h3>

<p>Splits the values of a response into subsets corresponding 
individuals and applies a function that calculates a single 
value to each individual's observations.
It includes the ability to calculate the observation that 
corresponds to the calculated value of the function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitValueCalculate(response, weights=NULL, individuals = "Snapshot.ID.Tag", 
                    FUN = "max", which.obs = FALSE, which.levels = NULL, 
                    data, na.rm=TRUE, sep=".", ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitValueCalculate_+3A_response">response</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of the column in 
<code>data</code> from which the values of <code>FUN</code> are to be  
calculated.</p>
</td></tr>
<tr><td><code id="splitValueCalculate_+3A_weights">weights</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of the column in 
<code>data</code> containing the weights to be supplied as <code>w</code> 
to <code>FUN</code>.</p>
</td></tr>
<tr><td><code id="splitValueCalculate_+3A_individuals">individuals</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name(s) of the 
<code>factor</code>(s) that define the subsets of the <code>data</code> for 
which each subset corresponds to the <code>response</code> value for an 
individual.</p>
</td></tr>
<tr><td><code id="splitValueCalculate_+3A_fun">FUN</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of the <code>function</code> 
that calculates the value for each subset.</p>
</td></tr>
<tr><td><code id="splitValueCalculate_+3A_which.obs">which.obs</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code> indicating whether or not to determine 
the observation corresponding to the value of the function, 
instead of the value of the function itself.</p>
</td></tr>
<tr><td><code id="splitValueCalculate_+3A_which.levels">which.levels</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the name of the 
<code><a href="base.html#topic+factor">factor</a></code> whose levels are to be identified as 
the level of the observation whose value matches the 
value of the function.</p>
</td></tr>
<tr><td><code id="splitValueCalculate_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the column from which the 
function is to be calculated.</p>
</td></tr>
<tr><td><code id="splitValueCalculate_+3A_na.rm">na.rm</code></td>
<td>
<p>A <code><a href="base.html#topic+logical">logical</a></code>  indicating whether <code>NA</code> values 
should be stripped before the calculation proceeds.</p>
</td></tr>
<tr><td><code id="splitValueCalculate_+3A_sep">sep</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the separator to use when the 
levels of <code>individuals</code> are combined. This is needed to avoid 
using a <code><a href="base.html#topic+character">character</a></code> that occurs in a factor to delimit 
levels when the levels of <code>individuals</code> are combined to 
identify subsets.</p>
</td></tr>
<tr><td><code id="splitValueCalculate_+3A_...">...</code></td>
<td>
<p>allows for arguments to be passed to <code>FUN</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code>, with the same number of rows as there are 
<code>individuals</code>, containing the values of the function for the 
<code>individuals</code>.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>See Also</h3>

<p><code><a href="#topic+splitContGRdiff">splitContGRdiff</a></code>, <code><a href="#topic+splitSplines">splitSplines</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(exampleData)
Area.smooth.max &lt;- splitValueCalculate("Area.smooth", data = longi.dat)
</code></pre>

<hr>
<h2 id='twoLevelOpcreate'>Creates a data.frame formed by applying, for each response, a binary operation 
to the paired values of two different treatments </h2><span id='topic+twoLevelOpcreate'></span>

<h3>Description</h3>

<p>Takes pairs of values for a set of responses indexed by a two-level 
<code>treatment.factor</code> and calculates, for each of pair, 
the result of applying a binary <code>operation</code> to their values 
for the two levels of the <code>treatment.factor</code>. The level of the 
<code>treatment.factor</code> designated the <code>control</code> will be 
on the right of the binary operator and the value for the other 
level will be on the left.</p>


<h3>Usage</h3>

<pre><code class='language-R'>twoLevelOpcreate(responses, data, treatment.factor = "Treatment.1", 
                 suffices.treatment = c("Cont","Salt"), control = 1, 
                 columns.suffixed = NULL, 
                 operations = "/", suffices.results="OST", 
                 columns.retained = c("Snapshot.ID.Tag","Smarthouse","Lane", 
                                      "Zones","xZones","SHZones","ZLane",
                                      "ZMainplots","xMainPosn", "Genotype.ID"),
                 by = c("Smarthouse","Zones","ZMainplots"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="twoLevelOpcreate_+3A_responses">responses</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the names of the columns 
in <code>data</code> that contain the responses to which the binary 
operations are to be applied.</p>
</td></tr>
<tr><td><code id="twoLevelOpcreate_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the columns specified by 
<code>treatment.factor</code>, <code>columns.retained</code> and 
<code>responses</code>.</p>
</td></tr>
<tr><td><code id="twoLevelOpcreate_+3A_treatment.factor">treatment.factor</code></td>
<td>
<p>A <code><a href="base.html#topic+factor">factor</a></code> with two levels corresponding to 
what is to be designated the <code>control</code> and treated 
observations .</p>
</td></tr>
<tr><td><code id="twoLevelOpcreate_+3A_suffices.treatment">suffices.treatment</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the characters to be 
appended to the names of the <code>responses</code> and 
<code>columns.suffixed</code>  in constructing the 
names of the columns containing the <code>responses</code> and 
<code>columns.suffixed</code> for each 
level of the <code>treatment.factor</code>. The order of the 
suffices in <code>suffices.treatment</code> should correspond to 
the order of the levels of <code>treatment.factor</code>.</p>
</td></tr>
<tr><td><code id="twoLevelOpcreate_+3A_control">control</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code>, equal to either 1 or 2, that specifies 
the level of <code>treatment.factor</code> that is the control 
treatment. The value for the <code>control</code> level will be on 
the right of the binary operator.</p>
</td></tr>
<tr><td><code id="twoLevelOpcreate_+3A_columns.suffixed">columns.suffixed</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the names of the 
<code>columns.retained</code> in <code>data</code> that are to be have the 
values for each treatment retained and whose names are to be 
suffixed using <code>suffices.treatment</code>. Generally, this is done 
when <code>columns.retained</code> has different values for different 
levels of the <code>treatment.factor</code>.</p>
</td></tr>
<tr><td><code id="twoLevelOpcreate_+3A_operations">operations</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the binary operations to 
perform on the values for the two different levels of the 
<code>treatment.factor</code>. It should be either of length one, 
in which case the same operation will be performed for all columns 
specified in <code>response.GR</code>, or equal in length to 
<code>response.GR</code> so its elements correspond to those of 
<code>response.GR</code>.</p>
</td></tr>
<tr><td><code id="twoLevelOpcreate_+3A_suffices.results">suffices.results</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the characters to be 
appended to the names of the responses in constructing the 
names of the columns containing the results of applying 
the operations. The order of the 
suffices in <code>suffices.results</code> should correspond to 
the order of the operators in <code>operations</code>.</p>
</td></tr>
<tr><td><code id="twoLevelOpcreate_+3A_columns.retained">columns.retained</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the names of the 
columns in <code>data</code> that are to be retained in the 
<code>data.frame</code> being created. These are usually 
<code><a href="base.html#topic+factor">factor</a>s</code> that index the results of applying the 
operations and that might be used subsequently.</p>
</td></tr>
<tr><td><code id="twoLevelOpcreate_+3A_by">by</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> giving the names of the columns in 
<code>data</code> whose combinations will be unique for the observation 
for each treatment. It is used by <code><a href="base.html#topic+merge">merge</a></code> when combining 
the values of the two treatments in separate 
columns in the <code>data.frame</code> to be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the following columns and the values of the :
</p>

<ol>
<li><p> those from <code>data</code> nominated in <code>columns.retained</code>;
</p>
</li>
<li><p> those containing the treated values of the columns whose names 
are specified in <code>responses</code>; the treated values are 
those having the other level of <code>treatment.factor</code> to 
that specified by <code>control</code>;
</p>
</li>
<li><p> those containing the <code>control</code> values of the columns whose 
names are specified in <code>responses</code>; the control values are 
those having the level of <code>treatment.factor</code> specified 
by <code>control</code>;
</p>
</li>
<li><p> those containing the values calculated using the binary 
<code>operations</code>; the names of these columns will be 
constructed from <code>responses</code> by appending 
<code>suffices.results</code> to them.
</p>
</li></ol>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(exampleData)
responses &lt;- c("Area.smooth.AGR","Area.smooth.RGR")
cols.retained &lt;-  c("Snapshot.ID.Tag","Smarthouse","Lane","Position",
                    "Days","Snapshot.Time.Stamp", "Hour", "xDays",
                    "Zones","xZones","SHZones","ZLane","ZMainplots",
                    "xMainPosn", "Genotype.ID")
longi.SIIT.dat &lt;- 
  twoLevelOpcreate(responses, longi.dat, suffices.treatment=c("C","S"),
                   operations = c("-", "/"), 
                   suffices.results = c("diff", "SIIT"), 
                   columns.retained = cols.retained, 
                   by = c("Smarthouse","Zones","ZMainplots","Days"))
longi.SIIT.dat &lt;- with(longi.SIIT.dat, 
                            longi.SIIT.dat[order(Smarthouse,Zones,ZMainplots,Days),])
</code></pre>

<hr>
<h2 id='WUI'>Calculates the Water Use Index (WUI)</h2><span id='topic+WUI'></span>

<h3>Description</h3>

<p>Calculates the Water Use Index, returning <code>NA</code> if the water use is zero.</p>


<h3>Usage</h3>

<pre><code class='language-R'>WUI(response, water)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WUI_+3A_response">response</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the value of the response achieved.</p>
</td></tr>
<tr><td><code id="WUI_+3A_water">water</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric</a></code> giving the amount of water used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+numeric">numeric</a></code> containing the water divided by the response, unless water is 
zero in which case<code>NA</code> is returned.</p>


<h3>Author(s)</h3>

<p>Chris Brien</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(exampleData)
Area.WUE &lt;- with(longi.dat, WUI(Area.AGR, Water.Loss))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
