<!DOCTYPE html><html><head><title>Help for package treesitter</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {treesitter}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#treesitter-package'><p>treesitter: Bindings to 'Tree-Sitter'</p></a></li>
<li><a href='#is_language'><p>Is <code>x</code> a language?</p></a></li>
<li><a href='#is_node'><p>Is <code>x</code> a node?</p></a></li>
<li><a href='#is_parser'><p>Is <code>x</code> a parser?</p></a></li>
<li><a href='#is_query'><p>Is <code>x</code> a query?</p></a></li>
<li><a href='#is_tree'><p>Is <code>x</code> a tree?</p></a></li>
<li><a href='#language_field_count'><p>Language field count</p></a></li>
<li><a href='#language_field_id_for_name'><p>Language field identifiers</p></a></li>
<li><a href='#language_field_name_for_id'><p>Language field names</p></a></li>
<li><a href='#language_name'><p>Language name</p></a></li>
<li><a href='#language_next_state'><p>Language state advancement</p></a></li>
<li><a href='#language_state_count'><p>Language state count</p></a></li>
<li><a href='#language_symbol_count'><p>Language symbol count</p></a></li>
<li><a href='#language_symbol_for_name'><p>Language symbols</p></a></li>
<li><a href='#language_symbol_name'><p>Language symbol names</p></a></li>
<li><a href='#node_descendant_count'><p>Node descendant count</p></a></li>
<li><a href='#node_field_name_for_child'><p>Get a child's field name by index</p></a></li>
<li><a href='#node_language'><p>Get a node's underlying language</p></a></li>
<li><a href='#node_parent'><p>Get a node's parent</p></a></li>
<li><a href='#node_raw_s_expression'><p>&quot;Raw&quot; S-expression</p></a></li>
<li><a href='#node_show_s_expression'><p>Pretty print a <code>node</code>'s s-expression</p></a></li>
<li><a href='#node_symbol'><p>Node symbol</p></a></li>
<li><a href='#node_text'><p>Get a node's underlying text</p></a></li>
<li><a href='#node_type'><p>Node type</p></a></li>
<li><a href='#node_walk'><p>Generate a <code>TreeCursor</code> iterator</p></a></li>
<li><a href='#node-child'><p>Get a node's child by index</p></a></li>
<li><a href='#node-child-by-field'><p>Get a node's child by field id or name</p></a></li>
<li><a href='#node-child-count'><p>Get a node's child count</p></a></li>
<li><a href='#node-children'><p>Get a node's children</p></a></li>
<li><a href='#node-descendant'><p>Node descendants</p></a></li>
<li><a href='#node-first-child-byte'><p>Get the first child that extends beyond the given byte offset</p></a></li>
<li><a href='#node-grammar'><p>Node grammar types and symbols</p></a></li>
<li><a href='#node-location'><p>Node byte and point accessors</p></a></li>
<li><a href='#node-metadata'><p>Node metadata</p></a></li>
<li><a href='#node-parse-state'><p>Node parse states</p></a></li>
<li><a href='#node-sibling'><p>Node sibling accessors</p></a></li>
<li><a href='#parser'><p>Create a new parser</p></a></li>
<li><a href='#parser-adjustments'><p>Parser adjustments</p></a></li>
<li><a href='#parser-parse'><p>Parse or reparse text</p></a></li>
<li><a href='#points'><p>Points</p></a></li>
<li><a href='#query'><p>Queries</p></a></li>
<li><a href='#query-accessors'><p>Query accessors</p></a></li>
<li><a href='#query-matches-and-captures'><p>Query matches and captures</p></a></li>
<li><a href='#ranges'><p>Ranges</p></a></li>
<li><a href='#text_parse'><p>Parse a snippet of text</p></a></li>
<li><a href='#tree_root_node'><p>Retrieve the root node of the tree</p></a></li>
<li><a href='#tree_root_node_with_offset'><p>Retrieve an offset root node</p></a></li>
<li><a href='#tree_walk'><p>Generate a <code>TreeCursor</code> iterator</p></a></li>
<li><a href='#tree-accessors'><p>Tree accessors</p></a></li>
<li><a href='#TreeCursor'><p>Tree cursors</p></a></li>
<li><a href='#x_tree_sitter_node'><p>Helper page for consistent documentation</p></a></li>
<li><a href='#x_tree_sitter_parser'><p>Helper page for consistent documentation</p></a></li>
<li><a href='#x_tree_sitter_query'><p>Helper page for consistent documentation</p></a></li>
<li><a href='#x_tree_sitter_tree'><p>Helper page for consistent documentation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Bindings to 'Tree-Sitter'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides bindings to 'Tree-sitter', an incremental parsing
    system for programming tools. 'Tree-sitter' builds concrete syntax
    trees for source files of any language, and can efficiently update
    those syntax trees as the source file is edited. It also includes a
    robust error recovery system that provides useful parse results even
    in the presence of syntax errors.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/DavisVaughan/r-tree-sitter">https://github.com/DavisVaughan/r-tree-sitter</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/DavisVaughan/r-tree-sitter/issues">https://github.com/DavisVaughan/r-tree-sitter/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli (&ge; 3.6.2), R6 (&ge; 2.5.1), rlang (&ge; 1.1.3), vctrs (&ge;
0.6.5)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), treesitter.r</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>tidyverse/tidytemplate</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-22 00:02:29 UTC; davis</td>
</tr>
<tr>
<td>Author:</td>
<td>Davis Vaughan [aut, cre],
  Posit Software, PBC [cph, fnd],
  Tree-sitter authors [cph] (Tree-sitter C library)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Davis Vaughan &lt;davis@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-24 15:30:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='treesitter-package'>treesitter: Bindings to 'Tree-Sitter'</h2><span id='topic+treesitter'></span><span id='topic+treesitter-package'></span>

<h3>Description</h3>

<p>Provides bindings to 'Tree-sitter', an incremental parsing system for programming tools. 'Tree-sitter' builds concrete syntax trees for source files of any language, and can efficiently update those syntax trees as the source file is edited. It also includes a robust error recovery system that provides useful parse results even in the presence of syntax errors.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Davis Vaughan <a href="mailto:davis@posit.co">davis@posit.co</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Posit Software, PBC [copyright holder, funder]
</p>
</li>
<li><p> Tree-sitter authors (Tree-sitter C library) [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/DavisVaughan/r-tree-sitter">https://github.com/DavisVaughan/r-tree-sitter</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/DavisVaughan/r-tree-sitter/issues">https://github.com/DavisVaughan/r-tree-sitter/issues</a>
</p>
</li></ul>


<hr>
<h2 id='is_language'>Is <code>x</code> a language?</h2><span id='topic+is_language'></span>

<h3>Description</h3>

<p>Use <code>is_language()</code> to determine if an object has a class of
<code>"tree_sitter_language"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_language(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_language_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[object]&#8288;</code>
</p>
<p>An object.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>TRUE</code> if <code>x</code> is a <code>"tree_sitter_language"</code>.
</p>
</li>
<li> <p><code>FALSE</code> otherwise.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
language &lt;- treesitter.r::language()
is_language(language)

</code></pre>

<hr>
<h2 id='is_node'>Is <code>x</code> a node?</h2><span id='topic+is_node'></span>

<h3>Description</h3>

<p>Checks if <code>x</code> is a <code>tree_sitter_node</code> or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_node(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_node_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[object]&#8288;</code>
</p>
<p>An object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>x</code> is a <code>tree_sitter_node</code>, otherwise <code>FALSE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
language &lt;- treesitter.r::language()
parser &lt;- parser(language)

text &lt;- "fn &lt;- function() { 1 + 1 }"
tree &lt;- parser_parse(parser, text)
node &lt;- tree_root_node(tree)

is_node(node)

is_node(1)

</code></pre>

<hr>
<h2 id='is_parser'>Is <code>x</code> a parser?</h2><span id='topic+is_parser'></span>

<h3>Description</h3>

<p>Checks if <code>x</code> is a <code>tree_sitter_parser</code> or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_parser(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_parser_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[object]&#8288;</code>
</p>
<p>An object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>x</code> is a <code>tree_sitter_parser</code>, otherwise <code>FALSE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
language &lt;- treesitter.r::language()
parser &lt;- parser(language)

is_parser(parser)

is_parser(1)

</code></pre>

<hr>
<h2 id='is_query'>Is <code>x</code> a query?</h2><span id='topic+is_query'></span>

<h3>Description</h3>

<p>Checks if <code>x</code> is a <code>tree_sitter_query</code> or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_query(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_query_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[object]&#8288;</code>
</p>
<p>An object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>x</code> is a <code>tree_sitter_query</code>, otherwise <code>FALSE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
source &lt;- "(identifier) @id"
language &lt;- treesitter.r::language()

query &lt;- query(language, source)

is_query(query)

is_query(1)

</code></pre>

<hr>
<h2 id='is_tree'>Is <code>x</code> a tree?</h2><span id='topic+is_tree'></span>

<h3>Description</h3>

<p>Checks if <code>x</code> is a <code>tree_sitter_tree</code> or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_tree(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_tree_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[object]&#8288;</code>
</p>
<p>An object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>x</code> is a <code>tree_sitter_tree</code>, otherwise <code>FALSE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
language &lt;- treesitter.r::language()
parser &lt;- parser(language)

text &lt;- "fn &lt;- function() { 1 + 1 }"
tree &lt;- parser_parse(parser, text)

is_tree(tree)

is_tree(1)

</code></pre>

<hr>
<h2 id='language_field_count'>Language field count</h2><span id='topic+language_field_count'></span>

<h3>Description</h3>

<p>Get the number of fields contained within a language.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>language_field_count(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="language_field_count_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_language]&#8288;</code>
</p>
<p>A tree-sitter language object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single double value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
language &lt;- treesitter.r::language()
language_field_count(language)

</code></pre>

<hr>
<h2 id='language_field_id_for_name'>Language field identifiers</h2><span id='topic+language_field_id_for_name'></span>

<h3>Description</h3>

<p>Get the integer field identifier for a field name. If you are going to be
using a field name repeatedly, it is often a little faster to use the
corresponding field identifier instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>language_field_id_for_name(x, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="language_field_id_for_name_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_language]&#8288;</code>
</p>
<p>A tree-sitter language object.</p>
</td></tr>
<tr><td><code id="language_field_id_for_name_+3A_name">name</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character]&#8288;</code>
</p>
<p>The language field names to look up field identifiers for.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector the same length as <code>name</code> containing:
</p>

<ul>
<li><p> The field identifier for the field name, if known.
</p>
</li>
<li> <p><code>NA</code>, if the field name was not known.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+language_field_name_for_id">language_field_name_for_id()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
language &lt;- treesitter.r::language()
language_field_id_for_name(language, "lhs")

</code></pre>

<hr>
<h2 id='language_field_name_for_id'>Language field names</h2><span id='topic+language_field_name_for_id'></span>

<h3>Description</h3>

<p>Get the field name for a field identifier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>language_field_name_for_id(x, id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="language_field_name_for_id_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_language]&#8288;</code>
</p>
<p>A tree-sitter language object.</p>
</td></tr>
<tr><td><code id="language_field_name_for_id_+3A_id">id</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer]&#8288;</code>
</p>
<p>The language field identifiers to look up field names for.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector the same length as <code>id</code> containing:
</p>

<ul>
<li><p> The field name for the field identifier, if known.
</p>
</li>
<li> <p><code>NA</code>, if the field identifier was not known.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+language_field_id_for_name">language_field_id_for_name()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
language &lt;- treesitter.r::language()
language_field_name_for_id(language, 1)

</code></pre>

<hr>
<h2 id='language_name'>Language name</h2><span id='topic+language_name'></span>

<h3>Description</h3>

<p>Extract a language object's language name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>language_name(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="language_name_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_language]&#8288;</code>
</p>
<p>A tree-sitter language object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
language &lt;- treesitter.r::language()
language_name(language)

</code></pre>

<hr>
<h2 id='language_next_state'>Language state advancement</h2><span id='topic+language_next_state'></span>

<h3>Description</h3>

<p>Get the next state in the grammar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>language_next_state(x, state, symbol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="language_next_state_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_language]&#8288;</code>
</p>
<p>A tree-sitter language object.</p>
</td></tr>
<tr><td><code id="language_next_state_+3A_state">state</code>, <code id="language_next_state_+3A_symbol">symbol</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer]&#8288;</code>
</p>
<p>Vectors of equal length containing the current state and symbol
information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single integer representing the next state.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
language &lt;- treesitter.r::language()
parser &lt;- parser(language)

text &lt;- "fn &lt;- function() { 1 + 1 }"
tree &lt;- parser_parse(parser, text)
node &lt;- tree_root_node(tree)

# Navigate to function definition
node &lt;- node_child(node, 1)
node &lt;- node_child(node, 3)
node

state &lt;- node_parse_state(node)
symbol &lt;- node_grammar_symbol(node)

# Function definition symbol
language_symbol_name(language, 85)

# Next state (this is all grammar dependent)
language_next_state(language, state, symbol)

</code></pre>

<hr>
<h2 id='language_state_count'>Language state count</h2><span id='topic+language_state_count'></span>

<h3>Description</h3>

<p>Get the number of states traversable within a language.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>language_state_count(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="language_state_count_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_language]&#8288;</code>
</p>
<p>A tree-sitter language object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single double value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
language &lt;- treesitter.r::language()
language_state_count(language)

</code></pre>

<hr>
<h2 id='language_symbol_count'>Language symbol count</h2><span id='topic+language_symbol_count'></span>

<h3>Description</h3>

<p>Get the number of symbols contained within a language.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>language_symbol_count(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="language_symbol_count_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_language]&#8288;</code>
</p>
<p>A tree-sitter language object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single double value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
language &lt;- treesitter.r::language()
language_symbol_count(language)

</code></pre>

<hr>
<h2 id='language_symbol_for_name'>Language symbols</h2><span id='topic+language_symbol_for_name'></span>

<h3>Description</h3>

<p>Get the integer symbol ID for a particular node name. Can be useful
for exploring the grammar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>language_symbol_for_name(x, name, ..., named = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="language_symbol_for_name_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_language]&#8288;</code>
</p>
<p>A tree-sitter language object.</p>
</td></tr>
<tr><td><code id="language_symbol_for_name_+3A_name">name</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character]&#8288;</code>
</p>
<p>The names to look up symbols for.</p>
</td></tr>
<tr><td><code id="language_symbol_for_name_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="language_symbol_for_name_+3A_named">named</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical]&#8288;</code>
</p>
<p>Should named or anonymous nodes be looked up? Recycled to the
size of <code>name</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector the same size as <code>name</code> containing either:
</p>

<ul>
<li><p> The integer symbol ID of the node name, if known.
</p>
</li>
<li> <p><code>NA</code> if the node name was not known.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+language_symbol_name">language_symbol_name()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
language &lt;- treesitter.r::language()
language_symbol_for_name(language, "identifier")

</code></pre>

<hr>
<h2 id='language_symbol_name'>Language symbol names</h2><span id='topic+language_symbol_name'></span>

<h3>Description</h3>

<p>Get the name for a particular language symbol ID. Can be useful for
exploring a grammar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>language_symbol_name(x, symbol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="language_symbol_name_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_language]&#8288;</code>
</p>
<p>A tree-sitter language object.</p>
</td></tr>
<tr><td><code id="language_symbol_name_+3A_symbol">symbol</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[positive integer]&#8288;</code>
</p>
<p>The language symbols to look up names for.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector the same length as <code>symbol</code> containing:
</p>

<ul>
<li><p> The name of the symbol, if known.
</p>
</li>
<li> <p><code>NA</code>, if the symbol was not known.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+language_symbol_for_name">language_symbol_for_name()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
language &lt;- treesitter.r::language()
language_symbol_name(language, 1)

</code></pre>

<hr>
<h2 id='node_descendant_count'>Node descendant count</h2><span id='topic+node_descendant_count'></span>

<h3>Description</h3>

<p>Returns the number of descendants of this node, including this node in the
count.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_descendant_count(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node_descendant_count_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_node]&#8288;</code>
</p>
<p>A node.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single double.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
language &lt;- treesitter.r::language()
parser &lt;- parser(language)

text &lt;- "fn &lt;- function() { 1 + 1 }"
tree &lt;- parser_parse(parser, text)
node &lt;- tree_root_node(tree)

# Top level program node
node_descendant_count(node)

# The whole `&lt;-` binary operator node
node &lt;- node_child(node, 1)
node_descendant_count(node)

# Just the literal `&lt;-` operator itself
node &lt;- node_child_by_field_name(node, "operator")
node_descendant_count(node)

</code></pre>

<hr>
<h2 id='node_field_name_for_child'>Get a child's field name by index</h2><span id='topic+node_field_name_for_child'></span>

<h3>Description</h3>

<p><code>node_field_name_for_child()</code> returns the field name for the <code>i</code>th child,
considering both named and anonymous nodes.
</p>
<p>Nodes themselves don't know their own field names, because they don't know
if they are fields or not. You must have access to their parents to query
their field names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_field_name_for_child(x, i)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node_field_name_for_child_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_node]&#8288;</code>
</p>
<p>A node.</p>
</td></tr>
<tr><td><code id="node_field_name_for_child_+3A_i">i</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer(1)]&#8288;</code>
</p>
<p>The index of the child to get the field name for.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The field name for the <code>i</code>th child of <code>x</code>, or <code>NA_character_</code> if that child
doesn't exist.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
language &lt;- treesitter.r::language()
parser &lt;- parser(language)

text &lt;- "fn &lt;- function() { 1 + 1 }"
tree &lt;- parser_parse(parser, text)
node &lt;- tree_root_node(tree)

# Navigate to first child
node &lt;- node_child(node, 1)
node

# Get the field name of the first few children (note that anonymous children
# are considered)
node_field_name_for_child(node, 1)
node_field_name_for_child(node, 2)

# 10th child doesn't exist, this returns `NA_character_`
node_field_name_for_child(node, 10)

</code></pre>

<hr>
<h2 id='node_language'>Get a node's underlying language</h2><span id='topic+node_language'></span>

<h3>Description</h3>

<p><code>node_language()</code> returns the document text underlying a node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_language(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node_language_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_node]&#8288;</code>
</p>
<p>A node.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tree_sitter_language</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
language &lt;- treesitter.r::language()
parser &lt;- parser(language)

text &lt;- "1 + foo"
tree &lt;- parser_parse(parser, text)
node &lt;- tree_root_node(tree)

node_language(node)

</code></pre>

<hr>
<h2 id='node_parent'>Get a node's parent</h2><span id='topic+node_parent'></span>

<h3>Description</h3>

<p><code>node_parent()</code> looks up the tree and returns the current node's parent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_parent(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node_parent_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_node]&#8288;</code>
</p>
<p>A node.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The parent node of <code>x</code> or <code>NULL</code> if there is no parent.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
language &lt;- treesitter.r::language()
parser &lt;- parser(language)

text &lt;- "fn &lt;- function() { 1 + 1 }"
tree &lt;- parser_parse(parser, text)
node &lt;- tree_root_node(tree)

# Parent of a root node is `NULL`
node_parent(node)

node_function &lt;- node |&gt;
  node_child(1) |&gt;
  node_child(3)

node_function

node_parent(node_function)

</code></pre>

<hr>
<h2 id='node_raw_s_expression'>&quot;Raw&quot; S-expression</h2><span id='topic+node_raw_s_expression'></span>

<h3>Description</h3>

<p><code>node_raw_s_expression()</code> returns the &quot;raw&quot; s-expression as seen by
tree-sitter. Most of the time, <code><a href="#topic+node_show_s_expression">node_show_s_expression()</a></code> provides a better
view of the tree, but occasionally it can be useful to see exactly what the
underlying C library is using.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_raw_s_expression(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node_raw_s_expression_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_node]&#8288;</code>
</p>
<p>A node.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single string containing the raw s-expression.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
language &lt;- treesitter.r::language()
parser &lt;- parser(language)

text &lt;- "1 + foo"
tree &lt;- parser_parse(parser, text)
node &lt;- tree_root_node(tree)

node_raw_s_expression(node)

</code></pre>

<hr>
<h2 id='node_show_s_expression'>Pretty print a <code>node</code>'s s-expression</h2><span id='topic+node_show_s_expression'></span>

<h3>Description</h3>

<p><code>node_show_s_expression()</code> prints a nicely formatted s-expression to the
console. It powers the print methods of nodes and trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_show_s_expression(
  x,
  ...,
  max_lines = NULL,
  show_anonymous = TRUE,
  show_locations = TRUE,
  show_parentheses = TRUE,
  dangling_parenthesis = TRUE,
  color_parentheses = TRUE,
  color_locations = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node_show_s_expression_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_node]&#8288;</code>
</p>
<p>A node.</p>
</td></tr>
<tr><td><code id="node_show_s_expression_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="node_show_s_expression_+3A_max_lines">max_lines</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[double(1) / NULL]&#8288;</code>
</p>
<p>An optional maximum number of lines to print. If the maximum is hit, then
<code style="white-space: pre;">&#8288;&lt;truncated&gt;&#8288;</code> will be printed at the end.</p>
</td></tr>
<tr><td><code id="node_show_s_expression_+3A_show_anonymous">show_anonymous</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[bool]&#8288;</code>
</p>
<p>Should anonymous nodes be shown? If <code>FALSE</code>, only named nodes are shown.</p>
</td></tr>
<tr><td><code id="node_show_s_expression_+3A_show_locations">show_locations</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[bool]&#8288;</code>
</p>
<p>Should node locations be shown?</p>
</td></tr>
<tr><td><code id="node_show_s_expression_+3A_show_parentheses">show_parentheses</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[bool]&#8288;</code>
</p>
<p>Should parentheses around each node be shown?</p>
</td></tr>
<tr><td><code id="node_show_s_expression_+3A_dangling_parenthesis">dangling_parenthesis</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[bool]&#8288;</code>
</p>
<p>Should the <code style="white-space: pre;">&#8288;)&#8288;</code> parenthesis &quot;dangle&quot; on its own line? If <code>FALSE</code>, it is
appended to the line containing the last child. This can be useful for
conserving space.</p>
</td></tr>
<tr><td><code id="node_show_s_expression_+3A_color_parentheses">color_parentheses</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[bool]&#8288;</code>
</p>
<p>Should parentheses be colored? Printing large s-expressions is faster if
this is set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="node_show_s_expression_+3A_color_locations">color_locations</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[bool]&#8288;</code>
</p>
<p>Should locations be colored? Printing large s-expressions is faster if
this is set to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
language &lt;- treesitter.r::language()
parser &lt;- parser(language)

text &lt;- "fn &lt;- function(a, b = 2) { a + b + 2 }"
tree &lt;- parser_parse(parser, text)
node &lt;- tree_root_node(tree)

node_show_s_expression(node)

node_show_s_expression(node, max_lines = 5)

# This is more like a typical abstract syntax tree
node_show_s_expression(
  node,
  show_anonymous = FALSE,
  show_locations = FALSE,
  dangling_parenthesis = FALSE
)

</code></pre>

<hr>
<h2 id='node_symbol'>Node symbol</h2><span id='topic+node_symbol'></span>

<h3>Description</h3>

<p><code>node_symbol()</code> returns the symbol id of the current node as an integer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_symbol(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node_symbol_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_node]&#8288;</code>
</p>
<p>A node.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single integer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
language &lt;- treesitter.r::language()
parser &lt;- parser(language)

text &lt;- "fn &lt;- function() { 1 + 1 }"
tree &lt;- parser_parse(parser, text)
node &lt;- tree_root_node(tree)

# Top level program node
node_symbol(node)

# The whole `&lt;-` binary operator node
node &lt;- node_child(node, 1)
node_symbol(node)

# Just the literal `&lt;-` operator itself
node &lt;- node_child_by_field_name(node, "operator")
node_symbol(node)

</code></pre>

<hr>
<h2 id='node_text'>Get a node's underlying text</h2><span id='topic+node_text'></span>

<h3>Description</h3>

<p><code>node_text()</code> returns the document text underlying a node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_text(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node_text_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_node]&#8288;</code>
</p>
<p>A node.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single string containing the node's text.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
language &lt;- treesitter.r::language()
parser &lt;- parser(language)

text &lt;- "1 + foo"
tree &lt;- parser_parse(parser, text)
node &lt;- tree_root_node(tree)

node |&gt;
  node_child(1) |&gt;
  node_child_by_field_name("rhs") |&gt;
  node_text()

</code></pre>

<hr>
<h2 id='node_type'>Node type</h2><span id='topic+node_type'></span>

<h3>Description</h3>

<p><code>node_type()</code> returns the &quot;type&quot; of the current node as a string.
</p>
<p>This is a very useful function for making decisions about how to handle
the current node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_type(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node_type_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_node]&#8288;</code>
</p>
<p>A node.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single string.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
language &lt;- treesitter.r::language()
parser &lt;- parser(language)

text &lt;- "fn &lt;- function() { 1 + 1 }"
tree &lt;- parser_parse(parser, text)
node &lt;- tree_root_node(tree)

# Top level program node
node_type(node)

# The whole `&lt;-` binary operator node
node &lt;- node_child(node, 1)
node
node_type(node)

# Just the literal `&lt;-` operator itself
node &lt;- node_child_by_field_name(node, "operator")
node
node_type(node)

</code></pre>

<hr>
<h2 id='node_walk'>Generate a <code>TreeCursor</code> iterator</h2><span id='topic+node_walk'></span>

<h3>Description</h3>

<p><code>node_walk()</code> creates a <a href="#topic+TreeCursor">TreeCursor</a> starting at the current node. You can
use it to &quot;walk&quot; the tree more efficiently than using <code><a href="#topic+node_child">node_child()</a></code> and
other similar node functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_walk(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node_walk_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_node]&#8288;</code>
</p>
<p>A node.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>TreeCursor</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
language &lt;- treesitter.r::language()
parser &lt;- parser(language)

text &lt;- "1 + foo"
tree &lt;- parser_parse(parser, text)
node &lt;- tree_root_node(tree)

cursor &lt;- node_walk(node)

cursor$goto_first_child()
cursor$goto_first_child()
cursor$node()
cursor$goto_next_sibling()
cursor$node()

</code></pre>

<hr>
<h2 id='node-child'>Get a node's child by index</h2><span id='topic+node-child'></span><span id='topic+node_child'></span><span id='topic+node_named_child'></span>

<h3>Description</h3>

<p>These functions return the <code>i</code>th child of <code>x</code>.
</p>

<ul>
<li> <p><code>node_child()</code> considers both named and anonymous children.
</p>
</li>
<li> <p><code>node_named_child()</code> considers only named children.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>node_child(x, i)

node_named_child(x, i)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node-child_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_node]&#8288;</code>
</p>
<p>A node.</p>
</td></tr>
<tr><td><code id="node-child_+3A_i">i</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer(1)]&#8288;</code>
</p>
<p>The index of the child to return.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>i</code>th child node of <code>x</code> or <code>NULL</code> if there is no child at that index.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
language &lt;- treesitter.r::language()
parser &lt;- parser(language)

text &lt;- "fn &lt;- function() { 1 + 1 }"
tree &lt;- parser_parse(parser, text)
node &lt;- tree_root_node(tree)

# Starts with `program` node for the whole document
node

# Navigate to first child
node &lt;- node_child(node, 1)
node

# Note how the named variant skips the anonymous operator node
node_child(node, 2)
node_named_child(node, 2)

# OOB indices return `NULL`
node_child(node, 5)

</code></pre>

<hr>
<h2 id='node-child-by-field'>Get a node's child by field id or name</h2><span id='topic+node-child-by-field'></span><span id='topic+node_child_by_field_id'></span><span id='topic+node_child_by_field_name'></span>

<h3>Description</h3>

<p>These functions return children of <code>x</code> by field id or name.
</p>

<ul>
<li> <p><code>node_child_by_field_id()</code> retrieves a child by field id.
</p>
</li>
<li> <p><code>node_child_by_field_name()</code> retrieves a child by field name.
</p>
</li></ul>

<p>Use <code><a href="#topic+language_field_id_for_name">language_field_id_for_name()</a></code> to get the field id for a field name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_child_by_field_id(x, id)

node_child_by_field_name(x, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node-child-by-field_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_node]&#8288;</code>
</p>
<p>A node.</p>
</td></tr>
<tr><td><code id="node-child-by-field_+3A_id">id</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer(1)]&#8288;</code>
</p>
<p>The field id of the child to return.</p>
</td></tr>
<tr><td><code id="node-child-by-field_+3A_name">name</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1)]&#8288;</code>
</p>
<p>The field name of the child to return.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A child of <code>x</code>, or <code>NULL</code> if no matching child can be found.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
language &lt;- treesitter.r::language()
parser &lt;- parser(language)

text &lt;- "fn &lt;- function() { 1 + 1 }"
tree &lt;- parser_parse(parser, text)
node &lt;- tree_root_node(tree)

# Navigate to first child
node &lt;- node_child(node, 1)
node

# Get the field name of the first child
name &lt;- node_field_name_for_child(node, 1)
name

# Now get the child again by that field name
node_child_by_field_name(node, name)

# If you need to look up by field name many times, you can look up the
# more direct field id first and use that instead
id &lt;- language_field_id_for_name(language, name)
id

node_child_by_field_id(node, id)

# Returns `NULL` if no matching child
node_child_by_field_id(node, 10000)

</code></pre>

<hr>
<h2 id='node-child-count'>Get a node's child count</h2><span id='topic+node-child-count'></span><span id='topic+node_child_count'></span><span id='topic+node_named_child_count'></span>

<h3>Description</h3>

<p>These functions return the number of children of <code>x</code>.
</p>

<ul>
<li> <p><code>node_child_count()</code> considers both named and anonymous children.
</p>
</li>
<li> <p><code>node_named_child_count()</code> considers only named children.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>node_child_count(x)

node_named_child_count(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node-child-count_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_node]&#8288;</code>
</p>
<p>A node.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single integer, the number of children of <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
language &lt;- treesitter.r::language()
parser &lt;- parser(language)

text &lt;- "fn &lt;- function() { 1 + 1 }"
tree &lt;- parser_parse(parser, text)
node &lt;- tree_root_node(tree)

# Navigate to first child
node &lt;- node_child(node, 1)
node

# Note how the named variant doesn't count the anonymous operator node
node_child_count(node)
node_named_child_count(node)

</code></pre>

<hr>
<h2 id='node-children'>Get a node's children</h2><span id='topic+node-children'></span><span id='topic+node_children'></span><span id='topic+node_named_children'></span>

<h3>Description</h3>

<p>These functions return the children of <code>x</code> within a list.
</p>

<ul>
<li> <p><code>node_children()</code> considers both named and anonymous children.
</p>
</li>
<li> <p><code>node_named_children()</code> considers only named children.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>node_children(x)

node_named_children(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node-children_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_node]&#8288;</code>
</p>
<p>A node.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The children of <code>x</code> as a list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
language &lt;- treesitter.r::language()
parser &lt;- parser(language)

text &lt;- "fn &lt;- function() { 1 + 1 }"
tree &lt;- parser_parse(parser, text)
node &lt;- tree_root_node(tree)

# Navigate to first child
node &lt;- node_child(node, 1)
node

# Note how the named variant doesn't include the anonymous operator node
node_children(node)
node_named_children(node)

</code></pre>

<hr>
<h2 id='node-descendant'>Node descendants</h2><span id='topic+node-descendant'></span><span id='topic+node_descendant_for_byte_range'></span><span id='topic+node_named_descendant_for_byte_range'></span><span id='topic+node_descendant_for_point_range'></span><span id='topic+node_named_descendant_for_point_range'></span>

<h3>Description</h3>

<p>These functions return the smallest node within this node that spans the
given range of bytes or points. If the ranges are out of bounds, or no
smaller node can be determined, the input is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_descendant_for_byte_range(x, start, end)

node_named_descendant_for_byte_range(x, start, end)

node_descendant_for_point_range(x, start, end)

node_named_descendant_for_point_range(x, start, end)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node-descendant_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_node]&#8288;</code>
</p>
<p>A node.</p>
</td></tr>
<tr><td><code id="node-descendant_+3A_start">start</code>, <code id="node-descendant_+3A_end">end</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer(1) / tree_sitter_point]&#8288;</code>
</p>
<p>For the byte range functions, start and end bytes to search within.
</p>
<p>For the point range functions, start and end points created by <code><a href="#topic+point">point()</a></code> to
search within.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
language &lt;- treesitter.r::language()
parser &lt;- parser(language)

text &lt;- "fn &lt;- function() { 1 + 1 }"
tree &lt;- parser_parse(parser, text)
node &lt;- tree_root_node(tree)

# The whole `&lt;-` binary operator node
node &lt;- node_child(node, 1)
node

# The byte range points to a location in the word `function`
node_descendant_for_byte_range(node, 7, 9)
node_named_descendant_for_byte_range(node, 7, 9)

start &lt;- point(0, 14)
end &lt;- point(0, 15)

node_descendant_for_point_range(node, start, end)
node_named_descendant_for_point_range(node, start, end)

# OOB returns the input
node_descendant_for_byte_range(node, 25, 29)

</code></pre>

<hr>
<h2 id='node-first-child-byte'>Get the first child that extends beyond the given byte offset</h2><span id='topic+node-first-child-byte'></span><span id='topic+node_first_child_for_byte'></span><span id='topic+node_first_named_child_for_byte'></span>

<h3>Description</h3>

<p>These functions return the first child of <code>x</code> that extends beyond the given
<code>byte</code> offset. Note that <code>byte</code> is a 0-indexed offset.
</p>

<ul>
<li> <p><code>node_first_child_for_byte()</code> considers both named and anonymous nodes.
</p>
</li>
<li> <p><code>node_first_named_child_for_byte()</code> considers only named nodes.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>node_first_child_for_byte(x, byte)

node_first_named_child_for_byte(x, byte)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node-first-child-byte_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_node]&#8288;</code>
</p>
<p>A node.</p>
</td></tr>
<tr><td><code id="node-first-child-byte_+3A_byte">byte</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer(1)]&#8288;</code>
</p>
<p>The byte to start the search from.
</p>
<p>Note that <code>byte</code> is 0-indexed!</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new node, or <code>NULL</code> if there is no node past the <code>byte</code> offset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
language &lt;- treesitter.r::language()
parser &lt;- parser(language)

text &lt;- "fn &lt;- function() { 1 + 1 }"
tree &lt;- parser_parse(parser, text)
node &lt;- tree_root_node(tree)

# Navigate to first child
node &lt;- node_child(node, 1)
node

# `fn {here}&lt;- function()`
node_first_child_for_byte(node, 3)
node_first_named_child_for_byte(node, 3)

# Past any node
node_first_child_for_byte(node, 100)

</code></pre>

<hr>
<h2 id='node-grammar'>Node grammar types and symbols</h2><span id='topic+node-grammar'></span><span id='topic+node_grammar_type'></span><span id='topic+node_grammar_symbol'></span>

<h3>Description</h3>


<ul>
<li> <p><code>node_grammar_type()</code> gets the node's type as it appears in the grammar,
<em>ignoring aliases</em>.
</p>
</li>
<li> <p><code>node_grammar_symbol()</code> gets the node's symbol (the type as a numeric id)
as it appears in the grammar, <em>ignoring aliases</em>. This should be used in
<code><a href="#topic+language_next_state">language_next_state()</a></code> rather than <code><a href="#topic+node_symbol">node_symbol()</a></code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>node_grammar_type(x)

node_grammar_symbol(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node-grammar_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_node]&#8288;</code>
</p>
<p>A node.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+node_type">node_type()</a></code>, <code><a href="#topic+node_symbol">node_symbol()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
language &lt;- treesitter.r::language()
parser &lt;- parser(language)

text &lt;- "fn &lt;- function() { 1 + 1 }"
tree &lt;- parser_parse(parser, text)
node &lt;- tree_root_node(tree)

# Examples for these functions are highly specific to the grammar,
# because they relies on the placement of `alias()` calls in the grammar.
node_grammar_type(node)
node_grammar_symbol(node)

</code></pre>

<hr>
<h2 id='node-location'>Node byte and point accessors</h2><span id='topic+node-location'></span><span id='topic+node_start_byte'></span><span id='topic+node_end_byte'></span><span id='topic+node_start_point'></span><span id='topic+node_end_point'></span><span id='topic+node_range'></span>

<h3>Description</h3>

<p>These functions return information about the location of <code>x</code> in the document.
The byte, row, and column locations are all 0-indexed.
</p>

<ul>
<li> <p><code>node_start_byte()</code> returns the start byte.
</p>
</li>
<li> <p><code>node_end_byte()</code> returns the end byte.
</p>
</li>
<li> <p><code>node_start_point()</code> returns the start point, containing a row and column
location within the document. Use accessors like <code><a href="#topic+point_row">point_row()</a></code> to extract
the row and column positions.
</p>
</li>
<li> <p><code>node_end_point()</code> returns the end point, containing a row and column
location within the document. Use accessors like <code><a href="#topic+point_row">point_row()</a></code> to extract
the row and column positions.
</p>
</li>
<li> <p><code>node_range()</code> returns a range object that contains all of the above
information. Use accessors like <code><a href="#topic+range_start_point">range_start_point()</a></code> to extract
individual pieces from the range.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>node_start_byte(x)

node_end_byte(x)

node_start_point(x)

node_end_point(x)

node_range(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node-location_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_node]&#8288;</code>
</p>
<p>A node.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>node_start_byte()</code> and <code>node_end_byte()</code> return a single numeric value.
</p>
</li>
<li> <p><code>node_start_point()</code> and <code>node_end_point()</code> return single points.
</p>
</li>
<li> <p><code>node_range()</code> returns a range.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
language &lt;- treesitter.r::language()
parser &lt;- parser(language)

text &lt;- "fn &lt;- function() { 1 + 1 }"
tree &lt;- parser_parse(parser, text)
node &lt;- tree_root_node(tree)

# Navigate to first child
node &lt;- node_child(node, 1)

# Navigate to function definition node
node &lt;- node_child(node, 3)
node

node_start_byte(node)
node_end_byte(node)

node_start_point(node)
node_end_point(node)

node_range(node)

</code></pre>

<hr>
<h2 id='node-metadata'>Node metadata</h2><span id='topic+node-metadata'></span><span id='topic+node_is_named'></span><span id='topic+node_is_missing'></span><span id='topic+node_is_extra'></span><span id='topic+node_is_error'></span><span id='topic+node_has_error'></span>

<h3>Description</h3>

<p>These functions return metadata about the current node.
</p>

<ul>
<li> <p><code>node_is_named()</code> reports if the current node is named or anonymous.
</p>
</li>
<li> <p><code>node_is_missing()</code> reports if the current node is <code>MISSING</code>, i.e.
if it was implied through error recovery.
</p>
</li>
<li> <p><code>node_is_extra()</code> reports if the current node is an &quot;extra&quot; from the
grammar.
</p>
</li>
<li> <p><code>node_is_error()</code> reports if the current node is an <code>ERROR</code> node.
</p>
</li>
<li> <p><code>node_has_error()</code> reports if the current node is an <code>ERROR</code> node, or if
any descendants of the current node are <code>ERROR</code> or <code>MISSING</code> nodes.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>node_is_named(x)

node_is_missing(x)

node_is_extra(x)

node_is_error(x)

node_has_error(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node-metadata_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_node]&#8288;</code>
</p>
<p>A node.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> or <code>FALSE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
language &lt;- treesitter.r::language()
parser &lt;- parser(language)

text &lt;- "fn &lt;- function() { 1 + 1 }"
tree &lt;- parser_parse(parser, text)
node &lt;- tree_root_node(tree)

node &lt;- node_child(node, 1)

fn &lt;- node_child(node, 1)
operator &lt;- node_child(node, 2)

fn
node_is_named(fn)

operator
node_is_named(operator)

# Examples of `TRUE` cases for these are a bit hard to come up with, because
# they are dependent on the exact state of the grammar and the error recovery
# algorithm
node_is_missing(node)
node_is_extra(node)

</code></pre>

<hr>
<h2 id='node-parse-state'>Node parse states</h2><span id='topic+node-parse-state'></span><span id='topic+node_parse_state'></span><span id='topic+node_next_parse_state'></span>

<h3>Description</h3>

<p>These are advanced functions that return information about the internal parse
states.
</p>

<ul>
<li> <p><code>node_parse_state()</code> returns the parse state of the current node.
</p>
</li>
<li> <p><code>node_next_parse_state()</code> returns the parse state after this node.
</p>
</li></ul>

<p>See <code><a href="#topic+language_next_state">language_next_state()</a></code> for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_parse_state(x)

node_next_parse_state(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node-parse-state_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_node]&#8288;</code>
</p>
<p>A node.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single integer representing a parse state.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
language &lt;- treesitter.r::language()
parser &lt;- parser(language)

text &lt;- "fn &lt;- function() { 1 + 1 }"
tree &lt;- parser_parse(parser, text)
node &lt;- tree_root_node(tree)

node &lt;- node_child(node, 1)

# Parse states are grammar dependent
node_parse_state(node)
node_next_parse_state(node)

</code></pre>

<hr>
<h2 id='node-sibling'>Node sibling accessors</h2><span id='topic+node-sibling'></span><span id='topic+node_next_sibling'></span><span id='topic+node_next_named_sibling'></span><span id='topic+node_previous_sibling'></span><span id='topic+node_previous_named_sibling'></span>

<h3>Description</h3>

<p>These functions return siblings of the current node, i.e. if you looked
&quot;left&quot; or &quot;right&quot; from the current node rather &quot;up&quot; (parent) or &quot;down&quot;
(child).
</p>

<ul>
<li> <p><code>node_next_sibling()</code> and <code>node_next_named_sibling()</code> return the next
sibling.
</p>
</li>
<li> <p><code>node_previous_sibling()</code> and <code>node_previous_named_sibling()</code> return the
previous sibling.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>node_next_sibling(x)

node_next_named_sibling(x)

node_previous_sibling(x)

node_previous_named_sibling(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node-sibling_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_node]&#8288;</code>
</p>
<p>A node.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sibling node, or <code>NULL</code> if there is no sibling node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
language &lt;- treesitter.r::language()
parser &lt;- parser(language)

text &lt;- "fn &lt;- function() { 1 + 1 }"
tree &lt;- parser_parse(parser, text)
node &lt;- tree_root_node(tree)

# Navigate to first child
node &lt;- node_child(node, 1)

# Navigate to function definition node
node &lt;- node_child(node, 3)
node

node_previous_sibling(node)

# Skip anonymous operator node
node_previous_named_sibling(node)

# There isn't one!
node_next_sibling(node)

</code></pre>

<hr>
<h2 id='parser'>Create a new parser</h2><span id='topic+parser'></span>

<h3>Description</h3>

<p><code>parser()</code> constructs a parser from a tree-sitter <code>language</code> object. You can
use <code><a href="#topic+parser_parse">parser_parse()</a></code> to parse language specific text with it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parser(language)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parser_+3A_language">language</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_language]&#8288;</code>
</p>
<p>A language object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new parser.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
language &lt;- treesitter.r::language()
parser &lt;- parser(language)
parser

text &lt;- "1 + foo"
tree &lt;- parser_parse(parser, text)
tree

</code></pre>

<hr>
<h2 id='parser-adjustments'>Parser adjustments</h2><span id='topic+parser-adjustments'></span><span id='topic+parser_set_language'></span><span id='topic+parser_set_timeout'></span><span id='topic+parser_set_included_ranges'></span>

<h3>Description</h3>


<ul>
<li> <p><code>parser_set_language()</code> sets the language of the parser. This is usually
done by <code><a href="#topic+parser">parser()</a></code> though.
</p>
</li>
<li> <p><code>parser_set_timeout()</code> sets an optional timeout used when calling
<code><a href="#topic+parser_parse">parser_parse()</a></code> or <code><a href="#topic+parser_reparse">parser_reparse()</a></code>. If the timeout is hit, an error
occurs.
</p>
</li>
<li> <p><code>parser_set_included_ranges()</code> sets an optional list of ranges that are
the only locations considered when parsing. The ranges are created by
<code><a href="#topic+range">range()</a></code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>parser_set_language(x, language)

parser_set_timeout(x, timeout)

parser_set_included_ranges(x, included_ranges)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parser-adjustments_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_parser]&#8288;</code>
</p>
<p>A parser.</p>
</td></tr>
<tr><td><code id="parser-adjustments_+3A_language">language</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_language]&#8288;</code>
</p>
<p>A language.</p>
</td></tr>
<tr><td><code id="parser-adjustments_+3A_timeout">timeout</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[double(1)]&#8288;</code>
</p>
<p>A single whole number corresponding to a timeout in microseconds to use
when parsing.</p>
</td></tr>
<tr><td><code id="parser-adjustments_+3A_included_ranges">included_ranges</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[list_of&lt;tree_sitter_range&gt;]&#8288;</code>
</p>
<p>A list of ranges constructed by <code><a href="#topic+range">range()</a></code>. These are the only locations
that will be considered when parsing.
</p>
<p>An empty list can be used to clear any existing ranges so that the parser
will again parse the entire document.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new parser.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
language &lt;- treesitter.r::language()
parser &lt;- parser(language)
parser_set_timeout(parser, 10000)

</code></pre>

<hr>
<h2 id='parser-parse'>Parse or reparse text</h2><span id='topic+parser-parse'></span><span id='topic+parser_parse'></span><span id='topic+parser_reparse'></span>

<h3>Description</h3>


<ul>
<li> <p><code>parser_parse()</code> performs an initial parse of <code>text</code>, a string typically
containing contents of a file. It returns a <code>tree</code> for further
manipulations.
</p>
</li>
<li> <p><code>parser_reparse()</code> performs a fast incremental reparse. <code>text</code> is typically
a slightly modified version of the original <code>text</code> with a new &quot;edit&quot;
applied. The position of the edit is described by the byte and point
arguments to this function. The <code>tree</code> argument corresponds to the original
<code>tree</code> returned by <code>parser_parse()</code>.
</p>
</li></ul>

<p>All bytes and points should be 0-indexed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parser_parse(x, text, ..., encoding = "UTF-8")

parser_reparse(
  x,
  text,
  tree,
  start_byte,
  start_point,
  old_end_byte,
  old_end_point,
  new_end_byte,
  new_end_point,
  ...,
  encoding = "UTF-8"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parser-parse_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_parser]&#8288;</code>
</p>
<p>A parser.</p>
</td></tr>
<tr><td><code id="parser-parse_+3A_text">text</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[string]&#8288;</code>
</p>
<p>The text to parse.</p>
</td></tr>
<tr><td><code id="parser-parse_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="parser-parse_+3A_encoding">encoding</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[string]&#8288;</code>
</p>
<p>The expected encoding of the <code>text</code>. Either <code>"UTF-8"</code> or <code>"UTF-16"</code>.</p>
</td></tr>
<tr><td><code id="parser-parse_+3A_tree">tree</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_tree]&#8288;</code>
</p>
<p>The original tree returned by <code>parser_parse()</code>. Components of the tree
will be reused to perform the incremental reparse.</p>
</td></tr>
<tr><td><code id="parser-parse_+3A_start_byte">start_byte</code>, <code id="parser-parse_+3A_start_point">start_point</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[double(1) / tree_sitter_point]&#8288;</code>
</p>
<p>The starting byte and starting point of the edit location.</p>
</td></tr>
<tr><td><code id="parser-parse_+3A_old_end_byte">old_end_byte</code>, <code id="parser-parse_+3A_old_end_point">old_end_point</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[double(1) / tree_sitter_point]&#8288;</code>
</p>
<p>The old ending byte and old ending point of the edit location.</p>
</td></tr>
<tr><td><code id="parser-parse_+3A_new_end_byte">new_end_byte</code>, <code id="parser-parse_+3A_new_end_point">new_end_point</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[double(1) / tree_sitter_point]&#8288;</code>
</p>
<p>The new ending byte and new ending point of the edit location.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new <code>tree</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
language &lt;- treesitter.r::language()
parser &lt;- parser(language)

text &lt;- "1 + foo"
tree &lt;- parser_parse(parser, text)
tree

text &lt;- "1 + bar(foo)"
parser_reparse(
  parser,
  text,
  tree,
  start_byte = 4,
  start_point = point(0, 4),
  old_end_byte = 7,
  old_end_point = point(0, 7),
  new_end_byte = 12,
  new_end_point = point(0, 12)
)

</code></pre>

<hr>
<h2 id='points'>Points</h2><span id='topic+points'></span><span id='topic+point'></span><span id='topic+point_row'></span><span id='topic+point_column'></span><span id='topic+is_point'></span>

<h3>Description</h3>


<ul>
<li> <p><code>point()</code> creates a new tree-sitter point.
</p>
</li>
<li> <p><code>point_row()</code> and <code>point_column()</code> access a point's row and column value,
respectively.
</p>
</li>
<li> <p><code>is_point()</code> determines whether or not an object is a point.
</p>
</li></ul>

<p>Note that points are 0-indexed. This is typically the easiest form to work
with them in, since most of the time when you are provided row and column
information from third party libraries, they will already be 0-indexed. It
is also consistent with bytes, which are also 0-indexed and are often
provided alongside their corresponding points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>point(row, column)

point_row(x)

point_column(x)

is_point(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="points_+3A_row">row</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[double(1)]&#8288;</code>
</p>
<p>A 0-indexed row to place the point at.</p>
</td></tr>
<tr><td><code id="points_+3A_column">column</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[double(1)]&#8288;</code>
</p>
<p>A 0-indexed column to place the point at.</p>
</td></tr>
<tr><td><code id="points_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_point]&#8288;</code>
</p>
<p>A point.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>point()</code> returns a new point.
</p>
</li>
<li> <p><code>point_row()</code> and <code>point_column()</code> return a single double.
</p>
</li>
<li> <p><code>is_point()</code> returns <code>TRUE</code> or <code>FALSE</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- point(1, 2)

point_row(x)
point_column(x)

is_point(x)
</code></pre>

<hr>
<h2 id='query'>Queries</h2><span id='topic+query'></span>

<h3>Description</h3>

<p><code>query()</code> lets you specify a query <code>source</code> string for use with
<code><a href="#topic+query_captures">query_captures()</a></code> and <code><a href="#topic+query_matches">query_matches()</a></code>. The <code>source</code> string is written
in a way that is somewhat similar to the idea of capture groups in regular
expressions. You write out a pattern that matches a node in a tree, and then
you &quot;capture&quot; parts of that pattern with <code style="white-space: pre;">&#8288;@name&#8288;</code> tags. The captures are
the values returned by <code><a href="#topic+query_captures">query_captures()</a></code> and <code><a href="#topic+query_matches">query_matches()</a></code>. There are
also a series of <em>predicates</em> that can be used to further refine the
query. Those are described in the <code><a href="#topic+query_matches">query_matches()</a></code> help page.
</p>
<p>Read the <a href="https://tree-sitter.github.io/tree-sitter/using-parsers#query-syntax">tree-sitter documentation</a>
to learn more about the query syntax.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>query(language, source)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="query_+3A_language">language</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_language]&#8288;</code>
</p>
<p>A language.</p>
</td></tr>
<tr><td><code id="query_+3A_source">source</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[string]&#8288;</code>
</p>
<p>A query source string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A query.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# This query looks for binary operators where the left hand side is an
# identifier named `fn`, and the right hand side is a function definition.
# The operator can be `&lt;-` or `=` (technically it can also be things like
# `+` as well in this example).
source &lt;- '(binary_operator
  lhs: (identifier) @lhs
  operator: _ @operator
  rhs: (function_definition) @rhs
  (#eq? @lhs "fn")
)'

language &lt;- treesitter.r::language()

query &lt;- query(language, source)

text &lt;- "
  fn &lt;- function() {}
  fn2 &lt;- function() {}
  fn &lt;- 5
  fn = function(a, b, c) { a + b + c }
"
parser &lt;- parser(language)
tree &lt;- parser_parse(parser, text)
node &lt;- tree_root_node(tree)

query_matches(query, node)

</code></pre>

<hr>
<h2 id='query-accessors'>Query accessors</h2><span id='topic+query-accessors'></span><span id='topic+query_pattern_count'></span><span id='topic+query_capture_count'></span><span id='topic+query_string_count'></span><span id='topic+query_start_byte_for_pattern'></span>

<h3>Description</h3>


<ul>
<li> <p><code>query_pattern_count()</code> returns the number of patterns in a query.
</p>
</li>
<li> <p><code>query_capture_count()</code> returns the number of captures in a query.
</p>
</li>
<li> <p><code>query_string_count()</code> returns the number of string literals in a query.
</p>
</li>
<li> <p><code>query_start_byte_for_pattern()</code> returns the byte where the <code>i</code>th pattern
starts in the query <code>source</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>query_pattern_count(x)

query_capture_count(x)

query_string_count(x)

query_start_byte_for_pattern(x, i)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="query-accessors_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_query]&#8288;</code>
</p>
<p>A query.</p>
</td></tr>
<tr><td><code id="query-accessors_+3A_i">i</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[double(1)]&#8288;</code>
</p>
<p>The <code>i</code>th pattern to extract the start byte for.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>query_pattern_count()</code>, <code>query_capture_count()</code>, and
<code>query_string_count()</code> return a single double count value.
</p>
</li>
<li> <p><code>query_start_byte_for_pattern()</code> returns a single double for the start byte
if there was an <code>i</code>th pattern, otherwise it returns <code>NA</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
source &lt;- '(binary_operator
  lhs: (identifier) @lhs
  operator: _ @operator
  rhs: (function_definition) @rhs
  (#eq? @lhs "fn")
)'
language &lt;- treesitter.r::language()

query &lt;- query(language, source)

query_pattern_count(query)
query_capture_count(query)
query_string_count(query)

text &lt;- "
  fn &lt;- function() {}
  fn2 &lt;- function() {}
  fn &lt;- 5
  fn &lt;- function(a, b, c) { a + b + c }
"
parser &lt;- parser(language)
tree &lt;- parser_parse(parser, text)
node &lt;- tree_root_node(tree)

query_matches(query, node)

</code></pre>

<hr>
<h2 id='query-matches-and-captures'>Query matches and captures</h2><span id='topic+query-matches-and-captures'></span><span id='topic+query_matches'></span><span id='topic+query_captures'></span>

<h3>Description</h3>

<p>These two functions execute a query on a given <code>node</code>, and return the
captures of the query for further use. Both functions return the same
information, just structured differently depending on your use case.
</p>

<ul>
<li> <p><code>query_matches()</code> returns the captures first grouped by <em>pattern</em>, and
further grouped by <em>match</em> within each pattern. This is useful if you
include multiple patterns in your query.
</p>
</li>
<li> <p><code>query_captures()</code> returns a flat list of captures ordered by their node
location in the original text. This is normally the easiest structure to
use if you have a single pattern without any alternations that would
benefit from having individual captures split by match.
</p>
</li></ul>

<p>Both also return the capture name, i.e. the <code style="white-space: pre;">&#8288;@name&#8288;</code> you specified in your
query.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>query_matches(x, node, ..., range = NULL)

query_captures(x, node, ..., range = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="query-matches-and-captures_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_query]&#8288;</code>
</p>
<p>A query.</p>
</td></tr>
<tr><td><code id="query-matches-and-captures_+3A_node">node</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_node]&#8288;</code>
</p>
<p>A node to run the query over.</p>
</td></tr>
<tr><td><code id="query-matches-and-captures_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="query-matches-and-captures_+3A_range">range</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_range / NULL]&#8288;</code>
</p>
<p>An optional range to restrict the query to.</p>
</td></tr>
</table>


<h3>Predicates</h3>

<p>There are 3 core types of predicates supported:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;#eq? @capture "string"&#8288;</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;#eq? @capture1 @capture2&#8288;</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;#match? @capture "regex"&#8288;</code>
</p>
</li></ul>

<p>Each of these predicates can also be inverted with a <code style="white-space: pre;">&#8288;not-&#8288;</code> prefix, i.e.
<code style="white-space: pre;">&#8288;#not-eq?&#8288;</code> and <code style="white-space: pre;">&#8288;#not-match?&#8288;</code>.
</p>


<h4>String double quotes</h4>

<p>The underlying tree-sitter predicate parser requires that strings supplied
in a query must use double quotes, i.e. <code>"string"</code> not <code>'string'</code>. If you
try and use single quotes, you will get a query error.
</p>



<h4><code style="white-space: pre;">&#8288;#match?&#8288;</code> regex</h4>

<p>The regex support provided by <code style="white-space: pre;">&#8288;#match?&#8288;</code> is powered by <code><a href="base.html#topic+grepl">grepl()</a></code>.
</p>
<p>Escapes are a little tricky to get right within these match regex strings.
To use something like <code style="white-space: pre;">&#8288;\s&#8288;</code> in the regex string, you need the literal text
<code style="white-space: pre;">&#8288;\\s&#8288;</code> to appear in the string to tell the tree-sitter regex engine to escape
the backslash so you end up with just <code style="white-space: pre;">&#8288;\s&#8288;</code> in the captured string. This
requires putting two literal backslash characters in the R string itself,
which can be accomplished with either <code>"\\\\s"</code> or using a raw string like
<code>r'["\\\\s"]'</code> which is typically a little easier. You can also write your
queries in a separate file (typically called <code>queries.scm</code>) and read them
into R, which is also a little more straightforward because you can just
write something like <code style="white-space: pre;">&#8288;(#match? @id "^\\s$")&#8288;</code> and that will be read in
correctly.
</p>



<h3>Examples</h3>

<pre><code class='language-R'>
text &lt;- "
foo + b + a + ab
and(a)
"

source &lt;- "(identifier) @id"

language &lt;- treesitter.r::language()

query &lt;- query(language, source)
parser &lt;- parser(language)
tree &lt;- parser_parse(parser, text)
node &lt;- tree_root_node(tree)

# A flat ordered list of captures, that's most useful here since
# we only have 1 pattern!
captures &lt;- query_captures(query, node)
captures$node

</code></pre>

<hr>
<h2 id='ranges'>Ranges</h2><span id='topic+ranges'></span><span id='topic+range'></span><span id='topic+range_start_byte'></span><span id='topic+range_start_point'></span><span id='topic+range_end_byte'></span><span id='topic+range_end_point'></span><span id='topic+is_range'></span>

<h3>Description</h3>


<ul>
<li> <p><code>range()</code> creates a new tree-sitter range.
</p>
</li>
<li> <p><code>range_start_byte()</code> and <code>range_end_byte()</code> access a range's start and
end bytes, respectively.
</p>
</li>
<li> <p><code>range_start_point()</code> and <code>range_end_point()</code> access a range's start and
end points, respectively.
</p>
</li>
<li> <p><code>is_range()</code> determines whether or not an object is a range.
</p>
</li></ul>

<p>Note that the bytes and points used in ranges are 0-indexed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>range(start_byte, start_point, end_byte, end_point)

range_start_byte(x)

range_start_point(x)

range_end_byte(x)

range_end_point(x)

is_range(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ranges_+3A_start_byte">start_byte</code>, <code id="ranges_+3A_end_byte">end_byte</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[double(1)]&#8288;</code>
</p>
<p>0-indexed bytes for the start and end of the range, respectively.</p>
</td></tr>
<tr><td><code id="ranges_+3A_start_point">start_point</code>, <code id="ranges_+3A_end_point">end_point</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_point]&#8288;</code>
</p>
<p>0-indexed points for the start and end of the range, respectively.</p>
</td></tr>
<tr><td><code id="ranges_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_range]&#8288;</code>
</p>
<p>A range.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>range()</code> returns a new range.
</p>
</li>
<li> <p><code>range_start_byte()</code> and <code>range_end_byte()</code> return a single double.
</p>
</li>
<li> <p><code>range_start_point()</code> and <code>range_end_point()</code> return a <code><a href="#topic+point">point()</a></code>.
</p>
</li>
<li> <p><code>is_range()</code> returns <code>TRUE</code> or <code>FALSE</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+node_range">node_range()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- range(5, point(1, 3), 7, point(1, 5))
x

range_start_byte(x)
range_end_byte(x)

range_start_point(x)
range_end_point(x)

is_range(x)
</code></pre>

<hr>
<h2 id='text_parse'>Parse a snippet of text</h2><span id='topic+text_parse'></span>

<h3>Description</h3>

<p><code>text_parse()</code> is a convenience utility for quickly parsing a small snippet
of text using a particular language and getting access to its root node. It
is meant for demonstration purposes. If you are going to need to reparse the
text after an edit has been made, you should create a full parser with
<code><a href="#topic+parser">parser()</a></code> and use <code><a href="#topic+parser_parse">parser_parse()</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_parse(x, language)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_parse_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[string]&#8288;</code>
</p>
<p>The text to parse.</p>
</td></tr>
<tr><td><code id="text_parse_+3A_language">language</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_language]&#8288;</code>
</p>
<p>The language to parse with.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A root node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
language &lt;- treesitter.r::language()
text &lt;- "map(xs, function(x) 1 + 1)"

# Note that this directly returns the root node, not the tree
text_parse(text, language)

</code></pre>

<hr>
<h2 id='tree_root_node'>Retrieve the root node of the tree</h2><span id='topic+tree_root_node'></span>

<h3>Description</h3>

<p><code>tree_root_node()</code> is the entry point for accessing nodes within
a specific tree. It returns the &quot;root&quot; of the tree, from which you
can use other <code style="white-space: pre;">&#8288;node_*()&#8288;</code> functions to navigate around.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree_root_node(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree_root_node_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_tree]&#8288;</code>
</p>
<p>A tree.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
language &lt;- treesitter.r::language()
parser &lt;- parser(language)

text &lt;- "fn &lt;- function() { 1 + 1 }"
tree &lt;- parser_parse(parser, text)
node &lt;- tree_root_node(tree)

# Trees and nodes have a similar print method, but you can
# only use other `node_*()` functions on nodes.
tree
node

node |&gt;
  node_child(1) |&gt;
  node_children()

</code></pre>

<hr>
<h2 id='tree_root_node_with_offset'>Retrieve an offset root node</h2><span id='topic+tree_root_node_with_offset'></span>

<h3>Description</h3>

<p><code>tree_root_node_with_offset()</code> is similar to <code><a href="#topic+tree_root_node">tree_root_node()</a></code>,
but the returned root node's position has been shifted by the given number of
bytes, rows, and columns.
</p>
<p>This function allows you to parse a subset of a document with
<code><a href="#topic+parser_parse">parser_parse()</a></code> as if it were a self-contained document, but then later
access the syntax tree in the coordinate space of the larger document.
</p>
<p>Note that the underlying <code>text</code> within <code>x</code> is not what you are offsetting
into. Instead, you should assume that the <code>text</code> you provided to
<code><a href="#topic+parser_parse">parser_parse()</a></code> already contained the entire subset of the document you care
about, and the offset you are providing is how far into the document the
beginning of <code>text</code> is.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree_root_node_with_offset(x, byte, point)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree_root_node_with_offset_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_tree]&#8288;</code>
</p>
<p>A tree.</p>
</td></tr>
<tr><td><code id="tree_root_node_with_offset_+3A_byte">byte</code>, <code id="tree_root_node_with_offset_+3A_point">point</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[double(1), tree_sitter_point]&#8288;</code>
</p>
<p>A byte and point offset combination.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An offset root node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
language &lt;- treesitter.r::language()
parser &lt;- parser(language)

text &lt;- "fn &lt;- function() { 1 + 1 }"
tree &lt;- parser_parse(parser, text)

# If `text` was the whole document, you can just use `tree_root_node()`
node &lt;- tree_root_node(tree)

# If `text` represents a subset of the document, use
# `tree_root_node_with_offset()` to be able to get positions in the
# coordinate space of the original document.
byte &lt;- 5
point &lt;- point(5, 0)
node_offset &lt;- tree_root_node_with_offset(tree, byte, point)

# The position of `fn` if you treat `text` as the whole document
node |&gt;
  node_child(1) |&gt;
  node_child(1)

# The position of `fn` if you treat `text` as a subset of a larger document
node_offset |&gt;
  node_child(1) |&gt;
  node_child(1)

</code></pre>

<hr>
<h2 id='tree_walk'>Generate a <code>TreeCursor</code> iterator</h2><span id='topic+tree_walk'></span>

<h3>Description</h3>

<p><code>tree_walk()</code> creates a <a href="#topic+TreeCursor">TreeCursor</a> starting at the root node. You can
use it to &quot;walk&quot; the tree more efficiently than using <code><a href="#topic+node_child">node_child()</a></code> and
other similar node functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree_walk(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree_walk_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_tree]&#8288;</code>
</p>
<p>A tree.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>TreeCursor</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
language &lt;- treesitter.r::language()
parser &lt;- parser(language)

text &lt;- "1 + foo"
tree &lt;- parser_parse(parser, text)

cursor &lt;- tree_walk(tree)

cursor$goto_first_child()
cursor$goto_first_child()
cursor$node()
cursor$goto_next_sibling()
cursor$node()

</code></pre>

<hr>
<h2 id='tree-accessors'>Tree accessors</h2><span id='topic+tree-accessors'></span><span id='topic+tree_included_ranges'></span><span id='topic+tree_text'></span><span id='topic+tree_language'></span>

<h3>Description</h3>


<ul>
<li> <p><code>tree_text()</code> retrieves the tree's <code>text</code> that it was parsed with.
</p>
</li>
<li> <p><code>tree_language()</code> retrieves the tree's <code>language</code> that it was parsed with.
</p>
</li>
<li> <p><code>tree_included_ranges()</code> retrieves the tree's <code>included_ranges</code> that were
provided to <code><a href="#topic+parser_set_included_ranges">parser_set_included_ranges()</a></code>. Note that if no ranges were
provided originally, then this still returns a default that always covers
the entire document.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>tree_included_ranges(x)

tree_text(x)

tree_language(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tree-accessors_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_tree]&#8288;</code>
</p>
<p>A tree.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>tree_text()</code> returns a string.
</p>
</li>
<li> <p><code>tree_language()</code> returns a <code>tree_sitter_language</code>.
</p>
</li>
<li> <p><code>tree_included_ranges()</code> returns a list of <code><a href="#topic+range">range()</a></code> objects.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
language &lt;- treesitter.r::language()
parser &lt;- parser(language)

text &lt;- "1 + foo"
tree &lt;- parser_parse(parser, text)

tree_text(tree)
tree_language(tree)
tree_included_ranges(tree)

</code></pre>

<hr>
<h2 id='TreeCursor'>Tree cursors</h2><span id='topic+TreeCursor'></span>

<h3>Description</h3>

<p><code>TreeCursor</code> is an R6 class that allows you to walk a tree in a more
efficient way than calling <code style="white-space: pre;">&#8288;node_*()&#8288;</code> functions like <code><a href="#topic+node_child">node_child()</a></code>
repeatedly.
</p>
<p>You can also more elegantly create a cursor with <code><a href="#topic+node_walk">node_walk()</a></code> and
<code><a href="#topic+tree_walk">tree_walk()</a></code>.
</p>


<h3>Value</h3>

<p>R6 object representing the tree cursor.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-tree_sitter_tree_cursor-new"><code>TreeCursor$new()</code></a>
</p>
</li>
<li> <p><a href="#method-tree_sitter_tree_cursor-reset"><code>TreeCursor$reset()</code></a>
</p>
</li>
<li> <p><a href="#method-tree_sitter_tree_cursor-node"><code>TreeCursor$node()</code></a>
</p>
</li>
<li> <p><a href="#method-tree_sitter_tree_cursor-field_name"><code>TreeCursor$field_name()</code></a>
</p>
</li>
<li> <p><a href="#method-tree_sitter_tree_cursor-field_id"><code>TreeCursor$field_id()</code></a>
</p>
</li>
<li> <p><a href="#method-tree_sitter_tree_cursor-descendant_index"><code>TreeCursor$descendant_index()</code></a>
</p>
</li>
<li> <p><a href="#method-tree_sitter_tree_cursor-goto_parent"><code>TreeCursor$goto_parent()</code></a>
</p>
</li>
<li> <p><a href="#method-tree_sitter_tree_cursor-goto_next_sibling"><code>TreeCursor$goto_next_sibling()</code></a>
</p>
</li>
<li> <p><a href="#method-tree_sitter_tree_cursor-goto_previous_sibling"><code>TreeCursor$goto_previous_sibling()</code></a>
</p>
</li>
<li> <p><a href="#method-tree_sitter_tree_cursor-goto_first_child"><code>TreeCursor$goto_first_child()</code></a>
</p>
</li>
<li> <p><a href="#method-tree_sitter_tree_cursor-goto_last_child"><code>TreeCursor$goto_last_child()</code></a>
</p>
</li>
<li> <p><a href="#method-tree_sitter_tree_cursor-depth"><code>TreeCursor$depth()</code></a>
</p>
</li>
<li> <p><a href="#method-tree_sitter_tree_cursor-goto_first_child_for_byte"><code>TreeCursor$goto_first_child_for_byte()</code></a>
</p>
</li>
<li> <p><a href="#method-tree_sitter_tree_cursor-goto_first_child_for_point"><code>TreeCursor$goto_first_child_for_point()</code></a>
</p>
</li></ul>


<hr>
<a id="method-tree_sitter_tree_cursor-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new tree cursor.
</p>


<h5>Usage</h5>

<div class="r"><pre>TreeCursor$new(node)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>node</code></dt><dd><p><code style="white-space: pre;">&#8288;[tree_sitter_node]&#8288;</code>
</p>
<p>The node to start walking from.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-tree_sitter_tree_cursor-reset"></a>



<h4>Method <code>reset()</code></h4>

<p>Reset the tree cursor to a new root node.
</p>


<h5>Usage</h5>

<div class="r"><pre>TreeCursor$reset(node)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>node</code></dt><dd><p><code style="white-space: pre;">&#8288;[tree_sitter_node]&#8288;</code>
</p>
<p>The node to start walking from.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-tree_sitter_tree_cursor-node"></a>



<h4>Method <code>node()</code></h4>

<p>Get the current node that the cursor points to.
</p>


<h5>Usage</h5>

<div class="r"><pre>TreeCursor$node()</pre></div>


<hr>
<a id="method-tree_sitter_tree_cursor-field_name"></a>



<h4>Method <code>field_name()</code></h4>

<p>Get the field name of the current node.
</p>


<h5>Usage</h5>

<div class="r"><pre>TreeCursor$field_name()</pre></div>


<hr>
<a id="method-tree_sitter_tree_cursor-field_id"></a>



<h4>Method <code>field_id()</code></h4>

<p>Get the field id of the current node.
</p>


<h5>Usage</h5>

<div class="r"><pre>TreeCursor$field_id()</pre></div>


<hr>
<a id="method-tree_sitter_tree_cursor-descendant_index"></a>



<h4>Method <code>descendant_index()</code></h4>

<p>Get the descendent index of the current node.
</p>


<h5>Usage</h5>

<div class="r"><pre>TreeCursor$descendant_index()</pre></div>


<hr>
<a id="method-tree_sitter_tree_cursor-goto_parent"></a>



<h4>Method <code>goto_parent()</code></h4>

<p>Go to the current node's parent.
</p>
<p>Returns <code>TRUE</code> if a parent was found, and <code>FALSE</code> if not.
</p>


<h5>Usage</h5>

<div class="r"><pre>TreeCursor$goto_parent()</pre></div>


<hr>
<a id="method-tree_sitter_tree_cursor-goto_next_sibling"></a>



<h4>Method <code>goto_next_sibling()</code></h4>

<p>Go to the current node's next sibling.
</p>
<p>Returns <code>TRUE</code> if a sibling was found, and <code>FALSE</code> if not.
</p>


<h5>Usage</h5>

<div class="r"><pre>TreeCursor$goto_next_sibling()</pre></div>


<hr>
<a id="method-tree_sitter_tree_cursor-goto_previous_sibling"></a>



<h4>Method <code>goto_previous_sibling()</code></h4>

<p>Go to the current node's previous sibling.
</p>
<p>Returns <code>TRUE</code> if a sibling was found, and <code>FALSE</code> if not.
</p>


<h5>Usage</h5>

<div class="r"><pre>TreeCursor$goto_previous_sibling()</pre></div>


<hr>
<a id="method-tree_sitter_tree_cursor-goto_first_child"></a>



<h4>Method <code>goto_first_child()</code></h4>

<p>Go to the current node's first child.
</p>
<p>Returns <code>TRUE</code> if a child was found, and <code>FALSE</code> if not.
</p>


<h5>Usage</h5>

<div class="r"><pre>TreeCursor$goto_first_child()</pre></div>


<hr>
<a id="method-tree_sitter_tree_cursor-goto_last_child"></a>



<h4>Method <code>goto_last_child()</code></h4>

<p>Go to the current node's last child.
</p>
<p>Returns <code>TRUE</code> if a child was found, and <code>FALSE</code> if not.
</p>


<h5>Usage</h5>

<div class="r"><pre>TreeCursor$goto_last_child()</pre></div>


<hr>
<a id="method-tree_sitter_tree_cursor-depth"></a>



<h4>Method <code>depth()</code></h4>

<p>Get the depth of the current node.
</p>


<h5>Usage</h5>

<div class="r"><pre>TreeCursor$depth()</pre></div>


<hr>
<a id="method-tree_sitter_tree_cursor-goto_first_child_for_byte"></a>



<h4>Method <code>goto_first_child_for_byte()</code></h4>

<p>Move the cursor to the first child of its current node that extends
beyond the given byte offset.
</p>
<p>Returns <code>TRUE</code> if a child was found, and <code>FALSE</code> if not.
</p>


<h5>Usage</h5>

<div class="r"><pre>TreeCursor$goto_first_child_for_byte(byte)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>byte</code></dt><dd><p><code style="white-space: pre;">&#8288;[double(1)]&#8288;</code>
</p>
<p>The byte to move the cursor past.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-tree_sitter_tree_cursor-goto_first_child_for_point"></a>



<h4>Method <code>goto_first_child_for_point()</code></h4>

<p>Move the cursor to the first child of its current node that extends
beyond the given point.
</p>
<p>Returns <code>TRUE</code> if a child was found, and <code>FALSE</code> if not.
</p>


<h5>Usage</h5>

<div class="r"><pre>TreeCursor$goto_first_child_for_point(point)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>point</code></dt><dd><p><code style="white-space: pre;">&#8288;[tree_sitter_point]&#8288;</code>
</p>
<p>The point to move the cursor past.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
language &lt;- treesitter.r::language()
parser &lt;- parser(language)

text &lt;- "fn &lt;- function(a, b) { a + b }"

tree &lt;- parser_parse(parser, text)
node &lt;- tree_root_node(tree)

cursor &lt;- TreeCursor$new(node)

cursor$node()
cursor$goto_first_child()
cursor$goto_first_child()
cursor$node()
cursor$goto_next_sibling()
cursor$node()

</code></pre>

<hr>
<h2 id='x_tree_sitter_node'>Helper page for consistent documentation</h2><span id='topic+x_tree_sitter_node'></span>

<h3>Description</h3>

<p>Helper page for consistent documentation
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="x_tree_sitter_node_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_node]&#8288;</code>
</p>
<p>A node.</p>
</td></tr>
</table>

<hr>
<h2 id='x_tree_sitter_parser'>Helper page for consistent documentation</h2><span id='topic+x_tree_sitter_parser'></span>

<h3>Description</h3>

<p>Helper page for consistent documentation
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="x_tree_sitter_parser_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_parser]&#8288;</code>
</p>
<p>A parser.</p>
</td></tr>
</table>

<hr>
<h2 id='x_tree_sitter_query'>Helper page for consistent documentation</h2><span id='topic+x_tree_sitter_query'></span>

<h3>Description</h3>

<p>Helper page for consistent documentation
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="x_tree_sitter_query_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_query]&#8288;</code>
</p>
<p>A query.</p>
</td></tr>
</table>

<hr>
<h2 id='x_tree_sitter_tree'>Helper page for consistent documentation</h2><span id='topic+x_tree_sitter_tree'></span>

<h3>Description</h3>

<p>Helper page for consistent documentation
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="x_tree_sitter_tree_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[tree_sitter_tree]&#8288;</code>
</p>
<p>A tree.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
