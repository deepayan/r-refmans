<!DOCTYPE html><html lang="en"><head><title>Help for package timedelay</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {timedelay}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#timedelay'><p>Time Delay Estimation for Stochastic Time Series of Gravitationally Lensed Quasars</p></a></li>
<li><a href='#bayesian'><p>Estimating the time delay via the Bayesian method</p></a></li>
<li><a href='#bayesian.multiband'><p>Estimating the time delay between doubly-lensed multi-band light curves in a Bayesian way</p></a></li>
<li><a href='#entirelogprofilelikelihood'><p>Calculating the entire profilel likelihood curve over the given grid values of the time delay</p></a></li>
<li><a href='#simple'>
<p>Simulated simple data of a doubly-lensed quasar</p></a></li>
<li><a href='#simple.band1'>
<p>Simulated simple data of a doubly-lensed quasar observed in band 1</p></a></li>
<li><a href='#simple.band2'>
<p>Simulated simple data of a doubly-lensed quasar observed in band 2</p></a></li>
<li><a href='#timedelay-internal'><p>Internal <code>bayesian</code> functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.0.11</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-05-18</td>
</tr>
<tr>
<td>Title:</td>
<td>Time Delay Estimation for Stochastic Time Series of
Gravitationally Lensed Quasars</td>
</tr>
<tr>
<td>Author:</td>
<td>Hyungsuk Tak, Kaisey Mandel, David A. van Dyk, Vinay L. Kashyap, Xiao-Li Meng, Aneta Siemiginowska, and Zhirui Hu</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hyungsuk Tak &lt;hyungsuk.tak@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS (&ge; 7.3-51.3), mvtnorm(&ge; 1.0-11)</td>
</tr>
<tr>
<td>Description:</td>
<td>We provide a toolbox to estimate the time delay between the brightness time series of gravitationally lensed quasar images via Bayesian and profile likelihood approaches. The model is based on a state-space representation for  irregularly observed time series data generated from a latent continuous-time Ornstein-Uhlenbeck process. Our Bayesian method adopts scientifically motivated hyper-prior distributions and a Metropolis-Hastings within Gibbs sampler, producing posterior samples of the model parameters that include the time delay. A profile likelihood of the time delay is a simple approximation to the marginal posterior distribution of the time delay. Both Bayesian and profile likelihood approaches complement each other, producing almost identical results; the Bayesian way is more principled but the profile likelihood is easier to implement. A new functionality is added in version 1.0.9 for estimating the time delay between doubly-lensed light curves observed in two bands. See also Tak et al. (2017) &lt;<a href="https://doi.org/10.1214%2F17-AOAS1027">doi:10.1214/17-AOAS1027</a>&gt;, Tak et al. (2018) &lt;<a href="https://doi.org/10.1080%2F10618600.2017.1415911">doi:10.1080/10618600.2017.1415911</a>&gt;, Hu and Tak (2020) &lt;<a href="https://doi.org/10.48550/arXiv.2005.08049">doi:10.48550/arXiv.2005.08049</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-05-19 03:27:07 UTC; hyungsuktak</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-05-19 11:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='timedelay'>Time Delay Estimation for Stochastic Time Series of Gravitationally Lensed Quasars</h2><span id='topic+timedelay-package'></span><span id='topic+timedelay'></span>

<h3>Description</h3>

<p>The R package <span class="pkg">timedelay</span> provides a toolbox to estimate the time delay between the brightness time series of gravitationally lensed quasar images via Bayesian and profile likelihood approaches. The model is based on a state-space representation for irregularly observed time series data generated from a latent continuous-time Ornstein-Uhlenbeck process. Our Bayesian method adopts scientifically motivated hyper-prior distributions and a Metropoli-Hastings within Gibbs sampler, producing posterior samples of the model parameters that include the time delay. A profile likelihood of the time delay is a simple approximation to the marginal posterior distribution of the time delay. Both Bayesian and profile likelihood approaches complement each other, producing almost identical results; the Bayesian way is more principled but the profile likelihood is easier to be implemented. A new functionality is added in version 1.0.9 for estimating the time delay between doubly-lensed light curves observed in two bands.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
    Package: </td><td style="text-align: left;"> timedelay</td>
</tr>
<tr>
 <td style="text-align: left;">
    Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
    Version: </td><td style="text-align: left;"> 1.0.11</td>
</tr>
<tr>
 <td style="text-align: left;">
    Date: </td><td style="text-align: left;"> 2020-05-18</td>
</tr>
<tr>
 <td style="text-align: left;">
    License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
    Main functions: </td><td style="text-align: left;"> <code><a href="#topic+bayesian">bayesian</a></code>, <code><a href="#topic+bayesian.multiband">bayesian.multiband</a></code>, <code><a href="#topic+entirelogprofilelikelihood">entirelogprofilelikelihood</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Hyungsuk Tak, Kaisey Mandel, David A. van Dyk, Vinay L. Kashyap, Xiao-Li Meng, and Aneta Siemiginowska
</p>
<p>Maintainer: Hyungsuk Tak &lt;hyungsuk.tak@gmail.com&gt;
</p>


<h3>References</h3>

<p>Hyungsuk Tak, Kaisey Mandel, David A. van Dyk, Vinay L. Kashyap, Xiao-Li Meng, and Aneta Siemiginowska (2017). &quot;Bayesian Estimates of Astronomical Time Delays between Gravitationally Lensed Stochastic Light Curves,&quot; The Annals of Applied Statistics, 11 (3), 1309-1348.
Hyungsuk Tak, Xiao-Li Meng, and David A. van Dyk (2018), &quot;A Repelling-Attracting Metropolis Algorithm for Multimodality&quot;, Journal of Computational and Graphical Statistics, 27 (3), 479-490.
Zhirui Hu and Hyungsuk Tak (2020+), &quot;Modeling Stochastic Variability in  Multi-Band Time Series Data,&quot; arXiv:2005.08049.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # Loading datasets
  data(simple)
  head(simple)

  # Subset (data for image A) of the typical quasar data set
  lcA &lt;- simple[, 1 : 3]

  # Another subset (data for image B) of the typical quasar data set
  # The observation times for image B are not necessarily the same as those for image A
  lcB &lt;- simple[, c(1, 4, 5)]

  # The two subsets do not need to have the same number of observations
  # For example, here we add one more observation time for image B
  lcB &lt;- rbind(lcB, c(290, 1.86, 0.006))

  dim(lcA)
  dim(lcB)

  ###############################################
  # Time delay estimation via Bayesian approach #
  ###############################################


  # Cubic microlensing model (m = 3)
  output &lt;- bayesian(data.lcA = lcA, data.lcB = lcB, 
                     data.flux = FALSE, theta.ini = c(0, 0.01, 200), 
                     delta.ini = 50, delta.uniform.range = c(0, 100), 
                     delta.proposal.scale = 1, 
                     tau.proposal.scale = 3, 
                     tau.prior.shape = 1, tau.prior.scale = 1,
                     sigma.prior.shape = 1, sigma.prior.scale = 2 / 10^7, 
                     asis = TRUE, micro = 3,
                     sample.size = 100, warmingup.size = 50)

  names(output)
  # hist(output$delta)
  # plot(output$delta, type = "l")
  # acf(output$delta)

  ### Argument description

  # data.lcA: An n1 by three matrix for image A (light curve A) with 
  #           n1 observation times in the first column,
  #           n1 observed magnitudes (or in flux) in the second column,
  #           n1 measurement errors for image A in the third column.

  # data.lcB: An n2 by three matrix for image B (light curve B) with 
  #           n2 observation times in the first column,
  #           n2 observed magnitudes (or in flux) in the second column,
  #           n2 measurement errors for image A in the third column.

  # data.flux: "True" if data are recorded on flux scale or "FALSE" if data are on magnitude scale.
  # If your observed time series can take on negative values, then data.flux = FALSE.

  # theta.ini: Initial values of theta = (mu, sigma, tau) for MCMC.
  # delta.ini: Initial values of the time delay for MCMC.
  # delta.uniform.range: The range of the Uniform prior distribution for the time delay.
  #                      The feasible entire support is 
  #                      c(min(simple[, 1]) - max(simple[, 1]), max(simple[, 1]) - min(simple[, 1]))

  # delta.proposal.scale: The proposal scale of the Metropolis step for the time delay.
  # tau.proposal.scale: The proposal scale of the Metropolis-Hastings step for tau.

  # tau.prior.shape: The shape parameter of the Inverse-Gamma hyper-prior distribution for tau. 
  # tau.prior.scale: The scale parameter of the Inverse-Gamma hyper-prior distribution for tau. 
  # sigma.prior.shape: The shape parameter of 
  #                    the Inverse-Gamma hyper-prior distribution for sigma^2.
  # sigma.prior.scale: The scale parameter of 
  #                    the Inverse-Gamma hyper-prior distribution for sigma^2.
  # micro: It determines the order of a polynomial regression model that accounts 
  #        for the difference between microlensing trends. Default is 3. 
  #        When zero is assigned, the Bayesian model fits a curve-shifted model.

  # asis: "TRUE" if we use the ancillarity-sufficiency interweaving strategy (ASIS) 
  #       for c (always recommended)
  # multimodality: "TRUE" if we use the repelling-attracting Metropolis algorithm
  #                for sampling Delta in the presence of multimodality.
  #                Please make sure that "adaptive.delta = FALSE" so that 
  #                adaptive MCMC for Delta is not used in the presence of multimodality.

  # adaptive.freqeuncy: The adaptive MCMC is applied for every specified frequency. 
  #                     If it is specified as 100, 
  #                     the adaptive MCMC is applied to every 100th iterstion.
  # adaptive.delta: "TRUE" if we use the adaptive MCMC for the time delay.
  # adaptive.delta.factor: The factor, exp(adaptive.delta.factor) or exp(-adaptive.delta.factor), 
  #                        multiplied to the proposal scale of the time delay for adaptive MCMC.
  #                        Default is 0.01.

  # adaptive.tau: "TRUE" if we use the adaptive MCMC for tau.
  # adaptive.tau.factor: The factor, exp(adaptive.tau.factor) or exp(-adaptive.tau.factor), 
  #                      multiplied to the proposal scale of tau for adaptive MCMC.

  # sample.size: The number of posterior samples for each parameter
  # warmingup.size: The number of burn-ins

  # Type ?bayesian for further details on graphical model checking.

  ################################################
  # Time delay estimation via profile likelihood #
  ################################################

  ###### The entire profile likelihood values on the grid of values of the time delay.


  # Cubic microlensing model
  ti1 &lt;- lcB[, 1]
  ti2 &lt;- lcB[, 1]^2
  ti3 &lt;- lcB[, 1]^3
  ss &lt;- lm(lcB[, 2] - mean(lcA[, 2]) ~ ti1 + ti2 + ti3)

  initial &lt;- c(mean(lcA[, 2]), log(0.01), log(200), ss$coefficients)
  delta.uniform.range &lt;- c(0, 100)
  grid &lt;- seq(0, 100, by = 0.1) 
  # grid interval "by = 0.1" is recommended for accuracy,
  # but users can set a finer grid of values of the time delay.

  ###  Running the following codes takes more time than CRAN policy
  ###  Please type the following lines without "#" to run the function and to see the results

  #  logprof &lt;- entirelogprofilelikelihood(data.lcA = lcA, data.lcB = lcB, grid = grid, 
  #                                        initial = initial, data.flux = FALSE, 
  #                                        delta.uniform.range = delta.uniform.range, micro = 3)

  #  plot(grid, logprof, type = "l", 
  #       xlab = expression(bold(Delta)),       
  #       ylab = expression(bold(paste("log L"[prof], "(", Delta, ")"))))
  #  prof &lt;- exp(logprof - max(logprof))  # normalization
  #  plot(grid, prof, type = "l", 
  #       xlab = expression(bold(Delta)),       
  #       ylab = expression(bold(paste("L"[prof], "(", Delta, ")"))))

  ### Argument description

  # data.lcA: The data set (n by 3 matrix) for light curve A 
  # (1st column: observation times, 2nd column: values of fluxes or magnitudes,
  #  3rd column: measurement errors)
  # data.lcB: The data set (w by 3 matrix) for light curve B 
  # (1st column: observation times, 2nd column: values of fluxes or magnitudes,
  #  3rd column: measurement errors)
  # grid: the vector of grid values of the time delay 
  #       on which the log profile likelihood values are calculated.
  # initial: The initial values of the other model parameters (mu, log(sigma), log(tau), beta)
  # data.flux: "True" if data are recorded on flux scale or "FALSE" if data are on magnitude scale.
  # delta.uniform.range: The range of the Uniform prior distribution for the time delay.
  # micro: It determines the order of a polynomial regression model that accounts 
  #        for the difference between microlensing trends. Default is 3. 
  #        When zero is assigned, the Bayesian model fits a curve-shifted model.

</code></pre>

<hr>
<h2 id='bayesian'>Estimating the time delay via the Bayesian method</h2><span id='topic+bayesian'></span>

<h3>Description</h3>

<p><code>bayesian</code> produces posterior samples of all the model parameters including the time delay. This function has options for three Markov chain Monte Carlo (MCMC) techniques; (i) ancillarity-sufficiency interweaving strategy (ASIS) and (ii) adaptive MCMC to improve the convergence rate, and (iii) repelling-attracting Metropolis for multimodality. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayesian(data.lcA, data.lcB, data.flux, theta.ini, 
   delta.ini, delta.uniform.range, delta.proposal.scale, 
   tau.proposal.scale, tau.prior.shape = 1, tau.prior.scale = 1,
   sigma.prior.shape = 1, sigma.prior.scale = 1e-7, 
   asis = TRUE, micro, multimodality = FALSE, 
   adaptive.frequency, adaptive.delta =  TRUE, adaptive.delta.factor,
   adaptive.tau = TRUE, adaptive.tau.factor,
   sample.size, warmingup.size)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bayesian_+3A_data.lca">data.lcA</code></td>
<td>

<p>A (<code class="reqn">n_1</code> by 3) matrix for image A (light curve A); the first column has <code class="reqn">n_1</code> observation times, the second column contains <code class="reqn">n_1</code> flux (or magnitude) values, the third column includes <code class="reqn">n_1</code> measurement errors.
</p>
</td></tr>
<tr><td><code id="bayesian_+3A_data.lcb">data.lcB</code></td>
<td>

<p>A (<code class="reqn">n_2</code> by 3) matrix for image B (light curve B); the first column has <code class="reqn">n_2</code> observation times, the second column contains <code class="reqn">n_2</code> flux (or magnitude) values, the third column includes <code class="reqn">n_2</code> measurement errors.
</p>
</td></tr>
<tr><td><code id="bayesian_+3A_data.flux">data.flux</code></td>
<td>

<p>&quot;True&quot; if data are recorded on flux scale or &quot;FALSE&quot; if data are on magnitude scale. Simply speaking, if your observed time series can take on negative values, then data.flux = FALSE.
</p>
</td></tr>
<tr><td><code id="bayesian_+3A_theta.ini">theta.ini</code></td>
<td>

<p>Initial values of the OU parameters, (<code class="reqn">\mu</code>, <code class="reqn">\sigma</code>, <code class="reqn">\tau</code>).
</p>
</td></tr>
<tr><td><code id="bayesian_+3A_delta.ini">delta.ini</code></td>
<td>

<p>Initial value of the time delay, <code class="reqn">\Delta</code>.
</p>
</td></tr>
<tr><td><code id="bayesian_+3A_delta.uniform.range">delta.uniform.range</code></td>
<td>

<p>The range of the Uniform prior distribution for the time delay.
</p>
</td></tr>
<tr><td><code id="bayesian_+3A_delta.proposal.scale">delta.proposal.scale</code></td>
<td>

<p>The proposal scale of the Metropolis step for the time delay.
</p>
</td></tr>
<tr><td><code id="bayesian_+3A_tau.proposal.scale">tau.proposal.scale</code></td>
<td>

<p>The proposal scale of the Metropolis-Hastings step for <code class="reqn">\tau</code>.
</p>
</td></tr>
<tr><td><code id="bayesian_+3A_tau.prior.shape">tau.prior.shape</code></td>
<td>

<p>The shape parameter of the Inverse-Gamma hyper-prior distribution for <code class="reqn">\tau</code>. Default is 1.
</p>
</td></tr>
<tr><td><code id="bayesian_+3A_tau.prior.scale">tau.prior.scale</code></td>
<td>

<p>The scale parameter of the Inverse-Gamma hyper-prior distribution for <code class="reqn">\tau</code>. Default is 1.
</p>
</td></tr>
<tr><td><code id="bayesian_+3A_sigma.prior.shape">sigma.prior.shape</code></td>
<td>

<p>The shape parameter of the Inverse-Gamma hyper-prior distribution for <code class="reqn">\sigma^2</code>.  Default is 1.
</p>
</td></tr>
<tr><td><code id="bayesian_+3A_sigma.prior.scale">sigma.prior.scale</code></td>
<td>

<p>The scale parameter of the Inverse-Gamma hyper-prior distribution for <code class="reqn">\sigma^2</code>. Default is 1e-7.
</p>
</td></tr>
<tr><td><code id="bayesian_+3A_asis">asis</code></td>
<td>

<p>(Optional) &quot;TRUE&quot; if we use the ancillarity-sufficiency interweaving strategy (ASIS) for c (always recommended). Default is &quot;TRUE&quot;.
</p>
</td></tr>
<tr><td><code id="bayesian_+3A_micro">micro</code></td>
<td>

<p>It determines the order of a polynomial regression model that accounts for the difference between microlensing trends. Default is 3. When zero is assigned, the Bayesian model fits a curve-shifted model.
</p>
</td></tr>
<tr><td><code id="bayesian_+3A_multimodality">multimodality</code></td>
<td>

<p>(Optional) &quot;TRUE&quot; if we use a repelling-attracting Metropolis algorithm for sampling Delta. When it is &quot;TRUE&quot; it is recommended that adaptive.delta = FALSE so that the adaptive MCMC is not used in the presence of multimodality. Default is &quot;FALSE&quot;. 
</p>
</td></tr>
<tr><td><code id="bayesian_+3A_adaptive.frequency">adaptive.frequency</code></td>
<td>

<p>(If &quot;adaptive.delta = TRUE&quot; or &quot;adaptive.tau = TRUE&quot;) The adaptive MCMC is applied for every specified frequency. If it is specified as 500, the adaptive MCMC is applied to every 500th iterstion.
</p>
</td></tr>
<tr><td><code id="bayesian_+3A_adaptive.delta">adaptive.delta</code></td>
<td>

<p>(Optional) &quot;TRUE&quot; if we use the adaptive MCMC for the time delay. Default is &quot;TRUE&quot;.
</p>
</td></tr>
<tr><td><code id="bayesian_+3A_adaptive.delta.factor">adaptive.delta.factor</code></td>
<td>

<p>(If &quot;adaptive.delta = TRUE&quot;) The factor, exp(<code class="reqn">\pm</code>adaptive.delta.factor), multiplied by the proposal scale of the time delay for adaptive MCMC.
</p>
</td></tr>
<tr><td><code id="bayesian_+3A_adaptive.tau">adaptive.tau</code></td>
<td>

<p>(Optional) &quot;TRUE&quot; if we use the adaptive MCMC for tau. Default is &quot;TRUE&quot;.
</p>
</td></tr>
<tr><td><code id="bayesian_+3A_adaptive.tau.factor">adaptive.tau.factor</code></td>
<td>

<p>(If &quot;adaptive.tau = TRUE&quot;) The factor, exp(<code class="reqn">\pm</code>adaptive.tau.factor), multiplied by the proposal scale of tau for adaptive MCMC.
</p>
</td></tr>
<tr><td><code id="bayesian_+3A_sample.size">sample.size</code></td>
<td>

<p>The number of the posterior samples of each model parameter.
</p>
</td></tr>
<tr><td><code id="bayesian_+3A_warmingup.size">warmingup.size</code></td>
<td>

<p>The number of burn-in posterior samples.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>bayesian</code> produces posterior samples of the model parameters one of which is the time delay. Please note that when astronomical time series data are loaded on R by <code>read.table</code>, <code>read.csv</code>, etc., some decimal places of the the observation times are automatically rounded because R's default is to load seven effective digits. For example, R will load the observation time 51075.412789 as 51075.41. This default will produce many ties in observation times even though there is actually no tie in observation times. To prevent this, please type &quot;<code>options(digits = 11)</code>&quot; before loading the data if the observation times are in seven effective digits.
</p>


<h3>Value</h3>

<p>The outcome of <code>bayesian</code> comprises of:
</p>
<table role = "presentation">
<tr><td><code>delta</code></td>
<td>
<p>Posterior samples of the time delay</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>Posterior samples of the latent magnitudes</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>Posterior samples of the polynomial regression coefficients, beta</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>Posterior samples of the mean parameter of the O-U process, mu</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>Posterior samples of the short term variability of the O-U process, sigma</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p>Posterior samples of the mean reversion time of the O-U process, tau</p>
</td></tr>
<tr><td><code>tau.accept.rate</code></td>
<td>
<p>The acceptance rate of the MCMC for tau</p>
</td></tr>
<tr><td><code>delta.accept.rate</code></td>
<td>
<p>The acceptance rate of the MCMC for the time delay</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hyungsuk Tak
</p>


<h3>References</h3>

<p>Hyungsuk Tak, Kaisey Mandel, David A. van Dyk, Vinay L. Kashyap, Xiao-Li Meng, and Aneta Siemiginowska (2017). &quot;Bayesian Estimates of Astronomical Time Delays between Gravitationally Lensed Stochastic Light Curves,&quot; The Annals of Applied Statistics, 11 (3), 1309-1348.
Hyungsuk Tak, Xiao-Li Meng, and David A. van Dyk (2018), &quot;A Repelling-Attracting Metropolis Algorithm for Multimodality&quot;, Journal of Computational and Graphical Statistics, 27 (3), 479-490.
Zhirui Hu and Hyungsuk Tak (2020+), &quot;Modeling Stochastic Variability in  Multi-Band Time Series Data,&quot; arXiv:2005.08049.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # Loading datasets
  data(simple)

  # A typical quasar data set  
  head(simple)

  # Subset (data for image A) of the typical quasar data set
  lcA &lt;- simple[, 1 : 3]

  # Another subset (data for image B) of the typical quasar data set
  # The observation times for image B are not necessarily the same as those for image A
  lcB &lt;- simple[, c(1, 4, 5)]

  # The two subsets do not need to have the same number of observations
  # For example, here we add one more observation time for image B
  lcB &lt;- rbind(lcB, c(290, 1.86, 0.006))

  dim(lcA)
  dim(lcB)

  ###############################################
  # Time delay estimation via Bayesian approach #
  ###############################################

  # Cubic microlensing model (m = 3)
  
  output = bayesian(data.lcA = lcA, data.lcB = lcB, 
                    data.flux = FALSE, theta.ini = c(0, 0.01, 200), 
                    delta.ini = 50, delta.uniform.range = c(0, 100), 
                    delta.proposal.scale = 1, 
                    tau.proposal.scale = 3, 
                    tau.prior.shape = 1, tau.prior.scale = 1,
                    sigma.prior.shape = 1, sigma.prior.scale = 2 / 10^7, 
                    asis = TRUE, micro = 3,
                    sample.size = 10, warmingup.size = 10)
  names(output)
  
  # hist(output$delta, 20)
  # plot(output$delta, type = "l")
  # acf(output$delta)
  # output$delta.accept
  # output$tau.accept

  # If multimodality exists, then please add two arguments:
  # multimodality = TRUE, adaptive.delta = FALSE
  # This is to prevent the Markov chain from adapting to a local mode.
  # If we know the distance between the most distant modes,
  # try the smallest value of delta.proposal.scale that still makes 
  # the Markov chain jump between those modes frequently.
  # For example, when the distance is d, then try 
  # delta.proposal.scale = d * 0.7, decreasing or increasing 0.7.

  # Graphical model checking 
  # beta.hat &lt;- colMeans(output$beta)
  # delta.hat &lt;- mean(output$delta)
  # time.x &lt;- lcB[, 1] - delta.hat
  # time.covariate &lt;- cbind(rep(1, length(time.x)), time.x, time.x^2, time.x^3)
  ##### This time.covariate is when micro = 3, a third-order polynomial regression.
  ##### With micro = 0, "time.covariate &lt;- rep(1, length(time.x))" is used.
  # predicted &lt;- time.covariate %*% beta.hat
  # plot(lcA[, 1], lcA[, 2], col = 2)     
  ##### Adjust the range of the x-axis by the argument of plot.
  ##### For example "xlim = c(-1, 2)" 
  # points(lcB[, 1] - delta.hat, lcB[, 2] - predicted, col = 4, pch = 1)
  # for (i in 1 : length(output$delta)) {
  #   temp.time &lt;- c(lcA[, 1], lcB[, 1] - output$delta[i])
  #   points(sort(temp.time), output$X[i, ], 
  #          col = "gray", cex = 0.5, pch = 1, lwd = 0.01)
  # }
  # points(lcA[, 1], lcA[, 2], pch = 0, col = 2, lwd = 1)
  # points(lcB[, 1] - delta.hat, lcB[, 2] - predicted, 
  #        col = 4, pch = 1, lwd = 1)


</code></pre>

<hr>
<h2 id='bayesian.multiband'>Estimating the time delay between doubly-lensed multi-band light curves in a Bayesian way</h2><span id='topic+bayesian.multiband'></span>

<h3>Description</h3>

<p><code>bayesian.multiband</code> produces posterior samples of all the model parameters including the time delay between doubly-lensed multi-band light curves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayesian.multiband(data.band1, data.band2, n.bands = 2,
  theta.ini = c(0.01, 0.01, 100, 100, 0.5),
  delta.ini, delta.uniform.range = c(-500, 500), delta.proposal.scale = 1,
  tau.proposal.scale = 1, tau.prior.shape = 1, tau.prior.scale = 1,
  sigma2.proposal.scale = 0.5, sigma2.prior.shape = 1, sigma2.prior.scale = 1e-7,
  rho.proposal.scale = 0.1, beta.prior.diag = 10 * c(0.1, 0.01, 1e-3, 1e-5)^2,
  micro = 3, timesc = 100, adaptive.frequency = 100,
  adaptive.delta.factor = 0.1, adaptive.tau.factor = 0.1,
  adaptive.sigma2.factor = 0.1, adaptive.rho.factor = 0.1,
  sample.size, warmingup.size)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bayesian.multiband_+3A_data.band1">data.band1</code></td>
<td>

<p>A (<code class="reqn">n_1</code> by 5) matrix composed of the data for doubly-lensed images oberved in band 1; the first column contains <code class="reqn">n_1</code> observation times, the second column contains <code class="reqn">n_1</code> magnitudes for image A, the third column has <code class="reqn">n_1</code> measurement error standard deviations for image A, the fourth column include <code class="reqn">n_1</code> magnitudes for image B, and the fifth column contains <code class="reqn">n_1</code> measurement error standard deviations for image B.
</p>
</td></tr>
<tr><td><code id="bayesian.multiband_+3A_data.band2">data.band2</code></td>
<td>

<p>A (<code class="reqn">n_2</code> by 5) matrix composed of the data for doubly-lensed images oberved in band 2; the first column contains <code class="reqn">n_2</code> observation times, the second column contains <code class="reqn">n_2</code> magnitudes for image A, the third column has <code class="reqn">n_2</code> measurement error standard deviations for image A, the fourth column include <code class="reqn">n_2</code> magnitudes for image B, and the fifth column contains <code class="reqn">n_2</code> measurement error standard deviations for image B.
</p>
</td></tr>
<tr><td><code id="bayesian.multiband_+3A_n.bands">n.bands</code></td>
<td>

<p>The number of bands used to obtain the data. For now, only two bands are allowed. The authors plan to modify the code to allow more bands in the near future.
</p>
</td></tr>
<tr><td><code id="bayesian.multiband_+3A_theta.ini">theta.ini</code></td>
<td>

<p>A vector for initial values of the OU processes for two bands, i.e., (<code class="reqn">\sigma_1</code>, <code class="reqn">\sigma_2</code>, <code class="reqn">\tau_1</code>, <code class="reqn">\tau_2</code>, <code class="reqn">\rho</code>), where <code class="reqn">\sigma_1</code> is the short-term variability (standard deviation) for band 1, <code class="reqn">\sigma_2</code> is the short-term variability (standard deviation) for band 2, <code class="reqn">\tau_1</code> is the timescale for band 1, and <code class="reqn">\tau_2</code> is the timescale for band 2, and <code class="reqn">\rho</code> is the cross-correlation parameter between two bands. Defaults are (<code class="reqn">0.01</code>, <code class="reqn">0.01</code>, 100, 100, 0.5).
</p>
</td></tr>
<tr><td><code id="bayesian.multiband_+3A_delta.ini">delta.ini</code></td>
<td>

<p>Initial values of the time delay.
</p>
</td></tr>
<tr><td><code id="bayesian.multiband_+3A_delta.uniform.range">delta.uniform.range</code></td>
<td>

<p>The range of the Uniform prior distribution for the time delay. Default range is set to <code class="reqn">(-500, 500)</code>.
</p>
</td></tr>
<tr><td><code id="bayesian.multiband_+3A_delta.proposal.scale">delta.proposal.scale</code></td>
<td>

<p>The proposal scale of the Metropolis step for the time delay. Default is 1.
</p>
</td></tr>
<tr><td><code id="bayesian.multiband_+3A_tau.proposal.scale">tau.proposal.scale</code></td>
<td>

<p>The proposal scale of the Metropolis-Hastings step for <code class="reqn">\tau_j</code> (<code class="reqn">j=1, 2</code>) Default is 1.
</p>
</td></tr>
<tr><td><code id="bayesian.multiband_+3A_tau.prior.shape">tau.prior.shape</code></td>
<td>

<p>The shape parameter of the Inverse-Gamma hyper-prior distribution for <code class="reqn">\tau_j</code>. Default is 1.
</p>
</td></tr>
<tr><td><code id="bayesian.multiband_+3A_tau.prior.scale">tau.prior.scale</code></td>
<td>

<p>The scale parameter of the Inverse-Gamma hyper-prior distribution for <code class="reqn">\tau_j</code>. Default is 1.
</p>
</td></tr>
<tr><td><code id="bayesian.multiband_+3A_sigma2.proposal.scale">sigma2.proposal.scale</code></td>
<td>

<p>The proposal scale of the Metropolis-Hastings step for <code class="reqn">\sigma^2_j</code> (<code class="reqn">j=1, 2</code>). Default is 0.5.
</p>
</td></tr>
<tr><td><code id="bayesian.multiband_+3A_sigma2.prior.shape">sigma2.prior.shape</code></td>
<td>

<p>The shape parameter of the Inverse-Gamma hyper-prior distribution for <code class="reqn">\sigma^2_j</code>. Default is 1.
</p>
</td></tr>
<tr><td><code id="bayesian.multiband_+3A_sigma2.prior.scale">sigma2.prior.scale</code></td>
<td>

<p>The scale parameter of the Inverse-Gamma hyper-prior distribution for <code class="reqn">\sigma^2_j</code>. If no prior information is available, we recommend using 1e-7 (default).
</p>
</td></tr>
<tr><td><code id="bayesian.multiband_+3A_rho.proposal.scale">rho.proposal.scale</code></td>
<td>

<p>The proposal scale of the Metropolis-Hastings step for <code class="reqn">\rho</code>. Default is 0.1.
</p>
</td></tr>
<tr><td><code id="bayesian.multiband_+3A_beta.prior.diag">beta.prior.diag</code></td>
<td>

<p>The diagonal elements of the covariance matrix in the multivariate Gaussian prior for <code class="reqn">\beta</code> (polynomial regression coefficients for microlensing adjustment). If such information is not available, these are set to <code>10 * c(0.1)^2</code> if <code>micro = 0</code>, <code>10 * c(0.1, 0.01)^2</code> if <code>micro = 1</code>, <code>10 * c(0.1, 0.01, 1e-3)^2</code> if <code>micro = 2</code>, and <code>10 * c(0.1, 0.01, 1e-3, 1e-5)^2</code> if <code>micro = 3</code>.
</p>
</td></tr>
<tr><td><code id="bayesian.multiband_+3A_micro">micro</code></td>
<td>

<p>A non-negative integer less than or equal to 3. It determines the order of a polynomial regression model that accounts for the long-term trend of microlensing effect. Default is 3.
</p>
</td></tr>
<tr><td><code id="bayesian.multiband_+3A_timesc">timesc</code></td>
<td>

<p>It scales the observation time for fitting polynomial of microlensing, i.e., time / timesc, so that the coefficients are not too small. Default is 100.
</p>
</td></tr>
<tr><td><code id="bayesian.multiband_+3A_adaptive.frequency">adaptive.frequency</code></td>
<td>

<p>The adaptive MCMC is applied for every specified frequency. If it is specified as 500, the adaptive MCMC is applied to every 500th iterstion. Default is 100.
</p>
</td></tr>
<tr><td><code id="bayesian.multiband_+3A_adaptive.delta.factor">adaptive.delta.factor</code></td>
<td>

<p>The factor, exp(<code class="reqn">\pm</code>adaptive.delta.factor), multiplied by the proposal scale of the time delay for adaptive MCMC. Default is 0.1.
</p>
</td></tr>
<tr><td><code id="bayesian.multiband_+3A_adaptive.tau.factor">adaptive.tau.factor</code></td>
<td>

<p>The factor, exp(<code class="reqn">\pm</code>adaptive.tau.factor), multiplied by the proposal scale of <code class="reqn">\tau_j</code> for adaptive MCMC. Default is 0.1.
</p>
</td></tr>
<tr><td><code id="bayesian.multiband_+3A_adaptive.sigma2.factor">adaptive.sigma2.factor</code></td>
<td>

<p>The factor, exp(<code class="reqn">\pm</code>adaptive.tau.factor), multiplied by the proposal scale of <code class="reqn">\sigma^2_j</code> for adaptive MCMC. Default is 0.1.
</p>
</td></tr>
<tr><td><code id="bayesian.multiband_+3A_adaptive.rho.factor">adaptive.rho.factor</code></td>
<td>

<p>The factor, exp(<code class="reqn">\pm</code>adaptive.tau.factor), multiplied by the proposal scale of <code class="reqn">\rho</code> for adaptive MCMC. Default is 0.1.
</p>
</td></tr>
<tr><td><code id="bayesian.multiband_+3A_sample.size">sample.size</code></td>
<td>

<p>The number of the posterior samples of each model parameter.
</p>
</td></tr>
<tr><td><code id="bayesian.multiband_+3A_warmingup.size">warmingup.size</code></td>
<td>

<p>The number of burn-in samples for MCMC.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>bayesian.multiband</code> produces posterior samples of the model parameters, where the time delay (delta) is of primary interest. For now, this function only supports doubly-lensed data observed in two bands. The authors plan to generalize this code to account for more than two bands and more than two lens.
</p>
<p>Please note that when astronomical time series data are loaded on R by <code>read.table</code>, <code>read.csv</code>, etc., some decimal places of the the observation times are automatically rounded because R's default is to load seven effective digits. For example, R will load the observation time 51075.412789 as 51075.41. This default will produce many ties in observation times even though there is actually no tie in observation times. To prevent this, please type &quot;<code>options(digits = 11)</code>&quot; before loading the data if the observation times are in seven effective digits.
</p>


<h3>Value</h3>

<p>The outcomes of <code>bayesian.multiband</code> are composed of:
</p>
<table role = "presentation">
<tr><td><code>delta</code></td>
<td>
<p>A vector for <code class="reqn">m</code> posterior samples of the time delay.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>An <code class="reqn">m</code> by <code class="reqn">k + 1</code> matrix containing posterior samples of the polynomial regression coefficients, where <code class="reqn">m</code> is the size of the posterior sample, and <code class="reqn">k</code> is the polynomial order for microlensing.</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>A vector for <code class="reqn">m</code> posterior samples of the cross-correlation parameter.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>An <code class="reqn">m</code> by <code class="reqn">2</code> matrix containing posterior samples of the short-term variability (standard deviation) of the O-U process. The first column is composed ot the <code class="reqn">m</code> posterior samples of <code class="reqn">\sigma_1</code> in band 1, and the second column contains the <code class="reqn">m</code> posterior samples of <code class="reqn">\sigma_2</code> in band 2.</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p>An <code class="reqn">m</code> by <code class="reqn">2</code> matrix containing posterior samples of the timescale of the O-U process. The first column is composed ot the <code class="reqn">m</code> posterior samples of <code class="reqn">\tau_1</code> in band 1, and the second column contains the <code class="reqn">m</code> posterior samples of <code class="reqn">\tau_2</code> in band 2.</p>
</td></tr>
<tr><td><code>tau.accept.rate</code></td>
<td>
<p>The acceptance rate of the MCMC for <code class="reqn">\tau_1</code> and <code class="reqn">\tau_2</code>.</p>
</td></tr>
<tr><td><code>sigma.accept.rate</code></td>
<td>
<p>The acceptance rate of the MCMC for <code class="reqn">\sigma_1</code> and <code class="reqn">\sigma_2</code>.</p>
</td></tr>
<tr><td><code>delta.accept.rate</code></td>
<td>
<p>The acceptance rate of the MCMC for the time delay</p>
</td></tr>
<tr><td><code>rho.accept.rate</code></td>
<td>
<p>The acceptance rate of the MCMC for <code class="reqn">\rho</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Zhirui Hu and Hyungsuk Tak
</p>


<h3>References</h3>

<p>Hyungsuk Tak, Kaisey Mandel, David A. van Dyk, Vinay L. Kashyap, Xiao-Li Meng, and Aneta Siemiginowska (2017). &quot;Bayesian Estimates of Astronomical Time Delays between Gravitationally Lensed Stochastic Light Curves,&quot; The Annals of Applied Statistics, 11 (3), 1309-1348.
Hyungsuk Tak, Xiao-Li Meng, and David A. van Dyk (2018), &quot;A Repelling-Attracting Metropolis Algorithm for Multimodality&quot;, Journal of Computational and Graphical Statistics, 27 (3), 479-490.
Zhirui Hu and Hyungsuk Tak (2020+), &quot;Modeling Stochastic Variability in  Multi-Band Time Series Data,&quot; arXiv:2005.08049.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # Loading datasets 
  data(simple.band1)
  data(simple.band2)

  # Doubly-lensed quasar data set observed in two bands
  # Each data set contains doubly-lensed light curves observed in one band. 
  head(simple.band1)
  head(simple.band2)

  # The length of each data set (i.e., number of observation times)
  # do not need to be the same.

  dim(simple.band1)
  dim(simple.band2)

  ###############################################
  # Time delay estimation via Bayesian approach #
  ###############################################

  # Cubic microlensing model (m = 3)
  
  output &lt;- bayesian.multiband(data.band1 = simple.band1, 
              data.band2 = simple.band2, n.bands = 2, 
              theta.ini = c(0.01, 0.01, 100, 100, 0.5),
              delta.ini = 100, delta.uniform.range = c(-500, 500), 
              tau.proposal.scale = 1, tau.prior.shape = 1, tau.prior.scale = 1, 
              sigma2.proposal.scale = 0.5, sigma2.prior.shape = 1, sigma2.prior.scale = 1e-7, 
              rho.proposal.scale = 0.1, beta.prior.diag = 10 * c(0.1, 0.01, 1e-3, 1e-5)^2, 
              micro = 3, timesc = 100, adaptive.frequency = 100,
              adaptive.delta.factor = 0.1, adaptive.tau.factor = 0.1,
              adaptive.sigma2.factor = 0.1, adaptive.rho.factor = 0.1,
              sample.size = 100, warmingup.size = 100)
  names(output)
  

  # hist(output$delta, 20)
  # plot(output$delta, type = "l")
  # acf(output$delta)
  # output$delta.accept.rate

</code></pre>

<hr>
<h2 id='entirelogprofilelikelihood'>Calculating the entire profilel likelihood curve over the given grid values of the time delay</h2><span id='topic+entirelogprofilelikelihood'></span>

<h3>Description</h3>

<p><code>entirelogprofilelikelihood</code> calculates the entire profilel likelihood curve over the given grid values of the time delay. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>entirelogprofilelikelihood(data.lcA, data.lcB, grid, 
                                  initial, data.flux, 
                                  delta.uniform.range, micro)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="entirelogprofilelikelihood_+3A_data.lca">data.lcA</code></td>
<td>

<p>A (<code class="reqn">n_1</code> by 3) matrix for image A (light curve A); the first column has <code class="reqn">n_1</code> observation times, the second column contains <code class="reqn">n_1</code> flux (or magnitude) values, the third column includes <code class="reqn">n_1</code> measurement errors.
</p>
</td></tr>
<tr><td><code id="entirelogprofilelikelihood_+3A_data.lcb">data.lcB</code></td>
<td>

<p>A (<code class="reqn">n_2</code> by 3) matrix for image B (light curve B); the first column has <code class="reqn">n_2</code> observation times, the second column contains <code class="reqn">n_2</code> flux (or magnitude) values, the third column includes <code class="reqn">n_2</code> measurement errors.
</p>
</td></tr>
<tr><td><code id="entirelogprofilelikelihood_+3A_grid">grid</code></td>
<td>

<p>A vector containing values of the time delay on which the profile likelihood values are calculated. We recommend using the grid interval equal to 0.1.
</p>
</td></tr>
<tr><td><code id="entirelogprofilelikelihood_+3A_initial">initial</code></td>
<td>

<p>The initial values of the other model parameters (mu, log(sigma), log(tau), beta). We take log on sigma and tau for numerical stability.
</p>
</td></tr>
<tr><td><code id="entirelogprofilelikelihood_+3A_data.flux">data.flux</code></td>
<td>

<p>&quot;True&quot; if data are recorded on flux scale or &quot;FALSE&quot; if data are on magnitude scale.
</p>
</td></tr>
<tr><td><code id="entirelogprofilelikelihood_+3A_delta.uniform.range">delta.uniform.range</code></td>
<td>

<p>The range of the Uniform prior distribution for the time delay.
</p>
</td></tr>
<tr><td><code id="entirelogprofilelikelihood_+3A_micro">micro</code></td>
<td>

<p>It determines the order of a polynomial regression model that accounts for the difference between microlensing trends. Default is 3. When zero is assigned, the Bayesian model fits a curve-shifted model.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>entirelogprofilelikelihood</code> is used to obtain the entire profile likelihood curve over the given grid values of the time delay. 
</p>


<h3>Value</h3>

<p>The outcome of <code>entirelogprofilelikelihood</code> is the values of the log profile likelihood function over the given grid values of the time delay.
</p>


<h3>Author(s)</h3>

<p>Hyungsuk Tak
</p>


<h3>References</h3>

<p>Hyungsuk Tak, Kaisey Mandel, David A. van Dyk, Vinay L. Kashyap, Xiao-Li Meng, and Aneta Siemiginowska (2017). &quot;Bayesian Estimates of Astronomical Time Delays between Gravitationally Lensed Stochastic Light Curves,&quot; The Annals of Applied Statistics, 11 (3), 1309-1348.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # Loading datasets
  data(simple)
  head(simple)

  ################################################
  # Time delay estimation via profile likelihood #
  ################################################


  # Subset (data for image A) of the typical quasar data set
  lcA &lt;- simple[, 1 : 3]

  # Another subset (data for image B) of the typical quasar data set
  # The observation times for image B are not necessarily the same as those for image A
  lcB &lt;- simple[, c(1, 4, 5)]

  # The two subsets do not need to have the same number of observations
  # For example, here we add one more observation time for image B
  lcB &lt;- rbind(lcB, c(290, 1.86, 0.006))

  dim(lcA)
  dim(lcB)

  ###### The entire profile likelihood values on the grid of values of the time delay.

  # Cubic microlensing model
  ti1 &lt;- lcB[, 1]
  ti2 &lt;- lcB[, 1]^2
  ti3 &lt;- lcB[, 1]^3
  ss &lt;- lm(lcB[, 2] - mean(lcA[, 2]) ~ ti1 + ti2 + ti3)

  initial &lt;- c(mean(lcA[, 2]), log(0.01), log(200), ss$coefficients)
  delta.uniform.range &lt;- c(0, 100)
  grid &lt;- seq(0, 100, by = 0.1) 
  # grid interval "by = 0.1" is recommended,
  # but users can set a finer grid of values of the time delay.

  
  logprof &lt;- entirelogprofilelikelihood(data.lcA = lcA, data.lcB = lcB, grid = grid, 
                                        initial = initial, data.flux = FALSE, 
                                        delta.uniform.range = delta.uniform.range, micro = 3)
  plot(grid, logprof, type = "l", 
       xlab = expression(bold(Delta)),       
       ylab = expression(bold(paste("log L"[prof], "(", Delta, ")"))))
  prof &lt;- exp(logprof - max(logprof))  # normalization
  plot(grid, prof, type = "l", 
       xlab = expression(bold(Delta)),       
       ylab = expression(bold(paste("L"[prof], "(", Delta, ")"))))
  

</code></pre>

<hr>
<h2 id='simple'>
Simulated simple data of a doubly-lensed quasar
</h2><span id='topic+simple'></span>

<h3>Description</h3>

<p>We simulated a simple data set of a doubly-lensed quasar with generative parameter values (Delta, beta0, mu, sigma, tau) equal to (50, 2, 0, 0.03, 100). The number of epochs is 78 and measurement errors are the same to 0.005.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(simple)</code></pre>


<h3>Format</h3>

<p>A simple data set of a doubly-lensed quasar:
</p>

<dl>
<dt><code>time</code></dt><dd><p>observation times</p>
</dd>
<dt><code>x</code></dt><dd><p>magnitudes of light A</p>
</dd>
<dt><code>se.x</code></dt><dd><p>measurement errors of x</p>
</dd>
<dt><code>y</code></dt><dd><p>magnitudes of light B</p>
</dd>
<dt><code>se.y</code></dt><dd><p>measurement errors of y</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>  data(simple)
</code></pre>

<hr>
<h2 id='simple.band1'>
Simulated simple data of a doubly-lensed quasar observed in band 1
</h2><span id='topic+simple.band1'></span>

<h3>Description</h3>

<p>A 50 by 5 matrix containing a data set of a doubly-lensed quasar observed in band 1, which is modified from realistic data. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(simple.band1)</code></pre>


<h3>Format</h3>

<p>A simple data set of a doubly-lensed quasar:
</p>

<dl>
<dt><code>time</code></dt><dd><p>observation times</p>
</dd>
<dt><code>x</code></dt><dd><p>magnitudes of light A observed in band 1</p>
</dd>
<dt><code>se.x</code></dt><dd><p>measurement errors of x</p>
</dd>
<dt><code>y</code></dt><dd><p>magnitudes of light B observed in band 1</p>
</dd>
<dt><code>se.y</code></dt><dd><p>measurement errors of y</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>  data(simple.band1)
</code></pre>

<hr>
<h2 id='simple.band2'>
Simulated simple data of a doubly-lensed quasar observed in band 2
</h2><span id='topic+simple.band2'></span>

<h3>Description</h3>

<p>A 30 by 5 matrix containing a data set of a doubly-lensed quasar observed in band 2, which is modified from realistic data. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(simple.band2)</code></pre>


<h3>Format</h3>

<p>A simple data set of a doubly-lensed quasar:
</p>

<dl>
<dt><code>time</code></dt><dd><p>observation times</p>
</dd>
<dt><code>x</code></dt><dd><p>magnitudes of light A observed in band 2</p>
</dd>
<dt><code>se.x</code></dt><dd><p>measurement errors of x</p>
</dd>
<dt><code>y</code></dt><dd><p>magnitudes of light B observed in band 2</p>
</dd>
<dt><code>se.y</code></dt><dd><p>measurement errors of y</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>  data(simple.band2)
</code></pre>

<hr>
<h2 id='timedelay-internal'>Internal <code>bayesian</code> functions</h2><span id='topic+postTheta'></span><span id='topic+logpostDelta'></span><span id='topic+postX'></span><span id='topic+Log.post.theta'></span><span id='topic+postTheta.multi'></span><span id='topic+postBeta'></span><span id='topic+Log.post.delta'></span><span id='topic+postX.multi'></span><span id='topic+orderData'></span>

<h3>Description</h3>

<p>Internal <code>bayesian</code> functions</p>


<h3>Details</h3>

<p>These are not to be called by the user.</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
