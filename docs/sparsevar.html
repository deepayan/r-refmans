<!DOCTYPE html><html><head><title>Help for package sparsevar</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sparsevar}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#accuracy'><p>Accuracy metric</p></a></li>
<li><a href='#bootstrappedVAR'><p>Bootstrap VAR</p></a></li>
<li><a href='#checkImpulseZero'><p>Check Impulse Zero</p></a></li>
<li><a href='#checkIsVar'><p>Check is var</p></a></li>
<li><a href='#companionVAR'><p>Companion VAR</p></a></li>
<li><a href='#computeForecasts'><p>Computes forecasts for VARs</p></a></li>
<li><a href='#createSparseMatrix'><p>Create Sparse Matrix</p></a></li>
<li><a href='#decomposePi'><p>Decompose Pi VECM matrix</p></a></li>
<li><a href='#errorBandsIRF'><p>Error bands for IRF</p></a></li>
<li><a href='#fitVAR'><p>Multivariate VAR estimation</p></a></li>
<li><a href='#fitVARX'><p>Multivariate VARX estimation</p></a></li>
<li><a href='#fitVECM'><p>Multivariate VECM estimation</p></a></li>
<li><a href='#frobNorm'><p>Froebenius norm of a matrix</p></a></li>
<li><a href='#impulseResponse'><p>Impulse Response Function</p></a></li>
<li><a href='#informCrit'><p>Computes information criteria for VARs</p></a></li>
<li><a href='#l1norm'><p>L1 matrix norm</p></a></li>
<li><a href='#l2norm'><p>L2 matrix norm</p></a></li>
<li><a href='#lInftyNorm'><p>L-infinity matrix norm</p></a></li>
<li><a href='#maxNorm'><p>Max-norm of a matrix</p></a></li>
<li><a href='#mcSimulations'><p>Monte Carlo simulations</p></a></li>
<li><a href='#multiplot'><p>Multiplots with ggplot</p></a></li>
<li><a href='#plotIRF'><p>IRF plot</p></a></li>
<li><a href='#plotIRFGrid'><p>IRF grid plot</p></a></li>
<li><a href='#plotMatrix'><p>Matrix plot</p></a></li>
<li><a href='#plotVAR'><p>Plot VARs</p></a></li>
<li><a href='#plotVECM'><p>Plot VECMs</p></a></li>
<li><a href='#simulateVAR'><p>VAR simulation</p></a></li>
<li><a href='#simulateVARX'><p>VARX simulation</p></a></li>
<li><a href='#sparsevar'><p>sparsevar: A package to estimate multivariate time series models (such as VAR and</p>
VECM), under the sparsity hypothesis.</a></li>
<li><a href='#spectralNorm'><p>Spectral norm</p></a></li>
<li><a href='#spectralRadius'><p>Spectral radius</p></a></li>
<li><a href='#testGranger'><p>Test for Ganger Causality</p></a></li>
<li><a href='#transformData'><p>Transorm data</p></a></li>
<li><a href='#varENET'><p>VAR ENET</p></a></li>
<li><a href='#varMCP'><p>VAR MCP</p></a></li>
<li><a href='#varSCAD'><p>VAR SCAD</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-04-16</td>
</tr>
<tr>
<td>Title:</td>
<td>Sparse VAR/VECM Models Estimation</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Simone Vazzoler &lt;svazzole@gmail.com&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix, ncvreg, parallel, doParallel, glmnet, ggplot2,
reshape2, grid, mvtnorm, picasso, corpcor,</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat,</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>A wrapper for sparse VAR/VECM time series models estimation
             using penalties like ENET (Elastic Net), SCAD (Smoothly Clipped 
             Absolute Deviation) and MCP (Minimax Concave Penalty). 
             Based on the work of Sumanta Basu and George Michailidis 
             &lt;<a href="https://doi.org/10.1214%2F15-AOS1315">doi:10.1214/15-AOS1315</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/svazzole/sparsevar">https://github.com/svazzole/sparsevar</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/svazzole/sparsevar">https://github.com/svazzole/sparsevar</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-04-17 07:03:01 UTC; svazzole</td>
</tr>
<tr>
<td>Author:</td>
<td>Simone Vazzoler [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-04-18 04:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='accuracy'>Accuracy metric</h2><span id='topic+accuracy'></span>

<h3>Description</h3>

<p>Compute the accuracy of a fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>accuracy(referenceM, A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="accuracy_+3A_referencem">referenceM</code></td>
<td>
<p>the matrix to use as reference</p>
</td></tr>
<tr><td><code id="accuracy_+3A_a">A</code></td>
<td>
<p>the matrix obtained from a fit</p>
</td></tr>
</table>

<hr>
<h2 id='bootstrappedVAR'>Bootstrap VAR</h2><span id='topic+bootstrappedVAR'></span>

<h3>Description</h3>

<p>Build the bootstrapped series from the original var
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrappedVAR(v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootstrappedVAR_+3A_v">v</code></td>
<td>
<p>the VAR object as from fitVAR or simulateVAR</p>
</td></tr>
</table>

<hr>
<h2 id='checkImpulseZero'>Check Impulse Zero</h2><span id='topic+checkImpulseZero'></span>

<h3>Description</h3>

<p>A function to find which entries of the impulse response function
are zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkImpulseZero(irf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkImpulseZero_+3A_irf">irf</code></td>
<td>
<p>irf output from impulseResponse function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix containing the indices of the impulse response function that
are 0.
</p>

<hr>
<h2 id='checkIsVar'>Check is var</h2><span id='topic+checkIsVar'></span>

<h3>Description</h3>

<p>Check if the input is a var object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkIsVar(v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkIsVar_+3A_v">v</code></td>
<td>
<p>the object to test</p>
</td></tr>
</table>

<hr>
<h2 id='companionVAR'>Companion VAR</h2><span id='topic+companionVAR'></span>

<h3>Description</h3>

<p>Build the VAR(1) representation of a VAR(p) process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>companionVAR(v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="companionVAR_+3A_v">v</code></td>
<td>
<p>the VAR object as from <code>fitVAR</code> or <code>simulateVAR</code></p>
</td></tr>
</table>

<hr>
<h2 id='computeForecasts'>Computes forecasts for VARs</h2><span id='topic+computeForecasts'></span>

<h3>Description</h3>

<p>This function computes forecasts for a given VAR.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeForecasts(v, num_steps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeForecasts_+3A_v">v</code></td>
<td>
<p>a VAR object as from fitVAR.</p>
</td></tr>
<tr><td><code id="computeForecasts_+3A_num_steps">num_steps</code></td>
<td>
<p>the number of forecasts to produce.</p>
</td></tr>
</table>

<hr>
<h2 id='createSparseMatrix'>Create Sparse Matrix</h2><span id='topic+createSparseMatrix'></span>

<h3>Description</h3>

<p>Creates a sparse square matrix with a given sparsity and
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createSparseMatrix(
  N,
  sparsity,
  method = "normal",
  stationary = FALSE,
  p = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createSparseMatrix_+3A_n">N</code></td>
<td>
<p>the dimension of the square matrix</p>
</td></tr>
<tr><td><code id="createSparseMatrix_+3A_sparsity">sparsity</code></td>
<td>
<p>the density of non zero elements</p>
</td></tr>
<tr><td><code id="createSparseMatrix_+3A_method">method</code></td>
<td>
<p>the method used to generate the entries of the matrix.
Possible values are <code>"normal"</code> (default) or <code>"bimodal"</code>.</p>
</td></tr>
<tr><td><code id="createSparseMatrix_+3A_stationary">stationary</code></td>
<td>
<p>should the spectral radius of the matrix be smaller than 1?
Possible values are <code>TRUE</code> or <code>FALSE</code>. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="createSparseMatrix_+3A_p">p</code></td>
<td>
<p>normalization constant (used for VAR of order greater than 1,
default = 1)</p>
</td></tr>
<tr><td><code id="createSparseMatrix_+3A_...">...</code></td>
<td>
<p>other options for the matrix (you can specify the mean
<code>mu_mat</code> and the standard deviation <code>sd_mat</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An NxN sparse matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M &lt;- createSparseMatrix(
  N = 30, sparsity = 0.05, method = "normal",
  stationary = TRUE
)
</code></pre>

<hr>
<h2 id='decomposePi'>Decompose Pi VECM matrix</h2><span id='topic+decomposePi'></span>

<h3>Description</h3>

<p>A function to estimate a (possibly big) multivariate VECM time series
using penalized least squares methods, such as ENET, SCAD or MC+.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decomposePi(vecm, rk, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decomposePi_+3A_vecm">vecm</code></td>
<td>
<p>the VECM object</p>
</td></tr>
<tr><td><code id="decomposePi_+3A_rk">rk</code></td>
<td>
<p>rank</p>
</td></tr>
<tr><td><code id="decomposePi_+3A_...">...</code></td>
<td>
<p>options for the function (TODO: specify)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>alpha
</p>
<p>beta
</p>

<hr>
<h2 id='errorBandsIRF'>Error bands for IRF</h2><span id='topic+errorBandsIRF'></span>

<h3>Description</h3>

<p>A function to estimate the confidence intervals for irf and oirf.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>errorBandsIRF(v, irf, alpha, M, resampling, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="errorBandsIRF_+3A_v">v</code></td>
<td>
<p>a var object as from fitVAR or simulateVAR</p>
</td></tr>
<tr><td><code id="errorBandsIRF_+3A_irf">irf</code></td>
<td>
<p>irf output from impulseResponse function</p>
</td></tr>
<tr><td><code id="errorBandsIRF_+3A_alpha">alpha</code></td>
<td>
<p>level of confidence (default <code>alpha = 0.01</code>)</p>
</td></tr>
<tr><td><code id="errorBandsIRF_+3A_m">M</code></td>
<td>
<p>number of bootstrapped series (default <code>M = 100</code>)</p>
</td></tr>
<tr><td><code id="errorBandsIRF_+3A_resampling">resampling</code></td>
<td>
<p>type of resampling: <code>"bootstrap"</code> or <code>"jackknife"</code></p>
</td></tr>
<tr><td><code id="errorBandsIRF_+3A_...">...</code></td>
<td>
<p>some options for the estimation: <code>verbose = TRUE</code> or <code>FALSE</code>,
<code>mode = "fast"</code> or <code>"slow"</code>, <code>threshold = TRUE</code> or <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix containing the indices of the impulse response function that
are 0.
</p>

<hr>
<h2 id='fitVAR'>Multivariate VAR estimation</h2><span id='topic+fitVAR'></span>

<h3>Description</h3>

<p>A function to estimate a (possibly high-dimensional)
multivariate VAR time series using penalized least squares methods,
such as ENET, SCAD or MC+.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitVAR(data, p = 1, penalty = "ENET", method = "cv", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitVAR_+3A_data">data</code></td>
<td>
<p>the data from the time series: variables in columns and
observations in rows</p>
</td></tr>
<tr><td><code id="fitVAR_+3A_p">p</code></td>
<td>
<p>order of the VAR model</p>
</td></tr>
<tr><td><code id="fitVAR_+3A_penalty">penalty</code></td>
<td>
<p>the penalty function to use. Possible values
are <code>"ENET"</code>, <code>"SCAD"</code> or <code>"MCP"</code></p>
</td></tr>
<tr><td><code id="fitVAR_+3A_method">method</code></td>
<td>
<p>possible values are <code>"cv"</code> or <code>"timeSlice"</code></p>
</td></tr>
<tr><td><code id="fitVAR_+3A_...">...</code></td>
<td>
<p>the options for the estimation. Global options are:
<code>threshold</code>: if <code>TRUE</code> all the entries smaller than the oracle
threshold are set to zero;
<code>scale</code>: scale the data (default = FALSE)?
<code>nfolds</code>: the number of folds used for cross validation (default = 10);
<code>parallel</code>: if <code>TRUE</code> use multicore backend (default = FALSE);
<code>ncores</code>: if <code>parallel</code> is <code>TRUE</code>, specify the number
of cores to use for parallel evaluation. Options for ENET estimation:
<code>alpha</code>: the value of alpha to use in elastic net
(0 is Ridge regression, 1 is LASSO (default));
<code>type.measure</code>: the measure to use for error evaluation
(<code>"mse"</code> or <code>"mae"</code>);
<code>nlambda</code>: the number of lambdas to use in the cross
validation (default = 100);
<code>leaveOut</code>: in the time slice validation leave out the
last <code>leaveOutLast</code> observations (default = 15);
<code>horizon</code>: the horizon to use for estimating mse/mae (default = 1);
<code>picasso</code>: use picasso package for estimation (only available
for <code>penalty = "SCAD"</code> and <code>method = "timeSlice"</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>A</code> the list (of length <code>p</code>) of the estimated matrices
of the process
</p>
<p><code>fit</code> the results of the penalized LS estimation
</p>
<p><code>mse</code> the mean square error of the cross validation
</p>
<p><code>time</code> elapsed time for the estimation
</p>
<p><code>residuals</code> the time series of the residuals
</p>

<hr>
<h2 id='fitVARX'>Multivariate VARX estimation</h2><span id='topic+fitVARX'></span>

<h3>Description</h3>

<p>A function to estimate a (possibly high-dimensional) multivariate VARX time series
using penalized least squares methods, such as ENET, SCAD or MC+.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitVARX(data, p = 1, Xt, m = 1, penalty = "ENET", method = "cv", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitVARX_+3A_data">data</code></td>
<td>
<p>the data from the time series: variables in columns and observations in
rows</p>
</td></tr>
<tr><td><code id="fitVARX_+3A_p">p</code></td>
<td>
<p>order of the VAR model</p>
</td></tr>
<tr><td><code id="fitVARX_+3A_xt">Xt</code></td>
<td>
<p>the exogenous variables</p>
</td></tr>
<tr><td><code id="fitVARX_+3A_m">m</code></td>
<td>
<p>order of the exogenous variables</p>
</td></tr>
<tr><td><code id="fitVARX_+3A_penalty">penalty</code></td>
<td>
<p>the penalty function to use. Possible values are <code>"ENET"</code>,
<code>"SCAD"</code> or <code>"MCP"</code></p>
</td></tr>
<tr><td><code id="fitVARX_+3A_method">method</code></td>
<td>
<p>possible values are <code>"cv"</code> or <code>"timeSlice"</code></p>
</td></tr>
<tr><td><code id="fitVARX_+3A_...">...</code></td>
<td>
<p>the options for the estimation. Global options are:
<code>threshold</code>: if <code>TRUE</code> all the entries smaller than the oracle threshold are set to zero;
<code>scale</code>: scale the data (default = FALSE)?
<code>nfolds</code>: the number of folds used for cross validation (default = 10);
<code>parallel</code>: if <code>TRUE</code> use multicore backend (default = FALSE);
<code>ncores</code>: if <code>parallel</code> is <code>TRUE</code>, specify the number of cores to use
for parallel evaluation. Options for ENET estimation:
<code>alpha</code>: the value of alpha to use in elastic net (0 is Ridge regression, 1 is LASSO (default));
<code>type.measure</code>: the measure to use for error evaluation (<code>"mse"</code> or <code>"mae"</code>);
<code>nlambda</code>: the number of lambdas to use in the cross validation (default = 100);
<code>leaveOut</code>: in the time slice validation leave out the last <code>leaveOutLast</code> observations
(default = 15);
<code>horizon</code>: the horizon to use for estimating mse/mae (default = 1);
<code>picasso</code>: use picasso package for estimation (only available for <code>penalty = "SCAD"</code>
and <code>method = "timeSlice"</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>A</code> the list (of length <code>p</code>) of the estimated matrices of the process
</p>
<p><code>fit</code> the results of the penalized LS estimation
</p>
<p><code>mse</code> the mean square error of the cross validation
</p>
<p><code>time</code> elapsed time for the estimation
</p>
<p><code>residuals</code> the time series of the residuals
</p>

<hr>
<h2 id='fitVECM'>Multivariate VECM estimation</h2><span id='topic+fitVECM'></span>

<h3>Description</h3>

<p>A function to estimate a (possibly big) multivariate VECM time series
using penalized least squares methods, such as ENET, SCAD or MC+.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitVECM(data, p, penalty, method, logScale, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitVECM_+3A_data">data</code></td>
<td>
<p>the data from the time series: variables in columns and observations in
rows</p>
</td></tr>
<tr><td><code id="fitVECM_+3A_p">p</code></td>
<td>
<p>order of the VECM model</p>
</td></tr>
<tr><td><code id="fitVECM_+3A_penalty">penalty</code></td>
<td>
<p>the penalty function to use. Possible values are <code>"ENET"</code>,
<code>"SCAD"</code> or <code>"MCP"</code></p>
</td></tr>
<tr><td><code id="fitVECM_+3A_method">method</code></td>
<td>
<p><code>"cv"</code> or <code>"timeSlice"</code></p>
</td></tr>
<tr><td><code id="fitVECM_+3A_logscale">logScale</code></td>
<td>
<p>should the function consider the <code>log</code> of the inputs? By default
this is set to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="fitVECM_+3A_...">...</code></td>
<td>
<p>options for the function (TODO: specify)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Pi the matrix <code>Pi</code> for the VECM model
</p>
<p>G the list (of length <code>p-1</code>) of the estimated matrices of the process
</p>
<p>fit the results of the penalized LS estimation
</p>
<p>mse the mean square error of the cross validation
</p>
<p>time elapsed time for the estimation
</p>

<hr>
<h2 id='frobNorm'>Froebenius norm of a matrix</h2><span id='topic+frobNorm'></span>

<h3>Description</h3>

<p>Compute the Froebenius norm of M
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frobNorm(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frobNorm_+3A_m">M</code></td>
<td>
<p>the matrix (real or complex valued)</p>
</td></tr>
</table>

<hr>
<h2 id='impulseResponse'>Impulse Response Function</h2><span id='topic+impulseResponse'></span>

<h3>Description</h3>

<p>A function to estimate the Impulse Response Function of a given VAR.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impulseResponse(v, len = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impulseResponse_+3A_v">v</code></td>
<td>
<p>the data in the for of a VAR</p>
</td></tr>
<tr><td><code id="impulseResponse_+3A_len">len</code></td>
<td>
<p>length of the impulse response function</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>irf</code> a 3d array containing the impulse response function.
</p>

<hr>
<h2 id='informCrit'>Computes information criteria for VARs</h2><span id='topic+informCrit'></span>

<h3>Description</h3>

<p>This function computes information criteria (AIC, Schwartz and
Hannan-Quinn) for VARs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>informCrit(v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="informCrit_+3A_v">v</code></td>
<td>
<p>a list of VAR objects as from fitVAR.</p>
</td></tr>
</table>

<hr>
<h2 id='l1norm'>L1 matrix norm</h2><span id='topic+l1norm'></span>

<h3>Description</h3>

<p>Compute the L1 matrix norm of M
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l1norm(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="l1norm_+3A_m">M</code></td>
<td>
<p>the matrix (real or complex valued)</p>
</td></tr>
</table>

<hr>
<h2 id='l2norm'>L2 matrix norm</h2><span id='topic+l2norm'></span>

<h3>Description</h3>

<p>Compute the L2 matrix norm of M
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l2norm(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="l2norm_+3A_m">M</code></td>
<td>
<p>the matrix (real or complex valued)</p>
</td></tr>
</table>

<hr>
<h2 id='lInftyNorm'>L-infinity matrix norm</h2><span id='topic+lInftyNorm'></span>

<h3>Description</h3>

<p>Compute the L-infinity matrix norm of M
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lInftyNorm(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lInftyNorm_+3A_m">M</code></td>
<td>
<p>the matrix (real or complex valued)</p>
</td></tr>
</table>

<hr>
<h2 id='maxNorm'>Max-norm of a matrix</h2><span id='topic+maxNorm'></span>

<h3>Description</h3>

<p>Compute the max-norm of M
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxNorm(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxNorm_+3A_m">M</code></td>
<td>
<p>the matrix (real or complex valued)</p>
</td></tr>
</table>

<hr>
<h2 id='mcSimulations'>Monte Carlo simulations</h2><span id='topic+mcSimulations'></span>

<h3>Description</h3>

<p>This function generates Monte Carlo simulations of sparse VAR and
its estimation (at the moment only for VAR(1) processes).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcSimulations(
  N,
  nobs = 250,
  nMC = 100,
  rho = 0.5,
  sparsity = 0.05,
  penalty = "ENET",
  covariance = "Toeplitz",
  method = "normal",
  modelSel = "cv",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcSimulations_+3A_n">N</code></td>
<td>
<p>dimension of the multivariate time series.</p>
</td></tr>
<tr><td><code id="mcSimulations_+3A_nobs">nobs</code></td>
<td>
<p>number of observations to be generated.</p>
</td></tr>
<tr><td><code id="mcSimulations_+3A_nmc">nMC</code></td>
<td>
<p>number of Monte Carlo simulations.</p>
</td></tr>
<tr><td><code id="mcSimulations_+3A_rho">rho</code></td>
<td>
<p>base value for the covariance.</p>
</td></tr>
<tr><td><code id="mcSimulations_+3A_sparsity">sparsity</code></td>
<td>
<p>density of non zero entries of the VAR matrices.</p>
</td></tr>
<tr><td><code id="mcSimulations_+3A_penalty">penalty</code></td>
<td>
<p>penalty function to use for LS estimation. Possible values are <code>"ENET"</code>,
<code>"SCAD"</code> or <code>"MCP"</code>.</p>
</td></tr>
<tr><td><code id="mcSimulations_+3A_covariance">covariance</code></td>
<td>
<p>type of covariance matrix to be used in the generation of the sparse VAR model.</p>
</td></tr>
<tr><td><code id="mcSimulations_+3A_method">method</code></td>
<td>
<p>which type of distribution to use in the generation of the entries of the matrices.</p>
</td></tr>
<tr><td><code id="mcSimulations_+3A_modelsel">modelSel</code></td>
<td>
<p>select which model selection criteria to use (<code>"cv"</code> or <code>"timeslice"</code>).</p>
</td></tr>
<tr><td><code id="mcSimulations_+3A_...">...</code></td>
<td>
<p>(TODO: complete)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>nMc</code>x5 matrix with the results of the Monte Carlo estimation
</p>

<hr>
<h2 id='multiplot'>Multiplots with ggplot</h2><span id='topic+multiplot'></span>

<h3>Description</h3>

<p>Multiple plot function. ggplot objects can be passed in ..., or
to plotlist (as a list of ggplot objects)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiplot(..., plotlist = NULL, cols = 1, layout = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiplot_+3A_...">...</code></td>
<td>
<p>a sequence of ggplots to be plotted in the grid.</p>
</td></tr>
<tr><td><code id="multiplot_+3A_plotlist">plotlist</code></td>
<td>
<p>a list containing ggplots as elements.</p>
</td></tr>
<tr><td><code id="multiplot_+3A_cols">cols</code></td>
<td>
<p>number of columns in layout</p>
</td></tr>
<tr><td><code id="multiplot_+3A_layout">layout</code></td>
<td>
<p>a matrix specifying the layout. If present, 'cols' is ignored.
If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),
then plot 1 will go in the upper left, 2 will go in the upper right, and
3 will go all the way across the bottom.
Taken from R Cookbook</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot containing the plots passed as arguments
</p>

<hr>
<h2 id='plotIRF'>IRF plot</h2><span id='topic+plotIRF'></span>

<h3>Description</h3>

<p>Plot a IRF object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotIRF(irf, eb, i, j, type, bands)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotIRF_+3A_irf">irf</code></td>
<td>
<p>the irf object to plot</p>
</td></tr>
<tr><td><code id="plotIRF_+3A_eb">eb</code></td>
<td>
<p>the errorbands to plot</p>
</td></tr>
<tr><td><code id="plotIRF_+3A_i">i</code></td>
<td>
<p>the first index</p>
</td></tr>
<tr><td><code id="plotIRF_+3A_j">j</code></td>
<td>
<p>the second index</p>
</td></tr>
<tr><td><code id="plotIRF_+3A_type">type</code></td>
<td>
<p><code>type = "irf"</code> or <code>type = "oirf"</code></p>
</td></tr>
<tr><td><code id="plotIRF_+3A_bands">bands</code></td>
<td>
<p><code>"quantiles"</code> or <code>"sd"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>image</code> plot relative to the impulse response function.
</p>

<hr>
<h2 id='plotIRFGrid'>IRF grid plot</h2><span id='topic+plotIRFGrid'></span>

<h3>Description</h3>

<p>Plot a IRF grid object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotIRFGrid(irf, eb, indexes, type, bands)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotIRFGrid_+3A_irf">irf</code></td>
<td>
<p>the irf object computed using impulseResponse</p>
</td></tr>
<tr><td><code id="plotIRFGrid_+3A_eb">eb</code></td>
<td>
<p>the error bands estimated using errorBands</p>
</td></tr>
<tr><td><code id="plotIRFGrid_+3A_indexes">indexes</code></td>
<td>
<p>a vector containing the indices that you want to plot</p>
</td></tr>
<tr><td><code id="plotIRFGrid_+3A_type">type</code></td>
<td>
<p>plot the irf (<code>type = "irf"</code> by default) or the orthogonal irf
(<code>type = "oirf"</code>)</p>
</td></tr>
<tr><td><code id="plotIRFGrid_+3A_bands">bands</code></td>
<td>
<p>which type of bands to plot (&quot;quantiles&quot; (default) or  &quot;sd&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>image</code> plot relative to the impulse response function.
</p>

<hr>
<h2 id='plotMatrix'>Matrix plot</h2><span id='topic+plotMatrix'></span>

<h3>Description</h3>

<p>Plot a sparse matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotMatrix(M, colors)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotMatrix_+3A_m">M</code></td>
<td>
<p>the matrix to plot</p>
</td></tr>
<tr><td><code id="plotMatrix_+3A_colors">colors</code></td>
<td>
<p>dark or light</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>image</code> plot with a particular color palette (black zero entries, red
for the negative ones and green for the positive)
</p>

<hr>
<h2 id='plotVAR'>Plot VARs</h2><span id='topic+plotVAR'></span>

<h3>Description</h3>

<p>Plot all the matrices of a VAR model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotVAR(..., colors)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotVAR_+3A_...">...</code></td>
<td>
<p>a sequence of VAR objects (one or more
than one, as from <code>simulateVAR</code> or <code>fitVAR</code>)</p>
</td></tr>
<tr><td><code id="plotVAR_+3A_colors">colors</code></td>
<td>
<p>the gradient used to plot the matrix. It can be &quot;light&quot; (low =
red &ndash; mid = white &ndash; high = blue) or &quot;dark&quot; (low = red &ndash; mid = black &ndash;
high = green)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>image</code> plot with a specific color palette
</p>

<hr>
<h2 id='plotVECM'>Plot VECMs</h2><span id='topic+plotVECM'></span>

<h3>Description</h3>

<p>Plot all the matrices of a VECM model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotVECM(v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotVECM_+3A_v">v</code></td>
<td>
<p>a VECM object (as from <code>fitVECM</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>image</code> plot with a specific color palette (black zero entries, red
for the negative ones and green for the positive)
</p>

<hr>
<h2 id='simulateVAR'>VAR simulation</h2><span id='topic+simulateVAR'></span>

<h3>Description</h3>

<p>This function generates a simulated multivariate VAR time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateVAR(N, p, nobs, rho, sparsity, mu, method, covariance, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulateVAR_+3A_n">N</code></td>
<td>
<p>dimension of the time series.</p>
</td></tr>
<tr><td><code id="simulateVAR_+3A_p">p</code></td>
<td>
<p>number of lags of the VAR model.</p>
</td></tr>
<tr><td><code id="simulateVAR_+3A_nobs">nobs</code></td>
<td>
<p>number of observations to be generated.</p>
</td></tr>
<tr><td><code id="simulateVAR_+3A_rho">rho</code></td>
<td>
<p>base value for the covariance matrix.</p>
</td></tr>
<tr><td><code id="simulateVAR_+3A_sparsity">sparsity</code></td>
<td>
<p>density (in percentage) of the number of nonzero elements of the VAR matrices.</p>
</td></tr>
<tr><td><code id="simulateVAR_+3A_mu">mu</code></td>
<td>
<p>a vector containing the mean of the simulated process.</p>
</td></tr>
<tr><td><code id="simulateVAR_+3A_method">method</code></td>
<td>
<p>which method to use to generate the VAR matrix. Possible values
are <code>"normal"</code> or <code>"bimodal"</code>.</p>
</td></tr>
<tr><td><code id="simulateVAR_+3A_covariance">covariance</code></td>
<td>
<p>type of covariance matrix to use in the simulation. Possible
values: <code>"toeplitz"</code>, <code>"block1"</code>, <code>"block2"</code> or simply <code>"diagonal"</code>.</p>
</td></tr>
<tr><td><code id="simulateVAR_+3A_...">...</code></td>
<td>
<p>the options for the simulation. These are:
<code>muMat</code>: the mean of the entries of the VAR matrices;
<code>sdMat</code>: the sd of the entries of the matrices;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A a list of NxN matrices ordered by lag
</p>
<p>data a list with two elements: <code>series</code> the multivariate time series and
<code>noises</code> the time series of errors
</p>
<p>S the variance/covariance matrix of the process
</p>

<hr>
<h2 id='simulateVARX'>VARX simulation</h2><span id='topic+simulateVARX'></span>

<h3>Description</h3>

<p>This function generates a simulated multivariate VAR time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateVARX(N, K, p, m, nobs, rho,
                    sparsityA1, sparsityA2, sparsityA3,
                    mu, method, covariance, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulateVARX_+3A_n">N</code></td>
<td>
<p>dimension of the time series.</p>
</td></tr>
<tr><td><code id="simulateVARX_+3A_k">K</code></td>
<td>
<p>TODO</p>
</td></tr>
<tr><td><code id="simulateVARX_+3A_p">p</code></td>
<td>
<p>number of lags of the VAR model.</p>
</td></tr>
<tr><td><code id="simulateVARX_+3A_m">m</code></td>
<td>
<p>TODO</p>
</td></tr>
<tr><td><code id="simulateVARX_+3A_nobs">nobs</code></td>
<td>
<p>number of observations to be generated.</p>
</td></tr>
<tr><td><code id="simulateVARX_+3A_rho">rho</code></td>
<td>
<p>base value for the covariance matrix.</p>
</td></tr>
<tr><td><code id="simulateVARX_+3A_sparsitya1">sparsityA1</code></td>
<td>
<p>density (in percentage) of the number of nonzero elements
of the A1 block.</p>
</td></tr>
<tr><td><code id="simulateVARX_+3A_sparsitya2">sparsityA2</code></td>
<td>
<p>density (in percentage) of the number of nonzero elements
of the A2 block.</p>
</td></tr>
<tr><td><code id="simulateVARX_+3A_sparsitya3">sparsityA3</code></td>
<td>
<p>density (in percentage) of the number of nonzero elements
of the A3 block.</p>
</td></tr>
<tr><td><code id="simulateVARX_+3A_mu">mu</code></td>
<td>
<p>a vector containing the mean of the simulated process.</p>
</td></tr>
<tr><td><code id="simulateVARX_+3A_method">method</code></td>
<td>
<p>which method to use to generate the VAR matrix. Possible values
are <code>"normal"</code> or <code>"bimodal"</code>.</p>
</td></tr>
<tr><td><code id="simulateVARX_+3A_covariance">covariance</code></td>
<td>
<p>type of covariance matrix to use in the simulation. Possible
values: <code>"toeplitz"</code>, <code>"block1"</code>, <code>"block2"</code> or simply <code>"diagonal"</code>.</p>
</td></tr>
<tr><td><code id="simulateVARX_+3A_...">...</code></td>
<td>
<p>the options for the simulation. These are:
<code>muMat</code>: the mean of the entries of the VAR matrices;
<code>sdMat</code>: the sd of the entries of the matrices;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A a list of NxN matrices ordered by lag
</p>
<p>data a list with two elements: <code>series</code> the multivariate time series and
<code>noises</code> the time series of errors
</p>
<p>S the variance/covariance matrix of the process
</p>

<hr>
<h2 id='sparsevar'>sparsevar: A package to estimate multivariate time series models (such as VAR and
VECM), under the sparsity hypothesis.</h2><span id='topic+sparsevar'></span>

<h3>Description</h3>

<p>It performs the estimation of the matrices of the models using penalized
least squares methods such as LASSO, SCAD and MCP.
</p>


<h3>sparsevar functions</h3>

<p><code>fitVAR</code>, <code>fitVECM</code>, <code>simulateVAR</code>, <code>createSparseMatrix</code>,
<code>plotMatrix</code>, <code>plotVAR</code>, <code>plotVECM</code>
<code>l2norm</code>, <code>l1norm</code>, <code>lInftyNorm</code>, <code>maxNorm</code>, <code>frobNorm</code>,
<code>spectralRadius</code>, <code>spectralNorm</code>, <code>impulseResponse</code>
</p>

<hr>
<h2 id='spectralNorm'>Spectral norm</h2><span id='topic+spectralNorm'></span>

<h3>Description</h3>

<p>Compute the spectral norm of M
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectralNorm(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spectralNorm_+3A_m">M</code></td>
<td>
<p>the matrix (real or complex valued)</p>
</td></tr>
</table>

<hr>
<h2 id='spectralRadius'>Spectral radius</h2><span id='topic+spectralRadius'></span>

<h3>Description</h3>

<p>Compute the spectral radius of M
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectralRadius(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spectralRadius_+3A_m">M</code></td>
<td>
<p>the matrix (real or complex valued)</p>
</td></tr>
</table>

<hr>
<h2 id='testGranger'>Test for Ganger Causality</h2><span id='topic+testGranger'></span>

<h3>Description</h3>

<p>This function should retain only the coefficients of the
matrices of the VAR that are statistically significative (from the bootstrap)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testGranger(v, eb)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testGranger_+3A_v">v</code></td>
<td>
<p>the VAR object as from fitVAR or simulateVAR</p>
</td></tr>
<tr><td><code id="testGranger_+3A_eb">eb</code></td>
<td>
<p>the error bands as obtained from errorBands</p>
</td></tr>
</table>

<hr>
<h2 id='transformData'>Transorm data</h2><span id='topic+transformData'></span>

<h3>Description</h3>

<p>Transform the input data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transformData(data, p, opt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transformData_+3A_data">data</code></td>
<td>
<p>the data</p>
</td></tr>
<tr><td><code id="transformData_+3A_p">p</code></td>
<td>
<p>the order of the VAR</p>
</td></tr>
<tr><td><code id="transformData_+3A_opt">opt</code></td>
<td>
<p>a list containing the options</p>
</td></tr>
</table>

<hr>
<h2 id='varENET'>VAR ENET</h2><span id='topic+varENET'></span>

<h3>Description</h3>

<p>Estimate VAR using ENET penalty
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varENET(data, p, lambdas, opt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varENET_+3A_data">data</code></td>
<td>
<p>the data</p>
</td></tr>
<tr><td><code id="varENET_+3A_p">p</code></td>
<td>
<p>the order of the VAR</p>
</td></tr>
<tr><td><code id="varENET_+3A_lambdas">lambdas</code></td>
<td>
<p>a vector containing the lambdas to be used in the fit</p>
</td></tr>
<tr><td><code id="varENET_+3A_opt">opt</code></td>
<td>
<p>a list containing the options</p>
</td></tr>
</table>

<hr>
<h2 id='varMCP'>VAR MCP</h2><span id='topic+varMCP'></span>

<h3>Description</h3>

<p>Estimate VAR using MCP penalty
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varMCP(data, p, lambdas, opt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varMCP_+3A_data">data</code></td>
<td>
<p>the data</p>
</td></tr>
<tr><td><code id="varMCP_+3A_p">p</code></td>
<td>
<p>the order of the VAR</p>
</td></tr>
<tr><td><code id="varMCP_+3A_lambdas">lambdas</code></td>
<td>
<p>a vector containing the lambdas to be used in the fit</p>
</td></tr>
<tr><td><code id="varMCP_+3A_opt">opt</code></td>
<td>
<p>a list containing the options</p>
</td></tr>
</table>

<hr>
<h2 id='varSCAD'>VAR SCAD</h2><span id='topic+varSCAD'></span>

<h3>Description</h3>

<p>Estimate VAR using SCAD penalty
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varSCAD(data, p, lambdas, opt, penalty)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varSCAD_+3A_data">data</code></td>
<td>
<p>the data</p>
</td></tr>
<tr><td><code id="varSCAD_+3A_p">p</code></td>
<td>
<p>the order of the VAR</p>
</td></tr>
<tr><td><code id="varSCAD_+3A_lambdas">lambdas</code></td>
<td>
<p>a vector containing the lambdas to be used in the fit</p>
</td></tr>
<tr><td><code id="varSCAD_+3A_opt">opt</code></td>
<td>
<p>a list containing the options</p>
</td></tr>
<tr><td><code id="varSCAD_+3A_penalty">penalty</code></td>
<td>
<p>a string &quot;SCAD&quot; or something else</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
