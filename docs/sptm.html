<!DOCTYPE html><html><head><title>Help for package sptm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sptm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#enhanced.ipw.coxph'><p> Enhanced Inverse Probability Weighted coxph</p></a></li>
<li><a href='#rstm'>
<p>Simulate failure time from a semiparametric transformation model</p></a></li>
<li><a href='#sim.fong'>
<p>Data Simulation as in Fong and Gilbert (2014)</p></a></li>
<li><a href='#sim.kong'>
<p>Data Simulation as in Kong et al. (2004)</p></a></li>
<li><a href='#stm'><p>Fit a semiparametric transformation model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Version:</td>
<td>2019.11-25</td>
</tr>
<tr>
<td>Title:</td>
<td>SemiParametric Transformation Model Methods</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.3), survival, survey, kyotil</td>
</tr>
<tr>
<td>Suggests:</td>
<td>RUnit, mvtnorm, Matrix, MASS</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements semiparametric transformation model two-phase estimation using calibration weights. The method in Fong and Gilbert (2015) Calibration weighted estimation of semiparametric transformation models for two-phase sampling. Statistics in Medicine &lt;<a href="https://doi.org/10.1002%2Fsim.6439">doi:10.1002/sim.6439</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-11-26 02:14:37 UTC; Youyi</td>
</tr>
<tr>
<td>Author:</td>
<td>Youyi Fong [cre],
  Krisztian Sebestyen [aut],
  Martin Maechler [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Youyi Fong &lt;youyifong@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-11-26 06:30:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='enhanced.ipw.coxph'> Enhanced Inverse Probability Weighted coxph </h2><span id='topic+enhanced.ipw.coxph'></span>

<h3>Description</h3>

 
<p><code>enhanced.ipw.coxph</code> is a wrapper function for calling svycoxph of survey package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enhanced.ipw.coxph (formula, dat, strata.formula, subset, imputation.formulae,
    verbose=FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enhanced.ipw.coxph_+3A_formula">formula</code></td>
<td>
<p> a formula that gives the model we are interested to fit </p>
</td></tr>
<tr><td><code id="enhanced.ipw.coxph_+3A_dat">dat</code></td>
<td>
<p> a data frame </p>
</td></tr>
<tr><td><code id="enhanced.ipw.coxph_+3A_strata.formula">strata.formula</code></td>
<td>
<p> a formula that gives how two phase sampling is done </p>
</td></tr>
<tr><td><code id="enhanced.ipw.coxph_+3A_subset">subset</code></td>
<td>
<p> a vector of logicals that give which observations are indluced in phase 2 </p>
</td></tr>
<tr><td><code id="enhanced.ipw.coxph_+3A_imputation.formulae">imputation.formulae</code></td>
<td>
<p> a list of formulae or a single formula that give models to impute missing data </p>
</td></tr>
<tr><td><code id="enhanced.ipw.coxph_+3A_verbose">verbose</code></td>
<td>
<p> Boolean </p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class svycoxph.
</p>


<h3>Author(s)</h3>

<p> Youyi Fong <a href="mailto:yfong@fhcrc.org">yfong@fhcrc.org</a> </p>

<hr>
<h2 id='rstm'>
Simulate failure time from a semiparametric transformation model
</h2><span id='topic+rstm'></span>

<h3>Description</h3>

<p>Simulate failure time from a semiparametric transformation model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rstm(n, family = c("PH", "PO", "P2"), linear.predictors, baseline.hazard = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rstm_+3A_n">n</code></td>
<td>

<p>integer. Sample size
</p>
</td></tr>
<tr><td><code id="rstm_+3A_family">family</code></td>
<td>

<p>string. 
</p>
</td></tr>
<tr><td><code id="rstm_+3A_linear.predictors">linear.predictors</code></td>
<td>

<p>vector. It can also be a matrix of 1 column, the dimension will be dropped
</p>
</td></tr>
<tr><td><code id="rstm_+3A_baseline.hazard">baseline.hazard</code></td>
<td>

<p>numeric.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Called by sim.fong
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n=100
beta= c(log(.5), log(.7), log(1.2)) 
t0=2.9999
init = c(log(0.0373*t0),beta)        
ft=rstm (n, family="PH", runif(n,1,2), baseline.hazard=0.032) 


</code></pre>

<hr>
<h2 id='sim.fong'>
Data Simulation as in Fong and Gilbert (2014)
</h2><span id='topic+sim.fong'></span>

<h3>Description</h3>

<p>Simulate data as in Fong and Gilbert (2014).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.fong (n, family=c("PH","PO","P2"), beta, 
    random.censoring=c("0%","20%","60%"), prevalence=0.1, non.adherence.ratio=0,
    design=c("FULL","CC"), auxiliary=c("weak","good","excellent","none"), 
    seed=NULL, var.S=1, var.W=1) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.fong_+3A_n">n</code></td>
<td>

<p>integer. Sample size
</p>
</td></tr>
<tr><td><code id="sim.fong_+3A_family">family</code></td>
<td>

<p>string. Link functions in the semiparametric transformation model
</p>
</td></tr>
<tr><td><code id="sim.fong_+3A_beta">beta</code></td>
<td>

<p>numerical vector. Coefficients of the linear model
</p>
</td></tr>
<tr><td><code id="sim.fong_+3A_random.censoring">random.censoring</code></td>
<td>

<p>string. Random censoring in addition to administrative censoring
</p>
</td></tr>
<tr><td><code id="sim.fong_+3A_prevalence">prevalence</code></td>
<td>

<p>numerical. Proportion of cases among z==0 when there is no random censoring and non-adherence ratio is 0
</p>
</td></tr>
<tr><td><code id="sim.fong_+3A_design">design</code></td>
<td>

<p>string. Full cohort or case-cohort (finite population sampling)
</p>
</td></tr>
<tr><td><code id="sim.fong_+3A_auxiliary">auxiliary</code></td>
<td>

<p>string. </p>
</td></tr>
<tr><td><code id="sim.fong_+3A_seed">seed</code></td>
<td>

<p>integer. Random generator seed</p>
</td></tr>
<tr><td><code id="sim.fong_+3A_var.s">var.S</code></td>
<td>

<p>numeric. Variance of the phase II covariate s</p>
</td></tr>
<tr><td><code id="sim.fong_+3A_var.w">var.W</code></td>
<td>

<p>numeric. Variance of the baseline covariate w
</p>
</td></tr>
<tr><td><code id="sim.fong_+3A_non.adherence.ratio">non.adherence.ratio</code></td>
<td>
<p>ratio of non-adherent</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of rows is the size of the full cohort.
Adherence ratio works as a Bernoulli variable.
Prevalence is used to compute baseline hazard function based on some empirical evidence.
</p>


<h3>Value</h3>

<p>If design is FULL, returns a data frame of:
</p>
<table>
<tr><td><code>ft</code></td>
<td>
<p>failure time</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>censoring time</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>smaller of the ft and C</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>event indicator</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>baseline covariate z</p>
</td></tr>
<tr><td><code>s</code></td>
<td>
<p>phase II covariate s</p>
</td></tr>
</table>
<p>If design is CC, returns a data frame of:
</p>
<table>
<tr><td><code>ft</code></td>
<td>
<p>failure time</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>censoring time</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>smaller of the ft and C</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>event indicator</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>baseline covariate z</p>
</td></tr>
<tr><td><code>s</code></td>
<td>
<p>phase II covariate s</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>baseline auxiliary covariate w</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
dat = sim.fong(n=10000, family="PH", beta=c(log(.5), log(.7), log(1.2)), design="CC", 
    auxiliary="weak", seed=1, prevalence=0.1, non.adherence.ratio=0, random.censoring="0")
mean(dat$d[dat$z==0])

dat = sim.fong(n=10000, family="PH", beta=c(log(.5), log(.7), log(1.2)), design="CC", 
    auxiliary="weak", seed=1, prevalence=0.1, non.adherence.ratio=0.15, random.censoring="0")
sum(dat$d &amp; !is.na(dat$s))
sum(!dat$d &amp; !is.na(dat$s)) / sum(dat$d &amp; !is.na(dat$s))

dat = sim.fong(n=10000, family="PH", beta=c(log(.5), log(.7), log(1.2)), design="CC", 
    auxiliary="weak", seed=1, prevalence=0.1, non.adherence.ratio=0.15, random.censoring="20")
sum(dat$d &amp; !is.na(dat$s))
sum(!dat$d &amp; !is.na(dat$s)) / sum(dat$d &amp; !is.na(dat$s))

</code></pre>

<hr>
<h2 id='sim.kong'>
Data Simulation as in Kong et al. (2004)
</h2><span id='topic+sim.kong'></span>

<h3>Description</h3>

<p>Simulate data as in Kong et al. (2004).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.kong(gamma, beta, design = "FULL", rho = 0.9, seed = 1, impute = FALSE, ppi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.kong_+3A_gamma">gamma</code></td>
<td>

</td></tr>
<tr><td><code id="sim.kong_+3A_beta">beta</code></td>
<td>

</td></tr>
<tr><td><code id="sim.kong_+3A_design">design</code></td>
<td>

</td></tr>
<tr><td><code id="sim.kong_+3A_rho">rho</code></td>
<td>

</td></tr>
<tr><td><code id="sim.kong_+3A_seed">seed</code></td>
<td>

</td></tr>
<tr><td><code id="sim.kong_+3A_impute">impute</code></td>
<td>

</td></tr>
<tr><td><code id="sim.kong_+3A_ppi">ppi</code></td>
<td>

</td></tr>
</table>

<hr>
<h2 id='stm'>Fit a semiparametric transformation model</h2><span id='topic+stm'></span><span id='topic+getFixedEf.stm'></span>

<h3>Description</h3>

<p>Fit a semiparametric transformation model</p>


<h3>Usage</h3>

<pre><code class='language-R'>stm (formula, dat, strata.formula, phase2.ind=NULL, imputation.formula=NULL, 
    family=c("PH","PO","P2"), ee=c("fine2","fine1","kong"), var.est.type=c("1","2"),
    t0, init=NULL, maxit=1000,
    intermediate=FALSE, verbose=FALSE, show.time.elapsed=TRUE)


## S3 method for class 'stm'
 getFixedEf(object, ...)


</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stm_+3A_formula">formula</code></td>
<td>
<p>formula. Regression model of interest</p>
</td></tr>
<tr><td><code id="stm_+3A_dat">dat</code></td>
<td>
<p>data frame.</p>
</td></tr>
<tr><td><code id="stm_+3A_strata.formula">strata.formula</code></td>
<td>
<p>formula.</p>
</td></tr>
<tr><td><code id="stm_+3A_phase2.ind">phase2.ind</code></td>
<td>
<p>Boolean vector. If TRUE, phase II samples; if FALSE, phase I samples. If NULL, will try to infer from which subjects have phase II variables. Should not be 0/1</p>
</td></tr>
<tr><td><code id="stm_+3A_imputation.formula">imputation.formula</code></td>
<td>
<p>formula. If not NULL, calibration weighting is done</p>
</td></tr>
<tr><td><code id="stm_+3A_family">family</code></td>
<td>
<p>string.</p>
</td></tr>
<tr><td><code id="stm_+3A_ee">ee</code></td>
<td>
<p>string. Type of design matrix used in estimating equation</p>
</td></tr>
<tr><td><code id="stm_+3A_var.est.type">var.est.type</code></td>
<td>
<p>string. 1: one-stage estimator, 2: two-stage estimator</p>
</td></tr>
<tr><td><code id="stm_+3A_t0">t0</code></td>
<td>
<p>numeric. Should be close to the end of study time</p>
</td></tr>
<tr><td><code id="stm_+3A_init">init</code></td>
<td>
<p>numerical vector.</p>
</td></tr>
<tr><td><code id="stm_+3A_maxit">maxit</code></td>
<td>
<p>integer. Maximum number of iterations in the optimization process</p>
</td></tr>
<tr><td><code id="stm_+3A_intermediate">intermediate</code></td>
<td>
<p>Boolean.</p>
</td></tr>
<tr><td><code id="stm_+3A_verbose">verbose</code></td>
<td>
<p>Boolean.</p>
</td></tr>
<tr><td><code id="stm_+3A_show.time.elapsed">show.time.elapsed</code></td>
<td>
<p>Boolean.</p>
</td></tr>
<tr><td><code id="stm_+3A_object">object</code></td>
<td>
<p>an object of type stm</p>
</td></tr>
<tr><td><code id="stm_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fit stm both with and without calibration. Calls stm.internal.
</p>


<h3>Value</h3>

<p>An object of type stm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n=100
beta= c(log(.5), log(.7), log(1.2)) 
t0=2.9999
init = c(log(0.0373*t0),beta)        
dat = sim.fong(n, family="PH", beta, random.censoring="0", design="CC", auxiliary="weak", seed=1)

est = stm(formula=Surv(X,d) ~ z + s + z:s, dat, strata.formula=~d, family="PH", t0=t0, init=init,
    var.est.type="1", verbose=3)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
