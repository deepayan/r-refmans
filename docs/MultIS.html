<!DOCTYPE html><html><head><title>Help for package MultIS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MultIS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bushmanplot'><p>Create a stacked area plot that represents the abundance of integration</p>
sites over time.</a></li>
<li><a href='#bw'><p>Calculate the bw index</p></a></li>
<li><a href='#convert_columnwise_relative'><p>Converts a matrix to relative abundances</p></a></li>
<li><a href='#evaluate_clustering'><p>Evaluate a clustering using the given method</p></a></li>
<li><a href='#evaluate_clustering_bw'><p>Evaluate a clustering using the bw index</p></a></li>
<li><a href='#evaluate_clustering_custom'><p>Evaluate a clustering using a custom evaluation function</p></a></li>
<li><a href='#evaluate_clustering_dunn'><p>Evaluate a clustering using the dunn index</p></a></li>
<li><a href='#evaluate_clustering_ptbiserial'><p>Evaluate a clustering using the point-biserial index</p></a></li>
<li><a href='#evaluate_clustering_sdindex'><p>Evaluate a clustering using the SD-index</p></a></li>
<li><a href='#evaluate_clustering_silhouette'><p>Evaluate a clustering using the silhouette index</p></a></li>
<li><a href='#filter_at_tp_biggest_n'><p>Filters a matrix of readouts for the n biggest IS at a certain</p>
measurement</a></li>
<li><a href='#filter_at_tp_min'><p>Filters a matrix of readouts for IS that have a minimum occurrence in some</p>
measurement</a></li>
<li><a href='#filter_combine_measurements'><p>Combines columns that have the same name. The columns are joined additively.</p></a></li>
<li><a href='#filter_is_names'><p>Shortens the rownames of a readout matrix to the shortest distinct prefix</p></a></li>
<li><a href='#filter_match'><p>Filters for columns containing a certain substring.</p></a></li>
<li><a href='#filter_measurement_names'><p>Splits a vector of strings by a given regexp, selects and rearranges the</p>
parts and joins them again</a></li>
<li><a href='#filter_names'><p>Filters a vector of names and returns the shortest common prefix.</p></a></li>
<li><a href='#filter_nr_tp_min'><p>Filters for a minimum number of time points/measurements</p></a></li>
<li><a href='#filter_zero_columns'><p>Removes columns that only contain 0 or NA.</p></a></li>
<li><a href='#filter_zero_rows'><p>Removes rows that only contain 0 or NA.</p></a></li>
<li><a href='#find_best_nr_cluster'><p>Finds the best number of clusters according to silhouette</p></a></li>
<li><a href='#get_similarity_matrix'><p>Generate a similarity matrix</p></a></li>
<li><a href='#ggplot_colors'><p>Get the default ggplot color palette or a color palette based on the ggplot</p>
palette, but with sub-colors that differ in their luminance</a></li>
<li><a href='#lineplot_split_clone'><p>Show line plots of all integration sites over time, split into facets by</p>
their respective clone.</a></li>
<li><a href='#normalize_timecourse'><p>Normalizes a time course using a given mapping from integration sites to</p>
clones.</a></li>
<li><a href='#plot_rsquare'><p>Plots R^2 of two integration sites</p></a></li>
<li><a href='#plot.clusterObj'><p>Plots the clustering based on a clustering object</p></a></li>
<li><a href='#plot.ISSimilarity'><p>Plots the similarity of integration sites</p></a></li>
<li><a href='#plot.timeseries'><p>Plots time series data, which consists of multiple measurements over</p>
time / place (cols) of different clones / integration sites (rows).</a></li>
<li><a href='#reconstruct'><p>Apply a clustering algorithm to a given time course.</p></a></li>
<li><a href='#reconstruct_kmedoid'><p>Calculate the k-medoids clustering for a given time course.</p></a></li>
<li><a href='#reconstruct_recursive'><p>Apply a clustering algorithm recursively to a given time course.</p></a></li>
<li><a href='#weighted_spring_model'><p>Plot the relationship of integration sites as a graph.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Reconstruction of Clones from Integration Site Readouts and
Visualization</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-08-06</td>
</tr>
<tr>
<td>Author:</td>
<td>Sebastian Wagner <a href="https://orcid.org/0000-0001-6468-4833"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut],
  Christoph Baldow <a href="https://orcid.org/0000-0002-4366-1453"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Ingmar Glauche <a href="https://orcid.org/0000-0002-2524-1199"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ths]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sebastian Wagner &lt;sebastian.wagner3@tu-dresden.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools necessary to reconstruct clonal affiliations from
    temporally and/or spatially separated measurements of viral
    integration sites. For this means it utilizes correlations present
    in the relative readouts of the integration sites. Furthermore,
    facilities for filtering of the data and visualization of different
    steps in the pipeline are provided with the package.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-2">LGPL-2</a> | <a href="https://www.r-project.org/Licenses/LGPL-2.1">LGPL-2.1</a> | <a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a> [expanded from: LGPL]</td>
</tr>
<tr>
<td>Imports:</td>
<td>clValid, cluster, clv, dplyr, foreach, ggplot2, igraph, ltm,
plyr, poweRlaw, reshape2, RColorBrewer, rlang, rmutil</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, markdown, mclust, testthat, gridExtra</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-08-06 10:36:57 UTC; wagnese</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-08-06 11:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bushmanplot'>Create a stacked area plot that represents the abundance of integration
sites over time.</h2><span id='topic+bushmanplot'></span>

<h3>Description</h3>

<p>Create a stacked area plot that represents the abundance of integration
sites over time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bushmanplot(
  readouts,
  aes = NULL,
  col = NULL,
  only = NULL,
  rec = NULL,
  time = NULL,
  facet = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bushmanplot_+3A_readouts">readouts</code></td>
<td>
<p>The readouts of the integration sites over time.</p>
</td></tr>
<tr><td><code id="bushmanplot_+3A_aes">aes</code></td>
<td>
<p>An additional 'ggplot2::aes' object, that will be used as the
plots main aesthetic. Note, that the 'geom_area' object
overwrites some of these aesthetics. Useful if you later on
want to add additional elements to the plot.</p>
</td></tr>
<tr><td><code id="bushmanplot_+3A_col">col</code></td>
<td>
<p>A color palette for integration sites that should be colored. Any
integration site not in this named vector will be colored
'gray50'. This takes precedence over 'only' and 'rec'.</p>
</td></tr>
<tr><td><code id="bushmanplot_+3A_only">only</code></td>
<td>
<p>A list of integration sites that should be colored with the
default ggplot2 color palette. Any other integration site is
colored 'gray50'. Takes precedence over 'rec'.</p>
</td></tr>
<tr><td><code id="bushmanplot_+3A_rec">rec</code></td>
<td>
<p>A matrix containing the columns &quot;IS&quot; and &quot;Clone&quot;. Integration
sites will be colored by the clone they belong to. The colors for
the clones are the default ggplot2 ones.</p>
</td></tr>
<tr><td><code id="bushmanplot_+3A_time">time</code></td>
<td>
<p>A function that extracts the time component from the measurement
(i.e. column)-names. Will be applied to the measurements.</p>
</td></tr>
<tr><td><code id="bushmanplot_+3A_facet">facet</code></td>
<td>
<p>A function that extracts a value from the measurement names and
splits the plot into different facets by that values. Useful,
for example if you have measurements that are sorted for the
cell type and you want to split these into facets.</p>
</td></tr>
</table>

<hr>
<h2 id='bw'>Calculate the bw index</h2><span id='topic+bw'></span>

<h3>Description</h3>

<p>Calculate the bw index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw(distance, clusters, bw_balance = 1, ind_cluster = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw_+3A_distance">distance</code></td>
<td>
<p>Distance or Dis-Similarity Matrix</p>
</td></tr>
<tr><td><code id="bw_+3A_clusters">clusters</code></td>
<td>
<p>The clustering to evaluate.</p>
</td></tr>
<tr><td><code id="bw_+3A_bw_balance">bw_balance</code></td>
<td>
<p>The balance [0, 1] between inner cluster similarity
(Compactness) and the similarity between clusters
(Separation). A balance value &lt; 1 increases the importance
of Compactness, whereas a value &gt; 1 increases the
importance of Separation.</p>
</td></tr>
<tr><td><code id="bw_+3A_ind_cluster">ind_cluster</code></td>
<td>
<p>If true, the bw value for all individual clusters is
returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A score that describes how well the clustering fits the data.
</p>

<hr>
<h2 id='convert_columnwise_relative'>Converts a matrix to relative abundances</h2><span id='topic+convert_columnwise_relative'></span>

<h3>Description</h3>

<p>Converts a matrix to relative abundances
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_columnwise_relative(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_columnwise_relative_+3A_data">data</code></td>
<td>
<p>A matrix of readouts that should be converted to relative
abundances</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix with all columns in percent
</p>

<hr>
<h2 id='evaluate_clustering'>Evaluate a clustering using the given method</h2><span id='topic+evaluate_clustering'></span>

<h3>Description</h3>

<p>Evaluate a clustering using the given method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_clustering(readouts, clustering, sim, method, custom_eval = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_clustering_+3A_readouts">readouts</code></td>
<td>
<p>The readouts the clustering and similarity matrix are based
on.</p>
</td></tr>
<tr><td><code id="evaluate_clustering_+3A_clustering">clustering</code></td>
<td>
<p>The clustering to evaluate.</p>
</td></tr>
<tr><td><code id="evaluate_clustering_+3A_sim">sim</code></td>
<td>
<p>The similarity matrix, this clustering is based on.</p>
</td></tr>
<tr><td><code id="evaluate_clustering_+3A_method">method</code></td>
<td>
<p>The method to evaluate the given clustering. This might be one
of &quot;silhouette&quot;, &quot;sdindex&quot;, &quot;ptbiserial&quot;, &quot;dunn&quot;, &quot;bw&quot;, or
&quot;custom'.</p>
</td></tr>
<tr><td><code id="evaluate_clustering_+3A_custom_eval">custom_eval</code></td>
<td>
<p>A custom function to be run for evaluating a clustering.
Only used with method &quot;custom&quot;.</p>
</td></tr>
<tr><td><code id="evaluate_clustering_+3A_...">...</code></td>
<td>
<p>Further arguments that are passed to a custom function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A score that describes how well the clustering fits the data.
</p>

<hr>
<h2 id='evaluate_clustering_bw'>Evaluate a clustering using the bw index</h2><span id='topic+evaluate_clustering_bw'></span>

<h3>Description</h3>

<p>Evaluate a clustering using the bw index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_clustering_bw(readouts, clustering, sim, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_clustering_bw_+3A_readouts">readouts</code></td>
<td>
<p>The readouts the clustering and similarity matrix are based
on.</p>
</td></tr>
<tr><td><code id="evaluate_clustering_bw_+3A_clustering">clustering</code></td>
<td>
<p>The clustering to evaluate.</p>
</td></tr>
<tr><td><code id="evaluate_clustering_bw_+3A_sim">sim</code></td>
<td>
<p>The similarity matrix, this clustering is based on.</p>
</td></tr>
<tr><td><code id="evaluate_clustering_bw_+3A_...">...</code></td>
<td>
<p>Further arguments that are passed to the bw function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A score that describes how well the clustering fits the data.
</p>

<hr>
<h2 id='evaluate_clustering_custom'>Evaluate a clustering using a custom evaluation function</h2><span id='topic+evaluate_clustering_custom'></span>

<h3>Description</h3>

<p>Evaluate a clustering using a custom evaluation function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_clustering_custom(readouts, clustering, sim, custom_eval, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_clustering_custom_+3A_readouts">readouts</code></td>
<td>
<p>The readouts the clustering and similarity matrix are based
on.</p>
</td></tr>
<tr><td><code id="evaluate_clustering_custom_+3A_clustering">clustering</code></td>
<td>
<p>The clustering to evaluate.</p>
</td></tr>
<tr><td><code id="evaluate_clustering_custom_+3A_sim">sim</code></td>
<td>
<p>The similarity matrix, this clustering is based on.</p>
</td></tr>
<tr><td><code id="evaluate_clustering_custom_+3A_custom_eval">custom_eval</code></td>
<td>
<p>The custom function to be run for evaluating a clustering.</p>
</td></tr>
<tr><td><code id="evaluate_clustering_custom_+3A_...">...</code></td>
<td>
<p>Further arguments that are passed to the custom function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A score that describes how well the clustering fits the data.
</p>

<hr>
<h2 id='evaluate_clustering_dunn'>Evaluate a clustering using the dunn index</h2><span id='topic+evaluate_clustering_dunn'></span>

<h3>Description</h3>

<p>Evaluate a clustering using the dunn index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_clustering_dunn(readouts, clustering, sim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_clustering_dunn_+3A_readouts">readouts</code></td>
<td>
<p>The readouts the clustering and similarity matrix are based
on.</p>
</td></tr>
<tr><td><code id="evaluate_clustering_dunn_+3A_clustering">clustering</code></td>
<td>
<p>The clustering to evaluate.</p>
</td></tr>
<tr><td><code id="evaluate_clustering_dunn_+3A_sim">sim</code></td>
<td>
<p>The similarity matrix, this clustering is based on.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A score that describes how well the clustering fits the data.
</p>

<hr>
<h2 id='evaluate_clustering_ptbiserial'>Evaluate a clustering using the point-biserial index</h2><span id='topic+evaluate_clustering_ptbiserial'></span>

<h3>Description</h3>

<p>Evaluate a clustering using the point-biserial index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_clustering_ptbiserial(readouts, clustering, sim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_clustering_ptbiserial_+3A_readouts">readouts</code></td>
<td>
<p>The readouts the clustering and similarity matrix are based
on.</p>
</td></tr>
<tr><td><code id="evaluate_clustering_ptbiserial_+3A_clustering">clustering</code></td>
<td>
<p>The clustering to evaluate.</p>
</td></tr>
<tr><td><code id="evaluate_clustering_ptbiserial_+3A_sim">sim</code></td>
<td>
<p>The similarity matrix, this clustering is based on.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A score that describes how well the clustering fits the data.
</p>

<hr>
<h2 id='evaluate_clustering_sdindex'>Evaluate a clustering using the SD-index</h2><span id='topic+evaluate_clustering_sdindex'></span>

<h3>Description</h3>

<p>Evaluate a clustering using the SD-index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_clustering_sdindex(readouts, clustering, sim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_clustering_sdindex_+3A_readouts">readouts</code></td>
<td>
<p>The readouts the clustering and similarity matrix are based
on.</p>
</td></tr>
<tr><td><code id="evaluate_clustering_sdindex_+3A_clustering">clustering</code></td>
<td>
<p>The clustering to evaluate.</p>
</td></tr>
<tr><td><code id="evaluate_clustering_sdindex_+3A_sim">sim</code></td>
<td>
<p>The similarity matrix, this clustering is based on.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A score that describes how well the clustering fits the data.
</p>

<hr>
<h2 id='evaluate_clustering_silhouette'>Evaluate a clustering using the silhouette index</h2><span id='topic+evaluate_clustering_silhouette'></span>

<h3>Description</h3>

<p>Evaluate a clustering using the silhouette index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_clustering_silhouette(readouts, clustering, sim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_clustering_silhouette_+3A_readouts">readouts</code></td>
<td>
<p>The readouts the clustering and similarity matrix are based
on.</p>
</td></tr>
<tr><td><code id="evaluate_clustering_silhouette_+3A_clustering">clustering</code></td>
<td>
<p>The clustering to evaluate.</p>
</td></tr>
<tr><td><code id="evaluate_clustering_silhouette_+3A_sim">sim</code></td>
<td>
<p>The similarity matrix, this clustering is based on.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A score that describes how well the clustering fits the data.
</p>

<hr>
<h2 id='filter_at_tp_biggest_n'>Filters a matrix of readouts for the n biggest IS at a certain
measurement</h2><span id='topic+filter_at_tp_biggest_n'></span>

<h3>Description</h3>

<p>Filters a matrix of readouts for the n biggest IS at a certain
measurement
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_at_tp_biggest_n(data, at = "168", n = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_at_tp_biggest_n_+3A_data">data</code></td>
<td>
<p>The readout matrix to filter.</p>
</td></tr>
<tr><td><code id="filter_at_tp_biggest_n_+3A_at">at</code></td>
<td>
<p>A filter for the columns/measurement. Only matching
columns/measurements are considered, though all will be returned.</p>
</td></tr>
<tr><td><code id="filter_at_tp_biggest_n_+3A_n">n</code></td>
<td>
<p>The number of biggest IS to return. If 'at' matches multiple
columns/measurements, the 'rowSum()' over the columns/measurements
will be used. For ties, more than 'n' IS may be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with only the n biggest IS at the selected measurements.
</p>

<hr>
<h2 id='filter_at_tp_min'>Filters a matrix of readouts for IS that have a minimum occurrence in some
measurement</h2><span id='topic+filter_at_tp_min'></span>

<h3>Description</h3>

<p>Filters a matrix of readouts for IS that have a minimum occurrence in some
measurement
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_at_tp_min(data, at = "168", min = 0.02)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_at_tp_min_+3A_data">data</code></td>
<td>
<p>The readout matrix to filter.</p>
</td></tr>
<tr><td><code id="filter_at_tp_min_+3A_at">at</code></td>
<td>
<p>A filter for the columns/measurements. Only matching
columns/measurements are considered, though all will be returned.
This is a regular expression, so multiple columns/measurements may
match it.</p>
</td></tr>
<tr><td><code id="filter_at_tp_min_+3A_min">min</code></td>
<td>
<p>The minimum with which an IS has to occur. This could be either
absolute or relative reads. If 'at' matches multiple
columns/measurements, the 'rowSum()' over the columns will be
used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with only the IS that occur with a minimum at the
selected measurements.
</p>

<hr>
<h2 id='filter_combine_measurements'>Combines columns that have the same name. The columns are joined additively.</h2><span id='topic+filter_combine_measurements'></span>

<h3>Description</h3>

<p>Combines columns that have the same name. The columns are joined additively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_combine_measurements(dat, pre_norm = TRUE, post_norm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_combine_measurements_+3A_dat">dat</code></td>
<td>
<p>The readout matrix to filter.</p>
</td></tr>
<tr><td><code id="filter_combine_measurements_+3A_pre_norm">pre_norm</code></td>
<td>
<p>Whether to normalize columns before joining them.</p>
</td></tr>
<tr><td><code id="filter_combine_measurements_+3A_post_norm">post_norm</code></td>
<td>
<p>Whether to normalize columns after they are joined.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix in which columns that had the same name are added and
(possibly) normalized.
</p>

<hr>
<h2 id='filter_is_names'>Shortens the rownames of a readout matrix to the shortest distinct prefix</h2><span id='topic+filter_is_names'></span>

<h3>Description</h3>

<p>Shortens the rownames of a readout matrix to the shortest distinct prefix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_is_names(dat, by = "[_():]|[^_():]*")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_is_names_+3A_dat">dat</code></td>
<td>
<p>The readout matrix for which the names should be filtered.</p>
</td></tr>
<tr><td><code id="filter_is_names_+3A_by">by</code></td>
<td>
<p>The regexp used to split the names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the names filtered to the shortest unique prefix.
</p>


<h3>See Also</h3>

<p>filter.names
</p>

<hr>
<h2 id='filter_match'>Filters for columns containing a certain substring.</h2><span id='topic+filter_match'></span>

<h3>Description</h3>

<p>Filters for columns containing a certain substring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_match(dat, match = "E2P11")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_match_+3A_dat">dat</code></td>
<td>
<p>The readout matrix to filter.</p>
</td></tr>
<tr><td><code id="filter_match_+3A_match">match</code></td>
<td>
<p>The substring that columns must match.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A readout matrix that only contains the columns whose names contain
the substring.
</p>

<hr>
<h2 id='filter_measurement_names'>Splits a vector of strings by a given regexp, selects and rearranges the
parts and joins them again</h2><span id='topic+filter_measurement_names'></span>

<h3>Description</h3>

<p>Splits a vector of strings by a given regexp, selects and rearranges the
parts and joins them again
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_measurement_names(dat, elems = c(1, 3), by = "_")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_measurement_names_+3A_dat">dat</code></td>
<td>
<p>The readout matrix to filter.</p>
</td></tr>
<tr><td><code id="filter_measurement_names_+3A_elems">elems</code></td>
<td>
<p>The elements to select. They are rearrange in the order that is
given via this argument.</p>
</td></tr>
<tr><td><code id="filter_measurement_names_+3A_by">by</code></td>
<td>
<p>The string used for splitting the names of the columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix where the names of the columns are split by the given
string, rearranged and again joined by the string.
</p>

<hr>
<h2 id='filter_names'>Filters a vector of names and returns the shortest common prefix.</h2><span id='topic+filter_names'></span>

<h3>Description</h3>

<p>Filters a vector of names and returns the shortest common prefix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_names(names, by = "[_():]|[^_():]*")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_names_+3A_names">names</code></td>
<td>
<p>The vector of names to filter.</p>
</td></tr>
<tr><td><code id="filter_names_+3A_by">by</code></td>
<td>
<p>A regexp that splits the string. The default filters by special
characters. A split by character can be achieved by using &quot;.&quot; as
the regexp.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The names shortened to the shortest prefix (in chunks defined by
the regexp) where all names are unique.
</p>

<hr>
<h2 id='filter_nr_tp_min'>Filters for a minimum number of time points/measurements</h2><span id='topic+filter_nr_tp_min'></span>

<h3>Description</h3>

<p>Filters for a minimum number of time points/measurements
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_nr_tp_min(dat, min = 6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_nr_tp_min_+3A_dat">dat</code></td>
<td>
<p>The readout matrix to filter.</p>
</td></tr>
<tr><td><code id="filter_nr_tp_min_+3A_min">min</code></td>
<td>
<p>The minimum number of measurements where an IS needs to have a
value that is not 0 or NA.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with only ISs that have more than 'min' columns that are
not 0 or NA.
</p>

<hr>
<h2 id='filter_zero_columns'>Removes columns that only contain 0 or NA.</h2><span id='topic+filter_zero_columns'></span>

<h3>Description</h3>

<p>Removes columns that only contain 0 or NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_zero_columns(dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_zero_columns_+3A_dat">dat</code></td>
<td>
<p>The readout matrix to filter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix where columns that where only 0 or NA are filtered out.
</p>

<hr>
<h2 id='filter_zero_rows'>Removes rows that only contain 0 or NA.</h2><span id='topic+filter_zero_rows'></span>

<h3>Description</h3>

<p>Removes rows that only contain 0 or NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_zero_rows(dat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_zero_rows_+3A_dat">dat</code></td>
<td>
<p>The readout matrix to filter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix where rows that where only 0 or NA are filtered out.
</p>

<hr>
<h2 id='find_best_nr_cluster'>Finds the best number of clusters according to silhouette</h2><span id='topic+find_best_nr_cluster'></span>

<h3>Description</h3>

<p>Finds the best number of clusters according to silhouette
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_best_nr_cluster(
  data,
  sim,
  method_reconstruction = "kmedoids",
  method_evaluation = "silhouette",
  report = FALSE,
  parallel = FALSE,
  best = max,
  return_all = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_best_nr_cluster_+3A_data">data</code></td>
<td>
<p>The barcode data in a matrix.</p>
</td></tr>
<tr><td><code id="find_best_nr_cluster_+3A_sim">sim</code></td>
<td>
<p>A similarity matrix.</p>
</td></tr>
<tr><td><code id="find_best_nr_cluster_+3A_method_reconstruction">method_reconstruction</code></td>
<td>
<p>The clustering method to use.</p>
</td></tr>
<tr><td><code id="find_best_nr_cluster_+3A_method_evaluation">method_evaluation</code></td>
<td>
<p>The evaluation method to use.</p>
</td></tr>
<tr><td><code id="find_best_nr_cluster_+3A_report">report</code></td>
<td>
<p>Whether the current progress should be reported. Note that
this will not work if parallel is set to TRUE.</p>
</td></tr>
<tr><td><code id="find_best_nr_cluster_+3A_parallel">parallel</code></td>
<td>
<p>Whether the clustering should be performed in parallel.</p>
</td></tr>
<tr><td><code id="find_best_nr_cluster_+3A_best">best</code></td>
<td>
<p>The method to use to determine the best clustering.</p>
</td></tr>
<tr><td><code id="find_best_nr_cluster_+3A_return_all">return_all</code></td>
<td>
<p>Whether to return the silhouette score for all
clusterings.</p>
</td></tr>
<tr><td><code id="find_best_nr_cluster_+3A_...">...</code></td>
<td>
<p>passed params to evaluating clustering</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The R^2 value for rows is1 and is2 in matrix dat
</p>

<hr>
<h2 id='get_similarity_matrix'>Generate a similarity matrix</h2><span id='topic+get_similarity_matrix'></span>

<h3>Description</h3>

<p>Generate a similarity matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_similarity_matrix(
  readouts,
  self = NULL,
  upper = TRUE,
  method = "rsquared",
  strategy = "atLeastOne",
  min_measures = 3L,
  post_norm = TRUE,
  parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_similarity_matrix_+3A_readouts">readouts</code></td>
<td>
<p>The readouts that are used to generate the similarity matrix</p>
</td></tr>
<tr><td><code id="get_similarity_matrix_+3A_self">self</code></td>
<td>
<p>Values to set on the diagonal of the matrix. If NULL, the values
that are returned by the method are used.</p>
</td></tr>
<tr><td><code id="get_similarity_matrix_+3A_upper">upper</code></td>
<td>
<p>Only used with &quot;rsquared&quot;. If TRUE, generates the upper
triangle.</p>
</td></tr>
<tr><td><code id="get_similarity_matrix_+3A_method">method</code></td>
<td>
<p>The method to use as a string. Possible values for the string
are &quot;rsquared&quot; and any method that is accepted by stats::dist.
In case of stats::dist we are using the change in the values
over time / compartments (columns).</p>
</td></tr>
<tr><td><code id="get_similarity_matrix_+3A_strategy">strategy</code></td>
<td>
<p>Defines the strategy how to treat 0 / NA values. Considering
a pair (two lines), **atLeastOne** ignores all columns, where
both are 0. **all** takes all measures into account,
independent whether they are 0 or not.</p>
</td></tr>
<tr><td><code id="get_similarity_matrix_+3A_min_measures">min_measures</code></td>
<td>
<p>Minimum number of measures to compare two integration
sites (rows). If there are less measures, the similarity
entry is NA.</p>
</td></tr>
<tr><td><code id="get_similarity_matrix_+3A_post_norm">post_norm</code></td>
<td>
<p>Normalize the similarity matrix to [0,1] scale.</p>
</td></tr>
<tr><td><code id="get_similarity_matrix_+3A_parallel">parallel</code></td>
<td>
<p>Whether parallelism should be used. Number of cores is set
by option mc.cores. If unset, parallel::detectCores is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A similarity matrix.
</p>

<hr>
<h2 id='ggplot_colors'>Get the default ggplot color palette or a color palette based on the ggplot
palette, but with sub-colors that differ in their luminance</h2><span id='topic+ggplot_colors'></span>

<h3>Description</h3>

<p>This is an adapted version of https://stackoverflow.com/a/8197703
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggplot_colors(n = 6, h = c(0, 360) + 15, l = c(65, 65))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggplot_colors_+3A_n">n</code></td>
<td>
<p>The number of colors in the color palette. If 'n' is a vector,
get a color palette, that has 'length(n)' different base colors.
For each item in n, the actual colors are equally spaced on
in the luminance range 'l' between the upper and lower value.</p>
</td></tr>
<tr><td><code id="ggplot_colors_+3A_h">h</code></td>
<td>
<p>The hue range.</p>
</td></tr>
<tr><td><code id="ggplot_colors_+3A_l">l</code></td>
<td>
<p>A vector of length 2 that describes the luminance range</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of 'sum(n)' colors strings
</p>

<hr>
<h2 id='lineplot_split_clone'>Show line plots of all integration sites over time, split into facets by
their respective clone.</h2><span id='topic+lineplot_split_clone'></span>

<h3>Description</h3>

<p>Show line plots of all integration sites over time, split into facets by
their respective clone.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lineplot_split_clone(
  bd,
  rec,
  order = NULL,
  mapping = NULL,
  sim = NULL,
  silhouette_values = !is.null(sim),
  singletons = TRUE,
  zero_values = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lineplot_split_clone_+3A_bd">bd</code></td>
<td>
<p>The readouts of the integration sites over time.</p>
</td></tr>
<tr><td><code id="lineplot_split_clone_+3A_rec">rec</code></td>
<td>
<p>A matrix with columns &quot;IS&quot; and &quot;Clone&quot;, that describes for each
integration site, which clone it belongs to.</p>
</td></tr>
<tr><td><code id="lineplot_split_clone_+3A_order">order</code></td>
<td>
<p>Integration site names will be converted to a factor. This
allows to give the order for this factor, as it influences the
order in which the lines are drawn.</p>
</td></tr>
<tr><td><code id="lineplot_split_clone_+3A_mapping">mapping</code></td>
<td>
<p>A ggplot2 aesthetics mapping that will be merged with the
aesthetics used by this plot.</p>
</td></tr>
<tr><td><code id="lineplot_split_clone_+3A_sim">sim</code></td>
<td>
<p>A similarity matrix giving the similarities for each pair of
integration sites. Used if 'silhouette_values' is 'TRUE' to
calculate the silhouette score.</p>
</td></tr>
<tr><td><code id="lineplot_split_clone_+3A_silhouette_values">silhouette_values</code></td>
<td>
<p>A boolean value that determines whether the
silhouette values for each clone should be
calculated and added to the facet labels.
Requires 'sim' to be present.</p>
</td></tr>
<tr><td><code id="lineplot_split_clone_+3A_singletons">singletons</code></td>
<td>
<p>Whether to show clones that only have a single integration
site.</p>
</td></tr>
<tr><td><code id="lineplot_split_clone_+3A_zero_values">zero_values</code></td>
<td>
<p>How to handle values that are zero. If 'TRUE', they remain
zero and subsequently, a the measurement the line drops to
zero. If 'FALSE', the values are removed and a gap in the
line is shown.</p>
</td></tr>
</table>

<hr>
<h2 id='normalize_timecourse'>Normalizes a time course using a given mapping from integration sites to
clones.</h2><span id='topic+normalize_timecourse'></span>

<h3>Description</h3>

<p>Each integration site is replaced by its clone. The size of the clone is
adjusted to be the mean size of the integration sites within it. For
integration sites that are not mentioned in 'rec', we adjust by the average
number of integration sites per clone.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize_timecourse(readouts, rec, rec_first = FALSE, reduce_clones = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalize_timecourse_+3A_readouts">readouts</code></td>
<td>
<p>The integration site readouts to adjust.</p>
</td></tr>
<tr><td><code id="normalize_timecourse_+3A_rec">rec</code></td>
<td>
<p>A matrix with columns &quot;IS&quot; and &quot;Clone&quot; that assigns each
integration site to a clone.</p>
</td></tr>
<tr><td><code id="normalize_timecourse_+3A_rec_first">rec_first</code></td>
<td>
<p>Whether the clones should be put in the first rows of the
resulting time course.</p>
</td></tr>
<tr><td><code id="normalize_timecourse_+3A_reduce_clones">reduce_clones</code></td>
<td>
<p>Whether to represent the integration sites by their
respective clone.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The adjusted time course.
</p>

<hr>
<h2 id='plot_rsquare'>Plots R^2 of two integration sites</h2><span id='topic+plot_rsquare'></span>

<h3>Description</h3>

<p>Plots R^2 of two integration sites
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_rsquare(dat, is1, is2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_rsquare_+3A_dat">dat</code></td>
<td>
<p>The matrix that holds the values</p>
</td></tr>
<tr><td><code id="plot_rsquare_+3A_is1">is1</code></td>
<td>
<p>The name of the first row</p>
</td></tr>
<tr><td><code id="plot_rsquare_+3A_is2">is2</code></td>
<td>
<p>The name of the second row</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object, which can be used to further individualize or to
plot directly.
</p>

<hr>
<h2 id='plot.clusterObj'>Plots the clustering based on a clustering object</h2><span id='topic+plot.clusterObj'></span>

<h3>Description</h3>

<p>Plots the clustering based on a clustering object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'clusterObj'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.clusterObj_+3A_x">x</code></td>
<td>
<p>The clustering object.</p>
</td></tr>
<tr><td><code id="plot.clusterObj_+3A_...">...</code></td>
<td>
<p>Further arguments are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object, which can be used to further individualize or to
plot directly.
</p>

<hr>
<h2 id='plot.ISSimilarity'>Plots the similarity of integration sites</h2><span id='topic+plot.ISSimilarity'></span>

<h3>Description</h3>

<p>Plots the similarity of integration sites
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ISSimilarity'
plot(x, na.rm = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ISSimilarity_+3A_x">x</code></td>
<td>
<p>The matrix that holds the similarity values</p>
</td></tr>
<tr><td><code id="plot.ISSimilarity_+3A_na.rm">na.rm</code></td>
<td>
<p>whether NA values should be deleted beforehand</p>
</td></tr>
<tr><td><code id="plot.ISSimilarity_+3A_...">...</code></td>
<td>
<p>Further arguments are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object, which can be used to further individualize or to
plot directly.
</p>

<hr>
<h2 id='plot.timeseries'>Plots time series data, which consists of multiple measurements over
time / place (cols) of different clones / integration sites (rows).</h2><span id='topic+plot.timeseries'></span>

<h3>Description</h3>

<p>Plots time series data, which consists of multiple measurements over
time / place (cols) of different clones / integration sites (rows).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'timeseries'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.timeseries_+3A_x">x</code></td>
<td>
<p>The data to plot.</p>
</td></tr>
<tr><td><code id="plot.timeseries_+3A_...">...</code></td>
<td>
<p>Further arguments are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object, which can be used to further individualize or to
plot directly.
</p>

<hr>
<h2 id='reconstruct'>Apply a clustering algorithm to a given time course.</h2><span id='topic+reconstruct'></span>

<h3>Description</h3>

<p>Apply a clustering algorithm to a given time course.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reconstruct(
  readouts,
  target_communities,
  method = "kmedoids",
  sim = MultIS::get_similarity_matrix(readouts = readouts, upper = TRUE),
  cluster_obj = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reconstruct_+3A_readouts">readouts</code></td>
<td>
<p>The time course for which to find clusters.</p>
</td></tr>
<tr><td><code id="reconstruct_+3A_target_communities">target_communities</code></td>
<td>
<p>The number of clusters to cluster for.</p>
</td></tr>
<tr><td><code id="reconstruct_+3A_method">method</code></td>
<td>
<p>Either &quot;kmedoids&quot;, &quot;kmeans&quot; or any string permitted as a
method for stats::hclust.</p>
</td></tr>
<tr><td><code id="reconstruct_+3A_sim">sim</code></td>
<td>
<p>A similarity matrix used with all methods except &quot;kmeans&quot;.</p>
</td></tr>
<tr><td><code id="reconstruct_+3A_cluster_obj">cluster_obj</code></td>
<td>
<p>If TRUE, a clusterObject with the readouts, similarity
and clustering is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with two columns: &quot;Clone&quot; and &quot;IS&quot; or if
cluster_obj = TRUE a cluster object, which can be used to plot the
clustering.
</p>

<hr>
<h2 id='reconstruct_kmedoid'>Calculate the k-medoids clustering for a given time course.</h2><span id='topic+reconstruct_kmedoid'></span>

<h3>Description</h3>

<p>Calculate the k-medoids clustering for a given time course.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reconstruct_kmedoid(
  readouts,
  target_communities,
  sim = MultIS::get_similarity_matrix(readouts = readouts, self = 0, upper = TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reconstruct_kmedoid_+3A_readouts">readouts</code></td>
<td>
<p>The time course for which to find clusters.</p>
</td></tr>
<tr><td><code id="reconstruct_kmedoid_+3A_target_communities">target_communities</code></td>
<td>
<p>The number of clusters to cluster for.</p>
</td></tr>
<tr><td><code id="reconstruct_kmedoid_+3A_sim">sim</code></td>
<td>
<p>A similarity matrix for the time course.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with two columns: &quot;Clone&quot; and &quot;IS&quot;.
</p>

<hr>
<h2 id='reconstruct_recursive'>Apply a clustering algorithm recursively to a given time course.</h2><span id='topic+reconstruct_recursive'></span>

<h3>Description</h3>

<p>Apply a clustering algorithm recursively to a given time course.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reconstruct_recursive(
  readouts,
  method = "kmedoids",
  sim = MultIS::get_similarity_matrix(readouts = readouts, upper = TRUE),
  split_similarity = 0.7,
  combine_similarity = 0.9,
  use_silhouette = TRUE,
  cluster_obj = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reconstruct_recursive_+3A_readouts">readouts</code></td>
<td>
<p>The time course for which to find clusters.</p>
</td></tr>
<tr><td><code id="reconstruct_recursive_+3A_method">method</code></td>
<td>
<p>Either &quot;kmedoids&quot;, &quot;kmeans&quot; or any string permitted as a
method for stats::hclust.</p>
</td></tr>
<tr><td><code id="reconstruct_recursive_+3A_sim">sim</code></td>
<td>
<p>A similarity matrix used with all methods except &quot;kmeans&quot;.</p>
</td></tr>
<tr><td><code id="reconstruct_recursive_+3A_split_similarity">split_similarity</code></td>
<td>
<p>Similarity Threshold. If any two elements within a
cluster are below this threshold, another split is
initiated.</p>
</td></tr>
<tr><td><code id="reconstruct_recursive_+3A_combine_similarity">combine_similarity</code></td>
<td>
<p>After Splitting, a combination phase is activated.
If any two elements between two clusters have a
similarity higher than this threshold, the cluster
are combined.</p>
</td></tr>
<tr><td><code id="reconstruct_recursive_+3A_use_silhouette">use_silhouette</code></td>
<td>
<p>If TRUE, silhouette is used to define number of cluster
during splitting, otherwise cluster are always split
into two new clusters.</p>
</td></tr>
<tr><td><code id="reconstruct_recursive_+3A_cluster_obj">cluster_obj</code></td>
<td>
<p>If TRUE, a clusterObject with the readouts, similarity
and clustering is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with two columns: &quot;Clone&quot; and &quot;IS&quot; or if
cluster_obj = TRUE a cluster object, which can be used to plot the
clustering.
</p>

<hr>
<h2 id='weighted_spring_model'>Plot the relationship of integration sites as a graph.</h2><span id='topic+weighted_spring_model'></span>

<h3>Description</h3>

<p>Integration sites will be represented as nodes in the graph, while their
mutual similarity is indicated by the line size and opaqueness of the lines
between them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted_spring_model(
  readouts,
  mapping,
  gt,
  sim = get_similarity_matrix(readouts, self = NA, upper = FALSE, parallel = FALSE),
  rec_pal = NULL,
  clone_pal = NULL,
  line_color = "#009900FF",
  seed = 4711L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted_spring_model_+3A_readouts">readouts</code></td>
<td>
<p>The integration site readouts that this spring model is
based on.</p>
</td></tr>
<tr><td><code id="weighted_spring_model_+3A_mapping">mapping</code></td>
<td>
<p>The reconstructed mapping from clones to integration sites.
This is represented as a matrix with two columns &quot;IS&quot; and
&quot;Clone&quot;.</p>
</td></tr>
<tr><td><code id="weighted_spring_model_+3A_gt">gt</code></td>
<td>
<p>The ground truth mapping from clones to integration sites, if
available. Same structure as 'mapping'.</p>
</td></tr>
<tr><td><code id="weighted_spring_model_+3A_sim">sim</code></td>
<td>
<p>The similarity matrix holding the similarities between all
integration sites.</p>
</td></tr>
<tr><td><code id="weighted_spring_model_+3A_rec_pal">rec_pal</code></td>
<td>
<p>A named vector color palette holding colors for each
integration site. Will be used as the fill color for the
nodes.</p>
</td></tr>
<tr><td><code id="weighted_spring_model_+3A_clone_pal">clone_pal</code></td>
<td>
<p>A named vector color palette holding colors for each
integration site. Will be used as the line color for the
nodes.</p>
</td></tr>
<tr><td><code id="weighted_spring_model_+3A_line_color">line_color</code></td>
<td>
<p>The line color to use for the edges of the graph.</p>
</td></tr>
<tr><td><code id="weighted_spring_model_+3A_seed">seed</code></td>
<td>
<p>A seed that will be set using 'set.seed()' to ensure
consistent behaviour with the layout that is provided by
'igraph'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object that contains the generated graph.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
