<!DOCTYPE html><html lang="en"><head><title>Help for package cppRouting</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cppRouting}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#assign_traffic'><p>Algorithms for solving the Traffic Assignment Problem (TAP).</p></a></li>
<li><a href='#cpp_contract'><p>Contraction hierarchies algorithm</p></a></li>
<li><a href='#cpp_simplify'><p>Reduce the number of edges by removing non-intersection nodes, duplicated edges and isolated loops in the graph.</p></a></li>
<li><a href='#get_aon'><p>Given an origin-destination matrix, compute All-or-Nothing assignment.</p></a></li>
<li><a href='#get_detour'><p>Return the nodes that can be reached in a detour time set around the shortest path</p></a></li>
<li><a href='#get_distance_matrix'><p>Compute all shortest distance between origin and destination nodes.</p></a></li>
<li><a href='#get_distance_pair'><p>Compute shortest distance between origin and destination nodes.</p></a></li>
<li><a href='#get_isochrone'><p>Compute isochrones/isodistances from nodes.</p></a></li>
<li><a href='#get_multi_paths'><p>Compute all shortest paths between origin and destination nodes.</p></a></li>
<li><a href='#get_path_pair'><p>Compute shortest path between origin and destination nodes.</p></a></li>
<li><a href='#makegraph'><p>Construct graph</p></a></li>
<li><a href='#to_df'><p>Convert cppRouting graph to data.frame</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Algorithms for Routing and Solving the Traffic Assignment
Problem</td>
</tr>
<tr>
<td>Version:</td>
<td>3.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-11-28</td>
</tr>
<tr>
<td>Author:</td>
<td>Vincent Larmet</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Vincent Larmet &lt;larmet.vincent@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Calculation of distances, shortest paths and isochrones on weighted graphs using several variants of Dijkstra algorithm.
    Proposed algorithms are unidirectional Dijkstra (Dijkstra, E. W. (1959) &lt;<a href="https://doi.org/10.1007%2FBF01386390">doi:10.1007/BF01386390</a>&gt;),
    bidirectional Dijkstra (Goldberg, Andrew &amp; Fonseca F. Werneck, Renato (2005) <a href="https://archive.siam.org/meetings/alenex05/papers/03agoldberg.pdf">https://archive.siam.org/meetings/alenex05/papers/03agoldberg.pdf</a>),
    A* search (P. E. Hart, N. J. Nilsson et B. Raphael (1968) &lt;<a href="https://doi.org/10.1109%2FTSSC.1968.300136">doi:10.1109/TSSC.1968.300136</a>&gt;),
    new bidirectional A* (Pijls &amp; Post (2009) <a href="https://repub.eur.nl/pub/16100/ei2009-10.pdf">https://repub.eur.nl/pub/16100/ei2009-10.pdf</a>),
    Contraction hierarchies (R. Geisberger, P. Sanders, D. Schultes and D. Delling (2008) &lt;<a href="https://doi.org/10.1007%2F978-3-540-68552-4_24">doi:10.1007/978-3-540-68552-4_24</a>&gt;),
    PHAST (D. Delling, A.Goldberg, A. Nowatzyk, R. Werneck (2011) &lt;<a href="https://doi.org/10.1016%2Fj.jpdc.2012.02.007">doi:10.1016/j.jpdc.2012.02.007</a>&gt;).
    Algorithms for solving the traffic assignment problem are All-or-Nothing assignment,
    Method of Successive Averages,
    Frank-Wolfe algorithm (M. Fukushima (1984) &lt;<a href="https://doi.org/10.1016%2F0191-2615%2884%2990029-8">doi:10.1016/0191-2615(84)90029-8</a>&gt;),
    Conjugate and Bi-Conjugate Frank-Wolfe algorithms (M. Mitradjieva, P. O. Lindberg (2012) &lt;<a href="https://doi.org/10.1287%2Ftrsc.1120.0409">doi:10.1287/trsc.1120.0409</a>&gt;),
    Algorithm-B (R. B. Dial (2006) &lt;<a href="https://doi.org/10.1016%2Fj.trb.2006.02.008">doi:10.1016/j.trb.2006.02.008</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.7), RcppParallel, RcppProgress, data.table</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppParallel, RcppProgress</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make, C++11</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/vlarmet/cppRouting">https://github.com/vlarmet/cppRouting</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, igraph</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-29 07:45:49 UTC; vincent</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-12-01 13:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='assign_traffic'>Algorithms for solving the Traffic Assignment Problem (TAP).</h2><span id='topic+assign_traffic'></span>

<h3>Description</h3>

<p>Estimation of the User Equilibrium (UE)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assign_traffic(
  Graph,
  from,
  to,
  demand,
  algorithm = "bfw",
  max_gap = 0.001,
  max_it = .Machine$integer.max,
  aon_method = "bi",
  constant = 1,
  dial_params = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assign_traffic_+3A_graph">Graph</code></td>
<td>
<p>An object generated by <a href="#topic+makegraph">makegraph</a> function.</p>
</td></tr>
<tr><td><code id="assign_traffic_+3A_from">from</code></td>
<td>
<p>A vector of origins</p>
</td></tr>
<tr><td><code id="assign_traffic_+3A_to">to</code></td>
<td>
<p>A vector of destinations.</p>
</td></tr>
<tr><td><code id="assign_traffic_+3A_demand">demand</code></td>
<td>
<p>A vector describing the flow between each origin-destination pair.</p>
</td></tr>
<tr><td><code id="assign_traffic_+3A_algorithm">algorithm</code></td>
<td>
<p>character. <code>msa</code>, <code>fw</code>, <code>cfw</code>, <code>bfw</code> or <code>dial</code>. Default to <code>bfw</code>. See details.</p>
</td></tr>
<tr><td><code id="assign_traffic_+3A_max_gap">max_gap</code></td>
<td>
<p>Numeric. Relative gap to achieve. Default to 0.001.</p>
</td></tr>
<tr><td><code id="assign_traffic_+3A_max_it">max_it</code></td>
<td>
<p>Numeric. Maximum number of iterations. Default to <code>.Machine$integer.max</code></p>
</td></tr>
<tr><td><code id="assign_traffic_+3A_aon_method">aon_method</code></td>
<td>
<p>Character.<code>d</code>, <code>bi</code>, <code>nba</code>, <code>cphast</code> or <code>cbi</code>. Default to <code>bi</code>. See details.</p>
</td></tr>
<tr><td><code id="assign_traffic_+3A_constant">constant</code></td>
<td>
<p>numeric. Constant to maintain the heuristic function admissible in NBA* algorithm. Default to 1, when cost is expressed in the same unit than coordinates. See details</p>
</td></tr>
<tr><td><code id="assign_traffic_+3A_dial_params">dial_params</code></td>
<td>
<p>List. Named list of hyperparameters for <code>dial</code> algorithm. See details.</p>
</td></tr>
<tr><td><code id="assign_traffic_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), progression is displayed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The most well-known assumptions in traffic assignment models are the ones following Wardrop's first principle.
Traffic assignment models are used to estimate the traffic flows on a network. These models take as input a matrix of flows that indicate the volume of traffic between origin and destination (O-D) pairs.
Unlike All-or-Nothing assignment (see <a href="#topic+get_aon">get_aon</a>), edge congestion is modeled through the <strong>Volume Decay Function (VDF)</strong>.
The Volume Decay Function used is the most popular in literature, from the Bureau of Public Roads :
</p>
<p><strong>t = t0 * (1 + a * (V/C)^b) </strong>
with t = actual travel time (minutes),
t0 = free-flow travel time (minutes),
a = alpha parameter (unitless),
b = beta parameter (unitless),
V = volume or flow (veh/hour)
C = edge capacity (veh/hour)
</p>
<p>Traffic Assignment Problem is a convex problem and solving algorithms can be divided into two categories : </p>

<ul>
<li><p> link-based : <strong>Method of Successive Average</strong> (<code>msa</code>) and <strong>Frank-Wolfe variants</strong> (normal : <code>fw</code>, conjugate : <code>cfw</code> and bi-conjugate : <code>bfw</code>).
These algorithms uses the descent direction given by AON assignment at each iteration, all links are updated at the same time.
</p>
</li>
<li><p> bush-based : <strong>Algorithm-B</strong> (<code>dial</code>)
The problem is decomposed into sub-problems, corresponding to each origin of the OD matrix, that operate on acyclic sub-networks of the original transportation network, called bushes.
Link flows are shifted from the longest path to the shortest path recursively within each bush using Newton method.
</p>
</li></ul>

<p>Link-based algorithms are historically the first algorithms developed for solving the traffic assignment problem. It require low memory and are known to tail in the vicinity of the optimum and usually cannot be used to achieve highly precise solutions.
Algorithm B is more recent, and is better suited for achieve the highest precise solution. However, it require more memory and can be time-consuming according the network size and OD matrix size.
In <code>cppRouting</code>, the implementation of algorithm-B allow &quot;batching&quot;, i.e. bushes are temporarily stored on disk if memory limit, defined by the user, is exceeded.
Please see the package website for practical example and deeper explanations about algorithms. (<a href="https://github.com/vlarmet/cppRouting/blob/master/README.md">https://github.com/vlarmet/cppRouting/blob/master/README.md</a>)
</p>
<p>Convergence criterion can be set by the user using max_gap argument, it is the relative gap which can be written as :
<strong>abs(TSTT/SPTT - 1)</strong>
with TSTT (Total System Travel Time) = sum(flow * cost),
SPTT (Shortest Path Travel Time) = sum(aon * cost)
</p>
<p>Especially for link-based algorithms (msa, *fw), the larger part of computation time rely on AON assignment. So, choosing the right AON algorithm is crucial for fast execution time.
Contracting the network on-the-fly before AON computing can be faster for large network and/or large OD matrix.
</p>
<p>AON algorithms are : </p>

<ul>
<li> <p><code>bi</code> : bidirectional Dijkstra algorithm
</p>
</li>
<li> <p><code>nba</code> : bidirectional A* algorithm, nodes coordinates and constant parameter are needed
</p>
</li>
<li> <p><code>d</code> : Dijkstra algorithm
</p>
</li>
<li> <p><code>cbi</code> : contraction hierarchies + bidirectional search
</p>
</li>
<li> <p><code>cphast</code> : contraction hierarchies + phast algorithm
</p>
</li></ul>

<p>These AON algorithm can be decomposed into two families, depending the sparsity of origin-destination matrix : </p>

<ul>
<li><p> recursive pairwise : <code>bi</code>, <code>nba</code> and <code>cbi</code>. Optimal for high sparsity. One-to-one algorithm is called N times, with N being the length of from.
</p>
</li>
<li><p> recursive one-to-many : <code>d</code> and <code>cphast</code>. Optimal for dense matrix. One-to-many algorithm is called N times, with N being the number of unique from (or to) nodes
</p>
</li></ul>

<p>For large instance, it may be appropriate to test different <code>aon_method</code> for few iterations and choose the fastest one for the final estimation.
</p>
<p>Hyperparameters for algorithm-b are : </p>

<ul>
<li> <p><code>inneriter</code> : number of time bushes are equilibrated within each iteration. Default to 20
</p>
</li>
<li> <p><code>max_tol</code> : numerical tolerance. Flow is set to 0 if less than max_tol. Since flow shifting consist of iteratively adding or substracting double types, numerical error can occur and stop convergence.
Default to 1e-11.
</p>
</li>
<li> <p><code>tmp_path</code> : Path for storing bushes during algorithm-B execution. Default using <code>tempdir()</code>
</p>
</li>
<li> <p><code>max_mem</code> : Maximum amount of RAM used by algorithm-B in gigabytes. Default to 8.
</p>
</li></ul>

<p>In New Bidirectional A star algorithm, euclidean distance is used as heuristic function.
To understand the importance of constant parameter, see the package description : <a href="https://github.com/vlarmet/cppRouting/blob/master/README.md">https://github.com/vlarmet/cppRouting/blob/master/README.md</a>
All algorithms are partly multithreaded (AON assignment).
</p>


<h3>Value</h3>

<p>A <code>list</code> containing : </p>

<ul>
<li><p> The relative gap achieved
</p>
</li>
<li><p> Number of iteration
</p>
</li>
<li><p> A data.frame containing edges attributes, including equilibrated flows, new costs and free-flow travel times.
</p>
</li></ul>



<h3>Note</h3>

<p><code>from</code>, <code>to</code> and <code>demand</code> must be the same length.
<code>alpha</code>, <code>beta</code> and <code>capacity</code> must be filled in during network construction. See <a href="#topic+makegraph">makegraph</a>.
</p>


<h3>References</h3>

<p>Wardrop, J. G. (1952). &quot;Some Theoretical Aspects of Road Traffic Research&quot;.
</p>
<p>M. Fukushima (1984). &quot;A modified Frank-Wolfe algorithm for solving the traffic assignment problem&quot;.
</p>
<p>R. B. Dial (2006). &quot;A path-based user-equilibrium traffic assignment algorithm that obviates path storage and enumeration&quot;.
</p>
<p>M. Mitradjieva, P. O. Lindberg (2012).  &quot;The Stiff Is Moving â€” Conjugate Direction Frank-Wolfe Methods with Applications to Traffic Assignment&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Choose number of cores used by cppRouting
RcppParallel::setThreadOptions(numThreads = 1)

#Data describing edges of the graph
edges&lt;-data.frame(from_vertex=c(0,0,1,1,2,2,3,4,4),
                  to_vertex=c(1,3,2,4,4,5,1,3,5),
                  cost=c(9,2,11,3,5,12,4,1,6))

# Origin-destination trips
trips &lt;- data.frame(from = c(0,0,0,0,1,1,1,1,2,2,2,3,3,4,5,5,5,5,5),
                    to = c(1,2,5,3,2,5,2,4,2,5,2,3,5,2,0,0,3,5,1),
                    flow = c(10,30,15,5,5,2,3,6,4,15,20,2,3,6,2,1,4,5,3))

#Construct graph
graph &lt;- makegraph(edges,directed=TRUE, alpha = 0.15, beta = 4, capacity = 5)


# Solve traffic assignment problem
## using Bi-conjugate Frank-Wolfe algorithm
traffic &lt;- assign_traffic(Graph=graph,
                          from=trips$from, to=trips$to, demand = trips$flow,
                          algorithm = "bfw")
print(traffic$data)

## using algorithm-B
traffic2 &lt;- assign_traffic(Graph=graph,
                           from=trips$from, to=trips$to, demand = trips$flow,
                           algorithm = "dial")
print(traffic2$data)
</code></pre>

<hr>
<h2 id='cpp_contract'>Contraction hierarchies algorithm</h2><span id='topic+cpp_contract'></span>

<h3>Description</h3>

<p>Contract a graph by using contraction hierarchies algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpp_contract(Graph, silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cpp_contract_+3A_graph">Graph</code></td>
<td>
<p>An object generated by <a href="#topic+makegraph">makegraph</a> or <a href="#topic+cpp_simplify">cpp_simplify</a> function.</p>
</td></tr>
<tr><td><code id="cpp_contract_+3A_silent">silent</code></td>
<td>
<p>Logical. If <code>TRUE</code>, progress is not displayed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Contraction hierarchies is a speed-up technique for finding shortest path in a graph.
It consist of two steps : preprocessing phase and query. <code>cpp_contract()</code> preprocess the input graph to later use special query algorithm implemented in <a href="#topic+get_distance_pair">get_distance_pair</a>, <a href="#topic+get_distance_matrix">get_distance_matrix</a>, <a href="#topic+get_aon">get_aon</a> and <a href="#topic+get_path_pair">get_path_pair</a> functions.
To see the benefits of using contraction hierarchies, see the package description : <a href="https://github.com/vlarmet/cppRouting/blob/master/README.md">https://github.com/vlarmet/cppRouting/blob/master/README.md</a>.
</p>


<h3>Value</h3>

<p>A contracted graph.
</p>


<h3>See Also</h3>

<p><a href="#topic+cpp_simplify">cpp_simplify</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Data describing edges of the graph
edges&lt;-data.frame(from_vertex=c(0,0,1,1,2,2,3,4,4),
                  to_vertex=c(1,3,2,4,4,5,1,3,5),
                  cost=c(9,2,11,3,5,12,4,1,6))

#Construct cppRouting graph
graph&lt;-makegraph(edges,directed=TRUE)

#Contract graph
contracted_graph&lt;-cpp_contract(graph,silent=TRUE)
</code></pre>

<hr>
<h2 id='cpp_simplify'>Reduce the number of edges by removing non-intersection nodes, duplicated edges and isolated loops in the graph.</h2><span id='topic+cpp_simplify'></span>

<h3>Description</h3>

<p>Reduce the number of edges by removing non-intersection nodes, duplicated edges and isolated loops in the graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpp_simplify(
  Graph,
  keep = NULL,
  rm_loop = TRUE,
  iterate = FALSE,
  silent = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cpp_simplify_+3A_graph">Graph</code></td>
<td>
<p>An object generated by <a href="#topic+makegraph">makegraph</a> function.</p>
</td></tr>
<tr><td><code id="cpp_simplify_+3A_keep">keep</code></td>
<td>
<p>Character or integer vector. Nodes of interest that will not be removed. Default to <code>NULL</code></p>
</td></tr>
<tr><td><code id="cpp_simplify_+3A_rm_loop">rm_loop</code></td>
<td>
<p>Logical. if <code>TRUE</code>, isolated loops as removed. Default to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="cpp_simplify_+3A_iterate">iterate</code></td>
<td>
<p>Logical. If <code>TRUE</code>, process is repeated until only intersection nodes remain in the graph. Default to FALSE</p>
</td></tr>
<tr><td><code id="cpp_simplify_+3A_silent">silent</code></td>
<td>
<p>Logical. If <code>TRUE</code> and iterate set to <code>TRUE</code>, number of iteration and number of removed nodes are printed to the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To understand why process can be iterated, see the package description : <a href="https://github.com/vlarmet/cppRouting/blob/master/README.md">https://github.com/vlarmet/cppRouting/blob/master/README.md</a>
</p>


<h3>Value</h3>

<p>The simplified cppRouting graph
</p>


<h3>Note</h3>

<p>Additional edge attributes like <code>aux</code>, <code>alpha</code>, <code>beta</code> and <code>capacity</code> will be removed.
The first iteration usually eliminates the majority of non-intersection nodes and is therefore faster.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Simple directed graph
edges&lt;-data.frame(from=c(1,2,3,4,5,6,7,8),
                  to=c(0,1,2,3,6,7,8,5),
                  dist=c(1,1,1,1,1,1,1,1))

#Plot
if(requireNamespace("igraph",quietly = TRUE)){
igr&lt;-igraph::graph_from_data_frame(edges)
plot(igr)
}

#Construct cppRouting graph
graph&lt;-makegraph(edges,directed=TRUE)

#Simplify the graph, removing loop
simp&lt;-cpp_simplify(graph, rm_loop=TRUE)

#Convert cppRouting graph to data frame
simp&lt;-to_df(simp)

#Plot
if(requireNamespace("igraph",quietly = TRUE)){
igr&lt;-igraph::graph_from_data_frame(simp)
plot(igr)
}

#Simplify the graph, keeping node 2 and keeping loop
simp&lt;-cpp_simplify(graph,keep=2 ,rm_loop=FALSE)

#Convert cppRouting graph to data frame
simp&lt;-to_df(simp)

#Plot
if(requireNamespace("igraph",quietly = TRUE)){
igr&lt;-igraph::graph_from_data_frame(simp)
plot(igr)
}

</code></pre>

<hr>
<h2 id='get_aon'>Given an origin-destination matrix, compute All-or-Nothing assignment.</h2><span id='topic+get_aon'></span>

<h3>Description</h3>

<p>Given an origin-destination matrix, compute All-or-Nothing assignment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_aon(Graph, from, to, demand, algorithm = "bi", constant = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_aon_+3A_graph">Graph</code></td>
<td>
<p>An object generated by <a href="#topic+makegraph">makegraph</a>, or <a href="#topic+cpp_contract">cpp_contract</a> function.</p>
</td></tr>
<tr><td><code id="get_aon_+3A_from">from</code></td>
<td>
<p>A vector of origins</p>
</td></tr>
<tr><td><code id="get_aon_+3A_to">to</code></td>
<td>
<p>A vector of destinations.</p>
</td></tr>
<tr><td><code id="get_aon_+3A_demand">demand</code></td>
<td>
<p>A vector describing the flow between each origin-destination pair.</p>
</td></tr>
<tr><td><code id="get_aon_+3A_algorithm">algorithm</code></td>
<td>
<p>character. For contracted network : <code>phast</code> or <code>bi</code>. Otherwise : <code>d</code>, <code>bi</code> or <code>nba</code>. Default to <code>bi</code>. See details.</p>
</td></tr>
<tr><td><code id="get_aon_+3A_constant">constant</code></td>
<td>
<p>numeric. Constant to maintain the heuristic function admissible in NBA* algorithm. Default to 1, when cost is expressed in the same unit than coordinates. See details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All-or-Nothing assignment (AON) is the simplest method to load flow on a network, since it assume there is no congestion effects.
The assignment algorithm itself is the procedure that loads the origin-destination matrix to the shortest path trees and produces the flows.
Origin-destination matrix is represented via 3 vectors : <code>from</code>, <code>to</code> and <code>demand</code>.
</p>
<p>There is two variants of algorithms, depending the <strong>sparsity</strong> of origin-destination matrix : </p>

<ul>
<li><p> recursive one-to-one : Bidirectional search (<code>bi</code>) and Bidirectional A* (<code>nba</code>). Optimal for high sparsity.
</p>
</li>
<li><p> recursive one-to-many : Dijkstra (<code>d</code>) and PHAST (<code>phast</code>). Optimal for dense matrix.
</p>
</li></ul>

<p>For large network and/or large OD matrix, this function is a lot faster on a contracted network.
In New Bidirectional A star algorithm, euclidean distance is used as heuristic function.
To understand the importance of constant parameter, see the package description : <a href="https://github.com/vlarmet/cppRouting/blob/master/README.md">https://github.com/vlarmet/cppRouting/blob/master/README.md</a>
</p>
<p>All algorithms are <strong>multithreaded.</strong> Please use <code>RcppParallel::setThreadOptions()</code> to set the number of threads.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> containing edges attributes, including flow.
</p>


<h3>Note</h3>

<p>'from', 'to' and 'demand' must be the same length.
</p>


<h3>See Also</h3>

<p><a href="#topic+cpp_contract">cpp_contract</a>, <a href="#topic+assign_traffic">assign_traffic</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Choose number of cores used by cppRouting
RcppParallel::setThreadOptions(numThreads = 1)

#Data describing edges of the graph
edges&lt;-data.frame(from_vertex=c(0,0,1,1,2,2,3,4,4),
                  to_vertex=c(1,3,2,4,4,5,1,3,5),
                  cost=c(9,2,11,3,5,12,4,1,6))

# Origin-destination trips
trips &lt;- data.frame(from = c(0,0,0,0,1,1,1,1,2,2,2,3,3,4,5,5,5,5,5),
                    to = c(1,2,5,3,2,5,2,4,2,5,2,3,5,2,0,0,3,5,1),
                    flow = c(10,30,15,5,5,2,3,6,4,15,20,2,3,6,2,1,4,5,3))

#Construct graph
graph&lt;-makegraph(edges,directed=TRUE)


# Compute All-or-Nothing assignment
aon &lt;- get_aon(Graph=graph, from=trips$from, to=trips$to, demand = trips$flow, algorithm = "d")
print(aon)
</code></pre>

<hr>
<h2 id='get_detour'>Return the nodes that can be reached in a detour time set around the shortest path</h2><span id='topic+get_detour'></span>

<h3>Description</h3>

<p>Return the nodes that can be reached in a detour time set around the shortest path
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_detour(Graph, from, to, extra = NULL, keep = NULL, long = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_detour_+3A_graph">Graph</code></td>
<td>
<p>An object generated by <a href="#topic+makegraph">makegraph</a> or <a href="#topic+cpp_simplify">cpp_simplify</a> function.</p>
</td></tr>
<tr><td><code id="get_detour_+3A_from">from</code></td>
<td>
<p>A vector of one or more vertices from which shortest path are calculated (origin).</p>
</td></tr>
<tr><td><code id="get_detour_+3A_to">to</code></td>
<td>
<p>A vector of one or more vertices (destination).</p>
</td></tr>
<tr><td><code id="get_detour_+3A_extra">extra</code></td>
<td>
<p>numeric. Additional cost</p>
</td></tr>
<tr><td><code id="get_detour_+3A_keep">keep</code></td>
<td>
<p>numeric or character. Vertices of interest that will be returned.</p>
</td></tr>
<tr><td><code id="get_detour_+3A_long">long</code></td>
<td>
<p>logical. If <code>TRUE</code>, a long <code>data.frame</code> is returned instead of a list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each returned nodes <em>n</em> meet the following condition :
</p>
<p><strong>SP(o,n) + SP(n,d) &lt; SP(o,d) + t</strong>
</p>
<p>with <em>SP</em> shortest distance/time, <em>o</em> the origin node, <em>d</em> the destination node and <em>t</em> the extra cost.
</p>
<p>Modified bidirectional Dijkstra algorithm is ran for each path.
</p>
<p>This algorithm is <strong>multithreaded.</strong> Please use <code>RcppParallel::setThreadOptions()</code> to set the number of threads.
</p>


<h3>Value</h3>

<p><code>list</code> or a <code>data.frame</code> of nodes that can be reached
</p>


<h3>Note</h3>

<p><code>from</code> and <code>to</code> must be the same length.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Choose number of cores used by cppRouting
RcppParallel::setThreadOptions(numThreads = 1)

if(requireNamespace("igraph",quietly = TRUE)){

#Generate fully connected graph
gf&lt;- igraph::make_full_graph(400)
igraph::V(gf)$names&lt;-1:400

#Convert to data frame and add random weights
df&lt;-igraph::as_long_data_frame(gf)
df$dist&lt;-sample(1:100,nrow(df),replace = TRUE)

#Construct cppRouting graph
graph&lt;-makegraph(df[,c(1,2,5)],directed = FALSE)

#Pick up random origin and destination node
origin&lt;-sample(1:400,1)
destination&lt;-sample(1:400,1)

#Compute distance from origin to all nodes
or_to_all&lt;-get_distance_matrix(graph,from=origin,to=1:400)

#Compute distance from all nodes to destination
all_to_dest&lt;-get_distance_matrix(graph,from=1:400,to=destination,)

#Get all shortest paths from origin to destination, passing by each node of the graph
total_paths&lt;-rowSums(cbind(t(or_to_all),all_to_dest))

#Compute shortest path between origin and destination
distance&lt;-get_distance_pair(graph,from=origin,to=destination)

#Compute detour with an additional cost of 3
det&lt;-get_detour(graph,from=origin,to=destination,extra=3)

#Check result validity
length(unlist(det))
length(total_paths[total_paths &lt; distance + 3])

}
</code></pre>

<hr>
<h2 id='get_distance_matrix'>Compute all shortest distance between origin and destination nodes.</h2><span id='topic+get_distance_matrix'></span>

<h3>Description</h3>

<p>Compute all shortest distance between origin and destination nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_distance_matrix(
  Graph,
  from,
  to,
  algorithm = "phast",
  aggregate_aux = FALSE,
  allcores = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_distance_matrix_+3A_graph">Graph</code></td>
<td>
<p>An object generated by <a href="#topic+makegraph">makegraph</a>, <a href="#topic+cpp_simplify">cpp_simplify</a> or <a href="#topic+cpp_contract">cpp_contract</a> function.</p>
</td></tr>
<tr><td><code id="get_distance_matrix_+3A_from">from</code></td>
<td>
<p>A vector of one or more vertices from which distances are calculated (origin).</p>
</td></tr>
<tr><td><code id="get_distance_matrix_+3A_to">to</code></td>
<td>
<p>A vector of one or more vertices (destination).</p>
</td></tr>
<tr><td><code id="get_distance_matrix_+3A_algorithm">algorithm</code></td>
<td>
<p>Character. Only for contracted graph, <code>mch</code> for Many to many CH, <code>phast</code> for PHAST algorithm</p>
</td></tr>
<tr><td><code id="get_distance_matrix_+3A_aggregate_aux">aggregate_aux</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the additional weight is summed along shortest paths.</p>
</td></tr>
<tr><td><code id="get_distance_matrix_+3A_allcores">allcores</code></td>
<td>
<p>Logical (deprecated). If <code>TRUE</code>, all cores are used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If graph is not contracted, <code>get_distance_matrix()</code> recursively perform Dijkstra algorithm for each <code>from</code> nodes.
If graph is contracted, the user has the choice between : </p>

<ul>
<li><p> many to many contraction hierarchies (<code>mch</code>) : optimal for square matrix.
</p>
</li>
<li><p> PHAST (<code>phast</code>) : outperform mch on rectangular matrix
</p>
</li></ul>

<p>Shortest path is always computed according to the main edge weights, corresponding to the 3rd column of <code>df</code> argument in <code>makegraph()</code> function.
If <code>aggregate_aux</code> argument is <code>TRUE</code>, the values returned are the sum of auxiliary weights along shortest paths.
</p>
<p>All algorithms are <strong>multithreaded.</strong> <code>allcores</code> argument is deprecated, please use <code>RcppParallel::setThreadOptions()</code> to set the number of threads.
</p>
<p>See details in package website : <a href="https://github.com/vlarmet/cppRouting/blob/master/README.md">https://github.com/vlarmet/cppRouting/blob/master/README.md</a>
</p>


<h3>Value</h3>

<p>Matrix of shortest distances.
</p>


<h3>Note</h3>

<p>It is not possible to aggregate auxiliary weights on a Graph object coming from <a href="#topic+cpp_simplify">cpp_simplify</a> function.
</p>


<h3>See Also</h3>

<p><a href="#topic+get_distance_pair">get_distance_pair</a>, <a href="#topic+get_multi_paths">get_multi_paths</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Choose number of cores used by cppRouting
RcppParallel::setThreadOptions(numThreads = 1)

#Data describing edges of the graph
edges &lt;- data.frame(from_vertex = c(0,0,1,1,2,2,3,4,4),
                    to_vertex = c(1,3,2,4,4,5,1,3,5),
                    time = c(9,2,11,3,5,12,4,1,6),
                    dist = c(5,3,4,7,5,5,5,8,7))

#Construct directed  graph with travel time as principal weight, and distance as secondary weight
graph &lt;- makegraph(edges[,1:3], directed=TRUE, aux = edges$dist)

#Get all nodes IDs
nodes &lt;- graph$dict$ref

# Get matrix of shortest times between all nodes : the result are in time unit
time_mat &lt;- get_distance_matrix(graph, from = nodes, to = nodes)

# Get matrix of distance according shortest times : the result are in distance unit
dist_mat &lt;- get_distance_matrix(graph, from = nodes, to = nodes, aggregate_aux = TRUE)

print(time_mat)
print(dist_mat)
</code></pre>

<hr>
<h2 id='get_distance_pair'>Compute shortest distance between origin and destination nodes.</h2><span id='topic+get_distance_pair'></span>

<h3>Description</h3>

<p>Compute shortest distance between origin and destination nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_distance_pair(
  Graph,
  from,
  to,
  aggregate_aux = FALSE,
  algorithm = "bi",
  constant = 1,
  allcores = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_distance_pair_+3A_graph">Graph</code></td>
<td>
<p>An object generated by <a href="#topic+makegraph">makegraph</a>, <a href="#topic+cpp_simplify">cpp_simplify</a> or <a href="#topic+cpp_contract">cpp_contract</a> function.</p>
</td></tr>
<tr><td><code id="get_distance_pair_+3A_from">from</code></td>
<td>
<p>A vector of one or more vertices from which distances are calculated (origin).</p>
</td></tr>
<tr><td><code id="get_distance_pair_+3A_to">to</code></td>
<td>
<p>A vector of one or more vertices (destination).</p>
</td></tr>
<tr><td><code id="get_distance_pair_+3A_aggregate_aux">aggregate_aux</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the additional weight is summed along shortest paths.</p>
</td></tr>
<tr><td><code id="get_distance_pair_+3A_algorithm">algorithm</code></td>
<td>
<p>character. <code>Dijkstra</code> for uni-directional Dijkstra, <code>bi</code> for bi-directional Dijkstra, <code>A*</code> for A star unidirectional search or <code>NBA</code> for New bi-directional A star .Default to <code>bi</code></p>
</td></tr>
<tr><td><code id="get_distance_pair_+3A_constant">constant</code></td>
<td>
<p>numeric. Constant to maintain the heuristic function admissible in <code>A*</code> and <code>NBA</code> algorithms.
Default to 1, when cost is expressed in the same unit than coordinates. See details</p>
</td></tr>
<tr><td><code id="get_distance_pair_+3A_allcores">allcores</code></td>
<td>
<p>Logical (deprecated). If <code>TRUE</code>, all cores are used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If graph is not contracted, the user has the choice between : </p>

<ul>
<li><p> unidirectional Dijkstra (<code>Dijkstra</code>)
</p>
</li>
<li><p> A star (<code>A*</code>) : projected coordinates should be provided
</p>
</li>
<li><p> bidirectional Dijkstra (<code>bi</code>)
</p>
</li>
<li><p> New bi-directional A star (<code>NBA</code>) : projected coordinates should be provided
</p>
</li></ul>

<p>If the input graph has been contracted by <a href="#topic+cpp_contract">cpp_contract</a> function, the algorithm is a modified bidirectional search.
</p>
<p>Shortest path is always computed according to the main edge weights, corresponding to the 3rd column of <code>df</code> argument in <a href="#topic+makegraph">makegraph</a> function.
If <code>aggregate_aux</code> argument is <code>TRUE</code>, the values returned are the sum of auxiliary weights along shortest paths.
</p>
<p>In A* and New Bidirectional A star algorithms, euclidean distance is used as heuristic function.
</p>
<p>All algorithms are <strong>multithreaded.</strong> <code>allcores</code> argument is deprecated, please use <code>RcppParallel::setThreadOptions()</code> to set the number of threads.
</p>
<p>To understand how A star algorithm work, see <a href="https://en.wikipedia.org/wiki/A*_search_algorithm">https://en.wikipedia.org/wiki/A*_search_algorithm</a>.
To understand the importance of constant parameter, see the package description : <a href="https://github.com/vlarmet/cppRouting/blob/master/README.md">https://github.com/vlarmet/cppRouting/blob/master/README.md</a>
</p>


<h3>Value</h3>

<p>Vector of shortest distances.
</p>


<h3>Note</h3>

<p><code>from</code> and <code>to</code> must be the same length.
It is not possible to aggregate auxiliary weights on a Graph object coming from <a href="#topic+cpp_simplify">cpp_simplify</a> function.
</p>


<h3>See Also</h3>

<p><a href="#topic+get_distance_matrix">get_distance_matrix</a>, <a href="#topic+get_path_pair">get_path_pair</a>, <a href="#topic+cpp_contract">cpp_contract</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Choose number of cores used by cppRouting
RcppParallel::setThreadOptions(numThreads = 1)

#Data describing edges of the graph
edges&lt;-data.frame(from_vertex=c(0,0,1,1,2,2,3,4,4),
                  to_vertex=c(1,3,2,4,4,5,1,3,5),
                  cost=c(9,2,11,3,5,12,4,1,6),
                  dist = c(5,3,4,7,5,5,5,8,7))

#Construct directed  graph with travel time as principal weight, and distance as secondary weight
graph &lt;- makegraph(edges[,1:3], directed=TRUE, aux = edges$dist)

#Get all nodes IDs
nodes &lt;- graph$dict$ref

# Get shortest times between all nodes : the result are in time unit
time_mat &lt;- get_distance_pair(graph, from = nodes, to = nodes)

# Get distance according shortest times : the result are in distance unit
dist_mat &lt;- get_distance_pair(graph, from = nodes, to = nodes, aggregate_aux = TRUE)

print(time_mat)
print(dist_mat)
</code></pre>

<hr>
<h2 id='get_isochrone'>Compute isochrones/isodistances from nodes.</h2><span id='topic+get_isochrone'></span>

<h3>Description</h3>

<p>Compute isochrones/isodistances from nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_isochrone(Graph, from, lim, setdif = FALSE, keep = NULL, long = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_isochrone_+3A_graph">Graph</code></td>
<td>
<p>An object generated by <a href="#topic+makegraph">makegraph</a> or <a href="#topic+cpp_simplify">cpp_simplify</a> function.</p>
</td></tr>
<tr><td><code id="get_isochrone_+3A_from">from</code></td>
<td>
<p>numeric or character. A vector of one or more vertices from which isochrones/isodistances are calculated.</p>
</td></tr>
<tr><td><code id="get_isochrone_+3A_lim">lim</code></td>
<td>
<p>numeric. A vector of one or multiple breaks.</p>
</td></tr>
<tr><td><code id="get_isochrone_+3A_setdif">setdif</code></td>
<td>
<p>logical. If <code>TRUE</code> and <code>length(lim) &gt; 1</code>, nodes that are reachable in a given break will not appear in a greater one.</p>
</td></tr>
<tr><td><code id="get_isochrone_+3A_keep">keep</code></td>
<td>
<p>numeric or character. Vertices of interest that will be returned.</p>
</td></tr>
<tr><td><code id="get_isochrone_+3A_long">long</code></td>
<td>
<p>logical. If <code>TRUE</code>, a long <code>data.frame</code> is returned instead of a <code>list</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>length(lim) &gt; 1</code>, value is a <code>list</code> of <code>length(from)</code>, containing <code>list</code>s of <code>length(lim)</code>.
</p>
<p>All algorithms are <strong>multithreaded.</strong> Please use <code>RcppParallel::setThreadOptions()</code> to set the number of threads.
</p>
<p>For large graph, <code>keep</code> argument can be used for saving memory.
</p>


<h3>Value</h3>

<p><code>list</code> or a <code>data.frame</code> containing reachable nodes below cost limit(s).
</p>


<h3>Note</h3>

<p><code>get_isochrone()</code> recursively perform Dijkstra algorithm for each <code>from</code> nodes and stop when cost limit is reached.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Choose number of cores used by cppRouting
RcppParallel::setThreadOptions(numThreads = 1)

#Data describing edges of the graph
edges&lt;-data.frame(from_vertex=c(0,0,1,1,2,2,3,4,4),
                  to_vertex=c(1,3,2,4,4,5,1,3,5),
                  cost=c(9,2,11,3,5,12,4,1,6))

#Construct directed graph
directed_graph&lt;-makegraph(edges,directed=TRUE)

#Get nodes reachable around node 4 with maximum distances of 1 and 2
iso&lt;-get_isochrone(Graph=directed_graph,from = "4",lim=c(1,2))

#With setdif set to TRUE
iso2&lt;-get_isochrone(Graph=directed_graph,from = "4",lim=c(1,2),setdif=TRUE)
print(iso)
print(iso2)
</code></pre>

<hr>
<h2 id='get_multi_paths'>Compute all shortest paths between origin and destination nodes.</h2><span id='topic+get_multi_paths'></span>

<h3>Description</h3>

<p>Compute all shortest paths between origin and destination nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_multi_paths(Graph, from, to, keep = NULL, long = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_multi_paths_+3A_graph">Graph</code></td>
<td>
<p>An object generated by <a href="#topic+makegraph">makegraph</a> or <a href="#topic+cpp_simplify">cpp_simplify</a> function.</p>
</td></tr>
<tr><td><code id="get_multi_paths_+3A_from">from</code></td>
<td>
<p>A vector of one or more vertices from which shortest paths are calculated (origin).</p>
</td></tr>
<tr><td><code id="get_multi_paths_+3A_to">to</code></td>
<td>
<p>A vector of one or more vertices (destination).</p>
</td></tr>
<tr><td><code id="get_multi_paths_+3A_keep">keep</code></td>
<td>
<p>numeric or character. Vertices of interest that will be returned.</p>
</td></tr>
<tr><td><code id="get_multi_paths_+3A_long">long</code></td>
<td>
<p>logical. If <code>TRUE</code>, a long data.frame is returned instead of a list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>get_multi_paths()</code> recursively perform Dijkstra algorithm for each 'from' nodes. It is the equivalent of <a href="#topic+get_distance_matrix">get_distance_matrix</a>, but it return the shortest path node sequence instead of the distance.
</p>
<p>This algorithm is <strong>multithreaded.</strong> Please use <code>RcppParallel::setThreadOptions()</code> to set the number of threads.
</p>


<h3>Value</h3>

<p>List or a data.frame containing shortest paths.
</p>


<h3>Note</h3>

<p>Be aware that if 'from' and 'to' have consequent size, output will require much memory space.
</p>


<h3>See Also</h3>

<p><a href="#topic+get_path_pair">get_path_pair</a>, <a href="#topic+get_isochrone">get_isochrone</a>, <a href="#topic+get_detour">get_detour</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Choose number of cores used by cppRouting
RcppParallel::setThreadOptions(numThreads = 1)

#Data describing edges of the graph
edges&lt;-data.frame(from_vertex=c(0,0,1,1,2,2,3,4,4),
                  to_vertex=c(1,3,2,4,4,5,1,3,5),
                  cost=c(9,2,11,3,5,12,4,1,6))

#Get all nodes
nodes&lt;-unique(c(edges$from_vertex,edges$to_vertex))

#Construct directed graph
directed_graph&lt;-makegraph(edges,directed=TRUE)

#Get all shortest paths (node sequences) between all nodes
dir_paths&lt;-get_multi_paths(Graph=directed_graph, from=nodes, to=nodes)
print(dir_paths)

#Get the same result in data.frame format
dir_paths_df&lt;-get_multi_paths(Graph=directed_graph, from=nodes, to=nodes, long = TRUE)
print(dir_paths_df)
</code></pre>

<hr>
<h2 id='get_path_pair'>Compute shortest path between origin and destination nodes.</h2><span id='topic+get_path_pair'></span>

<h3>Description</h3>

<p>Compute shortest path between origin and destination nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_path_pair(
  Graph,
  from,
  to,
  algorithm = "bi",
  constant = 1,
  keep = NULL,
  long = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_path_pair_+3A_graph">Graph</code></td>
<td>
<p>An object generated by <a href="#topic+makegraph">makegraph</a>, <a href="#topic+cpp_simplify">cpp_simplify</a> or <a href="#topic+cpp_contract">cpp_contract</a> function.</p>
</td></tr>
<tr><td><code id="get_path_pair_+3A_from">from</code></td>
<td>
<p>A vector of one or more vertices from which shortest paths are calculated (origin).</p>
</td></tr>
<tr><td><code id="get_path_pair_+3A_to">to</code></td>
<td>
<p>A vector of one or more vertices (destination).</p>
</td></tr>
<tr><td><code id="get_path_pair_+3A_algorithm">algorithm</code></td>
<td>
<p>character. <code>Dijkstra</code> for uni-directional Dijkstra, <code>bi</code> for bi-directional Dijkstra, <code>A*</code> for A star unidirectional search or <code>NBA</code> for New bi-directional A star .Default to <code>bi</code></p>
</td></tr>
<tr><td><code id="get_path_pair_+3A_constant">constant</code></td>
<td>
<p>numeric. Constant to maintain the heuristic function admissible in A* and NBA algorithms.</p>
</td></tr>
<tr><td><code id="get_path_pair_+3A_keep">keep</code></td>
<td>
<p>numeric or character. Vertices of interest that will be returned.</p>
</td></tr>
<tr><td><code id="get_path_pair_+3A_long">long</code></td>
<td>
<p>logical. If <code>TRUE</code>, a long <code>data.frame</code> is returned instead of a <code>list</code>.
Default to 1, when cost is expressed in the same unit than coordinates. See details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If graph is not contracted, the user has the choice between : </p>

<ul>
<li><p> unidirectional Dijkstra (<code>Dijkstra</code>)
</p>
</li>
<li><p> A star (<code>A*</code>) : projected coordinates should be provided
</p>
</li>
<li><p> bidirectional Dijkstra (<code>bi</code>)
</p>
</li>
<li><p> New bi-directional A star (<code>NBA</code>) : projected coordinates should be provided
</p>
</li></ul>

<p>If the input graph has been contracted by <a href="#topic+cpp_contract">cpp_contract</a> function, the algorithm is a modified bidirectional search.
</p>
<p>In <code>A*</code> and <code>NBA</code> algorithms, euclidean distance is used as heuristic function.
</p>
<p>All algorithms are <strong>multithreaded.</strong> Please use <code>RcppParallel::setThreadOptions()</code> to set the number of threads.
</p>
<p>To understand the importance of constant parameter, see the package description : <a href="https://github.com/vlarmet/cppRouting/blob/master/README.md">https://github.com/vlarmet/cppRouting/blob/master/README.md</a>
</p>


<h3>Value</h3>

<p><code>list</code> or a <code>data.frame</code> containing shortest path nodes between from and to.
</p>


<h3>Note</h3>

<p><code>from</code> and <code>from</code> must be the same length.
</p>


<h3>See Also</h3>

<p><a href="#topic+get_multi_paths">get_multi_paths</a>, <a href="#topic+get_isochrone">get_isochrone</a>, <a href="#topic+get_detour">get_detour</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Choose number of cores used by cppRouting
RcppParallel::setThreadOptions(numThreads = 1)

#Data describing edges of the graph
edges&lt;-data.frame(from_vertex=c(0,0,1,1,2,2,3,4,4),
                  to_vertex=c(1,3,2,4,4,5,1,3,5),
                  cost=c(9,2,11,3,5,12,4,1,6))

#Get all nodes
nodes&lt;-unique(c(edges$from_vertex,edges$to_vertex))

#Construct directed and undirected graph
directed_graph&lt;-makegraph(edges,directed=TRUE)
non_directed&lt;-makegraph(edges,directed=FALSE)

#Sampling origin and destination nodes
origin&lt;-sample(nodes,10,replace=TRUE)
destination&lt;-sample(nodes,10,replace=TRUE)

#Get distance between origin and destination in the two graphs
dir_paths&lt;-get_path_pair(Graph=directed_graph, from=origin, to=destination)
non_dir_paths&lt;-get_path_pair(Graph=non_directed, from=origin, to=destination)
print(dir_paths)
print(non_dir_paths)
</code></pre>

<hr>
<h2 id='makegraph'>Construct graph</h2><span id='topic+makegraph'></span>

<h3>Description</h3>

<p>Construct graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makegraph(
  df,
  directed = TRUE,
  coords = NULL,
  aux = NULL,
  capacity = NULL,
  alpha = NULL,
  beta = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makegraph_+3A_df">df</code></td>
<td>
<p>A data.frame or matrix containing 3 columns: from, to, cost. See details.</p>
</td></tr>
<tr><td><code id="makegraph_+3A_directed">directed</code></td>
<td>
<p>logical. If <code>FALSE</code>, then all edges are duplicated by inverting 'from' and 'to' nodes.</p>
</td></tr>
<tr><td><code id="makegraph_+3A_coords">coords</code></td>
<td>
<p>Optional. A data.frame or matrix containing all nodes coordinates. Columns order should be 'node_ID', 'X', 'Y'.</p>
</td></tr>
<tr><td><code id="makegraph_+3A_aux">aux</code></td>
<td>
<p>Optional. A vector or a single value describing an additional edge weight.</p>
</td></tr>
<tr><td><code id="makegraph_+3A_capacity">capacity</code></td>
<td>
<p>Optional. A vector or a single value describing edge capacity. Used for traffic assignment.</p>
</td></tr>
<tr><td><code id="makegraph_+3A_alpha">alpha</code></td>
<td>
<p>Optional. A vector or a single value describing alpha parameter. Used for traffic assignment.</p>
</td></tr>
<tr><td><code id="makegraph_+3A_beta">beta</code></td>
<td>
<p>Optional. A vector or a single value describing beta parameter. Used for traffic assignment.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'from' and 'to' are character or numeric vector containing nodes IDs.
'cost' is a non-negative numeric vector describing the cost (e.g time, distance) between each 'from' and 'to' nodes.
<code>coords</code> should not be angles (e.g latitude and longitude), but expressed in a projection system.
<code>aux</code> is an additional weight describing each edge. Shortest paths are always computed using 'cost' but <code>aux</code> can be summed over shortest paths.
<code>capacity</code>, <code>alpha</code> and <code>beta</code> are parameters used in the Volume Delay Function (VDF) to equilibrate traffic in the network. See <a href="#topic+assign_traffic">assign_traffic</a>.
<code>capacity</code>, <code>alpha</code>, <code>beta</code> and <code>aux</code> must have a length equal to <code>nrow(df)</code>. If a single value is provided, this value is replicated for each edge.
<code>alpha</code> must be different from 0 and <code>alpha</code> must be greater or equal to 1.
For more details and examples about traffic assignment, please see the package website : <a href="https://github.com/vlarmet/cppRouting/blob/master/README.md">https://github.com/vlarmet/cppRouting/blob/master/README.md</a>
</p>


<h3>Value</h3>

<p>Named list with two useful attributes for the user : <br />
</p>
<p><em>nbnode</em> : total number of vertices <br />
<em>dict$ref</em> : vertices IDs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Data describing edges of the graph
edges&lt;-data.frame(from_vertex=c(0,0,1,1,2,2,3,4,4),
                  to_vertex=c(1,3,2,4,4,5,1,3,5),
                  cost=c(9,2,11,3,5,12,4,1,6))

#Construct directed and undirected graph
directed_graph&lt;-makegraph(edges,directed=TRUE)
non_directed&lt;-makegraph(edges,directed=FALSE)

#Visualizing directed and undirected graphs
if(requireNamespace("igraph",quietly = TRUE)){
  plot(igraph::graph_from_data_frame(edges))
  plot(igraph::graph_from_data_frame(edges,directed=FALSE))
}

#Coordinates of each nodes
coord&lt;-data.frame(node=c(0,1,2,3,4,5),X=c(2,2,2,0,0,0),Y=c(0,2,2,0,2,4))

#Construct graph with coordinates
directed_graph2&lt;-makegraph(edges, directed=TRUE, coords=coord)

</code></pre>

<hr>
<h2 id='to_df'>Convert cppRouting graph to data.frame</h2><span id='topic+to_df'></span>

<h3>Description</h3>

<p>Convert cppRouting graph to data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_df(Graph)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="to_df_+3A_graph">Graph</code></td>
<td>
<p>An object generated by cppRouting::makegraph() or cpp_simplify() function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data.frame with from, to and dist column
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Simple directed graph

edges&lt;-data.frame(from=c(1,2,3,4,5,6,7,8),
to=c(0,1,2,3,6,7,8,5),
dist=c(1,1,1,1,1,1,1,1))

#Construct cppRouting graph
graph&lt;-makegraph(edges,directed=TRUE)

#Convert cppRouting graph to data.frame

df&lt;-to_df(graph)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
