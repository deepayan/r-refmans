<!DOCTYPE html><html><head><title>Help for package nse</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nse}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#nse'><p>nse: Computation of numerical standard errors in R</p></a></li>
<li><a href='#nse.andrews'><p>Andrews estimator</p></a></li>
<li><a href='#nse.boot'><p>Bootstrap estimator</p></a></li>
<li><a href='#nse.cos'><p>Long-run variance estimation using low-frequency cosine series.</p></a></li>
<li><a href='#nse.geyer'><p>Geyer estimator</p></a></li>
<li><a href='#nse.hiruk'><p>Hirukawa estimator</p></a></li>
<li><a href='#nse.nw'><p>Newey-West estimator</p></a></li>
<li><a href='#nse.spec0'><p>Spectral density at zero estimator</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.21</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-11-08</td>
</tr>
<tr>
<td>Title:</td>
<td>Numerical Standard Errors Computation in R</td>
</tr>
<tr>
<td>Author:</td>
<td>David Ardia <a href="https://orcid.org/0000-0003-2823-782X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Keven Bluteau <a href="https://orcid.org/0000-0003-2990-4807"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Keven Bluteau &lt;keven.bluteau@usherbrooke.ca&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Collection of functions designed to calculate numerical standard error (NSE) of univariate time series as described in Ardia et al. (2018) &lt;<a href="https://doi.org/10.1515%2Fjtse-2017-0011">doi:10.1515/jtse-2017-0011</a>&gt; and Ardia and Bluteau (2017) &lt;<a href="https://doi.org/10.21105%2Fjoss.00172">doi:10.21105/joss.00172</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/keblu/nse/issues">https://github.com/keblu/nse/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/keblu/nse">https://github.com/keblu/nse</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.0), coda, mcmc, mcmcse, np, sandwich</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-09 17:52:09 UTC; bluk2201</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-10 13:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='nse'>nse: Computation of numerical standard errors in R</h2><span id='topic+nse'></span><span id='topic+nse-package'></span>

<h3>Description</h3>

<p><code>nse</code> (Ardia and Bluteau, 2017) is an <span class="rlang"><b>R</b></span> package for computing the numerical standard error (NSE), an estimate
of the standard deviation of a simulation result, if the simulation experiment were to be repeated
many times. The package provides a set of wrappers around several R packages, which give access to
more than thirty NSE estimators, including batch means
estimators (Geyer, 1992, Section 3.2), initial sequence estimators Geyer (1992, Equation 3.3),
spectrum at zero estimators (Heidelberger and Welch, 1981), heteroskedasticity
and autocorrelation consistent (HAC) kernel estimators (Newey and West, 1987; Andrews, 1991; Andrews and
Monahan, 1992; Newey and West, 1994; Hirukawa, 2010), and bootstrap estimators Politis and
Romano (1992, 1994); Politis and White (2004). The full set of estimators is described in
Ardia et al. (2018).
</p>


<h3>Functions</h3>


<ul>
<li> <p><code><a href="#topic+nse.geyer">nse.geyer</a></code>: Geyer NSE estimator.
</p>
</li>
<li> <p><code><a href="#topic+nse.spec0">nse.spec0</a></code>: Spectral density at zero NSE estimator.
</p>
</li>
<li> <p><code><a href="#topic+nse.nw">nse.nw</a></code>: Newey-West NSE estimator.
</p>
</li>
<li> <p><code><a href="#topic+nse.andrews">nse.andrews</a></code>: Andrews NSE estimator.
</p>
</li>
<li> <p><code><a href="#topic+nse.hiruk">nse.hiruk</a></code>: Hirukawa NSE estimator.
</p>
</li>
<li> <p><code><a href="#topic+nse.boot">nse.boot</a></code>: Bootstrap NSE estimator.
</p>
</li></ul>



<h3>Note</h3>

<p>Functions rely on the packages <code>coda</code>, <code>mcmc</code>,<code>mcmcse</code>, <code>np</code>, and <code>sandwich</code>.
</p>
<p>Please cite the package in publications. Use <code>citation("nse")</code>.
</p>


<h3>Author(s)</h3>

<p>David Ardia and Keven Bluteau
</p>


<h3>References</h3>

<p>Andrews, D.W.K. (1991).
Heteroskedasticity and autocorrelation consistent covariance matrix estimation.
<em>Econometrica</em> <b>59</b>(3),  817-858.
</p>
<p>Andrews, D.W.K, Monahan, J.C. (1992).
An improved heteroskedasticity and autocorrelation consistent covariance matrix estimator.
<em>Econometrica</em> <b>60</b>(4),  953-966.
</p>
<p>Ardia, D., Bluteau, K., Hoogerheide, L. (2018).
Methods for computing numerical standard errors: Review and application to Value-at-Risk estimation.
<em>Journal of Time Series Econometrics</em> <b>10</b>(2), 1-9.
<a href="https://doi.org/10.1515/jtse-2017-0011">doi:10.1515/jtse-2017-0011</a>
<a href="https://doi.org/10.2139/ssrn.2741587">doi:10.2139/ssrn.2741587</a>
</p>
<p>Ardia, D., Bluteau, K. (2017).
nse: Computation of numerical standard errors in R.
<em>Journal of Open Source Software</em> <b>10</b>(2).
<a href="https://doi.org/10.21105/joss.00172">doi:10.21105/joss.00172</a>
</p>
<p>Geyer, C.J. (1992).
Practical Markov chain Monte Carlo.
<em>Statistical Science</em> <b>7</b>(4),  473-483.
</p>
<p>Heidelberger, P., Welch, Peter D. (1981).
A spectral method for confidence interval generation and run length control in simulations.
<em>Communications of the ACM</em> <b>24</b>(4),  233-245.
</p>
<p>Hirukawa, M. (2010).
A two-stage plug-in bandwidth selection and its implementation for covariance estimation.
<em>Econometric Theory</em> <b>26</b>(3),  710-743.
</p>
<p>Newey, W.K., West, K.D. (1987).
A simple, positive semi-definite, heteroskedasticity and autocorrelationconsistent covariance matrix.
<em>Econometrica</em> <b>55</b>(3),  703-708.
</p>
<p>Newey, W.K., West, K.D. (1994) .
Automatic lag selection in covariance matrix estimation.
<em>Review of Economic Studies</em> <b>61</b>(4), 631-653.
</p>
<p>Politis, D.N., Romano, and J.P. (1992).
A circular block-resampling procedure for stationary data.
In <em>Exploring the limits of bootstrap</em>, John Wiley &amp; Sons, 263-270.
</p>
<p>Politis, D.N., Romano, and J.P. (1994).
The stationary bootstrap.
<em>Journal of the American Statistical Association</em> <b>89</b>(428), 1303-1313.
</p>
<p>Politis, D.N., White, H. (2004).
Automatic block-length selection for the dependent bootstrap.
<em>Econometric Reviews</em> <b>23</b>(1), 53-70.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/keblu/nse">https://github.com/keblu/nse</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/keblu/nse/issues">https://github.com/keblu/nse/issues</a>
</p>
</li></ul>


<hr>
<h2 id='nse.andrews'>Andrews estimator</h2><span id='topic+nse.andrews'></span>

<h3>Description</h3>

<p>Function which calculates the numerical standard error with the kernel
based variance estimator by Andrews (1991).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nse.andrews(
  x,
  type = c("bartlett", "parzen", "tukey", "qs", "trunc"),
  lag.prewhite = 0,
  approx = c("AR(1)", "ARMA(1,1)")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nse.andrews_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="nse.andrews_+3A_type">type</code></td>
<td>
<p>The type of kernel used among which <code>"bartlett"</code>, <code>"parzen"</code>, <code>"qs"</code>, <code>"trunc"</code> and <code>"tukey"</code>. Default is <code>type = "bartlett"</code>.</p>
</td></tr>
<tr><td><code id="nse.andrews_+3A_lag.prewhite">lag.prewhite</code></td>
<td>
<p>Prewhite the series before analysis (integer or <code>NULL</code>). When <code>lag.prewhite = NULL</code> this performs automatic lag selection. Default is <code>lag.prewhite = 0</code> that is no prewhitening.</p>
</td></tr>
<tr><td><code id="nse.andrews_+3A_approx">approx</code></td>
<td>
<p>Andrews approximation, either <code>"AR(1)"</code> or <code>"ARMA(1,1)"</code>. Default is <code>approx = "AR(1)"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This kernel based variance estimation apply weight to the auto-covariance function with a kernel and sums up the value.
</p>


<h3>Value</h3>

<p>The NSE estimator.
</p>


<h3>Note</h3>

<p><code>nse.andrews</code> is a wrapper around <code><a href="sandwich.html#topic+lrvar">lrvar</a></code> from the <code><a href="sandwich.html#topic+sandwich">sandwich</a></code> package and uses Andrews (1991) automatic bandwidth estimator. See the documentation of <code><a href="sandwich.html#topic+sandwich">sandwich</a></code> for details.
</p>


<h3>Author(s)</h3>

<p>David Ardia and Keven Bluteau
</p>


<h3>References</h3>

<p>Andrews, D.W.K. (1991).
Heteroskedasticity and autocorrelation consistent covariance matrix estimation.
<em>Econometrica</em> <b>59</b>(3),  817-858.
</p>
<p>Andrews, D.W.K, Monahan, J.C. (1992).
An improved heteroskedasticity and autocorrelation consistent covariance matrix estimator.
<em>Econometrica</em> <b>60</b>(4),  953-966.
</p>
<p>Newey, W.K., West, K.D. (1987).
A simple, positive semi-definite, heteroskedasticity and autocorrelationconsistent covariance matrix.
<em>Econometrica</em> <b>55</b>(3),  703-708.
</p>
<p>Newey, W.K., West, K.D. (1994) .
Automatic lag selection in covariance matrix estimation.
<em>Review of Economic Studies</em> <b>61</b>(4),  631-653.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
n    = 1000
ar   = 0.9
mean = 1
sd   = 1

set.seed(1234)
x = c(arima.sim(n = n, list(ar = ar), sd = sd) + mean)

nse.andrews(x = x, type = "parzen", lag.prewhite = 0)
nse.andrews(x = x, type = "tukey", lag.prewhite = 1)
nse.andrews(x = x, type = "qs", lag.prewhite = NULL)

## End(Not run)
</code></pre>

<hr>
<h2 id='nse.boot'>Bootstrap estimator</h2><span id='topic+nse.boot'></span>

<h3>Description</h3>

<p>Function which calculates the numerical standard error with bootstrap estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nse.boot(x, nb, type = c("stationary", "circular"), b = NULL, lag.prewhite = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nse.boot_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="nse.boot_+3A_nb">nb</code></td>
<td>
<p>The number of bootstrap replications.</p>
</td></tr>
<tr><td><code id="nse.boot_+3A_type">type</code></td>
<td>
<p>The bootstrap scheme used, among <code>"stationary"</code> and <code>"circular"</code>. Default is <code>type = "stationary"</code>.</p>
</td></tr>
<tr><td><code id="nse.boot_+3A_b">b</code></td>
<td>
<p>The block length for the block bootstrap. If <code>NULL</code> automatic block length selection. Default is <code>b = NULL</code>.</p>
</td></tr>
<tr><td><code id="nse.boot_+3A_lag.prewhite">lag.prewhite</code></td>
<td>
<p>Prewhite the series before analysis (integer or <code>NULL</code>). When <code>lag.prewhite = NULL</code> this performs automatic lag selection. Default is <code>lag.prewhite = 0</code> that is no prewhitening.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The NSE estimator.
</p>


<h3>Note</h3>

<p><code>nse.boot</code> uses <code><a href="np.html#topic+b.star">b.star</a></code> of the <code><a href="np.html#topic+np">np</a></code> package
for the optimal block length selection.
</p>


<h3>Author(s)</h3>

<p>David Ardia and Keven Bluteau
</p>


<h3>References</h3>

<p>Politis, D.N., Romano, and J.P. (1992).
A circular block-resampling procedure for stationary data.
In <em>Exploring the limits of bootstrap</em>, John Wiley &amp; Sons,  263-270.
</p>
<p>Politis, D.N., Romano, and J.P. (1994).
The stationary bootstrap.
<em>Journal of the American Statistical Association</em> <b>89</b>(428),  1303-1313.
</p>
<p>Politis, D.N., White, H. (2004).
Automatic block-length selection for the dependent bootstrap.
<em>Econometric Reviews</em> <b>23</b>(1),  53-70.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
n    = 1000
ar   = 0.9
mean = 1
sd   = 1

set.seed(1234)
x = c(arima.sim(n = n, list(ar = ar), sd = sd) + mean)

set.seed(1234)
nse.boot(x = x, nb = 1000, type = "stationary", b = NULL, lag.prewhite = 0)
nse.boot(x = x, nb = 1000, type = "circular", b = NULL, lag.prewhite = NULL)
nse.boot(x = x, nb = 1000, type = "circular", b = 10, lag.prewhite = NULL)

## End(Not run)
</code></pre>

<hr>
<h2 id='nse.cos'>Long-run variance estimation using low-frequency cosine series.</h2><span id='topic+nse.cos'></span>

<h3>Description</h3>

<p>Function which calculates the numerical standard error with low-frequency cosine weighted averages of the original serie.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nse.cos(x, q = 12, lag.prewhite = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nse.cos_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="nse.cos_+3A_q">q</code></td>
<td>
<p>Number of consine series.</p>
</td></tr>
<tr><td><code id="nse.cos_+3A_lag.prewhite">lag.prewhite</code></td>
<td>
<p>Prewhite the series before analysis (integer or <code>NULL</code>). When <code>lag.prewhite = NULL</code> this performs automatic lag selection. Default is <code>lag.prewhite = 0</code> that is no prewhitening.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method estimate the series with a linear regression using cosine low frequency series. It than derived the NSE from the coefficient of the cosine series (Ulrich and Watson, 2017).
</p>


<h3>Value</h3>

<p>The NSE estimator.
</p>


<h3>Author(s)</h3>

<p>David Ardia and Keven Bluteau
</p>


<h3>References</h3>

<p>Muller, Ulrich K., and Mark W. Watson. (2015)
Low-frequency econometrics.
<em>National Bureau of Economic Research</em>, No. w21564.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
n    = 1000
ar   = 0.9
mean = 1
sd   = 1
set.seed(1234)
x = c(arima.sim(n = n, list(ar = ar), sd = sd) + mean)

nse.cos(x = x, q = 12, lag.prewhite = 0)
nse.cos(x = x, q = 12, lag.prewhite = NULL)

## End(Not run)
</code></pre>

<hr>
<h2 id='nse.geyer'>Geyer estimator</h2><span id='topic+nse.geyer'></span>

<h3>Description</h3>

<p>Function which calculates the numerical standard error with the method of Geyer (1992).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nse.geyer(
  x,
  type = c("iseq", "bm", "obm", "iseq.bm"),
  nbatch = 30,
  iseq.type = c("pos", "dec", "con")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nse.geyer_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="nse.geyer_+3A_type">type</code></td>
<td>
<p>The type which can be either <code>"iseq"</code>, <code>"bm"</code>, <code>"obm"</code> or <code>"iseq.bm"</code>.
See *Details*. Default is <code>type = "iseq"</code>.</p>
</td></tr>
<tr><td><code id="nse.geyer_+3A_nbatch">nbatch</code></td>
<td>
<p>Number of batches when <code>type = "bm"</code> and <code>type = "iseq.bm"</code>. Default is <code>nbatch = 30</code>.</p>
</td></tr>
<tr><td><code id="nse.geyer_+3A_iseq.type">iseq.type</code></td>
<td>
<p>Constraints on function: <code>"pos"</code> for nonnegative, <code>"dec"</code> for nonnegative
and nonincreasing, and <code>"con"</code> for nonnegative, nonincreasing, and convex. Default is <code>iseq.type = "pos"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The type <code>"iseq"</code> gives the positive intial sequence estimator, <code>"bm"</code> is the batch mean estimator,
<code>"obm"</code> is the overlapping batch mean estimator and <code>"iseq.bm"</code> is a combination of <code>"iseq"</code> and <code>"bm"</code>.
</p>


<h3>Value</h3>

<p>The NSE estimator.
</p>


<h3>Note</h3>

<p><code>nse.geyer</code> relies on the packages <code><a href="coda.html#topic+mcmc">mcmc</a></code> and <code><a href="mcmcse.html#topic+mcmcse">mcmcse</a></code>; see
the documentation of these packages for more details.
</p>


<h3>Author(s)</h3>

<p>David Ardia and Keven Bluteau
</p>


<h3>References</h3>

<p>Geyer, C.J. (1992).
Practical Markov chain Monte Carlo.
<em>Statistical Science</em> <b>7</b>(4),  .473-483.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
n    = 1000
ar   = 0.9
mean = 1
sd   = 1
set.seed(1234)
x = c(arima.sim(n = n, list(ar = ar), sd = sd) + mean)
nse.geyer(x = x, type = "bm", nbatch = 30)
nse.geyer(x = x, type = "obm", nbatch = 30)
nse.geyer(x = x, type = "iseq", iseq.type = "pos")
nse.geyer(x = x, type = "iseq.bm", iseq.type = "con")

## End(Not run)
</code></pre>

<hr>
<h2 id='nse.hiruk'>Hirukawa estimator</h2><span id='topic+nse.hiruk'></span>

<h3>Description</h3>

<p>Function which calculates the numerical standard error with the kernel based variance estimator
by Andrews (1991) using Hirukawa (2010) automatic bandwidth estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nse.hiruk(x, type = c("bartlett", "parzen"), lag.prewhite = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nse.hiruk_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="nse.hiruk_+3A_type">type</code></td>
<td>
<p>The type of kernel used among <code>"bartlett"</code> and <code>"parzen"</code>. Default is <code>type = "Bartlett"</code>.</p>
</td></tr>
<tr><td><code id="nse.hiruk_+3A_lag.prewhite">lag.prewhite</code></td>
<td>
<p>Prewhite the series before analysis (integer or <code>NULL</code>). When <code>lag.prewhite = NULL</code> this performs automatic lag selection. Default is <code>lag.prewhite = 0</code> that is no prewhitening.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The NSE estimator.
</p>


<h3>Note</h3>

<p><code>nse.hiruk</code> is a wrapper around <code><a href="sandwich.html#topic+lrvar">lrvar</a></code> from
the <code><a href="sandwich.html#topic+sandwich">sandwich</a></code> package and uses Hirukawa (2010) bandwidth estimator.
See the documentation of <code><a href="sandwich.html#topic+sandwich">sandwich</a></code> for details.
</p>


<h3>Author(s)</h3>

<p>David Ardia and Keven Bluteau
</p>


<h3>References</h3>

<p>Hirukawa, M. (2010).
A two-stage plug-in bandwidth selection and its implementation for covariance estimation.
<em>Econometric Theory</em> <b>26</b>(3),  710-743.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
n    = 1000
ar   = 0.9
mean = 1
sd   = 1

set.seed(1234)
x = c(arima.sim(n = n, list(ar = ar), sd = sd) + mean)
nse.hiruk(x = x, type = "parzen", lag.prewhite = 0)
nse.hiruk(x = x, type = "bartlett", lag.prewhite = NULL)

## End(Not run)
</code></pre>

<hr>
<h2 id='nse.nw'>Newey-West estimator</h2><span id='topic+nse.nw'></span>

<h3>Description</h3>

<p>Function which calculates the numerical standard error with the Newey West (1987, 1994) HAC estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nse.nw(x, lag.prewhite = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nse.nw_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="nse.nw_+3A_lag.prewhite">lag.prewhite</code></td>
<td>
<p>Prewhite the series before analysis (integer or <code>NULL</code>). When <code>lag.prewhite = NULL</code> this performs automatic lag selection. Default is <code>lag.prewhite = 0</code> that is no prewhitening.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The NSE estimator.
</p>


<h3>Note</h3>

<p><code>nse.nw</code> is a wrapper around <code><a href="sandwich.html#topic+lrvar">lrvar</a></code> from
the <code><a href="sandwich.html#topic+sandwich">sandwich</a></code> package. See the documentation of <code><a href="sandwich.html#topic+sandwich">sandwich</a></code> for details.
</p>


<h3>Author(s)</h3>

<p>David Ardia and Keven Bluteau
</p>


<h3>References</h3>

<p>Newey, W.K., West, K.D. (1987).
A simple, positive semi-definite, heteroskedasticity and autocorrelationconsistent covariance matrix.
<em>Econometrica</em> <b>55</b>(3),  .703-708.
</p>
<p>Newey, W.K., West, K.D. (1994) .
Automatic lag selection in covariance matrix estimation.
<em>Review of Economic Studies</em> <b>61</b>(4), .631-653.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
n    = 1000
ar   = 0.9
mean = 1
sd   = 1

set.seed(1234)
x = c(arima.sim(n = n, list(ar = ar), sd = sd) + mean)

nse.nw(x = x, lag.prewhite = 0)
nse.nw(x = x, lag.prewhite = 1)
nse.nw(x = x, lag.prewhite = NULL)

## End(Not run)
</code></pre>

<hr>
<h2 id='nse.spec0'>Spectral density at zero estimator</h2><span id='topic+nse.spec0'></span>

<h3>Description</h3>

<p>Function which calculates the numerical standard error with the spectrum at zero estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nse.spec0(
  x,
  type = c("ar", "glm", "daniell", "modified.daniell", "tukey-hanning", "parzen",
    "triweight", "bartlett-priestley", "triangular", "qs"),
  lag.prewhite = 0,
  welch = FALSE,
  steep = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nse.spec0_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="nse.spec0_+3A_type">type</code></td>
<td>
<p>Method to use in estimating the spectral density function, among <code>"ar"</code>, <code>"glm"</code>, <code>"daniell"</code>,
<code>"modified.daniell"</code>, <code>"tukey-hanning"</code>,
<code>"parzen"</code>, <code>"triweight"</code>,
<code>"bartlett-priestley"</code>, <code>"triangular"</code>, and <code>"qs"</code>. See *Details*.
Default is <code>type = "ar"</code>.</p>
</td></tr>
<tr><td><code id="nse.spec0_+3A_lag.prewhite">lag.prewhite</code></td>
<td>
<p>Prewhite the series before analysis (integer or <code>NULL</code>). When <code>lag.prewhite = NULL</code> this performs automatic lag selection. Default is <code>lag.prewhite = 0</code> that is no prewhitening.</p>
</td></tr>
<tr><td><code id="nse.spec0_+3A_welch">welch</code></td>
<td>
<p>Use Welch's method (Welsh, 1967) to estimate the spectral density.</p>
</td></tr>
<tr><td><code id="nse.spec0_+3A_steep">steep</code></td>
<td>
<p>Use steep or sharp version of the kernel (Phillips et al., 2006) (only available for type: <code>"qs"</code>,<code>"triangular"</code>, and <code>"parzen"</code>). <code>lag.prewhite</code> must be set to 0 to use steep version.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Welsh's method use 50% overlap and 8 sub-samples.
The method <code>"ar"</code> estimates the spectral density using an autoregressive model,
<code>"glm"</code> using a generalized linear model Heidelberger &amp; Welch (1981), 
<code>"daniell"</code> uses daniell window from the <span class="rlang"><b>R</b></span> kernel function,
<code>"modified.daniell"</code> uses daniell window the <span class="rlang"><b>R</b></span> kernel function,
<code>"tukey-hanning"</code> uses the tukey-hanning window,
<code>"parzen"</code> uses the parzen window,
<code>"triweight"</code> uses the triweight window,
<code>"bartlett-priestley"</code> uses the Bartlett-Priestley window,
<code>"triangular"</code> uses the triangular window, and
<code>"qs"</code> uses the quadratic-spectral window,
</p>
<p>This kernel based variance estimator apply weights to smooth out the spectral density using a kernel and takes the spectral density at frequency zero which is equivalent to the variance of the serie. Bandwidth for the kernel is automatically selected using cross-validatory methods (Hurvich, 1985).
</p>


<h3>Value</h3>

<p>The NSE estimator.
</p>


<h3>Note</h3>

<p><code>nse.spec0</code> relies on the packages <code>coda</code>; see the documentation of this package for more details.
</p>


<h3>Author(s)</h3>

<p>David Ardia and Keven Bluteau
</p>


<h3>References</h3>

<p>Heidelberger, P., Welch, Peter D. (1981).
A spectral method for confidence interval generation and run length control in simulations.
<em>Communications of the ACM</em> <b>24</b>(4), 233-245.
</p>
<p>Phillips, P. C., Sun, Y., &amp; Jin, S. (2006).
Spectral density estimation and robust hypothesis testing using steep origin kernels without truncation.
<em>International Economic Review</em>, <b>47</b>(3), 837-894.
</p>
<p>Welch, P. D. (1967),
The use of Fast Fourier Transform for the estimation of power spectra: A method based on time averaging over short, modified periodograms.
<em>IEEE Transactions on Audio and Electroacoustics</em>, <b>AU-15</b>(2): 70-73,
</p>
<p>Hurvich, C. M. (1985).
Data-driven choice of a spectrum estimate: extending the applicability of cross-validation methods.
<em>Journal of the American Statistical Association</em>, <b>80</b>(392), 933-940.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
n    = 1000
ar   = 0.9
mean = 1
sd   = 1
set.seed(1234)
x = c(arima.sim(n = n, list(ar = ar), sd = sd) + mean)

nse.spec0(x = x, type = "parzen", lag.prewhite = 0, welch = TRUE, steep = TRUE)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
