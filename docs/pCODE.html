<!DOCTYPE html><html><head><title>Help for package pCODE</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pCODE}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bootsvar'><p>Bootstrap variance estimator of structural parameters.</p></a></li>
<li><a href='#deltavar'><p>Numeric estimation of variance of structural parameters by Delta method.</p></a></li>
<li><a href='#innerobj'><p>Inner objective function (Single dimension version)</p></a></li>
<li><a href='#innerobj_lkh'><p>Inner objective function (likelihood and multiple dimension version)</p></a></li>
<li><a href='#innerobj_lkh_1d'><p>Inner objective function (Likelihood and Single dimension version)</p></a></li>
<li><a href='#innerobj_multi'><p>Inner objective function (multiple dimension version)</p></a></li>
<li><a href='#innerobj_multi_missing'><p>Inner objective function (multiple dimension version with unobserved state variables)</p></a></li>
<li><a href='#nls_optimize'><p>Optimizer for non-linear least square problems</p></a></li>
<li><a href='#nls_optimize.inner'><p>Optimizer for non-linear least square problems (for inner objective functions)</p></a></li>
<li><a href='#outterobj'><p>Outter objective function (Single dimension version)</p></a></li>
<li><a href='#outterobj_lkh'><p>Outter objective function (likelihood and multiple dimension version)</p></a></li>
<li><a href='#outterobj_lkh_1d'><p>Outter objective function (likelihood and single dimension version)</p></a></li>
<li><a href='#outterobj_multi_missing'><p>Outter objective function (multiple dimension version with unobserved state variables)</p></a></li>
<li><a href='#outterobj_multi_nls'><p>Outter objective function (multiple dimension version)</p></a></li>
<li><a href='#pcode'><p>Parameter Cascade Method for Ordinary Differential Equation Models</p></a></li>
<li><a href='#pcode_1d'><p>Parameter Cascade Method for Ordinary Differential Equation Models (Single dimension version)</p></a></li>
<li><a href='#pcode_lkh'><p>pcode_lkh (likelihood and multiple dimension version)</p></a></li>
<li><a href='#pcode_lkh_1d'><p>Parameter Cascade Method for Ordinary Differential Equation Models (likelihood and Single dimension version)</p></a></li>
<li><a href='#pcode_missing'><p>Parameter Cascade Method for Ordinary Differential Equation Models with missing state variable</p></a></li>
<li><a href='#prepare_basis'><p>Evaluate basis objects over observation times and quadrature points</p></a></li>
<li><a href='#tunelambda'><p>Find optimial penalty parameter lambda by cross-validation.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Estimation of an Ordinary Differential Equation Model by
Parameter Cascade Method</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.4</td>
</tr>
<tr>
<td>Imports:</td>
<td>fda, pracma, MASS, deSolve, stats</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of the parameter cascade method in Ramsay, J. O., Hooker,G., Campbell, D., and Cao, J. (2007) for estimating ordinary differential equation models with missing or complete observations. It combines smoothing method and profile estimation to estimate any non-linear dynamic system. The package also offers variance estimates for parameters of interest based on either bootstrap or Delta method.  </td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/alex-haixuw/PCODE">https://github.com/alex-haixuw/PCODE</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, Hmisc, testthat (&ge; 2.1.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-07 22:27:35 UTC; default</td>
</tr>
<tr>
<td>Author:</td>
<td>Haixu Wang [aut, cre],
  Jiguo Cao [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Haixu Wang &lt;haixuw@sfu.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-07 22:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bootsvar'>Bootstrap variance estimator of structural parameters.</h2><span id='topic+bootsvar'></span>

<h3>Description</h3>

<p>Obtaining an estimate of variance for structural parameters by bootstrap method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootsvar(data, time, ode.model,par.names,state.names, likelihood.fun = NULL,
       par.initial, basis.list, lambda = NULL,bootsrep,controls = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootsvar_+3A_data">data</code></td>
<td>
<p>A data frame or a matrix contain observations from each dimension of the ODE model.</p>
</td></tr>
<tr><td><code id="bootsvar_+3A_time">time</code></td>
<td>
<p>A vector contain observation times or a matrix if time points are different between dimensions.</p>
</td></tr>
<tr><td><code id="bootsvar_+3A_ode.model">ode.model</code></td>
<td>
<p>An R function that computes the time derivative of the ODE model given observations of states variable and structural parameters.</p>
</td></tr>
<tr><td><code id="bootsvar_+3A_par.names">par.names</code></td>
<td>
<p>The names of structural parameters defined in the 'ode.model'.</p>
</td></tr>
<tr><td><code id="bootsvar_+3A_state.names">state.names</code></td>
<td>
<p>The names of state variables defined in the 'ode.model'.</p>
</td></tr>
<tr><td><code id="bootsvar_+3A_likelihood.fun">likelihood.fun</code></td>
<td>
<p>A likelihood function passed to PCODE in case of that the error termsdevtools::document()do not have a Normal distribution.</p>
</td></tr>
<tr><td><code id="bootsvar_+3A_par.initial">par.initial</code></td>
<td>
<p>Initial value of structural parameters to be optimized.</p>
</td></tr>
<tr><td><code id="bootsvar_+3A_basis.list">basis.list</code></td>
<td>
<p>A list of basis objects for smoothing each dimension's observations. Can be the same or different across dimensions.</p>
</td></tr>
<tr><td><code id="bootsvar_+3A_lambda">lambda</code></td>
<td>
<p>Penalty parameter.</p>
</td></tr>
<tr><td><code id="bootsvar_+3A_bootsrep">bootsrep</code></td>
<td>
<p>Bootstrap sample to be used for estimating variance.</p>
</td></tr>
<tr><td><code id="bootsvar_+3A_controls">controls</code></td>
<td>
<p>A list of control parameters. Same as the controls in <code>pcode</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>boots.var The bootstrap variance of each structural parameters.
</p>

<hr>
<h2 id='deltavar'>Numeric estimation of variance of structural parameters by Delta method.</h2><span id='topic+deltavar'></span>

<h3>Description</h3>

<p>Obtaining variance of structural parameters by Delta method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deltavar(data, time, ode.model,par.names,state.names,
        likelihood.fun, par.initial, basis.list, lambda,stepsize,y_stepsize,controls)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deltavar_+3A_data">data</code></td>
<td>
<p>A data frame or a matrix contain observations from each dimension of the ODE model.</p>
</td></tr>
<tr><td><code id="deltavar_+3A_time">time</code></td>
<td>
<p>A vector contain observation times or a matrix if time points are different between dimensions.</p>
</td></tr>
<tr><td><code id="deltavar_+3A_ode.model">ode.model</code></td>
<td>
<p>An R function that computes the time derivative of the ODE model given observations of states variable and structural parameters.</p>
</td></tr>
<tr><td><code id="deltavar_+3A_par.names">par.names</code></td>
<td>
<p>The names of structural parameters defined in the 'ode.model'.</p>
</td></tr>
<tr><td><code id="deltavar_+3A_state.names">state.names</code></td>
<td>
<p>The names of state variables defined in the 'ode.model'.</p>
</td></tr>
<tr><td><code id="deltavar_+3A_likelihood.fun">likelihood.fun</code></td>
<td>
<p>A likelihood function passed to PCODE in case of that the error termsdevtools::document()do not have a Normal distribution.</p>
</td></tr>
<tr><td><code id="deltavar_+3A_par.initial">par.initial</code></td>
<td>
<p>Initial value of structural parameters to be optimized.</p>
</td></tr>
<tr><td><code id="deltavar_+3A_basis.list">basis.list</code></td>
<td>
<p>A list of basis objects for smoothing each dimension's observations. Can be the same or different across dimensions.</p>
</td></tr>
<tr><td><code id="deltavar_+3A_lambda">lambda</code></td>
<td>
<p>Penalty parameter.</p>
</td></tr>
<tr><td><code id="deltavar_+3A_stepsize">stepsize</code></td>
<td>
<p>Stepsize used in estimating partial derivatives with respect to structural parameters for the Delta method.</p>
</td></tr>
<tr><td><code id="deltavar_+3A_y_stepsize">y_stepsize</code></td>
<td>
<p>Stepsize used in estimating partial derivatives with respect to observations for the Delta method.</p>
</td></tr>
<tr><td><code id="deltavar_+3A_controls">controls</code></td>
<td>
<p>A list of control parameters. Same as the controls in <code>pcode</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>par.var The variance of structural parameters obtained by Delta method.
</p>

<hr>
<h2 id='innerobj'>Inner objective function (Single dimension version)</h2><span id='topic+innerobj'></span>

<h3>Description</h3>

<p>An objective function combines the sum of squared error of basis expansion estimates and the penalty controls how those estimates fail to satisfies the ODE model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>innerobj(basis_coef, ode.par, input, derive.model,NLS)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="innerobj_+3A_basis_coef">basis_coef</code></td>
<td>
<p>Basis coefficients for interpolating observations given a basis object.</p>
</td></tr>
<tr><td><code id="innerobj_+3A_ode.par">ode.par</code></td>
<td>
<p>Structural parameters of the ODE model.</p>
</td></tr>
<tr><td><code id="innerobj_+3A_input">input</code></td>
<td>
<p>Contains dependencies for the optimization, including observations, penalty parameter lambda, and etc..</p>
</td></tr>
<tr><td><code id="innerobj_+3A_derive.model">derive.model</code></td>
<td>
<p>The function defines the ODE model and is the same as the ode.model in 'pcode'</p>
</td></tr>
<tr><td><code id="innerobj_+3A_nls">NLS</code></td>
<td>
<p>Default is <code>TRUE</code> so the function returns vector of residuals, and otherwise returns sum of squared errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>residual.vec</code></td>
<td>
<p>Vector of residuals and evaluation of penalty function on quadrature points for approximating the integral.</p>
</td></tr>
</table>

<hr>
<h2 id='innerobj_lkh'>Inner objective function (likelihood and multiple dimension version)</h2><span id='topic+innerobj_lkh'></span>

<h3>Description</h3>

<p>An objective function combines the likelihood or loglikelihood of errors from each dimension of state variables and the penalty controls how the state estimates fail to satisfy the ODE model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>innerobj_lkh(basis_coef, ode.par, input, derive.model, likelihood.fun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="innerobj_lkh_+3A_basis_coef">basis_coef</code></td>
<td>
<p>Basis coefficients for interpolating observations given a basis boject.</p>
</td></tr>
<tr><td><code id="innerobj_lkh_+3A_ode.par">ode.par</code></td>
<td>
<p>Structural parameters of the ODD model.</p>
</td></tr>
<tr><td><code id="innerobj_lkh_+3A_input">input</code></td>
<td>
<p>Contains dependencies for the optimization, including observations, ode penalty, and etc..</p>
</td></tr>
<tr><td><code id="innerobj_lkh_+3A_derive.model">derive.model</code></td>
<td>
<p>The function defines the ODE model and is the same as the ode.model in 'pcode'.</p>
</td></tr>
<tr><td><code id="innerobj_lkh_+3A_likelihood.fun">likelihood.fun</code></td>
<td>
<p>The likelihood or loglikelihood function of the errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>obj.eval The evaluation of the inner objective function.
</p>

<hr>
<h2 id='innerobj_lkh_1d'>Inner objective function (Likelihood and Single dimension version)</h2><span id='topic+innerobj_lkh_1d'></span>

<h3>Description</h3>

<p>An objective function combines the likelihood or loglikelihood of errors from each dimension of state variables and the penalty controls how the state estimates fail to satisfy the ODE model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>innerobj_lkh_1d(basis_coef, ode.par, input, derive.model, likelihood.fun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="innerobj_lkh_1d_+3A_basis_coef">basis_coef</code></td>
<td>
<p>Basis coefficients for interpolating observations given a basis boject.</p>
</td></tr>
<tr><td><code id="innerobj_lkh_1d_+3A_ode.par">ode.par</code></td>
<td>
<p>Structural parameters of the ODD model.</p>
</td></tr>
<tr><td><code id="innerobj_lkh_1d_+3A_input">input</code></td>
<td>
<p>Contains dependencies for the optimization, including observations, ode penalty, and etc..</p>
</td></tr>
<tr><td><code id="innerobj_lkh_1d_+3A_derive.model">derive.model</code></td>
<td>
<p>The function defines the ODE model and is the same as the ode.model in 'pcode'.</p>
</td></tr>
<tr><td><code id="innerobj_lkh_1d_+3A_likelihood.fun">likelihood.fun</code></td>
<td>
<p>The likelihood or loglikelihood function of the errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>obj.eval The evaluation of the inner objective function.
</p>

<hr>
<h2 id='innerobj_multi'>Inner objective function (multiple dimension version)</h2><span id='topic+innerobj_multi'></span>

<h3>Description</h3>

<p>An objective function combines the sum of squared error of basis expansion estimates and the penalty controls how those estimates fail to satisfies the ODE model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>innerobj_multi(basis_coef, ode.par, input, derive.model,NLS)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="innerobj_multi_+3A_basis_coef">basis_coef</code></td>
<td>
<p>Basis coefficients for interpolating observations given a basis object.</p>
</td></tr>
<tr><td><code id="innerobj_multi_+3A_ode.par">ode.par</code></td>
<td>
<p>Structural parameters of the ODE model.</p>
</td></tr>
<tr><td><code id="innerobj_multi_+3A_input">input</code></td>
<td>
<p>Contains dependencies for the optimization, including observations, penalty parameter lambda, and etc..</p>
</td></tr>
<tr><td><code id="innerobj_multi_+3A_derive.model">derive.model</code></td>
<td>
<p>The function defines the ODE model and is the same as the <code>ode.model</code> in <code>pcode</code>.</p>
</td></tr>
<tr><td><code id="innerobj_multi_+3A_nls">NLS</code></td>
<td>
<p>Default is <code>TRUE</code> so the function returns vector of residuals, and otherwise returns sum of squared errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>residual.vec</code></td>
<td>
<p>Vector of residuals and evaluation of penalty function on quadrature points for approximating the integral.</p>
</td></tr>
</table>

<hr>
<h2 id='innerobj_multi_missing'>Inner objective function (multiple dimension version with unobserved state variables)</h2><span id='topic+innerobj_multi_missing'></span>

<h3>Description</h3>

<p>An objective function combines the sum of squared error of basis expansion estimates and the penalty controls how those estimates fail to satisfies the ODE model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>innerobj_multi_missing(basis_coef, ode.par, input, derive.model,NLS)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="innerobj_multi_missing_+3A_basis_coef">basis_coef</code></td>
<td>
<p>Basis coefficients for interpolating observations given a basis object.</p>
</td></tr>
<tr><td><code id="innerobj_multi_missing_+3A_ode.par">ode.par</code></td>
<td>
<p>Structural parameters of the ODE model.</p>
</td></tr>
<tr><td><code id="innerobj_multi_missing_+3A_input">input</code></td>
<td>
<p>Contains dependencies for the optimization, including observations, penalty parameter lambda, and etc..</p>
</td></tr>
<tr><td><code id="innerobj_multi_missing_+3A_derive.model">derive.model</code></td>
<td>
<p>The function defines the ODE model and is the same as the ode.model in 'pcode'</p>
</td></tr>
<tr><td><code id="innerobj_multi_missing_+3A_nls">NLS</code></td>
<td>
<p>Default is <code>TRUE</code> so the function returns vector of residuals, and otherwise returns sum of squared errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>residual.vec</code></td>
<td>
<p>Vector of residuals and evaluation of penalty function on quadrature points for approximating the integral.</p>
</td></tr>
</table>

<hr>
<h2 id='nls_optimize'>Optimizer for non-linear least square problems</h2><span id='topic+nls_optimize'></span>

<h3>Description</h3>

<p>Obtain the solution to minimize the sum of squared errors of the defined function <code>fun</code> by levenberg-marquardt method. Adapted from PRACMA package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nls_optimize(fun, x0, ..., options,verbal)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nls_optimize_+3A_fun">fun</code></td>
<td>
<p>The function returns the vector of weighted residuals.</p>
</td></tr>
<tr><td><code id="nls_optimize_+3A_x0">x0</code></td>
<td>
<p>The initial value for optimization.</p>
</td></tr>
<tr><td><code id="nls_optimize_+3A_...">...</code></td>
<td>
<p>Parameters to be passed for <code>fun</code></p>
</td></tr>
<tr><td><code id="nls_optimize_+3A_options">options</code></td>
<td>
<p>Additional optimization controls.</p>
</td></tr>
<tr><td><code id="nls_optimize_+3A_verbal">verbal</code></td>
<td>
<p>Default = 1 for printing iteration and other for suppressing</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>par</code></td>
<td>
<p>The solution to the non-linear least square problem, the same size as <code>x0</code></p>
</td></tr>
</table>

<hr>
<h2 id='nls_optimize.inner'>Optimizer for non-linear least square problems (for inner objective functions)</h2><span id='topic+nls_optimize.inner'></span>

<h3>Description</h3>

<p>Obtain the solution to minimize the sum of squared errors of the defined function <code>fun</code> by levenberg-marquardt method. Adapted from PRACMA package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nls_optimize.inner(fun, x0, ..., options)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nls_optimize.inner_+3A_fun">fun</code></td>
<td>
<p>The function returns the vector of weighted residuals.</p>
</td></tr>
<tr><td><code id="nls_optimize.inner_+3A_x0">x0</code></td>
<td>
<p>The initial value for optimization.</p>
</td></tr>
<tr><td><code id="nls_optimize.inner_+3A_...">...</code></td>
<td>
<p>Parameters to be passed for <code>fun</code></p>
</td></tr>
<tr><td><code id="nls_optimize.inner_+3A_options">options</code></td>
<td>
<p>Additional optimization controls.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>par</code></td>
<td>
<p>The solution to the non-linear least square problem, the same size as <code>x0</code></p>
</td></tr>
</table>

<hr>
<h2 id='outterobj'>Outter objective function (Single dimension version)</h2><span id='topic+outterobj'></span>

<h3>Description</h3>

<p>An objective function of the structural parameter computes the measure of fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outterobj(ode.parameter, basis.initial, derivative.model, inner.input, NLS)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="outterobj_+3A_ode.parameter">ode.parameter</code></td>
<td>
<p>Structural parameters of the ODE model.</p>
</td></tr>
<tr><td><code id="outterobj_+3A_basis.initial">basis.initial</code></td>
<td>
<p>Initial values of the basis coefficients for nonlinear least square optimization.</p>
</td></tr>
<tr><td><code id="outterobj_+3A_derivative.model">derivative.model</code></td>
<td>
<p>The function defines the ODE model and is the same as the ode.model in 'pcode'</p>
</td></tr>
<tr><td><code id="outterobj_+3A_inner.input">inner.input</code></td>
<td>
<p>Input that will be passed to the inner objective function. Contains dependencies for the optimization, including observations, penalty parameter lambda, and etc..</p>
</td></tr>
<tr><td><code id="outterobj_+3A_nls">NLS</code></td>
<td>
<p>Default is <code>TRUE</code> so the function returns vector of residuals, and otherwise returns sum of squared errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>residual</code></td>
<td>
<p>Vector of residuals and evaluation of penalty function on quadrature points for approximating the integral.</p>
</td></tr>
</table>

<hr>
<h2 id='outterobj_lkh'>Outter objective function (likelihood and multiple dimension version)</h2><span id='topic+outterobj_lkh'></span>

<h3>Description</h3>

<p>An objective function of the structural parameter computes the measure of fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outterobj_lkh(ode.parameter, basis.initial, derivative.model, likelihood.fun, inner.input)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="outterobj_lkh_+3A_ode.parameter">ode.parameter</code></td>
<td>
<p>Structural parameters of the ODE model.</p>
</td></tr>
<tr><td><code id="outterobj_lkh_+3A_basis.initial">basis.initial</code></td>
<td>
<p>Initial values of the basis coefficients for nonlinear least square optimization.</p>
</td></tr>
<tr><td><code id="outterobj_lkh_+3A_derivative.model">derivative.model</code></td>
<td>
<p>The function defines the ODE model and is the same as the ode.model in 'pcode'</p>
</td></tr>
<tr><td><code id="outterobj_lkh_+3A_likelihood.fun">likelihood.fun</code></td>
<td>
<p>The likelihood or loglikelihood function of the errors.</p>
</td></tr>
<tr><td><code id="outterobj_lkh_+3A_inner.input">inner.input</code></td>
<td>
<p>Input that will be passed to the inner objective function. Contains dependencies for the optimization, including observations, penalty parameter lambda, and etc..</p>
</td></tr>
</table>


<h3>Value</h3>

<p>neglik The negative of the likelihood or the loglikelihood function that will be passed further to the 'optim' function.
</p>

<hr>
<h2 id='outterobj_lkh_1d'>Outter objective function (likelihood and single dimension version)</h2><span id='topic+outterobj_lkh_1d'></span>

<h3>Description</h3>

<p>An objective function of the structural parameter computes the measure of fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outterobj_lkh_1d(ode.parameter, basis.initial,
                        derivative.model, likelihood.fun, inner.input)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="outterobj_lkh_1d_+3A_ode.parameter">ode.parameter</code></td>
<td>
<p>Structural parameters of the ODE model.</p>
</td></tr>
<tr><td><code id="outterobj_lkh_1d_+3A_basis.initial">basis.initial</code></td>
<td>
<p>Initial values of the basis coefficients for nonlinear least square optimization.</p>
</td></tr>
<tr><td><code id="outterobj_lkh_1d_+3A_derivative.model">derivative.model</code></td>
<td>
<p>The function defines the ODE model and is the same as the ode.model in 'pcode'</p>
</td></tr>
<tr><td><code id="outterobj_lkh_1d_+3A_likelihood.fun">likelihood.fun</code></td>
<td>
<p>The likelihood or loglikelihood function of the errors.</p>
</td></tr>
<tr><td><code id="outterobj_lkh_1d_+3A_inner.input">inner.input</code></td>
<td>
<p>Input that will be passed to the inner objective function. Contains dependencies for the optimization, including observations, penalty parameter lambda, and etc..</p>
</td></tr>
</table>


<h3>Value</h3>

<p>neglik The negative of the likelihood or the loglikelihood function that will be passed further to the 'optim' function.
</p>

<hr>
<h2 id='outterobj_multi_missing'>Outter objective function (multiple dimension version with unobserved state variables)</h2><span id='topic+outterobj_multi_missing'></span>

<h3>Description</h3>

<p>An objective function of the structural parameter computes the measure of fit for the basis expansion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outterobj_multi_missing(ode.parameter, basis.initial, derivative.model, inner.input, NLS)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="outterobj_multi_missing_+3A_ode.parameter">ode.parameter</code></td>
<td>
<p>Structural parameters of the ODE model.</p>
</td></tr>
<tr><td><code id="outterobj_multi_missing_+3A_basis.initial">basis.initial</code></td>
<td>
<p>Initial values of the basis coefficients for nonlinear least square optimization.</p>
</td></tr>
<tr><td><code id="outterobj_multi_missing_+3A_derivative.model">derivative.model</code></td>
<td>
<p>The function defines the ODE model and is the same as the ode.model in 'pcode'</p>
</td></tr>
<tr><td><code id="outterobj_multi_missing_+3A_inner.input">inner.input</code></td>
<td>
<p>Input that will be passed to the inner objective function. Contains dependencies for the optimization, including observations, penalty parameter lambda, and etc..</p>
</td></tr>
<tr><td><code id="outterobj_multi_missing_+3A_nls">NLS</code></td>
<td>
<p>Default is <code>TRUE</code> so the function returns vector of residuals, and otherwise returns sum of squared errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>residual</code></td>
<td>
<p>Vector of residuals and evaluation of penalty function on quadrature points for approximating the integral.</p>
</td></tr>
</table>

<hr>
<h2 id='outterobj_multi_nls'>Outter objective function (multiple dimension version)</h2><span id='topic+outterobj_multi_nls'></span>

<h3>Description</h3>

<p>An objective function of the structural parameter computes the measure of fit for the basis expansion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outterobj_multi_nls(ode.parameter, basis.initial, derivative.model, inner.input, NLS)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="outterobj_multi_nls_+3A_ode.parameter">ode.parameter</code></td>
<td>
<p>Structural parameters of the ODE model.</p>
</td></tr>
<tr><td><code id="outterobj_multi_nls_+3A_basis.initial">basis.initial</code></td>
<td>
<p>Initial values of the basis coefficients for nonlinear least square optimization.</p>
</td></tr>
<tr><td><code id="outterobj_multi_nls_+3A_derivative.model">derivative.model</code></td>
<td>
<p>The function defines the ODE model and is the same as the <code>ode.model</code> in <code>pcode</code>.</p>
</td></tr>
<tr><td><code id="outterobj_multi_nls_+3A_inner.input">inner.input</code></td>
<td>
<p>Input that will be passed to the inner objective function. Contains dependencies for the optimization, including observations, penalty parameter lambda, and etc..</p>
</td></tr>
<tr><td><code id="outterobj_multi_nls_+3A_nls">NLS</code></td>
<td>
<p>Default is <code>TRUE</code> so the function returns vector of residuals, and otherwise returns sum of squared errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>residual</code></td>
<td>
<p>Vector of residuals and evaluation of penalty function on quadrature points for approximating the integral.</p>
</td></tr>
</table>

<hr>
<h2 id='pcode'>Parameter Cascade Method for Ordinary Differential Equation Models</h2><span id='topic+pcode'></span>

<h3>Description</h3>

<p>Obtain estimates of both structural and nuisance parameters of an ODE model by parameter cascade method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcode(data, time, ode.model, par.names, state.names,
             likelihood.fun, par.initial, basis.list,lambda,controls)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcode_+3A_data">data</code></td>
<td>
<p>A data frame or a matrix contain observations from each dimension of the ODE model.</p>
</td></tr>
<tr><td><code id="pcode_+3A_time">time</code></td>
<td>
<p>A vector contain observation times or a matrix if time points are different between dimensions.</p>
</td></tr>
<tr><td><code id="pcode_+3A_ode.model">ode.model</code></td>
<td>
<p>An R function that computes the time derivative of the ODE model given observations of states variable and structural parameters.</p>
</td></tr>
<tr><td><code id="pcode_+3A_par.names">par.names</code></td>
<td>
<p>The names of structural parameters defined in the 'ode.model'.</p>
</td></tr>
<tr><td><code id="pcode_+3A_state.names">state.names</code></td>
<td>
<p>The names of state variables defined in the 'ode.model'.</p>
</td></tr>
<tr><td><code id="pcode_+3A_likelihood.fun">likelihood.fun</code></td>
<td>
<p>A likelihood function passed to PCODE in case of that the error terms do not have a Normal distribution.</p>
</td></tr>
<tr><td><code id="pcode_+3A_par.initial">par.initial</code></td>
<td>
<p>Initial value of structural parameters to be optimized.</p>
</td></tr>
<tr><td><code id="pcode_+3A_basis.list">basis.list</code></td>
<td>
<p>A list of basis objects for smoothing each dimension's observations. Can be the same or different across dimensions.</p>
</td></tr>
<tr><td><code id="pcode_+3A_lambda">lambda</code></td>
<td>
<p>Penalty parameter for controling the fidelity of interpolation.</p>
</td></tr>
<tr><td><code id="pcode_+3A_controls">controls</code></td>
<td>
<p>A list of control parameters. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>controls</code> argument is a list providing addition inputs for the nonlinear least square optimizer or general optimizer <code>optim</code>:
</p>

<dl>
<dt><code>nquadpts</code></dt><dd><p>Determine the number of quadrature points for approximating an integral. Default is 101.</p>
</dd>
<dt><code>smooth.lambda</code></dt><dd><p>Determine the smoothness penalty for obtaining initial value of nuisance parameters.</p>
</dd>
<dt><code>tau</code></dt><dd><p>Initial value of Marquardt parameter. Small values indicate good initial values for structural parameters.</p>
</dd>
<dt><code>tolx</code></dt><dd><p>Tolerance for parameters of objective functions. Default is set at 1e-6.</p>
</dd>
<dt><code>tolg</code></dt><dd><p>Tolerance for the gradient of parameters of objective functions. Default is set at 1e-6.</p>
</dd>
<dt><code>maxeval</code></dt><dd><p>The maximum number of evaluation of the outter optimizer. Default is set at 20.</p>
</dd>
</dl>



<h3>Value</h3>

<table>
<tr><td><code>structural.par</code></td>
<td>
<p>The structural parameters of the ODE model.</p>
</td></tr>
<tr><td><code>nuisance.par</code></td>
<td>
<p>The nuisance parameters or the basis coefficients for interpolating observations.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(fda)
library(deSolve)
library(MASS)
library(pracma)
#Simple ode model example
#define model parameters
model.par   &lt;- c(theta = c(0.1))
#define state initial value
state       &lt;- c(X     = 0.1)
#Define model for function 'ode' to numerically solve the system
ode.model &lt;- function(t, state,parameters){
 with(as.list(c(state,parameters)),
      {
        dX &lt;- theta*X*(1-X/10)
        return(list(dX))
      })
}
#Observation time points
times &lt;- seq(0,100,length.out=101)
#Solve the ode model
desolve.mod &lt;- ode(y=state,times=times,func=ode.model,parms = model.par)
#Prepare for doing parameter cascading method
#Generate basis object for interpolation and as argument of pcode
#21 konts equally spaced within [0,100]
knots &lt;- seq(0,100,length.out=21)
#order of basis functions
norder &lt;- 4
#number of basis funtions
nbasis &lt;- length(knots) + norder - 2
#creating Bspline basis
basis  &lt;- create.bspline.basis(c(0,100),nbasis,norder,breaks = knots)
#Add random noise to ode solution for simulating data
nobs  &lt;- length(times)
scale &lt;- 0.1
noise &lt;- scale*rnorm(n = nobs, mean = 0 , sd = 1)
observation &lt;- desolve.mod[,2] + noise
#parameter estimation
pcode(data = observation, time = times, ode.model = ode.model,
                     par.initial = 0.1, par.names = 'theta',state.names = 'X',
                     basis.list = basis, lambda = 1e2)

</code></pre>

<hr>
<h2 id='pcode_1d'>Parameter Cascade Method for Ordinary Differential Equation Models (Single dimension version)</h2><span id='topic+pcode_1d'></span>

<h3>Description</h3>

<p>Obtain estiamtes of structural parameters of an ODE model by parameter cascade method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcode_1d(data, time, ode.model, par.initial,par.names, basis,lambda,controls = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcode_1d_+3A_data">data</code></td>
<td>
<p>A data frame or a vector contains observations from the ODE model.</p>
</td></tr>
<tr><td><code id="pcode_1d_+3A_time">time</code></td>
<td>
<p>The vector contain observation times.</p>
</td></tr>
<tr><td><code id="pcode_1d_+3A_ode.model">ode.model</code></td>
<td>
<p>Defined R function that computes the time derivative of the ODE model given observations of states variable.</p>
</td></tr>
<tr><td><code id="pcode_1d_+3A_par.initial">par.initial</code></td>
<td>
<p>Initial value of structural parameters to be optimized.</p>
</td></tr>
<tr><td><code id="pcode_1d_+3A_par.names">par.names</code></td>
<td>
<p>The names of structural parameters defined in the 'ode.model'.</p>
</td></tr>
<tr><td><code id="pcode_1d_+3A_basis">basis</code></td>
<td>
<p>A basis objects for smoothing observations.</p>
</td></tr>
<tr><td><code id="pcode_1d_+3A_lambda">lambda</code></td>
<td>
<p>Penalty parameter.</p>
</td></tr>
<tr><td><code id="pcode_1d_+3A_controls">controls</code></td>
<td>
<p>A list of control parameters. See ‘Details’.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>structural.par</code></td>
<td>
<p>The structural parameters of the ODE model.</p>
</td></tr>
<tr><td><code>nuisance.par</code></td>
<td>
<p>The nuisance parameters or the basis coefficients for interpolating observations.</p>
</td></tr>
</table>

<hr>
<h2 id='pcode_lkh'>pcode_lkh (likelihood and multiple dimension version)</h2><span id='topic+pcode_lkh'></span>

<h3>Description</h3>

<p>Obtain estimates of both structural and nuisance parameters of an ODE model by parameter cascade method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcode_lkh(data, likelihood.fun, time, ode.model, par.names,
                 state.names, par.initial, basis.list, lambda, controls)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcode_lkh_+3A_data">data</code></td>
<td>
<p>A data frame or a matrix contain observations from each dimension of the ODE model.</p>
</td></tr>
<tr><td><code id="pcode_lkh_+3A_likelihood.fun">likelihood.fun</code></td>
<td>
<p>A function computes the likelihood or the loglikelihood of the errors.</p>
</td></tr>
<tr><td><code id="pcode_lkh_+3A_time">time</code></td>
<td>
<p>A vector contains observation ties or a matrix if time points are different between dimesion.</p>
</td></tr>
<tr><td><code id="pcode_lkh_+3A_ode.model">ode.model</code></td>
<td>
<p>An R function that computes the time derivative of the ODE model given observations of states variable and structural parameters.</p>
</td></tr>
<tr><td><code id="pcode_lkh_+3A_par.names">par.names</code></td>
<td>
<p>The names of structural parameters defined in the 'ode.model'.</p>
</td></tr>
<tr><td><code id="pcode_lkh_+3A_state.names">state.names</code></td>
<td>
<p>The names of state variables defined in the 'ode.model'.</p>
</td></tr>
<tr><td><code id="pcode_lkh_+3A_par.initial">par.initial</code></td>
<td>
<p>Initial value of structural parameters to be optimized.</p>
</td></tr>
<tr><td><code id="pcode_lkh_+3A_basis.list">basis.list</code></td>
<td>
<p>A list of basis objects for smoothing each dimension's observations. Can be the same or different across dimensions.</p>
</td></tr>
<tr><td><code id="pcode_lkh_+3A_lambda">lambda</code></td>
<td>
<p>Penalty parameter.</p>
</td></tr>
<tr><td><code id="pcode_lkh_+3A_controls">controls</code></td>
<td>
<p>A list of control parameters. See ‘Details’.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>controls</code> argument is a list providing addition inputs for the nonlinear least square optimizer:
</p>

<ul>
<li> <p><code>nquadpts</code> Determine the number of quadrature points for approximating an integral. Default is 101.
</p>
</li>
<li> <p><code>smooth.lambda</code> Determine the smoothness penalty for obtaining initial value of nuisance parameters.
</p>
</li>
<li> <p><code>tau</code> Initial value of Marquardt parameter. Small values indicate good initial values for structural parameters.
</p>
</li>
<li> <p><code>tolx</code> Tolerance for parameters of objective functions. Default is set at 1e-6.
</p>
</li>
<li> <p><code>tolg</code> Tolerance for the gradient of parameters of objective functions. Default is set at 1e-6.
</p>
</li>
<li> <p><code>maxeval</code> The maximum number of evaluation of the optimizer. Default is set at 20.
</p>
</li></ul>



<h3>Value</h3>

<table>
<tr><td><code>structural.par</code></td>
<td>
<p>The structural parameters of the ODE model.</p>
</td></tr>
<tr><td><code>nuisance.par</code></td>
<td>
<p>The nuisance parameters or the basis coefficients for interpolating observations.</p>
</td></tr>
</table>

<hr>
<h2 id='pcode_lkh_1d'>Parameter Cascade Method for Ordinary Differential Equation Models (likelihood and Single dimension version)</h2><span id='topic+pcode_lkh_1d'></span>

<h3>Description</h3>

<p>Obtain estimates of both structural and nuisance parameters of an ODE model by parameter cascade method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcode_lkh_1d(data, likelihood.fun, time, ode.model, par.names,
                    state.names, par.initial, basis.list, lambda, controls)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcode_lkh_1d_+3A_data">data</code></td>
<td>
<p>A data frame or a matrix contain observations from each dimension of the ODE model.</p>
</td></tr>
<tr><td><code id="pcode_lkh_1d_+3A_likelihood.fun">likelihood.fun</code></td>
<td>
<p>A function computes the likelihood or the loglikelihood of the errors.</p>
</td></tr>
<tr><td><code id="pcode_lkh_1d_+3A_time">time</code></td>
<td>
<p>A vector contains observation ties or a matrix if time points are different between dimesion.</p>
</td></tr>
<tr><td><code id="pcode_lkh_1d_+3A_ode.model">ode.model</code></td>
<td>
<p>An R function that computes the time derivative of the ODE model given observations of states variable and structural parameters.</p>
</td></tr>
<tr><td><code id="pcode_lkh_1d_+3A_par.names">par.names</code></td>
<td>
<p>The names of structural parameters defined in the 'ode.model'.</p>
</td></tr>
<tr><td><code id="pcode_lkh_1d_+3A_state.names">state.names</code></td>
<td>
<p>The names of state variables defined in the 'ode.model'.</p>
</td></tr>
<tr><td><code id="pcode_lkh_1d_+3A_par.initial">par.initial</code></td>
<td>
<p>Initial value of structural parameters to be optimized.</p>
</td></tr>
<tr><td><code id="pcode_lkh_1d_+3A_basis.list">basis.list</code></td>
<td>
<p>A list of basis objects for smoothing each dimension's observations. Can be the same or different across dimensions.</p>
</td></tr>
<tr><td><code id="pcode_lkh_1d_+3A_lambda">lambda</code></td>
<td>
<p>Penalty parameter.</p>
</td></tr>
<tr><td><code id="pcode_lkh_1d_+3A_controls">controls</code></td>
<td>
<p>A list of control parameters. See ‘Details’.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>controls</code> argument is a list providing addition inputs for the nonlinear least square optimizer:
</p>

<ul>
<li> <p><code>nquadpts</code> Determine the number of quadrature points for approximating an integral. Default is 101.
</p>
</li>
<li> <p><code>smooth.lambda</code> Determine the smoothness penalty for obtaining initial value of nuisance parameters.
</p>
</li>
<li> <p><code>tau</code> Initial value of Marquardt parameter. Small values indicate good initial values for structural parameters.
</p>
</li>
<li> <p><code>tolx</code> Tolerance for parameters of objective functions. Default is set at 1e-6.
</p>
</li>
<li> <p><code>tolg</code> Tolerance for the gradient of parameters of objective functions. Default is set at 1e-6.
</p>
</li>
<li> <p><code>maxeval</code> The maximum number of evaluation of the optimizer. Default is set at 20.
</p>
</li></ul>



<h3>Value</h3>

<table>
<tr><td><code>structural.par</code></td>
<td>
<p>The structural parameters of the ODE model.</p>
</td></tr>
<tr><td><code>nuisance.par</code></td>
<td>
<p>The nuisance parameters or the basis coefficients for interpolating observations.</p>
</td></tr>
</table>

<hr>
<h2 id='pcode_missing'>Parameter Cascade Method for Ordinary Differential Equation Models with missing state variable</h2><span id='topic+pcode_missing'></span>

<h3>Description</h3>

<p>Obtain estiamtes of both structural and nuisance parameters of an ODE model by parameter cascade method when the dynamics are partially observed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcode_missing(data, time, ode.model, par.names, state.names,
                     likelihood.fun,par.initial, basis.list,lambda,controls)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcode_missing_+3A_data">data</code></td>
<td>
<p>A data frame or a matrix contain observations from each dimension of the ODE model.</p>
</td></tr>
<tr><td><code id="pcode_missing_+3A_time">time</code></td>
<td>
<p>A vector contain observation times or a matrix if time points are different between dimensions.</p>
</td></tr>
<tr><td><code id="pcode_missing_+3A_ode.model">ode.model</code></td>
<td>
<p>An R function that computes the time derivative of the ODE model given observations of states variable and structural parameters.</p>
</td></tr>
<tr><td><code id="pcode_missing_+3A_par.names">par.names</code></td>
<td>
<p>The names of structural parameters defined in the 'ode.model'.</p>
</td></tr>
<tr><td><code id="pcode_missing_+3A_state.names">state.names</code></td>
<td>
<p>The names of state variables defined in the 'ode.model'.</p>
</td></tr>
<tr><td><code id="pcode_missing_+3A_likelihood.fun">likelihood.fun</code></td>
<td>
<p>A likelihood function passed to PCODE in case of that the error termsdevtools::document()do not have a Normal distribution.</p>
</td></tr>
<tr><td><code id="pcode_missing_+3A_par.initial">par.initial</code></td>
<td>
<p>Initial value of structural parameters to be optimized.</p>
</td></tr>
<tr><td><code id="pcode_missing_+3A_basis.list">basis.list</code></td>
<td>
<p>A list of basis objects for smoothing each dimension's observations. Can be the same or different across dimensions.</p>
</td></tr>
<tr><td><code id="pcode_missing_+3A_lambda">lambda</code></td>
<td>
<p>Penalty parameter.</p>
</td></tr>
<tr><td><code id="pcode_missing_+3A_controls">controls</code></td>
<td>
<p>A list of control parameters. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>controls</code> argument is a list providing addition inputs for the nonlinear least square optimizer or general optimizer <code>optim</code>:
</p>

<ul>
<li> <p><code>nquadpts</code> Determine the number of quadrature points for approximating an integral. Default is 101.
</p>
</li>
<li> <p><code>smooth.lambda</code> Determine the smoothness penalty for obtaining initial value of nuisance parameters.
</p>
</li>
<li> <p><code>tau</code> Initial value of Marquardt parameter. Small values indicate good initial values for structural parameters.
</p>
</li>
<li> <p><code>tolx</code> Tolerance for parameters of objective functions. Default is set at 1e-6.
</p>
</li>
<li> <p><code>tolg</code> Tolerance for the gradient of parameters of objective functions. Default is set at 1e-6.
</p>
</li>
<li> <p><code>maxeval</code> The maximum number of evaluation of the optimizer. Default is set at 20.
</p>
</li></ul>



<h3>Value</h3>

<table>
<tr><td><code>structural.par</code></td>
<td>
<p>The structural parameters of the ODE model.</p>
</td></tr>
<tr><td><code>nuisance.par</code></td>
<td>
<p>The nuisance parameters or the basis coefficients for interpolating observations.</p>
</td></tr>
</table>

<hr>
<h2 id='prepare_basis'>Evaluate basis objects over observation times and quadrature points</h2><span id='topic+prepare_basis'></span>

<h3>Description</h3>

<p>Calculate all basis functions over observation time points and store them as columns in a single matrix for each dimension. Also include first and second order derivative. Repeat over quadrature points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_basis(basis, times, nquadpts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare_basis_+3A_basis">basis</code></td>
<td>
<p>A basis object.</p>
</td></tr>
<tr><td><code id="prepare_basis_+3A_times">times</code></td>
<td>
<p>The vector contain observation times for corresponding dimension.</p>
</td></tr>
<tr><td><code id="prepare_basis_+3A_nquadpts">nquadpts</code></td>
<td>
<p>Number of quadrature points will be used later for approximating integrals.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>Phi.mat</code></td>
<td>
<p>Evaluations of all basis functions stored as columns in the matrix.</p>
</td></tr>
<tr><td><code>Qmat</code></td>
<td>
<p>Evaluations of all basis functions over quadrature points stored as columns in the matrix.</p>
</td></tr>
<tr><td><code>Q.D1mat</code></td>
<td>
<p>Evaluations of first order derivative all basis functions over quadrature points stored as columns in the matrix.</p>
</td></tr>
<tr><td><code>Q.D2mat</code></td>
<td>
<p>Evaluations of second order derivative all basis functions over quadrature points stored as columns in the matrix.</p>
</td></tr>
<tr><td><code>quadts</code></td>
<td>
<p>Quadrature points.</p>
</td></tr>
<tr><td><code>quadwts</code></td>
<td>
<p>Quadrature weights.</p>
</td></tr>
</table>

<hr>
<h2 id='tunelambda'>Find optimial penalty parameter lambda by cross-validation.</h2><span id='topic+tunelambda'></span>

<h3>Description</h3>

<p>Obtain the optimal sparsity parameter given a search grid based on cross validation score with replications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tunelambda(data, time, ode.model, par.names, state.names,
                  par.initial, basis.list,lambda_grid,cv_portion,kfolds, rep,controls)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tunelambda_+3A_data">data</code></td>
<td>
<p>A data frame or matrix contrain observations from each dimension of the ODE model.</p>
</td></tr>
<tr><td><code id="tunelambda_+3A_time">time</code></td>
<td>
<p>The vector contain observation times or a matrix if time points are different between dimensions.</p>
</td></tr>
<tr><td><code id="tunelambda_+3A_ode.model">ode.model</code></td>
<td>
<p>Defined R function that computes the time derivative of the ODE model given observations of states variable.</p>
</td></tr>
<tr><td><code id="tunelambda_+3A_par.names">par.names</code></td>
<td>
<p>The names of structural parameters defined in the 'ode.model'.</p>
</td></tr>
<tr><td><code id="tunelambda_+3A_state.names">state.names</code></td>
<td>
<p>The names of state variables defined in the 'ode.model'.</p>
</td></tr>
<tr><td><code id="tunelambda_+3A_par.initial">par.initial</code></td>
<td>
<p>Initial value of structural parameters to be optimized.</p>
</td></tr>
<tr><td><code id="tunelambda_+3A_basis.list">basis.list</code></td>
<td>
<p>A list of basis objects for smoothing each dimension's observations. Can be the same or different across dimensions.</p>
</td></tr>
<tr><td><code id="tunelambda_+3A_lambda_grid">lambda_grid</code></td>
<td>
<p>A search grid for finding the optimial sparsity parameter lambda.</p>
</td></tr>
<tr><td><code id="tunelambda_+3A_cv_portion">cv_portion</code></td>
<td>
<p>A number indicating the proportion of data will be saved for doing cross validation. Default is set at 5 as minimum.</p>
</td></tr>
<tr><td><code id="tunelambda_+3A_kfolds">kfolds</code></td>
<td>
<p>A number indicating the number of folds the data should be seprated into.</p>
</td></tr>
<tr><td><code id="tunelambda_+3A_rep">rep</code></td>
<td>
<p>A integer controls the number of replication of doing cross-validation for each penalty parameter.</p>
</td></tr>
<tr><td><code id="tunelambda_+3A_controls">controls</code></td>
<td>
<p>A list of control parameters. See ‘Details’.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>lambda_grid</code></td>
<td>
<p>The original input vector of a search grid for the optimal lambda.</p>
</td></tr>
<tr><td><code>cv.score</code></td>
<td>
<p>The matrix contains the cross validation score for each lambda of each replication</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
