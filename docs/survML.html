<!DOCTYPE html><html><head><title>Help for package survML</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {survML}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#stackG'><p>Estimate a conditional survival function using global survival stacking</p></a></li>
<li><a href='#stackL'><p>Estimate a conditional survival function via local survival stacking</p></a></li>
<li><a href='#survML-package'><p>survML: Flexible Estimation of Conditional Survival Functions Using Machine Learning</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Flexible Estimation of Conditional Survival Functions Using
Machine Learning</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for flexible estimation of conditional survival 
              functions using off-the-shelf machine learning tools. Implements both 
              global and local survival stacking. See Wolock CJ, Gilbert PB,
              Simon N, and Carone M (2024) &lt;<a href="https://doi.org/10.1080%2F10618600.2024.2304070">doi:10.1080/10618600.2024.2304070</a>&gt;. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>SuperLearner (&ge; 2.0.28),</td>
</tr>
<tr>
<td>Imports:</td>
<td>Iso (&ge; 0.0.18.1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0), ggplot2 (&ge; 3.4.0),
gam (&ge; 1.22.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/cwolock/survML">https://github.com/cwolock/survML</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/cwolock/survML/issues">https://github.com/cwolock/survML/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-17 01:51:19 UTC; cwolock</td>
</tr>
<tr>
<td>Author:</td>
<td>Charles Wolock <a href="https://orcid.org/0000-0003-3527-1102"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Charles Wolock &lt;cwolock@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-17 05:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='stackG'>Estimate a conditional survival function using global survival stacking</h2><span id='topic+stackG'></span>

<h3>Description</h3>

<p>Estimate a conditional survival function using global survival stacking
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stackG(
  time,
  event = rep(1, length(time)),
  entry = NULL,
  X,
  newX = NULL,
  newtimes = NULL,
  direction = "prospective",
  time_grid_fit = NULL,
  bin_size = NULL,
  time_basis,
  time_grid_approx = sort(unique(time)),
  surv_form = "PI",
  learner = "SuperLearner",
  SL_control = list(SL.library = c("SL.mean"), V = 10, method = "method.NNLS", stratifyCV
    = FALSE),
  tau = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stackG_+3A_time">time</code></td>
<td>
<p><code>n x 1</code> numeric vector of observed
follow-up times If there is censoring, these are the minimum of the
event and censoring times.</p>
</td></tr>
<tr><td><code id="stackG_+3A_event">event</code></td>
<td>
<p><code>n x 1</code> numeric vector of status indicators of
whether an event was observed. Defaults to a vector of 1s, i.e. no censoring.</p>
</td></tr>
<tr><td><code id="stackG_+3A_entry">entry</code></td>
<td>
<p>Study entry variable, if applicable. Defaults to <code>NULL</code>,
indicating that there is no truncation.</p>
</td></tr>
<tr><td><code id="stackG_+3A_x">X</code></td>
<td>
<p><code>n x p</code> data.frame of observed covariate values
on which to train the estimator.</p>
</td></tr>
<tr><td><code id="stackG_+3A_newx">newX</code></td>
<td>
<p><code>m x p</code> data.frame of new observed covariate
values at which to obtain <code>m</code> predictions for the estimated algorithm.
Must have the same names and structure as <code>X</code>.</p>
</td></tr>
<tr><td><code id="stackG_+3A_newtimes">newtimes</code></td>
<td>
<p><code>k x 1</code> numeric vector of times at which to obtain <code>k</code>
predicted conditional survivals.</p>
</td></tr>
<tr><td><code id="stackG_+3A_direction">direction</code></td>
<td>
<p>Whether the data come from a prospective or retrospective study.
This determines whether the data are treated as subject to left truncation and
right censoring (<code>"prospective"</code>) or right truncation alone
(<code>"retrospective"</code>).</p>
</td></tr>
<tr><td><code id="stackG_+3A_time_grid_fit">time_grid_fit</code></td>
<td>
<p>Named list of numeric vectors of times of times on which to discretize
for estimation of cumulative probability functions. This is an alternative to
<code>bin_size</code> and allows for specially tailored time grids rather than simply
using a quantile bin size. The list consists of vectors named
<code>F_Y_1_grid</code>, <code>F_Y_0_grid</code>, <code>G_W_1_grid</code>, and <code>G_W_0_grid</code>. These denote,
respectively, the grids used to estimate the conditional CDF of the <code>time</code> variable
among uncensored and censored observations, and the grids used to estimate the conditional
distribution of the <code>entry</code> variable among uncensored and censored observations.</p>
</td></tr>
<tr><td><code id="stackG_+3A_bin_size">bin_size</code></td>
<td>
<p>Size of time bin on which to discretize for estimation
of cumulative probability functions. Can be a number between 0 and 1,
indicating the size of quantile grid (e.g. <code>0.1</code> estimates
the cumulative probability functions on a grid based on deciles of
observed <code>time</code>s). If <code>NULL</code>, creates a grid of
all observed <code>time</code>s.</p>
</td></tr>
<tr><td><code id="stackG_+3A_time_basis">time_basis</code></td>
<td>
<p>How to treat time for training the binary
classifier. Options are <code>"continuous"</code> and <code>"dummy"</code>, meaning
an indicator variable is included for each time in the time grid.</p>
</td></tr>
<tr><td><code id="stackG_+3A_time_grid_approx">time_grid_approx</code></td>
<td>
<p>Numeric vector of times at which to
approximate product integral or cumulative hazard interval.
Defaults to <code>times</code> argument.</p>
</td></tr>
<tr><td><code id="stackG_+3A_surv_form">surv_form</code></td>
<td>
<p>Mapping from hazard estimate to survival estimate.
Can be either <code>"PI"</code> (product integral mapping) or <code>"exp"</code>
(exponentiated cumulative hazard estimate).</p>
</td></tr>
<tr><td><code id="stackG_+3A_learner">learner</code></td>
<td>
<p>Which binary regression algorithm to use. Currently, only
<code>SuperLearner</code> is supported, but more learners will be added.
See below for algorithm-specific arguments.</p>
</td></tr>
<tr><td><code id="stackG_+3A_sl_control">SL_control</code></td>
<td>
<p>Named list of parameters controlling the Super Learner fitting
process. These parameters are passed directly to the <code>SuperLearner</code> function.
Parameters include <code>SL.library</code> (library of algorithms to include in the
binary classification Super Learner), <code>V</code> (Number of cross validation folds on
which to train the Super Learner classifier, defaults to 10), <code>method</code> (Method for
estimating coefficients for the Super Learner, defaults to <code>"method.NNLS"</code>), <code>stratifyCV</code>
(logical indicating whether to stratify by outcome in <code>SuperLearner</code>'s cross-validation
scheme), and <code>obsWeights</code>
(observation weights, passed directly to prediction algorithms by <code>SuperLearner</code>).</p>
</td></tr>
<tr><td><code id="stackG_+3A_tau">tau</code></td>
<td>
<p>The maximum time of interest in a study, used for
retrospective conditional survival estimation. Rather than dealing
with right truncation separately than left truncation, it is simpler to
estimate the survival function of <code>tau - time</code>. Defaults to <code>NULL</code>,
in which case the maximum study entry time is chosen as the
reference point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of class <code>stackG</code>, with the following components:
</p>
<table>
<tr><td><code>S_T_preds</code></td>
<td>
<p>An <code>m x k</code> matrix of estimated event time survival probabilities at the
<code>m</code> covariate vector values and <code>k</code> times provided by the user in
<code>newX</code> and <code>newtimes</code>, respectively.</p>
</td></tr>
<tr><td><code>S_C_preds</code></td>
<td>
<p>An <code>m x k</code> matrix of estimated censoring time survival probabilities at the
<code>m</code> covariate vector values and <code>k</code> times provided by the user in
<code>newX</code> and <code>newtimes</code>, respectively.</p>
</td></tr>
<tr><td><code>time_grid_approx</code></td>
<td>
<p>The approximation grid for the product integral or cumulative hazard integral,
(user-specified).</p>
</td></tr>
<tr><td><code>direction</code></td>
<td>
<p>Whether the data come from a prospective or retrospective study (user-specified).</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p>The maximum time of interest in a study, used for
retrospective conditional survival estimation (user-specified).</p>
</td></tr>
<tr><td><code>surv_form</code></td>
<td>
<p>Exponential or product-integral form (user-specified).</p>
</td></tr>
<tr><td><code>time_basis</code></td>
<td>
<p>Whether time is included in the regression as <code>continuous</code> or
<code>dummy</code> (user-specified).</p>
</td></tr>
<tr><td><code>SL_control</code></td>
<td>
<p>Named list of parameters controlling the Super Learner fitting
process (user-specified).</p>
</td></tr>
<tr><td><code>fits</code></td>
<td>
<p>A named list of fitted regression objects corresponding to the constituent regressions needed for
global survival stacking. Includes <code>P_Delta</code> (probability of event given covariates),
<code>F_Y_1</code> (conditional cdf of follow-up times given covariates among uncensored),
<code>F_Y_0</code> (conditional cdf of follow-up times given covariates among censored),
<code>G_W_1</code> (conditional distribution of entry times given covariates and follow-up time among uncensored),
<code>G_W_0</code> (conditional distribution of entry times given covariates and follow-up time among uncensored).
Each of these objects includes estimated coefficients from the <code>SuperLearner</code> fit, as well as the
time grid used to create the stacked dataset (where applicable).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Wolock C.J., Gilbert P.B., Simon N., and Carone, M. (2022).
&quot;A framework for leveraging machine learning tools to estimate personalized survival curves.&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# This is a small simulation example
set.seed(123)
n &lt;- 500
X &lt;- data.frame(X1 = rnorm(n), X2 = rbinom(n, size = 1, prob = 0.5))

S0 &lt;- function(t, x){
  pexp(t, rate = exp(-2 + x[,1] - x[,2] + .5 * x[,1] * x[,2]), lower.tail = FALSE)
}
T &lt;- rexp(n, rate = exp(-2 + X[,1] - X[,2] + .5 *  X[,1] * X[,2]))

G0 &lt;- function(t, x) {
  as.numeric(t &lt; 15) *.9*pexp(t,
                              rate = exp(-2 -.5*x[,1]-.25*x[,2]+.5*x[,1]*x[,2]),
                              lower.tail=FALSE)
}
C &lt;- rexp(n, exp(-2 -.5 * X[,1] - .25 * X[,2] + .5 * X[,1] * X[,2]))
C[C &gt; 15] &lt;- 15

entry &lt;- runif(n, 0, 15)

time &lt;- pmin(T, C)
event &lt;- as.numeric(T &lt;= C)

sampled &lt;- which(time &gt;= entry)
X &lt;- X[sampled,]
time &lt;- time[sampled]
event &lt;- event[sampled]
entry &lt;- entry[sampled]

# Note that this a very small Super Learner library, for computational purposes.
SL.library &lt;- c("SL.mean", "SL.glm")

fit &lt;- stackG(time = time,
              event = event,
              entry = entry,
              X = X,
              newX = X,
              newtimes = seq(0, 15, .1),
              direction = "prospective",
              bin_size = 0.1,
              time_basis = "continuous",
              time_grid_approx = sort(unique(time)),
              surv_form = "exp",
              learner = "SuperLearner",
              SL_control = list(SL.library = SL.library,
                                V = 5))

plot(fit$S_T_preds[1,], S0(t =  seq(0, 15, .1), X[1,]))
abline(0,1,col='red')

</code></pre>

<hr>
<h2 id='stackL'>Estimate a conditional survival function via local survival stacking</h2><span id='topic+stackL'></span>

<h3>Description</h3>

<p>Estimate a conditional survival function via local survival stacking
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stackL(
  time,
  event = rep(1, length(time)),
  entry = NULL,
  X,
  newX,
  newtimes,
  direction = "prospective",
  bin_size = NULL,
  time_basis = "continuous",
  learner = "SuperLearner",
  SL_control = list(SL.library = c("SL.mean"), V = 10, method = "method.NNLS", stratifyCV
    = FALSE),
  tau = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stackL_+3A_time">time</code></td>
<td>
<p><code>n x 1</code> numeric vector of observed
follow-up times If there is censoring, these are the minimum of the
event and censoring times.</p>
</td></tr>
<tr><td><code id="stackL_+3A_event">event</code></td>
<td>
<p><code>n x 1</code> numeric vector of status indicators of
whether an event was observed. Defaults to a vector of 1s, i.e. no censoring.</p>
</td></tr>
<tr><td><code id="stackL_+3A_entry">entry</code></td>
<td>
<p>Study entry variable, if applicable. Defaults to <code>NULL</code>,
indicating that there is no truncation.</p>
</td></tr>
<tr><td><code id="stackL_+3A_x">X</code></td>
<td>
<p><code>n x p</code> data.frame of observed covariate values
on which to train the estimator.</p>
</td></tr>
<tr><td><code id="stackL_+3A_newx">newX</code></td>
<td>
<p><code>m x p</code> data.frame of new observed covariate
values at which to obtain <code>m</code> predictions for the estimated algorithm.
Must have the same names and structure as <code>X</code>.</p>
</td></tr>
<tr><td><code id="stackL_+3A_newtimes">newtimes</code></td>
<td>
<p><code>k x 1</code> numeric vector of times at which to obtain <code>k</code>
predicted conditional survivals.</p>
</td></tr>
<tr><td><code id="stackL_+3A_direction">direction</code></td>
<td>
<p>Whether the data come from a prospective or retrospective study.
This determines whether the data are treated as subject to left truncation and
right censoring (<code>"prospective"</code>) or right truncation alone
(<code>"retrospective"</code>).</p>
</td></tr>
<tr><td><code id="stackL_+3A_bin_size">bin_size</code></td>
<td>
<p>Size of bins for the discretization of time.
A value between 0 and 1 indicating the size of observed event time quantiles
on which to grid times (e.g. 0.02 creates a grid of 50 times evenly spaced on the
quantile scaled). If NULL, defaults to every observed event time.</p>
</td></tr>
<tr><td><code id="stackL_+3A_time_basis">time_basis</code></td>
<td>
<p>How to treat time for training the binary
classifier. Options are <code>"continuous"</code> and <code>"dummy"</code>, meaning
an indicator variable is included for each time in the time grid.</p>
</td></tr>
<tr><td><code id="stackL_+3A_learner">learner</code></td>
<td>
<p>Which binary regression algorithm to use. Currently, only
<code>SuperLearner</code> is supported, but more learners will be added.
See below for algorithm-specific arguments.</p>
</td></tr>
<tr><td><code id="stackL_+3A_sl_control">SL_control</code></td>
<td>
<p>Named list of parameters controlling the Super Learner fitting
process. These parameters are passed directly to the <code>SuperLearner</code> function.
Parameters include <code>SL.library</code> (library of algorithms to include in the
binary classification Super Learner), <code>V</code> (Number of cross validation folds on
which to train the Super Learner classifier, defaults to 10), <code>method</code> (Method for
estimating coefficients for the Super Learner, defaults to <code>"method.NNLS"</code>),
<code>stratifyCV</code> (logical indicating whether to stratify by outcome in <code>SuperLearner</code>'s cross-validation
scheme), and <code>obsWeights</code>
(observation weights, passed directly to prediction algorithms by <code>SuperLearner</code>).</p>
</td></tr>
<tr><td><code id="stackL_+3A_tau">tau</code></td>
<td>
<p>The maximum time of interest in a study, used for
retrospective conditional survival estimation. Rather than dealing
with right truncation separately than left truncation, it is simpler to
estimate the survival function of <code>tau - time</code>. Defaults to <code>NULL</code>,
in which case the maximum study entry time is chosen as the
reference point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of class <code>stackL</code>.
</p>
<table>
<tr><td><code>S_T_preds</code></td>
<td>
<p>An <code>m x k</code> matrix of estimated event time survival probabilities at the
<code>m</code> covariate vector values and <code>k</code> times provided by the user in
<code>newX</code> and <code>newtimes</code>, respectively.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>The Super Learner fit for binary classification on the stacked
dataset.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Polley E.C. and van der Laan M.J. (2011).
&quot;Super Learning for Right-Censored Data&quot; in Targeted Learning.
</p>
<p>Craig E., Zhong C., and Tibshirani R. (2021).
&quot;Survival stacking: casting survival analysis as a classification problem.&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# This is a small simulation example
set.seed(123)
n &lt;- 500
X &lt;- data.frame(X1 = rnorm(n), X2 = rbinom(n, size = 1, prob = 0.5))

S0 &lt;- function(t, x){
  pexp(t, rate = exp(-2 + x[,1] - x[,2] + .5 * x[,1] * x[,2]), lower.tail = FALSE)
}
T &lt;- rexp(n, rate = exp(-2 + X[,1] - X[,2] + .5 *  X[,1] * X[,2]))

G0 &lt;- function(t, x) {
  as.numeric(t &lt; 15) *.9*pexp(t,
                              rate = exp(-2 -.5*x[,1]-.25*x[,2]+.5*x[,1]*x[,2]),
                              lower.tail=FALSE)
}
C &lt;- rexp(n, exp(-2 -.5 * X[,1] - .25 * X[,2] + .5 * X[,1] * X[,2]))
C[C &gt; 15] &lt;- 15

entry &lt;- runif(n, 0, 15)

time &lt;- pmin(T, C)
event &lt;- as.numeric(T &lt;= C)

sampled &lt;- which(time &gt;= entry)
X &lt;- X[sampled,]
time &lt;- time[sampled]
event &lt;- event[sampled]
entry &lt;- entry[sampled]

# Note that this a very small Super Learner library, for computational purposes.
SL.library &lt;- c("SL.mean", "SL.glm")

fit &lt;- stackL(time = time,
               event = event,
               entry = entry,
               X = X,
               newX = X,
               newtimes = seq(0, 15, .1),
               direction = "prospective",
               bin_size = 0.1,
               time_basis = "continuous",
               SL_control = list(SL.library = SL.library,
                                 V = 5))

plot(fit$S_T_preds[1,], S0(t =  seq(0, 15, .1), X[1,]))
abline(0,1,col='red')

</code></pre>

<hr>
<h2 id='survML-package'>survML: Flexible Estimation of Conditional Survival Functions Using Machine Learning</h2><span id='topic+survML'></span><span id='topic+survML-package'></span>

<h3>Description</h3>

<p>Tools for flexible estimation of conditional survival functions using off-the-shelf machine learning tools. Implements both global and local survival stacking. See Wolock CJ, Gilbert PB, Simon N, and Carone M (2024) <a href="https://doi.org/10.1080/10618600.2024.2304070">doi:10.1080/10618600.2024.2304070</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Charles Wolock <a href="mailto:cwolock@gmail.com">cwolock@gmail.com</a> (<a href="https://orcid.org/0000-0003-3527-1102">ORCID</a>) [copyright holder]
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/cwolock/survML">https://github.com/cwolock/survML</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/cwolock/survML/issues">https://github.com/cwolock/survML/issues</a>
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
