<!DOCTYPE html><html lang="en"><head><title>Help for package survML</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {survML}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#survML-package'><p>survML: Tools for Flexible Survival Analysis Using Machine Learning</p></a></li>
<li><a href='#crossfit_oracle_preds'><p>Generate cross-fitted oracle prediction function estimates</p></a></li>
<li><a href='#crossfit_surv_preds'><p>Generate cross-fitted conditional survival predictions</p></a></li>
<li><a href='#currstatCIR'><p>Estimate a survival function under current status sampling</p></a></li>
<li><a href='#DR_pseudo_outcome_regression'><p>Generate oracle prediction function estimates using doubly-robust pseudo-outcome regression with SuperLearner</p></a></li>
<li><a href='#generate_folds'><p>Generate cross-fitting and sample-splitting folds</p></a></li>
<li><a href='#predict.stackG'><p>Obtain predicted conditional survival and cumulative hazard functions from a global survival stacking object</p></a></li>
<li><a href='#predict.stackL'><p>Obtain predicted conditional survival function from a local survival stacking object</p></a></li>
<li><a href='#stackG'><p>Estimate a conditional survival function using global survival stacking</p></a></li>
<li><a href='#stackL'><p>Estimate a conditional survival function via local survival stacking</p></a></li>
<li><a href='#vim'><p>Estimate AUC VIM</p></a></li>
<li><a href='#vim_accuracy'><p>Estimate classification accuracy VIM</p></a></li>
<li><a href='#vim_AUC'><p>Estimate AUC VIM</p></a></li>
<li><a href='#vim_brier'><p>Estimate Brier score VIM</p></a></li>
<li><a href='#vim_cindex'><p>Estimate concordance index VIM</p></a></li>
<li><a href='#vim_rsquared'><p>Estimate R-squared (proportion of explained variance) VIM based on event occurrence by a landmark time</p></a></li>
<li><a href='#vim_survival_time_mse'><p>Estimate restricted predicted survival time MSE VIM</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Tools for Flexible Survival Analysis Using Machine Learning</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Statistical tools for analyzing time-to-event data using
             machine learning. Implements survival stacking for conditional 
             survival estimation, standardized survival function estimation for 
             current status data, and methods for algorithm-agnostic variable
             importance. See Wolock CJ, Gilbert PB, Simon N, 
             and Carone M (2024) &lt;<a href="https://doi.org/10.1080%2F10618600.2024.2304070">doi:10.1080/10618600.2024.2304070</a>&gt;. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>SuperLearner (&ge; 2.0.28),</td>
</tr>
<tr>
<td>Imports:</td>
<td>Iso (&ge; 0.0.18.1), haldensify (&ge; 0.2.3), fdrtool (&ge; 1.2.17),
ChernoffDist (&ge; 0.1.0), dplyr (&ge; 1.0.10), gtools (&ge; 3.9.5),
mboost (&ge; 2.9.0), survival (&ge; 3.5.0), stats (&ge; 4.3.2),
methods (&ge; 4.3.2)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0), ggplot2 (&ge; 3.4.0),
gam (&ge; 1.22.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/cwolock/survML">https://github.com/cwolock/survML</a>,
<a href="https://cwolock.github.io/survML/">https://cwolock.github.io/survML/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/cwolock/survML/issues">https://github.com/cwolock/survML/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-30 22:52:17 UTC; cwolock</td>
</tr>
<tr>
<td>Author:</td>
<td>Charles Wolock <a href="https://orcid.org/0000-0003-3527-1102"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Avi Kenny <a href="https://orcid.org/0000-0002-9465-7307"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Charles Wolock &lt;cwolock@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-31 00:20:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='survML-package'>survML: Tools for Flexible Survival Analysis Using Machine Learning</h2><span id='topic+survML'></span><span id='topic+survML-package'></span>

<h3>Description</h3>

<p>Statistical tools for analyzing time-to-event data using machine learning. Implements survival stacking for conditional survival estimation, standardized survival function estimation for current status data, and methods for algorithm-agnostic variable importance. See Wolock CJ, Gilbert PB, Simon N, and Carone M (2024) <a href="https://doi.org/10.1080/10618600.2024.2304070">doi:10.1080/10618600.2024.2304070</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Charles Wolock <a href="mailto:cwolock@gmail.com">cwolock@gmail.com</a> (<a href="https://orcid.org/0000-0003-3527-1102">ORCID</a>) [copyright holder]
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Avi Kenny <a href="mailto:avi.kenny@gmail.com">avi.kenny@gmail.com</a> (<a href="https://orcid.org/0000-0002-9465-7307">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/cwolock/survML">https://github.com/cwolock/survML</a>
</p>
</li>
<li> <p><a href="https://cwolock.github.io/survML/">https://cwolock.github.io/survML/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/cwolock/survML/issues">https://github.com/cwolock/survML/issues</a>
</p>
</li></ul>


<hr>
<h2 id='crossfit_oracle_preds'>Generate cross-fitted oracle prediction function estimates</h2><span id='topic+crossfit_oracle_preds'></span>

<h3>Description</h3>

<p>Generate cross-fitted oracle prediction function estimates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crossfit_oracle_preds(
  time,
  event,
  X,
  folds,
  nuisance_preds,
  pred_generator,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crossfit_oracle_preds_+3A_time">time</code></td>
<td>
<p><code>n x 1</code> numeric vector of observed
follow-up times. If there is censoring, these are the minimum of the
event and censoring times.</p>
</td></tr>
<tr><td><code id="crossfit_oracle_preds_+3A_event">event</code></td>
<td>
<p><code>n x 1</code> numeric vector of status indicators of
whether an event was observed.</p>
</td></tr>
<tr><td><code id="crossfit_oracle_preds_+3A_x">X</code></td>
<td>
<p><code>n x p</code> data.frame of observed covariate values</p>
</td></tr>
<tr><td><code id="crossfit_oracle_preds_+3A_folds">folds</code></td>
<td>
<p><code>n x 1</code> numeric vector of folds identifiers for cross-fitting</p>
</td></tr>
<tr><td><code id="crossfit_oracle_preds_+3A_nuisance_preds">nuisance_preds</code></td>
<td>
<p>Named list of conditional event and censoring survival functions
that will be used to estimate the oracle prediction function.</p>
</td></tr>
<tr><td><code id="crossfit_oracle_preds_+3A_pred_generator">pred_generator</code></td>
<td>
<p>Function to be used to estimate oracle prediction function.</p>
</td></tr>
<tr><td><code id="crossfit_oracle_preds_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>pred_generator</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named list of cross-fitted oracle prediction estimates
</p>

<hr>
<h2 id='crossfit_surv_preds'>Generate cross-fitted conditional survival predictions</h2><span id='topic+crossfit_surv_preds'></span>

<h3>Description</h3>

<p>Generate cross-fitted conditional survival predictions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crossfit_surv_preds(time, event, X, newtimes, folds, pred_generator, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crossfit_surv_preds_+3A_time">time</code></td>
<td>
<p><code>n x 1</code> numeric vector of observed
follow-up times. If there is censoring, these are the minimum of the
event and censoring times.</p>
</td></tr>
<tr><td><code id="crossfit_surv_preds_+3A_event">event</code></td>
<td>
<p><code>n x 1</code> numeric vector of status indicators of
whether an event was observed.</p>
</td></tr>
<tr><td><code id="crossfit_surv_preds_+3A_x">X</code></td>
<td>
<p><code>n x p</code> data.frame of observed covariate values</p>
</td></tr>
<tr><td><code id="crossfit_surv_preds_+3A_newtimes">newtimes</code></td>
<td>
<p>Numeric vector of times on which to estimate the conditional survival functions</p>
</td></tr>
<tr><td><code id="crossfit_surv_preds_+3A_folds">folds</code></td>
<td>
<p><code>n x 1</code> numeric vector of folds identifiers for cross-fitting</p>
</td></tr>
<tr><td><code id="crossfit_surv_preds_+3A_pred_generator">pred_generator</code></td>
<td>
<p>Function to be used to estimate conditional survival function.</p>
</td></tr>
<tr><td><code id="crossfit_surv_preds_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>pred_generator</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named list of cross-fitted conditional survival predictions
</p>

<hr>
<h2 id='currstatCIR'>Estimate a survival function under current status sampling</h2><span id='topic+currstatCIR'></span>

<h3>Description</h3>

<p>Estimate a survival function under current status sampling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>currstatCIR(
  time,
  event,
  X,
  SL_control = list(SL.library = c("SL.mean", "SL.glm"), V = 3),
  HAL_control = list(n_bins = c(5), grid_type = c("equal_mass"), V = 3),
  deriv_method = "m-spline",
  eval_region,
  n_eval_pts = 101,
  alpha = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="currstatCIR_+3A_time">time</code></td>
<td>
<p><code>n x 1</code> numeric vector of observed monitoring times. For individuals that were never
monitored, this can be set to any arbitrary value, including <code>NA</code>, as long as the corresponding
<code>event</code> variable is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="currstatCIR_+3A_event">event</code></td>
<td>
<p><code>n x 1</code> numeric vector of status indicators of
whether an event was observed prior to the monitoring time. This value must be <code>NA</code> for
individuals that were never monitored.</p>
</td></tr>
<tr><td><code id="currstatCIR_+3A_x">X</code></td>
<td>
<p><code>n x p</code> dataframe of observed covariate values.</p>
</td></tr>
<tr><td><code id="currstatCIR_+3A_sl_control">SL_control</code></td>
<td>
<p>List of <code>SuperLearner</code> control parameters. This should be a named list; see
<code>SuperLearner</code> documentation for further information.</p>
</td></tr>
<tr><td><code id="currstatCIR_+3A_hal_control">HAL_control</code></td>
<td>
<p>List of <code>haldensify</code> control parameters. This should be a named list; see
<code>haldensify</code> documentation for further information.</p>
</td></tr>
<tr><td><code id="currstatCIR_+3A_deriv_method">deriv_method</code></td>
<td>
<p>Method for computing derivative. Options are <code>"m-spline"</code> (the default,
fit a smoothing spline to the estimated function and differentiate the smooth approximation),
<code>"linear"</code> (linearly interpolate the estimated function and use the slope of that line), and
<code>"line"</code> (use the slope of the line connecting the endpoints of the estimated function).</p>
</td></tr>
<tr><td><code id="currstatCIR_+3A_eval_region">eval_region</code></td>
<td>
<p>Region over which to estimate the survival function.</p>
</td></tr>
<tr><td><code id="currstatCIR_+3A_n_eval_pts">n_eval_pts</code></td>
<td>
<p>Number of points in grid on which to evaluate survival function.
The points will be evenly spaced, on the quantile scale, between the endpoints of <code>eval_region</code>.</p>
</td></tr>
<tr><td><code id="currstatCIR_+3A_alpha">alpha</code></td>
<td>
<p>The level at which to compute confidence intervals and hypothesis tests. Defaults to 0.05</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame giving results, with columns:
</p>
<table role = "presentation">
<tr><td><code>t</code></td>
<td>
<p>Time at which survival function is estimated</p>
</td></tr>
<tr><td><code>S_hat_est</code></td>
<td>
<p>Survival function estimate</p>
</td></tr>
<tr><td><code>S_hat_cil</code></td>
<td>
<p>Lower bound of confidence interval</p>
</td></tr>
<tr><td><code>S_hat_ciu</code></td>
<td>
<p>Upper bound of confidence interval</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: # This is a small simulation example
set.seed(123)
n &lt;- 300
x &lt;- cbind(2*rbinom(n, size = 1, prob = 0.5)-1,
           2*rbinom(n, size = 1, prob = 0.5)-1)
t &lt;- rweibull(n,
              shape = 0.75,
              scale = exp(0.4*x[,1] - 0.2*x[,2]))
y &lt;- rweibull(n,
              shape = 0.75,
              scale = exp(0.4*x[,1] - 0.2*x[,2]))

# round y to nearest quantile of y, just so there aren't so many unique values
quants &lt;- quantile(y, probs = seq(0, 1, by = 0.05), type = 1)
for (i in 1:length(y)){
  y[i] &lt;- quants[which.min(abs(y[i] - quants))]
}
delta &lt;- as.numeric(t &lt;= y)

dat &lt;- data.frame(y = y, delta = delta, x1 = x[,1], x2 = x[,2])

dat$delta[dat$y &gt; 1.8] &lt;- NA
dat$y[dat$y &gt; 1.8] &lt;- NA
eval_region &lt;- c(0.05, 1.5)
res &lt;- survML::currstatCIR(time = dat$y,
                           event = dat$delta,
                           X = dat[,3:4],
                           SL_control = list(SL.library = c("SL.mean", "SL.glm"),
                                             V = 3),
                           HAL_control = list(n_bins = c(5),
                                              grid_type = c("equal_mass"),
                                              V = 3),
                           eval_region = eval_region)

xvals = res$t
yvals = res$S_hat_est
fn=stepfun(xvals, c(yvals[1], yvals))
plot.function(fn, from=min(xvals), to=max(xvals))
## End(Not run)

</code></pre>

<hr>
<h2 id='DR_pseudo_outcome_regression'>Generate oracle prediction function estimates using doubly-robust pseudo-outcome regression with SuperLearner</h2><span id='topic+DR_pseudo_outcome_regression'></span>

<h3>Description</h3>

<p>Generate oracle prediction function estimates using doubly-robust pseudo-outcome regression with SuperLearner
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DR_pseudo_outcome_regression(
  time,
  event,
  X,
  newX,
  approx_times,
  S_hat,
  G_hat,
  newtimes,
  outcome,
  SL.library,
  V
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DR_pseudo_outcome_regression_+3A_time">time</code></td>
<td>
<p><code>n x 1</code> numeric vector of observed
follow-up times. If there is censoring, these are the minimum of the
event and censoring times.</p>
</td></tr>
<tr><td><code id="DR_pseudo_outcome_regression_+3A_event">event</code></td>
<td>
<p><code>n x 1</code> numeric vector of status indicators of
whether an event was observed.</p>
</td></tr>
<tr><td><code id="DR_pseudo_outcome_regression_+3A_x">X</code></td>
<td>
<p><code>n x p</code> data.frame of observed covariate values</p>
</td></tr>
<tr><td><code id="DR_pseudo_outcome_regression_+3A_newx">newX</code></td>
<td>
<p><code>m x p</code> data.frame of new observed covariate
values at which to obtain <code>m</code> predictions for the estimated algorithm.
Must have the same names and structure as <code>X</code>.</p>
</td></tr>
<tr><td><code id="DR_pseudo_outcome_regression_+3A_approx_times">approx_times</code></td>
<td>
<p>Numeric vector of length J2 giving times at which to
approximate integral appearing in the pseudo-outcomes</p>
</td></tr>
<tr><td><code id="DR_pseudo_outcome_regression_+3A_s_hat">S_hat</code></td>
<td>
<p><code>n x J2</code> matrix of conditional event time survival function estimates</p>
</td></tr>
<tr><td><code id="DR_pseudo_outcome_regression_+3A_g_hat">G_hat</code></td>
<td>
<p><code>n x J2</code> matrix of conditional censoring time survival function estimates</p>
</td></tr>
<tr><td><code id="DR_pseudo_outcome_regression_+3A_newtimes">newtimes</code></td>
<td>
<p>Numeric vector of times at which to generate oracle prediction function estimates</p>
</td></tr>
<tr><td><code id="DR_pseudo_outcome_regression_+3A_outcome">outcome</code></td>
<td>
<p>Outcome type, either <code>"survival_probability"</code> or <code>"restricted_survival_time"</code></p>
</td></tr>
<tr><td><code id="DR_pseudo_outcome_regression_+3A_sl.library">SL.library</code></td>
<td>
<p>Super Learner library</p>
</td></tr>
<tr><td><code id="DR_pseudo_outcome_regression_+3A_v">V</code></td>
<td>
<p>Number of cross-validation folds, to be passed to <code>SuperLearner</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of predictions.
</p>

<hr>
<h2 id='generate_folds'>Generate cross-fitting and sample-splitting folds</h2><span id='topic+generate_folds'></span>

<h3>Description</h3>

<p>Generate cross-fitting and sample-splitting folds
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_folds(n, V, sample_split)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_folds_+3A_n">n</code></td>
<td>
<p>Total sample size</p>
</td></tr>
<tr><td><code id="generate_folds_+3A_v">V</code></td>
<td>
<p>Number of cross-fitting folds to use</p>
</td></tr>
<tr><td><code id="generate_folds_+3A_sample_split">sample_split</code></td>
<td>
<p>Logical, whether or not sample-splitting is being used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named list of cross-fitting and sample-splitting folds
</p>

<hr>
<h2 id='predict.stackG'>Obtain predicted conditional survival and cumulative hazard functions from a global survival stacking object</h2><span id='topic+predict.stackG'></span>

<h3>Description</h3>

<p>Obtain predicted conditional survival and cumulative hazard functions from a global survival stacking object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stackG'
predict(
  object,
  newX,
  newtimes,
  surv_form = object$surv_form,
  time_grid_approx = object$time_grid_approx,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.stackG_+3A_object">object</code></td>
<td>
<p>Object of class <code>stackG</code></p>
</td></tr>
<tr><td><code id="predict.stackG_+3A_newx">newX</code></td>
<td>
<p><code>m x p</code> data.frame of new observed covariate
values at which to obtain <code>m</code> predictions for the estimated algorithm.
Must have the same names and structure as <code>X</code>.</p>
</td></tr>
<tr><td><code id="predict.stackG_+3A_newtimes">newtimes</code></td>
<td>
<p><code>k x 1</code> numeric vector of times at which to obtain <code>k</code>
predicted conditional survivals.</p>
</td></tr>
<tr><td><code id="predict.stackG_+3A_surv_form">surv_form</code></td>
<td>
<p>Mapping from hazard estimate to survival estimate.
Can be either <code>"PI"</code> (product integral mapping) or <code>"exp"</code>
(exponentiated cumulative hazard estimate). Defaults to the value
saved in <code>object</code>.</p>
</td></tr>
<tr><td><code id="predict.stackG_+3A_time_grid_approx">time_grid_approx</code></td>
<td>
<p>Numeric vector of times at which to
approximate product integral or cumulative hazard interval. Defaults to the value
saved in <code>object</code>.</p>
</td></tr>
<tr><td><code id="predict.stackG_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with the following components:
</p>
<table role = "presentation">
<tr><td><code>S_T_preds</code></td>
<td>
<p>An <code>m x k</code> matrix of estimated event time survival probabilities at the
<code>m</code> covariate vector values and <code>k</code> times provided by the user in
<code>newX</code> and <code>newtimes</code>, respectively.</p>
</td></tr>
<tr><td><code>S_C_preds</code></td>
<td>
<p>An <code>m x k</code> matrix of estimated censoring time survival probabilities at the
<code>m</code> covariate vector values and <code>k</code> times provided by the user in
<code>newX</code> and <code>newtimes</code>, respectively.</p>
</td></tr>
<tr><td><code>Lambda_T_preds</code></td>
<td>
<p>An <code>m x k</code> matrix of estimated event time cumulative hazard function values at the
<code>m</code> covariate vector values and <code>k</code> times provided by the user in
<code>newX</code> and <code>newtimes</code>, respectively.</p>
</td></tr>
<tr><td><code>Lambda_C_preds</code></td>
<td>
<p>An <code>m x k</code> matrix of estimated censoring time cumulative hazard function values at the
<code>m</code> covariate vector values and <code>k</code> times provided by the user in
<code>newX</code> and <code>newtimes</code>, respectively.</p>
</td></tr>
<tr><td><code>time_grid_approx</code></td>
<td>
<p>The approximation grid for the product integral or cumulative hazard integral,
(user-specified).</p>
</td></tr>
<tr><td><code>surv_form</code></td>
<td>
<p>Exponential or product-integral form (user-specified).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+stackG">stackG</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# This is a small simulation example
set.seed(123)
n &lt;- 250
X &lt;- data.frame(X1 = rnorm(n), X2 = rbinom(n, size = 1, prob = 0.5))

S0 &lt;- function(t, x){
  pexp(t, rate = exp(-2 + x[,1] - x[,2] + .5 * x[,1] * x[,2]), lower.tail = FALSE)
}
T &lt;- rexp(n, rate = exp(-2 + X[,1] - X[,2] + .5 *  X[,1] * X[,2]))

G0 &lt;- function(t, x) {
  as.numeric(t &lt; 15) *.9*pexp(t,
                              rate = exp(-2 -.5*x[,1]-.25*x[,2]+.5*x[,1]*x[,2]),
                              lower.tail=FALSE)
}
C &lt;- rexp(n, exp(-2 -.5 * X[,1] - .25 * X[,2] + .5 * X[,1] * X[,2]))
C[C &gt; 15] &lt;- 15

entry &lt;- runif(n, 0, 15)

time &lt;- pmin(T, C)
event &lt;- as.numeric(T &lt;= C)

sampled &lt;- which(time &gt;= entry)
X &lt;- X[sampled,]
time &lt;- time[sampled]
event &lt;- event[sampled]
entry &lt;- entry[sampled]

# Note that this a very small Super Learner library, for computational purposes.
SL.library &lt;- c("SL.mean", "SL.glm")

fit &lt;- stackG(time = time,
              event = event,
              entry = entry,
              X = X,
              newX = X,
              newtimes = seq(0, 15, .1),
              direction = "prospective",
              bin_size = 0.1,
              time_basis = "continuous",
              time_grid_approx = sort(unique(time)),
              surv_form = "exp",
              learner = "SuperLearner",
              SL_control = list(SL.library = SL.library,
                                V = 5))

preds &lt;- predict(object = fit,
                 newX = X,
                 newtimes = seq(0, 15, 0.1))

plot(preds$S_T_preds[1,], S0(t =  seq(0, 15, .1), X[1,]))
abline(0,1,col='red')
</code></pre>

<hr>
<h2 id='predict.stackL'>Obtain predicted conditional survival function from a local survival stacking object</h2><span id='topic+predict.stackL'></span>

<h3>Description</h3>

<p>Obtain predicted conditional survival function from a local survival stacking object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stackL'
predict(object, newX, newtimes, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.stackL_+3A_object">object</code></td>
<td>
<p>Object of class <code>stackL</code></p>
</td></tr>
<tr><td><code id="predict.stackL_+3A_newx">newX</code></td>
<td>
<p><code>m x p</code> data.frame of new observed covariate
values at which to obtain <code>m</code> predictions for the estimated algorithm.
Must have the same names and structure as <code>X</code>.</p>
</td></tr>
<tr><td><code id="predict.stackL_+3A_newtimes">newtimes</code></td>
<td>
<p><code>k x 1</code> numeric vector of times at which to obtain <code>k</code>
predicted conditional survivals.</p>
</td></tr>
<tr><td><code id="predict.stackL_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with the following components:
</p>
<table role = "presentation">
<tr><td><code>S_T_preds</code></td>
<td>
<p>An <code>m x k</code> matrix of estimated event time survival probabilities at the
<code>m</code> covariate vector values and <code>k</code> times provided by the user in
<code>newX</code> and <code>newtimes</code>, respectively.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+stackL">stackL</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# This is a small simulation example
set.seed(123)
n &lt;- 500
X &lt;- data.frame(X1 = rnorm(n), X2 = rbinom(n, size = 1, prob = 0.5))

S0 &lt;- function(t, x){
  pexp(t, rate = exp(-2 + x[,1] - x[,2] + .5 * x[,1] * x[,2]), lower.tail = FALSE)
}
T &lt;- rexp(n, rate = exp(-2 + X[,1] - X[,2] + .5 *  X[,1] * X[,2]))

G0 &lt;- function(t, x) {
  as.numeric(t &lt; 15) *.9*pexp(t,
                              rate = exp(-2 -.5*x[,1]-.25*x[,2]+.5*x[,1]*x[,2]),
                              lower.tail=FALSE)
}
C &lt;- rexp(n, exp(-2 -.5 * X[,1] - .25 * X[,2] + .5 * X[,1] * X[,2]))
C[C &gt; 15] &lt;- 15

entry &lt;- runif(n, 0, 15)

time &lt;- pmin(T, C)
event &lt;- as.numeric(T &lt;= C)

sampled &lt;- which(time &gt;= entry)
X &lt;- X[sampled,]
time &lt;- time[sampled]
event &lt;- event[sampled]
entry &lt;- entry[sampled]

# Note that this a very small Super Learner library, for computational purposes.
SL.library &lt;- c("SL.mean", "SL.glm")

fit &lt;- stackL(time = time,
               event = event,
               entry = entry,
               X = X,
               newX = X,
               newtimes = seq(0, 15, .1),
               direction = "prospective",
               bin_size = 0.1,
               time_basis = "continuous",
               SL_control = list(SL.library = SL.library,
                                 V = 5))

preds &lt;- predict(object = fit,
                 newX = X,
                 newtimes = seq(0, 15, 0.1))

plot(preds$S_T_preds[1,], S0(t =  seq(0, 15, .1), X[1,]))
abline(0,1,col='red')
</code></pre>

<hr>
<h2 id='stackG'>Estimate a conditional survival function using global survival stacking</h2><span id='topic+stackG'></span>

<h3>Description</h3>

<p>Estimate a conditional survival function using global survival stacking
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stackG(
  time,
  event = rep(1, length(time)),
  entry = NULL,
  X,
  newX = NULL,
  newtimes = NULL,
  direction = "prospective",
  time_grid_fit = NULL,
  bin_size = NULL,
  time_basis,
  time_grid_approx = sort(unique(time)),
  surv_form = "PI",
  learner = "SuperLearner",
  SL_control = list(SL.library = c("SL.mean"), V = 10, method = "method.NNLS", stratifyCV
    = FALSE),
  tau = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stackG_+3A_time">time</code></td>
<td>
<p><code>n x 1</code> numeric vector of observed
follow-up times If there is censoring, these are the minimum of the
event and censoring times.</p>
</td></tr>
<tr><td><code id="stackG_+3A_event">event</code></td>
<td>
<p><code>n x 1</code> numeric vector of status indicators of
whether an event was observed. Defaults to a vector of 1s, i.e. no censoring.</p>
</td></tr>
<tr><td><code id="stackG_+3A_entry">entry</code></td>
<td>
<p>Study entry variable, if applicable. Defaults to <code>NULL</code>,
indicating that there is no truncation.</p>
</td></tr>
<tr><td><code id="stackG_+3A_x">X</code></td>
<td>
<p><code>n x p</code> data.frame of observed covariate values
on which to train the estimator.</p>
</td></tr>
<tr><td><code id="stackG_+3A_newx">newX</code></td>
<td>
<p><code>m x p</code> data.frame of new observed covariate
values at which to obtain <code>m</code> predictions for the estimated algorithm.
Must have the same names and structure as <code>X</code>.</p>
</td></tr>
<tr><td><code id="stackG_+3A_newtimes">newtimes</code></td>
<td>
<p><code>k x 1</code> numeric vector of times at which to obtain <code>k</code>
predicted conditional survivals.</p>
</td></tr>
<tr><td><code id="stackG_+3A_direction">direction</code></td>
<td>
<p>Whether the data come from a prospective or retrospective study.
This determines whether the data are treated as subject to left truncation and
right censoring (<code>"prospective"</code>) or right truncation alone
(<code>"retrospective"</code>).</p>
</td></tr>
<tr><td><code id="stackG_+3A_time_grid_fit">time_grid_fit</code></td>
<td>
<p>Named list of numeric vectors of times of times on which to discretize
for estimation of cumulative probability functions. This is an alternative to
<code>bin_size</code> and allows for specially tailored time grids rather than simply
using a quantile bin size. The list consists of vectors named
<code>F_Y_1_grid</code>, <code>F_Y_0_grid</code>, <code>G_W_1_grid</code>, and <code>G_W_0_grid</code>. These denote,
respectively, the grids used to estimate the conditional CDF of the <code>time</code> variable
among uncensored and censored observations, and the grids used to estimate the conditional
distribution of the <code>entry</code> variable among uncensored and censored observations.</p>
</td></tr>
<tr><td><code id="stackG_+3A_bin_size">bin_size</code></td>
<td>
<p>Size of time bin on which to discretize for estimation
of cumulative probability functions. Can be a number between 0 and 1,
indicating the size of quantile grid (e.g. <code>0.1</code> estimates
the cumulative probability functions on a grid based on deciles of
observed <code>time</code>s). If <code>NULL</code>, creates a grid of
all observed <code>time</code>s.</p>
</td></tr>
<tr><td><code id="stackG_+3A_time_basis">time_basis</code></td>
<td>
<p>How to treat time for training the binary
classifier. Options are <code>"continuous"</code> and <code>"dummy"</code>, meaning
an indicator variable is included for each time in the time grid.</p>
</td></tr>
<tr><td><code id="stackG_+3A_time_grid_approx">time_grid_approx</code></td>
<td>
<p>Numeric vector of times at which to
approximate product integral or cumulative hazard interval.
Defaults to <code>times</code> argument.</p>
</td></tr>
<tr><td><code id="stackG_+3A_surv_form">surv_form</code></td>
<td>
<p>Mapping from hazard estimate to survival estimate.
Can be either <code>"PI"</code> (product integral mapping) or <code>"exp"</code>
(exponentiated cumulative hazard estimate).</p>
</td></tr>
<tr><td><code id="stackG_+3A_learner">learner</code></td>
<td>
<p>Which binary regression algorithm to use. Currently, only
<code>SuperLearner</code> is supported, but more learners will be added.
See below for algorithm-specific arguments.</p>
</td></tr>
<tr><td><code id="stackG_+3A_sl_control">SL_control</code></td>
<td>
<p>Named list of parameters controlling the Super Learner fitting
process. These parameters are passed directly to the <code>SuperLearner</code> function.
Parameters include <code>SL.library</code> (library of algorithms to include in the
binary classification Super Learner), <code>V</code> (Number of cross validation folds on
which to train the Super Learner classifier, defaults to 10), <code>method</code> (Method for
estimating coefficients for the Super Learner, defaults to <code>"method.NNLS"</code>), <code>stratifyCV</code>
(logical indicating whether to stratify by outcome in <code>SuperLearner</code>'s cross-validation
scheme), and <code>obsWeights</code>
(observation weights, passed directly to prediction algorithms by <code>SuperLearner</code>).</p>
</td></tr>
<tr><td><code id="stackG_+3A_tau">tau</code></td>
<td>
<p>The maximum time of interest in a study, used for
retrospective conditional survival estimation. Rather than dealing
with right truncation separately than left truncation, it is simpler to
estimate the survival function of <code>tau - time</code>. Defaults to <code>NULL</code>,
in which case the maximum study entry time is chosen as the
reference point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of class <code>stackG</code>, with the following components:
</p>
<table role = "presentation">
<tr><td><code>S_T_preds</code></td>
<td>
<p>An <code>m x k</code> matrix of estimated event time survival probabilities at the
<code>m</code> covariate vector values and <code>k</code> times provided by the user in
<code>newX</code> and <code>newtimes</code>, respectively.</p>
</td></tr>
<tr><td><code>S_C_preds</code></td>
<td>
<p>An <code>m x k</code> matrix of estimated censoring time survival probabilities at the
<code>m</code> covariate vector values and <code>k</code> times provided by the user in
<code>newX</code> and <code>newtimes</code>, respectively.</p>
</td></tr>
<tr><td><code>Lambda_T_preds</code></td>
<td>
<p>An <code>m x k</code> matrix of estimated event time cumulative hazard function values at the
<code>m</code> covariate vector values and <code>k</code> times provided by the user in
<code>newX</code> and <code>newtimes</code>, respectively.</p>
</td></tr>
<tr><td><code>Lambda_C_preds</code></td>
<td>
<p>An <code>m x k</code> matrix of estimated censoring time cumulative hazard function values at the
<code>m</code> covariate vector values and <code>k</code> times provided by the user in
<code>newX</code> and <code>newtimes</code>, respectively.</p>
</td></tr>
<tr><td><code>time_grid_approx</code></td>
<td>
<p>The approximation grid for the product integral or cumulative hazard integral,
(user-specified).</p>
</td></tr>
<tr><td><code>direction</code></td>
<td>
<p>Whether the data come from a prospective or retrospective study (user-specified).</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p>The maximum time of interest in a study, used for
retrospective conditional survival estimation (user-specified).</p>
</td></tr>
<tr><td><code>surv_form</code></td>
<td>
<p>Exponential or product-integral form (user-specified).</p>
</td></tr>
<tr><td><code>time_basis</code></td>
<td>
<p>Whether time is included in the regression as <code>continuous</code> or
<code>dummy</code> (user-specified).</p>
</td></tr>
<tr><td><code>SL_control</code></td>
<td>
<p>Named list of parameters controlling the Super Learner fitting
process (user-specified).</p>
</td></tr>
<tr><td><code>fits</code></td>
<td>
<p>A named list of fitted regression objects corresponding to the constituent regressions needed for
global survival stacking. Includes <code>P_Delta</code> (probability of event given covariates),
<code>F_Y_1</code> (conditional cdf of follow-up times given covariates among uncensored),
<code>F_Y_0</code> (conditional cdf of follow-up times given covariates among censored),
<code>G_W_1</code> (conditional distribution of entry times given covariates and follow-up time among uncensored),
<code>G_W_0</code> (conditional distribution of entry times given covariates and follow-up time among uncensored).
Each of these objects includes estimated coefficients from the <code>SuperLearner</code> fit, as well as the
time grid used to create the stacked dataset (where applicable).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Wolock C.J., Gilbert P.B., Simon N., and Carone, M. (2024).
&quot;A framework for leveraging machine learning tools to estimate personalized survival curves.&quot;
</p>


<h3>See Also</h3>

<p><a href="#topic+predict.stackG">predict.stackG</a> for <code>stackG</code> prediction method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This is a small simulation example
set.seed(123)
n &lt;- 250
X &lt;- data.frame(X1 = rnorm(n), X2 = rbinom(n, size = 1, prob = 0.5))

S0 &lt;- function(t, x){
  pexp(t, rate = exp(-2 + x[,1] - x[,2] + .5 * x[,1] * x[,2]), lower.tail = FALSE)
}
T &lt;- rexp(n, rate = exp(-2 + X[,1] - X[,2] + .5 *  X[,1] * X[,2]))

G0 &lt;- function(t, x) {
  as.numeric(t &lt; 15) *.9*pexp(t,
                              rate = exp(-2 -.5*x[,1]-.25*x[,2]+.5*x[,1]*x[,2]),
                              lower.tail=FALSE)
}
C &lt;- rexp(n, exp(-2 -.5 * X[,1] - .25 * X[,2] + .5 * X[,1] * X[,2]))
C[C &gt; 15] &lt;- 15

entry &lt;- runif(n, 0, 15)

time &lt;- pmin(T, C)
event &lt;- as.numeric(T &lt;= C)

sampled &lt;- which(time &gt;= entry)
X &lt;- X[sampled,]
time &lt;- time[sampled]
event &lt;- event[sampled]
entry &lt;- entry[sampled]

# Note that this a very small Super Learner library, for computational purposes.
SL.library &lt;- c("SL.mean", "SL.glm")

fit &lt;- stackG(time = time,
              event = event,
              entry = entry,
              X = X,
              newX = X,
              newtimes = seq(0, 15, .1),
              direction = "prospective",
              bin_size = 0.1,
              time_basis = "continuous",
              time_grid_approx = sort(unique(time)),
              surv_form = "exp",
              learner = "SuperLearner",
              SL_control = list(SL.library = SL.library,
                                V = 5))

plot(fit$S_T_preds[1,], S0(t =  seq(0, 15, .1), X[1,]))
abline(0,1,col='red')

</code></pre>

<hr>
<h2 id='stackL'>Estimate a conditional survival function via local survival stacking</h2><span id='topic+stackL'></span>

<h3>Description</h3>

<p>Estimate a conditional survival function via local survival stacking
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stackL(
  time,
  event = rep(1, length(time)),
  entry = NULL,
  X,
  newX,
  newtimes,
  direction = "prospective",
  bin_size = NULL,
  time_basis = "continuous",
  learner = "SuperLearner",
  SL_control = list(SL.library = c("SL.mean"), V = 10, method = "method.NNLS", stratifyCV
    = FALSE),
  tau = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stackL_+3A_time">time</code></td>
<td>
<p><code>n x 1</code> numeric vector of observed
follow-up times If there is censoring, these are the minimum of the
event and censoring times.</p>
</td></tr>
<tr><td><code id="stackL_+3A_event">event</code></td>
<td>
<p><code>n x 1</code> numeric vector of status indicators of
whether an event was observed. Defaults to a vector of 1s, i.e. no censoring.</p>
</td></tr>
<tr><td><code id="stackL_+3A_entry">entry</code></td>
<td>
<p>Study entry variable, if applicable. Defaults to <code>NULL</code>,
indicating that there is no truncation.</p>
</td></tr>
<tr><td><code id="stackL_+3A_x">X</code></td>
<td>
<p><code>n x p</code> data.frame of observed covariate values
on which to train the estimator.</p>
</td></tr>
<tr><td><code id="stackL_+3A_newx">newX</code></td>
<td>
<p><code>m x p</code> data.frame of new observed covariate
values at which to obtain <code>m</code> predictions for the estimated algorithm.
Must have the same names and structure as <code>X</code>.</p>
</td></tr>
<tr><td><code id="stackL_+3A_newtimes">newtimes</code></td>
<td>
<p><code>k x 1</code> numeric vector of times at which to obtain <code>k</code>
predicted conditional survivals.</p>
</td></tr>
<tr><td><code id="stackL_+3A_direction">direction</code></td>
<td>
<p>Whether the data come from a prospective or retrospective study.
This determines whether the data are treated as subject to left truncation and
right censoring (<code>"prospective"</code>) or right truncation alone
(<code>"retrospective"</code>).</p>
</td></tr>
<tr><td><code id="stackL_+3A_bin_size">bin_size</code></td>
<td>
<p>Size of bins for the discretization of time.
A value between 0 and 1 indicating the size of observed event time quantiles
on which to grid times (e.g. 0.02 creates a grid of 50 times evenly spaced on the
quantile scaled). If NULL, defaults to every observed event time.</p>
</td></tr>
<tr><td><code id="stackL_+3A_time_basis">time_basis</code></td>
<td>
<p>How to treat time for training the binary
classifier. Options are <code>"continuous"</code> and <code>"dummy"</code>, meaning
an indicator variable is included for each time in the time grid.</p>
</td></tr>
<tr><td><code id="stackL_+3A_learner">learner</code></td>
<td>
<p>Which binary regression algorithm to use. Currently, only
<code>SuperLearner</code> is supported, but more learners will be added.
See below for algorithm-specific arguments.</p>
</td></tr>
<tr><td><code id="stackL_+3A_sl_control">SL_control</code></td>
<td>
<p>Named list of parameters controlling the Super Learner fitting
process. These parameters are passed directly to the <code>SuperLearner</code> function.
Parameters include <code>SL.library</code> (library of algorithms to include in the
binary classification Super Learner), <code>V</code> (Number of cross validation folds on
which to train the Super Learner classifier, defaults to 10), <code>method</code> (Method for
estimating coefficients for the Super Learner, defaults to <code>"method.NNLS"</code>),
<code>stratifyCV</code> (logical indicating whether to stratify by outcome in <code>SuperLearner</code>'s cross-validation
scheme), and <code>obsWeights</code>
(observation weights, passed directly to prediction algorithms by <code>SuperLearner</code>).</p>
</td></tr>
<tr><td><code id="stackL_+3A_tau">tau</code></td>
<td>
<p>The maximum time of interest in a study, used for
retrospective conditional survival estimation. Rather than dealing
with right truncation separately than left truncation, it is simpler to
estimate the survival function of <code>tau - time</code>. Defaults to <code>NULL</code>,
in which case the maximum study entry time is chosen as the
reference point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of class <code>stackL</code>.
</p>
<table role = "presentation">
<tr><td><code>S_T_preds</code></td>
<td>
<p>An <code>m x k</code> matrix of estimated event time survival probabilities at the
<code>m</code> covariate vector values and <code>k</code> times provided by the user in
<code>newX</code> and <code>newtimes</code>, respectively.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>The Super Learner fit for binary classification on the stacked
dataset.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Polley E.C. and van der Laan M.J. (2011).
&quot;Super Learning for Right-Censored Data&quot; in Targeted Learning.
</p>
<p>Craig E., Zhong C., and Tibshirani R. (2021).
&quot;Survival stacking: casting survival analysis as a classification problem.&quot;
</p>


<h3>See Also</h3>

<p><a href="#topic+predict.stackL">predict.stackL</a> for <code>stackL</code> prediction method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# This is a small simulation example
set.seed(123)
n &lt;- 500
X &lt;- data.frame(X1 = rnorm(n), X2 = rbinom(n, size = 1, prob = 0.5))

S0 &lt;- function(t, x){
  pexp(t, rate = exp(-2 + x[,1] - x[,2] + .5 * x[,1] * x[,2]), lower.tail = FALSE)
}
T &lt;- rexp(n, rate = exp(-2 + X[,1] - X[,2] + .5 *  X[,1] * X[,2]))

G0 &lt;- function(t, x) {
  as.numeric(t &lt; 15) *.9*pexp(t,
                              rate = exp(-2 -.5*x[,1]-.25*x[,2]+.5*x[,1]*x[,2]),
                              lower.tail=FALSE)
}
C &lt;- rexp(n, exp(-2 -.5 * X[,1] - .25 * X[,2] + .5 * X[,1] * X[,2]))
C[C &gt; 15] &lt;- 15

entry &lt;- runif(n, 0, 15)

time &lt;- pmin(T, C)
event &lt;- as.numeric(T &lt;= C)

sampled &lt;- which(time &gt;= entry)
X &lt;- X[sampled,]
time &lt;- time[sampled]
event &lt;- event[sampled]
entry &lt;- entry[sampled]

# Note that this a very small Super Learner library, for computational purposes.
SL.library &lt;- c("SL.mean", "SL.glm")

fit &lt;- stackL(time = time,
               event = event,
               entry = entry,
               X = X,
               newX = X,
               newtimes = seq(0, 15, .1),
               direction = "prospective",
               bin_size = 0.1,
               time_basis = "continuous",
               SL_control = list(SL.library = SL.library,
                                 V = 5))

plot(fit$S_T_preds[1,], S0(t =  seq(0, 15, .1), X[1,]))
abline(0,1,col='red')

</code></pre>

<hr>
<h2 id='vim'>Estimate AUC VIM</h2><span id='topic+vim'></span>

<h3>Description</h3>

<p>Estimate AUC VIM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vim(
  type,
  time,
  event,
  X,
  landmark_times = stats::quantile(time[event == 1], probs = c(0.25, 0.5, 0.75)),
  restriction_time = max(time[event == 1]),
  approx_times = NULL,
  large_feature_vector,
  small_feature_vector,
  conditional_surv_preds = NULL,
  large_oracle_preds = NULL,
  small_oracle_preds = NULL,
  conditional_surv_generator = NULL,
  conditional_surv_generator_control = NULL,
  large_oracle_generator = NULL,
  large_oracle_generator_control = NULL,
  small_oracle_generator = NULL,
  small_oracle_generator_control = NULL,
  cf_folds = NULL,
  cf_fold_num = 5,
  sample_split = TRUE,
  ss_folds = NULL,
  robust = TRUE,
  scale_est = FALSE,
  alpha = 0.05,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vim_+3A_type">type</code></td>
<td>
<p>Type of VIM to compute. Options include <code>"accuracy"</code>, <code>"AUC"</code>, <code>"Brier"</code>, <code>"R-squared"</code>
<code>"C-index"</code>, and <code>"survival_time_MSE"</code>.</p>
</td></tr>
<tr><td><code id="vim_+3A_time">time</code></td>
<td>
<p><code>n x 1</code> numeric vector of observed
follow-up times. If there is censoring, these are the minimum of the
event and censoring times.</p>
</td></tr>
<tr><td><code id="vim_+3A_event">event</code></td>
<td>
<p><code>n x 1</code> numeric vector of status indicators of
whether an event was observed.</p>
</td></tr>
<tr><td><code id="vim_+3A_x">X</code></td>
<td>
<p><code>n x p</code> data.frame of observed covariate values</p>
</td></tr>
<tr><td><code id="vim_+3A_landmark_times">landmark_times</code></td>
<td>
<p>Numeric vector of length J1 giving
landmark times at which to estimate VIM (<code>"accuracy"</code>, <code>"AUC"</code>, <code>"Brier"</code>, <code>"R-squared"</code>).</p>
</td></tr>
<tr><td><code id="vim_+3A_restriction_time">restriction_time</code></td>
<td>
<p>Maximum follow-up time for calculation of <code>"C-index"</code> and <code>"survival_time_MSE"</code>.</p>
</td></tr>
<tr><td><code id="vim_+3A_approx_times">approx_times</code></td>
<td>
<p>Numeric vector of length J2 giving times at which to
approximate integrals. Defaults to a grid of 100 timepoints, evenly spaced on the quantile scale of the distribution of observed event times.</p>
</td></tr>
<tr><td><code id="vim_+3A_large_feature_vector">large_feature_vector</code></td>
<td>
<p>Numeric vector giving indices of features to include in the 'large' prediction model.</p>
</td></tr>
<tr><td><code id="vim_+3A_small_feature_vector">small_feature_vector</code></td>
<td>
<p>Numeric vector giving indices of features to include in the 'small' prediction model. Must be a
subset of <code>large_feature_vector</code>.</p>
</td></tr>
<tr><td><code id="vim_+3A_conditional_surv_preds">conditional_surv_preds</code></td>
<td>
<p>User-provided estimates of the conditional survival functions of the event and censoring
variables given the full covariate vector (if not using the <code>vim()</code> function to compute these nuisance estimates).
Must be a named list of lists with elements <code>S_hat</code>, <code>S_hat_train</code>, <code>G_hat</code>, and <code>G_hat_train</code>. Each of these is itself
a list of length <code>K</code>, where <code>K</code> is the number of cross-fitting folds. Each element of these lists is a matrix with J2 columns and number of rows
equal to either the number of samples in the <code>k</code>th fold (for <code>S_hat</code> or <code>G_hat</code>) or the number of samples used to compute the nuisance estimator
for the <code>k</code>th fold.</p>
</td></tr>
<tr><td><code id="vim_+3A_large_oracle_preds">large_oracle_preds</code></td>
<td>
<p>User-provided estimates of the oracle prediction function using <code>large_feature_vector</code>. Must be a named list of lists
with elements <code>f_hat</code> and <code>f_hat_train</code>. Each of these is itself a list of length <code>K</code>. Each element of these lists is a matrix with J1 columns
(for landmark time VIMs) or 1 column (for <code>"C-index"</code> and <code>"survival_time_MSE"</code>).</p>
</td></tr>
<tr><td><code id="vim_+3A_small_oracle_preds">small_oracle_preds</code></td>
<td>
<p>User-provided estimates of the oracle prediction function using <code>small_feature_vector</code>. Must be a named list of lists
with elements <code>f_hat</code> and <code>f_hat_train</code>. Each of these is itself a list of length <code>K</code>. Each element of these lists is a matrix with J1 columns
(for landmark time VIMs) or 1 column (for <code>"C-index"</code> and <code>"survival_time_MSE"</code>).</p>
</td></tr>
<tr><td><code id="vim_+3A_conditional_surv_generator">conditional_surv_generator</code></td>
<td>
<p>A user-written function to estimate the conditional survival functions of the event and censoring variables. Must take arguments
<code>time</code>, <code>event</code>, <code>folds</code> (cross-fitting fold identifiers), and
<code>newtimes</code> (times at which to generate predictions).</p>
</td></tr>
<tr><td><code id="vim_+3A_conditional_surv_generator_control">conditional_surv_generator_control</code></td>
<td>
<p>A list of arguments to pass to <code>conditional_surv_generator</code>.</p>
</td></tr>
<tr><td><code id="vim_+3A_large_oracle_generator">large_oracle_generator</code></td>
<td>
<p>A user-written function to estimate the oracle prediction function using <code>large_feature_vector</code>.Must take arguments
<code>time</code>, <code>event</code>, and <code>folds</code> (cross-fitting fold identifiers).</p>
</td></tr>
<tr><td><code id="vim_+3A_large_oracle_generator_control">large_oracle_generator_control</code></td>
<td>
<p>A list of arguments to pass to <code>large_oracle_generator</code>.</p>
</td></tr>
<tr><td><code id="vim_+3A_small_oracle_generator">small_oracle_generator</code></td>
<td>
<p>A user-written function to estimate the oracle prediction function using <code>small_feature_vector</code>.Must take arguments
<code>time</code>, <code>event</code>, and <code>folds</code> (cross-fitting fold identifiers).</p>
</td></tr>
<tr><td><code id="vim_+3A_small_oracle_generator_control">small_oracle_generator_control</code></td>
<td>
<p>A list of arguments to pass to <code>small_oracle_generator</code>.</p>
</td></tr>
<tr><td><code id="vim_+3A_cf_folds">cf_folds</code></td>
<td>
<p>Numeric vector of length <code>n</code> giving cross-fitting folds</p>
</td></tr>
<tr><td><code id="vim_+3A_cf_fold_num">cf_fold_num</code></td>
<td>
<p>The number of cross-fitting folds, if not providing <code>cf_folds</code></p>
</td></tr>
<tr><td><code id="vim_+3A_sample_split">sample_split</code></td>
<td>
<p>Logical indicating whether or not to sample split</p>
</td></tr>
<tr><td><code id="vim_+3A_ss_folds">ss_folds</code></td>
<td>
<p>Numeric vector of length <code>n</code> giving sample-splitting folds</p>
</td></tr>
<tr><td><code id="vim_+3A_robust">robust</code></td>
<td>
<p>Logical, whether or not to use the doubly-robust debiasing approach. This option
is meant for illustration purposes only &mdash; it should be left as <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="vim_+3A_scale_est">scale_est</code></td>
<td>
<p>Logical, whether or not to force the VIM estimate to be nonnegative</p>
</td></tr>
<tr><td><code id="vim_+3A_alpha">alpha</code></td>
<td>
<p>The level at which to compute confidence intervals and hypothesis tests. Defaults to 0.05</p>
</td></tr>
<tr><td><code id="vim_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print progress messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named list with the following elements:
</p>
<table role = "presentation">
<tr><td><code>result</code></td>
<td>
<p>Data frame giving results. See the documentation of the individual <code>vim_*</code> functions for details.</p>
</td></tr>
<tr><td><code>folds</code></td>
<td>
<p>A named list giving the cross-fitting fold IDs (<code>cf_folds</code>) and sample-splitting fold IDs (<code>ss_folds</code>).</p>
</td></tr>
<tr><td><code>approx_times</code></td>
<td>
<p>A vector of times used to approximate integrals appearing in the form of the VIM estimator.</p>
</td></tr>
<tr><td><code>conditional_surv_preds</code></td>
<td>
<p>A named list containing the estimated conditional event and censoring survival functions.</p>
</td></tr>
<tr><td><code>large_oracle_preds</code></td>
<td>
<p>A named list containing the estimated large oracle prediction function.</p>
</td></tr>
<tr><td><code>small_oracle_preds</code></td>
<td>
<p>A named list containing the estimated small oracle prediction function.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+vim_accuracy">vim_accuracy</a> <a href="#topic+vim_AUC">vim_AUC</a> <a href="#topic+vim_brier">vim_brier</a> <a href="#topic+vim_cindex">vim_cindex</a> <a href="#topic+vim_rsquared">vim_rsquared</a> <a href="#topic+vim_survival_time_mse">vim_survival_time_mse</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This is a small simulation example
set.seed(123)
n &lt;- 100
X &lt;- data.frame(X1 = rnorm(n), X2 = rbinom(n, size = 1, prob = 0.5))

T &lt;- rexp(n, rate = exp(-2 + X[,1] - X[,2] + .5 *  X[,1] * X[,2]))

C &lt;- rexp(n, exp(-2 -.5 * X[,1] - .25 * X[,2] + .5 * X[,1] * X[,2]))
C[C &gt; 15] &lt;- 15

time &lt;- pmin(T, C)
event &lt;- as.numeric(T &lt;= C)

# landmark times for AUC
landmark_times &lt;- c(3)

output &lt;- vim(type = "AUC",
              time = time,
              event = event,
              X = X,
              landmark_times = landmark_times,
              large_feature_vector = 1:2,
              small_feature_vector = 2,
              conditional_surv_generator_control = list(SL.library = c("SL.mean", "SL.glm")),
              large_oracle_generator_control = list(SL.library = c("SL.mean", "SL.glm")),
              small_oracle_generator_control = list(SL.library = c("SL.mean", "SL.glm")),
              cf_fold_num = 2,
              sample_split = FALSE,
              scale_est = TRUE)

print(output$result)
</code></pre>

<hr>
<h2 id='vim_accuracy'>Estimate classification accuracy VIM</h2><span id='topic+vim_accuracy'></span>

<h3>Description</h3>

<p>Estimate classification accuracy VIM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vim_accuracy(
  time,
  event,
  approx_times,
  landmark_times,
  f_hat,
  fs_hat,
  S_hat,
  G_hat,
  cf_folds,
  sample_split,
  ss_folds,
  scale_est = FALSE,
  alpha = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vim_accuracy_+3A_time">time</code></td>
<td>
<p><code>n x 1</code> numeric vector of observed
follow-up times If there is censoring, these are the minimum of the
event and censoring times.</p>
</td></tr>
<tr><td><code id="vim_accuracy_+3A_event">event</code></td>
<td>
<p><code>n x 1</code> numeric vector of status indicators of
whether an event was observed. Defaults to a vector of 1s, i.e. no censoring.</p>
</td></tr>
<tr><td><code id="vim_accuracy_+3A_approx_times">approx_times</code></td>
<td>
<p>Numeric vector of length J1 giving times at which to
approximate integrals.</p>
</td></tr>
<tr><td><code id="vim_accuracy_+3A_landmark_times">landmark_times</code></td>
<td>
<p>Numeric vector of length J2 giving
times at which to estimate accuracy</p>
</td></tr>
<tr><td><code id="vim_accuracy_+3A_f_hat">f_hat</code></td>
<td>
<p>Full oracle predictions (n x J1 matrix)</p>
</td></tr>
<tr><td><code id="vim_accuracy_+3A_fs_hat">fs_hat</code></td>
<td>
<p>Residual oracle predictions (n x J1 matrix)</p>
</td></tr>
<tr><td><code id="vim_accuracy_+3A_s_hat">S_hat</code></td>
<td>
<p>Estimates of conditional event time survival function (n x J2 matrix)</p>
</td></tr>
<tr><td><code id="vim_accuracy_+3A_g_hat">G_hat</code></td>
<td>
<p>Estimate of conditional censoring time survival function (n x J2 matrix)</p>
</td></tr>
<tr><td><code id="vim_accuracy_+3A_cf_folds">cf_folds</code></td>
<td>
<p>Numeric vector of length n giving cross-fitting folds</p>
</td></tr>
<tr><td><code id="vim_accuracy_+3A_sample_split">sample_split</code></td>
<td>
<p>Logical indicating whether or not to sample split</p>
</td></tr>
<tr><td><code id="vim_accuracy_+3A_ss_folds">ss_folds</code></td>
<td>
<p>Numeric vector of length n giving sample-splitting folds</p>
</td></tr>
<tr><td><code id="vim_accuracy_+3A_scale_est">scale_est</code></td>
<td>
<p>Logical, whether or not to force the VIM estimate to be nonnegative</p>
</td></tr>
<tr><td><code id="vim_accuracy_+3A_alpha">alpha</code></td>
<td>
<p>The level at which to compute confidence intervals and hypothesis tests. Defaults to 0.05</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame giving results, with the following columns:
</p>
<table role = "presentation">
<tr><td><code>landmark_time</code></td>
<td>
<p>Time at which AUC is evaluated.</p>
</td></tr>
<tr><td><code>est</code></td>
<td>
<p>VIM point estimate.</p>
</td></tr>
<tr><td><code>var_est</code></td>
<td>
<p>Estimated variance of the VIM estimate.</p>
</td></tr>
<tr><td><code>cil</code></td>
<td>
<p>Lower bound of the VIM confidence interval.</p>
</td></tr>
<tr><td><code>ciu</code></td>
<td>
<p>Upper bound of the VIM confidence interval.</p>
</td></tr>
<tr><td><code>cil_1sided</code></td>
<td>
<p>Lower bound of a one-sided confidence interval.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>p-value corresponding to a hypothesis test of null importance.</p>
</td></tr>
<tr><td><code>large_predictiveness</code></td>
<td>
<p>Estimated predictiveness of the large oracle prediction function.</p>
</td></tr>
<tr><td><code>small_predictiveness</code></td>
<td>
<p>Estimated predictiveness of the small oracle prediction function.</p>
</td></tr>
<tr><td><code>vim</code></td>
<td>
<p>VIM type.</p>
</td></tr>
<tr><td><code>large_feature_vector</code></td>
<td>
<p>Group of features available for the large oracle prediction function.</p>
</td></tr>
<tr><td><code>small_feature_vector</code></td>
<td>
<p>Group of features available for the small oracle prediction function.</p>
</td></tr>
</table>

<hr>
<h2 id='vim_AUC'>Estimate AUC VIM</h2><span id='topic+vim_AUC'></span>

<h3>Description</h3>

<p>Estimate AUC VIM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vim_AUC(
  time,
  event,
  approx_times,
  landmark_times,
  f_hat,
  fs_hat,
  S_hat,
  G_hat,
  cf_folds,
  sample_split,
  ss_folds,
  robust = TRUE,
  scale_est = FALSE,
  alpha = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vim_AUC_+3A_time">time</code></td>
<td>
<p><code>n x 1</code> numeric vector of observed
follow-up times If there is censoring, these are the minimum of the
event and censoring times.</p>
</td></tr>
<tr><td><code id="vim_AUC_+3A_event">event</code></td>
<td>
<p><code>n x 1</code> numeric vector of status indicators of
whether an event was observed. Defaults to a vector of 1s, i.e. no censoring.</p>
</td></tr>
<tr><td><code id="vim_AUC_+3A_approx_times">approx_times</code></td>
<td>
<p>Numeric vector of length J1 giving times at which to
approximate integrals.</p>
</td></tr>
<tr><td><code id="vim_AUC_+3A_landmark_times">landmark_times</code></td>
<td>
<p>Numeric vector of length J2 giving
times at which to estimate AUC</p>
</td></tr>
<tr><td><code id="vim_AUC_+3A_f_hat">f_hat</code></td>
<td>
<p>Full oracle predictions (n x J1 matrix)</p>
</td></tr>
<tr><td><code id="vim_AUC_+3A_fs_hat">fs_hat</code></td>
<td>
<p>Residual oracle predictions (n x J1 matrix)</p>
</td></tr>
<tr><td><code id="vim_AUC_+3A_s_hat">S_hat</code></td>
<td>
<p>Estimates of conditional event time survival function (n x J2 matrix)</p>
</td></tr>
<tr><td><code id="vim_AUC_+3A_g_hat">G_hat</code></td>
<td>
<p>Estimate of conditional censoring time survival function (n x J2 matrix)</p>
</td></tr>
<tr><td><code id="vim_AUC_+3A_cf_folds">cf_folds</code></td>
<td>
<p>Numeric vector of length n giving cross-fitting folds</p>
</td></tr>
<tr><td><code id="vim_AUC_+3A_sample_split">sample_split</code></td>
<td>
<p>Logical indicating whether or not to sample split</p>
</td></tr>
<tr><td><code id="vim_AUC_+3A_ss_folds">ss_folds</code></td>
<td>
<p>Numeric vector of length n giving sample-splitting folds</p>
</td></tr>
<tr><td><code id="vim_AUC_+3A_robust">robust</code></td>
<td>
<p>Logical, whether or not to use the doubly-robust debiasing approach. This option
is meant for illustration purposes only &mdash; it should be left as <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="vim_AUC_+3A_scale_est">scale_est</code></td>
<td>
<p>Logical, whether or not to force the VIM estimate to be nonnegative</p>
</td></tr>
<tr><td><code id="vim_AUC_+3A_alpha">alpha</code></td>
<td>
<p>The level at which to compute confidence intervals and hypothesis tests. Defaults to 0.05</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame giving results, with the following columns:
</p>
<table role = "presentation">
<tr><td><code>landmark_time</code></td>
<td>
<p>Time at which AUC is evaluated.</p>
</td></tr>
<tr><td><code>est</code></td>
<td>
<p>VIM point estimate.</p>
</td></tr>
<tr><td><code>var_est</code></td>
<td>
<p>Estimated variance of the VIM estimate.</p>
</td></tr>
<tr><td><code>cil</code></td>
<td>
<p>Lower bound of the VIM confidence interval.</p>
</td></tr>
<tr><td><code>ciu</code></td>
<td>
<p>Upper bound of the VIM confidence interval.</p>
</td></tr>
<tr><td><code>cil_1sided</code></td>
<td>
<p>Lower bound of a one-sided confidence interval.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>p-value corresponding to a hypothesis test of null importance.</p>
</td></tr>
<tr><td><code>large_predictiveness</code></td>
<td>
<p>Estimated predictiveness of the large oracle prediction function.</p>
</td></tr>
<tr><td><code>small_predictiveness</code></td>
<td>
<p>Estimated predictiveness of the small oracle prediction function.</p>
</td></tr>
<tr><td><code>vim</code></td>
<td>
<p>VIM type.</p>
</td></tr>
<tr><td><code>large_feature_vector</code></td>
<td>
<p>Group of features available for the large oracle prediction function.</p>
</td></tr>
<tr><td><code>small_feature_vector</code></td>
<td>
<p>Group of features available for the small oracle prediction function.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+vim">vim</a> for example usage
</p>

<hr>
<h2 id='vim_brier'>Estimate Brier score VIM</h2><span id='topic+vim_brier'></span>

<h3>Description</h3>

<p>Estimate Brier score VIM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vim_brier(
  time,
  event,
  approx_times,
  landmark_times,
  f_hat,
  fs_hat,
  S_hat,
  G_hat,
  cf_folds,
  ss_folds,
  sample_split,
  scale_est = FALSE,
  alpha = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vim_brier_+3A_time">time</code></td>
<td>
<p><code>n x 1</code> numeric vector of observed
follow-up times If there is censoring, these are the minimum of the
event and censoring times.</p>
</td></tr>
<tr><td><code id="vim_brier_+3A_event">event</code></td>
<td>
<p><code>n x 1</code> numeric vector of status indicators of
whether an event was observed. Defaults to a vector of 1s, i.e. no censoring.</p>
</td></tr>
<tr><td><code id="vim_brier_+3A_approx_times">approx_times</code></td>
<td>
<p>Numeric vector of length J1 giving times at which to
approximate integrals.</p>
</td></tr>
<tr><td><code id="vim_brier_+3A_landmark_times">landmark_times</code></td>
<td>
<p>Numeric vector of length J2 giving
times at which to estimate Brier score</p>
</td></tr>
<tr><td><code id="vim_brier_+3A_f_hat">f_hat</code></td>
<td>
<p>Full oracle predictions (n x J1 matrix)</p>
</td></tr>
<tr><td><code id="vim_brier_+3A_fs_hat">fs_hat</code></td>
<td>
<p>Residual oracle predictions (n x J1 matrix)</p>
</td></tr>
<tr><td><code id="vim_brier_+3A_s_hat">S_hat</code></td>
<td>
<p>Estimates of conditional event time survival function (n x J2 matrix)</p>
</td></tr>
<tr><td><code id="vim_brier_+3A_g_hat">G_hat</code></td>
<td>
<p>Estimate of conditional censoring time survival function (n x J2 matrix)</p>
</td></tr>
<tr><td><code id="vim_brier_+3A_cf_folds">cf_folds</code></td>
<td>
<p>Numeric vector of length n giving cross-fitting folds</p>
</td></tr>
<tr><td><code id="vim_brier_+3A_ss_folds">ss_folds</code></td>
<td>
<p>Numeric vector of length n giving sample-splitting folds</p>
</td></tr>
<tr><td><code id="vim_brier_+3A_sample_split">sample_split</code></td>
<td>
<p>Logical indicating whether or not to sample split</p>
</td></tr>
<tr><td><code id="vim_brier_+3A_scale_est">scale_est</code></td>
<td>
<p>Logical, whether or not to force the VIM estimate to be nonnegative</p>
</td></tr>
<tr><td><code id="vim_brier_+3A_alpha">alpha</code></td>
<td>
<p>The level at which to compute confidence intervals and hypothesis tests. Defaults to 0.05</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame giving results, with the following columns:
</p>
<table role = "presentation">
<tr><td><code>landmark_time</code></td>
<td>
<p>Time at which AUC is evaluated.</p>
</td></tr>
<tr><td><code>est</code></td>
<td>
<p>VIM point estimate.</p>
</td></tr>
<tr><td><code>var_est</code></td>
<td>
<p>Estimated variance of the VIM estimate.</p>
</td></tr>
<tr><td><code>cil</code></td>
<td>
<p>Lower bound of the VIM confidence interval.</p>
</td></tr>
<tr><td><code>ciu</code></td>
<td>
<p>Upper bound of the VIM confidence interval.</p>
</td></tr>
<tr><td><code>cil_1sided</code></td>
<td>
<p>Lower bound of a one-sided confidence interval.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>p-value corresponding to a hypothesis test of null importance.</p>
</td></tr>
<tr><td><code>large_predictiveness</code></td>
<td>
<p>Estimated predictiveness of the large oracle prediction function.</p>
</td></tr>
<tr><td><code>small_predictiveness</code></td>
<td>
<p>Estimated predictiveness of the small oracle prediction function.</p>
</td></tr>
<tr><td><code>vim</code></td>
<td>
<p>VIM type.</p>
</td></tr>
<tr><td><code>large_feature_vector</code></td>
<td>
<p>Group of features available for the large oracle prediction function.</p>
</td></tr>
<tr><td><code>small_feature_vector</code></td>
<td>
<p>Group of features available for the small oracle prediction function.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+vim">vim</a> for example usage
</p>

<hr>
<h2 id='vim_cindex'>Estimate concordance index VIM</h2><span id='topic+vim_cindex'></span>

<h3>Description</h3>

<p>Estimate concordance index VIM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vim_cindex(
  time,
  event,
  approx_times,
  restriction_time,
  f_hat,
  fs_hat,
  S_hat,
  G_hat,
  cf_folds,
  sample_split,
  ss_folds,
  scale_est = FALSE,
  alpha = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vim_cindex_+3A_time">time</code></td>
<td>
<p><code>n x 1</code> numeric vector of observed
follow-up times If there is censoring, these are the minimum of the
event and censoring times.</p>
</td></tr>
<tr><td><code id="vim_cindex_+3A_event">event</code></td>
<td>
<p><code>n x 1</code> numeric vector of status indicators of
whether an event was observed. Defaults to a vector of 1s, i.e. no censoring.</p>
</td></tr>
<tr><td><code id="vim_cindex_+3A_approx_times">approx_times</code></td>
<td>
<p>Numeric vector of length J1 giving times at which to
approximate integrals.</p>
</td></tr>
<tr><td><code id="vim_cindex_+3A_restriction_time">restriction_time</code></td>
<td>
<p>Restriction time (upper bound for event times to be compared in computing the C-index)</p>
</td></tr>
<tr><td><code id="vim_cindex_+3A_f_hat">f_hat</code></td>
<td>
<p>Full oracle predictions (n x J1 matrix)</p>
</td></tr>
<tr><td><code id="vim_cindex_+3A_fs_hat">fs_hat</code></td>
<td>
<p>Residual oracle predictions (n x J1 matrix)</p>
</td></tr>
<tr><td><code id="vim_cindex_+3A_s_hat">S_hat</code></td>
<td>
<p>Estimates of conditional event time survival function (n x J2 matrix)</p>
</td></tr>
<tr><td><code id="vim_cindex_+3A_g_hat">G_hat</code></td>
<td>
<p>Estimate of conditional censoring time survival function (n x J2 matrix)</p>
</td></tr>
<tr><td><code id="vim_cindex_+3A_cf_folds">cf_folds</code></td>
<td>
<p>Numeric vector of length n giving cross-fitting folds</p>
</td></tr>
<tr><td><code id="vim_cindex_+3A_sample_split">sample_split</code></td>
<td>
<p>Logical indicating whether or not to sample split</p>
</td></tr>
<tr><td><code id="vim_cindex_+3A_ss_folds">ss_folds</code></td>
<td>
<p>Numeric vector of length n giving sample-splitting folds</p>
</td></tr>
<tr><td><code id="vim_cindex_+3A_scale_est">scale_est</code></td>
<td>
<p>Logical, whether or not to force the VIM estimate to be nonnegative</p>
</td></tr>
<tr><td><code id="vim_cindex_+3A_alpha">alpha</code></td>
<td>
<p>The level at which to compute confidence intervals and hypothesis tests. Defaults to 0.05</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame giving results, with the following columns:
</p>
<table role = "presentation">
<tr><td><code>restriction_time</code></td>
<td>
<p>Restriction time (upper bound for event times to be compared in computing the C-index).</p>
</td></tr>
<tr><td><code>est</code></td>
<td>
<p>VIM point estimate.</p>
</td></tr>
<tr><td><code>var_est</code></td>
<td>
<p>Estimated variance of the VIM estimate.</p>
</td></tr>
<tr><td><code>cil</code></td>
<td>
<p>Lower bound of the VIM confidence interval.</p>
</td></tr>
<tr><td><code>ciu</code></td>
<td>
<p>Upper bound of the VIM confidence interval.</p>
</td></tr>
<tr><td><code>cil_1sided</code></td>
<td>
<p>Lower bound of a one-sided confidence interval.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>p-value corresponding to a hypothesis test of null importance.</p>
</td></tr>
<tr><td><code>large_predictiveness</code></td>
<td>
<p>Estimated predictiveness of the large oracle prediction function.</p>
</td></tr>
<tr><td><code>small_predictiveness</code></td>
<td>
<p>Estimated predictiveness of the small oracle prediction function.</p>
</td></tr>
<tr><td><code>vim</code></td>
<td>
<p>VIM type.</p>
</td></tr>
<tr><td><code>large_feature_vector</code></td>
<td>
<p>Group of features available for the large oracle prediction function.</p>
</td></tr>
<tr><td><code>small_feature_vector</code></td>
<td>
<p>Group of features available for the small oracle prediction function.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+vim">vim</a> for example usage
</p>

<hr>
<h2 id='vim_rsquared'>Estimate R-squared (proportion of explained variance) VIM based on event occurrence by a landmark time</h2><span id='topic+vim_rsquared'></span>

<h3>Description</h3>

<p>Estimate R-squared (proportion of explained variance) VIM based on event occurrence by a landmark time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vim_rsquared(
  time,
  event,
  approx_times,
  landmark_times,
  f_hat,
  fs_hat,
  S_hat,
  G_hat,
  cf_folds,
  ss_folds,
  sample_split,
  scale_est = FALSE,
  alpha = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vim_rsquared_+3A_time">time</code></td>
<td>
<p><code>n x 1</code> numeric vector of observed
follow-up times If there is censoring, these are the minimum of the
event and censoring times.</p>
</td></tr>
<tr><td><code id="vim_rsquared_+3A_event">event</code></td>
<td>
<p><code>n x 1</code> numeric vector of status indicators of
whether an event was observed. Defaults to a vector of 1s, i.e. no censoring.</p>
</td></tr>
<tr><td><code id="vim_rsquared_+3A_approx_times">approx_times</code></td>
<td>
<p>Numeric vector of length J1 giving times at which to
approximate integrals.</p>
</td></tr>
<tr><td><code id="vim_rsquared_+3A_landmark_times">landmark_times</code></td>
<td>
<p>Numeric vector of length J2 giving
times at which to estimate Brier score</p>
</td></tr>
<tr><td><code id="vim_rsquared_+3A_f_hat">f_hat</code></td>
<td>
<p>Full oracle predictions (n x J1 matrix)</p>
</td></tr>
<tr><td><code id="vim_rsquared_+3A_fs_hat">fs_hat</code></td>
<td>
<p>Residual oracle predictions (n x J1 matrix)</p>
</td></tr>
<tr><td><code id="vim_rsquared_+3A_s_hat">S_hat</code></td>
<td>
<p>Estimates of conditional event time survival function (n x J2 matrix)</p>
</td></tr>
<tr><td><code id="vim_rsquared_+3A_g_hat">G_hat</code></td>
<td>
<p>Estimate of conditional censoring time survival function (n x J2 matrix)</p>
</td></tr>
<tr><td><code id="vim_rsquared_+3A_cf_folds">cf_folds</code></td>
<td>
<p>Numeric vector of length n giving cross-fitting folds</p>
</td></tr>
<tr><td><code id="vim_rsquared_+3A_ss_folds">ss_folds</code></td>
<td>
<p>Numeric vector of length n giving sample-splitting folds</p>
</td></tr>
<tr><td><code id="vim_rsquared_+3A_sample_split">sample_split</code></td>
<td>
<p>Logical indicating whether or not to sample split</p>
</td></tr>
<tr><td><code id="vim_rsquared_+3A_scale_est">scale_est</code></td>
<td>
<p>Logical, whether or not to force the VIM estimate to be nonnegative</p>
</td></tr>
<tr><td><code id="vim_rsquared_+3A_alpha">alpha</code></td>
<td>
<p>The level at which to compute confidence intervals and hypothesis tests. Defaults to 0.05</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame giving results, with the following columns:
</p>
<table role = "presentation">
<tr><td><code>landmark_time</code></td>
<td>
<p>Time at which AUC is evaluated.</p>
</td></tr>
<tr><td><code>est</code></td>
<td>
<p>VIM point estimate.</p>
</td></tr>
<tr><td><code>var_est</code></td>
<td>
<p>Estimated variance of the VIM estimate.</p>
</td></tr>
<tr><td><code>cil</code></td>
<td>
<p>Lower bound of the VIM confidence interval.</p>
</td></tr>
<tr><td><code>ciu</code></td>
<td>
<p>Upper bound of the VIM confidence interval.</p>
</td></tr>
<tr><td><code>cil_1sided</code></td>
<td>
<p>Lower bound of a one-sided confidence interval.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>p-value corresponding to a hypothesis test of null importance.</p>
</td></tr>
<tr><td><code>large_predictiveness</code></td>
<td>
<p>Estimated predictiveness of the large oracle prediction function.</p>
</td></tr>
<tr><td><code>small_predictiveness</code></td>
<td>
<p>Estimated predictiveness of the small oracle prediction function.</p>
</td></tr>
<tr><td><code>vim</code></td>
<td>
<p>VIM type.</p>
</td></tr>
<tr><td><code>large_feature_vector</code></td>
<td>
<p>Group of features available for the large oracle prediction function.</p>
</td></tr>
<tr><td><code>small_feature_vector</code></td>
<td>
<p>Group of features available for the small oracle prediction function.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+vim">vim</a> for example usage
</p>

<hr>
<h2 id='vim_survival_time_mse'>Estimate restricted predicted survival time MSE VIM</h2><span id='topic+vim_survival_time_mse'></span>

<h3>Description</h3>

<p>Estimate restricted predicted survival time MSE VIM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vim_survival_time_mse(
  time,
  event,
  approx_times,
  restriction_time,
  f_hat,
  fs_hat,
  S_hat,
  G_hat,
  cf_folds,
  sample_split,
  ss_folds,
  scale_est = FALSE,
  alpha = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vim_survival_time_mse_+3A_time">time</code></td>
<td>
<p><code>n x 1</code> numeric vector of observed
follow-up times If there is censoring, these are the minimum of the
event and censoring times.</p>
</td></tr>
<tr><td><code id="vim_survival_time_mse_+3A_event">event</code></td>
<td>
<p><code>n x 1</code> numeric vector of status indicators of
whether an event was observed. Defaults to a vector of 1s, i.e. no censoring.</p>
</td></tr>
<tr><td><code id="vim_survival_time_mse_+3A_approx_times">approx_times</code></td>
<td>
<p>Numeric vector of length J1 giving times at which to
approximate integrals.</p>
</td></tr>
<tr><td><code id="vim_survival_time_mse_+3A_restriction_time">restriction_time</code></td>
<td>
<p>restriction time</p>
</td></tr>
<tr><td><code id="vim_survival_time_mse_+3A_f_hat">f_hat</code></td>
<td>
<p>Full oracle predictions (n x J1 matrix)</p>
</td></tr>
<tr><td><code id="vim_survival_time_mse_+3A_fs_hat">fs_hat</code></td>
<td>
<p>Residual oracle predictions (n x J1 matrix)</p>
</td></tr>
<tr><td><code id="vim_survival_time_mse_+3A_s_hat">S_hat</code></td>
<td>
<p>Estimates of conditional event time survival function (n x J2 matrix)</p>
</td></tr>
<tr><td><code id="vim_survival_time_mse_+3A_g_hat">G_hat</code></td>
<td>
<p>Estimate of conditional censoring time survival function (n x J2 matrix)</p>
</td></tr>
<tr><td><code id="vim_survival_time_mse_+3A_cf_folds">cf_folds</code></td>
<td>
<p>Numeric vector of length n giving cross-fitting folds</p>
</td></tr>
<tr><td><code id="vim_survival_time_mse_+3A_sample_split">sample_split</code></td>
<td>
<p>Logical indicating whether or not to sample split</p>
</td></tr>
<tr><td><code id="vim_survival_time_mse_+3A_ss_folds">ss_folds</code></td>
<td>
<p>Numeric vector of length n giving sample-splitting folds</p>
</td></tr>
<tr><td><code id="vim_survival_time_mse_+3A_scale_est">scale_est</code></td>
<td>
<p>Logical, whether or not to force the VIM estimate to be nonnegative</p>
</td></tr>
<tr><td><code id="vim_survival_time_mse_+3A_alpha">alpha</code></td>
<td>
<p>The level at which to compute confidence intervals and hypothesis tests. Defaults to 0.05</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame giving results, with the following columns:
</p>
<table role = "presentation">
<tr><td><code>restriction_time</code></td>
<td>
<p>Restriction time (upper bound for event times to be compared in computing the restricted survival time).</p>
</td></tr>
<tr><td><code>est</code></td>
<td>
<p>VIM point estimate.</p>
</td></tr>
<tr><td><code>var_est</code></td>
<td>
<p>Estimated variance of the VIM estimate.</p>
</td></tr>
<tr><td><code>cil</code></td>
<td>
<p>Lower bound of the VIM confidence interval.</p>
</td></tr>
<tr><td><code>ciu</code></td>
<td>
<p>Upper bound of the VIM confidence interval.</p>
</td></tr>
<tr><td><code>cil_1sided</code></td>
<td>
<p>Lower bound of a one-sided confidence interval.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>p-value corresponding to a hypothesis test of null importance.</p>
</td></tr>
<tr><td><code>large_predictiveness</code></td>
<td>
<p>Estimated predictiveness of the large oracle prediction function.</p>
</td></tr>
<tr><td><code>small_predictiveness</code></td>
<td>
<p>Estimated predictiveness of the small oracle prediction function.</p>
</td></tr>
<tr><td><code>vim</code></td>
<td>
<p>VIM type.</p>
</td></tr>
<tr><td><code>large_feature_vector</code></td>
<td>
<p>Group of features available for the large oracle prediction function.</p>
</td></tr>
<tr><td><code>small_feature_vector</code></td>
<td>
<p>Group of features available for the small oracle prediction function.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+vim">vim</a> for example usage
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
