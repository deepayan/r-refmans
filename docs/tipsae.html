<!DOCTYPE html><html><head><title>Help for package tipsae</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tipsae}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#tipsae-package'><p>The 'tipsae' Package.</p></a></li>
<li><a href='#benchmark'><p>Benchmarking Procedure for Model-Based Estimates</p></a></li>
<li><a href='#density.summary_fitsae'><p>Density Plot Function for a <code>summary_fitsae</code> Object</p></a></li>
<li><a href='#emilia'><p>Poverty in Emilia-Romagna (Italy) Health Districts</p></a></li>
<li><a href='#emilia_cs'><p>Poverty in Emilia-Romagna (Italy) Health Districts in 2016</p></a></li>
<li><a href='#emilia_shp'><p>Shapefile of Emilia-Romagna (Italy) Health Districts</p></a></li>
<li><a href='#export'><p>Exporting Results of a Small Area Model Fitting</p></a></li>
<li><a href='#extract'><p>Extract Posterior Summaries of Target Parameters</p></a></li>
<li><a href='#fit_sae'><p>Fitting a Small Area Model</p></a></li>
<li><a href='#map'><p>Map Relevant Quantities from a Small Area Model</p></a></li>
<li><a href='#plot.benchmark_fitsae'><p>Plot Method for <code>benchmark_fitsae</code> Object</p></a></li>
<li><a href='#plot.smoothing_fitsae'><p>Plot Method for <code>smoothing_fitsae</code> Object</p></a></li>
<li><a href='#plot.summary_fitsae'><p>Plot Method for a <code>summary_fitsae</code> Object</p></a></li>
<li><a href='#print.benchmark_fitsae'><p>Print Method for a <code>benchmark_fitsae</code> Object</p></a></li>
<li><a href='#print.estimates_fitsae'><p>Print Method for a <code>estimates_fitsae</code> Object</p></a></li>
<li><a href='#print.fitsae'><p>Print Method for a <code>fitsae</code> Object</p></a></li>
<li><a href='#print.smoothing_fitsae'><p>Print Method for a <code>smoothing_fitsae</code> Object</p></a></li>
<li><a href='#print.summary_fitsae'><p>Print Method for a <code>summary_fitsae</code> Object</p></a></li>
<li><a href='#runShiny_tipsae'><p>Lauch Shiny App to Performs Small Area Estimation</p></a></li>
<li><a href='#smoothing'><p>Variance Smoothing and Effective Sample Sizes Estimation</p></a></li>
<li><a href='#summary.fitsae'><p>Summary Method for <code>fitsae</code> Objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Tools for Handling Indices and Proportions in Small Area
Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>It allows for mapping proportions and indicators defined on the unit interval. It implements Beta-based small area methods comprising the classical Beta regression models, the Flexible Beta model and Zero and/or One Inflated extensions (Janicki 2020 &lt;<a href="https://doi.org/10.1080%2F03610926.2019.1570266">doi:10.1080/03610926.2019.1570266</a>&gt;). Such methods, developed within a Bayesian framework through Stan <a href="https://mc-stan.org/">https://mc-stan.org/</a>, come equipped with a set of diagnostics and complementary tools, visualizing and exporting functions. A Shiny application with a user-friendly interface can be launched to further simplify the process. For further details, refer to De Nicolò and Gardini (2024 &lt;<a href="https://doi.org/10.18637%2Fjss.v108.i01">doi:10.18637/jss.v108.i01</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), shiny (&ge; 1.0.3)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, Rcpp (&ge; 0.12.0), rstan (&ge; 2.26.0), ggplot2 (&ge;
3.3.2), nlme (&ge; 3.1.152), stats, sp, ggpubr, Rdpack</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rstantools (&ge; 2.1.1), RcppParallel (&ge; 5.0.1), callr, sf,
dplyr, leaflet, tmap, spam, spdep, gridExtra (&ge; 2.3), R.rsp,
shinythemes, shinyFeedback, shinybusy, shinyWidgets, shinyjs,
bayesplot, loo (&ge; 2.3.1)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH (&ge; 1.66.0), Rcpp (&ge; 0.12.0), RcppEigen (&ge; 0.3.3.3.0),
RcppParallel (&ge; 5.0.1), rstan (&ge; 2.26.0), StanHeaders (&ge;
2.26.0)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-26 16:36:57 UTC; aldo.gardini2</td>
</tr>
<tr>
<td>Author:</td>
<td>Silvia De Nicolò <a href="https://orcid.org/0000-0001-5052-6527"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Aldo Gardini <a href="https://orcid.org/0000-0002-2164-5815"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Silvia De Nicolò &lt;silvia.denicolo@unibo.it&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-26 23:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='tipsae-package'>The 'tipsae' Package.</h2><span id='topic+tipsae'></span><span id='topic+tipsae-package'></span>

<h3>Description</h3>

<p>It provides tools for mapping proportions and indicators defined on the unit interval, widely used to measure, for instance, unemployment, educational attainment and also disease prevalence. It implements Beta-based small area methods, particularly indicated for unit interval responses, comprising the classical Beta regression models, the Flexible Beta model and Zero and/or One Inflated extensions. Such methods, developed within a Bayesian framework, come equipped with a set of diagnostics and complementary tools, visualizing and exporting functions. A customized parallel computing is built-in to reduce the computational time. The features of the tipsae package assist the user in carrying out a complete SAE analysis through the entire process of estimation, validation and results presentation, making the application of Bayesian algorithms and complex SAE methods straightforward. A Shiny application with a user-friendly interface can be launched to further simplify the process.
</p>


<h3>Author(s)</h3>

<p>Silvia De Nicolò, <a href="mailto:silvia.denicolo@unibo.it">silvia.denicolo@unibo.it</a>
</p>
<p>Aldo Gardini, <a href="mailto:aldo.gardini@unibo.it">aldo.gardini@unibo.it</a>
</p>


<h3>References</h3>

<p>De Nicolò S, Gardini A (2024).
&ldquo;The R Package tipsae: Tools for Mapping Proportions and Indicators on the Unit Interval.&rdquo;
<em>Journal of Statistical Software</em>, <b>108</b>(1), 1&ndash;36.
<a href="https://doi.org/10.18637/jss.v108.i01">doi:10.18637/jss.v108.i01</a>.
</p>
<p>Stan Development Team (2020).
&ldquo;RStan: the R interface to Stan.&rdquo;
R package version 2.21.2, <a href="https://mc-stan.org/">https://mc-stan.org/</a>.
</p>
<p>Carpenter B, Gelman A, Hoffman MD, Lee D, Goodrich B, Betancourt M, Brubaker M, Guo J, Li P, Riddell A (2017).
&ldquo;Stan: A probabilistic programming language.&rdquo;
<em>Journal of Statistical Software</em>, <b>76</b>(1), 1&ndash;32.
</p>
<p>Janicki R (2020).
&ldquo;Properties of the beta regression model for small area estimation of proportions and application to estimation of poverty rates.&rdquo;
<em>Communications in Statistics-Theory and Methods</em>, <b>49</b>(9), 2264&ndash;2284.
</p>
<p>Vehtari A, Gelman A, Gabry J (2017).
&ldquo;Practical Bayesian model evaluation using leave-one-out cross-validation and WAIC.&rdquo;
<em>Statistics and Computing</em>, <b>27</b>(5), 1413&ndash;1432.
</p>
<p>Datta GS, Ghosh M, Steorts R, Maples J (2011).
&ldquo;Bayesian benchmarking with applications to small area estimation.&rdquo;
<em>Test</em>, <b>20</b>(3), 574&ndash;588.
</p>
<p>Kish L (1992).
&ldquo;Weighting for Unequal Pi.&rdquo;
<em>Journal of Official Statistics</em>, <b>8</b>(2), 183.
</p>
<p>Fabrizi E, Ferrante MR, Pacei S, Trivisano C (2011).
&ldquo;Hierarchical Bayes multivariate estimation of poverty rates based on increasing thresholds for small domains.&rdquo;
<em>Computational Statistics &amp; Data Analysis</em>, <b>55</b>(4), 1736&ndash;1747.
</p>
<p>Morris M, Wheeler-Martin K, Simpson D, Mooney SJ, Gelman A, DiMaggio C (2019).
&ldquo;Bayesian hierarchical spatial models: Implementing the Besag York Mollié model in stan.&rdquo;
<em>Spatial and Spatio-Temporal Epidemiology</em>, <b>31</b>, 100301.
</p>
<p>De Nicolò S, Ferrante MR, Pacei S (2023).
&ldquo;Small area estimation of inequality measures using mixtures of Beta.&rdquo;
<a href="https://doi.org/10.1093/jrsssa/qnad083">https://doi.org/10.1093/jrsssa/qnad083</a>.
</p>
<p>Chang W, Cheng J, Allaire JJ, Sievert C, Schloerke B, Xie Y, Allen J, McPherson J, Dipert A, Borges B (2021).
&ldquo;shiny: Web Application Framework for R.&rdquo;
R package version 1.6.0, <a href="https://CRAN.R-project.org/package=shiny">https://CRAN.R-project.org/package=shiny</a>.
</p>

<hr>
<h2 id='benchmark'>Benchmarking Procedure for Model-Based Estimates</h2><span id='topic+benchmark'></span>

<h3>Description</h3>

<p>The <code>benchmark()</code> function gives the chance to perform a benchmarking procedure on model-based estimates. Benchmarking could target solely the point estimates (single benchmarking) or, alternatively, also the ensemble variability (double benchmarking). Furthermore, an estimate of the overall posterior risk is provided, aggregated for all areas. This value is only yielded when in-sample areas are treated and a single benchmarking is performed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>benchmark(
  x,
  bench,
  share,
  method = c("raking", "ratio", "double"),
  H = NULL,
  time = NULL,
  areas = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="benchmark_+3A_x">x</code></td>
<td>
<p>Object of class <code>summary_fitsae</code>.</p>
</td></tr>
<tr><td><code id="benchmark_+3A_bench">bench</code></td>
<td>
<p>A numeric value denoting the benchmark for the whole set of areas or a subset of areas.</p>
</td></tr>
<tr><td><code id="benchmark_+3A_share">share</code></td>
<td>
<p>A numeric vector of areas weights, in case of proportions it denotes the population shares.</p>
</td></tr>
<tr><td><code id="benchmark_+3A_method">method</code></td>
<td>
<p>The method to be specified among <code>"raking"</code>, <code>"ratio"</code> and <code>"double"</code>, see details.</p>
</td></tr>
<tr><td><code id="benchmark_+3A_h">H</code></td>
<td>
<p>A numeric value denoting an additional benchmark, to be specified when the  <code>"double"</code> method is selected, corresponding to the ensemble variability.</p>
</td></tr>
<tr><td><code id="benchmark_+3A_time">time</code></td>
<td>
<p>A character string indicating the time period to be considered, in case of temporal models, where a benchmark can be specified only for one time period at a time.</p>
</td></tr>
<tr><td><code id="benchmark_+3A_areas">areas</code></td>
<td>
<p>If <code>NULL</code> (default option), benchmarking is done on the whole set of areas, alternatively it can be done on a subset of them by indicating a vector containing the names of subset areas.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function allows performing three different benchmarking methods, according to the argument method.  </p>
<ul>
<li><p> The <code>"ratio"</code> and <code>"raking"</code> methods provide benchmarked estimates that minimize the posterior expectation of the weighted squared error loss, see Datta et al. (2011) and <code>tipsae</code> vignette.  </p>
</li>
<li><p> The <code>"double"</code> method accounts for a further benchmark on the weighted ensemble variability, where <code>H</code> is a prespecified value of the estimators variability.</p>
</li></ul>



<h3>Value</h3>

<p>A <code>benchmark_fitsae</code> object being a list of the following elements:
</p>

<dl>
<dt><code>bench_est</code></dt><dd><p>A vector including the benchmarked estimates for each considered domain.</p>
</dd>
<dt><code>post_risk</code></dt><dd><p>A numeric value indicating an estimate of the overall posterior risk, aggregated for all areas. This value is only yielded when in-sample areas are treated and a single benchmarking is performed.</p>
</dd>
<dt><code>method</code></dt><dd><p>The benchmarking method performed as selected in the input argument.</p>
</dd>
<dt><code>time</code></dt><dd><p>The time considered as selected in the input argument.</p>
</dd>
<dt><code>areas</code></dt><dd><p>The areas considered as selected in the input argument.</p>
</dd>
<dt><code>data_obj</code></dt><dd><p>A list containing input objects including in-sample and out-of-sample relevant quantities.</p>
</dd>
<dt><code>model_settings</code></dt><dd><p>A list summarizing all the assumptions of the model: sampling likelihood, presence of intercept, dispersion parametrization, random effects priors and possible structures.</p>
</dd>
<dt><code>model_estimates</code></dt><dd><p>Posterior summaries of target parameters for in-sample areas.</p>
</dd>
<dt><code>model_estimates_oos</code></dt><dd><p>Posterior summaries of target parameters for out-of-sample areas.</p>
</dd>
<dt><code>is_oos</code></dt><dd><p>Logical vector defining whether each domain is out-of-sample or not.</p>
</dd>
<dt><code>direct_est</code></dt><dd><p>Vector of direct estimates for in-sample areas.</p>
</dd>
</dl>



<h3>References</h3>

<p>Datta GS, Ghosh M, Steorts R, Maples J (2011).
&ldquo;Bayesian benchmarking with applications to small area estimation.&rdquo;
<em>Test</em>, <b>20</b>(3), 574&ndash;588.
</p>
<p>De Nicolò S, Gardini A (2024).
&ldquo;The R Package tipsae: Tools for Mapping Proportions and Indicators on the Unit Interval.&rdquo;
<em>Journal of Statistical Software</em>, <b>108</b>(1), 1&ndash;36.
<a href="https://doi.org/10.18637/jss.v108.i01">doi:10.18637/jss.v108.i01</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.fitsae">summary.fitsae</a></code> to produce the input object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tipsae)

# loading toy dataset
data("emilia_cs")

# fitting a model

fit_beta &lt;- fit_sae(formula_fixed = hcr ~ x, data = emilia_cs, domains = "id",
                    type_disp = "var", disp_direct = "vars", domain_size = "n",
                    # MCMC setting to obtain a fast example. Remove next line for reliable results.
                    chains = 1, iter = 150, seed = 0)

# check model diagnostics
summ_beta &lt;- summary(fit_beta)

# creating a subset of the areas whose estimates have to be benchmarked
subset &lt;- c("RIMINI", "RICCIONE", "RUBICONE", "CESENA - VALLE DEL SAVIO")

# creating population shares of the subset areas
pop &lt;- emilia_cs$pop[emilia_cs$id %in% subset]
shares_subset &lt;- pop / sum(pop)

# perform benchmarking procedure
bmk_subset &lt;- benchmark(x = summ_beta,
                        bench = 0.13,
                        share = shares_subset,
                        method = "raking",
                        areas = subset)

# check benchmarked estimates and posterior risk
bmk_subset$bench_est
bmk_subset$post_risk





</code></pre>

<hr>
<h2 id='density.summary_fitsae'>Density Plot Function for a <code>summary_fitsae</code> Object</h2><span id='topic+density.summary_fitsae'></span>

<h3>Description</h3>

<p>The method <code>density()</code> provides, in a grid (default) or sequence, the density plot of direct estimates versus HB model estimates and the density plot of standardized posterior means of the random effects versus standard normal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary_fitsae'
density(x, grid = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="density.summary_fitsae_+3A_x">x</code></td>
<td>
<p>Object of class <code>summary_fitsae</code>.</p>
</td></tr>
<tr><td><code id="density.summary_fitsae_+3A_grid">grid</code></td>
<td>
<p>Logical indicating whether plots are displayed in a grid (<code>TRUE</code>) or in sequence (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="density.summary_fitsae_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Two <code>ggplot2</code> objects in a grid or in sequence.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.fitsae">summary.fitsae</a></code> to produce the input object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tipsae)

# loading toy dataset
data("emilia_cs")

# fitting a model
fit_beta &lt;- fit_sae(formula_fixed = hcr ~ x, data = emilia_cs, domains = "id",
                    type_disp = "var", disp_direct = "vars", domain_size = "n",
                    # MCMC setting to obtain a fast example. Remove next line for reliable results.
                    chains = 1, iter = 150, seed = 0)

# check model diagnostics
summ_beta &lt;- summary(fit_beta)

# visualize estimates and random effect densities via density() function
density(summ_beta)
</code></pre>

<hr>
<h2 id='emilia'>Poverty in Emilia-Romagna (Italy) Health Districts</h2><span id='topic+emilia'></span>

<h3>Description</h3>

<p>The <code>emilia</code> dataset consists of a panel on poverty mapping concerning 38 health districts within the Emilia-Romagna region, located in North-East of Italy, with annual observations recorded from 2014 to 2018.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emilia
</code></pre>


<h3>Format</h3>

<p>Dataframe with 190 observations and 8 variables.
</p>

<dl>
<dt><code>id</code></dt><dd><p>Character, name of the health district.</p>
</dd>
<dt><code>prov</code></dt><dd><p>Character, name of NUTS-3 region related to the district.</p>
</dd>
<dt><code>year</code></dt><dd><p>Numeric, year of the observation.</p>
</dd>
<dt><code>hcr</code></dt><dd><p>Numeric, head-count ratio estimate (used as response variable).</p>
</dd>
<dt><code>vars</code></dt><dd><p>Numeric, sampling variance of head-count ratio estimator.</p>
</dd>
<dt><code>n</code></dt><dd><p>Numeric, area sample size.</p>
</dd>
<dt><code>x</code></dt><dd><p>Numeric, fake covariate.</p>
</dd>
<dt><code>pop</code></dt><dd><p>Numeric, population size of the area.</p>
</dd>
</dl>



<h3>Details</h3>

<p>It has been built starting from model-based estimates and related CV freely available on Emilia-Romagna region <a href="https://statistica.regione.emilia-romagna.it/documentazione/pubblicazioni/documenti_catalogati/stima-poverta-2009-2018-distretti-sociosanitari-province-emilia-romagna">website</a>. Since it is used for illustrative purposes only, such estimates are assumed to be unreliable direct estimates, requiring a SAE procedure.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tipsae)
data("emilia")


</code></pre>

<hr>
<h2 id='emilia_cs'>Poverty in Emilia-Romagna (Italy) Health Districts in 2016</h2><span id='topic+emilia_cs'></span>

<h3>Description</h3>

<p>The <code>emilia</code> dataset consists of a dataset on poverty mapping concerning 38 health districts within the Emilia-Romagna region, located in North-East of Italy, with observations recorded in 2016.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emilia_cs
</code></pre>


<h3>Format</h3>

<p>Dataframe with 38 area observations and 8 variables.
</p>

<dl>
<dt><code>id</code></dt><dd><p>Character, name of the health district.</p>
</dd>
<dt><code>prov</code></dt><dd><p>Character, name of NUTS-3 region related to the district.</p>
</dd>
<dt><code>year</code></dt><dd><p>Numeric, year of the observation.</p>
</dd>
<dt><code>hcr</code></dt><dd><p>Numeric, head-count ratio estimate (used as response variable).</p>
</dd>
<dt><code>vars</code></dt><dd><p>Numeric, sampling variance of head-count ratio estimator.</p>
</dd>
<dt><code>n</code></dt><dd><p>Numeric, area sample size.</p>
</dd>
<dt><code>x</code></dt><dd><p>Numeric, fake covariate.</p>
</dd>
<dt><code>pop</code></dt><dd><p>Numeric, population size of the area.</p>
</dd>
</dl>



<h3>Details</h3>

<p>It has been built starting from model-based estimates and related CV freely available on Emilia-Romagna region <a href="https://statistica.regione.emilia-romagna.it/documentazione/pubblicazioni/documenti_catalogati/stima-poverta-2009-2018-distretti-sociosanitari-province-emilia-romagna">website</a>. Since it is used for illustrative purposes only, such estimates are assumed to be unreliable direct estimates, requiring a SAE procedure.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+emilia">emilia</a></code> for the panel dataset including observation from 2014 to 2018.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tipsae)
data("emilia_cs")

</code></pre>

<hr>
<h2 id='emilia_shp'>Shapefile of Emilia-Romagna (Italy) Health Districts</h2><span id='topic+emilia_shp'></span>

<h3>Description</h3>

<p>The <code>emilia_shp</code> shapefile consists of a <code>SpatialPolygonsDataFrame</code> object of 38 health districts within the Emilia-Romagna region, located in the North-East of Italy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emilia_shp
</code></pre>


<h3>Format</h3>

<p>A shapefile of class <code>SpatialPolygonsDataFrame</code>.
</p>

<dl>
<dt><code>COD_DIS_SA</code></dt><dd><p>Code of the health district.</p>
</dd>
<dt><code>NAME_DISTRICT</code></dt><dd><p>Name of the health district. It can be linked to the variable <code>id</code> in <code><a href="#topic+emilia">emilia</a></code> and <code><a href="#topic+emilia_cs">emilia_cs</a></code></p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+emilia">emilia</a></code> and <code><a href="#topic+emilia_cs">emilia_cs</a></code> for the provided datasets.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tipsae)
library(sp)
data("emilia_shp")


</code></pre>

<hr>
<h2 id='export'>Exporting Results of a Small Area Model Fitting</h2><span id='topic+export'></span>

<h3>Description</h3>

<p>The function <code>export()</code> allows for exporting model estimates in CSV format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export(x, file, type = "all", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="export_+3A_x">x</code></td>
<td>
<p>An object of class <code>estimates_fitsae</code>.</p>
</td></tr>
<tr><td><code id="export_+3A_file">file</code></td>
<td>
<p>A character string indicating the path (if different from the working directory) and filename of the CSV to be created. It should end with .csv.</p>
</td></tr>
<tr><td><code id="export_+3A_type">type</code></td>
<td>
<p>An option between <code>"in"</code>, <code>"out"</code> and <code>"all"</code>, indicating whether to export only in or out-of-sample areas or both.</p>
</td></tr>
<tr><td><code id="export_+3A_...">...</code></td>
<td>
<p>Additional arguments of <code><a href="utils.html#topic+write.csv">write.csv</a></code> function from <code>utils</code> package can be indicated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A CSV file is created in the working directory, or at the given path, exporting the <code>estimates_fitsae</code> object given as input.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extract">extract</a></code> to produce the input object and <code><a href="utils.html#topic+write.csv">write.csv</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(tipsae)

# loading toy dataset
data("emilia_cs")

# fitting a model
fit_beta &lt;- fit_sae(formula_fixed = hcr ~ x, data = emilia_cs, domains = "id",
                    type_disp = "var", disp_direct = "vars", domain_size = "n",
                    # MCMC setting to obtain a fast example. Remove next line for reliable results.
                    chains = 1, iter = 150, seed = 0)

# check model diagnostics
summ_beta &lt;- summary(fit_beta)

# extract model estimates
HB_estimates &lt;- extract(summ_beta)

# export model estimates
export(HB_estimates, file = "results.csv", type = "all")

## End(Not run)


</code></pre>

<hr>
<h2 id='extract'>Extract Posterior Summaries of Target Parameters</h2><span id='topic+extract'></span>

<h3>Description</h3>

<p>The <code>extract()</code> function provides the posterior summaries of target parameters, including model-based estimates, and possibly benchmarked estimates, related to a fitted small area model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_+3A_x">x</code></td>
<td>
<p>An object of class <code>summary_fitsae</code> or <code>benchmark_fitsae</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>estimates_fitsae</code>, being a list of two data frames, distinguishing between <code style="white-space: pre;">&#8288;$in_sample&#8288;</code> and <code style="white-space: pre;">&#8288;$out_of_sample&#8288;</code> areas, which gathers domains name, direct and HB estimates, as well as posterior summaries of target parameters. When the input is a <code>benchmark_fitsae</code> object, benchmarked estimates are also included.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.fitsae">summary.fitsae</a></code> and <code><a href="#topic+benchmark">benchmark</a></code> to produce the input object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tipsae)

# loading toy dataset
data("emilia_cs")

# fitting a model
fit_beta &lt;- fit_sae(formula_fixed = hcr ~ x, data = emilia_cs, domains = "id",
                    type_disp = "var", disp_direct = "vars", domain_size = "n",
                    # MCMC setting to obtain a fast example. Remove next line for reliable results.
                    chains = 1, iter = 150, seed = 0)

# check model diagnostics
summ_beta &lt;- summary(fit_beta)

# extract model estimates
HB_estimates &lt;- extract(summ_beta)
head(HB_estimates)


</code></pre>

<hr>
<h2 id='fit_sae'>Fitting a Small Area Model</h2><span id='topic+fit_sae'></span>

<h3>Description</h3>

<p><code>fit_sae()</code> is used to fit Beta-based small area models, such as the classical Beta, zero and/or one inflated Beta and Flexible Beta models. The random effect part can incorporate either a temporal and/or a spatial dependency structure devoted to the prior specification settings. In addition, different prior assumptions can be specified for the unstructured random effects, allowing for robust and shrinking priors and different parametrizations can be set up.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_sae(
  formula_fixed,
  data,
  domains = NULL,
  disp_direct,
  type_disp = c("neff", "var"),
  domain_size = NULL,
  likelihood = c("beta", "flexbeta", "Infbeta0", "Infbeta1", "Infbeta01"),
  prior_reff = c("normal", "t", "VG"),
  spatial_error = FALSE,
  spatial_df = NULL,
  domains_spatial_df = NULL,
  temporal_error = FALSE,
  temporal_variable = NULL,
  scale_prior = list(Unstructured = 2.5, Spatial = 2.5, Temporal = 2.5, Coeff. = 2.5),
  adapt_delta = 0.95,
  max_treedepth = 10,
  init = "0",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_sae_+3A_formula_fixed">formula_fixed</code></td>
<td>
<p>An object of class <code>"formula"</code> specifying the linear regression fixed part at the linking level.</p>
</td></tr>
<tr><td><code id="fit_sae_+3A_data">data</code></td>
<td>
<p>An object of class <code>"data.frame"</code> containing all relevant quantities.</p>
</td></tr>
<tr><td><code id="fit_sae_+3A_domains">domains</code></td>
<td>
<p>Data column name displaying the domain names. If <code>NULL</code> (default), the domains are denoted with a progressive number.</p>
</td></tr>
<tr><td><code id="fit_sae_+3A_disp_direct">disp_direct</code></td>
<td>
<p>Data column name displaying given values of sampling dispersion for each domain. In out-of-sample areas, dispersion must be <code>NA</code>.</p>
</td></tr>
<tr><td><code id="fit_sae_+3A_type_disp">type_disp</code></td>
<td>
<p>Parametrization of the dispersion parameter. The choices are variance (<code>"var"</code>) or <code class="reqn">\phi_d</code> + 1 (<code>"neff"</code>) parameter.</p>
</td></tr>
<tr><td><code id="fit_sae_+3A_domain_size">domain_size</code></td>
<td>
<p>Data column name indicating domain sizes (optional). In out-of-sample areas, sizes must be <code>NA</code>.</p>
</td></tr>
<tr><td><code id="fit_sae_+3A_likelihood">likelihood</code></td>
<td>
<p>Sampling likelihood to be used. The choices are <code>"beta"</code> (default), <code>"flexbeta"</code>, <code>"Infbeta0"</code>, <code>"Infbeta1"</code> and <code>"Infbeta01"</code>.</p>
</td></tr>
<tr><td><code id="fit_sae_+3A_prior_reff">prior_reff</code></td>
<td>
<p>Prior distribution of the unstructured random effect. The choices are: <code>"normal"</code>, <code>"t"</code>, <code>"VG"</code>.</p>
</td></tr>
<tr><td><code id="fit_sae_+3A_spatial_error">spatial_error</code></td>
<td>
<p>Logical indicating whether to include a spatially structured random effect.</p>
</td></tr>
<tr><td><code id="fit_sae_+3A_spatial_df">spatial_df</code></td>
<td>
<p>Object of class <code>SpatialPolygonsDataFrame</code> or <code>sf</code> with the shapefile of the studied region. Required if <code>spatial_error = TRUE</code>.</p>
</td></tr>
<tr><td><code id="fit_sae_+3A_domains_spatial_df">domains_spatial_df</code></td>
<td>
<p>Column name of the <code>spatial_df</code> object displaying the domain names. Required if <code>spatial_error = TRUE</code>.</p>
</td></tr>
<tr><td><code id="fit_sae_+3A_temporal_error">temporal_error</code></td>
<td>
<p>Logical indicating whether to include a temporally structured random effect.</p>
</td></tr>
<tr><td><code id="fit_sae_+3A_temporal_variable">temporal_variable</code></td>
<td>
<p>Data column name indicating temporal variable. Required if <code>temporal_error = TRUE</code>.</p>
</td></tr>
<tr><td><code id="fit_sae_+3A_scale_prior">scale_prior</code></td>
<td>
<p>List with the values of the prior scales. 4 named elements must be provided: &quot;Unstructured&quot;, &quot;Spatial&quot;, &quot;Temporal&quot;, &quot;Coeff.&quot;. Default: all equal to 2.5.</p>
</td></tr>
<tr><td><code id="fit_sae_+3A_adapt_delta">adapt_delta</code></td>
<td>
<p>HMC option: target average proposal acceptance probability. See <code><a href="rstan.html#topic+stan">stan</a></code> documentation.</p>
</td></tr>
<tr><td><code id="fit_sae_+3A_max_treedepth">max_treedepth</code></td>
<td>
<p>HMC option: target average proposal acceptance probability. See <code><a href="rstan.html#topic+stan">stan</a></code> documentation.</p>
</td></tr>
<tr><td><code id="fit_sae_+3A_init">init</code></td>
<td>
<p>Initial values specification. See the detailed documentation for 
the init argument in <code><a href="rstan.html#topic+stan">stan</a></code>.</p>
</td></tr>
<tr><td><code id="fit_sae_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="rstan.html#topic+sampling">sampling</a></code> (e.g. iter, chains).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>fitsae</code> containing the following objects:
</p>

<dl>
<dt><code>model_settings</code></dt><dd><p>A list summarizing all the assumptions of the model: sampling likelihood, presence of intercept, dispersion parametrization, random effects priors and possible structures.</p>
</dd>
<dt><code>data_obj</code></dt><dd><p>A list containing input objects including in-sample and out-of-sample relevant quantities.</p>
</dd>
<dt><code>stanfit</code></dt><dd><p>A <code>stanfit</code> object, outcome of <code><a href="rstan.html#topic+sampling">sampling</a></code> function containing full posterior draws. For details, see <code><a href="rstan.html#topic+stan">stan</a></code> documentation.</p>
</dd>
<dt><code>pars_interest</code></dt><dd><p>A vector containing the names of parameters whose posterior samples are stored.</p>
</dd>
<dt><code>call</code></dt><dd><p>Image of the function call that produced the <code>fitsae</code> object.</p>
</dd>
</dl>



<h3>References</h3>

<p>Janicki R (2020).
&ldquo;Properties of the beta regression model for small area estimation of proportions and application to estimation of poverty rates.&rdquo;
<em>Communications in Statistics-Theory and Methods</em>, <b>49</b>(9), 2264&ndash;2284.
</p>
<p>Carpenter B, Gelman A, Hoffman MD, Lee D, Goodrich B, Betancourt M, Brubaker M, Guo J, Li P, Riddell A (2017).
&ldquo;Stan: A probabilistic programming language.&rdquo;
<em>Journal of Statistical Software</em>, <b>76</b>(1), 1&ndash;32.
</p>
<p>Morris M, Wheeler-Martin K, Simpson D, Mooney SJ, Gelman A, DiMaggio C (2019).
&ldquo;Bayesian hierarchical spatial models: Implementing the Besag York Mollié model in stan.&rdquo;
<em>Spatial and Spatio-Temporal Epidemiology</em>, <b>31</b>, 100301.
</p>
<p>De Nicolò S, Ferrante MR, Pacei S (2023).
&ldquo;Small area estimation of inequality measures using mixtures of Beta.&rdquo;
<a href="https://doi.org/10.1093/jrsssa/qnad083">https://doi.org/10.1093/jrsssa/qnad083</a>.
</p>
<p>De Nicolò S, Gardini A (2024).
&ldquo;The R Package tipsae: Tools for Mapping Proportions and Indicators on the Unit Interval.&rdquo;
<em>Journal of Statistical Software</em>, <b>108</b>(1), 1&ndash;36.
<a href="https://doi.org/10.18637/jss.v108.i01">doi:10.18637/jss.v108.i01</a>.
</p>


<h3>See Also</h3>

<p><code><a href="rstan.html#topic+sampling">sampling</a></code> for sampler options and <code><a href="#topic+summary.fitsae">summary.fitsae</a></code> for handling the output.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tipsae)

# loading toy cross sectional dataset
data("emilia_cs")

# fitting a cross sectional model
fit_beta &lt;- fit_sae(formula_fixed = hcr ~ x, data = emilia_cs, domains = "id",
                    type_disp = "var", disp_direct = "vars", domain_size = "n",
                    # MCMC setting to obtain a fast example. Remove next line for reliable results.
                    chains = 1, iter = 150, seed = 0)


# Spatio-temporal model: it might require time to be fitted
## Not run: 
# loading toy panel dataset
data("emilia")
# loading the shapefile of the concerned areas
data("emilia_shp")

# fitting a spatio-temporal model
fit_ST &lt;- fit_sae(formula_fixed = hcr ~ x,
                  domains = "id",
                  disp_direct = "vars",
                  type_disp = "var",
                  domain_size = "n",
                  data = emilia,
                  spatial_error = TRUE,
                  spatial_df = emilia_shp,
                  domains_spatial_df = "NAME_DISTRICT",
                  temporal_error = TRUE,
                  temporal_variable = "year",
                  max_treedepth = 15,
                  seed = 0)

## End(Not run)

</code></pre>

<hr>
<h2 id='map'>Map Relevant Quantities from a Small Area Model</h2><span id='topic+map'></span>

<h3>Description</h3>

<p>The <code>map()</code> function enables to plot maps containing relevant model outputs by accounting for their geographical dimension. The shapefile of the area must be provided via a <code>SpatialPolygonsDataFrame</code> or <code>sf</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map(
  x,
  spatial_df,
  spatial_id_domains,
  match_names = NULL,
  color_palette = c("snow2", "deepskyblue4"),
  quantity = c("HB_est", "Direct_est", "SD"),
  time = NULL,
  style = "quantile",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map_+3A_x">x</code></td>
<td>
<p>An object of class <code>summary_fitsae</code> or <code>benchmark_fitsae</code>.</p>
</td></tr>
<tr><td><code id="map_+3A_spatial_df">spatial_df</code></td>
<td>
<p>A object of class <code>SpatialPolygonsDataFrame</code> (spatial polygons object) from <code>sp</code> package or <code>sf</code> from the <code>sf</code> package, accounting for the geographical dimension of the domains.</p>
</td></tr>
<tr><td><code id="map_+3A_spatial_id_domains">spatial_id_domains</code></td>
<td>
<p>A character string indicating the name of <code>spatial_df</code> variable containing area denominations, in order to correctly match the areas.</p>
</td></tr>
<tr><td><code id="map_+3A_match_names">match_names</code></td>
<td>
<p>An encoding two-columns <code>data.frame</code>: the first with the original data coding (domains) and the second one with corresponding <code>spatial_df</code> object labels. This argument has to be specified only if <code>spatial_df</code> object labels do not match the ones provided through the original dataset.</p>
</td></tr>
<tr><td><code id="map_+3A_color_palette">color_palette</code></td>
<td>
<p>A vector with two color strings denoting the extreme bounds of colors range to be used.</p>
</td></tr>
<tr><td><code id="map_+3A_quantity">quantity</code></td>
<td>
<p>A string indicating the quantity to be mapped. When a <code>summary_fitsae</code> is given as input, it can be selected among <code>"HB_est"</code> (model-based estimates), <code>"SD"</code>(posterior standard deviations) and <code>"Direct_est"</code>(direct estimates). While when a <code>benchmark_fitsae</code> class object is given as input, this argument turns automatically to <code>"Bench_est"</code>, displaying the benchmarked estimates.</p>
</td></tr>
<tr><td><code id="map_+3A_time">time</code></td>
<td>
<p>A string indicating the year of interest for the quantities to be treated, in case of temporal or spatio-temporal objects.</p>
</td></tr>
<tr><td><code id="map_+3A_style">style</code></td>
<td>
<p>Method to process the color scale, see <code><a href="tmap.html#topic+tmap">tmap</a></code> documentation.</p>
</td></tr>
<tr><td><code id="map_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="tmap.html#topic+tm_fill">tm_fill</a></code> (e.g. n, breaks).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A<code>tmap</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.fitsae">summary.fitsae</a></code> to produce the input object and <code><a href="sp.html#topic+SpatialPolygonsDataFrame">SpatialPolygonsDataFrame</a></code> to manage the shapefile.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(tipsae)

# loading toy dataset
data("emilia_cs")

# fitting a model
fit_beta &lt;- fit_sae(formula_fixed = hcr ~ x, data = emilia_cs, domains = "id",
                    type_disp = "var", disp_direct = "vars", domain_size = "n",
                    # MCMC setting to obtain a fast example. Remove next line for reliable results.
                    chains = 1, iter = 150, seed = 0)

# check model diagnostics
summ_beta &lt;- summary(fit_beta)

# load shapefile of concerned areas
data("emilia_shp")

# plot the map using model diagnostics and areas shapefile
map(x = summ_beta,
   spatial_df = emilia_shp,
   spatial_id_domains = "NAME_DISTRICT")
 
## End(Not run)
</code></pre>

<hr>
<h2 id='plot.benchmark_fitsae'>Plot Method for <code>benchmark_fitsae</code> Object</h2><span id='topic+plot.benchmark_fitsae'></span>

<h3>Description</h3>

<p>The method <code>plot()</code> provides the boxplots of original and benchmarked estimates in comparison with the benchmark value. Note that share weights are not considered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'benchmark_fitsae'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.benchmark_fitsae_+3A_x">x</code></td>
<td>
<p>A <code>benchmark_fitsae</code> object.</p>
</td></tr>
<tr><td><code id="plot.benchmark_fitsae_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+benchmark">benchmark</a></code> to produce the input object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tipsae)

# loading toy dataset
data("emilia_cs")

# fitting a model
fit_beta &lt;- fit_sae(formula_fixed = hcr ~ x, data = emilia_cs, domains = "id",
                    type_disp = "var", disp_direct = "vars", domain_size = "n",
                    # MCMC setting to obtain a fast example. Remove next line for reliable results.
                    chains = 1, iter = 150, seed = 0)

# check model diagnostics
summ_beta &lt;- summary(fit_beta)

# creating a subset of the areas whose estimates have to be benchmarked
subset &lt;- c("RIMINI", "RICCIONE", "RUBICONE", "CESENA - VALLE DEL SAVIO")

# creating population shares of the subset areas
pop &lt;- emilia_cs$pop[emilia_cs$id %in% subset]
shares_subset &lt;- pop / sum(pop)

# perform benchmarking procedure
bmk_subset &lt;- benchmark(x = summ_beta,
                        bench = 0.13,
                        share = shares_subset,
                        method = "raking",
                        areas = subset)
plot(bmk_subset)


</code></pre>

<hr>
<h2 id='plot.smoothing_fitsae'>Plot Method for <code>smoothing_fitsae</code> Object</h2><span id='topic+plot.smoothing_fitsae'></span>

<h3>Description</h3>

<p>The <code>plot()</code> method provides (a) the boxplot of variance estimates, when effective sample sizes are estimated through <code>kish</code> method; (b) a scatterplot of both original and smoothed estimates versus the area sample sizes, when variance smoothing is performed through methods <code>ols</code> and <code>gls</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smoothing_fitsae'
plot(x, size = 2.5, alpha = 0.8, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.smoothing_fitsae_+3A_x">x</code></td>
<td>
<p>A <code>smoothing_fitsae</code> object.</p>
</td></tr>
<tr><td><code id="plot.smoothing_fitsae_+3A_size">size</code></td>
<td>
<p>Aesthetic option denoting the size of scatterplots points, see <code><a href="ggplot2.html#topic+geom_point">geom_point</a></code> documentation.</p>
</td></tr>
<tr><td><code id="plot.smoothing_fitsae_+3A_alpha">alpha</code></td>
<td>
<p>Aesthetic option denoting the opacity of scatterplots points, see <code><a href="ggplot2.html#topic+geom_point">geom_point</a></code> documentation.</p>
</td></tr>
<tr><td><code id="plot.smoothing_fitsae_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smoothing">smoothing</a></code> to produce the input object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tipsae)

# loading toy dataset
data("emilia_cs")

# perform smoothing procedure
smoo &lt;- smoothing(emilia_cs, direct_estimates = "hcr", area_id = "id",
                  raw_variance = "vars", areas_sample_sizes = "n",
                  var_function = NULL, method = "ols")
plot(smoo)

</code></pre>

<hr>
<h2 id='plot.summary_fitsae'>Plot Method for a <code>summary_fitsae</code> Object</h2><span id='topic+plot.summary_fitsae'></span>

<h3>Description</h3>

<p>The generic method <code>plot()</code> provides, in a grid (default) or sequence, (a) a scatterplot of direct estimates versus model-based estimates, visually capturing the shrinking process, (b) a Bayesian P-values histogram, (c) a boxplot of standard deviation reduction values, and, if areas sample sizes are provided as input in <code>fit_sae()</code>, (d) a scatterplot of model residuals versus sample sizes, in order to check for design-consistency i.e., as long as sizes increase residuals should converge to zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary_fitsae'
plot(
  x,
  size = 2.5,
  alpha = 0.8,
  n_bins = 15,
  grid = TRUE,
  label_names = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.summary_fitsae_+3A_x">x</code></td>
<td>
<p>Object of class <code>summary_fitsae</code>.</p>
</td></tr>
<tr><td><code id="plot.summary_fitsae_+3A_size">size</code></td>
<td>
<p>Aesthetic option denoting the size of scatterplots points, see <code><a href="ggplot2.html#topic+geom_point">geom_point</a></code> documentation.</p>
</td></tr>
<tr><td><code id="plot.summary_fitsae_+3A_alpha">alpha</code></td>
<td>
<p>Aesthetic option denoting the opacity of scatterplots points, see <code><a href="ggplot2.html#topic+geom_point">geom_point</a></code> documentation.</p>
</td></tr>
<tr><td><code id="plot.summary_fitsae_+3A_n_bins">n_bins</code></td>
<td>
<p>Denoting the number of bins used for histogram.</p>
</td></tr>
<tr><td><code id="plot.summary_fitsae_+3A_grid">grid</code></td>
<td>
<p>Logical indicating whether plots are displayed in a grid (<code>TRUE</code>) or in sequence (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.summary_fitsae_+3A_label_names">label_names</code></td>
<td>
<p>Character string indicating the model name to display in boxplot x-axis label.</p>
</td></tr>
<tr><td><code id="plot.summary_fitsae_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Four <code>ggplot2</code> objects in a grid.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.fitsae">summary.fitsae</a></code> to produce the input object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tipsae)

# loading toy dataset
data("emilia_cs")

# fitting a model
fit_beta &lt;- fit_sae(formula_fixed = hcr ~ x, data = emilia_cs, domains = "id",
                    type_disp = "var", disp_direct = "vars", domain_size = "n",
                    # MCMC setting to obtain a fast example. Remove next line for reliable results.
                    chains = 1, iter = 150, seed = 0)

# check model diagnostics
summ_beta &lt;- summary(fit_beta)

# visualize diagnostics via plot() method
plot(summ_beta)

</code></pre>

<hr>
<h2 id='print.benchmark_fitsae'>Print Method for a <code>benchmark_fitsae</code> Object</h2><span id='topic+print.benchmark_fitsae'></span>

<h3>Description</h3>

<p>The generic method <code>print()</code> allow to explore relevant outputs of the input object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'benchmark_fitsae'
print(x, digits = 3L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.benchmark_fitsae_+3A_x">x</code></td>
<td>
<p>Object of class <code>benchmark_fitsae</code>.</p>
</td></tr>
<tr><td><code id="print.benchmark_fitsae_+3A_digits">digits</code></td>
<td>
<p>Number of digits to display.</p>
</td></tr>
<tr><td><code id="print.benchmark_fitsae_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Printed information on a <code>benchmark_fitsae</code> object.
</p>

<hr>
<h2 id='print.estimates_fitsae'>Print Method for a <code>estimates_fitsae</code> Object</h2><span id='topic+print.estimates_fitsae'></span>

<h3>Description</h3>

<p>The generic method <code>print()</code> allow to explore relevant outputs of the input object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'estimates_fitsae'
print(x, digits = 3L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.estimates_fitsae_+3A_x">x</code></td>
<td>
<p>Object of class <code>estimates_fitsae</code>.</p>
</td></tr>
<tr><td><code id="print.estimates_fitsae_+3A_digits">digits</code></td>
<td>
<p>Number of digits to display.</p>
</td></tr>
<tr><td><code id="print.estimates_fitsae_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Printed information on a <code>estimates_fitsae</code> object.
</p>

<hr>
<h2 id='print.fitsae'>Print Method for a <code>fitsae</code> Object</h2><span id='topic+print.fitsae'></span>

<h3>Description</h3>

<p>The generic method <code>print()</code> allow to explore relevant outputs of the input object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fitsae'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.fitsae_+3A_x">x</code></td>
<td>
<p>Object of class <code>fitsae</code>.</p>
</td></tr>
<tr><td><code id="print.fitsae_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Printed information on a <code>fitsae</code> object.
</p>

<hr>
<h2 id='print.smoothing_fitsae'>Print Method for a <code>smoothing_fitsae</code> Object</h2><span id='topic+print.smoothing_fitsae'></span>

<h3>Description</h3>

<p>The generic method <code>print()</code> allow to explore relevant outputs of the input object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smoothing_fitsae'
print(x, digits = 3L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.smoothing_fitsae_+3A_x">x</code></td>
<td>
<p>Object of class <code>smoothing_fitsae</code>.</p>
</td></tr>
<tr><td><code id="print.smoothing_fitsae_+3A_digits">digits</code></td>
<td>
<p>Number of digits to display.</p>
</td></tr>
<tr><td><code id="print.smoothing_fitsae_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Printed information on a <code>smoothing_fitsae</code> object.
</p>

<hr>
<h2 id='print.summary_fitsae'>Print Method for a <code>summary_fitsae</code> Object</h2><span id='topic+print.summary_fitsae'></span>

<h3>Description</h3>

<p>The generic method <code>print()</code> allow to explore relevant outputs of the input object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary_fitsae'
print(x, digits = 3L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary_fitsae_+3A_x">x</code></td>
<td>
<p>Object of class <code>summary_fitsae</code>.</p>
</td></tr>
<tr><td><code id="print.summary_fitsae_+3A_digits">digits</code></td>
<td>
<p>Number of digits to display.</p>
</td></tr>
<tr><td><code id="print.summary_fitsae_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Printed information on a <code>summary_fitsae</code> object.
</p>

<hr>
<h2 id='runShiny_tipsae'>Lauch Shiny App to Performs Small Area Estimation</h2><span id='topic+runShiny_tipsae'></span>

<h3>Description</h3>

<p>The command launches a Shiny application that assists the user from the data loading step to the export of the outputs. See the vignette for further details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runShiny_tipsae()
</code></pre>


<h3>Value</h3>

<p>No value returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tipsae)

# Starting the Shiny application
if(interactive()){
 runShiny_tipsae()
}



</code></pre>

<hr>
<h2 id='smoothing'>Variance Smoothing and Effective Sample Sizes Estimation</h2><span id='topic+smoothing'></span>

<h3>Description</h3>

<p>The <code>smoothing()</code> function implements three methods, all yielding refined estimates of either variance or effective sample size, to account for indicators with different variance functions. The output estimates are ready to be used as known parameters in an area-level model, and they need to be added to the analysed <code>data.frame</code> object. All the implemented methods enable the estimation of the effective sample sizes, whereas <code>"ols"</code> and <code>"gls"</code> also perform a variance smoothing procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smoothing(
  data,
  direct_estimates,
  area_id = NULL,
  raw_variance = NULL,
  areas_sample_sizes = NULL,
  additional_covariates = NULL,
  method = c("ols", "gls", "kish"),
  var_function = NULL,
  survey_data = NULL,
  survey_area_id = NULL,
  weights = NULL,
  sizes = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smoothing_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> object including the direct estimates.</p>
</td></tr>
<tr><td><code id="smoothing_+3A_direct_estimates">direct_estimates</code></td>
<td>
<p>Character string specifying the variable in <code>data</code> denoting the direct estimates.</p>
</td></tr>
<tr><td><code id="smoothing_+3A_area_id">area_id</code></td>
<td>
<p>Character string indicating the variable with domain names included in <code>data</code>, to be specified if method <code>"kish"</code> is selected.</p>
</td></tr>
<tr><td><code id="smoothing_+3A_raw_variance">raw_variance</code></td>
<td>
<p>Character string indicating the variable name for raw variance estimates included in <code>data</code> object, to be specified if methods <code>"ols"</code> or <code>"gls"</code> are selected.</p>
</td></tr>
<tr><td><code id="smoothing_+3A_areas_sample_sizes">areas_sample_sizes</code></td>
<td>
<p>Character string indicating the variable name for domain sample sizes included in <code>data</code> object, to be specified if methods <code>"ols"</code> or <code>"gls"</code> are selected.</p>
</td></tr>
<tr><td><code id="smoothing_+3A_additional_covariates">additional_covariates</code></td>
<td>
<p>A vector of character strings indicating the variable names of possible additional covariates, included in <code>data</code>, to be added to the smoothing procedure if methods <code>"ols"</code> or <code>"gls"</code> are selected.</p>
</td></tr>
<tr><td><code id="smoothing_+3A_method">method</code></td>
<td>
<p>The method to be used. The choices are <code>"kish"</code>,<code>"ols"</code> and <code>"gls"</code>.</p>
</td></tr>
<tr><td><code id="smoothing_+3A_var_function">var_function</code></td>
<td>
<p>An object of class <code>function</code> denoting the variance function of the response variable. The default option (<code>NULL</code>) matches the proportion case being equal to <code>function(x) x * (1 - x)</code>. If an alternative function is specified, only variance estimates are provided.</p>
</td></tr>
<tr><td><code id="smoothing_+3A_survey_data">survey_data</code></td>
<td>
<p>An additional dataset to be specified when method <code>"kish"</code> is selected, defined at sampling unit level (e.g., households) and comprising sampling weights, unit sizes and domain names.</p>
</td></tr>
<tr><td><code id="smoothing_+3A_survey_area_id">survey_area_id</code></td>
<td>
<p>Character string indicating the variable denoting the domain names included in the <code>survey_data</code> object.</p>
</td></tr>
<tr><td><code id="smoothing_+3A_weights">weights</code></td>
<td>
<p>Character string indicating the variable including sampling weights in <code>survey_data</code> object.</p>
</td></tr>
<tr><td><code id="smoothing_+3A_sizes">sizes</code></td>
<td>
<p>Character string indicating the variable including unit sizes in <code>survey_data</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>smoothing_fitsae</code>, being a list of vectors including dispersion estimates: the variances and, when no alternative variance functions are specified, the effective sample sizes. When <code>"ols"</code> or <code>"gls"</code> method has been selected, the list incorporates also an object of class <code><a href="nlme.html#topic+gls">gls</a></code> from <code>nlme</code> package.
</p>


<h3>References</h3>

<p>Kish L (1992).
&ldquo;Weighting for Unequal Pi.&rdquo;
<em>Journal of Official Statistics</em>, <b>8</b>(2), 183.
</p>
<p>Fabrizi E, Ferrante MR, Pacei S, Trivisano C (2011).
&ldquo;Hierarchical Bayes multivariate estimation of poverty rates based on increasing thresholds for small domains.&rdquo;
<em>Computational Statistics &amp; Data Analysis</em>, <b>55</b>(4), 1736&ndash;1747.
</p>
<p>De Nicolò S, Gardini A (2024).
&ldquo;The R Package tipsae: Tools for Mapping Proportions and Indicators on the Unit Interval.&rdquo;
<em>Journal of Statistical Software</em>, <b>108</b>(1), 1&ndash;36.
<a href="https://doi.org/10.18637/jss.v108.i01">doi:10.18637/jss.v108.i01</a>.
</p>


<h3>See Also</h3>

<p><code><a href="nlme.html#topic+gls">gls</a></code> for details on estimation procedure for <code>"ols"</code> and <code>"gls"</code> methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tipsae)

# loading toy dataset
data("emilia_cs")

# perform smoothing procedure
smoo &lt;- smoothing(emilia_cs, direct_estimates = "hcr", area_id = "id",
                  raw_variance = "vars", areas_sample_sizes = "n",
                  var_function = NULL, method = "ols")

</code></pre>

<hr>
<h2 id='summary.fitsae'>Summary Method for <code>fitsae</code> Objects</h2><span id='topic+summary.fitsae'></span>

<h3>Description</h3>

<p>Summarizing the small area model fitting through the distributions of estimated parameters and derived diagnostics using posterior draws.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fitsae'
summary(
  object,
  probs = c(0.025, 0.25, 0.5, 0.75, 0.975),
  compute_loo = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.fitsae_+3A_object">object</code></td>
<td>
<p>An instance of class <code>fitsae</code>.</p>
</td></tr>
<tr><td><code id="summary.fitsae_+3A_probs">probs</code></td>
<td>
<p>A numeric vector of <code><a href="stats.html#topic+quantile">quantile</a></code>s of interest. 
The default is <code>c(0.025,0.25,0.5,0.75,0.975)</code>.</p>
</td></tr>
<tr><td><code id="summary.fitsae_+3A_compute_loo">compute_loo</code></td>
<td>
<p>Logical, indicating whether to compute <code><a href="loo.html#topic+loo">loo</a></code> diagnostics or not.</p>
</td></tr>
<tr><td><code id="summary.fitsae_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If printed, the produced summary displays: </p>
<ul>
<li><p> Posterior summaries about the fixed effect coefficients and the scale parameters related to unstructured and possible structured random effects. </p>
</li>
<li><p> Model diagnostics summaries of (a) model residuals; (b) standard deviation reductions; (c) Bayesian P-values obtained with the MCMC samples. </p>
</li>
<li><p> Shrinking Bound Rate. </p>
</li>
<li> <p><code><a href="loo.html#topic+loo">loo</a></code> information criteria and related diagnostics from the <code>loo</code> package.</p>
</li></ul>



<h3>Value</h3>

<p>A list of class <code>summary_fitsae</code> containing diagnostics objects:
</p>

<dl>
<dt><code>raneff</code></dt><dd><p>A list of <code>data.frame</code> objects storing the random effects posterior summaries divided for each type: <code style="white-space: pre;">&#8288;$unstructured&#8288;</code>, <code style="white-space: pre;">&#8288;$temporal&#8288;</code>, and <code style="white-space: pre;">&#8288;$spatial&#8288;</code>.</p>
</dd>
<dt><code>fixed_coeff</code></dt><dd><p>Posterior summaries of fixed coefficients.</p>
</dd>
<dt><code>var_comp</code></dt><dd><p>Posterior summaries of model variance parameters.</p>
</dd>
<dt><code>model_estimates</code></dt><dd><p>Posterior summaries of the parameter of interest <code class="reqn">\theta_d</code> for each in-sample domain <code class="reqn">d</code>.</p>
</dd>
<dt><code>model_estimates_oos</code></dt><dd><p>Posterior summaries of the parameter of interest <code class="reqn">\theta_d</code> for each out-of-sample domain <code class="reqn">d</code>.</p>
</dd>
<dt><code>is_oos</code></dt><dd><p>Logical vector defining whether each domain is out-of-sample or not.</p>
</dd>
<dt><code>direct_est</code></dt><dd><p>Vector of input direct estimates.</p>
</dd>
<dt><code>post_means</code></dt><dd><p>Model-based estimates, i.e. posterior means of the parameter of interest <code class="reqn">\theta_d</code> for each domain <code class="reqn">d</code>.</p>
</dd>
<dt><code>sd_reduction</code></dt><dd><p>Standard deviation reduction, see details section.</p>
</dd>
<dt><code>sd_dir</code></dt><dd><p>Standard deviation of direct estimates, given as input if <code>type_disp="var"</code>.</p>
</dd>
<dt><code>loo</code></dt><dd><p>The object of class <code>loo</code>, for details see <code>loo</code> package documentation. </p>
</dd>
<dt><code>shrink_rate</code></dt><dd><p>Shrinking Bound Rate, see details section.</p>
</dd>
<dt><code>residuals</code></dt><dd><p>Residuals related to model-based estimates.</p>
</dd>
<dt><code>bayes_pvalues</code></dt><dd><p>Bayesian p-values obtained via MCMC samples, see details section.</p>
</dd>
<dt><code>y_rep</code></dt><dd><p>An array with values generated from the posterior predictive distribution, enabling the implementation of posterior predictive checks.</p>
</dd>
<dt><code>diag_summ</code></dt><dd><p>Summaries of residuals, standard deviation reduction and Bayesian p-values across the whole domain set.</p>
</dd>
<dt><code>data_obj</code></dt><dd><p>A list containing input objects including in-sample and out-of-sample relevant quantities.</p>
</dd>
<dt><code>model_settings</code></dt><dd><p>A list summarizing all the assumptions of the input model: sampling likelihood, presence of intercept, dispersion parametrization, random effects priors and possible structures.</p>
</dd>
<dt><code>call</code></dt><dd><p>Image of the function call that produced the input <code>fitsae</code> object.</p>
</dd>
</dl>



<h3>References</h3>

<p>Janicki R (2020).
&ldquo;Properties of the beta regression model for small area estimation of proportions and application to estimation of poverty rates.&rdquo;
<em>Communications in Statistics-Theory and Methods</em>, <b>49</b>(9), 2264&ndash;2284.
</p>
<p>Vehtari A, Gelman A, Gabry J (2017).
&ldquo;Practical Bayesian model evaluation using leave-one-out cross-validation and WAIC.&rdquo;
<em>Statistics and Computing</em>, <b>27</b>(5), 1413&ndash;1432.
</p>
<p>De Nicolò S, Gardini A (2024).
&ldquo;The R Package tipsae: Tools for Mapping Proportions and Indicators on the Unit Interval.&rdquo;
<em>Journal of Statistical Software</em>, <b>108</b>(1), 1&ndash;36.
<a href="https://doi.org/10.18637/jss.v108.i01">doi:10.18637/jss.v108.i01</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_sae">fit_sae</a></code> to estimate the model and the generic methods <code><a href="#topic+plot.summary_fitsae">plot.summary_fitsae</a></code> and <code><a href="#topic+density.summary_fitsae">density.summary_fitsae</a></code>, and functions <code><a href="#topic+map">map</a></code>, <code><a href="#topic+benchmark">benchmark</a></code> and <code><a href="#topic+extract">extract</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tipsae)

# loading toy dataset
data("emilia_cs")

# fitting a model
fit_beta &lt;- fit_sae(formula_fixed = hcr ~ x, data = emilia_cs, domains = "id",
                    type_disp = "var", disp_direct = "vars", domain_size = "n",
                    # MCMC setting to obtain a fast example. Remove next line for reliable results.
                    chains = 1, iter = 150, seed = 0)

# check model diagnostics via summary() method
summ_beta &lt;- summary(fit_beta)
summ_beta
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
