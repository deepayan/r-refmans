<!DOCTYPE html><html><head><title>Help for package lmerTest</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lmerTest}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#lmerTest-package'><p>lmerTest: Tests in Linear Mixed Effects Models</p></a></li>
<li><a href='#anova.lmerModLmerTest'><p>ANOVA Tables for Linear Mixed Models</p></a></li>
<li><a href='#anova.merModLmerTest'><p>Methods for Legacy lmerTest Objects</p></a></li>
<li><a href='#as_lmerModLmerTest'><p>Coerce lmerMod Objects to lmerModLmerTest</p></a></li>
<li><a href='#as.data.frame.ls_means'><p>Coerce <code>ls_means</code> Objects to <code>data.frame</code>s</p></a></li>
<li><a href='#carrots'><p>Consumer Preference Mapping of Carrots</p></a></li>
<li><a href='#containment'><p>Determine the Containment Structure for All Terms in a Model</p></a></li>
<li><a href='#contest'><p>Generic Contrast Test Functions</p></a></li>
<li><a href='#contest.lmerModLmerTest'><p>Test of Contrasts</p></a></li>
<li><a href='#contest1D.lmerModLmerTest'><p>Contrast Tests in 1D</p></a></li>
<li><a href='#contestMD.lmerModLmerTest'><p>Multiple Degrees-of-Freedom Contrast Tests</p></a></li>
<li><a href='#devfun_vp'><p>Compute Deviance of an LMM as a Function of Variance Parameters</p></a></li>
<li><a href='#doolittle'><p>Doolittle Decomposition</p></a></li>
<li><a href='#drop1.lmerModLmerTest'><p>Drop Marginal Terms from Model</p></a></li>
<li><a href='#ensure_full_rank'><p>Ensure a Design Matrix has Full (Column) Rank</p></a></li>
<li><a href='#get_contrasts_type1'><p>Type I ANOVA table contrasts</p></a></li>
<li><a href='#get_contrasts_type3'><p>Contrasts for Type III Tests</p></a></li>
<li><a href='#get_covbeta'><p>Compute cov(beta) as a Function of varpar of an LMM</p></a></li>
<li><a href='#get_Fstat_ddf'><p>Compute denominator df for F-test</p></a></li>
<li><a href='#get_model'><p>Extract Model from an Object</p></a></li>
<li><a href='#get_model_matrix'><p>Extract or remake model matrix from model</p></a></li>
<li><a href='#get_rdX'><p>Compute the 'Full' Rank-Deficient Design Matrix</p></a></li>
<li><a href='#ham'><p>Conjoint Study of Dry Cured Ham</p></a></li>
<li><a href='#is_estimable'><p>Estimability of Contrasts</p></a></li>
<li><a href='#lmer'><p>Fit Linear Mixed-Effects Models</p></a></li>
<li><a href='#lmerModLmerTest-class'><p>Represent Linear Mixed-Effects Models</p></a></li>
<li><a href='#ls_means'><p>LS-means Generic Function</p></a></li>
<li><a href='#ls_means.lmerModLmerTest'><p>LS-means for lmerTest Model Fits</p></a></li>
<li><a href='#merModLmerTest-class'><p>Legacy lmerTest representation of Linear Mixed-Effects Models</p></a></li>
<li><a href='#nullspace'><p>Nullspace</p></a></li>
<li><a href='#plot.ls_means'><p>Bar Plots of LS-Means</p></a></li>
<li><a href='#plot.step_list'><p>Plot LS-means for Backward Reduced Model</p></a></li>
<li><a href='#qform'><p>Compute Quadratic Form</p></a></li>
<li><a href='#ranova'><p>ANOVA-Like Table for Random-Effects</p></a></li>
<li><a href='#rbindall'><p><code>rbind</code> Multiple Objects</p></a></li>
<li><a href='#rm_complete_terms'><p>Remove Terms from Formula</p></a></li>
<li><a href='#show_tests'><p>Show Tests Generic Function and Default Method</p></a></li>
<li><a href='#show_tests.anova'><p>Show Hypothesis Tests in ANOVA Tables</p></a></li>
<li><a href='#show_tests.ls_means'><p>Show LS-means Hypothesis Tests and Contrasts</p></a></li>
<li><a href='#single_anova'><p>ANOVA Tables for Linear Mixed Models</p></a></li>
<li><a href='#step'><p>Generic Step Function</p></a></li>
<li><a href='#step.lmerModLmerTest'><p>Backward Elimination for Linear Mixed Models</p></a></li>
<li><a href='#summary.lmerModLmerTest'><p>Summary Method for Linear Mixed Models</p></a></li>
<li><a href='#term_contain'><p>Determine which Terms Contain a Term</p></a></li>
<li><a href='#TVbo'><p>Sensory Assesment of B&amp;O TVs</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tests in Linear Mixed Effects Models</td>
</tr>
<tr>
<td>Version:</td>
<td>3.1-3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.5), lme4 (&ge; 1.1-10), stats, methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>numDeriv, MASS, ggplot2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>pbkrtest (&ge; 0.4-3), tools</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides p-values in type I, II or III anova and summary tables
    for lmer model fits (cf. lme4) via Satterthwaite's degrees of freedom method. A
    Kenward-Roger method is also available via the pbkrtest package. Model selection
    methods include step, drop1 and anova-like tables for random effects (ranova).
    Methods for Least-Square means (LS-means) and tests of linear contrasts of fixed
    effects are also available.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/runehaubo/lmerTestR">https://github.com/runehaubo/lmerTestR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/runehaubo/lmerTestR/issues">https://github.com/runehaubo/lmerTestR/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Collate:</td>
<td>'anova_contrasts.R' 'contest.R' 'contrast_utils.R'
'data_documentation.R' 'drop1.R' 'estimability.R' 'legacy.R'
'lmer.R' 'lmerTest.R' 'lmer_anova.R' 'lmer_summary.R'
'ls_means.R' 'ranova.R' 'step.R' 'terms_utils.R' 'utils.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-10-23 07:00:33 UTC; rhbc</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexandra Kuznetsova [aut],
  Per Bruun Brockhoff [aut, ths],
  Rune Haubo Bojesen Christensen [aut, cre],
  Sofie PÃ¸denphant Jensen [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rune Haubo Bojesen Christensen &lt;Rune.Haubo@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-10-23 11:10:04 UTC</td>
</tr>
</table>
<hr>
<h2 id='lmerTest-package'>lmerTest: Tests in Linear Mixed Effects Models</h2><span id='topic+lmerTest-package'></span><span id='topic+lmerTest'></span>

<h3>Description</h3>

<p>The <span class="pkg">lmerTest</span> package provides p-values in type I, II or III
<code>anova</code> and <code>summary</code>
tables for linear mixed models (<code><a href="#topic+lmer">lmer</a></code> model fits cf. <span class="pkg">lme4</span>)
via Satterthwaite's degrees of freedom method; a Kenward-Roger method is also
available via the <span class="pkg">pbkrtest</span> package.
Model selection and assessment methods include <code><a href="#topic+step">step</a></code>,
<code><a href="stats.html#topic+drop1">drop1</a></code>, anova-like tables for random effects (<code><a href="#topic+ranova">ranova</a></code>),
least-square means (LS-means; <code><a href="#topic+ls_means">ls_means</a></code>)
and tests of linear contrasts of fixed effects (<code><a href="#topic+contest">contest</a></code>).
</p>


<h3>Key Functions and Methods</h3>


<dl>
<dt>lmer</dt><dd><p>overloads <code>lme4::lmer</code> and produced an object of class
<code>lmerModLmerTest</code> which inherits from <code>lmerMod</code>. In addition to
computing the model (using <code>lme4::lmer</code>), <code>lmerTest::lmer</code>
computes a couple of components needed for the evaluation of Satterthwaite's
denominator degrees of freedom.</p>
</dd>
<dt>anova</dt><dd><p>anova method for <code><a href="#topic+lmer">lmer</a></code> model fits produces
type I, II, and III anova tables for fixed-effect terms with
Satterthwaite and Kenward-Roger methods for denominator degrees of freedom
for F-tests.</p>
</dd>
<dt>summary</dt><dd><p>summary method for <code><a href="#topic+lmer">lmer</a></code> model fits adds
denominator degrees of freedom and p-values to the coefficient table.</p>
</dd>
<dt>ranova</dt><dd><p>anova-like table of random effects via likelihood ratio tests
with methods for both <code>lmerMod</code> and <code>lmerModLmerTest</code> objects.
<code>ranova</code> can either test reduction of random-effect terms to simpler
structures or it can test removal of entire random-effect terms.</p>
</dd>
<dt>drop1</dt><dd><p>F-tests of fixed-effect terms using Satterthwaite or
Kenward-Roger methods for denominator degrees of freedom. These 'single term
deletion' tables are useful for model selection and tests of marginal terms.
Compared to the likelihood ratio tests of <code>lme4::drop1</code> the F-tests and
p-values of <code>lmerTest::drop1</code> are more accurate and considerably faster
since no additional model fitting is required.</p>
</dd>
<dt>contest</dt><dd><p>tests of contrasts, i.e. tests of linear functions of the
fixed-effect coefficients. A user-friendly interface for tests of contrasts
with outputs either as a summary-like table of t-tests or an anova-like table
of F-tests (or a list of either). Contrasts can optionally be tested for
estimability. Contrasts are allowed to be rank-deficient as the rank is
automatically detected and appropriate adjustments made. Methods for
<code>lmerModLmerTest</code> as well as <code>lmerMod</code> objects &ndash; the latter avoids
the Satterthwaite specific computations when the Kenward-Roger method is used.</p>
</dd>
<dt>show_test</dt><dd><p>a function which operates on anova tables and LS-means tables
makes it possible to see exactly which
functions of the coefficients are being tested. This is helpful when
differences between type I, II and III anova tables are being considered and
discussed.</p>
</dd>
<dt>ls_means</dt><dd><p>computes the so-called least-squares means (classical Yates
contrasts) as well as pairwise differences of these.</p>
</dd>
<dt>step</dt><dd><p>performs automatic backward model selection of fixed and random
parts of the linear mixed model.</p>
</dd>
<dt>as_lmerModLmerTest</dt><dd><p>an explicit coerce function from class
<code>lmerMod</code> to <code>lmerModLmerTest</code>.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The computational approach is to let <code>lmerTest::lmer</code> compute the
Hessian and derivatives needed for evaluation of degrees of freedom and
t- and F-tests and to store these in the model object. The
Hessian and derivatives are therefore computed only once per model fit
and reused with each call to <code>anova</code>, <code>summary</code>, etc. Evaluation of
t and F-tests does not involve model re-fitting.
</p>
<p><code>lmerTest::lmer</code> roughly amounts to calling <code>lme4::lmer</code> followed by
<code>lmerTest::as_lmerModLmerTest</code>, so for computationally intensive model
fits it can make sense to use <code>lme4::lmer</code> rather than <code>lmerTest::lmer</code>
if computational time is an issue and summary tables and anova tables will
not be needed.
</p>


<h3>Author(s)</h3>

<p>Alexandra Kuznetsova, Per Bruun Brockhoff, Rune Haubo Bojesen Christensen
</p>


<h3>References</h3>

<p>Alexandra Kuznetsova, Per B. Brockhoff and Rune H. B. Christensen (2017)
lmerTest Package: Tests in Linear Mixed Effects Models.
<em>Journal of Statistical Software</em>, 82(13), 1&ndash;26. doi:10.18637/jss.v082.i13
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load lmerTest package
library(lmerTest)

## Fit linear mixed model to the ham data:
fm &lt;- lmer(Informed.liking ~ Gender + Information * Product + (1 | Consumer) +
             (1 | Consumer:Product), data=ham)

## Summary including coefficient table with p-values for t-statistics using
## Satterthwaite's method for denominator degrees of freedom:
summary(fm)

## Type III anova table with p-values for F-tests based on Satterthwaite's
## method:
(aov &lt;- anova(fm))

## Inspect the contrast matrix for the Type III test of Product:
show_tests(aov, fractions = TRUE)$Product

## Choose type II anova table with Kenward-Roger method for the F-test:
## Not run: 
if(requireNamespace("pbkrtest", quietly = TRUE))
  anova(fm, type=2, ddf="Kenward-Roger")

## End(Not run)

## Anova-like table of random-effect terms using likelihood ratio tests:
ranova(fm)

## F-tests of 'single term deletions' for all marginal terms:
drop1(fm)

## Least-Square means and pairwise differences:
(lsm &lt;- ls_means(fm))
ls_means(fm, which = "Product", pairwise = TRUE)

## ls_means also have plot and as.data.frame methods:
## Not run: 
plot(lsm, which=c("Product", "Information"))
as.data.frame(lsm)
## Inspect the LS-means contrasts:
show_tests(lsm, fractions=TRUE)$Product

## End(Not run)

## Contrast test (contest) using a custom contrast:
## Here we make the 2-df joint test of the main effects of Gender and Information
(L &lt;- diag(length(fixef(fm)))[2:3, ])
contest(fm, L = L)

## backward elimination of non-significant effects:
step_result &lt;- step(fm)

## Elimination tables for random- and fixed-effect terms:
step_result

# Extract the model that step found:
final_model &lt;- get_model(step_result)

</code></pre>

<hr>
<h2 id='anova.lmerModLmerTest'>ANOVA Tables for Linear Mixed Models</h2><span id='topic+anova.lmerModLmerTest'></span>

<h3>Description</h3>

<p>ANOVA table with F-tests and p-values using Satterthwaite's or
Kenward-Roger's method for denominator degrees-of-freedom and F-statistic.
Models should be fitted with
<code><a href="#topic+lmer">lmer</a></code> from the <span class="pkg">lmerTest</span>-package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmerModLmerTest'
anova(
  object,
  ...,
  type = c("III", "II", "I", "3", "2", "1"),
  ddf = c("Satterthwaite", "Kenward-Roger", "lme4")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova.lmerModLmerTest_+3A_object">object</code></td>
<td>
<p>an <code>lmerModLmerTest</code> object; the result of <code>lmer()</code>
after loading the <span class="pkg">lmerTest</span>-package.</p>
</td></tr>
<tr><td><code id="anova.lmerModLmerTest_+3A_...">...</code></td>
<td>
<p>potentially additional <code>lmer</code> or <code>lm</code> model objects for
comparison of models in which case <code>type</code> and <code>ddf</code> arguments are
ignored.</p>
</td></tr>
<tr><td><code id="anova.lmerModLmerTest_+3A_type">type</code></td>
<td>
<p>the type of ANOVA table requested (using SAS terminology)
with Type I being the familiar sequential ANOVA table.</p>
</td></tr>
<tr><td><code id="anova.lmerModLmerTest_+3A_ddf">ddf</code></td>
<td>
<p>the method for computing the denominator degrees of freedom and
F-statistics. <code>ddf="Satterthwaite"</code> (default) uses Satterthwaite's method;
<code>ddf="Kenward-Roger"</code> uses Kenward-Roger's method,
<code>ddf = "lme4"</code> returns the lme4-anova table, i.e., using the anova
method for <code>lmerMod</code> objects as defined in the <span class="pkg">lme4</span>-package and
ignores the <code>type</code> argument. Partial matching is allowed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>"Kenward-Roger"</code> method calls <code>pbkrtest::KRmodcomp</code> internally and
reports scaled F-statistics and associated denominator degrees-of-freedom.
</p>


<h3>Value</h3>

<p>an ANOVA table
</p>


<h3>Author(s)</h3>

<p>Rune Haubo B. Christensen and Alexandra Kuznetsova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+contestMD">contestMD</a></code> for multi degree-of-freedom contrast tests
and <code><a href="pbkrtest.html#topic+KRmodcomp">KRmodcomp</a></code> for the <code>"Kenward-Roger"</code> method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("sleepstudy", package="lme4")
m &lt;- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
anova(m) # with p-values from F-tests using Satterthwaite's denominator df
anova(m, ddf="lme4") # no p-values

# Use the Kenward-Roger method
if(requireNamespace("pbkrtest", quietly = TRUE))
  anova(m, ddf="Kenward-Roger")


</code></pre>

<hr>
<h2 id='anova.merModLmerTest'>Methods for Legacy lmerTest Objects</h2><span id='topic+anova.merModLmerTest'></span><span id='topic+legacy'></span><span id='topic+summary.merModLmerTest'></span><span id='topic+ls_means.merModLmerTest'></span><span id='topic+lsmeansLT.merModLmerTest'></span><span id='topic+difflsmeans.merModLmerTest'></span><span id='topic+drop1.merModLmerTest'></span><span id='topic+step.merModLmerTest'></span>

<h3>Description</h3>

<p>Methods are defined for legacy lmerTest objects of class
<code>merModLmerTest</code> generated with <span class="pkg">lmerTest</span> version <code>&lt; 3.0-0</code>.
These methods are defined by interfacing code for <code>lmerModLmerTest</code>
methods and therefore behaves like these methods do (which may differ from
the behavior of <span class="pkg">lmerTest</span> version <code>&lt; 3.0-0</code>.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'merModLmerTest'
anova(
  object,
  ...,
  type = c("III", "II", "I", "3", "2", "1"),
  ddf = c("Satterthwaite", "Kenward-Roger", "lme4")
)

## S3 method for class 'merModLmerTest'
summary(object, ..., ddf = c("Satterthwaite", "Kenward-Roger", "lme4"))

## S3 method for class 'merModLmerTest'
ls_means(
  model,
  which = NULL,
  level = 0.95,
  ddf = c("Satterthwaite", "Kenward-Roger"),
  pairwise = FALSE,
  ...
)

## S3 method for class 'merModLmerTest'
lsmeansLT(
  model,
  which = NULL,
  level = 0.95,
  ddf = c("Satterthwaite", "Kenward-Roger"),
  pairwise = FALSE,
  ...
)

## S3 method for class 'merModLmerTest'
difflsmeans(
  model,
  which = NULL,
  level = 0.95,
  ddf = c("Satterthwaite", "Kenward-Roger"),
  ...
)

## S3 method for class 'merModLmerTest'
drop1(
  object,
  scope,
  ddf = c("Satterthwaite", "Kenward-Roger", "lme4"),
  force_get_contrasts = FALSE,
  ...
)

## S3 method for class 'merModLmerTest'
step(
  object,
  ddf = c("Satterthwaite", "Kenward-Roger"),
  alpha.random = 0.1,
  alpha.fixed = 0.05,
  reduce.fixed = TRUE,
  reduce.random = TRUE,
  keep,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova.merModLmerTest_+3A_object">object</code></td>
<td>
<p>an <code>lmerModLmerTest</code> object; the result of <code>lmer()</code>
after loading the <span class="pkg">lmerTest</span>-package.</p>
</td></tr>
<tr><td><code id="anova.merModLmerTest_+3A_...">...</code></td>
<td>
<p>for the anova method optionally additional models; for other
methods see the corresponding <code>lmerModLmerTest</code> methods for details.</p>
</td></tr>
<tr><td><code id="anova.merModLmerTest_+3A_type">type</code></td>
<td>
<p>the type of ANOVA table requested (using SAS terminology)
with Type I being the familiar sequential ANOVA table.</p>
</td></tr>
<tr><td><code id="anova.merModLmerTest_+3A_ddf">ddf</code></td>
<td>
<p>the method for computing the denominator degrees of freedom and
F-statistics. <code>ddf="Satterthwaite"</code> (default) uses Satterthwaite's method;
<code>ddf="Kenward-Roger"</code> uses Kenward-Roger's method,
<code>ddf = "lme4"</code> returns the lme4-anova table, i.e., using the anova
method for <code>lmerMod</code> objects as defined in the <span class="pkg">lme4</span>-package and
ignores the <code>type</code> argument. Partial matching is allowed.</p>
</td></tr>
<tr><td><code id="anova.merModLmerTest_+3A_model">model</code></td>
<td>
<p>a model object fitted with <code><a href="#topic+lmer">lmer</a></code> (of class
<code>"lmerModLmerTest"</code>).</p>
</td></tr>
<tr><td><code id="anova.merModLmerTest_+3A_which">which</code></td>
<td>
<p>optional character vector naming factors for which LS-means should
be computed. If <code>NULL</code> (default) LS-means for all factors are computed.</p>
</td></tr>
<tr><td><code id="anova.merModLmerTest_+3A_level">level</code></td>
<td>
<p>confidence level.</p>
</td></tr>
<tr><td><code id="anova.merModLmerTest_+3A_pairwise">pairwise</code></td>
<td>
<p>compute pairwise differences of LS-means instead?</p>
</td></tr>
<tr><td><code id="anova.merModLmerTest_+3A_scope">scope</code></td>
<td>
<p>optional character vector naming terms to be dropped from the
model. Note that only marginal terms can be dropped. To see which terms are
marginal, use <code>drop.scope(terms(object))</code>.</p>
</td></tr>
<tr><td><code id="anova.merModLmerTest_+3A_force_get_contrasts">force_get_contrasts</code></td>
<td>
<p>enforce computation of contrast matrices by a
method in which the design matrices for full and restricted models are
compared.</p>
</td></tr>
<tr><td><code id="anova.merModLmerTest_+3A_alpha.random">alpha.random</code></td>
<td>
<p>alpha for random effects elimination</p>
</td></tr>
<tr><td><code id="anova.merModLmerTest_+3A_alpha.fixed">alpha.fixed</code></td>
<td>
<p>alpha for fixed effects elimination</p>
</td></tr>
<tr><td><code id="anova.merModLmerTest_+3A_reduce.fixed">reduce.fixed</code></td>
<td>
<p>reduce fixed effect structure? <code>TRUE</code> by default.</p>
</td></tr>
<tr><td><code id="anova.merModLmerTest_+3A_reduce.random">reduce.random</code></td>
<td>
<p>reduce random effect structure? <code>TRUE</code> by default.</p>
</td></tr>
<tr><td><code id="anova.merModLmerTest_+3A_keep">keep</code></td>
<td>
<p>an optional character vector of fixed effect terms which should
not be considered for eliminated. Valid terms are given by
<code>attr(terms(object), "term.labels")</code>. Terms that are marginal to terms
in keep will also not be considered for eliminations.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rune Haubo B. Christensen
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load model fits fm1 and fm2 generated with lmerTest version 2.3-37:
load(system.file("testdata","legacy_fits.RData", package="lmerTest"))

# Apply some methods defined by lmerTest:
anova(fm1)
summary(fm1)
contest(fm1, c(0, 1))
contest(fm1, c(0, 1), joint=FALSE)
drop1(fm1)
ranova(fm1)

# lme4-methods also work:
fixef(fm1)

# Ditto for second model fit:
anova(fm2)
summary(fm2)
ls_means(fm2)
difflsmeans(fm2)
</code></pre>

<hr>
<h2 id='as_lmerModLmerTest'>Coerce lmerMod Objects to lmerModLmerTest</h2><span id='topic+as_lmerModLmerTest'></span>

<h3>Description</h3>

<p>Coercing an lme4::lmer model-object (of class 'lmerMod') to a model-object
of class 'lmerModLmerTest' involves computing the covariance
matrix of the variance parameters and the gradient (Jacobian) of cov(beta)
with respect to the variance parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_lmerModLmerTest(model, tol = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_lmerModLmerTest_+3A_model">model</code></td>
<td>
<p>and lmer model-object (of class 'lmerMod') &ndash; the result of a
call to <code>lme4::lmer()</code></p>
</td></tr>
<tr><td><code id="as_lmerModLmerTest_+3A_tol">tol</code></td>
<td>
<p>tolerance for determining of eigenvalues are negative, zero or
positive</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>'lmerModLmerTest'</code> which sets the following
slots:
</p>
<table>
<tr><td><code>vcov_varpar</code></td>
<td>
<p>the asymptotic covariance matrix of the variance parameters
(theta, sigma).</p>
</td></tr>
<tr><td><code>Jac_list</code></td>
<td>
<p>list of Jacobian matrices; gradients of vcov(beta) with
respect to the variance parameters.</p>
</td></tr>
<tr><td><code>vcov_beta</code></td>
<td>
<p>the asymptotic covariance matrix of the fixed-effect
regression parameters (beta; vcov(beta)).</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>the residual standard deviation.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rune Haubo B. Christensen
</p>


<h3>See Also</h3>

<p>the class definition in <code><a href="#topic+lmerModLmerTest">lmerModLmerTest</a></code>) and
<code><a href="#topic+lmer">lmer</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- lme4::lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
bm &lt;- as_lmerModLmerTest(m)
slotNames(bm)

</code></pre>

<hr>
<h2 id='as.data.frame.ls_means'>Coerce <code>ls_means</code> Objects to <code>data.frame</code>s</h2><span id='topic+as.data.frame.ls_means'></span>

<h3>Description</h3>

<p>Coerce <code>ls_means</code> Objects to <code>data.frame</code>s
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ls_means'
as.data.frame(x, ..., add_levels = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.ls_means_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+ls_means">ls_means</a></code> object.</p>
</td></tr>
<tr><td><code id="as.data.frame.ls_means_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
<tr><td><code id="as.data.frame.ls_means_+3A_add_levels">add_levels</code></td>
<td>
<p>add <code>term</code> and <code>levels</code> columns to returned
<code>data.frame</code>?</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rune Haubo B. Christensen
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ls_means.lmerModLmerTest">ls_means.lmerModLmerTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fit example model:
data("cake", package="lme4")
cake$Temp &lt;- factor(cake$temperature, ordered = FALSE)
model &lt;- lmer(angle ~ recipe + Temp + (1|recipe:replicate), cake)

# Extract LS-means:
head(lsm &lt;- ls_means(model))

# Coerce LS-means objects to data.frames:
head(as.data.frame(lsm))
head(as.data.frame(lsm, add_levels=FALSE))

</code></pre>

<hr>
<h2 id='carrots'>Consumer Preference Mapping of Carrots</h2><span id='topic+carrots'></span>

<h3>Description</h3>

<p>In a consumer study 103 consumers scored their preference of 12 danish
carrot types on a scale from 1 to 7. Moreover the consumers scored the
degree of sweetness, bitterness and crispiness in the products.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(carrots)
</code></pre>


<h3>Format</h3>


<dl>
<dt>Consumer</dt><dd><p>factor with 103 levels: numbering identifying consumers.</p>
</dd>
<dt>Frequency</dt><dd><p>factor with 5 levels; &quot;How often do you eat carrots?&quot;
1: once a week or more, 2: once
every two weeks, 3: once every three weeks, 4: at least once month,
5: less than once a month.</p>
</dd>
<dt>Gender</dt><dd><p>factor with 2 levels. 1: male, 2:female.</p>
</dd>
<dt>Age</dt><dd><p>factor with 4 levels. 1: less than 25 years, 2: 26-40 years,
3: 41-60 years, 4 more than 61 years.</p>
</dd>
<dt>Homesize</dt><dd><p>factor with two levels. Number of persons in the household.
1: 1 or 2 persons, 2: 3 or more persons.</p>
</dd>
<dt>Work</dt><dd><p>factor with 7 levels. different types of employment.
1: unskilled worker(no education),
2: skilled worker(with education), 3: office worker, 4: housewife (or man),
5: independent
businessman/ self-employment, 6: student, 7: retired</p>
</dd>
<dt>Income</dt><dd><p>factor with 4 levels. 1: &lt;150000, 2: 150000-300000,
3: 300000-500000, 4: &gt;500000</p>
</dd>
<dt>Preference</dt><dd><p>consumer score on a seven-point scale.</p>
</dd>
<dt>Sweetness</dt><dd><p>consumer score on a seven-point scale.</p>
</dd>
<dt>Bitterness</dt><dd><p>consumer score on a seven-point scale.</p>
</dd>
<dt>Crispness</dt><dd><p>consumer score on a seven-point scale.</p>
</dd>
<dt>sens1</dt><dd><p>first sensory variable derived from a PCA.</p>
</dd>
<dt>sens2</dt><dd><p>second sensory variable derived from a PCA.</p>
</dd>
<dt>Product</dt><dd><p>factor on 12 levels.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The carrots were harvested in autumn 1996 and tested in march 1997. In
addition to the consumer survey, the carrot products were evaluated by
a trained panel of tasters, the sensory panel, with respect to a
number of sensory (taste, odour and texture) properties. Since usually
a high number of (correlated) properties (variables) are used, in this
case 14, it is a common procedure to use a few, often 2, combined
variables that contain as much of the information in the sensory
variables as possible. This is achieved by extracting the first two
principal components in a principal components analysis (PCA) on the
product-by-property panel average data matrix. In this data set the
variables for the first two principal components are named
(<code>sens1</code> and <code>sens2</code>).
</p>


<h3>Source</h3>

<p>Per Bruun Brockhoff, The Royal Veterinary and Agricultural University,
Denmark.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fm &lt;- lmer(Preference ~ sens2 + Homesize + (1 + sens2 | Consumer), data=carrots)
anova(fm)

</code></pre>

<hr>
<h2 id='containment'>Determine the Containment Structure for All Terms in a Model</h2><span id='topic+containment'></span>

<h3>Description</h3>

<p>See <code><a href="#topic+term_contain">term_contain</a></code> for details about containment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>containment(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="containment_+3A_object">object</code></td>
<td>
<p>a model object, e.g. of class <code>lm</code> or <code>merMod</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with one element for each term in the model. Each element/term
is a character vector of terms that the term is contained in.
</p>

<hr>
<h2 id='contest'>Generic Contrast Test Functions</h2><span id='topic+contest'></span><span id='topic+contest1D'></span><span id='topic+contestMD'></span>

<h3>Description</h3>

<p>Generic functions for tests contrasts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contest(model, L, ...)

contest1D(model, L, ...)

contestMD(model, L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contest_+3A_model">model</code></td>
<td>
<p>a model object.</p>
</td></tr>
<tr><td><code id="contest_+3A_l">L</code></td>
<td>
<p>a contrast vector or matrix.</p>
</td></tr>
<tr><td><code id="contest_+3A_...">...</code></td>
<td>
<p>additional arguments passed to methods.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rune Haubo B. Christensen
</p>


<h3>See Also</h3>

<p>contest methods for <code><a href="#topic+lmer">lmer</a></code> objects:
<code><a href="#topic+contest.lmerModLmerTest">contest</a></code>,
<code><a href="#topic+contest1D.lmerModLmerTest">contest1D</a></code>, and
<code><a href="#topic+contestMD.lmerModLmerTest">contestMD</a></code>.
</p>

<hr>
<h2 id='contest.lmerModLmerTest'>Test of Contrasts</h2><span id='topic+contest.lmerModLmerTest'></span><span id='topic+contest.lmerMod'></span>

<h3>Description</h3>

<p>Tests of vector or matrix contrasts for <code><a href="#topic+lmer">lmer</a></code> model fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmerModLmerTest'
contest(
  model,
  L,
  rhs = 0,
  joint = TRUE,
  collect = TRUE,
  confint = TRUE,
  level = 0.95,
  check_estimability = FALSE,
  ddf = c("Satterthwaite", "Kenward-Roger", "lme4"),
  ...
)

## S3 method for class 'lmerMod'
contest(
  model,
  L,
  rhs = 0,
  joint = TRUE,
  collect = TRUE,
  confint = TRUE,
  level = 0.95,
  check_estimability = FALSE,
  ddf = c("Satterthwaite", "Kenward-Roger", "lme4"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contest.lmerModLmerTest_+3A_model">model</code></td>
<td>
<p>a model object fitted with <code>lmer</code> from package
<span class="pkg">lmerTest</span>, i.e., an object of class <code><a href="#topic+lmerModLmerTest">lmerModLmerTest</a></code>.</p>
</td></tr>
<tr><td><code id="contest.lmerModLmerTest_+3A_l">L</code></td>
<td>
<p>a contrast vector or matrix or a list of these.
The <code>length</code>/<code>ncol</code> of each contrasts should equal
<code>length(fixef(model))</code>.</p>
</td></tr>
<tr><td><code id="contest.lmerModLmerTest_+3A_rhs">rhs</code></td>
<td>
<p>right-hand-side of the statistical test, i.e. the hypothesized
value (a numeric scalar).</p>
</td></tr>
<tr><td><code id="contest.lmerModLmerTest_+3A_joint">joint</code></td>
<td>
<p>make an F-test of potentially several contrast vectors? If
<code>FALSE</code> single DF t-tests are applied to each vector or each row of
contrasts matrices.</p>
</td></tr>
<tr><td><code id="contest.lmerModLmerTest_+3A_collect">collect</code></td>
<td>
<p>collect list of tests in a matrix?</p>
</td></tr>
<tr><td><code id="contest.lmerModLmerTest_+3A_confint">confint</code></td>
<td>
<p>include columns for lower and upper confidence limits? Applies
when <code>joint</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="contest.lmerModLmerTest_+3A_level">level</code></td>
<td>
<p>confidence level.</p>
</td></tr>
<tr><td><code id="contest.lmerModLmerTest_+3A_check_estimability">check_estimability</code></td>
<td>
<p>check estimability of contrasts? Only single DF
contrasts are checked for estimability thus requiring <code>joint = FALSE</code> to
take effect. See details section for necessary adjustments to <code>L</code> when
estimability is checked with rank deficient design matrices.</p>
</td></tr>
<tr><td><code id="contest.lmerModLmerTest_+3A_ddf">ddf</code></td>
<td>
<p>the method for computing the denominator degrees of freedom.
<code>ddf="Kenward-Roger"</code> uses Kenward-Roger's method.</p>
</td></tr>
<tr><td><code id="contest.lmerModLmerTest_+3A_...">...</code></td>
<td>
<p>passed to <code><a href="#topic+contestMD">contestMD</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the design matrix is rank deficient, <code>lmer</code> drops columns for the
aliased coefficients from the design matrix and excludes the corresponding
aliased coefficients from <code>fixef(model)</code>. When estimability is checked
the original rank-deficient design matrix is recontructed and therefore
<code>L</code> contrast vectors need to include elements for the aliased
coefficients. Similarly when <code>L</code> is a matrix, its number of columns
needs to match that of the reconstructed rank-deficient design matrix.
</p>


<h3>Value</h3>

<p>a <code>data.frame</code> or a list of <code>data.frame</code>s.
</p>


<h3>Author(s)</h3>

<p>Rune Haubo B. Christensen
</p>


<h3>See Also</h3>

<p><code><a href="#topic+contestMD.lmerModLmerTest">contestMD</a></code> for multi
degree-of-freedom contrast tests,
and <code><a href="#topic+contest1D.lmerModLmerTest">contest1D</a></code> for tests of
1-dimensional contrasts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("sleepstudy", package="lme4")
fm &lt;- lmer(Reaction ~ Days + I(Days^2) + (1|Subject) + (0+Days|Subject),
           sleepstudy)
# F-test of third coeffcients - I(Days^2):
contest(fm, c(0, 0, 1))
# Equivalent t-test:
contest(fm, L=c(0, 0, 1), joint=FALSE)
# Test of 'Days + I(Days^2)':
contest(fm, L=diag(3)[2:3, ])
# Other options:
contest(fm, L=diag(3)[2:3, ], joint=FALSE)
contest(fm, L=diag(3)[2:3, ], joint=FALSE, collect=FALSE)

# Illustrate a list argument:
L &lt;- list("First"=diag(3)[3, ], "Second"=diag(3)[-1, ])
contest(fm, L)
contest(fm, L, collect = FALSE)
contest(fm, L, joint=FALSE, confint = FALSE)
contest(fm, L, joint=FALSE, collect = FALSE, level=0.99)

# Illustrate testing of estimability:
# Consider the 'cake' dataset with a missing cell:
data("cake", package="lme4")
cake$temperature &lt;- factor(cake$temperature, ordered=FALSE)
cake &lt;- droplevels(subset(cake, temperature %in% levels(cake$temperature)[1:2] &amp;
                            !(recipe == "C" &amp; temperature == "185")))
with(cake, table(recipe, temperature))
fm &lt;- lmer(angle ~ recipe * temperature + (1|recipe:replicate), cake)
fixef(fm)
# The coefficient for recipeC:temperature185 is dropped:
attr(model.matrix(fm), "col.dropped")
# so any contrast involving this coefficient is not estimable:
Lmat &lt;- diag(6)
contest(fm, Lmat, joint=FALSE, check_estimability = TRUE)

</code></pre>

<hr>
<h2 id='contest1D.lmerModLmerTest'>Contrast Tests in 1D</h2><span id='topic+contest1D.lmerModLmerTest'></span><span id='topic+contest1D.lmerMod'></span>

<h3>Description</h3>

<p>Compute the test of a one-dimensional (vector) contrast in a
linear mixed model fitted with lmer from package <span class="pkg">lmerTest</span>.
The contrast should specify a linear function of the
mean-value parameters, beta. The Satterthwaite or Kenward-Roger method is
used to compute the (denominator) df for the t-test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmerModLmerTest'
contest1D(
  model,
  L,
  rhs = 0,
  ddf = c("Satterthwaite", "Kenward-Roger"),
  confint = FALSE,
  level = 0.95,
  ...
)

## S3 method for class 'lmerMod'
contest1D(
  model,
  L,
  rhs = 0,
  ddf = c("Satterthwaite", "Kenward-Roger"),
  confint = FALSE,
  level = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contest1D.lmerModLmerTest_+3A_model">model</code></td>
<td>
<p>a model object fitted with <code>lmer</code> from package
<span class="pkg">lmerTest</span>, i.e., an object of class <code><a href="#topic+lmerModLmerTest">lmerModLmerTest</a></code>.</p>
</td></tr>
<tr><td><code id="contest1D.lmerModLmerTest_+3A_l">L</code></td>
<td>
<p>a numeric (contrast) vector of the same length as
<code>fixef(model)</code>.</p>
</td></tr>
<tr><td><code id="contest1D.lmerModLmerTest_+3A_rhs">rhs</code></td>
<td>
<p>right-hand-side of the statistical test, i.e. the hypothesized
value (a numeric scalar).</p>
</td></tr>
<tr><td><code id="contest1D.lmerModLmerTest_+3A_ddf">ddf</code></td>
<td>
<p>the method for computing the denominator degrees of freedom.
<code>ddf="Kenward-Roger"</code> uses Kenward-Roger's method.</p>
</td></tr>
<tr><td><code id="contest1D.lmerModLmerTest_+3A_confint">confint</code></td>
<td>
<p>include columns for lower and upper confidence limits?</p>
</td></tr>
<tr><td><code id="contest1D.lmerModLmerTest_+3A_level">level</code></td>
<td>
<p>confidence level.</p>
</td></tr>
<tr><td><code id="contest1D.lmerModLmerTest_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The t-value and associated p-value is for the hypothesis
<code class="reqn">L' \beta = \mathrm{rhs}</code> in which rhs may be non-zero
and <code class="reqn">\beta</code> is <code>fixef(model)</code>.
The estimated value (<code>"Estimate"</code>) is <code class="reqn">L' \beta</code> with associated
standard error and (optionally) confidence interval.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with one row and columns with <code>"Estimate"</code>,
<code>"Std. Error"</code>, <code>"t value"</code>, <code>"df"</code>, and <code>"Pr(&gt;|t|)"</code>
(p-value). If <code>confint = TRUE</code> <code>"lower"</code> and <code>"upper"</code> columns
are included before the p-value column.
</p>


<h3>Author(s)</h3>

<p>Rune Haubo B. Christensen
</p>


<h3>See Also</h3>

<p><code><a href="#topic+contest.lmerModLmerTest">contest</a></code> for a flexible
and general interface to tests of contrasts among fixed-effect parameters.
<code><a href="#topic+contestMD.lmerModLmerTest">contestMD</a></code> is also available as a
direct interface for tests of multi degree-of-freedom contrast.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fit model using lmer with data from the lme4-package:
data("sleepstudy", package="lme4")
fm &lt;- lmer(Reaction ~ Days + (1 + Days|Subject), sleepstudy)

# Tests and CI of model coefficients are obtained with:
contest1D(fm, c(1, 0), confint=TRUE) # Test for Intercept
contest1D(fm, c(0, 1), confint=TRUE) # Test for Days

# Tests of coefficients are also part of:
summary(fm)

# Illustrate use of rhs argument:
contest1D(fm, c(0, 1), confint=TRUE, rhs=10) # Test for Days-coef == 10


</code></pre>

<hr>
<h2 id='contestMD.lmerModLmerTest'>Multiple Degrees-of-Freedom Contrast Tests</h2><span id='topic+contestMD.lmerModLmerTest'></span><span id='topic+calcSatterth'></span><span id='topic+contestMD.lmerMod'></span>

<h3>Description</h3>

<p>Compute the multi degrees-of-freedom test in a linear mixed model fitted
by <code><a href="#topic+lmer">lmer</a></code>. The contrast (L) specifies a linear function of the
mean-value parameters, beta. Satterthwaite's method is used to compute the
denominator df for the F-test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmerModLmerTest'
contestMD(
  model,
  L,
  rhs = 0,
  ddf = c("Satterthwaite", "Kenward-Roger"),
  eps = sqrt(.Machine$double.eps),
  ...
)

calcSatterth(model, L)

## S3 method for class 'lmerMod'
contestMD(
  model,
  L,
  rhs = 0,
  ddf = c("Satterthwaite", "Kenward-Roger"),
  eps = sqrt(.Machine$double.eps),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contestMD.lmerModLmerTest_+3A_model">model</code></td>
<td>
<p>a model object fitted with <code>lmer</code> from package
<span class="pkg">lmerTest</span>, i.e., an object of class <code><a href="#topic+lmerModLmerTest">lmerModLmerTest</a></code>.</p>
</td></tr>
<tr><td><code id="contestMD.lmerModLmerTest_+3A_l">L</code></td>
<td>
<p>a contrast matrix with nrow &gt;= 1 and ncol ==
<code>length(fixef(model))</code>.</p>
</td></tr>
<tr><td><code id="contestMD.lmerModLmerTest_+3A_rhs">rhs</code></td>
<td>
<p>right-hand-side of the statistical test, i.e. the hypothesized
value. A numeric vector of length <code>nrow(L)</code> or a numeric scalar.</p>
</td></tr>
<tr><td><code id="contestMD.lmerModLmerTest_+3A_ddf">ddf</code></td>
<td>
<p>the method for computing the denominator degrees of freedom and
F-statistics. <code>ddf="Kenward-Roger"</code> uses Kenward-Roger's method.</p>
</td></tr>
<tr><td><code id="contestMD.lmerModLmerTest_+3A_eps">eps</code></td>
<td>
<p>tolerance on eigenvalues to determine if an eigenvalue is
positive. The number of positive eigenvalues determine the rank of
L and the numerator df of the F-test.</p>
</td></tr>
<tr><td><code id="contestMD.lmerModLmerTest_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The F-value and associated p-value is for the hypothesis
<code class="reqn">L \beta = \mathrm{rhs}</code> in which rhs may be non-zero
and <code class="reqn">\beta</code> is <code>fixef(model)</code>.
</p>
<p>Note: NumDF = row-rank(L) is determined automatically so row rank-deficient L
are allowed. One-dimensional contrasts are also allowed (L has 1 row).
</p>


<h3>Value</h3>

<p>a <code>data.frame</code> with one row and columns with <code>"Sum Sq"</code>,
<code>"Mean Sq"</code>, <code>"F value"</code>, <code>"NumDF"</code> (numerator df),
<code>"DenDF"</code> (denominator df) and <code>"Pr(&gt;F)"</code> (p-value).
</p>


<h3>Author(s)</h3>

<p>Rune Haubo B. Christensen
</p>


<h3>See Also</h3>

<p><code><a href="#topic+contest.lmerModLmerTest">contest</a></code> for a flexible and
general interface to tests of contrasts among fixed-effect parameters.
<code><a href="#topic+contest1D.lmerModLmerTest">contest1D</a></code> is a direct interface for
tests of 1-dimensional contrasts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("sleepstudy", package="lme4")
fm &lt;- lmer(Reaction ~ Days + I(Days^2) + (1|Subject) + (0+Days|Subject),
           sleepstudy)

# Define 2-df contrast - since L has 2 (linearly independent) rows
# the F-test is on 2 (numerator) df:
L &lt;- rbind(c(0, 1, 0), # Note: ncol(L) == length(fixef(fm))
           c(0, 0, 1))

# Make the 2-df F-test of any effect of Days:
contestMD(fm, L)

# Illustrate rhs argument:
contestMD(fm, L, rhs=c(5, .1))

# Make the 1-df F-test of the effect of Days^2:
contestMD(fm, L[2, , drop=FALSE])
# Same test, but now as a t-test instead:
contest1D(fm, L[2, , drop=TRUE])

</code></pre>

<hr>
<h2 id='devfun_vp'>Compute Deviance of an LMM as a Function of Variance Parameters</h2><span id='topic+devfun_vp'></span>

<h3>Description</h3>

<p>This function is used for extracting the asymptotic variance-covariance matrix
of the variance parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>devfun_vp(varpar, devfun, reml)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="devfun_vp_+3A_varpar">varpar</code></td>
<td>
<p>variance parameters; <code>varpar = c(theta, sigma)</code>.</p>
</td></tr>
<tr><td><code id="devfun_vp_+3A_devfun">devfun</code></td>
<td>
<p>deviance function as a function of theta only.</p>
</td></tr>
<tr><td><code id="devfun_vp_+3A_reml">reml</code></td>
<td>
<p>if <code>TRUE</code> the REML deviance is computed;
if <code>FALSE</code>, the ML deviance is computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the REML or ML deviance.
</p>


<h3>Author(s)</h3>

<p>Rune Haubo B. Christensen
</p>

<hr>
<h2 id='doolittle'>Doolittle Decomposition</h2><span id='topic+doolittle'></span>

<h3>Description</h3>

<p>Doolittle Decomposition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doolittle(x, eps = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="doolittle_+3A_x">x</code></td>
<td>
<p>a numeric square matrix with at least 2 columns/rows.</p>
</td></tr>
<tr><td><code id="doolittle_+3A_eps">eps</code></td>
<td>
<p>numerical tolerance on the whether to normalize with components
in <code>L</code> with the diagonal elements of <code>U</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with two matrices of the same dimension as <code>x</code>:
</p>
<table>
<tr><td><code>L</code></td>
<td>
<p>lower-left unit-triangular matrix</p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>upper-right triangular matrix (<em>not</em> unit-triangular)</p>
</td></tr>
</table>

<hr>
<h2 id='drop1.lmerModLmerTest'>Drop Marginal Terms from Model</h2><span id='topic+drop1.lmerModLmerTest'></span>

<h3>Description</h3>

<p>Computes the F-test for all marginal terms, i.e. terms that can be dropped
from the model while respecting the hierarchy of terms in the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmerModLmerTest'
drop1(
  object,
  scope,
  ddf = c("Satterthwaite", "Kenward-Roger", "lme4"),
  force_get_contrasts = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop1.lmerModLmerTest_+3A_object">object</code></td>
<td>
<p>an <code><a href="#topic+lmer">lmer</a></code> model fit (of class
<code>"lmerModLmerTest"</code>.)</p>
</td></tr>
<tr><td><code id="drop1.lmerModLmerTest_+3A_scope">scope</code></td>
<td>
<p>optional character vector naming terms to be dropped from the
model. Note that only marginal terms can be dropped. To see which terms are
marginal, use <code>drop.scope(terms(object))</code>.</p>
</td></tr>
<tr><td><code id="drop1.lmerModLmerTest_+3A_ddf">ddf</code></td>
<td>
<p>the method for computing the denominator degrees of freedom and
F-statistics. <code>ddf="Satterthwaite"</code> (default) uses Satterthwaite's method;
<code>ddf="Kenward-Roger"</code> uses Kenward-Roger's method.
<code>ddf = "lme4"</code> returns the <code>drop1</code> table for <code>merMod</code> objects
as defined in package <span class="pkg">lme4</span>.</p>
</td></tr>
<tr><td><code id="drop1.lmerModLmerTest_+3A_force_get_contrasts">force_get_contrasts</code></td>
<td>
<p>enforce computation of contrast matrices by a
method in which the design matrices for full and restricted models are
compared.</p>
</td></tr>
<tr><td><code id="drop1.lmerModLmerTest_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simple marginal contrasts are used for all marginal terms unless the design
matrix is rank deficient. In that case (and if <code>force_get_contrasts</code> is
<code>TRUE</code>) the contrasts (i.e. restriction matrices on the design matrix
of the full model) are computed by comparison of the design matrices
for full and restricted models. The set of marginal terms considered for
dropping are computed using <code>drop.scope(terms(object))</code>.
</p>
<p>Since all tests are based on tests of contrasts in the full model, no
models are being (re)fitted.
</p>


<h3>Value</h3>

<p>An anova-like table with F-tests of marginal terms.
</p>


<h3>Author(s)</h3>

<p>Rune Haubo B. Christensen
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ranova">ranova</a></code> for tests of marginal random terms.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Basic usage:
fm &lt;- lmer(angle ~ recipe + temp + (1|recipe:replicate), cake)
drop1(fm) # Using Satterthwaite degrees of freedom
if(requireNamespace("pbkrtest", quietly = TRUE))
  drop1(fm, ddf="Kenward-Roger") # Alternative DenDF and F-test method
drop1(fm, ddf="lme4", test="Chi") # Asymptotic Likelihood ratio tests

# Consider a rank-deficient design matrix:
fm &lt;- lmer(angle ~ recipe + temp + temperature + (1|recipe:replicate), cake)
# Here temp accounts for the linear effect of temperature, and
# temperature is an (ordered) factor that accounts for the remaining
# variation between temperatures (4 df).
drop1(fm)
# While temperature is in the model, we cannot test the effect of dropping
# temp. After removing temperature we can test the effect of dropping temp:
drop1(lmer(angle ~ recipe + temp + (1|recipe:replicate), cake))

# Polynomials:
# Note that linear terms should usually not be dropped before squared terms.
# Therefore 'Days' should not be dropped before 'I(Days^2)' despite it being
# tested here:
fm &lt;- lmer(Reaction ~ Days + I(Days^2) + (Days|Subject), sleepstudy)
drop1(fm)
# Using poly() provides a test of the whole polynomial structure - not a
# separate test for the highest order (squared) term:
fm &lt;- lmer(Reaction ~ poly(Days, 2) + (Days|Subject), sleepstudy)
drop1(fm)

</code></pre>

<hr>
<h2 id='ensure_full_rank'>Ensure a Design Matrix has Full (Column) Rank</h2><span id='topic+ensure_full_rank'></span>

<h3>Description</h3>

<p>Determine and drop redundant columns using the <code><a href="base.html#topic+qr">qr</a></code>
decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ensure_full_rank(X, tol = 1e-07, silent = FALSE, test.ans = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ensure_full_rank_+3A_x">X</code></td>
<td>
<p>a design matrix as produced by <code>model.matrix</code>.</p>
</td></tr>
<tr><td><code id="ensure_full_rank_+3A_tol">tol</code></td>
<td>
<p><code>qr</code> tolerance.</p>
</td></tr>
<tr><td><code id="ensure_full_rank_+3A_silent">silent</code></td>
<td>
<p>throw message if columns are dropped from <code>X</code>? Default
is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ensure_full_rank_+3A_test.ans">test.ans</code></td>
<td>
<p>Test if the resulting/returned matrix has full rank? Default
is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A design matrix in which redundant columns are dropped
</p>

<hr>
<h2 id='get_contrasts_type1'>Type I ANOVA table contrasts</h2><span id='topic+get_contrasts_type1'></span>

<h3>Description</h3>

<p>Type I ANOVA table contrasts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_contrasts_type1(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_contrasts_type1_+3A_model">model</code></td>
<td>
<p>a model object with <code>terms</code> and <code>model.matrix</code> methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of contrast matrices - one contrast matrix for each model term.
</p>


<h3>Author(s)</h3>

<p>Rune Haubo B. Christensen
</p>

<hr>
<h2 id='get_contrasts_type3'>Contrasts for Type III Tests</h2><span id='topic+get_contrasts_type3'></span>

<h3>Description</h3>

<p>Contrasts for Type III Tests
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_contrasts_type3(model, which = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_contrasts_type3_+3A_model">model</code></td>
<td>
<p>model object.</p>
</td></tr>
<tr><td><code id="get_contrasts_type3_+3A_which">which</code></td>
<td>
<p>optional character vector naming terms for which to compute the
the contrasts.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of contrast matrices.
</p>

<hr>
<h2 id='get_covbeta'>Compute cov(beta) as a Function of varpar of an LMM</h2><span id='topic+get_covbeta'></span>

<h3>Description</h3>

<p>At the optimum cov(beta) is available as vcov(lmer-model). This function
computes cov(beta) at non (RE)ML estimates of <code>varpar</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_covbeta(varpar, devfun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_covbeta_+3A_varpar">varpar</code></td>
<td>
<p>variance parameters; <code>varpar = c(theta, sigma)</code>.</p>
</td></tr>
<tr><td><code id="get_covbeta_+3A_devfun">devfun</code></td>
<td>
<p>deviance function as a function of theta only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>cov(beta) at supplied varpar values.
</p>


<h3>Author(s)</h3>

<p>Rune Haubo B. Christensen
</p>

<hr>
<h2 id='get_Fstat_ddf'>Compute denominator df for F-test</h2><span id='topic+get_Fstat_ddf'></span>

<h3>Description</h3>

<p>From a vector of denominator df from independent t-statistics (<code>nu</code>),
the denominator df for the corresponding F-test is computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_Fstat_ddf(nu, tol = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_Fstat_ddf_+3A_nu">nu</code></td>
<td>
<p>vector of denominator df for the t-statistics</p>
</td></tr>
<tr><td><code id="get_Fstat_ddf_+3A_tol">tol</code></td>
<td>
<p>tolerance on the consequtive differences between elements of nu to</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that if any <code>nu &lt;= 2</code> then <code>2</code> is returned. Also, if all nu
are within tol of each other the simple average of the nu-vector is returned.
This is to avoid downward bias.
</p>


<h3>Value</h3>

<p>the denominator df; a numerical scalar
</p>


<h3>Author(s)</h3>

<p>Rune Haubo B. Christensen
</p>

<hr>
<h2 id='get_model'>Extract Model from an Object</h2><span id='topic+get_model'></span>

<h3>Description</h3>

<p>Extract Model from an Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_model(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_model_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
<tr><td><code id="get_model_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+get_model.step_list">get_model.step_list</a></code>
</p>

<hr>
<h2 id='get_model_matrix'>Extract or remake model matrix from model</h2><span id='topic+get_model_matrix'></span>

<h3>Description</h3>

<p>Extract or remake model matrix from model and potentially change the
contrast coding
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_model_matrix(model, type = c("extract", "remake"), contrasts = "restore")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_model_matrix_+3A_model">model</code></td>
<td>
<p>an <code>lm</code> or <code>lmerMod</code> model object.</p>
</td></tr>
<tr><td><code id="get_model_matrix_+3A_type">type</code></td>
<td>
<p>extract or remake model matrix?</p>
</td></tr>
<tr><td><code id="get_model_matrix_+3A_contrasts">contrasts</code></td>
<td>
<p>contrasts settings. These may be restored to those in the
model or they may be changed. If a length one character vector (e.g.
<code>"contr.SAS"</code>) this is applied to all factors in the model, but it can
also be a list naming factors for which the contrasts should be set as specified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the model (or 'design') matrix.
</p>


<h3>Author(s)</h3>

<p>Rune Haubo B Christensen
</p>

<hr>
<h2 id='get_rdX'>Compute the 'Full' Rank-Deficient Design Matrix</h2><span id='topic+get_rdX'></span>

<h3>Description</h3>

<p>Compute the 'Full' Rank-Deficient Design Matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_rdX(model, do.warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_rdX_+3A_model">model</code></td>
<td>
<p>a model object; lmerMod or lmerModLmerTest.</p>
</td></tr>
<tr><td><code id="get_rdX_+3A_do.warn">do.warn</code></td>
<td>
<p>throw a message if there is no data for some factor
combinations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the rank-deficien design matrix
</p>


<h3>Author(s)</h3>

<p>Rune Haubo B. Christensen
</p>

<hr>
<h2 id='ham'>Conjoint Study of Dry Cured Ham</h2><span id='topic+ham'></span>

<h3>Description</h3>

<p>One of the purposes of the study was to investigate the effect of
information given to the consumers measured in hedonic liking for the
hams. Two of the hams were Spanish and two were Norwegian, each origin
representing different salt levels and different aging time. The
information about origin was given in such way that both true and
false information was given. Essentially a 4x2 design with 4 samples
and 2 information levels. A total of 81 Consumers participated in the
study.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ham)
</code></pre>


<h3>Format</h3>


<dl>
<dt>Consumer</dt><dd><p>factor with 81 levels: numbering identifying consumers.</p>
</dd>
<dt>Product</dt><dd><p>factor with four levels.</p>
</dd>
<dt>Informed.liking</dt><dd><p>numeric: hedonic liking for the products.</p>
</dd>
<dt>Information</dt><dd><p>factor with two levels.</p>
</dd>
<dt>Gender</dt><dd><p>factor with two levels.</p>
</dd>
<dt>Age</dt><dd><p>numeric: age of Consumer.</p>
</dd>
</dl>



<h3>References</h3>

<p>T. NÃ¦s, V. Lengard, S. BÃ¸lling Johansen, M. Hersleth (2010)
Alternative methods for combining design variables and consumer preference
with information about attitudes and demographics in conjoint analysis,
<em>Food Quality and Preference</em>, 10-4, 368-378, ISSN 0950-3293,
<a href="https://doi.org/10.1016/j.foodqual.2009.09.004">https://doi.org/10.1016/j.foodqual.2009.09.004</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simple model for the ham data:
fm &lt;- lmer(Informed.liking ~ Product*Information + (1|Consumer) , data=ham)

# Anova table for the fixed effects:
anova(fm)

## Not run: 
# Fit 'big' model:
fm &lt;- lmer(Informed.liking ~ Product*Information*Gender*Age +
             + (1|Consumer) + (1|Consumer:Product) +
             (1|Consumer:Information),
           data=ham)
step_fm &lt;- step(fm)
step_fm # Display elimination results
final_fm &lt;- get_model(step_fm)

## End(Not run)

</code></pre>

<hr>
<h2 id='is_estimable'>Estimability of Contrasts</h2><span id='topic+is_estimable'></span>

<h3>Description</h3>

<p>Computes the estimability of a vector or matrix of contrasts (i.e. linear
functions of the coefficients) from the nullspace of a design matrix or
potentially directly from the design matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_estimable(
  contrast,
  nullspace = NULL,
  X = NULL,
  tol = sqrt(.Machine$double.eps)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_estimable_+3A_contrast">contrast</code></td>
<td>
<p>a numeric matrix where each row is a contrast vector for
which estimability is computed. The matrix should have as many columns as
there are columns in the design matrix (which equals the number of
coefficients). If <code>contrast</code> is a vector it is coerced to a matrix.</p>
</td></tr>
<tr><td><code id="is_estimable_+3A_nullspace">nullspace</code></td>
<td>
<p>the nullspace of the design matrix.</p>
</td></tr>
<tr><td><code id="is_estimable_+3A_x">X</code></td>
<td>
<p>design matrix.</p>
</td></tr>
<tr><td><code id="is_estimable_+3A_tol">tol</code></td>
<td>
<p>tolerance for determining if a contrast is orthogonal to the</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical vector of length <code>nrow(contrast)</code> determining if each
contrast is estimable
</p>


<h3>Author(s)</h3>

<p>Rune Haubo B. Christensen
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nullspace">nullspace</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# FIXME: We need some examples here

</code></pre>

<hr>
<h2 id='lmer'>Fit Linear Mixed-Effects Models</h2><span id='topic+lmer'></span>

<h3>Description</h3>

<p>This function overloads <code><a href="lme4.html#topic+lmer">lmer</a></code> from the <span class="pkg">lme4</span>-package
(<code>lme4::lmer</code>) and adds a couple of slots needed for the computation of
Satterthwaite denominator degrees of freedom. All arguments are the same as
for <code>lme4::lmer</code> and all the usual <code>lmer</code>-methods work.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmer(
  formula,
  data = NULL,
  REML = TRUE,
  control = lmerControl(),
  start = NULL,
  verbose = 0L,
  subset,
  weights,
  na.action,
  offset,
  contrasts = NULL,
  devFunOnly = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmer_+3A_formula">formula</code></td>
<td>
<p>a two-sided linear formula object describing both the
fixed-effects and random-effects part of the model, with the
response on the left of a <code>~</code> operator and the terms, separated
by <code>+</code> operators, on the right.  Random-effects terms are
distinguished by vertical bars (<code>|</code>) separating expressions
for design matrices from grouping factors.  Two vertical bars
(<code>||</code>) can be used to specify multiple uncorrelated random
effects for the same grouping variable. 
(Because of the way it is implemented, the <code>||</code>-syntax <em>works
only for design matrices containing numeric (continuous) predictors</em>;
to fit models with independent categorical effects, see <code><a href="lme4.html#topic+dummy">dummy</a></code>
or the <code>lmer_alt</code> function from the <a href="https://CRAN.R-project.org/package=afex"><span class="pkg">afex</span></a> package.)
</p>
</td></tr>
<tr><td><code id="lmer_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables named in
<code>formula</code>.  By default the variables are taken from the
environment from which <code>lmer</code> is called. While <code>data</code> is
optional, the package authors <em>strongly</em> recommend its use,
especially when later applying methods such as <code>update</code> and
<code>drop1</code> to the fitted model (<em>such methods are not
guaranteed to work properly if <code>data</code> is omitted</em>). If
<code>data</code> is omitted, variables will be taken from the environment
of <code>formula</code> (if specified as a formula) or from the parent
frame (if specified as a character vector).</p>
</td></tr>
<tr><td><code id="lmer_+3A_reml">REML</code></td>
<td>
<p>logical scalar - Should the estimates be chosen to
optimize the REML criterion (as opposed to the log-likelihood)?</p>
</td></tr>
<tr><td><code id="lmer_+3A_control">control</code></td>
<td>
<p>a list (of correct class, resulting from
<code><a href="lme4.html#topic+lmerControl">lmerControl</a>()</code> or <code><a href="lme4.html#topic+glmerControl">glmerControl</a>()</code>
respectively) containing control parameters, including the nonlinear
optimizer to be used and parameters to be passed through to the
nonlinear optimizer, see the <code>*lmerControl</code> documentation for
details.</p>
</td></tr>
<tr><td><code id="lmer_+3A_start">start</code></td>
<td>
<p>a named <code><a href="base.html#topic+list">list</a></code> of starting values for the
parameters in the model.  For <code>lmer</code> this can be a numeric
vector or a list with one component named <code>"theta"</code>.</p>
</td></tr>
<tr><td><code id="lmer_+3A_verbose">verbose</code></td>
<td>
<p>integer scalar.  If <code>&gt; 0</code> verbose output is
generated during the optimization of the parameter estimates.  If
<code>&gt; 1</code> verbose output is generated during the individual
penalized iteratively reweighted least squares (PIRLS) steps.</p>
</td></tr>
<tr><td><code id="lmer_+3A_subset">subset</code></td>
<td>
<p>an optional expression indicating the subset of the rows
of <code>data</code> that should be used in the fit. This can be a logical
vector, or a numeric vector indicating which observation numbers are
to be included, or a character vector of the row names to be
included.  All observations are included by default.</p>
</td></tr>
<tr><td><code id="lmer_+3A_weights">weights</code></td>
<td>
<p>an optional vector of &lsquo;prior weights&rsquo; to be used
in the fitting process.  Should be <code>NULL</code> or a numeric vector.
Prior <code>weights</code> are <em>not</em> normalized or standardized in
any way.  In particular, the diagonal of the residual covariance
matrix is the squared residual standard deviation parameter
<code><a href="lme4.html#topic+sigma">sigma</a></code> times the vector of inverse <code>weights</code>.
Therefore, if the <code>weights</code> have relatively large magnitudes,
then in order to compensate, the <code><a href="lme4.html#topic+sigma">sigma</a></code> parameter will
also need to have a relatively large magnitude.</p>
</td></tr>
<tr><td><code id="lmer_+3A_na.action">na.action</code></td>
<td>
<p>a function that indicates what should happen when the
data contain <code>NA</code>s.  The default action (<code>na.omit</code>,
inherited from the 'factory fresh' value of
<code>getOption("na.action")</code>) strips any observations with any
missing values in any variables.</p>
</td></tr>
<tr><td><code id="lmer_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an <em>a priori</em> known
component to be included in the linear predictor during
fitting. This should be <code>NULL</code> or a numeric vector of length
equal to the number of cases.  One or more <code><a href="stats.html#topic+offset">offset</a></code>
terms can be included in the formula instead or as well, and if more
than one is specified their sum is used.  See
<code><a href="stats.html#topic+model.offset">model.offset</a></code>.</p>
</td></tr>
<tr><td><code id="lmer_+3A_contrasts">contrasts</code></td>
<td>
<p>an optional list. See the <code>contrasts.arg</code> of
<code>model.matrix.default</code>.</p>
</td></tr>
<tr><td><code id="lmer_+3A_devfunonly">devFunOnly</code></td>
<td>
<p>logical - return only the deviance evaluation
function. Note that because the deviance function operates on
variables stored in its environment, it may not return
<em>exactly</em> the same values on subsequent calls (but the results
should always be within machine tolerance).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details about <code>lmer</code> see <code><a href="lme4.html#topic+lmer">lmer</a></code>
(<code>help(lme4::lmer)</code>). The description of all arguments is taken
unedited from the <span class="pkg">lme4</span>-package.
</p>
<p>In cases when a valid <code>lmer</code>-object
(<code>lmerMod</code>) is produced, but when the computations needed for
Satterthwaite df fails, the <code>lmerMod</code> object is returned - not an
<code>lmerModLmerTest</code> object.
</p>


<h3>Value</h3>

<p>an S4 object of class <code>"lmerModLmerTest"</code>
</p>


<h3>Author(s)</h3>

<p>Rune Haubo B. Christensen and Alexandra Kuznetsova for the overload
in <span class="pkg">lmerTest</span> &ndash; <span class="pkg">lme4</span>-authors for the underlying implementation
in <span class="pkg">lme4</span>.
</p>


<h3>See Also</h3>

<p><code><a href="lme4.html#topic+lmer">lmer</a></code> and <code><a href="#topic+lmerModLmerTest">lmerModLmerTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("sleepstudy", package="lme4")
m &lt;- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)
class(m) # lmerModLmerTest

</code></pre>

<hr>
<h2 id='lmerModLmerTest-class'>Represent Linear Mixed-Effects Models</h2><span id='topic+lmerModLmerTest-class'></span><span id='topic+lmerModLmerTest'></span>

<h3>Description</h3>

<p>The <code>lmerModLmerTest</code> class extends <code>lmerMod</code> (which extends
<code>merMod</code>) from the <span class="pkg">lme4</span>-package.
</p>


<h3>Value</h3>

<p>An object of class <code>lmerModLmerTest</code> with slots as in
<code>lmerMod</code> objects (see <code><a href="lme4.html#topic+merMod">merMod</a></code>) and a few
additional slots as described in the slots section.
</p>


<h3>Slots</h3>


<dl>
<dt><code>vcov_varpar</code></dt><dd><p>a numeric matrix holding the asymptotic variance-covariance
matrix of the variance parameters (including sigma).</p>
</dd>
<dt><code>Jac_list</code></dt><dd><p>a list of gradient matrices (Jacobians) for the gradient of
the variance-covariance of beta with respect to the variance parameters,
where beta are the mean-value parameters available in <code>fixef(object)</code>.</p>
</dd>
<dt><code>vcov_beta</code></dt><dd><p>a numeric matrix holding the asymptotic variance-covariance
matrix of the fixed-effect regression parameters (beta).</p>
</dd>
<dt><code>sigma</code></dt><dd><p>the residual standard deviation.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Rune Haubo B. Christensen
</p>


<h3>See Also</h3>

<p><code><a href="lme4.html#topic+lmer">lmer</a></code> and <code><a href="lme4.html#topic+merMod">merMod</a></code>
</p>

<hr>
<h2 id='ls_means'>LS-means Generic Function</h2><span id='topic+ls_means'></span><span id='topic+difflsmeans'></span><span id='topic+lsmeansLT'></span>

<h3>Description</h3>

<p>LS-means Generic Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ls_means(model, ...)

difflsmeans(model, ...)

lsmeansLT(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ls_means_+3A_model">model</code></td>
<td>
<p>a model object.</p>
</td></tr>
<tr><td><code id="ls_means_+3A_...">...</code></td>
<td>
<p>parsed on to methods.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rune Haubo B. Christensen
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ls_means.lmerModLmerTest">ls_means.lmerModLmerTest</a></code>
</p>
<p><code><a href="#topic+difflsmeans.lmerModLmerTest">difflsmeans.lmerModLmerTest</a></code>
</p>
<p><code><a href="#topic+lsmeansLT.lmerModLmerTest">lsmeansLT.lmerModLmerTest</a></code>
</p>

<hr>
<h2 id='ls_means.lmerModLmerTest'>LS-means for lmerTest Model Fits</h2><span id='topic+ls_means.lmerModLmerTest'></span><span id='topic+lsmeansLT.lmerModLmerTest'></span><span id='topic+difflsmeans.lmerModLmerTest'></span>

<h3>Description</h3>

<p>Computes LS-means or pairwise differences of LS-mean for all factors in a
linear mixed model. <code>lsmeansLT</code> is provided as an alias for
<code>ls_means</code> for backward compatibility.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmerModLmerTest'
ls_means(
  model,
  which = NULL,
  level = 0.95,
  ddf = c("Satterthwaite", "Kenward-Roger"),
  pairwise = FALSE,
  ...
)

## S3 method for class 'lmerModLmerTest'
lsmeansLT(
  model,
  which = NULL,
  level = 0.95,
  ddf = c("Satterthwaite", "Kenward-Roger"),
  pairwise = FALSE,
  ...
)

## S3 method for class 'lmerModLmerTest'
difflsmeans(
  model,
  which = NULL,
  level = 0.95,
  ddf = c("Satterthwaite", "Kenward-Roger"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ls_means.lmerModLmerTest_+3A_model">model</code></td>
<td>
<p>a model object fitted with <code><a href="#topic+lmer">lmer</a></code> (of class
<code>"lmerModLmerTest"</code>).</p>
</td></tr>
<tr><td><code id="ls_means.lmerModLmerTest_+3A_which">which</code></td>
<td>
<p>optional character vector naming factors for which LS-means should
be computed. If <code>NULL</code> (default) LS-means for all factors are computed.</p>
</td></tr>
<tr><td><code id="ls_means.lmerModLmerTest_+3A_level">level</code></td>
<td>
<p>confidence level.</p>
</td></tr>
<tr><td><code id="ls_means.lmerModLmerTest_+3A_ddf">ddf</code></td>
<td>
<p>method for computation of denominator degrees of freedom.</p>
</td></tr>
<tr><td><code id="ls_means.lmerModLmerTest_+3A_pairwise">pairwise</code></td>
<td>
<p>compute pairwise differences of LS-means instead?</p>
</td></tr>
<tr><td><code id="ls_means.lmerModLmerTest_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Confidence intervals and p-values are based on the t-distribution using
degrees of freedom based on Satterthwaites or Kenward-Roger methods.
</p>
<p>LS-means is SAS terminology for predicted/estimated marginal means, i.e. means
for levels of factors which are averaged over the levels of other factors in
the model. A flat (i.e. unweighted) average is taken which gives equal weight
to all levels of each of the other factors. Numeric/continuous variables are
set at their mean values. See <span class="pkg">emmeans</span> package
for more options and greater flexibility.
</p>
<p>LS-means contrasts are checked for estimability and unestimable contrasts appear
as <code>NA</code>s in the resulting table.
</p>
<p>LS-means objects (of class <code>"ls_means"</code> have a print method).
</p>


<h3>Value</h3>

<p>An LS-means table in the form of a <code>data.frame</code>. Formally an object
of class <code>c("ls_means", "data.frame")</code> with a number of attributes set.
</p>


<h3>Author(s)</h3>

<p>Rune Haubo B. Christensen and Alexandra Kuznetsova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+show_tests.ls_means">show_tests</a></code> for display of the
underlying LS-means contrasts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Get data and fit model:
data("cake", package="lme4")
model &lt;- lmer(angle ~ recipe * temp + (1|recipe:replicate), cake)

# Compute LS-means:
ls_means(model)

# Get LS-means contrasts:
show_tests(ls_means(model))

# Compute pairwise differences of LS-means for each factor:
ls_means(model, pairwise=TRUE)
difflsmeans(model) # Equivalent.

</code></pre>

<hr>
<h2 id='merModLmerTest-class'>Legacy lmerTest representation of Linear Mixed-Effects Models</h2><span id='topic+merModLmerTest-class'></span><span id='topic+merModLmerTest'></span>

<h3>Description</h3>

<p>The <code>merModLmerTest</code> class extends <code>lmerMod</code> (which extends
<code>merMod</code>) from the <span class="pkg">lme4</span>-package.
</p>


<h3>Author(s)</h3>

<p>Rune Haubo B. Christensen
</p>

<hr>
<h2 id='nullspace'>Nullspace</h2><span id='topic+nullspace'></span>

<h3>Description</h3>

<p>Compute the (right or left) nullspace of matrix using a (semi-complete)
Singular Value Decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nullspace(A, type = c("right", "left"), tol = sqrt(.Machine$double.eps))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nullspace_+3A_a">A</code></td>
<td>
<p>a numeric matrix.</p>
</td></tr>
<tr><td><code id="nullspace_+3A_type">type</code></td>
<td>
<p><code>"right"</code> (default) gives is the standard nullspace,
<code>"left"</code> gives left nullspace of <code>A</code>.</p>
</td></tr>
<tr><td><code id="nullspace_+3A_tol">tol</code></td>
<td>
<p>tolerance multiple of the first singular value to determine if
subsequent singular values are (sufficiently) positive to be determined
greater than zero.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implementation is fastest on matrices with more rows
than columns such as a typical design matrix for a linear model.
</p>


<h3>Value</h3>

<p>a matrix with as many rows as there are columns in <code>A</code>. The
number of columns (which may be zero) determine the dimensionality of the
nullspace of <code>A</code>.
</p>


<h3>Author(s)</h3>

<p>Rune Haubo B. Christensen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# FIXME: We need some examples here

</code></pre>

<hr>
<h2 id='plot.ls_means'>Bar Plots of LS-Means</h2><span id='topic+plot.ls_means'></span>

<h3>Description</h3>

<p>Bar plots of LS-means using the <span class="pkg">ggplot2</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ls_means'
plot(x, y = NULL, which = NULL, mult = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ls_means_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+ls_means">ls_means</a></code> object.</p>
</td></tr>
<tr><td><code id="plot.ls_means_+3A_y">y</code></td>
<td>
<p>not used and ignored with a warning.</p>
</td></tr>
<tr><td><code id="plot.ls_means_+3A_which">which</code></td>
<td>
<p>optional character vector naming factors for which LS-means should
be plotted. If <code>NULL</code> (default) plots for all LS-means are generated.</p>
</td></tr>
<tr><td><code id="plot.ls_means_+3A_mult">mult</code></td>
<td>
<p>if <code>TRUE</code> and there is more than one term for which to plot
LS-means the plots are organized in panels with <code>facet_wrap</code>.</p>
</td></tr>
<tr><td><code id="plot.ls_means_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>generates the desired plots and invisibly returns the plot objects.
</p>


<h3>Author(s)</h3>

<p>Rune Haubo B. Christensen
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ls_means.lmerModLmerTest">ls_means.lmerModLmerTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fit example model with 2 factors:
data("cake", package="lme4")
cake$Temp &lt;- factor(cake$temperature, ordered = FALSE)
model &lt;- lmer(angle ~ recipe * Temp + (1|recipe:replicate), cake)

# Extract LS-means:
(lsm &lt;- ls_means(model))

# Multi-frame plot of the LS-means
plot(lsm)

# Compute list of 'single frame' plots:
res &lt;- plot(lsm, mult=FALSE)

# Display each plot separately:
plot(res[[1]])
plot(res[[2]])

# Example with pairwise differences of LS-means:
(lsm &lt;- ls_means(model, pairwise = TRUE))
plot(lsm, which="Temp")

</code></pre>

<hr>
<h2 id='plot.step_list'>Plot LS-means for Backward Reduced Model</h2><span id='topic+plot.step_list'></span>

<h3>Description</h3>

<p>Computes the LS-means for the final backward reduced model and passes these
to <code><a href="#topic+plot.ls_means">plot.ls_means</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'step_list'
plot(
  x,
  y = NULL,
  which = NULL,
  pairwise = FALSE,
  mult = TRUE,
  level = 0.95,
  ddf = c("Satterthwaite", "Kenward-Roger"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.step_list_+3A_x">x</code></td>
<td>
<p>a <code>step_list</code> object; the result of running
<code><a href="#topic+step.lmerModLmerTest">step</a></code>.</p>
</td></tr>
<tr><td><code id="plot.step_list_+3A_y">y</code></td>
<td>
<p>not used and ignored with a warning.</p>
</td></tr>
<tr><td><code id="plot.step_list_+3A_which">which</code></td>
<td>
<p>optional character vector naming factors for which LS-means should
be plotted. If <code>NULL</code> (default) plots for all LS-means are generated.</p>
</td></tr>
<tr><td><code id="plot.step_list_+3A_pairwise">pairwise</code></td>
<td>
<p>pairwise differences of LS-means?</p>
</td></tr>
<tr><td><code id="plot.step_list_+3A_mult">mult</code></td>
<td>
<p>if <code>TRUE</code> and there is more than one term for which to plot
LS-means the plots are organized in panels with <code>facet_wrap</code>.</p>
</td></tr>
<tr><td><code id="plot.step_list_+3A_level">level</code></td>
<td>
<p>confidence level.</p>
</td></tr>
<tr><td><code id="plot.step_list_+3A_ddf">ddf</code></td>
<td>
<p>denominator degree of freedom method.</p>
</td></tr>
<tr><td><code id="plot.step_list_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Error bars are confidence intervals - the default is 95
level can be changed.
</p>


<h3>Author(s)</h3>

<p>Rune Haubo B. Christensen and Alexandra Kuznetsova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ls_means.lmerModLmerTest">ls_means</a></code> and
<code><a href="#topic+plot.ls_means">plot.ls_means</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# Fit example model:
tv &lt;- lmer(Sharpnessofmovement ~ TVset * Picture +
             (1 | Assessor:TVset) + (1 | Assessor:Picture) +
             (1 | Assessor:Picture:TVset) + (1 | Repeat) + (1 | Repeat:Picture) +
             (1 | Repeat:TVset) + (1 | Repeat:TVset:Picture) + (1 | Assessor),
           data = TVbo)

# Backward reduce the model:
(st &lt;- step(tv)) # takes ~10 sec to run

# Pairwise comparisons of LS-means for Picture and TVset:
  plot(st, which=c("Picture", "TVset"), pairwise = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='qform'>Compute Quadratic Form</h2><span id='topic+qform'></span>

<h3>Description</h3>

<p>Efficiently computes <code class="reqn">x' A x</code> - or in R-notation:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qform(x, A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qform_+3A_x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="qform_+3A_a">A</code></td>
<td>
<p>a symmetric numeric matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Length of <code>x</code> should equal the number of rows and columns of <code>A</code>.
</p>


<h3>Value</h3>

<p>a numerical scalar
</p>

<hr>
<h2 id='ranova'>ANOVA-Like Table for Random-Effects</h2><span id='topic+ranova'></span><span id='topic+rand'></span>

<h3>Description</h3>

<p>Compute an ANOVA-like table with tests of random-effect terms in the model.
Each random-effect term is reduced or removed and likelihood ratio tests of
model reductions are presented in a form similar to that of
<code><a href="#topic+drop1.lmerModLmerTest">drop1</a></code>.
<code>rand</code> is an alias for <code>ranova</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ranova(model, reduce.terms = TRUE, ...)

rand(model, reduce.terms = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ranova_+3A_model">model</code></td>
<td>
<p>a linear mixed effect model fitted with <code>lmer()</code>
(inheriting from class <code>lmerMod</code>).</p>
</td></tr>
<tr><td><code id="ranova_+3A_reduce.terms">reduce.terms</code></td>
<td>
<p>if <code>TRUE</code> (default) random-effect terms are
reduced (if possible). If <code>FALSE</code> random-effect terms are simply
removed.</p>
</td></tr>
<tr><td><code id="ranova_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the model is fitted with REML the tests are REML-likelihood ratio tests.
</p>
<p>A random-effect term of the form <code>(f1 + f2 | gr)</code> is reduced to
terms of the form <code>(f2 | gr)</code> and <code>(f1 | gr)</code> and these reduced
models are compared to the original model.
If <code>reduce.terms</code> is <code>FALSE</code> <code>(f1 + f2 | gr)</code> is removed
instead.
</p>
<p>A random-effect term of the form <code>(f1 | gr)</code> is reduced to <code>(1 | gr)</code>
(unless <code>reduce.terms</code> is <code>FALSE</code>).
</p>
<p>A random-effect term of the form <code>(1 | gr)</code> is not reduced but
simply removed.
</p>
<p>A random-effect term of the form <code>(0 + f1 | gr)</code> or <code>(-1 + f1 | gr)</code>
is reduced (if <code>reduce.terms = TRUE</code>) to <code>(1 | gr)</code>.
</p>
<p>A random-effect term of the form <code>(1 | gr1/gr2)</code> is automatically
expanded to two terms: <code>(1 | gr2:gr1)</code> and <code>(1 | gr1)</code> using
<code><a href="lme4.html#topic+findbars">findbars</a></code>.
</p>
<p>In this exposition it is immaterial whether <code>f1</code> and <code>f2</code> are
factors or continuous variables.
</p>


<h3>Value</h3>

<p>an ANOVA-like table with single term deletions of random-effects
inheriting from class <code>anova</code> and <code>data.frame</code> with the columns:
</p>
<table>
<tr><td><code>npar</code></td>
<td>
<p>number of model parameters.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>the log-likelihood for the model. Note that this is the
REML-logLik if the model is fitted with REML.</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>the AIC for the model evaluated as <code>-2*(logLik - npar)</code>.
Smaller is better.</p>
</td></tr>
<tr><td><code>LRT</code></td>
<td>
<p>the likelihood ratio test statistic; twice the difference in
log-likelihood, which is asymptotically chi-square distributed.</p>
</td></tr>
<tr><td><code>Df</code></td>
<td>
<p>degrees of freedom for the likelihood ratio test: the difference in
number of model parameters.</p>
</td></tr>
<tr><td><code>Pr(&gt;Chisq)</code></td>
<td>
<p>the p-value.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>In certain cases tests of non-nested models may be generated. An example
is when <code>(0 + poly(x, 2) | gr)</code> is reduced (the default) to <code>(1 | gr)</code>.
To our best knowledge non-nested model comparisons are only generated in
cases which are statistical nonsense anyway (such as in this example where
the random intercept is suppressed).
</p>


<h3>Note</h3>

<p>Note that <code>anova</code> can be used to compare two models and will often
be able to produce the same tests as <code>ranova</code>. This is, however, not always the
case as illustrated in the examples.
</p>


<h3>Author(s)</h3>

<p>Rune Haubo B. Christensen and Alexandra Kuznetsova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+drop1.lmerModLmerTest">drop1</a></code> for tests of marginal
fixed-effect terms and
<code><a href="stats.html#topic+anova">anova</a></code> for usual anova tables for fixed-effect terms.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Test reduction of (Days | Subject) to (1 | Subject):
fm1 &lt;- lmer(Reaction ~ Days + (Days|Subject), sleepstudy)
ranova(fm1) # 2 df test

# This test can also be achieved with anova():
fm2 &lt;- lmer(Reaction ~ Days + (1|Subject), sleepstudy)
anova(fm1, fm2, refit=FALSE)

# Illustrate reduce.test argument:
# Test removal of (Days | Subject):
ranova(fm1, reduce.terms = FALSE) # 3 df test

# The likelihood ratio test statistic is in this case:
fm3 &lt;- lm(Reaction ~ Days, sleepstudy)
2*c(logLik(fm1, REML=TRUE) - logLik(fm3, REML=TRUE)) # LRT

# anova() is not always able to perform the same tests as ranova(),
# for example:
anova(fm1, fm3, refit=FALSE) # compares REML with ML and should not be used
anova(fm1, fm3, refit=TRUE) # is a test of ML fits and not what we seek

# Also note that the lmer-fit needs to come first - not an lm-fit:
# anova(fm3, fm1) # does not work and gives an error

# ranova() may not generate all relevant test:
# For the following model ranova() indicates that we should not reduce
# (TVset | Assessor):
fm &lt;- lmer(Coloursaturation ~ TVset * Picture + (TVset | Assessor), data=TVbo)
ranova(fm)
# However, a more appropriate model is:
fm2 &lt;- lmer(Coloursaturation ~ TVset * Picture + (1 | TVset:Assessor), data=TVbo)
anova(fm, fm2, refit=FALSE)
# fm and fm2 has essentially the same fit to data but fm uses 5 parameters
# more than fm.

</code></pre>

<hr>
<h2 id='rbindall'><code>rbind</code> Multiple Objects</h2><span id='topic+rbindall'></span>

<h3>Description</h3>

<p><code>rbind</code> Multiple Objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbindall(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbindall_+3A_...">...</code></td>
<td>
<p>objects to be <code>rbind</code>'ed - typically matrices or vectors</p>
</td></tr>
</table>

<hr>
<h2 id='rm_complete_terms'>Remove Terms from Formula</h2><span id='topic+rm_complete_terms'></span>

<h3>Description</h3>

<p>Remove fixef or ranef terms from formula, return a list of modified formulae
with environment restored to that of the original formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rm_complete_terms(terms, full_formula, random = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rm_complete_terms_+3A_terms">terms</code></td>
<td>
<p>character vector (or list) of terms to remove from
<code>full_formula</code></p>
</td></tr>
<tr><td><code id="rm_complete_terms_+3A_full_formula">full_formula</code></td>
<td>
<p>formula</p>
</td></tr>
<tr><td><code id="rm_complete_terms_+3A_random">random</code></td>
<td>
<p>if <code>TRUE</code> names of the return list have parentheses around
them.</p>
</td></tr>
</table>

<hr>
<h2 id='show_tests'>Show Tests Generic Function and Default Method</h2><span id='topic+show_tests'></span><span id='topic+show_tests.default'></span>

<h3>Description</h3>

<p>Show Tests Generic Function and Default Method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_tests(object, ...)

## Default S3 method:
show_tests(object, fractions = FALSE, names = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_tests_+3A_object">object</code></td>
<td>
<p>a suitable object with an <code>"hypotheses"</code> attribute, e.g. an
anova table or an <code>ls_means</code> table as defined in <span class="pkg">lmerTest</span>.</p>
</td></tr>
<tr><td><code id="show_tests_+3A_...">...</code></td>
<td>
<p>parsed on to methods; currently not used in the default method.</p>
</td></tr>
<tr><td><code id="show_tests_+3A_fractions">fractions</code></td>
<td>
<p>display entries in the hypothesis matrices as fractions?</p>
</td></tr>
<tr><td><code id="show_tests_+3A_names">names</code></td>
<td>
<p>if <code>FALSE</code> column and row names of the hypothesis matrices
are suppressed.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rune Haubo B. Christensen
</p>
<p>Rune Haubo B. Christensen
</p>


<h3>See Also</h3>

<p><code><a href="#topic+show_tests.anova">show_tests.anova</a></code> and <code><a href="#topic+show_tests.ls_means">show_tests.ls_means</a></code>
</p>

<hr>
<h2 id='show_tests.anova'>Show Hypothesis Tests in ANOVA Tables</h2><span id='topic+show_tests.anova'></span>

<h3>Description</h3>

<p>Extracts hypothesis matrices for terms in ANOVA tables detailing exactly which
functions of the parameters are being tested in anova tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'anova'
show_tests(object, fractions = FALSE, names = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_tests.anova_+3A_object">object</code></td>
<td>
<p>an anova table with a <code>"hypotheses"</code> attribute.</p>
</td></tr>
<tr><td><code id="show_tests.anova_+3A_fractions">fractions</code></td>
<td>
<p>display entries in the hypothesis matrices as fractions?</p>
</td></tr>
<tr><td><code id="show_tests.anova_+3A_names">names</code></td>
<td>
<p>if <code>FALSE</code> column and row names of the hypothesis matrices
are suppressed.</p>
</td></tr>
<tr><td><code id="show_tests.anova_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of hypothesis matrices.
</p>


<h3>Author(s)</h3>

<p>Rune Haubo B. Christensen
</p>


<h3>See Also</h3>

<p><code><a href="#topic+show_tests.ls_means">show_tests</a></code> for <code>ls_means</code>
objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fit basic model to the 'cake' data:
data("cake", package="lme4")
fm1 &lt;- lmer(angle ~ recipe * temp + (1|recipe:replicate), cake)

# Type 3 anova table:
(an &lt;- anova(fm1, type="3"))

# Display tests/hypotheses for type 1, 2, and 3 ANOVA tables:
# (and illustrate effects of 'fractions' and 'names' arguments)
show_tests(anova(fm1, type="1"))
show_tests(anova(fm1, type="2"), fractions=TRUE, names=FALSE)
show_tests(an, fractions=TRUE)

</code></pre>

<hr>
<h2 id='show_tests.ls_means'>Show LS-means Hypothesis Tests and Contrasts</h2><span id='topic+show_tests.ls_means'></span>

<h3>Description</h3>

<p>Extracts the contrasts which defines the LS-mean hypothesis tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ls_means'
show_tests(object, fractions = FALSE, names = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_tests.ls_means_+3A_object">object</code></td>
<td>
<p>an <code>ls_means</code> object.</p>
</td></tr>
<tr><td><code id="show_tests.ls_means_+3A_fractions">fractions</code></td>
<td>
<p>display contrasts as fractions rather than decimal numbers?</p>
</td></tr>
<tr><td><code id="show_tests.ls_means_+3A_names">names</code></td>
<td>
<p>include row and column names of the contrasts matrices?</p>
</td></tr>
<tr><td><code id="show_tests.ls_means_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of contrast matrices; one matrix for each model term.
</p>


<h3>Author(s)</h3>

<p>Rune Haubo B. Christensen
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ls_means.lmerModLmerTest">ls_means</a></code> for computation of
LS-means and <code><a href="#topic+show_tests.anova">show_tests</a></code> for <code>anova</code>
objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("cake", package="lme4")
model &lt;- lmer(angle ~ recipe * temp + (1|recipe:replicate), cake)

# LS-means:
(lsm &lt;- ls_means(model))

# Contrasts for LS-means estimates and hypothesis tests:
show_tests(lsm)

</code></pre>

<hr>
<h2 id='single_anova'>ANOVA Tables for Linear Mixed Models</h2><span id='topic+single_anova'></span>

<h3>Description</h3>

<p>ANOVA Tables for Linear Mixed Models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>single_anova(
  object,
  type = c("III", "II", "I", "3", "2", "1", "yates", "marginal", "2b"),
  ddf = c("Satterthwaite", "Kenward-Roger")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="single_anova_+3A_object">object</code></td>
<td>
<p>an <code>lmerModLmerTest</code> object; the result of <code>lmer()</code>
after loading the <span class="pkg">lmerTest</span>-package.</p>
</td></tr>
<tr><td><code id="single_anova_+3A_type">type</code></td>
<td>
<p>the type of ANOVA table requested (using the SAS terminology for
these) with Type I being the familiar sequential ANOVA table.</p>
</td></tr>
<tr><td><code id="single_anova_+3A_ddf">ddf</code></td>
<td>
<p>method for computing denominator degrees of freedom.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an ANOVA table
</p>


<h3>Author(s)</h3>

<p>Rune Haubo B. Christensen
</p>

<hr>
<h2 id='step'>Generic Step Function</h2><span id='topic+step'></span><span id='topic+step.default'></span>

<h3>Description</h3>

<p>Generic step function with default method <code>stats::step</code>. This
construction ensures that <code>stats::step</code> still works on <code>lm</code>
objects etc. after loading the <span class="pkg">lmerTest</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step(object, ...)

## Default S3 method:
step(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_+3A_object">object</code></td>
<td>
<p>a model object.</p>
</td></tr>
<tr><td><code id="step_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rune Haubo B. Christensen
</p>


<h3>See Also</h3>

<p><code><a href="#topic+step.lmerModLmerTest">step</a></code>
</p>

<hr>
<h2 id='step.lmerModLmerTest'>Backward Elimination for Linear Mixed Models</h2><span id='topic+step.lmerModLmerTest'></span><span id='topic+get_model.step_list'></span>

<h3>Description</h3>

<p>Backward elimination of random-effect terms followed by backward elimination
of fixed-effect terms in linear mixed models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmerModLmerTest'
step(
  object,
  ddf = c("Satterthwaite", "Kenward-Roger"),
  alpha.random = 0.1,
  alpha.fixed = 0.05,
  reduce.fixed = TRUE,
  reduce.random = TRUE,
  keep,
  ...
)

## S3 method for class 'step_list'
get_model(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step.lmerModLmerTest_+3A_object">object</code></td>
<td>
<p>a fitted model object. For the <code>lmerModLmerTest</code> method
an <code><a href="#topic+lmer">lmer</a></code> model fit (of class <code>"lmerModLmerTest"</code>.)</p>
</td></tr>
<tr><td><code id="step.lmerModLmerTest_+3A_ddf">ddf</code></td>
<td>
<p>the method for computing the denominator degrees of freedom and
F-statistics. <code>ddf="Satterthwaite"</code> (default) uses Satterthwaite's method;
<code>ddf="Kenward-Roger"</code> uses Kenward-Roger's method.</p>
</td></tr>
<tr><td><code id="step.lmerModLmerTest_+3A_alpha.random">alpha.random</code></td>
<td>
<p>alpha for random effects elimination</p>
</td></tr>
<tr><td><code id="step.lmerModLmerTest_+3A_alpha.fixed">alpha.fixed</code></td>
<td>
<p>alpha for fixed effects elimination</p>
</td></tr>
<tr><td><code id="step.lmerModLmerTest_+3A_reduce.fixed">reduce.fixed</code></td>
<td>
<p>reduce fixed effect structure? <code>TRUE</code> by default.</p>
</td></tr>
<tr><td><code id="step.lmerModLmerTest_+3A_reduce.random">reduce.random</code></td>
<td>
<p>reduce random effect structure? <code>TRUE</code> by default.</p>
</td></tr>
<tr><td><code id="step.lmerModLmerTest_+3A_keep">keep</code></td>
<td>
<p>an optional character vector of fixed effect terms which should
not be considered for eliminated. Valid terms are given by
<code>attr(terms(object), "term.labels")</code>. Terms that are marginal to terms
in keep will also not be considered for eliminations.</p>
</td></tr>
<tr><td><code id="step.lmerModLmerTest_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
<tr><td><code id="step.lmerModLmerTest_+3A_x">x</code></td>
<td>
<p>a step object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tests of random-effects are performed using <code><a href="#topic+ranova">ranova</a></code> (using
<code>reduce.terms = TRUE</code>) and tests of fixed-effects are performed using
<code><a href="#topic+drop1.lmerModLmerTest">drop1</a></code>.
</p>
<p>The step method for <code><a href="#topic+lmer">lmer</a></code> fits has a print method.
</p>


<h3>Value</h3>

<p><code>step</code> returns a list with elements <code>"random"</code> and
<code>"fixed"</code> each
containing anova-like elimination tables. The <code>"fixed"</code> table is
based on <code>drop1</code> and the <code>"random"</code> table is
based on <code>ranova</code> (a <code>drop1</code>-like table for random effects). Both
tables have a column <code>"Eliminated"</code> indicating the order in which terms
are eliminated from the model with zero (<code>0</code>) indicating that the term
is not eliminated from the model.
</p>
<p>The <code>step</code> object also contains the final model as an attribute which
is extractable with <code>get_model(&lt;step_object&gt;)</code>.
</p>


<h3>Author(s)</h3>

<p>Rune Haubo B. Christensen and Alexandra Kuznetsova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+drop1.lmerModLmerTest">drop1</a></code> for tests of marginal
fixed-effect terms and <code><a href="#topic+ranova">ranova</a></code> for a
<code><a href="#topic+drop1.lmerModLmerTest">drop1</a></code>-like table of reduction of
random-effect terms.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fit a model to the ham dataset:
fm &lt;- lmer(Informed.liking ~ Product*Information+
             (1|Consumer) + (1|Product:Consumer)
           + (1|Information:Consumer), data=ham)

# Backward elimination using terms with default alpha-levels:
(step_res &lt;- step(fm))
final &lt;- get_model(step_res)
anova(final)

## Not run: 
# Fit 'big' model:
fm &lt;- lmer(Informed.liking ~ Product*Information*Gender*Age +
             + (1|Consumer) + (1|Consumer:Product) +
             (1|Consumer:Information), data=ham)
step_fm &lt;- step(fm)
step_fm # Display elimination results
final_fm &lt;- get_model(step_fm)

## End(Not run)

</code></pre>

<hr>
<h2 id='summary.lmerModLmerTest'>Summary Method for Linear Mixed Models</h2><span id='topic+summary.lmerModLmerTest'></span>

<h3>Description</h3>

<p>Summaries of Linear Mixed Models with coefficient tables including t-tests
and p-values using Satterthwaites's or Kenward-Roger's methods for
degrees-of-freedom and t-statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmerModLmerTest'
summary(object, ..., ddf = c("Satterthwaite", "Kenward-Roger", "lme4"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.lmerModLmerTest_+3A_object">object</code></td>
<td>
<p>an lmerModLmerTest object.</p>
</td></tr>
<tr><td><code id="summary.lmerModLmerTest_+3A_...">...</code></td>
<td>
<p>additional arguments passed on to <code>lme4::summary.merMod</code></p>
</td></tr>
<tr><td><code id="summary.lmerModLmerTest_+3A_ddf">ddf</code></td>
<td>
<p>the method for computing the degrees of freedom and
t-statistics. <code>ddf="Satterthwaite"</code> (default) uses Satterthwaite's method;
<code>ddf="Kenward-Roger"</code> uses Kenward-Roger's method,
<code>ddf = "lme4"</code> returns the lme4-summary i.e., using the summary
method for <code>lmerMod</code> objects as defined in the <span class="pkg">lme4</span>-package and
ignores the <code>type</code> argument. Partial matching is allowed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The returned object is of class
<code>c("summary.lmerModLmerTest", "summary.merMod")</code> utilizing <code>print</code>,
<code>coef</code> and other methods defined for <code>summary.merMod</code> objects.
The <code>"Kenward-Roger"</code> method use methods from the <span class="pkg">pbkrtest</span> package internally
to compute t-statistics and associated degrees-of-freedom.
</p>


<h3>Value</h3>

<p>A summary object with a coefficient table (a <code>matrix</code>) including
t-values and p-values. The coefficient table can be extracted with
<code>coef(summary(&lt;my-model&gt;))</code>.
</p>


<h3>Author(s)</h3>

<p>Rune Haubo B. Christensen and Alexandra Kuznetsova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+contest1D">contest1D</a></code> for one degree-of-freedom contrast tests
and <code><a href="pbkrtest.html#topic+KRmodcomp">KRmodcomp</a></code> for Kenward-Roger F-tests.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fit example model:
data("sleepstudy", package="lme4")
fm &lt;- lmer(Reaction ~ Days + (1|Subject) + (0+Days|Subject), sleepstudy)

# Get model summary:
summary(fm) # Satterthwaite df and t-tests

# Extract coefficient table:
coef(summary(fm))

# Use the Kenward-Roger method
if(requireNamespace("pbkrtest", quietly = TRUE))
  summary(fm, ddf="Kenward-Roger")

# The lme4-summary table:
summary(fm, ddf="lme4") # same as summary(as(fm, "lmerMod"))


</code></pre>

<hr>
<h2 id='term_contain'>Determine which Terms Contain a Term</h2><span id='topic+term_contain'></span>

<h3>Description</h3>

<p>The definition of <em>containment</em> follows from the SAS documentation on
&quot;The Four Types of Estimable Functions&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>term_contain(term, factors, dataClasses, term_names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="term_contain_+3A_term">term</code></td>
<td>
<p>character; name of a model term and one of <code>term_names</code>.</p>
</td></tr>
<tr><td><code id="term_contain_+3A_factors">factors</code></td>
<td>
<p>the result of <code>attr(terms_object, "factors")</code>.</p>
</td></tr>
<tr><td><code id="term_contain_+3A_dataclasses">dataClasses</code></td>
<td>
<p>the result of
<code>attr(terms(model, fixed.only=FALSE), "dataClasses")</code>. Note that
<code>fixed.only=FALSE</code> is only needed for <code>merMod</code> objects, but does
no harm for <code>lm</code> objects.</p>
</td></tr>
<tr><td><code id="term_contain_+3A_term_names">term_names</code></td>
<td>
<p>the result of <code>attr(terms_object, "term.labels")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Containment is defined for two model terms, say, F1 and F2 as:
F1 is contained in F2 (F2 contains F1) if
</p>

<ol>
<li><p> F1 and F2 involve the same continuous variables (if any)
</p>
</li>
<li><p> F2 involve more factors than F1
</p>
</li>
<li><p> All factors in F1 (if any) are part of F2
</p>
</li></ol>

<p>The intercept, though not really a model term, is defined by SAS to be
contained in all factor terms, but it is not contained in any
effect involving a continuous variable.
</p>


<h3>Value</h3>

<p>a logical vector indicating for each term in <code>term_names</code> if
it contains <code>term</code>.
</p>

<hr>
<h2 id='TVbo'>Sensory Assesment of B&amp;O TVs</h2><span id='topic+TVbo'></span>

<h3>Description</h3>

<p>The TVbo dataset has kindly been made available by the Danish high-end
consumer electronics company
<a href="https://www.bang-olufsen.com">Bang &amp; Olufsen</a>.
The main purpose was to assess 12 different TV sets (products) specified by
the two attributes Picture and TVset.
15 different response variables (characteristics of the
product) were assessed by a trained panel with 8 assessors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(TVbo)
</code></pre>


<h3>Format</h3>


<dl>
<dt>Assessor</dt><dd><p>factor with 8 levels assessors.</p>
</dd>
<dt>TVset</dt><dd><p>product factor with 3 levels.</p>
</dd>
<dt>Picture</dt><dd><p>product factor with 4 levels.</p>
</dd>
</dl>

<p>In addition the following 15 numeric (response) variables are the
characteristics on which the TV sets (products) are assessed:
</p>
<p>Coloursaturation, Colourbalance, Noise, Depth, Sharpness, Lightlevel,
Contrast, Sharpnessofmovement, Flickeringstationary, Flickeringmovement,
Distortion, Dimglasseffect, Cutting, Flossyedges, Elasticeffect.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fm &lt;- lmer(Coloursaturation ~ TVset + Picture + (1|Assessor:TVset) +
             (1|Assessor), data=TVbo)
ranova(fm)
anova(fm)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
