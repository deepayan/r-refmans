<!DOCTYPE html><html><head><title>Help for package rSRD</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rSRD}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#calculateCrossValidation'><p>calculateCrossValidation</p></a></li>
<li><a href='#calculateSRDDistribution'><p>calculateSRDDistribution</p></a></li>
<li><a href='#calculateSRDValues'><p>calculateSRDValues</p></a></li>
<li><a href='#plotCrossValidation'><p>plotCrossValidation</p></a></li>
<li><a href='#plotHeatmapSRD'><p>plotHeatmapSRD</p></a></li>
<li><a href='#plotPermTest'><p>plotPermTest</p></a></li>
<li><a href='#utilsCalculateDistance'><p>utilsCalculateDistance</p></a></li>
<li><a href='#utilsCalculateRank'><p>utilsCalculateRank</p></a></li>
<li><a href='#utilsColorPalette'><p>utilsColorPalette</p></a></li>
<li><a href='#utilsCreateReference'><p>utilsCreateReference</p></a></li>
<li><a href='#utilsDetailedSRD'><p>utilsDetailedSRD</p></a></li>
<li><a href='#utilsDetailedSRDNoChars'><p>utilsDetailedSRDNoChars</p></a></li>
<li><a href='#utilsMaxSRD'><p>utilsMaxSRD</p></a></li>
<li><a href='#utilsPreprocessDF'><p>utilsPreprocessDF</p></a></li>
<li><a href='#utilsRankingMatrix'><p>utilsRankingMatrix</p></a></li>
<li><a href='#utilsTieProbability'><p>utilsTieProbability</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Sum of Ranking Differences Statistical Test</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.7</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jochen Staudacher &lt;jochen.staudacher@hs-kempten.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>We provide an implementation for Sum of Ranking Differences (SRD), 
    a novel statistical test introduced by Héberger (2010) 
    &lt;<a href="https://doi.org/10.1016%2Fj.trac.2009.09.009">doi:10.1016/j.trac.2009.09.009</a>&gt;. The test allows the comparison of 
    different solutions through a reference by first performing a rank 
    transformation on the input, then calculating and comparing the distances 
    between the solutions and the reference - the latter is measured in the 
    L1 norm. The reference can be an external benchmark (e.g. an established 
    gold standard) or can be aggregated from the data. The calculated distances, 
    called SRD scores, are validated in two ways, see Héberger and Kollár-Hunek 
    (2011) &lt;<a href="https://doi.org/10.1002%2Fcem.1320">doi:10.1002/cem.1320</a>&gt;. A randomization test (also called permutation 
    test) compares the SRD scores of the solutions to the SRD scores of randomly 
    generated rankings. The second validation option is cross-validation that 
    checks whether the rankings generated from the solutions come from the same 
    distribution or not. For a detailed analysis about the cross-validation 
    process see Sziklai, Baranyi and Héberger (2021) &lt;<a href="https://arxiv.org/abs/2105.11939">arXiv:2105.11939</a>&gt;. The 
    package offers a wide array of features related to SRD including the computation 
    of the SRD scores, validation options, input preprocessing and plotting tools. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, dplyr, janitor, tibble, ggplot2, stringr, methods,
rlang, ggrepel, gplots</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++17, Rtools (&gt;= 4.2) for Windows</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-07 09:12:32 UTC; Jochen</td>
</tr>
<tr>
<td>Author:</td>
<td>Jochen Staudacher [aut, cph, cre],
  Balázs R. Sziklai [aut, cph],
  Linus Olsson [aut, cph],
  Dennis Horn [ctb],
  Alexander Pothmann [ctb],
  Ali Tugay Sen [ctb],
  Attila Gere [ctb],
  Károly Hébeger [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-08 08:02:31 UTC</td>
</tr>
</table>
<hr>
<h2 id='calculateCrossValidation'>calculateCrossValidation</h2><span id='topic+calculateCrossValidation'></span>

<h3>Description</h3>

<p>R interface to test whether the rankings induced by the columns come from the same 
distribution. If the number of folds and the test method are not specified, the default is 
the 8-fold Wilcoxon test combined with cross-validation. If the number of rows is less than 8, 
leave-one-out cross-validation is applied. Columns are ordered based on the SRD values of the 
different folds, then each consecutive column-pairs are tested. Test statistics for Alpaydin test 
follows F distribution with df1=2k, df2=k degrees of freedom. Dietterich test statistics follow 
t-distribution with k degrees of freedom (two-tailed). Wilcoxon test statistics is calculated 
as the absolute value of the difference of the sum of the positive ranks (W+) and sum of the 
negative ranks (W-). The distribution for this test statistics can be derived from the Wilcoxon 
signed rank distribution. For more information about the cross-validation process see 
Sziklai, Baranyi and Héberger (2021).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateCrossValidation(
  data_matrix,
  method = "Wilcoxon",
  number_of_folds = 8,
  precision = 5,
  output_to_file = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculateCrossValidation_+3A_data_matrix">data_matrix</code></td>
<td>
<p>A DataFrame.</p>
</td></tr>
<tr><td><code id="calculateCrossValidation_+3A_method">method</code></td>
<td>
<p>A string specifying the method. The methods &quot;Wilcoxon&quot;, &quot;Alpaydin&quot; and &quot;Dietterich&quot; are available.</p>
</td></tr>
<tr><td><code id="calculateCrossValidation_+3A_number_of_folds">number_of_folds</code></td>
<td>
<p>The number of folds used in the cross validation. Ranges between 5 to 10.</p>
</td></tr>
<tr><td><code id="calculateCrossValidation_+3A_precision">precision</code></td>
<td>
<p>The precision used for the the ranking matrix transformation.</p>
</td></tr>
<tr><td><code id="calculateCrossValidation_+3A_output_to_file">output_to_file</code></td>
<td>
<p>Boolean flag to enable file output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A List containing
</p>

<ul>
<li><p> a new column order sorted by the median of the SRD values computed on the different folds
</p>
</li>
<li><p> a vector of test statistics corresponding to each consecutive column pairs
</p>
</li>
<li><p> a vector indicating the test statistics' statistical significance 
</p>
</li>
<li><p> the SRD values of different folds and 
</p>
</li>
<li><p> additional data needed for the plotCrossValidation function. 
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Balázs R. Sziklai <a href="mailto:sziklai.balazs@krtk.hu">sziklai.balazs@krtk.hu</a>, Linus Olsson <a href="mailto:linusmeol@gmail.com">linusmeol@gmail.com</a>, Jochen Staudacher <a href="mailto:jochen.staudacher@hs-kempten.de">jochen.staudacher@hs-kempten.de</a>
</p>


<h3>References</h3>

<p>Sziklai, Balázs R., Máté Baranyi, and Károly Héberger (2021). 
&quot;Testing Cross-Validation Variants in Ranking Environments&quot;,  
arXiv preprint arXiv:2105.11939 (2021).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(
Sol_1=c(7, 6, 5, 4, 3, 2, 1),
Sol_2=c(1, 2, 3, 4, 5, 7, 6),
Sol_3=c(1, 2, 3, 4, 7, 5, 6),
Ref=c(1, 2, 3, 4, 5, 6, 7))

calculateCrossValidation(df, output_to_file = FALSE)
</code></pre>

<hr>
<h2 id='calculateSRDDistribution'>calculateSRDDistribution</h2><span id='topic+calculateSRDDistribution'></span>

<h3>Description</h3>

<p>R interface to calculate the SRD distribution that corresponds to the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateSRDDistribution(
  data_matrix,
  option = "f",
  tie_probability = 0,
  output_to_file = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculateSRDDistribution_+3A_data_matrix">data_matrix</code></td>
<td>
<p>A DataFrame.</p>
</td></tr>
<tr><td><code id="calculateSRDDistribution_+3A_option">option</code></td>
<td>
<p>A char to specify how ties are generated in the simulation.
The following options are available:
</p>

<ul>
<li><p> 'n': There are no ties for the solution vectors, the reference vector is fixed.
</p>
</li>
<li><p> 'r': There are no ties. Both the column vector and the reference are generated randomly.
</p>
</li>
<li><p> 't': Ties occur with a fixed probability specified by the user for both the solution vectors and the reference vector.
</p>
</li>
<li><p> 'p': Ties occur with a fixed probability specified by the user for the solution vectors, the reference vector is fixed.
</p>
</li>
<li><p> 'd': Tie distribution reflects the tie frequencies displayed by the solution vectors, the reference vector is fixed.
</p>
</li>
<li><p> As default (recommended): Tie distribution reflects the tie frequencies displayed in the reference, the reference vector is fixed.
</p>
</li></ul>
</td></tr>
<tr><td><code id="calculateSRDDistribution_+3A_tie_probability">tie_probability</code></td>
<td>
<p>The probability with which ties can occur.</p>
</td></tr>
<tr><td><code id="calculateSRDDistribution_+3A_output_to_file">output_to_file</code></td>
<td>
<p>Boolean flag to enable file output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A List containing the SRD distribution and related descriptive statistics. xx1 value 
indicates the 5 percent significance threshold. SRD values falling between xx1 and xx19 are not 
distinguishable from SRD scores of random rankings, while an SRD score higher than xx19 indicates 
that the solution ranks the objects in a reverse order (with 5 percent significance).
</p>


<h3>Author(s)</h3>

<p>Balázs R. Sziklai <a href="mailto:sziklai.balazs@krtk.hu">sziklai.balazs@krtk.hu</a>, Linus Olsson <a href="mailto:linusmeol@gmail.com">linusmeol@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;- data.frame(
A=c(32, 52, 44, 44, 47),
B=c(73, 75, 65, 76, 70),
C=c(60, 59, 57, 55, 60),
D=c(35, 24, 44, 83, 47),
E=c(41, 52, 46, 50, 65))

calculateSRDDistribution(df, option = 'p', tie_probability = 0.5)

</code></pre>

<hr>
<h2 id='calculateSRDValues'>calculateSRDValues</h2><span id='topic+calculateSRDValues'></span>

<h3>Description</h3>

<p>R interface to calculate SRD values.
To test the results' significance run calculateSRDDistribution(). 
For more information about SRD scores and their validation 
see Héberger and Kollár-Hunek (2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateSRDValues(data_matrix, output_to_file = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculateSRDValues_+3A_data_matrix">data_matrix</code></td>
<td>
<p>A DataFrame.</p>
</td></tr>
<tr><td><code id="calculateSRDValues_+3A_output_to_file">output_to_file</code></td>
<td>
<p>Boolean flag to enable file output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the SRD values.
</p>


<h3>Author(s)</h3>

<p>Balázs R. Sziklai <a href="mailto:sziklai.balazs@krtk.hu">sziklai.balazs@krtk.hu</a>, Linus Olsson <a href="mailto:linusmeol@gmail.com">linusmeol@gmail.com</a>
</p>


<h3>References</h3>

<p>Héberger K., Kollár-Hunek K. (2011) 
&quot;Sum of ranking differences for method discrimination and its validation:
comparison of ranks with random numbers&quot;, Journal of Chemometrics, 25(4), pp. 151–158.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(
A=c(32, 52, 44, 44, 47),
B=c(73, 75, 65, 76, 70),
C=c(60, 59, 57, 55, 60),
D=c(35, 24, 44, 83, 47),
E=c(41, 52, 46, 50, 65))

calculateSRDValues(df)
</code></pre>

<hr>
<h2 id='plotCrossValidation'>plotCrossValidation</h2><span id='topic+plotCrossValidation'></span>

<h3>Description</h3>

<p>Plots data generated by the calculateCrossValidation function as a boxplot. 
Includes max and min as whiskers as well as the average (marked by a crossed circle), 
median (marked by a horizontal bold line) and the 1st and 3rd quartile of the values. 
Visualizes outliers in the data as red triangles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCrossValidation(cv_results)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCrossValidation_+3A_cv_results">cv_results</code></td>
<td>
<p>The List of results returned by the calculateCrossValidation function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Linus Olsson <a href="mailto:linusmeol@gmail.com">linusmeol@gmail.com</a>, Alexander Pothmann
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(
Sol_1=c(7, 6, 5, 4, 3, 2, 1),
Sol_2=c(1, 2, 3, 4, 5, 7, 6),
Sol_3=c(1, 2, 3, 4, 7, 5, 6),
Ref=c(1, 2, 3, 4, 5, 6, 7))

cv_results &lt;- rSRD::calculateCrossValidation(df, output_to_file = FALSE) 
rSRD::plotCrossValidation(cv_results)
</code></pre>

<hr>
<h2 id='plotHeatmapSRD'>plotHeatmapSRD</h2><span id='topic+plotHeatmapSRD'></span>

<h3>Description</h3>

<p>Heatmap is generated based on the pairwise distance - measured in SRD - of the columns. 
Each column is set as reference once, then SRD values are calculated for the other columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotHeatmapSRD(df, output_to_file = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotHeatmapSRD_+3A_df">df</code></td>
<td>
<p>A DataFrame.</p>
</td></tr>
<tr><td><code id="plotHeatmapSRD_+3A_output_to_file">output_to_file</code></td>
<td>
<p>Logical. If true, the distance matrix will be saved to the hard drive.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a heatmap and the corresponding distance matrix.
</p>


<h3>Author(s)</h3>

<p>Attila Gere <a href="mailto:gereattilaphd@gmail.com">gereattilaphd@gmail.com</a>, Linus Olsson <a href="mailto:linusmeol@gmail.com">linusmeol@gmail.com</a>, Jochen Staudacher <a href="mailto:jochen.staudacher@hs-kempten.de">jochen.staudacher@hs-kempten.de</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>srdInput &lt;- data.frame(
A=c(32, 52, 44, 44, 47),
B=c(73, 75, 65, 76, 70),
C=c(60, 59, 57, 55, 60),
D=c(35, 24, 44, 83, 47),
E=c(41, 52, 46, 50, 65))

plotHeatmapSRD(srdInput)
</code></pre>

<hr>
<h2 id='plotPermTest'>plotPermTest</h2><span id='topic+plotPermTest'></span>

<h3>Description</h3>

<p>Plots the permutation test for the given data frame by
using the simulation data created by the calculateSRDDistribution() function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPermTest(df, simulationData, densityToDistr = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPermTest_+3A_df">df</code></td>
<td>
<p>A DataFrame.</p>
</td></tr>
<tr><td><code id="plotPermTest_+3A_simulationdata">simulationData</code></td>
<td>
<p>The output of the calculateSRDDistribution() function.</p>
</td></tr>
<tr><td><code id="plotPermTest_+3A_densitytodistr">densityToDistr</code></td>
<td>
<p>Flag to display the cumulative distribution function instead of the probability density.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Linus Olsson <a href="mailto:linusmeol@gmail.com">linusmeol@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;- data.frame(
A=c(32, 52, 44, 44, 47),
B=c(73, 75, 65, 76, 70),
C=c(60, 59, 57, 55, 60),
D=c(35, 24, 44, 83, 47),
E=c(41, 52, 46, 50, 65))

simulationData &lt;- rSRD::calculateSRDDistribution(df)
plotPermTest(df, simulationData)

</code></pre>

<hr>
<h2 id='utilsCalculateDistance'>utilsCalculateDistance</h2><span id='topic+utilsCalculateDistance'></span>

<h3>Description</h3>

<p>Calculates the Manhattan-distance between two rankings and inserts it into the DataFrame after the first column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utilsCalculateDistance(df, nameCol, refCol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utilsCalculateDistance_+3A_df">df</code></td>
<td>
<p>A DataFrame.</p>
</td></tr>
<tr><td><code id="utilsCalculateDistance_+3A_namecol">nameCol</code></td>
<td>
<p>The current Column of the iteration.</p>
</td></tr>
<tr><td><code id="utilsCalculateDistance_+3A_refcol">refCol</code></td>
<td>
<p>The reference Column of the dataFrame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a new <code>df</code> that has a Distance Column based on the <code>nameCol</code>.
</p>


<h3>Author(s)</h3>

<p>Ali Tugay Sen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SRDInput &lt;- data.frame(
A=c(32, 52, 44, 44, 47),
B=c(73, 75, 65, 76, 70),
C=c(60, 59, 57, 55, 60),
D=c(35, 24, 44, 83, 47),
E=c(41, 52, 46, 50, 65))
nameCol &lt;- "A"
refCol &lt;- "B"
 for(i in names(SRDInput)){ SRDInput &lt;- rSRD::utilsCalculateRank(SRDInput,i)}
rSRD::utilsCalculateDistance(SRDInput,nameCol,refCol)
</code></pre>

<hr>
<h2 id='utilsCalculateRank'>utilsCalculateRank</h2><span id='topic+utilsCalculateRank'></span>

<h3>Description</h3>

<p>Calculates the ranking of a given column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utilsCalculateRank(df, nameCol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utilsCalculateRank_+3A_df">df</code></td>
<td>
<p>A DataFrame.</p>
</td></tr>
<tr><td><code id="utilsCalculateRank_+3A_namecol">nameCol</code></td>
<td>
<p>The name of the column to be ranked. Note that this 
parameter needs to be specified as there is no default value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a new <code>df</code> that has an additional column with
the rankings of the column specified by <code>nameCol</code>.
</p>


<h3>Author(s)</h3>

<p>Jochen Staudacher <a href="mailto:jochen.staudacher@hs-kempten.de">jochen.staudacher@hs-kempten.de</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SRDInput &lt;- data.frame(
A=c(32, 52, 44, 44, 47),
B=c(73, 75, 65, 76, 70),
C=c(60, 59, 57, 55, 60),
D=c(35, 24, 44, 83, 47),
E=c(41, 52, 46, 50, 65))
columnName &lt;- "A"
rSRD::utilsCalculateRank(SRDInput,columnName)
</code></pre>

<hr>
<h2 id='utilsColorPalette'>utilsColorPalette</h2><span id='topic+utilsColorPalette'></span>

<h3>Description</h3>

<p>Unique color palette for heatmaps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utilsColorPalette
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 250.
</p>


<h3>Author(s)</h3>

<p>Attila Gere <a href="mailto:gereattilaphd@uni-mate.hu">gereattilaphd@uni-mate.hu</a>, Balázs R. Sziklai <a href="mailto:sziklai.balazs@krtk.hu">sziklai.balazs@krtk.hu</a>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>barplot(rep(1,250), col = utilsColorPalette)
</code></pre>

<hr>
<h2 id='utilsCreateReference'>utilsCreateReference</h2><span id='topic+utilsCreateReference'></span>

<h3>Description</h3>

<p>Adds a new reference column based on the input DataFrame df and the given method. 
This function iterates over the rows and applies the given method to define the value of the reference. 
Available options are: max, min, median, mean and mixed. This column is appended to the DataFrame.
When &quot;mixed&quot; is specified the function will consider the refVector for creating the reference column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utilsCreateReference(df, method = "max", refVector = c())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utilsCreateReference_+3A_df">df</code></td>
<td>
<p>A DataFrame.</p>
</td></tr>
<tr><td><code id="utilsCreateReference_+3A_method">method</code></td>
<td>
<p>A string value specifying the reference creating method. Available options: max, min, median, mean and mixed.</p>
</td></tr>
<tr><td><code id="utilsCreateReference_+3A_refvector">refVector</code></td>
<td>
<p>A vector of strings that specifies a method for each row.
Vector size should be equal to the number of rows in the DataFrame df.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a new DataFrame appended with the reference column created by the method.
</p>


<h3>Author(s)</h3>

<p>Ali Tugay Sen, Linus Olsson <a href="mailto:linusmeol@gmail.com">linusmeol@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SRDInput &lt;- data.frame(
A=c(32, 52, 44, 44, 47),
B=c(73, 75, 65, 76, 70),
C=c(60, 59, 57, 55, 60),
D=c(35, 24, 44, 83, 47),
E=c(41, 52, 46, 50, 65))
proc_data &lt;- rSRD::utilsPreprocessDF(SRDInput)
ref &lt;- c("min","max","min","max","mean")
rSRD::utilsCreateReference(proc_data, method = "mixed", ref)
</code></pre>

<hr>
<h2 id='utilsDetailedSRD'>utilsDetailedSRD</h2><span id='topic+utilsDetailedSRD'></span>

<h3>Description</h3>

<p>Detailed calculation of the SRD values including the computation of the ranking transformation. 
Unless there is a column specified with referenceCol the last column will always taken as the reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utilsDetailedSRD(
  df,
  referenceCol,
  createRefCol = function() {
 }
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utilsDetailedSRD_+3A_df">df</code></td>
<td>
<p>A DataFrame.</p>
</td></tr>
<tr><td><code id="utilsDetailedSRD_+3A_referencecol">referenceCol</code></td>
<td>
<p>Optional. A string that contains a column of <code>df</code> which will be used as the reference column.</p>
</td></tr>
<tr><td><code id="utilsDetailedSRD_+3A_createrefcol">createRefCol</code></td>
<td>
<p>Optional. Can be max, min, median, mean. Creates a new Column based on the existing <code>df</code> and attaches it to  <code>df</code> as the reference Column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a new DataFrame that shows the detailed SRD computation (ranking transformation and distance calculation). A newly added row contains the SRD values (displayed without normalization).
</p>


<h3>Author(s)</h3>

<p>Ali Tugay Sen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SRDInput &lt;- data.frame(
A=c(32, 52, 44, 44, 47),
B=c(73, 75, 65, 76, 70),
C=c(60, 59, 57, 55, 60),
D=c(35, 24, 44, 83, 47),
E=c(41, 52, 46, 50, 65))
rSRD::utilsDetailedSRD(SRDInput)
</code></pre>

<hr>
<h2 id='utilsDetailedSRDNoChars'>utilsDetailedSRDNoChars</h2><span id='topic+utilsDetailedSRDNoChars'></span>

<h3>Description</h3>

<p>Detailed calculation of the SRD values including the computation of the ranking transformation. 
Unless there is a column specified with referenceCol the last column will always taken as the reference. 
In this variant unused variables will not be converted to chars.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utilsDetailedSRDNoChars(
  df,
  referenceCol,
  createRefCol = function() {
 }
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utilsDetailedSRDNoChars_+3A_df">df</code></td>
<td>
<p>A DataFrame.</p>
</td></tr>
<tr><td><code id="utilsDetailedSRDNoChars_+3A_referencecol">referenceCol</code></td>
<td>
<p>Optional. A string that contains a column of <code>df</code> which will be used as the reference column.</p>
</td></tr>
<tr><td><code id="utilsDetailedSRDNoChars_+3A_createrefcol">createRefCol</code></td>
<td>
<p>Optional. Can be max, min, median, mean. Creates a new Column based on the existing <code>df</code> and attaches it to  <code>df</code> as the reference Column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a new DataFrame that shows the detailed SRD computation (ranking transformation and distance calculation). A newly added row contains the SRD values (displayed without normalization).
</p>


<h3>Author(s)</h3>

<p>Ali Tugay Sen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SRDInput &lt;- data.frame(
A=c(32, 52, 44, 44, 47),
B=c(73, 75, 65, 76, 70),
C=c(60, 59, 57, 55, 60),
D=c(35, 24, 44, 83, 47),
E=c(41, 52, 46, 50, 65))
rSRD::utilsDetailedSRDNoChars(SRDInput)
</code></pre>

<hr>
<h2 id='utilsMaxSRD'>utilsMaxSRD</h2><span id='topic+utilsMaxSRD'></span>

<h3>Description</h3>

<p>Calculates the maximum distance between two rankings of size n.
This function is used to normalize SRD values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utilsMaxSRD(rowsCount)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utilsMaxSRD_+3A_rowscount">rowsCount</code></td>
<td>
<p>The number of rows in the SRD calculation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The maximum achievable SRD value.
</p>


<h3>Author(s)</h3>

<p>Dennis Horn
</p>


<h3>Examples</h3>

<pre><code class='language-R'>maxSRD &lt;- rSRD::utilsMaxSRD(5)
</code></pre>

<hr>
<h2 id='utilsPreprocessDF'>utilsPreprocessDF</h2><span id='topic+utilsPreprocessDF'></span>

<h3>Description</h3>

<p>This function preprocesses the DataFrame depending on the <code>method</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utilsPreprocessDF(df, method = "range_scale")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utilsPreprocessDF_+3A_df">df</code></td>
<td>
<p>A DataFrame.</p>
</td></tr>
<tr><td><code id="utilsPreprocessDF_+3A_method">method</code></td>
<td>
<p>A string that should contain &quot;scale_to_unit&quot;, &quot;standardize&quot;, &quot;range_scale&quot; or &quot;scale_to_max&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a new <code>df</code> that has a Distance Column based on the <code>nameCol</code>.
</p>


<h3>Author(s)</h3>

<p>Ali Tugay Sen, Dennis Horn <a href="mailto:dennishorn@hotmail.de">dennishorn@hotmail.de</a>, Linus Olsson <a href="mailto:linusmeol@gmail.com">linusmeol@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SRDInput &lt;- data.frame(
A=c(32, 52, 44, 44, 47),
B=c(73, 75, 65, 76, 70),
C=c(60, 59, 57, 55, 60),
D=c(35, 24, 44, 83, 47),
E=c(41, 52, 46, 50, 65))
method &lt;- "standardize"
utilsPreprocessDF(SRDInput,method)
</code></pre>

<hr>
<h2 id='utilsRankingMatrix'>utilsRankingMatrix</h2><span id='topic+utilsRankingMatrix'></span>

<h3>Description</h3>

<p>R interface to perform the rank transformation on the columns of the input data frame. 
Ties are resolved by fractional ranking.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utilsRankingMatrix(data_matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utilsRankingMatrix_+3A_data_matrix">data_matrix</code></td>
<td>
<p>A DataFrame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A DataFrame containing the ranking matrix.
</p>


<h3>Author(s)</h3>

<p>Balázs R. Sziklai <a href="mailto:sziklai.balazs@krtk.hu">sziklai.balazs@krtk.hu</a>, Linus Olsson <a href="mailto:linusmeol@gmail.com">linusmeol@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(
A=c(32, 52, 44, 44, 47),
B=c(73, 75, 65, 76, 70),
C=c(60, 59, 57, 55, 60),
D=c(35, 24, 44, 83, 47),
E=c(41, 52, 46, 50, 65))

utilsRankingMatrix(df)
</code></pre>

<hr>
<h2 id='utilsTieProbability'>utilsTieProbability</h2><span id='topic+utilsTieProbability'></span>

<h3>Description</h3>

<p>Calculates the tie probability for a given vector. The tie probability is defined as the number of consecutive tied component-pairs <em>in the sorted vector</em> divided by the size of the vector minus 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utilsTieProbability(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utilsTieProbability_+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the tie probability as a numeric value.
</p>


<h3>Author(s)</h3>

<p>Ali Tugay Sen, Linus Olsson <a href="mailto:linusmeol@gmail.com">linusmeol@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;-c(1,2,4,4,5,5,6)
rSRD::utilsTieProbability(x)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
