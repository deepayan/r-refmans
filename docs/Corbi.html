<!DOCTYPE html><html><head><title>Help for package Corbi</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Corbi}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#best_subnets'><p>The best subnetworks</p></a></li>
<li><a href='#column'><p>Extract a column from a matrix</p></a></li>
<li><a href='#Corbi-package'><p>Corbi - Collection of Rudimentary Bioinformatics Tools</p></a></li>
<li><a href='#extend_subnets'><p>Extend subnetworks from smaller subnetworks</p></a></li>
<li><a href='#get_adjusted_deg_diff'><p>Calculate adjusted degree differences for given network</p></a></li>
<li><a href='#get_diff_ratio_net'><p>Construct differential expression ratio network</p></a></li>
<li><a href='#get_ratio_distribution'><p>Calculate expression ratio distribution</p></a></li>
<li><a href='#get_ratio_distribution2'><p>Calculate expression ratio distribution</p></a></li>
<li><a href='#get_ratio_variance'><p>Calculate expression ratio variances</p></a></li>
<li><a href='#get_shortest_distances'><p>Calculate shortest distances of unweighted network</p></a></li>
<li><a href='#get_subnets'><p>All subnetworks of limited size</p></a></li>
<li><a href='#kappa_score'><p>Cohen's kappa score</p></a></li>
<li><a href='#make_DEG_data'><p>Simulate differentially expressed gene data (Gaussian)</p></a></li>
<li><a href='#make_DEG_data2'><p>Simulate differentially expressed gene data (Negative binomial)</p></a></li>
<li><a href='#make_DEG_pattern'><p>Simulate differentially expressed gene pattern</p></a></li>
<li><a href='#markrank'><p>MarkRank</p></a></li>
<li><a href='#net_align'><p>Network alignment method based on conditional random fields</p></a></li>
<li><a href='#net_query'><p>Network querying method based on conditional random fields</p></a></li>
<li><a href='#netDEG'><p>netDEG: Differentially expressed gene identification method</p></a></li>
<li><a href='#netDEG_pvalue'><p>Calculate netDEG p-values</p></a></li>
<li><a href='#nnzero'><p>The number of non-zero values of a submatrix</p></a></li>
<li><a href='#p_combine'><p>Calculate combined p-value</p></a></li>
<li><a href='#pmultihyper'><p>The Multivariate Hypergeometric Distribution</p></a></li>
<li><a href='#pmultinom'><p>The Multinomial Distribution</p></a></li>
<li><a href='#read_net'><p>Read network information from text file</p></a></li>
<li><a href='#rmultihyper'><p>The Multivariate Hypergeometric Distribution</p></a></li>
<li><a href='#simulate_dropout'><p>Simulate dropout expression data</p></a></li>
<li><a href='#simulate_dropout2'><p>Simulate dropout expression data</p></a></li>
<li><a href='#simulate_sample_groups'><p>Simulate sample groups from given samples with labels</p></a></li>
<li><a href='#submatrix'><p>Extract a submatrix from a matrix</p></a></li>
<li><a href='#URG_getFactor'><p>Calculate normalization factors for URG method</p></a></li>
<li><a href='#URG_normalize'><p>Normalize using given factors</p></a></li>
<li><a href='#write_net'><p>Write network information to text file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.6-2</td>
</tr>
<tr>
<td>Title:</td>
<td>Collection of Rudimentary Bioinformatics Tools</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a bundle of basic and fundamental bioinformatics tools,
    such as network querying and alignment, subnetwork extraction and search,
    network biomarker identification.</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix, MASS, stats, CRF, igraph</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, BiocParallel, matrixcalc, mpmi,
fitdistrplus</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/wulingyun/Corbi/issues">https://github.com/wulingyun/Corbi/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/wulingyun/Corbi">https://github.com/wulingyun/Corbi</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Author:</td>
<td>Ling-Yun Wu [aut, cre],
  Qiang Huang [aut],
  Duanchen Sun [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ling-Yun Wu &lt;wulingyun@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Repository/R-Forge/Project:</td>
<td>corbi</td>
</tr>
<tr>
<td>Repository/R-Forge/Revision:</td>
<td>46</td>
</tr>
<tr>
<td>Repository/R-Forge/DateTimeStamp:</td>
<td>2022-05-03 08:39:32</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-30 16:30:07 UTC</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-03 08:52:24 UTC; rforge</td>
</tr>
</table>
<hr>
<h2 id='best_subnets'>The best subnetworks</h2><span id='topic+best_subnets'></span>

<h3>Description</h3>

<p>Search best subnetworks that maximize given objective functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>best_subnets(
  func,
  net.matrix,
  max.size = 10,
  exhaust.size = 5,
  max.top = 10000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="best_subnets_+3A_func">func</code></td>
<td>
<p>The objective function to maximize</p>
</td></tr>
<tr><td><code id="best_subnets_+3A_net.matrix">net.matrix</code></td>
<td>
<p>The adjacent matrix of network</p>
</td></tr>
<tr><td><code id="best_subnets_+3A_max.size">max.size</code></td>
<td>
<p>The maximal size of subnetworks</p>
</td></tr>
<tr><td><code id="best_subnets_+3A_exhaust.size">exhaust.size</code></td>
<td>
<p>The maximal size of subnetworks that use exhaustive searching strategy</p>
</td></tr>
<tr><td><code id="best_subnets_+3A_max.top">max.top</code></td>
<td>
<p>The maiximal number of top candidates kept for evaluation of next size,
used in heuristic searching strategy</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Enumerate and search the best subnetworks that maximize given objective function. If the size of 
subnetworks &lt;= <code>exhaust.size</code>, exact exhaustive searching is applied,
otherwise, heuristic searching algorithm is used.
</p>


<h3>Value</h3>

<p>A list with the following two components:
</p>
<table>
<tr><td><code>subnets</code></td>
<td>
<p>The list of top subnetworks in different sizes</p>
</td></tr>
<tr><td><code>obj.values</code></td>
<td>
<p>The list of objective values of corresponding subnetworks</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>get_subnets, extend_subnets
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(Corbi)
net &lt;- matrix(FALSE, nrow=10, ncol=10)
net[sample.int(100, 20)] &lt;- TRUE
net &lt;- net | t(net)
func &lt;- function(subnet) max(subnet) - min(subnet)
result &lt;- best_subnets(func, net, 5)

</code></pre>

<hr>
<h2 id='column'>Extract a column from a matrix</h2><span id='topic+column'></span>

<h3>Description</h3>

<p>Extract a specified column from a sparse matrix rapidly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>column(m, i)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="column_+3A_m">m</code></td>
<td>
<p>The matrix</p>
</td></tr>
<tr><td><code id="column_+3A_i">i</code></td>
<td>
<p>The column index</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements faster column extraction algorithm for the 
<code><a href="Matrix.html#topic+CsparseMatrix-class">CsparseMatrix</a></code> class in the package <span class="pkg">Matrix</span>.
</p>


<h3>Value</h3>

<p>This function will return the specified column as a vector of corresponding type.
</p>

<hr>
<h2 id='Corbi-package'>Corbi - Collection of Rudimentary Bioinformatics Tools</h2><span id='topic+Corbi-package'></span><span id='topic+Corbi'></span>

<h3>Description</h3>

<p>This pakcage provides a bundle of basic and fundamental bioinformatics tools.
</p>


<h3>Details</h3>

<p>These bioinformatics tools are developed by <a href="http://wulab.ac.cn">WuLab</a> at Academy of Mathematics
and Systems Science, Chinese Academy of Sciences.
</p>
<p>Network querying and alignment:
</p>

<ul>
<li> <p><code><a href="#topic+net_query">net_query</a></code> Network querying method based on conditional random fields
</p>
</li>
<li> <p><code><a href="#topic+net_query_batch">net_query_batch</a></code> Batch processing version of <code><a href="#topic+net_query">net_query</a></code>
</p>
</li>
<li> <p><code><a href="#topic+net_align">net_align</a></code> Network alignment method based on conditional random fields
</p>
</li></ul>

<p>Subnetwork extraction and search:
</p>

<ul>
<li> <p><code><a href="#topic+get_subnets">get_subnets</a></code> Enumerate all subnetworks of limited size
</p>
</li>
<li> <p><code><a href="#topic+extend_subnets">extend_subnets</a></code> Extend subnetworks from smaller subnetworks
</p>
</li>
<li> <p><code><a href="#topic+best_subnets">best_subnets</a></code> Search best subnetworks that maximize given objective function
</p>
</li></ul>

<p>Biomarker identification:
</p>

<ul>
<li> <p><code><a href="#topic+markrank">markrank</a></code> Biomarker identification and prioritization by integrating gene expression with biomolecular network
</p>
</li></ul>

<p>Differential expression analysis:
</p>

<ul>
<li> <p><code><a href="#topic+netDEG">netDEG</a></code> Sample specific differential expression analysis
</p>
</li></ul>

<p>Data normalization:
</p>

<ul>
<li> <p><code><a href="#topic+URG_getFactor">URG_getFactor</a></code> Gene expression data normalization by the uniform ratio graph method
</p>
</li></ul>



<h3>References</h3>

<p>Qiang Huang, Ling-Yun Wu, and Xiang-Sun Zhang. An Efficient
Network Querying Method Based on Conditional Random Fields. Bioinformatics,
27(22):3173-3178, 2011.
</p>
<p>Qiang Huang, Ling-Yun Wu, and Xiang-Sun Zhang. Corbi: A new
R package for biological network alignment and querying. BMC Systems Biology,
7(Suppl 2):S6, 2013.
</p>
<p>Duanchen Sun, Xianwen Ren, Eszter Ari, Tamas Korcsmaros, 
Peter Csermely, and Ling-Yun Wu. Discovering cooperative biomarkers for 
heterogeneous complex disease diagnoses. Briefings in Bioinformatics, 
20(1), 89–101, 2019.
</p>
<p>Xinhan Ye, Ling-Yun Wu. URG: a new normalization method for 
gene expression data based on graph model. Manuscript.
</p>

<hr>
<h2 id='extend_subnets'>Extend subnetworks from smaller subnetworks</h2><span id='topic+extend_subnets'></span>

<h3>Description</h3>

<p>Extend subnetworks by pairwise overlapping two sets of smaller subnetworks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extend_subnets(subnet1, subnet2, size = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extend_subnets_+3A_subnet1">subnet1</code></td>
<td>
<p>The matrix representing the first set of subnetworks</p>
</td></tr>
<tr><td><code id="extend_subnets_+3A_subnet2">subnet2</code></td>
<td>
<p>The matrix representing the second set of subnetworks</p>
</td></tr>
<tr><td><code id="extend_subnets_+3A_size">size</code></td>
<td>
<p>The desired size of extended subnetworks</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Enumerate all possible subnetworks of desired size by pairwise overlapping two sets of 
subnetworks of size <code>s1</code> and <code>s2</code>. The desired size should be between 
<code>max(s1,s2)+1</code> and <code>s1+s2-1</code>. Invalid desired size will be replaced by the 
minimum allowed value <code>max(s1,s2)+1</code>.
</p>


<h3>Value</h3>

<p>A matrix represents the extended subnetworks, in which each row represents a subnetwork.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(Corbi)
net &lt;- matrix(FALSE, nrow=10, ncol=10)
net[sample.int(100, 20)] &lt;- TRUE
net &lt;- net | t(net)
subnets &lt;- get_subnets(net, 3)
subnets[[4]] &lt;- extend_subnets(subnets[[3]], subnets[[2]], 4)

</code></pre>

<hr>
<h2 id='get_adjusted_deg_diff'>Calculate adjusted degree differences for given network</h2><span id='topic+get_adjusted_deg_diff'></span>

<h3>Description</h3>

<p>Calculate the adjusted degree differences for all genes in the given network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_adjusted_deg_diff(net, log.expr.val, scale.degree = FALSE, p = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_adjusted_deg_diff_+3A_net">net</code></td>
<td>
<p>The binary adjacent matrix of differential expression ratio network.</p>
</td></tr>
<tr><td><code id="get_adjusted_deg_diff_+3A_log.expr.val">log.expr.val</code></td>
<td>
<p>Numeric vector containing the logarithmic scale gene expression values.</p>
</td></tr>
<tr><td><code id="get_adjusted_deg_diff_+3A_scale.degree">scale.degree</code></td>
<td>
<p>Logical variable indicating whether the degree values are scaled according to the dropout rate.</p>
</td></tr>
<tr><td><code id="get_adjusted_deg_diff_+3A_p">p</code></td>
<td>
<p>The parameter for calculating the adjusted degree differences.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function will return a list with the following components:
</p>
<table>
<tr><td><code>diff</code></td>
<td>
<p>A numeric vector containing the adjusted degree differences of all genes.</p>
</td></tr>
<tr><td><code>degree</code></td>
<td>
<p>A list containing the raw degree differences and sums of all genes.</p>
</td></tr>
</table>

<hr>
<h2 id='get_diff_ratio_net'>Construct differential expression ratio network</h2><span id='topic+get_diff_ratio_net'></span>

<h3>Description</h3>

<p>Construct the differential expression ratio network for a single sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_diff_ratio_net(
  ref.ratio.dist,
  expr.val,
  log.expr = FALSE,
  scale.degree = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_diff_ratio_net_+3A_ref.ratio.dist">ref.ratio.dist</code></td>
<td>
<p>The expression ratio distribution profile returned by <code>get_ratio_distribution</code> or <code>get_ratio_distribution2</code>.</p>
</td></tr>
<tr><td><code id="get_diff_ratio_net_+3A_expr.val">expr.val</code></td>
<td>
<p>Numeric vector of gene expression values in the sample.</p>
</td></tr>
<tr><td><code id="get_diff_ratio_net_+3A_log.expr">log.expr</code></td>
<td>
<p>Logical variable indicating whether the input expression vector is in logarithmic scale.</p>
</td></tr>
<tr><td><code id="get_diff_ratio_net_+3A_scale.degree">scale.degree</code></td>
<td>
<p>Logical variable indicating whether the degree values are scaled according to the dropout rate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function will return a list with the following components:
</p>
<table>
<tr><td><code>net</code></td>
<td>
<p>The binary adjacent matrix of differential expression ratio network.</p>
</td></tr>
<tr><td><code>diff</code></td>
<td>
<p>A numeric vector containing the adjusted degree differences of all genes.</p>
</td></tr>
<tr><td><code>degree</code></td>
<td>
<p>A list containing the raw degree differences and sums of all genes.</p>
</td></tr>
</table>

<hr>
<h2 id='get_ratio_distribution'>Calculate expression ratio distribution</h2><span id='topic+get_ratio_distribution'></span>

<h3>Description</h3>

<p>Calculate the lower and upper quantiles of expression ratios for each pair of genes,
and estimate the parameters of negative binomial distribution from reference expression data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ratio_distribution(
  ref.expr.matrix,
  p.edge = 0.1,
  log.expr = FALSE,
  scale.degree = FALSE,
  use.parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_ratio_distribution_+3A_ref.expr.matrix">ref.expr.matrix</code></td>
<td>
<p>The reference expression matrix. Each row represents a gene and each column represents a sample.</p>
</td></tr>
<tr><td><code id="get_ratio_distribution_+3A_p.edge">p.edge</code></td>
<td>
<p>The expected probability of edges in the expression ratio network for a normal sample.</p>
</td></tr>
<tr><td><code id="get_ratio_distribution_+3A_log.expr">log.expr</code></td>
<td>
<p>Logical variable indicating whether the input expression matrix is in logarithmic scale.</p>
</td></tr>
<tr><td><code id="get_ratio_distribution_+3A_scale.degree">scale.degree</code></td>
<td>
<p>Logical variable indicating whether the degree values are scaled according to the dropout rate.</p>
</td></tr>
<tr><td><code id="get_ratio_distribution_+3A_use.parallel">use.parallel</code></td>
<td>
<p>Logical variable indicating to use the BiocParallel package to accelerate computation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function will return a list with the following components:
</p>
<table>
<tr><td><code>LB</code></td>
<td>
<p>A numeric matrix with element [i,j] represents the lower quantile of expressioin ratios for gene pairs (i, j).</p>
</td></tr>
<tr><td><code>NB</code></td>
<td>
<p>A numeric vector with two elements: <code>size</code> and <code>mu</code>, 
which are the estimated parameters of negative binomial distribution.</p>
</td></tr>
<tr><td><code>p.edge</code></td>
<td>
<p>The used input parameter <code>p.edge</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='get_ratio_distribution2'>Calculate expression ratio distribution</h2><span id='topic+get_ratio_distribution2'></span>

<h3>Description</h3>

<p>Calculate the lower and upper quantiles of expression ratios after trimming the extreme values, 
and estimate the parameters of negative binomial distribution from reference expression data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ratio_distribution2(
  ref.expr.matrix,
  p.edge = 0.1,
  p.trim = 0.3,
  log.expr = FALSE,
  scale.degree = FALSE,
  use.parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_ratio_distribution2_+3A_ref.expr.matrix">ref.expr.matrix</code></td>
<td>
<p>The reference expression matrix. Each row represents a gene and each column represents a sample.</p>
</td></tr>
<tr><td><code id="get_ratio_distribution2_+3A_p.edge">p.edge</code></td>
<td>
<p>The expected probability of edges in the expression ratio network for a normal sample.</p>
</td></tr>
<tr><td><code id="get_ratio_distribution2_+3A_p.trim">p.trim</code></td>
<td>
<p>The percentage of lower or upper extreme values to be trimmed from the expression ratios for each pair of genes.</p>
</td></tr>
<tr><td><code id="get_ratio_distribution2_+3A_log.expr">log.expr</code></td>
<td>
<p>Logical variable indicating whether the input expression matrix is in logarithmic scale.</p>
</td></tr>
<tr><td><code id="get_ratio_distribution2_+3A_scale.degree">scale.degree</code></td>
<td>
<p>Logical variable indicating whether the degree values are scaled according to the dropout rate.</p>
</td></tr>
<tr><td><code id="get_ratio_distribution2_+3A_use.parallel">use.parallel</code></td>
<td>
<p>Logical variable indicating to use the BiocParallel package to accelerate computation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function will return a list with the following components:
</p>
<table>
<tr><td><code>LB</code></td>
<td>
<p>A numeric matrix with element [i,j] represents the lower quantile of trimmed expressioin ratios for gene pairs (i, j).</p>
</td></tr>
<tr><td><code>NB</code></td>
<td>
<p>A numeric vector with two elements: <code>size</code> and <code>mu</code>, 
which are the estimated parameters of negative binomial distribution.</p>
</td></tr>
<tr><td><code>p.edge</code></td>
<td>
<p>The used input parameter <code>p.edge</code>.</p>
</td></tr>
<tr><td><code>p.trim</code></td>
<td>
<p>The used input parameter <code>p.trim</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='get_ratio_variance'>Calculate expression ratio variances</h2><span id='topic+get_ratio_variance'></span>

<h3>Description</h3>

<p>Calculate the variances of expression ratios for each pair of genes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ratio_variance(expr.matrix, log.expr = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_ratio_variance_+3A_expr.matrix">expr.matrix</code></td>
<td>
<p>The expression matrix. Each row represents a gene and each column represents a sample.</p>
</td></tr>
<tr><td><code id="get_ratio_variance_+3A_log.expr">log.expr</code></td>
<td>
<p>Logical variable indicating whether the input expression matrix is in logarithmic scale.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function will return a numeric matrix with element [i,j] represents the variance of 
expressioin ratios for gene pairs (i, j).
</p>

<hr>
<h2 id='get_shortest_distances'>Calculate shortest distances of unweighted network</h2><span id='topic+get_shortest_distances'></span>

<h3>Description</h3>

<p>Calculate all pairs of shortest distances of unweighted network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_shortest_distances(
  net.matrix,
  source.nodes = rep_len(TRUE, dim(net.matrix)[1])
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_shortest_distances_+3A_net.matrix">net.matrix</code></td>
<td>
<p>Logical adjacency matrix of given unweighted network</p>
</td></tr>
<tr><td><code id="get_shortest_distances_+3A_source.nodes">source.nodes</code></td>
<td>
<p>Logical vector to indicate the source nodes that 
need to calculate the shortest distances</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates all pairs of shortest distances of unweighted network
by using breadth-first-search (BFS) algorithm.
</p>


<h3>Value</h3>

<p>This function will return the shortest distance matrix, where the element
<code>[i, j]</code> is the shortest distance between node i and j. Value -1 means unreachable.
If <code>source.nodes[i]</code> equals FALSE, the shortest distance from i to other nodes
will not be calculated and the row i will be all -1.
</p>

<hr>
<h2 id='get_subnets'>All subnetworks of limited size</h2><span id='topic+get_subnets'></span>

<h3>Description</h3>

<p>Enumerate all subnetworks of size &lt;= <code>max.size</code> from given network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_subnets(net.matrix, max.size = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_subnets_+3A_net.matrix">net.matrix</code></td>
<td>
<p>The adjacent matrix of network</p>
</td></tr>
<tr><td><code id="get_subnets_+3A_max.size">max.size</code></td>
<td>
<p>The maximal size of subnetworks</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of generated subnetworks, with element $i$ corresponds the subnetworks
of size $i$. Each element is a matrix, in which each row represents a subnetwork.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(Corbi)
net &lt;- matrix(FALSE, nrow=10, ncol=10)
net[sample.int(100, 20)] &lt;- TRUE
net &lt;- net | t(net)
subnets &lt;- get_subnets(net, 3)

</code></pre>

<hr>
<h2 id='kappa_score'>Cohen's kappa score</h2><span id='topic+kappa_score'></span>

<h3>Description</h3>

<p>Calculate Cohen's kappa score for two vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kappa_score(x1, x2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kappa_score_+3A_x1">x1</code></td>
<td>
<p>The first logical vector</p>
</td></tr>
<tr><td><code id="kappa_score_+3A_x2">x2</code></td>
<td>
<p>The second logical vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculate Cohen's kappa score for two logical vectors.
</p>


<h3>Value</h3>

<p>The Cohen's kappa score
</p>

<hr>
<h2 id='make_DEG_data'>Simulate differentially expressed gene data (Gaussian)</h2><span id='topic+make_DEG_data'></span>

<h3>Description</h3>

<p>Generate differentially expressed gene (DEG) data from Gaussian distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_DEG_data(
  n.genes,
  n.samples.A,
  n.samples.B,
  exp.mean = 8,
  exp.sd = 2,
  alpha = 0.2,
  size.factor.sd = 0.1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_DEG_data_+3A_n.genes">n.genes</code></td>
<td>
<p>The total number of genes in the simulated data.</p>
</td></tr>
<tr><td><code id="make_DEG_data_+3A_n.samples.a">n.samples.A</code></td>
<td>
<p>The number of samples in the group A.</p>
</td></tr>
<tr><td><code id="make_DEG_data_+3A_n.samples.b">n.samples.B</code></td>
<td>
<p>The number of samples in the group B.</p>
</td></tr>
<tr><td><code id="make_DEG_data_+3A_exp.mean">exp.mean</code></td>
<td>
<p>The mean of log-normal distribution that determines gene-specific expression mean.</p>
</td></tr>
<tr><td><code id="make_DEG_data_+3A_exp.sd">exp.sd</code></td>
<td>
<p>The standard deviation of log-normal distribution that determines gene-specific expression means.</p>
</td></tr>
<tr><td><code id="make_DEG_data_+3A_alpha">alpha</code></td>
<td>
<p>The dispersion ratio of gene-specific expression standard deviation to mean.</p>
</td></tr>
<tr><td><code id="make_DEG_data_+3A_size.factor.sd">size.factor.sd</code></td>
<td>
<p>The standard deviation of size factors for samples.</p>
</td></tr>
<tr><td><code id="make_DEG_data_+3A_...">...</code></td>
<td>
<p>The parameters passed to function <code><a href="#topic+make_DEG_pattern">make_DEG_pattern</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The expression values of each gene are assumed following a Gaussian distribution with 
gene-specific mean, which follows a log-normal distribution. The size factor for each
sample follows a Gaussian distribution with zero mean and specific standard deviation.
The heterogeneity of gene expression data is simulated by using the function <code><a href="#topic+make_DEG_pattern">make_DEG_pattern</a></code>.
</p>


<h3>Value</h3>

<p>This function will return a list with the following components:
</p>
<table>
<tr><td><code>DEG</code></td>
<td>
<p>The matrix of simulated DEG pattern, which is generated by <code><a href="#topic+make_DEG_pattern">make_DEG_pattern</a></code>.</p>
</td></tr>
<tr><td><code>countsA</code></td>
<td>
<p>The expression matrix of group A. Each row represents a gene and each column represents a sample.</p>
</td></tr>
<tr><td><code>countsB</code></td>
<td>
<p>The expression matrix of group B. Each row represents a gene and each column represents a sample.</p>
</td></tr>
</table>

<hr>
<h2 id='make_DEG_data2'>Simulate differentially expressed gene data (Negative binomial)</h2><span id='topic+make_DEG_data2'></span>

<h3>Description</h3>

<p>Generate differentially expressed gene (DEG) data from negative binomial distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_DEG_data2(
  n.genes,
  n.samples.A,
  n.samples.B,
  exp.mean = 8,
  exp.sd = 2,
  dispersion = NULL,
  size.factor.sd = 0.1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_DEG_data2_+3A_n.genes">n.genes</code></td>
<td>
<p>The total number of genes in the simulated data.</p>
</td></tr>
<tr><td><code id="make_DEG_data2_+3A_n.samples.a">n.samples.A</code></td>
<td>
<p>The number of samples in the group A.</p>
</td></tr>
<tr><td><code id="make_DEG_data2_+3A_n.samples.b">n.samples.B</code></td>
<td>
<p>The number of samples in the group B.</p>
</td></tr>
<tr><td><code id="make_DEG_data2_+3A_exp.mean">exp.mean</code></td>
<td>
<p>The mean of log-normal distribution that determines gene-specific expression mean.</p>
</td></tr>
<tr><td><code id="make_DEG_data2_+3A_exp.sd">exp.sd</code></td>
<td>
<p>The standard deviation of log-normal distribution that determines gene-specific expression mean.</p>
</td></tr>
<tr><td><code id="make_DEG_data2_+3A_dispersion">dispersion</code></td>
<td>
<p>The dispersion parameter for negative binomial distribution. The default values are determined by the expression mean.</p>
</td></tr>
<tr><td><code id="make_DEG_data2_+3A_size.factor.sd">size.factor.sd</code></td>
<td>
<p>The standard deviation of size factors for samples.</p>
</td></tr>
<tr><td><code id="make_DEG_data2_+3A_...">...</code></td>
<td>
<p>The parameters passed to function <code><a href="#topic+make_DEG_pattern">make_DEG_pattern</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The expression values of each gene are assumed following a negative binomial distribution with 
gene-specific mean, which follows a log-normal distribution. The size factor for each
sample follows a Gaussian distribution with zero mean and specific standard deviation.
The heterogeneity of gene expression data is simulated by using the function <code><a href="#topic+make_DEG_pattern">make_DEG_pattern</a></code>.
</p>


<h3>Value</h3>

<p>This function will return a list with the following components:
</p>
<table>
<tr><td><code>DEG</code></td>
<td>
<p>The matrix of simulated DEG pattern, which is generated by <code><a href="#topic+make_DEG_pattern">make_DEG_pattern</a></code>.</p>
</td></tr>
<tr><td><code>countsA</code></td>
<td>
<p>The expression matrix of group A. Each row represents a gene and each column represents a sample.</p>
</td></tr>
<tr><td><code>countsB</code></td>
<td>
<p>The expression matrix of group B. Each row represents a gene and each column represents a sample.</p>
</td></tr>
</table>

<hr>
<h2 id='make_DEG_pattern'>Simulate differentially expressed gene pattern</h2><span id='topic+make_DEG_pattern'></span>

<h3>Description</h3>

<p>Generate complicated differentially expressed gene (DEG) pattern to simulate 
varied degree of heterogeneity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_DEG_pattern(
  n.genes,
  n.samples,
  fold.change = 2,
  gene.rate = 0.3,
  sample.rate = 1,
  active.rate = 1,
  up.rate = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_DEG_pattern_+3A_n.genes">n.genes</code></td>
<td>
<p>The total number of genes in the simulated data.</p>
</td></tr>
<tr><td><code id="make_DEG_pattern_+3A_n.samples">n.samples</code></td>
<td>
<p>The total number of samples in the simulated data.</p>
</td></tr>
<tr><td><code id="make_DEG_pattern_+3A_fold.change">fold.change</code></td>
<td>
<p>The fold change level of DEGs.</p>
</td></tr>
<tr><td><code id="make_DEG_pattern_+3A_gene.rate">gene.rate</code></td>
<td>
<p>The proportion of DEGs to all genes.</p>
</td></tr>
<tr><td><code id="make_DEG_pattern_+3A_sample.rate">sample.rate</code></td>
<td>
<p>The proportion of abnormal samples to all samples.</p>
</td></tr>
<tr><td><code id="make_DEG_pattern_+3A_active.rate">active.rate</code></td>
<td>
<p>The probability that a DEG is truely differentially 
expressed in an abnormal sample.</p>
</td></tr>
<tr><td><code id="make_DEG_pattern_+3A_up.rate">up.rate</code></td>
<td>
<p>The proportion of up-regulated DEGs to all DEGs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The heterogeneity of gene expression pattern is mainly controlled by
two parameters: <code>sample.rate</code> and <code>active.rate</code>. If both
parameters are equal to 1, the gene expression pattern will be homogeneous,
otherwise heterogeneous.
</p>


<h3>Value</h3>

<p>This function will return a list with the following components:
</p>
<table>
<tr><td><code>FC</code></td>
<td>
<p>The matrix of simulated fold changes. Each row represents a gene and each column represents a sample.</p>
</td></tr>
<tr><td><code>gene</code></td>
<td>
<p>The vector of gene status: 1 for up-regulated, -1 for down-regulated, and 0 for normal genes.</p>
</td></tr>
<tr><td><code>sample</code></td>
<td>
<p>The vector of sample status: 1 for abnormal, and 0 for normal samples.</p>
</td></tr>
</table>

<hr>
<h2 id='markrank'>MarkRank</h2><span id='topic+markrank'></span>

<h3>Description</h3>

<p>MarkRank is a novel proposed network-based model, which can identify the cooperative 
biomarkers for heterogeneous complex disease diagnoses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>markrank(
  dataset,
  label,
  adj_matrix,
  alpha = 0.8,
  lambda = 0.2,
  eps = 1e-10,
  E_value = NULL,
  trace = TRUE,
  d = Inf,
  Given_NET2 = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="markrank_+3A_dataset">dataset</code></td>
<td>
<p>The microarray expression matrix of related disease. Each row represents
a sample and each column represents a gene.</p>
</td></tr>
<tr><td><code id="markrank_+3A_label">label</code></td>
<td>
<p>The 0-1 binary phenotype vector of dataset samples. The size of label must
accord with the sample number in dataset.</p>
</td></tr>
<tr><td><code id="markrank_+3A_adj_matrix">adj_matrix</code></td>
<td>
<p>The 0-1 binary adjacent matrix of a connected biological network. 
Here the node set should be the same order as the gene set in expression matrix.</p>
</td></tr>
<tr><td><code id="markrank_+3A_alpha">alpha</code></td>
<td>
<p>The convex combination coefficient of network effect and prior information vector <code>E_value</code>.
The range of alpha is in <code>[0,1]</code>. A larger alpha will lay more emphasis on the 
network information. The default value is 0.8.</p>
</td></tr>
<tr><td><code id="markrank_+3A_lambda">lambda</code></td>
<td>
<p>In the random walk-based iteration, matrix A1 reflects the stucture information of the 
biological network, whereas matrix A2 reflects the cooperative effect of gene combinations.
Parameter lambda is the convex combination coefficient of two network effects. The range of lambda is
in <code>[0,1]</code>. A larger lambda will lay more emphasis on the A1. The default value is 0.2.</p>
</td></tr>
<tr><td><code id="markrank_+3A_eps">eps</code></td>
<td>
<p>The stop criteria for the iterative solution method. The default value is 1e-10.</p>
</td></tr>
<tr><td><code id="markrank_+3A_e_value">E_value</code></td>
<td>
<p>A vector containing the prior information about the importance of nodes. Default is the 
absolute Pearson correlation coefficient (PCC).</p>
</td></tr>
<tr><td><code id="markrank_+3A_trace">trace</code></td>
<td>
<p>Locaical variable indicated whether tracing information on the progress of the gene cooperation
network construction is produced.</p>
</td></tr>
<tr><td><code id="markrank_+3A_d">d</code></td>
<td>
<p>Threshold for simplifying the G_2 computation. Only the gene pairs whose shortest distances in PPI network are 
less than d participate in the G_2 computation. The default value is Inf.</p>
</td></tr>
<tr><td><code id="markrank_+3A_given_net2">Given_NET2</code></td>
<td>
<p>Whether a computed cooperation network is given for tuning parameter. See Details
for a more specific description.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>MarkRank is a network-based biomarker identification method to prioritize disease genes 
by integrating multi-source information including the biological network, e.g 
protein-protein interaction (PPI) network, the prior information about related diseases,
and the discriminative power of cooperative gene combinations. MarkRank shows that
explicit modeling of gene cooperative effects can greatly improve biomarker identification
for complex disease, especially for diseases with high heterogeneity.
</p>
<p>MarkRank algorithm contains mainly two steps: 1) The construction of gene cooperation network G_2 
and 2) a random walk based iteration procedure. The following descriptions will help the users to
using <code>markrank</code> more convenient:
</p>
<p>1) As for the construction of the gene cooperation network, we  suggest the user to set
<code>trace=TRUE</code> to output the G_2 computation process. The G_2 construction step finished
if the output number is identical to the gene number of the input expression matrix. The parameter <code>d</code>
introduced the structure information of used biological network to facilitate the construction
of G_2, only the gene pairs whose shortest distances in network are less than <code>d</code> participate
the G_2 computation. We suggest <code>d=Inf</code>, the default value, to fully use the information of expression
matrix. If the user given a preset <code>d</code>, the distance matrix of input network <code>dis</code> 
will be returned.
</p>
<p>2) MarkRank uses a random-walk based iteration procedure to score each gene. The detailed formula is: 
</p>
<p><code>score</code> = <code>alpha</code>*[<code>lambda</code>*A1 + (1-<code>lambda</code>)*A2]*<code>score</code> + (1-<code>alpha</code>)*<code>E_value</code>.
</p>
<p>The users could set an appropriate parameter settings in their pracitical application.
Our suggested value is <code>alpha</code>=0.8 and <code>lambda</code>=0.2. The model input parameter combinations and iteration steps will
be returned in output components <code>initial_pars</code> and <code>steps</code>, respectively. Because the iteration step is separate with
the cooperation network construction, the user can use the parameter <code>Given_NET2</code> to tune
the model parameters. In detail, the user could set 
</p>
<p><code>Given_NET2 = result$NET2</code> 
</p>
<p>in <code>markrank</code> input to avoid the repeated computation of G_2, where the object <code>result</code>
is the returned variable of <code>markrank</code> function.
</p>
<p>3) The final MarkRank score for each gene is in output <code>score</code>. The users could sort
this result and use the top ranked genes for further analysis.
</p>


<h3>Value</h3>

<p>This function will return a list with the following components:
</p>
<table>
<tr><td><code>score</code></td>
<td>
<p>The vector of final MarkRank scores for each gene.</p>
</td></tr>
<tr><td><code>steps</code></td>
<td>
<p>The final iteration steps in random walk based scoring procedure.</p>
</td></tr>
<tr><td><code>NET2</code></td>
<td>
<p>The weighted adjacent matrix of gene cooperation network.</p>
</td></tr>
<tr><td><code>initial_pars</code></td>
<td>
<p>The initial/input parameter values used in MarkRank.</p>
</td></tr>
<tr><td><code>dis</code></td>
<td>
<p>The pairwise distance matrix of input network. This variable will be <code>Null</code> if input d=Inf.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Duanchen Sun, Xianwen Ren, Eszter Ari, Tamas Korcsmaros, Peter Csermely,
Ling-Yun Wu. Discovering cooperative biomarkers for heterogeneous complex disease diagnoses.
Briefings in Bioinformatics, 20(1), 89–101, 2019.
</p>

<hr>
<h2 id='net_align'>Network alignment method based on conditional random fields</h2><span id='topic+net_align'></span>

<h3>Description</h3>

<p>Find the maximal matching subnetworks from a target network for a query
network based on the conditional random fields (CRF) model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>net_align(
  query.net,
  target.net,
  node.sim,
  query.type = 4,
  delta.d = 1e-10,
  delta.c = 0.5,
  delta.e = 1,
  delta.s = 1,
  output = "result.txt"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="net_align_+3A_query.net">query.net</code></td>
<td>
<p>The input file name of the query network.</p>
</td></tr>
<tr><td><code id="net_align_+3A_target.net">target.net</code></td>
<td>
<p>The input file name of the target network.</p>
</td></tr>
<tr><td><code id="net_align_+3A_node.sim">node.sim</code></td>
<td>
<p>The input file name of the node similarity scores between
the query network and the target network.</p>
</td></tr>
<tr><td><code id="net_align_+3A_query.type">query.type</code></td>
<td>
<p>The querying network type: 1 - general, 2 - chain, 3 -
tree, 4 - heuristic.</p>
</td></tr>
<tr><td><code id="net_align_+3A_delta.d">delta.d</code></td>
<td>
<p>The parameter delta.d is a parameter for deletions.</p>
</td></tr>
<tr><td><code id="net_align_+3A_delta.c">delta.c</code></td>
<td>
<p>The parameter delta.c is a parameter for consecutive
deletions.</p>
</td></tr>
<tr><td><code id="net_align_+3A_delta.e">delta.e</code></td>
<td>
<p>The parameter delta.e is a parameter for single deletion.</p>
</td></tr>
<tr><td><code id="net_align_+3A_delta.s">delta.s</code></td>
<td>
<p>The parameter delta.s is a parameter for insertions.</p>
</td></tr>
<tr><td><code id="net_align_+3A_output">output</code></td>
<td>
<p>The suffix of output file name. The output contains two files
in the working directory. One is the matching nodes and edges between query
network and target network, the other is the unique matching node pairs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an approach for network alignment problem based on conditional
random field (CRF) model which uses the node similarity and structure
information equally. This method is based on our network querying method
<code><a href="#topic+net_query">net_query</a></code>. This method uses an iterative strategy to get the
one-to-one map between the query network and target netowrk.
</p>
<p>More details can be seen in <code><a href="#topic+net_query">net_query</a></code>.
</p>


<h3>References</h3>

<p>Qiang Huang, Ling-Yun Wu, and Xiang-Sun Zhang. CNetA: Network
alignment by combining biological and topological features. In Proceedings
of 2012 IEEE International Conference on Systems Biology (ISB), 220-225,
IEEE, 2012.
</p>
<p>Qiang Huang, Ling-Yun Wu, and Xiang-Sun Zhang. Corbi: A new
R package for biological network alignment and querying. BMC Systems Biology,
7(Suppl 2):S6, 2013.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
library(Corbi)

## An example: "querynet.txt", "targetnet.txt", "nodesim.txt" are
## three input files in the working directory
net_align("querynet.txt", "targetnet.txt", "nodesim.txt")

## End(Not run)

</code></pre>

<hr>
<h2 id='net_query'>Network querying method based on conditional random fields</h2><span id='topic+net_query'></span><span id='topic+net_query_batch'></span>

<h3>Description</h3>

<p>Find the best matching subnetworks from a large target network for small
query networks based on the conditional random fields (CRF) model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>net_query(
  query.net,
  target.net,
  node.sim,
  query.type = 4,
  delta.d = 1e-10,
  delta.c = 0.5,
  delta.e = 1,
  delta.s = 1,
  output = "result.txt"
)

net_query_batch(
  query.nets,
  target.net,
  node.sim,
  query.type = 4,
  delta.d = 1e-10,
  delta.c = 0.5,
  delta.e = 1,
  delta.s = 1,
  output = "result.txt"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="net_query_+3A_query.net">query.net</code></td>
<td>
<p>The input file name of the query network.</p>
</td></tr>
<tr><td><code id="net_query_+3A_target.net">target.net</code></td>
<td>
<p>The input file name of the target network.</p>
</td></tr>
<tr><td><code id="net_query_+3A_node.sim">node.sim</code></td>
<td>
<p>The input file name of the node similarity scores between
the query network and the target network.</p>
</td></tr>
<tr><td><code id="net_query_+3A_query.type">query.type</code></td>
<td>
<p>The querying network type: 1 - general, 2 - chain, 3 -
tree, 4 - heuristic.</p>
</td></tr>
<tr><td><code id="net_query_+3A_delta.d">delta.d</code></td>
<td>
<p>The parameter delta.d is a parameter for deletions.</p>
</td></tr>
<tr><td><code id="net_query_+3A_delta.c">delta.c</code></td>
<td>
<p>The parameter delta.c is a parameter for consecutive
deletions.</p>
</td></tr>
<tr><td><code id="net_query_+3A_delta.e">delta.e</code></td>
<td>
<p>The parameter delta.e is a parameter for single deletion.</p>
</td></tr>
<tr><td><code id="net_query_+3A_delta.s">delta.s</code></td>
<td>
<p>The parameter delta.s is a parameter for insertions.</p>
</td></tr>
<tr><td><code id="net_query_+3A_output">output</code></td>
<td>
<p>The suffix of output file name.</p>
</td></tr>
<tr><td><code id="net_query_+3A_query.nets">query.nets</code></td>
<td>
<p>The vector of input file names of the query networks.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an approach for network querying problem based on conditional random
field (CRF) model which can handle both undirected and directed networks,
acyclic and cyclic networks, and any number of insertions/deletions.
</p>
<p>When querying several networks in the same target network,
<code><a href="#topic+net_query_batch">net_query_batch</a></code> will save much time.
</p>

<ul>
<li><p> query.net: The query network file is written as follows:<br />
v1 v2 v3 v4 v5<br /> v3 v4 <br /> ...  <br /> where v1, v2, v3, v4, v5 ... are the
nodes' names and each line indicates there are edges between the first node
and other nodes in the line. For example, the first line denotes 4 edges:
(v1, v2), (v1, v3), (v1, v4), and (v1, v5).
</p>
</li>
<li><p> target.net: The format of this file is the same as the query network
file.
</p>
</li>
<li><p> node.sim: This similarity file's format is as follows:<br /> v1 V1 s1 <br />
v1 V2 s2 <br /> ...  <br /> v1 is the node from the query network, V1 is the node
from the target network, s1 is the similarity score between the node v1 and
V1, and so on.
</p>
</li>
<li><p> query.type: If query.type = 1, the loopy belief propagation (LBP)
algorithm will be applied, which is an approximate algorithm for a general
graph with loops. If the query is a chain or tree, there are exact
algorithms. Set query.type = 2 when the query is a chain, and query.type = 3
when the query is a tree. The heuristic algorithm will be used when
query.type = 4, which will try the exact algorithm (junction tree algorithm)
first and resort to LBP algorithm when the exact algorithm failed. The
default value is 4.
</p>
</li>
<li><p> delta.d: The smaller delta.d is, the heavier penalty for deletions.
</p>
</li>
<li><p> delta.c: The smaller delta.c is, the heavier penalty for consecutive
deletions.
</p>
</li>
<li><p> delta.e: The smaller delta.e is, the heavier penalty for single
deletion.
</p>
</li>
<li><p> delta.s: The larger delta.s indicates heavier penalty for insertions.
</p>
</li></ul>



<h3>References</h3>

<p>Qiang Huang, Ling-Yun Wu, and Xiang-Sun Zhang. An Efficient
Network Querying Method Based on Conditional Random Fields. Bioinformatics,
27(22):3173-3178, 2011.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
library(Corbi)

## An example: "querynet.txt", "targetnet.txt", "nodesim.txt" are
## three input files in the working directory
net_query("querynet.txt", "targetnet.txt", "nodesim.txt", query.type=3)

## End(Not run)


## Not run: 
## Batch example
net_query_batch(c("querynet.txt", "querynet2.txt"),
  "targetnet.txt", "nodesim.txt", query.type=3)

## End(Not run)

</code></pre>

<hr>
<h2 id='netDEG'>netDEG: Differentially expressed gene identification method</h2><span id='topic+netDEG'></span>

<h3>Description</h3>

<p>Perform netDEG for two group samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netDEG(
  ref.expr.matrix,
  expr.matrix,
  p.edge = 0.1,
  summarize = c("gene", "sample"),
  summarize.method = c("sumlog", "sumlog"),
  summarize.shrink = c(Inf, Inf),
  log.expr = FALSE,
  zero.as.dropout = TRUE,
  scale.degree = TRUE,
  use.parallel = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="netDEG_+3A_ref.expr.matrix">ref.expr.matrix</code></td>
<td>
<p>The reference expression matrix. Each row represents a gene and each column represents a sample.</p>
</td></tr>
<tr><td><code id="netDEG_+3A_expr.matrix">expr.matrix</code></td>
<td>
<p>The test expression matrix. Each row represents a gene and each column represents a sample.</p>
</td></tr>
<tr><td><code id="netDEG_+3A_p.edge">p.edge</code></td>
<td>
<p>The expected probability of edges in the expression ratio network for a normal sample.</p>
</td></tr>
<tr><td><code id="netDEG_+3A_summarize">summarize</code></td>
<td>
<p>Character vector indicating how to summarize the results. Available methods are <code>c("gene", "sample")</code>.</p>
</td></tr>
<tr><td><code id="netDEG_+3A_summarize.method">summarize.method</code></td>
<td>
<p>Character vector indicating the methods used to summarize the results. See <code>p_combine</code>.</p>
</td></tr>
<tr><td><code id="netDEG_+3A_summarize.shrink">summarize.shrink</code></td>
<td>
<p>Numeric vector indicating the shrink parameter to summarize the results. See <code>p_combine</code>.</p>
</td></tr>
<tr><td><code id="netDEG_+3A_log.expr">log.expr</code></td>
<td>
<p>Logical variable indicating whether the input expression matrix is in logarithmic scale.</p>
</td></tr>
<tr><td><code id="netDEG_+3A_zero.as.dropout">zero.as.dropout</code></td>
<td>
<p>Logical variable indicating whether the zero expressions are regarded as dropouts.</p>
</td></tr>
<tr><td><code id="netDEG_+3A_scale.degree">scale.degree</code></td>
<td>
<p>Logical variable indicating whether the degree values are scaled according to the dropout rate.</p>
</td></tr>
<tr><td><code id="netDEG_+3A_use.parallel">use.parallel</code></td>
<td>
<p>Logical variable indicating to use the BiocParallel package to accelerate computation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function will return a list with the following components:
</p>
<table>
<tr><td><code>up</code></td>
<td>
<p>A numeric matrix with same dimension as <code>expr.matrix</code>, containing the p-values of up-regulation test.</p>
</td></tr>
<tr><td><code>down</code></td>
<td>
<p>A numeric matrix with same dimension as <code>expr.matrix</code>, containing the p-values of down-regulation test.</p>
</td></tr>
<tr><td><code>twoside</code></td>
<td>
<p>A numeric matrix with same dimension as <code>expr.matrix</code>, containing the p-values of twoside test.</p>
</td></tr>
<tr><td><code>rev</code></td>
<td>
<p>A list containing the reverse comparison results, containing three components: <code>up</code>, <code>down</code>, 
and <code>twoside</code>. Available if the gene method is specified in <code>summarize</code> argument.</p>
</td></tr>
<tr><td><code>gene</code></td>
<td>
<p>A list containing the gene-wise summaried results, containing three components: <code>up</code>, <code>down</code>, 
and <code>twoside</code>. Available if the gene method is specified in <code>summarize</code> argument.</p>
</td></tr>
<tr><td><code>sample</code></td>
<td>
<p>A list containing the sample-wise summaried results, containing three components: <code>up</code>, <code>down</code>,
and <code>twoside</code>. Available if the sample method is specified in <code>summarize</code> argument.</p>
</td></tr>
</table>

<hr>
<h2 id='netDEG_pvalue'>Calculate netDEG p-values</h2><span id='topic+netDEG_pvalue'></span>

<h3>Description</h3>

<p>Perform the single or two side tests and calculate the p-values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netDEG_pvalue(ref.ratio.dist, expr.val, log.expr = FALSE, scale.degree = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="netDEG_pvalue_+3A_ref.ratio.dist">ref.ratio.dist</code></td>
<td>
<p>The expression ratio distribution profile returned by <code>get_ratio_distribution</code> or <code>get_ratio_distribution2</code>.</p>
</td></tr>
<tr><td><code id="netDEG_pvalue_+3A_expr.val">expr.val</code></td>
<td>
<p>Numeric vector of gene expression values in the sample.</p>
</td></tr>
<tr><td><code id="netDEG_pvalue_+3A_log.expr">log.expr</code></td>
<td>
<p>Logical variable indicating whether the input expression vector is in logarithmic scale.</p>
</td></tr>
<tr><td><code id="netDEG_pvalue_+3A_scale.degree">scale.degree</code></td>
<td>
<p>Logical variable indicating whether the degree values are scaled according to the dropout rate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function will return a list with the following components:
</p>
<table>
<tr><td><code>up</code></td>
<td>
<p>A numeric vector containing the p-values of up-regulation test.</p>
</td></tr>
<tr><td><code>down</code></td>
<td>
<p>A numeric vector containing the p-values of down-regulation test.</p>
</td></tr>
<tr><td><code>twoside</code></td>
<td>
<p>A numeric vector containing the p-values of twoside test.</p>
</td></tr>
</table>

<hr>
<h2 id='nnzero'>The number of non-zero values of a submatrix</h2><span id='topic+nnzero'></span>

<h3>Description</h3>

<p>Retuen the number of non-zero values of the specified submatrix of a given sparse matrix rapidly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nnzero(m, rows = 1:dim(m)[1], cols = 1:dim(m)[2])
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nnzero_+3A_m">m</code></td>
<td>
<p>The matrix</p>
</td></tr>
<tr><td><code id="nnzero_+3A_rows">rows</code></td>
<td>
<p>The integer vector of row index(es) or logical vector indicated the selected rows</p>
</td></tr>
<tr><td><code id="nnzero_+3A_cols">cols</code></td>
<td>
<p>The integer vector of column index(es) or logical vector indicated the selected cols</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements faster calculation algorithm for the 
<code><a href="Matrix.html#topic+CsparseMatrix-class">CsparseMatrix</a></code> and <code><a href="Matrix.html#topic+RsparseMatrix-class">RsparseMatrix</a></code>
class in the package <span class="pkg">Matrix</span>.
</p>


<h3>Value</h3>

<p>This function will return the number of non-zero values in the specified submatrix.
</p>

<hr>
<h2 id='p_combine'>Calculate combined p-value</h2><span id='topic+p_combine'></span>

<h3>Description</h3>

<p>Combine the statistical significance results from several independent tests by using one of several methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_combine(p, method = "sumlog", shrink = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p_combine_+3A_p">p</code></td>
<td>
<p>the numeric vector containing the p-values need to combine.</p>
</td></tr>
<tr><td><code id="p_combine_+3A_method">method</code></td>
<td>
<p>the method use to combine the p-values, can be &quot;sumlog&quot; (Fisher's method), &quot;sumz&quot; (Stouffer’s method).</p>
</td></tr>
<tr><td><code id="p_combine_+3A_shrink">shrink</code></td>
<td>
<p>the number of p-values used in calculation, which are uniform selected from original p-value vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function will return a list with the following components:
</p>
<table>
<tr><td><code>p</code></td>
<td>
<p>The combined p-value.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>The value of statistic.</p>
</td></tr>
<tr><td><code>chisq</code></td>
<td>
<p>Use &quot;sumlog&quot; method: The value of chi-squared statistic.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Use &quot;sumlog&quot; method: The degrees of freedom of chi-squared distribution.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>Use &quot;sumz&quot; method: The value of sum z statistic.</p>
</td></tr>
</table>

<hr>
<h2 id='pmultihyper'>The Multivariate Hypergeometric Distribution</h2><span id='topic+pmultihyper'></span>

<h3>Description</h3>

<p>The distribution function for the weighted sums of multivariate hypergeometric distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmultihyper(x, k, m, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pmultihyper_+3A_x">x</code></td>
<td>
<p>The quantile of weighted sum.</p>
</td></tr>
<tr><td><code id="pmultihyper_+3A_k">k</code></td>
<td>
<p>The total number of balls drawn from the urn.</p>
</td></tr>
<tr><td><code id="pmultihyper_+3A_m">m</code></td>
<td>
<p>Integer non-negative vector of length N, containing the number of balls of each color in the urn.
N is the number of colors.</p>
</td></tr>
<tr><td><code id="pmultihyper_+3A_w">w</code></td>
<td>
<p>Numeric non-negative vector of length N, specifying the weight of balls of each color.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function gives the distribution function for the weighted sums of multivariate hypergeometric
distribution by recursively calling the hypergeometric distribution density function
<code><a href="stats.html#topic+dhyper">dhyper</a></code>.
</p>


<h3>Value</h3>

<p>This function will return the probablity of <code class="reqn">P(X \le x)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dhyper">dhyper</a></code>
</p>

<hr>
<h2 id='pmultinom'>The Multinomial Distribution</h2><span id='topic+pmultinom'></span>

<h3>Description</h3>

<p>The distribution function for the weighted sums of multinomial distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmultinom(x, k, m, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pmultinom_+3A_x">x</code></td>
<td>
<p>The quantile of weighted sum.</p>
</td></tr>
<tr><td><code id="pmultinom_+3A_k">k</code></td>
<td>
<p>The total number of balls drawn from the urn.</p>
</td></tr>
<tr><td><code id="pmultinom_+3A_m">m</code></td>
<td>
<p>Numeric non-negative vector of length N, specifying the probability
for drawing the ball of each color; is internally normalized to sum 1. Infinite and missing values
are not allowed. N is the number of colors.</p>
</td></tr>
<tr><td><code id="pmultinom_+3A_w">w</code></td>
<td>
<p>Numeric non-negative vector of length N, specifying the weight of balls of each color.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function gives the distribution function for the weighted sums of multinomial
distribution by recursively calling the binomial distribution density function
<code><a href="stats.html#topic+dbinom">dbinom</a></code>.
</p>


<h3>Value</h3>

<p>This function will return the probablity of <code class="reqn">P(X \le x)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dbinom">dbinom</a></code>, <code><a href="stats.html#topic+dmultinom">dmultinom</a></code>, <code><a href="stats.html#topic+rmultinom">rmultinom</a></code>
</p>

<hr>
<h2 id='read_net'>Read network information from text file</h2><span id='topic+read_net'></span>

<h3>Description</h3>

<p>Read the network information from a text file with specific format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_net(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_net_+3A_file">file</code></td>
<td>
<p>The name of text file</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function reads the network information from a text file with specific format:
each line contains two strings separated by spaces, which correspond to the 
names of two end points of one edge in the network.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>size</code></td>
<td>
<p>The number of network nodes</p>
</td></tr>
<tr><td><code>node</code></td>
<td>
<p>The vector of network node names</p>
</td></tr>
<tr><td><code>matrix</code></td>
<td>
<p>The logical adjacency matrix</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+write_net">write_net</a></code>
</p>

<hr>
<h2 id='rmultihyper'>The Multivariate Hypergeometric Distribution</h2><span id='topic+rmultihyper'></span>

<h3>Description</h3>

<p>Generate random variables for the multivariate hypergeometric distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmultihyper(n, k, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmultihyper_+3A_n">n</code></td>
<td>
<p>The number of observations.</p>
</td></tr>
<tr><td><code id="rmultihyper_+3A_k">k</code></td>
<td>
<p>The total number of balls drawn from the urn.</p>
</td></tr>
<tr><td><code id="rmultihyper_+3A_m">m</code></td>
<td>
<p>The integer vector containing the number of balls of each color in the urn.
Length of vector is the number of colors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates random variables for the multivariate hypergeometric
distribution by iteratively calling hypergeometric random variable generator
<code><a href="stats.html#topic+rhyper">rhyper</a></code>.
</p>


<h3>Value</h3>

<p>This function will return a matrix of <code>length(m)</code> rows and <code>n</code> columns,
and each column contains the number of balls of each color drawn from the urn.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+rhyper">rhyper</a></code>
</p>

<hr>
<h2 id='simulate_dropout'>Simulate dropout expression data</h2><span id='topic+simulate_dropout'></span>

<h3>Description</h3>

<p>Generate the expression data with desired dropout rate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_dropout(counts, dropout.rate = 0, dropout.rate.sd = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_dropout_+3A_counts">counts</code></td>
<td>
<p>expression matrix where each row is a gene and each column is a sample.</p>
</td></tr>
<tr><td><code id="simulate_dropout_+3A_dropout.rate">dropout.rate</code></td>
<td>
<p>the desired average dropout rate of all samples.</p>
</td></tr>
<tr><td><code id="simulate_dropout_+3A_dropout.rate.sd">dropout.rate.sd</code></td>
<td>
<p>the desired standard deviation of dropout rate among samples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The dropout event is modelled by a logistic distribution such that the low expression genes have 
higher probability of dropout. The expression value of genes in a sample are randomly set to zero
with probabilities associated with their true expression values until the desired dropout rate
for that sample is meet.
</p>


<h3>Value</h3>

<p>This function will return a list with the following components:
</p>
<table>
<tr><td><code>counts</code></td>
<td>
<p>The modified expression matrix with the same dimension as input <code>counts</code>.</p>
</td></tr>
<tr><td><code>original.counts</code></td>
<td>
<p>The original input expression matrix.</p>
</td></tr>
<tr><td><code>dropout</code></td>
<td>
<p>The binary matrix indicating where the dropout events happen.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Peter V. Kharchenko, Lev Silberstein, and David T. Scadden.
Bayesian approach to single-cell differential expression analysis.
Nature Methods, 11(7):740–742, 2014.
</p>

<hr>
<h2 id='simulate_dropout2'>Simulate dropout expression data</h2><span id='topic+simulate_dropout2'></span>

<h3>Description</h3>

<p>Generate the expression data with desired dropout rate range
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_dropout2(counts, min.rate = 0, max.rate = 0.8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_dropout2_+3A_counts">counts</code></td>
<td>
<p>expression matrix where each row is a gene and each column is a sample.</p>
</td></tr>
<tr><td><code id="simulate_dropout2_+3A_min.rate">min.rate</code></td>
<td>
<p>the minimum dropout rate of all samples.</p>
</td></tr>
<tr><td><code id="simulate_dropout2_+3A_max.rate">max.rate</code></td>
<td>
<p>the maximum dropout rate of all samples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The dropout event is modelled by a logistic distribution such that the low expression genes have 
higher probability of dropout. The expression value of genes in a sample are randomly set to zero
with probabilities associated with their true expression values until the desired dropout rate
for that sample is meet.
</p>


<h3>Value</h3>

<p>This function will return a list with the following components:
</p>
<table>
<tr><td><code>counts</code></td>
<td>
<p>The modified expression matrix with the same dimension as input <code>counts</code>.</p>
</td></tr>
<tr><td><code>original.counts</code></td>
<td>
<p>The original input expression matrix.</p>
</td></tr>
<tr><td><code>dropout</code></td>
<td>
<p>The binary matrix indicating where the dropout events happen.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Peter V. Kharchenko, Lev Silberstein, and David T. Scadden.
Bayesian approach to single-cell differential expression analysis.
Nature Methods, 11(7):740–742, 2014.
</p>

<hr>
<h2 id='simulate_sample_groups'>Simulate sample groups from given samples with labels</h2><span id='topic+simulate_sample_groups'></span>

<h3>Description</h3>

<p>Generate sample groups with desired labels and sizes from given sample labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_sample_groups(labels, groups, sizes, replace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_sample_groups_+3A_labels">labels</code></td>
<td>
<p>a vector containing the label of each sample in the pool.</p>
</td></tr>
<tr><td><code id="simulate_sample_groups_+3A_groups">groups</code></td>
<td>
<p>a vector containing the desired label of samples in each group.
The label must be available in the sample pool provided by <code>labels</code>.</p>
</td></tr>
<tr><td><code id="simulate_sample_groups_+3A_sizes">sizes</code></td>
<td>
<p>integer vector indicating the desired number of samples in each group.
The length must be either one or the same as <code>groups</code>.</p>
</td></tr>
<tr><td><code id="simulate_sample_groups_+3A_replace">replace</code></td>
<td>
<p>logical variable indicating whether sampling is with replacement.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function will return a list with the same length as <code>groups</code>.
Each component is a vector containing the indexes of samples that are sampled for
the corresponding group.
</p>

<hr>
<h2 id='submatrix'>Extract a submatrix from a matrix</h2><span id='topic+submatrix'></span>

<h3>Description</h3>

<p>Extract a specified submatrix from a sparse matrix rapidly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>submatrix(m, rows, cols)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="submatrix_+3A_m">m</code></td>
<td>
<p>The matrix</p>
</td></tr>
<tr><td><code id="submatrix_+3A_rows">rows</code></td>
<td>
<p>The integer vectors of row index(es)</p>
</td></tr>
<tr><td><code id="submatrix_+3A_cols">cols</code></td>
<td>
<p>The integer vectors of column index(es)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements faster submatrix extraction algorithm for the 
<code><a href="Matrix.html#topic+CsparseMatrix-class">CsparseMatrix</a></code> class in the package <span class="pkg">Matrix</span>.
</p>


<h3>Value</h3>

<p>This function will return the specified submatrix as a matrix of corresponding type.
</p>

<hr>
<h2 id='URG_getFactor'>Calculate normalization factors for URG method</h2><span id='topic+URG_getFactor'></span>

<h3>Description</h3>

<p>Calculate the normalization factor for each sample by using URG (uniform ratio graph) method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>URG_getFactor(expr.matrix, p.edge = 0.25, p.gene = 0.4, log.expr = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="URG_getFactor_+3A_expr.matrix">expr.matrix</code></td>
<td>
<p>The expression matrix. Each row represents a gene and each column represents a sample.</p>
</td></tr>
<tr><td><code id="URG_getFactor_+3A_p.edge">p.edge</code></td>
<td>
<p>The percentage of gene pairs that are selected into the uniform ratio graph.</p>
</td></tr>
<tr><td><code id="URG_getFactor_+3A_p.gene">p.gene</code></td>
<td>
<p>The maximal percentage of genes that are selected as the stable genes.</p>
</td></tr>
<tr><td><code id="URG_getFactor_+3A_log.expr">log.expr</code></td>
<td>
<p>Logical variable indicating whether the input expression matrix is in logarithmic scale.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function will return a numeric vector with each element [i] represents the normalization
factor of sample (i).
</p>


<h3>References</h3>

<p>Xinhan Ye, Ling-Yun Wu. URG: a new normalization method for 
gene expression data based on graph model. Manuscript.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+URG_normalize">URG_normalize</a></code>
</p>

<hr>
<h2 id='URG_normalize'>Normalize using given factors</h2><span id='topic+URG_normalize'></span>

<h3>Description</h3>

<p>Normalize the expression matrix by using the given factor for each sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>URG_normalize(expr.matrix, factor, log.expr = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="URG_normalize_+3A_expr.matrix">expr.matrix</code></td>
<td>
<p>The expression matrix. Each row represents a gene and each column represents a sample.</p>
</td></tr>
<tr><td><code id="URG_normalize_+3A_factor">factor</code></td>
<td>
<p>The numeric vector of normalization factors.</p>
</td></tr>
<tr><td><code id="URG_normalize_+3A_log.expr">log.expr</code></td>
<td>
<p>Logical variable indicating whether the input expression matrix is in logarithmic scale.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function will return a numeric matrix with the same dimension of <code>expr.matrix</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+URG_getFactor">URG_getFactor</a></code>
</p>

<hr>
<h2 id='write_net'>Write network information to text file</h2><span id='topic+write_net'></span>

<h3>Description</h3>

<p>Write the network information to a text file with specific format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_net(net, file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_net_+3A_net">net</code></td>
<td>
<p>A list as returned by <code><a href="#topic+read_net">read_net</a></code></p>
</td></tr>
<tr><td><code id="write_net_+3A_file">file</code></td>
<td>
<p>The name of text file</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function writes the network information to a text file with specific format:
each line contains two strings separated by spaces, which correspond to the
names of two end points of one edge in the network.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_net">read_net</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
