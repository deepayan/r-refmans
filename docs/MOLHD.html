<!DOCTYPE html><html><head><title>Help for package MOLHD</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MOLHD}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#MOLHD-package'><p>Multiple objective Latin hypercube design</p></a></li>
<li><a href='#cpf2'><p>Combine Pareto front designs of 2 criteria</p></a></li>
<li><a href='#cpf3'><p>Combine Pareto front designs of 3 criteria</p></a></li>
<li><a href='#LHD'><p>Generate a random Latin Hypercube design</p></a></li>
<li><a href='#md'><p>Minimum distance between any two points in the design</p></a></li>
<li><a href='#miM'><p>The miniMax criterion baesd on an approximate fill distance measure</p></a></li>
<li><a href='#miMLHD'><p>Generate the optimal Latin Hypercube Design based on the miniMax criterion.</p></a></li>
<li><a href='#Mm'><p>Computer the approximate Maximin Criterion for a design.</p></a></li>
<li><a href='#MmLHD'><p>Generate the optimal Maximin Latin Hypercube Design.</p></a></li>
<li><a href='#mp'><p>Computer the MaxPro Criterion for a design.</p></a></li>
<li><a href='#mpLHD'><p>Generate the optimal MaxPro Latin Hypercube Design.</p></a></li>
<li><a href='#pfMm'><p>Generate the Pareto front for the optimal Latin Hypercube Designs based on both the Maximin and miniMax criteria.</p></a></li>
<li><a href='#pfMp'><p>Generate the Pareto front for optimal Latin Hypercube Designs based on both the Maximin and the MaxPro criteria.</p></a></li>
<li><a href='#pfMpm'><p>Generate the Pareto front for the optimal Latin Hypercube Designs based on the Maximin, MaxPro and miniMax criteria.</p></a></li>
<li><a href='#pfpm'><p>Generate the Pareto front for the optimal Latin Hypercube Designs based on both the MaxPro and miniMax criteria.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multiple Objective Latin Hypercube Design</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2</td>
</tr>
<tr>
<td>Author:</td>
<td>Ruizhe Hou , Lu Lu</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ruizhe Hou &lt;houruizhe1210@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Generate the optimal maximin distance, minimax distance (only for low dimensions), and maximum projection designs within the class of Latin hypercube designs efficiently for computer experiments. Generate Pareto front optimal designs for each two of the three criteria and all the three criteria within the class of Latin hypercube designs efficiently. Provide criterion computing functions. References of this package can be found in Morris, M. D. and Mitchell, T. J. (1995) &lt;<a href="https://doi.org/10.1016%2F0378-3758%2894%2900035-T">doi:10.1016/0378-3758(94)00035-T</a>&gt;, Lu Lu and Christine M. Anderson-CookTimothy J. Robinson (2011) &lt;<a href="https://doi.org/10.1198%2FTech.2011.10087">doi:10.1198/Tech.2011.10087</a>&gt;, Joseph, V. R., Gul, E., and Ba, S. (2015) &lt;<a href="https://doi.org/10.1093%2Fbiomet%2Fasv002">doi:10.1093/biomet/asv002</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>fields, arrangements</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-2">LGPL-2</a> | <a href="https://www.r-project.org/Licenses/LGPL-2.1">LGPL-2.1</a> | <a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a> [expanded from: LGPL]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-5-6</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-05-06 16:24:37 UTC; 18722</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-05-06 16:49:25 UTC</td>
</tr>
</table>
<hr>
<h2 id='MOLHD-package'>Multiple objective Latin hypercube design</h2><span id='topic+MOLHD-package'></span><span id='topic+MOLHD'></span>

<h3>Description</h3>

<p>The MOLHD package provides useful and efficient functions for generating the optimal Maximin distance, Maximum Projection and miniMax distance (only for low dimensions) designs within the class of Latin hypercube designs for computer experiments. Ant it provides functions generating Pareto front optimal designs for each two of the three criteria and all the three criteria within the class of Latin hypercube designs. It also provides functions to compute the criteria for a given design.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> MOLHD</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2018-5-6</td>
</tr>
<tr>
 <td style="text-align: left;">
Lisense: </td><td style="text-align: left;"> LGPL</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>This package contains functions for generating the optimal maximin distance designs, maximum projection designs and minimax distance designs for low dimensions within the class of Latin hypercube designs (LHDs). This packages also contains functions for generating designs on the Pareto front of each two of the three criteria as maximin distance criterion, minimax distance criterion, and maximum projection criterion. This package also contains functions to compute each criterion for a random Latin hypercube design.
</p>
<p>Since minimax distance design is computational expensive, it is only approximately extimated when the design is at low dimension.
</p>


<h3>Author(s)</h3>

<p>Ruizhe Hou, Lu Lu
</p>
<p>Maintainer: Ruizhe Hou&lt;houruizhe1210@gmail.com&gt;
</p>


<h3>References</h3>

<p>Morris, M. D. and Mitchell, T. J. (1995), &quot;Exploratory Designs for Computation Experiments,&quot; <em>Journal of Statistical Planning and Inference</em>. &lt;doi:10.1016/0378-3758(94)00035-T&gt;
</p>
<p>Lu Lu and Christine M. Anderson-CookTimothy J. Robinson (2011), &quot;Optimization of Designed Experiments Based on Multiple Criteria Utilizing a Pareto Frontier,&quot; <em>Technometrics</em>.
&lt;doi:10.1198/Tech.2011.10087&gt;
</p>
<p>Joseph, V. R., Gul, E., and Ba, S. (2015), &quot;Maximum Projection Designs for Computer experiments,&quot; <em>Biometrika</em>. &lt;doi:10.1093/biomet/asv002&gt;
</p>

<hr>
<h2 id='cpf2'>Combine Pareto front designs of 2 criteria</h2><span id='topic+cpf2'></span>

<h3>Description</h3>

<p>Combine Pareto front designs of 2 criteria
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpf2(newdes, newpfval, curdes, curpfval)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpf2_+3A_newdes">newdes</code></td>
<td>
<p>a matrix which is a column bind of new designs</p>
</td></tr>
<tr><td><code id="cpf2_+3A_newpfval">newpfval</code></td>
<td>
<p>a matrix each row is 2 criteria correponding to each design</p>
</td></tr>
<tr><td><code id="cpf2_+3A_curdes">curdes</code></td>
<td>
<p>a matrix which is a column bind of current designs on Pareto front</p>
</td></tr>
<tr><td><code id="cpf2_+3A_curpfval">curpfval</code></td>
<td>
<p>a matrix each row is 2 criteria correponding to each Pareto front design</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to combine 2 criteria Pareto front designs
</p>


<h3>Value</h3>

<table>
<tr><td><code>pfdes</code></td>
<td>
<p>The column bind of Pareto front designs</p>
</td></tr>
<tr><td><code>pfvals</code></td>
<td>
<p>The Pareto front values corresponding to the Pareto front designs</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#Combine Pareto fronts each with 5 random starts for Mm and mp criteria
## Not run: 
pf1=pfMp(20,2,crlim = cbind(c(4.5,6.5),c(26,36)),nstarts = 5)
pf2=pfMp(20,2,crlim = cbind(c(4.5,6.5),c(26,36)),nstarts = 5)
pfnew=cpf2(pf1$pfdes,pf1$pfvals,pf2$pfdes,pf2$pfvals)
pfnew$pfdes
pfnew$pfvals

## End(Not run)
</code></pre>

<hr>
<h2 id='cpf3'>Combine Pareto front designs of 3 criteria</h2><span id='topic+cpf3'></span>

<h3>Description</h3>

<p>Combine Pareto front designs of 3 criteria
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpf3(newdes, newpfval, curdes, curpfval)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpf3_+3A_newdes">newdes</code></td>
<td>
<p>a matrix which is a column bind of new designs</p>
</td></tr>
<tr><td><code id="cpf3_+3A_newpfval">newpfval</code></td>
<td>
<p>a matrix each row is 3 criteria correponding to each design</p>
</td></tr>
<tr><td><code id="cpf3_+3A_curdes">curdes</code></td>
<td>
<p>a matrix which is a column bind of current designs on Pareto front</p>
</td></tr>
<tr><td><code id="cpf3_+3A_curpfval">curpfval</code></td>
<td>
<p>a matrix each row is 3 criteria correponding to each Pareto front design</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to combine 3 criteria Pareto front designs
</p>


<h3>Value</h3>

<table>
<tr><td><code>pfdes</code></td>
<td>
<p>The column bind of Pareto front designs</p>
</td></tr>
<tr><td><code>pfvals</code></td>
<td>
<p>The Pareto front values corresponding to the Pareto front designs</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#Combine Pareto fronts each with 1 random start for Mm, mp and mM criteria
## Not run: 
pf1=pfMpm(20,2,crlim = cbind(c(4.5,6.5),c(26,36),c(0.12,0.62)),num = 15,nstarts = 1)
pf2=pfMpm(20,2,crlim = cbind(c(4.5,6.5),c(26,36),c(0.12,0.62)),num = 15,nstarts = 1)
pfnew=cpf3(pf1$pfdes,pf1$pfvals,pf2$pfdes,pf2$pfvals)
pfnew$pfdes
pfnew$pfvals

## End(Not run)
</code></pre>

<hr>
<h2 id='LHD'>Generate a random Latin Hypercube design</h2><span id='topic+LHD'></span>

<h3>Description</h3>

<p>Generate a random Latin Hypercube design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LHD(n, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LHD_+3A_n">n</code></td>
<td>
<p>number of runs desired</p>
</td></tr>
<tr><td><code id="LHD_+3A_p">p</code></td>
<td>
<p>number of design factors</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>design</code></td>
<td>
<p>a Latin Hypercube Design that is not scaled (i.e. the grid point locations are integers)</p>
</td></tr>
<tr><td><code>standDesign</code></td>
<td>
<p>a standard Latin Hypercube Design that is scaled to (0,1); design locaitons are placed at the centers of selected grids.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#Generate a random Latin hypercube design with 20 runs and 2 variables
D&lt;-LHD(n = 20,p = 2)
D$design
D$standDesign
</code></pre>

<hr>
<h2 id='md'>Minimum distance between any two points in the design</h2><span id='topic+md'></span>

<h3>Description</h3>

<p>Minimum distance between any two points in the design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>md(D)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="md_+3A_d">D</code></td>
<td>
<p>a design matrix, rows are design locations, columns are design factors</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>MinimumDistance</code></td>
<td>
<p>Minimum distance between any two points in the design</p>
</td></tr>
<tr><td><code>number</code></td>
<td>
<p>number of pairs in the design achieve the minimum distance</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#compute the minimum distance between any two points in design D
d=md(D = cbind(c(0.875,0.375,0.125,0.625),c(0.375,0.125,0.625,0.875)))
d$MinimumDistance
d$number
</code></pre>

<hr>
<h2 id='miM'>The miniMax criterion baesd on an approximate fill distance measure</h2><span id='topic+miM'></span>

<h3>Description</h3>

<p>The miniMax criterion baesd on an approximate fill distance measure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>miM(D, num = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="miM_+3A_d">D</code></td>
<td>
<p>a design matrix, rows are design locations, columns are design factors</p>
</td></tr>
<tr><td><code id="miM_+3A_num">num</code></td>
<td>
<p>Optional, default is &quot;50&quot;. The fineness of the gridded points to divide the design space. Each dimension is evenly divided by num+1 points. Lower this parameter when dimension is high to reduce computing time.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the approximate fill distance for the design by using a set of gridded points, the maximum error of the value can be computed.
</p>


<h3>Value</h3>

<p>fill distance with 4 decimals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Compute the approximate fill distance of a design D
d=miM(D = cbind(c(0.875,0.375,0.125,0.625),c(0.375,0.125,0.625,0.875)), num = 20)
</code></pre>

<hr>
<h2 id='miMLHD'>Generate the optimal Latin Hypercube Design based on the miniMax criterion.</h2><span id='topic+miMLHD'></span>

<h3>Description</h3>

<p>Generate the optimal Latin Hypercube Design based on the miniMax criterion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>miMLHD(n, p, num = 50, temp0 = 0, nstarts = 1, times = 300,
  maxiter = 1e+06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="miMLHD_+3A_n">n</code></td>
<td>
<p>number of runs desired</p>
</td></tr>
<tr><td><code id="miMLHD_+3A_p">p</code></td>
<td>
<p>number of variables desired</p>
</td></tr>
<tr><td><code id="miMLHD_+3A_num">num</code></td>
<td>
<p>Optional, default is &quot;50&quot;. The fineness of the gridded points to divide the design space. Each dimension is evenly divided by num+1 points. Lower this parameter when dimension is high to reduce computing time.</p>
</td></tr>
<tr><td><code id="miMLHD_+3A_temp0">temp0</code></td>
<td>
<p>Initial temperature for simulated annealing</p>
</td></tr>
<tr><td><code id="miMLHD_+3A_nstarts">nstarts</code></td>
<td>
<p>Optional, default is &quot;1&quot;. The number of random starts</p>
</td></tr>
<tr><td><code id="miMLHD_+3A_times">times</code></td>
<td>
<p>Optional, default is &quot;300&quot;. The maximum number of non-improving searches allowed before terminating the search.</p>
</td></tr>
<tr><td><code id="miMLHD_+3A_maxiter">maxiter</code></td>
<td>
<p>Optional, default is &quot;1e+06&quot;.The maximum total number of iterations for each random start. Lower this number if the design is prohibitively large and you want to terminate the algorithm prematurely to report the best design found</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is to search the optimal Latin Hypercube design based on the miniMax criterion using the columnwise exchange algorithm coupled with the simulated annealing algorithm, and several computational shortcuts to improve efficiency. The approximate miniMax criterion is computed by using a set of gridded points to approximate the continuous design space, the maximum error of the value can be computed.(Can only work in relatively low dimensions)
</p>


<h3>Value</h3>

<table>
<tr><td><code>design</code></td>
<td>
<p>The optimal miniMax design matrix</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>
<p>The opproximate miniMax criterion for the chosen fineness of the grids</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>The total iterations</p>
</td></tr>
<tr><td><code>time_rec</code></td>
<td>
<p>Time to complete the search</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#Generate the optimal minimax distance LHD(20,2)
## Not run: 
D=miMLHD(n=20,p=2)
D$design
D$criterion

## End(Not run)
</code></pre>

<hr>
<h2 id='Mm'>Computer the approximate Maximin Criterion for a design.</h2><span id='topic+Mm'></span>

<h3>Description</h3>

<p>Computer the approximate Maximin Criterion for a design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mm(D, power = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mm_+3A_d">D</code></td>
<td>
<p>a design matrix</p>
</td></tr>
<tr><td><code id="Mm_+3A_power">power</code></td>
<td>
<p>Optional, default is &quot;100&quot;. The power parameter r in the average reciprocal inter-point distance measure. When r is approaching infinity, minimizing the average reciprocal inter-point distance measure is equivalent to maximizing the minimum distance among the design points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The approximate Maximin criterion with 4 decimals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Compute the maximin criterion of a random LHD(20,2)
des=LHD(n = 20,p = 2)$standDesign
Mm(D=des, power=150)
</code></pre>

<hr>
<h2 id='MmLHD'>Generate the optimal Maximin Latin Hypercube Design.</h2><span id='topic+MmLHD'></span>

<h3>Description</h3>

<p>Generate the optimal Maximin Latin Hypercube Design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MmLHD(n, p, power = 100, temp0 = 0, nstarts = 1, times = 300,
  maxiter = 1e+06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MmLHD_+3A_n">n</code></td>
<td>
<p>number of runs desired</p>
</td></tr>
<tr><td><code id="MmLHD_+3A_p">p</code></td>
<td>
<p>number of variables desired</p>
</td></tr>
<tr><td><code id="MmLHD_+3A_power">power</code></td>
<td>
<p>Optional, default is &quot;100&quot;. The power parameter r in the average reciprocal inter-point distance measure. When r turns to infinity, minimizing the average reciprocal inter-point distance measure is equivalent to maximizing the minimum distance among the design points.</p>
</td></tr>
<tr><td><code id="MmLHD_+3A_temp0">temp0</code></td>
<td>
<p>Initial temperature</p>
</td></tr>
<tr><td><code id="MmLHD_+3A_nstarts">nstarts</code></td>
<td>
<p>Optional, default is &quot;1&quot;. The number of random starts</p>
</td></tr>
<tr><td><code id="MmLHD_+3A_times">times</code></td>
<td>
<p>Optional, default is &quot;300&quot;. The maximum number of non-improving searches allowed. Lower this parameter if you expect the search to converge faster.</p>
</td></tr>
<tr><td><code id="MmLHD_+3A_maxiter">maxiter</code></td>
<td>
<p>Optional, default is &quot;1e+06&quot;.The maximum total number of iterations for each random start. Lower this number if the design is prohibitively large and you want to terminate the algorithm prematurely to report the best design found</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is to search the optimal Maximin design using columnwise exchange algorithm coupled with the simulated annealing algorithm and several computational shortcuts to improve efficiency.
</p>


<h3>Value</h3>

<table>
<tr><td><code>design</code></td>
<td>
<p>The optimal Maximin design matrix</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>
<p>The opproximate Maximin criterion of the design under chosen &quot;power&quot; parameter</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>The total iterations</p>
</td></tr>
<tr><td><code>time_rec</code></td>
<td>
<p>Time to complete the search</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#Generate the optimal maximin distance LHD(20,2)
D=MmLHD(n=20,p=2)
D$design
D$criterion
</code></pre>

<hr>
<h2 id='mp'>Computer the MaxPro Criterion for a design.</h2><span id='topic+mp'></span>

<h3>Description</h3>

<p>Computer the MaxPro Criterion for a design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mp(D)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mp_+3A_d">D</code></td>
<td>
<p>a design matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is to compute the MaxPro criterion for measuring projection characteristic of a computer experiment.
</p>


<h3>Value</h3>

<p>The MaxPro Criterion with 4 decimals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#compute the mp criterion of a random LHD(20,2)
D=LHD(20,2)$standDesign
mp(D)
</code></pre>

<hr>
<h2 id='mpLHD'>Generate the optimal MaxPro Latin Hypercube Design.</h2><span id='topic+mpLHD'></span>

<h3>Description</h3>

<p>Generate the optimal MaxPro Latin Hypercube Design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpLHD(n, p, temp0 = 0, nstarts = 1, times = 300, maxiter = 1e+06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpLHD_+3A_n">n</code></td>
<td>
<p>number of runs desired</p>
</td></tr>
<tr><td><code id="mpLHD_+3A_p">p</code></td>
<td>
<p>number of design factors desired</p>
</td></tr>
<tr><td><code id="mpLHD_+3A_temp0">temp0</code></td>
<td>
<p>Initial temperature for simulated annealing</p>
</td></tr>
<tr><td><code id="mpLHD_+3A_nstarts">nstarts</code></td>
<td>
<p>Optional, default is &quot;1&quot;. The number of random starts</p>
</td></tr>
<tr><td><code id="mpLHD_+3A_times">times</code></td>
<td>
<p>Optional, default is &quot;300&quot;. The maximum number of non-improving searches allowed. Lower this parameter if you expect the search to converge faster.</p>
</td></tr>
<tr><td><code id="mpLHD_+3A_maxiter">maxiter</code></td>
<td>
<p>Optional, default is &quot;1e+06&quot;.The maximum total number of iterations. Lower this number if the design is prohibitively large and you want to terminate the search prematurely to report the best design found</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is to search the optimal Latin Hypercube Design based on the MaxPro criterion using the columnwise exchange algorithm coupled with the simulated annealing algorithm, and several computational shortcuts to improve efficiency.
</p>


<h3>Value</h3>

<table>
<tr><td><code>design</code></td>
<td>
<p>The optimal LHD design matrix based on the MaxPro criterion</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>
<p>The MaxPro criterion of the selected optimal LHD design</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>The total iterations</p>
</td></tr>
<tr><td><code>time_rec</code></td>
<td>
<p>Time to complete the search</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#Generate a optimal maximum projection LHD(20,2) design
D=mpLHD(n=20,p=2)
D$design
D$criterion
</code></pre>

<hr>
<h2 id='pfMm'>Generate the Pareto front for the optimal Latin Hypercube Designs based on both the Maximin and miniMax criteria.</h2><span id='topic+pfMm'></span>

<h3>Description</h3>

<p>Generate the Pareto front for the optimal Latin Hypercube Designs based on both the Maximin and miniMax criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pfMm(n, p, crlim, num, nstarts = 1, times = 300, maxiter = 1e+06,
  temp0 = 0, wtset = cbind(c(1, 0), c(0.8, 0.2), c(0.6, 0.4), c(0.4, 0.6),
  c(0.2, 0.8), c(0, 1)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pfMm_+3A_n">n</code></td>
<td>
<p>number of runs desired</p>
</td></tr>
<tr><td><code id="pfMm_+3A_p">p</code></td>
<td>
<p>number of design factors desired</p>
</td></tr>
<tr><td><code id="pfMm_+3A_crlim">crlim</code></td>
<td>
<p>a matrix saving the best and worst values for each criterion to be used for defining the scaling choices for converting the natural criteria values onto a desirability scale between 0 and 1. Each column corresponds to one criterion. The best and worst values are recommended based on the values from each single criterion search. It is recommended that slightly wider range is used for defining the scaling choice for the Pareto front search.</p>
</td></tr>
<tr><td><code id="pfMm_+3A_num">num</code></td>
<td>
<p>The fineness of the grids to approximiate the approximate the continuous design space. Lower this parameter when dimension is high to reduce computing time.</p>
</td></tr>
<tr><td><code id="pfMm_+3A_nstarts">nstarts</code></td>
<td>
<p>Optional, default is &quot;1&quot;. The number of random starts</p>
</td></tr>
<tr><td><code id="pfMm_+3A_times">times</code></td>
<td>
<p>Optional, default is &quot;300&quot;. The maximum number of non-improving searches allowed before terminating the search. Lower this parameter if you expect the search to converge faster.</p>
</td></tr>
<tr><td><code id="pfMm_+3A_maxiter">maxiter</code></td>
<td>
<p>Optional, default is &quot;1e+06&quot;.The maximum total number of iterations. Lower this number if the design is prohibitively large.</p>
</td></tr>
<tr><td><code id="pfMm_+3A_temp0">temp0</code></td>
<td>
<p>Initial temperature for simualted annealing</p>
</td></tr>
<tr><td><code id="pfMm_+3A_wtset">wtset</code></td>
<td>
<p>Optional, default is &quot;cbind(c(1,0),c(0.8,0.2),c(0.6,0.4),c(0.4,0.6),c(0.2,0.8),c(0,1))&quot;. The set of weight combinations to guide the search in varied directions. Each column is a weight vector that guides the search in a certain direction.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is to search for the Pareto front and the Pareto set of LHDs based on the Maximin and miniMax criteria. Each design on Pareto front is not dominated by any other design.This function utilizes a version of simulated annealing algorithm and several computational shortcuts to efficiently generate the optimal Latin hypercube designs. Choose a lower maximum limit of the criteria but high enough for Pareto front designs will save the computing time.
</p>


<h3>Value</h3>

<table>
<tr><td><code>pfdes</code></td>
<td>
<p>The column bind of Pareto front designs whose criteria values are on the Pareto front.</p>
</td></tr>
<tr><td><code>pfvals</code></td>
<td>
<p>The Pareto front of criteria values based on the Maximin and miniMax criteria. Columns are the optimization criteria.</p>
</td></tr>
<tr><td><code>time_rec</code></td>
<td>
<p>Time to complete the search</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#Generate the Pareto front designs of maximin and minimax distance criterion for LHD(10,2)
## Not run: 
D1=MmLHD(n=10,p=2,nstarts=30)
D2=miMLHD(n=10,p=2,num=15,nstarts=30)
Mmlim=c(D1$criterion-0.2,D1$criterion-0.2+2)
mMlim=c(D2$criterion-0.05,D2$criterion-0.05+0.5)
crlim=cbind(Mmlim,mMlim)
pf=pfMm(10,2,crlim,num = 15,nstarts = 30)
pf$pfvals
pf$pfdes
pf$time_rec

## End(Not run)
</code></pre>

<hr>
<h2 id='pfMp'>Generate the Pareto front for optimal Latin Hypercube Designs based on both the Maximin and the MaxPro criteria.</h2><span id='topic+pfMp'></span>

<h3>Description</h3>

<p>Generate the Pareto front for optimal Latin Hypercube Designs based on both the Maximin and the MaxPro criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pfMp(n, p, crlim, nstarts = 1, times = 300, maxiter = 1e+06, temp0 = 0,
  wtset = cbind(c(1, 0), c(0.8, 0.2), c(0.6, 0.4), c(0.4, 0.6), c(0.2, 0.8),
  c(0, 1)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pfMp_+3A_n">n</code></td>
<td>
<p>number of runs desired</p>
</td></tr>
<tr><td><code id="pfMp_+3A_p">p</code></td>
<td>
<p>number of design factors desired</p>
</td></tr>
<tr><td><code id="pfMp_+3A_crlim">crlim</code></td>
<td>
<p>a matrix saving the best and worst values for each criterion to be used for defining the scaling choices for converting the natural criteria values onto a desirability scale between 0 and 1. Each column corresponds to one criterion. The best and worst values are recommended based on the values from each single criterion search. It is recommended that slightly wider range is used for defining the scaling choice for the Pareto front search.</p>
</td></tr>
<tr><td><code id="pfMp_+3A_nstarts">nstarts</code></td>
<td>
<p>Optional, default is &quot;1&quot;. The number of random starts</p>
</td></tr>
<tr><td><code id="pfMp_+3A_times">times</code></td>
<td>
<p>Optional, default is &quot;300&quot;. The maximum number of non-improving searches allowed before terminating the search. Lower this parameter if you expect the search to converge faster.</p>
</td></tr>
<tr><td><code id="pfMp_+3A_maxiter">maxiter</code></td>
<td>
<p>Optional, default is &quot;1e+06&quot;.The maximum total number of iterations. Lower this number if the design is prohibitively large and you want to terminate the search earlier to report the best design found.</p>
</td></tr>
<tr><td><code id="pfMp_+3A_temp0">temp0</code></td>
<td>
<p>Initial temperature for simualted annealing</p>
</td></tr>
<tr><td><code id="pfMp_+3A_wtset">wtset</code></td>
<td>
<p>Optional, default is &quot;cbind(c(1,0),c(0.8,0.2),c(0.6,0.4),c(0.4,0.6),c(0.2,0.8),c(0,1))&quot;. The set of weight combinations to guide the search in varied directions. Each column is a weight vector that guides the search in a certain direction.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is to search the Pareto front and the Pareto set of designs based on the Maximin and Maxpro criteria. Each design on Pareto front is not dominated by any other design.This function utilizes a version of simulated annealing algorithm and several computational shortcuts to efficiently generate the optimal Latin hypercube designs. Choose a lower maximum limit of the criteria but high enough for Pareto front designs will save the computing time.
</p>


<h3>Value</h3>

<table>
<tr><td><code>pfdes</code></td>
<td>
<p>The column bind of Pareto front designs whose criteria values are on the Pareto front.</p>
</td></tr>
<tr><td><code>pfvals</code></td>
<td>
<p>The Pareto front of criteria values based on the Maximin and MaxPro criteria. Columns are the optimization criteria.</p>
</td></tr>
<tr><td><code>time_rec</code></td>
<td>
<p>Time to complete the search</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#Generate the Pareto designs of maximin distance and maximum projection for LHD(10,5)
## Not run: 
D1=MmLHD(n=10,p=5,nstarts=30)
D2=mpLHD(n=10,p=5,nstarts=30)
Mmlim=c(D1$criterion-0.2,D1$criterion-0.2+2)
mplim=c(D2$criterion-2,D2$criterion-2+10)
crlim=cbind(Mmlim,mplim)
pf=pfMp(10,5,crlim,nstarts = 30)
pf$pfvals
pf$pfdes
pf$time_rec

## End(Not run)
</code></pre>

<hr>
<h2 id='pfMpm'>Generate the Pareto front for the optimal Latin Hypercube Designs based on the Maximin, MaxPro and miniMax criteria.</h2><span id='topic+pfMpm'></span>

<h3>Description</h3>

<p>Generate the Pareto front for the optimal Latin Hypercube Designs based on the Maximin, MaxPro and miniMax criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pfMpm(n, p, crlim, num, nstarts = 1, times = 300, maxiter = 1e+06,
  temp0 = 0, wtset = cbind(c(1, 0, 0), c(0.5, 0.5, 0), c(0.5, 0, 0.5), c(0,
  0.5, 0.5), c(0, 1, 0), c(0, 0, 1), c(1/3, 1/3, 1/3)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pfMpm_+3A_n">n</code></td>
<td>
<p>number of runs desired</p>
</td></tr>
<tr><td><code id="pfMpm_+3A_p">p</code></td>
<td>
<p>number of design factors desired</p>
</td></tr>
<tr><td><code id="pfMpm_+3A_crlim">crlim</code></td>
<td>
<p>a matrix saving the best and worst values for each criterion to be used for defining the scaling choices for converting the natural criteria values onto a desirability scale between 0 and 1. Each column corresponds to one criterion. The best and worst values are recommended based on the values from each single criterion search. It is recommended that slightly wider range is used for defining the scaling choice for the Pareto front search.</p>
</td></tr>
<tr><td><code id="pfMpm_+3A_num">num</code></td>
<td>
<p>The fineness of the grids to approximiate the approximate the continuous design space. Lower this parameter when dimension is high to reduce computing time.</p>
</td></tr>
<tr><td><code id="pfMpm_+3A_nstarts">nstarts</code></td>
<td>
<p>Optional, default is &quot;1&quot;. The number of random starts</p>
</td></tr>
<tr><td><code id="pfMpm_+3A_times">times</code></td>
<td>
<p>Optional, default is &quot;300&quot;. The maximum number of non-improving searches allowed before terminating the search. Lower this parameter if you expect the search to converge faster.</p>
</td></tr>
<tr><td><code id="pfMpm_+3A_maxiter">maxiter</code></td>
<td>
<p>Optional, default is &quot;1e+06&quot;.The maximum total number of iterations. Lower this number if the design is prohibitively large.</p>
</td></tr>
<tr><td><code id="pfMpm_+3A_temp0">temp0</code></td>
<td>
<p>Initial temperature for simualted annealing</p>
</td></tr>
<tr><td><code id="pfMpm_+3A_wtset">wtset</code></td>
<td>
<p>Optional, default is &quot;cbind(c(1,0,0),c(0.5,0.5,0),c(0.5,0,0.5),c(0,0.5,0.5),c(0,1,0),
</p>
<p>c(0,0,1),c(1/3,1/3,1/3))&quot;. The set of weight combinations to guide the search in varied directions. Each column is a weight vector that guides the search in a certain direction.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is to search for the Pareto front and the Pareto set of LHDs based on the Maximin, Maxpro and miniMax criteria. Each design on Pareto front is not dominated by any other design.This function utilizes a version of simulated annealing algorithm and several computational shortcuts to efficiently generate the optimal Latin hypercube designs. Choose a lower maximum limit of the criteria but high enough for Pareto front designs will save the computing time.
</p>


<h3>Value</h3>

<table>
<tr><td><code>pfdes</code></td>
<td>
<p>The column bind of Pareto front designs whose criteria values are on the Pareto front.</p>
</td></tr>
<tr><td><code>pfvals</code></td>
<td>
<p>The Pareto front of criteria values based on the Maximin, MaxPro and miniMax criteria. Columns are the optimization criteria.</p>
</td></tr>
<tr><td><code>time_rec</code></td>
<td>
<p>Time to complete the search</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#Generate the Pareto front designs of maximin distance,
#minimax diatance, and maximum projection criterion for LHD(10,2)
## Not run: 
D1=MmLHD(n=10,p=2,nstarts=30)
D2=mpLHD(n=10,p=2,nstarts=30)
D3=miMLHD(n=10,p=2,num=15,nstarts=30)
Mmlim=c(D1$criterion-0.2,D1$criterion-0.2+2)
mplim=c(D2$criterion-2,D2$criterion-2+10)
mMlim=c(D3$criterion-0.05,D3$criterion-0.05+0.5)
crlim=cbind(Mmlim,mplim,mMlim)
pf=pfMpm(10,2,crlim,num = 15,nstarts = 30)
pf$pfvals
pf$pfdes
pf$time_rec

## End(Not run)
</code></pre>

<hr>
<h2 id='pfpm'>Generate the Pareto front for the optimal Latin Hypercube Designs based on both the MaxPro and miniMax criteria.</h2><span id='topic+pfpm'></span>

<h3>Description</h3>

<p>Generate the Pareto front for the optimal Latin Hypercube Designs based on both the MaxPro and miniMax criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pfpm(n, p, crlim, num, nstarts = 1, times = 300, maxiter = 1e+06,
  temp0 = 0, wtset = cbind(c(1, 0), c(0.8, 0.2), c(0.6, 0.4), c(0.4, 0.6),
  c(0.2, 0.8), c(0, 1)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pfpm_+3A_n">n</code></td>
<td>
<p>number of runs desired</p>
</td></tr>
<tr><td><code id="pfpm_+3A_p">p</code></td>
<td>
<p>number of design factors desired</p>
</td></tr>
<tr><td><code id="pfpm_+3A_crlim">crlim</code></td>
<td>
<p>a matrix saving the best and worst values for each criterion to be used for defining the scaling choices for converting the natural criteria values onto a desirability scale between 0 and 1. Each column corresponds to one criterion. The best and worst values are recommended based on the values from each single criterion search. It is recommended that slightly wider range is used for defining the scaling choice for the Pareto front search.</p>
</td></tr>
<tr><td><code id="pfpm_+3A_num">num</code></td>
<td>
<p>The fineness of the grids to approximiate the approximate the continuous design space. Lower this parameter when dimension is high to reduce computing time.</p>
</td></tr>
<tr><td><code id="pfpm_+3A_nstarts">nstarts</code></td>
<td>
<p>Optional, default is &quot;1&quot;. The number of random starts</p>
</td></tr>
<tr><td><code id="pfpm_+3A_times">times</code></td>
<td>
<p>Optional, default is &quot;300&quot;. The maximum number of non-improving searches allowed before terminating the search. Lower this parameter if you expect the search to converge faster.</p>
</td></tr>
<tr><td><code id="pfpm_+3A_maxiter">maxiter</code></td>
<td>
<p>Optional, default is &quot;1e+06&quot;.The maximum total number of iterations. Lower this number if the design is prohibitively large.</p>
</td></tr>
<tr><td><code id="pfpm_+3A_temp0">temp0</code></td>
<td>
<p>Initial temperature for simualted annealing</p>
</td></tr>
<tr><td><code id="pfpm_+3A_wtset">wtset</code></td>
<td>
<p>Optional, default is &quot;cbind(c(1,0),c(0.8,0.2),c(0.6,0.4),c(0.4,0.6),c(0.2,0.8),c(0,1))&quot;. The set of weight combinations to guide the search in varied directions. Each column is a weight vector that guides the search in a certain direction.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is to search for the Pareto front and the Pareto set of LHDs based on the MaxPro and miniMax criteria. Each design on Pareto front is not dominated by any other design.This function utilizes a version of simulated annealing algorithm and several computational shortcuts to efficiently generate the optimal Latin hypercube designs. Choose a lower maximum limit of the criteria but high enough for Pareto front designs will save the computing time.
</p>


<h3>Value</h3>

<table>
<tr><td><code>pfdes</code></td>
<td>
<p>The column bind of Pareto front designs whose criteria values are on the Pareto front.</p>
</td></tr>
<tr><td><code>pfvals</code></td>
<td>
<p>The Pareto front of criteria values based on the Maximin and miniMax criteria. Columns are the optimization criteria.</p>
</td></tr>
<tr><td><code>time_rec</code></td>
<td>
<p>Time to complete the search</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#Generate the Pareto front designs of maximum projection and minimax distance criteria for LHD(10,2)
## Not run: 
D1=mpLHD(n=10,p=2,times=1000,nstarts=30)
D2=miMLHD(n=10,p=2,num=15,nstarts=30)
mplim=c(D1$criterion-2,D1$criterion-2+20)
mMlim=c(D2$criterion-0.05,D2$criterion-0.05+0.5)
crlim=cbind(mplim,mMlim)
pf=pfpm(10,2,crlim,num = 15,nstarts = 30)
pf$pfvals
pf$pfdes
pf$time_rec

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
