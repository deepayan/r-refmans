<!DOCTYPE html><html><head><title>Help for package tosca</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tosca}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.corpus.textmeta'><p>Transform textmeta to corpus</p></a></li>
<li><a href='#as.meta'><p>&quot;meta&quot; Component of &quot;textmeta&quot;-Objects</p></a></li>
<li><a href='#as.textmeta.corpus'><p>Transform corpus to textmeta</p></a></li>
<li><a href='#cleanTexts'><p>Data Preprocessing</p></a></li>
<li><a href='#clusterTopics'><p>Cluster Analysis</p></a></li>
<li><a href='#deleteAndRenameDuplicates'><p>Deletes and Renames Articles with the same ID</p></a></li>
<li><a href='#duplist'><p>Creating List of Duplicates</p></a></li>
<li><a href='#filterCount'><p>Subcorpus With Count Filter</p></a></li>
<li><a href='#filterDate'><p>Subcorpus With Date Filter</p></a></li>
<li><a href='#filterID'><p>Subcorpus With ID Filter</p></a></li>
<li><a href='#filterWord'><p>Subcorpus With Word Filter</p></a></li>
<li><a href='#intruderTopics'><p>Function to validate the fit of the LDA model</p></a></li>
<li><a href='#intruderWords'><p>Function to validate the fit of the LDA model</p></a></li>
<li><a href='#LDAgen'><p>Function to fit LDA model</p></a></li>
<li><a href='#LDAprep'><p>Create Lda-ready Dataset</p></a></li>
<li><a href='#makeWordlist'><p>Counts Words in Text Corpora</p></a></li>
<li><a href='#mergeLDA'><p>Preparation of Different LDAs For Clustering</p></a></li>
<li><a href='#mergeTextmeta'><p>Merge Textmeta Objects</p></a></li>
<li><a href='#plotArea'><p>Plotting topics over time as stacked areas below plotted lines.</p></a></li>
<li><a href='#plotFreq'><p>Plotting Counts of specified Wordgroups over Time (relative to Corpus)</p></a></li>
<li><a href='#plotHeat'><p>Plotting Topics over Time relative to Corpus</p></a></li>
<li><a href='#plotScot'><p>Plots Counts of Documents or Words over Time (relative to Corpus)</p></a></li>
<li><a href='#plotTopic'><p>Plotting Counts of Topics over Time (Relative to Corpus)</p></a></li>
<li><a href='#plotTopicWord'><p>Plotting Counts of Topics-Words-Combination over Time (Relative to Words)</p></a></li>
<li><a href='#plotWordpt'><p>Plots Counts of Topics-Words-Combination over Time (Relative to Topics)</p></a></li>
<li><a href='#plotWordSub'><p>Plotting Counts/Proportion of Words/Docs in LDA-generated Topic-Subcorpora over Time</p></a></li>
<li><a href='#precision'><p>Precision and Recall</p></a></li>
<li><a href='#readTextmeta'><p>Read Corpora as CSV</p></a></li>
<li><a href='#readWhatsApp'><p>Read WhatsApp files</p></a></li>
<li><a href='#readWiki'><p>Read Pages from Wikipedia</p></a></li>
<li><a href='#readWikinews'><p>Read files from Wikinews</p></a></li>
<li><a href='#removeXML'><p>Removes XML/HTML Tags and Umlauts</p></a></li>
<li><a href='#sampling'><p>Sample Texts</p></a></li>
<li><a href='#showMeta'><p>Export Readable Meta-Data of Articles.</p></a></li>
<li><a href='#showTexts'><p>Exports Readable Text Lists</p></a></li>
<li><a href='#textmeta'><p>&quot;textmeta&quot;-Objects</p></a></li>
<li><a href='#tidy.textmeta'><p>Transform textmeta to an object with tidy text data</p></a></li>
<li><a href='#topicCoherence'><p>Calculating Topic Coherence</p></a></li>
<li><a href='#topicsInText'><p>Coloring the words of a text corresponding to topic allocation</p></a></li>
<li><a href='#topTexts'><p>Get The IDs Of The Most Representive Texts</p></a></li>
<li><a href='#topWords'><p>Top Words per Topic</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Statistical Content Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3-2</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-10-28</td>
</tr>
<tr>
<td>Description:</td>
<td>A framework for statistical analysis in content analysis. In addition to a pipeline for preprocessing text corpora and linking to the latent Dirichlet allocation from the 'lda' package, plots are offered for the descriptive analysis of text corpora and topic models. In addition, an implementation of Chang's intruder words and intruder topics is provided. Sample data for the vignette is included in the toscaData package, which is available on gitHub: <a href="https://github.com/Docma-TU/toscaData">https://github.com/Docma-TU/toscaData</a>.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Docma-TU/tosca">https://github.com/Docma-TU/tosca</a>,
<a href="https://doi.org/10.5281/zenodo.3591068">https://doi.org/10.5281/zenodo.3591068</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>tm (&ge; 0.7-5), lda (&ge; 1.4.2), quanteda (&ge; 1.4.0), lubridate
(&ge; 1.7.3), htmltools (&ge; 0.3.6), RColorBrewer (&ge; 1.1-2),
stringr (&ge; 1.3.1), WikipediR (&ge; 1.5.0), data.table (&ge;
1.11.4)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>toscaData, testthat (&ge; 2.0.0), knitr (&ge; 1.20), devtools (&ge;
1.13), rmarkdown (&ge; 1.9)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-10-28 06:09:08 UTC; lars</td>
</tr>
<tr>
<td>Author:</td>
<td>Lars Koppers <a href="https://orcid.org/0000-0002-1642-9616"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Jonas Rieger <a href="https://orcid.org/0000-0002-0007-4478"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Karin Boczek <a href="https://orcid.org/0000-0003-1516-4094"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Gerret von Nordheim
    <a href="https://orcid.org/0000-0001-7553-3838"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lars Koppers &lt;koppers@statistik.tu-dortmund.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-10-28 13:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.corpus.textmeta'>Transform textmeta to corpus</h2><span id='topic+as.corpus.textmeta'></span>

<h3>Description</h3>

<p>Transfers data from a <code><a href="#topic+textmeta">textmeta</a></code> object to a
<code><a href="quanteda.html#topic+corpus">corpus</a></code> object -  the way text data is stored in the
package <code><a href="quanteda.html#topic+quanteda">quanteda</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.corpus.textmeta(
  object,
  docnames = "id",
  docvars = setdiff(colnames(object$meta), "id"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.corpus.textmeta_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+textmeta">textmeta</a></code> object</p>
</td></tr>
<tr><td><code id="as.corpus.textmeta_+3A_docnames">docnames</code></td>
<td>
<p>Character: string with the column of <code>object$meta</code>
which should be kept as <code><a href="quanteda.html#topic+docnames">docnames</a></code>.</p>
</td></tr>
<tr><td><code id="as.corpus.textmeta_+3A_docvars">docvars</code></td>
<td>
<p>Character: vector with columns of <code>object$meta</code> which
should be kept as <code><a href="quanteda.html#topic+docvars">docvars</a></code>.</p>
</td></tr>
<tr><td><code id="as.corpus.textmeta_+3A_...">...</code></td>
<td>
<p>Additional parameters like <code>meta</code> or <code>compress</code> for <code><a href="quanteda.html#topic+corpus">corpus</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="quanteda.html#topic+corpus">corpus</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>texts &lt;- list(A="Give a Man a Fish, and You Feed Him for a Day.
 Teach a Man To Fish, and You Feed Him for a Lifetime",
 B="So Long, and Thanks for All the Fish",
 C="A very able manipulative mathematician, Fisher enjoys a real mastery
 in evaluating complicated multiple integrals.")

obj &lt;- textmeta(meta=data.frame(id=c("A", "B", "C", "D"),
 title=c("Fishing", "Don't panic!", "Sir Ronald", "Berlin"),
 date=c("1885-01-02", "1979-03-04", "1951-05-06", "1967-06-02"),
 additionalVariable=1:4, stringsAsFactors=FALSE), text=texts)

corp &lt;- as.corpus.textmeta(obj)
quanteda::docvars(corp)
#quanteda::textstat_summary(corp)
</code></pre>

<hr>
<h2 id='as.meta'>&quot;meta&quot; Component of &quot;textmeta&quot;-Objects</h2><span id='topic+as.meta'></span>

<h3>Description</h3>

<p>Helper to create the requested data.frame to create a &quot;textmeta&quot; object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.meta(
  x,
  cols = colnames(x),
  idCol = "id",
  dateCol = "date",
  titleCol = "title",
  dateFormat
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.meta_+3A_x">x</code></td>
<td>
<p>data.frame to convert</p>
</td></tr>
<tr><td><code id="as.meta_+3A_cols">cols</code></td>
<td>
<p><code>character</code> vector with columns which should be kept</p>
</td></tr>
<tr><td><code id="as.meta_+3A_idcol">idCol</code></td>
<td>
<p><code>character</code> string with column name of the IDs</p>
</td></tr>
<tr><td><code id="as.meta_+3A_datecol">dateCol</code></td>
<td>
<p><code>character</code> string with column name of the Dates</p>
</td></tr>
<tr><td><code id="as.meta_+3A_titlecol">titleCol</code></td>
<td>
<p><code>character</code> string with column name of the Titles</p>
</td></tr>
<tr><td><code id="as.meta_+3A_dateformat">dateFormat</code></td>
<td>
<p><code>character</code> string with the date format in x for <code><a href="base.html#topic+as.Date">as.Date</a></code>.
If not supplied, dates are not transformed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with columns &quot;id&quot;, &quot;date&quot;, &quot;title&quot; and user-specified others.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>meta &lt;- data.frame(id = 1:3, additionalVariable = matrix(5, ncol = 4, nrow = 3))
(as.meta(meta))

</code></pre>

<hr>
<h2 id='as.textmeta.corpus'>Transform corpus to textmeta</h2><span id='topic+as.textmeta.corpus'></span>

<h3>Description</h3>

<p>Transfers data from a <code><a href="quanteda.html#topic+corpus">corpus</a></code> object -  the way text
data is stored in the package <code><a href="quanteda.html#topic+quanteda">quanteda</a></code> - to a
<code><a href="#topic+textmeta">textmeta</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.textmeta.corpus(
  corpus,
  cols,
  dateFormat = "%Y-%m-%d",
  idCol = "id",
  dateCol = "date",
  titleCol = "title",
  textCol = "texts",
  duplicateAction = TRUE,
  addMetadata = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.textmeta.corpus_+3A_corpus">corpus</code></td>
<td>
<p>Object of class <code><a href="quanteda.html#topic+corpus">corpus</a></code>,
package <code><a href="quanteda.html#topic+quanteda">quanteda</a></code>.</p>
</td></tr>
<tr><td><code id="as.textmeta.corpus_+3A_cols">cols</code></td>
<td>
<p>Character: vector with columns which should be kept.</p>
</td></tr>
<tr><td><code id="as.textmeta.corpus_+3A_dateformat">dateFormat</code></td>
<td>
<p>Character: string with the date format in the
date column for <code><a href="base.html#topic+as.Date">as.Date</a></code>.</p>
</td></tr>
<tr><td><code id="as.textmeta.corpus_+3A_idcol">idCol</code></td>
<td>
<p>Character: string with column name of the IDs in corpus
- named &quot;id&quot; in the resulting data.frame.</p>
</td></tr>
<tr><td><code id="as.textmeta.corpus_+3A_datecol">dateCol</code></td>
<td>
<p>Character: string with column name of the Dates in corpus
- named &quot;date&quot; in the resulting data.frame.</p>
</td></tr>
<tr><td><code id="as.textmeta.corpus_+3A_titlecol">titleCol</code></td>
<td>
<p>Character: string with column name of the Titles in corpus
- named &quot;title&quot; in the resulting data.frame.</p>
</td></tr>
<tr><td><code id="as.textmeta.corpus_+3A_textcol">textCol</code></td>
<td>
<p>Character: string with column name of the Texts in corpus
- results in a named list (&quot;id&quot;) of the Texts.</p>
</td></tr>
<tr><td><code id="as.textmeta.corpus_+3A_duplicateaction">duplicateAction</code></td>
<td>
<p>Logical:
Should <code><a href="#topic+deleteAndRenameDuplicates">deleteAndRenameDuplicates</a></code> be applied to the
created <code><a href="#topic+textmeta">textmeta</a></code> object?</p>
</td></tr>
<tr><td><code id="as.textmeta.corpus_+3A_addmetadata">addMetadata</code></td>
<td>
<p>Logical: Should the metadata flag of corpus
be added to the meta flag of the <code><a href="#topic+textmeta">textmeta</a></code> object? If there are
conflicts regarding the naming of columns, the metadata columns would be
overwritten by the document specific columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+textmeta">textmeta</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>texts &lt;- c("Give a Man a Fish, and You Feed Him for a Day.
 Teach a Man To Fish, and You Feed Him for a Lifetime",
 "So Long, and Thanks for All the Fish",
 "A very able manipulative mathematician, Fisher enjoys a real mastery
 in evaluating complicated multiple integrals.")

corp &lt;- quanteda::corpus(x = texts)
obj &lt;- as.textmeta.corpus(corp, addMetadata = FALSE)

quanteda::docvars(corp, "title") &lt;- c("Fishing", "Don't panic!", "Sir Ronald")
quanteda::docvars(corp, "date") &lt;- c("1885-01-02", "1979-03-04", "1951-05-06")
quanteda::docvars(corp, "id") &lt;- c("A", "B", "C")
quanteda::docvars(corp, "additionalVariable") &lt;- 1:3

obj &lt;- as.textmeta.corpus(corp)
</code></pre>

<hr>
<h2 id='cleanTexts'>Data Preprocessing</h2><span id='topic+cleanTexts'></span>

<h3>Description</h3>

<p>Removes punctuation, numbers and stopwords, changes letters into lowercase
and tokenizes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cleanTexts(
  object,
  text,
  sw = "en",
  paragraph = FALSE,
  lowercase = TRUE,
  rmPunctuation = TRUE,
  rmNumbers = TRUE,
  checkUTF8 = TRUE,
  ucp = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cleanTexts_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+textmeta">textmeta</a></code> object</p>
</td></tr>
<tr><td><code id="cleanTexts_+3A_text">text</code></td>
<td>
<p>Not necassary if <code>object</code> is specified, else should be
<code>object\$text</code>: List of article texts.</p>
</td></tr>
<tr><td><code id="cleanTexts_+3A_sw">sw</code></td>
<td>
<p>Character: Vector of stopwords. If the vector is of length
one, <code>sw</code> is interpreted as argument for <code><a href="tm.html#topic+stopwords">stopwords</a></code> from the tm package.</p>
</td></tr>
<tr><td><code id="cleanTexts_+3A_paragraph">paragraph</code></td>
<td>
<p>Logical: Should be set to <code>TRUE</code> if one article is a
list of character strings, representing the paragraphs.</p>
</td></tr>
<tr><td><code id="cleanTexts_+3A_lowercase">lowercase</code></td>
<td>
<p>Logical: Should be set to <code>TRUE</code> if all letters should
be coerced to lowercase.</p>
</td></tr>
<tr><td><code id="cleanTexts_+3A_rmpunctuation">rmPunctuation</code></td>
<td>
<p>Logical: Should be set to <code>TRUE</code> if punctuation should
be removed from articles.</p>
</td></tr>
<tr><td><code id="cleanTexts_+3A_rmnumbers">rmNumbers</code></td>
<td>
<p>Logical: Should be set to <code>TRUE</code> if numbers should
be removed from articles.</p>
</td></tr>
<tr><td><code id="cleanTexts_+3A_checkutf8">checkUTF8</code></td>
<td>
<p>Logical: Should be set to <code>TRUE</code> if articles should
be tested on UTF-8 - which is package standard.</p>
</td></tr>
<tr><td><code id="cleanTexts_+3A_ucp">ucp</code></td>
<td>
<p>Logical: ucp option for <code><a href="tm.html#topic+removePunctuation">removePunctuation</a></code> from the tm package. Runs remove punctuation twice (ASCII and Unicode).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Removes punctuation, numbers and stopwords, change into lowercase letters
and tokenization. Additional some cleaning steps: remove empty words /
paragraphs / article.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+textmeta">textmeta</a></code> object or a list (if <code>object</code> is not specified) containing the preprocessed articles.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>texts &lt;- list(A="Give a Man a Fish, and You Feed Him for a Day.
Teach a Man To Fish, and You Feed Him for a Lifetime",
B="So Long, and Thanks for All the Fish",
C="A very able manipulative mathematician, Fisher enjoys a real mastery
in evaluating complicated multiple integrals.")

corpus &lt;- textmeta(meta=data.frame(id=c("A", "B", "C", "D"),
title=c("Fishing", "Don't panic!", "Sir Ronald", "Berlin"),
date=c("1885-01-02", "1979-03-04", "1951-05-06", "1967-06-02"),
additionalVariable=1:4, stringsAsFactors=FALSE), text=texts)

cleanTexts(object=corpus)

texts &lt;- list(A=c("Give a Man a Fish, and You Feed Him for a Day.",
"Teach a Man To Fish, and You Feed Him for a Lifetime"),
B="So Long, and Thanks for All the Fish",
C=c("A very able manipulative mathematician,",
"Fisher enjoys a real mastery in evaluating complicated multiple integrals."))

cleanTexts(text=texts, sw = "en", paragraph = TRUE)

</code></pre>

<hr>
<h2 id='clusterTopics'>Cluster Analysis</h2><span id='topic+clusterTopics'></span>

<h3>Description</h3>

<p>This function makes a cluster analysis using the Hellinger distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusterTopics(
  ldaresult,
  file,
  tnames = NULL,
  method = "average",
  width = 30,
  height = 15,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clusterTopics_+3A_ldaresult">ldaresult</code></td>
<td>
<p>The result of a function call <code><a href="#topic+LDAgen">LDAgen</a></code> -
alternatively the corresponding matrix <code>result$topics</code></p>
</td></tr>
<tr><td><code id="clusterTopics_+3A_file">file</code></td>
<td>
<p>File for the dendogram pdf.</p>
</td></tr>
<tr><td><code id="clusterTopics_+3A_tnames">tnames</code></td>
<td>
<p>Character vector as label for the topics.</p>
</td></tr>
<tr><td><code id="clusterTopics_+3A_method">method</code></td>
<td>
<p>Method statement from <code><a href="stats.html#topic+hclust">hclust</a></code></p>
</td></tr>
<tr><td><code id="clusterTopics_+3A_width">width</code></td>
<td>
<p>Grafical parameter for pdf output. See <code><a href="grDevices.html#topic+pdf">pdf</a></code></p>
</td></tr>
<tr><td><code id="clusterTopics_+3A_height">height</code></td>
<td>
<p>Grafical parameter for pdf output. See <code><a href="grDevices.html#topic+pdf">pdf</a></code></p>
</td></tr>
<tr><td><code id="clusterTopics_+3A_...">...</code></td>
<td>
<p>Additional parameter for <code><a href="graphics.html#topic+plot">plot</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is useful to analyze
topic similarities and while evaluating the right number of topics of LDAs.
</p>


<h3>Value</h3>

<p>A dendogram as pdf and a list containing </p>
<table>
<tr><td><code>dist</code></td>
<td>
<p>A distance matrix</p>
</td></tr>
<tr><td><code>clust</code></td>
<td>
<p>The result from <code>hclust</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
texts &lt;- list(A="Give a Man a Fish, and You Feed Him for a Day.
Teach a Man To Fish, and You Feed Him for a Lifetime",
B="So Long, and Thanks for All the Fish",
C="A very able manipulative mathematician, Fisher enjoys a real mastery
in evaluating complicated multiple integrals.")

corpus &lt;- textmeta(meta=data.frame(id=c("A", "B", "C", "D"),
title=c("Fishing", "Don't panic!", "Sir Ronald", "Berlin"),
date=c("1885-01-02", "1979-03-04", "1951-05-06", "1967-06-02"),
additionalVariable=1:4, stringsAsFactors=FALSE), text=texts)

corpus &lt;- cleanTexts(corpus)
wordlist &lt;- makeWordlist(corpus$text)
ldaPrep &lt;- LDAprep(text=corpus$text, vocab=wordlist$words)

LDA &lt;- LDAgen(documents=ldaPrep, K = 3L, vocab=wordlist$words, num.words=3)
clusterTopics(ldaresult=LDA)

</code></pre>

<hr>
<h2 id='deleteAndRenameDuplicates'>Deletes and Renames Articles with the same ID</h2><span id='topic+deleteAndRenameDuplicates'></span>

<h3>Description</h3>

<p>Deletes articles with the same ID and same text. Renames the ID of articles
with the same ID but different text-component (_IDFakeDup, _IDRealDup).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deleteAndRenameDuplicates(object, renameRemaining = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deleteAndRenameDuplicates_+3A_object">object</code></td>
<td>
<p>A <code>textmeta</code> object as a result of a read-function.</p>
</td></tr>
<tr><td><code id="deleteAndRenameDuplicates_+3A_renameremaining">renameRemaining</code></td>
<td>
<p>Logical: Should all articles for which a counterpart with the same
id exists, but which do not have the same text and - in addition - which matches (an)other
article(s) in the text field be named a &quot;fake duplicate&quot; or not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Summary: Different types of duplicates:
&quot;complete duplicates&quot; = same ID, same information in text, same information in meta
&quot;real duplicates&quot; = same ID, same information in text, different information in meta
&quot;fake duplicates&quot; = same ID, different information in text
</p>


<h3>Value</h3>

<p>A filtered <code>textmeta</code> object with updated IDs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>texts &lt;- list(A="Give a Man a Fish, and You Feed Him for a Day.
Teach a Man To Fish, and You Feed Him for a Lifetime",
A="A fake duplicate",
B="So Long, and Thanks for All the Fish",
B="So Long, and Thanks for All the Fish",
C="A very able manipulative mathematician, Fisher enjoys a real mastery
in evaluating complicated multiple integrals.",
C="A very able manipulative mathematician, Fisher enjoys a real mastery
in evaluating complicated multiple integrals.")

corpus &lt;- textmeta(meta=data.frame(id=c("A", "A", "B", "B", "C", "C"),
title=c("Fishing", "Fake duplicate", "Don't panic!", "towel day", "Sir Ronald", "Sir Ronald"),
date=c("1885-01-02", "1885-01-03", "1979-03-04", "1979-03-05", "1951-05-06", "1951-05-06"),
stringsAsFactors=FALSE), text=texts)

duplicates &lt;- deleteAndRenameDuplicates(object=corpus)
duplicates$meta$id

texts &lt;- list(A="Give a Man a Fish, and You Feed Him for a Day.
Teach a Man To Fish, and You Feed Him for a Lifetime",
A="Give a Man a Fish, and You Feed Him for a Day.
Teach a Man To Fish, and You Feed Him for a Lifetime",
A="A fake duplicate",
B="So Long, and Thanks for All the Fish",
B="So Long, and Thanks for All the Fish",
C="A very able manipulative mathematician, Fisher enjoys a real mastery
in evaluating complicated multiple integrals.",
C="A very able manipulative mathematician, Fisher enjoys a real mastery
in evaluating complicated multiple integrals.")

corpus &lt;- textmeta(meta=data.frame(id=c("A", "A", "A", "B", "B", "C", "C"),
title=c("Fishing", "Fishing2", "Fake duplicate", "Don't panic!", "towel day",
"Sir Ronald", "Sir Ronald"),
date=c("1885-01-02", "1885-01-02", "1885-01-03", "1979-03-04", "1979-03-05",
"1951-05-06", "1951-05-06"),
stringsAsFactors=FALSE), text=texts)

duplicates &lt;- deleteAndRenameDuplicates(object=corpus)
duplicates2 &lt;- deleteAndRenameDuplicates(object=corpus, renameRemaining = FALSE)

</code></pre>

<hr>
<h2 id='duplist'>Creating List of Duplicates</h2><span id='topic+duplist'></span><span id='topic+is.duplist'></span><span id='topic+print.duplist'></span><span id='topic+summary.duplist'></span>

<h3>Description</h3>

<p>Creates a List of different types of Duplicates in a textmeta-object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>duplist(object, paragraph = FALSE)

is.duplist(x)

## S3 method for class 'duplist'
print(x, ...)

## S3 method for class 'duplist'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="duplist_+3A_object">object</code></td>
<td>
<p>A textmeta-object.</p>
</td></tr>
<tr><td><code id="duplist_+3A_paragraph">paragraph</code></td>
<td>
<p>Logical: Should be set to <code>TRUE</code> if the article is a
list of character strings, representing the paragraphs.</p>
</td></tr>
<tr><td><code id="duplist_+3A_x">x</code></td>
<td>
<p>An R Object.</p>
</td></tr>
<tr><td><code id="duplist_+3A_...">...</code></td>
<td>
<p>Further arguments for print and summary. Not implemented.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function helps to identify different types of Duplicates and gives the
ability to exclude these for further Analysis (e.g. LDA).
</p>


<h3>Value</h3>

<p>Named List:
</p>
<table>
<tr><td><code>uniqueTexts</code></td>
<td>
<p> Character vector of IDs so that each text occurs once - if a text occurs twice or more often in the corpus, the ID of the first text regarding the list-order is returned</p>
</td></tr>
<tr><td><code>notDuplicatedTexts</code></td>
<td>
<p> Character vector of IDs of texts which are represented only once in the whole corpus</p>
</td></tr>
<tr><td><code>idFakeDups</code></td>
<td>
<p> List of character vectors: IDs of texts which originally has the same ID but belongs to different texts grouped by their original ID</p>
</td></tr>
<tr><td><code>idRealDups</code></td>
<td>
<p> List of character vectors: IDs of texts which originally has the same ID and text but different meta information grouped by their original ID</p>
</td></tr>
<tr><td><code>allTextDups</code></td>
<td>
<p> List of character vectors: IDs of texts which occur twice or more often grouped by text equality</p>
</td></tr>
<tr><td><code>textMetaDups</code></td>
<td>
<p> List of character vectors: IDs of texts which occur twice or more often and have the same meta information grouped by text and meta equality</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>texts &lt;- list(A="Give a Man a Fish, and You Feed Him for a Day.
Teach a Man To Fish, and You Feed Him for a Lifetime",
A="A fake duplicate",
B="So Long, and Thanks for All the Fish",
B="So Long, and Thanks for All the Fish",
C="A very able manipulative mathematician, Fisher enjoys a real mastery
in evaluating complicated multiple integrals.",
C="A very able manipulative mathematician, Fisher enjoys a real mastery
in evaluating complicated multiple integrals.")

corpus &lt;- textmeta(meta=data.frame(id=c("A", "A", "B", "B", "C", "C"),
title=c("Fishing", "Fake duplicate", "Don't panic!", "towel day", "Sir Ronald", "Sir Ronald"),
date=c("1885-01-02", "1885-01-03", "1979-03-04", "1979-03-05", "1951-05-06", "1951-05-06"),
stringsAsFactors=FALSE), text=texts)

duplicates &lt;- deleteAndRenameDuplicates(object=corpus)
duplist(object=duplicates, paragraph = FALSE)
</code></pre>

<hr>
<h2 id='filterCount'>Subcorpus With Count Filter</h2><span id='topic+filterCount'></span><span id='topic+filterCount.default'></span><span id='topic+filterCount.textmeta'></span>

<h3>Description</h3>

<p>Generates a subcorpus by restricting it to texts containing a specific number of words.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filterCount(...)

## Default S3 method:
filterCount(text, count = 1L, out = c("text", "bin", "count"), ...)

## S3 method for class 'textmeta'
filterCount(
  object,
  count = 1L,
  out = c("text", "bin", "count"),
  filtermeta = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filterCount_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="filterCount_+3A_text">text</code></td>
<td>
<p>Not necassary if <code>object</code> is specified, else should be
<code>object$text</code>: list of article texts</p>
</td></tr>
<tr><td><code id="filterCount_+3A_count">count</code></td>
<td>
<p>An integer marking how many words must at least be found in the text.</p>
</td></tr>
<tr><td><code id="filterCount_+3A_out">out</code></td>
<td>
<p>Type of output: <code>text</code> filtered corpus,
<code>bin</code> logical vector for all texts,
<code>count</code> the counts.</p>
</td></tr>
<tr><td><code id="filterCount_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+textmeta">textmeta</a></code> object</p>
</td></tr>
<tr><td><code id="filterCount_+3A_filtermeta">filtermeta</code></td>
<td>
<p>Logical: Should the meta component be filtered, too?</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+textmeta">textmeta</a></code> object if <code>object</code> is specified,
else only the filtered <code>text</code>. If a <code><a href="#topic+textmeta">textmeta</a></code> object is
returned its meta data are filtered to those texts which appear in the corpus
by default (<code>filtermeta</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>texts &lt;- list(A="Give a Man a Fish, and You Feed Him for a Day.
Teach a Man To Fish, and You Feed Him for a Lifetime",
B="So Long, and Thanks for All the Fish",
C="A very able manipulative mathematician, Fisher enjoys a real mastery
in evaluating complicated multiple integrals.")

filterCount(text=texts, count=10L)
filterCount(text=texts, count=10L, out="bin")
filterCount(text=texts, count=10L, out="count")
</code></pre>

<hr>
<h2 id='filterDate'>Subcorpus With Date Filter</h2><span id='topic+filterDate'></span><span id='topic+filterDate.default'></span><span id='topic+filterDate.textmeta'></span>

<h3>Description</h3>

<p>Generates a subcorpus by restricting it to a specific time window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filterDate(...)

## Default S3 method:
filterDate(
  text,
  meta,
  s.date = min(meta$date, na.rm = TRUE),
  e.date = max(meta$date, na.rm = TRUE),
  ...
)

## S3 method for class 'textmeta'
filterDate(
  object,
  s.date = min(object$meta$date, na.rm = TRUE),
  e.date = max(object$meta$date, na.rm = TRUE),
  filtermeta = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filterDate_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="filterDate_+3A_text">text</code></td>
<td>
<p>Not necessary if <code>object</code> is specified, else should be
<code>object$text</code></p>
</td></tr>
<tr><td><code id="filterDate_+3A_meta">meta</code></td>
<td>
<p>Not necessary if <code>object</code> is specified, else should be
<code>object$meta</code></p>
</td></tr>
<tr><td><code id="filterDate_+3A_s.date">s.date</code></td>
<td>
<p>Start date of subcorpus as date object</p>
</td></tr>
<tr><td><code id="filterDate_+3A_e.date">e.date</code></td>
<td>
<p>End date of subcorpus as date object</p>
</td></tr>
<tr><td><code id="filterDate_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+textmeta">textmeta</a></code> object</p>
</td></tr>
<tr><td><code id="filterDate_+3A_filtermeta">filtermeta</code></td>
<td>
<p>Logical: Should the meta component be filtered, too?</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+textmeta">textmeta</a></code> object if <code>object</code> is specified,
else only the filtered <code>text</code>. If a <code><a href="#topic+textmeta">textmeta</a></code> object is
returned its meta data are filtered to those texts which appear in the corpus
by default (<code>filtermeta</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>texts &lt;- list(A="Give a Man a Fish, and You Feed Him for a Day.
Teach a Man To Fish, and You Feed Him for a Lifetime",
B="So Long, and Thanks for All the Fish",
C="A very able manipulative mathematician, Fisher enjoys a real mastery
in evaluating complicated multiple integrals.")

corpus &lt;- textmeta(meta=data.frame(id=c("A", "B", "C", "D"),
title=c("Fishing", "Don't panic!", "Sir Ronald", "Berlin"),
date=c("1885-01-02", "1979-03-04", "1951-05-06", "1967-06-02"),
additionalVariable=1:4, stringsAsFactors=FALSE), text=texts)

subcorpus &lt;- filterDate(object=corpus, s.date = "1951-05-06")
subcorpus$meta
subcorpus$text
</code></pre>

<hr>
<h2 id='filterID'>Subcorpus With ID Filter</h2><span id='topic+filterID'></span><span id='topic+filterID.default'></span><span id='topic+filterID.textmeta'></span>

<h3>Description</h3>

<p>Generates a subcorpus by restricting it to specific ids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filterID(...)

## Default S3 method:
filterID(text, id, ...)

## S3 method for class 'textmeta'
filterID(object, id, filtermeta = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filterID_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="filterID_+3A_text">text</code></td>
<td>
<p>Not necassary if <code>object</code> is specified, else should be
<code>object$text</code>: list of article texts</p>
</td></tr>
<tr><td><code id="filterID_+3A_id">id</code></td>
<td>
<p>Character: IDs the corpus should be filtered to.</p>
</td></tr>
<tr><td><code id="filterID_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+textmeta">textmeta</a></code> object</p>
</td></tr>
<tr><td><code id="filterID_+3A_filtermeta">filtermeta</code></td>
<td>
<p>Logical: Should the meta component be filtered, too?</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+textmeta">textmeta</a></code> object if <code>object</code> is specified,
else only the filtered <code>text</code>. If a <code><a href="#topic+textmeta">textmeta</a></code> object is
returned its meta data are filtered to those texts which appear in the corpus
by default (<code>filtermeta</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>texts &lt;- list(A="Give a Man a Fish, and You Feed Him for a Day.
Teach a Man To Fish, and You Feed Him for a Lifetime",
B="So Long, and Thanks for All the Fish",
C="A very able manipulative mathematician, Fisher enjoys a real mastery
in evaluating complicated multiple integrals.")

meta &lt;- data.frame(id = c("C", "B"), date = NA, title = c("Fisher", "Fish"),
stringsAsFactors = FALSE)
tm &lt;- textmeta(text = texts, meta = meta)

filterID(texts, c("A", "B"))
filterID(texts, "C")
filterID(tm, "C")
filterID(tm, "B")
filterID(tm, c("B", "A"), FALSE)
</code></pre>

<hr>
<h2 id='filterWord'>Subcorpus With Word Filter</h2><span id='topic+filterWord'></span><span id='topic+filterWord.default'></span><span id='topic+filterWord.textmeta'></span>

<h3>Description</h3>

<p>Generates a subcorpus by restricting it to texts containing specific filter words.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filterWord(...)

## Default S3 method:
filterWord(
  text,
  search,
  ignore.case = FALSE,
  out = c("text", "bin", "count"),
  ...
)

## S3 method for class 'textmeta'
filterWord(
  object,
  search,
  ignore.case = FALSE,
  out = c("text", "bin", "count"),
  filtermeta = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filterWord_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="filterWord_+3A_text">text</code></td>
<td>
<p>Not necessary if <code>object</code> is specified, else should be
<code>object$text</code>: list of article texts.</p>
</td></tr>
<tr><td><code id="filterWord_+3A_search">search</code></td>
<td>
<p>List of data frames. Every List element is an 'or'
link, every entry in a data frame is linked by an 'and'. The dataframe must have following tree variables: <code>pattern</code> a character string including the search terms, <code>word</code>, a logical value displaying if a word (TRUE) or character (search) is wanted and <code>count</code> an integer marking how many times the word must at least be found in the text. <code>word</code> can alternatively be a character string containing the keywords <code>pattern</code> for character search, <code>word</code> for word-search and <code>left</code> and <code>right</code> for truncated search.
If <code>search</code> is only a character Vector the link is 'or', and a character search will be used with <code>count=1</code></p>
</td></tr>
<tr><td><code id="filterWord_+3A_ignore.case">ignore.case</code></td>
<td>
<p>Logical: Lower and upper case will be ignored.</p>
</td></tr>
<tr><td><code id="filterWord_+3A_out">out</code></td>
<td>
<p>Type of output: <code>text</code> filtered corpus, <code>bin</code> logical vector for all texts, <code>count</code> the number of matches.</p>
</td></tr>
<tr><td><code id="filterWord_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+textmeta">textmeta</a></code> object</p>
</td></tr>
<tr><td><code id="filterWord_+3A_filtermeta">filtermeta</code></td>
<td>
<p>Logical: Should the meta component be filtered, too?</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+textmeta">textmeta</a></code> object if <code>object</code> is specified,
else only the filtered <code>text</code>. If a <code><a href="#topic+textmeta">textmeta</a></code> object is
returned its meta data are filtered to those texts which appear in the corpus
by default (<code>filtermeta</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>texts &lt;- list(A="Give a Man a Fish, and You Feed Him for a Day.
Teach a Man To Fish, and You Feed Him for a Lifetime",
B="So Long, and Thanks for All the Fish",
C="A very able manipulative mathematician, Fisher enjoys a real mastery
in evaluating complicated multiple integrals.")

# search for pattern "fish"
filterWord(text=texts, search="fish", ignore.case=TRUE)

# search for word "fish"
filterWord(text=texts, search=data.frame(pattern="fish", word="word", count=1),
ignore.case=TRUE)

# pattern must appear at least two times
filterWord(text=texts, search=data.frame(pattern="fish", word="pattern", count=2),
ignore.case=TRUE)

# search for "fish" AND "day"
filterWord(text=texts, search=data.frame(pattern=c("fish", "day"), word="word", count=1),
ignore.case=TRUE)

# search for "Thanks" OR "integrals"
filterWord(text=texts, search=list(data.frame(pattern="Thanks", word="word", count=1),
data.frame(pattern="integrals", word="word", count=1)))

</code></pre>

<hr>
<h2 id='intruderTopics'>Function to validate the fit of the LDA model</h2><span id='topic+intruderTopics'></span>

<h3>Description</h3>

<p>This function validates a LDA result by presenting a mix of topics and intruder topics to a human user, who has to identity them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intruderTopics(
  text = NULL,
  beta = NULL,
  theta = NULL,
  id = NULL,
  numIntruder = 1,
  numOuttopics = 4,
  byScore = TRUE,
  minWords = 0L,
  minOuttopics = 0L,
  stopTopics = NULL,
  printSolution = FALSE,
  oldResult = NULL,
  test = FALSE,
  testinput = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intruderTopics_+3A_text">text</code></td>
<td>
<p>A list of texts (e.g. the text element of a <code><a href="#topic+textmeta">textmeta</a></code> object).</p>
</td></tr>
<tr><td><code id="intruderTopics_+3A_beta">beta</code></td>
<td>
<p>A matrix of word-probabilities or frequency table for the topics (e.g. the <code>topics</code> matrix from the <code><a href="#topic+LDAgen">LDAgen</a></code> result). Each row is a topic, each column a word. The rows will be divided by the row sums, if they are not 1.</p>
</td></tr>
<tr><td><code id="intruderTopics_+3A_theta">theta</code></td>
<td>
<p>A matrix of wordcounts per text and topic (e.g. the <code>document_sums</code> matrix from the <code><a href="#topic+LDAgen">LDAgen</a></code> result). Each row is a topic, each column a text. In each cell stands the number of words in text j belonging to topic i.</p>
</td></tr>
<tr><td><code id="intruderTopics_+3A_id">id</code></td>
<td>
<p>Optional: character vector of text IDs that should be used for the function. Useful to start a inchoate coding task.</p>
</td></tr>
<tr><td><code id="intruderTopics_+3A_numintruder">numIntruder</code></td>
<td>
<p>Intended number of intruder words. If <code>numIntruder</code> is a integer vector, the number would be sampled for each topic.</p>
</td></tr>
<tr><td><code id="intruderTopics_+3A_numouttopics">numOuttopics</code></td>
<td>
<p>tba Integer: Number of words per topic, including the intruder words</p>
</td></tr>
<tr><td><code id="intruderTopics_+3A_byscore">byScore</code></td>
<td>
<p>Logical: Should the score of <code>top.topic.words</code> from the <code>lda</code> package be used?</p>
</td></tr>
<tr><td><code id="intruderTopics_+3A_minwords">minWords</code></td>
<td>
<p>Integer: Minimum number of words for a choosen text.</p>
</td></tr>
<tr><td><code id="intruderTopics_+3A_minouttopics">minOuttopics</code></td>
<td>
<p>Integer: Minimal number of words a topic needs to be classified as a possible correct Topic.</p>
</td></tr>
<tr><td><code id="intruderTopics_+3A_stoptopics">stopTopics</code></td>
<td>
<p>Optional: Integer vector to deselect stopword topics for the coding task.</p>
</td></tr>
<tr><td><code id="intruderTopics_+3A_printsolution">printSolution</code></td>
<td>
<p>Logical: If <code>TRUE</code> the coder gets a feedback after his/her vote.</p>
</td></tr>
<tr><td><code id="intruderTopics_+3A_oldresult">oldResult</code></td>
<td>
<p>Result object from an unfinished run of <code>intruderWords</code>. If oldResult is used, all other parameter will be ignored.</p>
</td></tr>
<tr><td><code id="intruderTopics_+3A_test">test</code></td>
<td>
<p>Logical: Enables test mode</p>
</td></tr>
<tr><td><code id="intruderTopics_+3A_testinput">testinput</code></td>
<td>
<p>Input for function tests</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>IntruderTopics</code>. List of 11
</p>
<table>
<tr><td><code>result</code></td>
<td>
<p>Matrix of 3 columns. Each row represents one labeled text. <code>numIntruder</code> (1. column) gives the number of intruder topics inputated in this text, <code>missIntruder</code> (2. column) the number of the intruder topics which were not found by the coder and <code>falseIntruder</code> (3. column) the number of the topics choosen by the coder which were no intruder.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>Parameter of the function call</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>Parameter of the function call</p>
</td></tr>
<tr><td><code>id</code></td>
<td>
<p>Charater Vector of IDs at the beginning</p>
</td></tr>
<tr><td><code>byScore</code></td>
<td>
<p>Parameter of the function call</p>
</td></tr>
<tr><td><code>numIntruder</code></td>
<td>
<p>Parameter of the function call</p>
</td></tr>
<tr><td><code>numOuttopics</code></td>
<td>
<p>Parameter of the function call</p>
</td></tr>
<tr><td><code>minWords</code></td>
<td>
<p>Parameter of the function call</p>
</td></tr>
<tr><td><code>minOuttopics</code></td>
<td>
<p>Parameter of the function call</p>
</td></tr>
<tr><td><code>unusedID</code></td>
<td>
<p>Character vector of unused text IDs for the next run</p>
</td></tr>
<tr><td><code>stopTopics</code></td>
<td>
<p>Parameter of the function call</p>
</td></tr>
</table>


<h3>References</h3>

<p>Chang, Jonathan and Sean Gerrish and Wang, Chong and Jordan L. Boyd-graber and David M. Blei. Reading Tea Leaves: How Humans Interpret Topic Models. Advances in Neural Information Processing Systems, 2009.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(politics)
poliClean &lt;- cleanTexts(politics)
words10 &lt;- makeWordlist(text=poliClean$text)
words10 &lt;- words10$words[words10$wordtable &gt; 10]
poliLDA &lt;- LDAprep(text=poliClean$text, vocab=words10)
LDAresult &lt;- LDAgen(documents=poliLDA, K=10, vocab=words10)
intruder &lt;- intruderTopics(text=politics$text, beta=LDAresult$topics,
                           theta=LDAresult$document_sums, id=names(poliLDA))

## End(Not run)
</code></pre>

<hr>
<h2 id='intruderWords'>Function to validate the fit of the LDA model</h2><span id='topic+intruderWords'></span>

<h3>Description</h3>

<p>This function validates a LDA result by presenting a mix of words from a topic and intruder words to a human user, who has to identity them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intruderWords(
  beta = NULL,
  byScore = TRUE,
  numTopwords = 30L,
  numIntruder = 1L,
  numOutwords = 5L,
  noTopic = TRUE,
  printSolution = FALSE,
  oldResult = NULL,
  test = FALSE,
  testinput = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intruderWords_+3A_beta">beta</code></td>
<td>
<p>A matrix of word-probabilities or frequency table for the topics (e.g. the <code>topics</code> matrix from the <code><a href="#topic+LDAgen">LDAgen</a></code> result). Each row is a topic, each column a word. The rows will be divided by the row sums, if they are not 1.</p>
</td></tr>
<tr><td><code id="intruderWords_+3A_byscore">byScore</code></td>
<td>
<p>Logical: Should the score of <code>top.topic.words</code> from the <code>lda</code> package be used?</p>
</td></tr>
<tr><td><code id="intruderWords_+3A_numtopwords">numTopwords</code></td>
<td>
<p>The number of topwords to be used for the intruder words</p>
</td></tr>
<tr><td><code id="intruderWords_+3A_numintruder">numIntruder</code></td>
<td>
<p>Intended number of intruder words. If <code>numIntruder</code> is a integer vector, the number would be sampled for each topic.</p>
</td></tr>
<tr><td><code id="intruderWords_+3A_numoutwords">numOutwords</code></td>
<td>
<p>Integer: Number of words per topic, including the intruder words.</p>
</td></tr>
<tr><td><code id="intruderWords_+3A_notopic">noTopic</code></td>
<td>
<p>Logical: Is <code>x</code> input allowed to mark nonsense topics?</p>
</td></tr>
<tr><td><code id="intruderWords_+3A_printsolution">printSolution</code></td>
<td>
<p>tba</p>
</td></tr>
<tr><td><code id="intruderWords_+3A_oldresult">oldResult</code></td>
<td>
<p>Result object from an unfinished run of <code>intruderWords</code>. If oldResult is used, all other parameter will be ignored.</p>
</td></tr>
<tr><td><code id="intruderWords_+3A_test">test</code></td>
<td>
<p>Logical: Enables test mode</p>
</td></tr>
<tr><td><code id="intruderWords_+3A_testinput">testinput</code></td>
<td>
<p>Input for function tests</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>IntruderWords</code>. List of 7
</p>
<table>
<tr><td><code>result</code></td>
<td>
<p>Matrix of 3 columns. Each row represents one topic. All values are 0 if the topic did not run before. <code>numIntruder</code> (1. column) gives the number of intruder words inputated in this topic, <code>missIntruder</code> (2. column) the number of the intruder words which were not found by the coder and <code>falseIntruder</code> (3. column) the number of the words choosen by the coder which were no intruder.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>Parameter of the function call</p>
</td></tr>
<tr><td><code>byScore</code></td>
<td>
<p>Parameter of the function call</p>
</td></tr>
<tr><td><code>numTopwords</code></td>
<td>
<p>Parameter of the function call</p>
</td></tr>
<tr><td><code>numIntruder</code></td>
<td>
<p>Parameter of the function call</p>
</td></tr>
<tr><td><code>numOutwords</code></td>
<td>
<p>Parameter of the function call</p>
</td></tr>
<tr><td><code>noTopic</code></td>
<td>
<p>Parameter of the function call</p>
</td></tr>
</table>


<h3>References</h3>

<p>Chang, Jonathan and Sean Gerrish and Wang, Chong and Jordan L. Boyd-graber and David M. Blei. Reading Tea Leaves: How Humans Interpret Topic Models. Advances in Neural Information Processing Systems, 2009.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(politics)
poliClean &lt;- cleanTexts(politics)
words10 &lt;- makeWordlist(text=poliClean$text)
words10 &lt;- words10$words[words10$wordtable &gt; 10]
poliLDA &lt;- LDAprep(text=poliClean$text, vocab=words10)
LDAresult &lt;- LDAgen(documents=poliLDA, K=10, vocab=words10)
intruder &lt;- intruderWords(beta=LDAresult$topics)
## End(Not run)
</code></pre>

<hr>
<h2 id='LDAgen'>Function to fit LDA model</h2><span id='topic+LDAgen'></span>

<h3>Description</h3>

<p>This function uses the <code><a href="lda.html#topic+lda.collapsed.gibbs.sampler">lda.collapsed.gibbs.sampler</a></code> from the lda-
package and additionally saves topword lists and a R workspace.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LDAgen(
  documents,
  K = 100L,
  vocab,
  num.iterations = 200L,
  burnin = 70L,
  alpha = NULL,
  eta = NULL,
  seed = NULL,
  folder = file.path(tempdir(), "lda-result"),
  num.words = 50L,
  LDA = TRUE,
  count = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LDAgen_+3A_documents">documents</code></td>
<td>
<p>A list prepared by <code><a href="#topic+LDAprep">LDAprep</a></code>.</p>
</td></tr>
<tr><td><code id="LDAgen_+3A_k">K</code></td>
<td>
<p>Number of topics</p>
</td></tr>
<tr><td><code id="LDAgen_+3A_vocab">vocab</code></td>
<td>
<p>Character vector containing the words in the corpus</p>
</td></tr>
<tr><td><code id="LDAgen_+3A_num.iterations">num.iterations</code></td>
<td>
<p>Number of iterations for the gibbs sampler</p>
</td></tr>
<tr><td><code id="LDAgen_+3A_burnin">burnin</code></td>
<td>
<p>Number of iterations for the burnin</p>
</td></tr>
<tr><td><code id="LDAgen_+3A_alpha">alpha</code></td>
<td>
<p>Hyperparameter for the topic proportions</p>
</td></tr>
<tr><td><code id="LDAgen_+3A_eta">eta</code></td>
<td>
<p>Hyperparameter for the word distributions</p>
</td></tr>
<tr><td><code id="LDAgen_+3A_seed">seed</code></td>
<td>
<p>A seed for reproducability.</p>
</td></tr>
<tr><td><code id="LDAgen_+3A_folder">folder</code></td>
<td>
<p>File for the results. Saves in the temporary directionary by default.</p>
</td></tr>
<tr><td><code id="LDAgen_+3A_num.words">num.words</code></td>
<td>
<p>Number of words in the top topic words list</p>
</td></tr>
<tr><td><code id="LDAgen_+3A_lda">LDA</code></td>
<td>
<p>logical: Should a new model be fitted or an existing R workspace?</p>
</td></tr>
<tr><td><code id="LDAgen_+3A_count">count</code></td>
<td>
<p>logical: Should article counts calculated
per top topic words be used for output as csv
(default: <code>FALSE</code>)?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A .csv file containing the topword list and a R workspace containing the
result data.
</p>


<h3>References</h3>

<p>Blei, David M. and Ng, Andrew and Jordan, Michael. Latent
Dirichlet allocation. Journal of Machine Learning Research, 2003.
</p>
<p>Jonathan Chang (2012). lda: Collapsed Gibbs sampling methods for topic
models.. R package version 1.3.2. http://CRAN.R-project.org/package=lda
</p>


<h3>See Also</h3>

<p>Documentation for the lda package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>texts &lt;- list(A="Give a Man a Fish, and You Feed Him for a Day.
Teach a Man To Fish, and You Feed Him for a Lifetime",
B="So Long, and Thanks for All the Fish",
C="A very able manipulative mathematician, Fisher enjoys a real mastery
in evaluating complicated multiple integrals.")

corpus &lt;- textmeta(meta=data.frame(id=c("A", "B", "C", "D"),
title=c("Fishing", "Don't panic!", "Sir Ronald", "Berlin"),
date=c("1885-01-02", "1979-03-04", "1951-05-06", "1967-06-02"),
additionalVariable=1:4, stringsAsFactors=FALSE), text=texts)

corpus &lt;- cleanTexts(corpus)
wordlist &lt;- makeWordlist(corpus$text)
ldaPrep &lt;- LDAprep(text=corpus$text, vocab=wordlist$words)

LDAgen(documents=ldaPrep, K = 3L, vocab=wordlist$words, num.words=3)

</code></pre>

<hr>
<h2 id='LDAprep'>Create Lda-ready Dataset</h2><span id='topic+LDAprep'></span>

<h3>Description</h3>

<p>This function transforms a text corpus such as the result of
<code><a href="#topic+cleanTexts">cleanTexts</a></code> into the form needed by the <code><a href="MASS.html#topic+lda">lda</a></code>-package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LDAprep(text, vocab, reduce = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LDAprep_+3A_text">text</code></td>
<td>
<p>A list of tokenized texts</p>
</td></tr>
<tr><td><code id="LDAprep_+3A_vocab">vocab</code></td>
<td>
<p>A character vector containing all words which should beused for
lda</p>
</td></tr>
<tr><td><code id="LDAprep_+3A_reduce">reduce</code></td>
<td>
<p>Logical: Should empty texts be deleted?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list in which every entry contains a matrix with two rows: The
first row gives the number of the entry of the word in <code>vocab</code> minus
one, the second row is 1 and the number of the
occurrence of the word will be shown by the number of columns belonging to
this word.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>texts &lt;- list(A="Give a Man a Fish, and You Feed Him for a Day.
Teach a Man To Fish, and You Feed Him for a Lifetime",
B="So Long, and Thanks for All the Fish",
C="A very able manipulative mathematician, Fisher enjoys a real mastery
in evaluating complicated multiple integrals.")

corpus &lt;- textmeta(meta=data.frame(id=c("A", "B", "C", "D"),
title=c("Fishing", "Don't panic!", "Sir Ronald", "Berlin"),
date=c("1885-01-02", "1979-03-04", "1951-05-06", "1967-06-02"),
additionalVariable=1:4, stringsAsFactors=FALSE), text=texts)

corpus &lt;- cleanTexts(corpus)
wordlist &lt;- makeWordlist(corpus$text)
LDAprep(text=corpus$text, vocab=wordlist$words, reduce = TRUE)

</code></pre>

<hr>
<h2 id='makeWordlist'>Counts Words in Text Corpora</h2><span id='topic+makeWordlist'></span>

<h3>Description</h3>

<p>Creates a wordlist and a frequency table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeWordlist(text, k = 100000L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeWordlist_+3A_text">text</code></td>
<td>
<p>List of texts.</p>
</td></tr>
<tr><td><code id="makeWordlist_+3A_k">k</code></td>
<td>
<p>Integer: How many texts should be processed at once (RAM
usage)?</p>
</td></tr>
<tr><td><code id="makeWordlist_+3A_...">...</code></td>
<td>
<p>further arguments for the sort function. Often you
want to set <code>method = "radix"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function helps, if <code>table(x)</code> needs too much RAM.
</p>


<h3>Value</h3>

<table>
<tr><td><code>words</code></td>
<td>
<p>An alphabetical list of the words in the corpus</p>
</td></tr>
<tr><td><code>wordtable</code></td>
<td>
<p>A frequency table of the words in the corpus</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>texts &lt;- list(A="Give a Man a Fish, and You Feed Him for a Day.
Teach a Man To Fish, and You Feed Him for a Lifetime",
B="So Long, and Thanks for All the Fish",
C="A very able manipulative mathematician, Fisher enjoys a real mastery
in evaluating complicated multiple integrals.")

texts &lt;- cleanTexts(text=texts)
makeWordlist(text=texts, k = 2L)

</code></pre>

<hr>
<h2 id='mergeLDA'>Preparation of Different LDAs For Clustering</h2><span id='topic+mergeLDA'></span>

<h3>Description</h3>

<p>Merges different lda-results to one matrix, including only the words which
appears in all lda-results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeLDA(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeLDA_+3A_x">x</code></td>
<td>
<p>A list of lda results.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is useful for merging lda-results prior to a cluster analysis with <code><a href="#topic+clusterTopics">clusterTopics</a></code>.
</p>


<h3>Value</h3>

<p>A matrix including all topics from all lda-results. The number of rows
is the number of topics, the number of columns is the number of words which
appear in all results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>texts &lt;- list(A="Give a Man a Fish, and You Feed Him for a Day.
Teach a Man To Fish, and You Feed Him for a Lifetime",
B="So Long, and Thanks for All the Fish",
C="A very able manipulative mathematician, Fisher enjoys a real mastery
in evaluating complicated multiple integrals.")

corpus &lt;- textmeta(meta=data.frame(id=c("A", "B", "C", "D"),
title=c("Fishing", "Don't panic!", "Sir Ronald", "Berlin"),
date=c("1885-01-02", "1979-03-04", "1951-05-06", "1967-06-02"),
additionalVariable=1:4, stringsAsFactors=FALSE), text=texts)

corpus &lt;- cleanTexts(corpus)
wordlist &lt;- makeWordlist(corpus$text)
ldaPrep &lt;- LDAprep(text=corpus$text, vocab=wordlist$words)

LDA1 &lt;- LDAgen(documents=ldaPrep, K = 3L, vocab=wordlist$words, num.words=3)
LDA2 &lt;- LDAgen(documents=ldaPrep, K = 3L, vocab=wordlist$words, num.words=3)
mergeLDA(list(LDA1=LDA1, LDA2=LDA2))
</code></pre>

<hr>
<h2 id='mergeTextmeta'>Merge Textmeta Objects</h2><span id='topic+mergeTextmeta'></span>

<h3>Description</h3>

<p>Merges a list of textmeta objects to a single object. It is possible to control whether all
columns or the intersect should be considered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeTextmeta(x, all = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeTextmeta_+3A_x">x</code></td>
<td>
<p>A list of <code><a href="#topic+textmeta">textmeta</a></code> objects</p>
</td></tr>
<tr><td><code id="mergeTextmeta_+3A_all">all</code></td>
<td>
<p>Logical: Should the result contain
<code><a href="base.html#topic+union">union</a></code> (<code>TRUE</code>) or <code><a href="base.html#topic+intersection">intersection</a></code> (<code>FALSE</code>) of columns of
all objects? If <code>TRUE</code>, the columns which at least appear in one of
the meta components are filled with <code>NA</code>s in the merged meta component.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+textmeta">textmeta</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>texts &lt;- list(A="Give a Man a Fish, and You Feed Him for a Day.
Teach a Man To Fish, and You Feed Him for a Lifetime",
B="So Long, and Thanks for All the Fish",
C="A very able manipulative mathematician, Fisher enjoys a real mastery
in evaluating complicated multiple integrals.")

corpus &lt;- textmeta(meta=data.frame(id=c("A", "B", "C", "D"),
title=c("Fishing", "Don't panic!", "Sir Ronald", "Berlin"),
date=c("1885-01-02", "1979-03-04", "1951-05-06", "1967-06-02"),
additionalVariable=1:4, stringsAsFactors=FALSE), text=texts)

corpus2 &lt;- textmeta(meta=data.frame(id=c("E", "F"),
title=c("title1", "title2"),
date=c("2018-01-01", "2018-01-01"),
additionalVariable2=1:2, stringsAsFactors=FALSE), text=list(E="text1", F="text2"))

merged &lt;- mergeTextmeta(x=list(corpus, corpus2), all = TRUE)
str(merged$meta)

merged &lt;- mergeTextmeta(x=list(corpus, corpus2), all = FALSE)
str(merged$meta)
</code></pre>

<hr>
<h2 id='plotArea'>Plotting topics over time as stacked areas below plotted lines.</h2><span id='topic+plotArea'></span>

<h3>Description</h3>

<p>Creates a stacked area plot of all or selected topics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotArea(
  ldaresult,
  ldaID,
  select = NULL,
  tnames = NULL,
  threshold = NULL,
  meta,
  unit = "quarter",
  xunit = "year",
  color = NULL,
  sort = TRUE,
  legend = NULL,
  legendLimit = 0,
  peak = 0,
  file
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotArea_+3A_ldaresult">ldaresult</code></td>
<td>
<p>LDA result object</p>
</td></tr>
<tr><td><code id="plotArea_+3A_ldaid">ldaID</code></td>
<td>
<p>Character vector including IDs of the texts</p>
</td></tr>
<tr><td><code id="plotArea_+3A_select">select</code></td>
<td>
<p>Selects all topics if parameter is null. Otherwise vector of integers or topic label. Only topics belonging to that numbers, and labels respectively would be plotted.</p>
</td></tr>
<tr><td><code id="plotArea_+3A_tnames">tnames</code></td>
<td>
<p>Character vector of topic labels. It must have same length than number of topics in the model.</p>
</td></tr>
<tr><td><code id="plotArea_+3A_threshold">threshold</code></td>
<td>
<p>Numeric: Treshold between 0 and 1. Topics would only be used if at least one time unit exist with a topic proportion above the treshold</p>
</td></tr>
<tr><td><code id="plotArea_+3A_meta">meta</code></td>
<td>
<p>The meta data for the texts or a date-string.</p>
</td></tr>
<tr><td><code id="plotArea_+3A_unit">unit</code></td>
<td>
<p>Time unit for x-axis. Possible units are <code>"bimonth"</code>, <code>"quarter"</code>, <code>"season"</code>,
<code>"halfyear"</code>, <code>"year"</code>, for more units see <code><a href="lubridate.html#topic+round_date">round_date</a></code></p>
</td></tr>
<tr><td><code id="plotArea_+3A_xunit">xunit</code></td>
<td>
<p>Time unit for tiks on the x-axis. For possible units see <code><a href="lubridate.html#topic+round_date">round_date</a></code></p>
</td></tr>
<tr><td><code id="plotArea_+3A_color">color</code></td>
<td>
<p>Color vector. Color vector would be replicated if the number of plotted topics is bigger than length of the vector.</p>
</td></tr>
<tr><td><code id="plotArea_+3A_sort">sort</code></td>
<td>
<p>Logical: Should the topics be sorted by topic proportion?</p>
</td></tr>
<tr><td><code id="plotArea_+3A_legend">legend</code></td>
<td>
<p>Position of legend. If <code>NULL</code> (default), no legend will be plotted</p>
</td></tr>
<tr><td><code id="plotArea_+3A_legendlimit">legendLimit</code></td>
<td>
<p>Numeric between 0 (default) and 1. Only Topics with proportions above this limit appear in the legend.</p>
</td></tr>
<tr><td><code id="plotArea_+3A_peak">peak</code></td>
<td>
<p>Numeric between 0 (default) and 1. Label peaks above <code>peak</code>. For each Topic every area which are at least once above <code>peak</code> will e labeled. An area ends if the topic proportion is under 1 percent.</p>
</td></tr>
<tr><td><code id="plotArea_+3A_file">file</code></td>
<td>
<p>Character: File path if a pdf should be created</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is useful to visualize the volume of topics and to show trends over time.
</p>


<h3>Value</h3>

<p>List of two matrices. <code>rel</code> contains the topic proportions over time, <code>relcum</code> contains the cumulated topic proportions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(politics)
poliClean &lt;- cleanTexts(politics)
words10 &lt;- makeWordlist(text=poliClean$text)
words10 &lt;- words10$words[words10$wordtable &gt; 10]
poliLDA &lt;- LDAprep(text=poliClean$text, vocab=words10)
LDAresult &lt;- LDAgen(documents=poliLDA, K=10, vocab=words10)
plotArea(ldaresult=LDAresult, ldaID=names(poliLDA), meta=politics$meta)

plotArea(ldaresult=LDAresult, ldaID=names(poliLDA), meta=politics$meta, select=c(1,3,5))

## End(Not run)
</code></pre>

<hr>
<h2 id='plotFreq'>Plotting Counts of specified Wordgroups over Time (relative to Corpus)</h2><span id='topic+plotFreq'></span>

<h3>Description</h3>

<p>Creates a plot of the counts/proportion of given wordgroups (<code>wordlist</code>)
in the subcorpus. The counts/proportion can be calculated on document or word
level - with an 'and' or 'or' link - and additionally can be normalised by
a subcorporus, which could be specified by <code>id</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotFreq(
  object,
  id = names(object$text),
  type = c("docs", "words"),
  wordlist,
  link = c("and", "or"),
  wnames,
  ignore.case = FALSE,
  rel = FALSE,
  mark = TRUE,
  unit = "month",
  curves = c("exact", "smooth", "both"),
  smooth = 0.05,
  both.lwd,
  both.lty,
  main,
  xlab,
  ylab,
  ylim,
  col,
  legend = "topright",
  natozero = TRUE,
  file,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotFreq_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+textmeta">textmeta</a></code> object with strictly tokenized
<code>text</code> component (<code>character</code> vectors) - like a result of
<code><a href="#topic+cleanTexts">cleanTexts</a></code></p>
</td></tr>
<tr><td><code id="plotFreq_+3A_id">id</code></td>
<td>
<p><code>character</code> vector (default: <code>object$meta$id</code>) which IDs
specify the subcorpus</p>
</td></tr>
<tr><td><code id="plotFreq_+3A_type">type</code></td>
<td>
<p><code>character</code> (default: <code>"docs"</code>) should counts/proportion
of documents, where every  <code>"docs"</code> or words <code>"words"</code> be plotted</p>
</td></tr>
<tr><td><code id="plotFreq_+3A_wordlist">wordlist</code></td>
<td>
<p>list of <code>character</code> vectors. Every list element is an 'or'
link, every <code>character</code> string in a vector is linked by the argument
<code>link</code>. If <code>wordlist</code> is only a <code>character</code> vector it will be
coerced to a list of the same length as the vector (see <code><a href="base.html#topic+as.list">as.list</a></code>),
so that the argument <code>link</code> has no effect. Each <code>character</code> vector
as a list element represents one curve in the outcoming plot</p>
</td></tr>
<tr><td><code id="plotFreq_+3A_link">link</code></td>
<td>
<p><code>character</code> (default: <code>"and"</code>) should the (inner)
<code>character</code> vectors of each list element be linked by an <code>"and"</code>
or an <code>"or"</code></p>
</td></tr>
<tr><td><code id="plotFreq_+3A_wnames">wnames</code></td>
<td>
<p><code>character</code> vector of same length as <code>wordlist</code>
- labels for every group of 'and' linked words</p>
</td></tr>
<tr><td><code id="plotFreq_+3A_ignore.case">ignore.case</code></td>
<td>
<p><code>logical</code> (default: <code>FALSE</code>) option
from <code><a href="base.html#topic+grepl">grepl</a></code>.</p>
</td></tr>
<tr><td><code id="plotFreq_+3A_rel">rel</code></td>
<td>
<p><code>logical</code> (default: <code>FALSE</code>) should counts
(<code>FALSE</code>) or proportion (<code>TRUE</code>) be plotted</p>
</td></tr>
<tr><td><code id="plotFreq_+3A_mark">mark</code></td>
<td>
<p><code>logical</code> (default: <code>TRUE</code>) should years be marked by
vertical lines</p>
</td></tr>
<tr><td><code id="plotFreq_+3A_unit">unit</code></td>
<td>
<p><code>character</code> (default: <code>"month"</code>) to which unit should
dates be floored. Other possible units are <code>"bimonth"</code>, <code>"quarter"</code>, <code>"season"</code>,
<code>"halfyear"</code>, <code>"year"</code>, for more units see <code><a href="lubridate.html#topic+round_date">round_date</a></code></p>
</td></tr>
<tr><td><code id="plotFreq_+3A_curves">curves</code></td>
<td>
<p><code>character</code> (default: <code>"exact"</code>) should <code>"exact"</code>,
<code>"smooth"</code> curve or <code>"both"</code> be plotted</p>
</td></tr>
<tr><td><code id="plotFreq_+3A_smooth">smooth</code></td>
<td>
<p><code>numeric</code> (default: <code>0.05</code>) smoothing parameter
which is handed over to <code><a href="stats.html#topic+lowess">lowess</a></code> as <code>f</code></p>
</td></tr>
<tr><td><code id="plotFreq_+3A_both.lwd">both.lwd</code></td>
<td>
<p>graphical parameter for smoothed values
if <code>curves = "both"</code></p>
</td></tr>
<tr><td><code id="plotFreq_+3A_both.lty">both.lty</code></td>
<td>
<p>graphical parameter for smoothed values
if <code>curves = "both"</code></p>
</td></tr>
<tr><td><code id="plotFreq_+3A_main">main</code></td>
<td>
<p><code>character</code> graphical parameter</p>
</td></tr>
<tr><td><code id="plotFreq_+3A_xlab">xlab</code></td>
<td>
<p><code>character</code> graphical parameter</p>
</td></tr>
<tr><td><code id="plotFreq_+3A_ylab">ylab</code></td>
<td>
<p><code>character</code> graphical parameter</p>
</td></tr>
<tr><td><code id="plotFreq_+3A_ylim">ylim</code></td>
<td>
<p>(default if <code>rel = TRUE</code>: <code>c(0, 1)</code>) graphical parameter</p>
</td></tr>
<tr><td><code id="plotFreq_+3A_col">col</code></td>
<td>
<p>graphical parameter, could be a vector. If <code>curves = "both"</code>
the function will for every wordgroup plot at first the exact and then the
smoothed curve - this is important for your col order.</p>
</td></tr>
<tr><td><code id="plotFreq_+3A_legend">legend</code></td>
<td>
<p><code>character</code> (default: &quot;topright&quot;) value(s) to specify the
legend coordinates. If &quot;none&quot; no legend is plotted.</p>
</td></tr>
<tr><td><code id="plotFreq_+3A_natozero">natozero</code></td>
<td>
<p><code>logical</code> (default: <code>TRUE</code>) should NAs be coerced
to zeros. Only has effect if <code>rel = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotFreq_+3A_file">file</code></td>
<td>
<p><code>character</code> file path if a pdf should be created</p>
</td></tr>
<tr><td><code id="plotFreq_+3A_...">...</code></td>
<td>
<p>additional graphical parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot.
Invisible: A dataframe with columns <code>date</code> and <code>wnames</code> - and
additionally columns <code>wnames_rel</code> for <code>rel = TRUE</code> - with the
counts (and proportion) of the given wordgroups.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(politics)
poliClean &lt;- cleanTexts(politics)
plotFreq(poliClean, wordlist=c("obama", "bush"))

## End(Not run)
</code></pre>

<hr>
<h2 id='plotHeat'>Plotting Topics over Time relative to Corpus</h2><span id='topic+plotHeat'></span>

<h3>Description</h3>

<p>Creates a pdf showing a heat map. For each topic, the heat map shows the deviation of
its current share from its mean share. Shares can be calculated on corpus level or on subcorpus level concerning LDA vocabulary.
Shares can be calculated in absolute deviation from the mean or relative to the mean of the topic to account for different topic strengths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotHeat(
  object,
  ldaresult,
  ldaID,
  select = 1:nrow(ldaresult$document_sums),
  tnames,
  norm = FALSE,
  file,
  unit = "year",
  date_breaks = 1,
  margins = c(5, 0),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotHeat_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+textmeta">textmeta</a></code> object with strictly tokenized <code>text</code>
component (calculation of proportion on document lengths) or
<code><a href="#topic+textmeta">textmeta</a></code> object which contains only the <code>meta</code> component
(calculation of proportion on count of words out of the LDA vocabulary in each
document)</p>
</td></tr>
<tr><td><code id="plotHeat_+3A_ldaresult">ldaresult</code></td>
<td>
<p>LDA result object.</p>
</td></tr>
<tr><td><code id="plotHeat_+3A_ldaid">ldaID</code></td>
<td>
<p>Character vector containing IDs of the texts.</p>
</td></tr>
<tr><td><code id="plotHeat_+3A_select">select</code></td>
<td>
<p>Numeric vector containing the numbers of the topics to be plotted. Defaults to all topics.</p>
</td></tr>
<tr><td><code id="plotHeat_+3A_tnames">tnames</code></td>
<td>
<p>Character vector with labels for the topics.</p>
</td></tr>
<tr><td><code id="plotHeat_+3A_norm">norm</code></td>
<td>
<p>Logical: Should the values be normalized by the mean topic share to account for differently sized topics (default: <code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="plotHeat_+3A_file">file</code></td>
<td>
<p>Character vector containing the path and name for the pdf output file.</p>
</td></tr>
<tr><td><code id="plotHeat_+3A_unit">unit</code></td>
<td>
<p>Character:  To which unit should dates be floored (default: <code>"year"</code>)?
Other possible units are <code>"bimonth"</code>, <code>"quarter"</code>, <code>"season"</code>,
<code>"halfyear"</code>, <code>"year"</code>, for more units see <code><a href="lubridate.html#topic+round_date">round_date</a></code></p>
</td></tr>
<tr><td><code id="plotHeat_+3A_date_breaks">date_breaks</code></td>
<td>
<p>How many labels should be shown on the x axis (default: <code>1</code>)?
If <code>data_breaks</code> is <code>5</code> every fifth label is drawn.</p>
</td></tr>
<tr><td><code id="plotHeat_+3A_margins">margins</code></td>
<td>
<p>See <code><a href="stats.html#topic+heatmap">heatmap</a></code></p>
</td></tr>
<tr><td><code id="plotHeat_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters passed to <code><a href="stats.html#topic+heatmap">heatmap</a></code>,
for example <code>distfun</code> or <code>hclustfun</code>.
details The function is useful to search for peaks in the coverage of topics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A pdf.
Invisible: A dataframe.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(politics)
poliClean &lt;- cleanTexts(politics)
words10 &lt;- makeWordlist(text=poliClean$text)
words10 &lt;- words10$words[words10$wordtable &gt; 10]
poliLDA &lt;- LDAprep(text=poliClean$text, vocab=words10)
LDAresult &lt;- LDAgen(documents=poliLDA, K=10, vocab=words10)
plotHeat(object=poliClean, ldaresult=LDAresult, ldaID=names(poliLDA))

## End(Not run)
</code></pre>

<hr>
<h2 id='plotScot'>Plots Counts of Documents or Words over Time (relative to Corpus)</h2><span id='topic+plotScot'></span>

<h3>Description</h3>

<p>Creates a plot of the counts/proportion of documents/words in the subcorpus,
which could be specified by <code>id</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotScot(
  object,
  id = object$meta$id,
  type = c("docs", "words"),
  rel = FALSE,
  mark = TRUE,
  unit = "month",
  curves = c("exact", "smooth", "both"),
  smooth = 0.05,
  main,
  xlab,
  ylab,
  ylim,
  both.lwd,
  both.col,
  both.lty,
  natozero = TRUE,
  file,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotScot_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+textmeta">textmeta</a></code> object with strictly tokenized
<code>text</code> component vectors if <code>type = "words"</code></p>
</td></tr>
<tr><td><code id="plotScot_+3A_id">id</code></td>
<td>
<p>Character: Vector (default: <code>object$meta$id</code>) which IDs
specify the subcorpus</p>
</td></tr>
<tr><td><code id="plotScot_+3A_type">type</code></td>
<td>
<p>Character: Should counts/proportion
of documents <code>"docs"</code> (default) or words <code>"words"</code> be plotted?</p>
</td></tr>
<tr><td><code id="plotScot_+3A_rel">rel</code></td>
<td>
<p>Logical: Should counts
(default: <code>FALSE</code>) or proportion (<code>TRUE</code>) be plotted?</p>
</td></tr>
<tr><td><code id="plotScot_+3A_mark">mark</code></td>
<td>
<p>Logical: Should years be marked by
vertical lines (default: <code>TRUE</code>)?</p>
</td></tr>
<tr><td><code id="plotScot_+3A_unit">unit</code></td>
<td>
<p>Character: To which unit should
dates be floored (default: <code>"month"</code>). Other possible units are <code>"bimonth"</code>, <code>"quarter"</code>, <code>"season"</code>,
<code>"halfyear"</code>, <code>"year"</code>, for more units see <code><a href="lubridate.html#topic+round_date">round_date</a></code>.</p>
</td></tr>
<tr><td><code id="plotScot_+3A_curves">curves</code></td>
<td>
<p>Character: Should <code>"exact"</code>,
<code>"smooth"</code> curve or <code>"both"</code> be plotted (default: <code>"exact"</code>)?</p>
</td></tr>
<tr><td><code id="plotScot_+3A_smooth">smooth</code></td>
<td>
<p>Numeric: Smoothing parameter
which is handed over to <code><a href="stats.html#topic+lowess">lowess</a></code> as <code>f</code> (default: <code>0.05</code>).</p>
</td></tr>
<tr><td><code id="plotScot_+3A_main">main</code></td>
<td>
<p>Character: Graphical parameter</p>
</td></tr>
<tr><td><code id="plotScot_+3A_xlab">xlab</code></td>
<td>
<p>Character: Graphical parameter</p>
</td></tr>
<tr><td><code id="plotScot_+3A_ylab">ylab</code></td>
<td>
<p>Character: Graphical parameter</p>
</td></tr>
<tr><td><code id="plotScot_+3A_ylim">ylim</code></td>
<td>
<p>Graphical parameter (default if <code>rel = TRUE</code>: <code>c(0, 1)</code>)</p>
</td></tr>
<tr><td><code id="plotScot_+3A_both.lwd">both.lwd</code></td>
<td>
<p>Graphical parameter for smoothed values if <code>curves = "both"</code></p>
</td></tr>
<tr><td><code id="plotScot_+3A_both.col">both.col</code></td>
<td>
<p>Graphical parameter for smoothed values if <code>curves = "both"</code></p>
</td></tr>
<tr><td><code id="plotScot_+3A_both.lty">both.lty</code></td>
<td>
<p>Graphical parameter for smoothed values if <code>curves = "both"</code></p>
</td></tr>
<tr><td><code id="plotScot_+3A_natozero">natozero</code></td>
<td>
<p>Logical: Should NAs be coerced
to zeros (default: <code>TRUE</code>)? Only has an effect if <code>rel = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotScot_+3A_file">file</code></td>
<td>
<p>Character: File path if a pdf should be created.</p>
</td></tr>
<tr><td><code id="plotScot_+3A_...">...</code></td>
<td>
<p>additional graphical parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>object</code> needs a textmeta object with strictly tokenized text component
(character vectors) if you use <code>type = "words"</code>.
If you use <code>type = "docs"</code> you can use a tokenized or a non-tokenized text component.
In fact, you can use the textmeta constructor
(<code>textmeta(meta = &lt;your-meta-data.frame&gt;)</code>) to create a textmeta object
containing only the meta field and plot the resulting object.
This way you can save time and memory at the first glance.
</p>


<h3>Value</h3>

<p>A plot
Invisible: A dataframe with columns <code>date</code> and <code>counts</code>,
respectively <code>proportion</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(politics)
poliClean &lt;- cleanTexts(politics)

# complete corpus
plotScot(object=poliClean)

# subcorpus
subID &lt;- filterWord(poliClean, search=c("bush", "obama"), out="bin")
plotScot(object=poliClean, id=names(subID)[subID], curves="both", smooth=0.3)

## End(Not run)
</code></pre>

<hr>
<h2 id='plotTopic'>Plotting Counts of Topics over Time (Relative to Corpus)</h2><span id='topic+plotTopic'></span>

<h3>Description</h3>

<p>Creates a plot of the counts/proportion of specified topics of a result of
<code><a href="#topic+LDAgen">LDAgen</a></code>. There is an option to plot all curves in one plot
or to create one plot for every curve (see <code>pages</code>).
In addition the plots can be written to a pdf by setting <code>file</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotTopic(
  object,
  ldaresult,
  ldaID,
  select = 1:nrow(ldaresult$document_sums),
  tnames,
  rel = FALSE,
  mark = TRUE,
  unit = "month",
  curves = c("exact", "smooth", "both"),
  smooth = 0.05,
  main,
  xlab,
  ylim,
  ylab,
  both.lwd,
  both.lty,
  col,
  legend = ifelse(pages, "onlyLast:topright", "topright"),
  pages = FALSE,
  natozero = TRUE,
  file,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotTopic_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+textmeta">textmeta</a></code> object with strictly tokenized
<code>text</code> component (character vectors) - such as a result of
<code><a href="#topic+cleanTexts">cleanTexts</a></code></p>
</td></tr>
<tr><td><code id="plotTopic_+3A_ldaresult">ldaresult</code></td>
<td>
<p>The result of a function call <code><a href="#topic+LDAgen">LDAgen</a></code></p>
</td></tr>
<tr><td><code id="plotTopic_+3A_ldaid">ldaID</code></td>
<td>
<p>Character vector of IDs of the documents in
<code>ldaresult</code></p>
</td></tr>
<tr><td><code id="plotTopic_+3A_select">select</code></td>
<td>
<p>Integer: Which topics of
<code>ldaresult</code> should be plotted (default: all topics)?</p>
</td></tr>
<tr><td><code id="plotTopic_+3A_tnames">tnames</code></td>
<td>
<p>Character vector of same length as <code>select</code>
- labels for the topics (default are the first returned words of
<code>top.topic.words</code> from the <code>lda</code> package for each topic)</p>
</td></tr>
<tr><td><code id="plotTopic_+3A_rel">rel</code></td>
<td>
<p>Logical: Should counts (<code>FALSE</code>) or
proportion (<code>TRUE</code>) be plotted (default: <code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="plotTopic_+3A_mark">mark</code></td>
<td>
<p>Logical: Should years be marked by
vertical lines (default: <code>TRUE</code>)?</p>
</td></tr>
<tr><td><code id="plotTopic_+3A_unit">unit</code></td>
<td>
<p>Character: To which unit should dates be floored
(default: <code>"month"</code>)? Other possible units are <code>"bimonth"</code>, <code>"quarter"</code>, <code>"season"</code>,
<code>"halfyear"</code>, <code>"year"</code>, for more units see <code><a href="lubridate.html#topic+round_date">round_date</a></code></p>
</td></tr>
<tr><td><code id="plotTopic_+3A_curves">curves</code></td>
<td>
<p>Character: Should <code>"exact"</code>,
<code>"smooth"</code> curve or <code>"both"</code> be plotted (default: <code>"exact"</code>)?</p>
</td></tr>
<tr><td><code id="plotTopic_+3A_smooth">smooth</code></td>
<td>
<p>Numeric: Smoothing parameter
which is handed over to <code><a href="stats.html#topic+lowess">lowess</a></code> as <code>f</code> (default: <code>0.05</code>)</p>
</td></tr>
<tr><td><code id="plotTopic_+3A_main">main</code></td>
<td>
<p>Character: Graphical parameter</p>
</td></tr>
<tr><td><code id="plotTopic_+3A_xlab">xlab</code></td>
<td>
<p>Character: Graphical parameter</p>
</td></tr>
<tr><td><code id="plotTopic_+3A_ylim">ylim</code></td>
<td>
<p>Graphical parameter</p>
</td></tr>
<tr><td><code id="plotTopic_+3A_ylab">ylab</code></td>
<td>
<p>Character: Graphical parameter</p>
</td></tr>
<tr><td><code id="plotTopic_+3A_both.lwd">both.lwd</code></td>
<td>
<p>Graphical parameter for smoothed values
if <code>curves = "both"</code></p>
</td></tr>
<tr><td><code id="plotTopic_+3A_both.lty">both.lty</code></td>
<td>
<p>Graphical parameter for smoothed values
if <code>curves = "both"</code></p>
</td></tr>
<tr><td><code id="plotTopic_+3A_col">col</code></td>
<td>
<p>Graphical parameter, could be a vector. If <code>curves = "both"</code>
the function will for every topicgroup plot at first the exact and then the
smoothed curve - this is important for your col order.</p>
</td></tr>
<tr><td><code id="plotTopic_+3A_legend">legend</code></td>
<td>
<p>Character: Value(s) to specify the legend coordinates (default: <code>"topright"</code>,
<code>"onlyLast:topright"</code> for <code>pages = TRUE</code> respectively).
If &quot;none&quot; no legend is plotted.</p>
</td></tr>
<tr><td><code id="plotTopic_+3A_pages">pages</code></td>
<td>
<p>Logical: Should all curves be
plotted in a single plot (default: <code>FALSE</code>)? In addtion you could set
<code>legend = "onlyLast:&lt;argument&gt;"</code> with <code>&lt;argument&gt;</code> as a
<code>character</code> <code>legend</code> argument
for only plotting a legend on the last plot of set.</p>
</td></tr>
<tr><td><code id="plotTopic_+3A_natozero">natozero</code></td>
<td>
<p>Logical: Should NAs be coerced
to zeros (default: <code>TRUE</code>)? Only has effect if <code>rel = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotTopic_+3A_file">file</code></td>
<td>
<p>Character: File path if a pdf should be created</p>
</td></tr>
<tr><td><code id="plotTopic_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot.
Invisible: A dataframe with columns <code>date</code> and <code>tnames</code> with the
counts/proportion of the selected topics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(politics)
poliClean &lt;- cleanTexts(politics)
words10 &lt;- makeWordlist(text=poliClean$text)
words10 &lt;- words10$words[words10$wordtable &gt; 10]
poliLDA &lt;- LDAprep(text=poliClean$text, vocab=words10)
LDAresult &lt;- LDAgen(documents=poliLDA, K=10, vocab=words10)

# plot all topics
plotTopic(object=poliClean, ldaresult=LDAresult, ldaID=names(poliLDA))

# plot special topics
plotTopic(object=poliClean, ldaresult=LDAresult, ldaID=names(poliLDA), select=c(1,4))

## End(Not run)
</code></pre>

<hr>
<h2 id='plotTopicWord'>Plotting Counts of Topics-Words-Combination over Time (Relative to Words)</h2><span id='topic+plotTopicWord'></span>

<h3>Description</h3>

<p>Creates a plot of the counts/proportion of specified combination of topics
and words. It is important to keep in mind that the baseline for
proportions are the sums of words, not sums of topics.
See also <code><a href="#topic+plotWordpt">plotWordpt</a></code>.
There is an option to plot all curves in one plot or to create one plot for
every curve (see <code>pages</code>). In addition the plots can be written to a pdf
by setting <code>file</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotTopicWord(
  object,
  docs,
  ldaresult,
  ldaID,
  wordlist = lda::top.topic.words(ldaresult$topics, 1),
  link = c("and", "or"),
  select = 1:nrow(ldaresult$document_sums),
  tnames,
  wnames,
  rel = FALSE,
  mark = TRUE,
  unit = "month",
  curves = c("exact", "smooth", "both"),
  smooth = 0.05,
  legend = ifelse(pages, "onlyLast:topright", "topright"),
  pages = FALSE,
  natozero = TRUE,
  file,
  main,
  xlab,
  ylab,
  ylim,
  both.lwd,
  both.lty,
  col,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotTopicWord_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+textmeta">textmeta</a></code> object with strictly tokenized
<code>text</code> component (Character vectors) - such as a result of
<code><a href="#topic+cleanTexts">cleanTexts</a></code></p>
</td></tr>
<tr><td><code id="plotTopicWord_+3A_docs">docs</code></td>
<td>
<p>Object as a result of <code><a href="#topic+LDAprep">LDAprep</a></code> which was handed over
to <code><a href="#topic+LDAgen">LDAgen</a></code></p>
</td></tr>
<tr><td><code id="plotTopicWord_+3A_ldaresult">ldaresult</code></td>
<td>
<p>The result of a function call <code><a href="#topic+LDAgen">LDAgen</a></code> with
<code>docs</code> as argument</p>
</td></tr>
<tr><td><code id="plotTopicWord_+3A_ldaid">ldaID</code></td>
<td>
<p>Character vector of IDs of the documents in
<code>ldaresult</code></p>
</td></tr>
<tr><td><code id="plotTopicWord_+3A_wordlist">wordlist</code></td>
<td>
<p>List of Ccharacter vectors. Every list element is an 'or'
link, every character string in a vector is linked by the argument
<code>link</code>. If <code>wordlist</code> is only a character vector it will be
coerced to a list of the same length as the vector (see <code><a href="base.html#topic+as.list">as.list</a></code>),
so that the argument <code>link</code> has no effect. Each character vector
as a list element represents one curve in the emerging plot.</p>
</td></tr>
<tr><td><code id="plotTopicWord_+3A_link">link</code></td>
<td>
<p>Character: Should the (inner)
character vectors of each list element be linked by an <code>"and"</code>
or an <code>"or"</code> (default: <code>"and"</code>)?</p>
</td></tr>
<tr><td><code id="plotTopicWord_+3A_select">select</code></td>
<td>
<p>List of integer vectors: Which topics - linked by an &quot;or&quot; every time -
should be take into account for plotting the
word counts/proportion (default: all topics as simple integer vector)?</p>
</td></tr>
<tr><td><code id="plotTopicWord_+3A_tnames">tnames</code></td>
<td>
<p>Character vector of same length as <code>select</code>
- labels for the topics (default are the first returned words of</p>
</td></tr>
<tr><td><code id="plotTopicWord_+3A_wnames">wnames</code></td>
<td>
<p>Character vector of same length as <code>wordlist</code>
- labels for every group of 'and' linked words
<code>top.topic.words</code> from the <code>lda</code> package for each topic)</p>
</td></tr>
<tr><td><code id="plotTopicWord_+3A_rel">rel</code></td>
<td>
<p>Logical: Should counts
(<code>FALSE</code>) or proportion (<code>TRUE</code>) be plotted (default: <code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="plotTopicWord_+3A_mark">mark</code></td>
<td>
<p>Logical: Should years be marked by
vertical lines (default: <code>TRUE</code>)?</p>
</td></tr>
<tr><td><code id="plotTopicWord_+3A_unit">unit</code></td>
<td>
<p>Character: To which unit should dates be floored
(default: <code>"month"</code>)? Other possible units are <code>"bimonth"</code>, <code>"quarter"</code>, <code>"season"</code>,
<code>"halfyear"</code>, <code>"year"</code>, for more units see <code><a href="lubridate.html#topic+round_date">round_date</a></code></p>
</td></tr>
<tr><td><code id="plotTopicWord_+3A_curves">curves</code></td>
<td>
<p>Character: Should <code>"exact"</code>,
<code>"smooth"</code> curve or <code>"both"</code> be plotted (default: <code>"exact"</code>)?</p>
</td></tr>
<tr><td><code id="plotTopicWord_+3A_smooth">smooth</code></td>
<td>
<p>Numeric: Smoothing parameter
which is handed over to <code><a href="stats.html#topic+lowess">lowess</a></code> as <code>f</code> (default: <code>0.05</code>)</p>
</td></tr>
<tr><td><code id="plotTopicWord_+3A_legend">legend</code></td>
<td>
<p>Character: Value(s) to specify the legend coordinates (default: <code>"topright"</code>,
<code>"onlyLast:topright"</code> for <code>pages = TRUE</code> respectively).
If &quot;none&quot; no legend is plotted.</p>
</td></tr>
<tr><td><code id="plotTopicWord_+3A_pages">pages</code></td>
<td>
<p>Logical: Should all curves be
plotted in a single plot (default: <code>FALSE</code>)? In addition you could set
<code>legend = "onlyLast:&lt;argument&gt;"</code> with <code>&lt;argument&gt;</code> as a
character <code>legend</code> argument
for only plotting a legend on the last plot of set.</p>
</td></tr>
<tr><td><code id="plotTopicWord_+3A_natozero">natozero</code></td>
<td>
<p>Logical: Should NAs be coerced
to zeros (default: <code>TRUE</code>)?</p>
</td></tr>
<tr><td><code id="plotTopicWord_+3A_file">file</code></td>
<td>
<p>Character: File path if a pdf should be created</p>
</td></tr>
<tr><td><code id="plotTopicWord_+3A_main">main</code></td>
<td>
<p>Character: Graphical parameter</p>
</td></tr>
<tr><td><code id="plotTopicWord_+3A_xlab">xlab</code></td>
<td>
<p>Character: Graphical parameter</p>
</td></tr>
<tr><td><code id="plotTopicWord_+3A_ylab">ylab</code></td>
<td>
<p>Character: Graphical parameter</p>
</td></tr>
<tr><td><code id="plotTopicWord_+3A_ylim">ylim</code></td>
<td>
<p>Graphical parameter</p>
</td></tr>
<tr><td><code id="plotTopicWord_+3A_both.lwd">both.lwd</code></td>
<td>
<p>Graphical parameter for smoothed values
if <code>curves = "both"</code></p>
</td></tr>
<tr><td><code id="plotTopicWord_+3A_both.lty">both.lty</code></td>
<td>
<p>Graphical parameter for smoothed values
if <code>curves = "both"</code></p>
</td></tr>
<tr><td><code id="plotTopicWord_+3A_col">col</code></td>
<td>
<p>Graphical parameter, could be a vector. If <code>curves = "both"</code>
the function will for every wordgroup plot at first the exact and then the
smoothed curve - this is important for your col order.</p>
</td></tr>
<tr><td><code id="plotTopicWord_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot.
Invisible: A dataframe with columns <code>date</code> and <code>tnames: wnames</code>
with the counts/proportion of the selected combination of topics and words.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(politics)
poliClean &lt;- cleanTexts(politics)
words10 &lt;- makeWordlist(text=poliClean$text)
words10 &lt;- words10$words[words10$wordtable &gt; 10]
poliLDA &lt;- LDAprep(text=poliClean$text, vocab=words10)
LDAresult &lt;- LDAgen(documents=poliLDA, K=10, vocab=words10)

# plot topwords from each topic
plotTopicWord(object=poliClean, docs=poliLDA, ldaresult=LDAresult, ldaID=names(poliLDA))
plotTopicWord(object=poliClean, docs=poliLDA, ldaresult=LDAresult, ldaID=names(poliLDA), rel=TRUE)

# plot one word in different topics
plotTopicWord(object=poliClean, docs=poliLDA, ldaresult=LDAresult, ldaID=names(poliLDA),
              select=c(1,3,8), wordlist=c("bush"))

# Differences between plotTopicWord and plotWordpt
par(mfrow=c(2,2))
plotTopicWord(object=poliClean, docs=poliLDA, ldaresult=LDAresult, ldaID=names(poliLDA),
              select=c(1,3,8), wordlist=c("bush"), rel=FALSE)
plotWordpt(object=poliClean, docs=poliLDA, ldaresult=LDAresult, ldaID=names(poliLDA),
           select=c(1,3,8), wordlist=c("bush"), rel=FALSE)
plotTopicWord(object=poliClean, docs=poliLDA, ldaresult=LDAresult, ldaID=names(poliLDA),
              select=c(1,3,8), wordlist=c("bush"), rel=TRUE)
plotWordpt(object=poliClean, docs=poliLDA, ldaresult=LDAresult, ldaID=names(poliLDA),
           select=c(1,3,8), wordlist=c("bush"), rel=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='plotWordpt'>Plots Counts of Topics-Words-Combination over Time (Relative to Topics)</h2><span id='topic+plotWordpt'></span>

<h3>Description</h3>

<p>Creates a plot of the counts/proportion of specified combination of topics
and words. The plot shows how often a word appears in a topic. It is important to keep in mind that the baseline for
proportions are the sums of topics, not sums of words.
See also <code><a href="#topic+plotTopicWord">plotTopicWord</a></code>.
There is an option to plot all curves in one plot or to create one plot for
every curve (see <code>pages</code>). In addition the plots can be written to a pdf
by setting <code>file</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotWordpt(
  object,
  docs,
  ldaresult,
  ldaID,
  select = 1:nrow(ldaresult$document_sums),
  link = c("and", "or"),
  wordlist = lda::top.topic.words(ldaresult$topics, 1),
  tnames,
  wnames,
  rel = FALSE,
  mark = TRUE,
  unit = "month",
  curves = c("exact", "smooth", "both"),
  smooth = 0.05,
  legend = ifelse(pages, "onlyLast:topright", "topright"),
  pages = FALSE,
  natozero = TRUE,
  file,
  main,
  xlab,
  ylab,
  ylim,
  both.lwd,
  both.lty,
  col,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotWordpt_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+textmeta">textmeta</a></code> object with strictly tokenized
<code>text</code> component (character vectors) - e.g. a result of
<code><a href="#topic+cleanTexts">cleanTexts</a></code></p>
</td></tr>
<tr><td><code id="plotWordpt_+3A_docs">docs</code></td>
<td>
<p>Object as a result of <code><a href="#topic+LDAprep">LDAprep</a></code> which was handed over
to <code><a href="#topic+LDAgen">LDAgen</a></code></p>
</td></tr>
<tr><td><code id="plotWordpt_+3A_ldaresult">ldaresult</code></td>
<td>
<p>The result of a function call <code><a href="#topic+LDAgen">LDAgen</a></code> with
<code>docs</code> as argument</p>
</td></tr>
<tr><td><code id="plotWordpt_+3A_ldaid">ldaID</code></td>
<td>
<p>Character vector of IDs of the documents in
<code>ldaresult</code></p>
</td></tr>
<tr><td><code id="plotWordpt_+3A_select">select</code></td>
<td>
<p>List of integer vectors. Every list element is an 'or'
link, every integer string in a vector is linked by the argument
<code>link</code>. If <code>select</code> is only a <code>integer</code> vector it will be
coerced to a list of the same length as the vector (see <code><a href="base.html#topic+as.list">as.list</a></code>),
so that the argument <code>link</code> has no effect. Each integer vector
as a list element represents one curve in the outcoming plot</p>
</td></tr>
<tr><td><code id="plotWordpt_+3A_link">link</code></td>
<td>
<p>Character:  Should the (inner)
integer vectors of each list element be linked by an <code>"and"</code>
or an <code>"or"</code> (default: <code>"and"</code>)?</p>
</td></tr>
<tr><td><code id="plotWordpt_+3A_wordlist">wordlist</code></td>
<td>
<p>List of character vectors: Which words - always linked by an &quot;or&quot; -
should be taken into account for plotting the topic counts/proportion
(default: the first <code>top.topic.words</code> per topic as simple character vector)?</p>
</td></tr>
<tr><td><code id="plotWordpt_+3A_tnames">tnames</code></td>
<td>
<p>Character vector of same length as <code>select</code>
- labels for the topics (default are the first returned words of</p>
</td></tr>
<tr><td><code id="plotWordpt_+3A_wnames">wnames</code></td>
<td>
<p>Character vector of same length as <code>wordlist</code>
- labels for every group of 'and' linked words
<code>top.topic.words</code> from the <code>lda</code> package for each topic)</p>
</td></tr>
<tr><td><code id="plotWordpt_+3A_rel">rel</code></td>
<td>
<p>Logical:  Should counts
(<code>FALSE</code>) or proportion (<code>TRUE</code>) be plotted (default: <code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="plotWordpt_+3A_mark">mark</code></td>
<td>
<p>Logical: Should years be marked by
vertical lines (default: <code>TRUE</code>)?</p>
</td></tr>
<tr><td><code id="plotWordpt_+3A_unit">unit</code></td>
<td>
<p>Character: To which unit should dates be floored
(default: <code>"month"</code>)? Other possible units are <code>"bimonth"</code>, <code>"quarter"</code>, <code>"season"</code>,
<code>"halfyear"</code>, <code>"year"</code>, for more units see <code><a href="lubridate.html#topic+round_date">round_date</a></code></p>
</td></tr>
<tr><td><code id="plotWordpt_+3A_curves">curves</code></td>
<td>
<p>Character:  Should <code>"exact"</code>,
<code>"smooth"</code> curve or <code>"both"</code> be plotted (default: <code>"exact"</code>)?</p>
</td></tr>
<tr><td><code id="plotWordpt_+3A_smooth">smooth</code></td>
<td>
<p>Numeric: Smoothing parameter
which is handed over to <code><a href="stats.html#topic+lowess">lowess</a></code> as <code>f</code> (default: <code>0.05</code>)</p>
</td></tr>
<tr><td><code id="plotWordpt_+3A_legend">legend</code></td>
<td>
<p>Character: Value(s) to specify the legend coordinates (default: <code>"topright"</code>,
<code>"onlyLast:topright"</code> for <code>pages = TRUE</code> respectively).
If &quot;none&quot; no legend is plotted.</p>
</td></tr>
<tr><td><code id="plotWordpt_+3A_pages">pages</code></td>
<td>
<p>Logical: Should all curves be
plotted in a single plot (default: <code>FALSE</code>)? In addtion you could set
<code>legend = "onlyLast:&lt;argument&gt;"</code> with <code>&lt;argument&gt;</code> as a
character <code>legend</code> argument
for only plotting a legend on the last plot of set.</p>
</td></tr>
<tr><td><code id="plotWordpt_+3A_natozero">natozero</code></td>
<td>
<p>Logical:  Should NAs be coerced
to zeros (default: <code>TRUE</code>)?</p>
</td></tr>
<tr><td><code id="plotWordpt_+3A_file">file</code></td>
<td>
<p>Character: File path if a pdf should be created</p>
</td></tr>
<tr><td><code id="plotWordpt_+3A_main">main</code></td>
<td>
<p>Character: Graphical parameter</p>
</td></tr>
<tr><td><code id="plotWordpt_+3A_xlab">xlab</code></td>
<td>
<p>Ccharacter: Graphical parameter</p>
</td></tr>
<tr><td><code id="plotWordpt_+3A_ylab">ylab</code></td>
<td>
<p>Character: Graphical parameter</p>
</td></tr>
<tr><td><code id="plotWordpt_+3A_ylim">ylim</code></td>
<td>
<p>Graphical parameter</p>
</td></tr>
<tr><td><code id="plotWordpt_+3A_both.lwd">both.lwd</code></td>
<td>
<p>Graphical parameter for smoothed values
if <code>curves = "both"</code></p>
</td></tr>
<tr><td><code id="plotWordpt_+3A_both.lty">both.lty</code></td>
<td>
<p>Graphical parameter for smoothed values
if <code>curves = "both"</code></p>
</td></tr>
<tr><td><code id="plotWordpt_+3A_col">col</code></td>
<td>
<p>Graphical parameter, could be a vector. If <code>curves = "both"</code>
the function will plot for every wordgroup the exact at first and then the
smoothed curve - this is important for your col order.</p>
</td></tr>
<tr><td><code id="plotWordpt_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot.
Invisible: A dataframe with columns <code>date</code> and <code>tnames: wnames</code>
with the counts/proportion of the selected combination of topics and words.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(politics)
poliClean &lt;- cleanTexts(politics)
words10 &lt;- makeWordlist(text=poliClean$text)
words10 &lt;- words10$words[words10$wordtable &gt; 10]
poliLDA &lt;- LDAprep(text=poliClean$text, vocab=words10)
LDAresult &lt;- LDAgen(documents=poliLDA, K=10, vocab=words10)
plotWordpt(object=poliClean, docs=poliLDA, ldaresult=LDAresult, ldaID=names(poliLDA))
plotWordpt(object=poliClean, docs=poliLDA, ldaresult=LDAresult, ldaID=names(poliLDA), rel=TRUE)

# Differences between plotTopicWord and plotWordpt
par(mfrow=c(2,2))
plotTopicWord(object=poliClean, docs=poliLDA, ldaresult=LDAresult, ldaID=names(poliLDA),
              select=c(1,3,8), wordlist=c("bush"), rel=FALSE)
plotWordpt(object=poliClean, docs=poliLDA, ldaresult=LDAresult, ldaID=names(poliLDA),
           select=c(1,3,8), wordlist=c("bush"), rel=FALSE)
plotTopicWord(object=poliClean, docs=poliLDA, ldaresult=LDAresult, ldaID=names(poliLDA),
              select=c(1,3,8), wordlist=c("bush"), rel=TRUE)
plotWordpt(object=poliClean, docs=poliLDA, ldaresult=LDAresult, ldaID=names(poliLDA),
           select=c(1,3,8), wordlist=c("bush"), rel=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='plotWordSub'>Plotting Counts/Proportion of Words/Docs in LDA-generated Topic-Subcorpora over Time</h2><span id='topic+plotWordSub'></span>

<h3>Description</h3>

<p>Creates a plot of the counts/proportion of words/docs in corpora which are
generated by a <code>ldaresult</code>. Therefore an article is allocated to a topic
- and then to the topics corpus - if there are enough (see <code>limit</code> and
<code>alloc</code>) allocations of words in the article to the corresponding topic.
Additionally the corpora are reduced by <code><a href="#topic+filterWord">filterWord</a></code> and a
<code>search</code>-argument. The plot shows counts of subcorpora or if
<code>rel = TRUE</code> proportion of subcorpora to its corresponding whole corpus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotWordSub(
  object,
  ldaresult,
  ldaID,
  limit = 10,
  alloc = c("multi", "unique", "best"),
  select = 1:nrow(ldaresult$document_sums),
  tnames,
  search,
  ignore.case = TRUE,
  type = c("docs", "words"),
  rel = TRUE,
  mark = TRUE,
  unit = "month",
  curves = c("exact", "smooth", "both"),
  smooth = 0.05,
  main,
  xlab,
  ylab,
  ylim,
  both.lwd,
  both.lty,
  col,
  legend = "topright",
  natozero = TRUE,
  file,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotWordSub_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+textmeta">textmeta</a></code> object with strictly tokenized
<code>text</code> component (character vectors) - such as a result of
<code><a href="#topic+cleanTexts">cleanTexts</a></code></p>
</td></tr>
<tr><td><code id="plotWordSub_+3A_ldaresult">ldaresult</code></td>
<td>
<p>The result of a function call <code><a href="#topic+LDAgen">LDAgen</a></code></p>
</td></tr>
<tr><td><code id="plotWordSub_+3A_ldaid">ldaID</code></td>
<td>
<p>Character vector of IDs of the documents in
<code>ldaresult</code></p>
</td></tr>
<tr><td><code id="plotWordSub_+3A_limit">limit</code></td>
<td>
<p>Integer/numeric: How often a word must be
allocated to a topic to count these article as belonging
to this topic - if <code>0&lt;limit&lt;1</code> proportion is used (default: <code>10</code>)?</p>
</td></tr>
<tr><td><code id="plotWordSub_+3A_alloc">alloc</code></td>
<td>
<p>Character:  Should every article
be allocated to multiple topics (<code>"multi"</code>), or maximum one
topic (<code>"unique"</code>), or the most represantative  - exactly one -
topic (<code>"best"</code>) (default: <code>"multi"</code>)? If <code>alloc = "best"</code> <code>limit</code> has no effect.</p>
</td></tr>
<tr><td><code id="plotWordSub_+3A_select">select</code></td>
<td>
<p>Integer vector: Which topics of
<code>ldaresult</code> should be plotted (default: all topics)?</p>
</td></tr>
<tr><td><code id="plotWordSub_+3A_tnames">tnames</code></td>
<td>
<p>Character vector of same length as <code>select</code>
- labels for the topics (default are the first returned words of
<code>top.topic.words</code> from the <code>lda</code> package for each topic)</p>
</td></tr>
<tr><td><code id="plotWordSub_+3A_search">search</code></td>
<td>
<p>See <code><a href="#topic+filterWord">filterWord</a></code></p>
</td></tr>
<tr><td><code id="plotWordSub_+3A_ignore.case">ignore.case</code></td>
<td>
<p>See <code><a href="#topic+filterWord">filterWord</a></code></p>
</td></tr>
<tr><td><code id="plotWordSub_+3A_type">type</code></td>
<td>
<p>Character: Should counts/proportion of documents, where every
<code>"docs"</code> or words <code>"words"</code> be plotted (default: <code>"docs"</code>)?</p>
</td></tr>
<tr><td><code id="plotWordSub_+3A_rel">rel</code></td>
<td>
<p>Logical. Should counts (<code>FALSE</code>)
or proportion (<code>TRUE</code>) be plotted (default: <code>TRUE</code>)?</p>
</td></tr>
<tr><td><code id="plotWordSub_+3A_mark">mark</code></td>
<td>
<p>Logical:  Should years be marked by
vertical lines (default: <code>TRUE</code>)?</p>
</td></tr>
<tr><td><code id="plotWordSub_+3A_unit">unit</code></td>
<td>
<p>Character: To which unit should dates be floored
(default: <code>"month"</code>)? Other possible units are &quot;bimonth&quot;, &quot;quarter&quot;, &quot;season&quot;,
&quot;halfyear&quot;, &quot;year&quot;, for more units see <code><a href="lubridate.html#topic+round_date">round_date</a></code></p>
</td></tr>
<tr><td><code id="plotWordSub_+3A_curves">curves</code></td>
<td>
<p>Character: Should <code>"exact"</code>,
<code>"smooth"</code> curve or <code>"both"</code> be plotted (default: <code>"exact"</code>)?</p>
</td></tr>
<tr><td><code id="plotWordSub_+3A_smooth">smooth</code></td>
<td>
<p>Numeric: Smoothing parameter
which is handed over to <code><a href="stats.html#topic+lowess">lowess</a></code> as <code>f</code> (default: <code>0.05</code>)</p>
</td></tr>
<tr><td><code id="plotWordSub_+3A_main">main</code></td>
<td>
<p>Character: Graphical parameter</p>
</td></tr>
<tr><td><code id="plotWordSub_+3A_xlab">xlab</code></td>
<td>
<p>Character: Graphical parameter</p>
</td></tr>
<tr><td><code id="plotWordSub_+3A_ylab">ylab</code></td>
<td>
<p>Character: Graphical parameter</p>
</td></tr>
<tr><td><code id="plotWordSub_+3A_ylim">ylim</code></td>
<td>
<p>Graphical parameter (default if <code>rel = TRUE</code>: <code>c(0, 1)</code>)</p>
</td></tr>
<tr><td><code id="plotWordSub_+3A_both.lwd">both.lwd</code></td>
<td>
<p>Graphical parameter for smoothed values
if <code>curves = "both"</code></p>
</td></tr>
<tr><td><code id="plotWordSub_+3A_both.lty">both.lty</code></td>
<td>
<p>Graphical parameter for smoothed values
if <code>curves = "both"</code></p>
</td></tr>
<tr><td><code id="plotWordSub_+3A_col">col</code></td>
<td>
<p>Graphical parameter, could be a vector. If <code>curves = "both"</code>
the function will for every wordgroup plot at first the exact and then the
smoothed curve - this is important for your col order.</p>
</td></tr>
<tr><td><code id="plotWordSub_+3A_legend">legend</code></td>
<td>
<p>Character: Value(s) to specify the
legend coordinates (default: &quot;topright&quot;). If &quot;none&quot; no legend is plotted.</p>
</td></tr>
<tr><td><code id="plotWordSub_+3A_natozero">natozero</code></td>
<td>
<p>Logical. Should NAs be coerced
to zeros (default: <code>TRUE</code>)? Only has effect if <code>rel = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotWordSub_+3A_file">file</code></td>
<td>
<p>Character: File path if a pdf should be created</p>
</td></tr>
<tr><td><code id="plotWordSub_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot.
Invisible: A dataframe with columns <code>date</code> and <code>tnames</code> with the
counts/proportion of the selected topics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(politics)
poliClean &lt;- cleanTexts(politics)
poliPraesidents &lt;- filterWord(object=poliClean, search=c("bush", "obama"))
words10 &lt;- makeWordlist(text=poliPraesidents$text)
words10 &lt;- words10$words[words10$wordtable &gt; 10]
poliLDA &lt;- LDAprep(text=poliPraesidents$text, vocab=words10)
LDAresult &lt;- LDAgen(documents=poliLDA, K=5, vocab=words10)
plotWordSub(object=poliClean, ldaresult=LDAresult, ldaID=names(poliLDA), search="obama")

## End(Not run)
</code></pre>

<hr>
<h2 id='precision'>Precision and Recall</h2><span id='topic+precision'></span><span id='topic+vprecision'></span><span id='topic+recall'></span><span id='topic+vrecall'></span>

<h3>Description</h3>

<p>Estimates Precision and Recall for sampling in different intersections
</p>


<h3>Usage</h3>

<pre><code class='language-R'>precision(w, p, subset)

vprecision(w, p, subset, n)

recall(w, p, subset)

vrecall(w, p, subset, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="precision_+3A_w">w</code></td>
<td>
<p>Numeric vector: Each entry represents one intersection.
Proportion of texts in this intersection.</p>
</td></tr>
<tr><td><code id="precision_+3A_p">p</code></td>
<td>
<p>Numeric vector: Each entry represents one intersection.
Proportion of relevant texts in this intersection.</p>
</td></tr>
<tr><td><code id="precision_+3A_subset">subset</code></td>
<td>
<p>Logical vector: Each entry represents one intersection.
Controls if the intersection belongs to the subcorpus of interest or not.</p>
</td></tr>
<tr><td><code id="precision_+3A_n">n</code></td>
<td>
<p>Integer vector: Number of Texts labeled in the corresponding intersection.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimator for precision, recall, and their variances respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>w &lt;- c(0.5, 0.1, 0.2, 0.2)
p &lt;- c(0.01, 0.8, 0.75, 0.95)
subset &lt;- c(FALSE, TRUE, FALSE, TRUE)
n &lt;- c(40, 20, 15, 33)
precision(w, p, subset)
vprecision(w, p, subset, n)
recall(w, p, subset)
vrecall(w, p, subset, n)

</code></pre>

<hr>
<h2 id='readTextmeta'>Read Corpora as CSV</h2><span id='topic+readTextmeta'></span><span id='topic+readTextmeta.df'></span>

<h3>Description</h3>

<p>Reads CSV-files and seperates the text and meta data. The result is a
<code><a href="#topic+textmeta">textmeta</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readTextmeta(
  path,
  file,
  cols,
  dateFormat = "%Y-%m-%d",
  idCol = "id",
  dateCol = "date",
  titleCol = "title",
  textCol = "text",
  encoding = "UTF-8",
  xmlAction = TRUE,
  duplicateAction = TRUE
)

readTextmeta.df(
  df,
  cols = colnames(df),
  dateFormat = "%Y-%m-%d",
  idCol = "id",
  dateCol = "date",
  titleCol = "title",
  textCol = "text",
  xmlAction = TRUE,
  duplicateAction = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readTextmeta_+3A_path">path</code></td>
<td>
<p><code>character/data.frame</code> string with path where the data files
are OR parameter <code>df</code> for <code>readTextmeta.df</code></p>
</td></tr>
<tr><td><code id="readTextmeta_+3A_file">file</code></td>
<td>
<p><code>character</code> string with names of the CSV files</p>
</td></tr>
<tr><td><code id="readTextmeta_+3A_cols">cols</code></td>
<td>
<p><code>character</code> vector with columns which should be kept</p>
</td></tr>
<tr><td><code id="readTextmeta_+3A_dateformat">dateFormat</code></td>
<td>
<p><code>character</code> string with the date format in the files
for <code><a href="base.html#topic+as.Date">as.Date</a></code></p>
</td></tr>
<tr><td><code id="readTextmeta_+3A_idcol">idCol</code></td>
<td>
<p><code>character</code> string with column name of the IDs</p>
</td></tr>
<tr><td><code id="readTextmeta_+3A_datecol">dateCol</code></td>
<td>
<p><code>character</code> string with column name of the Dates</p>
</td></tr>
<tr><td><code id="readTextmeta_+3A_titlecol">titleCol</code></td>
<td>
<p><code>character</code> string with column name of the Titles</p>
</td></tr>
<tr><td><code id="readTextmeta_+3A_textcol">textCol</code></td>
<td>
<p><code>character</code> string with column name of the Texts</p>
</td></tr>
<tr><td><code id="readTextmeta_+3A_encoding">encoding</code></td>
<td>
<p>character string with encoding specification of the files</p>
</td></tr>
<tr><td><code id="readTextmeta_+3A_xmlaction">xmlAction</code></td>
<td>
<p><code>logical</code> whether all columns of the CSV should be
handled with <code><a href="#topic+removeXML">removeXML</a></code></p>
</td></tr>
<tr><td><code id="readTextmeta_+3A_duplicateaction">duplicateAction</code></td>
<td>
<p><code>logical</code>
whether <code><a href="#topic+deleteAndRenameDuplicates">deleteAndRenameDuplicates</a></code> should be applied to the
created <code><a href="#topic+textmeta">textmeta</a></code> object</p>
</td></tr>
<tr><td><code id="readTextmeta_+3A_df">df</code></td>
<td>
<p><code>data.frame</code> table which should be transformed to a textmeta object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+textmeta">textmeta</a></code> object
</p>

<hr>
<h2 id='readWhatsApp'>Read WhatsApp files</h2><span id='topic+readWhatsApp'></span>

<h3>Description</h3>

<p>Reads HTML-files from WhatsApp and separates the text and meta data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readWhatsApp(path, file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readWhatsApp_+3A_path">path</code></td>
<td>
<p>Character: string with path where the data files are.
If only <code>path</code> is given, <code>file</code> will be determined by searching
for html files with <code><a href="base.html#topic+list.files">list.files</a></code> and recursion.</p>
</td></tr>
<tr><td><code id="readWhatsApp_+3A_file">file</code></td>
<td>
<p>Character: string with names of the HTML files.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+textmeta">textmeta</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Jonas Rieger (&lt;jonas.rieger@tu-dortmund.de&gt;)
</p>

<hr>
<h2 id='readWiki'>Read Pages from Wikipedia</h2><span id='topic+readWiki'></span>

<h3>Description</h3>

<p>Downloads pages from Wikipedia and extracts some meta information
with functions from the package <code>WikipediR</code>. Creates a
<code><a href="#topic+textmeta">textmeta</a></code> object including the requested pages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readWiki(
  category,
  subcategories = TRUE,
  language = "en",
  project = "wikipedia"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readWiki_+3A_category">category</code></td>
<td>
<p><code>character</code> articles of which category should be
downloaded, see <code>pages_in_category</code>, argument <code>categories</code></p>
</td></tr>
<tr><td><code id="readWiki_+3A_subcategories">subcategories</code></td>
<td>
<p><code>logical</code> (default: <code>TRUE</code>) should
subcategories be downloaded as well</p>
</td></tr>
<tr><td><code id="readWiki_+3A_language">language</code></td>
<td>
<p><code>character</code> (default: <code>"en"</code>),
see <code>pages_in_category</code></p>
</td></tr>
<tr><td><code id="readWiki_+3A_project">project</code></td>
<td>
<p><code>character</code> (default: <code>"wikipedia"</code>),
see <code>pages_in_category</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+textmeta">textmeta</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: corpus &lt;- readWiki(category="Person_(Studentenbewegung)",
subcategories = FALSE, language = "de", project = "wikipedia")
## End(Not run)
</code></pre>

<hr>
<h2 id='readWikinews'>Read files from Wikinews</h2><span id='topic+readWikinews'></span>

<h3>Description</h3>

<p>Reads the XML-files from the Wikinews export page <a href="https://en.wikinews.org/wiki/Special:Export">https://en.wikinews.org/wiki/Special:Export</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readWikinews(
  path = getwd(),
  file = list.files(path = path, pattern = "*.xml$", full.names = FALSE, recursive =
    TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readWikinews_+3A_path">path</code></td>
<td>
<p>Path where the data files are.</p>
</td></tr>
<tr><td><code id="readWikinews_+3A_file">file</code></td>
<td>
<p>Character string with names of the HTML files.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>textmeta-object
</p>

<hr>
<h2 id='removeXML'>Removes XML/HTML Tags and Umlauts</h2><span id='topic+removeXML'></span><span id='topic+removeUmlauts'></span><span id='topic+removeHTML'></span>

<h3>Description</h3>

<p>Removes XML tags (removeXML), remove or resolve HTML tags (removeHTML) and changes german umlauts in a standardized form (removeUmlauts).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeXML(x)

removeUmlauts(x)

removeHTML(
  x,
  dec = TRUE,
  hex = TRUE,
  entity = TRUE,
  symbolList = c(1:4, 9, 13, 15, 16),
  delete = TRUE,
  symbols = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="removeXML_+3A_x">x</code></td>
<td>
<p>Character: Vector or list of character vectors.</p>
</td></tr>
<tr><td><code id="removeXML_+3A_dec">dec</code></td>
<td>
<p>Logical: If <code>TRUE</code> HTML-entities in decimal-style would be resolved.</p>
</td></tr>
<tr><td><code id="removeXML_+3A_hex">hex</code></td>
<td>
<p>Logical: If <code>TRUE</code> HTML-entities in hexadecimal-style would be resolved.</p>
</td></tr>
<tr><td><code id="removeXML_+3A_entity">entity</code></td>
<td>
<p>Logical: If <code>TRUE</code> HTML-entities in text-style would be resolved.</p>
</td></tr>
<tr><td><code id="removeXML_+3A_symbollist">symbolList</code></td>
<td>
<p>numeric vector to chhose from the 16 ISO-8859 Lists (ISO-8859 12 did not exists and is empty).</p>
</td></tr>
<tr><td><code id="removeXML_+3A_delete">delete</code></td>
<td>
<p>Logical: If <code>TRUE</code> all not resolved HTML-entities would bei deleted?</p>
</td></tr>
<tr><td><code id="removeXML_+3A_symbols">symbols</code></td>
<td>
<p>Logical: If <code>TRUE</code> most symbols from ISO-8859 would be not resolved (DEC: 32:64, 91:96, 123:126, 160:191, 215, 247, 818, 8194:8222, 8254, 8291, 8364, 8417, 8470).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The decision which u.type is used should consider the language of the corpus, because in some languages the replacement of umlauts can change the meaning of a word.
To change which columns are used by removeXML use argument xmlAction in <code><a href="#topic+readTextmeta">readTextmeta</a></code>.
</p>


<h3>Value</h3>

<p>Adjusted character string or list, depending on input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xml &lt;- "&lt;text&gt;Some &lt;b&gt;important&lt;/b&gt; text&lt;/text&gt;"
removeXML(xml)

x &lt;- "&amp;#x00f8; &amp;#248; &amp;oslash;"
removeHTML(x=x, symbolList = 1, dec=TRUE, hex=FALSE, entity=FALSE, delete = FALSE)
removeHTML(x=x, symbolList = c(1,3))

y &lt;- c("Bl\UFChende Apfelb\UE4ume")
removeUmlauts(y)

</code></pre>

<hr>
<h2 id='sampling'>Sample Texts</h2><span id='topic+sampling'></span>

<h3>Description</h3>

<p>Sample texts from different subsets to minimize variance of the recall estimator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampling(id, corporaID, label, m, randomize = FALSE, exact = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampling_+3A_id">id</code></td>
<td>
<p>Character: IDs of all texts in the corpus.</p>
</td></tr>
<tr><td><code id="sampling_+3A_corporaid">corporaID</code></td>
<td>
<p>List of Character: Each list element is a character vector and
contains the IDs belonging to one subcorpus. Each ID has to be in <code>id</code>.</p>
</td></tr>
<tr><td><code id="sampling_+3A_label">label</code></td>
<td>
<p>Named Logical: Labeling result for already labeled texts. Could be empty, if no labeled data exists. The algorithm sets <code>p = 0.5</code> for all intersections.
Names have to be <code>id</code>.</p>
</td></tr>
<tr><td><code id="sampling_+3A_m">m</code></td>
<td>
<p>Integer: Number of new samples.</p>
</td></tr>
<tr><td><code id="sampling_+3A_randomize">randomize</code></td>
<td>
<p>Logical: If <code>TRUE</code> calculated split is used as parameter
to draw from a multinomial distribution.</p>
</td></tr>
<tr><td><code id="sampling_+3A_exact">exact</code></td>
<td>
<p>Logical: If <code>TRUE</code> exact calculation is used. For the default
<code>FALSE</code> an approximation is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector of IDs, which should be labeled next.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>id &lt;- paste0("ID", 1:1000)
corporaID &lt;- list(sample(id, 300), sample(id, 100), sample(id, 700))
label &lt;- sample(as.logical(0:1), 150, replace=TRUE)
names(label) &lt;- c(sample(id, 100), sample(corporaID[[2]], 50))
m &lt;- 100
sampling(id, corporaID, label, m)
</code></pre>

<hr>
<h2 id='showMeta'>Export Readable Meta-Data of Articles.</h2><span id='topic+showMeta'></span>

<h3>Description</h3>

<p>Exports requested meta-data of articles for given id's.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showMeta(
  meta,
  id = meta$id,
  cols = colnames(meta),
  file,
  fileEncoding = "UTF-8"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showMeta_+3A_meta">meta</code></td>
<td>
<p>A data.frame of meta-data as a result of a read-function.</p>
</td></tr>
<tr><td><code id="showMeta_+3A_id">id</code></td>
<td>
<p>Character vector or matrix including article ids.</p>
</td></tr>
<tr><td><code id="showMeta_+3A_cols">cols</code></td>
<td>
<p>Character vector including the requested columns of meta.</p>
</td></tr>
<tr><td><code id="showMeta_+3A_file">file</code></td>
<td>
<p>Character Filename for the export.</p>
</td></tr>
<tr><td><code id="showMeta_+3A_fileencoding">fileEncoding</code></td>
<td>
<p>character string: declares file encoding. For more information see <code><a href="utils.html#topic+write.csv">write.csv</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the requested meta data. If file is set, writes a csv including the meta-data of the
requested meta data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>meta &lt;- data.frame(id=c("A", "B", "C", "D"),
title=c("Fishing", "Don't panic!", "Sir Ronald", "Berlin"),
date=c("1885-01-02", "1979-03-04", "1951-05-06", "1967-06-02"),
additionalVariable=1:4, stringsAsFactors=FALSE)

extractedMeta &lt;- showMeta(meta=meta, cols = c("title", "date"))

</code></pre>

<hr>
<h2 id='showTexts'>Exports Readable Text Lists</h2><span id='topic+showTexts'></span>

<h3>Description</h3>

<p>Exports the article id, text, title and date.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showTexts(object, id = names(object$text), file, fileEncoding = "UTF-8")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showTexts_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+textmeta">textmeta</a></code> object</p>
</td></tr>
<tr><td><code id="showTexts_+3A_id">id</code></td>
<td>
<p>Character vector or matrix including article ids</p>
</td></tr>
<tr><td><code id="showTexts_+3A_file">file</code></td>
<td>
<p>Character Filename for the export. If not specified the functions output ist only invisible.</p>
</td></tr>
<tr><td><code id="showTexts_+3A_fileencoding">fileEncoding</code></td>
<td>
<p>character string: declares file encoding. For more information see <code><a href="utils.html#topic+write.csv">write.csv</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the requested articles. If file is set, writes a csv including the meta-data of the
requested articles.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>texts &lt;- list(A="Give a Man a Fish, and You Feed Him for a Day.
Teach a Man To Fish, and You Feed Him for a Lifetime",
B="So Long, and Thanks for All the Fish",
C="A very able manipulative mathematician, Fisher enjoys a real mastery
in evaluating complicated multiple integrals.")

corpus &lt;- textmeta(meta=data.frame(id=c("A", "B", "C", "D"),
title=c("Fishing", "Don't panic!", "Sir Ronald", "Berlin"),
date=c("1885-01-02", "1979-03-04", "1951-05-06", "1967-06-02"),
additionalVariable=1:4, stringsAsFactors=FALSE), text=texts)

exportedTexts &lt;- showTexts(object=corpus, id = c("A","C"))
</code></pre>

<hr>
<h2 id='textmeta'>&quot;textmeta&quot;-Objects</h2><span id='topic+textmeta'></span><span id='topic+is.textmeta'></span><span id='topic+print.textmeta'></span><span id='topic+summary.textmeta'></span><span id='topic+plot.textmeta'></span>

<h3>Description</h3>

<p>Creates, Tests, Summarises and Plots Textmeta-Objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>textmeta(meta = NULL, text = NULL, metamult = NULL, dateFormat = "%Y-%m-%d")

is.textmeta(x)

## S3 method for class 'textmeta'
print(x, ...)

## S3 method for class 'textmeta'
summary(object, listnames = names(object), metavariables = character(), ...)

## S3 method for class 'textmeta'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="textmeta_+3A_meta">meta</code></td>
<td>
<p>Data.frame (or matrix) of the meta-data, e.g. as received from <code><a href="#topic+as.meta">as.meta</a></code></p>
</td></tr>
<tr><td><code id="textmeta_+3A_text">text</code></td>
<td>
<p>Named list (or character vector) of the text-data (names should correspond
to IDs in meta)</p>
</td></tr>
<tr><td><code id="textmeta_+3A_metamult">metamult</code></td>
<td>
<p>List of the metamult-data</p>
</td></tr>
<tr><td><code id="textmeta_+3A_dateformat">dateFormat</code></td>
<td>
<p>Charachter string with the date format in meta
for <code><a href="base.html#topic+as.Date">as.Date</a></code></p>
</td></tr>
<tr><td><code id="textmeta_+3A_x">x</code></td>
<td>
<p>an R Object.</p>
</td></tr>
<tr><td><code id="textmeta_+3A_...">...</code></td>
<td>
<p>further arguments in plot. Not implemented for print and summary.</p>
</td></tr>
<tr><td><code id="textmeta_+3A_object">object</code></td>
<td>
<p>textmeta object</p>
</td></tr>
<tr><td><code id="textmeta_+3A_listnames">listnames</code></td>
<td>
<p>Character vector with names of textmeta lists (meta, text, metamult). Summaries are generated for those lists only. Default gives summaries for all lists.</p>
</td></tr>
<tr><td><code id="textmeta_+3A_metavariables">metavariables</code></td>
<td>
<p>Character vector with variable-names from the meta dataset. Summaries are generated for those variables only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>textmeta</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>texts &lt;- list(A="Give a Man a Fish, and You Feed Him for a Day.
Teach a Man To Fish, and You Feed Him for a Lifetime",
B="So Long, and Thanks for All the Fish",
C="A very able manipulative mathematician, Fisher enjoys a real mastery
in evaluating complicated multiple integrals.")

corpus &lt;- textmeta(meta=data.frame(id=c("A", "B", "C", "D"),
title=c("Fishing", "Don't panic!", "Sir Ronald", "Berlin"),
date=c("1885-01-02", "1979-03-04", "1951-05-06", "1967-06-02"),
additionalVariable=1:4, stringsAsFactors=FALSE), text=texts)

print(corpus)
summary(corpus)
str(corpus)

</code></pre>

<hr>
<h2 id='tidy.textmeta'>Transform textmeta to an object with tidy text data</h2><span id='topic+tidy.textmeta'></span><span id='topic+is.textmeta_tidy'></span><span id='topic+print.textmeta_tidy'></span>

<h3>Description</h3>

<p>Transfers data from a text component of a <code><a href="#topic+textmeta">textmeta</a></code> object to a
tidy data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy.textmeta(object)

is.textmeta_tidy(x)

## S3 method for class 'textmeta_tidy'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.textmeta_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+textmeta">textmeta</a></code> object</p>
</td></tr>
<tr><td><code id="tidy.textmeta_+3A_x">x</code></td>
<td>
<p>an R Object.</p>
</td></tr>
<tr><td><code id="tidy.textmeta_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with tidy text data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>texts &lt;- list(A="Give a Man a Fish, and You Feed Him for a Day.
 Teach a Man To Fish, and You Feed Him for a Lifetime",
 B="So Long, and Thanks for All the Fish",
 C="A very able manipulative mathematician, Fisher enjoys a real mastery
 in evaluating complicated multiple integrals.")

obj &lt;- textmeta(meta=data.frame(id=c("A", "B", "C", "D"),
 title=c("Fishing", "Don't panic!", "Sir Ronald", "Berlin"),
 date=c("1885-01-02", "1979-03-04", "1951-05-06", "1967-06-02"),
 additionalVariable=1:4, stringsAsFactors=FALSE), text=texts)

tidy.textmeta(obj)

obj &lt;- cleanTexts(obj)
tidy.textmeta(obj)
</code></pre>

<hr>
<h2 id='topicCoherence'>Calculating Topic Coherence</h2><span id='topic+topicCoherence'></span>

<h3>Description</h3>

<p>Implementationof Mimno's topic coherence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>topicCoherence(
  ldaresult,
  documents,
  num.words = 10,
  by.score = TRUE,
  sym.coherence = FALSE,
  epsilon = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="topicCoherence_+3A_ldaresult">ldaresult</code></td>
<td>
<p>The result of a function call <code><a href="#topic+LDAgen">LDAgen</a></code></p>
</td></tr>
<tr><td><code id="topicCoherence_+3A_documents">documents</code></td>
<td>
<p>A list prepared by <code><a href="#topic+LDAprep">LDAprep</a></code>.</p>
</td></tr>
<tr><td><code id="topicCoherence_+3A_num.words">num.words</code></td>
<td>
<p>Integer: Number of topwords used for calculating topic coherence (default: <code>10</code>).</p>
</td></tr>
<tr><td><code id="topicCoherence_+3A_by.score">by.score</code></td>
<td>
<p>Logical: Should the Score from <code><a href="lda.html#topic+top.topic.words">top.topic.words</a></code> be used (default: <code>TRUE</code>)?</p>
</td></tr>
<tr><td><code id="topicCoherence_+3A_sym.coherence">sym.coherence</code></td>
<td>
<p>Logical: Should a symmetric version of the topic coherence used for the calculations? If TRUE the denominator of the topic coherence uses both wordcounts and not just one.</p>
</td></tr>
<tr><td><code id="topicCoherence_+3A_epsilon">epsilon</code></td>
<td>
<p>Numeric: Smoothing factor to avoid log(0). Default is 1. Stevens et al. recommend  a smaller value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of topic coherences. the length of the vector corresponds to the number of topics in the model.
</p>


<h3>References</h3>

<p>Mimno, David and Wallach, Hannah M. and Talley, Edmund and Leenders, Miriam and McCallum, Andrew. Optimizing semantic coherence in topic models. EMNLP '11 Proceedings of the Conference on Empirical Methods in Natural Language Processing, 2011.
Stevens, Keith and Andrzejewski, David and Buttler, David. Exploring topic coherence over many models and many topics. EMNLP-CoNLL '12 Proceedings of the 2012 Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning, 2012.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>texts &lt;- list(A="Give a Man a Fish, and You Feed Him for a Day.
Teach a Man To Fish, and You Feed Him for a Lifetime",
B="So Long, and Thanks for All the Fish",
C="A very able manipulative mathematician, Fisher enjoys a real mastery
in evaluating complicated multiple integrals.")

corpus &lt;- textmeta(meta=data.frame(id=c("A", "B", "C", "D"),
title=c("Fishing", "Don't panic!", "Sir Ronald", "Berlin"),
date=c("1885-01-02", "1979-03-04", "1951-05-06", "1967-06-02"),
additionalVariable=1:4, stringsAsFactors=FALSE), text=texts)

corpus &lt;- cleanTexts(corpus)
wordlist &lt;- makeWordlist(corpus$text)
ldaPrep &lt;- LDAprep(text=corpus$text, vocab=wordlist$words)

result &lt;- LDAgen(documents=ldaPrep, K = 3L, vocab=wordlist$words, num.words=3)
topicCoherence(ldaresult=result, documents=ldaPrep, num.words=5, by.score=TRUE)
</code></pre>

<hr>
<h2 id='topicsInText'>Coloring the words of a text corresponding to topic allocation</h2><span id='topic+topicsInText'></span>

<h3>Description</h3>

<p>The function creates a HTML document with the words of texts colored depending on the topic allocation of each word.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>topicsInText(
  text,
  ldaID,
  id,
  ldaresult,
  label = NULL,
  vocab,
  wordOrder = c("both", "alphabetical", "topics", ""),
  colors = NULL,
  fixColors = FALSE,
  meta = NULL,
  originaltext = NULL,
  unclearTopicAssignment = TRUE,
  htmlreturn = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="topicsInText_+3A_text">text</code></td>
<td>
<p>The result of <code><a href="#topic+LDAprep">LDAprep</a></code></p>
</td></tr>
<tr><td><code id="topicsInText_+3A_ldaid">ldaID</code></td>
<td>
<p>List of IDs for <code>text</code></p>
</td></tr>
<tr><td><code id="topicsInText_+3A_id">id</code></td>
<td>
<p>ID of the article of interest</p>
</td></tr>
<tr><td><code id="topicsInText_+3A_ldaresult">ldaresult</code></td>
<td>
<p>A result object from the <code>standardLDA</code></p>
</td></tr>
<tr><td><code id="topicsInText_+3A_label">label</code></td>
<td>
<p>Optional label for each topic</p>
</td></tr>
<tr><td><code id="topicsInText_+3A_vocab">vocab</code></td>
<td>
<p>Character: Vector of <code>vocab</code> corresponding to the <code>text</code> object</p>
</td></tr>
<tr><td><code id="topicsInText_+3A_wordorder">wordOrder</code></td>
<td>
<p>Type of output: <code>"alphabetical"</code> prints the words of the article in alphabetical order, <code>"topics"</code> sorts by topic (biggest topic first) and <code>"both"</code> prints both versions. All other inputs will result to no output (this makes only sense in combination with <code>originaltext</code>.</p>
</td></tr>
<tr><td><code id="topicsInText_+3A_colors">colors</code></td>
<td>
<p>Character vector of colors. If the vector is shorter than the number of topics it will be completed by &quot;black&quot; entrys.</p>
</td></tr>
<tr><td><code id="topicsInText_+3A_fixcolors">fixColors</code></td>
<td>
<p>Logical: If <code>FALSE</code> the first color will be used for the biggest topic and so on. If <code>fixColors=TRUE</code> the the color-entry corresponding to the position of the topic is choosen.</p>
</td></tr>
<tr><td><code id="topicsInText_+3A_meta">meta</code></td>
<td>
<p>Optional input for meta data. It will be printed in the header of the output.</p>
</td></tr>
<tr><td><code id="topicsInText_+3A_originaltext">originaltext</code></td>
<td>
<p>Optional a list of texts (the <code>text</code> list of the <code>textmeta</code> object) including the desired text. Listnames must be IDs. Necessary for output in original text</p>
</td></tr>
<tr><td><code id="topicsInText_+3A_uncleartopicassignment">unclearTopicAssignment</code></td>
<td>
<p>Logical: If TRUE all words which are assigned to more than one topic will not be colored. Otherwise the words will be colored in order of topic apperance in the <code>ldaresult</code>.</p>
</td></tr>
<tr><td><code id="topicsInText_+3A_htmlreturn">htmlreturn</code></td>
<td>
<p>Logical: HTML output for tests</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A HTML document
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(politics)
poliClean &lt;- cleanTexts(politics)
words10 &lt;- makeWordlist(text=poliClean$text)
words10 &lt;- words10$words[words10$wordtable &gt; 10]
poliLDA &lt;- LDAprep(text=poliClean$text, vocab=words10)
LDAresult &lt;- LDAgen(documents=poliLDA, K=10, vocab=words10)
topicsInText(text=politics$text, ldaID=names(poliLDA), id="ID2756",
             ldaresult=LDAresult, vocab=words10)
## End(Not run)
</code></pre>

<hr>
<h2 id='topTexts'>Get The IDs Of The Most Representive Texts</h2><span id='topic+topTexts'></span>

<h3>Description</h3>

<p>The function extracts the text IDs belonging to the texts with the highest relative or
absolute number of words per topic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>topTexts(
  ldaresult,
  ldaID,
  limit = 20L,
  rel = TRUE,
  select = 1:nrow(ldaresult$document_sums),
  tnames,
  minlength = 30L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="topTexts_+3A_ldaresult">ldaresult</code></td>
<td>
<p>LDA result</p>
</td></tr>
<tr><td><code id="topTexts_+3A_ldaid">ldaID</code></td>
<td>
<p>Vector of text IDs</p>
</td></tr>
<tr><td><code id="topTexts_+3A_limit">limit</code></td>
<td>
<p>Integer: Number of text IDs per topic.</p>
</td></tr>
<tr><td><code id="topTexts_+3A_rel">rel</code></td>
<td>
<p>Logical: Should be the relative frequency be used?</p>
</td></tr>
<tr><td><code id="topTexts_+3A_select">select</code></td>
<td>
<p>Which topics should be returned?</p>
</td></tr>
<tr><td><code id="topTexts_+3A_tnames">tnames</code></td>
<td>
<p>Names of the selected topics</p>
</td></tr>
<tr><td><code id="topTexts_+3A_minlength">minlength</code></td>
<td>
<p>Minimal total number of words a text must have to be
included</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of text IDs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>texts &lt;- list(A="Give a Man a Fish, and You Feed Him for a Day.
Teach a Man To Fish, and You Feed Him for a Lifetime",
B="So Long, and Thanks for All the Fish",
C="A very able manipulative mathematician, Fisher enjoys a real mastery
in evaluating complicated multiple integrals.")

corpus &lt;- textmeta(meta=data.frame(id=c("A", "B", "C", "D"),
title=c("Fishing", "Don't panic!", "Sir Ronald", "Berlin"),
date=c("1885-01-02", "1979-03-04", "1951-05-06", "1967-06-02"),
additionalVariable=1:4, stringsAsFactors=FALSE), text=texts)

corpus &lt;- cleanTexts(corpus)
wordlist &lt;- makeWordlist(corpus$text)
ldaPrep &lt;- LDAprep(text=corpus$text, vocab=wordlist$words)

LDA &lt;- LDAgen(documents=ldaPrep, K = 3L, vocab=wordlist$words, num.words=3)
topTexts(ldaresult=LDA, ldaID=c("A","B","C"), limit = 1L, minlength=2)
</code></pre>

<hr>
<h2 id='topWords'>Top Words per Topic</h2><span id='topic+topWords'></span><span id='topic+importance'></span>

<h3>Description</h3>

<p>Determines the top words per topic as <code><a href="lda.html#topic+top.topic.words">top.topic.words</a></code> do.
In addition, it is possible to request the values that are taken for 
determining the top words per topic. Therefore, the function <code>importance</code>
is used, which also can be called independently.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>topWords(topics, numWords = 1, byScore = TRUE, epsilon = 1e-05, values = FALSE)

importance(topics, epsilon = 1e-05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="topWords_+3A_topics">topics</code></td>
<td>
<p><code>named matrix</code>: 
The counts of vocabularies (column wise) in topics (row wise).</p>
</td></tr>
<tr><td><code id="topWords_+3A_numwords">numWords</code></td>
<td>
<p><code>integer(1)</code>: 
The number of requested top words per topic.</p>
</td></tr>
<tr><td><code id="topWords_+3A_byscore">byScore</code></td>
<td>
<p><code>logical(1)</code>: 
Should the values that are taken for determining the top words per topic be
calculated by the function <code>importance</code> (<code>TRUE</code>) or should
the absolute counts be considered (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="topWords_+3A_epsilon">epsilon</code></td>
<td>
<p><code>numeric(1)</code>: 
Small number to add to logarithmic calculations to overcome the issue of
determining <code>log(0)</code>.</p>
</td></tr>
<tr><td><code id="topWords_+3A_values">values</code></td>
<td>
<p><code>logical(1)</code>: 
Should the values that are taken for determining the top words per topic be
returned?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of top words or, if <code>value</code> is <code>TRUE</code> a list of
matrices with entries <code>word</code> and <code>val</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>texts &lt;- list(
 A = "Give a Man a Fish, and You Feed Him for a Day.
      Teach a Man To Fish, and You Feed Him for a Lifetime",
 B = "So Long, and Thanks for All the Fish",
 C = "A very able manipulative mathematician, Fisher enjoys a real mastery
      in evaluating complicated multiple integrals.")

corpus &lt;- textmeta(meta = data.frame(id = c("A", "B", "C", "D"),
  title = c("Fishing", "Don't panic!", "Sir Ronald", "Berlin"),
  date = c("1885-01-02", "1979-03-04", "1951-05-06", "1967-06-02"),
  additionalVariable = 1:4, stringsAsFactors = FALSE), text = texts)

corpus &lt;- cleanTexts(corpus)
wordlist &lt;- makeWordlist(corpus$text)
ldaPrep &lt;- LDAprep(text = corpus$text, vocab = wordlist$words)

LDA &lt;- LDAgen(documents = ldaPrep, K = 3L, vocab = wordlist$words, num.words = 3)
topWords(LDA$topics)

importance(LDA$topics)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
