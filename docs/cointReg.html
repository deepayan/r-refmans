<!DOCTYPE html><html lang="en"><head><title>Help for package cointReg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cointReg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cointReg-package'><p>The cointReg package</p></a></li>
<li><a href='#checkDoptions'><p>Check list D.options.</p></a></li>
<li><a href='#checkObject'><p>Variable check for single objects.</p></a></li>
<li><a href='#checkVars'><p>Multiple variable checks for certain values.</p></a></li>
<li><a href='#cointReg'><p>Estimation and Inference for cointegrating regressions</p></a></li>
<li><a href='#cointRegD'><p>Dynamic OLS</p></a></li>
<li><a href='#cointRegFM'><p>Fully Modified OLS</p></a></li>
<li><a href='#cointRegIM'><p>Integrated Modified OLS</p></a></li>
<li><a href='#getBandwidth'><p>Automatic Bandwidth Selection</p></a></li>
<li><a href='#getLeadLag'><p>Leads and Lags</p></a></li>
<li><a href='#getLongRunVar'><p>Long-Run Variance</p></a></li>
<li><a href='#getLongRunWeights'><p>Weights for Long-Run Variance</p></a></li>
<li><a href='#getModD'><p>Get D OLS model.</p></a></li>
<li><a href='#makeLeadLagMatrix'><p>Leads-and-Lags Matrix</p></a></li>
<li><a href='#plot.cointReg'><p>Plot Method for Cointegration Models (Modified OLS).</p></a></li>
<li><a href='#print.cointReg'><p>Print Method for Cointegration Models (Modified OLS).</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Parameter Estimation and Inference in a Cointegrating Regression</td>
</tr>
<tr>
<td>Date:</td>
<td>2016-06-14</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Cointegration methods are widely used in empirical macroeconomics
    and empirical finance. It is well known that in a cointegrating
    regression the ordinary least squares (OLS) estimator of the
    parameters is super-consistent, i.e. converges at rate equal to the
    sample size T. When the regressors are endogenous, the limiting
    distribution of the OLS estimator is contaminated by so-called second
    order bias terms, see e.g. Phillips and Hansen (1990) &lt;<a href="https://doi.org/10.2307%2F2297545">doi:10.2307/2297545</a>&gt;.
    The presence of these bias terms renders inference difficult. Consequently,
    several modifications to OLS that lead to zero mean Gaussian mixture
    limiting distributions have been proposed, which in turn make
    standard asymptotic inference feasible. These methods include
    the fully modified OLS (FM-OLS) approach of Phillips and Hansen
    (1990) &lt;<a href="https://doi.org/10.2307%2F2297545">doi:10.2307/2297545</a>&gt;, the dynamic OLS (D-OLS) approach of Phillips
    and Loretan (1991) &lt;<a href="https://doi.org/10.2307%2F2298004">doi:10.2307/2298004</a>&gt;, Saikkonen (1991)
    &lt;<a href="https://doi.org/10.1017%2FS0266466600004217">doi:10.1017/S0266466600004217</a>&gt; and Stock and Watson (1993)
    &lt;<a href="https://doi.org/10.2307%2F2951763">doi:10.2307/2951763</a>&gt; and the new estimation approach called integrated
    modified OLS (IM-OLS) of Vogelsang and Wagner (2014)
    &lt;<a href="https://doi.org/10.1016%2Fj.jeconom.2013.10.015">doi:10.1016/j.jeconom.2013.10.015</a>&gt;. The latter is based on an augmented
    partial sum (integration) transformation of the regression model. IM-OLS is
    similar in spirit to the FM- and D-OLS approaches, with the key difference
    that it does not require estimation of long run variance matrices and avoids
    the need to choose tuning parameters (kernels, bandwidths, lags). However,
    inference does require that a long run variance be scaled out.
    This package provides functions for the parameter estimation and inference
    with all three modified OLS approaches. That includes the automatic
    bandwidth selection approaches of Andrews (1991) &lt;<a href="https://doi.org/10.2307%2F2938229">doi:10.2307/2938229</a>&gt; and
    of Newey and West (1994) &lt;<a href="https://doi.org/10.2307%2F2297912">doi:10.2307/2297912</a>&gt; as well as the calculation of
    the long run variance.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/aschersleben/cointReg">https://github.com/aschersleben/cointReg</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/aschersleben/cointReg/issues">https://github.com/aschersleben/cointReg/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate (&ge; 1.6.0), MASS, matrixStats (&ge; 0.14.1)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-06-14 07:49:50 UTC; Aschersleben</td>
</tr>
<tr>
<td>Author:</td>
<td>Philipp Aschersleben [aut, cre],
  Martin Wagner [aut] (Author of underlying MATLAB code.)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Philipp Aschersleben &lt;aschersleben@statistik.tu-dortmund.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-06-14 11:58:42</td>
</tr>
</table>
<hr>
<h2 id='cointReg-package'>The cointReg package</h2><span id='topic+cointReg-package'></span>

<h3>Description</h3>

<p>Parameter Estimation and Inference in a Cointegrating Regression
</p>


<h3>Details</h3>

<p>See the vignette:<br />
<code>vignette("cointReg")</code>
</p>
<p>See the DESCRIPTION:<br />
<code>help(package = cointReg)</code>
</p>
<p>See the README:<br />
<a href="https://github.com/aschersleben/cointReg/blob/master/README.md">https://github.com/aschersleben/cointReg/blob/master/README.md</a>
</p>
<p>Open the package documentation page:<br />
<code>package?cointReg</code>
</p>
<p>Further information and bug reporting:<br />
<a href="https://github.com/aschersleben/cointReg">https://github.com/aschersleben/cointReg</a>
</p>


<h3>Functions</h3>


<ul>
<li> <p><code><a href="#topic+cointReg">cointReg</a>(method = c("FM", "D", "IM"), ...)</code><br />
General function to estimate parameters of
the given model. Three methods are possible;
they can be choosen directly by using one of the following
functions:
</p>

<ul>
<li> <p><code><a href="#topic+cointRegFM">cointRegFM</a></code>: Fully Modified OLS
</p>
</li>
<li> <p><code><a href="#topic+cointRegD">cointRegD</a></code>: Dynamic OLS
</p>
</li>
<li> <p><code><a href="#topic+cointRegIM">cointRegIM</a></code>: Integrated Modified OLS
</p>
</li></ul>

</li>
<li> <p><code><a href="#topic+print.cointReg">print</a></code><br />
Print clear results.
</p>
</li>
<li> <p><code><a href="#topic+plot.cointReg">plot</a></code><br />
Plot the residuals of a <code>cointReg</code> model.
</p>
</li>
<li><p> Helper functions:
</p>

<ul>
<li><p> Checking inputs and arguments:<br />
<code><a href="#topic+checkObject">checkObject</a></code>, <code><a href="#topic+checkVars">checkVars</a></code>
</p>
</li>
<li><p> Calculation of bandwidth and long run variance:<br />
<code><a href="#topic+getBandwidth">getBandwidth</a></code>, <code><a href="#topic+getBandwidthAnd">getBandwidthAnd</a></code>,
<code><a href="#topic+getBandwidthNW">getBandwidthNW</a></code><br />
<code><a href="#topic+getLongRunVar">getLongRunVar</a></code>, <code><a href="#topic+getLongRunWeights">getLongRunWeights</a></code>
</p>
</li>
<li><p> Additional D-OLS functions:<br />
<code><a href="#topic+getLeadLag">getLeadLag</a></code>, <code><a href="#topic+makeLeadLagMatrix">makeLeadLagMatrix</a></code>,
<code><a href="#topic+getModD">getModD</a></code>,  <code><a href="#topic+checkDoptions">checkDoptions</a></code>
</p>
</li></ul>

</li></ul>


<hr>
<h2 id='checkDoptions'>Check list D.options.</h2><span id='topic+checkDoptions'></span>

<h3>Description</h3>

<p>Checking the list D.options, that is an argument of
<code><a href="#topic+cointRegD">cointRegD</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkDoptions(n.lag = NULL, n.lead = NULL, kmax = c("k4", "k12"),
  info.crit = c("AIC", "BIC"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkDoptions_+3A_n.lag">n.lag</code>, <code id="checkDoptions_+3A_n.lead">n.lead</code></td>
<td>
<p>[<code>NULL</code> | <code>numeric(1)</code>]<br />
Have to be &quot;integerish&quot; and &gt; 0.</p>
</td></tr>
<tr><td><code id="checkDoptions_+3A_kmax">kmax</code></td>
<td>
<p>[<code>NULL</code> | <code>character(1)</code>]<br />
One of <code>"k4"</code> or <code>"k12"</code>.</p>
</td></tr>
<tr><td><code id="checkDoptions_+3A_info.crit">info.crit</code></td>
<td>
<p>[<code>NULL</code> | <code>character(1)</code>]<br />
One of <code>"AIC"</code> or <code>"BIC"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>list</code>]. List with the checked and (if necessary)
converted arguments.
</p>
<p>If one of <code>n.lag</code> and <code>n.lead</code> is
<code>NULL</code>, only <code>kmax</code> and <code>info.crit</code> will be not <code>NULL</code>.
</p>


<h3>See Also</h3>

<p>Other check: <code><a href="#topic+checkObject">checkObject</a></code>,
<code><a href="#topic+checkVars">checkVars</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>checkDoptions(n.lag = 3, n.lead = 4)
checkDoptions(info.crit = "BIC")
checkDoptions()

# It's not sufficient to include only one of "n.lag" and "n.lead":
checkDoptions(n.lag = 2)

</code></pre>

<hr>
<h2 id='checkObject'>Variable check for single objects.</h2><span id='topic+checkObject'></span>

<h3>Description</h3>

<p>Checking the variable and convert it for internal use, if necessary.
(Also used by the <code>cointmonitoR</code> package.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkObject(obj, obj.name, ..., out = "return", .env)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkObject_+3A_obj">obj</code></td>
<td>
<p>[<code>any</code>]<br />
Variable or value to check and convert.</p>
</td></tr>
<tr><td><code id="checkObject_+3A_obj.name">obj.name</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Name of the object to check.
If <code>missing</code>, the name of <code>obj</code> has to be one of the possible
names (see details).</p>
</td></tr>
<tr><td><code id="checkObject_+3A_...">...</code></td>
<td>
<p>[<code>any</code>]<br />
An alternative to the use of the <code>obj</code> and <code>obj.name</code> arguments
is to directly give the name and the variable to be checked via
<code>name = variable</code> arguments (see examples). In the case of more than
one <code>...</code> argument, <code><a href="#topic+checkVars">checkVars</a></code> will be called internally.</p>
</td></tr>
<tr><td><code id="checkObject_+3A_out">out</code></td>
<td>
<p>[<code>character</code>]<br />
Whether to <code>"return"</code> or to <code>"assign"</code> the checked
(and converted) object. Also possible: <code>c("return", "assign")</code>.</p>
</td></tr>
<tr><td><code id="checkObject_+3A_.env">.env</code></td>
<td>
<p>[<code>environment</code>]<br />
Environment to which to assign the converted <code>obj</code> (usually the
same on that contains <code>obj</code>, if it's a variable).<br />
Required, if argument <code>out</code> contains <code>"assign"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Possible values of <code>obj.name</code> to check:
</p>

<dl>
<dt><code>"y"</code>, <code>"x.stat"</code>:</dt><dd>
<p>Of type <code>numeric</code>, <code>matrix</code> or <code>data.frame</code>.
Only the first row/column will be used.<br />
Converted to object: column matrix</p>
</dd>
<dt><code>"y.fm"</code>, <code>"x.coint"</code>, <code>"deter"</code>:</dt><dd>
<p>Of type <code>numeric</code>, <code>matrix</code> or <code>data.frame</code>.<br />
Converted to object: column matrix</p>
</dd>
<dt><code>"m"</code>:</dt><dd>
<p>Of type <code>numeric(1)</code>, has to be greater than 0.</p>
</dd>
<dt><code>"model"</code>:</dt><dd>
<p>One of <code>c("FM", "D", "IM")</code>.</p>
</dd>
<dt><code>"signif.level"</code>:</dt><dd>
<p>Of type <code>numeric(1)</code>, has to be in the interval [0.01, 0.1].</p>
</dd>
<dt><code>"trend"</code>, <code>"return.stats"</code>, <code>"return.input"</code>,
<code>"demeaning"</code>, <code>"t.test"</code>:</dt><dd>
<p>Converted to object: <code>logical(1)</code>.</p>
</dd>
<dt><code>"kernel"</code>:</dt><dd>
<p>One of <code>c("ba", "bo", "da", "pa", "qs", "th", "tr")</code>.</p>
</dd>
<dt><code>"bandwidth"</code>:</dt><dd>
<p>One of <code>c("and", "nw")</code>.</p>
</dd>
<dt><code>"selector"</code>:</dt><dd>
<p>One or both <code>c(1, 2)</code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p>The checked and converted argument is assigned to
the given environment (<code>.env</code>) and/or returned (depending on the
argument <code>out</code>).
</p>


<h3>See Also</h3>

<p>Other check: <code><a href="#topic+checkDoptions">checkDoptions</a></code>,
<code><a href="#topic+checkVars">checkVars</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = matrix(1:20, nrow = 2)
x2 = checkObject(x, "x.coint")
x2

env = environment()
y = 1:10
checkObject(y, out = "assign", .env = env)
y

# example for the use of the ... argument:
det = rbind(1, 1:10)
x3 = sin(10:20)
det2 = checkObject(deter = det)
det2
(checkObject(deter = det, x.stat = x3))

</code></pre>

<hr>
<h2 id='checkVars'>Multiple variable checks for certain values.</h2><span id='topic+checkVars'></span>

<h3>Description</h3>

<p>Checking the arguments and convert them for internal use, if necessary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkVars(..., out = "assign", .env)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkVars_+3A_...">...</code></td>
<td>
<p>[<code>any</code>]<br />
Variables to check, see details.</p>
</td></tr>
<tr><td><code id="checkVars_+3A_out">out</code></td>
<td>
<p>[<code>character</code>]<br />
Whether to <code>"return"</code> or to <code>"assign"</code> the checked
(and converted) object. Also possible: <code>c("return", "assign")</code>.</p>
</td></tr>
<tr><td><code id="checkVars_+3A_.env">.env</code></td>
<td>
<p>[<code>environment</code>]<br />
Environment to which to assign the converted <code>obj</code> (usually the
same on that contains <code>obj</code>, if it's a variable).<br />
Required, if argument <code>out</code> contains <code>"assign"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+checkObject">checkObject</a></code> for details.
</p>


<h3>Value</h3>

<p>The checked and converted arguments are assigned to
the given environment (<code>.env</code>) or invisibly returned as a <code>list</code>.
</p>


<h3>See Also</h3>

<p>Other check: <code><a href="#topic+checkDoptions">checkDoptions</a></code>,
<code><a href="#topic+checkObject">checkObject</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>env = environment()
x.data = data.frame(a = 1:10, b = 20:11)
y.data = 1:10
checkVars(x.coint = x.data, y = y.data, .env = env)
x.coint
y

test = checkVars(x.coint = x.data, y = y.data, out = "return")
str(test)

# If the variables already have the "right" name,
# there's no need to do something like
# checkVars(kernel = kernel, bandwidth = bandwidth) -
# just call checkVars without specifing the arguments:
kernel = "q"
bandwidth = "a"
(checkVars(kernel, bandwidth, out = "return"))

</code></pre>

<hr>
<h2 id='cointReg'>Estimation and Inference for cointegrating regressions</h2><span id='topic+cointReg'></span>

<h3>Description</h3>

<p>Computes either the Phillips and Hansen (1990) Fully Modified OLS estimator,
or the Saikkonen (1990) Dynamic OLS estimator, or the Vogelsang and Wagner
(2014) Integrated Modified OLS estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cointReg(method = c("FM", "D", "IM"), x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cointReg_+3A_method">method</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Select the method for the estimation of your cointegration model:
</p>

<ul>
<li> <p><code>"FM"</code>: FM-OLS (default), see details at <a href="#topic+cointRegFM">cointRegFM</a>
</p>
</li>
<li> <p><code>"D"</code>: D-OLS, see details at <a href="#topic+cointRegD">cointRegD</a>
</p>
</li>
<li> <p><code>"IM"</code>: IM-OLS, see details at <a href="#topic+cointRegIM">cointRegIM</a>
</p>
</li></ul>
</td></tr>
<tr><td><code id="cointReg_+3A_x">x</code></td>
<td>
<p>[<code>numeric</code> | <code>matrix</code> | <code>data.frame</code>]<br />
RHS variables on which to apply the model estimation.</p>
</td></tr>
<tr><td><code id="cointReg_+3A_y">y</code></td>
<td>
<p>[<code>numeric</code> | <code>matrix</code> | <code>data.frame</code>]<br />
LHS variable(s) on which to apply the model estimation.
Usually one-dimensional, but a <code>matrix</code> or
<code>data.frame</code> with more than one column is also possible
(only for FM-OLS).</p>
</td></tr>
<tr><td><code id="cointReg_+3A_...">...</code></td>
<td>
<p>[<code>any</code>]<br /> Arguments passed to the corresponding <code>cointReg</code> function,
like:
</p>

<ul>
<li> <p><code>x</code>, <code>y</code>, <code>deter</code>: data to include in the model
</p>
</li>
<li> <p><code>kernel</code>, <code>bandwidth</code>: parameters for calculating the
long-run variance
</p>
</li>
<li> <p><code>n.lead</code>, <code>n.lag</code>, <code>kmax</code>, <code>info.crit</code>:
D-OLS specific arguments.
</p>
</li>
<li> <p><code>selector</code>, <code>t.test</code>: IM-OLS specific arguments.
</p>
</li>
<li> <p><code>check</code>: Wheather to check (and if necessary convert)
the arguments. See <code><a href="#topic+checkVars">checkVars</a></code> for further information.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>cointReg</code>] object.
</p>


<h3>References</h3>


<ul>
<li><p> Phillips, P.C.B. and B. Hansen (1990): &quot;Statistical Inference in
Instrumental Variables Regression with I(1) Processes,&quot;
<em>Review of Economic Studies</em>, 57, 99&ndash;125,
<a href="http://dx.doi.org/10.2307/2297545">DOI:10.2307/2297545</a>.
</p>
</li>
<li><p> Phillips, P.C.B. and M. Loretan (1991): &quot;Estimating Long Run
Economic Equilibria,&quot; <em>Review of Economic Studies</em>, 58,
407&ndash;436,
<a href="http://dx.doi.org/10.2307/2298004">DOI:10.2307/2298004</a>.
</p>
</li>
<li><p> Saikkonen, P. (1991): &quot;Asymptotically Efficient Estimation of
Cointegrating Regressions,&quot; <em>Econometric Theory</em>, 7, 1&ndash;21,
<a href="http://dx.doi.org/10.1017/S0266466600004217">DOI:10.1017/S0266466600004217</a>.
</p>
</li>
<li><p> Stock, J.H. and M.W. Watson (1993): &quot;A Simple Estimator of
Cointegrating Vectors in Higher Order Integrated Systems,&quot;
<em>Econometrica</em>, 61, 783&ndash;820,
<a href="http://dx.doi.org/10.2307/2951763">DOI:10.2307/2951763</a>.
</p>
</li>
<li><p> Vogelsang, T.J. and M. Wagner (2014): &quot;Integrated Modified OLS
Estimation and Fixed-b Inference for Cointegrating Regressions,&quot;
<em>Journal of Econometrics</em>, 148, 741&ndash;760,
<a href="http://dx.doi.org/10.1016/j.jeconom.2013.10.015">DOI:10.1016/j.jeconom.2013.10.015</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other cointReg: <code><a href="#topic+cointRegD">cointRegD</a></code>,
<code><a href="#topic+cointRegFM">cointRegFM</a></code>, <code><a href="#topic+cointRegIM">cointRegIM</a></code>,
<code><a href="#topic+plot.cointReg">plot.cointReg</a></code>, <code><a href="#topic+print.cointReg">print.cointReg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1909)
x1 = cumsum(rnorm(100, mean = 0.05, sd = 0.1))
x2 = cumsum(rnorm(100, sd = 0.1)) + 1
x3 = cumsum(rnorm(100, sd = 0.2)) + 2
x = cbind(x1, x2, x3)
y = x1 + x2 + x3 + rnorm(100, sd = 0.2) + 1
deter = cbind(level = 1, trend = 1:100)
cointReg("FM", x = x, y = y, deter = deter, kernel = "ba",
         bandwidth = "and")

# Compare the results of all three models:
res = sapply(c("FM", "D", "IM"), cointReg, x = x, y = y, deter = deter)
do.call(cbind, lapply(res, "[[", "theta"))

</code></pre>

<hr>
<h2 id='cointRegD'>Dynamic OLS</h2><span id='topic+cointRegD'></span>

<h3>Description</h3>

<p>Computes the Saikkonen (1990) Dynamic OLS estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cointRegD(x, y, deter, kernel = c("ba", "pa", "qs", "tr"),
  bandwidth = c("and", "nw"), n.lead = NULL, n.lag = NULL,
  kmax = c("k4", "k12"), info.crit = c("AIC", "BIC"), demeaning = FALSE,
  check = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cointRegD_+3A_x">x</code></td>
<td>
<p>[<code>numeric</code> | <code>matrix</code> | <code>data.frame</code>]<br />
RHS variables on which to apply the D-OLS estimation (see Details).</p>
</td></tr>
<tr><td><code id="cointRegD_+3A_y">y</code></td>
<td>
<p>[<code>numeric</code> | <code>matrix</code> | <code>data.frame</code>]<br />
LHS variable(s) on which to apply the D-OLS estimation (see Details).
Has to be one-dimensional. If <code>matrix</code>, it may
have only one row or column, if <code>data.frame</code> just one column.</p>
</td></tr>
<tr><td><code id="cointRegD_+3A_deter">deter</code></td>
<td>
<p>[<code>numeric</code> | <code>matrix</code> | <code>data.frame</code> |
<code>NULL</code>]<br />
Deterministic variable to include in the equation (see Details). If it's
<code>NULL</code> or missing, no deterministic variable is included in the model.</p>
</td></tr>
<tr><td><code id="cointRegD_+3A_kernel">kernel</code></td>
<td>
<p>[<code>character(1)</code>]<br />
The kernel function to use for calculating the long-run variance.
Default is Bartlett kernel (<code>"ba"</code>), see Details for alternatives.</p>
</td></tr>
<tr><td><code id="cointRegD_+3A_bandwidth">bandwidth</code></td>
<td>
<p>[<code>character(1)</code> | <code>integer(1)</code>]<br />
The bandwidth to use for calculating the long-run variance.
Default is Andrews (1991) (<code>"and"</code>), an alternative is Newey West
(1994) (<code>"nw"</code>).</p>
</td></tr>
<tr><td><code id="cointRegD_+3A_n.lead">n.lead</code>, <code id="cointRegD_+3A_n.lag">n.lag</code></td>
<td>
<p>[<code>numeric(1)</code> | <code>NULL</code>]<br />
Numbers of Leads and Lags (see Details). Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cointRegD_+3A_kmax">kmax</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Maximal value for lags and leads if generated automatically (see Details).
Default is <code>"k4"</code>.</p>
</td></tr>
<tr><td><code id="cointRegD_+3A_info.crit">info.crit</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Information criterion to use for the automatical calculation of lags and
leads. Default is <code>"AIC"</code>.</p>
</td></tr>
<tr><td><code id="cointRegD_+3A_demeaning">demeaning</code></td>
<td>
<p>[<code>logical</code>]<br />
Demeaning of residuals in <code><a href="#topic+getLongRunVar">getLongRunVar</a></code>.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cointRegD_+3A_check">check</code></td>
<td>
<p>[<code>logical</code>]<br />
Wheather to check (and if necessary convert) the arguments.
See <code><a href="#topic+checkVars">checkVars</a></code> for further information.</p>
</td></tr>
<tr><td><code id="cointRegD_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+getBandwidthNW">getBandwidthNW</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The equation for which the FM-OLS estimator is calculated:
</p>
<p style="text-align: center;"><code class="reqn">y = \delta \cdot D + \beta \cdot x + u</code>
</p>

<p>with <code class="reqn">D</code> as the deterministics matrix.
Then <code class="reqn">\theta = (\delta', \beta')'</code> is the full parameter vector.
</p>
<p>Information about the D-OLS specific arguments:
</p>

<dl>
<dt><code>n.lag</code>, <code>n.lead</code></dt><dd><p>A positive number to set the number
of lags and leads. If at least one of them is equal to <code>NULL</code>
(default), the function <code><a href="#topic+getLeadLag">getLeadLag</a></code> will be used to
calculate them automatically (see Choi and Kurozumi (2012) for details).
In that case, the following two arguments are needed.</p>
</dd>
<dt><code>kmax</code></dt><dd><p>Maximal value for lags and leads, when they are
calculated automatically. If &quot;k4&quot;, then the maximum is equal to
<code>floor(4 * (x.T/100)^(1/4))</code>, else it's
<code>floor(12 * (x.T/100)^(1/4))</code> with <code>x.T</code> is equal
to the data's length. One of <code>"k4"</code> or <code>"k12"</code>.
Default is <code>"k4"</code>.</p>
</dd>
<dt><code>info.crit</code></dt><dd><p>Information criterion to use for the automatical
calculation of lags and leads. One of <code>"AIC"</code> or <code>"BIC"</code>.
Default is <code>"AIC"</code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p>[<code>cointReg</code>]. List with components:
</p>

<dl>
<dt><code>beta</code> [<code>numeric</code>]</dt><dd>
<p>coefficients of the regressors</p>
</dd>
<dt><code>delta</code> [<code>numeric</code>]</dt><dd>
<p>coefficients of the deterministics</p>
</dd>
<dt><code>theta</code> [<code>numeric</code>]</dt><dd>
<p>combined coefficients of <code>beta</code> and <code>delta</code></p>
</dd>
<dt><code>sd.theta</code> [<code>numeric</code>]</dt><dd>
<p>standard errors for <code>theta</code></p>
</dd>
<dt><code>t.theta</code> [<code>numeric</code>]</dt><dd>
<p>t-values for <code>theta</code></p>
</dd>
<dt><code>p.theta</code> [<code>numeric</code>]</dt><dd>
<p>p-values for <code>theta</code></p>
</dd>
<dt><code>theta.all</code> [<code>numeric</code>]</dt><dd>
<p>combined coefficients of <code>beta</code>, <code>delta</code> and the auxiliary
leads-and-lags regressors</p>
</dd>
<dt><code>residuals</code> [<code>numeric</code>]</dt><dd>
<p>D-OLS residuals (length depends on leads and lags)</p>
</dd>
<dt><code>omega.u.v</code> [<code>numeric</code>]</dt><dd>
<p>conditional long-run variance based on OLS residuals</p>
</dd>
<dt><code>varmat</code> [<code>matrix</code>]</dt><dd>
<p>variance-covariance matrix</p>
</dd>
<dt><code>Omega</code> [<code>list</code>]</dt><dd>
<p>the whole long-run variance matrix and parts of it</p>
</dd>
<dt><code>bandwidth</code> [<code>list</code>]</dt><dd>
<p>number and name of the calculated bandwidth</p>
</dd>
<dt><code>kernel</code> [<code>character</code>]</dt><dd>
<p>abbr. name of kernel type</p>
</dd>
<dt><code>lead.lag</code> [<code>list</code>]</dt><dd>
<p>leads-and-lags parameters</p>
</dd>
</dl>



<h3>References</h3>


<ul>
<li><p> Phillips, P.C.B. and M. Loretan (1991): &quot;Estimating Long Run
Economic Equilibria,&quot; <em>Review of Economic Studies</em>, 58,
407&ndash;436,
<a href="http://dx.doi.org/10.2307/2298004">DOI:10.2307/2298004</a>.
</p>
</li>
<li><p> Saikkonen, P. (1991): &quot;Asymptotically Efficient Estimation of
Cointegrating Regressions,&quot; <em>Econometric Theory</em>, 7, 1&ndash;21,
<a href="http://dx.doi.org/10.1017/S0266466600004217">DOI:10.1017/S0266466600004217</a>.
</p>
</li>
<li><p> Stock, J.H. and M.W. Watson (1993): &quot;A Simple Estimator of
Cointegrating Vectors in Higher Order Integrated Systems,&quot;
<em>Econometrica</em>, 61, 783&ndash;820,
<a href="http://dx.doi.org/10.2307/2951763">DOI:10.2307/2951763</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other cointReg: <code><a href="#topic+cointRegFM">cointRegFM</a></code>,
<code><a href="#topic+cointRegIM">cointRegIM</a></code>, <code><a href="#topic+cointReg">cointReg</a></code>,
<code><a href="#topic+plot.cointReg">plot.cointReg</a></code>, <code><a href="#topic+print.cointReg">print.cointReg</a></code>
</p>
<p>Other D-OLS: <code><a href="#topic+getLeadLag">getLeadLag</a></code>,
<code><a href="#topic+getModD">getModD</a></code>, <code><a href="#topic+makeLeadLagMatrix">makeLeadLagMatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1909)
x1 &lt;- cumsum(rnorm(100, mean = 0.05, sd = 0.1))
x2 &lt;- cumsum(rnorm(100, sd = 0.1)) + 1
x3 &lt;- cumsum(rnorm(100, sd = 0.2)) + 2
x &lt;- cbind(x1, x2, x3)
y &lt;- x1 + x2 + x3 + rnorm(100, sd = 0.2) + 1
deter &lt;- cbind(level = 1, trend = 1:100)
test &lt;- cointRegD(x, y, deter, n.lead = 2, n.lag = 2,
                    kernel = "ba", bandwidth = "and")
print(test)
test2 &lt;- cointRegD(x, y, deter, kmax = "k4", info.crit = "BIC",
                     kernel = "ba", bandwidth = "and")
print(test2)

</code></pre>

<hr>
<h2 id='cointRegFM'>Fully Modified OLS</h2><span id='topic+cointRegFM'></span>

<h3>Description</h3>

<p>Computes the Phillips and Hansen (1990) Fully Modified OLS estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cointRegFM(x, y, deter, kernel = c("ba", "pa", "qs", "tr"),
  bandwidth = c("and", "nw"), demeaning = FALSE, check = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cointRegFM_+3A_x">x</code></td>
<td>
<p>[<code>numeric</code> | <code>matrix</code> | <code>data.frame</code>]<br />
RHS variables on which to apply the FM-OLS estimation (see Details).</p>
</td></tr>
<tr><td><code id="cointRegFM_+3A_y">y</code></td>
<td>
<p>[<code>numeric</code> | <code>matrix</code> | <code>data.frame</code>]<br />
LHS variable(s) on which to apply the FM-OLS estimation (see Details).
Usually one-dimensional, but a <code>matrix</code> or
<code>data.frame</code> with more than one column is also possible.</p>
</td></tr>
<tr><td><code id="cointRegFM_+3A_deter">deter</code></td>
<td>
<p>[<code>numeric</code> | <code>matrix</code> | <code>data.frame</code> |
<code>NULL</code>]<br />
Deterministic variable to include in the equation (see Details). If it's
<code>NULL</code> or missing, no deterministic variable is included in the model.</p>
</td></tr>
<tr><td><code id="cointRegFM_+3A_kernel">kernel</code></td>
<td>
<p>[<code>character(1)</code>]<br />
The kernel function to use for calculating the long-run variance.
Default is Bartlett kernel (<code>"ba"</code>), see Details for alternatives.</p>
</td></tr>
<tr><td><code id="cointRegFM_+3A_bandwidth">bandwidth</code></td>
<td>
<p>[<code>character(1)</code> | <code>integer(1)</code>]<br />
The bandwidth to use for calculating the long-run variance.
Default is Andrews (1991) (<code>"and"</code>), an alternative is Newey West
(1994) (<code>"nw"</code>).</p>
</td></tr>
<tr><td><code id="cointRegFM_+3A_demeaning">demeaning</code></td>
<td>
<p>[<code>logical</code>]<br />
Demeaning of residuals in <code><a href="#topic+getLongRunVar">getLongRunVar</a></code>.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cointRegFM_+3A_check">check</code></td>
<td>
<p>[<code>logical</code>]<br />
Wheather to check (and if necessary convert) the arguments.
See <code><a href="#topic+checkVars">checkVars</a></code> for further information.</p>
</td></tr>
<tr><td><code id="cointRegFM_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+getBandwidthNW">getBandwidthNW</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The equation for which the FM-OLS estimator is calculated:
</p>
<p style="text-align: center;"><code class="reqn">y = \delta \cdot D + \beta \cdot x + u</code>
</p>

<p>with <code class="reqn">D</code> as the deterministics matrix.
Then <code class="reqn">\theta = (\delta', \beta')'</code> is the full parameter vector.
</p>
<p>The calculation of t-values and the variance-covariance matrix is only
possible, if <code>y</code> is one-dimensional.
</p>


<h3>Value</h3>

<p>[<code>cointReg</code>]. List with components:
</p>

<dl>
<dt><code>delta</code> [<code>numeric</code> | <code>matrix</code>]</dt><dd>
<p>coefficients as vector / matrix</p>
</dd>
<dt><code>beta</code> [<code>numeric</code> | <code>matrix</code>]</dt><dd>
<p>coefficients as vector / matrix</p>
</dd>
<dt><code>theta</code> [<code>numeric</code> | <code>matrix</code>]</dt><dd>
<p>combined coefficients of
<code>beta</code> and <code>delta</code> as vector / matrix</p>
</dd>
<dt><code>sd.theta</code> [<code>numeric</code>]</dt><dd>
<p>standard errors for <code>theta</code></p>
</dd>
<dt><code>t.theta</code> [<code>numeric</code>]</dt><dd>
<p>t-values for <code>theta</code></p>
</dd>
<dt><code>p.theta</code> [<code>numeric</code>]</dt><dd>
<p>p-values for <code>theta</code></p>
</dd>
<dt><code>residuals</code> [<code>numeric</code>]</dt><dd>
<p>FM-OLS residuals (first value is always missing)</p>
</dd>
<dt><code>omega.u.v</code> [<code>numeric</code>]</dt><dd>
<p>conditional long-run variance based on OLS residuals.</p>
</dd>
<dt><code>varmat</code> [<code>matrix</code>]</dt><dd>
<p>variance-covariance matrix</p>
</dd>
<dt><code>Omega</code> [<code>list</code>]</dt><dd>
<p>the whole long-run variance matrix and parts of it</p>
</dd>
<dt><code>beta.OLS</code> [<code>numeric</code> | <code>matrix</code>]</dt><dd>
<p>OLS coefficients as vector / matrix</p>
</dd>
<dt><code>delta.OLS</code> [<code>numeric</code> | <code>matrix</code>]</dt><dd>
<p>OLS coefficients as vector / matrix</p>
</dd>
<dt><code>u.OLS</code> [<code>numeric</code>]</dt><dd>
<p>OLS residuals</p>
</dd>
<dt><code>bandwidth</code> [<code>list</code>]</dt><dd>
<p><code>number</code> and <code>name</code> of bandwidth</p>
</dd>
<dt><code>kernel</code> [<code>character</code>]</dt><dd>
<p>abbr. name of kernel type</p>
</dd>
</dl>



<h3>References</h3>


<ul>
<li><p> Phillips, P.C.B. and B. Hansen (1990): &quot;Statistical Inference in
Instrumental Variables Regression with I(1) Processes,&quot;
<em>Review of Economic Studies</em>, 57, 99&ndash;125,
<a href="http://dx.doi.org/10.2307/2297545">DOI:10.2307/2297545</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other cointReg: <code><a href="#topic+cointRegD">cointRegD</a></code>,
<code><a href="#topic+cointRegIM">cointRegIM</a></code>, <code><a href="#topic+cointReg">cointReg</a></code>,
<code><a href="#topic+plot.cointReg">plot.cointReg</a></code>, <code><a href="#topic+print.cointReg">print.cointReg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1909)
x1 = cumsum(rnorm(100, mean = 0.05, sd = 0.1))
x2 = cumsum(rnorm(100, sd = 0.1)) + 1
x3 = cumsum(rnorm(100, sd = 0.2)) + 2
x = cbind(x1, x2, x3)
y = x1 + x2 + x3 + rnorm(100, sd = 0.2) + 1
deter = cbind(level = 1, trend = 1:100)
test = cointRegFM(x, y, deter, kernel = "ba", bandwidth = "and")
print(test)

</code></pre>

<hr>
<h2 id='cointRegIM'>Integrated Modified OLS</h2><span id='topic+cointRegIM'></span>

<h3>Description</h3>

<p>Computes the Vogelsang and Wagner (2014) Integrated Modified OLS estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cointRegIM(x, y, deter, selector = 1, t.test = TRUE, kernel = c("ba",
  "pa", "qs", "tr"), bandwidth = c("and", "nw"), check = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cointRegIM_+3A_x">x</code></td>
<td>
<p>[<code>numeric</code> | <code>matrix</code> | <code>data.frame</code>]<br />
RHS variables on which to apply the IM-OLS estimation (see Details).</p>
</td></tr>
<tr><td><code id="cointRegIM_+3A_y">y</code></td>
<td>
<p>[<code>numeric</code> | <code>matrix</code> | <code>data.frame</code>]<br />
LHS variable(s) on which to apply the IM-OLS estimation (see Details).
Has to be one-dimensional. If <code>matrix</code>, it may
have only one row or column, if <code>data.frame</code> just one column.</p>
</td></tr>
<tr><td><code id="cointRegIM_+3A_deter">deter</code></td>
<td>
<p>[<code>numeric</code> | <code>matrix</code> | <code>data.frame</code> |
<code>NULL</code>]<br />
Deterministic variable to include in the equation (see Details). If it's
<code>NULL</code> or missing, no deterministic variable is included in the model.</p>
</td></tr>
<tr><td><code id="cointRegIM_+3A_selector">selector</code></td>
<td>
<p>[<code>numeric</code>]<br />
Choose the regression type: <code>1</code>, <code>2</code>, or <code>c(1, 2)</code>
(see Details). Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="cointRegIM_+3A_t.test">t.test</code></td>
<td>
<p>[<code>logical</code>]<br />
Wheather to calculate t-values for the coefficients of the first
regression. Default is <code>TRUE</code>. Attention: Needs more calculation
time, because an additional FM-OLS model has to be fitted to get the
long-run variance.</p>
</td></tr>
<tr><td><code id="cointRegIM_+3A_kernel">kernel</code></td>
<td>
<p>[<code>character(1)</code>]<br />
The kernel function to use for calculating the long-run variance.
Default is Bartlett kernel (<code>"ba"</code>), see Details for alternatives.</p>
</td></tr>
<tr><td><code id="cointRegIM_+3A_bandwidth">bandwidth</code></td>
<td>
<p>[<code>character(1)</code> | <code>integer(1)</code>]<br />
The bandwidth to use for calculating the long-run variance.
Default is Andrews (1991) (<code>"and"</code>), an alternative is Newey West
(1994) (<code>"nw"</code>).</p>
</td></tr>
<tr><td><code id="cointRegIM_+3A_check">check</code></td>
<td>
<p>[<code>logical</code>]<br />
Wheather to check (and if necessary convert) the arguments.
See <code><a href="#topic+checkVars">checkVars</a></code> for further information.</p>
</td></tr>
<tr><td><code id="cointRegIM_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+getBandwidthNW">getBandwidthNW</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The equation for which the IM-OLS estimator is calculated (type 1):
</p>
<p style="text-align: center;"><code class="reqn">S_y = \delta \cdot S_{D} + \beta \cdot S_{x} + \gamma \cdot x + u</code>
</p>

<p>where <code class="reqn">S_y</code>, <code class="reqn">S_x</code> and <code class="reqn">S_D</code> are the cumulated
sums of <code class="reqn">y</code>, <code class="reqn">x</code> and <code class="reqn">D</code> (with <code class="reqn">D</code> as the deterministics
matrix).
Then <code class="reqn">\theta = (\delta', \beta', \gamma')'</code> is the full parameter vector.
</p>
<p>The equation for which the IM-OLS estimator is calculated (type 2):
</p>
<p style="text-align: center;"><code class="reqn">S_y = \delta \cdot S_D + \beta \cdot S_x + \gamma \cdot x +
\lambda \cdot Z + u</code>
</p>

<p>where <code class="reqn">S_y</code>, <code class="reqn">S_x</code> and <code class="reqn">S_D</code> are the cumulated
sums of <code class="reqn">y</code>, <code class="reqn">x</code> and <code class="reqn">D</code> (with <code class="reqn">D</code> as the deterministics
matrix) and <code class="reqn">Z</code> as defined in equation (19) in Vogelsang and Wagner
(2015).
Then <code class="reqn">\theta = (\delta', \beta', \gamma', \lambda')'</code> is the full
parameter vector.
</p>


<h3>Value</h3>

<p>[<code>cointReg</code>]. List with components:
</p>

<dl>
<dt><code>delta</code> [<code>numeric</code>]</dt><dd>
<p>coefficients of the deterministics (cumulative sum <code class="reqn">S_{deter}</code>)</p>
</dd>
<dt><code>beta</code> [<code>numeric</code>]</dt><dd>
<p>coefficients of the regressors (cumulative sum <code class="reqn">S_{x}</code>)</p>
</dd>
<dt><code>gamma</code> [<code>numeric</code>]</dt><dd>
<p>coefficients of the regressors (original regressors <code class="reqn">x</code>)</p>
</dd>
<dt><code>theta</code> [<code>numeric</code>]</dt><dd>
<p>combined coefficients of <code>beta</code>, <code>delta</code></p>
</dd>
<dt><code>sd.theta</code> [<code>numeric</code>]</dt><dd>
<p>standard errors for the <code>theta</code> coefficients</p>
</dd>
<dt><code>t.theta</code> [<code>numeric</code>]</dt><dd>
<p>t-values for the <code>theta</code> coefficients</p>
</dd>
<dt><code>p.theta</code> [<code>numeric</code>]</dt><dd>
<p>p-values for the <code>theta</code> coefficients</p>
</dd>
<dt><code>theta.all</code> [<code>numeric</code>]</dt><dd>
<p>combined coefficients of <code>beta</code>, <code>delta</code>, <code>gamma</code></p>
</dd>
<dt><code>residuals</code> [<code>numeric</code>]</dt><dd>
<p>IM-OLS residuals. Attention: These are the first differences of
<code class="reqn">S_u</code> &ndash; the original residuals are stored in <code>u.plus</code>.</p>
</dd>
<dt><code>u.plus</code> [<code>numeric</code>]</dt><dd>
<p>IM-OLS residuals, not differenced. See <code>residuals</code> above.</p>
</dd>
<dt><code>omega.u.v</code> [<code>numeric</code>]</dt><dd>
<p>conditional long-run variance based on OLS residuals, via
<code>cointRegFM</code> (in case of argument <code>t.test</code> is <code>TRUE</code>)
or <code>NULL</code></p>
</dd>
<dt><code>varmat</code> [<code>matrix</code>]</dt><dd>
<p>variance-covariance matrix</p>
</dd>
<dt><code>Omega</code> [<code>matrix</code>]</dt><dd>
<p><code>NULL</code> (no long-run variance matrix for this regression type)</p>
</dd>
<dt><code>bandwidth</code> [<code>list</code>]</dt><dd>
<p><code>number</code> and <code>name</code> of bandwidth if <code>t.test = TRUE</code></p>
</dd>
<dt><code>kernel</code> [<code>character</code>]</dt><dd>
<p>abbr. name of kernel type if <code>t.test = TRUE</code></p>
</dd>
<dt><code>delta2</code> [<code>numeric</code>]</dt><dd>
<p>coefficients of the deterministics (cumulative sum <code class="reqn">S_{deter}</code>)
for regression type 2</p>
</dd>
<dt><code>beta2</code> [<code>numeric</code>]</dt><dd>
<p>coefficients of the regressors (cumulative sum <code class="reqn">S_{x}</code>)
for regression type 2</p>
</dd>
<dt><code>gamma2</code> [<code>numeric</code>]</dt><dd>
<p>coefficients of the regressors (original regressors <code class="reqn">x</code>)
for regression type 2</p>
</dd>
<dt><code>lambda2</code> [<code>numeric</code>]</dt><dd>
<p>coefficients of the Z regressors for regression type 2</p>
</dd>
<dt><code>theta2</code> [<code>numeric</code>]</dt><dd>
<p>combined coefficients of <code>beta2</code>, <code>delta2</code>, <code>gamma2</code> and
<code>lambda2</code> for regression type 2</p>
</dd>
<dt><code>u.plus2</code> [<code>numeric</code>]</dt><dd>
<p>IM-OLS residuals for regression type 2</p>
</dd>
</dl>



<h3>References</h3>


<ul>
<li><p> Vogelsang, T.J. and M. Wagner (2014): &quot;Integrated Modified OLS
Estimation and Fixed-b Inference for Cointegrating Regressions,&quot;
<em>Journal of Econometrics</em>, 148, 741&ndash;760,
<a href="http://dx.doi.org/10.1016/j.jeconom.2013.10.015">DOI:10.1016/j.jeconom.2013.10.015</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other cointReg: <code><a href="#topic+cointRegD">cointRegD</a></code>,
<code><a href="#topic+cointRegFM">cointRegFM</a></code>, <code><a href="#topic+cointReg">cointReg</a></code>,
<code><a href="#topic+plot.cointReg">plot.cointReg</a></code>, <code><a href="#topic+print.cointReg">print.cointReg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1909)
x1 = cumsum(rnorm(100, mean = 0.05, sd = 0.1))
x2 = cumsum(rnorm(100, sd = 0.1)) + 1
x3 = cumsum(rnorm(100, sd = 0.2)) + 2
x = cbind(x1, x2, x3)
y = x1 + x2 + x3 + rnorm(100, sd = 0.2) + 1
deter = cbind(level = 1, trend = 1:100)
test = cointRegIM(x, y, deter, selector = c(1, 2), t.test = TRUE,
                    kernel = "ba", bandwidth = "and")
print(test)

</code></pre>

<hr>
<h2 id='getBandwidth'>Automatic Bandwidth Selection</h2><span id='topic+getBandwidth'></span><span id='topic+getBandwidthAnd'></span><span id='topic+getBandwidthNW'></span>

<h3>Description</h3>

<p>Automatic bandwidth selection of Andrews (1991) and of Newey and West (1994).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBandwidth(u, bandwidth = c("and", "nw"), kernel, ..., check = TRUE)

getBandwidthAnd(u, kernel = c("ba", "pa", "qs", "th", "tr"), check = TRUE)

getBandwidthNW(u, kernel = c("ba", "pa", "qs"), inter = FALSE,
  u.weights = NULL, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getBandwidth_+3A_u">u</code></td>
<td>
<p>[<code>numeric</code>]<br />
Data on which to apply the bandwidth selction.</p>
</td></tr>
<tr><td><code id="getBandwidth_+3A_bandwidth">bandwidth</code></td>
<td>
<p>[<code>character(1)</code>]<br />
The bandwidth selection method to use. Default is Andrews (1991) (<code>"and"</code>),
an alternative is Newey West (1994) (<code>"nw"</code>).</p>
</td></tr>
<tr><td><code id="getBandwidth_+3A_kernel">kernel</code></td>
<td>
<p>[<code>character(1)</code>]<br />
The kernel function to use for selecting the bandwidth.
Default is Bartlett kernel (<code>"ba"</code>), see Details for alternatives.</p>
</td></tr>
<tr><td><code id="getBandwidth_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>getBandwidthNW</code>.</p>
</td></tr>
<tr><td><code id="getBandwidth_+3A_check">check</code></td>
<td>
<p>[<code>logical</code>]<br />
Wheather to check (and if necessary convert) the arguments.
See <code><a href="#topic+checkVars">checkVars</a></code> for further information.</p>
</td></tr>
<tr><td><code id="getBandwidth_+3A_inter">inter</code></td>
<td>
<p>[<code>logical</code>]<br />
The first column will be ignored, if <code>TRUE</code> (intercept).
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="getBandwidth_+3A_u.weights">u.weights</code></td>
<td>
<p>[<code>numeric</code>]<br />
How to weight the columns of <code>u</code>.
If <code>NULL</code> (default), uses identical weights for all columns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For Andrews (1991), the AR(1) individual version is implemented.
</p>
<p>The kernel that is used for calculating the long-run variance can be
one of the following:
</p>

<ul>
<li> <p><code>"ba"</code>: Bartlett kernel
</p>
</li>
<li> <p><code>"pa"</code>: Parzen kernel
</p>
</li>
<li> <p><code>"qs"</code>: Quadratic Spectral kernel
</p>
</li>
<li> <p><code>"th"</code>: Tukey-Hanning kernel (only if <code>bandwidth = "and"</code>)
</p>
</li>
<li> <p><code>"tr"</code>: Truncated kernel (only if <code>bandwidth = "and"</code>)
</p>
</li></ul>



<h3>Value</h3>

<p>[<code>numeric(1)</code>]. Bandwidth
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>getBandwidthAnd</code>: Automatic bandwidth selection of Andrews (1991).
</p>
</li>
<li> <p><code>getBandwidthNW</code>: Automatic bandwidth selection of Newey and West (1994).
</p>
</li></ul>


<h3>References</h3>


<ul>
<li><p> Andrews, D.W.K. (1991): &quot;Heteroskedasticity and Autocorrelation
Consistent Covariance Matrix Estimation,&quot; <em>Econometrica</em>, 59,
817&ndash;854, <a href="http://dx.doi.org/10.2307/2938229">DOI:10.2307/2938229</a>.
</p>
</li>
<li><p> Newey, W.K. and K.D. West (1994): &quot;Automatic Lag Selection in
Covariance Matrix Estimation&quot;, <em>Review of Economic Studies</em>, 61,
631&ndash;653, <a href="http://dx.doi.org/10.2307/2297912">DOI:10.2307/2297912</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+getLongRunVar">getLongRunVar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1909)
x &lt;- rnorm(100)
getBandwidth(x, kernel = "ba")
getBandwidth(x, bandwidth = "nw", kernel = "ba")

x2 &lt;- arima.sim(model = list(ar = c(0.7, 0.2)), innov = x, n = 100)
getBandwidth(x2, kernel = "qs")
getBandwidth(x2, bandwidth = "nw", kernel = "qs")

</code></pre>

<hr>
<h2 id='getLeadLag'>Leads and Lags</h2><span id='topic+getLeadLag'></span>

<h3>Description</h3>

<p>Generates &quot;optimal&quot; numbers of leads and lags for the Dynamic OLS estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLeadLag(x, y, deter, max.lag, max.lead, ic = c("AIC", "BIC"),
  symmet = FALSE, check = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getLeadLag_+3A_x">x</code></td>
<td>
<p>[<code>numeric</code> | <code>matrix</code> | <code>data.frame</code>]<br />
RHS variables on which to apply the D-OLS estimation (see Details).</p>
</td></tr>
<tr><td><code id="getLeadLag_+3A_y">y</code></td>
<td>
<p>[<code>numeric</code> | <code>matrix</code> | <code>data.frame</code>]<br />
LHS variable(s) on which to apply the D-OLS estimation (see Details).
Has to be one-dimensional. If <code>matrix</code>, it may
have only one row or column, if <code>data.frame</code> just one column.</p>
</td></tr>
<tr><td><code id="getLeadLag_+3A_deter">deter</code></td>
<td>
<p>[<code>numeric</code> | <code>matrix</code> | <code>data.frame</code> |
<code>NULL</code>]<br />
Deterministic variable to include in the equation (see Details). If it's
<code>NULL</code> or missing, no deterministic variable is included in the model.</p>
</td></tr>
<tr><td><code id="getLeadLag_+3A_max.lead">max.lead</code>, <code id="getLeadLag_+3A_max.lag">max.lag</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Maximal numbers of leads and lags, have to be non-negative integer values.</p>
</td></tr>
<tr><td><code id="getLeadLag_+3A_ic">ic</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Information criterion (one of <code>"AIC"</code> or <code>"BIC"</code>).</p>
</td></tr>
<tr><td><code id="getLeadLag_+3A_symmet">symmet</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
If <code>TRUE</code>, only looks for equal leads and lags.</p>
</td></tr>
<tr><td><code id="getLeadLag_+3A_check">check</code></td>
<td>
<p>[<code>logical</code>]<br />
Wheather to check (and if necessary convert) the arguments.
See <code><a href="#topic+checkVars">checkVars</a></code> for further information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>numeric(2)</code>]. &quot;Optimal&quot; numbers of leads and lags.
</p>


<h3>See Also</h3>

<p>Other D-OLS: <code><a href="#topic+cointRegD">cointRegD</a></code>,
<code><a href="#topic+getModD">getModD</a></code>, <code><a href="#topic+makeLeadLagMatrix">makeLeadLagMatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1909)
y &lt;- matrix(cumsum(rnorm(100)), ncol = 1)
x &lt;- matrix(rep(y, 4) + rnorm(400, mean = 3, sd = 2), ncol = 4)
deter &lt;- cbind(1, 1:100)
cointReg:::getLeadLag(x = x, y = y, deter = deter, max.lag = 5,
                      max.lead = 5, ic = "AIC", symmet = FALSE)
</code></pre>

<hr>
<h2 id='getLongRunVar'>Long-Run Variance</h2><span id='topic+getLongRunVar'></span>

<h3>Description</h3>

<p>This function computes the long-run variance Omega,
the one sided long-run variance Delta (starting with lag 0)
and the variance Sigma from an input matrix of residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLongRunVar(u, bandwidth = c("and", "nw"), kernel = c("ba", "bo", "da",
  "pa", "qs", "tr"), demeaning = FALSE, check = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getLongRunVar_+3A_u">u</code></td>
<td>
<p>[<code>numeric</code> | <code>matrix</code>]<br />
Data on which to apply the calculation of the long-run variance.</p>
</td></tr>
<tr><td><code id="getLongRunVar_+3A_bandwidth">bandwidth</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
The bandwidth to use for calculating the long-run variance
as a positive intergerish value.</p>
</td></tr>
<tr><td><code id="getLongRunVar_+3A_kernel">kernel</code></td>
<td>
<p>[<code>character(1)</code>]<br />
The kernel function to use for selecting the bandwidth.
Default is Bartlett kernel (<code>"ba"</code>), see Details for alternatives.</p>
</td></tr>
<tr><td><code id="getLongRunVar_+3A_demeaning">demeaning</code></td>
<td>
<p>[<code>logical</code>]<br />
Demeaning of the data before the calculation (default is <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="getLongRunVar_+3A_check">check</code></td>
<td>
<p>[<code>logical</code>]<br />
Wheather to check (and if necessary convert) the arguments.
See <code><a href="#topic+checkVars">checkVars</a></code> for further information.</p>
</td></tr>
<tr><td><code id="getLongRunVar_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>getBandwidthNW</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The bandwidth can be one of the following:
</p>

<ul>
<li> <p><code>"ba"</code>: Bartlett kernel
</p>
</li>
<li> <p><code>"bo"</code>: Bohmann kernel
</p>
</li>
<li> <p><code>"da"</code>: Daniell kernel
</p>
</li>
<li> <p><code>"pa"</code>: Parzen kernel
</p>
</li>
<li> <p><code>"qs"</code>: Quadratic Spectral kernel
</p>
</li>
<li> <p><code>"tr"</code>: Truncated kernel
</p>
</li></ul>



<h3>Value</h3>

<p>[<code>list</code>] with components:
</p>

<dl>
<dt><code>Omega</code> [<code>matrix</code>]</dt><dd>
<p>Long-run variance matrix</p>
</dd>
<dt><code>Delta</code> [<code>matrix</code>]</dt><dd>
<p>One-sided long-run variance matrix</p>
</dd>
<dt><code>Sigma</code> [<code>matrix</code>]</dt><dd>
<p>Variance matrix</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+getBandwidth">getBandwidth</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1909)
x &lt;- rnorm(100)
band &lt;- getBandwidthAnd(x, kernel = "ba")
getLongRunVar(x, kernel = "ba", bandwidth = band)
# shorter:
getLongRunVar(x, kernel = "ba", bandwidth = "and")

x2 &lt;- arima.sim(model = list(ar = c(0.7, 0.2)), innov = x, n = 100)
x2 &lt;- cbind(a = x2, b = x2 + rnorm(100))
getLongRunVar(x2, kernel = "ba", bandwidth = "nw")

</code></pre>

<hr>
<h2 id='getLongRunWeights'>Weights for Long-Run Variance</h2><span id='topic+getLongRunWeights'></span>

<h3>Description</h3>

<p>Compute the weights corresponding to some kernel funtions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLongRunWeights(n, bandwidth, kernel)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getLongRunWeights_+3A_n">n</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Length of weights' vector.</p>
</td></tr>
<tr><td><code id="getLongRunWeights_+3A_bandwidth">bandwidth</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
The bandwidth (as number).</p>
</td></tr>
<tr><td><code id="getLongRunWeights_+3A_kernel">kernel</code></td>
<td>
<p>[<code>character(1)</code>]<br />
The kernel function (see <code><a href="#topic+getLongRunVar">getLongRunVar</a></code> for possible values).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>list</code>] with components:
</p>

<dl>
<dt><code>w</code> [<code>numeric</code>]</dt><dd>
<p>Vector of weights</p>
</dd>
<dt><code>upper</code> [<code>numeric(1)</code>]</dt><dd>
<p>Index to largest non-zero entry in w</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+getLongRunVar">getLongRunVar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lrw.ba = cointReg:::getLongRunWeights(100, kernel = "ba", bandwidth = 25)
plot(lrw.ba$w)

</code></pre>

<hr>
<h2 id='getModD'>Get D OLS model.</h2><span id='topic+getModD'></span>

<h3>Description</h3>

<p>Generates an <code>lm</code> model for the Dynamic OLS estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getModD(x, y, deter, n.lag, n.lead, check = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getModD_+3A_x">x</code></td>
<td>
<p>[<code>matrix</code>]<br />
RHS variables of the D OLS estimation.</p>
</td></tr>
<tr><td><code id="getModD_+3A_y">y</code></td>
<td>
<p>[<code>matrix</code>]<br />
LHS variable(s) of the D OLS estimation.</p>
</td></tr>
<tr><td><code id="getModD_+3A_deter">deter</code></td>
<td>
<p>[<code>matrix</code>]<br />
Matrix of deterministic variables to include in the D OLS model.</p>
</td></tr>
<tr><td><code id="getModD_+3A_n.lag">n.lag</code>, <code id="getModD_+3A_n.lead">n.lead</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Number of lags and leads, have to be non-negative integer values.</p>
</td></tr>
<tr><td><code id="getModD_+3A_check">check</code></td>
<td>
<p>[<code>logical</code>]<br />
Wheather to check (and if necessary convert) the arguments.
See <code><a href="#topic+checkVars">checkVars</a></code> for further information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>lm</code>]. An <code><a href="stats.html#topic+lm">lm</a></code> object, containing an additional
list element (<code>aux</code>) with D-OLS specific objects:
</p>

<dl>
<dt><code>Z</code> [<code>matrix</code>]</dt><dd>
<p>jointed matrix of deterministics and x</p>
</dd>
<dt><code>x.delta</code> [<code>matrix</code>]</dt><dd>
<p>differences of x</p>
</dd>
<dt><code>dx.all</code> [<code>matrix</code>]</dt><dd>
<p>leads-and-lags matrix</p>
</dd>
<dt><code>all.trunc</code> [<code>matrix</code>]</dt><dd>
<p>truncated version of jointed matrix of <code>Z</code> and <code>dx.all</code></p>
</dd>
<dt><code>y.trunc</code> [<code>matrix</code>]</dt><dd>
<p>truncated version of <code>y</code></p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other D-OLS: <code><a href="#topic+cointRegD">cointRegD</a></code>,
<code><a href="#topic+getLeadLag">getLeadLag</a></code>, <code><a href="#topic+makeLeadLagMatrix">makeLeadLagMatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1909)
y &lt;- matrix(cumsum(rnorm(100)), ncol = 1)
x &lt;- matrix(rep(y, 4) + rnorm(400, mean = 3, sd = 2), ncol = 4)
deter &lt;- cbind(1, 1:100)
cointReg:::getModD(x = x, y = y, deter = deter, n.lag = 2, n.lead = 3)
</code></pre>

<hr>
<h2 id='makeLeadLagMatrix'>Leads-and-Lags Matrix</h2><span id='topic+makeLeadLagMatrix'></span>

<h3>Description</h3>

<p>Generates leads-and-lags matrix for the Dynamic OLS estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeLeadLagMatrix(x, n.lag, n.lead)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeLeadLagMatrix_+3A_x">x</code></td>
<td>
<p>[<code>matrix</code>]<br />
Matrix for which to generate the leads-and-lags matrix.</p>
</td></tr>
<tr><td><code id="makeLeadLagMatrix_+3A_n.lag">n.lag</code>, <code id="makeLeadLagMatrix_+3A_n.lead">n.lead</code></td>
<td>
<p>[<code>numeric(1)</code>]<br />
Number of lags and leads, have to be non-negative integer values.
If greater than <code>nrow(x)</code>, produces 0-rows.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[<code>matrix</code>]. Leads-and-lags matrix.
</p>


<h3>See Also</h3>

<p>Other D-OLS: <code><a href="#topic+cointRegD">cointRegD</a></code>,
<code><a href="#topic+getLeadLag">getLeadLag</a></code>, <code><a href="#topic+getModD">getModD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(1:20, 2, byrow = TRUE)
cointReg:::makeLeadLagMatrix(x = x, n.lag = 2, n.lead = 3)
</code></pre>

<hr>
<h2 id='plot.cointReg'>Plot Method for Cointegration Models (Modified OLS).</h2><span id='topic+plot.cointReg'></span>

<h3>Description</h3>

<p>Plotting objects of class <code>"cointReg"</code>. Currently, only the residuals
will be plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cointReg'
plot(x, type, main, xlab, ylab, axes = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.cointReg_+3A_x">x</code></td>
<td>
<p>[<code>cointReg</code>]<br />
Object of class <code>"cointReg"</code>, i.e. the result of
<code><a href="#topic+cointRegFM">cointRegFM</a></code>, <code><a href="#topic+cointRegD">cointRegD</a></code>,
or <code><a href="#topic+cointRegIM">cointRegIM</a></code>.</p>
</td></tr>
<tr><td><code id="plot.cointReg_+3A_type">type</code></td>
<td>
<p>[<code>character</code>]<br />
Plot type (from <code><a href="base.html#topic+plot">plot</a></code>). Default is <code>"l"</code>.</p>
</td></tr>
<tr><td><code id="plot.cointReg_+3A_main">main</code>, <code id="plot.cointReg_+3A_xlab">xlab</code>, <code id="plot.cointReg_+3A_ylab">ylab</code></td>
<td>
<p>[<code>character</code>]<br />
Title and axis titles (from <code><a href="base.html#topic+plot">plot</a></code>). Default values will be
generated from the contents of <code>x</code>.</p>
</td></tr>
<tr><td><code id="plot.cointReg_+3A_axes">axes</code></td>
<td>
<p>[<code>logical</code>]<br />
Whether to add axes (from <code><a href="base.html#topic+plot">plot</a></code>) to the plot.</p>
</td></tr>
<tr><td><code id="plot.cointReg_+3A_...">...</code></td>
<td>
<p>[<code>any</code>]<br />
Further arguments passed to <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other cointReg: <code><a href="#topic+cointRegD">cointRegD</a></code>,
<code><a href="#topic+cointRegFM">cointRegFM</a></code>, <code><a href="#topic+cointRegIM">cointRegIM</a></code>,
<code><a href="#topic+cointReg">cointReg</a></code>, <code><a href="#topic+print.cointReg">print.cointReg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
x = data.frame(x1 = cumsum(rnorm(200)), x2 = cumsum(rnorm(200)))
eps1 = rnorm(200, sd = 2)
y = x$x1 - x$x2 + 10 + eps1
deter = cbind(level = rep(1, 200))
test = cointRegFM(x = x, y = y, deter = deter)
plot(test)

</code></pre>

<hr>
<h2 id='print.cointReg'>Print Method for Cointegration Models (Modified OLS).</h2><span id='topic+print.cointReg'></span>

<h3>Description</h3>

<p>Printing objects of class <code>"cointReg"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cointReg'
print(x, ..., digits = getOption("digits"),
  all.coeffs = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.cointReg_+3A_x">x</code></td>
<td>
<p>[<code>cointReg</code>]<br />
Object of class <code>"cointReg"</code>, i.e. the result of
<code>cointRegFM</code>, <code>cointRegD</code> or <code>cointRegIM</code>.</p>
</td></tr>
<tr><td><code id="print.cointReg_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="print.cointReg_+3A_digits">digits</code></td>
<td>
<p>[<code>numeric</code>]<br />
Number of significant digits to be used.</p>
</td></tr>
<tr><td><code id="print.cointReg_+3A_all.coeffs">all.coeffs</code></td>
<td>
<p>[<code>logical</code>]<br />
Whether to show all coefficients (i. e. the &quot;real&quot; regressors AND the
auxiliary regressors). Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The invisible <code>x</code> object.
</p>


<h3>See Also</h3>

<p>Other cointReg: <code><a href="#topic+cointRegD">cointRegD</a></code>,
<code><a href="#topic+cointRegFM">cointRegFM</a></code>, <code><a href="#topic+cointRegIM">cointRegIM</a></code>,
<code><a href="#topic+cointReg">cointReg</a></code>, <code><a href="#topic+plot.cointReg">plot.cointReg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
x = data.frame(x1 = cumsum(rnorm(200)), x2 = cumsum(rnorm(200)))
eps1 = rnorm(200, sd = 2)
y = x$x1 - x$x2 + 10 + eps1
deter = cbind(level = rep(1, 200))

test.fm = cointRegFM(x = x, y = y, deter = deter)
print(test.fm)

test.d = cointRegD(x = x, y = y, deter = deter)
print(test.d)

test.im2 = cointRegIM(x = x, y = y, deter = deter)
print(test.im2)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
