<!DOCTYPE html><html><head><title>Help for package ctsem</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ctsem}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AnomAuth'><p>AnomAuth</p></a></li>
<li><a href='#ctACF'><p>Continuous Time Autocorrelation Function (ctACF)</p></a></li>
<li><a href='#ctACFresiduals'><p>Calculate Continuous Time Autocorrelation Function (ACF) for Standardized Residuals of ctsem fit.</p></a></li>
<li><a href='#ctAddSamples'><p>Sample more values from an optimized ctstanfit object</p></a></li>
<li><a href='#ctCheckFit'><p>Visual model fit diagnostics for ctsem fit objects.</p></a></li>
<li><a href='#ctChisqTest'><p>Chi Square test wrapper for ctStanFit objects.</p></a></li>
<li><a href='#ctCollapse'><p>ctCollapse</p>
Easily collapse an array margin using a specified function.</a></li>
<li><a href='#ctDeintervalise'><p>ctDeintervalise</p></a></li>
<li><a href='#ctDensity'><p>ctDensity</p></a></li>
<li><a href='#ctDiscretiseData'><p>Discretise long format continuous time (ctsem) data to specific timestep.</p></a></li>
<li><a href='#ctDocs'><p>Get documentation pdf for ctsem</p></a></li>
<li><a href='#ctExample1'><p>ctExample1</p></a></li>
<li><a href='#ctExample1TIpred'><p>ctExample1TIpred</p></a></li>
<li><a href='#ctExample2'><p>ctExample2</p></a></li>
<li><a href='#ctExample2level'><p>ctExample2level</p></a></li>
<li><a href='#ctExample3'><p>ctExample3</p></a></li>
<li><a href='#ctExample4'><p>ctExample4</p></a></li>
<li><a href='#ctExtract'><p>Extract samples from a ctStanFit object</p></a></li>
<li><a href='#ctFit'><p>ctFit function placeholder</p></a></li>
<li><a href='#ctFitMultiModel'><p>Fit and summarise a list of ctsem models</p></a></li>
<li><a href='#ctGenerate'><p>ctGenerate</p></a></li>
<li><a href='#ctIndplot'><p>ctIndplot</p></a></li>
<li><a href='#ctIntervalise'><p>Converts absolute times to intervals for wide format ctsem panel data</p></a></li>
<li><a href='#ctKalman'><p>ctKalman</p></a></li>
<li><a href='#ctLongToWide'><p>ctLongToWide</p>
Restructures time series / panel data from long format to wide format for ctsem analysis</a></li>
<li><a href='#ctLOO'><p>K fold cross validation for ctStanFit objects</p></a></li>
<li><a href='#ctModel'><p>Define a ctsem model</p></a></li>
<li><a href='#ctModelHigherOrder'><p>Raise the order of a ctsem model object of type 'omx'.</p></a></li>
<li><a href='#ctModelLatex'><p>Generate and optionally compile latex equation of subject level ctsem model.</p></a></li>
<li><a href='#ctPlotArray'><p>Plots three dimensional y values for quantile plots</p></a></li>
<li><a href='#ctPoly'><p>Plots uncertainty bands with shading</p></a></li>
<li><a href='#ctPostPredData'><p>Create a data.table to compare data generated from a ctsem fit with the original data.</p></a></li>
<li><a href='#ctPostPredPlots'><p>Create diagnostic plots to assess the goodness-of-fit for a ctsem model.</p></a></li>
<li><a href='#ctResiduals'><p>Extract Standardized Residuals from a ctsem Fit</p></a></li>
<li><a href='#ctsem-package'><p>ctsem</p></a></li>
<li><a href='#ctStanContinuousPars'><p>ctStanContinuousPars</p></a></li>
<li><a href='#ctStanDiscretePars'><p>ctStanDiscretePars</p></a></li>
<li><a href='#ctStanDiscreteParsPlot'><p>ctStanDiscreteParsPlot</p></a></li>
<li><a href='#ctStanFit'><p>ctStanFit</p></a></li>
<li><a href='#ctStanFitUpdate'><p>Update a ctStanFit object</p></a></li>
<li><a href='#ctStanGenerate'><p>Generate data from a ctstanmodel object</p></a></li>
<li><a href='#ctStanGenerateFromFit'><p>Add a <code>$generated</code> object to ctstanfit object, with random data generated from posterior of ctstanfit object</p></a></li>
<li><a href='#ctStanKalman'><p>Get Kalman filter estimates from a ctStanFit object</p></a></li>
<li><a href='#ctStanModel'><p>Convert a frequentist (omx) ctsem model specification to Bayesian (Stan).</p></a></li>
<li><a href='#ctStanParnames'><p>ctStanParnames</p></a></li>
<li><a href='#ctStanPlotPost'><p>ctStanPlotPost</p></a></li>
<li><a href='#ctStanPostPredict'><p>Compares model implied density and values to observed, for a ctStanFit object.</p></a></li>
<li><a href='#ctStanSubjectPars'><p>Extract an array of subject specific parameters from a ctStanFit object.</p></a></li>
<li><a href='#ctstantestdat'><p>ctstantestdat</p></a></li>
<li><a href='#ctstantestfit'><p>ctstantestfit</p></a></li>
<li><a href='#ctStanTIpredeffects'><p>Get time independent predictor effect estimates</p></a></li>
<li><a href='#ctStanUpdModel'><p>Update an already compiled and fit ctStanFit object</p></a></li>
<li><a href='#ctWideNames'><p>ctWideNames</p>
sets default column names for wide ctsem datasets. Primarily intended for internal ctsem usage.</a></li>
<li><a href='#ctWideToLong'><p>ctWideToLong</p>
Convert ctsem wide to long format</a></li>
<li><a href='#datastructure'><p>datastructure</p></a></li>
<li><a href='#inv_logit'><p>Inverse logit</p></a></li>
<li><a href='#isdiag'><p>Diagnostics for ctsem importance sampling</p></a></li>
<li><a href='#log1p_exp'><p>log1p_exp</p></a></li>
<li><a href='#longexample'><p>longexample</p></a></li>
<li><a href='#Oscillating'><p>Oscillating</p></a></li>
<li><a href='#plot.ctKalmanDF'><p>Plots Kalman filter output from ctKalman.</p></a></li>
<li><a href='#plot.ctStanFit'><p>plot.ctStanFit</p></a></li>
<li><a href='#plot.ctStanModel'><p>Prior plotting</p></a></li>
<li><a href='#sdpcor2cov'><p>sdcor2cov</p></a></li>
<li><a href='#stan_checkdivergences'><p>Analyse divergences in a stanfit object</p></a></li>
<li><a href='#stan_reinitsf'><p>Quickly initialise stanfit object from model and data</p></a></li>
<li><a href='#stan_unconstrainsamples'><p>Convert samples from a stanfit object to the unconstrained scale</p></a></li>
<li><a href='#standatact_specificsubjects'><p>Adjust standata from ctsem to only use specific subjects</p></a></li>
<li><a href='#stanoptimis'><p>Optimize / importance sample a stan or ctStan model.</p></a></li>
<li><a href='#stanWplot'><p>Runs stan, and plots sampling information while sampling.</p></a></li>
<li><a href='#summary.ctStanFit'><p>summary.ctStanFit</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Continuous Time Structural Equation Modelling</td>
</tr>
<tr>
<td>Version:</td>
<td>3.9.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-30</td>
</tr>
<tr>
<td>Description:</td>
<td>Hierarchical continuous (and discrete) time state space modelling, for linear
    and nonlinear systems measured by  continuous variables, with limited support for 
    binary data. The subject specific dynamic system is modelled as a stochastic 
    differential equation (SDE) or difference equation, measurement models are typically multivariate normal factor models. 
    Linear mixed effects SDE's estimated via maximum likelihood and optimization are the default.
    Nonlinearities,  (state dependent parameters) and random effects on all parameters
    are possible, using either max likelihood / max a posteriori optimization 
    (with optional importance sampling) or Stan's Hamiltonian Monte Carlo sampling. 
    See  <a href="https://github.com/cdriveraus/ctsem/raw/master/vignettes/hierarchicalmanual.pdf">https://github.com/cdriveraus/ctsem/raw/master/vignettes/hierarchicalmanual.pdf</a>
    for details. Priors may be used. For the conceptual overview of the hierarchical Bayesian 
    linear SDE approach, 
    see <a href="https://www.researchgate.net/publication/324093594_Hierarchical_Bayesian_Continuous_Time_Dynamic_Modeling">https://www.researchgate.net/publication/324093594_Hierarchical_Bayesian_Continuous_Time_Dynamic_Modeling</a>.
    Exogenous inputs may also be included, for an overview of such possibilities see <a href="https://www.researchgate.net/publication/328221807_Understanding_the_Time_Course_of_Interventions_with_Continuous_Time_Dynamic_Models">https://www.researchgate.net/publication/328221807_Understanding_the_Time_Course_of_Interventions_with_Continuous_Time_Dynamic_Models</a> .
    Stan based functions are not available on 32 bit Windows systems at present. 
    <a href="https://cdriver.netlify.app/">https://cdriver.netlify.app/</a> contains some tutorial blog posts.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2.0), Rcpp (&ge; 0.12.16)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/cdriveraus/ctsem">https://github.com/cdriveraus/ctsem</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>cOde, data.table (&ge; 1.12.8), datasets, Deriv, expm, ggplot2,
graphics, grDevices, MASS, Matrix, methods, mize, mvtnorm,
parallel, plyr, RcppParallel (&ge; 5.0.1), rstan (&ge; 2.26.0),
rstantools (&ge; 2.3.0), stats, tibble, tools, utils</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH (&ge; 1.66.0-1), Rcpp (&ge; 0.12.16), RcppEigen (&ge;
0.3.3.4.0), RcppParallel (&ge; 5.0.1), rstan (&ge; 2.26),
StanHeaders (&ge; 2.26.0), RcppParallel (&ge; 5.0.1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, testthat, devtools, DEoptim, tinytex, lme4, shiny,
gridExtra, arules</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-30 12:24:21 UTC; Driver</td>
</tr>
<tr>
<td>Author:</td>
<td>Charles Driver [aut, cre, cph],
  Manuel Voelkle [aut, cph],
  Han Oud [aut, cph],
  Trustees of Columbia University [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Charles Driver &lt;charles.driver@ife.uzh.ch&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-30 14:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='AnomAuth'>AnomAuth</h2><span id='topic+AnomAuth'></span>

<h3>Description</h3>

<p>A dataset containing panel data assessments of individuals Anomia and Authoritarianism.
</p>


<h3>Format</h3>

<p>data frame with 2722 rows, 14 columns. Column Y1 represents anomia, 
Y2 Authoritarianism, dTx the time interval for measurement occasion x.
</p>


<h3>Source</h3>

<p>See <a href="https://psycnet.apa.org/record/2012-09124-001">https://psycnet.apa.org/record/2012-09124-001</a> for details.
</p>

<hr>
<h2 id='ctACF'>Continuous Time Autocorrelation Function (ctACF)</h2><span id='topic+ctACF'></span>

<h3>Description</h3>

<p>This function computes an approximate continuous time autocorrelation function (ACF) for data
containing multiple subjects and/or variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctACF(
  dat,
  varnames = "auto",
  ccfnames = "all",
  idcol = "id",
  timecol = "time",
  plot = TRUE,
  timestep = "auto",
  time.max = "auto",
  nboot = 100,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctACF_+3A_dat">dat</code></td>
<td>
<p>The input data in data frame or data table format.</p>
</td></tr>
<tr><td><code id="ctACF_+3A_varnames">varnames</code></td>
<td>
<p>Character vector of variable names in the data to compute the ACF for. 'auto' uses all columns that are not time / id.</p>
</td></tr>
<tr><td><code id="ctACF_+3A_ccfnames">ccfnames</code></td>
<td>
<p>Character vector of variable names in the data to compute cross correlation for. 'all' uses all variables in varnames.</p>
</td></tr>
<tr><td><code id="ctACF_+3A_idcol">idcol</code></td>
<td>
<p>The name of the column containing subject IDs (default is 'id').</p>
</td></tr>
<tr><td><code id="ctACF_+3A_timecol">timecol</code></td>
<td>
<p>The name of the column containing time values (default is 'time').</p>
</td></tr>
<tr><td><code id="ctACF_+3A_plot">plot</code></td>
<td>
<p>A logical value indicating whether to create a plot (default is TRUE).</p>
</td></tr>
<tr><td><code id="ctACF_+3A_timestep">timestep</code></td>
<td>
<p>The time step for discretizing data. 'auto' to automatically determine
the timestep based on data distribution (default is 'auto'). 
In this case the timestep is computed as 1/10th of the 10th percentile for time intervals in the data.</p>
</td></tr>
<tr><td><code id="ctACF_+3A_time.max">time.max</code></td>
<td>
<p>The maximum time lag to compute the ACF (default is 10). If 'auto', is set to 10 times the 90th percentile interval in the data.</p>
</td></tr>
<tr><td><code id="ctACF_+3A_nboot">nboot</code></td>
<td>
<p>The number of bootstrap samples for confidence interval estimation (default is 100).</p>
</td></tr>
<tr><td><code id="ctACF_+3A_...">...</code></td>
<td>
<p>additional arguments (such as demean=FALSE) to pass to the <code>stats::acf</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the continuous time ACF by discretizing the data and then
performing bootstrapped ACF calculations to estimate the confidence intervals. It can create
ACF plots with confidence intervals if 'plot' is set to TRUE.
</p>


<h3>Value</h3>

<p>If 'plot' is TRUE, the function returns a ggplot object of the ACF plot. If 'plot' is
FALSE, it returns a data table with ACF estimates and confidence intervals.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ctDiscretiseData">ctDiscretiseData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.table::setDTthreads(1) #ignore this line
# Example usage:
head(ctstantestdat)
ctACF(ctstantestdat,varnames=c('Y1'),idcol='id',timecol='time',nboot=5)

</code></pre>

<hr>
<h2 id='ctACFresiduals'>Calculate Continuous Time Autocorrelation Function (ACF) for Standardized Residuals of ctsem fit.</h2><span id='topic+ctACFresiduals'></span>

<h3>Description</h3>

<p>This function takes a fit object from ctsem and computes the continuous time autocorrelation
function (ACF) on the standardized residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctACFresiduals(fit, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctACFresiduals_+3A_fit">fit</code></td>
<td>
<p>A fitted model object generated by the ctsem package.</p>
</td></tr>
<tr><td><code id="ctACFresiduals_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the <code><a href="#topic+ctACF">ctACF</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function first extracts the standardized residuals from the fit object using
the <code><a href="#topic+ctStanKalman">ctStanKalman</a></code> function. Then, it calculates the continuous time ACF for these residuals
and returns the results as a data table.
</p>


<h3>Value</h3>

<p>A data table containing the continuous time ACF estimates for standardized residuals.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ctStanKalman">ctStanKalman</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.table::setDTthreads(1) #ignore this line
# Example usage:
ctACFresiduals(ctstantestfit, varnames='Y1',nboot=5)

</code></pre>

<hr>
<h2 id='ctAddSamples'>Sample more values from an optimized ctstanfit object</h2><span id='topic+ctAddSamples'></span>

<h3>Description</h3>

<p>Sample more values from an optimized ctstanfit object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctAddSamples(fit, nsamples, cores = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctAddSamples_+3A_fit">fit</code></td>
<td>
<p>fit object</p>
</td></tr>
<tr><td><code id="ctAddSamples_+3A_nsamples">nsamples</code></td>
<td>
<p>number of samples desired</p>
</td></tr>
<tr><td><code id="ctAddSamples_+3A_cores">cores</code></td>
<td>
<p>number of cores to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>fit object with extra samples
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
newfit &lt;- ctAddSamples(ctstantestfit, 10, 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='ctCheckFit'>Visual model fit diagnostics for ctsem fit objects.</h2><span id='topic+ctCheckFit'></span>

<h3>Description</h3>

<p>Visual model fit diagnostics for ctsem fit objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctCheckFit(
  fit,
  data = TRUE,
  postpred = TRUE,
  priorpred = FALSE,
  statepred = FALSE,
  residuals = FALSE,
  by = fit$ctstanmodelbase$timeName,
  TIpredNames = fit$ctstanmodelbase$TIpredNames,
  nsamples = 30,
  covplot = FALSE,
  corr = TRUE,
  combinevars = NA,
  fastcov = FALSE,
  lagcovplot = FALSE,
  aggfunc = mean,
  aggregate = FALSE,
  groupbysplit = FALSE,
  byNA = TRUE,
  lag = 0,
  smooth = TRUE,
  k = 4,
  breaks = 4,
  entropy = FALSE,
  reg = FALSE,
  verbose = 0,
  indlines = 30
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctCheckFit_+3A_fit">fit</code></td>
<td>
<p>ctStanFit object.</p>
</td></tr>
<tr><td><code id="ctCheckFit_+3A_data">data</code></td>
<td>
<p>Include empirical data in plots?</p>
</td></tr>
<tr><td><code id="ctCheckFit_+3A_postpred">postpred</code></td>
<td>
<p>Include post predictive (conditional on estimated parameters and covariates) distribution data in plots?</p>
</td></tr>
<tr><td><code id="ctCheckFit_+3A_priorpred">priorpred</code></td>
<td>
<p>Include prior predictive (conditional on priors) distribution data in plots?</p>
</td></tr>
<tr><td><code id="ctCheckFit_+3A_statepred">statepred</code></td>
<td>
<p>Include one step ahead (conditional on estimated parameters, covariates, and earlier data points) distribution data in plots?</p>
</td></tr>
<tr><td><code id="ctCheckFit_+3A_residuals">residuals</code></td>
<td>
<p>Include one step ahead error (conditional on estimated parameters, covariates, and earlier data points) in plots?</p>
</td></tr>
<tr><td><code id="ctCheckFit_+3A_by">by</code></td>
<td>
<p>Variable name to split or plot by. 'time', 'LogLik', and 'WhichObs' are also possibilities.</p>
</td></tr>
<tr><td><code id="ctCheckFit_+3A_tiprednames">TIpredNames</code></td>
<td>
<p>Since time independent predictors do not change with time, by default observations after the first are ignored. 
For observing attrition it can be helpful to set this to NULL, or when the combinevars argument is used, specifying different names may be useful.</p>
</td></tr>
<tr><td><code id="ctCheckFit_+3A_nsamples">nsamples</code></td>
<td>
<p>Number of samples (when applicable) to include in plots.</p>
</td></tr>
<tr><td><code id="ctCheckFit_+3A_covplot">covplot</code></td>
<td>
<p>Splits variables in the model by the 'by' argument, according to the number of breaks (breaks argument), 
and shows the covariance (or correlation) for the different data sources selected, as well as the differences between each pair.</p>
</td></tr>
<tr><td><code id="ctCheckFit_+3A_corr">corr</code></td>
<td>
<p>Turns the covplot into a correlation plot. Usually easier to make sense of visually.</p>
</td></tr>
<tr><td><code id="ctCheckFit_+3A_combinevars">combinevars</code></td>
<td>
<p>Can be a list of (possibly new) variable names, where each named element of the list contains a character vector 
of one or more variable names in the fit object, to combine into the one variable. By default, the mean is used, but see the aggfunc argument.
The combinevars argument can also be used to ensure that only certain variables are plotted.</p>
</td></tr>
<tr><td><code id="ctCheckFit_+3A_fastcov">fastcov</code></td>
<td>
<p>Uses base R cov function for computing covariances. Not recommended with missing data.</p>
</td></tr>
<tr><td><code id="ctCheckFit_+3A_lagcovplot">lagcovplot</code></td>
<td>
<p>Logical. Output lagged covariance type plots?</p>
</td></tr>
<tr><td><code id="ctCheckFit_+3A_aggfunc">aggfunc</code></td>
<td>
<p>Function to use for aggregation, if needed.</p>
</td></tr>
<tr><td><code id="ctCheckFit_+3A_aggregate">aggregate</code></td>
<td>
<p>If TRUE, duplicate observation types are aggregated over using aggfunc. For example,
if by = 'time' and there are 8 time points per subject, but breaks = 2, 
there will be 4 duplicate observation types per 'row' that will be collapsed. In most cases it is helpful to not collapse.</p>
</td></tr>
<tr><td><code id="ctCheckFit_+3A_groupbysplit">groupbysplit</code></td>
<td>
<p>Logical. Affects variable ordering in covariance plots. 
Defaults to FALSE, grouping by variable, and within variable by split.</p>
</td></tr>
<tr><td><code id="ctCheckFit_+3A_byna">byNA</code></td>
<td>
<p>Logical. Create an extra break for when the split variable is missing?</p>
</td></tr>
<tr><td><code id="ctCheckFit_+3A_lag">lag</code></td>
<td>
<p>Integer vector. lag = 1 creates additional variables for plotting, prefixed by 'lag1_', containing the prior row of observations
for that subject.</p>
</td></tr>
<tr><td><code id="ctCheckFit_+3A_smooth">smooth</code></td>
<td>
<p>For bivariate plots, use a smoother for estimation?</p>
</td></tr>
<tr><td><code id="ctCheckFit_+3A_k">k</code></td>
<td>
<p>Integer denoting number of knots to use in the smoothing spline.</p>
</td></tr>
<tr><td><code id="ctCheckFit_+3A_breaks">breaks</code></td>
<td>
<p>Integer denoting number of discrete breaks to split variables by (when covariance plotting).</p>
</td></tr>
<tr><td><code id="ctCheckFit_+3A_entropy">entropy</code></td>
<td>
<p>Still in development.</p>
</td></tr>
<tr><td><code id="ctCheckFit_+3A_reg">reg</code></td>
<td>
<p>Logical. Use regularisation when estimating covariance matrices? Can be necessary / faster for some problems.</p>
</td></tr>
<tr><td><code id="ctCheckFit_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If TRUE, shows optimization output when estimating covariances.</p>
</td></tr>
<tr><td><code id="ctCheckFit_+3A_indlines">indlines</code></td>
<td>
<p>Integer number of individual subject lines to draw per data type.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing. Just plots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ctCheckFit(ctstantestfit)

</code></pre>

<hr>
<h2 id='ctChisqTest'>Chi Square test wrapper for ctStanFit objects.</h2><span id='topic+ctChisqTest'></span>

<h3>Description</h3>

<p>Chi Square test wrapper for ctStanFit objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctChisqTest(fit1, fit2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctChisqTest_+3A_fit1">fit1</code></td>
<td>
<p>One of the fits to be compared (better fit is assumed as base for comparison)</p>
</td></tr>
<tr><td><code id="ctChisqTest_+3A_fit2">fit2</code></td>
<td>
<p>Second fit to be compared</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric probability
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
    df &lt;- data.frame(id=1, time=1:length(sunspot.year), Y1=sunspot.year)
    
    m1 &lt;- ctModel(type='standt', LAMBDA=diag(1),MANIFESTVAR=0)
    m2 &lt;- ctModel(type='standt', LAMBDA=diag(1),MANIFESTVAR=0,DRIFT = .9)
    
    f1 &lt;- ctStanFit(df,m1,cores=1)
    f2 &lt;- ctStanFit(df,m2,cores=1)
    
    ctChisqTest(f1,f2)

</code></pre>

<hr>
<h2 id='ctCollapse'>ctCollapse
Easily collapse an array margin using a specified function.</h2><span id='topic+ctCollapse'></span>

<h3>Description</h3>

<p>ctCollapse
Easily collapse an array margin using a specified function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctCollapse(inarray, collapsemargin, collapsefunc, plyr = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctCollapse_+3A_inarray">inarray</code></td>
<td>
<p>Input array of more than one dimension.</p>
</td></tr>
<tr><td><code id="ctCollapse_+3A_collapsemargin">collapsemargin</code></td>
<td>
<p>Integers denoting which margins to collapse.</p>
</td></tr>
<tr><td><code id="ctCollapse_+3A_collapsefunc">collapsefunc</code></td>
<td>
<p>function to use over the collapsing margin.</p>
</td></tr>
<tr><td><code id="ctCollapse_+3A_plyr">plyr</code></td>
<td>
<p>Whether to use plyr.</p>
</td></tr>
<tr><td><code id="ctCollapse_+3A_...">...</code></td>
<td>
<p>additional parameters to pass to collapsefunc.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>testarray &lt;- array(rnorm(900,2,1),dim=c(100,3,3))
ctCollapse(testarray,1,mean)
</code></pre>

<hr>
<h2 id='ctDeintervalise'>ctDeintervalise</h2><span id='topic+ctDeintervalise'></span>

<h3>Description</h3>

<p>Converts intervals in ctsem long format data to absolute time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctDeintervalise(datalong, id = "id", dT = "dT", startoffset = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctDeintervalise_+3A_datalong">datalong</code></td>
<td>
<p>data to use, in ctsem long format (attained via function ctWideToLong)</p>
</td></tr>
<tr><td><code id="ctDeintervalise_+3A_id">id</code></td>
<td>
<p>character string denoting column of data containing numeric identifier for each subject.</p>
</td></tr>
<tr><td><code id="ctDeintervalise_+3A_dt">dT</code></td>
<td>
<p>character string denoting column of data containing time interval preceding observations in that row.</p>
</td></tr>
<tr><td><code id="ctDeintervalise_+3A_startoffset">startoffset</code></td>
<td>
<p>Number of units of time to offset by when converting.</p>
</td></tr>
</table>

<hr>
<h2 id='ctDensity'>ctDensity</h2><span id='topic+ctDensity'></span>

<h3>Description</h3>

<p>Wrapper for base R density function that removes outliers and computes 'reasonable' bandwidth and x and y limits.
Used for ctsem density plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctDensity(x, bw = "auto", plot = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctDensity_+3A_x">x</code></td>
<td>
<p>numeric vector on which to compute density.</p>
</td></tr>
<tr><td><code id="ctDensity_+3A_bw">bw</code></td>
<td>
<p>either 'auto' or a numeric indicating bandwidth.</p>
</td></tr>
<tr><td><code id="ctDensity_+3A_plot">plot</code></td>
<td>
<p>logical to indicate whether or not to plot the output.</p>
</td></tr>
<tr><td><code id="ctDensity_+3A_...">...</code></td>
<td>
<p>Further args to density.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- ctDensity(exp(rnorm(80)))
plot(y$density,xlim=y$xlim,ylim=y$ylim)

#### Compare to base defaults:
par(mfrow=c(1,2))
y=exp(rnorm(10000))
ctdens&lt;-ctDensity(y)
plot(ctdens$density, ylim=ctdens$ylim,xlim=ctdens$xlim)
plot(density(y))
</code></pre>

<hr>
<h2 id='ctDiscretiseData'>Discretise long format continuous time (ctsem) data to specific timestep.</h2><span id='topic+ctDiscretiseData'></span>

<h3>Description</h3>

<p>Extends and rounds timing information so equal intervals, according to specified
timestep, are achieved. NA's are inserted in other columns as necessary,
any columns specified by TDpredNames or TIpredNames have zeroes rather than NA's
inserted (because some estimation routines do not tolerate NA's in covariates).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctDiscretiseData(
  dlong,
  timestep,
  timecol = "time",
  idcol = "id",
  TDpredNames = NULL,
  TIpredNames = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctDiscretiseData_+3A_dlong">dlong</code></td>
<td>
<p>Long format data</p>
</td></tr>
<tr><td><code id="ctDiscretiseData_+3A_timestep">timestep</code></td>
<td>
<p>Positive real value to discretise</p>
</td></tr>
<tr><td><code id="ctDiscretiseData_+3A_timecol">timecol</code></td>
<td>
<p>Name of column containing absolute (not intervals) time information.</p>
</td></tr>
<tr><td><code id="ctDiscretiseData_+3A_idcol">idcol</code></td>
<td>
<p>Name of column containing subject id variable.</p>
</td></tr>
<tr><td><code id="ctDiscretiseData_+3A_tdprednames">TDpredNames</code></td>
<td>
<p>Vector of column names of any time dependent predictors</p>
</td></tr>
<tr><td><code id="ctDiscretiseData_+3A_tiprednames">TIpredNames</code></td>
<td>
<p>Vector of column names of any time independent predictors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>long format ctsem data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>long &lt;- ctDiscretiseData(dlong=ctstantestdat, timestep = .1,
TDpredNames=c('TD1'),TIpredNames=c('TI1','TI2','TI3'))
</code></pre>

<hr>
<h2 id='ctDocs'>Get documentation pdf for ctsem</h2><span id='topic+ctDocs'></span>

<h3>Description</h3>

<p>Get documentation pdf for ctsem
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctDocs()
</code></pre>


<h3>Value</h3>

<p>Nothing. Opens a pdf.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ctDocs()
</code></pre>

<hr>
<h2 id='ctExample1'>ctExample1</h2><span id='topic+ctExample1'></span>

<h3>Description</h3>

<p>Simulated example dataset for the ctsem package
</p>


<h3>Format</h3>

<p>100 by 17 matrix containing containing ctsem wide format data. 
6 measurement occasions of leisure time and happiness and 5 measurement intervals for each of 100 individuals.
</p>

<hr>
<h2 id='ctExample1TIpred'>ctExample1TIpred</h2><span id='topic+ctExample1TIpred'></span>

<h3>Description</h3>

<p>Simulated example dataset for the ctsem package
</p>


<h3>Format</h3>

<p>100 by 18 matrix containing containing ctsem wide format data. 
6 measurement occasions of leisure time and happiness, 1 measurement of number of friends,
and 5 measurement intervals for each of 100 individuals.
</p>

<hr>
<h2 id='ctExample2'>ctExample2</h2><span id='topic+ctExample2'></span>

<h3>Description</h3>

<p>Simulated example dataset for the ctsem package
</p>


<h3>Format</h3>

<p>100 by 18 matrix containing containing ctsem wide format data. 
8 measurement occasions of leisure time and happiness, 
7 measurement occasions of a money intervention dummy,
and 7 measurement intervals for each of 50 individuals.
</p>

<hr>
<h2 id='ctExample2level'>ctExample2level</h2><span id='topic+ctExample2level'></span>

<h3>Description</h3>

<p>Simulated example dataset for the ctsem package
</p>


<h3>Format</h3>

<p>100 by 18 matrix containing ctsem wide format data. 
8 measurement occasions of leisure time and happiness, 
7 measurement occasions of a money intervention dummy,
and 7 measurement intervals for each of 50 individuals.
</p>

<hr>
<h2 id='ctExample3'>ctExample3</h2><span id='topic+ctExample3'></span>

<h3>Description</h3>

<p>Simulated example dataset for the ctsem package
</p>


<h3>Format</h3>

<p>1 by 399 matrix containing containing ctsem wide format data. 
100 observations of variables Y1 and Y2 and 199 measurement intervals, for 1 subject.
</p>

<hr>
<h2 id='ctExample4'>ctExample4</h2><span id='topic+ctExample4'></span>

<h3>Description</h3>

<p>Simulated example dataset for the ctsem package
</p>


<h3>Format</h3>

<p>20 by 79 matrix containing 20 observations of variables 
Y1, Y2, Y3, and 19 measurement intervals dTx, for each of 20 individuals.
</p>

<hr>
<h2 id='ctExtract'>Extract samples from a ctStanFit object</h2><span id='topic+ctExtract'></span><span id='topic+extract'></span>

<h3>Description</h3>

<p>Extract samples from a ctStanFit object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctExtract(
  object,
  subjectMatrices = FALSE,
  cores = 2,
  nsamples = "all",
  subjects = "all"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctExtract_+3A_object">object</code></td>
<td>
<p>ctStanFit object, samples may be from Stan's HMC, or the importance sampling approach of ctsem.</p>
</td></tr>
<tr><td><code id="ctExtract_+3A_subjectmatrices">subjectMatrices</code></td>
<td>
<p>Calculate subject specific system matrices?</p>
</td></tr>
<tr><td><code id="ctExtract_+3A_cores">cores</code></td>
<td>
<p>Only used if subjectMatrices = TRUE . For faster computation use more cores.</p>
</td></tr>
<tr><td><code id="ctExtract_+3A_nsamples">nsamples</code></td>
<td>
<p>either 'all' or an integer denoting number of random samples to extract.</p>
</td></tr>
<tr><td><code id="ctExtract_+3A_subjects">subjects</code></td>
<td>
<p>either 'all', or an integer vector denoting subjects to extract.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Array of posterior samples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
e = ctExtract(ctstantestfit)

</code></pre>

<hr>
<h2 id='ctFit'>ctFit function placeholder</h2><span id='topic+ctFit'></span>

<h3>Description</h3>

<p>For the original ctsem OpenMx functionality, the package ctsemOMX should be loaded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctFit(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctFit_+3A_...">...</code></td>
<td>
<p>arguments to pass to ctFit, if ctsemOMX is loaded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>message or fit object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(AnomAuth) 
AnomAuthmodel &lt;- ctModel(LAMBDA = matrix(c(1, 0, 0, 1), nrow = 2, ncol = 2), 
  Tpoints = 5, n.latent = 2, n.manifest = 2, MANIFESTVAR=diag(0, 2), TRAITVAR = NULL) 
AnomAuthfit &lt;- ctFit(AnomAuth, AnomAuthmodel)

</code></pre>

<hr>
<h2 id='ctFitMultiModel'>Fit and summarise a list of ctsem models</h2><span id='topic+ctFitMultiModel'></span>

<h3>Description</h3>

<p>Fit and summarise a list of ctsem models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctFitMultiModel(
  mlist,
  datalong,
  prefix = "",
  type = "stanct",
  cores = 2,
  summaryOutput = TRUE,
  saveFits = TRUE,
  summaryArgs = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctFitMultiModel_+3A_mlist">mlist</code></td>
<td>
<p>Named list of models</p>
</td></tr>
<tr><td><code id="ctFitMultiModel_+3A_datalong">datalong</code></td>
<td>
<p>ctsem long format data</p>
</td></tr>
<tr><td><code id="ctFitMultiModel_+3A_prefix">prefix</code></td>
<td>
<p>prefix for output files.</p>
</td></tr>
<tr><td><code id="ctFitMultiModel_+3A_type">type</code></td>
<td>
<p>'stanct' for continuous time or 'standt' for discrete time</p>
</td></tr>
<tr><td><code id="ctFitMultiModel_+3A_cores">cores</code></td>
<td>
<p>number of cpu cores to use</p>
</td></tr>
<tr><td><code id="ctFitMultiModel_+3A_summaryoutput">summaryOutput</code></td>
<td>
<p>Generate summary output into ctSummary folder? Large datasets can take some time.</p>
</td></tr>
<tr><td><code id="ctFitMultiModel_+3A_savefits">saveFits</code></td>
<td>
<p>Save fit objects to working directory?</p>
</td></tr>
<tr><td><code id="ctFitMultiModel_+3A_summaryargs">summaryArgs</code></td>
<td>
<p>Additional arguments for ctSummarise.</p>
</td></tr>
<tr><td><code id="ctFitMultiModel_+3A_...">...</code></td>
<td>
<p>Additional arguments for ctStanFit.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing a named list of model fits ($fits), and a compare object ($compare)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sunspots&lt;-data.frame(id=1,
  time=do.call(seq,(lapply(attributes(sunspot.year)$tsp,function(x) x))),
  sunspots=sunspot.year)

 ssmodel1 &lt;- ctModel(type='omx', manifestNames='sunspots', Tpoints=3,
  latentNames=c('ss_level', 'ss_velocity'),
   LAMBDA=matrix(c( 1, 'ma1| log(1+(exp(param)))' ), nrow=1, ncol=2),
   DRIFT=matrix(c(0, 'a21 | -log(1+exp(param))', 1, 'a22'), nrow=2, ncol=2),
   MANIFESTMEANS=matrix(c('m1|param * 10 + 44'), nrow=1, ncol=1),
   MANIFESTVAR=diag(0,1), #As per original spec
   CINT=matrix(c(0, 0), nrow=2, ncol=1),
   DIFFUSION=matrix(c(0, 0, 0, "diffusion"), ncol=2, nrow=2))
 
 ssmodel2 &lt;- ssmodel1
 ssmodel2$LAMBDA[2] &lt;- 0
 
 fits&lt;-ctFitMultiModel(list(m1=ssmodel1,m2=ssmodel2),datalong = sunspots,
   summaryOutput = FALSE,saveFits = FALSE,cores=1)
 print(fits$compare)

## End(Not run)
</code></pre>

<hr>
<h2 id='ctGenerate'>ctGenerate</h2><span id='topic+ctGenerate'></span>

<h3>Description</h3>

<p>This function generates data according to the specified ctsem model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctGenerate(
  ctmodelobj,
  n.subjects = 100,
  burnin = 0,
  dtmean = 1,
  logdtsd = 0,
  dtmat = NA,
  wide = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctGenerate_+3A_ctmodelobj">ctmodelobj</code></td>
<td>
<p>ctsem model object from <code><a href="#topic+ctModel">ctModel</a></code>.</p>
</td></tr>
<tr><td><code id="ctGenerate_+3A_n.subjects">n.subjects</code></td>
<td>
<p>Number of subjects to output.</p>
</td></tr>
<tr><td><code id="ctGenerate_+3A_burnin">burnin</code></td>
<td>
<p>Number of initial time points to discard (to simulate stationary data)</p>
</td></tr>
<tr><td><code id="ctGenerate_+3A_dtmean">dtmean</code></td>
<td>
<p>Positive numeric. Average time interval (delta T) to use.</p>
</td></tr>
<tr><td><code id="ctGenerate_+3A_logdtsd">logdtsd</code></td>
<td>
<p>Numeric. Standard deviation for variability of the time interval.</p>
</td></tr>
<tr><td><code id="ctGenerate_+3A_dtmat">dtmat</code></td>
<td>
<p>Either NA, or numeric matrix of n.subjects rows and Tpoints-1 columns, 
containing positive numeric values for all time intervals between measurements. 
If not NA, dtmean and logdtsd are ignored.</p>
</td></tr>
<tr><td><code id="ctGenerate_+3A_wide">wide</code></td>
<td>
<p>Logical. Output in wide format?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Covariance related matrices are treated as Cholesky factors. 
TRAITTDPREDCOV and TIPREDCOV matrices are not accounted for, at present. 
The first 1:n.TDpred rows and columns of TDPREDVAR are used for generating
tdpreds at each time point.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#generate data for 2 process model, each process measured by noisy indicator, 
#stable individual differences in process levels.

generatingModel&lt;-ctModel(Tpoints=8,n.latent=2,n.TDpred=0,n.TIpred=0,n.manifest=2,
 MANIFESTVAR=diag(.1,2),
 LAMBDA=diag(1,2),
 DRIFT=matrix(c(-.2,-.05,-.1,-.1),nrow=2),
 TRAITVAR=matrix(c(.5,.2,0,.8),nrow=2),
 DIFFUSION=matrix(c(1,.2,0,4),2),
 CINT=matrix(c(1,0),nrow=2),
 T0MEANS=matrix(0,ncol=1,nrow=2),
 T0VAR=diag(1,2))

data&lt;-ctGenerate(generatingModel,n.subjects=15,burnin=10)
</code></pre>

<hr>
<h2 id='ctIndplot'>ctIndplot</h2><span id='topic+ctIndplot'></span>

<h3>Description</h3>

<p>Convenience function to simply plot individuals trajectories from ctsem wide format data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctIndplot(
  datawide,
  n.manifest,
  Tpoints,
  n.subjects = "all",
  colourby = "variable",
  vars = "all",
  opacity = 1,
  varnames = NULL,
  xlab = "Time",
  ylab = "Value",
  type = "b",
  start = 0,
  legend = TRUE,
  legendposition = "topright",
  new = TRUE,
  jittersd = 0.05,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctIndplot_+3A_datawide">datawide</code></td>
<td>
<p>ctsem wide format data</p>
</td></tr>
<tr><td><code id="ctIndplot_+3A_n.manifest">n.manifest</code></td>
<td>
<p>Number of manifest variables in data structure</p>
</td></tr>
<tr><td><code id="ctIndplot_+3A_tpoints">Tpoints</code></td>
<td>
<p>Number of discrete time points per case in data structure</p>
</td></tr>
<tr><td><code id="ctIndplot_+3A_n.subjects">n.subjects</code></td>
<td>
<p>Number of subjects to randomly select for plotting, or character vector 'all'.</p>
</td></tr>
<tr><td><code id="ctIndplot_+3A_colourby">colourby</code></td>
<td>
<p>set  plot colours by &quot;subject&quot; or &quot;variable&quot;</p>
</td></tr>
<tr><td><code id="ctIndplot_+3A_vars">vars</code></td>
<td>
<p>either 'all' or a numeric vector specifying which manifest variables to plot.</p>
</td></tr>
<tr><td><code id="ctIndplot_+3A_opacity">opacity</code></td>
<td>
<p>Opacity of plot lines</p>
</td></tr>
<tr><td><code id="ctIndplot_+3A_varnames">varnames</code></td>
<td>
<p>vector of variable names for legend (defaults to NULL)</p>
</td></tr>
<tr><td><code id="ctIndplot_+3A_xlab">xlab</code></td>
<td>
<p>X axis label.</p>
</td></tr>
<tr><td><code id="ctIndplot_+3A_ylab">ylab</code></td>
<td>
<p>Y axis label.</p>
</td></tr>
<tr><td><code id="ctIndplot_+3A_type">type</code></td>
<td>
<p>character specifying plot type, as per usual base R plot commands. 
Defaults to 'b', both points and lines.</p>
</td></tr>
<tr><td><code id="ctIndplot_+3A_start">start</code></td>
<td>
<p>Measurement occasion to start plotting from - defaults to T0.</p>
</td></tr>
<tr><td><code id="ctIndplot_+3A_legend">legend</code></td>
<td>
<p>Logical. Plot a legend?</p>
</td></tr>
<tr><td><code id="ctIndplot_+3A_legendposition">legendposition</code></td>
<td>
<p>Where to position the legend.</p>
</td></tr>
<tr><td><code id="ctIndplot_+3A_new">new</code></td>
<td>
<p>logical. If TRUE, creates a new plot, otherwise overlays on current plot.</p>
</td></tr>
<tr><td><code id="ctIndplot_+3A_jittersd">jittersd</code></td>
<td>
<p>positive numeric indicating standard deviation of noise to add to observed
data for plotting purposes.</p>
</td></tr>
<tr><td><code id="ctIndplot_+3A_...">...</code></td>
<td>
<p>additional plotting parameters.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ctExample1)
ctIndplot(ctExample1,n.subjects=1, n.manifest=2,Tpoints=6, colourby='variable')

</code></pre>

<hr>
<h2 id='ctIntervalise'>Converts absolute times to intervals for wide format ctsem panel data</h2><span id='topic+ctIntervalise'></span>

<h3>Description</h3>

<p>Converts absolute times to intervals for wide format ctsem panel data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctIntervalise(
  datawide,
  Tpoints,
  n.manifest,
  n.TDpred = 0,
  n.TIpred = 0,
  imputedefs = F,
  manifestNames = "auto",
  TDpredNames = "auto",
  TIpredNames = "auto",
  digits = 5,
  mininterval = 0.001,
  individualRelativeTime = TRUE,
  startoffset = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctIntervalise_+3A_datawide">datawide</code></td>
<td>
<p>Wide format data, containing absolute time measurements, 
to convert to interval time scale.  
See <code><a href="#topic+ctLongToWide">ctLongToWide</a></code> to easily convert long format data.</p>
</td></tr>
<tr><td><code id="ctIntervalise_+3A_tpoints">Tpoints</code></td>
<td>
<p>Maximum number of discrete time points (waves of data, or measurement occasions) 
for an individual in the input data structure.</p>
</td></tr>
<tr><td><code id="ctIntervalise_+3A_n.manifest">n.manifest</code></td>
<td>
<p>number of manifest variables per time point in the data.</p>
</td></tr>
<tr><td><code id="ctIntervalise_+3A_n.tdpred">n.TDpred</code></td>
<td>
<p>number of time dependent predictors in the data structure.</p>
</td></tr>
<tr><td><code id="ctIntervalise_+3A_n.tipred">n.TIpred</code></td>
<td>
<p>number of time independent predictors in the data structure.</p>
</td></tr>
<tr><td><code id="ctIntervalise_+3A_imputedefs">imputedefs</code></td>
<td>
<p>if TRUE, impute time intervals based on the measurement occasion (i.e. column)
they are in, if FALSE (default), set related observations to NA.  
FALSE is recommended unless you are certain that the imputed value 
(mean of the relevant time column) is appropriate.  
Noise and bias in estimates will result if wrongly set to TRUE.</p>
</td></tr>
<tr><td><code id="ctIntervalise_+3A_manifestnames">manifestNames</code></td>
<td>
<p>vector of character strings giving variable names of manifest 
indicator variables (without _Tx suffix for measurement occasion).</p>
</td></tr>
<tr><td><code id="ctIntervalise_+3A_tdprednames">TDpredNames</code></td>
<td>
<p>vector of character strings giving variable names of time 
dependent predictor variables (without _Tx suffix for measurement occasion).</p>
</td></tr>
<tr><td><code id="ctIntervalise_+3A_tiprednames">TIpredNames</code></td>
<td>
<p>vector of character strings giving variable names of time 
independent predictor variables.</p>
</td></tr>
<tr><td><code id="ctIntervalise_+3A_digits">digits</code></td>
<td>
<p>How many digits to round to for interval calculations.</p>
</td></tr>
<tr><td><code id="ctIntervalise_+3A_mininterval">mininterval</code></td>
<td>
<p>set to lower than any possible observed measurement interval, 
but above 0 - this is used for filling NA values where necessary and has no 
impact on estimates when set in the correct range.  
(If all observed intervals are greater than 1, mininterval=1 may be a good choice)</p>
</td></tr>
<tr><td><code id="ctIntervalise_+3A_individualrelativetime">individualRelativeTime</code></td>
<td>
<p>if TRUE (default), the first measurement for each individual is 
assumed to be taken at time 0, and all other times are adjusted accordingly.  
If FALSE, new columns for an initial wave are created, consisting only of observations 
which occurred at the earliest observation time of the entire sample.</p>
</td></tr>
<tr><td><code id="ctIntervalise_+3A_startoffset">startoffset</code></td>
<td>
<p>if 0 (default) uses earliest observation as start time.
If greater than 0, all first observations are NA, with distance of 
startoffset to first recorded observation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Time column must be numeric!
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wideexample &lt;- ctLongToWide(datalong = ctstantestdat, id = "id", 
time = "time", manifestNames = c("Y1", "Y2"), 
TDpredNames = "TD1", TIpredNames = c("TI1", "TI2","TI3"))

#Then convert the absolute times to intervals, using the Tpoints reported from the prior step.
wide &lt;- ctIntervalise(datawide = wideexample, Tpoints = 10, n.manifest = 2, 
n.TDpred = 1, n.TIpred = 3, manifestNames = c("Y1", "Y2"), 
TDpredNames = "TD1", TIpredNames = c("TI1", "TI2","TI3") )
 
print(wide)
</code></pre>

<hr>
<h2 id='ctKalman'>ctKalman</h2><span id='topic+ctKalman'></span>

<h3>Description</h3>

<p>Outputs predicted, updated, and smoothed estimates of manifest indicators and latent states, 
with covariances, for specific subjects from data fit with <code><a href="#topic+ctStanFit">ctStanFit</a></code>, 
based on either the mode (if optimized) or mean (if sampled) of parameter distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctKalman(
  fit,
  timerange = "asdata",
  timestep = "auto",
  subjects = fit$setup$idmap[1, 1],
  removeObs = FALSE,
  plot = FALSE,
  standardisederrors = TRUE,
  realid = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctKalman_+3A_fit">fit</code></td>
<td>
<p>fit object as generated by <code><a href="#topic+ctStanFit">ctStanFit</a></code>.</p>
</td></tr>
<tr><td><code id="ctKalman_+3A_timerange">timerange</code></td>
<td>
<p>Either 'asdata' to just use the observed data range, or a numeric vector of length 2 denoting start and end of time range, 
allowing for estimates outside the range of observed data. Ranges smaller than the observed data
are ignored.</p>
</td></tr>
<tr><td><code id="ctKalman_+3A_timestep">timestep</code></td>
<td>
<p>Either 'asdata' to just use the observed data 
(which also requires 'asdata' for timerange) or a positive numeric value
indicating the time step to use for interpolating values. Lower values give a more accurate / smooth representation,
but take a little more time to calculate.</p>
</td></tr>
<tr><td><code id="ctKalman_+3A_subjects">subjects</code></td>
<td>
<p>vector of integers denoting which subjects (from 1 to N) to plot predictions for.</p>
</td></tr>
<tr><td><code id="ctKalman_+3A_removeobs">removeObs</code></td>
<td>
<p>Logical or integer. If TRUE, observations (but not covariates)
are set to NA, so only expectations based on parameters and covariates are returned. If a positive integer N, 
every N observations are retained while others are set NA for computing model expectations &ndash; useful for observing prediction performance
forward further in time than one observation.</p>
</td></tr>
<tr><td><code id="ctKalman_+3A_plot">plot</code></td>
<td>
<p>Logical. If TRUE, plots output instead of returning it. 
See <code><a href="#topic+plot.ctKalmanDF">plot.ctKalmanDF</a></code> 
(Stan based fit) for the possible arguments.</p>
</td></tr>
<tr><td><code id="ctKalman_+3A_standardisederrors">standardisederrors</code></td>
<td>
<p>if TRUE, also include standardised error output (based on covariance
per time point).</p>
</td></tr>
<tr><td><code id="ctKalman_+3A_realid">realid</code></td>
<td>
<p>use original (not necessarily integer sequence) subject id's? Otherwise use integers 1:N.</p>
</td></tr>
<tr><td><code id="ctKalman_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to <code><a href="#topic+plot.ctKalmanDF">plot.ctKalmanDF</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing matrix objects etaprior, etaupd, etasmooth, y, yprior, 
yupd, ysmooth, prederror, time, loglik,  with values for each time point in each row. 
eta refers to latent states and y to manifest indicators - y itself is thus just 
the input data. 
Covariance matrices etapriorcov, etaupdcov, etasmoothcov, ypriorcov, yupdcov, ysmoothcov,  
are returned in a row * column * time array. 
Some outputs are unavailable for ctStan fits at present.
If plot=TRUE, nothing is returned but a plot is generated.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#Basic
ctKalman(ctstantestfit, timerange=c(0,60), plot=TRUE)

#Multiple subjects, y and yprior, showing plot arguments
plot1&lt;-ctKalman(ctstantestfit, timerange=c(0,60), timestep=.1, plot=TRUE,
  subjects=2:3, 
  kalmanvec=c('y','yprior'),
  errorvec=c(NA,'ypriorcov')) #'auto' would also have achieved this
  
 #modify plot as per normal with ggplot
 print(plot1+ggplot2::coord_cartesian(xlim=c(0,10)))
 
 #or generate custom plot from scratch:#'  
 k=ctKalman(ctstantestfit, timerange=c(0,60), timestep=.1, subjects=2:3)
 library(ggplot2)
 ggplot(k[k$Element %in% 'yprior',],
   aes(x=Time, y=value,colour=Subject,linetype=Row)) +
   geom_line() +
   theme_bw()

 
</code></pre>

<hr>
<h2 id='ctLongToWide'>ctLongToWide
Restructures time series / panel data from long format to wide format for ctsem analysis</h2><span id='topic+ctLongToWide'></span>

<h3>Description</h3>

<p>ctLongToWide
Restructures time series / panel data from long format to wide format for ctsem analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctLongToWide(
  datalong,
  id,
  time,
  manifestNames,
  TDpredNames = NULL,
  TIpredNames = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctLongToWide_+3A_datalong">datalong</code></td>
<td>
<p>dataset in long format, including subject/id column, observation time 
(or change in observation time, with 0 for first observation) column, 
indicator (manifest / observed) variables, 
any time dependent predictors, and any time independent predictors.</p>
</td></tr>
<tr><td><code id="ctLongToWide_+3A_id">id</code></td>
<td>
<p>character string giving column name of the subject/id column</p>
</td></tr>
<tr><td><code id="ctLongToWide_+3A_time">time</code></td>
<td>
<p>character string giving column name of the time columnn</p>
</td></tr>
<tr><td><code id="ctLongToWide_+3A_manifestnames">manifestNames</code></td>
<td>
<p>vector of character strings giving column names of manifest indicator variables</p>
</td></tr>
<tr><td><code id="ctLongToWide_+3A_tdprednames">TDpredNames</code></td>
<td>
<p>vector of character strings giving column names of time dependent predictor variables</p>
</td></tr>
<tr><td><code id="ctLongToWide_+3A_tiprednames">TIpredNames</code></td>
<td>
<p>vector of character strings giving column names of time independent predictor variables</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Time column must be numeric
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ctIntervalise">ctIntervalise</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wideexample &lt;- ctLongToWide(datalong = ctstantestdat, id = "id", 
time = "time", manifestNames = c("Y1", "Y2"), 
TDpredNames = "TD1", TIpredNames = c("TI1", "TI2","TI3"))

#Then convert the absolute times to intervals, using the Tpoints reported from the prior step.
wide &lt;- ctIntervalise(datawide = wideexample, Tpoints = 10, n.manifest = 2, 
n.TDpred = 1, n.TIpred = 3, manifestNames = c("Y1", "Y2"), 
TDpredNames = "TD1", TIpredNames = c("TI1", "TI2","TI3") )
 
print(wide)
</code></pre>

<hr>
<h2 id='ctLOO'>K fold cross validation for ctStanFit objects</h2><span id='topic+ctLOO'></span>

<h3>Description</h3>

<p>K fold cross validation for ctStanFit objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctLOO(
  fit,
  folds = 10,
  cores = 2,
  parallelFolds = FALSE,
  subjectwise = ifelse(length(unique(fit$standata$subject)) &gt; folds, TRUE, FALSE),
  keepfirstobs = FALSE,
  leaveOutN = NA,
  refit = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctLOO_+3A_fit">fit</code></td>
<td>
<p>ctStanfit object</p>
</td></tr>
<tr><td><code id="ctLOO_+3A_folds">folds</code></td>
<td>
<p>Number of cross validation splits to use &ndash; 10 folds implies that the 
model is re-fit 10 times, each time to a data set with 1/10 of the observations randomly removed.</p>
</td></tr>
<tr><td><code id="ctLOO_+3A_cores">cores</code></td>
<td>
<p>Number of processor cores to use.</p>
</td></tr>
<tr><td><code id="ctLOO_+3A_parallelfolds">parallelFolds</code></td>
<td>
<p>compute folds in parallel or use cores to finish single folds faster. 
parallelFolds will use folds times as much memory.</p>
</td></tr>
<tr><td><code id="ctLOO_+3A_subjectwise">subjectwise</code></td>
<td>
<p>drop random subjects instead of data rows?</p>
</td></tr>
<tr><td><code id="ctLOO_+3A_keepfirstobs">keepfirstobs</code></td>
<td>
<p>do not drop first observation (more stable estimates)</p>
</td></tr>
<tr><td><code id="ctLOO_+3A_leaveoutn">leaveOutN</code></td>
<td>
<p>if a positive integer is given, the folds argument is ignored and 
instead the folds are calculated by leaving out every Nth row from the data when fitting. 
Leaving 2 out would result in 3 folds (starting at rows 1,2,3), each containing one third of the data.</p>
</td></tr>
<tr><td><code id="ctLOO_+3A_refit">refit</code></td>
<td>
<p>if FALSE, do not optimise parameters for the new data set, 
just compute the likelihoods etc from the original parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
ctLOO(ctstantestfit)

</code></pre>

<hr>
<h2 id='ctModel'>Define a ctsem model</h2><span id='topic+ctModel'></span>

<h3>Description</h3>

<p>This function is used to specify a continuous time structural equation model, 
which can then be fit to data with function <code><a href="#topic+ctStanFit">ctStanFit</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctModel(
  LAMBDA,
  type = "omx",
  n.manifest = "auto",
  n.latent = "auto",
  Tpoints = NULL,
  manifestNames = "auto",
  latentNames = "auto",
  id = "id",
  time = "time",
  silent = FALSE,
  T0VAR = "auto",
  T0MEANS = "auto",
  MANIFESTMEANS = "auto",
  MANIFESTVAR = "auto",
  DRIFT = "auto",
  CINT = "auto",
  DIFFUSION = "auto",
  n.TDpred = "auto",
  TDpredNames = "auto",
  n.TIpred = "auto",
  TIpredNames = "auto",
  tipredDefault = TRUE,
  TRAITVAR = NULL,
  T0TRAITEFFECT = NULL,
  MANIFESTTRAITVAR = NULL,
  TDPREDMEANS = "auto",
  TDPREDEFFECT = "auto",
  T0TDPREDCOV = "auto",
  TDPREDVAR = "auto",
  TRAITTDPREDCOV = "auto",
  TDTIPREDCOV = "auto",
  TIPREDMEANS = "auto",
  TIPREDEFFECT = "auto",
  T0TIPREDEFFECT = "auto",
  TIPREDVAR = "auto",
  PARS = NULL,
  startValues = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctModel_+3A_lambda">LAMBDA</code></td>
<td>
<p>n.manifest*n.latent loading matrix relating latent to manifest variables, 
with latent processes 1:n.latent along the columns, and manifest variables
1:n.manifest in the rows.</p>
</td></tr>
<tr><td><code id="ctModel_+3A_type">type</code></td>
<td>
<p>character string. If 'omx' (default) configures model for maximum likelihood fitting with ctFit, using OpenMx. 
If 'stanct' or 'standt' configures either continuous ('stanct') or discrete ('standt') time 
model for Bayesian fitting with <code><a href="#topic+ctStanFit">ctStanFit</a></code>, using Stan.</p>
</td></tr>
<tr><td><code id="ctModel_+3A_n.manifest">n.manifest</code></td>
<td>
<p>Number of manifest indicators per individual at each measurement occasion / time point.
Manifest variables are included as the first element of the wide data matrix, with all the 1:n.manifest manifest variables 
at time 1 followed by those of time 2, and so on.</p>
</td></tr>
<tr><td><code id="ctModel_+3A_n.latent">n.latent</code></td>
<td>
<p>Number of latent processes.</p>
</td></tr>
<tr><td><code id="ctModel_+3A_tpoints">Tpoints</code></td>
<td>
<p>For type='omx' only. Number of time points, or measurement occasions, in the data.  This will generally be the maximum 
number of time points for a single individual, but may be one extra if sample relative time intervals are used, 
see <code><a href="#topic+ctIntervalise">ctIntervalise</a></code>.</p>
</td></tr>
<tr><td><code id="ctModel_+3A_manifestnames">manifestNames</code></td>
<td>
<p>n.manifest length vector of manifest variable names as they appear in the data structure, 
without any _Tx time point suffix that may be present in wide data.  Defaults to Y1, Y2, etc.</p>
</td></tr>
<tr><td><code id="ctModel_+3A_latentnames">latentNames</code></td>
<td>
<p>n.latent length vector of latent variable names 
(used for naming parameters, defaults to eta1, eta2, etc).</p>
</td></tr>
<tr><td><code id="ctModel_+3A_id">id</code></td>
<td>
<p>character string denoting column name containing subject identification variables. 
id data may be of any form, though will be coerced internally to an integer sequence rising from 1.</p>
</td></tr>
<tr><td><code id="ctModel_+3A_time">time</code></td>
<td>
<p>character string denoting column name containing timing data. Timing data must be numeric.</p>
</td></tr>
<tr><td><code id="ctModel_+3A_silent">silent</code></td>
<td>
<p>Suppress all output to console.</p>
</td></tr>
<tr><td><code id="ctModel_+3A_t0var">T0VAR</code></td>
<td>
<p>lower triangular n.latent*n.latent cholesky matrix of latent process initial variance / covariance. 
&quot;auto&quot; freely estimates all parameters.</p>
</td></tr>
<tr><td><code id="ctModel_+3A_t0means">T0MEANS</code></td>
<td>
<p>n.latent*1 matrix of latent process means at first time point, T0. 
&quot;auto&quot; freely estimates all parameters.</p>
</td></tr>
<tr><td><code id="ctModel_+3A_manifestmeans">MANIFESTMEANS</code></td>
<td>
<p>n.manifest*1 matrix of manifest intercept parameters.
&quot;auto&quot; frees all parameters.</p>
</td></tr>
<tr><td><code id="ctModel_+3A_manifestvar">MANIFESTVAR</code></td>
<td>
<p>lower triangular n.manifest*n.manifest cholesky matrix of variance / covariance 
between manifests at each measurement occasion (i.e. measurement error / residual).  
&quot;auto&quot; freely estimates variance parameters, 
and fixes covariances between manifests to 0. &quot;free&quot; frees all values, including covariances.</p>
</td></tr>
<tr><td><code id="ctModel_+3A_drift">DRIFT</code></td>
<td>
<p>n.latent*n.latent DRIFT matrix of continuous auto and cross effects, 
relating the processes over time. 
&quot;auto&quot; freely estimates all parameters.</p>
</td></tr>
<tr><td><code id="ctModel_+3A_cint">CINT</code></td>
<td>
<p>n.latent * 1 matrix of latent process intercepts, allowing for non 0 
asymptotic levels of the latent processes. Generally only necessary for additional trends and more complex dynamics.
&quot;auto&quot; fixes all parameters to 0.</p>
</td></tr>
<tr><td><code id="ctModel_+3A_diffusion">DIFFUSION</code></td>
<td>
<p>lower triangular n.latent*n.latent cholesky matrix of diffusion process 
variance and covariance (latent error / dynamic innovation).
&quot;auto&quot; freely estimates all parameters.</p>
</td></tr>
<tr><td><code id="ctModel_+3A_n.tdpred">n.TDpred</code></td>
<td>
<p>Number of time dependent predictor variables in the dataset.</p>
</td></tr>
<tr><td><code id="ctModel_+3A_tdprednames">TDpredNames</code></td>
<td>
<p>n.TDpred length vector of time dependent predictor variable names, 
as they appear in the data structure, without any _Tx time point suffix that may appear in wide data.  
Default names are TD1, TD2, etc.</p>
</td></tr>
<tr><td><code id="ctModel_+3A_n.tipred">n.TIpred</code></td>
<td>
<p>Number of time independent predictors. 
Each TIpredictor is inserted at the right of the data matrix, after the time intervals.</p>
</td></tr>
<tr><td><code id="ctModel_+3A_tiprednames">TIpredNames</code></td>
<td>
<p>n.TIpred length vector of time independent predictor variable names,
as they appear in the data structure.  Default names are TI1, TI2, etc.</p>
</td></tr>
<tr><td><code id="ctModel_+3A_tipreddefault">tipredDefault</code></td>
<td>
<p>Logical. TRUE sets any parameters with unspecified time independent 
predictor effects to have effects estimated, FALSE fixes the effect to zero unless individually specified.</p>
</td></tr>
<tr><td><code id="ctModel_+3A_traitvar">TRAITVAR</code></td>
<td>
<p>For type='omx' only. Either NULL, if no trait / unobserved heterogeneity effect, 
or lower triangular n.latent*n.latent cholesky matrix of trait variance / covariance across subjects.
&quot;auto&quot; freely estimates all parameters.</p>
</td></tr>
<tr><td><code id="ctModel_+3A_t0traiteffect">T0TRAITEFFECT</code></td>
<td>
<p>For type='omx' only. Either NULL, if no trait / individual heterogeneity effect, 
or lower triangular n.latent*n.latent cholesky matrix of initial trait variance / covariance.
&quot;auto&quot; freely estimates all parametrers, if the TRAITVAR matrix is specified.</p>
</td></tr>
<tr><td><code id="ctModel_+3A_manifesttraitvar">MANIFESTTRAITVAR</code></td>
<td>
<p>For type='omx' only. Either NULL (default) if no trait variance / individual heterogeneity in the level of
the manifest indicators, otherwise a lower triangular n.manifest * n.manifest variance / covariance matrix. 
Set to &quot;auto&quot; to include and free all parameters - but identification problems will arise if <code>TRAITVAR</code> is 
also set.</p>
</td></tr>
<tr><td><code id="ctModel_+3A_tdpredmeans">TDPREDMEANS</code></td>
<td>
<p>For type='omx' only. (n.TDpred * (Tpoints - 1)) rows * 1 column matrix of time dependent predictor means.
If 'auto', the means are freely estimated.  Otherwise, 
the means for the Tpoints observations of your first time dependent predictor 
are followed by those of TDpred 2, and so on.</p>
</td></tr>
<tr><td><code id="ctModel_+3A_tdpredeffect">TDPREDEFFECT</code></td>
<td>
<p>n.latent*n.TDpred matrix of effects from time dependent predictors to latent processes.
Effects from 1:n.TDpred columns TDpredictors go to 1:n.latent rows of latent processes.
&quot;auto&quot; freely estimates all parameters.</p>
</td></tr>
<tr><td><code id="ctModel_+3A_t0tdpredcov">T0TDPREDCOV</code></td>
<td>
<p>For type='omx' only. n.latent rows * (Tpoints * n.TDpred) columns covariance matrix 
between latents at T0 and time dependent predictors.
Default of &quot;auto&quot; restricts covariance to 0, which is consistent with covariance to other time points. 
To freely estimate parameters, specify either 'free', or the desired matrix.</p>
</td></tr>
<tr><td><code id="ctModel_+3A_tdpredvar">TDPREDVAR</code></td>
<td>
<p>For type='omx' only. lower triangular (n.TDpred * Tpoints) rows 
* (n.TDpred * Tpoints) columns variance / covariance
cholesky matrix for time dependent predictors.
&quot;auto&quot; (default) freely estimates all parameters.</p>
</td></tr>
<tr><td><code id="ctModel_+3A_traittdpredcov">TRAITTDPREDCOV</code></td>
<td>
<p>For type='omx' only. n.latent rows * (n.TDpred*Tpoints) columns covariance matrix of 
latent traits and time dependent predictors. Defaults to zeroes, 
assuming predictors are independent of subjects baseline levels. When predictors depend on the subjects,
this should instead be set to 'free' or manually specified.
The Tpoints columns of the first preditor are followed by those of the second and so on.
Covariances with the trait variance of latent process 1 are specified in row 1, process 2 in row 2, etc.
&quot;auto&quot; (default) sets this matrix to zeroes, (if both traits and time dependent predictors exist, otherwise this matrix is set to NULL, and ignored in any case).</p>
</td></tr>
<tr><td><code id="ctModel_+3A_tdtipredcov">TDTIPREDCOV</code></td>
<td>
<p>For type='omx' only. (n.TDpred * Tpoints) rows * n.TIpred columns covariance
matrix between time dependent and time independent predictors.
&quot;auto&quot; (default) freely estimates all parameters.</p>
</td></tr>
<tr><td><code id="ctModel_+3A_tipredmeans">TIPREDMEANS</code></td>
<td>
<p>For type='omx' only. n.TIpred * 1 matrix of time independent predictor means.
If 'auto', the means are freely estimated.</p>
</td></tr>
<tr><td><code id="ctModel_+3A_tipredeffect">TIPREDEFFECT</code></td>
<td>
<p>For type='omx' only. n.latent*n.TIpred effect matrix of time independent predictors on latent processes.
&quot;auto&quot; freely estimates all parameters and generates starting values. TIPREDEFFECT parameters for type='stan' are estimated
by default on all subject level parameters, to restrict this, 
manually edit the model object after creation.</p>
</td></tr>
<tr><td><code id="ctModel_+3A_t0tipredeffect">T0TIPREDEFFECT</code></td>
<td>
<p>For type='omx' only.n.latent*n.TIpred effect matrix of time independent 
predictors on latents at T0. &quot;auto&quot; freely estimates all parameters, though note that under the default 
setting of <code>stationary</code> for ctFit, this matrix is ignored as the effects are determined based on
the overall process parameters.</p>
</td></tr>
<tr><td><code id="ctModel_+3A_tipredvar">TIPREDVAR</code></td>
<td>
<p>For type='omx' only.lower triangular n.TIpred * n.TIpred Cholesky decomposed covariance
matrix for all time independent predictors.
&quot;auto&quot; (default) freely estimates all parameters.</p>
</td></tr>
<tr><td><code id="ctModel_+3A_pars">PARS</code></td>
<td>
<p>for types 'stanct' and 'standt' only. May be of any structure, only needed to contain extra parameters for certain non-linear models.</p>
</td></tr>
<tr><td><code id="ctModel_+3A_startvalues">startValues</code></td>
<td>
<p>For type='omx' only. A named vector, where the names of each value must match a parameter in the specified model,
and the value sets the starting value for that parameter during optimization.
If not set, random starting values representing relatively stable processes with small effects and 
covariances are generated by ctFit.  
Better starting values may improve model fit speed and the chance of an appropriate model fit.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'> ### Frequentist example:
 ### impulse and level change time dependent predictor 
 ### example from Driver, Oud, Voelkle (2015)
 data('ctExample2')
 tdpredmodel &lt;- ctModel(n.manifest = 2, n.latent = 3, n.TDpred = 1, 
 Tpoints = 8, manifestNames = c('LeisureTime', 'Happiness'), 
 TDpredNames = 'MoneyInt', 
 latentNames = c('LeisureTime', 'Happiness', 'MoneyIntLatent'),
 LAMBDA = matrix(c(1,0, 0,1, 0,0), ncol = 3), TRAITVAR = "auto")

 tdpredmodel$TRAITVAR[3, ] &lt;- 0
 tdpredmodel$TRAITVAR[, 3] &lt;- 0
 tdpredmodel$DIFFUSION[, 3] &lt;- 0
 tdpredmodel$DIFFUSION[3, ] &lt;- 0
 tdpredmodel$T0VAR[3, ] &lt;- 0
 tdpredmodel$T0VAR[, 3] &lt;- 0
 tdpredmodel$CINT[3] &lt;- 0
 tdpredmodel$T0MEANS[3] &lt;- 0
 tdpredmodel$TDPREDEFFECT[3, ] &lt;- 1
 tdpredmodel$DRIFT[3, ] &lt;- 0
 
 
###Bayesian example:
model&lt;-ctModel(type='stanct',
n.latent=2, latentNames=c('eta1','eta2'),
n.manifest=2, manifestNames=c('Y1','Y2'),
n.TDpred=1, TDpredNames='TD1', 
n.TIpred=3, TIpredNames=c('TI1','TI2','TI3'),
LAMBDA=diag(2))


</code></pre>

<hr>
<h2 id='ctModelHigherOrder'>Raise the order of a ctsem model object of type 'omx'.</h2><span id='topic+ctModelHigherOrder'></span>

<h3>Description</h3>

<p>Raise the order of a ctsem model object of type 'omx'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctModelHigherOrder(
  ctm,
  indices,
  diffusion = TRUE,
  crosseffects = FALSE,
  cint = FALSE,
  explosive = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctModelHigherOrder_+3A_ctm">ctm</code></td>
<td>
<p>ctModel</p>
</td></tr>
<tr><td><code id="ctModelHigherOrder_+3A_indices">indices</code></td>
<td>
<p>Vector of integers, which latents to raise the order of.</p>
</td></tr>
<tr><td><code id="ctModelHigherOrder_+3A_diffusion">diffusion</code></td>
<td>
<p>Shift the diffusion parameters / values to the higher order?</p>
</td></tr>
<tr><td><code id="ctModelHigherOrder_+3A_crosseffects">crosseffects</code></td>
<td>
<p>Shift cross coupling parameters of the DRIFT matrix to the higher order?</p>
</td></tr>
<tr><td><code id="ctModelHigherOrder_+3A_cint">cint</code></td>
<td>
<p>shift continuous intercepts to higher order?</p>
</td></tr>
<tr><td><code id="ctModelHigherOrder_+3A_explosive">explosive</code></td>
<td>
<p>Allow explosive (non equilibrium returning) processes?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>extended ctModel
</p>


<h3>Examples</h3>

<pre><code class='language-R'>om &lt;- ctModel(LAMBDA=diag(1,2),DRIFT=0, 
  MANIFESTMEANS=0,type='omx',Tpoints=4)
  
om &lt;- ctModelHigherOrder(om,1:2)
print(om$DRIFT)

m &lt;- ctStanModel(om)
print(m$pars)
</code></pre>

<hr>
<h2 id='ctModelLatex'>Generate and optionally compile latex equation of subject level ctsem model.</h2><span id='topic+ctModelLatex'></span>

<h3>Description</h3>

<p>Generate and optionally compile latex equation of subject level ctsem model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctModelLatex(
  x,
  matrixnames = TRUE,
  digits = 3,
  linearise = class(x) %in% "ctStanFit",
  textsize = "normalsize",
  folder = tempdir(),
  filename = paste0("ctsemTex", as.numeric(Sys.time())),
  tex = TRUE,
  equationonly = FALSE,
  compile = TRUE,
  open = TRUE,
  includeNote = TRUE,
  minimal = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctModelLatex_+3A_x">x</code></td>
<td>
<p>ctsem model object or ctStanFit object.</p>
</td></tr>
<tr><td><code id="ctModelLatex_+3A_matrixnames">matrixnames</code></td>
<td>
<p>Logical. If TRUE, includes ctsem matrix names such as DRIFT and DIFFUSION under the matrices.</p>
</td></tr>
<tr><td><code id="ctModelLatex_+3A_digits">digits</code></td>
<td>
<p>Precision of decimals for numeric values.</p>
</td></tr>
<tr><td><code id="ctModelLatex_+3A_linearise">linearise</code></td>
<td>
<p>Logical. Show the linearised normal approximation for subject parameters and 
covariate effects, or the raw parameters?</p>
</td></tr>
<tr><td><code id="ctModelLatex_+3A_textsize">textsize</code></td>
<td>
<p>Standard latex text sizes &ndash; 
tiny scriptsize footnotesize small normalsize large Large LARGE huge Huge. 
Useful if output overflows page.</p>
</td></tr>
<tr><td><code id="ctModelLatex_+3A_folder">folder</code></td>
<td>
<p>Character string specifying folder to save to, defaults to temporary directory, use &quot;./&quot; for working directory.</p>
</td></tr>
<tr><td><code id="ctModelLatex_+3A_filename">filename</code></td>
<td>
<p>filename, without suffix, to output .tex and .pdf files too.</p>
</td></tr>
<tr><td><code id="ctModelLatex_+3A_tex">tex</code></td>
<td>
<p>Save .tex file? Otherwise latex is simply returned within R as a string.</p>
</td></tr>
<tr><td><code id="ctModelLatex_+3A_equationonly">equationonly</code></td>
<td>
<p>Logical. If TRUE, output is only the latex relevant to the equation, not a compileable document.</p>
</td></tr>
<tr><td><code id="ctModelLatex_+3A_compile">compile</code></td>
<td>
<p>Compile to .pdf? (Depends on <code>tex = TRUE</code>)</p>
</td></tr>
<tr><td><code id="ctModelLatex_+3A_open">open</code></td>
<td>
<p>Open after compiling? (Depends on <code>compile = TRUE</code>)</p>
</td></tr>
<tr><td><code id="ctModelLatex_+3A_includenote">includeNote</code></td>
<td>
<p>Include text describing matrix transformations and subject notation?
triangular matrices (which results in a covariance or Cholesky matrix) is shown &ndash; 
the latter is a more direct representation of the model, while the former is often simpler to convey.</p>
</td></tr>
<tr><td><code id="ctModelLatex_+3A_minimal">minimal</code></td>
<td>
<p>if TRUE, outputs reduced form version displaying matrix dimensions and equation structure only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character string of latex code. Side effects include saving a .tex, .pdf, and displaying the pdf.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ctmodel &lt;- ctModel(type='stanct', 
n.latent=2, n.manifest=1, 
manifestNames='sunspots', 
latentNames=c('ss_level', 'ss_velocity'),
LAMBDA=matrix(c( 1, 'ma1' ), nrow=1, ncol=2),
DRIFT=matrix(c(0, 1,   'a21', 'a22'), nrow=2, ncol=2, byrow=TRUE),
MANIFESTMEANS=matrix(c('m1'), nrow=1, ncol=1),
CINT=matrix(c(0, 0), nrow=2, ncol=1),
DIFFUSION=matrix(c(
  0, 0,
  0, "diffusion"), ncol=2, nrow=2, byrow=TRUE))
  
l=ctModelLatex(ctmodel,compile=FALSE, open=FALSE)
cat(l)
</code></pre>

<hr>
<h2 id='ctPlotArray'>Plots three dimensional y values for quantile plots</h2><span id='topic+ctPlotArray'></span>

<h3>Description</h3>

<p>1st margin of $Y sets line values, 2nd sets variables, 3rd quantiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctPlotArray(
  input,
  grid = FALSE,
  add = FALSE,
  colvec = "auto",
  lwdvec = "auto",
  ltyvec = "auto",
  typevec = "auto",
  plotcontrol = list(ylab = "Array values", xaxs = "i"),
  legend = TRUE,
  legendcontrol = list(),
  polygon = TRUE,
  polygonalpha = 0.1,
  polygoncontrol = list(steps = 25)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctPlotArray_+3A_input">input</code></td>
<td>
<p>list containing 3 dimensional array to use for Y values, <code>$y</code>
and vector of corresponding x values <code>$x</code>.</p>
</td></tr>
<tr><td><code id="ctPlotArray_+3A_grid">grid</code></td>
<td>
<p>Logical. Plot with a grid?</p>
</td></tr>
<tr><td><code id="ctPlotArray_+3A_add">add</code></td>
<td>
<p>Logical. If TRUE, plotting is overlayed on current plot, without creating new plot.</p>
</td></tr>
<tr><td><code id="ctPlotArray_+3A_colvec">colvec</code></td>
<td>
<p>color vector of same length as 2nd margin.</p>
</td></tr>
<tr><td><code id="ctPlotArray_+3A_lwdvec">lwdvec</code></td>
<td>
<p>lwd vector of same length as 2nd margin.</p>
</td></tr>
<tr><td><code id="ctPlotArray_+3A_ltyvec">ltyvec</code></td>
<td>
<p>lty vector of same length as 2nd margin.</p>
</td></tr>
<tr><td><code id="ctPlotArray_+3A_typevec">typevec</code></td>
<td>
<p>type vector of same length as 2nd margin.</p>
</td></tr>
<tr><td><code id="ctPlotArray_+3A_plotcontrol">plotcontrol</code></td>
<td>
<p>list of arguments to pass to plot.</p>
</td></tr>
<tr><td><code id="ctPlotArray_+3A_legend">legend</code></td>
<td>
<p>Logical. Draw a legend?</p>
</td></tr>
<tr><td><code id="ctPlotArray_+3A_legendcontrol">legendcontrol</code></td>
<td>
<p>list of arguments to pass to <code><a href="graphics.html#topic+legend">legend</a></code>.</p>
</td></tr>
<tr><td><code id="ctPlotArray_+3A_polygon">polygon</code></td>
<td>
<p>Logical. Draw the uncertainty polygon?</p>
</td></tr>
<tr><td><code id="ctPlotArray_+3A_polygonalpha">polygonalpha</code></td>
<td>
<p>Numeric, multiplier for alpha (transparency) of the 
uncertainty polygon.</p>
</td></tr>
<tr><td><code id="ctPlotArray_+3A_polygoncontrol">polygoncontrol</code></td>
<td>
<p>list of arguments to pass to <code><a href="#topic+ctPoly">ctPoly</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing. Generates plots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#'
input&lt;-ctStanTIpredeffects(ctstantestfit, plot=FALSE, whichpars='CINT', 
 nsamples=10,nsubjects=10)
    
ctPlotArray(input=input)

</code></pre>

<hr>
<h2 id='ctPoly'>Plots uncertainty bands with shading</h2><span id='topic+ctPoly'></span>

<h3>Description</h3>

<p>Plots uncertainty bands with shading
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctPoly(x, y, ylow, yhigh, steps = 20, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctPoly_+3A_x">x</code></td>
<td>
<p>x values</p>
</td></tr>
<tr><td><code id="ctPoly_+3A_y">y</code></td>
<td>
<p>y values</p>
</td></tr>
<tr><td><code id="ctPoly_+3A_ylow">ylow</code></td>
<td>
<p>lower limits of y</p>
</td></tr>
<tr><td><code id="ctPoly_+3A_yhigh">yhigh</code></td>
<td>
<p>upper limits of y</p>
</td></tr>
<tr><td><code id="ctPoly_+3A_steps">steps</code></td>
<td>
<p>number of polygons to overlay - higher integers lead to 
smoother changes in transparency between y and yhigh / ylow.</p>
</td></tr>
<tr><td><code id="ctPoly_+3A_...">...</code></td>
<td>
<p>arguments to pass to polygon()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing. Adds a polygon to existing plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(0:100,sqrt(0:100),type='l')
ctPoly(x=0:100, y=sqrt(0:100), 
yhigh=sqrt(0:100) - runif(101), 
ylow=sqrt(0:100) + runif(101),
col=adjustcolor('red',alpha.f=.1))
</code></pre>

<hr>
<h2 id='ctPostPredData'>Create a data.table to compare data generated from a ctsem fit with the original data.</h2><span id='topic+ctPostPredData'></span>

<h3>Description</h3>

<p>This function allows for easy comparison of data generated from a fitted ctsem model
with the original data used to fit the model. It provides options to include residuals
in the comparison.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctPostPredData(fit, residuals = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctPostPredData_+3A_fit">fit</code></td>
<td>
<p>A fitted ctsem model.</p>
</td></tr>
<tr><td><code id="ctPostPredData_+3A_residuals">residuals</code></td>
<td>
<p>If set to TRUE, includes residuals in the comparison.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data table containing the comparison between generated and original data.
</p>


<h3>See Also</h3>

<p>Other ctsem functions for model fitting and analysis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data_comparison &lt;- ctPostPredData(ctstantestfit)

</code></pre>

<hr>
<h2 id='ctPostPredPlots'>Create diagnostic plots to assess the goodness-of-fit for a ctsem model.</h2><span id='topic+ctPostPredPlots'></span>

<h3>Description</h3>

<p>This function generates a set of diagnostic plots to assess the goodness-of-fit for
a fitted ctsem model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctPostPredPlots(fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctPostPredPlots_+3A_fit">fit</code></td>
<td>
<p>A fitted ctsem model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calculates various statistics and creates visualizations to evaluate
how well the generated data matches the original data used to fit the model. The plots
included are as follows:
- A scatter plot comparing observed values and the median of generated data.
- A plot showing the proportion of observed data outside the 95
- A density plot of the proportion of observed data greater than the generated data.
- A time series plot of the proportion of observed data greater than generated data.
</p>


<h3>See Also</h3>

<p>Other ctsem functions for model fitting and analysis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ctPostPredPlots(ctstantestfit)

</code></pre>

<hr>
<h2 id='ctResiduals'>Extract Standardized Residuals from a ctsem Fit</h2><span id='topic+ctResiduals'></span>

<h3>Description</h3>

<p>This function takes a fit object from the ctsem package and extracts the standardized residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctResiduals(fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctResiduals_+3A_fit">fit</code></td>
<td>
<p>A fitted model object generated by the ctsem package.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the <code><a href="#topic+ctStanKalman">ctStanKalman</a></code> function to calculate the standardized residuals
and then extracts and formats them as a data table. The standardized residuals represent the differences
between the observed and predicted values, divided by the standard errors of the observations.
</p>


<h3>Value</h3>

<p>A data table containing the standardized residuals for each subject and time point.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ctStanKalman">ctStanKalman</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.table::setDTthreads(1) #ignore this line
# Example usage:
residuals &lt;- ctResiduals(ctstantestfit)

</code></pre>

<hr>
<h2 id='ctsem-package'>ctsem</h2><span id='topic+ctsem'></span><span id='topic+ctsem-package'></span>

<h3>Description</h3>

<p>ctsem is an R package for continuous time structural equation modelling of panel (N &gt; 1) 
and time series (N = 1) data, using either a frequentist or Bayesian approach, or middle
ground forms like maximum a posteriori. 
</p>
<p>The general workflow begins by specifying a model using the <code><a href="#topic+ctModel">ctModel</a></code> function, 
in which the <code>type</code> of model is also specified. Then the model is fit to data using 
<code><a href="#topic+ctStanFit">ctStanFit</a></code>. The ctFit function which allows for fitting using the OpenMx / SEM form,
as described in the original JSS ctsem paper, can now be found in the ctsemOMX package.  
The omx forms are no longer in 
development and for most purposes, the newer stan based forms are more robust and flexible.
For examples, see  <code><a href="#topic+ctStanFit">ctStanFit</a></code>. 
For citation info, please run <code>citation('ctsem')</code> .
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Charles Driver <a href="mailto:charles.driver@ife.uzh.ch">charles.driver@ife.uzh.ch</a> [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Manuel Voelkle [copyright holder]
</p>
</li>
<li><p> Han Oud [copyright holder]
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Trustees of Columbia University [copyright holder]
</p>
</li></ul>



<h3>References</h3>

<p>https://www.jstatsoft.org/article/view/v077i05
</p>
<p>Driver, C. C., &amp; Voelkle, M. C. (2018). Hierarchical Bayesian continuous time dynamic modeling. 
Psychological Methods. Advance online publication.http://dx.doi.org/10.1037/met0000168
</p>
<p>Stan Development Team (2018). RStan: the R interface to Stan. R package version 2.17.3. http://mc-stan.org
</p>
<p>#' @keywords internal
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/cdriveraus/ctsem">https://github.com/cdriveraus/ctsem</a>
</p>
</li></ul>


<hr>
<h2 id='ctStanContinuousPars'>ctStanContinuousPars</h2><span id='topic+ctStanContinuousPars'></span>

<h3>Description</h3>

<p>Returns the continuous time parameter matrices of a ctStanFit fit object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctStanContinuousPars(
  fit,
  calcfunc = quantile,
  calcfuncargs = list(probs = 0.5),
  timeinterval = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctStanContinuousPars_+3A_fit">fit</code></td>
<td>
<p>fit object from <code><a href="#topic+ctStanFit">ctStanFit</a></code></p>
</td></tr>
<tr><td><code id="ctStanContinuousPars_+3A_calcfunc">calcfunc</code></td>
<td>
<p>Function to apply over samples, must return a single value. 
By default the median over all samples is returned using the <code><a href="stats.html#topic+quantile">quantile</a></code> function, 
but one might also be interested in the <code><a href="base.html#topic+mean">mean</a></code> or <code><a href="stats.html#topic+sd">sd</a></code>, for instance.</p>
</td></tr>
<tr><td><code id="ctStanContinuousPars_+3A_calcfuncargs">calcfuncargs</code></td>
<td>
<p>A list of additional parameters to pass to calcfunc. 
For instance, with the default of calcfunc = quantile, 
the probs argument is needed to ensure only a single value is returned.</p>
</td></tr>
<tr><td><code id="ctStanContinuousPars_+3A_timeinterval">timeinterval</code></td>
<td>
<p>time interval for discrete time parameter matrix computation.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#posterior median over all subjects (also reflects mean of unconstrained pars)
ctStanContinuousPars(ctstantestfit)

</code></pre>

<hr>
<h2 id='ctStanDiscretePars'>ctStanDiscretePars</h2><span id='topic+ctStanDiscretePars'></span>

<h3>Description</h3>

<p>Calculate model implied regressions for a sequence of time intervals (if ct) or steps (if dt) based on
a ctStanFit object, for specified subjects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctStanDiscretePars(
  ctstanfitobj,
  subjects = "popmean",
  times = seq(from = 0, to = 10, by = 0.1),
  nsamples = 100,
  observational = FALSE,
  standardise = FALSE,
  cov = FALSE,
  plot = FALSE,
  cores = 2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctStanDiscretePars_+3A_ctstanfitobj">ctstanfitobj</code></td>
<td>
<p>model fit from <code><a href="#topic+ctStanFit">ctStanFit</a></code></p>
</td></tr>
<tr><td><code id="ctStanDiscretePars_+3A_subjects">subjects</code></td>
<td>
<p>Either 'popmean', to use the population mean parameter, or a vector of integers denoting which
subjects.</p>
</td></tr>
<tr><td><code id="ctStanDiscretePars_+3A_times">times</code></td>
<td>
<p>Numeric vector of positive values, discrete time parameters will be calculated for each. If the fit 
object is a discrete time model, these should be positive integers.</p>
</td></tr>
<tr><td><code id="ctStanDiscretePars_+3A_nsamples">nsamples</code></td>
<td>
<p>Number of samples from the stanfit to use for plotting. Higher values will
increase smoothness / accuracy, at cost of plotting speed. Values greater than the total
number of samples will be set to total samples.</p>
</td></tr>
<tr><td><code id="ctStanDiscretePars_+3A_observational">observational</code></td>
<td>
<p>Logical. If TRUE, outputs expected change in processes *conditional on observing* a 1 unit change in each &ndash; 
this change is correlated according to the DIFFUSION matrix. If FALSE, outputs expected regression values &ndash; also interpretable as
an independent 1 unit change on each process, giving the expected response under a 1 unit experimental impulse.</p>
</td></tr>
<tr><td><code id="ctStanDiscretePars_+3A_standardise">standardise</code></td>
<td>
<p>Logical. If TRUE, output is standardised according to expected total within subject variance, given by the 
asymDIFFUSIONcov matrix.</p>
</td></tr>
<tr><td><code id="ctStanDiscretePars_+3A_cov">cov</code></td>
<td>
<p>Logical. If TRUE, covariances are returned instead of regression coefficients.</p>
</td></tr>
<tr><td><code id="ctStanDiscretePars_+3A_plot">plot</code></td>
<td>
<p>Logical. If TRUE, plots output using <code><a href="#topic+ctStanDiscreteParsPlot">ctStanDiscreteParsPlot</a></code>
instead of returning output.</p>
</td></tr>
<tr><td><code id="ctStanDiscretePars_+3A_cores">cores</code></td>
<td>
<p>Number of cpu cores to use for computing subject matrices. 
If subject matrices were saved during fiting, not used.</p>
</td></tr>
<tr><td><code id="ctStanDiscretePars_+3A_...">...</code></td>
<td>
<p>additional plotting arguments to control <code><a href="#topic+ctStanDiscreteParsPlot">ctStanDiscreteParsPlot</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data.table::setDTthreads(1) #ignore this line
ctStanDiscretePars(ctstantestfit,times=seq(.5,4,.1), 
 plot=TRUE,indices='CR')
 
#modify plot
require(ggplot2)
g=ctStanDiscretePars(ctstantestfit,times=seq(.5,4,.1), 
 plot=TRUE,indices='CR')
g= g+ labs(title='Cross effects')
print(g)
</code></pre>

<hr>
<h2 id='ctStanDiscreteParsPlot'>ctStanDiscreteParsPlot</h2><span id='topic+ctStanDiscreteParsPlot'></span>

<h3>Description</h3>

<p>Plots model implied regression strengths at specified times for 
continuous time models fit with ctStanFit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctStanDiscreteParsPlot(
  x,
  indices = "all",
  quantiles = c(0.025, 0.5, 0.975),
  latentNames = "auto",
  ylab = "Coefficient",
  xlab = "Time interval",
  ylim = NA,
  facets = NA,
  splitSubjects = TRUE,
  colour = "Effect",
  title = "Temporal regressions | independent shock of 1.0",
  polygonalpha = 0.1,
  ggcode = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctStanDiscreteParsPlot_+3A_x">x</code></td>
<td>
<p>list object returned from <code><a href="#topic+ctStanDiscretePars">ctStanDiscretePars</a></code>.</p>
</td></tr>
<tr><td><code id="ctStanDiscreteParsPlot_+3A_indices">indices</code></td>
<td>
<p>Either a string specifying type of plot to create, or an n by 2
matrix specifying which indices of the output matrix to plot.
'AR' specifies all diagonals, for discrete time autoregression parameters.
'CR' specifies all off-diagonals,for discrete time cross regression parameters.
'all' plots all AR and CR effects at once.</p>
</td></tr>
<tr><td><code id="ctStanDiscreteParsPlot_+3A_quantiles">quantiles</code></td>
<td>
<p>numeric vector of length 3, with values between 0 and 1, specifying which quantiles to plot.
The default of c(.05,.5,.95) plots 95% credible intervals and the posterior median at 50%.</p>
</td></tr>
<tr><td><code id="ctStanDiscreteParsPlot_+3A_latentnames">latentNames</code></td>
<td>
<p>Vector of character strings denoting names for the latent variables. 
'auto' just uses eta1 eta2 etc.</p>
</td></tr>
<tr><td><code id="ctStanDiscreteParsPlot_+3A_ylab">ylab</code></td>
<td>
<p>y label.</p>
</td></tr>
<tr><td><code id="ctStanDiscreteParsPlot_+3A_xlab">xlab</code></td>
<td>
<p>x label.</p>
</td></tr>
<tr><td><code id="ctStanDiscreteParsPlot_+3A_ylim">ylim</code></td>
<td>
<p>Custom ylim.</p>
</td></tr>
<tr><td><code id="ctStanDiscreteParsPlot_+3A_facets">facets</code></td>
<td>
<p>May be 'Subject' or 'Effect'.</p>
</td></tr>
<tr><td><code id="ctStanDiscreteParsPlot_+3A_splitsubjects">splitSubjects</code></td>
<td>
<p>if TRUE, subjects are plotted separately, if FALSE they are combined.</p>
</td></tr>
<tr><td><code id="ctStanDiscreteParsPlot_+3A_colour">colour</code></td>
<td>
<p>Character string denoting how colour varies. 'Effect' or 'Subject'.</p>
</td></tr>
<tr><td><code id="ctStanDiscreteParsPlot_+3A_title">title</code></td>
<td>
<p>Character string.</p>
</td></tr>
<tr><td><code id="ctStanDiscreteParsPlot_+3A_polygonalpha">polygonalpha</code></td>
<td>
<p>Numeric between 0 and 1 to multiply the alpha of 
the fill.</p>
</td></tr>
<tr><td><code id="ctStanDiscreteParsPlot_+3A_ggcode">ggcode</code></td>
<td>
<p>if TRUE, returns a list containing the data.table to plot, and a character string that can be
evaluated (with the necessary arguments such as ylab etc filled in). For modifying plots.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object. This can be modified by the various ggplot2 functions, or displayed using print(x).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.table::setDTthreads(1) #ignore this line
x &lt;- ctStanDiscretePars(ctstantestfit)
ctStanDiscreteParsPlot(x, indices='CR')

#to modify plot:
g &lt;- ctStanDiscreteParsPlot(x, indices='CR') + 
 ggplot2::labs(title='My ggplot modification')
print(g)

</code></pre>

<hr>
<h2 id='ctStanFit'>ctStanFit</h2><span id='topic+ctStanFit'></span>

<h3>Description</h3>

<p>Fits a ctsem model specified via <code><a href="#topic+ctModel">ctModel</a></code> with type either 'stanct' or 'standt'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctStanFit(
  datalong,
  ctstanmodel,
  stanmodeltext = NA,
  iter = 1000,
  intoverstates = TRUE,
  binomial = FALSE,
  fit = TRUE,
  intoverpop = "auto",
  sameInitialTimes = FALSE,
  stationary = FALSE,
  plot = FALSE,
  derrind = NA,
  optimize = TRUE,
  optimcontrol = list(),
  nlcontrol = list(),
  nopriors = NA,
  priors = FALSE,
  chains = 2,
  cores = ifelse(optimize, getOption("mc.cores", 2L), "maxneeded"),
  inits = NULL,
  forcerecompile = FALSE,
  saveCompile = TRUE,
  savescores = FALSE,
  savesubjectmatrices = FALSE,
  saveComplexPars = FALSE,
  gendata = FALSE,
  control = list(),
  verbose = 0,
  vb = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctStanFit_+3A_datalong">datalong</code></td>
<td>
<p>long format data containing columns for subject id (numeric values, 1 to max subjects), manifest variables, 
any time dependent (i.e. varying within subject) predictors, 
and any time independent (not varying within subject) predictors.</p>
</td></tr>
<tr><td><code id="ctStanFit_+3A_ctstanmodel">ctstanmodel</code></td>
<td>
<p>model object as generated by <code><a href="#topic+ctModel">ctModel</a></code> with type='stanct' or 'standt', for continuous or discrete time
models respectively.</p>
</td></tr>
<tr><td><code id="ctStanFit_+3A_stanmodeltext">stanmodeltext</code></td>
<td>
<p>already specified Stan model character string, generally leave NA unless modifying Stan model directly.
(Possible after modification of output from fit=FALSE)</p>
</td></tr>
<tr><td><code id="ctStanFit_+3A_iter">iter</code></td>
<td>
<p>used when <code>optimize=FALSE</code>. number of iterations, half of which will be devoted to warmup by default when sampling.
When optimizing, this is the maximum number of iterations to allow &ndash; convergence hopefully occurs before this!</p>
</td></tr>
<tr><td><code id="ctStanFit_+3A_intoverstates">intoverstates</code></td>
<td>
<p>logical indicating whether or not to integrate over latent states using a Kalman filter. 
Generally recommended to set TRUE unless using non-gaussian measurement model.</p>
</td></tr>
<tr><td><code id="ctStanFit_+3A_binomial">binomial</code></td>
<td>
<p>Deprecated. Logical indicating the use of binary rather than Gaussian data, as with IRT analyses.
This now sets <code>intoverstates = FALSE</code> and the <code>manifesttype</code> of every indicator to 1, for binary.</p>
</td></tr>
<tr><td><code id="ctStanFit_+3A_fit">fit</code></td>
<td>
<p>If TRUE, fit specified model using Stan, if FALSE, return stan model object without fitting.</p>
</td></tr>
<tr><td><code id="ctStanFit_+3A_intoverpop">intoverpop</code></td>
<td>
<p>if 'auto', set to TRUE if optimizing and FALSE if using hmc. 
if TRUE, integrates over population distribution of parameters rather than full sampling.
Allows for optimization of non-linearities and random effects.</p>
</td></tr>
<tr><td><code id="ctStanFit_+3A_sameinitialtimes">sameInitialTimes</code></td>
<td>
<p>if TRUE, include an empty observation for every subject that has no observation 
at the earliest observation time of the dataset. This ensures that the T0MEANS occurs for every subject at the same time,
rather than just at the earliest observation for that subject. Important when modelling trends over time, age, etc.</p>
</td></tr>
<tr><td><code id="ctStanFit_+3A_stationary">stationary</code></td>
<td>
<p>Logical. If TRUE, T0VAR and T0MEANS input matrices are ignored, 
the parameters are instead fixed to long run expectations. More control over this can be achieved
by instead setting parameter names of T0MEANS and T0VAR matrices in the input model to 'stationary', for
elements that should be fixed to stationarity.</p>
</td></tr>
<tr><td><code id="ctStanFit_+3A_plot">plot</code></td>
<td>
<p>if TRUE, for sampling, a Shiny program is launched upon fitting to interactively plot samples. 
May struggle with many (e.g., &gt; 5000) parameters. For optimizing, various optimization details are plotted &ndash; in development.</p>
</td></tr>
<tr><td><code id="ctStanFit_+3A_derrind">derrind</code></td>
<td>
<p>deprecated, latents involved in dynamic error calculations are determined automatically now.</p>
</td></tr>
<tr><td><code id="ctStanFit_+3A_optimize">optimize</code></td>
<td>
<p>if TRUE, use <code><a href="#topic+stanoptimis">stanoptimis</a></code> function for maximum a posteriori / importance sampling estimates, 
otherwise use the HMC sampler from Stan, which is (much) slower, but generally more robust, accurate, and informative.</p>
</td></tr>
<tr><td><code id="ctStanFit_+3A_optimcontrol">optimcontrol</code></td>
<td>
<p>list of parameters sent to <code><a href="#topic+stanoptimis">stanoptimis</a></code> governing optimization / importance sampling.</p>
</td></tr>
<tr><td><code id="ctStanFit_+3A_nlcontrol">nlcontrol</code></td>
<td>
<p>List of non-linear control parameters. 
<code>maxtimestep</code> must be a positive numeric,  specifying the largest time
span covered by the numerical integration. The large default ensures that for each observation time interval, 
only a single step of exponential integration is used. When <code>maxtimestep</code> is smaller than the observation time interval, 
the integration is nested within an Euler like loop. 
Smaller values may offer greater accuracy, but are slower and not always necessary. Given the exponential integration,
linear model elements are fit exactly with only a single step.</p>
</td></tr>
<tr><td><code id="ctStanFit_+3A_nopriors">nopriors</code></td>
<td>
<p>deprecated, use priors argument. logical. If TRUE, any priors are disabled &ndash; sometimes desirable for optimization.</p>
</td></tr>
<tr><td><code id="ctStanFit_+3A_priors">priors</code></td>
<td>
<p>if TRUE, priors are included in computations, otherwise specified priors are ignored.</p>
</td></tr>
<tr><td><code id="ctStanFit_+3A_chains">chains</code></td>
<td>
<p>used when <code>optimize=FALSE</code>. Number of chains to sample, during HMC or post-optimization importance sampling. Unless the cores
argument is also set, the number of chains determines the number of cpu cores used, up to 
the maximum available minus one. Irrelevant when <code>optimize=TRUE</code>.</p>
</td></tr>
<tr><td><code id="ctStanFit_+3A_cores">cores</code></td>
<td>
<p>number of cpu cores to use. Either 'maxneeded' to use as many as available minus one,
up to the number of chains, or a positive integer. If <code>optimize=TRUE</code>, more cores are generally faster.</p>
</td></tr>
<tr><td><code id="ctStanFit_+3A_inits">inits</code></td>
<td>
<p>either character string 'optimize, NULL, or vector of (unconstrained)
parameter start values, as returned by the rstan function <code>rstan::unconstrain_pars</code>, or the parameter values
found in a ctsem fit object <code>myfit$stanfit$rawest</code> (or <code>$rawposterior</code>) for instance.</p>
</td></tr>
<tr><td><code id="ctStanFit_+3A_forcerecompile">forcerecompile</code></td>
<td>
<p>logical. For development purposes. 
If TRUE, stan model is recompiled, regardless of apparent need for compilation.</p>
</td></tr>
<tr><td><code id="ctStanFit_+3A_savecompile">saveCompile</code></td>
<td>
<p>if TRUE and compilation is needed / requested, writes the stan model to
the parent frame as ctsem.compiled (unless that object already exists and is not from ctsem), to avoid unnecessary recompilation.</p>
</td></tr>
<tr><td><code id="ctStanFit_+3A_savescores">savescores</code></td>
<td>
<p>Logical. If TRUE, output from the Kalman filter is saved in output. For datasets with many variables
or time points, will increase file size substantially.</p>
</td></tr>
<tr><td><code id="ctStanFit_+3A_savesubjectmatrices">savesubjectmatrices</code></td>
<td>
<p>Logical. If TRUE, subject specific matrices are saved &ndash; 
only relevant when either time dependent predictors or individual differences are 
used. Can increase memory usage dramatically in large models, and can be computed after fitting using ctExtract
or ctStanSubjectPars .</p>
</td></tr>
<tr><td><code id="ctStanFit_+3A_savecomplexpars">saveComplexPars</code></td>
<td>
<p>Logical. If TRUE, also save rowwise output of any complex parameters specified,
i.e. combinations of parameters, functions and states.</p>
</td></tr>
<tr><td><code id="ctStanFit_+3A_gendata">gendata</code></td>
<td>
<p>Logical &ndash; If TRUE, uses provided data for only covariates and a time and missingness structure, and 
generates random data according to the specified model / priors. 
Generated data is in the $Ygen subobject after running <code>extract</code> on the fit object.
For datasets with many manifest variables or time points, file size may be large.
To generate data based on the posterior of a fitted model, see <code><a href="#topic+ctStanGenerateFromFit">ctStanGenerateFromFit</a></code>.</p>
</td></tr>
<tr><td><code id="ctStanFit_+3A_control">control</code></td>
<td>
<p>Used when <code>optimize=FALSE</code>. List of arguments sent to <code><a href="rstan.html#topic+stan">stan</a></code> control argument, 
regarding warmup / sampling behaviour. Unless specified, values used are:
list(adapt_delta = .8, adapt_window=2, max_treedepth=10, adapt_init_buffer=2, stepsize = .001)</p>
</td></tr>
<tr><td><code id="ctStanFit_+3A_verbose">verbose</code></td>
<td>
<p>Integer from 0 to 2. Higher values print more information during model fit &ndash; for debugging.</p>
</td></tr>
<tr><td><code id="ctStanFit_+3A_vb">vb</code></td>
<td>
<p>Logical. Use variational Bayes algorithm from stan? Only kind of working, not recommended.</p>
</td></tr>
<tr><td><code id="ctStanFit_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to <code><a href="rstan.html#topic+stan">stan</a></code> function.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>

#generate a ctStanModel relying heavily on defaults
model&lt;-ctModel(type='stanct',
  latentNames=c('eta1','eta2'),
  manifestNames=c('Y1','Y2'),
  MANIFESTVAR=diag(.1,2),
  TDpredNames='TD1', 
  TIpredNames=c('TI1','TI2','TI3'),
  LAMBDA=diag(2)) 

fit&lt;-ctStanFit(ctstantestdat, model,priors=TRUE)

summary(fit) 

plot(fit,wait=FALSE)

#### extended examples

library(ctsem)
set.seed(3)

#  Data generation (run this, but no need to understand!) -----------------

Tpoints &lt;- 20
nmanifest &lt;- 4
nlatent &lt;- 2
nsubjects&lt;-20

#random effects
age &lt;- rnorm(nsubjects) #standardised
cint1&lt;-rnorm(nsubjects,2,.3)+age*.5
cint2 &lt;- cint1*.5+rnorm(nsubjects,1,.2)+age*.5
tdpredeffect &lt;- rnorm(nsubjects,5,.3)+age*.5

for(i in 1:nsubjects){
  #generating model
  gm&lt;-ctModel(Tpoints=Tpoints,n.manifest = nmanifest,n.latent = nlatent,n.TDpred = 1,
    LAMBDA = matrix(c(1,0,0,0, 0,1,.8,1.3),nrow=nmanifest,ncol=nlatent),
    DRIFT=matrix(c(-.3, .2, 0, -.5),nlatent,nlatent),
    TDPREDMEANS=matrix(c(rep(0,Tpoints-10),1,rep(0,9)),ncol=1),
    TDPREDEFFECT=matrix(c(tdpredeffect[i],0),nrow=nlatent),
    DIFFUSION = matrix(c(1, 0, 0, .5),2,2),
    CINT = matrix(c(cint1[i],cint2[i]),ncol=1),
    T0VAR=diag(2,nlatent,nlatent),
    MANIFESTVAR = diag(.5, nmanifest))

  #generate data
  newdat &lt;- ctGenerate(ctmodelobj = gm,n.subjects = 1,burnin = 2,
    dtmat&lt;-rbind(c(rep(.5,8),3,rep(.5,Tpoints-9))))
  newdat[,'id'] &lt;- i #set id for each subject
  newdat &lt;- cbind(newdat,age[i]) #include time independent predictor
  if(i ==1) {
    dat &lt;- newdat[1:(Tpoints-10),] #pre intervention data
    dat2 &lt;- newdat #including post intervention data
  }
  if(i &gt; 1) {
    dat &lt;- rbind(dat, newdat[1:(Tpoints-10),])
    dat2 &lt;- rbind(dat2,newdat)
  }
}
colnames(dat)[ncol(dat)] &lt;- 'age'
colnames(dat2)[ncol(dat)] &lt;- 'age'


#plot generated data for sanity
plot(age)
matplot(dat[,gm$manifestNames],type='l',pch=1)
plotvar &lt;- 'Y1'
plot(dat[dat[,'id']==1,'time'],dat[dat[,'id']==1,plotvar],type='l',
  ylim=range(dat[,plotvar],na.rm=TRUE))
for(i in 2:nsubjects){
  points(dat[dat[,'id']==i,'time'],dat[dat[,'id']==i,plotvar],type='l',col=i)
}


dat2[,gm$manifestNames][sample(1:length(dat2[,gm$manifestNames]),size = 100)] &lt;- NA


#data structure
head(dat2)


# Model fitting -----------------------------------------------------------

##simple univariate default model

m &lt;- ctModel(type = 'stanct', manifestNames = c('Y1'), LAMBDA = diag(1))
ctModelLatex(m)

#Specify univariate linear growth curve

m1 &lt;- ctModel(type = 'stanct',
  manifestNames = c('Y1'), latentNames=c('eta1'),
  DRIFT=matrix(-.0001,nrow=1,ncol=1),
  DIFFUSION=matrix(0,nrow=1,ncol=1),
  T0VAR=matrix(0,nrow=1,ncol=1),
  CINT=matrix(c('cint1'),ncol=1),
  T0MEANS=matrix(c('t0m1'),ncol=1),
  LAMBDA = diag(1),
  MANIFESTMEANS=matrix(0,ncol=1),
  MANIFESTVAR=matrix(c('merror'),nrow=1,ncol=1))

ctModelLatex(m1)

#fit
f1 &lt;- ctStanFit(datalong = dat2, ctstanmodel = m1, optimize=TRUE, priors=FALSE)

summary(f1)

#plots of individual subject models v data
ctKalman(f1,plot=TRUE,subjects=1,kalmanvec=c('y','yprior'),timestep=.01)
ctKalman(f1,plot=TRUE,subjects=1:3,kalmanvec=c('y','ysmooth'),timestep=.01,errorvec=NA)

ctStanPostPredict(f1, wait=FALSE) #compare randomly generated data from posterior to observed data

cf&lt;-ctCheckFit(f1) #compare mean and covariance of randomly generated data to observed cov
plot(cf,wait=FALSE)

 ### Further example models

#Include intervention
m2 &lt;- ctModel(type = 'stanct',
  manifestNames = c('Y1'), latentNames=c('eta1'),
  n.TDpred=1,TDpredNames = 'TD1', #this line includes the intervention
  TDPREDEFFECT=matrix(c('tdpredeffect'),nrow=1,ncol=1), #intervention effect
  DRIFT=matrix(-1e-5,nrow=1,ncol=1),
  DIFFUSION=matrix(0,nrow=1,ncol=1),
  CINT=matrix(c('cint1'),ncol=1),
  T0MEANS=matrix(c('t0m1'),ncol=1),
  T0VAR=matrix(0,nrow=1,ncol=1),
  LAMBDA = diag(1),
  MANIFESTMEANS=matrix(0,ncol=1),
  MANIFESTVAR=matrix(c('merror'),nrow=1,ncol=1))



#Individual differences in intervention, Bayesian estimation, covariates
m2i &lt;- ctModel(type = 'stanct',
  manifestNames = c('Y1'), latentNames=c('eta1'),
  TIpredNames = 'age',
  TDpredNames = 'TD1', #this line includes the intervention
  TDPREDEFFECT=matrix(c('tdpredeffect||TRUE'),nrow=1,ncol=1), #intervention effect
  DRIFT=matrix(-1e-5,nrow=1,ncol=1),
  DIFFUSION=matrix(0,nrow=1,ncol=1),
  CINT=matrix(c('cint1'),ncol=1),
  T0MEANS=matrix(c('t0m1'),ncol=1),
  T0VAR=matrix(0,nrow=1,ncol=1),
  LAMBDA = diag(1),
  MANIFESTMEANS=matrix(0,ncol=1),
  MANIFESTVAR=matrix(c('merror'),nrow=1,ncol=1))
  
  
#Including covariate effects
m2ic &lt;- ctModel(type = 'stanct',
  manifestNames = c('Y1'), latentNames=c('eta1'),
  n.TIpred = 1, TIpredNames = 'age',
  n.TDpred=1,TDpredNames = 'TD1', #this line includes the intervention
  TDPREDEFFECT=matrix(c('tdpredeffect'),nrow=1,ncol=1), #intervention effect
  DRIFT=matrix(-1e-5,nrow=1,ncol=1),
  DIFFUSION=matrix(0,nrow=1,ncol=1),
  CINT=matrix(c('cint1'),ncol=1),
  T0MEANS=matrix(c('t0m1'),ncol=1),
  T0VAR=matrix(0,nrow=1,ncol=1),
  LAMBDA = diag(1),
  MANIFESTMEANS=matrix(0,ncol=1),
  MANIFESTVAR=matrix(c('merror'),nrow=1,ncol=1))

m2ic$pars$indvarying[m2ic$pars$matrix %in% 'TDPREDEFFECT'] &lt;- TRUE


#Include deterministic dynamics
m3 &lt;- ctModel(type = 'stanct',
  manifestNames = c('Y1'), latentNames=c('eta1'),
  n.TDpred=1,TDpredNames = 'TD1', #this line includes the intervention
  TDPREDEFFECT=matrix(c('tdpredeffect'),nrow=1,ncol=1), #intervention effect
  DRIFT=matrix('drift11',nrow=1,ncol=1),
  DIFFUSION=matrix(0,nrow=1,ncol=1),
  CINT=matrix(c('cint1'),ncol=1),
  T0MEANS=matrix(c('t0m1'),ncol=1),
  T0VAR=matrix('t0var11',nrow=1,ncol=1),
  LAMBDA = diag(1),
  MANIFESTMEANS=matrix(0,ncol=1),
  MANIFESTVAR=matrix(c('merror1'),nrow=1,ncol=1))





#Add system noise to allow for fluctuations that persist in time
m3n &lt;- ctModel(type = 'stanct',
  manifestNames = c('Y1'), latentNames=c('eta1'),
  n.TDpred=1,TDpredNames = 'TD1', #this line includes the intervention
  TDPREDEFFECT=matrix(c('tdpredeffect'),nrow=1,ncol=1), #intervention effect
  DRIFT=matrix('drift11',nrow=1,ncol=1),
  DIFFUSION=matrix('diffusion',nrow=1,ncol=1),
  CINT=matrix(c('cint1'),ncol=1),
  T0MEANS=matrix(c('t0m1'),ncol=1),
  T0VAR=matrix('t0var11',nrow=1,ncol=1),
  LAMBDA = diag(1),
  MANIFESTMEANS=matrix(0,ncol=1),
  MANIFESTVAR=matrix(c(0),nrow=1,ncol=1))



#include 2nd latent process

m4 &lt;- ctModel(n.manifest = 2,n.latent = 2, type = 'stanct',
  manifestNames = c('Y1','Y2'), latentNames=c('L1','L2'),
  n.TDpred=1,TDpredNames = 'TD1',
  TDPREDEFFECT=matrix(c('tdpredeffect1','tdpredeffect2'),nrow=2,ncol=1),
  DRIFT=matrix(c('drift11','drift21','drift12','drift22'),nrow=2,ncol=2),
  DIFFUSION=matrix(c('diffusion11','diffusion21',0,'diffusion22'),nrow=2,ncol=2),
  CINT=matrix(c('cint1','cint2'),nrow=2,ncol=1),
  T0MEANS=matrix(c('t0m1','t0m2'),nrow=2,ncol=1),
  T0VAR=matrix(c('t0var11','t0var21',0,'t0var22'),nrow=2,ncol=2),
  LAMBDA = matrix(c(1,0,0,1),nrow=2,ncol=2),
  MANIFESTMEANS=matrix(c(0,0),nrow=2,ncol=1),
  MANIFESTVAR=matrix(c('merror1',0,0,'merror2'),nrow=2,ncol=2))

#dynamic factor model -- fixing CINT to 0 and freeing indicator level intercepts

m3df &lt;- ctModel(type = 'stanct',
  manifestNames = c('Y2','Y3'), latentNames=c('eta1'),
  n.TDpred=1,TDpredNames = 'TD1', #this line includes the intervention
  TDPREDEFFECT=matrix(c('tdpredeffect'),nrow=1,ncol=1), #intervention effect
  DRIFT=matrix('drift11',nrow=1,ncol=1),
  DIFFUSION=matrix('diffusion',nrow=1,ncol=1),
  CINT=matrix(c(0),ncol=1),
  T0MEANS=matrix(c('t0m1'),ncol=1),
  T0VAR=matrix('t0var11',nrow=1,ncol=1),
  LAMBDA = matrix(c(1,'Y3loading'),nrow=2,ncol=1),
  MANIFESTMEANS=matrix(c('Y2_int','Y3_int'),nrow=2,ncol=1),
  MANIFESTVAR=matrix(c('Y2residual',0,0,'Y3residual'),nrow=2,ncol=2))


</code></pre>

<hr>
<h2 id='ctStanFitUpdate'>Update a ctStanFit object</h2><span id='topic+ctStanFitUpdate'></span>

<h3>Description</h3>

<p>Either to include different data, or because you have upgraded ctsem and the internal data structure has changed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctStanFitUpdate(oldfit, data = NA, recompile = FALSE, refit = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctStanFitUpdate_+3A_oldfit">oldfit</code></td>
<td>
<p>fit object to be upgraded</p>
</td></tr>
<tr><td><code id="ctStanFitUpdate_+3A_data">data</code></td>
<td>
<p>replacement long format data object</p>
</td></tr>
<tr><td><code id="ctStanFitUpdate_+3A_recompile">recompile</code></td>
<td>
<p>whether to force a recompile &ndash; safer but slower and usually unnecessary.</p>
</td></tr>
<tr><td><code id="ctStanFitUpdate_+3A_refit">refit</code></td>
<td>
<p>if TRUE, refits the model using the old estimates as a starting point. Only applicable for
optimized fits, not sampling.</p>
</td></tr>
<tr><td><code id="ctStanFitUpdate_+3A_...">...</code></td>
<td>
<p>extra arguments to pass to ctStanFit</p>
</td></tr>
</table>


<h3>Value</h3>

<p>updated ctStanFit object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>newfit &lt;- ctStanFitUpdate(ctstantestfit,refit=FALSE)
</code></pre>

<hr>
<h2 id='ctStanGenerate'>Generate data from a ctstanmodel object</h2><span id='topic+ctStanGenerate'></span>

<h3>Description</h3>

<p>Generate data from a ctstanmodel object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctStanGenerate(
  cts,
  datastruct = NA,
  is = FALSE,
  fullposterior = TRUE,
  nsamples = 200,
  parsonly = FALSE,
  cores = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctStanGenerate_+3A_cts">cts</code></td>
<td>
<p><code><a href="#topic+ctStanModel">ctStanModel</a></code> , or <code><a href="#topic+ctStanFit">ctStanFit</a></code>,object.</p>
</td></tr>
<tr><td><code id="ctStanGenerate_+3A_datastruct">datastruct</code></td>
<td>
<p>long format data structure as used by ctsem. 
Not used if cts is a ctStanFit object.</p>
</td></tr>
<tr><td><code id="ctStanGenerate_+3A_is">is</code></td>
<td>
<p>If optimizing, follow up with importance sampling?</p>
</td></tr>
<tr><td><code id="ctStanGenerate_+3A_fullposterior">fullposterior</code></td>
<td>
<p>Generate from the full posterior or just the (unconstrained) mean?</p>
</td></tr>
<tr><td><code id="ctStanGenerate_+3A_nsamples">nsamples</code></td>
<td>
<p>How many samples to generate?</p>
</td></tr>
<tr><td><code id="ctStanGenerate_+3A_parsonly">parsonly</code></td>
<td>
<p>If TRUE, only return samples of raw parameters, don't generate data.</p>
</td></tr>
<tr><td><code id="ctStanGenerate_+3A_cores">cores</code></td>
<td>
<p>Number of cpu cores to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List contining Y, and array of nsamples by data rows by manifest variables, 
and llrow, an array of nsamples by data rows log likelihoods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#generate and plot samples from prior predictive
priorpred &lt;- ctStanGenerate(cts = ctstantestfit,cores=2,nsamples = 50)

</code></pre>

<hr>
<h2 id='ctStanGenerateFromFit'>Add a <code>$generated</code> object to ctstanfit object, with random data generated from posterior of ctstanfit object</h2><span id='topic+ctStanGenerateFromFit'></span>

<h3>Description</h3>

<p>Add a <code>$generated</code> object to ctstanfit object, with random data generated from posterior of ctstanfit object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctStanGenerateFromFit(
  fit,
  nsamples = 200,
  fullposterior = FALSE,
  verboseErrors = FALSE,
  cores = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctStanGenerateFromFit_+3A_fit">fit</code></td>
<td>
<p>ctstanfit object</p>
</td></tr>
<tr><td><code id="ctStanGenerateFromFit_+3A_nsamples">nsamples</code></td>
<td>
<p>Positive integer specifying number of datasets to generate.</p>
</td></tr>
<tr><td><code id="ctStanGenerateFromFit_+3A_fullposterior">fullposterior</code></td>
<td>
<p>Logical indicating whether to sample from the full posterior (original nsamples) or the posterior mean.</p>
</td></tr>
<tr><td><code id="ctStanGenerateFromFit_+3A_verboseerrors">verboseErrors</code></td>
<td>
<p>if TRUE, print verbose output when errors in generation encountered.</p>
</td></tr>
<tr><td><code id="ctStanGenerateFromFit_+3A_cores">cores</code></td>
<td>
<p>Number of cpu cores to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of generated data &ndash; one dataset per iteration, according to original time and missingness structure.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gen &lt;- ctStanGenerateFromFit(ctstantestfit, nsamples=3,fullposterior=TRUE,cores=1)
plot(gen$generated$Y[3,,2],type='l') #Third random data sample, 2nd manifest var, all time points. 
</code></pre>

<hr>
<h2 id='ctStanKalman'>Get Kalman filter estimates from a ctStanFit object</h2><span id='topic+ctStanKalman'></span>

<h3>Description</h3>

<p>Get Kalman filter estimates from a ctStanFit object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctStanKalman(
  fit,
  nsamples = NA,
  pointest = TRUE,
  collapsefunc = NA,
  cores = 1,
  subjects = 1:max(fit$standata$subject),
  timestep = "asdata",
  timerange = "asdata",
  standardisederrors = FALSE,
  subjectpars = TRUE,
  tformsubjectpars = TRUE,
  indvarstates = FALSE,
  removeObs = F,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctStanKalman_+3A_fit">fit</code></td>
<td>
<p>fit object from <code><a href="#topic+ctStanFit">ctStanFit</a></code>.</p>
</td></tr>
<tr><td><code id="ctStanKalman_+3A_nsamples">nsamples</code></td>
<td>
<p>either NA (to extract all) or a positive integer from 1 to maximum samples in the fit.</p>
</td></tr>
<tr><td><code id="ctStanKalman_+3A_pointest">pointest</code></td>
<td>
<p>If TRUE, uses the posterior mode as the single sample.</p>
</td></tr>
<tr><td><code id="ctStanKalman_+3A_collapsefunc">collapsefunc</code></td>
<td>
<p>function to apply over samples, such as <code>mean</code></p>
</td></tr>
<tr><td><code id="ctStanKalman_+3A_cores">cores</code></td>
<td>
<p>Integer number of cpu cores to use. Only needed if savescores was set to FALSE when fitting.</p>
</td></tr>
<tr><td><code id="ctStanKalman_+3A_subjects">subjects</code></td>
<td>
<p>integer vector of subjects to compute for.</p>
</td></tr>
<tr><td><code id="ctStanKalman_+3A_timestep">timestep</code></td>
<td>
<p>Either a positive numeric value, 'asdata' to use the times in the dataset, or 'auto' to select 
a timestep automatically (resulting in some interpolation but not excessive computation).</p>
</td></tr>
<tr><td><code id="ctStanKalman_+3A_timerange">timerange</code></td>
<td>
<p>only relevant if timestep is not 'asdata'. Positive numeric vector of length 2 denoting 
time range for computations.</p>
</td></tr>
<tr><td><code id="ctStanKalman_+3A_standardisederrors">standardisederrors</code></td>
<td>
<p>If TRUE, computes standardised errors for prior, upd, smooth conditions.</p>
</td></tr>
<tr><td><code id="ctStanKalman_+3A_subjectpars">subjectpars</code></td>
<td>
<p>if TRUE, state estimates are not returned, instead, predictions of each subjects parameters
are returned, for parameters that had random effects specified.</p>
</td></tr>
<tr><td><code id="ctStanKalman_+3A_tformsubjectpars">tformsubjectpars</code></td>
<td>
<p>if FALSE, subject level parameters are returned in raw, pre transformation form.</p>
</td></tr>
<tr><td><code id="ctStanKalman_+3A_indvarstates">indvarstates</code></td>
<td>
<p>if TRUE, do not remove indvarying states from output</p>
</td></tr>
<tr><td><code id="ctStanKalman_+3A_removeobs">removeObs</code></td>
<td>
<p>Logical or integer. If TRUE, observations (but not covariates)
are set to NA, so only expectations based on parameters and covariates are returned. If a positive integer N, 
every N observations are retained while others are set NA for computing model expectations &ndash; useful for observing prediction performance
forward further in time than one observation.</p>
</td></tr>
<tr><td><code id="ctStanKalman_+3A_...">...</code></td>
<td>
<p>additional arguments to collpsefunc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing Kalman filter elements, each element in array of
iterations, data row, variables. llrow is the log likelihood for each row of data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>k=ctStanKalman(ctstantestfit,subjectpars=TRUE,collapsefunc=mean)
</code></pre>

<hr>
<h2 id='ctStanModel'>Convert a frequentist (omx) ctsem model specification to Bayesian (Stan).</h2><span id='topic+ctStanModel'></span>

<h3>Description</h3>

<p>Convert a frequentist (omx) ctsem model specification to Bayesian (Stan).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctStanModel(ctmodelobj, type = "stanct", tipredDefault = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctStanModel_+3A_ctmodelobj">ctmodelobj</code></td>
<td>
<p>ctsem model object of type 'omx' (default)</p>
</td></tr>
<tr><td><code id="ctStanModel_+3A_type">type</code></td>
<td>
<p>either 'stanct' for continuous time, or 'standt' for discrete time.</p>
</td></tr>
<tr><td><code id="ctStanModel_+3A_tipreddefault">tipredDefault</code></td>
<td>
<p>Logical. TRUE sets any parameters with unspecified time independent 
predictor effects to have effects estimated, FALSE fixes the effect to zero unless individually specified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List object of class ctStanModel, with random effects specified for any intercept type parameters
(T0MEANS, MANIFESTMEANS, and or CINT), and time independent predictor effects for all parameters. Adjust these
after initial specification by directly editing the <code>pars</code> subobject, so <code>model$pars</code> .
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- ctModel(type='omx', Tpoints=50,
n.latent=2, n.manifest=1, 
manifestNames='sunspots', 
latentNames=c('ss_level', 'ss_velocity'),
LAMBDA=matrix(c( 1, 'ma1' ), nrow=1, ncol=2),
DRIFT=matrix(c(0, 1,   'a21', 'a22'), nrow=2, ncol=2, byrow=TRUE),
MANIFESTMEANS=matrix(c('m1'), nrow=1, ncol=1),
# MANIFESTVAR=matrix(0, nrow=1, ncol=1),
CINT=matrix(c(0, 0), nrow=2, ncol=1),
DIFFUSION=matrix(c(
  0, 0,
  0, "diffusion"), ncol=2, nrow=2, byrow=TRUE))

stanmodel=ctStanModel(model)


</code></pre>

<hr>
<h2 id='ctStanParnames'>ctStanParnames</h2><span id='topic+ctStanParnames'></span>

<h3>Description</h3>

<p>Gets internal stan parameter names of a ctStanFit object sampled via stan based on specified substrings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctStanParnames(x, substrings = c("pop_", "popsd"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctStanParnames_+3A_x">x</code></td>
<td>
<p>ctStanFit object</p>
</td></tr>
<tr><td><code id="ctStanParnames_+3A_substrings">substrings</code></td>
<td>
<p>vector of character strings, parameter names of the stan model
containing any of these strings will be returned. Useful strings may be 'pop_' for 
population means, 'popsd' for population standard deviations,
or specific combinations such as 'pop_DRIFT' for the population
means of temporal dynamics parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of character strings.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sunspots&lt;-sunspot.year
sunspots&lt;-sunspots[50: (length(sunspots) - (1988-1924))]
id &lt;- 1
time &lt;- 1749:1924
datalong &lt;- cbind(id, time, sunspots)

#setup model
ssmodel &lt;- ctModel(type='stanct', n.latent=2, n.manifest=1, 
 manifestNames='sunspots', 
 latentNames=c('ss_level', 'ss_velocity'),
 LAMBDA=matrix(c( 1, 'ma1| log(1+(exp(param)))' ), nrow=1, ncol=2),
 DRIFT=matrix(c(0, 'a21 | -log(1+exp(param))', 1, 'a22'), nrow=2, ncol=2),
 MANIFESTMEANS=matrix(c('m1|param * 10 + 44'), nrow=1, ncol=1),
 MANIFESTVAR=diag(0,1), #As per original spec
 CINT=matrix(c(0, 0), nrow=2, ncol=1),
 DIFFUSION=matrix(c(0, 0, 0, "diffusion"), ncol=2, nrow=2))

#fit
ssfit &lt;- ctStanFit(datalong, ssmodel, iter=2, 
  optimize=FALSE, chains=1)
ctStanParnames(ssfit,substrings=c('pop_','popsd'))


</code></pre>

<hr>
<h2 id='ctStanPlotPost'>ctStanPlotPost</h2><span id='topic+ctStanPlotPost'></span>

<h3>Description</h3>

<p>Plots prior and posterior distributions of model parameters in a ctStanModel or ctStanFit object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctStanPlotPost(
  obj,
  rows = "all",
  npp = 6,
  priorwidth = TRUE,
  smoothness = 1,
  priorsamples = 10000,
  plot = TRUE,
  wait = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctStanPlotPost_+3A_obj">obj</code></td>
<td>
<p>fit or model object as generated by <code><a href="#topic+ctStanFit">ctStanFit</a></code>,
<code><a href="#topic+ctModel">ctModel</a></code>, or <code><a href="#topic+ctStanModel">ctStanModel</a></code>.</p>
</td></tr>
<tr><td><code id="ctStanPlotPost_+3A_rows">rows</code></td>
<td>
<p>vector of integers denoting which rows of obj$setup$popsetup to plot priors for. 
Character string 'all' plots all rows with parameters to be estimated.</p>
</td></tr>
<tr><td><code id="ctStanPlotPost_+3A_npp">npp</code></td>
<td>
<p>Integer number of parameters to show per page.</p>
</td></tr>
<tr><td><code id="ctStanPlotPost_+3A_priorwidth">priorwidth</code></td>
<td>
<p>if TRUE, plots will be scaled to show bulk of both the prior 
and posterior distributions. If FALSE, scale is based only on the posterior.</p>
</td></tr>
<tr><td><code id="ctStanPlotPost_+3A_smoothness">smoothness</code></td>
<td>
<p>Positive numeric &ndash; multiplier to modify smoothness of density plots, higher is smoother but
can cause plots to exceed natural boundaries, such as standard deviations below zero.</p>
</td></tr>
<tr><td><code id="ctStanPlotPost_+3A_priorsamples">priorsamples</code></td>
<td>
<p>number of samples from prior to use. More is slower.</p>
</td></tr>
<tr><td><code id="ctStanPlotPost_+3A_plot">plot</code></td>
<td>
<p>Logical, if FALSE, ggplot objects are returned in a list instead of plotting.</p>
</td></tr>
<tr><td><code id="ctStanPlotPost_+3A_wait">wait</code></td>
<td>
<p>If true, user is prompted to continue before plotting next graph.
If false, graphs are plotted one after another without waiting.</p>
</td></tr>
<tr><td><code id="ctStanPlotPost_+3A_...">...</code></td>
<td>
<p>Parameters to pass to ctStanFit. <code>cores = x</code> will speed things up,
where x is the number of cpu cores to use.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
ctStanPlotPost(ctstantestfit, rows=3:4)

</code></pre>

<hr>
<h2 id='ctStanPostPredict'>Compares model implied density and values to observed, for a ctStanFit object.</h2><span id='topic+ctStanPostPredict'></span>

<h3>Description</h3>

<p>Compares model implied density and values to observed, for a ctStanFit object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctStanPostPredict(
  fit,
  diffsize = 1,
  jitter = 0.02,
  wait = TRUE,
  probs = c(0.025, 0.5, 0.975),
  datarows = "all",
  nsamples = 500,
  resolution = 100,
  plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctStanPostPredict_+3A_fit">fit</code></td>
<td>
<p>ctStanFit object.</p>
</td></tr>
<tr><td><code id="ctStanPostPredict_+3A_diffsize">diffsize</code></td>
<td>
<p>Integer &gt; 0. Number of discrete time lags to use for data viz.</p>
</td></tr>
<tr><td><code id="ctStanPostPredict_+3A_jitter">jitter</code></td>
<td>
<p>Positive numeric between 0 and 1, if TRUE, jitters empirical data by specified proportion of std dev.</p>
</td></tr>
<tr><td><code id="ctStanPostPredict_+3A_wait">wait</code></td>
<td>
<p>Logical, if TRUE and <code>plot=TRUE</code>, waits for input before plotting next plot.</p>
</td></tr>
<tr><td><code id="ctStanPostPredict_+3A_probs">probs</code></td>
<td>
<p>Vector of length 3 containing quantiles to plot &ndash; should be rising numeric values between 0 and 1.</p>
</td></tr>
<tr><td><code id="ctStanPostPredict_+3A_datarows">datarows</code></td>
<td>
<p>integer vector specifying rows of data to plot. Otherwise 'all' uses all data.</p>
</td></tr>
<tr><td><code id="ctStanPostPredict_+3A_nsamples">nsamples</code></td>
<td>
<p>Number of datasets to generate for comparisons, if fit object does not contain generated
data already.</p>
</td></tr>
<tr><td><code id="ctStanPostPredict_+3A_resolution">resolution</code></td>
<td>
<p>Positive integer, the number of rows and columns to split plots into for shading.</p>
</td></tr>
<tr><td><code id="ctStanPostPredict_+3A_plot">plot</code></td>
<td>
<p>logical. If FALSE, a list of ggplot objects is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function relies on the data generated during each iteration of fitting to approximate the
model implied distributions &ndash; thus, when limited iterations are available, the approximation will be worse.
</p>


<h3>Value</h3>

<p>If plot=FALSE, an array containing quantiles of generated data. If plot=TRUE, nothing, only plots.
</p>
<p>if plot=TRUE, nothing is returned and plots are created. Otherwise, a list containing ggplot objects is returned 
and may be customized as desired.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#'
ctStanPostPredict(ctstantestfit,wait=FALSE, diffsize=2,resolution=100)

</code></pre>

<hr>
<h2 id='ctStanSubjectPars'>Extract an array of subject specific parameters from a ctStanFit object.</h2><span id='topic+ctStanSubjectPars'></span>

<h3>Description</h3>

<p>Extract an array of subject specific parameters from a ctStanFit object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctStanSubjectPars(fit, pointest = TRUE, cores = 2, nsamples = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctStanSubjectPars_+3A_fit">fit</code></td>
<td>
<p>fit object</p>
</td></tr>
<tr><td><code id="ctStanSubjectPars_+3A_pointest">pointest</code></td>
<td>
<p>if TRUE, returns only the set of individual difference parameters
based on the max a posteriori estimate (or the median if sampling approaches were used).</p>
</td></tr>
<tr><td><code id="ctStanSubjectPars_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use.</p>
</td></tr>
<tr><td><code id="ctStanSubjectPars_+3A_nsamples">nsamples</code></td>
<td>
<p>Number of samples to calculate parameters for. Not used if pointest=TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the estimates of individual parameters, taking into account any
covariates and random effects.
</p>


<h3>Value</h3>

<p>an nsamples by nsubjects by nparams array.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>indpars &lt;- ctStanSubjectPars(ctstantestfit)
dimnames(indpars)
plot(indpars[1,,'cint1'],indpars[1,,'cint2'])
</code></pre>

<hr>
<h2 id='ctstantestdat'>ctstantestdat</h2><span id='topic+ctstantestdat'></span>

<h3>Description</h3>

<p>Generated dataset for testing <code><a href="#topic+ctStanFit">ctStanFit</a></code> from ctsem package.
</p>


<h3>Format</h3>

<p>matrix
</p>

<hr>
<h2 id='ctstantestfit'>ctstantestfit</h2><span id='topic+ctstantestfit'></span>

<h3>Description</h3>

<p>Dummy fit for testing functions from ctsem package.
</p>


<h3>Format</h3>

<p>ctStanFit object
</p>

<hr>
<h2 id='ctStanTIpredeffects'>Get time independent predictor effect estimates</h2><span id='topic+ctStanTIpredeffects'></span>

<h3>Description</h3>

<p>Computes and plots combined effects and quantiles for effects of time independent predictors
on subject level parameters of a ctStanFit object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctStanTIpredeffects(
  fit,
  returndifference = FALSE,
  probs = c(0.025, 0.5, 0.975),
  includeMeanUncertainty = FALSE,
  whichTIpreds = 1,
  parmatrices = TRUE,
  whichpars = "all",
  nsamples = 100,
  timeinterval = 1,
  nsubjects = 20,
  filter = NA,
  plot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctStanTIpredeffects_+3A_fit">fit</code></td>
<td>
<p>fit object from <code><a href="#topic+ctStanFit">ctStanFit</a></code></p>
</td></tr>
<tr><td><code id="ctStanTIpredeffects_+3A_returndifference">returndifference</code></td>
<td>
<p>logical. If FALSE, absolute parameter values are returned. 
If TRUE, only the effect of the covariate (i.e. without the average value of the parameter)
are returned. The former can be easier to interpret, but the latter are more likely to fit multiple plots together. 
Not used if <code>parmatrices=TRUE</code>.</p>
</td></tr>
<tr><td><code id="ctStanTIpredeffects_+3A_probs">probs</code></td>
<td>
<p>numeric vector of quantile probabilities from 0 to 1. Specify 3
values if plotting, the 2nd will be drawn as a line with uncertainty polygon
based on 1st and 3rd.</p>
</td></tr>
<tr><td><code id="ctStanTIpredeffects_+3A_includemeanuncertainty">includeMeanUncertainty</code></td>
<td>
<p>if TRUE, output includes sampling variation in the mean parameters. If FALSE,
mean parameters are fixed at their median, only uncertainty in time independent predictor effects is included.</p>
</td></tr>
<tr><td><code id="ctStanTIpredeffects_+3A_whichtipreds">whichTIpreds</code></td>
<td>
<p>integer vector specifying which of the tipreds in the fit object you want to
use to calculate effects. Unless quadratic / higher order versions of predictors have been 
included, selecting more than one probably doesn't make sense. If for instance a squared
predictor has been included, then you can specify both the linear and squared version. 
The x axis of the plot (if generated) will be based off the first indexed predictor. To 
check what predictors are in the model, run <code>fit$ctstanmodel$TIpredNames</code>.</p>
</td></tr>
<tr><td><code id="ctStanTIpredeffects_+3A_parmatrices">parmatrices</code></td>
<td>
<p>Logical. If TRUE (default), system matrices rather than specific parameters
are referenced &ndash; e.g. 'DRIFT' instead of a parameter name like drift12.</p>
</td></tr>
<tr><td><code id="ctStanTIpredeffects_+3A_whichpars">whichpars</code></td>
<td>
<p>if parmatrices==TRUE, character vector specifying which matrices, and potentially which 
indices of the matrices, to plot. c('dtDRIFT[2,1]', 'DRIFT') would output for row 2 and column 1 of 
the discrete time drift matrix, as well as all indices of the continuous time drift matrix. 
If parmatrices==FALSE, integer vector specifying which of the subject
level parameters to compute effects on. The integers corresponding to certain parameters can be found in the 
<code>param</code> column of the <code>fit$setup$matsetup</code> object. In either case 'all' uses all available parameters.</p>
</td></tr>
<tr><td><code id="ctStanTIpredeffects_+3A_nsamples">nsamples</code></td>
<td>
<p>Positive integer specifying the maximum number of saved iterations to use. 
Character string 'all' can also be used.</p>
</td></tr>
<tr><td><code id="ctStanTIpredeffects_+3A_timeinterval">timeinterval</code></td>
<td>
<p>positive numeric indicating time interval to use for discrete time parameter matrices,
if <code>parmatrices=TRUE</code>.</p>
</td></tr>
<tr><td><code id="ctStanTIpredeffects_+3A_nsubjects">nsubjects</code></td>
<td>
<p>Positive integer specifying the number of subjects to compute values for. When only one TIpred 
is used, this specifies the number of points along the curve.
Character string 'all' can also be used. Time taken for plotting is a function of nsubjects*niterations.</p>
</td></tr>
<tr><td><code id="ctStanTIpredeffects_+3A_filter">filter</code></td>
<td>
<p>either NA, or a length 2 vector, where the first element contains the time independent predictor index
to filter by, and the second contains the comparison operator in string form (e.g. &quot;&lt; 3&quot;,
to only calculate effects for subjects where the tipreds of the denoted index are less than 3).</p>
</td></tr>
<tr><td><code id="ctStanTIpredeffects_+3A_plot">plot</code></td>
<td>
<p>Logical. If TRUE, nothing is returned but instead <code><a href="#topic+ctPlotArray">ctPlotArray</a></code>
is used to plot the output instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a three dimensional array of predictor effects, or nothing with a plot
generated.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ctStanTIpredeffects(ctstantestfit,
 whichpars=c('CINT','dtDIFFUSION[2,2]'), plot=TRUE)
</code></pre>

<hr>
<h2 id='ctStanUpdModel'>Update an already compiled and fit ctStanFit object</h2><span id='topic+ctStanUpdModel'></span>

<h3>Description</h3>

<p>Allows one to change data and or model elements that don't require recompiling, then re fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctStanUpdModel(fit, datalong, ctstanmodel, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctStanUpdModel_+3A_fit">fit</code></td>
<td>
<p>ctStanFit object</p>
</td></tr>
<tr><td><code id="ctStanUpdModel_+3A_datalong">datalong</code></td>
<td>
<p>data as normally passed to <code><a href="#topic+ctStanFit">ctStanFit</a></code></p>
</td></tr>
<tr><td><code id="ctStanUpdModel_+3A_ctstanmodel">ctstanmodel</code></td>
<td>
<p>model as normally passed to <code><a href="#topic+ctStanFit">ctStanFit</a></code></p>
</td></tr>
<tr><td><code id="ctStanUpdModel_+3A_...">...</code></td>
<td>
<p>extra args for <code><a href="#topic+ctStanFit">ctStanFit</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='ctWideNames'>ctWideNames
sets default column names for wide ctsem datasets. Primarily intended for internal ctsem usage.</h2><span id='topic+ctWideNames'></span>

<h3>Description</h3>

<p>ctWideNames
sets default column names for wide ctsem datasets. Primarily intended for internal ctsem usage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctWideNames(
  n.manifest,
  Tpoints,
  n.TDpred = 0,
  n.TIpred = 0,
  manifestNames = "auto",
  TDpredNames = "auto",
  TIpredNames = "auto"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctWideNames_+3A_n.manifest">n.manifest</code></td>
<td>
<p>number of manifest variables per time point in the data.</p>
</td></tr>
<tr><td><code id="ctWideNames_+3A_tpoints">Tpoints</code></td>
<td>
<p>Maximum number of discrete time points (waves of data, or measurement occasions) 
for an individual in the input data structure.</p>
</td></tr>
<tr><td><code id="ctWideNames_+3A_n.tdpred">n.TDpred</code></td>
<td>
<p>number of time dependent predictors in the data structure.</p>
</td></tr>
<tr><td><code id="ctWideNames_+3A_n.tipred">n.TIpred</code></td>
<td>
<p>number of time independent predictors in the data structure.</p>
</td></tr>
<tr><td><code id="ctWideNames_+3A_manifestnames">manifestNames</code></td>
<td>
<p>vector of character strings giving column names of manifest indicator variables</p>
</td></tr>
<tr><td><code id="ctWideNames_+3A_tdprednames">TDpredNames</code></td>
<td>
<p>vector of character strings giving column names of time dependent predictor variables</p>
</td></tr>
<tr><td><code id="ctWideNames_+3A_tiprednames">TIpredNames</code></td>
<td>
<p>vector of character strings giving column names of time independent predictor variables</p>
</td></tr>
</table>

<hr>
<h2 id='ctWideToLong'>ctWideToLong
Convert ctsem wide to long format</h2><span id='topic+ctWideToLong'></span>

<h3>Description</h3>

<p>ctWideToLong
Convert ctsem wide to long format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctWideToLong(
  datawide,
  Tpoints,
  n.manifest,
  n.TDpred = 0,
  n.TIpred = 0,
  manifestNames = "auto",
  TDpredNames = "auto",
  TIpredNames = "auto"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctWideToLong_+3A_datawide">datawide</code></td>
<td>
<p>ctsem wide format data</p>
</td></tr>
<tr><td><code id="ctWideToLong_+3A_tpoints">Tpoints</code></td>
<td>
<p>number of measurement occasions in data</p>
</td></tr>
<tr><td><code id="ctWideToLong_+3A_n.manifest">n.manifest</code></td>
<td>
<p>number of manifest variables</p>
</td></tr>
<tr><td><code id="ctWideToLong_+3A_n.tdpred">n.TDpred</code></td>
<td>
<p>number of time dependent predictors</p>
</td></tr>
<tr><td><code id="ctWideToLong_+3A_n.tipred">n.TIpred</code></td>
<td>
<p>number of time independent predictors</p>
</td></tr>
<tr><td><code id="ctWideToLong_+3A_manifestnames">manifestNames</code></td>
<td>
<p>Character vector of manifest variable names.</p>
</td></tr>
<tr><td><code id="ctWideToLong_+3A_tdprednames">TDpredNames</code></td>
<td>
<p>Character vector of time dependent predictor names.</p>
</td></tr>
<tr><td><code id="ctWideToLong_+3A_tiprednames">TIpredNames</code></td>
<td>
<p>Character vector of time independent predictor names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Names must account for *all* the columns in the data - i.e. do not leave certain variables out
just because you do not need them.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#create wide data
wideexample &lt;- ctLongToWide(datalong = ctstantestdat, id = "id", 
time = "time", manifestNames = c("Y1", "Y2"), 
TDpredNames = "TD1", TIpredNames = c("TI1", "TI2","TI3"))

wide &lt;- ctIntervalise(datawide = wideexample, Tpoints = 10, n.manifest = 2, 
n.TDpred = 1, n.TIpred = 3, manifestNames = c("Y1", "Y2"), 
TDpredNames = "TD1", TIpredNames = c("TI1", "TI2","TI3") )

 #Then convert to long format
 longexample &lt;- ctWideToLong(datawide = wideexample, Tpoints=10, 
 n.manifest=2, manifestNames = c("Y1", "Y2"),
 n.TDpred=1, TDpredNames = "TD1", 
 n.TIpred=3, TIpredNames = c("TI1", "TI2","TI3"))

 #Then convert the time intervals to absolute time
 long &lt;- ctDeintervalise(datalong = longexample, id='id', dT='dT')
 head(long,22)


</code></pre>

<hr>
<h2 id='datastructure'>datastructure</h2><span id='topic+datastructure'></span>

<h3>Description</h3>

<p>Simulated example dataset for the ctsem package
</p>


<h3>Format</h3>

<p>2 by 15 matrix containing containing ctsem wide format data. 
3 measurement occasions of manifest variables Y1 and Y2, 
2 measurement occasions of time dependent predictor TD1, 
2 measurement intervals dTx, and 2 time independent predictors 
TI1 and TI2, for 2 individuals.
</p>

<hr>
<h2 id='inv_logit'>Inverse logit</h2><span id='topic+inv_logit'></span>

<h3>Description</h3>

<p>Maps the stan function so the same code works in R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inv_logit(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inv_logit_+3A_x">x</code></td>
<td>
<p>value to calculate the inverse logit for.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>inv_logit(-3)
</code></pre>

<hr>
<h2 id='isdiag'>Diagnostics for ctsem importance sampling</h2><span id='topic+isdiag'></span>

<h3>Description</h3>

<p>Diagnostics for ctsem importance sampling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isdiag(fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isdiag_+3A_fit">fit</code></td>
<td>
<p>Output from ctStanFit when optimize=TRUE and isloops &gt; 0</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing. Plots convergence of parameter mean estimates from initial Hessian based distribution to final sampling distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#get data
sunspots&lt;-sunspot.year
sunspots&lt;-sunspots[50: (length(sunspots) - (1988-1924))]
id &lt;- 1
time &lt;- 1749:1924
datalong &lt;- cbind(id, time, sunspots)

#setup model
model &lt;- ctModel(type='stanct', 
 manifestNames='sunspots', 
 latentNames=c('ss_level', 'ss_velocity'),
  LAMBDA=matrix(c( -1, 'ma1 | log(exp(-param)+1)' ), nrow=1, ncol=2),
  DRIFT=matrix(c(0, 'a21', 1, 'a22'), nrow=2, ncol=2),
  MANIFESTMEANS=matrix(c('m1 | (param)*5+44'), nrow=1, ncol=1),
  CINT=matrix(c(0, 0), nrow=2, ncol=1),
  T0VAR=matrix(c(1,0,0,1), nrow=2, ncol=2), #Because single subject
  DIFFUSION=matrix(c(0.0001, 0, 0, "diffusion"), ncol=2, nrow=2))

#fit and plot importance sampling diagnostic
fit &lt;- ctStanFit(datalong, model,verbose=0, 
  optimcontrol=list(is=TRUE, finishsamples=500),priors=TRUE)
isdiag(fit)

</code></pre>

<hr>
<h2 id='log1p_exp'>log1p_exp</h2><span id='topic+log1p_exp'></span>

<h3>Description</h3>

<p>Maps the stan function so the same code works in R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log1p_exp(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log1p_exp_+3A_x">x</code></td>
<td>
<p>value to use.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>log1p_exp(-3)
</code></pre>

<hr>
<h2 id='longexample'>longexample</h2><span id='topic+longexample'></span>

<h3>Description</h3>

<p>Simulated example dataset for the ctsem package
</p>


<h3>Format</h3>

<p>7 by 8 matrix containing ctsem long format data, for two subjects, 
with three manifest variables Y1, Y2, Y3, 
one time dependent predictor TD1, two time independent predictors TI1 and TI2, 
and absolute timing information Time.
</p>

<hr>
<h2 id='Oscillating'>Oscillating</h2><span id='topic+Oscillating'></span>

<h3>Description</h3>

<p>Simulated example dataset for the ctsem package.
</p>


<h3>Format</h3>

<p>200 by 21 matrix containing containing ctsem wide format data. 
11 measurement occasions and 10 measurement intervals for each of 200 individuals
</p>


<h3>Source</h3>

<p>See <a href="https://bpspsychub.onlinelibrary.wiley.com/doi/10.1111/j.2044-8317.2012.02043.x">https://bpspsychub.onlinelibrary.wiley.com/doi/10.1111/j.2044-8317.2012.02043.x</a>
</p>

<hr>
<h2 id='plot.ctKalmanDF'>Plots Kalman filter output from ctKalman.</h2><span id='topic+plot.ctKalmanDF'></span>

<h3>Description</h3>

<p>Plots Kalman filter output from ctKalman.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ctKalmanDF'
plot(
  x,
  subjects = unique(x$Subject),
  kalmanvec = c("y", "yprior"),
  errorvec = "auto",
  errormultiply = 1.96,
  plot = TRUE,
  elementNames = NA,
  polygonsteps = 10,
  polygonalpha = 0.1,
  facets = vars(Variable),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ctKalmanDF_+3A_x">x</code></td>
<td>
<p>Output from <code><a href="#topic+ctKalman">ctKalman</a></code>. In general it is easier to call 
<code><a href="#topic+ctKalman">ctKalman</a></code> directly with the <code>plot=TRUE</code> argument, which calls this function.</p>
</td></tr>
<tr><td><code id="plot.ctKalmanDF_+3A_subjects">subjects</code></td>
<td>
<p>vector of integers denoting which subjects (from 1 to N) to plot predictions for.</p>
</td></tr>
<tr><td><code id="plot.ctKalmanDF_+3A_kalmanvec">kalmanvec</code></td>
<td>
<p>string vector of names of any elements of the output you wish to plot, 
the defaults of 'y' and 'ysmooth' plot the original data, 'y', 
and the estimates of the 'true' value of y given all data. Replacing 'y' by 'eta' will 
plot latent states instead (though 'eta' alone does not exist) and replacing 'smooth' 
with 'upd' or 'prior' respectively plots updated (conditional on all data up to current time point)
or prior (conditional on all previous data) estimates.</p>
</td></tr>
<tr><td><code id="plot.ctKalmanDF_+3A_errorvec">errorvec</code></td>
<td>
<p>vector of names indicating which kalmanvec elements to plot uncertainty bands for. 
'auto' plots all possible.</p>
</td></tr>
<tr><td><code id="plot.ctKalmanDF_+3A_errormultiply">errormultiply</code></td>
<td>
<p>Numeric denoting the multiplication factor of the std deviation of errorvec objects. 
Defaults to 1.96, for 95% intervals.</p>
</td></tr>
<tr><td><code id="plot.ctKalmanDF_+3A_plot">plot</code></td>
<td>
<p>if FALSE, plots are not generated and the ggplot object is simply returned invisibly.</p>
</td></tr>
<tr><td><code id="plot.ctKalmanDF_+3A_elementnames">elementNames</code></td>
<td>
<p>if NA, all relevant object elements are included &ndash; e.g. if yprior is in the kalmanvec
argument, all manifest variables are plotted, and likewise for latent states if etasmooth was specified.
Alternatively, a character vector specifying the manifest and latent names to plot explicitly can be specified.</p>
</td></tr>
<tr><td><code id="plot.ctKalmanDF_+3A_polygonsteps">polygonsteps</code></td>
<td>
<p>Number of steps to use for uncertainty band shading.</p>
</td></tr>
<tr><td><code id="plot.ctKalmanDF_+3A_polygonalpha">polygonalpha</code></td>
<td>
<p>Numeric for the opacity of the uncertainty region.</p>
</td></tr>
<tr><td><code id="plot.ctKalmanDF_+3A_facets">facets</code></td>
<td>
<p>when multiple subjects are included in multivariate plots, the default is to facet plots 
by variable type. This can be set to NA for no facets, or <code>ggplot2::vars(Subject)</code> for facetting by subject.</p>
</td></tr>
<tr><td><code id="plot.ctKalmanDF_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object. Side effect &ndash; Generates plots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Get output from ctKalman
x&lt;-ctKalman(ctstantestfit,subjects=2,timestep=.01)

### Plot with plot.ctKalmanDF
plot(x, subjects=2)

###Single step procedure:
ctKalman(ctstantestfit,subjects=2,
  kalmanvec=c('y','yprior'),
  elementNames=c('Y1','Y2'), 
  plot=TRUE,timestep=.01)
</code></pre>

<hr>
<h2 id='plot.ctStanFit'>plot.ctStanFit</h2><span id='topic+plot.ctStanFit'></span><span id='topic+ctStanPlot'></span>

<h3>Description</h3>

<p>Plots for ctStanFit objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ctStanFit'
plot(x, types = "all", wait = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ctStanFit_+3A_x">x</code></td>
<td>
<p>Fit object from <code><a href="#topic+ctStanFit">ctStanFit</a></code>.</p>
</td></tr>
<tr><td><code id="plot.ctStanFit_+3A_types">types</code></td>
<td>
<p>Vector of character strings defining which plots to create.
'all' plots all possible types, including: 'regression', 'kalman', 
'priorcheck', 'trace', 'density','intervals'.</p>
</td></tr>
<tr><td><code id="plot.ctStanFit_+3A_wait">wait</code></td>
<td>
<p>Logical. Pause between plots?</p>
</td></tr>
<tr><td><code id="plot.ctStanFit_+3A_...">...</code></td>
<td>
<p>Arguments to pass through to the specific plot functions. Bewar of clashes
may occur if types='all'. For details see the specific functions generating each type of plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is just a wrapper calling the necessary functions for plotting - it 
may be simpler in many cases to access those directly. They are:
<code><a href="#topic+ctStanDiscretePars">ctStanDiscretePars</a></code>,<code><a href="#topic+ctKalman">ctKalman</a></code>,
<code><a href="#topic+ctStanPlotPost">ctStanPlotPost</a></code>,<code>stan_trace</code>,
<code>stan_dens</code>,<code>stan_plot</code>
rstan offers many plotting possibilities not available here, to use that functionality
one must simply call the relevant rstan plotting function. Use <code>x$stanfit</code> as the stan fit object
(where x is the name of your ctStanFit object). Because a ctStanFit object has many 
parameters, the additional argument <code>pars=ctStanParnames(x,'pop_')</code> is recommended.
This denotes population means, but see <code><a href="#topic+ctStanParnames">ctStanParnames</a></code> for
other options.
</p>


<h3>Value</h3>

<p>Nothing. Generates plots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot(ctstantestfit,types=c('regression','kalman','priorcheck'), wait=FALSE)

</code></pre>

<hr>
<h2 id='plot.ctStanModel'>Prior plotting</h2><span id='topic+plot.ctStanModel'></span>

<h3>Description</h3>

<p>Plots priors for free model parameters in a ctStanModel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ctStanModel'
plot(
  x,
  rows = "all",
  wait = FALSE,
  nsamples = 1e+06,
  rawpopsd = "marginalise",
  inddifdevs = c(-1, 1),
  inddifsd = 0.1,
  plot = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ctStanModel_+3A_x">x</code></td>
<td>
<p>ctStanModel object as generated by <code><a href="#topic+ctModel">ctModel</a></code> with type='stanct' or 'standt'.</p>
</td></tr>
<tr><td><code id="plot.ctStanModel_+3A_rows">rows</code></td>
<td>
<p>vector of integers denoting which rows of ctstanmodel$pars to plot priors for. 
Character string 'all' plots all rows with parameters to be estimated.</p>
</td></tr>
<tr><td><code id="plot.ctStanModel_+3A_wait">wait</code></td>
<td>
<p>If true, user is prompted to continue before plotting next graph.</p>
</td></tr>
<tr><td><code id="plot.ctStanModel_+3A_nsamples">nsamples</code></td>
<td>
<p>Numeric. Higher values increase fidelity (smoothness / accuracy) of density plots, at cost of speed.</p>
</td></tr>
<tr><td><code id="plot.ctStanModel_+3A_rawpopsd">rawpopsd</code></td>
<td>
<p>Either 'marginalise' to sample from the specified (in the ctstanmodel) 
prior distribution for the raw population standard deviation, or a numeric value to use for the raw population standard deviation
for all subject level prior plots - the plots in dotted blue or red.</p>
</td></tr>
<tr><td><code id="plot.ctStanModel_+3A_inddifdevs">inddifdevs</code></td>
<td>
<p>numeric vector of length 2, setting the means for the individual differences distributions.</p>
</td></tr>
<tr><td><code id="plot.ctStanModel_+3A_inddifsd">inddifsd</code></td>
<td>
<p>numeric, setting the standard deviation of the population means used to generate individual
difference distributions.</p>
</td></tr>
<tr><td><code id="plot.ctStanModel_+3A_plot">plot</code></td>
<td>
<p>If FALSE, ouputs list of GGplot objects that can be further modified.</p>
</td></tr>
<tr><td><code id="plot.ctStanModel_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plotted in black is the prior for the population mean. In red and blue are the subject level priors that result
given that the population mean is estimated as 1 std deviation above the mean of the prior, or 1 std deviation below. 
The distributions around these two points are then obtained by marginalising over the prior for the raw population std deviation - 
so the red and blue distributions do not represent any specific subject level prior, but rather characterise the general amount
and shape of possible subject level priors at the specific points of the population mean prior.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- ctModel(type='stanct',
manifestNames='sunspots', 
latentNames=c('ss_level', 'ss_velocity'),
LAMBDA=matrix(c( 1, 'ma1' ), nrow=1, ncol=2),
DRIFT=matrix(c(0, 1,   'a21', 'a22'), nrow=2, ncol=2, byrow=TRUE),
MANIFESTMEANS=matrix(c('m1'), nrow=1, ncol=1),
# MANIFESTVAR=matrix(0, nrow=1, ncol=1),
CINT=matrix(c(0, 0), nrow=2, ncol=1),
DIFFUSION=matrix(c(
  0, 0,
  0, "diffusion"), ncol=2, nrow=2, byrow=TRUE))
  
plot(model,rows=8)
</code></pre>

<hr>
<h2 id='sdpcor2cov'>sdcor2cov</h2><span id='topic+sdpcor2cov'></span>

<h3>Description</h3>

<p>Converts a lower triangular matrix with standard deviations on the diagonal and partial correlations on
lower triangle, to a covariance (or cholesky decomposed covariance)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdpcor2cov(mat, coronly = FALSE, cholesky = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sdpcor2cov_+3A_mat">mat</code></td>
<td>
<p>input square matrix with std dev on diagonal and lower tri of partial correlations.</p>
</td></tr>
<tr><td><code id="sdpcor2cov_+3A_coronly">coronly</code></td>
<td>
<p>if TRUE, ignores everything except the lower triangle and outputs correlation.</p>
</td></tr>
<tr><td><code id="sdpcor2cov_+3A_cholesky">cholesky</code></td>
<td>
<p>Logical. To return the cholesky decomposition instead of full covariance, set to TRUE.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>testmat &lt;- diag(exp(rnorm(5,-3,2)),5) #generate arbitrary std deviations
testmat[row(testmat) &gt; col(testmat)] &lt;- runif((5^2-5)/2, -1, 1) 
print(testmat)
covmat &lt;- sdpcor2cov(testmat) #convert to covariance
cov2cor(covmat) #convert covariance to correlation
</code></pre>

<hr>
<h2 id='stan_checkdivergences'>Analyse divergences in a stanfit object</h2><span id='topic+stan_checkdivergences'></span>

<h3>Description</h3>

<p>Analyse divergences in a stanfit object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan_checkdivergences(sf, nupars = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stan_checkdivergences_+3A_sf">sf</code></td>
<td>
<p>stanfit object.</p>
</td></tr>
<tr><td><code id="stan_checkdivergences_+3A_nupars">nupars</code></td>
<td>
<p>either the string 'all', or an integer reflecting how many pars 
(from first to nupars) to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of four matrices. $locationsort and $sdsort contian the bivariate interactions of 
unconstrained parameters, sorted by either the relative location of any divergences, or the relative standard deviation.
$locationmeans and $sdmeans collapse across the bivariate interactions to return the means for each parameter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sunspots&lt;-sunspot.year
sunspots&lt;-sunspots[50: (length(sunspots) - (1988-1924))]
id &lt;- 1
time &lt;- 1749:1924
datalong &lt;- cbind(id, time, sunspots)

#setup model
ssmodel &lt;- ctModel(type='stanct', n.latent=2, n.manifest=1, 
 manifestNames='sunspots', 
 latentNames=c('ss_level', 'ss_velocity'),
 LAMBDA=matrix(c( 1, 'ma1| log(1+(exp(param)))' ), nrow=1, ncol=2),
 DRIFT=matrix(c(0, 'a21 | -log(1+exp(param))', 1, 'a22'), nrow=2, ncol=2),
 MANIFESTMEANS=matrix(c('m1|param * 10 + 44'), nrow=1, ncol=1),
 MANIFESTVAR=diag(0,1), #As per original spec
 CINT=matrix(c(0, 0), nrow=2, ncol=1),
 DIFFUSION=matrix(c(0, 0, 0, "diffusion"), ncol=2, nrow=2))

#fit
ssfit &lt;- ctStanFit(datalong, ssmodel, iter=2, 
  optimize=FALSE, chains=1)
  
stan_checkdivergences(ssfit$stanfit$stanfit) #stan object

</code></pre>

<hr>
<h2 id='stan_reinitsf'>Quickly initialise stanfit object from model and data</h2><span id='topic+stan_reinitsf'></span>

<h3>Description</h3>

<p>Quickly initialise stanfit object from model and data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan_reinitsf(model, data, fast = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stan_reinitsf_+3A_model">model</code></td>
<td>
<p>stanmodel</p>
</td></tr>
<tr><td><code id="stan_reinitsf_+3A_data">data</code></td>
<td>
<p>standata</p>
</td></tr>
<tr><td><code id="stan_reinitsf_+3A_fast">fast</code></td>
<td>
<p>Use cut down form for speed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>stanfit object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sf &lt;- stan_reinitsf(ctstantestfit$stanmodel,ctstantestfit$standata)
</code></pre>

<hr>
<h2 id='stan_unconstrainsamples'>Convert samples from a stanfit object to the unconstrained scale</h2><span id='topic+stan_unconstrainsamples'></span>

<h3>Description</h3>

<p>Convert samples from a stanfit object to the unconstrained scale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan_unconstrainsamples(fit, standata = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stan_unconstrainsamples_+3A_fit">fit</code></td>
<td>
<p>stanfit object.</p>
</td></tr>
<tr><td><code id="stan_unconstrainsamples_+3A_standata">standata</code></td>
<td>
<p>only necessary if R session has been restarted since fitting model &ndash; used to reinitialize 
stanfit object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix containing columns of unconstrained parameters for each post-warmup iteration.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#get data
sunspots&lt;-sunspot.year
sunspots&lt;-sunspots[50: (length(sunspots) - (1988-1924))]
id &lt;- 1
time &lt;- 1749:1924
datalong &lt;- cbind(id, time, sunspots)

#setup model
ssmodel &lt;- ctModel(type='stanct', n.latent=2, n.manifest=1, 
  manifestNames='sunspots', 
  latentNames=c('ss_level', 'ss_velocity'),
  LAMBDA=matrix(c( 1, 'ma1| log(1+(exp(param)))' ), nrow=1, ncol=2),
  DRIFT=matrix(c(0, 'a21 | -log(1+exp(param))', 1, 'a22'), nrow=2, ncol=2),
  MANIFESTMEANS=matrix(c('m1|param * 10 + 44'), nrow=1, ncol=1),
  MANIFESTVAR=diag(0,1), #As per original spec
  CINT=matrix(c(0, 0), nrow=2, ncol=1),
  DIFFUSION=matrix(c(0, 0, 0, "diffusion"), ncol=2, nrow=2))

#fit
ssfit &lt;- ctStanFit(datalong, ssmodel, 
  iter=200, chains=2,optimize=FALSE, priors=TRUE,control=list(max_treedepth=4))
umat &lt;- stan_unconstrainsamples(ssfit$stanfit$stanfit)

</code></pre>

<hr>
<h2 id='standatact_specificsubjects'>Adjust standata from ctsem to only use specific subjects</h2><span id='topic+standatact_specificsubjects'></span>

<h3>Description</h3>

<p>Adjust standata from ctsem to only use specific subjects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standatact_specificsubjects(standata, subjects, timestep = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standatact_specificsubjects_+3A_standata">standata</code></td>
<td>
<p>standata</p>
</td></tr>
<tr><td><code id="standatact_specificsubjects_+3A_subjects">subjects</code></td>
<td>
<p>vector of subjects</p>
</td></tr>
<tr><td><code id="standatact_specificsubjects_+3A_timestep">timestep</code></td>
<td>
<p>ignored at present</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of updated structure
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- standatact_specificsubjects(ctstantestfit$standata, 1:2)
</code></pre>

<hr>
<h2 id='stanoptimis'>Optimize / importance sample a stan or ctStan model.</h2><span id='topic+stanoptimis'></span>

<h3>Description</h3>

<p>Optimize / importance sample a stan or ctStan model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stanoptimis(
  standata,
  sm,
  init = "random",
  initsd = 0.01,
  sampleinit = NA,
  deoptim = FALSE,
  estonly = FALSE,
  tol = 1e-08,
  decontrol = list(),
  stochastic = TRUE,
  priors = TRUE,
  carefulfit = TRUE,
  bootstrapUncertainty = FALSE,
  subsamplesize = 1,
  parsteps = c(),
  plot = FALSE,
  hessianType = "numerical",
  stochasticHessianSamples = 50,
  stochasticHessianEpsilon = 1e-05,
  is = FALSE,
  isloopsize = 1000,
  finishsamples = 1000,
  tdf = 10,
  chancethreshold = 100,
  finishmultiply = 5,
  verbose = 0,
  cores = 2,
  matsetup = NA,
  nsubsets = 100,
  stochasticTolAdjust = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stanoptimis_+3A_standata">standata</code></td>
<td>
<p>list object conforming to rstan data standards.</p>
</td></tr>
<tr><td><code id="stanoptimis_+3A_sm">sm</code></td>
<td>
<p>compiled stan model object.</p>
</td></tr>
<tr><td><code id="stanoptimis_+3A_init">init</code></td>
<td>
<p>vector of unconstrained parameter values, or character string 'random' to initialise with
random values very close to zero.</p>
</td></tr>
<tr><td><code id="stanoptimis_+3A_initsd">initsd</code></td>
<td>
<p>positive numeric specifying sd of normal distribution governing random sample of init parameters,
if init='random' .</p>
</td></tr>
<tr><td><code id="stanoptimis_+3A_sampleinit">sampleinit</code></td>
<td>
<p>either NA, or an niterations * nparams matrix of samples to initialise importance sampling.</p>
</td></tr>
<tr><td><code id="stanoptimis_+3A_deoptim">deoptim</code></td>
<td>
<p>Do first pass optimization using differential evolution? Slower, but better for cases with multiple
minima / difficult optimization.</p>
</td></tr>
<tr><td><code id="stanoptimis_+3A_estonly">estonly</code></td>
<td>
<p>if TRUE,just return point estimates under $rawest subobject.</p>
</td></tr>
<tr><td><code id="stanoptimis_+3A_tol">tol</code></td>
<td>
<p>objective tolerance.</p>
</td></tr>
<tr><td><code id="stanoptimis_+3A_decontrol">decontrol</code></td>
<td>
<p>List of control parameters for differential evolution step, to pass to <code>DEoptim.control</code>.</p>
</td></tr>
<tr><td><code id="stanoptimis_+3A_stochastic">stochastic</code></td>
<td>
<p>Logical. Use stochastic gradient descent instead of mize (bfgs) optimizer.
Still experimental, worth trying for either robustness checks or problematic, high dimensional, nonlinear, problems.</p>
</td></tr>
<tr><td><code id="stanoptimis_+3A_priors">priors</code></td>
<td>
<p>logical. If TRUE, a priors integer is set to 1 (TRUE) in the standata object &ndash; only has an effect if 
the stan model uses this value.</p>
</td></tr>
<tr><td><code id="stanoptimis_+3A_carefulfit">carefulfit</code></td>
<td>
<p>Logical. If TRUE, priors are always used for a rough first pass to obtain starting values when priors=FALSE</p>
</td></tr>
<tr><td><code id="stanoptimis_+3A_bootstrapuncertainty">bootstrapUncertainty</code></td>
<td>
<p>Logical. If TRUE, subject wise gradient contributions are resampled to estimate the hessian, 
for computing standard errors or initializing importance sampling.</p>
</td></tr>
<tr><td><code id="stanoptimis_+3A_subsamplesize">subsamplesize</code></td>
<td>
<p>value between 0 and 1 representing proportion of subjects to include in first pass fit.</p>
</td></tr>
<tr><td><code id="stanoptimis_+3A_parsteps">parsteps</code></td>
<td>
<p>ordered list of vectors of integers denoting which parameters should begin fixed
at zero, and freed sequentially (by list order). Useful for complex models, e.g. keep all cross couplings fixed to zero 
as a first step, free them in second step.</p>
</td></tr>
<tr><td><code id="stanoptimis_+3A_plot">plot</code></td>
<td>
<p>Logical. If TRUE, plot iteration details. Probably slower.</p>
</td></tr>
<tr><td><code id="stanoptimis_+3A_hessiantype">hessianType</code></td>
<td>
<p>either 'numerical' or 'stochastic', the latter is experimental at present.</p>
</td></tr>
<tr><td><code id="stanoptimis_+3A_stochastichessiansamples">stochasticHessianSamples</code></td>
<td>
<p>number of samples to use for stochastic Hessian, if selected.</p>
</td></tr>
<tr><td><code id="stanoptimis_+3A_stochastichessianepsilon">stochasticHessianEpsilon</code></td>
<td>
<p>SD of random samples for stochastic hessian, if selected.</p>
</td></tr>
<tr><td><code id="stanoptimis_+3A_is">is</code></td>
<td>
<p>Logical. Use importance sampling, or just return map estimates?</p>
</td></tr>
<tr><td><code id="stanoptimis_+3A_isloopsize">isloopsize</code></td>
<td>
<p>Number of samples of approximating distribution per iteration of importance sampling.</p>
</td></tr>
<tr><td><code id="stanoptimis_+3A_finishsamples">finishsamples</code></td>
<td>
<p>Number of samples to draw (either from hessian
based covariance or posterior distribution) for final results computation.</p>
</td></tr>
<tr><td><code id="stanoptimis_+3A_tdf">tdf</code></td>
<td>
<p>degrees of freedom of multivariate t distribution. Higher (more normal) generally gives more efficent
importance sampling, at risk of truncating tails.</p>
</td></tr>
<tr><td><code id="stanoptimis_+3A_chancethreshold">chancethreshold</code></td>
<td>
<p>drop iterations of importance sampling where any samples are chancethreshold times more likely to be drawn than expected.</p>
</td></tr>
<tr><td><code id="stanoptimis_+3A_finishmultiply">finishmultiply</code></td>
<td>
<p>Importance sampling stops once available samples reach <code>finishsamples * finishmultiply</code> , then the final samples are drawn
without replacement from this set.</p>
</td></tr>
<tr><td><code id="stanoptimis_+3A_verbose">verbose</code></td>
<td>
<p>Integer from 0 to 2. Higher values print more information during model fit &ndash; for debugging.</p>
</td></tr>
<tr><td><code id="stanoptimis_+3A_cores">cores</code></td>
<td>
<p>Number of cpu cores to use, should be at least 2.</p>
</td></tr>
<tr><td><code id="stanoptimis_+3A_matsetup">matsetup</code></td>
<td>
<p>subobject of ctStanFit output. If provided, parameter names instead of numbers are output for any problem indications.</p>
</td></tr>
<tr><td><code id="stanoptimis_+3A_nsubsets">nsubsets</code></td>
<td>
<p>number of subsets for stochastic optimizer. Subsets are further split across cores, 
but each subjects data remains whole &ndash; processed by one core in one subset.</p>
</td></tr>
<tr><td><code id="stanoptimis_+3A_stochastictoladjust">stochasticTolAdjust</code></td>
<td>
<p>Multiplier for stochastic optimizer tolerance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing fit elementsF
</p>

<hr>
<h2 id='stanWplot'>Runs stan, and plots sampling information while sampling.</h2><span id='topic+stanWplot'></span>

<h3>Description</h3>

<p>Runs stan, and plots sampling information while sampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stanWplot(object, iter = 2000, chains = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stanWplot_+3A_object">object</code></td>
<td>
<p>stan model object</p>
</td></tr>
<tr><td><code id="stanWplot_+3A_iter">iter</code></td>
<td>
<p>Number of iterations</p>
</td></tr>
<tr><td><code id="stanWplot_+3A_chains">chains</code></td>
<td>
<p>Number of chains</p>
</td></tr>
<tr><td><code id="stanWplot_+3A_...">...</code></td>
<td>
<p>All the other regular arguments to stan()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>On windows, requires Rtools installed and able to be found by pkgbuild::rtools_path()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rstan)
#### example 1 
scode &lt;- "
parameters {
  real y[2]; 
} 
model {
  y[1] ~ normal(0, .5);
  y[2] ~ double_exponential(0, 2);
} 
"
#Uncomment the following lines -- launches rscript not compatible with cran check.
#sm &lt;- stan_model(model_code = scode)
#fit1 &lt;- stanWplot(object = sm,iter = 100000,chains=2,cores=1)
</code></pre>

<hr>
<h2 id='summary.ctStanFit'>summary.ctStanFit</h2><span id='topic+summary.ctStanFit'></span>

<h3>Description</h3>

<p>Summarise a ctStanFit object that was fit using <code><a href="#topic+ctStanFit">ctStanFit</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ctStanFit'
summary(
  object,
  timeinterval = 1,
  digits = 4,
  parmatrices = TRUE,
  priorcheck = TRUE,
  residualcov = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.ctStanFit_+3A_object">object</code></td>
<td>
<p>fit object from <code><a href="#topic+ctStanFit">ctStanFit</a></code>, of class ctStanFit.</p>
</td></tr>
<tr><td><code id="summary.ctStanFit_+3A_timeinterval">timeinterval</code></td>
<td>
<p>positive numeric indicating time interval to use for discrete time parameter calculations
reported in summary.</p>
</td></tr>
<tr><td><code id="summary.ctStanFit_+3A_digits">digits</code></td>
<td>
<p>integer denoting number of digits to report.</p>
</td></tr>
<tr><td><code id="summary.ctStanFit_+3A_parmatrices">parmatrices</code></td>
<td>
<p>if TRUE, also return additional parameter matrices &ndash; can be slow to compute
for large models with many samples.</p>
</td></tr>
<tr><td><code id="summary.ctStanFit_+3A_priorcheck">priorcheck</code></td>
<td>
<p>Whether or not to use <code>ctsem:::priorchecking</code> to compare posterior mean and sd to prior mean and sd.</p>
</td></tr>
<tr><td><code id="summary.ctStanFit_+3A_residualcov">residualcov</code></td>
<td>
<p>Whether or not to show standardised residual covariance. Takes a little longer to compute.</p>
</td></tr>
<tr><td><code id="summary.ctStanFit_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code>ctsem:::priorcheckreport</code>, such as <code>meanlim</code>, or <code>sdlim</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing summary items.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(ctstantestfit)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
