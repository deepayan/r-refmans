<!DOCTYPE html><html lang="en"><head><title>Help for package tfCox</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tfCox}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#tfCox-package'>
<p>Fit the Additive Trend Filtering Cox Model</p></a></li>
<li><a href='#cv_tfCox'><p>Fit Trend Filtering Cox model and Choose Tuning Parameter via K-Fold Cross-Validation</p></a></li>
<li><a href='#negloglik'>
<p>Calculate the negative log likelihood from Cox model.</p></a></li>
<li><a href='#plot.cv_tfCox'>
<p>Plots Cross-Validation Curve for Object of Class &quot;cv_tfCox&quot;</p></a></li>
<li><a href='#plot.sim_dat'>
<p>Plot the true covariate effects</p></a></li>
<li><a href='#plot.tfCox'>
<p>Plot Fitted Functions from Class &quot;tfCox&quot;</p></a></li>
<li><a href='#predict_best_lambda'>
<p>Predict from the optimal lambda from tfCox_choose_lambda</p></a></li>
<li><a href='#predict.tfCox'><p>Predict for a New Covariate Matrix and fit from <code>tfCox</code></p></a></li>
<li><a href='#sim_dat'>
<p>Simulate Data from a Variety of Functional Scenarios</p></a></li>
<li><a href='#summary.cv_tfCox'>
<p>Summarize <code>cv_tfCox</code> object</p></a></li>
<li><a href='#summary.tfCox'>
<p>Summarize <code>tfCox</code> object</p></a></li>
<li><a href='#tfCox'><p>Fit the additive trend filtering Cox model with a range of tuning parameters</p></a></li>
<li><a href='#tfCox_choose_lambda'>
<p>Choose the tuning parameter lambda using training and testing dataset</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fits Piecewise Polynomial with Data-Adaptive Knots in Cox Model</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-07-29</td>
</tr>
<tr>
<td>Description:</td>
<td>In Cox's proportional hazard model, covariates are modeled as linear function and may not be flexible. This package implements additive trend filtering Cox proportional hazards model as proposed in Jiacheng Wu &amp; Daniela Witten (2019) "Flexible and Interpretable Models for Survival Data", Journal of Computational and Graphical Statistics, &lt;<a href="https://doi.org/10.1080%2F10618600.2019.1592758">doi:10.1080/10618600.2019.1592758</a>&gt;. The fitted functions are piecewise polynomial with adaptively chosen knots.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.14), survival, stats</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Author:</td>
<td>Jiacheng Wu [aut, cre],
  Daniela Witten [aut],
  Taylor Arnold [ctb],
  Veeranjaneyulu Sadhanala [ctb],
  Ryan Tibshirani [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jiacheng Wu &lt;wujiacheng1992@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-07-30 04:37:35 UTC; wujiacheng</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-08-01 11:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='tfCox-package'>
Fit the Additive Trend Filtering Cox Model
</h2><span id='topic+tfCox-package'></span>

<h3>Description</h3>

<p>This package is called tfCox or trend filtering for Cox model, which is proposed in Jiacheng Wu &amp; Daniela Witten (2019) Flexible and Interpretable Models for Survival Data, Journal of Computational and Graphical Statistics, DOI: 10.1080/10618600.2019.1592758. It provides an approach to fit additive Cox model in which each component function is estimated to be piecewise polynomial with adaptively-chosen knots.
</p>
<p>Function <code><a href="#topic+tfCox">tfCox</a></code> fits the trend filtering Cox model for a range of tuning parameters. Function <code><a href="#topic+cv_tfCox">cv_tfCox</a></code> returns the optimal tuning parameter selected by K-fold cross validation.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> tfCox</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.1.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2019-05-20</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The package includes the following functions:
<code><a href="#topic+tfCox">tfCox</a></code>, <code><a href="#topic+cv_tfCox">cv_tfCox</a></code>, <code><a href="#topic+plot.tfCox">plot.tfCox</a></code>, <code><a href="#topic+plot.cv_tfCox">plot.cv_tfCox</a></code>, <code><a href="#topic+predict.tfCox">predict.tfCox</a></code>, <code><a href="#topic+summary.tfCox">summary.tfCox</a></code>, <code><a href="#topic+summary.cv_tfCox">summary.cv_tfCox</a></code>, <code><a href="#topic+sim_dat">sim_dat</a></code>, <code><a href="#topic+plot.sim_dat">plot.sim_dat</a></code>.
</p>


<h3>Author(s)</h3>

<p>Jiacheng Wu
Maintainer: Jiacheng Wu &lt;wujiacheng1992@gmail.com&gt;
</p>


<h3>References</h3>

<p>Jiacheng Wu &amp; Daniela Witten (2019) Flexible and Interpretable Models for Survival Data, Journal of Computational and Graphical Statistics, DOI: 10.1080/10618600.2019.1592758
</p>

<hr>
<h2 id='cv_tfCox'>Fit Trend Filtering Cox model and Choose Tuning Parameter via K-Fold Cross-Validation</h2><span id='topic+cv_tfCox'></span>

<h3>Description</h3>

<p>Fit additive trend filtering Cox model where each component function is estimated to be piecewise constant or polynomial. Tuning parameter is selected via k-fold cross-validation. </p>


<h3>Usage</h3>

<pre><code class='language-R'>cv_tfCox(dat, ord=0, alpha=1, discrete=NULL, lambda.seq=NULL,
lambda.min.ratio=0.01, n.lambda=30, n.fold=5, seed=NULL, tol=1e-6,
niter=1000, stepSize=25,  backtracking=0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cv_tfCox_+3A_dat">dat</code></td>
<td>

<p>A list that contains <code>time</code>, <code>status</code> and <code>X</code>. <code>time</code> is failure or censoring time, <code>status</code> is censoring indicator, and  <code>X</code> is n x p matrix and may have p &gt; n.
</p>
</td></tr>
<tr><td><code id="cv_tfCox_+3A_ord">ord</code></td>
<td>

<p>The polynomial order of the trend filtering fit; a non-negative interger (<code>ord&gt;= 3</code> is not recommended). For instance, <code>ord=0</code> will produce piewise constant fit, <code>ord=1</code> will produce piewise linear fit, and <code>ord=2</code> will produce piewise quadratic fit.
</p>
</td></tr>
<tr><td><code id="cv_tfCox_+3A_alpha">alpha</code></td>
<td>

<p>The trade-off between trend filtering penalty and group lasso penalty. It must be in [0,1]. <code>alpha=1</code> corresponds to the case with only trend filtering penalty to produce piecewise polynomial, and <code>alpha=0</code> corresponds to the case with only group lasso penalty to produce sparsity of the functions. <code>alpha</code> between 0 and 1 is the tradeoff between the strength of these two penalties. For p &lt; n, we suggest using 1.
</p>
</td></tr>
<tr><td><code id="cv_tfCox_+3A_discrete">discrete</code></td>
<td>

<p>A vector of covariate/feature indice that are discrete. Discrete covariates are not penalized in the model. Default <code>NULL</code> means that none of the covariates are discrete thus all covariates will be penalized in the model.
</p>
</td></tr>
<tr><td><code id="cv_tfCox_+3A_lambda.seq">lambda.seq</code></td>
<td>

<p>The sequence of positive lambda values to consider. The default is <code>NULL</code>, which calculates <code>lambda.seq</code> using <code>lambda.min.ratio</code> and <code>n.lambda</code>. If <code>lambda.seq</code> is provided, it will override the default.  <code>lambda.seq</code> should be a decreasing positive sequence of values since <code>cv_tfCox</code> replies on warm starts to speed up the computation.
</p>
</td></tr>
<tr><td><code id="cv_tfCox_+3A_lambda.min.ratio">lambda.min.ratio</code></td>
<td>

<p>Smallest value for lambda.seq, as a fraction of the maximum lambda value, which is the smallest value such that the penalty term is zero. The default is 0.01.
</p>
</td></tr>
<tr><td><code id="cv_tfCox_+3A_n.lambda">n.lambda</code></td>
<td>

<p>The number of lambda values to consider. Default is 30.
</p>
</td></tr>
<tr><td><code id="cv_tfCox_+3A_n.fold">n.fold</code></td>
<td>

<p>The number of folds for cross-validation of <code>lambda</code>. The default is 5.
</p>
</td></tr>
<tr><td><code id="cv_tfCox_+3A_seed">seed</code></td>
<td>

<p>An optional number used with <code>set.seed()</code>.
</p>
</td></tr>
<tr><td><code id="cv_tfCox_+3A_tol">tol</code></td>
<td>

<p>Convergence criterion for estimates.
</p>
</td></tr>
<tr><td><code id="cv_tfCox_+3A_niter">niter</code></td>
<td>

<p>Maximum number of iterations.
</p>
</td></tr>
<tr><td><code id="cv_tfCox_+3A_stepsize">stepSize</code></td>
<td>

<p>Iniitial step size. Default is 25.
</p>
</td></tr>
<tr><td><code id="cv_tfCox_+3A_backtracking">backtracking</code></td>
<td>

<p>Whether backtracking should be used 1 (TRUE) or 0 (FALSE). Default is 0 (FALSE). 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code>cv_tfCox</code> does not cross-validate over <code>alpha</code>, and <code>alpha</code> should be provided. However, if the user would like to cross-validate over <code>alpha</code>, then <code>cv_tfCox</code> should be called multiple times for different values of <code>alpha</code> and the same <code>seed</code>. This ensures that the cross-validation folds (<code>fold</code>) remain the same for the different values of <code>alpha</code>. See the example below for details.
</p>


<h3>Value</h3>

<p>An object with S3 class &quot;cv_tfCox&quot;.
</p>
<table role = "presentation">
<tr><td><code>best.lambda</code></td>
<td>

<p>Optional lambda value chosen by cross-dalidation.
</p>
</td></tr>
<tr><td><code>lambda.seq</code></td>
<td>

<p>lambda sequence considered.
</p>
</td></tr>
<tr><td><code>mean.cv.error</code></td>
<td>

<p>vector of average cross validation error with the same length as <code>lambda.seq</code>
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jiacheng Wu
</p>


<h3>References</h3>

<p>Jiacheng Wu &amp; Daniela Witten (2019) Flexible and Interpretable Models for Survival Data, Journal of Computational and Graphical Statistics, DOI: 10.1080/10618600.2019.1592758
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.cv_tfCox">summary.cv_tfCox</a></code>, <code><a href="#topic+plot.cv_tfCox">plot.cv_tfCox</a></code>, <code><a href="#topic+tfCox">tfCox</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#generate data
set.seed(123)
dat = sim_dat(n=100, zerof=0, scenario=1)

#fit piecewise constant functions
#cross-validation to choose the tuning parameter lambda with fixed alpha=1
cv = cv_tfCox(dat, ord=0, alpha=1, n.fold=2, seed=123)
plot(cv, showSE=TRUE)
</code></pre>

<hr>
<h2 id='negloglik'>
Calculate the negative log likelihood from Cox model. 
</h2><span id='topic+negloglik'></span>

<h3>Description</h3>

<p>Calculate the negative log likelihood from Cox model from the estimated coefficient matrix theta.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>negloglik(dat, theta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="negloglik_+3A_dat">dat</code></td>
<td>

<p>A list that contains <code>time</code>, <code>status</code> and <code>X</code>. <code>time</code> is failure or censoring time, <code>status</code> is censoring indicator, and  <code>X</code> is n x p matrix and may have p &gt; n.
</p>
</td></tr>
<tr><td><code id="negloglik_+3A_theta">theta</code></td>
<td>

<p>An n x p matrix of coefficients corresponding to covariates <code>X</code>. 
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jiacheng Wu
</p>


<h3>References</h3>

<p>Jiacheng Wu &amp; Daniela Witten (2019) Flexible and Interpretable Models for Survival Data, Journal of Computational and Graphical Statistics, DOI: 10.1080/10618600.2019.1592758
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict_best_lambda">predict_best_lambda</a></code>, <code><a href="#topic+tfCox_choose_lambda">tfCox_choose_lambda</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#generate training and testing data
dat = sim_dat(n=100, zerof=0, scenario=1)
test_dat = sim_dat(n=100, zerof=0, scenario=1)

#choose the optimal tuning parameter
cv = tfCox_choose_lambda(dat, test_dat, ord=0, alpha=1)
plot(cv$lam_seq, cv$loss)

#optimal tuning parameter
cv$best_lambda

#predict the coefficients of testing covariates from the optimal tuning parameter
#from tfCox_choose_lambda object. 
theta_hat = predict_best_lambda(cv, test_dat$X)

#calculate the loss in the testing data based on the estimated coefficients theta
negloglik(test_dat, theta_hat)
</code></pre>

<hr>
<h2 id='plot.cv_tfCox'>
Plots Cross-Validation Curve for Object of Class &quot;cv_tfCox&quot;
</h2><span id='topic+plot.cv_tfCox'></span>

<h3>Description</h3>

<p>This function plots the cross-validation curve for models fitted by a range of tuning parameter lambda using <code><a href="#topic+cv_tfCox">cv_tfCox</a></code>. The cross-validation error with +/-1 standard error is plotted for each value of lambda. The dotted vertical line indicates the chosen lambda corresponding to the minimum cross-validation error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv_tfCox'
plot(x, showSE=F, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.cv_tfCox_+3A_x">x</code></td>
<td>

<p>an object of class &quot;cv_tfCox&quot;
</p>
</td></tr>
<tr><td><code id="plot.cv_tfCox_+3A_showse">showSE</code></td>
<td>

<p>a logical (TRUE or FALSE) for whether the standard errors of the curve should be plotted
</p>
</td></tr>
<tr><td><code id="plot.cv_tfCox_+3A_...">...</code></td>
<td>

<p>additional arguments to be passed. These are ignored in this function.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jiacheng Wu
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv_tfCox">cv_tfCox</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#generate data
set.seed(123)
dat = sim_dat(n=100, zerof=0, scenario=1)

#fit piecewise constant functions
#cross-validation to choose the tuning parameter lambda with fixed alpha=1
cv = cv_tfCox(dat, ord=0, alpha=1, n.fold=2, seed=123)
plot(cv, showSE=TRUE)
</code></pre>

<hr>
<h2 id='plot.sim_dat'>
Plot the true covariate effects
</h2><span id='topic+plot.sim_dat'></span>

<h3>Description</h3>

<p>This function plots the functional form of covariate effects in four simulation scenarios.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sim_dat'
plot(x, which.predictor = NULL, n.plot = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.sim_dat_+3A_x">x</code></td>
<td>

<p>an object of class &quot;sim_dat&quot;
</p>
</td></tr>
<tr><td><code id="plot.sim_dat_+3A_which.predictor">which.predictor</code></td>
<td>

<p>a vector of predictor index that indicates which predictor function to plot. The vector should have integer values from 1 to p where p is the number of predictors.
</p>
</td></tr>
<tr><td><code id="plot.sim_dat_+3A_n.plot">n.plot</code></td>
<td>

<p>the number of predictors to be plotted (default is 4). If <code>which.predictor</code> is supplied, this argument is ignored.
</p>
</td></tr>
<tr><td><code id="plot.sim_dat_+3A_...">...</code></td>
<td>

<p>additional arguments to be passed. These are ignored in this function.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jiacheng Wu
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim_dat">sim_dat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#generate data
set.seed(123)
dat = sim_dat(n=100, zerof=0, scenario=1)
#plot X versus the true theta
plot.sim_dat(dat)
</code></pre>

<hr>
<h2 id='plot.tfCox'>
Plot Fitted Functions from Class &quot;tfCox&quot;
</h2><span id='topic+plot.tfCox'></span>

<h3>Description</h3>

<p>This function plots the fitted functions from a model estimated by <code><a href="#topic+tfCox">tfCox</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tfCox'
plot(x, which.lambda=1, which.predictor = NULL, n.plot = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.tfCox_+3A_x">x</code></td>
<td>

<p>an object of class &quot;tfCox&quot;
</p>
</td></tr>
<tr><td><code id="plot.tfCox_+3A_which.lambda">which.lambda</code></td>
<td>

<p>the index for the model of interest to be plotted. <code>which.lambda</code> corresponds to the model fit in <code>lambda.seq</code> and should be integer between 1 to <code>length(fit$lambda.seq)</code>. In other words, the fit from <code>fit$theta.list[[which.lambda]]</code> will be plotted.
</p>
</td></tr>
<tr><td><code id="plot.tfCox_+3A_which.predictor">which.predictor</code></td>
<td>

<p>a vector of predictor index that indicates which predictor function to plot. The vector should have integer values from 1 to p where p is the number of predictors.
</p>
</td></tr>
<tr><td><code id="plot.tfCox_+3A_n.plot">n.plot</code></td>
<td>

<p>the number of predictors to be plotted (default is 4). Note that only those non-zero estimated functions will be plotted. If <code>which.predictor</code> is supplied, this argument is ignored.
</p>
</td></tr>
<tr><td><code id="plot.tfCox_+3A_...">...</code></td>
<td>

<p>additional arguments to be passed. These are ignored in this function.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jiacheng Wu
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tfCox">tfCox</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#generate data
set.seed(123)
dat = sim_dat(n=100, zerof=0, scenario=1)

fit = tfCox(dat, ord=0, alpha=1, lambda.seq=0.04)
plot(fit, n.plot=4)

</code></pre>

<hr>
<h2 id='predict_best_lambda'>
Predict from the optimal lambda from tfCox_choose_lambda
</h2><span id='topic+predict_best_lambda'></span>

<h3>Description</h3>

<p>Estimate the corresponding theta values from the optimal tuning parameter obtained by <code><a href="#topic+tfCox_choose_lambda">tfCox_choose_lambda</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_best_lambda(cv, newX)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict_best_lambda_+3A_cv">cv</code></td>
<td>

<p>An object from tfCox_choose_lambda. 
</p>
</td></tr>
<tr><td><code id="predict_best_lambda_+3A_newx">newX</code></td>
<td>

<p>The new covariate values. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimated theta values. 
</p>


<h3>Author(s)</h3>

<p>Jiacheng Wu
</p>


<h3>References</h3>

<p>Jiacheng Wu &amp; Daniela Witten (2019) Flexible and Interpretable Models for Survival Data, Journal of Computational and Graphical Statistics, DOI: 10.1080/10618600.2019.1592758
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tfCox_choose_lambda">tfCox_choose_lambda</a></code>, <code><a href="#topic+negloglik">negloglik</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#generate training and testing data
dat = sim_dat(n=100, zerof=0, scenario=1)
test_dat = sim_dat(n=100, zerof=0, scenario=1)

#choose the optimal tuning parameter
cv = tfCox_choose_lambda(dat, test_dat, ord=0, alpha=1)
plot(cv$lam_seq, cv$loss)

#optimal tuning parameter
cv$best_lambda

#Estimate the theta values of testing covariates from the optimal tuning parameter
#from tfCox_choose_lambda object. 
theta_hat = predict_best_lambda(cv, test_dat$X)
</code></pre>

<hr>
<h2 id='predict.tfCox'>Predict for a New Covariate Matrix and fit from <code><a href="#topic+tfCox">tfCox</a></code>
</h2><span id='topic+predict.tfCox'></span>

<h3>Description</h3>

<p>This function makes predictions from a specified covariate matrix for a fit of the class &quot;tfCox&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tfCox'
predict(object, newX, which.lambda=1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.tfCox_+3A_object">object</code></td>
<td>

<p>an object of the class &quot;tfCox&quot;
</p>
</td></tr>
<tr><td><code id="predict.tfCox_+3A_newx">newX</code></td>
<td>

<p>a n x p covariate matrix
</p>
</td></tr>
<tr><td><code id="predict.tfCox_+3A_which.lambda">which.lambda</code></td>
<td>

<p>the index for the model of interest to be plotted. <code>which.lambda</code> corresponds to the model fit in <code>lambda.seq</code> and should be integer between 1 to <code>length(fit$lambda.seq)</code>. In other words, the fit from <code>fit$theta.list[[which.lambda]]</code> will be plotted.
</p>
</td></tr>
<tr><td><code id="predict.tfCox_+3A_...">...</code></td>
<td>

<p>additional arguments to be passed. These are ignored in this function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prediction for the new data point is implemented by constant or linear interpolation. 0th order trend filtering will have constant interpolation, and 1th or higher order trend filtering will have linear interpolation.
</p>


<h3>Value</h3>

<p>A n x p matrix containing the fitted theta values.
</p>


<h3>Author(s)</h3>

<p>Jiacheng Wu
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tfCox">tfCox</a></code>
</p>

<hr>
<h2 id='sim_dat'>
Simulate Data from a Variety of Functional Scenarios
</h2><span id='topic+sim_dat'></span>

<h3>Description</h3>

<p>This function generates survival data according to the simulation scenarios considered in Section 4 of Wu, J., and Witten, D. (2019) Flexible and interpretable models for survival data. Cox model has the form
</p>
<p style="text-align: center;"><code class="reqn"> \lambda(t|x) = \lambda_0(t) exp(\sum_{j=1}^p f_j(x)) </code>
</p>
<p>.
Failure time is generated by Weibull distribution with baseline hazard </p>
<p style="text-align: center;"><code class="reqn">\lambda_0(t) = scale * shape * t ^ {shape-1}</code>
</p>
<p>. In the paper, however, failure time is generated by a simplied weibull distribution: exponential(1) baseline hazard corresponding to <code>shape=1</code> and <code>scale=1</code>. Censoring time is generated independently by exponential distribution with intensity <code>censoring.rate</code>. Thus the observed time is the minimum of failure time and censoring time. Each scenario has four covariates that have some non-linear association with the outcome. There is the option to also generate a user-specified number of covariates that have no association with the outcome. </p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_dat(n, zerof=0, scenario=1, scale=1, shape=1, censoring.rate=0.01, n.discrete=0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_dat_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="sim_dat_+3A_scenario">scenario</code></td>
<td>
<p>Simulation scenario. Options are 1, 2, 3, 4. Scenario 1 corresponds to piecewise constant functions, scenario 2 corresponds to smooth functions, scenario 3 corresponds to piecewise linear functions, and scenario 4 corresponds to functions that have varying degrees of smoothness. Each scenario has four covariates that have some non-linear association with the outcome. </p>
</td></tr>
<tr><td><code id="sim_dat_+3A_zerof">zerof</code></td>
<td>
<p>Number of additional covariates that have no association with the outcome. The total number of covariates is <code>4+zerof</code>.</p>
</td></tr>
<tr><td><code id="sim_dat_+3A_scale">scale</code></td>
<td>
<p>scale parameter as in <code>rweibull</code></p>
</td></tr>
<tr><td><code id="sim_dat_+3A_shape">shape</code></td>
<td>
<p>shape parameter as in <code>rweibull</code></p>
</td></tr>
<tr><td><code id="sim_dat_+3A_censoring.rate">censoring.rate</code></td>
<td>
<p>censoring intensity. Censoring time is generated by exponential distribution with intensity <code>censoring.rate</code>.</p>
</td></tr>
<tr><td><code id="sim_dat_+3A_n.discrete">n.discrete</code></td>
<td>
<p>The number of binary covariates and default is zero binary covariate.  </p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>time</code></td>
<td>
<p>failure or censoring time whichever comes first. </p>
</td></tr>
<tr><td><code>status</code></td>
<td>
<p>censoring indicator. 1 denotes censoring and 0 denotes failure. </p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>n x p covariate matrix. </p>
</td></tr>
<tr><td><code>true_theta</code></td>
<td>
<p>n x p matrix. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jiacheng Wu</p>


<h3>References</h3>

<p>Jiacheng Wu &amp; Daniela Witten (2019) Flexible and Interpretable Models for Survival Data, Journal of Computational and Graphical Statistics, DOI: 10.1080/10618600.2019.1592758
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.sim_dat">plot.sim_dat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#generate data
set.seed(123)
dat = sim_dat(n=100, zerof=0, scenario=1)
#plot X versus the true theta
plot.sim_dat(dat)
</code></pre>

<hr>
<h2 id='summary.cv_tfCox'>
Summarize <code>cv_tfCox</code> object
</h2><span id='topic+summary.cv_tfCox'></span>

<h3>Description</h3>

<p>This function summarizes <code>cv_tfCox</code> object and identifies the tuning parameter chosen by cross-validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv_tfCox'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.cv_tfCox_+3A_object">object</code></td>
<td>

<p>an object of class &quot;cv_tfCox&quot;
</p>
</td></tr>
<tr><td><code id="summary.cv_tfCox_+3A_...">...</code></td>
<td>

<p>additional arguments to be passed. These are ignored in this function.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jiacheng Wu
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv_tfCox">cv_tfCox</a></code>, <code><a href="#topic+plot.cv_tfCox">plot.cv_tfCox</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#generate data
set.seed(1234)
dat = sim_dat(n=100, zerof=0, scenario=1)

#cross-validation to choose the tuning parameter lambda with fixed alpha=1
cv = cv_tfCox(dat, ord=0, alpha=1, n.fold=2)
#summarize the cross-validation
summary(cv)
#plot the cross-validation curve
plot(cv)
</code></pre>

<hr>
<h2 id='summary.tfCox'>
Summarize <code>tfCox</code> object
</h2><span id='topic+summary.tfCox'></span>

<h3>Description</h3>

<p>This function summarizes <code>tfCox</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tfCox'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.tfCox_+3A_object">object</code></td>
<td>
<p>an object of class &quot;tfCox&quot;</p>
</td></tr>
<tr><td><code id="summary.tfCox_+3A_...">...</code></td>
<td>

<p>additional arguments to be passed. These are ignored in this function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Summarize the fit by the number of knots and percent sparsity achieved. Percent sparsity is the percentage of features estimated to have no relationship with the outcome.
</p>


<h3>Author(s)</h3>

<p>Jiacheng Wu
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tfCox">tfCox</a></code>, <code><a href="#topic+plot.tfCox">plot.tfCox</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#generate data
set.seed(1234)
dat = sim_dat(n=100, zerof=0, scenario=1)

#fit piecewise constant for alpha=1 and a range of lambda
fit = tfCox(dat, ord=0, alpha=1)

#summarize the fit by the number of knots and percent sparsity achieved.
#Percent sparsity is the percentage of features estimated to have
#no relationship with outcome
summary(fit)
</code></pre>

<hr>
<h2 id='tfCox'>Fit the additive trend filtering Cox model with a range of tuning parameters</h2><span id='topic+tfCox'></span>

<h3>Description</h3>

<p>Fit additive trend filtering Cox model where each component function is estimated to be piecewise constant or polynomial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tfCox(dat, ord=0, alpha=1, lambda.seq=NULL, discrete=NULL, n.lambda=30,
lambda.min.ratio = 0.01, tol=1e-6, niter=1000, stepSize=25, backtracking=0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tfCox_+3A_dat">dat</code></td>
<td>

<p>A list that contains <code>time</code>, <code>status</code> and <code>X</code>. <code>time</code> is failure or censoring time, <code>status</code> is failure indicator with 1 indicating failure and 0 indicating censoring, and <code>X</code> is n x p design matrix and may have p &gt; n. Missing data are not allowed in <code>time</code>, <code>status</code> and <code>X</code>. <code>X</code> should be numeric.
</p>
</td></tr>
<tr><td><code id="tfCox_+3A_ord">ord</code></td>
<td>

<p>The polynomial order of the trend filtering fit; a non-negative interger (<code>ord&gt;= 3</code> is not recommended). For instance, <code>ord=0</code> will produce piewise constant fit, <code>ord=1</code> will produce piewise linear fit, and <code>ord=2</code> will produce piewise quadratic fit.
</p>
</td></tr>
<tr><td><code id="tfCox_+3A_alpha">alpha</code></td>
<td>

<p>The trade-off between trend filtering penalty and group lasso penalty. It must be in [0,1]. <code>alpha=1</code> corresponds to the case with only trend filtering penalty to produce piecewise polynomial, and <code>alpha=0</code> corresponds to the case with only group lasso penalty to produce sparsity of the functions. <code>alpha</code> between 0 and 1 is the tradeoff between the strength of these two penalties. For p &lt; n, we suggest using 1.
</p>
</td></tr>
<tr><td><code id="tfCox_+3A_lambda.seq">lambda.seq</code></td>
<td>

<p>A vector of non-negative tuning parameters. If provided, <code>lambda.seq</code> should be a decreasing sequence of values since <code>tfCox</code> uses warm starts for speed. If <code>lambda.seq=NULL</code>, the default will calculate <code>lambda.seq</code> using <code>lambda.min.ratio</code> and <code>n.lambda</code>.
</p>
</td></tr>
<tr><td><code id="tfCox_+3A_discrete">discrete</code></td>
<td>

<p>A vector of covariate/feature indice that are discrete. Discrete covariates are not penalized in the model. Default <code>NULL</code> means that none of the covariates are discrete thus all covariates will be penalized in the model.
</p>
</td></tr>
<tr><td><code id="tfCox_+3A_n.lambda">n.lambda</code></td>
<td>

<p>The number of lambda values to consider and the default is 30.
</p>
</td></tr>
<tr><td><code id="tfCox_+3A_lambda.min.ratio">lambda.min.ratio</code></td>
<td>

<p>Smallest value for lambda.seq, as a fraction of the maximum lambda value, which is the smallest value such that the penalty term is zero. The default is 0.01.
</p>
</td></tr>
<tr><td><code id="tfCox_+3A_tol">tol</code></td>
<td>

<p>Convergence criterion for estimates.
</p>
</td></tr>
<tr><td><code id="tfCox_+3A_niter">niter</code></td>
<td>

<p>Maximum number of iterations.
</p>
</td></tr>
<tr><td><code id="tfCox_+3A_stepsize">stepSize</code></td>
<td>

<p>Initial step size. Default is 25.
</p>
</td></tr>
<tr><td><code id="tfCox_+3A_backtracking">backtracking</code></td>
<td>

<p>Whether backtracking should be used 1 (TRUE) or 0 (FALSE). Default is 0 (FALSE). 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The optimization problem has the form
</p>
<p style="text-align: center;"><code class="reqn"> l(\theta)+\alpha\lambda\sum_{j=1}^p |D_jP_j\theta_j|_1+(1-\alpha)\lambda\sum_{j=1}^p|\theta_j|_2 </code>
</p>

<p>where <code class="reqn">l</code> is the loss function defined as the negative log partial likelihood divided by n, and <code class="reqn">\alpha</code> provides a trade-off between trend filtering penalty and group lasso penalty. Covariate matrix <code>X</code> is not standardized before solving the optimization problem.
</p>


<h3>Value</h3>

<p>An object with S3 class &quot;tfCox&quot;.
</p>
<table role = "presentation">
<tr><td><code>ord</code></td>
<td>
<p>the polynomial order of the trend filtering fit. Specified by user (or default).  </p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>as specified by user (or default). </p>
</td></tr>
<tr><td><code>lambda.seq</code></td>
<td>
<p>vector of lambda values considered. </p>
</td></tr>
<tr><td><code>theta.list</code></td>
<td>
<p>list of estimated theta matrices of dimension n x p. Each component in the list corresponds to the fit from <code>lambda.seq</code>. </p>
</td></tr>
<tr><td><code>num.knots</code></td>
<td>
<p>vector of number of knots of the estimated theta. Each component corresponds to the fit from <code>lambda.seq</code>. </p>
</td></tr>
<tr><td><code>num.nonsparse</code></td>
<td>
<p>vector of proportion of non-sparse/non-zero covariates/features. Each component corresponds to the fit from <code>lambda.seq</code>. </p>
</td></tr>
<tr><td><code>dat</code></td>
<td>
<p>as specified by user. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jiacheng Wu
</p>


<h3>References</h3>

<p>Jiacheng Wu &amp; Daniela Witten (2019) Flexible and Interpretable Models for Survival Data, Journal of Computational and Graphical Statistics, DOI: 10.1080/10618600.2019.1592758
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.tfCox">summary.tfCox</a></code>, <code><a href="#topic+predict.tfCox">predict.tfCox</a></code>, <code><a href="#topic+plot.tfCox">plot.tfCox</a></code>, <code><a href="#topic+cv_tfCox">cv_tfCox</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###################################################################
#constant trend filtering (fused lasso) with adaptively chosen knots
#generate data from simulation scenario 1 with piecewise constant functions
set.seed(1234)
dat = sim_dat(n=100, zerof=0, scenario=1)

#fit piecewise constant for alpha=1 and a range of lambda
fit = tfCox(dat, ord=0, alpha=1)
summary(fit)
#plot the fit of lambda index 15 and the first predictor
plot(fit, which.lambda=15, which.predictor=1)

#cross-validation to choose the tuning parameter lambda with fixed alpha=1
cv = cv_tfCox(dat, ord=0, alpha=1, n.fold=2)
summary(cv)
cv$best.lambda
#plot the cross-validation curve
plot(cv)

#fit the model with the best tuning parameter chosen by cross-validation
one.fit = tfCox(dat, ord=0, alpha=1, lambda.seq=cv$best.lambda)
#predict theta from the fitted tfCox object
theta_hat = predict(one.fit, newX=dat$X, which.lambda=1)

#plot the fitted theta_hat (line) with the true theta (dot)
for (i in 1:4) {
  ordi = order(dat$X[,i])
  plot(dat$X[ordi,i], dat$true_theta[ordi,i],
    xlab=paste("predictor",i), ylab="theta" )
  lines(dat$X[ordi,i], theta_hat[ordi,i], type="s")
}


#################################################################
#linear trend filtering with adaptively chosen knots
#generate data from simulation scenario 3 with piecewise linear functions
set.seed(1234)
dat = sim_dat(n=100, zerof=0, scenario=3)

#fit piecewise constant for alpha=1 and a range of lambda
fit = tfCox(dat, ord=1, alpha=1)
summary(fit)
#plot the fit of lambda index 15 and the first predictor
plot(fit, which.lambda=15, which.predictor=1)

#cross-validation to choose the tuning parameter lambda with fixed alpha=1
cv = cv_tfCox(dat, ord=1, alpha=1, n.fold=2)
summary(cv)
#plot the cross-validation curve
plot(cv)

#fit the model with the best tuning parameter chosen by cross-validation
one.fit = tfCox(dat, ord=1, alpha=1, lambda.seq=cv$best.lambda)
#predict theta from the fitted tfCox object
theta_hat = predict(one.fit, newX=dat$X, which.lambda=1)

#plot the fitted theta_hat (line) with the true theta (dot)
for (i in 1:4) {
  ordi = order(dat$X[,i])
  plot(dat$X[ordi,i], dat$true_theta[ordi,i],
       xlab=paste("predictor",i), ylab="theta" )
  lines(dat$X[ordi,i], theta_hat[ordi,i], type="l")
}


</code></pre>

<hr>
<h2 id='tfCox_choose_lambda'>
Choose the tuning parameter lambda using training and testing dataset
</h2><span id='topic+tfCox_choose_lambda'></span>

<h3>Description</h3>

<p>Fit additive trend filtering Cox model where each component function is estimated to be piecewise constant or polynomial. Tuning parameter is selected via training and testing dataset described in Wu and Witten (2019). Training data is used to build the model, and testing data is used for selecting tuning parameter based on log likelihood. It is a convenience function to replicate the simulation results in Wu and Witten (2019). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tfCox_choose_lambda(dat, test_dat, ord = 0, alpha = 1, discrete = NULL, 
lam_seq = NULL, nlambda = 30, c = NULL, tol = 1e-06, niter=1000, 
stepSize=25, backtracking=0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tfCox_choose_lambda_+3A_dat">dat</code></td>
<td>

<p>A list that contains <code>time</code>, <code>status</code> and <code>X</code>. <code>time</code> is failure or censoring time, <code>status</code> is censoring indicator, and  <code>X</code> is n x p matrix and may have p &gt; n. This is the training data that will be used for estimation for a given tuning parameter lambda. 
</p>
</td></tr>
<tr><td><code id="tfCox_choose_lambda_+3A_test_dat">test_dat</code></td>
<td>

<p>Same list frame as before. This is the testing data that will be used for selecting tuning parameter based on the log likelihood fit. 
</p>
</td></tr>
<tr><td><code id="tfCox_choose_lambda_+3A_ord">ord</code></td>
<td>

<p>The polynomial order of the trend filtering fit; a non-negative interger (<code>ord&gt;= 3</code> is not recommended). For instance, <code>ord=0</code> will produce piewise constant fit, <code>ord=1</code> will produce piewise linear fit, and <code>ord=2</code> will produce piewise quadratic fit.
</p>
</td></tr>
<tr><td><code id="tfCox_choose_lambda_+3A_alpha">alpha</code></td>
<td>

<p>The trade-off between trend filtering penalty and group lasso penalty. It must be in [0,1]. <code>alpha=1</code> corresponds to the case with only trend filtering penalty to produce piecewise polynomial, and <code>alpha=0</code> corresponds to the case with only group lasso penalty to produce sparsity of the functions. <code>alpha</code> between 0 and 1 is the tradeoff between the strength of these two penalties. For p &lt; n, we suggest using 1.
</p>
</td></tr>
<tr><td><code id="tfCox_choose_lambda_+3A_discrete">discrete</code></td>
<td>

<p>A vector of covariate/feature indice that are discrete. Discrete covariates are not penalized in the model. Default <code>NULL</code> means that none of the covariates are discrete thus all covariates will be penalized in the model.
</p>
</td></tr>
<tr><td><code id="tfCox_choose_lambda_+3A_lam_seq">lam_seq</code></td>
<td>

<p>The sequence of positive lambda values to consider. The default is <code>NULL</code>, which calculates <code>lambda.seq</code> using <code>lambda.min.ratio</code> and <code>n.lambda</code>. If <code>lambda.seq</code> is provided, it will override the default.  <code>lambda.seq</code> should be a decreasing positive sequence of values since <code>cv_tfCox</code> replies on warm starts to speed up the computation.
</p>
</td></tr>
<tr><td><code id="tfCox_choose_lambda_+3A_nlambda">nlambda</code></td>
<td>

<p>The number of lambda values to consider. Default is 30.
</p>
</td></tr>
<tr><td><code id="tfCox_choose_lambda_+3A_c">c</code></td>
<td>

<p>Smallest value for lam_seq, as a fraction of the maximum lambda value, which is the smallest value such that the penalty term is zero. The default is NULL. 
</p>
</td></tr>
<tr><td><code id="tfCox_choose_lambda_+3A_tol">tol</code></td>
<td>

<p>Convergence criterion for estimates.
</p>
</td></tr>
<tr><td><code id="tfCox_choose_lambda_+3A_niter">niter</code></td>
<td>

<p>Maximum number of iterations.
</p>
</td></tr>
<tr><td><code id="tfCox_choose_lambda_+3A_stepsize">stepSize</code></td>
<td>

<p>Iniitial step size. Default is 25.
</p>
</td></tr>
<tr><td><code id="tfCox_choose_lambda_+3A_backtracking">backtracking</code></td>
<td>

<p>Whether backtracking should be used 1 (TRUE) or 0 (FALSE). Default is 0 (FALSE). 
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>lam_seq</code></td>
<td>

<p>Lambda sequence considered.
</p>
</td></tr>
<tr><td><code>loss</code></td>
<td>

<p>Loss based on the testing data with the same length as <code>lambda.seq</code>
</p>
</td></tr>
<tr><td><code>knots</code></td>
<td>

<p>Number of knots from the training data with the same length as <code>lambda.seq</code>
</p>
</td></tr>
<tr><td><code>paramfit</code></td>
<td>

<p>Mean square error between the estimated and true theta for the testing data. 
</p>
</td></tr>
<tr><td><code>best_lambda</code></td>
<td>

<p>The lambda that achieves the minimum loss for testing data. 
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jiacheng Wu
</p>


<h3>References</h3>

<p>Jiacheng Wu &amp; Daniela Witten (2019) Flexible and Interpretable Models for Survival Data, Journal of Computational and Graphical Statistics, DOI: 10.1080/10618600.2019.1592758
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict_best_lambda">predict_best_lambda</a></code>, <code><a href="#topic+negloglik">negloglik</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#generate training and testing data
dat = sim_dat(n=100, zerof=0, scenario=1)
test_dat = sim_dat(n=100, zerof=0, scenario=1)

#choose the optimal tuning parameter
cv = tfCox_choose_lambda(dat, test_dat, ord=0, alpha=1)
plot(cv$lam_seq, cv$loss)

#optimal tuning parameter
cv$best_lambda

#predict the coefficients of testing covariates from the optimal tuning parameter
#from tfCox_choose_lambda object. 
theta_hat = predict_best_lambda(cv, test_dat$X)

#calculate the loss in the testing data based on the estimated coefficients theta
negloglik(test_dat, theta_hat)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
