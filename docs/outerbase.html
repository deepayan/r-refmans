<!DOCTYPE html><html><head><title>Help for package outerbase</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {outerbase}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BFGS_lpdf'><p>BFGS lpdf</p></a></li>
<li><a href='#BFGS_std'><p>BFGS standard</p></a></li>
<li><a href='#covf'><p>covariance function class</p></a></li>
<li><a href='#covf_mat25'><p>Matern covariance function</p></a></li>
<li><a href='#covf_mat25ang'><p>Matern covariance function with angular transform</p></a></li>
<li><a href='#covf_mat25pow'><p>Matern covariance function with power transform</p></a></li>
<li><a href='#gethyp'><p>Get the hyperparameters</p></a></li>
<li><a href='#getpara'><p>Get the model parameters</p></a></li>
<li><a href='#listcov'><p>list all covariance functions</p></a></li>
<li><a href='#loglik_gauss'><p>Gaussian errors, large scale</p></a></li>
<li><a href='#loglik_gda'><p>Gaussian errors with diagonal adjustment</p></a></li>
<li><a href='#loglik_std'><p>Gaussian errors</p></a></li>
<li><a href='#logpr_gauss'><p>Gaussian prior</p></a></li>
<li><a href='#lpdf'><p>Log probability density function class</p></a></li>
<li><a href='#lpdf$optcg'><p>Optimization via Conjugate Gradient</p></a></li>
<li><a href='#lpdf$optnewton'><p>Optimization via Newton's Method</p></a></li>
<li><a href='#lpdfvec'><p>Vector of <code>lpdf</code> instances</p></a></li>
<li><a href='#obfit'><p>Outerbase model fit</p></a></li>
<li><a href='#obpred'><p>Prediction from outerbase</p></a></li>
<li><a href='#obtest_borehole3d'><p>Three dim borehole example</p></a></li>
<li><a href='#obtest_borehole8d'><p>Eight dim borehole example</p></a></li>
<li><a href='#outerbase'><p>Outer product-type basis</p></a></li>
<li><a href='#outerbase-package'><p>outerbase</p></a></li>
<li><a href='#outerbase$build'><p>Builds the outerbase</p></a></li>
<li><a href='#outerbase$getbase'><p>Get base functions</p></a></li>
<li><a href='#outerbase$getmat'><p>Get basis matrix</p></a></li>
<li><a href='#outerbase$matmul'><p>Matrix multiply</p></a></li>
<li><a href='#outerbase$tmatmul'><p>Transpose Matrix multiply</p></a></li>
<li><a href='#outermod'><p>Outer product-type model</p></a></li>
<li><a href='#outermod$getvar'><p>Get variance of coefficients</p></a></li>
<li><a href='#outermod$selectterms'><p>Select optimal terms</p></a></li>
<li><a href='#outermod$updatehyp'><p>Update hyperparameters</p></a></li>
<li><a href='#predictor'><p>prediction class</p></a></li>
<li><a href='#setcovfs'><p>Set covariance functions</p></a></li>
<li><a href='#setknot'><p>Set knot points</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Outer Product Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-06-03</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthew Plumlee &lt;mplumlee@northwestern.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>High-dimensional regression using outer product models.  Research on the methods is currently under investigation and published resources will be posted as they are available.  As the method is new, the website is the best resource for understanding the principals. Some of the core ideas are based on Plumlee and coauthors' work on analysis of grid-structured  experiments described in Plumlee (2014) &lt;<a href="https://doi.org/10.1080%2F01621459.2014.900250">doi:10.1080/01621459.2014.900250</a>&gt; and  Plumlee, Erickson, Ankenman, Lawrence (2021) &lt;<a href="https://doi.org/10.1093%2Fbiomet%2Fasaa084">doi:10.1093/biomet/asaa084</a>&gt;.  Some additional textbooks for additional information on Gaussian processes are Rasmussen and Williams (2005) &lt;<a href="https://doi.org/10.7551%2Fmitpress%2F3206.001.0001">doi:10.7551/mitpress/3206.001.0001</a>&gt; and  Gramacy (2022) &lt;<a href="https://doi.org/10.1201%2F9780367815493">doi:10.1201/9780367815493</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://mattplumlee.github.io/outerbase/">https://mattplumlee.github.io/outerbase/</a>,
<a href="https://github.com/MattPlumlee/outerbase/">https://github.com/MattPlumlee/outerbase/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/MattPlumlee/outerbase/issues">https://github.com/MattPlumlee/outerbase/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, Rcpp, utils, stats</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-06-08 16:50:38 UTC; floyd</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthew Plumlee [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-06-09 14:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='BFGS_lpdf'>BFGS lpdf</h2><span id='topic+BFGS_lpdf'></span>

<h3>Description</h3>

<p>A wrapper for code<a href="#topic+BFGS_std">BFGS_std</a> that is useful for easily calling 
parameter optimization for this package with as few lines as possible.
Note that <code>om</code> and <code>logpdf</code> will be set to optimal 
parameters, the return is simply for information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BFGS_lpdf(
  om,
  logpdf,
  parlist = list(),
  newt = FALSE,
  cgsteps = 100,
  cgtol = 0.001,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BFGS_lpdf_+3A_om">om</code></td>
<td>
<p>an <code><a href="#topic+outermod">outermod</a></code> instance</p>
</td></tr>
<tr><td><code id="BFGS_lpdf_+3A_logpdf">logpdf</code></td>
<td>
<p>a <code><a href="#topic+lpdf">lpdf</a></code> instance</p>
</td></tr>
<tr><td><code id="BFGS_lpdf_+3A_parlist">parlist</code></td>
<td>
<p>an initial point, which are pulled from 'om' and 'logpdf' if 
not provided</p>
</td></tr>
<tr><td><code id="BFGS_lpdf_+3A_newt">newt</code></td>
<td>
<p>boolean for if Newtons method should be used</p>
</td></tr>
<tr><td><code id="BFGS_lpdf_+3A_cgsteps">cgsteps</code></td>
<td>
<p>max number of cg iterations, if <code>newt=FALSE</code></p>
</td></tr>
<tr><td><code id="BFGS_lpdf_+3A_cgtol">cgtol</code></td>
<td>
<p>cg tolerance, if <code>newt=FALSE</code></p>
</td></tr>
<tr><td><code id="BFGS_lpdf_+3A_...">...</code></td>
<td>
<p>additional parameters passed to <code><a href="#topic+BFGS_std">BFGS_std</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of information from optimization.
</p>

<hr>
<h2 id='BFGS_std'>BFGS standard</h2><span id='topic+BFGS_std'></span>

<h3>Description</h3>

<p>Do generic minimization of a function <code>funcw</code> that takes
a list parlist using the &quot;Broyden-Fletcher-Goldfarb-Shanno&quot; (BFGS) algorithm.
Useful for hyperparameter optimization because it handles infinite returns
fairly easily.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BFGS_std(funcw, parlist, B = NULL, lr = 0.1, ..., verbose = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BFGS_std_+3A_funcw">funcw</code></td>
<td>
<p>An object to optimize</p>
</td></tr>
<tr><td><code id="BFGS_std_+3A_parlist">parlist</code></td>
<td>
<p>An initial point as a list</p>
</td></tr>
<tr><td><code id="BFGS_std_+3A_b">B</code></td>
<td>
<p>An initial Hessian to start from</p>
</td></tr>
<tr><td><code id="BFGS_std_+3A_lr">lr</code></td>
<td>
<p>An initial learning rate to start from</p>
</td></tr>
<tr><td><code id="BFGS_std_+3A_...">...</code></td>
<td>
<p>additional parameters passed to <code>funcw</code></p>
</td></tr>
<tr><td><code id="BFGS_std_+3A_verbose">verbose</code></td>
<td>
<p>an integer from 0-3 where larger prints more information</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of information from optimization, with the value stored in
<code>parlist</code>
</p>

<hr>
<h2 id='covf'>covariance function class</h2><span id='topic+covf'></span><span id='topic+Rcpp_covf-class'></span><span id='topic+Rcpp_covf'></span>

<h3>Description</h3>

<p>This is a base class designed to handle the specific features of 
covariances needed for outerbase.  Polymorphism allows for the implied 
methods to be used across several similar classes.
</p>


<h3>Value</h3>

<p>no returns, this is a class which contains methods
</p>


<h3>Fields</h3>


<dl>
<dt><code>covf$hyp</code></dt><dd><p>hyperparameters for this specific correlation function</p>
</dd>
<dt><code>covf$lowbnd,covf$uppbnd</code></dt><dd><p>upper and lower bounds for the inputs to the 
covariance function.</p>
</dd>
<dt><code>covf$cov(x1,x2)</code></dt><dd><p>returns the covariance matrix between two vectors of 
inputs <code>x1</code> and <code>x2</code></p>
</dd>
<dt><code>covf$covdiag(x1)</code></dt><dd><p>returns the diagonal of the covariance matrix between 
<code>x1</code> and itself</p>
</dd>
<dt><code>covf$cov_gradhyp(x1,x2)</code></dt><dd><p>returns a cube of the gradient the <code>cov</code> 
with respect to the covariance hyperparameters</p>
</dd>
</dl>


<h3>See Also</h3>

<p>derived class: <code><a href="#topic+covf_mat25">covf_mat25</a></code>, 
<code><a href="#topic+covf_mat25pow">covf_mat25pow</a></code>, 
<code><a href="#topic+covf_mat25ang">covf_mat25ang</a></code>
</p>

<hr>
<h2 id='covf_mat25'>Matern covariance function</h2><span id='topic+covf_mat25'></span><span id='topic+Rcpp_covf_mat25-class'></span><span id='topic+Rcpp_covf_mat25'></span>

<h3>Description</h3>

<pre>
covf = new(covf_mat25)
</pre>
<p>This is the standard Matern covariance function which has form
</p>
<p style="text-align: center;"><code class="reqn">c(x_1,x_2) = (1+ |h| + h^2/3) \exp(-|h|) </code>
</p>

<p>where <code class="reqn">h = (x_1-x_2)/\rho</code> and <code class="reqn">\rho</code>=<code>exp(2*hyp[0])</code>.
</p>


<h3>Value</h3>

<p>no returns, this is a class which contains methods
</p>


<h3>See Also</h3>

<p>base class: <code><a href="#topic+covf">covf</a></code>
</p>

<hr>
<h2 id='covf_mat25ang'>Matern covariance function with angular transform</h2><span id='topic+covf_mat25ang'></span><span id='topic+Rcpp_covf_mat25ang-class'></span><span id='topic+Rcpp_covf_mat25ang'></span>

<h3>Description</h3>

<pre>
covf = new(covf_mat25ang)
</pre>
<p>This is the standard Matern covariance function with a power transformation
which has form
</p>
<p style="text-align: center;"><code class="reqn">c(x_1,x_2) = (1+ |h| + h^2/3) \exp(-|h|) </code>
</p>

<p>where </p>
<p style="text-align: center;"><code class="reqn">h = \sqrt{(\sin(x_1)-\sin(x_2))^2/\rho_s + 
(\cos(x_1)-\cos(x_2))^2/\rho_c}.</code>
</p>

<p><code>hyp</code> is a two dimensional vector with 
<code class="reqn">\rho_s</code>=<code>exp(2*hyp[0])</code> and <code class="reqn">\rho_c</code>=<code>exp(2*hyp[1])</code>.
</p>


<h3>Value</h3>

<p>no returns, this is a class which contains methods
</p>


<h3>See Also</h3>

<p>base class: <code><a href="#topic+covf">covf</a></code>
</p>

<hr>
<h2 id='covf_mat25pow'>Matern covariance function with power transform</h2><span id='topic+covf_mat25pow'></span><span id='topic+Rcpp_covf_mat25pow-class'></span><span id='topic+Rcpp_covf_mat25pow'></span>

<h3>Description</h3>

<pre>
covf = new(covf_mat25pow)
</pre>
<p>This is the standard Matern covariance function with a power transformation
which has form
</p>
<p style="text-align: center;"><code class="reqn">c(x_1,x_2) = (1+ |h| + h^2/3) \exp(-|h|) </code>
</p>

<p>where <code class="reqn">h = (x_1^\alpha-x_2^\alpha)/\rho</code> and <code>hyp</code> is a two 
dimensional vector with <code class="reqn">\rho</code>=<code>exp(2*hyp[0]+0.25*hyp[1])</code>
and <code class="reqn">\alpha</code>=<code>exp(0.25*hyp[1])</code>.
</p>


<h3>Value</h3>

<p>no returns, this is a class which contains methods
</p>


<h3>See Also</h3>

<p>base class: <code><a href="#topic+covf">covf</a></code>
</p>

<hr>
<h2 id='gethyp'>Get the hyperparameters</h2><span id='topic+gethyp'></span>

<h3>Description</h3>

<pre>
hyp = gethyp(om)
</pre>
<p>Gets the current hyperparameters from an <code><a href="#topic+outermod">outermod</a></code> instance. It 
formats them in a way that makes reading in <code>R</code> easier.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="gethyp_+3A_om">om</code></td>
<td>
<p>an <code><a href="#topic+outermod">outermod</a></code> instance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of parameters
</p>


<h3>See Also</h3>

<p><code><a href="#topic+outermod">outermod</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>om = new(outermod)
setcovfs(om, c("mat25", "mat25", "mat25"))
hyp = gethyp(om)
print(hyp)
</code></pre>

<hr>
<h2 id='getpara'>Get the model parameters</h2><span id='topic+getpara'></span>

<h3>Description</h3>

<pre>
para = getpara(logpdf)
</pre>
<p>This function gets the current parameters from an <code><a href="#topic+lpdf">lpdf</a></code> class
instance. It formats them in a way that makes reading in <code>R</code> easier.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="getpara_+3A_logpdf">logpdf</code></td>
<td>
<p>an <code><a href="#topic+lpdf">lpdf</a></code> class instance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of parameters
</p>

<hr>
<h2 id='listcov'>list all covariance functions</h2><span id='topic+listcov'></span>

<h3>Description</h3>

<p>list all covariance functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>listcov()
</code></pre>


<h3>Value</h3>

<p>list all names of covariance functions recommend
as of this edition.  The first is the default.
</p>

<hr>
<h2 id='loglik_gauss'>Gaussian errors, large scale</h2><span id='topic+loglik_gauss'></span><span id='topic+Rcpp_loglik_gauss-class'></span><span id='topic+Rcpp_loglik_gauss'></span>

<h3>Description</h3>

<pre>
loglik = new(loglik_gauss, om, terms, y, x)
</pre>
<p>This is a standard model which has the form
</p>
<p style="text-align: center;"><code class="reqn">y = \langle \phi(x), \theta \rangle + \varepsilon, \varepsilon \sim 
N(0,\sigma^2)</code>
</p>

<p>where <code class="reqn">\phi(x)</code> is the basis, <code class="reqn">\theta</code> is the coefficient vector,
<code class="reqn">\varepsilon</code> is an unseen noise vector. 
The parameter vector is of length 1 where 
<code>para</code> <code class="reqn">= \log(\sigma)</code>.  It is a faster (sometimes) version of
<code><a href="#topic+loglik_std">loglik_std</a></code>  but can only handle diagonal variational 
inference.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="loglik_gauss_+3A_om">om</code></td>
<td>
<p>an <code><a href="#topic+outermod">outermod</a></code> instance to be referred to</p>
</td></tr>
<tr><td><code id="loglik_gauss_+3A_terms">terms</code></td>
<td>
<p>a matrix of <code>terms</code>, must have as many columns as dims in 
<code>om</code></p>
</td></tr>
<tr><td><code id="loglik_gauss_+3A_y">y</code></td>
<td>
<p>a vector of observations</p>
</td></tr>
<tr><td><code id="loglik_gauss_+3A_x">x</code></td>
<td>
<p>a matrix of predictors, must have as many columns as dims in 
<code>om</code> and the same number of rows as <code>y</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>no returns, this is a class which contains methods
</p>


<h3>See Also</h3>

<p>base class: <code><a href="#topic+lpdf">lpdf</a></code>
</p>

<hr>
<h2 id='loglik_gda'>Gaussian errors with diagonal adjustment</h2><span id='topic+loglik_gda'></span><span id='topic+Rcpp_loglik_gda-class'></span><span id='topic+Rcpp_loglik_gda'></span>

<h3>Description</h3>

<pre>
loglik = new(loglik_gda, om, terms, y, x)
</pre>
<p>This is a standard model which has the form
</p>
<p style="text-align: center;"><code class="reqn">y = \langle \phi(x), \theta \rangle + \delta(x) + \varepsilon,
\delta(x) \sim N(0, \lambda g(x)), \varepsilon \sim N(0,\sigma^2)</code>
</p>

<p>where <code class="reqn">\phi(x)</code> is the basis, <code class="reqn">\theta</code> is the coefficient vector,
<code class="reqn">\delta(x)</code> is unseen vector corresponding to unmodeled 
variance <code class="reqn">\lambda g(x)</code>, <code class="reqn">\varepsilon</code> is an unseen noise vector.
The parameter vector is of length 2 where 
<code class="reqn">\sigma=</code> <code>exp(para[0])</code> and <code class="reqn">\lambda=</code><code>exp(2*para[1])</code>.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="loglik_gda_+3A_om">om</code></td>
<td>
<p>an <code><a href="#topic+outermod">outermod</a></code> instance to be referred to</p>
</td></tr>
<tr><td><code id="loglik_gda_+3A_terms">terms</code></td>
<td>
<p>a matrix of <code>terms</code>, must have as many columns as dims in 
<code>om</code></p>
</td></tr>
<tr><td><code id="loglik_gda_+3A_y">y</code></td>
<td>
<p>a vector of observations</p>
</td></tr>
<tr><td><code id="loglik_gda_+3A_x">x</code></td>
<td>
<p>a matrix of predictors, must have as many columns as dims in 
<code>om</code> and the same number of rows as <code>y</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>no returns, this is a class which contains methods
</p>


<h3>See Also</h3>

<p>base class: <code><a href="#topic+lpdf">lpdf</a></code>
</p>

<hr>
<h2 id='loglik_std'>Gaussian errors</h2><span id='topic+loglik_std'></span><span id='topic+Rcpp_loglik_std-class'></span><span id='topic+Rcpp_loglik_std'></span>

<h3>Description</h3>

<pre>
loglik = new(loglik_std, om, terms, y, x)
</pre>
<p>This is a standard model which has the form
</p>
<p style="text-align: center;"><code class="reqn">y = \langle \phi(x), \theta \rangle + \varepsilon, \varepsilon \sim 
N(0,\sigma^2)</code>
</p>

<p>where <code class="reqn">\phi(x)</code> is the basis, <code class="reqn">\theta</code> is the coefficient vector,
<code class="reqn">\varepsilon</code> is an unseen noise vector.
The parameter vector is of length 1 where 
<code>para</code> <code class="reqn">= \log(\sigma)</code>.  It is a slower (sometimes) 
version of <code><a href="#topic+loglik_gauss">loglik_gauss</a></code> but allows for complete marginal 
inference.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="loglik_std_+3A_om">om</code></td>
<td>
<p>an <code><a href="#topic+outermod">outermod</a></code> instance to be referred to</p>
</td></tr>
<tr><td><code id="loglik_std_+3A_terms">terms</code></td>
<td>
<p>a matrix of <code>terms</code>, must have as many columns as dims in 
<code>om</code></p>
</td></tr>
<tr><td><code id="loglik_std_+3A_y">y</code></td>
<td>
<p>a vector of observations</p>
</td></tr>
<tr><td><code id="loglik_std_+3A_x">x</code></td>
<td>
<p>a matrix of predictors, must have as many columns as dims in 
<code>om</code> and the same number of rows as <code>y</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>no returns, this is a class which contains methods
</p>


<h3>See Also</h3>

<p>base class: <code><a href="#topic+lpdf">lpdf</a></code>
</p>

<hr>
<h2 id='logpr_gauss'>Gaussian prior</h2><span id='topic+logpr_gauss'></span><span id='topic+Rcpp_logpr_gauss-class'></span><span id='topic+Rcpp_logpr_gauss'></span>

<h3>Description</h3>

<pre>
logpr = new(logpr_gauss, om, terms)
</pre>
<p>This is a standard model of coefficients which has them as drawn 
independently
from
</p>
<p style="text-align: center;"><code class="reqn"> \theta_i \sim N(0, \rho c_i)</code>
</p>

<p>where <code class="reqn">c_i</code> is the variance supplied by <code>om</code> for the <code class="reqn">i</code>th term. 
The parameter vector is of length 1 where 
<code class="reqn">\rho=</code> <code>exp(para[0])</code>.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="logpr_gauss_+3A_om">om</code></td>
<td>
<p>an <code><a href="#topic+outermod">outermod</a></code> instance to be referred to</p>
</td></tr>
<tr><td><code id="logpr_gauss_+3A_terms">terms</code></td>
<td>
<p>a matrix of <code>terms</code>, must have as many columns as dims in 
<code>om</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>no returns, this is a class which contains methods
</p>


<h3>See Also</h3>

<p>base class: <code><a href="#topic+lpdf">lpdf</a></code>
</p>

<hr>
<h2 id='lpdf'>Log probability density function class</h2><span id='topic+lpdf'></span><span id='topic+Rcpp_lpdf-class'></span><span id='topic+Rcpp_lpdf'></span>

<h3>Description</h3>

<p>This is a base class designed to handle the learning of 
the underlying coefficients, hyperparameters, and parameters associated with
a specific learning instance.  Polymorphism allows for the implied methods to 
be used across several similar classes.
</p>


<h3>Value</h3>

<p>no returns, this is a class which contains methods
</p>


<h3>Fields</h3>


<dl>
<dt><code>lpdf$val</code></dt><dd><p>current value</p>
</dd>
<dt><code>lpdf$para</code></dt><dd><p>current model parameters</p>
</dd>
<dt><code>lpdf$coeff</code></dt><dd><p>current coefficients</p>
</dd>
<dt><code>lpdf$compute_val</code></dt><dd><p>on calling <code>update</code>, compute value and store in 
<code>val</code></p>
</dd>
<dt><code>lpdf$grad</code></dt><dd><p>current gradient with respect to coefficients</p>
</dd>
<dt><code>lpdf$gradhyp</code></dt><dd><p>current gradient with respect to covariance hyperparameters</p>
</dd>
<dt><code>lpdf$gradpara</code></dt><dd><p>current gradient with respect to model parameters</p>
</dd>
<dt><code>lpdf$compute_grad</code></dt><dd><p>on calling <code>update</code>, compute gradient with 
respect to coefficients and store in <code>grad</code></p>
</dd>
<dt><code>lpdf$compute_gradhyp</code></dt><dd><p>on calling <code>update</code>, compute gradient
with respect to covariance hyperparameters and store in <code>gradhyp</code></p>
</dd>
<dt><code>lpdf$compute_gradpara</code></dt><dd><p>on calling <code>update</code>, compute gradient
with respect to model parameters and store in <code>gradpara</code></p>
</dd>
<dt><code>lpdf$update(coeff)</code></dt><dd><p>update using new coefficients</p>
</dd>
<dt><code><a href="#topic+lpdf+24optcg">lpdf$optcg</a>(tol,epoch)</code></dt><dd><p>do optimization with respect to coefficients 
via conjugate gradient</p>
</dd>
<dt><code><a href="#topic+lpdf+24optnewton">lpdf$optnewton</a>()</code></dt><dd><p>do optimization via matrix inversion, one Newton 
step</p>
</dd>
<dt><code>lpdf$updateom()</code></dt><dd><p>update based on recent version of <code><a href="#topic+outermod">outermod</a></code></p>
</dd>
<dt><code>lpdf$updatepara(para)</code></dt><dd><p>update using new model parameters</p>
</dd>
<dt><code>lpdf$updateterms(terms)</code></dt><dd><p>update using new <code>terms</code></p>
</dd>
<dt><code>lpdf$hess()</code></dt><dd><p>returns the hessian with respect 
to coefficients</p>
</dd>
<dt><code>lpdf$hessgradhyp()</code></dt><dd><p>returns gradient of <code>hess()</code> with respect to 
covariance hyperparameters</p>
</dd>
<dt><code>lpdf$hessgradpara()</code></dt><dd><p>returns the gradient of <code>hess()</code> with respect to 
model parameters</p>
</dd>
<dt><code>lpdf$diaghess()</code></dt><dd><p>returns the diagonal of the hessian with 
respect to coefficients</p>
</dd>
<dt><code>lpdf$diaghessgradhyp()</code></dt><dd><p>returns the gradient of <code>diaghess()</code> with 
respect to  covariance hyperparameters</p>
</dd>
<dt><code>lpdf$diaghessgradpara()</code></dt><dd><p>returns the gradient of <code>diaghess()</code> with 
respect to model parameters</p>
</dd>
<dt><code>lpdf$paralpdf(para)</code></dt><dd><p>compute the log-prior on the parameters, useful for 
fitting</p>
</dd>
<dt><code>lpdf$paralpdf_grad(para)</code></dt><dd><p>gradient of <code>paralpdf(para)</code></p>
</dd>
</dl>


<h3>See Also</h3>

<p>container class: <code><a href="#topic+lpdfvec">lpdfvec</a></code>
</p>
<p>derived classes: <code><a href="#topic+loglik_std">loglik_std</a></code>, 
<code><a href="#topic+loglik_gauss">loglik_gauss</a></code>, <code><a href="#topic+loglik_gda">loglik_gda</a></code>, 
<code><a href="#topic+logpr_gauss">logpr_gauss</a></code>
</p>

<hr>
<h2 id='lpdf+24optcg'>Optimization via Conjugate Gradient</h2><span id='topic+lpdf+24optcg'></span>

<h3>Description</h3>

<pre>
lpdf$optcg(tol,epoch)
</pre>
<p>This optimizes the coefficient vector <code>coeff</code> using conjugate gradient. 
It currently is designed only for quadratic <code><a href="#topic+lpdf">lpdf</a></code> instances.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="lpdf+2B24optcg_+3A_tol">tol</code></td>
<td>
<p>A positive double representing tolerance, default is 
<code>0.001</code>.</p>
</td></tr>
<tr><td><code id="lpdf+2B24optcg_+3A_epoch">epoch</code></td>
<td>
<p>A positive integer representing the maximum number of steps 
conjugate gradient will take.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing is returned, the class instance is updated
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lpdf">lpdf</a></code>
</p>

<hr>
<h2 id='lpdf+24optnewton'>Optimization via Newton's Method</h2><span id='topic+lpdf+24optnewton'></span>

<h3>Description</h3>

<pre>
lpdf$optnewton()
</pre>
<p>This optimizes the coefficient vector <code>coeff</code> using Newton's Method.  
It currently is designed only for quadratic <code><a href="#topic+lpdf">lpdf</a></code> instances.  
It should take a single step.
</p>


<h3>Value</h3>

<p>nothing is returned, the class instance is updated
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lpdf">lpdf</a></code>
</p>

<hr>
<h2 id='lpdfvec'>Vector of <code>lpdf</code> instances</h2><span id='topic+lpdfvec'></span><span id='topic+Rcpp_lpdfvec-class'></span><span id='topic+Rcpp_lpdfvec'></span>

<h3>Description</h3>

<pre>
logpdf = new(lpdfvec, loglik, logpr)
</pre>
<p>This is a class where each instance contains two <code><a href="#topic+lpdf">lpdf</a></code> 
instances and can be 
manipulated as a single instance.  It presumes both are based on the same
<code><a href="#topic+outermod">outermod</a></code> instance, thus they share hyperparameters.  However
the model parameters are concatenated.  Currently also includes variations
on marginal adjustments.  
</p>
<p>Currently it is designed only for a pair, but the ordering is arbitrary.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="lpdfvec_+3A_loglik">loglik</code></td>
<td>
<p>one reference to a <code>lpdf</code> instance</p>
</td></tr>
<tr><td><code id="lpdfvec_+3A_logpr">logpr</code></td>
<td>
<p>another reference to a <code>lpdf</code> instance that shares 
<code><a href="#topic+outermod">outermod</a></code>  with <code>loglik</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>no returns, this is a class which contains methods
</p>


<h3>Fields</h3>


<dl>
<dt><code>lpdfvec$domarg</code></dt><dd><p>A boolean that controls if marginal adjustment is 
done</p>
</dd>
</dl>


<h3>See Also</h3>

<p>base class: <code><a href="#topic+lpdf">lpdf</a></code>
</p>

<hr>
<h2 id='obfit'>Outerbase model fit</h2><span id='topic+obfit'></span>

<h3>Description</h3>

<p>This function fits an outerbase model for prediction and hides most of the
actual object-oriented aspects of the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obfit(
  x,
  y,
  numb = 100,
  verbose = 0,
  covnames = NULL,
  hyp = NULL,
  numberopts = 2,
  nthreads = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obfit_+3A_x">x</code></td>
<td>
<p>a n by d sized matrix of inputs</p>
</td></tr>
<tr><td><code id="obfit_+3A_y">y</code></td>
<td>
<p>a n length vector of outputs</p>
</td></tr>
<tr><td><code id="obfit_+3A_numb">numb</code></td>
<td>
<p>size of basis to use</p>
</td></tr>
<tr><td><code id="obfit_+3A_verbose">verbose</code></td>
<td>
<p>0-3, how much information on optimization to print to console</p>
</td></tr>
<tr><td><code id="obfit_+3A_covnames">covnames</code></td>
<td>
<p>a d length vector of covariance names</p>
</td></tr>
<tr><td><code id="obfit_+3A_hyp">hyp</code></td>
<td>
<p>initial covariance hyperparameters</p>
</td></tr>
<tr><td><code id="obfit_+3A_numberopts">numberopts</code></td>
<td>
<p>number of optimizations done for hyperparameters, must be
larger than 1</p>
</td></tr>
<tr><td><code id="obfit_+3A_nthreads">nthreads</code></td>
<td>
<p>number of threads used in learning</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Saving important model information to be used with 
<code><a href="#topic+obpred">obpred</a></code>
</p>

<hr>
<h2 id='obpred'>Prediction from outerbase</h2><span id='topic+obpred'></span>

<h3>Description</h3>

<p>This function allows for turning an <code>obmodel</code> into predictions with 
mean and variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obpred(obmodel, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obpred_+3A_obmodel">obmodel</code></td>
<td>
<p>output from <code><a href="#topic+obfit">obfit</a></code></p>
</td></tr>
<tr><td><code id="obpred_+3A_x">x</code></td>
<td>
<p>a new m by d sized matrix of inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with <code>mean</code> and <code>var</code> at new x
</p>


<h3>See Also</h3>

<p>obfit
</p>

<hr>
<h2 id='obtest_borehole3d'>Three dim borehole example</h2><span id='topic+obtest_borehole3d'></span>

<h3>Description</h3>

<p>A three dimensional Borehole function used in illustrations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obtest_borehole3d(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obtest_borehole3d_+3A_x">x</code></td>
<td>
<p>a n by 3 vector of inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a length n vector of outputs
</p>

<hr>
<h2 id='obtest_borehole8d'>Eight dim borehole example</h2><span id='topic+obtest_borehole8d'></span>

<h3>Description</h3>

<p>An eight dimensional Borehole function used in illustrations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obtest_borehole8d(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obtest_borehole8d_+3A_x">x</code></td>
<td>
<p>a n by 8 vector of inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a length n vector of outputs
</p>

<hr>
<h2 id='outerbase'>Outer product-type basis</h2><span id='topic+outerbase'></span><span id='topic+Rcpp_outerbase-class'></span><span id='topic+Rcpp_outerbase'></span>

<h3>Description</h3>

<pre>
ob = new(outerbase, om, x)
</pre>
<p>Class that handles the basis for a given set of points 
<code>x</code>.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="outerbase_+3A_x">x</code></td>
<td>
<p>a matrix of predictors, must have as many columns as dims in 
<code>om</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>no returns, this is a class which contains methods
</p>


<h3>Fields</h3>


<dl>
<dt><code>nthreads</code></dt><dd><p>number of threads for <code>omp</code> to use</p>
</dd>
<dt><code><a href="#topic+outerbase+24getbase">outerbase$getbase</a>(k)</code></dt><dd><p>to get each dimensions basis 
functions</p>
</dd>
<dt><code><a href="#topic+outerbase+24getmat">outerbase$getmat</a>(terms)</code></dt><dd><p>to get the basis matrix at 
<code>terms</code></p>
</dd>
<dt><code><a href="#topic+outerbase+24build">outerbase$build</a>()</code></dt><dd><p>to (re)build the basis instance</p>
</dd>
<dt><code><a href="#topic+outerbase+24matmul">outerbase$matmul</a>(terms,a)</code></dt><dd><p>matrix multiply without 
building the basis matrix</p>
</dd>
<dt><code><a href="#topic+outerbase+24tmatmul">outerbase$tmatmul</a>(terms,a)</code></dt><dd><p>transpose matrix multiply 
without building the basis matrix</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+outermod">outermod</a></code> the core element that controls outerbase
</p>


<h3>Examples</h3>

<pre><code class='language-R'>om = new(outermod)
setcovfs(om, c("mat25", "mat25", "mat25"))
setknot(om,
         list(seq(0,1,by=0.025),seq(0,1,by=0.025),seq(0,1,by=0.025)))
x = matrix(runif(10*3),ncol=3)
ob = new(outerbase, om, x)
terms = om$selectterms(40)
basismat = ob$getmat(terms)
</code></pre>

<hr>
<h2 id='outerbase-package'>outerbase</h2><span id='topic+outerbase-package'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p>High-dimensional regression using outer product models. Research on the methods is currently under investigation and published resources will be posted as they are available. As the method is new, the website is the best resource for understanding the principals. Some of the core ideas are based on Plumlee and coauthors' work on analysis of grid-structured experiments described in Plumlee (2014) doi: <a href="https://doi.org/10.1080/01621459.2014.900250">10.1080/01621459.2014.900250</a> and Plumlee, Erickson, Ankenman, Lawrence (2021) doi: <a href="https://doi.org/10.1093/biomet/asaa084">10.1093/biomet/asaa084</a>. Some additional textbooks for additional information on Gaussian processes are Rasmussen and Williams (2005) doi: <a href="https://doi.org/10.7551/mitpress/3206.001.0001">10.7551/mitpress/3206.001.0001</a> and Gramacy (2022) doi: <a href="https://doi.org/10.1201/9780367815493">10.1201/9780367815493</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Matthew Plumlee <a href="mailto:mplumlee@northwestern.edu">mplumlee@northwestern.edu</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://mattplumlee.github.io/outerbase/">https://mattplumlee.github.io/outerbase/</a>
</p>
</li>
<li> <p><a href="https://github.com/MattPlumlee/outerbase/">https://github.com/MattPlumlee/outerbase/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/MattPlumlee/outerbase/issues">https://github.com/MattPlumlee/outerbase/issues</a>
</p>
</li></ul>


<hr>
<h2 id='outerbase+24build'>Builds the outerbase</h2><span id='topic+outerbase+24build'></span>

<h3>Description</h3>

<pre>
outerbase$build()
 </pre>
<p>Build (or re-build) a basis based on the recent evaluation 
of <code><a href="#topic+outermod">outermod</a></code>.
</p>


<h3>Value</h3>

<p>nothing is returned, the class instance is updated
</p>


<h3>See Also</h3>

<p><code><a href="#topic+outerbase">outerbase</a></code>
</p>

<hr>
<h2 id='outerbase+24getbase'>Get base functions</h2><span id='topic+outerbase+24getbase'></span>

<h3>Description</h3>

<pre>
basis_func = outerbase$getbase(k)
</pre>
<p>Returns the basis for dimension <code>k</code>.   Designed mostly for 
visualization.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="outerbase+2B24getbase_+3A_k">k</code></td>
<td>
<p>An integer from that corresponds to the dimension.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of evaluated basis functions
</p>


<h3>See Also</h3>

<p><code><a href="#topic+outerbase">outerbase</a></code>
</p>

<hr>
<h2 id='outerbase+24getmat'>Get basis matrix</h2><span id='topic+outerbase+24getmat'></span>

<h3>Description</h3>

<pre>
basismat = outerbase$getmat(terms)
 </pre>
<p>Returns the basis matrix for a given set of <code>terms</code>.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="outerbase+2B24getmat_+3A_terms">terms</code></td>
<td>
<p>a matrix of terms</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of evaluated basis functions based on 
<code>terms</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+outerbase">outerbase</a></code>
</p>

<hr>
<h2 id='outerbase+24matmul'>Matrix multiply</h2><span id='topic+outerbase+24matmul'></span>

<h3>Description</h3>

<pre>
 b = outerbase$matmul(terms, a)
</pre>
<p>Multiplies the basis times a vector without building the basis 
matrix.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="outerbase+2B24matmul_+3A_terms">terms</code></td>
<td>
<p>a matrix of <code>terms</code></p>
</td></tr>
<tr><td><code id="outerbase+2B24matmul_+3A_a">a</code></td>
<td>
<p>a vector of length the same as the rows in <code>terms</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector resulting from the matrix multiplication
</p>


<h3>See Also</h3>

<p><code><a href="#topic+outerbase">outerbase</a></code>
</p>

<hr>
<h2 id='outerbase+24tmatmul'>Transpose Matrix multiply</h2><span id='topic+outerbase+24tmatmul'></span>

<h3>Description</h3>

<pre>
  b = outerbase$tmatmul(terms, a)
</pre>
<p>Multiplies the transpose of the basis times a vector without 
building the basis matrix.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="outerbase+2B24tmatmul_+3A_terms">terms</code></td>
<td>
<p>a matrix of <code>terms</code></p>
</td></tr>
<tr><td><code id="outerbase+2B24tmatmul_+3A_a">a</code></td>
<td>
<p>a vector of length the same as the rows in <code>outerbase</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector resulting from the matrix multiplication
</p>


<h3>See Also</h3>

<p><code><a href="#topic+outerbase">outerbase</a></code>
</p>

<hr>
<h2 id='outermod'>Outer product-type model</h2><span id='topic+outermod'></span><span id='topic+Rcpp_outermod-class'></span><span id='topic+Rcpp_outermod'></span>

<h3>Description</h3>

<p>This is a class used to construct <code><a href="#topic+outerbase">outerbase</a></code>
class instances.  It stores key information for constructing a basis.
</p>


<h3>Value</h3>

<p>no returns, this is a class which contains methods
</p>


<h3>Fields</h3>


<dl>
<dt><code><a href="#topic+outermod+24updatehyp">outermod$updatehyp</a>(hyp)</code></dt><dd><p>update hyperparameters</p>
</dd>
<dt><code><a href="#topic+outermod+24selectterms">outermod$selectterms</a>(numterms)</code></dt><dd><p>find best <code>numterms</code> terms</p>
</dd>
<dt><code><a href="#topic+outermod+24getvar">outermod$getvar</a>(terms)</code></dt><dd><p>find variances of coefficients 
associated with  <code>terms</code></p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+outerbase">outerbase</a></code> the main product from an outermod
</p>
<p><code><a href="#topic+setcovfs">setcovfs</a></code>, <code><a href="#topic+setknot">setknot</a></code>, 
<code><a href="#topic+gethyp">gethyp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>om = new(outermod)
setcovfs(om, c("mat25", "mat25", "mat25"))
setknot(om,
         list(seq(0,1,by=0.01),seq(0,1,by=0.01),seq(0,1,by=0.01)))
terms = om$selectterms(40)
coeffvar =om$getvar(terms)
hyp = gethyp(om)
hyp[1:2] = 0.5
om$updatehyp(hyp)
coeffvar = om$getvar(terms)
</code></pre>

<hr>
<h2 id='outermod+24getvar'>Get variance of coefficients</h2><span id='topic+outermod+24getvar'></span>

<h3>Description</h3>

<pre>
coeffvar = outermod$getvar(terms)
</pre>
<p>Returns the variance of the coefficients associated with <code>terms</code>.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="outermod+2B24getvar_+3A_terms">terms</code></td>
<td>
<p>a matrix of <code>terms</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of variances of each coefficient
</p>


<h3>See Also</h3>

<p><code><a href="#topic+outermod">outermod</a></code>
</p>

<hr>
<h2 id='outermod+24selectterms'>Select optimal terms</h2><span id='topic+outermod+24selectterms'></span>

<h3>Description</h3>

<pre>
terms = om$selectterms(numterms)
</pre>
<p>Returns the best <code>numterms</code> given <code>outermod</code> currently using
maximum variance criteria.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="outermod+2B24selectterms_+3A_numterms">numterms</code></td>
<td>
<p>number of basis <code>terms</code> desired</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of <code>terms</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+outermod">outermod</a></code>
</p>

<hr>
<h2 id='outermod+24updatehyp'>Update hyperparameters</h2><span id='topic+outermod+24updatehyp'></span>

<h3>Description</h3>

<pre>
outermod$updatehyp(hyp)
</pre>
<p>Updates the hyperparameters for the instance of outermod.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="outermod+2B24updatehyp_+3A_hyp">hyp</code></td>
<td>
<p>A vector of hyperparameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>no value is returned, the class instance is updated
</p>


<h3>See Also</h3>

<p><code><a href="#topic+outermod">outermod</a></code>
</p>

<hr>
<h2 id='predictor'>prediction class</h2><span id='topic+predictor'></span><span id='topic+Rcpp_predictor-class'></span><span id='topic+Rcpp_predictor'></span>

<h3>Description</h3>

<pre>
pred = new(predictor, loglik)
</pre>
<p>This is a base class design to allow for coherent building of
predictions across multiple models.  Unlike many base classes in this 
package, it is meant to be directly used.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictor_+3A_loglik">loglik</code></td>
<td>
<p>An <code><a href="#topic+lpdf">lpdf</a></code> instance, specifically that starts with 
<code>loglik</code>, to build the predictor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>no returns, this is a class which contains methods
</p>


<h3>Fields</h3>


<dl>
<dt><code>predictor$update(x)</code></dt><dd><p>update the current input to <code>x</code> for prediction</p>
</dd>
<dt><code>predictor$mean()</code></dt><dd><p>return the vector of means for the prediction</p>
</dd>
<dt><code>predictor$var()</code></dt><dd><p>return the vector of variances for the prediction</p>
</dd>
<dt><code>predictor$setnthreads(k)</code></dt><dd><p>specifics <code>k</code> as the number of threads
to use</p>
</dd>
</dl>

<hr>
<h2 id='setcovfs'>Set covariance functions</h2><span id='topic+setcovfs'></span>

<h3>Description</h3>

<pre>
setcovfs(om, covnames)
</pre>
<p>Sets the covariance functions for an outermod class instance.
This is first thing one does when creating an outermod instance.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="setcovfs_+3A_om">om</code></td>
<td>
<p>an <code><a href="#topic+outermod">outermod</a></code> instance</p>
</td></tr>
<tr><td><code id="setcovfs_+3A_covnames">covnames</code></td>
<td>
<p>a vector of strings of the covariance functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>no value is returned, <code>om</code> is updated
</p>


<h3>See Also</h3>

<p><code><a href="#topic+outermod">outermod</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>om = new(outermod)
setcovfs(om, c("mat25", "mat25", "mat25"))
setcovfs(om, c("mat25", "mat25pow", "mat25", "mat25ang"))
</code></pre>

<hr>
<h2 id='setknot'>Set knot points</h2><span id='topic+setknot'></span>

<h3>Description</h3>

<pre>
setknot(om, knotslist)
</pre>
<p>Sets the knot points of <code>om</code> to <code>knotslist</code> to estimate the 
eigenfunctions and eigenvalues. It will naturally check if the knot points 
have the same dimension as the covariance functions.  It will also check if 
the knot points are within reasonable bounds for the covariance functions.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="setknot_+3A_om">om</code></td>
<td>
<p>an <code><a href="#topic+outermod">outermod</a></code> instance</p>
</td></tr>
<tr><td><code id="setknot_+3A_knotslist">knotslist</code></td>
<td>
<p>a list of one dimensional vectors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>no value is returned, <code>om</code> is updated
</p>


<h3>See Also</h3>

<p><code><a href="#topic+outermod">outermod</a></code>, <code><a href="#topic+setcovfs">setcovfs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>om = new(outermod)
setcovfs(om, c("mat25", "mat25", "mat25"))
knotslist = list(seq(0,1,by=0.01),seq(0,1,by=0.01),seq(0,1,by=0.01))
setknot(om, knotslist)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
