<!DOCTYPE html><html><head><title>Help for package shinyloadtest</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {shinyloadtest}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#load_runs'><p>Create Tidy Load Test Results</p></a></li>
<li><a href='#record_session'><p>Record a Session for Load Test</p></a></li>
<li><a href='#shinyloadtest_report'><p>Make shinyloadtest Report</p></a></li>
<li><a href='#slt_demo_data_1'><p>Example metrics for a 1-user load test</p></a></li>
<li><a href='#slt_demo_data_16'><p>Example metrics for a 16-user load test</p></a></li>
<li><a href='#slt_demo_data_4'><p>Example metrics for a 4-user load test</p></a></li>
<li><a href='#slt_plot'><p>Plotting outputs for shinyloadtest</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Load Test Shiny Applications</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Assesses the number of concurrent users 'shiny'
  applications are capable of supporting, and for directing application changes
  in order to support a higher number of users. Provides facilities for recording
  'shiny' application sessions, playing recorded sessions against a target
  server at load, and analyzing the resulting metrics.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://rstudio.github.io/shinyloadtest/">https://rstudio.github.io/shinyloadtest/</a>,
<a href="https://github.com/rstudio/shinyloadtest">https://github.com/rstudio/shinyloadtest</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rstudio/shinyloadtest/issues">https://github.com/rstudio/shinyloadtest/issues</a></td>
</tr>
<tr>
<td>Collate:</td>
<td>'enum.R' 'data.R' 'analysis.R' 'detect.R' 'auth.R'
'make_report.R' 'plotting.R' 'shiny-recorder.R' 'url.R'
'util.R' 'util-pipe.R'</td>
</tr>
<tr>
<td>Imports:</td>
<td>R6, curl, dplyr (&ge; 1.0.0), ggplot2, httpuv (&ge; 1.5.2),
jsonlite, magrittr, rlang (&ge; 0.1.2), scales, stringr, svglite,
vroom, websocket (&ge; 1.0.0), xml2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>getPass, glue, gtable, htmltools, lubridate, progress,
rmarkdown, testthat, spelling</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>pandoc (&gt;= 2.2) - http://pandoc.org</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-02-10 23:38:26 UTC; barret</td>
</tr>
<tr>
<td>Author:</td>
<td>Barret Schloerke <a href="https://orcid.org/0000-0001-9986-114X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Alan Dipert [aut],
  Barbara Borges [aut],
  RStudio [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Barret Schloerke &lt;barret@rstudio.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-02-11 14:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic++25+3E+25">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='load_runs'>Create Tidy Load Test Results</h2><span id='topic+load_runs'></span>

<h3>Description</h3>

<p>The <code>shinycannon</code> tool creates a directory of log files for
each load test. This function translates one or more test result
directories into a tidy data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_runs(..., verbose = vroom::vroom_progress())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="load_runs_+3A_...">...</code></td>
<td>
<p>Key-value pairs where the key is the desired name for the test and the
value is a path to the test result directory.</p>
</td></tr>
<tr><td><code id="load_runs_+3A_verbose">verbose</code></td>
<td>
<p>Whether or not to print progress for reading loadtest directories</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tidy data frame with the test result data. Each row is an event. Columns include identifiers and timing information for the event. The variables are as follows
</p>

<dl>
<dt>run</dt><dd><p>Name of the run</p>
</dd>
<dt>session_id</dt><dd><p>simulated session identifier, 0-based</p>
</dd>
<dt>user_id</dt><dd><p>simulated user identifier, 0-based</p>
</dd>
<dt>iteration</dt><dd><p>user session identifier, 0-based</p>
</dd>
<dt>input_line_number</dt><dd><p>recording line number associated with event</p>
</dd>
<dt>event</dt><dd><p>type of the event</p>
</dd>
<dt>start</dt><dd><p>time the event started, in seconds, relative to the time at which all simulated users were running.</p>
</dd>
<dt>end</dt><dd><p>time the event ended, in seconds, relative to the time at which all simulated users were running</p>
</dd>
<dt>time</dt><dd><p>event duration, in seconds</p>
</dd>
<dt>concurrency</dt><dd><p>number of events that happened at the same time as this one</p>
</dd>
<dt>maintenance</dt><dd><p>whether this event occurred before or after all simulated users were running</p>
</dd>
<dt>label</dt><dd><p>event-specific text label</p>
</dd>
<dt>json</dt><dd><p>raw message JSON and parsed JSON of the event</p>
</dd>
</dl>



<h3>Output variables</h3>


<ul>
<li> <p><code>run</code>: The name of the recording session.
</p>
</li>
<li> <p><code>session_id</code>: An incrementing integer value for every session within
a <code>run</code>. Starts at 0.
</p>
</li>
<li> <p><code>user_id</code>: Which simulated user is performing the work within a <code>run</code>.
Starts at 0.
</p>
</li>
<li> <p><code>iteration</code>: an incrementing integer value of the session iteration
for the #' matching <code>user_id</code>. Starts at 0.
</p>
</li>
<li> <p><code>input_line_number</code>: The line number corresponding to the event in the
<code>recording.log</code> file.
</p>
</li>
<li> <p><code>event</code>: the web event being performed. One of the following values:
</p>

<ul>
<li> <p><code>REQ_HOME</code>: initial request for to load the homepage
</p>
</li>
<li> <p><code>REQ_GET</code>: Request a supporting file (JavaScript / CSS)
</p>
</li>
<li> <p><code>REQ_TOK</code>: Request a Shiny token
</p>
</li>
<li> <p><code>REQ_SINF</code>: Request SockJS information
</p>
</li>
<li> <p><code>REQ_POST</code>: Perform a POST query, such as uploading part of a file
</p>
</li>
<li> <p><code>WS_RECV_BEGIN_UPLOAD</code>: A file upload is being requested
</p>
</li>
<li> <p><code>WS_OPEN</code>: Open a new SockJS connection
</p>
</li>
<li> <p><code>WS_RECV_INIT</code>: Initialize a new SockJS
</p>
</li>
<li> <p><code>WS_SEND</code>: Send information from the Shiny server to the browser
</p>
</li>
<li> <p><code>WS_RECV</code>: Send information from the browser to the Shiny server
</p>
</li>
<li> <p><code>WS_CLOSE</code>: Close the SockJS connection
</p>
</li></ul>

</li>
<li> <p><code>start</code>: Start time of the event relative to the beginning of the <code>run</code>'s
maintenance period
</p>
</li>
<li> <p><code>end</code>: End time of the event relative to the beginning of the <code>run</code>'s
maintenance period
</p>
</li>
<li> <p><code>time</code>: Total elapsed time of the event
</p>
</li>
<li> <p><code>concurrency</code>: A number of events that are being processed concurrently
</p>
</li>
<li> <p><code>maintenance</code>: A boolean determining whether or not all simulated users
are executing a session
</p>
</li>
<li> <p><code>label</code>: A human readable event name
</p>
</li>
<li> <p><code>json</code>: The parsed JSON provided in the <code>recording.log</code> file. If the field
<code>message</code> exists, a <code>message_parsed</code> field is added containing a parsed
form of the SockJS's JSON message content.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  load_runs(
     `1 core` = 'results/run-1/',
     `2 cores` = 'results/run-2/'
  )

## End(Not run)
</code></pre>

<hr>
<h2 id='record_session'>Record a Session for Load Test</h2><span id='topic+record_session'></span>

<h3>Description</h3>

<p>This function creates a <a href="https://en.wikipedia.org/wiki/Reverse_proxy">reverse proxy</a> at <code style="white-space: pre;">&#8288;http://host:port&#8288;</code>
(http://127.0.0.1:8600 by default) that intercepts and records activity
between your web browser and the Shiny application at <code>target_app_url</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>record_session(
  target_app_url,
  host = "127.0.0.1",
  port = 8600,
  output_file = "recording.log",
  open_browser = TRUE,
  connect_api_key = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="record_session_+3A_target_app_url">target_app_url</code></td>
<td>
<p>The URL of the deployed application.</p>
</td></tr>
<tr><td><code id="record_session_+3A_host">host</code></td>
<td>
<p>The host where the proxy will run. Usually localhost is used.</p>
</td></tr>
<tr><td><code id="record_session_+3A_port">port</code></td>
<td>
<p>The port for the reverse proxy. Default is 8600. Change this
default if port 8600 is used by another service.</p>
</td></tr>
<tr><td><code id="record_session_+3A_output_file">output_file</code></td>
<td>
<p>The name of the generated recording file.</p>
</td></tr>
<tr><td><code id="record_session_+3A_open_browser">open_browser</code></td>
<td>
<p>Whether to open a browser on the proxy (default=<code>TRUE</code>)
or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="record_session_+3A_connect_api_key">connect_api_key</code></td>
<td>
<p>An RStudio Connect api key. It may be useful to use
<code>Sys.getenv("CONNECT_API_KEY")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, after creating the reverse proxy, a web browser is opened
automatically. As you interact with the application in the web browser,
activity is written to the <code>output_file</code> (<code>recording.log</code> by default).
</p>
<p>To shut down the reverse proxy and complete the recording, close the web
browser tab or window.
</p>
<p>Recordings are used as input to the <code>shinycannon</code> command-line
load-generation tool which can be obtained from the <a href="https://rstudio.github.io/shinyloadtest/index.html">shinyloadtest documentation site</a>.
</p>


<h3>Value</h3>

<p>Creates a recording file that can be used as input to the
<code>shinycannon</code> command-line load generation tool.
</p>


<h3><code>fileInput</code>/<code>DT</code>/<code style="white-space: pre;">&#8288;HTTP POST&#8288;</code> support</h3>

<p>Shiny's <code>shiny::fileInput()</code> input for uploading files, the <code>DT</code> package,
and potentially other packages make HTTP POST requests to the target
application. Because POST requests can be large, they are not stored
directly in the recording file. Instead, new files adjacent to the
recording are created for each HTTP POST request intercepted.
</p>
<p>The adjacent files are named after the recording with the pattern
<code style="white-space: pre;">&#8288;&lt;output_file&gt;.post.&lt;N&gt;&#8288;</code>, where <code style="white-space: pre;">&#8288;&lt;output_file&gt;&#8288;</code> is the chosen recording
file name and <code style="white-space: pre;">&#8288;&lt;N&gt;&#8288;</code> is the number of the request.
</p>
<p>If present, these adjacent files must be kept alongside the recording file
when the recording is played back with the <code>shinycannon</code> tool.
</p>


<h3>See Also</h3>

<p><a href="https://rstudio.github.io/shinyloadtest/"><code>shinyloadtest</code> articles</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  record_session("https://example.com/your-shiny-app/")

## End(Not run)
</code></pre>

<hr>
<h2 id='shinyloadtest_report'>Make shinyloadtest Report</h2><span id='topic+shinyloadtest_report'></span>

<h3>Description</h3>

<p>Make shinyloadtest Report
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shinyloadtest_report(
  df,
  output = "shinyloadtest_report.html",
  duration_cutoff = c(attr(df, "recording_duration"), 60)[1],
  http_latency_cutoff = 5,
  max_websocket_cutoff = 20,
  open_browser = TRUE,
  self_contained = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shinyloadtest_report_+3A_df">df</code></td>
<td>
<p>data.frame returned from <code><a href="#topic+load_runs">load_runs()</a></code></p>
</td></tr>
<tr><td><code id="shinyloadtest_report_+3A_output">output</code></td>
<td>
<p>File where HTML output should be saved</p>
</td></tr>
<tr><td><code id="shinyloadtest_report_+3A_duration_cutoff">duration_cutoff</code></td>
<td>
<p>Cutoff value for session duration plot. Defaults to the recording duration used to simulate <code>df</code> or 60 seconds.</p>
</td></tr>
<tr><td><code id="shinyloadtest_report_+3A_http_latency_cutoff">http_latency_cutoff</code></td>
<td>
<p>Cutoff value for total http latency plot</p>
</td></tr>
<tr><td><code id="shinyloadtest_report_+3A_max_websocket_cutoff">max_websocket_cutoff</code></td>
<td>
<p>Cutoff value for max websocket latency plot</p>
</td></tr>
<tr><td><code id="shinyloadtest_report_+3A_open_browser">open_browser</code></td>
<td>
<p>Whether to open the created output in the browser</p>
</td></tr>
<tr><td><code id="shinyloadtest_report_+3A_self_contained">self_contained</code></td>
<td>
<p>Boolean that determines if the final output should be a self contained html file</p>
</td></tr>
<tr><td><code id="shinyloadtest_report_+3A_verbose">verbose</code></td>
<td>
<p>Boolean that determines if progress output is displayed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The path to the report, invisibly
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  shinyloadtest_report(slt_demo_data_1)

## End(Not run)
</code></pre>

<hr>
<h2 id='slt_demo_data_1'>Example metrics for a 1-user load test</h2><span id='topic+slt_demo_data_1'></span>

<h3>Description</h3>

<p>An example dataset like that returned by <code><a href="#topic+load_runs">load_runs</a></code>, but without the <code>json</code> variable for portability. Contains latency data for 1813 <code>shinycannon</code> events suitable for passing to <code><a href="#topic+shinyloadtest_report">shinyloadtest_report</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slt_demo_data_1
</code></pre>


<h3>Format</h3>

<p>A data frame with 1813 rows and 12 variables:
</p>

<dl>
<dt>run</dt><dd><p>Name of the run</p>
</dd>
<dt>session_id</dt><dd><p>simulated session identifier, 0-based</p>
</dd>
<dt>user_id</dt><dd><p>simulated user identifier, 0-based</p>
</dd>
<dt>iteration</dt><dd><p>user session identifier, 0-based</p>
</dd>
<dt>input_line_number</dt><dd><p>recording line number associated with event</p>
</dd>
<dt>event</dt><dd><p>type of the event</p>
</dd>
<dt>start</dt><dd><p>time the event started, in seconds, relative to the time at which all simulated users were running.</p>
</dd>
<dt>end</dt><dd><p>time the event ended, in seconds, relative to the time at which all simulated users were running</p>
</dd>
<dt>time</dt><dd><p>event duration, in seconds</p>
</dd>
<dt>concurrency</dt><dd><p>number of events that happened at the same time as this one</p>
</dd>
<dt>maintenance</dt><dd><p>whether this event occurred before or after all simulated users were running</p>
</dd>
<dt>label</dt><dd><p>event-specific text label</p>
</dd>
</dl>


<hr>
<h2 id='slt_demo_data_16'>Example metrics for a 16-user load test</h2><span id='topic+slt_demo_data_16'></span>

<h3>Description</h3>

<p>An example dataset like that returned by <code><a href="#topic+load_runs">load_runs</a></code>, but without the <code>json</code> variable for portability. Contains latency data for 5402 <code>shinycannon</code> events suitable for passing to <code><a href="#topic+shinyloadtest_report">shinyloadtest_report</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slt_demo_data_16
</code></pre>


<h3>Format</h3>

<p>A data frame with 5402 rows and 12 variables:
</p>

<dl>
<dt>run</dt><dd><p>Name of the run</p>
</dd>
<dt>session_id</dt><dd><p>simulated session identifier, 0-based</p>
</dd>
<dt>user_id</dt><dd><p>simulated user identifier, 0-based</p>
</dd>
<dt>iteration</dt><dd><p>user session identifier, 0-based</p>
</dd>
<dt>input_line_number</dt><dd><p>recording line number associated with event</p>
</dd>
<dt>event</dt><dd><p>type of the event</p>
</dd>
<dt>start</dt><dd><p>time the event started, in seconds, relative to the time at which all simulated users were running.</p>
</dd>
<dt>end</dt><dd><p>time the event ended, in seconds, relative to the time at which all simulated users were running</p>
</dd>
<dt>time</dt><dd><p>event duration, in seconds</p>
</dd>
<dt>concurrency</dt><dd><p>number of events that happened at the same time as this one</p>
</dd>
<dt>maintenance</dt><dd><p>whether this event occurred before or after all simulated users were running</p>
</dd>
<dt>label</dt><dd><p>event-specific text label</p>
</dd>
</dl>


<hr>
<h2 id='slt_demo_data_4'>Example metrics for a 4-user load test</h2><span id='topic+slt_demo_data_4'></span>

<h3>Description</h3>

<p>An example dataset like that returned by <code><a href="#topic+load_runs">load_runs</a></code>, but without the <code>json</code> variable for portability. Contains latency data for 4514 <code>shinycannon</code> events suitable for passing to <code><a href="#topic+shinyloadtest_report">shinyloadtest_report</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slt_demo_data_4
</code></pre>


<h3>Format</h3>

<p>A data frame with 4514 rows and 12 variables:
</p>

<dl>
<dt>run</dt><dd><p>Name of the run</p>
</dd>
<dt>session_id</dt><dd><p>simulated session identifier, 0-based</p>
</dd>
<dt>user_id</dt><dd><p>simulated user identifier, 0-based</p>
</dd>
<dt>iteration</dt><dd><p>user session identifier, 0-based</p>
</dd>
<dt>input_line_number</dt><dd><p>recording line number associated with event</p>
</dd>
<dt>event</dt><dd><p>type of the event</p>
</dd>
<dt>start</dt><dd><p>time the event started, in seconds, relative to the time at which all simulated users were running.</p>
</dd>
<dt>end</dt><dd><p>time the event ended, in seconds, relative to the time at which all simulated users were running</p>
</dd>
<dt>time</dt><dd><p>event duration, in seconds</p>
</dd>
<dt>concurrency</dt><dd><p>number of events that happened at the same time as this one</p>
</dd>
<dt>maintenance</dt><dd><p>whether this event occurred before or after all simulated users were running</p>
</dd>
<dt>label</dt><dd><p>event-specific text label</p>
</dd>
</dl>


<hr>
<h2 id='slt_plot'>Plotting outputs for shinyloadtest</h2><span id='topic+slt_plot'></span><span id='topic+slt_time_boxplot'></span><span id='topic+slt_time_concurrency'></span><span id='topic+slt_waterfall'></span><span id='topic+slt_hist_loadtimes'></span><span id='topic+slt_user'></span><span id='topic+slt_session'></span><span id='topic+slt_session_duration'></span><span id='topic+slt_session_latency'></span><span id='topic+slt_http_latency'></span><span id='topic+slt_websocket_latency'></span>

<h3>Description</h3>

<p>Many different plotting routines to display different loadtest information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slt_time_boxplot(df, labels = NULL)

slt_time_concurrency(df, labels = NULL)

slt_waterfall(df, limits = NULL)

slt_hist_loadtimes(df, max_load_time = 5)

slt_user(df)

slt_session(df)

slt_session_duration(df, cutoff = NULL)

slt_session_latency(df)

slt_http_latency(df, cutoff = 5)

slt_websocket_latency(df, cutoff = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slt_plot_+3A_df">df</code></td>
<td>
<p>data frame returned from <code><a href="#topic+load_runs">load_runs</a></code></p>
</td></tr>
<tr><td><code id="slt_plot_+3A_labels">labels</code></td>
<td>
<p>A vector of labels to include.  If none are supplied, all labels will be used.</p>
</td></tr>
<tr><td><code id="slt_plot_+3A_limits">limits</code></td>
<td>
<p>passed into <code><a href="ggplot2.html#topic+scale_colour_gradientn">scale_colour_gradientn</a></code></p>
</td></tr>
<tr><td><code id="slt_plot_+3A_max_load_time">max_load_time</code></td>
<td>
<p>The amount of time users will wait for the page to load
when first requesting the app.</p>
</td></tr>
<tr><td><code id="slt_plot_+3A_cutoff">cutoff</code></td>
<td>
<p>Where to draw a horizontal or vertical line to display a reasonable cutoff line for requests.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> plot object
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>slt_time_boxplot</code>: Box plot of load times for each event in each run
</p>
</li>
<li> <p><code>slt_time_concurrency</code>: Time on concurrency for each event for each run
</p>
</li>
<li> <p><code>slt_waterfall</code>: Event waterfall for each session within each run
</p>
</li>
<li> <p><code>slt_hist_loadtimes</code>: Histogram of page load times
</p>
</li>
<li> <p><code>slt_user</code>: Gantt chart of event duration for each user within each run
</p>
</li>
<li> <p><code>slt_session</code>: Event gantt chart of each user session within each run
</p>
</li>
<li> <p><code>slt_session_duration</code>: Event gantt chart of fastest to slowest session times within each run
</p>
</li>
<li> <p><code>slt_session_latency</code>: Stacked bar chart of event duration for each session within each run
</p>
</li>
<li> <p><code>slt_http_latency</code>: Bar chart of total HTTP latency for each session within each run
</p>
</li>
<li> <p><code>slt_websocket_latency</code>: Bar chart of maximum calculation (websocket) latency for each session within each run
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>slt_user(slt_demo_data_4)
slt_session(slt_demo_data_4)
slt_session_duration(slt_demo_data_4)

slt_waterfall(slt_demo_data_4)
slt_time_boxplot(slt_demo_data_4)
slt_time_concurrency(slt_demo_data_4)

slt_session_latency(slt_demo_data_4)
slt_http_latency(slt_demo_data_4)
slt_websocket_latency(slt_demo_data_4)
slt_hist_loadtimes(slt_demo_data_4)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
