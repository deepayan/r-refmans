<!DOCTYPE html><html><head><title>Help for package caRamel</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {caRamel}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#caRamel-package'><p>caRamel optimizer</p></a></li>
<li><a href='#boxes'><p>Box numbering for each points individual of the population</p></a></li>
<li><a href='#caRamel'><p>MAIN FUNCTION: multi-objective optimizer</p></a></li>
<li><a href='#Cextrap'><p>Extrapolation along orthogonal directions to the Pareto front in the space of the objectives</p></a></li>
<li><a href='#Cinterp'><p>Interpolation in simplexes of the objective space</p></a></li>
<li><a href='#Crecombination'><p>Recombination of the sets of parameters</p></a></li>
<li><a href='#Cusecovar'><p>New parameter vectors generation respecting a covariance structure</p></a></li>
<li><a href='#decrease_pop'><p>Decreasing of the population of parameters sets</p></a></li>
<li><a href='#Dimprove'><p>Determination of directions for improvement</p></a></li>
<li><a href='#dominate'><p>Successive Pareto fronts of a population</p></a></li>
<li><a href='#dominated'><p>Rows domination of a matrix by a vector</p></a></li>
<li><a href='#downsize'><p>Downsizing of a population to only one individual per box up to a given accuracy</p></a></li>
<li><a href='#matvcov'><p>Calculation of the variances-covariances matrix on the reference population</p></a></li>
<li><a href='#newXval'><p>Generation of a new population of parameter sets following the five rules of caRamel</p></a></li>
<li><a href='#pareto'><p>Indicates which rows are Pareto</p></a></li>
<li><a href='#plot_caramel'><p>Plotting of caRamel results</p></a></li>
<li><a href='#plot_pareto'><p>Plotting of a population of objectives and Pareto front</p></a></li>
<li><a href='#plot_population'><p>Plotting of a population of objectives</p></a></li>
<li><a href='#rselect'><p>Selection of n points</p></a></li>
<li><a href='#val2rank'><p>Converting the values of a vector into their rank</p></a></li>
<li><a href='#vol_splx'><p>Volume of a simplex</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Automatic Calibration by Evolutionary Multi Objective Algorithm</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-02-01</td>
</tr>
<tr>
<td>Author:</td>
<td>Nicolas Le Moine [aut],
  Celine Monteil [aut],
  Frederic Hendrickx [ctb],
  Fabrice Zaoui [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Fabrice Zaoui &lt;fabrice.zaoui@edf.fr&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>geometry, parallel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>markdown, rmarkdown, knitr, testthat</td>
</tr>
<tr>
<td>Description:</td>
<td>Multi-objective optimizer initially developed for the calibration of hydrological models.
     The algorithm is a hybrid of the MEAS algorithm (Efstratiadis and Koutsoyiannis (2005) &lt;<a href="https://doi.org/10.13140%2FRG.2.2.32963.81446">doi:10.13140/RG.2.2.32963.81446</a>&gt;) by using the directional search method based on the simplexes of the objective space
     and the epsilon-NGSA-II algorithm with the method of classification of the parameter vectors archiving management by epsilon-dominance (Reed and Devireddy &lt;<a href="https://doi.org/10.1142%2F9789812567796_0004">doi:10.1142/9789812567796_0004</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/fzao/caRamel">https://github.com/fzao/caRamel</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/fzao/caRamel/issues">https://github.com/fzao/caRamel/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-02-02 06:30:08 UTC; fabrice</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-02-25 09:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='caRamel-package'>caRamel optimizer</h2><span id='topic+caRamel-package'></span>

<h3>Description</h3>

<p>Automatic Calibration by Evolutionary Multi Objective Algorithm</p>


<h3>Details</h3>

<p><em>caRamel</em> is a package for multi-objective optimization of complex environmental models.
</p>
<p>The algorithm is a hybrid of the <em>MEAS</em> algorithm (Efstratiadis and Koutsoyiannis, 2005)
by using the directional search method based on the simplexes of the objective space 
and the <em>epsilon-NGSA-II</em> algorithm with the method of classification of the parameter vectors archiving management by epsilon-dominance
(Reed and Devireddy, 2004).
</p>
<p>The main function of the package is <em>caRamel()</em>.
</p>
<p>This function uses all the other functions of the package.
</p>
<p>An example of an hydrological optimization is available on the following presentation: <a href="https://www.researchgate.net/publication/341931417_Automatic_Calibration_by_Evolutionary_Multi_Objective_Algorithm_the_caRamel_R_package">useR! 2019</a>
</p>


<h3>Author(s)</h3>

<p>Fabrice Zaoui, Nicolas Le Moine, Celine Monteil (EDF R&amp;D - LNHE)</p>


<h3>References</h3>

<p>Efstratiadis, A. and Koutsoyiannis, D. (2005) <em>The multi-objective evolutionary annealing-simplex method and its application in calibration hydrological models</em>,
in EGU General Assembly 2005, Geophysical Research Abstracts, Vol. 7, Vienna, 04593, European Geophysical Union. doi:10.13140/ RG.2.2.32963.81446.
</p>
<p>Le Moine, N. (2009) <em>Description d’un algorithme génétique multi-objectif pour la calibration d’un modèle pluie-débit</em> (in French).
Post-Doctoral Status Rep. 2, UPMC/EDF, 13 pp.
</p>
<p>Reed, P. and Devireddy, D. (2004) <em>Groundwater monitoring design: a case study combining epsilon-dominance archiving and automatic parameterization for the NSGA-II</em>,
in Coello-Coello C, editor. Applications of multi-objective evolutionary algorithms, Advances in natural computation series,
vol. 1, pp. 79-100, World Scientific, New York. doi:10.1142/9789812567796_0004.
</p>

<hr>
<h2 id='boxes'>Box numbering for each points individual of the population</h2><span id='topic+boxes'></span>

<h3>Description</h3>

<p>This function returns a box number for each points individual of the population
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boxes(points, prec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boxes_+3A_points">points</code></td>
<td>
<p>: matrix of the objectives</p>
</td></tr>
<tr><td><code id="boxes_+3A_prec">prec</code></td>
<td>
<p>: (double, length = nobj) desired accuracy for the objectives (edges of the boxes)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of numbers for the boxes. boxes[i] gives the number of the box containing points[i].
</p>


<h3>Author(s)</h3>

<p>Fabrice Zaoui
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Definition of the parameters
points &lt;- matrix(rexp(200), 100, 2)
prec &lt;- c(1.e-3, 1.e-3)
# Call the function
res &lt;- boxes(points, prec)

</code></pre>

<hr>
<h2 id='caRamel'>MAIN FUNCTION: multi-objective optimizer</h2><span id='topic+caRamel'></span>

<h3>Description</h3>

<p>Multi-objective optimizer. It requires to define a multi-objective function (func) to calibrate the model and bounds on the parameters to optimize.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>caRamel(
  nobj,
  nvar,
  minmax,
  bounds,
  func,
  popsize,
  archsize,
  maxrun,
  prec,
  repart_gene = c(5, 5, 5, 5),
  gpp = NULL,
  blocks = NULL,
  pop = NULL,
  funcinit = NULL,
  objnames = NULL,
  listsave = NULL,
  write_gen = FALSE,
  carallel = 1,
  numcores = NULL,
  graph = TRUE,
  sensitivity = FALSE,
  verbose = TRUE,
  worklist = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="caRamel_+3A_nobj">nobj</code></td>
<td>
<p>: (integer, length = 1) the number of objectives to optimize (nobj &gt;= 2)</p>
</td></tr>
<tr><td><code id="caRamel_+3A_nvar">nvar</code></td>
<td>
<p>: (integer, length = 1) the number of variables</p>
</td></tr>
<tr><td><code id="caRamel_+3A_minmax">minmax</code></td>
<td>
<p>: (logical, length = nobj) the objective is either a minimization (FALSE value) or a maximization (TRUE value)</p>
</td></tr>
<tr><td><code id="caRamel_+3A_bounds">bounds</code></td>
<td>
<p>: (matrix, nrow = nvar, ncol = 2) lower and upper bounds for the variables</p>
</td></tr>
<tr><td><code id="caRamel_+3A_func">func</code></td>
<td>
<p>: (function) the objective function to optimize. Input argument is the number of parameter set (integer) in the x matrix. The function has to return a vector of at least 'nobj' values (Objectives 1 to nobj are used for optimization, values after nobj are recorded for information.).</p>
</td></tr>
<tr><td><code id="caRamel_+3A_popsize">popsize</code></td>
<td>
<p>: (integer, length = 1) the population size for the genetic algorithm</p>
</td></tr>
<tr><td><code id="caRamel_+3A_archsize">archsize</code></td>
<td>
<p>: (integer, length = 1) the size of the Pareto front</p>
</td></tr>
<tr><td><code id="caRamel_+3A_maxrun">maxrun</code></td>
<td>
<p>: (integer, length = 1) the max. number of simulations allowed</p>
</td></tr>
<tr><td><code id="caRamel_+3A_prec">prec</code></td>
<td>
<p>: (double, length = nobj) the desired accuracy for the optimization of the objectives</p>
</td></tr>
<tr><td><code id="caRamel_+3A_repart_gene">repart_gene</code></td>
<td>
<p>: (integer, length = 4) optional, number of new parameter sets for each rule and per generation</p>
</td></tr>
<tr><td><code id="caRamel_+3A_gpp">gpp</code></td>
<td>
<p>: (integer, length = 1) optional, calling frequency for the rule &quot;Fireworks&quot;</p>
</td></tr>
<tr><td><code id="caRamel_+3A_blocks">blocks</code></td>
<td>
<p>(optional): groups for parameters</p>
</td></tr>
<tr><td><code id="caRamel_+3A_pop">pop</code></td>
<td>
<p>: (matrix, nrow = nset, ncol = nvar or nvar+nobj ) optional, initial population (used to restart an optimization)</p>
</td></tr>
<tr><td><code id="caRamel_+3A_funcinit">funcinit</code></td>
<td>
<p>(function, optional): the initialization function applied on each node of cluster when parallel computation. The arguments are cl and numcores</p>
</td></tr>
<tr><td><code id="caRamel_+3A_objnames">objnames</code></td>
<td>
<p>(optional): names of the objectives</p>
</td></tr>
<tr><td><code id="caRamel_+3A_listsave">listsave</code></td>
<td>
<p>(optional): names of the listing files. Default: None (no output). If exists, fields to be defined: &quot;pmt&quot; (file of parameters on the Pareto Front), &quot;obj&quot; (file of corresponding objective values), &quot;evol&quot; (evolution of maximum objectives by generation). Optional field: &quot;totalpop&quot; (total population and corresponding objectives, useful to restart a computation)</p>
</td></tr>
<tr><td><code id="caRamel_+3A_write_gen">write_gen</code></td>
<td>
<p>: (logical, length = 1) optional, if TRUE, save files 'pmt' and 'obj' at each generation (FALSE by default)</p>
</td></tr>
<tr><td><code id="caRamel_+3A_carallel">carallel</code></td>
<td>
<p>: (integer, length = 1) optional, do parallel computations? (0: sequential, 1:parallel (default) , 2:user-defined choice)</p>
</td></tr>
<tr><td><code id="caRamel_+3A_numcores">numcores</code></td>
<td>
<p>: (integer, length = 1) optional, the number of cores for the parallel computations (all cores by default)</p>
</td></tr>
<tr><td><code id="caRamel_+3A_graph">graph</code></td>
<td>
<p>: (logical, length = 1) optional, plot graphical output at each generation (TRUE by default)</p>
</td></tr>
<tr><td><code id="caRamel_+3A_sensitivity">sensitivity</code></td>
<td>
<p>: (logical, length = 1) optional, compute the first order derivatives of the pareto front (FALSE by default)</p>
</td></tr>
<tr><td><code id="caRamel_+3A_verbose">verbose</code></td>
<td>
<p>: (logical, length = 1) optional, verbosity mode (TRUE by default)</p>
</td></tr>
<tr><td><code id="caRamel_+3A_worklist">worklist</code></td>
<td>
<p>: optional values to be transmitted to the user's function (not used)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The optimizer was originally written for Scilab by Nicolas Le Moine.
The algorithm is a hybrid of the MEAS algorithm (Efstratiadis and Koutsoyiannis (2005) &lt;doi:10.13140/RG.2.2.32963.81446&gt;) by using the directional search method based on the simplexes of the objective space
and the epsilon-NGSA-II algorithm with the method of classification of the parameter vectors archiving management by epsilon-dominance (Reed and Devireddy &lt;doi:10.1142/9789812567796_0004&gt;).
Reference : &quot;Multi-objective calibration by combination of stochastic and gradient-like parameter generation rules – the caRamel algorithm&quot;
Celine Monteil (EDF), Fabrice Zaoui (EDF), Nicolas Le Moine (UPMC) and Frederic Hendrickx (EDF)
June 2020 Hydrology and Earth System Sciences 24(6):3189-3209
DOI: 10.5194/hess-24-3189-2020
Documentation : &quot;Principe de l'optimiseur CaRaMEL et illustration au travers d'exemples de parametres dans le cadre de la modelisation hydrologique conceptuelle&quot;
Frederic Hendrickx (EDF) and Nicolas Le Moine (UPMC)
Report EDF H-P73-2014-09038-FR
</p>


<h3>Value</h3>

<p>List of seven elements:
</p>

<dl>
<dt>success</dt><dd><p>return value (logical, length = 1) : TRUE if successfull</p>
</dd>
<dt>parameters</dt><dd><p>Pareto front (matrix, nrow = archsize, ncol = nvar)</p>
</dd>
<dt>objectives</dt><dd><p>objectives of the Pareto front (matrix, nrow = archsize, ncol = nobj+nadditional)</p>
</dd>
<dt>derivatives</dt><dd><p>list of the Jacobian matrices of the Pareto front if the sensitivity parameter is TRUE or NA otherwise</p>
</dd>
<dt>save_crit</dt><dd><p>evolution of the optimal objectives</p>
</dd>
<dt>total_pop</dt><dd><p>total population (matrix, nrow = popsize+archsize, ncol = nvar+nobj+nadditional)</p>
</dd>
<dt>gpp</dt><dd><p>the calling period for the third generation rule (independent sampling with a priori parameters variance)</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Fabrice Zaoui - Celine Monteil
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Definition of the test function
viennet &lt;- function(i) {
  val1 &lt;- 0.5*(x[i,1]*x[i,1]+x[i,2]*x[i,2])+sin(x[i,1]*x[i,1]+x[i,2]*x[i,2])
  val2 &lt;- 15+(x[i,1]-x[i,2]+1)*(x[i,1]-x[i,2]+1)/27+(3*x[i,1]-2*x[i,2]+4)*(3*x[i,1]-2*x[i,2]+4)/8
  val3 &lt;- 1/(x[i,1]*x[i,1]+x[i,2]*x[i,2]+1) -1.1*exp(-(x[i,1]*x[i,1]+x[i,2]*x[i,2]))
  return(c(val1,val2,val3))
}
# Number of objectives
nobj &lt;- 3
# Number of variables
nvar &lt;- 2
# All the objectives are to be minimized
minmax &lt;- c(FALSE, FALSE, FALSE)
# Define the bound constraints
bounds &lt;- matrix(data = 1, nrow = nvar, ncol = 2)
bounds[, 1] &lt;- -3 * bounds[, 1]
bounds[, 2] &lt;- 3 * bounds[, 2]

# Caramel optimization
results &lt;-
  caRamel(nobj = nobj,
          nvar = nvar,
          minmax =  minmax,
          bounds = bounds,
          func = viennet,
          popsize = 100,
          archsize = 100,
          maxrun = 500,
          prec = matrix(1.e-3, nrow = 1, ncol = nobj),
          carallel = 0)

</code></pre>

<hr>
<h2 id='Cextrap'>Extrapolation along orthogonal directions to the Pareto front in the space of the objectives</h2><span id='topic+Cextrap'></span>

<h3>Description</h3>

<p>gives n new candidates by extrapolation along orthogonal directions to the Pareto front in the space of the objectives
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Cextrap(param, crit, directions, longu, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Cextrap_+3A_param">param</code></td>
<td>
<p>: matrix [ NPoints , NPar ] of already evaluated parameters</p>
</td></tr>
<tr><td><code id="Cextrap_+3A_crit">crit</code></td>
<td>
<p>: matrix [ Npoints , NObj ] of associated criteria</p>
</td></tr>
<tr><td><code id="Cextrap_+3A_directions">directions</code></td>
<td>
<p>: matrix [ NDir, 2 ] the starting and ending points of the candidate vectors</p>
</td></tr>
<tr><td><code id="Cextrap_+3A_longu">longu</code></td>
<td>
<p>: matrix [ NDir , 1 ] giving the length of each segment thus defined in the OBJ space (measure of the probability of exploring this direction)</p>
</td></tr>
<tr><td><code id="Cextrap_+3A_n">n</code></td>
<td>
<p>: number of new vectors to generate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>xnew : matrix [ n , NPar ] of new vectors
</p>
<p>pcrit : matrix [ n , NObj ] estimated positions of new sets in the goal space
</p>


<h3>Author(s)</h3>

<p>Fabrice Zaoui
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Definition of the parameters
param &lt;- matrix(rexp(100), 100, 1)
crit &lt;- matrix(rexp(200), 100, 2)
directions &lt;- matrix(c(1,3,2,7,13,40), nrow = 3, ncol = 2)
longu &lt;- runif(3)
n &lt;- 5
# Call the function
res &lt;- Cextrap(param, crit, directions, longu, n)

</code></pre>

<hr>
<h2 id='Cinterp'>Interpolation in simplexes of the objective space</h2><span id='topic+Cinterp'></span>

<h3>Description</h3>

<p>proposes n new candidates by interpolation in simplexes of the objective space
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Cinterp(param, crit, simplices, volume, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Cinterp_+3A_param">param</code></td>
<td>
<p>: matrix [ NPoints , NPar ] of already evaluated parameters</p>
</td></tr>
<tr><td><code id="Cinterp_+3A_crit">crit</code></td>
<td>
<p>: matrix [ Npoints , NObj ] of associated criteria</p>
</td></tr>
<tr><td><code id="Cinterp_+3A_simplices">simplices</code></td>
<td>
<p>: matrix [ NSimp , NObj+1 ] containing all or part of the triangulation of the space of the objectives</p>
</td></tr>
<tr><td><code id="Cinterp_+3A_volume">volume</code></td>
<td>
<p>: matrix [ NSimp , 1 ] giving the volume of each simplex (measure of the probability of interpolating in this simplex)</p>
</td></tr>
<tr><td><code id="Cinterp_+3A_n">n</code></td>
<td>
<p>: number of new vectors to generate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>xnew : matrix [ n , NPar ] of new vectors
</p>
<p>pcrit : matrix [ n , NObj ] estimated positions of new sets in the goal space
</p>


<h3>Author(s)</h3>

<p>Fabrice Zaoui
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Definition of the parameters
param &lt;- matrix(rexp(100), 100, 1)
crit &lt;- matrix(rexp(200), 100, 2)
simplices &lt;- matrix(c(15,2,1,15,22,1,18,15,2,17,13,14), nrow = 4, ncol = 3)
volume &lt;- runif(4)
n &lt;- 5
# Call the function
res &lt;- Cinterp(param, crit, simplices, volume, n)

</code></pre>

<hr>
<h2 id='Crecombination'>Recombination of the sets of parameters</h2><span id='topic+Crecombination'></span>

<h3>Description</h3>

<p>performs a recombination of the sets of parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Crecombination(param, blocks, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Crecombination_+3A_param">param</code></td>
<td>
<p>: matrix [ . , NPar ] of the population of parameters</p>
</td></tr>
<tr><td><code id="Crecombination_+3A_blocks">blocks</code></td>
<td>
<p>: list of integer vectors: list of variable blocks for recombination</p>
</td></tr>
<tr><td><code id="Crecombination_+3A_n">n</code></td>
<td>
<p>: number of new vectors to generate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>xnew : matrix [ n , NPar ] of new vectors
</p>


<h3>Author(s)</h3>

<p>Fabrice Zaoui
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Definition of the parameters
param &lt;- matrix(rexp(15), 15, 1)
blocks &lt;- NULL
n &lt;- 5
# Call the function
res &lt;- Crecombination(param, blocks, n)

</code></pre>

<hr>
<h2 id='Cusecovar'>New parameter vectors generation respecting a covariance structure</h2><span id='topic+Cusecovar'></span>

<h3>Description</h3>

<p>proposes new parameter vectors respecting a covariance structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Cusecovar(xref, amplif, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Cusecovar_+3A_xref">xref</code></td>
<td>
<p>: matrix [ . , NPar ] of the reference population whose covariance structure is to be used</p>
</td></tr>
<tr><td><code id="Cusecovar_+3A_amplif">amplif</code></td>
<td>
<p>: amplification factor of the standard deviation on each parameter</p>
</td></tr>
<tr><td><code id="Cusecovar_+3A_n">n</code></td>
<td>
<p>: number of new vectors to generate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>xnew : matrix [ n , NPar ] of new vectors
</p>


<h3>Author(s)</h3>

<p>Fabrice Zaoui
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Definition of the parameters
xref &lt;- matrix(rexp(35), 35, 1)
amplif &lt;- 2.
n &lt;- 5
# Call the function
res &lt;- Cusecovar(xref, amplif, n)

</code></pre>

<hr>
<h2 id='decrease_pop'>Decreasing of the population of parameters sets</h2><span id='topic+decrease_pop'></span>

<h3>Description</h3>

<p>decreases the population of parameters sets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decrease_pop(matobj, minmax, prec, archsize, popsize)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decrease_pop_+3A_matobj">matobj</code></td>
<td>
<p>: matrix of objectives, dimension (ngames, nobj)</p>
</td></tr>
<tr><td><code id="decrease_pop_+3A_minmax">minmax</code></td>
<td>
<p>: vector of booleans, of dimension nobj: TRUE if maximization of the objective, FALSE otherwise</p>
</td></tr>
<tr><td><code id="decrease_pop_+3A_prec">prec</code></td>
<td>
<p>: nobj dimension vector: accuracy</p>
</td></tr>
<tr><td><code id="decrease_pop_+3A_archsize">archsize</code></td>
<td>
<p>: integer: archive size</p>
</td></tr>
<tr><td><code id="decrease_pop_+3A_popsize">popsize</code></td>
<td>
<p>: integer: population size</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing two elements:
</p>

<dl>
<dt>ind_arch</dt><dd><p>indices of individuals in the updated Pareto front</p>
</dd>
<dt>ind_pop</dt><dd><p>indices of individuals in the updated population</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Fabrice Zaoui
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Definition of the parameters
matobj &lt;- matrix(rexp(200), 100, 2)
prec &lt;- c(1.e-3, 1.e-3)
archsize &lt;- 100
minmax &lt;- c(FALSE, FALSE)
popsize &lt;- 100
# Call the function
res &lt;- decrease_pop(matobj, minmax, prec, archsize, popsize)

</code></pre>

<hr>
<h2 id='Dimprove'>Determination of directions for improvement</h2><span id='topic+Dimprove'></span>

<h3>Description</h3>

<p>determines directions for improvement
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dimprove(o_splx, f_splx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dimprove_+3A_o_splx">o_splx</code></td>
<td>
<p>: matrix of objectives of simplexes (nrow = npoints, ncol = nobj)</p>
</td></tr>
<tr><td><code id="Dimprove_+3A_f_splx">f_splx</code></td>
<td>
<p>: vector (npoints) of associated Pareto numbers (1 = dominated)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of elements &quot;oriedge&quot;: oriented edges and &quot;ledge&quot;: length
</p>


<h3>Author(s)</h3>

<p>Fabrice Zaoui
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Definition of the parameters
o_splx &lt;- matrix(rexp(6), 3, 2)
f_splx &lt;- c(1,1,1)
# Call the function
res &lt;- Dimprove(o_splx, f_splx)

</code></pre>

<hr>
<h2 id='dominate'>Successive Pareto fronts of a population</h2><span id='topic+dominate'></span>

<h3>Description</h3>

<p>calculates the successive Pareto fronts of a population (classification &quot;onion peel&quot;), when objectives need to be maximized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dominate(matobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dominate_+3A_matobj">matobj</code></td>
<td>
<p>: matrix [ NInd , NObj ] of objectives</p>
</td></tr>
</table>


<h3>Value</h3>

<p>f : vector of dimension NInd of dominances
</p>


<h3>Author(s)</h3>

<p>Fabrice Zaoui
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Definition of the parameters
matobj &lt;- matrix(runif(200), 100, 2)
# Call the function
pareto_rank &lt;- dominate(matobj)

</code></pre>

<hr>
<h2 id='dominated'>Rows domination of a matrix by a vector</h2><span id='topic+dominated'></span>

<h3>Description</h3>

<p>indicates which rows of the matrix Y are dominated by the vector (row) x
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dominated(x, Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dominated_+3A_x">x</code></td>
<td>
<p>: row vecteur</p>
</td></tr>
<tr><td><code id="dominated_+3A_y">Y</code></td>
<td>
<p>: matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>D : vector of booleans
</p>


<h3>Author(s)</h3>

<p>Fabrice Zaoui
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Definition of the parameters
Y &lt;- matrix(rexp(200), 100, 2)
x &lt;- Y[1,]
# Call the function
res &lt;- dominated(x, Y)

</code></pre>

<hr>
<h2 id='downsize'>Downsizing of a population to only one individual per box up to a given accuracy</h2><span id='topic+downsize'></span>

<h3>Description</h3>

<p>reduces the number of individuals in a population to only one individual per box up to a given accuracy
</p>


<h3>Usage</h3>

<pre><code class='language-R'>downsize(points, Fo, prec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="downsize_+3A_points">points</code></td>
<td>
<p>: matrix of objectives</p>
</td></tr>
<tr><td><code id="downsize_+3A_fo">Fo</code></td>
<td>
<p>: rank on the front of each point (1: dominates on the Pareto)</p>
</td></tr>
<tr><td><code id="downsize_+3A_prec">prec</code></td>
<td>
<p>: (double, length = nobj) desired accuracy for sorting objectives</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector indices
</p>


<h3>Author(s)</h3>

<p>Fabrice Zaoui
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Definition of the parameters
points &lt;- matrix(rexp(200), 100, 2)
prec &lt;- c(1.e-3, 1.e-3)
Fo &lt;- sample(1:100, 100)
# Call the function
res &lt;- downsize(points, Fo, prec)

</code></pre>

<hr>
<h2 id='matvcov'>Calculation of the variances-covariances matrix on the reference population</h2><span id='topic+matvcov'></span>

<h3>Description</h3>

<p>calculates the variances-covariances matrix on the reference population
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matvcov(x, g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matvcov_+3A_x">x</code></td>
<td>
<p>: population</p>
</td></tr>
<tr><td><code id="matvcov_+3A_g">g</code></td>
<td>
<p>: center of reference population (in the parameter space)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rr : variances-covariances matrix on the reference population
</p>


<h3>Author(s)</h3>

<p>Fabrice Zaoui
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Definition of the parameters
x &lt;- matrix(rexp(30), 30, 1)
g &lt;- mean(x)
# Call the function
res &lt;- matvcov(x, g)

</code></pre>

<hr>
<h2 id='newXval'>Generation of a new population of parameter sets following the five rules of caRamel</h2><span id='topic+newXval'></span>

<h3>Description</h3>

<p>generates a new population of parameter sets following the five rules of caRamel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newXval(param, crit, isperf, sp, bounds, repart_gene, blocks, fireworks)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="newXval_+3A_param">param</code></td>
<td>
<p>: matrix [ Nvec , NPar ] of parameters of the current population</p>
</td></tr>
<tr><td><code id="newXval_+3A_crit">crit</code></td>
<td>
<p>: matrix [ Nvec , NObj ] of associated criteria</p>
</td></tr>
<tr><td><code id="newXval_+3A_isperf">isperf</code></td>
<td>
<p>: vector of Booleans of length NObj, TRUE if maximization of the objective, FALSE otherwise</p>
</td></tr>
<tr><td><code id="newXval_+3A_sp">sp</code></td>
<td>
<p>: variance a priori of the parameters</p>
</td></tr>
<tr><td><code id="newXval_+3A_bounds">bounds</code></td>
<td>
<p>: lower and upper bounds of parameters [ NPar , 2 ]</p>
</td></tr>
<tr><td><code id="newXval_+3A_repart_gene">repart_gene</code></td>
<td>
<p>: matrix of length 4 giving the number of games to be generated with each rule: 1 Interpolation in the simplexes of the front, 2 Extrapolation according to the directions of the edges &quot;orthogonal&quot; to the front, 3 Random draws with prescribed variance-covariance matrix, 4 Recombination by functional blocks</p>
</td></tr>
<tr><td><code id="newXval_+3A_blocks">blocks</code></td>
<td>
<p>: list of integer vectors containing function blocks of parameters</p>
</td></tr>
<tr><td><code id="newXval_+3A_fireworks">fireworks</code></td>
<td>
<p>: boolean, TRUE if one tests a random variation on each parameter and each maximum of O.F.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>xnew : matrix of new vectors [ sum(Repart_Gene) + eventually (nobj+1)*nvar if fireworks , NPar ]
</p>
<p>project_crit: assumed position of the new vectors in the criteria space: [ sum(Repart_Gene)+ eventually (nobj+1)*nvar if fireworks , NObj ];
</p>


<h3>Author(s)</h3>

<p>Fabrice Zaoui
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Definition of the parameters
param &lt;- matrix(rexp(100), 100, 1)
crit &lt;- matrix(rexp(200), 100, 2)
isperf &lt;- c(FALSE, FALSE)
bounds &lt;- matrix(data = 1, nrow = 1, ncol = 2)
bounds[, 1] &lt;- -5 * bounds[, 1]
bounds[, 2] &lt;- 10 * bounds[, 2]
sp &lt;- (bounds[, 2] - bounds[, 1]) / (2 * sqrt(3))
repart_gene &lt;- c(5, 5, 5, 5)
fireworks &lt;- TRUE
blocks &lt;- NULL
# Call the function
res &lt;- newXval(param, crit, isperf, sp, bounds, repart_gene, blocks, fireworks)

</code></pre>

<hr>
<h2 id='pareto'>Indicates which rows are Pareto</h2><span id='topic+pareto'></span>

<h3>Description</h3>

<p>indicates which rows of the X criterion matrix are Pareto, when objectives need to be maximized
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pareto(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pareto_+3A_x">X</code></td>
<td>
<p>: matrix of objectives [NInd * NObj]</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Ft : vector [NInd], TRUE when the set is on the Pareto front.
</p>


<h3>Author(s)</h3>

<p>Fabrice Zaoui
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Definition of the parameters
X &lt;- matrix(runif(200), 100, 2)
# Call the function
is_pareto &lt;- pareto(X)

</code></pre>

<hr>
<h2 id='plot_caramel'>Plotting of caRamel results</h2><span id='topic+plot_caramel'></span>

<h3>Description</h3>

<p>Plot graphs of the Pareto front and a graph of optimization evolution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_caramel(caramel_results, nobj = NULL, objnames = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_caramel_+3A_caramel_results">caramel_results</code></td>
<td>
<p>: list resulting from the caRamel() function, with fields $objectives and $save_crit</p>
</td></tr>
<tr><td><code id="plot_caramel_+3A_nobj">nobj</code></td>
<td>
<p>: number of objectives (optional)</p>
</td></tr>
<tr><td><code id="plot_caramel_+3A_objnames">objnames</code></td>
<td>
<p>: vector of objectives names (optional)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Definition of the test function
viennet &lt;- function(i) {
  val1 &lt;- 0.5*(x[i,1]*x[i,1]+x[i,2]*x[i,2])+sin(x[i,1]*x[i,1]+x[i,2]*x[i,2])
  val2 &lt;- 15+(x[i,1]-x[i,2]+1)*(x[i,1]-x[i,2]+1)/27+(3*x[i,1]-2*x[i,2]+4)*(3*x[i,1]-2*x[i,2]+4)/8
  val3 &lt;- 1/(x[i,1]*x[i,1]+x[i,2]*x[i,2]+1) -1.1*exp(-(x[i,1]*x[i,1]+x[i,2]*x[i,2]))
  return(c(val1,val2,val3))
}
nobj &lt;- 3 # Number of objectives
nvar &lt;- 2 # Number of variables
minmax &lt;- c(FALSE, FALSE, FALSE) # All the objectives are to be minimized
bounds &lt;- matrix(data = 1, nrow = nvar, ncol = 2) # Define the bound constraints
bounds[, 1] &lt;- -3 * bounds[, 1]
bounds[, 2] &lt;- 3 * bounds[, 2]

# Caramel optimization
results &lt;- caRamel(nobj, nvar, minmax, bounds, viennet, popsize = 100, archsize = 100,
          maxrun = 500, prec = matrix(1.e-3, nrow = 1, ncol = nobj), carallel = FALSE)

# Plot of results
plot_caramel(results)
</code></pre>

<hr>
<h2 id='plot_pareto'>Plotting of a population of objectives and Pareto front</h2><span id='topic+plot_pareto'></span>

<h3>Description</h3>

<p>Plots graphs the population regarding each couple of objectives and emphasizes the Pareto front
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_pareto(MatObj, nobj = NULL, objnames = NULL, maximized = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_pareto_+3A_matobj">MatObj</code></td>
<td>
<p>: matrix of the objectives [NInd, nobj]</p>
</td></tr>
<tr><td><code id="plot_pareto_+3A_nobj">nobj</code></td>
<td>
<p>: number of objectives (optional)</p>
</td></tr>
<tr><td><code id="plot_pareto_+3A_objnames">objnames</code></td>
<td>
<p>: vector, length nobj, of names of the objectives (optional)</p>
</td></tr>
<tr><td><code id="plot_pareto_+3A_maximized">maximized</code></td>
<td>
<p>: vector of logical, length nobj, TRUE if objective need to be maximized, FALSE if minimized</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Celine Monteil
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Definition of the population
Pop &lt;- matrix(runif(300), 100, 3)

# Definition of objectives to maximize (Obj1, Obj2) and to minimize (Obj3)
maximized &lt;- c(TRUE, TRUE, FALSE)

# Call the function
plot_pareto(MatObj = Pop, maximized = maximized)

</code></pre>

<hr>
<h2 id='plot_population'>Plotting of a population of objectives</h2><span id='topic+plot_population'></span>

<h3>Description</h3>

<p>Plot graphs the population regarding each couple of objectives
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_population(
  MatObj,
  nobj,
  ngen = NULL,
  nrun = NULL,
  objnames = NULL,
  MatEvol = NULL,
  popsize = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_population_+3A_matobj">MatObj</code></td>
<td>
<p>: matrix of the objectives [NInd, nobj]</p>
</td></tr>
<tr><td><code id="plot_population_+3A_nobj">nobj</code></td>
<td>
<p>: number of objectives</p>
</td></tr>
<tr><td><code id="plot_population_+3A_ngen">ngen</code></td>
<td>
<p>: number of generations (optional)</p>
</td></tr>
<tr><td><code id="plot_population_+3A_nrun">nrun</code></td>
<td>
<p>: number of model evaluations (optional)</p>
</td></tr>
<tr><td><code id="plot_population_+3A_objnames">objnames</code></td>
<td>
<p>: vector of objectives names (optional)</p>
</td></tr>
<tr><td><code id="plot_population_+3A_matevol">MatEvol</code></td>
<td>
<p>: matrix of the evolution of the optimal objectives (optional)</p>
</td></tr>
<tr><td><code id="plot_population_+3A_popsize">popsize</code></td>
<td>
<p>: integer, size of the initial population (optional)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Celine Monteil
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Definition of the population
Pop &lt;- matrix(runif(300), 100, 3)
# Call the function
plot_population(MatObj = Pop, nobj = 3, objnames = c("Obj1", "Obj2", "Obj3"))

</code></pre>

<hr>
<h2 id='rselect'>Selection of n points</h2><span id='topic+rselect'></span>

<h3>Description</h3>

<p>performs a selection of n points in facp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rselect(n, facp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rselect_+3A_n">n</code></td>
<td>
<p>: number of points to select</p>
</td></tr>
<tr><td><code id="rselect_+3A_facp">facp</code></td>
<td>
<p>: vector of initial points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ix : ranks of selected points (vector of dimension n)
</p>


<h3>Author(s)</h3>

<p>Fabrice Zaoui
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Definition of the parameters
n &lt;- 5
facp &lt;- runif(30)
# Call the function
res &lt;- rselect(n, facp)

</code></pre>

<hr>
<h2 id='val2rank'>Converting the values of a vector into their rank</h2><span id='topic+val2rank'></span>

<h3>Description</h3>

<p>converts the values of a vector into their rank
</p>


<h3>Usage</h3>

<pre><code class='language-R'>val2rank(X, opt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="val2rank_+3A_x">X</code></td>
<td>
<p>: vector to treat</p>
</td></tr>
<tr><td><code id="val2rank_+3A_opt">opt</code></td>
<td>
<p>: integer which gives the rule to follow in case of tied ranks (repeated values): if opt = 1, one returns the average rank, if opt = 2, one returns the corresponding rank in the series of the unique values, if opt = 3, return the max rank</p>
</td></tr>
</table>


<h3>Value</h3>

<p>R : rank vector
</p>


<h3>Author(s)</h3>

<p>Fabrice Zaoui
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Definition of the parameters
X &lt;- matrix(rexp(100), 100, 1)
opt &lt;- 3
# Call the function
res &lt;- val2rank(X, opt)

</code></pre>

<hr>
<h2 id='vol_splx'>Volume of a simplex</h2><span id='topic+vol_splx'></span>

<h3>Description</h3>

<p>calculates the volume of a simplex
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vol_splx(S)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vol_splx_+3A_s">S</code></td>
<td>
<p>: matrix (d+1) rows * d columns containing the coordinates in d-dim of d + 1 vertices of a simplex</p>
</td></tr>
</table>


<h3>Value</h3>

<p>V : simplex volume
</p>


<h3>Author(s)</h3>

<p>Fabrice Zaoui
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Definition of the parameters
S &lt;- matrix(rexp(6), 3, 2)
# Call the function
res &lt;- vol_splx(S)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
