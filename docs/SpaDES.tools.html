<!DOCTYPE html><html><head><title>Help for package SpaDES.tools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SpaDES.tools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#SpaDES.tools-package'><p>Categorized overview of the <code>SpaDES.tools</code> package</p></a></li>
<li><a href='#.findFactors'><p>Find factors</p></a></li>
<li><a href='#.matchedPointDirection'><p>Calculate matched point directions</p></a></li>
<li><a href='#.pkgEnv'><p>The <code>SpaDES.tools</code> package environment</p></a></li>
<li><a href='#.pointDistance'><p>Alternative point distance (and direction) calculations</p></a></li>
<li><a href='#adj'><p>Fast <code>adjacent</code> function, and Just In Time compiled version</p></a></li>
<li><a href='#agentLocation'><p><code>SELES</code> - Agent Location at initiation</p></a></li>
<li><a href='#cir'><p>Identify pixels in a circle or ring (doughnut) around an object.</p></a></li>
<li><a href='#cirSpecialQuick'><p>This is a very fast version of <code>cir</code> with <code>allowOverlap = TRUE</code>,</p>
<code>allowDuplicates = FALSE</code>, <code>returnIndices = TRUE</code>, <code>returnDistances = TRUE</code>, and
<code>includeBehavior = "excludePixels"</code>.
It is used inside <code>spread2</code>, when asymmetry is active.
The basic algorithm is to run <code>cir</code> just once, then add to the x,y coordinates of every locus.</a></li>
<li><a href='#directionFromEachPoint'><p>Calculate distances and directions between many points and many grid cells</p></a></li>
<li><a href='#distanceFromEachPoint'><p>Calculate distances and directions between many points and many grid cells</p></a></li>
<li><a href='#duplicatedInt'><p>Rcpp duplicated on integers using Rcpp Sugar</p></a></li>
<li><a href='#dwrpnorm2'><p>Vectorized wrapped normal density function</p></a></li>
<li><a href='#fastCrop'><p><code>fastCrop</code> is deprecated.</p></a></li>
<li><a href='#gaussMap'><p>Produce a <code>raster</code> of a random Gaussian process.</p></a></li>
<li><a href='#heading'><p>Heading between spatial points.</p></a></li>
<li><a href='#initiateAgents'><p><code>SELES</code> - Initiate agents</p></a></li>
<li><a href='#inRange'><p>Test whether a number lies within range <code style="white-space: pre;">&#8288;[a,b]&#8288;</code></p></a></li>
<li><a href='#mergeRaster'><p>Split and re-merge <code>RasterLayer</code>(s)</p></a></li>
<li><a href='#middlePixel'><p>Return the (approximate) middle pixel on a raster</p></a></li>
<li><a href='#move'><p>Move</p></a></li>
<li><a href='#neutralLandscapeMap'><p>Produce a neutral landscape using a midpoint displacement algorithm</p></a></li>
<li><a href='#numAgents'><p>SELES - Number of Agents to initiate</p></a></li>
<li><a href='#patchSize'><p>Patch size</p></a></li>
<li><a href='#probInit'><p><code>SELES</code> - Probability of Initiation</p></a></li>
<li><a href='#randomPolygons'><p>Produce a <code>SpatRaster</code> of  random polygons</p></a></li>
<li><a href='#randomStudyArea'><p>Create default study areas for use with <code>SpaDES</code> modules</p></a></li>
<li><a href='#rasterizeReduced'><p>Convert reduced representation to full raster</p></a></li>
<li><a href='#rbindlistDtDtpot'><p>Internal helpers</p></a></li>
<li><a href='#resample'><p>Adapted directly from the <code>base::sample()</code> help file.</p></a></li>
<li><a href='#rings'><p>Identifies all cells within a ring around the focal cells</p></a></li>
<li><a href='#runifC'><p>Rcpp Sugar version of runif</p></a></li>
<li><a href='#sampleV'><p>Resample</p></a></li>
<li><a href='#specificNumPerPatch'><p>Initiate a specific number of agents in a map of patches</p></a></li>
<li><a href='#spokes'><p>Identify outward radiating spokes from initial points</p></a></li>
<li><a href='#spread'><p>Simulate a spread process on a landscape.</p></a></li>
<li><a href='#spread2'><p>Simulate a contagious spread process on a landscape, with <code>data.table</code> internals</p></a></li>
<li><a href='#spread3'><p>An alternative spread function, conceived for insects</p></a></li>
<li><a href='#testEquivalentMetadata'><p>Test that metadata of 2 or more objects is the same</p></a></li>
<li><a href='#transitions'><p><code>SELES</code> - Transitioning to next time step</p></a></li>
<li><a href='#wrap'><p>Wrap coordinates or pixels in a torus-like fashion</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Additional Tools for Developing Spatially Explicit Discrete
Event Simulation (SpaDES) Models</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides GIS and map utilities, plus additional modeling tools for
    developing cellular automata, dynamic raster models, and agent based models
    in 'SpaDES'.
    Included are various methods for spatial spreading, spatial agents, GIS operations,
    random map generation, and others.
    See '?SpaDES.tools' for an categorized overview of these additional tools.
    The suggested package 'NLMR' can be installed from the following repository:
    (<a href="https://PredictiveEcology.r-universe.dev">https://PredictiveEcology.r-universe.dev</a>).</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://spades-tools.predictiveecology.org">https://spades-tools.predictiveecology.org</a>,
<a href="https://github.com/PredictiveEcology/SpaDES.tools">https://github.com/PredictiveEcology/SpaDES.tools</a></td>
</tr>
<tr>
<td>Date:</td>
<td>2024-05-14</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.7</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>backports, checkmate (&ge; 1.8.2), data.table (&ge; 1.10.4),
fpCompare (&ge; 0.2.1), graphics, methods, parallel, Rcpp (&ge;
0.12.12), reproducible (&ge; 2.0.9), stats, terra</td>
</tr>
<tr>
<td>Suggests:</td>
<td>animation, bit (&ge; 1.1-12), covr, DEoptim (&ge; 2.2-4), dqrng,
fastmatch, knitr, NLMR (&ge; 1.1.1), quickPlot (&ge; 1.0.2), raster
(&ge; 2.5-8), rmarkdown, sf, sp (&ge; 1.2-4), testthat (&ge; 3.0.0),
tools, withr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-CA</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://predictiveecology.r-universe.dev/">https://predictiveecology.r-universe.dev/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/PredictiveEcology/SpaDES.tools/issues">https://github.com/PredictiveEcology/SpaDES.tools/issues</a></td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>Collate:</td>
<td>'RcppExports.R' 'heading.R' 'SELES.R'
'distanceFromEachPoint.R' 'environment.R' 'helpers.R'
'initialize.R' 'mapReduce.R' 'mergeRaster.R' 'movement.R'
'neighbourhood.R' 'numerical-comparisons.R' 'probability.R'
'resample.R' 'rings.R' 'spades-tools-deprecated.R'
'spades-tools-package.R' 'splitRaster.R' 'spread.R' 'spread2.R'
'spread3.R' 'studyArea.R' 'zzz.R'</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-15 04:27:45 UTC; achubaty</td>
</tr>
<tr>
<td>Author:</td>
<td>Eliot J B McIntire
    <a href="https://orcid.org/0000-0002-6914-8316"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Alex M Chubaty <a href="https://orcid.org/0000-0001-7146-8135"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Yong Luo [ctb],
  Ceres Barros <a href="https://orcid.org/0000-0003-4036-977X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Steve Cumming [ctb],
  Jean Marchal [ctb],
  His Majesty the King in Right of Canada, as represented by the Minister
    of Natural Resources Canada [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alex M Chubaty &lt;achubaty@for-cast.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-15 09:00:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='SpaDES.tools-package'>Categorized overview of the <code>SpaDES.tools</code> package</h2><span id='topic+SpaDES.tools'></span><span id='topic+SpaDES.tools-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/SpaDES.png" width=100 alt="SpaDES logo" style="float: right;" />

</p>


<h3>1 Spatial spreading/distances methods</h3>

<p>Spatial contagion is a key phenomenon for spatially explicit simulation models.
Contagion can be modelled using discrete approaches or continuous approaches.
Several functions assist with these:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+adj">adj()</a></code> </td><td style="text-align: left;"> An optimized (i.e., faster) version of
<code><a href="terra.html#topic+adjacent">terra::adjacent()</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+cir">cir()</a></code> </td><td style="text-align: left;"> Identify pixels in a circle around a
<code style="white-space: pre;">&#8288;SpatialPoints*&#8288;</code> object</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+directionFromEachPoint">directionFromEachPoint()</a></code> </td><td style="text-align: left;"> Fast calculation of direction and
distance surfaces</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+distanceFromEachPoint">distanceFromEachPoint()</a></code> </td><td style="text-align: left;"> Fast calculation of distance surfaces</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+rings">rings()</a></code> </td><td style="text-align: left;"> Identify rings around focal cells (e.g., buffers and donuts)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+spokes">spokes()</a></code> </td><td style="text-align: left;"> TO DO: need description</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+spread">spread()</a></code> </td><td style="text-align: left;"> Contagious cellular automata</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+wrap">wrap()</a></code> </td><td style="text-align: left;"> Create a torus from a grid</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>2 Spatial agent methods</h3>

<p>Agents have several methods and functions specific to them:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+crw">crw()</a></code> </td><td style="text-align: left;"> Simple correlated random walk function</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+heading">heading()</a></code> </td><td style="text-align: left;"> Determines the heading between <code style="white-space: pre;">&#8288;SpatialPoints*&#8288;</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>quickPlot::makeLines()</code> </td><td style="text-align: left;"> Makes <code>SpatialLines</code> object for, e.g., drawing arrows</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+move">move()</a></code> </td><td style="text-align: left;"> A meta function that can currently only take "crw"</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+specificNumPerPatch">specificNumPerPatch()</a></code> </td><td style="text-align: left;"> Initiate a specific number of agents per patch</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>3 GIS operations</h3>

<p>In addition to the vast amount of GIS operations available in R (mostly from
contributed packages such as <code>sp</code>, <code>raster</code>, <code>maps</code>, <code>maptools</code>
and many others), we provide the following GIS-related functions:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>quickPlot::equalExtent()</code> </td><td style="text-align: left;"> Assess whether a list of extents are all equal</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>4 Map-reduce - type operations</h3>

<p>These functions convert between reduced and mapped representations of the same data.
This allows compact representation of, e.g., rasters that have many individual pixels
that share identical information.
</p>

<table>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+rasterizeReduced">rasterizeReduced()</a></code> </td><td style="text-align: left;"> Convert reduced representation to full raster</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>5 Random Map Generation</h3>

<p>It is often useful to build dummy maps with which to build simulation models
before all data are available.
These dummy maps can later be replaced with actual data maps.
</p>

<table>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+randomPolygons">randomPolygons()</a></code> </td><td style="text-align: left;"> Creates a random polygon with specified number of classes.</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>See the <span class="pkg">NLMR</span> package for tools to generate random landscapes (rasters).
</p>


<h3>6 SELES-type approach to simulation</h3>

<p>These functions are essentially skeletons and are not fully implemented.
They are intended to make translations from <a href="http://www.gowlland.ca/">SELES</a>.
You must know how to use SELES for these to be useful:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+agentLocation">agentLocation()</a></code> </td><td style="text-align: left;"> Agent location</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+initiateAgents">initiateAgents()</a></code> </td><td style="text-align: left;"> Initiate agents into a <code>SpatialPointsDataFrame</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+numAgents">numAgents()</a></code> </td><td style="text-align: left;"> Number of agents</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+probInit">probInit()</a></code> </td><td style="text-align: left;"> Probability of initiating an agent or event</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+transitions">transitions()</a></code> </td><td style="text-align: left;"> Transition probability</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>7 Package options</h3>

<p><code>SpaDES</code> packages use the following <code><a href="base.html#topic+options">options()</a></code> to configure behaviour:
</p>

<ul>
<li> <p><code>spades.lowMemory</code>: If true, some functions will use more memory
efficient (but slower) algorithms. Default <code>FALSE</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Alex M Chubaty <a href="mailto:achubaty@for-cast.ca">achubaty@for-cast.ca</a> (<a href="https://orcid.org/0000-0001-7146-8135">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Eliot J B McIntire <a href="mailto:eliot.mcintire@nrcan-rncan.gc.ca">eliot.mcintire@nrcan-rncan.gc.ca</a> (<a href="https://orcid.org/0000-0002-6914-8316">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Yong Luo <a href="mailto:Yong.Luo@gov.bc.ca">Yong.Luo@gov.bc.ca</a> [contributor]
</p>
</li>
<li><p> Ceres Barros <a href="mailto:ceres.barros@ubc.ca">ceres.barros@ubc.ca</a> (<a href="https://orcid.org/0000-0003-4036-977X">ORCID</a>) [contributor]
</p>
</li>
<li><p> Steve Cumming <a href="mailto:Steve.Cumming@sbf.ulaval.ca">Steve.Cumming@sbf.ulaval.ca</a> [contributor]
</p>
</li>
<li><p> Jean Marchal <a href="mailto:jean.d.marchal@gmail.com">jean.d.marchal@gmail.com</a> [contributor]
</p>
</li>
<li><p> His Majesty the King in Right of Canada, as represented by the Minister of Natural Resources Canada [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://spades-tools.predictiveecology.org">https://spades-tools.predictiveecology.org</a>
</p>
</li>
<li> <p><a href="https://github.com/PredictiveEcology/SpaDES.tools">https://github.com/PredictiveEcology/SpaDES.tools</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/PredictiveEcology/SpaDES.tools/issues">https://github.com/PredictiveEcology/SpaDES.tools/issues</a>
</p>
</li></ul>


<hr>
<h2 id='.findFactors'>Find factors</h2><span id='topic+.findFactors'></span>

<h3>Description</h3>

<p>Internal function (used in <code><a href="#topic+gaussMap">gaussMap()</a></code>).
Finds the integer factors of an integer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.findFactors(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".findFactors_+3A_x">x</code></td>
<td>
<p>An integer to factorize</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of integer factors
</p>

<hr>
<h2 id='.matchedPointDirection'>Calculate matched point directions</h2><span id='topic+.matchedPointDirection'></span><span id='topic+matchedPointDirection'></span>

<h3>Description</h3>

<p>Internal function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.matchedPointDirection(to, from)
</code></pre>

<hr>
<h2 id='.pkgEnv'>The <code>SpaDES.tools</code> package environment</h2><span id='topic+.pkgEnv'></span>

<h3>Description</h3>

<p>Environment used internally to store internal package objects and methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.pkgEnv
</code></pre>


<h3>Format</h3>

<p>An object of class <code>environment</code> of length 0.
</p>

<hr>
<h2 id='.pointDistance'>Alternative point distance (and direction) calculations</h2><span id='topic+.pointDistance'></span><span id='topic+pointDistance'></span>

<h3>Description</h3>

<p>These have been written with speed in mind.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.pointDistance(
  from,
  to,
  angles = NA,
  maxDistance = NA_real_,
  otherFromCols = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".pointDistance_+3A_from">from</code></td>
<td>
<p>Numeric matrix with 2 or 3 or more columns. They must include x and y,
representing x and y coordinates of &quot;from&quot; cell. If there is a column
named &quot;id&quot;, it will be &quot;id&quot; from <code>to</code>, i.e,. specific pair distances.
All other columns will be included in the return value of the function.</p>
</td></tr>
<tr><td><code id=".pointDistance_+3A_to">to</code></td>
<td>
<p>Numeric matrix with 2  or 3 columns (or optionally more, all of which
will be returned),
x and y, representing x and y coordinates of &quot;to&quot; cells, and
optional &quot;id&quot; which will be matched with &quot;id&quot; from <code>from</code>. Default is all cells.</p>
</td></tr>
<tr><td><code id=".pointDistance_+3A_angles">angles</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then the function will return angles in radians,
as well as distances.</p>
</td></tr>
<tr><td><code id=".pointDistance_+3A_maxdistance">maxDistance</code></td>
<td>
<p>Numeric in units of number of cells. The algorithm will build
the whole surface (from <code>from</code> to <code>to</code>), but will
remove all distances that are above this distance.
Using this will keep memory use down.</p>
</td></tr>
<tr><td><code id=".pointDistance_+3A_otherfromcols">otherFromCols</code></td>
<td>
<p>other columns to use as 'from'</p>
</td></tr>
</table>

<hr>
<h2 id='adj'>Fast <code>adjacent</code> function, and Just In Time compiled version</h2><span id='topic+adj'></span>

<h3>Description</h3>

<p>Faster function for determining the cells of the 4, 8 or bishop
neighbours of the <code>cells</code>. This is a hybrid function that uses
matrix for small numbers of loci (&lt;1e4) and data.table for larger numbers of loci
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adj(
  x = NULL,
  cells,
  directions = 8,
  sort = FALSE,
  pairs = TRUE,
  include = FALSE,
  target = NULL,
  numCol = NULL,
  numCell = NULL,
  match.adjacent = FALSE,
  cutoff.for.data.table = 2000,
  torus = FALSE,
  id = NULL,
  numNeighs = NULL,
  returnDT = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adj_+3A_x">x</code></td>
<td>
<p><code>SpatRaster</code> object for which adjacency will be calculated.</p>
</td></tr>
<tr><td><code id="adj_+3A_cells">cells</code></td>
<td>
<p>vector of cell numbers for which adjacent cells should be found.
Cell numbers start with 1 in the upper-left corner and increase
from left to right and from top to bottom.</p>
</td></tr>
<tr><td><code id="adj_+3A_directions">directions</code></td>
<td>
<p>the number of directions in which cells should be connected:
4 (rook's case), 8 (queen's case), or <code>"bishop"</code> to connect
cells with one-cell diagonal moves.
Or a neighbourhood matrix (see Details).</p>
</td></tr>
<tr><td><code id="adj_+3A_sort">sort</code></td>
<td>
<p>logical. Whether the outputs should be sorted or not, using cell ids
of the <code>from</code> cells (and <code>to</code> cells, if <code>match.adjacent</code>
is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="adj_+3A_pairs">pairs</code></td>
<td>
<p>logical. If <code>TRUE</code>, a matrix of pairs of adjacent cells is returned.
If <code>FALSE</code>, a vector of cells adjacent to cells is returned</p>
</td></tr>
<tr><td><code id="adj_+3A_include">include</code></td>
<td>
<p>logical. Should the focal cells be included in the result?</p>
</td></tr>
<tr><td><code id="adj_+3A_target">target</code></td>
<td>
<p>a vector of cells that can be spread to. This is the inverse of a mask.</p>
</td></tr>
<tr><td><code id="adj_+3A_numcol">numCol</code></td>
<td>
<p>numeric indicating number of columns in the raster.
Using this with <code>numCell</code> is a bit faster execution time.</p>
</td></tr>
<tr><td><code id="adj_+3A_numcell">numCell</code></td>
<td>
<p>numeric indicating number of cells in the raster.
Using this with <code>numCol</code> is a bit faster execution time.</p>
</td></tr>
<tr><td><code id="adj_+3A_match.adjacent">match.adjacent</code></td>
<td>
<p>logical. Should the returned object be the same as
<code>raster::adjacent</code>.
Default <code>FALSE</code>, which is faster.</p>
</td></tr>
<tr><td><code id="adj_+3A_cutoff.for.data.table">cutoff.for.data.table</code></td>
<td>
<p>numeric. If the number of cells is above this value,
the function uses data.table which is faster with
large numbers of cells. Default is 5000, which appears
to be the turning point where data.table becomes faster.</p>
</td></tr>
<tr><td><code id="adj_+3A_torus">torus</code></td>
<td>
<p>Logical. Should the spread event wrap around to the other side of the raster?
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="adj_+3A_id">id</code></td>
<td>
<p>numeric If not <code>NULL</code> (default), then function will return <code>"id"</code> column.</p>
</td></tr>
<tr><td><code id="adj_+3A_numneighs">numNeighs</code></td>
<td>
<p>A numeric scalar, indicating how many neighbours to return. Must be
less than or equal to <code>directions</code>; which neighbours are random
with equal probabilities.</p>
</td></tr>
<tr><td><code id="adj_+3A_returndt">returnDT</code></td>
<td>
<p>A logical. If TRUE, then the function will return the result
as a <code>data.table</code>, if the internals used <code>data.table</code>,
i.e., if number of cells is greater than <code>cutoff.for.data.table</code>.
User should be warned that this will therefore cause the output
format to change depending <code>cutoff.for.data.table</code>.
This will be faster for situations where <code>cutoff.for.data.table = TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Between 4x (large number loci) to 200x (small number loci) speed gains over
<code>adjacent</code> in raster package. There is some extra speed gain if
<code>NumCol</code> and <code>NumCells</code> are passed rather than a raster.
Efficiency gains come from:
</p>

<ol>
<li><p> use <code>data.table</code> internally
</p>

<ul>
<li><p> no need to remove NAs because wrapped or outside points are
just removed directly with data.table
</p>
</li>
<li><p> use data.table to sort and fast select (though not fastest possible)
</p>
</li></ul>

</li>
<li><p> don't make intermediate objects; just put calculation into return statement
</p>
</li></ol>

<p>The steps used in the algorithm are:
</p>

<ol>
<li><p> Calculate indices of neighbouring cells
</p>
</li>
<li><p> Remove &quot;to&quot; cells that are
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;&lt; 1&#8288;</code> or <code style="white-space: pre;">&#8288;&gt; numCells&#8288;</code> (i.e., they are above or below raster), using a single modulo
calculation
</p>
</li>
<li><p> where the modulo of &quot;to&quot; cells is equal to 1 if &quot;from&quot; cells are 0 (wrapped right
to left)
</p>
</li>
<li><p> or where the modulo of the &quot;to&quot; cells is equal to 0 if &quot;from&quot; cells are 1 (wrapped
left to right)
</p>
</li></ul>

</li></ol>



<h3>Value</h3>

<p>Either a matrix (if more than 1 column, i.e., <code>pairs = TRUE</code>,
and/or <code>id</code> is provided), a vector (if only one column), or a <code>data.table</code>
(if <code>cutoff.for.data.table</code> is less than <code>length(cells)</code> <em>and</em>
<code>returnDT</code> is <code>TRUE</code>.
To get a consistent output, say a matrix, it would be wise to test the output
for its class.
The variable output is done to minimize coercion to maintain speed.
The columns will be one or more of <code>id</code>, <code>from</code>, <code>to</code>.
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+adjacent">terra::adjacent()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)

origDTThreads &lt;- data.table::setDTthreads(2L)
origNcpus &lt;- options(Ncpus = 2L)

a &lt;- rast(ext(0, 1000, 0, 1000), res = 1)
sam &lt;- sample(1:ncell(a), 1e4)
numCol &lt;- ncol(a)
numCell &lt;- ncell(a)
adj.new &lt;- adj(numCol = numCol, numCell = numCell, cells = sam, directions = 8)
adj.new &lt;- adj(numCol = numCol, numCell = numCell, cells = sam, directions = 8,
               include = TRUE)

# clean up
data.table::setDTthreads(origDTThreads)
options(Ncpus = origNcpus)

</code></pre>

<hr>
<h2 id='agentLocation'><code>SELES</code> - Agent Location at initiation</h2><span id='topic+agentLocation'></span>

<h3>Description</h3>

<p>Sets the the location of the initiating agents. NOT YET FULLY IMPLEMENTED.
</p>
<p>A <code>SELES</code>-like function to maintain conceptual backwards compatibility
with that simulation tool. This is intended to ease transitions from
<a href="http://www.gowlland.ca/">SELES</a>.
</p>
<p>You must know how to use SELES for these to be useful.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>agentLocation(map)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="agentLocation_+3A_map">map</code></td>
<td>
<p>A <code style="white-space: pre;">&#8288;SpatialPoints*&#8288;</code>, <code style="white-space: pre;">&#8288;SpatialPolygons*&#8288;</code>, or <code style="white-space: pre;">&#8288;Raster*&#8288;</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of same class as provided as input.
If a <code style="white-space: pre;">&#8288;Raster*&#8288;</code>, then zeros are converted to <code>NA</code>.
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>

<hr>
<h2 id='cir'>Identify pixels in a circle or ring (doughnut) around an object.</h2><span id='topic+cir'></span>

<h3>Description</h3>

<p>Identify the pixels and coordinates that are at a (set of) buffer distance(s)
of the objects passed into <code>coords</code>.
This is similar to <code>sf::st_buffer</code> but much faster and without the georeferencing information.
In other words, it can be used for similar problems, but where speed is important.
This code is substantially adapted from <code>PlotRegionHighlighter::createCircle</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cir(
  landscape,
  coords,
  loci,
  maxRadius = ncol(landscape)/4,
  minRadius = maxRadius,
  allowOverlap = TRUE,
  allowDuplicates = FALSE,
  includeBehavior = "includePixels",
  returnDistances = FALSE,
  angles = NA_real_,
  returnAngles = FALSE,
  returnIndices = TRUE,
  closest = FALSE,
  simplify = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cir_+3A_landscape">landscape</code></td>
<td>
<p>Raster on which the circles are built.</p>
</td></tr>
<tr><td><code id="cir_+3A_coords">coords</code></td>
<td>
<p>Either a matrix with 2 (or 3) columns, <code>x</code> and <code>y</code> (and <code>id</code>), representing the
coordinates (and an associated id, like cell index),
or a <code style="white-space: pre;">&#8288;SpatialPoints*&#8288;</code> object around which to make circles. Must be same
coordinate system as the <code>landscape</code> argument. Default is missing,
meaning it uses the default to <code>loci</code>.</p>
</td></tr>
<tr><td><code id="cir_+3A_loci">loci</code></td>
<td>
<p>Numeric. An alternative to <code>coords</code>.
These are the indices on <code>landscape</code> to initiate this function (see <code>coords</code>).
Default is one point in centre of <code>landscape</code>.</p>
</td></tr>
<tr><td><code id="cir_+3A_maxradius">maxRadius</code></td>
<td>
<p>Numeric vector of length 1 or same length as <code>coords</code></p>
</td></tr>
<tr><td><code id="cir_+3A_minradius">minRadius</code></td>
<td>
<p>Numeric vector of length 1 or same length as <code>coords</code>. Default is
<code>maxRadius</code>, meaning return all cells that are touched
by the narrow ring at that exact radius. If smaller than <code>maxRadius</code>,
then this will create a buffer or doughnut or ring.</p>
</td></tr>
<tr><td><code id="cir_+3A_allowoverlap">allowOverlap</code></td>
<td>
<p>Logical. Should duplicates across id be removed or kept. Default TRUE.</p>
</td></tr>
<tr><td><code id="cir_+3A_allowduplicates">allowDuplicates</code></td>
<td>
<p>Logical. Should duplicates within id be removed or kept. Default FALSE.
This is useful if the actual x, y coordinates are desired, rather
than the cell indices. This will increase the size of the returned
object.</p>
</td></tr>
<tr><td><code id="cir_+3A_includebehavior">includeBehavior</code></td>
<td>
<p>Character string. Currently accepts only <code>"includePixels"</code>, the default,
and <code>"excludePixels"</code>. See details.</p>
</td></tr>
<tr><td><code id="cir_+3A_returndistances">returnDistances</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then a column will be added to the returned
data.table that reports the distance from <code>coords</code> to every
point that was in the circle/doughnut surrounding <code>coords</code>.
Default <code>FALSE</code>, which is faster.</p>
</td></tr>
<tr><td><code id="cir_+3A_angles">angles</code></td>
<td>
<p>Numeric. Optional vector of angles, in radians, to use. This will create
&quot;spokes&quot; outward from <code>coords.</code> Default is <code>NA</code>, meaning, use internally
derived angles that will &quot;fill&quot; the circle.</p>
</td></tr>
<tr><td><code id="cir_+3A_returnangles">returnAngles</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then a column will be added to the returned
data.table that reports the angle from <code>coords</code> to every
point that was in the circle/doughnut surrounding <code>coords</code>. Default <code>FALSE.</code></p>
</td></tr>
<tr><td><code id="cir_+3A_returnindices">returnIndices</code></td>
<td>
<p>Logical or numeric. If <code>1</code> or <code>TRUE</code>, will return a <code>data.table</code>
with indices and values of successful spread events.
If <code>2</code>, it will simply return a vector of pixel indices of
all cells that were touched. This will be the fastest option.
If <code>FALSE</code>, then it will return a raster with values.
See Details.</p>
</td></tr>
<tr><td><code id="cir_+3A_closest">closest</code></td>
<td>
<p>Logical. When determining non-overlapping circles, should the function
give preference to the closest <code>loci</code> or the first one (much faster).
Default is <code>FALSE</code>, meaning the faster, though maybe not desired behaviour.</p>
</td></tr>
<tr><td><code id="cir_+3A_simplify">simplify</code></td>
<td>
<p>logical. If <code>TRUE</code>, then all duplicate pixels are removed.
This means that some <code>x</code>, <code>y</code> combinations will disappear.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function identifies all the pixels as defined by a donut
with inner radius <code>minRadius</code> and outer radius of <code>maxRadius</code>.
The <code>includeBehavior</code> defines whether the cells that intersect the radii
but whose centres are not inside the donut are included <code>includePixels</code>
or not <code>excludePixels</code> in the returned pixels identified.
If this is <code>excludePixels</code>, and if a <code>minRadius</code> and
<code>maxRadius</code> are equal, this will return no pixels.
</p>


<h3>Value</h3>

<p>A <code>matrix</code> with 4 columns, <code>id</code>, <code>indices</code>,
<code>x</code>, <code>y</code>. The <code>x</code> and <code>y</code> indicate the exact coordinates of
the <code>indices</code> (i.e., cell number) of the <code>landscape</code>
associated with the ring or circle being identified by this function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rings">rings()</a></code> which uses <code>spread</code> internally.
<code>cir</code> tends to be faster when there are few starting points, <code>rings</code> tends to be faster
when there are many starting points. <code>cir</code> scales with <code>maxRadius^2</code> and <code>coords</code>.
Another difference between the two functions is that <code>rings</code> takes the centre of the pixel
as the centre of a circle, whereas <code>cir</code> takes the exact coordinates.
See example. For the specific case of creating distance surfaces from specific
points, see <code><a href="#topic+distanceFromEachPoint">distanceFromEachPoint()</a></code>, which is often faster.
For the more general GIS buffering, see <code>sf::st_buffer</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
library(terra)

origDTThreads &lt;- data.table::setDTthreads(2L)
origNcpus &lt;- options(Ncpus = 2L)
set.seed(1462)

# circle centred
ras &lt;- rast(ext(0, 15, 0, 15), res = 1, val = 0)
middleCircle &lt;- cir(ras)
ras[middleCircle[, "indices"]] &lt;- 1
circlePoints &lt;- vect(middleCircle[, c("x", "y")])
if (interactive()) {
  # clearPlot()
  terra::plot(ras)
  terra::plot(circlePoints, add = TRUE)
}

# circles non centred
ras &lt;- randomPolygons(ras, numTypes = 4)
n &lt;- 2
agent &lt;- vect(cbind(x = stats::runif(n, xmin(ras), xmax(ras)),
                    y = stats::runif(n, xmin(ras), xmax(ras))))

cirs &lt;- cir(ras, agent, maxRadius = 15, simplify = TRUE) ## TODO: empty with some seeds! e.g. 1642
cirsSP &lt;- vect(cirs[, c("x", "y")]) ## TODO: error with some seeds! e.g. 1642
cirsRas &lt;- rast(ras)
cirsRas[] &lt;- 0
cirsRas[cirs[, "indices"]] &lt;- 1

if (interactive()) {
  terra::plot(ras)
  terra::plot(cirsRas, add = TRUE, col = c("transparent", "#00000055"))
  terra::plot(agent, add = TRUE)
  terra::plot(cirsSP, add = TRUE)
}

# Example comparing rings and cir
hab &lt;- rast(system.file("extdata", "hab1.tif", package = "SpaDES.tools"))
radius &lt;- 4
n &lt;- 2
coords &lt;- vect(cbind(x = stats::runif(n, xmin(hab), xmax(hab)),
                     y = stats::runif(n, xmin(hab), xmax(hab))))

# cirs
cirs &lt;- cir(hab, coords, maxRadius = rep(radius, length(coords)), simplify = TRUE)

ras1 &lt;- rast(hab)
ras1[] &lt;- 0
ras1[cirs[, "indices"]] &lt;- cirs[, "id"]
if (interactive()) {
  terra::plot(ras1)
}

# rings
loci &lt;- cellFromXY(hab, crds(coords))
cirs2 &lt;- rings(hab, loci, maxRadius = radius, minRadius = radius - 1, returnIndices = TRUE)

ras2 &lt;- rast(hab)
ras2[] &lt;- 0
ras2[cirs2$indices] &lt;- cirs2$id
if (interactive()) {
  terra::plot(c(ras1, ras2))
}

hab &lt;- rast(system.file("extdata", "hab2.tif", package = "SpaDES.tools"))
cirs &lt;- cir(hab, coords, maxRadius = 44, minRadius = 0)
ras1 &lt;- rast(hab)
ras1[] &lt;- 0
cirsOverlap &lt;- data.table::data.table(cirs)[, list(sumIDs = sum(id)), by = indices]
ras1[cirsOverlap$indices] &lt;- cirsOverlap$sumIDs
if (interactive()) {
  terra::plot(ras1)
}

# Provide a specific set of angles
ras &lt;- rast(ext(0, 330, 0, 330), res = 1)
ras[] &lt;- 0
n &lt;- 2
coords &lt;- cbind(x = stats::runif(n, xmin(ras), xmax(ras)),
                y = stats::runif(n, xmin(ras), xmax(ras)))
circ &lt;- cir(ras, coords, angles = seq(0, 2 * pi, length.out = 21),
            maxRadius = 200, minRadius = 0, returnIndices = FALSE,
            allowOverlap = TRUE, returnAngles = TRUE)

# clean up
data.table::setDTthreads(origDTThreads)
options(Ncpus = origNcpus)
</code></pre>

<hr>
<h2 id='cirSpecialQuick'>This is a very fast version of <code>cir</code> with <code>allowOverlap = TRUE</code>,
<code>allowDuplicates = FALSE</code>, <code>returnIndices = TRUE</code>, <code>returnDistances = TRUE</code>, and
<code>includeBehavior = "excludePixels"</code>.
It is used inside <code>spread2</code>, when asymmetry is active.
The basic algorithm is to run <code>cir</code> just once, then add to the x,y coordinates of every locus.</h2><span id='topic+cirSpecialQuick'></span><span id='topic+.cirSpecialQuick'></span>

<h3>Description</h3>

<p>This is a very fast version of <code>cir</code> with <code>allowOverlap = TRUE</code>,
<code>allowDuplicates = FALSE</code>, <code>returnIndices = TRUE</code>, <code>returnDistances = TRUE</code>, and
<code>includeBehavior = "excludePixels"</code>.
It is used inside <code>spread2</code>, when asymmetry is active.
The basic algorithm is to run <code>cir</code> just once, then add to the x,y coordinates of every locus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.cirSpecialQuick(landscape, loci, maxRadius, minRadius)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cirSpecialQuick_+3A_landscape">landscape</code></td>
<td>
<p>Raster on which the circles are built.</p>
</td></tr>
<tr><td><code id="cirSpecialQuick_+3A_loci">loci</code></td>
<td>
<p>Numeric. An alternative to <code>coords</code>.
These are the indices on <code>landscape</code> to initiate this function (see <code>coords</code>).
Default is one point in centre of <code>landscape</code>.</p>
</td></tr>
<tr><td><code id="cirSpecialQuick_+3A_maxradius">maxRadius</code></td>
<td>
<p>Numeric vector of length 1 or same length as <code>coords</code></p>
</td></tr>
<tr><td><code id="cirSpecialQuick_+3A_minradius">minRadius</code></td>
<td>
<p>Numeric vector of length 1 or same length as <code>coords</code>. Default is
<code>maxRadius</code>, meaning return all cells that are touched
by the narrow ring at that exact radius. If smaller than <code>maxRadius</code>,
then this will create a buffer or doughnut or ring.</p>
</td></tr>
</table>

<hr>
<h2 id='directionFromEachPoint'>Calculate distances and directions between many points and many grid cells</h2><span id='topic+directionFromEachPoint'></span><span id='topic+.pointDirection'></span>

<h3>Description</h3>

<p>This is a modification of <code><a href="terra.html#topic+distance">terra::distance()</a></code> for the case
of many points.
This version can often be faster for a single point because it does not return
a <code>RasterLayer</code>.
This is different than <code><a href="terra.html#topic+distance">terra::distance()</a></code> because it does
not take the minimum distance from the set of points to all cells.
Rather this returns the every pair-wise point distance.
As a result, this can be used for doing inverse distance weightings, seed rain,
cumulative effects of distance-based processes etc.
If memory limitation is an issue, <code>maxDistance</code> will keep memory use down,
but with the consequences that there will be a maximum distance returned.
This function has the potential to use a lot of memory if there are a lot of
<code>from</code> and <code>to</code> points.
</p>
<p>Internal function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>directionFromEachPoint(from, to = NULL, landscape)

.pointDirection(from, to)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="directionFromEachPoint_+3A_from">from</code></td>
<td>
<p>matrix with 2 or 3 columns, x and y, representing x and y coordinates
of <code>from</code> cell, and optional <code>id</code>, which will be returned,
and if <code>id</code> column is in <code>to</code>, it will be matched with that.</p>
</td></tr>
<tr><td><code id="directionFromEachPoint_+3A_to">to</code></td>
<td>
<p>matrix with 2  or 3 columns (or optionally more, all of which will be returned),
x and y, representing x and y coordinates of <code>to</code> cells, and
optional <code>id</code> which will be matched with <code>id</code> from <code>from</code>.
It makes no sense to have <code>id</code> column here with no <code>id</code> column
in <code>from</code>.</p>
</td></tr>
<tr><td><code id="directionFromEachPoint_+3A_landscape">landscape</code></td>
<td>
<p>(optional) <code>RasterLayer</code> or <code>SpatRaster</code>.
This is only used if <code>to = NULL</code>, in which case all cells are considered <code>to</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>directionFromEachPoint</code> calls <code>.pointDirection</code>, which is
not intended to be called directly by the user.
</p>
<p>If knowing the which from cell matches with which to cell is important,
put a column &quot;id&quot; (e.g., starting cell) in the <code>from</code> matrix.
</p>


<h3>Value</h3>

<p>A sorted matrix on <code>id</code> with same number of rows as <code>to</code>,
but with one extra column, <code>angles</code> indicating the angle in radians between from and to.
For speed, this angle will be between <code>-pi/2</code> and <code>3*pi/2</code>.
If the user wants this between say, <code>0</code> and <code>2*pi</code>,
then <code style="white-space: pre;">&#8288;angles \%\% (2*pi)&#8288;</code> will do the trick. See example.
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distanceFromEachPoint">distanceFromEachPoint()</a></code>, which will also return directions if <code>angles = TRUE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)

origDTThreads &lt;- data.table::setDTthreads(2L)
origNcpus &lt;- options(Ncpus = 2L)

N &lt;- 2
dirRas &lt;- terra::rast(terra::ext(0,40,0,40), res = 1)
coords &lt;- cbind(x = round(runif(N, xmin(dirRas), xmax(dirRas))) + 0.5,
                y = round(runif(N, xmin(dirRas), xmax(dirRas))) + 0.5,
                id = 1:N)

dirs1 &lt;- directionFromEachPoint(from = coords, landscape = dirRas)

# helper function for converting radians to degrees
deg2 &lt;- function(radian) (radian * 180)/pi
dirs1[, "angles"] &lt;- deg2(dirs1[,"angles"] %% (2*pi))
indices &lt;- cellFromXY(dirRas,dirs1[, c("x", "y")])
minDir &lt;- tapply(dirs1[, "angles"], indices, function(x) min(x)) # minimum angle
dirRas[] &lt;- as.vector(minDir)

if (interactive()) {
  terra::plot(dirRas)
  start &lt;- terra::vect(coords[, c("x", "y"), drop = FALSE])
  terra::plot(start, add = TRUE)
}

# clean up
data.table::setDTthreads(origDTThreads)
options(Ncpus = origNcpus)

</code></pre>

<hr>
<h2 id='distanceFromEachPoint'>Calculate distances and directions between many points and many grid cells</h2><span id='topic+distanceFromEachPoint'></span>

<h3>Description</h3>

<p>This is a modification of <code><a href="terra.html#topic+distance">terra::distance()</a></code> for the case of many points.
This version can often be faster for a single point because it does not return a <code>RasterLayer</code>.
This is different than <code><a href="terra.html#topic+distance">terra::distance()</a></code> because it does not take the
minimum distance from the set of points to all cells.
Rather this returns the every pair-wise point distance.
As a result, this can be used for doing inverse distance weightings, seed rain,
cumulative effects of distance-based processes etc.
If memory limitation is an issue, <code>maxDistance</code> will keep memory use down,
but with the consequences that there will be a maximum distance returned.
This function has the potential to use a lot of memory if there are a lot of
<code>from</code> and <code>to</code> points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distanceFromEachPoint(
  from,
  to = NULL,
  landscape,
  angles = NA_real_,
  maxDistance = NA_real_,
  cumulativeFn = NULL,
  distFn = function(dist) 1/(1 + dist),
  cl,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distanceFromEachPoint_+3A_from">from</code></td>
<td>
<p>Numeric matrix with 2 or 3 or more columns. They must include x and y,
representing x and y coordinates of &quot;from&quot; cell. If there is a column
named &quot;id&quot;, it will be &quot;id&quot; from <code>to</code>, i.e,. specific pair distances.
All other columns will be included in the return value of the function.</p>
</td></tr>
<tr><td><code id="distanceFromEachPoint_+3A_to">to</code></td>
<td>
<p>Numeric matrix with 2  or 3 columns (or optionally more, all of which
will be returned),
x and y, representing x and y coordinates of &quot;to&quot; cells, and
optional &quot;id&quot; which will be matched with &quot;id&quot; from <code>from</code>. Default is all cells.</p>
</td></tr>
<tr><td><code id="distanceFromEachPoint_+3A_landscape">landscape</code></td>
<td>
<p><code>RasterLayer</code>. optional. This is only used if <code>to</code> is NULL, in which case
all cells are considered <code>to</code>.</p>
</td></tr>
<tr><td><code id="distanceFromEachPoint_+3A_angles">angles</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then the function will return angles in radians,
as well as distances.</p>
</td></tr>
<tr><td><code id="distanceFromEachPoint_+3A_maxdistance">maxDistance</code></td>
<td>
<p>Numeric in units of number of cells. The algorithm will build
the whole surface (from <code>from</code> to <code>to</code>), but will
remove all distances that are above this distance.
Using this will keep memory use down.</p>
</td></tr>
<tr><td><code id="distanceFromEachPoint_+3A_cumulativefn">cumulativeFn</code></td>
<td>
<p>A function that can be used to incrementally accumulate
values in each <code>to</code> location, as the function iterates
through each <code>from</code>. See Details.</p>
</td></tr>
<tr><td><code id="distanceFromEachPoint_+3A_distfn">distFn</code></td>
<td>
<p>A function. This can be a function of <code>landscape</code>,
<code>fromCell</code> (single integer value of a from pixel),
<code>toCells</code> (integer vector value of all the to pixel indices),
and <code>dist</code>.
If <code>cumulativeFn</code> is supplied, this will be used to convert
the distances to some other set of units that will be accumulated
by the <code>cumulativeFn</code>. See Details and examples.</p>
</td></tr>
<tr><td><code id="distanceFromEachPoint_+3A_cl">cl</code></td>
<td>
<p>A cluster object. Optional. This would generally be created using
<code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code> or equivalent. This is an alternative way, instead
of <code>beginCluster()</code>, to use parallelism for this function, allowing for
more control over cluster use.</p>
</td></tr>
<tr><td><code id="distanceFromEachPoint_+3A_...">...</code></td>
<td>
<p>Any additional objects needed for <code>distFn</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is cluster aware if the <code>raster</code> package is available.
If there is a cluster running, it will use it.
To start a cluster use <code>raster::beginCluster()</code>, with <code>N</code> being
the number of cores to use. See examples in <code>SpaDES.core::experiment</code>.
</p>
<p>If the user requires an id (indicating the <code>from</code> cell for each <code>to</code> cell)
to be returned with the function, the user must add an identifier to the
<code>from</code> matrix, such as <code>"id"</code>.
Otherwise, the function will only return the coordinates and distances.
</p>
<p><code>distanceFromEachPoint</code> calls <code>.pointDistance</code>, which is not intended to be called
directly by the user.
</p>
<p>This function has the potential to return a very large object, as it is doing pairwise
distances (and optionally directions) between from and to.
If there are memory limitations because there are many
<code>from</code> and many <code>to</code> points, then <code>cumulativeFn</code> and <code>distFn</code> can be used.
These two functions together will be used iteratively through the <code>from</code> points. The
<code>distFn</code> should be a transformation of distances to be used by the
<code>cumulativeFn</code> function. For example, if <code>distFn</code> is <code>1 / (1+x)</code>,
the default, and <code>cumulativeFn</code> is <code>+</code>, then it will do a sum of
inverse distance weights.
See examples.
</p>


<h3>Value</h3>

<p>A sorted matrix on <code>id</code> with same number of rows as <code>to</code>,
but with one extra column, <code>"dists"</code>, indicating the distance
between <code>from</code> and <code>to</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rings">rings()</a></code>, <code><a href="#topic+cir">cir()</a></code>, <code><a href="terra.html#topic+distance">terra::distance()</a></code>,
which can all be made to do the same thing, under specific combinations of arguments.
But each has different primary use cases. Each is also faster under different conditions.
For instance, if <code>maxDistance</code> is relatively small compared to the number of cells
in the <code>landscape</code>, then <code><a href="#topic+cir">cir()</a></code> will likely be faster. If a minimum
distance from all cells in the <code>landscape</code> to any cell in <code>from</code>, then
<code>distanceFromPoints</code> will be fastest. This function scales best when there are
many <code>to</code> points or all cells are used <code>to = NULL</code> (which is default).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)

origDTThreads &lt;- data.table::setDTthreads(2L)
origNcpus &lt;- options(Ncpus = 2L)

n &lt;- 2
distRas &lt;- rast(ext(0, 40, 0, 40), res = 1)
coords &lt;- cbind(x = round(runif(n, xmin(distRas), xmax(distRas))) + 0.5,
                y = round(runif(n, xmin(distRas), xmax(distRas))) + 0.5)

# inverse distance weights
dists1 &lt;- distanceFromEachPoint(coords, landscape = distRas)
indices &lt;- cellFromXY(distRas, dists1[, c("x", "y")])
invDist &lt;- tapply(dists1[, "dists"], indices, function(x) sum(1 / (1 + x))) # idw function
distRas[] &lt;- as.vector(invDist)
if (interactive()) {
  # clearPlot()
  terra::plot(distRas)
}

# With iterative summing via cumulativeFn to keep memory use low, with same result
dists1 &lt;- distanceFromEachPoint(coords[, c("x", "y"), drop = FALSE],
                                landscape = distRas, cumulativeFn = `+`)
idwRaster &lt;- rast(distRas)
idwRaster[] &lt;- dists1[, "dists"]
if (interactive()) terra::plot(idwRaster)

all(idwRaster[] == distRas[]) # TRUE

# A more complex example of cumulative inverse distance sums, weighted by the value
#  of the origin cell
ras &lt;- rast(ext(0, 34, 0, 34), res = 1, val = 0)
rp &lt;- randomPolygons(ras, numTypes = 10) ^ 2
n &lt;- 15
cells &lt;- sample(ncell(ras), n)
coords &lt;- xyFromCell(ras, cells)
distFn &lt;- function(landscape, fromCell, dist) landscape[fromCell] / (1 + dist)

#beginCluster(3) # can do parallel
dists1 &lt;- distanceFromEachPoint(coords[, c("x", "y"), drop = FALSE],
                                landscape = rp, distFn = distFn, cumulativeFn = `+`)
#endCluster() # if beginCluster was run

idwRaster &lt;- rast(ras)
idwRaster[] &lt;- dists1[, "dists"]
if (interactive()) {
  # clearPlot()
  terra::plot(rp)
  sp1 &lt;- vect(coords)
  terra::plot(sp1, add = TRUE)
  terra::plot(idwRaster)
  terra::plot(sp1, add = TRUE)
}

# On linux; can use numeric passed to cl; will use mclapply with mc.cores = cl
if (identical(Sys.info()["sysname"], "Linux")) {
  dists1 &lt;- distanceFromEachPoint(coords[, c("x", "y"), drop = FALSE],
                                  landscape = rp, distFn = distFn,
                                  cumulativeFn = `+`, cl = 2)
}

# clean up
data.table::setDTthreads(origDTThreads)
options(Ncpus = origNcpus)
</code></pre>

<hr>
<h2 id='duplicatedInt'>Rcpp duplicated on integers using Rcpp Sugar</h2><span id='topic+duplicatedInt'></span>

<h3>Description</h3>

<p><code>.duplicatedInt</code> does same as <code>duplicated</code> in R, but only on integers, and faster.
It uses Rcpp sugar
</p>


<h3>Usage</h3>

<pre><code class='language-R'>duplicatedInt(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="duplicatedInt_+3A_x">x</code></td>
<td>
<p>Integer Vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector, as per <code>duplicated</code>
</p>

<hr>
<h2 id='dwrpnorm2'>Vectorized wrapped normal density function</h2><span id='topic+dwrpnorm2'></span>

<h3>Description</h3>

<p>This is a modified version of <code>dwrpnorm</code> in the <code>CircStats</code> package
to allow for multiple angles at once (i.e., vectorized on <code>theta</code> and <code>mu</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dwrpnorm2(theta, mu, rho, sd = 1, acc = 1e-05, tol = acc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dwrpnorm2_+3A_theta">theta</code></td>
<td>
<p>value at which to evaluate the density function, measured in radians.</p>
</td></tr>
<tr><td><code id="dwrpnorm2_+3A_mu">mu</code></td>
<td>
<p>mean direction of distribution, measured in radians.</p>
</td></tr>
<tr><td><code id="dwrpnorm2_+3A_rho">rho</code></td>
<td>
<p>mean resultant length of distribution.</p>
</td></tr>
<tr><td><code id="dwrpnorm2_+3A_sd">sd</code></td>
<td>
<p>different way of select rho, see details below.</p>
</td></tr>
<tr><td><code id="dwrpnorm2_+3A_acc">acc</code></td>
<td>
<p>parameter defining the accuracy of the estimation of the density.
Terms are added to the infinite summation that defines the density function
until successive estimates are within acc of each other.</p>
</td></tr>
<tr><td><code id="dwrpnorm2_+3A_tol">tol</code></td>
<td>
<p>same as <code>acc</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Values for which to evaluate density
theta &lt;- c(1:500) * 2 * pi / 500
# Compute wrapped normal density function
density &lt;- c(1:500)
for(i in 1:500) {
  density[i] &lt;- dwrpnorm2(theta[i], pi, .75)
}

if (interactive()) {
  plot(theta, density)
}

# Approximate area under density curve
sum(density * 2 * pi / 500)

</code></pre>

<hr>
<h2 id='fastCrop'><code>fastCrop</code> is deprecated.</h2><span id='topic+fastCrop'></span>

<h3>Description</h3>

<p><code>fastCrop</code> is deprecated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastCrop(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fastCrop_+3A_x">x</code></td>
<td>
<p>Raster to crop</p>
</td></tr>
<tr><td><code id="fastCrop_+3A_y">y</code></td>
<td>
<p>Raster to crop with</p>
</td></tr>
<tr><td><code id="fastCrop_+3A_...">...</code></td>
<td>
<p>other</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code>velox::VeloxRaster_crop</code>
</p>

<hr>
<h2 id='gaussMap'>Produce a <code>raster</code> of a random Gaussian process.</h2><span id='topic+gaussMap'></span>

<h3>Description</h3>

<p>Defunct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussMap(
  x,
  scale = 10,
  var = 1,
  speedup = 1,
  method = "RMexp",
  alpha = 1,
  inMemory = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaussMap_+3A_x">x</code></td>
<td>
<p>A spatial object (e.g., a <code>RasterLayer</code>).</p>
</td></tr>
<tr><td><code id="gaussMap_+3A_scale">scale</code></td>
<td>
<p>The spatial scale in map units of the Gaussian pattern.</p>
</td></tr>
<tr><td><code id="gaussMap_+3A_var">var</code></td>
<td>
<p>Spatial variance.</p>
</td></tr>
<tr><td><code id="gaussMap_+3A_speedup">speedup</code></td>
<td>
<p>An numeric value indicating how much faster than 'normal'
to generate maps. It may be necessary to give a value larger
than 1 for large maps. Default is 1.</p>
</td></tr>
<tr><td><code id="gaussMap_+3A_method">method</code></td>
<td>
<p>The type of model used to produce the Gaussian pattern.
Should be one of <code>"RMgauss"</code> (Gaussian covariance model),
<code>"RMstable"</code> (the stable powered exponential model),
or the default, <code>"RMexp"</code> (exponential covariance model).</p>
</td></tr>
<tr><td><code id="gaussMap_+3A_alpha">alpha</code></td>
<td>
<p>A required parameter of the <code>"RMstable"</code> model.
Should be in the interval <code style="white-space: pre;">&#8288;[0,2]&#8288;</code> to provide a valid covariance function.
Default is 1.</p>
</td></tr>
<tr><td><code id="gaussMap_+3A_inmemory">inMemory</code></td>
<td>
<p>Should the <code>RasterLayer</code> be forced to be in memory?
Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="gaussMap_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>raster</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A raster map with same extent as <code>x</code>, with a Gaussian random pattern.
</p>

<hr>
<h2 id='heading'>Heading between spatial points.</h2><span id='topic+heading'></span>

<h3>Description</h3>

<p>Determines the heading between spatial points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heading(from, to)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="heading_+3A_from">from</code></td>
<td>
<p>The starting position; an object of class <code>SpatVector</code>.</p>
</td></tr>
<tr><td><code id="heading_+3A_to">to</code></td>
<td>
<p>The ending position; an object of class <code>SpatVector</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The heading between the points, in degrees.
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)

origDTThreads &lt;- data.table::setDTthreads(2L)
origNcpus &lt;- options(Ncpus = 2L)

N &lt;- 10L                       # number of agents
x1 &lt;- stats::runif(N, -50, 50) # previous X location
y1 &lt;- stats::runif(N, -50, 50) # previous Y location
x0 &lt;- stats::rnorm(N, x1, 5)   # current X location
y0 &lt;- stats::rnorm(N, y1, 5)   # current Y location

# using SpatVector
prev &lt;- terra::vect(cbind(x = x1, y = y1))
curr &lt;- terra::vect(cbind(x = x0, y = y0))
heading(prev, curr)

# using matrix
prev &lt;- matrix(c(x1, y1), ncol = 2, dimnames = list(NULL, c("x","y")))
curr &lt;- matrix(c(x0, y0), ncol = 2, dimnames = list(NULL, c("x","y")))
heading(prev, curr)

#using both
prev &lt;- terra::vect(cbind(x = x1, y = y1))
curr &lt;- matrix(c(x0, y0), ncol = 2, dimnames = list(NULL, c("x","y")))
heading(prev, curr)

prev &lt;- matrix(c(x1, y1), ncol = 2, dimnames = list(NULL, c("x","y")))
curr &lt;- terra::vect(cbind(x = x0, y = y0))
heading(prev, curr)

# clean up
data.table::setDTthreads(origDTThreads)
options(Ncpus = origNcpus)

</code></pre>

<hr>
<h2 id='initiateAgents'><code>SELES</code> - Initiate agents</h2><span id='topic+initiateAgents'></span>

<h3>Description</h3>

<p>Sets the the number of agents to initiate. THIS IS NOT FULLY IMPLEMENTED.
</p>
<p>A <code>SELES</code>-like function to maintain conceptual backwards compatibility
with that simulation tool. This is intended to ease transitions from
<a href="http://www.gowlland.ca/">SELES</a>.
</p>
<p>You must know how to use SELES for these to be useful.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initiateAgents(map, numAgents, probInit, asSpatialPoints = TRUE, indices)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initiateAgents_+3A_map">map</code></td>
<td>
<p><code>RasterLayer</code> with extent and resolution of desired return object</p>
</td></tr>
<tr><td><code id="initiateAgents_+3A_numagents">numAgents</code></td>
<td>
<p>numeric resulting from a call to <code><a href="#topic+numAgents">numAgents()</a></code></p>
</td></tr>
<tr><td><code id="initiateAgents_+3A_probinit">probInit</code></td>
<td>
<p>a <code>Raster</code> resulting from a <code><a href="#topic+probInit">probInit()</a></code> call</p>
</td></tr>
<tr><td><code id="initiateAgents_+3A_asspatialpoints">asSpatialPoints</code></td>
<td>
<p>logical or <code>"sf"</code>. Should returned object be <code>RasterLayer</code>
or <code>SpatVector</code> default (or legacy <code>TRUE</code> <code>SpatialPointsDataFrame</code>)</p>
</td></tr>
<tr><td><code id="initiateAgents_+3A_indices">indices</code></td>
<td>
<p>numeric. Indices of where agents should start</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>SpatialPointsDataFrame</code>, with each row representing an individual agent
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("sf", quietly = TRUE)) {
  library(data.table)
  library(terra)

  origDTThreads &lt;- data.table::setDTthreads(2L)
  origNcpus &lt;- options(Ncpus = 2L)

  map &lt;- rast(system.file("extdata", "map.tif", package = "SpaDES.tools"))
  names(map) &lt;- "layer"
  pr &lt;- probInit(map, p = (map[] / terra::minmax(map)[2])^2)
  agents &lt;- initiateAgents(map, 100, pr, asSpatialPoints = "sf")
  if (interactive()) {
    terra::plot(map)
    terra::plot(agents, add = TRUE)
  }
  # Test that they are indeed selecting according to probabilities in pr
  dt1 &lt;- data.table(table(round(extract(map, agents), 0)[, "layer"]))
  setnames(dt1, old = "N", new = "count")
  dt2 &lt;- data.table(table(round(map[], 0)))
  setnames(dt2, old = "N", new = "available")
  dt &lt;- dt1[dt2, on = "V1"]  # join the counts and available data.tables
  setnames(dt, old = "V1", new = "mapValue")
  dt[, selection := count / available]
  dt[is.na(selection), selection := 0]
  if (interactive()) {
    with(dt, plot(mapValue, selection))
  }
  #'
  # Note, can also produce a Raster representing agents,
  # then the number of points produced can't be more than
  # the number of pixels:
  agentsRas &lt;- initiateAgents(map, 30, pr, asSpatialPoints = FALSE)
  if (interactive()) {
    terra::plot(agentsRas)
  }
  #'
  # clean up
  data.table::setDTthreads(origDTThreads)
  options(Ncpus = origNcpus)
}
</code></pre>

<hr>
<h2 id='inRange'>Test whether a number lies within range <code style="white-space: pre;">&#8288;[a,b]&#8288;</code></h2><span id='topic+inRange'></span>

<h3>Description</h3>

<p>Default values of <code style="white-space: pre;">&#8288;a=0; b=1&#8288;</code> allow for quick test if
<code>x</code> is a probability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inRange(x, a = 0, b = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inRange_+3A_x">x</code></td>
<td>
<p>values to be tested</p>
</td></tr>
<tr><td><code id="inRange_+3A_a">a</code></td>
<td>
<p>lower bound (default 0)</p>
</td></tr>
<tr><td><code id="inRange_+3A_b">b</code></td>
<td>
<p>upper bound (default 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical vectors. <code>NA</code> values in <code>x</code> are retained.
</p>


<h3>Author(s)</h3>

<p>Alex Chubaty
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(100)
x &lt;- stats::rnorm(4) # -0.50219235  0.13153117 -0.07891709  0.88678481
inRange(x, 0, 1)

</code></pre>

<hr>
<h2 id='mergeRaster'>Split and re-merge <code>RasterLayer</code>(s)</h2><span id='topic+mergeRaster'></span><span id='topic+mergeRaster+2Clist-method'></span><span id='topic+splitRaster'></span>

<h3>Description</h3>

<p><code>splitRaster</code> divides up a raster into an arbitrary number of pieces (tiles).
Split rasters can be recombined using <code>do.call(merge, y)</code> or <code>mergeRaster(y)</code>,
where <code>y &lt;- splitRaster(x)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeRaster(x, fun = NULL)

## S4 method for signature 'list'
mergeRaster(x, fun = NULL)

splitRaster(
  r,
  nx = 1,
  ny = 1,
  buffer = c(0, 0),
  path = NA,
  cl,
  rType = "FLT4S",
  fExt = ".tif"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeRaster_+3A_x">x</code></td>
<td>
<p>A list of split raster tiles (i.e., from <code>splitRaster</code>).</p>
</td></tr>
<tr><td><code id="mergeRaster_+3A_fun">fun</code></td>
<td>
<p>Function (e.g. <code>mean</code>, <code>min</code>, or <code>max</code> that
accepts a <code>na.rm</code> argument. The default is <code>mean</code>.</p>
</td></tr>
<tr><td><code id="mergeRaster_+3A_r">r</code></td>
<td>
<p>The raster to be split.</p>
</td></tr>
<tr><td><code id="mergeRaster_+3A_nx">nx</code></td>
<td>
<p>The number of tiles to make along the x-axis.</p>
</td></tr>
<tr><td><code id="mergeRaster_+3A_ny">ny</code></td>
<td>
<p>The number of tiles to make along the y-axis.</p>
</td></tr>
<tr><td><code id="mergeRaster_+3A_buffer">buffer</code></td>
<td>
<p>Numeric vector of length 2 giving the size of the buffer along the x and y axes.
If values greater than or equal to <code>1</code> are used, this
is interpreted as the number of pixels (cells) to use as a buffer.
Values between <code>0</code> and <code>1</code> are interpreted as proportions
of the number of pixels in each tile (rounded up to an integer value).
Default is <code>c(0, 0)</code>, which means no buffer.</p>
</td></tr>
<tr><td><code id="mergeRaster_+3A_path">path</code></td>
<td>
<p>Character specifying the directory to which the split tiles will be saved.
If missing, the function will write to memory.</p>
</td></tr>
<tr><td><code id="mergeRaster_+3A_cl">cl</code></td>
<td>
<p>A cluster object. Optional. This would generally be created using
<code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code> or equivalent. This is an alternative way, instead
of <code>beginCluster()</code>, to use parallelism for this function, allowing for
more control over cluster use.</p>
</td></tr>
<tr><td><code id="mergeRaster_+3A_rtype">rType</code></td>
<td>
<p>Data type of the split rasters. Defaults to FLT4S.</p>
</td></tr>
<tr><td><code id="mergeRaster_+3A_fext">fExt</code></td>
<td>
<p>file extension (e.g., <code>".grd"</code> or <code>".tif"</code>) specifying the file format.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mergeRaster</code> differs from <code>merge</code> in how overlapping tile regions
are handled: <code>merge</code> retains the values of the first raster in the list.
This has the consequence of retaining the values from the buffered
region in the first tile in place of the values from the neighbouring tile.
On the other hand, <code>mergeRaster</code> retains the values of the tile region,
over the values in any buffered regions.
This is useful for reducing edge effects when performing raster operations involving
contagious processes.
</p>
<p>This function is parallel-aware using the same mechanism as used in <span class="pkg">raster</span>:
NOTE: This may not work as expected as we transition away from <code>raster</code>.
Specifically, if you start a cluster using <code>raster::beginCluster()</code>,
then this function will automatically use that cluster.
It is always a good idea to stop the cluster when finished, using <code>raster::endCluster()</code>.
</p>


<h3>Value</h3>

<p><code>mergeRaster</code> returns a <code>RasterLayer</code> object.
</p>
<p><code>splitRaster</code> returns a list (length <code>nx*ny</code>) of cropped raster tiles.
</p>


<h3>Author(s)</h3>

<p>Yong Luo, Alex Chubaty, Tati Micheletti &amp; Ian Eddy
</p>
<p>Alex Chubaty and Yong Luo
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+merge">terra::merge()</a></code>, <code><a href="terra.html#topic+mosaic">terra::mosaic()</a></code>
</p>
<p><code><a href="base.html#topic+do.call">do.call()</a></code>, <code><a href="terra.html#topic+merge">terra::merge()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)

origDTThreads &lt;- data.table::setDTthreads(2L)
origNcpus &lt;- options(Ncpus = 2L)
set.seed(1462)

## an example with dimensions: nrow = 77,  ncol = 101, nlayers = 3
b &lt;- rast(system.file("ex/logo.tif", package = "terra"))
r &lt;- b[[1]] # use first layer only
nx &lt;- 3
ny &lt;- 4

tmpdir &lt;- dir.create(file.path(tempdir(), "splitRaster-example"), showWarnings = FALSE)

y0 &lt;- splitRaster(r, nx, ny, path = file.path(tmpdir, "y0")) # no buffer

## buffer: 10 pixels along both axes
y1 &lt;- splitRaster(r, nx, ny, c(10, 10), path = file.path(tmpdir, "y1"))

## buffer: half the width and length of each tile
y2 &lt;- splitRaster(r, nx, ny, c(0.5, 0.5), path = file.path(tmpdir, "y2"))

## the original raster:
if (interactive()) plot(r) # may require a call to `dev()` if using RStudio

## the split raster:
layout(mat = matrix(seq_len(nx * ny), ncol = nx, nrow = ny))
plotOrder &lt;- unlist(lapply(split(1:12, rep(1:nx, each = ny)), rev))

if (interactive()) {
  invisible(lapply(y0[plotOrder], terra::plot))
}

## parallel splitting
if (requireNamespace("raster", quietly = TRUE) &amp;&amp;
    requireNamespace("parallel")) {
  if (interactive()) {
    n &lt;- pmin(parallel::detectCores(), 4) # use up to 4 cores
    raster::beginCluster(n, type = "PSOCK")
    y3 &lt;- splitRaster(r, nx, ny, c(0.7, 0.7), path = file.path(tmpdir, "y3"))
    raster::endCluster()
    if (interactive()) {
      invisible(lapply(y3[plotOrder], terra::plot))
    }
  }
}

## can be recombined using `terra::merge`
m0 &lt;- do.call(merge, y0)
all.equal(m0, r) ## TRUE

m1 &lt;- do.call(merge, y1)
all.equal(m1, r) ## TRUE

m2 &lt;- do.call(merge, y2)
all.equal(m2, r) ## TRUE

## or recombine using mergeRaster
n0 &lt;- mergeRaster(y0)
all.equal(n0, r) ## TRUE

n1 &lt;- mergeRaster(y1)
all.equal(n1, r) ## TRUE

n2 &lt;- mergeRaster(y2)
all.equal(n2, r) ## TRUE

# clean up
data.table::setDTthreads(origDTThreads)
options(Ncpus = origNcpus)
unlink(tmpdir, recursive = TRUE)
</code></pre>

<hr>
<h2 id='middlePixel'>Return the (approximate) middle pixel on a raster</h2><span id='topic+middlePixel'></span>

<h3>Description</h3>

<p>Return the (approximate) middle pixel on a raster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>middlePixel(ras)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="middlePixel_+3A_ras">ras</code></td>
<td>
<p>A <code>Raster</code> or <code>SpatRaster</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This calculation is slightly different depending on whether
the <code>nrow(ras)</code> and <code>ncol(ras)</code> are even or odd.
It will return the exact middle pixel if these are odd, and
the pixel just left and/or above the middle pixel if either
dimension is even, respectively.
</p>

<hr>
<h2 id='move'>Move</h2><span id='topic+move'></span><span id='topic+crw'></span>

<h3>Description</h3>

<p>Wrapper for selecting different animal movement methods.
</p>
<p>This version uses just turn angles and step lengths to define the correlated random walk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>move(hypothesis = "crw", ...)

crw(
  agent,
  extent,
  stepLength,
  stddev,
  lonlat = FALSE,
  torus = FALSE,
  returnMatrix = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="move_+3A_hypothesis">hypothesis</code></td>
<td>
<p>Character vector, length one, indicating which movement
hypothesis/method to test/use. Currently defaults to
'crw' (correlated random walk) using <code>crw</code>.</p>
</td></tr>
<tr><td><code id="move_+3A_...">...</code></td>
<td>
<p>arguments passed to the function in <code>hypothesis</code></p>
</td></tr>
<tr><td><code id="move_+3A_agent">agent</code></td>
<td>
<p>A <code>SpatVector</code> points geometry or a <code style="white-space: pre;">&#8288;SpatialPoints*&#8288;</code> (deprecated) object.
If is has attributes, e.g., <code>SpatialPointsDataFrame</code>,
2 of the columns must
be <code>x1</code> and <code>y1</code>, indicating the previous location.
If it does not have these columns as attributes, <code>x1</code> and
<code>y1</code> will be assigned randomly.</p>
</td></tr>
<tr><td><code id="move_+3A_extent">extent</code></td>
<td>
<p>An optional <code>Extent</code> object that will be used for <code>torus</code>.</p>
</td></tr>
<tr><td><code id="move_+3A_steplength">stepLength</code></td>
<td>
<p>Numeric vector of length 1 or number of agents describing
step length.</p>
</td></tr>
<tr><td><code id="move_+3A_stddev">stddev</code></td>
<td>
<p>Numeric vector of length 1 or number of agents describing
standard deviation of wrapped normal turn angles.</p>
</td></tr>
<tr><td><code id="move_+3A_lonlat">lonlat</code></td>
<td>
<p>Logical. If <code>TRUE</code>, coordinates should be in degrees.
If <code>FALSE</code> coordinates represent planar ('Euclidean')
space (e.g. units of meters)</p>
</td></tr>
<tr><td><code id="move_+3A_torus">torus</code></td>
<td>
<p>Logical. Should the movement be wrapped to the opposite
side of the map, as determined by the <code>extent</code> argument.
Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="move_+3A_returnmatrix">returnMatrix</code></td>
<td>
<p>If <code>TRUE</code> then the return object will be a <code>matrix</code>. This will
be MUCH faster than retaining the <code>sp</code> or <code>SpatVector</code> class,
and thus will be much more effective for iterative <code>crw</code> calls</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This simple version of a correlated random walk is largely the version that
was presented in Turchin 1998, but it was also used with bias modifications
in McIntire, Schultz, Crone 2007.
</p>


<h3>Value</h3>

<p>A <code>SpatVector</code> points object with updated spatial position defined
by a single occurrence of step length(s) and turn angle(s).
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>


<h3>References</h3>

<p>Turchin, P. 1998. Quantitative analysis of movement: measuring and
modeling population redistribution in animals and plants.
Sinauer Associates, Sunderland, MA.
</p>
<p>McIntire, E. J. B., C. B. Schultz, and E. E. Crone. 2007.
Designing a network for butterfly habitat restoration: where
individuals, populations and landscapes interact.
Journal of Applied Ecology 44:725-736.
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+distance">terra::distance()</a></code>
</p>
<p><code><a href="#topic+wrap">wrap()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>origDTThreads &lt;- data.table::setDTthreads(2L)
origNcpus &lt;- options(Ncpus = 2L)

# using just matrix
N &lt;- 10
xrange &lt;- yrange &lt;- c(-50, 50)
starts &lt;- cbind(x = stats::runif(N, xrange[1], xrange[2]),
                y = stats::runif(N, yrange[1], yrange[2]))
moved &lt;- crw(starts, stepLength = 5, stddev = 10)
plot(starts, col = rainbow(10), pch = 19)
points(moved, col = rainbow(10))

# as SpatVector
agent &lt;- terra::vect(starts)
moved &lt;- crw(agent, stepLength = 5, stddev = 10)
movedAgain &lt;- crw(moved, stepLength = 5, stddev = 10)
terra::plot(agent)
terra::plot(moved, add = TRUE, col = "red")
terra::plot(movedAgain, add = TRUE, col = "green")

# 1000x faster!! -- returnMatrix = TRUE
agentOrig &lt;- agent
reps &lt;- 1e2
system.time({
  for (i in 1:reps) agent &lt;- crw(agent, stepLength = 5, stddev = 10, returnMatrix = TRUE)
})
agent &lt;- agentOrig
system.time({
  for (i in 1:reps) agent &lt;- crw(agent, stepLength = 5, stddev = 10)
})

# as sp
if (requireNamespace("sp")) {
  agent &lt;- sp::SpatialPoints(starts)
  spdf &lt;- crw(agent, stepLength = 5, stddev = 10)
  spdfNew &lt;- crw(spdf, stepLength = 5, stddev = 10)
  terra::plot(spdf, pch = 19)
  terra::points(spdfNew, col = "blue", pch = 19)
}

# clean up
data.table::setDTthreads(origDTThreads)
options(Ncpus = origNcpus)

</code></pre>

<hr>
<h2 id='neutralLandscapeMap'>Produce a neutral landscape using a midpoint displacement algorithm</h2><span id='topic+neutralLandscapeMap'></span>

<h3>Description</h3>

<p>This is a wrapper for the <code>nlm_mpd</code> function in the <code>NLMR</code> package.
The main addition is that it makes sure that the output raster conforms
in extent with the input raster <code>x</code>, since <code>nlm_mpd</code> can output a smaller raster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neutralLandscapeMap(
  x,
  pad = 10L,
  type = c("nlm_mpd", "nlm_gaussianfield", "nlm_distancegradient", "nlm_edgegradient",
    "nlm_fbm", "nlm_mosaicfield", "nlm_mosaicgibbs", "nlm_mosaictess", "nlm_neigh",
    "nlm_percolation", "nlm_planargradient", "nlm_random",
    "nlm_randomrectangularcluster"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neutralLandscapeMap_+3A_x">x</code></td>
<td>
<p>A <code>RasterLayer</code>/<code>SpatRaster</code> to use as a template.</p>
</td></tr>
<tr><td><code id="neutralLandscapeMap_+3A_pad">pad</code></td>
<td>
<p>Integer. Number of cells by which to pad <code>x</code> internally to ensure
<code>nlm_mpd</code> produces a raster corresponding to the dimensions of <code>x</code>.</p>
</td></tr>
<tr><td><code id="neutralLandscapeMap_+3A_type">type</code></td>
<td>
<p>One of the supported <code>NLMR</code> functions.</p>
</td></tr>
<tr><td><code id="neutralLandscapeMap_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>NLMR</code> function specified in <code>type</code>
(except <code>ncol</code>, <code>nrow</code> and <code>resolution</code>, which are extracted from <code>x</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>RasterLayer</code>/<code>SpatRaster</code> with same extent as <code>x</code>, with randomly generated values.
</p>


<h3>See Also</h3>

<p><code>nlm_mpd</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  if (requireNamespace("NLMR", quietly = TRUE) &amp;&amp;
      requireNamespace("raster", quietly = TRUE)) {
    library(terra)
    nx &lt;- ny &lt;- 100L
    r &lt;- rast(nrows = ny, ncols = nx,
              xmin = -nx/2, xmax = nx/2,
              ymin = -ny/2, ymax = ny/2)
    ## or with raster package:
    # r &lt;- raster::raster(nrows = ny, ncols = nx,
    #                     xmn = -nx/2, xmx = nx/2,
    #                     ymn = -ny/2, ymx = ny/2)
    map1 &lt;- neutralLandscapeMap(r,
                                type = "nlm_mpd",
                                roughness = 0.65,
                                rand_dev = 200,
                                rescale = FALSE,
                                verbose = FALSE)
    if (interactive()) plot(map1)
  }

</code></pre>

<hr>
<h2 id='numAgents'>SELES - Number of Agents to initiate</h2><span id='topic+numAgents'></span>

<h3>Description</h3>

<p>Sets the the number of agents to initiate. THIS IS NOT YET FULLY IMPLEMENTED.
</p>
<p>A <code>SELES</code>-like function to maintain conceptual backwards compatibility
with that simulation tool. This is intended to ease transitions from
<a href="http://www.gowlland.ca/">SELES</a>.
</p>
<p>You must know how to use SELES for these to be useful.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numAgents(N, probInit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="numAgents_+3A_n">N</code></td>
<td>
<p>Number of agents to initiate (integer scalar).</p>
</td></tr>
<tr><td><code id="numAgents_+3A_probinit">probInit</code></td>
<td>
<p>Probability of initializing an agent at the location.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric, indicating number of agents to start
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>

<hr>
<h2 id='patchSize'>Patch size</h2><span id='topic+patchSize'></span>

<h3>Description</h3>

<p>Patch size
</p>


<h3>Usage</h3>

<pre><code class='language-R'>patchSize(patches)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="patchSize_+3A_patches">patches</code></td>
<td>
<p>Number of patches.</p>
</td></tr>
</table>

<hr>
<h2 id='probInit'><code>SELES</code> - Probability of Initiation</h2><span id='topic+probInit'></span>

<h3>Description</h3>

<p>Describes the probability of initiation of agents or events.
<em>THIS IS NOT FULLY IMPLEMENTED.</em>
</p>
<p>A <code>SELES</code>-like function to maintain conceptual backwards compatibility
with that simulation tool. This is intended to ease transitions from
<a href="http://www.gowlland.ca/">SELES</a>.
</p>
<p>You must know how to use SELES for these to be useful.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>probInit(map, p = NULL, absolute = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="probInit_+3A_map">map</code></td>
<td>
<p>A <code>spatialObjects</code> object. Currently, only provides CRS and, if p is not
a raster, then all the raster dimensions.</p>
</td></tr>
<tr><td><code id="probInit_+3A_p">p</code></td>
<td>
<p>probability, provided as a numeric or raster</p>
</td></tr>
<tr><td><code id="probInit_+3A_absolute">absolute</code></td>
<td>
<p>logical. Is <code>p</code> absolute probabilities or relative?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>RasterLayer</code> with probabilities of initialization.
There are several combinations of inputs possible and they each result
in different behaviours.
</p>
<p>If <code>p</code> is numeric or <code>Raster</code> and between 0 and 1, it is treated as an
absolute probability, and a map will be produced with the p value(s) everywhere.
</p>
<p>If <code>p</code> is numeric or <code>Raster</code> and not between 0 and 1, it is treated as a
relative probability, and a map will be produced with <code>p/max(p)</code> value(s) everywhere.
</p>
<p>If <code>absolute</code> is provided, it will override the previous statements, unless
<code>absolute = TRUE</code> and p is not between 0 and 1 (i.e., is not a probability).
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>

<hr>
<h2 id='randomPolygons'>Produce a <code>SpatRaster</code> of  random polygons</h2><span id='topic+randomPolygons'></span><span id='topic+randomPolygon'></span><span id='topic+randomPolygon.default'></span>

<h3>Description</h3>

<p>These are built with the <code><a href="#topic+spread">spread()</a></code> function internally.
</p>
<p>Produces a <code>SpatVector</code> polygons object with 1 feature that will have approximately an area
equal to <code>area</code> (expecting area in hectares), #' and a centre at approximately <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomPolygons(
  ras = rast(ext(0, 15, 0, 15), res = 1, vals = 0),
  numTypes = 2,
  ...
)

randomPolygon(x, hectares, area)

## Default S3 method:
randomPolygon(x, hectares, area)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randomPolygons_+3A_ras">ras</code></td>
<td>
<p>A raster that whose extent will be used for the random polygons.</p>
</td></tr>
<tr><td><code id="randomPolygons_+3A_numtypes">numTypes</code></td>
<td>
<p>Numeric value. The number of unique polygon types to use.</p>
</td></tr>
<tr><td><code id="randomPolygons_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>spread</code>. No known uses currently.</p>
</td></tr>
<tr><td><code id="randomPolygons_+3A_x">x</code></td>
<td>
<p>Either a <code>SpatVector</code>, or <code>SpatialPoints</code> (deprecated), <code>SpatialPolygons</code> (deprecated),
or <code>matrix</code> with two dimensions, 1 row, with the approximate centre of the new random
polygon to create.
If <code>matrix</code>, then longitude and latitude are assumed (<code>epsg:4326</code>).</p>
</td></tr>
<tr><td><code id="randomPolygons_+3A_hectares">hectares</code></td>
<td>
<p>Deprecated. Use <code>area</code> in meters squared.</p>
</td></tr>
<tr><td><code id="randomPolygons_+3A_area">area</code></td>
<td>
<p>A numeric, the approximate area in <code style="white-space: pre;">&#8288;meters squared&#8288;</code> of the random polygon.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A map of extent <code>ext</code> with random polygons.
</p>
<p>A <code>SpatVector</code> polygons object, with approximately the area request,
centred approximately at the coordinates requested, in the projection of <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spread">spread()</a></code>, <code><a href="#topic+randomPolygons">randomPolygons()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>origDTThreads &lt;- data.table::setDTthreads(2L)
origNcpus &lt;- options(Ncpus = 2L)

set.seed(1234)
Ras &lt;- randomPolygons(numTypes = 5)
if (interactive() ) {
  terra::plot(Ras, col = c("yellow", "dark green", "blue", "dark red"))
}

# more complex patterning, with a range of patch sizes
r &lt;- terra::rast(terra::ext(0, 50, 0, 50), resolution = 1, vals = 0)
a &lt;- randomPolygons(numTypes = 400, r)
a[a &lt; 320] &lt;- 0
a[a &gt;= 320] &lt;- 1
clumped &lt;- terra::patches(a)
if (interactive()) {
  terra::plot(a)
}

# clean up
data.table::setDTthreads(origDTThreads)
options(Ncpus = origNcpus)

a1 &lt;- terra::vect(cbind(-110, 59), crs = "epsg:4326")
a2 &lt;- randomPolygon(a1, area = 1e7)

if (interactive()) {
  terra::plot(a1)
  terra::points(a2, pch = 19)
}

if (require("sf", quietly = TRUE)) {
  b1 &lt;- list(cbind(
    x = c(-122.98, -116.1, -99.2, -106, -122.98),
    y = c(59.9, 65.73, 63.58, 54.79, 59.9)
  )) |&gt;
    sf::st_polygon() |&gt;
    sf::st_sfc() |&gt;
    sf::st_sf(geometry = _, ID = 1L, shinyLabel = "zone2", crs = "epsg:4326")
  b2 &lt;- randomPolygon(b1, area = 1e10)

  if (interactive()) {
    plot(sf::st_geometry(b1))
    plot(sf::st_geometry(b2), add = TRUE)
  }
}
</code></pre>

<hr>
<h2 id='randomStudyArea'>Create default study areas for use with <code>SpaDES</code> modules</h2><span id='topic+randomStudyArea'></span>

<h3>Description</h3>

<p>Create default study areas for use with <code>SpaDES</code> modules
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomStudyArea(center = NULL, size = 10000, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randomStudyArea_+3A_center">center</code></td>
<td>
<p><code>SpatialPoints</code> object specifying a set of coordinates and
a projection. Default is an area in southern Alberta, Canada.</p>
</td></tr>
<tr><td><code id="randomStudyArea_+3A_size">size</code></td>
<td>
<p>Numeric specifying the approximate size of the area in m^2.
Default <code>1e4</code>.</p>
</td></tr>
<tr><td><code id="randomStudyArea_+3A_seed">seed</code></td>
<td>
<p>Numeric indicating the random seed to set internally
(useful for ensuring the same study area is produced each time).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>SpatVector</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- randomStudyArea(seed = 123)
if (interactive()) {
  terra::plot(a)
}
</code></pre>

<hr>
<h2 id='rasterizeReduced'>Convert reduced representation to full raster</h2><span id='topic+rasterizeReduced'></span>

<h3>Description</h3>

<p>Convert reduced representation to full raster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rasterizeReduced(
  reduced,
  fullRaster,
  newRasterCols,
  mapcode = names(fullRaster),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rasterizeReduced_+3A_reduced">reduced</code></td>
<td>
<p><code>data.frame</code> or <code>data.table</code> that has at least one
column of codes that are represented in the <code>fullRaster</code>.</p>
</td></tr>
<tr><td><code id="rasterizeReduced_+3A_fullraster">fullRaster</code></td>
<td>
<p><code>RasterLayer</code>/<code>SpatRaster</code> of codes used in <code>reduced</code> that
represents a spatial representation of the data. Note that
if <code>fullRaster</code> is a <code>factor</code> <code>SpatRaster</code>, the active category
level values are used, not the IDs (see <code>terra::activeCat</code> and
<code>terra::cats</code>)</p>
</td></tr>
<tr><td><code id="rasterizeReduced_+3A_newrastercols">newRasterCols</code></td>
<td>
<p>Character vector, length 1 or more, with the name(s) of
the column(s) in <code>reduced</code> whose value will be
returned as a <code>RasterLayer</code>/<code>SpatRaster</code> or list
of <code>RasterLayer</code>/<code>SpatRaster</code>s.</p>
</td></tr>
<tr><td><code id="rasterizeReduced_+3A_mapcode">mapcode</code></td>
<td>
<p>a character, length 1, with the name of the column in <code>reduced</code>
that is represented in <code>fullRaster</code>.</p>
</td></tr>
<tr><td><code id="rasterizeReduced_+3A_...">...</code></td>
<td>
<p>Other arguments. None used yet.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>RasterLayer</code>/<code>SpatRaster</code> or list of
<code>RasterLayer</code>/<code>SpatRaster</code> of with same dimensions as <code>fullRaster</code> representing
<code>newRasterCols</code> spatially, according to the join between the <code>mapcode</code>
contained within <code>reduced</code> and <code>fullRaster</code>
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>


<h3>See Also</h3>

<p><code><a href="terra.html#topic+rast">terra::rast()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
library(terra)

origDTThreads &lt;- data.table::setDTthreads(2L)
origNcpus &lt;- options(Ncpus = 2L)

ras &lt;- rast(ext(0, 15, 0, 15), res = 1)
fullRas &lt;- randomPolygons(ras, numTypes = 2)
names(fullRas) &lt;- "mapcodeAll"
uniqueComms &lt;- unique(fullRas)
reducedDT &lt;- data.table(uniqueComms,
                        communities = sample(1:1000, length(uniqueComms)),
                        biomass = rnbinom(length(uniqueComms), mu = 4000, 0.4))
biomass &lt;- rasterizeReduced(reducedDT, fullRas, "biomass")

# The default key is the layer name of the fullRas, so rekey incase of miskey
setkey(reducedDT, biomass)

communities &lt;- rasterizeReduced(reducedDT, fullRas, "communities")
coltab(communities) &lt;- c("blue", "orange", "red")
if (interactive()) {
  terra::plot(c(biomass, communities, fullRas))
}

## with a factor SpatRaster, the mapcode should correspond to the
## active category (not the ids)
cls &lt;- data.frame(id = sort(unique(as.vector(fullRas[]))))
cls$Bclass &lt;- LETTERS[cls$id]
levels(fullRas) &lt;- cls
is.factor(fullRas)

clsDT &lt;- as.data.table(cls)
reducedDT &lt;- reducedDT[clsDT, on = "mapcodeAll==id"]
reducedDT[, mapcodeAll := Bclass]

biomass2 &lt;- rasterizeReduced(reducedDT, fullRas, "biomass")

# clean up
data.table::setDTthreads(origDTThreads)
options(Ncpus = origNcpus)
</code></pre>

<hr>
<h2 id='rbindlistDtDtpot'>Internal helpers</h2><span id='topic+rbindlistDtDtpot'></span><span id='topic+reorderColsWDistance'></span><span id='topic+angleQuality'></span><span id='topic+asymmetryAdjust'></span>

<h3>Description</h3>

<p>Not for users.
A function to <code>setnames</code> and <code>rbindlist</code> that is used in <code>spread2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbindlistDtDtpot(
  dt,
  dtPotential,
  returnFrom,
  needDistance,
  dtPotentialColNames
)

reorderColsWDistance(needDistance, dtPotential, dtPotentialColNames)

angleQuality(from, to, landscape, actualAsymmetryAngle)

asymmetryAdjust(angleQualities, quantity, actualAsymmetry)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbindlistDtDtpot_+3A_dt">dt</code></td>
<td>
<p>a <code>data.table</code> object</p>
</td></tr>
<tr><td><code id="rbindlistDtDtpot_+3A_dtpotential">dtPotential</code></td>
<td>
<p>a <code>data.table</code> object</p>
</td></tr>
<tr><td><code id="rbindlistDtDtpot_+3A_returnfrom">returnFrom</code></td>
<td>
<p>logical</p>
</td></tr>
<tr><td><code id="rbindlistDtDtpot_+3A_needdistance">needDistance</code></td>
<td>
<p>logical</p>
</td></tr>
<tr><td><code id="rbindlistDtDtpot_+3A_dtpotentialcolnames">dtPotentialColNames</code></td>
<td>
<p>character vector.</p>
</td></tr>
<tr><td><code id="rbindlistDtDtpot_+3A_from">from</code></td>
<td>
<p>vector of cell locations which are the &quot;from&quot; or starting cells</p>
</td></tr>
<tr><td><code id="rbindlistDtDtpot_+3A_to">to</code></td>
<td>
<p>vector of same length as <code>from</code> which are the &quot;to&quot; or receiving cells</p>
</td></tr>
<tr><td><code id="rbindlistDtDtpot_+3A_landscape">landscape</code></td>
<td>
<p><code>RasterLayer</code> passed from <code>spread2</code>.</p>
</td></tr>
<tr><td><code id="rbindlistDtDtpot_+3A_actualasymmetryangle">actualAsymmetryAngle</code></td>
<td>
<p>Angle in degrees, either a vector length 1 or vector
<code>NROW(dtPotential)</code>.</p>
</td></tr>
<tr><td><code id="rbindlistDtDtpot_+3A_anglequalities">angleQualities</code></td>
<td>
<p>Matrix. The output from <code>angleQuality</code></p>
</td></tr>
<tr><td><code id="rbindlistDtDtpot_+3A_quantity">quantity</code></td>
<td>
<p>Variable of interest to adjust, e.g., <code>spreadProb</code></p>
</td></tr>
<tr><td><code id="rbindlistDtDtpot_+3A_actualasymmetry">actualAsymmetry</code></td>
<td>
<p>Asymmetry intensity. Derived from <code>asymmetry</code> arg in <code>spread2</code></p>
</td></tr>
</table>

<hr>
<h2 id='resample'>Adapted directly from the <code><a href="base.html#topic+sample">base::sample()</a></code> help file.</h2><span id='topic+resample'></span><span id='topic+resampleZeroProof'></span>

<h3>Description</h3>

<p>Adapted directly from the <code><a href="base.html#topic+sample">base::sample()</a></code> help file.
</p>
<p><code>resampleZeroProof</code> is a version that works even if sum of all
probabilities passed to <code>sample.int</code> is zero.
This causes an error in <code>sample.int</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample(x, ...)

resampleZeroProof(spreadProbHas0, x, n, prob)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_+3A_x">x</code></td>
<td>
<p>either a vector of one or more elements from which to choose,
or a positive integer.  See &lsquo;Details.&rsquo;</p>
</td></tr>
<tr><td><code id="resample_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="base.html#topic+sample">base::sample()</a></code></p>
</td></tr>
<tr><td><code id="resample_+3A_spreadprobhas0">spreadProbHas0</code></td>
<td>
<p>logical. Does <code>spreadProb</code> have any zeros on it.</p>
</td></tr>
<tr><td><code id="resample_+3A_n">n</code></td>
<td>
<p>a positive number, the number of items to choose from.  See
&lsquo;Details.&rsquo;</p>
</td></tr>
<tr><td><code id="resample_+3A_prob">prob</code></td>
<td>
<p>a vector of probability weights for obtaining the elements
of the vector being sampled.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Intended for internal use only.
</p>

<hr>
<h2 id='rings'>Identifies all cells within a ring around the focal cells</h2><span id='topic+rings'></span>

<h3>Description</h3>

<p>Identifies the cell numbers of all cells within a ring defined by  minimum
and maximum distances from focal cells.
Uses <code><a href="#topic+spread">spread()</a></code> under the hood, with specific values set.
Under many situations, this may be faster than using <code>sf::st_buffer</code> twice
(once for smaller ring and once for larger ring, then removing the smaller ring cells).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rings(
  landscape,
  loci = NA_real_,
  id = FALSE,
  minRadius = 2,
  maxRadius = 5,
  allowOverlap = FALSE,
  returnIndices = FALSE,
  returnDistances = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rings_+3A_landscape">landscape</code></td>
<td>
<p>A <code>RasterLayer</code> or <code>SpatRaster</code> object. This defines the possible
locations for spreading events to start and spread into.
This can also be used as part of <code>stopRule</code>.</p>
</td></tr>
<tr><td><code id="rings_+3A_loci">loci</code></td>
<td>
<p>A vector of locations in <code>landscape</code>.
These should be cell indices.
If user has x and y coordinates, these can be converted
with <code><a href="terra.html#topic+xyCellFrom">cellFromXY()</a></code>.</p>
</td></tr>
<tr><td><code id="rings_+3A_id">id</code></td>
<td>
<p>Logical. If <code>TRUE</code>, returns a raster of events ids.
If <code>FALSE</code>, returns a raster of iteration numbers,
i.e., the spread history of one or more events.
NOTE: this is overridden if <code>returnIndices</code> is <code>TRUE</code>
or <code>1</code> or <code>2</code>.</p>
</td></tr>
<tr><td><code id="rings_+3A_minradius">minRadius</code></td>
<td>
<p>Numeric. Minimum radius to be included in the ring.
Note: this is inclusive, i.e., <code>&gt;=</code>.</p>
</td></tr>
<tr><td><code id="rings_+3A_maxradius">maxRadius</code></td>
<td>
<p>Numeric. Maximum radius to be included in the ring.
Note: this is inclusive, i.e., <code>&lt;=</code>.</p>
</td></tr>
<tr><td><code id="rings_+3A_allowoverlap">allowOverlap</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then individual events can overlap
with one another, i.e., they do not interact (this is slower
than if <code>allowOverlap = FALSE</code>).
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="rings_+3A_returnindices">returnIndices</code></td>
<td>
<p>Logical or numeric. If <code>1</code> or <code>TRUE</code>, will return a <code>data.table</code>
with indices and values of successful spread events.
If <code>2</code>, it will simply return a vector of pixel indices of
all cells that were touched. This will be the fastest option.
If <code>FALSE</code>, then it will return a raster with values.
See Details.</p>
</td></tr>
<tr><td><code id="rings_+3A_returndistances">returnDistances</code></td>
<td>
<p>Logical. Should the function include a column with the
individual cell distances from the locus where that event
started. Default is <code>FALSE</code>.
See Details.</p>
</td></tr>
<tr><td><code id="rings_+3A_...">...</code></td>
<td>
<p>Any other argument passed to <code>spread</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>This will return  a <code>data.table</code> with columns as described in
<code>spread</code> when <code>returnIndices = TRUE</code>.
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cir">cir()</a></code> which uses a different algorithm.
<code>cir</code> tends to be faster when there are few starting points, <code>rings</code>
tends to be faster when there are many starting points. Another difference
between the two functions is that <code>rings</code> takes the centre of the pixel
as the centre of a circle, whereas <code>cir</code> takes the exact coordinates.
See example.
</p>
<p><code>sf::st_buffer</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)

origDTThreads &lt;- data.table::setDTthreads(2L)
origNcpus &lt;- options(Ncpus = 2L)
set.seed(1462)

# Make random forest cover map
emptyRas &lt;- terra::rast(terra::ext(0, 1e2, 0, 1e2), res = 1)

# start from two cells near middle
loci &lt;- (ncell(emptyRas) / 2 - ncol(emptyRas)) / 2 + c(-3, 3)

# No overlap is default, occurs randomly
emptyRas[] &lt;- 0
rngs &lt;- rings(emptyRas, loci = loci, minRadius = 7, maxRadius = 9, returnIndices = TRUE)
emptyRas[rngs$indices] &lt;- rngs$id
if (interactive()) {
  terra::plot(emptyRas)
}

# Variable ring widths, including centre cell for smaller one
emptyRas[] &lt;- 0
rngs &lt;- rings(emptyRas, loci = loci, minRadius = c(0, 7), maxRadius = c(8, 18),
              returnIndices = TRUE)
emptyRas[rngs$indices] &lt;- rngs$id
if (interactive()) {
  terra::plot(emptyRas)
}

# clean up
data.table::setDTthreads(origDTThreads)
options(Ncpus = origNcpus)
</code></pre>

<hr>
<h2 id='runifC'>Rcpp Sugar version of runif</h2><span id='topic+runifC'></span>

<h3>Description</h3>

<p>Slightly faster than runif, and used a lot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runifC(N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runifC_+3A_n">N</code></td>
<td>
<p>Integer Vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of uniform random numbers as per <code>runif</code>
</p>

<hr>
<h2 id='sampleV'>Resample</h2><span id='topic+sampleV'></span>

<h3>Description</h3>

<p>A version of sample that doesn't have awkward behaviour when <code>length(x) == 1</code>.
Vectorized version of <code>sample</code> using <code>Vectorize</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleV(x, size, replace = FALSE, prob = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampleV_+3A_x">x</code></td>
<td>
<p>either a vector of one or more elements from which to choose,
or a positive integer.  See &lsquo;Details.&rsquo;</p>
</td></tr>
<tr><td><code id="sampleV_+3A_size">size</code></td>
<td>
<p>a non-negative integer giving the number of items to choose.</p>
</td></tr>
<tr><td><code id="sampleV_+3A_replace">replace</code></td>
<td>
<p>should sampling be with replacement?</p>
</td></tr>
<tr><td><code id="sampleV_+3A_prob">prob</code></td>
<td>
<p>a vector of probability weights for obtaining the elements
of the vector being sampled.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Intended for internal use only. <code>size</code> is vectorized.
</p>


<h3>Value</h3>

<p>A random permutation, as in <code>sample</code>, but with <code>size</code> vectorized.
</p>

<hr>
<h2 id='specificNumPerPatch'>Initiate a specific number of agents in a map of patches</h2><span id='topic+specificNumPerPatch'></span>

<h3>Description</h3>

<p>Instantiate a specific number of agents per patch.
The user can either supply a table of how many to initiate in each patch,
linked by a column in that table called <code>pops</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>specificNumPerPatch(patches, numPerPatchTable = NULL, numPerPatchMap = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="specificNumPerPatch_+3A_patches">patches</code></td>
<td>
<p><code>SpatRaster</code> of patches, with some sort of a patch id.</p>
</td></tr>
<tr><td><code id="specificNumPerPatch_+3A_numperpatchtable">numPerPatchTable</code></td>
<td>
<p>A <code>data.frame</code> or <code>data.table</code> with a
column named <code>pops</code> that matches the <code>patches</code> patch ids, and a
second column <code>num.in.pop</code> with population size in each patch.</p>
</td></tr>
<tr><td><code id="specificNumPerPatch_+3A_numperpatchmap">numPerPatchMap</code></td>
<td>
<p>A <code>SpatRaster</code> exactly the same as <code>patches</code>
but with agent numbers rather than ids as the cell values per patch.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A raster with 0s and 1s, where the 1s indicate starting locations of
agents following the numbers above.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)

origDTThreads &lt;- data.table::setDTthreads(2L)
origNcpus &lt;- options(Ncpus = 2L)

set.seed(1234)
Ntypes &lt;- 4
ras &lt;- randomPolygons(numTypes = Ntypes)
if (interactive()) {
  terra::plot(ras)
}

# Use numPerPatchTable
patchDT &lt;- data.table(pops = 1:Ntypes, num.in.pop = c(1, 3, 5, 7))
rasAgents &lt;- specificNumPerPatch(ras, patchDT)
rasAgents[is.na(rasAgents)] &lt;- 0

if (require(testthat))
  expect_true(all(unname(table(ras[rasAgents])) == patchDT$num.in.pop))

# Use numPerPatchMap
rasPatches &lt;- ras
for (i in 1:Ntypes) {
  rasPatches[rasPatches==i] &lt;- patchDT$num.in.pop[i]
}
if (interactive()) {
  terra::plot(c(ras, rasPatches))
}
rasAgents &lt;- specificNumPerPatch(ras, numPerPatchMap = rasPatches)
rasAgents[is.na(rasAgents)] &lt;- 0
if (interactive()) {
  terra::plot(rasAgents)
}

# clean up
data.table::setDTthreads(origDTThreads)
options(Ncpus = origNcpus)

</code></pre>

<hr>
<h2 id='spokes'>Identify outward radiating spokes from initial points</h2><span id='topic+spokes'></span>

<h3>Description</h3>

<p>This is a generalized version of a notion of a viewshed.
The main difference is that there can be many &quot;viewpoints&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spokes(
  landscape,
  coords,
  loci,
  maxRadius = ncol(landscape)/4,
  minRadius = maxRadius,
  allowOverlap = TRUE,
  stopRule = NULL,
  includeBehavior = "includePixels",
  returnDistances = FALSE,
  angles = NA_real_,
  nAngles = NA_real_,
  returnAngles = FALSE,
  returnIndices = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spokes_+3A_landscape">landscape</code></td>
<td>
<p>Raster on which the circles are built.</p>
</td></tr>
<tr><td><code id="spokes_+3A_coords">coords</code></td>
<td>
<p>Either a matrix with 2 (or 3) columns, <code>x</code> and <code>y</code> (and <code>id</code>), representing the
coordinates (and an associated id, like cell index),
or a <code style="white-space: pre;">&#8288;SpatialPoints*&#8288;</code> object around which to make circles. Must be same
coordinate system as the <code>landscape</code> argument. Default is missing,
meaning it uses the default to <code>loci</code>.</p>
</td></tr>
<tr><td><code id="spokes_+3A_loci">loci</code></td>
<td>
<p>Numeric. An alternative to <code>coords</code>.
These are the indices on <code>landscape</code> to initiate this function (see <code>coords</code>).
Default is one point in centre of <code>landscape</code>.</p>
</td></tr>
<tr><td><code id="spokes_+3A_maxradius">maxRadius</code></td>
<td>
<p>Numeric vector of length 1 or same length as <code>coords</code></p>
</td></tr>
<tr><td><code id="spokes_+3A_minradius">minRadius</code></td>
<td>
<p>Numeric vector of length 1 or same length as <code>coords</code>. Default is
<code>maxRadius</code>, meaning return all cells that are touched
by the narrow ring at that exact radius. If smaller than <code>maxRadius</code>,
then this will create a buffer or doughnut or ring.</p>
</td></tr>
<tr><td><code id="spokes_+3A_allowoverlap">allowOverlap</code></td>
<td>
<p>Logical. Should duplicates across id be removed or kept. Default TRUE.</p>
</td></tr>
<tr><td><code id="spokes_+3A_stoprule">stopRule</code></td>
<td>
<p>A function. If the spokes are to stop. This can be a function
of <code>landscape</code>, <code>fromCell</code>, <code>toCell</code>, <code>x</code>
(distance from coords cell), or any other named argument passed
into the <code>...</code> of this function. See examples.</p>
</td></tr>
<tr><td><code id="spokes_+3A_includebehavior">includeBehavior</code></td>
<td>
<p>Character string. Currently accepts only <code>"includePixels"</code>, the default,
and <code>"excludePixels"</code>. See details.</p>
</td></tr>
<tr><td><code id="spokes_+3A_returndistances">returnDistances</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then a column will be added to the returned
data.table that reports the distance from <code>coords</code> to every
point that was in the circle/doughnut surrounding <code>coords</code>.
Default <code>FALSE</code>, which is faster.</p>
</td></tr>
<tr><td><code id="spokes_+3A_angles">angles</code></td>
<td>
<p>Numeric. Optional vector of angles, in radians, to use. This will create
&quot;spokes&quot; outward from <code>coords.</code> Default is <code>NA</code>, meaning, use internally
derived angles that will &quot;fill&quot; the circle.</p>
</td></tr>
<tr><td><code id="spokes_+3A_nangles">nAngles</code></td>
<td>
<p>Numeric, length one. Alternative to angles. If provided, the function
will create a sequence of angles from <code>0</code> to <code>2*pi</code>,
with a length <code>nAngles</code>, and not including <code>2*pi</code>.
Will not be used if <code>angles</code> is provided, and will show
warning of both are given.</p>
</td></tr>
<tr><td><code id="spokes_+3A_returnangles">returnAngles</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then a column will be added to the returned
data.table that reports the angle from <code>coords</code> to every
point that was in the circle/doughnut surrounding <code>coords</code>. Default <code>FALSE.</code></p>
</td></tr>
<tr><td><code id="spokes_+3A_returnindices">returnIndices</code></td>
<td>
<p>Logical or numeric. If <code>1</code> or <code>TRUE</code>, will return a <code>data.table</code>
with indices and values of successful spread events.
If <code>2</code>, it will simply return a vector of pixel indices of
all cells that were touched. This will be the fastest option.
If <code>FALSE</code>, then it will return a raster with values.
See Details.</p>
</td></tr>
<tr><td><code id="spokes_+3A_...">...</code></td>
<td>
<p>Objects to be used by <code>stopRule()</code>. See examples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing columns id (representing the row numbers of <code>coords</code>),
angles (from <code>coords</code> to each point along the spokes), x and y coordinates
of each point along the spokes, the corresponding indices on the <code>landscape</code>
Raster, dists (the distances between each <code>coords</code> and each point along the
spokes), and stop, indicating if it was a point that caused a spoke to stop
going outwards due to <code>stopRule</code>.
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
library(terra)

origDTThreads &lt;- data.table::setDTthreads(2L)
origNcpus &lt;- options(Ncpus = 2L)
set.seed(1234)

ras &lt;- terra::rast(terra::ext(0, 10, 0, 10), res = 1, val = 0)
rp &lt;- randomPolygons(ras, numTypes = 10)

if (interactive())
  terra::plot(rp)

angles &lt;- seq(0, pi * 2, length.out = 17)
angles &lt;- angles[-length(angles)]
n &lt;- 2
loci &lt;- sample(terra::ncell(rp), n)
coords &lt;- terra::vect(terra::xyFromCell(rp, loci))
stopRule &lt;- function(landscape) landscape &lt; 3
d2 &lt;- spokes(rp, coords = coords, stopRule = stopRule,
             minRadius = 0, maxRadius = 50,
             returnAngles = TRUE, returnDistances = TRUE,
             allowOverlap = TRUE, angles = angles, returnIndices = TRUE)

# Assign values to the "patches" that were in the viewshed of a ray
rasB &lt;- terra::rast(ras)
rasB[] &lt;- 0
rasB[d2[d2[, "stop"] == 1, "indices"]] &lt;- 1

if (interactive()) {
  rasB[rasB == 0] &lt;- NA
  terra::plot(rasB, add = TRUE, col = "red", legend = FALSE)
}

if (NROW(d2) &gt; 0) {
  sp1 &lt;- terra::vect(d2[, c("x", "y")])
  if (interactive())
    terra::plot(sp1, add = TRUE, pch = 19)
}
if (interactive())
  terra::plot(coords, add = TRUE, pch = 19, col = "blue")

# clean up
data.table::setDTthreads(origDTThreads)
options(Ncpus = origNcpus)
</code></pre>

<hr>
<h2 id='spread'>Simulate a spread process on a landscape.</h2><span id='topic+spread'></span>

<h3>Description</h3>

<p>This can be used to simulate fires, seed dispersal, calculation of iterative,
concentric landscape values (symmetric or asymmetric) and many other things.
Essentially, it starts from a collection of cells (<code>loci</code>) and spreads
to neighbours, according to the <code>directions</code> and <code>spreadProb</code> arguments.
This can become quite general, if <code>spreadProb</code> is 1 as it will expand
from every loci until all cells in the landscape have been covered.
With <code>id</code> set to <code>TRUE</code>, the resulting map will be classified
by the index of the cell where that event propagated from.
This can be used to examine things like fire size distributions.
<strong>NOTE:</strong> See also <code><a href="#topic+spread2">spread2()</a></code>, which is more robust and can be
used to build custom functions.
However, under some conditions, this <code>spread</code> function is faster.
The two functions can accomplish many of the same things, and key differences are internal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spread(
  landscape,
  loci = NA_real_,
  spreadProb = 0.23,
  persistence = 0,
  mask = NA,
  maxSize = 100000000L,
  directions = 8L,
  iterations = 1000000L,
  lowMemory = NULL,
  returnIndices = FALSE,
  returnDistances = FALSE,
  mapID = NULL,
  id = FALSE,
  plot.it = FALSE,
  spreadProbLater = NA_real_,
  spreadState = NA,
  circle = FALSE,
  circleMaxRadius = NA_real_,
  stopRule = NA,
  stopRuleBehavior = "includeRing",
  allowOverlap = FALSE,
  asymmetry = NA_real_,
  asymmetryAngle = NA_real_,
  quick = FALSE,
  neighProbs = NULL,
  exactSizes = FALSE,
  relativeSpreadProb = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spread_+3A_landscape">landscape</code></td>
<td>
<p>A <code>RasterLayer</code> or <code>SpatRaster</code> object. This defines the possible
locations for spreading events to start and spread into.
This can also be used as part of <code>stopRule</code>.</p>
</td></tr>
<tr><td><code id="spread_+3A_loci">loci</code></td>
<td>
<p>A vector of locations in <code>landscape</code>.
These should be cell indices.
If user has x and y coordinates, these can be converted
with <code><a href="terra.html#topic+xyCellFrom">cellFromXY()</a></code>.</p>
</td></tr>
<tr><td><code id="spread_+3A_spreadprob">spreadProb</code></td>
<td>
<p>Numeric, <code>RasterLayer</code>, or <code>SpatRaster</code>.
If numeric of length 1, then this is the global probability
of spreading into each cell from a neighbour.
If a raster (or a vector of length <code>terra::ncell(landscape)</code>,
resolution and extent of <code>landscape</code>), then this will
be the cell-specific probability. Default is <code>0.23</code>.
If a <code>spreadProbLater</code> is provided, then this is
only used for the first iteration. Also called &quot;escape
probability&quot;. See section on &quot;Breaking out of spread events&quot;.</p>
</td></tr>
<tr><td><code id="spread_+3A_persistence">persistence</code></td>
<td>
<p>A length 1 probability that an active cell will continue
to burn, per time step.</p>
</td></tr>
<tr><td><code id="spread_+3A_mask">mask</code></td>
<td>
<p><code>RasterLayer</code> or <code>SpatRaster</code> object congruent with <code>landscape</code>,
whose elements are <code style="white-space: pre;">&#8288;0,1&#8288;</code>, where <code>1</code> indicates &quot;cannot spread to&quot;.
Currently not implemented, but identical behaviour can be
achieved if <code>spreadProb</code> has zeros in all unspreadable
locations.</p>
</td></tr>
<tr><td><code id="spread_+3A_maxsize">maxSize</code></td>
<td>
<p>Numeric. Maximum number of cells for a single or all events to be spread.
Recycled to match <code>loci</code> length, if it is not as long as <code>loci</code>.
See section on <code style="white-space: pre;">&#8288;Breaking out of spread events&#8288;</code>.</p>
</td></tr>
<tr><td><code id="spread_+3A_directions">directions</code></td>
<td>
<p>The number of adjacent cells in which to look;
default is 8 (Queen case). Can only be 4 or 8.</p>
</td></tr>
<tr><td><code id="spread_+3A_iterations">iterations</code></td>
<td>
<p>Number of iterations to spread.
Leaving this <code>NULL</code> allows the spread to continue
until stops spreading itself (i.e., exhausts itself).</p>
</td></tr>
<tr><td><code id="spread_+3A_lowmemory">lowMemory</code></td>
<td>
<p>Deprecated.</p>
</td></tr>
<tr><td><code id="spread_+3A_returnindices">returnIndices</code></td>
<td>
<p>Logical or numeric. If <code>1</code> or <code>TRUE</code>, will return a <code>data.table</code>
with indices and values of successful spread events.
If <code>2</code>, it will simply return a vector of pixel indices of
all cells that were touched. This will be the fastest option.
If <code>FALSE</code>, then it will return a raster with values.
See Details.</p>
</td></tr>
<tr><td><code id="spread_+3A_returndistances">returnDistances</code></td>
<td>
<p>Logical. Should the function include a column with the
individual cell distances from the locus where that event
started. Default is <code>FALSE</code>.
See Details.</p>
</td></tr>
<tr><td><code id="spread_+3A_mapid">mapID</code></td>
<td>
<p>Deprecated. Use <code>id</code>.</p>
</td></tr>
<tr><td><code id="spread_+3A_id">id</code></td>
<td>
<p>Logical. If <code>TRUE</code>, returns a raster of events ids.
If <code>FALSE</code>, returns a raster of iteration numbers,
i.e., the spread history of one or more events.
NOTE: this is overridden if <code>returnIndices</code> is <code>TRUE</code>
or <code>1</code> or <code>2</code>.</p>
</td></tr>
<tr><td><code id="spread_+3A_plot.it">plot.it</code></td>
<td>
<p>If <code>TRUE</code>, then plot the raster at every iteration,
so one can watch the spread event grow.</p>
</td></tr>
<tr><td><code id="spread_+3A_spreadproblater">spreadProbLater</code></td>
<td>
<p>Numeric, or <code>RasterLayer</code>. If provided, then this
will become the <code>spreadProb</code> after the first iteration.
See Details.</p>
</td></tr>
<tr><td><code id="spread_+3A_spreadstate">spreadState</code></td>
<td>
<p><code>data.table</code>. This should be the output of a previous call
to <code>spread</code>, where <code>returnIndices</code> was <code>TRUE</code>.
Default <code>NA</code>, meaning the spread is starting from <code>loci</code>.
See Details.</p>
</td></tr>
<tr><td><code id="spread_+3A_circle">circle</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then outward spread will be by
equidistant rings, rather than solely by adjacent cells
(via <code>directions</code> arg.). Default is <code>FALSE</code>.
Using <code>circle = TRUE</code> can be dramatically slower for large problems.
Note, this should usually be used with <code>spreadProb = 1</code>.</p>
</td></tr>
<tr><td><code id="spread_+3A_circlemaxradius">circleMaxRadius</code></td>
<td>
<p>Numeric. A further way to stop the outward spread of events.
If <code>circle</code> is <code>TRUE</code>, then it will grow to this maximum radius.
See section on <code style="white-space: pre;">&#8288;Breaking out of spread events&#8288;</code>.
Default is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="spread_+3A_stoprule">stopRule</code></td>
<td>
<p>A function which will be used to assess whether each
individual cluster should stop growing.
This function can be an argument of <code>"landscape"</code>,
<code>"id"</code>, <code>"cells"</code>, and any other variables passed to
<code>spread</code> in the <code>...</code>. <code>cells</code> and <code>landscape</code> will both
be numeric vectors of length of active cells. <code>cells</code> will
be the raster index, so can be used to extract values
from another raster passed via ... .
Default <code>NA</code>, meaning that spreading will not stop
as a function of the landscape.
See section on &quot;Breaking out of spread events&quot; and examples.</p>
</td></tr>
<tr><td><code id="spread_+3A_stoprulebehavior">stopRuleBehavior</code></td>
<td>
<p>Character. Can be one of <code>"includePixel"</code>,
<code>"excludePixel"</code>, <code>"includeRing"</code>, or
<code>"excludeRing"</code>.
If <code>stopRule</code> contains a function, this argument is
used determine what to do with the cell(s) that caused
the rule to be <code>TRUE</code>. See details.
Default is <code>"includeRing"</code> which means to accept the
entire ring of cells that caused the rule to be <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="spread_+3A_allowoverlap">allowOverlap</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then individual events can overlap
with one another, i.e., they do not interact (this is slower
than if <code>allowOverlap = FALSE</code>).
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="spread_+3A_asymmetry">asymmetry</code></td>
<td>
<p>A numeric indicating the ratio of the asymmetry to be used.
Default is <code>NA</code>, indicating no asymmetry.
See details. This is still experimental.
<strong>Use with caution.</strong></p>
</td></tr>
<tr><td><code id="spread_+3A_asymmetryangle">asymmetryAngle</code></td>
<td>
<p>A numeric indicating the angle in degrees (0 is &quot;up&quot;,
as in North on a map), that describes which way the <code>asymmetry</code> is.</p>
</td></tr>
<tr><td><code id="spread_+3A_quick">quick</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then several potentially time consuming
checking (such as <code>inRange</code>) will be skipped.
This should only be used if there is no concern about checking
to ensure that inputs are legal.</p>
</td></tr>
<tr><td><code id="spread_+3A_neighprobs">neighProbs</code></td>
<td>
<p>A numeric vector, whose sum is 1.
It indicates the probabilities an individual spread iteration
spreading to <code>1:length(neighProbs)</code> neighbours.</p>
</td></tr>
<tr><td><code id="spread_+3A_exactsizes">exactSizes</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then the <code>maxSize</code> will be
treated as exact sizes, i.e., the spread events will continue
until they are <code>floor(maxSize)</code>.
This is overridden by <code>iterations</code>, but if <code>iterations</code>
is run, and individual events haven't reached <code>maxSize</code>,
then the returned <code>data.table</code> will still have at least
one active cell per event that did not achieve <code>maxSize</code>,
so that the events can continue if passed into <code>spread</code>
with <code>spreadState</code>.</p>
</td></tr>
<tr><td><code id="spread_+3A_relativespreadprob">relativeSpreadProb</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then <code>spreadProb</code> will
be rescaled <em>within</em> the <code>directions</code> neighbours, such that
the sum of the probabilities of all neighbours will be 1. Default
<code>FALSE</code>, unless <code>spreadProb</code> values are not contained
between 0 and 1, which will force <code>relativeSpreadProb</code>
to be <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="spread_+3A_...">...</code></td>
<td>
<p>Additional named vectors or named list of named vectors required for <code>stopRule</code>.
These vectors should be as long as required e.g., length <code>loci</code> if there is
one value per event.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For large rasters, a combination of <code>lowMemory = TRUE</code> and
<code>returnIndices = TRUE</code> or <code>returnIndices = 2</code>
will be fastest and use the least amount of memory.
<strong>2022-07-25: <code>lowMemory = TRUE</code> is deprecated due to removal of package <code>ffbase</code> from CRAN.</strong>
</p>
<p>This function can be interrupted before all active cells are exhausted if
the <code>iterations</code> value is reached before there are no more active
cells to spread into. If this is desired, <code>returnIndices</code> should be
<code>TRUE</code> and the output of this call can be passed subsequently as an input
to this same function. This is intended to be used for situations where external
events happen during a spread event, or where one or more arguments to the spread
function change before a spread event is completed. For example, if it is
desired that the <code>spreadProb</code> change before a spread event is completed because,
for example, a fire is spreading, and a new set of conditions arise due to
a change in weather.
</p>
<p><code>asymmetry</code> is currently used to modify the <code>spreadProb</code> in the following way.
First for each active cell, spreadProb is converted into a length 2 numeric of Low and High
spread probabilities for that cell:
<code style="white-space: pre;">&#8288;spreadProbsLH &lt;- (spreadProb*2) // (asymmetry+1)*c(1,asymmetry)&#8288;</code>,
whose ratio is equal to
<code>asymmetry</code>.
Then, using <code>asymmetryAngle</code>, the angle between the
initial starting point of the event and all potential
cells is found. These are converted into a proportion of the angle from
<code>-asymmetryAngle</code>
to
<code>asymmetryAngle</code>
using:
<code>angleQuality &lt;- (cos(angles - rad2(asymmetryAngle))+1)/2</code>
where <code>rad2 &lt;- function (degree) (degree * pi)/180</code>
</p>
<p>These are then converted to multiple <code>spreadProbs</code> by
<code>spreadProbs &lt;- lowSpreadProb + (angleQuality * diff(spreadProbsLH))</code>
To maintain an expected <code>spreadProb</code> that is the same as the asymmetric
<code>spreadProbs</code>, these are then rescaled so that the mean of the
asymmetric spreadProbs is always equal to spreadProb at every iteration:
<code>spreadProbs &lt;- spreadProbs - diff(c(spreadProb, mean(spreadProbs)))</code>
</p>


<h3>Value</h3>

<p>Either a <code>RasterLayer</code> indicating the spread of the process in
the landscape or a <code>data.table</code> if <code>returnIndices</code> is <code>TRUE</code>.
If a <code>RasterLayer</code>, then it represents
every cell in which a successful spread event occurred. For the case of, say, a fire
this would represent every cell that burned. If <code>allowOverlap</code> is <code>TRUE</code>,
This <code>RasterLayer</code> will represent the sum of the individual event ids
(which are numerics <code>seq_along(loci)</code>.
This will generally be of minimal use because it won't be possible to distinguish
if event 2 overlapped with event 5 or if it was just event 7.
</p>
<p>If <code>returnIndices</code> is <code>TRUE</code>,
then this function returns a <code>data.table</code> with columns:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>id</code> </td><td style="text-align: left;"> an arbitrary ID <code>1:length(loci)</code> identifying
unique clusters of spread events, i.e., all cells
that have been spread into that have a
common initial cell.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>initialLocus</code> </td><td style="text-align: left;"> the initial cell number of that particular
spread event.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>indices</code> </td><td style="text-align: left;"> The cell indices of cells that have
been touched by the spread algorithm.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>active</code> </td><td style="text-align: left;"> a logical indicating whether the cell is active (i.e.,
could still be a source for spreading) or not (no
spreading will occur from these cells).</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>This will generally be more useful when <code>allowOverlap</code> is <code>TRUE</code>.
</p>


<h3>Breaking out of spread events</h3>

<p>There are 4 ways for the spread to &quot;stop&quot; spreading. Here, each &quot;event&quot; is defined as
all cells that are spawned from a single starting loci. So, one spread call can have
multiple spreading &quot;events&quot;. The ways outlines below are all acting at all times,
i.e., they are not mutually exclusive. Therefore, it is the user's
responsibility to make sure the different rules are interacting with
each other correctly. Using <code>spreadProb</code> or <code>maxSize</code> are computationally
fastest, sometimes dramatically so.
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>spreadProb</code> </td><td style="text-align: left;"> Probabilistically, if spreadProb is low enough,
active spreading events will stop. In practice,
active spreading events will stop. In practice,
this number generally should be below 0.3 to actually
see an event stop</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>maxSize</code> </td><td style="text-align: left;"> This is the number of cells that are "successfully" turned
on during a spreading event. This can be vectorized, one value
for each event   </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>circleMaxRadius</code> </td><td style="text-align: left;"> If <code>circle</code> is TRUE, then this will be the maximum
radius reached, and then the event will stop. This is
vectorized, and if length is &gt;1, it will be matched
in the order of <code>loci</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>stopRule</code> </td><td style="text-align: left;"> This is a function that can use "landscape", "id", "cells",
or any named vector passed into <code>spread</code> in the <code>...</code>.
This can take on relatively complex functions.
Passing in, say, a <code>RasterLayer</code> to <code>spread</code>
can access the individual values on that arbitrary
<code>RasterLayer</code> using "cells".
These will be calculated within all the cells of the individual
event (equivalent to a "group_by(event)" in <code>dplyr</code>.
So, <code>sum(arbitraryRaster[cells])</code> would sum up all
the raster values on the <code>arbitraryRaster</code> raster
that are overlaid by the individual event.
This can then be used in a logical statement. See examples.
To confirm the cause of stopping, the user can assess the values
after the function has finished.</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The spread function does not return the result of this <code>stopRule</code>.
If, say, an event has both <code>circleMaxRadius</code> and <code>stopRule</code>,
and it is the <code>circleMaxRadius</code> that caused the event spreading to stop,
there will be no indicator returned from this function that indicates
which rule caused the stop.
</p>
<p><code>stopRule</code> has many use cases. One common use case is evaluating
a neighbourhood around a focal set of points. This provides,
therefore, an alternative to the <code><a href="terra.html#topic+buffer">terra::buffer()</a></code> function or
<code><a href="terra.html#topic+focal">terra::focal()</a></code> function.
In both of those cases, the window/buffer size must be an input to the function. Here,
the resulting size can be emergent based on the incremental growing and calculating
of the <code>landscape</code> values underlying the spreading event.
</p>


<h3><code>stopRuleBehavior</code></h3>

<p>This determines how the <code>stopRule</code> should be implemented. Because
spreading occurs outwards in concentric circles or shapes, one cell width at a time, there
are 4 possible ways to interpret the logical inequality defined in <code>stopRule</code>.
In order of number of cells included in resulting events, from most cells to fewest cells:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>"includeRing"</code> </td><td style="text-align: left;"> Will include the entire ring of cells that, as a group,
caused <code>stopRule</code> to be <code>TRUE</code>.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"includePixel"</code> </td><td style="text-align: left;"> Working backwards from the entire ring that caused the
<code>stopRule</code> to be <code>TRUE</code>, this will iteratively
random cells in the final ring
until the <code>stopRule</code> is <code>FALSE</code>. This will add back
the last removed cell and include it in the return result
for that event.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"excludePixel"</code> </td><td style="text-align: left;"> Like <code>"includePixel"</code>, but it will not add back the cell
that causes <code>stopRule</code> to be <code>TRUE</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"excludeRing"</code> </td><td style="text-align: left;"> Analogous to <code>"excludePixel"</code>, but for the entire final
ring of cells added. This will exclude the entire ring of cells
that caused the <code>stopRule</code> to be <code>TRUE</code></td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Note</h3>

<p><code>dqrng</code> version 0.4.0 changed the default RNG. If backwards compatibility is needed,
set <code>dqrng::dqRNGkind("Xoroshiro128+")</code> before running <code>spread</code> to ensure numerical
reproducibility with previous versions.
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire and Steve Cumming
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spread2">spread2()</a></code> for a different implementation of the same algorithm.
It is more robust, meaning, there will be fewer unexplainable errors, and the behaviour
has been better tested, so it is more likely to be exactly as described under all
argument combinations.
Also, <code><a href="#topic+rings">rings()</a></code> which uses <code>spread</code> but with specific argument
values selected for a specific purpose.
<code><a href="terra.html#topic+distance">terra::distance()</a></code>.
<code><a href="#topic+cir">cir()</a></code> to create &quot;circles&quot;; it is fast for many small problems.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
origDTThreads &lt;- data.table::setDTthreads(2L)
origNcpus &lt;- options(Ncpus = 2L)

# Make random forest cover map
set.seed(123)
emptyRas &lt;- rast(ext(0, 1e2, 0, 1e2), res = 1)
hab &lt;- randomPolygons(emptyRas, numTypes = 40)
names(hab) &lt;- "hab"
mask &lt;- rast(emptyRas)
values(mask) &lt;- 0
mask[1:5000] &lt;- 1
numCol &lt;- ncol(emptyRas)
numCell &lt;- ncell(emptyRas)
directions &lt;- 8

# Can use transparent as a colour
coltab(hab) &lt;- paste(c("transparent", grey(0:40/40)))

terra::plot(hab)

# initiate 10 fires
startCells &lt;- as.integer(sample(1:ncell(emptyRas), 100))
fires &lt;- spread(hab, loci = startCells, 0.235, persistence = 0, numNeighs = 2,
                mask = NULL, maxSize = 1e8, directions = 8, iterations = 1e6, id = TRUE)

terra::plot(hab, type = "classes", legend = FALSE)
fires[fires == 0] &lt;- NA
terra::plot(fires, add = TRUE, col = "red", type = "continuous", legend = FALSE)

# Instead, to give a colour to the zero values, use \code{zero.color=}
coltab(fires) &lt;- NULL
# need to specify "type" to get correct legend
terra::plot(fires,  col = c(colorRampPalette(c("blue", "green"))(100)),
            type = "continuous")

##------------------------------------------------------------------------------
## Continue event by passing interrupted object into spreadState
##------------------------------------------------------------------------------

## Interrupt a spread event using iterations - need `returnIndices = TRUE` to
##  use outputs as new inputs in next iteration
fires &lt;- spread(hab, loci = as.integer(sample(1:ncell(hab), 10)),
                returnIndices = TRUE, 0.235, 0, NULL, 1e8, 8, iterations = 3, id = TRUE)
fires[, list(size = length(initialLocus)), by = id]  # See sizes of fires

fires2 &lt;- spread(hab, loci = NA_real_, returnIndices = TRUE, 0.235, 0, NULL,
                 1e8, 8, iterations = 2, id = TRUE, spreadState = fires)
# NOTE events are assigned arbitrary IDs, starting at 1


## Use data.table and loci...
fires &lt;- spread(hab, loci = as.integer(sample(1:ncell(hab), 10)),
                returnIndices = TRUE, 0.235, 0, NULL, 1e8, 8,
                iterations = 2, id = TRUE)
fullRas &lt;- rast(hab)
fullRas[] &lt;- 1:ncell(hab)
burned &lt;- fires[active == FALSE]
burnedMap &lt;- rasterizeReduced(burned, fullRas, "id", "indices")

terra::plot(burnedMap, type = "classes")

####################
## stopRule examples
####################

# examples with stopRule, which means that the eventual size is driven by the values on the raster
#  passed in to the landscape argument. It won't be exact because the pixel values
#  will likely not allow it
stopRule22 &lt;- function(landscape) sum(landscape) &gt; 100

set.seed(1234)
stopRule1 &lt;- function(landscape) sum(landscape) &gt; 50
stopRuleA &lt;- spread(hab, loci = as.integer(sample(1:ncell(hab), 10)), 1, 0, NULL,
                    maxSize = 1e6, 8, 1e6, id = TRUE, circle = TRUE, stopRule = stopRule1,
                    stopRuleBehavior = "excludePixel")
tapply(hab[], stopRuleA[], sum) # all below 50

set.seed(1234)
# using stopRuleBehavior = "excludePixel"
stopRuleB &lt;- spread(hab, loci = as.integer(sample(1:ncell(hab), 10)), 1, 0, NULL,
                    maxSize = 1e6, 8, 1e6, id = TRUE, circle = TRUE, stopRule = stopRule22,
                    stopRuleBehavior = "excludePixel")
tapply(hab[], stopRuleB[], sum) # all below 100

if (interactive())
  terra::plot(c(stopRuleA, stopRuleB))
# Cellular automata shapes
# Diamonds - can make them with: a boolean raster, directions = 4,
#    stopRule in place, spreadProb = 1
diamonds &lt;- spread(hab &gt; 0, spreadProb = 1, directions = 4, id = TRUE, stopRule = stopRule22)

terra::plot(diamonds)

# Squares - can make them with: a boolean raster, directions = 8,
#    stopRule in place, spreadProb = 1
squares &lt;- spread(hab &gt; 0, spreadProb = 1, directions = 8, id = TRUE, stopRule = stopRule22)
terra::plot(squares)

# Interference shapes - can make them with: a boolean raster, directions = 8,
#    stopRule in place, spreadProb = 1
stopRule2 &lt;- function(landscape) sum(landscape) &gt; 200
squashedDiamonds &lt;- spread(hab &gt; 0, spreadProb = 1,
                           loci = (ncell(hab) - ncol(hab)) / 2 + c(4, -4),
                           directions = 4, id = TRUE, stopRule = stopRule2)
terra::plot(squashedDiamonds)

# Circles with spreadProb &lt; 1 will give "more" circular shapes, but definitely not circles
stopRule2 &lt;- function(landscape) sum(landscape) &gt; 200
seed &lt;- sample(1e4, 1)
set.seed(seed)

circlish &lt;- spread(hab &gt; 0, spreadProb = 1, iterations = 10,
                   loci = (ncell(hab) - ncol(hab)) / 2 + c(4, -4),
                   directions = 8, id = TRUE, circle = TRUE)#, stopRule = stopRule2)
if (interactive())
  terra::plot(c(circlish))

set.seed(seed)
regularCA &lt;- spread(hab &gt; 0, spreadProb = 1, iterations = 10,
                    loci = (ncell(hab) - ncol(hab)) / 2 + c(4, -4),
                    directions = 8, id = TRUE)#, stopRule = stopRule2)

if (interactive()) # compare to circlish
  terra::plot(regularCA)

####################
# complex stopRule
####################

initialLoci &lt;- sample(seq_len(ncell(hab)), 2)
endSizes &lt;- seq_along(initialLoci) * 200

# Can be a function of landscape, id, and/or any other named
#   variable passed into spread
stopRule3 &lt;- function(landscape, id, endSizes) sum(landscape) &gt; endSizes[id]

set.seed(1)
twoCirclesDiffSize &lt;- spread(hab, spreadProb = 1, loci = initialLoci,
                             circle = TRUE, directions = 8, id = TRUE,
                             stopRule = stopRule3, endSizes = endSizes,
                             stopRuleBehavior = "excludePixel")

# or using named list of named elements:
set.seed(1)
twoCirclesDiffSize2 &lt;- spread(hab, spreadProb = 1, loci = initialLoci,
                              circle = TRUE, directions = 8, id = TRUE,
                              stopRule = stopRule3,
                              vars = list(endSizes = endSizes),
                              stopRuleBehavior = "excludePixel")

compareGeom(twoCirclesDiffSize, twoCirclesDiffSize2, res = TRUE,
            stopOnError = FALSE)

terra::plot(c(twoCirclesDiffSize , twoCirclesDiffSize2))

cirs &lt;- values(twoCirclesDiffSize)
vals &lt;- tapply(hab[][cirs &gt; 0], cirs[cirs &gt; 0], sum) # one is &lt;200, other is &lt;400 as per endSizes

# Stop if sum of landscape is big or mean of quality is too small
quality &lt;- rast(hab)
quality[] &lt;- runif(ncell(quality), 0, 1)
stopRule4 &lt;- function(landscape, quality, cells) {
  (sum(landscape) &gt; 20) | (mean(values(quality)[cells]) &lt; 0.3)
}

twoCirclesDiffSize &lt;- spread(hab, spreadProb = 1, loci = initialLoci, circle = TRUE,
                             directions = 8, id = TRUE, stopRule = stopRule4,
                             quality = quality, stopRuleBehavior = "excludePixel")


## Using alternative algorithm, not probabilistic diffusion
## Will give exactly correct sizes, yet still with variability
## within the spreading (i.e., cells with and without successes)
seed &lt;- sample(1e6, 1)
set.seed(seed)
startCells &lt;- startCells[1:4]
maxSizes &lt;- rexp(length(startCells), rate = 1 / 500)
fires &lt;- spread(hab, loci = startCells, 1, persistence = 0,
                neighProbs = c(0.5, 0.5, 0.5) / 1.5,
                mask = NULL, maxSize = maxSizes, directions = 8,
                iterations = 1e6, id = TRUE, plot.it = FALSE, exactSizes = TRUE)
all(table(fires[fires &gt; 0][]) == floor(maxSizes))

terra::plot(fires)
hist(fires[][fires[] &gt; 0], main = "fire size distribution")

## Example with relativeSpreadProb ... i.e., a relative probability spreadProb
##  (shown here because because spreadProb raster is not a probability).
##  Here, we force the events to grow, choosing always 2 neighbours,
##  according to the relative probabilities contained on hab layer.
##
## Note: `neighProbs = c(0,1)` forces each active pixel to move to 2 new pixels
## (`prob = 0` for 1 neighbour, `prob = 1` for 2 neighbours)
##
## Note: set hab3 to be very distinct probability differences, to detect spread
##  differences
hab3 &lt;- (hab &lt; 20) * 200 + 1
seed &lt;- 643503
set.seed(seed)
sam &lt;- sample(which(hab3[] == 1), 1)
set.seed(seed)
events1 &lt;- spread(hab3, spreadProb = hab3, loci = sam, directions = 8,
                  neighProbs = c(0, 1), maxSize = c(70), exactSizes = TRUE)

# Compare to absolute probability version
set.seed(seed)
events2 &lt;- spread(hab3, id = TRUE, loci = sam, directions = 8,
                  neighProbs = c(0, 1), maxSize = c(70), exactSizes = TRUE)

terra::plot(events1)

terra::plot(events2, col = c("white", "red", "red"))

hist(events1[], breaks = 30, main = "Event size distribution") ## TODO: fix this plot
# Compare outputs -- should be more high value hab pixels spread to in event1
#  (randomness may prevent this in all cases)
sum(hab3[events1[] &gt; 0]) &gt;= sum(hab3[events2[] &gt; 0]) ## should be usually TRUE

# clean up
data.table::setDTthreads(origDTThreads)
options(Ncpus = origNcpus)
</code></pre>

<hr>
<h2 id='spread2'>Simulate a contagious spread process on a landscape, with <code>data.table</code> internals</h2><span id='topic+spread2'></span>

<h3>Description</h3>

<p>This can be used to simulate fires, seed dispersal, calculation of iterative,
concentric, symmetric (currently) landscape values and many other things.
Essentially, it starts from a collection of cells (<code>start</code>, called &quot;events&quot;)
and spreads to neighbours, according to the <code>directions</code>
and <code>spreadProb</code> with modifications due to other arguments. <strong>NOTE:</strong>
the <code>spread</code> function is similar, but sometimes slightly faster, but less
robust, and more difficult to use iteratively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spread2(
  landscape,
  start = ncell(landscape)/2 - ncol(landscape)/2,
  spreadProb = 0.23,
  persistProb = NA_real_,
  asRaster = TRUE,
  maxSize,
  exactSize,
  directions = 8L,
  iterations = 1000000L,
  returnDistances = FALSE,
  returnDirections = FALSE,
  returnFrom = FALSE,
  maxRetriesPerID = 10,
  spreadProbRel = NA_real_,
  plot.it = FALSE,
  circle = FALSE,
  asymmetry = NA_real_,
  asymmetryAngle = NA_real_,
  allowOverlap = 0,
  neighProbs = NA_real_,
  oneNeighbourOnly = FALSE,
  skipChecks = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spread2_+3A_landscape">landscape</code></td>
<td>
<p>Required. A <code>RasterLayer</code> object. This defines the possible
locations for spreading events to start and <code>spread2</code> into. Required.</p>
</td></tr>
<tr><td><code id="spread2_+3A_start">start</code></td>
<td>
<p>Required. Either a vector of pixel numbers to initiate spreading, or a
<code>data.table</code> that is the output of a previous <code>spread2</code>.
If a vector, they should be cell indices (pixels) on the <code>landscape</code>.
If user has x and y coordinates, these can be converted with
<code><a href="terra.html#topic+xyCellFrom">cellFromXY()</a></code>.</p>
</td></tr>
<tr><td><code id="spread2_+3A_spreadprob">spreadProb</code></td>
<td>
<p>Numeric of length 1 or length <code>ncell(landscape)</code> or
a <code>RasterLayer</code> that is the identical dimensions as
<code>landscape</code>.
If numeric of length 1, then this is the global (absolute)
probability of spreading into each cell from a neighbour.
If a numeric of length <code>ncell(landscape)</code> or a raster,
then this must be the cell-specific (absolute)
probability of a &quot;receiving&quot; potential cell. Default is <code>0.23</code>.
If relative probabilities are required, use <code>spreadProbRel</code>.
If used together, then the relative probabilities will be
re-scaled so that the mean relative probability of potential
neighbours is equal to the mean of <code>spreadProb</code> of
the potential neighbours.</p>
</td></tr>
<tr><td><code id="spread2_+3A_persistprob">persistProb</code></td>
<td>
<p>Numeric of length 1 or <code>RasterLayer</code>.
If numeric of length 1, then this is the global (absolute)
probability of cell continuing to burn per time step.
If a raster, then this must be the cell-specific (absolute)
probability of a fire persisting.
Default is <code>NA</code>, which is the same as 0, i.e. a cell only burns
for one time step.</p>
</td></tr>
<tr><td><code id="spread2_+3A_asraster">asRaster</code></td>
<td>
<p>Logical, length 1. If <code>TRUE</code>, the function will return a <code>Raster</code>
where raster non NA values indicate the cells that were &quot;active&quot;, and the
value is the initial starting pixel.</p>
</td></tr>
<tr><td><code id="spread2_+3A_maxsize">maxSize</code></td>
<td>
<p>Numeric. Maximum number of cells for a single or all events to be <code>spread2</code>.
Recycled to match <code>start</code> length, if it is not as long as <code>start</code>.
This will be overridden if <code>exactSize</code> also provided.
See section on 'Breaking out of <code>spread2</code> events'.</p>
</td></tr>
<tr><td><code id="spread2_+3A_exactsize">exactSize</code></td>
<td>
<p>Numeric vector, length 1 or <code>length(start)</code>.
Similar to <code>maxSize</code>, but these will be the exact
final sizes of the events.  i.e., the <code>spread2</code> events
will continue until they are <code>floor(exactSize)</code>.
This will override <code>maxSize</code> if both provided.
See Details.</p>
</td></tr>
<tr><td><code id="spread2_+3A_directions">directions</code></td>
<td>
<p>The number adjacent cells in which to look;
default is 8 (Queen case). Can only be 4 or 8.</p>
</td></tr>
<tr><td><code id="spread2_+3A_iterations">iterations</code></td>
<td>
<p>Number of iterations to <code>spread2</code>.
Leaving this <code>NULL</code> allows the <code>spread2</code> to continue
until stops spreading itself (i.e., exhausts itself).</p>
</td></tr>
<tr><td><code id="spread2_+3A_returndistances">returnDistances</code></td>
<td>
<p>Logical. Should the function include a column with the
individual cell distances from the locus where that event
started. Default is FALSE. See Details.</p>
</td></tr>
<tr><td><code id="spread2_+3A_returndirections">returnDirections</code></td>
<td>
<p>Logical. Should the function include a column with the
individual directions (in radians) from the locus where
that event started. Default is FALSE.</p>
</td></tr>
<tr><td><code id="spread2_+3A_returnfrom">returnFrom</code></td>
<td>
<p>Logical. Should the function return a column with the
source, i.e, the lag 1 &quot;from&quot; pixel, for each iteration.</p>
</td></tr>
<tr><td><code id="spread2_+3A_maxretriesperid">maxRetriesPerID</code></td>
<td>
<p>Only active if <code>exactSize</code> is used. This is the number of attempts
that will be made per event ID, before abandoning, therefore completing
the <code>spread2</code> for that event with a size that is smaller than
<code>exactSize</code>. Default 10 times.</p>
</td></tr>
<tr><td><code id="spread2_+3A_spreadprobrel">spreadProbRel</code></td>
<td>
<p>Optional <code>RasterLayer</code> indicating a surface of relative
probabilities useful when using <code>neighProbs</code> (which
provides a mechanism for selecting a specific number of
cells at each iteration).
This indicates the relative probabilities for the selection
of successful neighbours.
<code>spreadProb</code> will still be evaluated <em>after</em>
the relative probabilities and <code>neighProbs</code> has been
evaluated, i.e., potential cells will be identified, then
some could be rejected via <code>spreadProb</code>.
If absolute <code>spreadProb</code> is not desired,
<em>be sure to set</em> <code>spreadProb = 1</code>.
Ignored if <code>neighProbs</code> is not provided.</p>
</td></tr>
<tr><td><code id="spread2_+3A_plot.it">plot.it</code></td>
<td>
<p>If <code>TRUE</code>, then plot the raster at every iteration,
so one can watch the <code>spread2</code> event grow.</p>
</td></tr>
<tr><td><code id="spread2_+3A_circle">circle</code></td>
<td>
<p>Logical. If TRUE, then outward <code>spread2</code> will be by equidistant rings,
rather than solely by adjacent cells (via <code>directions</code> arg.).
Default is <code>FALSE</code>.
Using <code>circle = TRUE</code> can be dramatically slower for large problems.
Note, this will likely create unexpected results if <code>spreadProb &lt; 1</code>.</p>
</td></tr>
<tr><td><code id="spread2_+3A_asymmetry">asymmetry</code></td>
<td>
<p>A numeric or <code>RasterLayer</code> indicating the ratio of the
asymmetry to be used. i.e., 1 is no asymmetry; 2 means that the
angles in the direction of the <code>asymmetryAngle</code> are 2x the
<code>spreadProb</code>
of the angles opposite tot he <code>asymmetryAngle</code>  Default is
NA, indicating no asymmetry. See details. This is still experimental.
Use with caution.</p>
</td></tr>
<tr><td><code id="spread2_+3A_asymmetryangle">asymmetryAngle</code></td>
<td>
<p>A numeric or <code>RasterLayer</code> indicating the angle in degrees
(0 is &quot;up&quot;, as in North on a map),
that describes which way the <code>asymmetry</code> is.</p>
</td></tr>
<tr><td><code id="spread2_+3A_allowoverlap">allowOverlap</code></td>
<td>
<p><code>numeric</code> (<code>logical</code> will work for backwards compatibility).
See details.  Default is 0, i.e., no overlapping.</p>
</td></tr>
<tr><td><code id="spread2_+3A_neighprobs">neighProbs</code></td>
<td>
<p>An optional numeric vector, whose sum is 1.
It indicates the probabilities that an individual spread iteration
will spread to <code style="white-space: pre;">&#8288;1, 2, ..., length(neighProbs)&#8288;</code> neighbours, respectively.
If this is used (i.e., something other than <code>NA</code>), <code>circle</code> and
<code>returnDistances</code> will not work currently.</p>
</td></tr>
<tr><td><code id="spread2_+3A_oneneighbouronly">oneNeighbourOnly</code></td>
<td>
<p>Logical. Default is <code>FALSE</code>. If <code>TRUE</code>, then this
spread algorithm will allow exactly one neighbour to be
spread to (not fewer or more). This could be used, e.g.,
for an animal moving. If this is <code>TRUE</code>, then <code>allowOverlap</code>
will be set to <code>2</code> if it is <code>0</code> or <code>1</code>.</p>
</td></tr>
<tr><td><code id="spread2_+3A_skipchecks">skipChecks</code></td>
<td>
<p>Logical. If TRUE, the argument checking (i.e., assertions) will be
skipped. This should likely only be used once it is clear that the function
arguments are well understood and function speed is of the primary importance.
This is likely most useful in repeated iteration cases i.e., if this call
is using the previous output from this same function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are 2 main underlying algorithms for active cells to &quot;spread&quot; to
nearby cells (adjacent cells): <code>spreadProb</code> and <code>neighProb</code>.
Using <code>spreadProb</code>, every &quot;active&quot; pixel will assess all
neighbours (either 4 or 8, depending on  <code>directions</code>), and will &quot;activate&quot;
whichever neighbours successfully pass independent calls to
<code>runif(1,0,1) &lt; spreadProb</code>.
The algorithm will iterate again and again, each time starting from the newly
&quot;activated&quot; cells. Several built-in decisions are as follows.
</p>

<ol>
<li><p> no active cell can activate a cell that was already activated by
the same event (i.e., &quot;it won't go backwards&quot;). 2. If <code>allowOverlap</code> is
<code>FALSE</code>, then the previous rule will also apply, regardless of which
&quot;event&quot; caused the pixels to be previously active.
</p>
</li></ol>

<p>This function can be interrupted before all active cells are exhausted if
the <code>iterations</code> value is reached before there are no more active
cells to <code>spread2</code> into. The interrupted output (a <code>data.table</code>) can be passed
subsequently as an input to this same function (as <code>start</code>).
This is intended to be used for situations where external events happen during
a <code>spread2</code> event, or where one or more arguments to the <code>spread2</code> function
change before a <code>spread2</code> event is completed.
For example, if it is desired that the <code>spreadProb</code> change before a
<code>spread2</code> event is completed because, for example, a fire is spreading, and a
new set of conditions arise due to a change in weather.
</p>
<p><code>asymmetry</code> here is slightly different than in the <code>spread</code> function,
so that it can deal with a <code>RasterLayer</code> of <code>asymmetryAngle</code>.
Here, the <code>spreadProb</code> values of a given set of neighbours around each active pixel
are adjusted to create <code>adjustedSpreadProb</code> which is calculated maintain the
following two qualities: </p>
<p style="text-align: center;"><code class="reqn">mean(spreadProb) = mean(ajustedSpreadProb)</code>
</p>
<p> and
</p>
<p style="text-align: center;"><code class="reqn">max(spreadProb)/min(spreadProb) = asymmetry</code>
</p>
<p> along the axis of
<code>asymmetryAngle</code>. NOTE: this means that the 8 neighbours around an active
cell may not fulfill the preceeding equality if <code>asymmetryAngle</code> is not
exactly one of the 8 angles of the 8 neighbours. This means that
</p>
<p style="text-align: center;"><code class="reqn">max(spreadProb)/min(spreadProb)</code>
</p>
<p> will generally be less than
<code>asymmetry</code>, for the 8 neighbours. The exact adjustment to the spreadProb
is calculated with:
</p>
<p style="text-align: center;"><code class="reqn">angleQuality &lt;- (cos(angles - rad2(asymmetryAngle))+1)/2</code>
</p>

<p>which is multiplied to get an angle-adjusted spreadProb:
</p>
<p style="text-align: center;"><code class="reqn">spreadProbAdj &lt;- actualSpreadProb * angleQuality</code>
</p>

<p>which is then rescaled:
</p>
<p style="text-align: center;"><code class="reqn">adjustedSpreadProb = (spreadProbAdj - min(spreadProbAdj)) * par2 + par1</code>
</p>
<p>,
where <code>par1</code> and <code>par2</code> are parameters calculated internally to make the 2 conditions above true.
</p>
<p>If <code>maxSize</code> or <code>exactSize</code> are used, then spreading will continue and stop
before or at <code>maxSize</code> or at <code>exactSize</code>, respectively.
If <code>iterations</code> is specified, then the function will end, and the returned <code>data.table</code>
may (if <code>maxSize</code>) or will (if <code>exactSize</code>) have at least one active
cell per event that did not already achieve <code>maxSize</code> or <code>exactSize</code>.
This will be very useful to build new, customized higher-level wrapper functions that
iteratively call <code>spread2</code>.
</p>


<h3>Value</h3>

<p>Either a <code>data.table</code> (<code>asRaster=FALSE</code>) or a <code>RasterLayer</code>
(<code>asRaster=TRUE</code>, the default).
The <code>data.table</code> will have one attribute named <code>spreadState</code>, which
is a list containing a <code>data.table</code> of current cluster-level information
about the spread events.
If <code>asRaster=TRUE</code>, then the <code>data.table</code> (with its <code>spreadState</code>
attribute) will be attached to the <code>Raster</code> as an attribute named <code>pixel</code> as it
provides pixel-level information about the spread events.
</p>
<p>The <code>RasterLayer</code> represents every cell in which a successful <code>spread2</code> event occurred.
For the case of, say, a fire this would represent every cell that burned.
If <code>allowOverlap</code> is <code>TRUE</code>, the return will always be a <code>data.table</code>.
</p>
<p>If <code>asRaster</code> is <code>FALSE</code>, then this function returns a
<code>data.table</code> with 3 (or 4 if <code>returnFrom</code> is <code>TRUE</code>) columns:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>initialPixels</code> </td><td style="text-align: left;"> the initial cell number of that particular
<code>spread2</code> event.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>pixels</code> </td><td style="text-align: left;"> The cell indices of cells that have
been touched by the <code>spread2</code> algorithm.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>state</code> </td><td style="text-align: left;"> a logical indicating whether the cell is active (i.e.,
could still be a source for spreading) or not (no
spreading will occur from these cells).</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>from</code> </td><td style="text-align: left;"> The pixel indices that were the immediately preceding
"source" for each <code>pixels</code>, i.e., the lag 1 pixels.
Only returned if <code>returnFrom</code> is <code>TRUE</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The attribute saved with the name <code>"spreadState"</code> (e.g., <code>attr(output, "spreadState")</code>)
includes a <code>data.table</code> with columns:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>id</code> </td><td style="text-align: left;"> An arbitrary code, from 1 to <code>length(start)</code> for each "event".</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>initialPixels</code> </td><td style="text-align: left;"> the initial cell number of that particular
<code>spread2</code> event.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>numRetries</code> </td><td style="text-align: left;"> The number of re-starts the event did because it got
stuck (normally only because <code>exactSize</code> was used
and was not achieved.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>maxSize</code> </td><td style="text-align: left;"> The number of pixels that were provided as inputs via
<code>maxSize</code> or <code>exactSize</code>.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>size</code> </td><td style="text-align: left;"> The current size, in pixels, of each event.</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>and several other objects that provide significant speed ups in iterative calls to
<code>spread2</code>. If the user runs <code>spread2</code> iteratively, there will likely be significant
speed gains if the <code>data.table</code> passed in to <code>start</code> should have the attribute
attached, or re-attached if it was lost, e.g., via
<code>setattr(outInput, "spreadState", attr(out, "spreadState"))</code>, where <code>out</code> is the
returned <code>data.table</code> from the previous call to <code>spread2</code>, and <code>outInput</code> is
the modified <code>data.table</code>. Currently, the modified <code>data.table</code> <strong>must</strong> have the
same order as <code>out</code>.
</p>


<h3>Breaking out of <code>spread2</code> events</h3>

<p>There are 3 ways for the <code>spread2</code> to &quot;stop&quot; spreading.
Here, each &quot;event&quot; is defined as all cells that are spawned from each unique
<code>start</code> location.
The ways outlined below are all acting at all times, i.e., they are not
mutually exclusive.
Therefore, it is the user's responsibility to make sure the different rules
are interacting with each other correctly.
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>spreadProb</code> </td><td style="text-align: left;"> Probabilistically, if <code>spreadProb</code> is low enough,
active spreading events will stop.
In practice, this number generally should be below 0.3
to actually see an event stop.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>maxSize</code> </td><td style="text-align: left;"> This is the number of cells that are "successfully" turned
on during a spreading event. <code>spreadProb</code> will still
be active, so, it is possible that the end size of each event
is smaller than <code>maxSize</code>, but they will not be greater
than <code>maxSize</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>exactSize</code> </td><td style="text-align: left;"> This is the number of cells that are "successfully" turned
on during a spreading event. This will override an event that
stops probabilistically via <code>spreadProb</code>, but forcing
its last set of active cells to try again to find neighbours.
It will try <code>maxRetriesPerID</code> times per event, before giving up.
During those <code>maxRetriesPerID</code> times, it will try to "jump" up to
4 cells outwards from each of the active cells, every 5 retries.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>iterations</code> </td><td style="text-align: left;"> This is a hard cap on the number of internal iterations to
complete before returning the current state of the system
as a <code>data.table</code>.</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Building custom spreading events</h3>

<p>This function can be used iteratively, with relatively little overhead compared to using
it non-iteratively. In general, this function can be called with arguments set as user
needs, and with specifying e.g., <code>iterations = 1</code>. This means that the function will spread
outwards 1 iteration, then stop. The returned object will be a <code>data.table</code> or
<code>RasterLayer</code> that can be passed immediately back as the start argument into a subsequent
call to <code>spread2</code>. This means that every argument can be updated at each iteration.
</p>
<p>When using this function iteratively, there are several things to keep in mind.
The output will likely be sorted differently than the input (i.e., the
order of start, if a vector, may not be the same order as that returned).
This means that when passing the same object back into the next iteration of the
function call, <code>maxSize</code> or <code>exactSize</code> may not be in the same order.
To get the same order, the easiest thing to do is sort the initial <code>start</code>
objects by their pixel location, increasing.
Then, of course, sorting any vectorized arguments (e.g., <code>maxSize</code>) accordingly.
</p>
<p><strong>NOTE</strong>: the <code>data.table</code> or <code>RasterLayer</code> should not be altered
when passed back into <code>spread2</code>.
</p>


<h3><code>allowOverlap</code></h3>

<p>If <code>1</code> (or <code>TRUE</code>),
then individual events can overlap with one another, i.e., allow
overlap between events. If <code>2</code> (or <code>NA</code>), then each pixel
is essentially independent, allowing overlap between and within
events. This likely requires a user to intervene as it is possible
to spread back onto itself. If <code>3</code> (did not exist previously),
individual events can overlap, and there can be overlap within an
event, but only within an iteration, i.e., once an iteration is
finished, and a pixel was activated, then the spreading will not
return onto these pixels. If <code>0</code> (or <code>FALSE</code>), then once a
pixel is activated, it cannot be re-activated, within or between event.
This allows events to not interfere with one another i.e.,
they do not interact (this is slower than if
<code>allowOverlap = FALSE</code>). Default is 0. In the case of 2 or 3,
this would be, perhaps, useful for dispersal of,
say, insect swarms.
</p>


<h3>Note</h3>

<p><code>exactSize</code> may not be achieved if there aren't enough cells in the map.
Also, <code>exactSize</code> may not be achieved because the active cells are &quot;stuck&quot;,
i.e., they have no inactivated cells to move to; or the <code>spreadProb</code> is low.
In the latter two cases, the algorithm will retry again, but it will only
retry from the last iteration's active cells.
The algorithm will only retry 10 times before quitting.
Currently, there will also be an attempt to &quot;jump&quot; up to four cells away from
the active cells to try to continue spreading.
</p>
<p>A common way to use this function is to build wrappers around this, followed
by iterative calls in a <code>while</code> loop. See example.
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire and Steve Cumming
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spread">spread()</a></code> for a different implementation of the same algorithm.
<code>spread</code> is less robust but it is often slightly faster.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)

origDTThreads &lt;- data.table::setDTthreads(2L)
origNcpus &lt;- options(Ncpus = 2L)

a &lt;- rast(ext(0, 10, 0, 10), res = 1)
sams &lt;- sort(sample(ncell(a), 3))

# Simple use -- similar to spread(...)
out &lt;- spread2(a, start = sams, 0.225)
if (interactive()) {
  terra::plot(out)
}

# Use maxSize -- this gives an upper limit
maxSizes &lt;- sort(sample(1:10, size = length(sams)))
out &lt;- spread2(a, start = sams, 0.225, maxSize = maxSizes, asRaster = FALSE)
# check TRUE using data.table .N
out[, .N, by = "initialPixels"]$N &lt;= maxSizes

# Use exactSize -- gives an exact size, if there is enough space on the Raster
exactSizes &lt;- maxSizes
out &lt;- spread2(a, start = sams, spreadProb = 0.225,
               exactSize = exactSizes, asRaster = FALSE)
out[, .N, by = "initialPixels"]$N == maxSizes # should be TRUE TRUE TRUE

# Use exactSize -- but where it can't be achieved
exactSizes &lt;- sort(sample(100:110, size = length(sams)))
out &lt;- spread2(a, start = sams, 1, exactSize = exactSizes)

# Iterative calling -- create a function with a high escape probability
spreadWithEscape &lt;- function(ras, start, escapeProb, spreadProb) {
  out &lt;- spread2(ras, start = sams, spreadProb = escapeProb, asRaster = FALSE)
  while (any(out$state == "sourceActive")) {
    # pass in previous output as start
    out &lt;- spread2(ras, start = out, spreadProb = spreadProb,
                    asRaster = FALSE, skipChecks = TRUE) # skipChecks for speed
  }
  out
}

set.seed(421)
out1 &lt;- spreadWithEscape(a, sams, escapeProb = 0.25, spreadProb = 0.225)
set.seed(421)
out2 &lt;- spread2(a, sams, 0.225, asRaster = FALSE)
# The one with high escape probability is larger (most of the time)
NROW(out1) &gt; NROW(out2) ## TODO: not true

## Use neighProbs, with a spreadProb that is a RasterLayer
# Create a raster of different values, which will be the relative probabilities
#   i.e., they are rescaled to relative probabilities within the 8 neighbour choices.
#   The neighProbs below means 70% of the time, 1 neighbour will be chosen,
#   30% of the time 2 neighbours.
#   The cells with spreadProb of 5 are 5 times more likely than cells with 1 to be chosen,
#   when they are both within the 8 neighbours
sp &lt;- rast(ext(0, 3, 0, 3), res = 1, vals = 1:9) #small raster, simple values
# Check neighProbs worked
out &lt;- list()

# enough replicates to see stabilized probabilities
for (i in 1:100) {
  out[[i]] &lt;- spread2(sp, spreadProbRel = sp, spreadProb = 1,
                      start = 5, iterations = 1,
                      neighProbs = c(1), asRaster = FALSE)
}
out &lt;- data.table::rbindlist(out)[pixels != 5] # remove starting cell
table(sp[out$pixels])
# should be non-significant -- note no 5 because that was the starting cell
#  This tests whether the null model is true ... there should be proportions
#  equivalent to 1:2:3:4:6:7:8:9 ... i.e,. cell 9 should have 9x as many events
#  spread to it as cell 1. This comes from sp object above which is providing
#  the relative spread probabilities
keep &lt;- c(1:4, 6:9)
chisq.test(keep, unname(tabulate(sp[out$pixels]$lyr.1, 9)[keep]),
           simulate.p.value = TRUE)

## Example showing asymmetry
sams &lt;- ncell(a) / 4 - ncol(a) / 4 * 3
circs &lt;- spread2(a, spreadProb = 0.213, start = sams,
                 asymmetry = 2, asymmetryAngle = 135,
                 asRaster = TRUE)
## ADVANCED: Estimate spreadProb when using asymmetry, such that the expected
##   event size is the same as without using asymmetry

  if (interactive()) {
    # Still using `raster` as it works more easily with parallelism due to not using pointers
    #   This will updated at a later release
    if (requireNamespace("raster", quietly = TRUE)) {
      ras &lt;- raster::raster(a)
      ras[] &lt;- 1

      n &lt;- 100
      sizes &lt;- integer(n)
      for (i in 1:n) {
        circs &lt;- spread2(ras, spreadProb = 0.225,
                         start = round(ncell(ras) / 4 - ncol(ras) / 4 * 3),
                         asRaster = FALSE)
        sizes[i] &lt;- circs[, .N]
      }
      goalSize &lt;- mean(sizes)

      if (requireNamespace("DEoptim", quietly = TRUE)) {
        library(parallel)
        library(DEoptim)

        # need 10 cores for 10 populations in DEoptim
        cl &lt;- makeCluster(pmin(10, detectCores() - 2))
        parallel::clusterEvalQ(cl, {
          library(SpaDES.tools)
          library(terra)
          library(raster)
          library(fpCompare)
        })

        objFn &lt;- function(sp, n = 20, ras, goalSize) {
          sizes &lt;- integer(n)
          for (i in 1:n) {
            circs &lt;- spread2(ras, spreadProb = sp, start = ncell(ras) / 4 - ncol(ras) / 4 * 3,
                             asymmetry = 2, asymmetryAngle = 135,
                             asRaster = FALSE)
            sizes[i] &lt;- circs[, .N]
          }
          abs(mean(sizes) - goalSize)
        }
        aa &lt;- DEoptim(objFn, lower = 0.2, upper = 0.23,
                      control =
                        DEoptim.control(
                          cluster = cl, NP = 10, VTR = 0.02,
                          # imposing itermax simply for example; should let go to completion
                          itermax = 5,
                          initialpop = as.matrix(rnorm(10, 0.213, 0.001))),
                      ras = ras, goalSize = goalSize)

        # The value of spreadProb that will give the
        #    same expected event sizes to spreadProb = 0.225 is:
        sp &lt;- aa$optim$bestmem
        circs &lt;- spread2(ras, spreadProb = sp, start = ncell(ras) / 4 - ncol(ras) / 4 * 3,
                         asymmetry = 2, asymmetryAngle = 135, asRaster = FALSE)

        stopCluster(cl)
      }
    }
  }

  # clean up
  data.table::setDTthreads(origDTThreads)
  options(Ncpus = origNcpus)

</code></pre>

<hr>
<h2 id='spread3'>An alternative spread function, conceived for insects</h2><span id='topic+spread3'></span>

<h3>Description</h3>

<p>This is built with <code><a href="#topic+spread2">spread2()</a></code> and is still experimental.
This one differs from other attempts in that it treats the advection and
dispersal as mathematical vectors that are added together.
They are &quot;rounded&quot; to pixel centres.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spread3(
  start,
  rasQuality,
  rasAbundance,
  advectionDir,
  advectionMag,
  meanDist,
  dispersalKernel = "exponential",
  sdDist = 1,
  plot.it = 2,
  minNumAgents = 50,
  verbose = getOption("LandR.verbose", 0),
  saveStack = NULL,
  skipChecks = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spread3_+3A_start">start</code></td>
<td>
<p>Raster indices from which to initiate dispersal</p>
</td></tr>
<tr><td><code id="spread3_+3A_rasquality">rasQuality</code></td>
<td>
<p>A raster with habitat quality. Currently, must
be scaled from 0 to 1, i.e., a probability of &quot;settling&quot;</p>
</td></tr>
<tr><td><code id="spread3_+3A_rasabundance">rasAbundance</code></td>
<td>
<p>A raster where each pixel represents the number
of &quot;agents&quot; or pseudo-agents contained. This number of agents, will
be spread horizontally, and distributed from each pixel
that contains a non-zero non NA value.</p>
</td></tr>
<tr><td><code id="spread3_+3A_advectiondir">advectionDir</code></td>
<td>
<p>A single number or <code>RasterLayer</code> in degrees from North = 0
(though it will use radians if all values are <code style="white-space: pre;">&#8288;abs(advectionDir) &gt; 2 * pi)&#8288;</code>.
This indicates the direction of advective forcing (i.e., wind).</p>
</td></tr>
<tr><td><code id="spread3_+3A_advectionmag">advectionMag</code></td>
<td>
<p>A single number or <code>RasterLayer</code> in distance units of the
<code>rasQuality</code>, e.g., meters, indicating the relative forcing that will
occur. It is imposed on the total event, i.e., if the <code>meanDist</code> is
<code>10000</code>, and <code>advectionMag</code> is <code>5000</code>, then the expected
distance (i.e., <code style="white-space: pre;">&#8288;63%&#8288;</code> of agents) will have settled by <code>15000</code> map units.</p>
</td></tr>
<tr><td><code id="spread3_+3A_meandist">meanDist</code></td>
<td>
<p>A single number indicating the mean distance parameter in map units
(not pixels), for a negative exponential distribution
dispersal kernel (e.g., <code>dexp</code>). This will mean that <code style="white-space: pre;">&#8288;63%&#8288;</code> of agents will have
settled at this <code>meanDist</code> (still experimental).</p>
</td></tr>
<tr><td><code id="spread3_+3A_dispersalkernel">dispersalKernel</code></td>
<td>
<p>One of either <code>"exponential"</code> or <code>"weibull"</code>.</p>
</td></tr>
<tr><td><code id="spread3_+3A_sddist">sdDist</code></td>
<td>
<p>A single number indicating the <code>sd</code> parameter of a two-parameter
<code>dispersalKernel</code>.
Defaults to <code>1</code>, which is the same as the <code>exponential</code> distribution.</p>
</td></tr>
<tr><td><code id="spread3_+3A_plot.it">plot.it</code></td>
<td>
<p>Numeric. With increasing numbers above 0, there will be plots
produced during iterations. Currently, only 0, 1, or 2+ are distinct.</p>
</td></tr>
<tr><td><code id="spread3_+3A_minnumagents">minNumAgents</code></td>
<td>
<p>Single numeric indicating the minimum number of agents
to consider all dispersing finished. Default is 50.</p>
</td></tr>
<tr><td><code id="spread3_+3A_verbose">verbose</code></td>
<td>
<p>Numeric. With increasing numbers above 0, there will be more
messages produced. Currently, only 0, 1, or 2+ are distinct.</p>
</td></tr>
<tr><td><code id="spread3_+3A_savestack">saveStack</code></td>
<td>
<p>If provided as a character string, it will save each iteration
as part of a <code>rasterStack</code> to disk upon exit.</p>
</td></tr>
<tr><td><code id="spread3_+3A_skipchecks">skipChecks</code></td>
<td>
<p>Logical. If <code>TRUE</code>, assertions will be skipped (faster, but could miss
problems)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.table</code> with all information used during the spreading
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## these tests are fairly heavy, so don't run during automated tests
#########################################################
# Simple case, no variation in rasQuality, numeric advectionDir and advectionMag
#########################################################

  library(terra)

  origDTThreads &lt;- data.table::setDTthreads(2L)
  origNcpus &lt;- options(Ncpus = 2L)

  maxDim &lt;- 10000
  ras &lt;- terra::rast(terra::ext(c(0, maxDim, 0, maxDim)), res = 100, vals = 0)
  rasQuality &lt;- terra::rast(ras)
  rasQuality[] &lt;- 1
  rasAbundance &lt;- terra::rast(rasQuality)
  rasAbundance[] &lt;- 0
  # startPixel &lt;- middlePixel(rasAbundance)
  startPixel &lt;- sample(seq(terra::ncell(rasAbundance)), 30)
  rasAbundance[startPixel] &lt;- 1000
  advectionDir &lt;- 70
  advectionMag &lt;- 4 * res(rasAbundance)[1]
  meanDist &lt;- 2600

  # Test the dispersal kernel -- create a function
  plotDispersalKernel &lt;- function(out, meanAdvectionMag) {
    out[, disGroup := round(distance / 100) * 100]
    freqs &lt;- out[, .N, by = "disGroup"]
    freqs[, `:=`(cumSum = cumsum(N), N = N)]
    plot(freqs$disGroup, freqs$cumSum, # addTo = "CumulativeNumberSettled",
         main = "Cumulative Number Settled") # can plot the distance X number
    abline(v = meanAdvectionMag + meanDist)
    newTitle &lt;- "Number Settled By Distance"
    plot(freqs$disGroup, freqs$N, # addTo = gsub(" ", "", newTitle),
         main = newTitle) # can plot the distance X number
    abline(v = meanAdvectionMag + meanDist)
    # should be 0.63:
    freqs[disGroup == meanAdvectionMag + meanDist, cumSum] / tail(freqs, 1)[, cumSum]
    mtext(side = 3, paste("Average habitat quality: ",
                          round(mean(rasQuality[], na.rm = TRUE), 2)),
          outer = TRUE, line = -2, cex = 2)
  }
  out &lt;- spread3(rasAbundance = rasAbundance,
                 rasQuality = rasQuality,
                 advectionDir = advectionDir,
                 advectionMag = advectionMag,
                 meanDist = meanDist, verbose = 2,
                 plot.it = interactive())

  plotDispersalKernel(out, advectionMag)

  # The next examples are potentially time consuming; avoid on automated testing
  if (interactive()) {
    #########################################################
    ### The case of variable quality raster
    #########################################################
    rasQuality &lt;- terra::rast(system.file("extdata", "rasQuality.tif",
                                          package = "SpaDES.tools"))
    terra::crs(rasQuality) &lt;- system.file("extdata", "targetCRS.rds", package = "SpaDES.tools") |&gt;
      readRDS() |&gt;
      slot("projargs")
    mask &lt;- rasQuality &lt; 5
    rasQuality[mask[] %in% TRUE] &lt;- 0
    # rescale so min is 0.75 and max is 1
    rasQuality[] &lt;- rasQuality[] / (reproducible::maxFn(rasQuality) * 4) + 1 / 4
    rasAbundance &lt;- terra::rast(rasQuality)
    rasAbundance[] &lt;- 0
    startPixel &lt;- sample(seq(ncell(rasAbundance)), 300)
    rasAbundance[startPixel] &lt;- 1000
    advectionDir &lt;- 75
    advectionMag &lt;- 4 * res(rasAbundance)[1]
    meanDist &lt;- 2600
    out &lt;- spread3(rasAbundance = rasAbundance,
                   rasQuality = rasQuality,
                   advectionDir = advectionDir,
                   advectionMag = advectionMag,
                   meanDist = meanDist, verbose = 2,
                   plot.it = interactive())
    if (interactive()) {
      plotDispersalKernel(out, advectionMag)
    }

    ###############################################################################
    ### The case of variable quality raster, raster for advectionDir &amp; advectionMag
    ###############################################################################
    maxDim &lt;- 10000
    ras &lt;- terra::rast(terra::ext(c(0, maxDim, 0, maxDim)), res = 100, vals = 0)
    rasQuality &lt;- terra::rast(ras)
    rasQuality[] &lt;- 1
    rasAbundance &lt;- terra::rast(rasQuality)
    rasAbundance[] &lt;- NA
    # startPixel &lt;- middlePixel(rasAbundance)
    startPixel &lt;- sample(seq(ncell(rasAbundance)), 25)
    rasAbundance[startPixel] &lt;- 1000

    # raster for advectionDir
    advectionDir &lt;- terra::rast(system.file("extdata", "advectionDir.tif",
                                            package = "SpaDES.tools"))
    crs(advectionDir) &lt;- crs(rasQuality)
    # rescale so min is 0.75 and max is 1
    advectionDir[] &lt;- advectionDir[] / (reproducible::maxFn(advectionDir)) * 180

    # raster for advectionMag
    advectionMag &lt;- terra::rast(system.file("extdata", "advectionMag.tif",
                                            package = "SpaDES.tools"))
    crs(advectionMag) &lt;- crs(rasQuality)
    # rescale so min is 0.75 and max is 1
    advectionMag[] &lt;- advectionMag[] / (reproducible::maxFn(advectionMag)) * 600

    out &lt;- spread3(rasAbundance = rasAbundance,
                   rasQuality = rasQuality,
                   advectionDir = advectionDir,
                   advectionMag = advectionMag,
                   meanDist = meanDist, verbose = 2,
                   plot.it = interactive())

    if (interactive()) {
      names(advectionDir) &lt;- "Wind direction"
      names(advectionMag) &lt;- "Wind speed"
      names(rasAbundance) &lt;- "Initial abundances"
      terra::plot(c(advectionDir, advectionMag, rasAbundance))

      plotDispersalKernel(out, mean(advectionMag[]))
    }

    #########################################
    # save iterations to a stack to make animated GIF
    ########################################
    tmpStack &lt;- tempfile(pattern = "stackToAnimate", fileext = ".tif")
    out &lt;- spread3(rasAbundance = rasAbundance,
                   rasQuality = rasQuality,
                   advectionDir = advectionDir,
                   advectionMag = advectionMag,
                   meanDist = 2600, verbose = 2,
                   plot.it = interactive(), saveStack = tmpStack)

    ## This animates the series of images into an animated GIF
    if (require(animation, quietly = TRUE)) {
      out2 &lt;- terra::rast(tmpStack)
      gifName &lt;- file.path(tempdir(), "animation.gif")

      # Only works on some systems; may need to configure
      # Works on Windows without system adjustments
      if (identical(.Platform$OS.type, "windows"))
        saveGIF(interval = 0.1, movie.name = gifName, expr = {
          for (i in seq(length(names(out2)))) terra::plot(out2[[i]])
        })
    }
  }

  # clean up
  data.table::setDTthreads(origDTThreads)
  options(Ncpus = origNcpus)

</code></pre>

<hr>
<h2 id='testEquivalentMetadata'>Test that metadata of 2 or more objects is the same</h2><span id='topic+testEquivalentMetadata'></span>

<h3>Description</h3>

<p>Currently, only Raster class has a useful method. Defaults to
<code>all(sapply(list(...)[-1], function(x) identical(list(...)[1], x)))</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testEquivalentMetadata(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testEquivalentMetadata_+3A_...">...</code></td>
<td>
<p>2 or more of the same type of object to test for equivalent metadata.</p>
</td></tr>
</table>

<hr>
<h2 id='transitions'><code>SELES</code> - Transitioning to next time step</h2><span id='topic+transitions'></span>

<h3>Description</h3>

<p>Describes the probability of an agent successfully persisting until next
time step. THIS IS NOT YET FULLY IMPLEMENTED.
</p>
<p>A <code>SELES</code>-like function to maintain conceptual backwards compatibility
with that simulation tool. This is intended to ease transitions from
<a href="http://www.gowlland.ca/">SELES</a>.
</p>
<p>You must know how to use SELES for these to be useful.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transitions(p, agent)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transitions_+3A_p">p</code></td>
<td>
<p>realized probability of persisting (i.e., either 0 or 1).</p>
</td></tr>
<tr><td><code id="transitions_+3A_agent">agent</code></td>
<td>
<p><code style="white-space: pre;">&#8288;SpatialPoints*&#8288;</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns new <code style="white-space: pre;">&#8288;SpatialPoints*&#8288;</code> object with potentially fewer agents.
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>

<hr>
<h2 id='wrap'>Wrap coordinates or pixels in a torus-like fashion</h2><span id='topic+wrap'></span>

<h3>Description</h3>

<p>Generally useful for model development purposes. Primarily used internally
in e.g., <code>crw</code> if <code>torus = TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrap(X, bounds, withHeading = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wrap_+3A_x">X</code></td>
<td>
<p><code>SpatVector</code>, <code>sf</code>, or matrix of coordinates.</p>
</td></tr>
<tr><td><code id="wrap_+3A_bounds">bounds</code></td>
<td>
<p>Either a <code style="white-space: pre;">&#8288;SpatRaster*&#8288;</code>, <code>Extent</code>, or <code>bbox</code> object defining bounds to wrap around.</p>
</td></tr>
<tr><td><code id="wrap_+3A_withheading">withHeading</code></td>
<td>
<p>logical. If <code>TRUE</code>, the previous points must be wrapped
also so that the subsequent heading calculation will work.
Default <code>FALSE</code>. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>withHeading</code> used, then <code>X</code> must be an <code>sf</code> or <code>SpatVector</code> object
that contains two columns, <code>x1</code> and <code>y1</code>, with the immediately
previous agent locations.
</p>


<h3>Value</h3>

<p>Object of the same class as <code>X</code>, but with coordinates updated to reflect the wrapping.
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>


<h3>Examples</h3>

<pre><code class='language-R'>origDTThreads &lt;- data.table::setDTthreads(2L)
origNcpus &lt;- options(Ncpus = 2L)

xrange &lt;- yrange &lt;- c(-50, 50)
hab &lt;- terra::rast(terra::ext(c(xrange, yrange)))
hab[] &lt;- 0

# initialize agents
N &lt;- 10

# previous points
x1 &lt;- y1 &lt;- rep(0, N)
# initial points
starts &lt;- cbind(x = stats::runif(N, xrange[1], xrange[2]),
                y = stats::runif(N, yrange[1], yrange[2]))

# create the agent object # the x1 and y1 are needed for "previous location"
agent &lt;- terra::vect(data.frame(x1, y1, starts), geom = c("x", "y"))

ln &lt;- rlnorm(N, 1, 0.02) # log normal step length
sd &lt;- 30 # could be specified globally in params

if (interactive()) {
  # clearPlot()
  terra::plot(hab, col = "white")
}

for (i in 1:10) {
  agent &lt;- crw(agent = agent, extent = terra::ext(hab), stepLength = ln,
               stddev = sd, lonlat = FALSE, torus = FALSE) # don't wrap
  if (interactive()) terra::plot(agent[, 1], add = TRUE, col = 1:10)
}
terra::crds(agent) # many are "off" the map, i.e., beyond the extent of hab
agent &lt;- SpaDES.tools::wrap(agent, bounds = terra::ext(hab))
terra::plot(agent, add = TRUE, col = 1:10) # now inside the extent of hab

# clean up
data.table::setDTthreads(origDTThreads)
options(Ncpus = origNcpus)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
