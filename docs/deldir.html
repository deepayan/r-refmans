<!DOCTYPE html><html><head><title>Help for package deldir</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {deldir}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cvt'>
<p>Centroidal Voronoi (Dirichlet) tessellation.</p></a></li>
<li><a href='#deldir'>
<p>Delaunay triangulation and Dirichlet tessellation</p></a></li>
<li><a href='#deldir-internal'><p>Internal deldir functions</p></a></li>
<li><a href='#divchain'>
<p>Dividing chain.</p></a></li>
<li><a href='#duplicatedxy'>
<p>Determine duplicated points.</p></a></li>
<li><a href='#getNbrs'>
<p>List Delaunay neighbours.</p></a></li>
<li><a href='#grapherXmpl'>
<p>grapherXmpl</p></a></li>
<li><a href='#lawSummary'>
<p>Produce a Lewis-Aboav-Weaire summary of a tessellation.</p></a></li>
<li><a href='#niProperties'>
<p>Northern Ireland properties.</p></a></li>
<li><a href='#plot.deldir'>
<p>Plot objects produced by deldir</p></a></li>
<li><a href='#plot.divchain'>
<p>Plot a dividing chain.</p></a></li>
<li><a href='#plot.tile.list'><p> Plot Dirichlet (Voronoi) tiles</p></a></li>
<li><a href='#plot.triang.list'><p> Plot Delaunay triangles</p></a></li>
<li><a href='#print.deldir'>
<p>Print some information about a tessellation/triangulation.</p></a></li>
<li><a href='#print.tileInfo'>
<p>Print a summary of tile information.</p></a></li>
<li><a href='#seaweed'>
<p>seaweed</p></a></li>
<li><a href='#tile.centroids'>
<p>Compute centroids of Dirichlet (Voronoi) tiles</p></a></li>
<li><a href='#tile.list'><p> Create a list of tiles in a tessellation</p></a></li>
<li><a href='#tileArea'>
<p>Area of a Dirichlet tile.</p></a></li>
<li><a href='#tileInfo'>
<p>Extract information from a tile list.</p></a></li>
<li><a href='#tilePerim'>
<p>Calculate tile perimeters.</p></a></li>
<li><a href='#toyPattern'>
<p>A toy marked point pattern object, with 59 points.</p></a></li>
<li><a href='#triang.list'>
<p>Create a list of Delaunay triangles</p></a></li>
<li><a href='#triMat'>
<p>Produce matrix of triangle vertex indices.</p></a></li>
<li><a href='#volTriPoints'>
<p>Solute plume concentration data set.</p></a></li>
<li><a href='#which.tile'>
<p>Determine the tile containing a given point.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.0-4</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-27</td>
</tr>
<tr>
<td>Title:</td>
<td>Delaunay Triangulation and Dirichlet (Voronoi) Tessellation</td>
</tr>
<tr>
<td>Author:</td>
<td>Rolf Turner</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rolf Turner &lt;rolfturner@posteo.net&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>polyclip</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grDevices</td>
</tr>
<tr>
<td>Description:</td>
<td>Calculates the Delaunay triangulation and the Dirichlet
	or Voronoi tessellation (with respect to the entire plane) of
	a planar point set. Plots triangulations and tessellations in
	various ways.  Clips tessellations to sub-windows. Calculates
	perimeters of tessellations.  Summarises information about
	the tiles of the tessellation.	Calculates the centroidal
	Voronoi (Dirichlet) tessellation using Lloyd's algorithm.</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-27 02:48:30 UTC; rolf</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-28 04:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cvt'>
Centroidal Voronoi (Dirichlet) tessellation.
</h2><span id='topic+cvt'></span>

<h3>Description</h3>

<p>Calculates the centroidal Voronoi (Dirichlet) tessellation using
Lloyd's algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    cvt(object, stopcrit = c("change", "maxit"), tol = NULL,
       maxit = 100, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cvt_+3A_object">object</code></td>
<td>

<p>An object of class either <code>"deldir"</code> (as returned by <code><a href="#topic+deldir">deldir</a>()</code>)
or <code>"tile.list"</code> (as returned by <code><a href="#topic+tile.list">tile.list</a>()</code>).
</p>
</td></tr>
<tr><td><code id="cvt_+3A_stopcrit">stopcrit</code></td>
<td>

<p>Text string specifying the stopping criterion for the algorithm. If
this is <code>"change"</code> then the algorithm halts when the maximum
change in in the distances between corresponding centroids,
between iterations, is less than <code>tol</code> (see below).
It <code>stopcrit</code> is <code>"maxit"</code> then the algorithm halts
after a specified number of iterations (<code>maxit</code>; see below)
have been completed.  This argument may be abbreviated, e.g. to
<code>"c"</code> or <code>"m"</code>.
</p>
</td></tr>
<tr><td><code id="cvt_+3A_tol">tol</code></td>
<td>

<p>The tolerance used when the stopping criterion is <code>"change"</code>.
Defaults to <code>.Machine$double.eps</code>.
</p>
</td></tr>
<tr><td><code id="cvt_+3A_maxit">maxit</code></td>
<td>

<p>The maximum number of iterations to perform when the stopping criterion
is <code>"maxit"</code>.
</p>
</td></tr>
<tr><td><code id="cvt_+3A_verbose">verbose</code></td>
<td>

<p>Logical scalar.  If <code>verbose</code> is <code>TRUE</code> then rudimentary
&ldquo;progress reports&rdquo; are printed out, every 10 iterations if
the stopping criterion is <code>"change"</code> or every iteration if the
stopping criterion is <code>"maxit"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm iteratively tessellates a set of points and
then replaces the points with the centroids of the tiles associated
with those points.  &ldquo;Eventually&rdquo; (at convergence) points
and the centroids of their associated tiles coincide.
</p>


<h3>Value</h3>

<p>A list with components:
</p>
<table>
<tr><td><code>centroids</code></td>
<td>
<p>A data frame with columns <code>"x"</code> and
<code>"y"</code> specifying the coordinates of the limiting locations
of the tile centroids.</p>
</td></tr>
<tr><td><code>tiles</code></td>
<td>
<p>An object of class <code>"tile.list"</code> specifying
the Dirichlet (Voronoi) tiles in the tessellation of the points
whose coordinates are given in <code>centroids</code>.  Note the tile
associated with the <code class="reqn">i</code>th point has centroid <em>equal</em>
to that point.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function was added to the <code>deldir</code> package at the
suggestion of Dr. MichaÃ«l Aupetit, Senior Scientist at the
Qatar Computing Research Institute, Hamad Bin Khalifa University.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner <a href="mailto:rolfurner@posteo.net">rolfurner@posteo.net</a></p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Lloyd's_algorithm">https://en.wikipedia.org/wiki/Lloyd's_algorithm</a>
</p>
<p>Lloyd, Stuart P. (1982). Least squares quantization in PCM.
<em>IEEE Transactions on Information Theory</em> <b>28</b> (2),
pp. 129&ndash;137, doi:10.1109/TIT.1982.1056489.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+deldir">deldir</a>()</code> <code><a href="#topic+tile.list">tile.list</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:  # Takes too long.
    set.seed(42)
    x &lt;- runif(20)
    y &lt;- runif(20)
    dxy &lt;- deldir(x,y,rw=c(0,1,0,1))
    cxy1 &lt;- cvt(dxy,verb=TRUE)
    plot(cxy1$tiles)
    with(cxy1$centroids,points(x,y,pch=20,col="red"))
    cxy2 &lt;- cvt(dxy,stopcrit="m",verb=TRUE)
    plot(cxy2$tiles)
    with(cxy2$centroids,points(x,y,pch=20,col="red"))
# Visually indistinguishable from the cxy1 plot.
# But ...
    all.equal(cxy1$centroids,cxy2$centroids) # Not quite.
    cxy3 &lt;- cvt(dxy,stopcrit="m",verb=TRUE,maxit=250)
    all.equal(cxy1$centroids,cxy3$centroids) # Close, but no cigar.
    cxy4 &lt;- cvt(dxy,verb=TRUE,tol=1e-14)
    cxy5 &lt;- cvt(dxy,stopcrit="m",verb=TRUE,maxit=600)
    all.equal(cxy4$centroids,cxy5$centroids) # TRUE
# Takes a lot of iterations or a really small tolerance
# to get "good" convergence.  But this is almost surely
# of no practical importance.
    txy &lt;- tile.list(dxy)
    cxy6 &lt;- cvt(txy)
    all.equal(cxy6$centroids,cxy1$centroids) # TRUE

## End(Not run)
</code></pre>

<hr>
<h2 id='deldir'>
Delaunay triangulation and Dirichlet tessellation
</h2><span id='topic+deldir'></span>

<h3>Description</h3>

<p>This function computes the Delaunay triangulation (and hence the
Dirichlet or Voronoi tessellation) of a planar point set according
to the second (iterative) algorithm of Lee and Schacter &mdash; see
<b>References</b>.  The triangulation is made to be with respect to
the whole plane by &ldquo;suspending&rdquo; it from so-called ideal points
(-Inf,-Inf), (Inf,-Inf) (Inf,Inf), and (-Inf,Inf).  The triangulation
is also enclosed in a finite rectangular window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deldir(x, y, z=NULL, rw=NULL, eps=1e-09, sort=TRUE, plot=FALSE,
       round=TRUE,digits=6, id=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deldir_+3A_x">x</code>, <code id="deldir_+3A_y">y</code></td>
<td>

<p>These arguments specify the coordinates of the point set being
triangulated/tessellated.  Argument <code>x</code> may be a numeric
vector or it may be a data structure consisting of a matrix, a
data frame, a generic list, or an object of class <code>"ppp"</code>.
(See package <code>spatstat</code>.)  Argument <code>y</code>, if specified, is
always a numeric vector.  The <code>"x"</code> and <code>"y"</code> coordinates
are extracted from arguments <code>x</code> and <code>y</code>  according to
(what can be, in some instances) a rather complicated protocol.
See <b>Notes on extracting the coordinates</b> for details of
this protocol.
</p>
</td></tr>
<tr><td><code id="deldir_+3A_z">z</code></td>
<td>

<p>Optional argument specifying &ldquo;auxiliary&rdquo; values or
&ldquo;tags&rdquo; associated with the respective points.  (See
<b>Notes on &ldquo;tags&rdquo;</b>.) This argument may be a vector or
factor whose entries constitute these tags, or it may be a text
string naming such a vector or factor.  If <code>z</code>, or the object
named by <code>z</code> is a vector (rather than a factor) it may be
of any mode (numeric, character, logical, etc.).  See <b>Notes
on extracting <code>z</code></b> for how <code>z</code> is handled when argument
<code>x</code> is a data structure (rather than a numeric vector).
</p>
</td></tr>
<tr><td><code id="deldir_+3A_rw">rw</code></td>
<td>

<p>The coordinates of the corners of the rectangular window enclosing
the triangulation, in the order (xmin, xmax, ymin, ymax).  Any data
points outside this window are discarded.  If this argument is
omitted, it defaults to values given by the range of the data,
plus and minus 10 percent.
</p>
</td></tr>
<tr><td><code id="deldir_+3A_eps">eps</code></td>
<td>

<p>A value of epsilon used in testing whether a quantity is zero, mainly
in the context of whether points are collinear.  If anomalous errors
arise, it is possible that these may averted by adjusting the value
of eps upward or downward.
</p>
</td></tr>
<tr><td><code id="deldir_+3A_sort">sort</code></td>
<td>

<p>Logical argument; if <code>TRUE</code> (the default) the data are sorted
into a sequence of &ldquo;bins&rdquo; prior to triangulation; this makes
the algorithm slightly more efficient.  Normally one would set
<code>sort</code> equal to <code>FALSE</code> only if one wished to observe
some of the fine detail of the way in which adding a point to a
data set affected the triangulation, and therefore wished to make
sure that the point in question was added last.  Essentially this
argument would get used only in a debugging process.
</p>
</td></tr>
<tr><td><code id="deldir_+3A_plot">plot</code></td>
<td>

<p>Logical argument; if <code>TRUE</code> a plot is produced.  The nature
of the plot may be controlled by using the <code>...</code> argument
to pass appropriate arguments to <code>plot.deldir()</code>.  Without
&ldquo;further instruction&rdquo; a plot of the points being triangulated
and of both the triangulation and the tessellation is produced;
</p>
</td></tr>
<tr><td><code id="deldir_+3A_round">round</code></td>
<td>

<p>Logical scalar.  Should the data stored in the returned value
be rounded to <code>digits</code> decimal digits?  This is essentially
for cosmetic purposes.  This argument is a &ldquo;new addition&rdquo;
to <code>deldir()</code>, as of version 0.1-26.  Previously rounding
was done willy-nilly.  The change was undertaken when Kodi
Arfer pointed out that the rounding might have unwanted effects
upon &ldquo;downstream&rdquo; operations.
</p>
</td></tr>
<tr><td><code id="deldir_+3A_digits">digits</code></td>
<td>

<p>The number of decimal places to which all numeric values in the
returned list should be rounded.  Defaults to 6. Ignored if
<code>round</code> (see above) is set to <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="deldir_+3A_id">id</code></td>
<td>

<p>Optional vector of the same length as <code>x</code> and
<code>y</code>, providing identifiers for the points that are being
triangulated/tessellated.  This vector will be coerced to mode
<code>"character"</code> internally.  If <code>id</code> is not specified,
it defaults to the sequence of indices of the points.  Note that
<code>id</code> must specify identifiers for <em>all</em> points, even
though some of these points may be dropped from consideration if
they do not lie inside the &ldquo;rectangular window&rdquo; <code>rw</code>.
Note also that <code>id</code> must contain no duplicate values.
</p>
<p>The <code>id</code> argument should not be confused with the <code>z</code>
argument.  The two are entirely different and serve entirely different
purposes.
</p>
</td></tr>
<tr><td><code id="deldir_+3A_...">...</code></td>
<td>

<p>Auxiliary arguments <code>add</code>, <code>wlines</code>,
<code>labelPts</code>, <code>lex</code>, <code>col</code>, <code>lty</code>, <code>pch</code>,
<code>xlim</code>, and <code>ylim</code> (and possibly other plotting parameters)
may be passed to <code><a href="#topic+plot.deldir">plot.deldir</a>()</code> through <code>...</code>
if <code>plot=TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This package had its origins (way back in the mists of time!)  as an
Splus library section named &ldquo;delaunay&rdquo;.  That library section
in turn was a re-write of a stand-alone Fortran program written
in 1987/88 while the author was with the Division of Mathematics
and Statistics, CSIRO, Sydney, Australia.  This program was an
implementation of the second (iterative) Lee-Schacter algorithm.
The stand-alone Fortran program was re-written as an Splus function
(which called upon dynamically loaded Fortran code) while the author
was visiting the University of Western Australia, May, 1995.
</p>
<p>Further revisions were made December 1996. The author gratefully
acknowledges the contributions, assistance, and guidance of Mark
Berman, of D.M.S., CSIRO, in collaboration with whom this project
was originally undertaken.  The author also acknowledges much useful
advice from Adrian Baddeley, formerly of D.M.S., CSIRO (now
Professor of Statistics at Curtin University).
Daryl Tingley of the Department of Mathematics
and Statistics, University of New Brunswick, provided some helpful
insight.  Special thanks are extended to Alan Johnson, of the
Alaska Fisheries Science Centre, who supplied two data sets which
were extremely valuable in tracking down some errors in the code.
</p>
<p>Don MacQueen, of Lawrence Livermore National Lab, wrote an Splus
driver function for the old stand-alone version of this software.
That driver, which was available on Statlib, was deprecated in favour
of the Statlib package &ldquo;delaunay&rdquo;.  Don also collaborated
in the preparation of the latter package.  It is not clear to me
whether the &ldquo;delaunay&rdquo; package, or indeed Statlib (or indeed
Splus!) still exist.
</p>
<p>See the <code>ChangeLog</code> for information about further revisions
and bug-fixes.
</p>


<h3>Value</h3>

<p>A list (of class <code>deldir</code>), invisible if <code>plot=TRUE</code>, with components:
</p>
<table>
<tr><td><code>delsgs</code></td>
<td>

<p>A data frame with 6 columns.  The first 4 entries of each row are the
coordinates of the points joined by an edge of a Delaunay triangle,
in the order <code>(x1,y1,x2,y2)</code>.  The last two entries are the
identifiers (defaulting to the indices, if <code>id</code> is not supplied)
of the two points which are joined.
</p>
</td></tr>
<tr><td><code>dirsgs</code></td>
<td>

<p>A data frame with 10 columns.  The first 4 entries of each
row are the coordinates of the endpoints of one the edges of a
Dirichlet tile, in the order <code>(x1,y1,x2,y2)</code>.  The fifth and
sixth entries, in the columns named <code>ind1</code> and <code>ind2</code>,
are the identifiers (defaulting to the indices, if <code>id</code> is
not supplied)  of the two points, in the set being triangulated,
which are separated by that edge. The seventh and eighth entries,
in the columns named <code>bp1</code> and <code>bp2</code> are logical values.
The entry in column <code>bp1</code> indicates whether the first endpoint
of the corresponding edge of a Dirichlet tile is a boundary point
(a point on the boundary of the rectangular window).  Likewise for
the entry in column <code>bp2</code> and the second endpoint of the edge.
</p>
<p>The ninth and tenth entries, in columns named <code>thirdv1</code>
and <code>thirdv2</code> are the identifiers of the respective third
vertices of the Delaunay triangles whose circumcentres constitute
the corresponding endpoints of the edge under consideration.
(The other two vertices of the triangle in question are identified by
the entries of columns <code>ind1</code> and <code>ind2</code>.)
</p>
<p>The entries of columns <code>thirdv1</code> and <code>thirdv2</code> may (also)
take the values $-1, -2, -3$, and $-4$. (These will be coerced to
mode character if <code>id</code> was supplied.)  This will be the case
if the circumcentre in question lies outside of the rectangular
window <code>rw</code>.  In these circumstances the corresponding
endpoint of the tile edge is the intersection of the line joining
the two circumcentres with the boundary of <code>rw</code>, and the
numeric value of the entry of column &ldquo;thirdv1&rdquo; (respectively
&ldquo;thirdv2&rdquo;) indicates which side.  The numbering follows the
convention for numbering the sides of a plot region in <code>R</code>:
1 for the bottom side, 2 for the left hand side, 3 for the top side
and 4 for the right hand side.
</p>
<p>Note that the entry in column <code>thirdv1</code> will be negative if and
only if the corresponding entry in column <code>bp1</code> is <code>TRUE</code>.
Similarly for columns <code>thirdv2</code> and <code>bp2</code>.
</p>
</td></tr>
<tr><td><code>summary</code></td>
<td>

<p>a data frame with 9, 10 or 11 columns and <code>n.data</code> rows
(see below).  The rows correspond to the points in the set being
triangulated.  Note that the row names are the indices of the points
in the original sequence of points being triangulated/tessellated.
Usually these will be the sequence 1, 2, ..., n.  However if there
were <em>duplicated</em> points then the row name corresponding to a
point is the <em>first</em> of the indices of the set of duplicated
points in which the given point appears.  The columns are:
</p>

<ul>
<li> <p><code>x</code> (the <code class="reqn">x</code>-coordinate of the point)
</p>
</li>
<li> <p><code>y</code> (the <code class="reqn">y</code>-coordinate of the point)
</p>
</li>
<li> <p><code>id</code> (the identifers of the points; present only if
<code>id</code> was specified)
</p>
</li>
<li> <p><code>z</code> (the auxiliary values or &ldquo;tags&rdquo;; present
only if these were specified)
</p>
</li>
<li> <p><code>n.tri</code> (the number of Delaunay triangles emanating from
the point)
</p>
</li>
<li> <p><code>del.area</code> (1/3 of the total area of all the Delaunay
triangles emanating from the point)
</p>
</li>
<li> <p><code>del.wts</code> (the corresponding entry of the <code>del.area</code>
column divided by the sum of this column)
</p>
</li>
<li> <p><code>n.tside</code> (the number of sides &mdash; within the rectangular
window &mdash; of the Dirichlet tile surrounding the point)
</p>
</li>
<li> <p><code>nbpt</code> (the number of points in which the Dirichlet tile
intersects the boundary of the rectangular window)
</p>
</li>
<li> <p><code>dir.area</code> (the area of the Dirichlet tile surrounding
the point)
</p>
</li>
<li> <p><code>dir.wts</code> (the corresponding entry of the <code>dir.area</code>
column divided by the sum of this column).
</p>
</li></ul>

<p>Note that the factor of 1/3 associated with the del.area column
arises because each triangle occurs three times &mdash; once for
each corner.
</p>
</td></tr>
<tr><td><code>n.data</code></td>
<td>

<p>the number of points in the set which was triangulated, with any
duplicate points eliminated.  It is the same as the number of rows
of <code>summary</code>.
</p>
</td></tr>
<tr><td><code>del.area</code></td>
<td>

<p>the area of the convex hull of the set of points being triangulated,
as formed by summing the <code>del.area</code> column of <code>summary</code>.
</p>
</td></tr>
<tr><td><code>dir.area</code></td>
<td>

<p>the area of the rectangular window enclosing the points being triangulated,
as formed by summing the <code>dir.area</code> column of <code>summary</code>.
</p>
</td></tr>
<tr><td><code>rw</code></td>
<td>

<p>the specification of the corners of the rectangular window enclosing
the data, in the order (xmin, xmax, ymin, ymax).
</p>
</td></tr>
<tr><td><code>ind.orig</code></td>
<td>
<p>A vector of the indices of the points (x,y) in the
set of coordinates initially supplied to <code>deldir()</code> before
duplicate points (if any) were removed.  These indices are used
by <code><a href="#topic+triang.list">triang.list</a>()</code>.
</p>
</td></tr></table>


<h3>Side Effects</h3>

<p>If <code>plot=TRUE</code> a plot of the triangulation and/or tessellation
is produced or added to an existing plot.
</p>


<h3>Notes on extracting the coordinates</h3>

<p>The protocol for extracting the <code class="reqn">x</code> and <code class="reqn">y</code> coordinates
from the arguments <code>x</code> and <code>y</code> is a bit complicated
and confusing.  It is designed to handle a number of different
desiderata and to accommodate various feature-requests that users
have made over the years.  Basically the protocol is:
</p>

<ul>
<li><p> If <code>x</code> is a numeric vector and <code>y</code> is a numeric
vector then <code>x</code> is used as the <code class="reqn">x</code>-coordinates and
<code>y</code> is used as the <code class="reqn">y</code>-coordinates.
</p>
</li>
<li><p> If <code>x</code> is a matrix, a data frame, or a generic list),
and <code>y</code> is a numeric vector, then the <code class="reqn">x</code>-coordinates
are sought amongst the components of <code>x</code> and <code>y</code>
is used as the <code class="reqn">y</code>-coordinates.
</p>
</li>
<li><p> If <code>x</code> is a matrix, a data frame, or a generic list
and <code>y</code> is not specified or cannot be found, then both the
<code class="reqn">x</code>-coordinates and <code class="reqn">y</code>-coordinates are sought amongst
the components of <code>x</code>.
</p>
</li>
<li><p> If <code>x</code> an object of class <code>"ppp"</code> then both the
<code class="reqn">x</code>-coordinates and <code class="reqn">y</code>-coordinates are taken from the
components of <code>x</code>.   If <code>y</code> is specified, it is ignored
(with a warning).
</p>
</li>
<li><p> If <code>x</code> is a numeric vector and <code>y</code> is not specified
or cannot be found, then an error is thrown.
</p>
</li></ul>

<p>A few more details:
</p>

<ul>
<li><p> If <code>x</code> is of class <code>"ppp"</code> then it will definitely
have components named <code>"x"</code> and <code>"y"</code>.
</p>
</li>
<li><p> If <code>x</code> is a generic list, it <em>must</em> have a
component named <code>"x"</code> (otherwise an error is thrown),
and the <code class="reqn">x</code>-coordinates are set equal to this component.
If <code>y</code> is not specified or cannot be found, then a <code>"y"</code>
component of <code>x</code> is sought.  If such a component exists
then the <code class="reqn">y</code>-coordinates are set equal to this component.
Otherwise an error is thrown).
</p>
</li>
<li><p> If <code>x</code> is a matrix or a data frame, the protocol gets
a bit more intricate.
</p>

<ul>
<li><p> If <code>x</code> has a column named <code>"x"</code> then this column
is taken to be the <code class="reqn">x</code>-coordinates.
</p>
</li>
<li><p> Otherwise the <code class="reqn">x</code>-coordinates are taken to be the
<em>first</em> column of <code>x</code> that is not named <code>"y"</code> or
<code>znm</code> (where <code>znm</code> is the name of the object providing
the &ldquo;tags&rdquo;, if &ldquo;tags&rdquo; have been specified).
</p>
</li>
<li><p> If there is no such first column (e.g. if there are only
two columns and these have names <code>"y"</code> and <code>znm</code>)
then an error is thrown.
</p>
</li>
<li><p> If <code>y</code> is not specified or cannot be found, and
if <code>x</code> has a column named <code>"y"</code> then this column is
taken to be the <code class="reqn">y</code>-coordinates.
</p>
</li>
<li><p> Otherwise, in this situation, the <code class="reqn">y</code>-coordinates
are taken to be the <em>first</em> column of <code>x</code> that is
not named <code>"x"</code> or <code>znm</code> and is not equal to the
column previously selected to be the <code>x</code>-coordinates.
</p>
</li>
<li><p> If there is no such first column (e.g. if there are only
two columns and these have names <code>"x"</code> and <code>znm</code>),
then an error is thrown.
</p>
</li></ul>

</li></ul>

<p>Got all that? <code>:-) </code> If these instructions seem rather
bewildering (and indeed they are!) just keep things simple and make
calls like <code>deldir(x,y)</code> where <code>x</code> and <code>y</code> are numeric
vectors that have been previously assigned in the global environment.
</p>


<h3>Notes on extracting <code>z</code></h3>

<p>If argument <code>x</code> is a data structure (rather than a numeric
vector) and is <em>not</em> an object of class <code>"ppp"</code> then
<code>z</code>, if specified and not found, is searched for in <code>x</code>.
If <code>x</code> <em>is</em> of class <code>"ppp"</code> then what happens depends
on whether <code>z</code> was specified or left to take its default value
of <code>NULL</code>.  In the former case, <code>z</code> takes the specified
value.  In the latter case the value of <code>"z"</code> is taken from
the marks of <code>x</code> provided that <code>x</code> is indeed a marked
point pattern and that the marks are <em>atomic</em> (essentially
provided that the marks are not a data frame). Otherwise <code>z</code>
is left <code>NULL</code>, i.e. there are no &ldquo;tags&rdquo; associated
with the points.
</p>


<h3>Notes on &ldquo;tags&rdquo;</h3>

<p>The &ldquo;tags&rdquo; are simply values that are associated in some way
with the data points and hence with the tiles of the tessellation
produced.  They <b>DO NOT</b> affect the tessellation.  In previous
versions of this package (0.2-10 and earlier) the entries of <code>z</code>
were referred to as &ldquo;weights&rdquo;.  This terminology has been
changed since it is misleading.  The tessellation produced when
a <code>z</code> argument is supplied is the same as is it would be
if there were no <code>z</code> argument (i.e. no &ldquo;weights&rdquo;).
The <code>deldir</code> package <b>DOES NOT do weighted tessellation</b>.
</p>


<h3>Notes on Memory Allocation</h3>

<p>It is difficult-to-impossible to determine <em>a priori</em> how much
memory needs to be allocated (in the Fortran code) for storing the
edges of the Delaunay triangles and Dirichlet tiles, and for storing
the &ldquo;adjacency list&rdquo; used by the Lee-Schacter algorithm.
In the code, an attempt is made to allocate sufficient storage.
If, during the course of running the algorithm, the amount of
storage turns out to be inadequate, the algorithm is halted, the
storage is incremented, and the algorithm is restarted (with an
informative message).  This message may be suppressed by wrapping
the call to <code>deldir()</code> in <code><a href="base.html#topic+suppressMessages">suppressMessages</a>()</code>.
</p>


<h3>Notes on error messages</h3>

<p>In previous versions of this package, error traps were set in
the underlying Fortran code for 17 different errors. These were
identified by an error number which was passed back up the call stack
and finally printed out by <code>deldir()</code> which then invisibly
returned a <code>NULL</code> value.  A glossary of the meanings of the
values of was provided in a file to be found in a file located in the
<code>inst</code> directory (&ldquo;folder&rdquo; if you are a Windoze weenie).
</p>
<p>This was a pretty shaganappi system.  Consequently, as of version
1.2-1, conversion to &ldquo;proper&rdquo; error trapping was implemented.
Such error trapping is effected via the <code>rexit()</code> subroutine
which is now available in <code>R</code>.  (See &ldquo;Writing R
Extensions&rdquo;, section 6.2.1.)
</p>
<p>Note that when an error is detected, <code>deldir()</code> now exits with
a genuine error, rather than returning <code>NULL</code>.  The glossary
of the meanings of &ldquo;error numbers&rdquo; is now irrelevant and
has been removed from the <code>inst</code> directory.
</p>
<p>An error trap that merits particular mention was introduced in
version <code>0.1-16</code> of <code>deldir</code>.  This error trap relates to
&ldquo;triangle problems&rdquo;.  It was drawn to my attention by Adam
Dadvar (on 18 December, 2018) that in some data sets collinearity
problems may cause the &ldquo;triangle finding&rdquo; procedure, used
by the algorithm to successively add new points to a tessellation,
to go into an infinite loop.  A symptom of the collinearity is
that the vertices of a putative triangle appear <em>not</em> to be
in anticlockwise order irrespective of whether they are presented
in the order <code>i, j, k</code> or <code>k, j, i</code>.  The result of this
anomaly is that the procedure keeps alternating between moving to
&ldquo;triangle&rdquo; <code>i, j, k</code> and moving to &ldquo;triangle&rdquo;
<code>k, j, i</code>, forever.
</p>
<p>The error trap in question is set in <code>trifnd</code>, the triangle
finding subroutine.  It detects such occurrences of &ldquo;clockwise
in either orientation&rdquo; vertices.  The trap causes the <code>deldir()</code>
function to throw an error rather than disappearing into a black
hole.
</p>
<p>When an error of the &ldquo;triangle problems&rdquo; nature occurs, a
<em>possible</em> remedy is to increase the value of the <code>eps</code>
argument of <code>deldir()</code>. (See the <b>Examples</b>.)  There may
conceivably be other problems that lead to infinite loops and so I
put in another error trap to detect whether the procedure has
inspected more triangles than actually exist, and if so to throw
an error.
</p>
<p>Note that the strategy of increasing the value of <code>eps</code>
is <em>probably</em> the appropriate response in most (if not all)
of the cases where errors of this nature arise.  Similarly this
strategy is <em>probably</em> the appropriate response to the errors
</p>

<ul>
<li><p> Vertices of &ldquo;triangle&rdquo; are collinear and vertex 2 is not
between 1 and 3.  Error in circen.
</p>
</li>
<li><p> Vertices of triangle are collinear.  Error in dirseg.
</p>
</li>
<li><p> Vertices of triangle are collinear.  Error in dirout.
</p>
</li></ul>

<p>However it is impossible to be sure.  The intricacy and numerical
delicacy of triangulations is too great for anyone to be able to
foresee all the possibilities that could arise.
</p>
<p>If there is any doubt as to the appropriateness of the
&ldquo;increase <code>eps</code>&rdquo; strategy, users are advised to do
their best to explore the data set, graphically or by other means,
and thereby determine what is actually going on and why problems
are occurring.
</p>


<h3>Warnings</h3>


<ol>
<li><p> The process for determining if points are duplicated
changed between versions 0.1-9 and 0.1-10.  Previously there
was an argument <code>frac</code> for this function, which defaulted
to 0.0001.  Points were deemed to be duplicates if the difference
in <code>x</code>-coordinates was less than <code>frac</code> times the width
of <code>rw</code> and <code>y</code>-coordinates was less than <code>frac</code>
times the height of <code>rw</code>.  This process has been changed to
one which uses <code><a href="base.html#topic+duplicated">duplicated</a>()</code> on the data frame whose
columns are <code>x</code> and <code>y</code>.
</p>
<p>As a result it may happen that points which were previously
eliminated as duplicates will no longer be eliminated.  (And
possibly vice-versa.)
</p>
</li>
<li><p> The components <code>delsgs</code> and <code>summary</code> of the value
returned by <code>deldir()</code> are now <em>data frames</em> rather than
matrices.  The component <code>summary</code> was changed to allow the
&ldquo;auxiliary&rdquo; values <code>z</code> to be of arbitrary mode (i.e.
not necessarily numeric).  The component <code>delsgs</code> was then
changed for consistency.  Note that the other &ldquo;matrix-like&rdquo;
component <code>dirsgs</code> has been a data frame since time immemorial.
</p>
</li></ol>



<h3>Acknowledgement</h3>

<p>I would like to express my most warm and sincere thanks to Duncan
Murdoch (Emeritus Professor of Statistics, Western University) for
helping me, with incredible patience and forbearance, to straighten
out my thinking in respect of adjustments that I recently (October
2021) made to the argument processing protocol in the <code>deldir()</code>
function.  Duncan provided numerous simple examples to demonstrate
when and how things were going wrong, and patiently explained to
me how I was getting one aspect of the protocol backwards.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner <a href="mailto:rolfurner@posteo.net">rolfurner@posteo.net</a></p>


<h3>References</h3>

<p>Lee, D. T. and Schacter, B. J. (1980). Two algorithms for
constructing a Delaunay triangulation, <em>International Journal
of Computer and Information Sciences</em> <b>9</b> (3), pp. 219 &ndash; 242.
</p>
<p>Ahuja, N. and Schacter, B. J. (1983).  Pattern Models.  New York: Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.deldir">plot.deldir</a>()</code>, <code><a href="#topic+tile.list">tile.list</a>()</code>, <code><a href="#topic+triang.list">triang.list</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(2.3,3.0,7.0,1.0,3.0,8.0)
y &lt;- c(2.3,3.0,2.0,5.0,8.0,9.0)

# Let deldir() choose the rectangular window.
dxy1 &lt;- deldir(x,y)

# User chooses the rectangular window.
dxy2 &lt;- deldir(x,y,rw=c(0,10,0,10))

# Put "dummy" points at the corners of the rectangular
# window, i.e. at (0,0), (10,0), (10,10), and (0,10)
xx &lt;- c(x,0,10,10,0)
yy &lt;- c(y,0,0,10,10)
dxy3 &lt;- deldir(xx,yy,rw=c(0,10,0,10))

# Plot the triangulation created (but not the tessellation).
dxy2 &lt;- deldir(x,y,rw=c(0,10,0,10),plot=TRUE,wl="tr")

# Example of collinearity error.
## Not run: 
    dniP &lt;- deldir(niProperties) # Throws an error

## End(Not run)
    dniP &lt;- deldir(niProperties,eps=1e-8) # No error.

# Example of using data stored in a data frame.
dsw  &lt;- deldir(seaweed)
# Example where "data" is of class "ppp".
dtoy &lt;- deldir(toyPattern)
# The "tags", in dtoy$summary$z, are the marks of the toy ppp
# object which consists of the letters "a","b","c" and "d".

# Artificial example of tags.
set.seed(42)
trees1  &lt;- sample(c("spruce","birch","poplar","shoe"),20,TRUE)
trees2  &lt;- sample(c("fir","maple","larch","palm"),20,TRUE)
egDat   &lt;- data.frame(x=runif(20),y=runif(20),species=trees1)
tagNm   &lt;- "species"
species &lt;- trees2
dd1     &lt;- deldir(egDat) # No tags.
dd2     &lt;- deldir(egDat,z=species)  # Uses trees1 as the tags.
dd3     &lt;- deldir(egDat,z="species") # Same as dd2.
dd4     &lt;- deldir(egDat,z=tagNm) # Same as dd2 and dd3.
spec    &lt;- species
dd5     &lt;- deldir(egDat,z=spec) # Uses trees2 as the tags.

# Duncan Murdoch's examples.  The deldir() function was not
# handling such examples correctly until Duncan kindly set
# me on the right path.
set.seed(123)
dd6 &lt;- deldir(rnorm(32),rnorm(32),rnorm(32))
#
x &lt;- cbind(x = 1:10, junk = 11:20)
y &lt;- 21:30
z &lt;- 31:40
d7 &lt;- deldir(x=x, y=y, z=z)
#
# print(d7$summary) reveals that x is 1:10, y is 21:30
# and z is 31:40; x[,"junk"] is ignored as it should be.
x &lt;- cbind(x = 1:10, "rnorm(10)" = 11:20)
y &lt;- 21:30
z &lt;- 41:50
d8 &lt;- deldir(x=x, y=y, z=rnorm(10))  
#
# print(d8$summary) reveals that x is 1:10, y is 21:30 and z is a
# vector of standard normal values.  Even though x has a column with
# the name of the z argument i.e. "rnorm(10)" (!!!)  the specified
# value of z takes precedence over this column (and, as per the usual
# R syntax) over the object named "z" in the global environment.

# Artificial example of the use of the "id" argument.
set.seed(42)
x  &lt;- runif(50)
y  &lt;- runif(50)
ll &lt;- expand.grid(a=letters[1:10],b=letters[1:10])
aa &lt;- sample(paste0(ll[["a"]],ll[["b"]]),50)
dxy.wid &lt;- deldir(x,y,id=aa)
</code></pre>

<hr>
<h2 id='deldir-internal'>Internal deldir functions</h2><span id='topic++5B.tile.list'></span><span id='topic++5B.triang.list'></span><span id='topic+acw'></span><span id='topic+binsrtR'></span><span id='topic+doClip'></span><span id='topic+findNewInOld'></span><span id='topic+get.cnrind'></span><span id='topic+getCol'></span><span id='topic+insidePoly'></span><span id='topic+insideRect'></span><span id='topic+mid.in'></span><span id='topic+mnndR'></span><span id='topic+prelimtlist'></span><span id='topic+tilePerim0'></span><span id='topic+verGetter'></span>

<h3>Description</h3>

<p>Internal deldir functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tile.list'
x[i,...]
## S3 method for class 'triang.list'
x[i,...]
acw(xxx)
doClip(object,clipp,rw)
binsrtR(x,y,rw)
findNewInOld(xnew,xold,ynew,yold,tolerance=sqrt(.Machine$double.eps))
get.cnrind(x,y,rw)
getCol(x,warn=FALSE)
insidePoly(x,y,pgon,sanityCheck=FALSE,tolerance=sqrt(.Machine$double.eps))
insideRect(x,y,rect,rw)
mid.in(x,y,rx,ry)
mnndR(x,y)
prelimtlist(object)
tilePerim0(object,inclbdry=TRUE)
verGetter()
</code></pre>


<h3>Details</h3>

<p>These functions are auxiliary and are not intended to be called by
the user.
</p>

<hr>
<h2 id='divchain'>
Dividing chain.
</h2><span id='topic+divchain'></span><span id='topic+divchain.default'></span><span id='topic+divchain.deldir'></span>

<h3>Description</h3>

<p>Create the &ldquo;dividing chain&rdquo; of a Dirichlet tessellation.
The tessellation must have been created from a set of points
having associated &ldquo;tags&rdquo;.  The dividing chain consists
of those edges of Dirichlet tiles which separate points having
different values of the given tags.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   divchain(x, ...)
   ## Default S3 method:
divchain(x, y, z, ...)
   ## S3 method for class 'deldir'
divchain(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="divchain_+3A_x">x</code></td>
<td>

<p>Either an object specifying coordinates (in the case of the
<code>"default"</code> method; see <code><a href="#topic+deldir">deldir</a>()</code> for details)
or an object of class &ldquo;deldir&rdquo;.  In the latter case this
object must have been created in such a way that the points of the
set being tessellated have associate categorical &ldquo;tags&rdquo;.
That is, <code><a href="#topic+deldir">deldir</a>()</code> must have been called with a
<code>z</code> argument or the <code>x</code> argument to  <code>deldir()</code>
must have had an appropriate component which could be taken to
be <code>z</code>.  Note that if the value of <code>z</code> that was used
was not a factor, it is coerced to one.
</p>
</td></tr>
<tr><td><code id="divchain_+3A_y">y</code></td>
<td>

<p>A numeric vector constituting the <code class="reqn">y</code>-coordinates of the
set of points being tessellated.  See <code><a href="#topic+deldir">deldir</a>()</code>
for details.  Not used by the <code>"deldir"</code> method.
</p>
</td></tr>
<tr><td><code id="divchain_+3A_z">z</code></td>
<td>

<p>A vector or factor specifying &ldquo;auxiliary&rdquo; values or
&ldquo;tags&rdquo;.  If this argument is left <code>NULL</code> then it
is extracted, if possible, from the components of <code>x</code>.
See <code><a href="#topic+deldir">deldir</a>()</code> for further details.  If <code>z</code> is
not a factor it is coerced to one.  See <code><a href="#topic+deldir">deldir</a>()</code>
for details.  Not used by the <code>"deldir"</code> method.
</p>
</td></tr>
<tr><td><code id="divchain_+3A_...">...</code></td>
<td>

<p>Arguments to be passed to <code>deldir()</code>.  Not used by
the <code>"deldir"</code> method.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &ldquo;divchain&rdquo; consisting of a data frame
with columns named &ldquo;x0&rdquo;, &ldquo;y0&rdquo;, &ldquo;x1&rdquo;,
&ldquo;y1&rdquo;, &ldquo;v01&rdquo;, &ldquo;v02&rdquo;, &ldquo;v03&rdquo;,
&ldquo;v11&rdquo;, &ldquo;v12&rdquo; and &ldquo;v13&rdquo;.
</p>
<p>The columns named &ldquo;x0&rdquo; and &ldquo;y0&rdquo; consist of the
coordinates of one endpoint of an edge of a Dirichlet tile and
the columns named &ldquo;x1&rdquo; and &ldquo;y1&rdquo; consist of the
coordinates of the other endpoint.
</p>
<p>The columns named &ldquo;vij&rdquo;, i = 0, 1, j = 1, 2, 3, consist
of the indices of the vertices of the Delaunay triangles
whose circumcentres constitute the respective endpoints of the
corresponding edge of a Dirichlet tile.  The entries of column
&ldquo;vi3&rdquo; may (also) take the values $-1, -2, -3$, and $-4$.
This will be the case if the circumcentre in question lay outside
of the rectangular window <code>rw</code> (see <code><a href="#topic+deldir">deldir</a>()</code>)
enclosing the points being tessellated.  In these circumstances the
corresponding endpoint of the tile edge is the intersection of the
line joining the two circumcentres with the boundary of <code>rw</code>,
and the numeric value of the entry of column &ldquo;vi3&rdquo; indicates
which side.  The numbering follows the convention for numbering
the sides of a plot region in <code>R</code>: 1 for the bottom side,
2 for the left side, 3 for the top side and 4 for the right side.
</p>
<p>Note that the triple of vertices uniquely identify the endpoint
of the tile edge.
</p>
<p>The object has an attribute <code>rw</code> which is equal to
the specification of the rectangular window within which
the triangulation/tessellation in question was constructed.
(See <code><a href="#topic+deldir">deldir</a>()</code>.)
</p>


<h3>Note</h3>

<p>This function was created in response to a question asked
on <code>stackoverflow.com</code> by a user named &ldquo;Dan&rdquo;.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner <a href="mailto:rolfurner@posteo.net">rolfurner@posteo.net</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+deldir">deldir</a>()</code> <code><a href="#topic+plot.divchain">plot.divchain</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   set.seed(42)
   x   &lt;- runif(50)
   y   &lt;- runif(50)
   z   &lt;- factor(kmeans(cbind(x,y),centers=4)$cluster)
   dc1 &lt;- divchain(x,y,z,rw=c(0,1,0,1))
   dxy &lt;- deldir(x,y,z=z,rw=c(0,1,0,1))
   dc2 &lt;- divchain(dxy)
</code></pre>

<hr>
<h2 id='duplicatedxy'>
Determine duplicated points.
</h2><span id='topic+duplicatedxy'></span>

<h3>Description</h3>

<p>Find which points among a given set are duplicates of others.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>duplicatedxy(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="duplicatedxy_+3A_x">x</code></td>
<td>

<p>Either a vector of <code>x</code> coordinates of a set of (two
dimensional) points, or a list (or data frame) with columns
<code>x</code> and <code>y</code> giving the coordinates of a set of such
points.
</p>
</td></tr>
<tr><td><code id="duplicatedxy_+3A_y">y</code></td>
<td>

<p>A vector of <code>y</code> coordinates of a set of (two
dimensional) points.  Ignored if <code>x</code> is a list or data
frame.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Often it is of interest to associate each Dirichlet tile in a
tessellation of a planar point set with the point determining
the tile.  This becomes problematic if there are <em>duplicate</em>
points in the set being tessellated/triangulated.  Duplicated
points are automatically eliminated &ldquo;internally&rdquo; by
<code>deldir()</code>.  The association between tiles and the indices
of the original set of points is now preserved by the component
<code>ind.orig</code> of the object returned by <code>deldir()</code>.
However confusion could still arise.
</p>
<p>If it is of interest to associate Dirichlet tiles with the
points determining them, then it is better to proceed by
eliminating duplicate points to start with.  This function
(<code>duplicatedxy()</code>) provides a convenient way of doing so.
</p>


<h3>Value</h3>

<p>A logical vector of length equal to the (original) number
of points being considered, with entries <code>TRUE</code> if the
corresponding point is a duplicate of a point with a smaller
index, and <code>FALSE</code> otherwise.
</p>


<h3>Warning</h3>

<p>Which indices will be considered to be indices of duplicated
points (i.e. get <code>TRUE</code> values) will of course depend on
the order in which the points are presented.
</p>


<h3>Note</h3>

<p>The real work is done by the base <b>R</b> function <code><a href="base.html#topic+duplicated">duplicated</a>()</code>.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner <a href="mailto:rolfurner@posteo.net">rolfurner@posteo.net</a></p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+duplicated">duplicated</a>()</code>, <code><a href="#topic+deldir">deldir</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   set.seed(42)
   xy  &lt;- data.frame(x=runif(20),y=runif(20))
   # Lots of duplicated points.
   xy  &lt;- rbind(xy,xy[sample(1:20,20,TRUE),])
   # Scramble.
   ii  &lt;- sample(1:40,40)
   x   &lt;- xy$x[ii]
   y   &lt;- xy$y[ii]
   # Unduplicate!
   iii &lt;- !duplicatedxy(x,y)
   xu  &lt;- x[iii]
   yu  &lt;- y[iii]
   # The i-th tile is determined by (xu[i],yu[i]):
   dxy &lt;- deldir(xu,yu)
</code></pre>

<hr>
<h2 id='getNbrs'>
List Delaunay neighbours.
</h2><span id='topic+getNbrs'></span>

<h3>Description</h3>

<p>Lists the indices (or identifiers if these are provided) of the
Delaunay neighbours of each point in the set of points being
triangulated/tessellated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNbrs(object, interior = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getNbrs_+3A_object">object</code></td>
<td>

<p>An object of class <code>"deldir"</code>, as returned by the function
<code>deldir()</code>.
</p>
</td></tr>
<tr><td><code id="getNbrs_+3A_interior">interior</code></td>
<td>

<p>Either a rectangle, i.e. a numeric vector of length 4,
<code>(xmin,xmax,ymin,ymax)</code>, or a polygon (a list with components
named <code>"x"</code> and <code>"y"</code>, which are numeric vectors
of equal length, say <code>n</code>.  The pairs <code>(x[i],y[i])</code>
specify the vertices of the polygon and should be presented in
<em>anticlockwise</em> order.  The last vertex should <b>NOT</b>
repeat the first.
</p>
<p>If <code>interior</code> is given as a rectangle, its entries must
satisfy <code>xmin &lt; xmax</code> and <code>ymin &lt; ymax</code>.  Moreover,
in this case, <code>interior</code> must be a subset of the rectangular
window <code>rw</code> (see <code><a href="#topic+deldir">deldir</a>()</code>) with respect to
which the points in question are being triangulated/tessellated.
That is, its entries must satisfy <code>rw[1] &lt;= xmin</code>, <code>xmax &lt;= rw[2]</code>,
<code>rw[3] &lt;= ymin</code> and <code>ymax &lt;= rw[4]</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>interior</code> is specified then Delaunay neighbours are listed
only for those points which lie in <code>interior</code>.  Note that
these <em>neighbours</em> need not themselves lie in <code>interior</code>.
</p>
<p>Note also that it is possible for points <code>i</code> and <code>j</code> to
be neighbours even though the &ldquo;clipped&rdquo; versions of the tiles
are discontiguous.
</p>


<h3>Value</h3>

<p>A (named) list of length equal to the number points in the set
being triangulated/tessellated, or to the number of such points that
lie in <code>interior</code> if that argument was specified.  The names
of the list are the identifiers of the points as specified by
<code>id</code> if <code>id</code> was specified in the call to <code>deldir()</code>
that produced <code>object</code>.  If <code>id</code> was not specified, then
the names are the indices of the points, coerced to character mode.
</p>
<p>The entries of this list are vectors of the identifiers or
indices of the Delaunay neighbours of the point corresponding to
that entry.
</p>


<h3>Warning</h3>

<p>Be careful about addressing the entries of the list returned
by this function.  If <code>id</code> was not specified in the call
to <code>deldir()</code> that produced <code>object</code>, then the names
of this list are the point indices coerced to character mode.
If <code>interior</code> was specified then the name of <code class="reqn">i</code>-th entry
of the list will not in general be <code>i</code>.  E.g. given that
<code>xxx</code> is the list returned by this function, <code>xxx[[14]]</code>
will <b>not</b> in general give the Delaunay neighbours of point 14.
Instead, specify <code>xxx[["14"]]</code> or <code>xxx[[id[14]]]</code> where
<code>id</code> is the vector of identifiers supplied in the call to
<code>deldir()</code>.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner <a href="mailto:rolfurner@posteo.net">rolfurner@posteo.net</a></p>


<h3>References</h3>

<p>See <code><a href="#topic+deldir">deldir</a>()</code> for references.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
x &lt;- runif(60)
y &lt;- runif(60)
dxy &lt;- deldir(x,y,rw=c(0,1,0,1))
nbrs &lt;- getNbrs(dxy,interior=c(0.2,0.8,0.2,0.8))
nbrs[["14"]] # Correct.
nbrs[[14]]   # Incorrect.
names(nbrs)[14] # The result is 42.
# Thus nbrs[[14]] actually gives the Delaunay neighbours of point 42.

# Demonstrate that neighbours can have discontiguous clipped tiles.
if(require(polyclip)) {
    x &lt;- c(0.38,0.44,0.04,0.97,0.43,0.96,0.89,0.64,0.97,0.62,0.33,0.35,
           0.40,0.78,0.04,0.75,0.68,0.17,0.26,0.51)
    y &lt;- c(0.68,0.98,0.76,0.57,0.85,0.19,0.27,0.83,0.69,0.24,0.04,0.14,
           0.22,0.48,0.20,0.72,0.01,0.38,0.51,0.00)
    CP &lt;- list(x=c(0.72,0.93,0.76,0.61,-0.03,-0.04,0.41),
               y=c(0.46,0.76,0.94,1.03,1.01,0.37,0.31))
    dxy &lt;- deldir(x,y,rw=c(0,1,0,1))
    TL &lt;- tile.list(dxy)
    plot(TL,labelPts=TRUE)
    plot(TL[16],clipp=CP,fillcol="orange",labelPts=TRUE,add=TRUE)
    polygon(CP,border="red")
    nbrs &lt;- getNbrs(dxy,interior=CP) # Tiles are clipped to CP.
# Note that point 14 is a neighbour of point 16, even though their
# clipped tiles do not meet.
}
</code></pre>

<hr>
<h2 id='grapherXmpl'>
grapherXmpl
</h2><span id='topic+grapherXmpl'></span>

<h3>Description</h3>

<p>A data set taken from an example in the grapherator package.
This data set demonstrates handling a data set with duplicated
points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grapherXmpl</code></pre>


<h3>Format</h3>

<p>A data frame with 250 observations on the following 2 variables.
</p>

<dl>
<dt><code>x</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>y</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>There are 25 duplicated points, so the net number of
observations is 225.  These data constitute a structure (named
<code>coordinates</code>) generated internally in the function
<code>addEdgesDelaunay</code>.  The call is to be found in the
examples in the help file for the <code>plot.grapherator()</code>
in the <code>grapherator</code> package.  The relevant example
initially threw an error, revealing a bug in <code>deldir()</code>
that was triggered when there were duplicated points in the data.
</p>


<h3>Source</h3>

<p>The <code>grapherator</code> package,
<a href="https://CRAN.R-project.org/package=grapherator">https://CRAN.R-project.org/package=grapherator</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dgX &lt;- deldir(grapherXmpl) # Now works!!!`
</code></pre>

<hr>
<h2 id='lawSummary'>
Produce a Lewis-Aboav-Weaire summary of a tessellation.
</h2><span id='topic+lawSummary'></span>

<h3>Description</h3>

<p>Produce a summary of a Dirichlet (Voronoi) tessellation in terms
of parameters relevant to Lewis's law and Aboav-Weaire's law.
Note that &ldquo;law&rdquo; in the function name corresponds to
&ldquo;Lewis-Aboav-Weaire&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lawSummary(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lawSummary_+3A_object">object</code></td>
<td>

<p>An object of class <code>"deldir"</code> as returned by the function
<code>deldir()</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tiles are stripped away from the tessellation in &ldquo;layers&rdquo;.
Layer 1 consists of &ldquo;boundary&rdquo; tiles, i.e. tiles having
at least one vertex on the enclosing rectangle (determined by the
<code>rw</code> argument of <code><a href="#topic+deldir">deldir</a>()</code>).  Layer 2 consists
of tiles which are neighbours of tiles in layer 1 (i.e. tiles
determined by points that are Delaunay neighbours of points
determining the tiles in layer 1).  Layer 3 consists of tiles
which are neighbours of tiles in layer 2.
</p>
<p>The parameters of interest in respect of the Lewis-Aboav-Weaire summary are
then calculated in terms of the tiles that remain after the three layers
have been stripped away, which will be referred to as &ldquo;interior&rdquo;
tiles.  These parameters are:
</p>

<ul>
<li><p> the areas of each of the interior tiles
</p>
</li>
<li><p> the number of edges of each of the interior tiles
</p>
</li>
<li><p> the number of edges of all neighbouring tiles of each of
the interior tiles.
</p>
</li></ul>

<p>Note that the neighbouring tiles of the interior tiles may include
tiles which are <em>not themselves</em> interior tiles (i.e. tiles
which are in layer 3).
</p>
<p>This function was created at the request of Kai Xu
(Fisheries College, Jimei University, Xiamen, Fujian, China 361021).
</p>


<h3>Value</h3>

<p>If no tiles remain after the three layers have been stripped
away, then the returned value is <code>NULL</code>.  Otherwise the
returned value is a list with components calculated in terms of
the remaining (&ldquo;interior&rdquo;) tiles.  These components are:
</p>

<ul>
<li> <p><code>tile.vertices</code> A list whose entries are data frames
giving the coordinates of the vertices of the interior tiles.
</p>
</li>
<li> <p><code>tile.areas</code> A vector of the areas of the interior tiles
in the tessellation in question.
</p>
</li>
<li><p>tile.tags A vector or factor whose values are the &ldquo;tags&rdquo;
of the interior tiles.  The &ldquo;original&rdquo; of this object (the
&ldquo;tags&rdquo; associated with all of the tiles) is provided
as the <code>z</code> argument to <code>deldir()</code>.  The <code>tile.tags</code>
component of the value returned by <code>lawSummary()</code> is present
only if <code>deldir()</code> was called with a (non-<code>NULL</code>) value
of the <code>z</code> argument.
</p>
</li>
<li> <p><code>num.edges</code> A vector of the number of edges of each
such tile.
</p>
</li>
<li> <p><code>num.nbr.edges</code> A list with a component for each
point, in the set being tessellated, whose corresponding tile
is an interior tile.  Each component of this
list is the vector of the number of edges of the interior tiles
determined by points which are Delaunay neighbours of
the point corresponding to the list component in question.
</p>
</li>
<li> <p><code>totnum.nbr.edges</code> A vector whose entries consist
of the sums of the vectors in the foregoing list.
</p>
</li></ul>

<p>The returned list also has attributes as follows:
</p>

<ul>
<li> <p><code>i1</code> An integer vector whose entries are in the indices
of the tiles in layer 1.
</p>
</li>
<li> <p><code>i2</code> An integer vector whose entries are in the indices
of the tiles in layer 2.
</p>
</li>
<li> <p><code>i3</code> An integer vector whose entries are in the indices
of the tiles in layer 3.
</p>
</li>
<li> <p><code>i.kept</code> An integer vector whose entries are in the indices
of the tiles that are kept, i.e. those that remain after the three layers
have been stripped away.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Rolf Turner <a href="mailto:rolfurner@posteo.net">rolfurner@posteo.net</a></p>


<h3>See Also</h3>

 <p><code><a href="#topic+tile.list">tile.list</a>()</code> <code><a href="#topic+tile.centroids">tile.centroids</a>()</code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># A random pattern:
set.seed(42)
xy1   &lt;- data.frame(x=runif(400,0,20),y=runif(400,0,20))
dxy1  &lt;- deldir(xy1)
ldxy1 &lt;- lawSummary(dxy1)
tl1   &lt;- tile.list(dxy1)
plot(0,0,type="n",xlim=c(-2,35),ylim=c(0,20),asp=1,xlab="x",ylab="y",bty="l")
plot(tl1,showpoints=FALSE,add=TRUE)
points(xy1[attr(ldxy1,"i1"),],pch=20,col="yellow")
points(xy1[attr(ldxy1,"i2"),],pch=20,col="blue")
points(xy1[attr(ldxy1,"i3"),],pch=20,col="green")
points(xy1[attr(ldxy1,"i.kept"),],pch=20,col="red")
legend("right",pch=20,col=c("yellow","blue","green","red"),
       legend=c("layer 1","layer 2","layer 3","interior"))

# A highly structured pattern (example due to Kai Xu):
set.seed(115)
x  &lt;- c(rep(1:20,10),rep((1:20)+0.5,10))
y  &lt;- c(rep(1:10,each=20),rep((1:10)+0.5,each=20))*sqrt(3)
a  &lt;- runif(400,0,2*pi)
b  &lt;- runif(400,-1,1)
x  &lt;- x+0.1*cos(a)*b
y  &lt;- y+0.1*sin(a)*b
xy2 &lt;- data.frame(x,y)
dxy2  &lt;- deldir(xy2)
ldxy2 &lt;- lawSummary(dxy2)
tl2   &lt;- tile.list(dxy2)
plot(0,0,type="n",xlim=c(-2,35),ylim=c(0,20),asp=1,xlab="x",ylab="y",bty="l")
plot(tl2,showpoints=FALSE,add=TRUE)
points(xy2[attr(ldxy2,"i1"),],pch=20,col="yellow")
points(xy2[attr(ldxy2,"i2"),],pch=20,col="blue")
points(xy2[attr(ldxy2,"i3"),],pch=20,col="green")
points(xy2[attr(ldxy2,"i.kept"),],pch=20,col="red")
legend("right",pch=20,col=c("yellow","blue","green","red"),
       legend=c("layer 1","layer 2","layer 3","interior"))

</code></pre>

<hr>
<h2 id='niProperties'>
Northern Ireland properties.
</h2><span id='topic+niProperties'></span>

<h3>Description</h3>

<p>The locations (in longitude and latitude) of a number of properties
(land holdings) in Northern Ireland.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("niProperties")</code></pre>


<h3>Format</h3>

<p>A data frame with 240 observations on the following 2 variables.
</p>

<dl>
<dt><code>x</code></dt><dd><p>A numeric vector of longitudes.</p>
</dd>
<dt><code>y</code></dt><dd><p>A numeric vector of latitudes.</p>
</dd>
</dl>



<h3>Source</h3>

<p>These data were kindly provided by Adam Dadvar of the
<em>Cartesian Limited</em> consulting service.<br />
URL: <code>http://www.cartesian.com</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># data(niProperties)
# It is unnecessary to use \code{data} since \code{niProperties} is
# a "first class object".  It is "lazily loaded".
plot(niProperties)
</code></pre>

<hr>
<h2 id='plot.deldir'>
Plot objects produced by deldir
</h2><span id='topic+plot.deldir'></span>

<h3>Description</h3>

<p>This is a method for plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'deldir'
plot(x,add=FALSE,wlines=c("both","triang","tess"),
                      showpoints=TRUE,labelPts=FALSE,cex=1,lex=1,
                      cmpnt_col=NULL,cmpnt_lty=NULL,pch=1,xlim=NULL,
                      ylim=NULL,axes=FALSE,xlab=if(axes) "x" else "",
                      ylab=if(axes) "y" else"",showrect=FALSE,asp=1,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.deldir_+3A_x">x</code></td>
<td>

<p>An object of class &quot;deldir&quot; as returned by the function deldir.
</p>
</td></tr>
<tr><td><code id="plot.deldir_+3A_add">add</code></td>
<td>

<p>logical argument; should the plot be added to an existing plot?
</p>
</td></tr>
<tr><td><code id="plot.deldir_+3A_wlines">wlines</code></td>
<td>

<p>&quot;which lines?&quot;.  I.e.  should the Delaunay triangulation be plotted
(wlines=&quot;triang&quot;), should the Dirichlet tessellation be plotted
(wlines=&quot;tess&quot;), or should both be plotted (wlines=&quot;both&quot;, the
default) ?
</p>
</td></tr>
<tr><td><code id="plot.deldir_+3A_showpoints">showpoints</code></td>
<td>

<p>Logical scalar; should the points being triangulated/tessellated
be plotted?
</p>
</td></tr>
<tr><td><code id="plot.deldir_+3A_labelpts">labelPts</code></td>
<td>

<p>Logical argument, defaulting to <code>FALSE</code>; if <code>TRUE</code> then the
points plotted will be labelled with their identifiers (as specified
by the optional argument <code>id</code> of <code>deldir()</code>.  If <code>id</code>
was not specified to <code>deldir()</code>, then the identifiers default
to the indices of the points, which correspond to the row numbers
of the matrix &quot;summary&quot; in the output of <code>deldir()</code>).
</p>
</td></tr>
<tr><td><code id="plot.deldir_+3A_cex">cex</code></td>
<td>

<p>The value of the character expansion argument cex to be used
with the plotting symbols for plotting the points.
</p>
</td></tr>
<tr><td><code id="plot.deldir_+3A_lex">lex</code></td>
<td>

<p>The value of the character expansion argument cex to be used by the
text function when labelling the points with their identifiers.  Used only
if <code>labelPts</code> is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="plot.deldir_+3A_cmpnt_col">cmpnt_col</code></td>
<td>

<p>A vector or list specifying the colours to be used for plotting
the (up to five) different components of the graphic, explicitly the
triangulation, the tessellation, the data points,
the point labels and the enclosing rectangle (<code>x$rw</code>) in that
order.  The components of this vector or list may be named, with the
names chosen from <code>"tri","tess","points","labels","rect".</code>
The default is <code>c(tri=1,tess=1,points=1,labels=1,rect=1)</code>.
If the vector or list is not named, the component names are assumed
to be from the default list of names in the given order.
</p>
<p>Colours may be specified as positive integers, corresponding to
the entries of the current <code><a href="grDevices.html#topic+palette">palette</a>()</code>, or as names of
colours (from the list given by <code><a href="grDevices.html#topic+colors">colors</a>()</code>), or  in terms
of their RGB components with strings of the form <code>"#RRGGBB"</code>.
(See <b>Color Specification</b> in <code><a href="graphics.html#topic+par">par</a>()</code>.)
</p>
<p>If fewer than five colours are given, the missing components are
filled in with <code>1</code> or <code>palette()[1]</code> as is appropriate.
If <code>cmpnt_col</code> does not have names then the components are
simply recycled.  If more than five colours are given, the redundant
ones are ignored (i.e. only the first five are used).
</p>
</td></tr>
<tr><td><code id="plot.deldir_+3A_cmpnt_lty">cmpnt_lty</code></td>
<td>

<p>A vector or list (of length two) of line types for plotting
the two components of the graphic that consist of lines,
i.e. the triangulation and the tessellation.  The types may
consist of integers between 1 and 6, or of approriate text
strings (&quot;solid&quot;, &quot;dashed&quot;, &quot;dotted&quot;, &quot;dotdash&quot;, &quot;longdash&quot; or
&quot;twodash&quot;; see the discussion of <code>lty</code> in <code><a href="graphics.html#topic+par">par</a>()</code>).
The components of <code>cmpnt_lty</code> (vector or list) may have names
(<code>"tri","tess"</code>).  The default is c(tri=1,tess=2).  If a
single value is given, the missing one is filled in as <code>1</code> or
<code>"solid"</code> as is appropriate.  If more than two values are given,
the redundant ones are ignored, i.e. only the first two are used.
</p>
</td></tr>
<tr><td><code id="plot.deldir_+3A_pch">pch</code></td>
<td>

<p>The plotting symbol for plotting the points.  May be either
integer or character.
</p>
</td></tr>
<tr><td><code id="plot.deldir_+3A_xlim">xlim</code></td>
<td>

<p>The limits on the x-axis.  Defaults to <code>rw[1:2]</code> where <code>rw</code> is the
rectangular window specification returned by deldir().
</p>
</td></tr>
<tr><td><code id="plot.deldir_+3A_ylim">ylim</code></td>
<td>

<p>The limits on the y-axis.  Defaults to <code>rw[3:4]</code> where <code>rw</code> is the
rectangular window specification returned by deldir().
</p>
</td></tr>
<tr><td><code id="plot.deldir_+3A_axes">axes</code></td>
<td>

<p>Logical scalar.  Should axes be drawn on the plot?
</p>
</td></tr>
<tr><td><code id="plot.deldir_+3A_xlab">xlab</code></td>
<td>

<p>Label for the x-axis.  Defaults to <code>x</code> if <code>axes</code> is
<code>TRUE</code> and to the empty string if <code>axes</code> is <code>FALSE</code>.
Ignored if <code>add=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="plot.deldir_+3A_ylab">ylab</code></td>
<td>

<p>Label for the y-axis.  Defaults to <code>y</code> if <code>axes</code> is
<code>TRUE</code> and to the empty string if <code>axes</code> is <code>FALSE</code>.
Ignored if <code>add=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="plot.deldir_+3A_showrect">showrect</code></td>
<td>

<p>Logical scalar; show the enclosing rectangle <code>rw</code> (see
<code><a href="#topic+deldir">deldir</a>()</code>) be plotted? </p>
</td></tr>
<tr><td><code id="plot.deldir_+3A_asp">asp</code></td>
<td>

<p>The aspect ratio of the plot; integer scalar or <code>NA</code>.  Set this
argument equal to <code>NA</code> to allow the data to determine the aspect
ratio and hence to make the plot occupy the complete plotting region
in both <code>x</code> and <code>y</code> directions.  This is inadvisable;
see the <b>Warning</b>.  The <code>asp</code> argument is ignored if
<code>add</code> is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="plot.deldir_+3A_...">...</code></td>
<td>

<p>Further plotting parameters (e.g. <code>lw</code>, <code>col</code>) to be passed
to <code>segments()</code>.  (Conceivably one might also use <code>...</code>
to supply additional arguments to be passed to <code>points()</code>
or <code>text()</code> but this is unlikely.)  Note that if <code>col</code>
is specified as one of the <code>...</code> arguments then this is used
as the <code>col</code> argument of <code>segments</code> (and the values of
<code>cmpnt_col[1:2]</code> are ignored.
</p>
</td></tr>
</table>


<h3>Side Effects</h3>

<p>A plot of the edges of the Delaunay triangles and/or of the Dirichlet
tiles is produced or added to an existing plot.  By default the
triangles are plotted with solid lines (lty=1) and the tiles with
dotted lines (lty=2).  In addition the points
being triangulated may be plotted.
</p>


<h3>Warnings</h3>


<ul>
<li><p> As of release 1.0-8 the argument <code>number</code> of
<code><a href="#topic+plot.deldir">plot.deldir</a>()</code> and <code><a href="#topic+plot.tile.list">plot.tile.list</a>()</code>
was changed to <code>labelPts</code>.  As a consequence the argument
<code>nex</code> of this function has had its name changed to
<code>lex</code>.
</p>
</li>
<li><p> In previous versions of the <code>deldir</code> package, the aspect
ratio was not set.  Instead, the shape of the plotting region was
set to be square (<code>pty="s"</code>).  This practice was suboptimal.
To reproduce previous behaviour set <code>asp=NA</code> (and possibly
<code>pty="s"</code>) in the call to <code>plot.deldir()</code>.  Users, unless
they <em>really</em> understand what they are doing and why they are
doing it, are now <em>strongly advised</em> not to set the value of
<code>asp</code> but rather to leave <code>asp</code> equal to its default value
of <code>1</code>.  Any other value may distort the tessellation and destroy
the perpendicular appearance of lines which are indeed perpendicular.
(And conversely may cause lines which are not perpendicular to
appear as if they are.)
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Rolf Turner <a href="mailto:rolfurner@posteo.net">rolfurner@posteo.net</a></p>


<h3>See Also</h3>

 <p><code><a href="#topic+deldir">deldir</a>()</code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(2.3,3.0,7.0,1.0,3.0,8.0) + 0.5
y &lt;- c(2.3,3.0,2.0,5.0,8.0,9.0) + 0.5
x &lt;- c(x,1,10,10,1)
y &lt;- c(y,1,1,10,10)
dxy &lt;- deldir(x,y,rw=c(0,11,0,11))
plot(dxy)

# Plots the tessellation, but does not save the results:
deldir(x,y,rw=c(0,11,0,11),plot=TRUE,
       wl="tess",cmpnt_col=c(1,1,2,3,4),labelPts=TRUE)

# Plots the triangulation, but not the tessellation or the points,
# and saves the returned structure:

dxy &lt;- deldir(x,y,rw=c(0,11,0,11),plot=TRUE,wl="triang",wp="none")

# Plot everything:
plot(dxy,cmpnt_col=c("orange","green","red","blue","black"),cmpnt_lty=1,
     labelPts=TRUE,lex=1.5,pch=c(19,9),showrect=TRUE,axes=TRUE)

# Complicated example from He Huang:
# "Linguistic distances".
vldm &lt;- c(308.298557,592.555483,284.256926,141.421356,449.719913,
          733.976839,591.141269,282.842712,1.414214,732.562625)
ldm &lt;- matrix(nrow=5,ncol=5)
ldm[row(ldm) &gt; col(ldm)]  &lt;- vldm
ldm[row(ldm) &lt;= col(ldm)] &lt;- 0
ldm &lt;- (ldm + t(ldm))/2
rownames(ldm) &lt;- LETTERS[1:5]
colnames(ldm) &lt;- LETTERS[1:5]

# Data to be triangulated.
id &lt;- c("A","B","C","D","E")
x  &lt;- c(0.5,1,1,1.5,2)
y  &lt;- c(5.5,3,7,6.5,5)
dat_Huang &lt;- data.frame(id = id, x = x, y = y)

# Form the triangulation/tessellation.
dH &lt;- deldir(dat_Huang)

# Plot the triangulation with line widths proportional
# to "linguistic distances".
all_col &lt;- rainbow(100)
i       &lt;- pmax(1,round(100*vldm/max(vldm)))
use_col &lt;- all_col[i]
ind     &lt;- as.matrix(dH$delsgs[,c("ind1","ind2")])
lwv &lt;- ldm[ind]
lwv &lt;- 10*lwv/max(lwv)
plot(dH,wlines="triang",col=use_col,showpoints=FALSE,
     lw=lwv,asp=NA)
with(dH,text(x,y,id,cex=1.5))
</code></pre>

<hr>
<h2 id='plot.divchain'>
Plot a dividing chain.
</h2><span id='topic+plot.divchain'></span>

<h3>Description</h3>

<p>Plot the dividing chain of a Dirichlet tessellation.
The tessellation must have been created from a set of points
having associated categorical &ldquo;tags&rdquo;.  The dividing
chain consists of those edges of Dirichlet tiles which separate
points having different values of the given tags.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   ## S3 method for class 'divchain'
plot(x, add = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.divchain_+3A_x">x</code></td>
<td>

<p>An object of class &ldquo;divchain&rdquo;.  See <code><a href="#topic+divchain.deldir">divchain.deldir</a>()</code>
for details.
</p>
</td></tr>
<tr><td><code id="plot.divchain_+3A_add">add</code></td>
<td>

<p>Logical scalar.  It <code>add=TRUE</code> the plot of the dividing chain
is added to an existing plot.
</p>
</td></tr>
<tr><td><code id="plot.divchain_+3A_...">...</code></td>
<td>

<p>Graphical parameters such as <code>main</code>, <code>xlab</code>, <code>col.main</code>,
<code>col.lab</code>.  In particular if <code>bty</code> is supplied
(as a value other than <code>n</code>) a &ldquo;box&rdquo; will be drawn
around the plot that is formed when <code>add=FALSE</code>.
Also a non-standard graphical parameter <code>boxcol</code> may be supplied
which will be taken to be the colour with which the box is drawn.
If a <code>col</code> argument is supplied, this determines the colour
for plotting the segments constituting the dividing chain.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>Note</h3>

<p>This function was created in response to a question asked
on <code>stackoverflow.com</code> by a user named &ldquo;Dan&rdquo;.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner <a href="mailto:rolfurner@posteo.net">rolfurner@posteo.net</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+divchain">divchain</a>()</code> <code><a href="#topic+divchain.default">divchain.default</a>()</code>
<code><a href="#topic+divchain.deldir">divchain.deldir</a>()</code> <code><a href="#topic+deldir">deldir</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   set.seed(42)
   x   &lt;- runif(50)
   y   &lt;- runif(50)
   z   &lt;- factor(kmeans(cbind(x,y),centers=4)$cluster)
   dc  &lt;- divchain(x,y,z,rw=c(0,1,0,1))
   plot(dc,lwd=2,col="blue",bty="o")
</code></pre>

<hr>
<h2 id='plot.tile.list'> Plot Dirichlet (Voronoi) tiles </h2><span id='topic+plot.tile.list'></span>

<h3>Description</h3>

<p> A method for <code>plot</code>.  Plots (sequentially)
the tiles associated with each point in the set being tessellated. </p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tile.list'
plot(x, verbose = FALSE, close = FALSE, pch = 1,
                         fillcol = getCol(x,warn=warn), col.pts=NULL,
                         col.lbls=NULL,border=NULL, showpoints = !labelPts,
                         add = FALSE, asp = 1, clipp=NULL, xlab = "x",
                         ylab = "y", main = "", axes=TRUE,warn=TRUE,
                         labelPts=FALSE,adj=NULL,...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.tile.list_+3A_x">x</code></td>
<td>

<p>A list of the tiles in a tessellation, as produced
the function <code><a href="#topic+tile.list">tile.list</a>()</code>.
</p>
</td></tr>
<tr><td><code id="plot.tile.list_+3A_verbose">verbose</code></td>
<td>

<p>Logical scalar; if <code>TRUE</code> the tiles are
plotted one at a time (with a &ldquo;Go?&rdquo; prompt after each)
so that the process can be watched.
</p>
</td></tr>
<tr><td><code id="plot.tile.list_+3A_close">close</code></td>
<td>

<p>Logical scalar; if <code>TRUE</code> the outer edges of of the tiles
(i.e. the edges which are constitute parts of the edges of the
enclosing rectangle) are drawn.  Otherwise tiles on the periphery
of the tessellation are left &ldquo;open&rdquo;.
</p>
</td></tr>
<tr><td><code id="plot.tile.list_+3A_pch">pch</code></td>
<td>

<p>The plotting character (or vector of plotting
characters) with which to plot the points of the pattern which
was tessellated.  Ignored if <code>showpoints</code> is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="plot.tile.list_+3A_fillcol">fillcol</code></td>
<td>

<p>Optional vector (possibly of length 1, i.e. a scalar) whose
entries can be interpreted as colours by <code><a href="grDevices.html#topic+col2rgb">col2rgb</a>()</code>.
The <code class="reqn">i</code>-th entry indicates with which colour to fill the
<code class="reqn">i</code>-th tile.  Note that an <code>NA</code> entry cause the tile
to be left unfilled.  This argument will be replicated to have
length equal to the number of tiles.  The default value is
created (using the tile &ldquo;tags&rdquo;, i.e. the <code>z</code>
components of the tiles, if these exist) by
the undocumented function <code>getCol()</code>.  Note that if
these <code>z</code> components are not present, then <code>getCol()</code>
returns <code>NA</code>.
</p>
</td></tr>
<tr><td><code id="plot.tile.list_+3A_col.pts">col.pts</code></td>
<td>

<p>Optional vector like unto <code>fillcol</code> whose entries can be
interpreted as colours by <code><a href="grDevices.html#topic+col2rgb">col2rgb</a>()</code>.  The <code class="reqn">i</code>-th
entry indicates with which colour to plot the <code class="reqn">i</code>-th point.
This argument will be replicated to have length equal to the
number of tiles.  Ignored if <code>showpoints</code> is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="plot.tile.list_+3A_col.lbls">col.lbls</code></td>
<td>

<p>Optional vector like unto <code>col.pts</code>. Determines the colours
in which the point labels (see <code>labelPts</code> below) are plotted.
This argument will be replicated to have length equal to the
number of tiles.  Ignored if <code>labelPts</code> is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="plot.tile.list_+3A_border">border</code></td>
<td>

<p>A scalar that can be interpreted as a colour by <code>col2rgb()</code>,
indicating the colour with which to plot the tile boundaries.
Defaults to black unless all of the fill colours specified by
<code>fillcol</code> are black, in which case it defaults to white.
If <code>length(border) &gt; 1</code> then only its first entry is used.
</p>
</td></tr>
<tr><td><code id="plot.tile.list_+3A_showpoints">showpoints</code></td>
<td>
<p>Logical scalar; if <code>TRUE</code> the points of
the pattern which was triangulated/tessellated are plotted.
If <code>clipp</code> is specified, then only those points
associated with non-empty clipped tiles are shown.  Note that
some such points will be external to the polygon <code>clipp</code>
and that these &ldquo;external&rdquo; points <em>are</em> shown.
</p>
</td></tr>
<tr><td><code id="plot.tile.list_+3A_add">add</code></td>
<td>

<p>Logical scalar; should the plot of the tiles be added
to an existing plot?
</p>
</td></tr>
<tr><td><code id="plot.tile.list_+3A_asp">asp</code></td>
<td>
<p>The aspect ratio of the plot; integer scalar or
<code>NA</code>.  Set this argument equal to <code>NA</code> to allow the data
to determine the aspect ratio and hence to make the plot occupy the
complete plotting region in both <code>x</code> and <code>y</code> directions.
This is inadvisable; see the <b>Warnings</b>.
</p>
</td></tr>
<tr><td><code id="plot.tile.list_+3A_clipp">clipp</code></td>
<td>
<p>An object specifying a polygon to which the tessellation
being plotted should be clipped.  It should consist either of:
</p>

<ul>
<li><p> a list containing two components x and y giving the
coordinates of the vertices of a single polygon. The last vertex
should not repeat the first vertex. Or:
</p>
</li>
<li><p> a list of list(x,y) structures giving the coordinates of
the vertices of several polygons.
</p>
</li></ul>

<p>If this argument is provided then the plot of the tessellation
is &ldquo;clipped&rdquo; to the polygon specified by <code>clipp</code>.
</p>
</td></tr>
<tr><td><code id="plot.tile.list_+3A_xlab">xlab</code></td>
<td>

<p>Label for the <code>x</code>-axis (used only if <code>add</code> is <code>FALSE</code>).
</p>
</td></tr>
<tr><td><code id="plot.tile.list_+3A_ylab">ylab</code></td>
<td>

<p>Label for the <code>y</code>-axis (used only if <code>add</code> is <code>FALSE</code>).
</p>
</td></tr>
<tr><td><code id="plot.tile.list_+3A_main">main</code></td>
<td>

<p>A title for the plot (used only if <code>add</code> is <code>FALSE</code>).
</p>
</td></tr>
<tr><td><code id="plot.tile.list_+3A_axes">axes</code></td>
<td>

<p>Logical scalar.  Should axes (with a marked numeric scale)
be plotted?  This argument is used only if <code>add</code> is
<code>FALSE</code>.  It allows the plotting of such axes to be
suppressed.  The argument was added at the request of Damon
Tutunjian.  To suppress the plotting of axis <em>labels</em>
set <code>xlab=""</code> and/or <code>ylab=""</code>.
</p>
</td></tr>
<tr><td><code id="plot.tile.list_+3A_warn">warn</code></td>
<td>
<p>Logical scalar passed to the internal function <code>getCol()</code>.
Should a warning be issued if the <code>z</code> components of the entries
of <code>x</code> cannot all be interpreted as colours?  (See <b>Notes</b>.)
</p>
</td></tr>
<tr><td><code id="plot.tile.list_+3A_labelpts">labelPts</code></td>
<td>
<p>Logical scalar; if <code>TRUE</code> the labels of the
points determining the tiles are plotted in the tiles.  Note
that if <code>labelPts</code> is <code>TRUE</code> then <code>showpoints</code>
defaults to <code>FALSE</code>
</p>
</td></tr>
<tr><td><code id="plot.tile.list_+3A_adj">adj</code></td>
<td>
<p>The &ldquo;adjustment&rdquo; argument to <code>text()</code>.
If <code>labelPts</code> and <code>showpoints</code> are both <code>TRUE</code> it
defaults to <code>-1</code> (so that the labels and point symbols
are not superimposed).  If <code>labelPts</code> is <code>TRUE</code> and
<code>showpoints</code> is <code>FALSE</code> it defaults to <code>0</code>.
If <code>labelPts</code> is <code>FALSE</code> it is ignored.
</p>
</td></tr>
<tr><td><code id="plot.tile.list_+3A_...">...</code></td>
<td>
<p>Optional arguments; may be passed to <code>points()</code>
and <code>text()</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The list of tiles being plotted.  This will be the input
list of  tiles specified by argument <code>x</code>, or this list
clipped to the polygon <code>clipp</code> if the latter was specified.
</p>


<h3>Warnings</h3>


<ul>
<li><p> As of release 1.0-8 the argument <code>number</code> of
<code><a href="#topic+plot.deldir">plot.deldir</a>()</code> and <code><a href="#topic+plot.tile.list">plot.tile.list</a>()</code>
was changed to <code>labelPts</code>.  As a consequence the argument
<code>col.num</code> of this function has had its name changed to
<code>col.lbls</code>.
</p>
</li>
<li><p> The behaviour of this function with respect to
&ldquo;clipping&rdquo; has changed substantially since the previous
release of <code>deldir</code>, i.e. 1.1-0.  The argument <code>clipwin</code>
has been re-named <code>clipp</code> (&ldquo;p&rdquo; for &ldquo;polygon&rdquo;).
Clipping is now effected via the new package <code>polyclip</code>.
The <code>spatstat</code> package is no longer used.  The argument
<code>use.gpclib</code> has been eliminated, since <code>gpclib</code> (which
used to be called upon by <code>spatstat</code> has been superseded by
<code>polyclip</code> which has an unrestrictive license.
</p>
</li>
<li><p> As of release 0.1-1 of the <code>deldir</code> package, the
argument <code>fillcol</code> to this function <em>replaces</em> the old
argument <code>polycol</code>, but behaves somewhat differently.
</p>
</li>
<li><p> The argument <code>showrect</code> which was present in versions
of this function prior to release 0.1-1 has been eliminated.
It was redundant.
</p>
</li>
<li><p> As of release 0.1-1 the <code>col.pts</code> argument <em>might</em>
behave somewhat differently from how it behaved in the past.
</p>
</li>
<li><p> The arguments <code>border</code>, <code>clipp</code>, and <code>warn</code>
are new as of release 0.1-1.
</p>
</li>
<li><p> Users, unless they <em>really</em> understand what they are
doing and why they are doing it, are <em>strongly advised</em>
not to set the value of <code>asp</code> but rather to leave <code>asp</code>
equal to its default value of <code>1</code>.  Any other value distorts
the tesselation and destroys the perpendicular appearance of
lines which are indeed perpendicular.  (And conversely can cause
lines which are not perpendicular to appear as if they are.)
The argument <code>asp</code> was added at the request of Zubin Dowlaty
(who presumably knows what he's doing!).
</p>
</li></ul>



<h3>Notes</h3>


<ul>
<li><p> If <code>clipp</code> is not <code>NULL</code> and <code>showpoints</code>
is <code>TRUE</code> then it is possible that some of the points
&ldquo;shown&rdquo; will not fall inside any of the plotted tiles.
(This will happen if the parts of the tiles in which they fall
have been &ldquo;clipped&rdquo; out.)  If a tile is clipped out
<em>completely</em> then the point which determines that tile is
<em>not</em> plotted irrespective of the value of <code>showpoints</code>.
</p>
</li>
<li><p> If the <code>z</code> components of the entries of <code>x</code>
exist but cannot all be interpreted as colours then the internal
function <code>getCol()</code> returns <code>NA</code>.  If <code>warn</code> is
<code>TRUE</code> then a warning is issued.  The function <code>getCol()</code>
will also return <code>NA</code> (no warning is issued in this case)
if there <em>aren't</em> any <code>z</code> components. This circumstance
will arise if no <code>z</code> argument was supplied in the call to
<code>deldir()</code>.  An <code>NA</code> value of <code>fillcol</code> results
(as is indicated by the argument list entry for <code>fillcol</code>)
in (all of) the tiles being left unfilled.
</p>
</li>
<li><p> The change from argument <code>polycol</code> to argument
<code>fillcol</code>, and the resulting change in the way in which
plotted tiles are filled with colours, was made as a result of
a request from Chris Triggs.  Likewise the argument <code>clipp</code>
was added due to a request from Chris Triggs.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Rolf Turner <a href="mailto:rolfurner@posteo.net">rolfurner@posteo.net</a></p>


<h3>See Also</h3>

 <p><code><a href="#topic+deldir">deldir</a>()</code>, <code><a href="#topic+tile.list">tile.list</a>()</code>,
<code><a href="#topic+triang.list">triang.list</a>()</code>, <code><a href="#topic+plot.triang.list">plot.triang.list</a>()</code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  set.seed(42)
  x &lt;- runif(20)
  y &lt;- runif(20)
  z &lt;- deldir(x,y,rw=c(0,1,0,1))
  w &lt;- tile.list(z)
  plot(w)
  ccc &lt;- heat.colors(20) # Or topo.colors(20), or terrain.colors(20)
                         # or cm.colors(20), or rainbow(20).
  plot(w,fillcol=ccc,close=TRUE)
  if(require(polyclip)) {
     CP  &lt;- list(x=c(0.49,0.35,0.15,0.20,0.35,0.42,
                     0.43,0.62,0.46,0.63,0.82,0.79),
                 y=c(0.78,0.86,0.79,0.54,0.58,0.70,
                     0.51,0.46,0.31,0.20,0.37,0.54))
     cul &lt;- rainbow(10)[c(1,7,3:6,2,8:10)] # Rearranging colours to improve
                                           # the contrast between contiguous tiles.
     plot(w,clipp=CP,showpoints=FALSE,fillcol=cul)
  }
  plot(w,labelPts=TRUE,col.lbls="red")
  plot(w,labelPts=TRUE,col.lbls="red",cex=0.5)
  plot(w,showpoints=TRUE,labelPts=TRUE,col.pts="green",col.lbls="red")
  plot(w,axes=FALSE,xlab="",ylab="",close=TRUE)
</code></pre>

<hr>
<h2 id='plot.triang.list'> Plot Delaunay triangles </h2><span id='topic+plot.triang.list'></span>

<h3>Description</h3>

<p> A method for <code>plot</code>.  Plots the triangles of
a Delaunay triangulation of a set of points in the plane.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'triang.list'
plot(x, showrect = FALSE, add = FALSE,
              xlab = "x", ylab = "y", main = "", asp = 1,
              rectcol="black", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.triang.list_+3A_x">x</code></td>
<td>

<p>An object of class &ldquo;triang.list&rdquo; as produced by
<code><a href="#topic+triang.list">triang.list</a>()</code>.
</p>
</td></tr>
<tr><td><code id="plot.triang.list_+3A_showrect">showrect</code></td>
<td>

<p>Logical scalar; show the enclosing rectangle <code>rw</code> (see
<code><a href="#topic+deldir">deldir</a>()</code>) be plotted?
</p>
</td></tr>
<tr><td><code id="plot.triang.list_+3A_add">add</code></td>
<td>

<p>Logical scalar; should the plot of the triangles be added
to an existing plot?
</p>
</td></tr>
<tr><td><code id="plot.triang.list_+3A_xlab">xlab</code></td>
<td>

<p>Label for the <code>x</code>-axis.
</p>
</td></tr>
<tr><td><code id="plot.triang.list_+3A_ylab">ylab</code></td>
<td>

<p>Label for the <code>y</code>-axis.
</p>
</td></tr>
<tr><td><code id="plot.triang.list_+3A_main">main</code></td>
<td>

<p>A title for the plot (used only if <code>add</code> is <code>FALSE</code>).
</p>
</td></tr>
<tr><td><code id="plot.triang.list_+3A_asp">asp</code></td>
<td>
<p>The aspect ratio of the plot; integer scalar or
<code>NA</code>.  Set this argument equal to <code>NA</code> to allow the data
to determine the aspect ratio and hence to make the plot occupy the
complete plotting region in both <code>x</code> and <code>y</code> directions.
This is inadvisable; see the <b>Warnings</b>.
</p>
</td></tr>
<tr><td><code id="plot.triang.list_+3A_rectcol">rectcol</code></td>
<td>

<p>Text string or integer specifying the colour in which the enclosing
rectangle should be plotted.  Ignored unless <code>showrect</code> is
<code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="plot.triang.list_+3A_...">...</code></td>
<td>

<p>Arguments passed to <code><a href="graphics.html#topic+polygon">polygon</a>()</code> which does the actual
plotting of the triangles.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.  This function has the side effect of producing (or
adding to) a plot.
</p>


<h3>Warnings</h3>

<p>Users are <em>strongly advised</em> not to set the value of
<code>asp</code> (unless they really know what they are doing) but rather
to leave <code>asp</code> equal to its default value of <code>1</code>.
Any other value distorts the tesselation and destroys the
perpendicular appearance of lines which are indeed perpendicular.
(And conversely can cause lines which are not perpendicular to
appear as if they are.)
</p>
<p>The argument <code>asp</code> was added at the request of Zubin
Dowlaty (who presumably knows what he is doing!).
</p>


<h3>Author(s)</h3>

<p>Rolf Turner <a href="mailto:rolfurner@posteo.net">rolfurner@posteo.net</a></p>


<h3>See Also</h3>

 <p><code><a href="#topic+deldir">deldir</a>()</code>, <code><a href="#topic+plot.triang.list">plot.triang.list</a>()</code>,
<code><a href="#topic+tile.list">tile.list</a>()</code>, <code><a href="#topic+plot.tile.list">plot.tile.list</a>()</code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
x &lt;- runif(20)
y &lt;- runif(20)
d &lt;- deldir(x,y)
ttt &lt;- triang.list(d)
plot(ttt,border="red",showrect=TRUE,rectcol="green")
sss &lt;- tile.list(d)
plot(sss)
plot(ttt,add=TRUE,border="blue",showrect=TRUE,rectcol="red")
</code></pre>

<hr>
<h2 id='print.deldir'>
Print some information about a tessellation/triangulation.
</h2><span id='topic+print.deldir'></span>

<h3>Description</h3>

<p>Prints a very brief description of an object of class <code>"deldir"</code>
as returned by <code><a href="#topic+deldir">deldir</a>()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'deldir'
print(x,digits=NULL,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.deldir_+3A_x">x</code></td>
<td>

<p>A Delaunay triangulation and Dirichlet (Voronoi) tessellation
of a set of points (object of class <code>"deldir"</code>).
</p>
</td></tr>
<tr><td><code id="print.deldir_+3A_digits">digits</code></td>
<td>

<p>Integer scalar.  The number of digits to which to round the
numeric information before printing.  Note this may be give
negative values.  (See <code><a href="base.html#topic+round">round</a>()</code>.)
</p>
</td></tr>
<tr><td><code id="print.deldir_+3A_...">...</code></td>
<td>

<p>Not used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic <code><a href="base.html#topic+print">print</a>()</code> function.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner <a href="mailto:rolfurner@posteo.net">rolfurner@posteo.net</a></p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+print">print</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
x    &lt;- rnorm(200,0,4)
y    &lt;- rnorm(200,0,4)
dxy1 &lt;- deldir(x,y)
dxy2 &lt;- deldir(x,y,rw=c(-12,12,-11,11))
dxy1
dxy2
print(dxy1,digits=4)
</code></pre>

<hr>
<h2 id='print.tileInfo'>
Print a summary of tile information.
</h2><span id='topic+print.tileInfo'></span>

<h3>Description</h3>

<p>Print a reasonably readable summary of an object of class
<code>tileInfo</code> as produced by the <code>tileInfo()</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tileInfo'
print(x, digits = 4, npl = 6, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.tileInfo_+3A_x">x</code></td>
<td>
<p>An object of class <code>tileInfo</code> as produced by the
<code>tileInfo()</code> function.
</p>
</td></tr>
<tr><td><code id="print.tileInfo_+3A_digits">digits</code></td>
<td>

<p>Integer scalar.  The (maximum) number of decimal digits to which
the output is to be printed.
</p>
</td></tr>
<tr><td><code id="print.tileInfo_+3A_npl">npl</code></td>
<td>

<p>Integer scalar.  &ldquo;Number per line&rdquo;. It specifies the
(maximum) number of values per line.  Used (only) when printing
the edge lengths component of <code>x</code>.  It effects a tidy
&ldquo;folding&rdquo; of the printed vector of edge lengths of the
tile associated with a given point.  If you increase the value of
<code>digits</code> you may wish to decrease the value of <code>npl</code>,
and vice versa.
</p>
</td></tr>
<tr><td><code id="print.tileInfo_+3A_...">...</code></td>
<td>

<p>Not used.  Present for compatibility with the generic
<code>print()</code> function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The list produced by <code>tileInfo()</code> is a bit messy and
hard to comprehend, especially if there is a large number
of tiles.  This print method produces a screen display which
is somewhat more perspicuous.
</p>
<p>There are four components to the display:
</p>

<ul>
<li><p> A list, each entry of which is the vector of edge lengths
of the tile.  Each edge length is formatted to have a number
of digits specified by the <code>digits</code> argument.  Each list
entry may be displayed over a number of lines. The first of these
lines is prefixed by an &ldquo;informative&rdquo; string indicating
the point that determines the tile whose edge lengths are being
printed.  The string is formed from the identifier of the point.
See <code><a href="#topic+deldir">deldir</a>()</code>, <code><a href="#topic+plot.deldir">plot.deldir</a>()</code> and
<code><a href="#topic+getNbrs">getNbrs</a>()</code>.  The identifier may consist essentially
of the index of the point in the sequence of points that is
being tessellated.
</p>
<p>Succeeding lines, corresponding to the same list entry, are
prefixed with a number of blanks so as to produce an aesthetically
pleasing alignment.
</p>
</li>
<li><p> A table of the edge counts of the tiles.
</p>
</li>
<li><p> A simple print out of the areas of the tiles (rounded
to a maximum of <code>digits</code> decimal digits).
</p>
</li>
<li><p> A simple print out of the perimeters of the tiles (rounded
to a maximum of <code>digits</code> decimal digits).
</p>
</li></ul>

<p>This screen display is for &ldquo;looking at&rdquo; only.  In order
to do further calculations on the output of <code>tileInfo</code> it
is necessary to delve into the bowels of <code>x</code> and extract
the relevant bits.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner <a href="mailto:rolfurner@posteo.net">rolfurner@posteo.net</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+tileInfo">tileInfo</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(179)
x    &lt;- runif(100)
y    &lt;- runif(100)
dxy  &lt;- deldir(x,y,rw=c(0,1,0,1))
ixy1 &lt;- tileInfo(dxy)
print(ixy1)
ixy2 &lt;- tileInfo(dxy,bndry=TRUE)
print(ixy2)
if(require(polyclip)) {
    CP &lt;- list(x=c(0.49,0.35,0.15,0.20,0.35,0.42,
                   0.43,0.62,0.46,0.63,0.82,0.79),
               y=c(0.78,0.86,0.79,0.54,0.58,0.70,
                   0.51,0.46,0.31,0.20,0.37,0.54))
    ixy3 &lt;- tileInfo(dxy,clipp=CP)
    options(width=120) # And enlarge the console window.
    print(ixy3) # 33 tiles are retained.
    print(ixy3$perimeters$perComps) # The tiles for points 9 and 94 have
                                    # been split into two components.
}
</code></pre>

<hr>
<h2 id='seaweed'>
seaweed
</h2><span id='topic+seaweed'></span>

<h3>Description</h3>

<p>A data frame whose columns are the coordinates of the centroids
of the cells in a seaweed frond. The points are estimates-by-eye
of where the centroids of the cells occur.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("seaweed")</code></pre>


<h3>Format</h3>

<p>A data frame with 266 observations on the following 2 variables.
</p>

<dl>
<dt><code>x</code></dt><dd><p>The <code class="reqn">x</code>-coordinates of the cell centroids.</p>
</dd>
<dt><code>y</code></dt><dd><p>The <code class="reqn">y</code>-coordinates of the cell centroids.</p>
</dd>
</dl>



<h3>Source</h3>

<p>These data were kindly supplied by Dr. John Bothwell of the
Department of Biosciences, Durham University.  The data were
collected by Kevin Yun and Georgia Campbell, members of Dr.
Bothwell's research group.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># data(seaweed)
# It is unnecessary to use \code{data} since \code{seaweed} is
# a "first class object".  It is "lazily loaded".

dsw &lt;- deldir(seaweed)
isw &lt;- tileInfo(dsw)
# Expand the width of the terminal window.
options(width=120)
isw
tsw &lt;- tile.list(dsw)
plot(tsw,labelPts=TRUE,col.lbls="red",cex=0.5,adj=0.5)
</code></pre>

<hr>
<h2 id='tile.centroids'>
Compute centroids of Dirichlet (Voronoi) tiles
</h2><span id='topic+tile.centroids'></span>

<h3>Description</h3>

<p>Given a list of Dirichlet tiles, as produced by <code>tile.list()</code>,
produces a data frame consisting of the centroids of those tiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tile.centroids(tl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tile.centroids_+3A_tl">tl</code></td>
<td>
<p>A list of the tiles (produced by <code>tile.list()</code>)
in a Dirichlet tessellation of a set of planar points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with two columns named <code>x</code> and <code>y</code>.
Each row of this data frame constitutes the centroid of one
of the Dirichlet tiles.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner <a href="mailto:rolfurner@posteo.net">rolfurner@posteo.net</a></p>


<h3>References</h3>

<p>URL http://en.wikipedia.org/wiki/Centroid
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+tile.list">tile.list</a>()</code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
x &lt;- runif(20)
y &lt;- runif(20)
d &lt;- deldir(x,y)
l &lt;- tile.list(d)
g &lt;- tile.centroids(l)
plot(l,close=TRUE)
points(g,pch=20,col="red")
</code></pre>

<hr>
<h2 id='tile.list'> Create a list of tiles in a tessellation </h2><span id='topic+tile.list'></span>

<h3>Description</h3>

<p>For each point in the set being tessellated produces a list
entry describing the Dirichlet/Voronoi tile containing that
point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> tile.list(object,minEdgeLength=NULL,clipp=NULL) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tile.list_+3A_object">object</code></td>
<td>
<p> An object of class <code>deldir</code> as produced
by the function <code><a href="#topic+deldir">deldir</a>()</code>.</p>
</td></tr>
<tr><td><code id="tile.list_+3A_minedgelength">minEdgeLength</code></td>
<td>

<p>Positive numeric scalar specifying the minimum length that
an edge of a tile may have.  It is used to eliminate edges
that are effectively of zero length, which can cause tiles
to be &ldquo;invalid&rdquo;.  This argument defaults to
<code>sqrt(.Machine$double.eps)</code> time the diameter (length
of the diagonal) of the &ldquo;rectangular window&rdquo;
associated with the tessellation.  This rectangular window
is available as the <code>rw</code> component of <code>object</code>.
</p>
</td></tr>
<tr><td><code id="tile.list_+3A_clipp">clipp</code></td>
<td>
<p>An object specifying a polygon to which the
tessellation, whose tiles are being determined, should be clipped.
It should consist either of:
</p>

<ul>
<li><p> a list containing two components x and y giving the
coordinates of the vertices of a single polygon. The last vertex
should not repeat the first vertex. Or:
</p>
</li>
<li><p> a list of list(x,y) structures giving the coordinates of
the vertices of several polygons.
</p>
</li></ul>

<p>If this argument is provided then the tiles in the list that
is produced are &ldquo;clipped&rdquo; to the polygon specified by
<code>clipp</code>.  Empty tiles (those which do not intersect the
polygon specified by <code>clipp</code>) are omitted.  The clipping
process may subdivide some of the tiles into two or more
discontiguous parts.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with one entry for each of the points in the set being
tessellated, or for each of the tiles that are retained after clipping
if <code>clipp</code> is not <code>NULL</code>.  Each entry is in turn a list
with a number of components.  These components always include:
</p>
<table>
<tr><td><code>ptNum</code></td>
<td>
<p>The index of the point in the original sequence of points
that is being tessellated.  Note that if a point is one of a set
of <em>duplicated</em> points then <code>ptNum</code> is the <em>first</em> of the
indices of the points in this set.</p>
</td></tr>
<tr><td><code>pt</code></td>
<td>
<p>The coordinates of the point whose tile is being described.</p>
</td></tr>
<tr><td><code>area</code></td>
<td>
<p>The area of the tile.</p>
</td></tr>
</table>
<p>If the tile in question has <em>not</em> been subdivided by the
clipping process then the list components also include:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>The <code>x</code> coordinates of the vertices of the tile, in
anticlockwise order.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>The <code>y</code> coordinates of the vertices of the tile, in
anticlockwise order.</p>
</td></tr>
<tr><td><code>bp</code></td>
<td>
<p>Vector of logicals indicating whether the tile vertex is a
&ldquo;real&rdquo; vertex, or a <em>boundary point</em>, i.e. a point where the
tile edge intersects the boundary of the enclosing rectangle.</p>
</td></tr>
</table>
<p>If the tile in question <em>has</em> been subdivided then the list
does not have the foregoing three components but rather has a
component <code>tileParts</code> which is in turn a list of length equal
to the number of parts into which the tile was subdivided.  Each
component of <code>tileParts</code> is yet another list with four
components <code>x</code>, <code>y</code>, <code>bp</code> and <code>area</code> as described above
and as are appropriate for the part in question. 
</p>
<table>
<tr><td><code>z</code></td>
<td>
<p>The &ldquo;auxiliary value&rdquo; or &ldquo;tag&rdquo; associated
with the <code>pt</code>; present only if such values were supplied in
the call to <code>deldir()</code>.</p>
</td></tr>
</table>


<h3>Acknowledgement</h3>

<p>The author expresses sincere thanks to Majid Yazdani who found and
pointed out a serious bug in <code>tile.list</code> in a previous version
(0.0-5) of the <code>deldir</code> package.
</p>


<h3>Warning</h3>

<p>The set of vertices of each tile may be &ldquo;incomplete&rdquo;.  Only
vertices which lie within the enclosing rectangle, and &ldquo;boundary
points&rdquo; are listed.
</p>
<p>Note that the enclosing rectangle may be specified by the user
in the call to <code><a href="#topic+deldir">deldir</a>()</code>.
</p>
<p>In contrast to some earlier versions of <code>deldir</code>, the corners
of the enclosing rectangle are now included as vertices of tiles.
I.e. a tile which in fact extends beyond the rectangular window
and contains a corner of that window will have that corner added
to its list of vertices.  Thus the corresponding polygon is the
intersection of the tile with the enclosing rectangle.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner <a href="mailto:rolfurner@posteo.net">rolfurner@posteo.net</a></p>


<h3>See Also</h3>

 <p><code><a href="#topic+deldir">deldir</a>()</code>, <code><a href="#topic+plot.tile.list">plot.tile.list</a>()</code>
<code><a href="#topic+triang.list">triang.list</a>()</code> <code><a href="#topic+plot.triang.list">plot.triang.list</a>()</code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>    set.seed(42)
    x &lt;- runif(20)
    y &lt;- runif(20)
    z &lt;- deldir(x,y)
    w &lt;- tile.list(z)

    z &lt;- deldir(x,y,rw=c(0,1,0,1))
    w &lt;- tile.list(z)

    z &lt;- deldir(x,y,rw=c(0,1,0,1),dpl=list(ndx=2,ndy=2))
    w &lt;- tile.list(z)
    if(require(polyclip)) {
        CP &lt;- list(x=c(0.49,0.35,0.15,0.20,0.35,0.42,
                       0.43,0.62,0.46,0.63,0.82,0.79),
                   y=c(0.78,0.86,0.79,0.54,0.58,0.70,
                       0.51,0.46,0.31,0.20,0.37,0.54)) 
        wc &lt;- tile.list(z,clipp=CP) # 10 tiles are retained; the third tile,
                                    # corresponding to point 6, is
                                    # subdivided into two parts.
    # Determine the tiles on the border of a clipping region.
    # Example due to Huimin Wang.
    set.seed(112)
    x      &lt;- runif(100)
    y      &lt;- runif(100)
    dxy    &lt;- deldir(x,y)
    txy    &lt;- tile.list(dxy)
    chind  &lt;- chull(x,y)
    bdry   &lt;- list(x=x[chind],y=y[chind])
    ctxy   &lt;- tile.list(dxy,clipp=bdry)
    inside &lt;- lapply(ctxy,function(tile,bdry){insidePoly(tile$x,tile$y,bdry)},
                                            bdry=bdry)
    border &lt;- sapply(inside,function(x){any(!x) | any(attr(x,"on.boundary"))})
    plot(ctxy[border],main="Border tiles")
    }
</code></pre>

<hr>
<h2 id='tileArea'>
Area of a Dirichlet tile.
</h2><span id='topic+tileArea'></span>

<h3>Description</h3>

<p>Calculates the area of a Dirichlet tile, applying a discrete
version of Stoke's theorem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tileArea(x, y, rw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tileArea_+3A_x">x</code></td>
<td>

<p>The <code>x</code>-coordinates of the vertices of the tile, in
<b>anticlockwise</b> direction.   The last coordinate should
<b>not</b> repeat the first.
</p>
</td></tr>
<tr><td><code id="tileArea_+3A_y">y</code></td>
<td>

<p>The <code>y</code>-coordinates of the vertices of the tile, in
<b>anticlockwise</b> direction.   The last coordinate should
<b>not</b> repeat the first.
</p>
</td></tr>
<tr><td><code id="tileArea_+3A_rw">rw</code></td>
<td>

<p>A vector of length 4 specifying the rectangular window in
which the relevant tessellation was constructed.  See
<code><a href="#topic+deldir">deldir</a>()</code> for more detail.  Actually this
can be any rectangle containing the tile in question.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The heavy lifting is done by the Fortran subroutine <code>stoke()</code>
which is called by the <code>.Fortran()</code> function.
</p>


<h3>Value</h3>

<p>A positive scalar.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner <a href="mailto:rolfurner@posteo.net">rolfurner@posteo.net</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+deldir">deldir</a>()</code>
<code><a href="#topic+tilePerim">tilePerim</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
x &lt;- runif(20)
y &lt;- runif(20)
z &lt;- deldir(x,y,rw=c(0,1,0,1))
w &lt;- tile.list(z)
with(w[[1]],tileArea(x,y,rw=z$rw))
sapply(w,function(x,rw){tileArea(x$x,x$y,attr(w,"rw"))})
x &lt;- c(0.613102,0.429294,0.386023,0.271880,0.387249,0.455900,0.486101)
y &lt;- c(0.531978,0.609665,0.597780,0.421738,0.270596,0.262953,0.271532)
# The vertices of the Dirichlet tile for point 6.
tileArea(x,y,rw=c(0,1,0,1))
tileArea(x,y,rw=c(-1,2,-3,4)) # Same as above.
</code></pre>

<hr>
<h2 id='tileInfo'>
Extract information from a tile list.
</h2><span id='topic+tileInfo'></span>

<h3>Description</h3>

<p>Produces a summary of information about the tiles in an
object of class <code>deldir</code> as produced by the function
<code>deldir()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tileInfo(object, bndry = FALSE, clipp=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tileInfo_+3A_object">object</code></td>
<td>
<p> An object of class <code>deldir</code> as produced
by the function <code>deldir()</code>.
</p>
</td></tr>
<tr><td><code id="tileInfo_+3A_bndry">bndry</code></td>
<td>

<p>Logical scalar.  If <code>TRUE</code> then the &ldquo;boundary&rdquo; tiles
(those tiles having edges forming part of the &ldquo;rectangular
window&rdquo; enclosing the tessellation) are included in the summary.
Otherwise they are excluded.  Note that if all tiles are
boundary tiles and <code>bndry</code> is <code>FALSE</code>, then the list of
included tiles is empty.  In this setting the information summary
would be vacuous and hence an error is thrown.
</p>
</td></tr>
<tr><td><code id="tileInfo_+3A_clipp">clipp</code></td>
<td>
<p>An object specifying a polygon to which the tiles of
the tessellation should be clipped.  See <code>link{tile.list}()</code>
for more information.  Note that tiles which were originally
boundary tiles may no longer be boundary tiles after being clipped.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"tileInfo"</code> which consists of a
list with components:
</p>
<table>
<tr><td><code>indivTiles</code></td>
<td>
<p>This is itself a list. If <code>clipp</code>
is <code>NULL</code> then this list has one entry for each tile in
&ldquo;object&rdquo;.  If <code>clipp</code> is not <code>NULL</code> then tiles
are retained only if they have non-empty intersection with the
polygon specified by <code>clipp</code>.  The list <code>indivTiles</code> is
in fact a <em>named</em> list, the names being of form <code>pt.n</code>,
where <code>n</code> is equal to the value of <code>ptNum</code> (see below)
corresponding to the tile.
</p>
<p>The entries of <code>indivTiles</code> are themselves in turn lists with
entries
</p>

<ul>
<li> <p><code>edges</code>:  a matrix whose rows consists of the <code>x</code>
and <code>y</code> coordinates of the endpoints of each edge of the tile
</p>
</li>
<li> <p><code>edgeLengths</code>: a vector of the lengths of the edges
of the tile
</p>
</li>
<li> <p><code>area</code>: a positive number equal to the area of the tile
</p>
</li>
<li> <p><code>ptNum</code> an integer equal to the number of the point
determining the tile.  Note that this is the number of the point
in the <em>original</em> sequence of points that were tessellated.
</p>
</li></ul>

</td></tr>
<tr><td><code>allEdgeCounts</code></td>
<td>
<p>An integer vector of the number of
edges for each of the tiles.</p>
</td></tr>
<tr><td><code>tabEdgeCounts</code></td>
<td>
<p>A table of <code>allEdgeCounts</code>.</p>
</td></tr>
<tr><td><code>allEdgeLengths</code></td>
<td>
<p>A vector of all of the tile edge lengths;
a catenation of the <code>edgeLengths</code> components of the entries
of <code>indivTiles</code>.  Note that there will be many duplicate
lengths since each tile edge is, in general, an edge of <em>two</em>
tiles.</p>
</td></tr>
<tr><td><code>Areas</code></td>
<td>
<p>A vector of the areas of the tiles.</p>
</td></tr>
<tr><td><code>uniqueEdgeLengths</code></td>
<td>
<p>A vector of the lengths of the tiles edges
with the duplicates (which occur in <code>allEdgeLengths</code>) being
eliminated. Each tile edge is represented only once.</p>
</td></tr>
<tr><td><code>perimeters</code></td>
<td>
<p>A list, as returned by <code><a href="#topic+tilePerim">tilePerim</a>()</code>
containing the perimeters of the tiles, as well as the total and
the mean of these perimeters.  In addition <code>perimeters</code> has
a component <code>perComps</code> giving the breakdown of the perimeters
into the perimeters of the parts into which tiles may have been
subdivided by the clipping process.</p>
</td></tr>
</table>


<h3>Remark</h3>

<p>There is a <code>print()</code> method for class <code>"tileInfo"</code> which
produces a convenient display of the information returned by this
function.
</p>


<h3>Acknowledgement</h3>

<p>Thanks to Krisztina Konya of Ruhr-University Bochum, who provided
an example illustrating the need for an error trap in the setting
in which all tiles are boundary tiles.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner <a href="mailto:rolfurner@posteo.net">rolfurner@posteo.net</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+deldir">deldir</a>()</code> <code><a href="#topic+tile.list">tile.list</a>()</code> <code><a href="#topic+print.tileInfo">print.tileInfo</a>()</code>
<code><a href="#topic+tilePerim">tilePerim</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
x    &lt;- runif(20)
y    &lt;- runif(20)
dxy  &lt;- deldir(x,y,rw=c(0,1,0,1))
ixy1 &lt;- tileInfo(dxy)
ixy2 &lt;- tileInfo(dxy,bndry=TRUE)
if(require(polyclip)) {
    CP &lt;- list(x=c(0.49,0.35,0.15,0.20,0.35,0.42,
                   0.43,0.62,0.46,0.63,0.82,0.79),
               y=c(0.78,0.86,0.79,0.54,0.58,0.70,
                   0.51,0.46,0.31,0.20,0.37,0.54))
    ixy3 &lt;- tileInfo(dxy,clipp=CP) # 10 tiles are retained; the third tile,
                                   # corresponding to point 6, is
                                   # subdivided into two parts.
}
</code></pre>

<hr>
<h2 id='tilePerim'>
Calculate tile perimeters.
</h2><span id='topic+tilePerim'></span>

<h3>Description</h3>

<p>Calculates the perimeters of all of the Dirichlet (Voronoi)
tiles in a tessellation of a set of planar points.  Also
calculates the sum and the mean of these perimeters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tilePerim(object,inclbdry=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tilePerim_+3A_object">object</code></td>
<td>

<p>An object of class <code>tile.list</code> (as produced by
<code><a href="#topic+tile.list">tile.list</a>()</code> specifying the Dirichlet (Voronoi)
tiles in a tessellation of a set of planar points.
</p>
</td></tr>
<tr><td><code id="tilePerim_+3A_inclbdry">inclbdry</code></td>
<td>

<p>Logical scalar.  Should boundary segments (edges of tiles
at least one of whose endpoints lies on the enclosing
rectangle <code>rw</code> (see <code><a href="#topic+deldir">deldir</a>()</code>) be included
in the perimeter?
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components
</p>
<table>
<tr><td><code>perimeters</code></td>
<td>

<p>A vector consisting of the values of the perimeters of
the Dirichlet tiles in the tessellation.
</p>
</td></tr>
<tr><td><code>totalPerim</code></td>
<td>

<p>The sum of <code>perimeters</code>.
</p>
</td></tr>
<tr><td><code>meanPerim</code></td>
<td>

<p>The mean of <code>perimeters</code>.
</p>
</td></tr>
<tr><td><code>perComps</code></td>
<td>

<p>A list whose entries are vectors consisting of the &ldquo;components&rdquo; of the
perimeters of each tile.  If/when the tiles are clipped, some
tiles may be subdivided by the clipping into discontiguous parts.  The
components referred to above are the perimeters of this parts.  If no
subdivision has occurred then the vector in question has a single entry
equal to the perimeter of the corresponding tile.  If subdivision has
occurred then the perimeter of the tile is the sum of the perimeters
of the components.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Function added at the request of Haozhe Zhang.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner <a href="mailto:rolfurner@posteo.net">rolfurner@posteo.net</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+tile.list">tile.list</a>()</code>, <code><a href="#topic+plot.tile.list">plot.tile.list</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    x &lt;- runif(20)
    y &lt;- runif(20)
    z &lt;- deldir(x,y,rw=c(0,1,0,1))
    w &lt;- tile.list(z)
    p1 &lt;- tilePerim(w)
    p0 &lt;- tilePerim(w,inclbdry=FALSE)
    p1$totalPerim - p0$totalPerim # Get 4 = the perimeter of rw.
    ss &lt;- apply(as.matrix(z$dirsgs[,1:4]),1,
                function(x){(x[1]-x[3])^2 + (x[2]-x[4])^2})
    2*sum(sqrt(ss)) - p0$totalPerim # Get 0; in tilePerim() each interior
                                    # edge is counted twice.
    if(require(polyclip)) {
        CP &lt;- list(x=c(0.49,0.35,0.15,0.20,0.35,0.42,
                       0.43,0.62,0.46,0.63,0.82,0.79),
                   y=c(0.78,0.86,0.79,0.54,0.58,0.70,
                       0.51,0.46,0.31,0.20,0.37,0.54))
        wc &lt;- tile.list(z,clipp=CP)
        p2 &lt;- tilePerim(wc) # Doesn't matter here if inclbdry is TRUE or FALSE.
        p2$perComps[["pt.6"]] # The tile for point 6 has got subdivided into
                              # two parts, a tetrahedron and a triangle.
        cul &lt;- rainbow(10)[c(1,7,3:6,2,8:10)] # Rearranging colours to improve
                                              # the contrast between contiguous tiles.
        plot(wc,labelPts=TRUE,fillcol=cul)
    }
</code></pre>

<hr>
<h2 id='toyPattern'>
A toy marked point pattern object, with 59 points.
</h2><span id='topic+toyPattern'></span>

<h3>Description</h3>

<p>A simulated object of class <code>"ppp"</code> provided for use
in an example illustrating the application of <code>deldir()</code>
to point pattern objects. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toyPattern</code></pre>


<h3>Format</h3>

<p>An object of class <code>"ppp"</code> consisting of a simulated marked
point pattern.  Entries include
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code>x</code> </td><td style="text-align: left;"> Cartesian <code class="reqn">x</code>-coordinates </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>y</code> </td><td style="text-align: left;"> Cartesian <code class="reqn">y</code>-coordinates </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>marks</code> </td><td style="text-align: left;"> factor with levels <code>"a","b","c","d"</code>
    </td>
</tr>

</table>



<h3>Source</h3>

<p> Simulated.  </p>


<h3>Examples</h3>

<pre><code class='language-R'>dtoy    &lt;- deldir(toyPattern) # "Tags" are the marks of the pattern.
set.seed(42)
dtoy.nt &lt;- deldir(toyPattern,z=round(runif(59),2)) # Tags are numeric.
</code></pre>

<hr>
<h2 id='triang.list'>
Create a list of Delaunay triangles
</h2><span id='topic+triang.list'></span>

<h3>Description</h3>

<p>From an object of class &ldquo;deldir&rdquo; produces a list
of the Delaunay triangles in the triangulation of a set
of points in the plane.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triang.list(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triang.list_+3A_object">object</code></td>
<td>

<p>An object of class &ldquo;deldir&rdquo; as produced by <code><a href="#topic+deldir">deldir</a>()</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list each of whose components is a <code class="reqn">3 \times 3</code> or
<code class="reqn">3 \times 4</code> data frame corresponding to one of the
Delaunay triangles specified by &ldquo;object&rdquo;.  The rows of each
such data frame correspond to the vertices of the corresponding
Delaunay triangle. The columns are:
</p>

<ul>
<li> <p><code>ptNum</code> (the index of the point in the original sequence
of points that is being triangulated.  Note that if a point is
one of a set of <em>duplicated</em> points then <code>ptNum</code> is
the <em>first</em> of the indices of the points in this set.)
</p>
</li>
<li> <p><code>x</code> (the <code class="reqn">x</code>-coordinate of the vertex)
</p>
</li>
<li> <p><code>y</code> (the <code class="reqn">y</code>-coordinate of the vertex)
</p>
</li>
<li> <p><code>z</code> (the &ldquo;auxiliary value&rdquo; or &ldquo;tag&rdquo;
<code>z</code> associated with the vertex; present only if such values
were supplied in the call to <code>deldir()</code>)
</p>
</li></ul>

<p>The returned value has an attribute &ldquo;rw&rdquo; consisting of the
enclosing rectangle of the triangulation.
</p>


<h3>Warning</h3>

<p>There may not actually <b>be</b> any triangles determined by
<code>object</code>, in which case this function returns an empty
list with an <code>"rw"</code> attribute.  See <b>Examples</b>. 
</p>


<h3>Note</h3>

<p>The code of this function was taken more-or-less directly
from code written by Adrian Baddeley for the &ldquo;delaunay()&rdquo;
function in the &ldquo;spatstat&rdquo; package.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner <a href="mailto:rolfurner@posteo.net">rolfurner@posteo.net</a></p>


<h3>See Also</h3>

 <p><code><a href="#topic+deldir">deldir</a>()</code>, <code><a href="#topic+plot.triang.list">plot.triang.list</a>()</code>,
<code><a href="#topic+tile.list">tile.list</a>()</code>, <code><a href="#topic+plot.tile.list">plot.tile.list</a>()</code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
x  &lt;- runif(20)
y  &lt;- runif(20)
z  &lt;- sample(1:100,20)
d1 &lt;- deldir(x,y,z=z)
t1 &lt;- triang.list(d1)
# A "triangulation" with no triangles!
d2 &lt;- deldir(x=1:10,y=11:20)
plot(d2)
t2 &lt;- triang.list(d2)
plot(t2,showrect=TRUE,rectcol="blue") # Pretty boring!
</code></pre>

<hr>
<h2 id='triMat'>
Produce matrix of triangle vertex indices.
</h2><span id='topic+triMat'></span>

<h3>Description</h3>

<p>Lists the indices of the vertices of each Delaunay triangle in
the triangulation of a planar point set.  The indices are listed
(in increasing numeric order) as the rows of an <code class="reqn">n \times 3</code>
matrix where <code class="reqn">n</code> is the number of Delaunay triangles in the
triangulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triMat(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triMat_+3A_object">object</code></td>
<td>

<p>An object of class <code>deldir</code> (as produced by the function
<code><a href="#topic+deldir">deldir</a>()</code>) specifying the Delaunay triangulation
and Dirichlet (Voronoi) tessellation of a planar point set.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function was suggested by Robin Hankin of the School of
Mathematical and Computing Sciences at Auckland University of
Technology.
</p>


<h3>Value</h3>

<p>An <code class="reqn">n \times 3</code> matrix where <code class="reqn">n</code> is the number
of Delaunay triangles in the triangulation specified by <code>object</code>.
The <code class="reqn">i^{th}</code> row consists of the indices (in the original
list of points being triangulated) of vertices of the <code class="reqn">i^{th}</code>
Delaunay triangle.  The indices are listed in increasing numeric
order in each row.
</p>


<h3>Note</h3>

<p>Earlier versions of this function (prior to release 0.1-14
of <b>deldir</b>) could sometimes give incorrect results.
This happened if the union of three contiguous Delaunay triangles
happened to constitute another triangle.  This latter triangle
would appear in the list of triangles produced by <code>triMat()</code>
but is <em>not</em> itself a Delaunay triangle.  The updated version
of <code>triMat()</code> now checks for this possibility and gives
(<em>I think!</em>) correct results.
</p>
<p>Many thanks to Jay Call, who pointed out this bug to me.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner <a href="mailto:rolfurner@posteo.net">rolfurner@posteo.net</a></p>


<h3>See Also</h3>

 <p><code><a href="#topic+deldir">deldir</a>()</code>
<code><a href="#topic+triang.list">triang.list</a>()</code>
<code><a href="#topic+plot.triang.list">plot.triang.list</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># These are the data used by Jay Call to illustrate the bug
# that appeared in a previous incarnation of triMat.
xy &lt;- data.frame(
          x = c(0.048,0.412,0.174,0.472,0.607,0.565,0.005,0.237,0.810,0.023),
          y = c(0.512,0.928,0.955,0.739,0.946,0.134,0.468,0.965,0.631,0.782)
      )
dxy &lt;- deldir(xy)
M   &lt;- triMat(dxy)
plot(dxy,wlines="triang",num=TRUE,axes=FALSE,cmpnt_col=c(1,1,1,1,2,1))
# The triangle with vertices {4,5,8} was listed in the output of
# the previous (buggy) version of triMat().  It is NOT a Delaunay
# triangle and hence should NOT be listed.
</code></pre>

<hr>
<h2 id='volTriPoints'>
Solute plume concentration data set.
</h2><span id='topic+volTriPoints'></span>

<h3>Description</h3>

<p>Example solute plume concentration data set
associated with the GWSDAT (&ldquo;GroundWater
Spatiotemporal Data Analysis Tool&rdquo;) project
<a href="https://protect-au.mimecast.com/s/demRC91WzLH6qo3TorzN7?domain=gwsdat.net">https://protect-au.mimecast.com/s/demRC91WzLH6qo3TorzN7?domain=gwsdat.net</a>.
The <code>deldir</code> package is used in this project as part of a
numerical routine to estimate plume quantities (mass, average
concentration and centre of mass).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>volTriPoints</code></pre>


<h3>Format</h3>

<p>A data frame with 232 observations on the following 3 variables.
</p>

<dl>
<dt><code>x</code></dt><dd><p>The <code>x</code>-coordinates of the centres of mass
of the plumes.</p>
</dd>
<dt><code>y</code></dt><dd><p>The <code>y</code>-coordinates of the centres of mass
of the plumes.</p>
</dd>
<dt><code>z</code></dt><dd><p>The plume concentrations.</p>
</dd>
</dl>



<h3>Details</h3>

<p>This data set played a critical role in revealing a bug in the
Fortran code underlying the <code>deldir()</code> function.
</p>


<h3>Source</h3>

<p>These data were kindly provided by Wayne W. Jones of the GWSDAT
project.  The data set was originally named <code>Vol.Tri.Points</code>;
the name was changed so as to be more consistent with my usual
naming conventions.
</p>


<h3>References</h3>

<p>Jones, W. R., Spence, M. J., Bowman, A. W., Evers, L. and Molinari,
D. A.  (2014). A software tool for the spatiotemporal analysis
and reporting of groundwater monitoring data. <em>Environmental
Modelling &amp; Software</em> <b>55</b>, pp. 242&ndash;249.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dvtp &lt;- deldir(volTriPoints)
plot(dvtp)
</code></pre>

<hr>
<h2 id='which.tile'>
Determine the tile containing a given point.
</h2><span id='topic+which.tile'></span>

<h3>Description</h3>

<p>Finds the Dirichlet/Voronoi tile, of a tessellation produced
by <code>deldir()</code>, that contains a given point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which.tile(x, y, tl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="which.tile_+3A_x">x</code></td>
<td>

<p>The <code>x</code> coordinate of the point in question.
</p>
</td></tr>
<tr><td><code id="which.tile_+3A_y">y</code></td>
<td>

<p>The <code>y</code> coordinate of the point in question.
</p>
</td></tr>
<tr><td><code id="which.tile_+3A_tl">tl</code></td>
<td>

<p>A tile list, as produced by the function <code><a href="#topic+tile.list">tile.list</a>()</code>
from a tessellation produced by <code><a href="#topic+deldir">deldir</a>()</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Just minimises the distance from the point in question to the
points of the pattern determining the tiles.
</p>


<h3>Value</h3>

<p>An integer equal to the index of the tile in which the given
point lies.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner <a href="mailto:rolfurner@posteo.net">rolfurner@posteo.net</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+tile.list">tile.list</a>()</code> <code><a href="#topic+deldir">deldir</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
x   &lt;- runif(20,0,100)
y   &lt;- runif(20,0,100)
dxy &lt;- deldir(x,y)
txy &lt;- tile.list(dxy)
i   &lt;- which.tile(30,50,txy) # The value of i here is 14.
plot(txy,showpoints=FALSE)
text(x,y,labels=1:length(txy),col="red")
points(30,50,pch=20,col="blue")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
