<!DOCTYPE html><html><head><title>Help for package ptinpoly</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ptinpoly}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#blocks2vf'>
<p>Convertor from 3-Block Representation Representation to Vertices-Faces</p></a></li>
<li><a href='#comb'>
<p>Sample Data: Comb Polygon</p></a></li>
<li><a href='#cube'>
<p>Sample Data: Simple Cube</p></a></li>
<li><a href='#fractal'>
<p>Sample Data: Fractal Polygon</p></a></li>
<li><a href='#pip2d'>
<p>Test for Point Containment in 2D Polygon</p></a></li>
<li><a href='#pip3d'>
<p>Test for Point Containment in 3D Polyhedron</p></a></li>
<li><a href='#spiral'>
<p>Sample Data: Spiral Polygon</p></a></li>
<li><a href='#vf2blocks'>
<p>Convertor from Vertices-Faces Representation to 3-Block Representation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Point-in-Polyhedron Test (2D and 3D)</td>
</tr>
<tr>
<td>Version:</td>
<td>2.8</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-05-31</td>
</tr>
<tr>
<td>Author:</td>
<td>Jose M. Maisog, Yuan Wang, George Luta, Jianfei Liu</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jose M. Maisog &lt;bravas02@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Function pip3d() tests whether a point in 3D space is
  within, exactly on, or outside an enclosed surface defined by a triangular mesh.
  Function pip2d() tests whether a point in 2D space is within, exactly on, or outside a polygon.
  For a reference, see: Liu et al., A new point containment test algorithm based on preprocessing
  and determining triangles, Computer-Aided Design 42(12):1143-1150.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), misc3d</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rgl, geometry</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://ptinpoly.pbworks.com">http://ptinpoly.pbworks.com</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Repository/R-Forge/Project:</td>
<td>ptinpoly</td>
</tr>
<tr>
<td>Repository/R-Forge/Revision:</td>
<td>41</td>
</tr>
<tr>
<td>Repository/R-Forge/DateTimeStamp:</td>
<td>2020-05-31 12:01:50</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-06-02 15:10:07 UTC</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-05-31 12:07:07 UTC; rforge</td>
</tr>
</table>
<hr>
<h2 id='blocks2vf'>
Convertor from 3-Block Representation Representation to Vertices-Faces
</h2><span id='topic+blocks2vf'></span>

<h3>Description</h3>

<p>Converts a polyhedron from the <dfn>three-block</dfn> representation to the <dfn>vertices-faces</dfn> representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blocks2vf(Block1,Block2,Block3)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blocks2vf_+3A_block1">Block1</code></td>
<td>
<p>M by 3 matrix containing the XYZ coordinates of vertex 1 of the M faces of the polyhedron</p>
</td></tr>
<tr><td><code id="blocks2vf_+3A_block2">Block2</code></td>
<td>
<p>M by 3 matrix containing the XYZ coordinates of vertex 2 of the M faces of the polyhedron</p>
</td></tr>
<tr><td><code id="blocks2vf_+3A_block3">Block3</code></td>
<td>
<p>M by 3 matrix containing the XYZ coordinates of vertex 3 of the M faces of the polyhedron</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The values in the first output matrix can be floating point integers, representing the
XYZ coordinates of the vertices of the polyhedron.
</p>
<p>The values in the second output matrix will be integers with values running from 1 to N,
where N is the number of vertices.  A value of '1' in this matrix, for example,
represents the 1st vertex, i.e., the vertex defined by the first row in the
matrix <code>Vertices</code>.  Each row in this matrix defines a triangular face in the polyhedron.
</p>
<p>This function is the inverse of the <code>vf2blocks</code> function.
</p>


<h3>Value</h3>

<p>Returns a list of two matrices.
The first is a N by 3 matrix containing the XYZ coordinates of the N vertices of the polyhedron.
The second M by 3 matrix containing indices of the vertices defining the M faces.  See the example below.
</p>


<h3>Note</h3>

<p>This function requires the <b>misc3d</b> library.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load example data.
data(verts)
data(faces)

# Use vf2blocks to convert from vertices-faces representation to 3-block representation.
# Note double square brackets.
blocks = vf2blocks(verts,faces)
block1 = blocks[[1]]
block2 = blocks[[2]]
block3 = blocks[[3]]

# Now use blocks2vf to convert back to vertices-faces representation.
# 'verts2' and 'faces2' should encode the same polyhedron as the
# original 'verts' and 'faces', although perhaps in a different order.
# Note double square brackets.
vertsFaces = blocks2vf(block1,block2,block3)
verts2 = vertsFaces[[1]]
faces2 = vertsFaces[[2]]
</code></pre>

<hr>
<h2 id='comb'>
Sample Data: Comb Polygon
</h2><span id='topic+comb'></span>

<h3>Description</h3>

<p>Sample data defining an enclosed comb 2D polygon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(comb)</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'># Load polygon.
data(comb)

# Plot the polygon.
plot(rbind(comb,comb[1,]),type="l")

# Generate 3333 random test points.
set.seed(1902)
n       &lt;- 3333
x1      &lt;- rnorm(n) ; x2 &lt;- rnorm(n)
X       &lt;- cbind(x1,x2)
queries &lt;- as.matrix(X)

# Check whether test points are contained in the polygon.
# Most of these points will lie outside the polygon.
containment = pip2d(comb,queries);
</code></pre>

<hr>
<h2 id='cube'>
Sample Data: Simple Cube
</h2><span id='topic+cube'></span><span id='topic+faces'></span><span id='topic+verts'></span><span id='topic+queries'></span>

<h3>Description</h3>

<p>This is sample data that defines a simple cube: eight vertices,
and twelve triangles that make up the six faces.
</p>
<p>Also included is an example matrix <code>queries</code> of five test points.
The first test point is contained within the cube, the second
through fourth test points lie exactly on the surface of the
cube, and the fifth test point lies outside the cube.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(verts)
data(faces)
data(queries)
</code></pre>


<h3>Format</h3>

<p><code>verts</code> is an 8 by 3 matrix containing the XYZ coordinates of the vertices of a simple cube.
</p>
<p><code>faces</code> is a 12 by 3 matrix containing the indices of the vertices defining the twelve
triangular faces making up the surface of the cube.
</p>
<p><code>queries</code> is a 5 by 3 matrix containing the XYZ coordinates of five test points to be
tested for containment within the cube.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load sample data defining a simple cube. 
data(verts)
data(faces)

# Also load sample data for five test points.
data(queries)

# Test whether each point in 'queries' is contained in
# the simple cube defined by 'verts' and 'faces'.
# This should return "1  0  0  0 -1".
containment = pip3d(verts,faces,queries);
</code></pre>

<hr>
<h2 id='fractal'>
Sample Data: Fractal Polygon
</h2><span id='topic+fractal'></span>

<h3>Description</h3>

<p>Sample data defining an enclosed fractal 2D polygon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fractal)</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'># Load polygon.
data(fractal)

# Plot the polygon.
plot(rbind(fractal,fractal[1,]),type="l")

# Generate 3333 random test points.
set.seed(1902)
n       &lt;- 3333
x1      &lt;- rnorm(n) ; x2 &lt;- rnorm(n)
X       &lt;- cbind(x1,x2)
queries &lt;- as.matrix(X)

# Check whether test points are contained in the polygon.
# Most of these points will lie outside the polygon.
containment = pip2d(fractal,queries);
</code></pre>

<hr>
<h2 id='pip2d'>
Test for Point Containment in 2D Polygon
</h2><span id='topic+pip2d'></span>

<h3>Description</h3>

<p>Tests whether points are contained within a two-dimensional polygon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pip2d(Vertices,Queries)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pip2d_+3A_vertices">Vertices</code></td>
<td>
<p>N by 2 matrix containing the XY coordinates of N vertices of the polygon</p>
</td></tr>
<tr><td><code id="pip2d_+3A_queries">Queries</code></td>
<td>
<p>P by 2 matrix containing the XY coordinates of P points
to be tested for containment in the polygon defined by 'Vertices'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The XY coordinates of the vertices are stored <em>in order</em> in the
matrix <code>Vertices</code>. It is assumed that the last vertex listed in the matrix
is connected to the first vertex, so that the polygon does not have a &rdquo;hole&rdquo;.
</p>


<h3>Value</h3>

<p>Returns a vector containing P values, one for each of the P points listed in
the <code>Queries</code> matrix.
</p>
<p>'1' indicates that the point is contained in the polygon.
</p>
<p>'0' indicates that the point lies exactly on the surface of the polygon.
</p>
<p>'-1' indicates that the point lies outside the polygon.
</p>
<p>'-3' (error) indicates that the <code>Vertices</code> matrix didn't have two columns
</p>
<p>'-6' (error) indicates that the <code>Queries</code> matrix didn't have two columns
</p>
<p>'-8' (error) indicates computational error not otherwise specified
</p>


<h3>Note</h3>

<p>The polygon defined by <code>Vertices</code> <em>must</em> be &quot;non-leaky&quot;;
i.e., it must define an &quot;inside&quot; versus &quot;outside&quot; and must not contain any holes.
</p>


<h3>References</h3>

<p>W.P. Horn and D.L. Taylor, <em>A theorem to determine the spatial containment of a point in a planar polygon</em>, Computer Vision, Graphics and Image Processing, vol. 45, pp. 106-116,1989.
</p>
<p>S. Nordbeck and B. Rysedt, <em>Computer cartography point-in-polygon programs</em>, BIT, vol. 7, pp. 39-64, 1967.
</p>
<p>J.A. Baerentzen and H. Aanaes, <em>Signed distance computation using the angle weighted pseudo-normal</em>, IEEE Trans. Visualization and Computer Graphics, vol. 11, no. 3, pp. 243-253, May/June 2005.
</p>
<p>J. Liu, Y.Q. Chen, J.M. Maisog, G. Luta, <em>A new point containment test algorithm for polygon composed of huge number of triangles</em>, Computer-Aided Design, Volume 42, Issue 12, December 2010, Pages 1143-1150.
</p>
<p><a href="http://ptinpoly.pbworks.com/">http://ptinpoly.pbworks.com/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#-------------------------------------------
# Load sample data defining a comb, spiral, and fractal. 
data(comb)
data(spiral)
data(fractal)

# Plot the comb, spiral, and fractal.
plot(rbind(comb,comb[1,]),type="l")
plot(rbind(spiral,spiral[1,]),type="l")
plot(rbind(fractal,fractal[1,]),type="l")

# Generate 3333 random test points.
set.seed(1902)
n       &lt;- 3333
x1      &lt;- rnorm(n) ; x2 &lt;- rnorm(n)
X       &lt;- cbind(x1,x2)
queries &lt;- as.matrix(X)

# Check whether test points are contained in the comb, spiral, and factal.
# Most of these points will lie outside the polygons.
containment1 &lt;- pip2d(comb,queries);
containment2 &lt;- pip2d(spiral,queries);
containment3 &lt;- pip2d(fractal,queries);
</code></pre>

<hr>
<h2 id='pip3d'>
Test for Point Containment in 3D Polyhedron
</h2><span id='topic+pip3d'></span>

<h3>Description</h3>

<p>Tests whether points are contained within a three-dimensional polyhedron.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pip3d(Vertices,Faces,Queries)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pip3d_+3A_vertices">Vertices</code></td>
<td>
<p>N by 3 matrix containing the XYZ coordinates of N vertices of the polyhedron</p>
</td></tr>
<tr><td><code id="pip3d_+3A_faces">Faces</code></td>
<td>
<p>M by 3 matrix containing the indices of the three vertices defining the M triangular faces of the polyhedron</p>
</td></tr>
<tr><td><code id="pip3d_+3A_queries">Queries</code></td>
<td>
<p>P by 3 matrix containing the XYZ coordinates of P points
to be tested for containment in the polyhedron defined by 'Vertices' and 'Faces'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The values in the <code>Faces</code> matrix must be integers with values running from 1 to N,
where N is the number of vertices.  A value of '1' in this matrix, for example,
represents the 1st vertex, i.e., the vertex defined by the first row in the
matrix <code>Vertices</code>.
</p>


<h3>Value</h3>

<p>Returns a vector containing P values, one for each of the P points listed in
the <code>Queries</code> matrix.
</p>
<p>'1' indicates that the point is contained in the polyhedron.
</p>
<p>'0' indicates that the point lies exactly on the surface of the polyhedron.
</p>
<p>'-1' indicates that the point lies outside the polyhedron.
</p>
<p>'-2' (error) indicates that the polyhedron was topologically defective (e.g., had a hole)
</p>
<p>'-3' (error) indicates that the <code>Vertices</code> matrix didn't have three columns
</p>
<p>'-4' (error) indicates that the <code>Faces</code> matrix didn't have three columns
</p>
<p>'-5' (error) indicates that the <code>Faces</code> matrix was 0- rather than 1-offset
</p>
<p>'-6' (error) indicates that the <code>Queries</code> matrix didn't have three columns
</p>
<p>'-7' (error) indicates that two faces in the polyhedron were too close to one another
</p>
<p>'-8' (error) indicates computational error not otherwise specified. A possible cause is when two faces of the polygon are extremely close to one another (imagine bending a cylindrical balloon until the two ends meet). Adjusting the spatial smoothness of the data may fix this problem.
</p>


<h3>Note</h3>

<p>The polyhedron defined by <code>Vertices</code> and <code>Faces</code> <em>must</em> be &quot;non-leaky&quot;;
i.e., it must define an &quot;inside&quot; versus &quot;outside&quot; and must not contain any holes.
</p>
<p>For an example of external software that could potentially be used to fix defective polyhedra,
see, e.g., PolyMender (<a href="http://www1.cse.wustl.edu/~taoju/code/polymender.htm">http://www1.cse.wustl.edu/~taoju/code/polymender.htm</a>).
</p>
<p>Previous versions of this function would hang when there were more than two vertices very close
to one another; this problem was discovered with a polyhedron in which there were multip;le
duplicate vertices and one triplicate vertex.  The triplicate vertex fulfilled the case of
&quot;more than two vertices very close to one another&quot;, and caused the code to hang.
The threshold for vertices that are very close to one another has been increased to three.
It is advisable to make sure that a polyhedron does not have more than three vertices
that are &quot;very close to one another&quot;, and to make sure that there are no duplicate vertices.
Similarly, it is advisable to make sure that a polyhedron does not have <em>faces</em> that
that are extremely close to one another.
</p>


<h3>References</h3>

<p>W.P. Horn and D.L. Taylor, <em>A theorem to determine the spatial containment of a point in a planar polygon</em>, Computer Vision, Graphics and Image Processing, vol. 45, pp. 106-116,1989.
</p>
<p>S. Nordbeck and B. Rysedt, <em>Computer cartography point-in-polygon programs</em>, BIT, vol. 7, pp. 39-64, 1967.
</p>
<p>J.A. Baerentzen and H. Aanaes, <em>Signed distance computation using the angle weighted pseudo-normal</em>, IEEE Trans. Visualization and Computer Graphics, vol. 11, no. 3, pp. 243-253, May/June 2005.
</p>
<p>J. Liu, Y.Q. Chen, J.M. Maisog, G. Luta, <em>A new point containment test algorithm for polyhedron composed of huge number of triangles</em>, Computer-Aided Design, Volume 42, Issue 12, December 2010, Pages 1143-1150.
</p>
<p><a href="http://ptinpoly.pbworks.com/">http://ptinpoly.pbworks.com/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#-------------------------------------------
# Simple Cube example.

# Load sample data defining a simple cube. 
data(verts)
data(faces)

# Also load sample data for five test points.
data(queries)

# Test whether each point in 'queries' is contained in
# the simple cube defined by 'verts' and 'faces'.
# This should return "1  0  0  0 -1".
containment &lt;- pip3d(verts,faces,queries);

#-------------------------------------------
# Torus example.

# Make a donut-shaped polyhedron.
torus &lt;- parametric3d(fx = function(u,v) (1+0.25*cos(v))*cos(u),
                      fy = function(u,v) (1+0.25*cos(v))*sin(u),
                      fz = function(u,v) 0.25*sin(v),
                      u = seq(0,2*pi,length.out=10),
                      v = seq(0,2*pi,length.out=10),
                      engine = "none", color="orange", alpha=0.25)

# If desired, this torus can be rendered for visualization, e.g.:
# library(geometry)
# library(rgl)
# drawScene.rgl(torus)

# Convert the torus to vertices-faces representation.
ve       &lt;- misc3d:::t2ve(torus)
Vertices &lt;- t(ve$vb)
Faces    &lt;- t(ve$ib)

# Generate 3333 random test points.
set.seed(1902)
n       &lt;- 3333
x1      &lt;- rnorm(n) ; x2 &lt;- rnorm(n) ; x3 &lt;- rnorm(n)
X       &lt;- cbind(x1,x2,x3)
Queries &lt;- as.matrix(X)

# Check whether test points are contained in the torus.
# Most of these points will lie outside the torus.
containment &lt;- pip3d(Vertices,Faces,Queries);

#-------------------------------------------
# If you remove one of the faces of the cube, the resulting cube
# becomes "leaky".  Running 'pip3d' on the resulting defective
# polyhedron will return -2.
# NOT RUN
#
# badcube     &lt;- faces[1:11,]
# containment &lt;- pip3d(verts,badcube,queries);
</code></pre>

<hr>
<h2 id='spiral'>
Sample Data: Spiral Polygon
</h2><span id='topic+spiral'></span>

<h3>Description</h3>

<p>Sample data defining an enclosed spiral 2D polygon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(spiral)</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'># Load polygon.
data(spiral)

# Plot the polygon.
plot(rbind(spiral,spiral[1,]),type="l")

# Generate 3333 random test points.
set.seed(1902)
n       &lt;- 3333
x1      &lt;- rnorm(n) ; x2 &lt;- rnorm(n)
X       &lt;- cbind(x1,x2)
queries &lt;- as.matrix(X)

# Check whether test points are contained in the polygon.
# Most of these points will lie outside the polygon.
containment = pip2d(spiral,queries);
</code></pre>

<hr>
<h2 id='vf2blocks'>
Convertor from Vertices-Faces Representation to 3-Block Representation
</h2><span id='topic+vf2blocks'></span>

<h3>Description</h3>

<p>Converts a polyhedron from the <dfn>vertices-faces</dfn> representation to the <dfn>three-block</dfn> representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vf2blocks(Vertices,Faces)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vf2blocks_+3A_vertices">Vertices</code></td>
<td>
<p>N by 3 matrix containing the XYZ coordinates of N vertices</p>
</td></tr>
<tr><td><code id="vf2blocks_+3A_faces">Faces</code></td>
<td>
<p>M by 3 matrix containing indices of vertices defining M faces</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The values in the <code>Face</code> matrix must be integers with values running from 1 to N,
where N is the number of vertices.  A value of '1' in this matrix, for example,
represents the 1st vertex, i.e., the vertex defined by the first row in the
matrix <code>Vertices</code>.
</p>
<p>This function is the inverse of the <code>blocks2vf</code> function.
</p>


<h3>Value</h3>

<p>Returns a list of three matrices.
The first is an M by 3 matrix containing the XYZ coordinates of vertex 1 of the M faces of the polyhedron.
The second and third are similarly M by 3 matrices, but contain the XYZ coordinates of
vertices 2 and 3 of the faces.  See the example below.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load example data.
data(verts)
data(faces)

# Use vf2blocks to convert from vertices-faces representation to 3-block representation.
# Note double square brackets.
blocks = vf2blocks(verts,faces)
block1 = blocks[[1]]
block2 = blocks[[2]]
block3 = blocks[[3]]
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
