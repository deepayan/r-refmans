<!DOCTYPE html><html lang="en"><head><title>Help for package graph4lg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {graph4lg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_nodes_attr'><p>Add attributes to the nodes of a graph</p></a></li>
<li><a href='#check_merge'><p>Check whether the option 'nomerge' was used when building the landscape</p>
graph with Graphab</a></li>
<li><a href='#compar_r_fisher'><p>Compare two correlation coefficients obtained from different sample sizes</p></a></li>
<li><a href='#compute_graph_modul'><p>Compute modules from a graph by maximising modularity</p></a></li>
<li><a href='#compute_node_metric'><p>Compute graph-theoretic metrics from a graph at the node level</p></a></li>
<li><a href='#convert_cd'><p>Fit a model to convert cost-distances into Euclidean distances</p></a></li>
<li><a href='#data_ex_genind'><p>data_ex_genind genetic dataset</p></a></li>
<li><a href='#data_ex_gstud'><p>data_ex_gstud genetic dataset</p></a></li>
<li><a href='#data_ex_loci'><p>data_ex_loci genetic dataset</p></a></li>
<li><a href='#data_simul_genind'><p>data_simul_genind genetic dataset</p></a></li>
<li><a href='#data_tuto'><p>data_tuto : data used to generate the vignette</p></a></li>
<li><a href='#deg2rad'><p>Convert degrees to radians</p></a></li>
<li><a href='#df_to_pw_mat'><p>Convert an edge-list data.frame into a pairwise matrix</p></a></li>
<li><a href='#dist_gc_hvs'><p>Calculate the Great-Circle distance between two points using the</p>
Harversine formula (hvs)</a></li>
<li><a href='#dist_gc_slc'><p>Calculate the Great-Circle distance between two points using the</p>
Spherical Law of Cosines (slc)</a></li>
<li><a href='#dist_gc_vicenty'><p>Calculate the Great-Circle distance between two points using the</p>
Vincenty inverse formula for ellipsoids (vicenty)</a></li>
<li><a href='#dist_great_circle'><p>Compute the Great Circle distance between two points</p></a></li>
<li><a href='#dist_max_corr'><p>Compute the distance at which the correlation between genetic distance</p>
and landscape distance is maximal</a></li>
<li><a href='#g_percol'><p>Prune a graph using the 'percolation threshold' method</p></a></li>
<li><a href='#gen_graph_indep'><p>Create an independence graph of genetic differentiation</p>
from genetic data of class genind</a></li>
<li><a href='#gen_graph_thr'><p>Create a graph of genetic differentiation</p>
using a link weight threshold</a></li>
<li><a href='#gen_graph_topo'><p>Create a graph of genetic differentiation with</p>
a specific topology</a></li>
<li><a href='#genepop_to_genind'><p>Convert a GENEPOP file into a genind object</p></a></li>
<li><a href='#genind_to_genepop'><p>Convert a genind object into a GENEPOP file</p></a></li>
<li><a href='#genind_to_structure'><p>Convert a genind object into a STRUCTURE file</p></a></li>
<li><a href='#get_graphab'><p>Download Graphab if not present on the user's machine</p></a></li>
<li><a href='#get_graphab_linkset'><p>Get linkset computed in the Graphab project</p></a></li>
<li><a href='#get_graphab_linkset_cost'><p>Get cost values associated with a linkset in a Graphab project</p></a></li>
<li><a href='#get_graphab_metric'><p>Get metrics computed at the node in the Graphab project</p></a></li>
<li><a href='#get_graphab_raster_codes'><p>Get unique raster codes from a Graphab project</p></a></li>
<li><a href='#gini_coeff'><p>Compute Gini coefficient from a numeric vector</p></a></li>
<li><a href='#graph_modul_compar'><p>Compare the partition into modules of two graphs</p></a></li>
<li><a href='#graph_node_compar'><p>Compare the local properties of the nodes from two graphs</p></a></li>
<li><a href='#graph_plan'><p>Create a graph with a minimum planar graph topology</p></a></li>
<li><a href='#graph_plot_compar'><p>Visualize the topological differences between two spatial graphs on a map</p></a></li>
<li><a href='#graph_to_df'><p>Convert a graph into a edge list data.frame</p></a></li>
<li><a href='#graph_to_shp'><p>Export a spatial graph to shapefile layers</p></a></li>
<li><a href='#graph_topo_compar'><p>Compute an index comparing graph topologies</p></a></li>
<li><a href='#graphab_capacity'><p>Computes custom capacities of patches in the Graphab project</p></a></li>
<li><a href='#graphab_corridor'><p>Computes corridors from least-cost paths already computed in</p>
the Graphab project</a></li>
<li><a href='#graphab_graph'><p>Create a graph in the Graphab project</p></a></li>
<li><a href='#graphab_interpol'><p>Creates a raster with interpolated connectivity metric values from metrics</p>
already computed in the Graphab project</a></li>
<li><a href='#graphab_link'><p>Create a link set in the Graphab project</p></a></li>
<li><a href='#graphab_metric'><p>Compute connectivity metrics from a graph in the Graphab project</p></a></li>
<li><a href='#graphab_modul'><p>Create modules from a graph in the Graphab project</p></a></li>
<li><a href='#graphab_pointset'><p>Add a point set to the Graphab project</p></a></li>
<li><a href='#graphab_project'><p>Create a Graphab project</p></a></li>
<li><a href='#graphab_project_desc'><p>Describe the objects of a Graphab project</p></a></li>
<li><a href='#graphab_to_igraph'><p>Create landscape graphs from Graphab link set</p></a></li>
<li><a href='#gstud_to_genind'><p>Convert a file from <span class="pkg">gstudio</span> or <span class="pkg">popgraph</span> into a genind object</p></a></li>
<li><a href='#harm_mean'><p>Compute the harmonic mean of a numeric vector</p></a></li>
<li><a href='#kernel_param'><p>Compute dispersal kernel parameters</p></a></li>
<li><a href='#link_compar'><p>Compare two link sets created in a Graphab project</p></a></li>
<li><a href='#loci_to_genind'><p>Convert a loci object into a genind object</p></a></li>
<li><a href='#mat_cost_dist'><p>Compute cost distances between points on a raster</p></a></li>
<li><a href='#mat_gen_dist'><p>Compute a pairwise matrix of genetic distances between populations</p></a></li>
<li><a href='#mat_geo_dist'><p>Compute Euclidean geographic distances between points</p></a></li>
<li><a href='#mat_pw_dps'><p>Compute a pairwise genetic distance matrix between populations</p>
using Bowcock et al. (1994) formula</a></li>
<li><a href='#mat_pw_fst'><p>Compute a pairwise FST matrix between populations</p></a></li>
<li><a href='#mypalette'><p>Vector of custom colors</p></a></li>
<li><a href='#patch_areas'><p>Extract patch areas from a categorical raster</p></a></li>
<li><a href='#plot_graph_lg'><p>Plot graphs</p></a></li>
<li><a href='#plot_w_hist'><p>Plot histograms of link weights</p></a></li>
<li><a href='#pop_gen_index'><p>Compute population-level genetic indices</p></a></li>
<li><a href='#pop_rare_gen_index'><p>Compute population-level rarefied genetic indices with ADZE software</p></a></li>
<li><a href='#pts_pop_ex'><p>pts_pop_ex : details on simulated populations</p></a></li>
<li><a href='#pts_pop_simul'><p>pts_pop_simul : details on simulated populations</p></a></li>
<li><a href='#pw_mat_to_df'><p>Convert a pairwise matrix into an edge-list data.frame</p></a></li>
<li><a href='#reorder_mat'><p>Reorder the rows and columns of a symmetric matrix</p></a></li>
<li><a href='#sample_raster'><p>Sample points or patches on a categorical raster layer</p></a></li>
<li><a href='#sc01'><p>Scaling function</p></a></li>
<li><a href='#scatter_dist'><p>Plot scatterplots of genetic distance vs landscape distance</p></a></li>
<li><a href='#scatter_dist_g'><p>Plot scatterplots of distances to visualize the graph pruning intensity</p></a></li>
<li><a href='#structure_to_genind'><p>Convert a file in STRUCTURE format into a genind object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Build Graphs for Landscape Genetics Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.8.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Paul Savary &lt;psavary@protonmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Build graphs for landscape genetics analysis. This set of 
	functions can be used to import and convert spatial and genetic data 
	initially in different formats, import landscape graphs created with 
	'GRAPHAB' software (Foltete et al., 2012) &lt;<a href="https://doi.org/10.1016%2Fj.envsoft.2012.07.002">doi:10.1016/j.envsoft.2012.07.002</a>&gt;, 
	make diagnosis plots of isolation by distance relationships in order to 
	choose how to build genetic graphs, create graphs with a large range of 
	pruning methods, weight their links with several genetic distances, plot 
	and analyse graphs,	compare them with other graphs. It uses functions from 
	other packages such as 'adegenet' 
	(Jombart, 2008) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtn129">doi:10.1093/bioinformatics/btn129</a>&gt; and 'igraph' (Csardi
	et Nepusz, 2006) <a href="https://igraph.org/">https://igraph.org/</a>. It also implements methods 
	commonly used in landscape genetics to create graphs, described by Dyer et 
	Nason (2004) &lt;<a href="https://doi.org/10.1111%2Fj.1365-294X.2004.02177.x">doi:10.1111/j.1365-294X.2004.02177.x</a>&gt; and Greenbaum et 
	Fefferman (2017) &lt;<a href="https://doi.org/10.1111%2Fmec.14059">doi:10.1111/mec.14059</a>&gt;, and to analyse distance data 
	(van Strien et al., 2015) &lt;<a href="https://doi.org/10.1038%2Fhdy.2014.62">doi:10.1038/hdy.2014.62</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.1.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>adegenet, ggplot2, stringr, igraph, stats, spatstat.geom,
spatstat.linnet, Matrix, vegan, utils, methods, pegas, MASS,
tidyr, sp, sf, hierfstat, rappdirs, gdistance, raster, foreign,
ecodist, Rdpack</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-30 00:23:37 UTC; paul</td>
</tr>
<tr>
<td>Author:</td>
<td>Paul Savary <a href="https://orcid.org/0000-0002-2104-9941"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Gilles Vuidel <a href="https://orcid.org/0000-0001-6330-6136"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Tyler Rudolph [ctb],
  Alexandrine Daniel [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-30 14:00:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_nodes_attr'>Add attributes to the nodes of a graph</h2><span id='topic+add_nodes_attr'></span>

<h3>Description</h3>

<p>The function adds attributes to the nodes of a graph from
either an object of class <code>data.frame</code> or from a shapefile layer.
The node IDs in the input objects must be the same as in the graph object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_nodes_attr(
  graph,
  input = "df",
  data,
  dir_path = NULL,
  layer = NULL,
  index = "Id",
  include = "all"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_nodes_attr_+3A_graph">graph</code></td>
<td>
<p>A graph object of class <code>igraph</code>.</p>
</td></tr>
<tr><td><code id="add_nodes_attr_+3A_input">input</code></td>
<td>
<p>A character string indicating the nature of the
input data from which come the attributes to add to the nodes.
</p>

<ul>
<li><p>If 'input = &quot;shp&quot;', then attributes come from the attribute table of
a shapefile layer of type point.
</p>
</li>
<li><p>If 'input = &quot;df&quot;', then attributes come from an object of class
<code>data.frame</code>
</p>
</li></ul>

<p>In both cases, input attribute table or dataframe must have a column with
the exact same values as the node IDs.</p>
</td></tr>
<tr><td><code id="add_nodes_attr_+3A_data">data</code></td>
<td>
<p>(only if 'input = &quot;df&quot;') The name of the object of
class <code>data.frame</code> with the attributes to add to the nodes.</p>
</td></tr>
<tr><td><code id="add_nodes_attr_+3A_dir_path">dir_path</code></td>
<td>
<p>(only if 'input = &quot;shp&quot;') The path (character string) to the
directory containing the shapefile layer of type point whose attribute
table contains the attributes to add to the nodes.</p>
</td></tr>
<tr><td><code id="add_nodes_attr_+3A_layer">layer</code></td>
<td>
<p>(only if 'input = &quot;shp&quot;') The name (character string) of the
shapefile layer of type point (without extension, ex.: &quot;nodes&quot; refers
to &quot;nodes.shp&quot; layer) whose attribute table contains the attributes
to add to the nodes.</p>
</td></tr>
<tr><td><code id="add_nodes_attr_+3A_index">index</code></td>
<td>
<p>The name (character string) of the column with the nodes names
in the input data (column of the attribute table or of the dataframe).</p>
</td></tr>
<tr><td><code id="add_nodes_attr_+3A_include">include</code></td>
<td>
<p>A character string (vector) indicating which columns of the
input data will be added as nodes' attributes.
By default, 'include = &quot;all&quot;', i.e. every column of the input data is added.
Alternatively, 'include' can be a vector with the names of the columns to add
(ex.: &quot;c('x', 'y', 'pop_name')&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The graph can be created with the function
<code><a href="#topic+graphab_to_igraph">graphab_to_igraph</a></code> by importing output from Graphab projects.
Values of the metrics computed at the node level with Graphab can then be
added to such a graph with this function.
</p>


<h3>Value</h3>

<p>A graph object of class <code>igraph</code>
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("data_tuto")
graph &lt;- data_tuto[[3]]
df_nodes &lt;- data.frame(Id = igraph::V(graph)$name,
                       Area = runif(50, min = 10, max = 60))
graph &lt;- add_nodes_attr(graph,
                        data = df_nodes,
                        input = "df",
                        index = "Id",
                        include = "Area")
</code></pre>

<hr>
<h2 id='check_merge'>Check whether the option 'nomerge' was used when building the landscape
graph with Graphab</h2><span id='topic+check_merge'></span>

<h3>Description</h3>

<p>The function checks whether the option 'nomerge' was used when
building the landscape graph with Graphab
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_merge(proj_end_path)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_merge_+3A_proj_end_path">proj_end_path</code></td>
<td>
<p>The path to the project .xml file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a logical indicating whether 'nomerge' was used.
If nomerge=TRUE, then it returns FALSE. If nomerge=FALSE, it returns TRUE.
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
proj_name &lt;- "grphb_ex"
check_merge(proj_name = proj_name)

## End(Not run)
</code></pre>

<hr>
<h2 id='compar_r_fisher'>Compare two correlation coefficients obtained from different sample sizes</h2><span id='topic+compar_r_fisher'></span>

<h3>Description</h3>

<p>The function compares two correlation coefficients obtained from
different sample sizes using Z-Fisher transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compar_r_fisher(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compar_r_fisher_+3A_data">data</code></td>
<td>
<p>An object of class <code>data.frame</code> with at least 4 columns
of data used to perform the test.
4 columns must be called &quot;n1&quot;, &quot;n2&quot;, &quot;r1&quot; and &quot;r2&quot;.
</p>

<ul>
<li><p>n1 and n2 are the sizes of the samples from which r1 and r2
were computed respectively.
</p>
</li>
<li><p>r1 and r2 are Pearson's correlation coefficients
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The Z-Fisher method consists in computing z scores from the
correlation coefficients and to compare these z scores.
z scores are computed as follows :
Let n1 and r1 be the sample size and the correlation coefficient,
z1 = (1/2)*log( (1+r1) / (1-r1) )
Then, a test's statistic is computed from z1 and z2 :
Z = (z1-z2) / sqrt( (1/(n1-3)) + (1/(n2-3)))
If Z is above the limit given by the alpha value, then the difference between
r1 and r2 is significant
</p>


<h3>Value</h3>

<p>An object of class <code>data.frame</code> with the same columns as 'data'
and 4 columns more : z1, z2 (respective z-scores), Z (test's statistic) and
p (p-value) of the test.
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(n1 = rpois(n = 40, lambda = 85),
                 n2 = rpois(n = 40, lambda = 60),
                 r1 = runif(n = 40, min = 0.6, max = 0.85),
                 r2 = runif(n = 40, min = 0.55, max = 0.75))
data &lt;- compar_r_fisher(df)
</code></pre>

<hr>
<h2 id='compute_graph_modul'>Compute modules from a graph by maximising modularity</h2><span id='topic+compute_graph_modul'></span>

<h3>Description</h3>

<p>The function computes  modules from a graph by maximising
modularity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_graph_modul(
  graph,
  algo = "fast_greedy",
  node_inter = NULL,
  nb_modul = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_graph_modul_+3A_graph">graph</code></td>
<td>
<p>An object of class <code>igraph</code>. Its nodes must have names.</p>
</td></tr>
<tr><td><code id="compute_graph_modul_+3A_algo">algo</code></td>
<td>
<p>A character string indicating the algorithm used to create
the modules with <span class="pkg">igraph</span>. </p>

<ul>
<li><p>If <code>algo = 'fast_greedy'</code> (default),
function <code>cluster_fast_greedy</code> from <span class="pkg">igraph</span>
is used (Clauset et al., 2004).
</p>
</li>
<li><p>If <code>algo = 'walktrap'</code>, function <code>cluster_walktrap</code>
from <span class="pkg">igraph</span> is used (Pons et Latapy, 2006) with 4 steps
(default options).
</p>
</li>
<li><p>If <code>algo = 'louvain'</code>, function <code>cluster_louvain</code>
from <span class="pkg">igraph</span> is used (Blondel et al., 2008). In that case, the number
of modules created in each graph is imposed.
</p>
</li>
<li><p>If <code>algo = 'optimal'</code>, function <code>cluster_optimal</code>
from <span class="pkg">igraph</span> is used (Brandes et al., 2008) (can be very long).
In that case, the number of modules created in each graph is imposed.
</p>
</li></ul>
</td></tr>
<tr><td><code id="compute_graph_modul_+3A_node_inter">node_inter</code></td>
<td>
<p>(optional, default = NULL) A character string indicating
whether the links of the graph are weighted by distances or by similarity
indices. It is only used to compute the modularity index. It can be:
</p>

<ul>
<li><p>'distance': Link weights correspond to distances. Nodes that are close
to each other will more likely be in the same module.
</p>
</li>
<li><p>'similarity': Link weights correspond to similarity indices. Nodes that
are similar to each other will more likely be in the same module. Inverse
link weights are then used to compute the modularity index.
</p>
</li></ul>
</td></tr>
<tr><td><code id="compute_graph_modul_+3A_nb_modul">nb_modul</code></td>
<td>
<p>(optional , default = NULL) A numeric or integer value
indicating the number of modules in the graph. When this number is not
specified, the optimal value is retained.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with the node names and the corresponding
module ID.
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("data_tuto")
mat_gen &lt;- data_tuto[[1]]
graph &lt;- gen_graph_thr(mat_w = mat_gen, mat_thr = mat_gen,
                            thr = 0.8)
res_mod &lt;- compute_graph_modul(graph = graph,
                                algo = "fast_greedy",
                                node_inter = "distance")
</code></pre>

<hr>
<h2 id='compute_node_metric'>Compute graph-theoretic metrics from a graph at the node level</h2><span id='topic+compute_node_metric'></span>

<h3>Description</h3>

<p>The function computes graph-theoretic metric values at the
node level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_node_metric(
  graph,
  metrics = c("deg", "close", "btw", "str", "siw", "miw"),
  weight = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_node_metric_+3A_graph">graph</code></td>
<td>
<p>An object of class <code>igraph</code>. Its nodes must have names.</p>
</td></tr>
<tr><td><code id="compute_node_metric_+3A_metrics">metrics</code></td>
<td>
<p>Character vector specifying the graph-theoretic
metrics computed at the node-level in the graphs
Graph-theoretic metrics can be:
</p>

<ul>
<li><p>Degree (<code>metrics = c("deg", ...)</code>)
</p>
</li>
<li><p>Closeness centrality index (<code>metrics = c("close",...)</code>)
</p>
</li>
<li><p>Betweenness centrality index (<code>metrics = c("btw",...)</code>)
</p>
</li>
<li><p>Strength (sum of the weights of the links connected to a node)
(<code>metrics = c("str",...)</code>)
</p>
</li>
<li><p>Sum of the inverse weights of the links connected to a
node (<code>metrics = c("siw", ...)</code>, default)
</p>
</li>
<li><p>Mean of the inverse weights of the links connected to a
node (<code>metrics = c("miw", ...)</code>)
</p>
</li></ul>

<p>By default, the vector <code>metrics</code> includes all these metrics.</p>
</td></tr>
<tr><td><code id="compute_node_metric_+3A_weight">weight</code></td>
<td>
<p>Logical which indicates whether the links are weighted during
the calculation of the centrality indices betweenness and closeness.
(default: <code>weight = TRUE</code>). Link weights are interpreted as distances
when computing the shortest paths. They should then be inversely proportional
to the strength of the relationship between nodes (e.g. to fluxes).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with the node names and the metrics computed.
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(data_ex_genind)
mat_gen &lt;- mat_gen_dist(x = data_ex_genind, dist = "DPS")
graph &lt;- gen_graph_thr(mat_w = mat_gen, mat_thr = mat_gen,
                            thr = 0.8)
res_met &lt;- compute_node_metric(graph)
</code></pre>

<hr>
<h2 id='convert_cd'>Fit a model to convert cost-distances into Euclidean distances</h2><span id='topic+convert_cd'></span>

<h3>Description</h3>

<p>The function fits a model to convert cost-distances into
Euclidean distances as implemented in Graphab software.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_cd(
  mat_euc,
  mat_ld,
  to_convert,
  method = "log-log",
  fig = TRUE,
  line_col = "black",
  pts_col = "#999999"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert_cd_+3A_mat_euc">mat_euc</code></td>
<td>
<p>A symmetric <code>matrix</code> or <code>dist</code> object with
pairwise geographical Euclidean distances between populations or sample
sites. It will be the explanatory variable, and only values from the off
diagonal lower triangle will be used.</p>
</td></tr>
<tr><td><code id="convert_cd_+3A_mat_ld">mat_ld</code></td>
<td>
<p>A symmetric <code>matrix</code> or <code>dist</code> object with pairwise
landscape distances between populations or sample sites. These distances can
be cost-distances or resistance distances, among others. It will be the
explained variable, and only values from the off diagonal lower triangle
will be used.</p>
</td></tr>
<tr><td><code id="convert_cd_+3A_to_convert">to_convert</code></td>
<td>
<p>A numeric value or numeric vector with Euclidean distances
to convert into cost-distances.</p>
</td></tr>
<tr><td><code id="convert_cd_+3A_method">method</code></td>
<td>
<p>A character string indicating the method used to fit the model.
</p>

<ul>
<li><p>If 'method = &quot;log-log&quot;' (default), then the model takes the
following form : log(ld) ~ A + B * log(euc)
</p>
</li>
<li><p>If 'method = &quot;lm&quot;', then the model takes the following form :
ld ~ A + B * euc
</p>
</li></ul>
</td></tr>
<tr><td><code id="convert_cd_+3A_fig">fig</code></td>
<td>
<p>Logical (default = TRUE) indicating whether a figure is plotted</p>
</td></tr>
<tr><td><code id="convert_cd_+3A_line_col">line_col</code></td>
<td>
<p>(if 'fig = TRUE') Character string indicating the color
used to plot the line (default: &quot;blue&quot;). It must be a hexadecimal color
code or a color used by default in R.</p>
</td></tr>
<tr><td><code id="convert_cd_+3A_pts_col">pts_col</code></td>
<td>
<p>(if 'fig = TRUE') Character string indicating the color
used to plot the points (default: &quot;#999999&quot;). It must be a hexadecimal color
code or a color used by default in R.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>IDs in 'mat_euc' and 'mat_ld' must be the same and refer to the same
sampling site or populations, and both matrices must be ordered
in the same way.
Matrix of Euclidean distance 'mat_euc' can be computed using the function
<code><a href="#topic+mat_geo_dist">mat_geo_dist</a></code>.
Matrix of landscape distance 'mat_ld' can be computed using the function
<code><a href="#topic+mat_cost_dist">mat_cost_dist</a></code>.
Before the log calculation, 0 distance values are converted into 1,
so that they are 0 after this calculation.
</p>


<h3>Value</h3>

<p>A list of output (converted values, estimated parameters, R2)
and optionally a ggplot2 object to plot
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>References</h3>

<p>FoltÃªte J, Clauzel C, Vuidel G (2012).
&ldquo;A software tool dedicated to the modelling of landscape networks.&rdquo;
<em>Environmental Modelling &amp; Software</em>, <b>38</b>, 316&ndash;327.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("data_tuto")
mat_ld &lt;- data_tuto[[2]][1:10, 1:10] * 1000
mat_euc &lt;- data_tuto[[1]][1:10, 1:10] * 50000
to_convert &lt;- c(30000, 40000)
res &lt;- convert_cd(mat_euc = mat_euc,
                  mat_ld = mat_ld,
                  to_convert = to_convert, fig = FALSE)
</code></pre>

<hr>
<h2 id='data_ex_genind'>data_ex_genind genetic dataset</h2><span id='topic+data_ex_genind'></span>

<h3>Description</h3>

<p>Genetic dataset from genetic simulation on CDPOP
200 individuals, 10 populations
20 microsatellite loci (3 digits coding)
100 generations simulated
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_ex_genind
</code></pre>


<h3>Format</h3>

<p>An object of type 'genind'
</p>


<h3>Details</h3>

<p>The simulation was made with CDPOP during 100 generations.
Dispersal was possible between the 10 populations. Its probability depended
on the cost distance between populations, calculated on a simulated
resistance surface (raster). Mutations were not possible. There
were initially 600 alleles in total (many disappeared because of drift).
Population stayed constant
with a sex-ratio of 1. Generations did not overlap.
This simulation includes a part of stochasticity and these data result
from only 1 simulation run.
</p>


<h3>References</h3>

<p>Landguth EL, Cushman SA (2010).
&ldquo;CDPOP: a spatially explicit cost distance population genetics program.&rdquo;
<em>Molecular Ecology Resources</em>, <b>10</b>(1), 156&ndash;161.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("data_ex_genind")
length(unique(data_ex_genind@pop))
</code></pre>

<hr>
<h2 id='data_ex_gstud'>data_ex_gstud genetic dataset</h2><span id='topic+data_ex_gstud'></span>

<h3>Description</h3>

<p>Genetic dataset from genetic simulation on CDPOP
200 individuals, 10 populations
20 microsatellite loci (3 digits coding)
100 generations simulated
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_ex_gstud
</code></pre>


<h3>Format</h3>

<p>A 'data.frame' with columns:
</p>

<dl>
<dt>ID</dt><dd><p>Individual ID</p>
</dd>
<dt>POP</dt><dd><p>Population name</p>
</dd>
<dt>LOCI-1 to LOCI-20</dt><dd><p>20 loci columns with microsatellite data with
3 digits coding, alleles separated by &quot;:&quot;, and blank missing data
(class 'locus' from <span class="pkg">gstudio</span>)</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data("data_ex_gstud")
str(data_ex_gstud)
length(unique(data_ex_gstud$POP))
</code></pre>

<hr>
<h2 id='data_ex_loci'>data_ex_loci genetic dataset</h2><span id='topic+data_ex_loci'></span>

<h3>Description</h3>

<p>Genetic dataset from genetic simulation on CDPOP
200 individuals, 10 populations
20 microsatellite loci (3 digits coding)
100 generations simulated
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_ex_loci
</code></pre>


<h3>Format</h3>

<p>An object of class 'loci' and 'data.frame' with the columns :
</p>

<dl>
<dt>population</dt><dd><p>Population name</p>
</dd>
<dt>Other columns</dt><dd><p>20 loci columns with microsatellite data with
3 digits coding, alleles separated by &quot;/&quot;, and missing data noted &quot;NA/NA&quot;</p>
</dd>
</dl>

<p>Row names correspond to individuals' ID
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("data_ex_loci")
length(unique(data_ex_loci$population))
</code></pre>

<hr>
<h2 id='data_simul_genind'>data_simul_genind genetic dataset</h2><span id='topic+data_simul_genind'></span>

<h3>Description</h3>

<p>Genetic dataset from genetic simulation on CDPOP
1500 individuals, 50 populations
20 microsatellite loci (3 digits coding)
50 generations simulated
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_simul_genind
</code></pre>


<h3>Format</h3>

<p>An object of type 'genind'
</p>


<h3>Details</h3>

<p>The simulation was made with CDPOP during 50 generations.
Dispersal was possible between the 50 populations. Its probability depended
on the cost distance between populations, calculated on a simulated
resistance surface (raster). Mutations were not possible. There
were initially 600 alleles in total (many disappeared because of drift).
Population stayed constant
with a sex-ratio of 1. Generations did not overlap.
This simulation includes a part of stochasticity and these data result
from only 1 simulation run.
</p>


<h3>References</h3>

<p>Landguth EL, Cushman SA (2010).
&ldquo;CDPOP: a spatially explicit cost distance population genetics program.&rdquo;
<em>Molecular Ecology Resources</em>, <b>10</b>(1), 156&ndash;161.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("data_simul_genind")
length(unique(data_simul_genind@pop))
</code></pre>

<hr>
<h2 id='data_tuto'>data_tuto : data used to generate the vignette</h2><span id='topic+data_tuto'></span>

<h3>Description</h3>

<p>Data used to generate the vignette
</p>
<p>Data used to generate the vignette
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_tuto

data_tuto
</code></pre>


<h3>Format</h3>

<p>Several outputs or inputs to show how the package works in a list
</p>

<dl>
<dt>mat_dps</dt><dd><p>Genetic distance matrix example</p>
</dd>
<dt>mat_pg</dt><dd><p>Second genetic distance matrix example</p>
</dd>
<dt>graph_ci</dt><dd><p>Genetic independence graph example</p>
</dd>
<dt>dmc</dt><dd><p>Output of the function 'dist_max_corr'</p>
</dd>
<dt>land_graph</dt><dd><p>Landscape graph example</p>
</dd>
<dt>mat_ld</dt><dd><p>Landscape distance matrix example</p>
</dd>
</dl>

<p>Several outputs or inputs to show how the package works in a list
</p>

<dl>
<dt>dmc</dt><dd><p>Output of the function 'dist_max_corr'</p>
</dd>
<dt>graph_ci</dt><dd><p>Genetic independence graph example</p>
</dd>
<dt>mat_dps</dt><dd><p>Genetic distance matrix example</p>
</dd>
<dt>mat_pg</dt><dd><p>Second genetic distance matrix example</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data("data_tuto")
mat_dps &lt;- data_tuto[[1]]
str(mat_dps)
data("data_tuto")
mat_dps &lt;- data_tuto[[1]]
str(mat_dps)
</code></pre>

<hr>
<h2 id='deg2rad'>Convert degrees to radians</h2><span id='topic+deg2rad'></span>

<h3>Description</h3>

<p>The function converts degree to radians
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deg2rad(deg)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deg2rad_+3A_deg">deg</code></td>
<td>
<p>A coordinate in degrees</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The coordinate in radians
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>deg2rad(40.75170)
</code></pre>

<hr>
<h2 id='df_to_pw_mat'>Convert an edge-list data.frame into a pairwise matrix</h2><span id='topic+df_to_pw_mat'></span>

<h3>Description</h3>

<p>The function converts an edge-list data.frame
into a symmetric pairwise matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df_to_pw_mat(data, from, to, value)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="df_to_pw_mat_+3A_data">data</code></td>
<td>
<p>An object of class <code>data.frame</code></p>
</td></tr>
<tr><td><code id="df_to_pw_mat_+3A_from">from</code></td>
<td>
<p>A character string indicating the name of the column with the ID
of the origins</p>
</td></tr>
<tr><td><code id="df_to_pw_mat_+3A_to">to</code></td>
<td>
<p>A character string indicating the name of the column with the ID
of the arrivals</p>
</td></tr>
<tr><td><code id="df_to_pw_mat_+3A_value">value</code></td>
<td>
<p>A character string indicating the name of the column with the
values corresponding to each pair</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The matrix is a symmetric matrix. Be careful, you shall not provide
a data.frame with different values corresponding to the pair 1-2 and 2-1 as
an example. Ideally, for a complete matrix, data should have n(n-1)/2 rows
if values are computed between n objects.
</p>


<h3>Value</h3>

<p>A pairwise matrix
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pts_pop_simul)
suppressWarnings(mat_geo &lt;- mat_geo_dist(pts_pop_simul,
                 ID = "ID",
                 x = "x",
                y = "y"))
g &lt;- gen_graph_topo(mat_w = mat_geo,
                    mat_topo = mat_geo,
                    topo = "comp")
df &lt;- data.frame(igraph::as_edgelist(g))
df$w &lt;- igraph::E(g)$weight
df_to_pw_mat(df, from = "X1", to = "X2", value = "w")
</code></pre>

<hr>
<h2 id='dist_gc_hvs'>Calculate the Great-Circle distance between two points using the
Harversine formula (hvs)</h2><span id='topic+dist_gc_hvs'></span>

<h3>Description</h3>

<p>The function calculates the Great-Circle distance between two
points specified by radian latitude/longitude using the
Harversine formula (hvs)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_gc_hvs(long1, lat1, long2, lat2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist_gc_hvs_+3A_long1">long1</code></td>
<td>
<p>Point 1 longitude in radians</p>
</td></tr>
<tr><td><code id="dist_gc_hvs_+3A_lat1">lat1</code></td>
<td>
<p>Point 1 latitude in radians</p>
</td></tr>
<tr><td><code id="dist_gc_hvs_+3A_long2">long2</code></td>
<td>
<p>Point 2 longitude in radians</p>
</td></tr>
<tr><td><code id="dist_gc_hvs_+3A_lat2">lat2</code></td>
<td>
<p>Point 2 latitude in radians</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The distance between points 1 and 2 in meters
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dist_gc_hvs(long1 = -73.99420, lat1 = 40.75170,
            long2 = -87.63940, lat2 = 41.87440)
</code></pre>

<hr>
<h2 id='dist_gc_slc'>Calculate the Great-Circle distance between two points using the
Spherical Law of Cosines (slc)</h2><span id='topic+dist_gc_slc'></span>

<h3>Description</h3>

<p>The function calculates the Great-Circle distance between two
points specified by radian latitude/longitude using the Spherical Law
of Cosines (slc)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_gc_slc(long1, lat1, long2, lat2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist_gc_slc_+3A_long1">long1</code></td>
<td>
<p>Point 1 longitude in radians</p>
</td></tr>
<tr><td><code id="dist_gc_slc_+3A_lat1">lat1</code></td>
<td>
<p>Point 1 latitude in radians</p>
</td></tr>
<tr><td><code id="dist_gc_slc_+3A_long2">long2</code></td>
<td>
<p>Point 2 longitude in radians</p>
</td></tr>
<tr><td><code id="dist_gc_slc_+3A_lat2">lat2</code></td>
<td>
<p>Point 2 latitude in radians</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The distance between points 1 and 2 in meters
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dist_gc_slc(long1 = -73.99420, lat1 = 40.75170,
            long2 = -87.63940, lat2 = 41.87440)
</code></pre>

<hr>
<h2 id='dist_gc_vicenty'>Calculate the Great-Circle distance between two points using the
Vincenty inverse formula for ellipsoids (vicenty)</h2><span id='topic+dist_gc_vicenty'></span>

<h3>Description</h3>

<p>The function calculates the Great-Circle distance between two
points specified by radian latitude/longitude using the
Vincenty inverse formula for ellipsoids (vicenty)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_gc_vicenty(long1, lat1, long2, lat2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist_gc_vicenty_+3A_long1">long1</code></td>
<td>
<p>Point 1 longitude in radians</p>
</td></tr>
<tr><td><code id="dist_gc_vicenty_+3A_lat1">lat1</code></td>
<td>
<p>Point 1 latitude in radians</p>
</td></tr>
<tr><td><code id="dist_gc_vicenty_+3A_long2">long2</code></td>
<td>
<p>Point 2 longitude in radians</p>
</td></tr>
<tr><td><code id="dist_gc_vicenty_+3A_lat2">lat2</code></td>
<td>
<p>Point 2 latitude in radians</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The distance between points 1 and 2 in meters
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dist_gc_vicenty(long1 = -73.99420, lat1 = 40.75170,
            long2 = -87.63940, lat2 = 41.87440)
</code></pre>

<hr>
<h2 id='dist_great_circle'>Compute the Great Circle distance between two points</h2><span id='topic+dist_great_circle'></span>

<h3>Description</h3>

<p>The function computes the Great Circle distance between two
two points defined by their longitudes and latitudes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_great_circle(long1, long2, lat1, lat2, method = "vicenty")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist_great_circle_+3A_long1">long1</code></td>
<td>
<p>project name, project dir in which proj_name.xml is found</p>
</td></tr>
<tr><td><code id="dist_great_circle_+3A_long2">long2</code></td>
<td>
<p>raster.tif INT2S path or present in wd,</p>
</td></tr>
<tr><td><code id="dist_great_circle_+3A_lat1">lat1</code></td>
<td>
<p>habitat code in the raster file</p>
</td></tr>
<tr><td><code id="dist_great_circle_+3A_lat2">lat2</code></td>
<td>
<p>default 0, minimum habitat size in ha</p>
</td></tr>
<tr><td><code id="dist_great_circle_+3A_method">method</code></td>
<td>
<p>default NULL nodata code in the raster file</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dist_great_circle(long1 = -73.99420,
                  lat1 = 40.75170,
                  long2 = -87.63940,
                  lat2 = 41.87440,
                  method = "vicenty")
</code></pre>

<hr>
<h2 id='dist_max_corr'>Compute the distance at which the correlation between genetic distance
and landscape distance is maximal</h2><span id='topic+dist_max_corr'></span>

<h3>Description</h3>

<p>The function enables to compute the distance at which the
correlation between genetic distance and landscape distance is maximal,
using a method similar to that employed by van Strien et al. (2015).
Iteratively, distance threshold values are tested. For each value, all the
population pairs separated by a landscape distance larger than the threshold
are removed before the Mantel correlation coefficient between genetic
distance and landscape distance is computed.
The distance threshold at which the correlation is the strongest is then
identified. A figure showing the evolution of the correlation coefficients
when landscape distance threshold increases is plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_max_corr(
  mat_gd,
  mat_ld,
  interv,
  from = NULL,
  to = NULL,
  fig = TRUE,
  thr_gd = NULL,
  line_col = "black",
  pts_col = "#999999"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist_max_corr_+3A_mat_gd">mat_gd</code></td>
<td>
<p>A symmetric <code>matrix</code> or <code>dist</code> object with pairwise
genetic distances between populations or sample sites.</p>
</td></tr>
<tr><td><code id="dist_max_corr_+3A_mat_ld">mat_ld</code></td>
<td>
<p>A symmetric <code>matrix</code> or <code>dist</code> object with pairwise
landscape distances between populations or sample sites. These distances
can be Euclidean distances, cost-distances or resistance distances,
among others.</p>
</td></tr>
<tr><td><code id="dist_max_corr_+3A_interv">interv</code></td>
<td>
<p>A numeric or integer value indicating the interval between
the different distance thresholds for which the correlation coefficients
are computed.</p>
</td></tr>
<tr><td><code id="dist_max_corr_+3A_from">from</code></td>
<td>
<p>(optional) The minimum distance threshold value at which the
correlation coefficient is computed.</p>
</td></tr>
<tr><td><code id="dist_max_corr_+3A_to">to</code></td>
<td>
<p>(optional) The maximum distance threshold value at which the
correlation coefficient is computed.</p>
</td></tr>
<tr><td><code id="dist_max_corr_+3A_fig">fig</code></td>
<td>
<p>Logical (default = TRUE) indicating whether a figure is plotted.</p>
</td></tr>
<tr><td><code id="dist_max_corr_+3A_thr_gd">thr_gd</code></td>
<td>
<p>(optional) A numeric or integer value used to remove
genetic distance values from the data before the calculation.
All genetic distances values above 'thr_gd' are removed from the data.
This parameter can be used especially when there are outliers.</p>
</td></tr>
<tr><td><code id="dist_max_corr_+3A_line_col">line_col</code></td>
<td>
<p>(optional, if fig = TRUE) A character string indicating the
color used to plot the line (default: &quot;blue&quot;). It must be a hexadecimal color
code or a color used by default in R.</p>
</td></tr>
<tr><td><code id="dist_max_corr_+3A_pts_col">pts_col</code></td>
<td>
<p>(optional, if fig = TRUE) A character string indicating the
color used to plot the points (default: &quot;#999999&quot;). It must be a hexadecimal
color code or a color used by default in R.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>IDs in 'mat_gd' and 'mat_ld' must be the same and refer to the same
sampling sites or populations, and both matrices must be ordered
in the same way.
The correlation coefficient between genetic distance and landscape distance
computed is a Mantel correlation coefficient. If there are less than 50
pairwise values, the correlation is not computed, as in
van Strien et al. (2015). Such a method can be subject to criticism from
a strict statistical point of view given correlation coefficients computed
from samples of different size are compared.
The matrix of genetic distance 'mat_gd' can be computed using
<code><a href="#topic+mat_gen_dist">mat_gen_dist</a></code>.
The matrix of landscape distance 'mat_ld' can be computed using
<code><a href="#topic+mat_geo_dist">mat_geo_dist</a></code> when the landscape distance needed is a
Euclidean geographical distance.
Mantel correlation coefficients are computed using
the function <code><a href="vegan.html#topic+mantel">mantel</a></code>.
</p>


<h3>Value</h3>

<p>A list of objects:
</p>

<ul>
<li><p>The distance at which the correlation is the highest.
</p>
</li>
<li><p>The vector of correlation coefficients at the different
distance thresholds
</p>
</li>
<li><p>The vector of the different distance thresholds
</p>
</li>
<li><p>A ggplot2 object to plot
</p>
</li></ul>



<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>References</h3>

<p>Van Strien MJ, Holderegger R, Van Heck HJ (2015).
&ldquo;Isolation-by-distance in landscapes: considerations for landscape genetics.&rdquo;
<em>Heredity</em>, <b>114</b>(1), 27.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("data_tuto")
mat_gen &lt;- data_tuto[[1]]
mat_dist &lt;- data_tuto[[2]]*1000
res_dmc &lt;- dist_max_corr(mat_gd = mat_gen,
                         mat_ld = mat_dist,
                         from = 32000, to = 42000,
                         interv = 5000,
                         fig = FALSE)
</code></pre>

<hr>
<h2 id='g_percol'>Prune a graph using the 'percolation threshold' method</h2><span id='topic+g_percol'></span>

<h3>Description</h3>

<p>The function allows to prune a graph by removing
the links with the largest weights until the graph breaks into
two components. The returned graph is the last graph with only one
component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g_percol(x, val_step = 20)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="g_percol_+3A_x">x</code></td>
<td>
<p>A symmetric <code>matrix</code> or a <code>dist</code> object with pairwise
distances between nodes</p>
</td></tr>
<tr><td><code id="g_percol_+3A_val_step">val_step</code></td>
<td>
<p>The number of classes to create to search for the
threshold value without testing all the possibilities. By default,
'val_step = 20'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A graph object of type <code>igraph</code>
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(data_ex_genind)
suppressWarnings(mat_w &lt;- graph4lg::mat_geo_dist(data = pts_pop_ex,
                            ID = "ID",
                            x = "x",
                            y = "y"))
g_percol(x = mat_w)
</code></pre>

<hr>
<h2 id='gen_graph_indep'>Create an independence graph of genetic differentiation
from genetic data of class genind</h2><span id='topic+gen_graph_indep'></span>

<h3>Description</h3>

<p>The function allows to create genetic graphs from genetic data
by applying the conditional independence principle. Populations whose allelic
frequencies covary significantly once the covariance with the other
populations has been taken into account are linked on the graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_graph_indep(
  x,
  dist = "basic",
  cov = "sq",
  pcor = "magwene",
  alpha = 0.05,
  test = "EED",
  adj = "none",
  output = "igraph"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gen_graph_indep_+3A_x">x</code></td>
<td>
<p>An object of class <code>genind</code> that contains the multilocus
genotype (format 'locus') of the individuals as well as their population
and their geographical coordinates.</p>
</td></tr>
<tr><td><code id="gen_graph_indep_+3A_dist">dist</code></td>
<td>
<p>A character string indicating the method used to compute the
multilocus genetic distance between populations
</p>

<ul>
<li><p>If 'dist = 'basic&rdquo; (default), then the multilocus genetic distance is
computed using a Euclidean genetic distance formula (Excoffier et al., 1992)
</p>
</li>
<li><p>If 'dist = 'weight&rdquo;, then the multilocus genetic distance is computed
as in Fortuna et al. (2009). It is a Euclidean genetic distance giving more
weight to rare alleles
</p>
</li>
<li><p>If 'dist = 'PG&rdquo;, then the multilocus genetic distance is computed as
in popgraph::popgraph function, following several steps of PCA and SVD
(Dyer et Nason, 2004).
</p>
</li>
<li><p>If 'dist = 'PCA&rdquo;, then the genetic distance is computed following a
PCA of the matrix of allelic frequencies by population. It is a Euclidean
genetic distance between populations in the multidimensional space defined
by all the independent principal components.
</p>
</li></ul>
</td></tr>
<tr><td><code id="gen_graph_indep_+3A_cov">cov</code></td>
<td>
<p>A character string indicating the formula used to compute the
covariance matrix from the distance matrix
</p>

<ul>
<li><p>If 'cov = 'sq&rdquo; (default), then the covariance matrix is calculated
from the matrix of squared distances as in Everitt et Hothorn (2011)
</p>
</li>
<li><p>If 'cov = 'dist&rdquo;, then the covariance matrix is calculated from the
matrix of distances as in Dyer et Nason (2004) and popgraph function
</p>
</li></ul>
</td></tr>
<tr><td><code id="gen_graph_indep_+3A_pcor">pcor</code></td>
<td>
<p>A character string indicating the way the partial correlation
matrix is computed from the covariance matrix.
</p>

<ul>
<li><p>If 'pcor = 'magwene&rdquo;, the steps followed are the same as in
Magwene (2001) and in popgraph::popgraph function. It is the recommended
option as it meets mathematical requirements.
</p>
</li>
<li><p>If 'pcor = 'other&rdquo;, the steps followed are the same as used
by Fortuna et al. (2009). They are not consistent with the approach
of Magwene (2001).
</p>
</li></ul>
</td></tr>
<tr><td><code id="gen_graph_indep_+3A_alpha">alpha</code></td>
<td>
<p>A numeric value corresponding to the statistical tolerance
threshold used to test the difference from 0 of the partial correlation
coefficients. By default, 'alpha=0.05'.</p>
</td></tr>
<tr><td><code id="gen_graph_indep_+3A_test">test</code></td>
<td>
<p>A character string indicating the method used to test the
significance of the partial correlation coefficients.
</p>

<ul>
<li><p>If 'test = 'EED&rdquo; (default), then the Edge Exclusion Deviance
criterion is used (Whittaker, 2009). Although other methods exist, this is
the most common and thus the only one implemented here.
</p>
</li></ul>
</td></tr>
<tr><td><code id="gen_graph_indep_+3A_adj">adj</code></td>
<td>
<p>A character string indicating the way of adjusting p-values to
assess the significance of the p-values
</p>

<ul>
<li><p>If 'adj = 'none&rdquo; (default), there is no p-value adjustment correction
</p>
</li>
<li><p>If 'adj = 'holm&rdquo;, p-values are adjusted using the sequential
Bonferroni correction (Holm, 1979)
</p>
</li>
<li><p>If 'adj = 'bonferroni&rdquo;, p-values are adjusted using the classic
Bonferroni correction
</p>
</li>
<li><p>If 'adj = 'BH&rdquo;, p-values are adjusted using Benjamini et Hochberg
(1995) correction controlling false discovery rate
</p>
</li></ul>
</td></tr>
<tr><td><code id="gen_graph_indep_+3A_output">output</code></td>
<td>
<p>A character string indicating the matrices included in
the output list.
</p>

<ul>
<li><p>If 'output = 'all&rdquo; (default), then D (distance matrix),
C (covariance matrix), Rho (partial correlation matrix),
M (graph incidence matrix) and S (strength matrix) are included
</p>
</li>
<li><p>If 'output = 'dist_graph&rdquo;, then the distance matrix D is returned
only with the values corresponding to the graph edges
</p>
</li>
<li><p>If 'output = 'str_graph&rdquo;, then the strength values matrix S is
returned only with the values corresponding to the graph edges
</p>
</li>
<li><p>If 'output = 'inc&rdquo;, then the binary adjacency matrix M is returned
</p>
</li>
<li><p>If 'output = 'igraph&rdquo;, then a graph of class <code>igraph</code>
is returned
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The function allows to vary many parameters such as the genetic
distance used, the formula used to compute the covariance, the statistical
tolerance threshold, the p-values adjustment, among others.
</p>


<h3>Value</h3>

<p>A <code>list</code> of objects of class <code>matrix</code>, an object of
class <code>matrix</code> or a graph object of class <code>igraph</code>
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>References</h3>

<p>Dyer RJ, Nason JD (2004).
&ldquo;Population graphs: the graph theoretic shape of genetic structure.&rdquo;
<em>Molecular ecology</em>, <b>13</b>(7), 1713&ndash;1727.
Benjamini Y, Hochberg Y (1995).
&ldquo;Controlling the false discovery rate: a practical and powerful approach to multiple testing.&rdquo;
<em>Journal of the royal statistical society. Series B (Methodological)</em>, 289&ndash;300.
Bowcock AM, Ruiz-Linares A, Tomfohrde J, Minch E, Kidd JR, Cavalli-Sforza LL (1994).
&ldquo;High resolution of human evolutionary trees with polymorphic microsatellites.&rdquo;
<em>nature</em>, <b>368</b>(6470), 455&ndash;457.
Everitt B, Hothorn T (2011).
<em>An introduction to applied multivariate analysis with R</em>.
Springer.
Excoffier L, Smouse PE, Quattro JM (1992).
&ldquo;Analysis of molecular variance inferred from metric distances among DNA haplotypes: application to human mitochondrial DNA restriction data.&rdquo;
<em>Genetics</em>, <b>131</b>(2), 479&ndash;491.
Fortuna MA, Albaladejo RG, FernÃ¡ndez L, Aparicio A, Bascompte J (2009).
&ldquo;Networks of spatial genetic variation across species.&rdquo;
<em>Proceedings of the National Academy of Sciences</em>, <b>106</b>(45), 19044&ndash;19049.
Holm S (1979).
&ldquo;A simple sequentially rejective multiple test procedure.&rdquo;
<em>Scandinavian journal of statistics</em>, 65&ndash;70.
Magwene PM (2001).
&ldquo;New tools for studying integration and modularity.&rdquo;
<em>Evolution</em>, <b>55</b>(9), 1734&ndash;1745.
Wermuth N, Scheidt E (1977).
&ldquo;Algorithm AS 105: fitting a covariance selection model to a matrix.&rdquo;
<em>Journal of the Royal Statistical Society. Series C (Applied Statistics)</em>, <b>26</b>(1), 88&ndash;92.
Whittaker J (2009).
<em>Graphical models in applied multivariate statistics</em>.
Wiley Publishing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(data_ex_genind)
dist_graph_test &lt;- gen_graph_indep(x = data_ex_genind, dist = "basic",
                             cov = "sq", pcor = "magwene",
                             alpha = 0.05, test = "EED",
                             adj = "none", output = "igraph")
</code></pre>

<hr>
<h2 id='gen_graph_thr'>Create a graph of genetic differentiation
using a link weight threshold</h2><span id='topic+gen_graph_thr'></span>

<h3>Description</h3>

<p>The function allows to construct a genetic graph whose
links' weights are larger or lower than a specific threshold
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_graph_thr(mat_w, mat_thr = NULL, thr, mode = "larger")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gen_graph_thr_+3A_mat_w">mat_w</code></td>
<td>
<p>A symmetric (pairwise) <code>matrix</code> or a <code>dist</code> object
whose elements will be the links' weights</p>
</td></tr>
<tr><td><code id="gen_graph_thr_+3A_mat_thr">mat_thr</code></td>
<td>
<p>(optional) A symmetric (pairwise) distance <code>matrix</code>
or a <code>dist</code> object whose values will be used for the pruning based
on the threshold value.</p>
</td></tr>
<tr><td><code id="gen_graph_thr_+3A_thr">thr</code></td>
<td>
<p>The threshold value (logically between min(mat_thr)
and max(mat_thr))(integer or numeric)</p>
</td></tr>
<tr><td><code id="gen_graph_thr_+3A_mode">mode</code></td>
<td>

<ul>
<li><p>If 'mode = 'larger&rdquo; (default), all the links whose weight is larger
than 'thr' are removed.
</p>
</li>
<li><p>If 'mode = 'lower&rdquo;, all the links whose weight is lower
than 'thr' are removed.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>If 'mat_thr' is not defined, 'mat_w' is used for the pruning.
Matrices 'mat_w' and 'mat_thr' must have the same dimensions and the
same rows' and columns' names.
Values in 'mat_thr' matrix must be positive. Negative values from
'mat_w' are transformed into zeros.
The function works only for undirected graphs.
If dist objects are specified, it is assumed that colnames and
row.names of mat_w and mat_thr refer to the same populations/locations.
</p>


<h3>Value</h3>

<p>A graph object of class <code>igraph</code>
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat_w &lt;- mat_gen_dist(x = data_ex_genind, dist = 'DPS')
suppressWarnings(mat_thr &lt;- mat_geo_dist(pts_pop_ex,
                 ID = "ID",
                 x = "x",
                y = "y"))
mat_thr &lt;- mat_thr[row.names(mat_w), colnames(mat_w)]
graph &lt;- gen_graph_thr(mat_w, mat_thr, thr = 6000, mode = "larger")
</code></pre>

<hr>
<h2 id='gen_graph_topo'>Create a graph of genetic differentiation with
a specific topology</h2><span id='topic+gen_graph_topo'></span>

<h3>Description</h3>

<p>The function constructs a genetic graph with
a specific topology from genetic and/or geographical distance matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_graph_topo(mat_w, mat_topo = NULL, topo = "gabriel", k = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gen_graph_topo_+3A_mat_w">mat_w</code></td>
<td>
<p>A symmetric (pairwise) <code>matrix</code> or a <code>dist</code> object
whose elements will be the links' weights</p>
</td></tr>
<tr><td><code id="gen_graph_topo_+3A_mat_topo">mat_topo</code></td>
<td>
<p>(optional) A symmetric (pairwise) distance <code>matrix</code>
or a <code>dist</code> object whose values will be used for the pruning method.</p>
</td></tr>
<tr><td><code id="gen_graph_topo_+3A_topo">topo</code></td>
<td>
<p>Which topology does the created graph have?
</p>

<ul>
<li><p>If 'topo = 'gabriel&rdquo; (default), the resulting graph will be a
Gabriel graph (Gabriel et al., 1969). It means that there is a link
between nodes x and y if and only if
<code class="reqn">d_{xy}^{2} \leq \min(\sqrt{d_{xz}^{2}+d_{yz}^{2}}) </code>,
with z any other node of the graph.
</p>
</li>
<li><p>If 'topo = 'mst&rdquo;, the resulting graph will have the topology
of a minimum spanning tree. It means that the graph will not include
any cycle (tree) and it will be the subgraph with a tree topology with
the minimum total links' weight (based on 'mat_topo' values).
</p>
</li>
<li><p>If 'topo = 'percol&rdquo;, if the link of the resulting graph with the
minimum weight is removed, then the graph breaks into two components.
</p>
</li>
<li><p>If 'topo = 'comp&rdquo;, a complete graph whose links are weighted with
values from 'mat_w' is created.
</p>
</li>
<li><p>If 'topo = 'knn&rdquo;, a k-nearest neighbor graph  whose links are
weighted with values from 'mat_w' is created. If the distance between node i
and node j is among the k-th smallest distances between node i and the other
nodes according to distances in matrix 'mat_topo', then there is a link
between i and j in the resulting graph. Therefore, a node can be connected
to more than two nodes because the nearest node to node j is not necessarily
among the k nearest neighbors to node i. Let d1 be the smallest distance
from node i to other nodes, if there are k nodes or more at this distance
from node i, they are all connected to i. If there are less than k nodes
connected to i at a distance d1, then we consider nodes at a distance d2
from i. In the latter case, all the nodes at a distance d2 from i are
connected to i.
</p>
</li></ul>
</td></tr>
<tr><td><code id="gen_graph_topo_+3A_k">k</code></td>
<td>
<p>(if 'topo = 'knn&rdquo;) An integer which indicates the number of
nearest neighbors considered to create the K-nearest neighbor graph. k must
be lower than the total number of nodes minus 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If 'mat_topo' is not defined, 'mat_w' is used for the pruning.
Matrices 'mat_w' and 'mat_topo' must have the same dimensions and the
same rows' and columns' names.
Values in 'mat_topo' matrix must be positive. Negative values from
'mat_w' are transformed into zeros.
The function works only for undirected graphs.
Note that the topology 'knn' works best when 'mat_topo' contains distance
values from a continuous value range, thereby avoiding equal distances
between a node and the others.  are more than k nodes located
at distances in the k-th smallest distances
If dist objects are specified, it is assumed that colnames and
row.names of mat_w and mat_topo refer to the same populations/locations.
</p>


<h3>Value</h3>

<p>A graph object of class <code>igraph</code>
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>References</h3>

<p>Gabriel KR, Sokal RR (1969).
&ldquo;A new statistical approach to geographic variation analysis.&rdquo;
<em>Systematic zoology</em>, <b>18</b>(3), 259&ndash;278.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat_w &lt;- mat_gen_dist(x = data_ex_genind, dist = 'DPS')
suppressWarnings(mat_topo &lt;- mat_geo_dist(pts_pop_ex,
                 ID = "ID",
                 x = "x",
                y = "y"))
mat_topo &lt;- mat_topo[row.names(mat_w), colnames(mat_w)]
graph &lt;- gen_graph_topo(mat_w, mat_topo, topo = "mst")
</code></pre>

<hr>
<h2 id='genepop_to_genind'>Convert a GENEPOP file into a genind object</h2><span id='topic+genepop_to_genind'></span>

<h3>Description</h3>

<p>The function converts a text file in the format used by GENEPOP
software into a genind object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genepop_to_genind(path, n.loci, pop_names = NULL, allele.digit.coding = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genepop_to_genind_+3A_path">path</code></td>
<td>
<p>A character string with the path leading to the GENEPOP file
in format .txt, or alternatively the name of this file in the working
directory.</p>
</td></tr>
<tr><td><code id="genepop_to_genind_+3A_n.loci">n.loci</code></td>
<td>
<p>The number of loci in the GENEPOP file (integer or numeric).</p>
</td></tr>
<tr><td><code id="genepop_to_genind_+3A_pop_names">pop_names</code></td>
<td>
<p>(optional) Populations' names in the same order
as in the GENEPOP file.
Vector object (class character) of the same length as the number
of populations.
Without this parameter, populations are numbered from 1 to the number
of populations.</p>
</td></tr>
<tr><td><code id="genepop_to_genind_+3A_allele.digit.coding">allele.digit.coding</code></td>
<td>
<p>Number indicating whether alleles are coded
with 3 (default) or 2 digits.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses functions from <span class="pkg">pegas</span> package.
GENEPOP file should can include microsatellites loci or SNPs with allele names
of length 2 or 3 (noted as 01, 02, 03 or 04 for SNPs).
The loci line(s) must not start with a spacing.
</p>


<h3>Value</h3>

<p>An object of type <code>genind</code>.
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>References</h3>

<p>Raymond M (1995).
&ldquo;GENEPOP: Population genetics software for exact tests and ecumenism. Vers. 1.2.&rdquo;
<em>Journal of Heredity</em>, <b>86</b>, 248&ndash;249.
</p>


<h3>See Also</h3>

<p>For more details about GENEPOP file formatting :
<a href="https://genepop.curtin.edu.au:443/help_input.html">https://genepop.curtin.edu.au:443/help_input.html</a>
For the opposite conversion, see <code><a href="#topic+genind_to_genepop">genind_to_genepop</a></code>.
The output file can be used to compute pairwise FST matrix
with <code><a href="#topic+mat_pw_fst">mat_pw_fst</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path_in &lt;- system.file('extdata', 'gpop_simul_10_g100_04_20.txt',
                       package = 'graph4lg')
file_n &lt;- file.path(tempdir(), "gpop_simul_10_g100_04_20.txt")
file.copy(path_in, file_n, overwrite = TRUE)
genepop_to_genind(path = file_n, n.loci = 20,
                  pop_names = as.character(order(as.character(1:10))))
file.remove(file_n)
</code></pre>

<hr>
<h2 id='genind_to_genepop'>Convert a genind object into a GENEPOP file</h2><span id='topic+genind_to_genepop'></span>

<h3>Description</h3>

<p>The function converts an object of class <code>genind</code> into
a GENEPOP file.
It then allows to use the functionalities of the GENEPOP software and
its derived package <span class="pkg">GENEPOP</span> on R, as well as some functions
from other packages (differentiation test, F-stats calculations,
HWE test,...).
It is designed to be used with diploid microsatellite data with
alleles coded with 2 or 3 digits or SNPs genind objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genind_to_genepop(x, output = "data.frame")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genind_to_genepop_+3A_x">x</code></td>
<td>
<p>An object of class <code>genind</code>
from package <span class="pkg">adegenet</span>.</p>
</td></tr>
<tr><td><code id="genind_to_genepop_+3A_output">output</code></td>
<td>
<p>A character string indicating the option used to select what
the function will return:
</p>

<ul>
<li><p>If <code>output = "data.frame"</code>(default), then the function will
return an object 'x' of class <code>data.frame</code> ready to be saved as a
text file with the following command:
<code>write.table(x, file = "file_name.txt", quote=FALSE,
row.names=FALSE, col.names=FALSE)</code>
</p>
</li>
<li><p>If <code>output = "path_to_file/file_name.txt"</code>, then the function
will write a text file named 'file_name.txt' in the directory corresponding
to 'path_to_file'. Without 'path_to_file', the text file is written in the
current working directory. The text file has the format required by GENEPOP
software.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of type <code>data.frame</code> if <code>ouput = "data.frame"</code>.
If <code>output</code> is the path and/or the file name of a text file, then
nothing is returned in R environment but a text file is created with the
specified file name, either in the current working directory or in the
specified folder.
</p>


<h3>Warning</h3>



<h4>Confusion</h4>

<p>Do not confound this function with <code><a href="adegenet.html#topic+genind2genpop">genind2genpop</a></code>
from <span class="pkg">adegenet</span>. The latter converts an object of class <code>genind</code>
into an object of class <code>genpop</code>, whereas <code>genind_to_genepop</code>
converts an object of class <code>genind</code> into a text file compatible with
GENEPOP software (Rousset, 2008).
</p>



<h4>Allele coding</h4>

<p>This function can handle genetic data with different allele coding: 2 or 3
digit coding for microsatellite data or 2 digit coding for SNPs (A,C,T,G
become respectively 01, 02, 03, 04).
</p>



<h4>Individuals order</h4>

<p>When individuals in input data are not ordered by populations, individuals
from the same population can be separated by individuals from other
populations. It can be problematic when calculating then pairwise distance
matrices. Therefore, in such a case, individuals are ordered by populations
and populations ordered in alphabetic order.
</p>



<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>References</h3>

<p>Raymond M (1995).
&ldquo;GENEPOP: Population genetics software for exact tests and ecumenism. Vers. 1.2.&rdquo;
<em>Journal of Heredity</em>, <b>86</b>, 248&ndash;249.
</p>


<h3>See Also</h3>

<p>For more details about GENEPOP file formatting :
<a href="https://genepop.curtin.edu.au:443/help_input.html">https://genepop.curtin.edu.au:443/help_input.html</a>.
For the opposite conversion, see <code><a href="#topic+genepop_to_genind">genepop_to_genind</a></code>.
The output file can be used to compute pairwise FST matrix
with <code><a href="#topic+mat_pw_fst">mat_pw_fst</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(data_ex_genind)
x &lt;- data_ex_genind
df_genepop &lt;- suppressWarnings(genind_to_genepop(x,
                                                 output = "data.frame"))
</code></pre>

<hr>
<h2 id='genind_to_structure'>Convert a genind object into a STRUCTURE file</h2><span id='topic+genind_to_structure'></span>

<h3>Description</h3>

<p>The function converts an object of class <code>genind</code> into
a STRUCTURE file.
It is designed to be used with diploid microsatellite data with
alleles coded with 2 or 3 digits or SNPs genind objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genind_to_structure(x, output = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genind_to_structure_+3A_x">x</code></td>
<td>
<p>An object of class <code>genind</code>
from package <span class="pkg">adegenet</span>.</p>
</td></tr>
<tr><td><code id="genind_to_structure_+3A_output">output</code></td>
<td>
<p>A character string of the form 
<code>output = "path_to_file/file_name.txt"</code>. Then, the function
will write a text file named 'file_name.txt' in the directory corresponding
to 'path_to_file'. Without 'path_to_file', the text file is written in the
current working directory. The text file has the format required by STRUCTURE
software.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>output</code> is the path and/or the file name of a text file, 
then nothing is returned in R environment but a text file is created with 
the specified file name, either in the current working directory or in the
specified folder.
</p>


<h3>Warning</h3>



<h4>Allele coding</h4>

<p>This function can handle genetic data with different allele coding: 2 or 3
digit coding for microsatellite data or 2 digit coding for SNPs (A,C,T,G
become respectively 01, 02, 03, 04).
</p>



<h4>Individuals order</h4>

<p>When individuals in input data are not ordered by populations, individuals
from the same population can be separated by individuals from other
populations. It can be problematic when calculating then pairwise distance
matrices. Therefore, in such a case, individuals are ordered by populations
and populations ordered in alphabetic order.
</p>



<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(data_ex_genind)
x &lt;- data_ex_genind
genind_to_structure(x,
                    output = tempfile(fileext = ".txt"))
</code></pre>

<hr>
<h2 id='get_graphab'>Download Graphab if not present on the user's machine</h2><span id='topic+get_graphab'></span>

<h3>Description</h3>

<p>The function checks for the presence of Graphab (.jar) on the
user's machine and downloads it if absent. It also checks that users have
installed java on their machine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_graphab(res = TRUE, return = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_graphab_+3A_res">res</code></td>
<td>
<p>Logical indicating whether a message says if Graphab has been
downloaded or not.</p>
</td></tr>
<tr><td><code id="get_graphab_+3A_return">return</code></td>
<td>
<p>Logical indicating whether the function returns a 1 or a 0
to indicate if Graphab has been downloaded or not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the download does not work, you can create a directory named
'graph4lg_jar' in the directory <code>rappdirs::user_data_dir()</code> and copy
Graphab software downloaded from
<a href="https://thema.univ-fcomte.fr/productions/download.php?name=graphab&amp;version=2.8&amp;username=Graph4lg&amp;institution=R">https://thema.univ-fcomte.fr/productions/download.php?name=graphab&amp;version=2.8&amp;username=Graph4lg&amp;institution=R</a>
</p>


<h3>Value</h3>

<p>If res = TRUE, the function displays a message indicating to users
what has been done.
If return = TRUE, it returns a 0 if Graphab is already on the machine and
a 1 if it has been downloaded.
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
get_graphab()

## End(Not run)
</code></pre>

<hr>
<h2 id='get_graphab_linkset'>Get linkset computed in the Graphab project</h2><span id='topic+get_graphab_linkset'></span>

<h3>Description</h3>

<p>The function gets a linkset computed in the Graphab project
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_graphab_linkset(proj_name, linkset, proj_path = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_graphab_linkset_+3A_proj_name">proj_name</code></td>
<td>
<p>A character string indicating the Graphab project name.
The project name is also the name of the project directory in which the
file proj_name.xml is.</p>
</td></tr>
<tr><td><code id="get_graphab_linkset_+3A_linkset">linkset</code></td>
<td>
<p>A character string indicating the name of the link set
whose properties are imported. The link set has been created with Graphab
or using <code><a href="#topic+graphab_link">graphab_link</a></code> function.</p>
</td></tr>
<tr><td><code id="get_graphab_linkset_+3A_proj_path">proj_path</code></td>
<td>
<p>(optional) A character string indicating the path to the
directory that contains the project directory. It should be used when the
project directory is not in the current working directory. Default is NULL.
When 'proj_path = NULL', the project directory is equal to <code>getwd()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See more information in Graphab 2.8 manual:
<a href="https://sourcesup.renater.fr/www/graphab/download/manual-2.8-en.pdf">https://sourcesup.renater.fr/www/graphab/download/manual-2.8-en.pdf</a>.
This function works if <code>link{get_graphab}</code> function works correctly.
</p>


<h3>Value</h3>

<p>A data.frame with the link properties (from, to, cost-distance,
Euclidean distance)
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
get_graphab_linkset(proj_name = "grphb_ex",
               linkset = "lkst1")

## End(Not run)
</code></pre>

<hr>
<h2 id='get_graphab_linkset_cost'>Get cost values associated with a linkset in a Graphab project</h2><span id='topic+get_graphab_linkset_cost'></span>

<h3>Description</h3>

<p>The function extracts the cost values associated with a
linkset in a Graphab project
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_graphab_linkset_cost(proj_name, linkset, proj_path = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_graphab_linkset_cost_+3A_proj_name">proj_name</code></td>
<td>
<p>A character string indicating the Graphab project name.
The project name is also the name of the project directory in which the
file proj_name.xml will be created.</p>
</td></tr>
<tr><td><code id="get_graphab_linkset_cost_+3A_linkset">linkset</code></td>
<td>
<p>(optional, default=NULL) A character string indicating the
name of the link set used to create the graph. Link sets can be created
with <code><a href="#topic+graphab_link">graphab_link</a></code>.</p>
</td></tr>
<tr><td><code id="get_graphab_linkset_cost_+3A_proj_path">proj_path</code></td>
<td>
<p>(optional) A character string indicating the path to the
directory that contains the project directory. It should be used when the
project directory is not in the current working directory. Default is NULL.
When 'proj_path = NULL', the project directory is equal to <code>getwd()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a data.frame with the cost values corresponding
to every raster code value.
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
proj_name &lt;- "grphb_ex"
get_graphab_linkset_cost(proj_name = proj_name,
               linkset = "lkst1")

## End(Not run)
</code></pre>

<hr>
<h2 id='get_graphab_metric'>Get metrics computed at the node in the Graphab project</h2><span id='topic+get_graphab_metric'></span>

<h3>Description</h3>

<p>The function gets the metrics computed at the node-level in
the Graphab project
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_graphab_metric(proj_name, proj_path = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_graphab_metric_+3A_proj_name">proj_name</code></td>
<td>
<p>A character string indicating the Graphab project name.
The project name is also the name of the project directory in which the
file proj_name.xml is.</p>
</td></tr>
<tr><td><code id="get_graphab_metric_+3A_proj_path">proj_path</code></td>
<td>
<p>(optional) A character string indicating the path to the
directory that contains the project directory. It should be used when the
project directory is not in the current working directory. Default is NULL.
When 'proj_path = NULL', the project directory is equal to <code>getwd()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The imported metrics describe the patches and have been computed
from the different graphs created in the Graphab project.
See more information in Graphab 2.8 manual:
<a href="https://sourcesup.renater.fr/www/graphab/download/manual-2.8-en.pdf">https://sourcesup.renater.fr/www/graphab/download/manual-2.8-en.pdf</a>
</p>


<h3>Value</h3>

<p>A data.frame with metrics computed at the patch level.
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
get_graphab_metric(proj_name = "grphb_ex")

## End(Not run)
</code></pre>

<hr>
<h2 id='get_graphab_raster_codes'>Get unique raster codes from a Graphab project</h2><span id='topic+get_graphab_raster_codes'></span>

<h3>Description</h3>

<p>The function extracts unique raster codes from a Graphab project
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_graphab_raster_codes(proj_name, mode = "all", proj_path = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_graphab_raster_codes_+3A_proj_name">proj_name</code></td>
<td>
<p>A character string indicating the Graphab project name.
The project name is also the name of the project directory in which the
file proj_name.xml will be created.</p>
</td></tr>
<tr><td><code id="get_graphab_raster_codes_+3A_mode">mode</code></td>
<td>
<p>A character string equal to either 'all' (default) or 'habitat'
indicating whether the returned codes are all the codes of the source raster
used for creating the project or only the code corresponding to the
habitat patches.</p>
</td></tr>
<tr><td><code id="get_graphab_raster_codes_+3A_proj_path">proj_path</code></td>
<td>
<p>(optional) A character string indicating the path to the
directory that contains the project directory. It should be used when the
project directory is not in the current working directory. Default is NULL.
When 'proj_path = NULL', the project directory is equal to <code>getwd()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a vector of integer values corresponding to
the source raster codes (all the codes or only the one corresponding to
habitat patches).
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
proj_name &lt;- "grphb_ex"
get_graphab_raster_codes(proj_name = proj_name,
               mode = "all")

## End(Not run)
</code></pre>

<hr>
<h2 id='gini_coeff'>Compute Gini coefficient from a numeric vector</h2><span id='topic+gini_coeff'></span>

<h3>Description</h3>

<p>The function computes Gini coefficient from a numeric vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gini_coeff(x, unbiased = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gini_coeff_+3A_x">x</code></td>
<td>
<p>A numeric vector with positive values</p>
</td></tr>
<tr><td><code id="gini_coeff_+3A_unbiased">unbiased</code></td>
<td>
<p>A logical value indicating whether the computed coefficient
is biased or not. Unbiased value are equal to n/(n-1) times the biased ones.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value corresponding to the Gini coefficient of the numeric
vector
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(10, 2, 5, 15)
gini &lt;- gini_coeff(x)
</code></pre>

<hr>
<h2 id='graph_modul_compar'>Compare the partition into modules of two graphs</h2><span id='topic+graph_modul_compar'></span>

<h3>Description</h3>

<p>The function computes the Adjusted Rand Index (ARI) to
compare two graphs' partitions into modules or clusters more generally.
Both graphs must have the same number of nodes, but not necessarily the same
number of links. They must also have the same node names and in the
same order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_modul_compar(
  x,
  y,
  mode = "graph",
  nb_modul = NULL,
  algo = "fast_greedy",
  node_inter = "distance",
  data = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph_modul_compar_+3A_x">x</code></td>
<td>
<p>The first graph object
</p>

<ul>
<li><p>If <code>mode = 'graph'</code> (default), <code>x</code> is a graph object of
class <code>igraph</code>.
Then, its nodes must have the same names as in graph <code>y</code>.
</p>
</li>
<li><p>If <code>mode = 'data.frame'</code>, <code>x</code> refers to a column of
the <code>data.frame</code> 'data'.
Then <code>x</code> must be a character string indicating the name of the
column of 'data' with the modules' labels of the nodes in the first graph.
In that case, the column can be of class <code>numeric</code>, <code>character</code>
or <code>factor</code> but will be converted into a <code>numeric</code> vector
in any case.
</p>
</li>
<li><p>If <code>mode = 'vector'</code>, <code>x</code> is a vector of
class <code>character</code>, <code>factor</code> or <code>numeric</code>.
In that case, it must have the same length as vector <code>y</code> and
will be converted into a <code>numeric</code> vector.
</p>
</li></ul>
</td></tr>
<tr><td><code id="graph_modul_compar_+3A_y">y</code></td>
<td>
<p>The second graph object
Same classes possible as for <code>x</code>. Must be of the same format as <code>x</code></p>
</td></tr>
<tr><td><code id="graph_modul_compar_+3A_mode">mode</code></td>
<td>
<p>A character string indicating whether x and y are igraph objects,
vectors or columns from a data.frame. <code>mode</code> can be 'graph',
'data.frame' or 'vector'.</p>
</td></tr>
<tr><td><code id="graph_modul_compar_+3A_nb_modul">nb_modul</code></td>
<td>
<p>(if x and y are igraph objects) A numeric or integer value
or a numeric vector with 2 elements indicating the number of modules to
create in both graphs.
</p>

<ul>
<li><p>If <code>nb_modul</code> is a numeric value, then the same number of modules
are created in both graphs.
</p>
</li>
<li><p>If <code>nb_modul</code> is a numeric vector of length 2, then the
numbers of modules created in graphs <code>x</code> and <code>y</code> are the
first and second elements of <code>nb_modul</code>, respectively.
</p>
</li></ul>
</td></tr>
<tr><td><code id="graph_modul_compar_+3A_algo">algo</code></td>
<td>
<p>(if x and y are igraph objects) A character string indicating the
algorithm used to create the modules with <span class="pkg">igraph</span>.
</p>

<ul>
<li><p>If <code>algo = 'fast_greedy'</code> (default),
function <code>cluster_fast_greedy</code>
from <span class="pkg">igraph</span> is used (Clauset et al., 2004).
</p>
</li>
<li><p>If <code>algo = 'walktrap'</code> (default), function <code>cluster_walktrap</code>
from <span class="pkg">igraph</span> is used (Pons et Latapy, 2006) with
4 steps (default options).
</p>
</li>
<li><p>If <code>algo = 'louvain'</code>, function <code>cluster_louvain</code>
from <span class="pkg">igraph</span> is used (Blondel et al., 2008).
In that case, the number of modules created in each graph is imposed.
</p>
</li>
<li><p>If <code>algo = 'optimal'</code>, function <code>cluster_optimal</code>
from <span class="pkg">igraph</span> is used (Brandes et al., 2008) (can be very long).
In that case, the number of modules created in each graph is imposed.
</p>
</li></ul>
</td></tr>
<tr><td><code id="graph_modul_compar_+3A_node_inter">node_inter</code></td>
<td>
<p>(optional, if x and y are igraph objects,
default is 'none') A character string indicating whether the links of the
graph are weighted by distances or by similarity indices. It is only used
to compute the modularity index. It can be: </p>

<ul>
<li><p>'distance': Link weights correspond to distances. Nodes that are close
to each other will more likely be in the same module.
</p>
</li>
<li><p>'similarity': Link weights correspond to similarity indices. Nodes that
are similar to each other will more likely be in the same module. Inverse
link weights are then used to compute the modularity index.
</p>
</li>
<li><p>'none': Links are not weighted for the computation, which is only
based on graph topology.
</p>
</li></ul>

<p>Two different weightings can be used to create the modules of the two graphs.
</p>

<ul>
<li><p>If <code>node_inter</code> is a character string, then the same link
weighting is used for both graphs.
</p>
</li>
<li><p>If <code>node_inter</code> is a character vector of length 2, then
the link weighting used by the algorithm to create the modules of
graphs <code>x</code> and <code>y</code> is determined by the first and second elements
of <code>node_inter</code>, respectively.
</p>
</li></ul>
</td></tr>
<tr><td><code id="graph_modul_compar_+3A_data">data</code></td>
<td>
<p>(if x and y are columns from a data.frame) An object of class
data.frame with at least two columns and as many rows as there are nodes
in the graphs compared. The columns indicate the modules of each node in
2 different classifications.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This index takes values between -1 and 1. It measures how often
pairs of nodes pertaining to the same module in one graph also pertain to
the same module in the other graph.
Therefore, large values indicate that both partitions are similar.
The Rand Index can be defined as the frequency of agreement between two
classifications into discrete classes. It is the number of times a pair of
elements are classified into the same class or in two different classes
in both compared classifications, divided by the total number of possible
pairs of elements. The Rand Index is between 0 and 1 but its maximum value
depends on the number of elements. Thus, another 'adjusted' index was
created, the Adjusted Rand Index. According to the Hubert et
Arabie's formula, the ARI is computed as follows:
<code class="reqn">ARI=\frac{Index - Expected index}{Maximum index - Expected index}</code>
where the values of Index, Expected index and Maximum index are computed
from a contingency table.
This function uses <code>adjustedRandIndex</code> from package <span class="pkg">mclust</span> which
applies the Hubert and Arabie's formula for the ARI.
This function works for undirected graphs only.
</p>


<h3>Value</h3>

<p>The value of the ARI
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>References</h3>

<p>Dyer RJ, Nason JD (2004).
&ldquo;Population graphs: the graph theoretic shape of genetic structure.&rdquo;
<em>Molecular ecology</em>, <b>13</b>(7), 1713&ndash;1727.
Hubert L, Arabie P (1985).
&ldquo;Comparing partitions.&rdquo;
<em>Journal of classification</em>, <b>2</b>(1), 193&ndash;218.
Clauset A, Newman ME, Moore C (2004).
&ldquo;Finding community structure in very large networks.&rdquo;
<em>Physical review E</em>, <b>70</b>(6).
Blondel VD, Guillaume J, Lambiotte R, Lefebvre E (2008).
&ldquo;Fast unfolding of communities in large networks.&rdquo;
<em>Journal of Statistical Mechanics - Theory and Experiment</em>, <b>10</b>.
Brandes U, Delling D, Gaertler M, Gorke R, Hoefer M, Nikoloski Z, Wagner D (2008).
&ldquo;On modularity clustering.&rdquo;
<em>IEEE transactions on knowledge and data engineering</em>, <b>20</b>(2), 172&ndash;188.
Pons P, Latapy M (2006).
&ldquo;Computing communities in large networks using random walks.&rdquo;
<em>J. Graph Algorithms Appl.</em>, <b>10</b>(2), 191&ndash;218.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(data_ex_genind)
data(pts_pop_ex)
mat_dist &lt;- suppressWarnings(graph4lg::mat_geo_dist(data=pts_pop_ex,
      ID = "ID",
      x = "x",
      y = "y"))
mat_dist &lt;- mat_dist[order(as.character(row.names(mat_dist))),
                      order(as.character(colnames(mat_dist)))]
graph_obs &lt;- gen_graph_thr(mat_w = mat_dist, mat_thr = mat_dist,
                            thr = 24000, mode = "larger")
mat_gen &lt;- mat_gen_dist(x = data_ex_genind, dist = "DPS")
graph_pred &lt;- gen_graph_topo(mat_w = mat_gen, mat_topo = mat_dist,
                            topo = "gabriel")
ARI &lt;- graph_modul_compar(x = graph_obs, y = graph_pred)
</code></pre>

<hr>
<h2 id='graph_node_compar'>Compare the local properties of the nodes from two graphs</h2><span id='topic+graph_node_compar'></span>

<h3>Description</h3>

<p>The function computes a correlation coefficient between the
graph-theoretic metric values computed at the node-level in two graphs
sharing the same nodes. It allows to assess whether the connectivity
properties of the nodes in one graph are similar to that of the same nodes
in the other graph. Alternatively, the correlation is computed between
a graph-theoretic metric values and the values of an attribute associated
to the nodes of a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_node_compar(
  x,
  y,
  metrics = c("siw", "siw"),
  method = "spearman",
  weight = TRUE,
  test = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph_node_compar_+3A_x">x</code></td>
<td>
<p>An object of class <code>igraph</code>.
Its nodes must have the same names as in graph <code>y</code>.</p>
</td></tr>
<tr><td><code id="graph_node_compar_+3A_y">y</code></td>
<td>
<p>An object of class <code>igraph</code>.
Its nodes must have the same names as in graph <code>x</code>.</p>
</td></tr>
<tr><td><code id="graph_node_compar_+3A_metrics">metrics</code></td>
<td>
<p>Two-element character vector specifying the graph-theoretic
metrics computed at the node-level in the graphs or the node attribute
values to be correlated to these metrics.
Graph-theoretic metrics can be:
</p>

<ul>
<li><p>Degree (<code>metrics = c("deg", ...)</code>)
</p>
</li>
<li><p>Closeness centrality index (<code>metrics = c("close",...)</code>)
</p>
</li>
<li><p>Betweenness centrality index (<code>metrics = c("btw",...)</code>)
</p>
</li>
<li><p>Strength (sum of the weights of the links connected to a node)
(<code>metrics = c("str",...)</code>)
</p>
</li>
<li><p>Sum of the inverse weights of the links connected to a
node (<code>metrics = c("siw", ...)</code>, default)
</p>
</li>
<li><p>Mean of the inverse weights of the links connected to a
node (<code>metrics = c("miw", ...)</code>)
</p>
</li></ul>

<p>Node attributes must have the same names as in the <code>igraph</code> object,
and must refer to an attribute with numerical values.
The vector <code>metrics</code> is composed of two character values.
When a node attribute has the same name as a metric computable from the
graph, node attributes are given priority.</p>
</td></tr>
<tr><td><code id="graph_node_compar_+3A_method">method</code></td>
<td>
<p>A character string indicating which correlation coefficient
is to be computed (<code>"pearson"</code>, <code>"kendall"</code> or
<code>"spearman"</code> (default)).</p>
</td></tr>
<tr><td><code id="graph_node_compar_+3A_weight">weight</code></td>
<td>
<p>Logical which indicates whether the links are weighted during
the calculation of the centrality indices betweenness and closeness.
(default: <code>weight = TRUE</code>). Link weights are interpreted as distances
when computing the shortest paths. They should then be inversely proportional
to the strength of the relationship between nodes (e.g. to fluxes).</p>
</td></tr>
<tr><td><code id="graph_node_compar_+3A_test">test</code></td>
<td>
<p>Logical. Should significance testing be performed?
(default = TRUE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The correlation coefficients between the metrics can be computed
in different ways, as initial assumptions (e.g. linear relationship) are
rarely verified. Pearson's r, Spearman's rho and Kendall's tau can be
computed (from function <code><a href="stats.html#topic+cor">cor</a></code>).
When <code>x</code> is similar to <code>y</code>, then the correlation is computed
between two metrics characterizing the nodes of the same graph.
</p>


<h3>Value</h3>

<p>A <code>list</code> summarizing the correlation analysis.
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(data_ex_genind)
data(pts_pop_ex)
mat_dist &lt;- suppressWarnings(graph4lg::mat_geo_dist(data = pts_pop_ex,
      ID = "ID",
      x = "x",
      y = "y"))
mat_dist &lt;- mat_dist[order(as.character(row.names(mat_dist))),
                      order(as.character(colnames(mat_dist)))]
graph_obs &lt;- gen_graph_thr(mat_w = mat_dist, mat_thr = mat_dist,
                           thr = 9500, mode = "larger")
mat_gen &lt;- mat_gen_dist(x = data_ex_genind, dist = "DPS")
graph_pred &lt;- gen_graph_topo(mat_w = mat_gen, mat_topo = mat_dist,
                            topo = "gabriel")
res_cor &lt;- graph_node_compar(x = graph_obs, y = graph_pred,
                             metrics = c("siw", "siw"), method = "spearman",
                             test = TRUE, weight = TRUE)
</code></pre>

<hr>
<h2 id='graph_plan'>Create a graph with a minimum planar graph topology</h2><span id='topic+graph_plan'></span>

<h3>Description</h3>

<p>The function constructs a graph with a minimum planar
graph topology
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_plan(crds, ID = NULL, x = NULL, y = NULL, weight = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph_plan_+3A_crds">crds</code></td>
<td>
<p>A <code>data.frame</code> with the spatial
coordinates of the point set (the graph nodes). It must have three columns:
</p>

<ul>
<li><p>ID: A character string indicating the name of the points(graph nodes).
</p>
</li>
<li><p>x: A numeric or integer indicating the longitude of the graph nodes.
</p>
</li>
<li><p>y: A numeric or integer indicating the latitude of the graph nodes.
</p>
</li></ul>
</td></tr>
<tr><td><code id="graph_plan_+3A_id">ID</code></td>
<td>
<p>A character string indicating the name of the column
of <code>crds</code> with the point IDs</p>
</td></tr>
<tr><td><code id="graph_plan_+3A_x">x</code></td>
<td>
<p>A character string indicating the name of the column
of <code>crds</code> with the point longitude</p>
</td></tr>
<tr><td><code id="graph_plan_+3A_y">y</code></td>
<td>
<p>A character string indicating the name of the column
of <code>crds</code> with the point latitude</p>
</td></tr>
<tr><td><code id="graph_plan_+3A_weight">weight</code></td>
<td>
<p>A character string indicating whether the links of
the graph are weighted by Euclidean distances (TRUE)(default) or not (FALSE).
When the graph links do not have weights in Euclidean distances, each link
is given a weight of 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A delaunay triangulation is performed in order to get the
planar graph.
</p>


<h3>Value</h3>

<p>A planar graph of class <code>igraph</code>
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pts_pop_ex)
g_plan &lt;- graph_plan(crds = pts_pop_ex,
             ID = "ID",
             x = "x",
             y = "y")
</code></pre>

<hr>
<h2 id='graph_plot_compar'>Visualize the topological differences between two spatial graphs on a map</h2><span id='topic+graph_plot_compar'></span>

<h3>Description</h3>

<p>The function enables to compare two spatial graphs by
plotting them highlighting the topological similarities and differences
between them. Both graphs should share the same nodes and cannot
be directed graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_plot_compar(x, y, crds)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph_plot_compar_+3A_x">x</code></td>
<td>
<p>A graph object of class <code>igraph</code>.
Its nodes must have the same names as in graph <code>y</code>.</p>
</td></tr>
<tr><td><code id="graph_plot_compar_+3A_y">y</code></td>
<td>
<p>A graph object of class <code>igraph</code>.
Its nodes must have the same names as in graph <code>x</code>.</p>
</td></tr>
<tr><td><code id="graph_plot_compar_+3A_crds">crds</code></td>
<td>
<p>A <code>data.frame</code> with the spatial
coordinates of the graph nodes (both <code>x</code> and <code>y</code>).
It must have three columns:
</p>

<ul>
<li><p>ID: Name of the graph nodes (character string).
The names must be the same as the node names of the graphs of
class <code>igraph</code> (<code>igraph::V(graph)$name</code>)
</p>
</li>
<li><p>x: Longitude of the graph nodes (numeric or integer).
</p>
</li>
<li><p>y: Latitude of the graph nodes (numeric or integer).
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The graphs <code>x</code> and <code>y</code> of class <code>igraph</code> must have
node names (not necessarily in the same order as IDs in crds,
given a merging is done).
</p>


<h3>Value</h3>

<p>A ggplot2 object to plot
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pts_pop_ex)
data(data_ex_genind)
mat_w &lt;- mat_gen_dist(data_ex_genind, dist = "DPS")
mat_dist &lt;- mat_geo_dist(data = pts_pop_ex,
                         ID = "ID",
                         x = "x",
                         y = "y")
mat_dist &lt;- mat_dist[order(as.character(row.names(mat_dist))),
                   order(as.character(colnames(mat_dist)))]
g1 &lt;- gen_graph_topo(mat_w = mat_w, topo = "mst")
g2 &lt;- gen_graph_topo(mat_w = mat_w, mat_topo = mat_dist, topo = "gabriel")
g &lt;- graph_plot_compar(x = g1, y = g2,
                       crds = pts_pop_ex)
</code></pre>

<hr>
<h2 id='graph_to_df'>Convert a graph into a edge list data.frame</h2><span id='topic+graph_to_df'></span>

<h3>Description</h3>

<p>The function converts a graph into a edge list data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_to_df(graph, weight = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph_to_df_+3A_graph">graph</code></td>
<td>
<p>A graph object of class <code>igraph</code></p>
</td></tr>
<tr><td><code id="graph_to_df_+3A_weight">weight</code></td>
<td>
<p>Logical. If TRUE (default), then the column 'link' of the
output data.frame contains the weights of the links. If FALSE,
it contains only 0 and 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The 'graph' nodes must have names. Links must have weights if
'weight = TRUE'.
</p>


<h3>Value</h3>

<p>An object of class <code>data.frame</code> with a link ID, the origin nodes
('from') and arrival nodes ('to') and the link
value ('link')(weighted or binary)
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pts_pop_ex)
suppressWarnings(mat_geo &lt;- mat_geo_dist(pts_pop_ex,
                 ID = "ID",
                 x = "x",
                y = "y"))
g1 &lt;- gen_graph_thr(mat_w = mat_geo,
                    mat_thr = mat_geo,
                    thr = 20000)
g1_df &lt;- graph_to_df(g1,
                     weight = TRUE)
</code></pre>

<hr>
<h2 id='graph_to_shp'>Export a spatial graph to shapefile layers</h2><span id='topic+graph_to_shp'></span>

<h3>Description</h3>

<p>The function enables to export a spatial graph to
shapefile layers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_to_shp(
  graph,
  crds,
  mode = "both",
  crds_crs,
  layer,
  dir_path,
  metrics = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph_to_shp_+3A_graph">graph</code></td>
<td>
<p>A graph object of class <code>igraph</code></p>
</td></tr>
<tr><td><code id="graph_to_shp_+3A_crds">crds</code></td>
<td>
<p>(if 'mode = 'spatial&rdquo;) A <code>data.frame</code> with the spatial
coordinates of the graph nodes. It must have three columns:
</p>

<ul>
<li><p>ID: Name of the graph nodes (will be converted into character string).
The names must the same as the node names of the graph object of
class <code>igraph</code> (<code>igraph::V(graph)$name</code>)
</p>
</li>
<li><p>x: Longitude (numeric or integer) of the graph nodes in the coordinates
reference system indicated with the argument crds_crs.
</p>
</li>
<li><p>y: Latitude (numeric or integer) of the graph nodes in the coordinates
reference system indicated with the argument crds_crs.
</p>
</li></ul>
</td></tr>
<tr><td><code id="graph_to_shp_+3A_mode">mode</code></td>
<td>
<p>Indicates which shapefile layers will be created
</p>

<ul>
<li><p>If 'mode = 'both&rdquo; (default), then two shapefile layers are created,
one for the nodes and another for the links.
</p>
</li>
<li><p>If 'mode = 'node&rdquo;, a shapefile layer is created for the nodes only.
</p>
</li>
<li><p>If 'mode = 'link&rdquo;, a shapefile layer is created for the links only.
</p>
</li></ul>
</td></tr>
<tr><td><code id="graph_to_shp_+3A_crds_crs">crds_crs</code></td>
<td>
<p>An integer indicating the EPSG code of the coordinates
reference system to use.
The projection and datum are given in the PROJ.4 format.</p>
</td></tr>
<tr><td><code id="graph_to_shp_+3A_layer">layer</code></td>
<td>
<p>A character string indicating the suffix of the name of
the layers to be created.</p>
</td></tr>
<tr><td><code id="graph_to_shp_+3A_dir_path">dir_path</code></td>
<td>
<p>A character string corresponding to the path to the directory
in which the shapefile layers will be exported. If <code>dir_path = "wd"</code>,
then the layers are created in the current working directory.</p>
</td></tr>
<tr><td><code id="graph_to_shp_+3A_metrics">metrics</code></td>
<td>
<p>(not considered if 'mode = 'link&rdquo;) Logical. Should graph
node attributes integrated in the attribute table of the node shapefile
layer? (default: FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Create shapefile layers in the directory specified with the parameter
'dir_path'.
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(data_tuto)
mat_w &lt;- data_tuto[[1]]
gp &lt;- gen_graph_topo(mat_w = mat_w, topo = "gabriel")
crds_crs &lt;- 2154
crds &lt;- pts_pop_simul
layer &lt;- "graph_dps_gab"
graph_to_shp(graph = gp, crds = pts_pop_simul, mode = "both",
             crds_crs = crds_crs,
             layer = "test_fonct",
             dir_path = tempdir(),
             metrics = FALSE)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='graph_topo_compar'>Compute an index comparing graph topologies</h2><span id='topic+graph_topo_compar'></span>

<h3>Description</h3>

<p>The function computes several indices in order to compare two
graph topologies. One of the graph has the &quot;true&quot; topology the other is
supposed to reproduce. The indices are then a way to assess the reliability
of the latter graph.
Both graphs must have the same number of nodes, but not necessarily the
same number of links. They must also have the same node names and in
the same order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_topo_compar(obs_graph, pred_graph, mode = "mcc", directed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph_topo_compar_+3A_obs_graph">obs_graph</code></td>
<td>
<p>A graph object of class <code>igraph</code> with n nodes.
It is the observed graph that <code>pred_graph</code> is supposed to approach.</p>
</td></tr>
<tr><td><code id="graph_topo_compar_+3A_pred_graph">pred_graph</code></td>
<td>
<p>A graph object of class <code>igraph</code> with n nodes.
It is the predicted graph that is supposed to be akin to <code>obs_graph</code>.</p>
</td></tr>
<tr><td><code id="graph_topo_compar_+3A_mode">mode</code></td>
<td>
<p>A character string specifying which index to compute in order
to compare the topologies of the graphs.
</p>

<ul>
<li><p>If 'mode = 'mcc&rdquo; (default), the Matthews Correlation
Coefficient (MCC) is computed.
</p>
</li>
<li><p>If 'mode = 'kappa&rdquo;, the Kappa index is computed.
</p>
</li>
<li><p>If 'mode = 'fdr&rdquo;, the False Discovery Rate (FDR) is computed.
</p>
</li>
<li><p>If 'mode = 'acc&rdquo;, the Accuracy is computed.
</p>
</li>
<li><p>If 'mode = 'sens&rdquo;, the Sensitivity is computed.
</p>
</li>
<li><p>If 'mode = 'spec&rdquo;, the Specificity is computed.
</p>
</li>
<li><p>If 'mode = 'prec&rdquo;, the Precision is computed.
</p>
</li></ul>
</td></tr>
<tr><td><code id="graph_topo_compar_+3A_directed">directed</code></td>
<td>
<p>Logical (TRUE or FALSE) specifying whether both graphs
are directed or not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The indices are calculated from a confusion matrix counting
the number of links that are in the &quot;observed&quot; graph (&quot;true&quot;) and also
in the &quot;predicted&quot; graph (true positives : TP), that are in the &quot;observed&quot;
graph but not in the &quot;predicted&quot; graph (false negatives : FN), that are not
in the &quot;observed&quot; graph but in the &quot;predicted&quot; graph (false positives : FP)
and that are not in the &quot;observed&quot; graph and not in the &quot;predicted&quot; graph
neither (true negatives: TN). K is the total number of links in the graphs.
K is equal to <code class="reqn">n\times(n-1)</code> if the graphs are directed and to
<code class="reqn">\frac{n\times(n-1)}{2}</code> if they are not directed, with n the number
of nodes.
OP = TP + FN, ON = TN + FP, PP = TP + FP and PN = FN + TN.
</p>
<p>The Matthews Correlation Coefficient (MCC) is computed as follows:
<code class="reqn">MCC = \frac{TP\times TN-FP\times FN}{\sqrt{(TP+FP)(TP+FN)(TN+FP)(TN+FN)}}</code>
</p>
<p>The Kappa index is computed as follows:
<code class="reqn">Kappa = \frac{K\times (TP + TN) - (ON \times PN) - (OP \times PP)}{K^{2} - (ON \times PN) - (OP \times PP)}</code>
</p>
<p>The False Discovery Rate (FDR) is calculated as follows:
<code class="reqn">FDR = \frac{FP}{TP+FP}</code>
</p>
<p>The Accuracy is calculated as follows:
<code class="reqn">Acc = \frac{TP + TN}{K}</code>
</p>
<p>The Sensitivity is calculated as follows:
<code class="reqn">Sens = \frac{TP}{TP+FN}</code>
</p>
<p>The Specificity is calculated as follows:
<code class="reqn">Spec = \frac{TN}{TN+FP}</code>
</p>
<p>The Precision is calculated as follows:
<code class="reqn">Prec = \frac{TP}{TP+FP}</code>
</p>
<p>Self loops are not taken into account.
</p>


<h3>Value</h3>

<p>The value of the index computed
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>References</h3>

<p>Dyer RJ, Nason JD (2004).
&ldquo;Population graphs: the graph theoretic shape of genetic structure.&rdquo;
<em>Molecular ecology</em>, <b>13</b>(7), 1713&ndash;1727.
Baldi P, Brunak S, Chauvin Y, Andersen CA, Nielsen H (2000).
&ldquo;Assessing the accuracy of prediction algorithms for classification: an overview.&rdquo;
<em>Bioinformatics</em>, <b>16</b>(5), 412&ndash;424.
Matthews BW (1975).
&ldquo;Comparison of the predicted and observed secondary structure of T4 phage lysozyme.&rdquo;
<em>Biochimica et Biophysica Acta (BBA)-Protein Structure</em>, <b>405</b>(2), 442&ndash;451.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(data_ex_genind)
data(pts_pop_ex)
mat_dist &lt;- suppressWarnings(graph4lg::mat_geo_dist(data=pts_pop_ex,
      ID = "ID",
      x = "x",
      y = "y"))
mat_dist &lt;- mat_dist[order(as.character(row.names(mat_dist))),
                      order(as.character(colnames(mat_dist)))]
graph_obs &lt;- gen_graph_thr(mat_w = mat_dist, mat_thr = mat_dist,
                            thr = 15000, mode = "larger")
mat_gen &lt;- mat_gen_dist(x = data_ex_genind, dist = "DPS")
graph_pred &lt;- gen_graph_topo(mat_w = mat_gen, mat_topo = mat_dist,
                            topo = "gabriel")
graph_topo_compar(obs_graph = graph_obs,
                  pred_graph = graph_pred,
                  mode = "mcc",
                  directed = FALSE)
</code></pre>

<hr>
<h2 id='graphab_capacity'>Computes custom capacities of patches in the Graphab project</h2><span id='topic+graphab_capacity'></span>

<h3>Description</h3>

<p>The function computes custom capacities of patches
in the Graphab project
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graphab_capacity(
  proj_name,
  mode = "area",
  patch_codes = NULL,
  exp = NULL,
  ext_file = NULL,
  thr = NULL,
  linkset = NULL,
  codes = NULL,
  cost_conv = FALSE,
  weight = FALSE,
  proj_path = NULL,
  alloc_ram = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graphab_capacity_+3A_proj_name">proj_name</code></td>
<td>
<p>A character string indicating the Graphab project name.
The project name is also the name of the project directory in which the
file proj_name.xml is. It can be created with <code><a href="#topic+graphab_project">graphab_project</a></code></p>
</td></tr>
<tr><td><code id="graphab_capacity_+3A_mode">mode</code></td>
<td>
<p>A character string indicating the way capacities are
computed. It must be either:</p>

<ul>
<li><p><code>mode='area'</code>(default): The capacity of the patches is computed
as the area of each habitat patch. The argument <code>exp</code> makes it
possible to raise area to a power given by an exposant.
</p>
</li>
<li><p><code>mode='ext_file'</code>: The capacity of the patches is given by an
external .csv file. See argument <code>ext_file</code> below.
</p>
</li>
<li><p><code>mode='neigh'</code>: The capacity is computed depending on the
neighbouring raster cells from each habitat patch. The number of cells
with a value given by <code>codes</code> argument is summed up to the
distance <code>thr</code>. This number can be weighted according to the
<code>weight</code> argument.
</p>
</li></ul>
</td></tr>
<tr><td><code id="graphab_capacity_+3A_patch_codes">patch_codes</code></td>
<td>
<p>(optional, default=NULL) An integer value or vector
specifying the codes corresponding to the habitat pixel whose corresponding
patches are included to compute the capacity as the area of the habitat
when <code>mode='area'</code>. Patches corresponding to other initial habitat
codes are weighted by 0.</p>
</td></tr>
<tr><td><code id="graphab_capacity_+3A_exp">exp</code></td>
<td>
<p>An integer value specifying the power to which patch area are
raised when <code>mode='area'</code>. When not specified, <code>exp=1</code> by default.</p>
</td></tr>
<tr><td><code id="graphab_capacity_+3A_ext_file">ext_file</code></td>
<td>
<p>A character string specifying the name of the .csv file in
which patch capacities are stored. It must be located either in the working
directory or in the directory defined by <code>proj_path</code>. It must have
as many rows as there are patches in the project and its column names
must include 'Id' and 'Capacity'. The 'Id' column must correspond to the
patch ID in the 'patches' layer (see <code><a href="#topic+get_graphab_metric">get_graphab_metric</a></code>).
The 'Capacity' column must contain the corresponding patch capacities to
assign each patch.</p>
</td></tr>
<tr><td><code id="graphab_capacity_+3A_thr">thr</code></td>
<td>
<p>(optional, default=NULL) An integer or numeric value indicating
the maximum distance in cost distance units (except when
<code>cost_conv = TRUE</code>) at which cells are considered for computing the
capacity when <code>mode='neigh'</code>.</p>
</td></tr>
<tr><td><code id="graphab_capacity_+3A_linkset">linkset</code></td>
<td>
<p>(optional, default=NULL) A character string indicating the
name of the link set used to take distance into account when computing
the capacity. Only used when <code>mode='neigh'</code>. Link sets can be
created with <code><a href="#topic+graphab_link">graphab_link</a></code>.</p>
</td></tr>
<tr><td><code id="graphab_capacity_+3A_codes">codes</code></td>
<td>
<p>An integer value or a vector of integer values specifying the
codes of the raster cells taken into account when computing the capacity in
the neighbourhood of the patches, when <code>mode='neigh'</code>.</p>
</td></tr>
<tr><td><code id="graphab_capacity_+3A_cost_conv">cost_conv</code></td>
<td>
<p>FALSE (default) or TRUE. Logical indicating whether numeric
<code>thr</code> values are converted from cost-distance into Euclidean distance
using a log-log linear regression. See also <code><a href="#topic+convert_cd">convert_cd</a></code>
function. Only used when <code>mode='neigh'</code>.</p>
</td></tr>
<tr><td><code id="graphab_capacity_+3A_weight">weight</code></td>
<td>
<p>A logical indicating whether the cells are weighted by a
weight decreasing with the distance from the patches (TRUE) or not (FALSE).
The weights follow a negative exponential decline such that
wi = exp(-alpha*di), where wi is the weight of cell i, di its distance from
the patch and alpha a parameter determined such that wi = 0.05 when di = thr.</p>
</td></tr>
<tr><td><code id="graphab_capacity_+3A_proj_path">proj_path</code></td>
<td>
<p>(optional) A character string indicating the path to the
directory that contains the project directory. It should be used when the
project directory is not in the current working directory. Default is NULL.
When 'proj_path = NULL', the project directory is equal to <code>getwd()</code>.</p>
</td></tr>
<tr><td><code id="graphab_capacity_+3A_alloc_ram">alloc_ram</code></td>
<td>
<p>(optional, default = NULL) Integer or numeric value
indicating RAM gigabytes allocated to the java process. Increasing this
value can speed up the computations. Too large values may not be compatible
with your machine settings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See more information in Graphab 2.8 manual:
<a href="https://sourcesup.renater.fr/www/graphab/download/manual-2.8-en.pdf">https://sourcesup.renater.fr/www/graphab/download/manual-2.8-en.pdf</a>
Be careful, when capacity has been changed. The last changes are taken into
account for subsequent calculations in a project.
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
graphab_capacity(proj_name = "grphb_ex",
                 mode = "area")

## End(Not run)
</code></pre>

<hr>
<h2 id='graphab_corridor'>Computes corridors from least-cost paths already computed in
the Graphab project</h2><span id='topic+graphab_corridor'></span>

<h3>Description</h3>

<p>The function computes corridors around the least-cost paths
which have been computed in the Graphab project.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graphab_corridor(
  proj_name,
  graph,
  maxcost,
  format = "raster",
  cost_conv = FALSE,
  proj_path = NULL,
  alloc_ram = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graphab_corridor_+3A_proj_name">proj_name</code></td>
<td>
<p>A character string indicating the Graphab project name.
The project name is also the name of the project directory in which the
file proj_name.xml is. It can be created with <code><a href="#topic+graphab_project">graphab_project</a></code></p>
</td></tr>
<tr><td><code id="graphab_corridor_+3A_graph">graph</code></td>
<td>
<p>A character string indicating the name of the graph with the
links from which the corridors are computed.
This graph has been created with Graphab or using <code><a href="#topic+graphab_graph">graphab_graph</a></code>
function and is associated with a link set.
Only the links present in the graph will be used in the computation.</p>
</td></tr>
<tr><td><code id="graphab_corridor_+3A_maxcost">maxcost</code></td>
<td>
<p>An integer or numeric value indicating the maximum cost
distance from the least-cost paths considered for creating the corridors,
in cost distance units (except when <code>cost_conv = TRUE</code>).</p>
</td></tr>
<tr><td><code id="graphab_corridor_+3A_format">format</code></td>
<td>
<p>(optional, default = &quot;raster&quot;) A character string indicating
whether the output is a raster file or a shapefile layer.</p>
</td></tr>
<tr><td><code id="graphab_corridor_+3A_cost_conv">cost_conv</code></td>
<td>
<p>FALSE (default) or TRUE. Logical indicating whether numeric
<code>thr</code> values are converted from cost-distance into Euclidean distance
using a log-log linear regression. See also <code><a href="#topic+convert_cd">convert_cd</a></code>
function. Only used when <code>mode='neigh'</code>.</p>
</td></tr>
<tr><td><code id="graphab_corridor_+3A_proj_path">proj_path</code></td>
<td>
<p>(optional) A character string indicating the path to the
directory that contains the project directory. It should be used when the
project directory is not in the current working directory. Default is NULL.
When 'proj_path = NULL', the project directory is equal to <code>getwd()</code>.</p>
</td></tr>
<tr><td><code id="graphab_corridor_+3A_alloc_ram">alloc_ram</code></td>
<td>
<p>(optional, default = NULL) Integer or numeric value
indicating RAM gigabytes allocated to the java process. Increasing this
value can speed up the computations. Too large values may not be compatible
with your machine settings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See more information in Graphab 2.8 manual:
<a href="https://sourcesup.renater.fr/www/graphab/download/manual-2.8-en.pdf">https://sourcesup.renater.fr/www/graphab/download/manual-2.8-en.pdf</a>
Be careful, when capacity has been changed. The last changes are taken into
account for subsequent calculations in a project.
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
graphab_corridor(proj_name = "grphb_ex",
                 graph = "graph",
                 maxcost = 1000,
                 format = "raster",
                 cost_conv = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='graphab_graph'>Create a graph in the Graphab project</h2><span id='topic+graphab_graph'></span>

<h3>Description</h3>

<p>The function creates a graph from a link set in a Graphab project
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graphab_graph(
  proj_name,
  linkset = NULL,
  name = NULL,
  thr = NULL,
  cost_conv = FALSE,
  proj_path = NULL,
  alloc_ram = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graphab_graph_+3A_proj_name">proj_name</code></td>
<td>
<p>A character string indicating the Graphab project name.
The project name is also the name of the project directory in which the
file proj_name.xml is. It can be created with <code><a href="#topic+graphab_project">graphab_project</a></code></p>
</td></tr>
<tr><td><code id="graphab_graph_+3A_linkset">linkset</code></td>
<td>
<p>(optional, default=NULL) A character string indicating the
name of the link set used to create the graph. If <code>linkset=NULL</code>, every
link set present in the project will be used to create a graph. Link sets
can be created with <code><a href="#topic+graphab_link">graphab_link</a></code>.</p>
</td></tr>
<tr><td><code id="graphab_graph_+3A_name">name</code></td>
<td>
<p>(optional, default=NULL) A character string indicating the
name of the graph created. If <code>name=NULL</code>, a name will be created. If
both <code>linkset=NULL</code> and <code>name=NULL</code>, then a graph will be created
for every link set present in the project and a name will be created every
time. In the latter case, a unique name cannot be specified. Link sets
can be created with <code><a href="#topic+graphab_link">graphab_link</a></code>.</p>
</td></tr>
<tr><td><code id="graphab_graph_+3A_thr">thr</code></td>
<td>
<p>(optional, default=NULL) An integer or numeric value indicating
the maximum distance associated with the links of the created graph. It
allows users to create a pruned graph based on a distance threshold. Note that
when the link set used has a planar topology, the graph is necessarily a
pruned graph (not complete) and adding this threshold parameter can remove
other links. When the link set has been created with cost-distances, the
parameter is expressed in cost-distance units whereas when the link set is
based upon Euclidean distances, the parameter is expressed in meters.</p>
</td></tr>
<tr><td><code id="graphab_graph_+3A_cost_conv">cost_conv</code></td>
<td>
<p>FALSE (default) or TRUE. Logical indicating whether numeric
<code>thr</code> values are converted from cost-distance into Euclidean distance
using a log-log linear regression. See also <code><a href="#topic+convert_cd">convert_cd</a></code>
function.</p>
</td></tr>
<tr><td><code id="graphab_graph_+3A_proj_path">proj_path</code></td>
<td>
<p>(optional) A character string indicating the path to the
directory that contains the project directory. It should be used when the
project directory is not in the current working directory. Default is NULL.
When 'proj_path = NULL', the project directory is equal to <code>getwd()</code>.</p>
</td></tr>
<tr><td><code id="graphab_graph_+3A_alloc_ram">alloc_ram</code></td>
<td>
<p>(optional, default = NULL) Integer or numeric value
indicating RAM gigabytes allocated to the java process. Increasing this
value can speed up the computations. Too large values may not be compatible
with your machine settings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, intra-patch distances are considered for metric
calculation. See more information in Graphab 2.8 manual:
<a href="https://sourcesup.renater.fr/www/graphab/download/manual-2.8-en.pdf">https://sourcesup.renater.fr/www/graphab/download/manual-2.8-en.pdf</a>
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
graphab_graph(proj_name = "grphb_ex",
              linkset = "lcp",
              name = "graph")

## End(Not run)
</code></pre>

<hr>
<h2 id='graphab_interpol'>Creates a raster with interpolated connectivity metric values from metrics
already computed in the Graphab project</h2><span id='topic+graphab_interpol'></span>

<h3>Description</h3>

<p>The function creates a raster with interpolated connectivity
metric values from a metric already computed in the Graphab project.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graphab_interpol(
  proj_name,
  name,
  reso,
  linkset,
  graph,
  var,
  dist,
  prob = 0.05,
  thr = NULL,
  summed = FALSE,
  proj_path = NULL,
  alloc_ram = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graphab_interpol_+3A_proj_name">proj_name</code></td>
<td>
<p>A character string indicating the Graphab project name.
The project name is also the name of the project directory in which the
file proj_name.xml is. It can be created with <code><a href="#topic+graphab_project">graphab_project</a></code></p>
</td></tr>
<tr><td><code id="graphab_interpol_+3A_name">name</code></td>
<td>
<p>A character string indicating the name of the raster to be
created after the interpolation.</p>
</td></tr>
<tr><td><code id="graphab_interpol_+3A_reso">reso</code></td>
<td>
<p>An integer indicating the spatial resolution in meters of the
raster resulting from the metric interpolation.</p>
</td></tr>
<tr><td><code id="graphab_interpol_+3A_linkset">linkset</code></td>
<td>
<p>A character string indicating the name of the link set used
for the interpolation. It should be the one used to create the used graph
and the metric.</p>
</td></tr>
<tr><td><code id="graphab_interpol_+3A_graph">graph</code></td>
<td>
<p>A character string indicating the name of the graph from which
the metric was computed and whose links are considered for a potential
multi-linkage with patches.
This graph has been created with Graphab or using <code><a href="#topic+graphab_graph">graphab_graph</a></code>
function and is associated with a link set.</p>
</td></tr>
<tr><td><code id="graphab_interpol_+3A_var">var</code></td>
<td>
<p>A character string indicating the name of the already computed
metric to be interpolated.</p>
</td></tr>
<tr><td><code id="graphab_interpol_+3A_dist">dist</code></td>
<td>
<p>A numeric or integer value specifying the distance at which we
assume a probability equal to <code>prob</code> during the interpolation.
It is used to set <code class="reqn">\alpha</code> for computing probabilities associated
with distances between each pixel and the neighboring patch(es) such that
probability between patch i and pixel j is <code class="reqn">p_{ij}= e^{-\alpha d_{ij}}</code>.</p>
</td></tr>
<tr><td><code id="graphab_interpol_+3A_prob">prob</code></td>
<td>
<p>A numeric or integer value specifying the probability
at distance <code>dist</code>. By default, <code>code=0.05</code>. It is used to set
<code class="reqn">\alpha</code> (see param <code>dist</code> above).</p>
</td></tr>
<tr><td><code id="graphab_interpol_+3A_thr">thr</code></td>
<td>
<p>(default NULL) If NULL, the value of each pixel is computed from
the value of the metric at the nearest habitat patch, weighted by a
probability depending on distance. If an integer, the value of each pixel
depends on the values of the metric taken at several of the nearest habitat
patches, up to a distance (cost or Euclidean distance, depending on the type
of linkset) equal to <code>thr</code>.</p>
</td></tr>
<tr><td><code id="graphab_interpol_+3A_summed">summed</code></td>
<td>
<p>Logical (default = FALSE) only used if <code>thr</code> is not NULL,
and specifying whether multiple values are summed up (TRUE) or averaged
after being weighted by probabilities.</p>
</td></tr>
<tr><td><code id="graphab_interpol_+3A_proj_path">proj_path</code></td>
<td>
<p>(optional) A character string indicating the path to the
directory that contains the project directory. It should be used when the
project directory is not in the current working directory. Default is NULL.
When 'proj_path = NULL', the project directory is equal to <code>getwd()</code>.</p>
</td></tr>
<tr><td><code id="graphab_interpol_+3A_alloc_ram">alloc_ram</code></td>
<td>
<p>(optional, default = NULL) Integer or numeric value
indicating RAM gigabytes allocated to the java process. Increasing this
value can speed up the computations. Too large values may not be compatible
with your machine settings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See more information in Graphab 2.8 manual:
<a href="https://sourcesup.renater.fr/www/graphab/download/manual-2.8-en.pdf">https://sourcesup.renater.fr/www/graphab/download/manual-2.8-en.pdf</a>
Be careful, when capacity has been changed. The last changes are taken into
account for subsequent calculations in a project.
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
graphab_interpol(proj_name = "grphb_ex",
                 name = "F_interp",
                 reso = 20,
                 linkset = "lcp",
                 graph = "graph",
                 var = "F_d600_p0.5_beta1_graph",
                 dist = 600,
                 prob = 0.5)

## End(Not run)
</code></pre>

<hr>
<h2 id='graphab_link'>Create a link set in the Graphab project</h2><span id='topic+graphab_link'></span>

<h3>Description</h3>

<p>The function creates a link set between habitat patches in the
Graphab project.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graphab_link(
  proj_name,
  distance = "cost",
  name,
  cost = NULL,
  topo = "planar",
  remcrosspath = FALSE,
  proj_path = NULL,
  alloc_ram = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graphab_link_+3A_proj_name">proj_name</code></td>
<td>
<p>A character string indicating the Graphab project name.
The project name is also the name of the project directory in which the
file proj_name.xml is. It can be created with <code><a href="#topic+graphab_project">graphab_project</a></code></p>
</td></tr>
<tr><td><code id="graphab_link_+3A_distance">distance</code></td>
<td>
<p>A character string indicating whether links between patches
are computed based on:</p>

<ul>
<li><p>Shortest cost distances: <code>distance='cost'</code> (default)
</p>
</li>
<li><p>Straight Euclidean distances: <code>distance='euclid'</code>
</p>
</li></ul>

<p>In the resulting link set, each link will be associated with its
corresponding cost-distance and the length of the least-cost path in meters
(if <code>distance='cost'</code>) or with its length in Euclidean distance
(if <code>distance='euclid'</code>)</p>
</td></tr>
<tr><td><code id="graphab_link_+3A_name">name</code></td>
<td>
<p>A character string indicating the name of the created linkset.</p>
</td></tr>
<tr><td><code id="graphab_link_+3A_cost">cost</code></td>
<td>
<p>This argument could be:</p>

<ul>
<li><p>A <code>data.frame</code> indicating the cost values associated to each
raster cell value. These values refer to the raster used to create the
project with <code>graphab_project</code>. The data.frame must have two
columns:</p>

<ul>
<li><p>'code': raster cell values
</p>
</li>
<li><p>'cost': corresponding cost values
</p>
</li></ul>

</li>
<li><p>The path to an external raster file in .tif format with cost values.
</p>
</li></ul>
</td></tr>
<tr><td><code id="graphab_link_+3A_topo">topo</code></td>
<td>
<p>A character string indicating the topology of the created
link set. It can be:</p>

<ul>
<li><p>Planar (<code>topo='planar'</code> (default)): a planar set of links is
created. It speeds up the computation but will prevent from creating
complete graphs with <code><a href="#topic+graphab_graph">graphab_graph</a></code>.
</p>
</li>
<li><p>Complete (<code>topo='complete'</code>): a complete set of links is created.
A link is computed between every pair of patches.
</p>
</li></ul>
</td></tr>
<tr><td><code id="graphab_link_+3A_remcrosspath">remcrosspath</code></td>
<td>
<p>(optional, default = FALSE) A logical indicating whether
links crossing patches are removed (TRUE).</p>
</td></tr>
<tr><td><code id="graphab_link_+3A_proj_path">proj_path</code></td>
<td>
<p>(optional) A character string indicating the path to the
directory that contains the project directory. It should be used when the
project directory is not in the current working directory. Default is NULL.
When 'proj_path = NULL', the project directory is equal to <code>getwd()</code>.</p>
</td></tr>
<tr><td><code id="graphab_link_+3A_alloc_ram">alloc_ram</code></td>
<td>
<p>(optional, default = NULL) Integer or numeric value
indicating RAM gigabytes allocated to the java process. Increasing this
value can speed up the computations. Too large values may not be compatible
with your machine settings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, links crossing patches are not ignored nor broken into
two links. For example, a link from patches A to C crossing patch B
is created. It takes into account the distance inside patch B. It can be a
problem when computing BC index. See more information in Graphab 2.8 manual:
<a href="https://sourcesup.renater.fr/www/graphab/download/manual-2.8-en.pdf">https://sourcesup.renater.fr/www/graphab/download/manual-2.8-en.pdf</a>
</p>


<h3>Author(s)</h3>

<p>P. Savary, T. Rudolph
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
df_cost &lt;- data.frame(code = 1:5,
                      cost = c(1, 10, 100, 1000, 1))
graphab_link(proj_name = "grphb_ex",
            distance = "cost",
            name = "lcp",
            cost = df_cost,
            topo = "complete")

## End(Not run)
</code></pre>

<hr>
<h2 id='graphab_metric'>Compute connectivity metrics from a graph in the Graphab project</h2><span id='topic+graphab_metric'></span>

<h3>Description</h3>

<p>The function computes connectivity metrics on a graph from a
link set in a Graphab project
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graphab_metric(
  proj_name,
  graph,
  metric,
  multihab = FALSE,
  dist = NULL,
  prob = 0.05,
  beta = 1,
  cost_conv = FALSE,
  return_val = TRUE,
  proj_path = NULL,
  alloc_ram = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graphab_metric_+3A_proj_name">proj_name</code></td>
<td>
<p>A character string indicating the Graphab project name.
The project name is also the name of the project directory in which the
file proj_name.xml is.</p>
</td></tr>
<tr><td><code id="graphab_metric_+3A_graph">graph</code></td>
<td>
<p>A character string indicating the name of the graph on which
the metric is computed. This graph has been created with Graphab
or using <code><a href="#topic+graphab_graph">graphab_graph</a></code> function and is associated
with a link set. Only the links present in the graph and their corresponding
weights will be used in the computation, together with patch areas.</p>
</td></tr>
<tr><td><code id="graphab_metric_+3A_metric">metric</code></td>
<td>
<p>A character string indicating the metric which will be computed
on the graph. This metric can be:</p>

<ul>
<li><p>A global metric:</p>

<ul>
<li><p>Probability of Connectivity (<code>metric = 'PC'</code>): Sum of products of
area of all pairs of patches weighted by their interaction probability,
divided by the square of the area of the study zone.
This ratio is the equivalent to the probability that two points randomly
placed in the study area are connected.
</p>
</li>
<li><p>Equivalent Connectivity (<code>metric = 'EC'</code>): Square root of the
sum of products of capacity of all pairs of patches weighted by their
interaction probability. This is the size of a single patch (maximally
connected) that would provide the same probability of connectivity as the
actual habitat pattern in the landscape (Saura et al., 2011).
</p>
</li>
<li><p>Integral Index of Connectivity (<code>metric = 'IIC'</code>): For the
entire graph: product of patch areas divided by the number of links
between them, the sum is divided by the square of the area of the study
zone. IIC is built like the PC index but using the inverse of a topological
distance rather than a negative exponential function of the distance
based on the link weight.
</p>
</li></ul>

</li>
<li><p>A local metric:</p>

<ul>
<li><p>Flux (<code>metric = 'F'</code>): For the focal patch i : sum of area
of patches other than i and weighted according to their minimum distance
to the focal patch through the graph. This sum is an indicator of the
potential dispersion from the patch i or, conversely to the patch i
</p>
</li>
<li><p>Betweenness Centrality index (<code>metric = 'BC'</code>): Sum of the
shortest paths through the focal patch i, each path is weighted by the
product of the areas of the patches connected and of their interaction
probability. All possible paths between every pair of patches is
considered in this computation.
</p>
</li>
<li><p>Interaction Flux (<code>metric = 'IF'</code>): Sum of products of the focal
patch area with all the other patches, weighted by their interaction
probability.
</p>
</li>
<li><p>Degree (<code>metric = 'Dg'</code>): Number of edges connected to the
node i i.e. number of patches connected directly to the patch i.
</p>
</li>
<li><p>Closeness Centrality index (<code>metric = 'CCe'</code>): Mean distance
from the patch i to all other patches of its component k.
</p>
</li>
<li><p>Current Flux (<code>metric = 'CF'</code>): Sum of currents passing through
the patch i. <code class="reqn">c_{i}^{j}</code> represents the current through the patch i when
currents are sent from all patches (except j) to the patch j.
The patch j is connected to the ground.
</p>
</li></ul>

</li>
<li><p>A delta metric:</p>

<ul>
<li><p>delta Probability of Connectivity (<code>metric = 'dPC'</code>): Rate of
variation between the value of PC index and the value of PC' corresponding
to the removal of the patch i. The value of <code>dPC</code> is decomposed
into three parts:</p>

<ul>
<li><p><code class="reqn">dPC_{area}</code> is the variation induced by the area lost after removal;
</p>
</li>
<li><p><code class="reqn">dPC_{flux}</code> is the variation induced by the loss of interaction
between the patch i and other patches;
</p>
</li>
<li><p><code class="reqn">dPC_{connector}</code> is the variation induced by the modification of
paths connecting other patches and initially routed through i.
</p>
</li></ul>

</li></ul>

</li></ul>

<p>For most metrics, the interaction probability is computed for each pair of
patches from the path that minimizes the distance d (or the cost) between
them. It then maximizes <code class="reqn">{e}^{-\alpha d_{ij}}</code> for patches i and j.
To use patch capacity values different from the patch area, please use
directly Graphab software.</p>
</td></tr>
<tr><td><code id="graphab_metric_+3A_multihab">multihab</code></td>
<td>
<p>A logical (default = FALSE) indicating whether the
'multihabitat' mode is used when computing the metric. It only applies to
the following metrics: 'EC', 'F', 'IF' and 'BC'. If TRUE, then the project
must have been created with the option <code>nomerge=TRUE</code>. It then returns
several columns with metric values including the decomposition of the
computation according to the type of habitat of every patch.
Be careful, this option is in development and we cannot guarantee the
results are correct.</p>
</td></tr>
<tr><td><code id="graphab_metric_+3A_dist">dist</code></td>
<td>
<p>A numeric or integer value specifying the distance at which
dispersal probability is equal to <code>prob</code>. This argument is mandatory
for weighted metrics (PC, F, IF, BC, dPC, CCe, CF) but not used for others.
It is used to set <code class="reqn">\alpha</code> for computing dispersal probabilities associated
with all inter-patch distances such that dispersal probability between
patches i and j is <code class="reqn">p_{ij}= e^{-\alpha d_{ij}}</code>.</p>
</td></tr>
<tr><td><code id="graphab_metric_+3A_prob">prob</code></td>
<td>
<p>A numeric or integer value specifying the dispersal probability
at distance <code>dist</code>. By default, <code>code=0.05</code>. It is used to set
<code class="reqn">\alpha</code> (see param <code>dist</code> above).</p>
</td></tr>
<tr><td><code id="graphab_metric_+3A_beta">beta</code></td>
<td>
<p>A numeric or integer value between 0 and 1 specifying the
exponent associated with patch areas in the computation of metrics
weighted by patch area. By default, <code>beta=1</code>. When <code>beta=0</code>, patch
areas do not have any influence in the computation.</p>
</td></tr>
<tr><td><code id="graphab_metric_+3A_cost_conv">cost_conv</code></td>
<td>
<p>FALSE (default) or TRUE. Logical indicating whether numeric
<code>dist</code> values are converted from cost-distance into Euclidean distance
using a log-log linear regression. See also <code><a href="#topic+convert_cd">convert_cd</a></code>
function.</p>
</td></tr>
<tr><td><code id="graphab_metric_+3A_return_val">return_val</code></td>
<td>
<p>Logical (default = TRUE) indicating whether metric values
are returned in R (TRUE) or only stored in the patch attribute layer (FALSE)</p>
</td></tr>
<tr><td><code id="graphab_metric_+3A_proj_path">proj_path</code></td>
<td>
<p>(optional) A character string indicating the path to the
directory that contains the project directory. It should be used when the
project directory is not in the current working directory. Default is NULL.
When 'proj_path = NULL', the project directory is equal to <code>getwd()</code>.</p>
</td></tr>
<tr><td><code id="graphab_metric_+3A_alloc_ram">alloc_ram</code></td>
<td>
<p>(optional, default = NULL) Integer or numeric value
indicating RAM gigabytes allocated to the java process. Increasing this
value can speed up the computations. Too large values may not be compatible
with your machine settings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The metrics are described in Graphab 2.8 manual:
<a href="https://sourcesup.renater.fr/www/graphab/download/manual-2.8-en.pdf">https://sourcesup.renater.fr/www/graphab/download/manual-2.8-en.pdf</a>
Graphab software makes possible the computation of other metrics.
Be careful, when the same metric is computed several times, the option
<code>return=TRUE</code> is not returning the right columns. In these cases,
use <code><a href="#topic+get_graphab_metric">get_graphab_metric</a></code>.
</p>


<h3>Value</h3>

<p>If <code>return_val=TRUE</code>, the function returns a <code>data.frame</code>
with the computed metric values and the corresponding patch ID when the
metric is local or delta metric, or the numeric value of the global metric.
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
graphab_metric(proj_name = "grphb_ex",
               graph = "graph",
               metric = "PC",
               dist = 1000,
               prob = 0.05,
               beta = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='graphab_modul'>Create modules from a graph in the Graphab project</h2><span id='topic+graphab_modul'></span>

<h3>Description</h3>

<p>The function creates modules from a graph by maximising
modularity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graphab_modul(
  proj_name,
  graph,
  dist,
  prob = 0.05,
  beta = 1,
  nb = NULL,
  return = TRUE,
  proj_path = NULL,
  alloc_ram = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graphab_modul_+3A_proj_name">proj_name</code></td>
<td>
<p>A character string indicating the Graphab project name.
The project name is also the name of the project directory in which the
file proj_name.xml is.</p>
</td></tr>
<tr><td><code id="graphab_modul_+3A_graph">graph</code></td>
<td>
<p>A character string indicating the name of the graph on which
the modularity index is computed. This graph has been created with Graphab
or using <code><a href="#topic+graphab_graph">graphab_graph</a></code> function and is associated
with a link set. Only the links present in the graph and their corresponding
weights will be used in the computation, together with patch areas.</p>
</td></tr>
<tr><td><code id="graphab_modul_+3A_dist">dist</code></td>
<td>
<p>A numeric or integer value specifying the distance at which
dispersal probability is equal to <code>prob</code>. This argument is mandatory
for weighted metrics (PC, F, IF, BC, dPC, CCe, CF) but not used for others.
It is used to set <code class="reqn">\alpha</code> for computing dispersal probabilities associated
with all inter-patch distances such that dispersal probability between
patches i and j is <code class="reqn">p_{ij}= e^{-\alpha d_{ij}}</code>.</p>
</td></tr>
<tr><td><code id="graphab_modul_+3A_prob">prob</code></td>
<td>
<p>A numeric or integer value specifying the dispersal probability
at distance <code>dist</code>. By default, <code>code=0.05</code>. It is used to set
<code class="reqn">\alpha</code> (see param <code>dist</code> above).</p>
</td></tr>
<tr><td><code id="graphab_modul_+3A_beta">beta</code></td>
<td>
<p>A numeric or integer value between 0 and 1 specifying the
exponent associated with patch areas in the computation of metrics
weighted by patch area. By default, <code>beta=1</code>. When <code>beta=0</code>, patch
areas do not have any influence in the computation.</p>
</td></tr>
<tr><td><code id="graphab_modul_+3A_nb">nb</code></td>
<td>
<p>(optional, default=NULL) An integer or numeric value indicating
the number of modules to be created. By default, it is the number that
maximises the modularity index.</p>
</td></tr>
<tr><td><code id="graphab_modul_+3A_return">return</code></td>
<td>
<p>Logical (default=TRUE) indicating whether results are returned
to user.</p>
</td></tr>
<tr><td><code id="graphab_modul_+3A_proj_path">proj_path</code></td>
<td>
<p>(optional) A character string indicating the path to the
directory that contains the project directory. It should be used when the
project directory is not in the current working directory. Default is NULL.
When 'proj_path = NULL', the project directory is equal to <code>getwd()</code>.</p>
</td></tr>
<tr><td><code id="graphab_modul_+3A_alloc_ram">alloc_ram</code></td>
<td>
<p>(optional, default = NULL) Integer or numeric value
indicating RAM gigabytes allocated to the java process. Increasing this
value can speed up the computations. Too large values may not be compatible
with your machine settings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function maximises a modularity index by searching for the
node partition involves a large number of links within modules and a small
number of inter-module links. Each link is given a weight in the computation,
such as the weight <code class="reqn">w_{ij}</code> of the link between patches i and j is:
</p>
<p style="text-align: center;"><code class="reqn">w_{ij} = (a_{i} a_{j})^\beta e^{-\alpha d_{ij}}</code>
</p>
<p>.
This function does not allow users to convert automatically Euclidean
distances into cost-distances.
See more information in Graphab 2.8 manual:
<a href="https://sourcesup.renater.fr/www/graphab/download/manual-2.8-en.pdf">https://sourcesup.renater.fr/www/graphab/download/manual-2.8-en.pdf</a>
</p>


<h3>Value</h3>

<p>If <code>return=TRUE</code>, the function returns a message indicating
whether the partition has been done. New options are being developed.
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
graphab_modul(proj_name = "grphb_ex",
               graph = "graph",
               dist = 1000,
               prob = 0.05,
               beta = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='graphab_pointset'>Add a point set to the Graphab project</h2><span id='topic+graphab_pointset'></span>

<h3>Description</h3>

<p>The function adds a spatial point set to the Graphab project,
allowing users to identify closest habitat patch from each point and
get corresponding connectivity metrics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graphab_pointset(
  proj_name,
  linkset,
  pointset,
  id = "ID",
  return_val = TRUE,
  proj_path = NULL,
  alloc_ram = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graphab_pointset_+3A_proj_name">proj_name</code></td>
<td>
<p>A character string indicating the Graphab project name.
The project name is also the name of the project directory in which the
file proj_name.xml is.</p>
</td></tr>
<tr><td><code id="graphab_pointset_+3A_linkset">linkset</code></td>
<td>
<p>A character string indicating the name of the link set used.
The link set is here used to get the defined cost values and compute the
distance from the point to the patches. Link sets can be created
with <code><a href="#topic+graphab_link">graphab_link</a></code>.</p>
</td></tr>
<tr><td><code id="graphab_pointset_+3A_pointset">pointset</code></td>
<td>
<p>Can be either;</p>

<ul>
<li><p>A character string indicating the path (absolute or relative) to a
shapefile point layer
</p>
</li>
<li><p>A character string indicating the path to a .csv file with three
columns: ID, x and y, respectively indicating the point ID, longitude
and latitude.
</p>
</li>
<li><p>A data.frame with three columns:
ID, x and y, respectively indicating the point ID, longitude and latitude.
</p>
</li>
<li><p>A SpatialPointsDataFrame
</p>
</li></ul>

<p>The point ID column must be 'ID' by default but can also be specified
by the <code>id</code> argument in all three cases.</p>
</td></tr>
<tr><td><code id="graphab_pointset_+3A_id">id</code></td>
<td>
<p>A character string indicating the name of the column in either
the .csv table, data.frame or attribute table, corresponding to the ID
of the points. By default, it should be 'ID'. This column is used for naming
the points when returning the output.</p>
</td></tr>
<tr><td><code id="graphab_pointset_+3A_return_val">return_val</code></td>
<td>
<p>Logical (default=TRUE) indicating whether the metrics
associated with closest habitat patches from the points are returned to
users.</p>
</td></tr>
<tr><td><code id="graphab_pointset_+3A_proj_path">proj_path</code></td>
<td>
<p>(optional) A character string indicating the path to the
directory that contains the project directory. It should be used when the
project directory is not in the current working directory. Default is NULL.
When 'proj_path = NULL', the project directory is equal to <code>getwd()</code>.</p>
</td></tr>
<tr><td><code id="graphab_pointset_+3A_alloc_ram">alloc_ram</code></td>
<td>
<p>(optional, default = NULL) Integer or numeric value
indicating RAM gigabytes allocated to the java process. Increasing this
value can speed up the computations. Too large values may not be compatible
with your machine settings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Point coordinates must be in the same coordinate reference system
as the habitat patches (and initial raster layer). See more information in
Graphab 2.8 manual:
<a href="https://sourcesup.renater.fr/www/graphab/download/manual-2.8-en.pdf">https://sourcesup.renater.fr/www/graphab/download/manual-2.8-en.pdf</a>
</p>


<h3>Value</h3>

<p>If <code>return_val=TRUE</code>, the function returns a <code>data.frame</code>
with the properties of the nearest patch to every point in the point set,
as well as the distance from each point to the nearest patch.
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
graphab_pointset(proj_name = "grphb_ex",
               graph = "graph",
               pointset = "pts.shp")

## End(Not run)
</code></pre>

<hr>
<h2 id='graphab_project'>Create a Graphab project</h2><span id='topic+graphab_project'></span>

<h3>Description</h3>

<p>The function creates a Graphab project from a raster file on
which habitat patches can be delimited.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graphab_project(
  proj_name,
  raster,
  habitat,
  nomerge = FALSE,
  minarea = 0,
  nodata = NULL,
  maxsize = NULL,
  con8 = FALSE,
  alloc_ram = NULL,
  proj_path = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graphab_project_+3A_proj_name">proj_name</code></td>
<td>
<p>A character string indicating the Graphab project name.
The project name is also the name of the project directory in which the
file proj_name.xml will be created.</p>
</td></tr>
<tr><td><code id="graphab_project_+3A_raster">raster</code></td>
<td>
<p>A character string indicating the name of the .tif raster file
or of its path. If the path is not specified, the raster must be present in
the current working directory. Raster cell values must be in INT2S encoding.</p>
</td></tr>
<tr><td><code id="graphab_project_+3A_habitat">habitat</code></td>
<td>
<p>An integer or numeric value or vector indicating the
code.s (cell value.s) of the habitat cells in the raster file.</p>
</td></tr>
<tr><td><code id="graphab_project_+3A_nomerge">nomerge</code></td>
<td>
<p>(optional, default=FALSE) A logical indicating whether
contiguous patches corresponding to different pixel codes are merged
(FALSE, default) or not merged (TRUE).
Be careful, the <code>nomerge = TRUE</code> option is in development and we cannot
guarantee the results are correct.</p>
</td></tr>
<tr><td><code id="graphab_project_+3A_minarea">minarea</code></td>
<td>
<p>(optional, default=0) An integer or numeric value specifiying
the minimum area in hectares for a habitat patch size to become a graph node.</p>
</td></tr>
<tr><td><code id="graphab_project_+3A_nodata">nodata</code></td>
<td>
<p>(optional, default=NULL) An integer or numeric value
specifying the code in the raster file associated with nodata value
(often corresponding to peripheric cells)</p>
</td></tr>
<tr><td><code id="graphab_project_+3A_maxsize">maxsize</code></td>
<td>
<p>(optional, default=NULL) An integer or numeric value
specifying the maximum side length of the rectangular full extent of each
habitat patch in metric units. If this side length exceeds <code>maxsize</code> m,
then several patches are created.
(often corresponding to peripheric cells)</p>
</td></tr>
<tr><td><code id="graphab_project_+3A_con8">con8</code></td>
<td>
<p>(optional, default=FALSE) A logical indicating whether a
neighborhood of 8 pixels (TRUE) is used for patch definition. By default,
<code>con8=4</code>, corresponding to 4 pixel neighborhood.</p>
</td></tr>
<tr><td><code id="graphab_project_+3A_alloc_ram">alloc_ram</code></td>
<td>
<p>(optional, default = NULL) Integer or numeric value
indicating RAM gigabytes allocated to the java process. Increasing this
value can speed up the computations. Too large values may not be compatible
with your machine settings.</p>
</td></tr>
<tr><td><code id="graphab_project_+3A_proj_path">proj_path</code></td>
<td>
<p>(optional) A character string indicating the path to the
directory that contains the project directory. It should be used when the
project directory is not in the current working directory. Default is NULL.
When 'proj_path = NULL', the project directory is equal to <code>getwd()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A habitat patch consists of the central pixel with its eight
neighbors if they are of the same value (8-connexity) and the path
geometry is not simplified. See more information in Graphab 2.8 manual:
<a href="https://sourcesup.renater.fr/www/graphab/download/manual-2.8-en.pdf">https://sourcesup.renater.fr/www/graphab/download/manual-2.8-en.pdf</a>
</p>


<h3>Author(s)</h3>

<p>P. Savary, T. Rudolph
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
proj_name &lt;- "grphb_ex"
raster &lt;- "rast_ex.tif"
habitat &lt;- 5
graphab_project(proj_name = proj_name,
               raster = raster,
               habitat = habitat)

## End(Not run)
</code></pre>

<hr>
<h2 id='graphab_project_desc'>Describe the objects of a Graphab project</h2><span id='topic+graphab_project_desc'></span>

<h3>Description</h3>

<p>The function describes the objects of a Graphab project
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graphab_project_desc(
  proj_name,
  mode = "patches",
  linkset = NULL,
  proj_path = NULL,
  fig = FALSE,
  return_val = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graphab_project_desc_+3A_proj_name">proj_name</code></td>
<td>
<p>A character string indicating the Graphab project name.
The project name is also the name of the project directory in which the
file proj_name.xml is.</p>
</td></tr>
<tr><td><code id="graphab_project_desc_+3A_mode">mode</code></td>
<td>
<p>A character string indicating the objects of the project that
are described. It must be either:</p>

<ul>
<li><p><code>mode='patches'</code>(default): The habitat patches are described
with synthetic descriptors (code, number, mean capacity, median capacity,
capacity harmonic mean, capacity Gini coefficient) and a histogram of
capacity distribution.
</p>
</li>
<li><p><code>mode='linkset'</code>: The links of a link set are described
with synthetic descriptors (codes, costs, number, mean cost distance,
median cost distance, cost distance harmonic mean, cost distance Gini
coefficient) and a histogram of cost distance distribution.
</p>
</li>
<li><p><code>mode='both'</code>: Both the patches and links of a linkset are
described
</p>
</li></ul>
</td></tr>
<tr><td><code id="graphab_project_desc_+3A_linkset">linkset</code></td>
<td>
<p>A character string indicating the name of the link set
whose properties are imported. The link set has been created with Graphab
or using <code><a href="#topic+graphab_link">graphab_link</a></code> function.</p>
</td></tr>
<tr><td><code id="graphab_project_desc_+3A_proj_path">proj_path</code></td>
<td>
<p>(optional) A character string indicating the path to the
directory that contains the project directory. It should be used when the
project directory is not in the current working directory. Default is NULL.
When 'proj_path = NULL', the project directory is equal to <code>getwd()</code>.</p>
</td></tr>
<tr><td><code id="graphab_project_desc_+3A_fig">fig</code></td>
<td>
<p>Logical (default = FALSE) indicating whether to plot a figure of
the resulting spatial graph. The figure is plotted using function
<code><a href="#topic+plot_graph_lg">plot_graph_lg</a></code>. The plotting can be long if the graph has many
nodes and links.</p>
</td></tr>
<tr><td><code id="graphab_project_desc_+3A_return_val">return_val</code></td>
<td>
<p>Logical (default = TRUE) indicating whether the project
features are returned as a list (TRUE) or only displayed in the
R console (FALSE).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
graphab_project_desc(proj_name = "grphb_ex",
                     mode = "patches",
                     fig = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='graphab_to_igraph'>Create landscape graphs from Graphab link set</h2><span id='topic+graphab_to_igraph'></span>

<h3>Description</h3>

<p>The function creates a landscape graph from a link set created
with Graphab software or different functions of this package and converts
it into a graph object of class <code>igraph</code>.
The graph has weighted links and is undirected.
Nodes attributes present in the Graphab project are included, including
connectivity metrics when computed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graphab_to_igraph(
  proj_name,
  linkset,
  nodes = "patches",
  weight = "cost",
  proj_path = NULL,
  fig = FALSE,
  crds = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graphab_to_igraph_+3A_proj_name">proj_name</code></td>
<td>
<p>A character string indicating the project name. It is also
the name of the directory in which proj_name.xml file is found. By default,
'proj_name' is searched into the current working directory</p>
</td></tr>
<tr><td><code id="graphab_to_igraph_+3A_linkset">linkset</code></td>
<td>
<p>A character string indicating the name of the linkset used to
create the graph links. The linkset must have been created previously (see
the function <code><a href="#topic+graphab_link">graphab_link</a></code>). It can be complete or planar. The
graph is given the topology of the selected link set.</p>
</td></tr>
<tr><td><code id="graphab_to_igraph_+3A_nodes">nodes</code></td>
<td>
<p>A character string indicating whether the nodes of the created
graph are given all the attributes or metrics computed in Graphab or only
those specific to a given graph previously created with
<code><a href="#topic+graphab_graph">graphab_graph</a></code>
It can be:</p>

<ul>
<li><p><code>nodes = "patches"</code>(default): all the attributes and metrics of
the habitat patches are included as node attributes in <code>igraph</code> object.
</p>
</li>
<li><p><code>nodes = "graph_name"</code>(default): only the metrics of
the habitat patches computed from the graph 'graph_name' created with
<code><a href="#topic+graphab_graph">graphab_graph</a></code> are included as node attributes in
<code>igraph</code> object, along with some basic patch attributes.
</p>
</li></ul>
</td></tr>
<tr><td><code id="graphab_to_igraph_+3A_weight">weight</code></td>
<td>
<p>A character string (&quot;euclid&quot; or &quot;cost&quot;) indicating
whether to weight the links with Euclidean distance or
cost-distance (default) values.</p>
</td></tr>
<tr><td><code id="graphab_to_igraph_+3A_proj_path">proj_path</code></td>
<td>
<p>(optional) A character string indicating the path to the
directory that contains the project directory ('proj_name'). By default,
'proj_name' is searched into the current working directory</p>
</td></tr>
<tr><td><code id="graphab_to_igraph_+3A_fig">fig</code></td>
<td>
<p>Logical (default = FALSE) indicating whether to plot a figure of
the resulting spatial graph. The figure is plotted using function
<code><a href="#topic+plot_graph_lg">plot_graph_lg</a></code>. The plotting can be long if the graph has many
nodes and links.</p>
</td></tr>
<tr><td><code id="graphab_to_igraph_+3A_crds">crds</code></td>
<td>
<p>Logical (default = FALSE) indicating whether to create an object
of class <code>data.frame</code> with the node centroid spatial coordinates. Such a
<code>data.frame</code> has 3 columns: 'ID', 'x', 'y'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A graph object of class <code>igraph</code> (if crds = FALSE) or a
list of objects: a graph object of class <code>igraph</code> and a
<code>data.frame</code> with the nodes spatial coordinates (if crds = TRUE).
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>References</h3>

<p>FoltÃªte J, Clauzel C, Vuidel G (2012).
&ldquo;A software tool dedicated to the modelling of landscape networks.&rdquo;
<em>Environmental Modelling &amp; Software</em>, <b>38</b>, 316&ndash;327.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
proj_path &lt;- system.file('extdata',package='graph4lg')
proj_name &lt;- "grphb_ex"
linkset &lt;- "lkst1"
nodes &lt;- "graph"
graph &lt;- graphab_to_igraph(proj_name = proj_name,
                           linkset = "lkst1",
                           nodes = "graph",
                           links = links,
                           weights = "cost",
                           proj_path = proj_path,
                           crds = FALSE,
                           fig = FALSE)
                           
## End(Not run)
</code></pre>

<hr>
<h2 id='gstud_to_genind'>Convert a file from <span class="pkg">gstudio</span> or <span class="pkg">popgraph</span> into a genind object</h2><span id='topic+gstud_to_genind'></span>

<h3>Description</h3>

<p>The function converts a file formatted to use <span class="pkg">gstudio</span> or
<span class="pkg">popgraph</span> package into a genind object (<span class="pkg">adegenet</span> package)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gstud_to_genind(x, pop_col, ind_col = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gstud_to_genind_+3A_x">x</code></td>
<td>
<p>An object of class <code>data.frame</code> with loci columns in
format <code>locus</code> (defined in package <span class="pkg">gstudio</span>) with as many rows as
individuals and as many columns in format <code>locus</code> as there are loci and
additional columns</p>
</td></tr>
<tr><td><code id="gstud_to_genind_+3A_pop_col">pop_col</code></td>
<td>
<p>A character string indicating the name of the column with
populations' names in <code>x</code></p>
</td></tr>
<tr><td><code id="gstud_to_genind_+3A_ind_col">ind_col</code></td>
<td>
<p>(optional) A character string indicating the name of the
column with individuals' ID in <code>x</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses functions from <span class="pkg">pegas</span> package.
It can handle genetic data where alleles codings do not have same length,
(99:101, for example).
If the names of the loci include '.' characters, they will
be replaced by '_'.
</p>


<h3>Value</h3>

<p>An object of class <code>genind</code>.
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("data_ex_gstud")
x &lt;- data_ex_gstud
pop_col &lt;- "POP"
ind_col &lt;- "ID"
data_genind &lt;- gstud_to_genind(x, pop_col, ind_col)
</code></pre>

<hr>
<h2 id='harm_mean'>Compute the harmonic mean of a numeric vector</h2><span id='topic+harm_mean'></span>

<h3>Description</h3>

<p>The function computes the harmonic mean of a numeric vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>harm_mean(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="harm_mean_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value corresponding to the harmonic mean of the vector
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(10, 2, 5, 15)
hm &lt;- harm_mean(x)
</code></pre>

<hr>
<h2 id='kernel_param'>Compute dispersal kernel parameters</h2><span id='topic+kernel_param'></span>

<h3>Description</h3>

<p>The function computes the constant parameters of a dispersal
kernel with a negative exponential distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel_param(p, d_disp, mode = "A")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kernel_param_+3A_p">p</code></td>
<td>
<p>A numeric value indicating the dispersal probability at a distance
equal to 'd_disp' under a negative exponential distribution.</p>
</td></tr>
<tr><td><code id="kernel_param_+3A_d_disp">d_disp</code></td>
<td>
<p>A numeric value indicating the distance to which dispersal
probability is equal to 'p' under a negative exponential distribution.</p>
</td></tr>
<tr><td><code id="kernel_param_+3A_mode">mode</code></td>
<td>
<p>A character string indicating the value to return:
</p>

<ul>
<li><p>If 'mode = 'A&rdquo; (default), the returned value 'alpha' is such that
exp(-alpha * d_disp) = p
</p>
</li>
<li><p>If 'mode = 'B&rdquo;, the returned value 'alpha' is such that
10(-alpha * d_disp) = p
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>If the resulting parameter when mode = &quot;A&quot; is a and the resulting
parameter when mode = &quot;B&quot; is b, then we have:
p = exp(-a.d_disp) = 10^(-b.d_disp) and a = b.ln(10)
</p>


<h3>Value</h3>

<p>A numeric value
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- 0.5
d_disp &lt;- 3000
alpha &lt;- kernel_param(p, d_disp, mode = "A")
</code></pre>

<hr>
<h2 id='link_compar'>Compare two link sets created in a Graphab project</h2><span id='topic+link_compar'></span>

<h3>Description</h3>

<p>The function compares two link sets created in a Graphab project
both quantitatively and spatially.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>link_compar(
  proj_name,
  linkset1,
  linkset2,
  buffer_width = 200,
  min_length = NULL,
  proj_path = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="link_compar_+3A_proj_name">proj_name</code></td>
<td>
<p>A character string indicating the Graphab project name.
The project name is also the name of the project directory in which the
file proj_name.xml is. It can be created with <code><a href="#topic+graphab_project">graphab_project</a></code></p>
</td></tr>
<tr><td><code id="link_compar_+3A_linkset1">linkset1</code></td>
<td>
<p>A character string indicating the name of the first link set
involved in the comparison. The link set has to be present in the project
and can be created with <code><a href="#topic+graphab_link">graphab_link</a></code>.</p>
</td></tr>
<tr><td><code id="link_compar_+3A_linkset2">linkset2</code></td>
<td>
<p>A character string indicating the name of the second link set
involved in the comparison. The link set has to be present in the project
and can be created with <code><a href="#topic+graphab_link">graphab_link</a></code>.</p>
</td></tr>
<tr><td><code id="link_compar_+3A_buffer_width">buffer_width</code></td>
<td>
<p>(default=200) An integer or numeric value
indicating the width of the buffer created in each side of the links prior
to spatial intersection. It is expressed in meters.</p>
</td></tr>
<tr><td><code id="link_compar_+3A_min_length">min_length</code></td>
<td>
<p>(optional, default=NULL) An integer or numeric value
indicating the minimum length in meters of the links to be compared. Links
whose length is larger than <code>min_length</code> will be ignored in
the comparison.</p>
</td></tr>
<tr><td><code id="link_compar_+3A_proj_path">proj_path</code></td>
<td>
<p>(optional, default=NULL) A character string indicating the
path to the directory that contains the project directory. It should be used
when the project directory is not in the current working directory.
Default is NULL. When 'proj_path = NULL', the project directory is equal
to <code>getwd()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function compares two link sets linking the same habitat patches
of the Graphab project but computed using different cost scenarios. It
creates a buffer in each side of every link and then overlaps every link
in linkset1 with the same link in linkset2. It returns the area of both
buffered links and the area of their intersection. It also computes the
Mantel correlation coefficient between the cost distances associated to the
same links in both linksets.
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
link_compar(proj_name = "grphb_ex",
              linkset1 = "lcp1",
              linkset2 = "lcp2"
              buffer_width = 200)

## End(Not run)
</code></pre>

<hr>
<h2 id='loci_to_genind'>Convert a loci object into a genind object</h2><span id='topic+loci_to_genind'></span>

<h3>Description</h3>

<p>This function is exactly the same as <code>loci2genind</code>
from <span class="pkg">pegas</span> package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loci_to_genind(x, ploidy = 2, na.alleles = c("NA"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loci_to_genind_+3A_x">x</code></td>
<td>
<p>An object of class <code>loci</code> to convert</p>
</td></tr>
<tr><td><code id="loci_to_genind_+3A_ploidy">ploidy</code></td>
<td>
<p>An integer indicating the ploidy level
(by default, 'ploidy = 2')</p>
</td></tr>
<tr><td><code id="loci_to_genind_+3A_na.alleles">na.alleles</code></td>
<td>
<p>A character vector indicating the coding of the alleles
to be treated as missing data (by default, 'na.alleles = c(&quot;NA&quot;)')</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>genind</code>
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("data_ex_loci")
genind &lt;- loci_to_genind(data_ex_loci, ploidy = 2, na.alleles = "NA")
</code></pre>

<hr>
<h2 id='mat_cost_dist'>Compute cost distances between points on a raster</h2><span id='topic+mat_cost_dist'></span>

<h3>Description</h3>

<p>The function computes cost-distances associated to least cost
paths between point pairs on a raster with specified cost values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat_cost_dist(
  raster,
  pts,
  cost,
  method = "gdistance",
  return = "mat",
  direction = 8,
  parallel.java = 1,
  alloc_ram = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mat_cost_dist_+3A_raster">raster</code></td>
<td>
<p>A parameter indicating the raster file on which cost distances
are computed. It can be:</p>

<ul>
<li><p>A character string indicating the path to a raster file in format
.tif or .asc.
</p>
</li>
<li><p>A <code>RasterLayer</code> object already loaded in R environment
</p>
</li></ul>

<p>All the raster cell values must be present in the column 'code' from
<code>cost</code> argument.</p>
</td></tr>
<tr><td><code id="mat_cost_dist_+3A_pts">pts</code></td>
<td>
<p>A parameter indicating the points between which cost distances
are computed. It can be either: </p>

<ul>
<li><p>A character string indicating the path to a .csv file. It must have
three columns:</p>

<ul>
<li><p>ID: The ID of the points.
</p>
</li>
<li><p>x: A numeric or integer indicating the longitude of the points.
</p>
</li>
<li><p>y: A numeric or integer indicating the latitude of the points.
</p>
</li></ul>

</li>
<li><p>A <code>data.frame</code> with the spatial coordinates of the points.
It must have three columns:</p>

<ul>
<li><p>ID: The ID of the points.
</p>
</li>
<li><p>x: A numeric or integer indicating the longitude of the points.
</p>
</li>
<li><p>y: A numeric or integer indicating the latitude of the points.
</p>
</li></ul>

</li>
<li><p>A <code>SpatialPointsDataFrame</code> with at least an attribute column
named &quot;ID&quot; with the point IDs.
</p>
</li></ul>

<p>The point coordinates must be in the same spatial coordinate reference system
as the raster file.</p>
</td></tr>
<tr><td><code id="mat_cost_dist_+3A_cost">cost</code></td>
<td>
<p>A <code>data.frame</code> indicating the cost values associated to each
raster value. It must have two columns:</p>

<ul>
<li><p>'code': raster cell values
</p>
</li>
<li><p>'cost': corresponding cost values
</p>
</li></ul>
</td></tr>
<tr><td><code id="mat_cost_dist_+3A_method">method</code></td>
<td>
<p>A character string indicating the method used to compute the
cost distances. It must be:</p>

<ul>
<li><p>'gdistance': uses the functions from the package <span class="pkg">gdistance</span>
assuming that movement is possible in 8 directions from each cell, that
a geo-correction is applied to correct for diagonal movement lengths and that
raster cell values correspond to resistance (and not conductance).
</p>
</li>
<li><p>'java': uses a .jar file which is downloaded on the user's machine if
necessary and if java is installed. This option substantially reduces
computation times and makes possible the parallelisation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mat_cost_dist_+3A_return">return</code></td>
<td>
<p>A character string indicating whether the returned object is a
<code>data.frame</code> (<code>return="df"</code>) or a pairwise
<code>matrix</code> (<code>return="mat"</code>).</p>
</td></tr>
<tr><td><code id="mat_cost_dist_+3A_direction">direction</code></td>
<td>
<p>An integer (4, 8, 16) indicating the directions in which
movement can take place from a cell. Only used when <code>method="gdistance"</code>.
By default, <code>direction=8</code>.</p>
</td></tr>
<tr><td><code id="mat_cost_dist_+3A_parallel.java">parallel.java</code></td>
<td>
<p>An integer indicating how many computer cores are used
to run the .jar file. By default, <code>parallel.java=1</code>.</p>
</td></tr>
<tr><td><code id="mat_cost_dist_+3A_alloc_ram">alloc_ram</code></td>
<td>
<p>(optional, default = NULL) Integer or numeric value
indicating RAM gigabytes allocated to the java process when used. Increasing
this value can speed up the computations. Too large values may not be
compatible with your machine settings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns:</p>

<ul>
<li><p>If <code>return="mat"</code>, a pairwise <code>matrix</code> with cost-distance
values between points.
</p>
</li>
<li><p>If <code>return="df"</code>, an object of type <code>data.frame</code> with three columns:
</p>

<ul>
<li><p>from: A character string indicating the ID of the point of origin.
</p>
</li>
<li><p>to: A character string indicating the ID of the point of destination.
</p>
</li>
<li><p>cost_dist: A numeric indicating the accumulated cost-distance along
the least-cost path between point ID1 and point ID2.
</p>
</li></ul>


</li></ul>



<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- raster::raster(ncol=10, nrow=10, xmn=0, xmx=100, ymn=0, ymx=100)
raster::values(x) &lt;- sample(c(1,2,3,4), size = 100, replace = TRUE)
pts &lt;- data.frame(ID = 1:4,
                  x = c(10, 90, 10, 90),
                  y = c(90, 10, 10, 90))
cost &lt;- data.frame(code = 1:4,
                   cost = c(1, 10, 100, 1000))
mat_cost_dist(raster = x,
              pts = pts, cost = cost,
              method = "gdistance")

## End(Not run)
</code></pre>

<hr>
<h2 id='mat_gen_dist'>Compute a pairwise matrix of genetic distances between populations</h2><span id='topic+mat_gen_dist'></span>

<h3>Description</h3>

<p>The function computes a pairwise matrix of genetic distances
between populations and allows to implement several formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat_gen_dist(x, dist = "basic", null_val = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mat_gen_dist_+3A_x">x</code></td>
<td>
<p>An object of class <code>genind</code> that contains the multilocus
genotypes (format 'locus') of the individuals as well as their populations.</p>
</td></tr>
<tr><td><code id="mat_gen_dist_+3A_dist">dist</code></td>
<td>
<p>A character string indicating the method used to compute the
multilocus genetic distance between populations
</p>

<ul>
<li><p>If 'dist = 'basic&rdquo; (default), then the multilocus genetic distance is
computed using a formula of Euclidean genetic
distance (Excoffier et al., 1992)
</p>
</li>
<li><p>If 'dist = 'weight&rdquo;, then the multilocus genetic distance is computed
as in Fortuna et al. (2009). It is a Euclidean genetic distance giving more
weight to rare alleles
</p>
</li>
<li><p>If 'dist = 'PG&rdquo;, then the multilocus genetic distance is computed as
in popgraph::popgraph function, following several steps of PCA and SVD
(Dyer et Nason, 2004).
</p>
</li>
<li><p>If 'dist = 'DPS&rdquo;, then the genetic distance used is equal to
1 - the proportion of shared alleles (Bowcock, 1994)
</p>
</li>
<li><p>If 'dist = 'FST&rdquo;, then the genetic distance used is the pairwise
FST (Weir et Cockerham, 1984)
</p>
</li>
<li><p>If 'dist = 'FST_lin&rdquo;, then the genetic distance used is the linearised
pairwise FST (Weir et Cockerham, 1984)(FST_lin = FST/(1-FST))
</p>
</li>
<li><p>If 'dist = 'PCA&rdquo;, then the genetic distance is computed following a
PCA of the matrix of allelic frequencies by population. It is a
Euclidean genetic distance between populations in the multidimensional
space defined by all the independent principal components.
</p>
</li>
<li><p>If 'dist = 'GST&rdquo;, then the genetic distance used is the
G'ST (Hedrick, 2005). See graph4lg &lt;= 1.6.0 only, because it used diveRsity
</p>
</li>
<li><p>If 'dist = 'D&rdquo;, then the genetic distance used is
Jost's D (Jost, 2008). See graph4lg &lt;= 1.6.0 only, because it used diveRsity
</p>
</li></ul>
</td></tr>
<tr><td><code id="mat_gen_dist_+3A_null_val">null_val</code></td>
<td>
<p>(optional) Logical. Should negative and null FST, FST_lin,
GST or D values be replaced by half the minimum positive value?
This option allows to compute Gabriel graphs from these &quot;distances&quot;.
Default is null_val = FALSE.
This option only works if 'dist = 'FST&rdquo; or 'FST_lin' or 'GST' or 'D'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Negative values are converted into 0.
Euclidean genetic distance <code class="reqn">d_{ij}</code> between population i and j
is computed as follows:
</p>
<p style="text-align: center;"><code class="reqn">d_{ij}^{2} = \sum_{k=1}^{n} (x_{ki} - x_{kj})^{2} </code>
</p>
<p> where
<code class="reqn">x_{ki}</code> is the allelic frequency of allele k in population i and n is
the total number of alleles. Note that when 'dist = 'weight&rdquo;, the formula
becomes </p>
<p style="text-align: center;"><code class="reqn">d_{ij}^{2} = \sum_{k=1}^{n} (1/(K*p_{k}))(x_{ki} - x_{kj})^{2}</code>
</p>

<p>where K is the number of alleles at the locus of the allele k and <code class="reqn">p_{k}</code>
is the frequency of the allele k in all populations.
Note that when 'dist = 'PCA&rdquo;, n is the number of conserved independent
principal components and <code class="reqn">x_{ki}</code> is the value taken by the principal
component k in population i.
</p>


<h3>Value</h3>

<p>An object of class <code>matrix</code>
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>References</h3>

<p>Bowcock AM, Ruiz-Linares A, Tomfohrde J, Minch E, Kidd JR, Cavalli-Sforza LL (1994).
&ldquo;High resolution of human evolutionary trees with polymorphic microsatellites.&rdquo;
<em>nature</em>, <b>368</b>(6470), 455&ndash;457.
Excoffier L, Smouse PE, Quattro JM (1992).
&ldquo;Analysis of molecular variance inferred from metric distances among DNA haplotypes: application to human mitochondrial DNA restriction data.&rdquo;
<em>Genetics</em>, <b>131</b>(2), 479&ndash;491.
Dyer RJ, Nason JD (2004).
&ldquo;Population graphs: the graph theoretic shape of genetic structure.&rdquo;
<em>Molecular ecology</em>, <b>13</b>(7), 1713&ndash;1727.
Fortuna MA, Albaladejo RG, FernÃ¡ndez L, Aparicio A, Bascompte J (2009).
&ldquo;Networks of spatial genetic variation across species.&rdquo;
<em>Proceedings of the National Academy of Sciences</em>, <b>106</b>(45), 19044&ndash;19049.
Weir BS, Cockerham CC (1984).
&ldquo;Estimating F-statistics for the analysis of population structure.&rdquo;
<em>evolution</em>, <b>38</b>(6), 1358&ndash;1370.
Hedrick PW (2005).
&ldquo;A standardized genetic differentiation measure.&rdquo;
<em>Evolution</em>, <b>59</b>(8), 1633&ndash;1638.
Jost L (2008).
&ldquo;GST and its relatives do not measure differentiation.&rdquo;
<em>Molecular ecology</em>, <b>17</b>(18), 4015&ndash;4026.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(data_ex_genind)
x &lt;- data_ex_genind
D &lt;- mat_gen_dist(x = x, dist = "basic")
</code></pre>

<hr>
<h2 id='mat_geo_dist'>Compute Euclidean geographic distances between points</h2><span id='topic+mat_geo_dist'></span>

<h3>Description</h3>

<p>The function computes Euclidean geographic distance between
points given their spatial coordinates either in a metric projected
Coordinate Reference System or in a polar coordinates system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat_geo_dist(
  data,
  ID = NULL,
  x = NULL,
  y = NULL,
  crds_type = "proj",
  gc_formula = "vicenty"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mat_geo_dist_+3A_data">data</code></td>
<td>
<p>An object of class :</p>

<ul>
<li> <p><code>data.frame</code> with 3 columns: 2 columns with the point spatial
coordinates and another column with point IDs
</p>
</li>
<li> <p><code>SpatialPointsDataFrame</code> </p>
</li></ul>
</td></tr>
<tr><td><code id="mat_geo_dist_+3A_id">ID</code></td>
<td>
<p>(if <code>data</code> is of class <code>data.frame</code>) A character string
indicating the name of the column of <code>data</code> with the point IDs</p>
</td></tr>
<tr><td><code id="mat_geo_dist_+3A_x">x</code></td>
<td>
<p>(if <code>data</code> is of class <code>data.frame</code>) A character string
indicating the name of the column of <code>data</code> with the point longitude</p>
</td></tr>
<tr><td><code id="mat_geo_dist_+3A_y">y</code></td>
<td>
<p>(if <code>data</code> is of class <code>data.frame</code>) A character string
indicating the name of the column of <code>data</code> with the point latitude</p>
</td></tr>
<tr><td><code id="mat_geo_dist_+3A_crds_type">crds_type</code></td>
<td>
<p>A character string indicating the type of coordinate
reference system:</p>

<ul>
<li><p>'proj' (default): a projected coordinate reference system
</p>
</li>
<li><p>'polar': a polar coordinate reference system, such as WGS84
</p>
</li></ul>
</td></tr>
<tr><td><code id="mat_geo_dist_+3A_gc_formula">gc_formula</code></td>
<td>
<p>A character string indicating the formula used to compute
the Great Circle distance:</p>

<ul>
<li><p>'vicenty'(default): Vincenty inverse formula for ellipsoids
</p>
</li>
<li><p>'slc': Spherical Law of Cosines
</p>
</li>
<li><p>'hvs': Harversine formula
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>When a projected coordinate reference system is used, it calculates
classical Euclidean geographic distance between two points using
Pythagora's theorem. When a polar coordinate reference system is used, it
calculates the Great circle distance between points using different methods.
Unless <code>method = "polar"</code>, when <code>data</code> is a <code>data.frame</code>,
it assumes projected coordinates by default.
</p>


<h3>Value</h3>

<p>A pairwise matrix of geographic distances between points in meters
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Projected CRS
data(pts_pop_simul)
mat_dist &lt;- mat_geo_dist(data=pts_pop_simul,
             ID = "ID",
             x = "x",
             y = "y")

#Polar CRS
city_us &lt;- data.frame(name = c("New York City", "Chicago",
                               "Los Angeles", "Atlanta"),
                      lat  = c(40.75170,  41.87440,
                               34.05420,  33.75280),
                      lon  = c(-73.99420, -87.63940,
                              -118.24100, -84.39360))
mat_geo_us &lt;- mat_geo_dist(data = city_us,
                           ID = "name", x = "lon", y = "lat",
                           crds_type = "polar")
</code></pre>

<hr>
<h2 id='mat_pw_dps'>Compute a pairwise genetic distance matrix between populations
using Bowcock et al. (1994) formula</h2><span id='topic+mat_pw_dps'></span>

<h3>Description</h3>

<p>The function computes the pairwise DPS, a genetic distance
based on the proportion of shared alleles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat_pw_dps(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mat_pw_dps_+3A_x">x</code></td>
<td>
<p>An object of class <code>genind</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The formula used is inspired from MSA software :
</p>
<p style="text-align: center;"><code class="reqn">D_{PS}=1-\frac{\sum_{d}^{D}\sum_{k}^{K}\min (f_{a_{kd}i},f_{a_{kd}j})}{D} </code>
</p>

<p>such as <code class="reqn">a_{kd}</code> is the allele <code class="reqn">k</code> at locus <code class="reqn">d</code>
<code class="reqn">D</code> is the total number of loci
<code class="reqn">K</code> is the allele number at each locus
<code class="reqn">\gamma_{a_{kd^{ij}}}=0</code> if individuals <code class="reqn">i</code> and <code class="reqn">j</code>
do not share allele <code class="reqn">a_{kd}</code>
<code class="reqn">\gamma_{a_{kd^{ij}}}=1</code> if one of individuals <code class="reqn">i</code> and <code class="reqn">j</code>
has a copy of <code class="reqn">a_{kd}</code>
<code class="reqn">\gamma_{a_{kd^{ij}}}=2</code> if both individuals have 2 copies
of <code class="reqn">a_{kd}</code> (homozygotes)
<code class="reqn">f_{a_{kd}i}</code> is allele <code class="reqn">a_{kd}</code> frequency in
individual <code class="reqn">i</code> (0, 0.5 or 1).
More information in :
<a href="https://pubmed.ncbi.nlm.nih.gov/7510853/">Bowcock et al., 1994</a>
and Microsatellite Analyser software (MSA) manual.
This function uses functions from <span class="pkg">adegenet</span> package
Note that in the paper of Bowcock et al. (1994), the denominator is 2D.
But, in MSA software manual, the denominator is D.
</p>


<h3>Value</h3>

<p>A pairwise matrix of genetic distances between populations
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>References</h3>

<p>Bowcock AM, Ruiz-Linares A, Tomfohrde J, Minch E, Kidd JR, Cavalli-Sforza LL (1994).
&ldquo;High resolution of human evolutionary trees with polymorphic microsatellites.&rdquo;
<em>nature</em>, <b>368</b>(6470), 455&ndash;457.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("data_ex_genind")
dist_bowcock &lt;- mat_pw_dps(data_ex_genind)
</code></pre>

<hr>
<h2 id='mat_pw_fst'>Compute a pairwise FST matrix between populations</h2><span id='topic+mat_pw_fst'></span>

<h3>Description</h3>

<p>The function computes the pairwise FST matrix between
populations from an object of class <code>genind</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat_pw_fst(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mat_pw_fst_+3A_x">x</code></td>
<td>
<p>An object of class <code>genind</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The formula used is that of Weir et Cockerham (1984).
This functions uses directly the function <code>pairwise.WCfst</code>
from <span class="pkg">hierfstat</span>.
</p>


<h3>Value</h3>

<p>A pairwise <code>matrix</code> of FST with as many rows and columns as
there are populations in the input data.
</p>


<h3>Warnings</h3>

<p>Negative values are converted into 0
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>References</h3>

<p>Weir BS, Cockerham CC (1984).
&ldquo;Estimating F-statistics for the analysis of population structure.&rdquo;
<em>evolution</em>, <b>38</b>(6), 1358&ndash;1370.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("data_ex_genind")
mat_fst &lt;- mat_pw_fst(data_ex_genind)

## End(Not run)
</code></pre>

<hr>
<h2 id='mypalette'>Vector of custom colors</h2><span id='topic+mypalette'></span>

<h3>Description</h3>

<p>Vector of custom colors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mypalette
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 27.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mypalette[1]
</code></pre>

<hr>
<h2 id='patch_areas'>Extract patch areas from a categorical raster</h2><span id='topic+patch_areas'></span>

<h3>Description</h3>

<p>The function extracts patch areas from a categorical raster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>patch_areas(raster, class, edge_size = 0, neighborhood = 8, surf_min = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="patch_areas_+3A_raster">raster</code></td>
<td>
<p>A RasterLayer object corresponding to a categorical raster layer</p>
</td></tr>
<tr><td><code id="patch_areas_+3A_class">class</code></td>
<td>
<p>An integer value or vector with the value(s) corresponding to
the code values of the raster layer within which points will be sampled.
are computed.</p>
</td></tr>
<tr><td><code id="patch_areas_+3A_edge_size">edge_size</code></td>
<td>
<p>An integer value indicating the width of the edge
(in meters) of the raster layer which is ignored during the sampling
(default = 0). It prevents from sampling in the margins of the study area.</p>
</td></tr>
<tr><td><code id="patch_areas_+3A_neighborhood">neighborhood</code></td>
<td>
<p>An integer value indicating which cells are considered
adjacent when contiguous patches are delineated (it should be 8
(default, Queen's case) or 4 (Rook's case)). This parameter is ignored
when <code>by_patch = FALSE</code>.</p>
</td></tr>
<tr><td><code id="patch_areas_+3A_surf_min">surf_min</code></td>
<td>
<p>An integer value indicating the minimum surface of a patch
considered for the sampling in number of raster cells. This parameter is used
whatever the <code>by_patch</code> argument is. Default is 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the areas of the patches
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>

<hr>
<h2 id='plot_graph_lg'>Plot graphs</h2><span id='topic+plot_graph_lg'></span>

<h3>Description</h3>

<p>The function enables to plot graphs, whether spatial or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_graph_lg(
  graph,
  crds = NULL,
  mode = "aspatial",
  node_inter = NULL,
  link_width = NULL,
  node_size = NULL,
  module = NULL,
  pts_col = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_graph_lg_+3A_graph">graph</code></td>
<td>
<p>A graph object of class <code>igraph</code></p>
</td></tr>
<tr><td><code id="plot_graph_lg_+3A_crds">crds</code></td>
<td>
<p>(optional, default = NULL) If 'mode = 'spatial&rdquo;, it is a
<code>data.frame</code> with the spatial coordinates of the graph nodes.
It must have three columns :
</p>

<ul>
<li><p>ID: A character string indicating the name of the graph nodes.
The names must be the same as the node names of the graph of
class <code>igraph</code> (<code>igraph::V(graph)$name</code>)
</p>
</li>
<li><p>x: A numeric or integer indicating the longitude of the graph nodes.
</p>
</li>
<li><p>y: A numeric or integer indicating the latitude of the graph nodes.
</p>
</li></ul>

<p>This argument is not used when 'mode = 'aspatial&rdquo; and mandatory when 'mode =
'spatial&rdquo;.</p>
</td></tr>
<tr><td><code id="plot_graph_lg_+3A_mode">mode</code></td>
<td>
<p>A character string indicating whether the graph is
spatial ('mode = 'spatial&rdquo;) or not ('mode = 'aspatial&rdquo; (default))</p>
</td></tr>
<tr><td><code id="plot_graph_lg_+3A_node_inter">node_inter</code></td>
<td>
<p>(optional, default = NULL) A character string indicating
whether the links of the graph are weighted by distances or by similarity
indices. It is only used when 'mode = 'aspatial&rdquo; to compute the node
positions with Fruchterman and Reingold algorithm. It can be equal to:
</p>

<ul>
<li><p>'distance': Link weights correspond to distances. Nodes that are close
to each other will be close on the figure.
</p>
</li>
<li><p>'similarity': Link weights correspond to similarity indices. Nodes that
are similar to each other will be close on the figure.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot_graph_lg_+3A_link_width">link_width</code></td>
<td>
<p>(optional, default = NULL) A character string indicating
how the width of the link is set on the figure. Their width can be:</p>

<ul>
<li><p>inversely proportional to link weights (&quot;inv_w&quot;, convenient with
distances, default)
</p>
</li>
<li><p>proportional to link weights (&quot;w&quot;)
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot_graph_lg_+3A_node_size">node_size</code></td>
<td>
<p>(optional, default = NULL) A character string indicating
the graph node attribute used to set the node size on the figure. It must be
the name of a numeric or integer node attribute from the graph.</p>
</td></tr>
<tr><td><code id="plot_graph_lg_+3A_module">module</code></td>
<td>
<p>(optional, default = NULL) A character string indicating
the graph node modules used to set the node color on the figure. It must be
the name of a node attribute from the graph with discrete values.</p>
</td></tr>
<tr><td><code id="plot_graph_lg_+3A_pts_col">pts_col</code></td>
<td>
<p>(optional, default = NULL) A character string indicating the
color used to plot the nodes (default: &quot;#F2B950&quot;). It must be a hexadecimal
color code or a color used by default in R. It cannot be used if 'module' is
specified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the graph is not spatial ('mode = 'aspatial&rdquo;),
the nodes coordinates are calculated with Fruchterman et Reingold algorithm.
The graph object <code>graph</code> of class <code>igraph</code> must have node names
(not necessarily in the same order as IDs in crds, given a merging is done).
</p>


<h3>Value</h3>

<p>A ggplot2 object to plot
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>References</h3>

<p>Fruchterman TM, Reingold EM (1991).
&ldquo;Graph drawing by force-directed placement.&rdquo;
<em>Software: Practice and experience</em>, <b>21</b>(11), 1129&ndash;1164.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pts_pop_ex)
data(data_ex_genind)
mat_w &lt;- mat_gen_dist(data_ex_genind, dist = "DPS")
gp &lt;- gen_graph_topo(mat_w = mat_w, topo = "mst")
g &lt;- plot_graph_lg(graph = gp,
                             crds = pts_pop_ex,
                             mode = "spatial",
                             link_width = "inv_w")
</code></pre>

<hr>
<h2 id='plot_w_hist'>Plot histograms of link weights</h2><span id='topic+plot_w_hist'></span>

<h3>Description</h3>

<p>The function enables to plot histogram to visualize the
distribution of the link weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_w_hist(graph, fill = "#396D35", class_width = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_w_hist_+3A_graph">graph</code></td>
<td>
<p>A graph object of class <code>igraph</code> whose links are weighted</p>
</td></tr>
<tr><td><code id="plot_w_hist_+3A_fill">fill</code></td>
<td>
<p>A character string indicating the color used to fill
the bars (default: &quot;#396D35&quot;). It must be a hexadecimal color code or
a color used by default in R.</p>
</td></tr>
<tr><td><code id="plot_w_hist_+3A_class_width">class_width</code></td>
<td>
<p>(default values: NULL) A numeric or an integer specifying
the width of the classes displayed on the histogram. When it is not
specified, the width is equal to the difference between the minimum and
maximum values divided by 80.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object to plot
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(data_ex_genind)
mat_w &lt;- mat_gen_dist(data_ex_genind, dist = "DPS")
gp &lt;- gen_graph_topo(mat_w = mat_w, topo = "gabriel")
hist &lt;- plot_w_hist(gp)
</code></pre>

<hr>
<h2 id='pop_gen_index'>Compute population-level genetic indices</h2><span id='topic+pop_gen_index'></span>

<h3>Description</h3>

<p>The function computes population-level genetic indices from an
object of class <code>genind</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pop_gen_index(x, pop_names = NULL, indices = c("Nb_ind", "A", "He", "Ho"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pop_gen_index_+3A_x">x</code></td>
<td>
<p>An object of class <code>genind</code>
from package <span class="pkg">adegenet</span>.</p>
</td></tr>
<tr><td><code id="pop_gen_index_+3A_pop_names">pop_names</code></td>
<td>
<p>(optional) A character vector indicating population names.
It is of the same length as the number of populations. Without this
argument, populations are given the names they have initially in the
'genind' object (which is sometimes only a number). The order of the
population names must match with their order in the 'genind' object.
The function does not reorder them. Users must be careful.</p>
</td></tr>
<tr><td><code id="pop_gen_index_+3A_indices">indices</code></td>
<td>
<p>(optional) A character vector indicating the population-level
indices to compute. These indices can be:
</p>

<ul>
<li><p>Mean allelic richness by locus by
population (<code>indices = c("A", ...)</code>)
</p>
</li>
<li><p>Mean expected heterozygosity by locus by
population (<code>indices = c("He",...)</code>)
</p>
</li>
<li><p>Mean observed heterozygosity by locus by
population (<code>indices = c("Ho",...)</code>)
</p>
</li>
<li><p>Number of individuals by
population (<code>indices = c("Nb_ind", ...)</code>)
</p>
</li>
<li><p>Total allelic richness by
population (<code>indices = c("A_tot",...)</code>)
</p>
</li></ul>

<p>By default, <code>indices = c("Nb_ind", "A", "He", "Ho")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>data.frame</code> whose rows
correspond to populations and columns to population attributes
(ID, size, genetic indices). By default, the first column corresponds to
the population names (ID). The order of the columns depends on the
vector 'indices'.
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(data_ex_genind)
x &lt;- data_ex_genind
pop_names &lt;- levels(x@pop)
df_pop_indices &lt;- pop_gen_index(x = x,
                   pop_names = pop_names,
                   indices = c("Nb_ind", "A"))
</code></pre>

<hr>
<h2 id='pop_rare_gen_index'>Compute population-level rarefied genetic indices with ADZE software</h2><span id='topic+pop_rare_gen_index'></span>

<h3>Description</h3>

<p>The function computes population-level rarefied genetic indices
from an object of class <code>genind</code> with the ADZE software.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pop_rare_gen_index(x, max_g = NULL, pop_names = NULL, OS = "linux")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pop_rare_gen_index_+3A_x">x</code></td>
<td>
<p>An object of class <code>genind</code>
from package <span class="pkg">adegenet</span>.</p>
</td></tr>
<tr><td><code id="pop_rare_gen_index_+3A_max_g">max_g</code></td>
<td>
<p>(optional default = NULL) The maximum standardized sample size
used by ADZE software (MAX_G) in ADZE manual. It is equal to twice the
minimum number of individuals considered for the rarefaction analysis. By
default, it is equal to twice the number of individuals in the smallest
population. Ohterwise, it must be either a numeric or integer value.</p>
</td></tr>
<tr><td><code id="pop_rare_gen_index_+3A_pop_names">pop_names</code></td>
<td>
<p>(optional) A character vector indicating population names.
It is of the same length as the number of populations. Without this
argument, populations are given the names they have initially in the
'genind' object (which is sometimes only a number). The order of the
population names must match with their order in the 'genind' object.
The function does not reorder them. Users must be careful.</p>
</td></tr>
<tr><td><code id="pop_rare_gen_index_+3A_os">OS</code></td>
<td>
<p>A character string indicating whether you use a Linux ('linux')
or Windows ('win') operating system.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>data.frame</code> whose rows
correspond to populations and columns to population attributes
(ID, size, genetic indices). By default, the first column corresponds to
the population names (ID). The order of the columns depends on the
vector 'indices'.
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>

<hr>
<h2 id='pts_pop_ex'>pts_pop_ex : details on simulated populations</h2><span id='topic+pts_pop_ex'></span>

<h3>Description</h3>

<p>Simulation dataset
10 populations located on a simulated landscape
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pts_pop_ex
</code></pre>


<h3>Format</h3>

<p>An object of class 'data.frame' with the following columns :
</p>

<dl>
<dt>ID</dt><dd><p>Population ID of the 10 populations</p>
</dd>
<dt>x</dt><dd><p>Site longitude (RGF93)</p>
</dd>
<dt>y</dt><dd><p>Site latitude (RGF93)</p>
</dd>
</dl>



<h3>References</h3>

<p>Landguth EL, Cushman SA (2010).
&ldquo;CDPOP: a spatially explicit cost distance population genetics program.&rdquo;
<em>Molecular Ecology Resources</em>, <b>10</b>(1), 156&ndash;161.
There are as many rows as there are sampled populations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pts_pop_ex")
str(pts_pop_ex)
</code></pre>

<hr>
<h2 id='pts_pop_simul'>pts_pop_simul : details on simulated populations</h2><span id='topic+pts_pop_simul'></span>

<h3>Description</h3>

<p>Simulation dataset
50 populations located on a simulated landscape
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pts_pop_simul
</code></pre>


<h3>Format</h3>

<p>An object of class 'data.frame' with the following columns :
</p>

<dl>
<dt>ID</dt><dd><p>Population ID of the 50 populations</p>
</dd>
<dt>x</dt><dd><p>Site longitude (RGF93)</p>
</dd>
<dt>y</dt><dd><p>Site latitude (RGF93)</p>
</dd>
</dl>



<h3>References</h3>

<p>Landguth EL, Cushman SA (2010).
&ldquo;CDPOP: a spatially explicit cost distance population genetics program.&rdquo;
<em>Molecular Ecology Resources</em>, <b>10</b>(1), 156&ndash;161.
There are as many rows as there are sampled populations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pts_pop_simul")
str(pts_pop_simul)
</code></pre>

<hr>
<h2 id='pw_mat_to_df'>Convert a pairwise matrix into an edge-list data.frame</h2><span id='topic+pw_mat_to_df'></span>

<h3>Description</h3>

<p>The function converts a pairwise matrix into an edge-list
data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pw_mat_to_df(pw_mat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pw_mat_to_df_+3A_pw_mat">pw_mat</code></td>
<td>
<p>A pairwise matrix which can be:</p>

<ul>
<li><p>An object of class <code>matrix</code>. It must have
the same row names and column names. If values represent distances,
diagonal elements should be equal to 0.
</p>
</li>
<li><p>An object of class <code>dist</code>. In that, its column numbers are
used to create IDs in the resulting data.frame.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>data.frame</code>
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(data_tuto)
pw_mat &lt;- data_tuto[[1]]
df &lt;- pw_mat_to_df(pw_mat)
</code></pre>

<hr>
<h2 id='reorder_mat'>Reorder the rows and columns of a symmetric matrix</h2><span id='topic+reorder_mat'></span>

<h3>Description</h3>

<p>The function reorders the rows and columns of a symmetric
matrix according to a specified order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reorder_mat(mat, order)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reorder_mat_+3A_mat">mat</code></td>
<td>
<p>An object of class <code>matrix</code></p>
</td></tr>
<tr><td><code id="reorder_mat_+3A_order">order</code></td>
<td>
<p>A character vector with the rows and columns names of the matrix
in the order in which they will be ordered by the function. All its elements
must be rows and columns names of the matrix <code>mat</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The matrix <code>mat</code> must be symmetric and have rows and columns
names. Its values are not modified.
</p>


<h3>Value</h3>

<p>A reordered symmetric matrix
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat &lt;- matrix(rnorm(36), 6)
mat[lower.tri(mat)] &lt;- t(mat)[lower.tri(mat)]
row.names(mat) &lt;- colnames(mat) &lt;- c("A", "C", "E", "B", "D", "F")
order &lt;- c("A", "B", "C", "D", "E", "F")
mat &lt;- reorder_mat(mat = mat, order = order)
</code></pre>

<hr>
<h2 id='sample_raster'>Sample points or patches on a categorical raster layer</h2><span id='topic+sample_raster'></span>

<h3>Description</h3>

<p>The function samples points or patches on a categorical raster
layer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_raster(
  raster,
  class,
  nb_pts,
  dist_min = 0,
  edge_size = 0,
  by_patch = TRUE,
  neighborhood = 8,
  surf_min = 0,
  prop_area = TRUE,
  step_max = 1000,
  output = "df",
  desc = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_raster_+3A_raster">raster</code></td>
<td>
<p>A RasterLayer object corresponding to a categorical raster layer</p>
</td></tr>
<tr><td><code id="sample_raster_+3A_class">class</code></td>
<td>
<p>An integer value or vector with the value(s) corresponding to
the code values of the raster layer within which points will be sampled.</p>
</td></tr>
<tr><td><code id="sample_raster_+3A_nb_pts">nb_pts</code></td>
<td>
<p>An integer value indicating the number of points to be sampled</p>
</td></tr>
<tr><td><code id="sample_raster_+3A_dist_min">dist_min</code></td>
<td>
<p>An integer value indicating the minimum distance separating
the sampled points (default = 0).</p>
</td></tr>
<tr><td><code id="sample_raster_+3A_edge_size">edge_size</code></td>
<td>
<p>An integer value indicating the width of the edge of the
raster layer which is ignored during the sampling (default = 0). It prevents
from sampling in the margins of the study area.</p>
</td></tr>
<tr><td><code id="sample_raster_+3A_by_patch">by_patch</code></td>
<td>
<p>A logical value indicating whether contiguous patches with
cells having the same code value are delineated prior to
sampling (default = TRUE). It prevents from sampling several points in the
same contiguous patch.</p>
</td></tr>
<tr><td><code id="sample_raster_+3A_neighborhood">neighborhood</code></td>
<td>
<p>An integer value indicating which cells are considered
adjacent when contiguous patches are delineated (it should be 8
(default, Queen's case) or 4 (Rook's case)). This parameter is ignored
when <code>by_patch = FALSE</code>.</p>
</td></tr>
<tr><td><code id="sample_raster_+3A_surf_min">surf_min</code></td>
<td>
<p>An integer value indicating the minimum surface of a patch
considered for the sampling in number of raster cells. This parameter is used
whatever the <code>by_patch</code> argument is. Default is 0.</p>
</td></tr>
<tr><td><code id="sample_raster_+3A_prop_area">prop_area</code></td>
<td>
<p>A logical value indicating whether sampling in large patches
is more likely (default = TRUE). If <code>by_patch = FALSE</code>, this parameter
is ignored. When <code>prop_area = TRUE</code>, the probability to sample a given
patch is proportional to its area.</p>
</td></tr>
<tr><td><code id="sample_raster_+3A_step_max">step_max</code></td>
<td>
<p>An integer value indicating how many sampling steps are
performed to identify a point set satisfying all the conditions before
returning an error.</p>
</td></tr>
<tr><td><code id="sample_raster_+3A_output">output</code></td>
<td>
<p>A character string indicating the type of returned output:
</p>

<ul>
<li><p>'data.frame': A <code>data.frame</code> with three/four columns:
</p>

<ul>
<li><p>ID: The point or patch centroid ID
</p>
</li>
<li><p>x: The point or patch centroid longitude
</p>
</li>
<li><p>y: The point or patch centroid latitude
</p>
</li>
<li><p>area: The area of the sampled patch (only if <code>by_patch = TRUE</code>)
</p>
</li></ul>

</li>
<li><p>'pts_layer': A <code>SpatialPointsDataFrame</code> layer corresponding
to the sampled point (points or patch centroids)
</p>
</li>
<li><p>'poly_layer': A <code>SpatialPolygonsDataFrame</code> layer corresponding
to the sampled patch polygons
</p>
</li></ul>
</td></tr>
<tr><td><code id="sample_raster_+3A_desc">desc</code></td>
<td>
<p>A logical value indicating whether the result should be
described or not (default = FALSE). If <code>desc = TRUE</code>, then the Gini
coefficient of the distances between points and of the patch areas (if
<code>by_patch = TRUE</code>) is computed with the <code><a href="#topic+gini_coeff">gini_coeff</a></code>.
An histogram of the link weights is also described.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of object(s) with one or several elements according to the
<code>output</code> and <code>desc</code> arguments.
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>

<hr>
<h2 id='sc01'>Scaling function</h2><span id='topic+sc01'></span>

<h3>Description</h3>

<p>Scales values between 0 and 1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sc01(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sc01_+3A_x">x</code></td>
<td>
<p>Numeric or integer vector</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(min = 3, max = 15, n = 20)
x01 &lt;- sc01(x)
</code></pre>

<hr>
<h2 id='scatter_dist'>Plot scatterplots of genetic distance vs landscape distance</h2><span id='topic+scatter_dist'></span>

<h3>Description</h3>

<p>The function enables to plot scatterplots to visualize the
relationship between genetic distance (or differentiation) and landscape
distance (Euclidean distance, cost-distance, etc.)between populations or
sample sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scatter_dist(
  mat_gd,
  mat_ld,
  method = "loess",
  thr_gd = NULL,
  thr_ld = NULL,
  se = TRUE,
  smooth_col = "black",
  pts_col = "#999999"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scatter_dist_+3A_mat_gd">mat_gd</code></td>
<td>
<p>A symmetric <code>matrix</code> or <code>dist</code> object with pairwise
genetic distances between populations or sample sites.</p>
</td></tr>
<tr><td><code id="scatter_dist_+3A_mat_ld">mat_ld</code></td>
<td>
<p>A symmetric <code>matrix</code> or <code>dist</code> object with pairwise
landscape distances between populations or sample sites. These distances
can be Euclidean distances, cost-distances or resistance distances,
among others.</p>
</td></tr>
<tr><td><code id="scatter_dist_+3A_method">method</code></td>
<td>
<p>A character string indicating the smoothing method
used to fit a line on the scatterplot. Possible values are the same as
with function 'geom_smooth()' from <span class="pkg">ggplot2</span> : 'lm', 'glm', 'gam',
'loess' (default).</p>
</td></tr>
<tr><td><code id="scatter_dist_+3A_thr_gd">thr_gd</code></td>
<td>
<p>(optional) A numeric or integer value used to remove values
from the data before to plot. All genetic distances values above
<code>thr_gd</code> are removed from the data.</p>
</td></tr>
<tr><td><code id="scatter_dist_+3A_thr_ld">thr_ld</code></td>
<td>
<p>(optional) A numeric or integer value used to remove values
from the data before to plot. All landscape distances values above
<code>thr_ld</code> are removed from the data.</p>
</td></tr>
<tr><td><code id="scatter_dist_+3A_se">se</code></td>
<td>
<p>Logical (optional, default = TRUE) indicating whether the
confidence interval around the smooth line is displayed.</p>
</td></tr>
<tr><td><code id="scatter_dist_+3A_smooth_col">smooth_col</code></td>
<td>
<p>(optional) A character string indicating the color
used to plot the smoothing line (default: &quot;blue&quot;). It must be a hexadecimal
color code or a color used by default in R.</p>
</td></tr>
<tr><td><code id="scatter_dist_+3A_pts_col">pts_col</code></td>
<td>
<p>(optional) Character string indicating the color
used to plot the points (default: &quot;#999999&quot;). It must be a hexadecimal color
code or a color used by default in R.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>IDs in <code>mat_gd</code> and <code>mat_ld</code> must be the same and refer
to the same sampling sites or populations, and both matrices must be ordered
in the same way.
Matrix of genetic distance <code>mat_gd</code> can be computed using
<code><a href="#topic+mat_gen_dist">mat_gen_dist</a></code>.
Matrix of landscape distance <code>mat_ld</code> can be computed using
<code><a href="#topic+mat_geo_dist">mat_geo_dist</a></code> when the landscape distance needed is a
Euclidean geographical distance.
</p>


<h3>Value</h3>

<p>A ggplot2 object to plot
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(data_tuto)
mat_dps &lt;- data_tuto[[1]]
mat_dist &lt;- suppressWarnings(mat_geo_dist(data = pts_pop_simul,
      ID = "ID",
      x = "x",
      y = "y"))
mat_dist &lt;- mat_dist[order(as.character(row.names(mat_dist))),
                      order(as.character(colnames(mat_dist)))]
scatterplot_ex &lt;- scatter_dist(mat_gd = mat_dps,
                              mat_ld = mat_dist)
</code></pre>

<hr>
<h2 id='scatter_dist_g'>Plot scatterplots of distances to visualize the graph pruning intensity</h2><span id='topic+scatter_dist_g'></span>

<h3>Description</h3>

<p>The function enables to plot scatterplots of the relationship
between two distances (often a genetic distance and a landscape distance
between populations or sample sites), while highlighting the population pairs
between which a link was conserved during the creation of a graph whose
nodes are populations (or sample sites). It thereby allows to visualize the
graph pruning intensity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scatter_dist_g(
  mat_y,
  mat_x,
  graph,
  thr_y = NULL,
  thr_x = NULL,
  pts_col_1 = "#999999",
  pts_col_2 = "black"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scatter_dist_g_+3A_mat_y">mat_y</code></td>
<td>
<p>A symmetric (complete) <code>matrix</code> or <code>dist</code> object with
pairwise (genetic or landscape) distances between populations or sample
sites. These values will be the point coordinates on the y axis.
<code>mat_y</code> is the matrix used to weight the links of the graph <code>x</code>,
whose nodes correspond to row and column names of <code>mat_y</code>.</p>
</td></tr>
<tr><td><code id="scatter_dist_g_+3A_mat_x">mat_x</code></td>
<td>
<p>A symmetric (complete) <code>matrix</code> or <code>dist</code> object with
pairwise (genetic or landscape) distances between populations or sample
sites. These values will be the point coordinates on the x axis.
<code>mat_x</code> and <code>mat_y</code> must have the same row and column names,
ordered in the same way.</p>
</td></tr>
<tr><td><code id="scatter_dist_g_+3A_graph">graph</code></td>
<td>
<p>A graph object of class <code>igraph</code>.
Its nodes must have the same names as the row and column of
<code>mat_y</code> and <code>mat_x</code> matrices. <code>x</code> must have weighted links.
Link weights have to be values from <code>mat_y</code> matrix. <code>graph</code> must
be an undirected graph.</p>
</td></tr>
<tr><td><code id="scatter_dist_g_+3A_thr_y">thr_y</code></td>
<td>
<p>(optional) A numeric or integer value used to remove values
from the data before to plot. All values from <code>mat_y</code> above <code>thr_y</code>
are removed from the data.</p>
</td></tr>
<tr><td><code id="scatter_dist_g_+3A_thr_x">thr_x</code></td>
<td>
<p>(optional) A numeric or integer value used to remove values
from the data before to plot. All values from <code>mat_x</code> above <code>thr_x</code>
are removed from the data.</p>
</td></tr>
<tr><td><code id="scatter_dist_g_+3A_pts_col_1">pts_col_1</code></td>
<td>
<p>(optional) A character string indicating the color used to
plot the points associated to all populations or sample sites
pairs (default: &quot;#999999&quot;). It must be a hexadecimal color
code or a color used by default in R.</p>
</td></tr>
<tr><td><code id="scatter_dist_g_+3A_pts_col_2">pts_col_2</code></td>
<td>
<p>(optional) A character string indicating the color used to
plot the points associated to populations or sample sites pairs connected on
the graph (default: &quot;black&quot;). It must be a hexadecimal color
code or a color used by default in R.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>IDs in <code>mat_y</code> and <code>mat_x</code> must be the same and refer
to the same sampling sites or populations, and both matrices must be ordered
in the same way.
Matrices of genetic distance can be computed using
<code><a href="#topic+mat_gen_dist">mat_gen_dist</a></code>.
Matrices of landscape distance can be computed using
<code><a href="#topic+mat_geo_dist">mat_geo_dist</a></code> when the landscape distance needed is a
Euclidean geographical distance.
This function is based upon <code><a href="#topic+scatter_dist">scatter_dist</a></code> function.
</p>


<h3>Value</h3>

<p>A ggplot2 object to plot
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(data_tuto)
mat_gen &lt;- data_tuto[[1]]
mat_dist &lt;- suppressWarnings(mat_geo_dist(data=pts_pop_simul,
      ID = "ID",
      x = "x",
      y = "y"))
mat_dist &lt;- mat_dist[order(as.character(row.names(mat_dist))),
                     order(as.character(colnames(mat_dist)))]
x &lt;- gen_graph_topo(mat_w = mat_gen, mat_topo = mat_dist, topo = "gabriel")
scat &lt;- scatter_dist_g(mat_y = mat_gen, mat_x = mat_dist,
                       graph = x)
</code></pre>

<hr>
<h2 id='structure_to_genind'>Convert a file in STRUCTURE format into a genind object</h2><span id='topic+structure_to_genind'></span>

<h3>Description</h3>

<p>The function converts a text file in STRUCTURE format into
a genind object to use in R
</p>


<h3>Usage</h3>

<pre><code class='language-R'>structure_to_genind(
  path,
  pop_names = NULL,
  loci_names = NULL,
  ind_names = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="structure_to_genind_+3A_path">path</code></td>
<td>
<p>A character string indicating the path to the STRUCTURE file in
format .txt, or alternatively the name of the file in the working directory.
The STRUCTURE file must only have :
</p>

<ul>
<li><p> A first column with the IDs of the individuals
(can be a simple number)
</p>
</li>
<li><p> A second column with the IDs of the populations
(can be a simple number)
</p>
</li>
<li><p> Some loci columns : as many columns as loci in the data
</p>
</li></ul>

<p>The row for loci names is optional but recommended.
Each individual is displayed on 2 rows.</p>
</td></tr>
<tr><td><code id="structure_to_genind_+3A_pop_names">pop_names</code></td>
<td>
<p>(optional) A character vector indicating the population
names in the same order as in the STRUCTURE file. It is of the same length
as the number of populations. Without this argument, populations are
numbered from 1 to the total number of individuals.</p>
</td></tr>
<tr><td><code id="structure_to_genind_+3A_loci_names">loci_names</code></td>
<td>
<p>A character vector with the names of the loci if not
specified in the file first row. This argument is mandatory if the
STRUCTURE file does not include the names of the loci in the first row.
In other cases, the names of the loci is extracted from the file first row</p>
</td></tr>
<tr><td><code id="structure_to_genind_+3A_ind_names">ind_names</code></td>
<td>
<p>(optional) A character vector indicating the individual
names in the same order as in the STRUCTURE file. It is of the same length
as the number of individuals. Without this argument, individuals are
numbered from 1 to the total number of individuals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The column order of the resulting object can be different from
that of objects returned by <code><a href="#topic+gstud_to_genind">gstud_to_genind</a></code>
and <code><a href="#topic+genepop_to_genind">genepop_to_genind</a></code>, depending on allele and loci coding
This function uses functions from <span class="pkg">pegas</span> package.
For details about STRUCTURE file format :
<a href="http://www.ccg.unam.mx/~vinuesa/tlem09/docs/structure_doc.pdf">STRUCTURE user manual</a>
</p>


<h3>Value</h3>

<p>An object of type <code>genind</code>.
</p>


<h3>Author(s)</h3>

<p>P. Savary
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("data_ex_genind")
loci_names &lt;- levels(data_ex_genind@loc.fac)
pop_names &lt;- levels(data_ex_genind@pop)
ind_names &lt;- row.names(data_ex_genind@tab)
path_in &lt;- system.file('extdata', 'data_ex_str.txt',
                       package = 'graph4lg')
file_n &lt;- file.path(tempdir(), "data_ex_str.txt")
file.copy(path_in, file_n, overwrite = TRUE)
str &lt;- structure_to_genind(path = file_n, loci_names = loci_names,
                           pop_names = pop_names, ind_names = ind_names)
file.remove(file_n)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
