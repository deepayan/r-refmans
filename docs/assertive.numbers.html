<!DOCTYPE html><html><head><title>Help for package assertive.numbers</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {assertive.numbers}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#assert_all_are_divisible_by'><p>Is the input divisible by a number?</p></a></li>
<li><a href='#assert_all_are_equal_to'><p>How does the input relate to a value?</p></a></li>
<li><a href='#assert_all_are_finite'><p>Are the inputs (in)finite?</p></a></li>
<li><a href='#assert_all_are_imaginary'><p>Is the input real/imaginary?</p></a></li>
<li><a href='#assert_all_are_in_closed_range'><p>Is the input in range?</p></a></li>
<li><a href='#assert_all_are_nan'><p>Is the input (not) NaN?</p></a></li>
<li><a href='#assert_all_numbers_are_whole_numbers'><p>Is the input a whole number?</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Assertions to Check Properties of Numbers</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0-2</td>
</tr>
<tr>
<td>Date:</td>
<td>2016-05-05</td>
</tr>
<tr>
<td>Author:</td>
<td>Richard Cotton [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Richard Cotton &lt;richierocks@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of predicates and assertions for checking the properties of
    numbers.  This is mainly for use by other package developers who want to
    include run-time testing features in their own packages.  End-users will
    usually want to use assertive directly.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://bitbucket.org/richierocks/assertive.numbers">https://bitbucket.org/richierocks/assertive.numbers</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://bitbucket.org/richierocks/assertive.numbers/issues">https://bitbucket.org/richierocks/assertive.numbers/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>assertive.base (&ge; 0.0-2)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Acknowledgments:</td>
<td>Development of this package was partially funded by
the Proteomics Core at Weill Cornell Medical College in Qatar
&lt;http://qatar-weill.cornell.edu&gt;.  The Core is supported by
'Biomedical Research Program' funds, a program funded by Qatar
Foundation.</td>
</tr>
<tr>
<td>Collate:</td>
<td>'assert-is-divisible-by.R' 'assert-is-equal-to.R' 'imports.R'
'assert-is-in-range.R' 'assert-is-infinity-nan.R'
'assert-is-real-imaginary.R' 'assert-is-whole-number.R'
'is-divisible-by.R' 'is-equal-to.R' 'is-in-range.R'
'is-infinity-nan.R' 'is-real-imaginary.R' 'is-whole-number.R'</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-05-09 16:36:28 UTC; richie</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-05-09 21:37:47</td>
</tr>
</table>
<hr>
<h2 id='assert_all_are_divisible_by'>Is the input divisible by a number?</h2><span id='topic+assert_all_are_divisible_by'></span><span id='topic+assert_all_are_even'></span><span id='topic+assert_all_are_odd'></span><span id='topic+assert_any_are_divisible_by'></span><span id='topic+assert_any_are_even'></span><span id='topic+assert_any_are_odd'></span><span id='topic+is_divisible_by'></span><span id='topic+is_even'></span><span id='topic+is_odd'></span>

<h3>Description</h3>

<p>Checks to see if the input is divisible by some number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_all_are_divisible_by(x, n, tol = 100 * .Machine$double.eps,
  na_ignore = FALSE, severity = getOption("assertive.severity", "stop"))

assert_any_are_divisible_by(x, n, tol = 100 * .Machine$double.eps,
  na_ignore = FALSE, severity = getOption("assertive.severity", "stop"))

assert_all_are_even(x, tol = 100 * .Machine$double.eps, na_ignore = FALSE,
  severity = getOption("assertive.severity", "stop"))

assert_any_are_even(x, tol = 100 * .Machine$double.eps, na_ignore = FALSE,
  severity = getOption("assertive.severity", "stop"))

assert_all_are_odd(x, tol = 100 * .Machine$double.eps, na_ignore = FALSE,
  severity = getOption("assertive.severity", "stop"))

assert_any_are_odd(x, tol = 100 * .Machine$double.eps, na_ignore = FALSE,
  severity = getOption("assertive.severity", "stop"))

is_divisible_by(x, n, tol = 100 * .Machine$double.eps,
  .xname = get_name_in_parent(x))

is_even(x, tol = 100 * .Machine$double.eps, .xname = get_name_in_parent(x))

is_odd(x, tol = 100 * .Machine$double.eps, .xname = get_name_in_parent(x))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assert_all_are_divisible_by_+3A_x">x</code></td>
<td>
<p>A numeric vector to divide.</p>
</td></tr>
<tr><td><code id="assert_all_are_divisible_by_+3A_n">n</code></td>
<td>
<p>A numeric vector to divide by.</p>
</td></tr>
<tr><td><code id="assert_all_are_divisible_by_+3A_tol">tol</code></td>
<td>
<p>Differences from zero smaller than <code>tol</code> are not considered.</p>
</td></tr>
<tr><td><code id="assert_all_are_divisible_by_+3A_na_ignore">na_ignore</code></td>
<td>
<p>A logical value.  If <code>FALSE</code>, <code>NA</code> values
cause an error; otherwise they do not.  Like <code>na.rm</code> in many
stats package functions, except that the position of the failing
values does not change.</p>
</td></tr>
<tr><td><code id="assert_all_are_divisible_by_+3A_severity">severity</code></td>
<td>
<p>How severe should the consequences of the assertion be?
Either <code>"stop"</code>, <code>"warning"</code>, <code>"message"</code>, or <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="assert_all_are_divisible_by_+3A_.xname">.xname</code></td>
<td>
<p>Not intended to be used directly.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the input <code>x</code> is divisible by <code>n</code>, within 
the specified tolerance.
</p>


<h3>Note</h3>

<p><code>is_even</code> and <code>is_odd</code> are shortcuts for divisibility by two.
</p>


<h3>See Also</h3>

<p><code>is_whole_number</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_divisible_by(1:10, 3)
is_divisible_by(-5:5, -2)
is_divisible_by(1.5:10.5, c(1.5, 3.5))
assert_any_are_even(1:10)
assertive.base::dont_stop(assert_all_are_even(1:10))
</code></pre>

<hr>
<h2 id='assert_all_are_equal_to'>How does the input relate to a value?</h2><span id='topic+assert_all_are_equal_to'></span><span id='topic+assert_all_are_greater_than'></span><span id='topic+assert_all_are_greater_than_or_equal_to'></span><span id='topic+assert_all_are_less_than'></span><span id='topic+assert_all_are_less_than_or_equal_to'></span><span id='topic+assert_all_are_not_equal_to'></span><span id='topic+assert_any_are_equal_to'></span><span id='topic+assert_any_are_greater_than'></span><span id='topic+assert_any_are_greater_than_or_equal_to'></span><span id='topic+assert_any_are_less_than'></span><span id='topic+assert_any_are_less_than_or_equal_to'></span><span id='topic+assert_any_are_not_equal_to'></span><span id='topic+is_equal_to'></span><span id='topic+is_greater_than'></span><span id='topic+is_greater_than_or_equal_to'></span><span id='topic+is_less_than'></span><span id='topic+is_less_than_or_equal_to'></span><span id='topic+is_not_equal_to'></span>

<h3>Description</h3>

<p>Is <code>x</code> equal/not equal/greater than/less than <code>y</code>?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_all_are_equal_to(x, y, tol = 100 * .Machine$double.eps,
  na_ignore = FALSE, severity = getOption("assertive.severity", "stop"))

assert_any_are_equal_to(x, y, tol = 100 * .Machine$double.eps,
  na_ignore = FALSE, severity = getOption("assertive.severity", "stop"))

assert_all_are_not_equal_to(x, y, tol = 100 * .Machine$double.eps,
  na_ignore = FALSE, severity = getOption("assertive.severity", "stop"))

assert_any_are_not_equal_to(x, y, tol = 100 * .Machine$double.eps,
  na_ignore = FALSE, severity = getOption("assertive.severity", "stop"))

assert_all_are_greater_than(x, y, na_ignore = FALSE,
  severity = getOption("assertive.severity", "stop"))

assert_any_are_greater_than(x, y, na_ignore = FALSE,
  severity = getOption("assertive.severity", "stop"))

assert_all_are_greater_than_or_equal_to(x, y, na_ignore = FALSE,
  severity = getOption("assertive.severity", "stop"))

assert_any_are_greater_than_or_equal_to(x, y, na_ignore = FALSE,
  severity = getOption("assertive.severity", "stop"))

assert_all_are_less_than(x, y, na_ignore = FALSE,
  severity = getOption("assertive.severity", "stop"))

assert_any_are_less_than(x, y, na_ignore = FALSE,
  severity = getOption("assertive.severity", "stop"))

assert_all_are_less_than_or_equal_to(x, y, na_ignore = FALSE,
  severity = getOption("assertive.severity", "stop"))

assert_any_are_less_than_or_equal_to(x, y, na_ignore = FALSE,
  severity = getOption("assertive.severity", "stop"))

is_equal_to(x, y, tol = 100 * .Machine$double.eps,
  .xname = get_name_in_parent(x), .yname = get_name_in_parent(x))

is_not_equal_to(x, y, tol = 100 * .Machine$double.eps,
  .xname = get_name_in_parent(x), .yname = get_name_in_parent(x))

is_greater_than(x, y, .xname = get_name_in_parent(x),
  .yname = get_name_in_parent(x))

is_greater_than_or_equal_to(x, y, .xname = get_name_in_parent(x),
  .yname = get_name_in_parent(x))

is_less_than(x, y, .xname = get_name_in_parent(x),
  .yname = get_name_in_parent(x))

is_less_than_or_equal_to(x, y, .xname = get_name_in_parent(x),
  .yname = get_name_in_parent(x))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assert_all_are_equal_to_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="assert_all_are_equal_to_+3A_y">y</code></td>
<td>
<p>Another numeric vector, typically scalar or the same
length as <code>x</code>.  See note.</p>
</td></tr>
<tr><td><code id="assert_all_are_equal_to_+3A_tol">tol</code></td>
<td>
<p>Values within <code>tol</code> are considered equal.</p>
</td></tr>
<tr><td><code id="assert_all_are_equal_to_+3A_na_ignore">na_ignore</code></td>
<td>
<p>A logical value.  If <code>FALSE</code>, <code>NA</code> values
cause an error; otherwise they do not.  Like <code>na.rm</code> in many
stats package functions, except that the position of the failing
values does not change.</p>
</td></tr>
<tr><td><code id="assert_all_are_equal_to_+3A_severity">severity</code></td>
<td>
<p>How severe should the consequences of the assertion be?
Either <code>"stop"</code>, <code>"warning"</code>, <code>"message"</code>, or <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="assert_all_are_equal_to_+3A_.xname">.xname</code></td>
<td>
<p>Not intended to be used directly.</p>
</td></tr>
<tr><td><code id="assert_all_are_equal_to_+3A_.yname">.yname</code></td>
<td>
<p>Not intended to be used directly.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the input <code>x</code> is equal/not equal/greater 
than/less than <code>y</code>
</p>


<h3>Note</h3>

<p>The usual recycling rules apply when <code>x</code> and <code>y</code>
are different lengths.  See Intro to R for details:
<a href="https://cran.r-project.org/doc/manuals/r-devel/R-intro.html#Vector-arithmetic">https://cran.r-project.org/doc/manuals/r-devel/R-intro.html#Vector-arithmetic</a>
<a href="https://cran.r-project.org/doc/manuals/r-devel/R-intro.html#The-recycling-rule">https://cran.r-project.org/doc/manuals/r-devel/R-intro.html#The-recycling-rule</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Approximate and exact floating point comparisons:
# See FAQ on R 7.31
x &lt;- sqrt(2) * sqrt(2)
is_equal_to(x, 2)
is_equal_to(x, 2, tol = 0)
is_not_equal_to(x, 2)
is_not_equal_to(x, 2, tol = 0)

# Elements of x and y are recycled
is_equal_to(1:6, 1:3)

# Inequalities
x &lt;- c(1 - .Machine$double.neg.eps, 1, 1 + .Machine$double.eps)
is_greater_than(x, 1)
is_greater_than_or_equal_to(x, 1)
is_less_than(x, 1)
is_less_than_or_equal_to(x, 1)
</code></pre>

<hr>
<h2 id='assert_all_are_finite'>Are the inputs (in)finite?</h2><span id='topic+assert_all_are_finite'></span><span id='topic+assert_all_are_infinite'></span><span id='topic+assert_all_are_negative_infinity'></span><span id='topic+assert_all_are_positive_infinity'></span><span id='topic+assert_any_are_finite'></span><span id='topic+assert_any_are_infinite'></span><span id='topic+assert_any_are_negative_infinity'></span><span id='topic+assert_any_are_positive_infinity'></span><span id='topic+is_finite'></span><span id='topic+is_infinite'></span><span id='topic+is_negative_infinity'></span><span id='topic+is_positive_infinity'></span>

<h3>Description</h3>

<p>Checks to see if the inputs are (in)finite.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_all_are_finite(x, severity = getOption("assertive.severity", "stop"))

assert_any_are_finite(x, severity = getOption("assertive.severity", "stop"))

assert_all_are_infinite(x, severity = getOption("assertive.severity", "stop"))

assert_any_are_infinite(x, severity = getOption("assertive.severity", "stop"))

assert_all_are_negative_infinity(x, severity = getOption("assertive.severity",
  "stop"))

assert_any_are_negative_infinity(x, severity = getOption("assertive.severity",
  "stop"))

assert_all_are_positive_infinity(x, severity = getOption("assertive.severity",
  "stop"))

assert_any_are_positive_infinity(x, severity = getOption("assertive.severity",
  "stop"))

is_finite(x, .xname = get_name_in_parent(x))

is_infinite(x, .xname = get_name_in_parent(x))

is_negative_infinity(x, .xname = get_name_in_parent(x))

is_positive_infinity(x, .xname = get_name_in_parent(x))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assert_all_are_finite_+3A_x">x</code></td>
<td>
<p>Input to check.</p>
</td></tr>
<tr><td><code id="assert_all_are_finite_+3A_severity">severity</code></td>
<td>
<p>How severe should the consequences of the assertion be?
Either <code>"stop"</code>, <code>"warning"</code>, <code>"message"</code>, or <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="assert_all_are_finite_+3A_.xname">.xname</code></td>
<td>
<p>Not intended to be used directly.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>is_finite</code> wraps <code>is.finite</code>, showing the 
names of the inputs in the answer. <code>is_infinite</code> works 
likewise for <code>is.infinite</code>.  The <code>assert_*</code> functions 
return nothing but throw an error if the corresponding 
<code>is_*</code> function returns <code>FALSE</code>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+is.finite">is.finite</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(0, Inf, -Inf, NA, NaN)
is_finite(x)
is_infinite(x)
is_positive_infinity(x)
is_negative_infinity(x)
assert_all_are_finite(1:10)
assert_any_are_finite(c(1, Inf))
assert_all_are_infinite(c(Inf, -Inf))
assertive.base::dont_stop(assert_all_are_finite(c(0, Inf, -Inf, NA, NaN)))
</code></pre>

<hr>
<h2 id='assert_all_are_imaginary'>Is the input real/imaginary?</h2><span id='topic+assert_all_are_imaginary'></span><span id='topic+assert_all_are_real'></span><span id='topic+assert_any_are_imaginary'></span><span id='topic+assert_any_are_real'></span><span id='topic+is_imaginary'></span><span id='topic+is_real'></span>

<h3>Description</h3>

<p>Checks to see if the input is real or imaginary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_all_are_imaginary(x, tol = 100 * .Machine$double.eps,
  na_ignore = FALSE, severity = getOption("assertive.severity", "stop"))

assert_any_are_imaginary(x, tol = 100 * .Machine$double.eps,
  na_ignore = FALSE, severity = getOption("assertive.severity", "stop"))

assert_all_are_real(x, tol = 100 * .Machine$double.eps, na_ignore = FALSE,
  severity = getOption("assertive.severity", "stop"))

assert_any_are_real(x, tol = 100 * .Machine$double.eps, na_ignore = FALSE,
  severity = getOption("assertive.severity", "stop"))

is_imaginary(x, tol = 100 * .Machine$double.eps,
  .xname = get_name_in_parent(x))

is_real(x, tol = 100 * .Machine$double.eps, .xname = get_name_in_parent(x))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assert_all_are_imaginary_+3A_x">x</code></td>
<td>
<p>Input to check.</p>
</td></tr>
<tr><td><code id="assert_all_are_imaginary_+3A_tol">tol</code></td>
<td>
<p>Imaginary/real components smaller than <code>tol</code> are not 
considered.</p>
</td></tr>
<tr><td><code id="assert_all_are_imaginary_+3A_na_ignore">na_ignore</code></td>
<td>
<p>A logical value.  If <code>FALSE</code>, <code>NA</code> values
cause an error; otherwise they do not.  Like <code>na.rm</code> in many
stats package functions, except that the position of the failing
values does not change.</p>
</td></tr>
<tr><td><code id="assert_all_are_imaginary_+3A_severity">severity</code></td>
<td>
<p>How severe should the consequences of the assertion be?
Either <code>"stop"</code>, <code>"warning"</code>, <code>"message"</code>, or <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="assert_all_are_imaginary_+3A_.xname">.xname</code></td>
<td>
<p>Not intended to be used directly.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the input has imaginary component equal to zero.
The <code>assert_*</code> functions return nothing but
throw an error if the corresponding <code>is_*</code> function returns 
<code>FALSE</code>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+complex">complex</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(x &lt;- with(expand.grid(re = -1:1, im = -1:1), re + im * 1i))
is_real(x)
is_imaginary(x)

# By default, very small imaginary/real components are ignored.
x &lt;- .Machine$double.eps * (1 + 1i)
is_real(x)
is_real(x, 0)
is_imaginary(x)
is_imaginary(x, 0)
# numbers with both a real and imaginary component return FALSE
# (since they are neither purely real nor purely imaginary)
cmplx &lt;- 1 + 1i
is_real(cmplx)
is_imaginary(cmplx)
assert_all_are_real(1:10)
assert_all_are_real(1:10 + 0i)
assert_any_are_real(c(1i, 0))
assert_all_are_imaginary(1:10 * 1i)
assert_any_are_imaginary(c(1i, 0))
assertive.base::dont_stop(assert_all_are_real(x))
assertive.base::dont_stop(assert_all_are_imaginary(x))
</code></pre>

<hr>
<h2 id='assert_all_are_in_closed_range'>Is the input in range?</h2><span id='topic+assert_all_are_in_closed_range'></span><span id='topic+assert_all_are_in_left_open_range'></span><span id='topic+assert_all_are_in_open_range'></span><span id='topic+assert_all_are_in_range'></span><span id='topic+assert_all_are_in_right_open_range'></span><span id='topic+assert_all_are_negative'></span><span id='topic+assert_all_are_non_negative'></span><span id='topic+assert_all_are_non_positive'></span><span id='topic+assert_all_are_percentages'></span><span id='topic+assert_all_are_positive'></span><span id='topic+assert_all_are_proportions'></span><span id='topic+assert_any_are_in_closed_range'></span><span id='topic+assert_any_are_in_left_open_range'></span><span id='topic+assert_any_are_in_open_range'></span><span id='topic+assert_any_are_in_range'></span><span id='topic+assert_any_are_in_right_open_range'></span><span id='topic+assert_any_are_negative'></span><span id='topic+assert_any_are_non_negative'></span><span id='topic+assert_any_are_non_positive'></span><span id='topic+assert_any_are_percentages'></span><span id='topic+assert_any_are_positive'></span><span id='topic+assert_any_are_proportions'></span><span id='topic+is_in_closed_range'></span><span id='topic+is_in_left_open_range'></span><span id='topic+is_in_open_range'></span><span id='topic+is_in_range'></span><span id='topic+is_in_right_open_range'></span><span id='topic+is_negative'></span><span id='topic+is_non_negative'></span><span id='topic+is_non_positive'></span><span id='topic+is_percentage'></span><span id='topic+is_positive'></span><span id='topic+is_proportion'></span>

<h3>Description</h3>

<p>Checks to see if the input is within an numeric interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_all_are_in_closed_range(x, lower = -Inf, upper = Inf,
  na_ignore = FALSE, severity = getOption("assertive.severity", "stop"))

assert_any_are_in_closed_range(x, lower = -Inf, upper = Inf,
  na_ignore = FALSE, severity = getOption("assertive.severity", "stop"))

assert_all_are_in_left_open_range(x, lower = -Inf, upper = Inf,
  na_ignore = FALSE, severity = getOption("assertive.severity", "stop"))

assert_any_are_in_left_open_range(x, lower = -Inf, upper = Inf,
  na_ignore = FALSE, severity = getOption("assertive.severity", "stop"))

assert_all_are_in_open_range(x, lower = -Inf, upper = Inf,
  na_ignore = FALSE, severity = getOption("assertive.severity", "stop"))

assert_any_are_in_open_range(x, lower = -Inf, upper = Inf,
  na_ignore = FALSE, severity = getOption("assertive.severity", "stop"))

assert_all_are_in_range(x, lower = -Inf, upper = Inf,
  lower_is_strict = FALSE, upper_is_strict = FALSE, na_ignore = FALSE,
  severity = getOption("assertive.severity", "stop"))

assert_any_are_in_range(x, lower = -Inf, upper = Inf,
  lower_is_strict = FALSE, upper_is_strict = FALSE, na_ignore = FALSE,
  severity = getOption("assertive.severity", "stop"))

assert_all_are_in_right_open_range(x, lower = -Inf, upper = Inf,
  na_ignore = FALSE, severity = getOption("assertive.severity", "stop"))

assert_any_are_in_right_open_range(x, lower = -Inf, upper = Inf,
  na_ignore = FALSE, severity = getOption("assertive.severity", "stop"))

assert_all_are_negative(x, na_ignore = FALSE,
  severity = getOption("assertive.severity", "stop"))

assert_any_are_negative(x, na_ignore = FALSE,
  severity = getOption("assertive.severity", "stop"))

assert_all_are_non_negative(x, na_ignore = FALSE,
  severity = getOption("assertive.severity", "stop"))

assert_any_are_non_negative(x, na_ignore = FALSE,
  severity = getOption("assertive.severity", "stop"))

assert_all_are_non_positive(x, na_ignore = FALSE,
  severity = getOption("assertive.severity", "stop"))

assert_any_are_non_positive(x, na_ignore = FALSE,
  severity = getOption("assertive.severity", "stop"))

assert_all_are_percentages(x, lower_is_strict = FALSE,
  upper_is_strict = FALSE, na_ignore = FALSE,
  severity = getOption("assertive.severity", "stop"))

assert_any_are_percentages(x, lower_is_strict = FALSE,
  upper_is_strict = FALSE, na_ignore = FALSE,
  severity = getOption("assertive.severity", "stop"))

assert_all_are_positive(x, na_ignore = FALSE,
  severity = getOption("assertive.severity", "stop"))

assert_any_are_positive(x, na_ignore = FALSE,
  severity = getOption("assertive.severity", "stop"))

assert_all_are_proportions(x, lower_is_strict = FALSE,
  upper_is_strict = FALSE, na_ignore = FALSE,
  severity = getOption("assertive.severity", "stop"))

assert_any_are_proportions(x, lower_is_strict = FALSE,
  upper_is_strict = FALSE, na_ignore = FALSE,
  severity = getOption("assertive.severity", "stop"))

is_in_closed_range(x, lower = -Inf, upper = Inf,
  .xname = get_name_in_parent(x))

is_in_left_open_range(x, lower = -Inf, upper = Inf,
  .xname = get_name_in_parent(x))

is_in_open_range(x, lower = -Inf, upper = Inf,
  .xname = get_name_in_parent(x))

is_in_range(x, lower = -Inf, upper = Inf, lower_is_strict = FALSE,
  upper_is_strict = FALSE, .xname = get_name_in_parent(x))

is_in_right_open_range(x, lower = -Inf, upper = Inf,
  .xname = get_name_in_parent(x))

is_negative(x, .xname = get_name_in_parent(x))

is_non_negative(x, .xname = get_name_in_parent(x))

is_non_positive(x, .xname = get_name_in_parent(x))

is_percentage(x, lower_is_strict = FALSE, upper_is_strict = FALSE,
  .xname = get_name_in_parent(x))

is_positive(x, .xname = get_name_in_parent(x))

is_proportion(x, lower_is_strict = FALSE, upper_is_strict = FALSE,
  .xname = get_name_in_parent(x))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assert_all_are_in_closed_range_+3A_x">x</code></td>
<td>
<p>Input to check.</p>
</td></tr>
<tr><td><code id="assert_all_are_in_closed_range_+3A_lower">lower</code></td>
<td>
<p>Lower bound for the interval.</p>
</td></tr>
<tr><td><code id="assert_all_are_in_closed_range_+3A_upper">upper</code></td>
<td>
<p>Upper bound for the interval.</p>
</td></tr>
<tr><td><code id="assert_all_are_in_closed_range_+3A_na_ignore">na_ignore</code></td>
<td>
<p>A logical value.  If <code>FALSE</code>, <code>NA</code> values
cause an error; otherwise they do not.  Like <code>na.rm</code> in many
stats package functions, except that the position of the failing
values does not change.</p>
</td></tr>
<tr><td><code id="assert_all_are_in_closed_range_+3A_severity">severity</code></td>
<td>
<p>How severe should the consequences of the assertion be?
Either <code>"stop"</code>, <code>"warning"</code>, <code>"message"</code>, or <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="assert_all_are_in_closed_range_+3A_lower_is_strict">lower_is_strict</code></td>
<td>
<p>If <code>TRUE</code>, the lower bound is open (strict) 
otherwise it is closed.</p>
</td></tr>
<tr><td><code id="assert_all_are_in_closed_range_+3A_upper_is_strict">upper_is_strict</code></td>
<td>
<p>If <code>TRUE</code>, the upper bound is open (strict)
otherwise it is closed.</p>
</td></tr>
<tr><td><code id="assert_all_are_in_closed_range_+3A_.xname">.xname</code></td>
<td>
<p>Not intended to be used directly.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>is_*</code> functions return <code>TRUE</code> if the input is 
within an interval.  The <code>assert_*</code> functions return nothing but
throw an error if the corresponding <code>is_*</code> function returns 
<code>FALSE</code>.
</p>


<h3>Note</h3>

<p><code>is_in_range</code> provides the most flexibility in determining
if values are within a numeric interval.  The other functions restrict
the input arguments for convience in common cases.  For example,
<code>is_percentage</code> forces the interval to be from 0 to 100.
The function is not vectorized by the <code>lower_is_strict</code> and
<code>upper_is_strict</code> for speed (these are assumed to be scalar logical
values).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>assert_all_are_positive(1:10)
assert_all_are_non_negative(0:10)
assert_any_are_positive(c(-1, 1))
assert_all_are_percentages(c(0, 50, 100))
assert_all_are_proportions(c(0, 0.5, 1))
assert_all_are_in_left_open_range(1 + .Machine$double.eps, lower = 1)
</code></pre>

<hr>
<h2 id='assert_all_are_nan'>Is the input (not) NaN?</h2><span id='topic+assert_all_are_nan'></span><span id='topic+assert_all_are_not_nan'></span><span id='topic+assert_any_are_nan'></span><span id='topic+assert_any_are_not_nan'></span><span id='topic+is_nan'></span><span id='topic+is_not_nan'></span>

<h3>Description</h3>

<p>Checks to see if the input is a number that is(n't) NaN.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_all_are_nan(x, severity = getOption("assertive.severity", "stop"))

assert_any_are_nan(x, severity = getOption("assertive.severity", "stop"))

assert_all_are_not_nan(x, severity = getOption("assertive.severity", "stop"))

assert_any_are_not_nan(x, severity = getOption("assertive.severity", "stop"))

is_nan(x, .xname = get_name_in_parent(x))

is_not_nan(x, .xname = get_name_in_parent(x))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assert_all_are_nan_+3A_x">x</code></td>
<td>
<p>Input to check.</p>
</td></tr>
<tr><td><code id="assert_all_are_nan_+3A_severity">severity</code></td>
<td>
<p>How severe should the consequences of the assertion be?
Either <code>"stop"</code>, <code>"warning"</code>, <code>"message"</code>, or <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="assert_all_are_nan_+3A_.xname">.xname</code></td>
<td>
<p>Not intended to be used directly.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>is_nan</code> wraps <code>is.nan</code>, coercing the input to
numeric if necessary.  <code>is_not_nan</code> works similarly, but returns
the negation.  The <code>assert_*</code> functions return nothing but
throw an error if the corresponding <code>is_*</code> function returns
<code>FALSE</code>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+is.nan">is.nan</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(0, NaN, NA)
is_nan(x)
is_not_nan(x)
assert_all_are_not_nan(1:10)
assert_any_are_not_nan(x)
assertive.base::dont_stop(assert_all_are_not_nan(x))
</code></pre>

<hr>
<h2 id='assert_all_numbers_are_whole_numbers'>Is the input a whole number?</h2><span id='topic+assert_all_are_whole_numbers'></span><span id='topic+assert_all_numbers_are_whole_numbers'></span><span id='topic+assert_any_are_whole_numbers'></span><span id='topic+assert_any_numbers_are_whole_numbers'></span><span id='topic+is_whole_number'></span>

<h3>Description</h3>

<p>Checks that the (probably floating point) input is a whole number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_all_numbers_are_whole_numbers(x, tol = 100 * .Machine$double.eps,
  na_ignore = FALSE, severity = getOption("assertive.severity", "stop"))

assert_any_numbers_are_whole_numbers(x, tol = 100 * .Machine$double.eps,
  na_ignore = FALSE, severity = getOption("assertive.severity", "stop"))

assert_all_are_whole_numbers(x, tol = 100 * .Machine$double.eps,
  na_ignore = FALSE, severity = getOption("assertive.severity", "stop"))

assert_any_are_whole_numbers(x, tol = 100 * .Machine$double.eps,
  na_ignore = FALSE, severity = getOption("assertive.severity", "stop"))

is_whole_number(x, tol = 100 * .Machine$double.eps,
  .xname = get_name_in_parent(x))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assert_all_numbers_are_whole_numbers_+3A_x">x</code></td>
<td>
<p>Input to check.</p>
</td></tr>
<tr><td><code id="assert_all_numbers_are_whole_numbers_+3A_tol">tol</code></td>
<td>
<p>Differences smaller than <code>tol</code> are not considered.</p>
</td></tr>
<tr><td><code id="assert_all_numbers_are_whole_numbers_+3A_na_ignore">na_ignore</code></td>
<td>
<p>A logical value.  If <code>FALSE</code>, <code>NA</code> values
cause an error; otherwise they do not.  Like <code>na.rm</code> in many
stats package functions, except that the position of the failing
values does not change.</p>
</td></tr>
<tr><td><code id="assert_all_numbers_are_whole_numbers_+3A_severity">severity</code></td>
<td>
<p>How severe should the consequences of the assertion be?
Either <code>"stop"</code>, <code>"warning"</code>, <code>"message"</code>, or <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="assert_all_numbers_are_whole_numbers_+3A_.xname">.xname</code></td>
<td>
<p>Not intended to be used directly.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the input is a whole number.
</p>


<h3>Note</h3>

<p>The term whole number is used to distinguish from integer in
that the input <code>x</code> need not have type <code>integer</code>.  In fact
it is expected that <code>x</code> will be <code>numeric</code>.
</p>


<h3>See Also</h3>

<p><code>is_divisible_by</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1, plus or minus a very small number
x &lt;- 1 + c(0, .Machine$double.eps, -.Machine$double.neg.eps)
# By default, you get a bit of tolerance for rounding errors
is_whole_number(x)
# Set the tolerance to zero for exact matching.
is_whole_number(x, tol = 0)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
