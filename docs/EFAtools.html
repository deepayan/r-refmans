<!DOCTYPE html><html><head><title>Help for package EFAtools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {EFAtools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#EFAtools-package'><p>EFAtools: Fast and Flexible Implementations of Exploratory Factor Analysis Tools</p></a></li>
<li><a href='#.compute_vars'><p>Compute explained variances from loadings</p></a></li>
<li><a href='#.factor_corres'><p>Compute number of non-matching indicator-to-factor correspondences</p></a></li>
<li><a href='#.numformat'><p>Format numbers for print method</p></a></li>
<li><a href='#.paf_iter'><p>Perform the iterative PAF procedure</p></a></li>
<li><a href='#.parallel_sim'><p>Parallel analysis on simulated data.</p></a></li>
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#BARTLETT'><p>Bartlett's test of sphericity</p></a></li>
<li><a href='#CD'><p>Comparison Data</p></a></li>
<li><a href='#COMPARE'><p>Compare two vectors or matrices (communalities or loadings)</p></a></li>
<li><a href='#DOSPERT'><p>DOSPERT</p></a></li>
<li><a href='#DOSPERT_raw'><p>DOSPERT_raw</p></a></li>
<li><a href='#EFA'><p>Exploratory factor analysis (EFA)</p></a></li>
<li><a href='#EFA_AVERAGE'><p>Model averaging across different EFA methods and types</p></a></li>
<li><a href='#EKC'><p>Empirical Kaiser Criterion</p></a></li>
<li><a href='#FACTOR_SCORES'><p>Estimate factor scores for an EFA model</p></a></li>
<li><a href='#GRiPS_raw'><p>GRiPS_raw</p></a></li>
<li><a href='#HULL'><p>Hull method for determining the number of factors to retain</p></a></li>
<li><a href='#IDS2_R'><p>Intelligence subtests from the Intelligence and Development Scales&ndash;2</p></a></li>
<li><a href='#KGC'><p>Kaiser-Guttman Criterion</p></a></li>
<li><a href='#KMO'><p>Kaiser-Meyer-Olkin criterion</p></a></li>
<li><a href='#N_FACTORS'><p>Various Factor Retention Criteria</p></a></li>
<li><a href='#OMEGA'><p>McDonald's omega</p></a></li>
<li><a href='#PARALLEL'><p>Parallel analysis</p></a></li>
<li><a href='#plot.CD'><p>Plot CD object</p></a></li>
<li><a href='#plot.EFA_AVERAGE'><p>Plot EFA_AVERAGE object</p></a></li>
<li><a href='#plot.EKC'><p>Plot EKC object</p></a></li>
<li><a href='#plot.HULL'><p>Plot HULL object</p></a></li>
<li><a href='#plot.KGC'><p>Plot KGC object</p></a></li>
<li><a href='#plot.PARALLEL'><p>Plot PARALLEL object</p></a></li>
<li><a href='#plot.SCREE'><p>Plot SCREE object</p></a></li>
<li><a href='#population_models'><p>population_models</p></a></li>
<li><a href='#print.BARTLETT'><p>Print BARTLETT object</p></a></li>
<li><a href='#print.CD'><p>Print function for CD objects</p></a></li>
<li><a href='#print.COMPARE'><p>Print COMPARE object</p></a></li>
<li><a href='#print.EFA'><p>Print EFA object</p></a></li>
<li><a href='#print.EFA_AVERAGE'><p>Print EFA_AVERAGE object</p></a></li>
<li><a href='#print.EKC'><p>Print function for EKC objects</p></a></li>
<li><a href='#print.HULL'><p>Print function for HULL objects</p></a></li>
<li><a href='#print.KGC'><p>Print function for KGC objects</p></a></li>
<li><a href='#print.KMO'><p>Print KMO object</p></a></li>
<li><a href='#print.LOADINGS'><p>Print LOADINGS object</p></a></li>
<li><a href='#print.N_FACTORS'><p>Print function for N_FACTORS objects</p></a></li>
<li><a href='#print.OMEGA'><p>Print OMEGA object</p></a></li>
<li><a href='#print.PARALLEL'><p>Print function for PARALLEL objects</p></a></li>
<li><a href='#print.SCREE'><p>Print function for SCREE objects</p></a></li>
<li><a href='#print.SL'><p>Print SL object</p></a></li>
<li><a href='#print.SLLOADINGS'><p>Print SLLOADINGS object</p></a></li>
<li><a href='#print.SMT'><p>Print SMT object</p></a></li>
<li><a href='#RiskDimensions'><p>RiskDimensions</p></a></li>
<li><a href='#SCREE'><p>Scree Plot</p></a></li>
<li><a href='#SL'><p>Schmid-Leiman Transformation</p></a></li>
<li><a href='#SMT'><p>Sequential Chi Square Model Tests, RMSEA lower bound, and AIC</p></a></li>
<li><a href='#SPSS_23'><p>Various outputs from SPSS (version 23) FACTOR</p></a></li>
<li><a href='#SPSS_27'><p>Various outputs from SPSS (version 27) FACTOR</p></a></li>
<li><a href='#test_models'><p>Four test models used in Grieder and Steiner (2020)</p></a></li>
<li><a href='#UPPS_raw'><p>UPPS_raw</p></a></li>
<li><a href='#WJIV_ages_14_19'><p>Woodcock Johnson IV: ages 14 to 19</p></a></li>
<li><a href='#WJIV_ages_20_39'><p>Woodcock Johnson IV: ages 20 to 39</p></a></li>
<li><a href='#WJIV_ages_3_5'><p>Woodcock Johnson IV: ages 3 to 5</p></a></li>
<li><a href='#WJIV_ages_40_90'><p>Woodcock Johnson IV: ages 40 to 90 plus</p></a></li>
<li><a href='#WJIV_ages_6_8'><p>Woodcock Johnson IV: ages 6 to 8</p></a></li>
<li><a href='#WJIV_ages_9_13'><p>Woodcock Johnson IV: ages 9 to 13</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Fast and Flexible Implementations of Exploratory Factor Analysis
Tools</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions to perform exploratory factor analysis (EFA) procedures and compare their solutions. The goal is to provide state-of-the-art factor retention methods and a high degree of flexibility in the EFA procedures. This way, for example, implementations from R 'psych' and 'SPSS' can be compared. Moreover, functions for Schmid-Leiman transformation and the computation of omegas are provided. To speed up the analyses, some of the iterative procedures, like principal axis factoring (PAF), are implemented in C++.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mdsteiner/EFAtools">https://github.com/mdsteiner/EFAtools</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mdsteiner/EFAtools/issues">https://github.com/mdsteiner/EFAtools/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>lavaan, psych, crayon, stringr, stats, ggplot2, tibble,
magrittr, dplyr, cli, Rcpp, viridisLite, graphics,
future.apply, future, GPArotation, checkmate, tidyr, progressr,
progress, rlang</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, microbenchmark</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-05 10:09:57 UTC; ma1159938</td>
</tr>
<tr>
<td>Author:</td>
<td>Markus Steiner [aut, cre],
  Silvia Grieder [aut],
  William Revelle [ctb],
  Max Auerswald [ctb],
  Morten Moshagen [ctb],
  John Ruscio [ctb],
  Brendan Roche [ctb],
  Urbano Lorenzo-Seva [ctb],
  David Navarro-Gonzalez [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Markus Steiner &lt;markus.d.steiner@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-06 14:50:40 UTC</td>
</tr>
</table>
<hr>
<h2 id='EFAtools-package'>EFAtools: Fast and Flexible Implementations of Exploratory Factor Analysis Tools</h2><span id='topic+EFAtools'></span><span id='topic+EFAtools-package'></span>

<h3>Description</h3>

<p>Provides functions to perform exploratory factor analysis (EFA) procedures and compare their solutions. The goal is to provide state-of-the-art factor retention methods and a high degree of flexibility in the EFA procedures. This way, for example, implementations from R 'psych' and 'SPSS' can be compared. Moreover, functions for Schmid-Leiman transformation and the computation of omegas are provided. To speed up the analyses, some of the iterative procedures, like principal axis factoring (PAF), are implemented in C++.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Markus Steiner <a href="mailto:markus.d.steiner@gmail.com">markus.d.steiner@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Silvia Grieder <a href="mailto:silvia.grieder@gmail.com">silvia.grieder@gmail.com</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> William Revelle [contributor]
</p>
</li>
<li><p> Max Auerswald [contributor]
</p>
</li>
<li><p> Morten Moshagen [contributor]
</p>
</li>
<li><p> John Ruscio [contributor]
</p>
</li>
<li><p> Brendan Roche [contributor]
</p>
</li>
<li><p> Urbano Lorenzo-Seva [contributor]
</p>
</li>
<li><p> David Navarro-Gonzalez [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/mdsteiner/EFAtools">https://github.com/mdsteiner/EFAtools</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/mdsteiner/EFAtools/issues">https://github.com/mdsteiner/EFAtools/issues</a>
</p>
</li></ul>


<hr>
<h2 id='.compute_vars'>Compute explained variances from loadings</h2><span id='topic+.compute_vars'></span>

<h3>Description</h3>

<p>From unrotated loadings compute the communalities and uniquenesses for total
variance. Compute explained variances per factor from rotated loadings (and
factor intercorrelations Phi if oblique rotation was used).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.compute_vars(L_unrot, L_rot, Phi = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".compute_vars_+3A_l_unrot">L_unrot</code></td>
<td>
<p>matrix. Unrotated factor loadings.</p>
</td></tr>
<tr><td><code id=".compute_vars_+3A_l_rot">L_rot</code></td>
<td>
<p>matrix. Rotated factor loadings.</p>
</td></tr>
<tr><td><code id=".compute_vars_+3A_phi">Phi</code></td>
<td>
<p>matrix. Factor intercorrelations. Provide only if oblique rotation
is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with sum of squared loadings, proportion explained variance
from total variance per factor, same as previous but cumulative, Proportion
of explained variance from total explained variance, and same as previous but
cumulative.
</p>

<hr>
<h2 id='.factor_corres'>Compute number of non-matching indicator-to-factor correspondences</h2><span id='topic+.factor_corres'></span>

<h3>Description</h3>

<p>Compute number of non-matching indicator-to-factor correspondences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.factor_corres(x, y, thresh = 0.3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".factor_corres_+3A_x">x</code></td>
<td>
<p>numeric matrix. A matrix of pattern coefficients.</p>
</td></tr>
<tr><td><code id=".factor_corres_+3A_y">y</code></td>
<td>
<p>numeric matrix. A second matrix of coefficients.</p>
</td></tr>
<tr><td><code id=".factor_corres_+3A_thresh">thresh</code></td>
<td>
<p>numeric. The threshold to classify a pattern coefficient as substantial.</p>
</td></tr>
</table>

<hr>
<h2 id='.numformat'>Format numbers for print method</h2><span id='topic+.numformat'></span>

<h3>Description</h3>

<p>Helper function used in the print method for class LOADINGS and SLLOADINGS.
Strips the 0 in front of the decimal point of a number if number &lt; 1, only
keeps the first <code>digits</code> number of digits, and adds an empty space in
front of the number if the number is positive. This way all returned strings
(except for those &gt; 1, which are exceptions in LOADINGS) have the same number
of characters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.numformat(x, digits = 2, print_zero = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".numformat_+3A_x">x</code></td>
<td>
<p>numeric. Number to be formatted.</p>
</td></tr>
<tr><td><code id=".numformat_+3A_digits">digits</code></td>
<td>
<p>numeric. Number of digits after the comma to keep.</p>
</td></tr>
<tr><td><code id=".numformat_+3A_print_zero">print_zero</code></td>
<td>
<p>logical. Whether, if a number is between [-1, 1], the
zero should be omitted or printed (default is FALSE, i.e. omit zeros).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A formated number
</p>

<hr>
<h2 id='.paf_iter'>Perform the iterative PAF procedure</h2><span id='topic+.paf_iter'></span>

<h3>Description</h3>

<p>Function called from within PAF so usually no call to this is needed by the user.
Provides a C++ implementation of the PAF procedure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.paf_iter(h2, criterion, R, n_fac, abs_eig, crit_type, max_iter)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".paf_iter_+3A_h2">h2</code></td>
<td>
<p>numeric. The initial communality estimates.</p>
</td></tr>
<tr><td><code id=".paf_iter_+3A_criterion">criterion</code></td>
<td>
<p>double. The convergence criterion to use.</p>
</td></tr>
<tr><td><code id=".paf_iter_+3A_r">R</code></td>
<td>
<p>matrix. The correlation matrix with the initial communality estimates in the diagonal.</p>
</td></tr>
<tr><td><code id=".paf_iter_+3A_n_fac">n_fac</code></td>
<td>
<p>numeric. The number of factors to extract.</p>
</td></tr>
<tr><td><code id=".paf_iter_+3A_abs_eig">abs_eig</code></td>
<td>
<p>logical. Whether absolute eigenvalues should be used to compute the loadings.</p>
</td></tr>
<tr><td><code id=".paf_iter_+3A_crit_type">crit_type</code></td>
<td>
<p>numeric. Whether maximum absolute differences (crit_type = 1), or sum of differences (crit_type = 2) should be used</p>
</td></tr>
<tr><td><code id=".paf_iter_+3A_max_iter">max_iter</code></td>
<td>
<p>numeric. The number of iterations after which to end the procedure if no convergence has been reached by then.</p>
</td></tr>
</table>

<hr>
<h2 id='.parallel_sim'>Parallel analysis on simulated data.</h2><span id='topic+.parallel_sim'></span>

<h3>Description</h3>

<p>Function called from within PARALLEL so usually no call to this is needed by the user.
Provides a C++ implementation of the PARALLEL simulation procedure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.parallel_sim(n_datasets, n_vars, N, eigen_type, maxit = 10000L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".parallel_sim_+3A_n_datasets">n_datasets</code></td>
<td>
<p>numeric. Number of datasets with dimensions (N, n_vars) to simulate.</p>
</td></tr>
<tr><td><code id=".parallel_sim_+3A_n_vars">n_vars</code></td>
<td>
<p>numeric. Number of variables / indicators in dataset.</p>
</td></tr>
<tr><td><code id=".parallel_sim_+3A_n">N</code></td>
<td>
<p>numeric. Number of cases / observations in dataset.</p>
</td></tr>
<tr><td><code id=".parallel_sim_+3A_eigen_type">eigen_type</code></td>
<td>
<p>numeric. Whether PCA (eigen_type = 1; i.e., leaving diagonal of correlation matrix at 1) or PAF (eigen_type = 2; i.e., setting diagonal of correlation matrix to SMCs).</p>
</td></tr>
<tr><td><code id=".parallel_sim_+3A_maxit">maxit</code></td>
<td>
<p>numeric. Maximum iterations to perform after which to abort.</p>
</td></tr>
</table>

<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='BARTLETT'>Bartlett's test of sphericity</h2><span id='topic+BARTLETT'></span>

<h3>Description</h3>

<p>This function tests whether a correlation matrix is significantly different
from an identity matrix (Bartlett, 1951). If the Bartlett's test is not
significant, the correlation matrix is not suitable for factor analysis
because the variables show too little covariance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BARTLETT(
  x,
  N = NA,
  use = c("pairwise.complete.obs", "all.obs", "complete.obs", "everything",
    "na.or.complete"),
  cor_method = c("pearson", "spearman", "kendall")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BARTLETT_+3A_x">x</code></td>
<td>
<p>data.frame or matrix. Dataframe or matrix of raw data or matrix with
correlations.</p>
</td></tr>
<tr><td><code id="BARTLETT_+3A_n">N</code></td>
<td>
<p>numeric. The number of observations. Needs only be specified if a
correlation matrix is used.</p>
</td></tr>
<tr><td><code id="BARTLETT_+3A_use">use</code></td>
<td>
<p>character. Passed to <code><a href="stats.html#topic+cor">stats::cor</a></code> if raw data
is given as input. Default is &quot;pairwise.complete.obs&quot;.</p>
</td></tr>
<tr><td><code id="BARTLETT_+3A_cor_method">cor_method</code></td>
<td>
<p>character. Passed to <code><a href="stats.html#topic+cor">stats::cor</a></code>.
Default is &quot;pearson&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Bartlett (1951) proposed this statistic to determine a correlation
matrix' suitability for factor analysis. The statistic is approximately
chi square distributed with <code class="reqn">df = \frac{p(p - 1)}{2}</code> and is given by
</p>
<p style="text-align: center;"><code class="reqn">chi^2 = -log(det(R)) (N - 1 - (2 * p + 5)/6)</code>
</p>

<p>where <code class="reqn">det(R)</code> is the determinant of the correlation matrix, <code class="reqn">N</code> is
the sample size, and <code class="reqn">p</code> is the number of variables.
</p>
<p>This tests requires multivariate normality. If this condition is not met,
the Kaiser-Meyer-Olkin criterion (<code><a href="#topic+KMO">KMO</a></code>)
can still be used.
</p>
<p>This function was heavily influenced by the <code><a href="psych.html#topic+cortest.bartlett">psych::cortest.bartlett</a></code> function from the psych package.
</p>
<p>The <code>BARTLETT</code> function can also be called together with the
(<code><a href="#topic+KMO">KMO</a></code>) function and with factor retention criteria
in the <code><a href="#topic+N_FACTORS">N_FACTORS</a></code> function.
</p>


<h3>Value</h3>

<p>A list containing
</p>
<table>
<tr><td><code>chisq</code></td>
<td>
<p>The chi square statistic.</p>
</td></tr>
<tr><td><code>p_value</code></td>
<td>
<p>The p value of the chi square statistic.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>The degrees of freedom for the chi square statistic.</p>
</td></tr>
<tr><td><code>settings</code></td>
<td>
<p>A list of the settings used.</p>
</td></tr>
</table>


<h3>Source</h3>

<p>Bartlett, M. S. (1951). The effect of standardization on a Chi-square
approximation in factor analysis. Biometrika, 38, 337-344.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+KMO">KMO</a></code> for another measure to determine
suitability for factor analysis.
</p>
<p><code><a href="#topic+N_FACTORS">N_FACTORS</a></code> as a wrapper function for this function,
<code><a href="#topic+KMO">KMO</a></code> and several factor retention criteria.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>BARTLETT(test_models$baseline$cormat, N = 500)

</code></pre>

<hr>
<h2 id='CD'>Comparison Data</h2><span id='topic+CD'></span>

<h3>Description</h3>

<p>Factor retention method introduced by Ruscio and Roche (2012). The code was
adapted from the CD code by Auerswald and Moshagen (2017) available at
<a href="https://osf.io/x5cz2/?view_only=d03efba1fd0f4c849a87db82e6705668">https://osf.io/x5cz2/?view_only=d03efba1fd0f4c849a87db82e6705668</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CD(
  x,
  n_factors_max = NA,
  N_pop = 10000,
  N_samples = 500,
  alpha = 0.3,
  use = c("pairwise.complete.obs", "all.obs", "complete.obs", "everything",
    "na.or.complete"),
  cor_method = c("pearson", "spearman", "kendall"),
  max_iter = 50
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CD_+3A_x">x</code></td>
<td>
<p>data.frame or matrix. Dataframe or matrix of raw data.</p>
</td></tr>
<tr><td><code id="CD_+3A_n_factors_max">n_factors_max</code></td>
<td>
<p>numeric. The maximum number of factors to test against.
Larger numbers will increase the duration the procedure takes, but test more
possible solutions. If left NA (default) the maximum number of factors for
which the model is still over-identified (df &gt; 0) is used.</p>
</td></tr>
<tr><td><code id="CD_+3A_n_pop">N_pop</code></td>
<td>
<p>numeric. Size of finite populations of comparison data. Default
is 10000.</p>
</td></tr>
<tr><td><code id="CD_+3A_n_samples">N_samples</code></td>
<td>
<p>numeric. Number of samples drawn from each population.
Default is 500.</p>
</td></tr>
<tr><td><code id="CD_+3A_alpha">alpha</code></td>
<td>
<p>numeric. The alpha level used to test the significance of the
improvement added by an additional factor. Default is .30.</p>
</td></tr>
<tr><td><code id="CD_+3A_use">use</code></td>
<td>
<p>character. Passed to <code><a href="stats.html#topic+cor">stats::cor</a></code>. Default
is &quot;pairwise.complete.obs&quot;. However, for the comparison data procedure,
<code>NA</code> values will be excluded using na.omit(). If missing data should
be handled differently (e.g., imputation), do this before passing the data to
<code>CD()</code>.</p>
</td></tr>
<tr><td><code id="CD_+3A_cor_method">cor_method</code></td>
<td>
<p>character. Passed to <code><a href="stats.html#topic+cor">stats::cor</a></code>.
Default is &quot;pearson&quot;.</p>
</td></tr>
<tr><td><code id="CD_+3A_max_iter">max_iter</code></td>
<td>
<p>numeric. The maximum number of iterations to perform after
which the iterative PAF procedure is halted. Default is 50.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;Parallel analysis (PA) is an effective stopping rule that compares
the eigenvalues of randomly generated data with those for the actual data.
PA takes into account sampling error, and at present it is widely considered
the best available method. We introduce a variant of PA that goes even further
by reproducing the observed correlation matrix rather than generating random
data. Comparison data (CD) with known factorial structure are first generated
using 1 factor, and then the number of factors is increased until the
reproduction of the observed eigenvalues fails to improve significantly&quot;
(Ruscio &amp; Roche, 2012, p. 282).
</p>
<p>The CD implementation here is based on the code by Ruscio and Roche (2012), but
is slightly adapted to increase speed by performing the principal axis factoring
using a C++ based function.
</p>
<p>Note that if the data contains missing values, these will be removed for the
comparison data procedure using <code><a href="stats.html#topic+na.fail">stats::na.omit</a></code>. If
missing data should be treated differently, e.g., by imputation, do this outside
<code>CD</code> and then pass the complete data.
</p>
<p>The <code>CD</code> function can also be called together with other factor retention
criteria in the <code><a href="#topic+N_FACTORS">N_FACTORS</a></code> function.
</p>


<h3>Value</h3>

<p>A list of class CD containing
</p>
<table>
<tr><td><code>n_factors</code></td>
<td>
<p>The number of factors to retain according to comparison data results.</p>
</td></tr>
<tr><td><code>eigenvalues</code></td>
<td>
<p>A vector containing the eigenvalues of the entered data.</p>
</td></tr>
<tr><td><code>RMSE_eigenvalues</code></td>
<td>
<p>A matrix containing the RMSEs between the eigenvalues of the generated data and those of the entered data.</p>
</td></tr>
<tr><td><code>settings</code></td>
<td>
<p>A list of the settings used.</p>
</td></tr>
</table>


<h3>Source</h3>

<p>Auerswald, M., &amp; Moshagen, M. (2019). How to determine the number of
factors to retain in exploratory factor analysis: A comparison of extraction
methods under realistic conditions. Psychological Methods, 24(4), 468–491.
https://doi.org/10.1037/met0000200
</p>
<p>Ruscio, J., &amp; Roche, B. (2012). Determining the number of factors to
retain in an exploratory factor analysis using comparison data of known
factorial structure. Psychological Assessment, 24, 282–292.
doi: 10.1037/a0025697
</p>


<h3>See Also</h3>

<p>Other factor retention criteria: <code><a href="#topic+EKC">EKC</a></code>,
<code><a href="#topic+HULL">HULL</a></code>, <code><a href="#topic+KGC">KGC</a></code>, <code><a href="#topic+PARALLEL">PARALLEL</a></code>, <code><a href="#topic+SMT">SMT</a></code>
</p>
<p><code><a href="#topic+N_FACTORS">N_FACTORS</a></code> as a wrapper function for this and all
the above-mentioned factor retention criteria.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# determine n factors of the GRiPS
CD(GRiPS_raw)

# determine n factors of the DOSPERT risk subscale
CD(DOSPERT_raw)

</code></pre>

<hr>
<h2 id='COMPARE'>Compare two vectors or matrices (communalities or loadings)</h2><span id='topic+COMPARE'></span>

<h3>Description</h3>

<p>The function takes two objects of the same dimensions containing numeric
information (loadings or communalities) and returns a list of class COMPARE
containing summary information of the differences of the objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>COMPARE(
  x,
  y,
  reorder = c("congruence", "names", "none"),
  corres = TRUE,
  thresh = 0.3,
  digits = 4,
  m_red = 0.001,
  range_red = 0.001,
  round_red = 3,
  print_diff = TRUE,
  na.rm = FALSE,
  x_labels = c("x", "y"),
  plot = TRUE,
  plot_red = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="COMPARE_+3A_x">x</code></td>
<td>
<p>matrix, or vector. Loadings or communalities of a factor
analysis output.</p>
</td></tr>
<tr><td><code id="COMPARE_+3A_y">y</code></td>
<td>
<p>matrix, or vector. Loadings or communalities of another
factor analysis output to compare to x.</p>
</td></tr>
<tr><td><code id="COMPARE_+3A_reorder">reorder</code></td>
<td>
<p>character. Whether and how elements / columns should be
reordered. If &quot;congruence&quot; (default), reordering is done according to Tuckers
correspondence coefficient, if &quot;names&quot;, objects according to their names,
if &quot;none&quot;, no reordering is done.</p>
</td></tr>
<tr><td><code id="COMPARE_+3A_corres">corres</code></td>
<td>
<p>logical. Whether factor correspondences should be compared if a
matrix is entered.</p>
</td></tr>
<tr><td><code id="COMPARE_+3A_thresh">thresh</code></td>
<td>
<p>numeric. The threshold to classify a pattern coefficient as substantial. Default is .3.</p>
</td></tr>
<tr><td><code id="COMPARE_+3A_digits">digits</code></td>
<td>
<p>numeric. Number of decimals to print in the output. Default is 4.</p>
</td></tr>
<tr><td><code id="COMPARE_+3A_m_red">m_red</code></td>
<td>
<p>numeric. Number above which the mean and median should be printed
in red (i.e., if .001 is used, the mean will be in red if it is larger than
.001, otherwise it will be displayed in green.) Default is .001.</p>
</td></tr>
<tr><td><code id="COMPARE_+3A_range_red">range_red</code></td>
<td>
<p>numeric. Number above which the min and max should be printed
in red (i.e., if .001 is used, min and max will be in red if the max is larger
than .001, otherwise it will be displayed in green. Default is .001). Note that
the color of min also depends on max, that is min will be displayed in the
same color as max.</p>
</td></tr>
<tr><td><code id="COMPARE_+3A_round_red">round_red</code></td>
<td>
<p>numeric. Number above which the max decimals to round to where
all corresponding elements of x and y are still equal are displayed in red
(i.e., if 3 is used, the number will be in red if it is smaller than
3, otherwise it will be displayed in green). Default is 3.</p>
</td></tr>
<tr><td><code id="COMPARE_+3A_print_diff">print_diff</code></td>
<td>
<p>logical. Whether the difference vector or matrix should be
printed or not. Default is TRUE.</p>
</td></tr>
<tr><td><code id="COMPARE_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Whether NAs should be removed in the mean, median, min,
and max functions. Default is FALSE.</p>
</td></tr>
<tr><td><code id="COMPARE_+3A_x_labels">x_labels</code></td>
<td>
<p>character. A vector of length two containing identifying
labels for the two objects x and y that will be compared. These will be used
as labels on the x-axis of the plot. Default is &quot;x&quot; and &quot;y&quot;.</p>
</td></tr>
<tr><td><code id="COMPARE_+3A_plot">plot</code></td>
<td>
<p>logical. If TRUE (default), a plot illustrating the differences
will be shown.</p>
</td></tr>
<tr><td><code id="COMPARE_+3A_plot_red">plot_red</code></td>
<td>
<p>numeric. Threshold above which to plot the absolute differences
in red. Default is .001.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class COMPARE containing summary statistics on the differences
of x and y.
</p>
<table>
<tr><td><code>diff</code></td>
<td>
<p>The vector or matrix containing the differences between x and y.</p>
</td></tr>
<tr><td><code>mean_abs_diff</code></td>
<td>
<p>The mean absolute difference between x and y.</p>
</td></tr>
<tr><td><code>median_abs_diff</code></td>
<td>
<p>The median absolute difference between x and y.</p>
</td></tr>
<tr><td><code>min_abs_diff</code></td>
<td>
<p>The minimum absolute difference between x and y.</p>
</td></tr>
<tr><td><code>max_abs_diff</code></td>
<td>
<p>The maximum absolute difference between x and y.</p>
</td></tr>
<tr><td><code>max_dec</code></td>
<td>
<p>The maximum number of decimals to which a comparison makes sense.
For example, if x contains only values up to the third decimals, and y is a
normal double, max_dec will be three.</p>
</td></tr>
<tr><td><code>are_equal</code></td>
<td>
<p>The maximal number of decimals to which all elements of x and y
are equal.</p>
</td></tr>
<tr><td><code>diff_corres</code></td>
<td>
<p>The number of differing variable-to-factor correspondences
between x and y, when only the highest loading is considered.</p>
</td></tr>
<tr><td><code>diff_corres_cross</code></td>
<td>
<p>The number of differing variable-to-factor correspondences
between x and y when all loadings <code>&gt;= thresh</code> are considered.</p>
</td></tr>
<tr><td><code>g</code></td>
<td>
<p>The root mean squared distance (RMSE) between x and y.</p>
</td></tr>
<tr><td><code>settings</code></td>
<td>
<p>List of the settings used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># A type SPSS EFA to mimick the SPSS implementation
EFA_SPSS_6 &lt;- EFA(test_models$case_11b$cormat, n_factors = 6, type = "SPSS")

# A type psych EFA to mimick the psych::fa() implementation
EFA_psych_6 &lt;- EFA(test_models$case_11b$cormat, n_factors = 6, type = "psych")

# compare the two
COMPARE(EFA_SPSS_6$unrot_loadings, EFA_psych_6$unrot_loadings,
        x_labels = c("SPSS", "psych"))
</code></pre>

<hr>
<h2 id='DOSPERT'>DOSPERT</h2><span id='topic+DOSPERT'></span>

<h3>Description</h3>

<p>A list containing the the bivariate correlations (cormat) of the 40 items of
the Domain Specific Risk Taking Scale (DOSPERT; Weber, Blais, &amp; Betz, 2002)
and the sample size (N) based on the publicly available dataset at
(<a href="https://osf.io/rce7g">https://osf.io/rce7g</a>) of the Basel-Berlin Risk Study (Frey et al., 2017).
The items measure risk-taking propensity on six different domains: social,
recreational, gambling, health/ safety, investment, and ethical.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DOSPERT
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.
</p>


<h3>Source</h3>

<p>Weber, E. U., Blais, A.-R., &amp; Betz, N. E. (2002). A domain specific risk-attitude scale: Measuring risk perceptions and risk behaviors. Journal of Behavioral Decision Making, 15(4), 263–290. doi: 10.1002/bdm.414
</p>
<p>Frey, R., Pedroni, A., Mata, R., Rieskamp, J., &amp; Hertwig, R. (2017). Risk preference shares the psychometric structure of major psychological traits. Science Advances, 3, e1701381.
</p>
<p><a href="https://osf.io/rce7g">https://osf.io/rce7g</a>
</p>

<hr>
<h2 id='DOSPERT_raw'>DOSPERT_raw</h2><span id='topic+DOSPERT_raw'></span>

<h3>Description</h3>

<p>A data.frame containing responses to the risk subscale of the Domain Specific
Risk Taking Scale (DOSPERT; Weber, Blais, &amp; Betz, 2002) based on the publicly
available dataset (at <a href="https://osf.io/pjt57/">https://osf.io/pjt57/</a>) by Frey, Duncan, and Weber (2020).
The items measure risk-taking propensity on six different domains: social,
recreational, gambling, health/ safety, investment, and ethical.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DOSPERT_raw
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 3123 rows and 30 columns.
</p>


<h3>Source</h3>

<p>Blais, A.-R., &amp; Weber, E. U. (2002). A domain-specific risk-taking (DOSPERT) scale for adult populations. Judgment and Decision Making, 15(4), 263–290. doi: 10.1002/bdm.414
</p>
<p>Frey, R., Duncan, S. M., &amp; Weber, E. U. (2020). Towards a typology of risk preference: Four risk profiles describe two thirds of individuals in a large sample of the U.S. population. PsyArXiv Preprint. doi:10.31234/osf.io/yjwr9
</p>

<hr>
<h2 id='EFA'>Exploratory factor analysis (EFA)</h2><span id='topic+EFA'></span>

<h3>Description</h3>

<p>This function does an EFA with either <code>PAF</code>, <code>ML</code>,
or <code>ULS</code> with or without subsequent rotation.
All arguments with default value <code>NA</code> can be left to default if <code>type</code>
is set to one of &quot;EFAtools&quot;, &quot;SPSS&quot;, or &quot;psych&quot;. The respective specifications are
then handled according to the specified type (see details). For all rotations
except varimax and promax, the <code>GPArotation</code> package is needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EFA(
  x,
  n_factors,
  N = NA,
  method = c("PAF", "ML", "ULS"),
  rotation = c("none", "varimax", "equamax", "quartimax", "geominT", "bentlerT",
    "bifactorT", "promax", "oblimin", "quartimin", "simplimax", "bentlerQ", "geominQ",
    "bifactorQ"),
  type = c("EFAtools", "psych", "SPSS", "none"),
  max_iter = NA,
  init_comm = NA,
  criterion = NA,
  criterion_type = NA,
  abs_eigen = NA,
  use = c("pairwise.complete.obs", "all.obs", "complete.obs", "everything",
    "na.or.complete"),
  varimax_type = NA,
  k = NA,
  normalize = TRUE,
  P_type = NA,
  precision = 1e-05,
  order_type = NA,
  start_method = "psych",
  cor_method = c("pearson", "spearman", "kendall"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EFA_+3A_x">x</code></td>
<td>
<p>data.frame or matrix. Dataframe or matrix of raw data or matrix with
correlations. If raw data is entered, the correlation matrix is found from the
data.</p>
</td></tr>
<tr><td><code id="EFA_+3A_n_factors">n_factors</code></td>
<td>
<p>numeric. Number of factors to extract.</p>
</td></tr>
<tr><td><code id="EFA_+3A_n">N</code></td>
<td>
<p>numeric. The number of observations. Needs only be specified if a
correlation matrix is used. If input is a correlation matrix and <code>N</code> = NA
(default), not all fit indices can be computed.</p>
</td></tr>
<tr><td><code id="EFA_+3A_method">method</code></td>
<td>
<p>character. One of &quot;PAF&quot;, &quot;ML&quot;, or &quot;ULS&quot; to use principal axis
factoring, maximum likelihood, or unweighted least squares (also called minres),
respectively, to fit the EFA.</p>
</td></tr>
<tr><td><code id="EFA_+3A_rotation">rotation</code></td>
<td>
<p>character. Either perform no rotation (&quot;none&quot;; default),
an orthogonal rotation (&quot;varimax&quot;, &quot;equamax&quot;, &quot;quartimax&quot;, &quot;geominT&quot;,
&quot;bentlerT&quot;, or &quot;bifactorT&quot;), or an oblique rotation (&quot;promax&quot;, &quot;oblimin&quot;,
&quot;quartimin&quot;, &quot;simplimax&quot;, &quot;bentlerQ&quot;, &quot;geominQ&quot;, or &quot;bifactorQ&quot;).</p>
</td></tr>
<tr><td><code id="EFA_+3A_type">type</code></td>
<td>
<p>character. If one of &quot;EFAtools&quot; (default), &quot;psych&quot;, or &quot;SPSS&quot; is
used, and the following arguments with default NA are left with
NA, these implementations are executed according to the respective program
(&quot;psych&quot; and &quot;SPSS&quot;) or according to the best solution found in Grieder &amp;
Steiner (2020; &quot;EFAtools&quot;). Individual properties can be adapted using one of
the three types and specifying some of the following arguments. If set to
&quot;none&quot; additional arguments must be specified depending on the <code>method</code>
and <code>rotation</code> used (see details).</p>
</td></tr>
<tr><td><code id="EFA_+3A_max_iter">max_iter</code></td>
<td>
<p>numeric. The maximum number of iterations to perform after which
the iterative PAF procedure is halted with a warning. If <code>type</code> is one of
&quot;EFAtools&quot;, &quot;SPSS&quot;, or &quot;psych&quot;, this is automatically specified if <code>max_iter</code> is
left to be <code>NA</code>, but can be overridden by entering a number. Default is
<code>NA</code>.</p>
</td></tr>
<tr><td><code id="EFA_+3A_init_comm">init_comm</code></td>
<td>
<p>character. The method to estimate the initial communalities
in <code>PAF</code>. &quot;smc&quot; will use squared multiple correlations, &quot;mac&quot; will use
maximum absolute correlations, &quot;unity&quot; will use 1s (see details).
Default is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="EFA_+3A_criterion">criterion</code></td>
<td>
<p>numeric. The convergence criterion used for PAF.
If the change in communalities from one iteration to the next is smaller than
this criterion the solution is accepted and the procedure ends.
Default is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="EFA_+3A_criterion_type">criterion_type</code></td>
<td>
<p>character. Type of convergence criterion used for
PAF. &quot;max_individual&quot; selects the maximum change in any of the
communalities from one iteration to the next and tests it against the
specified criterion. This is also used by SPSS. &quot;sum&quot; takes the difference of
the sum of all communalities in one iteration and the sum of all communalities
in the next iteration and tests this against the criterion. This procedure is
used by the <code><a href="psych.html#topic+fa">psych::fa</a></code> function. Default is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="EFA_+3A_abs_eigen">abs_eigen</code></td>
<td>
<p>logical. Which algorithm to use in the PAF
iterations. If FALSE, the loadings are computed from the eigenvalues. This is
also used by the <code><a href="psych.html#topic+fa">psych::fa</a></code> function. If TRUE the
loadings are computed with the absolute eigenvalues as done by SPSS.
Default is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="EFA_+3A_use">use</code></td>
<td>
<p>character. Passed to <code><a href="stats.html#topic+cor">stats::cor</a></code> if raw data
is given as input. Default is &quot;pairwise.complete.obs&quot;.</p>
</td></tr>
<tr><td><code id="EFA_+3A_varimax_type">varimax_type</code></td>
<td>
<p>character. The type of the varimax rotation performed.
If &quot;svd&quot;, singular value decomposition is used, as <a href="stats.html#topic+varimax">stats::varimax</a> does. If &quot;kaiser&quot;, the varimax procedure performed in SPSS is used.
This is the original procedure from Kaiser (1958), but with slight alterations
in the varimax criterion (see details, and Grieder &amp; Steiner, 2020). Default is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="EFA_+3A_k">k</code></td>
<td>
<p>numeric. Either the power used for computing the target matrix P in
the promax rotation or the number of 'close to zero loadings' for the simplimax
rotation (see <code><a href="GPArotation.html#topic+GPA">GPArotation::GPFoblq</a></code>). If left to
<code>NA</code> (default), the value for promax depends on the specified type.
For simplimax, <code>nrow(L)</code>, where L is the matrix of unrotated loadings,
is used by default.</p>
</td></tr>
<tr><td><code id="EFA_+3A_normalize">normalize</code></td>
<td>
<p>logical. If <code>TRUE</code>, a kaiser normalization is
performed before the specified rotation. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="EFA_+3A_p_type">P_type</code></td>
<td>
<p>character. This specifies how the target
matrix P is computed in promax rotation. If &quot;unnorm&quot; it will use the
unnormalized target matrix as originally done in Hendrickson and White (1964).
This is also used in the psych and stats packages. If &quot;norm&quot; it will use the
normalized target matrix as used in SPSS. Default is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="EFA_+3A_precision">precision</code></td>
<td>
<p>numeric. The tolerance for stopping in the rotation
procedure. Default is 10^-5 for all rotation methods.</p>
</td></tr>
<tr><td><code id="EFA_+3A_order_type">order_type</code></td>
<td>
<p>character. How to order the factors. &quot;eigen&quot; will reorder
the factors according to the largest to lowest eigenvalues of the matrix of
rotated loadings. &quot;ss_factors&quot; will reorder the factors according to descending
sum of squared factor loadings per factor. Default is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="EFA_+3A_start_method">start_method</code></td>
<td>
<p>character. How to specify the starting values for the
optimization procedure for ML. Default is &quot;psych&quot; which takes the
starting values specified in <a href="psych.html#topic+fa">psych::fa</a>. &quot;factanal&quot; takes the
starting values specified in the <a href="stats.html#topic+factanal">stats::factanal</a> function.
Solutions are very similar.</p>
</td></tr>
<tr><td><code id="EFA_+3A_cor_method">cor_method</code></td>
<td>
<p>character. Passed to <code><a href="stats.html#topic+cor">stats::cor</a></code>.
Default is &quot;pearson&quot;.</p>
</td></tr>
<tr><td><code id="EFA_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to rotation functions from the <code>GPArotation</code> package (e.g., <code>maxit</code> for maximum number of iterations).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two main ways to use this function. The easiest way is to
use it with a specified <code>type</code> (see above), which sets most of the other
arguments accordingly. Another way is to use it more flexibly by explicitly
specifying all arguments used and set <code>type</code> to &quot;none&quot; (see examples).
A mix of the two can also be done by specifying a <code>type</code> as well as
additional arguments. However, this will throw warnings to avoid unintentional
deviations from the implementations according to the specified <code>type</code>.
</p>
<p>The <code>type</code> argument is evaluated for PAF and for all rotations (mainly
important for the varimax and promax rotations). The type-specific settings
for these functions are detailed below.
</p>
<p>For PAF, the values of <code>init_comm</code>, <code>criterion</code>, <code>criterion_type</code>,
and <code>abs_eigen</code> depend on the <code>type</code> argument.
</p>
<p><code>type = "EFAtools"</code> will use the following argument specification:
<code>init_comm = "smc", criterion = .001, criterion_type = "sum",
abs_eigen = TRUE</code>.
</p>
<p><code>type = "psych"</code> will use the following argument specification:
<code>init_comm = "smc", criterion = .001, criterion_type = "sum",
abs_eigen = FALSE</code>.
</p>
<p><code>type = "SPSS"</code> will use the following argument specification:
<code>init_comm = "smc", criterion = .001, criterion_type = "max_individual",
abs_eigen = TRUE</code>.
</p>
<p>If SMCs fail, SPSS takes &quot;mac&quot;. However, as SPSS takes absolute eigenvalues,
this is hardly ever the case. Psych, on the other hand, takes &quot;unity&quot; if SMCs
fail, but uses the Moore-Penrose Psudo Inverse of a matrix, thus, taking &quot;unity&quot;
is only necessary if negative eigenvalues occur afterwards in the iterative
PAF procedure. The EFAtools type setting combination was the best in terms of accuracy
and number of Heywood cases compared to all the
other setting combinations tested in simulation studies in Grieder &amp; Steiner
(2020), which is why this type is used as a default here.
</p>
<p>For varimax, the values of <code>varimax_type</code> and <code>order_type</code> depend on
the <code>type</code> argument.
</p>
<p><code>type = "EFAtools"</code> will use the following argument specification:
<code>varimax_type = "kaiser", order_type = "eigen"</code>.
</p>
<p><code>type = "psych"</code> will use the following argument specification:
<code>varimax_type = "svd", order_type = "eigen"</code>.
</p>
<p><code>type = "SPSS"</code> will use the following argument specification:
<code>varimax_type = "kaiser", order_type = "ss_factors"</code>.
</p>
<p>For promax, the values of <code>P_type</code>,
<code>order_type</code>, and <code>k</code> depend on the <code>type</code> argument.
</p>
<p><code>type = "EFAtools"</code> will use the following argument specification:
<code>P_type = "norm", order_type = "eigen", k = 4</code>.
</p>
<p><code>type = "psych"</code> will use the following argument specification:
<code>P_type = "unnorm", order_type = "eigen", k = 4</code>.
</p>
<p><code>type = "SPSS"</code> will use the following argument specification:
<code>P_type = "norm", order_type = "ss_factors", k = 4</code>.
</p>
<p>The <code>P_type</code> argument can take two values, &quot;unnorm&quot; and &quot;norm&quot;. It controls
which formula is used to compute the target matrix P in the promax rotation.
&quot;unnorm&quot; uses the formula from Hendrickson and White (1964), specifically:
<code>P = abs(A^(k + 1)) / A</code>,
where A is the unnormalized matrix containing varimax rotated loadings.
&quot;SPSS&quot; uses the normalized varimax rotated loadings. Specifically it used the
following formula, which can be found in the SPSS 23 and SPSS 27 Algorithms manuals:
<code>P = abs(A / sqrt(rowSums(A^2))) ^(k + 1) * (sqrt(rowSums(A^2)) / A)</code>.
As for PAF, the EFAtools type setting combination for promax was the best
compared to the other setting combinations tested in simulation studies in
Grieder &amp; Steiner (2020).
</p>
<p>The <code>varimax_type</code> argument can take two values, &quot;svd&quot;, and &quot;kaiser&quot;. &quot;svd&quot; uses
singular value decomposition, by calling <a href="stats.html#topic+varimax">stats::varimax</a>. &quot;kaiser&quot;
performs the varimax procedure as described in the SPSS 23 Algorithms manual and as described
by Kaiser (1958). However, there is a slight alteration in computing the varimax criterion, which
we found to better align with the results obtain from SPSS. Specifically, the original varimax
criterion as described in the SPSS 23 Algorithms manual is
<code>sum(n*colSums(lambda ^ 4) - colSums(lambda ^ 2) ^ 2) / n ^ 2</code>, where n is the
number of indicators, and lambda is the rotated loadings matrix. However, we found the following
to produce results more similar to those of SPSS:
<code>sum(n*colSums(abs(lambda)) - colSums(lambda ^ 4) ^ 2) / n^2</code>.
</p>
<p>For all other rotations except varimax and promax, the <code>type</code> argument
only controls the <code>order_type</code> argument with the same values as stated
above for the varimax and promax rotations. For these other rotations, the
<code>GPArotation</code> package is needed. Additional arguments can also be
specified and will be passed to the respective <code>GPArotation</code> function
(e.g., maxit to change the maximum number of iterations for the rotation procedure).
</p>
<p>The <code>type</code> argument has no effect on ULS and ML. For ULS, no additional
arguments are needed. For ML, an additional argument
<code>start_method</code> is needed to determine the starting values for the
optimization procedure. Default for this argument is &quot;factanal&quot; which takes
the starting values specified in the <a href="stats.html#topic+factanal">stats::factanal</a> function.
</p>


<h3>Value</h3>

<p>A list of class EFA containing (a subset of) the following:
</p>
<table>
<tr><td><code>orig_R</code></td>
<td>
<p>Original correlation matrix.</p>
</td></tr>
<tr><td><code>h2_init</code></td>
<td>
<p>Initial communality estimates from PAF.</p>
</td></tr>
<tr><td><code>h2</code></td>
<td>
<p>Final communality estimates from the unrotated solution.</p>
</td></tr>
<tr><td><code>orig_eigen</code></td>
<td>
<p>Eigen values of the original correlation matrix.</p>
</td></tr>
<tr><td><code>init_eigen</code></td>
<td>
<p>Initial eigenvalues, obtained from the correlation matrix
with the initial communality estimates as diagonal in PAF.</p>
</td></tr>
<tr><td><code>final_eigen</code></td>
<td>
<p>Eigenvalues obtained from the correlation matrix
with the final communality estimates as diagonal.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>The number of iterations needed for convergence.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>Integer code for convergence as returned by
<code><a href="stats.html#topic+optim">stats:optim</a></code> (only for ML and ULS).
0 indicates successful completion.</p>
</td></tr>
<tr><td><code>unrot_loadings</code></td>
<td>
<p>Loading matrix containing the final unrotated loadings.</p>
</td></tr>
<tr><td><code>vars_accounted</code></td>
<td>
<p>Matrix of explained variances and sums of squared loadings. Based on the unrotated loadings.</p>
</td></tr>
<tr><td><code>fit_indices</code></td>
<td>
<p>For ML and ULS: Fit indices derived from the unrotated
factor loadings: Chi Square, including significance level, degrees of freedom
(df), Comparative Fit Index (CFI), Root Mean Square Error of Approximation
(RMSEA), including its 90% confidence interval, Akaike Information Criterion
(AIC), Bayesian Information Criterion (BIC), and the common part accounted
for (CAF) index as proposed by Lorenzo-Seva, Timmerman, &amp; Kiers (2011).
For PAF, only the CAF and dfs are returned.</p>
</td></tr>
<tr><td><code>rot_loadings</code></td>
<td>
<p>Loading matrix containing the final rotated loadings
(pattern matrix).</p>
</td></tr>
<tr><td><code>Phi</code></td>
<td>
<p>The factor intercorrelations (only for oblique rotations).</p>
</td></tr>
<tr><td><code>Structure</code></td>
<td>
<p>The structure matrix (only for oblique rotations).</p>
</td></tr>
<tr><td><code>rotmat</code></td>
<td>
<p>The rotation matrix.</p>
</td></tr>
<tr><td><code>vars_accounted_rot</code></td>
<td>
<p>Matrix of explained variances and sums of squared
loadings. Based on rotated loadings and, for oblique rotations, the factor
intercorrelations.</p>
</td></tr>
<tr><td><code>settings</code></td>
<td>
<p>A list of the settings used.</p>
</td></tr>
</table>


<h3>Source</h3>

<p>Grieder, S., &amp; Steiner, M.D. (2020). Algorithmic Jingle Jungle:
A Comparison of Implementations of Principal Axis Factoring and Promax Rotation
in R and SPSS. Manuscript in Preparation.
</p>
<p>Hendrickson, A. E., &amp; White, P. O. (1964). Promax: A quick method for
rotation to oblique simple structure. British Journal of Statistical Psychology,
17 , 65–70. doi: 10.1111/j.2044-8317.1964.tb00244.x
</p>
<p>Lorenzo-Seva, U., Timmerman, M. E., &amp; Kiers, H. A. L. (2011). The
Hull Method for Selecting the Number of Common Factors, Multivariate Behavioral
Research, 46, 340-364, doi: 10.1080/00273171.2011.564527
</p>
<p>Kaiser, H. F. (1958). The varimax criterion for analytic rotation in
factor analysis. Psychometrika, 23, 187–200. doi: 10.1007/BF02289233
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A type EFAtools (as presented in Steiner and Grieder, 2020) EFA
EFAtools_PAF &lt;- EFA(test_models$baseline$cormat, n_factors = 3, N = 500,
                    type = "EFAtools", method = "PAF", rotation = "none")

# A type SPSS EFA to mimick the SPSS implementation (this will throw a warning,
# see below)
SPSS_PAF &lt;- EFA(test_models$baseline$cormat, n_factors = 3, N = 500,
                type = "SPSS", method = "PAF", rotation = "none")

# A type psych EFA to mimick the psych::fa() implementation
psych_PAF &lt;- EFA(test_models$baseline$cormat, n_factors = 3, N = 500,
                 type = "psych", method = "PAF", rotation = "none")

# Use ML instead of PAF with type EFAtools
EFAtools_ML &lt;- EFA(test_models$baseline$cormat, n_factors = 3, N = 500,
                   type = "EFAtools", method = "ML", rotation = "none")

# Use oblimin rotation instead of no rotation with type EFAtools
EFAtools_oblim &lt;- EFA(test_models$baseline$cormat, n_factors = 3, N = 500,
                      type = "EFAtools", method = "PAF", rotation = "oblimin")

# Do a PAF without rotation without specifying a type, so the arguments
# can be flexibly specified (this is only recommended if you know what your
# doing)
PAF_none &lt;- EFA(test_models$baseline$cormat, n_factors = 3, N = 500,
                type = "none", method = "PAF", rotation = "none",
                max_iter = 500, init_comm = "mac", criterion = 1e-4,
                criterion_type = "sum", abs_eigen = FALSE)

# Add a promax rotation
PAF_pro &lt;- EFA(test_models$baseline$cormat, n_factors = 3, N = 500,
               type = "none", method = "PAF", rotation = "promax",
               max_iter = 500, init_comm = "mac", criterion = 1e-4,
               criterion_type = "sum", abs_eigen = FALSE, k = 3,
               P_type = "unnorm", precision= 1e-5, order_type = "eigen",
               varimax_type = "svd")

</code></pre>

<hr>
<h2 id='EFA_AVERAGE'>Model averaging across different EFA methods and types</h2><span id='topic+EFA_AVERAGE'></span>

<h3>Description</h3>

<p>Not all EFA procedures always arrive at the same solution. This function allows
you perform a number of EFAs from different methods (e.g., Maximum Likelihood
and Principal Axis Factoring), with different implementations (e.g., the SPSS
and psych implementations of Principal Axis Factoring), and across different
rotations of the same type (e.g., multiple oblique rotations, like promax and
oblimin). EFA_AVERAGE will then run all these EFAs (using the <code><a href="#topic+EFA">EFA</a></code>
function) and provide a summary across the different solutions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EFA_AVERAGE(
  x,
  n_factors,
  N = NA,
  method = "PAF",
  rotation = "promax",
  type = "none",
  averaging = c("mean", "median"),
  trim = 0,
  salience_threshold = 0.3,
  max_iter = 10000,
  init_comm = c("smc", "mac", "unity"),
  criterion = c(0.001),
  criterion_type = c("sum", "max_individual"),
  abs_eigen = c(TRUE),
  varimax_type = c("svd", "kaiser"),
  normalize = TRUE,
  k_promax = 2:4,
  k_simplimax = ncol(x),
  P_type = c("norm", "unnorm"),
  precision = 1e-05,
  start_method = c("psych", "factanal"),
  use = c("pairwise.complete.obs", "all.obs", "complete.obs", "everything",
    "na.or.complete"),
  cor_method = c("pearson", "spearman", "kendall"),
  show_progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EFA_AVERAGE_+3A_x">x</code></td>
<td>
<p>data.frame or matrix. Dataframe or matrix of raw data or matrix with
correlations. If raw data is entered, the correlation matrix is found from the
data.</p>
</td></tr>
<tr><td><code id="EFA_AVERAGE_+3A_n_factors">n_factors</code></td>
<td>
<p>numeric. Number of factors to extract.</p>
</td></tr>
<tr><td><code id="EFA_AVERAGE_+3A_n">N</code></td>
<td>
<p>numeric. The number of observations. Needs only be specified if a
correlation matrix is used. If input is a correlation matrix and <code>N</code> = NA
(default), not all fit indices can be computed.</p>
</td></tr>
<tr><td><code id="EFA_AVERAGE_+3A_method">method</code></td>
<td>
<p>character vector. Any combination of  &quot;PAF&quot;, &quot;ML&quot;, and &quot;ULS&quot;,
to use principal axis factoring, maximum likelihood, or unweighted least
squares (also called minres), respectively, to fit the EFAs. Default is &quot;PAF&quot;.</p>
</td></tr>
<tr><td><code id="EFA_AVERAGE_+3A_rotation">rotation</code></td>
<td>
<p>character vector. Either perform no rotation (&quot;none&quot;),
any combination of orthogonal rotations (&quot;varimax&quot;, &quot;equamax&quot;, &quot;quartimax&quot;, &quot;geominT&quot;,
&quot;bentlerT&quot;, and &quot;bifactorT&quot;; using &quot;orthogonal&quot; runs all of these), or of
oblique rotations (&quot;promax&quot;, &quot;oblimin&quot;, &quot;quartimin&quot;, &quot;simplimax&quot;, &quot;bentlerQ&quot;,
&quot;geominQ&quot;, and &quot;bifactorQ&quot;; using &quot;oblique&quot; runs all of these). Rotation types
(no rotation, orthogonal rotations, and oblique rotations) cannot be mixed.
Default is &quot;promax&quot;.</p>
</td></tr>
<tr><td><code id="EFA_AVERAGE_+3A_type">type</code></td>
<td>
<p>character vector. Any combination of &quot;none&quot; (default), &quot;EFAtools&quot;,
&quot;psych&quot;, and &quot;SPSS&quot; can be entered. &quot;none&quot; allows the specification of various
combinations of the arguments controlling both factor extraction methods and
the rotations. The others (&quot;EFAtools&quot;, &quot;psych&quot;, and &quot;SPSS&quot;), control the execution
of the respective factor extraction method and rotation to be in line with how
it is executed in this package (i.e., the respective default procedure), in the
psych package, and in SPSS. A specific psych implementation exists for PAF, ML, varimax,
and promax. The SPSS implementation exists for PAF, varimax, and promax. For
details, see <code><a href="#topic+EFA">EFA</a></code>.</p>
</td></tr>
<tr><td><code id="EFA_AVERAGE_+3A_averaging">averaging</code></td>
<td>
<p>character. One of &quot;mean&quot; (default), and &quot;median&quot;. Controls
whether the different results should be averaged using the (trimmed) mean,
or the median.</p>
</td></tr>
<tr><td><code id="EFA_AVERAGE_+3A_trim">trim</code></td>
<td>
<p>numeric. If averaging is set to &quot;mean&quot;, this argument controls
the trimming of extremes (for details see <code><a href="base.html#topic+mean">base::mean</a></code>).
By default no trimming is done (i.e., trim = 0).</p>
</td></tr>
<tr><td><code id="EFA_AVERAGE_+3A_salience_threshold">salience_threshold</code></td>
<td>
<p>numeric. The threshold to use to classify a pattern
coefficient or loading as salient (i.e., substantial enough to assign it to
a factor). Default is 0.3. Indicator-to-factor correspondences will be inferred
based on this threshold. Note that this may not be meaningful if rotation = &quot;none&quot;
and n_factors &gt; 1 are used, as no simple structure is present there.</p>
</td></tr>
<tr><td><code id="EFA_AVERAGE_+3A_max_iter">max_iter</code></td>
<td>
<p>numeric. The maximum number of iterations to perform after which
the iterative PAF procedure is halted with a warning. Default is 10,000. Note
that non-converged procedures are excluded from the averaging procedure.</p>
</td></tr>
<tr><td><code id="EFA_AVERAGE_+3A_init_comm">init_comm</code></td>
<td>
<p>character vector. Any combination of &quot;smc&quot;, &quot;mac&quot;, and &quot;unity&quot;.
Controls the methods to estimate the initial communalities in <code>PAF</code> if
&quot;none&quot; is among the specified types. &quot;smc&quot; will use squared multiple
correlations, &quot;mac&quot; will use maximum absolute correlations, &quot;unity&quot; will use
1s (for details see <code><a href="#topic+EFA">EFA</a></code>). Default is <code>c("smc", "mac", "unity")</code>.</p>
</td></tr>
<tr><td><code id="EFA_AVERAGE_+3A_criterion">criterion</code></td>
<td>
<p>numeric vector. The convergence criterion used for PAF if
&quot;none&quot; is among the specified types.
If the change in communalities from one iteration to the next is smaller than
this criterion the solution is accepted and the procedure ends.
Default is <code>0.001</code>.</p>
</td></tr>
<tr><td><code id="EFA_AVERAGE_+3A_criterion_type">criterion_type</code></td>
<td>
<p>character vector. Any combination of &quot;max_individual&quot; and
&quot;sum&quot;. Type of convergence criterion used for PAF if &quot;none&quot; is among the
specified types. &quot;max_individual&quot; selects the maximum change in any of the
communalities from one iteration to the next and tests it against the
specified criterion. &quot;sum&quot; takes the difference of
the sum of all communalities in one iteration and the sum of all communalities
in the next iteration and tests this against the criterion
(for details see <code><a href="#topic+EFA">EFA</a></code>). Default is <code>c("sum", "max_individual")</code>.</p>
</td></tr>
<tr><td><code id="EFA_AVERAGE_+3A_abs_eigen">abs_eigen</code></td>
<td>
<p>logical vector. Any combination of TRUE and FALSE.
Which algorithm to use in the PAF iterations if &quot;none&quot; is among the specified
types. If FALSE, the loadings are computed from the eigenvalues. This is also
used by the <code><a href="psych.html#topic+fa">psych::fa</a></code> function. If TRUE the
loadings are computed with the absolute eigenvalues as done by SPSS
(for details see <code><a href="#topic+EFA">EFA</a></code>). Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="EFA_AVERAGE_+3A_varimax_type">varimax_type</code></td>
<td>
<p>character vector. Any combination of &quot;svd&quot; and &quot;kaiser&quot;.
The type of the varimax rotation performed if &quot;none&quot; is among the specified
types and &quot;varimax&quot;, &quot;promax&quot;, &quot;orthogonal&quot;, or &quot;oblique&quot; is among the specified
rotations. &quot;svd&quot; uses singular value decomposition, as
<a href="stats.html#topic+varimax">stats::varimax</a> does, and &quot;kaiser&quot; uses the varimax
procedure performed in SPSS. This is the original procedure from Kaiser (1958),
but with slight alterations in the varimax criterion (for details, see
<code><a href="#topic+EFA">EFA</a></code> and Grieder &amp; Steiner, 2020).
Default is <code>c("svd", "kaiser")</code>.</p>
</td></tr>
<tr><td><code id="EFA_AVERAGE_+3A_normalize">normalize</code></td>
<td>
<p>logical vector. Any combination of TRUE and FALSE.
<code>TRUE</code> performs a kaiser normalization before the specified rotation(s).
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="EFA_AVERAGE_+3A_k_promax">k_promax</code></td>
<td>
<p>numeric vector. The power used for computing the target matrix
P in the promax rotation if &quot;none&quot; is among the specified types and &quot;promax&quot;
or &quot;oblique&quot; is among the specified rotations. Default is <code>2:4</code>.</p>
</td></tr>
<tr><td><code id="EFA_AVERAGE_+3A_k_simplimax">k_simplimax</code></td>
<td>
<p>numeric. The number of 'close to zero loadings' for the
simplimax rotation (see <code><a href="GPArotation.html#topic+GPA">GPArotation::GPFoblq</a></code>)
if &quot;simplimax&quot; or &quot;oblique&quot; is among the specified rotations. Default
is <code>ncol(x)</code>, where x is the entered data.</p>
</td></tr>
<tr><td><code id="EFA_AVERAGE_+3A_p_type">P_type</code></td>
<td>
<p>character vector. Any combination of &quot;norm&quot; and &quot;unnorm&quot;.
This specifies how the target matrix P is computed in promax rotation if
&quot;none&quot; is among the specified types and &quot;promax&quot; or &quot;oblique&quot; is among the
specified rotations. &quot;unnorm&quot; will use the unnormalized target matrix as
originally done in Hendrickson and White (1964). &quot;norm&quot; will use a
normalized target matrix (for details see <code><a href="#topic+EFA">EFA</a></code>).
Default is <code>c("norm", "unnorm")</code>.</p>
</td></tr>
<tr><td><code id="EFA_AVERAGE_+3A_precision">precision</code></td>
<td>
<p>numeric vector. The tolerance for stopping in the rotation
procedure(s). Default is 10^-5.</p>
</td></tr>
<tr><td><code id="EFA_AVERAGE_+3A_start_method">start_method</code></td>
<td>
<p>character vector. Any combination of &quot;psych&quot; and &quot;factanal&quot;.
How to specify the starting values for the optimization procedure for ML.
&quot;psych&quot; takes the starting values specified in <a href="psych.html#topic+fa">psych::fa</a>.
&quot;factanal&quot; takes the starting values specified in the
<a href="stats.html#topic+factanal">stats::factanal</a> function. Default is
<code>c("psych", "factanal")</code>.</p>
</td></tr>
<tr><td><code id="EFA_AVERAGE_+3A_use">use</code></td>
<td>
<p>character. Passed to <code><a href="stats.html#topic+cor">stats::cor</a></code> if raw data
is given as input. Default is &quot;pairwise.complete.obs&quot;.</p>
</td></tr>
<tr><td><code id="EFA_AVERAGE_+3A_cor_method">cor_method</code></td>
<td>
<p>character. Passed to <code><a href="stats.html#topic+cor">stats::cor</a></code>.
Default is &quot;pearson&quot;.</p>
</td></tr>
<tr><td><code id="EFA_AVERAGE_+3A_show_progress">show_progress</code></td>
<td>
<p>logical. Whether a progress bar should be shown in the
console. Default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As a first step in this function, a grid is produced containing the setting
combinations for the to-be-performed EFAs. These settings are then entered as
arguments to the <code><a href="#topic+EFA">EFA</a></code> function and the EFAs are run in a second
step. After all EFAs are run, the factor solutions are averaged and their
variability determined in a third step.
</p>
<p>The grid containing the setting combinations is produced based on the entries
to the respective arguments. To this end, all possible combinations resulting
in unique EFA models are considered. That is, if, for example, the <code>type</code>
argument was set to <code>c("none", "SPSS")</code> and one combination of the specific
settings entered was identical to the SPSS combination, this combination
would be included in the grid and run only once. We include here a list
of arguments that are only evaluated under specific conditions:
</p>
<p>The arguments <code>init_comm</code>, <code>criterion</code>, <code>criterion_type</code>,
<code>abs_eigen</code> are only evaluated if &quot;PAF&quot; is included in <code>method</code>
and &quot;none&quot; is included in <code>type</code>.
</p>
<p>The argument <code>varimax_type</code> is only evaluated if &quot;varimax&quot;, &quot;promax&quot;,
&quot;oblique&quot;, or &quot;orthogonal&quot; is included in <code>rotation</code> and &quot;none&quot; is
included in <code>type</code>.
</p>
<p>The argument <code>normalize</code> is only evaluated if <code>rotation</code> is not
set to &quot;none&quot; and &quot;none&quot; is included in <code>type</code>.
</p>
<p>The argument <code>k_simplimax</code> is only evaluated if &quot;simplimax&quot; or &quot;oblique&quot;
is included in <code>rotation</code>.
</p>
<p>The arguments <code>k_promax</code> and <code>P_type</code> are only evaluated if
&quot;promax&quot; or &quot;oblique&quot; is included in <code>rotation</code> and &quot;none&quot; is included
in <code>type</code>.
</p>
<p>The argument <code>start_method</code> is only evaluated if &quot;ML&quot; is included in
<code>method</code>.
</p>
<p>To avoid a bias in the averaged factor solutions from problematic solutions,
these are excluded prior to averaging. A solution is deemed problematic if
at least one of the following is true: an error occurred, the model did not
converge, or there is at least one Heywood case (defined as a loading or communality of &gt;= .998).
Information on errors, convergence, and Heywood cases are returned in the
implementations_grid and a summary of these is given when printing the output.
In addition to these, information on the admissibility of the factor solutions
is also included. A solution was deemed admissible if (1) no error occurred,
(2) the model converged, (3) no Heywood cases are present, and (4) there are
at least two salient loadings (i.e., loadings exceeding the specified
<code>salience_threshold</code>) for each factor. So, solutions failing one of the
first three of these criteria of admissibility are also deemed problematic and
therefore excluded from averaging. However, solutions failing only
the fourth criterion of admissibility are still included for averaging.
Finally, if all solutions are problematic (e.g., all solutions contain
Heywood cases), no averaging is performed and the respective outputs are NA.
In this case, the implementations_grid should be inspected to see if there
are any error messages, and the separate EFA solutions that are also included
in the output can be inspected as well, for example, to see where Heywood
cases occurred.
</p>
<p>A core output of this function includes the average, minimum, and maximum
loadings derived from all non-problematic (see above) factor solutions. Please
note that these are not entire solutions, but the matrices include the average,
minimum, or maximum value for each cell (i.e., each loading separately). This
means that, for example, the matrix with the minimum loadings will contain
the minimum value in any of the factor solutions for each specific loading,
and therefore most likely contains loadings from different factor solutions.
The matrices containing the minimum and maximum factor solutions can
therefore not be interpreted as whole factor solutions.
</p>
<p>The output also includes information on the average, minimum, maximum, and
variability of the fit indices across the non-problematic factor solutions.
It is important to note that not all fit indices are computed for all fit
methods: For ML and ULS, all fit indices can be computed, while for PAF, only
the common part accounted for (CAF) index (Lorenzo-Seva, Timmerman, &amp; Kiers, 2011)
can be computed. As a consequence, if only &quot;PAF&quot; is included in the
<code>method</code> argument, averaging can only be performed for the CAF, and the
other fit indices are NA. If a combination of &quot;PAF&quot; and &quot;ML&quot; and/or &quot;ULS&quot; are
included in the <code>method</code> argument, the CAF is averaged across all non-
problematic factor solutions, while all other fit indices are only averaged
across the ML and ULS solutions. The user should therefore keep in mind that
the number of EFAs across which the fit indices are averaged can diverge for
the CAF compared to all other fit indices.
</p>


<h3>Value</h3>

<p>A list of class EFA_AVERAGE containing
</p>
<table>
<tr><td><code>orig_R</code></td>
<td>
<p>Original correlation matrix.</p>
</td></tr>
<tr><td><code>h2</code></td>
<td>
<p>A list with the average, standard deviation, minimum, maximum, and
range of the final communality estimates across the factor solutions.</p>
</td></tr>
<tr><td><code>loadings</code></td>
<td>
<p>A list with the average, standard deviation, minimum, maximum,
and range of the final loadings across the factor solutions. If rotation was
&quot;none&quot;, the unrotated loadings, otherwise the rotated loadings (pattern
coefficients).</p>
</td></tr>
<tr><td><code>Phi</code></td>
<td>
<p>A list with the average, standard deviation, minimum, maximum, and
range of the factor intercorrelations across factor solutions obtained with
oblique rotations.</p>
</td></tr>
<tr><td><code>ind_fac_corres</code></td>
<td>
<p>A matrix with each cell containing the proportion of
the factor solutions in which the respective indicator-to-factor correspondence
occurred, i.e., in which the loading exceeded the specified salience threshold.
Note: Rowsums can exceed 1 due to cross-loadings.</p>
</td></tr>
<tr><td><code>vars_accounted</code></td>
<td>
<p>A list with the average, standard deviation, minimum,
maximum, and range of explained variances and sums of squared loadings across
the factor solutions. Based on the unrotated loadings.</p>
</td></tr>
<tr><td><code>fit_indices</code></td>
<td>
<p>A matrix containing the average, standard deviation,
minimum, maximum, and range for all applicable fit indices across the respective
factor solutions, and the degrees of freedom (df). If the method argument
contains ML or ULS: Fit indices derived
from the unrotated factor loadings: Chi Square (chisq), including significance
level, Comparative Fit Index (CFI), Root Mean Square Error of Approximation
(RMSEA), Akaike Information Criterion (AIC), Bayesian Information Criterion
(BIC)and the common part accounted for (CAF) index as proposed by
Lorenzo-Seva, Timmerman, &amp; Kiers (2011). For PAF, only the CAF can be
calculated (see details).</p>
</td></tr>
<tr><td><code>implementations_grid</code></td>
<td>
<p>A matrix containing, for each performed EFA,
the setting combination, if an error occurred (logical), the error message
(character), an integer code for convergence as returned by
<code><a href="stats.html#topic+optim">stats:optim</a></code> (0 indicates successful completion.),
if heywood cases occurred (logical, see details for definition), if the
solution was admissible (logical, see details for definition), and the fit
indices.</p>
</td></tr>
<tr><td><code>efa_list</code></td>
<td>
<p>A list containing the outputs of all performed EFAs. The names
correspond to the rownames from the implementations_grid.</p>
</td></tr>
<tr><td><code>settings</code></td>
<td>
<p>A list of the settings used.</p>
</td></tr>
</table>


<h3>Source</h3>

<p>Grieder, S., &amp; Steiner, M.D. (2020). Algorithmic Jingle Jungle:
A Comparison of Implementations of Principal Axis Factoring and Promax Rotation
in R and SPSS. Manuscript in Preparation.
</p>
<p>Hendrickson, A. E., &amp; White, P. O. (1964). Promax: A quick method for
rotation to oblique simple structure. British Journal of Statistical Psychology,
17 , 65–70. doi: 10.1111/j.2044-8317.1964.tb00244.x
</p>
<p>Lorenzo-Seva, U., Timmerman, M. E., &amp; Kiers, H. A. L. (2011). The
Hull Method for Selecting the Number of Common Factors, Multivariate Behavioral
Research, 46, 340-364, doi: 10.1080/00273171.2011.564527
</p>
<p>Kaiser, H. F. (1958). The varimax criterion for analytic rotation in
factor analysis. Psychometrika, 23, 187–200. doi: 10.1007/BF02289233
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Averaging across different implementations of PAF and promax rotation (72 EFAs)
Aver_PAF &lt;- EFA_AVERAGE(test_models$baseline$cormat, n_factors = 3, N = 500)

# Use median instead of mean for averaging (72 EFAs)
Aver_PAF_md &lt;- EFA_AVERAGE(test_models$baseline$cormat, n_factors = 3, N = 500,
                           averaging = "median")

# Averaging across different implementations of PAF and promax rotation,
# and across ULS and different versions of ML (108 EFAs)
Aver_meth_ext &lt;- EFA_AVERAGE(test_models$baseline$cormat, n_factors = 3, N = 500,
                             method = c("PAF", "ULS", "ML"))

# Averaging across one implementation each of PAF (EFAtools type), ULS, and
# ML with one implementation of promax (EFAtools type) (3 EFAs)
Aver_meth &lt;- EFA_AVERAGE(test_models$baseline$cormat, n_factors = 3, N = 500,
                         method = c("PAF", "ULS", "ML"), type = "EFAtools",
                         start_method = "psych")

# Averaging across different oblique rotation methods, using one implementation
# of ML and one implementation of promax (EFAtools type) (7 EFAs)
Aver_rot &lt;- EFA_AVERAGE(test_models$baseline$cormat, n_factors = 3, N = 500,
                         method = "ML", rotation = "oblique", type = "EFAtools",
                         start_method = "psych")

## End(Not run)

</code></pre>

<hr>
<h2 id='EKC'>Empirical Kaiser Criterion</h2><span id='topic+EKC'></span>

<h3>Description</h3>

<p>The empirical Kaiser criterion incorporates random sampling variations of the
eigenvalues from the Kaiser-Guttman criterion (<code><a href="#topic+KGC">KGC</a></code>; see Auerswald &amp; Moshagen
, 2019; Braeken &amp; van Assen, 2017). The code is based on Auerswald and Moshagen
(2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EKC(
  x,
  N = NA,
  use = c("pairwise.complete.obs", "all.obs", "complete.obs", "everything",
    "na.or.complete"),
  cor_method = c("pearson", "spearman", "kendall")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EKC_+3A_x">x</code></td>
<td>
<p>data.frame or matrix. data.frame or matrix of raw data or matrix with
correlations.</p>
</td></tr>
<tr><td><code id="EKC_+3A_n">N</code></td>
<td>
<p>numeric. The number of observations. Only needed if x is a correlation
matrix.</p>
</td></tr>
<tr><td><code id="EKC_+3A_use">use</code></td>
<td>
<p>character. Passed to <code><a href="stats.html#topic+cor">stats::cor</a></code> if raw
data is given as input. Default is  <code>"pairwise.complete.obs"</code>.</p>
</td></tr>
<tr><td><code id="EKC_+3A_cor_method">cor_method</code></td>
<td>
<p>character. Passed to <code><a href="stats.html#topic+cor">stats::cor</a></code>.
Default is  <code>"pearson"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Kaiser-Guttman criterion was defined with the intend that a factor
should only be extracted if it explains at least as much variance as a single
factor (see <code><a href="#topic+KGC">KGC</a></code>). However, this only applies to population-level
correlation matrices. Due to sampling variation, the KGC strongly overestimates
the number of factors to retrieve (e.g., Zwick &amp; Velicer, 1986). To account
for this and to introduce a factor retention method that performs well with
small number of indicators and correlated factors (cases where the performance
of parallel analysis, see <code><a href="#topic+PARALLEL">PARALLEL</a></code>, is known to deteriorate)
Braeken and van Assen (2017) introduced the empirical Kaiser criterion in
which a series of reference eigenvalues is created as a function of the
variables-to-sample-size ratio and the observed eigenvalues.
</p>
<p>Braeken and van Assen (2017) showed that &quot;(a) EKC performs about as well as
parallel analysis for data arising from the null, 1-factor, or orthogonal
factors model; and (b) clearly outperforms parallel analysis for the specific
case of oblique factors, particularly whenever factor intercorrelation is
moderate to high and the number of variables per factor is small, which is
characteristic of many applications these days&quot; (p.463-464).
</p>
<p>The <code>EKC</code> function can also be called together with other factor
retention criteria in the <code><a href="#topic+N_FACTORS">N_FACTORS</a></code> function.
</p>


<h3>Value</h3>

<p>A list of class EKC containing
</p>
<table>
<tr><td><code>eigenvalues</code></td>
<td>
<p>A vector containing the eigenvalues found on the correlation matrix of the entered data.</p>
</td></tr>
<tr><td><code>n_factors</code></td>
<td>
<p>The number of factors to retain according to the empirical Kaiser criterion.</p>
</td></tr>
<tr><td><code>references</code></td>
<td>
<p>The reference eigenvalues.</p>
</td></tr>
<tr><td><code>settings</code></td>
<td>
<p>A list with the settings used.</p>
</td></tr>
</table>


<h3>Source</h3>

<p>Auerswald, M., &amp; Moshagen, M. (2019). How to determine the number of
factors to retain in exploratory factor analysis: A comparison of extraction
methods under realistic conditions. Psychological Methods, 24(4), 468–491.
https://doi.org/10.1037/met0000200
</p>
<p>Braeken, J., &amp; van Assen, M. A. (2017). An empirical Kaiser criterion.
Psychological Methods, 22, 450 – 466. http://dx.doi.org/10.1037/ met0000074
</p>
<p>Zwick, W. R., &amp; Velicer, W. F. (1986). Comparison of five rules for
determining the number of components to retain. Psychological Bulletin, 99,
432–442. http://dx.doi.org/10.1037/0033-2909.99.3.432
</p>


<h3>See Also</h3>

<p>Other factor retention criteria: <code><a href="#topic+CD">CD</a></code>,
<code><a href="#topic+HULL">HULL</a></code>, <code><a href="#topic+KGC">KGC</a></code>, <code><a href="#topic+PARALLEL">PARALLEL</a></code>,
<code><a href="#topic+SMT">SMT</a></code>
</p>
<p><code><a href="#topic+N_FACTORS">N_FACTORS</a></code> as a wrapper function for this and all
the above-mentioned factor retention criteria.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>EKC(test_models$baseline$cormat, N = 500)
</code></pre>

<hr>
<h2 id='FACTOR_SCORES'>Estimate factor scores for an EFA model</h2><span id='topic+FACTOR_SCORES'></span>

<h3>Description</h3>

<p>This is a wrapper function for
<code><a href="psych.html#topic+factor.scores">psych::factor.scores</a></code> to be used directly
with an output from <code><a href="#topic+EFA">EFA</a></code> or by manually specifying the factor
loadings and intercorrelations. Calculates factor scores according to the
specified methods if raw data are provided, and only factor weights if a
correlation matrix is provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FACTOR_SCORES(
  x,
  f,
  Phi = NULL,
  method = c("Thurstone", "tenBerge", "Anderson", "Bartlett", "Harman", "components"),
  impute = c("none", "means", "median")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FACTOR_SCORES_+3A_x">x</code></td>
<td>
<p>data.frame or matrix. Dataframe or matrix of raw data (needed to get
factor scores) or matrix with correlations.</p>
</td></tr>
<tr><td><code id="FACTOR_SCORES_+3A_f">f</code></td>
<td>
<p>object of class <code><a href="#topic+EFA">EFA</a></code> or matrix.</p>
</td></tr>
<tr><td><code id="FACTOR_SCORES_+3A_phi">Phi</code></td>
<td>
<p>matrix. A matrix of factor intercorrelations. Only needs to be
specified if a factor loadings matrix is entered directly into <code>f</code>.
Default is <code>NULL</code>, in which case all intercorrelations are assumed to be zero.</p>
</td></tr>
<tr><td><code id="FACTOR_SCORES_+3A_method">method</code></td>
<td>
<p>character. The method used to calculate factor scores. One of
&quot;Thurstone&quot; (regression-based; default), &quot;tenBerge&quot;, &quot;Anderson&quot;, &quot;Bartlett&quot;,
&quot;Harman&quot;, or &quot;components&quot;.
See <code><a href="psych.html#topic+factor.scores">psych::factor.scores</a></code> for details.</p>
</td></tr>
<tr><td><code id="FACTOR_SCORES_+3A_impute">impute</code></td>
<td>
<p>character. Whether and how missing values in <code>x</code> should
be imputed. One of &quot;none&quot; (default, only complete cases are scored), &quot;median&quot;,
or &quot;mean&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class FACTOR_SCORES containing the following:
</p>
<table>
<tr><td><code>scores</code></td>
<td>
<p>The factor scores (only if raw data are provided.)</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>The factor weights.</p>
</td></tr>
<tr><td><code>r.scores</code></td>
<td>
<p>The correlations of the factor score estimates.</p>
</td></tr>
<tr><td><code>missing</code></td>
<td>
<p>A vector of the number of missing observations per subject
(only if raw data are provided.</p>
</td></tr>
<tr><td><code>R2</code></td>
<td>
<p>Multiple R2 of the scores with the factors.</p>
</td></tr>
<tr><td><code>settings</code></td>
<td>
<p>A list of the settings used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Example with raw data with method "Bartlett" and no imputation
EFA_raw &lt;- EFA(DOSPERT_raw, n_factors = 10, type = "EFAtools", method = "PAF",
               rotation = "oblimin")
fac_scores_raw &lt;- FACTOR_SCORES(DOSPERT_raw, f = EFA_raw, method = "Bartlett",
                                impute = "none")

# Example with a correlation matrix (does not return factor scores)
EFA_cor &lt;- EFA(test_models$baseline$cormat, n_factors = 3, N = 500,
               type = "EFAtools", method = "PAF", rotation = "oblimin")
fac_scores_cor &lt;- FACTOR_SCORES(test_models$baseline$cormat, f = EFA_cor)

</code></pre>

<hr>
<h2 id='GRiPS_raw'>GRiPS_raw</h2><span id='topic+GRiPS_raw'></span>

<h3>Description</h3>

<p>A data.frame containing responses to the General Risk Propensity Scale (GRiPS, Zhang,
Highhouse &amp; Nye, 2018) of 810 participants of Study 1 of Steiner and Frey (2020).
The original data can be accessed via <a href="https://osf.io/kxp8t/">https://osf.io/kxp8t/</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GRiPS_raw
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 810 rows and 8 columns.
</p>


<h3>Source</h3>

<p>Zhang, D. C., Highhouse, S., &amp; Nye, C. D. (2018). Development and validation of the general risk propensity scale (GRiPS).Journal of Behavioral Decision Making, 32, 152–167. doi: 10.1002/bdm.2102
</p>
<p>Steiner, M., &amp; Frey, R. (2020). Representative design in psychological assessment: A case study using the Balloon Analogue Risk Task (BART). PsyArXiv Preprint. doi:10.31234/osf.io/dg4ks
</p>

<hr>
<h2 id='HULL'>Hull method for determining the number of factors to retain</h2><span id='topic+HULL'></span>

<h3>Description</h3>

<p>Implementation of the Hull method suggested by Lorenzo-Seva, Timmerman,
and Kiers (2011), with an extension to principal axis factoring. See details for
parallelization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HULL(
  x,
  N = NA,
  n_fac_theor = NA,
  method = c("PAF", "ULS", "ML"),
  gof = c("CAF", "CFI", "RMSEA"),
  eigen_type = c("SMC", "PCA", "EFA"),
  use = c("pairwise.complete.obs", "all.obs", "complete.obs", "everything",
    "na.or.complete"),
  cor_method = c("pearson", "spearman", "kendall"),
  n_datasets = 1000,
  percent = 95,
  decision_rule = c("means", "percentile", "crawford"),
  n_factors = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HULL_+3A_x">x</code></td>
<td>
<p>matrix or data.frame. Dataframe or matrix of raw data or matrix with
correlations.</p>
</td></tr>
<tr><td><code id="HULL_+3A_n">N</code></td>
<td>
<p>numeric. Number of cases in the data. This is passed to <a href="#topic+PARALLEL">PARALLEL</a>.
Only has to be specified if x is a correlation matrix, otherwise it is determined
based on the dimensions of x.</p>
</td></tr>
<tr><td><code id="HULL_+3A_n_fac_theor">n_fac_theor</code></td>
<td>
<p>numeric. Theoretical number of factors to retain. The maximum
of this number and the number of factors suggested by <a href="#topic+PARALLEL">PARALLEL</a> plus
one will be used in the Hull method.</p>
</td></tr>
<tr><td><code id="HULL_+3A_method">method</code></td>
<td>
<p>character. The estimation method to use. One of  <code>"PAF"</code>,
<code>"ULS"</code>, or  <code>"ML"</code>, for principal axis factoring, unweighted
least squares, and maximum likelihood, respectively.</p>
</td></tr>
<tr><td><code id="HULL_+3A_gof">gof</code></td>
<td>
<p>character. The goodness of fit index to use. Either <code>"CAF"</code>,
<code>"CFI"</code>, or <code>"RMSEA"</code>, or any combination of them.
If <code>method = "PAF"</code> is used, only
the CAF can be used as goodness of fit index. For details on the CAF, see
Lorenzo-Seva, Timmerman, and Kiers (2011).</p>
</td></tr>
<tr><td><code id="HULL_+3A_eigen_type">eigen_type</code></td>
<td>
<p>character. On what the eigenvalues should be found in the
parallel analysis. Can be one of <code>"SMC"</code>, <code>"PCA"</code>, or <code>"EFA"</code>.
If using  <code>"SMC"</code> (default), the diagonal of the correlation matrices is
replaced by the squared multiple correlations (SMCs) of the indicators. If
using  <code>"PCA"</code>, the diagonal values of the correlation
matrices are left to be 1. If using  <code>"EFA"</code>, eigenvalues are found on the
correlation  matrices with the final communalities of an EFA solution as
diagonal. This is passed to  <code><a href="#topic+PARALLEL">PARALLEL</a></code>.</p>
</td></tr>
<tr><td><code id="HULL_+3A_use">use</code></td>
<td>
<p>character. Passed to <code><a href="stats.html#topic+cor">stats::cor</a></code> if raw data
is given as input. Default is <code>"pairwise.complete.obs"</code>.</p>
</td></tr>
<tr><td><code id="HULL_+3A_cor_method">cor_method</code></td>
<td>
<p>character. Passed to <code><a href="stats.html#topic+cor">stats::cor</a></code>.
Default is  <code>"pearson"</code>.</p>
</td></tr>
<tr><td><code id="HULL_+3A_n_datasets">n_datasets</code></td>
<td>
<p>numeric. The number of datasets to simulate. Default is 1000.
This is passed to <code><a href="#topic+PARALLEL">PARALLEL</a></code>.</p>
</td></tr>
<tr><td><code id="HULL_+3A_percent">percent</code></td>
<td>
<p>numeric. A vector of percentiles to take the simulated eigenvalues from.
Default is 95. This is passed to <code><a href="#topic+PARALLEL">PARALLEL</a></code>.</p>
</td></tr>
<tr><td><code id="HULL_+3A_decision_rule">decision_rule</code></td>
<td>
<p>character. Which rule to use to determine the number of
factors to retain. Default is <code>"means"</code>, which will use the average
simulated eigenvalues. <code>"percentile"</code>, uses the percentiles specified
in percent. <code>"crawford"</code> uses the 95th percentile for the first factor
and the mean afterwards (based on Crawford et al, 2010). This is passed to <code><a href="#topic+PARALLEL">PARALLEL</a></code>.</p>
</td></tr>
<tr><td><code id="HULL_+3A_n_factors">n_factors</code></td>
<td>
<p>numeric. Number of factors to extract if  <code>"EFA"</code> is
included in <code>eigen_type</code>. Default is 1. This is passed to
<code><a href="#topic+PARALLEL">PARALLEL</a></code>.</p>
</td></tr>
<tr><td><code id="HULL_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+EFA">EFA</a></code>, also in
<code><a href="#topic+PARALLEL">PARALLEL</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Hull method aims to find a model with an optimal balance between
model fit and number of parameters. That is, it aims to retrieve only major
factors (Lorenzo-Seva, Timmerman, &amp; Kiers, 2011). To this end, it performs
the following steps (Lorenzo-Seva, Timmerman, &amp; Kiers, 2011, p.351):
</p>

<ol>
<li><p> It performs parallel analysis and adds one to the identified number of factors (this number is denoted <em>J</em>). <em>J</em> is taken as an upper bound of the number of factors to retain in the hull method. Alternatively, a theoretical number of factors can be entered. In this case <em>J</em> will be set to whichever of these two numbers (from parallel analysis or based on theory) is higher.
</p>
</li>
<li><p> For all 0 to <em>J</em> factors, the goodness-of-fit (one of <em>CAF</em>, <em>RMSEA</em>, or <em>CFI</em>) and the degrees of freedom (<em>df</em>) are computed.
</p>
</li>
<li><p> The solutions are ordered according to their <em>df</em>.
</p>
</li>
<li><p> Solutions that are not on the boundary of the convex hull are eliminated (see Lorenzo-Seva, Timmerman, &amp; Kiers, 2011, for details).
</p>
</li>
<li><p> All the triplets of adjacent solutions are considered consecutively. The middle solution is excluded if its point is below or on the line connecting its neighbors in a plot of the goodness-of-fit versus the degrees of freedom.
</p>
</li>
<li><p> Step 5 is repeated until no solution can be excluded.
</p>
</li>
<li><p> The <em>st</em> values of the “hull” solutions are determined.
</p>
</li>
<li><p> The solution with the highest <em>st</em> value is selected.
</p>
</li></ol>

<p>The <a href="#topic+PARALLEL">PARALLEL</a> function and the principal axis factoring of the
different number of factors can be parallelized using the future framework,
by calling the <a href="future.html#topic+plan">future::plan</a> function. The examples
provide example code on how to enable parallel processing.
</p>
<p>Note that if <code>gof = "RMSEA"</code> is used, 1 - RMSEA is actually used to
compare the different solutions. Thus, the threshold of .05 is then .95. This
is necessary due to how the heuristic to locate the elbow of the hull works.
</p>
<p>The ML estimation method uses the <a href="stats.html#topic+factanal">stats::factanal</a>
starting values. See also the <a href="#topic+EFA">EFA</a> documentation.
</p>
<p>The <code>HULL</code> function can also be called together with other factor
retention criteria in the <code><a href="#topic+N_FACTORS">N_FACTORS</a></code> function.
</p>


<h3>Value</h3>

<p>A list of class HULL containing the following objects
</p>
<table>
<tr><td><code>n_fac_CAF</code></td>
<td>
<p>The number of factors to retain according to the Hull method
with the CAF.</p>
</td></tr>
<tr><td><code>n_fac_CFI</code></td>
<td>
<p>The number of factors to retain according to the Hull method
with the CFI.</p>
</td></tr>
<tr><td><code>n_fac_RMSEA</code></td>
<td>
<p>The number of factors to retain according to the Hull method
with the RMSEA.</p>
</td></tr>
<tr><td><code>solutions_CAF</code></td>
<td>
<p>A matrix containing the CAFs, degrees of freedom, and for the factors lying on the hull, the st values of the hull solution (see Lorenzo-Seva, Timmerman, and Kiers 2011 for details).</p>
</td></tr>
<tr><td><code>solutions_CFI</code></td>
<td>
<p>A matrix containing the CFIs, degrees of freedom, and for the factors lying on the hull, the st values of the hull solution (see Lorenzo-Seva, Timmerman, and Kiers 2011 for details).</p>
</td></tr>
<tr><td><code>solutions_RMSEA</code></td>
<td>
<p>A matrix containing the RMSEAs, degrees of freedom, and for the factors lying on the hull, the st values of the hull solution (see Lorenzo-Seva, Timmerman, and Kiers 2011 for details).</p>
</td></tr>
<tr><td><code>n_fac_max</code></td>
<td>
<p>The upper bound <em>J</em> of the number of factors to extract (see details).</p>
</td></tr>
<tr><td><code>settings</code></td>
<td>
<p>A list of the settings used.</p>
</td></tr>
</table>


<h3>Source</h3>

<p>Lorenzo-Seva, U., Timmerman, M. E., &amp; Kiers, H. A. (2011).
The Hull method for selecting the number of common factors. Multivariate
Behavioral Research, 46(2), 340-364.
</p>


<h3>See Also</h3>

<p>Other factor retention criteria: <code><a href="#topic+CD">CD</a></code>, <code><a href="#topic+EKC">EKC</a></code>,
<code><a href="#topic+KGC">KGC</a></code>, <code><a href="#topic+PARALLEL">PARALLEL</a></code>, <code><a href="#topic+SMT">SMT</a></code>
</p>
<p><code><a href="#topic+N_FACTORS">N_FACTORS</a></code> as a wrapper function for this and all the
above-mentioned factor retention criteria.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# using PAF (this will throw a warning if gof is not specified manually
# and CAF will be used automatically)
HULL(test_models$baseline$cormat, N = 500, gof = "CAF")

# using ML with all available fit indices (CAF, CFI, and RMSEA)
HULL(test_models$baseline$cormat, N = 500, method = "ML")

# using ULS with only RMSEA
HULL(test_models$baseline$cormat, N = 500, method = "ULS", gof = "RMSEA")


## Not run: 
# using parallel processing (Note: plans can be adapted, see the future
# package for details)
future::plan(future::multisession)
HULL(test_models$baseline$cormat, N = 500, gof = "CAF")

## End(Not run)
</code></pre>

<hr>
<h2 id='IDS2_R'>Intelligence subtests from the Intelligence and Development Scales&ndash;2</h2><span id='topic+IDS2_R'></span>

<h3>Description</h3>

<p>A matrix containing the bivariate correlations of the 14 intelligence subtests from the Intelligence and Development Scales&ndash;2 (IDS-2; Grob &amp; Hagmann-von Arx, 2018), an intelligence and development test battery for children and adolescents aged 5 to 20 years, for the standardization and validation sample (N = 1,991). Details can be found in Grieder &amp; Grob (2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IDS2_R
</code></pre>


<h3>Format</h3>

<p>A 14 x 14 matrix of bivariate correlations
</p>

<dl>
<dt>GS</dt><dd><p>(numeric) - Geometric shapes.</p>
</dd>
<dt>PL</dt><dd><p>(numeric) - Plates.</p>
</dd>
<dt>TC</dt><dd><p>(numeric) - Two characteristics.</p>
</dd>
<dt>CB</dt><dd><p>(numeric) - Crossing out boxes.</p>
</dd>
<dt>NL</dt><dd><p>(numeric) - Numbers / letters.</p>
</dd>
<dt>NLM</dt><dd><p>(numeric) - Numbers / letter mixed.</p>
</dd>
<dt>GF</dt><dd><p>(numeric) - Geometric figures.</p>
</dd>
<dt>RGF</dt><dd><p>(numeric) - Rotated geometric figures.</p>
</dd>
<dt>CM</dt><dd><p>(numeric) - Completing matrices.</p>
</dd>
<dt>EP</dt><dd><p>(numeric) - Excluding pictures.</p>
</dd>
<dt>CA</dt><dd><p>(numeric) - Categories.</p>
</dd>
<dt>OP</dt><dd><p>(numeric) - Opposites.</p>
</dd>
<dt>RS</dt><dd><p>(numeric) - Retelling a story.</p>
</dd>
<dt>DP</dt><dd><p>(numeric) - Describing pictures.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Grieder, S., &amp; Grob, A. (2019). Exploratory factor analyses of the intelligence and development scales&ndash;2: Implications for theory and practice. Assessment. Advance online publication. doi:10.1177/10731911198450
</p>
<p>Grob, A., &amp; Hagmann-von Arx, P. (2018). Intelligence and Development Scales&ndash;2 (IDS-2). Intelligenz- und Entwicklungsskalen für Kinder und Jugendliche.
[Intelligence and Development Scales for Children and Adolescents.]. Bern, Switzerland: Hogrefe.
</p>

<hr>
<h2 id='KGC'>Kaiser-Guttman Criterion</h2><span id='topic+KGC'></span>

<h3>Description</h3>

<p>Probably the most popular factor retention criterion. Kaiser and Guttman suggested
to retain as many factors as there are sample eigenvalues greater than 1.
This is why the criterion is also known as eigenvalues-greater-than-one rule.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KGC(
  x,
  eigen_type = c("PCA", "SMC", "EFA"),
  use = c("pairwise.complete.obs", "all.obs", "complete.obs", "everything",
    "na.or.complete"),
  cor_method = c("pearson", "spearman", "kendall"),
  n_factors = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KGC_+3A_x">x</code></td>
<td>
<p>data.frame or matrix. Dataframe or matrix of raw data or matrix with
correlations.</p>
</td></tr>
<tr><td><code id="KGC_+3A_eigen_type">eigen_type</code></td>
<td>
<p>character. On what the eigenvalues should be found. Can be
either &quot;PCA&quot;, &quot;SMC&quot;, or &quot;EFA&quot;, or some combination of them. If using &quot;PCA&quot;,
the diagonal values of the correlation matrices are left to be 1. If using
&quot;SMC&quot;, the diagonal of the
correlation matrices is replaced by the squared multiple correlations (SMCs)
of the indicators. If using &quot;EFA&quot;, eigenvalues are found on the correlation
matrices with the final communalities of an exploratory factor analysis
solution (default is principal axis factoring extracting 1 factor) as
diagonal.</p>
</td></tr>
<tr><td><code id="KGC_+3A_use">use</code></td>
<td>
<p>character. Passed to <code><a href="stats.html#topic+cor">stats::cor</a></code> if raw
data is given as input. Default is &quot;pairwise.complete.obs&quot;.</p>
</td></tr>
<tr><td><code id="KGC_+3A_cor_method">cor_method</code></td>
<td>
<p>character. Passed to <code><a href="stats.html#topic+cor">stats::cor</a></code>.
Default is &quot;pearson&quot;.</p>
</td></tr>
<tr><td><code id="KGC_+3A_n_factors">n_factors</code></td>
<td>
<p>numeric. Number of factors to extract if &quot;EFA&quot; is included in
<code>eigen_type</code>. Default is 1.</p>
</td></tr>
<tr><td><code id="KGC_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+EFA">EFA</a></code>. For example,
to change the extraction method (PAF is default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Originally, the Kaiser-Guttman criterion was intended for the use
with prinicpal components, hence with eigenvalues derived from the original
correlation matrix. This can be done here by setting <code>eigen_type</code> to
&quot;PCA&quot;. However, it is well-known that this criterion is often inaccurate and
that it tends to overestimate the number of factors, especially for unidimensional
or orthogonal factor structures (e.g., Zwick &amp; Velicer, 1986).
</p>
<p>The criterion's inaccuracy in these cases is somewhat addressed if it is
applied on the correlation matrix with communalities in the diagonal, either
initial communalities estimated from SMCs (done setting <code>eigen_type</code> to
&quot;SMC&quot;) or final communality estimates from an EFA (done setting <code>eigen_type</code>
to &quot;EFA&quot;; see Auerswald &amp; Moshagen, 2019). However, although this variant
of the KGC is more accurate in some cases compared to the traditional KGC, it
is at the same time less accurate than the PCA-variant in other cases, and it
is still often less accurate than other factor retention methods, for
example parallel analysis (<code><a href="#topic+PARALLEL">PARALLEL</a></code>), the Hull method
<code><a href="#topic+HULL">HULL</a></code>, or sequential <code class="reqn">chi^2</code> model tests (<code><a href="#topic+SMT">SMT</a></code>;
see Auerswald &amp; Moshagen, 2019).
</p>
<p>The <code>KGC</code> function can also be called together with other factor
retention criteria in the <code><a href="#topic+N_FACTORS">N_FACTORS</a></code> function.
</p>


<h3>Value</h3>

<p>A list of class KGC containing
</p>
<table>
<tr><td><code>eigen_PCA</code></td>
<td>
<p> A vector containing the eigenvalues found with PCA.</p>
</td></tr>
<tr><td><code>eigen_SMC</code></td>
<td>
<p> A vector containing the eigenvalues found with SMCs.</p>
</td></tr>
<tr><td><code>eigen_EFA</code></td>
<td>
<p> A vector containing the eigenvalues found with EFA.</p>
</td></tr>
<tr><td><code>n_fac_PCA</code></td>
<td>
<p> The number of factors to retain according to the Kaiser-
Guttmann criterion with PCA eigenvalues type.</p>
</td></tr>
<tr><td><code>n_fac_SMC</code></td>
<td>
<p> The number of factors to retain according to the Kaiser-
Guttmann criterion with SMC eigenvalues type.</p>
</td></tr>
<tr><td><code>n_fac_EFA</code></td>
<td>
<p> The number of factors to retain according to the Kaiser-
Guttmann criterion with EFA eigenvalues type.</p>
</td></tr>
<tr><td><code>settings</code></td>
<td>
<p>A list of the settings used.</p>
</td></tr>
</table>


<h3>Source</h3>

<p>Auerswald, M., &amp; Moshagen, M. (2019). How to determine the number of
factors to retain in exploratory factor analysis: A comparison of extraction
methods under realistic conditions. Psychological Methods, 24(4), 468–491.
https://doi.org/10.1037/met0000200
</p>
<p>Guttman, L. (1954). Some necessary conditions for common-factor analysis.
Psychometrika, 19, 149 –161. http://dx.doi.org/10.1007/BF02289162
</p>
<p>Kaiser, H. F. (1960). The application of electronic computers to factor
analysis. Educational and Psychological Measurement, 20, 141–151.
http://dx.doi.org/10.1177/001316446002000116
</p>
<p>Zwick, W. R., &amp; Velicer, W. F. (1986). Comparison of five rules for
determining the number of components to retain. Psychological Bulletin, 99,
432–442. http://dx.doi.org/10.1037/0033-2909.99.3.432
</p>


<h3>See Also</h3>

<p>Other factor retention criteria: <code><a href="#topic+CD">CD</a></code>, <code><a href="#topic+EKC">EKC</a></code>,
<code><a href="#topic+HULL">HULL</a></code>, <code><a href="#topic+PARALLEL">PARALLEL</a></code>, <code><a href="#topic+SMT">SMT</a></code>
</p>
<p><code><a href="#topic+N_FACTORS">N_FACTORS</a></code> as a wrapper function for this and all the
above-mentioned factor retention criteria.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>KGC(test_models$baseline$cormat, eigen_type = c("PCA", "SMC"))
</code></pre>

<hr>
<h2 id='KMO'>Kaiser-Meyer-Olkin criterion</h2><span id='topic+KMO'></span>

<h3>Description</h3>

<p>This function computes the Kaiser-Meyer-Olkin (KMO) criterion overall and for
each variable in a correlation matrix. The KMO represents the degree to
which each observed variable is predicted by the other variables in the
dataset and with this indicates the suitability for factor analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KMO(
  x,
  use = c("pairwise.complete.obs", "all.obs", "complete.obs", "everything",
    "na.or.complete"),
  cor_method = c("pearson", "spearman", "kendall")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KMO_+3A_x">x</code></td>
<td>
<p>data.frame or matrix. Dataframe or matrix of raw data or matrix with
correlations.</p>
</td></tr>
<tr><td><code id="KMO_+3A_use">use</code></td>
<td>
<p>character. Passed to <code><a href="stats.html#topic+cor">stats::cor</a></code> if raw
data is given as input. Default is &quot;pairwise.complete.obs&quot;.</p>
</td></tr>
<tr><td><code id="KMO_+3A_cor_method">cor_method</code></td>
<td>
<p>character. Passed to <code><a href="stats.html#topic+cor">stats::cor</a></code>.
Default is &quot;pearson&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Kaiser (1970) proposed this index, originally called measure of
sampling adequacy (MSA), that indicates how near the inverted correlation
matrix <code class="reqn">R^{-1}</code> is to a diagonal matrix <code class="reqn">S</code> to determine a given
correlation matrix's (<code class="reqn">R</code>) suitability for factor analysis.
The index is
</p>
<p style="text-align: center;"><code class="reqn">KMO = \frac{\sum\limits_{i&lt;j}\sum r_{ij}^2}{\sum\limits_{i&lt;j}\sum r_{ij}^2 + \sum\limits_{i&lt;j}\sum q_{ij}^2}</code>
</p>

<p>with <code class="reqn">Q = SR^{-1}S</code> and S = <code class="reqn">(diag R^{-1})^{-1/2}</code> where
<code class="reqn">\sum\limits_{i&lt;j}\sum r_{ij}^2</code> is the sum of squares of the upper
off-diagonal elements of <code class="reqn">R</code> and <code class="reqn">\sum\limits_{i&lt;j}\sum q_{ij}^2</code> is the
sum of squares of the upper off-diagonal elements of <code class="reqn">Q</code> (see also Cureton &amp; D'Augustino, 1983).
</p>
<p>So KMO varies between 0 and 1, with larger values indicating higher suitability
for factor analysis. Kaiser and Rice (1974) suggest that KMO should at least
exceed .50 for a correlation matrix to be suitable for factor analysis.
</p>
<p>This function was heavily influenced by the <code><a href="psych.html#topic+KMO">psych::KMO</a></code>
function.
</p>
<p>See also <code><a href="#topic+BARTLETT">BARTLETT</a></code> for another test of suitability for factor
analysis.
</p>
<p>The <code>KMO</code> function can also be called together with the
<code><a href="#topic+BARTLETT">BARTLETT</a></code> function and with factor retention criteria in the
<code><a href="#topic+N_FACTORS">N_FACTORS</a></code> function.
</p>


<h3>Value</h3>

<p>A list containing
</p>
<table>
<tr><td><code>KMO</code></td>
<td>
<p>Overall KMO.</p>
</td></tr>
<tr><td><code>KMO_i</code></td>
<td>
<p>KMO for each variable.</p>
</td></tr>
<tr><td><code>settings</code></td>
<td>
<p>A list of the settings used.</p>
</td></tr>
</table>


<h3>Source</h3>

<p>Kaiser, H. F. (1970). A second generation little jiffy. Psychometrika,
35, 401-415.
</p>
<p>Kaiser, H. F. &amp; Rice, J. (1974). Little jiffy, mark IV. Educational
and Psychological Measurement, 34, 111-117.
</p>
<p>Cureton, E. E. &amp; D'Augustino, R. B. (1983). Factor analysis: An
applied approach. Hillsdale, N.J.: Lawrence Erlbaum Associates, Inc.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BARTLETT">BARTLETT</a></code> for another measure to determine
suitability for factor analysis.
</p>
<p><code><a href="#topic+N_FACTORS">N_FACTORS</a></code> as a wrapper function for this function,
<code><a href="#topic+BARTLETT">BARTLETT</a></code> and several factor retention criteria.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>KMO(test_models$baseline$cormat)
</code></pre>

<hr>
<h2 id='N_FACTORS'>Various Factor Retention Criteria</h2><span id='topic+N_FACTORS'></span>

<h3>Description</h3>

<p>Among the most important decisions for an exploratory factor analysis (EFA) is
the choice of the number of factors to retain. Several factor retention
criteria have been developed for this. With this function, various factor
retention criteria can be performed simultaneously. Additionally, the data
can be checked for their suitability for factor analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>N_FACTORS(
  x,
  criteria = c("CD", "EKC", "HULL", "KGC", "PARALLEL", "SCREE", "SMT"),
  suitability = TRUE,
  N = NA,
  use = c("pairwise.complete.obs", "all.obs", "complete.obs", "everything",
    "na.or.complete"),
  cor_method = c("pearson", "spearman", "kendall"),
  n_factors_max = NA,
  N_pop = 10000,
  N_samples = 500,
  alpha = 0.3,
  max_iter_CD = 50,
  n_fac_theor = NA,
  method = c("PAF", "ULS", "ML"),
  gof = c("CAF", "CFI", "RMSEA"),
  eigen_type_HULL = c("SMC", "PCA", "EFA"),
  eigen_type_other = c("PCA", "SMC", "EFA"),
  n_factors = 1,
  n_datasets = 1000,
  percent = 95,
  decision_rule = c("means", "percentile", "crawford"),
  show_progress = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="N_FACTORS_+3A_x">x</code></td>
<td>
<p>data.frame or matrix. Dataframe or matrix of raw data or matrix with
correlations. If <code>"CD"</code> is included as a criterion, x must be raw
data.</p>
</td></tr>
<tr><td><code id="N_FACTORS_+3A_criteria">criteria</code></td>
<td>
<p>character. A vector with the factor retention methods to
perform. Possible inputs are: <code>"CD"</code>, <code>"EKC"</code>, <code>"HULL"</code>,
<code>"KGC"</code>, <code>"PARALLEL"</code>, <code>"SCREE"</code>, and <code>"SMT"</code>
(see details). By default, all factor retention methods are performed.</p>
</td></tr>
<tr><td><code id="N_FACTORS_+3A_suitability">suitability</code></td>
<td>
<p>logical. Whether the data should be checked for suitability
for factor analysis using the Bartlett's test of sphericity and the
Kaiser-Guttmann criterion (see details). Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="N_FACTORS_+3A_n">N</code></td>
<td>
<p>numeric. The number of observations. Only needed if x is a
correlation matrix.</p>
</td></tr>
<tr><td><code id="N_FACTORS_+3A_use">use</code></td>
<td>
<p>character. Passed to <code><a href="stats.html#topic+cor">stats::cor</a></code> if raw
data is given as input. Default is <code>"pairwise.complete.obs"</code>.</p>
</td></tr>
<tr><td><code id="N_FACTORS_+3A_cor_method">cor_method</code></td>
<td>
<p>character. Passed to <code><a href="stats.html#topic+cor">stats::cor</a></code>
Default is  <code>"pearson"</code>.</p>
</td></tr>
<tr><td><code id="N_FACTORS_+3A_n_factors_max">n_factors_max</code></td>
<td>
<p>numeric. Passed to <code><a href="#topic+CD">CD</a></code>.The maximum number
of factors to test against.
Larger numbers will increase the duration the procedure takes, but test more
possible solutions. Maximum possible is number of variables / 2. Default is
NA. If not specified, number of variables / 2 is used.</p>
</td></tr>
<tr><td><code id="N_FACTORS_+3A_n_pop">N_pop</code></td>
<td>
<p>numeric. Passed to <code><a href="#topic+CD">CD</a></code>. Size of finite populations
of comparison data. Default is 10000.</p>
</td></tr>
<tr><td><code id="N_FACTORS_+3A_n_samples">N_samples</code></td>
<td>
<p>numeric. Passed to <code><a href="#topic+CD">CD</a></code>. Number of samples drawn
from each population. Default is 500.</p>
</td></tr>
<tr><td><code id="N_FACTORS_+3A_alpha">alpha</code></td>
<td>
<p>numeric. Passed to <code><a href="#topic+CD">CD</a></code>. The alpha level used to test
the significance of the improvement added by an additional factor.
Default is .30.</p>
</td></tr>
<tr><td><code id="N_FACTORS_+3A_max_iter_cd">max_iter_CD</code></td>
<td>
<p>numeric. Passed to <code><a href="#topic+CD">CD</a></code>. The maximum number of
iterations to perform after which the iterative PAF procedure is halted.
Default is 50.</p>
</td></tr>
<tr><td><code id="N_FACTORS_+3A_n_fac_theor">n_fac_theor</code></td>
<td>
<p>numeric. Passed to <code><a href="#topic+HULL">HULL</a></code>. Theoretical number
of factors to retain. The maximum of this number and the number of factors
suggested by <a href="#topic+PARALLEL">PARALLEL</a> plus one will be used in the Hull method.</p>
</td></tr>
<tr><td><code id="N_FACTORS_+3A_method">method</code></td>
<td>
<p>character. Passed to <code><a href="#topic+EFA">EFA</a></code> in <code><a href="#topic+HULL">HULL</a></code>,
<code><a href="#topic+KGC">KGC</a></code>, <code><a href="#topic+SCREE">SCREE</a></code>, and <code><a href="#topic+PARALLEL">PARALLEL</a></code>. The
estimation method to use. One of  <code>"PAF"</code>, <code>"ULS"</code>, or  <code>"ML"</code>,
for principal axis factoring, unweighted least squares, and maximum
likelihood, respectively.</p>
</td></tr>
<tr><td><code id="N_FACTORS_+3A_gof">gof</code></td>
<td>
<p>character. Passed to <code><a href="#topic+HULL">HULL</a></code>. The goodness of fit index
to use. Either <code>"CAF"</code>, <code>"CFI"</code>, or <code>"RMSEA"</code>, or any
combination of them. If <code>method = "PAF"</code> is used, only
the CAF can be used as goodness of fit index. For details on the CAF, see
Lorenzo-Seva, Timmerman, and Kiers (2011).</p>
</td></tr>
<tr><td><code id="N_FACTORS_+3A_eigen_type_hull">eigen_type_HULL</code></td>
<td>
<p>character. Passed to  <code><a href="#topic+PARALLEL">PARALLEL</a></code> in
<code><a href="#topic+HULL">HULL</a></code>. On what the
eigenvalues should be found in the parallel analysis. Can be one of
<code>"SMC"</code>, <code>"PCA"</code>, or <code>"EFA"</code>. If using  <code>"SMC"</code> (default),
the diagonal of the correlation matrices is
replaced by the squared multiple correlations (SMCs) of the indicators. If
using  <code>"PCA"</code>, the diagonal values of the correlation
matrices are left to be 1. If using  <code>"EFA"</code>, eigenvalues are found on the
correlation  matrices with the final communalities of an EFA solution as
diagonal.</p>
</td></tr>
<tr><td><code id="N_FACTORS_+3A_eigen_type_other">eigen_type_other</code></td>
<td>
<p>character. Passed to <code><a href="#topic+KGC">KGC</a></code>,
<code><a href="#topic+SCREE">SCREE</a></code>, and <code><a href="#topic+PARALLEL">PARALLEL</a></code>. The same as eigen_type_HULL,
but multiple inputs
are possible here. Default is to use all inputs, that is, <code>c("PCA",
"SMC", "EFA"</code>)</p>
</td></tr>
<tr><td><code id="N_FACTORS_+3A_n_factors">n_factors</code></td>
<td>
<p>numeric. Passed to <code><a href="#topic+PARALLEL">PARALLEL</a></code> (also within
<code><a href="#topic+HULL">HULL</a></code>), <code><a href="#topic+KGC">KGC</a></code>, and <code><a href="#topic+SCREE">SCREE</a></code>. Number of
factors to extract if <code>"EFA"</code> is included in <code>eigen_type_HULL</code> or
<code>eigen_type_other</code>. Default is 1.</p>
</td></tr>
<tr><td><code id="N_FACTORS_+3A_n_datasets">n_datasets</code></td>
<td>
<p>numeric. Passed to <code><a href="#topic+PARALLEL">PARALLEL</a></code> (also within
<code><a href="#topic+HULL">HULL</a></code>). The number of datasets to simulate. Default is 1000.</p>
</td></tr>
<tr><td><code id="N_FACTORS_+3A_percent">percent</code></td>
<td>
<p>numeric. Passed to <code><a href="#topic+PARALLEL">PARALLEL</a></code> (also within
<code><a href="#topic+HULL">HULL</a></code>). A vector of percentiles to take the simulated eigenvalues
from. Default is 95.</p>
</td></tr>
<tr><td><code id="N_FACTORS_+3A_decision_rule">decision_rule</code></td>
<td>
<p>character. Passed to <code><a href="#topic+PARALLEL">PARALLEL</a></code> (also within
<code><a href="#topic+HULL">HULL</a></code>). Which rule to use to determine the number of
factors to retain. Default is <code>"means"</code>, which will use the average
simulated eigenvalues. <code>"percentile"</code>, uses the percentiles specified
in percent. <code>"crawford"</code> uses the 95th percentile for the first factor
and the mean afterwards (based on Crawford et al, 2010).</p>
</td></tr>
<tr><td><code id="N_FACTORS_+3A_show_progress">show_progress</code></td>
<td>
<p>logical. Whether a progress bar should be shown in the
console. Default is TRUE.</p>
</td></tr>
<tr><td><code id="N_FACTORS_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+EFA">EFA</a></code> in
<code><a href="#topic+PARALLEL">PARALLEL</a></code> (also within <code><a href="#topic+HULL">HULL</a></code>) and <code><a href="#topic+KGC">KGC</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, the entered data are checked for suitability for factor analysis
using the following methods (see respective documentations for details):
</p>

<ul>
<li><p>Bartlett's test of sphericity (see <code><a href="#topic+BARTLETT">BARTLETT</a></code>)
</p>
</li>
<li><p>Kaiser-Meyer-Olkin criterion (see <code><a href="#topic+KMO">KMO</a></code>)</p>
</li></ul>

<p>The available factor retention criteria are the following (see respective
documentations for details):
</p>

<ul>
<li><p>Comparison data (see <code><a href="#topic+CD">CD</a></code>)
</p>
</li>
<li><p>Empirical Kaiser criterion (see <code><a href="#topic+EKC">EKC</a></code>)
</p>
</li>
<li><p>Hull method (see <code><a href="#topic+HULL">HULL</a></code>)
</p>
</li>
<li><p>Kaiser-Guttman criterion (see <code><a href="#topic+KGC">KGC</a></code>)
</p>
</li>
<li><p>Parallel analysis (see <code><a href="#topic+PARALLEL">PARALLEL</a></code>)
</p>
</li>
<li><p>Scree plot (see <code><a href="#topic+SCREE">SCREE</a></code>)
</p>
</li>
<li><p>Sequential chi-square model tests, RMSEA lower bound, and AIC
(see <code><a href="#topic+SMT">SMT</a></code>)
</p>
</li></ul>



<h3>Value</h3>

<p>A list of class N_FACTORS containing
</p>
<table>
<tr><td><code>outputs</code></td>
<td>
<p>A list with the outputs from <code><a href="#topic+BARTLETT">BARTLETT</a></code> and
<code><a href="#topic+KMO">KMO</a></code> and the factor retention criteria.</p>
</td></tr>
<tr><td><code>n_factors</code></td>
<td>
<p>A named vector containing the suggested number of factors
from each factor retention criterion.</p>
</td></tr>
<tr><td><code>settings</code></td>
<td>
<p>A list of the settings used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# All criteria, with correlation matrix and fit method "ML" (where needed)
# This will throw a warning for CD, as no raw data were specified
nfac_all &lt;- N_FACTORS(test_models$baseline$cormat, N = 500, method = "ML")

# The same as above, but without "CD"
nfac_wo_CD &lt;- N_FACTORS(test_models$baseline$cormat, criteria = c("EKC",
                        "HULL", "KGC", "PARALLEL", "SCREE", "SMT"), N = 500,
                        method = "ML")

# Use PAF instead of ML (this will take a lot longer). For this, gof has
# to be set to "CAF" for the Hull method.
nfac_PAF &lt;- N_FACTORS(test_models$baseline$cormat, criteria = c("EKC",
                      "HULL", "KGC", "PARALLEL", "SCREE", "SMT"), N = 500,
                      gof = "CAF")

# Do KGC and PARALLEL with only "PCA" type of eigenvalues
nfac_PCA &lt;- N_FACTORS(test_models$baseline$cormat, criteria = c("EKC",
                      "HULL", "KGC", "PARALLEL", "SCREE", "SMT"), N = 500,
                      method = "ML", eigen_type_other = "PCA")

# Use raw data, such that CD can also be performed
nfac_raw &lt;- N_FACTORS(GRiPS_raw, method = "ML")

</code></pre>

<hr>
<h2 id='OMEGA'>McDonald's omega</h2><span id='topic+OMEGA'></span>

<h3>Description</h3>

<p>This function finds omega total, hierarchical, and subscale, as well as additional
model-based indices of interpretive relevance (H index, ECV, PUC)
from a Schmid-Leiman (SL) solution or lavaan single factor, second-order (see below),
or bifactor solution. The SL-based omegas can either be found from a
<code><a href="psych.html#topic+schmid">psych::schmid</a></code>, <code><a href="#topic+SL">SL</a></code>, or,
in a more flexible way, by leaving
<code>model = NULL</code> and specifying additional arguments. By setting the
<code>type</code> argument, results from <code><a href="psych.html#topic+omega">psych::omega</a></code>
can be reproduced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OMEGA(
  model = NULL,
  type = c("EFAtools", "psych"),
  g_name = "g",
  group_names = NULL,
  add_ind = TRUE,
  factor_corres = NULL,
  var_names = NULL,
  fac_names = NULL,
  g_load = NULL,
  s_load = NULL,
  u2 = NULL,
  cormat = NULL,
  pattern = NULL,
  Phi = NULL,
  variance = c("correlation", "sums_load")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OMEGA_+3A_model">model</code></td>
<td>
<p>class <code><a href="#topic+SL">SL</a></code>, class <code><a href="psych.html#topic+schmid">schmid</a></code>, or class
<code>lavaan</code> object. That is, an output object from <code><a href="#topic+SL">SL</a></code> or
<code><a href="psych.html#topic+schmid">psych::schmid</a></code>, or a <code>lavaan</code> fit object with a
single factor, second-order, or bifactor solution. If of class <code>lavaan</code>,
only <code>g_name</code> needs to be specified additionally. If of class
<code><a href="#topic+SL">SL</a></code> or <code><a href="psych.html#topic+schmid">schmid</a></code>, only the arguments <code>factor_corres</code>
and <code>cormat</code> need to be specified additionally.</p>
</td></tr>
<tr><td><code id="OMEGA_+3A_type">type</code></td>
<td>
<p>character. Either <code>"EFAtools"</code> (default) or <code>"psych"</code>
(see details)</p>
</td></tr>
<tr><td><code id="OMEGA_+3A_g_name">g_name</code></td>
<td>
<p>character. The name of the general factor from the lavaan solution.
This needs only be specified if <code>model</code> is a <code>lavaan</code> second-order
or bifactor solution. Default is &quot;g&quot;.</p>
</td></tr>
<tr><td><code id="OMEGA_+3A_group_names">group_names</code></td>
<td>
<p>character. An optional vector of group names. The length
must correspond to the number of groups for which the <code>lavaan</code> model
was fitted.</p>
</td></tr>
<tr><td><code id="OMEGA_+3A_add_ind">add_ind</code></td>
<td>
<p>logical. Whether additional indices (H index, ECV, PUC) should
be calculated or not (see details for these indices). If FALSE, only omegas
are returned. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="OMEGA_+3A_factor_corres">factor_corres</code></td>
<td>
<p>matrix. A logical matrix or a numeric matrix containing
0's and 1's that indicates which variable corresponds to which group factor.
Must have the same dimensions as the matrix of group factor loadings from the
SL solution. Cross-loadings are allowed here. See examples for use.</p>
</td></tr>
<tr><td><code id="OMEGA_+3A_var_names">var_names</code></td>
<td>
<p>character. A vector with subtest names in the order
of the rows from the SL solution. This needs only be specified if <code>model</code>
is left <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="OMEGA_+3A_fac_names">fac_names</code></td>
<td>
<p>character. An optional vector of group factor names in the
order of the columns of the SL solution. If left <code>NULL</code>, names of the
group factors from the entered solution are taken.</p>
</td></tr>
<tr><td><code id="OMEGA_+3A_g_load">g_load</code></td>
<td>
<p>numeric. A vector of general factor loadings from an SL solution.
This needs only be specified if <code>model</code> is left <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="OMEGA_+3A_s_load">s_load</code></td>
<td>
<p>matrix. A matrix of group factor loadings from an SL solution.
This needs only be specified if <code>model</code> is left <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="OMEGA_+3A_u2">u2</code></td>
<td>
<p>numeric. A vector of uniquenesses from an SL solution. This needs
only be specified if <code>model</code> is left <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="OMEGA_+3A_cormat">cormat</code></td>
<td>
<p>matrix. A correlation matrix to be used when
<code>variance = "correlation"</code>. If left <code>NULL</code> and an <code><a href="#topic+SL">SL</a></code>
output is entered in <code>model</code>, the correlation matrix is taken from the
output. If left <code>NULL</code> and a <code><a href="psych.html#topic+schmid">psych::schmid</a></code>
output is entered, the correlation matrix will be found based on the pattern
matrix and Phi from the <code><a href="psych.html#topic+schmid">psych::schmid</a></code> output
using <code><a href="psych.html#topic+factor.model">psych::factor.model</a></code>.
If left <code>NULL</code> and model is also left <code>NULL</code>, the correlation matrix
is found based on the pattern matrix and Phi entered. However, if the
correlation matrix is available, <code>cormat</code> should be specified instead
of <code>Phi</code> and <code>pattern</code>.</p>
</td></tr>
<tr><td><code id="OMEGA_+3A_pattern">pattern</code></td>
<td>
<p>matrix. Pattern coefficients from an oblique factor solution.
This needs only be specified if <code>model</code> is left <code>NULL</code>,
<code>variance = "correlation"</code> and <code>cormat</code> is also left <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="OMEGA_+3A_phi">Phi</code></td>
<td>
<p>matrix. Factor intercorrelations from an oblique factor solution.
This needs only be specified if <code>model</code> is left <code>NULL</code>,
<code>variance = "correlation"</code> and <code>cormat</code> is also left <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="OMEGA_+3A_variance">variance</code></td>
<td>
<p>character. If <code>"correlation"</code> (default), then total
variances for the whole scale as well as for the subscale composites are
calculated based on the correlation
matrix. If <code>"sums_load"</code>, then total variances are calculated using the
squared sums of general factor loadings and group factor loadings and
the sum of uniquenesses (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>## What this function does
</p>
<p>This function calculates McDonald's omegas (McDonald, 1978, 1985, 1999),
the H index (Hancock &amp; Mueller, 2001), the explained common variance (ECV;
Sijtsma, 2009), and the percent of uncontaminated correlations (PUC; Bonifay
et al., 2015; Reise et al., 2013).
</p>
<p>All types of omegas (total, hierarchical, and subscale) are calculated for
the general factor as well as for the subscales / group factors (see, e.g.,
Gignac, 2014; Rodriguez et al., 2016a, 2016b). Omegas refer to the correlation
between a factor and a unit-weighted composite score and thus the
true score variance in a unit-weighted composite based on the respective
indicators. Omega total is the total true score variance in a composite.
Omega hierarchical is the true score variance in a composite that is attributable
to the general factor, and omega subscale is the true score variance in a
composite attributable to all subscales / group factors (for the whole scale)
or to the specific subscale / group factor (for subscale composites).
</p>
<p>The H index (also construct reliability or replicability index) is the
correlation between an optimally-weighted composite score
and a factor (Hancock &amp; Mueller, 2001; Rodriguez et al., 2016a, 2016b). It, too,
can be calculated for the whole scale / general factor as well as for the
subscales / grouup factors. Low values indicate that a latent variable is not well
defined by its indicators.
</p>
<p>The ECV (Sijtsma, 2009, Rodriguez et al., 2016a, 2016b) is the ratio of the
variance explained by the general factor and the variance explained by the
general factor and the group factors.
</p>
<p>The PUC (Bonifay et al., 2015; Reise et al., 2013, Rodriguez et al., 2016a,
2016b) refers to the proportion
of correlations in the underlying correlation matrix that is not contaminated
by variance of both the general factor and the group factors (i.e., correlations
between indicators from different group factors, which reflect only general
factor variance). The higher the PUC, the more similar a general factor from
a multidimensional model will be to the single factor from a unidimensional
model.
</p>
<p>## How to use this function
</p>
<p>If <code>model</code> is a <code>lavaan</code> second-order or bifactor solution,
only the name of the general factor from the lavaan model needs to be specified
additionally with the <code>g_name</code> argument. It is then determined whether this
general factor is a second-order factor (second-order model with one second-order
factor assumed) or a breadth factor (bifactor model assumed). Please note that
this function only works for second-order models if they contain no more than
one second-order factor. In case of a second-order solution, a
Schmid-Leiman transformation is performed on the first- and second-order loadings
and omega coefficents are obtained from the transformed (orthogonalized) solution
(see <code><a href="#topic+SL">SL</a></code> for more information on Schmid-Leiman transformation).
There is also the possibility to enter a <code>lavaan</code> single factor solution.
In this case, <code>g_name</code> is not needed. Finally, if a solution from a
<code>lavaan</code> multiple group analysis is entered, the indices are computed for
each group.
The type argument is not evaluated if <code>model</code> is of class
<code>lavaan</code>.
</p>
<p>If <code>model</code> is of class <code><a href="#topic+SL">SL</a></code> or
<code><a href="psych.html#topic+schmid">psych::schmid</a></code> only the
<code>type</code> and, depending on the type (see below), the <code>factor_corres</code>
arguments need to be specified additionally. If model is of class
<code><a href="psych.html#topic+schmid">psych::schmid</a></code> and <code>variance = "correlation"</code>
(default), it is
recommended to also provide the original correlation matrix in <code>cormat</code>
to get more accurate results. Otherwise, the correlation matrix will be found
based on the pattern matrix and Phi from the
<code><a href="psych.html#topic+schmid">psych::schmid</a></code> output
using the <code><a href="psych.html#topic+factor.model">psych::factor.model</a></code> function.
</p>
<p>If <code>model = NULL</code>, the arguments <code>type</code>, <code>factor_corres</code>
(depending on the type, see below), <code>var_names</code>, <code>g_load</code>, <code>s_load</code>,
and <code>u2</code> and either <code>cormat</code> (recommended) or <code>Phi</code> and
<code>pattern</code> need to be specified. If <code>Phi</code> and <code>pattern</code> are
specified instead of <code>cormat</code>, the correlation matrix is found using
the <code><a href="psych.html#topic+factor.model">psych::factor.model</a></code> function.
</p>
<p>The only difference between <code>type = "EFAtools"</code> and <code>type = "psych"</code>
is the determination of variable-to-factor correspondences. <code>type = "psych"</code>
reproduces the <code><a href="psych.html#topic+omega">psych::omega</a></code> results, where
variable-to-factor correspondences are found by taking the highest
group factor loading for each variable as the relevant group factor loading.
To do this, <code>factor_corres</code> must be left <code>NULL</code>.
</p>
<p>The calculation of the total variance (for the whole scale as well as the
subscale composites) can also be controlled in this function using the
<code>variance</code> argument. For both types&mdash;<code>"EFAtools"</code> and <code>"psych"</code>
&mdash;<code>variance</code> is set to <code>"correlation"</code> by default, which means that
total variances are found using the correlation matrix. If
<code>variance = "sums_load"</code> the total variance is calculated using the
squared sums of general loadings and group factor loadings and the sum of the
uniquenesses. This will only get comparable results to
<code>variance = "correlation"</code> if no cross-loadings are present and simple
structure is well-achieved in general with the SL solution (i.e., the
uniquenesses should capture almost all of the variance not explained by the
general factor and the variable's allocated group factor).
</p>


<h3>Value</h3>

<p>If found for an SL or <code>lavaan</code> second-order of bifactor solution
without multiple groups:
A matrix with omegas for the whole scale and for the subscales and (only if
<code>add_ind = TRUE</code>) with the H index, ECV, and PUC.
</p>
<table>
<tr><td><code>tot</code></td>
<td>
<p>Omega total.</p>
</td></tr>
<tr><td><code>hier</code></td>
<td>
<p>Omega hierarchical.</p>
</td></tr>
<tr><td><code>sub</code></td>
<td>
<p>Omega subscale.</p>
</td></tr>
<tr><td><code>H</code></td>
<td>
<p>H index.</p>
</td></tr>
<tr><td><code>ECV</code></td>
<td>
<p>Explained common variance.</p>
</td></tr>
<tr><td><code>PUC</code></td>
<td>
<p>Percent of uncontaminated correlations.</p>
</td></tr>
</table>
<p>If found for a <code>lavaan</code> single factor solution without multiple groups:
A (named) vector with omega total and (if <code>add_ind = TRUE</code>) the H index
for the single factor.
</p>
<p>If found for a <code>lavaan</code> output from a multiple group analysis: A list
containing the output described above for each group.
</p>


<h3>Source</h3>

<p>McDonald, R. P. (1978). Generalizability in factorable domains: ‘‘Domain
validity and generalizability’’. Educational and Psychological Measurement,
38, 75–79.
</p>
<p>McDonald, R. P. (1985). Factor analysis and related methods. Hillsdale,
NJ: Erlbaum.
</p>
<p>McDonald, R. P. (1999). Test theory: A unified treatment. Mahwah,
NJ: Erlbaum.
</p>
<p>Rodriguez, A., Reise, S. P., &amp; Haviland, M. G. (2016a). Applying bifactor
statistical indices in the evaluation of psychological measures. Journal of
Personality Assessment, 98, 223-237.
</p>
<p>Rodriguez, A., Reise, S. P., &amp; Haviland, M. G. (2016b). Evaluating
bifactor models: Calculating and interpreting statistical indices.
Psychological Methods, 21, 137-150.
</p>
<p>Hancock, G. R., &amp; Mueller, R. O. (2001). Rethinking construct reliability
within latent variable systems. In R. Cudeck, S. du Toit, &amp; D. Sörbom (Eds.),
Structural equation modeling: Present and future—A Festschrift in honor of Karl
Jöreskog (pp. 195–216). Lincolnwood, IL: Scientific Software International.
</p>
<p>Sijtsma, K. (2009). On the use, the misuse, and the very limited usefulness
of Cronbach’s alpha. Psychometrika, 74, 107–120.
</p>
<p>Reise, S. P., Scheines, R., Widaman, K. F., &amp; Haviland, M. G. (2013).
Multidimensionality and structural coefficient bias in structural equation
modeling: A bifactor perspective. Educational and Psychological Measurement,
73, 5–26.
</p>
<p>Bonifay, W. E., Reise, S. P., Scheines, R., &amp; Meijer, R. R. (2015).
When are multidimensional data unidimensional enough for structural equation
modeling?: An evaluation of the DETECT multidimensionality index. Structural
Equation Modeling, 22, 504—516.
</p>
<p>Gignac, G. E. (2014). On the Inappropriateness of Using Items to
Calculate Total Scale Score Reliability via Coefficient Alpha for Multidimensional
Scales. European Journal of Psychological Assessment, 30, 130-139.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Use with lavaan outputs

# Create and fit bifactor model in lavaan (assume all variables have SDs of 1)
mod &lt;- 'F1 =~ V1 + V2 + V3 + V4 + V5 + V6
        F2 =~ V7 + V8 + V9 + V10 + V11 + V12
        F3 =~ V13 + V14 + V15 + V16 + V17 + V18
        g =~ V1 + V2 + V3 + V4 + V5 + V6 + V7 + V8 + V9 + V10 + V11 + V12 +
             V13 + V14 + V15 + V16 + V17 + V18'
fit_bi &lt;- lavaan::cfa(mod, sample.cov = test_models$baseline$cormat,
                      sample.nobs = 500, estimator = "ml", orthogonal = TRUE)

# Compute omegas and additional indices for bifactor solution
OMEGA(fit_bi, g_name = "g")

# Compute only omegas
OMEGA(fit_bi, g_name = "g", add_ind = FALSE)

# Create and fit second-order model in lavaan (assume all variables have SDs of 1)
mod &lt;- 'F1 =~ V1 + V2 + V3 + V4 + V5 + V6
        F2 =~ V7 + V8 + V9 + V10 + V11 + V12
        F3 =~ V13 + V14 + V15 + V16 + V17 + V18
        g =~ F1 + F2 + F3'
fit_ho &lt;- lavaan::cfa(mod, sample.cov = test_models$baseline$cormat,
                      sample.nobs = 500, estimator = "ml")

# Compute omegas and additional indices for second-order solution
OMEGA(fit_ho, g_name = "g")


## Use with an output from the SL function, with type EFAtools
efa_mod &lt;- EFA(test_models$baseline$cormat, N = 500, n_factors = 3,
               type = "EFAtools", method = "PAF", rotation = "promax")
sl_mod &lt;- SL(efa_mod, type = "EFAtools", method = "PAF")

# Two examples how to specify the indicator-to-factor correspondences:

# Based on a specific salience threshold for the loadings (here: .20):
factor_corres_1 &lt;- sl_mod$sl[, c("F1", "F2", "F3")] &gt;= .2

# Or more flexibly (could also be TRUE and FALSE instead of 0 and 1):
factor_corres_2 &lt;- matrix(c(rep(0, 12), rep(1, 6), rep(0, 6), rep(1, 6),
                         rep(0, 6), rep(1, 6), rep(0, 12)), ncol = 3,
                         byrow = FALSE)

OMEGA(sl_mod, type = "EFAtools", factor_corres = factor_corres_1)

## Use with an output from the psych::schmid function, with type psych for
## OMEGA
schmid_mod &lt;- psych::schmid(test_models$baseline$cormat, nfactors = 3,
                            n.obs = 500, fm = "pa", rotate = "Promax")
# Find correlation matrix from phi and pattern matrix from psych::schmid output
OMEGA(schmid_mod, type = "psych")
# Use specified correlation matrix
OMEGA(schmid_mod, type = "psych", cormat = test_models$baseline$cormat)

## Manually specify components (useful if omegas should be computed for a SL
## or bifactor solution found with another program)
## As an example, we extract the elements from an SL output here. This gives
## the same results as in the second example above.

efa_mod &lt;- EFA(test_models$baseline$cormat, N = 500, n_factors = 3,
               type = "EFAtools", method = "PAF", rotation = "promax")
sl_mod &lt;- SL(efa_mod, type = "EFAtools", method = "PAF")

factor_corres &lt;- matrix(c(rep(0, 12), rep(1, 6), rep(0, 6), rep(1, 6),
                        rep(0, 6), rep(1, 6), rep(0, 12)), ncol = 3,
                        byrow = FALSE)

OMEGA(model = NULL, type = "EFAtools", var_names = rownames(sl_mod$sl),
      g_load = sl_mod$sl[, "g"], s_load = sl_mod$sl[, c("F1", "F2", "F3")],
      u2 = sl_mod$sl[, "u2"], cormat = test_models$baseline$cormat,
      factor_corres = factor_corres)

</code></pre>

<hr>
<h2 id='PARALLEL'>Parallel analysis</h2><span id='topic+PARALLEL'></span>

<h3>Description</h3>

<p>Various methods for performing parallel analysis. This function uses
<a href="future.apply.html#topic+future_lapply">future_lapply</a> for which a parallel processing plan can
be selected. To do so, call <code>library(future)</code> and, for example,
<code>plan(multisession)</code>; see examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PARALLEL(
  x = NULL,
  N = NA,
  n_vars = NA,
  n_datasets = 1000,
  percent = 95,
  eigen_type = c("PCA", "SMC", "EFA"),
  use = c("pairwise.complete.obs", "all.obs", "complete.obs", "everything",
    "na.or.complete"),
  cor_method = c("pearson", "spearman", "kendall"),
  decision_rule = c("means", "percentile", "crawford"),
  n_factors = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PARALLEL_+3A_x">x</code></td>
<td>
<p>matrix or data.frame. The real data to compare the simulated eigenvalues
against. Must not contain variables of classes other than numeric. Can be a
correlation matrix or raw data.</p>
</td></tr>
<tr><td><code id="PARALLEL_+3A_n">N</code></td>
<td>
<p>numeric. The number of cases / observations to simulate. Only has to
be specified if <code>x</code> is either a correlation matrix or <code>NULL</code>. If
x contains raw data, <code>N</code> is found from the dimensions of <code>x</code>.</p>
</td></tr>
<tr><td><code id="PARALLEL_+3A_n_vars">n_vars</code></td>
<td>
<p>numeric. The number of variables / indicators to simulate.
Only has to be specified if <code>x</code> is left as <code>NULL</code> as otherwise the
dimensions are taken from <code>x</code>.</p>
</td></tr>
<tr><td><code id="PARALLEL_+3A_n_datasets">n_datasets</code></td>
<td>
<p>numeric. The number of datasets to simulate. Default is 1000.</p>
</td></tr>
<tr><td><code id="PARALLEL_+3A_percent">percent</code></td>
<td>
<p>numeric. The percentile to take from the simulated eigenvalues.
Default is 95.</p>
</td></tr>
<tr><td><code id="PARALLEL_+3A_eigen_type">eigen_type</code></td>
<td>
<p>character. On what the eigenvalues should be found. Can be
either &quot;SMC&quot;, &quot;PCA&quot;, or &quot;EFA&quot;. If using &quot;SMC&quot;, the diagonal of the correlation
matrix is replaced by the squared multiple correlations (SMCs) of the
indicators. If using &quot;PCA&quot;, the diagonal values of the correlation matrices
are left to be 1. If using &quot;EFA&quot;, eigenvalues are found on the correlation
matrices with the final communalities of an EFA solution as diagonal.</p>
</td></tr>
<tr><td><code id="PARALLEL_+3A_use">use</code></td>
<td>
<p>character. Passed to <code><a href="stats.html#topic+cor">stats::cor</a></code> if raw data
is given as input. Default is &quot;pairwise.complete.obs&quot;.</p>
</td></tr>
<tr><td><code id="PARALLEL_+3A_cor_method">cor_method</code></td>
<td>
<p>character. Passed to <code><a href="stats.html#topic+cor">stats::cor</a></code>
Default is &quot;pearson&quot;.</p>
</td></tr>
<tr><td><code id="PARALLEL_+3A_decision_rule">decision_rule</code></td>
<td>
<p>character. Which rule to use to determine the number of
factors to retain. Default is <code>"means"</code>, which will use the average
simulated eigenvalues. <code>"percentile"</code>, uses the percentiles specified
in percent. <code>"crawford"</code> uses the 95th percentile for the first factor
and the mean afterwards (based on Crawford et al, 2010).</p>
</td></tr>
<tr><td><code id="PARALLEL_+3A_n_factors">n_factors</code></td>
<td>
<p>numeric. Number of factors to extract if &quot;EFA&quot; is included in
<code>eigen_type</code>. Default is 1.</p>
</td></tr>
<tr><td><code id="PARALLEL_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+EFA">EFA</a></code>. For example,
the extraction method can be changed here (default is &quot;PAF&quot;). PAF is more
robust, but it will take longer compared to the other estimation methods
available (&quot;ML&quot; and &quot;ULS&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Parallel analysis (Horn, 1965) compares the eigenvalues obtained from
the sample
correlation matrix against those of null model correlation matrices (i.e.,
with uncorrelated variables) of the same sample size. This way, it accounts
for the variation in eigenvalues introduced by sampling error and thus
eliminates the main problem inherent in the Kaiser-Guttman criterion
(<code><a href="#topic+KGC">KGC</a></code>).
</p>
<p>Three different ways of finding the eigenvalues under the factor model are
implemented, namely &quot;SMC&quot;, &quot;PCA&quot;, and &quot;EFA&quot;. PCA leaves the diagonal elements
of the correlation matrix as they are and is thus equivalent to what is done
in PCA. SMC uses squared multiple correlations as communality estimates with
which the diagonal of the correlation matrix is replaced. Finally, EFA performs
an <code><a href="#topic+EFA">EFA</a></code> with one factor (can be adapted to more factors) to estimate
the communalities and based on the correlation matrix with these as diagonal
elements, finds the eigenvalues.
</p>
<p>Parallel analysis is often argued to be one of the most accurate factor
retention criteria. However, for highly correlated
factor structures it has been shown to underestimate the correct number of
factors. The reason for this is that a null model (uncorrelated variables)
is used as reference. However, when factors are highly correlated, the first
eigenvalue will be much larger compared to the following ones, as
later eigenvalues are conditional on the earlier ones in the sequence and thus
the shared variance is already accounted in the first eigenvalue (e.g.,
Braeken &amp; van Assen, 2017).
</p>
<p>The <code>PARALLEL</code> function can also be called together with other factor
retention criteria in the <code><a href="#topic+N_FACTORS">N_FACTORS</a></code> function.
</p>


<h3>Value</h3>

<p>A list of class PARALLEL containing the following objects
</p>
<table>
<tr><td><code>eigenvalues_PCA</code></td>
<td>
<p>A matrix containing the eigenvalues of the real and the simulated data found with eigen_type = &quot;PCA&quot;</p>
</td></tr>
<tr><td><code>eigenvalues_SMC</code></td>
<td>
<p>A matrix containing the eigenvalues of the real and the simulated data found with eigen_type = &quot;SMC&quot;</p>
</td></tr>
<tr><td><code>eigenvalues_EFA</code></td>
<td>
<p>A matrix containing the eigenvalues of the real and the simulated data found with eigen_type = &quot;EFA&quot;</p>
</td></tr>
<tr><td><code>n_fac_PCA</code></td>
<td>
<p>The number of factors to retain according to the parallel procedure with eigen_type = &quot;PCA&quot;.</p>
</td></tr>
<tr><td><code>n_fac_SMC</code></td>
<td>
<p>The number of factors to retain according to the parallel procedure with eigen_type = &quot;SMC&quot;.</p>
</td></tr>
<tr><td><code>n_fac_EFA</code></td>
<td>
<p>The number of factors to retain according to the parallel procedure with eigen_type = &quot;EFA&quot;.</p>
</td></tr>
<tr><td><code>settings</code></td>
<td>
<p>A list of control settings used in the print function.</p>
</td></tr>
</table>


<h3>Source</h3>

<p>Braeken, J., &amp; van Assen, M. A. (2017). An empirical Kaiser criterion.
Psychological Methods, 22, 450 – 466. http://dx.doi.org/10.1037/ met0000074
</p>
<p>Crawford, A. V., Green, S. B., Levy, R., Lo, W. J., Scott, L.,
Svetina, D., &amp; Thompson, M. S. (2010). Evaluation of parallel analysis methods
for determining the number of factors. Educational and Psychological
Measurement, 70(6), 885-901.
</p>
<p>Horn, J. L. (1965). A rationale and test for the number of factors in
factor analysis. Psychometrika, 30(2), 179–185. doi: 10.1007/BF02289447
</p>


<h3>See Also</h3>

<p>Other factor retention criteria: <code><a href="#topic+CD">CD</a></code>, <code><a href="#topic+EKC">EKC</a></code>,
<code><a href="#topic+HULL">HULL</a></code>, <code><a href="#topic+KGC">KGC</a></code>, <code><a href="#topic+SMT">SMT</a></code>
</p>
<p><code><a href="#topic+N_FACTORS">N_FACTORS</a></code> as a wrapper function for this and all the
above-mentioned factor retention criteria.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# example without real data
pa_unreal &lt;- PARALLEL(N = 500, n_vars = 10)

# example with correlation matrix with all eigen_types and PAF estimation
pa_paf &lt;- PARALLEL(test_models$case_11b$cormat, N = 500)

# example with correlation matrix with all eigen_types and ML estimation
# this will be faster than the above with PAF)
pa_ml &lt;- PARALLEL(test_models$case_11b$cormat, N = 500, method = "ML")


## Not run: 
# for parallel computation
future::plan(future::multisession)
pa_faster &lt;- PARALLEL(test_models$case_11b$cormat, N = 500)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.CD'>Plot CD object</h2><span id='topic+plot.CD'></span>

<h3>Description</h3>

<p>Plot method showing a summarized output of the <a href="#topic+CD">CD</a> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CD'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.CD_+3A_x">x</code></td>
<td>
<p>a list of class CD. An output from the <a href="#topic+CD">CD</a> function.</p>
</td></tr>
<tr><td><code id="plot.CD_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>

<hr>
<h2 id='plot.EFA_AVERAGE'>Plot EFA_AVERAGE object</h2><span id='topic+plot.EFA_AVERAGE'></span>

<h3>Description</h3>

<p>Plot method showing a summarized output of the <a href="#topic+EFA_AVERAGE">EFA_AVERAGE</a> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'EFA_AVERAGE'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.EFA_AVERAGE_+3A_x">x</code></td>
<td>
<p>list. An output from the <a href="#topic+EFA_AVERAGE">EFA_AVERAGE</a> function.</p>
</td></tr>
<tr><td><code id="plot.EFA_AVERAGE_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
EFA_aver &lt;- EFA_AVERAGE(test_models$baseline$cormat, n_factors = 3, N = 500)
EFA_aver

## End(Not run)

</code></pre>

<hr>
<h2 id='plot.EKC'>Plot EKC object</h2><span id='topic+plot.EKC'></span>

<h3>Description</h3>

<p>Plot method showing a summarized output of the <a href="#topic+EKC">EKC</a> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'EKC'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.EKC_+3A_x">x</code></td>
<td>
<p>a list of class EKC. An output from the <a href="#topic+EKC">EKC</a> function.</p>
</td></tr>
<tr><td><code id="plot.EKC_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>EKC_base &lt;- EKC(test_models$baseline$cormat, N = 500)
plot(EKC_base)

</code></pre>

<hr>
<h2 id='plot.HULL'>Plot HULL object</h2><span id='topic+plot.HULL'></span>

<h3>Description</h3>

<p>Plot method showing a summarized output of the <code><a href="#topic+HULL">HULL</a></code> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'HULL'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.HULL_+3A_x">x</code></td>
<td>
<p>list of class HULL. An output from the <code><a href="#topic+HULL">HULL</a></code> function.</p>
</td></tr>
<tr><td><code id="plot.HULL_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- HULL(test_models$baseline$cormat, N = 500, method = "ML")
plot(x)

</code></pre>

<hr>
<h2 id='plot.KGC'>Plot KGC object</h2><span id='topic+plot.KGC'></span>

<h3>Description</h3>

<p>Plot method showing a summarized output of the <a href="#topic+KGC">KGC</a> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'KGC'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.KGC_+3A_x">x</code></td>
<td>
<p>a list of class KGC. An output from the <a href="#topic+KGC">KGC</a> function.</p>
</td></tr>
<tr><td><code id="plot.KGC_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>KGC_base &lt;- KGC(test_models$baseline$cormat)
plot(KGC_base)

</code></pre>

<hr>
<h2 id='plot.PARALLEL'>Plot PARALLEL object</h2><span id='topic+plot.PARALLEL'></span>

<h3>Description</h3>

<p>Plot method showing a summarized output of the <a href="#topic+PARALLEL">PARALLEL</a> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PARALLEL'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.PARALLEL_+3A_x">x</code></td>
<td>
<p>list of class PARALLEL. An output from the <a href="#topic+PARALLEL">PARALLEL</a> function.</p>
</td></tr>
<tr><td><code id="plot.PARALLEL_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# example with correlation matrix and "ML" estimation
x &lt;- PARALLEL(test_models$case_11b$cormat, N = 500, method = "ML")
plot(x)

</code></pre>

<hr>
<h2 id='plot.SCREE'>Plot SCREE object</h2><span id='topic+plot.SCREE'></span>

<h3>Description</h3>

<p>Plot method showing a summarized output of the <a href="#topic+SCREE">SCREE</a> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SCREE'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.SCREE_+3A_x">x</code></td>
<td>
<p>a list of class SCREE An output from the <a href="#topic+SCREE">SCREE</a> function.</p>
</td></tr>
<tr><td><code id="plot.SCREE_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>SCREE_base &lt;- SCREE(test_models$baseline$cormat)
plot(SCREE_base)

</code></pre>

<hr>
<h2 id='population_models'>population_models</h2><span id='topic+population_models'></span>

<h3>Description</h3>

<p>Population factor models, some of which (baseline to case_11e) used for the
simulation analyses reported in Grieder and Steiner (2019). All combinations
of the pattern matrices and the factor
intercorrelations were used in the simulations. Many models are based on cases
used in de Winter and Dodou (2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>population_models
</code></pre>


<h3>Format</h3>

<p>A list of 3 lists &quot;loadings&quot;, &quot;phis_3&quot;, and &quot;phis_6&quot;.
</p>

<p><code>loadings</code> contains the following matrices of pattern coefficients:
</p>
<dl>
<dt>baseline</dt><dd><p>(matrix) - The pattern coefficients of the baseline model. Three factors with six indicators each, all with pattern coefficients of .6. Same baseline model as used in de Winter and Dodou (2012).</p>
</dd>
<dt>case_1a</dt><dd><p>(matrix) - Three factors with 2 indicators per factor.</p>
</dd>
<dt>case_1b</dt><dd><p>(matrix) - Three factors with 3 indicators per factor. Case 5 in de Winter and Dodou (2012).</p>
</dd>
<dt>case_1c</dt><dd><p>(matrix) - Three factors with 4 indicators per factor.</p>
</dd>
<dt>case_1d</dt><dd><p>(matrix) - Three factors with 5 indicators per factor.</p>
</dd>
<dt>case_2</dt><dd><p>(matrix) - Same as baseline model but with low pattern coefficients of .3.</p>
</dd>
<dt>case_3</dt><dd><p>(matrix) - Same as baseline model but with high pattern coefficients of .9.</p>
</dd>
<dt>case_4</dt><dd><p>(matrix) - Three factors with different pattern coefficients <em>between</em> factors (one factor with .9, one with .6, and one with .3, respectively). Case 7 in de Winter and Dodou (2012).</p>
</dd>
<dt>case_5</dt><dd><p>(matrix) - Three factors with different pattern coefficients <em>within</em> factors (each factor has two pattern coefficients of each .9, .6, and .3). Similar to cases 8/ 9 in de Winter and Dodou (2012).</p>
</dd>
<dt>case_6a</dt><dd><p>(matrix) - Same as baseline model but with one cross loading of .4. Similar to case 10 in de Winter and Dodou (2012).</p>
</dd>
<dt>case_6b</dt><dd><p>(matrix) - Same as baseline model but with three cross loading of .4 (One factor with 2 and one with 1 crossloading). Similar to case 10 in de Winter and Dodou (2012).</p>
</dd>
<dt>case_7</dt><dd><p>(matrix) - Three factors with different number of indicators per factor (2, 4, and 6 respectively). Similar to cases 11/ 12 in de Winter and Dodou (2012).</p>
</dd>
<dt>case_8</dt><dd><p>(matrix) - Three factors with random variation in pattern coefficients added, drawn from a uniform distribution between [-.2, .2]. Case 13 in de Winter and Dodou (2012).</p>
</dd>
<dt>case_9a</dt><dd><p>(matrix) - Three factors with 2 indicators per factor, with different pattern coefficients within one of the factors.</p>
</dd>
<dt>case_9b</dt><dd><p>(matrix) - Three factors with 3 indicators per factor, with different pattern coefficients.</p>
</dd>
<dt>case_9c</dt><dd><p>(matrix) - Three factors with 4 indicators per factor, with different pattern coefficients.</p>
</dd>
<dt>case_9d</dt><dd><p>(matrix) - Three factors with 5 indicators per factor, with different pattern coefficients.</p>
</dd>
<dt>case_10a</dt><dd><p>(matrix) - Six factors with 2 indicators per factor, all with pattern coefficients of .6.</p>
</dd>
<dt>case_10b</dt><dd><p>(matrix) - Six factors with 3 indicators per factor, all with pattern coefficients of .6.</p>
</dd>
<dt>case_10c</dt><dd><p>(matrix) - Six factors with 4 indicators per factor, all with pattern coefficients of .6.</p>
</dd>
<dt>case_10d</dt><dd><p>(matrix) - Six factors with 5 indicators per factor, all with pattern coefficients of .6.</p>
</dd>
<dt>case_10e</dt><dd><p>(matrix) - Six factors with 6 indicators per factor, all with pattern coefficients of .6.</p>
</dd>
<dt>case_11a</dt><dd><p>(matrix) - Six factors with 2 indicators per factor, with different pattern coefficients within and between factors (.3, .6, and .9).</p>
</dd>
<dt>case_11b</dt><dd><p>(matrix) - Six factors with 3 indicators per factor, with different pattern coefficients within and between factors (.3, .6, and .9).</p>
</dd>
<dt>case_11c</dt><dd><p>(matrix) - Six factors with 4 indicators per factor, with different pattern coefficients within and between factors (.3, .6, and .9).</p>
</dd>
<dt>case_11d</dt><dd><p>(matrix) - Six factors with 5 indicators per factor, with different pattern coefficients within and between factors (.3, .6, and .9).</p>
</dd>
<dt>case_11e</dt><dd><p>(matrix) - Six factors with 6 indicators per factor, with different pattern coefficients within and between factors (.3, .6, and .9).</p>
</dd>
<dt>case_12a</dt><dd><p>(matrix) - One factor, with 2 equal pattern coefficients (.6).</p>
</dd>
<dt>case_12b</dt><dd><p>(matrix) - One factor, with 3 equal pattern coefficients (.6).</p>
</dd>
<dt>case_12c</dt><dd><p>(matrix) - One factor, with 6 equal pattern coefficients (.6).</p>
</dd>
<dt>case_12d</dt><dd><p>(matrix) - One factor, with 10 equal pattern coefficients (.6).</p>
</dd>
<dt>case_12e</dt><dd><p>(matrix) - One factor, with 15 equal pattern coefficients (.6).</p>
</dd>
<dt>case_13a</dt><dd><p>(matrix) - One factor, with 2 different pattern coefficients (.3, and .6).</p>
</dd>
<dt>case_13b</dt><dd><p>(matrix) - One factor, with 3 different pattern coefficients (.3, .6, and .9).</p>
</dd>
<dt>case_13c</dt><dd><p>(matrix) - One factor, with 6 different pattern coefficients (.3, .6, and .9).</p>
</dd>
<dt>case_13d</dt><dd><p>(matrix) - One factor, with 10 different pattern coefficients (.3, .6, and .9).</p>
</dd>
<dt>case_13e</dt><dd><p>(matrix) - One factor, with 15 different pattern coefficients (.3, .6, and .9).</p>
</dd>
<dt>case_14a</dt><dd><p>(matrix) - No factor, 2 variables (0).</p>
</dd>
<dt>case_14b</dt><dd><p>(matrix) - No factor, 3 variables (0).</p>
</dd>
<dt>case_14c</dt><dd><p>(matrix) - No factor, 6 variables (0).</p>
</dd>
<dt>case_14d</dt><dd><p>(matrix) - No factor, 10 variables (0).</p>
</dd>
<dt>case_14e</dt><dd><p>(matrix) - No factor, 15 variables (0).</p>
</dd>
</dl>
<p><code>phis_3</code> contains the following 3x3 matrices:
</p>
<dl>
<dt>zero</dt><dd><p>(matrix) - Matrix of factor intercorrelations of 0. Same intercorrelations as used in de Winter and Dodou (2012).</p>
</dd>
<dt>moderate</dt><dd><p>(matrix) - Matrix of moderate factor intercorrelations of .3.</p>
</dd>
<dt>mixed</dt><dd><p>(matrix) - Matrix of mixed (.3, .5, and .7) factor intercorrelations.</p>
</dd>
<dt>strong</dt><dd><p>(matrix) - Matrix of strong factor intercorrelations of .7. Same intercorrelations as used in de Winter and Dodou (2012).</p>
</dd>
</dl>
<p><code>phis_6</code> contains the following 6x6 matrices:
</p>
<dl>
<dt>zero</dt><dd><p>(matrix) - Matrix of factor intercorrelations of 0. Same intercorrelations as used in de Winter and Dodou (2012).</p>
</dd>
<dt>moderate</dt><dd><p>(matrix) - Matrix of moderate factor intercorrelations of .3.</p>
</dd>
<dt>mixed</dt><dd><p>(matrix) - Matrix of mixed (around .3, .5, and .7; smoothing was necessary for the matrix to be positive definite) factor intercorrelations.</p>
</dd>
<dt>strong</dt><dd><p>(matrix) - Matrix of strong factor intercorrelations of .7. Same intercorrelations as used in de Winter and Dodou (2012).</p>
</dd>
</dl>



<h3>Source</h3>

<p>Grieder, S., &amp; Steiner, M.D. (2020). Algorithmic Jingle Jungle:
A Comparison of Implementations of Principal Axis Factoring and Promax Rotation
in R and SPSS. Manuscript in Preparation.
</p>
<p>de Winter, J.C.F., &amp; Dodou, D. (2012). Factor recovery by principal axis factoring and maximum likelihood factor analysis as a function of factor pattern and sample size. Journal of Applied Statistics. 39.
</p>

<hr>
<h2 id='print.BARTLETT'>Print BARTLETT object</h2><span id='topic+print.BARTLETT'></span>

<h3>Description</h3>

<p>Print BARTLETT object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BARTLETT'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.BARTLETT_+3A_x">x</code></td>
<td>
<p>list of class BARTLETT (output from the <a href="#topic+BARTLETT">BARTLETT</a> function)</p>
</td></tr>
<tr><td><code id="print.BARTLETT_+3A_...">...</code></td>
<td>
<p>additional arguments passed to print</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>BARTLETT(test_models$baseline$cormat, N = 500)

</code></pre>

<hr>
<h2 id='print.CD'>Print function for CD objects</h2><span id='topic+print.CD'></span>

<h3>Description</h3>

<p>Print function for CD objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CD'
print(x, plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.CD_+3A_x">x</code></td>
<td>
<p>a list of class CD. Output from <a href="#topic+CD">CD</a> function.</p>
</td></tr>
<tr><td><code id="print.CD_+3A_plot">plot</code></td>
<td>
<p>logical. Whether to plot the results.</p>
</td></tr>
<tr><td><code id="print.CD_+3A_...">...</code></td>
<td>
<p>Further arguments for print.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# determine n factors of the GRiPS
CD(GRiPS_raw)


</code></pre>

<hr>
<h2 id='print.COMPARE'>Print COMPARE object</h2><span id='topic+print.COMPARE'></span>

<h3>Description</h3>

<p>Print Method showing a summarized output of the <code><a href="#topic+COMPARE">COMPARE</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'COMPARE'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.COMPARE_+3A_x">x</code></td>
<td>
<p>list. An object of class COMPARE to be printed</p>
</td></tr>
<tr><td><code id="print.COMPARE_+3A_...">...</code></td>
<td>
<p>Further arguments for print.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># A type SPSS EFA to mimick the SPSS implementation
EFA_SPSS_5 &lt;- EFA(IDS2_R, n_factors = 5, type = "SPSS")

# A type psych EFA to mimick the psych::fa() implementation
EFA_psych_5 &lt;- EFA(IDS2_R, n_factors = 5, type = "psych")

# compare the two
COMPARE(EFA_SPSS_5$unrot_loadings, EFA_psych_5$unrot_loadings,
        x_labels = c("SPSS", "psych"))
</code></pre>

<hr>
<h2 id='print.EFA'>Print EFA object</h2><span id='topic+print.EFA'></span>

<h3>Description</h3>

<p>Print Method showing a summarized output of the <a href="#topic+EFA">EFA</a> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'EFA'
print(x, cutoff = 0.3, digits = 3, max_name_length = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.EFA_+3A_x">x</code></td>
<td>
<p>list. An object of class EFA to be printed</p>
</td></tr>
<tr><td><code id="print.EFA_+3A_cutoff">cutoff</code></td>
<td>
<p>numeric. Passed to <code><a href="#topic+print.LOADINGS">print.LOADINGS</a></code>.
The number above which to print loadings in bold. Default is .3.</p>
</td></tr>
<tr><td><code id="print.EFA_+3A_digits">digits</code></td>
<td>
<p>numeric. Passed to <code><a href="#topic+print.LOADINGS">print.LOADINGS</a></code>
Number of digits to round the loadings to (default is 3).</p>
</td></tr>
<tr><td><code id="print.EFA_+3A_max_name_length">max_name_length</code></td>
<td>
<p>numeric. Passed to <code><a href="#topic+print.LOADINGS">print.LOADINGS</a></code>.
The maximum length of the variable names to display. Everything beyond this
will be cut from the right.</p>
</td></tr>
<tr><td><code id="print.EFA_+3A_...">...</code></td>
<td>
<p>Further arguments for print.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>EFAtools_PAF &lt;- EFA(test_models$baseline$cormat, n_factors = 3, N = 500,
                    type = "EFAtools", method = "PAF", rotation = "promax")
EFAtools_PAF

</code></pre>

<hr>
<h2 id='print.EFA_AVERAGE'>Print EFA_AVERAGE object</h2><span id='topic+print.EFA_AVERAGE'></span>

<h3>Description</h3>

<p>Print Method showing a summarized output of the <a href="#topic+EFA_AVERAGE">EFA_AVERAGE</a> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'EFA_AVERAGE'
print(x, stat = c("average", "range"), plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.EFA_AVERAGE_+3A_x">x</code></td>
<td>
<p>list. An object of class EFA_AVERAGE to be printed</p>
</td></tr>
<tr><td><code id="print.EFA_AVERAGE_+3A_stat">stat</code></td>
<td>
<p>character. A vector with the statistics to print. Possible inputs
are &quot;average&quot;, &quot;sd&quot;, &quot;range&quot;, &quot;min&quot;, and &quot;max&quot;. Default is &quot;average&quot; and
&quot;range&quot;.</p>
</td></tr>
<tr><td><code id="print.EFA_AVERAGE_+3A_plot">plot</code></td>
<td>
<p>logical. Whether a plot of the average and min- max loadings should
be created. Default is TRUE. If more than 10 factors are extracted, no plot is
created.</p>
</td></tr>
<tr><td><code id="print.EFA_AVERAGE_+3A_...">...</code></td>
<td>
<p>Further arguments for print.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
EFA_aver &lt;- EFA_AVERAGE(test_models$baseline$cormat, n_factors = 3, N = 500)
EFA_aver

## End(Not run)
</code></pre>

<hr>
<h2 id='print.EKC'>Print function for EKC objects</h2><span id='topic+print.EKC'></span>

<h3>Description</h3>

<p>Print function for EKC objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'EKC'
print(x, plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.EKC_+3A_x">x</code></td>
<td>
<p>a list of class EKC. Output from <code><a href="#topic+EKC">EKC</a></code> function.</p>
</td></tr>
<tr><td><code id="print.EKC_+3A_plot">plot</code></td>
<td>
<p>logical. Whether to plot the results.</p>
</td></tr>
<tr><td><code id="print.EKC_+3A_...">...</code></td>
<td>
<p>Further arguments for print.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>EKC_base &lt;- EKC(test_models$baseline$cormat, N = 500)
EKC_base

</code></pre>

<hr>
<h2 id='print.HULL'>Print function for HULL objects</h2><span id='topic+print.HULL'></span>

<h3>Description</h3>

<p>Print function for HULL objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'HULL'
print(x, plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.HULL_+3A_x">x</code></td>
<td>
<p>a list of class HULL. Output from the <code><a href="#topic+HULL">HULL</a></code> function.</p>
</td></tr>
<tr><td><code id="print.HULL_+3A_plot">plot</code></td>
<td>
<p>logical. Whether to plot the results.</p>
</td></tr>
<tr><td><code id="print.HULL_+3A_...">...</code></td>
<td>
<p>Further arguments for print.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
HULL(test_models$baseline$cormat, N = 500, method = "ML")

</code></pre>

<hr>
<h2 id='print.KGC'>Print function for KGC objects</h2><span id='topic+print.KGC'></span>

<h3>Description</h3>

<p>Print function for KGC objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'KGC'
print(x, plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.KGC_+3A_x">x</code></td>
<td>
<p>a list of class KGC. Output from <a href="#topic+KGC">KGC</a> function.</p>
</td></tr>
<tr><td><code id="print.KGC_+3A_plot">plot</code></td>
<td>
<p>logical. Whether to plot the results.</p>
</td></tr>
<tr><td><code id="print.KGC_+3A_...">...</code></td>
<td>
<p>Further arguments for print.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>KGC_base &lt;- KGC(test_models$baseline$cormat)
KGC_base

</code></pre>

<hr>
<h2 id='print.KMO'>Print KMO object</h2><span id='topic+print.KMO'></span>

<h3>Description</h3>

<p>Print KMO object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'KMO'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.KMO_+3A_x">x</code></td>
<td>
<p>list of class KMO (output from the <a href="#topic+KMO">KMO</a> function)</p>
</td></tr>
<tr><td><code id="print.KMO_+3A_...">...</code></td>
<td>
<p>additional arguments passed to print</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>KMO_base &lt;- KMO(test_models$baseline$cormat)
KMO_base

</code></pre>

<hr>
<h2 id='print.LOADINGS'>Print LOADINGS object</h2><span id='topic+print.LOADINGS'></span>

<h3>Description</h3>

<p>Print LOADINGS object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LOADINGS'
print(x, cutoff = 0.3, digits = 3, max_name_length = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.LOADINGS_+3A_x">x</code></td>
<td>
<p>class LOADINGS matrix.</p>
</td></tr>
<tr><td><code id="print.LOADINGS_+3A_cutoff">cutoff</code></td>
<td>
<p>numeric. The number above which to print loadings in bold
default is .3.</p>
</td></tr>
<tr><td><code id="print.LOADINGS_+3A_digits">digits</code></td>
<td>
<p>numeric. Passed to <code><a href="base.html#topic+Round">round</a></code>. Number of digits
to round the loadings to (default is 3).</p>
</td></tr>
<tr><td><code id="print.LOADINGS_+3A_max_name_length">max_name_length</code></td>
<td>
<p>numeric. The maximum length of the variable names to
display. Everything beyond this will be cut from the right.</p>
</td></tr>
<tr><td><code id="print.LOADINGS_+3A_...">...</code></td>
<td>
<p>additional arguments passed to print</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>EFAtools_PAF &lt;- EFA(test_models$baseline$cormat, n_factors = 3, N = 500,
                    type = "EFAtools", method = "PAF", rotation = "promax")
EFAtools_PAF

</code></pre>

<hr>
<h2 id='print.N_FACTORS'>Print function for N_FACTORS objects</h2><span id='topic+print.N_FACTORS'></span>

<h3>Description</h3>

<p>Print function for N_FACTORS objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'N_FACTORS'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.N_FACTORS_+3A_x">x</code></td>
<td>
<p>a list of class N_FACTORS. Output from <a href="#topic+N_FACTORS">N_FACTORS</a> function.</p>
</td></tr>
<tr><td><code id="print.N_FACTORS_+3A_...">...</code></td>
<td>
<p>Further arguments for print.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# All criteria except "CD", with correlation matrix and fit method "ML"
# (where needed)
N_FACTORS(test_models$baseline$cormat, criteria = c("EKC", "HULL", "KGC",
          "PARALLEL", "SCREE", "SMT"), N = 500, method = "ML")

</code></pre>

<hr>
<h2 id='print.OMEGA'>Print OMEGA object</h2><span id='topic+print.OMEGA'></span>

<h3>Description</h3>

<p>Print OMEGA object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'OMEGA'
print(x, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.OMEGA_+3A_x">x</code></td>
<td>
<p>output of class OMEGA (output from the <a href="#topic+OMEGA">OMEGA</a> function)</p>
</td></tr>
<tr><td><code id="print.OMEGA_+3A_digits">digits</code></td>
<td>
<p>numeric. Passed to <code><a href="base.html#topic+Round">round</a></code>. Number of digits
to round to (default is 3).</p>
</td></tr>
<tr><td><code id="print.OMEGA_+3A_...">...</code></td>
<td>
<p>additional arguments passed to print</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>efa_mod &lt;- EFA(test_models$baseline$cormat, N = 500, n_factors = 3,
               type = "EFAtools", method = "PAF", rotation = "promax")
sl_mod &lt;- SL(efa_mod, type = "EFAtools", method = "PAF")

OMEGA(sl_mod, type = "EFAtools",
factor_corres = sl_mod$sl[, c("F1", "F2", "F3")] &gt;= .2)

</code></pre>

<hr>
<h2 id='print.PARALLEL'>Print function for PARALLEL objects</h2><span id='topic+print.PARALLEL'></span>

<h3>Description</h3>

<p>Print function for PARALLEL objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PARALLEL'
print(x, plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.PARALLEL_+3A_x">x</code></td>
<td>
<p>a list of class PARALLEL. Output from <a href="#topic+PARALLEL">PARALLEL</a> function.</p>
</td></tr>
<tr><td><code id="print.PARALLEL_+3A_plot">plot</code></td>
<td>
<p>logical. Whether to plot the results.</p>
</td></tr>
<tr><td><code id="print.PARALLEL_+3A_...">...</code></td>
<td>
<p>Further arguments for print.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# example without real data
PARALLEL(N = 500, n_vars = 10)

# example with correlation matrix and "ML" estimation
PARALLEL(test_models$case_11b$cormat, N = 500, method = "ML")

</code></pre>

<hr>
<h2 id='print.SCREE'>Print function for SCREE objects</h2><span id='topic+print.SCREE'></span>

<h3>Description</h3>

<p>Print function for SCREE objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SCREE'
print(x, plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.SCREE_+3A_x">x</code></td>
<td>
<p>a list of class SCREE Output from <a href="#topic+SCREE">SCREE</a> function.</p>
</td></tr>
<tr><td><code id="print.SCREE_+3A_plot">plot</code></td>
<td>
<p>logical. Whether to plot the results.</p>
</td></tr>
<tr><td><code id="print.SCREE_+3A_...">...</code></td>
<td>
<p>Further arguments for print.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>SCREE_base &lt;- SCREE(test_models$baseline$cormat)
SCREE_base

</code></pre>

<hr>
<h2 id='print.SL'>Print SL object</h2><span id='topic+print.SL'></span>

<h3>Description</h3>

<p>Print Method showing a summarized output of the <a href="#topic+SL">SL</a> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SL'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.SL_+3A_x">x</code></td>
<td>
<p>list. An object of class SL to be printed</p>
</td></tr>
<tr><td><code id="print.SL_+3A_...">...</code></td>
<td>
<p>Further arguments for print.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>EFA_mod &lt;- EFA(test_models$baseline$cormat, N = 500, n_factors = 3,
               type = "EFAtools", method = "PAF", rotation = "promax")
SL(EFA_mod, type = "EFAtools", method = "PAF")

</code></pre>

<hr>
<h2 id='print.SLLOADINGS'>Print SLLOADINGS object</h2><span id='topic+print.SLLOADINGS'></span>

<h3>Description</h3>

<p>Print SLLOADINGS object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SLLOADINGS'
print(x, cutoff = 0.2, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.SLLOADINGS_+3A_x">x</code></td>
<td>
<p>class SLLOADINGS matrix.</p>
</td></tr>
<tr><td><code id="print.SLLOADINGS_+3A_cutoff">cutoff</code></td>
<td>
<p>numeric. The number above which to print loadings in bold
(default is .2).</p>
</td></tr>
<tr><td><code id="print.SLLOADINGS_+3A_digits">digits</code></td>
<td>
<p>numeric. Passed to <code><a href="base.html#topic+Round">round</a></code>. Number of digits
to round the loadings to (default is 3).</p>
</td></tr>
<tr><td><code id="print.SLLOADINGS_+3A_...">...</code></td>
<td>
<p>additional arguments passed to print</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>EFA_mod &lt;- EFA(test_models$baseline$cormat, N = 500, n_factors = 3,
               type = "EFAtools", method = "PAF", rotation = "promax")
SL(EFA_mod, type = "EFAtools", method = "PAF")

</code></pre>

<hr>
<h2 id='print.SMT'>Print SMT object</h2><span id='topic+print.SMT'></span>

<h3>Description</h3>

<p>Print SMT object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SMT'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.SMT_+3A_x">x</code></td>
<td>
<p>list of class SMT (output from the <a href="#topic+SMT">SMT</a> function)</p>
</td></tr>
<tr><td><code id="print.SMT_+3A_...">...</code></td>
<td>
<p>additional arguments passed to print</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>SMT_base &lt;- SMT(test_models$baseline$cormat, N = 500)
SMT_base

</code></pre>

<hr>
<h2 id='RiskDimensions'>RiskDimensions</h2><span id='topic+RiskDimensions'></span>

<h3>Description</h3>

<p>A list containing the bivariate correlations (cormat)
of the 9 dimensions on which participants in Fischhoff et al. (1978) rated
different activities and technologies as well as the sample size (N). This was
then analyzed together with ratings of the risks and benefits of these
activities and technologies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RiskDimensions
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.
</p>


<h3>Source</h3>

<p>Fischhoff, B, Slovic, P, Lichtenstein, S, Read, S, and Combs, B. (1978). How safe is safe enough? A psychometric study of attitudes towards technological risks and benefits. Policy Sciences, 9, 127-152. doi: 10.1007/BF00143739
</p>

<hr>
<h2 id='SCREE'>Scree Plot</h2><span id='topic+SCREE'></span>

<h3>Description</h3>

<p>The scree plot was originally introduced by Cattell (1966) to perform the
scree test. In a scree plot, the eigenvalues of the factors / components are
plotted against the index of the factors / components, ordered from 1 to N
factors components, hence from largest to smallest eigenvalue. According to
the scree test, the number of factors / components to retain is the number of
factors / components to the left of the &quot;elbow&quot; (where the curve starts to
level off) in the scree plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SCREE(
  x,
  eigen_type = c("PCA", "SMC", "EFA"),
  use = c("pairwise.complete.obs", "all.obs", "complete.obs", "everything",
    "na.or.complete"),
  cor_method = c("pearson", "spearman", "kendall"),
  n_factors = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SCREE_+3A_x">x</code></td>
<td>
<p>data.frame or matrix. Dataframe or matrix of raw data or matrix with
correlations.</p>
</td></tr>
<tr><td><code id="SCREE_+3A_eigen_type">eigen_type</code></td>
<td>
<p>character. On what the eigenvalues should be found. Can be
either &quot;PCA&quot;, &quot;SMC&quot;, or &quot;EFA&quot;, or some combination of them. If using &quot;PCA&quot;,
the diagonal values of the correlation matrices are left to be 1. If using
&quot;SMC&quot;, the diagonal of the
correlation matrices is replaced by the squared multiple correlations (SMCs)
of the indicators. If using &quot;EFA&quot;, eigenvalues are found on the correlation
matrices with the final communalities of an exploratory factor analysis
solution (default is principal axis factoring extracting 1 factor) as
diagonal.</p>
</td></tr>
<tr><td><code id="SCREE_+3A_use">use</code></td>
<td>
<p>character. Passed to <code><a href="stats.html#topic+cor">stats::cor</a></code> if raw
data is given as input. Default is &quot;pairwise.complete.obs&quot;.</p>
</td></tr>
<tr><td><code id="SCREE_+3A_cor_method">cor_method</code></td>
<td>
<p>character. Passed to <code><a href="stats.html#topic+cor">stats::cor</a></code>.
Default is &quot;pearson&quot;.</p>
</td></tr>
<tr><td><code id="SCREE_+3A_n_factors">n_factors</code></td>
<td>
<p>numeric. Number of factors to extract if &quot;EFA&quot; is included in
<code>eigen_type</code>. Default is 1.</p>
</td></tr>
<tr><td><code id="SCREE_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+EFA">EFA</a></code>. For example,
to change the extraction method (PAF is default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As the scree test requires visual examination, the test has been
especially criticized for its subjectivity and with this low inter-rater
reliability. Moreover, a scree plot can be ambiguous if there are either no
clear &quot;elbow&quot; or multiple &quot;elbows&quot;, making it difficult to judge just where
the eigenvalues do level off. Finally, the scree test has also been found to
be less accurate than other factor retention criteria. For all these reasons,
the scree test has been recommended against, at least for exclusive use as a
factor retention criterion (Zwick &amp; Velicer, 1986)
</p>
<p>The <code>SCREE</code> function can also be called together with other factor
retention criteria in the <code><a href="#topic+N_FACTORS">N_FACTORS</a></code> function.
</p>


<h3>Value</h3>

<p>A list of class SCREE containing
</p>
<table>
<tr><td><code>eigen_PCA</code></td>
<td>
<p> A vector containing the eigenvalues found with PCA.</p>
</td></tr>
<tr><td><code>eigen_SMC</code></td>
<td>
<p> A vector containing the eigenvalues found with SMCs.</p>
</td></tr>
<tr><td><code>eigen_EFA</code></td>
<td>
<p> A vector containing the eigenvalues found with EFA.</p>
</td></tr>
<tr><td><code>settings</code></td>
<td>
<p>A list of the settings used.</p>
</td></tr>
</table>


<h3>Source</h3>

<p>Cattell, R. B. (1966). The scree test for the number of factors.
Multivariate Behavioral Research, 1(2), 245–276.
https://doi.org/10.1207/s15327906mbr0102_10
</p>
<p>Zwick, W. R., &amp; Velicer, W. F. (1986). Comparison of five rules for
determining the number of components to retain. Psychological Bulletin, 99,
432–442. http://dx.doi.org/10.1037/0033-2909.99.3.432
</p>


<h3>See Also</h3>

<p>Other factor retention criteria: <code><a href="#topic+CD">CD</a></code>, <code><a href="#topic+EKC">EKC</a></code>,
<code><a href="#topic+HULL">HULL</a></code>, <code><a href="#topic+PARALLEL">PARALLEL</a></code>, <code><a href="#topic+SMT">SMT</a></code>
</p>
<p><code><a href="#topic+N_FACTORS">N_FACTORS</a></code> as a wrapper function for this and all the
above-mentioned factor retention criteria.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SCREE(test_models$baseline$cormat, eigen_type = c("PCA", "SMC"))
</code></pre>

<hr>
<h2 id='SL'>Schmid-Leiman Transformation</h2><span id='topic+SL'></span>

<h3>Description</h3>

<p>This function implements the Schmid-Leiman (SL) transformation
(Schmid &amp; Leiman, 1957). It takes the pattern coefficients and factor
intercorrelations from an oblique factor solution as
input and can reproduce the results from <code><a href="psych.html#topic+schmid">psych::schmid</a></code>
and from the SPSS implementation from Wolff &amp; Preising (2005). Other arguments
from <code><a href="#topic+EFA">EFA</a></code> can be used to control the procedure to find the
second-order loadings more flexibly. The function can also be used on a
second-order confirmatory factor analysis (CFA) solution from lavaan.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SL(
  x,
  Phi = NULL,
  type = c("EFAtools", "psych", "SPSS", "none"),
  method = c("PAF", "ML", "ULS"),
  g_name = "g",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SL_+3A_x">x</code></td>
<td>
<p>object of class <code><a href="#topic+EFA">EFA</a></code>, class <code><a href="psych.html#topic+fa">psych::fa</a></code>,
class <code><a href="lavaan.html#topic+lavaan">lavaan</a></code> or matrix. If class <code><a href="#topic+EFA">EFA</a></code> or
class <code><a href="psych.html#topic+fa">psych::fa</a></code>, pattern coefficients and factor
intercorrelations are taken from this object. If class <code><a href="lavaan.html#topic+lavaan">lavaan</a></code>,
it must be a second-order CFA solution. In this case first-order and second-order
factor loadings are taken from this object and the <code>g_name</code> argument has
to be specified.
x can also be a pattern matrix from an oblique factor solution (see <code>Phi</code>)
or a matrix of first-order factor loadings from a higher-order confirmatory factor
analysis (see <code>L2</code>).</p>
</td></tr>
<tr><td><code id="SL_+3A_phi">Phi</code></td>
<td>
<p>matrix. A matrix of factor intercorrelations from an oblique factor
solution. Only needs to be specified if a pattern matrix is entered directly
into <code>x</code>.</p>
</td></tr>
<tr><td><code id="SL_+3A_type">type</code></td>
<td>
<p>character. One of &quot;EFAtools&quot; (default), &quot;psych&quot;, &quot;SPSS&quot;, or &quot;none&quot;.
This is used to control the procedure of the second-order factor analysis. See
<code><a href="#topic+EFA">EFA</a></code> for details.</p>
</td></tr>
<tr><td><code id="SL_+3A_method">method</code></td>
<td>
<p>character. One of &quot;PAF&quot;, &quot;ML&quot;, or &quot;ULS&quot; to use
principal axis factoring, maximum likelihood, or unweighted least squares
(also called minres), respectively, used in <code><a href="#topic+EFA">EFA</a></code> to find the second-order
loadings.</p>
</td></tr>
<tr><td><code id="SL_+3A_g_name">g_name</code></td>
<td>
<p>character. The name of the general factor. This needs only be
specified if <code>x</code> is a <code>lavaan</code> second-order solution. Default is &quot;g&quot;.</p>
</td></tr>
<tr><td><code id="SL_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="#topic+EFA">EFA</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The SL transformation (also called SL orthogonalization) is a procedure with
which an oblique factor solution is transformed into a hierarchical,
orthogonalized solution. As a first step, the factor intercorrelations are
again factor analyzed to find second-order factor loadings. If there is only
one higher-order factor, this step of the procedure stops there, resulting in
a second-order factor structure. The first-order factor and the second-order
factor are then orthogonalized, resulting in an orthogonalized factor solution
with proportionality constraints. The procedure thus makes a suggested
hierarchical data structure based on factor intercorrelations explicit. One
major advantage of SL transformation is that it enables variance
partitioning between higher-order and first-order factors, including the
calculation of McDonald's omegas (see <code><a href="#topic+OMEGA">OMEGA</a></code>).
</p>


<h3>Value</h3>

<p>A list of class SL containing the following
</p>
<table>
<tr><td><code>orig_R</code></td>
<td>
<p>Original correlation matrix.</p>
</td></tr>
<tr><td><code>sl</code></td>
<td>
<p>A matrix with general factor loadings, group factor loadings, communalities,
and uniquenesses.</p>
</td></tr>
<tr><td><code>L2</code></td>
<td>
<p>Second-order factor loadings.</p>
</td></tr>
<tr><td><code>vars_accounted</code></td>
<td>
<p>A matrix of explained variances and sums of squared loadings.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>The number of iterations needed for convergence in EFA.</p>
</td></tr>
<tr><td><code>settings</code></td>
<td>
<p>list. The settings (arguments) used in EFA to get the
second-order loadings.</p>
</td></tr>
</table>


<h3>Source</h3>

<p>Schmid, J. &amp; Leiman, J. M. (1957). The development of hierarchical
factor solutions. Psychometrika, 22(1), 53–61. doi:10.1007/BF02289209
</p>
<p>Wolff, H.-G., &amp; Preising, K. (2005). Exploring item and higher order
factor structure with the Schmid-Leiman solution: Syntax codes for SPSS and
SAS. Behavior Research Methods, 37 , 48–58. doi:10.3758/BF03206397
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Use with an output from the EFAtools::EFA function, both with type EFAtools
EFA_mod &lt;- EFA(test_models$baseline$cormat, N = 500, n_factors = 3,
               type = "EFAtools", method = "PAF", rotation = "promax")
SL_EFAtools &lt;- SL(EFA_mod, type = "EFAtools", method = "PAF")


## Use with an output from the psych::fa function with type psych in SL
fa_mod &lt;- psych::fa(test_models$baseline$cormat, nfactors = 3, n.obs = 500,
                    fm = "pa", rotate = "Promax")
SL_psych &lt;- SL(fa_mod, type = "psych", method = "PAF")


## Use more flexibly by entering a pattern matrix and phi directly (useful if
## a factor solution found with another program should be subjected to SL
## transformation)

## For demonstration, take pattern matrix and phi from an EFA output
## This gives the same solution as the first example
EFA_mod &lt;- EFA(test_models$baseline$cormat, N = 500, n_factors = 3,
               type = "EFAtools", method = "PAF", rotation = "promax")
SL_flex &lt;- SL(EFA_mod$rot_loadings, Phi = EFA_mod$Phi, type = "EFAtools",
              method = "PAF")


## Use with a lavaan second-order CFA output

# Create and fit model in lavaan (assume all variables have SDs of 1)
mod &lt;- 'F1 =~ V1 + V2 + V3 + V4 + V5 + V6
        F2 =~ V7 + V8 + V9 + V10 + V11 + V12
        F3 =~ V13 + V14 + V15 + V16 + V17 + V18
        g =~ F1 + F2 + F3'
fit &lt;- lavaan::cfa(mod, sample.cov = test_models$baseline$cormat,
                   sample.nobs = 500, estimator = "ml")

SL_lav &lt;- SL(fit, g_name = "g")


</code></pre>

<hr>
<h2 id='SMT'>Sequential Chi Square Model Tests, RMSEA lower bound, and AIC</h2><span id='topic+SMT'></span>

<h3>Description</h3>

<p>Sequential Chi Square Model Tests (SMT) are a factor retention method where
multiple
EFAs with increasing numbers of factors are fitted and the number of factors
for which the Chi Square value first becomes non-significant is taken as the
suggested number of factors.
Preacher, Zhang, Kim, &amp; Mels (2013) suggested a similar approach with the
lower bound of the 90% confidence interval of the Root Mean Square Error of
Approximation (RMSEA; Browne &amp; Cudeck, 1992; Steiger &amp; Lind, 1980), and with
the Akaike Information Criterion (AIC). For the RMSEA, the
number of factors for which this lower bound first falls below .05 is the
suggested number of factors to retain. For the AIC, it is the number of factors
where the AIC is lowest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SMT(
  x,
  N = NA,
  use = c("pairwise.complete.obs", "all.obs", "complete.obs", "everything",
    "na.or.complete"),
  cor_method = c("pearson", "spearman", "kendall")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SMT_+3A_x">x</code></td>
<td>
<p>data.frame or matrix. Dataframe or matrix of raw data or matrix with
correlations.</p>
</td></tr>
<tr><td><code id="SMT_+3A_n">N</code></td>
<td>
<p>numeric. The number of observations. Needs only be specified if a
correlation matrix is used.</p>
</td></tr>
<tr><td><code id="SMT_+3A_use">use</code></td>
<td>
<p>character. Passed to <code><a href="stats.html#topic+cor">stats::cor</a></code> if raw
data is given as input. Default is &quot;pairwise.complete.obs&quot;.</p>
</td></tr>
<tr><td><code id="SMT_+3A_cor_method">cor_method</code></td>
<td>
<p>character. Passed to <code><a href="stats.html#topic+cor">stats::cor</a></code>.
Default is &quot;pearson&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As a first step in the procedure, a maximum number of factors to extract is
determined for which the model is still over-identified (df &gt; 0).
</p>
<p>Then, EFAs with increasing numbers of factors from 1 to the maximum number are
fitted with maximum likelihood estimation.
</p>
<p>For the SMT, first the significance of the chi
square value for a model with 0 factors is determined. If this value is
not significant, 0 factors are suggested to retain. If it is significant,
a model with 1 factor is estimated and the significance of its chi square value
is determined, and so on, until a non-significant result is obtained. The
suggested number of factors is the number of factors for the model where the
chi square value first becomes non-significant.
</p>
<p>Regarding the RMSEA, the suggested number of factors is the number of factors
for the model where the lower bound of the 90% confidence interval of the
RMSEA first falls below the .05 threshold.
</p>
<p>Regarding the AIC, the suggested number of factors is the number of factors
for the model with the lowest AIC.
</p>
<p>In comparison with other prominent factor retention criteria, SMT performed
well at determining the number of factors to extract in EFA (Auerswald &amp;
Moshagen, 2019). The RMSEA lower bound also performed well at determining the true
number of factors, while the AIC performed well at determining the
most generalizable model (Preacher, Zhang, Kim, &amp; Mels, 2013).
</p>
<p>The <code>SMT</code> function can also be called together with other factor
retention criteria in the <code><a href="#topic+N_FACTORS">N_FACTORS</a></code> function.
</p>


<h3>Value</h3>

<p>A list of class SMT containing
</p>
<table>
<tr><td><code>nfac_chi</code></td>
<td>
<p>The number of factors to retain according to the significance
of the chi square value.</p>
</td></tr>
<tr><td><code>nfac_RMSEA</code></td>
<td>
<p>The number of factors to retain according to the RMSEA lower
bound</p>
</td></tr>
<tr><td><code>nfac_AIC</code></td>
<td>
<p>The number of factors to retain according to the AIC</p>
</td></tr>
<tr><td><code>p_null</code></td>
<td>
<p>The p-value for the null model (zero factors)</p>
</td></tr>
<tr><td><code>ps_chi</code></td>
<td>
<p>The p-values for EFA models with increasing numbers of factors,
starting with 1 factor</p>
</td></tr>
<tr><td><code>RMSEA_LB_null</code></td>
<td>
<p>The lower bounds of the 90% confidence interval for the RMSEA
for the null model (zero factors).</p>
</td></tr>
<tr><td><code>RMSEA_LBs</code></td>
<td>
<p>The lower bounds of the 90% confidence interval for the RMSEA
for EFA models with increasing numbers of factors, starting with 1 factor</p>
</td></tr>
<tr><td><code>AIC_null</code></td>
<td>
<p>The AICs for the null model (zero factors)</p>
</td></tr>
<tr><td><code>AICs</code></td>
<td>
<p>The AICs for EFA models with increasing numbers of factors,
starting with 1 factor</p>
</td></tr>
</table>


<h3>Source</h3>

<p>Auerswald, M., &amp; Moshagen, M. (2019). How to determine the number of
factors to retain in exploratory factor analysis: A comparison of extraction
methods under realistic conditions. Psychological Methods, 24(4), 468–491.
https://doi.org/10.1037/met0000200
</p>
<p>Browne, M.W., &amp; Cudeck, R. (1992). Alternative ways of assessing model
fit. Sociological Methods and Research, 21, 230–258.
</p>
<p>Preacher, K. J., Zhang G., Kim, C., &amp; Mels, G. (2013). Choosing the
Optimal Number of Factors in Exploratory Factor Analysis: A Model Selection
Perspective, Multivariate Behavioral Research, 48(1), 28-56,
doi:10.108/00273171.2012.710386
</p>
<p>Steiger, J. H., &amp; Lind, J. C. (1980, May). Statistically based tests
for the number of common factors. Paper presented at the annual meeting of
the Psychometric Society, Iowa City, IA.
</p>


<h3>See Also</h3>

<p>Other factor retention criteria: <code><a href="#topic+CD">CD</a></code>, <code><a href="#topic+EKC">EKC</a></code>,
<code><a href="#topic+HULL">HULL</a></code>, <code><a href="#topic+KGC">KGC</a></code>, <code><a href="#topic+PARALLEL">PARALLEL</a></code>
</p>
<p><code><a href="#topic+N_FACTORS">N_FACTORS</a></code> as a wrapper function for this and all the
above-mentioned factor retention criteria.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SMT_base &lt;- SMT(test_models$baseline$cormat, N = 500)
SMT_base

</code></pre>

<hr>
<h2 id='SPSS_23'>Various outputs from SPSS (version 23) FACTOR</h2><span id='topic+SPSS_23'></span>

<h3>Description</h3>

<p>Various outputs from SPSS (version 23) FACTOR for the IDS-2 (Grob &amp; Hagmann-von Arx, 2018), the WJIV (3 to 5 and 20 to 39 years; McGrew, LaForte, &amp; Schrank, 2014), the DOSPERT (Frey et al., 2017; Weber,
Blais, &amp; Betz, 2002), the NEO-PI-R (Costa, &amp; McCrae, 1992), and four simulated datasets (baseline, case_1a, case_6b, and case_11b, see <a href="#topic+test_models">test_models</a> and <a href="#topic+population_models">population_models</a>) used in Grieder and Steiner (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SPSS_23
</code></pre>


<h3>Format</h3>

<p>A list of 9 containing EFA results for each of the data sets mentioned above. Each of these nine entries is a list of 4 or 8 (see details), of the following structure:
</p>

<dl>
<dt>paf_comm</dt><dd><p>(vector) - The final communalities obtained with the FACTOR algorithm with PAF and no rotation. For details, see Grieder and Grob (2019).</p>
</dd>
<dt>paf_load</dt><dd><p>(matrix) - F1 to FN = unrotated factor loadings obtained with the FACTOR algorithm with PAF. Rownames are the abbreviated subtest names.</p>
</dd>
<dt>paf_iter</dt><dd><p>(numeric) - Number of iterations needed for the principal axis factoring to converge.</p>
</dd>
<dt>var_load</dt><dd><p>(matrix) - F1 to FN = varimax rotated factor loadings obtained with the FACTOR algorithm with PAF. Rownames are the abbreviated subtest names.</p>
</dd>
<dt>pro_load</dt><dd><p>(matrix) - F1 to FN = promax rotated factor loadings obtained with the FACTOR algorithm with PAF. Rownames are the abbreviated subtest names.</p>
</dd>
<dt>pro_phi</dt><dd><p>(matrix) - F1 to FN = intercorrelations of the promax rotated loadings.</p>
</dd>
<dt>sl</dt><dd><p>(matrix) - g = General / second order factor of the Schmid-Leiman solution. F1 to FN  = First order factors of the Schmid-Leiman solution. h2 = Communalities of the Schmid-Leiman solution. This Schmid-Leiman solution was found using the SPSS Syntax provided by Wolff and Preising (2005).</p>
</dd>
<dt>L2</dt><dd><p>(matrix) - Second order loadings used for the Schmid-Leiman transformation. This Schmid-Leiman solution was found using the SPSS Syntax provided by Wolff and Preising (2005).</p>
</dd>
</dl>



<h3>Details</h3>

<p>The IDS-2, the two WJIV, the DOSPERT, and the NEO-PI-R contain all the above entries, while the four simulated datasets contain only paf_load, var_load, pro_load, and pro_phi.
</p>


<h3>Source</h3>

<p>Grieder, S., &amp; Steiner, M.D. (2020). Algorithmic Jingle Jungle:
A Comparison of Implementations of Principal Axis Factoring and Promax Rotation
in R and SPSS. Manuscript in Preparation.
</p>
<p>Wolff, H.G., &amp; Preising, K. (2005). Exploring item and higher order factor structure with the Schmid-Leiman solution: Syntax codes for SPSS and SAS. Behavior Research Methods, 37, 48–58. doi: 10.3758/BF03206397
</p>
<p>Grieder, S., &amp; Grob, A. (2019). Exploratory factor analyses of the intelligence and development scales–2: Implications for theory and practice. Assessment. Advance online publication. doi:10.1177/10731911198450
</p>
<p>Grob, A., &amp; Hagmann-von Arx, P. (2018). Intelligence and Development Scales&ndash;2 (IDS-2). Intelligenz- und Entwicklungsskalen für Kinder und Jugendliche.
[Intelligence and Development Scales for Children and Adolescents.]. Bern, Switzerland: Hogrefe.
</p>
<p>Frey, R., Pedroni, A., Mata, R., Rieskamp, J., &amp; Hertwig, R. (2017). Risk preference shares the psychometric structure of major psychological traits. Science Advances, 3, e1701381.
</p>
<p>McGrew, K. S., LaForte, E. M., &amp; Schrank, F. A. (2014). Technical
Manual. Woodcock-Johnson IV. Rolling Meadows, IL: Riverside.
</p>
<p>Schrank, F. A., McGrew, K. S., &amp; Mather, N. (2014). Woodcock-Johnson IV.
Rolling Meadows, IL: Riverside.
</p>
<p>Costa, P. T., &amp; McCrae, R. R. (1992). NEO PI-R professional manual. Odessa, FL: Psychological Assessment Resources, Inc.
</p>

<hr>
<h2 id='SPSS_27'>Various outputs from SPSS (version 27) FACTOR</h2><span id='topic+SPSS_27'></span>

<h3>Description</h3>

<p>Various outputs from SPSS (version 27) FACTOR for the IDS-2 (Grob &amp; Hagmann-von Arx, 2018), the WJIV (3 to 5 and 20 to 39 years; McGrew, LaForte, &amp; Schrank, 2014), the DOSPERT (Frey et al., 2017; Weber,
Blais, &amp; Betz, 2002), the NEO-PI-R (Costa, &amp; McCrae, 1992), and four simulated datasets (baseline, case_1a, case_6b, and case_11b, see <a href="#topic+test_models">test_models</a> and <a href="#topic+population_models">population_models</a>) used in Grieder and Steiner (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SPSS_27
</code></pre>


<h3>Format</h3>

<p>A list of 9 containing EFA results for each of the data sets mentioned above. Each of these nine entries is a list of 4 or 8 (see details), of the following structure:
</p>

<dl>
<dt>paf_comm</dt><dd><p>(vector) - The final communalities obtained with the FACTOR algorithm with PAF and no rotation. For details, see Grieder and Grob (2019).</p>
</dd>
<dt>paf_load</dt><dd><p>(matrix) - F1 to FN = unrotated factor loadings obtained with the FACTOR algorithm with PAF. Rownames are the abbreviated subtest names.</p>
</dd>
<dt>paf_iter</dt><dd><p>(numeric) - Number of iterations needed for the principal axis factoring to converge.</p>
</dd>
<dt>var_load</dt><dd><p>(matrix) - F1 to FN = varimax rotated factor loadings obtained with the FACTOR algorithm with PAF. Rownames are the abbreviated subtest names.</p>
</dd>
<dt>pro_load</dt><dd><p>(matrix) - F1 to FN = promax rotated factor loadings obtained with the FACTOR algorithm with PAF. Rownames are the abbreviated subtest names.</p>
</dd>
<dt>pro_phi</dt><dd><p>(matrix) - F1 to FN = intercorrelations of the promax rotated loadings.</p>
</dd>
<dt>sl</dt><dd><p>(matrix) - g = General / second order factor of the Schmid-Leiman solution. F1 to FN  = First order factors of the Schmid-Leiman solution. h2 = Communalities of the Schmid-Leiman solution. This Schmid-Leiman solution was found using the SPSS Syntax provided by Wolff and Preising (2005).</p>
</dd>
<dt>L2</dt><dd><p>(matrix) - Second order loadings used for the Schmid-Leiman transformation. This Schmid-Leiman solution was found using the SPSS Syntax provided by Wolff and Preising (2005).</p>
</dd>
</dl>



<h3>Details</h3>

<p>The IDS-2, the two WJIV, the DOSPERT, and the NEO-PI-R contain all the above entries, while the four simulated datasets contain only paf_load, var_load, pro_load, and pro_phi.
</p>


<h3>Source</h3>

<p>Grieder, S., &amp; Steiner, M.D. (2020). Algorithmic Jingle Jungle:
A Comparison of Implementations of Principal Axis Factoring and Promax Rotation
in R and SPSS. Manuscript in Preparation.
</p>
<p>Wolff, H.G., &amp; Preising, K. (2005). Exploring item and higher order factor structure with the Schmid-Leiman solution: Syntax codes for SPSS and SAS. Behavior Research Methods, 37, 48–58. doi: 10.3758/BF03206397
</p>
<p>Grieder, S., &amp; Grob, A. (2019). Exploratory factor analyses of the intelligence and development scales–2: Implications for theory and practice. Assessment. Advance online publication. doi:10.1177/10731911198450
</p>
<p>Grob, A., &amp; Hagmann-von Arx, P. (2018). Intelligence and Development Scales&ndash;2 (IDS-2). Intelligenz- und Entwicklungsskalen für Kinder und Jugendliche.
[Intelligence and Development Scales for Children and Adolescents.]. Bern, Switzerland: Hogrefe.
</p>
<p>Frey, R., Pedroni, A., Mata, R., Rieskamp, J., &amp; Hertwig, R. (2017). Risk preference shares the psychometric structure of major psychological traits. Science Advances, 3, e1701381.
</p>
<p>McGrew, K. S., LaForte, E. M., &amp; Schrank, F. A. (2014). Technical
Manual. Woodcock-Johnson IV. Rolling Meadows, IL: Riverside.
</p>
<p>Schrank, F. A., McGrew, K. S., &amp; Mather, N. (2014). Woodcock-Johnson IV.
Rolling Meadows, IL: Riverside.
</p>
<p>Costa, P. T., &amp; McCrae, R. R. (1992). NEO PI-R professional manual. Odessa, FL: Psychological Assessment Resources, Inc.
</p>

<hr>
<h2 id='test_models'>Four test models used in Grieder and Steiner (2020)</h2><span id='topic+test_models'></span>

<h3>Description</h3>

<p>Correlation matrices created from simulated data from four of the
<code><a href="#topic+population_models">population_models</a></code> cases, each with strong factor intercorrelations.
These are used in Grieder &amp; Steiner (2020) to compare the psych and SPSS
implementations in this package with the actual implementations of the programs.
For details on the cases, see <code><a href="#topic+population_models">population_models</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_models
</code></pre>


<h3>Format</h3>

<p>A list of 4 lists &quot;baseline&quot;, &quot;case_1a&quot;, &quot;case_6b&quot;, and&quot;case_11b&quot;, each with the following elements.
</p>

<dl>
<dt>cormat</dt><dd><p>(matrix) - The correlation matrix of the simulated data.</p>
</dd>
<dt>n_factors</dt><dd><p>(numeric) - The true number of factors.</p>
</dd>
<dt>N</dt><dd><p>(numeric) - The sample size of the generated data.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Grieder, S., &amp; Steiner, M.D. (2020). Algorithmic Jingle Jungle:
A Comparison of Implementations of Principal Axis Factoring and Promax Rotation
in R and SPSS. Manuscript in Preparation.
</p>

<hr>
<h2 id='UPPS_raw'>UPPS_raw</h2><span id='topic+UPPS_raw'></span>

<h3>Description</h3>

<p>A dataframe containing responses to the UPPS personality scale (Whiteside &amp;
Lynam, 2005) of 645 participants of Study 2 of Steiner and Frey (2020). Each
column are the ratings to one of 45 items to assess urgency, premeditation,
perseverance, and sensation seeking. The original data can be accessed via
<a href="https://osf.io/kxp8t/">https://osf.io/kxp8t/</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UPPS_raw
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 645 rows and 45 columns.
</p>


<h3>Source</h3>

<p>Whiteside, S. P., Lynam, D. R., Miller, J. D., &amp; Reynolds, S. K. (2005).
Validation of the UPPS impulsive behaviour scale: A four-factor model of
impulsivity. European Journal of Personality, 19 (7), 559–574.
</p>
<p>Steiner, M., &amp; Frey, R. (2020). Representative design in psychological assessment: A case study using the Balloon Analogue Risk Task (BART). PsyArXiv Preprint. doi:10.31234/osf.io/dg4ks
</p>

<hr>
<h2 id='WJIV_ages_14_19'>Woodcock Johnson IV: ages 14 to 19</h2><span id='topic+WJIV_ages_14_19'></span>

<h3>Description</h3>

<p>A list containing the bivariate correlations (N = 1,685) of the 47
cognitive and achievement subtests from the WJ IV for 14- to 19-year-olds
from the standardization sample obtained from
the WJ-IV technical manual (McGrew, LaForte, &amp; Schrank, 2014).
Tables are reproduced with permission from the publisher.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WJIV_ages_14_19
</code></pre>


<h3>Format</h3>

<p>A list of 2 with elements &quot;cormat&quot; (47 x 47 matrix of bivariate correlations)
and &quot;N&quot; (scalar). The correlation matrix contains the following variables:
</p>

<dl>
<dt>ORLVOC</dt><dd><p>(numeric) - Oral Vocabulary.</p>
</dd>
<dt>NUMSER</dt><dd><p>(numeric) - Number Series.</p>
</dd>
<dt>VRBATN</dt><dd><p>(numeric) - Verbal Attention.</p>
</dd>
<dt>LETPAT</dt><dd><p>(numeric) - Letter-Pattern Matching.</p>
</dd>
<dt>PHNPRO</dt><dd><p>(numeric) - Phonological Processing.</p>
</dd>
<dt>STYREC</dt><dd><p>(numeric) - Story Recall.</p>
</dd>
<dt>VISUAL</dt><dd><p>(numeric) - Visualization.</p>
</dd>
<dt>GENINF</dt><dd><p>(numeric) - General Information.</p>
</dd>
<dt>CONFRM</dt><dd><p>(numeric) - Concept Formation.</p>
</dd>
<dt>NUMREV</dt><dd><p>(numeric) - Numbers Reversed.</p>
</dd>
<dt>NUMPAT</dt><dd><p>(numeric) - Number-Pattern Matching.</p>
</dd>
<dt>NWDREP</dt><dd><p>(numeric) - Nonword Repetition.</p>
</dd>
<dt>VAL</dt><dd><p>(numeric) - Visual-Auditory Learning.</p>
</dd>
<dt>PICREC</dt><dd><p>(numeric) - Picture Recognition.</p>
</dd>
<dt>ANLSYN</dt><dd><p>(numeric) - Analysis-Synthesis.</p>
</dd>
<dt>OBJNUM</dt><dd><p>(numeric) - Object-Number Sequencing.</p>
</dd>
<dt>PAIRCN</dt><dd><p>(numeric) - Pair Cancellation.</p>
</dd>
<dt>MEMWRD</dt><dd><p>(numeric) - Memory for Words.</p>
</dd>
<dt>PICVOC</dt><dd><p>(numeric) - Picture Vocabulary.</p>
</dd>
<dt>ORLCMP</dt><dd><p>(numeric) - Oral Comprehension.</p>
</dd>
<dt>SEGMNT</dt><dd><p>(numeric) - Segmentation.</p>
</dd>
<dt>RPCNAM</dt><dd><p>(numeric) - Rapid Picture Naming.</p>
</dd>
<dt>SENREP</dt><dd><p>(numeric) - Sentence Repetition.</p>
</dd>
<dt>UNDDIR</dt><dd><p>(numeric) - Understanding Directions.</p>
</dd>
<dt>SNDBLN</dt><dd><p>(numeric) - Sound Blending.</p>
</dd>
<dt>RETFLU</dt><dd><p>(numeric) - Retrieval Fluency.</p>
</dd>
<dt>SNDAWR</dt><dd><p>(numeric) - Sound Awareness.</p>
</dd>
<dt>LWIDNT</dt><dd><p>(numeric) - Letter-Word Identification.</p>
</dd>
<dt>APPROB</dt><dd><p>(numeric) - Applied Problems.</p>
</dd>
<dt>SPELL</dt><dd><p>(numeric) - Spelling.</p>
</dd>
<dt>PSGCMP</dt><dd><p>(numeric) - Passage Comprehension.</p>
</dd>
<dt>CALC</dt><dd><p>(numeric) - Calculation.</p>
</dd>
<dt>WRTSMP</dt><dd><p>(numeric) - Writing Samples.</p>
</dd>
<dt>WRDATK</dt><dd><p>(numeric) - Word Attack.</p>
</dd>
<dt>ORLRDG</dt><dd><p>(numeric) - Oral Reading.</p>
</dd>
<dt>SNRDFL</dt><dd><p>(numeric) - Sentence Reading Fluency.</p>
</dd>
<dt>MTHFLU</dt><dd><p>(numeric) - Math Facts Fluency.</p>
</dd>
<dt>SNWRFL</dt><dd><p>(numeric) - Sentence Writing Fluency.</p>
</dd>
<dt>RDGREC</dt><dd><p>(numeric) - Reading Recall.</p>
</dd>
<dt>NUMMAT</dt><dd><p>(numeric) - Number Matrices.</p>
</dd>
<dt>EDIT</dt><dd><p>(numeric) - Editing.</p>
</dd>
<dt>WRDFLU</dt><dd><p>(numeric) - Word Reading Fluency.</p>
</dd>
<dt>SPLSND</dt><dd><p>(numeric) - Spelling of Sounds.</p>
</dd>
<dt>RDGVOC</dt><dd><p>(numeric) - Reading Vocabulary.</p>
</dd>
<dt>SCI</dt><dd><p>(numeric) - Science.</p>
</dd>
<dt>SOC</dt><dd><p>(numeric) - Social Studies.</p>
</dd>
<dt>HUM</dt><dd><p>(numeric) - Humanities.</p>
</dd>
</dl>



<h3>Source</h3>

<p>McGrew, K. S., LaForte, E. M., &amp; Schrank, F. A. (2014). Technical
Manual. Woodcock-Johnson IV. Rolling Meadows, IL: Riverside.
</p>
<p>Schrank, F. A., McGrew, K. S., &amp; Mather, N. (2014). Woodcock-Johnson IV.
Rolling Meadows, IL: Riverside.
</p>

<hr>
<h2 id='WJIV_ages_20_39'>Woodcock Johnson IV: ages 20 to 39</h2><span id='topic+WJIV_ages_20_39'></span>

<h3>Description</h3>

<p>A list containing the bivariate correlations (N = 1,251) of the 47
cognitive and achievement subtests from the WJ IV for the 20- to 39-year-olds
from the standardization sample obtained from
the WJ-IV technical manual (McGrew, LaForte, &amp; Schrank, 2014).
Tables are reproduced with permission from the publisher.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WJIV_ages_20_39
</code></pre>


<h3>Format</h3>

<p>A list of 2 with elements &quot;cormat&quot; (47 x 47 matrix of bivariate correlations)
and &quot;N&quot; (scalar). The correlation matrix contains the following variables:
</p>

<dl>
<dt>ORLVOC</dt><dd><p>(numeric) - Oral Vocabulary.</p>
</dd>
<dt>NUMSER</dt><dd><p>(numeric) - Number Series.</p>
</dd>
<dt>VRBATN</dt><dd><p>(numeric) - Verbal Attention.</p>
</dd>
<dt>LETPAT</dt><dd><p>(numeric) - Letter-Pattern Matching.</p>
</dd>
<dt>PHNPRO</dt><dd><p>(numeric) - Phonological Processing.</p>
</dd>
<dt>STYREC</dt><dd><p>(numeric) - Story Recall.</p>
</dd>
<dt>VISUAL</dt><dd><p>(numeric) - Visualization.</p>
</dd>
<dt>GENINF</dt><dd><p>(numeric) - General Information.</p>
</dd>
<dt>CONFRM</dt><dd><p>(numeric) - Concept Formation.</p>
</dd>
<dt>NUMREV</dt><dd><p>(numeric) - Numbers Reversed.</p>
</dd>
<dt>NUMPAT</dt><dd><p>(numeric) - Number-Pattern Matching.</p>
</dd>
<dt>NWDREP</dt><dd><p>(numeric) - Nonword Repetition.</p>
</dd>
<dt>VAL</dt><dd><p>(numeric) - Visual-Auditory Learning.</p>
</dd>
<dt>PICREC</dt><dd><p>(numeric) - Picture Recognition.</p>
</dd>
<dt>ANLSYN</dt><dd><p>(numeric) - Analysis-Synthesis.</p>
</dd>
<dt>OBJNUM</dt><dd><p>(numeric) - Object-Number Sequencing.</p>
</dd>
<dt>PAIRCN</dt><dd><p>(numeric) - Pair Cancellation.</p>
</dd>
<dt>MEMWRD</dt><dd><p>(numeric) - Memory for Words.</p>
</dd>
<dt>PICVOC</dt><dd><p>(numeric) - Picture Vocabulary.</p>
</dd>
<dt>ORLCMP</dt><dd><p>(numeric) - Oral Comprehension.</p>
</dd>
<dt>SEGMNT</dt><dd><p>(numeric) - Segmentation.</p>
</dd>
<dt>RPCNAM</dt><dd><p>(numeric) - Rapid Picture Naming.</p>
</dd>
<dt>SENREP</dt><dd><p>(numeric) - Sentence Repetition.</p>
</dd>
<dt>UNDDIR</dt><dd><p>(numeric) - Understanding Directions.</p>
</dd>
<dt>SNDBLN</dt><dd><p>(numeric) - Sound Blending.</p>
</dd>
<dt>RETFLU</dt><dd><p>(numeric) - Retrieval Fluency.</p>
</dd>
<dt>SNDAWR</dt><dd><p>(numeric) - Sound Awareness.</p>
</dd>
<dt>LWIDNT</dt><dd><p>(numeric) - Letter-Word Identification.</p>
</dd>
<dt>APPROB</dt><dd><p>(numeric) - Applied Problems.</p>
</dd>
<dt>SPELL</dt><dd><p>(numeric) - Spelling.</p>
</dd>
<dt>PSGCMP</dt><dd><p>(numeric) - Passage Comprehension.</p>
</dd>
<dt>CALC</dt><dd><p>(numeric) - Calculation.</p>
</dd>
<dt>WRTSMP</dt><dd><p>(numeric) - Writing Samples.</p>
</dd>
<dt>WRDATK</dt><dd><p>(numeric) - Word Attack.</p>
</dd>
<dt>ORLRDG</dt><dd><p>(numeric) - Oral Reading.</p>
</dd>
<dt>SNRDFL</dt><dd><p>(numeric) - Sentence Reading Fluency.</p>
</dd>
<dt>MTHFLU</dt><dd><p>(numeric) - Math Facts Fluency.</p>
</dd>
<dt>SNWRFL</dt><dd><p>(numeric) - Sentence Writing Fluency.</p>
</dd>
<dt>RDGREC</dt><dd><p>(numeric) - Reading Recall.</p>
</dd>
<dt>NUMMAT</dt><dd><p>(numeric) - Number Matrices.</p>
</dd>
<dt>EDIT</dt><dd><p>(numeric) - Editing.</p>
</dd>
<dt>WRDFLU</dt><dd><p>(numeric) - Word Reading Fluency.</p>
</dd>
<dt>SPLSND</dt><dd><p>(numeric) - Spelling of Sounds.</p>
</dd>
<dt>RDGVOC</dt><dd><p>(numeric) - Reading Vocabulary.</p>
</dd>
<dt>SCI</dt><dd><p>(numeric) - Science.</p>
</dd>
<dt>SOC</dt><dd><p>(numeric) - Social Studies.</p>
</dd>
<dt>HUM</dt><dd><p>(numeric) - Humanities.</p>
</dd>
</dl>



<h3>Source</h3>

<p>McGrew, K. S., LaForte, E. M., &amp; Schrank, F. A. (2014). Technical
Manual. Woodcock-Johnson IV. Rolling Meadows, IL: Riverside.
</p>
<p>Schrank, F. A., McGrew, K. S., &amp; Mather, N. (2014). Woodcock-Johnson IV.
Rolling Meadows, IL: Riverside.
</p>

<hr>
<h2 id='WJIV_ages_3_5'>Woodcock Johnson IV: ages 3 to 5</h2><span id='topic+WJIV_ages_3_5'></span>

<h3>Description</h3>

<p>A list containing the bivariate correlations (N = 435) of the 29
cognitive and achievement subtests from the WJ IV for 3- to 5-year-olds from
the standardization sample obtained from
the WJ IV technical Manual (McGrew, LaForte, &amp; Schrank, 2014).
Tables are reproduced with permission from the publisher.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WJIV_ages_3_5
</code></pre>


<h3>Format</h3>

<p>A list of 2 with elements &quot;cormat&quot; (29 x 29 matrix of bivariate correlations)
and &quot;N&quot; (scalar). The correlation matrix contains the following variables:
</p>

<dl>
<dt>ORLVOC</dt><dd><p>(numeric) - Oral Vocabulary.</p>
</dd>
<dt>VRBATN</dt><dd><p>(numeric) - Verbal Attention.</p>
</dd>
<dt>LETPAT</dt><dd><p>(numeric) - Phonological Processing.</p>
</dd>
<dt>STYREC</dt><dd><p>(numeric) - Story Recall.</p>
</dd>
<dt>VISUAL</dt><dd><p>(numeric) - Visualization.</p>
</dd>
<dt>GENINF</dt><dd><p>(numeric) - General Information.</p>
</dd>
<dt>CONFRM</dt><dd><p>(numeric) - Concept Formation.</p>
</dd>
<dt>NUMREV</dt><dd><p>(numeric) - Numbers Reversed.</p>
</dd>
<dt>NUMPAT</dt><dd><p>(numeric) - Number-Pattern Matching.</p>
</dd>
<dt>NWDREP</dt><dd><p>(numeric) - Nonword Repetition.</p>
</dd>
<dt>VAL</dt><dd><p>(numeric) - Visual-Auditory Learning.</p>
</dd>
<dt>PICREC</dt><dd><p>(numeric) - Picture Recognition.</p>
</dd>
<dt>MEMWRD</dt><dd><p>(numeric) - Memory for Words.</p>
</dd>
<dt>PICVOC</dt><dd><p>(numeric) - Picture Vocabulary.</p>
</dd>
<dt>ORLCMP</dt><dd><p>(numeric) - Oral Comprehension.</p>
</dd>
<dt>SEGMNT</dt><dd><p>(numeric) - Segmentation.</p>
</dd>
<dt>RPCNAM</dt><dd><p>(numeric) - Rapid Picture Naming.</p>
</dd>
<dt>SENREP</dt><dd><p>(numeric) - Sentence Repetition.</p>
</dd>
<dt>UNDDIR</dt><dd><p>(numeric) - Understanding Directions.</p>
</dd>
<dt>SNDBLN</dt><dd><p>(numeric) - Sound Blending.</p>
</dd>
<dt>RETFLU</dt><dd><p>(numeric) - Retrieval Fluency.</p>
</dd>
<dt>SNDAWR</dt><dd><p>(numeric) - Sound Awareness.</p>
</dd>
<dt>LWIDNT</dt><dd><p>(numeric) - Letter-Word Identification.</p>
</dd>
<dt>APPROB</dt><dd><p>(numeric) - Applied Problems.</p>
</dd>
<dt>SPELL</dt><dd><p>(numeric) - Spelling.</p>
</dd>
<dt>PSGCMP</dt><dd><p>(numeric) - Passage Comprehension.</p>
</dd>
<dt>SCI</dt><dd><p>(numeric) - Science.</p>
</dd>
<dt>SOC</dt><dd><p>(numeric) - Social Studies.</p>
</dd>
<dt>HUM</dt><dd><p>(numeric) - Humanities.</p>
</dd>
</dl>



<h3>Source</h3>

<p>McGrew, K. S., LaForte, E. M., &amp; Schrank, F. A. (2014). Technical
Manual. Woodcock-Johnson IV. Rolling Meadows, IL: Riverside.
</p>
<p>Schrank, F. A., McGrew, K. S., &amp; Mather, N. (2014). Woodcock-Johnson IV.
Rolling Meadows, IL: Riverside.
</p>

<hr>
<h2 id='WJIV_ages_40_90'>Woodcock Johnson IV: ages 40 to 90 plus</h2><span id='topic+WJIV_ages_40_90'></span>

<h3>Description</h3>

<p>A list containing the bivariate correlations (N = 1,146) of the 47
cognitive and achievement subtests from the WJ IV for 40- to 90+-year-olds
from the standardization sample obtained from
the WJ-IV technical manual (McGrew, LaForte, &amp; Schrank, 2014).
Tables are reproduced with permission from the publisher.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WJIV_ages_40_90
</code></pre>


<h3>Format</h3>

<p>A list of 2 with elements &quot;cormat&quot; (47 x 47 matrix of bivariate correlations)
and &quot;N&quot;. The correlation matrix contains the following variables:
</p>

<dl>
<dt>ORLVOC</dt><dd><p>(numeric) - Oral Vocabulary.</p>
</dd>
<dt>NUMSER</dt><dd><p>(numeric) - Number Series.</p>
</dd>
<dt>VRBATN</dt><dd><p>(numeric) - Verbal Attention.</p>
</dd>
<dt>LETPAT</dt><dd><p>(numeric) - Letter-Pattern Matching.</p>
</dd>
<dt>PHNPRO</dt><dd><p>(numeric) - Phonological Processing.</p>
</dd>
<dt>STYREC</dt><dd><p>(numeric) - Story Recall.</p>
</dd>
<dt>VISUAL</dt><dd><p>(numeric) - Visualization.</p>
</dd>
<dt>GENINF</dt><dd><p>(numeric) - General Information.</p>
</dd>
<dt>CONFRM</dt><dd><p>(numeric) - Concept Formation.</p>
</dd>
<dt>NUMREV</dt><dd><p>(numeric) - Numbers Reversed.</p>
</dd>
<dt>NUMPAT</dt><dd><p>(numeric) - Number-Pattern Matching.</p>
</dd>
<dt>NWDREP</dt><dd><p>(numeric) - Nonword Repetition.</p>
</dd>
<dt>VAL</dt><dd><p>(numeric) - Visual-Auditory Learning.</p>
</dd>
<dt>PICREC</dt><dd><p>(numeric) - Picture Recognition.</p>
</dd>
<dt>ANLSYN</dt><dd><p>(numeric) - Analysis-Synthesis.</p>
</dd>
<dt>OBJNUM</dt><dd><p>(numeric) - Object-Number Sequencing.</p>
</dd>
<dt>PAIRCN</dt><dd><p>(numeric) - Pair Cancellation.</p>
</dd>
<dt>MEMWRD</dt><dd><p>(numeric) - Memory for Words.</p>
</dd>
<dt>PICVOC</dt><dd><p>(numeric) - Picture Vocabulary.</p>
</dd>
<dt>ORLCMP</dt><dd><p>(numeric) - Oral Comprehension.</p>
</dd>
<dt>SEGMNT</dt><dd><p>(numeric) - Segmentation.</p>
</dd>
<dt>RPCNAM</dt><dd><p>(numeric) - Rapid Picture Naming.</p>
</dd>
<dt>SENREP</dt><dd><p>(numeric) - Sentence Repetition.</p>
</dd>
<dt>UNDDIR</dt><dd><p>(numeric) - Understanding Directions.</p>
</dd>
<dt>SNDBLN</dt><dd><p>(numeric) - Sound Blending.</p>
</dd>
<dt>RETFLU</dt><dd><p>(numeric) - Retrieval Fluency.</p>
</dd>
<dt>SNDAWR</dt><dd><p>(numeric) - Sound Awareness.</p>
</dd>
<dt>LWIDNT</dt><dd><p>(numeric) - Letter-Word Identification.</p>
</dd>
<dt>APPROB</dt><dd><p>(numeric) - Applied Problems.</p>
</dd>
<dt>SPELL</dt><dd><p>(numeric) - Spelling.</p>
</dd>
<dt>PSGCMP</dt><dd><p>(numeric) - Passage Comprehension.</p>
</dd>
<dt>CALC</dt><dd><p>(numeric) - Calculation.</p>
</dd>
<dt>WRTSMP</dt><dd><p>(numeric) - Writing Samples.</p>
</dd>
<dt>WRDATK</dt><dd><p>(numeric) - Word Attack.</p>
</dd>
<dt>ORLRDG</dt><dd><p>(numeric) - Oral Reading.</p>
</dd>
<dt>SNRDFL</dt><dd><p>(numeric) - Sentence Reading Fluency.</p>
</dd>
<dt>MTHFLU</dt><dd><p>(numeric) - Math Facts Fluency.</p>
</dd>
<dt>SNWRFL</dt><dd><p>(numeric) - Sentence Writing Fluency.</p>
</dd>
<dt>RDGREC</dt><dd><p>(numeric) - Reading Recall.</p>
</dd>
<dt>NUMMAT</dt><dd><p>(numeric) - Number Matrices.</p>
</dd>
<dt>EDIT</dt><dd><p>(numeric) - Editing.</p>
</dd>
<dt>WRDFLU</dt><dd><p>(numeric) - Word Reading Fluency.</p>
</dd>
<dt>SPLSND</dt><dd><p>(numeric) - Spelling of Sounds.</p>
</dd>
<dt>RDGVOC</dt><dd><p>(numeric) - Reading Vocabulary.</p>
</dd>
<dt>SCI</dt><dd><p>(numeric) - Science.</p>
</dd>
<dt>SOC</dt><dd><p>(numeric) - Social Studies.</p>
</dd>
<dt>HUM</dt><dd><p>(numeric) - Humanities.</p>
</dd>
</dl>



<h3>Source</h3>

<p>McGrew, K. S., LaForte, E. M., &amp; Schrank, F. A. (2014). Technical
Manual. Woodcock-Johnson IV. Rolling Meadows, IL: Riverside.
</p>
<p>Schrank, F. A., McGrew, K. S., &amp; Mather, N. (2014). Woodcock-Johnson IV.
Rolling Meadows, IL: Riverside.
</p>

<hr>
<h2 id='WJIV_ages_6_8'>Woodcock Johnson IV: ages 6 to 8</h2><span id='topic+WJIV_ages_6_8'></span>

<h3>Description</h3>

<p>A list containing the bivariate correlations (N = 825) of the 47
cognitive and achievement subtests from the WJ IV for 6- to 8-year-olds from
the standardization sample obtained from
the WJ-IV technical manual (McGrew, LaForte, &amp; Schrank, 2014).
Tables are reproduced with permission from the publisher.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WJIV_ages_6_8
</code></pre>


<h3>Format</h3>

<p>A list of 2 with elements &quot;cormat&quot; (47 x 47 matrix of bivariate
correlations) and &quot;N&quot;. The correlation matrix contains the following
variables:
</p>

<dl>
<dt>ORLVOC</dt><dd><p>(numeric) - Oral Vocabulary.</p>
</dd>
<dt>NUMSER</dt><dd><p>(numeric) - Number Series.</p>
</dd>
<dt>VRBATN</dt><dd><p>(numeric) - Verbal Attention.</p>
</dd>
<dt>LETPAT</dt><dd><p>(numeric) - Letter-Pattern Matching.</p>
</dd>
<dt>PHNPRO</dt><dd><p>(numeric) - Phonological Processing.</p>
</dd>
<dt>STYREC</dt><dd><p>(numeric) - Story Recall.</p>
</dd>
<dt>VISUAL</dt><dd><p>(numeric) - Visualization.</p>
</dd>
<dt>GENINF</dt><dd><p>(numeric) - General Information.</p>
</dd>
<dt>CONFRM</dt><dd><p>(numeric) - Concept Formation.</p>
</dd>
<dt>NUMREV</dt><dd><p>(numeric) - Numbers Reversed.</p>
</dd>
<dt>NUMPAT</dt><dd><p>(numeric) - Number-Pattern Matching.</p>
</dd>
<dt>NWDREP</dt><dd><p>(numeric) - Nonword Repetition.</p>
</dd>
<dt>VAL</dt><dd><p>(numeric) - Visual-Auditory Learning.</p>
</dd>
<dt>PICREC</dt><dd><p>(numeric) - Picture Recognition.</p>
</dd>
<dt>ANLSYN</dt><dd><p>(numeric) - Analysis-Synthesis.</p>
</dd>
<dt>OBJNUM</dt><dd><p>(numeric) - Object-Number Sequencing.</p>
</dd>
<dt>PAIRCN</dt><dd><p>(numeric) - Pair Cancellation.</p>
</dd>
<dt>MEMWRD</dt><dd><p>(numeric) - Memory for Words.</p>
</dd>
<dt>PICVOC</dt><dd><p>(numeric) - Picture Vocabulary.</p>
</dd>
<dt>ORLCMP</dt><dd><p>(numeric) - Oral Comprehension.</p>
</dd>
<dt>SEGMNT</dt><dd><p>(numeric) - Segmentation.</p>
</dd>
<dt>RPCNAM</dt><dd><p>(numeric) - Rapid Picture Naming.</p>
</dd>
<dt>SENREP</dt><dd><p>(numeric) - Sentence Repetition.</p>
</dd>
<dt>UNDDIR</dt><dd><p>(numeric) - Understanding Directions.</p>
</dd>
<dt>SNDBLN</dt><dd><p>(numeric) - Sound Blending.</p>
</dd>
<dt>RETFLU</dt><dd><p>(numeric) - Retrieval Fluency.</p>
</dd>
<dt>SNDAWR</dt><dd><p>(numeric) - Sound Awareness.</p>
</dd>
<dt>LWIDNT</dt><dd><p>(numeric) - Letter-Word Identification.</p>
</dd>
<dt>APPROB</dt><dd><p>(numeric) - Applied Problems.</p>
</dd>
<dt>SPELL</dt><dd><p>(numeric) - Spelling.</p>
</dd>
<dt>PSGCMP</dt><dd><p>(numeric) - Passage Comprehension.</p>
</dd>
<dt>CALC</dt><dd><p>(numeric) - Calculation.</p>
</dd>
<dt>WRTSMP</dt><dd><p>(numeric) - Writing Samples.</p>
</dd>
<dt>WRDATK</dt><dd><p>(numeric) - Word Attack.</p>
</dd>
<dt>ORLRDG</dt><dd><p>(numeric) - Oral Reading.</p>
</dd>
<dt>SNRDFL</dt><dd><p>(numeric) - Sentence Reading Fluency.</p>
</dd>
<dt>MTHFLU</dt><dd><p>(numeric) - Math Facts Fluency.</p>
</dd>
<dt>SNWRFL</dt><dd><p>(numeric) - Sentence Writing Fluency.</p>
</dd>
<dt>RDGREC</dt><dd><p>(numeric) - Reading Recall.</p>
</dd>
<dt>NUMMAT</dt><dd><p>(numeric) - Number Matrices.</p>
</dd>
<dt>EDIT</dt><dd><p>(numeric) - Editing.</p>
</dd>
<dt>WRDFLU</dt><dd><p>(numeric) - Word Reading Fluency.</p>
</dd>
<dt>SPLSND</dt><dd><p>(numeric) - Spelling of Sounds.</p>
</dd>
<dt>RDGVOC</dt><dd><p>(numeric) - Reading Vocabulary.</p>
</dd>
<dt>SCI</dt><dd><p>(numeric) - Science.</p>
</dd>
<dt>SOC</dt><dd><p>(numeric) - Social Studies.</p>
</dd>
<dt>HUM</dt><dd><p>(numeric) - Humanities.</p>
</dd>
</dl>



<h3>Source</h3>

<p>McGrew, K. S., LaForte, E. M., &amp; Schrank, F. A. (2014). Technical
Manual. Woodcock-Johnson IV. Rolling Meadows, IL: Riverside.
</p>
<p>Schrank, F. A., McGrew, K. S., &amp; Mather, N. (2014). Woodcock-Johnson IV.
Rolling Meadows, IL: Riverside.
</p>

<hr>
<h2 id='WJIV_ages_9_13'>Woodcock Johnson IV: ages 9 to 13</h2><span id='topic+WJIV_ages_9_13'></span>

<h3>Description</h3>

<p>A list containing the bivariate correlations (N = 1,572) of the 47
cognitive and achievement subtests from the WJ IV for 9- to 13-year-olds from
the standardization sample obtained from
the WJ-IV technical manual (McGrew, LaForte, &amp; Schrank, 2014).
Tables are reproduced with permission from the publisher.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WJIV_ages_9_13
</code></pre>


<h3>Format</h3>

<p>A list of 2 with elements &quot;cormat&quot; (47 x 47 matrix of bivariate
correlations) and &quot;N&quot;. The correlation matrix contains the following variables:
</p>

<dl>
<dt>ORLVOC</dt><dd><p>(numeric) - Oral Vocabulary.</p>
</dd>
<dt>NUMSER</dt><dd><p>(numeric) - Number Series.</p>
</dd>
<dt>VRBATN</dt><dd><p>(numeric) - Verbal Attention.</p>
</dd>
<dt>LETPAT</dt><dd><p>(numeric) - Letter-Pattern Matching.</p>
</dd>
<dt>PHNPRO</dt><dd><p>(numeric) - Phonological Processing.</p>
</dd>
<dt>STYREC</dt><dd><p>(numeric) - Story Recall.</p>
</dd>
<dt>VISUAL</dt><dd><p>(numeric) - Visualization.</p>
</dd>
<dt>GENINF</dt><dd><p>(numeric) - General Information.</p>
</dd>
<dt>CONFRM</dt><dd><p>(numeric) - Concept Formation.</p>
</dd>
<dt>NUMREV</dt><dd><p>(numeric) - Numbers Reversed.</p>
</dd>
<dt>NUMPAT</dt><dd><p>(numeric) - Number-Pattern Matching.</p>
</dd>
<dt>NWDREP</dt><dd><p>(numeric) - Nonword Repetition.</p>
</dd>
<dt>VAL</dt><dd><p>(numeric) - Visual-Auditory Learning.</p>
</dd>
<dt>PICREC</dt><dd><p>(numeric) - Picture Recognition.</p>
</dd>
<dt>ANLSYN</dt><dd><p>(numeric) - Analysis-Synthesis.</p>
</dd>
<dt>OBJNUM</dt><dd><p>(numeric) - Object-Number Sequencing.</p>
</dd>
<dt>PAIRCN</dt><dd><p>(numeric) - Pair Cancellation.</p>
</dd>
<dt>MEMWRD</dt><dd><p>(numeric) - Memory for Words.</p>
</dd>
<dt>PICVOC</dt><dd><p>(numeric) - Picture Vocabulary.</p>
</dd>
<dt>ORLCMP</dt><dd><p>(numeric) - Oral Comprehension.</p>
</dd>
<dt>SEGMNT</dt><dd><p>(numeric) - Segmentation.</p>
</dd>
<dt>RPCNAM</dt><dd><p>(numeric) - Rapid Picture Naming.</p>
</dd>
<dt>SENREP</dt><dd><p>(numeric) - Sentence Repetition.</p>
</dd>
<dt>UNDDIR</dt><dd><p>(numeric) - Understanding Directions.</p>
</dd>
<dt>SNDBLN</dt><dd><p>(numeric) - Sound Blending.</p>
</dd>
<dt>RETFLU</dt><dd><p>(numeric) - Retrieval Fluency.</p>
</dd>
<dt>SNDAWR</dt><dd><p>(numeric) - Sound Awareness.</p>
</dd>
<dt>LWIDNT</dt><dd><p>(numeric) - Letter-Word Identification.</p>
</dd>
<dt>APPROB</dt><dd><p>(numeric) - Applied Problems.</p>
</dd>
<dt>SPELL</dt><dd><p>(numeric) - Spelling.</p>
</dd>
<dt>PSGCMP</dt><dd><p>(numeric) - Passage Comprehension.</p>
</dd>
<dt>CALC</dt><dd><p>(numeric) - Calculation.</p>
</dd>
<dt>WRTSMP</dt><dd><p>(numeric) - Writing Samples.</p>
</dd>
<dt>WRDATK</dt><dd><p>(numeric) - Word Attack.</p>
</dd>
<dt>ORLRDG</dt><dd><p>(numeric) - Oral Reading.</p>
</dd>
<dt>SNRDFL</dt><dd><p>(numeric) - Sentence Reading Fluency.</p>
</dd>
<dt>MTHFLU</dt><dd><p>(numeric) - Math Facts Fluency.</p>
</dd>
<dt>SNWRFL</dt><dd><p>(numeric) - Sentence Writing Fluency.</p>
</dd>
<dt>RDGREC</dt><dd><p>(numeric) - Reading Recall.</p>
</dd>
<dt>NUMMAT</dt><dd><p>(numeric) - Number Matrices.</p>
</dd>
<dt>EDIT</dt><dd><p>(numeric) - Editing.</p>
</dd>
<dt>WRDFLU</dt><dd><p>(numeric) - Word Reading Fluency.</p>
</dd>
<dt>SPLSND</dt><dd><p>(numeric) - Spelling of Sounds.</p>
</dd>
<dt>RDGVOC</dt><dd><p>(numeric) - Reading Vocabulary.</p>
</dd>
<dt>SCI</dt><dd><p>(numeric) - Science.</p>
</dd>
<dt>SOC</dt><dd><p>(numeric) - Social Studies.</p>
</dd>
<dt>HUM</dt><dd><p>(numeric) - Humanities.</p>
</dd>
</dl>



<h3>Source</h3>

<p>McGrew, K. S., LaForte, E. M., &amp; Schrank, F. A. (2014). Technical
Manual. Woodcock-Johnson IV. Rolling Meadows, IL: Riverside.
</p>
<p>Schrank, F. A., McGrew, K. S., &amp; Mather, N. (2014). Woodcock-Johnson IV.
Rolling Meadows, IL: Riverside.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
