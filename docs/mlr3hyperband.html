<!DOCTYPE html><html><head><title>Help for package mlr3hyperband</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mlr3hyperband}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#hyperband_budget'><p>Hyperband Budget</p></a></li>
<li><a href='#hyperband_n_configs'><p>Hyperband Configs</p></a></li>
<li><a href='#hyperband_schedule'><p>Hyperband Schedule</p></a></li>
<li><a href='#mlr_optimizers_hyperband'><p>Optimizer Using the Hyperband Algorithm</p></a></li>
<li><a href='#mlr_optimizers_successive_halving'><p>Hyperparameter Optimization with Successive Halving</p></a></li>
<li><a href='#mlr_tuners_hyperband'><p>Tuner Using the Hyperband Algorithm</p></a></li>
<li><a href='#mlr_tuners_successive_halving'><p>Hyperparameter Tuning with Successive Halving</p></a></li>
<li><a href='#mlr3hyperband-package'><p>mlr3hyperband: Hyperband for 'mlr3'</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Hyperband for 'mlr3'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Successive Halving (Jamieson and Talwalkar (2016)
    &lt;<a href="https://arxiv.org/abs/1502.07943">arXiv:1502.07943</a>&gt;) and Hyperband (Li et al. 2018 &lt;<a href="https://arxiv.org/abs/1603.06560">arXiv:1603.06560</a>&gt;)
    optimization algorithm for the mlr3 ecosystem. The implementation in
    mlr3hyperband features improved scheduling and parallelizes the evaluation
    of configurations. The package includes tuners for hyperparameter
    optimization in mlr3tuning and optimizers for black-box optimization in
    bbotk.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://mlr3hyperband.mlr-org.com">https://mlr3hyperband.mlr-org.com</a>,
<a href="https://github.com/mlr-org/mlr3hyperband">https://github.com/mlr-org/mlr3hyperband</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mlr-org/mlr3hyperband/issues">https://github.com/mlr-org/mlr3hyperband/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>mlr3tuning (&ge; 0.13.0), R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>bbotk (&ge; 0.7.0), checkmate (&ge; 1.9.4), data.table, lgr, mlr3
(&ge; 0.13.1), mlr3misc (&ge; 0.10.0), paradox (&ge; 0.9.0), R6</td>
</tr>
<tr>
<td>Suggests:</td>
<td>emoa, mlr3learners (&ge; 0.5.2), mlr3pipelines, rpart, testthat
(&ge; 3.0.0), xgboost</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Collate:</td>
<td>'aaa.R' 'OptimizerSuccessiveHalving.R' 'OptimizerHyperband.R'
'TunerHyperband.R' 'TunerSuccessiveHalving.R' 'bibentries.R'
'helper.R' 'zzz.R'</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-04 15:45:03 UTC; marc</td>
</tr>
<tr>
<td>Author:</td>
<td>Marc Becker <a href="https://orcid.org/0000-0002-8115-0400"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Sebastian Gruber <a href="https://orcid.org/0000-0002-8544-3470"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Jakob Richter <a href="https://orcid.org/0000-0003-4481-5554"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Julia Moosbauer <a href="https://orcid.org/0000-0002-0000-9297"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Bernd Bischl <a href="https://orcid.org/0000-0001-6002-6980"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marc Becker &lt;marcbecker@posteo.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-05 05:30:19 UTC</td>
</tr>
</table>
<hr>
<h2 id='hyperband_budget'>Hyperband Budget</h2><span id='topic+hyperband_budget'></span>

<h3>Description</h3>

<p>Calculates the total budget used by hyperband.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hyperband_budget(r_min, r_max, eta, integer_budget = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hyperband_budget_+3A_r_min">r_min</code></td>
<td>
<p>(<code>numeric(1)</code>)<br />
Lower bound of budget parameter.</p>
</td></tr>
<tr><td><code id="hyperband_budget_+3A_r_max">r_max</code></td>
<td>
<p>(<code>numeric(1)</code>)<br />
Upper bound of budget parameter.</p>
</td></tr>
<tr><td><code id="hyperband_budget_+3A_eta">eta</code></td>
<td>
<p>(<code>numeric(1)</code>)<br />
Fraction parameter of the successive halving algorithm: With every stage the
configuration budget is increased by a factor of <code>eta</code> and only the best
<code>1/eta</code> points are used for the next stage. Non-integer values are supported,
but <code>eta</code> is not allowed to be less or equal 1.</p>
</td></tr>
<tr><td><code id="hyperband_budget_+3A_integer_budget">integer_budget</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
Determines if budget is an integer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>integer(1)</code>
</p>

<hr>
<h2 id='hyperband_n_configs'>Hyperband Configs</h2><span id='topic+hyperband_n_configs'></span>

<h3>Description</h3>

<p>Calculates how many different configurations are sampled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hyperband_n_configs(r_min, r_max, eta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hyperband_n_configs_+3A_r_min">r_min</code></td>
<td>
<p>(<code>numeric(1)</code>)<br />
Lower bound of budget parameter.</p>
</td></tr>
<tr><td><code id="hyperband_n_configs_+3A_r_max">r_max</code></td>
<td>
<p>(<code>numeric(1)</code>)<br />
Upper bound of budget parameter.</p>
</td></tr>
<tr><td><code id="hyperband_n_configs_+3A_eta">eta</code></td>
<td>
<p>(<code>numeric(1)</code>)<br />
Fraction parameter of the successive halving algorithm: With every stage the
configuration budget is increased by a factor of <code>eta</code> and only the best
<code>1/eta</code> points are used for the next stage. Non-integer values are supported,
but <code>eta</code> is not allowed to be less or equal 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>integer(1)</code>
</p>

<hr>
<h2 id='hyperband_schedule'>Hyperband Schedule</h2><span id='topic+hyperband_schedule'></span>

<h3>Description</h3>

<p>Returns hyperband schedule.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hyperband_schedule(r_min, r_max, eta, integer_budget = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hyperband_schedule_+3A_r_min">r_min</code></td>
<td>
<p>(<code>numeric(1)</code>)<br />
Lower bound of budget parameter.</p>
</td></tr>
<tr><td><code id="hyperband_schedule_+3A_r_max">r_max</code></td>
<td>
<p>(<code>numeric(1)</code>)<br />
Upper bound of budget parameter.</p>
</td></tr>
<tr><td><code id="hyperband_schedule_+3A_eta">eta</code></td>
<td>
<p>(<code>numeric(1)</code>)<br />
Fraction parameter of the successive halving algorithm: With every stage the
configuration budget is increased by a factor of <code>eta</code> and only the best
<code>1/eta</code> points are used for the next stage. Non-integer values are supported,
but <code>eta</code> is not allowed to be less or equal 1.</p>
</td></tr>
<tr><td><code id="hyperband_schedule_+3A_integer_budget">integer_budget</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
Determines if budget is an integer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>
</p>

<hr>
<h2 id='mlr_optimizers_hyperband'>Optimizer Using the Hyperband Algorithm</h2><span id='topic+mlr_optimizers_hyperband'></span><span id='topic+OptimizerHyperband'></span>

<h3>Description</h3>

<p>Optimizer using the Hyperband (HB) algorithm.
HB runs the <a href="#topic+OptimizerSuccessiveHalving">Successive Halving Algorithm</a> (SHA) with different numbers of stating configurations.
The algorithm is initialized with the same parameters as Successive Halving but without <code>n</code>.
Each run of Successive Halving is called a bracket and starts with a different budget <code>r_0</code>.
A smaller starting budget means that more configurations can be tried out.
The most explorative bracket allocated the minimum budget <code>r_min</code>.
The next bracket increases the starting budget by a factor of <code>eta</code>.
In each bracket, the starting budget increases further until the last bracket <code>s = 0</code> essentially performs a random search with the full budget <code>r_max</code>.
The number of brackets <code>s_max + 1</code> is calculated with <code>s_max = log(r_min / r_max)(eta)</code>.
Under the condition that <code>r_0</code> increases by <code>eta</code> with each bracket, <code>r_min</code> sometimes has to be adjusted slightly in order not to use more than <code>r_max</code> resources in the last bracket.
The number of configurations in the base stages is calculated so that each bracket uses approximately the same amount of budget.
The following table shows a full run of HB with <code>eta = 2</code>, <code>r_min = 1</code> and <code>r_max = 8</code>.</p>

<table>
<tr>
 <td style="text-align: right;">
   <code>s</code> </td><td style="text-align: left;">  </td><td style="text-align: right;">  </td><td style="text-align: right;"> 3 </td><td style="text-align: left;">  </td><td style="text-align: right;">  </td><td style="text-align: right;"> 2 </td><td style="text-align: left;">  </td><td style="text-align: right;">  </td><td style="text-align: right;"> 1 </td><td style="text-align: left;">  </td><td style="text-align: right;">  </td><td style="text-align: right;"> 0 </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>i</code> </td><td style="text-align: left;">  </td><td style="text-align: right;"> <code>n_i</code> </td><td style="text-align: right;"> <code>r_i</code> </td><td style="text-align: left;">  </td><td style="text-align: right;"> <code>n_i</code> </td><td style="text-align: right;"> <code>r_i</code> </td><td style="text-align: left;">  </td><td style="text-align: right;"> <code>n_i</code> </td><td style="text-align: right;"> <code>r_i</code> </td><td style="text-align: left;">  </td><td style="text-align: right;"> <code>n_i</code> </td><td style="text-align: right;"> <code>r_i</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   0 </td><td style="text-align: left;">  </td><td style="text-align: right;"> 8 </td><td style="text-align: right;"> 1 </td><td style="text-align: left;">  </td><td style="text-align: right;"> 6 </td><td style="text-align: right;"> 2 </td><td style="text-align: left;">  </td><td style="text-align: right;"> 4 </td><td style="text-align: right;"> 4 </td><td style="text-align: left;">  </td><td style="text-align: right;"> 8 </td><td style="text-align: right;"> 4 </td>
</tr>
<tr>
 <td style="text-align: right;">
   1 </td><td style="text-align: left;">  </td><td style="text-align: right;"> 4 </td><td style="text-align: right;"> 2 </td><td style="text-align: left;">  </td><td style="text-align: right;"> 3 </td><td style="text-align: right;"> 4 </td><td style="text-align: left;">  </td><td style="text-align: right;"> 2 </td><td style="text-align: right;"> 8 </td><td style="text-align: left;">  </td><td style="text-align: right;">  </td><td style="text-align: right;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   2 </td><td style="text-align: left;">  </td><td style="text-align: right;"> 2 </td><td style="text-align: right;"> 4 </td><td style="text-align: left;">  </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 8 </td><td style="text-align: left;">  </td><td style="text-align: right;">  </td><td style="text-align: right;">  </td><td style="text-align: left;">  </td><td style="text-align: right;">  </td><td style="text-align: right;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   3 </td><td style="text-align: left;">  </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 8 </td><td style="text-align: left;">  </td><td style="text-align: right;">  </td><td style="text-align: right;">  </td><td style="text-align: left;">  </td><td style="text-align: right;">  </td><td style="text-align: right;">  </td><td style="text-align: left;">  </td><td style="text-align: right;">  </td><td style="text-align: right;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>

<p><code>s</code> is the bracket number, <code>i</code> is the stage number, <code>n_i</code> is the number of configurations and <code>r_i</code> is the budget allocated to a single configuration.
</p>
<p>The budget hyperparameter must be tagged with <code>"budget"</code> in the search space.
The minimum budget (<code>r_min</code>) which is allocated in the base stage of the most explorative bracket, is set by the lower bound of the budget parameter.
The upper bound defines the maximum budget (<code>r_max</code>) which is allocated to the candidates in the last stages.
</p>


<h3>Resources</h3>

<p>The <a href="https://mlr-org.com/gallery-all-optimization.html">gallery</a> features a collection of case studies and demos about optimization.
</p>

<ul>
<li> <p><a href="https://mlr-org.com/gallery/series/2023-01-15-hyperband-xgboost/">Tune</a> the hyperparameters of XGBoost with Hyperband.
</p>
</li>
<li><p> Use data <a href="https://mlr-org.com/gallery/series/2023-01-16-hyperband-subsampling/">subsampling</a> and Hyperband to optimize a support vector machine.
</p>
</li></ul>



<h3>Dictionary</h3>

<p>This Optimizer can be instantiated via the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
mlr_optimizers or with the associated sugar function <code>opt()</code>:
</p>
<div class="sourceCode"><pre>mlr_optimizers$get("hyperband")
opt("hyperband")
</pre></div>


<h3>Parameters</h3>


<dl>
<dt><code>eta</code></dt><dd><p><code>numeric(1)</code><br />
With every stage, the budget is increased by a factor of <code>eta</code> and only the best <code>1 / eta</code> points are promoted to the next stage.
Non-integer values are supported, but <code>eta</code> is not allowed to be less or equal to 1.</p>
</dd>
<dt><code>sampler</code></dt><dd><p><a href="paradox.html#topic+Sampler">paradox::Sampler</a><br />
Object defining how the samples of the parameter space should be drawn in the base stage of each bracket.
The default is uniform sampling.</p>
</dd>
<dt><code>repetitions</code></dt><dd><p><code>integer(1)</code><br />
If <code>1</code> (default), optimization is stopped once all brackets are evaluated.
Otherwise, optimization is stopped after <code>repetitions</code> runs of HB.
The <a href="bbotk.html#topic+Terminator">bbotk::Terminator</a> might stop the optimization before all repetitions are executed.</p>
</dd>
</dl>



<h3>Archive</h3>

<p>The <a href="bbotk.html#topic+Archive">bbotk::Archive</a> holds the following additional columns that are specific to HB:
</p>

<ul>
<li> <p><code>bracket</code> (<code>integer(1)</code>)<br />
The bracket index. Counts down to 0.
</p>
</li>
<li> <p><code>stage</code> (<code style="white-space: pre;">&#8288;integer(1))&#8288;</code><br />
The stages of each bracket. Starts counting at 0.
</p>
</li>
<li> <p><code>repetition</code> (<code style="white-space: pre;">&#8288;integer(1))&#8288;</code><br />
Repetition index. Start counting at 1.
</p>
</li></ul>



<h3>Custom Sampler</h3>

<p>Hyperband supports custom <a href="paradox.html#topic+Sampler">paradox::Sampler</a> object for initial
configurations in each bracket.
A custom sampler may look like this (the full example is given in the
<em>examples</em> section):
</p>
<div class="sourceCode"><pre># - beta distribution with alpha = 2 and beta = 5
# - categorical distribution with custom probabilities
sampler = SamplerJointIndep$new(list(
  Sampler1DRfun$new(params[[2]], function(n) rbeta(n, 2, 5)),
  Sampler1DCateg$new(params[[3]], prob = c(0.2, 0.3, 0.5))
))
</pre></div>


<h3>Progress Bars</h3>

<p><code style="white-space: pre;">&#8288;$optimize()&#8288;</code> supports progress bars via the package <a href="https://CRAN.R-project.org/package=progressr"><span class="pkg">progressr</span></a>
combined with a Terminator. Simply wrap the function in
<code>progressr::with_progress()</code> to enable them. We recommend to use package
<a href="https://CRAN.R-project.org/package=progress"><span class="pkg">progress</span></a> as backend; enable with <code>progressr::handlers("progress")</code>.
</p>


<h3>Logging</h3>

<p>Hyperband uses a logger (as implemented in <a href="https://CRAN.R-project.org/package=lgr"><span class="pkg">lgr</span></a>) from package
<a href="https://CRAN.R-project.org/package=bbotk"><span class="pkg">bbotk</span></a>.
Use <code>lgr::get_logger("bbotk")</code> to access and control the logger.
</p>


<h3>Super class</h3>

<p><code><a href="bbotk.html#topic+Optimizer">bbotk::Optimizer</a></code> -&gt; <code>OptimizerHyperband</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-OptimizerHyperband-new"><code>OptimizerHyperband$new()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimizerHyperband-clone"><code>OptimizerHyperband$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="format"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-format'><code>bbotk::Optimizer$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="help"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-help'><code>bbotk::Optimizer$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="optimize"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-optimize'><code>bbotk::Optimizer$optimize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="print"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-print'><code>bbotk::Optimizer$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-OptimizerHyperband-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizerHyperband$new()</pre></div>


<hr>
<a id="method-OptimizerHyperband-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizerHyperband$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Source</h3>

<p>Li L, Jamieson K, DeSalvo G, Rostamizadeh A, Talwalkar A (2018).
&ldquo;Hyperband: A Novel Bandit-Based Approach to Hyperparameter Optimization.&rdquo;
<em>Journal of Machine Learning Research</em>, <b>18</b>(185), 1-52.
<a href="https://jmlr.org/papers/v18/16-558.html">https://jmlr.org/papers/v18/16-558.html</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(bbotk)
library(data.table)

# set search space
search_space = domain = ps(
  x1 = p_dbl(-5, 10),
  x2 = p_dbl(0, 15),
  fidelity = p_dbl(1e-2, 1, tags = "budget")
)

# Branin function with fidelity, see `bbotk::branin()`
fun = function(xs) branin_wu(xs[["x1"]], xs[["x2"]], xs[["fidelity"]])

# create objective
objective = ObjectiveRFun$new(
  fun = fun,
  domain = domain,
  codomain = ps(y = p_dbl(tags = "minimize"))
)

# initialize instance and optimizer
instance = OptimInstanceSingleCrit$new(
  objective = objective,
  search_space = search_space,
  terminator = trm("evals", n_evals = 50)
)

optimizer = opt("hyperband")

# optimize branin function
optimizer$optimize(instance)

# best scoring evaluation
instance$result

# all evaluations
as.data.table(instance$archive)
</code></pre>

<hr>
<h2 id='mlr_optimizers_successive_halving'>Hyperparameter Optimization with Successive Halving</h2><span id='topic+mlr_optimizers_successive_halving'></span><span id='topic+OptimizerSuccessiveHalving'></span>

<h3>Description</h3>

<p>Optimizer using the Successive Halving Algorithm (SHA).
SHA is initialized with the number of starting configurations <code>n</code>, the proportion of configurations discarded in each stage <code>eta</code>, and the minimum <code>r_min</code> and maximum <code style="white-space: pre;">&#8288;_max&#8288;</code> budget of a single evaluation.
The algorithm starts by sampling <code>n</code> random configurations and allocating the minimum budget <code>r_min</code> to them.
The configurations are evaluated and <code>1 / eta</code> of the worst-performing configurations are discarded.
The remaining configurations are promoted to the next stage and evaluated on a larger budget.
The following table is the stage layout for <code>eta = 2</code>, <code>r_min = 1</code> and <code>r_max = 8</code>.</p>

<table>
<tr>
 <td style="text-align: right;">
   <code>i</code> </td><td style="text-align: right;"> <code>n_i</code> </td><td style="text-align: right;"> <code>r_i</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   0 </td><td style="text-align: right;"> 8 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: right;">
   1 </td><td style="text-align: right;"> 4 </td><td style="text-align: right;"> 2 </td>
</tr>
<tr>
 <td style="text-align: right;">
   2 </td><td style="text-align: right;"> 2 </td><td style="text-align: right;"> 4 </td>
</tr>
<tr>
 <td style="text-align: right;">
   3 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 8 </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>

<p><code>i</code> is the stage number, <code>n_i</code> is the number of configurations and <code>r_i</code> is the budget allocated to a single configuration.
</p>
<p>The number of stages is calculated so that each stage consumes approximately the same budget.
This sometimes results in the minimum budget having to be slightly adjusted by the algorithm.
</p>


<h3>Resources</h3>

<p>The <a href="https://mlr-org.com/gallery-all-optimization.html">gallery</a> features a collection of case studies and demos about optimization.
</p>

<ul>
<li> <p><a href="https://mlr-org.com/gallery/series/2023-01-15-hyperband-xgboost/">Tune</a> the hyperparameters of XGBoost with Hyperband (Hyperband can be easily swapped with SHA).
</p>
</li>
<li><p> Use data <a href="https://mlr-org.com/gallery/series/2023-01-16-hyperband-subsampling/">subsampling</a> and Hyperband to optimize a support vector machine.
</p>
</li></ul>



<h3>Dictionary</h3>

<p>This Optimizer can be instantiated via the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
mlr_optimizers or with the associated sugar function <code>opt()</code>:
</p>
<div class="sourceCode"><pre>mlr_optimizers$get("successive_halving")
opt("successive_halving")
</pre></div>


<h3>Parameters</h3>


<dl>
<dt><code>n</code></dt><dd><p><code>integer(1)</code><br />
Number of configurations in the base stage.</p>
</dd>
<dt><code>eta</code></dt><dd><p><code>numeric(1)</code><br />
With every stage, the budget is increased by a factor of <code>eta</code> and only the best <code>1 / eta</code> configurations are promoted to the next stage.
Non-integer values are supported, but <code>eta</code> is not allowed to be less or equal to 1.</p>
</dd>
<dt><code>sampler</code></dt><dd><p><a href="paradox.html#topic+Sampler">paradox::Sampler</a><br />
Object defining how the samples of the parameter space should be drawn.
The default is uniform sampling.</p>
</dd>
<dt><code>repetitions</code></dt><dd><p><code>integer(1)</code><br />
If <code>1</code> (default), optimization is stopped once all stages are evaluated.
Otherwise, optimization is stopped after <code>repetitions</code> runs of SHA.
The <a href="bbotk.html#topic+Terminator">bbotk::Terminator</a> might stop the optimization before all repetitions are executed.</p>
</dd>
<dt><code>adjust_minimum_budget</code></dt><dd><p><code>logical(1)</code><br />
If <code>TRUE</code>, the minimum budget is increased so that the last stage uses the maximum budget defined in the search space.</p>
</dd>
</dl>



<h3>Archive</h3>

<p>The <a href="bbotk.html#topic+Archive">bbotk::Archive</a> holds the following additional columns that are specific to SHA:
</p>

<ul>
<li> <p><code>stage</code> (<code style="white-space: pre;">&#8288;integer(1))&#8288;</code><br />
Stage index. Starts counting at 0.
</p>
</li>
<li> <p><code>repetition</code> (<code style="white-space: pre;">&#8288;integer(1))&#8288;</code><br />
Repetition index. Start counting at 1.
</p>
</li></ul>



<h3>Custom Sampler</h3>

<p>Hyperband supports custom <a href="paradox.html#topic+Sampler">paradox::Sampler</a> object for initial
configurations in each bracket.
A custom sampler may look like this (the full example is given in the
<em>examples</em> section):
</p>
<div class="sourceCode"><pre># - beta distribution with alpha = 2 and beta = 5
# - categorical distribution with custom probabilities
sampler = SamplerJointIndep$new(list(
  Sampler1DRfun$new(params[[2]], function(n) rbeta(n, 2, 5)),
  Sampler1DCateg$new(params[[3]], prob = c(0.2, 0.3, 0.5))
))
</pre></div>


<h3>Progress Bars</h3>

<p><code style="white-space: pre;">&#8288;$optimize()&#8288;</code> supports progress bars via the package <a href="https://CRAN.R-project.org/package=progressr"><span class="pkg">progressr</span></a>
combined with a Terminator. Simply wrap the function in
<code>progressr::with_progress()</code> to enable them. We recommend to use package
<a href="https://CRAN.R-project.org/package=progress"><span class="pkg">progress</span></a> as backend; enable with <code>progressr::handlers("progress")</code>.
</p>


<h3>Logging</h3>

<p>Hyperband uses a logger (as implemented in <a href="https://CRAN.R-project.org/package=lgr"><span class="pkg">lgr</span></a>) from package
<a href="https://CRAN.R-project.org/package=bbotk"><span class="pkg">bbotk</span></a>.
Use <code>lgr::get_logger("bbotk")</code> to access and control the logger.
</p>


<h3>Super class</h3>

<p><code><a href="bbotk.html#topic+Optimizer">bbotk::Optimizer</a></code> -&gt; <code>OptimizerSuccessiveHalving</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-OptimizerSuccessiveHalving-new"><code>OptimizerSuccessiveHalving$new()</code></a>
</p>
</li>
<li> <p><a href="#method-OptimizerSuccessiveHalving-clone"><code>OptimizerSuccessiveHalving$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="format"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-format'><code>bbotk::Optimizer$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="help"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-help'><code>bbotk::Optimizer$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="optimize"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-optimize'><code>bbotk::Optimizer$optimize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="bbotk" data-topic="Optimizer" data-id="print"><a href='../../bbotk/html/Optimizer.html#method-Optimizer-print'><code>bbotk::Optimizer$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-OptimizerSuccessiveHalving-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizerSuccessiveHalving$new()</pre></div>


<hr>
<a id="method-OptimizerSuccessiveHalving-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>OptimizerSuccessiveHalving$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Source</h3>

<p>Jamieson K, Talwalkar A (2016).
&ldquo;Non-stochastic Best Arm Identification and Hyperparameter Optimization.&rdquo;
In Gretton A, Robert CC (eds.), <em>Proceedings of the 19th International Conference on Artificial Intelligence and Statistics</em>, volume 51 series Proceedings of Machine Learning Research, 240-248.
<a href="http://proceedings.mlr.press/v51/jamieson16.html">http://proceedings.mlr.press/v51/jamieson16.html</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(bbotk)
library(data.table)

# set search space
search_space = domain = ps(
  x1 = p_dbl(-5, 10),
  x2 = p_dbl(0, 15),
  fidelity = p_dbl(1e-2, 1, tags = "budget")
)

# Branin function with fidelity, see `bbotk::branin()`
fun = function(xs) branin_wu(xs[["x1"]], xs[["x2"]], xs[["fidelity"]])

# create objective
objective = ObjectiveRFun$new(
  fun = fun,
  domain = domain,
  codomain = ps(y = p_dbl(tags = "minimize"))
)

# initialize instance and optimizer
instance = OptimInstanceSingleCrit$new(
  objective = objective,
  search_space = search_space,
  terminator = trm("evals", n_evals = 50)
)

optimizer = opt("successive_halving")

# optimize branin function
optimizer$optimize(instance)

# best scoring evaluation
instance$result

# all evaluations
as.data.table(instance$archive)
</code></pre>

<hr>
<h2 id='mlr_tuners_hyperband'>Tuner Using the Hyperband Algorithm</h2><span id='topic+mlr_tuners_hyperband'></span><span id='topic+TunerHyperband'></span>

<h3>Description</h3>

<p>Optimizer using the Hyperband (HB) algorithm.
HB runs the <a href="#topic+OptimizerSuccessiveHalving">Successive Halving Algorithm</a> (SHA) with different numbers of stating configurations.
The algorithm is initialized with the same parameters as Successive Halving but without <code>n</code>.
Each run of Successive Halving is called a bracket and starts with a different budget <code>r_0</code>.
A smaller starting budget means that more configurations can be tried out.
The most explorative bracket allocated the minimum budget <code>r_min</code>.
The next bracket increases the starting budget by a factor of <code>eta</code>.
In each bracket, the starting budget increases further until the last bracket <code>s = 0</code> essentially performs a random search with the full budget <code>r_max</code>.
The number of brackets <code>s_max + 1</code> is calculated with <code>s_max = log(r_min / r_max)(eta)</code>.
Under the condition that <code>r_0</code> increases by <code>eta</code> with each bracket, <code>r_min</code> sometimes has to be adjusted slightly in order not to use more than <code>r_max</code> resources in the last bracket.
The number of configurations in the base stages is calculated so that each bracket uses approximately the same amount of budget.
The following table shows a full run of HB with <code>eta = 2</code>, <code>r_min = 1</code> and <code>r_max = 8</code>.</p>

<table>
<tr>
 <td style="text-align: right;">
   <code>s</code> </td><td style="text-align: left;">  </td><td style="text-align: right;">  </td><td style="text-align: right;"> 3 </td><td style="text-align: left;">  </td><td style="text-align: right;">  </td><td style="text-align: right;"> 2 </td><td style="text-align: left;">  </td><td style="text-align: right;">  </td><td style="text-align: right;"> 1 </td><td style="text-align: left;">  </td><td style="text-align: right;">  </td><td style="text-align: right;"> 0 </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>i</code> </td><td style="text-align: left;">  </td><td style="text-align: right;"> <code>n_i</code> </td><td style="text-align: right;"> <code>r_i</code> </td><td style="text-align: left;">  </td><td style="text-align: right;"> <code>n_i</code> </td><td style="text-align: right;"> <code>r_i</code> </td><td style="text-align: left;">  </td><td style="text-align: right;"> <code>n_i</code> </td><td style="text-align: right;"> <code>r_i</code> </td><td style="text-align: left;">  </td><td style="text-align: right;"> <code>n_i</code> </td><td style="text-align: right;"> <code>r_i</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   0 </td><td style="text-align: left;">  </td><td style="text-align: right;"> 8 </td><td style="text-align: right;"> 1 </td><td style="text-align: left;">  </td><td style="text-align: right;"> 6 </td><td style="text-align: right;"> 2 </td><td style="text-align: left;">  </td><td style="text-align: right;"> 4 </td><td style="text-align: right;"> 4 </td><td style="text-align: left;">  </td><td style="text-align: right;"> 8 </td><td style="text-align: right;"> 4 </td>
</tr>
<tr>
 <td style="text-align: right;">
   1 </td><td style="text-align: left;">  </td><td style="text-align: right;"> 4 </td><td style="text-align: right;"> 2 </td><td style="text-align: left;">  </td><td style="text-align: right;"> 3 </td><td style="text-align: right;"> 4 </td><td style="text-align: left;">  </td><td style="text-align: right;"> 2 </td><td style="text-align: right;"> 8 </td><td style="text-align: left;">  </td><td style="text-align: right;">  </td><td style="text-align: right;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   2 </td><td style="text-align: left;">  </td><td style="text-align: right;"> 2 </td><td style="text-align: right;"> 4 </td><td style="text-align: left;">  </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 8 </td><td style="text-align: left;">  </td><td style="text-align: right;">  </td><td style="text-align: right;">  </td><td style="text-align: left;">  </td><td style="text-align: right;">  </td><td style="text-align: right;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   3 </td><td style="text-align: left;">  </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 8 </td><td style="text-align: left;">  </td><td style="text-align: right;">  </td><td style="text-align: right;">  </td><td style="text-align: left;">  </td><td style="text-align: right;">  </td><td style="text-align: right;">  </td><td style="text-align: left;">  </td><td style="text-align: right;">  </td><td style="text-align: right;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>

<p><code>s</code> is the bracket number, <code>i</code> is the stage number, <code>n_i</code> is the number of configurations and <code>r_i</code> is the budget allocated to a single configuration.
</p>
<p>The budget hyperparameter must be tagged with <code>"budget"</code> in the search space.
The minimum budget (<code>r_min</code>) which is allocated in the base stage of the most explorative bracket, is set by the lower bound of the budget parameter.
The upper bound defines the maximum budget (<code>r_max</code>) which is allocated to the candidates in the last stages.
</p>


<h3>Dictionary</h3>

<p>This Tuner can be instantiated via the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
mlr_tuners or with the associated sugar function <code><a href="ModelMetrics.html#topic+tnr">tnr()</a></code>:
</p>
<div class="sourceCode"><pre>TunerHyperband$new()
mlr_tuners$get("hyperband")
tnr("hyperband")
</pre></div>


<h3>Subsample Budget</h3>

<p>If the learner lacks a natural budget parameter,
<a href="mlr3pipelines.html#topic+mlr_pipeops_subsample">mlr3pipelines::PipeOpSubsample</a> can be applied to use the subsampling rate
as budget parameter. The resulting <a href="mlr3pipelines.html#topic+mlr_learners_graph">mlr3pipelines::GraphLearner</a> is fitted on
small proportions of the <a href="mlr3.html#topic+Task">mlr3::Task</a> in the first stage, and on the complete
task in last stage.
</p>


<h3>Custom Sampler</h3>

<p>Hyperband supports custom <a href="paradox.html#topic+Sampler">paradox::Sampler</a> object for initial
configurations in each bracket.
A custom sampler may look like this (the full example is given in the
<em>examples</em> section):
</p>
<div class="sourceCode"><pre># - beta distribution with alpha = 2 and beta = 5
# - categorical distribution with custom probabilities
sampler = SamplerJointIndep$new(list(
  Sampler1DRfun$new(params[[2]], function(n) rbeta(n, 2, 5)),
  Sampler1DCateg$new(params[[3]], prob = c(0.2, 0.3, 0.5))
))
</pre></div>


<h3>Progress Bars</h3>

<p><code style="white-space: pre;">&#8288;$optimize()&#8288;</code> supports progress bars via the package <a href="https://CRAN.R-project.org/package=progressr"><span class="pkg">progressr</span></a>
combined with a Terminator. Simply wrap the function in
<code>progressr::with_progress()</code> to enable them. We recommend to use package
<a href="https://CRAN.R-project.org/package=progress"><span class="pkg">progress</span></a> as backend; enable with <code>progressr::handlers("progress")</code>.
</p>


<h3>Parallelization</h3>

<p>This hyperband implementation evaluates hyperparameter configurations of equal budget across brackets in one batch.
For example, all configurations in stage 1 of bracket 3 and stage 0 of bracket 2 in one batch.
To select a parallel backend, use the <code>plan()</code> function of the <a href="https://CRAN.R-project.org/package=future"><span class="pkg">future</span></a> package.
</p>


<h3>Logging</h3>

<p>Hyperband uses a logger (as implemented in <a href="https://CRAN.R-project.org/package=lgr"><span class="pkg">lgr</span></a>) from package
<a href="https://CRAN.R-project.org/package=bbotk"><span class="pkg">bbotk</span></a>.
Use <code>lgr::get_logger("bbotk")</code> to access and control the logger.
</p>


<h3>Resources</h3>

<p>The <a href="https://mlr-org.com/gallery-all-optimization.html">gallery</a> features a collection of case studies and demos about optimization.
</p>

<ul>
<li> <p><a href="https://mlr-org.com/gallery/series/2023-01-15-hyperband-xgboost/">Tune</a> the hyperparameters of XGBoost with Hyperband.
</p>
</li>
<li><p> Use data <a href="https://mlr-org.com/gallery/series/2023-01-16-hyperband-subsampling/">subsampling</a> and Hyperband to optimize a support vector machine.
</p>
</li></ul>



<h3>Parameters</h3>


<dl>
<dt><code>eta</code></dt><dd><p><code>numeric(1)</code><br />
With every stage, the budget is increased by a factor of <code>eta</code> and only the best <code>1 / eta</code> points are promoted to the next stage.
Non-integer values are supported, but <code>eta</code> is not allowed to be less or equal to 1.</p>
</dd>
<dt><code>sampler</code></dt><dd><p><a href="paradox.html#topic+Sampler">paradox::Sampler</a><br />
Object defining how the samples of the parameter space should be drawn in the base stage of each bracket.
The default is uniform sampling.</p>
</dd>
<dt><code>repetitions</code></dt><dd><p><code>integer(1)</code><br />
If <code>1</code> (default), optimization is stopped once all brackets are evaluated.
Otherwise, optimization is stopped after <code>repetitions</code> runs of HB.
The <a href="bbotk.html#topic+Terminator">bbotk::Terminator</a> might stop the optimization before all repetitions are executed.</p>
</dd>
</dl>



<h3>Archive</h3>

<p>The <a href="bbotk.html#topic+Archive">bbotk::Archive</a> holds the following additional columns that are specific to HB:
</p>

<ul>
<li> <p><code>bracket</code> (<code>integer(1)</code>)<br />
The bracket index. Counts down to 0.
</p>
</li>
<li> <p><code>stage</code> (<code style="white-space: pre;">&#8288;integer(1))&#8288;</code><br />
The stages of each bracket. Starts counting at 0.
</p>
</li>
<li> <p><code>repetition</code> (<code style="white-space: pre;">&#8288;integer(1))&#8288;</code><br />
Repetition index. Start counting at 1.
</p>
</li></ul>



<h3>Super classes</h3>

<p><code><a href="mlr3tuning.html#topic+Tuner">mlr3tuning::Tuner</a></code> -&gt; <code><a href="mlr3tuning.html#topic+TunerFromOptimizer">mlr3tuning::TunerFromOptimizer</a></code> -&gt; <code>TunerHyperband</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-TunerHyperband-new"><code>TunerHyperband$new()</code></a>
</p>
</li>
<li> <p><a href="#method-TunerHyperband-clone"><code>TunerHyperband$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3tuning" data-topic="Tuner" data-id="format"><a href='../../mlr3tuning/html/Tuner.html#method-Tuner-format'><code>mlr3tuning::Tuner$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3tuning" data-topic="Tuner" data-id="help"><a href='../../mlr3tuning/html/Tuner.html#method-Tuner-help'><code>mlr3tuning::Tuner$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3tuning" data-topic="Tuner" data-id="print"><a href='../../mlr3tuning/html/Tuner.html#method-Tuner-print'><code>mlr3tuning::Tuner$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3tuning" data-topic="TunerFromOptimizer" data-id="optimize"><a href='../../mlr3tuning/html/TunerFromOptimizer.html#method-TunerFromOptimizer-optimize'><code>mlr3tuning::TunerFromOptimizer$optimize()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-TunerHyperband-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>TunerHyperband$new()</pre></div>


<hr>
<a id="method-TunerHyperband-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>TunerHyperband$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Source</h3>

<p>Li L, Jamieson K, DeSalvo G, Rostamizadeh A, Talwalkar A (2018).
&ldquo;Hyperband: A Novel Bandit-Based Approach to Hyperparameter Optimization.&rdquo;
<em>Journal of Machine Learning Research</em>, <b>18</b>(185), 1-52.
<a href="https://jmlr.org/papers/v18/16-558.html">https://jmlr.org/papers/v18/16-558.html</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("xgboost")) {
  library(mlr3learners)

  # define hyperparameter and budget parameter
  search_space = ps(
    nrounds = p_int(lower = 1, upper = 16, tags = "budget"),
    eta = p_dbl(lower = 0, upper = 1),
    booster = p_fct(levels = c("gbtree", "gblinear", "dart"))
  )

  
  # hyperparameter tuning on the pima indians diabetes data set
  instance = tune(
    tnr("hyperband"),
    task = tsk("pima"),
    learner = lrn("classif.xgboost", eval_metric = "logloss"),
    resampling = rsmp("cv", folds = 3),
    measures = msr("classif.ce"),
    search_space = search_space,
    term_evals = 100
  )

  # best performing hyperparameter configuration
  instance$result
  
}
</code></pre>

<hr>
<h2 id='mlr_tuners_successive_halving'>Hyperparameter Tuning with Successive Halving</h2><span id='topic+mlr_tuners_successive_halving'></span><span id='topic+TunerSuccessiveHalving'></span>

<h3>Description</h3>

<p>Optimizer using the Successive Halving Algorithm (SHA).
SHA is initialized with the number of starting configurations <code>n</code>, the proportion of configurations discarded in each stage <code>eta</code>, and the minimum <code>r_min</code> and maximum <code style="white-space: pre;">&#8288;_max&#8288;</code> budget of a single evaluation.
The algorithm starts by sampling <code>n</code> random configurations and allocating the minimum budget <code>r_min</code> to them.
The configurations are evaluated and <code>1 / eta</code> of the worst-performing configurations are discarded.
The remaining configurations are promoted to the next stage and evaluated on a larger budget.
The following table is the stage layout for <code>eta = 2</code>, <code>r_min = 1</code> and <code>r_max = 8</code>.</p>

<table>
<tr>
 <td style="text-align: right;">
   <code>i</code> </td><td style="text-align: right;"> <code>n_i</code> </td><td style="text-align: right;"> <code>r_i</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   0 </td><td style="text-align: right;"> 8 </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: right;">
   1 </td><td style="text-align: right;"> 4 </td><td style="text-align: right;"> 2 </td>
</tr>
<tr>
 <td style="text-align: right;">
   2 </td><td style="text-align: right;"> 2 </td><td style="text-align: right;"> 4 </td>
</tr>
<tr>
 <td style="text-align: right;">
   3 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 8 </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>

<p><code>i</code> is the stage number, <code>n_i</code> is the number of configurations and <code>r_i</code> is the budget allocated to a single configuration.
</p>
<p>The number of stages is calculated so that each stage consumes approximately the same budget.
This sometimes results in the minimum budget having to be slightly adjusted by the algorithm.
</p>


<h3>Dictionary</h3>

<p>This Tuner can be instantiated via the <a href="mlr3misc.html#topic+Dictionary">dictionary</a>
mlr_tuners or with the associated sugar function <code><a href="ModelMetrics.html#topic+tnr">tnr()</a></code>:
</p>
<div class="sourceCode"><pre>TunerSuccessiveHalving$new()
mlr_tuners$get("successive_halving")
tnr("successive_halving")
</pre></div>


<h3>Subsample Budget</h3>

<p>If the learner lacks a natural budget parameter,
<a href="mlr3pipelines.html#topic+mlr_pipeops_subsample">mlr3pipelines::PipeOpSubsample</a> can be applied to use the subsampling rate
as budget parameter. The resulting <a href="mlr3pipelines.html#topic+mlr_learners_graph">mlr3pipelines::GraphLearner</a> is fitted on
small proportions of the <a href="mlr3.html#topic+Task">mlr3::Task</a> in the first stage, and on the complete
task in last stage.
</p>


<h3>Custom Sampler</h3>

<p>Hyperband supports custom <a href="paradox.html#topic+Sampler">paradox::Sampler</a> object for initial
configurations in each bracket.
A custom sampler may look like this (the full example is given in the
<em>examples</em> section):
</p>
<div class="sourceCode"><pre># - beta distribution with alpha = 2 and beta = 5
# - categorical distribution with custom probabilities
sampler = SamplerJointIndep$new(list(
  Sampler1DRfun$new(params[[2]], function(n) rbeta(n, 2, 5)),
  Sampler1DCateg$new(params[[3]], prob = c(0.2, 0.3, 0.5))
))
</pre></div>


<h3>Progress Bars</h3>

<p><code style="white-space: pre;">&#8288;$optimize()&#8288;</code> supports progress bars via the package <a href="https://CRAN.R-project.org/package=progressr"><span class="pkg">progressr</span></a>
combined with a Terminator. Simply wrap the function in
<code>progressr::with_progress()</code> to enable them. We recommend to use package
<a href="https://CRAN.R-project.org/package=progress"><span class="pkg">progress</span></a> as backend; enable with <code>progressr::handlers("progress")</code>.
</p>


<h3>Parallelization</h3>

<p>The hyperparameter configurations of one stage are evaluated in parallel with the <a href="https://CRAN.R-project.org/package=future"><span class="pkg">future</span></a> package.
To select a parallel backend, use the <code>plan()</code> function of the <a href="https://CRAN.R-project.org/package=future"><span class="pkg">future</span></a> package.
</p>


<h3>Logging</h3>

<p>Hyperband uses a logger (as implemented in <a href="https://CRAN.R-project.org/package=lgr"><span class="pkg">lgr</span></a>) from package
<a href="https://CRAN.R-project.org/package=bbotk"><span class="pkg">bbotk</span></a>.
Use <code>lgr::get_logger("bbotk")</code> to access and control the logger.
</p>


<h3>Resources</h3>

<p>The <a href="https://mlr-org.com/gallery-all-optimization.html">gallery</a> features a collection of case studies and demos about optimization.
</p>

<ul>
<li> <p><a href="https://mlr-org.com/gallery/series/2023-01-15-hyperband-xgboost/">Tune</a> the hyperparameters of XGBoost with Hyperband (Hyperband can be easily swapped with SHA).
</p>
</li>
<li><p> Use data <a href="https://mlr-org.com/gallery/series/2023-01-16-hyperband-subsampling/">subsampling</a> and Hyperband to optimize a support vector machine.
</p>
</li></ul>



<h3>Parameters</h3>


<dl>
<dt><code>n</code></dt><dd><p><code>integer(1)</code><br />
Number of configurations in the base stage.</p>
</dd>
<dt><code>eta</code></dt><dd><p><code>numeric(1)</code><br />
With every stage, the budget is increased by a factor of <code>eta</code> and only the best <code>1 / eta</code> configurations are promoted to the next stage.
Non-integer values are supported, but <code>eta</code> is not allowed to be less or equal to 1.</p>
</dd>
<dt><code>sampler</code></dt><dd><p><a href="paradox.html#topic+Sampler">paradox::Sampler</a><br />
Object defining how the samples of the parameter space should be drawn.
The default is uniform sampling.</p>
</dd>
<dt><code>repetitions</code></dt><dd><p><code>integer(1)</code><br />
If <code>1</code> (default), optimization is stopped once all stages are evaluated.
Otherwise, optimization is stopped after <code>repetitions</code> runs of SHA.
The <a href="bbotk.html#topic+Terminator">bbotk::Terminator</a> might stop the optimization before all repetitions are executed.</p>
</dd>
<dt><code>adjust_minimum_budget</code></dt><dd><p><code>logical(1)</code><br />
If <code>TRUE</code>, the minimum budget is increased so that the last stage uses the maximum budget defined in the search space.</p>
</dd>
</dl>



<h3>Archive</h3>

<p>The <a href="bbotk.html#topic+Archive">bbotk::Archive</a> holds the following additional columns that are specific to SHA:
</p>

<ul>
<li> <p><code>stage</code> (<code style="white-space: pre;">&#8288;integer(1))&#8288;</code><br />
Stage index. Starts counting at 0.
</p>
</li>
<li> <p><code>repetition</code> (<code style="white-space: pre;">&#8288;integer(1))&#8288;</code><br />
Repetition index. Start counting at 1.
</p>
</li></ul>



<h3>Super classes</h3>

<p><code><a href="mlr3tuning.html#topic+Tuner">mlr3tuning::Tuner</a></code> -&gt; <code><a href="mlr3tuning.html#topic+TunerFromOptimizer">mlr3tuning::TunerFromOptimizer</a></code> -&gt; <code>TunerSuccessiveHalving</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-TunerSuccessiveHalving-new"><code>TunerSuccessiveHalving$new()</code></a>
</p>
</li>
<li> <p><a href="#method-TunerSuccessiveHalving-clone"><code>TunerSuccessiveHalving$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3tuning" data-topic="Tuner" data-id="format"><a href='../../mlr3tuning/html/Tuner.html#method-Tuner-format'><code>mlr3tuning::Tuner$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3tuning" data-topic="Tuner" data-id="help"><a href='../../mlr3tuning/html/Tuner.html#method-Tuner-help'><code>mlr3tuning::Tuner$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3tuning" data-topic="Tuner" data-id="print"><a href='../../mlr3tuning/html/Tuner.html#method-Tuner-print'><code>mlr3tuning::Tuner$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3tuning" data-topic="TunerFromOptimizer" data-id="optimize"><a href='../../mlr3tuning/html/TunerFromOptimizer.html#method-TunerFromOptimizer-optimize'><code>mlr3tuning::TunerFromOptimizer$optimize()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-TunerSuccessiveHalving-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a new instance of this <a href="R6.html#topic+R6Class">R6</a> class.
</p>


<h5>Usage</h5>

<div class="r"><pre>TunerSuccessiveHalving$new()</pre></div>


<hr>
<a id="method-TunerSuccessiveHalving-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>TunerSuccessiveHalving$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Source</h3>

<p>Jamieson K, Talwalkar A (2016).
&ldquo;Non-stochastic Best Arm Identification and Hyperparameter Optimization.&rdquo;
In Gretton A, Robert CC (eds.), <em>Proceedings of the 19th International Conference on Artificial Intelligence and Statistics</em>, volume 51 series Proceedings of Machine Learning Research, 240-248.
<a href="http://proceedings.mlr.press/v51/jamieson16.html">http://proceedings.mlr.press/v51/jamieson16.html</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("xgboost")) {
  library(mlr3learners)

  # define hyperparameter and budget parameter
  search_space = ps(
    nrounds = p_int(lower = 1, upper = 16, tags = "budget"),
    eta = p_dbl(lower = 0, upper = 1),
    booster = p_fct(levels = c("gbtree", "gblinear", "dart"))
  )

  
  # hyperparameter tuning on the pima indians diabetes data set
  instance = tune(
    tnr("successive_halving"),
    task = tsk("pima"),
    learner = lrn("classif.xgboost", eval_metric = "logloss"),
    resampling = rsmp("cv", folds = 3),
    measures = msr("classif.ce"),
    search_space = search_space,
    term_evals = 100
  )

  # best performing hyperparameter configuration
  instance$result
  
}
</code></pre>

<hr>
<h2 id='mlr3hyperband-package'>mlr3hyperband: Hyperband for 'mlr3'</h2><span id='topic+mlr3hyperband'></span><span id='topic+mlr3hyperband-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Successive Halving (Jamieson and Talwalkar (2016) <a href="https://arxiv.org/abs/1502.07943">arXiv:1502.07943</a>) and Hyperband (Li et al. 2018 <a href="https://arxiv.org/abs/1603.06560">arXiv:1603.06560</a>) optimization algorithm for the mlr3 ecosystem. The implementation in mlr3hyperband features improved scheduling and parallelizes the evaluation of configurations. The package includes tuners for hyperparameter optimization in mlr3tuning and optimizers for black-box optimization in bbotk.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Marc Becker <a href="mailto:marcbecker@posteo.de">marcbecker@posteo.de</a> (<a href="https://orcid.org/0000-0002-8115-0400">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Sebastian Gruber <a href="mailto:gruber_sebastian@t-online.de">gruber_sebastian@t-online.de</a> (<a href="https://orcid.org/0000-0002-8544-3470">ORCID</a>)
</p>
</li>
<li><p> Jakob Richter <a href="mailto:jakob1richter@gmail.com">jakob1richter@gmail.com</a> (<a href="https://orcid.org/0000-0003-4481-5554">ORCID</a>)
</p>
</li>
<li><p> Julia Moosbauer <a href="mailto:ju.moosbauer@googlemail.com">ju.moosbauer@googlemail.com</a> (<a href="https://orcid.org/0000-0002-0000-9297">ORCID</a>)
</p>
</li>
<li><p> Bernd Bischl <a href="mailto:bernd_bischl@gmx.net">bernd_bischl@gmx.net</a> (<a href="https://orcid.org/0000-0001-6002-6980">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://mlr3hyperband.mlr-org.com">https://mlr3hyperband.mlr-org.com</a>
</p>
</li>
<li> <p><a href="https://github.com/mlr-org/mlr3hyperband">https://github.com/mlr-org/mlr3hyperband</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/mlr-org/mlr3hyperband/issues">https://github.com/mlr-org/mlr3hyperband/issues</a>
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
