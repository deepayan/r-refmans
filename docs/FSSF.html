<!DOCTYPE html><html><head><title>Help for package FSSF</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {FSSF}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#FSSF-package'><p>Large-Scale Fully-Sequential Space-filling Algorithms for Computer Experiments</p></a></li>
<li><a href='#fssf_b'><p>Generate fully-sequential maximin designs inside a unit hypercube.</p></a></li>
<li><a href='#fssf_f'><p>Generate fully-sequential maximin designs inside a unit hypercube.</p></a></li>
<li><a href='#fssf_fr'><p>Generate fully-sequential minimax designs inside a unit hypercube using a heuristic.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Generate Fully-Sequential Space-Filling Designs Inside a Unit
Hypercube</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-02-03</td>
</tr>
<tr>
<td>Author:</td>
<td>Boyang Shang and Daniel W. Apley</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Boyang Shang &lt;boyangshang2015@u.northwestern.edu&gt;</td>
</tr>
<tr>
<td>Copyright:</td>
<td>ANN library is copyright University of Maryland and Sunil
Arya and David Mount. See file COPYRIGHTS for details.</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides three methods proposed by Shang and Apley (2019) &lt;<a href="https://doi.org/10.1080%2F00224065.2019.1705207">doi:10.1080/00224065.2019.1705207</a>&gt; to generate fully-sequential space-filling designs inside a unit hypercube. A 'fully-sequential space-filling design' means a sequence of nested designs (as the design size varies from one point up to some maximum number of points) with the design points added one at a time and such that the design at each size has good space-filling properties. Two methods target the minimum pairwise distance criterion and generate maximin designs, among which one method is more efficient when design size is large. One method targets the maximum hole size criterion and uses a heuristic to generate what is closer to a minimax design. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.10)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-02-04 02:59:58 UTC; boyangshang</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-02-05 12:10:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='FSSF-package'>Large-Scale Fully-Sequential Space-filling Algorithms for Computer Experiments</h2><span id='topic+FSSF'></span><span id='topic+FSSF-package'></span>

<h3>Description</h3>

<p>Provides large-scale computer experimental design tools to generate fully-sequential (a nested sequence of designs with points added one at a time) space-filling designs inside a unit hypercube (Shang and Apley, 2019).
</p>


<h3>Details</h3>

<p>Fully-sequential (i.e., with design points added one at a time) space-filling designs are useful for global surrogate modeling of expensive computer experiments when the number of design points required to achieve a suitable accuracy is unknown in advance. We provide three fully-sequential space-filling (FSSF) design algorithms that are conceptually simple and computationally efficient and that achieve much better space-filling properties than alternative methods such as Sobol sequences and more complex batch-sequential methods based on sliced or nested optimal Latin hypercube designs (LHDs). 
</p>
<p>Brief descriptions of the main functions are provided below:
</p>
<p><code>fssf_f()</code> generates maximin designs using a similar idea with Kennard and Stone (1969). The &quot;f&quot; stands for &quot;forward&quot;, since the algorithm begins with the smallest design and adds points one at a time.
</p>
<p><code>fssf-b()</code> generates large-size maximin designs efficiently. The &quot;b&quot; stands for &quot;backward&quot;, since the algorithm begins with the largest design and removes points one at a time.
</p>
<p><code>fssf-fr()</code> uses a heuristic to generate what is closer to a minimax design. The &quot;fr&quot; stands for &quot;forward reflected&quot;, since the algorithm uses a modification of the criterion used in the fssf-f algorithm. 
</p>


<h3>Author(s)</h3>

<p>Boyang Shang <a href="mailto:boyangshang2015@u.northwestern.edu">boyangshang2015@u.northwestern.edu</a> <br /> Daniel W. Apley <a href="mailto:apley@northwestern.edu">apley@northwestern.edu</a></p>


<h3>References</h3>

<p>Shang, B. and Apley, D.W. (2019), &quot;Large-Scale Fully-Sequential Space-filling Algorithms for Computer Experiments&quot;, Journal of Quality Technology (in press). doi:10.1080/00224065.2019.1705207. 
</p>
<p>Kennard, R.W. and Stone, L.A. (1969). &quot;Computer aided design of experiments&quot;. Technometrics 11.1, pp. 137-148.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# See the examples in the help pages for the main functions mentioned above.
#
</code></pre>

<hr>
<h2 id='fssf_b'>Generate fully-sequential maximin designs inside a unit hypercube.</h2><span id='topic+fssf_b'></span>

<h3>Description</h3>

<p>Produces a random fully-sequential design (a nested sequence of designs with points added one at a time) inside a unit hypercube such that the design points are as far away from each other as possible (Shang and Apley, 2019). The &quot;b&quot; stands for &quot;backward&quot;, since the algorithm begins with the largest design and removes points one at a time. <code>fssf_b</code> is much faster than <code>fssf_f</code> when the design size is large.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	fssf_b(d, nMax, N=-1, eps=0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fssf_b_+3A_d">d</code></td>
<td>

<p>The dimension of the design space.
</p>
</td></tr>
<tr><td><code id="fssf_b_+3A_nmax">nMax</code></td>
<td>

<p>The largest design size required by the user.
</p>
</td></tr>
<tr><td><code id="fssf_b_+3A_n">N</code></td>
<td>

<p>Size of the candidate set used to generate the design points. -1 corresponds to the default setting, and the candidate set size will be calculated as  <code class="reqn">1000 \times d + 2 \times nMax</code>. Using large <code>N</code> will make the design more space-filling, but will slow down the program.
</p>
</td></tr>
<tr><td><code id="fssf_b_+3A_eps">eps</code></td>
<td>

<p>The error bound for approximate nearest neighbor searching. Default value is 0.5 and <code>eps</code> must be greater or equal to 0. Using large <code>eps</code> will make the program run faster, but will cause worse space-filling performances. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>fssf_b</code> function calls portions of the Approximate Nearest Neighbor Library, version 1.1.2,  written by David M. Mount and Sunil Arya to do the neareast neighbor search. Some changes have been made to the original ANN library to suit the needs of the <code>fssf_b</code> function. More information about the ANN library can be found in the ANN Programming Manual at <a href="http://www.cs.umd.edu/~mount/ANN">http://www.cs.umd.edu/~mount/ANN</a>
</p>


<h3>Value</h3>

<p>A <code class="reqn">nMax \times d</code> matrix with the <code class="reqn">i^{th}</code> row corresponding to the <code class="reqn">i^{th}</code> design point.
</p>


<h3>Author(s)</h3>

<p>Boyang Shang <a href="mailto:boyangshang2015@u.northwestern.edu">boyangshang2015@u.northwestern.edu</a> <br /> Daniel W. Apley <a href="mailto:apley@northwestern.edu">apley@northwestern.edu</a></p>


<h3>References</h3>

<p>Shang, B. and Apley, D.W. (2019), &quot;Large-Scale Fully-Sequential Space-filling Algorithms for Computer Experiments&quot;, Journal of Quality Technology (in press). doi:10.1080/00224065.2019.1705207.
</p>
<p>Kennard, R.W. and Stone, L.A. (1969). &quot;Computer aided design of experiments&quot;. Technometrics 11.1, pp. 137-148.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Generate a design using the fssf_b function.
Design &lt;- fssf_b(d=2, nMax = 320)
plot(Design[,1], Design[,2])
</code></pre>

<hr>
<h2 id='fssf_f'>Generate fully-sequential maximin designs inside a unit hypercube.</h2><span id='topic+fssf_f'></span>

<h3>Description</h3>

<p>Produces a random fully-sequential design (a nested sequence of designs with points added one at a time) inside a unit hypercube such that the design points are as far away from each other as possible (Shang and Apley, 2019). The &quot;f&quot; stands for &quot;forward&quot;, since the algorithm begins with the smallest design and adds points one at a time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	fssf_f(d, nMax, N=-1, ScaleVector = NULL, Dinit = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fssf_f_+3A_d">d</code></td>
<td>

<p>The dimension of the design space.
</p>
</td></tr>
<tr><td><code id="fssf_f_+3A_nmax">nMax</code></td>
<td>

<p>The largest design size required by the user.
</p>
</td></tr>
<tr><td><code id="fssf_f_+3A_n">N</code></td>
<td>

<p>Size of the candidate set used to generate the design points. -1 corresponds to the default setting, and the candidate set size will be calculated as  <code class="reqn">1000 \times d + 2 \times nMax</code>. Using large <code>N</code> will make the design more space-filling, but will slow down the program.
</p>
</td></tr>
<tr><td><code id="fssf_f_+3A_scalevector">ScaleVector</code></td>
<td>
<p>Array of the lengthscale parameters of different inputs. Default is NULL, which corresponds to the <code>ScaleVector</code> being a unit vector of length <code>d</code>. When <code>ScaleVector</code> is not NULL, for instance, <code>ScaleVector</code> is <code class="reqn">(\theta_1, \cdots, \theta_d)</code>, the distance between point <code class="reqn">(x_1, \cdots, x_d)</code> and point <code class="reqn">(y_1, \cdots, y_d)</code> will be computed as <code class="reqn">\sum_{j=1}^{d} {\Big( \frac{y_j - x_j}{\theta_j} \Big)}^2</code></p>
</td></tr>  
<tr><td><code id="fssf_f_+3A_dinit">Dinit</code></td>
<td>
<p>Numerical Matrix with <code class="reqn">n_{init}</code> rows and <code>d</code> columns, where <code class="reqn">n_{init}</code> is a user-specified parameter. This is an optional initial design with size <code class="reqn">n_{init}</code> provided by the user. Default is NULL, which corresponds to no initial design. If <code>Dinit</code> is not NULL, then the algorithm will select <code>nMax</code> additional design points taking into account of this initial design.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>fssf_f</code> uses a similar idea as proposed by Kennard and Stone(1969); modifications have been made to improve the space-filling performance as well as efficiency.
</p>


<h3>Value</h3>

<p>A <code class="reqn">nMax \times d</code> matrix with the <code class="reqn">i^{th}</code> row corresponding to the <code class="reqn">i^{th}</code> design point.
</p>


<h3>Author(s)</h3>

<p>Boyang Shang <a href="mailto:boyangshang2015@u.northwestern.edu">boyangshang2015@u.northwestern.edu</a> <br /> Daniel W. Apley <a href="mailto:apley@northwestern.edu">apley@northwestern.edu</a></p>


<h3>References</h3>

<p>Shang, B. and Apley, D.W. (2019), &quot;Large-Scale Fully-Sequential Space-filling Algorithms for Computer Experiments&quot;, Journal of Quality Technology (in press). doi:10.1080/00224065.2019.1705207. 
</p>
<p>Kennard, R.W. and Stone, L.A. (1969). &quot;Computer aided design of experiments&quot;. Technometrics 11.1, pp. 137-148.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Generate a design using the fssf_f function with no scaling vector and no initial design.
Design &lt;- fssf_f(d=2, nMax = 320)
plot(Design[,1], Design[,2])

##Generate a design using the fssf_f function with scaling vector and no initial design.
d = 2
n = 100
ScaleVector = c(1.0, 20.0)*0.5
Design = fssf_f(d = d, nMax = n, ScaleVector = ScaleVector)
plot(Design[,1], Design[,2])

##Generate a design using the fssf_f function with a scaling vector and with an initial design
d = 2
n = 100
Dinit =  fssf_f(d=2, nMax = 40)
ScaleVector = c(1.0, 20.0)*0.5
Design = fssf_f(d = d, nMax = n, ScaleVector = ScaleVector, Dinit = Dinit)
plot(Design[,1], Design[,2])
points(Dinit[,1], Dinit[,2], col="red")
</code></pre>

<hr>
<h2 id='fssf_fr'>Generate fully-sequential minimax designs inside a unit hypercube using a heuristic.</h2><span id='topic+fssf_fr'></span>

<h3>Description</h3>

<p>Produces a random fully-sequential design (a nested sequence of designs with points added one at a time) inside a unit hypercube such that the largest distance between any point inside the unit hypercube to its closest design point is as small as possible (Shang and Apley, 2019). The 
&quot;fr&quot; stands for &quot;forward reflected&quot;, since the algorithm uses a modification of the criterion used in the fssf-f algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	fssf_fr(d, nMax, N=-1, Preference = "minimax", ScaleVector = NULL, Dinit = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fssf_fr_+3A_d">d</code></td>
<td>

<p>The dimension of the design space.
</p>
</td></tr>
<tr><td><code id="fssf_fr_+3A_nmax">nMax</code></td>
<td>

<p>The largest design size required by the user.
</p>
</td></tr>
<tr><td><code id="fssf_fr_+3A_n">N</code></td>
<td>

<p>Size of the candidate set used to generate the design points. -1 corresponds to the default setting, and the candidate set size will be calculated as  <code class="reqn">1000 \times d + 2 \times nMax</code>. Using large <code>N</code> will make the design more space-filling, but will slow down the program.
</p>
</td></tr>
<tr><td><code id="fssf_fr_+3A_preference">Preference</code></td>
<td>

<p>Choosing <code>Preference</code> as &quot;minimax&quot; will produce a design that leaves small holes in the design space, especially for the early design points, with the cost that design points may be closer to each other than the other option. Choosing <code>Preference</code> as &quot;maximin&quot; will produce a design that leaves a little larger holes than the other option, but the design points will be further away from each other. 
</p>
</td></tr>
<tr><td><code id="fssf_fr_+3A_scalevector">ScaleVector</code></td>
<td>
<p>Array of the lengthscale parameters of different inputs. Default is NULL, which corresponds to the <code>ScaleVector</code> being a unit vector of length <code>d</code>. When <code>ScaleVector</code> is not NULL, for instance, <code>ScaleVector</code> is <code class="reqn">(\theta_1, \cdots, \theta_d)</code>, the distance between point <code class="reqn">(x_1, \cdots, x_d)</code> and point <code class="reqn">(y_1, \cdots, y_d)</code> will be computed as <code class="reqn">\sum_{j=1}^{d} {\Big( \frac{y_j - x_j}{\theta_j} \Big)}^2</code></p>
</td></tr>
<tr><td><code id="fssf_fr_+3A_dinit">Dinit</code></td>
<td>
<p>Numerical Matrix with <code class="reqn">n_{init}</code> rows and <code>d</code> columns, where <code class="reqn">n_{init}</code> is a user-specified parameter. This is an optional initial design with size <code class="reqn">n_{init}</code> provided by the user. Default is NULL, which corresponds to no initial design. If <code>Dinit</code> is not NULL, then the algorithm will select <code>nMax</code> additional design points taking into account of this initial design.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code class="reqn">nMax \times d</code> matrix with the <code class="reqn">i^{th}</code> row corresponding to the <code class="reqn">i^{th}</code> design point.
</p>


<h3>Author(s)</h3>

<p>Boyang Shang <a href="mailto:boyangshang2015@u.northwestern.edu">boyangshang2015@u.northwestern.edu</a> <br /> Daniel W. Apley <a href="mailto:apley@northwestern.edu">apley@northwestern.edu</a></p>


<h3>References</h3>

<p>Shang, B. and Apley, D.W. (2019), &quot;Large-Scale Fully-Sequential Space-filling Algorithms for Computer Experiments&quot;, Journal of Quality Technology (in press). doi:10.1080/00224065.2019.1705207. 
</p>
<p>Kennard, R.W. and Stone, L.A. (1969). &quot;Computer aided design of experiments&quot;. Technometrics 11.1, pp. 137-148.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Generate a design using the fssf_fr function.
Design &lt;- fssf_fr(d=2, nMax = 320)
plot(Design[,1], Design[,2]) 


##Generate a design using the fssf_fr function with scaling vector and no initial design.
d = 2
n = 100
ScaleVector = c(1.0, 20.0)*0.5
Design = fssf_fr(d = d, nMax = n, ScaleVector = ScaleVector)
plot(Design[,1], Design[,2])

##Generate a design using the fssf_fr function with a scaling vector and with an initial design
d = 2
n = 100
Dinit =  fssf_fr(d=2, nMax = 40)
ScaleVector = c(1.0, 20.0)*0.5
Design = fssf_fr(d = d, nMax = n, ScaleVector = ScaleVector, Dinit = Dinit)
plot(Design[,1], Design[,2])
points(Dinit[,1], Dinit[,2], col="red")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
