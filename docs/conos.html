<!DOCTYPE html><html><head><title>Help for package conos</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {conos}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#armaCor'><p>A slightly faster way of calculating column correlation matrix</p></a></li>
<li><a href='#basicSeuratProc'><p>Create and preprocess a Seurat object</p></a></li>
<li><a href='#bestClusterThresholds'><p>Find threshold of cluster detectability</p></a></li>
<li><a href='#bestClusterTreeThresholds'><p>Find threshold of cluster detectability in trees of clusters</p></a></li>
<li><a href='#buildWijMatrix'><p>Rescale the weights in an edge matrix to match a given perplexity.</p></a></li>
<li><a href='#checkCountsWholeNumbers'><p>Check that the count data contain only integer counts</p></a></li>
<li><a href='#Conos'><p>Conos R6 class</p></a></li>
<li><a href='#convertToPagoda2'><p>Convert Conos object to Pagoda2 object</p></a></li>
<li><a href='#edgeMat&lt;-'><p>Set edge matrix edgeMat with certain values on sample</p></a></li>
<li><a href='#estimateWeightEntropyPerCell'><p>Estimate entropy of edge weights per cell according to the specified factor.</p>
Can be used to visualize alignment quality according to this factor.</a></li>
<li><a href='#filter.genes.by.cluster.expression'><p>Filter genes by requiring minimum average expression within at least one of the provided cell clusters</p></a></li>
<li><a href='#findSubcommunities'><p>Increase resolution for a specific set of clusters</p></a></li>
<li><a href='#getBetweenCellTypeCorrectedDE'><p>Compare two cell types across the entire panel</p></a></li>
<li><a href='#getBetweenCellTypeDE'><p>Compare two cell types across the entire panel</p></a></li>
<li><a href='#getCellNames'><p>Access cell names from sample</p></a></li>
<li><a href='#getClustering'><p>Access clustering from sample</p></a></li>
<li><a href='#getClusteringGroups'><p>Extract specified clustering from list of conos clusterings</p></a></li>
<li><a href='#getClusterRelationshipConsistency'><p>Evaluate consistency of cluster relationships</p>
Using the clustering we are generating per-sample dendrograms
and we are examining their similarity between different samples
More information about similarity measures
&lt;https://www.rdocumentation.org/packages/dendextend/versions/1.8.0/topics/cor_cophenetic&gt;
&lt;https://www.rdocumentation.org/packages/dendextend/versions/1.8.0/topics/cor_bakers_gamma&gt;</a></li>
<li><a href='#getCountMatrix'><p>Access count matrix from sample</p></a></li>
<li><a href='#getEmbedding'><p>Access embedding from sample</p></a></li>
<li><a href='#getGeneExpression'><p>Access gene expression from sample</p></a></li>
<li><a href='#getGenes'><p>Access genes from sample</p></a></li>
<li><a href='#getGlobalClusterMarkers'><p>Deprecated; Get markers for global clusters</p></a></li>
<li><a href='#getNeighborMatrix'><p>Establish rough neighbor matching between samples given their projections in a common space</p></a></li>
<li><a href='#getOdGenesUniformly'><p>Get top overdispersed genes across samples</p></a></li>
<li><a href='#getOverdispersedGenes'><p>Access overdispersed genes from sample</p></a></li>
<li><a href='#getPca'><p>Access PCA from sample</p></a></li>
<li><a href='#getPerCellTypeDE'><p>Do differential expression for each cell type in a conos object between the specified subsets of apps</p></a></li>
<li><a href='#getPercentGlobalClusters'><p>Evaluate how many clusters are global</p></a></li>
<li><a href='#getRawCountMatrix'><p>Access raw count matrix from sample</p></a></li>
<li><a href='#getSampleNamePerCell'><p>Retrieve sample names per cell</p></a></li>
<li><a href='#greedyModularityCut'><p>Performs a greedy top-down selective cut to optmize modularity</p></a></li>
<li><a href='#multimulti.community'><p>Constructrs a two-step clustering, first running multilevel.communities, and then walktrap.communities within each</p>
These are combined into an overall hierarchy</a></li>
<li><a href='#multitrap.community'><p>Constructs a two-step clustering, first running multilevel.communities, and then walktrap.communities within each</p>
These are combined into an overall hierarchy</a></li>
<li><a href='#namedLevels'><p>Get a vector with the levels of a factor named with their</p>
own name. Useful for lapply loops over factor levels</a></li>
<li><a href='#namedNames'><p>Get a vector of the names of an object named by the names themselves.</p>
This is useful with lapply when passing names of objects as it ensures that the output list
is also named</a></li>
<li><a href='#p2app4conos'><p>Utility function to generate a pagoda2 app from a conos object</p></a></li>
<li><a href='#plotClusterBarplots'><p>Plots barplots per sample of composition of each pagoda2 application based on</p>
selected clustering</a></li>
<li><a href='#plotClusterBoxPlotsByAppType'><p>Generate boxplot per cluster of the proportion of cells in each celltype</p></a></li>
<li><a href='#plotComponentVariance'><p>Plot fraction of variance explained by the successive reduced space components (PCA, CPCA)</p></a></li>
<li><a href='#plotDEheatmap'><p>Plot a heatmap of differential genes</p></a></li>
<li><a href='#plotEmbeddings'><p>Plot panel of specified embeddings</p></a></li>
<li><a href='#plotSamples'><p>Plot panel of specified embeddings, extracting them from pagoda2 objects</p></a></li>
<li><a href='#projectKNNs'><p>Project a distance matrix into a lower-dimensional space.</p></a></li>
<li><a href='#propagateLabelsDiffusion'><p>Estimate labeling distribution for each vertex, based on provided labels using Random Walk</p></a></li>
<li><a href='#quickCCA'><p>Perform CCA (using PMA package or otherwise) on two samples</p></a></li>
<li><a href='#quickCPCA'><p>Perform cpca on two samples</p></a></li>
<li><a href='#quickPlainPCA'><p>Use space of combined sample-specific PCAs as a space</p></a></li>
<li><a href='#rawMatricesWithCommonGenes'><p>Get raw matrices with common genes</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#saveConosForScanPy'><p>Save Conos object on disk to read it from ScanPy</p></a></li>
<li><a href='#saveDEasCSV'><p>Save differential expression as table in *csv format</p></a></li>
<li><a href='#saveDEasJSON'><p>Save differential expression results as JSON</p></a></li>
<li><a href='#scanKModularity'><p>Scan joint graph modularity for a range of k (or k.self) values</p>
Builds graph with different values of k (or k.self if scan.k.self=TRUE), evaluating modularity of the resulting multilevel clustering
NOTE: will run evaluations in parallel using con$n.cores (temporarily setting con$n.cores to 1 in the process)</a></li>
<li><a href='#sgdBatches'><p>Calculate the default number of batches for a given number of vertices and edges.</p>
The formula used is the one used by the 'largeVis' reference implementation.  This is substantially less than the recommendation <code class="reqn">E * 10000</code> in the original paper.</a></li>
<li><a href='#small_panel.preprocessed'><p>Small pre-processed data from Pagoda2, two samples, each dimension (1000, 100)</p></a></li>
<li><a href='#stableTreeClusters'><p>Determine number of detectable clusters given a reference walktrap and a bunch of permuted walktraps</p></a></li>
<li><a href='#velocityInfoConos'><p>RNA velocity analysis on samples integrated with conos</p>
Create a list of objects to pass into gene.relative.velocity.estimates function from the velocyto.R package</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Clustering on Network of Samples</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Wires together large collections of single-cell RNA-seq datasets, which allows for both the identification of recurrent cell clusters and the propagation of information between datasets in multi-sample or atlas-scale collections. 'Conos' focuses on the uniform mapping of homologous cell types across heterogeneous sample collections. For instance, users could investigate a collection of dozens of peripheral blood samples from cancer patients combined with dozens of controls, which perhaps includes samples of a related tissue such as lymph nodes. This package interacts with data available through the 'conosPanel' package, which is available in a 'drat' repository. To access this data package, see the instructions at <a href="https://github.com/kharchenkolab/conos">https://github.com/kharchenkolab/conos</a>. The size of the 'conosPanel' package is approximately 12 MB.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Copyright:</td>
<td>See the file COPYRIGHTS for various conos copyright details</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), Matrix, igraph</td>
</tr>
<tr>
<td>Imports:</td>
<td>abind, cowplot, ComplexHeatmap, dendextend, dplyr, ggplot2,
ggrepel, gridExtra, irlba, leidenAlg, magrittr, methods, N2R,
parallel, R6, reshape2, rlang, Rtsne, sccore (&ge; 1.0.0), stats,
tools, utils</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>AnnotationDbi, BiocParallel, conosPanel, drat, DESeq2,
entropy, ggrastr, GO.db, jsonlite, knitr, org.Hs.eg.db,
org.Mm.eg.db, p2data, pagoda2, PMA, plyr, rhdf5, rmarkdown,
rmumps, Seurat, shinycssloaders, SummarizedExperiment,
testthat, tibble, uwot, zoo</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://kharchenkolab.github.io/drat/">https://kharchenkolab.github.io/drat/</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/kharchenkolab/conos">https://github.com/kharchenkolab/conos</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/kharchenkolab/conos/issues">https://github.com/kharchenkolab/conos/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppEigen, RcppProgress</td>
</tr>
<tr>
<td>Author:</td>
<td>Viktor Petukhov [aut],
  Nikolas Barkas [aut],
  Peter Kharchenko [aut],
  Weiliang Qiu [ctb],
  Evan Biederstedt [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Evan Biederstedt &lt;evan.biederstedt@gmail.com&gt;</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-26 18:23:02 UTC; evanbiederstedt</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-26 19:30:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='armaCor'>A slightly faster way of calculating column correlation matrix</h2><span id='topic+armaCor'></span>

<h3>Description</h3>

<p>A slightly faster way of calculating column correlation matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>armaCor(mat, nthreads = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="armaCor_+3A_mat">mat</code></td>
<td>
<p>matrix whose columns will be correlated</p>
</td></tr>
<tr><td><code id="armaCor_+3A_nthreads">nthreads</code></td>
<td>
<p>number of threads to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>correlation matrix
</p>

<hr>
<h2 id='basicSeuratProc'>Create and preprocess a Seurat object</h2><span id='topic+basicSeuratProc'></span>

<h3>Description</h3>

<p>Create and preprocess a Seurat object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basicSeuratProc(
  count.matrix,
  vars.to.regress = NULL,
  verbose = TRUE,
  do.par = TRUE,
  n.pcs = 100,
  cluster = TRUE,
  tsne = TRUE,
  umap = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="basicSeuratProc_+3A_count.matrix">count.matrix</code></td>
<td>
<p>gene count matrix</p>
</td></tr>
<tr><td><code id="basicSeuratProc_+3A_vars.to.regress">vars.to.regress</code></td>
<td>
<p>variables to regress with Seurat (default=NULL)</p>
</td></tr>
<tr><td><code id="basicSeuratProc_+3A_verbose">verbose</code></td>
<td>
<p>boolean Verbose mode (default=TRUE)</p>
</td></tr>
<tr><td><code id="basicSeuratProc_+3A_do.par">do.par</code></td>
<td>
<p>boolean Use parallel processing for regressing out variables faster (default=TRUE)</p>
</td></tr>
<tr><td><code id="basicSeuratProc_+3A_n.pcs">n.pcs</code></td>
<td>
<p>numeric Number of principal components (default=100)</p>
</td></tr>
<tr><td><code id="basicSeuratProc_+3A_cluster">cluster</code></td>
<td>
<p>boolean Whether to perform clustering (default=TRUE)</p>
</td></tr>
<tr><td><code id="basicSeuratProc_+3A_tsne">tsne</code></td>
<td>
<p>boolean Whether to construct tSNE embedding (default=TRUE)</p>
</td></tr>
<tr><td><code id="basicSeuratProc_+3A_umap">umap</code></td>
<td>
<p>boolean Whether to construct UMAP embedding, works only for Seurat v2.3.1 or higher (default=FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Seurat object
</p>

<hr>
<h2 id='bestClusterThresholds'>Find threshold of cluster detectability</h2><span id='topic+bestClusterThresholds'></span>

<h3>Description</h3>

<p>For a given clustering, walks the walktrap result tree to find
a subtree with max(min(sens,spec)) for each cluster, where sens is sensitivity, spec is specificity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bestClusterThresholds(res, clusters, clmerges = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bestClusterThresholds_+3A_res">res</code></td>
<td>
<p>walktrap result object (igraph)</p>
</td></tr>
<tr><td><code id="bestClusterThresholds_+3A_clusters">clusters</code></td>
<td>
<p>cluster factor</p>
</td></tr>
<tr><td><code id="bestClusterThresholds_+3A_clmerges">clmerges</code></td>
<td>
<p>integer matrix of cluster merges (default=NULL). If NULL, the function treeJaccard() performs calculation without it.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of $thresholds - per cluster optimal detectability values, and $node - internal node id (merge row) where the optimum was found
</p>

<hr>
<h2 id='bestClusterTreeThresholds'>Find threshold of cluster detectability in trees of clusters</h2><span id='topic+bestClusterTreeThresholds'></span>

<h3>Description</h3>

<p>For a given clustering, walks the walktrap (of clusters) result tree to find
a subtree with max(min(sens,spec)) for each cluster, where sens is sensitivity, spec is specificity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bestClusterTreeThresholds(res, leaf.factor, clusters, clmerges = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bestClusterTreeThresholds_+3A_res">res</code></td>
<td>
<p>walktrap result object (igraph) where the nodes were clusters</p>
</td></tr>
<tr><td><code id="bestClusterTreeThresholds_+3A_leaf.factor">leaf.factor</code></td>
<td>
<p>a named factor describing cell assignments to the leaf nodes (in the same order as res$names)</p>
</td></tr>
<tr><td><code id="bestClusterTreeThresholds_+3A_clusters">clusters</code></td>
<td>
<p>cluster factor</p>
</td></tr>
<tr><td><code id="bestClusterTreeThresholds_+3A_clmerges">clmerges</code></td>
<td>
<p>integer matrix of cluster merges (default=NULL). If NULL, the function treeJaccard() performs calculation without it.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of $thresholds - per cluster optimal detectability values, and $node - internal node id (merge row) where the optimum was found
</p>

<hr>
<h2 id='buildWijMatrix'>Rescale the weights in an edge matrix to match a given perplexity.</h2><span id='topic+buildWijMatrix'></span><span id='topic+buildWijMatrix.TsparseMatrix'></span><span id='topic+buildWijMatrix.CsparseMatrix'></span>

<h3>Description</h3>

<p>Rescale the weights in an edge matrix to match a given perplexity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildWijMatrix(x, threads = NULL, perplexity = 50)

## S3 method for class 'TsparseMatrix'
buildWijMatrix(x, threads = NULL, perplexity = 50)

## S3 method for class 'CsparseMatrix'
buildWijMatrix(x, threads = NULL, perplexity = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildWijMatrix_+3A_x">x</code></td>
<td>
<p>A sparse matrix</p>
</td></tr>
<tr><td><code id="buildWijMatrix_+3A_threads">threads</code></td>
<td>
<p>numeric The maximum number of threads to spawn. Determined automatically if <code>NULL</code> (default=NULL)</p>
</td></tr>
<tr><td><code id="buildWijMatrix_+3A_perplexity">perplexity</code></td>
<td>
<p>numeric Given perplexity (default=50)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the following components: </p>

<dl>
<dt>'dist'</dt><dd><p>An [N,K] matrix of the distances to the nearest neighbors.</p>
</dd>
<dt>'id'</dt><dd><p>An [N,K] matrix of the node indexes of the neartest neighbors.  Note that this matrix is 1-indexed,
unlike most other matrices in this package.</p>
</dd>
<dt>'k'</dt><dd><p>The number of nearest neighbors.</p>
</dd>
</dl>


<hr>
<h2 id='checkCountsWholeNumbers'>Check that the count data contain only integer counts</h2><span id='topic+checkCountsWholeNumbers'></span>

<h3>Description</h3>

<p>Check that the count data contain only integer counts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkCountsWholeNumbers(input.matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkCountsWholeNumbers_+3A_input.matrix">input.matrix</code></td>
<td>
<p>the count data from aggregated samples input to DESeq</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if non-integer counts are found, an error is returned
</p>

<hr>
<h2 id='Conos'>Conos R6 class</h2><span id='topic+Conos'></span>

<h3>Description</h3>

<p>The class encompasses sample collections, providing methods for calculating and visualizing joint graph and communities.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>samples</code></dt><dd><p>list of samples (Pagoda2 or Seurat objects)</p>
</dd>
<dt><code>pairs</code></dt><dd><p>pairwise alignment results</p>
</dd>
<dt><code>graph</code></dt><dd><p>alignment graph</p>
</dd>
<dt><code>clusters</code></dt><dd><p>list of clustering results named by clustering type</p>
</dd>
<dt><code>expression.adj</code></dt><dd><p>adjusted expression values</p>
</dd>
<dt><code>embeddings</code></dt><dd><p>list of joint embeddings</p>
</dd>
<dt><code>embedding</code></dt><dd><p>joint embedding</p>
</dd>
<dt><code>n.cores</code></dt><dd><p>number of cores</p>
</dd>
<dt><code>misc</code></dt><dd><p>list with unstructured additional info</p>
</dd>
<dt><code>override.conos.plot.theme</code></dt><dd><p>boolean Whether to override the conos plot theme</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Conos-new"><code>Conos$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Conos-addSamples"><code>Conos$addSamples()</code></a>
</p>
</li>
<li> <p><a href="#method-Conos-buildGraph"><code>Conos$buildGraph()</code></a>
</p>
</li>
<li> <p><a href="#method-Conos-getDifferentialGenes"><code>Conos$getDifferentialGenes()</code></a>
</p>
</li>
<li> <p><a href="#method-Conos-findCommunities"><code>Conos$findCommunities()</code></a>
</p>
</li>
<li> <p><a href="#method-Conos-plotPanel"><code>Conos$plotPanel()</code></a>
</p>
</li>
<li> <p><a href="#method-Conos-embedGraph"><code>Conos$embedGraph()</code></a>
</p>
</li>
<li> <p><a href="#method-Conos-plotClusterStability"><code>Conos$plotClusterStability()</code></a>
</p>
</li>
<li> <p><a href="#method-Conos-plotGraph"><code>Conos$plotGraph()</code></a>
</p>
</li>
<li> <p><a href="#method-Conos-correctGenes"><code>Conos$correctGenes()</code></a>
</p>
</li>
<li> <p><a href="#method-Conos-propagateLabels"><code>Conos$propagateLabels()</code></a>
</p>
</li>
<li> <p><a href="#method-Conos-getClusterCountMatrices"><code>Conos$getClusterCountMatrices()</code></a>
</p>
</li>
<li> <p><a href="#method-Conos-getDatasetPerCell"><code>Conos$getDatasetPerCell()</code></a>
</p>
</li>
<li> <p><a href="#method-Conos-getJointCountMatrix"><code>Conos$getJointCountMatrix()</code></a>
</p>
</li>
<li> <p><a href="#method-Conos-clone"><code>Conos$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Conos-new"></a>



<h4>Method <code>new()</code></h4>

<p>initialize Conos class
</p>


<h5>Usage</h5>

<div class="r"><pre>Conos$new(
  x,
  ...,
  n.cores = parallel::detectCores(logical = FALSE),
  verbose = TRUE,
  override.conos.plot.theme = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>a named list of pagoda2 or Seurat objects (one per sample)</p>
</dd>
<dt><code>...</code></dt><dd><p>additional parameters upon initializing Conos</p>
</dd>
<dt><code>n.cores</code></dt><dd><p>numeric Number of cores to use (default=parallel::detectCores(logical=FALSE))</p>
</dd>
<dt><code>verbose</code></dt><dd><p>boolean Whether to provide verbose output (default=TRUE)</p>
</dd>
<dt><code>override.conos.plot.theme</code></dt><dd><p>boolean Whether to reset plot settings to the ggplot2 default (default=FALSE)</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a new 'Conos' object
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>con &lt;- Conos$new(small_panel.preprocessed, n.cores=1)

</pre>
</div>


<hr>
<a id="method-Conos-addSamples"></a>



<h4>Method <code>addSamples()</code></h4>

<p>Initialize or add a set of samples to the conos panel. Note: this will simply add samples, but will not update graph, clustering, etc.
</p>


<h5>Usage</h5>

<div class="r"><pre>Conos$addSamples(x, replace = FALSE, verbose = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>a named list of pagoda2 or Seurat objects (one per sample)</p>
</dd>
<dt><code>replace</code></dt><dd><p>boolean Whether the existing samples should be purged before adding new ones (default=FALSE)</p>
</dd>
<dt><code>verbose</code></dt><dd><p>boolean Whether to provide verbose output (default=FALSE)</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>invisible view of the full sample list
</p>


<hr>
<a id="method-Conos-buildGraph"></a>



<h4>Method <code>buildGraph()</code></h4>

<p>Build the joint graph that encompasses all the samples, establishing weighted inter-sample cell-to-cell links
</p>


<h5>Usage</h5>

<div class="r"><pre>Conos$buildGraph(
  k = 15,
  k.self = 10,
  k.self.weight = 0.1,
  alignment.strength = NULL,
  space = "PCA",
  matching.method = "mNN",
  metric = "angular",
  k1 = k,
  data.type = "counts",
  l2.sigma = 1e+05,
  var.scale = TRUE,
  ncomps = 40,
  n.odgenes = 2000,
  matching.mask = NULL,
  exclude.samples = NULL,
  common.centering = TRUE,
  verbose = TRUE,
  base.groups = NULL,
  append.global.axes = TRUE,
  append.decoys = TRUE,
  decoy.threshold = 1,
  n.decoys = k * 2,
  score.component.variance = FALSE,
  snn = FALSE,
  snn.quantile = 0.9,
  min.snn.jaccard = 0,
  min.snn.weight = 0,
  snn.k.self = k.self,
  balance.edge.weights = FALSE,
  balancing.factor.per.cell = NULL,
  same.factor.downweight = 1,
  k.same.factor = k,
  balancing.factor.per.sample = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>k</code></dt><dd><p>integer integer Size of the inter-sample neighborhood (default=15)</p>
</dd>
<dt><code>k.self</code></dt><dd><p>integer Size of the with-sample neighborhoods (default=10).</p>
</dd>
<dt><code>k.self.weight</code></dt><dd><p>numeric Weight multiplier on the intra-sample edges relative to inter-sample edges (default=0.1)</p>
</dd>
<dt><code>alignment.strength</code></dt><dd><p>numeric Alignment strength (default=NULL will result in alignment.strength=0)</p>
</dd>
<dt><code>space</code></dt><dd><p>character Reduced expression space used to establish putative alignments between pairs of samples (default='PCA'). Currently supported spaces are:
&mdash; &quot;CPCA&quot; Common principal component analysis
&mdash; &quot;JNMF&quot; Joint NMF
&mdash; &quot;genes&quot; Gene expression space (log2 transformed)
&mdash; &quot;PCA&quot; Principal component analysis
&mdash; &quot;CCA&quot; Canonical correlation analysis
&mdash; &quot;PMA&quot; (Penalized Multivariate Analysis &lt;https://cran.r-project.org/web/packages/PMA/index.html&gt;)</p>
</dd>
<dt><code>matching.method</code></dt><dd><p>character Matching method (default='mNN'). Currently supported methods are &quot;NN&quot; (nearest neighbors) or &quot;mNN&quot; (mututal nearest neighbors).</p>
</dd>
<dt><code>metric</code></dt><dd><p>character Distance metric to measure similarity (default='angular'). Currenlty supported metrics are &quot;angular&quot; and &quot;L2&quot;.</p>
</dd>
<dt><code>k1</code></dt><dd><p>numeric Neighborhood radius for identifying mutually-matching neighbors (default=k). Note that k1 must be greater than or equal to k, i.e. k1&gt;=k. Increasing k1 beyond k will lead to more aggressive alignment of distinct subpopulations (i.e. increased alignment strengths).</p>
</dd>
<dt><code>data.type</code></dt><dd><p>character Type of data type in the input pagoda2 objects within r.n (default='counts').</p>
</dd>
<dt><code>l2.sigma</code></dt><dd><p>numeric L2 distances get transformed as exp(-d/sigma) using this value (default=1e5)</p>
</dd>
<dt><code>var.scale</code></dt><dd><p>boolean Whether to use common variance scaling (default=TRUE). If TRUE, use geometric means for variance, as we're trying to focus on the common variance components. See scaledMatricesP2() code.</p>
</dd>
<dt><code>ncomps</code></dt><dd><p>integer Number of components (default=40)</p>
</dd>
<dt><code>n.odgenes</code></dt><dd><p>integer Number of overdispersed genes to be used in each pairwise alignment (default=2000)</p>
</dd>
<dt><code>matching.mask</code></dt><dd><p>an optional matrix explicitly specifying which pairs of samples should be compared (a symmetrical matrix of logical values with row and column names corresponding to sample names). (default=NULL). By default, comparisons between all paris are allowed. The argument can be used to exclude comparisons across certain pairs of samples (e.g. techincal replicates, which are expected to show very high similarity).</p>
</dd>
<dt><code>exclude.samples</code></dt><dd><p>optional list of sample names that should be excluded from the alignment and the resulting graph (default=NULL)</p>
</dd>
<dt><code>common.centering</code></dt><dd><p>boolean When calculating reduced expression space for a given sample pair, whether the expression of genes should be centered using the mean from both samples (TRUE) or using the mean within each sample (FALSE) (default=TRUE)</p>
</dd>
<dt><code>verbose</code></dt><dd><p>boolean Whether to provide verbose output (default=TRUE)</p>
</dd>
<dt><code>base.groups</code></dt><dd><p>an optional factor on cells specifying previously-obtained cell grouping to be used for adjusting the sample alignment (default: NULL). Specifically, cell clusters specfiieid by the base.groups can be used to i) calculate global expression axes which are appended to the overall set of eigenvectors, ii) adding decoy cells.</p>
</dd>
<dt><code>append.global.axes</code></dt><dd><p>boolean Whether to project samples on global expression axes, as defined by pre-defined (typically crude) set of cell subpopulations as specified by the base.gruops parameter (default=TRUE, but works only if base.groups is specified)</p>
</dd>
<dt><code>append.decoys</code></dt><dd><p>boolean Whether to use pre-defined cell groups (specified by base.groups) to append decoy cells to the samples which are otherwise lacking any of the pre-specified cell groups (default=TRUE, but works only if base.groups is specified). The decoy cells can reduce the number of erroneous matches in highly heterogeneous sample collections, where some of the samples lack entire cell subpopulations which are found in other samples. The approach only works if the base.groups (typically a crude clustering of top-level cell types) can be established with a reasonable confidence.</p>
</dd>
<dt><code>decoy.threshold</code></dt><dd><p>integer Minimal number of cells of a given cell type that should exist in a given sample (according to base.groups) to avoid addition of decoy cells to that sample for the purposes of alignment (default=1)</p>
</dd>
<dt><code>n.decoys</code></dt><dd><p>integer Number of decoy cells that should be added to a sample that had less than decoy.threshold cells of a given cell type (default=k*2)</p>
</dd>
<dt><code>score.component.variance</code></dt><dd><p>boolean Whether to score the amount of total variance explained by different components (default=FALSE as it takes extra time to calculate)</p>
</dd>
<dt><code>snn</code></dt><dd><p>boolean Whether to transform the joint graph by computing a shared nearest neighborhood graph (analogous to Seurat 3), further weighting the edges between two matched cells based on the similarity (measured by Jaccard coefficient) of all of their predicted neighbors (across all of the samples) (default: FALSE)</p>
</dd>
<dt><code>snn.quantile</code></dt><dd><p>numeric Specifies how the shared neighborhood graph transformation will determine final edge weights. If snn.quantile=NULL, the edge weight will be simply equal to the Jaccard coefficient of the neighborhoods. If snn.quantile is a vector of two numeric values (p1, p2), they will be treated as quantile probabilities, and quantile values (q1,q2) on the set of all Jaccard coefficients (for all edges) will be determiend. The edge weights will then be reset, so that edges with Jaccard coefficients below or equal to q1 will be set to 0, and those with coefficients &gt;=q2 will be set to 1. The rest of the weights will be mapped uniformly from [q1,q2]-&gt;[0,1] range. If a single numeric value is supplied, it will be treated as a symmetric quantile probability (i.e. snn.quantile=0.8 is equivalent to specifying snn.quantile=c(1-0.8,0.8)). (default: 0.9)</p>
</dd>
<dt><code>min.snn.jaccard</code></dt><dd><p>numeric Minimum Jaccard coefficient required for a shared neighborhood graph edge (default: 0). The edges with Jaccard coefficients below this threshold will be removed (i.e. weight set to 0)</p>
</dd>
<dt><code>min.snn.weight</code></dt><dd><p>numeric Shared nearest neighbor procedure will adjust the weights of the edges, and even eliminate some of the edges (by setting their weight to zero). The min.snn.weight parameter allows to set a minimal adjusted edge weight, so that the edge weight is never reduced beyond this level (and hence never deleted) (default: 0 - no adjustments)</p>
</dd>
<dt><code>snn.k.self</code></dt><dd><p>integer Size of the within-sample neighorhood to be used in shared nearest neighbor calculations (default=k.self)</p>
</dd>
<dt><code>balance.edge.weights</code></dt><dd><p>boolean Whether to balance edge weights to control for a cell- or sample- specific factor (default=FALSE)</p>
</dd>
<dt><code>balancing.factor.per.cell</code></dt><dd><p>A per-cell factor (discrete factor, named with cell names) specifying a design difference should be controlled for by adjusting edge weights in the joint graph (default=NULL)</p>
</dd>
<dt><code>same.factor.downweight</code></dt><dd><p>numeric Optional weighting factor for edges connecting cells with the same cell factor level per cell balancing (default=1.0)</p>
</dd>
<dt><code>k.same.factor</code></dt><dd><p>integer An neighborhood size that should be used when aligning samples of the same balancing.factor.per.sample level. Setting a value smaller than k will lead to reduction of alingment strenth within the sample batches (default=k)</p>
</dd>
<dt><code>balancing.factor.per.sample</code></dt><dd><p>A covariate factor per sample that should be controlled for by adjusting edge weights in the joint graph (default=NULL)</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>joint graph to be used for downstream analysis
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>con &lt;- Conos$new(small_panel.preprocessed, n.cores=1)
con$buildGraph(k=10, k.self=5, space='PCA', ncomps=10, n.odgenes=20, matching.method='mNN',
    metric='angular', score.component.variance=TRUE, verbose=TRUE)


</pre>
</div>


<hr>
<a id="method-Conos-getDifferentialGenes"></a>



<h4>Method <code>getDifferentialGenes()</code></h4>

<p>Calculate genes differentially expressed between cell clusters. Estimates base mean, z-score, p-values, specificity, precision, expressionFraction, AUC (if append.auc=TRUE)
</p>


<h5>Usage</h5>

<div class="r"><pre>Conos$getDifferentialGenes(
  clustering = NULL,
  groups = NULL,
  z.threshold = 3,
  upregulated.only = FALSE,
  verbose = TRUE,
  append.specificity.metrics = TRUE,
  append.auc = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>clustering</code></dt><dd><p>character Name of the clustering to use (see names(con$clusters)) for the value of the groups factor (default: NULL - if groups are not specified, the first clustering will be used)</p>
</dd>
<dt><code>groups</code></dt><dd><p>a cell factor (a factor named with cell names) specifying clusters of cells to be compared (one against all). To compare two cell clusters against each other, simply pass a factor containing only two levels (default: NULL, see clustering)</p>
</dd>
<dt><code>z.threshold</code></dt><dd><p>numeric Minimum absolute value of a Z score for which the genes should be reported (default=3.0).</p>
</dd>
<dt><code>upregulated.only</code></dt><dd><p>boolean If TRUE, will report only genes significantly upregulated in each cluster; otherwise both up- and down-regulated genes will be reported (default=FALSE)</p>
</dd>
<dt><code>verbose</code></dt><dd><p>boolean Whether to provide verbose output (default=TRUE)</p>
</dd>
<dt><code>append.specificity.metrics</code></dt><dd><p>boolean Whether to append specificity metrics (default=TRUE)</p>
</dd>
<dt><code>append.auc</code></dt><dd><p>boolean Whether to append AUC scores (default=TRUE)</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>list of DE results; each is a data frame with rows corresponding to the differentially expressed genes, and columns listing log2 fold change (M), signed Z scores (both raw and adjusted for mulitple hypothesis using BH correction), optional specificty/sensitivity and AUC metrics.
</p>


<hr>
<a id="method-Conos-findCommunities"></a>



<h4>Method <code>findCommunities()</code></h4>

<p>Find cell clusters (as communities on the joint graph)
</p>


<h5>Usage</h5>

<div class="r"><pre>Conos$findCommunities(
  method = leiden.community,
  min.group.size = 0,
  name = NULL,
  test.stability = FALSE,
  stability.subsampling.fraction = 0.95,
  stability.subsamples = 100,
  verbose = TRUE,
  cls = NULL,
  sr = NULL,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>method</code></dt><dd><p>community detection method (igraph syntax) (default=leiden.community)</p>
</dd>
<dt><code>min.group.size</code></dt><dd><p>numeric Minimal allowed community size (default=0)</p>
</dd>
<dt><code>name</code></dt><dd><p>character Optional name of the clustering result (will default to the algorithm name) (default=NULL will try to obtain the name from the community detection method, or will use 'community' as a default)</p>
</dd>
<dt><code>test.stability</code></dt><dd><p>boolean Whether to test stability of community detection (default=FALSE)</p>
</dd>
<dt><code>stability.subsampling.fraction</code></dt><dd><p>numeric Fraction of clusters to subset (default=0.95). Must be within range [0, 1].</p>
</dd>
<dt><code>stability.subsamples</code></dt><dd><p>integer Number of subsampling iterations (default=100)</p>
</dd>
<dt><code>verbose</code></dt><dd><p>boolean Whether to provide verbose output (default=TRUE)</p>
</dd>
<dt><code>cls</code></dt><dd><p>optional pre-calculated community result (may be useful for stability testing) (default: NULL)</p>
</dd>
<dt><code>sr</code></dt><dd><p>optional pre-calculated subsampled community results (useful for stability testing) (default: NULL)</p>
</dd>
<dt><code>...</code></dt><dd><p>extra parameters are passed to the specified community detection method</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>invisible list containing identified communities (groups) and the full community detection result (result); The results are stored in $clusters$name slot in the conos object. Each such slot contains an object with elements: $results which stores the raw output of the community detection method, and $groups which is a factor on cells describing the resulting clustering. The later can be used, for instance, in plotting: con$plotGraph(groups=con$clusters$leiden$groups). If test.stability==TRUE, then the result object will also contain a $stability slot.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>con &lt;- Conos$new(small_panel.preprocessed, n.cores=1)
con$buildGraph(k=10, k.self=5, space='PCA', ncomps=10, n.odgenes=20, matching.method='mNN',
    metric='angular', score.component.variance=TRUE, verbose=TRUE)
con$findCommunities(method = igraph::walktrap.community, steps=5)

</pre>
</div>


<hr>
<a id="method-Conos-plotPanel"></a>



<h4>Method <code>plotPanel()</code></h4>

<p>Plot panel of individual embeddings per sample with joint coloring
</p>


<h5>Usage</h5>

<div class="r"><pre>Conos$plotPanel(
  clustering = NULL,
  groups = NULL,
  colors = NULL,
  gene = NULL,
  use.local.clusters = FALSE,
  plot.theme = NULL,
  use.common.embedding = FALSE,
  embedding = NULL,
  adj.list = NULL,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>clustering</code></dt><dd><p>character Name of the clustering to use (see names(con$clusters)) for the value of the groups factor (default=NULL - if groups are not specified, the first clustering will be used)</p>
</dd>
<dt><code>groups</code></dt><dd><p>a cell factor (a factor named with cell names) specifying clusters of cells to be compared (one against all). To compare two cell clusters against each other, simply pass a factor containing only two levels (default=NULL, see clustering)</p>
</dd>
<dt><code>colors</code></dt><dd><p>a color factor (named with cell names) use for cell coloring</p>
</dd>
<dt><code>gene</code></dt><dd><p>show expression of a gene</p>
</dd>
<dt><code>use.local.clusters</code></dt><dd><p>boolean Whether clusters should be taken from the individual samples; otherwise joint clusters in the conos object will be used (see clustering) (default=FALSE).</p>
</dd>
<dt><code>plot.theme</code></dt><dd><p>string Theme for the plot, passed to plotSamples() (default=NULL)</p>
</dd>
<dt><code>use.common.embedding</code></dt><dd><p>boolean Whether a joint embedding in the conos object should be used (or embeddings determined for the individual samples) (default=FALSE)</p>
</dd>
<dt><code>embedding</code></dt><dd><p>(default=NULL) If a character value is passed, it is interpreted as an embedding name (a name of a joint embedding in conos when use.commmon.embedding=TRUE, or a name of an embedding within the individual objects when use.common.embedding=FALSE).
If a matrix is passed, it is interpreted as an actual embedding (then first two columns are interpreted as x/y coordinates, row names must be cell names). If NULL, the default embedding will be used.</p>
</dd>
<dt><code>adj.list</code></dt><dd><p>an optional list of additional ggplot2 directions to apply (default=NULL)</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional parameters passed to plotSamples(), plotEmbeddings(), sccore::embeddingPlot().</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>cowplot grid object with the panel of plots
</p>


<hr>
<a id="method-Conos-embedGraph"></a>



<h4>Method <code>embedGraph()</code></h4>

<p>Generate an embedding of a joint graph
</p>


<h5>Usage</h5>

<div class="r"><pre>Conos$embedGraph(
  method = "largeVis",
  embedding.name = method,
  M = 1,
  gamma = 1,
  alpha = 0.1,
  perplexity = NA,
  sgd_batches = 1e+08,
  seed = 1,
  verbose = TRUE,
  target.dims = 2,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>method</code></dt><dd><p>Embedding method (default='largeVis'). Currently 'largeVis' and 'UMAP' are supported.</p>
</dd>
<dt><code>embedding.name</code></dt><dd><p>character Optional name of the name of the embedding set by user to store multiple embeddings (default: method name)</p>
</dd>
<dt><code>M</code></dt><dd><p>numeric (largeVis) The number of negative edges to sample for each positive edge to be used (default=1)</p>
</dd>
<dt><code>gamma</code></dt><dd><p>numeric (largeVis) The strength of the force pushing non-neighbor nodes apart (default=1)</p>
</dd>
<dt><code>alpha</code></dt><dd><p>numeric (largeVis) Hyperparameter used in the default distance function, <code class="reqn">1 / (1 + \alpha \dot ||y_i - y_j||^2)</code> (default=0.1).  The function relates the distance
between points in the low-dimensional projection to the likelihood that the two points are nearest neighbors. Increasing <code class="reqn">\alpha</code> tends
to push nodes and their neighbors closer together; decreasing <code class="reqn">\alpha</code> produces a broader distribution. Setting <code class="reqn">\alpha</code> to zero
enables the alternative distance function. <code class="reqn">\alpha</code> below zero is meaningless.</p>
</dd>
<dt><code>perplexity</code></dt><dd><p>(largeVis) The perplexity passed to largeVis (default=NA)</p>
</dd>
<dt><code>sgd_batches</code></dt><dd><p>(largeVis) The number of edges to process during SGD (default=1e8). Defaults to a value set based on the size of the dataset. If the parameter given is
between <code>0</code> and <code>1</code>, the default value will be multiplied by the parameter.</p>
</dd>
<dt><code>seed</code></dt><dd><p>numeric Random seed for the largeVis algorithm (default=1)</p>
</dd>
<dt><code>verbose</code></dt><dd><p>boolean Whether to provide verbose output (default=TRUE)</p>
</dd>
<dt><code>target.dims</code></dt><dd><p>numeric Number of dimensions for the reduction (default=2). Higher dimensions can be used to generate embeddings for subsequent reductions by other methods, such as tSNE</p>
</dd>
<dt><code>...</code></dt><dd><p>additional arguments, passed to UMAP embedding (run ?conos:::embedGraphUmap for more info)</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Conos-plotClusterStability"></a>



<h4>Method <code>plotClusterStability()</code></h4>

<p>Plot cluster stability statistics.
</p>


<h5>Usage</h5>

<div class="r"><pre>Conos$plotClusterStability(clustering = NULL, what = "all")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>clustering</code></dt><dd><p>string Name of the clustering result to show (default=NULL)</p>
</dd>
<dt><code>what</code></dt><dd><p>string Show a specific plot (ari - adjusted rand index, fjc - flat Jaccard, hjc - hierarchical Jaccard, dend - cluster dendrogram, all - everything except 'dend') (default='all')</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>cluster stability statistics
</p>


<hr>
<a id="method-Conos-plotGraph"></a>



<h4>Method <code>plotGraph()</code></h4>

<p>Plot joint graph
</p>


<h5>Usage</h5>

<div class="r"><pre>Conos$plotGraph(
  color.by = "cluster",
  clustering = NULL,
  embedding = NULL,
  groups = NULL,
  colors = NULL,
  gene = NULL,
  plot.theme = NULL,
  subset = NULL,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>color.by</code></dt><dd><p>character A shortcut to color the plot by 'cluster' or by 'sample' (default: 'cluster'). If any other string is input, an error is thrown.</p>
</dd>
<dt><code>clustering</code></dt><dd><p>a character name of the clustering to use (see names(con$clusters)) for the value of the groups factor (default: NULL - if groups are not specified, the first clustering will be used)</p>
</dd>
<dt><code>embedding</code></dt><dd><p>A character name of an embedding, or a matrix of the actual embedding (rownames should correspond to cells, first to columns to x/y coordinates). If NULL (default: NULL), the latest generated embedding will be used</p>
</dd>
<dt><code>groups</code></dt><dd><p>a cell factor (a factor named with cell names) specifying clusters of cells to be compared (one against all). To compare two cell clusters against each other, simply pass a factor containing only two levels (default: NULL, see clustering)</p>
</dd>
<dt><code>colors</code></dt><dd><p>a color factor (named with cell names) use for cell coloring (default=NULL)</p>
</dd>
<dt><code>gene</code></dt><dd><p>Show expression of a gene (default=NULL)</p>
</dd>
<dt><code>plot.theme</code></dt><dd><p>Theme for the plot, passed to sccore::embeddingPlot() (default=NULL)</p>
</dd>
<dt><code>subset</code></dt><dd><p>A subset of cells to show (default: NULL - shows all the cells)</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional parameters passed to sccore::embeddingPlot()</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>ggplot2 plot of joint graph
</p>


<hr>
<a id="method-Conos-correctGenes"></a>



<h4>Method <code>correctGenes()</code></h4>

<p>Smooth expression of genes to minimize the batch effect between samples
Use diffusion of expression on graph with the equation dv = exp(-a * (v + b))
</p>


<h5>Usage</h5>

<div class="r"><pre>Conos$correctGenes(
  genes = NULL,
  n.od.genes = 500,
  fading = 10,
  fading.const = 0.5,
  max.iters = 15,
  tol = 0.005,
  name = "diffusion",
  verbose = TRUE,
  count.matrix = NULL,
  normalize = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>genes</code></dt><dd><p>List of genes to be smooothed smoothing (default=NULL will smooth top n.od.genes overdispersed genes)</p>
</dd>
<dt><code>n.od.genes</code></dt><dd><p>numeric If 'genes' is NULL, top n.od.genes of overdispersed genes are taken across all samples (default=500)</p>
</dd>
<dt><code>fading</code></dt><dd><p>numeric Level of fading of expression change from distance on the graph (parameter 'a' of the equation) (default=10)</p>
</dd>
<dt><code>fading.const</code></dt><dd><p>numeric Minimal penalty for each new edge during diffusion (parameter 'b' of the equation) (default=0.5)</p>
</dd>
<dt><code>max.iters</code></dt><dd><p>numeric Maximal number of diffusion iterations (default=15)</p>
</dd>
<dt><code>tol</code></dt><dd><p>numeric Tolerance after which the diffusion stops (default=5e-3)</p>
</dd>
<dt><code>name</code></dt><dd><p>string Name to save the correction (default='diffusion')</p>
</dd>
<dt><code>verbose</code></dt><dd><p>boolean Verbose mode (default=TRUE)</p>
</dd>
<dt><code>count.matrix</code></dt><dd><p>Alternative gene count matrix to correct (rows: genes, columns: cells; has to be dense matrix). Default: joint count matrix for all datasets.</p>
</dd>
<dt><code>normalize</code></dt><dd><p>boolean Whether to normalize values (default=TRUE)</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>smoothed expression of the input genes
</p>


<hr>
<a id="method-Conos-propagateLabels"></a>



<h4>Method <code>propagateLabels()</code></h4>

<p>Estimate labeling distribution for each vertex, based on a partial labeling of the cells.
There are two methods used for the propagation to calculate the distribution of labels: &quot;solver&quot; and &quot;diffusion&quot;.
* &quot;diffusion&quot; (default) will estimate the labeling distribution for each vertex, based on provided labels using a random walk.
* &quot;solver&quot; will propagate labels using the algorithm described by Zhu, Ghahramani, Lafferty (2003) &lt;http://mlg.eng.cam.ac.uk/zoubin/papers/zgl.pdf&gt;
Confidence values are then calculated by taking the maximum value from this distribution of labels, for each cell.
</p>


<h5>Usage</h5>

<div class="r"><pre>Conos$propagateLabels(labels, method = "diffusion", ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>labels</code></dt><dd><p>Input labels</p>
</dd>
<dt><code>method</code></dt><dd><p>type of propagation. Either 'diffusion' or 'solver'. 'solver' gives better result
but has bad asymptotics, so is inappropriate for datasets &gt; 20k cells. (default='diffusion')</p>
</dd>
<dt><code>...</code></dt><dd><p>additional arguments for conos:::propagateLabels* functions</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>list with three fields:
* labels = matrix with distribution of label probabilities for each vertex by rows.
* uncertainty = 1 - confidence values
* label.distribution = the distribution of labels calculated using either the methods &quot;diffusion&quot; or &quot;solver&quot;
</p>


<hr>
<a id="method-Conos-getClusterCountMatrices"></a>



<h4>Method <code>getClusterCountMatrices()</code></h4>

<p>Calculate pseudo-bulk expression matrices for clusters (by adding up, for each gene, all of the molecules detected for all cells in a given cluster in a given sample)
</p>


<h5>Usage</h5>

<div class="r"><pre>Conos$getClusterCountMatrices(
  clustering = NULL,
  groups = NULL,
  common.genes = TRUE,
  omit.na.cells = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>clustering</code></dt><dd><p>string Name of the clustering to use</p>
</dd>
<dt><code>groups</code></dt><dd><p>a factor on cells to use for coloring</p>
</dd>
<dt><code>common.genes</code></dt><dd><p>boolean Whether to bring individual sample matrices to a common gene list (default=TRUE)</p>
</dd>
<dt><code>omit.na.cells</code></dt><dd><p>boolean If set to FALSE, the resulting matrices will include a first column named 'NA' that will report total molecule counts for all of the cells that were not covered by the provided factor. (default=TRUE)</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a list of per-sample uniform dense matrices with rows being genes, and columns being clusters
</p>


<hr>
<a id="method-Conos-getDatasetPerCell"></a>



<h4>Method <code>getDatasetPerCell()</code></h4>

<p>applies 'getCellNames()' on all samples
</p>


<h5>Usage</h5>

<div class="r"><pre>Conos$getDatasetPerCell()</pre></div>



<h5>Returns</h5>

<p>list of cellnames for all samples
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>con &lt;- Conos$new(small_panel.preprocessed, n.cores=1)
con$getDatasetPerCell()

</pre>
</div>


<hr>
<a id="method-Conos-getJointCountMatrix"></a>



<h4>Method <code>getJointCountMatrix()</code></h4>

<p>Retrieve joint count matrices
</p>


<h5>Usage</h5>

<div class="r"><pre>Conos$getJointCountMatrix(raw = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>raw</code></dt><dd><p>boolean If TRUE, return merged &quot;raw&quot; count matrices, using function getRawCountMatrix(). Otherwise, return the merged count matrices, using getCountMatrix(). (default=FALSE)</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>list of merged count matrices
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>con &lt;- Conos$new(small_panel.preprocessed, n.cores=1)
con$getJointCountMatrix()

</pre>
</div>


<hr>
<a id="method-Conos-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Conos$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `Conos$new`
## ------------------------------------------------

con &lt;- Conos$new(small_panel.preprocessed, n.cores=1)


## ------------------------------------------------
## Method `Conos$buildGraph`
## ------------------------------------------------

con &lt;- Conos$new(small_panel.preprocessed, n.cores=1)
con$buildGraph(k=10, k.self=5, space='PCA', ncomps=10, n.odgenes=20, matching.method='mNN',
    metric='angular', score.component.variance=TRUE, verbose=TRUE)



## ------------------------------------------------
## Method `Conos$findCommunities`
## ------------------------------------------------

con &lt;- Conos$new(small_panel.preprocessed, n.cores=1)
con$buildGraph(k=10, k.self=5, space='PCA', ncomps=10, n.odgenes=20, matching.method='mNN',
    metric='angular', score.component.variance=TRUE, verbose=TRUE)
con$findCommunities(method = igraph::walktrap.community, steps=5)


## ------------------------------------------------
## Method `Conos$getDatasetPerCell`
## ------------------------------------------------

con &lt;- Conos$new(small_panel.preprocessed, n.cores=1)
con$getDatasetPerCell()


## ------------------------------------------------
## Method `Conos$getJointCountMatrix`
## ------------------------------------------------

con &lt;- Conos$new(small_panel.preprocessed, n.cores=1)
con$getJointCountMatrix()

</code></pre>

<hr>
<h2 id='convertToPagoda2'>Convert Conos object to Pagoda2 object</h2><span id='topic+convertToPagoda2'></span>

<h3>Description</h3>

<p>Convert Conos object to Pagoda2 object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convertToPagoda2(con, n.pcs = 100, n.odgenes = 2000, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convertToPagoda2_+3A_con">con</code></td>
<td>
<p>Conos object</p>
</td></tr>
<tr><td><code id="convertToPagoda2_+3A_n.pcs">n.pcs</code></td>
<td>
<p>numeric Number of principal components (default=100)</p>
</td></tr>
<tr><td><code id="convertToPagoda2_+3A_n.odgenes">n.odgenes</code></td>
<td>
<p>numeric Number of overdispersed genes (default=2000)</p>
</td></tr>
<tr><td><code id="convertToPagoda2_+3A_verbose">verbose</code></td>
<td>
<p>boolean Whether to give verbose output (default=TRUE)</p>
</td></tr>
<tr><td><code id="convertToPagoda2_+3A_...">...</code></td>
<td>
<p>parameters passed to Pagoda2$new()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>pagoda2 object
</p>

<hr>
<h2 id='edgeMat+26lt+3B-'>Set edge matrix edgeMat with certain values on sample</h2><span id='topic+edgeMat+3C-'></span><span id='topic+edgeMat+3C-+2CPagoda2-method'></span><span id='topic+edgeMat+3C-+2Cseurat-method'></span><span id='topic+edgeMat+3C-+2CSeurat-method'></span><span id='topic+edgeMat'></span><span id='topic+edgeMat+2CPagoda2-method'></span><span id='topic+edgeMat+2Cseurat-method'></span><span id='topic+edgeMat+2CSeurat-method'></span>

<h3>Description</h3>

<p>Set edge matrix edgeMat with certain values on sample
</p>
<p>Access edgeMat from sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edgeMat(sample) &lt;- value

## S4 replacement method for signature 'Pagoda2'
edgeMat(sample) &lt;- value

## S4 replacement method for signature 'seurat'
edgeMat(sample) &lt;- value

## S4 replacement method for signature 'Seurat'
edgeMat(sample) &lt;- value

edgeMat(sample)

## S4 method for signature 'Pagoda2'
edgeMat(sample)

## S4 method for signature 'seurat'
edgeMat(sample)

## S4 method for signature 'Seurat'
edgeMat(sample)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edgeMat+2B26lt+2B3B-_+3A_sample">sample</code></td>
<td>
<p>sample from which to access edge matrix edgeMat</p>
</td></tr>
<tr><td><code id="edgeMat+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>values to set with edgeMat&lt;-</p>
</td></tr>
</table>

<hr>
<h2 id='estimateWeightEntropyPerCell'>Estimate entropy of edge weights per cell according to the specified factor.
Can be used to visualize alignment quality according to this factor.</h2><span id='topic+estimateWeightEntropyPerCell'></span>

<h3>Description</h3>

<p>Estimate entropy of edge weights per cell according to the specified factor.
Can be used to visualize alignment quality according to this factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateWeightEntropyPerCell(con, factor.per.cell)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateWeightEntropyPerCell_+3A_con">con</code></td>
<td>
<p>conos object</p>
</td></tr>
<tr><td><code id="estimateWeightEntropyPerCell_+3A_factor.per.cell">factor.per.cell</code></td>
<td>
<p>some factor, which group cells, such as sample or a specific condition</p>
</td></tr>
</table>


<h3>Value</h3>

<p>entropy of edge weights per cell
</p>

<hr>
<h2 id='filter.genes.by.cluster.expression'>Filter genes by requiring minimum average expression within at least one of the provided cell clusters</h2><span id='topic+filter.genes.by.cluster.expression'></span>

<h3>Description</h3>

<p>Filter genes by requiring minimum average expression within at least one of the provided cell clusters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter.genes.by.cluster.expression(
  emat,
  clusters,
  min.max.cluster.average = 0.1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter.genes.by.cluster.expression_+3A_emat">emat</code></td>
<td>
<p>spliced (exonic) count matrix</p>
</td></tr>
<tr><td><code id="filter.genes.by.cluster.expression_+3A_clusters">clusters</code></td>
<td>
<p>named cell factor defining clusters</p>
</td></tr>
<tr><td><code id="filter.genes.by.cluster.expression_+3A_min.max.cluster.average">min.max.cluster.average</code></td>
<td>
<p>numeric Required minimum average expression count (no normalization is perfomed) (default=0.1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>filtered emat matrix
</p>

<hr>
<h2 id='findSubcommunities'>Increase resolution for a specific set of clusters</h2><span id='topic+findSubcommunities'></span>

<h3>Description</h3>

<p>Increase resolution for a specific set of clusters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findSubcommunities(
  con,
  target.clusters,
  clustering = NULL,
  groups = NULL,
  method = leiden.community,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findSubcommunities_+3A_con">con</code></td>
<td>
<p>conos object</p>
</td></tr>
<tr><td><code id="findSubcommunities_+3A_target.clusters">target.clusters</code></td>
<td>
<p>clusters for which the resolution should be increased</p>
</td></tr>
<tr><td><code id="findSubcommunities_+3A_clustering">clustering</code></td>
<td>
<p>name of clustering in the conos object to use. Either 'clustering' or 'groups' must be provided (default=NULL).</p>
</td></tr>
<tr><td><code id="findSubcommunities_+3A_groups">groups</code></td>
<td>
<p>set of clusters to use. Ignored if 'clustering' is not NULL (default=NULL).</p>
</td></tr>
<tr><td><code id="findSubcommunities_+3A_method">method</code></td>
<td>
<p>function, used to find communities (default=leiden.community).</p>
</td></tr>
<tr><td><code id="findSubcommunities_+3A_...">...</code></td>
<td>
<p>additional params passed to the community function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>set of clusters with increased resolution
</p>

<hr>
<h2 id='getBetweenCellTypeCorrectedDE'>Compare two cell types across the entire panel</h2><span id='topic+getBetweenCellTypeCorrectedDE'></span>

<h3>Description</h3>

<p>Compare two cell types across the entire panel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBetweenCellTypeCorrectedDE(
  con.obj,
  sample.groups = NULL,
  groups = NULL,
  cooks.cutoff = FALSE,
  refgroup = NULL,
  altgroup = NULL,
  min.cell.count = 10,
  independent.filtering = FALSE,
  cluster.sep.chr = "&lt;!!&gt;",
  return.details = TRUE,
  only.paired = TRUE,
  correction = NULL,
  ref.level = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getBetweenCellTypeCorrectedDE_+3A_con.obj">con.obj</code></td>
<td>
<p>conos object</p>
</td></tr>
<tr><td><code id="getBetweenCellTypeCorrectedDE_+3A_sample.groups">sample.groups</code></td>
<td>
<p>a named list of two character vectors specifying the app groups to compare</p>
</td></tr>
<tr><td><code id="getBetweenCellTypeCorrectedDE_+3A_groups">groups</code></td>
<td>
<p>factor describing cell grouping</p>
</td></tr>
<tr><td><code id="getBetweenCellTypeCorrectedDE_+3A_cooks.cutoff">cooks.cutoff</code></td>
<td>
<p>cooksCutoff parameter for DESeq2</p>
</td></tr>
<tr><td><code id="getBetweenCellTypeCorrectedDE_+3A_refgroup">refgroup</code></td>
<td>
<p>cell type to compare to be used as reference</p>
</td></tr>
<tr><td><code id="getBetweenCellTypeCorrectedDE_+3A_altgroup">altgroup</code></td>
<td>
<p>cell type to compare to</p>
</td></tr>
<tr><td><code id="getBetweenCellTypeCorrectedDE_+3A_min.cell.count">min.cell.count</code></td>
<td>
<p>minimum number of cells per celltype/sample combination to keep</p>
</td></tr>
<tr><td><code id="getBetweenCellTypeCorrectedDE_+3A_independent.filtering">independent.filtering</code></td>
<td>
<p>independentFiltering parameter for DESeq2</p>
</td></tr>
<tr><td><code id="getBetweenCellTypeCorrectedDE_+3A_cluster.sep.chr">cluster.sep.chr</code></td>
<td>
<p>character string of length 1 specifying a delimiter to separate cluster and app names</p>
</td></tr>
<tr><td><code id="getBetweenCellTypeCorrectedDE_+3A_return.details">return.details</code></td>
<td>
<p>logical, return detailed results</p>
</td></tr>
<tr><td><code id="getBetweenCellTypeCorrectedDE_+3A_only.paired">only.paired</code></td>
<td>
<p>only keep samples that that both cell types above the min.cell.count threshold</p>
</td></tr>
<tr><td><code id="getBetweenCellTypeCorrectedDE_+3A_correction">correction</code></td>
<td>
<p>fold change corrections per genes</p>
</td></tr>
<tr><td><code id="getBetweenCellTypeCorrectedDE_+3A_ref.level">ref.level</code></td>
<td>
<p>reference level on the basis of which the correction was calculated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns either a DESeq2::results() object, or if return.details=TRUE,
returns a list of the DESeq2::results(), the samples from the panel to use in this comparison, refgroups, altgroup, and samplegroups
</p>

<hr>
<h2 id='getBetweenCellTypeDE'>Compare two cell types across the entire panel</h2><span id='topic+getBetweenCellTypeDE'></span>

<h3>Description</h3>

<p>Compare two cell types across the entire panel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBetweenCellTypeDE(
  con.obj,
  groups = NULL,
  sample.groups = NULL,
  cooks.cutoff = FALSE,
  refgroup = NULL,
  altgroup = NULL,
  min.cell.count = 10,
  independent.filtering = FALSE,
  cluster.sep.chr = "&lt;!!&gt;",
  return.details = TRUE,
  only.paired = TRUE,
  remove.na = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getBetweenCellTypeDE_+3A_con.obj">con.obj</code></td>
<td>
<p>conos object</p>
</td></tr>
<tr><td><code id="getBetweenCellTypeDE_+3A_groups">groups</code></td>
<td>
<p>factor describing cell grouping (default=NULL)</p>
</td></tr>
<tr><td><code id="getBetweenCellTypeDE_+3A_sample.groups">sample.groups</code></td>
<td>
<p>a named list of two character vectors specifying the app groups to compare (default=NULL)</p>
</td></tr>
<tr><td><code id="getBetweenCellTypeDE_+3A_cooks.cutoff">cooks.cutoff</code></td>
<td>
<p>boolean cooksCutoff parameter for DESeq2 (default=FALSE)</p>
</td></tr>
<tr><td><code id="getBetweenCellTypeDE_+3A_refgroup">refgroup</code></td>
<td>
<p>cell type to compare to be used as reference (default=NULL)</p>
</td></tr>
<tr><td><code id="getBetweenCellTypeDE_+3A_altgroup">altgroup</code></td>
<td>
<p>cell type to compare to be used as ALT against refgroup (default=NULL)</p>
</td></tr>
<tr><td><code id="getBetweenCellTypeDE_+3A_min.cell.count">min.cell.count</code></td>
<td>
<p>numeric Minimum number of cells per celltype/sample combination to keep (default=10)</p>
</td></tr>
<tr><td><code id="getBetweenCellTypeDE_+3A_independent.filtering">independent.filtering</code></td>
<td>
<p>boolean Whether to use independentFiltering parameter for DESeq2 (default=FALSE)</p>
</td></tr>
<tr><td><code id="getBetweenCellTypeDE_+3A_cluster.sep.chr">cluster.sep.chr</code></td>
<td>
<p>character string of length 1 specifying a delimiter to separate cluster and app names (default='&lt;!!&gt;')</p>
</td></tr>
<tr><td><code id="getBetweenCellTypeDE_+3A_return.details">return.details</code></td>
<td>
<p>boolean Return detailed results (default=TRUE)</p>
</td></tr>
<tr><td><code id="getBetweenCellTypeDE_+3A_only.paired">only.paired</code></td>
<td>
<p>boolean Only keep samples that that both cell types above the min.cell.count threshold (default=TRUE)</p>
</td></tr>
<tr><td><code id="getBetweenCellTypeDE_+3A_remove.na">remove.na</code></td>
<td>
<p>boolean If TRUE, remove NAs from DESeq calculations (default=TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns either a DESeq2::results() object, or if return.details=TRUE,
returns a list of the DESeq2::results(), the samples from the panel to use in this comparison, refgroups, altgroup, and samplegroups
</p>

<hr>
<h2 id='getCellNames'>Access cell names from sample</h2><span id='topic+getCellNames'></span><span id='topic+getCellNames+2CPagoda2-method'></span><span id='topic+getCellNames+2Cseurat-method'></span><span id='topic+getCellNames+2CSeurat-method'></span><span id='topic+getCellNames+2CConos-method'></span>

<h3>Description</h3>

<p>Access cell names from sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCellNames(sample)

## S4 method for signature 'Pagoda2'
getCellNames(sample)

## S4 method for signature 'seurat'
getCellNames(sample)

## S4 method for signature 'Seurat'
getCellNames(sample)

## S4 method for signature 'Conos'
getCellNames(sample)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCellNames_+3A_sample">sample</code></td>
<td>
<p>sample from which to cell names</p>
</td></tr>
</table>

<hr>
<h2 id='getClustering'>Access clustering from sample</h2><span id='topic+getClustering'></span><span id='topic+getClustering+2CPagoda2-method'></span><span id='topic+getClustering+2Cseurat-method'></span><span id='topic+getClustering+2CSeurat-method'></span><span id='topic+getClustering+2CConos-method'></span>

<h3>Description</h3>

<p>Access clustering from sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getClustering(sample, type)

## S4 method for signature 'Pagoda2'
getClustering(sample, type)

## S4 method for signature 'seurat'
getClustering(sample, type)

## S4 method for signature 'Seurat'
getClustering(sample, type)

## S4 method for signature 'Conos'
getClustering(sample, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getClustering_+3A_sample">sample</code></td>
<td>
<p>sample from which to get the clustering</p>
</td></tr>
<tr><td><code id="getClustering_+3A_type">type</code></td>
<td>
<p>character Type of clustering to get</p>
</td></tr>
</table>

<hr>
<h2 id='getClusteringGroups'>Extract specified clustering from list of conos clusterings</h2><span id='topic+getClusteringGroups'></span>

<h3>Description</h3>

<p>Extract specified clustering from list of conos clusterings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getClusteringGroups(clusters, clustering)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getClusteringGroups_+3A_clusters">clusters</code></td>
<td>
<p>list of conos clusterings</p>
</td></tr>
<tr><td><code id="getClusteringGroups_+3A_clustering">clustering</code></td>
<td>
<p>name of extracted clustering</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of clusters, named with cell names
</p>

<hr>
<h2 id='getClusterRelationshipConsistency'>Evaluate consistency of cluster relationships
Using the clustering we are generating per-sample dendrograms
and we are examining their similarity between different samples
More information about similarity measures
&lt;https://www.rdocumentation.org/packages/dendextend/versions/1.8.0/topics/cor_cophenetic&gt;
&lt;https://www.rdocumentation.org/packages/dendextend/versions/1.8.0/topics/cor_bakers_gamma&gt;</h2><span id='topic+getClusterRelationshipConsistency'></span>

<h3>Description</h3>

<p>Evaluate consistency of cluster relationships
Using the clustering we are generating per-sample dendrograms
and we are examining their similarity between different samples
More information about similarity measures
&lt;https://www.rdocumentation.org/packages/dendextend/versions/1.8.0/topics/cor_cophenetic&gt;
&lt;https://www.rdocumentation.org/packages/dendextend/versions/1.8.0/topics/cor_bakers_gamma&gt;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getClusterRelationshipConsistency(p2list, pjc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getClusterRelationshipConsistency_+3A_p2list">p2list</code></td>
<td>
<p>list of pagoda2 object</p>
</td></tr>
<tr><td><code id="getClusterRelationshipConsistency_+3A_pjc">pjc</code></td>
<td>
<p>a clustering factor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of cophenetic and bakers_gama similarities of the dendrograms from each sample
</p>

<hr>
<h2 id='getCountMatrix'>Access count matrix from sample</h2><span id='topic+getCountMatrix'></span><span id='topic+getCountMatrix+2CPagoda2-method'></span><span id='topic+getCountMatrix+2Cseurat-method'></span><span id='topic+getCountMatrix+2CSeurat-method'></span>

<h3>Description</h3>

<p>Access count matrix from sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCountMatrix(sample, transposed = FALSE)

## S4 method for signature 'Pagoda2'
getCountMatrix(sample, transposed = FALSE)

## S4 method for signature 'seurat'
getCountMatrix(sample, transposed = FALSE)

## S4 method for signature 'Seurat'
getCountMatrix(sample, transposed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCountMatrix_+3A_sample">sample</code></td>
<td>
<p>sample from which to get the count matrix</p>
</td></tr>
<tr><td><code id="getCountMatrix_+3A_transposed">transposed</code></td>
<td>
<p>boolean Whether the count matrix should be transposed (default=FALSE)</p>
</td></tr>
</table>

<hr>
<h2 id='getEmbedding'>Access embedding from sample</h2><span id='topic+getEmbedding'></span><span id='topic+getEmbedding+2CPagoda2-method'></span><span id='topic+getEmbedding+2Cseurat-method'></span><span id='topic+getEmbedding+2CSeurat-method'></span><span id='topic+getEmbedding+2CConos-method'></span>

<h3>Description</h3>

<p>Access embedding from sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getEmbedding(sample, type)

## S4 method for signature 'Pagoda2'
getEmbedding(sample, type)

## S4 method for signature 'seurat'
getEmbedding(sample, type)

## S4 method for signature 'Seurat'
getEmbedding(sample, type)

## S4 method for signature 'Conos'
getEmbedding(sample, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getEmbedding_+3A_sample">sample</code></td>
<td>
<p>sample from which to get the embedding</p>
</td></tr>
<tr><td><code id="getEmbedding_+3A_type">type</code></td>
<td>
<p>character Type of embedding to get</p>
</td></tr>
</table>

<hr>
<h2 id='getGeneExpression'>Access gene expression from sample</h2><span id='topic+getGeneExpression'></span><span id='topic+getGeneExpression+2CPagoda2-method'></span><span id='topic+getGeneExpression+2CConos-method'></span><span id='topic+getGeneExpression+2CSeurat-method'></span><span id='topic+getGeneExpression+2Cseurat-method'></span>

<h3>Description</h3>

<p>Access gene expression from sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGeneExpression(sample, gene)

## S4 method for signature 'Pagoda2'
getGeneExpression(sample, gene)

## S4 method for signature 'Conos'
getGeneExpression(sample, gene)

## S4 method for signature 'Seurat'
getGeneExpression(sample, gene)

## S4 method for signature 'seurat'
getGeneExpression(sample, gene)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getGeneExpression_+3A_sample">sample</code></td>
<td>
<p>sample from which to access gene expression</p>
</td></tr>
<tr><td><code id="getGeneExpression_+3A_gene">gene</code></td>
<td>
<p>character vector Genes to access</p>
</td></tr>
</table>

<hr>
<h2 id='getGenes'>Access genes from sample</h2><span id='topic+getGenes'></span><span id='topic+getGenes+2CPagoda2-method'></span><span id='topic+getGenes+2Cseurat-method'></span><span id='topic+getGenes+2CSeurat-method'></span><span id='topic+getGenes+2CConos-method'></span>

<h3>Description</h3>

<p>Access genes from sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGenes(sample)

## S4 method for signature 'Pagoda2'
getGenes(sample)

## S4 method for signature 'seurat'
getGenes(sample)

## S4 method for signature 'Seurat'
getGenes(sample)

## S4 method for signature 'Conos'
getGenes(sample)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getGenes_+3A_sample">sample</code></td>
<td>
<p>sample from which to get genes</p>
</td></tr>
</table>

<hr>
<h2 id='getGlobalClusterMarkers'>Deprecated; Get markers for global clusters</h2><span id='topic+getGlobalClusterMarkers'></span>

<h3>Description</h3>

<p>Deprecated; Get markers for global clusters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGlobalClusterMarkers(
  conos.obj,
  clustering = "multi level",
  min.samples.expressing = 0,
  min.percent.samples.expressing = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getGlobalClusterMarkers_+3A_conos.obj">conos.obj</code></td>
<td>
<p>conos object</p>
</td></tr>
<tr><td><code id="getGlobalClusterMarkers_+3A_clustering">clustering</code></td>
<td>
<p>character Name of the clustering to use (default='multi level')</p>
</td></tr>
<tr><td><code id="getGlobalClusterMarkers_+3A_min.samples.expressing">min.samples.expressing</code></td>
<td>
<p>numeric Minimum number of samples that must have the genes upregulated in the respective cluster (default=0)</p>
</td></tr>
<tr><td><code id="getGlobalClusterMarkers_+3A_min.percent.samples.expressing">min.percent.samples.expressing</code></td>
<td>
<p>numeric Minumum percent of samples that must have the gene upregulated (default=0)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of consistent genes per each cluster
</p>

<hr>
<h2 id='getNeighborMatrix'>Establish rough neighbor matching between samples given their projections in a common space</h2><span id='topic+getNeighborMatrix'></span>

<h3>Description</h3>

<p>Establish rough neighbor matching between samples given their projections in a common space
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNeighborMatrix(
  p1,
  p2,
  k,
  k1 = k,
  matching = "mNN",
  metric = "angular",
  l2.sigma = 1e+05,
  cor.base = 1,
  min.similarity = 1e-05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getNeighborMatrix_+3A_p1">p1</code></td>
<td>
<p>projection of sample 1</p>
</td></tr>
<tr><td><code id="getNeighborMatrix_+3A_p2">p2</code></td>
<td>
<p>projection of sample 2</p>
</td></tr>
<tr><td><code id="getNeighborMatrix_+3A_k">k</code></td>
<td>
<p>neighborhood radius</p>
</td></tr>
<tr><td><code id="getNeighborMatrix_+3A_k1">k1</code></td>
<td>
<p>neighborhood radius</p>
</td></tr>
<tr><td><code id="getNeighborMatrix_+3A_matching">matching</code></td>
<td>
<p>string mNN (default) or NN (default='mNN')</p>
</td></tr>
<tr><td><code id="getNeighborMatrix_+3A_metric">metric</code></td>
<td>
<p>string Distance type (default: &quot;angular&quot;, can also be 'L2')</p>
</td></tr>
<tr><td><code id="getNeighborMatrix_+3A_l2.sigma">l2.sigma</code></td>
<td>
<p>numeric L2 distances get transformed as exp(-d/sigma) using this value (default=1e5)</p>
</td></tr>
<tr><td><code id="getNeighborMatrix_+3A_cor.base">cor.base</code></td>
<td>
<p>numeric (default=1)</p>
</td></tr>
<tr><td><code id="getNeighborMatrix_+3A_min.similarity">min.similarity</code></td>
<td>
<p>minimal similarity between two cells, required to have an edge</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with the similarity (!) values corresponding to weight (1-d for angular, and exp(-d/l2.sigma) for L2)
</p>

<hr>
<h2 id='getOdGenesUniformly'>Get top overdispersed genes across samples</h2><span id='topic+getOdGenesUniformly'></span>

<h3>Description</h3>

<p>Get top overdispersed genes across samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getOdGenesUniformly(samples, n.genes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getOdGenesUniformly_+3A_samples">samples</code></td>
<td>
<p>list of pagoda2 objects</p>
</td></tr>
<tr><td><code id="getOdGenesUniformly_+3A_n.genes">n.genes</code></td>
<td>
<p>number of overdispersed genes to extract</p>
</td></tr>
</table>

<hr>
<h2 id='getOverdispersedGenes'>Access overdispersed genes from sample</h2><span id='topic+getOverdispersedGenes'></span><span id='topic+getOverdispersedGenes+2CPagoda2-method'></span><span id='topic+getOverdispersedGenes+2Cseurat-method'></span><span id='topic+getOverdispersedGenes+2CSeurat-method'></span><span id='topic+getOverdispersedGenes+2CConos-method'></span>

<h3>Description</h3>

<p>Access overdispersed genes from sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getOverdispersedGenes(sample, n.odgenes = 1000)

## S4 method for signature 'Pagoda2'
getOverdispersedGenes(sample, n.odgenes = NULL)

## S4 method for signature 'seurat'
getOverdispersedGenes(sample, n.odgenes = NULL)

## S4 method for signature 'Seurat'
getOverdispersedGenes(sample, n.odgenes = NULL)

## S4 method for signature 'Conos'
getOverdispersedGenes(sample, n.odgenes = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getOverdispersedGenes_+3A_sample">sample</code></td>
<td>
<p>sample from which to overdispereed genes</p>
</td></tr>
<tr><td><code id="getOverdispersedGenes_+3A_n.odgenes">n.odgenes</code></td>
<td>
<p>numeric Number of overdisperesed genes to get</p>
</td></tr>
</table>

<hr>
<h2 id='getPca'>Access PCA from sample</h2><span id='topic+getPca'></span><span id='topic+getPca+2CPagoda2-method'></span><span id='topic+getPca+2Cseurat-method'></span><span id='topic+getPca+2CSeurat-method'></span>

<h3>Description</h3>

<p>Access PCA from sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPca(sample)

## S4 method for signature 'Pagoda2'
getPca(sample)

## S4 method for signature 'seurat'
getPca(sample)

## S4 method for signature 'Seurat'
getPca(sample)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPca_+3A_sample">sample</code></td>
<td>
<p>sample from which to access PCA</p>
</td></tr>
</table>

<hr>
<h2 id='getPerCellTypeDE'>Do differential expression for each cell type in a conos object between the specified subsets of apps</h2><span id='topic+getPerCellTypeDE'></span>

<h3>Description</h3>

<p>Do differential expression for each cell type in a conos object between the specified subsets of apps
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPerCellTypeDE(
  con.obj,
  groups = NULL,
  sample.groups = NULL,
  cooks.cutoff = FALSE,
  ref.level = NULL,
  min.cell.count = 10,
  remove.na = TRUE,
  max.cell.count = Inf,
  test = "LRT",
  independent.filtering = FALSE,
  n.cores = 1,
  cluster.sep.chr = "&lt;!!&gt;",
  return.details = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPerCellTypeDE_+3A_con.obj">con.obj</code></td>
<td>
<p>conos object</p>
</td></tr>
<tr><td><code id="getPerCellTypeDE_+3A_groups">groups</code></td>
<td>
<p>factor specifying cell types (default=NULL)</p>
</td></tr>
<tr><td><code id="getPerCellTypeDE_+3A_sample.groups">sample.groups</code></td>
<td>
<p>a list of two character vector specifying the app groups to compare (default=NULL)</p>
</td></tr>
<tr><td><code id="getPerCellTypeDE_+3A_cooks.cutoff">cooks.cutoff</code></td>
<td>
<p>boolean cooksCutoff for DESeq2 (default=FALSE)</p>
</td></tr>
<tr><td><code id="getPerCellTypeDE_+3A_ref.level">ref.level</code></td>
<td>
<p>the reference level of the sample.groups against which the comparison should be made (default=NULL). If NULL, will pick the first one.</p>
</td></tr>
<tr><td><code id="getPerCellTypeDE_+3A_min.cell.count">min.cell.count</code></td>
<td>
<p>integer Minimal number of cells per cluster for a sample to be taken into account in a comparison (default=10)</p>
</td></tr>
<tr><td><code id="getPerCellTypeDE_+3A_remove.na">remove.na</code></td>
<td>
<p>boolean If TRUE, remove NAs from DESeq calculations, which often arise as comparisons not possible (default=TRUE)</p>
</td></tr>
<tr><td><code id="getPerCellTypeDE_+3A_max.cell.count">max.cell.count</code></td>
<td>
<p>maximal number of cells per cluster per sample to include in a comparison (useful for comparing the number of DE genes between cell types) (default=Inf)</p>
</td></tr>
<tr><td><code id="getPerCellTypeDE_+3A_test">test</code></td>
<td>
<p>which DESeq2 test to use (options: &quot;LRT&quot; or &quot;Wald&quot;) (default=&quot;LRT&quot;)</p>
</td></tr>
<tr><td><code id="getPerCellTypeDE_+3A_independent.filtering">independent.filtering</code></td>
<td>
<p>boolean independentFiltering for DESeq2 (default=FALSE)</p>
</td></tr>
<tr><td><code id="getPerCellTypeDE_+3A_n.cores">n.cores</code></td>
<td>
<p>numeric Number of cores (default=1)</p>
</td></tr>
<tr><td><code id="getPerCellTypeDE_+3A_cluster.sep.chr">cluster.sep.chr</code></td>
<td>
<p>character string of length 1 specifying a delimiter to separate cluster and app names (default='&lt;!!&gt;')</p>
</td></tr>
<tr><td><code id="getPerCellTypeDE_+3A_return.details">return.details</code></td>
<td>
<p>boolean Whether to return verbose details (default=TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of differential expression results for every cell type
</p>

<hr>
<h2 id='getPercentGlobalClusters'>Evaluate how many clusters are global</h2><span id='topic+getPercentGlobalClusters'></span>

<h3>Description</h3>

<p>Evaluate how many clusters are global
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPercentGlobalClusters(
  p2list,
  pjc,
  pc.samples.cutoff = 0.9,
  min.cell.count.per.sample = 10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPercentGlobalClusters_+3A_p2list">p2list</code></td>
<td>
<p>list of pagoda2 object on which clustering was generated</p>
</td></tr>
<tr><td><code id="getPercentGlobalClusters_+3A_pjc">pjc</code></td>
<td>
<p>the result of joint clustering</p>
</td></tr>
<tr><td><code id="getPercentGlobalClusters_+3A_pc.samples.cutoff">pc.samples.cutoff</code></td>
<td>
<p>numeric The percent of the number of the total samples that a cluster has to span to be considered global (default=0.9)</p>
</td></tr>
<tr><td><code id="getPercentGlobalClusters_+3A_min.cell.count.per.sample">min.cell.count.per.sample</code></td>
<td>
<p>numeric The minimum number of cells of cluster in sample to be considered as represented in that sample (default=10)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>percent of clusters that are global given the above criteria
</p>

<hr>
<h2 id='getRawCountMatrix'>Access raw count matrix from sample</h2><span id='topic+getRawCountMatrix'></span><span id='topic+getRawCountMatrix+2CPagoda2-method'></span><span id='topic+getRawCountMatrix+2Cseurat-method'></span><span id='topic+getRawCountMatrix+2CSeurat-method'></span><span id='topic+getRawCountMatrix+2CConos-method'></span>

<h3>Description</h3>

<p>Access raw count matrix from sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRawCountMatrix(sample, transposed = FALSE)

## S4 method for signature 'Pagoda2'
getRawCountMatrix(sample, transposed = FALSE)

## S4 method for signature 'seurat'
getRawCountMatrix(sample, transposed = FALSE)

## S4 method for signature 'Seurat'
getRawCountMatrix(sample, transposed = FALSE)

## S4 method for signature 'Conos'
getRawCountMatrix(sample, transposed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRawCountMatrix_+3A_sample">sample</code></td>
<td>
<p>sample from which to get the raw count matrix</p>
</td></tr>
<tr><td><code id="getRawCountMatrix_+3A_transposed">transposed</code></td>
<td>
<p>boolean Whether the raw count matrix should be transposed (default=FALSE)</p>
</td></tr>
</table>

<hr>
<h2 id='getSampleNamePerCell'>Retrieve sample names per cell</h2><span id='topic+getSampleNamePerCell'></span>

<h3>Description</h3>

<p>Retrieve sample names per cell
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSampleNamePerCell(samples)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSampleNamePerCell_+3A_samples">samples</code></td>
<td>
<p>list of samples</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of sample names
getSampleNamePerCell(small_panel.preprocessed)
</p>

<hr>
<h2 id='greedyModularityCut'>Performs a greedy top-down selective cut to optmize modularity</h2><span id='topic+greedyModularityCut'></span>

<h3>Description</h3>

<p>Performs a greedy top-down selective cut to optmize modularity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>greedyModularityCut(
  wt,
  N,
  leaf.labels = NULL,
  minsize = 0,
  minbreadth = 0,
  flat.cut = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="greedyModularityCut_+3A_wt">wt</code></td>
<td>
<p>walktrap result</p>
</td></tr>
<tr><td><code id="greedyModularityCut_+3A_n">N</code></td>
<td>
<p>numeric Number of top greedy splits to take</p>
</td></tr>
<tr><td><code id="greedyModularityCut_+3A_leaf.labels">leaf.labels</code></td>
<td>
<p>leaf sample label factor, for breadth calculations - must be a named factor containing all wt$names, or if wt$names is null, a factor listing cells in the same order as wt leafs (default=NULL)</p>
</td></tr>
<tr><td><code id="greedyModularityCut_+3A_minsize">minsize</code></td>
<td>
<p>numeric Minimum size of the branch (in number of leafs) (default=0)</p>
</td></tr>
<tr><td><code id="greedyModularityCut_+3A_minbreadth">minbreadth</code></td>
<td>
<p>numeric Minimum allowed breadth of a branch (measured as normalized entropy) (default=0)</p>
</td></tr>
<tr><td><code id="greedyModularityCut_+3A_flat.cut">flat.cut</code></td>
<td>
<p>boolean Whether to simply take a flat cut (i.e. follow provided tree; default=TRUE). Does no observe minsize/minbreadth restrictions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list(hclust - hclust structure of the derived tree, leafContent - binary matrix with rows corresponding to old leaves, columns to new ones, deltaM - modularity increments)
</p>

<hr>
<h2 id='multimulti.community'>Constructrs a two-step clustering, first running multilevel.communities, and then walktrap.communities within each
These are combined into an overall hierarchy</h2><span id='topic+multimulti.community'></span>

<h3>Description</h3>

<p>Constructrs a two-step clustering, first running multilevel.communities, and then walktrap.communities within each
These are combined into an overall hierarchy
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multimulti.community(
  graph,
  n.cores = parallel::detectCores(logical = FALSE),
  hclust.link = "single",
  min.community.size = 10,
  verbose = FALSE,
  level = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multimulti.community_+3A_graph">graph</code></td>
<td>
<p>graph</p>
</td></tr>
<tr><td><code id="multimulti.community_+3A_n.cores">n.cores</code></td>
<td>
<p>numeric Number of cores to use (default=parallel::detectCores(logical=FALSE))</p>
</td></tr>
<tr><td><code id="multimulti.community_+3A_hclust.link">hclust.link</code></td>
<td>
<p>character Link function to use when clustering multilevel communities (based on collapsed graph connectivity) (default='single')</p>
</td></tr>
<tr><td><code id="multimulti.community_+3A_min.community.size">min.community.size</code></td>
<td>
<p>numeric Minimal community size parameter for the walktrap communities .. communities smaller than that will be merged (default=10)</p>
</td></tr>
<tr><td><code id="multimulti.community_+3A_verbose">verbose</code></td>
<td>
<p>boolean Whether to output progress messages (default=FALSE)</p>
</td></tr>
<tr><td><code id="multimulti.community_+3A_level">level</code></td>
<td>
<p>numeric What level of multitrap clustering to use in the starting step. By default, uses the top level. An integer can be specified for a lower level (i.e. 1) (default=NULL)</p>
</td></tr>
<tr><td><code id="multimulti.community_+3A_...">...</code></td>
<td>
<p>arguments passed to walktrap</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a fakeCommunities object that has methods membership() and as.dendrogram() to mimic regular igraph returns
</p>

<hr>
<h2 id='multitrap.community'>Constructs a two-step clustering, first running multilevel.communities, and then walktrap.communities within each
These are combined into an overall hierarchy</h2><span id='topic+multitrap.community'></span>

<h3>Description</h3>

<p>Constructs a two-step clustering, first running multilevel.communities, and then walktrap.communities within each
These are combined into an overall hierarchy
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multitrap.community(
  graph,
  n.cores = parallel::detectCores(logical = FALSE),
  hclust.link = "single",
  min.community.size = 10,
  verbose = FALSE,
  level = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multitrap.community_+3A_graph">graph</code></td>
<td>
<p>graph</p>
</td></tr>
<tr><td><code id="multitrap.community_+3A_n.cores">n.cores</code></td>
<td>
<p>numeric Number of cores to use (default=parallel::detectCores(logical=FALSE))</p>
</td></tr>
<tr><td><code id="multitrap.community_+3A_hclust.link">hclust.link</code></td>
<td>
<p>character Link function to use when clustering multilevel communities (based on collapsed graph connectivity) (default='single')</p>
</td></tr>
<tr><td><code id="multitrap.community_+3A_min.community.size">min.community.size</code></td>
<td>
<p>numeric Minimal community size parameter for the walktrap communities .. communities smaller than that will be merged (default=10)</p>
</td></tr>
<tr><td><code id="multitrap.community_+3A_verbose">verbose</code></td>
<td>
<p>boolean Whether to output progress messages (default=FALSE)</p>
</td></tr>
<tr><td><code id="multitrap.community_+3A_level">level</code></td>
<td>
<p>numeric What level of multitrap clustering to use in the starting step. By default, uses the top level. An integer can be specified for a lower level (i.e. 1) (default=NULL)</p>
</td></tr>
<tr><td><code id="multitrap.community_+3A_...">...</code></td>
<td>
<p>passed to walktrap</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a fakeCommunities object that has methods membership() and as.dendrogram() to mimic regular igraph returns
</p>

<hr>
<h2 id='namedLevels'>Get a vector with the levels of a factor named with their
own name. Useful for lapply loops over factor levels</h2><span id='topic+namedLevels'></span>

<h3>Description</h3>

<p>Get a vector with the levels of a factor named with their
own name. Useful for lapply loops over factor levels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>namedLevels(f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="namedLevels_+3A_f">f</code></td>
<td>
<p>a factor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named character vector of factor levels
</p>

<hr>
<h2 id='namedNames'>Get a vector of the names of an object named by the names themselves.
This is useful with lapply when passing names of objects as it ensures that the output list
is also named</h2><span id='topic+namedNames'></span>

<h3>Description</h3>

<p>Get a vector of the names of an object named by the names themselves.
This is useful with lapply when passing names of objects as it ensures that the output list
is also named
</p>


<h3>Usage</h3>

<pre><code class='language-R'>namedNames(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="namedNames_+3A_g">g</code></td>
<td>
<p>an objects on which we can call names()</p>
</td></tr>
</table>

<hr>
<h2 id='p2app4conos'>Utility function to generate a pagoda2 app from a conos object</h2><span id='topic+p2app4conos'></span>

<h3>Description</h3>

<p>Utility function to generate a pagoda2 app from a conos object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p2app4conos(
  conos,
  cdl = NULL,
  metadata = NULL,
  filename = "conos_app.bin",
  save = TRUE,
  n.cores = 1,
  n.odgenes = 3000,
  nPcs = 100,
  k = 30,
  perplexity = 50,
  log.scale = TRUE,
  trim = 10,
  keep.genes = NULL,
  min.cells.per.gene = 0,
  min.transcripts.per.cell = 100,
  get.largevis = TRUE,
  get.tsne = TRUE,
  make.geneknn = TRUE,
  go.env = NULL,
  cell.subset = NULL,
  max.cells = Inf,
  additional.embeddings = NULL,
  test.pathway.overdispersion = FALSE,
  organism = NULL,
  return.details = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p2app4conos_+3A_conos">conos</code></td>
<td>
<p>Conos object</p>
</td></tr>
<tr><td><code id="p2app4conos_+3A_cdl">cdl</code></td>
<td>
<p>list Optional list of raw matrices (so that gene merging doesn't have to be redone) (default=NULL)</p>
</td></tr>
<tr><td><code id="p2app4conos_+3A_metadata">metadata</code></td>
<td>
<p>list Optional list of (named) metadata factors (default=NULL)</p>
</td></tr>
<tr><td><code id="p2app4conos_+3A_filename">filename</code></td>
<td>
<p>string Name of the *.bin file to seralize for the pagoda2 application if save=TRUE (default='conos_app.bin')</p>
</td></tr>
<tr><td><code id="p2app4conos_+3A_save">save</code></td>
<td>
<p>boolean Save serialized *bin file specified in filename (default=TRUE)</p>
</td></tr>
<tr><td><code id="p2app4conos_+3A_n.cores">n.cores</code></td>
<td>
<p>integer Number of cores (default=1)</p>
</td></tr>
<tr><td><code id="p2app4conos_+3A_n.odgenes">n.odgenes</code></td>
<td>
<p>numeric Number of top overdispersed genes to use (dfault=3e3). From pagoda2::basicP2proc().</p>
</td></tr>
<tr><td><code id="p2app4conos_+3A_npcs">nPcs</code></td>
<td>
<p>numeric Number of PCs to use (default=100). From pagoda2::basicP2proc().</p>
</td></tr>
<tr><td><code id="p2app4conos_+3A_k">k</code></td>
<td>
<p>numeric Default number of neighbors to use in kNN graph (default=30). From pagoda2::basicP2proc().</p>
</td></tr>
<tr><td><code id="p2app4conos_+3A_perplexity">perplexity</code></td>
<td>
<p>numeric Perplexity to use in generating tSNE and largeVis embeddings (default=50). From pagoda2::basicP2proc().</p>
</td></tr>
<tr><td><code id="p2app4conos_+3A_log.scale">log.scale</code></td>
<td>
<p>boolean Whether to use log scale normalization (default=TRUE). From pagoda2::basicP2proc().</p>
</td></tr>
<tr><td><code id="p2app4conos_+3A_trim">trim</code></td>
<td>
<p>numeric Number of cells to trim in winsorization (default=10). From pagoda2::basicP2proc().</p>
</td></tr>
<tr><td><code id="p2app4conos_+3A_keep.genes">keep.genes</code></td>
<td>
<p>optional set of genes to keep from being filtered out (even at low counts) (default=NULL). From pagoda2::basicP2proc().</p>
</td></tr>
<tr><td><code id="p2app4conos_+3A_min.cells.per.gene">min.cells.per.gene</code></td>
<td>
<p>numeric Minimal number of cells required for gene to be kept (unless listed in keep.genes) (default=0). From pagoda2::basicP2proc().</p>
</td></tr>
<tr><td><code id="p2app4conos_+3A_min.transcripts.per.cell">min.transcripts.per.cell</code></td>
<td>
<p>numeric Minimumal number of molecules/reads for a cell to be admitted (default=100). From pagoda2::basicP2proc().</p>
</td></tr>
<tr><td><code id="p2app4conos_+3A_get.largevis">get.largevis</code></td>
<td>
<p>boolean Whether to caluclate largeVis embedding (default=TRUE). From pagoda2::basicP2proc().</p>
</td></tr>
<tr><td><code id="p2app4conos_+3A_get.tsne">get.tsne</code></td>
<td>
<p>boolean Whether to calculate tSNE embedding (default=TRUE). From pagoda2::basicP2proc().</p>
</td></tr>
<tr><td><code id="p2app4conos_+3A_make.geneknn">make.geneknn</code></td>
<td>
<p>boolean Whether pre-calculate gene kNN (for gene search) (default=TRUE). From pagoda2::basicP2proc().</p>
</td></tr>
<tr><td><code id="p2app4conos_+3A_go.env">go.env</code></td>
<td>
<p>GO environment for the organism of interest (default=NULL)</p>
</td></tr>
<tr><td><code id="p2app4conos_+3A_cell.subset">cell.subset</code></td>
<td>
<p>string Cells to subset with the conos embedding conos$embedding. If NULL, uses all cells via rownames(conos$embedding) (default=NULL)</p>
</td></tr>
<tr><td><code id="p2app4conos_+3A_max.cells">max.cells</code></td>
<td>
<p>numeric Limit to the cells that are included in the conos. If Inf, there is no limit (default=Inf)</p>
</td></tr>
<tr><td><code id="p2app4conos_+3A_additional.embeddings">additional.embeddings</code></td>
<td>
<p>list Additional embeddings to add to conos for the pagoda2 app (default=NULL)</p>
</td></tr>
<tr><td><code id="p2app4conos_+3A_test.pathway.overdispersion">test.pathway.overdispersion</code></td>
<td>
<p>boolean Find all IDs using GO category against either org.Hs.eg.db ('hs') or org.Mm.eg.db ('mm') (default=FALSE</p>
</td></tr>
<tr><td><code id="p2app4conos_+3A_organism">organism</code></td>
<td>
<p>string Organism of interest, either 'hs' (Homo sapiens) or 'mm' (Mus musculus, i.e. mouse) (default=NULL). Only used if test.pathway.overdispersion is TRUE. If NULL and test.pathway.overdispersion=TRUE, then 'hs' is used.</p>
</td></tr>
<tr><td><code id="p2app4conos_+3A_return.details">return.details</code></td>
<td>
<p>boolean If TRUE, return list of p2 application, pagoda2 object, list of raw matrices, and cell names. If FALSE, simply return pagoda2 app object. (default=FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>pagoda2 app object
</p>

<hr>
<h2 id='plotClusterBarplots'>Plots barplots per sample of composition of each pagoda2 application based on
selected clustering</h2><span id='topic+plotClusterBarplots'></span>

<h3>Description</h3>

<p>Plots barplots per sample of composition of each pagoda2 application based on
selected clustering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotClusterBarplots(
  conos.obj = NULL,
  clustering = NULL,
  groups = NULL,
  sample.factor = NULL,
  show.entropy = TRUE,
  show.size = TRUE,
  show.composition = TRUE,
  legend.height = 0.2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotClusterBarplots_+3A_conos.obj">conos.obj</code></td>
<td>
<p>A conos object (default=NULL)</p>
</td></tr>
<tr><td><code id="plotClusterBarplots_+3A_clustering">clustering</code></td>
<td>
<p>name of clustering in the current object (default=NULL)</p>
</td></tr>
<tr><td><code id="plotClusterBarplots_+3A_groups">groups</code></td>
<td>
<p>arbitrary grouping of cells (to use instead of the clustering) (default=NULL)</p>
</td></tr>
<tr><td><code id="plotClusterBarplots_+3A_sample.factor">sample.factor</code></td>
<td>
<p>a factor describing cell membership in the samples (or some other category) (default=NULL). This will default to samples if not provided.</p>
</td></tr>
<tr><td><code id="plotClusterBarplots_+3A_show.entropy">show.entropy</code></td>
<td>
<p>boolean Whether to include entropy barplot (default=TRUE)</p>
</td></tr>
<tr><td><code id="plotClusterBarplots_+3A_show.size">show.size</code></td>
<td>
<p>boolean Whether to include size barplot (default=TRUE)</p>
</td></tr>
<tr><td><code id="plotClusterBarplots_+3A_show.composition">show.composition</code></td>
<td>
<p>boolean Whether to include composition barplot (default=TRUE)</p>
</td></tr>
<tr><td><code id="plotClusterBarplots_+3A_legend.height">legend.height</code></td>
<td>
<p>numeric Relative hight of the legend panel (default=0.2)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object
</p>

<hr>
<h2 id='plotClusterBoxPlotsByAppType'>Generate boxplot per cluster of the proportion of cells in each celltype</h2><span id='topic+plotClusterBoxPlotsByAppType'></span>

<h3>Description</h3>

<p>Generate boxplot per cluster of the proportion of cells in each celltype
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotClusterBoxPlotsByAppType(
  conos.obj,
  clustering = NULL,
  apptypes = NULL,
  return.details = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotClusterBoxPlotsByAppType_+3A_conos.obj">conos.obj</code></td>
<td>
<p>conos object</p>
</td></tr>
<tr><td><code id="plotClusterBoxPlotsByAppType_+3A_clustering">clustering</code></td>
<td>
<p>name of the clustering to use (default=NULL)</p>
</td></tr>
<tr><td><code id="plotClusterBoxPlotsByAppType_+3A_apptypes">apptypes</code></td>
<td>
<p>a factor specifying how to group the samples (default=NULL)</p>
</td></tr>
<tr><td><code id="plotClusterBoxPlotsByAppType_+3A_return.details">return.details</code></td>
<td>
<p>boolean If TRUE return a list with the plot and the summary data.frame (default=FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boxplot per cluster of the proportion of cells in each celltype
</p>

<hr>
<h2 id='plotComponentVariance'>Plot fraction of variance explained by the successive reduced space components (PCA, CPCA)</h2><span id='topic+plotComponentVariance'></span>

<h3>Description</h3>

<p>Requires buildGraph() or updatePairs() to be ran first with the argument score.component.variance=TRUE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotComponentVariance(
  conos.obj,
  space = "PCA",
  plot.theme = ggplot2::theme_bw()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotComponentVariance_+3A_conos.obj">conos.obj</code></td>
<td>
<p>conos object</p>
</td></tr>
<tr><td><code id="plotComponentVariance_+3A_space">space</code></td>
<td>
<p>character Reduction space to be analyzed (currently, component variance scoring is only supported by PCA and CPCA) (default='PCA')</p>
</td></tr>
<tr><td><code id="plotComponentVariance_+3A_plot.theme">plot.theme</code></td>
<td>
<p>ggplot theme (default=ggplot2::theme_bw()). Refer to &lt;https://ggplot2.tidyverse.org/reference/ggtheme.html&gt; for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot
</p>

<hr>
<h2 id='plotDEheatmap'>Plot a heatmap of differential genes</h2><span id='topic+plotDEheatmap'></span>

<h3>Description</h3>

<p>Plot a heatmap of differential genes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotDEheatmap(
  con,
  groups,
  de = NULL,
  min.auc = NULL,
  min.specificity = NULL,
  min.precision = NULL,
  n.genes.per.cluster = 10,
  additional.genes = NULL,
  exclude.genes = NULL,
  labeled.gene.subset = NULL,
  expression.quantile = 0.99,
  pal = colorRampPalette(c("dodgerblue1", "grey95", "indianred1"))(1024),
  ordering = "-AUC",
  column.metadata = NULL,
  show.gene.clusters = TRUE,
  remove.duplicates = TRUE,
  column.metadata.colors = NULL,
  show.cluster.legend = TRUE,
  show_heatmap_legend = FALSE,
  border = TRUE,
  return.details = FALSE,
  row.label.font.size = 10,
  order.clusters = FALSE,
  split = FALSE,
  split.gap = 0,
  cell.order = NULL,
  averaging.window = 0,
  max.cells = Inf,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotDEheatmap_+3A_con">con</code></td>
<td>
<p>conos (or p2) object</p>
</td></tr>
<tr><td><code id="plotDEheatmap_+3A_groups">groups</code></td>
<td>
<p>groups in which the DE genes were determined (so that the cells can be ordered correctly)</p>
</td></tr>
<tr><td><code id="plotDEheatmap_+3A_de">de</code></td>
<td>
<p>differential expression result (list of data frames) (default=NULL)</p>
</td></tr>
<tr><td><code id="plotDEheatmap_+3A_min.auc">min.auc</code></td>
<td>
<p>optional minimum AUC threshold (default=NULL)</p>
</td></tr>
<tr><td><code id="plotDEheatmap_+3A_min.specificity">min.specificity</code></td>
<td>
<p>optional minimum specificity threshold (default=NULL)</p>
</td></tr>
<tr><td><code id="plotDEheatmap_+3A_min.precision">min.precision</code></td>
<td>
<p>optional minimum precision threshold (default=NULL)</p>
</td></tr>
<tr><td><code id="plotDEheatmap_+3A_n.genes.per.cluster">n.genes.per.cluster</code></td>
<td>
<p>numeric Number of genes to show for each cluster (default=10)</p>
</td></tr>
<tr><td><code id="plotDEheatmap_+3A_additional.genes">additional.genes</code></td>
<td>
<p>optional additional genes to include (the genes will be assigned to the closest cluster) (default=NULL)</p>
</td></tr>
<tr><td><code id="plotDEheatmap_+3A_exclude.genes">exclude.genes</code></td>
<td>
<p>an optional list of genes to exclude from the heatmap (default=NULL)</p>
</td></tr>
<tr><td><code id="plotDEheatmap_+3A_labeled.gene.subset">labeled.gene.subset</code></td>
<td>
<p>a subset of gene names to show (instead of all genes) (default=NULL). Can be a vector of gene names, or a number of top genes (in each cluster) to show the names for.</p>
</td></tr>
<tr><td><code id="plotDEheatmap_+3A_expression.quantile">expression.quantile</code></td>
<td>
<p>numeric Expression quantile to show (default=0.99)</p>
</td></tr>
<tr><td><code id="plotDEheatmap_+3A_pal">pal</code></td>
<td>
<p>palette to use for the main heatmap (default=colorRampPalette(c('dodgerblue1','grey95','indianred1'))(1024))</p>
</td></tr>
<tr><td><code id="plotDEheatmap_+3A_ordering">ordering</code></td>
<td>
<p>order by which the top DE genes (to be shown) are determined (default &quot;-AUC&quot;)</p>
</td></tr>
<tr><td><code id="plotDEheatmap_+3A_column.metadata">column.metadata</code></td>
<td>
<p>additional column metadata, passed either as a data.frame with rows named as cells, or as a list of named cell factors (default=NULL).</p>
</td></tr>
<tr><td><code id="plotDEheatmap_+3A_show.gene.clusters">show.gene.clusters</code></td>
<td>
<p>whether to show gene cluster color codes</p>
</td></tr>
<tr><td><code id="plotDEheatmap_+3A_remove.duplicates">remove.duplicates</code></td>
<td>
<p>remove duplicated genes (leaving them in just one of the clusters)</p>
</td></tr>
<tr><td><code id="plotDEheatmap_+3A_column.metadata.colors">column.metadata.colors</code></td>
<td>
<p>a list of color specifications for additional column metadata, specified according to the HeatmapMetadata format. Use &quot;clusters&quot; slot to specify cluster colors.</p>
</td></tr>
<tr><td><code id="plotDEheatmap_+3A_show.cluster.legend">show.cluster.legend</code></td>
<td>
<p>boolean Whether to show the cluster legend (default=TRUE)</p>
</td></tr>
<tr><td><code id="plotDEheatmap_+3A_show_heatmap_legend">show_heatmap_legend</code></td>
<td>
<p>boolean Whether to show the expression heatmap legend (default=FALSE)</p>
</td></tr>
<tr><td><code id="plotDEheatmap_+3A_border">border</code></td>
<td>
<p>boolean Whether to show borders around the heatmap and annotations (default=TRUE)</p>
</td></tr>
<tr><td><code id="plotDEheatmap_+3A_return.details">return.details</code></td>
<td>
<p>boolean If TRUE will return a list containing the heatmap (ha), but also raw matrix (x), expression list (expl) and other info to produce the heatmap on your own (default=FALSE).</p>
</td></tr>
<tr><td><code id="plotDEheatmap_+3A_row.label.font.size">row.label.font.size</code></td>
<td>
<p>numeric Font size for the row labels (default=10)</p>
</td></tr>
<tr><td><code id="plotDEheatmap_+3A_order.clusters">order.clusters</code></td>
<td>
<p>boolean Whether to re-order the clusters according to the similarity of the expression patterns (of the genes being shown) (default=FALSE)</p>
</td></tr>
<tr><td><code id="plotDEheatmap_+3A_split">split</code></td>
<td>
<p>boolean Whether to use arguments &quot;row_split&quot; and &quot;column_split&quot; in ComplexHeatmap::Heatmap() (default=FALSE). These arguments are categorical vectors used to split the rows/columns in the heatmap.</p>
</td></tr>
<tr><td><code id="plotDEheatmap_+3A_split.gap">split.gap</code></td>
<td>
<p>numeric Value of millimeters &quot;mm&quot; to use for 'row_gap' and 'column_gap' (default=0). If split is FALSE, this argument is ignored.</p>
</td></tr>
<tr><td><code id="plotDEheatmap_+3A_cell.order">cell.order</code></td>
<td>
<p>explicitly supply cell order (default=NULL)</p>
</td></tr>
<tr><td><code id="plotDEheatmap_+3A_averaging.window">averaging.window</code></td>
<td>
<p>numeric Optional window averaging between neighboring cells within each group (turned off by default) - useful when very large number of cells shown (requires zoo package) (default=0)</p>
</td></tr>
<tr><td><code id="plotDEheatmap_+3A_max.cells">max.cells</code></td>
<td>
<p>numeric Maximum cells to include in any given group (default: Inf)</p>
</td></tr>
<tr><td><code id="plotDEheatmap_+3A_...">...</code></td>
<td>
<p>extra parameters are passed to ComplexHeatmap::Heatmap() call</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ComplexHeatmap::Heatmap object (see return.details param for other output)
</p>

<hr>
<h2 id='plotEmbeddings'>Plot panel of specified embeddings</h2><span id='topic+plotEmbeddings'></span>

<h3>Description</h3>

<p>Plot panel of specified embeddings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotEmbeddings(
  embeddings,
  groups = NULL,
  colors = NULL,
  ncol = NULL,
  nrow = NULL,
  raster = FALSE,
  raster.dpi = 300,
  panel.size = NULL,
  adjust.func = NULL,
  title.size = 6,
  adj.list = NULL,
  subset = NULL,
  return.plotlist = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotEmbeddings_+3A_embeddings">embeddings</code></td>
<td>
<p>list of two-column matrices with (x, y) coordinates of the embeddings. Each mutrix must have cell names in rownames.</p>
</td></tr>
<tr><td><code id="plotEmbeddings_+3A_groups">groups</code></td>
<td>
<p>vector of cluster labels, names contain cell names (default=NULL)</p>
</td></tr>
<tr><td><code id="plotEmbeddings_+3A_colors">colors</code></td>
<td>
<p>vector of numbers, which must be shown with point colors, names contain cell names (default=NULL). This argument is ignored if groups are provided.</p>
</td></tr>
<tr><td><code id="plotEmbeddings_+3A_ncol">ncol</code></td>
<td>
<p>number of columns in the panel (default=NULL)</p>
</td></tr>
<tr><td><code id="plotEmbeddings_+3A_nrow">nrow</code></td>
<td>
<p>number of rows in the panel (default=NULL)</p>
</td></tr>
<tr><td><code id="plotEmbeddings_+3A_raster">raster</code></td>
<td>
<p>boolean whether layer with the points be rasterized (default=FALSE). Setting of this argument to TRUE is useful when you need to export a plot with large number of points</p>
</td></tr>
<tr><td><code id="plotEmbeddings_+3A_raster.dpi">raster.dpi</code></td>
<td>
<p>dpi of the rasterized plot. (default=300). Ignored if raster == FALSE.</p>
</td></tr>
<tr><td><code id="plotEmbeddings_+3A_panel.size">panel.size</code></td>
<td>
<p>vector with two numbers, which specified (width, height) of the panel in inches (default=NULL). Ignored if raster is FALSE.</p>
</td></tr>
<tr><td><code id="plotEmbeddings_+3A_adjust.func">adjust.func</code></td>
<td>
<p>function to adjust plots before combining them to single panel (default=NULL). Can be used, for example, to provide color pallette of guides of the plots.</p>
</td></tr>
<tr><td><code id="plotEmbeddings_+3A_subset">subset</code></td>
<td>
<p>a subset of cells to show (vector of cell names) (default=NULL)</p>
</td></tr>
<tr><td><code id="plotEmbeddings_+3A_return.plotlist">return.plotlist</code></td>
<td>
<p>boolean Whether to return a list of ggplot objects instead of a combined plot (default=FALSE)</p>
</td></tr>
<tr><td><code id="plotEmbeddings_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="ggrepel.html#topic+geom_text_repel">ggrepel::geom_label_repel</a></code>
</p>

<dl>
<dt><code>mapping</code></dt><dd><p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes</a></code> or
<code><a href="ggplot2.html#topic+aes_">aes_</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), is combined with the default mapping at the top level of the
plot. You only need to supply <code>mapping</code> if there isn't a mapping
defined for the plot.</p>
</dd>
<dt><code>data</code></dt><dd><p>A data frame. If specified, overrides the default data frame
defined at the top level of the plot.</p>
</dd>
<dt><code>stat</code></dt><dd><p>The statistical transformation to use on the data for this
layer, as a string.</p>
</dd>
<dt><code>position</code></dt><dd><p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</dd>
<dt><code>parse</code></dt><dd><p>If TRUE, the labels will be parsed into expressions and
displayed as described in ?plotmath</p>
</dd>
<dt><code>box.padding</code></dt><dd><p>Amount of padding around bounding box, as unit or number.
Defaults to 0.25. (Default unit is lines, but other units can be specified
by passing <code>unit(x, "units")</code>).</p>
</dd>
<dt><code>label.padding</code></dt><dd><p>Amount of padding around label, as unit or number.
Defaults to 0.25. (Default unit is lines, but other units can be specified
by passing <code>unit(x, "units")</code>).</p>
</dd>
<dt><code>point.padding</code></dt><dd><p>Amount of padding around labeled point, as unit or
number. Defaults to 0. (Default unit is lines, but other units can be
specified by passing <code>unit(x, "units")</code>).</p>
</dd>
<dt><code>label.r</code></dt><dd><p>Radius of rounded corners, as unit or number. Defaults
to 0.15. (Default unit is lines, but other units can be specified by
passing <code>unit(x, "units")</code>).</p>
</dd>
<dt><code>label.size</code></dt><dd><p>Size of label border, in mm.</p>
</dd>
<dt><code>min.segment.length</code></dt><dd><p>Skip drawing segments shorter than this, as unit or
number. Defaults to 0.5. (Default unit is lines, but other units can be
specified by passing <code>unit(x, "units")</code>).</p>
</dd>
<dt><code>arrow</code></dt><dd><p>specification for arrow heads, as created by <code><a href="grid.html#topic+arrow">arrow</a></code></p>
</dd>
<dt><code>force</code></dt><dd><p>Force of repulsion between overlapping text labels. Defaults
to 1.</p>
</dd>
<dt><code>force_pull</code></dt><dd><p>Force of attraction between a text label and its
corresponding data point. Defaults to 1.</p>
</dd>
<dt><code>max.time</code></dt><dd><p>Maximum number of seconds to try to resolve overlaps.
Defaults to 0.5.</p>
</dd>
<dt><code>max.iter</code></dt><dd><p>Maximum number of iterations to try to resolve overlaps.
Defaults to 10000.</p>
</dd>
<dt><code>max.overlaps</code></dt><dd><p>Exclude text labels that overlap too many things.
Defaults to 10.</p>
</dd>
<dt><code>nudge_x,nudge_y</code></dt><dd><p>Horizontal and vertical adjustments to nudge the
starting position of each text label. The units for <code>nudge_x</code> and
<code>nudge_y</code> are the same as for the data units on the x-axis and y-axis.</p>
</dd>
<dt><code>xlim,ylim</code></dt><dd><p>Limits for the x and y axes. Text labels will be constrained
to these limits. By default, text labels are constrained to the entire plot
area.</p>
</dd>
<dt><code>na.rm</code></dt><dd><p>If <code>FALSE</code> (the default), removes missing values with
a warning.  If <code>TRUE</code> silently removes missing values.</p>
</dd>
<dt><code>direction</code></dt><dd><p>&quot;both&quot;, &quot;x&quot;, or &quot;y&quot; &ndash; direction in which to adjust position of labels</p>
</dd>
<dt><code>seed</code></dt><dd><p>Random seed passed to <code><a href="base.html#topic+set.seed">set.seed</a></code>. Defaults to
<code>NA</code>, which means that <code>set.seed</code> will not be called.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>If <code>TRUE</code>, some diagnostics of the repel algorithm are printed</p>
</dd>
<dt><code>inherit.aes</code></dt><dd><p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders</a></code>.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 object with the panel of plots
</p>

<hr>
<h2 id='plotSamples'>Plot panel of specified embeddings, extracting them from pagoda2 objects</h2><span id='topic+plotSamples'></span>

<h3>Description</h3>

<p>Plot panel of specified embeddings, extracting them from pagoda2 objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSamples(
  samples,
  groups = NULL,
  colors = NULL,
  gene = NULL,
  embedding.type = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSamples_+3A_samples">samples</code></td>
<td>
<p>list of pagoda2 or Seurat objects</p>
</td></tr>
<tr><td><code id="plotSamples_+3A_groups">groups</code></td>
<td>
<p>vector of cluster labels, names contain cell names (default=NULL)</p>
</td></tr>
<tr><td><code id="plotSamples_+3A_colors">colors</code></td>
<td>
<p>vector of numbers, which must be shown with point colors, names contain cell names (default=NULL). This argument is ignored if groups are provided.</p>
</td></tr>
<tr><td><code id="plotSamples_+3A_gene">gene</code></td>
<td>
<p>gene name (default=NULL). If this parameter is provided, points are colored by expression of this gene.</p>
</td></tr>
<tr><td><code id="plotSamples_+3A_embedding.type">embedding.type</code></td>
<td>
<p>type of embedding (default=NULL). If embedding.type is NULL, this defaults to 'tSNE'. If a matrix is passed, it is interpreted as an actual embedding (then first two columns are interpreted as x/y coordinates, row names must be cell names).</p>
</td></tr>
<tr><td><code id="plotSamples_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="ggrepel.html#topic+geom_text_repel">ggrepel::geom_label_repel</a></code>
</p>

<dl>
<dt><code>mapping</code></dt><dd><p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes</a></code> or
<code><a href="ggplot2.html#topic+aes_">aes_</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), is combined with the default mapping at the top level of the
plot. You only need to supply <code>mapping</code> if there isn't a mapping
defined for the plot.</p>
</dd>
<dt><code>data</code></dt><dd><p>A data frame. If specified, overrides the default data frame
defined at the top level of the plot.</p>
</dd>
<dt><code>stat</code></dt><dd><p>The statistical transformation to use on the data for this
layer, as a string.</p>
</dd>
<dt><code>position</code></dt><dd><p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</dd>
<dt><code>parse</code></dt><dd><p>If TRUE, the labels will be parsed into expressions and
displayed as described in ?plotmath</p>
</dd>
<dt><code>box.padding</code></dt><dd><p>Amount of padding around bounding box, as unit or number.
Defaults to 0.25. (Default unit is lines, but other units can be specified
by passing <code>unit(x, "units")</code>).</p>
</dd>
<dt><code>label.padding</code></dt><dd><p>Amount of padding around label, as unit or number.
Defaults to 0.25. (Default unit is lines, but other units can be specified
by passing <code>unit(x, "units")</code>).</p>
</dd>
<dt><code>point.padding</code></dt><dd><p>Amount of padding around labeled point, as unit or
number. Defaults to 0. (Default unit is lines, but other units can be
specified by passing <code>unit(x, "units")</code>).</p>
</dd>
<dt><code>label.r</code></dt><dd><p>Radius of rounded corners, as unit or number. Defaults
to 0.15. (Default unit is lines, but other units can be specified by
passing <code>unit(x, "units")</code>).</p>
</dd>
<dt><code>label.size</code></dt><dd><p>Size of label border, in mm.</p>
</dd>
<dt><code>min.segment.length</code></dt><dd><p>Skip drawing segments shorter than this, as unit or
number. Defaults to 0.5. (Default unit is lines, but other units can be
specified by passing <code>unit(x, "units")</code>).</p>
</dd>
<dt><code>arrow</code></dt><dd><p>specification for arrow heads, as created by <code><a href="grid.html#topic+arrow">arrow</a></code></p>
</dd>
<dt><code>force</code></dt><dd><p>Force of repulsion between overlapping text labels. Defaults
to 1.</p>
</dd>
<dt><code>force_pull</code></dt><dd><p>Force of attraction between a text label and its
corresponding data point. Defaults to 1.</p>
</dd>
<dt><code>max.time</code></dt><dd><p>Maximum number of seconds to try to resolve overlaps.
Defaults to 0.5.</p>
</dd>
<dt><code>max.iter</code></dt><dd><p>Maximum number of iterations to try to resolve overlaps.
Defaults to 10000.</p>
</dd>
<dt><code>max.overlaps</code></dt><dd><p>Exclude text labels that overlap too many things.
Defaults to 10.</p>
</dd>
<dt><code>nudge_x,nudge_y</code></dt><dd><p>Horizontal and vertical adjustments to nudge the
starting position of each text label. The units for <code>nudge_x</code> and
<code>nudge_y</code> are the same as for the data units on the x-axis and y-axis.</p>
</dd>
<dt><code>xlim,ylim</code></dt><dd><p>Limits for the x and y axes. Text labels will be constrained
to these limits. By default, text labels are constrained to the entire plot
area.</p>
</dd>
<dt><code>na.rm</code></dt><dd><p>If <code>FALSE</code> (the default), removes missing values with
a warning.  If <code>TRUE</code> silently removes missing values.</p>
</dd>
<dt><code>direction</code></dt><dd><p>&quot;both&quot;, &quot;x&quot;, or &quot;y&quot; &ndash; direction in which to adjust position of labels</p>
</dd>
<dt><code>seed</code></dt><dd><p>Random seed passed to <code><a href="base.html#topic+set.seed">set.seed</a></code>. Defaults to
<code>NA</code>, which means that <code>set.seed</code> will not be called.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>If <code>TRUE</code>, some diagnostics of the repel algorithm are printed</p>
</dd>
<dt><code>inherit.aes</code></dt><dd><p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders</a></code>.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 object with the panel of plots
</p>

<hr>
<h2 id='projectKNNs'>Project a distance matrix into a lower-dimensional space.</h2><span id='topic+projectKNNs'></span>

<h3>Description</h3>

<p>Takes as input a sparse matrix of the edge weights connecting each node to its nearest neighbors, and outputs
a matrix of coordinates embedding the inputs in a lower-dimensional space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>projectKNNs(
  wij,
  dim = 2,
  sgd_batches = NULL,
  M = 5,
  gamma = 7,
  alpha = 1,
  rho = 1,
  coords = NULL,
  useDegree = FALSE,
  momentum = NULL,
  seed = NULL,
  threads = NULL,
  verbose = getOption("verbose", TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="projectKNNs_+3A_wij">wij</code></td>
<td>
<p>A symmetric sparse matrix of edge weights, in C-compressed format, as created with the <code>Matrix</code> package.</p>
</td></tr>
<tr><td><code id="projectKNNs_+3A_dim">dim</code></td>
<td>
<p>numeric Number of dimensions for the projection space (default=2).</p>
</td></tr>
<tr><td><code id="projectKNNs_+3A_sgd_batches">sgd_batches</code></td>
<td>
<p>The number of edges to process during SGD (default=NULL). Defaults to a value set based on the size of the dataset. If the parameter given is
between <code>0</code> and <code>1</code>, the default value will be multiplied by the parameter.</p>
</td></tr>
<tr><td><code id="projectKNNs_+3A_m">M</code></td>
<td>
<p>numeric Number of negative edges to sample for each positive edge (default=5).</p>
</td></tr>
<tr><td><code id="projectKNNs_+3A_gamma">gamma</code></td>
<td>
<p>numeric Strength of the force pushing non-neighbor nodes apart (default=7).</p>
</td></tr>
<tr><td><code id="projectKNNs_+3A_alpha">alpha</code></td>
<td>
<p>numeric Hyperparameter used in the default distance function, <code class="reqn">1 / (1 + \alpha \dot ||y_i - y_j||^2)</code> (default=1).  The function relates the distance
between points in the low-dimensional projection to the likelihood that the two points are nearest neighbors. Increasing <code class="reqn">\alpha</code> tends
to push nodes and their neighbors closer together; decreasing <code class="reqn">\alpha</code> produces a broader distribution. Setting <code class="reqn">\alpha</code> to zero
enables the alternative distance function. <code class="reqn">\alpha</code> below zero is meaningless.</p>
</td></tr>
<tr><td><code id="projectKNNs_+3A_rho">rho</code></td>
<td>
<p>numeric Initial learning rate (default=1)</p>
</td></tr>
<tr><td><code id="projectKNNs_+3A_coords">coords</code></td>
<td>
<p>An initialized coordinate matrix (default=NULL).</p>
</td></tr>
<tr><td><code id="projectKNNs_+3A_usedegree">useDegree</code></td>
<td>
<p>boolean Whether to use vertex degree to determine weights (default=FALSE). If TRUE, weights determined in negative sampling; if FALSE, weights determined by the sum of the vertex's edges. See Notes.</p>
</td></tr>
<tr><td><code id="projectKNNs_+3A_momentum">momentum</code></td>
<td>
<p>If not <code>NULL</code> (the default), SGD with momentum is used, with this multiplier, which must be between 0 and 1. Note that
momentum can drastically speed-up training time, at the cost of additional memory consumed.</p>
</td></tr>
<tr><td><code id="projectKNNs_+3A_seed">seed</code></td>
<td>
<p>numeric Random seed to be passed to the C++ functions (default=NULL). If NULL, sampled from hardware entropy pool.
Note that if the seed is not <code>NULL</code> (the default), the maximum number of threads will be set to 1 in phases of the algorithm
that would otherwise be non-deterministic.</p>
</td></tr>
<tr><td><code id="projectKNNs_+3A_threads">threads</code></td>
<td>
<p>numeric The maximum number of threads to spawn (default=NULL). Determined automatically if <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="projectKNNs_+3A_verbose">verbose</code></td>
<td>
<p>boolean Verbosity (default=getOption(&quot;verbose&quot;, TRUE))</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm attempts to estimate a <code>dim</code>-dimensional embedding using stochastic gradient descent and
negative sampling.
</p>
<p>The objective function is: </p>
<p style="text-align: center;"><code class="reqn"> O = \sum_{(i,j)\in E} w_{ij} (\log f(||p(e_{ij} = 1||) + \sum_{k=1}^{M} E_{jk~P_{n}(j)} \gamma \log(1 - f(||p(e_{ij_k} - 1||)))</code>
</p>

<p>where <code class="reqn">f()</code> is a probabilistic function relating the distance between two points in the low-dimensional projection space,
and the probability that they are nearest neighbors.
</p>
<p>The default probabilistic function is <code class="reqn">1 / (1 + \alpha \dot ||x||^2)</code>. If <code class="reqn">\alpha</code> is set to zero,
an alternative probabilistic function, <code class="reqn">1 / (1 + \exp(x^2))</code> will be used instead.
</p>
<p>Note that the input matrix should be symmetric.  If any columns in the matrix are empty, the function will fail.
</p>


<h3>Value</h3>

<p>A dense [N,D] matrix of the coordinates projecting the w_ij matrix into the lower-dimensional space.
</p>


<h3>Note</h3>

<p>If specified, <code>seed</code> is passed to the C++ and used to initialize the random number generator. This will not, however, be
sufficient to ensure reproducible results, because the initial coordinate matrix is generated using the <code>R</code> random number generator.
To ensure reproducibility, call <code><a href="base.html#topic+set.seed">set.seed</a></code> before calling this function, or pass it a pre-allocated coordinate matrix.
</p>
<p>The original paper called for weights in negative sampling to be calculated according to the degree of each vertex, the number of edges
connecting to the vertex. The reference implementation, however, uses the sum of the weights of the edges to each vertex. In experiments, the
difference was imperceptible with small (MNIST-size) datasets, but the results seems aesthetically preferrable using degree. The default
is to use the edge weights, consistent with the reference implementation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(CO2)
CO2$Plant &lt;- as.integer(CO2$Plant)
CO2$Type &lt;- as.integer(CO2$Type)
CO2$Treatment &lt;- as.integer(CO2$Treatment)
co &lt;- scale(as.matrix(CO2))
# Very small datasets often produce a warning regarding the alias table.  This is safely ignored.
suppressWarnings(vis &lt;- largeVis(t(co), K = 20, sgd_batches = 1, threads = 2))
suppressWarnings(coords &lt;- projectKNNs(vis$wij, threads = 2))
plot(t(coords))

## End(Not run)

</code></pre>

<hr>
<h2 id='propagateLabelsDiffusion'>Estimate labeling distribution for each vertex, based on provided labels using Random Walk</h2><span id='topic+propagateLabelsDiffusion'></span>

<h3>Description</h3>

<p>Estimate labeling distribution for each vertex, based on provided labels using Random Walk
</p>


<h3>Usage</h3>

<pre><code class='language-R'>propagateLabelsDiffusion(
  graph,
  labels,
  max.iters = 100,
  diffusion.fading = 10,
  diffusion.fading.const = 0.1,
  tol = 0.025,
  verbose = TRUE,
  fixed.initial.labels = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="propagateLabelsDiffusion_+3A_graph">graph</code></td>
<td>
<p>input graph</p>
</td></tr>
<tr><td><code id="propagateLabelsDiffusion_+3A_labels">labels</code></td>
<td>
<p>vector of factor or character labels, named by cell names</p>
</td></tr>
<tr><td><code id="propagateLabelsDiffusion_+3A_max.iters">max.iters</code></td>
<td>
<p>maximal number of iterations (default=100)</p>
</td></tr>
<tr><td><code id="propagateLabelsDiffusion_+3A_tol">tol</code></td>
<td>
<p>numeric Absolute tolerance as a stopping criteria (default=0.025)</p>
</td></tr>
<tr><td><code id="propagateLabelsDiffusion_+3A_verbose">verbose</code></td>
<td>
<p>boolean Verbose mode (default=TRUE)</p>
</td></tr>
<tr><td><code id="propagateLabelsDiffusion_+3A_fixed.initial.labels">fixed.initial.labels</code></td>
<td>
<p>boolean Prohibit changes of initial labels during diffusion (default=TRUE)</p>
</td></tr>
</table>

<hr>
<h2 id='quickCCA'>Perform CCA (using PMA package or otherwise) on two samples</h2><span id='topic+quickCCA'></span>

<h3>Description</h3>

<p>Perform CCA (using PMA package or otherwise) on two samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quickCCA(
  r.n,
  data.type = "counts",
  ncomps = 100,
  n.odgenes = NULL,
  var.scale = TRUE,
  verbose = TRUE,
  PMA = FALSE,
  score.component.variance = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quickCCA_+3A_r.n">r.n</code></td>
<td>
<p>list of pagoda2 objects</p>
</td></tr>
<tr><td><code id="quickCCA_+3A_data.type">data.type</code></td>
<td>
<p>character Type of data type in the input pagoda2 objects within r.n (default='counts')</p>
</td></tr>
<tr><td><code id="quickCCA_+3A_ncomps">ncomps</code></td>
<td>
<p>numeric Number of components to calculate (default=100)</p>
</td></tr>
<tr><td><code id="quickCCA_+3A_n.odgenes">n.odgenes</code></td>
<td>
<p>numeric Number of overdispersed genes to take from each dataset</p>
</td></tr>
<tr><td><code id="quickCCA_+3A_var.scale">var.scale</code></td>
<td>
<p>boolean Whether to scale variance (default=TRUE)</p>
</td></tr>
<tr><td><code id="quickCCA_+3A_verbose">verbose</code></td>
<td>
<p>boolean Whether to be verbose (default=TRUE)</p>
</td></tr>
<tr><td><code id="quickCCA_+3A_score.component.variance">score.component.variance</code></td>
<td>
<p>boolean Whether to score component variance (default=FALSE)</p>
</td></tr>
</table>

<hr>
<h2 id='quickCPCA'>Perform cpca on two samples</h2><span id='topic+quickCPCA'></span>

<h3>Description</h3>

<p>Perform cpca on two samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quickCPCA(
  r.n,
  data.type = "counts",
  ncomps = 100,
  n.odgenes = NULL,
  var.scale = TRUE,
  verbose = TRUE,
  score.component.variance = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quickCPCA_+3A_r.n">r.n</code></td>
<td>
<p>list of pagoda2 objects</p>
</td></tr>
<tr><td><code id="quickCPCA_+3A_data.type">data.type</code></td>
<td>
<p>character Type of data type in the input pagoda2 objects within r.n (default='counts')</p>
</td></tr>
<tr><td><code id="quickCPCA_+3A_ncomps">ncomps</code></td>
<td>
<p>numeric Number of components to calculate (default=100)</p>
</td></tr>
<tr><td><code id="quickCPCA_+3A_n.odgenes">n.odgenes</code></td>
<td>
<p>numeric Number of overdispersed genes to take from each dataset (default=NULL)</p>
</td></tr>
<tr><td><code id="quickCPCA_+3A_var.scale">var.scale</code></td>
<td>
<p>boolean Whether to scale variance (default=TRUE)</p>
</td></tr>
<tr><td><code id="quickCPCA_+3A_verbose">verbose</code></td>
<td>
<p>boolean Whether to be verbose (default=TRUE)</p>
</td></tr>
<tr><td><code id="quickCPCA_+3A_score.component.variance">score.component.variance</code></td>
<td>
<p>boolean Whether to score component variance (default=FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>cpca projection on two samples
</p>

<hr>
<h2 id='quickPlainPCA'>Use space of combined sample-specific PCAs as a space</h2><span id='topic+quickPlainPCA'></span>

<h3>Description</h3>

<p>Use space of combined sample-specific PCAs as a space
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quickPlainPCA(
  r.n,
  data.type = "counts",
  ncomps = 30,
  n.odgenes = NULL,
  var.scale = TRUE,
  verbose = TRUE,
  score.component.variance = FALSE,
  n.cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quickPlainPCA_+3A_r.n">r.n</code></td>
<td>
<p>list of pagoda2 objects</p>
</td></tr>
<tr><td><code id="quickPlainPCA_+3A_data.type">data.type</code></td>
<td>
<p>character Type of data type in the input pagoda2 objects within r.n (default='counts')</p>
</td></tr>
<tr><td><code id="quickPlainPCA_+3A_ncomps">ncomps</code></td>
<td>
<p>numeric Number of components to calculate (default=30)</p>
</td></tr>
<tr><td><code id="quickPlainPCA_+3A_n.odgenes">n.odgenes</code></td>
<td>
<p>numeric Number of overdispersed genes to take from each dataset (default=NULL)</p>
</td></tr>
<tr><td><code id="quickPlainPCA_+3A_var.scale">var.scale</code></td>
<td>
<p>boolean Whether to scale variance (default=TRUE)</p>
</td></tr>
<tr><td><code id="quickPlainPCA_+3A_verbose">verbose</code></td>
<td>
<p>boolean Whether to be verbose (default=TRUE)</p>
</td></tr>
<tr><td><code id="quickPlainPCA_+3A_score.component.variance">score.component.variance</code></td>
<td>
<p>boolean Whether to score component variance (default=FALSE)</p>
</td></tr>
<tr><td><code id="quickPlainPCA_+3A_n.cores">n.cores</code></td>
<td>
<p>numeric Number of cores to use (default=1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>PCA projection, using space of combined sample-specific PCAs
</p>

<hr>
<h2 id='rawMatricesWithCommonGenes'>Get raw matrices with common genes</h2><span id='topic+rawMatricesWithCommonGenes'></span>

<h3>Description</h3>

<p>Get raw matrices with common genes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rawMatricesWithCommonGenes(con.obj, sample.groups = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rawMatricesWithCommonGenes_+3A_con.obj">con.obj</code></td>
<td>
<p>Conos object</p>
</td></tr>
<tr><td><code id="rawMatricesWithCommonGenes_+3A_sample.groups">sample.groups</code></td>
<td>
<p>list of samples to select from Conos object, con.obj$samples (default=NULL)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>raw matrices subset with common genes
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+leiden.community'></span><span id='topic+embeddingPlot'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>leidenAlg</dt><dd><p><code><a href="leidenAlg.html#topic+leiden.community">leiden.community</a></code>, <code><a href="leidenAlg.html#topic+leiden.community">leiden.community</a></code></p>
</dd>
<dt>sccore</dt><dd><p><code><a href="sccore.html#topic+embeddingPlot">embeddingPlot</a></code></p>
</dd>
</dl>

<hr>
<h2 id='saveConosForScanPy'>Save Conos object on disk to read it from ScanPy</h2><span id='topic+saveConosForScanPy'></span>

<h3>Description</h3>

<p>Save Conos object on disk to read it from ScanPy
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveConosForScanPy(
  con,
  output.path,
  hdf5_filename,
  metadata.df = NULL,
  cm.norm = FALSE,
  pseudo.pca = FALSE,
  pca = FALSE,
  n.dims = 100,
  embedding = TRUE,
  alignment.graph = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saveConosForScanPy_+3A_con">con</code></td>
<td>
<p>conos object</p>
</td></tr>
<tr><td><code id="saveConosForScanPy_+3A_output.path">output.path</code></td>
<td>
<p>path to a folder, where intermediate files will be saved</p>
</td></tr>
<tr><td><code id="saveConosForScanPy_+3A_hdf5_filename">hdf5_filename</code></td>
<td>
<p>name of HDF5 written with ScanPy files. Note: the rhdf5 package is required</p>
</td></tr>
<tr><td><code id="saveConosForScanPy_+3A_metadata.df">metadata.df</code></td>
<td>
<p>data.frame with additional metadata with rownames corresponding to cell ids, which should be passed to ScanPy (default=NULL)
If NULL, only information about cell ids and origin dataset will be saved.</p>
</td></tr>
<tr><td><code id="saveConosForScanPy_+3A_cm.norm">cm.norm</code></td>
<td>
<p>boolean Whether to include the matrix of normalised counts (default=FALSE).</p>
</td></tr>
<tr><td><code id="saveConosForScanPy_+3A_pseudo.pca">pseudo.pca</code></td>
<td>
<p>boolean Whether to produce an emulated PCA by embedding the graph to a space with 'n.dims' dimensions and save it as a pseudoPCA (default=FALSE).</p>
</td></tr>
<tr><td><code id="saveConosForScanPy_+3A_pca">pca</code></td>
<td>
<p>boolean Whether to include PCA of all the samples (not batch corrected) (default=FALSE).</p>
</td></tr>
<tr><td><code id="saveConosForScanPy_+3A_n.dims">n.dims</code></td>
<td>
<p>numeric Number of dimensions for calculating PCA and/or pseudoPCA (default=100).</p>
</td></tr>
<tr><td><code id="saveConosForScanPy_+3A_embedding">embedding</code></td>
<td>
<p>boolean Whether to include the current conos embedding (default=TRUE).</p>
</td></tr>
<tr><td><code id="saveConosForScanPy_+3A_alignment.graph">alignment.graph</code></td>
<td>
<p>boolean Whether to include graph of connectivities and distances (default=TRUE).</p>
</td></tr>
<tr><td><code id="saveConosForScanPy_+3A_verbose">verbose</code></td>
<td>
<p>boolean Whether to use verbose mode (default=FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>AnnData object for ScanPy, saved to disk
</p>


<h3>See Also</h3>

<p>The rhdf5 package documentation here: &lt;https://www.bioconductor.org/packages/release/bioc/html/rhdf5.html&gt;
</p>

<hr>
<h2 id='saveDEasCSV'>Save differential expression as table in *csv format</h2><span id='topic+saveDEasCSV'></span>

<h3>Description</h3>

<p>Save differential expression as table in *csv format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveDEasCSV(de.results, saveprefix, gene.metadata = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saveDEasCSV_+3A_de.results">de.results</code></td>
<td>
<p>output of differential expression results, corrected or uncorrected</p>
</td></tr>
<tr><td><code id="saveDEasCSV_+3A_saveprefix">saveprefix</code></td>
<td>
<p>character prefix for output file</p>
</td></tr>
<tr><td><code id="saveDEasCSV_+3A_gene.metadata">gene.metadata</code></td>
<td>
<p>gene metadta to include (default=NULL)</p>
</td></tr>
</table>

<hr>
<h2 id='saveDEasJSON'>Save differential expression results as JSON</h2><span id='topic+saveDEasJSON'></span>

<h3>Description</h3>

<p>Save differential expression results as JSON
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveDEasJSON(
  de.results = NULL,
  saveprefix = NULL,
  gene.metadata = NULL,
  cluster.sep.chr = "&lt;!!&gt;"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saveDEasJSON_+3A_de.results">de.results</code></td>
<td>
<p>differential expression results (default=NULL)</p>
</td></tr>
<tr><td><code id="saveDEasJSON_+3A_saveprefix">saveprefix</code></td>
<td>
<p>prefix for the differential expression output (default=NULL)</p>
</td></tr>
<tr><td><code id="saveDEasJSON_+3A_gene.metadata">gene.metadata</code></td>
<td>
<p>data.frame with gene metadata (default=NULL)</p>
</td></tr>
<tr><td><code id="saveDEasJSON_+3A_cluster.sep.chr">cluster.sep.chr</code></td>
<td>
<p>character string of length 1 specifying a delimiter to separate cluster and app names (default='&lt;!!&gt;')</p>
</td></tr>
</table>


<h3>Value</h3>

<p>JSON with DE results
</p>

<hr>
<h2 id='scanKModularity'>Scan joint graph modularity for a range of k (or k.self) values
Builds graph with different values of k (or k.self if scan.k.self=TRUE), evaluating modularity of the resulting multilevel clustering
NOTE: will run evaluations in parallel using con$n.cores (temporarily setting con$n.cores to 1 in the process)</h2><span id='topic+scanKModularity'></span>

<h3>Description</h3>

<p>Scan joint graph modularity for a range of k (or k.self) values
Builds graph with different values of k (or k.self if scan.k.self=TRUE), evaluating modularity of the resulting multilevel clustering
NOTE: will run evaluations in parallel using con$n.cores (temporarily setting con$n.cores to 1 in the process)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scanKModularity(
  con,
  min = 3,
  max = 50,
  by = 1,
  scan.k.self = FALSE,
  omit.internal.edges = TRUE,
  verbose = TRUE,
  plot = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scanKModularity_+3A_con">con</code></td>
<td>
<p>Conos object to test</p>
</td></tr>
<tr><td><code id="scanKModularity_+3A_min">min</code></td>
<td>
<p>numeric Minimal value of k to test (default=3)</p>
</td></tr>
<tr><td><code id="scanKModularity_+3A_max">max</code></td>
<td>
<p>numeric Value of k to test (default=50)</p>
</td></tr>
<tr><td><code id="scanKModularity_+3A_by">by</code></td>
<td>
<p>numeric Scan step (default=1)</p>
</td></tr>
<tr><td><code id="scanKModularity_+3A_scan.k.self">scan.k.self</code></td>
<td>
<p>boolean Whether to test dependency on scan.k.self (default=FALSE)</p>
</td></tr>
<tr><td><code id="scanKModularity_+3A_omit.internal.edges">omit.internal.edges</code></td>
<td>
<p>boolean Whether to omit internal edges of the graph (default=TRUE)</p>
</td></tr>
<tr><td><code id="scanKModularity_+3A_verbose">verbose</code></td>
<td>
<p>boolean Whether to provide verbose output (default=TRUE)</p>
</td></tr>
<tr><td><code id="scanKModularity_+3A_plot">plot</code></td>
<td>
<p>boolean Whether to plot the output (default=TRUE)</p>
</td></tr>
<tr><td><code id="scanKModularity_+3A_...">...</code></td>
<td>
<p>other parameters will be passed to con$buildGraph()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with $k $m columns giving k and the corresponding modularity
</p>

<hr>
<h2 id='sgdBatches'>Calculate the default number of batches for a given number of vertices and edges.
The formula used is the one used by the 'largeVis' reference implementation.  This is substantially less than the recommendation <code class="reqn">E * 10000</code> in the original paper.</h2><span id='topic+sgdBatches'></span>

<h3>Description</h3>

<p>Calculate the default number of batches for a given number of vertices and edges.
The formula used is the one used by the 'largeVis' reference implementation.  This is substantially less than the recommendation <code class="reqn">E * 10000</code> in the original paper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sgdBatches(N, E = 150 * N/2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sgdBatches_+3A_n">N</code></td>
<td>
<p>Number of vertices</p>
</td></tr>
<tr><td><code id="sgdBatches_+3A_e">E</code></td>
<td>
<p>Number of edges (default = 150*N/2)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The recommended number of sgd batches.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Observe that increasing K has no effect on processing time
N &lt;- 70000 # MNIST
K &lt;- 10:250
plot(K, sgdBatches(rep(N, length(K)), N * K / 2))

# Observe that processing time scales linarly with N
N &lt;- c(seq(from = 1, to = 10000, by = 100), seq(from = 10000, to = 10000000, by = 1000))
plot(N, sgdBatches(N))

</code></pre>

<hr>
<h2 id='small_panel.preprocessed'>Small pre-processed data from Pagoda2, two samples, each dimension (1000, 100)</h2><span id='topic+small_panel.preprocessed'></span>

<h3>Description</h3>

<p>Small pre-processed data from Pagoda2, two samples, each dimension (1000, 100)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>small_panel.preprocessed
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.
</p>

<hr>
<h2 id='stableTreeClusters'>Determine number of detectable clusters given a reference walktrap and a bunch of permuted walktraps</h2><span id='topic+stableTreeClusters'></span>

<h3>Description</h3>

<p>Determine number of detectable clusters given a reference walktrap and a bunch of permuted walktraps
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stableTreeClusters(
  refwt,
  tests,
  min.threshold = 0.8,
  min.size = 10,
  n.cores = 30,
  average.thresholds = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stableTreeClusters_+3A_refwt">refwt</code></td>
<td>
<p>reference walktrap result</p>
</td></tr>
<tr><td><code id="stableTreeClusters_+3A_tests">tests</code></td>
<td>
<p>a list of permuted walktrap results</p>
</td></tr>
<tr><td><code id="stableTreeClusters_+3A_min.threshold">min.threshold</code></td>
<td>
<p>numeric Min detectability threshold (default=0.8)</p>
</td></tr>
<tr><td><code id="stableTreeClusters_+3A_min.size">min.size</code></td>
<td>
<p>numeric Minimum cluster size (number of leafs) (default=10)</p>
</td></tr>
<tr><td><code id="stableTreeClusters_+3A_n.cores">n.cores</code></td>
<td>
<p>numeric Number of cores (default=30)</p>
</td></tr>
<tr><td><code id="stableTreeClusters_+3A_average.thresholds">average.thresholds</code></td>
<td>
<p>boolean Report a single number of detectable clusters for averaged detected thresholds (default=FALSE) (a list of detected clusters for each element of the tests list is returned by default)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>number of detectable stable clusters
</p>

<hr>
<h2 id='velocityInfoConos'>RNA velocity analysis on samples integrated with conos
Create a list of objects to pass into gene.relative.velocity.estimates function from the velocyto.R package</h2><span id='topic+velocityInfoConos'></span>

<h3>Description</h3>

<p>RNA velocity analysis on samples integrated with conos
Create a list of objects to pass into gene.relative.velocity.estimates function from the velocyto.R package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>velocityInfoConos(
  cms.list,
  con,
  clustering = NULL,
  groups = NULL,
  n.odgenes = 2000,
  verbose = TRUE,
  min.max.cluster.average.emat = 0.2,
  min.max.cluster.average.nmat = 0.05,
  min.max.cluster.average.smat = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="velocityInfoConos_+3A_cms.list">cms.list</code></td>
<td>
<p>list of velocity files written out as cell.counts.matrices.rds files by running dropest with -V option</p>
</td></tr>
<tr><td><code id="velocityInfoConos_+3A_con">con</code></td>
<td>
<p>conos object (after creating an embedding and running leiden clustering)</p>
</td></tr>
<tr><td><code id="velocityInfoConos_+3A_clustering">clustering</code></td>
<td>
<p>name of clustering in the conos object to use (default=NULL). Either 'clustering' or 'groups' must be provided.</p>
</td></tr>
<tr><td><code id="velocityInfoConos_+3A_groups">groups</code></td>
<td>
<p>set of clusters to use (default=NULL). Ignored if 'clustering' is not NULL.</p>
</td></tr>
<tr><td><code id="velocityInfoConos_+3A_n.odgenes">n.odgenes</code></td>
<td>
<p>numeric Number of overdispersed genes to use for PCA (default=2000).</p>
</td></tr>
<tr><td><code id="velocityInfoConos_+3A_verbose">verbose</code></td>
<td>
<p>boolean Whether to use verbose mode (default=TRUE)</p>
</td></tr>
<tr><td><code id="velocityInfoConos_+3A_min.max.cluster.average.emat">min.max.cluster.average.emat</code></td>
<td>
<p>Required minimum average expression count for emat, the spliced (exonic) count matrix (default=0.2). Note: no normalization is perfomed. See the parameter 'min.max.cluster.average' in the function 'filter.genes.by.cluster.expression.'</p>
</td></tr>
<tr><td><code id="velocityInfoConos_+3A_min.max.cluster.average.nmat">min.max.cluster.average.nmat</code></td>
<td>
<p>Required minimum average expression count for nmat, the unspliced (nascent) count matrix (default=0.05). Note: no normalization is perfomed. See the parameter 'min.max.cluster.average' in the function 'filter.genes.by.cluster.expression.'</p>
</td></tr>
<tr><td><code id="velocityInfoConos_+3A_min.max.cluster.average.smat">min.max.cluster.average.smat</code></td>
<td>
<p>Required minimum average expression count for smat, the spanning read matrix (used in offset calculations) (default=0.01). Note: no normalization is perfomed. See the parameter 'min.max.cluster.average' in the function 'filter.genes.by.cluster.expression.'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with cell distances, combined spliced expression matrix, combined unspliced expression matrix, combined matrix of spanning reads, cell colors for clusters and embedding (taken from conos)
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
