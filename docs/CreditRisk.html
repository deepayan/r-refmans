<!DOCTYPE html><html><head><title>Help for package CreditRisk</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CreditRisk}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#at1p'><p>Analytically - Tractable First Passage (AT1P) model</p></a></li>
<li><a href='#BlackCox'><p>Black and Cox's model</p></a></li>
<li><a href='#calibrate.at1p'><p>AT1P model calibration to market CDS data</p></a></li>
<li><a href='#calibrate.BlackCox'><p>Black and Cox model calibration to market CDS data</p></a></li>
<li><a href='#calibrate.cds'><p>Calibrate the default intensities to market CDS data</p></a></li>
<li><a href='#calibrate.sbtv'><p>SBTV model calibration to market CDS data</p></a></li>
<li><a href='#cds'><p>Calculates Credit Default Swap rates</p></a></li>
<li><a href='#cds2'><p>Calculate Credit Default Swap rates</p></a></li>
<li><a href='#cdsdata'><p>CDS quotes from market</p></a></li>
<li><a href='#cum_normal_density'><p>Cumulative Normal Distribution Function</p></a></li>
<li><a href='#generalized_black_scholes'><p>Generalized Black-Scholes Option Pricing Model</p></a></li>
<li><a href='#Merton'><p>Merton's model</p></a></li>
<li><a href='#Merton.sim'><p>Firm value in Merton's model</p></a></li>
<li><a href='#sbtv'><p>Scenario Barrier Time-Varying Volatility AT1P model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Evaluation of Credit Risk with Structural and Reduced Form
Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-04-18</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alessandro Cimarelli &lt;alessandro.cimarelli@icloud.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Evaluation of default probability of sovereign and corporate entities based on structural or intensity based models and calibration on market Credit Default Swap quotes. References: Damiano Brigo, Massimo Morini, Andrea Pallavicini (2013) &lt;<a href="https://doi.org/10.1002%2F9781118818589">doi:10.1002/9781118818589</a>&gt;. Print ISBN: 9780470748466, Online ISBN: 9781118818589. © 2013 John Wiley &amp; Sons Ltd.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-19 08:00:09 UTC; alessandro.cimarelli</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-19 10:53:09 UTC</td>
</tr>
<tr>
<td>Author:</td>
<td>Alessandro Cimarelli [aut, cre],
  Nicolò Manca [aut]</td>
</tr>
</table>
<hr>
<h2 id='at1p'>Analytically - Tractable First Passage (AT1P) model</h2><span id='topic+at1p'></span>

<h3>Description</h3>

<p><code>at1p</code> calculates the survival probability <code class="reqn">Q(\tau &gt; t)</code> and default intensity
for each maturity according to the structural Analytically - Tractable First Passage model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>at1p(V0, H0, B, sigma, r, t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="at1p_+3A_v0">V0</code></td>
<td>
<p>firm value at time <code>t = 0</code> (it is a constant value).</p>
</td></tr>
<tr><td><code id="at1p_+3A_h0">H0</code></td>
<td>
<p>value of the safety level at time <code>t = 0</code>.</p>
</td></tr>
<tr><td><code id="at1p_+3A_b">B</code></td>
<td>
<p>free positive parameter used for shaping the barrier <code>Ht</code>.</p>
</td></tr>
<tr><td><code id="at1p_+3A_sigma">sigma</code></td>
<td>
<p>a vector of constant stepwise volatility <code class="reqn">\sigma_t</code>.</p>
</td></tr>
<tr><td><code id="at1p_+3A_r">r</code></td>
<td>
<p>a vector of constant stepwise risk-free rate.</p>
</td></tr>
<tr><td><code id="at1p_+3A_t">t</code></td>
<td>
<p>a vector of debt maturity structure (it is a numeric vector).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In this function the safety level <code>Ht</code> is calculated using the formula:
</p>
<p style="text-align: center;"><code class="reqn">H(t) = \frac{H0}{V0} * E_0[V_t] * \exp^{- B \int_0^t \sigma_u du}</code>
</p>

<p>The backbone of the default barrier at <code class="reqn">t</code> is a proportion, controlled by the parameter
<code>H0</code>, of the expected value of the company assets at <code class="reqn">t</code>. <code>H0</code> may depend on the
level of the liabilities, on safety covenants, and in general on the characteristics of the capital
structure of the company. Also, depending on the value of the parameter <code>B</code>, it is possible
that this backbone is modified by accounting for the volatility of the company assets. For
example, if <code>B &gt; 0</code> corresponds to the interpretation that when volatility increases - which
can be independed of credit quality - the barrier is slightly lowered to cut some more slack
to the company before going bankrupt. When <code>B = 0</code> the barrier does not depend on the
volatility and the &quot;distance to default&quot; is simply modelled through the barrier parameter <code>H0</code>.
</p>


<h3>Value</h3>

<p><code>at1p</code> returns an object of class <code>data.frame</code> containing the firm value, safety level <code class="reqn">H(t)</code>
and the survival probability for each maturity. The last column is the default intensity calculated
among each interval <code class="reqn">\Delta t</code>.
</p>


<h3>References</h3>

<p>Damiano Brigo, Massimo Morini, Andrea Pallavicini (2013)
Counterparty Credit Risk, Collateral and Funding.
With Pricing Cases for All Asset Classes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- at1p(V0 = 1, H0 = 0.7, B = 0.4, sigma = rep(0.1, 10), r = cdsdata$ED.Zero.Curve,
t = cdsdata$Maturity)
mod

plot(cdsdata$Maturity, mod$Ht, type = 'b', xlab = 'Maturity', ylab = 'Safety Level H(t)',
main = 'Safety level for different maturities', ylim = c(min(mod$Ht), 1.5),
col = 'red')
lines(cdsdata$Maturity, mod$Vt, xlab = 'Maturity', ylab = 'V(t)',
main = 'Value of the Firm \n at time t', type = 's')

plot(cdsdata$Maturity, mod$Survival, type = 'b',
main = 'Survival Probability for different Maturity \n (AT1P model)',
xlab = 'Maturity', ylab = 'Survival Probability')

matplot(cdsdata$Maturity, mod$Default.Intensity, type = 'l', xlab = 'Maturity',
ylab = 'Default Intensity')

</code></pre>

<hr>
<h2 id='BlackCox'>Black and Cox's model</h2><span id='topic+BlackCox'></span>

<h3>Description</h3>

<p><code>BlackCox</code> calculates the survival probability <code class="reqn">Q(\tau &gt; t)</code> and default intensity
for each maturity according to the structural Black and Cox's model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BlackCox(L, K = L, V0, sigma, r, gamma, t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BlackCox_+3A_l">L</code></td>
<td>
<p>debt face value at maturity <code>t = T</code> (it is a constant value).</p>
</td></tr>
<tr><td><code id="BlackCox_+3A_k">K</code></td>
<td>
<p>positive parameter needed to calculate the safety level.</p>
</td></tr>
<tr><td><code id="BlackCox_+3A_v0">V0</code></td>
<td>
<p>firm value at time <code>t = 0</code> (it is a constant value).</p>
</td></tr>
<tr><td><code id="BlackCox_+3A_sigma">sigma</code></td>
<td>
<p>volatility (constant for all t).</p>
</td></tr>
<tr><td><code id="BlackCox_+3A_r">r</code></td>
<td>
<p>risk-free rate (constant for all t).</p>
</td></tr>
<tr><td><code id="BlackCox_+3A_gamma">gamma</code></td>
<td>
<p>interest rate used to discount the safety level <code>Ht</code> (it is a constant value).</p>
</td></tr>
<tr><td><code id="BlackCox_+3A_t">t</code></td>
<td>
<p>a vector of debt maturity structure (it is a numeric vector).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In Merton's model the default event can occurr only at debt maturity <code class="reqn">T</code> while
in Black and Cox's model the default event can occurr even before.
In this model the safety level is given by the output <code>Ht</code>. Hitting this barrier is
considered as an erlier default. Assuming a debt face value of <code>L</code> at the final
maturity that coincides with the safety level in <code class="reqn">t = T</code>, the safety level in <code class="reqn">t\le T</code> is the
<code>K</code>, with <code class="reqn">K\le L</code>, value discounted at back at time <code class="reqn">t</code> using the interest rate
<code>gamma</code>, obtaining: </p>
<p style="text-align: center;"><code class="reqn">H(t | t\le T) = K * \exp^{- \gamma * (T- t)}</code>
</p>

<p>The output parameter <code>Default.Intensity</code> represents the default intensity of
<code class="reqn">\Delta t</code>. The firm's value <code>Vt</code> is calculated as in the <code>Merton</code> function.
</p>


<h3>Value</h3>

<p>This function returns an object of class <code>data.frame</code> containing firm value, safety level <code class="reqn">H(t)</code>
and the survival probability for each maturity. The last column is the default intensity calculated
among each interval <code class="reqn">\Delta t</code>.
</p>


<h3>References</h3>

<p>David Lando  (2004) Credit risk modeling.
</p>
<p>Damiano Brigo, Massimo Morini, Andrea Pallavicini (2013)
Counterparty Credit Risk, Collateral and Funding.
With Pricing Cases for All Asset Classes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- BlackCox(L = 0.55, K = 0.40, V0 = 1, sigma = 0.3, r = 0.05, gamma = 0.04,
t = c(0.50, 1.00, 2.00, 5.00, 7.00, 10.00, 20.00, 30.00))
mod

plot(c(0.50, 1.00, 2.00, 5.00, 7.00, 10.00, 20.00, 30.00), mod$Ht, type = 'b',
     xlab = 'Maturity', ylab = 'Safety Level H(t)', main = 'Safety level for different
     maturities', ylim = c(min(mod$Ht), 1.5), col = 'red')
abline(h = 0.55, col = 'red')
lines(c(0.50, 1.00, 2.00, 5.00, 7.00, 10.00, 20.00, 30.00), mod$Vt, xlab = 'Maturity',
      ylab = 'V(t)', main = 'Value of the Firm \n at time t', type = 's')

plot(c(0.50, 1.00, 2.00, 5.00, 7.00, 10.00, 20.00, 30.00), mod$Survival, type = 'b',
     main = 'Survival Probability for different Maturity \n (Black &amp; Cox model)',
     xlab = 'Maturity', ylab = 'Survival Probability')

matplot(c(0.50, 1.00, 2.00, 5.00, 7.00, 10.00, 20.00, 30.00), mod$Default.Intensity,
        type = 'l', xlab = 'Maturity', ylab = 'Default Intensity')

</code></pre>

<hr>
<h2 id='calibrate.at1p'>AT1P model calibration to market CDS data</h2><span id='topic+calibrate.at1p'></span>

<h3>Description</h3>

<p>Compares CDS rates quoted on the market with theoric CDS rates calculeted by the function
<code>cds</code> and looks for the parameters to be used into <code>at1p</code>
for returning the default intensities corresponding to real market CDS rates performing the
minimization of the objective function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibrate.at1p(V0, cdsrate, r, t, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calibrate.at1p_+3A_v0">V0</code></td>
<td>
<p>firm value at time <code>t = 0</code>.</p>
</td></tr>
<tr><td><code id="calibrate.at1p_+3A_cdsrate">cdsrate</code></td>
<td>
<p>CDS rates from market.</p>
</td></tr>
<tr><td><code id="calibrate.at1p_+3A_r">r</code></td>
<td>
<p>a vector of risk-free rate.</p>
</td></tr>
<tr><td><code id="calibrate.at1p_+3A_t">t</code></td>
<td>
<p>a vector of debt maturity structure.</p>
</td></tr>
<tr><td><code id="calibrate.at1p_+3A_...">...</code></td>
<td>
<p>additional parameters used in <code>cds</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Inside <code>calibrate.at1p</code>, the function <code>objfn</code> takes the input a
vector of parameters and returns the mean error occurred estimating CDS rates with
<code>cds</code> function. The inputs used in <code>cds</code> are the default intensities calculated by
the <code>at1p</code> function with the calibrated parameters. In particular the error is
calculated as:
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{n}\sum_{i=1}^n (c^{ds}-c^{ds}_{mkt})^2.</code>
</p>
<p> This quantity is a function of
the default intensities and it is the objective function to be minimized in order to take
optimal solutions for intensities.
</p>


<h3>Value</h3>

<p><code>calibrate.at1p</code> returns an object of class <code>data.frame</code> with calculated parameters of
the <code>at1p</code> model and the error occurred in the minimization procedure.
</p>


<h3>References</h3>

<p>Damiano Brigo, Massimo Morini, Andrea Pallavicini (2013)
Counterparty Credit Risk, Collateral and Funding.
With Pricing Cases for All Asset Classes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>calibrate.at1p(V0 = 1, cdsrate = cdsdata$Par.spread, r = cdsdata$ED.Zero.Curve,
t = cdsdata$Maturity)

</code></pre>

<hr>
<h2 id='calibrate.BlackCox'>Black and Cox model calibration to market CDS data</h2><span id='topic+calibrate.BlackCox'></span>

<h3>Description</h3>

<p>Compares CDS rates quoted on the market with theoric CDS rates calculeted by the function
<code>cds</code> and looks for the parameters to be used into <code>BlackCox</code>
for returning the default intensities corresponding to real market CDS rates performing the
minimization of the objective function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibrate.BlackCox(V0, cdsrate, r, t, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calibrate.BlackCox_+3A_v0">V0</code></td>
<td>
<p>firm value at time <code>t = 0</code>.</p>
</td></tr>
<tr><td><code id="calibrate.BlackCox_+3A_cdsrate">cdsrate</code></td>
<td>
<p>CDS rates from the market.</p>
</td></tr>
<tr><td><code id="calibrate.BlackCox_+3A_r">r</code></td>
<td>
<p>risk-free rate.</p>
</td></tr>
<tr><td><code id="calibrate.BlackCox_+3A_t">t</code></td>
<td>
<p>a vector of debt maturity structure.</p>
</td></tr>
<tr><td><code id="calibrate.BlackCox_+3A_...">...</code></td>
<td>
<p>additional parameters used in <code>cds</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Inside <code>calibrate.BlackCox</code>, the function <code>objfn</code> takes the input a
vector of parameters and returns the mean error occurred estimating CDS rates with
<code>cds</code> function. The inputs used in <code>cds</code> are the default intensities calculated by
the <code>BlackCox</code> function with the calibrated parameters. In particular the error is
calculated as:
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{n}\sum_{i=1}^n (c^{ds}-c^{ds}_{mkt})^2.</code>
</p>
<p> This quantity is a function of
the default intensities and it is the objective function to be minimized in order to take
optimal solutions for intensities.
</p>


<h3>Value</h3>

<p><code>calibrate.BlackCox</code> returns an object of class <code>data.frame</code> with calculated parameters of
the <code>BlackCox</code> model and the error occurred in the minimization procedure.
</p>


<h3>References</h3>

<p>Damiano Brigo, Massimo Morini, Andrea Pallavicini (2013)
Counterparty Credit Risk, Collateral and Funding.
With Pricing Cases for All Asset Classes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>calibrate.BlackCox(V0 = 1, cdsrate = cdsdata$Par.spread, r = 0.005, t = cdsdata$Maturity)

</code></pre>

<hr>
<h2 id='calibrate.cds'>Calibrate the default intensities to market CDS data</h2><span id='topic+calibrate.cds'></span>

<h3>Description</h3>

<p>Compares CDS rates quoted on market with theoric CDS rates and looks for default intensities
that correspond to real market CDS rates trough a minimization problem of an objective
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibrate.cds(r, t, Tj, cdsrate, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calibrate.cds_+3A_r">r</code></td>
<td>
<p>interest rates.</p>
</td></tr>
<tr><td><code id="calibrate.cds_+3A_t">t</code></td>
<td>
<p>premiums timetable.</p>
</td></tr>
<tr><td><code id="calibrate.cds_+3A_tj">Tj</code></td>
<td>
<p>CDS maturities.</p>
</td></tr>
<tr><td><code id="calibrate.cds_+3A_cdsrate">cdsrate</code></td>
<td>
<p>CDS rates from market.</p>
</td></tr>
<tr><td><code id="calibrate.cds_+3A_...">...</code></td>
<td>
<p>additional parameters used in <code>cds</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Inside <code>calibrate.cds</code>, the function <code>err.cds</code> takes the input a
vector of intensities and return the mean error occurred estimating CDS rates with
<code>cds</code>. In particular such error is calculated as:
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{n}\sum_{i=1}^n (c^{ds}-c^{ds}_{mkt})^2.</code>
</p>
<p> This quantity is a function of default intensities and is the our objective
function to be minimized in order to take optimal solutions for intensities.
</p>


<h3>Value</h3>

<p>returns an object of class <code>list</code> with calculated intensities and the
error occurred in the minimization procedure.
</p>


<h3>References</h3>

<p>David Lando (2004) Credit risk modeling
</p>
<p>Damiano Brigo, Massimo Morini, Andrea Pallavicini (2013)
Counterparty Credit Risk, Collateral and Funding.
With Pricing Cases for All Asset Classes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>calibrate.cds( r = cdsdata$ED.Zero.Curve, t = seq(.5, 30, by = 0.5),
               Tj = c(1, 2, 3, 4, 5, 7, 10, 20, 30), cdsrate = cdsdata$Par.spread, RR = 0.4)

</code></pre>

<hr>
<h2 id='calibrate.sbtv'>SBTV model calibration to market CDS data</h2><span id='topic+calibrate.sbtv'></span>

<h3>Description</h3>

<p>Compares CDS rates quoted on the market with theoric CDS rates calculeted by the function
<code>cds</code> and looks for the parameters to be used into <code>sbtv</code>
for returning the default intensities corresponding to real market CDS rates performing the
minimization of the objective function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibrate.sbtv(V0, p, cdsrate, r, t, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calibrate.sbtv_+3A_v0">V0</code></td>
<td>
<p>firm value at time <code>t = 0</code>.</p>
</td></tr>
<tr><td><code id="calibrate.sbtv_+3A_p">p</code></td>
<td>
<p>vector of the probability of different scenario (sum of p must be 1).</p>
</td></tr>
<tr><td><code id="calibrate.sbtv_+3A_cdsrate">cdsrate</code></td>
<td>
<p>CDS rates from market.</p>
</td></tr>
<tr><td><code id="calibrate.sbtv_+3A_r">r</code></td>
<td>
<p>a vector of risk-free rate.</p>
</td></tr>
<tr><td><code id="calibrate.sbtv_+3A_t">t</code></td>
<td>
<p>a vector of debt maturity structure.</p>
</td></tr>
<tr><td><code id="calibrate.sbtv_+3A_...">...</code></td>
<td>
<p>additional parameters used in <code>cds</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Inside <code>calibrate.sbtv</code>, the function <code>objfn</code> takes the input a
vector of parameters and returns the mean error occurred estimating CDS rates with
<code>cds</code> function. The inputs used in <code>cds</code> are the default intensities calculated by
the <code>sbtv</code> function with the calibrated parameters. In particular the error is
calculated as:
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{n}\sum_{i=1}^n (c^{ds}-c^{ds}_{mkt})^2.</code>
</p>
<p> This quantity is a function of
the default intensities and it is the objective function to be minimized in order to take
optimal solutions for intensities.
</p>


<h3>Value</h3>

<p>This function returns an object of class <code>list</code> with calculated parameters of
<code>sbtv</code> model and the error occurred in the minimization procedure.
</p>


<h3>References</h3>

<p>Damiano Brigo, Massimo Morini, Andrea Pallavicini (2013)
Counterparty Credit Risk, Collateral and Funding.
With Pricing Cases for All Asset Classes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>calibrate.sbtv(V0 = 1, p = c(0.95, 0.05), cdsrate = cdsdata$Par.spread,
r = cdsdata$ED.Zero.Curve, t = cdsdata$Maturity)

</code></pre>

<hr>
<h2 id='cds'>Calculates Credit Default Swap rates</h2><span id='topic+cds'></span>

<h3>Description</h3>

<p>Calculates CDS rates starting form default intensities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cds(t, int, r, R = 0.005, RR = 0.4, simplified = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cds_+3A_t">t</code></td>
<td>
<p>premium timetable.</p>
</td></tr>
<tr><td><code id="cds_+3A_int">int</code></td>
<td>
<p>deterministic default intensities vector.</p>
</td></tr>
<tr><td><code id="cds_+3A_r">r</code></td>
<td>
<p>spot interest rates.</p>
</td></tr>
<tr><td><code id="cds_+3A_r">R</code></td>
<td>
<p>constant premium payments, value that the buyer pays in each <code class="reqn">t_i</code>.</p>
</td></tr>
<tr><td><code id="cds_+3A_rr">RR</code></td>
<td>
<p>recovery rate on the underline bond, default value is 40%.</p>
</td></tr>
<tr><td><code id="cds_+3A_simplified">simplified</code></td>
<td>
<p>logic argument. If FALSE calculates the CDS rates using the
semplified version of calculations, if TRUE use the complete version.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p>  Premium timetable is <code class="reqn">t_i;  i=1,...,T</code>. The vector starts from
<code class="reqn">t_1\le 1</code>, i.e. the first premium is payed at a year fraction in the possibility that
the bond is not yet defaulted. Since premium are a postponed payment (unlike usual insurance
contracts).
</p>
</li>
<li><p> Intensities timetable have domains <code class="reqn">\gamma_i;  i=t_1,...,T</code>.
</p>
</li>
<li><p>  spot interest rates of bond have domain <code class="reqn">r_i; i=t_1,...,T</code>. The function transforms
spot rates in forward rates. If we specify that we want to calculate CDS rates with the
simplified alghoritm, in each period, the amount of the constant premium payment
is expressed by: </p>
<p style="text-align: center;"><code class="reqn">\pi^{pb}=\sum_{i=1}^Tp(0,i)S(0,i)\alpha_i</code>
</p>

<p>and the amount of protection, assuming a recovery rate <code class="reqn">\delta</code>, is:
</p>
<p style="text-align: center;"><code class="reqn">\pi^{ps}=(1-\delta)\sum_{i=1}^Tp(0,i)\hat{Q}(\tau=i)\alpha_i</code>
</p>

<p>If we want to calculate same quantities with the complete version, that evaluate premium in the continous,
the value of the premium leg is calculated as:
</p>
<p style="text-align: center;"><code class="reqn">\pi^{pb}(0,1)=-\int_{T_a}^{T_b}P(0,t)\cdot(t-T_{\beta(t)-1}) d_t Q
 (\tau\geq t)+\sum_{i=a+1}^bP(0,T_i)\cdot\alpha_i * Q(\tau\geq T_i)</code>
</p>
<p> and the protection leg
as:
</p>
<p style="text-align: center;"><code class="reqn">\pi_{a,b}^{ps}(1):=-\int_{t=T_a}^{T_b}P(0,t)d*Q(\tau\geq t)</code>
</p>

<p>In both versions the forward rates and intensities are supposed as costant stepwise functions
with discontinuity in <code class="reqn">t_i</code>
</p>
</li></ul>



<h3>Value</h3>

<p><code>cds</code> returns an object of class <code>data.frame</code> with columns, for esch date
<code class="reqn">t_i</code> the value of survival probability, the premium and protection leg, CDS rate
and CDS price.
</p>


<h3>References</h3>

<p>David Lando  (2004) Credit risk modeling.
</p>
<p>Damiano Brigo, Massimo Morini, Andrea Pallavicini (2013)
Counterparty Credit Risk, Collateral and Funding.
With Pricing Cases for All Asset Classes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cds(t = seq(0.5, 10, by = 0.5), int = seq(.01, 0.05, len = 20),
r = seq(0,0.02, len=20), R = 0.005, RR = 0.4, simplified = FALSE)

</code></pre>

<hr>
<h2 id='cds2'>Calculate Credit Default Swap rates</h2><span id='topic+cds2'></span>

<h3>Description</h3>

<p>Calculate CDS rates starting from default intensities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cds2(t, Tj, tr, r, tint, int, R = 0.005, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cds2_+3A_t">t</code></td>
<td>
<p>premium timetable.</p>
</td></tr>
<tr><td><code id="cds2_+3A_tj">Tj</code></td>
<td>
<p>CDS maturities.</p>
</td></tr>
<tr><td><code id="cds2_+3A_tr">tr</code></td>
<td>
<p>interest rates timetable.</p>
</td></tr>
<tr><td><code id="cds2_+3A_r">r</code></td>
<td>
<p>spot interest rates.</p>
</td></tr>
<tr><td><code id="cds2_+3A_tint">tint</code></td>
<td>
<p>intensity timetable.</p>
</td></tr>
<tr><td><code id="cds2_+3A_int">int</code></td>
<td>
<p>default intensities timetable.</p>
</td></tr>
<tr><td><code id="cds2_+3A_r">R</code></td>
<td>
<p>constant premium payment.</p>
</td></tr>
<tr><td><code id="cds2_+3A_...">...</code></td>
<td>
<p>further arguments on <code>cds</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>cds2</code> is based on <code>cds</code> but allows a more fine controll on maturities
and on discretization of <code>r</code> and <code>int</code>. In particular input <code>(t, tr, tint)</code>
can be of different length thanks to the function <a href="stats.html#topic+approx">approx</a>.
</p>


<h3>Value</h3>

<p>An object of class <code>data.frame</code> that contains the quantities calculated by <code>cds</code>
on Tj timetable.
</p>


<h3>References</h3>

<p>David Lando (2004) Credit Risk Modeling.
</p>
<p>Damiano Brigo, Massimo Morini, Andrea Pallavicini (2013)
Counterparty Credit Risk, Collateral and Funding.
With Pricing Cases for All Asset Classes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cds2(t = c(1:20),Tj = c(1:20), tr = c(1:20), r = seq(0.01,0.06, len =20),
tint = c(1:20), int= seq(0.01,0.06, len =20))

</code></pre>

<hr>
<h2 id='cdsdata'>CDS quotes from market</h2><span id='topic+cdsdata'></span>

<h3>Description</h3>


<ul>
<li> <p><code>Maturity</code>: Maturities of cds contracts expressed in years;
</p>
</li>
<li> <p><code>Par.Spread</code>: CDS rates quotes, spread that nullify the present value of the two legs;
</p>
</li>
<li> <p><code>ED.Zero.Curve</code>: EURIBOR interest rates (risk-free)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(cdsdata)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"data.frame"</code>.
</p>


<h3>Source</h3>

<p>Thomson Reuters, CDS quotes of Unicredit on 2017-01-23
</p>

<hr>
<h2 id='cum_normal_density'>Cumulative Normal Distribution Function</h2><span id='topic+cum_normal_density'></span>

<h3>Description</h3>

<p>This function calculates the cumulative normal distribution function (CDF) 
for a given value x using the Hastings approximation method. This approximation 
is typically used in finance for the calculation of option pricing probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cum_normal_density(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cum_normal_density_+3A_x">x</code></td>
<td>
<p>A numeric value or vector for which the cumulative normal distribution 
is to be calculated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses a polynomial approximation as described by E.G. Haug in 
&quot;The Complete Guide to Option Pricing Formulas&quot; to estimate the CDF of a normal distribution.
The coefficients used in the approximation are specifically chosen to minimize the error
in the tail of the distribution, which is critical for financial applications like option pricing.
</p>
<p>The polynomial approximation is applied to the normal density function:
</p>
<p style="text-align: center;"><code class="reqn">N(x) = \frac{1}{\sqrt{2\pi}} e^{-x^2/2}</code>
</p>

<p>Then, the cumulative probability is adjusted based on the sign of x:
- If x is non-negative, it returns \(1 - t\), where t is the polynomial approximation.
- If x is negative, it returns \(t\).
</p>
<p>The cumulative normal distribution function is important in statistics for hypothesis
testing and in finance for the Black-Scholes option pricing formula.
</p>


<h3>Value</h3>

<p>Returns the cumulative probability under the normal curve from \(-</p>
<p style="text-align: center;"><code class="reqn">\infty</code>
</p>
<p>\) to x.
</p>


<h3>References</h3>

<p>Haug, E.G., The Complete Guide to Option Pricing Formulas.
Hastings, C. Approximations for Digital Computers. Princeton Univ. Press, 1955.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cum_normal_density(1.96)  
cum_normal_density(-1.96) 

</code></pre>

<hr>
<h2 id='generalized_black_scholes'>Generalized Black-Scholes Option Pricing Model</h2><span id='topic+generalized_black_scholes'></span>

<h3>Description</h3>

<p>This function calculates the price of a European call or put option using the
generalized Black-Scholes formula, which extends the standard model to
incorporate a continuous dividend yield.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generalized_black_scholes(TypeFlag = c("c", "p"), S, X, Time, r, b, sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generalized_black_scholes_+3A_typeflag">TypeFlag</code></td>
<td>
<p>A character vector indicating the type of option to be priced,
either &quot;c&quot; for call options or &quot;p&quot; for put options.</p>
</td></tr>
<tr><td><code id="generalized_black_scholes_+3A_s">S</code></td>
<td>
<p>Current stock price (scalar).</p>
</td></tr>
<tr><td><code id="generalized_black_scholes_+3A_x">X</code></td>
<td>
<p>Strike price of the option (scalar).</p>
</td></tr>
<tr><td><code id="generalized_black_scholes_+3A_time">Time</code></td>
<td>
<p>Time to expiration of the option (in years).</p>
</td></tr>
<tr><td><code id="generalized_black_scholes_+3A_r">r</code></td>
<td>
<p>Risk-free interest rate (annualized).</p>
</td></tr>
<tr><td><code id="generalized_black_scholes_+3A_b">b</code></td>
<td>
<p>Cost of carry rate, b = r - q for a dividend yield q.</p>
</td></tr>
<tr><td><code id="generalized_black_scholes_+3A_sigma">sigma</code></td>
<td>
<p>Volatility of the underlying asset (annualized).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generalized Black-Scholes formula considers both the risk-free rate and
a cost of carry, making it suitable for a wider range of financial instruments,
including commodities and currencies with continuous yields.
</p>
<p>The pricing formula for call and put options is determined by:
</p>
<p style="text-align: center;"><code class="reqn">C = S e^{(b-r)T} N(d_1) - X e^{-rT} N(d_2)</code>
</p>

<p style="text-align: center;"><code class="reqn">P = X e^{-rT} N(-d_2) - S e^{(b-r)T} N(-d_1)</code>
</p>

<p>where:
</p>
<p style="text-align: center;"><code class="reqn">d_1 = \frac{\log(S / X) + (b + \sigma^2 / 2) T}{\sigma \sqrt{T}}</code>
</p>

<p style="text-align: center;"><code class="reqn">d_2 = d_1 - \sigma \sqrt{T}</code>
</p>

<p>and <code class="reqn">(N(\cdot))</code> is the cumulative normal distribution function, estimated
by the 'cum_normal_density' function.
</p>


<h3>Value</h3>

<p>Returns the price of the specified option (call or put).
</p>


<h3>References</h3>

<p>Haug, E.G., The Complete Guide to Option Pricing Formulas.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate the price of a call option
generalized_black_scholes("c", S = 100, X = 100, Time = 1, r = 0.05, b = 0.05, sigma = 0.2)
# Calculate the price of a put option
generalized_black_scholes("p", S = 100, X = 100, Time = 1, r = 0.05, b = 0.05, sigma = 0.2)

</code></pre>

<hr>
<h2 id='Merton'>Merton's model</h2><span id='topic+Merton'></span>

<h3>Description</h3>

<p><code>Merton</code> calculates the survival probability <code class="reqn">Q(\tau &gt; T)</code> for
each maturity according to the structural Merton's model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Merton(L, V0, sigma, r, t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Merton_+3A_l">L</code></td>
<td>
<p>debt face value at maturity <code>t = T</code>; if the value of
the firm <code class="reqn">V_T</code> is below the debt face value to be paid in <code class="reqn">T</code> the
company default has occurred (it is a constant value).</p>
</td></tr>
<tr><td><code id="Merton_+3A_v0">V0</code></td>
<td>
<p>firm value at time <code>t = 0</code> (it is a constant value).</p>
</td></tr>
<tr><td><code id="Merton_+3A_sigma">sigma</code></td>
<td>
<p>volatility (constant for all t).</p>
</td></tr>
<tr><td><code id="Merton_+3A_r">r</code></td>
<td>
<p>risk-free rate (constant for all t).</p>
</td></tr>
<tr><td><code id="Merton_+3A_t">t</code></td>
<td>
<p>a vector of debt maturity structure. The last value of this
vector rapresents the debt maturity T.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In Merton model the default event can occur only at debt maturity T and not before.
In this model the debt face value <code>L</code> represents the constant safety
level. In this model the firm value is the sum of the firm equity value <code>St</code> and
ad the firm debt value <code>Dt</code>. The debt value at time <code class="reqn">t &lt; T</code> is calculated by the formula:
</p>
<p style="text-align: center;"><code class="reqn">D_t = L * \exp(-r  (T - t)) - Put(t, T; V_t, L)</code>
</p>

<p>The equity value can be derived as a difference between the firm value and the debt:
</p>
<p style="text-align: center;"><code class="reqn">S_t = V_t - D_t = V_t - L * \exp(-r  (T - t)) + Put(t, T; V_t, L) = Call(t, T; V_t, L)</code>
</p>

<p>(by the put-call parity) so that in the Merton model the equity can be interpreted as a
Call option on the value of the firm.
</p>


<h3>Value</h3>

<p><code>Merton</code> returns an object of class <code>data.frame</code> with:
</p>

<ul>
<li> <p><code>Vt</code>: expected Firm value at time <code class="reqn">t &lt; T</code> calculated by the simple formula
<code class="reqn">V_t = V_0 * \exp(r t)</code>.
</p>
</li>
<li> <p><code>St</code>: firm equity value at each <code class="reqn">t &lt; T</code>. This value can be seen as a call
option on the firm value <code>V_t</code>.
</p>
</li>
<li> <p><code>Dt</code>: firm debt value at each <code class="reqn">t &lt; T</code>.
</p>
</li>
<li> <p><code>Survival</code>: survival probability for each maturity.
</p>
</li></ul>



<h3>References</h3>

<p>Damiano Brigo, Massimo Morini, Andrea Pallavicini (2013)
Counterparty Credit Risk, Collateral and Funding.
With Pricing Cases for All Asset Classes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- Merton(L = 10, V0 = 20, sigma = 0.2, r = 0.005,
              t = c(0.50, 1.00, 2.00, 3.25, 5.00, 10.00, 15.00, 20.00))
mod

plot(c(0.50, 1.00, 2.00, 3.25, 5.00, 10.00, 15.00, 20.00), mod$Surv,
     main = 'Survival Probability for different Maturity \n (Merton model)',
     xlab = 'Maturity', ylab = 'Survival Probability', type = 'b')
</code></pre>

<hr>
<h2 id='Merton.sim'>Firm value in Merton's model</h2><span id='topic+Merton.sim'></span>

<h3>Description</h3>

<p>With this function we simulate <code>n</code> trajectories of firm value based on
Merton's model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Merton.sim(V0, r, sigma, t, n, seed = as.numeric(Sys.time()))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Merton.sim_+3A_v0">V0</code></td>
<td>
<p>firm value at time <code>t = 0</code>.</p>
</td></tr>
<tr><td><code id="Merton.sim_+3A_r">r</code></td>
<td>
<p>risk-free interest rate (constant for all t).</p>
</td></tr>
<tr><td><code id="Merton.sim_+3A_sigma">sigma</code></td>
<td>
<p>volatility (constant for all t).</p>
</td></tr>
<tr><td><code id="Merton.sim_+3A_t">t</code></td>
<td>
<p>a vector of debt maturity structure.</p>
</td></tr>
<tr><td><code id="Merton.sim_+3A_n">n</code></td>
<td>
<p>number of trajectories to be generated.</p>
</td></tr>
<tr><td><code id="Merton.sim_+3A_seed">seed</code></td>
<td>
<p>starting seed, default seed is setted randomly.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The trajectories are calculated according to the equation:
</p>
<p style="text-align: center;"><code class="reqn">V_T = V_0 \exp{\int_0^T dln V_t}</code>
</p>

<p>Where we express <code>dln V_t</code> using Ito's lemma to derive the differential
of the logarithm of the firm value as:
</p>
<p style="text-align: center;"><code class="reqn">dln V_t =(\mu - \frac{\sigma^2}{2})dt + \sigma dW_t</code>
</p>



<h3>Value</h3>

<p>This function returns a matrix containing the simulated firm values.
</p>


<h3>References</h3>

<p>Gergely Daròczi, Michael Puhle, Edina Berlinger, Péter Csòka, Dàniel Havran
Màrton Michaletzky, Zsolt Tulasay, Kata Vàradi, Agnes Vidovics-Dancs (2013)
Introduction to R for Quantitative Finance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>V &lt;- Merton.sim(V0 = 20, r = 0.05, sigma = 0.2, t = seq(0, 30, by = 0.5), n = 5)
matplot(x = seq(0, 30, by = 0.5), y = V, type = 's', lty = 1, xlab = 'Time',
ylab = 'Firm value trajectories', main = "Trajectories of the firm values in the Merton's model")

</code></pre>

<hr>
<h2 id='sbtv'>Scenario Barrier Time-Varying Volatility AT1P model</h2><span id='topic+sbtv'></span>

<h3>Description</h3>

<p><code>sbtv</code> calculates the survival probability <code class="reqn">Q(\tau &gt; t)</code> and default intensity
for each maturity according to the structural SBTV model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sbtv(V0, H, p, B, sigma, r, t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sbtv_+3A_v0">V0</code></td>
<td>
<p>firm value at time <code>t = 0</code> (it is a constant value).</p>
</td></tr>
<tr><td><code id="sbtv_+3A_h">H</code></td>
<td>
<p>vector of differents safety level at time <code>t = 0</code>.</p>
</td></tr>
<tr><td><code id="sbtv_+3A_p">p</code></td>
<td>
<p>vector of the probability of different scenario (sum of p must be 1).</p>
</td></tr>
<tr><td><code id="sbtv_+3A_b">B</code></td>
<td>
<p>free positive parameter used for shaping the barrier <code>Ht</code>.</p>
</td></tr>
<tr><td><code id="sbtv_+3A_sigma">sigma</code></td>
<td>
<p>a vector of constant stepwise volatility <code class="reqn">\sigma_t</code>.</p>
</td></tr>
<tr><td><code id="sbtv_+3A_r">r</code></td>
<td>
<p>a vector of constant stepwise risk-free rate.</p>
</td></tr>
<tr><td><code id="sbtv_+3A_t">t</code></td>
<td>
<p>a vector of debt maturity structure (it is a numeric vector).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sbtv</code> is an extension of the <code>at1p</code> model. In this model the parameter <code>H0</code> used
in the <code>at1p</code> model is replaced by a random variable assuming different values in different
scenarios, each scenario with a different probability. The survival probability is calculated
as a weighted avarage of the survival probability using the formula:
</p>
<p style="text-align: center;"><code class="reqn">SBTV.Surv = \sum_{i = 1}^N p[i] * AT1P.Surv(H[i])</code>
</p>

<p>where <code>AT1P.Surv(H[i])</code> is the survival probability computed according to the AT1P model
when <code class="reqn">H_0 = H[i]</code> and with weights equal to the probabilities of the different scenarios.
</p>


<h3>Value</h3>

<p><code>sbtv</code> returns an object of class <code>data.frame</code> containing the survival probability
for each maturity. The last column is the default intensity calculated
among each interval <code class="reqn">\Delta t</code>.
</p>


<h3>References</h3>

<p>Damiano Brigo, Massimo Morini, Andrea Pallavicini (2013)
Counterparty Credit Risk, Collateral and Funding.
With Pricing Cases for All Asset Classes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- sbtv(V0 = 1, H = c(0.4, 0.8), p = c(0.95, 0.05), B = 0, sigma = rep(0.20, 10),
            r = cdsdata$ED.Zero.Curve, t = cdsdata$Maturity)
mod

plot(cdsdata$Maturity, mod$Survival, type = 'b')

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
