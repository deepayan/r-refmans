<!DOCTYPE html><html><head><title>Help for package qsimulatR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {qsimulatR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+2A+2Cccnotgate+2Cqstate-method'><p>times-ccnotgate-qstate</p></a></li>
<li><a href='#+2A+2Cccqgate+2Cqstate-method'><p>times-ccqgate-qstate</p></a></li>
<li><a href='#+2A+2Ccnotgate+2Cqstate-method'><p>times-cnotgate-qstate</p></a></li>
<li><a href='#+2A+2Ccnqgate+2Cqstate-method'><p>times-cnqgate-qstate</p></a></li>
<li><a href='#+2A+2Ccomplex+2Cqstate-method'><p>times-number-qstate</p></a></li>
<li><a href='#+2A+2Ccqgate+2Cqstate-method'><p>times-cqgate-qstate</p></a></li>
<li><a href='#+2A+2Ccswapgate+2Cqstate-method'><p>times-cswapgate-qstate</p></a></li>
<li><a href='#+2A+2Cmatrix+2Cqstate-method'><p>times-matrix-qstate</p></a></li>
<li><a href='#+2A+2Csqgate+2Cqstate-method'><p>times-sqgate-qstate</p></a></li>
<li><a href='#+2A+2Cswapgate+2Cqstate-method'><p>times-swapgate-qstate</p></a></li>
<li><a href='#CCNOT'><p>The CCNOT or toffoli gate</p></a></li>
<li><a href='#ccnotgate'><p>The CCNOT gate</p></a></li>
<li><a href='#ccqgate'><p>A twice controlled single qubit gate</p></a></li>
<li><a href='#CNOT'><p>The CNOT gate</p></a></li>
<li><a href='#cnotgate'><p>The CNOT gate</p></a></li>
<li><a href='#cnqgate'><p>n-fold controlled single qubit gate</p></a></li>
<li><a href='#cqft'><p>cqft</p></a></li>
<li><a href='#cqgate'><p>A controlled single qubit gate</p></a></li>
<li><a href='#CSWAP'><p>The CSWAP or Fredkin gate</p></a></li>
<li><a href='#cswapgate'><p>The CSWAP gate</p></a></li>
<li><a href='#export2qiskit'><p>export2qiskit</p></a></li>
<li><a href='#genComputationalBasis'><p>genComputationalBasis</p></a></li>
<li><a href='#genNoise'><p>genNoise</p></a></li>
<li><a href='#genStateNumber'><p>genStateNumber</p></a></li>
<li><a href='#genStateString'><p>genStateString</p></a></li>
<li><a href='#H'><p>The Hadarmard gate</p></a></li>
<li><a href='#hist.measurement'><p>Plot the histogram of a quantum measurement</p></a></li>
<li><a href='#Id'><p>The identity gate</p></a></li>
<li><a href='#is.bitset'><p>is.bitset</p></a></li>
<li><a href='#measure'><p>Method measure</p></a></li>
<li><a href='#noise'><p>A noise gate</p></a></li>
<li><a href='#normalise'><p>normalise</p></a></li>
<li><a href='#phase_estimation'><p>phase_estimation</p></a></li>
<li><a href='#plot+2Cqstate+2Cmissing-method'><p>plot-qstate</p></a></li>
<li><a href='#qft'><p>qft</p></a></li>
<li><a href='#qsimulatR'><p>The qsimulatR Package</p></a></li>
<li><a href='#qstate'><p>The qstate class</p></a></li>
<li><a href='#Ri'><p>The Ri gate</p></a></li>
<li><a href='#Rx'><p>The Rx gate</p></a></li>
<li><a href='#Ry'><p>The Ry gate</p></a></li>
<li><a href='#Rz'><p>The Rz gate</p></a></li>
<li><a href='#S'><p>The S gate</p></a></li>
<li><a href='#sqgate'><p>A single qubit gate</p></a></li>
<li><a href='#summary.measurement'><p>Summarize a quantum measurement</p></a></li>
<li><a href='#SWAP'><p>The SWAP gate</p></a></li>
<li><a href='#swapgate'><p>The SWAP gate</p></a></li>
<li><a href='#Tgate'><p>The Tgate gate</p></a></li>
<li><a href='#truth.table'><p>Method truth.table</p></a></li>
<li><a href='#X'><p>The X gate</p></a></li>
<li><a href='#Y'><p>The Y gate</p></a></li>
<li><a href='#Z'><p>The Z gate</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-16</td>
</tr>
<tr>
<td>Title:</td>
<td>A Quantum Computer Simulator</td>
</tr>
<tr>
<td>Description:</td>
<td>A quantum computer simulator framework with up to 24 qubits. It allows to
    define general single qubit gates and general controlled single
    qubit gates. For convenience, it currently provides the
    most common gates (X, Y, Z, H, Z, S, T, Rx, Ry, Rz, CNOT, SWAP, Toffoli or
    CCNOT, Fredkin or CSWAP). 'qsimulatR' also implements noise models.
    'qsimulatR' supports plotting of circuits and is able to
    export circuits to 'Qiskit' <a href="https://qiskit.org/">https://qiskit.org/</a>, a python package
    which can be used to run on IBM's hardware <a href="https://quantum-computing.ibm.com/">https://quantum-computing.ibm.com/</a>.</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, markdown, rmarkdown</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/HISKP-LQCD/qsimulatR">https://github.com/HISKP-LQCD/qsimulatR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/HISKP-LQCD/qsimulatR/issues">https://github.com/HISKP-LQCD/qsimulatR/issues</a></td>
</tr>
<tr>
<td>Collate:</td>
<td>'state.R' 'sqgate.R' 'ccqgate.R' 'cnotgate.R' 'cnqgate.R'
'cqgate.R' 'export2qiskit.R' 'measure.R' 'phase_estimation.R'
'plot-qstate.R' 'qft.R' 'qsimulatR-package.R' 'swapgate.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-16 09:48:50 UTC; urbach</td>
</tr>
<tr>
<td>Author:</td>
<td>Johann Ostmeyer [aut],
  Carsten Urbach [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Carsten Urbach &lt;urbach@hiskp.uni-bonn.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-16 10:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+2A+2Cccnotgate+2Cqstate-method'>times-ccnotgate-qstate</h2><span id='topic++2A+2Cccnotgate+2Cqstate-method'></span>

<h3>Description</h3>

<p>Applies a CCNOT (or toffoli) gate to a quantum state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ccnotgate,qstate'
e1 * e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2A+2B2Cccnotgate+2B2Cqstate-method_+3A_e1">e1</code></td>
<td>
<p>object of S4 class 'ccnotgate'</p>
</td></tr>
<tr><td><code id="+2B2A+2B2Cccnotgate+2B2Cqstate-method_+3A_e2">e2</code></td>
<td>
<p>object of S4 class 'qstate'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of S4 class 'qstate'
</p>

<hr>
<h2 id='+2A+2Cccqgate+2Cqstate-method'>times-ccqgate-qstate</h2><span id='topic++2A+2Cccqgate+2Cqstate-method'></span>

<h3>Description</h3>

<p>Applies a twice controlled single qubit gate to a quantum state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ccqgate,qstate'
e1 * e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2A+2B2Cccqgate+2B2Cqstate-method_+3A_e1">e1</code></td>
<td>
<p>object of S4 class 'ccqgate'</p>
</td></tr>
<tr><td><code id="+2B2A+2B2Cccqgate+2B2Cqstate-method_+3A_e2">e2</code></td>
<td>
<p>object of S4 class 'qstate'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of S4 class 'qstate'
</p>

<hr>
<h2 id='+2A+2Ccnotgate+2Cqstate-method'>times-cnotgate-qstate</h2><span id='topic++2A+2Ccnotgate+2Cqstate-method'></span>

<h3>Description</h3>

<p>Applies a CNOT gate to a quantum state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'cnotgate,qstate'
e1 * e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2A+2B2Ccnotgate+2B2Cqstate-method_+3A_e1">e1</code></td>
<td>
<p>object of S4 class 'cnotgate'</p>
</td></tr>
<tr><td><code id="+2B2A+2B2Ccnotgate+2B2Cqstate-method_+3A_e2">e2</code></td>
<td>
<p>object of S4 class 'qstate'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of S4 class 'qstate'
</p>

<hr>
<h2 id='+2A+2Ccnqgate+2Cqstate-method'>times-cnqgate-qstate</h2><span id='topic++2A+2Ccnqgate+2Cqstate-method'></span>

<h3>Description</h3>

<p>Applies n-fold controlled single qubit gate to a quantum state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'cnqgate,qstate'
e1 * e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2A+2B2Ccnqgate+2B2Cqstate-method_+3A_e1">e1</code></td>
<td>
<p>object of S4 class 'cnqgate'</p>
</td></tr>
<tr><td><code id="+2B2A+2B2Ccnqgate+2B2Cqstate-method_+3A_e2">e2</code></td>
<td>
<p>object of S4 class 'qstate'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of S4 class 'qstate'
</p>

<hr>
<h2 id='+2A+2Ccomplex+2Cqstate-method'>times-number-qstate</h2><span id='topic++2A+2Ccomplex+2Cqstate-method'></span>

<h3>Description</h3>

<p>Multiplies a quantum gate by a global (phase) factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'complex,qstate'
e1 * e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2A+2B2Ccomplex+2B2Cqstate-method_+3A_e1">e1</code></td>
<td>
<p>object of S4 class 'complex'</p>
</td></tr>
<tr><td><code id="+2B2A+2B2Ccomplex+2B2Cqstate-method_+3A_e2">e2</code></td>
<td>
<p>object of S4 class 'qstate'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of S4 class 'qstate'
</p>

<hr>
<h2 id='+2A+2Ccqgate+2Cqstate-method'>times-cqgate-qstate</h2><span id='topic++2A+2Ccqgate+2Cqstate-method'></span>

<h3>Description</h3>

<p>Applies a controlled single qubit gate to a quantum state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'cqgate,qstate'
e1 * e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2A+2B2Ccqgate+2B2Cqstate-method_+3A_e1">e1</code></td>
<td>
<p>object of S4 class 'cqgate'</p>
</td></tr>
<tr><td><code id="+2B2A+2B2Ccqgate+2B2Cqstate-method_+3A_e2">e2</code></td>
<td>
<p>object of S4 class 'qstate'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of S4 class 'qstate'
</p>

<hr>
<h2 id='+2A+2Ccswapgate+2Cqstate-method'>times-cswapgate-qstate</h2><span id='topic++2A+2Ccswapgate+2Cqstate-method'></span>

<h3>Description</h3>

<p>Applies a CSWAP gate to a quantum state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'cswapgate,qstate'
e1 * e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2A+2B2Ccswapgate+2B2Cqstate-method_+3A_e1">e1</code></td>
<td>
<p>object of S4 class 'cswapgate'</p>
</td></tr>
<tr><td><code id="+2B2A+2B2Ccswapgate+2B2Cqstate-method_+3A_e2">e2</code></td>
<td>
<p>object of S4 class 'qstate'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of S4 class 'qstate'
</p>

<hr>
<h2 id='+2A+2Cmatrix+2Cqstate-method'>times-matrix-qstate</h2><span id='topic++2A+2Cmatrix+2Cqstate-method'></span>

<h3>Description</h3>

<p>Applies a single qubit gate to a quantum state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'matrix,qstate'
e1 * e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2A+2B2Cmatrix+2B2Cqstate-method_+3A_e1">e1</code></td>
<td>
<p>object of S4 class 'matrix'</p>
</td></tr>
<tr><td><code id="+2B2A+2B2Cmatrix+2B2Cqstate-method_+3A_e2">e2</code></td>
<td>
<p>object of S4 class 'qstate'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of S4 class 'qstate'
</p>

<hr>
<h2 id='+2A+2Csqgate+2Cqstate-method'>times-sqgate-qstate</h2><span id='topic++2A+2Csqgate+2Cqstate-method'></span>

<h3>Description</h3>

<p>Applies a single qubit gate to a quantum state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'sqgate,qstate'
e1 * e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2A+2B2Csqgate+2B2Cqstate-method_+3A_e1">e1</code></td>
<td>
<p>object of S4 class 'sqgate'</p>
</td></tr>
<tr><td><code id="+2B2A+2B2Csqgate+2B2Cqstate-method_+3A_e2">e2</code></td>
<td>
<p>object of S4 class 'qstate'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of S4 class 'qstate'
</p>

<hr>
<h2 id='+2A+2Cswapgate+2Cqstate-method'>times-swapgate-qstate</h2><span id='topic++2A+2Cswapgate+2Cqstate-method'></span>

<h3>Description</h3>

<p>Applies a SWAP gate to a quantum state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'swapgate,qstate'
e1 * e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2A+2B2Cswapgate+2B2Cqstate-method_+3A_e1">e1</code></td>
<td>
<p>object of S4 class 'swapgate'</p>
</td></tr>
<tr><td><code id="+2B2A+2B2Cswapgate+2B2Cqstate-method_+3A_e2">e2</code></td>
<td>
<p>object of S4 class 'qstate'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of S4 class 'qstate'
</p>

<hr>
<h2 id='CCNOT'>The CCNOT or toffoli gate</h2><span id='topic+CCNOT'></span><span id='topic+toffoli'></span>

<h3>Description</h3>

<p>The CCNOT or toffoli gate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CCNOT(bits = c(1, 2, 3))

toffoli(bits = c(1, 2, 3))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CCNOT_+3A_bits">bits</code></td>
<td>
<p>integer vector of length two, the first bit being the control and the second
the target bit.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S4 class 'ccnotgate' object is returned
</p>

<hr>
<h2 id='ccnotgate'>The CCNOT gate</h2><span id='topic+ccnotgate'></span><span id='topic+ccnotgate-class'></span>

<h3>Description</h3>

<p>This class represents a generic CNOT gate
</p>


<h3>Slots</h3>


<dl>
<dt><code>bits</code></dt><dd><p>Integer vector of length 2. First two bits are the control bits,
third the target bit.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- qstate(nbits=3)
z &lt;- CCNOT(c(1,2,3)) * (H(1) * x)

</code></pre>

<hr>
<h2 id='ccqgate'>A twice controlled single qubit gate</h2><span id='topic+ccqgate'></span><span id='topic+ccqgate-class'></span>

<h3>Description</h3>

<p>This class represents a generic controlled gate
</p>


<h3>Details</h3>

<p>The qubits are counted from 1 to <code>nbits</code> starting with the least
significant bit.
</p>


<h3>Slots</h3>


<dl>
<dt><code>bits</code></dt><dd><p>Integer. Integer vector of bits. The first two are the control bits, the third the target bit.</p>
</dd>
<dt><code>gate</code></dt><dd><p>sqgate. The single qubit gate.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- H(1) * qstate(nbits=3)
## application of the CCX (CCNOT) gate to bit 1,2,3
z &lt;- ccqgate(bits=c(1L, 2L, 3L), gate=X(3L)) * x
z
## the same, but differently implemented
z &lt;- CCNOT(c(1,2,3)) * x
z

</code></pre>

<hr>
<h2 id='CNOT'>The CNOT gate</h2><span id='topic+CNOT'></span>

<h3>Description</h3>

<p>The CNOT gate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CNOT(bits = c(1, 2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CNOT_+3A_bits">bits</code></td>
<td>
<p>integer vector of length two, the first bit being the control and the second
the target bit.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S4 class 'cnotgate' object is returned
</p>

<hr>
<h2 id='cnotgate'>The CNOT gate</h2><span id='topic+cnotgate'></span><span id='topic+cnotgate-class'></span>

<h3>Description</h3>

<p>This class represents a generic CNOT gate
</p>


<h3>Slots</h3>


<dl>
<dt><code>bits</code></dt><dd><p>Integer vector of length 2. First bit is the control bit,
second the target bit.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- qstate(nbits=2)
## A Bell state
z &lt;- CNOT(c(1,2)) * (H(1) * x)

</code></pre>

<hr>
<h2 id='cnqgate'>n-fold controlled single qubit gate</h2><span id='topic+cnqgate'></span><span id='topic+cnqgate-class'></span>

<h3>Description</h3>

<p>This class represents a generic n-fold controlled gate
</p>


<h3>Details</h3>

<p>The qubits are counted from 1 to <code>nbits</code> starting with the least
significant bit.
</p>


<h3>Slots</h3>


<dl>
<dt><code>cbits</code></dt><dd><p>Integer. Integer vector of control bits.</p>
</dd>
<dt><code>tbit</code></dt><dd><p>Integer. Target bit.</p>
</dd>
<dt><code>gate</code></dt><dd><p>sqgate. The single qubit gate.</p>
</dd>
<dt><code>inverse</code></dt><dd><p>Logical. Boolean vector of same length as <code>cbits</code>. If
<code>TRUE</code>, the corresponding control bit is negated.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- H(1) * qstate(nbits=3)
## application of the CCX (CCNOT) gate to bits 1,2 and 3
z &lt;- cnqgate(cbits=c(1L, 2L), tbit=3L, gate=X(3L)) * x
z
## the same, but differently implemented
z &lt;- CCNOT(c(1,2,3)) * x
z

</code></pre>

<hr>
<h2 id='cqft'>cqft</h2><span id='topic+cqft'></span>

<h3>Description</h3>

<p>performs the controlled quantum Fourier Trafo on the qstate x and the
specified list of qubits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cqft(c, x, inverse = FALSE, bits)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cqft_+3A_c">c</code></td>
<td>
<p>integer. a single control qubit.</p>
</td></tr>
<tr><td><code id="cqft_+3A_x">x</code></td>
<td>
<p>qstate. state the qft will applied to</p>
</td></tr>
<tr><td><code id="cqft_+3A_inverse">inverse</code></td>
<td>
<p>boolean. If 'TRUE', perform inverse transform</p>
</td></tr>
<tr><td><code id="cqft_+3A_bits">bits</code></td>
<td>
<p>integer. list of qubits to include in the trafo. if
missing, <code>bits=c(1:n)[-c]</code> is assumed, with <code>n</code> the number of qubits
in <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Controlled Quantum Fourier Trafo
</p>
<p>The Fourier Trafo is defined as
</p>
<p style="text-align: center;"><code class="reqn">|j&gt; -&gt; 1/sqrt(N) sum_k=0^N_1 exp(2 pi i j k/N) |k&gt;</code>
</p>

<p>the inverse with the oposite sign in the exponential.
</p>


<h3>Value</h3>

<p>a <code>qstate</code> object with the quantum Fourier trafo of input <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- qstate(3)
y &lt;- cqft(1, x)
z &lt;- cqft(1, y, inverse=TRUE)

</code></pre>

<hr>
<h2 id='cqgate'>A controlled single qubit gate</h2><span id='topic+cqgate'></span><span id='topic+cqgate-class'></span>

<h3>Description</h3>

<p>This class represents a generic controlled gate
</p>


<h3>Details</h3>

<p>The qubits are counted from 1 to <code>nbits</code> starting with the least
significant bit.
</p>


<h3>Slots</h3>


<dl>
<dt><code>bits</code></dt><dd><p>Integer. Integer vector of bits. The first is the control bit, the second the target bit.</p>
</dd>
<dt><code>gate</code></dt><dd><p>sqgate. The single qubit gate.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- H(1) * qstate(nbits=2)
## application of the CX (CNOT) gate to bit 1,2
z &lt;- cqgate(bits=c(1L, 2L), gate=X(2L)) * x
z
## the same as, but differently implemented
z &lt;- CNOT(c(1,2)) * x
z

</code></pre>

<hr>
<h2 id='CSWAP'>The CSWAP or Fredkin gate</h2><span id='topic+CSWAP'></span><span id='topic+fredkin'></span>

<h3>Description</h3>

<p>The CSWAP or Fredkin gate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CSWAP(bits = c(1, 2, 3))

fredkin(bits = c(1, 2, 3))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CSWAP_+3A_bits">bits</code></td>
<td>
<p>integer vector of length two, the first bit being the control and the second
the target bit.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S4 class 'cswapgate' object is returned
</p>

<hr>
<h2 id='cswapgate'>The CSWAP gate</h2><span id='topic+cswapgate'></span><span id='topic+cswapgate-class'></span>

<h3>Description</h3>

<p>This class represents a generic SWAP gate, also called Fredkin gate
</p>


<h3>Slots</h3>


<dl>
<dt><code>bits</code></dt><dd><p>Integer vector of length 2. First two bits are the control bits,
third the target bit.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- qstate(nbits=3)
z &lt;- CSWAP(c(1,2,3)) * (H(1) * x)

</code></pre>

<hr>
<h2 id='export2qiskit'>export2qiskit</h2><span id='topic+export2qiskit'></span>

<h3>Description</h3>

<p>export a circuit to IBM's qiskit python format. Note that only
gates can be exported where the correspondence in qiskit is known
and well defined. Qiskit can then be used for IBM's QASM to run on
real hardware.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export2qiskit(object, varname = "qc", filename = "circuit.py",
  append = FALSE, import = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="export2qiskit_+3A_object">object</code></td>
<td>
<p>a qstate object</p>
</td></tr>
<tr><td><code id="export2qiskit_+3A_varname">varname</code></td>
<td>
<p>character. The name of the circuit variable</p>
</td></tr>
<tr><td><code id="export2qiskit_+3A_filename">filename</code></td>
<td>
<p>character. The filename of the textfile where to store the circuit</p>
</td></tr>
<tr><td><code id="export2qiskit_+3A_append">append</code></td>
<td>
<p>boolean. Whether or not to append to the file. For this the file has to exist.</p>
</td></tr>
<tr><td><code id="export2qiskit_+3A_import">import</code></td>
<td>
<p>boolean. Shall numpy and qiskit be loaded explicitly?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Export to IBM's Qiskit
</p>
<p>Currently the following gates can be exported: H, X, Y, Z, S,
Tgate, Rz, Rx, Ry, CNOT, SWAP, CCNOT, CSWAP, measure.
</p>
<p>note that only standard gates can be exported, not self defined ones.
The function will draw a warning in case a gate cannot be exported
and indicate it in the output file.
</p>


<h3>Value</h3>

<p>nothing is returned, but a file is created.
</p>


<h3>References</h3>

<p>https://qiskit.org/documentation/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- qstate(2)
x &lt;- H(1) * x
x &lt;- X(2) * x
x &lt;- CNOT(c(1,2)) * x
export2qiskit(measure(x,1)$psi)
cat(readLines("circuit.py"), sep = '\n')
file.remove("circuit.py")

</code></pre>

<hr>
<h2 id='genComputationalBasis'>genComputationalBasis</h2><span id='topic+genComputationalBasis'></span>

<h3>Description</h3>

<p>function to generate the basis strings for given number of
bits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genComputationalBasis(nbits, collapse = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genComputationalBasis_+3A_nbits">nbits</code></td>
<td>
<p>integer. The number of qubits</p>
</td></tr>
<tr><td><code id="genComputationalBasis_+3A_collapse">collapse</code></td>
<td>
<p>character. String to fill in between separate bits</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector of length 2^nbits
</p>


<h3>Examples</h3>

<pre><code class='language-R'>genComputationalBasis(4)
genComputationalBasis(2, collapse="&gt;|")

</code></pre>

<hr>
<h2 id='genNoise'>genNoise</h2><span id='topic+genNoise'></span>

<h3>Description</h3>

<p>function to generate the noise list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genNoise(nbits, p = 0, bits = 1:nbits, error = "any", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genNoise_+3A_nbits">nbits</code></td>
<td>
<p>integer. The number of qubits</p>
</td></tr>
<tr><td><code id="genNoise_+3A_p">p</code></td>
<td>
<p>probability with which noise is applied after every gate</p>
</td></tr>
<tr><td><code id="genNoise_+3A_bits">bits</code></td>
<td>
<p>integer or integer array. The bit to which to apply the gate.</p>
</td></tr>
<tr><td><code id="genNoise_+3A_error">error</code></td>
<td>
<p>String containing the error model.</p>
</td></tr>
<tr><td><code id="genNoise_+3A_...">...</code></td>
<td>
<p>Additional arguments to be stored in <code>args</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See function <code>noise</code> for details.
</p>


<h3>Value</h3>

<p>a list containing <code>p</code>, <code>bits</code>, <code>error</code> and
<code>args</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>genNoise(4)
genNoise(2, p=1, error="small", sigma=0.1)

</code></pre>

<hr>
<h2 id='genStateNumber'>genStateNumber</h2><span id='topic+genStateNumber'></span>

<h3>Description</h3>

<p>function to generate the bit representation for a specific basis state
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genStateNumber(int, nbits)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genStateNumber_+3A_int">int</code></td>
<td>
<p>integer number representing the basis state</p>
</td></tr>
<tr><td><code id="genStateNumber_+3A_nbits">nbits</code></td>
<td>
<p>integer. The number of qubits</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a integer vector of length <code>nbits</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>genStateNumber(5, 4)
genStateNumber(2, 2)

</code></pre>

<hr>
<h2 id='genStateString'>genStateString</h2><span id='topic+genStateString'></span>

<h3>Description</h3>

<p>function to generate the string for a specific basis state
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genStateString(int, nbits, collapse = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genStateString_+3A_int">int</code></td>
<td>
<p>integer number representing the basis state</p>
</td></tr>
<tr><td><code id="genStateString_+3A_nbits">nbits</code></td>
<td>
<p>integer. The number of qubits</p>
</td></tr>
<tr><td><code id="genStateString_+3A_collapse">collapse</code></td>
<td>
<p>character. String to fill in between separate bits</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character
</p>


<h3>Examples</h3>

<pre><code class='language-R'>genStateString(5, 4)
genStateString(2, 2, collapse="&gt;|")

</code></pre>

<hr>
<h2 id='H'>The Hadarmard gate</h2><span id='topic+H'></span>

<h3>Description</h3>

<p>The Hadarmard gate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>H(bit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="H_+3A_bit">bit</code></td>
<td>
<p>integer. The bit to which to apply the gate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S4 class 'sqgate' object is returned
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- qstate(nbits=2)
z &lt;- H(1) * x
z

</code></pre>

<hr>
<h2 id='hist.measurement'>Plot the histogram of a quantum measurement</h2><span id='topic+hist.measurement'></span>

<h3>Description</h3>

<p>Plot the histogram of a quantum measurement
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'measurement'
hist(x, only.nonzero = TRUE, by.name = only.nonzero,
  freq = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hist.measurement_+3A_x">x</code></td>
<td>
<p>object as returned by <code>measure</code></p>
</td></tr>
<tr><td><code id="hist.measurement_+3A_only.nonzero">only.nonzero</code></td>
<td>
<p>are the states with zero measurements to be plotted?</p>
</td></tr>
<tr><td><code id="hist.measurement_+3A_by.name">by.name</code></td>
<td>
<p>shall the xlabel contain the basis names? If <code>FALSE</code>, the
index number is used.</p>
</td></tr>
<tr><td><code id="hist.measurement_+3A_freq">freq</code></td>
<td>
<p>shall the total counts be plotted? If not, the values are
normalised to 1.</p>
</td></tr>
<tr><td><code id="hist.measurement_+3A_...">...</code></td>
<td>
<p>Generic parameters to pass on to <code>barplot()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>

<hr>
<h2 id='Id'>The identity gate</h2><span id='topic+Id'></span>

<h3>Description</h3>

<p>The identity gate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Id(bit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Id_+3A_bit">bit</code></td>
<td>
<p>integer. The bit to which to apply the gate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S4 class 'sqgate' object is returned
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- qstate(nbits=2)
z &lt;- Id(1) * x
z

</code></pre>

<hr>
<h2 id='is.bitset'>is.bitset</h2><span id='topic+is.bitset'></span>

<h3>Description</h3>

<p>checks whether or not a bit is set in target
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.bitset(x, bit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.bitset_+3A_x">x</code></td>
<td>
<p>target vector</p>
</td></tr>
<tr><td><code id="is.bitset_+3A_bit">bit</code></td>
<td>
<p>integer. The bit to check</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a boolean vector
</p>

<hr>
<h2 id='measure'>Method measure</h2><span id='topic+measure'></span><span id='topic+measure+2Cqstate-method'></span>

<h3>Description</h3>

<p>performs a masurement on a <code>qstate</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>measure(e1, bit = NA, repetitions = NA)

## S4 method for signature 'qstate'
measure(e1, bit = NA, repetitions = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="measure_+3A_e1">e1</code></td>
<td>
<p>object to measure</p>
</td></tr>
<tr><td><code id="measure_+3A_bit">bit</code></td>
<td>
<p>bit to project on</p>
</td></tr>
<tr><td><code id="measure_+3A_repetitions">repetitions</code></td>
<td>
<p>number of measurements</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>measure(e1, bit, repetitions)</code> performs <code>repetitions</code> many
projections/measurements of the qubit <code>bit</code>. If <code>bit</code> is not given
explicitly, all qubits are projected.
</p>


<h3>Value</h3>

<p><code>measure(e1, bit, repetitions)</code> returns a list with the measured <code>bit</code>,
the number of <code>repetitions</code>, the probability distribution of all states
<code>prob</code> and the results vector <code>value</code>. If all bits are measured, the
basis is added to the list as <code>basis</code>. The collapsed state is stored as
<code>psi</code> if exactly one measurement is performed.
In the case of a single qubit measurement <code>value</code> is of length <code>repetitions</code>
and contains all the results of this projection. Otherwise <code>value</code> is of
length 2^nbits and it contains the counts how often each state has been
obtained.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## measure the separate bits
x &lt;- H(1) * (H(2) * qstate(nbits=2))
summary(measure(x, bit=1))
hist(measure(x, rep=100))
</code></pre>

<hr>
<h2 id='noise'>A noise gate</h2><span id='topic+noise'></span>

<h3>Description</h3>

<p>A noise gate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noise(bit, p = 1, error = "any", type = "ERR", args = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="noise_+3A_bit">bit</code></td>
<td>
<p>integer or integer array. The bit to which to apply the gate. If
an array is provided, the gate will be applied randomly to one of the bits
only.</p>
</td></tr>
<tr><td><code id="noise_+3A_p">p</code></td>
<td>
<p>probability with which noise is applied</p>
</td></tr>
<tr><td><code id="noise_+3A_error">error</code></td>
<td>
<p>one of &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, &quot;small&quot; or &quot;any&quot;. The model which the noise
follows. Can be one of the Pauli matrices (X,Y,Z), a random SU(2)-matrix
with a small deviation <code>sigma</code> from the identity (&quot;small&quot;) or an
arbitrary, uniformly sampled, SU(2)-matrix (&quot;any&quot;).</p>
</td></tr>
<tr><td><code id="noise_+3A_type">type</code></td>
<td>
<p>a character vector representing the type of gate</p>
</td></tr>
<tr><td><code id="noise_+3A_args">args</code></td>
<td>
<p>a list of further arguments passed to specific error models. For
<code>error="small"</code> the standard deviation <code>sigma</code> has to be provided
here (default=1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S4 class 'sqgate' object is returned
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- noise(1, error="X") * qstate(nbits=2)
x
y &lt;- noise(2, p=0.5) * x
y
z &lt;- noise(2, error="small", args=list(sigma=0.1)) * x
z

</code></pre>

<hr>
<h2 id='normalise'>normalise</h2><span id='topic+normalise'></span>

<h3>Description</h3>

<p>Normalises a complex vector to 1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalise(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalise_+3A_x">x</code></td>
<td>
<p>complex valued vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the normalised complex valued vector
</p>

<hr>
<h2 id='phase_estimation'>phase_estimation</h2><span id='topic+phase_estimation'></span>

<h3>Description</h3>

<p>phase estimation algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phase_estimation(bitmask, FUN, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phase_estimation_+3A_bitmask">bitmask</code></td>
<td>
<p>integer. Vector of qubits for the t qubit wide
register needed for the phase estimation</p>
</td></tr>
<tr><td><code id="phase_estimation_+3A_fun">FUN</code></td>
<td>
<p>a function implementing the controlled application of
a unitary operator U to the power 2^(j-1) to the state x. It's first
argument must be the control qubit 'c', the second the integer 'j'
and the third the state 'x'. Additional parameters can be passed
via '...'.</p>
</td></tr>
<tr><td><code id="phase_estimation_+3A_x">x</code></td>
<td>
<p>a 'qstate' object</p>
</td></tr>
<tr><td><code id="phase_estimation_+3A_...">...</code></td>
<td>
<p>additional parameter to be passed on to 'FUN'</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## NOT^k = Id if k even
cnotwrapper &lt;- function(c, j, x, t) {
  if(j == 1) return(CNOT(c(c, t)) * x)
  return(Id(t) * x)
}
x &lt;- X(1) * qstate(3)
## X has eigenvalues lambda=1 and lambda=-1
## thus phases 0 and 1/2
x &lt;- phase_estimation(bitmas=c(2:3), FUN=cnotwrapper, x=x, t=1)
x

</code></pre>

<hr>
<h2 id='plot+2Cqstate+2Cmissing-method'>plot-qstate</h2><span id='topic+plot+2Cqstate+2Cmissing-method'></span><span id='topic+plot'></span>

<h3>Description</h3>

<p>Plots a circuit corresponding to a qstate object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'qstate,missing'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2Cqstate+2B2Cmissing-method_+3A_x">x</code></td>
<td>
<p>qstate object</p>
</td></tr>
<tr><td><code id="plot+2B2Cqstate+2B2Cmissing-method_+3A_y">y</code></td>
<td>
<p>not used here</p>
</td></tr>
<tr><td><code id="plot+2B2Cqstate+2B2Cmissing-method_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed on</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing is returned, but a plot created
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- qstate(2)
y &lt;- H(1) * x
z &lt;- CNOT(c(1,2)) * y
plot(z)

</code></pre>

<hr>
<h2 id='qft'>qft</h2><span id='topic+qft'></span>

<h3>Description</h3>

<p>performs the quantum Fourier Trafo on the qstate x and the
specified list of qubits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qft(x, inverse = FALSE, bits)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qft_+3A_x">x</code></td>
<td>
<p>qstate</p>
</td></tr>
<tr><td><code id="qft_+3A_inverse">inverse</code></td>
<td>
<p>boolean. If 'TRUE', perform inverse transform</p>
</td></tr>
<tr><td><code id="qft_+3A_bits">bits</code></td>
<td>
<p>integer. list of qubits to include in the trafo. if
missing, <code>bits=c(1:n)</code> is assumed, with <code>n</code> the number of qubits
in <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Quantum Fourier Trafo
</p>
<p>The Fourier Trafo is defined as
</p>
<p style="text-align: center;"><code class="reqn">|j&gt; -&gt; 1/sqrt(N) sum_k=0^N_1 exp(2 pi i j k/N) |k&gt;</code>
</p>

<p>the inverse with the oposite sign in the exponential.
</p>


<h3>Value</h3>

<p>a <code>qstate</code> object with the quantum Fourier trafo of input <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- qstate(3)
y &lt;- qft(x)
z &lt;- qft(y, inverse=TRUE)

</code></pre>

<hr>
<h2 id='qsimulatR'>The qsimulatR Package</h2><span id='topic+qsimulatR'></span>

<h3>Description</h3>

<p>A simulator for a quantum computer
</p>


<h3>Details</h3>

<p>A quantum computer simulator framework. General single qubit gates
and general controlled single qubit gates can be easily defined.
For convenience, it currently directly provides
most common gates (X, Y, Z, H, Z, S, T, Rx, Ry, Rz, CNOT, SWAP,
toffoli or CCNOT, CSWAP). 'qsimulatR' supports plotting
of circuits and is able to export circuits into IBM's 'Qiskit' python
package, which can be run on IBM's real quantum hardware.
'qsimulatR' currently works for up to 24 qubits (a virtual
restriction, which can be lifted).
</p>


<h3>Author(s)</h3>

<p>Johann Ostemeyer, Carsten Urbach, <a href="mailto:urbach@hiskp.uni-bonn.de">urbach@hiskp.uni-bonn.de</a>
</p>

<hr>
<h2 id='qstate'>The qstate class</h2><span id='topic+qstate'></span><span id='topic+qstate-class'></span>

<h3>Description</h3>

<p>This class represents a quantum state
</p>


<h3>Details</h3>

<p>The qubits are counted from 1 to <code>nbits</code> starting with the least
significant bit.
</p>


<h3>Slots</h3>


<dl>
<dt><code>nbits</code></dt><dd><p>The number of qubits</p>
</dd>
<dt><code>coefs</code></dt><dd><p>The 2^nbits complex valued vector of coefficients</p>
</dd>
<dt><code>basis</code></dt><dd><p>String or vector of strings. A single string will be interpreted
as the <code>collapse</code>-parameter in <code>genComputationalBasis</code>. A vector
of length 2^nbits yields the basis directly.</p>
</dd>
<dt><code>noise</code></dt><dd><p>List containing the probability <code>p</code> some noise is applied
to one of the <code>bits</code> after a gate application, the model
<code>error</code> of this noise and further arguments <code>args</code> to be passed to the
function <code>noise</code>. See function <code>noise</code> for details.
The list <code>noise</code> can be generated with <code>genNoise</code>.</p>
</dd>
<dt><code>circuit</code></dt><dd><p>List containing the number of non-quantum bits <code>ncbits</code>
and a list of gates <code>gatelist</code> applied to the original state.
Filled automatically as gates are applied, required for plotting.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- qstate(nbits=2)
x

x &lt;- qstate(nbits=2, coefs=as.complex(sqrt(rep(0.25, 4))), basis=",")
x

x &lt;- qstate(nbits=1, coefs=as.complex(sqrt(rep(0.5, 2))), basis=c("|dead&gt;", "|alive&gt;"))
x

x &lt;- qstate(nbits=2, noise=genNoise(nbits=2, p=1))
Id(2) * x

x &lt;- qstate(nbits=3, noise=genNoise(p=1, bits=1:2, error="small", sigma=0.1))
Id(2) * x

</code></pre>

<hr>
<h2 id='Ri'>The Ri gate</h2><span id='topic+Ri'></span>

<h3>Description</h3>

<p>The Ri gate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ri(bit, i, sign = +1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ri_+3A_bit">bit</code></td>
<td>
<p>integer. The bit to which to apply the gate</p>
</td></tr>
<tr><td><code id="Ri_+3A_i">i</code></td>
<td>
<p>integer</p>
</td></tr>
<tr><td><code id="Ri_+3A_sign">sign</code></td>
<td>
<p>integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implements the gate
( 1   0                )
( 0   exp(+-2<em>pi</em>1i/2^i) )
</p>
<p>If 'sign &lt; 0', the inverse of the exponential is used.
This gate is up to global phase identical with the 'Rz'
gate with specific values of the angle.
</p>


<h3>Value</h3>

<p>An S4 class 'sqgate' object is returned
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- X(1) * qstate(nbits=2)
z &lt;- Ri(1, i=2) * x
z

</code></pre>

<hr>
<h2 id='Rx'>The Rx gate</h2><span id='topic+Rx'></span>

<h3>Description</h3>

<p>The Rx gate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rx(bit, theta = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rx_+3A_bit">bit</code></td>
<td>
<p>integer. The bit to which to apply the gate</p>
</td></tr>
<tr><td><code id="Rx_+3A_theta">theta</code></td>
<td>
<p>numeric. angle</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S4 class 'sqgate' object is returned
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- qstate(nbits=2)
z &lt;- Rx(1, pi/4) * x
z

</code></pre>

<hr>
<h2 id='Ry'>The Ry gate</h2><span id='topic+Ry'></span>

<h3>Description</h3>

<p>The Ry gate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ry(bit, theta = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ry_+3A_bit">bit</code></td>
<td>
<p>integer. The bit to which to apply the gate</p>
</td></tr>
<tr><td><code id="Ry_+3A_theta">theta</code></td>
<td>
<p>numeric. angle</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S4 class 'sqgate' object is returned
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- qstate(nbits=2)
z &lt;- Ry(1, pi/4) * x
z

</code></pre>

<hr>
<h2 id='Rz'>The Rz gate</h2><span id='topic+Rz'></span>

<h3>Description</h3>

<p>The Rz gate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rz(bit, theta = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rz_+3A_bit">bit</code></td>
<td>
<p>integer. The bit to which to apply the gate</p>
</td></tr>
<tr><td><code id="Rz_+3A_theta">theta</code></td>
<td>
<p>numeric. angle</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S4 class 'sqgate' object is returned
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- qstate(nbits=2)
z &lt;- Rz(1, pi/4) * x
z

</code></pre>

<hr>
<h2 id='S'>The S gate</h2><span id='topic+S'></span>

<h3>Description</h3>

<p>The S gate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>S(bit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="S_+3A_bit">bit</code></td>
<td>
<p>integer. The bit to which to apply the gate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S4 class 'sqgate' object is returned
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- X(1) * qstate(nbits=2)
z &lt;- S(1) * x
z

</code></pre>

<hr>
<h2 id='sqgate'>A single qubit gate</h2><span id='topic+sqgate'></span><span id='topic+sqgate-class'></span>

<h3>Description</h3>

<p>This class represents a generic single qubit gate
</p>


<h3>Details</h3>

<p>The qubits are counted from 1 to <code>nbits</code> starting with the least
significant bit.
</p>


<h3>Slots</h3>


<dl>
<dt><code>bit</code></dt><dd><p>Integer. The single bit to act on.</p>
</dd>
<dt><code>M</code></dt><dd><p>complex valued array. The 2x2 matrix representing the
gate</p>
</dd>
<dt><code>type</code></dt><dd><p>a character vector representing the type of gate</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- qstate(nbits=2)
## application of the X (NOT) gate to bit 1
z &lt;- sqgate(bit=1L, M=array(as.complex(c(0,1,1,0)), dim=c(2,2))) * x
z

</code></pre>

<hr>
<h2 id='summary.measurement'>Summarize a quantum measurement</h2><span id='topic+summary.measurement'></span>

<h3>Description</h3>

<p>Summarize a quantum measurement
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'measurement'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.measurement_+3A_object">object</code></td>
<td>
<p>as returned by <code>measure</code></p>
</td></tr>
<tr><td><code id="summary.measurement_+3A_...">...</code></td>
<td>
<p>Generic parameters to pass on, not used here.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>

<hr>
<h2 id='SWAP'>The SWAP gate</h2><span id='topic+SWAP'></span>

<h3>Description</h3>

<p>The SWAP gate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SWAP(bits = c(1, 2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SWAP_+3A_bits">bits</code></td>
<td>
<p>integer vector of length two, containing the bits to swap.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S4 class 'swapgate' object is returned
</p>

<hr>
<h2 id='swapgate'>The SWAP gate</h2><span id='topic+swapgate'></span><span id='topic+swapgate-class'></span>

<h3>Description</h3>

<p>This class represents a generic SWAP gate
</p>


<h3>Slots</h3>


<dl>
<dt><code>bits</code></dt><dd><p>Integer vector of length 2. The two bits to swap.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- H(1) * qstate(nbits=2)
z &lt;- SWAP(c(1,2)) * (H(1) * x)

</code></pre>

<hr>
<h2 id='Tgate'>The Tgate gate</h2><span id='topic+Tgate'></span>

<h3>Description</h3>

<p>The Tgate gate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Tgate(bit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Tgate_+3A_bit">bit</code></td>
<td>
<p>integer. The bit to which to apply the gate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S4 class 'sqgate' object is returned
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- X(1)*qstate(nbits=2)
z &lt;- Tgate(1) * x
z

</code></pre>

<hr>
<h2 id='truth.table'>Method truth.table</h2><span id='topic+truth.table'></span>

<h3>Description</h3>

<p>Method truth.table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>truth.table(e1, nbits, bits, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="truth.table_+3A_e1">e1</code></td>
<td>
<p>gate to measure.</p>
</td></tr>
<tr><td><code id="truth.table_+3A_nbits">nbits</code></td>
<td>
<p>number of bits the gate acts on.</p>
</td></tr>
<tr><td><code id="truth.table_+3A_bits">bits</code></td>
<td>
<p>optional vector of length <code>nbits</code> containing the qubit order in the gate.</p>
</td></tr>
<tr><td><code id="truth.table_+3A_...">...</code></td>
<td>
<p>additional parameters to passed be on to 'e1'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>calculates the quantum truth table of the gate <code>e1</code>.
If a basis state is transformed to a superposition of basis states by
the gate, the result is 'NA'.
</p>


<h3>Value</h3>

<p>returns a data.frame containing the truth table. Each row corresponds
to one input-output combination. Each column to one specific bit.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## truth table for a single bit gate
truth.table(X, 1)
## for a 2-bit gate
truth.table(CNOT, 2)
## for a 2-bit gate with reversed controll and target bits
truth.table(CNOT, bits=2:1)
## for a general controlled gate
truth.table(cqgate, 2, gate=H(2))
## for an arbitrary circuit (here a swap implementation using only CNOTs)
myswap &lt;- function(bits){ function(x){ CNOT(bits) * (CNOT(rev(bits)) * (CNOT(bits) * x))}}
truth.table(myswap, 2)

</code></pre>

<hr>
<h2 id='X'>The X gate</h2><span id='topic+X'></span>

<h3>Description</h3>

<p>The X gate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>X(bit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="X_+3A_bit">bit</code></td>
<td>
<p>integer. The bit to which to apply the gate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S4 class 'sqgate' object is returned
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- qstate(nbits=2)
z &lt;- X(1) * x
z

</code></pre>

<hr>
<h2 id='Y'>The Y gate</h2><span id='topic+Y'></span>

<h3>Description</h3>

<p>The Y gate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Y(bit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Y_+3A_bit">bit</code></td>
<td>
<p>integer. The bit to which to apply the gate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S4 class 'sqgate' object is returned
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- qstate(nbits=2)
z &lt;- Y(1) * x
z

</code></pre>

<hr>
<h2 id='Z'>The Z gate</h2><span id='topic+Z'></span>

<h3>Description</h3>

<p>The Z gate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Z(bit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Z_+3A_bit">bit</code></td>
<td>
<p>integer. The bit to which to apply the gate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S4 class 'sqgate' object is returned
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- X(1) * qstate(nbits=2)
z &lt;- Z(1) * x
z

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
