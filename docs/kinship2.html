<!DOCTYPE html><html><head><title>Help for package kinship2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {kinship2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#align.pedigree'>
<p>Generate plotting information for a pedigree</p></a></li>
<li><a href='#as.data.frame.pedigree'><p>data.frame from a pedigree object</p></a></li>
<li><a href='#autohint'>
<p>Align a pedigree to print well</p></a></li>
<li><a href='#bitSize'>
<p>Calculate pedigree bitsize, defined as 2 * # NonFounders - # Founders</p></a></li>
<li><a href='#familycheck'>
<p>Error check for a family classification</p></a></li>
<li><a href='#findAvailAffected'>
<p>Find a single person to trim from a pedigree whose is available</p></a></li>
<li><a href='#findAvailNonInform'>
<p>Find subjects from a pedigree who are available and uninformative</p></a></li>
<li><a href='#findUnavailable'>
<p>Find or trim unavailable subjects in a pedigree</p></a></li>
<li><a href='#fixParents'><p>Fix details on the parents for children of the pedigree</p></a></li>
<li><a href='#ibdMatrix'><p>Create an IBD matrix</p></a></li>
<li><a href='#kindepth'><p>Compute the depth of each subject in a pedigree</p></a></li>
<li><a href='#kinship'>
<p>Compute a kinship matrix</p></a></li>
<li><a href='#kinship2'><p>The kinship2 package for pedigree data</p></a></li>
<li><a href='#legendPlot'><p>Legend Pedigree Plot</p></a></li>
<li><a href='#makefamid'><p>Construct a family id from pedigree information</p></a></li>
<li><a href='#makekinship'>
<p>Create a sparse kinship matrix</p></a></li>
<li><a href='#minnbreast'><p>Minnesota Breast Cancer Study</p></a></li>
<li><a href='#pedigree'><p>Create a pedigree or pedigreeList object</p></a></li>
<li><a href='#pedigree.legend'><p>plot a legend for a pedigree</p></a></li>
<li><a href='#pedigree.shrink'><p>Shrink pedigree object</p></a></li>
<li><a href='#pedigree.unrelated'><p>Determine set of maximum number of unrelated available subjects</p>
from a pedigree</a></li>
<li><a href='#plot.pedigree'>
<p>plot pedigrees</p></a></li>
<li><a href='#plot.pedigree.shrink'>
<p>plot pedigree.shrink object that is a shrunk pedigree object</p></a></li>
<li><a href='#sample.ped'><p> Two example pedigrees</p></a></li>
<li><a href='#testped1'><p> testped1</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.9.6.1</td>
</tr>
<tr>
<td>Title:</td>
<td>Pedigree Functions</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0), Matrix, quadprog</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats, methods, knitr</td>
</tr>
<tr>
<td>Description:</td>
<td>Routines to handle family data with a pedigree object. The initial purpose
	     was to create correlation structures that describe family relationships such 
	     as kinship and identity-by-descent, which can be used to model family data 
	     in mixed effects models, such as in the coxme function. Also includes a tool
	     for pedigree drawing which is focused on producing compact layouts without 
	     intervention. Recent additions include utilities to trim the pedigree object
	     with various criteria, and kinship for the X chromosome.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://cran.r-project.org/package=kinship2">https://cran.r-project.org/package=kinship2</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-24 10:56:31 UTC; hornik</td>
</tr>
<tr>
<td>Author:</td>
<td>Jason Sinnwell [aut, cre],
  Terry Therneau [aut],
  Daniel Schaid [ctb],
  Elizabeth Atkinson [ctb],
  Carly Mester [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jason Sinnwell &lt;sinnwell.jason@mayo.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-24 14:45:15 UTC</td>
</tr>
</table>
<hr>
<h2 id='align.pedigree'>
Generate plotting information for a pedigree
</h2><span id='topic+align.pedigree'></span>

<h3>Description</h3>

<p>Given a pedigree, this function creates helper matrices that descibe
the layout of a plot of the pedigree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>align.pedigree(ped, packed=TRUE, width=10, align=TRUE, hints=ped$hints)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="align.pedigree_+3A_ped">ped</code></td>
<td>
<p>a pedigree object</p>
</td></tr>
<tr><td><code id="align.pedigree_+3A_packed">packed</code></td>
<td>

<p>should the pedigree be compressed, i.e., to allow diagonal lines connecting
parents to children in order to have a smaller overall width for the plot.
</p>
</td></tr>
<tr><td><code id="align.pedigree_+3A_hints">hints</code></td>
<td>
<p>plotting hints for the pedigree.
This is a list with components <code>order</code> and <code>spouse</code>, the
second one is optional.  If the hints are missing the <code>autohint</code>
routine is called to supply an initial guess.
</p>
<p>The order component is a numeric vector with one element per subject in
the pedigree.  It determines the relative order of subjects within a sibship,
as well as the relative order of processing for the founder couples.
(For this latter, the female founders are ordered as though they were sisters).
The spouse component is a matrix with one row per hinted marriage,
usually only a few marriages in a pedigree will need an added hint, for
instance reverse the plot order of a husband/wife pair.
Each row contains the index of the left spouse, the right hand spouse,
and the anchor: 1=left, 2=right, 0=either.  Children will preferentially
appear under the parents of the anchored spouse.
</p>
</td></tr>
<tr><td><code id="align.pedigree_+3A_width">width</code></td>
<td>

<p>for a packed output, the minimum width
</p>
</td></tr>
<tr><td><code id="align.pedigree_+3A_align">align</code></td>
<td>

<p>for a packed pedigree, align children under parents (TRUE), to the
extent possible given the page width, or align to to the left margin (FALSE).
The latter is mostly used by internal routines.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p> This is an internal routine, used almost exclusively by
<code>plot.pedigree</code>.
The subservient functions <code>alignped1</code>, 
<code>alignped2</code>, 
<code>alignped3</code>, 
and <code>alignped4</code> contain the bulk of the computation.
</p>


<h3>Value</h3>

<p>a structure with components
</p>
<table>
<tr><td><code>n</code></td>
<td>
<p>a vector giving the number of subjects on each horizonal level
of the plot</p>
</td></tr>
<tr><td><code>nid</code></td>
<td>

<p>a matrix with one row for each level, giving the numeric id of each subject
plotted.  (An value of 17 means the 17th subject in the pedigree).
</p>
</td></tr>
<tr><td><code>pos</code></td>
<td>
<p>a matrix giving the horizontal position of each plot point</p>
</td></tr>
<tr><td><code>fam</code></td>
<td>

<p>a matrix giving the family id of each plot point.  A value of &quot;3&quot; would mean
that the two subjects in positions 3 and 4, in the row above, are this
subject's parents.</p>
</td></tr>
<tr><td><code>spouse</code></td>
<td>

<p>a matrix with values 1= subject plotted to the immediate right is a spouse,
2= subject plotted to the immediate right is an inbred spouse, 0 = not a 
spouse</p>
</td></tr>
<tr><td><code>twins</code></td>
<td>

<p>optional matrix which will only be present if the pedigree contains twins.
It has values 1= sibling to the right is a monozygotic twin, 2= sibling to
the right is a dizygotic twin, 3= sibling to the right is a twin of unknown
zygosity, 0 = not a twin</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+plot.pedigree">plot.pedigree</a></code>, <code><a href="#topic+autohint">autohint</a></code></p>

<hr>
<h2 id='as.data.frame.pedigree'>data.frame from a pedigree object</h2><span id='topic+as.data.frame.pedigree'></span>

<h3>Description</h3>

<p>Extract the internal data from a pedigree object into a data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pedigree'
as.data.frame(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.pedigree_+3A_x">x</code></td>
<td>
<p>pedigree object</p>
</td></tr>
<tr><td><code id="as.data.frame.pedigree_+3A_...">...</code></td>
<td>
<p>additional arguments passed to internal methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with the data necessary to re-create the pedigree,
minus special relationships.
#' @author Jason Sinnwell
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pedigree">pedigree</a></code>
</p>

<hr>
<h2 id='autohint'>
Align a pedigree to print well
</h2><span id='topic+autohint'></span>

<h3>Description</h3>

<p>A pedigree structure can contain a <code>hints</code> object
which helps to reorder the pedigree (e.g. left-to-right order of
children within family) so as to plot with minimal distortion.
This routine is used to create an initial version of the
hints.  They can then be modified if desired.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autohint(ped, hints, packed=TRUE, align=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autohint_+3A_ped">ped</code></td>
<td>
<p> a pedigree structure</p>
</td></tr>
<tr><td><code id="autohint_+3A_hints">hints</code></td>
<td>
<p> optional hints object. Only the order
component is used.
</p>
</td></tr>
<tr><td><code id="autohint_+3A_packed">packed</code></td>
<td>

<p>If TRUE, uniform distance between all individuals at a given level.
</p>
</td></tr>
<tr><td><code id="autohint_+3A_align">align</code></td>
<td>
<p> these parameters control the extra effort spent trying to
align children underneath parents, but without making the pedigree too
wide.  Set to FALSE to speed up plotting.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine would not normally be called by a user. 
It moves children within families, so that marriages are on the &quot;edge&quot;
of a set children, closest to the spouse.  
For pedigrees that have only a single connection between two families 
this simple-minded approach works surprisingly well.
For more complex structures hand-tuning of the hints matrix may be
required.
</p>
<p>The pedigree in the example below is one where rearranging the founders
greatly decreases the number of extra connections.
When autohint is called with a a vector of numbers as the second
argument, the values for the founder
females are used to order the founder families left to right across
the plot.  The values within a sibship are used as the preliminary
order of siblings within a family; this may be changed to move one
of them to the edge so as to match up with a spouse.
The actual values in the vector are not important, only their order.
</p>


<h3>Value</h3>

<p>a list containing components <code>order</code> and <code>spouse</code></p>


<h3>See Also</h3>

<p>pedigree, besthint
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(testped1)
ped1 &lt;- with(testped1, pedigree(id, father, mother, sex))
plot(ped1, cex=.7, symbolsize=.7)

# rearrange some founders
temp &lt;- 1:nrow(testped1)
temp[76] &lt;- .1
temp[77] &lt;- .2
temp[74] &lt;- .3
temp[60] &lt;- .4
temp[30] &lt;- temp[8] + .1
temp[65] &lt;- temp[4] + .1
temp[14] &lt;- temp[3] + .1
ped1$hints &lt;- autohint(ped1, temp)
plot(ped1, cex=.7)
</code></pre>

<hr>
<h2 id='bitSize'>
Calculate pedigree bitsize, defined as 2 * # NonFounders - # Founders
</h2><span id='topic+bitSize'></span>

<h3>Description</h3>

<p>This is a utility function used in pedigree.shrink()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bitSize(ped)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bitSize_+3A_ped">ped</code></td>
<td>

<p>A pedigree object
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components: 
</p>
<table>
<tr><td><code>bitSize</code></td>
<td>

<p>The bitSize of input pedigree
</p>
</td></tr>
<tr><td><code>nFounder</code></td>
<td>

<p>The number of founders in the pedigree
</p>
</td></tr>
<tr><td><code>nNonFounder</code></td>
<td>

<p>The number of nonfounders in the pedgiree
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+pedigree.shrink">pedigree.shrink</a></code>
</p>

<hr>
<h2 id='familycheck'>
Error check for a family classification
</h2><span id='topic+familycheck'></span>

<h3>Description</h3>

<p>Given a family id vector, also compute the familial grouping from
first principles using the parenting data, and compare the results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>familycheck(famid, id, father.id, mother.id, newfam)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="familycheck_+3A_famid">famid</code></td>
<td>

<p>a vector of family identifiers
</p>
</td></tr>
<tr><td><code id="familycheck_+3A_id">id</code></td>
<td>

<p>a vector of unique subject identifiers
</p>
</td></tr>
<tr><td><code id="familycheck_+3A_father.id">father.id</code></td>
<td>

<p>vector containing the id of the biological father
</p>
</td></tr>
<tr><td><code id="familycheck_+3A_mother.id">mother.id</code></td>
<td>

<p>vector containing the id of the biological mother
</p>
</td></tr>
<tr><td><code id="familycheck_+3A_newfam">newfam</code></td>
<td>

<p>the result of a call to <code>makefamid</code>.
If this has allready been computed by the user,
adding it as an argument shortens the running time somewhat.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>makefamid</code> function is used to create a
de novo family id from the parentage data, and this is compared to the
family id given in the data.
</p>


<h3>Value</h3>

<p>a data frame with one row for each unique family id in the
<code>famid</code> argument.
Components of the output are
</p>
<table>
<tr><td><code>famid</code></td>
<td>

<p>the family id, as entered into the data set
</p>
</td></tr>
<tr><td><code>n</code></td>
<td>

<p>number of subjects in the family
</p>
</td></tr>
<tr><td><code>unrelated</code></td>
<td>

<p>number of them that appear to be unrelated to anyone else 
in the entire pedigree set.  
This is usually marry-ins with no 
children (in the pedigree), and if so are not a problem.
</p>
</td></tr>
<tr><td><code>split</code></td>
<td>

<p>number of unique &quot;new&quot; family ids.
If this is 0, it means that no one in this &quot;family&quot; is related to
anyone else (not good); 
1 = everythings is fine;
2+= the family appears to be a set of disjoint trees.  Are you
missing some of the people?
</p>
</td></tr>
<tr><td><code>join</code></td>
<td>

<p>number of other families that had a unique famid, but are actually
joined to this one.  0 is the hope.
If there are any joins, then an attribute &quot;join&quot; is attached.  It will be
a matrix with famid as row labels, new-family-id as the columns, and
the number of subjects as entries.  
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+makefamid">makefamid</a></code>, <code><a href="#topic+makekinship">makekinship</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># use 2 sample peds
data(sample.ped)
pedAll &lt;- with(sample.ped, pedigree(id, father, mother, sex,
                    affected=cbind(affected, avail), famid=ped))

## check them giving separate ped ids
fcheck.sep &lt;- with(sample.ped, familycheck(ped, id, father, mother))
fcheck.sep

## check assigning them same ped id
fcheck.combined &lt;- with(sample.ped, familycheck(rep(1,nrow(sample.ped)), id, father, mother))
fcheck.combined

#make person 120's father be her son.
sample.ped[20,3] &lt;- 131
fcheck1.bad &lt;- try({with(sample.ped, familycheck(ped, id, father, mother))}, silent=FALSE)

## fcheck1.bad is a try-error
</code></pre>

<hr>
<h2 id='findAvailAffected'>
Find a single person to trim from a pedigree whose is available
</h2><span id='topic+findAvailAffected'></span>

<h3>Description</h3>

<p>Finds one subject from among available non-parents with indicated
affection status
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findAvailAffected(ped, avail, affstatus)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findAvailAffected_+3A_ped">ped</code></td>
<td>

<p>A pedigree objects, with id (subject ID),
findex (father index), mindex (mother index)
</p>
</td></tr>
<tr><td><code id="findAvailAffected_+3A_avail">avail</code></td>
<td>

<p>Vector of availability status (e.g., genotyped) 0/1 or TRUE/FALSE
</p>
</td></tr>
<tr><td><code id="findAvailAffected_+3A_affstatus">affstatus</code></td>
<td>

<p>Vector of affection status 0/1 or TRUE/FALSE.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When used within pedigree.shrink, this function is called with the
first affected indicator, if the affected item in the pedigree is a
matrix of multiple affected indicators.  
</p>


<h3>Value</h3>

<p>A list is returned with the following components
</p>
<table>
<tr><td><code>ped</code></td>
<td>

<p>Dataframe with trimmed subject removed
</p>
</td></tr>
<tr><td><code>idTrimmed</code></td>
<td>

<p>Vector of IDs of trimmed individuals
</p>
</td></tr>
<tr><td><code>isTrimmed</code></td>
<td>

<p>logical value indicating whether pedigree has been trimmed
</p>
</td></tr>
<tr><td><code>bitSize</code></td>
<td>

<p>Bit size of the trimmed pedigree
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+pedigree.shrink">pedigree.shrink</a></code>
</p>

<hr>
<h2 id='findAvailNonInform'>
Find subjects from a pedigree who are available and uninformative 
</h2><span id='topic+findAvailNonInform'></span>

<h3>Description</h3>

<p>Identify subjects to remove from a pedigree who are available but
non-informative.  This is the second step to remove subjects in
pedigree.shrink if the pedigree does not meet the desired bit size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findAvailNonInform(ped, avail)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findAvailNonInform_+3A_ped">ped</code></td>
<td>

<p>A pedigree object
</p>
</td></tr>
<tr><td><code id="findAvailNonInform_+3A_avail">avail</code></td>
<td>

<p>Vector of availability status (e.g. genotyped) 0/1 or TRUE/FALSE
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of subject ids who can be removed by having lowest informativeness.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pedigree.shrink">pedigree.shrink</a></code>
</p>

<hr>
<h2 id='findUnavailable'>
Find or trim unavailable subjects in a pedigree
</h2><span id='topic+findUnavailable'></span><span id='topic+pedigree.trim'></span><span id='topic+excludeUnavailFounders'></span><span id='topic+excludeStrayMarryin'></span>

<h3>Description</h3>

<p>Find the ID of subjects in a pedigree iteratively, as anyone who is
not available and does not have an available descendant by
successively removing unavailable terminal nodes. pedigree.trim
carries out the removal of the subjects identified by findUnavailable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findUnavailable(ped, avail)
pedigree.trim(removeID, ped)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findUnavailable_+3A_ped">ped</code></td>
<td>

<p>A pedigree object with an id, findex, mindex, sex, plus other optional items
</p>
</td></tr>
<tr><td><code id="findUnavailable_+3A_avail">avail</code></td>
<td>

<p>Logical vector of availability status (e.g., genotyped) 0/1 or TRUE/FALSE
</p>
</td></tr>
<tr><td><code id="findUnavailable_+3A_removeid">removeID</code></td>
<td>

<p>vector of subject ids of persons to trim from a pedigree
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Originally written as pedTrim by Steve Iturria, modified by Dan Schaid
2007, and now split into the two separate functions: <code>findUnavailable()</code>,
and <code>pedigree.trim()</code> to do the tasks separately.  <code>findUnavailable()</code>
calls <code>excludeStrayMarryin</code> to find stray
available marry-ins who are isolated after trimming their unavailable
offspring, and excludeUnavailFounders.
If the subject ids are character, make sure none of the characters
in the ids is a colon (&quot;:&quot;), which is a special character used to
concatenate and split subjects within the utlity.
</p>


<h3>Value</h3>

<p>findUnavailable returns a vector of subject ids for who can be
removed. pedigree.trim returns a trimmed pedigree object.  
</p>


<h3>Side Effects</h3>

<p>relation matrix from pedigree.trim is trimmed of any special relations
that include the subjects to trim.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pedigree.shrink">pedigree.shrink</a></code>,
</p>

<hr>
<h2 id='fixParents'>Fix details on the parents for children of the pedigree</h2><span id='topic+fixParents'></span>

<h3>Description</h3>

<p>Fix the sex of parents, add parents that are missing from the pedigree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixParents(id, dadid, momid, sex, missid = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixParents_+3A_id">id</code></td>
<td>
<p>Identification variable for individual</p>
</td></tr>
<tr><td><code id="fixParents_+3A_dadid">dadid</code></td>
<td>
<p>Identification variable for father. Founders parents should be coded 
to NA, or another value specified by missid.</p>
</td></tr>
<tr><td><code id="fixParents_+3A_momid">momid</code></td>
<td>
<p>Identification variable for mother. Founders parents should be coded
to NA, or another value specified by missid.</p>
</td></tr>
<tr><td><code id="fixParents_+3A_sex">sex</code></td>
<td>
<p>Gender of individual noted in 'id'. Either character (&quot;male&quot;,&quot;female&quot;,&quot;unknown&quot;,&quot;terminated&quot;)
or numeric (1=&quot;male&quot;, 2=&quot;female&quot;, 3=&quot;unknown&quot;, 4=&quot;terminated&quot;)
data is allowed.  For character data the string may be truncated,
and of arbitrary case.</p>
</td></tr>
<tr><td><code id="fixParents_+3A_missid">missid</code></td>
<td>
<p>The founders are those with no father or mother in the pedigree.  The
<code>dadid</code> and <code>momid</code> values for these subjects will either be
NA or the value of this variable.  The default for <code>missid</code> is 0
if the <code>id</code> variable is numeric, and &quot;&quot; (the empty string)
otherwise.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First look to add parents whose ids are given in momid/dadid. Second,
fix sex of parents. Last look to add second parent for children for whom
only one parent id is given.
</p>


<h3>Value</h3>

<p>A data.frame with id, dadid, momid, sex as columns
</p>


<h3>Author(s)</h3>

<p>Jason Sinnwell
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pedigree">pedigree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test1char &lt;- data.frame(id=paste("fam", 101:111, sep=""),
  sex=c("male","female")[c(1,2,1,2,1, 1,2, 2,1,2, 1)],
  father=c(0,0,"fam101","fam101","fam101", 0,0,"fam106","fam106","fam106", "fam109"),
  mother=c(0,0,"fam102","fam102","fam102", 0,0,"fam107","fam107","fam107", "fam112"))
test1newmom &lt;- with(test1char, fixParents(id, father, mother, sex, missid="0"))
newped &lt;- with(test1newmom, pedigree(id, dadid, momid, sex, missid="0"))
as.data.frame(newped)

</code></pre>

<hr>
<h2 id='ibdMatrix'>Create an IBD matrix</h2><span id='topic+ibdMatrix'></span>

<h3>Description</h3>

<p>Transform identity by descent (IBD) matrix data from the form produced
by external programs such as SOLAR
into the compact form used by the coxme and lmekin routines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ibdMatrix(id1, id2, x, idmap, diagonal)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ibdMatrix_+3A_id1">id1</code>, <code id="ibdMatrix_+3A_id2">id2</code></td>
<td>
<p>pairs of subject identifiers</p>
</td></tr>
<tr><td><code id="ibdMatrix_+3A_x">x</code></td>
<td>
<p>the IBD value for that pair</p>
</td></tr>
<tr><td><code id="ibdMatrix_+3A_idmap">idmap</code></td>
<td>
<p>an optional 2 column matrix or data frame whose first
element is the internal value (as found in <code>id1</code> and
<code>id2</code>), and whose second element will be used for the dimnames
of the result</p>
</td></tr>
<tr><td><code id="ibdMatrix_+3A_diagonal">diagonal</code></td>
<td>
<p>optional value for the diagonal element. If present,
any missing diagonal elements in the input data will be set to this
value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The IBD matrix for a set of n subjects will be an n by n symmetric
matrix whose i,j element is the contains, for some given genetic
location, a 0/1 indicator of whether 0, 1/2 or 2/2 of the alleles for i
and j are identical by descent.  Fractional values occur if the IBD
fraction must be imputed.  The diagonal will be 1.
Since a large fraction of the values will be zero, programs such as
Solar return a data set containing only the non-zero elements.  As
well, Solar will have renumbered the subjects as 1:n in such a way that
families are grouped together in the matrix; a separate index file
contains the mapping between this new id and the original one.
The final matrix should be labeled with the original identifiers.
</p>


<h3>Value</h3>

<p>a sparse matrix of class <code>dsCMatrix</code>.  This is the same form
used for kinship matrices.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kinship">kinship</a></code>,
<code><a href="Matrix.html#topic+Matrix">Matrix</a></code>
</p>

<hr>
<h2 id='kindepth'>Compute the depth of each subject in a pedigree</h2><span id='topic+kindepth'></span>

<h3>Description</h3>

<p>Mark each person as to their depth in a pedigree;
0 for a founder, otherwise depth = 1 + max(father's depth, mother's
depth)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kindepth(id, dad.id, mom.id, align = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kindepth_+3A_id">id</code></td>
<td>
<p>Identification code for each individual</p>
</td></tr>
<tr><td><code id="kindepth_+3A_dad.id">dad.id</code></td>
<td>
<p>Id code for the father</p>
</td></tr>
<tr><td><code id="kindepth_+3A_mom.id">mom.id</code></td>
<td>
<p>Id code for the mother</p>
</td></tr>
<tr><td><code id="kindepth_+3A_align">align</code></td>
<td>
<p>If align=T, go one step further and try to make both
parents of each child have the same depth.
(This is not always possible).  It helps
the drawing program by lining up pedigrees that &quot;join in the middle&quot;
via a marriage.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the case of an inbred pedigree a perfect alignment obeying
<code>extra=TRUE</code> may not exist.</p>


<h3>Value</h3>

<p>an integer vector containing the depth for each subject</p>


<h3>Author(s)</h3>

<p>Terry Therneau</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.pedigree">plot.pedigree</a></code></p>

<hr>
<h2 id='kinship'>
Compute a kinship matrix
</h2><span id='topic+kinship'></span><span id='topic+kinship.default'></span><span id='topic+kinship.pedigree'></span><span id='topic+kinship.pedigreeList'></span>

<h3>Description</h3>

<p>Compute the kinship matrix for a set of related autosomal subjects.
The function is generic, and can accept a pedigree, pedigreeList,
or vector as the first argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kinship(id, ...)
## S3 method for class 'pedigree'
kinship(id, chrtype="autosome", ...)
## S3 method for class 'pedigreeList'
kinship(id, chrtype="autosome", ...)
## Default S3 method:
kinship(id, dadid, momid, sex, chrtype="autosome", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kinship_+3A_id">id</code></td>
<td>

<p>either a pedigree object, pedigreeList object, or a vector of
subject identifiers.  Subject identifiers may be numeric or
character.  
</p>
</td></tr>
<tr><td><code id="kinship_+3A_dadid">dadid</code></td>
<td>

<p>for each subject, the identifier of the biological father.
This is only used if <code>id</code> is a vector.
</p>
</td></tr>
<tr><td><code id="kinship_+3A_momid">momid</code></td>
<td>

<p>for each subject, the identifier of the biological mother.
This is only used if <code>id</code> is a vector.
</p>
</td></tr>
<tr><td><code id="kinship_+3A_sex">sex</code></td>
<td>
<p>vector of sex values coded as 1=male, 2=female</p>
</td></tr>
<tr><td><code id="kinship_+3A_chrtype">chrtype</code></td>
<td>
<p>chromosome type.  The currently supported types
are &quot;autosome&quot; and &quot;X&quot; or &quot;x&quot;.  </p>
</td></tr>
<tr><td><code id="kinship_+3A_...">...</code></td>
<td>
<p>Any number of optional arguments</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The function will usually be called with a pedigree or pedigreeList;
the third form is provided for backwards compatability with an earlier
release of the library that was less capable.
The first argument is named <code>id</code>
for the same reason.  Note that when using the third form any
information on twins is not available to the function.
</p>
<p>When called with a pedigreeList, i.e., with multiple families, the
routine will create a block-diagonal-symmetric sparse matrix object
of class <code>dsCMatrix</code>.
Since the [i,j] value of the result is 0 for any two
unrelated individuals i and j and a <code>Matrix</code> utilizes sparse
representation, the resulting object is often orders of magnitude
smaller than an ordinary matrix.
When <code>kinship</code> is called with a single pedigree
an ordinary matrix is returned.
</p>
<p>Two genes G1 and G2 are identical by descent (IBD) if they are both physical
copies of the same ancestral gene; two genes are identical by state if
they represent the same allele.  
So the brown eye gene that I inherited from my mother is IBD with hers;
the same gene in an unrelated individual is not.
</p>
<p>The kinship coefficient between two subjects is the probability that a
randomly selected allele from a locus will be IBD between them.
It is obviously 0 between unrelated individuals.
For an autosomal site and no inbreeding
it will be 0.5 for an individual
with themselves, .25 between mother and child, .125 between an uncle and
neice, etc.
</p>
<p>The computation is based on a recursive algorithm described in Lange,
which assumes that the founder alleles are all independent.
</p>


<h3>Value</h3>

<p>a matrix of kinship coefficients.
</p>


<h3>References</h3>

<p>K Lange, Mathematical and Statistical Methods for Genetic Analysis,
Springer-Verlag, New York, 1997.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pedigree">pedigree</a></code>, <code><a href="#topic+makekinship">makekinship</a></code>,<code><a href="#topic+makefamid">makefamid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test1 &lt;- data.frame(id  =c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14),
                    mom =c(0, 0, 0, 0, 2, 2, 4, 4, 6,  2,  0,  0, 12, 13),
                    dad =c(0, 0, 0, 0, 1, 1, 3, 3, 3,  7,  0,  0, 11, 10),
                    sex =c(0, 1, 0, 1, 0, 1, 0, 1, 0,  0,  0,  1,  1,  1))
tped &lt;- with(test1, pedigree(id, dad, mom, sex))
round(8*kinship(tped))

</code></pre>

<hr>
<h2 id='kinship2'>The kinship2 package for pedigree data</h2><span id='topic+kinship2'></span>

<h3>Description</h3>

<p>The kinship2 package for pedigree data
</p>


<h3>Details</h3>

<p>The package download, NEWS, and README are available on CRAN: <a href="https://cran.r-project.org/package=kinship2">https://cran.r-project.org/package=kinship2</a>
</p>


<h3>Functions</h3>

<p>Below are listed some of the most widely used functions available in <code>arsenal</code>:
</p>
<p><code><a href="#topic+pedigree">pedigree</a></code>: Contstructor of the pedigree class, given identifiers, sex, affection status(es), and special relationships
</p>
<p><code><a href="#topic+kinship">kinship</a></code>: Calculates the kinship matrix, the probability having an allele sampled from two individuals be the same via IBD.
</p>
<p><code><a href="#topic+plot.pedigree">plot.pedigree</a></code>: Plot method for a pedigree object. Allows extra information to be included in the id under the plot symbol
</p>
<p><code><a href="#topic+legendPlot">legendPlot</a></code>:  Special version of plot.pedigree, with an informative legend along the bottom of the figure
</p>
<p><code><a href="#topic+pedigree.shrink">pedigree.shrink</a></code>: Shrink a pedigree to a specific bit size, removing non-informative members first.
</p>
<p><code><a href="#topic+bitSize">bitSize</a></code>: Approximate the output from SAS's <code>PROC FREQ</code> procedure when using
the <code>/list</code> option of the <code>TABLE</code> statement.
</p>


<h3>Data</h3>

<p><code><a href="#topic+sample.ped">sample.ped</a></code>: Pedigree example data sets with two pedigrees
</p>
<p><code><a href="#topic+minnbreast">minnbreast</a></code>: Larger cohort of pedigrees from MN breast cancer study
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(kinship2)

</code></pre>

<hr>
<h2 id='legendPlot'>Legend Pedigree Plot</h2><span id='topic+legendPlot'></span>

<h3>Description</h3>

<p>Pedigree plot with ready-made legend along the bottom of the page to represent colors 
and affection statuses
</p>


<h3>Usage</h3>

<pre><code class='language-R'>legendPlot(
  x,
  id = x$id,
  affected = x$affected,
  affected.label = NULL,
  col = 1,
  col.label = NULL,
  symbolsize = 0.75,
  cex = 0.5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="legendPlot_+3A_x">x</code></td>
<td>
<p>Pedigree data frame with ped (pedigree id), id (id of individual),
father (id of father), mother (id of mother), sex, affected (affection status), 
and avail (DNA availability).</p>
</td></tr>
<tr><td><code id="legendPlot_+3A_id">id</code></td>
<td>
<p>Optional, a character string to replace the correspinding id for persons in the pedigree</p>
</td></tr>
<tr><td><code id="legendPlot_+3A_affected">affected</code></td>
<td>
<p>A variable indicating affection status. A multi-column matrix can be used to
give the status with respect to multiple traits. Logical, factor, and integer types
are converted to 0/1 representing unaffected and affected, respectively. NAs are
considered missing.</p>
</td></tr>
<tr><td><code id="legendPlot_+3A_affected.label">affected.label</code></td>
<td>
<p>Set labels for affection statuses</p>
</td></tr>
<tr><td><code id="legendPlot_+3A_col">col</code></td>
<td>
<p>Colors for the plot symbol for each individual</p>
</td></tr>
<tr><td><code id="legendPlot_+3A_col.label">col.label</code></td>
<td>
<p>Named vector, with elements matching the unique color codes, the names are the labels used in the legend.</p>
</td></tr>
<tr><td><code id="legendPlot_+3A_symbolsize">symbolsize</code></td>
<td>
<p>Size of symbols (circle/square/triangle). Default is 1.0</p>
</td></tr>
<tr><td><code id="legendPlot_+3A_cex">cex</code></td>
<td>
<p>Character expansion size for labels and ids. Default is 1.0</p>
</td></tr>
<tr><td><code id="legendPlot_+3A_...">...</code></td>
<td>
<p>Character expansion size for labels and ids. Default is 1.0</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jason Sinnwell, code contributed by Sara Achenbach
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pedigree">pedigree</a></code>, <code><a href="#topic+plot.pedigree">plot.pedigree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(sample.ped)
pedAll &lt;- pedigree(sample.ped$id, sample.ped$father,
   sample.ped$mother, sample.ped$sex,
   affected=cbind(sample.ped$affected, sample.ped$avail),
   famid=sample.ped$ped)
ped1 &lt;- pedAll["1"]
legendPlot(ped1,  affected.label=c("cancer","available"))

## End(Not run)
</code></pre>

<hr>
<h2 id='makefamid'>Construct a family id from pedigree information</h2><span id='topic+makefamid'></span>

<h3>Description</h3>

<p>Create a vector of length n, giving the family &quot;tree&quot; number of
each subject.  If the pedigree is totally connected, then everyone will
end up in tree 1, otherwise the tree numbers represent the disconnected
subfamilies.  Singleton subjects give a zero for family number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makefamid(id, father.id, mother.id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makefamid_+3A_id">id</code></td>
<td>
<p>Identifier for each subject in the set of pedigrees</p>
</td></tr>
<tr><td><code id="makefamid_+3A_father.id">father.id</code></td>
<td>

<p>Identifier for the father.  This will be 0 or &quot;&quot; for a founder.
</p>
</td></tr>
<tr><td><code id="makefamid_+3A_mother.id">mother.id</code></td>
<td>
<p>Identifer for the mother.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command is depricated.  The kinship command now can be applied
directly to pedigreeList objects.
</p>


<h3>Value</h3>

<p>An integer vector giving family groupings</p>


<h3>Author(s)</h3>

<p>Terry Therneau</p>


<h3>See Also</h3>

<p><code><a href="#topic+makekinship">makekinship</a></code></p>

<hr>
<h2 id='makekinship'>
Create a sparse kinship matrix
</h2><span id='topic+makekinship'></span>

<h3>Description</h3>

<p>Compute the overall kinship matrix for a collection of families, and
store it efficiently.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makekinship(famid, id, father.id, mother.id, unrelated=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makekinship_+3A_famid">famid</code></td>
<td>

<p>a vector of family identifiers
</p>
</td></tr>
<tr><td><code id="makekinship_+3A_id">id</code></td>
<td>

<p>a vector of unique subject identifiers
</p>
</td></tr>
<tr><td><code id="makekinship_+3A_father.id">father.id</code></td>
<td>

<p>for each subject, the identifier of their biolgical father
</p>
</td></tr>
<tr><td><code id="makekinship_+3A_mother.id">mother.id</code></td>
<td>

<p>for each subject, the identifier of thier biological mother
</p>
</td></tr>
<tr><td><code id="makekinship_+3A_unrelated">unrelated</code></td>
<td>

<p>subjects with this family id are considered to be unrelated singletons,
i.e., not related to each other or to anyone else.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command is depricated.  The kinship command now can be applied
directly to pedigreeList objects.
</p>


<h3>Value</h3>

<p>a sparse kinship matrix of class <code>bdsmatrix</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kinship">kinship</a></code>, <code><a href="#topic+makefamid">makefamid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Data set from a large family study of breast cancer
#  there are 26050 subjects in the file, from 426 families
## Not run: 
&gt; table(cdata$sex)
     F     M 
 12699 13351
&gt; length(unique(cdata$famid))
[1] 426

&gt; kin1 &lt;- makekinship(cdata$famid, cdata$gid, cdata$dadid, cdata$momid)
&gt; dim(kin1)
[1] 26050 26050
&gt; class(kin1)
[1] "bdsmatrix"
# The next line shows that few of the elements of the full matrix are &gt;0
&gt; length(kin1@blocks)/ prod(dim(kin1))
[1] 0.00164925

# kinship matrix for the females only
&gt; femid &lt;- cdata$gid[cdata$sex=='F']
&gt; femindex &lt;- !is.na(match(dimnames(kin1)[[1]], femid))
&gt; kin2 &lt;- kin1[femindex, femindex]
#
# Note that "femindex &lt;- match(femid, dimnames(kin1)[[1]])" is wrong, since
#  then kin1[femindex, femindex] might improperly reorder the rows/cols 
#  (if families were not contiguous in cdata).  
# However sort(match(femid, dimnames(kin1)[[1]])) would be okay.

## End(Not run)</code></pre>

<hr>
<h2 id='minnbreast'>Minnesota Breast Cancer Study</h2><span id='topic+minnbreast'></span><span id='topic+minnbreast2'></span>

<h3>Description</h3>

<p>Data from the Minnesota Breast Cancer Family Study.  This contains
extended pedigrees from 426 families, each identified by a single
proband in  1945-52, with follow up for incident breast cancer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(minnbreast)</code></pre>


<h3>Format</h3>

<p>minnbreast: A data frame with 28081 observations, one line per subject,
on the following 14 variables. 
</p>

<dl>
<dt><code>id</code></dt><dd><p>subject identifier</p>
</dd>
<dt><code>proband</code></dt><dd><p>if 1, this subject is one of the original 426 probands</p>
</dd>
<dt><code>fatherid</code></dt><dd><p>identifier of the father, if the father is
part of the data set; zero otherwise</p>
</dd>
<dt><code>motherid</code></dt><dd><p>identifier of the mother, if the mother is
part of the data set; zero otherwise</p>
</dd>
<dt><code>famid</code></dt><dd><p>family identifier</p>
</dd>
<dt><code>endage</code></dt><dd><p>age at last follow-up or incident cancer</p>
</dd>
<dt><code>cancer</code></dt><dd><p>1= breast cancer (females) or prostate cancer
(males), 0=censored</p>
</dd>
<dt><code>yob</code></dt><dd><p>year of birth</p>
</dd>
<dt><code>education</code></dt><dd><p>amount of education: 1-8 years,
9-12 years, high school graduate,  vocational education beyond high
school, some college but did not graduate,  college graduate,
post-graduate education, refused to answer on the questionairre</p>
</dd>
<dt><code>marstat</code></dt><dd><p>marital status: married, living with someone
in a marriage-like relationship, separated or divorced,  widowed,
never married, refused to answer the questionaiire</p>
</dd>
<dt><code>everpreg</code></dt><dd><p>ever pregnant: never pregnant at the time of
baseline survey, ever pregnant at the time of baseline survey</p>
</dd>
<dt><code>parity</code></dt><dd><p>number of births</p>
</dd>
<dt><code>nbreast</code></dt><dd><p>number of breast biopsies</p>
</dd>
<dt>sex</dt><dd><p>M or F</p>
</dd>
<dt>bcpc</dt><dd><p>part of one of the families in the breast/prostate
cancer substudy: 0=no, 1=yes.  Note that subjects who were recruited
to the overall study after the date of the BP substudy are coded as zero.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The original study was conducted by Dr. Elving Anderson at the Dight
Institute for Human Genetics at the University of Minnesota.  From 1944
to 1952, 544 sequential breast cancer cases seen at the University
Hospital were enrolled, and information gathered on parents, siblings,
offspring, aunts/uncles, and grandparents with the goal of
understanding possible familial aspects of brest cancer.  In 1991 the
study was resurrected by Dr. Tom Sellers.  Of the original 544 he
excluded 58 prevalent cases, along with another 19 who had less than 2
living relatives at the time of Dr Anderson's survey.  Of the
remaining 462 families 10 had no living members, 23 could not be
located and 8 refused, leaving 426 families on whom updated pedigrees
were obtained.  This gave a study with 13351 males and 12699 females
(5183 marry-ins).  Primary questions were the relationship of early
life exposures, breast density, and pharmacogenomics on incident
breast cancer risk.
</p>
<p>For a subset of the families data was gathered on prostate cancer risk
for male subjects via questionairres sent to men over 40.  Other than
this, data items other than parentage are limited to the female subjects.
</p>
<p>In ___ a second phase of the study was instituted.  The pedigrees were
further extended to the numbers found in this data set, and further
data gathered by questionairre.
</p>


<h3>Source</h3>

<p>Authors of the study</p>


<h3>References</h3>

<p>Epidemiologic and genetic follow-up study of 544 Minnesota breast
cancer families: design and methods.  Sellers TA, Anderson VE, Potter
JD, Bartow SA, Chen PL, Everson L, King RA, Kuni CC, Kushi LH,
McGovern PG, et al.  Genetic Epidemiology, 1995; 12(4):417-29.
</p>
<p>Evaluation of familial clustering of breast and prostate cancer in the
Minnesota Breast Cancer Family Study.
Grabrick DM, Cerhan JR, Vierkant RA, Therneau TM, Cheville JC, Tindall
DJ, Sellers TA. Cancer Detect Prev. 2003; 27(1):30-6.
</p>
<p>Risk of breast cancer with oral contraceptive use in women with a
family history of breast cancer.  Grabrick DM, Hartmann LC, Cerhan JR,
Vierkant RA, Therneau TM, Vachon CM, Olson JE, Couch FJ, Anderson KE,
Pankratz VS, Sellers TA.  JAMA. 2000; 284(14):1791-8.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(minnbreast)
breastped &lt;- with(minnbreast, pedigree(id, fatherid, motherid, sex,
                  status=(cancer&amp; !is.na(cancer)), affected=proband,
                   famid=famid))
print(breastped["8"])
print(breastped[8])
#plot(breastped["8"])  #plot family 8, proband is solid, slash for cancers
#Note that breastped[8] is a different family, since ids are not 1,2,3,...
</code></pre>

<hr>
<h2 id='pedigree'>Create a pedigree or pedigreeList object</h2><span id='topic+pedigree'></span><span id='topic++5B.pedigreeList'></span><span id='topic++5B.pedigree'></span><span id='topic+print.pedigree'></span><span id='topic+print.pedigreeList'></span>

<h3>Description</h3>

<p>Create a pedigree or pedigreeList object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pedigree(id, dadid, momid, sex, affected, status, relation, famid, missid)

## S3 method for class 'pedigreeList'
x[..., drop = FALSE]

## S3 method for class 'pedigree'
x[..., drop = FALSE]

## S3 method for class 'pedigree'
print(x, ...)

## S3 method for class 'pedigreeList'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pedigree_+3A_id">id</code></td>
<td>
<p>Identification variable for individual</p>
</td></tr>
<tr><td><code id="pedigree_+3A_dadid">dadid</code></td>
<td>
<p>Identification variable for father. Founders' parents should be coded
to NA, or another value specified by missid.</p>
</td></tr>
<tr><td><code id="pedigree_+3A_momid">momid</code></td>
<td>
<p>Identification variable for mother. Founders' parents should be coded
to NA, or another value specified by missid.</p>
</td></tr>
<tr><td><code id="pedigree_+3A_sex">sex</code></td>
<td>
<p>Gender of individual noted in &lsquo;id&rsquo;. Either character (&quot;male&quot;,&quot;female&quot;,
&quot;unknown&quot;,&quot;terminated&quot;) or numeric (1=&quot;male&quot;, 2=&quot;female&quot;, 3=&quot;unknown&quot;, 4=&quot;terminated&quot;)
data is allowed.  For character data the string may be truncated, and of arbitrary case.</p>
</td></tr>
<tr><td><code id="pedigree_+3A_affected">affected</code></td>
<td>
<p>A variable indicating affection status.  A multi-column matrix
can be used to give the status with respect to multiple traits. Logical, factor, and 
integer types are converted to 0/1 representing unaffected and affected, respectively. 
NAs are considered missing.</p>
</td></tr>
<tr><td><code id="pedigree_+3A_status">status</code></td>
<td>
<p>Censor/Vital status (0=&quot;censored&quot;, 1=&quot;dead&quot;)</p>
</td></tr>
<tr><td><code id="pedigree_+3A_relation">relation</code></td>
<td>
<p>A matrix with 3 required columns (id1, id2, code) specifying special 
relationship between pairs of individuals. Codes: 1=Monozygotic twin,  2=Dizygotic twin, 
3=Twin of unknown zygosity, 4=Spouse. (The last is necessary in order to place a marriage 
with no children into the plot.) If famid is given in the call to create pedigrees, then
famid needs to be in the last column of the relation matrix. Note for tuples of &gt;= 3 with 
a mixture of zygosities, the plotting is limited to showing pairwise zygosity of adjacent 
subjects, so it is only necessary to specify the pairwise zygosity, in the order the subjects 
are given or appear on the plot.</p>
</td></tr>
<tr><td><code id="pedigree_+3A_famid">famid</code></td>
<td>
<p>An optional vector of family identifiers.  If it is present the result will 
contain individual pedigrees for each family in the set, which can be extacted using 
subscripts. Individuals need to have a unique id <em>within</em> family.</p>
</td></tr>
<tr><td><code id="pedigree_+3A_missid">missid</code></td>
<td>
<p>The founders are those with no father or mother in the pedigree. The dadid
and momid values for these subjects will either be NA or the value of this variable. The 
default for missid is 0 if the id variable is numeric, and &quot;&quot; (empty string) otherwise.</p>
</td></tr>
<tr><td><code id="pedigree_+3A_x">x</code></td>
<td>
<p>pedigree object in print and subset methods</p>
</td></tr>
<tr><td><code id="pedigree_+3A_...">...</code></td>
<td>
<p>optional arguments passed to internal functions</p>
</td></tr>
<tr><td><code id="pedigree_+3A_drop">drop</code></td>
<td>
<p>logical, used in subset function for dropping dimensionanlity</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>pedigree</code> or <code>pedigreeList</code> Containing the following items:
famid id findex mindex sex  affected status relation
@examples
data(minnbreast)
bpeds &lt;- with(minnbreast,
pedigree(id, fatherid, motherid, sex, affected=proband, famid=famid))
bped.id8 &lt;- bpeds['8']
print(bped.id8)
## show this pedigree with mixed zygosity quadruplets
rel8 &lt;- data.frame(id1=c(137,138,139), id2=c(138,139,140), code=c(1,2,2))
bped.id8 &lt;- with(minnbreast[minnbreast$famid==8,],
pedigree(id, fatherid, motherid, sex, affected=proband, relation=rel8))
print(bped.id8)
</p>


<h3>Author(s)</h3>

<p>Terry Therneau
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kinship">kinship</a></code>, <code><a href="#topic+plot.pedigree">plot.pedigree</a></code>, <code><a href="#topic+autohint">autohint</a></code>
</p>

<hr>
<h2 id='pedigree.legend'>plot a legend for a pedigree</h2><span id='topic+pedigree.legend'></span>

<h3>Description</h3>

<p>circular legend for a pedigree as a key to the affection statuses
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pedigree.legend(
  ped,
  labels = dimnames(ped$affected)[[2]],
  edges = 200,
  radius = NULL,
  location = "bottomright",
  new = TRUE,
  density = c(-1, 35, 65, 20),
  angle = c(90, 65, 40, 0),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pedigree.legend_+3A_ped">ped</code></td>
<td>
<p>Pedigree data frame with ped (pedigree id), id (id of individual),
father (id of father), mother (id of mother), sex, affected (affection status), 
and avail (DNA availability).</p>
</td></tr>
<tr><td><code id="pedigree.legend_+3A_labels">labels</code></td>
<td>
<p>names for the affected indicators</p>
</td></tr>
<tr><td><code id="pedigree.legend_+3A_edges">edges</code></td>
<td>
<p>Number of edges for each polygon. Higher numbers give better
resolution for the circle</p>
</td></tr>
<tr><td><code id="pedigree.legend_+3A_radius">radius</code></td>
<td>
<p>radius (inches) of the circle</p>
</td></tr>
<tr><td><code id="pedigree.legend_+3A_location">location</code></td>
<td>
<p>similar to how the location of a base-R legend is given,
used only if new=TRUE.  A character string indicating which of the four corners
to plot the legend, given by &quot;bottomright&quot;, &quot;bottomleft&quot;, &quot;topleft&quot;, or &quot;topright&quot;.</p>
</td></tr>
<tr><td><code id="pedigree.legend_+3A_new">new</code></td>
<td>
<p>Logical. If TRUE, plot the legend on the current plot. Otherwise, plot
on a separate plot.</p>
</td></tr>
<tr><td><code id="pedigree.legend_+3A_density">density</code></td>
<td>
<p>Density of lines shaded in sections of the circle. These match the
density settings for the plot.pedigree function.</p>
</td></tr>
<tr><td><code id="pedigree.legend_+3A_angle">angle</code></td>
<td>
<p>The angle at which lines are shaded in sections of the circle. These
match the angles for the plot.pedigree function.</p>
</td></tr>
<tr><td><code id="pedigree.legend_+3A_...">...</code></td>
<td>
<p>optional parameters for the plot function that apply to text</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jason Sinnwell
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pedigree">pedigree</a></code>, <code><a href="#topic+plot.pedigree">plot.pedigree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(sample.ped)
fam1 &lt;- sample.ped[sample.ped$ped==1,]
ped1 &lt;- with(fam1, pedigree(id, father, mother, sex,
             affected=cbind(avail,affected)))
plot(ped1)
pedigree.legend(ped1, location="bottomright", radius=.8)
pedigree.legend(ped1, location="topleft", radius=.6, cex=1.2)
pedigree.legend(ped1, new=FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='pedigree.shrink'>Shrink pedigree object</h2><span id='topic+pedigree.shrink'></span><span id='topic+print.pedigree.shrink'></span>

<h3>Description</h3>

<p>Shrink pedigree object to specified bit size with priority placed on trimming
uninformative subjects. The algorithm is useful for getting a pedigree condensed to 
a minimally informative size for algorithms or testing that are limited by size 
of the pedigree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pedigree.shrink(ped, avail, affected = NULL, maxBits = 16)

## S3 method for class 'pedigree.shrink'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pedigree.shrink_+3A_ped">ped</code></td>
<td>
<p>Pedigree object created by the pedigree function,</p>
</td></tr>
<tr><td><code id="pedigree.shrink_+3A_avail">avail</code></td>
<td>
<p>vector of binary availability status (0/1), i.e. having data, or sample available</p>
</td></tr>
<tr><td><code id="pedigree.shrink_+3A_affected">affected</code></td>
<td>
<p>vector of binary affected status (0/1/NA). If NULL, uses first column of the pedigree object affected matrix.</p>
</td></tr>
<tr><td><code id="pedigree.shrink_+3A_maxbits">maxBits</code></td>
<td>
<p>Optional, the bit size for which to shrink the pedigree</p>
</td></tr>
<tr><td><code id="pedigree.shrink_+3A_x">x</code></td>
<td>
<p>pedigree.shrink object used in method functions</p>
</td></tr>
<tr><td><code id="pedigree.shrink_+3A_...">...</code></td>
<td>
<p>optional arguments passed to internal functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Iteratively remove subjects from the pedigree. The random removal of members
was previously controlled by a seed argument, but we remove this, forcing users
to control randomness outside the function. First remove uninformative 
subjects, i.e., unavailable (not genotyped) with no available descendants.  
Next, available terminal subjects with unknown phenotype if both parents 
available. Last, iteratively shrinks pedigrees by preferentially removing 
individuals (chosen at random if there are multiple of the same status): 
1. Subjects with unknown affected status, 
2. Subjects with unaffected affected status
3. Affected subjects.
</p>


<h3>Author(s)</h3>

<p>Original by Dan Schaid, updated to kinship2 by Jason Sinnwell
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pedigree">pedigree</a></code>, <code><a href="#topic+plot.pedigree.shrink">plot.pedigree.shrink</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sample.ped)
pedAll &lt;- pedigree(sample.ped$id, sample.ped$father, sample.ped$mother,
  sample.ped$sex, affected=cbind(sample.ped$affected, sample.ped$avail),
  famid=sample.ped$ped)
ped1 &lt;- pedAll['1']
pedigree.shrink(ped1, maxBits=12, avail=ped1$affected[,2])

</code></pre>

<hr>
<h2 id='pedigree.unrelated'>Determine set of maximum number of unrelated available subjects
from a pedigree
</h2><span id='topic+pedigree.unrelated'></span>

<h3>Description</h3>

<p>Determine set of maximum number of unrelated available subjects
from a pedigree, given vectors id, father, and mother for a pedigree structure,
and status vector of T/F for whether each subject is available (e.g. has DNA)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pedigree.unrelated(ped, avail)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pedigree.unrelated_+3A_ped">ped</code></td>
<td>

<p>A pedigree objects with unique id, father index, mother index
</p>
</td></tr>
<tr><td><code id="pedigree.unrelated_+3A_avail">avail</code></td>
<td>

<p>Vector of availability status (e.g., genotyped) 0/1 or TRUE/FALSE
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a greedy algorithm that uses the kinship matrix, sequentially
removing rows/cols that are non-zero for subjects that have the most
number of zero kinship coefficients (greedy by choosing a row of
kinship matrix that has the most number of zeros, and then remove any
cols and their corresponding rows that are non-zero. To account for
ties of the count of zeros for rows, a random choice is made. Hence,
running this function multiple times can return different sets of
unrelated subjects.
</p>


<h3>Value</h3>

<p>A vector of the ids of subjects that are unrelated.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kinship">kinship</a></code>,
<code><a href="#topic+pedigree">pedigree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sample.ped)
fam1 &lt;- sample.ped[sample.ped$ped==1,]


ped1 &lt;- pedigree(fam1$id, fam1$father, fam1$mother,
                 fam1$sex, fam1$affected, fam1$avail)

## to see plot:
## plot.pedigree(ped1, align=FALSE)
id1 &lt;- pedigree.unrelated(ped1, avail=fam1$avail)

id1
## some possible vectors
##[1] "110" "113" "133" "109"
##[1] "113" "118" "141" "109" 
##[1] "113" "118" "140" "109" 
##[1] "110" "113" "116" "109" 
##[1] "113" "133" "141" "109" 

 
fam2 &lt;- sample.ped[sample.ped$ped==2,]

ped2 &lt;- pedigree(fam2$id, fam2$father, fam2$mother,
               fam2$sex, fam2$affected, fam2$avail)

## to see plot:
## plot.pedigree(ped2, align=FALSE)

id2 &lt;- pedigree.unrelated(ped2, avail=fam2$avail)

## some possible vectors
##[1] "203" "207"
##[1] "203" "204"
##[1] "201" "203"
##[1] "214" "203"
id2

</code></pre>

<hr>
<h2 id='plot.pedigree'>
plot pedigrees
</h2><span id='topic+plot.pedigree'></span>

<h3>Description</h3>

<p>plot objects created with the pedigree function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pedigree'
plot(x, id = x$id, status = x$status, 
                        affected = x$affected, 
                        cex = 1, col = 1,
                        symbolsize = 1, branch = 0.6, 
                        packed = TRUE, align = c(1.5,2), width = 8, 
                        density=c(-1, 35,65,20), #mar=c(3.1, 1, 3.1, 1),
                        angle=c(90,65,40,0), keep.par=FALSE,
                        subregion, pconnect=.5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.pedigree_+3A_x">x</code></td>
<td>

<p>object created by the function pedigree.
</p>
</td></tr>
<tr><td><code id="plot.pedigree_+3A_id">id</code></td>
<td>

<p>id variable - used for labeling.  
</p>
</td></tr>
<tr><td><code id="plot.pedigree_+3A_status">status</code></td>
<td>

<p>can be missing.  If it exists, 0=alive/missing and 1=death.
</p>
</td></tr>
<tr><td><code id="plot.pedigree_+3A_affected">affected</code></td>
<td>

<p>vector, or matrix with up to 4 columns for affected
indicators. Subject's symbol is divided into sections for each
status, shaded if indicator is 1, not-shaded for 0, and symbol &quot;?&quot;
if missing (NA)
</p>
</td></tr>
<tr><td><code id="plot.pedigree_+3A_cex">cex</code></td>
<td>

<p>controls text size.  Default=1.
</p>
</td></tr>
<tr><td><code id="plot.pedigree_+3A_col">col</code></td>
<td>

<p>color for each id.  Default assigns the same color to everyone.
</p>
</td></tr>
<tr><td><code id="plot.pedigree_+3A_symbolsize">symbolsize</code></td>
<td>

<p>controls symbolsize. Default=1.
</p>
</td></tr>
<tr><td><code id="plot.pedigree_+3A_branch">branch</code></td>
<td>

<p>defines how much angle is used to connect various levels of nuclear families.
</p>
</td></tr>
<tr><td><code id="plot.pedigree_+3A_packed">packed</code></td>
<td>

<p>default=T.  If T, uniform distance between all individuals at a given level.
</p>
</td></tr>
<tr><td><code id="plot.pedigree_+3A_align">align</code></td>
<td>
<p> these parameters control the extra effort spent trying to
align children underneath parents, but without making the pedigree too
wide.  Set to F to speed up plotting.
</p>
</td></tr>
<tr><td><code id="plot.pedigree_+3A_width">width</code></td>
<td>

<p>default=8.  For a packed pedigree, the minimum width allowed in the
realignment of pedigrees.
</p>
</td></tr>
<tr><td><code id="plot.pedigree_+3A_density">density</code></td>
<td>

<p>defines density used in the symbols.  Takes up to 4 different values.
</p>
</td></tr>
<tr><td><code id="plot.pedigree_+3A_mar">mar</code></td>
<td>
<p>margin parmeters, as in the <code>par</code> function</p>
</td></tr>
<tr><td><code id="plot.pedigree_+3A_angle">angle</code></td>
<td>

<p>defines angle used in the symbols.  Takes up to 4 different values.
</p>
</td></tr>
<tr><td><code id="plot.pedigree_+3A_keep.par">keep.par</code></td>
<td>

<p>Default = F, allows user to keep the parameter settings the same as they
were for plotting (useful for adding extras to the plot)
</p>
</td></tr>
<tr><td><code id="plot.pedigree_+3A_subregion">subregion</code></td>
<td>
<p>4-element vector for (min x, max x, min depth, max depth),
used to edit away portions of the plot coordinates returned by
align.pedigree
</p>
</td></tr>
<tr><td><code id="plot.pedigree_+3A_pconnect">pconnect</code></td>
<td>
<p>when connecting parent to children the program will try
to make the connecting line as close to vertical as possible, subject
to it lying inside the endpoints of the line that connects the
children by at least <code>pconnect</code> people.  Setting this option
to a large number will force the line to connect at the midpoint of
the children.</p>
</td></tr>
<tr><td><code id="plot.pedigree_+3A_...">...</code></td>
<td>

<p>Extra options that feed into the plot function.
</p>
</td></tr>
</table>


<h3>Details</h3>

  
<p>Two important parameters control the looks of the result.
One is the user specified
maximum width.  The smallest possible width is the maximum number of subjects
on a line, if the user's suggestion  
is too low it is increased to 1+ that
amount (to give just a little wiggle room).
To make a pedigree where all children are centered under parents simply
make the width large enough, however, the symbols may get very small.
</p>
<p>The second is <code>align</code>, a vector of 2 alignment parameters $a$ and $b$.
For each set of siblings at a set of locations
<code>x</code> and with parents at <code>p=c(p1,p2)</code> the
alignment penalty is
</p>
<p style="text-align: center;"><code class="reqn">(1/k^a)\sum{i=1}{k} [(x_i - (p1+p2)/2)]^2</code>
</p>

<p>where k is the number of siblings in the set.
when $a=1$ moving a sibship with $k$ sibs one unit to the left or
right of optimal will incur the same cost as moving one with only 1 or
two sibs out of place.  If $a=0$ then large sibships are harder to move
than small ones, with the default value $a=1.5$ they are slightly easier 
to move than small ones.  The rationale for the default is as long as the
parents are somewhere between the first and last siblings the result looks
fairly good, so we are more flexible with the spacing of a large family.
By tethering all the sibs to a single spot they are kept close to 
each other.
The alignment penalty for spouses is
<code class="reqn">b(x_1 - x_2)^2</code>, which tends to keep 
them together.  The size of $b$ controls the relative importance of sib-parent
and spouse-spouse closeness.
</p>


<h3>Value</h3>

<p>an invisible list containing
</p>
<table>
<tr><td><code>plist</code></td>
<td>
<p>a list that contains all the position information for
plotting the pedigree.  This will useful for further functions
(yet unwritten) for manipulating the plot, but likely not to an
ordinary user.</p>
</td></tr>
<tr><td><code>x</code>, <code>y</code></td>
<td>
<p>the x an and y plot coordinates of each subject in the
plot. The coordinate is for the top of the plotted symbol.
These will be in the same order as the input pedigree.  If
someone in the pedigree does not appear in the plot their
coordinates will be NA.  If they appear multiple times one of the
instances is chosen.  (Which one is a function of the order in
which the pedigree was constructed.)</p>
</td></tr>
<tr><td><code>boxh</code></td>
<td>
<p>the height of the symbol, in user coordinates</p>
</td></tr>
<tr><td><code>boxw</code></td>
<td>
<p>the width of the symbol</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>a copy of the call that generated the plot</p>
</td></tr>
</table>


<h3>Side Effects</h3>

<p>creates plot on current plotting device.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pedigree">pedigree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sample.ped)

pedAll &lt;- pedigree(sample.ped$id, sample.ped$father, sample.ped$mother, 
       sample.ped$sex,  #affected=sample.ped$affected,
       affected=cbind(sample.ped$affected, sample.ped$avail), 
       famid=sample.ped$ped)

ped2 &lt;- pedAll['2']

print(ped2)


## plot(ped2)

</code></pre>

<hr>
<h2 id='plot.pedigree.shrink'>
plot pedigree.shrink object that is a shrunk pedigree object
</h2><span id='topic+plot.pedigree.shrink'></span>

<h3>Description</h3>

<p>Plot the pedigree object that is the trimmed pedigree.shrink object
along with colors based on availability and affection status.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pedigree.shrink'
plot(x, bigped=FALSE, title="", xlegend="topright", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.pedigree.shrink_+3A_x">x</code></td>
<td>

<p>A pedigree.shrink object, which contains a pedigree object and
information about which subject was removed.
</p>
</td></tr>
<tr><td><code id="plot.pedigree.shrink_+3A_bigped">bigped</code></td>
<td>

<p>Logical value indicating whether pedigree should be compacted to fit
in plotting region.  If T, then packed=F is used in pedigree() along
with smaller symbol sizes.
</p>
</td></tr>
<tr><td><code id="plot.pedigree.shrink_+3A_title">title</code></td>
<td>

<p>Optional plot title
</p>
</td></tr>
<tr><td><code id="plot.pedigree.shrink_+3A_xlegend">xlegend</code></td>
<td>

<p>The x argument for the legend command, which allows coordinates or,
more conveniently, options such as &quot;topright&quot;, &quot;right&quot;, &quot;left&quot;, &quot;bottomleft&quot;,
etc., which is useful for pedigrees that cover most of the plot region.
</p>
</td></tr>
<tr><td><code id="plot.pedigree.shrink_+3A_...">...</code></td>
<td>

<p>Optional arguments to plot method
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+pedigree.shrink">pedigree.shrink</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sample.ped)

fam2 &lt;- sample.ped[sample.ped$ped==2,]
ped2 &lt;- pedigree(fam2$id, fam2$father, fam2$mother, fam2$sex,
                 fam2$affected, fam2$avail)

shrink2 &lt;- pedigree.shrink(ped2,avail=fam2$avail)
shrink2

plot(ped2)

plot.pedigree.shrink(shrink2, title="Sample Pedigree 2")




</code></pre>

<hr>
<h2 id='sample.ped'> Two example pedigrees </h2><span id='topic+sample.ped'></span>

<h3>Description</h3>

<p>Two pedigrees of different size for testing pedigree operations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sample.ped)</code></pre>


<h3>Format</h3>

<p>A data frame with 55 observations on the following 7 variables.
</p>

<dl>
<dt><code>ped</code></dt><dd><p> pedigree id</p>
</dd>
<dt><code>id</code></dt><dd><p> subject id, unique to each ped</p>
</dd>
<dt><code>father</code></dt><dd><p>id of the subject's father</p>
</dd>
<dt><code>mother</code></dt><dd><p>id of the subject's mother</p>
</dd>
<dt><code>sex</code></dt><dd><p> 1=male, 2=female, 3=unknown</p>
</dd>
<dt><code>affected</code></dt><dd><p>affection status; 0=unaffected, 1=affected, NA=unknown</p>
</dd>
<dt><code>avail</code></dt><dd><p> is DNA data available; 0=unavailable, 1=available</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(sample.ped)
</code></pre>

<hr>
<h2 id='testped1'> testped1</h2><span id='topic+testped1'></span>

<h3>Description</h3>

<p>Sample pedigree 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(testped1)</code></pre>


<h3>Format</h3>

<p>A data frame with 79 subjects in one family with the following variables.
</p>

<dl>
<dt><code>id</code></dt><dd><p> subject id, unique to each ped</p>
</dd>
<dt><code>father</code></dt><dd><p>id of the subject's father</p>
</dd>
<dt><code>mother</code></dt><dd><p>id of the subject's mother</p>
</dd>
<dt><code>sex</code></dt><dd><p> 1=male, 2=female</p>
</dd>   
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(testped1)
testped1[1:20,]

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
