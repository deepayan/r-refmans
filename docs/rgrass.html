<!DOCTYPE html><html lang="en"><head><title>Help for package rgrass</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rgrass}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rgrass'><p>rgrass: Interface between GRASS geographical information system and R</p></a></li>
<li><a href='#execGRASS'><p>Run GRASS commands</p></a></li>
<li><a href='#gmeta'><p>Reads GRASS metadata from the current LOCATION</p></a></li>
<li><a href='#initGRASS'><p>Initiate GRASS session</p></a></li>
<li><a href='#read_RAST'><p>Read and write GRASS raster files</p></a></li>
<li><a href='#read_VECT'><p>Read and write GRASS vector object files</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.5-2</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-02-13</td>
</tr>
<tr>
<td>Title:</td>
<td>Interface Between 'GRASS' Geographical Information System and
'R'</td>
</tr>
<tr>
<td>Description:</td>
<td>An interface between the 'GRASS' geographical information system ('GIS') and 'R', based on starting 'R' from within the 'GRASS' 'GIS' environment, or running a free-standing 'R' session in a temporary 'GRASS' location; the package provides facilities for using all 'GRASS' commands from the 'R' command line. The original interface package for 'GRASS 5' (2000-2010) is described in Bivand (2000) &lt;<a href="https://doi.org/10.1016%2FS0098-3004%2800%2900057-1">doi:10.1016/S0098-3004(00)00057-1</a>&gt; and Bivand (2001) <a href="https://www.r-project.org/conferences/DSC-2001/Proceedings/Bivand.pdf">https://www.r-project.org/conferences/DSC-2001/Proceedings/Bivand.pdf</a>. This was succeeded by 'spgrass6' for 'GRASS 6' (2006-2016) and 'rgrass7' for 'GRASS 7' (2015-present). The 'rgrass' package modernizes the interface for 'GRASS 8' while still permitting the use of 'GRASS 7'.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils, methods, xml2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>terra (&ge; 1.6-16), sp (&ge; 0.9), knitr, rmarkdown, sf, stars,
raster (&ge; 3.6-3), codetools, testthat (&ge; 3.0.0), withr, fs</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GRASS (&gt;= 7)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://osgeo.github.io/rgrass/">https://osgeo.github.io/rgrass/</a>, <a href="https://grass.osgeo.org/">https://grass.osgeo.org/</a>,
<a href="https://github.com/osgeo/rgrass">https://github.com/osgeo/rgrass</a>,
<a href="https://lists.osgeo.org/mailman/listinfo/grass-stats">https://lists.osgeo.org/mailman/listinfo/grass-stats</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/osgeo/rgrass/issues/">https://github.com/osgeo/rgrass/issues/</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-14 04:11:04 UTC; ubuntu</td>
</tr>
<tr>
<td>Author:</td>
<td>Roger Bivand <a href="https://orcid.org/0000-0003-2392-6140"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Sebastian Jeworutzki
    <a href="https://orcid.org/0000-0002-2671-5253"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Rainer Krug <a href="https://orcid.org/0000-0002-7490-0066"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Robin Lovelace <a href="https://orcid.org/0000-0001-5679-6536"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Markus Neteler <a href="https://orcid.org/0000-0003-1916-1966"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Steven Pawley <a href="https://orcid.org/0000-0002-5524-3320"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut],
  Floris Vanderhaeghe
    <a href="https://orcid.org/0000-0002-6378-6229"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Steven Pawley &lt;dr.stevenpawley@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-14 05:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='rgrass'>rgrass: Interface between GRASS geographical information system and R</h2><span id='topic+rgrass-package'></span><span id='topic+rgrass'></span>

<h3>Description</h3>

<p>Interpreted interface between GRASS geographical information
system, versions 7 and 8, and R, based on starting R from within the GRASS
environment, or on running R stand-alone and creating a throw-away GRASS
environment from within R. The interface uses classes defined in the sp
package to hold spatial data.
</p>


<h3>Details</h3>

<p>Index:
</p>
<pre>
read_RAST              read GRASS raster files
write_RAST             write GRASS raster files
read_VECT              read GRASS vector object files
write_VECT             write GRASS vector object files
gmeta                  read GRASS metadata from the current LOCATION
getLocationProj        return a WKT2 string of projection information
gmeta2grd              create a GridTopology object from the GRASS region
vInfo                  return vector geometry information
vColumns               return vector database columns information
vDataCount             return count of vector database rows
vect2neigh             return area neighbours with shared boundary length
</pre>
<p>Note that the examples now use the smaller subset North Carolina location:
<a href="https://grass.osgeo.org/sampledata/north_carolina/nc_basic_spm_grass7.tar.gz">https://grass.osgeo.org/sampledata/north_carolina/nc_basic_spm_grass7.tar.gz</a>
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Steven Pawley <a href="mailto:dr.stevenpawley@gmail.com">dr.stevenpawley@gmail.com</a> (<a href="https://orcid.org/0000-0002-5524-3320">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Roger Bivand <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a> (<a href="https://orcid.org/0000-0003-2392-6140">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Sebastian Jeworutzki <a href="mailto:Sebastian.Jeworutzki@rub.de">Sebastian.Jeworutzki@rub.de</a> (<a href="https://orcid.org/0000-0002-2671-5253">ORCID</a>) [contributor]
</p>
</li>
<li><p> Rainer Krug <a href="mailto:Rainer@krugs.de">Rainer@krugs.de</a> (<a href="https://orcid.org/0000-0002-7490-0066">ORCID</a>) [contributor]
</p>
</li>
<li><p> Robin Lovelace (<a href="https://orcid.org/0000-0001-5679-6536">ORCID</a>) [contributor]
</p>
</li>
<li><p> Markus Neteler <a href="mailto:neteler@osgeo.org">neteler@osgeo.org</a> (<a href="https://orcid.org/0000-0003-1916-1966">ORCID</a>) [contributor]
</p>
</li>
<li><p> Floris Vanderhaeghe <a href="mailto:floris.vanderhaeghe@inbo.be">floris.vanderhaeghe@inbo.be</a> (<a href="https://orcid.org/0000-0002-6378-6229">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://osgeo.github.io/rgrass/">https://osgeo.github.io/rgrass/</a>
</p>
</li>
<li> <p><a href="https://grass.osgeo.org/">https://grass.osgeo.org/</a>
</p>
</li>
<li> <p><a href="https://github.com/osgeo/rgrass">https://github.com/osgeo/rgrass</a>
</p>
</li>
<li> <p><a href="https://lists.osgeo.org/mailman/listinfo/grass-stats">https://lists.osgeo.org/mailman/listinfo/grass-stats</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/osgeo/rgrass/issues/">https://github.com/osgeo/rgrass/issues/</a>
</p>
</li></ul>


<hr>
<h2 id='execGRASS'>Run GRASS commands</h2><span id='topic+execGRASS'></span><span id='topic+stringexecGRASS'></span><span id='topic+doGRASS'></span><span id='topic+parseGRASS'></span><span id='topic+print.GRASS_interface_desc'></span><span id='topic+getXMLencoding'></span><span id='topic+setXMLencoding'></span>

<h3>Description</h3>

<p>The functions provide an interface to GRASS commands run through
<code>system</code>, based on the values returned by the <code style="white-space: pre;">&#8288;--interface description&#8288;</code>
flag using XML parsing. If required parameters are omitted, and
have declared defaults, the defaults will be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>execGRASS(
  cmd,
  flags = NULL,
  ...,
  parameters = NULL,
  intern = NULL,
  ignore.stderr = NULL,
  Sys_ignore.stdout = FALSE,
  Sys_wait = TRUE,
  Sys_input = NULL,
  Sys_show.output.on.console = TRUE,
  Sys_minimized = FALSE,
  Sys_invisible = TRUE,
  echoCmd = NULL,
  redirect = FALSE,
  legacyExec = NULL
)

stringexecGRASS(
  string,
  intern = NULL,
  ignore.stderr = NULL,
  Sys_ignore.stdout = FALSE,
  Sys_wait = TRUE,
  Sys_input = NULL,
  Sys_show.output.on.console = TRUE,
  Sys_minimized = FALSE,
  Sys_invisible = TRUE,
  echoCmd = NULL,
  redirect = FALSE,
  legacyExec = NULL
)

doGRASS(
  cmd,
  flags = NULL,
  ...,
  parameters = NULL,
  echoCmd = NULL,
  legacyExec = NULL
)

parseGRASS(cmd, legacyExec = NULL)

## S3 method for class 'GRASS_interface_desc'
print(x, ...)

getXMLencoding()

setXMLencoding(enc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="execGRASS_+3A_cmd">cmd</code></td>
<td>
<p>GRASS command name.</p>
</td></tr>
<tr><td><code id="execGRASS_+3A_flags">flags</code></td>
<td>
<p>character vector of GRASS command flags.</p>
</td></tr>
<tr><td><code id="execGRASS_+3A_...">...</code></td>
<td>
<p>for <code>execGRASS</code> and <code>doGRASS</code>, GRASS module parameters
given as R named arguments directly. For the <code>print</code> method, other
arguments to print method. The storage modes of values passed must match
those required in GRASS, so a single GRASS string must be a character vector
of length 1, a single GRASS integer must be an integer vector of length 1
(may be an integer constant such as 10L), and a single GRASS float must be
a numeric vector of length 1. For multiple values, use vectors of suitable
length.</p>
</td></tr>
<tr><td><code id="execGRASS_+3A_parameters">parameters</code></td>
<td>
<p>list of GRASS command parameters, used if GRASS parameters
are not given as R arguments directly; the two methods for passing GRASS
parameters may not be mixed. The storage modes of values passed must match
those required in GRASS, so a single GRASS string must be a character vector
of length 1, a single GRASS integer must be an integer vector of length 1
(may be an integer constant such as 10L), and a single GRASS float must be
a numeric vector of length 1. For multiple values, use vectors of suitable
length.</p>
</td></tr>
<tr><td><code id="execGRASS_+3A_intern">intern</code></td>
<td>
<p>default NULL, in which case set internally from
<code>get.useInternOption</code>; a logical (not 'NA') which indicates whether to
make the output of the command an R object. Not available unless 'popen' is
supported on the platform.</p>
</td></tr>
<tr><td><code id="execGRASS_+3A_ignore.stderr">ignore.stderr</code></td>
<td>
<p>default NULL, taking the value set by
<code>set.ignore.stderrOption</code>, a logical indicating whether error messages
written to 'stderr' should be ignored.</p>
</td></tr>
<tr><td><code id="execGRASS_+3A_sys_ignore.stdout">Sys_ignore.stdout</code>, <code id="execGRASS_+3A_sys_wait">Sys_wait</code>, <code id="execGRASS_+3A_sys_input">Sys_input</code></td>
<td>
<p>pass extra arguments to
<code>system</code>.</p>
</td></tr>
<tr><td><code id="execGRASS_+3A_sys_show.output.on.console">Sys_show.output.on.console</code>, <code id="execGRASS_+3A_sys_minimized">Sys_minimized</code>, <code id="execGRASS_+3A_sys_invisible">Sys_invisible</code></td>
<td>
<p>pass extra
arguments to <code>system</code> on Windows systems only.</p>
</td></tr>
<tr><td><code id="execGRASS_+3A_echocmd">echoCmd</code></td>
<td>
<p>default NULL, taking the logical value set by
<code>set.echoCmdOption</code>, print GRASS command to be executed to console.</p>
</td></tr>
<tr><td><code id="execGRASS_+3A_redirect">redirect</code></td>
<td>
<p>default <code>FALSE</code>, if <code>TRUE</code>, add &quot;2&gt;&amp;1&quot; to
the command string and set <code>intern</code> to <code>TRUE</code>; only used in
legacy mode.</p>
</td></tr>
<tr><td><code id="execGRASS_+3A_legacyexec">legacyExec</code></td>
<td>
<p>default NULL, taking the logical value set by
<code>set.legacyExecOption</code> which is initialised to <code>FALSE</code> on
&quot;unix&quot; platforms and <code>TRUE</code> otherwise. If <code>TRUE</code>, use
<code>system</code>, if <code>FALSE</code> use <code>system2</code> and divert stderr to
temporary file to record error messages and warnings from GRASS modules.</p>
</td></tr>
<tr><td><code id="execGRASS_+3A_string">string</code></td>
<td>
<p>a string representing <em>one</em> full GRASS statement, using shell
syntax: command name, optionally followed by flags and parameters, all
separated by whitespaces. Parameters follow the key=value format; if
’value’ contains spaces, then ’value’ must be quoted</p>
</td></tr>
<tr><td><code id="execGRASS_+3A_x">x</code></td>
<td>
<p>object to be printed</p>
</td></tr>
<tr><td><code id="execGRASS_+3A_enc">enc</code></td>
<td>
<p>character string to replace UTF-8 in header of XML data generated
by GRASS module –interface-description output when the internationalised
messages are not in UTF-8 (known to apply to French, which is in latin1)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>parseGRASS</code> checks to see whether the GRASS command has been parsed
already and cached in this session; if not, it reads the interface
description, parses it and caches it for future use. <code>doGRASS</code> assembles
a proposed GRASS command with flags and parameters as a string, wrapping
<code>parseGRASS</code>, and <code>execGRASS</code> is a wrapper for <code>doGRASS</code>,
running the command through <code>system</code> (from 0.7-4, the <code>...</code>
argument is not used for passing extra arguments for <code>system</code>). The
command string is termed proposed, because not all of the particular needs of
commands are provided by the interface description, and no check is made for
the existence of input objects. Support for multiple parameter values added
with help from Patrick Caldon. Support for defaults and for direct use of
GRASS parameters instead of a parameter list suggested by Rainer Krug.
</p>
<p><code>stringexecGRASS</code> is a wrapper around <code>execGRASS</code>, and accepts a
single shell statement as a string (following GRASS's command syntax).
</p>


<h3>Value</h3>

<p><code>parseGRASS</code> returns a <code>GRASS_interface_desc</code> object,
<code>doGRASS</code> returns a character string with a proposed GRASS command -
the expanded command name is returned as an attribute, and <code>execGRASS</code>
and  <code>stringexecGRASS</code> return what <code>system</code> or <code>system2</code>
return, particularly depending on the <code>intern</code> argument when the
character strings output by GRASS modules are returned.
</p>
<p>If <code>intern</code> is <code>FALSE</code>, <code>system</code> returns the module exit
code, while <code>system2</code> returns the module exit code with
&quot;resOut&quot; and &quot;resErr&quot; attributes.
</p>


<h3>Note</h3>

<p>If any package command fails with a UTF-8 error from the XML package, try
using <code>setXMLencoding</code> to work around the problem that GRASS modules
declare &ndash;interface-description output as UTF-8 without ensuring that it is
(French is of 6.4.0 RC5 latin1).
</p>


<h3>Author(s)</h3>

<p>Roger S. Bivand, e-mail: <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+system">base::system()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Run examples if in an active GRASS session in the nc_basic_spm_grass7
Sys.setenv("_SP_EVOLUTION_STATUS_" = "2")
run &lt;- FALSE
GISRC &lt;- Sys.getenv("GISRC")
if (nchar(GISRC) &gt; 0) {
  location_name &lt;- read.dcf(GISRC)[1, "LOCATION_NAME"]
  if (location_name == "nc_basic_spm_grass7") {
    run &lt;- TRUE
  }
}

# Save and set echo command option
echoCmdOption &lt;- get.echoCmdOption()
set.echoCmdOption(TRUE)

if (run) {
  # Read and print GRASS interface description for 'r.slope.aspect'
  print(parseGRASS("r.slope.aspect"))
}
if (run) {
  # Assemble the 'r.slope.aspect' command with specified parameters as a string
  doGRASS(
    "r.slope.aspect",
    flags = c("overwrite"),
    elevation = "elevation.dem",
    slope = "slope",
    aspect = "aspect"
  )
}
if (run) {
  # Alternatively, specify parameters as a list
  params &lt;- list(elevation = "elevation",
                 slope = "slope",
                 aspect = "aspect")
  doGRASS("r.slope.aspect",
          flags = c("overwrite"),
          parameters = params)
}
if (run) {
  # Read and print GRASS interface description for 'r.buffer'
  print(parseGRASS("r.buffer"))
}
if (run) {
  # Assemble the 'r.buffer' with specified parameters as as string
  doGRASS(
    "r.buffer",
    flags = c("overwrite"),
    input = "schools",
    output = "bmap",
    distances = seq(1000, 15000, 1000)
  )
}
if (run) {
  # Alternatively, specify parameters as a list
  params &lt;- list(
    input = "schools",
    output = "bmap",
    distances = seq(1000, 15000, 1000)
  )
  doGRASS("r.buffer", flags = c("overwrite"), parameters = params)
}
if (run) {
  # Restore original echo command option
  set.echoCmdOption(echoCmdOption)

  # Try executing 'r.stats' command which will fail because "fire_blocksgg"
  # does not exist in the mapset
  try(res &lt;- execGRASS("r.stats", input = "fire_blocksgg", flags = c("C", "n")),
      silent = FALSE)
}
if (run) {
  # Execute 'r.stats' with legacyExec and print the result
  res &lt;- execGRASS(
    "r.stats",
    input = "fire_blocksgg",
    flags = c("C", "n"),
    legacyExec = TRUE
  )
  print(res)
}
if (run) {
  # If the command failed, retrieve error message
  if (res != 0) {
    resERR &lt;- execGRASS(
      "r.stats",
      input = "fire_blocksgg",
      flags = c("C", "n"),
      redirect = TRUE,
      legacyExec = TRUE
    )
    print(resERR)
  }
}
if (run) {

  # Use 'stringexecGRASS' to run a command and print the result
  res &lt;- stringexecGRASS("r.stats -p -l input=geology", intern = TRUE)
  print(res)

  stringexecGRASS(
    "r.random.cells --overwrite --quiet output=samples distance=1000 ncells=100 seed=1"
  )
}
if (run) {
  # Alternatively, run the same command using 'execGRASS'
  execGRASS(
    "r.random.cells",
    flags  = c("overwrite", "quiet"),
    output = "samples",
    distance = 1000,
    ncells = 100L,
    seed = 1L
  )
}
</code></pre>

<hr>
<h2 id='gmeta'>Reads GRASS metadata from the current LOCATION</h2><span id='topic+gmeta'></span><span id='topic+getLocationProj'></span><span id='topic+gmeta2grd'></span><span id='topic+print.gmeta'></span><span id='topic+get.ignore.stderrOption'></span><span id='topic+get.stop_on_no_flags_parasOption'></span><span id='topic+get.echoCmdOption'></span><span id='topic+get.useInternOption'></span><span id='topic+get.legacyExecOption'></span><span id='topic+get.defaultFlagsOption'></span><span id='topic+get.suppressEchoCmdInFuncOption'></span><span id='topic+set.ignore.stderrOption'></span><span id='topic+set.stop_on_no_flags_parasOption'></span><span id='topic+set.echoCmdOption'></span><span id='topic+set.useInternOption'></span><span id='topic+set.legacyExecOption'></span><span id='topic+set.defaultFlagsOption'></span><span id='topic+set.suppressEchoCmdInFuncOption'></span>

<h3>Description</h3>

<p>GRASS LOCATION metadata are read into a list in R; helper function
getLocationProj returns a WKT2 string of projection information. The helper
function <code>gmeta2grd</code> creates a GridTopology object from the current
GRASS mapset region definitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmeta(ignore.stderr = FALSE, g.proj_WKT = NULL)

getLocationProj(ignore.stderr = FALSE, g.proj_WKT = NULL)

gmeta2grd(ignore.stderr = FALSE)

## S3 method for class 'gmeta'
print(x, ...)

get.ignore.stderrOption()

get.stop_on_no_flags_parasOption()

get.echoCmdOption()

get.useInternOption()

get.legacyExecOption()

get.defaultFlagsOption()

get.suppressEchoCmdInFuncOption()

set.ignore.stderrOption(value)

set.stop_on_no_flags_parasOption(value)

set.echoCmdOption(value)

set.useInternOption(value)

set.legacyExecOption(value)

set.defaultFlagsOption(value)

set.suppressEchoCmdInFuncOption(value)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gmeta_+3A_ignore.stderr">ignore.stderr</code></td>
<td>
<p>default FALSE, can be set to TRUE to silence
<code>system()</code> output to standard error; does not apply on Windows
platforms.</p>
</td></tr>
<tr><td><code id="gmeta_+3A_g.proj_wkt">g.proj_WKT</code></td>
<td>
<p>default NULL: return WKT2 representation in GRASS &gt;= 7.6
and Proj4 in GRASS &lt; 7.6; may be set to FALSE to return Proj4 for GRASS &gt;=
7.6.</p>
</td></tr>
<tr><td><code id="gmeta_+3A_x">x</code></td>
<td>
<p>S3 object returned by gmeta</p>
</td></tr>
<tr><td><code id="gmeta_+3A_...">...</code></td>
<td>
<p>arguments passed through print method</p>
</td></tr>
<tr><td><code id="gmeta_+3A_value">value</code></td>
<td>
<p>logical value for setting options on <code>ignore.stderr</code> set by
default on package load to FALSE, <code>stop_on_no_flags_params</code> set by default
on package load to TRUE, <code>echoCmd</code> set by default on package load to FALSE.
<code>useIntern</code> sets the intern argument globally; <code>legacyExec</code> sets the
legacyExec option globally, but is initialized to FALSE on unix systems
(all but Windows) and TRUE on Windows; <code>defaultFlags</code> is initialized to
NULL, but may be a character vector with values from c(&quot;quiet&quot;, &quot;verbose&quot;)
<code>suppressEchoCmdInFunc</code> default TRUE suppresses the effect of echoCmd
within package functions, maybe set FALSE for debugging.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns list of g.gisenv, g.region -g3, and g.proj values.
</p>


<h3>Author(s)</h3>

<p>Roger S. Bivand, e-mail: <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>run &lt;- FALSE
if (nchar(Sys.getenv("GISRC")) &gt; 0 &amp;&amp;
    read.dcf(Sys.getenv("GISRC"))[1, "LOCATION_NAME"] == "nc_basic_spm_grass7") {
  run &lt;- TRUE
}

if (run) {
  G &lt;- gmeta()
  print(G)
}

if (run) {
  cat(getLocationProj(), "\n")
  cat(getLocationProj(g.proj_WKT = FALSE), "\n")
}

if (run) {
  grd &lt;- gmeta2grd()
  print(grd)
}

if (run) {
  ncells &lt;- prod(slot(grd, "cells.dim"))
  df &lt;- data.frame(k = rep(1, ncells))
  mask_SG &lt;- sp::SpatialGridDataFrame(grd, data = df)
  print(summary(mask_SG))
}
</code></pre>

<hr>
<h2 id='initGRASS'>Initiate GRASS session</h2><span id='topic+initGRASS'></span><span id='topic+get.GIS_LOCK'></span><span id='topic+set.GIS_LOCK'></span><span id='topic+unset.GIS_LOCK'></span><span id='topic+unlink_.gislock'></span><span id='topic+remove_GISRC'></span>

<h3>Description</h3>

<p>Run GRASS interface in an R session not started within GRASS. In general,
most users will use <code>initGRASS</code> in throwaway locations, to use GRASS
modules  on R objects without the need to define and populate a location. The
function initializes environment variables used by GRASS, the .gisrc used by
GRASS for further environment variables, and a temporary location.
</p>
<p>On Windows, if OSGeo4W GRASS is being used, the R session must be started in
the OSGeo4W shell. If not, the non-standard placing of files and of
environment variables confuses the function. If <code>toupper(gisBase)</code>
contains &quot;OSGEO4W64/APPS/GRASS&quot; or &quot;OSGEO4W/APPS/GRASS&quot; (and
after converting &quot;\&quot; to &quot;/&quot;), but the environment variable
<code>OSGEO4W_ROOT</code> is not defined, <code>initGRASS()</code> will exit with an
error before confusion leads to further errors. For further details, see
<a href="https://github.com/osgeo/rgrass/issues/16">https://github.com/osgeo/rgrass/issues/16</a> and
<a href="https://github.com/osgeo/rgrass/issues/16">https://github.com/osgeo/rgrass/issues/16</a>.
</p>
<p>The same restriction applies to use of GRASS with QGIS Windows standalone
installations, which may be used with <code>initGRASS</code> only if the R session
is started from the OSGeo4W shell shipped as part of the standalone installer
(see <a href="https://github.com/osgeo/rgrass/issues/87">https://github.com/osgeo/rgrass/issues/87</a>). The function will
exit with an error if R was not started from the QGIS OSGeo4W shell before
confusion leads to further errors.
</p>
<p>The locking functions are used internally, but are exposed for experienced
R/GRASS scripters needing to use the GRASS module &quot;g.mapset&quot; through
<code>initGRASS</code> in an existing GRASS location. In particular,
&quot;g.mapset&quot; may leave a <code>.gislock</code> file in the current MAPSET, so
it may be important to call <code>unlink_.gislock</code> to clean up before
quitting the R session. <code>remove_GISRC</code> may be used to try to remove the
file given in the &quot;GISRC&quot; environment variable if created by
<code>initGRASS</code> with argument <code style="white-space: pre;">&#8288;remove_GISRC=&#8288;</code> TRUE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initGRASS(
  gisBase = NULL,
  home,
  SG,
  gisDbase,
  addon_base,
  location,
  mapset,
  override = FALSE,
  use_g.dirseps.exe = TRUE,
  pid,
  remove_GISRC = FALSE,
  ignore.stderr = get.ignore.stderrOption()
)

get.GIS_LOCK()

set.GIS_LOCK(pid)

unset.GIS_LOCK()

unlink_.gislock()

remove_GISRC()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="initGRASS_+3A_gisbase">gisBase</code></td>
<td>
<p>The directory path to GRASS binaries and libraries, containing
bin and lib subdirectories among others; if NULL, set from environment
variable GRASS_INSTALLATION if found, if not found,
<code>system("grass --config path")</code> is tried.</p>
</td></tr>
<tr><td><code id="initGRASS_+3A_home">home</code></td>
<td>
<p>The directory in which to create the .gisrc file; defaults to
<code style="white-space: pre;">&#8288;$HOME&#8288;</code> on Unix systems and to <code>USERPROFILE</code> on Windows systems;
can usually be set to <code>tempdir()</code>.</p>
</td></tr>
<tr><td><code id="initGRASS_+3A_sg">SG</code></td>
<td>
<p>An optional <code>SpatRaster</code> or <code>SpatialGrid</code> object to
define the <code>DEFAULT_WIND</code> of the temporary location.</p>
</td></tr>
<tr><td><code id="initGRASS_+3A_gisdbase">gisDbase</code></td>
<td>
<p>if missing, <code>tempdir()</code> will be used; GRASS GISDBASE
directory for the working session.</p>
</td></tr>
<tr><td><code id="initGRASS_+3A_addon_base">addon_base</code></td>
<td>
<p>if missing, assumed to be &quot;$HOME/.grass7/addons&quot; on
Unix-like platforms, on MS Windows &quot;\
and checked for existence.</p>
</td></tr>
<tr><td><code id="initGRASS_+3A_location">location</code></td>
<td>
<p>if missing, <code>basename(tempfile())</code> will be used; GRASS
location directory for the working session.</p>
</td></tr>
<tr><td><code id="initGRASS_+3A_mapset">mapset</code></td>
<td>
<p>if missing, <code>basename(tempfile())</code> will be used; GRASS
mapset directory for the working session.</p>
</td></tr>
<tr><td><code id="initGRASS_+3A_override">override</code></td>
<td>
<p>default FALSE, set to TRUE if accidental trashing of GRASS
.gisrc files and locations is not a problem.</p>
</td></tr>
<tr><td><code id="initGRASS_+3A_use_g.dirseps.exe">use_g.dirseps.exe</code></td>
<td>
<p>default TRUE; when TRUE appears to work for WinGRASS
Native binaries, when FALSE for QGIS GRASS binaries; ignored on other
platforms.</p>
</td></tr>
<tr><td><code id="initGRASS_+3A_pid">pid</code></td>
<td>
<p>default <code>as.integer(round(runif(1, 1, 1000)))</code>, integer used
to identify GIS_LOCK; the value here is arbitrary, but probably should be
set correctly.</p>
</td></tr>
<tr><td><code id="initGRASS_+3A_remove_gisrc">remove_GISRC</code></td>
<td>
<p>default FALSE; if TRUE, attempt to unlink the temporary
file named in the &quot;GISRC&quot; environment variable when the R session
terminates or when this package is unloaded.</p>
</td></tr>
<tr><td><code id="initGRASS_+3A_ignore.stderr">ignore.stderr</code></td>
<td>
<p>default taking the value set by
<code>set.ignore.stderrOption</code>; can be set to TRUE to silence
<code>system()</code> output to standard error; does not apply on Windows
platforms.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function establishes an out-of-GRASS working environment providing GRASS
commands with the environment variable support required, and may also provide
a temporary location for use until the end of the running R session if the
<code>home</code> argument is set to <code>tempdir()</code>, and the <code>gisDbase</code>
argument is not given. Running <code>gmeta</code> shows where the location is,
should it be desired to archive it before leaving R.
</p>


<h3>Value</h3>

<p>The function runs <code>gmeta6</code> before returning the current values
of the running GRASS session that it provides.
</p>


<h3>Note</h3>

<p>If any package command fails with a UTF-8 error from the XML package, try
using <code>setXMLencoding</code> to work around the problem that GRASS modules
declare &ndash;interface-description output as UTF-8 without ensuring that it is.
</p>


<h3>Author(s)</h3>

<p>Roger S. Bivand, e-mail: <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gmeta">gmeta()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Run only if GRASS installation is found and 'terra' package is installed
GRASS_INSTALLATION &lt;- Sys.getenv("GRASS_INSTALLATION")
run &lt;- nzchar(GRASS_INSTALLATION) &amp;&amp;
       file.exists(GRASS_INSTALLATION) &amp;&amp;
       file.info(GRASS_INSTALLATION)$isdir &amp;&amp;
       require(terra, quietly = TRUE)

if (run) {
  # Get the terra example dataset
  f &lt;- system.file("ex/elev.tif", package="terra")
  r &lt;- rast(f)
}

# Check for existing GRASS session running
if (run) {
  loc_existing &lt;- try(gmeta(), silent = TRUE)
}

if (run) {
  # Initialize a temporary GRASS project using the example data
  loc &lt;- initGRASS(
    gisBase = GRASS_INSTALLATION,
    home = tempdir(),
    SG = r,
    override = TRUE
  )
}

if (run) {
  # Write the example data to the GRASS database
  write_RAST(r, "elev", flags = "overwrite")
  execGRASS("r.info", map = "elev")
}

if (run) {
  # Calculate slope and aspect raster
  execGRASS(
    "r.slope.aspect",
    flags    = "overwrite",
    elevation = "elev",
    slope    = "slope",
    aspect   = "aspect"
  )
}

if (run) {
  # Read the results back into R and plot
  u1 &lt;- read_RAST(c("elev", "slope", "aspect"), return_format = "terra")
  plot(u1[["elev"]], col = terrain.colors(50))
}

# Restore the original GRASS session
if (run) {
  if (!inherits(loc_existing, "try-error")) {
    loc &lt;- initGRASS(
      home = tempdir(),
      gisBase = GRASS_INSTALLATION,
      gisDbase = loc_existing$GISDBASE,
      location = loc_existing$LOCATION_NAME,
      mapset = loc_existing$MAPSET,
      override = TRUE
    )
  }
}
</code></pre>

<hr>
<h2 id='read_RAST'>Read and write GRASS raster files</h2><span id='topic+read_RAST'></span><span id='topic+write_RAST'></span>

<h3>Description</h3>

<p>Read GRASS raster files from GRASS into R <code><a href="terra.html#topic+SpatRaster-class">terra::SpatRaster</a></code> or
<code><a href="sp.html#topic+SpatialGridDataFrame">sp::SpatialGridDataFrame</a></code> objects, and write single columns of
<code><a href="terra.html#topic+SpatRaster-class">terra::SpatRaster</a></code> or <code><a href="sp.html#topic+SpatialGridDataFrame">sp::SpatialGridDataFrame</a></code>
objects to GRASS. When <code>return_format="terra"</code>, temporary binary files
and r.out.bin and r.in.bin are used for speed reasons. <code>read_RAST()</code> and
<code>write_RAST()</code> by default use &quot;RRASTER&quot; files written and read by
GDAL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_RAST(
  vname,
  cat = NULL,
  NODATA = NULL,
  return_format = "terra",
  close_OK = return_format == "SGDF",
  flags = NULL,
  Sys_ignore.stdout = FALSE,
  ignore.stderr = get.ignore.stderrOption()
)

write_RAST(
  x,
  vname,
  zcol = 1,
  NODATA = NULL,
  flags = NULL,
  ignore.stderr = get.ignore.stderrOption(),
  overwrite = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_RAST_+3A_vname">vname</code></td>
<td>
<p>A vector of GRASS raster file names in mapsets in the current
search path, as set by &quot;g.mapsets&quot;; the file names may be given as
fully-qualified map names using &quot;name@mapset&quot;, in which case only
the mapset given in the full path will be searched for the existence of the
raster; if more than one raster with the same name is found in mapsets in
the current search path, an error will occur, in which case the user should
give the fully-qualified map name. If the fully-qualified name is used,
<code>@</code> will be replaced by underscore in the output object.</p>
</td></tr>
<tr><td><code id="read_RAST_+3A_cat">cat</code></td>
<td>
<p>default NULL; if not NULL, must be a logical vector matching
vname, stating which (CELL) rasters to return as factor.</p>
</td></tr>
<tr><td><code id="read_RAST_+3A_nodata">NODATA</code></td>
<td>
<p>by default NULL, in which case it is set to one less than
<code>floor()</code> of the data values for FCELL rasters or the range maximum
for CELL Byte, UInt16 and Uint32 rasters (with no negative values), and an
attempt is made to set NODATA to the upper Int16 and Int32 range if the
lower range is occupied; otherwise an integer NODATA value (required to be
integer by GRASS r.out.bin).</p>
</td></tr>
<tr><td><code id="read_RAST_+3A_return_format">return_format</code></td>
<td>
<p>default <code>terra</code>, optionally <code>SGDF</code>.</p>
</td></tr>
<tr><td><code id="read_RAST_+3A_close_ok">close_OK</code></td>
<td>
<p>default TRUE - clean up possible open connections used for
reading metadata; may be set to FALSE to avoid the side-effect of other
user-opened connections being broken.</p>
</td></tr>
<tr><td><code id="read_RAST_+3A_flags">flags</code></td>
<td>
<p>default NULL, character vector, for example <code>overwrite</code>.</p>
</td></tr>
<tr><td><code id="read_RAST_+3A_sys_ignore.stdout">Sys_ignore.stdout</code></td>
<td>
<p>Passed to <code>system</code>.</p>
</td></tr>
<tr><td><code id="read_RAST_+3A_ignore.stderr">ignore.stderr</code></td>
<td>
<p>default taking the value set by
<code>set.ignore.stderrOption</code>; can be set to TRUE to silence
<code>system()</code> output to standard error; does not apply on Windows
platforms.</p>
</td></tr>
<tr><td><code id="read_RAST_+3A_x">x</code></td>
<td>
<p>A terra <code><a href="terra.html#topic+SpatRaster-class">terra::SpatRaster</a></code> or sp <code><a href="sp.html#topic+SpatialGridDataFrame">sp::SpatialGridDataFrame</a></code>
object,</p>
</td></tr>
<tr><td><code id="read_RAST_+3A_zcol">zcol</code></td>
<td>
<p>Attribute column number or name,</p>
</td></tr>
<tr><td><code id="read_RAST_+3A_overwrite">overwrite</code></td>
<td>
<p>default FALSE, if TRUE inserts &quot;overwrite&quot; into the value of
the flags argument if not already there to allow existing GRASS rasters to
be overwritten,</p>
</td></tr>
<tr><td><code id="read_RAST_+3A_verbose">verbose</code></td>
<td>
<p>default TRUE, report how writing to GRASS is specified,</p>
</td></tr>
</table>


<h3>Value</h3>

<p>by default returns a SpatRaster object, but may return a legacy
SpatialGridDataFrame object if <code>return_format="SGDF"</code>.
<code>write_RAST</code> silently returns the object being written to GRASS.
</p>


<h3>Author(s)</h3>

<p>Roger S. Bivand, e-mail: <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Run example only if GRASS settings file indicates that the
# nc_basic_spm_grass7 location is active
run &lt;- FALSE
GISRC &lt;- Sys.getenv("GISRC")

if (nchar(GISRC) &gt; 0) {
  location_name &lt;- read.dcf(GISRC)[1, "LOCATION_NAME"]
  if (location_name == "nc_basic_spm_grass7") {
    run &lt;- TRUE
  }
}

# store original environment variables before modifying
GV &lt;- Sys.getenv("GRASS_VERBOSE")
Sys.setenv("GRASS_VERBOSE" = 0)
original_ignore_stderr &lt;- get.ignore.stderrOption()
set.ignore.stderrOption(TRUE)

if (run) {
  # Retrieve GRASS metadata and creata a new mapset
  meta &lt;- gmeta()
  location_path &lt;- file.path(meta$GISDBASE, meta$LOCATION_NAME)
  previous_mapset &lt;- meta$MAPSET
  example_mapset &lt;- "RGRASS_EXAMPLES"
  execGRASS("g.mapset", flags = "c", mapset = example_mapset)
}

if (run) {
  # List available mapsets and raster maps
  mapsets &lt;- unlist(
    strsplit(execGRASS("g.mapsets", flags = "p", intern = TRUE), " ")
  )
  print(mapsets)
}

if (run) {
  execGRASS("g.list", type = "raster", pattern = "soils", flags = "m",
            intern = TRUE)
}

if (run) {
  execGRASS("g.list", type = "raster", pattern = "soils@PERMANENT",
            mapset = ".", flags = "m", intern = TRUE)
}

if (run) {
  execGRASS("g.list", type = "raster", pattern = "soils",
            mapset = "PERMANENT", flags = "m", intern = TRUE)
}
# Read/write the GRASS "landuse" dataset as a SpatRaster
if (require("terra", quietly = TRUE)) {
 if (run) {
  v1 &lt;- read_RAST("landuse", cat = TRUE, return_format = "terra")
  print(v1)
  print(inMemory(v1))
 }

 if (run) {
  write_RAST(v1, "landuse1", flags = c("o", "overwrite"))
  execGRASS("r.stats", flags = "c", input = "landuse1")
  execGRASS("g.remove", flags = "f", name = "landuse1", type = "raster")
 }
}

# read the geology and elevation GRASS datasets as SpatialGridDataFrames
if (require("sp", quietly = TRUE)) {
 if (run) {
  nc_basic &lt;- read_RAST(c("geology", "elevation"), cat = c(TRUE, FALSE),
                        return_format = "SGDF")
  print(table(nc_basic$geology))
 }

 if (run) {
  execGRASS("r.stats", flags = c("c", "l", "quiet"), input = "geology")
  boxplot(nc_basic$elevation ~ nc_basic$geology)
 }
 if (run) {
 # Compute square root of elevation and write back to GRASS
  nc_basic$sqdem &lt;- sqrt(nc_basic$elevation)
  write_RAST(nc_basic, "sqdemSP", zcol = "sqdem",
             flags = c("quiet", "overwrite"))
  execGRASS("r.info", map = "sqdemSP")
 }

 if (run) {
  # Read the new raster data and measure read times
  print(system.time(
    sqdemSP &lt;- read_RAST(c("sqdemSP", "elevation"), return_format = "SGDF")
  ))
 }

 if (run) {
  print(system.time(
    sqdem &lt;- read_RAST(c("sqdemSP", "elevation"), return_format = "terra"))
  )
 }

 if (run) {
  print(names(sqdem))
 }

 if (run) {
  sqdem1 &lt;- read_RAST(c("sqdemSP@RGRASS_EXAMPLES", "elevation@PERMANENT"))
  print(names(sqdem1))
 }

 if (run) {
  execGRASS("g.remove", flags = "f", name = "sqdemSP", type = "raster")

  # GRASS r.mapcalc example
  execGRASS("r.mapcalc", expression = "basins0 = basins - 1",
            flags = "overwrite")
  execGRASS("r.stats", flags = "c", input = "basins0")
 }

 if (run) {
  basins0 &lt;- read_RAST("basins0", return_format = "SGDF")
  print(table(basins0$basins0))
  execGRASS("g.remove", flags = "f", name = "basins0", type = "raster")
 }

 if (run) {
  # Create and read a test raster
  execGRASS("r.mapcalc", expression = "test_t = 66000",
            flags = "overwrite")
  execGRASS("r.info", flags = "r", map = "test_t", intern = TRUE)
  tt &lt;- read_RAST("test_t")
  execGRASS("g.remove", flags = "f", name = "test_t", type = "raster")
 }
}

if (run) {
  # Restore the previous mapset and clean up
  execGRASS("g.mapset", mapset = previous_mapset)
  if (example_mapset != previous_mapset) {
    unlink(file.path(location_path, example_mapset), recursive = TRUE)
  }
}

# Restore original GRASS settings
Sys.setenv("GRASS_VERBOSE" = GV)
set.ignore.stderrOption(original_ignore_stderr)
</code></pre>

<hr>
<h2 id='read_VECT'>Read and write GRASS vector object files</h2><span id='topic+read_VECT'></span><span id='topic+write_VECT'></span><span id='topic+vInfo'></span><span id='topic+vColumns'></span><span id='topic+vDataCount'></span><span id='topic+vect2neigh'></span>

<h3>Description</h3>

<p><code>read_VECT</code> moves one GRASS vector object file with attribute data
through a temporary GeoPackage file to a <code><a href="terra.html#topic+SpatVector-class">terra::SpatVector</a></code>
object; <code>write_VECT</code> moves a <code><a href="terra.html#topic+SpatVector-class">terra::SpatVector</a></code> object
through a temporary GeoPackage file to a GRASS vector object file.
<code>vect2neigh</code> returns neighbour pairs with shared boundary length as
described by Markus Neteler, in
<a href="https://stat.ethz.ch/pipermail/r-sig-geo/2005-October/000616.html">https://stat.ethz.ch/pipermail/r-sig-geo/2005-October/000616.html</a>.
<code>cygwin_clean_temp</code> can be called to try to clean the GRASS
mapset-specific temporary directory under cygwin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_VECT(
  vname,
  layer = "",
  proxy = FALSE,
  use_gdal_grass_driver = TRUE,
  type = NULL,
  flags = "overwrite",
  Sys_ignore.stdout = FALSE,
  ignore.stderr = get.ignore.stderrOption()
)

write_VECT(
  x,
  vname,
  flags = "overwrite",
  ignore.stderr = get.ignore.stderrOption()
)

vInfo(vname, layer, ignore.stderr = NULL)

vColumns(vname, layer, ignore.stderr = NULL)

vDataCount(vname, layer, ignore.stderr = NULL)

vect2neigh(
  vname,
  ID = NULL,
  ignore.stderr = NULL,
  remove = TRUE,
  vname2 = NULL,
  units = "k"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_VECT_+3A_vname">vname</code></td>
<td>
<p>A GRASS vector file name.</p>
</td></tr>
<tr><td><code id="read_VECT_+3A_layer">layer</code></td>
<td>
<p>a layer name (string); if missing the first layer will be used.</p>
</td></tr>
<tr><td><code id="read_VECT_+3A_proxy">proxy</code></td>
<td>
<p>Default is <code>FALSE</code>. Set as <code>TRUE</code> if you need a
<code>SpatVectorProxy</code> object.</p>
</td></tr>
<tr><td><code id="read_VECT_+3A_use_gdal_grass_driver">use_gdal_grass_driver</code></td>
<td>
<p>Default <code>TRUE</code>. The
<a href="https://github.com/OSGeo/gdal-grass">standalone GDAL-GRASS driver</a>
for the vector format will be used if it is installed. The advantage is
that no intermediate file needs to be written from GRASS GIS and
subsequently read into R; instead the vector layer is read directly from
the GRASS GIS database. Please read the <strong>Note</strong> further below!.</p>
</td></tr>
<tr><td><code id="read_VECT_+3A_type">type</code></td>
<td>
<p>override type detection when multiple types are non-zero, passed
to v.out.ogr.</p>
</td></tr>
<tr><td><code id="read_VECT_+3A_flags">flags</code></td>
<td>
<p>Character vector containing additional optional flags and/or
options for v.in.ogr, particularly &quot;o&quot; and &quot;overwrite&quot;.</p>
</td></tr>
<tr><td><code id="read_VECT_+3A_sys_ignore.stdout">Sys_ignore.stdout</code></td>
<td>
<p>Passed to <code>system</code>.</p>
</td></tr>
<tr><td><code id="read_VECT_+3A_ignore.stderr">ignore.stderr</code></td>
<td>
<p>default the value set by <code>set.ignore.stderrOption</code>;
NULL, taking the value set by <code>set.ignore.stderrOption</code>, can be set to
TRUE to silence <code>system()</code> output to standard error; does not apply on
Windows platforms.</p>
</td></tr>
<tr><td><code id="read_VECT_+3A_x">x</code></td>
<td>
<p>A <code>SpatVector</code> object moved to GRASS.</p>
</td></tr>
<tr><td><code id="read_VECT_+3A_id">ID</code></td>
<td>
<p>A valid DB column name for unique identifiers (optional).</p>
</td></tr>
<tr><td><code id="read_VECT_+3A_remove">remove</code></td>
<td>
<p>default TRUE, remove copied vectors created in
<code>vect2neigh</code>.</p>
</td></tr>
<tr><td><code id="read_VECT_+3A_vname2">vname2</code></td>
<td>
<p>If on a previous run, remove was FALSE, the name of the
temporary vector may be given to circumvent its generation.</p>
</td></tr>
<tr><td><code id="read_VECT_+3A_units">units</code></td>
<td>
<p>default &quot;k&quot;; see GRASS 'v.to.db' manual page for alternatives.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>read_VECT</code> imports a GRASS vector layer into a <code>SpatVector</code> or
<code>SpatVectorProxy</code> object.
<code>vect2neigh</code> returns a data frame object with left and right
neighbours and boundary lengths, also given class GRASSneigh and
spatial.neighbour (as used in spdep). The incantation to retrieve the
neighbours list is <code>sn2listw(vect2neigh())$neighbours</code>, and to
retrieve the boundary lengths: <code>sn2listw(vect2neigh())$weights</code>. The
GRASSneigh object has two other useful attributes: external is a vector
giving the length of shared boundary between each polygon and the external
area, and total giving each polygon's total boundary length.
</p>


<h3>Note</h3>

<p>Be aware that the GDAL-GRASS driver may have some
<a href="https://github.com/OSGeo/gdal-grass/issues">issues</a> for vector data. In
our experience, the error and warning messages for vector data can be
ignored. Further, the returned metadata about the coordinate reference system
may currently be incomplete, e.g. it may miss the EPSG code.
</p>


<h3>Author(s)</h3>

<p>Roger S. Bivand, e-mail: <a href="mailto:Roger.Bivand@nhh.no">Roger.Bivand@nhh.no</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Run example if in active GRASS nc_basic_spm_grass7 location
run &lt;- FALSE
if (nchar(Sys.getenv("GISRC")) &gt; 0 &amp;&amp;
    read.dcf(Sys.getenv("GISRC"))[1, "LOCATION_NAME"] == "nc_basic_spm_grass7") {
  run &lt;- require(terra, quietly = TRUE)
}

# Store original environment variable settings
GV &lt;- Sys.getenv("GRASS_VERBOSE")
Sys.setenv("GRASS_VERBOSE" = 0)
ois &lt;- get.ignore.stderrOption()
set.ignore.stderrOption(TRUE)

if (run) {
  # Create a new mapset
  meta &lt;- gmeta()
  location_path &lt;- file.path(meta$GISDBASE, meta$LOCATION_NAME)
  previous_mapset &lt;- meta$MAPSET
  example_mapset &lt;- "RGRASS_EXAMPLES"
  execGRASS("g.mapset", "c", mapset = example_mapset)
 }

if (run) {
  # Report basic metadata about the schools dataset
  execGRASS("v.info", map = "schools", layer = "1")
  print(vInfo("schools"))
 }

if (run) {
  # Read/write as a SpatVector
  schs &lt;- read_VECT("schools")
  print(summary(schs))
 }

if (run) {
  try({
    write_VECT(schs, "newsch", flags = c("o", "overwrite"))
  })
  schs &lt;- read_VECT("schools", use_gdal_grass_driver = FALSE)
 }

if (run) {
  write_VECT(schs, "newsch", flags = c("o", "overwrite"))
  execGRASS("v.info", map = "newsch", layer = "1")
 }

if (run) {
  nschs &lt;- read_VECT("newsch")
  print(summary(nschs))
 }

if (run) {
  print(all.equal(names(nschs), as.character(vColumns("newsch")[, 2])))
 }

if (run) {
  # Show metadata for the roadsmajor dataset and read as spatVector
  print(vInfo("roadsmajor"))
 }

if (run) {
  roads &lt;- read_VECT("roadsmajor")
  print(summary(roads))
}

# not run: vect2neigh() currently writes 3 new data sources in the PERMANENT
# mapset, despite this mapset not being the active one.
if (FALSE) {
  cen_neig &lt;- vect2neigh("census")
  str(cen_neig)
}

# Cleanup the previously created datasets
if (run) {
  execGRASS(
    "g.remove",
    flags = "f",
    name = c("newsch", "newsch1"),
    type = "vector"
  )
  execGRASS("g.mapset", mapset = previous_mapset)
  if (example_mapset != previous_mapset) {
    unlink(file.path(location_path, example_mapset), recursive = TRUE)
  }
}

# Restore environment variable settings
Sys.setenv("GRASS_VERBOSE" = GV)
set.ignore.stderrOption(ois)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
