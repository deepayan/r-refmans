<!DOCTYPE html><html lang="en"><head><title>Help for package multidplyr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {multidplyr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#multidplyr-package'><p>multidplyr: A Multi-Process 'dplyr' Backend</p></a></li>
<li><a href='#cluster_call'><p>Call a function on each node of a cluster</p></a></li>
<li><a href='#cluster_utils'><p>Cluster utitility functions</p></a></li>
<li><a href='#default_cluster'><p>Default cluster</p></a></li>
<li><a href='#new_cluster'><p>Create a new cluster with sensible defaults.</p></a></li>
<li><a href='#partition'><p>Partition data across workers in a cluster</p></a></li>
<li><a href='#party_df'><p>A 'party_df' partitioned data frame</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>A Multi-Process 'dplyr' Backend</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Partition a data frame across multiple worker processes to
    provide simple multicore parallelism.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://multidplyr.tidyverse.org">https://multidplyr.tidyverse.org</a>,
<a href="https://github.com/tidyverse/multidplyr">https://github.com/tidyverse/multidplyr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tidyverse/multidplyr/issues">https://github.com/tidyverse/multidplyr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>callr (&ge; 3.5.1), cli, crayon, dplyr (&ge; 1.0.0), magrittr, qs
(&ge; 0.24.1), R6, rlang (&ge; 1.0.6), tibble, tidyselect, vctrs
(&ge; 0.3.6)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, knitr, lubridate, mgcv, nycflights13, rmarkdown,
testthat (&ge; 3.0.2), vroom, withr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>tidyverse/tidytemplate</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-21 15:00:55 UTC; hadleywickham</td>
</tr>
<tr>
<td>Author:</td>
<td>Hadley Wickham [aut, cre],
  Posit Software, PBC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hadley Wickham &lt;hadley@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-22 13:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='multidplyr-package'>multidplyr: A Multi-Process 'dplyr' Backend</h2><span id='topic+multidplyr'></span><span id='topic+multidplyr-package'></span>

<h3>Description</h3>

<p>Partition a data frame across multiple worker processes to provide simple multicore parallelism.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Hadley Wickham <a href="mailto:hadley@posit.co">hadley@posit.co</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Posit Software, PBC [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://multidplyr.tidyverse.org">https://multidplyr.tidyverse.org</a>
</p>
</li>
<li> <p><a href="https://github.com/tidyverse/multidplyr">https://github.com/tidyverse/multidplyr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/tidyverse/multidplyr/issues">https://github.com/tidyverse/multidplyr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='cluster_call'>Call a function on each node of a cluster</h2><span id='topic+cluster_call'></span><span id='topic+cluster_send'></span>

<h3>Description</h3>

<p>'cluster_call()' executes the code on each worker and returns the results;
'cluster_send()' executes the code ignoring the result. Jobs are submitted
to workers in parallel, and then we wait until they're complete.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_call(cluster, code, simplify = FALSE, ptype = NULL)

cluster_send(cluster, code)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cluster_call_+3A_cluster">cluster</code></td>
<td>
<p>A cluster.</p>
</td></tr>
<tr><td><code id="cluster_call_+3A_code">code</code></td>
<td>
<p>An expression to execute on each worker.</p>
</td></tr>
<tr><td><code id="cluster_call_+3A_simplify">simplify</code></td>
<td>
<p>Should the results be simplified from a list?
* 'TRUE': simplify or die trying.
* 'NA': simplify if possible.
* 'FALSE': never try to simplify, always leaving as a list.
</p>
<p>'code' must return a vector of length one in order for simplification
to succeed.</p>
</td></tr>
<tr><td><code id="cluster_call_+3A_ptype">ptype</code></td>
<td>
<p>If 'simplify' is 'TRUE', use 'ptype' to enforce the desired
output type.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of results with one element for each worker in 'cluster'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cl &lt;- default_cluster()

# Run code on each cluster and retrieve results
cluster_call(cl, Sys.getpid())
cluster_call(cl, runif(1))

# use ptype to simplify
cluster_call(cl, runif(1), simplify = TRUE)

# use cluster_send() to ignore results
cluster_send(cl, x &lt;- runif(1))
cluster_call(cl, x, simplify = TRUE)
</code></pre>

<hr>
<h2 id='cluster_utils'>Cluster utitility functions</h2><span id='topic+cluster_utils'></span><span id='topic+cluster_assign'></span><span id='topic+cluster_assign_each'></span><span id='topic+cluster_assign_partition'></span><span id='topic+cluster_copy'></span><span id='topic+cluster_rm'></span><span id='topic+cluster_library'></span>

<h3>Description</h3>

<p>These functions provide useful helpers for performaning common operations.
'cluster_assign()' assigns the same value on each worker;
'cluster_assign_each()' assigns different values on each worker;
'cluster_assign_partition()' partitions vectors so that each worker gets
(approximately) the same number of pieces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_assign(.cluster, ...)

cluster_assign_each(.cluster, ...)

cluster_assign_partition(.cluster, ...)

cluster_copy(cluster, names, env = caller_env())

cluster_rm(cluster, names)

cluster_library(cluster, packages)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cluster_utils_+3A_...">...</code></td>
<td>
<p>Name-value pairs</p>
</td></tr>
<tr><td><code id="cluster_utils_+3A_cluster">cluster</code>, <code id="cluster_utils_+3A_.cluster">.cluster</code></td>
<td>
<p>Cluster to work on</p>
</td></tr>
<tr><td><code id="cluster_utils_+3A_names">names</code></td>
<td>
<p>Name of variables to copy.</p>
</td></tr>
<tr><td><code id="cluster_utils_+3A_env">env</code></td>
<td>
<p>Environment in which to look for varibles to copy.</p>
</td></tr>
<tr><td><code id="cluster_utils_+3A_packages">packages</code></td>
<td>
<p>Character vector of packages to load</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Functions that modify the worker environment invisibly return
'cluster' so calls can be piped together. The other functions return
lists with one element for each worker.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cl &lt;- default_cluster()
cluster_assign(cl, a = runif(1))
cluster_call(cl, a)

# Assign different values on each cluster
cluster_assign_each(cl, b = c(1, 10))
cluster_call(cl, b)

# Partition a vector so that each worker gets approximately the
# same amount of it
cluster_assign_partition(cl, c = 1:11)
cluster_call(cl, c)

# If you want different to compute different values on each
# worker, use `cluster_call()` directly:
cluster_call(cl, d &lt;- runif(1))
cluster_call(cl, d)

# cluster_copy() is a useful shortcut
e &lt;- 10
cluster_copy(cl, "e")

cluster_call(cl, ls())
cluster_rm(cl, letters[1:5])
cluster_call(cl, ls())

# Use cluster_library() to load packages
cluster_call(cl, search())
cluster_library(cl, "magrittr")
cluster_call(cl, search())
</code></pre>

<hr>
<h2 id='default_cluster'>Default cluster</h2><span id='topic+default_cluster'></span>

<h3>Description</h3>

<p>Setting up a cluster is relatively expensive, so it's best to use a single
cluster throughout a session. This function lazily creates a 2-worker
cluster for use in examples and test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_cluster(n = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="default_cluster_+3A_n">n</code></td>
<td>
<p>Number of workers to use; defaults to 2 because this is the maximum
allowed by CRAN.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cached cluster of workers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>default_cluster()
</code></pre>

<hr>
<h2 id='new_cluster'>Create a new cluster with sensible defaults.</h2><span id='topic+new_cluster'></span>

<h3>Description</h3>

<p>Clusters created with this function will automatically clean up after
themselves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_cluster(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_cluster_+3A_n">n</code></td>
<td>
<p>Number of workers to create. Avoid setting this higher than the
number of cores in your computer as it will degrade performance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'multidplyr_cluster' object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cluster &lt;- new_cluster(2)
cluster
</code></pre>

<hr>
<h2 id='partition'>Partition data across workers in a cluster</h2><span id='topic+partition'></span>

<h3>Description</h3>

<p>Partitioning ensures that all observations in a group end up on the same
worker. To try and keep the observations on each worker balanced,
'partition()' uses a greedy algorithm that iteratively assigns each group to
the worker that currently has the fewest rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partition(data, cluster)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="partition_+3A_data">data</code></td>
<td>
<p>Dataset to partition, typically grouped. When grouped, all
observations in a group will be assigned to the same cluster.</p>
</td></tr>
<tr><td><code id="partition_+3A_cluster">cluster</code></td>
<td>
<p>Cluster to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A [party_df].
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
cl &lt;- default_cluster()
cluster_library(cl, "dplyr")

mtcars2 &lt;- partition(mtcars, cl)
mtcars2 %&gt;% mutate(cyl2 = 2 * cyl)
mtcars2 %&gt;% filter(vs == 1)
mtcars2 %&gt;% group_by(cyl) %&gt;% summarise(n())
mtcars2 %&gt;% select(-cyl)
</code></pre>

<hr>
<h2 id='party_df'>A 'party_df' partitioned data frame</h2><span id='topic+party_df'></span>

<h3>Description</h3>

<p>This S3 class represents a data frame partitioned across workers in a
cluster. You can use this constructor if you have already spread
data frames spread across a cluster. If not, start with [partition()]
instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>party_df(cluster, name, auto_rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="party_df_+3A_cluster">cluster</code></td>
<td>
<p>A cluster</p>
</td></tr>
<tr><td><code id="party_df_+3A_name">name</code></td>
<td>
<p>Name of data frame variable. Must exist on every worker,
be a data frame, and have the same names.</p>
</td></tr>
<tr><td><code id="party_df_+3A_auto_rm">auto_rm</code></td>
<td>
<p>If 'TRUE', will automatically 'rm()' the data frame on
the workers when this object is created.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object with class 'multidplyr_party_df'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># If a real example, you might spread file names across the clusters
# and read in using data.table::fread()/vroom::vroom()/qs::qread().
cl &lt;- default_cluster()
cluster_send(cl[1], n &lt;- 10)
cluster_send(cl[2], n &lt;- 15)
cluster_send(cl, df &lt;- data.frame(x = runif(n)))

df &lt;- party_df(cl, "df")
df
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>magrittr</dt><dd><p><code><a href="magrittr.html#topic+pipe">%&gt;%</a></code></p>
</dd>
</dl>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
