<!DOCTYPE html><html><head><title>Help for package latte</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {latte}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#latte'><p>R Interface to LattE and 4ti2</p></a></li>
<li><a href='#genmodel'><p>Generate a configuration matrix</p></a></li>
<li><a href='#kprod'><p>Iterated Kronecker product</p></a></li>
<li><a href='#latte-count'><p>Count integer points in a polytope</p></a></li>
<li><a href='#latte-files'><p>Format/read/write a matrix in latte's style</p></a></li>
<li><a href='#latte-optim'><p>Solve an integer progam with LattE</p></a></li>
<li><a href='#lattice-bases'><p>Compute a basis with 4ti2</p></a></li>
<li><a href='#ones'><p>Ones</p></a></li>
<li><a href='#pathing'><p>Set paths to LattE and 4ti2 executables</p></a></li>
<li><a href='#plot-matrix'><p>Plot a matrix</p></a></li>
<li><a href='#ppi'><p>Compute the primitive partition identities</p></a></li>
<li><a href='#print.tableau'><p>Pretty printing of tableau output.</p></a></li>
<li><a href='#qsolve'><p>Solve a linear system over the rationals</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#tab2vec'><p>Array to vector conversion</p></a></li>
<li><a href='#tableau'><p>Tableau Notation for Markov</p></a></li>
<li><a href='#vec2tab'><p>Vector to array conversion</p></a></li>
<li><a href='#zsolve'><p>Solve a linear system over the integers</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Interface to 'LattE' and '4ti2'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Kahle &lt;david@kahle.io&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Back-end connections to 'LattE' (<a href="https://www.math.ucdavis.edu/~latte">https://www.math.ucdavis.edu/~latte</a>) 
	for counting lattice points and integration inside convex polytopes and 
	'4ti2' (<a href="http://www.4ti2.de/">http://www.4ti2.de/</a>) for algebraic, geometric, and combinatorial 
	problems on linear spaces and front-end tools facilitating their use in the 
	'R' ecosystem.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/dkahle/latte">https://github.com/dkahle/latte</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/dkahle/latte/issues">https://github.com/dkahle/latte/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>LattE &lt;https://www.math.ucdavis.edu/~latte/&gt;, 4ti2
&lt;http://www.4ti2.de/&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>magrittr, stringr, mpoly, ggplot2, memoise, dplyr, usethis,
glue</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-03-22 00:34:52 UTC; david_kahle</td>
</tr>
<tr>
<td>Author:</td>
<td>David Kahle <a href="https://orcid.org/0000-0002-9999-1558"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cph, cre],
  Luis Garcia [aut, cph],
  Ruriko Yoshida [aut, cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-03-25 10:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='latte'>R Interface to LattE and 4ti2</h2><span id='topic+latte'></span><span id='topic+package-latte'></span><span id='topic+latte-package'></span>

<h3>Description</h3>

<p>Back-end connections to LattE (<a href="https://www.math.ucdavis.edu/~latte/">https://www.math.ucdavis.edu/~latte/</a>)
and 4ti2 (<a href="http://www.4ti2.de/">http://www.4ti2.de/</a>) executables and front-end tools
facilitating their use in the R ecosystem.
</p>

<hr>
<h2 id='genmodel'>Generate a configuration matrix</h2><span id='topic+genmodel'></span>

<h3>Description</h3>

<p>genmodel runs 4ti2's genmodel program to compute the configuration matrix A
corresponding to graphical statistical models given by a simplicial complex
and levels on the nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genmodel(varlvls, facets, dir = tempdir(), quiet = TRUE,
  shell = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genmodel_+3A_varlvls">varlvls</code></td>
<td>
<p>a vector containing the number of levels of each variable</p>
</td></tr>
<tr><td><code id="genmodel_+3A_facets">facets</code></td>
<td>
<p>the facets generating the hierarchical model, a list of vectors
of variable indices</p>
</td></tr>
<tr><td><code id="genmodel_+3A_dir">dir</code></td>
<td>
<p>Directory to place the files in, without an ending /</p>
</td></tr>
<tr><td><code id="genmodel_+3A_quiet">quiet</code></td>
<td>
<p>If FALSE, messages the 4ti2 output</p>
</td></tr>
<tr><td><code id="genmodel_+3A_shell">shell</code></td>
<td>
<p>Messages the shell code used to do the computation</p>
</td></tr>
<tr><td><code id="genmodel_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to the function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The configuration matrix of the model provided
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (has_4ti2()) {

varlvls &lt;- rep(2, 2)
facets &lt;- list(1, 2)
genmodel(varlvls, facets)
genmodel(varlvls, facets, quiet = FALSE)

varlvls &lt;- rep(3, 3)
facets &lt;- list(1:2, 2:3, c(3,1))
genmodel(varlvls, facets)

# compare this to algstat's hmat function

}

</code></pre>

<hr>
<h2 id='kprod'>Iterated Kronecker product</h2><span id='topic+kprod'></span>

<h3>Description</h3>

<p>Compute the Kronecker product of several matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kprod(..., FUN = `*`)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kprod_+3A_...">...</code></td>
<td>
<p>A listing of matrices</p>
</td></tr>
<tr><td><code id="kprod_+3A_fun">FUN</code></td>
<td>
<p>A function to pass to <code><a href="base.html#topic+kronecker">kronecker()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If kronecker is  the function that computes A x B, kprod computes A x B x C
and so on; it's a wrapper of Reduce and kronecker.
</p>


<h3>Value</h3>

<p>A matrix that is the kronecker product of the specified matrices
(from left to right).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
kprod(diag(2), t(ones(2)))
kprod(t(ones(2)), diag(2))


kprod(diag(2), t(ones(2)), t(ones(2)))
kprod(t(ones(2)), diag(2), t(ones(2)))
kprod(t(ones(2)), t(ones(2)), diag(2))


# cf. aoki, hara, and takemura p.13
rbind(
  kprod(diag(2), t(ones(2))),
  kprod(t(ones(2)), diag(2))
) 


</code></pre>

<hr>
<h2 id='latte-count'>Count integer points in a polytope</h2><span id='topic+latte-count'></span><span id='topic+count_core'></span><span id='topic+latte_count'></span><span id='topic+latte_fcount'></span>

<h3>Description</h3>

<p><code>latte_count</code> uses LattE's count function to count the (integer) lattice
points in a polytope and compute Ehrhart polynomials.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_core(spec, dir = tempdir(), quiet = TRUE, mpoly = TRUE, ...)

latte_count(spec, dir = tempdir(), quiet = TRUE, mpoly = TRUE, ...)

latte_fcount(spec, dir = tempdir(), quiet = TRUE, mpoly = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="latte-count_+3A_spec">spec</code></td>
<td>
<p>Specification, see details and examples</p>
</td></tr>
<tr><td><code id="latte-count_+3A_dir">dir</code></td>
<td>
<p>Directory to place the files in, without an ending /</p>
</td></tr>
<tr><td><code id="latte-count_+3A_quiet">quiet</code></td>
<td>
<p>Show latte output?</p>
</td></tr>
<tr><td><code id="latte-count_+3A_mpoly">mpoly</code></td>
<td>
<p>When opts = &quot;&ndash;ehrhart-polynomial&quot;, return the mpoly version of
it</p>
</td></tr>
<tr><td><code id="latte-count_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to the function, see count &ndash;help at
the command line to see examples.  Note that dashes - should be specified
with underscores _</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The specification should be one of the following: (1) a character string or
strings containing an inequality in the mpoly expression format (see
examples), (2) a list of vertices, (3) a list of A and b for the equation Ax
&lt;= b (see examples), or (4) raw code for LattE's count program. If a
character vector is supplied, (1) and (4) are distinguished by the number of
strings.
</p>
<p>Behind the scenes, count works by writing a latte file and running count on
it.  If a specification other than a length one character is given to it
(which is considered to be the code), count attempts to convert it into LattE
code and then run count on it.
</p>


<h3>Value</h3>

<p>The count.  If the count is a number has less than 10 digits, an
integer is returned.  If the number has 10 or more digits, an integer in a
character string is returned. You may want to use the gmp package's as.bigz
to parse it.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (has_latte()) {

spec &lt;- c("x + y &lt;= 10", "x &gt;= 1", "y &gt;= 1")
latte_count(spec) # 45
latte_count(spec, quiet = FALSE) # 45
latte_count(spec, dilation = 10) # 3321
latte_count(spec, homog = TRUE) # 45

# by default, the output from LattE is in
list.files(tempdir())
list.files(tempdir(), recursive = TRUE)

# ehrhart polynomials
latte_count(spec, ehrhart_polynomial = TRUE)
latte_count(spec, ehrhart_polynomial = TRUE, mpoly = FALSE)

# ehrhart series (raw since mpoly can't handle rational functions)
latte_count(spec, ehrhart_series = TRUE)

# simplified ehrhart series - not yet implemented
#latte_count(spec, simplified_ehrhart_polynomial = TRUE)

# first terms of the ehrhart series
latte_count(spec, ehrhart_taylor = 1)
latte_count(spec, ehrhart_taylor = 2)
latte_count(spec, ehrhart_taylor = 3)
latte_count(spec, ehrhart_taylor = 4)

# multivariate generating function
latte_count(spec, multivariate_generating_function = TRUE)


# by vertices
spec &lt;- list(c(1,1), c(10,1), c(1,10), c(10,10))
latte_count(spec)
latte_count(spec, vrep = TRUE)

code &lt;- "
5 3
1 -1  0
1  0 -1
1 -1 -1
0  1  0
0  0  1
"
latte_count(code)


# for Ax &lt;= b, see this example from the latte manual p.10
A &lt;- matrix(c(
   1,  0,
   0,  1,
   1,  1,
  -1,  0,
   0, -1
), nrow = 5, byrow = TRUE)
b &lt;- c(1, 1, 1, 0, 0)
latte_count(list(A = A, b = b))









}


</code></pre>

<hr>
<h2 id='latte-files'>Format/read/write a matrix in latte's style</h2><span id='topic+latte-files'></span><span id='topic+format_latte'></span><span id='topic+write_latte'></span><span id='topic+write.latte'></span><span id='topic+read_latte'></span><span id='topic+read.latte'></span>

<h3>Description</h3>

<p><code><a href="#topic+format_latte">format_latte()</a></code> formats a matrix in latte's style.
<code><a href="#topic+write_latte">write_latte()</a></code> writes a latte-formatted file to file.
<code><a href="#topic+read_latte">read_latte()</a></code> reads a latte-formatted file from disk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_latte(mat, file)

write_latte(mat, file)

write.latte(mat, file)

read_latte(file, format = c("mat", "Ab"))

read.latte(file, format = c("mat", "Ab"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="latte-files_+3A_mat">mat</code></td>
<td>
<p>A matrix</p>
</td></tr>
<tr><td><code id="latte-files_+3A_file">file</code></td>
<td>
<p>A filename</p>
</td></tr>
<tr><td><code id="latte-files_+3A_format">format</code></td>
<td>
<p>&quot;mat&quot; or &quot;Ab&quot;</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code><a href="#topic+format_latte">format_latte()</a></code> &ndash; A character string of the matrix in
latte format.
</p>
</li>
<li> <p><code><a href="#topic+write_latte">write_latte()</a></code> &ndash; An invisible character
string of the formatted output.
</p>
</li>
<li> <p><code><a href="#topic+read_latte">read_latte()</a></code> &ndash; An integer matrix.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>

(mat &lt;- matrix(sample(9), 3, 3))

format_latte(mat)
cat(format_latte(mat))

(file &lt;- file.path(tempdir(), "foo.hrep"))
write_latte(mat, file)
file.show(file)
read_latte(file)
read_latte(file, "Ab")

attr(mat, "linearity") &lt;- c(1, 3)
attr(mat, "nonnegative") &lt;- 2
mat
format_latte(mat)
cat(format_latte(mat))
write_latte(mat, file)
file.show(file)
read_latte(file)

file.remove(file)



</code></pre>

<hr>
<h2 id='latte-optim'>Solve an integer progam with LattE</h2><span id='topic+latte-optim'></span><span id='topic+latte_optim'></span><span id='topic+latte_max'></span><span id='topic+latte_min'></span>

<h3>Description</h3>

<p><code>latte_max</code> and <code>latte_min</code> use LattE's <code>latte-maximize</code> and
<code>latte-minimize</code> functions to find the maximum or minimum of a linear
objective function over the integers points in a polytope (i.e. satisfying
linearity constraints). This makes use of the digging algorithm; see the
LattE manual at <a href="http://www.math.ucdavis.edu/~latte">http://www.math.ucdavis.edu/~latte</a> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latte_optim(objective, constraints, type = c("max", "min"),
  method = c("lp", "cones"), dir = tempdir(), opts = "",
  quiet = TRUE, shell = FALSE)

latte_max(objective, constraints, method = c("lp", "cones"),
  dir = tempdir(), opts = "", quiet = TRUE)

latte_min(objective, constraints, method = c("lp", "cones"),
  dir = tempdir(), opts = "", quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="latte-optim_+3A_objective">objective</code></td>
<td>
<p>A linear polynomial to pass to <code><a href="mpoly.html#topic+mp">mp()</a></code>, see examples</p>
</td></tr>
<tr><td><code id="latte-optim_+3A_constraints">constraints</code></td>
<td>
<p>A collection of linear polynomial (in)equalities that
define the feasibility region, the integers in the polytope</p>
</td></tr>
<tr><td><code id="latte-optim_+3A_type">type</code></td>
<td>
<p><code>"max"</code> or <code>"min"</code></p>
</td></tr>
<tr><td><code id="latte-optim_+3A_method">method</code></td>
<td>
<p>Method <code>"LP"</code> or <code>"cones"</code></p>
</td></tr>
<tr><td><code id="latte-optim_+3A_dir">dir</code></td>
<td>
<p>Directory to place the files in, without an ending /</p>
</td></tr>
<tr><td><code id="latte-optim_+3A_opts">opts</code></td>
<td>
<p>Options; see the LattE manual at
<a href="http://www.math.ucdavis.edu/~latte">http://www.math.ucdavis.edu/~latte</a></p>
</td></tr>
<tr><td><code id="latte-optim_+3A_quiet">quiet</code></td>
<td>
<p>Show latte output</p>
</td></tr>
<tr><td><code id="latte-optim_+3A_shell">shell</code></td>
<td>
<p>Messages the shell code used to do the computation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with components <code>par</code>, a named-vector of optimizing
arguments, and <code>value</code>, the value of the objective function at the
optimial point.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

if (has_latte()) {

latte_max(
  "-2 x + 3 y", 
  c("x + y &lt;= 10", "x &gt;= 0", "y &gt;= 0")
)

latte_max(
  "-2 x + 3 y", 
  c("x + y &lt;= 10", "x &gt;= 0", "y &gt;= 0"),
  quiet = FALSE
)


df &lt;- expand.grid("x" = 0:10, "y" = 0:10)
df &lt;- subset(df, x + y &lt;= 10L)
df$objective &lt;- with(df, -2*x + 3*y)
library("ggplot2")
ggplot(df, aes(x, y, size = objective)) +
  geom_point()

latte_min(
  "-2 x + 3 y",
  c("x + y &lt;= 10", "x &gt;= 0", "y &gt;= 0"),
  method = "cones"
)



latte_min("-2 x - 3 y - 4 z", c(
  "3 x + 2 y + z &lt;= 10",
  "2 x + 5 y + 3 z &lt;= 15",
  "x &gt;= 0", "y &gt;= 0", "z &gt;= 0"
), "cones", quiet = FALSE)





}

</code></pre>

<hr>
<h2 id='lattice-bases'>Compute a basis with 4ti2</h2><span id='topic+lattice-bases'></span><span id='topic+basis'></span><span id='topic+zbasis'></span><span id='topic+markov'></span><span id='topic+groebner'></span><span id='topic+hilbert'></span><span id='topic+graver'></span><span id='topic+fzbasis'></span><span id='topic+fmarkov'></span><span id='topic+fgroebner'></span><span id='topic+fhilbert'></span><span id='topic+fgraver'></span>

<h3>Description</h3>

<p>4ti2 provides several executables that can be used to generate bases for a
configuration matrix A.  See the references for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basis(exec, memoise = TRUE)

zbasis(A, format = c("mat", "vec", "tab"), dim = NULL, all = FALSE,
  dir = tempdir(), quiet = TRUE, shell = FALSE, dbName = NULL, ...)

markov(A, format = c("mat", "vec", "tab"), dim = NULL, all = FALSE,
  dir = tempdir(), quiet = TRUE, shell = FALSE, dbName = NULL, ...)

groebner(A, format = c("mat", "vec", "tab"), dim = NULL, all = FALSE,
  dir = tempdir(), quiet = TRUE, shell = FALSE, dbName = NULL, ...)

hilbert(A, format = c("mat", "vec", "tab"), dim = NULL, all = FALSE,
  dir = tempdir(), quiet = TRUE, shell = FALSE, dbName = NULL, ...)

graver(A, format = c("mat", "vec", "tab"), dim = NULL, all = FALSE,
  dir = tempdir(), quiet = TRUE, shell = FALSE, dbName = NULL, ...)

fzbasis(A, format = c("mat", "vec", "tab"), dim = NULL, all = FALSE,
  dir = tempdir(), quiet = TRUE, shell = FALSE, dbName = NULL, ...)

fmarkov(A, format = c("mat", "vec", "tab"), dim = NULL, all = FALSE,
  dir = tempdir(), quiet = TRUE, shell = FALSE, dbName = NULL, ...)

fgroebner(A, format = c("mat", "vec", "tab"), dim = NULL,
  all = FALSE, dir = tempdir(), quiet = TRUE, shell = FALSE,
  dbName = NULL, ...)

fhilbert(A, format = c("mat", "vec", "tab"), dim = NULL, all = FALSE,
  dir = tempdir(), quiet = TRUE, shell = FALSE, dbName = NULL, ...)

fgraver(A, format = c("mat", "vec", "tab"), dim = NULL, all = FALSE,
  dir = tempdir(), quiet = TRUE, shell = FALSE, dbName = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lattice-bases_+3A_exec">exec</code></td>
<td>
<p>don't use this parameter</p>
</td></tr>
<tr><td><code id="lattice-bases_+3A_memoise">memoise</code></td>
<td>
<p>don't use this parameter</p>
</td></tr>
<tr><td><code id="lattice-bases_+3A_a">A</code></td>
<td>
<p>The configuration matrix</p>
</td></tr>
<tr><td><code id="lattice-bases_+3A_format">format</code></td>
<td>
<p>How the basis (moves) should be returned.  if &quot;mat&quot;, the moves
are returned as the columns of a matrix.</p>
</td></tr>
<tr><td><code id="lattice-bases_+3A_dim">dim</code></td>
<td>
<p>The dimension to be passed to <code><a href="#topic+vec2tab">vec2tab()</a></code> if format = &quot;tab&quot; is
used; a vector of the number of levels of each variable in order</p>
</td></tr>
<tr><td><code id="lattice-bases_+3A_all">all</code></td>
<td>
<p>If TRUE, all moves (+ and -) are given.  if FALSE, only the +
moves are given as returned by the executable.</p>
</td></tr>
<tr><td><code id="lattice-bases_+3A_dir">dir</code></td>
<td>
<p>Directory to place the files in, without an ending /</p>
</td></tr>
<tr><td><code id="lattice-bases_+3A_quiet">quiet</code></td>
<td>
<p>If FALSE, messages the 4ti2 output</p>
</td></tr>
<tr><td><code id="lattice-bases_+3A_shell">shell</code></td>
<td>
<p>Messages the shell code used to do the computation</p>
</td></tr>
<tr><td><code id="lattice-bases_+3A_dbname">dbName</code></td>
<td>
<p>The name of the model in the markov bases database,
http://markov-bases.de, see examples</p>
</td></tr>
<tr><td><code id="lattice-bases_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to the function, e.g. <code>p =
  "arb"</code> specifies the flag <code>-parb</code>; not setting this issues a common
warning</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix containing the Markov basis as its columns (for easy
addition to tables)
</p>


<h3>References</h3>

<p>Drton, M., B. Sturmfels, and S. Sullivant (2009). <em>Lectures
on Algebraic Statistics</em>, Basel: Birkhauser Verlag AG.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

if (has_4ti2()) {


# basic input and output for the 3x3 independence example
(A &lt;- rbind(
  kprod(diag(3), ones(1,3)),
  kprod(ones(1,3), diag(3))
))
markov(A, p = "arb")



# you can get the output formatted in different ways:
markov(A, p = "arb", all = TRUE)
markov(A, p = "arb", "vec")
markov(A, p = "arb", "tab", c(3, 3))
tableau(markov(A, p = "arb"), dim = c(3, 3)) # tableau notation



# you can add options by listing them off
# to see the options available to you by function,
# go to http://www.4ti2.de
markov(A, p = "arb")



# the basis functions are automatically cached for future use.
# (note that it doesn't persist across sessions.)
A &lt;- rbind(
  kprod(  diag(4), ones(1,4), ones(1,4)),
  kprod(ones(1,4),   diag(4), ones(1,4)),
  kprod(ones(1,4), ones(1,4),   diag(4))
)
system.time(markov(A, p = "arb"))
system.time(markov(A, p = "arb"))

# the un-cashed versions begin with an "f"
# (think: "forgetful" markov)
system.time(fmarkov(A, p = "arb"))
system.time(fmarkov(A, p = "arb"))



# you can see the command line code by typing shell = TRUE
# and the standard output wiht quiet = FALSE
# we illustrate these with fmarkov because otherwise it's cached
(A &lt;- rbind(
  kprod(diag(2), ones(1,4)),
  kprod(ones(1,4), diag(2))
))
fmarkov(A, p = "arb", shell = TRUE)
fmarkov(A, p = "arb", quiet = FALSE)



# compare the bases for the 3x3x3 no-three-way interaction model
A &lt;- rbind(
  kprod(  diag(3),   diag(3), ones(1,3)),
  kprod(  diag(3), ones(1,3),   diag(3)),
  kprod(ones(1,3),   diag(3),   diag(3))
)
str(  zbasis(A, p = "arb")) #    8 elements = ncol(A) - qr(A)$rank
str(  markov(A, p = "arb")) #   81 elements
str(groebner(A, p = "arb")) #  110 elements
str(  graver(A))            #  795 elements


# the other bases are also cached
A &lt;- rbind(
  kprod(  diag(3), ones(1,3), ones(1,2)),
  kprod(ones(1,3),   diag(3), ones(1,2)),
  kprod(ones(1,3), ones(1,3),   diag(2))
)
system.time( graver(A))
system.time( graver(A))
system.time(fgraver(A))
system.time(fgraver(A))



# LAS ex 1.2.1, p.12 : 2x3 independence
(A &lt;- rbind(
  kprod(diag(2), ones(1,3)),
  kprod(ones(1,2), diag(3))
))

markov(A, p = "arb", "tab", c(3, 3))
# Prop 1.2.2 says that there should be
2*choose(2, 2)*choose(3,2) # = 6
# moves (up to +-1)
markov(A, p = "arb", "tab", c(3, 3), TRUE)



# LAS example 1.2.12, p.17  (no 3-way interaction)
(A &lt;- rbind(
  kprod(  diag(2),   diag(2), ones(1,2)),
  kprod(  diag(2), ones(1,2),   diag(2)),
  kprod(ones(1,2),   diag(2),   diag(2))
))
plot_matrix(A)
markov(A, p = "arb")
groebner(A, p = "arb")
graver(A)
tableau(markov(A, p = "arb"), dim = c(2,2,2))





# using the markov bases database, must be connected to internet
# commented out for predictable and fast cran checks time
# A &lt;- markov(dbName = "ind3-3")
# B &lt;- markov(rbind(
#   kprod(diag(3), ones(1,3)),
#   kprod(ones(1,3), diag(3))
# ), p = "arb")
# all(A == B)





# possible issues
# markov(diag(1, 10))
# zbasis(diag(1, 10), "vec")
# groebner(diag(1, 10), "vec", all = TRUE)
# graver(diag(1, 10), "vec", all = TRUE)
# graver(diag(1, 4), "tab", all = TRUE, dim = c(2,2))



}


</code></pre>

<hr>
<h2 id='ones'>Ones</h2><span id='topic+ones'></span>

<h3>Description</h3>

<p>Make an array of ones
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ones(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ones_+3A_...">...</code></td>
<td>
<p>A sequence of dimensions separated by commas</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer array of ones
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ones(5)
ones(5, 1)
ones(1, 5)
ones(2, 3)
ones(2, 3, 2)

str(ones(5))

</code></pre>

<hr>
<h2 id='pathing'>Set paths to LattE and 4ti2 executables</h2><span id='topic+pathing'></span><span id='topic+set_latte_path'></span><span id='topic+set_4ti2_path'></span><span id='topic+get_4ti2_path'></span><span id='topic+get_latte_path'></span><span id='topic+has_4ti2'></span><span id='topic+has_latte'></span><span id='topic+missing_4ti2_stop'></span><span id='topic+missing_latte_stop'></span>

<h3>Description</h3>

<p>These functions set the path to external programs either by (1) passing them
a character string or (2) using <code><a href="base.html#topic+file.choose">file.choose()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_latte_path(path)

set_4ti2_path(path)

get_4ti2_path()

get_latte_path()

has_4ti2()

has_latte()

missing_4ti2_stop()

missing_latte_stop()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pathing_+3A_path">path</code></td>
<td>
<p>A character string, the path to a 4ti2 function (e.g. markov) for
setting 4ti2's path or a LattE function (e.g. count) for LattE's path</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When latte is loaded it attempts to find LattE and 4ti2 executables
(represented by count and markov, respectively).  How it looks depends on
your operating system.
</p>
<p>If you're using a Mac or Linux machine, it looks based on your system's path.
Unfortunately, R changes the system path in such a way that the path that R
sees is not the same as the path that you'd see if you were working in the
terminal. (You can open the Terminal app on a Mac by going to
/Applications/Utilities/Terminal.)  Consequently, latte tries to guess the
file in which your path is set.  To do so, it first checks if your home
directory (type echo ~/ in the terminal to figure out which directory this is
if you don't know) for the file named .bash_profile.  If this file is
present, it runs it and then checks your system's path variable (echo $PATH).
If it's not present, it does the same for .bashrc and then .profile. In any
case, once it has its best guess at your path, it looks for &quot;latte&quot;.
</p>
<p>On Windows, latte just uses <code><a href="base.html#topic+Sys.which">Sys.which()</a></code> on &quot;whereis&quot; to On Windows, latte
just uses <code><a href="base.html#topic+Sys.which">Sys.which()</a></code> on &quot;whereis&quot; to determine where the executables count
and markov are (for LattE and 4ti2, respectively).
</p>


<h3>Value</h3>

<p>An invisible character string, the path found.  More importantly, the
function has the side effect of setting the option &quot;latte_path&quot; or
&quot;4ti2_path&quot;
</p>


<h3>Author(s)</h3>

<p>David Kahle <a href="mailto:david@kahle.io">david@kahle.io</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

has_4ti2()
if (has_4ti2()) get_4ti2_path()

has_latte()
if (has_4ti2()) get_latte_path()

# these are stored in your .Renviron file; that's where you should put the 
# path to LattE and 4ti2 executables. for example, you should have a lines 
# that look like
# LATTE=/Applications/latte/bin
# 4TI2=/Applications/latte/bin
# you can set these with usethis::edit_r_environ() 

# you can change these in your current session with set_latte_path() and 
# set_4ti2_path(), for example set_4ti2_path("/path/to/4ti2")


</code></pre>

<hr>
<h2 id='plot-matrix'>Plot a matrix</h2><span id='topic+plot-matrix'></span><span id='topic+plot_matrix'></span>

<h3>Description</h3>

<p>plot_matrix is a R variant of Matlab's <code>spy</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_matrix(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot-matrix_+3A_a">A</code></td>
<td>
<p>A matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object
</p>


<h3>Author(s)</h3>

<p>David Kahle <a href="mailto:david@kahle.io">david@kahle.io</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# the no-three-way interaction configuration
(A &lt;- kprod(ones(1,3), diag(3), ones(3)))
plot_matrix(A)


if (has_4ti2()) {

plot_matrix(markov(A))

(A &lt;- genmodel(c(2L, 2L), list(1L, 2L)))
plot_matrix(A)
plot_matrix(markov(A))

(A &lt;- genmodel(c(5L, 5L), list(1L, 2L)))
plot_matrix(A)
plot_matrix(markov(A))

}

</code></pre>

<hr>
<h2 id='ppi'>Compute the primitive partition identities</h2><span id='topic+ppi'></span>

<h3>Description</h3>

<p>ppi runs 4ti2's ppi program to compute the primitive partition identities,
that is, the Graver basis of 1:N.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppi(N, dir = tempdir(), quiet = TRUE, shell = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ppi_+3A_n">N</code></td>
<td>
<p>A postive integer &gt; 2</p>
</td></tr>
<tr><td><code id="ppi_+3A_dir">dir</code></td>
<td>
<p>Directory to place the files in, without an ending /</p>
</td></tr>
<tr><td><code id="ppi_+3A_quiet">quiet</code></td>
<td>
<p>If FALSE, messages the 4ti2 output</p>
</td></tr>
<tr><td><code id="ppi_+3A_shell">shell</code></td>
<td>
<p>Messages the shell code used to do the computation</p>
</td></tr>
<tr><td><code id="ppi_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to the function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the basis as its columns (for easy addition to
tables)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+graver">graver()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (has_4ti2()) {

ppi(3)
t(ppi(3)) %*% 1:3
plot_matrix(ppi(3))

graver(t(1:3))
plot_matrix(graver(t(1:3)))

ppi(5, quiet = FALSE, shell = TRUE)

}


</code></pre>

<hr>
<h2 id='print.tableau'>Pretty printing of tableau output.</h2><span id='topic+print.tableau'></span>

<h3>Description</h3>

<p>Pretty printing of tableau output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tableau'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.tableau_+3A_x">x</code></td>
<td>
<p>an object of class tableau</p>
</td></tr>
<tr><td><code id="print.tableau_+3A_...">...</code></td>
<td>
<p>...</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisible string of the printed object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# see ?tableau


</code></pre>

<hr>
<h2 id='qsolve'>Solve a linear system over the rationals</h2><span id='topic+qsolve'></span>

<h3>Description</h3>

<p>qsolve runs 4ti2's qsolve program to compute the
configuration matrix A corresponding to graphical statistical
models given by a simplicial complex and levels on the nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qsolve(mat, rel, sign, dir = tempdir(), quiet = TRUE, shell = FALSE,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qsolve_+3A_mat">mat</code></td>
<td>
<p>The A matrix (see the 4ti2 documentation or examples)</p>
</td></tr>
<tr><td><code id="qsolve_+3A_rel">rel</code></td>
<td>
<p>A vector of &quot;&lt;&quot; or &quot;&gt;&quot; relations</p>
</td></tr>
<tr><td><code id="qsolve_+3A_sign">sign</code></td>
<td>
<p>The signs of the individual</p>
</td></tr>
<tr><td><code id="qsolve_+3A_dir">dir</code></td>
<td>
<p>Directory to place the files in, without an ending /</p>
</td></tr>
<tr><td><code id="qsolve_+3A_quiet">quiet</code></td>
<td>
<p>If FALSE, messages the 4ti2 output</p>
</td></tr>
<tr><td><code id="qsolve_+3A_shell">shell</code></td>
<td>
<p>Messages the shell code used to do the computation</p>
</td></tr>
<tr><td><code id="qsolve_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to the function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The configuration matrix of the model provided
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (has_4ti2()) {

# x + y &gt; 0
# x + y &lt; 0

mat &lt;- rbind(
  c( 1,  1),
  c( 1,  1)
)
rel &lt;- c("&gt;", "&lt;")
sign &lt;- c(0, 0)

qsolve(mat, rel, sign, p = "arb")
qsolve(mat, rel, sign, p = "arb", quiet = FALSE)
qsolve(mat, rel, sign, p = "arb", shell = TRUE)

}


</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+edit_r_environ'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>usethis</dt><dd><p><code><a href="usethis.html#topic+edit_r_environ">edit_r_environ</a></code></p>
</dd>
</dl>

<hr>
<h2 id='tab2vec'>Array to vector conversion</h2><span id='topic+tab2vec'></span>

<h3>Description</h3>

<p>Convert an array into a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tab2vec(tab)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tab2vec_+3A_tab">tab</code></td>
<td>
<p>An array of counts</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts an array (or a multi-way contingency table) into a
vector, using a consistent ordering of the cells. The ordering of the cells
is lexicographical and cannot be specified by the user.
</p>


<h3>Value</h3>

<p>a Named integer vector.  The names correspond to the cell indices in
the table.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vec2tab">vec2tab()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a &lt;- array(1:24, c(2,3,4))
tab2vec(a)

data(Titanic)
tab2vec(Titanic)
Titanic[1,1,1,1]
Titanic[1,1,1,2]


</code></pre>

<hr>
<h2 id='tableau'>Tableau Notation for Markov</h2><span id='topic+tableau'></span>

<h3>Description</h3>

<p>Print the tableau notation for a Markov move.  See the reference
provided, p. 13.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tableau(move, dim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tableau_+3A_move">move</code></td>
<td>
<p>a markov move matrix, where the columns are moves in
vector form (e.g. the output of markov)</p>
</td></tr>
<tr><td><code id="tableau_+3A_dim">dim</code></td>
<td>
<p>the dimensions of the table form of the move,
oftentimes a vector of the number of levels of each variable in
order</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class tableau
</p>


<h3>References</h3>

<p>Drton, M., B. Sturmfels, and S. Sullivant (2009).
<em>Lectures on Algebraic Statistics</em>, Basel: Birkhauser
Verlag AG.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
vec &lt;- matrix(c(1, -1, -1, 1), nrow = 4)
varlvls &lt;- c(2, 2)
tableau(vec, varlvls)


</code></pre>

<hr>
<h2 id='vec2tab'>Vector to array conversion</h2><span id='topic+vec2tab'></span>

<h3>Description</h3>

<p>Convert a vector into an array given a set of dimensions; it therefore simply
wraps <code><a href="base.html#topic+aperm">aperm()</a></code> and <code><a href="base.html#topic+array">array()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec2tab(vec, dim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec2tab_+3A_vec">vec</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="vec2tab_+3A_dim">dim</code></td>
<td>
<p>The desired array dimensions, oftentimes a vector of the number of
levels of each variable in order</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts an array (or a multi-way contingency table) into a
vector, using a consistent ordering of the cells. The ordering of the cells
is lexicographical and cannot be specified by the user.
</p>


<h3>Value</h3>

<p>An array
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tab2vec">tab2vec()</a></code>, <code><a href="base.html#topic+aperm">aperm()</a></code>, <code><a href="base.html#topic+array">array()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Titanic)
Titanic
tab2vec(Titanic)
vec2tab(tab2vec(Titanic), dim(Titanic))
vec2tab(tab2vec(Titanic), dim(Titanic)) == Titanic
all(vec2tab(tab2vec(Titanic), dim(Titanic)) == Titanic)


</code></pre>

<hr>
<h2 id='zsolve'>Solve a linear system over the integers</h2><span id='topic+zsolve'></span>

<h3>Description</h3>

<p>zsolve runs 4ti2's zsolve program to compute the configuration matrix A
corresponding to graphical statistical models given by a simplicial complex
and levels on the nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zsolve(mat, rel, rhs, sign, lat, lb, ub, dir = tempdir(), quiet = TRUE,
  shell = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zsolve_+3A_mat">mat</code></td>
<td>
<p>The A matrix (see the 4ti2 documentation or examples)</p>
</td></tr>
<tr><td><code id="zsolve_+3A_rel">rel</code></td>
<td>
<p>A vector of &quot;&lt;&quot; or &quot;&gt;&quot; relations</p>
</td></tr>
<tr><td><code id="zsolve_+3A_rhs">rhs</code></td>
<td>
<p>The right hand side b</p>
</td></tr>
<tr><td><code id="zsolve_+3A_sign">sign</code></td>
<td>
<p>The signs of the individual</p>
</td></tr>
<tr><td><code id="zsolve_+3A_lat">lat</code></td>
<td>
<p>A lattice basis (instead of a matrix)</p>
</td></tr>
<tr><td><code id="zsolve_+3A_lb">lb</code></td>
<td>
<p>Lower bounds on columns</p>
</td></tr>
<tr><td><code id="zsolve_+3A_ub">ub</code></td>
<td>
<p>Upper bounds on columns</p>
</td></tr>
<tr><td><code id="zsolve_+3A_dir">dir</code></td>
<td>
<p>Directory to place the files in, without an ending /</p>
</td></tr>
<tr><td><code id="zsolve_+3A_quiet">quiet</code></td>
<td>
<p>If FALSE, messages the 4ti2 output</p>
</td></tr>
<tr><td><code id="zsolve_+3A_shell">shell</code></td>
<td>
<p>Messages the shell code used to do the computation</p>
</td></tr>
<tr><td><code id="zsolve_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to the function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The configuration matrix of the model provided
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (has_4ti2()) {

mat &lt;- rbind(
  c( 1, -1),
  c(-3,  1),
  c( 1,  1)
)
rel &lt;- c("&lt;", "&lt;", "&gt;")
rhs &lt;- c(2, 1, 1)
sign &lt;- c(0, 1)

zsolve(mat, rel, rhs, sign)
zsolve(mat, rel, rhs, sign, quiet = FALSE)
zsolve(mat, rel, rhs, sign, shell = TRUE)

zsolve(mat, rel, rhs, sign, p = "gmp", quiet = FALSE)

}


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
