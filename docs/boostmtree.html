<!DOCTYPE html><html><head><title>Help for package boostmtree</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {boostmtree}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AF'>
<p>Atrial Fibrillation Data</p></a></li>
<li><a href='#boostmtree'><p>Boosted multivariate trees for longitudinal data</p></a></li>
<li><a href='#boostmtree-package'>
<p>Boosted multivariate trees for longitudinal data.</p></a></li>
<li><a href='#boostmtree.news'><p>Show the NEWS file</p></a></li>
<li><a href='#marginalPlot'><p>Marginal plot analysis</p></a></li>
<li><a href='#partialPlot'><p>Partial plot analysis</p></a></li>
<li><a href='#plot.boostmtree'><p>Plot Summary Analysis</p></a></li>
<li><a href='#predict.boostmtree'><p>Prediction for Boosted multivariate trees for longitudinal data.</p></a></li>
<li><a href='#print.boostmtree'><p>Print Summary Output</p></a></li>
<li><a href='#simLong'><p>Simulate longitudinal data</p></a></li>
<li><a href='#spirometry'><p>Spirometry Data</p></a></li>
<li><a href='#vimp.boostmtree'><p>Variable Importance</p></a></li>
<li><a href='#vimpPlot'>
<p>Variable Importance (VIMP) plot</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.5.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-03-09</td>
</tr>
<tr>
<td>Title:</td>
<td>Boosted Multivariate Trees for Longitudinal Data</td>
</tr>
<tr>
<td>Author:</td>
<td>Hemant Ishwaran &lt;hemant.ishwaran@gmail.com&gt;, Amol Pande &lt;amoljpande@gmail.com&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Udaya B. Kogalur &lt;ubk@kogalur.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>randomForestSRC (&ge; 2.9.0), parallel, splines, nlme</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements Friedman's gradient descent boosting algorithm for modeling longitudinal response using multivariate tree base learners. Longitudinal response could be continuous, binary, nominal or ordinal.  A time-covariate interaction effect is modeled using penalized B-splines (P-splines) with estimated adaptive smoothing parameter. Although the package is design for longitudinal data, it can handle cross-sectional data as well. Implementation details are provided in Pande et al. (2017), Mach Learn &lt;<a href="https://doi.org/10.1007%2Fs10994-016-5597-1">doi:10.1007/s10994-016-5597-1</a>&gt;. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://ishwaran.org/ishwaran.html">https://ishwaran.org/ishwaran.html</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-03-09 16:34:06 UTC; udaya</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-03-10 09:40:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='AF'>
Atrial Fibrillation Data
</h2><span id='topic+AF'></span>

<h3>Description</h3>

<p>Atrial Fibrillation (AF) data is obtained from a randomized trial to study
the effect of surgical ablation as a treatment option for AF 
among patients with persistent and
long-standing persistent AF who requires mitral valve surgery.
Patients were randomized into two groups: mitral valve
surgery with ablation and mitral valve surgery without ablation.
Patients in the ablation group were further randomized into
two types of procedure: pulmonary vain isolation (PVI)
and biatrial maze procedure.
These patients were followed weekly for a period of 12 months. The
primary outcome of the study is the presence/absence of AF
(binary longitudinal response).
Data includes 228 patients. From 228 patients, 7949 AF measurements
are available with average of 35 measurements per patient.
</p>


<h3>Format</h3>

<p>A list containing four elements:
</p>

<ol>
<li><p>  The 84 patient variables (features).
</p>
</li>
<li><p>  Time points (time).
</p>
</li>
<li><p>  Unique patient identifier (id).
</p>
</li>
<li><p>  Presence or absence of AF (y).
</p>
</li></ol>



<h3>References</h3>

<p>Gillinov A. M., Gelijns A.C., Parides M.K., DeRose J.J.Jr.,
Moskowitz~A.J. et al. Surgical ablation of atrial fibrillation during mitral
valve surgery.
<em>The New England Journal of Medicine</em> 372(15):1399&ndash;1408, 2015.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(AF, package = "boostmtree")</code></pre>

<hr>
<h2 id='boostmtree'>Boosted multivariate trees for longitudinal data</h2><span id='topic+boostmtree'></span><span id='topic+boostmtree'></span>

<h3>Description</h3>

<p>Multivariate extension of Friedman's gradient descent boosting method
for modeling continuous or binary longitudinal response using 
multivariate tree base learners (Pande et
al., 2017).  Covariate-time interactions are modeled using penalized
B-splines (P-splines) with estimated adaptive smoothing parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> boostmtree(x,
            tm,
            id,
            y,
            family = c("Continuous","Binary","Nominal","Ordinal"),
            y_reference = NULL,
            M = 200,
            nu = 0.05,
            na.action = c("na.omit","na.impute")[2],
            K = 5,
            mtry = NULL,
            nknots = 10,
            d = 3,
            pen.ord = 3,
            lambda,
            rho,
            lambda.max = 1e6,
            lambda.iter = 2,
            svd.tol = 1e-6,
            forest.tol = 1e-3,
            verbose = TRUE,
            cv.flag = FALSE,
            eps = 1e-5,
            mod.grad = TRUE,
            NR.iter = 3,
            ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boostmtree_+3A_x">x</code></td>
<td>
<p>Data frame (or matrix) containing the x-values.   Rows
must be duplicated to match the number of time points for an individual.
That is, if individual <em>i</em> has <em>n[i]</em> outcome y-values,
then there must be <em>n[i]</em> duplicate rows of <em>i</em>'s x-value.</p>
</td></tr>
<tr><td><code id="boostmtree_+3A_tm">tm</code></td>
<td>
<p>Vector of time values, one entry for each row in <code>x</code>.</p>
</td></tr>
<tr><td><code id="boostmtree_+3A_id">id</code></td>
<td>
<p>Unique subject identifier, one entry for each row in <code>x</code>.</p>
</td></tr>
<tr><td><code id="boostmtree_+3A_y">y</code></td>
<td>
<p>Observed y-value, one entry for each row in <code>x</code>.</p>
</td></tr>
<tr><td><code id="boostmtree_+3A_family">family</code></td>
<td>
<p>Family of the response variable <code>y</code>. Use any one 
from {&quot;Continuous&quot;, &quot;Binary&quot;,&quot;Nominal&quot;,&quot;Ordinal&quot;} based on the scale of <code>y</code>.</p>
</td></tr>
<tr><td><code id="boostmtree_+3A_y_reference">y_reference</code></td>
<td>
<p>Set this value, among the unique <code>y</code> values 
when <code>family</code> == &quot;Nominal&quot;. If NULL, lowest value, among unique <code>y</code> values, is used.</p>
</td></tr>
<tr><td><code id="boostmtree_+3A_m">M</code></td>
<td>
<p>Number of boosting iterations</p>
</td></tr>
<tr><td><code id="boostmtree_+3A_nu">nu</code></td>
<td>
<p>Boosting regularization parameter.  A value in (0,1].</p>
</td></tr>
<tr><td><code id="boostmtree_+3A_na.action">na.action</code></td>
<td>
<p>Remove missing values (casewise) or impute it. Default is to impute the missign values.</p>
</td></tr>
<tr><td><code id="boostmtree_+3A_k">K</code></td>
<td>
<p>Number of terminal nodes used for the multivariate tree learner.</p>
</td></tr>
<tr><td><code id="boostmtree_+3A_mtry">mtry</code></td>
<td>
<p>Number of <code>x</code> variables selected randomly for tree fitting. Default is use all <code>x</code> variables.</p>
</td></tr>
<tr><td><code id="boostmtree_+3A_nknots">nknots</code></td>
<td>
<p>Number of knots used for the B-spline for modeling the
time interaction effect.</p>
</td></tr>
<tr><td><code id="boostmtree_+3A_d">d</code></td>
<td>
<p>Degree of the piecewise B-spline polynomial (no time
effect is fit when d &lt; 1).</p>
</td></tr>
<tr><td><code id="boostmtree_+3A_pen.ord">pen.ord</code></td>
<td>
<p>Differencing order used to define the penalty with
increasing values implying greater smoothness.</p>
</td></tr>
<tr><td><code id="boostmtree_+3A_lambda">lambda</code></td>
<td>
<p>Smoothing (penalty) parameter used for B-splines with
increasing values associated with increasing
smoothness/penalization. If missing, or non-positive, the value is
estimated adaptively using a mixed models approach.</p>
</td></tr>
<tr><td><code id="boostmtree_+3A_rho">rho</code></td>
<td>
<p>If missing, rho is estimated, else, use the <code>rho</code> value specified in this argument.</p>
</td></tr>
<tr><td><code id="boostmtree_+3A_lambda.max">lambda.max</code></td>
<td>
<p>Tolerance used for adaptively estimated lambda
(caps it).  For experts only.</p>
</td></tr>
<tr><td><code id="boostmtree_+3A_lambda.iter">lambda.iter</code></td>
<td>
<p>Number of iterations used to estimate lambda
(only applies when lambda is not supplied and adaptive smoothing
is employed).</p>
</td></tr>
<tr><td><code id="boostmtree_+3A_svd.tol">svd.tol</code></td>
<td>
<p>Tolerance value used in the SVD calculation of the
penalty matrix.  For experts only.</p>
</td></tr>
<tr><td><code id="boostmtree_+3A_forest.tol">forest.tol</code></td>
<td>
<p>Tolerance used for forest weighted least squares
solution.  Experimental and for experts only.</p>
</td></tr>
<tr><td><code id="boostmtree_+3A_verbose">verbose</code></td>
<td>
<p>Should verbose output be printed?</p>
</td></tr>
<tr><td><code id="boostmtree_+3A_cv.flag">cv.flag</code></td>
<td>
<p>Should in-sample cross-validation (CV) be used to determine
optimal stopping using out of bag data?</p>
</td></tr>
<tr><td><code id="boostmtree_+3A_eps">eps</code></td>
<td>
<p>Tolerance value used for determining the optimal
<code>M</code>. Applies only if <code>cv.flag</code> = TRUE.  For experts only.</p>
</td></tr>
<tr><td><code id="boostmtree_+3A_mod.grad">mod.grad</code></td>
<td>
<p>Use a modified gradient? See details below.</p>
</td></tr>
<tr><td><code id="boostmtree_+3A_nr.iter">NR.iter</code></td>
<td>
<p>Number of Newton-Raphson iteration. Applied 
for <code>family</code> = {Binary&quot;,&quot;Nominal&quot;,&quot;Ordinal&quot;}.</p>
</td></tr>
<tr><td><code id="boostmtree_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each individual has observed y-values, over possibly different time
points, with possibly differing number of time points.  Given y, the
time points, and x, the conditional mean time profile of y is
estimated using gradient boosting in which the gradient is derived
from a criterion function involving a working variance matrix for y
specified as an equicorrelation matrix with parameter <em>rho</em>
multiplied by a variance parameter <em>phi</em>. Multivariate trees are
used for base learners and weighted least squares is used for solving
the terminal node optimization problem.  This provides solutions to
the core parameters of the algorithm.  For ancillary parameters, a
mixed-model formulation is used to estimate the smoothing parameter
associated with the B-splines used for the time-interaction effect,
although the user can manually set the smoothing parameter as well.
Ancillary parameters <em>rho</em> and <em>phi</em> are estimated using GLS
(generalized least squares).
</p>
<p>In the original boostmtree algorithm (Pande et al., 2017), the
equicorrelation parameter <em>rho</em> is used in two places in the
algorithm: (1) for growing trees using the gradient, which depends
upon <em>rho</em>; and (2) for solving the terminal node optimization
problem which also uses the gradient.  However, Pande (2017) observed
that setting <em>rho</em> to zero in the gradient used for growing trees
improved performance of the algorithm, especially in high dimensions.
For this reason the default setting used in this algorithm is to set
<em>rho</em> to zero in the gradient for (1).  The <code>rho</code> in the
gradient for (2) is not touched.  The option <code>mod.grad</code> specifies
whether a modified gradient is used in the tree growing process and is
TRUE by default.
</p>
<p>By default, trees are grown from a bootstrap sample of the data &ndash;
thus the boosting method employed here is a modified example of
stochastic gradient descent boosting (Friedman, 2002).  Stochastic
descent often improves performance and has the added advantage that
out-of-sample data (out-of-bag, OOB) can be used to calculate
variable importance (VIMP).
</p>
<p>The package implements R-side parallel processing by replacing
the R function <code>lapply</code> with <code>mclapply</code> found in the
<span class="pkg">parallel</span> package.  You can set the number of cores accessed by
<code>mclapply</code> by issuing the command <code>options(mc.cores =
    x)</code>, where <code>x</code> is the number of cores.  The options command
can also be placed in the users .Rprofile file for convenience.  You
can, alternatively, initialize the environment variable
<code>MC_CORES</code> in your shell environment.
</p>
<p>As an example, issuing the following options command uses all
available cores for R-side parallel processing:
</p>
<p><code>options(mc.cores=detectCores())</code>
</p>
<p>However, be cautious when setting <code>mc.cores</code>.  This can create
not only high CPU usage but also high RAM usage, especially when using
functions <code>partialPlot</code> and <code>predict</code>.
</p>
<p>The method can impute the missing observations in x (covariates) using
on the fly imputation. Details regarding can be found in the
<span class="pkg">randomForestSRC</span> package. If missing values are present in the
<code>tm</code>, <code>id</code> or <code>y</code>, the user should either impute or
delete these values before executing the function.
</p>
<p>Finally note <code>cv.flag</code> can be used for an in-sample
cross-validated estimate of prediction error.  This is used to
determine the optimized number of boosting iterations <em>Mopt</em>.
The final mu predictor is evaluated at this value and is
cross-validated.  The prediction error returned via <code>err.rate</code>
is standardized by the overall standard deviation of y.  </p>


<h3>Value</h3>

<p> An
object of class <code>(boostmtree, grow)</code> with the following
components:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>The x-values, but with only one row per individual
(i.e. duplicated rows are removed). Values sorted on <code>id</code>.</p>
</td></tr>
<tr><td><code>xvar.names</code></td>
<td>
<p>X-variable names.</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>List with each component containing the time
points for a given individual. Values sorted on <code>id</code>.</p>
</td></tr>
<tr><td><code>id</code></td>
<td>
<p>Sorted subject identifier.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>List with each component containing the observed
y-values for a given individual. Values sorted on <code>id</code>.</p>
</td></tr>
<tr><td><code>Yorg</code></td>
<td>
<p>For family == &quot;Nominal&quot; or family == &quot;Ordinal&quot;, this provides the 
response in list-format where each element coverted the response into the binary response.</p>
</td></tr>  
<tr><td><code>family</code></td>
<td>
<p>Family of <code>y</code>.</p>
</td></tr>   
<tr><td><code>ymean</code></td>
<td>
<p>Overall mean of y-values for all individuals. If <code>family</code> = 
&quot;Binary&quot;, <code>ymean</code> = 0.</p>
</td></tr>
<tr><td><code>ysd</code></td>
<td>
<p>Overall standard deviation of y-values for all individuals. If <code>family</code> = 
&quot;Binary&quot;, <code>ysd</code> = 1.</p>
</td></tr>
<tr><td><code>na.action</code></td>
<td>
<p>Remove missing values or impute?</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>Total number of subjects.</p>
</td></tr>
<tr><td><code>ni</code></td>
<td>
<p>Number of repeated measures for each subject.</p>
</td></tr>
<tr><td><code>n.Q</code></td>
<td>
<p>Number of class labels for non-continuous response.</p>
</td></tr>
<tr><td><code>Q_set</code></td>
<td>
<p>Class labels for the non-continuous response.</p>
</td></tr>
<tr><td><code>y.unq</code></td>
<td>
<p>Unique y values for the non-continous response.</p>
</td></tr>
<tr><td><code>y_reference</code></td>
<td>
<p>Reference value for family == &quot;Nominal&quot;.</p>
</td></tr>  
<tr><td><code>tm.unq</code></td>
<td>
<p>Unique time points.</p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>
<p>List of length <em>M</em>, with each component
containing the boosted tree fitted values.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>List with each component containing the estimated mean
values for an individual.  That is, each component contains the
estimated time-profile for an individual.  When in-sample
cross-validation is requested using <code>cv.flag</code>=TRUE, the
estimated mean is cross-validated and evaluated at the optimal
number of iterations <code>Mopt</code>.
If the family == &quot;Nominal&quot; or family == &quot;Ordinal&quot;, <code>mu</code> will have a higher level
of list to accommodate binary responses generated from nominal or ordinal response.</p>
</td></tr> 
<tr><td><code>Prob_class</code></td>
<td>
<p>For family == &quot;Ordinal&quot;, this provides individual probabilty rather than
cumulative probabilty.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>Smoothing parameter. Results provided in vector or matrix form, depending
on whether family == c(&quot;Continuous&quot;,&quot;Binary&quot;) or family == c(&quot;Nominal&quot;, &quot;Ordinal&quot;).</p>
</td></tr>
<tr><td><code>phi</code></td>
<td>
<p>Variance parameter.Results provided in vector or matrix form, depending
on whether family == c(&quot;Continuous&quot;,&quot;Binary&quot;) or family == c(&quot;Nominal&quot;, &quot;Ordinal&quot;).</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>Correlation parameter.Results provided in vector or matrix form, depending
on whether family == c(&quot;Continuous&quot;,&quot;Binary&quot;) or family == c(&quot;Nominal&quot;, &quot;Ordinal&quot;).</p>
</td></tr>
<tr><td><code>baselearner</code></td>
<td>
<p>List of length <em>M</em> containing the base learners.</p>
</td></tr>
<tr><td><code>membership</code></td>
<td>
<p>List of length <em>M</em>, with each component
containing the terminal node membership for a given boosting
iteration.</p>
</td></tr>
<tr><td><code>X.tm</code></td>
<td>
<p>Design matrix for all the unique time points.</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>Design matrix for each subject.</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>Degree of the piecewise B-spline polynomial.</p>
</td></tr>
<tr><td><code>pen.ord</code></td>
<td>
<p>Penalization difference order.</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>Number of terminal nodes.</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>Number of boosting iterations.</p>
</td></tr>
<tr><td><code>nu</code></td>
<td>
<p>Boosting regularization parameter.</p>
</td></tr>
<tr><td><code>ntree</code></td>
<td>
<p>Number of trees.</p>
</td></tr>
<tr><td><code>cv.flag</code></td>
<td>
<p>Whether in-sample CV is used or not?</p>
</td></tr>
<tr><td><code>err.rate</code></td>
<td>
<p>In-sample standardized estimate of l1-error and RMSE.</p>
</td></tr>
<tr><td><code>rmse</code></td>
<td>
<p>In-sample standardized RMSE at optimized <code>M</code>.</p>
</td></tr>
<tr><td><code>Mopt</code></td>
<td>
<p>The optimized <code>M</code>.</p>
</td></tr>
<tr><td><code>gamma.i.list</code></td>
<td>
<p>Estimate of gamma obtained from in-sample CV if <code>cv.flag</code> = TRUE,       else NULL</p>
</td></tr>
<tr><td><code>forest.tol</code></td>
<td>
<p>Forest tolerance value (needed for prediction).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hemant Ishwaran, Amol Pande and Udaya B. Kogalur
</p>


<h3>References</h3>

<p>Friedman J.H. (2001). Greedy function approximation: a gradient
boosting machine, <em>Ann. of Statist.</em>, 5:1189-1232.
</p>
<p>Friedman J.H. (2002). Stochastic gradient boosting.
<em>Comp. Statist. Data Anal.</em>, 38(4):367&ndash;378.
</p>
<p>Pande A., Li L., Rajeswaran J., Ehrlinger J., Kogalur U.B.,
Blackstone E.H., Ishwaran H. (2017).  Boosted multivariate trees for
longitudinal data, <em>Machine Learning</em>, 106(2): 277&ndash;305.
</p>
<p>Pande A. (2017).  <em>Boosting for longitudinal data</em>.  Ph.D. Dissertation,
Miller School of Medicine, University of Miami.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+marginalPlot">marginalPlot</a></code>
<code><a href="#topic+partialPlot">partialPlot</a></code>,
<code><a href="#topic+plot.boostmtree">plot.boostmtree</a></code>,
<code><a href="#topic+predict.boostmtree">predict.boostmtree</a></code>,
<code><a href="#topic+print.boostmtree">print.boostmtree</a></code>,
<code><a href="#topic+simLong">simLong</a></code>,
<code><a href="#topic+vimpPlot">vimpPlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##------------------------------------------------------------
## synthetic example (Response y is continuous)
## 0.8 correlation, quadratic time with quadratic interaction
##-------------------------------------------------------------
#simulate the data (use a small sample size for illustration)
dta &lt;- simLong(n = 50, N = 5, rho =.80, model = 2,family = "Continuous")$dtaL

#basic boosting call (M set to a small value for illustration)
boost.grow &lt;- boostmtree(dta$features, dta$time, dta$id, dta$y,family = "Continuous",M = 20)

#print results
print(boost.grow)

#plot.results
plot(boost.grow)

##------------------------------------------------------------
## synthetic example (Response y is binary)
## 0.8 correlation, quadratic time with quadratic interaction
##-------------------------------------------------------------
#simulate the data (use a small sample size for illustration)
dta &lt;- simLong(n = 50, N = 5, rho =.80, model = 2, family = "Binary")$dtaL

#basic boosting call (M set to a small value for illustration)
boost.grow &lt;- boostmtree(dta$features, dta$time, dta$id, dta$y,family = "Binary", M = 20)

#print results
print(boost.grow)

#plot.results
plot(boost.grow)

## Not run: 
##------------------------------------------------------------
## Same synthetic example as above with continuous response
## but with in-sample cross-validation estimate for RMSE
##-------------------------------------------------------------
dta &lt;- simLong(n = 50, N = 5, rho =.80, model = 2,family = "Continuous")$dtaL
boost.cv.grow &lt;- boostmtree(dta$features, dta$time, dta$id, dta$y,
                 family = "Continuous", M = 300, cv.flag = TRUE)
plot(boost.cv.grow)
print(boost.cv.grow)

##----------------------------------------------------------------------------
## spirometry data (Response is continuous)
##----------------------------------------------------------------------------
data(spirometry, package = "boostmtree")

#boosting call: cubic B-splines with 15 knots
spr.obj &lt;- boostmtree(spirometry$features, spirometry$time, spirometry$id, spirometry$y,
                        family = "Continuous",M = 100, nu = .025, nknots = 15)
plot(spr.obj)


##----------------------------------------------------------------------------
## Atrial Fibrillation data (Response is binary)
##----------------------------------------------------------------------------
data(AF, package = "boostmtree")

#boosting call: cubic B-splines with 15 knots
AF.obj &lt;- boostmtree(AF$feature, AF$time, AF$id, AF$y,
                        family = "Binary",M = 100, nu = .025, nknots = 15)
plot(AF.obj)


##----------------------------------------------------------------------------
## sneaky way to use boostmtree for (univariate) regression: boston housing
##----------------------------------------------------------------------------

if (library("mlbench", logical.return = TRUE)) {

  ## assemble the data
  data(BostonHousing)
  x &lt;- BostonHousing; x$medv &lt;- NULL
  y &lt;- BostonHousing$medv
  trn &lt;- sample(1:nrow(x), size = nrow(x) * (2 / 3), replace = FALSE)

  ## run boosting in univariate mode
  o &lt;- boostmtree(x = x[trn,], y = y[trn],family = "Continuous")
  o.p &lt;- predict(o, x = x[-trn, ], y = y[-trn])
  print(o)
  plot(o.p)

  ## run boosting in univariate mode to obtain RMSE and vimp
  o.cv &lt;- boostmtree(x = x, y = y, M = 100,family = "Continuous",cv.flag = TRUE)
  print(o.cv)
  plot(o.cv)
}


## End(Not run)</code></pre>

<hr>
<h2 id='boostmtree-package'>
Boosted multivariate trees for longitudinal data.
</h2><span id='topic+boostmtree-package'></span>

<h3>Description</h3>

<p>Multivariate extension of Friedman's (2001) gradient descent boosting
method for modeling longitudinal response
using multivariate tree base learners.
Longitudinal response could be continuous, binary, nominal or ordinal.
Covariate-time interactions are modeled using penalized B-splines
(P-splines) with estimated adaptive smoothing parameter.
</p>


<h3>Package Overview</h3>

<p>This package contains many useful functions and users should read the
help file in its entirety for details.  However, we briefly mention
several key functions that may make it easier to navigate and
understand the layout of the package.
</p>

<ol>
<li> <p><code><a href="#topic+boostmtree">boostmtree</a></code>
</p>
<p>This is the main entry point to the package.  It grows a
multivariate tree using user supplied training data.  Trees are
grown using the <span class="pkg">randomForestSRC</span> R-package.
</p>
</li>
<li> <p><code><a href="#topic+predict.boostmtree">predict.boostmtree</a></code> (<code>predict</code>)
</p>
<p>Used for prediction.  Predicted values are obtained by dropping the
user supplied test data down the grow forest.  The resulting object
has class <code>(rfsrc, predict)</code>.
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Hemant Ishwaran, Amol Pande and Udaya B. Kogalur
</p>


<h3>References</h3>

<p>Friedman J.H. (2001). Greedy function approximation: a gradient
boosting machine, <em>Ann. of Statist.</em>, 5:1189-1232.
</p>
<p>Friedman J.H. (2002). Stochastic gradient boosting.
<em>Comp. Statist. Data Anal.</em>, 38(4):367&ndash;378.
</p>
<p>Pande A., Li L., Rajeswaran J., Ehrlinger J., Kogalur U.B.,
Blackstone E.H., Ishwaran H. (2017).  Boosted multivariate trees for
longitudinal data, <em>Machine Learning</em>, 106(2): 277&ndash;305. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+partialPlot">partialPlot</a></code>,
<code><a href="#topic+plot.boostmtree">plot.boostmtree</a></code>,
<code><a href="#topic+predict.boostmtree">predict.boostmtree</a></code>,
<code><a href="#topic+print.boostmtree">print.boostmtree</a></code>,
<code><a href="#topic+simLong">simLong</a></code>
</p>

<hr>
<h2 id='boostmtree.news'>Show the NEWS file</h2><span id='topic+boostmtree.news'></span>

<h3>Description</h3>

<p>Show the NEWS file of the <span class="pkg">boostmtree</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boostmtree.news(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boostmtree.news_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Hemant Ishwaran, Amol Pande  and Udaya B. Kogalur
</p>

<hr>
<h2 id='marginalPlot'>Marginal plot analysis</h2><span id='topic+marginalPlot'></span>

<h3>Description</h3>

<p>Marginal plot of x against the unadjusted predicted y. This is mainly used to obtain
marginal relationships between x and the unadjusted predicted
y. Marginal plots have a faster
execution compared to partial plots (Friedman, 2001).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marginalPlot(object,
             xvar.names,
             tm.unq,
             subset,
             plot.it = FALSE,
             path_saveplot = NULL,
             Verbose = TRUE,
             ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marginalPlot_+3A_object">object</code></td>
<td>
<p>A boosting object of class <code>(boostmtree, grow)</code>.</p>
</td></tr>
<tr><td><code id="marginalPlot_+3A_xvar.names">xvar.names</code></td>
<td>
<p>Names of the x-variables to be used.  By default,
all variables are plotted.</p>
</td></tr>
<tr><td><code id="marginalPlot_+3A_tm.unq">tm.unq</code></td>
<td>
<p>Unique time points used for the plots of x against y.  By default,
the deciles of the observed time values are used.</p>
</td></tr>
<tr><td><code id="marginalPlot_+3A_subset">subset</code></td>
<td>
<p>Vector indicating which rows of the x-data to be used for the
analysis.  The default is to use the entire data.</p>
</td></tr>
<tr><td><code id="marginalPlot_+3A_plot.it">plot.it</code></td>
<td>
<p>Should plots be displayed? If <code>xvar.names</code> is a vector with more than
one variable name, then instead of displaying, plot is stored as &quot;MarginalPlot.pdf&quot; in the location specified
by <code>path_saveplot</code>.</p>
</td></tr>
<tr><td><code id="marginalPlot_+3A_path_saveplot">path_saveplot</code></td>
<td>
<p>Provide the location where plot should be saved. By default the plot will be saved at temporary folder.</p>
</td></tr>
<tr><td><code id="marginalPlot_+3A_verbose">Verbose</code></td>
<td>
<p>Display the path where the plot is saved?</p>
</td></tr>
<tr><td><code id="marginalPlot_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Marginal plot of x values specified by
<code>xvar.names</code> against the unadjusted predicted y-values over a set
of time points specified by <code>tm.unq</code>.  Analysis can be restricted to
a subset of the data using <code>subset</code>.
</p>


<h3>Author(s)</h3>

<p>Hemant Ishwaran, Amol Pande and Udaya B. Kogalur
</p>


<h3>References</h3>

<p>Friedman J.H. Greedy function approximation: a gradient
boosting machine, <em>Ann. of Statist.</em>, 5:1189-1232, 2001.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##------------------------------------------------------------
## Synthetic example (Response is continuous)
## High correlation, quadratic time with quadratic interaction
##-------------------------------------------------------------
#simulate the data
dta &lt;- simLong(n = 50, N = 5, rho =.80, model = 2,family = "Continuous")$dtaL

#basic boosting call
boost.grow &lt;- boostmtree(dta$features, dta$time, dta$id, dta$y, family = "Continuous", M = 300)

#plot results
#x1 has a linear main effect
#x2 is quadratic with quadratic time trend
marginalPlot(boost.grow, "x1",plot.it = TRUE)
marginalPlot(boost.grow, "x2",plot.it = TRUE)

#Plot of all covariates. The plot will be stored as the "MarginalPlot.pdf"
# in the current working directory.
marginalPlot(boost.grow,plot.it = TRUE)


##------------------------------------------------------------
## Synthetic example (Response is binary)
## High correlation, quadratic time with quadratic interaction
##-------------------------------------------------------------
#simulate the data
dta &lt;- simLong(n = 50, N = 5, rho =.80, model = 2,family = "Binary")$dtaL

#basic boosting call
boost.grow &lt;- boostmtree(dta$features, dta$time, dta$id, dta$y, family = "Binary", M = 300)

#plot results
#x1 has a linear main effect
#x2 is quadratic with quadratic time trend
marginalPlot(boost.grow, "x1",plot.it = TRUE)
marginalPlot(boost.grow, "x2",plot.it = TRUE)

#Plot of all covariates. The plot will be stored as the "MarginalPlot.pdf"
# in the current working directory.
marginalPlot(boost.grow,plot.it = TRUE)

##----------------------------------------------------------------------------
## spirometry data
##----------------------------------------------------------------------------
data(spirometry, package = "boostmtree")

#boosting call: cubic B-splines with 15 knots
spr.obj &lt;- boostmtree(spirometry$features, spirometry$time, spirometry$id, spirometry$y,
            family = "Continuous",M = 300, nu = .025, nknots = 15)

#marginal plot of double-lung group at 5 years
dltx &lt;- marginalPlot(spr.obj, "AGE", tm.unq = 5, subset = spr.obj$x$DOUBLE==1,plot.it = TRUE)

#marginal plot of single-lung group at 5 years
sltx &lt;- marginalPlot(spr.obj, "AGE", tm.unq = 5, subset = spr.obj$x$DOUBLE==0,plot.it = TRUE)

#combine the two plots
dltx &lt;- dltx[[2]][[1]]
sltx &lt;- sltx[[2]][[1]]
plot(range(c(dltx[[1]][, 1], sltx[[1]][, 1])), range(c(dltx[[1]][, -1], sltx[[1]][, -1])),
     xlab = "age", ylab = "predicted y", type = "n")
lines(dltx[[1]][, 1][order(dltx[[1]][, 1]) ], dltx[[1]][, -1][order(dltx[[1]][, 1]) ], 
      lty = 1, lwd = 2, col = "red")
lines(sltx[[1]][, 1][order(sltx[[1]][, 1]) ], sltx[[1]][, -1][order(sltx[[1]][, 1]) ], 
      lty = 1, lwd = 2, col = "blue")
legend("topright", legend = c("DLTx", "SLTx"), lty = 1, fill = c(2,4))

## End(Not run)
</code></pre>

<hr>
<h2 id='partialPlot'>Partial plot analysis</h2><span id='topic+partialPlot'></span>

<h3>Description</h3>

<p>Partial dependence plot of x against adjusted predicted y.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partialPlot(object,
            M = NULL,
            xvar.names,
            tm.unq,
            xvar.unq = NULL,
            npts = 25,
            subset,
            prob.class = FALSE,
            conditional.xvars = NULL,
            conditional.values = NULL,
            plot.it = FALSE,
            Variable_Factor = FALSE,
            path_saveplot = NULL,
            Verbose = TRUE,
            useCVflag = FALSE,
            ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partialPlot_+3A_object">object</code></td>
<td>
<p>A boosting object of class <code>(boostmtree, grow)</code>.</p>
</td></tr>
<tr><td><code id="partialPlot_+3A_m">M</code></td>
<td>
<p>Fixed value for the boosting step number. If NULL, then use Mopt
if it is available from the object, else use M</p>
</td></tr>
<tr><td><code id="partialPlot_+3A_xvar.names">xvar.names</code></td>
<td>
<p>Names of the x-variables to be used.  By default,
all variables are plotted.</p>
</td></tr>
<tr><td><code id="partialPlot_+3A_tm.unq">tm.unq</code></td>
<td>
<p>Unique time points used for the plots of x against y.  By default,
the deciles of the observed time values are used.</p>
</td></tr>
<tr><td><code id="partialPlot_+3A_xvar.unq">xvar.unq</code></td>
<td>
<p>Unique values used for the partial plot. Default is NULL in which case
unique values are obtained uniformaly based on the range of variable. Values must
be provided using list with same length as lenght of <code>xvar.names</code>.</p>
</td></tr>
<tr><td><code id="partialPlot_+3A_npts">npts</code></td>
<td>
<p>Maximum number of points used for x.  Reduce this value if
plots are slow.</p>
</td></tr>
<tr><td><code id="partialPlot_+3A_subset">subset</code></td>
<td>
<p>Vector indicating which rows of the x-data to be used for the
analysis.  The default is to use the entire data.</p>
</td></tr>
<tr><td><code id="partialPlot_+3A_prob.class">prob.class</code></td>
<td>
<p>In case of ordinal response, use class probability rather than cumulative probability.</p>
</td></tr>
<tr><td><code id="partialPlot_+3A_conditional.xvars">conditional.xvars</code></td>
<td>
<p>Vector of character values indicating names of the x-variables
to be used for further conditioning (adjusting) the predicted y values. Variable names
should be different from <code>xvar.names</code>.</p>
</td></tr>
<tr><td><code id="partialPlot_+3A_conditional.values">conditional.values</code></td>
<td>
<p>Vector of values taken by the variables from <code>conditional.xvars</code>.
The length of the vector should be same as the length of the vector for <code>conditional.xvars</code>, which means only one value per conditional variable.</p>
</td></tr>
<tr><td><code id="partialPlot_+3A_plot.it">plot.it</code></td>
<td>
<p>Should plots be displayed?</p>
</td></tr>
<tr><td><code id="partialPlot_+3A_variable_factor">Variable_Factor</code></td>
<td>
<p>Default is FALSE. Use TRUE if the variable specified
in <code>xvar.names</code> is a factor.</p>
</td></tr>
<tr><td><code id="partialPlot_+3A_path_saveplot">path_saveplot</code></td>
<td>
<p>Provide the location where plot should be saved. By default the plot will be saved at temporary folder.</p>
</td></tr>
<tr><td><code id="partialPlot_+3A_verbose">Verbose</code></td>
<td>
<p>Display the path where the plot is saved?</p>
</td></tr>
<tr><td><code id="partialPlot_+3A_usecvflag">useCVflag</code></td>
<td>
<p>Should the predicted value be based on the estimate derived from oob sample?</p>
</td></tr>
<tr><td><code id="partialPlot_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Partial dependence plot (Friedman, 2001) of x values specified by
<code>xvar.names</code> against the adjusted predicted y-values over a set
of time points specified by <code>tm.unq</code>.  Analysis can be restricted to
a subset of the data using <code>subset</code>. Further conditioning can be
imposed using <code>conditional.xvars</code>.
</p>


<h3>Author(s)</h3>

<p>Hemant Ishwaran, Amol Pande and Udaya B. Kogalur
</p>


<h3>References</h3>

<p>Friedman J.H. Greedy function approximation: a gradient
boosting machine, <em>Ann. of Statist.</em>, 5:1189-1232, 2001.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##------------------------------------------------------------
## Synthetic example (Response is continuous)
## high correlation, quadratic time with quadratic interaction
##-------------------------------------------------------------
#simulate the data
dta &lt;- simLong(n = 50, N = 5, rho =.80, model = 2,family = "Continuous")$dtaL

#basic boosting call
boost.grow &lt;- boostmtree(dta$features, dta$time, dta$id, dta$y,family = "Continuous",M = 300)

#plot results
#x1 has a linear main effect
#x2 is quadratic with quadratic time trend
pp.obj &lt;- partialPlot(object = boost.grow, xvar.names = "x1",plot.it = TRUE)
pp.obj &lt;- partialPlot(object = boost.grow, xvar.names = "x2",plot.it = TRUE)

#partial plot using "x2" as the conditional variable
pp.obj &lt;- partialPlot(object = boost.grow, xvar.names = "x1",
                      conditional.xvar = "x2", conditional.values = 1,plot.it = TRUE)
pp.obj &lt;- partialPlot(object = boost.grow, xvar.names = "x1",
                      conditional.xvar = "x2", conditional.values = 2,plot.it = TRUE)

##------------------------------------------------------------
## Synthetic example (Response is binary)
## high correlation, quadratic time with quadratic interaction
##-------------------------------------------------------------
#simulate the data
dta &lt;- simLong(n = 50, N = 5, rho =.80, model = 2,family = "Binary")$dtaL

#basic boosting call
boost.grow &lt;- boostmtree(dta$features, dta$time, dta$id, dta$y,family = "Binary",M = 300)

#plot results
#x1 has a linear main effect
#x2 is quadratic with quadratic time trend
pp.obj &lt;- partialPlot(object = boost.grow, xvar.names = "x1",plot.it = TRUE)
pp.obj &lt;- partialPlot(object = boost.grow, xvar.names = "x2",plot.it = TRUE)

##----------------------------------------------------------------------------
## spirometry data
##----------------------------------------------------------------------------
data(spirometry, package = "boostmtree")

#boosting call: cubic B-splines with 15 knots
spr.obj &lt;- boostmtree(spirometry$features, spirometry$time, spirometry$id, spirometry$y,
            family = "Continuous",M = 300, nu = .025, nknots = 15)

#partial plot of double-lung group at 5 years
dltx &lt;- partialPlot(object = spr.obj, xvar.names = "AGE",
                    tm.unq = 5, subset=spr.obj$x$DOUBLE==1,plot.it = TRUE)

#partial plot of single-lung group at 5 years
sltx &lt;- partialPlot(object = spr.obj, xvar.names = "AGE",
                    tm.unq = 5, subset=spr.obj$x$DOUBLE==0,plot.it = TRUE)

#combine the two plots: we use lowess smoothed values
dltx &lt;- dltx$l.obj[[1]]
sltx &lt;- sltx$l.obj[[1]]
plot(range(c(dltx[, 1], sltx[, 1])), range(c(dltx[, -1], sltx[, -1])),
     xlab = "age", ylab = "predicted y (adjusted)", type = "n")
lines(dltx[, 1], dltx[, -1], lty = 1, lwd = 2, col = "red")
lines(sltx[, 1], sltx[, -1], lty = 1, lwd = 2, col = "blue")
legend("topright", legend = c("DLTx", "SLTx"), lty = 1, fill = c(2,4))

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.boostmtree'>Plot Summary Analysis</h2><span id='topic+plot.boostmtree'></span>

<h3>Description</h3>

<p>Plot summary analysis of the boosting analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'boostmtree'
plot(x, use.rmse = TRUE, path_saveplot = NULL, Verbose = TRUE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.boostmtree_+3A_x">x</code></td>
<td>
<p>An object of class <code>(boostmtree, grow)</code> or
<code>(boostmtree, predict)</code>.</p>
</td></tr>
<tr><td><code id="plot.boostmtree_+3A_use.rmse">use.rmse</code></td>
<td>
<p>Report performance values in terms of standardized
root-mean-squared-error (RMSE) or mean-squared-error (MSE)?  Default
is standardized RMSE.</p>
</td></tr>
<tr><td><code id="plot.boostmtree_+3A_path_saveplot">path_saveplot</code></td>
<td>
<p>Provide the location where plot should be saved. By default the plot will be saved at temporary folder.</p>
</td></tr>
<tr><td><code id="plot.boostmtree_+3A_verbose">Verbose</code></td>
<td>
<p>Display the path where the plot is saved?</p>
</td></tr>
<tr><td><code id="plot.boostmtree_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plot summary output, including predicted values and residuals.  Also plots
various parameters against the number of boosting iterations.
</p>


<h3>Author(s)</h3>

<p>Hemant Ishwaran, Amol Pande and Udaya B. Kogalur
</p>


<h3>References</h3>

<p>Pande A., Li L., Rajeswaran J., Ehrlinger J., Kogalur U.B.,
Blackstone E.H., Ishwaran H. (2017).  Boosted multivariate trees for
longitudinal data, <em>Machine Learning</em>, 106(2): 277&ndash;305. 
</p>

<hr>
<h2 id='predict.boostmtree'>Prediction for Boosted multivariate trees for longitudinal data.</h2><span id='topic+predict.boostmtree'></span>

<h3>Description</h3>

<p>Obtain predicted values.  Also returns test-set performance
if the test data contains y-outcomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'boostmtree'
predict(object,
        x,
        tm,
        id,
        y,
        M,
        eps = 1e-5,
        useCVflag = FALSE,
        ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.boostmtree_+3A_object">object</code></td>
<td>
<p>A boosting object of class <code>(boostmtree, grow)</code>.</p>
</td></tr>
<tr><td><code id="predict.boostmtree_+3A_x">x</code></td>
<td>
<p>Data frame (or matrix) containing test set x-values.  Rows
must be duplicated to match the number of time points for an
individual. If missing, the training x values are used and
<code>tm</code>, <code>id</code> and <code>y</code> are not required and no
performance values are returned.</p>
</td></tr>
<tr><td><code id="predict.boostmtree_+3A_tm">tm</code></td>
<td>
<p>Time values for each test set individual with one entry for
each row of <code>x</code>.  Optional, but if missing, the set of unique time
values from the training values are used for each individual and no
test-set performance values are returned.</p>
</td></tr>
<tr><td><code id="predict.boostmtree_+3A_id">id</code></td>
<td>
<p>Unique subject identifier, one entry for each row in
<code>x</code>.  Optional, but if missing, each individual is assumed to
have a full time-profile specified by the unique time values from
the training data.</p>
</td></tr>
<tr><td><code id="predict.boostmtree_+3A_y">y</code></td>
<td>
<p>Test set y-values, with one entry for each row  in <code>x</code>.</p>
</td></tr>
<tr><td><code id="predict.boostmtree_+3A_m">M</code></td>
<td>
<p>Fixed value for the boosting step number.  Leave this empty 
to determine the optimized value obtained by minimizing test-set error.</p>
</td></tr>
<tr><td><code id="predict.boostmtree_+3A_eps">eps</code></td>
<td>
<p>Tolerance value used for determining the optimal <code>M</code>.
For experts only.</p>
</td></tr>
<tr><td><code id="predict.boostmtree_+3A_usecvflag">useCVflag</code></td>
<td>
<p>Should the predicted value be based on the estimate derived from oob sample?</p>
</td></tr>  
<tr><td><code id="predict.boostmtree_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The predicted time profile and performance values are obtained for
test data from the boosted object grown on the training data.
</p>
<p>R-side parallel processing is implemented by replacing the R function
<code>lapply</code> with <code>mclapply</code> found in the <span class="pkg">parallel</span>
package.  You can set the number of cores accessed by
<code>mclapply</code> by issuing the command <code>options(mc.cores =
  x)</code>, where <code>x</code> is the number of cores.  As an example, issuing
the following options command uses all available cores:
</p>
<p><code>options(mc.cores=detectCores())</code>
</p>
<p>However, this can create high RAM usage, especially when using
function <code>partialPlot</code> which calls the <code>predict</code>
function.
</p>
<p>Note that all performance values (for example prediction error) 
are standardized by the overall y-standard deviation.
Thus, reported RMSE (root-mean-squared-error) is actually standardized
RMSE.  Values are reported at the optimal stopping time.
</p>


<h3>Value</h3>

<p>An object of class <code>(boostmtree, predict)</code>, which is a list with the
following components:
</p>
<table>
<tr><td><code>boost.obj</code></td>
<td>
<p>The original boosting object.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>The test x-values, but with only one row per individual
(i.e. duplicated rows are removed).</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>List with each component containing the time
points for a given test individual.</p>
</td></tr>
<tr><td><code>id</code></td>
<td>
<p>Sorted subject identifier.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>List containing the test y-values.</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p>y-values, in the list-format, where nominal or ordinal Response
is converted into the binary response.</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>Family of <code>y</code>.</p>
</td></tr>
<tr><td><code>ymean</code></td>
<td>
<p>Overall mean of y-values for all individuals. If <code>family</code> = 
&quot;Binary&quot;, &quot;Nominal&quot; or &quot;Ordinal&quot;, <code>ymean</code> = 0.</p>
</td></tr>
<tr><td><code>ysd</code></td>
<td>
<p>Overall standard deviation of y-values for all individuals. If <code>family</code> = 
&quot;Binary&quot;, &quot;Nominal&quot; or &quot;Ordinal&quot;, <code>ysd</code> = 1.</p>
</td></tr>
<tr><td><code>xvar.names</code></td>
<td>
<p>X-variable names.</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>Number of terminal nodes.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>Total number of subjects.</p>
</td></tr>
<tr><td><code>ni</code></td>
<td>
<p>Number of repeated measures for each subject.</p>
</td></tr>
<tr><td><code>n.Q</code></td>
<td>
<p>Number of class labels for non-continuous response.</p>
</td></tr>
<tr><td><code>Q_set</code></td>
<td>
<p>Class labels for the non-continuous response.</p>
</td></tr>
<tr><td><code>y.unq</code></td>
<td>
<p>Unique y values for the non-continous response.</p>
</td></tr>
<tr><td><code>nu</code></td>
<td>
<p>Boosting regularization parameter.</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>Design matrix for each subject.</p>
</td></tr>
<tr><td><code>df.D</code></td>
<td>
<p>Number of columns of <code>D</code>.</p>
</td></tr>
<tr><td><code>time.unq</code></td>
<td>
<p>Vector of the unique time points.</p>
</td></tr>
<tr><td><code>baselearner</code></td>
<td>
<p>List of length <em>M</em> containing the base learners.</p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>
<p>List of length <em>M</em>, with each component
containing the boosted tree fitted values.</p>
</td></tr>
<tr><td><code>membership</code></td>
<td>
<p>List of length <em>M</em>, with each component
containing the terminal node membership for a given boosting
iteration.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>Estimated mean profile at the optimized <code>M</code>.</p>
</td></tr>
<tr><td><code>Prob_class</code></td>
<td>
<p>For family == &quot;Ordinal&quot;, this provides individual probabilty rather than
cumulative probabilty.</p>
</td></tr>
<tr><td><code>muhat</code></td>
<td>
<p>Extrapolated mean profile to all unique time points
evaluated at the the optimized <code>M</code>.</p>
</td></tr>
<tr><td><code>Prob_hat_class</code></td>
<td>
<p>Extrapolated <code>Prob_class</code> to all unique time points
evaluated at the the optimized <code>M</code>.</p>
</td></tr>
<tr><td><code>err.rate</code></td>
<td>
<p>Test set standardized l1-error and RMSE.</p>
</td></tr>
<tr><td><code>rmse</code></td>
<td>
<p>Test set standardized RMSE at the optimized <code>M</code>.</p>
</td></tr>
<tr><td><code>Mopt</code></td>
<td>
<p>The optimized <code>M</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hemant Ishwaran, Amol Pande and Udaya B. Kogalur
</p>


<h3>References</h3>

<p>Pande A., Li L., Rajeswaran J., Ehrlinger J., Kogalur U.B.,
Blackstone E.H., Ishwaran H. (2017).  Boosted multivariate trees for
longitudinal data, <em>Machine Learning</em>, 106(2): 277&ndash;305. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.boostmtree">plot.boostmtree</a></code>,
<code><a href="#topic+print.boostmtree">print.boostmtree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##------------------------------------------------------------
## Synthetic example (Response is continuous)
##
##  High correlation, quadratic time with quadratic interaction
##  largish number of noisy variables
##
##  Illustrates how modified gradient improves performance
##  also compares performance to ideal and well specified linear models 
##----------------------------------------------------------------------------

## simulate the data
## simulation 2: main effects (x1, x3, x4), quad-time-interaction (x2)
dtaO &lt;- simLong(n = 100, ntest = 100, model = 2, family = "Continuous", q = 25)

## save the data as both a list and data frame
dtaL &lt;- dtaO$dtaL
dta &lt;- dtaO$dta

## get the training data
trn &lt;- dtaO$trn

## save formulas for linear model comparisons
f.true &lt;- dtaO$f.true
f.linr &lt;- "y~g( x1+x2+x3+x4+x1*time+x2*time+x3*time+x4*time )"


## modified tree gradient (default)
o.1 &lt;- boostmtree(dtaL$features[trn, ], dtaL$time[trn], dtaL$id[trn],dtaL$y[trn],
       family = "Continuous",M = 350)
p.1 &lt;- predict(o.1, dtaL$features[-trn, ], dtaL$time[-trn], dtaL$id[-trn], dtaL$y[-trn])

## non-modified tree gradient (nmtg)
o.2 &lt;- boostmtree(dtaL$features[trn, ], dtaL$time[trn], dtaL$id[trn], dtaL$y[trn],
       family = "Continuous",M = 350, mod.grad = FALSE)
p.2 &lt;- predict(o.2, dtaL$features[-trn, ], dtaL$time[-trn], dtaL$id[-trn], dtaL$y[-trn])

## set rho = 0
o.3 &lt;- boostmtree(dtaL$features[trn, ], dtaL$time[trn], dtaL$id[trn], dtaL$y[trn],
       family = "Continuous",M = 350, rho = 0)
p.3 &lt;- predict(o.3, dtaL$features[-trn, ], dtaL$time[-trn], dtaL$id[-trn], dtaL$y[-trn])


##rmse values compared to generalized least squares (GLS)
##for true model and well specified linear models (LM)
cat("true LM           :", boostmtree:::gls.rmse(f.true,dta,trn),"\n")
cat("well specified LM :", boostmtree:::gls.rmse(f.linr,dta,trn),"\n")
cat("boostmtree        :", p.1$rmse,"\n")
cat("boostmtree  (nmtg):", p.2$rmse,"\n")
cat("boostmtree (rho=0):", p.3$rmse,"\n")

##predicted value plots
plot(p.1)
plot(p.2)
plot(p.3)



##------------------------------------------------------------
## Synthetic example (Response is binary)
##
##  High correlation, quadratic time with quadratic interaction
##  largish number of noisy variables
##----------------------------------------------------------------------------

## simulate the data
## simulation 2: main effects (x1, x3, x4), quad-time-interaction (x2)
dtaO &lt;- simLong(n = 100, ntest = 100, model = 2, family = "Binary", q = 25)

## save the data as both a list and data frame
dtaL &lt;- dtaO$dtaL
dta &lt;- dtaO$dta

## get the training data
trn &lt;- dtaO$trn

## save formulas for linear model comparisons
f.true &lt;- dtaO$f.true
f.linr &lt;- "y~g( x1+x2+x3+x4+x1*time+x2*time+x3*time+x4*time )"


## modified tree gradient (default)
o.1 &lt;- boostmtree(dtaL$features[trn, ], dtaL$time[trn], dtaL$id[trn],dtaL$y[trn],
       family = "Binary",M = 350)
p.1 &lt;- predict(o.1, dtaL$features[-trn, ], dtaL$time[-trn], dtaL$id[-trn], dtaL$y[-trn])


## End(Not run)
</code></pre>

<hr>
<h2 id='print.boostmtree'>Print Summary Output</h2><span id='topic+print.boostmtree'></span>

<h3>Description</h3>

<p>Print summary output from the boosting analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'boostmtree'
print(x, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.boostmtree_+3A_x">x</code></td>
<td>
<p>An object of class <code>(boostmtree, grow)</code> or <code>(boostmtree,
	predict)</code>.</p>
</td></tr>
<tr><td><code id="print.boostmtree_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hemant Ishwaran, Amol Pande and Udaya B. Kogalur
</p>


<h3>References</h3>

<p>Pande A., Li L., Rajeswaran J., Ehrlinger J., Kogalur U.B.,
Blackstone E.H., Ishwaran H. (2017).  Boosted multivariate trees for
longitudinal data, <em>Machine Learning</em>, 106(2): 277&ndash;305. 
</p>

<hr>
<h2 id='simLong'>Simulate longitudinal data</h2><span id='topic+simLong'></span>

<h3>Description</h3>

<p>Simulates longitudinal data with continuous or binary response 
from models with increasing complexity of
covariate-time interactions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simLong(n,
        ntest = 0,
        N = 5,
        rho = 0.8,
        type = c("corCompSym", "corAR1", "corSymm", "iid"),
        model = c(0, 1, 2, 3),
        family = c("Continuous","Binary"),
        phi = 1,
        q = 0,
        ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simLong_+3A_n">n</code></td>
<td>
<p>Requested training sample size.</p>
</td></tr>
<tr><td><code id="simLong_+3A_ntest">ntest</code></td>
<td>
<p>Requested test sample size.</p>
</td></tr>
<tr><td><code id="simLong_+3A_n">N</code></td>
<td>
<p>Parameter controlling number of time points per subject.</p>
</td></tr>
<tr><td><code id="simLong_+3A_rho">rho</code></td>
<td>
<p>Correlation parameter.</p>
</td></tr>
<tr><td><code id="simLong_+3A_type">type</code></td>
<td>
<p>Type of correlation matrix.</p>
</td></tr>
<tr><td><code id="simLong_+3A_model">model</code></td>
<td>
<p>Requested simulation model.</p>
</td></tr>
<tr><td><code id="simLong_+3A_family">family</code></td>
<td>
<p>Family of response <code>y</code>. Use any one from {&quot;Continuous&quot;, &quot;Binary&quot;} based on the scale of <code>y</code>.</p>
</td></tr> 
<tr><td><code id="simLong_+3A_phi">phi</code></td>
<td>
<p>Variance of measurement error.</p>
</td></tr>
<tr><td><code id="simLong_+3A_q">q</code></td>
<td>
<p>Number of zero-signal variables (i.e., variables unrelated to y).</p>
</td></tr>
<tr><td><code id="simLong_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simulates longitudinal data with 3 main effects and (possibly) a covariate-time
interaction.  Complexity of the model is specified using the option <code>model</code>:
</p>

<ol>
<li> <p><em><code>model=0</code>:</em> Linear with no covariate-time interactions.
</p>
</li>
<li> <p><em><code>model=1</code>:</em> Linear covariate-time interaction.
</p>
</li>
<li> <p><em><code>model=2</code>:</em> Quadratic time-quadratic covariate
interaction.
</p>
</li>
<li> <p><em><code>model=3</code>:</em> Quadratic time-quadratic two-way
covariate interaction.
</p>
</li></ol>

<p>For details see Pande et al. (2017).
</p>


<h3>Value</h3>

<p>An invisible list with the following components:
</p>
<table>
<tr><td><code>dtaL</code></td>
<td>
<p>List containing the simulated data in the following order:
<code>features</code>, <code>time</code>, <code>id</code> and <code>y</code>.</p>
</td></tr>
<tr><td><code>dta</code></td>
<td>
<p>Simulated data given as a data frame.</p>
</td></tr>
<tr><td><code>trn</code></td>
<td>
<p>Index of <code>id</code> values identifying the training data.</p>
</td></tr>
<tr><td><code>f.true</code></td>
<td>
<p>Formula of the simulation model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hemant Ishwaran, Amol Pande and Udaya B. Kogalur
</p>


<h3>References</h3>

<p>Pande A., Li L., Rajeswaran J., Ehrlinger J., Kogalur U.B.,
Blackstone E.H., Ishwaran H. (2017).  Boosted multivariate trees for
longitudinal data, <em>Machine Learning</em>, 106(2): 277&ndash;305. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##------------------------------------------------------------
##  Response is continuous
##----------------------------------------------------------------------------

## set the number of boosting iterations
M &lt;- 500

## simulation 0: only main effects (x1, x3, x4)
dta &lt;- simLong(n = 100, ntest = 100, model = 0, family = "Continuous", q = 5)
trn &lt;- dta$trn
dtaL &lt;- dta$dtaL
dta &lt;- dta$dta
obj.0 &lt;-  boostmtree(dtaL$features[trn, ], dtaL$time[trn], dtaL$id[trn], dtaL$y[trn], 
          family = "Continuous", M = M)
pred.0 &lt;- predict(obj.0, dtaL$features[-trn, ], dtaL$time[-trn], dtaL$id[-trn], dtaL$y[-trn])



##------------------------------------------------------------
##  Response is binary
##----------------------------------------------------------------------------

## set the number of boosting iterations
M &lt;- 500

## simulation 0: only main effects (x1, x3, x4)
dta &lt;- simLong(n = 100, ntest = 100, model = 0, family = "Binary", q = 5)
trn &lt;- dta$trn
dtaL &lt;- dta$dtaL
dta &lt;- dta$dta
obj.0 &lt;-  boostmtree(dtaL$features[trn, ], dtaL$time[trn], dtaL$id[trn], dtaL$y[trn], 
          family = "Binary", M = M)
pred.0 &lt;- predict(obj.0, dtaL$features[-trn, ], dtaL$time[-trn], dtaL$id[-trn], dtaL$y[-trn])

## End(Not run)
</code></pre>

<hr>
<h2 id='spirometry'>Spirometry Data</h2><span id='topic+spirometry'></span>

<h3>Description</h3>

<p>Data consists of 9471 longitudinal evaluations of forced 1-second
expiratory volume (FEV1-percentage of predicted) after lung
transplant from 509 patients who underwent lung transplant (LTx) at
the Cleveland Clinic.  Twenty three patient/procedure variables were
collected at the time of the transplant.  The major objectives are
to evaluate the temporal trend of FEV1 after LTx, and to identify
factors associated with post-LTx FEV1 and assessing the differences
in the trends after Single LTx versus Double LTx. 
</p>


<h3>Format</h3>

<p>A list containing four elements:
</p>

<ol>
<li><p>  The 23 patient variables (features).
</p>
</li>
<li><p>  Time points (time).
</p>
</li>
<li><p>  Unique patient identifier (id).
</p>
</li>
<li><p>  FEV1-outcomes (y).
</p>
</li></ol>



<h3>References</h3>

<p>Mason D.P., Rajeswaran J., Li L., Murthy S.C., Su J.W., Pettersson G.B.,
Blackstone E.H. Effect of changes in postoperative spirometry on
survival after lung transplantation. <em>J. Thorac. Cardiovasc. Surg.</em>,
144:197-203, 2012.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(spirometry, package = "boostmtree")</code></pre>

<hr>
<h2 id='vimp.boostmtree'>Variable Importance</h2><span id='topic+vimp.boostmtree'></span>

<h3>Description</h3>

<p>Calculate VIMP score for each of the individual covariates or a joint VIMP
of multiple covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vimp.boostmtree(object,
                x.names = NULL,
                joint = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vimp.boostmtree_+3A_object">object</code></td>
<td>
<p>A boosting object of class <code>(boostmtree, grow)</code> or class <code>(boostmtree, predict)</code>.</p>
</td></tr>
<tr><td><code id="vimp.boostmtree_+3A_x.names">x.names</code></td>
<td>
<p>Names of the x-variables for which VIMP is requested. If NULL, VIMP
is calcuated for all the covariates</p>
</td></tr>
<tr><td><code id="vimp.boostmtree_+3A_joint">joint</code></td>
<td>
<p>Estimate individual VIMP for each covariate from <code>x.names</code> or a joint VIMP
for all covariates combine.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Variable Importance (VIMP) is calcuated for each of the covariates individually or a joint
VIMP is calulated for all the covariates specfied in <code>x.names</code>.
</p>


<h3>Author(s)</h3>

<p>Hemant Ishwaran, Amol Pande and Udaya B. Kogalur
</p>


<h3>References</h3>

<p>Friedman J.H. Greedy function approximation: a gradient
boosting machine, <em>Ann. of Statist.</em>, 5:1189-1232, 2001.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##------------------------------------------------------------
## Synthetic example (Response is continuous)
## VIMP is based on in-sample CV using out of bag data
##-------------------------------------------------------------
#simulate the data
dta &lt;- simLong(n = 50, N = 5, rho =.80, model = 2,family = "Continuous")$dtaL

#basic boosting call
boost.grow &lt;- boostmtree(dta$features, dta$time, dta$id, dta$y,
              family = "Continuous", M = 300,cv.flag = TRUE)
vimp.grow &lt;- vimp.boostmtree(object = boost.grow,x.names=c("x1","x2"),joint = FALSE)
vimp.joint.grow &lt;- vimp.boostmtree(object = boost.grow,x.names=c("x1","x2"),joint = TRUE)

##------------------------------------------------------------
## Synthetic example (Response is continuous)
## VIMP is based on test data
##-------------------------------------------------------------
#simulate the data
dtaO &lt;- simLong(n = 100, ntest = 100, N = 5, rho =.80, model = 2, family = "Continuous")

## save the data as both a list and data frame
dtaL &lt;- dtaO$dtaL
dta &lt;- dtaO$dta

## get the training data
trn &lt;- dtaO$trn

#basic boosting call
boost.grow &lt;- boostmtree(dtaL$features[trn,], dtaL$time[trn], dtaL$id[trn], dtaL$y[trn],
              family = "Continuous", M = 300)
boost.pred &lt;- predict(boost.grow,dtaL$features[-trn,], dtaL$time[-trn], dtaL$id[-trn],
              dtaL$y[-trn])
vimp.pred &lt;- vimp.boostmtree(object = boost.pred,x.names=c("x1","x2"),joint = FALSE)
vimp.joint.pred &lt;- vimp.boostmtree(object = boost.pred,x.names=c("x1","x2"),joint = TRUE)


## End(Not run)
</code></pre>

<hr>
<h2 id='vimpPlot'>
Variable Importance (VIMP) plot
</h2><span id='topic+vimpPlot'></span>

<h3>Description</h3>

<p>Barplot displaying VIMP.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vimpPlot(vimp,
         Q_set = NULL,
         Time_Interaction = TRUE,
         xvar.names = NULL,
         cex.xlab = NULL,
         ymaxlim = 0,
         ymaxtimelim = 0,
         subhead.cexval = 1,
         yaxishead = NULL,
         xaxishead = NULL,
         main = "Variable Importance (%)",
         col = grey(0.8),
         cex.lab = 1.5,
         subhead.labels = c("Time-Interactions Effects", "Main Effects"),
         ylbl = FALSE,
         seplim = NULL,
         eps = 0.1,
         Width_Bar = 1,
         path_saveplot = NULL,
         Verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vimpPlot_+3A_vimp">vimp</code></td>
<td>

<p>VIMP values.
</p>
</td></tr>
<tr><td><code id="vimpPlot_+3A_q_set">Q_set</code></td>
<td>

<p>Provide names for various levels of nominal or ordinal response.
</p>
</td></tr>
<tr><td><code id="vimpPlot_+3A_time_interaction">Time_Interaction</code></td>
<td>

<p>Whether VIMP is estimated from a longitudinal data, in which case VIMP
is available for covariate and covariate-time interaction. Default is TRUE.
If FALSE, VIMP is assumed to be estimated from a cross-sectional data.
</p>
</td></tr>
<tr><td><code id="vimpPlot_+3A_xvar.names">xvar.names</code></td>
<td>

<p>Names of the covariates. If NULL, names are assigned as x1, x2,...,xp.
</p>
</td></tr>
<tr><td><code id="vimpPlot_+3A_cex.xlab">cex.xlab</code></td>
<td>

<p>Magnification of the names of the covariates above (and below) the barplot.
</p>
</td></tr>
<tr><td><code id="vimpPlot_+3A_ymaxlim">ymaxlim</code></td>
<td>

<p>By default, we use the range of the vimp values for the covariates for the ylim. If one wants to
extend the ylim, add the amount with which the ylim will extend above.
</p>
</td></tr>
<tr><td><code id="vimpPlot_+3A_ymaxtimelim">ymaxtimelim</code></td>
<td>

<p>By default, we use the range of the vimp values for the covariates-time for the ylim. If one wants to
extend the ylim, add the amount with which the ylim will extend below. Argument only works for the longitudinal setting.
</p>
</td></tr>
<tr><td><code id="vimpPlot_+3A_subhead.cexval">subhead.cexval</code></td>
<td>

<p>Magnification of the <code>subhead.labels</code>. Argument only works for the longitudinal setting.
</p>
</td></tr>
<tr><td><code id="vimpPlot_+3A_yaxishead">yaxishead</code></td>
<td>

<p>This represent a vector with two values which are points on the y-axis. Corresponding to the values, the lables for <code>subhead.labels</code> is shown. First argument corresponds to covariate-time interaction, whereas second argument is for the main effect. Argument only works for the longitudinal setting.
</p>
</td></tr>
<tr><td><code id="vimpPlot_+3A_xaxishead">xaxishead</code></td>
<td>

<p>This represent a vector with two values which are points on the x-axis. Corresponding to the values, the lables for <code>subhead.labels</code> is shown. First argument corresponds to covariate-time interaction, whereas second argument is for the main effect. Argument only works for the longitudinal setting.</p>
</td></tr>
<tr><td><code id="vimpPlot_+3A_main">main</code></td>
<td>

<p>Main title for the plot.
</p>
</td></tr>
<tr><td><code id="vimpPlot_+3A_col">col</code></td>
<td>

<p>Color of the plot.
</p>
</td></tr>
<tr><td><code id="vimpPlot_+3A_cex.lab">cex.lab</code></td>
<td>

<p>Magnification of the x and y lables.
</p>
</td></tr>
<tr><td><code id="vimpPlot_+3A_subhead.labels">subhead.labels</code></td>
<td>

<p>Labels corresponding to the plot. Default is &quot;Time-Interactions Effects&quot; for the barplot below x-axis, and &quot;Main Effects&quot; for the barplot above x-axis.
</p>
</td></tr>
<tr><td><code id="vimpPlot_+3A_ylbl">ylbl</code></td>
<td>

<p>Should labels for the sub-headings be shown on left side of the y-axis.
</p>
</td></tr>
<tr><td><code id="vimpPlot_+3A_seplim">seplim</code></td>
<td>

<p>if <code>ylbl</code> is <code>TRUE</code>, the distance between the lables of the sub-headings.
</p>
</td></tr>
<tr><td><code id="vimpPlot_+3A_eps">eps</code></td>
<td>

<p>Amount of gap between the top of the barplot and variable names.
</p>
</td></tr>
<tr><td><code id="vimpPlot_+3A_width_bar">Width_Bar</code></td>
<td>

<p>Width of the barplot.
</p>
</td></tr>
<tr><td><code id="vimpPlot_+3A_path_saveplot">path_saveplot</code></td>
<td>
<p>Provide the location where plot should be saved. By default the plot will be saved at temporary folder.</p>
</td></tr>
<tr><td><code id="vimpPlot_+3A_verbose">Verbose</code></td>
<td>
<p>Display the path where the plot is saved?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Barplot displaying VIMP. If the analysis is for the univariate case,
VIMP is displayed above the x-axis. If the analysis is for the
longitudinal case, VIMP for covariates (main effects) are shown above
the x-axis while VIMP for covariate-time interactions (time interaction
effects) are shown below the x-axis. In either case, negative vimp value
is set to zero.
</p>


<h3>Author(s)</h3>

<p>Hemant Ishwaran, Amol Pande and Udaya B. Kogalur
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##------------------------------------------------------------
## Synthetic example
## high correlation, quadratic time with quadratic interaction
##-------------------------------------------------------------
#simulate the data
dta &lt;- simLong(n = 50, N = 5, rho =.80, model = 2,family = "Continuous")$dtaL

#basic boosting call
boost.grow &lt;- boostmtree(dta$features, dta$time, dta$id, dta$y, 
              family = "Continuous",M = 300, cv.flag = TRUE)
vimp.grow &lt;- vimp.boostmtree(object = boost.grow)              

# VIMP plot
vimpPlot(vimp = vimp.grow, ymaxlim = 20, ymaxtimelim = 20,
         xaxishead = c(3,3), yaxishead = c(65,65),
         cex.xlab = 1, subhead.cexval = 1.2)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
