<!DOCTYPE html><html><head><title>Help for package surface</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {surface}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#surface-package'>
<p>Fitting Hansen Models to Investigate Convergent Evolution</p></a></li>
<li><a href='#convertTreeData'>
<p>Utilities for Formatting Objects for SURFACE Analysis</p></a></li>
<li><a href='#getAIC'>
<p>Akaike's Information Criterion for SURFACE Models</p></a></li>
<li><a href='#getBranchTimes'>
<p>Extract Branching Times from an <code>ouch</code> Tree</p></a></li>
<li><a href='#ouchDescendants'>
<p>Obtain Descendants from an <code>ouch</code> Tree</p></a></li>
<li><a href='#propRegMatch'>
<p>Similarity of Two Hansen Models</p></a></li>
<li><a href='#repaint'>
<p>Paint the Branches of a Tree</p></a></li>
<li><a href='#runSurface'>
<p>Run All Steps of a SURFACE Analysis</p></a></li>
<li><a href='#startingModel'>
<p>Create an Initial Model for a SURFACE Analysis</p></a></li>
<li><a href='#surfaceAICPlot'>
<p>Plot the AIC Throughout a SURFACE Analysis</p></a></li>
<li><a href='#surfaceBackward'>
<p>Collapsing Convergent Regimes in a Hansen Model</p></a></li>
<li><a href='#surfaceDemo'>
<p>Tree and Data for Demonstrating SURFACE</p></a></li>
<li><a href='#surfaceForward'>
<p>Adding Regimes to a Hansen Model</p></a></li>
<li><a href='#surfaceSimulate'>
<p>Simulate Data for SURFACE</p></a></li>
<li><a href='#surfaceSummary'>
<p>Summarize SURFACE Output</p></a></li>
<li><a href='#surfaceTreePlot'>
<p>Visualize Results of a SURFACE Analysis</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fitting Hansen Models to Investigate Convergent Evolution</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-12-16</td>
</tr>
<tr>
<td>Author:</td>
<td>Travis Ingram</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Travis Ingram &lt;travis.ingram@otago.ac.nz&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.6), ape, ouch, MASS, geiger</td>
</tr>
<tr>
<td>Suggests:</td>
<td>igraph</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>Description:</td>
<td>This data-driven phylogenetic comparative method fits stabilizing selection models to continuous trait data, building on the 'ouch' methodology of Butler and King (2004) &lt;<a href="https://doi.org/10.1086%2F426002">doi:10.1086/426002</a>&gt;. The main functions fit a series of Hansen models using stepwise AIC, then identify cases of convergent evolution where multiple lineages have shifted to the same adaptive peak. For more information see Ingram and Mahler (2013) &lt;<a href="https://doi.org/10.1111%2F2041-210X.12034">doi:10.1111/2041-210X.12034</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.otago.ac.nz/ecoevotago/code/surface.html">https://www.otago.ac.nz/ecoevotago/code/surface.html</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-12-16 00:00:01 UTC; ingtr64p</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-12-18 13:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='surface-package'>
Fitting Hansen Models to Investigate Convergent Evolution
</h2><span id='topic+surface-package'></span><span id='topic+surface'></span>

<h3>Description</h3>

<p><code>surface</code> provides a wrapper to the <code>ouch</code> package, fitting a series of Hansen multiple-peak stabilizing selection models using stepwise AIC, and identifying cases of convergence where independent lineages discovered the same adaptive peak
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> surface</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.5</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2020-11-10</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;=2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p><code>surface</code> uses the Hansen model of stabilizing selection around multiple adaptive peaks to infer a macroevolutionary adaptive landscape using only trait data and a phylogenetic tree. The most important functions are <code>surfaceForward</code> and <code>surfaceBackward</code>, which carry out the two stepwise phases of the method, and <code>runSurface</code>, a wrapper function that carries out both phases. Results can be displayed using <code>surfaceSummary</code>, and visualized using <code>surfaceTreePlot</code>, <code>surfaceTraitPlot</code>, and <code>surfaceAICPlot</code>. Hypothesis tests, such as whether the extent of convergence exceeds the expectation under a model without true convergence, can be done with the assistance of <code>surfaceSimulate</code>. The vignette &lsquo;surface_tutorial&rsquo; demonstrates the use of the various functions included in the package 
</p>


<h3>Author(s)</h3>

<p>Travis Ingram &lt;travis.ingram@otago.ac.nz&gt;
</p>


<h3>References</h3>

<p>Ingram, T. &amp; Mahler, D.L. (2013) SURFACE: detecting convergent evolution from comparative data by fitting Ornstein-Uhlenbeck models with stepwise AIC. Methods in Ecology and Evolution 4: 416-425. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+runSurface">runSurface</a></code>, <code><a href="#topic+surfaceForward">surfaceForward</a></code>, <code><a href="#topic+surfaceBackward">surfaceBackward</a></code>, <code><a href="#topic+surfaceSimulate">surfaceSimulate</a></code>, <code><a href="#topic+surfaceSummary">surfaceSummary</a></code>, <code><a href="#topic+surfaceTreePlot">surfaceTreePlot</a></code>, <code><a href="#topic+surfaceTraitPlot">surfaceTraitPlot</a></code>, <code><a href="#topic+surfaceAICPlot">surfaceAICPlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#executable R code and demonstrations of the key functions can be found in the tutorial
#vignette("surface_tutorial", package = "surface")
</code></pre>

<hr>
<h2 id='convertTreeData'>
Utilities for Formatting Objects for SURFACE Analysis
</h2><span id='topic+convertTreeData'></span><span id='topic+convertBack'></span><span id='topic+nameNodes'></span>

<h3>Description</h3>

<p><code>convertTreeData</code> converts a <code>phylo</code>-formatted tree and a data frame into formats ready to be analyzed with the <code>ouch</code> functions called by <code>surface</code>. <code>convertBack</code> converts an <code>ouchtree</code> to a data frame including regime information, and is called internally by <code>surfaceTreePlot</code>. <code>nameNodes</code> adds unique node labels to a <code>phylo</code> tree to ensure reliable conversion between formats 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convertTreeData(tree, dat)
convertBack(tree, otree, regshifts)
nameNodes(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convertTreeData_+3A_tree">tree</code></td>
<td>

<p>Phylogenetic tree in <code>phylo</code> format: to ensure reliable conversion, should have node labels (e.g. using <code>nameNodes</code>)
</p>
</td></tr>
<tr><td><code id="convertTreeData_+3A_dat">dat</code></td>
<td>

<p>Data frame with row names corresponding to the taxa in <code>tree</code> and columns consisting of one or more trait measurements
</p>
</td></tr>
<tr><td><code id="convertTreeData_+3A_otree">otree</code></td>
<td>

<p>Phylogenetic tree in <code>ouchtree</code> format
</p>
</td></tr>
<tr><td><code id="convertTreeData_+3A_regshifts">regshifts</code></td>
<td>

<p>Named character vector of regime shifts indicating branches containing shifts (numbered corresponding to <code>otree@nodes</code>) and regime identities (usually lower-case letters)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>convertTreeData</code> returns a list with components <code>otree</code> (a phylogenetic tree in <code>ouchtree</code> format) and <code>odata</code> (a data frame containing trait data, with rownames corresponding to <code>otree@labels</code>). <code>convertBack</code> returns a data frame containing original phenotypic data as well as regime assignments of tip taxa. <code>nameNodes</code> returns the input tree, with arbitrary node names added (<code>zzz1</code>, <code>zzz2</code>, etc) to ensure reliable conversion between formats
</p>


<h3>Author(s)</h3>

<p>Travis Ingram
</p>


<h3>References</h3>

<p>Ingram, T. &amp; Mahler, D.L. (2013) SURFACE: detecting convergent evolution from comparative data by fitting Ornstein-Uhlenbeck models with stepwise AIC. Methods in Ecology and Evolution 4: 416-425. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+surfaceBackward">surfaceBackward</a></code>, <code><a href="#topic+surfaceForward">surfaceForward</a></code>, <code><a href="#topic+surfaceTreePlot">surfaceTreePlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(surfaceDemo)
tree&lt;-surfaceDemo$tree
dat&lt;-surfaceDemo$sim$dat
olist&lt;-convertTreeData(tree,dat)
</code></pre>

<hr>
<h2 id='getAIC'>
Akaike's Information Criterion for SURFACE Models
</h2><span id='topic+getAIC'></span><span id='topic+npSurface'></span>

<h3>Description</h3>

<p>Calculates AICc for a Hansen model using combined likelihoods across multiple traits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAIC(L, np, n, AICc = TRUE)
npSurface(fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAIC_+3A_fit">fit</code></td>
<td>

<p>Fitted Hansen model object (the list returned by one iteration of <code>surfaceForward</code> or <code>surfaceBackward</code>
</p>
</td></tr>
<tr><td><code id="getAIC_+3A_l">L</code></td>
<td>

<p>Log-likelihood of the model
</p>
</td></tr>
<tr><td><code id="getAIC_+3A_np">np</code></td>
<td>

<p>Number of parameters in the model
</p>
</td></tr>
<tr><td><code id="getAIC_+3A_n">n</code></td>
<td>

<p>Sample size (total number of trait values)
</p>
</td></tr>
<tr><td><code id="getAIC_+3A_aicc">AICc</code></td>
<td>

<p>A logical indicating whether to use small-sample size corrected AIC; defaults to <code>TRUE</code>, and is currently set to <code>TRUE</code> during all calls within the <code>surface</code> functions
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of parameters is calculated as p = k + (k' + 2) m, where k is the number of regime shifts, k' is the number of distinct regimes, and m is the number of traits. Note that this differs from many applications of Hansen models, in that SURFACE counts regime shifts as &quot;parameters&quot;, modeling the complexity of both the adaptive landscape (number of regimes) and the evolutionary history of the clade (number of regime shifts). For AICc, the sample size is taken to be the total number of trait values mn, where n is the number of taxa
</p>


<h3>Value</h3>

<p><code>npSurface</code> returns an integer number of parameters. <code>getAIC</code> returns a numeric AIC or AICc value
</p>


<h3>Author(s)</h3>

<p>Travis Ingram
</p>


<h3>References</h3>

<p>Ingram, T. &amp; Mahler, D.L. (2013) SURFACE: detecting convergent evolution from comparative data by fitting Ornstein-Uhlenbeck models with stepwise AIC. Methods in Ecology and Evolution 4: 416-425. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(surfaceDemo)
tree&lt;-surfaceDemo$tree
dat&lt;-surfaceDemo$sim$dat
olist&lt;-convertTreeData(tree,dat)
otree&lt;-olist[[1]]; odata&lt;-olist[[2]]
startmod&lt;-startingModel(otree, odata, shifts = c("6"="b")) 
np&lt;-as.numeric(npSurface(startmod[[1]]))
LnL&lt;-sum(sapply(startmod[[1]]$fit, function(x) summary(x)$loglik))
getAIC(LnL,np,n=ncol(dat)*nrow(dat),AICc=TRUE)
</code></pre>

<hr>
<h2 id='getBranchTimes'>
Extract Branching Times from an <code>ouch</code> Tree
</h2><span id='topic+getBranchTimes'></span>

<h3>Description</h3>

<p>Extracts the time from root of each node in an <code>ouchtree</code> or <code>hansentree</code> formatted phylogenetic tree; used to compute the timing of regime shifts in a Hansen model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBranchTimes(h)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getBranchTimes_+3A_h">h</code></td>
<td>

<p>Fitted <code>ouchtree</code> or <code>hansentree</code> object
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of branching times
</p>


<h3>Author(s)</h3>

<p>Travis Ingram
</p>


<h3>References</h3>

<p>Ingram, T. &amp; Mahler, D.L. (2013) SURFACE: detecting convergent evolution from comparative data by fitting Ornstein-Uhlenbeck models with stepwise AIC. Methods in Ecology and Evolution 4: 416-425. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(surfaceDemo)
tree&lt;-surfaceDemo$tree
dat&lt;-surfaceDemo$sim$dat
olist&lt;-convertTreeData(tree,dat)
otree&lt;-olist[[1]]
getBranchTimes(otree)
</code></pre>

<hr>
<h2 id='ouchDescendants'>
Obtain Descendants from an <code>ouch</code> Tree
</h2><span id='topic+ouchDescendants'></span>

<h3>Description</h3>

<p>Identifies the nodes and tip taxa descended from a given ancestor in an <code>ouchtree</code> or <code>hansentree</code> object. Used to test whether two &lsquo;convergent&rsquo; regimes are actually nested when randomly placing regime shifts in a Hansen model in the function <code>surfaceSimulate</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ouchDescendants(node, otree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ouchDescendants_+3A_node">node</code></td>
<td>

<p>Which node in the ouchtree object to identify the descendants of
</p>
</td></tr>
<tr><td><code id="ouchDescendants_+3A_otree">otree</code></td>
<td>

<p>An <code>ouchtree</code> object
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of integers corresponding to the descendents (integers match the <code>@nodes</code> element of the <code>ouchtree</code>)
</p>


<h3>Author(s)</h3>

<p>Travis Ingram
</p>


<h3>References</h3>

<p>Ingram, T. &amp; Mahler, D.L. (2013) SURFACE: detecting convergent evolution from comparative data by fitting Ornstein-Uhlenbeck models with stepwise AIC. Methods in Ecology and Evolution 4: 416-425. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(surfaceDemo)
tree&lt;-surfaceDemo$tree
dat&lt;-surfaceDemo$sim$dat
olist&lt;-convertTreeData(tree,dat)
otree&lt;-olist[[1]]
ouchDescendants(6, otree)
</code></pre>

<hr>
<h2 id='propRegMatch'>
Similarity of Two Hansen Models
</h2><span id='topic+propRegMatch'></span>

<h3>Description</h3>

<p>Calculates the pairwise matching between two alternate paintings of the same phylogenetic tree. This is done by creating a half-matrix for each <code>hansentree</code> object indicating whether each pairwise comparison of tip species or branches shows they are in the same regime (coded &lsquo;1&rsquo;) or different regimes (coded &lsquo;0&rsquo;). The &lsquo;proportion matching&rsquo; value returned is the proportion of elements of the two matrices that are equal; a measure of correspondence between two Hansen models (one of which may be the &lsquo;true&rsquo; model if data are simulated)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>propRegMatch(fit1, fit2, internal = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="propRegMatch_+3A_fit1">fit1</code></td>
<td>

<p>First fitted Hansen model; can be the <code>$fit</code> component of the list returned by either one iteration of an analyis with <code>surfaceForward</code> or <code>surfaceBackward</code>, or the list returned by <code>surfaceSimulate</code> 
</p>
</td></tr>
<tr><td><code id="propRegMatch_+3A_fit2">fit2</code></td>
<td>

<p>Second fitted Hansen model; see <code>fit1</code>
</p>
</td></tr>
<tr><td><code id="propRegMatch_+3A_internal">internal</code></td>
<td>

<p>A logical indicating whether internal branches should be included in the calculation of matching in addition to tip taxa; this is only possible if the two trees have identical topology; defaults to FALSE
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single value quantifying the proportion of pairwise regime comparisons that are the same between the two models
</p>


<h3>Author(s)</h3>

<p>Travis Ingram
</p>


<h3>References</h3>

<p>Ingram, T. &amp; Mahler, D.L. (2013) SURFACE: detecting convergent evolution from comparative data by fitting Ornstein-Uhlenbeck models with stepwise AIC. Methods in Ecology and Evolution 4: 416-425. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+surfaceForward">surfaceForward</a></code>, <code><a href="#topic+surfaceBackward">surfaceBackward</a></code>, <code><a href="#topic+surfaceSimulate">surfaceSimulate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(surfaceDemo)
tree&lt;-surfaceDemo$tree
dat&lt;-surfaceDemo$sim$dat
olist&lt;-convertTreeData(tree,dat)
otree&lt;-olist[[1]]; odata&lt;-olist[[2]]
startmod&lt;-startingModel(otree, odata, shifts = c("6"="b")) 
startmod2&lt;-startingModel(otree, odata, shifts = c("6"="b","17"="c")) 
propRegMatch(startmod[[1]]$fit, startmod2[[1]]$fit)
</code></pre>

<hr>
<h2 id='repaint'>
Paint the Branches of a Tree
</h2><span id='topic+repaint'></span>

<h3>Description</h3>

<p>A wrapper to the <code>paint</code> function in <code>ouch</code> to ensure that regime paintings are automatically formatted for SURFACE analysis (painting the stem branch of a clade and ensuring that the root is assigned a regime)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repaint(otree, regshifts, stem = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="repaint_+3A_otree">otree</code></td>
<td>

<p>Phylogenetic tree in <code>ouchtree</code> format
</p>
</td></tr>
<tr><td><code id="repaint_+3A_regshifts">regshifts</code></td>
<td>

<p>Named character vector of regime shifts
</p>
</td></tr>
<tr><td><code id="repaint_+3A_stem">stem</code></td>
<td>

<p>A logical indicating whether the painting of a clade should include the stem branch; defaults to <code>TRUE</code>, and is set to <code>TRUE</code> during all calls within the <code>surface</code> functions
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named character vector of regime assignments for each branch, as returned by <code>paint</code>
</p>


<h3>Author(s)</h3>

<p>Travis Ingram
</p>


<h3>References</h3>

<p>Butler, M.A. &amp; King, A.A. (2004) Phylogenetic comparative analysis: a modeling approach for adaptive evolution. American Naturalist 164: 683-695.
</p>
<p>Ingram, T. &amp; Mahler, D.L. (2013) SURFACE: detecting convergent evolution from comparative data by fitting Ornstein-Uhlenbeck models with stepwise AIC. Methods in Ecology and Evolution 4: 416-425. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(surfaceDemo)
tree&lt;-surfaceDemo$tree
dat&lt;-surfaceDemo$sim$dat
olist&lt;-convertTreeData(tree,dat)
otree&lt;-olist[[1]]
repaint(otree, regshifts = c(c("1"="a","6"="b","17"="c")))
</code></pre>

<hr>
<h2 id='runSurface'>
Run All Steps of a SURFACE Analysis
</h2><span id='topic+runSurface'></span>

<h3>Description</h3>

<p>Carries out both the forward and backward phases of SURFACE's stepwise AIC routine, with sensible default behaviors. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runSurface(tree, dat, exclude = 0, aic_threshold = 0, max_steps = NULL, 
verbose = FALSE, plotaic = FALSE, error_skip = FALSE, only_best = FALSE,
sample_shifts=FALSE, sample_threshold = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runSurface_+3A_tree">tree</code></td>
<td>

<p>Phylogenetic tree in <code>phylo</code> format
</p>
</td></tr>
<tr><td><code id="runSurface_+3A_dat">dat</code></td>
<td>

<p>Data frame with taxa names as rownames matching the tip labels of <code>tree</code>, and one or more columns of trait data
</p>
</td></tr>
<tr><td><code id="runSurface_+3A_exclude">exclude</code></td>
<td>

<p>Optionally, the proportion of the worst models (AICc scores for each shift point) to exclude in the current round of the forward phase (defaults to zero)
</p>
</td></tr>
<tr><td><code id="runSurface_+3A_aic_threshold">aic_threshold</code></td>
<td>

<p>Change in AICc needed to accept a candidate model as a sufficient improvement over the previous iteration of SURFACE. Defaults to zero, meaning any improvement in the AICc will be accepted; more stringent thresholds are specified using *negative* values of <code>aic_threshold</code>
</p>
</td></tr>
<tr><td><code id="runSurface_+3A_max_steps">max_steps</code></td>
<td>

<p>Maximum number of steps to allow to allow each phase to carry out (assuming the model improvement continues to exceed <code>aic_threshold</code>)
</p>
</td></tr>
<tr><td><code id="runSurface_+3A_verbose">verbose</code></td>
<td>

<p>A logical indicating whether to print progress (defaults to <code>FALSE</code>)
</p>
</td></tr>
<tr><td><code id="runSurface_+3A_plotaic">plotaic</code></td>
<td>

<p>A logical indicating whether to plot AICc values of all candidate models at each step (defaults to <code>FALSE</code>)
</p>
</td></tr>
<tr><td><code id="runSurface_+3A_only_best">only_best</code></td>
<td>

<p>A logical indicating whether to only allow one pair of regimes to be collapsed at each iteration; if <code>FALSE</code>, <code>igraph</code> functions are used to identify pairs of regimes that can be collapsed to improve the model without any inconsistencies (defaults to <code>FALSE</code>)
</p>
</td></tr>
<tr><td><code id="runSurface_+3A_error_skip">error_skip</code></td>
<td>

<p>A logical indicating whether to skip over any candidate model that produces an error message during likelihood optimization (this is rare, but can cause an entire analysis to abort; defaults to <code>FALSE</code>) 
</p>
</td></tr>
<tr><td><code id="runSurface_+3A_sample_shifts">sample_shifts</code></td>
<td>

<p>A logical indicating whether to randomly sample from among the best models at each step (those within <code>sample_threshold</code> of the best AICc), rather than deterministically selecting the best candidate model (defaults to <code>FALSE</code>)
</p>
</td></tr>
<tr><td><code id="runSurface_+3A_sample_threshold">sample_threshold</code></td>
<td>

<p>Number of AICc units within which to sample among candidate models that are close to as good as the best model at each step (defaults to 2, but only used if <code>sample_shifts=TRUE</code>, and only used in the backward phase if <code>only_best=TRUE</code>)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Carries out all steps of SURFACE, including converting data structures and running both forward and backward phases of the analysis. The default behavior should be appropriate in most circumstances, but some functionalities require using the functions <code>surfaceForward</code> and <code>surfaceBackward</code> that are called by <code>runSurface</code>
</p>


<h3>Value</h3>

<p>A list with two elements, <code>fwd</code> and <code>bwd</code>. 
</p>
<table>
<tr><td><code>fwd</code></td>
<td>
<p>The results of the forward phase, as returned by <code>surfaceForward</code> </p>
</td></tr>
<tr><td><code>bwd</code></td>
<td>
<p>The results of the backward phase, as returned by <code>surfaceBackward</code> </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Travis Ingram
</p>


<h3>References</h3>

<p>Butler, M.A. &amp; King, A.A. (2004) Phylogenetic comparative analysis: a modeling approach for adaptive evolution. American Naturalist 164: 683-695.
</p>
<p>Ingram, T. &amp; Mahler, D.L. (2013) SURFACE: detecting convergent evolution from comparative data by fitting Ornstein-Uhlenbeck models with stepwise AIC. Methods in Ecology and Evolution 4: 416-425. 
</p>
<p>Mahler, D.L., Ingram, T., Revell, L.J. &amp; Losos, J.B. (2013) Exceptional convergence on the macroevolutionary landscape in island lizard radiations. Science 341: 292-295.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+surfaceBackward">surfaceBackward</a></code>, <code><a href="#topic+surfaceForward">surfaceForward</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	## Not run: 
data(surfaceDemo)
tree&lt;-surfaceDemo$tree
dat&lt;-surfaceDemo$sim$dat
result&lt;-runSurface(tree,dat)
	
## End(Not run)
</code></pre>

<hr>
<h2 id='startingModel'>
Create an Initial Model for a SURFACE Analysis
</h2><span id='topic+startingModel'></span>

<h3>Description</h3>

<p>Generate a model to start a SURFACE analysis, or fit specific Hansen or Brownian motion models that can be compared to the models returned by SURFACE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>startingModel(otree, odata, shifts = NULL, brownian = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="startingModel_+3A_otree">otree</code></td>
<td>

<p>Phylogenetic tree in <code>ouchtree</code> format
</p>
</td></tr>
<tr><td><code id="startingModel_+3A_odata">odata</code></td>
<td>

<p>Data frame with rownames corresponding to <code>otree@labels</code>
</p>
</td></tr>
<tr><td><code id="startingModel_+3A_shifts">shifts</code></td>
<td>

<p>A named character vector of regime shifts. Names should correspond to <code>otree@nodes</code>, and regime assignments can be any character other than <code>"a"</code> (see details). Defaults to <code>NULL</code>, in which case a single-regime OU model is returned. 
</p>
</td></tr>
<tr><td><code id="startingModel_+3A_brownian">brownian</code></td>
<td>

<p>A logical indicating whether to return the fitted Brownian motion model for the data set by calling the <code>ouch</code> function <code>brown</code> and obtaining AICs by adding log-likelihoods across traits. If TRUE, overrides any specified <code>shifts</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For most analysis, this function is not accessed by the user, but is called from within <code>surfaceForward</code> to initialize the run with a single-regime OU model. However, the user can optionally supply a starting model that imposes some regime shifts  (e.g. if there is strong a priori reason to include them, or to evaluate how their inclusion changes the result of SURFACE analysis). If <code>shifts</code> are supplied, they are always modified so that the first element codes a basal regime 'shift' <code>c("1"="a")</code>. Thus, if any other element in <code>shifts</code> is specified as regime <code>"a"</code>, or has name <code>"1"</code>, an error will be returned. <code>startingModel</code> can also be used to obtain a fit (with AICc calculated after adding log-likelihoods across traits) for any hypothesized Hansen model or for Brownian motion (if <code>brownian=TRUE</code>) for comparison with models returned by SURFACE
</p>


<h3>Value</h3>

<p>A list of length 1 containing an object with the same structure as the lists returned by each iteration of <code>surfaceForward</code> and <code>surfaceBackward</code> (containing elements <code>fit</code>, <code>all_aic</code>, <code>aic</code>, <code>savedshifts</code>, and <code>n_regimes</code>). This allows it to be supplied as argument <code>starting_list</code> in a call to <code>surfaceForward</code>. 
</p>


<h3>Author(s)</h3>

<p>Travis Ingram
</p>


<h3>References</h3>

<p>Ingram, T. &amp; Mahler, D.L. (2013) SURFACE: detecting convergent evolution from comparative data by fitting Ornstein-Uhlenbeck models with stepwise AIC. Methods in Ecology and Evolution 4: 416-425. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+surfaceForward">surfaceForward</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(surfaceDemo)
tree&lt;-surfaceDemo$tree
dat&lt;-surfaceDemo$sim$dat
olist&lt;-convertTreeData(tree,dat)
otree&lt;-olist[[1]]; odata&lt;-olist[[2]]
startmod&lt;-startingModel(otree, odata, shifts = c("6"="b")) 
</code></pre>

<hr>
<h2 id='surfaceAICPlot'>
Plot the AIC Throughout a SURFACE Analysis
</h2><span id='topic+surfaceAICPlot'></span><span id='topic+surfaceAICMultiPlot'></span>

<h3>Description</h3>

<p>Plots a line graph showing how the AICc changed over the forward and backward phases of a SURFACE analysis. <code>surfaceAICPlot</code> can optionally show the change in the deviance or 'partial AICc' for each trait separately as well as for the analysis as a whole. <code>surfaceAICMultiPlot</code> plots lines from multiple runs on the same plot, allowing comparison among analyses done on alternate tree topologies or with stochasticity added using <code>sample_shifts</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surfaceAICPlot(fwd = NULL, bwd = NULL, out = NULL, summ = NULL, 
traitplot = "none", cols = NULL, daic = FALSE,  ...)
surfaceAICMultiPlot(fwd = NULL, bwd = NULL, out = NULL, summ = NULL, 
cols = NULL, daic = FALSE,  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surfaceAICPlot_+3A_fwd">fwd</code></td>
<td>

<p>List resulting from a <code>surfaceForward</code> run, or a list of such lists if calling <code>surfaceAICMultiPlot</code>
</p>
</td></tr>
<tr><td><code id="surfaceAICPlot_+3A_bwd">bwd</code></td>
<td>

<p>List resulting from a <code>surfaceBackward</code> run, or a list of such lists if calling <code>surfaceAICMultiPlot</code>
</p>
</td></tr>
<tr><td><code id="surfaceAICPlot_+3A_out">out</code></td>
<td>

<p>List resulting from a <code>runSurface</code> run, consisting of elements <code>fwd</code> and <code>bwd</code>, or a list of such lists if calling <code>surfaceAICMultiPlot</code>
</p>
</td></tr>
<tr><td><code id="surfaceAICPlot_+3A_summ">summ</code></td>
<td>

<p>Object returned by <code>surfaceSummary</code> (run on the forward and backward phases of an analysis together), or a list of such objects if calling <code>surfaceAICMultiPlot</code>
</p>
</td></tr>
<tr><td><code id="surfaceAICPlot_+3A_traitplot">traitplot</code></td>
<td>

<p>String indicating what values to use to draw lines corresponding to individual traits: <code>"none"</code>, <code>"dev"</code> or <code>"aic"</code> (see details); defaults to <code>"none"</code>  
</p>
</td></tr>
<tr><td><code id="surfaceAICPlot_+3A_cols">cols</code></td>
<td>

<p>An optional character vector of colors for the AICc lines, used to color the different runs in <code>surfaceAICMultiPlot</code>. Only used in <code>surfaceAICPlot</code> if <code>traitplot = "aic"</code> or <code>traitplot = "dev"</code>, in which case the colors are used for the trait lines (the overall AICc line is drawn in black)
</p>
</td></tr>
<tr><td><code id="surfaceAICPlot_+3A_daic">daic</code></td>
<td>

<p>A logical indicating whether to rescale all delta-AICc (and delta-deviance) values to the value from the starting model; defaults to <code>FALSE</code>, but is automatically set to <code>TRUE</code> if <code>traitplot = "aic"</code> or <code>traitplot = "dev"</code>
</p>
</td></tr>
<tr><td><code id="surfaceAICPlot_+3A_...">...</code></td>
<td>

<p>Additional arguments to be passed to the <code>plot</code> or <code>points</code> functions
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If values are plotted on a trait-by-trait basis, either <code>traitplot="dev"</code> or <code>traitplot="aic"</code> can be specified. If <code>traitplot="dev"</code>, the deviance (-2*log likelihood) at each step is shown for each trait. If <code>traitplot="aic"</code>, a &quot;partial AICc&quot; at each step is shown for each of the <code>m</code> traits, consisting of the deviance and 1/m of the &quot;penalty&quot; part of the overall AICc, where m is the number of traits. Note that this is not a proper statistical construct, but its property of adding to give the overall AICc can be useful in visualizing the patterns among traits
</p>


<h3>Value</h3>

<p>Plots AIC values from a SURFACE analysis on the current graphics device
</p>


<h3>Author(s)</h3>

<p>Travis Ingram
</p>


<h3>References</h3>

<p>Ingram, T. &amp; Mahler, D.L. (2013) SURFACE: detecting convergent evolution from comparative data by fitting Ornstein-Uhlenbeck models with stepwise AIC. Methods in Ecology and Evolution 4: 416-425. 
</p>
<p>Mahler, D.L., Ingram, T., Revell, L.J. &amp; Losos, J.B. (2013) Exceptional convergence on the macroevolutionary landscape in island lizard radiations. Science 341: 292-295.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+surfaceForward">surfaceForward</a></code>, <code><a href="#topic+surfaceBackward">surfaceBackward</a></code>, <code><a href="#topic+surfaceSimulate">surfaceSimulate</a></code>, <code><a href="#topic+surfaceSummary">surfaceSummary</a></code>, <code><a href="#topic+surfaceTreePlot">surfaceTreePlot</a></code>, <code><a href="#topic+surfaceTraitPlot">surfaceTraitPlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	## Not run: 
data(surfaceDemo)
tree&lt;-surfaceDemo$tree
dat&lt;-surfaceDemo$sim$dat
result&lt;-runSurface(tree,dat)
surfaceAICPlot(result$fwd,result$bwd)
	
## End(Not run)
</code></pre>

<hr>
<h2 id='surfaceBackward'>
Collapsing Convergent Regimes in a Hansen Model
</h2><span id='topic+surfaceBackward'></span><span id='topic+collapseRegimes'></span>

<h3>Description</h3>

<p>Carries out the backward phase of SURFACE's stepwise AIC routine. Beginning with a fitted Hansen model produced by <code>surfaceForward</code>, tests pairwise collapses of regimes and identifies collapses that improve the fit. Continues this iterative process until the model stops improving beyond the given AIC threshold
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surfaceBackward(otree, odata, starting_model, aic_threshold = 0, 
max_steps = NULL, save_steps = FALSE, filename = "temp_back_list.R", 
verbose = FALSE, only_best = FALSE, plotaic = FALSE, 
error_skip = FALSE, sample_shifts = FALSE, sample_threshold = 2)
collapseRegimes(otree, odata, oldshifts, oldaic, oldfit, aic_threshold = 0, 
only_best = FALSE, verbose = TRUE, plotaic = TRUE, error_skip = FALSE, 
sample_shifts = FALSE, sample_threshold = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surfaceBackward_+3A_otree">otree</code></td>
<td>

<p>Phylogenetic tree in <code>ouchtree</code> format
</p>
</td></tr>
<tr><td><code id="surfaceBackward_+3A_odata">odata</code></td>
<td>

<p>Data frame with rownames corresponding to <code>otree@labels</code>
</p>
</td></tr>
<tr><td><code id="surfaceBackward_+3A_starting_model">starting_model</code></td>
<td>

<p>The Hansen model to attempt regime collapses on; typically the final element of a <code>surfaceForward</code> analysis
</p>
</td></tr>
<tr><td><code id="surfaceBackward_+3A_aic_threshold">aic_threshold</code></td>
<td>

<p>Change in AICc needed to accept a candidate model as a sufficient improvement over the previous iteration of SURFACE. Defaults to zero, meaning any improvement in the AICc will be accepted; more stringent thresholds are specified using *negative* values of <code>aic_threshold</code>
</p>
</td></tr>
<tr><td><code id="surfaceBackward_+3A_max_steps">max_steps</code></td>
<td>

<p>Maximum number of steps in the backward phase to carry out (assuming the model improvement continues to exceed <code>aic_threshold</code>)
</p>
</td></tr>
<tr><td><code id="surfaceBackward_+3A_save_steps">save_steps</code></td>
<td>

<p>A logical indicating whether to save the current iteration of the model at each step (overwriting if necessary) to a file <code>filename</code> (defaults to <code>FALSE</code>)
</p>
</td></tr>
<tr><td><code id="surfaceBackward_+3A_filename">filename</code></td>
<td>

<p>Name of the file to save progress to at each step, if <code>savesteps=TRUE</code>
</p>
</td></tr>
<tr><td><code id="surfaceBackward_+3A_verbose">verbose</code></td>
<td>

<p>A logical indicating whether to print progress (defaults to <code>FALSE</code>)
</p>
</td></tr>
<tr><td><code id="surfaceBackward_+3A_only_best">only_best</code></td>
<td>

<p>A logical indicating whether to only allow one pair of regimes to be collapsed at each iteration; if <code>FALSE</code>, <code>igraph</code> functions are used to identify pairs of regimes that can be collapsed to improve the model without any inconsistencies (defaults to <code>FALSE</code>)
</p>
</td></tr>
<tr><td><code id="surfaceBackward_+3A_plotaic">plotaic</code></td>
<td>

<p>A logical indicating whether to plot AICc values of candidate models at each step (defaults to <code>FALSE</code>)
</p>
</td></tr>
<tr><td><code id="surfaceBackward_+3A_error_skip">error_skip</code></td>
<td>

<p>A logical indicating whether to skip over any candidate model that produces an error message (this is rare, but can cause an entire analysis to abort; defaults to <code>FALSE</code>) 
</p>
</td></tr>
<tr><td><code id="surfaceBackward_+3A_sample_shifts">sample_shifts</code></td>
<td>

<p>A logical indicating whether to sample from among the best models at each step (those within <code>sample_threshold</code> of the best AICc), rather than always selecting the best candidate model (defaults to <code>FALSE</code>; both <code>sample_shifts</code> and <code>only_best</code> must be set to <code>TRUE</code> to use this option during the backward phase
</p>
</td></tr>
<tr><td><code id="surfaceBackward_+3A_sample_threshold">sample_threshold</code></td>
<td>

<p>Number of AICc units within which to sample among candidate models that are close to as good as the best model at each step (defaults to 2, but only used if <code>sample_shifts=TRUE</code> and <code>only_best=TRUE</code>)
</p>
</td></tr>
<tr><td><code id="surfaceBackward_+3A_oldshifts">oldshifts</code></td>
<td>

<p>Shifts present in the previous iteration of the Hansen model
</p>
</td></tr>
<tr><td><code id="surfaceBackward_+3A_oldaic">oldaic</code></td>
<td>

<p>AICc value for the Hansen model from the previous iteration
</p>
</td></tr>
<tr><td><code id="surfaceBackward_+3A_oldfit">oldfit</code></td>
<td>

<p>Previous fitted Hansen model
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Can be time-consuming, as the number of likelihood searches at a step is <code>k(k-1)/2</code>, where <code>k</code> is the number of regimes in the model. 
</p>


<h3>Value</h3>

<p><code>collapseRegime</code> returns a list corresponding to one iteration of the backward phase of the SURFACE analysis; <code>surfaceBackward</code> returns a list of such lists consisting of each step of the stepwise process
</p>
<table>
<tr><td><code>fit</code></td>
<td>
<p>The fitted Hansen model selected for improving the AICc most over the previous iteration; consists of a single <code>hansentree</code> object if the number of traits <code>m = 1</code>, or a list of <code>hansentree</code> objects if <code>m &gt; 1</code> </p>
</td></tr>
<tr><td><code>all_aic</code></td>
<td>
<p>The AICc for each model tested during the iteration (one per pair of regimes)</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>The AICc of the current Hansen model</p>
</td></tr>
<tr><td><code>savedshifts</code></td>
<td>
<p>The shifts present in the current Hansen model; represented as a named character vector of regime assignments (lower-case letters), with names indicating branches containing shifts</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Travis Ingram
</p>


<h3>References</h3>

<p>Butler, M.A. &amp; King, A.A. (2004) Phylogenetic comparative analysis: a modeling approach for adaptive evolution. American Naturalist 164: 683-695.
</p>
<p>Ingram, T. &amp; Mahler, D.L. (2013) SURFACE: detecting convergent evolution from comparative data by fitting Ornstein-Uhlenbeck models with stepwise AIC. Methods in Ecology and Evolution 4: 416-425. 
</p>
<p>Mahler, D.L., Ingram, T., Revell, L.J. &amp; Losos, J.B. (2013) Exceptional convergence on the macroevolutionary landscape in island lizard radiations. Science 341: 292-295.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+surfaceForward">surfaceForward</a></code>, <code><a href="#topic+surfaceSimulate">surfaceSimulate</a></code>, <code><a href="#topic+surfaceTreePlot">surfaceTreePlot</a></code>, <code><a href="#topic+surfaceSummary">surfaceSummary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	## Not run: 
data(surfaceDemo)
tree&lt;-surfaceDemo$tree
dat&lt;-surfaceDemo$sim$dat
olist&lt;-convertTreeData(tree,dat)
otree&lt;-olist[[1]]; odata&lt;-olist[[2]]
fwd&lt;-surfaceForward(otree, odata, aic_threshold = 0, exclude = 0, verbose = FALSE, plotaic = FALSE)
k&lt;-length(fwd)
bwd&lt;-surfaceBackward(otree, odata, starting_model = fwd[[k]], aic_threshold = 0)
	
## End(Not run)
</code></pre>

<hr>
<h2 id='surfaceDemo'>
Tree and Data for Demonstrating SURFACE
</h2><span id='topic+surfaceDemo'></span>

<h3>Description</h3>

<p>This simulated tree and data set can be used to demonstrate the functionality of SURFACE. The vignette &lsquo;surface_tutorial&rsquo; demonstrates the use of the various functions included in the package using <code>surfaceDemo</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(surfaceDemo)</code></pre>


<h3>Format</h3>

<p>A list containing a tree in <code>phylo</code> format (<code>surfaceDemo$tree</code>), and a list <code>surfaceDemo$sim</code>, which contains trait data (<code>surfaceDemo$sim$data</code>) and the other features output by <code>surfaceSimulate</code>, including the generating Hansen model (<code>surfaceDemo$sim$fit</code>)
</p>


<h3>Source</h3>

<p>simulated data</p>


<h3>References</h3>

<p>Ingram, T. &amp; Mahler, D.L. (2013) SURFACE: detecting convergent evolution from comparative data by fitting Ornstein-Uhlenbeck models with stepwise AIC. Methods in Ecology and Evolution 4: 416-425. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(surfaceDemo)
tree&lt;-surfaceDemo$tree
dat&lt;-surfaceDemo$sim$dat
</code></pre>

<hr>
<h2 id='surfaceForward'>
Adding Regimes to a Hansen Model
</h2><span id='topic+surfaceForward'></span><span id='topic+addRegime'></span>

<h3>Description</h3>

<p>Carries out the forward phase of SURFACE's stepwise AIC routine, adding regime shifts to a Hansen model. <code>addRegime</code> performs one step of this analysis, and is called repeatedly by <code>surfaceForward</code>. At each step, the delta-AICc of each possible shift placement (i.e. branch) is calculated, and an updated Hansen model is returned with one shift added. This process is iterated until the model stops improving beyond a threshold delta-AICc
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surfaceForward(otree, odata, starting_list=NULL, starting_shifts=NULL, 
exclude=0,  aic_threshold=0, max_steps=NULL, save_steps=FALSE, 
filename="temp_out_list.R", verbose=FALSE, plotaic=FALSE, 
error_skip=FALSE, sample_shifts=FALSE, sample_threshold=2)
addRegime(otree, odata, oldshifts, oldaic, oldfit, alloldaic=NULL, 
exclude=NULL, aic_threshold=0, verbose=FALSE, plotaic=FALSE, 
error_skip=FALSE, sample_shifts=FALSE, sample_threshold=2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surfaceForward_+3A_otree">otree</code></td>
<td>

<p>Phylogenetic tree in <code>ouchtree</code> format
</p>
</td></tr>
<tr><td><code id="surfaceForward_+3A_odata">odata</code></td>
<td>

<p>Data frame with rownames corresponding to <code>otree@labels</code>
</p>
</td></tr>
<tr><td><code id="surfaceForward_+3A_starting_list">starting_list</code></td>
<td>

<p>An optional list which may containing either a partially completed analysis (which can be built upon instead of starting over), or a custom starting model created with <code>startingModel</code>, which may include some pre-specified shifts 
</p>
</td></tr>
<tr><td><code id="surfaceForward_+3A_starting_shifts">starting_shifts</code></td>
<td>

<p>An optional named character vector of shifts that are required to be in the Hansen model, which will be passed to <code>startingModel</code> when the initial model is built 
</p>
</td></tr>
<tr><td><code id="surfaceForward_+3A_exclude">exclude</code></td>
<td>

<p>Optionally, the proportion of the worst models (AICc scores for each shift point) to exclude in the current round (defaults to zero; values greater than 0.5 are not recommended)
</p>
</td></tr>
<tr><td><code id="surfaceForward_+3A_aic_threshold">aic_threshold</code></td>
<td>

<p>Change in AICc needed to accept a candidate model as a sufficient improvement over the previous iteration of SURFACE. Defaults to zero, meaning any improvement in the AICc will be accepted; more stringent thresholds are specified using *negative* values of <code>aic_threshold</code>
</p>
</td></tr>
<tr><td><code id="surfaceForward_+3A_max_steps">max_steps</code></td>
<td>

<p>Maximum number of regimes to allow to be added (assuming the model improvement continues to exceed <code>aic_threshold</code>)
</p>
</td></tr>
<tr><td><code id="surfaceForward_+3A_save_steps">save_steps</code></td>
<td>

<p>A logical indicating whether to save the current iteration of the model at each step (overwriting previous iterations) to a file <code>filename</code> (defaults to <code>FALSE</code>)
</p>
</td></tr>
<tr><td><code id="surfaceForward_+3A_filename">filename</code></td>
<td>

<p>Name of the file to save progress to at each step, if <code>savesteps=TRUE</code>
</p>
</td></tr>
<tr><td><code id="surfaceForward_+3A_verbose">verbose</code></td>
<td>

<p>A logical indicating whether to print progress (defaults to <code>FALSE</code>)
</p>
</td></tr>
<tr><td><code id="surfaceForward_+3A_plotaic">plotaic</code></td>
<td>

<p>A logical indicating whether to plot AICc values of candidate models at each step (defaults to <code>FALSE</code>)
</p>
</td></tr>
<tr><td><code id="surfaceForward_+3A_error_skip">error_skip</code></td>
<td>

<p>A logical indicating whether to skip over any candidate model that produces an error message (this is rare, but can cause an entire analysis to abort; defaults to <code>FALSE</code>) 
</p>
</td></tr>
<tr><td><code id="surfaceForward_+3A_sample_shifts">sample_shifts</code></td>
<td>

<p>A logical indicating whether to sample from among the best models at each step (those within <code>sample_threshold</code> of the best AICc), rather than always selecting the best candidate model (defaults to <code>FALSE</code>)
</p>
</td></tr>
<tr><td><code id="surfaceForward_+3A_sample_threshold">sample_threshold</code></td>
<td>

<p>Number of AICc units within which to sample among candidate models that are close to as good as the best model at each step (defaults to 2, but only used if <code>sample_shifts=TRUE</code>)
</p>
</td></tr>
<tr><td><code id="surfaceForward_+3A_oldshifts">oldshifts</code></td>
<td>

<p>Any shifts present in the previous iteration of the Hansen model
</p>
</td></tr>
<tr><td><code id="surfaceForward_+3A_oldaic">oldaic</code></td>
<td>

<p>AICc value for the Hansen model from the previous iteration
</p>
</td></tr>
<tr><td><code id="surfaceForward_+3A_oldfit">oldfit</code></td>
<td>

<p>Previous fitted Hansen model
</p>
</td></tr>
<tr><td><code id="surfaceForward_+3A_alloldaic">alloldaic</code></td>
<td>

<p>AICc values for each tested shift point in the previous iteration
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Can be time-consuming, as many likelihood searches are carried out at each iteration. Depending on the number of traits and taxa and the number of regimes that are fitted, <code>surfaceForward</code> can take anywhere from minutes to many hours (only tree sizes up to 128 taxa have been tested). Options to manage computation time include adding regimes one at a time with <code>addRegime</code> or using <code>max_steps</code> to perform the analysis several iterations at a time
</p>


<h3>Value</h3>

<p><code>addRegime</code> returns a list describing one iteration of the forward phase of the SURFACE analysis; <code>surfaceForward</code> returns a list of such lists consisting of each step of the stepwise process
</p>
<table>
<tr><td><code>fit</code></td>
<td>
<p>The fitted Hansen model selected for improving the AICc most over the previous iteration; consists of a single <code>hansentree</code> object if the number of traits <code>m = 1</code>, or a list of <code>hansentree</code> objects if <code>m &gt; 1</code> </p>
</td></tr>
<tr><td><code>all_aic</code></td>
<td>
<p>The AICc for each model tested during the iteration (numbered by branch)</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>The AICc of the current Hansen model</p>
</td></tr>
<tr><td><code>savedshifts</code></td>
<td>
<p>The shifts present in the current Hansen model; represented as a named character vector of regime shifts (lower-case letters), with names indicating branches containing shifts</p>
</td></tr> 
<tr><td><code>n_regimes</code></td>
<td>
<p>A two-element vector of the number of regime shifts and the number of distinct regimes in the current model</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Travis Ingram
</p>


<h3>References</h3>

<p>Butler, M.A. &amp; King, A.A. (2004) Phylogenetic comparative analysis: a modeling approach for adaptive evolution. American Naturalist 164: 683-695.
</p>
<p>Ingram, T. &amp; Mahler, D.L. (2013) SURFACE: detecting convergent evolution from comparative data by fitting Ornstein-Uhlenbeck models with stepwise AIC. Methods in Ecology and Evolution 4: 416-425. 
</p>
<p>Mahler, D.L., Ingram, T., Revell, L.J. &amp; Losos, J.B. (2013) Exceptional convergence on the macroevolutionary landscape in island lizard radiations. Science 341: 292-295.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+surfaceBackward">surfaceBackward</a></code>, <code><a href="#topic+surfaceSimulate">surfaceSimulate</a></code>, <code><a href="#topic+surfaceTreePlot">surfaceTreePlot</a></code>, <code><a href="#topic+surfaceSummary">surfaceSummary</a></code>, <code><a href="#topic+convertTreeData">convertTreeData</a></code>, <code><a href="#topic+startingModel">startingModel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	## Not run: 
data(surfaceDemo)
tree&lt;-surfaceDemo$tree
dat&lt;-surfaceDemo$sim$dat
olist&lt;-convertTreeData(tree,dat)
otree&lt;-olist[[1]]; odata&lt;-olist[[2]]
fwd&lt;-surfaceForward(otree, odata, aic_threshold = 0, exclude = 0)
	
## End(Not run)
</code></pre>

<hr>
<h2 id='surfaceSimulate'>
Simulate Data for SURFACE
</h2><span id='topic+surfaceSimulate'></span>

<h3>Description</h3>

<p>Provides several ways to simulate data sets on phylogenetic trees in conjunction with SURFACE analyses. Can simulate under simple models without regime shifts, under a Hansen model with sampled shift locations, or under a fitted Hansen model (optionally with resampled optima)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surfaceSimulate(phy, type = "BM", param = 0, n_traits = NULL, dat = NULL, 
vcv = NULL, hansenfit = NULL, shifts = NULL, n_shifts = NULL, 
n_conv_shifts = NULL, n_regimes = NULL, n_per_regime = NULL, 
no_nested = TRUE, optima = NULL, sample_optima = TRUE, 
optima_distrib = NULL, optima_type = "rnorm", sigma_squared = NULL, 
alpha = NULL, pshift_timefactor = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surfaceSimulate_+3A_phy">phy</code></td>
<td>

<p>A phylogenetic tree in <code>phylo</code> format on which to simulate data
</p>
</td></tr>
<tr><td><code id="surfaceSimulate_+3A_type">type</code></td>
<td>

<p>Type of simulation desired - options are <code>"BM"</code>, <code>"hansen-fit"</code>, and <code>"hansen-paint"</code> (see Details)
</p>
</td></tr>
<tr><td><code id="surfaceSimulate_+3A_param">param</code></td>
<td>

<p>If <code>type="BM"</code>, an optional parameter to rescale the tree (see Details)
</p>
</td></tr>
<tr><td><code id="surfaceSimulate_+3A_n_traits">n_traits</code></td>
<td>

<p>Number of traits (if not provided will be determined from other inputs or default to 1)
</p>
</td></tr>
<tr><td><code id="surfaceSimulate_+3A_dat">dat</code></td>
<td>

<p>Optional data frame of original trait data (function will use this to extract features of the data set)
</p>
</td></tr>
<tr><td><code id="surfaceSimulate_+3A_vcv">vcv</code></td>
<td>

<p>Optional evolutionary variance-covariance matrix
</p>
</td></tr>
<tr><td><code id="surfaceSimulate_+3A_hansenfit">hansenfit</code></td>
<td>

<p>A fitted Hansen model (or a list of such if multiple traits) (if <code>type = "hansen-fit"</code>)
</p>
</td></tr>
<tr><td><code id="surfaceSimulate_+3A_shifts">shifts</code></td>
<td>

<p>A vector of regime shifts, named for the branches they are to be placed on in the Hansen model to be simulated under (if <code>type = "hansen-paint"</code>). If specified, <code>n_shifts</code>, <code>n_conv_shifts</code>, <code>n_regimes</code> and <code>n_per_regime</code> are all ignored
</p>
</td></tr>
<tr><td><code id="surfaceSimulate_+3A_n_shifts">n_shifts</code></td>
<td>

<p>Number of shifts to add to the Hansen model (if <code>type = "hansen-paint"</code>)
</p>
</td></tr>
<tr><td><code id="surfaceSimulate_+3A_n_conv_shifts">n_conv_shifts</code></td>
<td>

<p>Number of convergent shifts to add to the Hansen model (if <code>type = "hansen-paint"</code>). Either <code>n_conv_shifts</code> or <code>n_regimes</code> can be specified along with <code>n_shifts</code>, but not both
</p>
</td></tr>
<tr><td><code id="surfaceSimulate_+3A_n_regimes">n_regimes</code></td>
<td>

<p>Number of regimes to add to the Hansen model (if <code>type = "hansen-paint"</code>). Either <code>n_conv_shifts</code> or <code>n_regimes</code> can be specified along with <code>n_shifts</code>, but not both
</p>
</td></tr>
<tr><td><code id="surfaceSimulate_+3A_n_per_regime">n_per_regime</code></td>
<td>

<p>Integer vector of the number of shifts to each regime in the model (if <code>type = "hansen-paint"</code>). If specified, the vector length determines <code>n_regimes</code>, and the sum of the values determines <code>n_shifts</code>, and the number of entries &gt;1 determines <code>n_conv_shifts</code>
</p>
</td></tr>
<tr><td><code id="surfaceSimulate_+3A_no_nested">no_nested</code></td>
<td>

<p>A logical indicating whether to ensure that a pair of &lsquo;convergent&rsquo; regimes is not in fact two nested clades (if <code>type = "hansen-paint"</code>; defaults to <code>TRUE</code>)
</p>
</td></tr>
<tr><td><code id="surfaceSimulate_+3A_optima">optima</code></td>
<td>

<p>Optional matrix of optima
</p>
</td></tr>
<tr><td><code id="surfaceSimulate_+3A_sample_optima">sample_optima</code></td>
<td>

<p>A logical indicating whether to replace the optima in the fitted model with new values from a distribution based on the inferred optima (if <code>type = "hansen-fit"</code>; defaults to <code>TRUE</code>)
</p>
</td></tr>
<tr><td><code id="surfaceSimulate_+3A_optima_distrib">optima_distrib</code></td>
<td>

<p>Optional matrix of optima distribution for each trait (see <code>optima_type</code>). Each column is a two-element vector <code>c(A, B)</code> for the trait. 
</p>
</td></tr>
<tr><td><code id="surfaceSimulate_+3A_optima_type">optima_type</code></td>
<td>

<p>How to sample optima based on <code>optima_distrib</code>. Can be one of <code>"rnorm"</code> (default; distribution is normal with mean=A, sd=B), <code>"runif"</code> (distribution is uniform with center=A, width=B), or <code>"even"</code> (optima are evenly spaced with spacing=B, then randomized)
</p>
</td></tr>
<tr><td><code id="surfaceSimulate_+3A_sigma_squared">sigma_squared</code></td>
<td>

<p>Scalar or vector of Brownian rate parameters to use in simulations
</p>
</td></tr>
<tr><td><code id="surfaceSimulate_+3A_alpha">alpha</code></td>
<td>

<p>Scalar or vector of OU attraction parameter values to use in simulations
</p>
</td></tr>
<tr><td><code id="surfaceSimulate_+3A_pshift_timefactor">pshift_timefactor</code></td>
<td>

<p>Factor by which to bias sampling of branches to place regimes on to be earlier (if &lt;1) or later (if &gt;1) in the tree. The sampling probability will be <code>pshift_timefactor</code> times higher at the tips than at the root
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Type of simulation may be <code>"BM"</code>, <code>"hansen-fit"</code>, or <code>"hansen-paint"</code>.
</p>
<p>If type = <code>"BM"</code>, simulation uses the <code>sim.char</code> function in <code>geiger</code>, with Brownian rate <code>sigma_squared</code>. If <code>type = "BM"</code>, <code>param</code> values other than 0 will transform the tree based on the Early Burst (<code>param &lt; 0</code>) or single-peak Ornstein-Uhlenbeck (<code>param &gt; 0</code>) model before simulating, causing trait disparity to be concentrated earlier or later in the tree, respectively 
</p>
<p>If <code>type = "hansen-fit"</code>, an existing <code>hansentree</code> object is used as the basis of simulation using <code>ouch</code> functions, optionally with new parameter values
</p>
<p>If <code>type = "hansen-paint"</code>, a new <code>hansentree</code> object is produced for simulation using <code>ouch</code> functions, with specified parameter values and numbers of regimes and/or regime shifts
</p>


<h3>Value</h3>

<p>A list with the following components (most are NULL if <code>type = "BM"</code>):
</p>
<table>
<tr><td><code>data</code></td>
<td>
<p>Simulated trait data in a data frame</p>
</td></tr>
<tr><td><code>optima</code></td>
<td>
<p>Matrix of optima for each regime for each trait in the generating model</p>
</td></tr>
<tr><td><code>savedshifts</code></td>
<td>
<p>Shift locations in the generating Hansen model</p>
</td></tr>
<tr><td><code>regimes</code></td>
<td>
<p>Regime assignments of tip taxa</p>
</td></tr>
<tr><td><code>shifttimes</code></td>
<td>
<p>Timing of each shift in the Hansen model (measured from the root of the tree</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>Generating Hansen model used in the simulation</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Travis Ingram
</p>


<h3>References</h3>

<p>Ingram, T. &amp; Mahler, D.L. (2013) SURFACE: detecting convergent evolution from comparative data by fitting Ornstein-Uhlenbeck models with stepwise AIC. Methods in Ecology and Evolution 4: 416-425. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+surfaceForward">surfaceForward</a></code>, <code><a href="#topic+surfaceBackward">surfaceBackward</a></code>, <code><a href="#topic+surfaceTreePlot">surfaceTreePlot</a></code>, <code><a href="#topic+surfaceTraitPlot">surfaceTraitPlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(surfaceDemo)
tree&lt;-surfaceDemo$tree
dat&lt;-surfaceDemo$sim$dat
olist&lt;-convertTreeData(tree,dat)
otree&lt;-olist[[1]]; odata&lt;-olist[[2]]
sim&lt;-surfaceSimulate(otree,type="hansen-paint",dat=dat,shifts=c(c("1"="a","6"="b","17"="c")))
</code></pre>

<hr>
<h2 id='surfaceSummary'>
Summarize SURFACE Output
</h2><span id='topic+surfaceSummary'></span>

<h3>Description</h3>

<p>Extracts the most important results from the output of the forward, backward, or both phases of a SURFACE analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surfaceSummary(fwd = NULL, bwd = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surfaceSummary_+3A_fwd">fwd</code></td>
<td>

<p>A list returned by <code>surfaceForward</code> (which may be stored as the <code>$fwd</code> component of the list returned by <code>runSurface</code>)
</p>
</td></tr>
<tr><td><code id="surfaceSummary_+3A_bwd">bwd</code></td>
<td>

<p>A list returned by <code>surfaceBackward</code> (which may be stored as the <code>$bwd</code> component of the list returned by <code>runSurface</code>)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If both <code>fwd</code> and <code>bwd</code> are provided, both phases of the analysis will be summarized together 
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>n_steps</code></td>
<td>
<p>number of iterations in the stepwise analysis</p>
</td></tr>
<tr><td><code>lnls</code></td>
<td>
<p>matrix of traits-by-iterations, giving the log-likelihood for each trait at each iteration of the analysis</p>
</td></tr>
<tr><td><code>n_regimes_seq</code></td>
<td>
<p>matrix of the summaries of regime structure at each iteration of the model</p>
</td></tr>
<tr><td><code>aics</code></td>
<td>
<p>vector giving the AICc value at each step</p>
</td></tr>
<tr><td><code>shifts</code></td>
<td>
<p>shifts present in the final fitted Hansen model</p>
</td></tr>
<tr><td><code>n_regimes</code></td>
<td>
<p>summary of regime structure of the final fitted Hansen model (see note below)</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>estimate of alpha for each trait in the final model</p>
</td></tr>
<tr><td><code>sigma_squared</code></td>
<td>
<p>estimate of sigma_squared for each trait in the final model</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>matrix of estimated optima (one per regime per trait) in the final model</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The elements <code>n_regimes_seq</code> and <code>n_regimes</code> contain measures of the regime structure in a SURFACE analysis (for each iteration, and in the final model, respectively). The measures returned are: <code>k</code> (the number of regime shifts, counting the basal regime as 1), <code>kprime</code>, (the number of regimes, some of which may be reached by multiple shifts), <code>deltak</code> (<code>k-kprime</code>, a measure of convergence), <code>c</code> (the number of shifts to convergent regimes, another measure of convergence), <code>kprime_conv</code> (the number of convergent regimes shifted to multiple times), and <code>kprime_nonconv</code> (the number of nonconvergent regimes only shifted to once)
</p>


<h3>Author(s)</h3>

<p>Travis Ingram
</p>


<h3>References</h3>

<p>Ingram, T. &amp; Mahler, D.L. (2013) SURFACE: detecting convergent evolution from comparative data by fitting Ornstein-Uhlenbeck models with stepwise AIC. Methods in Ecology and Evolution 4: 416-425. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+surfaceForward">surfaceForward</a></code>, <code><a href="#topic+surfaceBackward">surfaceBackward</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	## Not run: 
data(surfaceDemo)
tree&lt;-surfaceDemo$tree
dat&lt;-surfaceDemo$sim$dat
result&lt;-runSurface(tree,dat)
surfaceSummary(result$fwd,result$bwd)
	
## End(Not run)
</code></pre>

<hr>
<h2 id='surfaceTreePlot'>
Visualize Results of a SURFACE Analysis
</h2><span id='topic+surfaceTreePlot'></span><span id='topic+surfaceTraitPlot'></span>

<h3>Description</h3>

<p>Plotting functions to visualize the results of a SURFACE analysis, with colors depicting regime structure: <code>surfaceTreePlot</code> produces a customized <code>plot.phylo</code> figure, and <code>surfaceTraitPlot</code> produces a scatterplot of trait values and optima
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surfaceTreePlot(tree, hansenfit, cols = NULL, convcol = TRUE, labelshifts = FALSE, ...)
surfaceTraitPlot(dat, hansenfit, whattraits = c(1, 2), cols = NULL, 
convcol = TRUE, pchs = c(21, 21), cex.opt = 2.5, optellipses = FALSE, 
ellipsescale = 1, flatten1D = FALSE, add = FALSE, ypos = 0,
 plotoptima = TRUE, plottraits = TRUE, y.lim = NULL, x.lim = NULL, 
y.lab = NULL, x.lab = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surfaceTreePlot_+3A_tree">tree</code></td>
<td>

<p>Phylogenetic tree in <code>phylo</code> format
</p>
</td></tr>
<tr><td><code id="surfaceTreePlot_+3A_dat">dat</code></td>
<td>

<p>Trait data formatted as a data frame with named rows and at least two columns
</p>
</td></tr>
<tr><td><code id="surfaceTreePlot_+3A_hansenfit">hansenfit</code></td>
<td>

<p>An object containing the fitted Hansen model to use in plotting, with elements <code>fit</code> and <code>savedshifts</code>. This may be the list produced by any one iteration of <code>surfaceForward</code> or <code>surfaceBackward</code>, or the list produced by <code>surfaceSimulate</code>
</p>
</td></tr>
<tr><td><code id="surfaceTreePlot_+3A_whattraits">whattraits</code></td>
<td>

<p>A two-element integer (or a single integer; see Details) indicating which traits to use for the (x,y) axes of a trait plot (defaults to <code>c(1,2)</code>)
</p>
</td></tr>
<tr><td><code id="surfaceTreePlot_+3A_cols">cols</code></td>
<td>

<p>An optional character vector of colors for painting branches in <code>surfaceTreePlot</code> or coloring symbols in <code>surfaceTraitPlot</code>. One color should be provided per regime in <code>hansenfit</code>; if <code>cols=NULL</code> the function will attempt an appropriate default 
</p>
</td></tr>
<tr><td><code id="surfaceTreePlot_+3A_convcol">convcol</code></td>
<td>

<p>A logical indicating whether to select separate colors for convergent (colorful) and non-convergent (greyscale) regimes (defaults to <code>TRUE</code>)
</p>
</td></tr>
<tr><td><code id="surfaceTreePlot_+3A_labelshifts">labelshifts</code></td>
<td>

<p>A logical indicating whether to add integer labels to branches in the tree to show the order in which regime shifts were added in the forward phase (defaults to <code>FALSE</code>)
</p>
</td></tr>
<tr><td><code id="surfaceTreePlot_+3A_pchs">pchs</code></td>
<td>

<p>Vector with two integers representing the plotting characters to use for trait values and optima, respectively, in <code>surfaceTraitPlot</code>; both default to 21 (filled circles) 
</p>
</td></tr>
<tr><td><code id="surfaceTreePlot_+3A_cex.opt">cex.opt</code></td>
<td>

<p>Character expansion for symbols representing the optima in <code>surfaceTraitPlot</code>; defaults to 2.5 (symbols representing data points can be specified with <code>cex</code>)
</p>
</td></tr>
<tr><td><code id="surfaceTreePlot_+3A_optellipses">optellipses</code></td>
<td>

<p>A logical indicating whether to draw ellipses based on the fitted OU model instead of denoting optimum positions with <code>pchs</code> and <code>cex.opt</code>. The ellipses are drawn as the optima +/- the standard deviation of the stationary distribution of the inferred OU process: sigma_squared/(2*alpha), multiplied by <code>ellipsescale</code>
</p>
</td></tr>
<tr><td><code id="surfaceTreePlot_+3A_ellipsescale">ellipsescale</code></td>
<td>

<p>A scalar or vector indicating how many standard deviations to draw ellipses above and below the optima; if a vector, concentric ellipses of various sizes will be drawn; defaults to 1
</p>
</td></tr>
<tr><td><code id="surfaceTreePlot_+3A_flatten1d">flatten1D</code></td>
<td>

<p>A logical indicating whether all regimes should be placed on a single line when <code>surfaceTraitPlot</code> is called for a single trait; defaults to <code>FALSE</code>
</p>
</td></tr>
<tr><td><code id="surfaceTreePlot_+3A_add">add</code></td>
<td>

<p>A logical indicating whether to add a new element to an existing <code>surfaceTraitPlot</code> graph instead of creating a new one; defaults to <code>FALSE</code> 
</p>
</td></tr>
<tr><td><code id="surfaceTreePlot_+3A_ypos">ypos</code></td>
<td>

<p>Position on the y axis to place the traits and optima on; only applies if a single trait is used and <code>flatten1D = TRUE</code>
</p>
</td></tr>
<tr><td><code id="surfaceTreePlot_+3A_plotoptima">plotoptima</code></td>
<td>

<p>A logical indicating whether the optima should be displayed in <code>surfaceTraitPlot</code>; defaults to <code>TRUE</code>
</p>
</td></tr>
<tr><td><code id="surfaceTreePlot_+3A_plottraits">plottraits</code></td>
<td>

<p>A logical indicating whether the trait values should be displayed in <code>surfaceTraitPlot</code>; defaults to <code>TRUE</code>
</p>
</td></tr>
<tr><td><code id="surfaceTreePlot_+3A_y.lim">y.lim</code></td>
<td>

<p>Lower and upper limits for the y-axis; by default will be calculated to fit all points and ellipses fit in the frame
</p>
</td></tr>
<tr><td><code id="surfaceTreePlot_+3A_x.lim">x.lim</code></td>
<td>

<p>Lower and upper limits for the x-axis; by default will be calculated to fit all points and ellipses fit in the frame
</p>
</td></tr>
<tr><td><code id="surfaceTreePlot_+3A_y.lab">y.lab</code></td>
<td>

<p>y-axis label; defaults to the column name in the data frame
</p>
</td></tr>
<tr><td><code id="surfaceTreePlot_+3A_x.lab">x.lab</code></td>
<td>

<p>x-axis label; defaults to the column name in the data frame
</p>
</td></tr>
<tr><td><code id="surfaceTreePlot_+3A_...">...</code></td>
<td>

<p>Additional arguments to be passed to the <code>plot</code> or <code>points</code> functions
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For trait plots using the option <code>optellipses=TRUE</code>, note that in some cases (e.g. if alpha is very small) the ellipses will not convey useful information. If trait data are unidimensional, or if <code>whattraits</code> is provided as a single integer, data will be plotted on the x-axis and the y-axis will separate different regimes (and ellipse width in the y-dimension will not be meaningful)
</p>


<h3>Value</h3>

<p>Creates one tree or trait plot on the current graphics device
</p>


<h3>Author(s)</h3>

<p>Travis Ingram
</p>


<h3>References</h3>

<p>Ingram, T. &amp; Mahler, D.L. (2013) SURFACE: detecting convergent evolution from comparative data by fitting Ornstein-Uhlenbeck models with stepwise AIC. Methods in Ecology and Evolution 4: 416-425. 
</p>
<p>Mahler, D.L., Ingram, T., Revell, L.J. &amp; Losos, J.B. (2013) Exceptional convergence on the macroevolutionary landscape in island lizard radiations. Science 341: 292-295.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+surfaceForward">surfaceForward</a></code>, <code><a href="#topic+surfaceBackward">surfaceBackward</a></code>, <code><a href="#topic+surfaceSimulate">surfaceSimulate</a></code>, <code><a href="#topic+surfaceSummary">surfaceSummary</a></code>, <code><a href="#topic+surfaceAICPlot">surfaceAICPlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(surfaceDemo)
tree&lt;-surfaceDemo$tree
dat&lt;-surfaceDemo$sim$dat
olist&lt;-convertTreeData(tree,dat)
otree&lt;-olist[[1]]; odata&lt;-olist[[2]]
startmod&lt;-startingModel(otree, odata, shifts = c("6"="b")) 
surfaceTreePlot(tree,startmod[[1]],labelshifts=TRUE,cols=c("black","red"))
surfaceTraitPlot(dat,startmod[[1]],whattraits=c(1,2),cols=c("black","red"))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
