<!DOCTYPE html><html lang="en"><head><title>Help for package HDTSA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {HDTSA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#HDTSA-package'><p>HDTSA: High Dimensional Time Series Analysis Tools</p></a></li>
<li><a href='#Coint'><p>Identifying the cointegration rank of nonstationary vector time series</p></a></li>
<li><a href='#CP_MTS'><p>Estimating the matrix time series CP-factor model</p></a></li>
<li><a href='#DGP.CP'><p>Generating simulated data for the example in Chang et al. (2024)</p></a></li>
<li><a href='#Factors'><p>Factor analysis for vector time series</p></a></li>
<li><a href='#FamaFrench'><p>Fama-French 10*10 return series</p></a></li>
<li><a href='#HDSReg'><p>Factor analysis with observed regressors for vector time series</p></a></li>
<li><a href='#IPindices'><p>U.S. Industrial Production indices</p></a></li>
<li><a href='#MartG_test'><p>Testing for martingale difference hypothesis in high dimension</p></a></li>
<li><a href='#PCA_TS'><p>Principal component analysis for vector time series</p></a></li>
<li><a href='#predict.factors'><p>Make predictions from a <code>"factors"</code> object</p></a></li>
<li><a href='#predict.mtscp'><p>Make predictions from a <code>"mtscp"</code> object</p></a></li>
<li><a href='#predict.tspca'><p>Make predictions from a <code>"tspca"</code> object</p></a></li>
<li><a href='#QWIdata'><p>The national QWI hires data</p></a></li>
<li><a href='#SpecMulTest'><p>Multiple testing with FDR control for spectral density matrix</p></a></li>
<li><a href='#SpecTest'><p>Global testing for spectral density matrix</p></a></li>
<li><a href='#UR_test'><p>Testing for unit roots based on sample autocovariances</p></a></li>
<li><a href='#WN_test'><p>Testing for white noise hypothesis in high dimension</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>High Dimensional Time Series Analysis Tools</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.5-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-01-25</td>
</tr>
<tr>
<td>Author:</td>
<td>Jinyuan Chang [aut],
  Jing He [aut],
  Chen Lin [aut, cre],
  Qiwei Yao [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Chen Lin &lt;linchen@smail.swufe.edu.cn&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation for high-dimensional time series analysis methods, including factor model for vector time series 
      proposed by Lam and Yao (2012) &lt;<a href="https://doi.org/10.1214%2F12-AOS970">doi:10.1214/12-AOS970</a>&gt; and Chang, Guo and Yao (2015)
      &lt;<a href="https://doi.org/10.1016%2Fj.jeconom.2015.03.024">doi:10.1016/j.jeconom.2015.03.024</a>&gt;, martingale difference test proposed by 
      Chang, Jiang and Shao (2023) &lt;<a href="https://doi.org/10.1016%2Fj.jeconom.2022.09.001">doi:10.1016/j.jeconom.2022.09.001</a>&gt;, principal 
      component analysis for vector time series proposed by Chang, Guo and Yao (2018) &lt;<a href="https://doi.org/10.1214%2F17-AOS1613">doi:10.1214/17-AOS1613</a>&gt;,
      cointegration analysis proposed by Zhang, Robinson and Yao (2019)
      &lt;<a href="https://doi.org/10.1080%2F01621459.2018.1458620">doi:10.1080/01621459.2018.1458620</a>&gt;, unit root test proposed by Chang, Cheng and Yao (2022)
      &lt;<a href="https://doi.org/10.1093%2Fbiomet%2Fasab034">doi:10.1093/biomet/asab034</a>&gt;, white noise test proposed by Chang, Yao and Zhou (2017)
      &lt;<a href="https://doi.org/10.1093%2Fbiomet%2Fasw066">doi:10.1093/biomet/asw066</a>&gt;, CP-decomposition for matrix time 
      series proposed by Chang et al. (2023) &lt;<a href="https://doi.org/10.1093%2Fjrsssb%2Fqkac011">doi:10.1093/jrsssb/qkac011</a>&gt; and
      Chang et al. (2024) &lt;<a href="https://doi.org/10.48550%2FarXiv.2410.05634">doi:10.48550/arXiv.2410.05634</a>&gt;, and statistical inference for
      spectral density matrix proposed by Chang et al. (2022) 
      &lt;<a href="https://doi.org/10.48550%2FarXiv.2212.13686">doi:10.48550/arXiv.2212.13686</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, Rcpp, clime, sandwich, methods, MASS, geigen,
jointDiag, vars, forecast</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>RcppEigen, Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Linc2021/HDTSA">https://github.com/Linc2021/HDTSA</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Linc2021/HDTSA/issues">https://github.com/Linc2021/HDTSA/issues</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-27 08:05:22 UTC; linchen</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-28 04:00:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='HDTSA-package'>HDTSA: High Dimensional Time Series Analysis Tools</h2><span id='topic+HDTSA-package'></span><span id='topic+HDTSA'></span>

<h3>Description</h3>

<p>The purpose of <code>HDTSA</code> is to address a range of high-dimensional time
series problems, which includes solutions to a series of statistical issues,
primarily comprising: Procedures for high-dimensional time series analysis
including factor analysis proposed by Lam and Yao (2012)
&lt;doi:10.1214/12-AOS970&gt; and Chang, Guo and Yao (2015)
&lt;doi:10.1016/j.jeconom.2015.03.024&gt;,martingale difference test proposed by
Chang, Jiang and Shao (2022) &lt;doi:10.1016/j.jeconom.2022.09.001&gt; in press,
principal component analysis proposed by Chang, Guo and Yao (2018)
&lt;doi:10.1214/17-AOS1613&gt;, identifying cointegration proposed by Zhang,
Robinson and Yao (2019) &lt;doi:10.1080/01621459.2018.1458620&gt;,
unit root test proposed by Chang, Cheng and Yao (2021)
&lt;doi:10.1093/biomet/asab034&gt;, white noise test proposed by Chang, Yao and
Zhou (2017) &lt;doi:10.1093/biomet/asw066&gt;, CP-decomposition for high-dimensional
matrix time series proposed by Chang, He, Yang and Yao (2023)
&lt;doi:10.1093/jrsssb/qkac011&gt; and Chang, Du, Huang and Yao (2024+), and
Statistical inference for high-dimensional spectral density matrix porposed
by Chang, Jiang, McElroy and Shao (2023) &lt;doi:10.48550/arXiv.2212.13686&gt;.
</p>


<h3>Author(s)</h3>

<p>Chen lin, Jinyuan Chang, Qiwei Yao
Maintainer: Chen lin&lt;linchen@smail.swufe.edu.cn&gt;
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/Linc2021/HDTSA">https://github.com/Linc2021/HDTSA</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/Linc2021/HDTSA/issues">https://github.com/Linc2021/HDTSA/issues</a>
</p>
</li></ul>


<hr>
<h2 id='Coint'>Identifying the cointegration rank of nonstationary vector time series</h2><span id='topic+Coint'></span>

<h3>Description</h3>

<p><code>Coint()</code> deals with cointegration analysis for high-dimensional
vector time series proposed in Zhang, Robinson and Yao (2019). Consider the model:
</p>
<p style="text-align: center;"><code class="reqn">{\bf y}_t = {\bf Ax}_t\,,</code>
</p>

<p>where <code class="reqn">{\bf A}</code> is a <code class="reqn">p \times p</code> unknown and invertible constant matrix,
<code class="reqn">{\bf x}_t = ({\bf x}'_{t,1}, {\bf x}'_{t,2})'</code> is a latent
<code class="reqn">p \times 1</code> process, <code class="reqn">{\bf x}_{t,2}</code> is an <code class="reqn">r \times 1</code> <code class="reqn">I(0)</code> process,
<code class="reqn">{\bf x}_{t,1}</code> is a process with nonstationary components, and no linear
combination of <code class="reqn">{\bf x}_{t,1}</code> is <code class="reqn">I(0)</code>. This function aims to estimate the
cointegration rank <code class="reqn">r</code> and the invertible constant matrix <code class="reqn">{\bf A}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Coint(
  Y,
  lag.k = 5,
  type = c("acf", "urtest", "both"),
  c0 = 0.3,
  m = 20,
  alpha = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Coint_+3A_y">Y</code></td>
<td>
<p>An <code class="reqn">n \times p</code> data matrix <code class="reqn">{\bf Y} = ({\bf y}_1, \dots , {\bf y}_n )'</code>,
where <code class="reqn">n</code> is the number of the 
observations of the <code class="reqn">p \times 1</code> time series <code class="reqn">\{{\bf y}_t\}_{t=1}^n</code>.</p>
</td></tr>
<tr><td><code id="Coint_+3A_lag.k">lag.k</code></td>
<td>
<p>The time lag <code class="reqn">K</code> used to calculate the nonnegative definte
matrix <code class="reqn">\hat{{\bf W}}_y</code>: </p>
<p style="text-align: center;"><code class="reqn">\hat{\mathbf{W}}_y\ =\
\sum_{k=0}^{K}\hat{\mathbf{\Sigma}}_y(k)\hat{\mathbf{\Sigma}}_y(k)'\,,</code>
</p>

<p>where <code class="reqn">\hat{\bf \Sigma}_y(k)</code> is the sample autocovariance of
<code class="reqn"> {\bf y}_t</code> at lag <code class="reqn">k</code>. The default is 5.</p>
</td></tr>
<tr><td><code id="Coint_+3A_type">type</code></td>
<td>
<p>The method used to identify the cointegration rank. Available
options include: <code>"acf"</code> (the default) for the method based on the sample
autocorrelations, <code>"urtest"</code> for the method based on the unit root tests,
and <code>"both"</code> to apply these two methods. See Section 2.3 of Zhang, Robinson
and Yao (2019) and 'Details' for more information.</p>
</td></tr>
<tr><td><code id="Coint_+3A_c0">c0</code></td>
<td>
<p>The prescribed constant <code class="reqn">c_0</code> involved in the method based on
the sample correlations, which is used
when <code>type = "acf"</code> or <code>type = "both"</code>. See Section 2.3 of Zhang, Robinson
and Yao (2019) and 'Details' for more information. The default is 0.3.</p>
</td></tr>
<tr><td><code id="Coint_+3A_m">m</code></td>
<td>
<p>The prescribed constant <code class="reqn">m</code> involved in the method based on
the sample correlations, which is used
when <code>type = "acf"</code> or <code>type = "both"</code>. See Section 2.3 of Zhang, Robinson
and Yao (2019) and 'Details' for more information. The default is 20.</p>
</td></tr>
<tr><td><code id="Coint_+3A_alpha">alpha</code></td>
<td>
<p>The significance level <code class="reqn">\alpha</code> of the unit root tests,
which is used when <code>type = "urtest"</code> or <code>type = "both"</code>.
See 'Details'. The default is 0.01.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Write <code class="reqn">\hat{\bf x}_t=\hat{\bf A}'{\bf y}_t\equiv (\hat{x}_t^1,\ldots,\hat{x}_t^p)'</code>.
When <code>type = "acf"</code>, <code>Coint()</code> estimates <code class="reqn">r</code> by
</p>
<p style="text-align: center;"><code class="reqn">\hat{r}=\sum_{i=1}^{p}1\bigg\{\frac{S_i(m)}{m}&lt;c_0 \bigg\}</code>
</p>
<p> for some
constant <code class="reqn">c_0\in (0,1)</code> and some large constant <code class="reqn">m</code>, where
<code class="reqn">S_i(m)</code> is the sum of the sample autocorrelations of
<code class="reqn">\hat{x}^{i}_{t}</code> over lags 1 to <code class="reqn">m</code>,
which is specified in Section 2.3 of Zhang, Robinson and Yao (2019).
</p>
<p>When <code>type = "urtest"</code>, <code>Coint()</code> estimates <code class="reqn">r</code> by unit root
tests. For <code class="reqn">i= 1,\ldots, p</code>, consider the null hypothesis 
</p>
<p style="text-align: center;"><code class="reqn">H_{0,i}:\hat{x}_t^{p-i+1} \sim I(0)\,.</code>
</p>
<p> The estimation procedure for
<code class="reqn">r</code> can be implemented as follows:
</p>
<p><em>Step 1</em>. Start with <code class="reqn">i=1</code>. Perform the unit root test proposed
in Chang, Cheng and Yao (2021) for <code class="reqn">H_{0,i}</code>.
</p>
<p><em>Step 2</em>. If the null hypothesis is not rejected at the significance
level <code class="reqn">\alpha</code>, increment <code class="reqn">i</code> by 1 and repeat Step 1. Otherwise, stop
the procedure and denote the value of <code class="reqn">i</code> at termination as <code class="reqn">i_0</code>.
The cointegration rank is then estimated as <code class="reqn">\hat{r}=i_0-1</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"coint"</code>, which contains the following
components:
</p>
<table role = "presentation">
<tr><td><code>A</code></td>
<td>
<p>The estimated <code class="reqn">\hat{\bf A}</code>. </p>
</td></tr>
<tr><td><code>coint_rank</code></td>
<td>
<p>The estimated cointegration rank <code class="reqn">\hat{r}</code>.</p>
</td></tr>
<tr><td><code>lag.k</code></td>
<td>
<p>The time lag used in function.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>A string indicating which method is used to identify the
cointegration rank.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Chang, J., Cheng, G., &amp; Yao, Q. (2022).  Testing for unit
roots based on sample autocovariances. <em>Biometrika</em>, <strong>109</strong>, 543&ndash;550.
<a href="https://doi.org/10.1093/biomet/asab034">doi:10.1093/biomet/asab034</a>.
</p>
<p>Zhang, R., Robinson, P., &amp; Yao, Q. (2019). Identifying cointegration by
eigenanalysis. <em>Journal of the American Statistical Association</em>,
<strong>114</strong>, 916&ndash;927. <a href="https://doi.org/10.1080/01621459.2018.1458620">doi:10.1080/01621459.2018.1458620</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1 (Example 1 in Zhang, Robinson and Yao (2019))
## Generate yt
p &lt;- 10
n &lt;- 1000
r &lt;- 3
d &lt;- 1
X &lt;- mat.or.vec(p, n)
X[1,] &lt;- arima.sim(n-d, model = list(order=c(0, d, 0)))
for(i in 2:3)X[i,] &lt;- rnorm(n)
for(i in 4:(r+1)) X[i, ] &lt;- arima.sim(model = list(ar = 0.5), n)
for(i in (r+2):p) X[i, ] &lt;- arima.sim(n = (n-d), model = list(order=c(1, d, 1), ar=0.6, ma=0.8))
M1 &lt;- matrix(c(1, 1, 0, 1/2, 0, 1, 0, 1, 0), ncol = 3, byrow = TRUE)
A &lt;- matrix(runif(p*p, -3, 3), ncol = p)
A[1:3,1:3] &lt;- M1
Y &lt;- t(A%*%X)

Coint(Y, type = "both")
</code></pre>

<hr>
<h2 id='CP_MTS'>Estimating the matrix time series CP-factor model</h2><span id='topic+CP_MTS'></span>

<h3>Description</h3>

<p><code>CP_MTS()</code> deals with the estimation of the CP-factor model for matrix time series:
</p>
<p style="text-align: center;"><code class="reqn">{\bf{Y}}_t = {\bf A \bf X}_t{\bf B}' +
{\boldsymbol{\epsilon}}_t, </code>
</p>
<p> where <code class="reqn">{\bf X}_t = {\rm diag}(x_{t,1},\ldots,x_{t,d})</code> is a <code class="reqn">d \times d</code>
unobservable diagonal matrix, <code class="reqn"> {\boldsymbol{\epsilon}}_t </code>
is a <code class="reqn">p \times q</code> matrix white noise, <code class="reqn">{\bf A}</code> and <code class="reqn">{\bf B}</code> are, respectively, <code class="reqn">p
\times d</code> and <code class="reqn">q \times d</code> unknown constant matrices with their columns being
unit vectors, and <code class="reqn">1\leq d &lt; \min(p,q)</code> is an unknown integer.
Let <code class="reqn">{\rm rank}(\mathbf{A}) = d_1</code>
and <code class="reqn">{\rm rank}(\mathbf{B}) = d_2</code> with some unknown <code class="reqn">d_1,d_2\leq d</code>.
This function aims to estimate <code class="reqn">d, d_1, d_2</code> and the loading
matrices <code class="reqn">{\bf A}</code> and <code class="reqn">{\bf B}</code> using the methods proposed in Chang
et al. (2023) and Chang et al. (2024).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CP_MTS(
  Y,
  xi = NULL,
  Rank = NULL,
  lag.k = 20,
  lag.ktilde = 10,
  method = c("CP.Direct", "CP.Refined", "CP.Unified"),
  thresh1 = FALSE,
  thresh2 = FALSE,
  thresh3 = FALSE,
  delta1 = 2 * sqrt(log(dim(Y)[2] * dim(Y)[3])/dim(Y)[1]),
  delta2 = delta1,
  delta3 = delta1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CP_MTS_+3A_y">Y</code></td>
<td>
<p>An <code class="reqn">n \times p \times q</code> array, where <code class="reqn">n</code> is the number
of observations of the <code class="reqn">p \times q</code> matrix time series <code class="reqn">\{{\bf Y}_t\}_{t=1}^n</code>.</p>
</td></tr>
<tr><td><code id="CP_MTS_+3A_xi">xi</code></td>
<td>
<p>An <code class="reqn">n \times 1</code> vector <code class="reqn">\boldsymbol{\xi} = (\xi_1,\ldots, \xi_n)'</code>,
where <code class="reqn">\xi_t</code> represents a linear combination of <code class="reqn">{\bf Y}_t</code>.
If <code>xi = NULL</code> (the default), <code class="reqn">\xi_{t}</code> is determined by the PCA
method introduced in Section 5.1 of Chang et al. (2023). Otherwise, <code>xi</code>
can be given by the users.</p>
</td></tr>
<tr><td><code id="CP_MTS_+3A_rank">Rank</code></td>
<td>
<p>A list containing the following components: <code>d</code> representing
the number of columns of <code class="reqn">{\bf A}</code> and <code class="reqn">{\bf B}</code>, <code>d1</code> representing
the rank of <code class="reqn">{\bf A}</code>, and <code>d2</code> representing the rank of <code class="reqn">{\bf B}</code>.
If set to <code>NULL</code> (default), <code class="reqn">d</code>, <code class="reqn">d_1</code>, and <code class="reqn">d_2</code> will be estimated.
Otherwise, they can be given by the users.</p>
</td></tr>
<tr><td><code id="CP_MTS_+3A_lag.k">lag.k</code></td>
<td>
<p>The time lag <code class="reqn">K</code> used to calculate the nonnegative definite 
matrices <code class="reqn">\hat{\mathbf{M}}_1</code> and <code class="reqn">\hat{\mathbf{M}}_2</code> when <code>method = "CP.Refined"</code>
or <code>method = "CP.Unified"</code>:
</p>
<p style="text-align: center;"><code class="reqn">\hat{\mathbf{M}}_1\ =\
  \sum_{k=1}^{K} \hat{\bf \Sigma}_{k} \hat{\bf \Sigma}_{k}'\ \ {\rm and}
  \ \ \hat{\mathbf{M}}_2\ =\ \sum_{k=1}^{K} \hat{\bf \Sigma}_{k}' \hat{\bf \Sigma}_{k}\,,
  </code>
</p>

<p>where <code class="reqn">\hat{\bf \Sigma}_{k}</code> is an estimate of the cross-covariance between
<code class="reqn"> {\bf Y}_t</code> and <code class="reqn">\xi_t</code> at lag <code class="reqn">k</code>. See 'Details'. The default is 20.</p>
</td></tr>
<tr><td><code id="CP_MTS_+3A_lag.ktilde">lag.ktilde</code></td>
<td>
<p>The time lag <code class="reqn">\tilde K</code> involved in the unified
estimation method [See (16) in Chang et al. (2024)], which is used
when <code>method = "CP.Unified"</code>. The default is 10.</p>
</td></tr>
<tr><td><code id="CP_MTS_+3A_method">method</code></td>
<td>
<p>A string indicating which CP-decomposition method is used. Available options include:
<code>"CP.Direct"</code> (the default) for the direct estimation method
[See Section 3.1 of Chang et al. (2023)], <code>"CP.Refined"</code> for the refined estimation
method [See Section 3.2 of Chang et al. (2023)], and <code>"CP.Unified"</code> for the
unified estimation method [See Section 4 of Chang et al. (2024)].
The validity of methods <code>"CP.Direct"</code> and <code>"CP.Refined"</code> depends on the assumption
<code class="reqn">d_1=d_2=d</code>. When <code class="reqn">d_1,d_2 \leq d</code>, the method <code>"CP.Unified"</code> can be applied.
See Chang et al. (2024) for details.</p>
</td></tr>
<tr><td><code id="CP_MTS_+3A_thresh1">thresh1</code></td>
<td>
<p>Logical. If <code>FALSE</code> (the default), no thresholding will
be applied in <code class="reqn">\hat{\bf \Sigma}_{k}</code>, which indicates that the threshold level
<code class="reqn">\delta_1=0</code>. If <code>TRUE</code>, <code class="reqn">\delta_1</code> will be set through <code>delta1</code>.
<code>thresh1</code> is used for all three methods. See 'Details'.</p>
</td></tr>
<tr><td><code id="CP_MTS_+3A_thresh2">thresh2</code></td>
<td>
<p>Logical. If <code>FALSE</code> (the default), no thresholding will
be applied in <code class="reqn">\check{\bf \Sigma}_{k}</code>, which indicates that the threshold level
<code class="reqn">\delta_2=0</code>. If <code>TRUE</code>, <code class="reqn">\delta_2</code> will be set through <code>delta2</code>.
<code>thresh2</code> is used only when <code>method = "CP.Refined"</code>. See 'Details'.</p>
</td></tr>
<tr><td><code id="CP_MTS_+3A_thresh3">thresh3</code></td>
<td>
<p>Logical. If <code>FALSE</code> (the default), no thresholding will
be applied in <code class="reqn">\vec{\bf \Sigma}_{k}</code>, which indicates that the threshold level
<code class="reqn">\delta_3=0</code>. If <code>TRUE</code>, <code class="reqn">\delta_3</code> will be set through <code>delta3</code>.
<code>thresh3</code> is used only when <code>method = "CP.Unified"</code>. See 'Details'.</p>
</td></tr>
<tr><td><code id="CP_MTS_+3A_delta1">delta1</code></td>
<td>
<p>The value of the threshold level <code class="reqn">\delta_1</code>. The default is
<code class="reqn"> \delta_1 = 2 \sqrt{n^{-1}\log (pq)}</code>.</p>
</td></tr>
<tr><td><code id="CP_MTS_+3A_delta2">delta2</code></td>
<td>
<p>The value of the threshold level <code class="reqn">\delta_2</code>. The default is
<code class="reqn"> \delta_2 = 2 \sqrt{n^{-1}\log (pq)}</code>.</p>
</td></tr>
<tr><td><code id="CP_MTS_+3A_delta3">delta3</code></td>
<td>
<p>The value of the threshold level <code class="reqn">\delta_3</code>. The default is
<code class="reqn"> \delta_3 = 2 \sqrt{n^{-1}\log(pq)}</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All three CP-decomposition methods involve the estimation of the autocovariance of
<code class="reqn"> {\bf Y}_t</code> and <code class="reqn">\xi_t</code> at lag <code class="reqn">k</code>, which is defined as follows:
</p>
<p style="text-align: center;"><code class="reqn">\hat{\bf \Sigma}_{k} = T_{\delta_1}\{\hat{\boldsymbol{\Sigma}}_{\mathbf{Y},
 \xi}(k)\}\ \ {\rm with}\ \ \hat{\boldsymbol{\Sigma}}_{\mathbf{Y}, \xi}(k) = \frac{1}{n-k}
\sum_{t=k+1}^n(\mathbf{Y}_t-\bar{\mathbf{Y}})(\xi_{t-k}-\bar{\xi})\,,</code>
</p>

<p>where <code class="reqn">\bar{\bf Y} = n^{-1}\sum_{t=1}^n {\bf Y}_t</code>, <code class="reqn">\bar{\xi}=n^{-1}\sum_{t=1}^n \xi_t</code>
and <code class="reqn">T_{\delta_1}(\cdot)</code> is a threshold operator defined as
<code class="reqn">T_{\delta_1}({\bf W}) = \{w_{i,j}1(|w_{i,j}|\geq \delta_1)\}</code> for any matrix
<code class="reqn">{\bf W}=(w_{i,j})</code>, with the threshold level <code class="reqn">\delta_1 \geq 0</code> and <code class="reqn">1(\cdot)</code>
representing the indicator function. Chang et al. (2023) and Chang et al. (2024) suggest to choose
<code class="reqn">\delta_1 = 0</code> when <code class="reqn">p, q</code> are fixed and <code class="reqn">\delta_1&gt;0</code> when <code class="reqn">pq \gg n</code>.
</p>
<p>The refined estimation method involves
</p>
<p style="text-align: center;"><code class="reqn">\check{\bf \Sigma}_{k} =
T_{\delta_2}\{\hat{\mathbf{\Sigma}}_{\check{\mathbf{Y}}}(k)\}\ \ {\rm with}
\ \ \hat{\mathbf{\Sigma}}_{\check{\mathbf{Y}}}(k)=\frac{1}{n-k}
\sum_{t=k+1}^n(\mathbf{Y}_t-\bar{\mathbf{Y}}) \otimes {\rm vec}
(\mathbf{Y}_{t-k}-\bar{\mathbf{Y}})\,,</code>
</p>

<p>where <code class="reqn">T_{\delta_2}(\cdot)</code> is a threshold operator with the threshold level
<code class="reqn">\delta_2 \geq 0</code>, and <code class="reqn">{\rm vec}(\cdot)</code> is a vecterization operator
with <code class="reqn">{\rm vec}({\bf H})</code> being the <code class="reqn">(m_1m_2)\times 1</code> vector obtained by stacking
the columns of the <code class="reqn">m_1 \times m_2</code> matrix <code class="reqn">{\bf H}</code>. See Section 3.2.2 of Chang
et al. (2023) for details.
</p>
<p>The unified estimation method involves
</p>
<p style="text-align: center;"><code class="reqn">\vec{\bf \Sigma}_{k}=
T_{\delta_3}\{\hat{\boldsymbol{\Sigma}}_{\vec{\mathbf{Y}}}(k)\}
\ \ {\rm with}\ \ \hat{\boldsymbol{\Sigma}}_{\vec{\mathbf{Y}}}(k)=\frac{1}{n-k}
\sum_{t=k+1}^n{\rm vec}({\mathbf{Y}}_t-\bar{\mathbf{Y}})\{{\rm vec}
(\mathbf{Y}_{t-k}-\bar{\mathbf{Y}})\}'\,,</code>
</p>

<p>where <code class="reqn">T_{\delta_3}(\cdot)</code> is a threshold operator with the threshold level
<code class="reqn">\delta_3 \geq 0</code>. See Section 4.2 of Chang et al. (2024) for details.
</p>


<h3>Value</h3>

<p>An object of class <code>"mtscp"</code>, which contains the following
components:
</p>
<table role = "presentation">
<tr><td><code>A</code></td>
<td>
<p>The estimated <code class="reqn">p \times \hat{d}</code> left loading matrix <code class="reqn">\hat{\bf A}</code>.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>The estimated <code class="reqn">q \times \hat{d}</code> right loading matrix <code class="reqn">\hat{\bf B}</code>.</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>The estimated latent process <code class="reqn">\hat{x}_{t,1},\ldots,\hat{x}_{t,\hat{d}}</code>.</p>
</td></tr>
<tr><td><code>Rank</code></td>
<td>
<p>The estimated <code class="reqn">\hat{d}_1,\hat{d}_2</code>, and <code class="reqn">\hat{d}</code>.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>A string indicating which CP-decomposition method is used.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Chang, J., Du, Y., Huang, G., &amp; Yao, Q. (2024). Identification and
estimation for matrix time series CP-factor models. <em>arXiv preprint</em>.
<a href="https://doi.org/10.48550/arXiv.2410.05634">doi:10.48550/arXiv.2410.05634</a>.
</p>
<p>Chang, J., He, J., Yang, L., &amp; Yao, Q. (2023). Modelling matrix time series via a tensor CP-decomposition.
<em>Journal of the Royal Statistical Society Series B: Statistical Methodology</em>, <strong>85</strong>, 127&ndash;148. 
<a href="https://doi.org/10.1093/jrsssb/qkac011">doi:10.1093/jrsssb/qkac011</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1.
p &lt;- 10
q &lt;- 10
n &lt;- 400
d = d1 = d2 &lt;- 3
## DGP.CP() generates simulated data for the example in Chang et al. (2024).
data &lt;- DGP.CP(n, p, q, d, d1, d2)
Y &lt;- data$Y

## d is unknown
res1 &lt;- CP_MTS(Y, method = "CP.Direct")
res2 &lt;- CP_MTS(Y, method = "CP.Refined")
res3 &lt;- CP_MTS(Y, method = "CP.Unified")

## d is known
res4 &lt;- CP_MTS(Y, Rank = list(d = 3), method = "CP.Direct")
res5 &lt;- CP_MTS(Y, Rank = list(d = 3), method = "CP.Refined")


# Example 2.
p &lt;- 10
q &lt;- 10
n &lt;- 400
d1 = d2 &lt;- 2
d &lt;-3
data &lt;- DGP.CP(n, p, q, d, d1, d2)
Y1 &lt;- data$Y

## d, d1 and d2 are unknown
res6 &lt;- CP_MTS(Y1, method = "CP.Unified")
## d, d1 and d2 are known
res7 &lt;- CP_MTS(Y1, Rank = list(d = 3, d1 = 2, d2 = 2), method = "CP.Unified")

</code></pre>

<hr>
<h2 id='DGP.CP'>Generating simulated data for the example in Chang et al. (2024)</h2><span id='topic+DGP.CP'></span>

<h3>Description</h3>

<p><code>DGP.CP()</code> function generates simulated data following the 
data generating process described in Section 7.1 of Chang et al. (2024).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DGP.CP(n, p, q, d, d1, d2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DGP.CP_+3A_n">n</code></td>
<td>
<p>Integer. The number of observations of the <code class="reqn">p \times q</code> matrix 
time series <code class="reqn">{\bf Y}_t</code>.</p>
</td></tr>
<tr><td><code id="DGP.CP_+3A_p">p</code></td>
<td>
<p>Integer. The number of rows of <code class="reqn">{\bf Y}_t</code>.</p>
</td></tr>
<tr><td><code id="DGP.CP_+3A_q">q</code></td>
<td>
<p>Integer. The number of columns of <code class="reqn">{\bf Y}_t</code>.</p>
</td></tr>
<tr><td><code id="DGP.CP_+3A_d">d</code></td>
<td>
<p>Integer. The number of columns of the factor loading matrices <code class="reqn">\bf A</code> 
and <code class="reqn">\bf B</code>.</p>
</td></tr>
<tr><td><code id="DGP.CP_+3A_d1">d1</code></td>
<td>
<p>Integer. The rank of the <code class="reqn">p \times d</code> matrix <code class="reqn">\bf A</code>.</p>
</td></tr>
<tr><td><code id="DGP.CP_+3A_d2">d2</code></td>
<td>
<p>Integer. The rank of the <code class="reqn">q \times d</code> matrix <code class="reqn">\bf B</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We generate
</p>
<p style="text-align: center;"><code class="reqn">{\bf{Y}}_t = {\bf A \bf X}_t{\bf B}' + {\boldsymbol{\epsilon}}_t </code>
</p>

<p>for any <code class="reqn">t=1, \ldots, n</code>, where <code class="reqn">{\bf X}_t = {\rm diag}({\bf x}_t)</code> 
with <code class="reqn">{\bf x}_t = (x_{t,1},\ldots,x_{t,d})'</code> being a <code class="reqn">d \times 1</code> time series,
<code class="reqn"> {\boldsymbol{\epsilon}}_t </code> is a <code class="reqn">p \times q</code> matrix white noise,
and <code class="reqn">{\bf A}</code> and <code class="reqn">{\bf B}</code> are, respectively, <code class="reqn">p\times d</code> and 
<code class="reqn">q \times d</code> factor loading matrices. <code class="reqn">\bf A</code>, <code class="reqn">{\bf X}_t</code>, and <code class="reqn">\bf B</code>
are generated based on the data generating process described in Section 7.1 of 
Chang et al. (2024) and satisfy <code class="reqn">{\rm rank}({\bf A})=d_1</code> and 
<code class="reqn">{\rm rank}({\bf B})=d_2</code>, <code class="reqn">1 \le d_1, d_2 \le d</code>.
</p>


<h3>Value</h3>

<p>A list containing the following
components:
</p>
<table role = "presentation">
<tr><td><code>Y</code></td>
<td>
<p>An <code class="reqn">n \times p \times q</code> array.</p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>The <code class="reqn">p \times d</code> left loading matrix <code class="reqn">\bf A</code>.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>The <code class="reqn">q \times d</code> right loading matrix <code class="reqn">\bf B</code>.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>An <code class="reqn">n \times d \times d</code> array.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Chang, J., Du, Y., Huang, G., &amp; Yao, Q. (2024). Identification and
estimation for matrix time series CP-factor models. <em>arXiv preprint</em>.
<a href="https://doi.org/10.48550/arXiv.2410.05634">doi:10.48550/arXiv.2410.05634</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CP_MTS">CP_MTS</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- 10
q &lt;- 10
n &lt;- 400
d = d1 = d2 &lt;- 3
data &lt;- DGP.CP(n,p,q,d1,d2,d)
Y &lt;- data$Y

## The first observation: Y_1
Y[1, , ]
</code></pre>

<hr>
<h2 id='Factors'>Factor analysis for vector time series</h2><span id='topic+Factors'></span>

<h3>Description</h3>

<p><code>Factors()</code> deals with factor modeling for high-dimensional
time series proposed in Lam and Yao (2012):</p>
<p style="text-align: center;"><code class="reqn">{\bf y}_t = {\bf Ax}_t +
{\boldsymbol{\epsilon}}_t, </code>
</p>
<p> where <code class="reqn">{\bf x}_t</code> is an <code class="reqn">r \times 1</code>
latent process with (unknown) <code class="reqn">r \leq p</code>, <code class="reqn">{\bf A}</code> is a <code class="reqn">p
\times r</code> unknown constant matrix, and <code class="reqn"> {\boldsymbol{\epsilon}}_t</code> is a
vector white noise process. The number of factors <code class="reqn">r</code> and the factor
loadings <code class="reqn">{\bf A}</code> can be estimated in terms of an eigenanalysis for a
nonnegative definite matrix, and is therefore applicable when the dimension
of <code class="reqn">{\bf y}_t</code> is on the order of a few thousands. This function aims to
estimate the number of factors <code class="reqn">r</code> and the factor loading matrix
<code class="reqn">{\bf A}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Factors(
  Y,
  lag.k = 5,
  thresh = FALSE,
  delta = 2 * sqrt(log(ncol(Y))/nrow(Y)),
  twostep = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Factors_+3A_y">Y</code></td>
<td>
<p>An <code class="reqn">n \times p</code> data matrix <code class="reqn">{\bf Y} = ({\bf y}_1, \dots , {\bf y}_n )'</code>,
where <code class="reqn">n</code> is the number of the observations of the <code class="reqn">p \times 1</code> time
series <code class="reqn">\{{\bf y}_t\}_{t=1}^n</code>.</p>
</td></tr>
<tr><td><code id="Factors_+3A_lag.k">lag.k</code></td>
<td>
<p>The time lag <code class="reqn">K</code> used to calculate the nonnegative definite
matrix <code class="reqn"> \hat{\mathbf{M}}</code>: </p>
<p style="text-align: center;"><code class="reqn">\hat{\mathbf{M}}\ =\
\sum_{k=1}^{K} T_\delta\{\hat{\mathbf{\Sigma}}_y(k)\} T_\delta\{\hat{\mathbf{\Sigma}}_y(k)\}'\,,
</code>
</p>
<p> where <code class="reqn">\hat{\bf \Sigma}_y(k)</code> is the sample autocovariance of
<code class="reqn"> {\bf y}_t</code> at lag <code class="reqn">k</code> and <code class="reqn">T_\delta(\cdot)</code>
is a threshold operator with the threshold level <code class="reqn">\delta \geq 0</code>. See 'Details'.
The default is 5.</p>
</td></tr>
<tr><td><code id="Factors_+3A_thresh">thresh</code></td>
<td>
<p>Logical. If <code>thresh = FALSE</code> (the default), no thresholding will
be applied to estimate <code class="reqn">\hat{\mathbf{M}}</code>. If <code>thresh = TRUE</code>,
<code class="reqn">\delta</code> will be set through <code>delta</code>.</p>
</td></tr>
<tr><td><code id="Factors_+3A_delta">delta</code></td>
<td>
<p>The value of the threshold level <code class="reqn">\delta</code>. The default is
<code class="reqn"> \delta = 2 \sqrt{n^{-1}\log p}</code>.</p>
</td></tr>
<tr><td><code id="Factors_+3A_twostep">twostep</code></td>
<td>
<p>Logical. If <code>twostep = FALSE</code> (the default), the standard
procedure [See Section 2.2 in Lam and Yao (2012)] for estimating <code class="reqn">r</code>
and <code class="reqn">{\bf A}</code> will be implemented. If <code>twostep = TRUE</code>, the two-step
estimation procedure [See Section 4 in Lam and Yao (2012)]
for estimating <code class="reqn">r</code> and <code class="reqn">{\bf A}</code> will be implemented.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The threshold operator <code class="reqn">T_\delta(\cdot)</code> is defined as
<code class="reqn">T_\delta({\bf W}) = \{w_{i,j}1(|w_{i,j}|\geq \delta)\}</code> for any matrix
<code class="reqn">{\bf W}=(w_{i,j})</code>, with the threshold level <code class="reqn">\delta \geq 0</code> and <code class="reqn">1(\cdot)</code>
representing the indicator function. We recommend to choose
<code class="reqn">\delta=0</code> when <code class="reqn">p</code> is fixed and <code class="reqn">\delta&gt;0</code> when <code class="reqn">p \gg n</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"factors"</code>, which contains the following
components: 
</p>
<table role = "presentation">
<tr><td><code>factor_num</code></td>
<td>
<p>The estimated number of factors
<code class="reqn">\hat{r}</code>.</p>
</td></tr> 
<tr><td><code>loading.mat</code></td>
<td>
<p>The estimated <code class="reqn">p \times \hat{r}</code> factor
loading matrix <code class="reqn">\hat{\bf A}</code>.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>The <code class="reqn">n\times \hat{r}</code> matrix
<code class="reqn">\hat{\bf X}=(\hat{\bf x}_1,\dots,\hat{\bf x}_n)'</code> with
<code class="reqn">\hat{\bf x}_t = \hat{\bf A}'\hat{\bf y}_t</code>.</p>
</td></tr>
<tr><td><code>lag.k</code></td>
<td>
<p>The time lag used in function.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Lam, C., &amp; Yao, Q. (2012). Factor modelling for
high-dimensional time series: Inference for the number of factors. <em>The
Annals of Statistics</em>, <strong>40</strong>, 694&ndash;726. <a href="https://doi.org/10.1214/12-AOS970">doi:10.1214/12-AOS970</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1 (Example in Section 3.3 of lam and Yao 2012)
## Generate y_t
p &lt;- 200
n &lt;- 400
r &lt;- 3
X &lt;- mat.or.vec(n, r)
A &lt;- matrix(runif(p*r, -1, 1), ncol=r)
x1 &lt;- arima.sim(model=list(ar=c(0.6)), n=n)
x2 &lt;- arima.sim(model=list(ar=c(-0.5)), n=n)
x3 &lt;- arima.sim(model=list(ar=c(0.3)), n=n)
eps &lt;- matrix(rnorm(n*p), p, n)
X &lt;- t(cbind(x1, x2, x3))
Y &lt;- A %*% X + eps
Y &lt;- t(Y)

fac &lt;- Factors(Y,lag.k=2)
r_hat &lt;- fac$factor_num
loading_Mat &lt;- fac$loading.mat
</code></pre>

<hr>
<h2 id='FamaFrench'>Fama-French 10*10 return series</h2><span id='topic+FamaFrench'></span>

<h3>Description</h3>

<p>The portfolios are constructed by the intersections of 10 levels
of size, denoted by <code class="reqn">{\rm S}_{1}, \ldots, {\rm S}_{10}</code>, and 10 levels of the book
equity to market equity ratio (BE), denoted by <code class="reqn">{\rm BE}_1, \ldots,{\rm BE}_{10}</code>.
The dataset consists of monthly returns from January 1964 to
December 2021, which contains 69600 observations for 696 total months.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(FamaFrench)
</code></pre>


<h3>Format</h3>

<p>A data frame with 696 rows and 102 columns. The first column
represents the month, and the second column named
<code>MKT.RF</code> represents the monthly market returns. The rest of the columns
represent the return series for different sizes and BE-ratios.
</p>


<h3>Source</h3>

<p><a href="http://mba.tuck.dartmouth.edu/pages/faculty/ken.french/data_library.html">http://mba.tuck.dartmouth.edu/pages/faculty/ken.french/data_library.html</a>
</p>

<hr>
<h2 id='HDSReg'>Factor analysis with observed regressors for vector time series</h2><span id='topic+HDSReg'></span>

<h3>Description</h3>

<p><code>HDSReg()</code> considers a multivariate time series model which
represents a high-dimensional vector process as a sum of three terms: a
linear regression of some observed regressors, a linear combination of some
latent and serially correlated factors, and a vector white noise:</p>
<p style="text-align: center;"><code class="reqn">{\bf
y}_t = {\bf Dz}_t + {\bf Ax}_t + {\boldsymbol {\epsilon}}_t,</code>
</p>
<p> where <code class="reqn">{\bf
y}_t</code> and <code class="reqn">{\bf z}_t</code> are, respectively, observable <code class="reqn">p\times 1</code> and
<code class="reqn">m \times 1</code> time series, <code class="reqn">{\bf x}_t</code> is an <code class="reqn">r \times 1</code> latent
factor process, <code class="reqn">{\boldsymbol{\epsilon}}_t</code> is a vector white noise process,
<code class="reqn">{\bf D}</code> is an unknown regression coefficient matrix, and
<code class="reqn">{\bf A}</code> is an unknown factor loading matrix. This procedure proposed in
Chang, Guo and Yao (2015) aims to estimate the regression coefficient
matrix <code class="reqn">{\bf D}</code>, the number of factors <code class="reqn">r</code> and the factor loading
matrix <code class="reqn">{\bf A}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HDSReg(
  Y,
  Z,
  D = NULL,
  lag.k = 5,
  thresh = FALSE,
  delta = 2 * sqrt(log(ncol(Y))/nrow(Y)),
  twostep = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HDSReg_+3A_y">Y</code></td>
<td>
<p>An <code class="reqn">n \times p</code> data matrix <code class="reqn">{\bf Y} = ({\bf y}_1, \dots , {\bf y}_n )'</code>,
where <code class="reqn">n</code> is the number of the observations of the <code class="reqn">p \times 1</code> time
series <code class="reqn">\{{\bf y}_t\}_{t=1}^n</code>.</p>
</td></tr>
<tr><td><code id="HDSReg_+3A_z">Z</code></td>
<td>
<p>An <code class="reqn">n \times m</code> data matrix <code class="reqn">{\bf Z} = ({\bf z}_1, \dots , {\bf z}_n )'</code>
consisting of the observed regressors.</p>
</td></tr>
<tr><td><code id="HDSReg_+3A_d">D</code></td>
<td>
<p>A <code class="reqn">p\times m</code> regression coefficient matrix <code class="reqn">\tilde{\bf
D}</code>. If <code>D = NULL</code> (the default), our procedure will estimate
<code class="reqn">{\bf D}</code> first and let <code class="reqn">\tilde{\bf D}</code> be the estimate of
<code class="reqn">{\bf D}</code>. If <code>D</code> is given by the users, then
<code class="reqn">\tilde{\bf D}={\bf D}</code>.</p>
</td></tr>
<tr><td><code id="HDSReg_+3A_lag.k">lag.k</code></td>
<td>
<p>The time lag <code class="reqn">K</code> used to calculate the nonnegative definte
matrix <code class="reqn"> \hat{\mathbf{M}}_{\eta}</code>: </p>
<p style="text-align: center;"><code class="reqn">\hat{\mathbf{M}}_{\eta}\ =\
\sum_{k=1}^{K} T_\delta\{\hat{\mathbf{\Sigma}}_{\eta}(k)\} T_\delta\{\hat{\mathbf{\Sigma}}_{\eta}(k)\}',
</code>
</p>
<p> where <code class="reqn">\hat{\bf \Sigma}_{\eta}(k)</code> is the sample autocovariance
of <code class="reqn"> {\boldsymbol {\eta}}_t = {\bf y}_t - \tilde{\bf D}{\bf z}_t</code>
at lag <code class="reqn">k</code> and <code class="reqn">T_\delta(\cdot)</code>
is a threshold operator with the threshold level <code class="reqn">\delta \geq 0</code>. See 'Details'.
The default is 5.</p>
</td></tr>
<tr><td><code id="HDSReg_+3A_thresh">thresh</code></td>
<td>
<p>Logical. If <code>thresh = FALSE</code> (the default), no thresholding will
be applied to estimate <code class="reqn">\hat{\mathbf{M}}_{\eta}</code>. If <code>thresh = TRUE</code>,
<code class="reqn">\delta</code> will be set through <code>delta</code>.
See 'Details'.</p>
</td></tr>
<tr><td><code id="HDSReg_+3A_delta">delta</code></td>
<td>
<p>The value of the threshold level <code class="reqn">\delta</code>. The default is
<code class="reqn"> \delta = 2 \sqrt{n^{-1}\log p}</code>.</p>
</td></tr>
<tr><td><code id="HDSReg_+3A_twostep">twostep</code></td>
<td>
<p>Logical. The same as the argument <code>twostep</code> in <code><a href="#topic+Factors">Factors</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The threshold operator <code class="reqn">T_\delta(\cdot)</code> is defined as
<code class="reqn">T_\delta({\bf W}) = \{w_{i,j}1(|w_{i,j}|\geq \delta)\}</code> for any matrix
<code class="reqn">{\bf W}=(w_{i,j})</code>, with the threshold level <code class="reqn">\delta \geq 0</code> and <code class="reqn">1(\cdot)</code>
representing the indicator function. We recommend to choose
<code class="reqn">\delta=0</code> when <code class="reqn">p</code> is fixed and <code class="reqn">\delta&gt;0</code> when <code class="reqn">p \gg n</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"factors"</code>, which contains the following
components:
</p>
<table role = "presentation">
<tr><td><code>factor_num</code></td>
<td>
<p>The estimated number of factors <code class="reqn">\hat{r}</code>.</p>
</td></tr>
<tr><td><code>reg.coff.mat</code></td>
<td>
<p>The estimated <code class="reqn">p \times m</code> regression coefficient
matrix <code class="reqn">\tilde{\bf D}</code>.</p>
</td></tr>
<tr><td><code>loading.mat</code></td>
<td>
<p>The estimated <code class="reqn">p \times \hat{r}</code> factor loading matrix
<code class="reqn">{\bf \hat{A}}</code>.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>The <code class="reqn">n\times \hat{r}</code> matrix
<code class="reqn">\hat{\bf X}=(\hat{\bf x}_1,\dots,\hat{\bf x}_n)'</code> with
<code class="reqn">\hat{\mathbf{x}}_t=\hat{\mathbf{A}}'(\mathbf{y}_t-\tilde{\mathbf{D}} \mathbf{z}_t)</code>.</p>
</td></tr>
<tr><td><code>lag.k</code></td>
<td>
<p>The time lag used in function.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Chang, J., Guo, B., &amp; Yao, Q. (2015). High dimensional
stochastic regression with latent factors, endogeneity and nonlinearity.
<em>Journal of Econometrics</em>, <strong>189</strong>, 297&ndash;312.
<a href="https://doi.org/10.1016/j.jeconom.2015.03.024">doi:10.1016/j.jeconom.2015.03.024</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Factors">Factors</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1 (Example 1 in Chang, Guo and Yao (2015)).
## Generate xt
n &lt;- 400
p &lt;- 200
m &lt;- 2
r &lt;- 3
X &lt;- mat.or.vec(n,r)
x1 &lt;- arima.sim(model = list(ar = c(0.6)), n = n)
x2 &lt;- arima.sim(model = list(ar = c(-0.5)), n = n)
x3 &lt;- arima.sim(model = list(ar = c(0.3)), n = n)
X &lt;- cbind(x1, x2, x3)
X &lt;- t(X)

## Generate yt
Z &lt;- mat.or.vec(m,n)
S1 &lt;- matrix(c(5/8, 1/8, 1/8, 5/8), 2, 2)
Z[,1] &lt;- c(rnorm(m))
for(i in c(2:n)){
  Z[,i] &lt;- S1%*%Z[, i-1] + c(rnorm(m))
}
D &lt;- matrix(runif(p*m, -2, 2), ncol = m)
A &lt;- matrix(runif(p*r, -2, 2), ncol = r)
eps &lt;- mat.or.vec(n, p)
eps &lt;- matrix(rnorm(n*p), p, n)
Y &lt;- D %*% Z + A %*% X + eps
Y &lt;- t(Y)
Z &lt;- t(Z)

## D is known
res1 &lt;- HDSReg(Y, Z, D, lag.k = 2)
## D is unknown
res2 &lt;- HDSReg(Y, Z, lag.k = 2)
</code></pre>

<hr>
<h2 id='IPindices'>U.S. Industrial Production indices</h2><span id='topic+IPindices'></span>

<h3>Description</h3>

<p>The dataset consists of 7 monthly U.S. Industrial
Production indices, namely <em>the total index</em>, <em>nonindustrial supplies</em>,
<em>final products</em>, <em>manufacturing</em>, <em>materials</em>, <em>mining</em>,
and <em>utilities</em>, from January 1947 to December 2023 published by the U.S.
Federal Reserve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(IPindices)
</code></pre>


<h3>Format</h3>

<p>A data frame with 924 rows and 8 variables:
</p>

<dl>
<dt>DATE</dt><dd><p>The observation date</p>
</dd>
<dt>INDPRO</dt><dd><p>The total index</p>
</dd>
<dt>IPB54000S</dt><dd><p>Nonindustrial supplies</p>
</dd>
<dt>IPFINAL</dt><dd><p>Final products</p>
</dd>
<dt>IPMANSICS</dt><dd><p>Manufacturing</p>
</dd>
<dt>IPMAT</dt><dd><p>Materials</p>
</dd>
<dt>IPMINE</dt><dd><p>Mining</p>
</dd>
<dt>IPUTIL</dt><dd><p>Utilities</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://fred.stlouisfed.org/release/tables?rid=13&amp;eid=49670">https://fred.stlouisfed.org/release/tables?rid=13&amp;eid=49670</a>
</p>

<hr>
<h2 id='MartG_test'>Testing for martingale difference hypothesis in high dimension</h2><span id='topic+MartG_test'></span>

<h3>Description</h3>

<p><code>MartG_test()</code> implements a new test proposed in
Chang, Jiang and Shao (2023) for the following hypothesis testing problem: 
</p>
<p style="text-align: center;"><code class="reqn">H_0:\{{\bf y}_t\}_{t=1}^n\mathrm{\ is\ a\ MDS\ \ versus\ \ }H_1:
\{{\bf y}_t\}_{t=1}^n\mathrm{\ is\ not\ a\ MDS}\,, </code>
</p>
<p> where 
MDS is the abbreviation of &quot;martingale difference sequence&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MartG_test(
  Y,
  lag.k = 2,
  B = 1000,
  type = c("Linear", "Quad"),
  alpha = 0.05,
  kernel.type = c("QS", "Par", "Bart")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MartG_test_+3A_y">Y</code></td>
<td>
<p>An <code class="reqn">n \times p</code> data matrix <code class="reqn">{\bf Y} = ({\bf y}_1, \dots , {\bf y}_n )'</code>,
where <code class="reqn">n</code> is the number of the observations of the <code class="reqn">p \times 1</code>
time series <code class="reqn">\{{\bf y}_t\}_{t=1}^n</code>.</p>
</td></tr>
<tr><td><code id="MartG_test_+3A_lag.k">lag.k</code></td>
<td>
<p>The time lag <code class="reqn">K</code> used to calculate the test
statistic [See (3) in Chang, Jiang and Shao (2023)]. The default is 2.</p>
</td></tr>
<tr><td><code id="MartG_test_+3A_b">B</code></td>
<td>
<p>The number of bootstrap replications for generating multivariate
normally distributed random vectors when calculating the critical value. 
The default is 1000.</p>
</td></tr>
<tr><td><code id="MartG_test_+3A_type">type</code></td>
<td>
<p>The map used for constructing the test statistic.
Available options include: <code>"Linear"</code> (the default) for the linear identity 
map and <code>"Quad"</code> for the map including both linear and quadratic terms.
<code>type</code> can also be set by the users. See 'Details' and Section 2.1
of Chang, Jiang and Shao (2023) for more information.</p>
</td></tr>
<tr><td><code id="MartG_test_+3A_alpha">alpha</code></td>
<td>
<p>The significance level of the test. The default is 0.05.</p>
</td></tr>
<tr><td><code id="MartG_test_+3A_kernel.type">kernel.type</code></td>
<td>
<p>The option for choosing the symmetric kernel 
used in the estimation of long-run covariance matrix. 
Available options include: <code>"QS"</code> (the default)  for the
Quadratic spectral kernel, <code>"Par"</code> for the Parzen kernel,
and <code>"Bart"</code>  for the Bartlett kernel.
See Chang, Jiang and Shao (2023) for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Write <code class="reqn">{\bf x}= (x_1,\ldots,x_p)'</code>.
When <code>type = "Linear"</code>, the linear identity map is defined
as <code class="reqn">\boldsymbol \phi({\bf x})={\bf x}</code>.
</p>
<p>When <code>type = "Quad"</code>,
<code class="reqn">\boldsymbol \phi({\bf x})=\{{\bf x}',({\bf x}^2)'\}'</code>
includes both linear and quadratic terms, where
<code class="reqn">{\bf x}^2 = (x_1^2,\ldots,x_p^2)'</code>.
</p>
<p>We can also choose <code class="reqn">\boldsymbol \phi({\bf x}) = \cos({\bf x})</code> to capture
certain type of nonlinear dependence, where
<code class="reqn">\cos({\bf x}) = (\cos x_1,\ldots,\cos x_p)'</code>.
</p>
<p>See 'Examples'.
</p>


<h3>Value</h3>

<p>An object of class <code>"hdtstest"</code>, which contains the following
components:
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>The test statistic of the test.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The p-value of the test.</p>
</td></tr>
<tr><td><code>lag.k</code></td>
<td>
<p>The time lag used in function.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>The map used in function.</p>
</td></tr>
<tr><td><code>kernel.type</code></td>
<td>
<p>The kernel used in function.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Chang, J., Jiang, Q., &amp; Shao, X. (2023). Testing the
martingale difference hypothesis in high dimension. <em>Journal of 
Econometrics</em>, <strong>235</strong>, 972&ndash;1000. <a href="https://doi.org/10.1016/j.jeconom.2022.09.001">doi:10.1016/j.jeconom.2022.09.001</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
n &lt;- 200
p &lt;- 10
X &lt;- matrix(rnorm(n*p),n,p)

res &lt;- MartG_test(X, type="Linear")
res &lt;- MartG_test(X, type=cbind(X, X^2)) #the same as type = "Quad"

## map can also be defined as an expression in R.
res &lt;- MartG_test(X, type=quote(cbind(X, X^2))) # expr using quote()
res &lt;- MartG_test(X, type=substitute(cbind(X, X^2))) # expr using substitute()
res &lt;- MartG_test(X, type=expression(cbind(X, X^2))) # expr using expression()
res &lt;- MartG_test(X, type=parse(text="cbind(X, X^2)")) # expr using parse()

## map can also be defined as a function in R.
map_fun &lt;- function(X) {X &lt;- cbind(X, X^2); X}

res &lt;- MartG_test(X, type=map_fun)
Pvalue &lt;- res$p.value
rej &lt;- res$reject
</code></pre>

<hr>
<h2 id='PCA_TS'>Principal component analysis for vector time series</h2><span id='topic+PCA_TS'></span>

<h3>Description</h3>

<p><code>PCA_TS()</code> seeks for a contemporaneous linear
transformation for a multivariate time series such that the transformed
series is segmented into several lower-dimensional subseries: </p>
<p style="text-align: center;"><code class="reqn">{\bf
  y}_t={\bf Ax}_t,</code>
</p>
<p> where <code class="reqn">{\bf x}_t</code> is an unobservable <code class="reqn">p \times 1</code>
weakly stationary time series consisting of <code class="reqn">q\ (\geq 1)</code> both
contemporaneously and serially uncorrelated subseries. See Chang, Guo and
Yao (2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCA_TS(
  Y,
  lag.k = 5,
  opt = 1,
  permutation = c("max", "fdr"),
  thresh = FALSE,
  delta = 2 * sqrt(log(ncol(Y))/nrow(Y)),
  prewhiten = TRUE,
  m = NULL,
  beta,
  control = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PCA_TS_+3A_y">Y</code></td>
<td>
<p>An <code class="reqn">n \times p</code> data matrix <code class="reqn">{\bf Y} = ({\bf y}_1, \dots , {\bf y}_n )'</code>,
where <code class="reqn">n</code> is the number of the observations of the <code class="reqn">p \times 1</code>
time series <code class="reqn">\{{\bf y}_t\}_{t=1}^n</code>. The procedure will first
normalize <code class="reqn">{\bf y}_t</code> as <code class="reqn">\hat{{\bf V}}^{-1/2}{\bf y}_t</code>, where
<code class="reqn">\hat{{\bf V}}</code> is an estimator for covariance of <code class="reqn">{\bf y}_t</code>.
See details below for the selection of <code class="reqn">\hat{{\bf V}}^{-1}</code>.</p>
</td></tr>
<tr><td><code id="PCA_TS_+3A_lag.k">lag.k</code></td>
<td>
<p>The time lag <code class="reqn">K</code> used to calculate the nonnegative definte
matrix <code class="reqn">\hat{{\bf W}}_y</code>: </p>
<p style="text-align: center;"><code class="reqn">\hat{\mathbf{W}}_y\ =\ \mathbf{I}_p+
\sum_{k=1}^{K} T_\delta \{\hat{\mathbf{\Sigma}}_y(k)\} T_\delta \{\hat{\mathbf{\Sigma}}_y(k)\}',
 </code>
</p>
<p> where <code class="reqn">\hat{\bf \Sigma}_y(k)</code> is the sample autocovariance of
<code class="reqn"> \hat{{\bf V}}^{-1/2}{\bf y}_t</code> at lag <code class="reqn">k</code> and <code class="reqn">T_\delta(\cdot)</code>
is a threshold operator with the threshold level <code class="reqn">\delta \geq 0</code>. See 'Details'.
The default is 5.</p>
</td></tr>
<tr><td><code id="PCA_TS_+3A_opt">opt</code></td>
<td>
<p>An option used to choose which method will be implemented to get a
consistent estimate <code class="reqn">\hat{\bf V}</code> (or <code class="reqn">\hat{\bf V}^{-1}</code>) for the
covariance (precision) matrix of <code class="reqn">{\bf y}_t</code>. If <code>opt = 1</code>,
<code class="reqn">\hat{\bf V}</code> will be defined as the sample covariance matrix. If
<code>opt = 2</code>, the precision matrix <code class="reqn">\hat{\bf V}^{-1}</code> will be calculated
by using the function <code>clime()</code> of <span class="pkg">clime</span> (Cai, Liu and Luo, 2011) with
the arguments passed by <code>control</code>.</p>
</td></tr>
<tr><td><code id="PCA_TS_+3A_permutation">permutation</code></td>
<td>
<p>The method of permutation procedure to assign the
components of <code class="reqn">\hat{\bf z}_t</code> to different groups [See Section 2.2.1 in
Chang, Guo and Yao (2018)]. Available options include: <code>"max"</code> (the default) for the
maximum cross correlation method and <code>"fdr"</code> for the false discovery
rate procedure based on multiple tests. See Sections
2.2.2 and 2.2.3 in Chang, Guo and Yao (2018) for more information.</p>
</td></tr>
<tr><td><code id="PCA_TS_+3A_thresh">thresh</code></td>
<td>
<p>Logical. If <code>thresh = FALSE</code> (the default), no thresholding will
be applied to estimate <code class="reqn">\hat{\bf W}_y</code>. If <code>thresh = TRUE</code>, the
argument <code>delta</code> is used to specify the threshold level <code class="reqn">\delta</code>.</p>
</td></tr>
<tr><td><code id="PCA_TS_+3A_delta">delta</code></td>
<td>
<p>The value of the threshold level <code class="reqn">\delta</code>. The default is
<code class="reqn"> \delta = 2 \sqrt{n^{-1}\log p}</code>.</p>
</td></tr>
<tr><td><code id="PCA_TS_+3A_prewhiten">prewhiten</code></td>
<td>
<p>Logical. If <code>TRUE</code> (the default), we prewhiten each
transformed component series of <code class="reqn">\hat{\bf z}_t</code> [See Section 2.2.1 in
Chang, Guo and Yao (2018)] by fitting a univariate AR model with the order
between 0 and 5 determined by AIC. If <code>FALSE</code>, then the prewhiten
procedure will not be performed.</p>
</td></tr>
<tr><td><code id="PCA_TS_+3A_m">m</code></td>
<td>
<p>A positive integer used in the permutation procedure [See (2.10) in
Chang, Guo and Yao (2018)]. The default is 10.</p>
</td></tr>
<tr><td><code id="PCA_TS_+3A_beta">beta</code></td>
<td>
<p>The error rate used in the permutation procedure[See (2.16) in
Chang, Guo and Yao (2018)] when <code>permutation = "fdr"</code>.</p>
</td></tr>
<tr><td><code id="PCA_TS_+3A_control">control</code></td>
<td>
<p>A list of control arguments. See ‘Details’.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The threshold operator <code class="reqn">T_\delta(\cdot)</code> is defined as
<code class="reqn">T_\delta({\bf W}) = \{w_{i,j}1(|w_{i,j}|\geq \delta)\}</code> for any matrix
<code class="reqn">{\bf W}=(w_{i,j})</code>, with the threshold level <code class="reqn">\delta \geq 0</code> and <code class="reqn">1(\cdot)</code>
representing the indicator function. We recommend to choose
<code class="reqn">\delta=0</code> when <code class="reqn">p</code> is fixed and <code class="reqn">\delta&gt;0</code> when <code class="reqn">p \gg n</code>.
</p>
<p>For large <code class="reqn">p</code>, since the sample covariance matrix may not be consistent,
we recommend to use the method proposed
in Cai, Liu and Luo (2011) to estimate the precision matrix 
<code class="reqn">\hat{{\bf V}}^{-1}</code> (<code>opt = 2</code>).
</p>
<p><code>control</code> is a list of arguments passed to the function <code>clime()</code>,
which contains the following components:
</p>

<ul>
<li> <p><code>nlambda</code>: Number of values for program generated lambda. The default is 100.
</p>
</li>
<li> <p><code>lambda.max</code>: Maximum value of program generated lambda. The default is 0.8.
</p>
</li>
<li> <p><code>lambda.min</code>: Minimum value of program generated lambda. 
The default is <code class="reqn">10^{-4}</code> (<code class="reqn">n&gt;p</code>) or <code class="reqn">10^{-2}</code> (<code class="reqn">n&lt;p</code>).
</p>
</li>
<li> <p><code>standardize</code>: Logical. If <code>standardize = TRUE</code>, the
variables will be standardized to have mean zero and unit standard
deviation. The default is <code>FALSE</code>.
</p>
</li>
<li> <p><code>linsolver</code>: An option used to choose which method should be employed.
Available options include <code>"primaldual"</code> (the default) and <code>"simplex"</code>.
Rule of thumb: <code>"primaldual"</code> for large <code class="reqn">p</code>, <code>"simplex"</code> for small <code class="reqn">p</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code>"tspca"</code>, which contains the following
components: 
</p>
<table role = "presentation">
<tr><td><code>B</code></td>
<td>
<p>The <code class="reqn">p\times p</code> transformation matrix
<code class="reqn">\hat{\bf B}=\hat{\bf \Gamma}_y'\hat{{\bf V}}^{-1/2}</code>, where
<code class="reqn">\hat{\bf \Gamma}_y</code> is a <code class="reqn">p \times p</code> orthogonal matrix with the
columns being the eigenvectors of <code class="reqn">\hat{\bf W}_y</code>.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>The <code class="reqn">n \times p</code> matrix
<code class="reqn">\hat{\bf X}=(\hat{\bf x}_1,\dots,\hat{\bf x}_n)'</code> with
<code class="reqn">\hat{\bf x}_t = \hat{\bf B}{\bf y}_t</code>.</p>
</td></tr>
<tr><td><code>NoGroups</code></td>
<td>
<p>The number of groups.</p>
</td></tr>
<tr><td><code>No_of_Members</code></td>
<td>
<p>The number of members in each group.</p>
</td></tr>
<tr><td><code>Groups</code></td>
<td>
<p>The indices of the components of <code class="reqn">\hat{\bf x}_t</code> that
belong to each group.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>A string indicating which permutation procedure is performed.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Cai, T., Liu, W., &amp; Luo, X. (2011). A constrained L1 minimization
approach for sparse precision matrix estimation. <em>Journal of the American
Statistical Association</em>, <strong>106</strong>, 594&ndash;607. <a href="https://doi.org/10.1198/jasa.2011.tm10155">doi:10.1198/jasa.2011.tm10155</a>.
</p>
<p>Chang, J., Guo, B., &amp; Yao, Q. (2018). Principal component
analysis for second-order stationary vector time series. <em>The Annals of
Statistics</em>, <strong>46</strong>, 2094&ndash;2124. <a href="https://doi.org/10.1214/17-AOS1613">doi:10.1214/17-AOS1613</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1 (Example 1 in the supplementary material of Chang, Guo and Yao (2018)).
# p=6, x_t consists of 3 independent subseries with 3, 2 and 1 components.

## Generate x_t
p &lt;- 6;n &lt;- 1500
X &lt;- mat.or.vec(p,n)
x &lt;- arima.sim(model = list(ar = c(0.5, 0.3), ma = c(-0.9, 0.3, 1.2,1.3)),
n = n+2, sd = 1)
for(i in 1:3) X[i,] &lt;- x[i:(n+i-1)]
x &lt;- arima.sim(model = list(ar = c(0.8,-0.5),ma = c(1,0.8,1.8) ), n = n+1, sd = 1)
for(i in 4:5) X[i,] &lt;- x[(i-3):(n+i-4)]
x &lt;- arima.sim(model = list(ar = c(-0.7, -0.5), ma = c(-1, -0.8)), n = n, sd = 1)
X[6,] &lt;- x

## Generate y_t
A &lt;- matrix(runif(p*p, -3, 3), ncol = p)
Y &lt;- A%*%X
Y &lt;- t(Y)

## permutation = "max" or permutation = "fdr"
res &lt;- PCA_TS(Y, lag.k = 5,permutation = "max")
res1 &lt;- PCA_TS(Y, lag.k = 5,permutation = "fdr", beta = 10^(-10))
Z &lt;- res$X


# Example 2 (Example 2 in the supplementary material of Chang, Guo and Yao (2018)).
# p=20, x_t consists of 5 independent subseries with 6, 5, 4, 3 and 2 components.

## Generate x_t
p &lt;- 20;n &lt;- 3000
X &lt;- mat.or.vec(p,n)
x &lt;- arima.sim(model = list(ar = c(0.5, 0.3), ma = c(-0.9, 0.3, 1.2, 1.3)), 
n.start = 500, n = n+5, sd = 1)
for(i in 1:6) X[i,] &lt;- x[i:(n+i-1)]
x &lt;- arima.sim(model = list(ar = c(-0.4, 0.5), ma = c(1, 0.8, 1.5, 1.8)),
n.start = 500, n = n+4, sd = 1)
for(i in 7:11) X[i,] &lt;- x[(i-6):(n+i-7)]
x &lt;- arima.sim(model = list(ar = c(0.85,-0.3), ma=c(1, 0.5, 1.2)),
n.start = 500, n = n+3,sd = 1)
for(i in 12:15) X[i,] &lt;- x[(i-11):(n+i-12)]
x &lt;- arima.sim(model = list(ar = c(0.8, -0.5),ma = c(1, 0.8, 1.8)),
n.start = 500, n = n+2,sd = 1)
for(i in 16:18) X[i,] &lt;- x[(i-15):(n+i-16)]
x &lt;- arima.sim(model = list(ar = c(-0.7, -0.5), ma = c(-1, -0.8)),
n.start = 500,n = n+1,sd = 1)
for(i in 19:20) X[i,] &lt;- x[(i-18):(n+i-19)]

## Generate y_t
A &lt;- matrix(runif(p*p, -3, 3), ncol =p)
Y &lt;- A%*%X
Y &lt;- t(Y)

## permutation = "max" or permutation = "fdr"
res &lt;- PCA_TS(Y, lag.k = 5,permutation = "max")
res1 &lt;- PCA_TS(Y, lag.k = 5,permutation = "fdr",beta = 10^(-200))
Z &lt;- res$X

</code></pre>

<hr>
<h2 id='predict.factors'>Make predictions from a <code>"factors"</code> object</h2><span id='topic+predict.factors'></span>

<h3>Description</h3>

<p>This function makes predictions from a <code>"factors"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'factors'
predict(
  object,
  newdata = NULL,
  n.ahead = 10,
  control_ARIMA = list(),
  control_VAR = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.factors_+3A_object">object</code></td>
<td>
<p>An object of class <code>"factors"</code> constructed by <code><a href="#topic+Factors">Factors</a></code>.</p>
</td></tr>
<tr><td><code id="predict.factors_+3A_newdata">newdata</code></td>
<td>
<p>Optional. A new data matrix to predict from.</p>
</td></tr>
<tr><td><code id="predict.factors_+3A_n.ahead">n.ahead</code></td>
<td>
<p>An integer specifying the number of steps ahead for prediction.</p>
</td></tr>
<tr><td><code id="predict.factors_+3A_control_arima">control_ARIMA</code></td>
<td>
<p>A list of arguments passed to the function
<code>auto.arima()</code> of <span class="pkg">forecast</span>. See 'Details' and the manual of <code>auto.arima()</code>.
The default is <code>list(ic = "aic")</code>.</p>
</td></tr>
<tr><td><code id="predict.factors_+3A_control_var">control_VAR</code></td>
<td>
<p>A list of arguments passed to the function
<code>VAR()</code> of <span class="pkg">vars</span>. See 'Details' and the manual of <code>VAR()</code>.
The default is <code>list(type = "const", lag.max = 6, ic = "AIC")</code>.</p>
</td></tr>
<tr><td><code id="predict.factors_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Forecasting for <code class="reqn">{\bf y}_t</code> can be implemented in two steps:
</p>
<p><em>Step 1</em>. Get the <code class="reqn">h</code>-step ahead forecast of the <code class="reqn">\hat{r} \times 1</code> 
time series <code class="reqn">\hat{\bf x}_t</code> [See <code><a href="#topic+Factors">Factors</a></code>], denoted by
<code class="reqn">\hat{\bf x}_{n+h}</code>, using a VAR model 
(if <code class="reqn">\hat{r} &gt; 1</code>) or an ARIMA model (if <code class="reqn">\hat{r} = 1</code>). The orders 
of VAR and ARIMA models are determined by AIC by default. Otherwise, they 
can also be specified by users through the arguments <code>control_VAR</code>
and <code>control_ARIMA</code>, respectively.
</p>
<p><em>Step 2</em>. The forecasted value for <code class="reqn">{\bf y}_t</code> is obtained by
<code class="reqn">\hat{\bf y}_{n+h}= \hat{\bf A}\hat{\bf x}_{n+h}</code>.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>ts_pred</code></td>
<td>
<p>A matrix of predicted values.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+Factors">Factors</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(HDTSA)
data(FamaFrench, package = "HDTSA")

## Remove the market effects
reg &lt;- lm(as.matrix(FamaFrench[, -c(1:2)]) ~ as.matrix(FamaFrench$MKT.RF))
Y_2d = reg$residuals

res_factors &lt;- Factors(Y_2d, lag.k = 5)
pred_fac_Y &lt;- predict(res_factors, n.ahead = 1)

</code></pre>

<hr>
<h2 id='predict.mtscp'>Make predictions from a <code>"mtscp"</code> object</h2><span id='topic+predict.mtscp'></span>

<h3>Description</h3>

<p>This function makes predictions from a <code>"mtscp"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mtscp'
predict(
  object,
  newdata = NULL,
  n.ahead = 10,
  control_ARIMA = list(),
  control_VAR = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.mtscp_+3A_object">object</code></td>
<td>
<p>An object of class <code>"mtscp"</code> constructed by <code><a href="#topic+CP_MTS">CP_MTS</a></code>.</p>
</td></tr>
<tr><td><code id="predict.mtscp_+3A_newdata">newdata</code></td>
<td>
<p>Optional. A new data matrix to predict from.</p>
</td></tr>
<tr><td><code id="predict.mtscp_+3A_n.ahead">n.ahead</code></td>
<td>
<p>An integer specifying the number of steps ahead for prediction.</p>
</td></tr>
<tr><td><code id="predict.mtscp_+3A_control_arima">control_ARIMA</code></td>
<td>
<p>A list of arguments passed to the function
<code>auto.arima()</code> of <span class="pkg">forecast</span>. See 'Details' and the manual of <code>auto.arima()</code>.
The default is <code>list(ic = "aic")</code>.</p>
</td></tr>
<tr><td><code id="predict.mtscp_+3A_control_var">control_VAR</code></td>
<td>
<p>A list of arguments passed to the function
<code>VAR()</code> of <span class="pkg">vars</span>. See 'Details' and the manual of <code>VAR()</code>.
The default is <code>list(type = "const", lag.max = 6, ic = "AIC")</code>.</p>
</td></tr>
<tr><td><code id="predict.mtscp_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Forecasting for <code class="reqn">{\bf y}_t</code> can be implemented in two steps:
</p>
<p><em>Step 1</em>. Get the <code class="reqn">h</code>-step ahead forecast of the <code class="reqn">\hat{d} \times 1</code> 
time series <code class="reqn">\hat{\bf x}_t=(\hat{x}_{t,1},\ldots,\hat{x}_{t,\hat{d}})'</code>
[See <code><a href="#topic+CP_MTS">CP_MTS</a></code>], denoted by <code class="reqn">\hat{\bf x}_{n+h}</code>, using a VAR model 
(if <code class="reqn">\hat{d} &gt; 1</code>) or an ARIMA model
(if <code class="reqn">\hat{d} = 1</code>). The orders of VAR and ARIMA models are determined by
AIC by default. Otherwise, they can also be specified by users through the
arguments <code>control_VAR</code> and <code>control_ARIMA</code>, respectively.
</p>
<p><em>Step 2</em>. The forecasted value for <code class="reqn">{\bf Y}_t</code> is obtained by
<code class="reqn">\hat{\bf Y}_{n+h}= \hat{\bf A} \hat{\bf X}_{n+h} \hat{\bf B}'</code> with
<code class="reqn"> \hat{\bf X}_{n+h} = {\rm diag}(\hat{\bf x}_{n+h})</code>.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Y_pred</code></td>
<td>
<p>A list of length <code>n.ahead</code>, where each element is a 
<code class="reqn">p \times q</code> matrix representing the predicted values at
each time step.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+CP_MTS">CP_MTS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(HDTSA)
data(FamaFrench, package = "HDTSA")

## Remove the market effects
reg &lt;- lm(as.matrix(FamaFrench[, -c(1:2)]) ~ as.matrix(FamaFrench$MKT.RF))
Y_2d = reg$residuals

## Rearrange Y_2d into a 3-dimensional array Y
Y = array(NA, dim = c(NROW(Y_2d), 10, 10))
for (tt in 1:NROW(Y_2d)) {
  for (ii in 1:10) {
    Y[tt, ii, ] &lt;- Y_2d[tt, (1 + 10*(ii - 1)):(10 * ii)]
  }
}

res_cp &lt;- CP_MTS(Y, lag.k = 20, method = "CP.Refined")
pred_cp_Y &lt;- predict(res_cp, n.ahead = 1)[[1]]

</code></pre>

<hr>
<h2 id='predict.tspca'>Make predictions from a <code>"tspca"</code> object</h2><span id='topic+predict.tspca'></span>

<h3>Description</h3>

<p>This function makes predictions from a <code>"tspca"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tspca'
predict(
  object,
  newdata = NULL,
  n.ahead = 10,
  control_ARIMA = list(),
  control_VAR = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.tspca_+3A_object">object</code></td>
<td>
<p>An object of class <code>"tspca"</code> constructed by <code><a href="#topic+PCA_TS">PCA_TS</a></code>.</p>
</td></tr>
<tr><td><code id="predict.tspca_+3A_newdata">newdata</code></td>
<td>
<p>Optional. A new data matrix to predict from.</p>
</td></tr>
<tr><td><code id="predict.tspca_+3A_n.ahead">n.ahead</code></td>
<td>
<p>An integer specifying the number of steps ahead for prediction.</p>
</td></tr>
<tr><td><code id="predict.tspca_+3A_control_arima">control_ARIMA</code></td>
<td>
<p>A list of arguments passed to the function
<code>auto.arima()</code> of <span class="pkg">forecast</span>. See 'Details' and the manual of <code>auto.arima()</code>.
The default is <code>list(max.d = 0, max.q = 0, ic = "aic")</code>.</p>
</td></tr>
<tr><td><code id="predict.tspca_+3A_control_var">control_VAR</code></td>
<td>
<p>A list of arguments passed to the function
<code>VAR()</code> of <span class="pkg">vars</span>. See 'Details' and the manual of <code>VAR()</code>.
The default is <code>list(type = "const", lag.max = 6, ic = "AIC")</code>.</p>
</td></tr>
<tr><td><code id="predict.tspca_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Having obtained <code class="reqn">\hat{\bf x}_t</code> using the <code><a href="#topic+PCA_TS">PCA_TS</a></code> function, which is
segmented into <code class="reqn">q</code> uncorrelated subseries
<code class="reqn">\hat{\bf x}_t^{(1)},\ldots,\hat{\bf x}_t^{(q)}</code>, the forecasting for <code class="reqn">{\bf y}_t</code>
can be performed in two steps:
</p>
<p><em>Step 1</em>. Get the <code class="reqn">h</code>-step ahead forecast <code class="reqn">\hat{\bf x}_{n+h}^{(j)}</code> <code class="reqn">(j=1,\ldots,q)</code>
by using a VAR model (if the dimension of <code class="reqn">\hat{\bf x}_t^{(j)}</code> is larger than 1) 
or an ARIMA model (if the dimension of <code class="reqn">\hat{\bf x}_t^{(j)}</code> is 1). The orders 
of VAR and ARIMA models are determined by AIC by default. Otherwise, they 
can also be specified by users through the arguments <code>control_VAR</code> and <code>control_ARIMA</code>, respectively.
</p>
<p><em>Step 2</em>. Let <code class="reqn">\hat{\bf x}_{n+h} = (\{\hat{\bf x}_{n+h}^{(1)}\}',\ldots,\{\hat{\bf x}_{n+h}^{(q)}\}')'</code>.
The forecasted value for <code class="reqn">{\bf y}_t</code> is obtained by
<code class="reqn">\hat{\bf y}_{n+h}= \hat{\bf B}^{-1}\hat{\bf x}_{n+h}</code>.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Y_pred</code></td>
<td>
<p>A matrix of predicted values.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+PCA_TS">PCA_TS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(HDTSA)
data(FamaFrench, package = "HDTSA")

## Remove the market effects
reg &lt;- lm(as.matrix(FamaFrench[, -c(1:2)]) ~ as.matrix(FamaFrench$MKT.RF))
Y_2d = reg$residuals

res_pca &lt;- PCA_TS(Y_2d, lag.k = 5, thresh = TRUE)
pred_pca_Y &lt;- predict(res_pca, n.ahead = 1)


</code></pre>

<hr>
<h2 id='QWIdata'>The national QWI hires data</h2><span id='topic+QWIdata'></span>

<h3>Description</h3>

<p>The data on new hires at a national level are obtained from the
Quarterly Workforce Indicators (QWI) of the Longitudinal Employer-Household
Dynamics program at the U.S. Census Bureau (Abowd et al., 2009). The national
QWI hires data covers a variable number of years, with some states providing
time series going back to 1990 (e.g., Washington), and others
(e.g., Massachusetts) only commencing at 2010. For each of 51 states
(excluding D.C. but including Puerto Rico) there is a new hires time series
for each county. Additional description of the data, along with its relevancy
to labor economics, can be found in Hyatt and McElroy (2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(QWIdata)
</code></pre>


<h3>Format</h3>

<p>A list with 51 elements. Every element contains a multivariate time series.
</p>


<h3>Source</h3>

<p><a href="https://qwiexplorer.ces.census.gov/">https://qwiexplorer.ces.census.gov/</a>
</p>
<p><a href="https://ledextract.ces.census.gov/qwi/all">https://ledextract.ces.census.gov/qwi/all</a>
</p>


<h3>References</h3>

<p>Abowd, J. M., Stephens, B. E., Vilhuber, L., Andersson, F., McKinney, K. L., Roemer,
M., and Woodcock, S. (2009). The LEHD infrastructure files and the creation of the
quarterly workforce indicators. In <em>Producer dynamics: New evidence from micro data</em>,
pages 149&ndash;230. University of Chicago Press. <a href="https://doi.org/10.7208/chicago/9780226172576.003.0006">doi:10.7208/chicago/9780226172576.003.0006</a>.
</p>
<p>Hyatt, H. R. and McElroy, T. S. (2019). Labor reallocation, employment,
and earnings: Vector autoregression evidence. <em>Labour</em>, <strong>33</strong>, 463&ndash;487.
<a href="https://doi.org/10.1111/labr.12153">doi:10.1111/labr.12153</a>
</p>

<hr>
<h2 id='SpecMulTest'>Multiple testing with FDR control for spectral density matrix</h2><span id='topic+SpecMulTest'></span>

<h3>Description</h3>

<p><code>SpecMulTest()</code> implements a new multiple testing procedure proposed in
Chang et al. (2022) for the following <code class="reqn">Q</code> hypothesis testing problems: 
</p>
<p style="text-align: center;"><code class="reqn">H_{0,q}:f_{i,j}(\omega)=0\mathrm{\ for\ any\ }(i,j)\in\mathcal{I}^{(q)}\mathrm{\ and\ }
\omega\in\mathcal{J}^{(q)}\mathrm{\ \ versus\ \ }
H_{1,q}:H_{0,q}\mathrm{\ is\ not\ true} </code>
</p>

<p>for <code class="reqn">q=1,\dots,Q</code>. 
Here, <code class="reqn">f_{i,j}(\omega)</code> represents the cross-spectral density between 
<code class="reqn"> x_{t,i}</code> and <code class="reqn"> x_{t,j}</code> at frequency <code class="reqn">\omega</code> with <code class="reqn">x_{t,i}</code> being 
the <code class="reqn">i</code>-th component of the <code class="reqn">p \times 1</code> times series <code class="reqn">{\bf x}_t</code>,
and <code class="reqn">\mathcal{I}^{(q)}</code> and <code class="reqn">\mathcal{J}^{(q)}</code> refer to
the set of index pairs and the set of frequencies associated with the
<code class="reqn">q</code>-th test, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SpecMulTest(Q, PVal, alpha = 0.05, seq_len = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SpecMulTest_+3A_q">Q</code></td>
<td>
<p>The number of the hypothesis tests.</p>
</td></tr>
<tr><td><code id="SpecMulTest_+3A_pval">PVal</code></td>
<td>
<p>A vector of length <code class="reqn">Q</code> representing p-values of the <code class="reqn">Q</code> hypothesis tests.</p>
</td></tr>
<tr><td><code id="SpecMulTest_+3A_alpha">alpha</code></td>
<td>
<p>The prescribed level for the FDR control. The default is 0.05.</p>
</td></tr>
<tr><td><code id="SpecMulTest_+3A_seq_len">seq_len</code></td>
<td>
<p>The step size for generating a sequence from 0 to
<code class="reqn">\sqrt{2\times\log Q-2\times\log(\log Q )}</code>. The default is 0.01.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"hdtstest"</code>, which contains the following
component:
</p>
<table role = "presentation">
<tr><td><code>MultiTest</code></td>
<td>
<p>A logical vector of length <code class="reqn">Q</code>. If its <code class="reqn">q</code>-th element is <code>TRUE</code>, 
it indicates that <code class="reqn">H_{0,q}</code> should be rejected. Otherwise,
<code class="reqn">H_{0,q}</code> should not be rejected.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Chang, J., Jiang, Q., McElroy, T. S., &amp; Shao, X. (2022). 
Statistical inference for high-dimensional spectral density matrix.
<em>arXiv preprint</em>. <a href="https://doi.org/10.48550/arXiv.2212.13686">doi:10.48550/arXiv.2212.13686</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SpecTest">SpecTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
## Generate xt
n &lt;- 200
p &lt;- 10
flag_c &lt;- 0.8
B &lt;- 1000
burn &lt;- 1000
z.sim &lt;- matrix(rnorm((n+burn)*p),p,n+burn)
phi.mat &lt;- 0.4*diag(p)
x.sim &lt;- phi.mat %*% z.sim[,(burn+1):(burn+n)]
x &lt;- x.sim - rowMeans(x.sim)
Q &lt;- 4

## Generate the sets Iq and Jq
ISET &lt;- list()
ISET[[1]] &lt;- matrix(c(1,2),ncol=2)
ISET[[2]] &lt;- matrix(c(1,3),ncol=2)
ISET[[3]] &lt;- matrix(c(1,4),ncol=2)
ISET[[4]] &lt;- matrix(c(1,5),ncol=2)
JSET &lt;- as.list(2*pi*seq(0,3)/4 - pi)

## Calculate Q p-values
PVal &lt;- rep(NA,Q)
for (q in 1:Q) {
  cross.indices &lt;- ISET[[q]]
  J.set &lt;- JSET[[q]]
  temp.q &lt;- SpecTest(t(x), J.set, cross.indices, B, flag_c)
  PVal[q] &lt;- temp.q$p.value
}
res &lt;- SpecMulTest(Q, PVal)
res

</code></pre>

<hr>
<h2 id='SpecTest'>Global testing for spectral density matrix</h2><span id='topic+SpecTest'></span>

<h3>Description</h3>

<p><code>SpecTest()</code> implements a new global test proposed in 
Chang et al. (2022) for the following hypothesis testing problem: 
</p>
<p style="text-align: center;"><code class="reqn">H_0:f_{i,j}(\omega)=0 \mathrm{\ for\ any\ }(i,j)\in \mathcal{I}\mathrm{\ and\ }
\omega \in \mathcal{J}\mathrm{\ \ versus\ \ }H_1:H_0\mathrm{\ is\ not\ true }\,,</code>
</p>

<p>where <code class="reqn">f_{i,j}(\omega)</code> represents the cross-spectral density between 
<code class="reqn"> x_{t,i}</code> and <code class="reqn"> x_{t,j}</code> at frequency <code class="reqn">\omega</code> with <code class="reqn">x_{t,i}</code> being 
the <code class="reqn">i</code>-th component of the <code class="reqn">p \times 1</code> times series <code class="reqn">{\bf x}_t</code>.
Here, <code class="reqn">\mathcal{I}</code> is the set of index pairs of interest, and
<code class="reqn">\mathcal{J}</code> is the set of frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SpecTest(X, J.set, cross.indices, B = 1000, flag_c = 0.8)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SpecTest_+3A_x">X</code></td>
<td>
<p>An <code class="reqn">n\times p</code> data matrix <code class="reqn">{\bf X} = ({\bf x}_1, \dots , {\bf x}_n)'</code>,
where <code class="reqn">n</code> is the number of observations of the <code class="reqn">p\times 1</code> time
series <code class="reqn">\{{\bf x}_t\}_{t=1}^n</code>.</p>
</td></tr>
<tr><td><code id="SpecTest_+3A_j.set">J.set</code></td>
<td>
<p>A vector representing the set <code class="reqn">\mathcal{J}</code>
of frequencies.</p>
</td></tr>
<tr><td><code id="SpecTest_+3A_cross.indices">cross.indices</code></td>
<td>
<p>An <code class="reqn">r \times 2</code> matrix representing the set
<code class="reqn">\mathcal{I}</code> of <code class="reqn">r</code> index pairs, where each row represents an index pair.</p>
</td></tr>
<tr><td><code id="SpecTest_+3A_b">B</code></td>
<td>
<p>The number of bootstrap replications for generating multivariate normally
distributed random vectors when calculating the critical value. The default is 2000.</p>
</td></tr>
<tr><td><code id="SpecTest_+3A_flag_c">flag_c</code></td>
<td>
<p>The bandwidth <code class="reqn">c\in(0,1]</code> of the flat-top kernel for estimating 
<code class="reqn">f_{i,j}(\omega)</code> [See (2) in Chang et al. (2022)]. The default is 0.8.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"hdtstest"</code>, which contains the following
components:
</p>
<table role = "presentation">
<tr><td><code>Stat</code></td>
<td>
<p>The test statistic of the test.</p>
</td></tr>
<tr><td><code>pval</code></td>
<td>
<p>The p-value of the test.</p>
</td></tr>
<tr><td><code>cri95</code></td>
<td>
<p>The critical value of the test
at the significance level 0.05.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Chang, J., Jiang, Q., McElroy, T. S., &amp; Shao, X. (2022). 
Statistical inference for high-dimensional spectral density matrix.
<em>arXiv preprint</em>. <a href="https://doi.org/10.48550/arXiv.2212.13686">doi:10.48550/arXiv.2212.13686</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SpecMulTest">SpecMulTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
## Generate xt
n &lt;- 200
p &lt;- 10
flag_c &lt;- 0.8
B &lt;- 1000
burn &lt;- 1000
z.sim &lt;- matrix(rnorm((n+burn)*p),p,n+burn)
phi.mat &lt;- 0.4*diag(p)
x.sim &lt;- phi.mat %*% z.sim[,(burn+1):(burn+n)]
x &lt;- x.sim - rowMeans(x.sim)

## Generate the sets I and J
cross.indices &lt;- matrix(c(1,2), ncol=2)
J.set &lt;- 2*pi*seq(0,3)/4 - pi

res &lt;- SpecTest(t(x), J.set, cross.indices, B, flag_c)
Stat &lt;- res$statistic
Pvalue &lt;- res$p.value
CriVal &lt;- res$cri95
</code></pre>

<hr>
<h2 id='UR_test'>Testing for unit roots based on sample autocovariances</h2><span id='topic+UR_test'></span>

<h3>Description</h3>

<p>This function implements the test proposed in Chang, Cheng and Yao (2022)
for the following hypothesis testing problem:
</p>
<p style="text-align: center;"><code class="reqn">H_0:Y_t \sim I(0)\ \ \mathrm{versus}\ \ H_1:Y_t \sim
I(d)\ \mathrm{for\ some\ integer\ }d \geq 1\,,</code>
</p>
<p> where <code class="reqn">Y_t</code> is
a univariate time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UR_test(Y, lagk.vec = NULL, con_vec = NULL, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="UR_test_+3A_y">Y</code></td>
<td>
<p>A vector <code class="reqn">{\bf Y} = (Y_1, \dots , Y_n )'</code>, where <code class="reqn">n</code> is the number
of the observations.</p>
</td></tr>
<tr><td><code id="UR_test_+3A_lagk.vec">lagk.vec</code></td>
<td>
<p>The time lag <code class="reqn">K_0</code> used to calculate the test statistic
[See Section 2.1 of Chang, Cheng and Yao (2022)]. It can be a vector specifying
multiple time lags. If provided as a <code class="reqn">s \times 1</code> vector, the function will
output the test results corresponding to each of the <code class="reqn">s</code> values in <code>lagk.vec</code>.
The default is <code>c(0, 1, 2, 3, 4)</code>.</p>
</td></tr>
<tr><td><code id="UR_test_+3A_con_vec">con_vec</code></td>
<td>
<p>The constant <code class="reqn">c_\kappa</code> specified in (5) of
Chang, Cheng and Yao (2022). The default is 0.55. Alternatively, it can be an
<code class="reqn">m \times 1</code> vector specified by users, representing <code class="reqn">m</code> candidate values
of <code class="reqn">c_\kappa</code>.</p>
</td></tr>
<tr><td><code id="UR_test_+3A_alpha">alpha</code></td>
<td>
<p>The significance level of the test. The default is 0.05.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"urtest"</code>, which contains the following
components:
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>A <code class="reqn">s \times 1</code> vector with each element representing
the test statistic value associated with each of the <code class="reqn">s</code> time lags specified
in <code>lagk.vec</code>.</p>
</td></tr>
<tr><td><code>reject</code></td>
<td>
<p>An <code class="reqn">m \times s</code> data matrix <code class="reqn">{\bf R}=(R_{i,j})</code> where
<code class="reqn">R_{i,j}</code> represents whether the null hypothesis <code class="reqn">H_0</code> should be rejected
for <code class="reqn">c_\kappa</code> specified by the <code class="reqn">i</code>-th component of <code>con_vec</code>,
and <code class="reqn">K_0</code> specified by the <code class="reqn">j</code>-th component of <code>lagk.vec</code>.
<code class="reqn">R_{i,j}=1</code> indicates rejection of the null hypothesis,
while <code class="reqn">R_{i,j}=0</code> indicates non-rejection.</p>
</td></tr>
<tr><td><code>lag.vec</code></td>
<td>
<p>The time lags used in function.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Chang, J., Cheng, G., &amp; Yao, Q. (2022). Testing for unit
roots based on sample autocovariances. <em>Biometrika</em>, <strong>109</strong>,
543&ndash;550. <a href="https://doi.org/10.1093/biomet/asab034">doi:10.1093/biomet/asab034</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
## Generate yt
N &lt;- 100
Y &lt;-arima.sim(list(ar = c(0.9)), n = 2*N, sd = sqrt(1))
con_vec &lt;- c(0.45, 0.55, 0.65)
lagk.vec &lt;- c(0, 1, 2)

UR_test(Y, lagk.vec = lagk.vec, con_vec = con_vec, alpha = 0.05)
UR_test(Y, alpha = 0.05)
</code></pre>

<hr>
<h2 id='WN_test'>Testing for white noise hypothesis in high dimension</h2><span id='topic+WN_test'></span>

<h3>Description</h3>

<p><code>WN_test()</code> implements the test proposed in Chang, Yao and Zhou
(2017) for the following hypothesis testing problem: </p>
<p style="text-align: center;"><code class="reqn">H_0:\{{\bf y}_t
\}_{t=1}^n\mathrm{\ is\ white\ noise\ \ versus\ \ }H_1:\{{\bf y}_t
\}_{t=1}^n\mathrm{\ is\ not\ white\ noise.} </code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>WN_test(
  Y,
  lag.k = 2,
  B = 1000,
  kernel.type = c("QS", "Par", "Bart"),
  pre = FALSE,
  alpha = 0.05,
  control.PCA = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="WN_test_+3A_y">Y</code></td>
<td>
<p>An <code class="reqn">n \times p</code> data matrix <code class="reqn">{\bf Y} = ({\bf y}_1, \dots , {\bf y}_n )'</code>,
where <code class="reqn">n</code> is the number of the observations of the <code class="reqn">p \times 1</code>
time series <code class="reqn">\{{\bf y}_t\}_{t=1}^n</code>.</p>
</td></tr>
<tr><td><code id="WN_test_+3A_lag.k">lag.k</code></td>
<td>
<p>The time lag <code class="reqn">K</code> used to calculate the test
statistic [See (4) of Chang, Yao and Zhou (2017)]. The default is 2.</p>
</td></tr>
<tr><td><code id="WN_test_+3A_b">B</code></td>
<td>
<p>The number of bootstrap replications for generating multivariate
normally distributed random vectors when calculating the critical value.
The default is 1000.</p>
</td></tr>
<tr><td><code id="WN_test_+3A_kernel.type">kernel.type</code></td>
<td>
<p>The option for choosing the symmetric kernel used
in the estimation of long-run covariance matrix. Available options include:
<code>"QS"</code> (the default) for the Quadratic spectral kernel, <code>"Par"</code>
for the Parzen kernel, and <code>"Bart"</code> for the Bartlett kernel.
See Chang, Yao and Zhou (2017) for more information.</p>
</td></tr>
<tr><td><code id="WN_test_+3A_pre">pre</code></td>
<td>
<p>Logical. If <code>TRUE</code> (the default), the time series PCA
proposed in Chang, Guo and Yao (2018) should be performed on
<code class="reqn">\{{\bf y}_t\}_{t=1}^n</code> before implementing the white noise test [See Remark 1
of Chang, Yao and Zhou (2017)]. The time series PCA is implemented by using
the function <code><a href="#topic+PCA_TS">PCA_TS</a></code> with the arguments passed by <code>control.PCA</code>.</p>
</td></tr>
<tr><td><code id="WN_test_+3A_alpha">alpha</code></td>
<td>
<p>The significance level of the test. The default is 0.05.</p>
</td></tr>
<tr><td><code id="WN_test_+3A_control.pca">control.PCA</code></td>
<td>
<p>A list of control arguments passed to the function
<code>PCA_TS()</code>, including <code>lag.k</code>, <code>opt</code>, <code>thresh</code>,
<code>delta</code>, and the associated arguments passed to the <code>clime</code> function
(when <code>opt = 2</code>). See 'Details’ in <code><a href="#topic+PCA_TS">PCA_TS</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"hdtstest"</code>, which contains the following
components:
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>The test statistic of the test.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The p-value of the test.</p>
</td></tr>
<tr><td><code>lag.k</code></td>
<td>
<p>The time lag used in function.</p>
</td></tr>
<tr><td><code>kernel.type</code></td>
<td>
<p>The kernel used in function.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Chang, J., Guo, B., &amp; Yao, Q. (2018). Principal component analysis for
second-order stationary vector time series. <em>The Annals of Statistics</em>,
<strong>46</strong>, 2094&ndash;2124. <a href="https://doi.org/10.1214/17-AOS1613">doi:10.1214/17-AOS1613</a>.
</p>
<p>Chang, J., Yao, Q., &amp; Zhou, W. (2017). Testing for
high-dimensional white noise using maximum cross-correlations. <em>Biometrika</em>,
<strong>104</strong>, 111&ndash;127. <a href="https://doi.org/10.1093/biomet/asw066">doi:10.1093/biomet/asw066</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PCA_TS">PCA_TS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example 1
## Generate xt
n &lt;- 200
p &lt;- 10
Y &lt;- matrix(rnorm(n * p), n, p)

res &lt;- WN_test(Y)
Pvalue &lt;- res$p.value
rej &lt;- res$reject
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
