<!DOCTYPE html><html><head><title>Help for package gam</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gam}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#gam-package'><p>Generalized Additive Models</p></a></li>
<li><a href='#anova.Gam'><p>Analysis of Deviance for a Generalized Additive Model</p></a></li>
<li><a href='#gam'><p>Fitting Generalized Additive Models</p></a></li>
<li><a href='#gam-internal'><p>Internal gam functions</p></a></li>
<li><a href='#gam.control'><p>Auxilliary for controlling GAM fitting</p></a></li>
<li><a href='#gam.data'><p>Simulated dataset for gam</p></a></li>
<li><a href='#gam.exact'><p>A method for gam producing asymptotically exact standard errors for linear</p>
estimates</a></li>
<li><a href='#gam.lo'><p>Specify a loess fit in a GAM formula</p></a></li>
<li><a href='#gam.random'><p>Specify a Random Effects Fit in a GAM Formula</p></a></li>
<li><a href='#gam.s'><p>Specify a Smoothing Spline Fit in a GAM Formula</p></a></li>
<li><a href='#gam.scope'><p>Generate a scope for step.Gam</p></a></li>
<li><a href='#gam.smoothers'><p>Smoothers available for backfitting</p></a></li>
<li><a href='#kyphosis'><p>A classic example dataset for GAMs</p></a></li>
<li><a href='#na.gam.replace'><p>Missing Data Filter for GAMs</p></a></li>
<li><a href='#plot.Gam'><p>Plot Components of a GAM Object</p></a></li>
<li><a href='#predict.Gam'><p>Predict method for GAM fits</p></a></li>
<li><a href='#step.Gam'><p>Stepwise model builder for GAM</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Generalized Additive Models</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-28</td>
</tr>
<tr>
<td>Version:</td>
<td>1.22-3</td>
</tr>
<tr>
<td>Author:</td>
<td>Trevor Hastie</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for fitting and working with generalized
		additive models, as described in chapter 7 of "Statistical Models in S" (Chambers and Hastie (eds), 1991), and "Generalized Additive Models" (Hastie and Tibshirani, 1990).</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Trevor Hastie &lt;hastie@stanford.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0), stats, splines, foreach</td>
</tr>
<tr>
<td>Suggests:</td>
<td>interp, testthat</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-29 01:39:59 UTC; hastie</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-29 05:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='gam-package'>Generalized Additive Models</h2><span id='topic+gam-package'></span>

<h3>Description</h3>

<p>This package provides functions for fitting and working with generalized additive models as described in chapter 7 of &quot;Statistical Models in S&quot; (Chambers and Hastie (eds), 1991) and &quot;Generalized Additive Models&quot; (Hastie and Tibshirani, 1990).
</p>


<h3>Author(s)</h3>

<p>Trevor Hastie
</p>

<hr>
<h2 id='anova.Gam'>Analysis of Deviance for a Generalized Additive Model</h2><span id='topic+anova.Gam'></span><span id='topic+summary.Gam'></span>

<h3>Description</h3>

<p>Produces an ANODEV table for a set of GAM models, or else a summary for a single GAM model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Gam'
anova(object, ..., test = c("Chisq", "F", "Cp"))

## S3 method for class 'Gam'
summary(object, dispersion = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova.Gam_+3A_object">object</code></td>
<td>
<p>a fitted Gam</p>
</td></tr>
<tr><td><code id="anova.Gam_+3A_...">...</code></td>
<td>
<p>other fitted Gams for <code>anova</code></p>
</td></tr>
<tr><td><code id="anova.Gam_+3A_test">test</code></td>
<td>
<p>a character string specifying the test statistic to be used.
Can be one of '&quot;F&quot;', '&quot;Chisq&quot;' or '&quot;Cp&quot;', with partial matching allowed, or
'NULL' for no test.</p>
</td></tr>
<tr><td><code id="anova.Gam_+3A_dispersion">dispersion</code></td>
<td>
<p>a dispersion parameter to be used in computing standard
errors</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are methods for the functions <code>anova</code> or <code>summary</code> for
objects inheriting from class <code>Gam</code>. See <code><a href="stats.html#topic+anova">anova</a></code> for the general
behavior of this function and for the interpretation of <code>test</code>.
</p>
<p>When called with a single <code>Gam</code> object, a special pair of anova tables for
<code>Gam</code> models is returned. This gives a breakdown of the degrees of freedom
for all the terms in the model, separating the projection part and
nonparametric part of each, and returned as a list of two anova objects. For
example, a term specified by <code>s()</code> is broken down into a single degree of
freedom for its linear component, and the remainder for the nonparametric
component. In addition, a type of score test is performed for each of the
nonparametric terms. The nonparametric component is set to zero, and the
linear part is updated, holding the other nonparametric terms fixed. This is
done efficiently and simulataneously for all terms.
</p>


<h3>Author(s)</h3>

<p>Written by Trevor Hastie, following closely the design in the
&quot;Generalized Additive Models&quot; chapter (Hastie, 1992) in Chambers and Hastie
(1992).
</p>


<h3>References</h3>

<p>Hastie, T. J. (1992) <em>Generalized additive models.</em> Chapter
7 of <em>Statistical Models in S</em> eds J. M. Chambers and T. J. Hastie,
Wadsworth &amp; Brooks/Cole.
</p>
<p>Hastie, T. and Tibshirani, R. (1990) <em>Generalized Additive Models.</em>
London: Chapman and Hall.
</p>
<p>Venables, W. N. and Ripley, B. D. (2002) <em>Modern Applied Statistics
with S.</em> New York: Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(gam.data)
Gam.object &lt;- gam(y~s(x,6)+z,data=gam.data)
anova(Gam.object)
Gam.object2 &lt;- update(Gam.object, ~.-z)
anova(Gam.object, Gam.object2, test="Chisq")
</code></pre>

<hr>
<h2 id='gam'>Fitting Generalized Additive Models</h2><span id='topic+gam'></span><span id='topic+gam.fit'></span>

<h3>Description</h3>

<p><code>gam</code> is used to fit generalized additive models, specified by giving a
symbolic description of the additive predictor and a description of the
error distribution. <code>gam</code> uses the <em>backfitting algorithm</em> to
combine different smoothing or fitting methods. The methods currently
supported are local regression and smoothing splines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gam(
  formula,
  family = gaussian,
  data,
  weights,
  subset,
  na.action,
  start = NULL,
  etastart,
  mustart,
  control = gam.control(...),
  model = TRUE,
  method = "glm.fit",
  x = FALSE,
  y = TRUE,
  ...
)

gam.fit(
  x,
  y,
  smooth.frame,
  weights = rep(1, nobs),
  start = NULL,
  etastart = NULL,
  mustart = NULL,
  offset = rep(0, nobs),
  family = gaussian(),
  control = gam.control()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gam_+3A_formula">formula</code></td>
<td>
<p>a formula expression as for other regression models, of the
form <code>response ~ predictors</code>. See the documentation of <code>lm</code> and
<code>formula</code> for details.  Built-in nonparametric smoothing terms are
indicated by <code>s</code> for smoothing splines or <code>lo</code> for <code>loess</code>
smooth terms.  See the documentation for <code>s</code> and <code>lo</code> for their
arguments. Additional smoothers can be added by creating the appropriate
interface functions. Interactions with nonparametric smooth terms are not
fully supported, but will not produce errors; they will simply produce the
usual parametric interaction.</p>
</td></tr>
<tr><td><code id="gam_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link function to
be used in the model. This can be a character string naming a family
function, a family function or the result of a call to a family function.
(See <code><a href="stats.html#topic+family">family</a></code> for details of family functions.)</p>
</td></tr>
<tr><td><code id="gam_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables in the model.
If not found in <code>data</code>, the variables are taken from
<code>environment(formula)</code>, typically the environment from which <code>gam</code>
is called.</p>
</td></tr>
<tr><td><code id="gam_+3A_weights">weights</code></td>
<td>
<p>an optional vector of weights to be used in the fitting
process.</p>
</td></tr>
<tr><td><code id="gam_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="gam_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain <code>NA</code>s.  The default is set by the <code>na.action</code> setting of
<code><a href="base.html#topic+options">options</a></code>, and is <code><a href="stats.html#topic+na.fail">na.fail</a></code> if that is unset.  The
&ldquo;factory-fresh&rdquo; default is <code><a href="stats.html#topic+na.omit">na.omit</a></code>. A special method
<code><a href="#topic+na.gam.replace">na.gam.replace</a></code> allows for mean-imputation of missing values
(assumes missing at random), and works gracefully with <code>gam</code></p>
</td></tr>
<tr><td><code id="gam_+3A_start">start</code></td>
<td>
<p>starting values for the parameters in the additive predictor.</p>
</td></tr>
<tr><td><code id="gam_+3A_etastart">etastart</code></td>
<td>
<p>starting values for the additive predictor.</p>
</td></tr>
<tr><td><code id="gam_+3A_mustart">mustart</code></td>
<td>
<p>starting values for the vector of means.</p>
</td></tr>
<tr><td><code id="gam_+3A_control">control</code></td>
<td>
<p>a list of parameters for controlling the fitting process.
See the documentation for <code><a href="#topic+gam.control">gam.control</a></code> for details. These can
also be set as arguments to <code>gam()</code> itself.</p>
</td></tr>
<tr><td><code id="gam_+3A_model">model</code></td>
<td>
<p>a logical value indicating whether <em>model frame</em> should be
included as a component of the returned value. Needed if <code>gam</code> is
called and predicted from inside a user function. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="gam_+3A_method">method</code></td>
<td>
<p>the method to be used in fitting the parametric part of the
model.  The default method <code>"glm.fit"</code> uses iteratively reweighted
least squares (IWLS).  The only current alternative is <code>"model.frame"</code>
which returns the model frame and does no fitting.</p>
</td></tr>
<tr><td><code id="gam_+3A_x">x</code>, <code id="gam_+3A_y">y</code></td>
<td>
<p>For <code>gam</code>: logical values indicating whether the response
vector and model matrix used in the fitting process should be returned as
components of the returned value.
</p>
<p>For <code>gam.fit</code>: <code>x</code> is a model matrix of dimension <code>n * p</code>,
and <code>y</code> is a vector of observations of length <code>n</code>.</p>
</td></tr>
<tr><td><code id="gam_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="gam_+3A_smooth.frame">smooth.frame</code></td>
<td>
<p>for <code>gam.fit</code> only. This is essentially a subset of
the model frame corresponding to the smooth terms, and has the ingredients
needed for smoothing each variable in the backfitting algorithm. The
elements of this frame are produced by the formula functions <code>lo</code> and
<code>s</code>.</p>
</td></tr>
<tr><td><code id="gam_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an <em>a priori</em> known component
to be included in the additive predictor during fitting.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The gam model is fit using the local scoring algorithm, which iteratively
fits weighted additive models by backfitting. The backfitting algorithm is a
Gauss-Seidel method for fitting additive models, by iteratively smoothing
partial residuals.  The algorithm separates the parametric from the
nonparametric part of the fit, and fits the parametric part using weighted
linear least squares within the backfitting algorithm. This version of
<code>gam</code> remains faithful to the philosophy of GAM models as outlined in
the references below.
</p>
<p>An object <code>gam.slist</code> (currently set to <code>c("lo","s","random")</code>)
lists the smoothers supported by <code>gam</code>. Corresponding to each of these
is a smoothing function <code>gam.lo</code>, <code>gam.s</code> etc that take particular
arguments and produce particular output, custom built to serve as building
blocks in the backfitting algorithm. This allows users to add their own
smoothing methods. See the documentation for these methods for further
information. In addition, the object <code>gam.wlist</code> (currently set to
<code>c("s","lo")</code>) lists the smoothers for which efficient backfitters are
provided. These are invoked if all the smoothing methods are of one kind
(either all <code>"lo"</code> or all <code>"s"</code>).
</p>


<h3>Value</h3>

<p><code>gam</code> returns an object of class <code>Gam</code>, which inherits
from both <code>glm</code> and <code>lm</code>.
</p>
<p>Gam objects can be examined by <code>print</code>, <code>summary</code>, <code>plot</code>,
and <code>anova</code>.  Components can be extracted using extractor functions
<code>predict</code>, <code>fitted</code>, <code>residuals</code>, <code>deviance</code>,
<code>formula</code>, and <code>family</code>. Can be modified using <code>update</code>. It
has all the components of a <code>glm</code> object, with a few more. This also
means it can be queried, summarized etc by methods for <code>glm</code> and
<code>lm</code> objects. Other generic functions that have methods for <code>Gam</code>
objects are <code>step</code> and <code>preplot</code>.
</p>
<p>The following components must be included in a legitimate &lsquo;Gam&rsquo; object. The
residuals, fitted values, coefficients and effects should be extracted by
the generic functions of the same name, rather than by the <code>"$"</code>
operator. The <code>family</code> function returns the entire family object used
in the fitting, and <code>deviance</code> can be used to extract the deviance of
the fit.
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p> the coefficients of the parametric part of the
<code>additive.predictors</code>, which multiply the columns of the model matrix.
The names of the coefficients are the names of the single-degree-of-freedom
effects (the columns of the model matrix). If the model is overdetermined
there will be missing values in the coefficients corresponding to
inestimable coefficients. </p>
</td></tr> <tr><td><code>additive.predictors</code></td>
<td>
<p> the additive fit,
given by the product of the model matrix and the coefficients, plus the
columns of the <code>$smooth</code> component. </p>
</td></tr> <tr><td><code>fitted.values</code></td>
<td>
<p> the fitted
mean values, obtained by transforming the component
<code>additive.predictors</code> using the inverse link function. </p>
</td></tr> <tr><td><code>smooth</code>, <code>nl.df</code>, <code>nl.chisq</code>, <code>var</code></td>
<td>
<p> these four characterize the nonparametric aspect of
the fit. <code>smooth</code> is a matrix of smooth terms, with a column
corresponding to each smooth term in the model; if no smooth terms are in
the <code>Gam</code> model, all these components will be missing. Each column
corresponds to the strictly nonparametric part of the term, while the
parametric part is obtained from the model matrix. <code>nl.df</code> is a vector
giving the approximate degrees of freedom for each column of <code>smooth</code>.
For smoothing splines specified by <code>s(x)</code>, the approximate <code>df</code>
will be the trace of the implicit smoother matrix minus 2. <code>nl.chisq</code>
is a vector containing a type of score test for the removal of each of the
columns of <code>smooth</code>. <code>var</code> is a matrix like <code>smooth</code>,
containing the approximate pointwise variances for the columns of
<code>smooth</code>. </p>
</td></tr> <tr><td><code>smooth.frame</code></td>
<td>
<p>This is essentially a subset of the
model frame corresponding to the smooth terms, and has the ingredients
needed for making predictions from a <code>Gam</code> object</p>
</td></tr> <tr><td><code>residuals</code></td>
<td>

<p>the residuals from the final weighted additive fit; also known as residuals,
these are typically not interpretable without rescaling by the weights. </p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p> up to a constant, minus twice the maximized log-likelihood.
Similar to the residual sum of squares. Where sensible, the constant is
chosen so that a saturated model has deviance zero. </p>
</td></tr>
<tr><td><code>null.deviance</code></td>
<td>
<p>The deviance for the null model, comparable with
<code>deviance</code>. The null model will include the offset, and an intercept if
there is one in the model</p>
</td></tr> <tr><td><code>iter</code></td>
<td>
<p> the number of local scoring
iterations used to compute the estimates. </p>
</td></tr> <tr><td><code>bf.iter</code></td>
<td>
<p>a vector of
length <code>iter</code> giving number of backfitting iterations used at each
inner loop.</p>
</td></tr> <tr><td><code>family</code></td>
<td>
<p> a three-element character vector giving the name
of the family, the link, and the variance function; mainly for printing
purposes. </p>
</td></tr> <tr><td><code>weights</code></td>
<td>
<p>the <em>working</em> weights, that is the weights
in the final iteration of the local scoring fit.</p>
</td></tr> <tr><td><code>prior.weights</code></td>
<td>
<p>the
case weights initially supplied.</p>
</td></tr> <tr><td><code>df.residual</code></td>
<td>
<p>the residual degrees of
freedom.</p>
</td></tr> <tr><td><code>df.null</code></td>
<td>
<p>the residual degrees of freedom for the null
model.</p>
</td></tr>
</table>
<p>The object will also have the components of a <code>lm</code> object:
<code>coefficients</code>, <code>residuals</code>, <code>fitted.values</code>, <code>call</code>,
<code>terms</code>, and some others involving the numerical fit.  See
<code>lm.object</code>.
</p>


<h3>Author(s)</h3>

<p>Written by Trevor Hastie, following closely the design in the
&quot;Generalized Additive Models&quot; chapter (Hastie, 1992) in Chambers and Hastie
(1992), and the philosophy in Hastie and Tibshirani (1991).  This version of
<code>gam</code> is adapted from the S version to match the <code>glm</code> and
<code>lm</code> functions in R.
</p>
<p>Note that this version of <code>gam</code> is different from the function with the
same name in the R library <code>mgcv</code>, which uses only smoothing splines
with a focus on automatic smoothing parameter selection via GCV. To avoid
issues with S3 method handling when both packages are loaded, the object
class in package &quot;gam&quot; is now &quot;Gam&quot;.
</p>


<h3>References</h3>

<p>Hastie, T. J. (1991) <em>Generalized additive models.</em> Chapter
7 of <em>Statistical Models in S</em> eds J. M. Chambers and T. J. Hastie,
Wadsworth &amp; Brooks/Cole.
</p>
<p>Hastie, T. and Tibshirani, R. (1990) <em>Generalized Additive Models.</em>
London: Chapman and Hall.
</p>
<p>Venables, W. N. and Ripley, B. D. (2002) <em>Modern Applied Statistics
with S.</em> New York: Springer.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="stats.html#topic+family">family</a></code>, <code><a href="stats.html#topic+lm">lm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(kyphosis)
gam(Kyphosis ~ s(Age,4) + Number, family = binomial, data=kyphosis,
trace=TRUE)
data(airquality)
gam(Ozone^(1/3) ~ lo(Solar.R) + lo(Wind, Temp), data=airquality, na=na.gam.replace)
gam(Kyphosis ~ poly(Age,2) + s(Start), data=kyphosis, family=binomial, subset=Number&gt;2)
data(gam.data)
Gam.object &lt;- gam(y ~ s(x,6) + z,data=gam.data)
summary(Gam.object)
plot(Gam.object,se=TRUE)
data(gam.newdata)
predict(Gam.object,type="terms",newdata=gam.newdata)

</code></pre>

<hr>
<h2 id='gam-internal'>Internal gam functions</h2><span id='topic+gam-internal'></span><span id='topic+.First.lib'></span><span id='topic++5B.smooth'></span><span id='topic+general.wam'></span><span id='topic+anova.Gamlist'></span><span id='topic+as.anova'></span><span id='topic+as.data.frame.lo.smooth'></span><span id='topic+assign.list'></span><span id='topic+Gamlist'></span><span id='topic+gam.match'></span><span id='topic+gam.nlchisq'></span><span id='topic+gam.sp'></span><span id='topic+gplot'></span><span id='topic+gplot.default'></span><span id='topic+gplot.factor'></span><span id='topic+gplot.list'></span><span id='topic+gplot.matrix'></span><span id='topic+gplot.numeric'></span><span id='topic+labels.Gam'></span><span id='topic+lo.wam'></span><span id='topic+newdata.predict.Gam'></span><span id='topic+polylo'></span><span id='topic+print.Gam'></span><span id='topic+print.Gamex'></span><span id='topic+print.summary.Gam'></span><span id='topic+s.wam'></span><span id='topic+ylim.scale'></span>

<h3>Description</h3>

<p>Service functions and as yet undocumented functions for the gam library
</p>


<h3>Author(s)</h3>

<p>Trevor Hastie
</p>

<hr>
<h2 id='gam.control'>Auxilliary for controlling GAM fitting</h2><span id='topic+gam.control'></span>

<h3>Description</h3>

<p>Auxiliary function as user interface for 'gam' fitting. Typically only used
when calling 'gam' or 'gam.fit'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gam.control(
  epsilon = 1e-07,
  bf.epsilon = 1e-07,
  maxit = 30,
  bf.maxit = 30,
  trace = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gam.control_+3A_epsilon">epsilon</code></td>
<td>
<p>convergence threshold for local scoring iterations</p>
</td></tr>
<tr><td><code id="gam.control_+3A_bf.epsilon">bf.epsilon</code></td>
<td>
<p>convergence threshold for backfitting iterations</p>
</td></tr>
<tr><td><code id="gam.control_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of local scoring iterations</p>
</td></tr>
<tr><td><code id="gam.control_+3A_bf.maxit">bf.maxit</code></td>
<td>
<p>maximum number of backfitting iterations</p>
</td></tr>
<tr><td><code id="gam.control_+3A_trace">trace</code></td>
<td>
<p>should iteration details be printed while <code>gam</code> is fitting
the model.</p>
</td></tr>
<tr><td><code id="gam.control_+3A_...">...</code></td>
<td>
<p>placemark for additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list is returned, consisting of the five parameters, conveniently
packaged up to supply the <code>control</code> argument to <code>gam</code>. The values
for <code>gam.control</code> can be supplied directly in a call to <code>gam</code>;
these are then filtered through <code>gam.control</code> inside <code>gam</code>.
</p>


<h3>References</h3>

<p>Hastie, T. J. (1992) <em>Generalized additive models.</em> Chapter
7 of <em>Statistical Models in S</em> eds J. M. Chambers and T. J. Hastie,
Wadsworth &amp; Brooks/Cole.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: gam(formula, family, control = gam.control(bf.maxit=15))
## Not run: gam(formula, family, bf.maxit = 15) # these are equivalent

</code></pre>

<hr>
<h2 id='gam.data'>Simulated dataset for gam</h2><span id='topic+gam.data'></span><span id='topic+gam.newdata'></span>

<h3>Description</h3>

<p>A simple simulated dataset, used to test out the gam functions
</p>


<h3>Format</h3>

<p>A data frame with 100 observations on the following 6 variables:
</p>

<dl>
<dt>x</dt><dd><p>a numeric vector - predictor</p>
</dd>
<dt>y</dt><dd><p>a numeric vector - the response</p>
</dd>
<dt>z</dt><dd><p>a numeric vector - noise predictor</p>
</dd>
<dt>f</dt><dd><p>a numeric vector - true function</p>
</dd>
<dt>probf</dt><dd><p>a numeric vector - probability function</p>
</dd>
<dt>ybin</dt><dd><p>a numeric vector - binary response</p>
</dd>
</dl>



<h3>Details</h3>

<p>This dataset is artificial, and is used to test out some of the features of
gam.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(gam.data)
gam(y ~ s(x) + z, data=gam.data)

</code></pre>

<hr>
<h2 id='gam.exact'>A method for gam producing asymptotically exact standard errors for linear
estimates</h2><span id='topic+gam.exact'></span>

<h3>Description</h3>

<p>This function is a &quot;wrapper&quot; for a Gam object, and produces exact standard
errors for each linear term in the gam call (except for the intercept).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gam.exact(Gam.obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gam.exact_+3A_gam.obj">Gam.obj</code></td>
<td>
<p>a Gam object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only standard errors for the linear terms are produced. There is a print
method for the Gamex class.
</p>


<h3>Value</h3>

<p>A list (of class Gamex) containing a table of coefficients and a
variance covariance matrix for the linear terms in the formula of the gam
call.
</p>


<h3>Author(s)</h3>

<p>Aidan McDermott, Department of Biostatistics, Johns Hopkins
University. Modified by Trevor Hastie for R
</p>


<h3>References</h3>

<p>Issues in Semiparametric Regression: A Case Study of Time
Series Models in Air Pollution and Mortality, Dominici F., McDermott A.,
Hastie T.J., <em>JASA</em>, December 2004, 99(468), 938-948. See
<a href="https://hastie.su.domains/Papers/dominiciR2.pdf">https://hastie.su.domains/Papers/dominiciR2.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(31)
n     &lt;- 200
x     &lt;- rnorm(n)
y     &lt;- rnorm(n)
a     &lt;- rep(1:10,length=n)
b     &lt;- rnorm(n)
z     &lt;- 1.4 + 2.1*a + 1.2*b + 0.2*sin(x/(3*max(x))) + 0.3*cos(y/(5*max(y))) + 0.5 * rnorm(n)
dat   &lt;- data.frame(x,y,a,b,z,testit=b*2)
### Model 1: Basic
Gam.o &lt;- gam(z ~ a + b + s(x,3) + s(y,5), data=dat)
coefficients(summary.glm(Gam.o))
gam.exact(Gam.o)
### Model 2: Poisson
Gam.o &lt;- gam(round(abs(z)) ~ a + b + s(x,3) + s(y,5), data=dat,family=poisson)
coefficients(summary.glm(Gam.o))
gam.exact(Gam.o)

</code></pre>

<hr>
<h2 id='gam.lo'>Specify a loess fit in a GAM formula</h2><span id='topic+gam.lo'></span><span id='topic+lo'></span>

<h3>Description</h3>

<p>A symbolic wrapper to indicate a smooth term in a formala argument to gam
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gam.lo(
  x,
  y,
  w = rep(1, length(y)),
  span = 0.5,
  degree = 1,
  ncols = p,
  xeval = x
)

lo(..., span = 0.5, degree = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gam.lo_+3A_x">x</code></td>
<td>
<p>for <code>gam.lo</code>, the appropriate basis of polynomials generated
from the arguments to <code>lo</code>. These are also the variables that receive
linear coefficients in the GAM fit.</p>
</td></tr>
<tr><td><code id="gam.lo_+3A_y">y</code></td>
<td>
<p>a response variable passed to <code>gam.lo</code> during backfitting</p>
</td></tr>
<tr><td><code id="gam.lo_+3A_w">w</code></td>
<td>
<p>weights</p>
</td></tr>
<tr><td><code id="gam.lo_+3A_span">span</code></td>
<td>
<p>the number of observations in a neighborhood. This is the
smoothing parameter for a <code>loess</code> fit. If specified, the full argument
name <code>span</code> must be written.</p>
</td></tr>
<tr><td><code id="gam.lo_+3A_degree">degree</code></td>
<td>
<p>the degree of local polynomial to be fit; currently restricted
to be <code>1</code> or <code>2</code>. If specified, the full argument name
<code>degree</code> must be written.</p>
</td></tr>
<tr><td><code id="gam.lo_+3A_ncols">ncols</code></td>
<td>
<p>for <code>gam.lo</code> the number of columns in <code>x</code> used as the
smoothing inputs to local regression. For example, if <code>degree=2</code>, then
<code>x</code> has two columns defining a degree-2 polynomial basis. Both are
needed for the parameteric part of the fit, but <code>ncol=1</code> telling the
local regression routine that the first column is the actually smoothing
variable.</p>
</td></tr>
<tr><td><code id="gam.lo_+3A_xeval">xeval</code></td>
<td>
<p>If this argument is present, then <code>gam.lo</code> produces a
prediction at <code>xeval</code>.</p>
</td></tr>
<tr><td><code id="gam.lo_+3A_...">...</code></td>
<td>
<p>the unspecified <code>...{}</code> can be a comma-separated list of
numeric vectors, numeric matrix, or expressions that evaluate to either of
these. If it is a list of vectors, they must all have the same length.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A smoother in gam separates out the parametric part of the fit from the
non-parametric part. For local regression, the parametric part of the fit is
specified by the particular polynomial being fit locally. The workhorse
function <code>gam.lo</code> fits the local polynomial, then strips off this
parametric part. All the parametric pieces from all the terms in the
additive model are fit simultaneously in one operation for each loop of the
backfitting algorithm.
</p>


<h3>Value</h3>

<p><code>lo</code> returns a numeric matrix.  The simplest case is when there
is a single argument to <code>lo</code> and <code>degree=1</code>; a one-column matrix
is returned, consisting of a normalized version of the vector.  If
<code>degree=2</code> in this case, a two-column matrix is returned, consisting of
a degree-2 polynomial basis.  Similarly, if there are two arguments, or the
single argument is a two-column matrix, either a two-column matrix is
returned if <code>degree=1</code>, or a five-column matrix consisting of powers
and products up to degree <code>2</code>.  Any dimensional argument is allowed,
but typically one or two vectors are used in practice.
</p>
<p>The matrix is endowed with a number of attributes; the matrix itself is used
in the construction of the model matrix, while the attributes are needed for
the backfitting algorithms <code>general.wam</code> (weighted additive model) or
<code>lo.wam</code> (currently not implemented). Local-linear curve or surface
fits reproduce linear responses, while local-quadratic fits reproduce
quadratic curves or surfaces. These parts of the <code>loess</code> fit are
computed exactly together with the other parametric linear parts
</p>
<p>When two or more smoothing variables are given, the user should make sure
they are in a commensurable scale; <code>lo()</code> does no normalization. This
can make a difference, since <code>lo()</code> uses a spherical (isotropic)
neighborhood when establishing the nearest neighbors.
</p>
<p>Note that <code>lo</code> itself does no smoothing; it simply sets things up for
<code>gam</code>; <code>gam.lo</code> does the actual smoothing. of the model.
</p>
<p>One important attribute is named <code>call</code>. For example, <code>lo(x)</code> has
a call component <code>gam.lo(data[["lo(x)"]], z, w, span = 0.5, degree = 1,
ncols = 1)</code>. This is an expression that gets evaluated repeatedly in
<code>general.wam</code> (the backfitting algorithm).
</p>
<p><code>gam.lo</code> returns an object with components </p>
<table>
<tr><td><code>residuals</code></td>
<td>
<p>The
residuals from the smooth fit. Note that the smoother removes the parametric
part of the fit (using a linear fit with the columns in <code>x</code>), so these
residual represent the nonlinear part of the fit.</p>
</td></tr> <tr><td><code>nl.df</code></td>
<td>
<p>the
nonlinear degrees of freedom</p>
</td></tr> <tr><td><code>var</code></td>
<td>
<p>the pointwise variance for the
nonlinear fit</p>
</td></tr>
</table>
<p>When <code>gam.lo</code> is evaluated with an <code>xeval</code> argument, it returns a
matrix of predictions.
</p>


<h3>Author(s)</h3>

<p>Written by Trevor Hastie, following closely the design in the
&quot;Generalized Additive Models&quot; chapter (Hastie, 1992) in Chambers and Hastie
(1992).
</p>


<h3>References</h3>

<p>Hastie, T. J. (1992) <em>Generalized additive models.</em> Chapter
7 of <em>Statistical Models in S</em> eds J. M. Chambers and T. J. Hastie,
Wadsworth &amp; Brooks/Cole.
</p>
<p>Hastie, T. and Tibshirani, R. (1990) <em>Generalized Additive Models.</em>
London: Chapman and Hall.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+s">s</a></code>, <code><a href="splines.html#topic+bs">bs</a></code>, <code><a href="splines.html#topic+ns">ns</a></code>,
<code><a href="stats.html#topic+poly">poly</a></code>, <code><a href="stats.html#topic+loess">loess</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
y ~ Age + lo(Start)
     # fit Start using a loess smooth with a (default) span of 0.5.
y ~ lo(Age) + lo(Start, Number) 
y ~ lo(Age, span=0.3) # the argument name span cannot be abbreviated.

</code></pre>

<hr>
<h2 id='gam.random'>Specify a Random Effects Fit in a GAM Formula</h2><span id='topic+gam.random'></span><span id='topic+random'></span>

<h3>Description</h3>

<p>A symbolic wrapper for a factor term, to specify a random effect term in a
formula argument to gam
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gam.random(f, y, w, df = sum(non.zero), lambda = 0, intercept = TRUE, xeval)

random(f, df = NULL, lambda = 0, intercept = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gam.random_+3A_f">f</code></td>
<td>
<p>factor variable, or expression that evaluates to a factor.</p>
</td></tr>
<tr><td><code id="gam.random_+3A_y">y</code></td>
<td>
<p>a response variable passed to <code>gam.random</code> during backfitting</p>
</td></tr>
<tr><td><code id="gam.random_+3A_w">w</code></td>
<td>
<p>weights</p>
</td></tr>
<tr><td><code id="gam.random_+3A_df">df</code></td>
<td>
<p>the target equivalent degrees of freedom, used as a smoothing
parameter. The real smoothing parameter (<code>lambda</code> below) is found such
that <code>df=tr(S)</code>, where <code>S</code> is the implicit smoother matrix. Values
for <code>df</code> should be greater than <code>0</code> and less than the number of
levels of <code>f</code>.  If both <code>df</code> and <code>lambda</code> are supplied, the
latter takes precedence. Note that <code>df</code> is not necessarily an integer.</p>
</td></tr>
<tr><td><code id="gam.random_+3A_lambda">lambda</code></td>
<td>
<p>the non-negative penalty parameter. This is interpreted as a
variance ratio in a mixed effects model - namely the ratio of the noise
variance to the random-effect variance.</p>
</td></tr>
<tr><td><code id="gam.random_+3A_intercept">intercept</code></td>
<td>
<p>if <code>intercept=TRUE</code> (the default) then the estimated
level effects are centered to average zero, otherwise they are left alone.</p>
</td></tr>
<tr><td><code id="gam.random_+3A_xeval">xeval</code></td>
<td>
<p>If this argument is present, then <code>gam.random</code> produces a
prediction at <code>xeval</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This &quot;smoother&quot; takes a factor as input and returns a shrunken-mean fit.  If
<code>lambda=0</code>, it simply computes the mean of the response at each level
of <code>f</code>. With <code>lambda&gt;0</code>, it returns a shrunken mean, where the
j'th level is shrunk by <code>nj/(nj+lambda)</code>, with <code>nj</code> being the
number of observations (or sum of their weights) at level <code>j</code>. Using
such smoother(s) in gam is formally equivalent to fitting a mixed-effect
model by generalized least squares.
</p>


<h3>Value</h3>

<p><code>random</code> returns the vector <code>f</code>, endowed with a number of
attributes. The vector itself is used in computing the means in backfitting,
while the attributes are needed for the backfitting algorithms
<code>general.wam</code>. Note that <code>random</code> itself does no smoothing; it
simply sets things up for <code>gam</code>.
</p>
<p>One important attribute is named <code>call</code>. For example, <code>random(f,
lambda=2)</code> has a call component <code>gam.random(data[["random(f, lambda =
2)"]], z, w, df = NULL, lambda = 2, intercept = TRUE)</code>. This is an
expression that gets evaluated repeatedly in <code>general.wam</code> (the
backfitting algorithm).
</p>
<p><code>gam.random</code> returns an object with components </p>
<table>
<tr><td><code>residuals</code></td>
<td>
<p>The
residuals from the smooth fit. </p>
</td></tr> <tr><td><code>nl.df</code></td>
<td>
<p>the degrees of freedom</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>the pointwise variance for the fit</p>
</td></tr> <tr><td><code>lambda</code></td>
<td>
<p>the value of
<code>lambda</code> used in the fit</p>
</td></tr></table>
<p> When <code>gam.random</code> is evaluated with an
<code>xeval</code> argument, it returns a vector of predictions.
</p>


<h3>Author(s)</h3>

<p>Written by Trevor Hastie, following closely the design in the
&quot;Generalized Additive Models&quot; chapter (Hastie, 1992) in Chambers and Hastie
(1992).
</p>


<h3>References</h3>

<p>Hastie, T. J. (1992) <em>Generalized additive models.</em> Chapter
7 of <em>Statistical Models in S</em> eds J. M. Chambers and T. J. Hastie,
Wadsworth &amp; Brooks/Cole.
</p>
<p>Hastie, T. and Tibshirani, R. (1990) <em>Generalized Additive Models.</em>
London: Chapman and Hall.
</p>
<p>Cantoni, E. and hastie, T. (2002) Degrees-of-freedom tests for smoothing
splines, <em>Biometrika</em> 89(2), 251-263
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lo">lo</a></code>, <code><a href="#topic+s">s</a></code>, <code><a href="splines.html#topic+bs">bs</a></code>,
<code><a href="splines.html#topic+ns">ns</a></code>, <code><a href="stats.html#topic+poly">poly</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# fit a model with a linear term in Age and a random effect in the factor Level
y ~ Age + random(Level, lambda=1)
 
</code></pre>

<hr>
<h2 id='gam.s'>Specify a Smoothing Spline Fit in a GAM Formula</h2><span id='topic+gam.s'></span><span id='topic+s'></span>

<h3>Description</h3>

<p>A symbolic wrapper to indicate a smooth term in a formala argument to gam
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gam.s(x, y, w = rep(1, length(x)), df = 4, spar = 1, xeval)

s(x, df = 4, spar = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gam.s_+3A_x">x</code></td>
<td>
<p>the univariate predictor, or expression, that evaluates to a
numeric vector.</p>
</td></tr>
<tr><td><code id="gam.s_+3A_y">y</code></td>
<td>
<p>a response variable passed to <code>gam.s</code> during backfitting</p>
</td></tr>
<tr><td><code id="gam.s_+3A_w">w</code></td>
<td>
<p>weights</p>
</td></tr>
<tr><td><code id="gam.s_+3A_df">df</code></td>
<td>
<p>the target equivalent degrees of freedom, used as a smoothing
parameter. The real smoothing parameter (<code>spar</code> below) is found such
that <code>df=tr(S)-1</code>, where <code>S</code> is the implicit smoother matrix.
Values for <code>df</code> should be greater than <code>1</code>, with <code>df=1</code>
implying a linear fit. If both <code>df</code> and <code>spar</code> are supplied, the
former takes precedence. Note that <code>df</code> is not necessarily an integer.</p>
</td></tr>
<tr><td><code id="gam.s_+3A_spar">spar</code></td>
<td>
<p>can be used as smoothing parameter, with values typically in
<code>(0,1]</code>. See <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code> for more details.</p>
</td></tr>
<tr><td><code id="gam.s_+3A_xeval">xeval</code></td>
<td>
<p>If this argument is present, then <code>gam.s</code> produces a
prediction at <code>xeval</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>s</code> returns the vector <code>x</code>, endowed with a number of attributes.
The vector itself is used in the construction of the model matrix, while the
attributes are needed for the backfitting algorithms <code>general.wam</code>
(weighted additive model) or <code>s.wam</code>. Since smoothing splines
reproduces linear fits, the linear part will be efficiently computed with
the other parametric linear parts of the model.
</p>
<p>Note that <code>s</code> itself does no smoothing; it simply sets things up for
<code>gam</code>.
</p>
<p>One important attribute is named <code>call</code>. For example, <code>s(x)</code> has a
call component <code>gam.s(data[["s(x)"]], z, w, spar = 1, df = 4)</code>. This is
an expression that gets evaluated repeatedly in <code>general.wam</code> (the
backfitting algorithm).
</p>
<p><code>gam.s</code> returns an object with components </p>
<table>
<tr><td><code>residuals</code></td>
<td>
<p>The
residuals from the smooth fit. Note that the smoother removes the parametric
part of the fit (using a linear fit in <code>x</code>), so these residual
represent the nonlinear part of the fit.</p>
</td></tr> <tr><td><code>nl.df</code></td>
<td>
<p>the nonlinear degrees
of freedom</p>
</td></tr> <tr><td><code>var</code></td>
<td>
<p>the pointwise variance for the nonlinear fit</p>
</td></tr>
</table>
<p>When <code>gam.s</code> is evaluated with an <code>xeval</code> argument, it returns a
vector of predictions.
</p>


<h3>Author(s)</h3>

<p>Written by Trevor Hastie, following closely the design in the
&quot;Generalized Additive Models&quot; chapter (Hastie, 1992) in Chambers and Hastie
(1992).
</p>


<h3>References</h3>

<p>Hastie, T. J. (1992) <em>Generalized additive models.</em> Chapter
7 of <em>Statistical Models in S</em> eds J. M. Chambers and T. J. Hastie,
Wadsworth &amp; Brooks/Cole.
</p>
<p>Hastie, T. and Tibshirani, R. (1990) <em>Generalized Additive Models.</em>
London: Chapman and Hall.
</p>
<p>Cantoni, E. and hastie, T. (2002) Degrees-of-freedom tests for smoothing
splines, <em>Biometrika</em> 89(2), 251-263
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lo">lo</a></code>, <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>, <code><a href="splines.html#topic+bs">bs</a></code>,
<code><a href="splines.html#topic+ns">ns</a></code>, <code><a href="stats.html#topic+poly">poly</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
     # fit Start using a smoothing spline with 4 df.
     y ~ Age + s(Start, 4)
     # fit log(Start) using a smoothing spline with 5 df.
     y ~ Age + s(log(Start), df=5)
 
</code></pre>

<hr>
<h2 id='gam.scope'>Generate a scope for step.Gam</h2><span id='topic+gam.scope'></span>

<h3>Description</h3>

<p>Given a data.frame as an argument, generate a scope list for use in
step.Gam, each element of which gives the candidates for that term.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gam.scope(frame, response = 1, smoother = "s", arg = NULL, form = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gam.scope_+3A_frame">frame</code></td>
<td>
<p>a data.frame to be used in <code>step.Gam</code>. Apart from the
response column, all other columns will be used.</p>
</td></tr>
<tr><td><code id="gam.scope_+3A_response">response</code></td>
<td>
<p>The column in <code>frame</code> used as the response. Default is
1.</p>
</td></tr>
<tr><td><code id="gam.scope_+3A_smoother">smoother</code></td>
<td>
<p>which smoother to use for the nonlinear terms; i.e. &quot;s&quot; or
&quot;lo&quot;, or any other supplied smoother. Default is &quot;s&quot;.</p>
</td></tr>
<tr><td><code id="gam.scope_+3A_arg">arg</code></td>
<td>
<p>a character (vector), which is the argument to <code>smoother</code>.
For example, <code>arg="df=6"</code> would result in the expression
<code>s(x,df=6)</code> for a column named &quot;x&quot;. This can be a vector, for example
<code>arg=c("df=4","df=6")</code>, which would result two smooth terms.</p>
</td></tr>
<tr><td><code id="gam.scope_+3A_form">form</code></td>
<td>
<p>if <code>TRUE</code>, each term is a formula, else a character vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a similar scope formula for each variable in the
frame. A column named &quot;x&quot; by default will generate a scope term
<code>~1+x+s(x)</code>. With <code>arg=c("df=4","df=6")</code> we get
<code>~1+x+s(x,df=4)+s(x,df=6)</code>. With form=FALSE, we would get the character
vector <code>c("1","x","s(x,df=4)","s(x,df=6")</code>.
</p>


<h3>Value</h3>

<p>a scope list is returned, with either a formula or a character
vector for each term, which describes the candidates for that term in the
Gam.
</p>


<h3>Author(s)</h3>

<p>Written by Trevor Hastie, following closely the design in the
&quot;Generalized Additive Models&quot; chapter (Hastie, 1992) in Chambers and Hastie
(1992).  This version of <code>gam.scope</code> is adapted from the S version.
</p>


<h3>References</h3>

<p>Hastie, T. J. (1991) <em>Generalized additive models.</em> Chapter
7 of <em>Statistical Models in S</em> eds J. M. Chambers and T. J. Hastie,
Wadsworth &amp; Brooks/Cole.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+step.Gam">step.Gam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(gam.data)
gdata=gam.data[,1:3]
gam.scope(gdata,2)
gam.scope(gdata,2,arg="df=5")
gam.scope(gdata,2,arg="df=5",form=FALSE)
gam.scope(gdata,2,arg=c("df=4","df=6"))

</code></pre>

<hr>
<h2 id='gam.smoothers'>Smoothers available for backfitting</h2><span id='topic+gam.smoothers'></span><span id='topic+gam.smooth.list'></span>

<h3>Description</h3>

<p>Auxiliary function as user interface for 'gam' fitting. Lists what smoothers
are implemented, and allows users to include new smoothers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gam.smoothers(slist = c("s", "lo", "random"), wlist = c("s", "lo"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gam.smoothers_+3A_slist">slist</code></td>
<td>
<p>character vector giving names of smoothers available for
general backfitting. For every entry, eg &quot;lo&quot;, there must exist a formula
function &quot;lo()&quot; that prepares the data, and a fitting function with the name
&quot;gam.lo&quot; which actually does the fitting. Look at &quot;lo&quot; and &quot;s&quot; as examples.</p>
</td></tr>
<tr><td><code id="gam.smoothers_+3A_wlist">wlist</code></td>
<td>
<p>character vector (subset of slist) giving names of smoothers
for which a special backfitting algorithm is available, when only that
smoother appears (multiple times) in the formula, along with other non
smooth terms.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list is returned, consisting of the two named vectors. If the
function is called with no arguments, it gets the version of
&quot;gam.smooth.list&quot;' in the search path, by default from the package name
space. Once it is called with either of the arguments, it places a local
copy in the users namespace.
</p>


<h3>References</h3>

<p>Hastie, T. J. (1992) <em>Generalized additive models.</em> Chapter
7 of <em>Statistical Models in S</em> eds J. M. Chambers and T. J. Hastie,
Wadsworth &amp; Brooks/Cole.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: gam.smoothers()$slist # get the gam.smooth.list, and extract component slist
## Not run: gam.smoothers(slist=c("s","lo","random","tps") # add a new smoother "tps" to the list

</code></pre>

<hr>
<h2 id='kyphosis'>A classic example dataset for GAMs</h2><span id='topic+kyphosis'></span>

<h3>Description</h3>

<p>Data on the results of a spinal operation &quot;laminectomy&quot; on children, to
correct for a condition called &quot;kyphosis&quot;; see Hastie and Tibshirani (1990)
for details
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(kyphosis)
</code></pre>


<h3>Format</h3>

<p>A data frame with 81 observations on the following 4 variables.
</p>
 <dl>
<dt>Kyphosis</dt><dd><p>a response factor with levels <code>absent</code>
<code>present</code>.</p>
</dd> <dt>Age</dt><dd><p>of child in months, a numeric vector</p>
</dd>
<dt>Number</dt><dd><p>of vertebra involved in the operation,a numeric vector</p>
</dd>
<dt>Start</dt><dd><p>level of the operation, a numeric vector</p>
</dd> </dl>



<h3>Source</h3>

<p>Hastie, T. and Tibshirani, R. (1990) <em>Generalized Additive
Models.</em> London: Chapman and Hall.
</p>

<hr>
<h2 id='na.gam.replace'>Missing Data Filter for GAMs</h2><span id='topic+na.gam.replace'></span>

<h3>Description</h3>

<p>A method for dealing with missing values, friendly to GAM models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>na.gam.replace(frame)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="na.gam.replace_+3A_frame">frame</code></td>
<td>
<p>a model or data frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a model or data frame is returned, with the missing observations
(NAs) replaced. The following rules are used. A factor with missing data is
replaced by a new factor with one more level, labelled <code>"NA"</code>, which
records the missing data.  Ordered factors are treated similarly, except the
result is an unordered factor. A missing numeric vector has its missing
entires replaced by the mean of the non-missing entries. Similarly, a matrix
with missing entries has each missing entry replace by the mean of its
column. If <code>frame</code> is a model frame, the response variable can be
identified, as can the weights (if present). Any rows for which the response
or weight is missing are removed entirely from the model frame.
</p>
<p>The word <code>"gam"</code> in the name is relevant, because <code>gam()</code> makes
special use of this filter. All columns of a model frame that were created
by a call to <code>lo()</code> or <code>s()</code> have an attribute names <code>"NAs"</code>
if NAs are present in their columns.  Despite the replacement by means,
these attributes remain on the object, and <code>gam()</code> takes appropriate
action when smoothing against these columns. See section 7.3.2 in Hastie
(1992) for more details.
</p>


<h3>Author(s)</h3>

<p>Trevor Hastie
</p>


<h3>References</h3>

<p>Hastie, T. J. (1992) <em>Generalized additive models.</em> Chapter
7 of <em>Statistical Models in S</em> eds J. M. Chambers and T. J. Hastie,
Wadsworth &amp; Brooks/Cole.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+na.fail">na.fail</a></code>, <code><a href="stats.html#topic+na.omit">na.omit</a></code>, <code><a href="#topic+gam">gam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(airquality)
gam(Ozone^(1/3) ~ lo(Solar.R) + lo(Wind, Temp), data=airquality, na=na.gam.replace)

</code></pre>

<hr>
<h2 id='plot.Gam'>Plot Components of a GAM Object</h2><span id='topic+plot.Gam'></span><span id='topic+preplot.Gam'></span><span id='topic+plot.preplot.Gam'></span>

<h3>Description</h3>

<p>A plot method for GAM objects, which can be used on GLM and LM objects as
well. It focuses on terms (main-effects), and produces a suitable plot for
terms of different types
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Gam'
plot(
  x,
  residuals = NULL,
  rugplot = TRUE,
  se = FALSE,
  scale = 0,
  ask = FALSE,
  terms = labels.Gam(x),
  ...
)

## S3 method for class 'Gam'
preplot(object, newdata, terms = labels.Gam(object), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.Gam_+3A_x">x</code></td>
<td>
<p>a <code>Gam</code> object, or a <code>preplot.Gam</code> object. The
first thing <code>plot.Gam()</code> does is check if <code>x</code> has a
component called <code>preplot</code>; if not, it computes one using
<code>preplot.Gam()</code>. Either way, it is this <code>preplot.Gam</code>
object that is required for plotting a <code>Gam</code> object.</p>
</td></tr>
<tr><td><code id="plot.Gam_+3A_residuals">residuals</code></td>
<td>
<p>if <code>TRUE</code>, partial deviance residuals are
plotted along with the fitted terms&mdash;default is <code>FALSE</code>. If
<code>residuals</code> is a vector with the same length as each fitted
term in <code>x</code>, then these are taken to be the overall
residuals to be used for constructing the partial residuals.</p>
</td></tr>
<tr><td><code id="plot.Gam_+3A_rugplot">rugplot</code></td>
<td>
<p>if <code>TRUE</code> (the default), a univariate histogram
or <code>rugplot</code> is displayed along the base of each plot,
showing the occurrence of each <code>x</code>; ties are broken by jittering.</p>
</td></tr>
<tr><td><code id="plot.Gam_+3A_se">se</code></td>
<td>
<p>if <code>TRUE</code>, upper and lower pointwise
twice-standard-error curves are included for each plot. The
default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.Gam_+3A_scale">scale</code></td>
<td>
<p>a lower limit for the number of units covered by the
limits on the <code>y</code> for each plot. The default is <code>scale=0</code>,
in which case each plot uses the range of the functions being
plotted to create their <code>ylim</code>. By setting <code>scale</code> to
be the maximum value of <code>diff(ylim)</code> for all the plots, then
all subsequent plots will produced in the same vertical
units. This is essential for comparing the importance of fitted
terms in additive models.</p>
</td></tr>
<tr><td><code id="plot.Gam_+3A_ask">ask</code></td>
<td>
<p>if <code>TRUE</code>, <code>plot.Gam()</code> operates in interactive mode.</p>
</td></tr>
<tr><td><code id="plot.Gam_+3A_terms">terms</code></td>
<td>
<p>subsets of the terms can be selected</p>
</td></tr>
<tr><td><code id="plot.Gam_+3A_...">...</code></td>
<td>
<p>Additonal plotting arguments, not all of which will
work (like xlim)</p>
</td></tr>
<tr><td><code id="plot.Gam_+3A_object">object</code></td>
<td>
<p>same as <code>x</code></p>
</td></tr>
<tr><td><code id="plot.Gam_+3A_newdata">newdata</code></td>
<td>
<p>if supplied to <code>preplot.Gam</code>, the preplot object is based on them rather than the original.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot is produced for each of the terms in the object
<code>x</code>. The function currently knows how to plot all
main-effect functions of one or two predictors. So in particular,
interactions are not plotted. An appropriate <code>x-y</code> is produced to
display each of the terms, adorned with residuals, standard-error
curves, and a rugplot, depending on the choice of options.  The
form of the plot is different, depending on whether the <code>x</code>-value
for each plot is numeric, a factor, or a matrix.
</p>
<p>When <code>ask=TRUE</code>, rather than produce each plot sequentially,
<code>plot.Gam()</code> displays a menu listing all the terms that can be plotted,
as well as switches for all the options.
</p>
<p>A <code>preplot.Gam</code> object is a list of precomputed terms. Each such term
(also a <code>preplot.Gam</code> object) is a list with components <code>x</code>,
<code>y</code> and others&mdash;the basic ingredients needed for each term plot. These
are in turn handed to the specialized plotting function <code>gplot()</code>,
which has methods for different classes of the leading <code>x</code> argument. In
particular, a different plot is produced if <code>x</code> is numeric, a category
or factor, a matrix, or a list. Experienced users can extend this range by
creating more <code>gplot()</code> methods for other classes.  Graphical
parameters (see <code><a href="graphics.html#topic+par">par</a></code>) may also be supplied as arguments to this
function. This function is a method for the generic function <code>plot()</code>
for class <code>"Gam"</code>.
</p>
<p>It can be invoked by calling <code>plot(x)</code> for an object <code>x</code> of the
appropriate class, or directly by calling <code>plot.Gam(x)</code> regardless of
the class of the object.
</p>


<h3>Author(s)</h3>

<p>Written by Trevor Hastie, following closely the design in the
&quot;Generalized Additive Models&quot; chapter (Hastie, 1992) in Chambers and Hastie
(1992).
</p>


<h3>References</h3>

<p>Hastie, T. J. (1992) <em>Generalized additive models.</em> Chapter
7 of <em>Statistical Models in S</em> eds J. M. Chambers and T. J. Hastie,
Wadsworth &amp; Brooks/Cole.
</p>
<p>Hastie, T. and Tibshirani, R. (1990) <em>Generalized Additive Models.</em>
London: Chapman and Hall.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+preplot">preplot</a></code>, <code><a href="#topic+predict.Gam">predict.Gam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(gam.data)
Gam.object &lt;- gam(y ~ s(x,6) + z,data=gam.data)
plot(Gam.object,se=TRUE)
data(gam.newdata)
preplot(Gam.object,newdata=gam.newdata)

</code></pre>

<hr>
<h2 id='predict.Gam'>Predict method for GAM fits</h2><span id='topic+predict.Gam'></span>

<h3>Description</h3>

<p>Obtains predictions and optionally estimates standard errors of those
predictions from a fitted generalized additive model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Gam'
predict(
  object,
  newdata,
  type = c("link", "response", "terms"),
  dispersion = NULL,
  se.fit = FALSE,
  na.action = na.pass,
  terms = labels(object),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.Gam_+3A_object">object</code></td>
<td>
<p>a fitted <code>Gam</code> object, or one of its
inheritants, such as a <code>glm</code> or <code>lm</code> object.</p>
</td></tr>
<tr><td><code id="predict.Gam_+3A_newdata">newdata</code></td>
<td>
<p>a data frame containing the values at which
predictions are required. This argument can be missing, in which
case predictions are made at the same values used to compute the
object.  Only those predictors, referred to in the right side of
the formula in object need be present by name in <code>newdata</code>.</p>
</td></tr>
<tr><td><code id="predict.Gam_+3A_type">type</code></td>
<td>
<p>type of predictions, with choices <code>"link"</code> (the
default), <code>"response"</code>, or <code>"terms"</code>. The default
produces predictions on the scale of the additive predictors, and
with <code>newdata</code> missing, <code>predict</code> is simply an
extractor function for this component of a <code>Gam</code> object. If
<code>"response"</code> is selected, the predictions are on the scale
of the response, and are monotone transformations of the additive
predictors, using the inverse link function. If
<code>type="terms"</code> is selected, a matrix of predictions is
produced, one column for each term in the model.</p>
</td></tr>
<tr><td><code id="predict.Gam_+3A_dispersion">dispersion</code></td>
<td>
<p>the dispersion of the GLM fit to be assumed in
computing the standard errors.  If omitted, that returned by
'summary' applied to the object is used</p>
</td></tr>
<tr><td><code id="predict.Gam_+3A_se.fit">se.fit</code></td>
<td>
<p>if <code>TRUE</code>, pointwise standard errors are
computed along with the predictions.</p>
</td></tr>
<tr><td><code id="predict.Gam_+3A_na.action">na.action</code></td>
<td>
<p>function determining what should be done with
missing values in 'newdata'.  The default is to predict 'NA'.</p>
</td></tr>
<tr><td><code id="predict.Gam_+3A_terms">terms</code></td>
<td>
<p>if <code>type="terms"</code>, the <code>terms=</code> argument can
be used to specify which terms should be included; the default is
<code>labels(object)</code>.</p>
</td></tr>
<tr><td><code id="predict.Gam_+3A_...">...</code></td>
<td>
<p>Placemark for additional arguments to predict</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector or matrix of predictions, or a list consisting of
the predictions and their standard errors if <code>se.fit =
  TRUE</code>.  If <code>type="terms"</code>, a matrix of fitted terms is
produced, with one column for each term in the model (or subset
of these if the <code>terms=</code> argument is used). There is no
column for the intercept, if present in the model, and each of
the terms is centered so that their average over the original
data is zero.  The matrix of fitted terms has a <code>"constant"</code>
attribute which, when added to the sum of these centered terms,
gives the additive predictor. See the documentation of
<code>predict</code> for more details on the components returned.
</p>
<p>When <code>newdata</code> are supplied, <code>predict.Gam</code> simply invokes
inheritance and gets <code>predict.glm</code> to produce the parametric part of
the predictions. For each nonparametric term, <code>predict.Gam</code>
reconstructs the partial residuals and weights from the final iteration of
the local scoring algorithm. The appropriate smoother is called for each
term, with the appropriate <code>xeval</code> argument (see <code><a href="#topic+s">s</a></code> or
<code><a href="#topic+lo">lo</a></code>), and the prediction for that term is produced.
</p>
<p>The standard errors are based on an approximation given in Hastie (1992).
Currently <code>predict.Gam</code> does not produce standard errors for
predictions at <code>newdata</code>.
</p>
<p>Warning: naive use of the generic <code>predict</code> can produce incorrect
predictions when the <code>newdata</code> argument is used, if the formula in
<code>object</code> involves transformations such as <code>sqrt(Age - min(Age))</code>.
</p>


<h3>Author(s)</h3>

<p>Written by Trevor Hastie, following closely the design in the
&quot;Generalized Additive Models&quot; chapter (Hastie, 1992) in Chambers and Hastie
(1992). This version of <code>predict.Gam</code> is adapted from the S version to
match the corresponding predict methods for <code>glm</code> and <code>lm</code> objects
in R. The <code>safe.predict.Gam</code> function in S is no longer required,
primarily because a safe prediction method is in place for functions like
<code>ns</code>, <code>bs</code>, and <code>poly</code>.
</p>


<h3>References</h3>

<p>Hastie, T. J. (1992) <em>Generalized additive models.</em> Chapter
7 of <em>Statistical Models in S</em> eds J. M. Chambers and T. J. Hastie,
Wadsworth &amp; Brooks/Cole.
</p>
<p>Hastie, T. and Tibshirani, R. (1990) <em>Generalized Additive Models.</em>
London: Chapman and Hall.
</p>
<p>Venables, W. N. and Ripley, B. D. (2002) <em>Modern Applied Statistics
with S.</em> New York: Springer.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+predict.glm">predict.glm</a></code>, <code><a href="stats.html#topic+fitted">fitted</a></code>,
<code><a href="base.html#topic+expand.grid">expand.grid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(gam.data)
Gam.object &lt;- gam(y ~ s(x,6) + z, data=gam.data)
predict(Gam.object) # extract the additive predictors
data(gam.newdata)
predict(Gam.object, gam.newdata, type="terms") 
</code></pre>

<hr>
<h2 id='step.Gam'>Stepwise model builder for GAM</h2><span id='topic+step.Gam'></span>

<h3>Description</h3>

<p>Builds a GAM model in a step-wise fashion. For each &quot;term&quot; there is an
ordered list of alternatives, and the function traverses these in a greedy
fashion. Note: this is NOT a method for <code>step</code>, which used to be a
generic, so must be invoked with the full name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step.Gam(
  object,
  scope,
  scale,
  direction = c("both", "backward", "forward"),
  trace = TRUE,
  keep = NULL,
  steps = 1000,
  parallel = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step.Gam_+3A_object">object</code></td>
<td>
<p>An object of class <code>Gam</code> or any of it's inheritants.</p>
</td></tr>
<tr><td><code id="step.Gam_+3A_scope">scope</code></td>
<td>
<p>defines the range of models examined in the step-wise search.
It is a list of formulas, with each formula corresponding to a term in the
model. Each of these formulas specifies a &quot;regimen&quot; of candidate forms in
which the particular term may enter the model. For example, a term formula
might be <code>~1+ Income + log(Income) + s(Income)</code>. This means that
<code>Income</code> could either appear not at all, linearly, linearly in its
logarithm, or as a smooth function estimated nonparametrically. A <code>1</code>
in the formula allows the additional option of leaving the term out of the
model entirely.  Every term in the model is described by such a term
formula, and the final model is built up by selecting a component from each
formula.
</p>
<p>As an alternative more convenient for big models, each list can have instead
of a formula a character vector corresponding to the candidates for that
term. Thus we could have <code>c("1","x","s(x,df=5")</code> rather than
<code>~1+x+s(x,df=5)</code>.
</p>
<p>The supplied model <code>object</code> is used as the starting model, and hence
there is the requirement that one term from each of the term formulas be
present in <code>formula(object)</code>. This also implies that any terms in
<code>formula(object)</code> <em>not</em> contained in any of the term formulas will
be forced to be present in every model considered. The function
<code>gam.scope</code> is helpful for generating the scope argument for a large
model.</p>
</td></tr>
<tr><td><code id="step.Gam_+3A_scale">scale</code></td>
<td>
<p>an optional argument used in the definition of the AIC
statistic used to evaluate models for selection. By default, the scaled
Chi-squared statistic for the initial model is used, but if forward
selection is to be performed, this is not necessarily a sound choice.</p>
</td></tr>
<tr><td><code id="step.Gam_+3A_direction">direction</code></td>
<td>
<p>The mode of step-wise search, can be one of <code>"both"</code>,
<code>"backward"</code>, or <code>"forward"</code>, with a default of <code>"both"</code>. If
<code>scope</code> is missing, the default for <code>direction</code> is &quot;both&quot;.</p>
</td></tr>
<tr><td><code id="step.Gam_+3A_trace">trace</code></td>
<td>
<p>If <code>TRUE</code> (the default), information is printed during the
running of <code>step.Gam()</code>. This is an encouraging choice in general,
since <code>step.Gam()</code> can take some time to compute either for large
models or when called with an an extensive <code>scope=</code> argument. A simple
one line model summary is printed for each model selected. This argument can
also be given as the binary <code>0</code> or <code>1</code>. A value <code>trace=2</code>
gives a more verbose trace.</p>
</td></tr>
<tr><td><code id="step.Gam_+3A_keep">keep</code></td>
<td>
<p>A filter function whose input is a fitted <code>Gam</code> object, and
anything else passed via ..., and whose output is arbitrary. Typically
<code>keep()</code> will select a subset of the components of the object and
return them. The default is not to keep anything.</p>
</td></tr>
<tr><td><code id="step.Gam_+3A_steps">steps</code></td>
<td>
<p>The maximum number of steps to be considered. The default is
1000 (essentially as many as required). It is typically used to stop the
process early.</p>
</td></tr>
<tr><td><code id="step.Gam_+3A_parallel">parallel</code></td>
<td>
<p>If <code>TRUE</code>, use parallel <code>foreach</code> to fit each
trial run.  Must register parallel before hand, such as <code>doMC</code> or
others.  See the example below.</p>
</td></tr>
<tr><td><code id="step.Gam_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed on to <code>keep</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The step-wise-selected model is returned, with up to two additional
components. There is an <code>"anova"</code> component corresponding to the steps
taken in the search, as well as a <code>"keep"</code> component if the
<code>keep=</code> argument was supplied in the call.
</p>
<p>We describe the most general setup, when <code>direction = "both"</code>. At any
stage there is a current model comprising a single term from each of the
term formulas supplied in the <code>scope=</code> argument. A series of models is
fitted, each corrresponding to a formula obtained by moving each of the
terms one step up or down in its regimen, relative to the formula of the
current model. If the current value for any term is at either of the extreme
ends of its regimen, only one rather than two steps can be considered. So if
there are <code>p</code> term formulas, at most <code>2*p - 1</code> models are
considered. A record is kept of all the models ever visited (hence the
<code>-1</code> above), to avoid repetition. Once each of these models has been
fit, the &quot;best&quot; model in terms of the AIC statistic is selected and defines
the step. The entire process is repeated until either the maximum number of
steps has been used, or until the AIC criterion can not be decreased by any
of the eligible steps.
</p>


<h3>Author(s)</h3>

<p>Written by Trevor Hastie, following closely the design in the
&quot;Generalized Additive Models&quot; chapter (Hastie, 1992) in Chambers and Hastie
(1992).
</p>


<h3>References</h3>

<p>Hastie, T. J. (1992) <em>Generalized additive models.</em> Chapter
7 of <em>Statistical Models in S</em> eds J. M. Chambers and T. J. Hastie,
Wadsworth &amp; Brooks/Cole.
</p>
<p>Hastie, T. and Tibshirani, R. (1990) <em>Generalized Additive Models.</em>
London: Chapman and Hall.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gam.scope">gam.scope</a></code>,<code><a href="stats.html#topic+step">step</a></code>,<code><a href="stats.html#topic+glm">glm</a></code>,
<code><a href="#topic+gam">gam</a></code>, <code><a href="stats.html#topic+drop1">drop1</a></code>, <code><a href="stats.html#topic+add1">add1</a></code>,
<code><a href="#topic+anova.Gam">anova.Gam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(gam.data)
Gam.object &lt;- gam(y~x+z, data=gam.data)
step.object &lt;-step.Gam(Gam.object, scope=list("x"=~1+x+s(x,4)+s(x,6)+s(x,12),"z"=~1+z+s(z,4)))
## Not run: 
# Parallel
require(doMC)
registerDoMC(cores=2)
step.Gam(Gam.object, scope=list("x"=~1+x+s(x,4)+s(x,6)+s(x,12),"z"=~1+z+s(z,4)),parallel=TRUE)

## End(Not run)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
