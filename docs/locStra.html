<!DOCTYPE html><html><head><title>Help for package locStra</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {locStra}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bed_fastCovEVs'><p>Computation of the k leading eigenvectors of the covariance matrix directly from a bed+bim+fam file.</p></a></li>
<li><a href='#bed_fastGrmEVs'><p>Computation of the k leading eigenvectors of the genomic relationship matrix, defined in Yang et al. (2011), directly from a bed+bim+fam file.</p></a></li>
<li><a href='#bed_fastJaccardEVs'><p>Computation of the k leading eigenvectors of the Jaccard similarity matrix directly from a bed+bim+fam file.. Note that this computation is only approximate and does not necessarily coincide with the result obtained by extracting the k leading eigenvectors of the Jaccard matrix computed with the function <code>jaccardMatrix</code>.</p></a></li>
<li><a href='#bed_fastSMatrixEVs'><p>Computation of the k leading eigenvectors of the s-matrix (the weighted Jaccard similarity matrix) directly from a bed+bim+fam file. Note that in contrast to the parameters of the function <code>sMatrix</code>, the choice <code>phased=FALSE</code> cannot be modified for the fast eigenvector computation. Moreover, inverting the minor allele is not possible when reading directly from external files.</p></a></li>
<li><a href='#covMatrix'><p>C++ implementation to compute the covariance matrix for a (sparse) input matrix. The function is equivalent to the R command 'cov' applied to matrices.</p></a></li>
<li><a href='#fastCovEVs'><p>Computation of the k leading eigenvectors of the covariance matrix for a (sparse) input matrix.</p></a></li>
<li><a href='#fastGrmEVs'><p>Computation of the k leading eigenvectors of the genomic relationship matrix, defined in Yang et al. (2011), for a (sparse) input matrix.</p></a></li>
<li><a href='#fastJaccardEVs'><p>Computation of the k leading eigenvectors of the Jaccard similarity matrix for a (sparse) input matrix. Note that this computation is only approximate and does not necessarily coincide with the result obtained by extracting the k leading eigenvectors of the Jaccard matrix computed with the function <code>jaccardMatrix</code>.</p></a></li>
<li><a href='#fastSMatrixEVs'><p>Computation of the k leading eigenvectors of the s-matrix (the weighted Jaccard similarity matrix) for a (sparse) input matrix. Note that in contrast to the parameters of the function <code>sMatrix</code>, the choice <code>phased=FALSE</code> cannot be modified for the fast eigenvector computation.</p></a></li>
<li><a href='#fullscan'><p>A full scan of the input data <code>m</code> using a collection of windows given by the two-column matrix <code>windows</code>. For each window, the data is processed using the function <code>matrixFunction</code> (this could be, e.g., the <code>covMatrix</code> function), then the processed data is summarized using the function <code>summaryFunction</code> (e.g., the largest eigenvector computed with the function <code>powerMethod</code>), and finally the global and local summaries are compared using the function <code>comparisonFunction</code> (e.g., the vector correlation with R's function <code>cor</code>). The function returns a two-column matrix which contains per row the global summary statistics (e.g., the correlation between the global and local eigenvectors) and the local summary statistics (e.g., the correlation between the local eigenvectors of the previous and current windows) for each window.</p></a></li>
<li><a href='#grMatrix'><p>C++ implementation to compute the genomic relationship matrix (grm) for a (sparse) input matrix as defined in Yang et al. (2011).</p></a></li>
<li><a href='#jaccardMatrix'><p>C++ implementation to compute the Jaccard similarity matrix for a (sparse) input matrix.</p></a></li>
<li><a href='#makeWindows'><p>Auxiliary function to generate a two-column matrix of windows to be used in the function 'fullscan'.</p></a></li>
<li><a href='#powerMethod'><p>C++ implementation of the power method (von Mises iteration) to compute the largest eigenvector of a dense input matrix.</p></a></li>
<li><a href='#selectVariants'><p>Auxiliary function to invert minor alleles and to select those variants/loci exceeding a minimal cutoff value.</p></a></li>
<li><a href='#sMatrix'><p>C++ implementation to compute the s-matrix (the weighted Jaccard similarity matrix) for a (sparse) input matrix as in the 'Stego' package: https://github.com/dschlauch/stego</p></a></li>
<li><a href='#testdata'><p>Simulated test data.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fast Implementation of (Local) Population Stratification Methods</td>
</tr>
<tr>
<td>Version:</td>
<td>1.9</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-04-07</td>
</tr>
<tr>
<td>Author:</td>
<td>Georg Hahn [aut,cre], Sharon M. Lutz [ctb], Christoph Lange [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Georg Hahn &lt;ghahn@hsph.harvard.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Fast implementations to compute the genetic covariance matrix, the Jaccard similarity matrix, the s-matrix (the weighted Jaccard similarity matrix), and the (classic or robust) genomic relationship matrix of a (dense or sparse) input matrix (see Hahn, Lutz, Hecker, Prokopenko, Cho, Silverman, Weiss, and Lange (2020) &lt;<a href="https://doi.org/10.1002%2Fgepi.22356">doi:10.1002/gepi.22356</a>&gt;). Full support for sparse matrices from the R-package 'Matrix'. Additionally, an implementation of the power method (von Mises iteration) to compute the largest eigenvector of a matrix is included, a function to perform an automated full run of global and local correlations in population stratification data, a function to compute sliding windows, and a function to invert minor alleles and to select those variants/loci exceeding a minimal cutoff value. New functionality in locStra allows one to extract the k leading eigenvectors of the genetic covariance matrix, Jaccard similarity matrix, s-matrix, and genomic relationship matrix via fast PCA without actually computing the similarity matrices. The fast PCA to compute the k leading eigenvectors can now also be run directly from 'bed'+'bim'+'fam' files.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.13), Rdpack, Matrix, RSpectra, bigsnpr</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-08 00:26:41 UTC; acer</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-12 18:52:29 UTC</td>
</tr>
</table>
<hr>
<h2 id='bed_fastCovEVs'>Computation of the k leading eigenvectors of the covariance matrix directly from a bed+bim+fam file.</h2><span id='topic+bed_fastCovEVs'></span>

<h3>Description</h3>

<p>Computation of the k leading eigenvectors of the covariance matrix directly from a bed+bim+fam file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bed_fastCovEVs(f, k, q = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bed_fastCovEVs_+3A_f">f</code></td>
<td>
<p>The filename of the bed file (including its extension). The bim and fam files need to be in the same folder and have the same base filename.</p>
</td></tr>
<tr><td><code id="bed_fastCovEVs_+3A_k">k</code></td>
<td>
<p>The number of leading eigenvectors.</p>
</td></tr>
<tr><td><code id="bed_fastCovEVs_+3A_q">q</code></td>
<td>
<p>The number of power iteration steps (default is <code>q=2</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The k leading eigenvectors of the covariance matrix of <code>m</code> as a column matrix.
</p>


<h3>References</h3>

<p>R Core Team (2014). R: A Language and Environment for Statistical Computing. R Foundation for Stat Comp, Vienna, Austria.
</p>
<p>N. Halko, P.G. Martinsson, and J.A. Tropp (2011). Finding Structure with Randomness: Probabilistic Algorithms for Constructing Approximate Matrix Decompositions. SIAM Review: 53(2), pp. 217&ndash;288.
</p>
<p>F. Prive, M. Blum, H. Aschard, B.J. Vilhjalmsson (2022). bigsnpr: Analysis of Massive SNP Arrays. https://cran.r-project.org/package=bigsnpr
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(locStra)

</code></pre>

<hr>
<h2 id='bed_fastGrmEVs'>Computation of the k leading eigenvectors of the genomic relationship matrix, defined in Yang et al. (2011), directly from a bed+bim+fam file.</h2><span id='topic+bed_fastGrmEVs'></span>

<h3>Description</h3>

<p>Computation of the k leading eigenvectors of the genomic relationship matrix, defined in Yang et al. (2011), directly from a bed+bim+fam file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bed_fastGrmEVs(f, k, robust = TRUE, q = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bed_fastGrmEVs_+3A_f">f</code></td>
<td>
<p>The filename of the bed file (including its extension). The bim and fam files need to be in the same folder and have the same base filename.</p>
</td></tr>
<tr><td><code id="bed_fastGrmEVs_+3A_k">k</code></td>
<td>
<p>The number of leading eigenvectors.</p>
</td></tr>
<tr><td><code id="bed_fastGrmEVs_+3A_robust">robust</code></td>
<td>
<p>Flag to indicate if the classic (<code>robust=FALSE</code>) or robust (<code>robust=TRUE</code>) version of the genomic relationship matrix is desired. Default is <code>robust=TRUE</code>.</p>
</td></tr>
<tr><td><code id="bed_fastGrmEVs_+3A_q">q</code></td>
<td>
<p>The number of power iteration steps (default is <code>q=2</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The k leading eigenvectors of the genomic relationship matrix of <code>m</code> as a column matrix.
</p>


<h3>References</h3>

<p>Yang J, Lee SH, Goddard ME, Visscher PM (2011). GCTA: a tool for genome-wide complex trait analysis. Am J Hum Genet, 88(1):76-82.
</p>
<p>N. Halko, P.G. Martinsson, and J.A. Tropp (2011). Finding Structure with Randomness: Probabilistic Algorithms for Constructing Approximate Matrix Decompositions. SIAM Review: 53(2), pp. 217&ndash;288.
</p>
<p>F. Prive, M. Blum, H. Aschard, B.J. Vilhjalmsson (2022). bigsnpr: Analysis of Massive SNP Arrays. https://cran.r-project.org/package=bigsnpr
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(locStra)

</code></pre>

<hr>
<h2 id='bed_fastJaccardEVs'>Computation of the k leading eigenvectors of the Jaccard similarity matrix directly from a bed+bim+fam file.. Note that this computation is only approximate and does not necessarily coincide with the result obtained by extracting the k leading eigenvectors of the Jaccard matrix computed with the function <code>jaccardMatrix</code>.</h2><span id='topic+bed_fastJaccardEVs'></span>

<h3>Description</h3>

<p>Computation of the k leading eigenvectors of the Jaccard similarity matrix directly from a bed+bim+fam file.. Note that this computation is only approximate and does not necessarily coincide with the result obtained by extracting the k leading eigenvectors of the Jaccard matrix computed with the function <code>jaccardMatrix</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bed_fastJaccardEVs(f, k, q = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bed_fastJaccardEVs_+3A_f">f</code></td>
<td>
<p>The filename of the bed file (including its extension). The bim and fam files need to be in the same folder and have the same base filename.</p>
</td></tr>
<tr><td><code id="bed_fastJaccardEVs_+3A_k">k</code></td>
<td>
<p>The number of leading eigenvectors.</p>
</td></tr>
<tr><td><code id="bed_fastJaccardEVs_+3A_q">q</code></td>
<td>
<p>The number of power iteration steps (default is <code>q=2</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The k leading eigenvectors of the Jaccard matrix of <code>m</code> as a column matrix.
</p>


<h3>References</h3>

<p>Dmitry Prokopenko, Julian Hecker, Edwin Silverman, Marcello Pagano, Markus Noethen, Christian Dina, Christoph Lange and Heide Fier (2016). Utilizing the Jaccard index to reveal population stratification in sequencing data: a simulation study and an application to the 1000 Genomes Project. Bioinformatics, 32(9):1366-1372.
</p>
<p>N. Halko, P.G. Martinsson, and J.A. Tropp (2011). Finding Structure with Randomness: Probabilistic Algorithms for Constructing Approximate Matrix Decompositions. SIAM Review: 53(2), pp. 217&ndash;288.
</p>
<p>F. Prive, M. Blum, H. Aschard, B.J. Vilhjalmsson (2022). bigsnpr: Analysis of Massive SNP Arrays. https://cran.r-project.org/package=bigsnpr
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(locStra)

</code></pre>

<hr>
<h2 id='bed_fastSMatrixEVs'>Computation of the k leading eigenvectors of the s-matrix (the weighted Jaccard similarity matrix) directly from a bed+bim+fam file. Note that in contrast to the parameters of the function <code>sMatrix</code>, the choice <code>phased=FALSE</code> cannot be modified for the fast eigenvector computation. Moreover, inverting the minor allele is not possible when reading directly from external files.</h2><span id='topic+bed_fastSMatrixEVs'></span>

<h3>Description</h3>

<p>Computation of the k leading eigenvectors of the s-matrix (the weighted Jaccard similarity matrix) directly from a bed+bim+fam file. Note that in contrast to the parameters of the function <code>sMatrix</code>, the choice <code>phased=FALSE</code> cannot be modified for the fast eigenvector computation. Moreover, inverting the minor allele is not possible when reading directly from external files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bed_fastSMatrixEVs(f, k, Djac = FALSE, q = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bed_fastSMatrixEVs_+3A_f">f</code></td>
<td>
<p>The filename of the bed file (including its extension). The bim and fam files need to be in the same folder and have the same base filename.</p>
</td></tr>
<tr><td><code id="bed_fastSMatrixEVs_+3A_k">k</code></td>
<td>
<p>The number of leading eigenvectors.</p>
</td></tr>
<tr><td><code id="bed_fastSMatrixEVs_+3A_djac">Djac</code></td>
<td>
<p>Flag to switch between the unweighted (<code>Djac=TRUE</code>) or weighted (<code>Djac=FALSE</code>) version. Default is <code>Djac=FALSE</code>.</p>
</td></tr>
<tr><td><code id="bed_fastSMatrixEVs_+3A_q">q</code></td>
<td>
<p>The number of power iteration steps (default is <code>q=2</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The k leading eigenvectors of the s-matrix of <code>m</code> as a column matrix.
</p>


<h3>References</h3>

<p>Daniel Schlauch (2016). Implementation of the stego algorithm - Similarity Test for Estimating Genetic Outliers. https://github.com/dschlauch/stego
</p>
<p>N. Halko, P.G. Martinsson, and J.A. Tropp (2011). Finding Structure with Randomness: Probabilistic Algorithms for Constructing Approximate Matrix Decompositions. SIAM Review: 53(2), pp. 217&ndash;288.
</p>
<p>F. Prive, M. Blum, H. Aschard, B.J. Vilhjalmsson (2022). bigsnpr: Analysis of Massive SNP Arrays. https://cran.r-project.org/package=bigsnpr
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(locStra)

</code></pre>

<hr>
<h2 id='covMatrix'>C++ implementation to compute the covariance matrix for a (sparse) input matrix. The function is equivalent to the R command 'cov' applied to matrices.</h2><span id='topic+covMatrix'></span>

<h3>Description</h3>

<p>C++ implementation to compute the covariance matrix for a (sparse) input matrix. The function is equivalent to the R command 'cov' applied to matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covMatrix(m, useCpp = TRUE, sparse = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covMatrix_+3A_m">m</code></td>
<td>
<p>A (sparse) matrix for which the covariance matrix is sought. The input matrix is assumed to be oriented to contain the data for one individual per column.</p>
</td></tr>
<tr><td><code id="covMatrix_+3A_usecpp">useCpp</code></td>
<td>
<p>Flag to switch between R or C++ implementations. Default is <code>useCpp=TRUE</code>.</p>
</td></tr>
<tr><td><code id="covMatrix_+3A_sparse">sparse</code></td>
<td>
<p>Flag to switch between purpose-built dense or sparse implementations. Default is <code>sparse=TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The covariance matrix of <code>m</code>.
</p>


<h3>References</h3>

<p>R Core Team (2014). R: A Language and Environment for Statistical Computing. R Foundation for Stat Comp, Vienna, Austria.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(locStra)
require(Matrix)
m &lt;- matrix(sample(0:1,15,replace=TRUE),ncol=3)
sparseM &lt;- Matrix(m,sparse=TRUE)
print(covMatrix(sparseM))

</code></pre>

<hr>
<h2 id='fastCovEVs'>Computation of the k leading eigenvectors of the covariance matrix for a (sparse) input matrix.</h2><span id='topic+fastCovEVs'></span>

<h3>Description</h3>

<p>Computation of the k leading eigenvectors of the covariance matrix for a (sparse) input matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastCovEVs(m, k, useCpp = TRUE, sparse = TRUE, q = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fastCovEVs_+3A_m">m</code></td>
<td>
<p>A (sparse) matrix for which the eigenvectors of its covariance matrix are sought. The input matrix is assumed to be oriented to contain the data for one individual per column.</p>
</td></tr>
<tr><td><code id="fastCovEVs_+3A_k">k</code></td>
<td>
<p>The number of leading eigenvectors.</p>
</td></tr>
<tr><td><code id="fastCovEVs_+3A_usecpp">useCpp</code></td>
<td>
<p>Flag to switch between R or C++ implementations. Default is <code>useCpp=TRUE</code>.</p>
</td></tr>
<tr><td><code id="fastCovEVs_+3A_sparse">sparse</code></td>
<td>
<p>Flag to switch between purpose-built dense or sparse implementations. Default is <code>sparse=TRUE</code>.</p>
</td></tr>
<tr><td><code id="fastCovEVs_+3A_q">q</code></td>
<td>
<p>The number of power iteration steps (default is <code>q=2</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The k leading eigenvectors of the covariance matrix of <code>m</code> as a column matrix.
</p>


<h3>References</h3>

<p>R Core Team (2014). R: A Language and Environment for Statistical Computing. R Foundation for Stat Comp, Vienna, Austria.
</p>
<p>N. Halko, P.G. Martinsson, and J.A. Tropp (2011). Finding Structure with Randomness: Probabilistic Algorithms for Constructing Approximate Matrix Decompositions. SIAM Review: 53(2), pp. 217&ndash;288.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(locStra)
require(Matrix)
m &lt;- matrix(sample(0:1,100,replace=TRUE),ncol=5)
sparseM &lt;- Matrix(m,sparse=TRUE)
print(fastCovEVs(sparseM,k=2,useCpp=FALSE))

</code></pre>

<hr>
<h2 id='fastGrmEVs'>Computation of the k leading eigenvectors of the genomic relationship matrix, defined in Yang et al. (2011), for a (sparse) input matrix.</h2><span id='topic+fastGrmEVs'></span>

<h3>Description</h3>

<p>Computation of the k leading eigenvectors of the genomic relationship matrix, defined in Yang et al. (2011), for a (sparse) input matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastGrmEVs(m, k, useCpp = TRUE, sparse = TRUE, robust = TRUE, q = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fastGrmEVs_+3A_m">m</code></td>
<td>
<p>A (sparse) matrix for which the eigenvectors of its genomic relationship matrix are sought. The input matrix is assumed to be oriented to contain the data for one individual per column.</p>
</td></tr>
<tr><td><code id="fastGrmEVs_+3A_k">k</code></td>
<td>
<p>The number of leading eigenvectors.</p>
</td></tr>
<tr><td><code id="fastGrmEVs_+3A_usecpp">useCpp</code></td>
<td>
<p>Flag to switch between R or C++ implementations. Default is <code>useCpp=TRUE</code>.</p>
</td></tr>
<tr><td><code id="fastGrmEVs_+3A_sparse">sparse</code></td>
<td>
<p>Flag to switch between purpose-built dense or sparse implementations. Default is <code>sparse=TRUE</code>.</p>
</td></tr>
<tr><td><code id="fastGrmEVs_+3A_robust">robust</code></td>
<td>
<p>Flag to indicate if the classic (<code>robust=FALSE</code>) or robust (<code>robust=TRUE</code>) version of the genomic relationship matrix is desired. Default is <code>robust=TRUE</code>.</p>
</td></tr>
<tr><td><code id="fastGrmEVs_+3A_q">q</code></td>
<td>
<p>The number of power iteration steps (default is <code>q=2</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The k leading eigenvectors of the genomic relationship matrix of <code>m</code> as a column matrix.
</p>


<h3>References</h3>

<p>Yang J, Lee SH, Goddard ME, Visscher PM (2011). GCTA: a tool for genome-wide complex trait analysis. Am J Hum Genet, 88(1):76-82.
</p>
<p>N. Halko, P.G. Martinsson, and J.A. Tropp (2011). Finding Structure with Randomness: Probabilistic Algorithms for Constructing Approximate Matrix Decompositions. SIAM Review: 53(2), pp. 217&ndash;288.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(locStra)
require(Matrix)
m &lt;- matrix(sample(0:1,100,replace=TRUE),ncol=5)
sparseM &lt;- Matrix(m,sparse=TRUE)
print(fastGrmEVs(sparseM,k=2,useCpp=FALSE))

</code></pre>

<hr>
<h2 id='fastJaccardEVs'>Computation of the k leading eigenvectors of the Jaccard similarity matrix for a (sparse) input matrix. Note that this computation is only approximate and does not necessarily coincide with the result obtained by extracting the k leading eigenvectors of the Jaccard matrix computed with the function <code>jaccardMatrix</code>.</h2><span id='topic+fastJaccardEVs'></span>

<h3>Description</h3>

<p>Computation of the k leading eigenvectors of the Jaccard similarity matrix for a (sparse) input matrix. Note that this computation is only approximate and does not necessarily coincide with the result obtained by extracting the k leading eigenvectors of the Jaccard matrix computed with the function <code>jaccardMatrix</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastJaccardEVs(m, k, useCpp = TRUE, sparse = TRUE, q = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fastJaccardEVs_+3A_m">m</code></td>
<td>
<p>A (sparse) matrix for which the eigenvectors of its Jaccard matrix are sought. The input matrix is assumed to be oriented to contain the data for one individual per column.</p>
</td></tr>
<tr><td><code id="fastJaccardEVs_+3A_k">k</code></td>
<td>
<p>The number of leading eigenvectors.</p>
</td></tr>
<tr><td><code id="fastJaccardEVs_+3A_usecpp">useCpp</code></td>
<td>
<p>Flag to switch between R or C++ implementations. Default is <code>useCpp=TRUE</code>.</p>
</td></tr>
<tr><td><code id="fastJaccardEVs_+3A_sparse">sparse</code></td>
<td>
<p>Flag to switch between purpose-built dense or sparse implementations. Default is <code>sparse=TRUE</code>.</p>
</td></tr>
<tr><td><code id="fastJaccardEVs_+3A_q">q</code></td>
<td>
<p>The number of power iteration steps (default is <code>q=2</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The k leading eigenvectors of the Jaccard matrix of <code>m</code> as a column matrix.
</p>


<h3>References</h3>

<p>Dmitry Prokopenko, Julian Hecker, Edwin Silverman, Marcello Pagano, Markus Noethen, Christian Dina, Christoph Lange and Heide Fier (2016). Utilizing the Jaccard index to reveal population stratification in sequencing data: a simulation study and an application to the 1000 Genomes Project. Bioinformatics, 32(9):1366-1372.
</p>
<p>N. Halko, P.G. Martinsson, and J.A. Tropp (2011). Finding Structure with Randomness: Probabilistic Algorithms for Constructing Approximate Matrix Decompositions. SIAM Review: 53(2), pp. 217&ndash;288.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(locStra)
require(Matrix)
m &lt;- matrix(sample(0:1,100,replace=TRUE),ncol=5)
sparseM &lt;- Matrix(m,sparse=TRUE)
print(fastJaccardEVs(sparseM,k=2,useCpp=FALSE))

</code></pre>

<hr>
<h2 id='fastSMatrixEVs'>Computation of the k leading eigenvectors of the s-matrix (the weighted Jaccard similarity matrix) for a (sparse) input matrix. Note that in contrast to the parameters of the function <code>sMatrix</code>, the choice <code>phased=FALSE</code> cannot be modified for the fast eigenvector computation.</h2><span id='topic+fastSMatrixEVs'></span>

<h3>Description</h3>

<p>Computation of the k leading eigenvectors of the s-matrix (the weighted Jaccard similarity matrix) for a (sparse) input matrix. Note that in contrast to the parameters of the function <code>sMatrix</code>, the choice <code>phased=FALSE</code> cannot be modified for the fast eigenvector computation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastSMatrixEVs(m, k, useCpp = TRUE, sparse = TRUE, Djac = FALSE, q = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fastSMatrixEVs_+3A_m">m</code></td>
<td>
<p>A (sparse) matrix for which the eigenvectors of its s-matrix are sought. The input matrix is assumed to be oriented to contain the data for one individual per column.</p>
</td></tr>
<tr><td><code id="fastSMatrixEVs_+3A_k">k</code></td>
<td>
<p>The number of leading eigenvectors.</p>
</td></tr>
<tr><td><code id="fastSMatrixEVs_+3A_usecpp">useCpp</code></td>
<td>
<p>Flag to switch between R or C++ implementations. Default is <code>useCpp=TRUE</code>.</p>
</td></tr>
<tr><td><code id="fastSMatrixEVs_+3A_sparse">sparse</code></td>
<td>
<p>Flag to switch between purpose-built dense or sparse implementations. Default is <code>sparse=TRUE</code>.</p>
</td></tr>
<tr><td><code id="fastSMatrixEVs_+3A_djac">Djac</code></td>
<td>
<p>Flag to switch between the unweighted (<code>Djac=TRUE</code>) or weighted (<code>Djac=FALSE</code>) version. Default is <code>Djac=FALSE</code>.</p>
</td></tr>
<tr><td><code id="fastSMatrixEVs_+3A_q">q</code></td>
<td>
<p>The number of power iteration steps (default is <code>q=2</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The k leading eigenvectors of the s-matrix of <code>m</code> as a column matrix.
</p>


<h3>References</h3>

<p>Daniel Schlauch (2016). Implementation of the stego algorithm - Similarity Test for Estimating Genetic Outliers. https://github.com/dschlauch/stego
</p>
<p>N. Halko, P.G. Martinsson, and J.A. Tropp (2011). Finding Structure with Randomness: Probabilistic Algorithms for Constructing Approximate Matrix Decompositions. SIAM Review: 53(2), pp. 217&ndash;288.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(locStra)
require(Matrix)
m &lt;- matrix(sample(0:1,100,replace=TRUE),ncol=5)
sparseM &lt;- Matrix(m,sparse=TRUE)
print(fastSMatrixEVs(sparseM,k=2,useCpp=FALSE))

</code></pre>

<hr>
<h2 id='fullscan'>A full scan of the input data <code>m</code> using a collection of windows given by the two-column matrix <code>windows</code>. For each window, the data is processed using the function <code>matrixFunction</code> (this could be, e.g., the <code>covMatrix</code> function), then the processed data is summarized using the function <code>summaryFunction</code> (e.g., the largest eigenvector computed with the function <code>powerMethod</code>), and finally the global and local summaries are compared using the function <code>comparisonFunction</code> (e.g., the vector correlation with R's function <code>cor</code>). The function returns a two-column matrix which contains per row the global summary statistics (e.g., the correlation between the global and local eigenvectors) and the local summary statistics (e.g., the correlation between the local eigenvectors of the previous and current windows) for each window.</h2><span id='topic+fullscan'></span>

<h3>Description</h3>

<p>A full scan of the input data <code>m</code> using a collection of windows given by the two-column matrix <code>windows</code>. For each window, the data is processed using the function <code>matrixFunction</code> (this could be, e.g., the <code>covMatrix</code> function), then the processed data is summarized using the function <code>summaryFunction</code> (e.g., the largest eigenvector computed with the function <code>powerMethod</code>), and finally the global and local summaries are compared using the function <code>comparisonFunction</code> (e.g., the vector correlation with R's function <code>cor</code>). The function returns a two-column matrix which contains per row the global summary statistics (e.g., the correlation between the global and local eigenvectors) and the local summary statistics (e.g., the correlation between the local eigenvectors of the previous and current windows) for each window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fullscan(m, windows, matrixFunction, summaryFunction, comparisonFunction)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fullscan_+3A_m">m</code></td>
<td>
<p>A (sparse) matrix for which the full scan is sought. The input matrix is assumed to be oriented to contain the data for one individual per column.</p>
</td></tr>
<tr><td><code id="fullscan_+3A_windows">windows</code></td>
<td>
<p>A two-column matrix containing per column the windows on which the data is scanned. The windows can be overlapping. The windows can be computed using the function <code>makeWindows</code>.</p>
</td></tr>
<tr><td><code id="fullscan_+3A_matrixfunction">matrixFunction</code></td>
<td>
<p>Function on one matrix argument to process the data for each window (e.g., the covariance matrix).</p>
</td></tr>
<tr><td><code id="fullscan_+3A_summaryfunction">summaryFunction</code></td>
<td>
<p>Function on one argument to summarize the output of the function <code>matrixFunction</code> (e.g., the largest eigenvector).</p>
</td></tr>
<tr><td><code id="fullscan_+3A_comparisonfunction">comparisonFunction</code></td>
<td>
<p>Function on two inputs to compute a comparison measure for the output of the function <code>summaryFunction</code> (e.g., vector correlation, or matrix norm).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A two-column matrix containing per row the global and local summary statistics for each window. Plotting the correlation data of the returned matrix gives a figure analogously to the figure shown here, which was generated with the example code below.
</p>
<p><img src="../help/figures/fig.pdf" alt="fig.pdf" />
</p>


<h3>References</h3>

<p>Dmitry Prokopenko, Julian Hecker, Edwin Silverman, Marcello Pagano, Markus Noethen, Christian Dina, Christoph Lange and Heide Fier (2016). Utilizing the Jaccard index to reveal population stratification in sequencing data: a simulation study and an application to the 1000 Genomes Project. Bioinformatics, 32(9):1366-1372.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(locStra)
require(Matrix)
data(testdata)
cor2 &lt;- function(x,y) ifelse(sum(x)==0 | sum(y)==0, 0, cor(x,y))
windowSize &lt;- 10000
w &lt;- makeWindows(nrow(testdata),windowSize,windowSize)
resCov &lt;- fullscan(testdata,w,covMatrix,powerMethod,cor2)
resJac &lt;- fullscan(testdata,w,jaccardMatrix,powerMethod,cor2)
resSMx &lt;- fullscan(testdata,w,sMatrix,powerMethod,cor2)
resGRM &lt;- fullscan(testdata,w,grMatrix,powerMethod,cor2)
resAll &lt;- cbind(resCov[,1], resJac[,1], resSMx[,1], resGRM[,1])
xlabel &lt;- "SNP position"
ylabel &lt;- "correlation between global and local eigenvectors"
mainlabel &lt;- paste("window size",windowSize)
matplot(w[,1],abs(resAll),type="b",xlab=xlabel,ylab=ylabel,ylim=c(0,1),main=mainlabel)
legend("topright",legend=c("Cov","Jaccard","s-Matrix","GRM"),pch=paste(1:ncol(resAll)))

</code></pre>

<hr>
<h2 id='grMatrix'>C++ implementation to compute the genomic relationship matrix (grm) for a (sparse) input matrix as defined in Yang et al. (2011).</h2><span id='topic+grMatrix'></span>

<h3>Description</h3>

<p>C++ implementation to compute the genomic relationship matrix (grm) for a (sparse) input matrix as defined in Yang et al. (2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grMatrix(m, useCpp = TRUE, sparse = TRUE, robust = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grMatrix_+3A_m">m</code></td>
<td>
<p>A (sparse) matrix for which the genomic relationship matrix is sought. The input matrix is assumed to be oriented to contain the data for one individual per column.</p>
</td></tr>
<tr><td><code id="grMatrix_+3A_usecpp">useCpp</code></td>
<td>
<p>Flag to switch between R or C++ implementations. Default is <code>useCpp=TRUE</code>.</p>
</td></tr>
<tr><td><code id="grMatrix_+3A_sparse">sparse</code></td>
<td>
<p>Flag to switch between purpose-built dense or sparse implementations. Default is <code>sparse=TRUE</code>.</p>
</td></tr>
<tr><td><code id="grMatrix_+3A_robust">robust</code></td>
<td>
<p>Flag to indicate if the classic (<code>robust=FALSE</code>) or robust (<code>robust=TRUE</code>) version of the genomic relationship matrix is desired. Default is <code>robust=TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The genomic relationship matrix of <code>m</code>.
</p>


<h3>References</h3>

<p>Yang J, Lee SH, Goddard ME, Visscher PM (2011). GCTA: a tool for genome-wide complex trait analysis. Am J Hum Genet, 88(1):76-82.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(locStra)
require(Matrix)
m &lt;- matrix(sample(0:1,15,replace=TRUE),ncol=3)
sparseM &lt;- Matrix(m,sparse=TRUE)
print(grMatrix(sparseM))

</code></pre>

<hr>
<h2 id='jaccardMatrix'>C++ implementation to compute the Jaccard similarity matrix for a (sparse) input matrix.</h2><span id='topic+jaccardMatrix'></span>

<h3>Description</h3>

<p>C++ implementation to compute the Jaccard similarity matrix for a (sparse) input matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jaccardMatrix(m, useCpp = TRUE, sparse = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jaccardMatrix_+3A_m">m</code></td>
<td>
<p>A (sparse) matrix for which the Jaccard similarity matrix is sought. The input matrix is assumed to be oriented to contain the data for one individual per column.</p>
</td></tr>
<tr><td><code id="jaccardMatrix_+3A_usecpp">useCpp</code></td>
<td>
<p>Flag to switch between R or C++ implementations. Default is <code>useCpp=TRUE</code>.</p>
</td></tr>
<tr><td><code id="jaccardMatrix_+3A_sparse">sparse</code></td>
<td>
<p>Flag to switch between purpose-built dense or sparse implementations. Default is <code>sparse=TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Jaccard matrix of <code>m</code>.
</p>


<h3>References</h3>

<p>Dmitry Prokopenko, Julian Hecker, Edwin Silverman, Marcello Pagano, Markus Noethen, Christian Dina, Christoph Lange and Heide Fier (2016). Utilizing the Jaccard index to reveal population stratification in sequencing data: a simulation study and an application to the 1000 Genomes Project. Bioinformatics, 32(9):1366-1372.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(locStra)
require(Matrix)
m &lt;- matrix(sample(0:1,15,replace=TRUE),ncol=3)
sparseM &lt;- Matrix(m,sparse=TRUE)
print(jaccardMatrix(sparseM))

</code></pre>

<hr>
<h2 id='makeWindows'>Auxiliary function to generate a two-column matrix of windows to be used in the function 'fullscan'.</h2><span id='topic+makeWindows'></span>

<h3>Description</h3>

<p>Auxiliary function to generate a two-column matrix of windows to be used in the function 'fullscan'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeWindows(len, size, offset)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeWindows_+3A_len">len</code></td>
<td>
<p>The overall length of the data which is to be scanned in windows.</p>
</td></tr>
<tr><td><code id="makeWindows_+3A_size">size</code></td>
<td>
<p>The window size.</p>
</td></tr>
<tr><td><code id="makeWindows_+3A_offset">offset</code></td>
<td>
<p>The offset of the generated windows (e.g., if <code>offset=1</code> then sliding window, if <code>offset=size</code> then blocks).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A two-column matrix of sliding windows, with one window per row defined through start and end value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(locStra)
print(makeWindows(100,10,5))

</code></pre>

<hr>
<h2 id='powerMethod'>C++ implementation of the power method (von Mises iteration) to compute the largest eigenvector of a dense input matrix.</h2><span id='topic+powerMethod'></span>

<h3>Description</h3>

<p>C++ implementation of the power method (von Mises iteration) to compute the largest eigenvector of a dense input matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>powerMethod(m, initvector = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="powerMethod_+3A_m">m</code></td>
<td>
<p>Symmetric matrix for which the largest eigenvector is sought.</p>
</td></tr>
<tr><td><code id="powerMethod_+3A_initvector">initvector</code></td>
<td>
<p>Optional vector compatible with the input matrix which serves as a starting value for the iteration. Default is zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The largest eigenvector of <code>m</code>.
</p>


<h3>References</h3>

<p>Richard von Mises and Hilda Pollaczek-Geiringer (1929). Praktische Verfahren der Gleichungsaufloesung. ZAMM Zeitschrift fuer Angewandte Mathematik und Mechanik, 9:152-164.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(locStra)
m &lt;- matrix(1:9,3)
print(powerMethod(m))

</code></pre>

<hr>
<h2 id='selectVariants'>Auxiliary function to invert minor alleles and to select those variants/loci exceeding a minimal cutoff value.</h2><span id='topic+selectVariants'></span>

<h3>Description</h3>

<p>Auxiliary function to invert minor alleles and to select those variants/loci exceeding a minimal cutoff value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectVariants(m, phased = FALSE, invertMinorAllele = TRUE, minVariants = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectVariants_+3A_m">m</code></td>
<td>
<p>A (sparse) input matrix. The input matrix is assumed to be oriented to contain the data for one individual per column.</p>
</td></tr>
<tr><td><code id="selectVariants_+3A_phased">phased</code></td>
<td>
<p>Boolean flag to indicate if the input matrix is phased. Default is <code>phased=FALSE</code>.</p>
</td></tr>
<tr><td><code id="selectVariants_+3A_invertminorallele">invertMinorAllele</code></td>
<td>
<p>Boolean flag to indicate if the minor allele should be inverted. Default is <code>invertMinorAllele=TRUE</code>.</p>
</td></tr>
<tr><td><code id="selectVariants_+3A_minvariants">minVariants</code></td>
<td>
<p>Cutoff value for minimal number of variants for keeping a locus. Default is <code>minVariants=0</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The processed matrix with pruned variants/loci.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(locStra)
m &lt;- matrix(sample(0:1,100,replace=TRUE),ncol=10)
print(selectVariants(m))

</code></pre>

<hr>
<h2 id='sMatrix'>C++ implementation to compute the s-matrix (the weighted Jaccard similarity matrix) for a (sparse) input matrix as in the 'Stego' package: https://github.com/dschlauch/stego</h2><span id='topic+sMatrix'></span>

<h3>Description</h3>

<p>C++ implementation to compute the s-matrix (the weighted Jaccard similarity matrix) for a (sparse) input matrix as in the 'Stego' package: https://github.com/dschlauch/stego
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sMatrix(m, useCpp = TRUE, sparse = TRUE, Djac = FALSE, phased = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sMatrix_+3A_m">m</code></td>
<td>
<p>A (sparse) matrix for which the s-matrix is sought. The input matrix is assumed to be oriented to contain the data for one individual per column.</p>
</td></tr>
<tr><td><code id="sMatrix_+3A_usecpp">useCpp</code></td>
<td>
<p>Flag to switch between R or C++ implementations. Default is <code>useCpp=TRUE</code>.</p>
</td></tr>
<tr><td><code id="sMatrix_+3A_sparse">sparse</code></td>
<td>
<p>Flag to switch between purpose-built dense or sparse implementations. Default is <code>sparse=TRUE</code>.</p>
</td></tr>
<tr><td><code id="sMatrix_+3A_djac">Djac</code></td>
<td>
<p>Flag to switch between the unweighted (<code>Djac=TRUE</code>) or weighted (<code>Djac=FALSE</code>) version. Default is <code>Djac=FALSE</code>.</p>
</td></tr>
<tr><td><code id="sMatrix_+3A_phased">phased</code></td>
<td>
<p>Boolean flag to indicate if the input matrix is phased. Default is <code>phased=FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The s-matrix (the weighted Jaccard matrix) of <code>m</code>.
</p>


<h3>References</h3>

<p>Daniel Schlauch (2016). Implementation of the stego algorithm - Similarity Test for Estimating Genetic Outliers. https://github.com/dschlauch/stego
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(locStra)
require(Matrix)
m &lt;- matrix(sample(0:1,15,replace=TRUE),ncol=3)
sparseM &lt;- Matrix(m,sparse=TRUE)
print(sMatrix(sparseM))

</code></pre>

<hr>
<h2 id='testdata'>Simulated test data.</h2><span id='topic+testdata'></span>

<h3>Description</h3>

<p>An artificial dataset containing 100,000 RVs for 100 subjects (one per column). The dataset was generated by resampling the data for chromosome 1 of the 1,000 Genome Project with replacement for randomly chosen subjects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(testdata)
</code></pre>


<h3>Format</h3>

<p>A matrix with 100,000 rows and 100 columns.
</p>


<h3>References</h3>

<p>A global reference for human genetic variation, The 1000 Genomes Project Consortium, Nature 526, 68-74 (01 October 2015) doi:10.1038/nature15393.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
