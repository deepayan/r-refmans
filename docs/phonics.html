<!DOCTYPE html><html lang="en"><head><title>Help for package phonics</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {phonics}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#caverphone'><p>Caverphone</p></a></li>
<li><a href='#cologne'><p>Cologne Phonetic Name Coding</p></a></li>
<li><a href='#lein'><p>Lein Name Coding</p></a></li>
<li><a href='#metaphone'><p>Generate phonetic versions of strings with Metaphone</p></a></li>
<li><a href='#mra_encode'><p>Match Rating Approach Encoder</p></a></li>
<li><a href='#nysiis'><p>New York State Identification and Intelligence System</p></a></li>
<li><a href='#onca'><p>Oxford Name Compression Algorithm</p></a></li>
<li><a href='#phonex'><p>Phonex Name Coding</p></a></li>
<li><a href='#phonics'><p>Phonetic Spelling Algorithms</p></a></li>
<li><a href='#rogerroot'><p>Roger Root Name Coding Procedure</p></a></li>
<li><a href='#soundex'><p>Soundex</p></a></li>
<li><a href='#statcan'><p>Statistics Canada Name Coding</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Phonetic Spelling Algorithms</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.10</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-7-11</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://jameshoward.us/phonics-in-r/">https://jameshoward.us/phonics-in-r/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/k3jph/phonics-in-r/issues">https://github.com/k3jph/phonics-in-r/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a collection of phonetic algorithms including
    Soundex, Metaphone, NYSIIS, Caverphone, and others.  The package is
    documented in &lt;<a href="https://doi.org/10.18637%2Fjss.v095.i08">doi:10.18637/jss.v095.i08</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-2-Clause">BSD_2_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.1), data.table</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, markdown, rmarkdown, devtools</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, BH</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-07-11 21:16:06 UTC; howarjp1</td>
</tr>
<tr>
<td>Author:</td>
<td>James Howard <a href="https://orcid.org/0000-0003-4530-1547"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Kyle Haynes [ctb],
  Amanda Hood [ctb],
  Os Keyes [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>James Howard &lt;jh@jameshoward.us&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-07-11 21:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='caverphone'>Caverphone</h2><span id='topic+caverphone'></span>

<h3>Description</h3>

<p>The Caverphone family of phonetic algorithms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>caverphone(word, maxCodeLen = NULL, modified = FALSE, clean = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="caverphone_+3A_word">word</code></td>
<td>
<p>string or vector of strings to encode</p>
</td></tr>
<tr><td><code id="caverphone_+3A_maxcodelen">maxCodeLen</code></td>
<td>
<p>maximum length of the resulting encodings, in characters</p>
</td></tr>
<tr><td><code id="caverphone_+3A_modified">modified</code></td>
<td>
<p>if <code>TRUE</code>, use the Caverphone 2 algorithm</p>
</td></tr>
<tr><td><code id="caverphone_+3A_clean">clean</code></td>
<td>
<p>if <code>TRUE</code>, return <code>NA</code> for unknown alphabetical characters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The variable <code>maxCodeLen</code> is the limit on how long the returned
Caverphone code should be.  The default is 6, unless <code>modified</code>
is set to <code>TRUE</code>, then the default is 10.
</p>
<p>The variable <code>modified</code> directs <code>caverphone</code> to use the
Caverphone2 method, instead of the original.
</p>
<p>The <code>caverphone</code> algorithm is only defined for inputs over the
standard English alphabet, <em>i.e.</em>, &quot;A-Z.&quot;. Non-alphabetical
characters are removed from the string in a locale-dependent fashion.
This strips spaces, hyphens, and numbers.  Other letters, such as
&quot;Ü,&quot; may be permissible in the current locale but are unknown to
<code>caverphone</code>.  For inputs outside of its known range, the output is
undefined and <code>NA</code> is returned and a <code>warning</code> this thrown.
If <code>clean</code> is <code>FALSE</code>, <code>caverphone</code> attempts to process the
strings.  The default is <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>the Caverphone encoded character vector
</p>


<h3>References</h3>

<p>David Hood, &quot;Caverphone: Phonetic matching algorithm,&quot; Technical
Paper CTP060902, University of Otago, New Zealand, 2002.
</p>
<p>David Hood, &quot;Caverphone Revisited,&quot; Technical Paper CTP150804
University of Otago, New Zealand, 2004.
</p>
<p>James P. Howard, II, &quot;Phonetic Spelling Algorithm Implementations
for R,&quot; <em>Journal of Statistical Software</em>, vol. 25, no. 8,
(2020), p. 1&ndash;21, &lt;10.18637/jss.v095.i08&gt;.
</p>


<h3>See Also</h3>

<p>Other phonics: 
<code><a href="#topic+cologne">cologne</a>()</code>,
<code><a href="#topic+lein">lein</a>()</code>,
<code><a href="#topic+metaphone">metaphone</a>()</code>,
<code><a href="#topic+mra_encode">mra_encode</a>()</code>,
<code><a href="#topic+nysiis">nysiis</a>()</code>,
<code><a href="#topic+onca">onca</a>()</code>,
<code><a href="#topic+phonex">phonex</a>()</code>,
<code><a href="#topic+phonics">phonics</a>()</code>,
<code><a href="#topic+rogerroot">rogerroot</a>()</code>,
<code><a href="#topic+soundex">soundex</a>()</code>,
<code><a href="#topic+statcan">statcan</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>caverphone("William")
caverphone(c("Peter", "Peady"), modified = TRUE)
caverphone("Stevenson", maxCodeLen = 4)

</code></pre>

<hr>
<h2 id='cologne'>Cologne Phonetic Name Coding</h2><span id='topic+cologne'></span>

<h3>Description</h3>

<p>The Cologne phonetic name coding procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cologne(word, maxCodeLen = NULL, clean = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cologne_+3A_word">word</code></td>
<td>
<p>string or vector of strings to encode</p>
</td></tr>
<tr><td><code id="cologne_+3A_maxcodelen">maxCodeLen</code></td>
<td>
<p>maximum length of the resulting encodings, in characters</p>
</td></tr>
<tr><td><code id="cologne_+3A_clean">clean</code></td>
<td>
<p>if <code>TRUE</code>, return <code>NA</code> for unknown alphabetical characters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The variable <code>word</code> is the name to be encoded.  The variable
<code>maxCodeLen</code> is the limit on how long the returned name code
should be.  The default is 4.
</p>
<p>The <code>cologne</code> algorithm is only defined for inputs over the
standard English alphabet, <em>i.e.</em>, &quot;A-Z,&quot; &quot;Ä,&quot; &quot;Ö,&quot; &quot;Ü,&quot; and
&quot;ß.&quot; Non-alphabetical characters are removed from the string in a
locale-dependent fashion.  This strips spaces, hyphens, and numbers.
Other letters, such as &quot;ç,&quot; may be permissible in the current locale
but are unknown to <code>cologne</code>.  For inputs outside of its known
range, the output is undefined and <code>NA</code> is returned and a
<code>warning</code> this thrown.  If <code>clean</code> is <code>FALSE</code>,
<code>cologne</code> attempts to process the strings.  The default is
<code>TRUE</code>.
</p>


<h3>Value</h3>

<p>the Cologne encoded character vector
</p>


<h3>References</h3>

<p>James P. Howard, II, &quot;Phonetic Spelling Algorithm Implementations
for R,&quot; <em>Journal of Statistical Software</em>, vol. 25, no. 8,
(2020), p. 1&ndash;21, &lt;10.18637/jss.v095.i08&gt;.
</p>
<p>Hans Joachim Postel. &quot;Die Koelner Phonetik. Ein Verfahren zur
Identifizierung von Personennamen auf der Grundlage der
Gestaltanalyse.&quot;  <em>IBM-Nachrichten</em> 19. Jahrgang, 1969,
p. 925-931.
</p>


<h3>See Also</h3>

<p>Other phonics: 
<code><a href="#topic+caverphone">caverphone</a>()</code>,
<code><a href="#topic+lein">lein</a>()</code>,
<code><a href="#topic+metaphone">metaphone</a>()</code>,
<code><a href="#topic+mra_encode">mra_encode</a>()</code>,
<code><a href="#topic+nysiis">nysiis</a>()</code>,
<code><a href="#topic+onca">onca</a>()</code>,
<code><a href="#topic+phonex">phonex</a>()</code>,
<code><a href="#topic+phonics">phonics</a>()</code>,
<code><a href="#topic+rogerroot">rogerroot</a>()</code>,
<code><a href="#topic+soundex">soundex</a>()</code>,
<code><a href="#topic+statcan">statcan</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cologne("William")
cologne(c("Peter", "Peady"))
cologne("Stevenson", maxCodeLen = 8)

</code></pre>

<hr>
<h2 id='lein'>Lein Name Coding</h2><span id='topic+lein'></span>

<h3>Description</h3>

<p>The Lein name coding procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lein(word, maxCodeLen = 4, clean = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lein_+3A_word">word</code></td>
<td>
<p>string or vector of strings to encode</p>
</td></tr>
<tr><td><code id="lein_+3A_maxcodelen">maxCodeLen</code></td>
<td>
<p>maximum length of the resulting encodings, in characters</p>
</td></tr>
<tr><td><code id="lein_+3A_clean">clean</code></td>
<td>
<p>if <code>TRUE</code>, return <code>NA</code> for unknown alphabetical characters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The variable <code>word</code> is the name to be encoded.  The variable
<code>maxCodeLen</code> is the limit on how long the returned name code
should be.  The default is 4.
</p>
<p>The <code>lein</code> algorithm is only defined for inputs over the
standard English alphabet, <em>i.e.</em>, &quot;A-Z.&quot;. Non-alphabetical
characters are removed from the string in a locale-dependent fashion.
This strips spaces, hyphens, and numbers.  Other letters, such as
&quot;Ü,&quot; may be permissible in the current locale but are unknown to
<code>lein</code>.  For inputs outside of its known range, the output is
undefined and <code>NA</code> is returned and a <code>warning</code> this thrown.
If <code>clean</code> is <code>FALSE</code>, <code>lein</code> attempts to process the
strings.  The default is <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>the Lein encoded character vector
</p>


<h3>References</h3>

<p>James P. Howard, II, &quot;Phonetic Spelling Algorithm Implementations
for R,&quot; <em>Journal of Statistical Software</em>, vol. 25, no. 8,
(2020), p. 1&ndash;21, &lt;10.18637/jss.v095.i08&gt;.
</p>
<p>Billy T. Lynch and William L. Arends. &quot;Selection of surname coding
procedure for the SRS record linkage system.&quot; United States
Department of Agriculture, Sample Survey Research Branch, Research
Division, Washington, 1977.
</p>


<h3>See Also</h3>

<p>Other phonics: 
<code><a href="#topic+caverphone">caverphone</a>()</code>,
<code><a href="#topic+cologne">cologne</a>()</code>,
<code><a href="#topic+metaphone">metaphone</a>()</code>,
<code><a href="#topic+mra_encode">mra_encode</a>()</code>,
<code><a href="#topic+nysiis">nysiis</a>()</code>,
<code><a href="#topic+onca">onca</a>()</code>,
<code><a href="#topic+phonex">phonex</a>()</code>,
<code><a href="#topic+phonics">phonics</a>()</code>,
<code><a href="#topic+rogerroot">rogerroot</a>()</code>,
<code><a href="#topic+soundex">soundex</a>()</code>,
<code><a href="#topic+statcan">statcan</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lein("William")
lein(c("Peter", "Peady"))
lein("Stevenson", maxCodeLen = 8)

</code></pre>

<hr>
<h2 id='metaphone'>Generate phonetic versions of strings with Metaphone</h2><span id='topic+metaphone'></span>

<h3>Description</h3>

<p>The function <code>metaphone</code> phonentically encodes the
given string using the metaphone algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metaphone(word, maxCodeLen = 10L, clean = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="metaphone_+3A_word">word</code></td>
<td>
<p>string or vector of strings to encode</p>
</td></tr>
<tr><td><code id="metaphone_+3A_maxcodelen">maxCodeLen</code></td>
<td>
<p>maximum length of the resulting encodings, in characters</p>
</td></tr>
<tr><td><code id="metaphone_+3A_clean">clean</code></td>
<td>
<p>if <code>TRUE</code>, return <code>NA</code> for unknown alphabetical characters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There is some discrepency with respect to how the metaphone algorithm
actually works. For instance, there is a version in the Java Apache
Commons library.  There is a version provided within PHP. These do
not provide the same results.  On the questionable theory that the
implementation in PHP is probably more well known, this code should
match it in output.
</p>
<p>This implementation is based on a Javascript implementation which is
itself based on the PHP internal implementation.
</p>
<p>The variable <code>maxCodeLen</code> is the limit on how long the returned
metaphone should be.
</p>
<p>The <code>metaphone</code> algorithm is only defined for inputs over the
standard English alphabet, <em>i.e.</em>, &quot;A-Z.&quot;. Non-alphabetical
characters are removed from the string in a locale-dependent fashion.
This strips spaces, hyphens, and numbers.  Other letters, such as
&quot;Ü,&quot; may be permissible in the current locale but are unknown to
<code>metaphone</code>.  For inputs outside of its known range, the output
is undefined and <code>NA</code> is returned and a <code>warning</code> this
thrown.  If <code>clean</code> is <code>FALSE</code>, <code>metaphone</code> attempts
to process the strings.  The default is <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>a character vector containing the metaphones of <code>word</code>,
or an NA if the <code>word</code> value is NA
</p>


<h3>References</h3>

<p>James P. Howard, II, &quot;Phonetic Spelling Algorithm Implementations
for R,&quot; <em>Journal of Statistical Software</em>, vol. 25, no. 8,
(2020), p. 1&ndash;21, &lt;10.18637/jss.v095.i08&gt;.
</p>


<h3>See Also</h3>

<p>Other phonics: 
<code><a href="#topic+caverphone">caverphone</a>()</code>,
<code><a href="#topic+cologne">cologne</a>()</code>,
<code><a href="#topic+lein">lein</a>()</code>,
<code><a href="#topic+mra_encode">mra_encode</a>()</code>,
<code><a href="#topic+nysiis">nysiis</a>()</code>,
<code><a href="#topic+onca">onca</a>()</code>,
<code><a href="#topic+phonex">phonex</a>()</code>,
<code><a href="#topic+phonics">phonics</a>()</code>,
<code><a href="#topic+rogerroot">rogerroot</a>()</code>,
<code><a href="#topic+soundex">soundex</a>()</code>,
<code><a href="#topic+statcan">statcan</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>metaphone("wheel")
metaphone(c("school", "benji"))

</code></pre>

<hr>
<h2 id='mra_encode'>Match Rating Approach Encoder</h2><span id='topic+mra_encode'></span><span id='topic+mra_compare'></span>

<h3>Description</h3>

<p>The Western Airlines matching rating approach name encoder
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mra_encode(word, clean = TRUE)

mra_compare(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mra_encode_+3A_word">word</code></td>
<td>
<p>string or vector of strings to encode</p>
</td></tr>
<tr><td><code id="mra_encode_+3A_clean">clean</code></td>
<td>
<p>if <code>TRUE</code>, return <code>NA</code> for unknown alphabetical characters</p>
</td></tr>
<tr><td><code id="mra_encode_+3A_x">x</code></td>
<td>
<p>MRA-encoded character vector</p>
</td></tr>
<tr><td><code id="mra_encode_+3A_y">y</code></td>
<td>
<p>MRA-encoded character vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The variable <code>word</code> is the name to be encoded.  The variable
<code>maxCodeLen</code> is <em>not</em> supported in this algorithm encoder
because the algorithm itself is dependent upon its six-character
length.  The variables <code>x</code> and <code>y</code> are MRA-encoded and are
compared to each other using the MRA comparison specification.
</p>
<p>The <code>mra_encode</code> algorithm is only defined for inputs over the
standard English alphabet, <em>i.e.</em>, &quot;A-Z.&quot;. Non-alphabetical
characters are removed from the string in a locale-dependent fashion.
This strips spaces, hyphens, and numbers.  Other letters, such as
&quot;Ü,&quot; may be permissible in the current locale but are unknown to
<code>mra_encode</code>.  For inputs outside of its known range, the output is
undefined and <code>NA</code> is returned and a <code>warning</code> this thrown.
If <code>clean</code> is <code>FALSE</code>, <code>mra_encode</code> attempts to process the
strings.  The default is <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>The <code>mra_encode</code> function returns match rating approach
encoded character vector.  The <code>mra_compare</code> returns a boolean
vector which is <code>TRUE</code> if <code>x</code> and <code>y</code> pass the MRA
comparison test.
</p>


<h3>References</h3>

<p>James P. Howard, II, &quot;Phonetic Spelling Algorithm Implementations
for R,&quot; <em>Journal of Statistical Software</em>, vol. 25, no. 8,
(2020), p. 1&ndash;21, &lt;10.18637/jss.v095.i08&gt;.
</p>
<p>G.B. Moore, J.L. Kuhns, J.L. Treffzs, and C.A. Montgomery,
<em>Accessing Individual Records from Personal Data Files Using
Nonunique Identifiers,</em> US National Institute of Standards and
Technology, SP-500-2 (1977), p. 17.
</p>


<h3>See Also</h3>

<p>Other phonics: 
<code><a href="#topic+caverphone">caverphone</a>()</code>,
<code><a href="#topic+cologne">cologne</a>()</code>,
<code><a href="#topic+lein">lein</a>()</code>,
<code><a href="#topic+metaphone">metaphone</a>()</code>,
<code><a href="#topic+nysiis">nysiis</a>()</code>,
<code><a href="#topic+onca">onca</a>()</code>,
<code><a href="#topic+phonex">phonex</a>()</code>,
<code><a href="#topic+phonics">phonics</a>()</code>,
<code><a href="#topic+rogerroot">rogerroot</a>()</code>,
<code><a href="#topic+soundex">soundex</a>()</code>,
<code><a href="#topic+statcan">statcan</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mra_encode("William")
mra_encode(c("Peter", "Peady"))
mra_encode("Stevenson")
</code></pre>

<hr>
<h2 id='nysiis'>New York State Identification and Intelligence System</h2><span id='topic+nysiis'></span>

<h3>Description</h3>

<p>The NYSIIS phonetic algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nysiis(word, maxCodeLen = 6, modified = FALSE, clean = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nysiis_+3A_word">word</code></td>
<td>
<p>string or vector of strings to encode</p>
</td></tr>
<tr><td><code id="nysiis_+3A_maxcodelen">maxCodeLen</code></td>
<td>
<p>maximum length of the resulting encodings, in characters</p>
</td></tr>
<tr><td><code id="nysiis_+3A_modified">modified</code></td>
<td>
<p>if <code>TRUE</code>, use the modified NYSIIS algorithm</p>
</td></tr>
<tr><td><code id="nysiis_+3A_clean">clean</code></td>
<td>
<p>if <code>TRUE</code>, return <code>NA</code> for unknown alphabetical characters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>nysiis</code> function phentically encodes the given
string using the New York State Identification and Intelligence
System (NYSIIS) algorithm. The algorithm is based on the
implementation provided by Wikipedia and is implemented in pure R
using regular expressions.
</p>
<p>The variable <code>maxCodeLen</code> is the limit on how long the returned
NYSIIS code should be.  The default is 6.
</p>
<p>The variable <code>modified</code> directs <code>nysiis</code> to use the
modified method instead of the original.
</p>
<p>The <code>nysiis</code> algorithm is only defined for inputs over the
standard English alphabet, <em>i.e.</em>, &quot;A-Z.&quot;. Non-alphabetical
characters are removed from the string in a locale-dependent fashion.
This strips spaces, hyphens, and numbers.  Other letters, such as
&quot;Ü,&quot; may be permissible in the current locale but are unknown to
<code>nysiis</code>.  For inputs outside of its known range, the output is
undefined and <code>NA</code> is returned and a <code>warning</code> this thrown.
If <code>clean</code> is <code>FALSE</code>, <code>nysiis</code> attempts to process the
strings.  The default is <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>the NYSIIS encoded character vector
</p>


<h3>References</h3>

<p>James P. Howard, II, &quot;Phonetic Spelling Algorithm Implementations
for R,&quot; <em>Journal of Statistical Software</em>, vol. 25, no. 8,
(2020), p. 1&ndash;21, &lt;10.18637/jss.v095.i08&gt;.
</p>
<p>Robert L. Taft, <em>Name search techniques</em>, Bureau of Systems
Development, Albany, New York, 1970.
</p>


<h3>See Also</h3>

<p>Other phonics: 
<code><a href="#topic+caverphone">caverphone</a>()</code>,
<code><a href="#topic+cologne">cologne</a>()</code>,
<code><a href="#topic+lein">lein</a>()</code>,
<code><a href="#topic+metaphone">metaphone</a>()</code>,
<code><a href="#topic+mra_encode">mra_encode</a>()</code>,
<code><a href="#topic+onca">onca</a>()</code>,
<code><a href="#topic+phonex">phonex</a>()</code>,
<code><a href="#topic+phonics">phonics</a>()</code>,
<code><a href="#topic+rogerroot">rogerroot</a>()</code>,
<code><a href="#topic+soundex">soundex</a>()</code>,
<code><a href="#topic+statcan">statcan</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nysiis("Robert")
nysiis("rupert")
nysiis(c("Alabama", "Alaska"), modified = TRUE)
nysiis("mississippi", 4)

</code></pre>

<hr>
<h2 id='onca'>Oxford Name Compression Algorithm</h2><span id='topic+onca'></span>

<h3>Description</h3>

<p>The Oxford Name Compression Algorithm name coding procedure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>onca(word, maxCodeLen = 4, clean = TRUE, modified = FALSE, refined = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="onca_+3A_word">word</code></td>
<td>
<p>string or vector of strings to encode</p>
</td></tr>
<tr><td><code id="onca_+3A_maxcodelen">maxCodeLen</code></td>
<td>
<p>maximum length of the resulting encodings, in characters</p>
</td></tr>
<tr><td><code id="onca_+3A_clean">clean</code></td>
<td>
<p>if <code>TRUE</code>, return <code>NA</code> for unknown alphabetical characters</p>
</td></tr>
<tr><td><code id="onca_+3A_modified">modified</code></td>
<td>
<p>if <code>TRUE</code>, use the modified <code>nysiis</code> function</p>
</td></tr>
<tr><td><code id="onca_+3A_refined">refined</code></td>
<td>
<p>if <code>TRUE</code>, use the <code>refinedSoundex</code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The variable <code>word</code> is the name to be encoded.  The variable
<code>maxCodeLen</code> is the limit on how long the returned name code
should be.  The default is 4.
</p>
<p>The <code>onca</code> algorithm is only defined for inputs over the
standard English alphabet, <em>i.e.</em>, &quot;A-Z.&quot;. Non-alphabetical
characters are removed from the string in a locale-dependent fashion.
This strips spaces, hyphens, and numbers.  Other letters, such as
&quot;Ü,&quot; may be permissible in the current locale but are unknown to
<code>onca</code>.  For inputs outside of its known range, the output is
undefined and <code>NA</code> is returned and a <code>warning</code> this thrown.
If <code>clean</code> is <code>FALSE</code>, <code>onca</code> attempts to process the
strings.  The default is <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>the ONCA encoded character vector
</p>


<h3>References</h3>

<p>Gill, Leicester. &quot;OX-LINK: the Oxford medical record linkage system.&quot; (1997).
</p>
<p>James P. Howard, II, &quot;Phonetic Spelling Algorithm Implementations
for R,&quot; <em>Journal of Statistical Software</em>, vol. 25, no. 8,
(2020), p. 1&ndash;21, &lt;10.18637/jss.v095.i08&gt;.
</p>


<h3>See Also</h3>

<p>Other phonics: 
<code><a href="#topic+caverphone">caverphone</a>()</code>,
<code><a href="#topic+cologne">cologne</a>()</code>,
<code><a href="#topic+lein">lein</a>()</code>,
<code><a href="#topic+metaphone">metaphone</a>()</code>,
<code><a href="#topic+mra_encode">mra_encode</a>()</code>,
<code><a href="#topic+nysiis">nysiis</a>()</code>,
<code><a href="#topic+phonex">phonex</a>()</code>,
<code><a href="#topic+phonics">phonics</a>()</code>,
<code><a href="#topic+rogerroot">rogerroot</a>()</code>,
<code><a href="#topic+soundex">soundex</a>()</code>,
<code><a href="#topic+statcan">statcan</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>onca("William")
onca(c("Peter", "Peady"))
onca("Stevenson", maxCodeLen = 8)

</code></pre>

<hr>
<h2 id='phonex'>Phonex Name Coding</h2><span id='topic+phonex'></span>

<h3>Description</h3>

<p>The Phonex name coding procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phonex(word, maxCodeLen = 4, clean = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="phonex_+3A_word">word</code></td>
<td>
<p>string or vector of strings to encode</p>
</td></tr>
<tr><td><code id="phonex_+3A_maxcodelen">maxCodeLen</code></td>
<td>
<p>maximum length of the resulting encodings, in characters</p>
</td></tr>
<tr><td><code id="phonex_+3A_clean">clean</code></td>
<td>
<p>if <code>TRUE</code>, return <code>NA</code> for unknown alphabetical characters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The variable <code>word</code> is the name to be encoded.  The variable
<code>maxCodeLen</code> is the limit on how long the returned name code
should be.  The default is 4.
</p>
<p>The <code>phonex</code> algorithm is only defined for inputs over the
standard English alphabet, <em>i.e.</em>, &quot;A-Z,&quot; &quot;Ä,&quot; &quot;Ö,&quot; &quot;Ü,&quot; and
&quot;ß.&quot; Non-alphabetical characters are removed from the string in a
locale-dependent fashion.  This strips spaces, hyphens, and numbers.
Other letters, such as &quot;ç,&quot; may be permissible in the current locale
but are unknown to <code>phonex</code>.  For inputs outside of its known
range, the output is undefined and <code>NA</code> is returned and a
<code>warning</code> this thrown.  If <code>clean</code> is <code>FALSE</code>,
<code>phonex</code> attempts to process the strings.  The default is
<code>TRUE</code>.
</p>


<h3>Value</h3>

<p>the Phonex encoded character vector
</p>


<h3>References</h3>

<p>James P. Howard, II, &quot;Phonetic Spelling Algorithm Implementations
for R,&quot; <em>Journal of Statistical Software</em>, vol. 25, no. 8,
(2020), p. 1&ndash;21, &lt;10.18637/jss.v095.i08&gt;.
</p>
<p>A.J. Lait and Brian Randell. &quot;An assessment of name matching
algorithms.&quot; Technical Report Series-University of Newcastle Upon
Tyne Computing Science (1996).
</p>


<h3>See Also</h3>

<p>Other phonics: 
<code><a href="#topic+caverphone">caverphone</a>()</code>,
<code><a href="#topic+cologne">cologne</a>()</code>,
<code><a href="#topic+lein">lein</a>()</code>,
<code><a href="#topic+metaphone">metaphone</a>()</code>,
<code><a href="#topic+mra_encode">mra_encode</a>()</code>,
<code><a href="#topic+nysiis">nysiis</a>()</code>,
<code><a href="#topic+onca">onca</a>()</code>,
<code><a href="#topic+phonics">phonics</a>()</code>,
<code><a href="#topic+rogerroot">rogerroot</a>()</code>,
<code><a href="#topic+soundex">soundex</a>()</code>,
<code><a href="#topic+statcan">statcan</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phonex("William")
phonex(c("Peter", "Peady"))
phonex("Stevenson", maxCodeLen = 8)

</code></pre>

<hr>
<h2 id='phonics'>Phonetic Spelling Algorithms</h2><span id='topic+phonics'></span>

<h3>Description</h3>

<p>The <code>phonics</code> package for <code>R</code> is designed to provide a
variety of phonetic indexing algorithms in common and not-so-common
use today.  The algorithms generally reduce a string to a symbolic
representation approximating the sound made by pronouncing the
string.  They can be used to match names, strings, and as a proxy for
assorted string distance algorithms.  The algorithm reduces a string
to a symbolic representation approximating the sound.  It can be used
to match names, strings, and as a proxy for assorted string distance
algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phonics(word, method, clean = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="phonics_+3A_word">word</code></td>
<td>
<p>string or vector of strings to encode</p>
</td></tr>
<tr><td><code id="phonics_+3A_method">method</code></td>
<td>
<p>vector of method names to use</p>
</td></tr>
<tr><td><code id="phonics_+3A_clean">clean</code></td>
<td>
<p>if <code>TRUE</code>, return <code>NA</code> for unknown alphabetical characters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>phonics</code> package for <code>R</code> is designed to provide a
variety of phonetic indexing algorithms in common and not-so-common
use today.  The algorithms generally reduce a string to a symbolic
representation approximating the sound made by pronouncing the
string.  They can be used to match names, strings, and as a proxy for
assorted string distance algorithms.  The algorithm reduces a string
to a symbolic representation approximating the sound.  It can be used
to match names, strings, and as a proxy for assorted string distance
algorithms.
</p>
<p>The variable <code>word</code> is a character string or a vector of
character strings to be encoded.
</p>
<p>Different phonetic algorithm are only defined for inputs over the
limited alphabets, Non-alphabetical characters are removed from the
string in a locale-dependent fashion. This strips spaces, hyphens,
and numbers. For inputs outside of its known range, the output is
undefined and <code>NA</code> is returned and a warning this thrown. If
<code>clean</code> is <code>FALSE</code>, <code>phonics</code> attempts to process the
strings. The default is <code>TRUE</code>.
</p>
<p>The <code>method</code> parameter should be a character vector containing one or
more methods that should be used. The available list of methods is
&quot;caverphone&quot;, &quot;caverphone.modified&quot;, &quot;cologne&quot;, &quot;lein&quot;, &quot;metaphone&quot;,
&quot;nysiis&quot;, &quot;nysiis.modified&quot;, &quot;onca&quot;, &quot;onca.modified&quot;, &quot;onca.refined&quot;,
&quot;onca.modified.refined&quot;, &quot;phonex&quot;, &quot;rogerroot&quot;, &quot;soundex&quot;,
&quot;soundex.refined&quot;, and &quot;statcan&quot;.
</p>


<h3>Value</h3>

<p>Returns a data frame containing the phonetic spellings of the input
for each method applied.
</p>


<h3>References</h3>

<p>James P. Howard, II, &quot;Phonetic Spelling Algorithm Implementations
for R,&quot; <em>Journal of Statistical Software</em>, vol. 25, no. 8,
(2020), p. 1&ndash;21, &lt;10.18637/jss.v095.i08&gt;.
</p>


<h3>See Also</h3>

<p>Other phonics: 
<code><a href="#topic+caverphone">caverphone</a>()</code>,
<code><a href="#topic+cologne">cologne</a>()</code>,
<code><a href="#topic+lein">lein</a>()</code>,
<code><a href="#topic+metaphone">metaphone</a>()</code>,
<code><a href="#topic+mra_encode">mra_encode</a>()</code>,
<code><a href="#topic+nysiis">nysiis</a>()</code>,
<code><a href="#topic+onca">onca</a>()</code>,
<code><a href="#topic+phonex">phonex</a>()</code>,
<code><a href="#topic+rogerroot">rogerroot</a>()</code>,
<code><a href="#topic+soundex">soundex</a>()</code>,
<code><a href="#topic+statcan">statcan</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phonics(c("Peter", "Peady"), c("soundex", "soundex.refined"))

</code></pre>

<hr>
<h2 id='rogerroot'>Roger Root Name Coding Procedure</h2><span id='topic+rogerroot'></span>

<h3>Description</h3>

<p>Provides the Roger Root name coding system
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rogerroot(word, maxCodeLen = 5, clean = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rogerroot_+3A_word">word</code></td>
<td>
<p>string or vector of strings to encode</p>
</td></tr>
<tr><td><code id="rogerroot_+3A_maxcodelen">maxCodeLen</code></td>
<td>
<p>maximum length of the resulting encodings, in characters</p>
</td></tr>
<tr><td><code id="rogerroot_+3A_clean">clean</code></td>
<td>
<p>if <code>TRUE</code>, return <code>NA</code> for unknown alphabetical characters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>rogerroot</code> function phentically encodes the given string
using the Roger Root algorithm.  The variable <code>word</code> is a string
or vector of strings to encode.
</p>
<p>The variable <code>maxCodeLen</code> is the limit on how long the returned
code should be.  The default is 5.
</p>
<p>The <code>rogerroot</code> algorithm is only defined for inputs over the
standard English alphabet, <em>i.e.</em>, &quot;A-Z.&quot;. Non-alphabetical
characters are removed from the string in a locale-dependent fashion.
This strips spaces, hyphens, and numbers.  Other letters, such as
&quot;Ü,&quot; may be permissible in the current locale but are unknown to
<code>rogerroot</code>.  For inputs outside of its known range, the output
is undefined and <code>NA</code> is returned and a <code>warning</code> this
thrown.  If <code>clean</code> is <code>FALSE</code>, <code>rogerroot</code> attempts
to process the strings.  The default is <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>the Roger Root encoded character vector
</p>


<h3>References</h3>

<p>James P. Howard, II, &quot;Phonetic Spelling Algorithm Implementations
for R,&quot; <em>Journal of Statistical Software</em>, vol. 25, no. 8,
(2020), p. 1&ndash;21, &lt;10.18637/jss.v095.i08&gt;.
</p>
<p>Robert L. Taft, <em>Name search techniques</em>, Bureau of Systems
Development, Albany, New York, 1970.
</p>


<h3>See Also</h3>

<p>Other phonics: 
<code><a href="#topic+caverphone">caverphone</a>()</code>,
<code><a href="#topic+cologne">cologne</a>()</code>,
<code><a href="#topic+lein">lein</a>()</code>,
<code><a href="#topic+metaphone">metaphone</a>()</code>,
<code><a href="#topic+mra_encode">mra_encode</a>()</code>,
<code><a href="#topic+nysiis">nysiis</a>()</code>,
<code><a href="#topic+onca">onca</a>()</code>,
<code><a href="#topic+phonex">phonex</a>()</code>,
<code><a href="#topic+phonics">phonics</a>()</code>,
<code><a href="#topic+soundex">soundex</a>()</code>,
<code><a href="#topic+statcan">statcan</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rogerroot("William")
rogerroot(c("Peter", "Peady"))
rogerroot("Stevenson")

</code></pre>

<hr>
<h2 id='soundex'>Soundex</h2><span id='topic+soundex'></span><span id='topic+refinedSoundex'></span>

<h3>Description</h3>

<p>The Soundex phonetic algorithms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>soundex(word, maxCodeLen = 4L, clean = TRUE)

refinedSoundex(word, maxCodeLen = 10L, clean = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="soundex_+3A_word">word</code></td>
<td>
<p>string or vector of strings to encode</p>
</td></tr>
<tr><td><code id="soundex_+3A_maxcodelen">maxCodeLen</code></td>
<td>
<p>maximum length of the resulting encodings, in characters</p>
</td></tr>
<tr><td><code id="soundex_+3A_clean">clean</code></td>
<td>
<p>if <code>TRUE</code>, return <code>NA</code> for unknown alphabetical characters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>soundex</code> phonentically encodes the given
string using the soundex algorithm.  The function <code>refinedSoundex</code>
uses Apache's refined soundex algorithm.  Both implementations are loosely
based on the Apache Commons Java editons.
</p>
<p>The variable <code>maxCodeLen</code> is the limit on how long the returned
soundex should be.
</p>
<p>The <code>soundex</code> and <code>revisedSoundex</code> algorithms are only
defined for inputs over the standard English alphabet, <em>i.e.</em>,
&quot;A-Z.&quot; Non-alphabetical characters are removed from the string in a
locale-dependent fashion.  This strips spaces, hyphens, and numbers.
Other letters, such as &quot;Ü,&quot; may be permissible in the current locale
but are unknown to <code>soundex</code> and <code>revisedSoundex</code>.  For
inputs outside of its known range, the output is undefined and
<code>NA</code> is returned and a <code>warning</code> this thrown.  If
<code>clean</code> is <code>FALSE</code>, <code>soundex</code> and
<code>revisedSoundex</code> attempts to process the strings.  The default
is <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>soundex encoded character vector
</p>


<h3>Caveats</h3>

<p>The <code>soundex</code> and <code>refinedSoundex</code> algorithms are only
defined for inputs over the standard English alphabet, <em>i.e.</em>,
&quot;A-Z.&quot; For inputs outside this range, the output is undefined.
</p>


<h3>References</h3>

<p>Charles P. Bourne and Donald F. Ford, &quot;A study of methods for
systematically abbreviating English words and names,&quot; <em>Journal
of the ACM</em>, vol. 8, no. 4 (1961), p. 538-552.
</p>
<p>James P. Howard, II, &quot;Phonetic Spelling Algorithm Implementations
for R,&quot; <em>Journal of Statistical Software</em>, vol. 25, no. 8,
(2020), p. 1&ndash;21, &lt;10.18637/jss.v095.i08&gt;.
</p>
<p>Howard B. Newcombe, James M. Kennedy, &quot;Record linkage: making
maximum use of the discriminating power of identifying information,&quot;
<em>Communications of the ACM</em>, vol. 5, no. 11 (1962), p. 563-566.
</p>


<h3>See Also</h3>

<p>Other phonics: 
<code><a href="#topic+caverphone">caverphone</a>()</code>,
<code><a href="#topic+cologne">cologne</a>()</code>,
<code><a href="#topic+lein">lein</a>()</code>,
<code><a href="#topic+metaphone">metaphone</a>()</code>,
<code><a href="#topic+mra_encode">mra_encode</a>()</code>,
<code><a href="#topic+nysiis">nysiis</a>()</code>,
<code><a href="#topic+onca">onca</a>()</code>,
<code><a href="#topic+phonex">phonex</a>()</code>,
<code><a href="#topic+phonics">phonics</a>()</code>,
<code><a href="#topic+rogerroot">rogerroot</a>()</code>,
<code><a href="#topic+statcan">statcan</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>soundex("wheel")
soundex(c("school", "benji"))

</code></pre>

<hr>
<h2 id='statcan'>Statistics Canada Name Coding</h2><span id='topic+statcan'></span>

<h3>Description</h3>

<p>The modified Statistics Canada name coding procedure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>statcan(word, maxCodeLen = 4, clean = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="statcan_+3A_word">word</code></td>
<td>
<p>string or vector of strings to encode</p>
</td></tr>
<tr><td><code id="statcan_+3A_maxcodelen">maxCodeLen</code></td>
<td>
<p>maximum length of the resulting encodings, in characters</p>
</td></tr>
<tr><td><code id="statcan_+3A_clean">clean</code></td>
<td>
<p>if <code>TRUE</code>, return <code>NA</code> for unknown alphabetical characters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The variable <code>word</code> is the name to be encoded.  The variable
<code>maxCodeLen</code> is the limit on how long the returned name code
should be.  The default is 4.
</p>
<p>The <code>statcan</code> algorithm is only defined for inputs over the
standard French alphabet. Non-alphabetical characters are removed
from the string in a locale-dependent fashion.  This strips spaces,
hyphens, and numbers.  Other letters, such as &quot;Ü,&quot; may be permissible
in the current locale but are unknown to <code>statcan</code>.  For inputs
outside of its known range, the output is undefined and <code>NA</code> is
returned and a <code>warning</code> this thrown.  If <code>clean</code> is
<code>FALSE</code>, <code>statcan</code> attempts to process the strings.  The
default is <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>the Statistics Canada encoded character vector
</p>


<h3>References</h3>

<p>James P. Howard, II, &quot;Phonetic Spelling Algorithm Implementations
for R,&quot; <em>Journal of Statistical Software</em>, vol. 25, no. 8,
(2020), p. 1&ndash;21, &lt;10.18637/jss.v095.i08&gt;.
</p>
<p>Billy T. Lynch and William L. Arends. &quot;Selection of surname coding
procedure for the SRS record linkage system.&quot; United States
Department of Agriculture, Sample Survey Research Branch, Research
Division, Washington, 1977.
</p>


<h3>See Also</h3>

<p>Other phonics: 
<code><a href="#topic+caverphone">caverphone</a>()</code>,
<code><a href="#topic+cologne">cologne</a>()</code>,
<code><a href="#topic+lein">lein</a>()</code>,
<code><a href="#topic+metaphone">metaphone</a>()</code>,
<code><a href="#topic+mra_encode">mra_encode</a>()</code>,
<code><a href="#topic+nysiis">nysiis</a>()</code>,
<code><a href="#topic+onca">onca</a>()</code>,
<code><a href="#topic+phonex">phonex</a>()</code>,
<code><a href="#topic+phonics">phonics</a>()</code>,
<code><a href="#topic+rogerroot">rogerroot</a>()</code>,
<code><a href="#topic+soundex">soundex</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>statcan("William")
statcan(c("Peter", "Peady"))
statcan("Stevenson", maxCodeLen = 8)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
