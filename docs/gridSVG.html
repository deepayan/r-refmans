<!DOCTYPE html><html lang="en"><head><title>Help for package gridSVG</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gridSVG}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#animate'>

<p>Convert animation specifications to SVG elements.</p></a></li>
<li><a href='#animUnit'>
<p>Generate a set of animation values.</p></a></li>
<li><a href='#Clipping+20Paths'>
<p>Create the definition of a non-rectangular clipping path.</p></a></li>
<li><a href='#Coordinate+20Conversion+20Functions'>
<p>Functions for using an imported coordinate system</p></a></li>
<li><a href='#Coordinate+20System+20Import+2FExport'>
<p>Importing an external coordinate system</p></a></li>
<li><a href='#fe'>
<p>Creating a generic filter effect</p></a></li>
<li><a href='#feBlend'>
<p>Blend two objects together.</p></a></li>
<li><a href='#feColorMatrix'>
<p>Apply a matrix transformation on colour values.</p></a></li>
<li><a href='#feComponentTransfer'>
<p>Perform Colour Component-wise Remapping.</p></a></li>
<li><a href='#feComposite'>
<p>Combine images using Porter-Duff operations.</p></a></li>
<li><a href='#feConvolveMatrix'>
<p>Apply a matrix convolution filter effect.</p></a></li>
<li><a href='#feDiffuseLighting'>
<p>Light an image using the alpha channel as a bump map.</p></a></li>
<li><a href='#feDisplacementMap'>
<p>Displace pixel values from a filter input.</p></a></li>
<li><a href='#feDistantLight'>
<p>Create a Distant Light Source</p></a></li>
<li><a href='#feFlood'>
<p>Create and fill a rectangular region.</p></a></li>
<li><a href='#feGaussianBlur'>
<p>Apply a Gaussian blur to an image.</p></a></li>
<li><a href='#feImage'>
<p>Draw a referred image.</p></a></li>
<li><a href='#feMerge'>
<p>Composite image layers together.</p></a></li>
<li><a href='#feMorphology'>
<p>&quot;Fatten&quot; or &quot;thin&quot; artwork.</p></a></li>
<li><a href='#feOffset'>
<p>Offset an input image relative to its current position.</p></a></li>
<li><a href='#fePointLight'>
<p>Create a Point Light Source</p></a></li>
<li><a href='#feSpecularLighting'>
<p>Light an image using the alpha channel as a bump map.</p></a></li>
<li><a href='#feSpotLight'>
<p>Create a Spot Light Source</p></a></li>
<li><a href='#feTile'>
<p>Fill a rectangle with a tiled pattern of an input image.</p></a></li>
<li><a href='#feTurbulence'>
<p>Create an image using the Perlin turbulence function.</p></a></li>
<li><a href='#Filter+20Inputs'>
<p>Identifies input for a filter effect primitive.</p></a></li>
<li><a href='#filterEffect'>
<p>Creating Filter Effects</p></a></li>
<li><a href='#garnish'>

<p>Convert animation specifications to SVG elements.</p></a></li>
<li><a href='#getSVGFonts'>
<p>Manage SVG fonts</p></a></li>
<li><a href='#Gradient+20Fills'>
<p>Create a definition of a gradient fill.</p></a></li>
<li><a href='#Gradient+20Objects'>
<p>Create Linear and Radial Gradients</p></a></li>
<li><a href='#grid.animate'><p> Animate a grid grob</p></a></li>
<li><a href='#grid.clipPath'>
<p>Apply a clipping path to a grid grob.</p></a></li>
<li><a href='#grid.comment'><p> Create a grid grob representing a comment</p></a></li>
<li><a href='#grid.element'><p> Create a grid grob representing an SVG element</p></a></li>
<li><a href='#grid.export'><p> Generate SVG output from a grid graphic</p></a></li>
<li><a href='#grid.filter'>
<p>Associate a filter effect with a grid grob.</p></a></li>
<li><a href='#grid.garnish'><p> Associate arbitrary SVG attributes with a grid grob</p></a></li>
<li><a href='#grid.gradientFill'>
<p>Associate a gradient fill with a grid grob</p></a></li>
<li><a href='#grid.hyperlink'><p> Associate a hyperlink with a grid grob</p></a></li>
<li><a href='#grid.mask'>
<p>Apply an opacity mask to a grid grob.</p></a></li>
<li><a href='#grid.patternFill'><p> Associate a pattern fill with a grid grob</p></a></li>
<li><a href='#grid.script'><p> Create a grid grob containing an SVG script</p></a></li>
<li><a href='#gridsvg'>
<p>gridSVG Graphics Device</p></a></li>
<li><a href='#gridSVG.newpage'>
<p>Move to a New Page on a gridSVG Device</p></a></li>
<li><a href='#grobToDev'>

<p>Convert a grob to device calls</p></a></li>
<li><a href='#Import+20Coordinate+20JS'>
<p>Importing JavaScript coordinate information.</p></a></li>
<li><a href='#Import+20Mappings+20JS'>
<p>Importing JavaScript mapping information.</p></a></li>
<li><a href='#listSVGDefinitions'>
<p>List All Reference Definitions</p></a></li>
<li><a href='#Mapping+20Names+20to+20IDs'>
<p>Mapping Viewport, Grob and Reference Names to SVG IDs</p></a></li>
<li><a href='#Opacity+20Masks'>
<p>Create the definition of an opacity mask.</p></a></li>
<li><a href='#Pattern+20Fills'>
<p>Create a definition of a fill pattern.</p></a></li>
<li><a href='#popContext'>
<p>Leaving A Modified Viewport Context</p></a></li>
<li><a href='#primToDev'>

<p>Convert a grob to device calls</p></a></li>
<li><a href='#pushClipPath'>
<p>Apply a clipping context to the current viewport.</p></a></li>
<li><a href='#pushMask'>
<p>Apply a masking context to the current viewport.</p></a></li>
<li><a href='#registerFilter'>
<p>Create the definition a filter effect.</p></a></li>
<li><a href='#Retrieve+20Names+20Mapped+20to+20SVG+20IDs+2C+20CSS+20Selectors+20and+20XPath+20Expressions'>
<p>Retrieving Viewport, Grob, and Reference Names as SVG IDs, CSS</p>
Selectors and XPath Expressions</a></li>
<li><a href='#setSVGoptions'><p> Get and Set Global Options</p></a></li>
<li><a href='#svg-internal'><p>Internal gridSVG Functions</p></a></li>
<li><a href='#viewportCreate'>
<p>Recreate a viewport from imported coordinate information.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Export 'grid' Graphics as SVG</td>
</tr>
<tr>
<td>Version:</td>
<td>1.7-5</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to export graphics drawn with package grid to SVG
  format.  Additional functions provide access to SVG features that
  are not available in standard R graphics, such as hyperlinks, 
  animation, filters, masks, clipping paths, and gradient and pattern fills.</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, graphics, utils, methods, grid, jsonlite, XML</td>
</tr>
<tr>
<td>Suggests:</td>
<td>lattice</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-09 00:13:06 UTC; pmur002</td>
</tr>
<tr>
<td>Author:</td>
<td>Paul Murrell [cre, aut],
  Simon Potter [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Paul Murrell &lt;paul@stat.auckland.ac.nz&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-09 23:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='animate'>

Convert animation specifications to SVG elements.
</h2><span id='topic+animate'></span>

<h3>Description</h3>


<p>This function is used to generate <code>&lt;animate&gt;</code> elements
based on animation information on a grob.
It is generic so new grob classes can
write their own methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>animate(x, dev)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="animate_+3A_x">x</code></td>
<td>
<p> A grob.
</p>
</td></tr>
<tr><td><code id="animate_+3A_dev">dev</code></td>
<td>
<p>  A graphics device.
</p>
</td></tr>
</table>


<h3>Details</h3>


<p>This function is not called directly by the user.
It is exposed so that new grob classes can easily write
their own methods which call existing methods for
standard grobs.
</p>


<h3>Author(s)</h3>


<p>Paul Murrell
</p>

<hr>
<h2 id='animUnit'>
Generate a set of animation values.
</h2><span id='topic+animUnit'></span><span id='topic+animValue'></span><span id='topic+as.animUnit'></span><span id='topic+as.animValue'></span>

<h3>Description</h3>

<p>These functions can be used to generate a set of values
for use with <code>grid.animate()</code> to animate some
feature of a grob.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>animUnit(x, timeid = NULL, id = NULL)
animValue(x, timeid = NULL, id = NULL)
as.animUnit(x, ...)
as.animValue(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="animUnit_+3A_x">x</code></td>
<td>

<p>A set of animation values.  Could be a numeric vector, a character
vector, a unit vector, a matrix, a list of units.
</p>
</td></tr>
<tr><td><code id="animUnit_+3A_timeid">timeid</code></td>
<td>

<p>A vector that associates each value of <code>x</code> with a time point.
</p>
</td></tr>
<tr><td><code id="animUnit_+3A_id">id</code></td>
<td>

<p>A vector that associates each value of <code>x</code> with a different
(numeric) identifier.
</p>
</td></tr>
<tr><td><code id="animUnit_+3A_...">...</code></td>
<td>
<p> For future use. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of animation values is ultimately either a numeric or character
vector OR a unit vector.  Subsets of the animation values can be
defined per time point, or per identifier, or both.
</p>
<p>The <code>as</code> functions allow animation values to be specified as
matrices or lists, which are converted to formal animation value sets.
The <code>grid.animate()</code> function calls these functions so the
conversion typically happens automatically.
</p>
<p>These functions should only have to be called directly in relatively
complex cases where multiple values need to be specified per time
point AND per identifier.
</p>


<h3>Value</h3>

<p>An animUnit or animValue object.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grid.animate">grid.animate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(grid)

animValue(c("visible", "hidden"))
animUnit(unit(1:24, "in"),
         timeid=rep(1:3, each=8),
         id=rep(1:2, 12))
</code></pre>

<hr>
<h2 id='Clipping+20Paths'>
Create the definition of a non-rectangular clipping path.
</h2><span id='topic+clipPath'></span><span id='topic+registerClipPath'></span>

<h3>Description</h3>

<p>A feature of SVG is that elements can be clipped to by more than just
a rectangular region. Most graphical elements can be drawn. The
purpose of these functions is to define a more sophisticated clipping
path that will be applied until the current viewport (or context, see
<code><a href="#topic+popContext">popContext</a></code>) is popped.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clipPath(grob)
registerClipPath(label, clippath)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Clipping+2B20Paths_+3A_grob">grob</code></td>
<td>

<p>A grid grob.
</p>
</td></tr>
<tr><td><code id="Clipping+2B20Paths_+3A_label">label</code></td>
<td>

<p>A character identifier that will be used to reference this
definition.
</p>
</td></tr>
<tr><td><code id="Clipping+2B20Paths_+3A_clippath">clippath</code></td>
<td>

<p>A <code>clipPath</code> object produced by <code><a href="#topic+clipPath">clipPath</a></code> that
defines a clipping path region.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A clipping path will be drawn within the current viewport at the time
of definition (if the grob has no <code>vp</code> specified).
</p>
<p>Most grobs can be used for clipping but there are some limitations on
what will actually be used for clipping. In general though, anything
that is drawn as the clipping path will have the union of its drawn
regions become the new region that the current viewport (or grob) will
clip to.
</p>
<p>The limitations are as follows:
</p>

<ul>
<li><p> Any viewport pushed by the clipping path grob will no longer
clip to its contents. However, its clipping region will remain. This
means that the clipping region for a pushed viewport will become the
union of its contents and the viewport clipping region itself,
instead of just the pushed viewport's clipping region.
</p>
</li>
<li><p> When drawing a <code>textGrob</code>, only character labels will be
used, no <code>plotmath</code> expressions will be used.
</p>
</li>
<li><p> No <code>pointGrob</code>s are able to be used for clipping.
</p>
</li>
<li><p> Any operations that apply to containers (e.g. gpars,
garnishing, animation), will no longer work. Any operations that are
not applied to groups are unaffected. This affects in particular
viewports, gTrees, and the familiar gridSVG grob grouping that
occurs.
</p>
</li></ul>



<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Simon Potter
</p>


<h3>See Also</h3>

<p><code><a href="#topic+popContext">popContext</a></code>, <code><a href="#topic+grid.clipPath">grid.clipPath</a></code>,
<code><a href="#topic+pushClipPath">pushClipPath</a></code>, <code><a href="grid.html#topic+grid.clip">grid.clip</a></code>
</p>

<hr>
<h2 id='Coordinate+20Conversion+20Functions'>
Functions for using an imported coordinate system
</h2><span id='topic+viewportConvertX'></span><span id='topic+viewportConvertY'></span><span id='topic+viewportConvertPos'></span><span id='topic+viewportConvertWidth'></span><span id='topic+viewportConvertHeight'></span><span id='topic+viewportConvertDim'></span>

<h3>Description</h3>

<p>These functions convert between different units. The conversion occurs
within viewports unknown to <code>grid</code>, but imported to R via
<code><a href="#topic+gridSVGCoords">gridSVGCoords</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>viewportConvertX(vpname, x, from, to = "svg")
viewportConvertY(vpname, x, from, to = "svg")
viewportConvertPos(vpname, x, y, from, to = "svg")
viewportConvertWidth(vpname, x, from, to)
viewportConvertHeight(vpname, x, from, to)
viewportConvertDim(vpname, w, h, from, to)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Coordinate+2B20Conversion+2B20Functions_+3A_vpname">vpname</code></td>
<td>

<p>The name of the viewport that the unit belongs within.
</p>
</td></tr>
<tr><td><code id="Coordinate+2B20Conversion+2B20Functions_+3A_x">x</code>, <code id="Coordinate+2B20Conversion+2B20Functions_+3A_y">y</code>, <code id="Coordinate+2B20Conversion+2B20Functions_+3A_w">w</code>, <code id="Coordinate+2B20Conversion+2B20Functions_+3A_h">h</code></td>
<td>

<p>The size of the unit in <code>from</code> units.
</p>
</td></tr>
<tr><td><code id="Coordinate+2B20Conversion+2B20Functions_+3A_from">from</code></td>
<td>

<p>The type of unit that <code>x</code> is.
</p>
</td></tr>
<tr><td><code id="Coordinate+2B20Conversion+2B20Functions_+3A_to">to</code></td>
<td>

<p>The unit that <code>x</code> is being converted to.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Although <code>grid</code> has conversion functions available, it
only converts units relative to the current viewport. After writing
out to SVG, we no longer have actual grid viewports to convert units
within.
</p>
<p>These functions are designed so that once coordinate information is
loaded into <code>gridSVG</code> via <code><a href="#topic+gridSVGCoords">gridSVGCoords</a></code>, we can
translate units within each of these viewports. Note: this requires
that a <code>gridSVG</code> plot has had viewport information exported.
</p>
<p>These functions can be used in much the same way as <code>grid</code>'s unit
conversion functions, the only difference being that we have a new
unit, <code>svg</code>, which represents the size of a unit in SVG pixels.
</p>
<p>The <code>viewportConvertPos()</code> and <code>viewportConvertDim()</code>
functions are for use with a viewport
that has a non-zero rotation (both <code>viewportConvertX()</code> and
<code>viewportConvertY()</code> will fail in that situation
and <code>viewportConvertWidth()</code> and <code>viewportConvertHeight()</code>
will give a not very useful answer).  
</p>


<h3>Value</h3>

<p>A numeric vector containing a single value, the value of the new unit,
or a list with components <code>x</code> and <code>y</code> for
<code>viewportConvertPos()</code>, or a list with components <code>w</code>
and <code>h</code> for <code>viewportConvertDim()</code>.
</p>
<p>In the case of the <code>viewportConvertX</code> and <code>viewportConvertY</code>
functions, we always return a value that is in terms of SVG pixels.
</p>


<h3>Author(s)</h3>

<p>Simon Potter
</p>

<hr>
<h2 id='Coordinate+20System+20Import+2FExport'>
Importing an external coordinate system
</h2><span id='topic+gridSVGCoords'></span>

<h3>Description</h3>

<p>This function is both a getter and a setter function for coordinate
information imported from a plot unknown to the current R session.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gridSVGCoords(newcoords = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Coordinate+2B20System+2B20Import+2B2FExport_+3A_newcoords">newcoords</code></td>
<td>

<p>A named list (names are viewport names) of coordinate information,
produced by <code><a href="#topic+grid.export">grid.export</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to translate between SVG coordinates and the coordinate
system that <code>grid</code> understands, we first need to import the
coordinate information exported from <code><a href="#topic+grid.export">grid.export</a></code>. We can
then take the JSON representation of this coordinate information and
import it as a named list via <code>fromJSON</code>. This can then
initialise a coordinate system by passing that named list into
<code>gridSVGCoords</code>.
</p>
<p>We can supply new definitions of a viewport's coordinate system by
simply passing in an appropriate list with information for that
viewport.
</p>
<p>All viewport coordinate system information can be wiped if a single
<code>NA</code> value is passed in.
</p>


<h3>Value</h3>

<p>If <code>newcoords</code> is <code>NULL</code>, then we get back a named list
representing coordinate system information.
</p>
<p>If we pass the named list representing a coordinate system into the
function, we get no output. We also get no output if we pass in a
single <code>NA</code> value.
</p>


<h3>Author(s)</h3>

<p>Simon Potter
</p>

<hr>
<h2 id='fe'>
Creating a generic filter effect
</h2><span id='topic+fe'></span>

<h3>Description</h3>

<p>This function creates an object that contains all of the basic
attributes that each filter effect inherits from. This is not intended
to be used directly, instead it is to be used as a convenience
function for building up filter effect objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fe(...,
   x = unit(0.5, "npc"), y = unit(0.5, "npc"),
   width = unit(1, "npc"), height = unit(1, "npc"),
   just = "centre", hjust = NULL, vjust = NULL,
   default.units = "npc", result = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fe_+3A_...">...</code></td>
<td>

<p>Further attributes to add to the object.
</p>
</td></tr>
<tr><td><code id="fe_+3A_x">x</code></td>
<td>

<p>A numeric vector or unit object specifying x-location.
</p>
</td></tr>
<tr><td><code id="fe_+3A_y">y</code></td>
<td>

<p>A numeric vector or unit object specifying y-location.
</p>
</td></tr>
<tr><td><code id="fe_+3A_width">width</code></td>
<td>

<p>A numeric vector or unit object specifying width.
</p>
</td></tr>
<tr><td><code id="fe_+3A_height">height</code></td>
<td>

<p>A numeric vector or unit object specifying height.
</p>
</td></tr>
<tr><td><code id="fe_+3A_just">just</code></td>
<td>

<p>The justification of the pattern relative to its (x, y) location.
If there are two values, the first value specifies horizontal
justification and the second value specifies vertical justification.
Possible string values are: <code>"left"</code>, <code>"right"</code>,
<code>"centre"</code>, <code>"center"</code>, <code>"bottom"</code>, and <code>"top"</code>.
For numeric values, 0 means left alignment and 1 means right
alignment.
</p>
</td></tr>
<tr><td><code id="fe_+3A_hjust">hjust</code></td>
<td>

<p>A numeric vector specifying horizontal justification. If specified,
overrides the <code>just</code> setting.
</p>
</td></tr>
<tr><td><code id="fe_+3A_vjust">vjust</code></td>
<td>

<p>A numeric vector specifying vertical justification. If specified,
overrides the <code>just</code> setting.
</p>
</td></tr>
<tr><td><code id="fe_+3A_default.units">default.units</code></td>
<td>

<p>A string indicating the default units to use if <code>x</code>, <code>y</code>,
<code>width</code>, or <code>height</code> are only given as numeric vectors.
</p>
</td></tr>
<tr><td><code id="fe_+3A_result">result</code></td>
<td>

<p>A character identifier, naming the result of the filter operation.
The result can be used an an input to some filter effects.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>filter.effect</code> object.
</p>


<h3>Author(s)</h3>

<p>Simon Potter
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filterEffect">filterEffect</a></code>
</p>

<hr>
<h2 id='feBlend'>
Blend two objects together.
</h2><span id='topic+feBlend'></span>

<h3>Description</h3>

<p>This filter composites two objects together using commonly used
imaging software blending modes. It performs a pixel-wise combination
of two input images.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feBlend(input1 = NA, input2 = NA,
        mode = c("normal", "multiply", "screen", "darken", "lighten"),
        ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="feBlend_+3A_input1">input1</code></td>
<td>

<p>Identifies an input for this filter primtive. See
<code><a href="#topic+filterInputs">filterInputs</a></code>.
</p>
</td></tr>
<tr><td><code id="feBlend_+3A_input2">input2</code></td>
<td>

<p>Identfies a second input for this filter primitive. See
<code><a href="#topic+filterInputs">filterInputs</a></code>.
</p>
</td></tr>
<tr><td><code id="feBlend_+3A_mode">mode</code></td>
<td>

<p>An image blending mode.
</p>
</td></tr>
<tr><td><code id="feBlend_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed onto <code><a href="#topic+fe">fe</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more information about this primitive, consult the reference to
the SVG specification.
</p>


<h3>Value</h3>

<p>An <code>fe.blend</code> object.
</p>


<h3>Author(s)</h3>

<p>Simon Potter
</p>


<h3>References</h3>

<p><a href="https://www.w3.org/TR/SVG/filters.html#feBlendElement">https://www.w3.org/TR/SVG/filters.html#feBlendElement</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filterEffect">filterEffect</a></code>, <code><a href="#topic+fe">fe</a></code>.
</p>

<hr>
<h2 id='feColorMatrix'>
Apply a matrix transformation on colour values.
</h2><span id='topic+feColorMatrix'></span>

<h3>Description</h3>

<p>This filter applies a matrix transformation on the RGBA colour and
alpha values of every pixel on the input graphics to produce a result
with a new set of RGBA colour and alpha values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feColorMatrix(input = NA,
              type = c("matrix", "saturate",
                       "hueRotate", "luminanceToAlpha"),
              values = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="feColorMatrix_+3A_input">input</code></td>
<td>

<p>Identifies an input for this filter primtive. See
<code><a href="#topic+filterInputs">filterInputs</a></code>.
</p>
</td></tr>
<tr><td><code id="feColorMatrix_+3A_type">type</code></td>
<td>

<p>Indicates the type of matrix operation. The keyword <code>"matrix"</code>
indicates that a full 5x4 matrix of values will be provided. The
other keywords represent convenience shortcuts to allow commonly
used color operations to be performed without specifying a complete
matrix.
</p>
</td></tr>
<tr><td><code id="feColorMatrix_+3A_values">values</code></td>
<td>

<p>The contents of <code>values</code> depend on what <code>type</code> is:
</p>

<ul>
<li> <p><code>matrix</code> A 5x4 matrix of numeric values.
</p>
</li>
<li> <p><code>saturate</code> A single element numeric vector whose value
is between 0 and 1.
</p>
</li>
<li> <p><code>hueRotate</code> A single element numeric vector whose value
represents degrees.
</p>
</li>
<li> <p><code>luminanceToAlpha</code> Should be left as <code>NULL</code> as
there are no applicable values.
</p>
</li></ul>

</td></tr>
<tr><td><code id="feColorMatrix_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed onto <code><a href="#topic+fe">fe</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more information about this primitive, consult the reference to
the SVG specification.
</p>


<h3>Value</h3>

<p>An <code>fe.color.matrix</code> object.
</p>


<h3>Author(s)</h3>

<p>Simon Potter
</p>


<h3>References</h3>

<p><a href="https://www.w3.org/TR/SVG/filters.html#feColorMatrixElement">https://www.w3.org/TR/SVG/filters.html#feColorMatrixElement</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filterEffect">filterEffect</a></code>, <code><a href="#topic+fe">fe</a></code>.
</p>

<hr>
<h2 id='feComponentTransfer'>
Perform Colour Component-wise Remapping.
</h2><span id='topic+feComponentTransfer'></span><span id='topic+addComponentFunction'></span><span id='topic+transferFunction'></span>

<h3>Description</h3>

<p>This filter primitive performs component-wise remapping of data by
taking a colour transfer function, and applying that to the set of
RGBA colour components.
</p>
<p>It allows operations like brightness adjustment, contrast adjustment,
colour balance or thresholding.
</p>
<p>The calculations are performed on non-premultiplied colour values. If
the input graphics consists of premultiplied colour values, those
values are automatically converted into non-premultiplied colour
values for this operation. (Note that the undoing and redoing of the
premultiplication can be avoided if alpha transfer function is the
identity transform and all alpha values on the source graphic are set
to 1.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feComponentTransfer(input = NA, transfers = NULL, ...)
addComponentFunction(ct, channel = c("R", "G", "B", "A"), func)
transferFunction(type = c("identity", "table", "discrete",
                          "linear", "gamma"),
                 tableValues = numeric(),
                 slope = 1, intercept = 0,
                 amplitude = 1, exponent = 1, offset = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="feComponentTransfer_+3A_input">input</code></td>
<td>

<p>Identifies an input for this filter primtive. See
<code><a href="#topic+filterInputs">filterInputs</a></code>.
</p>
</td></tr>
<tr><td><code id="feComponentTransfer_+3A_transfers">transfers</code></td>
<td>

<p>A named list of <code>transfer.function</code> objects (produced by
<code><a href="#topic+transferFunction">transferFunction</a></code>). The name for each element of the
list should be one of <code>R</code>, <code>G</code>, <code>B</code> or <code>A</code>.
</p>
</td></tr>
<tr><td><code id="feComponentTransfer_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed onto <code><a href="#topic+fe">fe</a></code>.
</p>
</td></tr>
<tr><td><code id="feComponentTransfer_+3A_ct">ct</code></td>
<td>

<p>An <code>fe.component.transfer</code> object, produced by
<code><a href="#topic+feComponentTransfer">feComponentTransfer</a></code>.
</p>
</td></tr>
<tr><td><code id="feComponentTransfer_+3A_channel">channel</code></td>
<td>

<p>The colour channel that <code>func</code> will be applied to.
</p>
</td></tr>
<tr><td><code id="feComponentTransfer_+3A_func">func</code></td>
<td>

<p>A <code>transfer.function</code> object, produced by
<code><a href="#topic+transferFunction">transferFunction</a></code>.
</p>
</td></tr>
<tr><td><code id="feComponentTransfer_+3A_type">type</code></td>
<td>

<p>Indicates the type of component transfer function. The type of
function determines the applicability of the other arguments.
</p>
</td></tr>
<tr><td><code id="feComponentTransfer_+3A_tablevalues">tableValues</code></td>
<td>

<p>When <code>type</code> is <code>"table"</code>, this is a list of values which
define the lookup table.
</p>
</td></tr>
<tr><td><code id="feComponentTransfer_+3A_slope">slope</code></td>
<td>

<p>When <code>type</code> is <code>"linear"</code>, the slope of the linear
function.
</p>
</td></tr>
<tr><td><code id="feComponentTransfer_+3A_intercept">intercept</code></td>
<td>

<p>When <code>type</code> is <code>"linear"</code>, the intercept of the linear
function.
</p>
</td></tr>
<tr><td><code id="feComponentTransfer_+3A_amplitude">amplitude</code></td>
<td>

<p>When <code>type</code> is <code>"gamma"</code>, the amplitude of the gamma
function.
</p>
</td></tr>
<tr><td><code id="feComponentTransfer_+3A_exponent">exponent</code></td>
<td>

<p>When <code>type</code> is <code>"gamma"</code>, the exponent of the gamma
function.
</p>
</td></tr>
<tr><td><code id="feComponentTransfer_+3A_offset">offset</code></td>
<td>

<p>When <code>type</code> is <code>"gamma"</code>, the offset of the gamma
function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more information about this primitive, consult the references to
the SVG specification.
</p>


<h3>Value</h3>

<p>For <code>feComponentTransfer</code>, an <code>fe.component.transfer</code>
object.
</p>
<p>For <code>addComponentFunction</code>, none.
</p>
<p>For <code>transferFunction</code>, a <code>transfer.function</code> object.
</p>


<h3>Author(s)</h3>

<p>Simon Potter
</p>


<h3>References</h3>

<p><a href="https://www.w3.org/TR/SVG/filters.html#feComponentTransferElement">https://www.w3.org/TR/SVG/filters.html#feComponentTransferElement</a>,
<a href="https://www.w3.org/TR/SVG/filters.html#feFuncRElement">https://www.w3.org/TR/SVG/filters.html#feFuncRElement</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filterEffect">filterEffect</a></code>, <code><a href="#topic+fe">fe</a></code>.
</p>

<hr>
<h2 id='feComposite'>
Combine images using Porter-Duff operations.
</h2><span id='topic+feComposite'></span>

<h3>Description</h3>

<p>This filter performs the combination of the two input images
pixel-wise in image space using one of the Porter-Duff
compositing operations.
</p>
<p>The arithmetic operation is useful for combining the output from the
<code><a href="#topic+feDiffuseLighting">feDiffuseLighting</a></code> and <code><a href="#topic+feSpecularLighting">feSpecularLighting</a></code>
filter effects with texture data. It is also useful for implementing
dissolve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feComposite(input1 = NA, input2 = NA,
            operator = c("over", "in", "out", "atop",
                         "xor", "arithmetic"),
            k1 = 0, k2 = 0, k3 = 0, k4 = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="feComposite_+3A_input1">input1</code></td>
<td>

<p>Identifies an input for this filter primtive. See
<code><a href="#topic+filterInputs">filterInputs</a></code>.
</p>
</td></tr>
<tr><td><code id="feComposite_+3A_input2">input2</code></td>
<td>

<p>Identfies a second input for this filter primitive. See
<code><a href="#topic+filterInputs">filterInputs</a></code>.
</p>
</td></tr>
<tr><td><code id="feComposite_+3A_operator">operator</code></td>
<td>

<p>The compositing operation that is to be performed. All of the
<code>operator</code> types except <code>"arithmetic"</code> match the
corresponding operation as described in the referenced Porter-Duff
text. The arithmetic operator is described in the referenced SVG
specification.
</p>
</td></tr>
<tr><td><code id="feComposite_+3A_k1">k1</code></td>
<td>

<p>A numeric value. Only applicable if <code>operator</code> is
<code>"arithmetic"</code>.
</p>
</td></tr>
<tr><td><code id="feComposite_+3A_k2">k2</code></td>
<td>

<p>A numeric value. Only applicable if <code>operator</code> is
<code>"arithmetic"</code>.
</p>
</td></tr>
<tr><td><code id="feComposite_+3A_k3">k3</code></td>
<td>

<p>A numeric value. Only applicable if <code>operator</code> is
<code>"arithmetic"</code>.
</p>
</td></tr>
<tr><td><code id="feComposite_+3A_k4">k4</code></td>
<td>

<p>A numeric value. Only applicable if <code>operator</code> is
<code>"arithmetic"</code>.
</p>
</td></tr>
<tr><td><code id="feComposite_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed onto <code><a href="#topic+fe">fe</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more information about this primitive, consult the reference to
the SVG specification.
</p>


<h3>Value</h3>

<p>An <code>fe.composite</code> object.
</p>


<h3>Author(s)</h3>

<p>Simon Potter
</p>


<h3>References</h3>

<p><a href="https://www.w3.org/TR/SVG/filters.html#feCompositeElement">https://www.w3.org/TR/SVG/filters.html#feCompositeElement</a>
</p>
<p>Compositing Digital Images, T. Porter and T. Duff. SIGGRAPH '84
Conference Proceedings, Association for Computing Machinery, Volume
18, Number 3, July 1984.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filterEffect">filterEffect</a></code>, <code><a href="#topic+fe">fe</a></code>.
</p>

<hr>
<h2 id='feConvolveMatrix'>
Apply a matrix convolution filter effect.
</h2><span id='topic+feConvolveMatrix'></span>

<h3>Description</h3>

<p>A convolution combines pixels in the input image with neighbouring
pixels to produce a resulting image. A wide variety of imaging
operations can be achieved through convolutions, including blurring,
edge detection, sharpening, embossing and beveling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feConvolveMatrix(input = NA, order = 3,
                 kernelMatrix = matrix(),
                 divisor = 1, bias = 0,
                 targetX = 1, targetY = 1,
                 edgeMode = c("duplicate", "wrap", "none"),
                 kernelUnitLength = NA, preserveAlpha = FALSE,
                 ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="feConvolveMatrix_+3A_input">input</code></td>
<td>

<p>Identifies an input for this filter primtive. See
<code><a href="#topic+filterInputs">filterInputs</a></code>.
</p>
</td></tr>
<tr><td><code id="feConvolveMatrix_+3A_order">order</code></td>
<td>

<p>A numeric vector of length 1 or 2. Indicates the number of cells in
each dimension for <code>kernelMatrix</code>. The values provided must be
integers greater than zero. The first number (orderX), indicates the
number of columns in the matrix. The second number (orderY),
indicates the number of rows in the matrix. If this is a vector of
length one then the number of rows is assumed to be same as the
number of columns specified.
</p>
</td></tr>
<tr><td><code id="feConvolveMatrix_+3A_kernelmatrix">kernelMatrix</code></td>
<td>

<p>The kernel matrix for the convolution. The number of entries must
correspond with the values given by <code>order</code>.
</p>
</td></tr>
<tr><td><code id="feConvolveMatrix_+3A_divisor">divisor</code></td>
<td>

<p>After applying the <code>kernelMatrix</code> to the input image to yield a
number, that number is divided by <code>divisor</code> to yield the final
destination colour value. A divisor that is the sum of all the
matrix values tends to have an evening effect on the overall colour
intensity of the result. It is an error to specify a divisor of
zero. The default value is the sum of all values in kernelMatrix,
with the exception that if the sum is zero, then the divisor is set
to 1.
</p>
</td></tr>
<tr><td><code id="feConvolveMatrix_+3A_bias">bias</code></td>
<td>

<p>After applying the <code>kernelMatrix</code> to the input image to yield a
number and applying the <code>divisor</code>, the <code>bias</code> attribute is
added to each component. One application of <code>bias</code> is when it
is desirable to have 0.5 gray value be the zero response of the
filter. The bias property shifts the range of the filter. This
allows representation of values that would otherwise be clamped to 0
or 1.
</p>
</td></tr>
<tr><td><code id="feConvolveMatrix_+3A_targetx">targetX</code></td>
<td>

<p>Determines the positioning in X of the convolution matrix relative
to a given target pixel in the input image. The leftmost column of
the matrix is column number zero. The value must be such that:
<code class="reqn">0 &lt;= targetX &lt; orderX</code>. By default, the
convolution matrix is centered in X over each pixel of the input
image (i.e., <code class="reqn">targetX = \lfloor orderX / 2 \rfloor</code>.
</p>
</td></tr>
<tr><td><code id="feConvolveMatrix_+3A_targety">targetY</code></td>
<td>

<p>Determines the positioning in Y of the convolution matrix relative
to a given target pixel in the input image. The topmost row of the
matrix is row number zero. The value must be such that: <code class="reqn">0 &lt;=
    targetY &lt; orderY</code>. By default, the
convolution matrix is centered in Y over each pixel of the input
image (i.e., <code class="reqn">targetY = \lfloor orderY / 2 \rfloor</code>.
</p>
</td></tr>
<tr><td><code id="feConvolveMatrix_+3A_edgemode">edgeMode</code></td>
<td>

<p>Determines how to extend the input image as necessary with colour
values so that the matrix operations can be applied when the kernel
is positioned at or near the edge of the input image.
</p>

<ul>
<li> <p><code>"duplicate"</code> indicates that the input image is
extended along each of its borders as necessary by duplicating the
colour values at the given edge of the input image.
</p>
</li>
<li> <p><code>"wrap"</code> indicates that the input image is extended by
taking the colour values from the opposite edge of the image.
</p>
</li>
<li> <p><code>"none"</code> indicates that the input image is extended
with pixel values of zero for R, G, B and A.
</p>
</li></ul>

</td></tr>
<tr><td><code id="feConvolveMatrix_+3A_kernelunitlength">kernelUnitLength</code></td>
<td>

<p>The first number is the <code>dx</code> value. The second number is the
<code>dy</code> value. If the <code>dy</code> value is not specified, it
defaults to the same value as <code>dx</code>. Indicates the intended
distance in current filter units (i.e., units as determined by the
value of the filter effect container's <code>primitiveUnits</code>)
between successive columns and rows, respectively, in the
<code>kernelMatrix</code>. By specifying value(s) for
<code>kernelUnitLength</code>, the kernel becomes defined in a scalable,
abstract coordinate system. If <code>kernelUnitLength</code> is not
specified, the default value is one pixel in the offscreen bitmap,
which is a pixel-based coordinate system, and thus potentially not
scalable.
</p>
</td></tr>
<tr><td><code id="feConvolveMatrix_+3A_preservealpha">preserveAlpha</code></td>
<td>

<p>A value of <code>FALSE</code> indicates that the convolution will apply to
all channels, including the alpha channel.
</p>
<p>A value of <code>TRUE</code> indicates that the convolution will only
apply to the colour channels. In this case, the filter will
temporarily unpremultiply the colour component values, apply the
kernel, and then re-premultiply at the end.
</p>
</td></tr>
<tr><td><code id="feConvolveMatrix_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed onto <code><a href="#topic+fe">fe</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more information about this primitive, consult the reference to
the SVG specification.
</p>


<h3>Value</h3>

<p>An <code>fe.convolve.matrix</code> object.
</p>


<h3>Author(s)</h3>

<p>Simon Potter
</p>


<h3>References</h3>

<p><a href="https://www.w3.org/TR/SVG/filters.html#feConvolveMatrixElement">https://www.w3.org/TR/SVG/filters.html#feConvolveMatrixElement</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filterEffect">filterEffect</a></code>, <code><a href="#topic+fe">fe</a></code>.
</p>

<hr>
<h2 id='feDiffuseLighting'>
Light an image using the alpha channel as a bump map.
</h2><span id='topic+feDiffuseLighting'></span>

<h3>Description</h3>

<p>This filter primitive lights an image using the alpha channel as a
bump map. The resulting image is an RGBA opaque image based on the
light colour with <code>alpha = 1</code> everywhere. The lighting
calculation follows the standard diffuse component of the Phong
lighting model. The resulting image depends on the light colour, light
position and surface geometry of the input bump map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feDiffuseLighting(input = NA,
                  surfaceScale = 1, diffuseConstant = 1,
                  kernelUnitLength = NA, col = "white",
                  lightSource = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="feDiffuseLighting_+3A_input">input</code></td>
<td>

<p>Identifies an input for this filter primtive. See
<code><a href="#topic+filterInputs">filterInputs</a></code>.
</p>
</td></tr>
<tr><td><code id="feDiffuseLighting_+3A_surfacescale">surfaceScale</code></td>
<td>

<p>Scale applied to the input alpha surface.
</p>
</td></tr>
<tr><td><code id="feDiffuseLighting_+3A_diffuseconstant">diffuseConstant</code></td>
<td>

<p><code>kd</code> in the Phong lighting model. Must be non-negative.
</p>
</td></tr>
<tr><td><code id="feDiffuseLighting_+3A_kernelunitlength">kernelUnitLength</code></td>
<td>

<p>The first number is the <code>dx</code> value. The second number is the
<code>dy</code> value. If the <code>dy</code> value is not specified, it
defaults to the same value as <code>dx</code>. Indicates the intended
distance in current filter units (i.e., units as determined by the
value of parent filter container's <code>primitiveUnits</code>) for
<code>dx</code> and <code>dy</code>, respectively, in the surface normal
calculation formulas. By specifying value(s) for
<code>kernelUnitLength</code>, the kernel becomes defined in a scalable,
abstract coordinate system. If <code>kernelUnitLength</code> is not
specified, the <code>dx</code> and <code>dy</code> values should represent very
small deltas relative to a given (x,y) position, which might be
implemented in some cases as one pixel in the intermediate image
offscreen bitmap, which is a pixel-based coordinate system, and thus
potentially not scalable.
</p>
</td></tr>
<tr><td><code id="feDiffuseLighting_+3A_col">col</code></td>
<td>

<p>The colour to apply to the light from <code>lightSource</code>.
</p>
</td></tr>
<tr><td><code id="feDiffuseLighting_+3A_lightsource">lightSource</code></td>
<td>

<p>A light source object, produced by one of
<code><a href="#topic+feDistantLight">feDistantLight</a></code>, <code><a href="#topic+fePointLight">fePointLight</a></code>, or
<code><a href="#topic+feSpotLight">feSpotLight</a></code>.
</p>
</td></tr>
<tr><td><code id="feDiffuseLighting_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed onto <code><a href="#topic+fe">fe</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more information about this primitive, consult the reference to
the SVG specification.
</p>


<h3>Value</h3>

<p>An <code>fe.diffuse.lighting</code> object.
</p>


<h3>Author(s)</h3>

<p>Simon Potter
</p>


<h3>References</h3>

<p><a href="https://www.w3.org/TR/SVG/filters.html#feDiffuseLightingElement">https://www.w3.org/TR/SVG/filters.html#feDiffuseLightingElement</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filterEffect">filterEffect</a></code> <code><a href="#topic+fe">fe</a></code>,
<code><a href="#topic+feDistantLight">feDistantLight</a></code>, <code><a href="#topic+fePointLight">fePointLight</a></code>,
<code><a href="#topic+feSpotLight">feSpotLight</a></code>.
</p>

<hr>
<h2 id='feDisplacementMap'>
Displace pixel values from a filter input.
</h2><span id='topic+feDisplacementMap'></span>

<h3>Description</h3>

<p>This filter primitive uses the pixels values from the image from
<code>input2</code> to spatially displace the image from <code>input1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feDisplacementMap(input1 = NA, input2 = NA,
                  scale = 0,
                  xChannelSelector = c("A", "R", "G", "B"),
                  yChannelSelector = c("A", "R", "G", "B"),
                  ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="feDisplacementMap_+3A_input1">input1</code></td>
<td>

<p>Identifies an input for this filter primtive. See
<code><a href="#topic+filterInputs">filterInputs</a></code>.
</p>
</td></tr>
<tr><td><code id="feDisplacementMap_+3A_input2">input2</code></td>
<td>

<p>Identfies a second input for this filter primitive. See
<code><a href="#topic+filterInputs">filterInputs</a></code>.
</p>
</td></tr>
<tr><td><code id="feDisplacementMap_+3A_scale">scale</code></td>
<td>

<p>Displacement scale factor. The amount is expressed in the coordinate
system established by attribute <code>primitiveUnits</code> on the parent
filter container. When the value of <code>scale</code> is 0, this
operation has no effect on the source image.
</p>
</td></tr>
<tr><td><code id="feDisplacementMap_+3A_xchannelselector">xChannelSelector</code></td>
<td>

<p>Indicates which channel from <code>input2</code> to use to displace the
pixels in <code>input</code> along the x-axis.
</p>
</td></tr>
<tr><td><code id="feDisplacementMap_+3A_ychannelselector">yChannelSelector</code></td>
<td>

<p>Indicates which channel from <code>input2</code> to use to displace the
pixels in <code>input</code> along the y-axis.
</p>
</td></tr>
<tr><td><code id="feDisplacementMap_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed onto <code><a href="#topic+fe">fe</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more information about this primitive, consult the reference to
the SVG specification.
</p>


<h3>Value</h3>

<p>An <code>fe.displacement.map</code> object.
</p>


<h3>Author(s)</h3>

<p>Simon Potter
</p>


<h3>References</h3>

<p><a href="https://www.w3.org/TR/SVG/filters.html#feDisplacementMapElement">https://www.w3.org/TR/SVG/filters.html#feDisplacementMapElement</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filterEffect">filterEffect</a></code>, <code><a href="#topic+fe">fe</a></code>.
</p>

<hr>
<h2 id='feDistantLight'>
Create a Distant Light Source
</h2><span id='topic+feDistantLight'></span>

<h3>Description</h3>

<p>This filter primitive defines a distant light source that can be used
within a lighting filter primitive: <code><a href="#topic+feDiffuseLighting">feDiffuseLighting</a></code> or
<code><a href="#topic+feSpecularLighting">feSpecularLighting</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feDistantLight(azimuth = 0, elevation = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="feDistantLight_+3A_azimuth">azimuth</code></td>
<td>

<p>Direction angle for the light source on the x-y plane (clockwise),
in degrees from the x axis.
</p>
</td></tr>
<tr><td><code id="feDistantLight_+3A_elevation">elevation</code></td>
<td>

<p>Direction angle for the light source from the x-y plane towards the z
axis, in degrees. Note the positive z-axis points towards the viewer
of the content.
</p>
</td></tr>
<tr><td><code id="feDistantLight_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed onto <code>fe</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more information about this primitive, consult the reference to
the SVG specification.
</p>


<h3>Value</h3>

<p>An <code>fe.distant.light</code> object.
</p>


<h3>Author(s)</h3>

<p>Simon Potter
</p>


<h3>References</h3>

<p><a href="https://www.w3.org/TR/SVG/filters.html#feDistantLightElement">https://www.w3.org/TR/SVG/filters.html#feDistantLightElement</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filterEffect">filterEffect</a></code>, <code><a href="#topic+fe">fe</a></code>,
<code><a href="#topic+feDiffuseLighting">feDiffuseLighting</a></code>, <code><a href="#topic+feSpecularLighting">feSpecularLighting</a></code>.
</p>

<hr>
<h2 id='feFlood'>
Create and fill a rectangular region.
</h2><span id='topic+feFlood'></span>

<h3>Description</h3>

<p>This filter primitive creates a rectangle filled with a specified
colour. The rectangle is as large as the filter primitive subregion
established by the <code>x</code>, <code>y</code>, <code>width</code> and <code>height</code>
attributes passed onto <code><a href="#topic+fe">fe</a></code> via <code>...</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feFlood(col = "black", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="feFlood_+3A_col">col</code></td>
<td>

<p>A colour that will be used to fill the filter region.
</p>
</td></tr>
<tr><td><code id="feFlood_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed onto <code><a href="#topic+fe">fe</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more information about this primitive, consult the reference to
the SVG specification.
</p>


<h3>Value</h3>

<p>An <code>fe.flood</code> object.
</p>


<h3>Author(s)</h3>

<p>Simon Potter
</p>


<h3>References</h3>

<p><a href="https://www.w3.org/TR/SVG/filters.html#feFloodElement">https://www.w3.org/TR/SVG/filters.html#feFloodElement</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filterEffect">filterEffect</a></code>, <code><a href="#topic+fe">fe</a></code>.
</p>

<hr>
<h2 id='feGaussianBlur'>
Apply a Gaussian blur to an image.
</h2><span id='topic+feGaussianBlur'></span>

<h3>Description</h3>

<p>This filter effect primitive performs a Gaussian blur on the input
image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feGaussianBlur(input = NA, sd = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="feGaussianBlur_+3A_input">input</code></td>
<td>

<p>Identifies an input for this filter primtive. See
<code><a href="#topic+filterInputs">filterInputs</a></code>.
</p>
</td></tr>
<tr><td><code id="feGaussianBlur_+3A_sd">sd</code></td>
<td>

<p>The value of <code>sd</code> can be a numeric vector with either one or
two elements. If two numbers are provided, the first number
represents a standard deviation value along the x-axis of the
current coordinate system and the second value represents a standard
deviation in Y. If one number is provided, then that value is used
for both X and Y.
</p>
</td></tr>
<tr><td><code id="feGaussianBlur_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed onto <code><a href="#topic+fe">fe</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more information about this primitive, consult the reference to
the SVG specification.
</p>


<h3>Value</h3>

<p>An <code>fe.gaussian.blur</code> object.
</p>


<h3>Author(s)</h3>

<p>Simon Potter
</p>


<h3>References</h3>

<p><a href="https://www.w3.org/TR/SVG/filters.html#feGaussianBlurElement">https://www.w3.org/TR/SVG/filters.html#feGaussianBlurElement</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filterEffect">filterEffect</a></code>, <code><a href="#topic+fe">fe</a></code>.
</p>

<hr>
<h2 id='feImage'>
Draw a referred image.
</h2><span id='topic+feImage'></span>

<h3>Description</h3>

<p>This filter effect primitive refers to a graphic external to this
filter container, which is loaded or rendered into an RGBA raster and
becomes the result of the filter effect primitive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feImage(preserveAspectRatio = "xMidYMid meet", href = "", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="feImage_+3A_preserveaspectratio">preserveAspectRatio</code></td>
<td>

<p>See references for appropriate values and behaviour.
</p>
</td></tr>
<tr><td><code id="feImage_+3A_href">href</code></td>
<td>

<p>A <code>URL</code> reference to a stand-alone image resource such as a
JPEG, PNG or SVG file. e.g. <code>http://example.com/img.jpg</code>
</p>
</td></tr>
<tr><td><code id="feImage_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed onto <code><a href="#topic+fe">fe</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more information about this primitive, consult the reference to
the SVG specification.
</p>


<h3>Value</h3>

<p>An <code>fe.image</code> object.
</p>


<h3>Author(s)</h3>

<p>Simon Potter
</p>


<h3>References</h3>

<p><a href="https://www.w3.org/TR/SVG/filters.html#feImageElement">https://www.w3.org/TR/SVG/filters.html#feImageElement</a>
<a href="https://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute">https://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filterEffect">filterEffect</a></code>, <code><a href="#topic+fe">fe</a></code>.
</p>

<hr>
<h2 id='feMerge'>
Composite image layers together.
</h2><span id='topic+feMerge'></span><span id='topic+feMergeNode'></span><span id='topic+addMergeNode'></span>

<h3>Description</h3>

<p>This filter primitive composites input image layers on top of each
other using the &quot;over&quot; operator with &quot;input1&quot; (corresponding to the
first child merge node) on the bottom and the last specified input,
&quot;inputN&quot; (corresponding to the last child merge node), on top.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feMerge(mergeNodes = NULL, ...)
addMergeNode(fe, mergeNode, after = NA)
feMergeNode(input = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="feMerge_+3A_mergenodes">mergeNodes</code></td>
<td>

<p>A list of <code>fe.merge.node</code> objects, produced by
<code><a href="#topic+feMergeNode">feMergeNode</a></code>.
</p>
</td></tr>
<tr><td><code id="feMerge_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed onto <code><a href="#topic+fe">fe</a></code>.
</p>
</td></tr>
<tr><td><code id="feMerge_+3A_fe">fe</code></td>
<td>

<p>An <code>fe.merge</code> object, created by <code><a href="#topic+feMerge">feMerge</a></code>.
</p>
</td></tr>
<tr><td><code id="feMerge_+3A_mergenode">mergeNode</code></td>
<td>

<p>An <code>fe.merge.node</code> object, created by <code><a href="#topic+feMerge">feMerge</a></code>.
</p>
</td></tr>
<tr><td><code id="feMerge_+3A_after">after</code></td>
<td>

<p>The position to add <code>mergeNode</code> to in the list of <code>fe</code>'s
children. When <code>NA</code>, appends to the end of the list of
children.
</p>
</td></tr>
<tr><td><code id="feMerge_+3A_input">input</code></td>
<td>

<p>Identifies an input for this filter primtive. See
<code><a href="#topic+filterInputs">filterInputs</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you wish to add more merge nodes after an <code>fe.merge</code> object
has been created, use <code><a href="#topic+addMergeNode">addMergeNode</a></code> to add merge nodes to
the filter primitive.
</p>
<p>For more information about the <code>feMerge</code> primitive, consult the
reference to the SVG specification.
</p>


<h3>Value</h3>

<p>For <code>feMerge</code>, an <code>fe.merge</code> object.
</p>
<p>For <code>addMergeNode</code>, an <code>fe.merge</code> object.
</p>
<p>For <code>feMergeNode</code>, an <code>fe.merge.node</code> object.
</p>


<h3>Author(s)</h3>

<p>Simon Potter
</p>


<h3>References</h3>

<p><a href="https://www.w3.org/TR/SVG/filters.html#feMergeElement">https://www.w3.org/TR/SVG/filters.html#feMergeElement</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filterEffect">filterEffect</a></code>, <code><a href="#topic+fe">fe</a></code>.
</p>

<hr>
<h2 id='feMorphology'>
&quot;Fatten&quot; or &quot;thin&quot; artwork.
</h2><span id='topic+feMorphology'></span>

<h3>Description</h3>

<p>This filter primitive performs &quot;fattening&quot; or &quot;thinning&quot; of
artwork. It is particularly useful for fattening or thinning an alpha
channel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feMorphology(input = NA, operator = c("erode", "dilate"),
             radius = unit(0, "npc"), default.units = "npc", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="feMorphology_+3A_input">input</code></td>
<td>

<p>Identifies an input for this filter primtive. See
<code><a href="#topic+filterInputs">filterInputs</a></code>.
</p>
</td></tr>
<tr><td><code id="feMorphology_+3A_operator">operator</code></td>
<td>

<p>A keyword indicating whether to erode (i.e., thin) or dilate
(fatten) the source graphic, <code>input</code>.
</p>
</td></tr>
<tr><td><code id="feMorphology_+3A_radius">radius</code></td>
<td>

<p>The radius (or radii) for the operation. If two values are provided,
the first value represents a x-radius and the second value
represents a y-radius. If one radius is provided, then that value is
used for both xand y.
</p>
</td></tr>
<tr><td><code id="feMorphology_+3A_default.units">default.units</code></td>
<td>

<p>A string indicating the default units to use if <code>radius</code> is
only given as a numeric vector.
</p>
</td></tr>
<tr><td><code id="feMorphology_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed onto <code><a href="#topic+fe">fe</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more information about this primitive, consult the reference to
the SVG specification.
</p>


<h3>Value</h3>

<p>An <code>fe.morphology</code> object.
</p>


<h3>Author(s)</h3>

<p>Simon Potter
</p>


<h3>References</h3>

<p><a href="https://www.w3.org/TR/SVG/filters.html#feMorphologyElement">https://www.w3.org/TR/SVG/filters.html#feMorphologyElement</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filterEffect">filterEffect</a></code>, <code><a href="#topic+fe">fe</a></code>.
</p>

<hr>
<h2 id='feOffset'>
Offset an input image relative to its current position.
</h2><span id='topic+feOffset'></span>

<h3>Description</h3>

<p>This filter primitive offsets the input image relative to its current
position in the image space by the specified vector.
</p>
<p>This is important for effects like drop shadows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feOffset(input = NA,
         dx = unit(0, "npc"), dy = unit(0, "npc"),
         default.units = "npc", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="feOffset_+3A_input">input</code></td>
<td>

<p>Identifies an input for this filter primtive. See
<code><a href="#topic+filterInputs">filterInputs</a></code>.
</p>
</td></tr>
<tr><td><code id="feOffset_+3A_dx">dx</code></td>
<td>

<p>The amount to offset <code>input</code> by along the x-axis.
</p>
</td></tr>
<tr><td><code id="feOffset_+3A_dy">dy</code></td>
<td>

<p>The amount to offset <code>input</code> by along the y-axis.
</p>
</td></tr>
<tr><td><code id="feOffset_+3A_default.units">default.units</code></td>
<td>

<p>A string indicating the default units to use if <code>dx</code> or
<code>dy</code> are only given as numeric vectors.
</p>
</td></tr>
<tr><td><code id="feOffset_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed onto <code><a href="#topic+fe">fe</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more information about this primitive, consult the reference to
the SVG specification.
</p>


<h3>Value</h3>

<p>An <code>fe.offset</code> object.
</p>


<h3>Author(s)</h3>

<p>Simon Potter
</p>


<h3>References</h3>

<p><a href="https://www.w3.org/TR/SVG/filters.html#feOffsetElement">https://www.w3.org/TR/SVG/filters.html#feOffsetElement</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filterEffect">filterEffect</a></code>, <code><a href="#topic+fe">fe</a></code>.
</p>

<hr>
<h2 id='fePointLight'>
Create a Point Light Source
</h2><span id='topic+fePointLight'></span>

<h3>Description</h3>

<p>This filter primitive defines a point light source that can be used
within a lighting filter primitive: <code><a href="#topic+feDiffuseLighting">feDiffuseLighting</a></code> or
<code><a href="#topic+feSpecularLighting">feSpecularLighting</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fePointLight(z = unit(0, "npc"), default.units = "npc", zdim = "x", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fePointLight_+3A_z">z</code></td>
<td>

<p>A numeric vector or unit object specifying z-location.
</p>
</td></tr>
<tr><td><code id="fePointLight_+3A_default.units">default.units</code></td>
<td>

<p>A string indicating the default units to use if <code>z</code> if given as
a numeric vector.
</p>
</td></tr>
<tr><td><code id="fePointLight_+3A_zdim">zdim</code></td>
<td>

<p>Either <code>"x"</code> or <code>"y"</code>. Determines the dimension to which
<code>z</code> will be located relative to. This is necessary because R
graphics has no concept of a z-dimension.
</p>
</td></tr>
<tr><td><code id="fePointLight_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed onto <code>fe</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more information about this primitive, consult the reference to
the SVG specification.
</p>


<h3>Value</h3>

<p>An <code>fe.point.light</code> object.
</p>


<h3>Author(s)</h3>

<p>Simon Potter
</p>


<h3>References</h3>

<p><code>http://www.w3.org/TR/SVG/filters.html#fePointLightElement</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filterEffect">filterEffect</a></code>, <code><a href="#topic+fe">fe</a></code>,
<code><a href="#topic+feDiffuseLighting">feDiffuseLighting</a></code>, <code><a href="#topic+feSpecularLighting">feSpecularLighting</a></code>.
</p>

<hr>
<h2 id='feSpecularLighting'>
Light an image using the alpha channel as a bump map.
</h2><span id='topic+feSpecularLighting'></span>

<h3>Description</h3>

<p>This filter primitive lights a source graphic using the alpha channel
as a bump map. The resulting image is an RGBA image based on the light
colour. The lighting calculation follows the standard specular
component of the Phong lighting model. The resulting image depends on
the light colour, light position and surface geometry of the input bump
map. The result of the lighting calculation is added. The filter
primitive assumes that the viewer is at infinity in the z direction
(i.e., the unit vector in the eye direction is (0,0,1) everywhere).
</p>
<p>This filter primitive produces an image which contains the specular
reflection part of the lighting calculation. Such a map is intended to
be combined with a texture using the add term of the arithmetic method
in <code><a href="#topic+feComposite">feComposite</a></code>. Multiple light sources can be simulated
by adding several of these light maps before applying it to the
texture image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feSpecularLighting(input = NA,
                   surfaceScale = 1, specularConstant = 1,
                   specularExponent = 1, kernelUnitLength = NA,
                   col = "white", lightSource = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="feSpecularLighting_+3A_input">input</code></td>
<td>

<p>Identifies an input for this filter primtive. See
<code><a href="#topic+filterInputs">filterInputs</a></code>.
</p>
</td></tr>
<tr><td><code id="feSpecularLighting_+3A_surfacescale">surfaceScale</code></td>
<td>

<p>Scale applied to the input alpha surface.
</p>
</td></tr>
<tr><td><code id="feSpecularLighting_+3A_specularconstant">specularConstant</code></td>
<td>

<p><code>kd</code> in the Phong lighting model. Must be non-negative.
</p>
</td></tr>
<tr><td><code id="feSpecularLighting_+3A_specularexponent">specularExponent</code></td>
<td>

<p>Numeric exponent for specular term, larger is more &quot;shiny&quot;. Range
[1,128].
</p>
</td></tr>
<tr><td><code id="feSpecularLighting_+3A_kernelunitlength">kernelUnitLength</code></td>
<td>

<p>The first number is the <code>dx</code> value. The second number is the
<code>dy</code> value. If the <code>dy</code> value is not specified, it
defaults to the same value as <code>dx</code>. Indicates the intended
distance in current filter units (i.e., units as determined by the
value of parent filter container's <code>primitiveUnits</code>) for
<code>dx</code> and <code>dy</code>, respectively, in the surface normal
calculation formulas. By specifying value(s) for
<code>kernelUnitLength</code>, the kernel becomes defined in a scalable,
abstract coordinate system. If <code>kernelUnitLength</code> is not
specified, the <code>dx</code> and <code>dy</code> values should represent very
small deltas relative to a given (x,y) position, which might be
implemented in some cases as one pixel in the intermediate image
offscreen bitmap, which is a pixel-based coordinate system, and thus
potentially not scalable.
</p>
</td></tr>
<tr><td><code id="feSpecularLighting_+3A_col">col</code></td>
<td>

<p>The colour to apply to the light from <code>lightSource</code>.
</p>
</td></tr>
<tr><td><code id="feSpecularLighting_+3A_lightsource">lightSource</code></td>
<td>

<p>A light source object, produced by one of
<code><a href="#topic+feDistantLight">feDistantLight</a></code>, <code><a href="#topic+fePointLight">fePointLight</a></code>, or
<code><a href="#topic+feSpotLight">feSpotLight</a></code>.
</p>
</td></tr>
<tr><td><code id="feSpecularLighting_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed onto <code><a href="#topic+fe">fe</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more information about this primitive, consult the reference to
the SVG specification.
</p>


<h3>Value</h3>

<p>An <code>fe.specular.lighting</code> object.
</p>


<h3>Author(s)</h3>

<p>Simon Potter
</p>


<h3>References</h3>

<p><a href="https://www.w3.org/TR/SVG/filters.html#feSpecularLightingElement">https://www.w3.org/TR/SVG/filters.html#feSpecularLightingElement</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filterEffect">filterEffect</a></code> <code><a href="#topic+fe">fe</a></code>,
<code><a href="#topic+feDistantLight">feDistantLight</a></code>, <code><a href="#topic+fePointLight">fePointLight</a></code>,
<code><a href="#topic+feSpotLight">feSpotLight</a></code>.
</p>

<hr>
<h2 id='feSpotLight'>
Create a Spot Light Source
</h2><span id='topic+feSpotLight'></span>

<h3>Description</h3>

<p>This filter primitive defines a spot light source that can be used
within a lighting filter primitive: <code><a href="#topic+feDiffuseLighting">feDiffuseLighting</a></code> or
<code><a href="#topic+feSpecularLighting">feSpecularLighting</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feSpotLight(x = unit(0, "npc"), y = unit(0, "npc"), z = unit(0, "npc"),
            pointsAtX = unit(1, "npc"), pointsAtY = unit(1, "npc"),
            pointsAtZ = unit(0, "npc"), zdim = "x",
            default.units = "npc", specularExponent = 1,
            limitingConeAngle = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="feSpotLight_+3A_x">x</code></td>
<td>

<p>A numeric vector or unit object specifying the x-location of the
light source.
</p>
</td></tr>
<tr><td><code id="feSpotLight_+3A_y">y</code></td>
<td>

<p>A numeric vector or unit object specifying the y-location of the
light source.
</p>
</td></tr>
<tr><td><code id="feSpotLight_+3A_z">z</code></td>
<td>

<p>A numeric vector or unit object specifying the z-location of the
light source.
</p>
</td></tr>
<tr><td><code id="feSpotLight_+3A_pointsatx">pointsAtX</code></td>
<td>

<p>A numeric vector or unit object specifying the x-location that the
light points at.
</p>
</td></tr>
<tr><td><code id="feSpotLight_+3A_pointsaty">pointsAtY</code></td>
<td>

<p>A numeric vector or unit object specifying the y-location that the
light points at.
</p>
</td></tr>
<tr><td><code id="feSpotLight_+3A_pointsatz">pointsAtZ</code></td>
<td>

<p>A numeric vector or unit object specifying the z-location that the
light points at.
</p>
</td></tr>
<tr><td><code id="feSpotLight_+3A_zdim">zdim</code></td>
<td>

<p>Either <code>"x"</code> or <code>"y"</code>. Determines the dimension to which
<code>z</code> and <code>pointsAtZ</code> will be located relative to. This is
necessary because R graphics has no concept of a z-dimension.
</p>
</td></tr>
<tr><td><code id="feSpotLight_+3A_default.units">default.units</code></td>
<td>

<p>A string indicating the default units to use if <code>x</code>, <code>y</code>,
<code>z</code>, <code>pointsAtX</code>, <code>pointsAtY</code>, <code>pointsAtZ</code> are
only given as numeric vectors.
</p>
</td></tr>
<tr><td><code id="feSpotLight_+3A_specularexponent">specularExponent</code></td>
<td>

<p>Exponent value controlling the focus for the light source.
</p>
</td></tr>
<tr><td><code id="feSpotLight_+3A_limitingconeangle">limitingConeAngle</code></td>
<td>

<p>If <code>NA</code>, no limiting cone is applied, otherwise a limiting cone
which restricts the region where the light is projected. No light is
projected outside the cone. <code>limitingConeAngle</code> represents the
angle in degrees between the spot light axis (i.e. the axis between
the light source and the point to which it is pointing at) and the
spot light cone.
</p>
</td></tr>
<tr><td><code id="feSpotLight_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed onto <code>fe</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more information about this primitive, consult the reference to
the SVG specification.
</p>


<h3>Value</h3>

<p>An <code>fe.spot.light</code> object.
</p>


<h3>Author(s)</h3>

<p>Simon Potter
</p>


<h3>References</h3>

<p><a href="https://www.w3.org/TR/SVG/filters.html#feSpotLightElement">https://www.w3.org/TR/SVG/filters.html#feSpotLightElement</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filterEffect">filterEffect</a></code>, <code><a href="#topic+fe">fe</a></code>,
<code><a href="#topic+feDiffuseLighting">feDiffuseLighting</a></code>, <code><a href="#topic+feSpecularLighting">feSpecularLighting</a></code>.
</p>

<hr>
<h2 id='feTile'>
Fill a rectangle with a tiled pattern of an input image.
</h2><span id='topic+feTile'></span>

<h3>Description</h3>

<p>This filter primitive fills a target rectangle with a repeated, tiled
pattern of an input image. The target rectangle is as large as the
filter primitive subregion established by the <code>x</code>, <code>y</code>,
<code>width</code> and <code>height</code> arguments that are passed onto
<code><a href="#topic+fe">fe</a></code> by <code><a href="#topic+feTile">feTile</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feTile(input = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="feTile_+3A_input">input</code></td>
<td>

<p>Identifies an input for this filter primtive. See
<code><a href="#topic+filterInputs">filterInputs</a></code>.
</p>
</td></tr>
<tr><td><code id="feTile_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed onto <code><a href="#topic+fe">fe</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more information about this primitive, consult the reference to
the SVG specification.
</p>


<h3>Value</h3>

<p>An <code>fe.tile</code> object.
</p>


<h3>Author(s)</h3>

<p>Simon Potter
</p>


<h3>References</h3>

<p><a href="https://www.w3.org/TR/SVG/filters.html#feTileElement">https://www.w3.org/TR/SVG/filters.html#feTileElement</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filterEffect">filterEffect</a></code>, <code><a href="#topic+fe">fe</a></code>.
</p>

<hr>
<h2 id='feTurbulence'>
Create an image using the Perlin turbulence function.
</h2><span id='topic+feTurbulence'></span>

<h3>Description</h3>

<p>This filter primitive creates an image using the Perlin turbulence
function. It allows the synthesis of artificial textures like clouds
or marble.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feTurbulence(baseFrequency = 0, numOctaves = 1,
             seed = 1, stitchTiles = FALSE,
             type = c("turbulence", "fractalNoise"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="feTurbulence_+3A_basefrequency">baseFrequency</code></td>
<td>

<p>The base frequency (frequencies) parameter(s) for the noise
function. If a two element numeric vector is provided, the first
number represents a base frequency in the X direction and the second
value represents a base frequency in the Y direction. If one number
is provided, then that value is used for both X and Y.
</p>
</td></tr>
<tr><td><code id="feTurbulence_+3A_numoctaves">numOctaves</code></td>
<td>

<p>The <code>numOctaves</code> parameter for the noise function.
</p>
</td></tr>
<tr><td><code id="feTurbulence_+3A_seed">seed</code></td>
<td>

<p>The starting number for the pseudo random number generator.
</p>
</td></tr>
<tr><td><code id="feTurbulence_+3A_stitchtiles">stitchTiles</code></td>
<td>

<p>If <code>stitchTiles</code> is <code>FALSE</code>, no attempt it made to
achieve smooth transitions at the border of tiles which contain a
turbulence function. Sometimes the result will show clear
discontinuities at the tile borders.
</p>
<p>If <code>stitchTiles</code> is <code>TRUE</code>, then the user agent will
automatically adjust <code>baseFrequency</code>-x and
<code>baseFrequency</code>-y values such that the <code>feTurbulence</code>'s
width and height (i.e., the width and height of the current
subregion) contains an integral number of the Perlin tile width and
height for the first octave. The <code>baseFrequency</code> will be
adjusted up or down depending on which way has the smallest relative
(not absolute) change as follows: Given the frequency, calculate
<code class="reqn">lowFreq = \lfloor width * frequency \rfloor / width</code> and <code class="reqn">hiFreq = \lceil
    width*frequency \rceil
    /width</code>. If
<code class="reqn">frequency/lowFreq &lt; hiFreq/frequency</code> then use <code>lowFreq</code>, else use
<code>hiFreq</code>. While generating turbulence values, generate lattice
vectors as normal for Perlin Noise, except for those lattice points
that lie on the right or bottom edges of the active area (the size
of the resulting tile). In those cases, copy the lattice vector from
the opposite edge of the active area.
</p>
</td></tr>
<tr><td><code id="feTurbulence_+3A_type">type</code></td>
<td>

<p>Indicates whether the filter primitive should perform a noise or
turbulence function.
</p>
</td></tr>
<tr><td><code id="feTurbulence_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed onto <code><a href="#topic+fe">fe</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more information about this primitive, consult the reference to
the SVG specification.
</p>


<h3>Value</h3>

<p>An <code>fe.turbulence</code> object.
</p>


<h3>Author(s)</h3>

<p>Simon Potter
</p>


<h3>References</h3>

<p><a href="https://www.w3.org/TR/SVG/filters.html#feTurbulenceElement">https://www.w3.org/TR/SVG/filters.html#feTurbulenceElement</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filterEffect">filterEffect</a></code>, <code><a href="#topic+fe">fe</a></code>.
</p>

<hr>
<h2 id='Filter+20Inputs'>
Identifies input for a filter effect primitive.
</h2><span id='topic+filterInputs'></span>

<h3>Description</h3>

<p>How to use and identify inputs for filter effect primitives.
</p>


<h3>Filter Inputs</h3>

<p>The value chosen for a filter effect primitive can be either one of
six keywords or can be a string which matches a previous <code>result</code>
attribute value within the same filter effect container. If no value
is provided and this is the first filter effect primitive, then the
input will be <code>SourceGraphic</code>. If no value is provided and this
is a subsequent filter effect primitive, then this filter effect
primitive will use the result from the previous filter primitive as
its input.
</p>
<p>If the value for <code>result</code> appears multiple times within a given
filter container, then a reference to that result will use the closest
preceding filter primitive with the given value for the <code>result</code>
results. Forward references to results are an error and will not draw.
</p>
<p>Definitions for the seven possible options:
</p>

<ul>
<li> <p><code>SourceGraphic</code> This keyword represents the appearance of
grobs before they are being filtered. For raster effects filter
primitives, the grobs will be rasterized into an initially clear
RGBA raster in image space. Pixels left untouched by the original
graphic will be left clear. The image is specified to be rendered in
linear RGBA pixels. The alpha channel of this image captures any
anti-aliasing specified by SVG. (Since the raster is linear, the
alpha channel of this image will represent the exact percent
coverage of each pixel.)
</p>
</li>
<li> <p><code>SourceAlpha</code> This keyword represents the appearance of
grobs before they are being filtered. <code>SourceAlpha</code> has all of
the same rules as <code>SourceGraphic</code> except that only the alpha
channel is used. The input image is an RGBA image consisting of
implicitly black color values for the RGB channels, but whose alpha
channel is the same as <code>SourceGraphic</code>. If this option is used,
then some implementations might need to rasterize the graphics
elements in order to extract the alpha channel.
</p>
</li>
<li> <p><code>BackgroundImage</code> This keyword represents an image
snapshot of the canvas under the filter region at the time that the
referring grob is being filtered.
</p>
</li>
<li> <p><code>BackgroundAlpha</code> Same as <code>BackgroundImage</code> except
only the alpha channel is used.
</p>
</li>
<li> <p><code>FillPaint</code> This keyword represents the value of the
<code>fill</code> property on the grob being filtered. The
<code>FillPaint</code> image has conceptually infinite extent. Frequently
this image is opaque everywhere, but it might not be if the &quot;paint&quot;
itself has alpha, as in the case of a gradient or pattern which
itself includes transparent or semi-transparent parts.
</p>
</li>
<li> <p><code>StrokePaint</code> This keyword represents the value of the
<code>col</code> property on the grob being filtered. The
<code>StrokePaint</code> image has conceptually infinite
extent. Frequently this image is opaque everywhere, but it might not
be if the &quot;paint&quot; itself has alpha, as in the case of a gradient or
pattern which itself includes transparent or semi-transparent parts.
</p>
</li>
<li><p> The result of any filter effect operation. This is the name
that has been given to the <code>result</code> argument of a filter
primitive.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Simon Potter
</p>


<h3>References</h3>

<p><a href="https://www.w3.org/TR/SVG/filters.html#FilterPrimitiveInAttribute">https://www.w3.org/TR/SVG/filters.html#FilterPrimitiveInAttribute</a>
</p>

<hr>
<h2 id='filterEffect'>
Creating Filter Effects
</h2><span id='topic+filterEffect'></span><span id='topic+addFilterEffect'></span>

<h3>Description</h3>

<p>Create objects which describe filter effects. These objects can be
used to add filter effect primitives. They can be used to apply a
filter effect to grobs and also to define a filter effect so that it
may be used multiple times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filterEffect(feList = NULL, filterUnits = c("coords", "bbox"),
             x = unit(0.5, "npc"), y = unit(0.5, "npc"),
             width = unit(1, "npc"), height = unit(1, "npc"),
             just = "centre", hjust = NULL, vjust = NULL,
             default.units = "npc",
             primitiveUnits = c("coords", "bbox"))
addFilterEffect(filter, filterEffect, after = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filterEffect_+3A_felist">feList</code></td>
<td>

<p>A list of filter effect primitives. For example a list containing a
gaussian blur primitive created by <code><a href="#topic+feGaussianBlur">feGaussianBlur</a></code>.
</p>
</td></tr>
<tr><td><code id="filterEffect_+3A_filterunits">filterUnits</code></td>
<td>

<p>If <code>"bbox"</code>, the filter effect itself is positioned relative to
the bounding box of the referring grob. All units attempt to be
converted to equivalent &quot;npc&quot; coordinates as a reulst.
</p>
<p>If <code>"coords"</code>, uses grid coordinates to determine positioning.
</p>
</td></tr>
<tr><td><code id="filterEffect_+3A_x">x</code></td>
<td>

<p>A numeric vector or unit object specifying x-location.
</p>
</td></tr>
<tr><td><code id="filterEffect_+3A_y">y</code></td>
<td>

<p>A numeric vector or unit object specifying y-location.
</p>
</td></tr>
<tr><td><code id="filterEffect_+3A_width">width</code></td>
<td>

<p>A numeric vector or unit object specifying width.
</p>
</td></tr>
<tr><td><code id="filterEffect_+3A_height">height</code></td>
<td>

<p>A numeric vector or unit object specifying height.
</p>
</td></tr>
<tr><td><code id="filterEffect_+3A_just">just</code></td>
<td>

<p>The justification of the pattern relative to its (x, y) location.
If there are two values, the first value specifies horizontal
justification and the second value specifies vertical justification.
Possible string values are: <code>"left"</code>, <code>"right"</code>,
<code>"centre"</code>, <code>"center"</code>, <code>"bottom"</code>, and <code>"top"</code>.
For numeric values, 0 means left alignment and 1 means right
alignment.
</p>
</td></tr>
<tr><td><code id="filterEffect_+3A_hjust">hjust</code></td>
<td>

<p>A numeric vector specifying horizontal justification. If specified,
overrides the <code>just</code> setting.
</p>
</td></tr>
<tr><td><code id="filterEffect_+3A_vjust">vjust</code></td>
<td>

<p>A numeric vector specifying vertical justification. If specified,
overrides the <code>just</code> setting.
</p>
</td></tr>
<tr><td><code id="filterEffect_+3A_default.units">default.units</code></td>
<td>

<p>A string indicating the default units to use if <code>x</code>, <code>y</code>,
<code>width</code>, or <code>height</code> are only given as numeric vectors.
</p>
</td></tr>
<tr><td><code id="filterEffect_+3A_primitiveunits">primitiveUnits</code></td>
<td>

<p>If <code>"bbox"</code>, all filter effect primitives will be positioned
relative to the bounding box of the filter effect region (determined
by <code>x</code>, <code>y</code>, <code>width</code>, <code>height</code> and
<code>filterUnits</code>). All units attempt to be converted to equivalent
&quot;npc&quot; coordinates.
</p>
<p>If <code>"coords"</code>, uses grid coordinates to determine positioning.
</p>
</td></tr>
<tr><td><code id="filterEffect_+3A_filter">filter</code></td>
<td>

<p>A filter effect container object, as created by <code>filterEffect</code>.
</p>
</td></tr>
<tr><td><code id="filterEffect_+3A_filtereffect">filterEffect</code></td>
<td>

<p>A filter effect primitive object.
</p>
</td></tr>
<tr><td><code id="filterEffect_+3A_after">after</code></td>
<td>

<p>Numeric. Determines where amongst the children of <code>filter</code> that
<code>filterEffect</code> should be added. <code>NA</code> indicates that
<code>filterEffect</code> should be appended to the end of the list of
children.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is primarily a container object to hold filter effect primitives.
</p>


<h3>Value</h3>

<p>A <code>filter</code> object.
</p>


<h3>Author(s)</h3>

<p>Simon Potter
</p>


<h3>References</h3>

<p><a href="https://www.w3.org/TR/SVG/filters.html#FilterElement">https://www.w3.org/TR/SVG/filters.html#FilterElement</a>
</p>


<h3>See Also</h3>

<p>Any of the filter effect primitives (named <code>fe*</code>),
e.g. <code><a href="#topic+feGaussianBlur">feGaussianBlur</a></code>.
</p>

<hr>
<h2 id='garnish'>

Convert animation specifications to SVG elements.
</h2><span id='topic+garnish'></span>

<h3>Description</h3>


<p>This function is used to generate a list of SVG attributes
based on information on a grob.
It is generic so new grob classes can
write their own methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>garnish(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="garnish_+3A_x">x</code></td>
<td>
<p> A grob.
</p>
</td></tr>
<tr><td><code id="garnish_+3A_...">...</code></td>
<td>
<p> For future use.
</p>
</td></tr>
</table>


<h3>Details</h3>


<p>This function is not called directly by the user.
It is exposed so that new grob classes can easily write
their own methods which call existing methods for
standard grobs.
</p>


<h3>Author(s)</h3>


<p>Paul Murrell
</p>

<hr>
<h2 id='getSVGFonts'>
Manage SVG fonts
</h2><span id='topic+getSVGFonts'></span><span id='topic+setSVGFonts'></span>

<h3>Description</h3>

<p>These functions control the SVG font stacks that are used when
exporting text to SVG.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSVGFonts()
setSVGFonts(fontStacks)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getSVGFonts_+3A_fontstacks">fontStacks</code></td>
<td>
<p>A list of font stacks (typically the modified result
from <code>getSVGFonts()</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>getSVGFonts()</code> returns a list of three font stacks called
<code>serif</code>, <code>sans</code>, and <code>mono</code>.  The user can modify the
values in each stack and then reset the stacks by calling
<code>setSVGFonts()</code> (a default value will always be forced at the
end of each font stack).
</p>


<h3>Value</h3>

<p>A list (for <code>getSVGFonts()</code>).
</p>


<h3>Author(s)</h3>

<p>Simon Potter
</p>

<hr>
<h2 id='Gradient+20Fills'>
Create a definition of a gradient fill.
</h2><span id='topic+registerGradientFill'></span>

<h3>Description</h3>

<p>A feature of SVG is that elements can be filled with a gradient that
is defined somewhere in the document. The purpose of the
<code>registerGradientFill</code> function is to create a definition of a
gradient fill so that it can be referred to by grobs drawn by gridSVG.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>registerGradientFill(label, gradient)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Gradient+2B20Fills_+3A_label">label</code></td>
<td>

<p>A character identifier for a gradient fill.
</p>
</td></tr>
<tr><td><code id="Gradient+2B20Fills_+3A_gradient">gradient</code></td>
<td>

<p>A gradient object filled with gradient stops. See
<code><a href="#topic+linearGradient">linearGradient</a></code> and <code><a href="#topic+radialGradient">radialGradient</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Simon Potter
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linearGradient">linearGradient</a></code>, <code><a href="#topic+radialGradient">radialGradient</a></code>,
<code><a href="#topic+grid.gradientFill">grid.gradientFill</a></code>
</p>

<hr>
<h2 id='Gradient+20Objects'>
Create Linear and Radial Gradients
</h2><span id='topic+linearGradient'></span><span id='topic+radialGradient'></span>

<h3>Description</h3>

<p>Create objects which describe linear and radial gradients. These
objects can later be used to apply a gradient fill to grobs, and also
to define a gradient so that it may be reused multiple times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linearGradient(col = c("black", "white"),
               stops = seq(0, 1, length.out = length(col)),
               gradientUnits = c("bbox", "coords"),
               x0 = unit(0, "npc"), x1 = unit(1, "npc"),
               y0 = unit(0, "npc"), y1 = unit(1, "npc"),
               default.units = "npc",
               spreadMethod = c("pad", "reflect", "repeat"))
radialGradient(col = c("black", "white"),
               stops = seq(0, 1, length.out = length(col)),
               gradientUnits = c("bbox", "coords"),
               x = unit(0.5, "npc"), y = unit(0.5, "npc"),
               r = unit(0.5, "npc"),
               fx = unit(0.5, "npc"), fy = unit(0.5, "npc"),
               default.units = "npc",
               spreadMethod = c("pad", "reflect", "repeat"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Gradient+2B20Objects_+3A_col">col</code></td>
<td>

<p>A vector of colours used for gradient stops.
</p>
</td></tr>
<tr><td><code id="Gradient+2B20Objects_+3A_stops">stops</code></td>
<td>

<p>A numeric vector of offsets (typically between 0 and 1) to place the
the colours (<code>col</code>) at.
</p>
</td></tr>
<tr><td><code id="Gradient+2B20Objects_+3A_gradientunits">gradientUnits</code></td>
<td>

<p>If <code>"bbox"</code>, the gradient is positioned relative to the
bounding box of the referring grob. All units attempt to be
converted to equivalent &quot;npc&quot; coordinates as a result.
</p>
<p>If <code>"coords"</code>, uses grid coordinates to determine positioning.
</p>
</td></tr>
<tr><td><code id="Gradient+2B20Objects_+3A_x0">x0</code></td>
<td>

<p>Numeric or unit object indicating the starting x-location of the
linear gradient.
</p>
</td></tr>
<tr><td><code id="Gradient+2B20Objects_+3A_x1">x1</code></td>
<td>

<p>Numeric or unit object indicating the stopping x-location of the linear
gradient.
</p>
</td></tr>
<tr><td><code id="Gradient+2B20Objects_+3A_y0">y0</code></td>
<td>

<p>Numeric or unit object indicating the starting y-location of the linear
gradient.
</p>
</td></tr>
<tr><td><code id="Gradient+2B20Objects_+3A_y1">y1</code></td>
<td>

<p>Numeric or unit object indicating the stopping y-location of the linear
gradient.
</p>
</td></tr>
<tr><td><code id="Gradient+2B20Objects_+3A_x">x</code></td>
<td>

<p>Numeric or unit object indicating the x-location of the radial
gradient.
</p>
</td></tr>
<tr><td><code id="Gradient+2B20Objects_+3A_y">y</code></td>
<td>

<p>Numeric or unit object indicating the y-location of the radial
gradient.
</p>
</td></tr>
<tr><td><code id="Gradient+2B20Objects_+3A_r">r</code></td>
<td>

<p>A numeric vector or unit object specifying the radius of the radial
gradient.
</p>
</td></tr>
<tr><td><code id="Gradient+2B20Objects_+3A_fx">fx</code></td>
<td>

<p>A numeric vector or unit object specifying an x-location. Determines
the x-location of the focal point of the radial gradient.
</p>
</td></tr>
<tr><td><code id="Gradient+2B20Objects_+3A_fy">fy</code></td>
<td>

<p>A numeric vector or unit object specifying an y-location. Determines
the y-location of the focal point of the radial gradient.
</p>
</td></tr>
<tr><td><code id="Gradient+2B20Objects_+3A_default.units">default.units</code></td>
<td>

<p>A string indicating the default units to use if <code>x</code>, <code>y</code>,
<code>r</code>, <code>fx</code> or <code>fy</code> are only given as numeric vectors.
</p>
</td></tr>
<tr><td><code id="Gradient+2B20Objects_+3A_spreadmethod">spreadMethod</code></td>
<td>

<p>A character vector determining when happens when a gradient begins
or ends within its bounds. See details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When defining gradient stops via <code>col</code> and <code>stops</code>, the
order is important. Gradient stops which are defined earlier are drawn
first, with later stops being drawn over the top.
</p>
<p>For <code>spreadMethod</code> the possible values are:
</p>

<ul>
<li><p>pad
Use the terminal colors of the gradient to fill the remainder of
the target region.

</p>
</li>
<li><p>reflect
Reflect the gradient pattern start-to-end, end-to-start,
start-to-end, etc. continuously until the target region is filled.

</p>
</li>
<li><p>repeat
Repeat the gradient pattern start-to-end, start-to-end,
start-to-end, etc. continuously until the target region is filled.

</p>
</li></ul>



<h3>Value</h3>

<p>A <code>gradient</code> object.
</p>


<h3>Author(s)</h3>

<p>Simon Potter
</p>

<hr>
<h2 id='grid.animate'> Animate a grid grob </h2><span id='topic+grid.animate'></span><span id='topic+animateGrob'></span>

<h3>Description</h3>

<p>Creates an animated.grob object.
Useful in conjunction with
<code>grid.export</code>, to produce an SVG document with
animated graphical elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>animateGrob(grob, ...,
            duration=1,
            rep=FALSE, revert=FALSE,
            begin=0, interpolate="linear", group=FALSE)
grid.animate(path, ..., group=FALSE, redraw = FALSE,
             strict=FALSE, grep=FALSE, global=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grid.animate_+3A_grob">grob</code></td>
<td>
<p> A grob to add animation to. </p>
</td></tr>
<tr><td><code id="grid.animate_+3A_path">path</code></td>
<td>
<p> A grob path specifying a drawn grob. </p>
</td></tr>
<tr><td><code id="grid.animate_+3A_...">...</code></td>
<td>
<p> Arguments of the grob to animate. </p>
</td></tr>
<tr><td><code id="grid.animate_+3A_duration">duration</code></td>
<td>
<p> The duration in seconds of the animation. </p>
</td></tr>
<tr><td><code id="grid.animate_+3A_rep">rep</code></td>
<td>
<p> The number of times the animation should repeat.
<code>FALSE</code> means once, <code>TRUE</code> means indefinitely. </p>
</td></tr>
<tr><td><code id="grid.animate_+3A_revert">revert</code></td>
<td>
<p> What should happen when (if) the animation ends;
<code>TRUE</code> means revert to the first animated value,
<code>FALSE</code> means finish on the last animated value. </p>
</td></tr>
<tr><td><code id="grid.animate_+3A_begin">begin</code></td>
<td>
<p> When the animation should begin (seconds). </p>
</td></tr>
<tr><td><code id="grid.animate_+3A_interpolate">interpolate</code></td>
<td>
<p> A character value describing how animation values are
interpreted. One of <code>linear</code> or <code>discrete</code>. </p>
</td></tr>
<tr><td><code id="grid.animate_+3A_group">group</code></td>
<td>
<p> A logical indicating whether the animation values
should be applied to the overall group element in SVG or
to individual SVG elements.</p>
</td></tr>
<tr><td><code id="grid.animate_+3A_redraw">redraw</code></td>
<td>

<p>A logical value to indicate whether to redraw the grob.
</p>
</td></tr>
<tr><td><code id="grid.animate_+3A_strict">strict</code></td>
<td>

<p>A boolean indicating whether the <code>path</code> must be matched
exactly.
</p>
</td></tr>
<tr><td><code id="grid.animate_+3A_grep">grep</code></td>
<td>

<p>Whether the <code>path</code> should be treated as a regular expression.
</p>
</td></tr>
<tr><td><code id="grid.animate_+3A_global">global</code></td>
<td>

<p>A boolean indicating whether the function should affect just the
first match of the <code>path</code>, or whether all matches should be
affected.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An animated.grob object.
</p>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>See Also</h3>

 <p><code><a href="#topic+grid.export">grid.export</a></code> </p>

<hr>
<h2 id='grid.clipPath'>
Apply a clipping path to a grid grob.
</h2><span id='topic+grid.clipPath'></span><span id='topic+clipPathGrob'></span>

<h3>Description</h3>

<p>Creates a <code>pathClipped.grob</code> object which is a normal grid grob,
with a clipping path applied to it. Used in conjunction with
<code>registerClipPath</code>, to produce an SVG document containing
graphical elements with masked content.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.clipPath(path, clippath = NULL, label = NULL,
              group = TRUE, redraw = FALSE,
              strict = FALSE, grep = FALSE, global = FALSE)
clipPathGrob(x, clippath = NULL, label = NULL, group = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grid.clipPath_+3A_x">x</code></td>
<td>

<p>A grob to clip.
</p>
</td></tr>
<tr><td><code id="grid.clipPath_+3A_path">path</code></td>
<td>

<p>A grob path specifying a drawn grob.
</p>
</td></tr>
<tr><td><code id="grid.clipPath_+3A_clippath">clippath</code></td>
<td>

<p>A grob defining a clipping region.
</p>
</td></tr>
<tr><td><code id="grid.clipPath_+3A_label">label</code></td>
<td>

<p>A label that is associated with a definition of a clipping path.
This is the label used to make a clipping path definition with
<code>registerClipPath</code>.
</p>
</td></tr>
<tr><td><code id="grid.clipPath_+3A_group">group</code></td>
<td>

<p>A logical vector that indicates whether the opacity mask should be
applied to the overall parent group for the relevant SVG element, or
to individual SVG elements.
</p>
</td></tr>
<tr><td><code id="grid.clipPath_+3A_redraw">redraw</code></td>
<td>

<p>A logical value to indicate whether to redraw the grob.
</p>
</td></tr>
<tr><td><code id="grid.clipPath_+3A_strict">strict</code></td>
<td>

<p>A boolean indicating whether the <code>path</code> must be matched
exactly.
</p>
</td></tr>
<tr><td><code id="grid.clipPath_+3A_grep">grep</code></td>
<td>

<p>Whether the <code>path</code> should be treated as a regular expression.
</p>
</td></tr>
<tr><td><code id="grid.clipPath_+3A_global">global</code></td>
<td>

<p>A boolean indicating whether the function should affect just the
first match of the <code>path</code>, or whether all matches should be
affected.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>label</code> is specified, uses a clipping path that has been
supplied to <code>registerClipPath</code>. If <code>clippath</code> is specified
it will be used as the clipping path applied to each grob. If both are
specified, it will attempt to define the clipping path with the given
label, as well as applying the clipping path to the appropriate grobs.
</p>


<h3>Value</h3>

<p>A <code>pathClipped.grob</code> object (for <code>clipPathGrob</code>).
</p>


<h3>Author(s)</h3>

<p>Simon Potter
</p>


<h3>See Also</h3>

<p><code><a href="#topic+registerClipPath">registerClipPath</a></code>, <code><a href="#topic+pushClipPath">pushClipPath</a></code>.
</p>

<hr>
<h2 id='grid.comment'> Create a grid grob representing a comment </h2><span id='topic+grid.comment'></span><span id='topic+commentGrob'></span>

<h3>Description</h3>

<p>Creates a <code>comment.grob</code> object which is a grid
<code><a href="grid.html#topic+nullGrob">nullGrob</a></code>, with a comment attached. Useful in conjunction
with <code>grid.export</code>, to produce an SVG document with comments
inserted at the point where the grob is &ldquo;drawn&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.comment(comment, name = NULL, vp = NULL)
commentGrob(comment, name = NULL, vp = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grid.comment_+3A_comment">comment</code></td>
<td>

<p>A character vector used to write out a comment. If this has a length
greater than one, each element is assumed to be a line.
</p>
</td></tr>
<tr><td><code id="grid.comment_+3A_name">name</code></td>
<td>
<p> A character identifier. </p>
</td></tr>
<tr><td><code id="grid.comment_+3A_vp">vp</code></td>
<td>
<p> The viewport to which the grob belongs. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>comment.grob</code> object.
</p>


<h3>Author(s)</h3>

<p> Simon Potter </p>


<h3>See Also</h3>

 <p><code><a href="#topic+grid.export">grid.export</a></code> </p>

<hr>
<h2 id='grid.element'> Create a grid grob representing an SVG element </h2><span id='topic+grid.element'></span><span id='topic+elementGrob'></span><span id='topic+grid.textNode'></span><span id='topic+textNodeGrob'></span>

<h3>Description</h3>

<p>Creates a <code>element.grob</code> object which is a grid
<code><a href="grid.html#topic+gTree">gTree</a></code>, representing an SVG element. Useful in
conjunction with <code>grid.export</code>, to produce an SVG document with
elements inserted at particular points. The element (and its children)
are inserted at the point where the grob is &ldquo;drawn&rdquo;. Text can
be inserted in a similar manner with <code>grid.textNode</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.element(el, name = NULL, attrs = NULL,
             namespace = NULL, namespaceDefinitions = NULL,
             children = NULL, vp = NULL,
             childrenvp = NULL, asis = FALSE)
elementGrob(el, name = NULL, attrs = NULL,
            namespace = NULL, namespaceDefinitions = NULL,
            children = NULL, vp = NULL,
            childrenvp = NULL, asis = FALSE)
grid.textNode(text, name = NULL, vp = NULL)
textNodeGrob(text, name = NULL, vp = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grid.element_+3A_el">el</code></td>
<td>

<p>The name of the SVG element to create, e.g. &quot;rect&quot;.
</p>
</td></tr>
<tr><td><code id="grid.element_+3A_text">text</code></td>
<td>

<p>A single element character vector of text directly into insert into
the SVG image.
</p>
</td></tr>
<tr><td><code id="grid.element_+3A_name">name</code></td>
<td>

<p>A character identifier.
</p>
</td></tr>
<tr><td><code id="grid.element_+3A_attrs">attrs</code></td>
<td>

<p>A list, where the names are SVG attribute names, and values are the
values given to the SVG attributes.
</p>
</td></tr>
<tr><td><code id="grid.element_+3A_namespace">namespace</code></td>
<td>

<p>A character vector specifying the namespace for this new element.
</p>
</td></tr>
<tr><td><code id="grid.element_+3A_namespacedefinitions">namespaceDefinitions</code></td>
<td>

<p>A character vector or a list with each element being a string.
</p>
<p>These give the URIs identifying the namespaces uniquely. The
elements should have names which are used as prefixes. A default
namespace has &quot;&quot; as the name. The values here are used only for
defining new namespaces and not for determining the namespace to use
for this particular element.
</p>
</td></tr>
<tr><td><code id="grid.element_+3A_children">children</code></td>
<td>

<p>A gList object containing children of this element (if any).
</p>
</td></tr>
<tr><td><code id="grid.element_+3A_vp">vp</code></td>
<td>
<p> A viewport object to draw within. </p>
</td></tr>
<tr><td><code id="grid.element_+3A_childrenvp">childrenvp</code></td>
<td>

<p>A viewport object to use for the children of the element grob.
</p>
</td></tr>
<tr><td><code id="grid.element_+3A_asis">asis</code></td>
<td>

<p>If <code>TRUE</code>, SVG id attributes will be generated from the
<code>name</code> with no modification so that we can easily refer to the
generated elements.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>element.grob</code> object. For <code>grid.textNode</code> a
<code>textnode.grob</code> object.
</p>


<h3>Author(s)</h3>

<p> Simon Potter </p>


<h3>See Also</h3>

 <p><code><a href="#topic+grid.export">grid.export</a></code> </p>

<hr>
<h2 id='grid.export'> Generate SVG output from a grid graphic </h2><span id='topic+grid.export'></span><span id='topic+gridToSVG'></span>

<h3>Description</h3>

<p>Produces an SVG version of the current grid page.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.export(name = "Rplots.svg",
            exportCoords = c("none", "inline", "file"),
            exportMappings = c("none", "inline", "file"),
            exportJS = c("none", "inline", "file"),
            res = NULL,
            prefix = "",
            addClasses = FALSE,
            indent = TRUE,
            htmlWrapper = FALSE,
            usePaths = c("vpPaths", "gPaths", "none", "both"),
            uniqueNames = TRUE,
            annotate = TRUE,
            progress = FALSE,
            compression = 0,
            strict = TRUE,
            rootAttrs = NULL,
            xmldecl = xmlDecl())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grid.export_+3A_name">name</code></td>
<td>

<p>The name of the SVG file to produce.
</p>
<p>If this parameter is <code>NULL</code> or <code>""</code>, a list
containing the SVG document, coordinate information, and JavaScript
utility functions are returned.
</p>
</td></tr>
<tr><td><code id="grid.export_+3A_exportcoords">exportCoords</code></td>
<td>

<p>If this parameter is not <code>none</code> a coordinates file is exported.
</p>
<p>If this parameter is <code>file</code>, the coordinates information is
written to a file, while <code>inline</code> will include the contents
within the SVG document.
</p>
</td></tr>
<tr><td><code id="grid.export_+3A_exportmappings">exportMappings</code></td>
<td>

<p>If this parameter is not <code>none</code> a mapping file is exported.
</p>
<p>If this parameter is <code>file</code>, the mapping information is written
to a file, while <code>inline</code> will include the contents within the
SVG document.
</p>
</td></tr>
<tr><td><code id="grid.export_+3A_exportjs">exportJS</code></td>
<td>

<p>If this parameter is not <code>none</code> a JavaScript file is written out.
This contains useful functions for manipulating gridSVG plots in the
browser, including unit conversion functions.
</p>
<p>If this parameter is <code>file</code>, the JavaScript file is written to
a file, while <code>inline</code> will include the contents within the SVG
document.
</p>
</td></tr>
<tr><td><code id="grid.export_+3A_res">res</code></td>
<td>

<p>The device resolution to print at (in DPI).
</p>
<p>If <code>NULL</code>, this is automatically calculated to be the
resolution of the current device. Typically the PDF device would be
used, and this uses a resolution of 72, i.e. 72 DPI.
</p>
</td></tr>
<tr><td><code id="grid.export_+3A_prefix">prefix</code></td>
<td>

<p>A prefix to apply to all generated SVG ID attributes. Useful for
ensuring unique IDs when many SVG images exist within the same HTML
document.
</p>
<p>If a valid prefix has been given, the root <code>&lt;svg&gt;</code> element will
be given an ID attribute with the prefix as its value.
</p>
</td></tr>
<tr><td><code id="grid.export_+3A_addclasses">addClasses</code></td>
<td>

<p>If <code>TRUE</code>, adds an SVG class attribute to all grobs and
viewports which holds the value of the class of the grob or
viewport. If the class attribute already exists (via
<code><a href="#topic+grid.garnish">grid.garnish</a></code> or <code><a href="#topic+grid.element">grid.element</a></code>), the
resulting SVG class attribute will be the union of the existing
class attribute and the grob/viewport classes.
</p>
</td></tr>
<tr><td><code id="grid.export_+3A_indent">indent</code></td>
<td>

<p>Determines whether the resulting SVG document will be exported with
indentation present.
</p>
<p>Indentation makes the document more readable, but when <code>indent</code>
is set to <code>FALSE</code>, parsing the SVG in JavaScript is easier
because there are no empty text nodes.
</p>
</td></tr>
<tr><td><code id="grid.export_+3A_htmlwrapper">htmlWrapper</code></td>
<td>

<p>If <code>TRUE</code>, saves a wrapping HTML file. This file contains a
snippet of HTML which links to the exported SVG file.
</p>
</td></tr>
<tr><td><code id="grid.export_+3A_usepaths">usePaths</code></td>
<td>

<p>If this parameter is set to <code>vpPaths</code>, then when writing out
viewports gridSVG will set the SVG element ID to the current
<code>vpPath</code> instead of the current viewport name.
</p>
<p>If this parameter is set to <code>gPaths</code>, gridSVG will set the
names of grobs to be the current <code>gPath</code> instead of the current
grob name.
</p>
<p>When <code>none</code>, viewports and grobs will not incorporate paths.
</p>
<p>When <code>both</code>, viewports and grobs will both use paths.
</p>
</td></tr>
<tr><td><code id="grid.export_+3A_uniquenames">uniqueNames</code></td>
<td>

<p>If <code>TRUE</code>, gridSVG will make an attempt to produce unique grob
names. Unique <code>id</code> attributes are required for valid SVG. It is
highly recommended that mapping information is used when this
parameter is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="grid.export_+3A_annotate">annotate</code></td>
<td>

<p>If <code>TRUE</code>, an SVG metadata element will be introduced directly
below the root <code>&lt;svg&gt;</code> element. This element contains XML that
describes the information that gridSVG used to draw the image
(mostly arguments to <code>grid.export</code>). This output may be useful
for debugging purposes.
</p>
</td></tr>
<tr><td><code id="grid.export_+3A_progress">progress</code></td>
<td>

<p>If <code>TRUE</code>, messages will be displayed in the console that show
how quickly gridSVG is progressing when exporting an SVG image. This
is particularly useful when there are large images being exported so
we have a reasonable estimate of how long exporting will take.
</p>
</td></tr>
<tr><td><code id="grid.export_+3A_compression">compression</code></td>
<td>

<p>An integer between 0 and 9 indicating the level of (gzip)
compression applied to the SVG image when it is saved to a
file. Higher values of <code>compression</code> indicate smaller file
sizes at the expense of increased computation.
</p>
</td></tr>
<tr><td><code id="grid.export_+3A_strict">strict</code></td>
<td>

<p>A logical indicating whether checks should be made that all
attributes added to SVG elements are valid.  If this is
<code>TRUE</code> and invalid attributes are detected, those
attributes are removed, with a warning.
</p>
</td></tr>
<tr><td><code id="grid.export_+3A_rootattrs">rootAttrs</code></td>
<td>

<p>A named character vector containing attributes for the top-level
<code>&lt;svg&gt;</code> element.
</p>
</td></tr>
<tr><td><code id="grid.export_+3A_xmldecl">xmldecl</code></td>
<td>

<p>This parameter sets the XML declaraction that will be applied to the
SVG document.
</p>
<p>By default this parameter simply declares that the document is XML
version 1.0, along with the character encoding that was used to
export the SVG document.
</p>
<p>If <code>xmldecl</code> is <code>NULL</code>, then no XML declaration is
printed. This may be useful when you want only the SVG document and
nothing more.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>uniqueNames</code> parameter is set to <code>TRUE</code> by default in
order to ensure that each SVG element ID is unique. This is a
requirement of XML (which SVG is based on). This differs from
<code>usePaths</code> because <code>usePaths</code> can still generate names that
are not unique (there are several ways for this to
happen). <code>uniqueNames</code> modifies grob and viewport names with a
numeric suffix to ensure uniqueness. When <code>FALSE</code>, only grob
names will be kept unmodified because modifying viewport names would
affect coordinate information.
</p>
<p>Occasionally the XML package can report warnings, despite valid SVG
being produced. If spurious warnings are being produced, set
<code>options(gridSVGWarnings = FALSE)</code> to ignore them.
</p>
<p>See the files in the directory gridSVG/tests for examples
of things that can be done.  See the file gridSVG/doc/overview.tex
for limitations.
</p>


<h3>Value</h3>

<p>When <code>name</code> has a valid filename the side effect is to produce an
SVG file of the specified name.
</p>
<p>Optionally a JavaScript file containing coordinate transformation
information is also exported.
</p>
<p>Optionally a JavaScript file containing name mapping information is
also exported.
</p>
<p>Optionally a JavaScript file containing utility JavaScript functions
is also exported.
</p>
<p>When <code>name</code> has a filename with zero characters, a named list is
returned with four elements. <code>svg</code> is the SVG root node (and all
its children, see the XML package for more information on how to use
this. <code>coords</code> contains the list of coordinate information for
exported viewports. <code>mappings</code> is a list containing information
on how names have been modified during the exporting process.
<code>utils</code> is a character vector containing JavaScript code to
manipulate gridSVG plots in the browser.
</p>
<p>This list is always returned but when a valid filename is given, it is
returned invisibly.
</p>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>See Also</h3>

 <p><code><a href="#topic+grid.hyperlink">grid.hyperlink</a></code>, <code><a href="#topic+grid.animate">grid.animate</a></code>, <code><a href="#topic+grid.garnish">grid.garnish</a></code> </p>

<hr>
<h2 id='grid.filter'>
Associate a filter effect with a grid grob.
</h2><span id='topic+grid.filter'></span><span id='topic+filterGrob'></span>

<h3>Description</h3>

<p>Creates a <code>filtered.grob</code> object which is a normal grid grob,
with a filter effect applied to it Used in conjunction with
<code><a href="#topic+registerFilter">registerFilter</a></code>, to produce an SVG document containing
graphical elements with filter effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.filter(path, filter = NULL, label = NULL,
            group = TRUE, redraw = FALSE,
            strict = FALSE, grep = FALSE, global = FALSE)
filterGrob(x, filter = NULL, label = NULL, group = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grid.filter_+3A_x">x</code></td>
<td>

<p>A grob to filter.
</p>
</td></tr>
<tr><td><code id="grid.filter_+3A_path">path</code></td>
<td>

<p>A grob path specifying a drawn grob.
</p>
</td></tr>
<tr><td><code id="grid.filter_+3A_filter">filter</code></td>
<td>

<p>A <code>filter</code> object, provided by the <code><a href="#topic+filterEffect">filterEffect</a></code>
function. Provides the definition of a filter effect that will be
applied to <code>x</code> or <code>path</code>.
</p>
</td></tr>
<tr><td><code id="grid.filter_+3A_label">label</code></td>
<td>

<p>A label that is associated with a definition of a filter effect.
This is the label used to create a filter effect definition with
<code>registerFilter</code>.
</p>
</td></tr>
<tr><td><code id="grid.filter_+3A_group">group</code></td>
<td>

<p>A logical vector that indicates whether the filter effect should be
applied to the overall parent group for the relevant SVG element, or
to individual SVG elements.
</p>
</td></tr>
<tr><td><code id="grid.filter_+3A_redraw">redraw</code></td>
<td>

<p>A logical value to indicate whether to redraw the grob.
</p>
</td></tr>
<tr><td><code id="grid.filter_+3A_strict">strict</code></td>
<td>

<p>A boolean indicating whether the <code>path</code> must be matched
exactly.
</p>
</td></tr>
<tr><td><code id="grid.filter_+3A_grep">grep</code></td>
<td>

<p>Whether the <code>path</code> should be treated as a regular expression.
</p>
</td></tr>
<tr><td><code id="grid.filter_+3A_global">global</code></td>
<td>

<p>A boolean indicating whether the function should affect just the
first match of the <code>path</code>, or whether all matches should be
affected.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>label</code> is specified, uses a filter effect that has been supplied to
<code>registerFilter</code>. If <code>filter</code> is specified it will be used as
the filter effect applied to each grob. If both are specified, it will
attempt to define the filter effect with the given label, as well as
applying the filter effect to the appropriate grobs.
</p>


<h3>Value</h3>

<p>A <code>filtered.grob</code> object (for <code>filterGrob</code>).
</p>


<h3>Author(s)</h3>

<p>Simon Potter
</p>


<h3>See Also</h3>

<p><code><a href="#topic+registerFilter">registerFilter</a></code>, <code><a href="#topic+filterEffect">filterEffect</a></code>.
</p>

<hr>
<h2 id='grid.garnish'> Associate arbitrary SVG attributes with a grid grob </h2><span id='topic+grid.garnish'></span><span id='topic+garnishGrob'></span>

<h3>Description</h3>

<p>Creates an svg.grob object which is a normal grid grob,
with SVG attributes attached.  Useful in conjunction with
<code>grid.export</code>, to produce an SVG document with
attributes that have no corresponding concept in grid graphics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>garnishGrob(x, ..., group=TRUE)
grid.garnish(path, ..., group=TRUE, redraw=FALSE,
             strict = FALSE, grep=FALSE, global=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grid.garnish_+3A_x">x</code></td>
<td>
<p>A grob.</p>
</td></tr>
<tr><td><code id="grid.garnish_+3A_path">path</code></td>
<td>
<p> A grob path specifying a drawn grob. </p>
</td></tr>
<tr><td><code id="grid.garnish_+3A_...">...</code></td>
<td>
<p> Arbitrary SVG attribute settings. </p>
</td></tr>
<tr><td><code id="grid.garnish_+3A_group">group</code></td>
<td>
<p> A logical indicating whether the SVG attributes
should be attached to the overall parent group for the
relevant SVG element, or to individual SVG elements. </p>
</td></tr>
<tr><td><code id="grid.garnish_+3A_redraw">redraw</code></td>
<td>

<p>A logical value to indicate whether to redraw the grob.
</p>
</td></tr>
<tr><td><code id="grid.garnish_+3A_strict">strict</code></td>
<td>

<p>A boolean indicating whether the <code>path</code> must be matched
exactly.
</p>
</td></tr>
<tr><td><code id="grid.garnish_+3A_grep">grep</code></td>
<td>

<p>Whether the <code>path</code> should be treated as a regular expression.
</p>
</td></tr>
<tr><td><code id="grid.garnish_+3A_global">global</code></td>
<td>

<p>A boolean indicating whether the function should affect just the
first match of the <code>path</code>, or whether all matches should be
affected.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The SVG attribute settings can be vectors (in the case of garnishing
individual SVG elements) or even named vectors (if you want precise
control over which attribute value is apportioned to which
individual SVG element).
</p>


<h3>Value</h3>

<p>A garnished.grob object.
</p>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>See Also</h3>

 <p><code><a href="#topic+grid.export">grid.export</a></code> </p>

<hr>
<h2 id='grid.gradientFill'>
Associate a gradient fill with a grid grob
</h2><span id='topic+grid.gradientFill'></span><span id='topic+gradientFillGrob'></span>

<h3>Description</h3>

<p>Creates a <code>gradientFilled.grob</code> object which is a normal grid
grob, with a gradient fill used in place of a regular fill. Used in
conjunction with <code>registerGradientFill</code>, to produce an SVG
document containing graphical elements with gradient fills.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.gradientFill(path, gradient = NULL, label = NULL,
                  alpha = 1, group = TRUE, redraw = FALSE,
                  strict = FALSE, grep = FALSE, global = FALSE)
gradientFillGrob(x, gradient = NULL, label = NULL,
                 alpha = 1, group = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grid.gradientFill_+3A_x">x</code></td>
<td>

<p>A grob to add a pattern fill to.
</p>
</td></tr>
<tr><td><code id="grid.gradientFill_+3A_path">path</code></td>
<td>

<p>A grob path specifying a drawn grob.
</p>
</td></tr>
<tr><td><code id="grid.gradientFill_+3A_gradient">gradient</code></td>
<td>

<p>A <code>gradient</code> object, provided by the <code>linearGradient</code> and
<code>radialGradient</code> functions. Provides the definition of a
gradient fill that will be applied to <code>x</code> or <code>path</code>.
</p>
</td></tr>
<tr><td><code id="grid.gradientFill_+3A_label">label</code></td>
<td>

<p>A label that is associated with a definition of a gradient
fill. This is the label used to create a gradient fill
definition with <code>registerGradientFill</code>.
</p>
</td></tr>
<tr><td><code id="grid.gradientFill_+3A_alpha">alpha</code></td>
<td>

<p>The alpha channel for transparency. A value between 0 and 1.
</p>
</td></tr>
<tr><td><code id="grid.gradientFill_+3A_group">group</code></td>
<td>

<p>A logical vector that indicates whether the gradient fill
should be applied to the overall parent group for the
relevant SVG element, or to individual SVG elements.
</p>
</td></tr>
<tr><td><code id="grid.gradientFill_+3A_redraw">redraw</code></td>
<td>

<p>A logical value to indicate whether to redraw the grob.
</p>
</td></tr>
<tr><td><code id="grid.gradientFill_+3A_strict">strict</code></td>
<td>

<p>A boolean indicating whether the <code>path</code> must be matched
exactly.
</p>
</td></tr>
<tr><td><code id="grid.gradientFill_+3A_grep">grep</code></td>
<td>

<p>Whether the <code>path</code> should be treated as a regular expression.
</p>
</td></tr>
<tr><td><code id="grid.gradientFill_+3A_global">global</code></td>
<td>

<p>A boolean indicating whether the function should affect just the
first match of the <code>path</code>, or whether all matches should be
affected.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>label</code> is specified, uses a gradient that has been supplied
to <code>registerGradientFill</code>. If <code>gradient</code> is specified it
will be used as the gradient fill applied to each grob. If both are
specified, it will attempt to define the gradient with the given
label, as well as applying a gradient fill to the appropriate grobs.
</p>


<h3>Value</h3>

<p>A <code>gradientFilled.grob</code> object (for <code>gradientFillGrob</code>).
</p>


<h3>Author(s)</h3>

<p>Simon Potter
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linearGradient">linearGradient</a></code>, <code><a href="#topic+radialGradient">radialGradient</a></code>,
<code><a href="#topic+registerGradientFill">registerGradientFill</a></code>
</p>

<hr>
<h2 id='grid.hyperlink'> Associate a hyperlink with a grid grob </h2><span id='topic+grid.hyperlink'></span><span id='topic+hyperlinkGrob'></span>

<h3>Description</h3>

<p>Creates a linked.grob object which is a normal grid grob,
with a hyperlink attached.  Useful in conjunction with
<code>grid.export</code>, to produce an SVG document with
hyperlinked graphical elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.hyperlink(path, href, show=NULL, group=TRUE, redraw=FALSE,
               strict=FALSE, grep=FALSE, global=FALSE)
hyperlinkGrob(x, href, show=NULL, group=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grid.hyperlink_+3A_x">x</code></td>
<td>
<p> A grob to add a hyperlink to. </p>
</td></tr>
<tr><td><code id="grid.hyperlink_+3A_path">path</code></td>
<td>
<p> A grob path specifying a drawn grob. </p>
</td></tr>
<tr><td><code id="grid.hyperlink_+3A_href">href</code></td>
<td>
<p> A valid Xlink URI.  Can be a vector of several links
(see <code>group</code> argument below). </p>
</td></tr>
<tr><td><code id="grid.hyperlink_+3A_show">show</code></td>
<td>

<p>A character vector specifying how the link should be opened.
<code>NULL</code> and <code>""</code> will avoid adding an attribute. The most
common cases are to use <code>"new"</code> to open a link in a new
window/tab, or <code>"replace"</code> to open the link in the current
window/tab.
</p>
</td></tr>
<tr><td><code id="grid.hyperlink_+3A_group">group</code></td>
<td>
<p> A logical indicating whether the hyperlinks
should be attached to the overall parent group for the
relevant SVG element, or to individual SVG elements. </p>
</td></tr>
<tr><td><code id="grid.hyperlink_+3A_redraw">redraw</code></td>
<td>

<p>A logical value to indicate whether to redraw the grob.
</p>
</td></tr>
<tr><td><code id="grid.hyperlink_+3A_strict">strict</code></td>
<td>

<p>A boolean indicating whether the <code>path</code> must be matched
exactly.
</p>
</td></tr>
<tr><td><code id="grid.hyperlink_+3A_grep">grep</code></td>
<td>

<p>Whether the <code>path</code> should be treated as a regular expression.
</p>
</td></tr>
<tr><td><code id="grid.hyperlink_+3A_global">global</code></td>
<td>

<p>A boolean indicating whether the function should affect just the
first match of the <code>path</code>, or whether all matches should be
affected.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A linked.grob object.
</p>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>See Also</h3>

 <p><code><a href="#topic+grid.export">grid.export</a></code> </p>

<hr>
<h2 id='grid.mask'>
Apply an opacity mask to a grid grob.
</h2><span id='topic+grid.mask'></span><span id='topic+maskGrob'></span>

<h3>Description</h3>

<p>Creates a <code>masked.grob</code> object which is a normal grid grob, with
an opacity mask applied to it. Used in conjunction with
<code>registerMask</code>, to produce an SVG document containing graphical
elements with masked content.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.mask(path, mask = NULL, label = NULL, group = TRUE, redraw = FALSE,
          strict = FALSE, grep = FALSE, global = FALSE)
maskGrob(x, mask = NULL, label = NULL, group = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grid.mask_+3A_x">x</code></td>
<td>

<p>A grob to mask.
</p>
</td></tr>
<tr><td><code id="grid.mask_+3A_path">path</code></td>
<td>

<p>A grob path specifying a drawn grob.
</p>
</td></tr>
<tr><td><code id="grid.mask_+3A_mask">mask</code></td>
<td>

<p>A <code>mask</code> object, provided by the <code><a href="#topic+mask">mask</a></code> function.
Provides the definition of an opacity mask that will be applied to
<code>x</code> or <code>path</code>.
</p>
</td></tr>
<tr><td><code id="grid.mask_+3A_label">label</code></td>
<td>

<p>A label that is associated with a definition of an opacity mask.
This is the label used to create an opacity mask definition with
<code>registerMask</code>.
</p>
</td></tr>
<tr><td><code id="grid.mask_+3A_group">group</code></td>
<td>

<p>A logical vector that indicates whether the opacity mask should be
applied to the overall parent group for the relevant SVG element, or
to individual SVG elements.
</p>
</td></tr>
<tr><td><code id="grid.mask_+3A_redraw">redraw</code></td>
<td>

<p>A logical value to indicate whether to redraw the grob.
</p>
</td></tr>
<tr><td><code id="grid.mask_+3A_strict">strict</code></td>
<td>

<p>A boolean indicating whether the <code>path</code> must be matched
exactly.
</p>
</td></tr>
<tr><td><code id="grid.mask_+3A_grep">grep</code></td>
<td>

<p>Whether the <code>path</code> should be treated as a regular expression.
</p>
</td></tr>
<tr><td><code id="grid.mask_+3A_global">global</code></td>
<td>

<p>A boolean indicating whether the function should affect just the
first match of the <code>path</code>, or whether all matches should be
affected.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>label</code> is specified, uses a mask that has been supplied to
<code>registerMask</code>. If <code>mask</code> is specified it will be used as
the opacity mask applied to each grob. If both are specified, it will
attempt to define the opacity mask with the given label, as well as
applying the mask to the appropriate grobs.
</p>


<h3>Value</h3>

<p>A <code>masked.grob</code> object (for <code>maskGrob</code>).
</p>


<h3>Author(s)</h3>

<p>Simon Potter
</p>


<h3>See Also</h3>

<p><code><a href="#topic+registerMask">registerMask</a></code>, <code><a href="#topic+mask">mask</a></code>,
<code><a href="#topic+pushMask">pushMask</a></code>.
</p>

<hr>
<h2 id='grid.patternFill'> Associate a pattern fill with a grid grob </h2><span id='topic+grid.patternFill'></span><span id='topic+patternFillGrob'></span>

<h3>Description</h3>

<p>Creates a patternFilled.grob object which is a normal grid grob, with
a pattern fill used in place of a regular fill. Used in conjunction
with <code>registerPatternFill</code>, to produce an SVG document containing
graphical elements with pattern fills.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.patternFill(path, pattern = NULL, label = NULL,
                 alpha = 1, group = TRUE, redraw = FALSE,
                 strict = FALSE, grep = FALSE, global = FALSE)
patternFillGrob(x, pattern = NULL, label = NULL,
                alpha = 1, group = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grid.patternFill_+3A_x">x</code></td>
<td>

<p>A grob to add a pattern fill to.
</p>
</td></tr>
<tr><td><code id="grid.patternFill_+3A_pattern">pattern</code></td>
<td>

<p>A <code>pattern</code> object, provided by the <code>pattern</code>
function. Provides the definition of a pattern fill that will be
applied to <code>x</code> or <code>path</code>.
</p>
</td></tr>
<tr><td><code id="grid.patternFill_+3A_label">label</code></td>
<td>

<p>A label that is associated with a definition of a pattern fill. This
is the label used to create a pattern fill definition with
<code><a href="#topic+registerPatternFill">registerPatternFill</a></code>.
</p>
</td></tr>
<tr><td><code id="grid.patternFill_+3A_path">path</code></td>
<td>

<p>A grob path specifying a drawn grob.
</p>
</td></tr>
<tr><td><code id="grid.patternFill_+3A_alpha">alpha</code></td>
<td>

<p>The alpha channel for transparency. A value between 0 and 1.
</p>
</td></tr>
<tr><td><code id="grid.patternFill_+3A_group">group</code></td>
<td>

<p>A logical vector that indicates whether the pattern fill should be
applied to the overall parent group for the relevant SVG element, or
to individual SVG elements.
</p>
</td></tr>
<tr><td><code id="grid.patternFill_+3A_redraw">redraw</code></td>
<td>

<p>A logical value to indicate whether to redraw the grob.
</p>
</td></tr>
<tr><td><code id="grid.patternFill_+3A_strict">strict</code></td>
<td>

<p>A boolean indicating whether the <code>path</code> must be matched
exactly.
</p>
</td></tr>
<tr><td><code id="grid.patternFill_+3A_grep">grep</code></td>
<td>

<p>Whether the <code>path</code> should be treated as a regular expression.
</p>
</td></tr>
<tr><td><code id="grid.patternFill_+3A_global">global</code></td>
<td>

<p>A boolean indicating whether the function should affect just the
first match of the <code>path</code>, or whether all matches should be
affected.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>label</code> is specified, uses a pattern that has been supplied to
<code><a href="#topic+registerPatternFill">registerPatternFill</a></code>. If <code>pattern</code> is specified it
will be used as the fill pattern applied to each grob. If both are
specified, it will attempt to define the pattern with the given label,
as well as applying a pattern fill to the appropriate grobs.
</p>


<h3>Value</h3>

<p>A patternFilled.grob object (for <code>patternFillGrob</code>).
</p>


<h3>Author(s)</h3>

<p> Simon Potter </p>


<h3>See Also</h3>

 <p><code><a href="#topic+registerPatternFill">registerPatternFill</a></code> </p>

<hr>
<h2 id='grid.script'> Create a grid grob containing an SVG script</h2><span id='topic+grid.script'></span><span id='topic+scriptGrob'></span>

<h3>Description</h3>

<p>Creates a script object which is a normal grid grob
containing an SVG script. Useful in conjunction with
<code>grid.export</code>, to produce an SVG document with
script elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scriptGrob(script=NULL, filename=NULL, type="application/ecmascript",
           inline=FALSE, name=NULL)
grid.script(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grid.script_+3A_script">script</code></td>
<td>
<p> A character value specifying script code. </p>
</td></tr>
<tr><td><code id="grid.script_+3A_filename">filename</code></td>
<td>
<p> The name of a file that contains script code. </p>
</td></tr>
<tr><td><code id="grid.script_+3A_type">type</code></td>
<td>
<p> The type of the script code. </p>
</td></tr>
<tr><td><code id="grid.script_+3A_inline">inline</code></td>
<td>
<p> A logical specifying whether the script code from the
file should be included inline or just referenced. </p>
</td></tr>
<tr><td><code id="grid.script_+3A_name">name</code></td>
<td>
<p> A character value giving a name for the grob. </p>
</td></tr>
<tr><td><code id="grid.script_+3A_...">...</code></td>
<td>
<p> Arguments to be passed into <code>scriptGrob</code>. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A script.grob object.
</p>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>See Also</h3>

 <p><code><a href="#topic+grid.export">grid.export</a></code> </p>

<hr>
<h2 id='gridsvg'>
gridSVG Graphics Device
</h2><span id='topic+gridsvg'></span><span id='topic+dev.off'></span>

<h3>Description</h3>

<p>Provides a convenient and familiar graphics device interface for the
gridSVG package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gridsvg(name = "Rplots.svg",
        exportCoords = c("none", "inline", "file"),
        exportMappings = c("none", "inline", "file"),
        exportJS = c("none", "inline", "file"),
        res = NULL,
        prefix = "",
        addClasses = FALSE,
        indent = TRUE,
        htmlWrapper = FALSE,
        usePaths = c("vpPaths", "gPaths", "none", "both"),
        uniqueNames = TRUE,
        annotate = TRUE,
        progress = FALSE,
        compression = 0,
        strict = TRUE,
        rootAttrs = NULL,
        xmldecl = xmlDecl(), ...)
dev.off(which = dev.cur())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gridsvg_+3A_name">name</code>, <code id="gridsvg_+3A_exportcoords">exportCoords</code>, <code id="gridsvg_+3A_exportmappings">exportMappings</code>, <code id="gridsvg_+3A_exportjs">exportJS</code>, <code id="gridsvg_+3A_res">res</code>, <code id="gridsvg_+3A_prefix">prefix</code>, <code id="gridsvg_+3A_addclasses">addClasses</code>, <code id="gridsvg_+3A_indent">indent</code>, <code id="gridsvg_+3A_htmlwrapper">htmlWrapper</code>, <code id="gridsvg_+3A_usepaths">usePaths</code>, <code id="gridsvg_+3A_uniquenames">uniqueNames</code>, <code id="gridsvg_+3A_annotate">annotate</code>, <code id="gridsvg_+3A_progress">progress</code>, <code id="gridsvg_+3A_compression">compression</code>, <code id="gridsvg_+3A_strict">strict</code>, <code id="gridsvg_+3A_rootattrs">rootAttrs</code>, <code id="gridsvg_+3A_xmldecl">xmldecl</code></td>
<td>

<p>These parameters are passed onto <code><a href="#topic+grid.export">grid.export</a></code>.
</p>
</td></tr>
<tr><td><code id="gridsvg_+3A_...">...</code></td>
<td>

<p>Further parameters that are passed onto a <code>NULL</code>
<code><a href="grDevices.html#topic+pdf">pdf</a></code> graphics device. Useful parameters include
<code>width</code> and <code>height</code>.
</p>
</td></tr>
<tr><td><code id="gridsvg_+3A_which">which</code></td>
<td>

<p>An integer specifying a device number.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions provide a more familiar and perhaps convenient
interface to gridSVG than <code><a href="#topic+grid.export">grid.export</a></code>. It uses a PDF
device as drawing occurs, but when the device needs to be written out
(via <code>dev.off</code>) then it will save an SVG image instead.
</p>
<p>When a grid display list is not in use, or any device other than the
<code>gridsvg</code> device is used, the behaviour of <code>dev.off</code> is the
same as <code><a href="grDevices.html#topic+dev.off">dev.off</a></code> from the <code>grDevices</code>
package.
</p>


<h3>Value</h3>

<p><code>gridsvg</code> returns nothing.
</p>
<p><code>dev.off</code> will return in the same manner as
<code><a href="#topic+grid.export">grid.export</a></code>. A list is always returned, but invisibly
when an invalid filename is given.
</p>


<h3>Author(s)</h3>

<p>Simon Potter
</p>


<h3>See Also</h3>

<p><code><a href="grDevices.html#topic+pdf">pdf</a></code> and <code><a href="#topic+grid.export">grid.export</a></code>.
</p>

<hr>
<h2 id='gridSVG.newpage'>
Move to a New Page on a gridSVG Device
</h2><span id='topic+gridSVG.newpage'></span>

<h3>Description</h3>

<p>This function erases the current device or moves to a new page. In
addition, it clears any definitions of referenced content defined by
gridSVG.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gridSVG.newpage(wipeRefs = TRUE, recording = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gridSVG.newpage_+3A_wiperefs">wipeRefs</code></td>
<td>

<p>A logical value that determines whether referenced content should be
deleted.
</p>
</td></tr>
<tr><td><code id="gridSVG.newpage_+3A_recording">recording</code></td>
<td>

<p>A logical value to indicate whether the new-page operation should be
saved onto the Grid display list.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When creating a gridSVG image, it is possible to create referenced
content. An example is pattern fills. This function should be used in
order to remove the definitions of referenced content.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Simon Potter
</p>

<hr>
<h2 id='grobToDev'>

Convert a grob to device calls
</h2><span id='topic+grobToDev'></span>

<h3>Description</h3>


<p>This function is used to make calls to a device to
draw a grob.  It is generic so new grob classes can
write their own methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grobToDev(x, dev)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grobToDev_+3A_x">x</code></td>
<td>
<p> A grob.
</p>
</td></tr>
<tr><td><code id="grobToDev_+3A_dev">dev</code></td>
<td>
<p>  A graphics device.
</p>
</td></tr>
</table>


<h3>Details</h3>


<p>This function is not called directly by the user.
It is exposed so that new grob classes can easily write
their own methods which call existing methods for
standard grobs.
</p>
<p>The difference between this function and <code>primToDev()</code> is
that this one takes care of setting up coordinate systems based on
the grid viewports so that
SVG output is positioned correctly, then it calls <code>primToDev()</code>
to produce the actual SVG elements.
</p>


<h3>Author(s)</h3>


<p>Paul Murrell
</p>

<hr>
<h2 id='Import+20Coordinate+20JS'>
Importing JavaScript coordinate information.
</h2><span id='topic+readCoordsJS'></span>

<h3>Description</h3>

<p>This function reads in a JavaScript file and transforms it into JSON
text. This text is then transformed into a list that can be used in
conjunction with <code><a href="#topic+gridSVGCoords">gridSVGCoords</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readCoordsJS(filename)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Import+2B20Coordinate+2B20JS_+3A_filename">filename</code></td>
<td>

<p>A character vector that represents a file name. This file should be
a JavaScript file containing coordinate information produced by
<code><a href="#topic+grid.export">grid.export</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to use the <code>fromJSON</code> function to parse JSON text,
the JavaScript file produced by <code><a href="#topic+grid.export">grid.export</a></code> needs to be
transformed. It needs to transform from being an assignment of an object
literal to simply the object literal itself.
</p>
<p>This function performs that task by producing a valid JSON string ready
for parsing by <code>fromJSON</code>. It then returns the parsed list.
</p>


<h3>Value</h3>

<p>A list of coordinate information.
</p>


<h3>Author(s)</h3>

<p>Simon Potter
</p>

<hr>
<h2 id='Import+20Mappings+20JS'>
Importing JavaScript mapping information.
</h2><span id='topic+readMappingsJS'></span>

<h3>Description</h3>

<p>This function reads in a JavaScript file and transforms it into JSON
text. This text is then transformed into a list that can be used in
conjunction with <code><a href="#topic+gridSVGMappings">gridSVGMappings</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readMappingsJS(filename)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Import+2B20Mappings+2B20JS_+3A_filename">filename</code></td>
<td>

<p>A character vector that represents a file name. This file should be
a JavaScript file containing mapping information produced by
<code><a href="#topic+grid.export">grid.export</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to use the <code>fromJSON</code> function to parse JSON text,
the JavaScript file produced by <code><a href="#topic+grid.export">grid.export</a></code> needs to be
transformed. It needs to transform from being an assignment of an object
literal to simply the object literal itself.
</p>
<p>This function performs that task by producing a valid JSON string ready
for parsing by <code>fromJSON</code>. It then returns the parsed list.
</p>


<h3>Value</h3>

<p>A list of mapping information.
</p>


<h3>Author(s)</h3>

<p>Simon Potter
</p>

<hr>
<h2 id='listSVGDefinitions'>
List All Reference Definitions
</h2><span id='topic+listSVGDefinitions'></span>

<h3>Description</h3>

<p>Returns a listing of the labels given to reference definitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>listSVGDefinitions(print = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="listSVGDefinitions_+3A_print">print</code></td>
<td>

<p>If <code>TRUE</code>, prints the listing of reference definitions.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When definitions of referenced content are stored in gridSVG via any
of the <code>register*</code> functions
(e.g. <code><a href="#topic+registerPatternFill">registerPatternFill</a></code>), we can use this function to
show us all of the labels given when content is registered.
</p>


<h3>Value</h3>

<p>A data frame, returned invisibly.
</p>


<h3>Author(s)</h3>

<p>Simon Potter
</p>

<hr>
<h2 id='Mapping+20Names+20to+20IDs'>
Mapping Viewport, Grob and Reference Names to SVG IDs
</h2><span id='topic+gridSVGMappings'></span>

<h3>Description</h3>

<p>This function is both a getter and a setter function for mapping
information imported from a plot unknown to the current R session.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gridSVGMappings(newmappings = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Mapping+2B20Names+2B20to+2B20IDs_+3A_newmappings">newmappings</code></td>
<td>

<p>A named list mapping information, produced by
<code><a href="#topic+grid.export">grid.export</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to generate unique names for SVG IDs, gridSVG output will not
produce the same names as are visible on the grid display list. This
function will store and return mapping information. This is
information on how names have been translated from their original
grob/viewport names to their SVG IDs.
</p>
<p>Mapping information is stored as a list with 4 components, viewport
mapping information, grob mapping information, reference mapping
information and the ID separator used at the time of exporting.
</p>
<p>Viewport, grob, and reference mapping information is stored as the
name of the object, paired with a vector of suffixes associated with
these names. When combined with the ID separator, we can construct the
SVG IDs that have been applied, given each name. Use
<code><a href="#topic+getSVGMappings">getSVGMappings</a></code> to do this.
</p>


<h3>Value</h3>

<p>If <code>newmappings</code> is <code>NULL</code>, then we get back a named list
representing name mapping information.
</p>
<p>If we pass the named list representing mapping information into the
function, we get no output.
</p>


<h3>Author(s)</h3>

<p>Simon Potter
</p>

<hr>
<h2 id='Opacity+20Masks'>
Create the definition of an opacity mask.
</h2><span id='topic+mask'></span><span id='topic+registerMask'></span>

<h3>Description</h3>

<p>A feature of SVG is that elements can have an opacity mask applied to
it. An opacity mask is an image that, for various levels of opacity,
makes the object that is being masked inherit the same levels of
opacity. The purpose of these functions is to define an opacity mask
that will be applied until the current viewport (or context, see
<code><a href="#topic+popContext">popContext</a></code>) is popped. Alternatively it can also be
applied to grobs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mask(grob,
     x = unit(0.5, "npc"), y = unit(0.5, "npc"),
     width = unit(1, "npc"), height = unit(1, "npc"),
     default.units = "npc",
     just = "centre", hjust = NULL, vjust = NULL)
registerMask(label, mask = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Opacity+2B20Masks_+3A_grob">grob</code></td>
<td>

<p>A grob or gTree that will be drawn as the opacity mask.
</p>
</td></tr>
<tr><td><code id="Opacity+2B20Masks_+3A_x">x</code></td>
<td>

<p>A numeric vector or unit object specifying x-location.
</p>
</td></tr>
<tr><td><code id="Opacity+2B20Masks_+3A_y">y</code></td>
<td>

<p>A numeric vector or unit object specifying y-location.
</p>
</td></tr>
<tr><td><code id="Opacity+2B20Masks_+3A_width">width</code></td>
<td>

<p>A numeric vector or unit object specifying width.
</p>
</td></tr>
<tr><td><code id="Opacity+2B20Masks_+3A_height">height</code></td>
<td>

<p>A numeric vector or unit object specifying height.
</p>
</td></tr>
<tr><td><code id="Opacity+2B20Masks_+3A_default.units">default.units</code></td>
<td>

<p>A string indicating the default units to use if <code>x</code>, <code>y</code>,
<code>width</code>, or <code>height</code> are only given as numeric vectors.
</p>
</td></tr>
<tr><td><code id="Opacity+2B20Masks_+3A_just">just</code></td>
<td>

<p>The justification of the pattern relative to its (x, y) location.
If there are two values, the first value specifies horizontal
justification and the second value specifies vertical justification.
Possible string values are: <code>"left"</code>, <code>"right"</code>,
<code>"centre"</code>, <code>"center"</code>, <code>"bottom"</code>, and <code>"top"</code>.
For numeric values, 0 means left alignment and 1 means right
alignment.
</p>
</td></tr>
<tr><td><code id="Opacity+2B20Masks_+3A_hjust">hjust</code></td>
<td>

<p>A numeric vector specifying horizontal justification. If specified,
overrides the <code>just</code> setting.
</p>
</td></tr>
<tr><td><code id="Opacity+2B20Masks_+3A_vjust">vjust</code></td>
<td>

<p>A numeric vector specifying vertical justification. If specified,
overrides the <code>just</code> setting.
</p>
</td></tr>
<tr><td><code id="Opacity+2B20Masks_+3A_label">label</code></td>
<td>

<p>A character identifier that will be used to reference this
definition.
</p>
</td></tr>
<tr><td><code id="Opacity+2B20Masks_+3A_mask">mask</code></td>
<td>

<p>A <code>mask</code> object that defines the mask.
</p>
</td></tr>
<tr><td><code id="Opacity+2B20Masks_+3A_...">...</code></td>
<td>

<p>Arguments to be given to <code><a href="#topic+mask">mask</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When registering the mask, the rectangular region that the mask
applies to will become fixed.
</p>
<p>When referring to an opacity mask, the masked content will be opaque
at the same coordinates that the mask is opaque. The same applies when
there is any level of transparency, as any transparency in the mask
will also apply in the same corresponding region of the masked object.
</p>
<p>The mask's opacity is defined as being the level of luminance present
in the mask. This means anything black is fully transparent, while
anything white is completely opaque. The background is assumed to be
black (i.e. fully transparent). The <code>alpha</code> value in a mask will
still be used, but its effect is combined with the computed opacity
from the luminance of the mask.
</p>
<p>By using an opacity mask it is possible to have a grob with
non-uniform opacity. In other words, rather than specifying an opacity
via <code><a href="grid.html#topic+gpar">gpar</a></code>'s <code>alpha</code> parameter, which is uniform
across the grob, we can define varying opacities on a grob via an
opacity mask.
</p>
<p>The <code>x</code>, <code>y</code>, <code>width</code>, <code>height</code> parameters
determine the location and dimensions of the area to apply the mask
to. This means we can apply a mask to any rectangular region, relative
to the viewport in which it is defined (via <code>registerMask</code>).
</p>


<h3>Value</h3>

<p>For <code>mask</code>, a <code>mask</code> object.
</p>


<h3>Author(s)</h3>

<p>Simon Potter
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grid.mask">grid.mask</a></code>, <code><a href="#topic+pushMask">pushMask</a></code>,
<code><a href="#topic+popContext">popContext</a></code>.
</p>

<hr>
<h2 id='Pattern+20Fills'>
Create a definition of a fill pattern.
</h2><span id='topic+pattern'></span><span id='topic+registerPatternFill'></span><span id='topic+registerPatternFillRef'></span>

<h3>Description</h3>

<p>A feature of SVG is that elements can be filled with a pattern that is
defined somewhere in the document. The purpose of these functions is to
create the definition of a fill pattern so that it can be referred to
by grobs drawn by gridSVG.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pattern(grob,
        x = unit(0, "npc"), y = unit(0, "npc"),
        width = unit(0.1, "npc"), height = unit(0.1, "npc"),
        default.units = "npc",
        just = "centre", hjust = NULL, vjust = NULL,
        dev.width = 7, dev.height = 7)
registerPatternFill(label, pattern = NULL, ...)
registerPatternFillRef(label, refLabel, pattern = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Pattern+2B20Fills_+3A_label">label</code></td>
<td>

<p>A character identifier for the definition.
</p>
</td></tr>
<tr><td><code id="Pattern+2B20Fills_+3A_reflabel">refLabel</code></td>
<td>

<p>A character identifier referring to an existing pattern definition
that has been created by <code>registerPatternFill</code>.
</p>
</td></tr>
<tr><td><code id="Pattern+2B20Fills_+3A_pattern">pattern</code></td>
<td>

<p>A <code>pattern</code> object created by <code>pattern</code>.
</p>
</td></tr>
<tr><td><code id="Pattern+2B20Fills_+3A_grob">grob</code></td>
<td>

<p>A grid grob or tree of grobs.
</p>
</td></tr>
<tr><td><code id="Pattern+2B20Fills_+3A_x">x</code></td>
<td>

<p>A numeric vector or unit object specifying x-location.
</p>
</td></tr>
<tr><td><code id="Pattern+2B20Fills_+3A_y">y</code></td>
<td>

<p>A numeric vector or unit object specifying y-location.
</p>
</td></tr>
<tr><td><code id="Pattern+2B20Fills_+3A_width">width</code></td>
<td>

<p>A numeric vector or unit object specifying width.
</p>
</td></tr>
<tr><td><code id="Pattern+2B20Fills_+3A_height">height</code></td>
<td>

<p>A numeric vector or unit object specifying height.
</p>
</td></tr>
<tr><td><code id="Pattern+2B20Fills_+3A_just">just</code></td>
<td>

<p>The justification of the pattern relative to its (x, y) location.
If there are two values, the first value specifies horizontal
justification and the second value specifies vertical justification.
Possible string values are: <code>"left"</code>, <code>"right"</code>,
<code>"centre"</code>, <code>"center"</code>, <code>"bottom"</code>, and <code>"top"</code>.
For numeric values, 0 means left alignment and 1 means right
alignment.
</p>
</td></tr>
<tr><td><code id="Pattern+2B20Fills_+3A_hjust">hjust</code></td>
<td>

<p>A numeric vector specifying horizontal justification. If specified,
overrides the <code>just</code> setting.
</p>
</td></tr>
<tr><td><code id="Pattern+2B20Fills_+3A_vjust">vjust</code></td>
<td>

<p>A numeric vector specifying vertical justification. If specified,
overrides the <code>just</code> setting.
</p>
</td></tr>
<tr><td><code id="Pattern+2B20Fills_+3A_default.units">default.units</code></td>
<td>

<p>A string indicating the default units to use if <code>x</code>, <code>y</code>,
<code>width</code>, or <code>height</code> are only given as numeric vectors.
</p>
</td></tr>
<tr><td><code id="Pattern+2B20Fills_+3A_dev.width">dev.width</code>, <code id="Pattern+2B20Fills_+3A_dev.height">dev.height</code></td>
<td>

<p>The width and height of the fill pattern's graphics region in
inches. The default values are <code>7</code>.
</p>
</td></tr>
<tr><td><code id="Pattern+2B20Fills_+3A_...">...</code></td>
<td>

<p>Arguments to be be passed onto <code>pattern</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The pattern fill is drawn off-screen on a new device. The size of this
device is determined by <code>dev.width</code> and <code>dev.height</code>. The
<code>grob</code> and <code>vp</code> that have been given are then drawn within
this device. This is relevant for determining what the pattern
definition looks like.
</p>
<p>The previous arguments do not determine the size of the pattern as it
is being used (i.e. how big each &quot;tile&quot; is). This is set by the
<code>x</code>, <code>y</code>, <code>width</code>, <code>height</code> arguments. The values
of these arguments are relative to the current viewport as this
function is being called. From then on, the definition of the location
and size of the pattern are fixed.
</p>
<p>In summary, the <code>pattern</code> function defines what a pattern
looks like, along with how big each tile is (and its position).
</p>
<p>To avoid repetition of pattern definitions, use
<code>registerPatternFillRef</code> to reuse an existing pattern definition
(referred to by <code>refLabel</code>). This means that a pattern &quot;tile&quot; can
now be reused, repositioned and rescaled without having to describe
how it needs to be drawn.
</p>
<p>In general use, first create a pattern object, then either give a
label to the definition (for grobs to use), or alternatively simply
pass on the pattern object to <code><a href="#topic+grid.patternFill">grid.patternFill</a></code>.
</p>


<h3>Value</h3>

<p>A <code>pattern</code> object for <code>pattern</code>, none otherwise.
</p>


<h3>Author(s)</h3>

<p>Simon Potter
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grid.patternFill">grid.patternFill</a></code>
</p>

<hr>
<h2 id='popContext'>
Leaving A Modified Viewport Context
</h2><span id='topic+popContext'></span>

<h3>Description</h3>

<p>A modified viewport context is where the appearance of grobs is no
longer determined solely by the grob itself and the viewport into
which they're drawn. This can occur when applying clipping paths and
opacity masks, which modify the appearance of anything drawn after
they have been applied. This function should be used when attempting
to stop the effect of a modified viewport context (e.g. to stop
clipping to paths).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>popContext(n = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="popContext_+3A_n">n</code></td>
<td>

<p>The number of contexts to pop. A warning will be given when <code>n</code>
is greater than the number that has been applied.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Popping a context can produce a warning. In this case it is
recommended that the context &quot;pushing&quot; and &quot;popping&quot; be revised to
have matching pairs of pushes and pops.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Simon Potter
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grid.clipPath">grid.clipPath</a></code> and <code><a href="#topic+grid.mask">grid.mask</a></code>
</p>

<hr>
<h2 id='primToDev'>

Convert a grob to device calls
</h2><span id='topic+primToDev'></span>

<h3>Description</h3>


<p>This function is used to make calls to a device to
draw a grob.  It is generic so new grob classes can
write their own methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>primToDev(x, dev)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="primToDev_+3A_x">x</code></td>
<td>
<p> A grob.
</p>
</td></tr>
<tr><td><code id="primToDev_+3A_dev">dev</code></td>
<td>
<p>  A graphics device.
</p>
</td></tr>
</table>


<h3>Details</h3>


<p>This function is not called directly by the user.
It is exposed so that new grob classes can easily write
their own methods which call existing methods for
standard grobs.
</p>


<h3>Author(s)</h3>


<p>Paul Murrell
</p>

<hr>
<h2 id='pushClipPath'>
Apply a clipping context to the current viewport.
</h2><span id='topic+pushClipPath'></span><span id='topic+popClipPath'></span>

<h3>Description</h3>

<p>This function is intended to be used similarly to
<code><a href="grid.html#topic+grid.clip">grid.clip</a></code>. The only difference is that a non-rectangular
clipping region can be applied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pushClipPath(clippath = NULL, label = NULL, name = NULL, draw = TRUE)
popClipPath()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pushClipPath_+3A_clippath">clippath</code></td>
<td>

<p>A graphics object, used as the definition of a clipping path.
</p>
</td></tr>
<tr><td><code id="pushClipPath_+3A_label">label</code></td>
<td>

<p>A label for a defined reference.
</p>
</td></tr>
<tr><td><code id="pushClipPath_+3A_name">name</code></td>
<td>

<p>A character identifier for the grob applying the clipping context.
</p>
</td></tr>
<tr><td><code id="pushClipPath_+3A_draw">draw</code></td>
<td>

<p>A logical value indicating whether graphics output should be
produced.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>label</code> is specified, uses a clipping path that has been
supplied to <code>registerClipPath</code>. If <code>clippath</code> is specified
it will be used as the new clipping context for the current
viewport. If both are specified, it will attempt to define the
clipping path with the given label, as well as adding the clipping
path as a clipping context for the current viewport.
</p>
<p><code>popClipPath</code> is an alias for <code><a href="#topic+popContext">popContext</a></code>
</p>


<h3>Value</h3>

<p>A <code>pushClipPath</code> grob. The value is returned invisibly.
</p>


<h3>Author(s)</h3>

<p>Simon Potter
</p>


<h3>See Also</h3>

<p><code><a href="#topic+registerClipPath">registerClipPath</a></code>, <code><a href="#topic+grid.clipPath">grid.clipPath</a></code>,
<code><a href="#topic+popContext">popContext</a></code>.
</p>

<hr>
<h2 id='pushMask'>
Apply a masking context to the current viewport.
</h2><span id='topic+pushMask'></span><span id='topic+popMask'></span>

<h3>Description</h3>

<p>This function is intended to be used similarly to
<code><a href="grid.html#topic+grid.clip">grid.clip</a></code>. The key difference is that instead of
applying a new clipping context to the viewport, we apply a new
masking context.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pushMask(mask = NULL, label = NULL, name = NULL, draw = TRUE)
popMask()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pushMask_+3A_mask">mask</code></td>
<td>

<p>A <code>mask</code> object, used as the definition of an opacity mask.
</p>
</td></tr>
<tr><td><code id="pushMask_+3A_label">label</code></td>
<td>

<p>A label for a defined reference.
</p>
</td></tr>
<tr><td><code id="pushMask_+3A_name">name</code></td>
<td>

<p>A character identifier for the grob applying the masking context.
</p>
</td></tr>
<tr><td><code id="pushMask_+3A_draw">draw</code></td>
<td>

<p>A logical value indicating whether graphics output should be
produced.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>label</code> is specified, uses a mask that has been supplied to
<code>registerMask</code>. If <code>mask</code> is specified it will be used as
the new masking context for the current viewport. If both are
specified, it will attempt to define the mask with the given label, as
well as applying the mask as the new masking context for the current
viewport.
</p>
<p><code>popMask</code> is an alias for <code><a href="#topic+popContext">popContext</a></code>.
</p>


<h3>Value</h3>

<p>A <code>pushMask</code> grob. The value is returned invisibly.
</p>


<h3>Author(s)</h3>

<p>Simon Potter
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mask">mask</a></code>, <code><a href="#topic+registerMask">registerMask</a></code>,
<code><a href="#topic+grid.mask">grid.mask</a></code>, <code><a href="#topic+popContext">popContext</a></code>.
</p>

<hr>
<h2 id='registerFilter'>
Create the definition a filter effect.
</h2><span id='topic+registerFilter'></span>

<h3>Description</h3>

<p>A feature of SVG is that elements can be filtered using filter effects
defined somewhere in the document. The purpose of this function is to
create the definition of a filter effect so that it can be referred to
by grobs drawn by gridSVG.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>registerFilter(label, filter)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="registerFilter_+3A_label">label</code></td>
<td>

<p>A character identifier for the definition.
</p>
</td></tr>
<tr><td><code id="registerFilter_+3A_filter">filter</code></td>
<td>

<p>A <code>filter</code> object, produced by the <code><a href="#topic+filterEffect">filterEffect</a></code>
function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When registering a filter, all locations and dimensions that filter
effects refer to become fixed.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Simon Potter
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grid.filter">grid.filter</a></code>, <code><a href="#topic+filterEffect">filterEffect</a></code>.
</p>

<hr>
<h2 id='Retrieve+20Names+20Mapped+20to+20SVG+20IDs+2C+20CSS+20Selectors+20and+20XPath+20Expressions'>
Retrieving Viewport, Grob, and Reference Names as SVG IDs, CSS
Selectors and XPath Expressions
</h2><span id='topic+getSVGMappings'></span>

<h3>Description</h3>

<p>This function gives us SVG IDs (or CSS selectors and XPath
expressions) that have been created from a grob, viewport, or
referenced name as a result of exporting to SVG.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSVGMappings(name, type, result = "id")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Retrieve+2B20Names+2B20Mapped+2B20to+2B20SVG+2B20IDs+2B2C+2B20CSS+2B20Selectors+2B20and+2B20XPath+2B20Expressions_+3A_name">name</code></td>
<td>

<p>A single element character vector. This should be the name of a grob
or viewport (as determined by <code>type</code>) present as the grid plot
was exported.
</p>
</td></tr>
<tr><td><code id="Retrieve+2B20Names+2B20Mapped+2B20to+2B20SVG+2B20IDs+2B2C+2B20CSS+2B20Selectors+2B20and+2B20XPath+2B20Expressions_+3A_type">type</code></td>
<td>

<p>A single element character vector, must be one of <code>vp</code>,
<code>grob</code> or <code>ref</code>. This determines whether we are trying to
get the IDs of a grob or a viewport or a referenced object like a
fill pattern.
</p>
</td></tr>
<tr><td><code id="Retrieve+2B20Names+2B20Mapped+2B20to+2B20SVG+2B20IDs+2B2C+2B20CSS+2B20Selectors+2B20and+2B20XPath+2B20Expressions_+3A_result">result</code></td>
<td>

<p>The type of output we want. <code>id</code> gives us SVG element
IDs. <code>selector</code> gives us CSS selectors. <code>xpath</code> gives us
XPath expressions.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to generate unique names for SVG IDs, gridSVG output will not
produce the same names as are visible on the grid display list. This
function retrieves the SVG IDs associated with grob and viewport
names. To use this function first requires importing mapping
information, see <code><a href="#topic+gridSVGMappings">gridSVGMappings</a></code>.
</p>
<p>To make using results easier with existing JavaScript libraries and R
packages, CSS selectors and XPath expressions can be returned. This is
the case when <code>result</code> is specified as one of <code>selector</code> or
<code>xpath</code>. These are targeted to match just the SVG element itself,
nothing more.
</p>


<h3>Value</h3>

<p>A character vector representing values that can target specific SVG
output.
</p>


<h3>Author(s)</h3>

<p>Simon Potter
</p>

<hr>
<h2 id='setSVGoptions'> Get and Set Global Options </h2><span id='topic+setSVGoptions'></span><span id='topic+getSVGoption'></span><span id='topic+getSVGoptions'></span>

<h3>Description</h3>

<p>Provides access to a predefined set of global options for the
<span class="pkg">gridSVG</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSVGoption(name)
getSVGoptions()
setSVGoptions(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setSVGoptions_+3A_name">name</code></td>
<td>
<p> The name of one option. </p>
</td></tr>
<tr><td><code id="setSVGoptions_+3A_...">...</code></td>
<td>

<p>Named arguments giving a name, value pair for a new option setting.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The options currently available are:
</p>

<ul>
<li> <p><code>id.sep</code> which controls the separator used between the
grob name and the suffix number when <span class="pkg">gridSVG</span> generates
id values for SVG elements.
</p>
</li>
<li> <p><code>gPath.sep</code> which controls the separator used between
elements of a grid <code>gPath</code>.
</p>
</li>
<li> <p><code>vpPath.sep</code> which controls the separator used between
elements of a grid <code>vpPath</code>.
</p>
</li></ul>



<h3>Value</h3>

<p><code>getSVGoption()</code> returns at most one option setting.
<code>getSVGoptions()</code> returns all option settings.
<code>setSVGoptions()</code> returns a list of previous option settings
for the options that were changed.
</p>


<h3>Author(s)</h3>

<p> Paul Murrell </p>


<h3>See Also</h3>

 <p><code><a href="#topic+grid.export">grid.export</a></code> </p>

<hr>
<h2 id='svg-internal'>Internal gridSVG Functions</h2><span id='topic+svgOpen'></span><span id='topic+svgClose'></span><span id='topic+svgStartGroup'></span><span id='topic+svgEndGroup'></span><span id='topic+svgRaster'></span><span id='topic+svgRect'></span><span id='topic+svgLines'></span><span id='topic+svgPath'></span><span id='topic+svgPolygon'></span><span id='topic+svgText'></span><span id='topic+svgCircle'></span><span id='topic+svgScript'></span><span id='topic+svgAnimate'></span><span id='topic+svgStartLink'></span><span id='topic+svgEndLink'></span><span id='topic+svgStyle'></span><span id='topic+svgStartElement'></span><span id='topic+svgEndElement'></span>

<h3>Description</h3>

<p>Some functions you can call, but I'm not documenting (yet).
</p>

<hr>
<h2 id='viewportCreate'>
Recreate a viewport from imported coordinate information.
</h2><span id='topic+viewportCreate'></span>

<h3>Description</h3>

<p>Creates a viewport object that is positioned in the same location as a
previously exported viewport.
</p>
<p>The purpose of this function is so that we can recreate content for
later manipulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>viewportCreate(vpname, newname = NULL,
               vpPath.sep = getSVGoption("vpPath.sep"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="viewportCreate_+3A_vpname">vpname</code></td>
<td>

<p>The name of the viewport to be recreated, as stored in
coordinate information. This is most likely a viewport path.
</p>
</td></tr>
<tr><td><code id="viewportCreate_+3A_newname">newname</code></td>
<td>

<p>The name that is going to be assigned to the viewport as it is
re-created. If this parameter is <code>NULL</code>, then the name is taken
to be the last viewport in listed in <code>vpname</code> (because it is
usually a viewport path).
</p>
</td></tr>
<tr><td><code id="viewportCreate_+3A_vppath.sep">vpPath.sep</code></td>
<td>

<p>The viewport path separator that was used for <code>vpname</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to use this function, coordinate information must be
available to <code>gridSVG</code>. This means that viewport information must
be imported using <code><a href="#topic+gridSVGCoords">gridSVGCoords</a></code>.
</p>
<p>The <code>ROOT</code> viewport must also have coordinate information
imported because the created viewport is positioned relative to this.
</p>


<h3>Value</h3>

<p>A viewport object.
</p>


<h3>Author(s)</h3>

<p>Simon Potter
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  require(grid)

  grid.newpage()

  # Pushing a new VP to draw a rect within
  pushViewport(viewport(x = unit(0.3, "npc"), y = unit(0.2, "npc"),
                        width = unit(0.1, "npc"), height = unit(0.3, "npc"),
                        xscale = c(0, 20), yscale = c(0, 10),
                        name = "testVP"))
  grid.rect()
  grid.export("create-test.svg", exportCoords = "file")

  # Importing coordinate information
  gridSVGCoords(readCoordsJS("create-test.svg.coords.js"))

  # This should appear to be the same rect
  grid.newpage()
  pushViewport(viewportCreate("testVP.1"))
  grid.rect()

  # Let's see if the scales are accurate, should be:
  # xscale: [0, 20]
  # yscale: [0, 10]
  current.viewport()$xscale
  current.viewport()$yscale

## End(Not run)</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
