<!DOCTYPE html><html><head><title>Help for package matsbyname</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {matsbyname}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#matsbyname-package'><p>matsbyname: An Implementation of Matrix Mathematics that Respects Row and Column Names</p></a></li>
<li><a href='#+3A+3D'><p>Assignment</p></a></li>
<li><a href='#.data'><p>Data pronoun</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#abs_byname'><p>Absolute value of matrix elements</p></a></li>
<li><a href='#aggregate_byname'><p>Aggregate rows and columns in a matrix</p></a></li>
<li><a href='#aggregate_pieces_byname'><p>Aggregate a matrix by pieces of row and/or column names</p></a></li>
<li><a href='#aggregate_to_pref_suff_byname'><p>Aggregate a matrix to prefixes or suffixes of row and/or column names</p></a></li>
<li><a href='#aggregation_map_helpers'><p>Aggregation map conversions</p></a></li>
<li><a href='#all_byname'><p>Are all matrix elements <code>TRUE</code>?</p></a></li>
<li><a href='#and_byname'><p>And &quot;by name&quot;</p></a></li>
<li><a href='#any_byname'><p>Are any matrix elements <code>TRUE</code>?</p></a></li>
<li><a href='#binaryapply_byname'><p>Apply a binary function &quot;by name&quot;</p></a></li>
<li><a href='#clean_byname'><p>Clean (delete) rows or columns of matrices that contain exclusively <code>clean_value</code></p></a></li>
<li><a href='#colprods_byname'><p>Column products, sorted by name</p></a></li>
<li><a href='#colsums_byname'><p>Column sums, sorted by name</p></a></li>
<li><a href='#coltype'><p>Column type</p></a></li>
<li><a href='#compare_byname'><p>Compare matrix entries to a value</p></a></li>
<li><a href='#complete_and_sort'><p>Complete matrices relative to one another and sort into same row, column order</p></a></li>
<li><a href='#complete_rows_cols'><p>Complete rows and columns in one matrix relative to another</p></a></li>
<li><a href='#count_vals_byname'><p>Count the number of matrix entries that meet a criterion</p></a></li>
<li><a href='#count_vals_incols_byname'><p>Count the number of matrix entries in columns that meet a criterion</p></a></li>
<li><a href='#count_vals_inrows_byname'><p>Count the number of matrix entries in rows that meet a criterion</p></a></li>
<li><a href='#create_colvec_byname'><p>Create column vectors from data</p></a></li>
<li><a href='#create_matrix_byname'><p>Create a &quot;byname&quot; matrix from a vector</p></a></li>
<li><a href='#create_rowvec_byname'><p>Create row vectors from data</p></a></li>
<li><a href='#cumapply_byname'><p>Apply a function cumulatively to a list of matrices or numbers</p></a></li>
<li><a href='#cumprod_byname'><p>Cumulative element-product that respects row and column names</p></a></li>
<li><a href='#cumsum_byname'><p>Cumulative sum that respects row and column names</p></a></li>
<li><a href='#difference_byname'><p>Name-wise subtraction of matrices</p></a></li>
<li><a href='#eigenvalues_byname'><p>Calculate eigenvalues of a matrix</p></a></li>
<li><a href='#eigenvectors_byname'><p>Calculate eigenvectors of a matrix</p></a></li>
<li><a href='#elementapply_byname'><p>Apply a function to an element of a matrix specified by rows and columns</p></a></li>
<li><a href='#equal_byname'><p>Compare two matrices &quot;by name&quot; for equality</p></a></li>
<li><a href='#exp_byname'><p>Exponential of matrix elements</p></a></li>
<li><a href='#fractionize_byname'><p>Compute fractions of matrix entries</p></a></li>
<li><a href='#geometricmean_byname'><p>Name- and element-wise geometric mean of two matrices.</p></a></li>
<li><a href='#getcolnames_byname'><p>Gets column names</p></a></li>
<li><a href='#getrownames_byname'><p>Gets row names</p></a></li>
<li><a href='#getzerorowcolnames_byname'><p>Names of zero rows and columns</p></a></li>
<li><a href='#hadamardproduct_byname'><p>Name-wise matrix Hadamard multiplication</p></a></li>
<li><a href='#hatinv_byname'><p>Hatize and invert a vector</p></a></li>
<li><a href='#hatize_byname'><p>Creates a diagonal &quot;hat&quot; matrix from a vector</p></a></li>
<li><a href='#identical_byname'><p>Compare two matrices &quot;by name&quot; for exact equality</p></a></li>
<li><a href='#identize_byname'><p>Named identity matrix or vector</p></a></li>
<li><a href='#Iminus_byname'><p>Subtract a matrix with named rows and columns from a suitably named and sized identity matrix (<code>I</code>)</p></a></li>
<li><a href='#invert_byname'><p>Invert a matrix</p></a></li>
<li><a href='#is_matrix_or_Matrix'><p>Tells whether an object is one of a matrix or a Matrix</p></a></li>
<li><a href='#is.Matrix'><p>Is an object a Matrix?</p></a></li>
<li><a href='#iszero_byname'><p>Test whether this is the zero matrix</p></a></li>
<li><a href='#kvec_from_template_byname'><p>Create a constant vector from matrix <code>a</code></p></a></li>
<li><a href='#list_of_rows_or_cols'><p>Named list of rows or columns of matrices</p></a></li>
<li><a href='#log_byname'><p>Logarithm of matrix elements</p></a></li>
<li><a href='#logarithmicmean_byname'><p>Name- and element-wise logarithmic mean of matrices</p></a></li>
<li><a href='#logmean'><p>Logarithmic mean of two numbers</p></a></li>
<li><a href='#margin_from_types_byname'><p>Translate row and column types to integer margins</p></a></li>
<li><a href='#matricize_byname'><p>Matricize a vector</p></a></li>
<li><a href='#Matrix'><p>Create a Matrix amenable to use in the <code>matsbyname</code> package</p></a></li>
<li><a href='#matrixproduct_byname'><p>Name-wise matrix multiplication</p></a></li>
<li><a href='#mean_byname'><p>Name- and element-wise arithmetic mean of matrices</p></a></li>
<li><a href='#naryapply_byname'><p>Apply a function &quot;by name&quot; to any number of operands</p></a></li>
<li><a href='#naryapplylogical_byname'><p>Apply a function logically to numbers, matrices, or lists of numbers or matrices</p></a></li>
<li><a href='#ncol_byname'><p>Get the number of columns in a &quot;byname&quot; matrix.</p></a></li>
<li><a href='#nrow_byname'><p>Get the number of rows in a &quot;byname&quot; matrix.</p></a></li>
<li><a href='#organize_args'><p>Organize binary arguments</p></a></li>
<li><a href='#pow_byname'><p>Powers of matrix elements</p></a></li>
<li><a href='#prep_vector_arg'><p>Prepare a vector argument</p></a></li>
<li><a href='#prepare_.FUNdots'><p>Prepare the <code>.FUNdots</code> argument for <code style="white-space: pre;">&#8288;*apply_byname&#8288;</code> functions.</p></a></li>
<li><a href='#prodall_byname'><p>Product of all elements in a matrix</p></a></li>
<li><a href='#quotient_byname'><p>Name-wise matrix element division</p></a></li>
<li><a href='#rename_to_piece_byname'><p>Rename matrix rows and columns by piece of row or column names</p></a></li>
<li><a href='#rename_to_pref_suff_byname'><p>Rename matrix rows and columns by prefix and suffix</p></a></li>
<li><a href='#replaceNaN_byname'><p>Replace <code>NaN</code> values with a value</p></a></li>
<li><a href='#rowprods_byname'><p>Row products, sorted by name</p></a></li>
<li><a href='#rowsums_byname'><p>Row sums, sorted by name</p></a></li>
<li><a href='#rowtype'><p>Row type</p></a></li>
<li><a href='#samestructure_byname'><p>Test whether matrices or lists of matrices have same structure</p></a></li>
<li><a href='#select_cols_byname'><p>Select columns of a matrix (or list of matrices) by name</p></a></li>
<li><a href='#select_rowcol_piece_byname'><p>Select or remove rows or columns based on pieces of the names.</p></a></li>
<li><a href='#select_rows_byname'><p>Select (or de-select) rows of a matrix (or list of matrices) by name</p></a></li>
<li><a href='#selectzerocols_byname'><p>Select zero columns</p></a></li>
<li><a href='#selectzerorows_byname'><p>Select zero rows</p></a></li>
<li><a href='#setcolnames_byname'><p>Sets column names</p></a></li>
<li><a href='#setcoltype'><p>Sets column type for a matrix or a list of matrices</p></a></li>
<li><a href='#setrownames_byname'><p>Sets row names</p></a></li>
<li><a href='#setrowtype'><p>Sets row type for a matrix or a list of matrices</p></a></li>
<li><a href='#sort_rows_cols'><p>Sorts rows and columns of a matrix</p></a></li>
<li><a href='#sum_byname'><p>Name-wise addition of matrices</p></a></li>
<li><a href='#sumall_byname'><p>Sum of all elements in a matrix</p></a></li>
<li><a href='#svd_byname'><p>Calculate the singular value decomposition of a matrix</p></a></li>
<li><a href='#switch_notation_byname'><p>Change row and column name notation</p></a></li>
<li><a href='#transpose_byname'><p>Transpose a matrix by name</p></a></li>
<li><a href='#trim_rows_cols'><p>Trim rows and/or columns from a matrix</p></a></li>
<li><a href='#unaryapply_byname'><p>Apply a unary function by name</p></a></li>
<li><a href='#vec_from_store_byname'><p>Create a vector with labels from a matrix and values from a vector store</p></a></li>
<li><a href='#vectorize_byname'><p>Vectorize a matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>An Implementation of Matrix Mathematics that Respects Row and
Column Names</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.10</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-12</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthew Heun &lt;matthew.heun@me.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of matrix mathematics wherein operations are performed "by name."</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>Config/testthat/start-first:</td>
<td>Binary, Utilities, Unary</td>
</tr>
<tr>
<td>Imports:</td>
<td>assertthat, dplyr, lifecycle, Matrix, magrittr, matrixcalc,
methods, purrr, RCLabels, rlang, tibble</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bench, covr, Hmisc, knitr, matsindf, rmarkdown, spelling,
testthat (&ge; 3.0.0), tidyr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/MatthewHeun/matsbyname">https://github.com/MatthewHeun/matsbyname</a>,
<a href="https://matthewheun.github.io/matsbyname/">https://matthewheun.github.io/matsbyname/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/MatthewHeun/matsbyname/issues">https://github.com/MatthewHeun/matsbyname/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-12 19:57:36 UTC; mkh2</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthew Heun <a href="https://orcid.org/0000-0002-7438-214X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-12 21:20:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='matsbyname-package'>matsbyname: An Implementation of Matrix Mathematics that Respects Row and Column Names</h2><span id='topic+matsbyname'></span><span id='topic+matsbyname-package'></span>

<h3>Description</h3>

<p>An implementation of matrix mathematics wherein operations are performed &quot;by name.&quot;
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Matthew Heun <a href="mailto:matthew.heun@me.com">matthew.heun@me.com</a> (<a href="https://orcid.org/0000-0002-7438-214X">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/MatthewHeun/matsbyname">https://github.com/MatthewHeun/matsbyname</a>
</p>
</li>
<li> <p><a href="https://matthewheun.github.io/matsbyname/">https://matthewheun.github.io/matsbyname/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/MatthewHeun/matsbyname/issues">https://github.com/MatthewHeun/matsbyname/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+3A+3D'>Assignment</h2><span id='topic++3A+3D'></span>

<h3>Description</h3>

<p>See <code>rlang::<a href="rlang.html#topic++3A+3D">:=</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x := y
</code></pre>

<hr>
<h2 id='.data'>Data pronoun</h2><span id='topic+.data'></span>

<h3>Description</h3>

<p>See <a href="rlang.html#topic+dot-data">rlang::.data</a> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.data
</code></pre>

<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic++25+3E+25">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='abs_byname'>Absolute value of matrix elements</h2><span id='topic+abs_byname'></span>

<h3>Description</h3>

<p>Absolute value of matrix elements
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abs_byname(a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abs_byname_+3A_a">a</code></td>
<td>
<p>A matrix or list of matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>a</code> with each element replaced by its absolute value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>abs_byname(1)
abs_byname(-1)
m &lt;- matrix(c(-10,1,1,100), nrow = 2, dimnames = list(paste0("i", 1:2), paste0("c", 1:2))) %&gt;%
  setrowtype("Industry") %&gt;% setcoltype("Commodity")
m
abs_byname(m)
</code></pre>

<hr>
<h2 id='aggregate_byname'>Aggregate rows and columns in a matrix</h2><span id='topic+aggregate_byname'></span>

<h3>Description</h3>

<p>Rows (<code>margin = 1</code>), columns (<code>margin = 2</code>), or both (<code>margin = c(1, 2)</code>, the default)
are aggregated according to <code>aggregation_map</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregate_byname(
  a,
  aggregation_map = NULL,
  margin = c(1, 2),
  pattern_type = "exact"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregate_byname_+3A_a">a</code></td>
<td>
<p>A matrix or list of matrices whose rows or columns are to be aggregated.</p>
</td></tr>
<tr><td><code id="aggregate_byname_+3A_aggregation_map">aggregation_map</code></td>
<td>
<p>A named list of rows or columns to be aggregated (or <code>NULL</code>). See <code>details</code>.</p>
</td></tr>
<tr><td><code id="aggregate_byname_+3A_margin">margin</code></td>
<td>
<p><code>1</code>, <code>2</code>, or <code>c(1, 2)</code> for row aggregation, column aggregation, or both.
As a string, <code>margin</code> can be a row or column type.
Default is <code>c(1, 2)</code>.</p>
</td></tr>
<tr><td><code id="aggregate_byname_+3A_pattern_type">pattern_type</code></td>
<td>
<p>See <code>RCLabels::make_or_pattern()</code>.
Default is &quot;exact&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>aggregation_map</code> is <code>NULL</code> (the default),
rows (or columns or both) of same name are aggregated together.
</p>
<p>If <code>aggregation_map</code> is not <code>NULL</code>, it must be a named list.
The name of each <code>aggregation_map</code> item is the name of a row or column in output
that will contain the specified aggregation.
The value of each item in <code>aggregation_map</code> must be a vector of names of rows or columns in <code>a</code>.
The names in the value are aggregated and inserted into the output with the name of the value.
For example <code>aggregation_map = list(new_row = c("r1", "r2"))</code>
will aggregate rows &quot;r1&quot; and &quot;r2&quot;, delete rows &quot;r1&quot; and &quot;r2&quot;, and insert a new row
whose name is &quot;new_row&quot; and whose value is the sum of rows &quot;r1&quot; and &quot;r2'.
</p>
<p>The values in the <code>aggregation_map</code> are interpreted as regular expressions, and
they are escaped using <code>Hmisc::escapeRegex()</code> prior to use.
</p>
<p><code>margin</code> can be a string, in which case it is interpreted as a row or column type.
If a string <code>margin</code> does not match a row or column type,
<code>a</code> is returned unmodified.
</p>
<p>Note that aggregation on one margin only will sort only the aggregated margin, because
the other margin is not guaranteed to have unique names.
</p>


<h3>Value</h3>

<p>A version of <code>a</code> with aggregated rows and/or columns
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(tibble)
m &lt;- matrix(1:9, byrow = TRUE, nrow = 3, 
            dimnames = list(c("r2", "r1", "r1"), c("c2", "c1", "c1"))) %&gt;% 
  setrowtype("rows") %&gt;% setcoltype("cols")
# Aggregate all rows by establishing an aggregation map (`am`)
am &lt;- list(new_row = c("r1", "r2"))
aggregate_byname(m, aggregation_map = am, margin = 1)
# aggregate_byname() also works with lists and in data frames
m1 &lt;- matrix(42, nrow = 1, dimnames = list(c("r1"), c("c1")))
m2 &lt;- matrix(1:4, byrow = TRUE, nrow = 2, 
             dimnames = list(c("a", "a"), c("a", "a")))
m3 &lt;- matrix(1:9, byrow = TRUE, nrow = 3, 
             dimnames = list(c("r2", "r1", "r1"), c("c2", "c1", "c1")))
DF &lt;- tibble(m = list(m1, m1, m1, m2, m2, m2, m3, m3, m3), 
             margin = list(1, 2, c(1,2), 1, 2, c(1, 2), 1, 2, c(1, 2))) %&gt;% 
  mutate(
    aggregated = aggregate_byname(m, margin = margin), 
  )
m1
DF$aggregated[[1]] # by rows
DF$aggregated[[2]] # by cols
DF$aggregated[[3]] # by rows and cols
m2
DF$aggregated[[4]] # by rows
DF$aggregated[[5]] # by cols
DF$aggregated[[6]] # by rows and cols
m3
DF$aggregated[[7]] # by rows
DF$aggregated[[8]] # by cols
DF$aggregated[[9]] # by rows and cols
</code></pre>

<hr>
<h2 id='aggregate_pieces_byname'>Aggregate a matrix by pieces of row and/or column names</h2><span id='topic+aggregate_pieces_byname'></span>

<h3>Description</h3>

<p>Aggregate a matrix (or list of matrices or a column in a <code>matsindf</code> data frame)
by pieces of the row and column names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregate_pieces_byname(
  a,
  piece,
  margin = list(c(1, 2)),
  inf_notation = TRUE,
  notation = list(RCLabels::notations_list),
  choose_most_specific = FALSE,
  prepositions = list(RCLabels::prepositions_list),
  aggregation_map = NULL,
  pattern_type = "exact"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregate_pieces_byname_+3A_a">a</code></td>
<td>
<p>A matrix or list of matrices.</p>
</td></tr>
<tr><td><code id="aggregate_pieces_byname_+3A_piece">piece</code></td>
<td>
<p>A character string indicating which piece of the row or column names to retain,
one of &quot;noun&quot;, &quot;pps&quot;, &quot;pref&quot; or &quot;suff&quot;, or a preposition,
indicating which part of the row or column name is to be retained.</p>
</td></tr>
<tr><td><code id="aggregate_pieces_byname_+3A_margin">margin</code></td>
<td>
<p>As a character, the row type or column type to be renamed.
As an integer, the margin to be renamed.
Default is <code>c(1, 2)</code>, meaning that both
rows (<code>margin = 1</code>) and columns (<code>margin = 2</code>)
will be renamed.</p>
</td></tr>
<tr><td><code id="aggregate_pieces_byname_+3A_inf_notation">inf_notation</code></td>
<td>
<p>A boolean that tells whether to infer notation.
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="aggregate_pieces_byname_+3A_notation">notation</code></td>
<td>
<p>The notation used for row and column labels.
Default is <code>list(RCLabels::notations_list)</code>.
The default value is wrapped in a list,
because <code>RCLabels::notations_list</code> is, itself, a list.
See <code>RCLabels</code>.</p>
</td></tr>
<tr><td><code id="aggregate_pieces_byname_+3A_choose_most_specific">choose_most_specific</code></td>
<td>
<p>A boolean that indicates whether the most-specific notation
will be inferred when more than one of <code>notation</code> matches
a row or column label
and <code>allow_multiple = FALSE</code>.
When <code>FALSE</code>, the first matching notation in <code>notations</code>
is returned when <code>allow_multiple = FALSE</code>.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="aggregate_pieces_byname_+3A_prepositions">prepositions</code></td>
<td>
<p>Prepositions that can be used in the row and column label.
Default is <code>RCLabels::prepositions_list</code>.</p>
</td></tr>
<tr><td><code id="aggregate_pieces_byname_+3A_aggregation_map">aggregation_map</code></td>
<td>
<p>A named list of rows or columns to be aggregated (or <code>NULL</code>). See <code>details</code>.</p>
</td></tr>
<tr><td><code id="aggregate_pieces_byname_+3A_pattern_type">pattern_type</code></td>
<td>
<p>See <code>RCLabels::make_or_pattern()</code>.
Default is &quot;exact&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a convenience function that bundles two others
for common use cases:
<code>rename_to_piece_byname()</code> followed by <code>aggregate_byname()</code>.
Note that after renaming to the piece,
there may be rows or columns that are identically named.
If those identically named names aren't included in the <code>aggregation_map</code>,
an error will result.
So, <code>aggregate_byname()</code> is called twice;
first with <code>aggregation_map = NULL</code> to sweep up any
rows or columns that are identically named
after renaming and
second with <code>aggregation_map = aggregation_map</code> to
sum the desired rows or columns.
See examples.
</p>
<p>When <code>aggregation_map</code> is <code>NULL</code> (the default),
rows (or columns or both) of same name are aggregated together.
</p>
<p>If <code>aggregation_map</code> is not <code>NULL</code>, it must be a named list.
The name of each <code>aggregation_map</code> item is the name of a row or column in output
that will contain the specified aggregation.
The value of each item in <code>aggregation_map</code> must be a vector of names of rows or columns in <code>a</code>.
The names in the value are aggregated and inserted into the output with the name of the value.
For example <code>aggregation_map = list(new_row = c("r1", "r2"))</code>
will aggregate rows &quot;r1&quot; and &quot;r2&quot;, delete rows &quot;r1&quot; and &quot;r2&quot;, and insert a new row
whose name is &quot;new_row&quot; and whose value is the sum of rows &quot;r1&quot; and &quot;r2'.
</p>
<p>The values in the <code>aggregation_map</code> are interpreted as regular expressions, and
they are escaped using <code>Hmisc::escapeRegex()</code> prior to use.
</p>
<p><code>aggregation_map</code> should aggregate by pieces,
not by the full, original row and/or column names.
</p>


<h3>Value</h3>

<p>A version of <code>a</code> with rows and/or columns aggregated according to <code>aggregation_map</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- matrix(c(1, 2, 3, 
              4, 5, 6), nrow = 2, ncol = 3, byrow = TRUE, 
            dimnames = list(c("a [from b]", "c [from d]"), 
                            c("e [from f]", "g [from h]", "i [from j]")))
a %&gt;%
  aggregate_pieces_byname(piece = "suff", 
                          notation = RCLabels::from_notation,
                          aggregation_map = list(rows = c("b", "d"), 
                                                 cols = c("h", "j")))
m &lt;- matrix(c(1, 0, 0, 
              0, 1, 1, 
              0, 1, 1), nrow = 3, ncol = 3, byrow = TRUE, 
            dimnames = list(c("Gasoline [from Oil refineries]", 
                              "Electricity [from Main activity producer electricity plants]", 
                              "Electricity [from Hydro]"),
                            c("Automobiles", "LED lamps", "CFL lamps"))) %&gt;%
  setrowtype("Product") %&gt;% setcoltype("Industry")
mT &lt;- transpose_byname(m)
# Aggregate the "Electricity" rows.
aggregate_pieces_byname(m, piece = "noun", margin = "Product",
                        notation = RCLabels::bracket_notation)
# Also works in a list.
aggregate_pieces_byname(a = list(m, mT), piece = "noun", 
                        margin = "Product",
                        notation = RCLabels::bracket_notation)
# Use an aggregation map
aggregate_pieces_byname(a = list(m, mT), piece = "noun", 
                        margin = "Product",
                        aggregation_map = list(list(final = c("Electricity", "Gasoline"))),
                        notation = RCLabels::bracket_notation)
# Also works in a data frame.
df &lt;- tibble::tibble(m = list(m, mT), 
                     pce = "noun",
                     mgn = "Product",
                     agg_map = list(list(final = c("Electricity", "Gasoline"))), 
                     notn = list(RCLabels::bracket_notation)) %&gt;%
  dplyr::mutate(
    agg = aggregate_pieces_byname(a = m, piece = pce, margin = mgn, 
                                  aggregation_map = agg_map,
                                  notation = notn)
  )
df$agg
# Works when renaming to the piece results in identical row or col names.
b &lt;- matrix(1:6, nrow = 3, ncol = 2, 
            dimnames = list(c("a [from b]", "c [from d]", "c [from e]"), 
                            c("c1", "c2")))
b
# This aggregation works, because the "c" rows
# are aggregated before applying the aggregation_map,
# which, itself, does NOT aggregate the "c" rows.
b %&gt;% 
  aggregate_pieces_byname(piece = "noun",
                          margin = 1,
                          inf_notation = FALSE, 
                          notation = RCLabels::bracket_notation, 
                          aggregation_map = list(f = c("a", "b")))
</code></pre>

<hr>
<h2 id='aggregate_to_pref_suff_byname'>Aggregate a matrix to prefixes or suffixes of row and/or column names</h2><span id='topic+aggregate_to_pref_suff_byname'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
Row and column names are often constructed in the form
<code>prefix_start</code> <code>prefix</code> <code>prefix_end</code> <code>suffix_start</code> <code>suffix</code> <code>suffix_end</code>
and described by a notation vector.
(See <code>notation_vec()</code>.)
This function performs aggregation by prefix or suffix according to a notation vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregate_to_pref_suff_byname(
  a,
  aggregation_map = NULL,
  keep,
  margin = c(1, 2),
  notation,
  pattern_type = "exact"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregate_to_pref_suff_byname_+3A_a">a</code></td>
<td>
<p>A matrix of list of matrices to be aggregated by prefix or suffix.</p>
</td></tr>
<tr><td><code id="aggregate_to_pref_suff_byname_+3A_aggregation_map">aggregation_map</code></td>
<td>
<p>See <code>aggregate_byname()</code>.</p>
</td></tr>
<tr><td><code id="aggregate_to_pref_suff_byname_+3A_keep">keep</code></td>
<td>
<p>See <code>rename_to_pref_suff_byname()</code></p>
</td></tr>
<tr><td><code id="aggregate_to_pref_suff_byname_+3A_margin">margin</code></td>
<td>
<p>the dimension over which aggregation is to be performed; <code>1</code> for rows, <code>2</code> for columns, or <code>c(1, 2)</code> for both.</p>
</td></tr>
<tr><td><code id="aggregate_to_pref_suff_byname_+3A_notation">notation</code></td>
<td>
<p>See <code>notation_vec()</code>.</p>
</td></tr>
<tr><td><code id="aggregate_to_pref_suff_byname_+3A_pattern_type">pattern_type</code></td>
<td>
<p>See <code>aggregate_byname()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a convenience function, as it bundles sequential calls to two helper functions,
<code>rename_to_pref_suff_byname()</code> and <code>aggregate_byname()</code>.
All arguments are passed to the helper functions.
</p>


<h3>Value</h3>

<p>An aggregated version of <code>a</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This function is superseded. 
# Instead, use `aggregate_pieces_byname()`.
# For example:
m &lt;- matrix((1:9), byrow = TRUE, nrow = 3, 
            dimnames = list(c("r1 -&gt; b", "r2 -&gt; b", "r3 -&gt; a"), c("c1 -&gt; z", "c2 -&gt; y", "c3 -&gt; y")))
m
aggregate_pieces_byname(m, piece = "pref", notation = RCLabels::arrow_notation)
aggregate_pieces_byname(m, piece = "suff", notation = RCLabels::arrow_notation)

# Original examples:
# Aggregation by prefixes does nothing more than rename, because all prefixes are different.
# Doing renaming like this (without also aggregating) is potentially dangerous, because  
# some rows and some columns could end up with same names.
aggregate_to_pref_suff_byname(m, keep = "pref", notation = RCLabels::arrow_notation)
# Aggregation by suffix reduces the number of rows and columns, 
# because there are same suffixes in both rows and columns
aggregate_to_pref_suff_byname(m, keep = "suff", notation = RCLabels::arrow_notation)
</code></pre>

<hr>
<h2 id='aggregation_map_helpers'>Aggregation map conversions</h2><span id='topic+aggregation_map_helpers'></span><span id='topic+agg_table_to_agg_map'></span><span id='topic+agg_map_to_agg_table'></span>

<h3>Description</h3>

<p>Aggregation is a many-to-few operation
where specifics are summed to comprise broader categories.
Examples include &quot;John&quot;, &quot;Paul&quot;, &quot;George&quot;, and &quot;Ringo&quot;
aggregated to &quot;Beatles&quot;; and
&quot;Mick&quot;, &quot;Keith&quot;, &quot;Ronnie&quot;, &quot;Bill&quot;, and &quot;Charlie&quot;
aggregated to &quot;Stones&quot;.
An aggregation map is a named list that describes the aggregation
to be performed.
An aggregation map for the examples above is
<code>list(Beatles = c("John", "Paul", "George", "Ringo"),  Stones = c("Mick", "Keith", "Ronnie", "Bill", "Charlie"))</code>
Aggregation maps can be generated from many shapes of data.
These functions assist with translating from different data shapes to
aggregation maps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>agg_table_to_agg_map(.df, few_colname, many_colname)

agg_map_to_agg_table(aggregation_map, few_colname, many_colname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregation_map_helpers_+3A_.df">.df</code></td>
<td>
<p>A data frame from which an aggregation map is to be extracted.</p>
</td></tr>
<tr><td><code id="aggregation_map_helpers_+3A_few_colname">few_colname</code></td>
<td>
<p>The string name of a column in a data frame that corresponds
to the &quot;few&quot; aggregated categories.</p>
</td></tr>
<tr><td><code id="aggregation_map_helpers_+3A_many_colname">many_colname</code></td>
<td>
<p>The string name of a column in a data frame that corresponds
to the &quot;many&quot; specific items that will be aggregated.</p>
</td></tr>
<tr><td><code id="aggregation_map_helpers_+3A_aggregation_map">aggregation_map</code></td>
<td>
<p>An aggregation map to be converted to a data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>agg_table_to_agg_map()</code>, an aggregation map.
For <code>agg_map_to_agg_table()</code>, a <code>data.frame</code>, probably at <code>tibble</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bands &lt;- tibble::tribble(~band, ~members, 
                         "The Beatles", "John", 
                         "The Beatles", "Paul", 
                         "The Beatles", "George", 
                         "The Beatles", "Ringo", 
                         # Rejects duplicates and NA
                         "The Beatles", "Ringo",
                         "The Beatles", NA, 
                         "Rolling Stones", "Mick", 
                         "Rolling Stones", "Keith",
                         "Rolling Stones", "Ronnie",
                         "Rolling Stones", "Bill",
                         "Rolling Stones", "Charlie")
agg_map &lt;- agg_table_to_agg_map(bands, 
                                 few_colname = "band",
                                 many_colname = "members")
agg_map
agg_map_to_agg_table(agg_map, few_colname = "bands", many_colname = "members")
</code></pre>

<hr>
<h2 id='all_byname'>Are all matrix elements <code>TRUE</code>?</h2><span id='topic+all_byname'></span>

<h3>Description</h3>

<p>Tells whether all elements in matrix <code>a</code> are true.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_byname(a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all_byname_+3A_a">a</code></td>
<td>
<p>a matrix or list of matrices</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>a</code> can be a matrix or a list of matrices.
</p>


<h3>Value</h3>

<p><code>TRUE</code> if all elements of <code>a</code> are <code>TRUE</code>, <code>FALSE</code> otherwise
</p>


<h3>Examples</h3>

<pre><code class='language-R'>all_byname(matrix(rep(TRUE, times = 4), nrow = 2, ncol = 2))
all_byname(matrix(c(TRUE, FALSE), nrow = 2, ncol = 1))
</code></pre>

<hr>
<h2 id='and_byname'>And &quot;by name&quot;</h2><span id='topic+and_byname'></span>

<h3>Description</h3>

<p>Operands should be logical, although numerical operands are accepted.
Numerical operands are interpreted as <code>FALSE</code> when <code>0</code> and
<code>TRUE</code> for any other number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>and_byname(..., .summarise = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="and_byname_+3A_...">...</code></td>
<td>
<p>Operands to the logical <code>and</code> function.</p>
</td></tr>
<tr><td><code id="and_byname_+3A_.summarise">.summarise</code></td>
<td>
<p>Tells whether the operation should be accomplished
across lists (<code>FALSE</code>) or down lists (<code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical <code>and</code> applied to the operands.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>and_byname(TRUE)
and_byname(FALSE)
and_byname(list(TRUE, FALSE), list(TRUE, TRUE), list(TRUE, TRUE), list(TRUE, TRUE))
m1 &lt;- matrix(c(TRUE, TRUE, TRUE, FALSE), nrow = 2, ncol = 2, 
  dimnames = list(c("r1", "r2"), c("c1", "c2")))
m2 &lt;- matrix(c(TRUE, FALSE, TRUE, TRUE), nrow = 2, ncol = 2,
  dimnames = list(c("r1", "r2"), c("c1", "c2")))
and_byname(m1, m1)
and_byname(m1, m2)
and_byname(list(m1, m1), list(m1, m1), list(m2, m2))
and_byname(list(m1, m1), list(m1, m1), list(m2, m2), .summarise = TRUE)
</code></pre>

<hr>
<h2 id='any_byname'>Are any matrix elements <code>TRUE</code>?</h2><span id='topic+any_byname'></span>

<h3>Description</h3>

<p>Tells whether any elements in matrix <code>a</code> are true.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>any_byname(a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="any_byname_+3A_a">a</code></td>
<td>
<p>a matrix or list of matrices</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>a</code> can be a matrix or a list of matrices.
</p>


<h3>Value</h3>

<p><code>TRUE</code> if any elements of <code>a</code> are <code>TRUE</code>, <code>FALSE</code> otherwise
</p>


<h3>Examples</h3>

<pre><code class='language-R'>any_byname(matrix(c(TRUE, FALSE), nrow = 2, ncol = 1))
any_byname(matrix(rep(FALSE, times = 4), nrow = 2, ncol = 2))
</code></pre>

<hr>
<h2 id='binaryapply_byname'>Apply a binary function &quot;by name&quot;</h2><span id='topic+binaryapply_byname'></span>

<h3>Description</h3>

<p>If either <code>a</code> or <code>b</code> is missing or <code>NULL</code>,
<code>0</code> is passed to <code>FUN</code> in its place.
Note that if either <code>a</code> and <code>b</code> are lists, elements must be named the same.
The names of list elements of <code>a</code> are applied to the output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binaryapply_byname(
  FUN,
  a,
  b,
  .FUNdots = NULL,
  match_type = c("all", "matmult", "none"),
  set_rowcoltypes = TRUE,
  .organize = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binaryapply_byname_+3A_fun">FUN</code></td>
<td>
<p>a binary function to be applied &quot;by name&quot; to <code>a</code> and <code>b</code>.</p>
</td></tr>
<tr><td><code id="binaryapply_byname_+3A_a">a</code></td>
<td>
<p>the first operand for <code>FUN</code>.</p>
</td></tr>
<tr><td><code id="binaryapply_byname_+3A_b">b</code></td>
<td>
<p>the second operand for <code>FUN</code>.</p>
</td></tr>
<tr><td><code id="binaryapply_byname_+3A_.fundots">.FUNdots</code></td>
<td>
<p>a list of additional named arguments passed to <code>FUN.</code></p>
</td></tr>
<tr><td><code id="binaryapply_byname_+3A_match_type">match_type</code></td>
<td>
<p>one of &quot;all&quot;, &quot;matmult&quot;, or &quot;none&quot;.
When both <code>a</code> and <code>b</code> are matrices,
&quot;all&quot; (the default) indicates that
rowtypes of <code>a</code> must match rowtypes of <code>b</code> and
coltypes of <code>a</code> must match coltypes of <code>b</code>.
If &quot;matmult&quot;,
coltypes of <code>a</code> must match rowtypes of <code>b</code>.
If &quot;none&quot;,
neither coltypes nor rowtypes are checked.</p>
</td></tr>
<tr><td><code id="binaryapply_byname_+3A_set_rowcoltypes">set_rowcoltypes</code></td>
<td>
<p>tells whether to apply row and column types from <code>a</code> and <code>b</code>
to the output.
Set <code>TRUE</code> (the default) to apply row and column types to the output.
Set <code>FALSE</code>, to <em>not</em> apply row and column types to the output.</p>
</td></tr>
<tr><td><code id="binaryapply_byname_+3A_.organize">.organize</code></td>
<td>
<p>a boolean that tells whether or not to automatically
complete <code>a</code> and <code>b</code> relative to each other and
sort the rows and columns of the completed matrices.
Normally, this should be <code>TRUE</code> (the default).
However, if <code>FUN</code> takes over this responsibility, set to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the result of applying <code>FUN</code> &quot;by name&quot; to <code>a</code> and <code>b</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>productnames &lt;- c("p1", "p2")
industrynames &lt;- c("i1", "i2")
U &lt;- matrix(1:4, ncol = 2, dimnames = list(productnames, industrynames)) %&gt;%
  setrowtype("Products") %&gt;% setcoltype("Industries")
Y &lt;- matrix(1:4, ncol = 2, dimnames = list(rev(productnames), rev(industrynames))) %&gt;%
  setrowtype("Products") %&gt;% setcoltype("Industries")
sum_byname(U, Y)
binaryapply_byname(`+`, U, Y)
</code></pre>

<hr>
<h2 id='clean_byname'>Clean (delete) rows or columns of matrices that contain exclusively <code>clean_value</code></h2><span id='topic+clean_byname'></span>

<h3>Description</h3>

<p>Cleaning is performed when all entries in a row or column or both, depending on the value of <code>margin</code>,
are within <code style="white-space: pre;">&#8288;+/- tol&#8288;</code> of <code>clean_value</code>.
Internally, values are deemed within +/- of tol when
<code>abs(x - clean_value) &lt;= tol</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_byname(a, margin = c(1, 2), clean_value = 0, tol = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean_byname_+3A_a">a</code></td>
<td>
<p>The matrix to be cleaned.</p>
</td></tr>
<tr><td><code id="clean_byname_+3A_margin">margin</code></td>
<td>
<p>The dimension over which cleaning should occur, <code>1</code> for rows, <code>2</code> for columns,
or <code>c(1, 2)</code> for both rows and columns.
Default is <code>c(1, 2)</code>.</p>
</td></tr>
<tr><td><code id="clean_byname_+3A_clean_value">clean_value</code></td>
<td>
<p>The undesirable value.
Default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="clean_byname_+3A_tol">tol</code></td>
<td>
<p>The tolerance with which any value is deemed equal to <code>clean_value</code>.
Default is <code>0</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If there is concern about machine precision, you might want to call this function with
<code>tol = .Machine$double.eps</code>.
</p>
<p>When a row (when <code>margin = 1</code>) or a column (when <code>margin = 2</code>)
contains exclusively <code>clean_value</code> (within <code>tol</code>), the row or column is deleted from the matrix.
</p>


<h3>Value</h3>

<p>A &quot;cleaned&quot; matrix, expunged of rows or columns that contain exclusively <code>clean_value.</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(c(-20, 1, -20, 2), nrow = 2, dimnames = list(c("r1", "r2"), c("c1", "c2")))
m
m %&gt;% clean_byname(margin = 1, clean_value = -20) # Eliminates -20, -20 row
# Nothing cleaned, because no columns contain all 0's (the default clean_value).
m %&gt;% clean_byname(margin = 2) 
# Also works with lists
list(m, m) %&gt;% clean_byname(margin = 1, clean_value = -20)
# Also works with data frames
DF &lt;- data.frame(m = I(list()))
DF[[1,"m"]] &lt;- m
DF[[2,"m"]] &lt;- m
DF %&gt;% clean_byname(margin = 1, clean_value = -20)
m2 &lt;- matrix(c(-20, -20, 0, -20, -20, 0, -20, -20, -20), nrow = 3,
             dimnames = list(c("r1", "r2", "r3"), c("c1", "c2", "c3")) )
m2
clean_byname(m2, margin = c(1,2), clean_value = -20)
DF2 &lt;- data.frame(m2 = I(list()))
DF2[[1, "m2"]] &lt;- m2
DF2[[2, "m2"]] &lt;- m2
DF2 %&gt;% clean_byname(margin = c(1, 2), clean_value = -20)
</code></pre>

<hr>
<h2 id='colprods_byname'>Column products, sorted by name</h2><span id='topic+colprods_byname'></span>

<h3>Description</h3>

<p>Calculates column products (the product of all elements in a column) for a matrix.
An optional <code>rowname</code> for the resulting row vector can be supplied.
If <code>rowname</code> is <code>NULL</code> or <code>NA</code> (the default),
the row name is set to the row type as given by <code>rowtype(a)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colprods_byname(a, rowname = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colprods_byname_+3A_a">a</code></td>
<td>
<p>A matrix or data frame from which column products are desired.</p>
</td></tr>
<tr><td><code id="colprods_byname_+3A_rowname">rowname</code></td>
<td>
<p>The Name of the output row containing column products.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a row vector of type <code>matrix</code> containing the column products of <code>a</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
M &lt;- matrix(c(1:6), nrow = 2, dimnames = list(paste0("i", 1:2), paste0("c", 3:1))) %&gt;%
  setrowtype("Industries") %&gt;% setcoltype("Commodities")
colprods_byname(M)
colprods_byname(M, rowname = "E.ktoe")
M %&gt;% colprods_byname %&gt;% rowprods_byname
# This also works with lists
colprods_byname(list(M, M))
colprods_byname(list(M, M), rowname = "E.ktoe")
colprods_byname(list(M, M), rowname = NA)
colprods_byname(list(M, M), rowname = NULL)
DF &lt;- data.frame(M = I(list()))
DF[[1,"M"]] &lt;- M
DF[[2,"M"]] &lt;- M
colprods_byname(DF$M[[1]])
colprods_byname(DF$M)
colprods_byname(DF$M, "prods")
res &lt;- DF %&gt;% mutate(
  cs = colprods_byname(M),
  cs2 = colprods_byname(M, rowname = "prod")
)
res$cs2
</code></pre>

<hr>
<h2 id='colsums_byname'>Column sums, sorted by name</h2><span id='topic+colsums_byname'></span>

<h3>Description</h3>

<p>Calculates column sums for a matrix by premultiplying by an identity vector (containing all 1's).
In contrast to <code>colSums</code> (which returns a <code>numeric</code> result),
the return value from <code>colsums_byname</code> is a matrix.
An optional <code>rowname</code> for the resulting row vector can be supplied.
If <code>rowname</code> is <code>NA</code> (the default),
the row name is set to the row type as given by <code>rowtype(a)</code>.
If <code>rowname</code> is set to <code>NULL</code>, the row name is returned empty.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colsums_byname(a, rowname = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colsums_byname_+3A_a">a</code></td>
<td>
<p>A matrix or list of matrices from which column sums are desired.</p>
</td></tr>
<tr><td><code id="colsums_byname_+3A_rowname">rowname</code></td>
<td>
<p>The name of the output row containing column sums.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A row vector of type <code>matrix</code> containing the column sums of <code>a</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
colsums_byname(42)
m &lt;- matrix(c(1:6), nrow = 2, dimnames = list(paste0("i", 1:2), paste0("c", 3:1))) %&gt;%
  setrowtype("Industries") %&gt;% setcoltype("Commodities")
m
colsums_byname(m)
colsums_byname(m, rowname = "E.ktoe")
m %&gt;% 
  colsums_byname() %&gt;% 
  rowsums_byname()
# This also works with lists
colsums_byname(list(m, m))
colsums_byname(list(m, m), rowname = "E.ktoe")
colsums_byname(list(m, m), rowname = NA)
colsums_byname(list(m, m), rowname = NULL)
DF &lt;- data.frame(m = I(list()))
DF[[1,"m"]] &lt;- m
DF[[2,"m"]] &lt;- m
colsums_byname(DF$m[[1]])
colsums_byname(DF$m)
colsums_byname(DF$m, "sums")
res &lt;- DF %&gt;% mutate(
  cs = colsums_byname(m),
  cs2 = colsums_byname(m, rowname = "sum")
)
res$cs2
</code></pre>

<hr>
<h2 id='coltype'>Column type</h2><span id='topic+coltype'></span>

<h3>Description</h3>

<p>Extracts column type of <code>a</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coltype(a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coltype_+3A_a">a</code></td>
<td>
<p>The object from which you want to extract column types.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The column type of <code>a</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>commoditynames &lt;- c("c1", "c2")
industrynames &lt;- c("i1", "i2")
U &lt;- matrix(1:4, ncol = 2, dimnames = list(commoditynames, industrynames)) %&gt;%
  setrowtype(rowtype = "Commodities") %&gt;% setcoltype("Industries")
coltype(U)
# This also works for lists
coltype(list(U,U))
</code></pre>

<hr>
<h2 id='compare_byname'>Compare matrix entries to a value</h2><span id='topic+compare_byname'></span>

<h3>Description</h3>

<p>Compares matrix entries to a value,
returning a matrix of same size as <code>a</code>
containing <code>TRUE</code> or <code>FALSE</code> values
as the result of applying <code>compare_fun</code> and <code>val</code>
to all entries in <code>a</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_byname(a, compare_fun = c("==", "!=", "&lt;", "&lt;=", "&gt;=", "&gt;"), val = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_byname_+3A_a">a</code></td>
<td>
<p>a matrix or list of matrices whose values are to be counted according to <code>compare_fun</code></p>
</td></tr>
<tr><td><code id="compare_byname_+3A_compare_fun">compare_fun</code></td>
<td>
<p>the comparison function, one of &quot;<code>==</code>&quot;, &quot;<code>!=</code>&quot;,
&quot;<code>&lt;</code>&quot;, &quot;<code>&lt;=</code>&quot;, &quot;<code>&gt;=</code>&quot;, or &quot;<code>&gt;</code>&quot;. Default is &quot;<code>==</code>&quot;.</p>
</td></tr>
<tr><td><code id="compare_byname_+3A_val">val</code></td>
<td>
<p>a single value against which entries in matrix <code>a</code> are compared. Default is <code>0</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical matrix of same size as <code>a</code> containing <code>TRUE</code> where the criterion is met,
<code>FALSE</code> otherwise
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(c(0, 1, 2, 3, 4, 0), nrow = 3, ncol = 2)
compare_byname(m, "&lt;", 3)
compare_byname(list(m,m), "&lt;", 3)
</code></pre>

<hr>
<h2 id='complete_and_sort'>Complete matrices relative to one another and sort into same row, column order</h2><span id='topic+complete_and_sort'></span>

<h3>Description</h3>

<p>Completes each matrix relative to each other, thereby assuring that
both matrices have same row and column names.
Missing rows and columns (relative to the other matrix)
are filled with <code>fill</code>.
Thereafter, rows and columns of the matrices are sorted
such that they are in the same order (by name).
To complete rows of <code>m1</code> relative to columns of <code>m2</code>,
set the <code>m2</code> argument to <code>transpose_byname(m2)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complete_and_sort(
  a,
  b,
  fill = 0,
  margin = c(1, 2),
  roworder = NA,
  colorder = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="complete_and_sort_+3A_a">a</code></td>
<td>
<p>The first matrix</p>
</td></tr>
<tr><td><code id="complete_and_sort_+3A_b">b</code></td>
<td>
<p>The second (optional) matrix.</p>
</td></tr>
<tr><td><code id="complete_and_sort_+3A_fill">fill</code></td>
<td>
<p>rows and columns added to <code>a</code> and <code>b</code> will contain the value <code>fill</code> (a double).</p>
</td></tr>
<tr><td><code id="complete_and_sort_+3A_margin">margin</code></td>
<td>
<p>Specifies the dimension(s) of <code>a</code> and <code>b</code> over which
completing and sorting will occur</p>
</td></tr>
<tr><td><code id="complete_and_sort_+3A_roworder">roworder</code></td>
<td>
<p>Specifies a custom ordering for rows of returned matrices.
Unspecified rows are dropped.</p>
</td></tr>
<tr><td><code id="complete_and_sort_+3A_colorder">colorder</code></td>
<td>
<p>Specifies a custom ordering for columns of returned matrices.
Unspecified columns are dropped.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>margin</code> has nearly the same semantic meaning as in <code>base::apply()</code>.
For rows only, give <code>1</code>;
for columns only, give <code>2</code>;
for both rows and columns, give <code>c(1,2)</code>, the default value.
</p>
<p>If only <code>m1</code> is specified, rows of <code>m1</code> are completed and sorted
relative to columns of <code>m1</code>.
If neither <code>m1</code> nor <code>m2</code> have dimnames,
<code>m1</code> and <code>m2</code> are returned unmodified.
If only one of <code>m1</code> or <code>m2</code> has dimnames, an error is thrown.
</p>


<h3>Value</h3>

<p>A named list containing completed and sorted versions of <code>a</code> and <code>b</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m1 &lt;- matrix(c(1:6), nrow=3, dimnames = list(c("r1", "r2", "r3"), c("c2", "c1")))
m2 &lt;- matrix(c(7:12), ncol=3, dimnames = list(c("r3", "r4"), c("c2", "c3", "c4")))
complete_and_sort(m1)
complete_and_sort(m1, m2)
complete_and_sort(m1, m2, roworder = c("r3", "r2", "r1"))
complete_and_sort(m1, m2, colorder = c("c4", "c3")) # Drops un-specified columns
complete_and_sort(m1, m2, margin = 1)
complete_and_sort(m1, m2, margin = 2)
complete_and_sort(m1, t(m2))
complete_and_sort(m1, t(m2), margin = 1)
complete_and_sort(m1, t(m2), margin = 2)
v &lt;- matrix(1:6, ncol=2, dimnames=list(c("r3", "r1", "r2"), c("c2", "c1")))
complete_and_sort(v, v)
# Also works with lists
complete_and_sort(list(m1,m1), list(m2,m2))
</code></pre>

<hr>
<h2 id='complete_rows_cols'>Complete rows and columns in one matrix relative to another</h2><span id='topic+complete_rows_cols'></span>

<h3>Description</h3>

<p>&quot;Completing&quot; rows and columns means that <code>a</code> contains a union of rows and columns
between <code>a</code> and <code>mat</code>,
with missing data represented by the value for <code>fill</code> (<code>0</code>, by default),
<code>fillrow</code>, or <code>fillcol</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complete_rows_cols(
  a = NULL,
  mat = NULL,
  fill = 0,
  fillrow = NULL,
  fillcol = NULL,
  margin = c(1, 2)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="complete_rows_cols_+3A_a">a</code></td>
<td>
<p>A <code>matrix</code> or list of <code>matrix</code> objects to be completed.
<code>a</code> can be <code>Matrix</code> objects, too.</p>
</td></tr>
<tr><td><code id="complete_rows_cols_+3A_mat">mat</code></td>
<td>
<p>A <code>matrix</code> or <code>Matrix</code> from which dimnames will be extracted
for the purposes of completing <code>a</code> with respect to <code>mat</code>.</p>
</td></tr>
<tr><td><code id="complete_rows_cols_+3A_fill">fill</code></td>
<td>
<p>Rows and columns added to <code>a</code> will contain the value <code>fill</code>.
(Default is <code>0</code>.)</p>
</td></tr>
<tr><td><code id="complete_rows_cols_+3A_fillrow">fillrow</code></td>
<td>
<p>A row vector of type <code>matrix</code> with same column names as <code>a</code>.
Any rows added to <code>a</code> will be <code>fillrow</code>.
If non-<code>NULL</code>, <code>fillrow</code> takes precedence over both <code>fillcol</code> and <code>fill</code>
in the case of conflicts.</p>
</td></tr>
<tr><td><code id="complete_rows_cols_+3A_fillcol">fillcol</code></td>
<td>
<p>A column vector of type matrix with same row names as <code>a</code>.
Any columns added to <code>a</code> will be <code>fillcol</code>.
If non-<code>NULL</code>, <code>fillcol</code> takes precedence over <code>fill</code>
in the case of conflicts.</p>
</td></tr>
<tr><td><code id="complete_rows_cols_+3A_margin">margin</code></td>
<td>
<p>Specifies the subscript(s) in <code>a</code> over which completion will occur
<code>margin</code> has nearly the same semantic meaning as in <code>base::apply()</code>
For rows only, give <code>1</code>;
for columns only, give <code>2</code>;
for both rows and columns, give <code>c(1,2)</code>, the default value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code>complete_rows_cols(mat1, mat2)</code> and <code>complete_rows_cols(mat2, mat1)</code> are
not guaranteed to have the same order for rows and columns.
(Nor are the values in the matrix guaranteed to have the same positions.)
</p>
<p>If <code>dimnames(mat)</code> is <code>NULL</code>, <code>a</code> is returned unmodified.
</p>
<p>If either <code>a</code> or <code>mat</code> are missing names on a margin (row or column),
an error is given.
</p>
<p>When <code>a</code> is non-<code>NULL</code>,
<code>a</code> is named, and <code>mat</code> is <code>NULL</code> (the default),
<code>a</code> is completed relative to itself,
meaning that <code>a</code> will be made square,
containing the union of row and column names from <code>a</code>.
Under these conditions, no warning is given.
</p>
<p>If <code>mat</code> is non-<code>NULL</code> and dimnames of <code>mat</code> cannot be determined
(because, for example, <code>mat</code> doesn't have dimnames),
<code>a</code> is completed relative to itself and a warning is given.
</p>
<p>All added rows and columns will be created from one of the <code style="white-space: pre;">&#8288;fill*&#8288;</code> arguments.
When conflicts arise, precedence among the <code style="white-space: pre;">&#8288;fill*&#8288;</code> arguments is
<code>fillrow</code> then <code>fillcol</code> then <code>fill</code>.
</p>


<h3>Value</h3>

<p>A modified version of <code>a</code> possibly containing additional rows and columns
whose names are obtained from <code>mat</code> and whose values are obtained from
<code>fillrow</code>, <code>fillcol</code> or <code>fill</code> (in that order of preference).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m1 &lt;- matrix(c(1:6), nrow=3, dimnames = list(c("r1", "r2", "r3"), c("c1", "c2")))
m1
m2 &lt;- matrix(c(7:12), ncol=3, dimnames = list(c("r2", "r3"), c("c2", "c3", "c4")))
m2
complete_rows_cols(m1, m2) # Adds empty column c4
complete_rows_cols(m1, t(m2)) # Creates r2, r3 columns; c2, c3, c4 rows
complete_rows_cols(m1, m2, margin = 1) # No changes because r2 and r3 already present in m1
complete_rows_cols(m1, m2, margin = 2) # Adds empty columns c3 and c4
complete_rows_cols(m1, t(m2), margin = 1) # Adds empty rows c2, c3, c4
complete_rows_cols(m1, m2, fill = 100) # Adds columns c3 and c4 with 100's
complete_rows_cols(m1, m1) # Nothing added, because everything already present
complete_rows_cols(m1, t(m1)) # Adds empty c1, c2 rows; Adds empty r1, r2, r3 columns
# Same as previous. With missing matrix, complete relative to transpose of m1.
complete_rows_cols(m1) 
# Adds rows r10, r11; cols c10, c11
complete_rows_cols(m1, matrix(0, nrow = 2, ncol = 2, 
                              dimnames = list(c("r10", "r11"), c("c10", "c11")))) 
# Also works with lists
complete_rows_cols(a = list(m1,m1))
complete_rows_cols(a = list(m1,m1), mat = list(m2,m2))
# No changes because r2, r3 already present in m1
complete_rows_cols(a = list(m1,m1), mat = list(m2,m2), margin = 1) 
complete_rows_cols(a = list(m1,m1), mat = list(m2,m2), margin = 2)
complete_rows_cols(a = list(m1,m1), 
                   mat = RCLabels::make_list(matrix(0,
                                                    nrow = 2, 
                                                    ncol = 2, 
                                                    dimnames = list(c("r10", "r11"), 
                                                                    c("c10", "c11"))), 
                                             n = 2, lenx = 1))
# fillrow or fillcol can be specified
a &lt;- matrix(c(11, 12, 21, 22), byrow = TRUE, nrow = 2, ncol = 2, 
            dimnames = list(c("r1", "r2"), c("c1", "c2")))
b &lt;- matrix(c(1:6), byrow = TRUE, nrow = 3, ncol = 2, 
            dimnames = list(c("r1", "r2", "r3"), c("c1", "c2")))
fillrow &lt;- matrix(c(31, 32), byrow = TRUE, nrow = 1, ncol = 2, 
                  dimnames = list("r42", c("c1", "c2")))
complete_rows_cols(a = a, mat = b, fillrow = fillrow)
</code></pre>

<hr>
<h2 id='count_vals_byname'>Count the number of matrix entries that meet a criterion</h2><span id='topic+count_vals_byname'></span>

<h3>Description</h3>

<p>Expressions can be written in a natural way such as
<code>count_vals_byname(m, "&lt;=", 1)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_vals_byname(
  a,
  compare_fun = c("==", "!=", "&lt;", "&lt;=", "&gt;=", "&gt;"),
  val = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_vals_byname_+3A_a">a</code></td>
<td>
<p>A matrix or list of matrices whose values are to be counted according to <code>compare_fun</code>.</p>
</td></tr>
<tr><td><code id="count_vals_byname_+3A_compare_fun">compare_fun</code></td>
<td>
<p>The comparison function, one of &quot;==&quot;, &quot;!=&quot;,
&quot;&lt;&quot;, &quot;&lt;=&quot;, &quot;&gt;&quot;, or &quot;&gt;=&quot;.
Default is &quot;==&quot;.</p>
</td></tr>
<tr><td><code id="count_vals_byname_+3A_val">val</code></td>
<td>
<p>The value against which matrix entries are compared.
Default is <code>0</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Either a single matrix or a list of matrices can be given as the <code>a</code> argument.
<code>compare_fun</code> can be specified as a string (&quot;!=&quot;)
or as a back-quoted function (<code>`!=`</code>).
</p>


<h3>Value</h3>

<p>An integer indicating the number of entries in <code>a</code>
that meet the specified criterion
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(c(0, 1, 2, 3, 4, 0), nrow = 3, ncol = 2)
count_vals_byname(m) # uses defaults: compare_fun = "==" and val = 0
count_vals_byname(m, compare_fun = "!=")
count_vals_byname(m, compare_fun = `!=`)
# Write expressions in a natural way
count_vals_byname(m, "&lt;=", 1)
# Also works for lists
count_vals_byname(list(m,m), "&lt;=", 1)
</code></pre>

<hr>
<h2 id='count_vals_incols_byname'>Count the number of matrix entries in columns that meet a criterion</h2><span id='topic+count_vals_incols_byname'></span>

<h3>Description</h3>

<p>Expressions can be written in a natural way such as
<code>count_vals_incols_byname(m, "&lt;=", 1)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_vals_incols_byname(
  a,
  compare_fun = c("==", "!=", "&lt;", "&lt;=", "&gt;=", "&gt;"),
  val = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_vals_incols_byname_+3A_a">a</code></td>
<td>
<p>a matrix or list of matrices whose values are to be counted by columns
according to <code>compare_fun</code></p>
</td></tr>
<tr><td><code id="count_vals_incols_byname_+3A_compare_fun">compare_fun</code></td>
<td>
<p>the comparison function, one of &quot;<code>==</code>&quot;, &quot;<code>!=</code>&quot;,
&quot;<code>&lt;</code>&quot;, &quot;<code>&lt;=</code>&quot;, &quot;<code>&gt;</code>&quot;, or &quot;<code>&gt;=</code>&quot;. Default is &quot;<code>==</code>&quot;</p>
</td></tr>
<tr><td><code id="count_vals_incols_byname_+3A_val">val</code></td>
<td>
<p>the value against which matrix entries are compared. Default is <code>0</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Either a single matrix or a list of matrices can be given as the <code>a</code> argument.
<code>compare_fun</code> can be specified as a string (<code>"!="</code>)
or as a back-quoted function (<code>`!=`</code>).
</p>


<h3>Value</h3>

<p>an <code>matrix</code> with a single row indicating the number of entries in <code>a</code>
that meet the specified criterion in each column of <code>a</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(c(0, 1, 2, 3, 4, 0), nrow = 3, ncol = 2)
count_vals_incols_byname(m) # uses defaults: compare_fun = "==" and val = 0
count_vals_incols_byname(m, compare_fun = "!=")
count_vals_incols_byname(m, compare_fun = `!=`)
# Write expressions in a natural way
count_vals_incols_byname(m, "&lt;=", 1)
# Also works for lists
count_vals_incols_byname(list(m,m), "&lt;=", 1)
</code></pre>

<hr>
<h2 id='count_vals_inrows_byname'>Count the number of matrix entries in rows that meet a criterion</h2><span id='topic+count_vals_inrows_byname'></span>

<h3>Description</h3>

<p>Expressions can be written in a natural way such as
<code>count_vals_inrows_byname(m, "&lt;=", 1)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_vals_inrows_byname(
  a,
  compare_fun = c("==", "!=", "&lt;", "&lt;=", "&gt;=", "&gt;"),
  val = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_vals_inrows_byname_+3A_a">a</code></td>
<td>
<p>a matrix or list of matrices whose values are to be counted by rows according to <code>compare_fun</code></p>
</td></tr>
<tr><td><code id="count_vals_inrows_byname_+3A_compare_fun">compare_fun</code></td>
<td>
<p>the comparison function, one of &quot;<code>==</code>&quot;, &quot;<code>!=</code>&quot;,
&quot;<code>&lt;</code>&quot;, &quot;<code>&lt;=</code>&quot;, &quot;<code>&gt;</code>&quot;, or &quot;<code>&gt;=</code>&quot;. Default is &quot;<code>==</code>&quot;.</p>
</td></tr>
<tr><td><code id="count_vals_inrows_byname_+3A_val">val</code></td>
<td>
<p>the value against which matrix entries are compared. Default is <code>0</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Either a single matrix or a list of matrices can be given as the <code>a</code> argument.
<code>compare_fun</code> can be specified as a string (<code>"!="</code>)
or as a back-quoted function (<code>`!=`</code>).
</p>


<h3>Value</h3>

<p>an <code>matrix</code> with a single column indicating the number of entries in <code>a</code>
that meet the specified criterion in each row of <code>a</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(c(0, 1, 2, 3, 4, 0), nrow = 3, ncol = 2)
count_vals_inrows_byname(m) # uses defaults: compare_fun = "==" and val = 0
count_vals_inrows_byname(m, compare_fun = "!=")
count_vals_inrows_byname(m, compare_fun = `!=`)
# Write expressions in a natural way
count_vals_inrows_byname(m, "&lt;=", 1)
# Also works for lists
count_vals_inrows_byname(list(m,m), "&lt;=", 1)
</code></pre>

<hr>
<h2 id='create_colvec_byname'>Create column vectors from data</h2><span id='topic+create_colvec_byname'></span>

<h3>Description</h3>

<p>This function takes data in the <code>.dat</code> and creates column vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_colvec_byname(
  .dat,
  dimnames = NA,
  colname = NA,
  matrix_class = c("matrix", "Matrix")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_colvec_byname_+3A_.dat">.dat</code></td>
<td>
<p>Data to be converted to column vectors.</p>
</td></tr>
<tr><td><code id="create_colvec_byname_+3A_dimnames">dimnames</code></td>
<td>
<p>The dimension names to be used for creating the column vector, in a list format, or as a data frame column
containing a list of the dimension names to be used for each observation.</p>
</td></tr>
<tr><td><code id="create_colvec_byname_+3A_colname">colname</code></td>
<td>
<p>The name of the column of the colvector.</p>
</td></tr>
<tr><td><code id="create_colvec_byname_+3A_matrix_class">matrix_class</code></td>
<td>
<p>One of &quot;matrix&quot; or &quot;Matrix&quot;.
&quot;matrix&quot; creates a <code>base::matrix</code> object with the <code>matrix()</code> function.
&quot;Matrix&quot; creates a <code>Matrix::Matrix</code> object using the <code>matsbyname::Matrix()</code> function.
This could be a sparse matrix.
Default is &quot;matrix&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The row and column names in the resulting column vector are taken from
the names of <code>.dat</code> and <code>colname</code>.
If set, <code>dimnames</code> overrides the names of <code>.dat</code> and <code>colname</code>.
</p>
<p>This function is a &quot;byname&quot; function that can accept a single number,
a vector, a list, or a data frame in <code>.dat</code>.
</p>
<p>Row types and column types are taken from the row type and column type attributes of <code>.dat</code>.
</p>


<h3>Value</h3>

<p>A column vector, a list of column vectors, or a data frame column of column vectors, depending on the
value of <code>.dat</code> and <code>class</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Works with single numbers
create_colvec_byname(c(r1 = 1) %&gt;% setrowtype("rt") %&gt;% setcoltype("ct"), 
                     colname = "r1")
# Works with vectors
create_colvec_byname(c(r1 = 1, r2 = 2), colname = "c1")
# Works with a list
create_colvec_byname(list(c(r1 = 1, r2 = 2), c(R1 = 3, R2 = 4, R3 = 5)), 
                     colname = list("c1", "C1"))
# Works in a tibble, too.
# (Must be a tibble, not a data frame, so that names are preserved.)
dat &lt;- list(c(r1 = 1, r2 = 2),
            c(R1 = 2, R2 = 3), 
            c(r1 = 1, r2 = 2, r3 = 3, r4 = 4, r5 = 5, r6 = 6))
cnms &lt;- list("c1", "C1", "c1")
df1 &lt;- tibble::tibble(dat, cnms)
df1
df1 &lt;- df1 %&gt;%
  dplyr::mutate(
    colvec_col = create_colvec_byname(dat, colname = cnms)
  )
df1$colvec_col[[1]]
df1$colvec_col[[2]]
df1$colvec_col[[3]]
</code></pre>

<hr>
<h2 id='create_matrix_byname'>Create a &quot;byname&quot; matrix from a vector</h2><span id='topic+create_matrix_byname'></span>

<h3>Description</h3>

<p>This function creates a &quot;byname&quot; matrix, or list of matrices, from <code>.dat</code>,
depending on the input arguments.
This function is similar to <code>matrix()</code>, but with &quot;byname&quot; characteristics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_matrix_byname(
  .dat,
  nrow,
  ncol,
  byrow = FALSE,
  dimnames,
  matrix_class = c("matrix", "Matrix")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_matrix_byname_+3A_.dat">.dat</code></td>
<td>
<p>The data to be used to create the matrix, in a list format, or as a data frame column
containing a list of the data to be used for each observation.</p>
</td></tr>
<tr><td><code id="create_matrix_byname_+3A_nrow">nrow</code></td>
<td>
<p>The number of rows to be used to create the matrix, in a list format, or as a data frame column
containing a list of the number of rows to be used for each observation.</p>
</td></tr>
<tr><td><code id="create_matrix_byname_+3A_ncol">ncol</code></td>
<td>
<p>The number of columns to be used to create the matrix, in a list format, or as a data frame column
containing a list of the number of columns to be used for each observation.</p>
</td></tr>
<tr><td><code id="create_matrix_byname_+3A_byrow">byrow</code></td>
<td>
<p>The argument stating whether the matrix should be filled by rows or by columns (FALSE by column, TRUE by row),
in a list format, or as a data frame column containing a list of the byrow argument for each observation.
Default is <code>FALSE.</code></p>
</td></tr>
<tr><td><code id="create_matrix_byname_+3A_dimnames">dimnames</code></td>
<td>
<p>The dimension names to be used for creating the matrices, in a list format, or as a data frame column
containing a list of the dimension names to be used for each observation.</p>
</td></tr>
<tr><td><code id="create_matrix_byname_+3A_matrix_class">matrix_class</code></td>
<td>
<p>One of &quot;matrix&quot; or &quot;Matrix&quot;.
&quot;matrix&quot; creates a <code>base::matrix</code> object with the <code>matrix()</code> function.
&quot;Matrix&quot; creates a <code>Matrix::Matrix</code> object using the <code>matsbyname::Matrix()</code> function.
This could be a sparse matrix.
Default is &quot;matrix&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Row and column names are taken from the <code>dimnames</code> argument.
</p>
<p>Any row or column type information on <code>.dat</code> is preserved on output.
</p>
<p>The created object(s) can be of type <code>base::matrix</code> or <code>Matrix::Matrix</code>,
the latter enables sparse objects to save both memory and disk.
</p>


<h3>Value</h3>

<p>A matrix, list of matrices, or column in a data frame, depending on the input arguments.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>create_matrix_byname(c(1, 2), nrow = 2, ncol = 1,
                     dimnames = list(c("r1", "r2"), "c1"))
create_matrix_byname(list(1, 2), nrow = list(1, 1), ncol = list(1,1), 
                     dimnames = list(list("r1", "c1"), list("R1", "C1")))
</code></pre>

<hr>
<h2 id='create_rowvec_byname'>Create row vectors from data</h2><span id='topic+create_rowvec_byname'></span>

<h3>Description</h3>

<p>This function takes data in the <code>.dat</code> and creates row vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_rowvec_byname(
  .dat,
  dimnames = NA,
  rowname = NA,
  matrix_class = c("matrix", "Matrix")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_rowvec_byname_+3A_.dat">.dat</code></td>
<td>
<p>Data to be converted to row vectors.</p>
</td></tr>
<tr><td><code id="create_rowvec_byname_+3A_dimnames">dimnames</code></td>
<td>
<p>The dimension names to be used for creating the row vector, in a list format, or as a data frame column
containing a list of the dimension names to be used for each observation.</p>
</td></tr>
<tr><td><code id="create_rowvec_byname_+3A_rowname">rowname</code></td>
<td>
<p>The name of the row of the row vector.</p>
</td></tr>
<tr><td><code id="create_rowvec_byname_+3A_matrix_class">matrix_class</code></td>
<td>
<p>One of &quot;matrix&quot; or &quot;Matrix&quot;.
&quot;matrix&quot; creates a <code>base::matrix</code> object with the <code>matrix()</code> function.
&quot;Matrix&quot; creates a <code>Matrix::Matrix</code> object using the <code>matsbyname::Matrix()</code> function.
This could be a sparse matrix.
Default is &quot;matrix&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The row and column names in the resulting row vector are taken from
<code>rowname</code> and the names of <code>.dat</code>.
If set, <code>dimnames</code> overrides <code>rowname</code> and the names of <code>.dat</code>.
</p>
<p>Row types and column types are taken from the row type and column type attributes of <code>.dat</code>.
</p>
<p>This function is a &quot;byname&quot; function that can accept a single number,
a vector, a list, or a data frame in <code>.dat</code>.
</p>


<h3>Value</h3>

<p>A row vector, a list of row vectors, or a data frame column of row vectors, depending on the
values of <code>.dat</code> and <code>class</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Works with single numbers
create_rowvec_byname(c(c1 = 1) %&gt;% setrowtype("rt") %&gt;% setcoltype("ct"), rowname = "r1")
# Works with vectors
create_rowvec_byname(c(c1 = 1, c2 = 2), rowname = "r1")
# Works with a list
create_rowvec_byname(list(c(c1 = 1, c2 = 2), c(C1 = 3, C2 = 4, C3 = 5)), 
                     rowname = list("r1", "R1"))
# Works in a tibble, too.
# (Must be a tibble, not a data frame, so that names are preserved.)
dat &lt;- list(c(c1 = 1),
            c(C1 = 2, C2 = 3), 
            c(c1 = 1, c2 = 2, c3 = 3, c4 = 4, c5 = 5, c6 = 6))
rnms &lt;- list("r1", "R1", "r1")
df1 &lt;- tibble::tibble(dat, rnms)
df1
df1 &lt;- df1 %&gt;%
  dplyr::mutate(
    rowvec_col = create_rowvec_byname(dat, rowname = rnms)
  )
df1$rowvec_col[[1]]
df1$rowvec_col[[2]]
df1$rowvec_col[[3]]
</code></pre>

<hr>
<h2 id='cumapply_byname'>Apply a function cumulatively to a list of matrices or numbers</h2><span id='topic+cumapply_byname'></span>

<h3>Description</h3>

<p><code>FUN</code> must be a binary function that also accepts a single argument.
The result is a list with first element <code>FUN(a[[1]])</code>.
For <code>i &gt;= 2</code>, elements are <code>FUN(a[[i]], out[[i-1]])</code>,
where <code>out</code> is the result list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cumapply_byname(FUN, a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cumapply_byname_+3A_fun">FUN</code></td>
<td>
<p>the function to be applied</p>
</td></tr>
<tr><td><code id="cumapply_byname_+3A_a">a</code></td>
<td>
<p>the list of matrices or numbers to which <code>FUN</code> will be applied cumulatively</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>naryapply_byname()</code> and <code>cumapply_byname()</code> are similar.
Their differences can be described by considering a data frame.
<code>naryapply_byname()</code> applies <code>FUN</code> to several columns (variables) of the data frame.
For example, <code>sum_byname()</code> applied to several variables gives another column
containing the sums across each row of the data frame.
<code>cumapply_byname()</code> applies <code>FUN</code> to successive entries in a single column.
For example <code>sum_byname()</code> applied to a single column gives the sum of all numbers in that column.
</p>


<h3>Value</h3>

<p>a list of same length as <code>a</code>
containing the cumulative application of <code>FUN</code> to <code>a</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cumapply_byname(sum, list(1, 2, 3, 4))
cumapply_byname(sum_byname, list(1, 2, 3, 4))
cumapply_byname(prod, list(1, 2, 3, 4))
cumapply_byname(hadamardproduct_byname, list(1, 2, 3, 4))
</code></pre>

<hr>
<h2 id='cumprod_byname'>Cumulative element-product that respects row and column names</h2><span id='topic+cumprod_byname'></span>

<h3>Description</h3>

<p>Provides cumulative element-products along a list or column of a data frame.
If <code>a</code> is a single number, <code>a</code> is returned.
If <code>a</code> is a list of numbers, a list representing the cumulative product of the numbers is returned.
If <code>a</code> is a single matrix, <code>a</code> is returned.
If <code>a</code> is a list of matrices, a list representing the cumulative product
of the matrices is returned.
In this case, each entry in the returned list is product &quot;by name,&quot;
such that row and column names of the matrices are respected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cumprod_byname(a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cumprod_byname_+3A_a">a</code></td>
<td>
<p>A number, list of numbers, matrix or list of matrices for which cumulative element product is desired.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function respects groups if <code>a</code> is a variable in a data frame.
</p>


<h3>Value</h3>

<p>A single number, list of numbers, a single matrix, or a list of matrices,
depending on the nature of <code>a</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cumprod_byname(list(1, 2, 3, 4, 5))
m1 &lt;- matrix(c(1), nrow = 1, ncol = 1, dimnames = list("r1", "c1")) %&gt;%
  setrowtype("row") %&gt;% setcoltype("col")
m2 &lt;- matrix(c(2), nrow = 1, ncol = 1, dimnames = list("r2", "c2")) %&gt;%
  setrowtype("row") %&gt;% setcoltype("col")
m3 &lt;- matrix(c(3), nrow = 1, ncol = 1, dimnames = list("r3", "c3")) %&gt;%
  setrowtype("row") %&gt;% setcoltype("col")
cumprod_byname(list(m1, m2, m3))
</code></pre>

<hr>
<h2 id='cumsum_byname'>Cumulative sum that respects row and column names</h2><span id='topic+cumsum_byname'></span>

<h3>Description</h3>

<p>Provides cumulative sums along a list or column of a data frame.
If <code>a</code> is a single number, <code>a</code> is returned.
If <code>a</code> is a list of numbers, a list representing the cumulative sum of the numbers is returned.
If <code>a</code> is a single matrix, <code>a</code> is returned.
If <code>a</code> is a list of matrices, a list representing the cumulative sum
of the matrices is returned.
In this case, each entry in the returned list is sum &quot;by name,&quot;
such that row and column names of the matrices are respected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cumsum_byname(a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cumsum_byname_+3A_a">a</code></td>
<td>
<p>A number, list of numbers, matrix or list of matrices for which cumulative sum is desired.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If cumulative sums are desired in the context of a data frame,
groups in the data frame are respected if <code>mutate</code> is used.
See examples.
</p>


<h3>Value</h3>

<p>A single number, list of numbers, a single matrix, or a list of matrices,
depending on the nature of <code>a</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(tibble)
m1 &lt;- matrix(c(1), nrow = 1, ncol = 1, dimnames = list("r1", "c1")) %&gt;% 
  setrowtype("row") %&gt;% setcoltype("col")
m2 &lt;- matrix(c(2), nrow = 1, ncol = 1, dimnames = list("r2", "c2")) %&gt;% 
  setrowtype("row") %&gt;% setcoltype("col")
m3 &lt;- matrix(c(3), nrow = 1, ncol = 1, dimnames = list("r3", "c3")) %&gt;% 
  setrowtype("row") %&gt;% setcoltype("col")
cumsum_byname(list(m1, m2, m3))
# Groups are respected in the context of mutate.
tibble(grp = c("A", "A", "B"), m = list(m1, m2, m3)) %&gt;% group_by(grp) %&gt;% 
  mutate(m2 = cumsum_byname(m))
</code></pre>

<hr>
<h2 id='difference_byname'>Name-wise subtraction of matrices</h2><span id='topic+difference_byname'></span>

<h3>Description</h3>

<p>Name-wise subtraction of matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>difference_byname(minuend, subtrahend)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="difference_byname_+3A_minuend">minuend</code></td>
<td>
<p>matrix or constant</p>
</td></tr>
<tr><td><code id="difference_byname_+3A_subtrahend">subtrahend</code></td>
<td>
<p>matrix or constant
</p>
<p>Performs a union and sorting of row and column names prior to differencing.
Zeroes are inserted for missing matrix elements.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix representing the name-wise difference between <code>minuend</code> and <code>subtrahend</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
difference_byname(100, 50)
commoditynames &lt;- c("c1", "c2")
industrynames &lt;- c("i1", "i2")
U &lt;- matrix(1:4, ncol = 2, dimnames = list(commoditynames, industrynames)) %&gt;%
  setrowtype("Commodities") %&gt;% setcoltype("Industries")
G &lt;- matrix(rev(1:4), ncol = 2, dimnames = list(rev(commoditynames), rev(industrynames))) %&gt;%
  setrowtype("Commodities") %&gt;% setcoltype("Industries")
U - G # Non-sensical. Row and column names not respected.
difference_byname(U, G) # Row and column names respected! Should be all zeroes.
difference_byname(100, U)
difference_byname(10, G)
difference_byname(G) # When subtrahend is missing, return minuend (in this case, G).
difference_byname(subtrahend = G) # When minuend is missing, return - subtrahend (in this case, -G)
# This also works with lists
difference_byname(list(100, 100), list(50, 50))
difference_byname(list(U,U), list(G,G))
DF &lt;- data.frame(U = I(list()), G = I(list()))
DF[[1,"U"]] &lt;- U
DF[[2,"U"]] &lt;- U
DF[[1,"G"]] &lt;- G
DF[[2,"G"]] &lt;- G
difference_byname(DF$U, DF$G)
DF %&gt;% mutate(diffs = difference_byname(U, G))
</code></pre>

<hr>
<h2 id='eigenvalues_byname'>Calculate eigenvalues of a matrix</h2><span id='topic+eigenvalues_byname'></span>

<h3>Description</h3>

<p>Calculate the eigenvalues of a matrix or a list of matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eigenvalues_byname(a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eigenvalues_byname_+3A_a">a</code></td>
<td>
<p>A matrix or list of matrices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function pairs with <code>eigenvectors_byname()</code>;
the first value of the result is the eigenvalue
for the eigenvector reported in the first column of the result from <code>eigenvectors_byname()</code>.
The second value of the result is the eigenvalue
for the eigenvector reported in the second column of the result from <code>eigenvectors_byname()</code>.
Etc.
</p>
<p>Internally, this function uses <code>base::eigen(only.values = TRUE)</code>.
</p>
<p><code>complete_rows_cols()</code> is called prior to calculating the eigenvalues.
</p>


<h3>Value</h3>

<p>A vector of eigenvalues.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(c( 4,  6, 10, 
               3, 10, 13, 
              -2, -6, -8), byrow = TRUE, nrow = 3, ncol = 3, 
            dimnames = list(c("p1", "p2", "p3"), c("p1", "p2", "p3")))
m
eigenvalues_byname(m)
eigenvalues_byname(list(m, 2*m))
DF &lt;- tibble::tibble(m_col = list(m, 2*m)) %&gt;% 
  dplyr::mutate(
    eigen_col = eigenvalues_byname(m_col)
  )
DF$eigen_col[[1]]
DF$eigen_col[[2]]
</code></pre>

<hr>
<h2 id='eigenvectors_byname'>Calculate eigenvectors of a matrix</h2><span id='topic+eigenvectors_byname'></span>

<h3>Description</h3>

<p>Calculate the eigenvectors of a matrix or a list of matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eigenvectors_byname(a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eigenvectors_byname_+3A_a">a</code></td>
<td>
<p>A matrix or list of matrices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function pairs with <code>eigenvalues_byname()</code>;
the first column of the resulting matrix is the eigenvector
for the first eigenvalue reported by <code>eigenvalues_byname()</code>.
The second column of the resulting matrix is the eigenvector
for the second eigenvalue reported by <code>eigenvalues_byname()</code>.
Etc.
</p>
<p>Internally, this function uses <code>base::eigen()</code>.
</p>
<p><code>complete_rows_cols()</code> is called prior to calculating the eigenvectors.
</p>


<h3>Value</h3>

<p>A matrix whose columns are the eigenvectors of <code>a</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(c( 4,  6, 10, 
               3, 10, 13, 
              -2, -6, -8), byrow = TRUE, nrow = 3, ncol = 3, 
            dimnames = list(c("p1", "p2", "p3"), c("p1", "p2", "p3")))
m
eigenvectors_byname(m)
eigenvectors_byname(list(m, 2*m))
DF &lt;- tibble::tibble(m_col = list(m, 2*m)) %&gt;% 
  dplyr::mutate(
    eigen_col = eigenvectors_byname(m_col)
  )
DF$eigen_col[[1]]
DF$eigen_col[[2]]
</code></pre>

<hr>
<h2 id='elementapply_byname'>Apply a function to an element of a matrix specified by rows and columns</h2><span id='topic+elementapply_byname'></span>

<h3>Description</h3>

<p><code>FUN</code> is applied to the element of <code>a</code> that is specified by <code>row</code> and <code>col</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elementapply_byname(FUN, a, row, col, .FUNdots = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elementapply_byname_+3A_fun">FUN</code></td>
<td>
<p>a unary function to be applied to specified rows and columns of <code>a</code></p>
</td></tr>
<tr><td><code id="elementapply_byname_+3A_a">a</code></td>
<td>
<p>the argument to <code>FUN</code></p>
</td></tr>
<tr><td><code id="elementapply_byname_+3A_row">row</code></td>
<td>
<p>the row name of the element to which <code>FUN</code> will be applied</p>
</td></tr>
<tr><td><code id="elementapply_byname_+3A_col">col</code></td>
<td>
<p>the column name of the element to which <code>FUN</code> will be applied</p>
</td></tr>
<tr><td><code id="elementapply_byname_+3A_.fundots">.FUNdots</code></td>
<td>
<p>a list of additional arguments to <code>FUN</code>. (Default is <code>NULL</code>.)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>row</code> and <code>col</code> can be any of row or column names or integer indices or a mix of both.
</p>


<h3>Value</h3>

<p><code>a</code>, after <code>FUN</code> has been applied to the element at <code>row</code> and <code>col</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>divide &lt;- function(x, divisor){
  x/divisor
}
m &lt;- matrix(c(1:4), nrow = 2, ncol = 2, dimnames = list(c("r1", "r2"), c("c1", "c2"))) %&gt;% 
  setrowtype("row") %&gt;% setcoltype("col")
elementapply_byname(divide, a = m, row = 1, col = 1, .FUNdots = list(divisor = 2))
elementapply_byname(divide, a = m, row = 1, col = 2, .FUNdots = list(divisor = 10))
elementapply_byname(divide, a = m, row = "r2", col = "c2", .FUNdots = list(divisor = 100))
</code></pre>

<hr>
<h2 id='equal_byname'>Compare two matrices &quot;by name&quot; for equality</h2><span id='topic+equal_byname'></span>

<h3>Description</h3>

<p>If operands are matrices, they are completed and sorted relative to one another prior to comparison.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equal_byname(..., .summarise = FALSE, tol = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="equal_byname_+3A_...">...</code></td>
<td>
<p>Operands to be compared.</p>
</td></tr>
<tr><td><code id="equal_byname_+3A_.summarise">.summarise</code></td>
<td>
<p>Tells whether the operation should be accomplished
across lists (<code>FALSE</code>) or down lists (<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="equal_byname_+3A_tol">tol</code></td>
<td>
<p>A double that tells how precisely equal the values
of <code>a</code> and <code>b</code> must be.
Default is <code>0</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Comparisons are made by <code>equal_matrix_or_Matrix(a, b, tolerance = abs(tol))</code>
so that variations among numbers
within <code>tol</code> will still return <code>TRUE.</code>
</p>
<p>If EXACT comparison is needed, use <code>identical_byname()</code>,
which compares using <code>identical(a, b)</code>.
</p>
<p><code>tol</code> should be a single value that applies to all items in <code>...</code>.
</p>


<h3>Value</h3>

<p><code>TRUE</code> iff all information is equal, including
row and column types <em>and</em>
row and column names <em>and</em>
entries in the matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- matrix(1:4, nrow = 2)
b &lt;- matrix(1:4, nrow = 2)
equal_byname(a, b)
equal_byname(a, b + 1e-100)
identical_byname(a, b + 1e-100)
a &lt;- a %&gt;% setrowtype("Industries") %&gt;% setcoltype("Commodities")
equal_byname(a, b) # FALSE because a has row and column types, but b does not.
b &lt;- b %&gt;% setrowtype("Industries") %&gt;% setcoltype("Commodities")
equal_byname(a, b)
dimnames(a) &lt;- list(c("i1", "i2"), c("c1", "c2"))
dimnames(b) &lt;- list(c("c1", "c2"), c("i1", "i2"))
equal_byname(a, b) # FALSE, because row and column names are not equal
dimnames(b) &lt;- dimnames(a)
equal_byname(a, b)
</code></pre>

<hr>
<h2 id='exp_byname'>Exponential of matrix elements</h2><span id='topic+exp_byname'></span>

<h3>Description</h3>

<p>Gives the exponential of all elements of a matrix or list of matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exp_byname(a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exp_byname_+3A_a">a</code></td>
<td>
<p>a matrix of list of matrices</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>M</code> with each element replaced by its exponential
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exp_byname(1)
m &lt;- matrix(c(log(10),log(1),
              log(1),log(100)), 
              byrow = TRUE, nrow = 2, ncol = 2,
              dimnames = list(paste0("i", 1:2), paste0("c", 1:2))) %&gt;%
  setrowtype("Industry") %&gt;% setcoltype("Commodity")
m
exp_byname(m)
</code></pre>

<hr>
<h2 id='fractionize_byname'>Compute fractions of matrix entries</h2><span id='topic+fractionize_byname'></span>

<h3>Description</h3>

<p>This function divides all entries in <code>a</code> by the specified sum,
thereby &quot;fractionizing&quot; the matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fractionize_byname(a, margin, inf_becomes = .Machine$double.xmax)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fractionize_byname_+3A_a">a</code></td>
<td>
<p>The matrix to be fractionized.</p>
</td></tr>
<tr><td><code id="fractionize_byname_+3A_margin">margin</code></td>
<td>
<p>If <code>1</code> (rows), each entry in <code>a</code> is divided by its row's sum.
If <code>2</code> (columns), each entry in <code>a</code> is divided by its column's sum.
If <code>c(1,2)</code> (both rows and columns),
each entry in <code>a</code> is divided by the sum of all entries in <code>a</code>.</p>
</td></tr>
<tr><td><code id="fractionize_byname_+3A_inf_becomes">inf_becomes</code></td>
<td>
<p>A value to be substitute for any <code>Inf</code> produced by division.
Default is <code>.Machine$double.xmax</code>.
Another reasonable value is <code>Inf</code>.
Set to <code>NULL</code> to disable substitution.
<code>inf_becomes</code> is passed to <code>hatinv_byname()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A fractionized matrix of same dimensions and same row and column types as <code>a</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M &lt;- matrix(c(1, 5,
              4, 5),
            nrow = 2, ncol = 2, byrow = TRUE, 
            dimnames = list(c("p1", "p2"), c("i1", "i2"))) %&gt;% 
            setcoltype("Products") %&gt;% setrowtype("Industries")
fractionize_byname(M, margin = c(1,2))
fractionize_byname(M, margin = 1)
fractionize_byname(M, margin = 2)
</code></pre>

<hr>
<h2 id='geometricmean_byname'>Name- and element-wise geometric mean of two matrices.</h2><span id='topic+geometricmean_byname'></span>

<h3>Description</h3>

<p>Gives the geometric mean of corresponding entries of <code>a</code> and <code>b</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geometricmean_byname(..., .summarise = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geometricmean_byname_+3A_...">...</code></td>
<td>
<p>operands; constants, matrices, or lists of matrices</p>
</td></tr>
<tr><td><code id="geometricmean_byname_+3A_.summarise">.summarise</code></td>
<td>
<p>Tells whether the operation should be accomplished
across lists (<code>FALSE</code>) or down lists (<code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs a union and sorting of row and column names
prior to performing geometric mean.
Zeroes are inserted for missing matrix elements.
</p>


<h3>Value</h3>

<p>name-wise geometric mean of operands
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
geometricmean_byname(10, 1000)
geometricmean_byname(10, 1000, 100000)
commoditynames &lt;- c("c1", "c2")
industrynames &lt;- "i1"
U &lt;- matrix(c(10, 1000), ncol = 1, nrow = 2, dimnames = list(commoditynames, industrynames)) %&gt;%
  setrowtype("Commodities") %&gt;% setcoltype("Industries")
G &lt;- matrix(c(1e3, 1e5), ncol = 1, nrow = 2, 
            dimnames = list(rev(commoditynames), rev(industrynames))) %&gt;%
  setrowtype("Commodities") %&gt;% setcoltype("Industries")
# Non-sensical. Row and column names not respected.
sqrt(U*G)
# Row and column names respected!
geometricmean_byname(U, G)
geometricmean_byname(1000, U)
geometricmean_byname(10, G)
# This also works with lists
geometricmean_byname(list(10, 1000), list(1000, 10))
geometricmean_byname(list(U,U), list(G,G))
DF &lt;- data.frame(U = I(list()), G = I(list()))
DF[[1,"U"]] &lt;- U
DF[[2,"U"]] &lt;- U
DF[[1,"G"]] &lt;- G
DF[[2,"G"]] &lt;- G
geometricmean_byname(DF$U, DF$G)
DF %&gt;% mutate(geomeans = geometricmean_byname(U, G))
</code></pre>

<hr>
<h2 id='getcolnames_byname'>Gets column names</h2><span id='topic+getcolnames_byname'></span>

<h3>Description</h3>

<p>Gets column names in a way that is amenable to use in chaining operations in a functional programming way
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getcolnames_byname(a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getcolnames_byname_+3A_a">a</code></td>
<td>
<p>The matrix or data frame from which column names are to be retrieved</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Column names of <code>m</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(c(1:6), nrow = 2, dimnames = list(paste0("i", 1:2), paste0("c", 1:3))) %&gt;%
  setrowtype("Industries") %&gt;% setcoltype("Commodities")
getcolnames_byname(m)
# This also works for lists
getcolnames_byname(list(m,m))
DF &lt;- data.frame(m = I(list()))
DF[[1,"m"]] &lt;- m
DF[[2,"m"]] &lt;- m
getcolnames_byname(DF$m)
</code></pre>

<hr>
<h2 id='getrownames_byname'>Gets row names</h2><span id='topic+getrownames_byname'></span>

<h3>Description</h3>

<p>Gets row names in a way that is amenable to use in chaining operations in a functional programming way
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getrownames_byname(a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getrownames_byname_+3A_a">a</code></td>
<td>
<p>The matrix or data frame on which row names are to be retrieved</p>
</td></tr>
</table>


<h3>Value</h3>

<p>row names of <code>a</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(c(1:6), nrow = 2, dimnames = list(paste0("i", 1:2), paste0("c", 1:3))) %&gt;%
  setrowtype("Industries") %&gt;% setcoltype("Commodities")
getrownames_byname(m)
# This also works for lists
getrownames_byname(list(m,m))
DF &lt;- data.frame(m = I(list()))
DF[[1,"m"]] &lt;- m
DF[[2,"m"]] &lt;- m
getrownames_byname(DF$m)
</code></pre>

<hr>
<h2 id='getzerorowcolnames_byname'>Names of zero rows and columns</h2><span id='topic+getzerorowcolnames_byname'></span>

<h3>Description</h3>

<p>When a matrix has rows or columns full of zeroes,
it is singular, and can't be inverted.
This function returns the names of rows or columns that are full with zeroes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getzerorowcolnames_byname(a, tol = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getzerorowcolnames_byname_+3A_a">a</code></td>
<td>
<p>A matrix or list of matrices.</p>
</td></tr>
<tr><td><code id="getzerorowcolnames_byname_+3A_tol">tol</code></td>
<td>
<p>The allowable deviation from 0 for any element.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of names of zero rows or columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(c(1, 0, 1,
              1, 0, 0, 
              0, 0, 0),
            dimnames = list(c("r1", "r2", "r3"), c("c1", "c2", "c3")), 
            nrow = 3, ncol = 3, byrow = TRUE)
m
getzerorowcolnames_byname(m)
</code></pre>

<hr>
<h2 id='hadamardproduct_byname'>Name-wise matrix Hadamard multiplication</h2><span id='topic+hadamardproduct_byname'></span>

<h3>Description</h3>

<p>Performs a union and sorting of names of rows and columns for both multiplicand and multiplier
for each sequential multiplication step.
Zeroes are inserted for missing matrix elements.
Doing so ensures that
the dimensions of the multiplicand and multiplier are be conformable for each sequential multiplication.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hadamardproduct_byname(..., .summarise = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hadamardproduct_byname_+3A_...">...</code></td>
<td>
<p>Operands; constants, matrices, or lists of matrices.</p>
</td></tr>
<tr><td><code id="hadamardproduct_byname_+3A_.summarise">.summarise</code></td>
<td>
<p>When <code>TRUE</code>, operands are multiplied down lists.
When <code>FALSE</code> (the default), items multiplied across lists.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Hadamard product is also known as the <code>entrywise</code> product.
</p>


<h3>Value</h3>

<p>Name-wise element product of operands.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
hadamardproduct_byname(2, 2)
commoditynames &lt;- c("c1", "c2")
industrynames &lt;- c("i1", "i2")
U &lt;- matrix(1:4, ncol = 2, dimnames = list(commoditynames, industrynames)) %&gt;%
  setrowtype("Commodities") %&gt;% setcoltype("Industries")
G &lt;- matrix(1:4, ncol = 2, dimnames = list(rev(commoditynames), rev(industrynames))) %&gt;%
  setrowtype("Commodities") %&gt;% setcoltype("Industries")
U * G # Not what is desired, because names aren't aligned
hadamardproduct_byname(U, G)
hadamardproduct_byname(U, G, G)
hadamardproduct_byname(U, 0)
hadamardproduct_byname(0, G)
# This also works with lists
hadamardproduct_byname(list(U, U), list(G, G))
DF &lt;- data.frame(U = I(list()), G = I(list()))
DF[[1,"U"]] &lt;- U
DF[[2,"U"]] &lt;- U
DF[[1,"G"]] &lt;- G
DF[[2,"G"]] &lt;- G
hadamardproduct_byname(DF$U, DF$G)
DF %&gt;% mutate(entrywiseprods = hadamardproduct_byname(U, G))
# Also works down lists with `.summarise = TRUE`.
hadamardproduct_byname(list(U, G), .summarise = TRUE)
</code></pre>

<hr>
<h2 id='hatinv_byname'>Hatize and invert a vector</h2><span id='topic+hatinv_byname'></span>

<h3>Description</h3>

<p>When dividing rows or columns of a matrix by elements of a vector,
the vector elements are placed on the diagonal of a new matrix,
the diagonal matrix is inverted, and
the result is pre- or post-multiplied into the matrix.
This function performs the hatizing and inverting of vector <code>v</code> in one step
and takes advantage of computational efficiencies to achieve the desired result.
The computational shortcut is apparent when one observes that the matrix produced by hatizing and inverting
a vector is a diagonal matrix whose non-zero elements are the numerical inverses of the individual elements of <code>v</code>.
So this function first inverts each element of <code>v</code> then places the inverted elements on the diagonal of a diagonal matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hatinv_byname(v, keep = NULL, inf_becomes = .Machine$double.xmax)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hatinv_byname_+3A_v">v</code></td>
<td>
<p>The vector to be hatized and inverted.</p>
</td></tr>
<tr><td><code id="hatinv_byname_+3A_keep">keep</code></td>
<td>
<p>See <code>hatize_byname()</code>.</p>
</td></tr>
<tr><td><code id="hatinv_byname_+3A_inf_becomes">inf_becomes</code></td>
<td>
<p>A value to be substitute for any <code>Inf</code> produced by the inversion process.
Default is <code>.Machine$double.xmax</code>.
Another reasonable value is <code>Inf</code>.
Set to <code>NULL</code> to disable substitution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this function gives the same result as <code>invert_byname(hatize_byname(v))</code>,
except that <code>invert_byname(hatize_byname(v))</code> fails due to a singular matrix error
when any of the elements of <code>v</code> are zero.
This function will give <code>inf_becomes</code> on the diagonal of the result for each zero element of <code>v</code>,
arguably a better answer.
The sign of <code>Inf</code> is preserved in the substitution.
The default value of <code>inf_becomes</code> is <code>.Machine$double.xmax</code>.
Set <code>inf_becomes</code> to <code>NULL</code> to disable this behavior.
</p>
<p>The default behavior is helpful for cases when the result of <code>hatinv_byname()</code> is later multiplied by <code>0</code>
to obtain <code>0</code>.
Multiplying <code>Inf</code> by <code>0</code> gives <code>NaN</code> which would effectively end the stream of calculations.
</p>


<h3>Value</h3>

<p>a square diagonal matrix with inverted elements of <code>v</code> on the diagonal
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- matrix(1:10, ncol = 1, dimnames = list(c(paste0("i", 1:10)), c("c1"))) %&gt;%
  setrowtype("Industries") %&gt;% setcoltype(NA)
r &lt;- matrix(1:5, nrow = 1, dimnames = list(c("r1"), c(paste0("c", 1:5)))) %&gt;%
  setrowtype(NA) %&gt;% setcoltype("Commodities")
hatinv_byname(v, keep = "rownames")
hatinv_byname(r, keep = "colnames")
# This function also works with lists.
hatinv_byname(list(v, v), keep = "rownames")
# Watch out for 0 values
v2 &lt;- matrix(0:1, ncol = 1, dimnames = list(c(paste0("i", 0:1)), c("p1"))) %&gt;%
  setrowtype("Industries") %&gt;% setcoltype(NA)
# Produces singular matrix error
## Not run: v2 %&gt;% hatize_byname() %&gt;% invert_byname
# Handles 0 values well
hatinv_byname(v2, keep = "rownames")
hatinv_byname(v2, inf_becomes = 42, keep = "rownames")
hatinv_byname(v2, inf_becomes = NA, keep = "rownames")
# Deals with 1x1 matrices well, if the `keep` argument is set.
m &lt;- matrix(42, nrow = 1, ncol = 1, dimnames = list("r1", "c1")) %&gt;% 
  setrowtype("Product -&gt; Industry") %&gt;% 
  setcoltype("Industry -&gt; Product")
m %&gt;% 
  hatinv_byname(keep = "rownames")
m %&gt;% 
  hatinv_byname(keep = "colnames")
</code></pre>

<hr>
<h2 id='hatize_byname'>Creates a diagonal &quot;hat&quot; matrix from a vector</h2><span id='topic+hatize_byname'></span>

<h3>Description</h3>

<p>A &quot;hat&quot; matrix (or a diagonal matrix) is one in which the only non-zero elements are along on the diagonal.
To &quot;hatize&quot; a vector is to place its elements on the diagonal of an otherwise-zero square matrix.
<code>v</code> must be a matrix object with at least one of its two dimensions of length 1 (i.e., a vector).
The names on both dimensions of the hatized matrix are the same and taken from
the dimension of <code>v</code> that is <em>not</em> 1.
Note that the row names and column names are sorted prior to forming the &quot;hat&quot; matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hatize_byname(v, keep = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hatize_byname_+3A_v">v</code></td>
<td>
<p>The vector from which a &quot;hat&quot; matrix is to be created.</p>
</td></tr>
<tr><td><code id="hatize_byname_+3A_keep">keep</code></td>
<td>
<p>One of &quot;rownames&quot; or &quot;colnames&quot; or <code>NULL</code>.
If <code>NULL</code>, the default, names are kept from
the dimension that is not size 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Hatizing a 1x1 vector is potentially undefined.
The argument <code>keep</code>
determines whether to keep &quot;rownames&quot; or &quot;colnames&quot;.
By default <code>keep</code> is <code>NULL</code>,
meaning that the function should attempt to figure out which dimension's names
should be used for the hatized matrix on output.
If vector <code>v</code> could ever be 1x1,
it is best to set a value for <code>keep</code> when writing code
that calls <code>hatize_byname()</code>.
</p>
<p>If the caller specifies <code>keep = "colnames"</code> when <code>v</code> is a column vector,
an error is thrown.
If the caller specifies <code>keep = "rownames"</code> when <code>v</code> is a row vector,
an error is thrown.
</p>


<h3>Value</h3>

<p>A square &quot;hat&quot; matrix with size equal to the length of <code>v</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- matrix(1:10, ncol = 1, dimnames = list(c(paste0("i", 1:10)), c("c1"))) %&gt;%
  setrowtype("Industries") %&gt;% setcoltype(NA)
v
hatize_byname(v, keep = "rownames")
r &lt;- matrix(1:5, nrow = 1, dimnames = list(c("r1"), c(paste0("c", 1:5)))) %&gt;%
  setrowtype(NA) %&gt;% setcoltype("Commodities")
r
hatize_byname(r, keep = "colnames")
# This also works with lists.
hatize_byname(list(v, v), keep = "rownames")
# A 1x1 column vector is a degenerate case. 
# Row names and rowtype are transferred to the column.
matrix(42, nrow = 1, ncol = 1, dimnames = list("r1")) %&gt;% 
  setrowtype("Product -&gt; Industry") %&gt;% 
  hatize_byname(keep = "rownames")
# A 1x1 row vector is a degenerate case. 
# Column names and coltype are transferred to the row.
matrix(42, nrow = 1, ncol = 1, dimnames = list(NULL, "c1")) %&gt;% 
  setcoltype("Industry -&gt; Product") %&gt;% 
  hatize_byname(keep = "colnames")
# A 1x1 matrix with both row and column names generates a failure.
## Not run: 
matrix(42, nrow = 1, ncol = 1, dimnames = list("r1", "c1")) %&gt;% 
  setrowtype("Product -&gt; Industry") %&gt;% 
  setcoltype("Industry -&gt; Product") %&gt;% 
  hatize_byname()

## End(Not run)
# But you could specify which you want keep, row names or column names.
m &lt;- matrix(42, nrow = 1, ncol = 1, dimnames = list("r1", "c1")) %&gt;% 
  setrowtype("Product -&gt; Industry") %&gt;% 
  setcoltype("Industry -&gt; Product")
m
m %&gt;% 
  hatize_byname(keep = "rownames")
m %&gt;% 
  hatize_byname(keep = "colnames")
</code></pre>

<hr>
<h2 id='identical_byname'>Compare two matrices &quot;by name&quot; for exact equality</h2><span id='topic+identical_byname'></span>

<h3>Description</h3>

<p>If operands are matrices, they are completed and sorted relative to one another prior to comparison.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identical_byname(..., .summarise = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identical_byname_+3A_...">...</code></td>
<td>
<p>Operands to be compared.</p>
</td></tr>
<tr><td><code id="identical_byname_+3A_.summarise">.summarise</code></td>
<td>
<p>Tells whether the operation should be accomplished
across lists (<code>FALSE</code>) or down lists (<code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Comparisons are made by <code>identical(a, b)</code> so that variations among numbers
within the computational precision will return <code>FALSE</code>.
</p>
<p>If fuzzy comparison is needed, use <code><a href="#topic+equal_byname">equal_byname</a></code>,
which compares using <code>isTRUE(all.equal(a, b))</code>.
</p>


<h3>Value</h3>

<p><code>TRUE</code> iff all information is identical, including
row and column types <em>and</em>
row and column names <em>and</em>
entries in the matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- matrix(1:4, nrow = 2)
b &lt;- matrix(1:4, nrow = 2)
identical_byname(a, b)
identical_byname(a, b + 1e-100)
a &lt;- a %&gt;% setrowtype("Industries") %&gt;% setcoltype("Commodities")
identical_byname(a, b) # FALSE because a has row and column types, but b does not.
b &lt;- b %&gt;% setrowtype("Industries") %&gt;% setcoltype("Commodities")
identical_byname(a, b)
dimnames(a) &lt;- list(c("i1", "i2"), c("c1", "c2"))
dimnames(b) &lt;- list(c("c1", "c2"), c("i1", "i2"))
identical_byname(a, b) # FALSE, because row and column names are not equal
dimnames(b) &lt;- dimnames(a)
identical_byname(a, b)
</code></pre>

<hr>
<h2 id='identize_byname'>Named identity matrix or vector</h2><span id='topic+identize_byname'></span>

<h3>Description</h3>

<p>Creates an identity matrix (<strong>I</strong>) or vector (<strong>i</strong>) of same size and with same names and
same row and column types as <code>a</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identize_byname(a, margin = c(1, 2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identize_byname_+3A_a">a</code></td>
<td>
<p>the matrix whose names and dimensions are to be preserved in an identity matrix or vector</p>
</td></tr>
<tr><td><code id="identize_byname_+3A_margin">margin</code></td>
<td>
<p>determines whether an identity vector or matrix is returned. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Behaviour for different values of <code>margin</code> are as follows:
</p>

<ul>
<li><p> If <code>margin = 1</code>, makes a column matrix filled with <code>1</code>s.
Row names and type are taken from row names and type of <code>a</code>.
Column name and type are same as column type of <code>a</code>.
</p>
</li>
<li><p> If <code>margin = 2</code>, make a row matrix filled with <code>1</code>s.
Column names and type are taken from column name and type of <code>a</code>.
Row name and type are same as row type of <code>a</code>.
</p>
</li>
<li><p> If <code>list(c(1,2))</code> (the default), make an identity matrix with <code>1</code>s on the diagonal.
Row and column names are sorted on output.
</p>
</li></ul>



<h3>Value</h3>

<p>An identity matrix or vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M &lt;- matrix(1:16, ncol = 4, dimnames=list(c(paste0("i", 1:4)), paste0("c", 1:4))) %&gt;%
  setrowtype("Industries") %&gt;% setcoltype("Commodities")
identize_byname(M)
identize_byname(M, margin = c(1,2))
identize_byname(M, margin = 1)
identize_byname(M, margin = 2)
N &lt;- matrix(c(-21, -12, -21, -10), ncol = 2, dimnames = list(c("b", "a"), c("b", "a"))) %&gt;%
  setrowtype("Industries") %&gt;% setcoltype("Commodities")
identize_byname(N)
# This also works with lists
identize_byname(list(M, M))
</code></pre>

<hr>
<h2 id='Iminus_byname'>Subtract a matrix with named rows and columns from a suitably named and sized identity matrix (<code>I</code>)</h2><span id='topic+Iminus_byname'></span>

<h3>Description</h3>

<p>The order of rows and columns of <code>m</code> may change before subtracting from <code>I</code>,
because the rows and columns are sorted by name prior to subtracting from <code>I</code>.
Furthermore, if <code>m</code> is not square, it will be made square
before subtracting from <code>I</code> by calling <code>complete_and_sort()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Iminus_byname(a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Iminus_byname_+3A_a">a</code></td>
<td>
<p>The matrix to be subtracted from <code>I</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The difference between an identity matrix (<code>I</code>) and <code>m</code>.
(whose rows and columns have been completed and sorted)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(c(-21, -12, -21, -10), ncol = 2, dimnames = list(c("b", "a"), c("b", "a"))) %&gt;%
  setrowtype("Industries") %&gt;% setcoltype("Commodities")
# Rows and columns are unsorted
diag(1, nrow = 2) - m 
# Rows and columns are sorted prior to subtracting from the identity matrix
Iminus_byname(m) 
# This also works with lists
Iminus_byname(list(m,m))
# If the m is not square before subtracting from I,
# it will be made square by the function complete_and_sort.
m2 &lt;- matrix(c(1,2,3,4,5,6), ncol = 2, dimnames = list(c("a", "b", "c"), c("a", "b"))) %&gt;%
  setrowtype("Industries") %&gt;% setcoltype("Commodities")
Iminus_byname(m2)
</code></pre>

<hr>
<h2 id='invert_byname'>Invert a matrix</h2><span id='topic+invert_byname'></span>

<h3>Description</h3>

<p>This function transposes row and column names as well as row and column types.
Rows and columns of <code>a</code> are sorted prior to inverting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invert_byname(a, method = c("solve", "QR", "SVD"), tol = .Machine$double.eps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invert_byname_+3A_a">a</code></td>
<td>
<p>The matrix to be inverted. <code>a</code> must be square.</p>
</td></tr>
<tr><td><code id="invert_byname_+3A_method">method</code></td>
<td>
<p>One of &quot;solve&quot;, &quot;QR&quot;, or &quot;SVD&quot;. Default is &quot;solve&quot;. See details.</p>
</td></tr>
<tr><td><code id="invert_byname_+3A_tol">tol</code></td>
<td>
<p>The tolerance for detecting linear dependencies in the columns of <code>a</code>.
Default is <code>.Machine$double.eps</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>method</code> argument specifies which method should be used for
calculating the inverse.
&quot;solve&quot; uses <code>base::solve()</code> and the value of <code>tol</code>.
&quot;QR&quot; uses <code>base::solve.qr()</code> and the value of <code>tol</code>.
&quot;SVD&quot; uses <code>matrixcalc::svd.inverse()</code>, ignoring the <code>tol</code> argument.
</p>
<p>Both <code>tol</code> and <code>method</code> should be a single values and apply to all matrices in <code>a</code>.
</p>
<p>If <code>a</code> is a singular matrix,
names of zero rows and columns are reported in the error message.
</p>


<h3>Value</h3>

<p>The inversion of <code>a</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(c(10,0,0,100), nrow = 2, dimnames = list(paste0("i", 1:2), paste0("c", 1:2))) %&gt;%
  setrowtype("Industry") %&gt;% setcoltype("Commodity")
m
invert_byname(m)
matrixproduct_byname(m, invert_byname(m))
matrixproduct_byname(invert_byname(m), m)
invert_byname(list(m,m))
invert_byname(m, method = "QR")
invert_byname(m, method = "SVD")
</code></pre>

<hr>
<h2 id='is_matrix_or_Matrix'>Tells whether an object is one of a matrix or a Matrix</h2><span id='topic+is_matrix_or_Matrix'></span>

<h3>Description</h3>

<p>Often, it helps to know whether an object is a <code>matrix</code> or a <code>Matrix</code>,
and you don't care which.
This function helps in those situations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_matrix_or_Matrix(a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_matrix_or_Matrix_+3A_a">a</code></td>
<td>
<p>The object about which we want to know if it is a <code>matrix</code> or a <code>Matrix</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> when <code>a</code> is a <code>matrix</code> or a <code>Matrix</code>. <code>FALSE</code> otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_matrix_or_Matrix(42)
is_matrix_or_Matrix(matrix(42))
is_matrix_or_Matrix(Matrix::Matrix(42))
is_matrix_or_Matrix(matsbyname::Matrix(42))
</code></pre>

<hr>
<h2 id='is.Matrix'>Is an object a Matrix?</h2><span id='topic+is.Matrix'></span>

<h3>Description</h3>

<p>Arguably, this function should be in the <code>Matrix</code> package,
but it is not.
We include it here for convenience.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.Matrix(a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.Matrix_+3A_a">a</code></td>
<td>
<p>The object to be queried if it is Matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is not vectorized.
</p>
<p><code>is.Matrix()</code> is a wrapper for <code style="white-space: pre;">&#8288;inherits(a, "Matrix)&#8288;</code>.
</p>


<h3>Value</h3>

<p>A boolean. <code>TRUE</code> if <code>a</code> is a <code>Matrix</code>, <code>FALSE</code> otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.Matrix(matrix(42))
is.Matrix(Matrix::Matrix(42))
</code></pre>

<hr>
<h2 id='iszero_byname'>Test whether this is the zero matrix</h2><span id='topic+iszero_byname'></span>

<h3>Description</h3>

<p>Note that this function tests whether the elements of <code>abs(a)</code> are <code style="white-space: pre;">&#8288;&lt;= tol&#8288;</code>.
The default value for <code>tol</code> is <code>1e-6</code>.
So, you can set <code>tol = 0</code> to discover if <code>a</code> is EXACTLY the zero matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iszero_byname(a, tol = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iszero_byname_+3A_a">a</code></td>
<td>
<p>A matrix or list of matrices.</p>
</td></tr>
<tr><td><code id="iszero_byname_+3A_tol">tol</code></td>
<td>
<p>The allowable deviation from 0 for any element.
Interpreted as an absolute value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> Iff this is the zero matrix within <code>tol</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>zero &lt;- matrix(0, nrow = 50, ncol = 50)
iszero_byname(zero)
nonzero &lt;- matrix(1:4, nrow = 2)
iszero_byname(nonzero)
# Also works for lists
iszero_byname(list(zero, nonzero))
# And it works for data frames
DF &lt;- data.frame(A = I(list()), B = I(list()))
DF[[1,"A"]] &lt;- zero
DF[[2,"A"]] &lt;- nonzero
DF[[1,"B"]] &lt;- nonzero
DF[[2,"B"]] &lt;- zero
iszero_byname(DF$A)
iszero_byname(DF$B)
iszero_byname(matrix(1e-10, nrow = 2))
iszero_byname(matrix(1e-10, nrow = 2), tol = 1e-11)
</code></pre>

<hr>
<h2 id='kvec_from_template_byname'>Create a constant vector from matrix <code>a</code></h2><span id='topic+kvec_from_template_byname'></span>

<h3>Description</h3>

<p>This function creates a vector using <code>a</code> as a template
and <code>k</code> as its value.
Row names are taken from the row names of <code>a</code>.
The column name of the output is given by <code>colname</code>.
Row and column types are transferred from <code>a</code> to the output, directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kvec_from_template_byname(a, k = 1, colname = NA, column = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kvec_from_template_byname_+3A_a">a</code></td>
<td>
<p>The template matrix for the column vector.</p>
</td></tr>
<tr><td><code id="kvec_from_template_byname_+3A_k">k</code></td>
<td>
<p>The value of the entries in the output column vector.</p>
</td></tr>
<tr><td><code id="kvec_from_template_byname_+3A_colname">colname</code></td>
<td>
<p>The name of the output vector's 1-sized dimension
(the only column if <code>column</code> is <code>TRUE</code>, the only row otherwise).</p>
</td></tr>
<tr><td><code id="kvec_from_template_byname_+3A_column">column</code></td>
<td>
<p>Tells whether a column vector (if <code>TRUE</code>, the default) or a row vector (if <code>FALSE</code>) should be created.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>column</code> is <code>TRUE</code>, the output is a column vector with
row names taken from row names of <code>a</code> and a column named by <code>colname</code>.
If <code>column</code> is <code>FALSE</code>, the output is a row vevtor with
column names taken from column names of <code>a</code> and a row named by <code>colname</code>.
</p>
<p>If the class of <code>a</code> is <code>Matrix</code>, the output object will be a <code>Matrix</code>.
Otherwise, the class of the output object will be a <code>matrix</code>.
</p>


<h3>Value</h3>

<p>A vector vector formed from <code>a</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kvec_from_template_byname(matrix(42, nrow = 4, ncol = 2,
                                 dimnames = list(c("r1", "r2", "r3", "r4"), c("c1", "c2"))), 
                          colname = "new column")
kvec_from_template_byname(matrix(42, nrow = 4, ncol = 2,
                                 dimnames = list(c("r1", "r2", "r3", "r4"), c("c1", "c2"))), 
                          colname = "new row", column = FALSE)
</code></pre>

<hr>
<h2 id='list_of_rows_or_cols'>Named list of rows or columns of matrices</h2><span id='topic+list_of_rows_or_cols'></span>

<h3>Description</h3>

<p>This function takes matrix <code>m</code> and converts it to a list of
single-row (if <code>margin == 1</code>) or single-column(if <code>margin == 2</code>)
matrices.
Each item in the list is named for its row (if <code>margin == 1</code>)
or column (if <code>margin == 2</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_of_rows_or_cols(a, margin)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list_of_rows_or_cols_+3A_a">a</code></td>
<td>
<p>a matrix or list of matrices (say, from a column of a data frame)</p>
</td></tr>
<tr><td><code id="list_of_rows_or_cols_+3A_margin">margin</code></td>
<td>
<p>the margin of the matrices to be extracted (<code>1</code> for rows, <code>2</code> for columns)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the result provides column vectors, regardless of the value of <code>margin</code>.
</p>


<h3>Value</h3>

<p>a named list of rows or columns extracted from <code>m</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(data = c(1:6), 
            nrow = 2, ncol = 3, 
            dimnames = list(c("p1", "p2"), c("i1", "i2", "i3"))) %&gt;%
  setrowtype(rowtype = "Products") %&gt;% setcoltype(coltype = "Industries")
list_of_rows_or_cols(m, margin = 1)
list_of_rows_or_cols(m, margin = 2)
</code></pre>

<hr>
<h2 id='log_byname'>Logarithm of matrix elements</h2><span id='topic+log_byname'></span>

<h3>Description</h3>

<p>Specify the base of the log with <code>base</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_byname(a, base = exp(1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log_byname_+3A_a">a</code></td>
<td>
<p>A matrix or list of matrices.</p>
</td></tr>
<tr><td><code id="log_byname_+3A_base">base</code></td>
<td>
<p>The base of the logarithm (default is <code>exp(1)</code>, giving the natural logarithm).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>M with each element replaced by its base <code>base</code> logarithm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>log_byname(exp(1))
m &lt;- matrix(c(10,1,1,100), nrow = 2, dimnames = list(paste0("i", 1:2), paste0("c", 1:2))) %&gt;%
  setrowtype("Industry") %&gt;% setcoltype("Commodity")
m
log_byname(m)
log_byname(m, base = 10)
</code></pre>

<hr>
<h2 id='logarithmicmean_byname'>Name- and element-wise logarithmic mean of matrices</h2><span id='topic+logarithmicmean_byname'></span>

<h3>Description</h3>

<p>The logarithmic mean of corresponding entries of <code>a</code> and <code>b</code> is
<code>0</code> if <code>a = 0</code> or <code>b = 0</code>,
<code>a</code> if <code>a = b</code>, or
<code>(b - a) / (log(b) - log(a))</code> otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logarithmicmean_byname(a, b, base = exp(1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logarithmicmean_byname_+3A_a">a</code></td>
<td>
<p>first operand (a matrix or constant value or lists of same).</p>
</td></tr>
<tr><td><code id="logarithmicmean_byname_+3A_b">b</code></td>
<td>
<p>second operand (a matrix or constant value or lists of same).</p>
</td></tr>
<tr><td><code id="logarithmicmean_byname_+3A_base">base</code></td>
<td>
<p>the base of the logarithm used when computing the logarithmic mean.
(Default is <code>base = exp(1)</code>.)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs a union and sorting of row and column names
prior to performing logarithmic mean.
Zeroes are inserted for missing matrix elements.
</p>
<p>Internally, the third condition is implemented as
<code>(b - a) / log(b/a)</code>.
</p>
<p>Note that <code>(b - a) / log(b/a) = (a - b) / log(a/b)</code>,
so logarithmic mean is commutative;
the order of arguments <strong><code>a</code></strong> and <strong><code>b</code></strong>
does not change the result.
</p>


<h3>Value</h3>

<p>A matrix representing the name-wise logarithmic mean
of <code>a</code> and <code>b</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
m1 &lt;- matrix(c(1:6), nrow = 3, ncol = 2) %&gt;% 
  setrownames_byname(c("r1", "r2", "r3")) %&gt;% setcolnames_byname(c("c1", "c2")) %&gt;% 
  setrowtype("row") %&gt;% setcoltype("col")
m2 &lt;- matrix(c(7:12), nrow = 3, ncol = 2) %&gt;% 
  setrownames_byname(c("r2", "r3", "r4")) %&gt;% setcolnames_byname(c("c2", "c3")) %&gt;% 
  setrowtype("row") %&gt;% setcoltype("col")
logarithmicmean_byname(m1, m2)
# This also works with lists
logarithmicmean_byname(list(m1, m1), list(m2, m2))
DF &lt;- data.frame(m1 = I(list()), m2 = I(list()))
DF[[1,"m1"]] &lt;- m1
DF[[2,"m1"]] &lt;- m1
DF[[1,"m2"]] &lt;- m2
DF[[2,"m2"]] &lt;- m2
logarithmicmean_byname(DF$m1, DF$m2)
DF %&gt;% mutate(logmeans = logarithmicmean_byname(m1, m2))
</code></pre>

<hr>
<h2 id='logmean'>Logarithmic mean of two numbers</h2><span id='topic+logmean'></span>

<h3>Description</h3>

<p>Calculates the logarithmic mean of two numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logmean(a, b, base = exp(1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logmean_+3A_a">a</code></td>
<td>
<p>the first operand (must be non-negative)</p>
</td></tr>
<tr><td><code id="logmean_+3A_b">b</code></td>
<td>
<p>the second operand (must be non-negative)</p>
</td></tr>
<tr><td><code id="logmean_+3A_base">base</code></td>
<td>
<p>the base of the logarithm used in this calculation.
(Default is <code>exp(1)</code>.)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an internal helper function for <code>logarithmicmean_byname</code>.
</p>


<h3>Value</h3>

<p><code>0</code> if <code>a = 0</code> or <code>b = 0</code>; <code>x1</code> if <code>a == b</code>; and
<code>(a - b) / log(a/b, base = base)</code>
for all other values of <code>a</code> and <code>b</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>matsbyname:::logmean(0, 0) # 0
matsbyname:::logmean(0, 1) # 0
matsbyname:::logmean(1, 0) # 0
matsbyname:::logmean(1, 1) # 1
matsbyname:::logmean(2, 1)
matsbyname:::logmean(1, 2) # commutative
matsbyname:::logmean(1, 10) # base = exp(1), the default
matsbyname:::logmean(1, 10, base = 10)
</code></pre>

<hr>
<h2 id='margin_from_types_byname'>Translate row and column types to integer margins</h2><span id='topic+margin_from_types_byname'></span>

<h3>Description</h3>

<p>Converts row and column types to integer margins,
based on <code>a</code> and <code>types</code>.
If <code>types</code> is not a character vector, <code>types</code> is returned unmodified.
If <code>types</code> is a character vector, an integer vector is returned
corresponding to the margins on which <code>types</code> are found.
If <code>types</code> are not found in the row or column types of <code>a</code>,
<code>NA_integer_</code> is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>margin_from_types_byname(a, types)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="margin_from_types_byname_+3A_a">a</code></td>
<td>
<p>A matrix or list of matrices.</p>
</td></tr>
<tr><td><code id="margin_from_types_byname_+3A_types">types</code></td>
<td>
<p>A character vector or list of character vectors
representing row or column types whose
corresponding integer margins in <code>a</code> are to be determined.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of integers or list of vectors of integers
corresponding to the margins on which <code>types</code> exist.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Works for single matrices
m &lt;- matrix(1) %&gt;%
  setrowtype("Product") %&gt;% setcoltype("Industry")
margin_from_types_byname(m, "Product")
margin_from_types_byname(m, "Industry")
margin_from_types_byname(m, c("Product", "Industry"))
margin_from_types_byname(m, c("Industry", "Product"))
# Works for lists of matrices
margin_from_types_byname(list(m, m), types = "Product")
margin_from_types_byname(list(m, m), types = "Industry")
margin_from_types_byname(list(m, m), types = c("Product", "Product"))
margin_from_types_byname(list(m, m), types = c("Industry", "Industry"))
margin_from_types_byname(list(m, m), types = c("Product", "Industry"))
margin_from_types_byname(list(m, m), types = list("Product", "Industry"))
margin_from_types_byname(list(m, m), types = list(c("Product", "Industry")))
margin_from_types_byname(list(m, m), types = list(c("Product", "Industry"), 
                                                  c("Product", "Industry")))
# Works in a data frame
m2 &lt;- matrix(2) %&gt;%
  setrowtype("Industry") %&gt;% setcoltype("Product")
df &lt;- tibble::tibble(m = list(m, m2), types = list("Product", c("Product", "Industry")))
res &lt;- df %&gt;%
  dplyr::mutate(
    margin = margin_from_types_byname(m, types)
 )
res$margin
</code></pre>

<hr>
<h2 id='matricize_byname'>Matricize a vector</h2><span id='topic+matricize_byname'></span>

<h3>Description</h3>

<p>Converts a vector with rows or columns named according to <code>notation</code>
into a <code>matrix</code> or a <code>Matrix</code>, depending on the type of <code>a</code>.
Row and column types of the output are taken from the
row or column type of the long dimension of the incoming vector.
If the row or column type of the long dimension of the incoming vector is <code>NULL</code>,
the outgoing matrix will have <code>NULL</code> rowtype and <code>NULL</code> coltype.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matricize_byname(a, notation)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matricize_byname_+3A_a">a</code></td>
<td>
<p>A row (column) vector to be converted to a matrix based on its row (column) names.</p>
</td></tr>
<tr><td><code id="matricize_byname_+3A_notation">notation</code></td>
<td>
<p>A string vector created by <code>RCLabels::notation_vec()</code> that identifies the notation for row or column names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix created from vector <code>a</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- matrix(c(1,
              2,
              3, 
              4), 
            nrow = 4, ncol = 1, dimnames = list(c("p1 -&gt; i1", 
                                                  "p2 -&gt; i1", 
                                                  "p1 -&gt; i2", 
                                                  "p2 -&gt; i2"))) %&gt;% 
  setrowtype("Products -&gt; Industries")
# Default separator is " -&gt; ".
matricize_byname(v, notation = RCLabels::arrow_notation)
</code></pre>

<hr>
<h2 id='Matrix'>Create a Matrix amenable to use in the <code>matsbyname</code> package</h2><span id='topic+Matrix'></span>

<h3>Description</h3>

<p>The <code>matsbyname</code> package uses <code>Matrix</code> objects for its
default data representation, taking advantage
of the sparse matrix capabilities of <code>Matrix</code> compared
to the base <code>matrix</code> class.
This function routes to <code>Matrix::Matrix()</code>, with some important
differences. See details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Matrix(
  data = NA,
  nrow = 1,
  ncol = 1,
  byrow = FALSE,
  dimnames = base::dimnames(data),
  sparse = NULL,
  doDiag = FALSE,
  forceCheck = FALSE,
  rowtype = matsbyname::rowtype(data),
  coltype = matsbyname::coltype(data)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Matrix_+3A_data">data</code></td>
<td>
<p>An optional numeric data vector or <code>matrix.</code></p>
</td></tr>
<tr><td><code id="Matrix_+3A_nrow">nrow</code></td>
<td>
<p>When <code>data</code> is not a <code>matrix</code> or a <code>Matrix</code>, the desired number of rows.
Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="Matrix_+3A_ncol">ncol</code></td>
<td>
<p>When <code>data</code> is not a <code>matrix</code> or a <code>Matrix</code>, the desired number of columns.
Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="Matrix_+3A_byrow">byrow</code></td>
<td>
<p>A boolean. If <code>FALSE</code> (the default) the Matrix is filled by columns, otherwise the Matrix is filled by rows.</p>
</td></tr>
<tr><td><code id="Matrix_+3A_dimnames">dimnames</code></td>
<td>
<p>A dimnames attribute for the Matrix: a list of two character components.
Default is <code>base::dimnames(data)</code>.</p>
</td></tr>
<tr><td><code id="Matrix_+3A_sparse">sparse</code></td>
<td>
<p>A boolean or <code>NULL</code>. Specifies whether the result should be sparse or not.
By default (<code>NULL</code>), the Matrix is made sparse when more than half
of the entries are <code>0</code>.</p>
</td></tr>
<tr><td><code id="Matrix_+3A_dodiag">doDiag</code></td>
<td>
<p>A boolean indicating if a <code>diagonalMatrix</code> object should be returned
when the resulting Matrix is diagonal (mathematically).
Default is <code>FALSE</code>, which is different from <code>Matrix::Matrix()</code>.</p>
</td></tr>
<tr><td><code id="Matrix_+3A_forcecheck">forceCheck</code></td>
<td>
<p>A boolean indicating if the checks for structure should happen
when <code>data</code> is already a <code>Matrix</code> object.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="Matrix_+3A_rowtype">rowtype</code></td>
<td>
<p>The rowtype for the result. Default is <code>matsbyname::rowtype(data)</code>.</p>
</td></tr>
<tr><td><code id="Matrix_+3A_coltype">coltype</code></td>
<td>
<p>The coltype for the result. Default is <code>matsbyname::coltype(data)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function NEVER creates a symmetric matrix
(e.g., <code>dsCMatrix</code>, <code>dsyMatrix</code>, <code>dsRMatrix</code>, <code>lsyMatrix</code>, <code>nsyMatrix</code>),
because symmetric matrices do not respect some future changes to <code>dimnames</code>,
which can cause information loss in the <code>matsbyname</code> context.
A non-symmetric <code>Matrix</code> is assured by calling <code>as(out, "generalMatrix")</code>
on the outgoing <code>Matrix</code> object.
</p>
<p>This function enables setting row and column types at the time of construction
with the <code>rowtype</code> and <code>coltype</code> arguments.
</p>
<p>This function has different defaults compared to <code>Matrix::Matrix()</code>, including
</p>

<ul>
<li><p> Here, the default for <code>doDiag</code> is <code>FALSE</code>,
while the default for <code>doDiag</code> is <code>TRUE</code> for <code>Matrix::Matrix()</code>.
</p>
</li>
<li><p> Preserves rowtype and coltype on <code>data</code>.
</p>
</li></ul>

<p>This function is vectorized over a list of <code>matrix</code> objects supplied to <code>data</code>.
See examples.
</p>


<h3>Value</h3>

<p>A <code>Matrix</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># matsbyname::Matrix() will not create a Matrix with a symmetric subclass.
# dgCMatrix is a general matrix.
matsbyname::Matrix(c(1, 0, 2, 
                     0, 0, 0, 
                     2, 0, 0), byrow = TRUE, nrow = 3, ncol = 3)
# But Matrix::Matrix() will create a symmetric matrix.
# dsCMatrix is a symmetric matrix.
Matrix::Matrix(c(1, 0, 2, 
                 0, 0, 0, 
                 2, 0, 0), byrow = TRUE, nrow = 3, ncol = 3)
# matsbyname::Matrix() will not create a diagonal matrix.
# dgeMatrix is a general matrix.
matsbyname::Matrix(c(1, 0, 
                     0, 1), byrow = TRUE, nrow = 2, ncol = 2)
# But Matrix::Matrix() will create a diagonal matrix.
# ddiMatrix is a diagonal matrix.
Matrix::Matrix(c(1, 0, 
                 0, 1), byrow = TRUE, nrow = 2, ncol = 2)
# This function is vectorized over lists of `matrix` objects in `data`.
m &lt;- matrix(c(1, 0, 2, 
              0, 0, 0, 
              2, 0, 0), byrow = TRUE, nrow = 3, ncol = 3)
matsbyname::Matrix(list(m, m))
</code></pre>

<hr>
<h2 id='matrixproduct_byname'>Name-wise matrix multiplication</h2><span id='topic+matrixproduct_byname'></span>

<h3>Description</h3>

<p>Multiplies operands from left to right
(when <code>.summarise = FALSE</code>).
If <code>.summarise = TRUE</code>,
operands are multiplied from first to last.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrixproduct_byname(..., .summarise = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrixproduct_byname_+3A_...">...</code></td>
<td>
<p>Operands; constants, matrices, or lists of matrices.</p>
</td></tr>
<tr><td><code id="matrixproduct_byname_+3A_.summarise">.summarise</code></td>
<td>
<p>When <code>TRUE</code>, a matrix multiplication proceeds down lists of arguments.
When <code>FALSE</code> (the default), items are multiplied across lists.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs a union and sorting of multiplicand rows and multiplier columns by name
prior to multiplication.
Zeroes are inserted for missing matrix elements.
Doing so ensures that
the dimensions of multiplicand and multiplier matrices will be conformable.
I.e., the number of columns in multiplicand
will equal the number of rows in multiplier,
so long as the column names of multiplicand are unique and
the row names of multiplier are unique.
If column type of the multiplicand is not same as
row type of the multiplier on any step of the multiplication,
the function will fail.
The result is matrix product
with row names from the first multiplicand and column names from the last multiplier.
</p>


<h3>Value</h3>

<p>A matrix representing the name-wise product of operands.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
V &lt;- matrix(1:6, ncol = 3, dimnames = list(c("i1", "i2"), c("c1", "c2", "c3"))) %&gt;%
  setrowtype("Industries") %&gt;% setcoltype("Commodities")
G &lt;- matrix(1:4, ncol = 2, dimnames = list(c("c2", "c1"), c("i2", "i1"))) %&gt;%
  setrowtype("Commodities") %&gt;% setcoltype("Industries")
Z &lt;- matrix(11:14, ncol = 2, dimnames = list(c("i1", "i2"), c("s1", "s2"))) %&gt;% 
  setrowtype("Industries") %&gt;% setcoltype("Sectors")
# Succeeds because G is completed to include a row named c3 (that contains zeroes).
matrixproduct_byname(V, G)
## Not run: V %*% G # Fails because E lacks a row named c3.
matrixproduct_byname(V, G, Z)
# This also works with lists
matrixproduct_byname(list(V,V), list(G,G))
DF &lt;- data.frame(V = I(list()), G = I(list()))
DF[[1,"V"]] &lt;- V
DF[[2,"V"]] &lt;- V
DF[[1,"G"]] &lt;- G
DF[[2,"G"]] &lt;- G
matrixproduct_byname(DF$V, DF$G)
DF %&gt;% mutate(matprods = matrixproduct_byname(V, G))
# Also works with lists, multiplying down the lists if `.summarise = TRUE`.
matrixproduct_byname(list(V, G, Z), .summarise = TRUE)
</code></pre>

<hr>
<h2 id='mean_byname'>Name- and element-wise arithmetic mean of matrices</h2><span id='topic+mean_byname'></span>

<h3>Description</h3>

<p>Gives the arithmetic mean of operands in <code>...</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_byname(..., .summarise = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_byname_+3A_...">...</code></td>
<td>
<p>Operands: constants, matrices, or lists of matrices.</p>
</td></tr>
<tr><td><code id="mean_byname_+3A_.summarise">.summarise</code></td>
<td>
<p>Tells whether the operation should be accomplished
across lists (<code>FALSE</code>) or down lists (<code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs a union and sorting of row and column names
prior to performing arithmetic mean.
Zeroes are inserted for missing matrix elements.
</p>


<h3>Value</h3>

<p>name-wise arithmetic mean of operands.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
mean_byname(100, 50)
mean_byname(10, 20, 30)
commoditynames &lt;- c("c1", "c2")
industrynames &lt;- c("i1", "i2")
U &lt;- matrix(1:4, ncol = 2, dimnames = list(commoditynames, industrynames)) %&gt;%
  setrowtype("Commodities") %&gt;% setcoltype("Industries")
G &lt;- matrix(rev(1:4), ncol = 2, dimnames = list(rev(commoditynames), rev(industrynames))) %&gt;%
  setrowtype("Commodities") %&gt;% setcoltype("Industries")
(U + G) / 2 # Non-sensical. Row and column names not respected.
mean_byname(U, G) # Row and column names respected! Should be 1, 2, 3, and 4. 
mean_byname(U, G, G)
mean_byname(100, U)
mean_byname(100, 50, U)
mean_byname(10, G)
# This also works with lists
mean_byname(list(100, 100), list(50, 50))
mean_byname(list(U,U), list(G,G))
DF &lt;- data.frame(U = I(list()), G = I(list()))
DF[[1,"U"]] &lt;- U
DF[[2,"U"]] &lt;- U
DF[[1,"G"]] &lt;- G
DF[[2,"G"]] &lt;- G
mean_byname(DF$U, DF$G)
DF %&gt;% mutate(means = mean_byname(U, G))
</code></pre>

<hr>
<h2 id='naryapply_byname'>Apply a function &quot;by name&quot; to any number of operands</h2><span id='topic+naryapply_byname'></span>

<h3>Description</h3>

<p>Applies <code>FUN</code> to all operands in <code>...</code>.
Other arguments have similar meaning as <code>binaryapply_byname()</code>.
See details for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>naryapply_byname(
  FUN,
  ...,
  .FUNdots = NULL,
  match_type = c("all", "matmult", "none"),
  set_rowcoltypes = TRUE,
  .organize = TRUE,
  .summarise = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="naryapply_byname_+3A_fun">FUN</code></td>
<td>
<p>a binary function to be applied &quot;by name&quot; to all operands in <code>...</code>.</p>
</td></tr>
<tr><td><code id="naryapply_byname_+3A_...">...</code></td>
<td>
<p>the operands for <code>FUN</code>.</p>
</td></tr>
<tr><td><code id="naryapply_byname_+3A_.fundots">.FUNdots</code></td>
<td>
<p>a list of additional named arguments passed to <code>FUN</code>.</p>
</td></tr>
<tr><td><code id="naryapply_byname_+3A_match_type">match_type</code></td>
<td>
<p>One of &quot;all&quot;, &quot;matmult&quot;, or &quot;none&quot;.
When <code>...</code> are matrices,
&quot;all&quot; (the default) indicates that
rowtypes of all <code>...</code> matrices must match and
coltypes of all <code>...</code> matrices must match.
If &quot;matmult&quot;,
the coltype of the first operand must match the rowtype of the second operand
for every sequential invocation of <code>FUN</code>.
If &quot;none&quot;,
neither coltypes nor rowtypes are checked by <code>naryapply_byname()</code>.</p>
</td></tr>
<tr><td><code id="naryapply_byname_+3A_set_rowcoltypes">set_rowcoltypes</code></td>
<td>
<p>Tells whether to apply row and column types from
operands in <code>...</code> to the output of each sequential invocation of <code>FUN</code>.
Set <code>TRUE</code> (the default) to apply row and column types.
Set <code>FALSE</code>, to <em>not</em> apply row and column types to the output.</p>
</td></tr>
<tr><td><code id="naryapply_byname_+3A_.organize">.organize</code></td>
<td>
<p>A boolean that tells whether or not to automatically
complete operands in <code>...</code> relative to each other and
sort the rows and columns of the completed matrices.
This organizing is done on each sequential invocation of <code>FUN</code>.
Normally, this should be <code>TRUE</code> (the default).
However, if <code>FUN</code> takes over this responsibility, set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="naryapply_byname_+3A_.summarise">.summarise</code></td>
<td>
<p>A boolean that tells whether this call is considered
a summarise operation (like <code>dplyr::summarise()</code>).
Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If only one <code>...</code> argument is supplied,
<code>FUN</code> must be capable of handling one argument, and
the call is routed to <code>unaryapply_byname()</code>.
When <code>set_rowcoltypes</code> is <code>TRUE</code>,
the <code>rowcoltypes</code> argument of <code>unaryapply_byname()</code> is set to &quot;all&quot;,
but when <code>set_rowcoltypes</code> is <code>FALSE</code>,
the <code>rowcoltypes</code> argument of <code>unaryapply_byname()</code> is set to &quot;none&quot;.
If finer control is desired, the caller should use <code>unaryapply_byname()</code> directly.
If more than one argument is passed in <code>...</code>,
<code>FUN</code> must be a binary function, but its use in by <code>naryapply_byname()</code> is &quot;n-ary.&quot;
Arguments <code>match_type</code>, <code>set_rowcoltypes</code>, and <code>.organize</code>
have same meaning as for <code>binaryapply_byname()</code>.
Thus, all of the operands in <code>...</code> must obey the rules of type matching
when <code>match_type</code> is <code>TRUE</code>.
</p>
<p><code>naryapply_byname()</code> and <code>cumapply_byname()</code> are similar.
Their differences can be described by considering a data frame.
<code>naryapply_byname()</code> applies <code>FUN</code> to several columns (variables) of the data frame.
For example, <code>sum_byname()</code> applied to several variables gives another column
containing the sums across each row of the data frame.
<code>cumapply_byname()</code> applies <code>FUN</code> to successive entries in a single column.
For example <code>sum_byname()</code> applied to a single column gives the sum of all numbers in that column.
</p>


<h3>Value</h3>

<p>the result of applying <code>FUN</code> to all operands in <code>...</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>naryapply_byname(FUN = sum_byname, 2, 3)
naryapply_byname(FUN = sum_byname, 2, 3, 4, -4, -3, -2)
# Routes to unaryapply_byname
naryapply_byname(FUN = `^`, list(1,2,3), .FUNdots = list(2))
</code></pre>

<hr>
<h2 id='naryapplylogical_byname'>Apply a function logically to numbers, matrices, or lists of numbers or matrices</h2><span id='topic+naryapplylogical_byname'></span>

<h3>Description</h3>

<p>Operands should be logical, although numerical operands are accepted.
Numerical operands are interpreted as <code>0</code> is <code>FALSE</code>, and
any other number is <code>TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>naryapplylogical_byname(
  FUN,
  ...,
  .FUNdots = NULL,
  match_type = c("all", "matmult", "none"),
  set_rowcoltypes = TRUE,
  .organize = TRUE,
  .summarise = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="naryapplylogical_byname_+3A_fun">FUN</code></td>
<td>
<p>a binary function (that returns logical values) to be applied over operands</p>
</td></tr>
<tr><td><code id="naryapplylogical_byname_+3A_...">...</code></td>
<td>
<p>operands; constants, matrices, or lists of matrices</p>
</td></tr>
<tr><td><code id="naryapplylogical_byname_+3A_.fundots">.FUNdots</code></td>
<td>
<p>a list of additional named arguments passed to <code>FUN</code>.</p>
</td></tr>
<tr><td><code id="naryapplylogical_byname_+3A_match_type">match_type</code></td>
<td>
<p>One of &quot;all&quot;, &quot;matmult&quot;, or &quot;none&quot;.
When <code>...</code> are matrices,
&quot;all&quot; (the default) indicates that
rowtypes of all <code>...</code> matrices must match and
coltypes of all <code>...</code> matrices must match.
If &quot;matmult&quot;,
the coltype of the first operand must match the rowtype of the second operand
for every sequential invocation of <code>FUN</code>.
If &quot;none&quot;,
neither coltypes nor rowtypes are checked by <code>naryapply_byname()</code>.</p>
</td></tr>
<tr><td><code id="naryapplylogical_byname_+3A_set_rowcoltypes">set_rowcoltypes</code></td>
<td>
<p>Tells whether to apply row and column types from
operands in <code>...</code> to the output of each sequential invocation of <code>FUN</code>.
Set <code>TRUE</code> (the default) to apply row and column types.
Set <code>FALSE</code>, to <em>not</em> apply row and column types to the output.</p>
</td></tr>
<tr><td><code id="naryapplylogical_byname_+3A_.organize">.organize</code></td>
<td>
<p>A boolean that tells whether or not to automatically
complete operands in <code>...</code> relative to each other and
sort the rows and columns of the completed matrices.
This organizing is done on each sequential invocation of <code>FUN</code>.
Normally, this should be <code>TRUE</code> (the default).
However, if <code>FUN</code> takes over this responsibility, set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="naryapplylogical_byname_+3A_.summarise">.summarise</code></td>
<td>
<p>A boolean that tells whether this call is considered
a summarise operation (like <code>dplyr::summarise()</code>).
Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is not exported,
thereby retaining the right to future changes.
</p>


<h3>Value</h3>

<p>the result of <code>FUN</code> applied logically to <code>...</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>matsbyname:::naryapplylogical_byname(`&amp;`, TRUE, TRUE, TRUE)
matsbyname:::naryapplylogical_byname(`&amp;`, TRUE, TRUE, FALSE)
</code></pre>

<hr>
<h2 id='ncol_byname'>Get the number of columns in a &quot;byname&quot; matrix.</h2><span id='topic+ncol_byname'></span>

<h3>Description</h3>

<p>The function gets the number of columns in a &quot;byname&quot; matrix, or for each &quot;byname&quot; matrix contained
in a column of a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ncol_byname(a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ncol_byname_+3A_a">a</code></td>
<td>
<p>A matrix or a column of a data frame populated with &quot;byname&quot; matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of columns of the matrix, or a list containing the number of columns
in each of the matrices contained in the column of a data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>productnames &lt;- c("p1", "p2")
industrynames &lt;- c("i1", "i2")
U &lt;- matrix(1:4, ncol = 2, dimnames = list(productnames, industrynames)) %&gt;% 
  setrowtype("Products") %&gt;% 
  setcoltype("Industries")
productnames &lt;- c("p1", "p2")
industrynames &lt;- c("i1", "i2", "i3")
U2 &lt;- matrix(1:3, ncol = length(industrynames), 
             nrow = length(productnames), dimnames = list(productnames, industrynames)) %&gt;% 
  setrowtype("Products") %&gt;% 
  setcoltype("Industries")
productnames &lt;- c("p1", "p2", "p3")
industrynames &lt;- c("i1", "i2", "i3", "i4")
U3 &lt;- matrix(1:4, ncol = length(industrynames), 
             nrow = length(productnames), dimnames = list(productnames, industrynames)) %&gt;% 
  setrowtype("Products") %&gt;% 
  setcoltype("Industries")
dfUs &lt;- data.frame(
  year = numeric(),
  matrix_byname = I(list())
)
  dfUs &lt;- data.frame(
year = numeric(),
matrix_byname = I(list())
)
dfUs[[1, "matrix_byname"]] &lt;- U
dfUs[[2, "matrix_byname"]] &lt;- U2
dfUs[[3, "matrix_byname"]] &lt;- U3
dfUs[[1, "year"]] &lt;- 2000
dfUs[[2, "year"]] &lt;- 2001
dfUs[[3, "year"]] &lt;- 2002
number_cols &lt;- ncol_byname(dfUs$matrix_byname) %&gt;% 
print()
</code></pre>

<hr>
<h2 id='nrow_byname'>Get the number of rows in a &quot;byname&quot; matrix.</h2><span id='topic+nrow_byname'></span>

<h3>Description</h3>

<p>The function gets the number of rows in a &quot;byname&quot; matrix, or for each &quot;byname&quot; matrix contained
in a column of a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nrow_byname(a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nrow_byname_+3A_a">a</code></td>
<td>
<p>A matrix or a column of a data frame populated with &quot;byname&quot; matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of rows of the matrix, or a list containing the number of rows
in each of the matrices contained in the column of a data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>productnames &lt;- c("p1", "p2")
industrynames &lt;- c("i1", "i2")
U &lt;- matrix(1:4, ncol = 2, dimnames = list(productnames, industrynames)) %&gt;% 
  setrowtype("Products") %&gt;% 
  setcoltype("Industries")
productnames &lt;- c("p1", "p2")
industrynames &lt;- c("i1", "i2", "i3")
U2 &lt;- matrix(1:3, ncol = length(industrynames), 
             nrow = length(productnames), dimnames = list(productnames, industrynames)) %&gt;% 
  setrowtype("Products") %&gt;% 
  setcoltype("Industries")
productnames &lt;- c("p1", "p2", "p3")
industrynames &lt;- c("i1", "i2", "i3", "i4")
U3 &lt;- matrix(1:4, ncol = length(industrynames), 
             nrow = length(productnames), dimnames = list(productnames, industrynames)) %&gt;% 
  setrowtype("Products") %&gt;% 
  setcoltype("Industries")
dfUs &lt;- data.frame(
  year = numeric(),
  matrix_byname = I(list())
)
dfUs[[1, "matrix_byname"]] &lt;- U
dfUs[[2, "matrix_byname"]] &lt;- U2
dfUs[[3, "matrix_byname"]] &lt;- U3
dfUs[[1, "year"]] &lt;- 2000
dfUs[[2, "year"]] &lt;- 2001
dfUs[[3, "year"]] &lt;- 2002
number_rows &lt;- matsbyname::nrow_byname(dfUs$matrix_byname)
</code></pre>

<hr>
<h2 id='organize_args'>Organize binary arguments</h2><span id='topic+organize_args'></span>

<h3>Description</h3>

<p>Organizes arguments of binary (2 arguments) <code style="white-space: pre;">&#8288;_byname&#8288;</code> functions.
Actions performed are:
</p>

<ul>
<li><p>if only one argument is a list, make the other argument also a list of equal length.
</p>
</li>
<li><p>if both arguments are lists, ensure that they are same length.
</p>
</li>
<li><p>if one argument is a matrix and the other is a constant, make the constant into a matrix.
</p>
</li>
<li><p>ensures that row and column types match for <code>typematch_margins</code>.
</p>
</li>
<li><p>ensures that list item names match if both <code>a</code> and <code>b</code> are lists;
no complaints are made if neither <code>a</code> nor <code>b</code> has names.
</p>
</li>
<li><p>completes and sorts the matrices.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>organize_args(a, b, match_type = "all", fill)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="organize_args_+3A_a">a</code></td>
<td>
<p>the first argument to be organized</p>
</td></tr>
<tr><td><code id="organize_args_+3A_b">b</code></td>
<td>
<p>the second argument to be organized</p>
</td></tr>
<tr><td><code id="organize_args_+3A_match_type">match_type</code></td>
<td>
<p>one of <code>"all"</code>, <code>"matmult"</code>, <code>"none"</code>.
When both <code>a</code> and <code>b</code> are matrices,
&quot;<code>all</code>&quot; (the default) indicates that
rowtypes of <code>a</code> must match rowtypes of <code>b</code> and
coltypes of <code>a</code> must match coltypes of <code>b</code>.
If &quot;<code>matmult</code>&quot;,
coltypes of <code>a</code> must match rowtypes of <code>b</code>.</p>
</td></tr>
<tr><td><code id="organize_args_+3A_fill">fill</code></td>
<td>
<p>a replacement value for <code>a</code> or <code>b</code> if either is missing or <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with two elements (named <code>a</code> and <code>b</code>) containing organized versions of the arguments
</p>

<hr>
<h2 id='pow_byname'>Powers of matrix elements</h2><span id='topic+pow_byname'></span>

<h3>Description</h3>

<p>Gives the result of raising all elements of a matrix or list of matrices to a power.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pow_byname(a, pow)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pow_byname_+3A_a">a</code></td>
<td>
<p>a matrix of list of matrices</p>
</td></tr>
<tr><td><code id="pow_byname_+3A_pow">pow</code></td>
<td>
<p>the power to which elements of <code>a</code> will be raised</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>a</code> with each element raised to <code>pow</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
pow_byname(2, 3)
m &lt;- matrix(2, nrow = 2, ncol = 3, dimnames = list(paste0("r", 1:2), paste0("c", 1:3))) %&gt;% 
  setrowtype("rows") %&gt;% setcoltype("cols")
pow_byname(m, 2)
DF &lt;- data.frame(m = I(list()), pow = I(list()))
DF[[1, "m"]] &lt;- m
DF[[2, "m"]] &lt;- m
DF[[1, "pow"]] &lt;- 0.5
DF[[2, "pow"]] &lt;- -1
DF %&gt;% mutate(
  sqrtm = pow_byname(m, 0.5),
  mtopow = pow_byname(m, pow)
)
</code></pre>

<hr>
<h2 id='prep_vector_arg'>Prepare a vector argument</h2><span id='topic+prep_vector_arg'></span>

<h3>Description</h3>

<p>This is a helper function for many <code style="white-space: pre;">&#8288;*_byname&#8288;</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_vector_arg(a, vector_arg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prep_vector_arg_+3A_a">a</code></td>
<td>
<p>A matrix or list of matrices.</p>
</td></tr>
<tr><td><code id="prep_vector_arg_+3A_vector_arg">vector_arg</code></td>
<td>
<p>The vector argument over which to apply a calculation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is potentially ambiguous to specify a vector or matrix argument, say, <code>margin = c(1, 2)</code> when applying
the <code style="white-space: pre;">&#8288;*_byname&#8288;</code> functions to unary list of <code>a</code>.
Rather, one should specify, say, <code>margin = list(c(1, 2))</code>
to avoid ambiguity.
If <code>a</code> is a list,
<code>vector_arg</code> is not a list and has length &gt; 1 and length not equal to the length of a,
this function returns a list value for <code>vector_arg</code>.
If <code>a</code> is not a list and <code>vector_arg</code> is a list,
this function returns an un-recursive, unlisted version of <code>vector_arg</code>.
</p>
<p>Note that if <code>vector_arg</code> is a single matrix, it is automatically enclosed by a list when <code>a</code> is a list.
</p>


<h3>Value</h3>

<p><code>vector_arg</code>, possibly modified when <code>a</code> is a list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(c(2, 2))
prep_vector_arg(m, vector_arg = c(1,2))
prep_vector_arg(list(m), vector_arg = c(1,2))
prep_vector_arg(list(m, m), vector_arg = c(1,2))
prep_vector_arg(list(m, m, m), vector_arg = c(1,2))
</code></pre>

<hr>
<h2 id='prepare_.FUNdots'>Prepare the <code>.FUNdots</code> argument for <code style="white-space: pre;">&#8288;*apply_byname&#8288;</code> functions.</h2><span id='topic+prepare_.FUNdots'></span>

<h3>Description</h3>

<p>This is a helper function for the various <code style="white-space: pre;">&#8288;*apply_byname&#8288;</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_.FUNdots(a, .FUNdots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare_.FUNdots_+3A_a">a</code></td>
<td>
<p>the main argument to an <code style="white-space: pre;">&#8288;*apply_byname&#8288;</code> function.</p>
</td></tr>
<tr><td><code id="prepare_.FUNdots_+3A_.fundots">.FUNdots</code></td>
<td>
<p>a list of additional arguments to be applied to <code>FUN</code> in one of the <code style="white-space: pre;">&#8288;*apply_byname&#8288;</code> functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We have four cases between a and any single item of .FUNdots:
</p>

<ul>
<li><p> both a and the item of .FUNdots are lists
</p>

<ul>
<li><p> if the item of .FUNdots (a list itself) has length different from 1 or length(a), throw an error
</p>
</li>
<li><p> if the item of .FUNdots (a list itself) has length 1, replicate the single item to be a list of length = length(a)
</p>
</li>
<li><p> if the item of .FUNdots (a list itself) has length = length(a), use the item of .FUNdots as is
</p>
</li></ul>

</li>
<li><p> a is a list but the item (argument) of .FUNdots is NOT a list
</p>

<ul>
<li><p> if the item of .FUNdots (which is not a list) has length != 1, throw an error,
because there is ambiguity how the item of .FUNdots should be treated.
</p>
</li>
<li><p> if the item of .FUNdots (which is not a list) has length = 1, replicate that single item to be a list of length = length(a)
</p>
</li></ul>

</li>
<li><p> a is NOT a list, but the item of .FUNdots IS a list
</p>

<ul>
<li><p> pass the argument along and hope for the best.  This situation is probably an error.  If so, it will become apparent soon.
</p>
</li></ul>

</li>
<li><p> neither a nor the item of .FUNdots is a list
</p>

<ul>
<li><p> a should have length = 1, but a single matrix reports its length as the number of elements of the matrix.
So, we can't check length in this situation.
</p>
</li>
<li><p> the item of .FUNdots is assumed to have length 1 and passed along
</p>
</li></ul>

</li></ul>



<h3>Value</h3>

<p>a reconfigured version of <code>.FUNdots</code>, ready for use by an <code style="white-space: pre;">&#8288;*apply_byname&#8288;</code> function.
</p>

<ul>
<li><p> both a and the item of .FUNdots are lists
</p>

<ul>
<li><p> if the item of .FUNdots (a list itself) has length different from 1 or length(a), throw an error
</p>
</li>
<li><p> if the item of .FUNdots (a list itself) has length 1, replicate the single item to be a list of length = length(a)
</p>
</li>
<li><p> if the item of .FUNdots (a list itself) has length = length(a), use the item of .FUNdots as is
</p>
</li></ul>

</li>
<li><p> a is NOT a list, but the item of .FUNdots IS a list
</p>

<ul>
<li><p> pass the argument along and hope for the best.  This situation is probably an error.
If so, it will become apparent soon.
</p>
</li></ul>

</li>
<li><p> a is a list but the item (argument) of .FUNdots is NOT a list
This situation could be ambiguous.
Let's say the list of <code>a</code> values has length 2, and an argument <code>margin = c(1, 2)</code>.
Should <code>margin = 1</code> be applied to <code>a[[1]]</code> and <code>margin = 2</code> be applied to <code>a[[2]]</code>?
Or should <code>margin = c(1, 2)</code> be applied to both <code>a[[1]]</code> and <code>a[[2]]</code>?
This ambiguity should be handled by using the function <code>prep_vector_arg()</code>
within the function that calls <code>unaryapply_byname()</code>.
For an example, see <code>identize_byname()</code>.
When the arguments are coming in from a data frame, there will be no ambiguity,
but the information will not be coming <code>.FUNdots[[i]]</code> as a list.
Optimizing for the data frame case,
this function allows vectors of length equal to the length of the list <code>a</code>,
interpreting such vectors as applying in sequence to each <code>a</code> in turn.
So the algorithm is as follows:
</p>

<ul>
<li><p> if a non-NULL item of .FUNdots (which is not a list) has
length other than 1 or length(a), throw an error.
</p>
</li>
<li><p> if a non-NULL item of .FUNdots (which is not a list) has length = 1,
replicate that single item to be a list of length = length(a).
</p>
</li>
<li><p> if a non-NULL item of .FUNdots (which is not a list) has length = length(a),
leave it as-is.
</p>
</li></ul>

</li>
<li><p> neither a nor the item of .FUNdots is a list
</p>

<ul>
<li><p> a should have length = 1, but a single matrix reports its length as the number of elements of the matrix.
So, we can't check length in this situation.
</p>
</li>
<li><p> the item of .FUNdots is assumed to have length 1 and passed along
</p>
</li></ul>

</li></ul>


<hr>
<h2 id='prodall_byname'>Product of all elements in a matrix</h2><span id='topic+prodall_byname'></span>

<h3>Description</h3>

<p>This function is equivalent to <code style="white-space: pre;">&#8288;a \%&gt;\% rowprods_byname() \%&gt;\% colprods_byname()&#8288;</code>,
but returns a single numeric value instead of a 1x1 matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prodall_byname(a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prodall_byname_+3A_a">a</code></td>
<td>
<p>The matrix whose elements are to be multiplied.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The product of all elements in <code>a</code> as a numeric.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
M &lt;- matrix(2, nrow=2, ncol=2, dimnames = list(paste0("i", 1:2), paste0("c", 1:2))) %&gt;%
  setrowtype("Industry") %&gt;% setcoltype("Product")
prodall_byname(M)
rowprods_byname(M) %&gt;% colprods_byname
# Also works for lists
prodall_byname(list(M,M))
DF &lt;- data.frame(M = I(list()))
DF[[1,"M"]] &lt;- M
DF[[2,"M"]] &lt;- M
prodall_byname(DF$M[[1]])
prodall_byname(DF$M)
res &lt;- DF %&gt;% mutate(
  prods = prodall_byname(M)
)
res$prods
</code></pre>

<hr>
<h2 id='quotient_byname'>Name-wise matrix element division</h2><span id='topic+quotient_byname'></span>

<h3>Description</h3>

<p>Element-wise division of two matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quotient_byname(dividend, divisor)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quotient_byname_+3A_dividend">dividend</code></td>
<td>
<p>Dividend matrix or constant</p>
</td></tr>
<tr><td><code id="quotient_byname_+3A_divisor">divisor</code></td>
<td>
<p>Divisor matrix or constant</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs a union and sorting of names of rows and columns for both <code>dividend</code> and <code>divisor</code>
prior to element division.
Zeroes are inserted for missing matrix elements.
Doing so ensures that
the dimensions of the <code>dividend</code> and <code>divisor</code> will be conformable.
</p>


<h3>Value</h3>

<p>A matrix representing the name-wise element quotient of <code>dividend</code> and <code>divisor</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
quotient_byname(100, 50)
commoditynames &lt;- c("c1", "c2")
industrynames &lt;- c("i1", "i2")
U &lt;- matrix(1:4, ncol = 2, dimnames = list(commoditynames, industrynames)) %&gt;%
  setrowtype("Commodities") %&gt;% setcoltype("Industries")
G &lt;- matrix(rev(1:4), ncol = 2, dimnames = list(rev(commoditynames), rev(industrynames))) %&gt;%
  setrowtype("Commodities") %&gt;% setcoltype("Industries")
U / G # Non-sensical.  Names aren't aligned
quotient_byname(U, G)
quotient_byname(U, 10)
quotient_byname(10, G)
# This also works with lists
quotient_byname(10, list(G,G))
quotient_byname(list(G,G), 10)
quotient_byname(list(U, U), list(G, G))
DF &lt;- data.frame(U = I(list()), G = I(list()))
DF[[1,"U"]] &lt;- U
DF[[2,"U"]] &lt;- U
DF[[1,"G"]] &lt;- G
DF[[2,"G"]] &lt;- G
quotient_byname(DF$U, DF$G)
DF %&gt;% mutate(elementquotients = quotient_byname(U, G))
</code></pre>

<hr>
<h2 id='rename_to_piece_byname'>Rename matrix rows and columns by piece of row or column names</h2><span id='topic+rename_to_piece_byname'></span>

<h3>Description</h3>

<p>It can be convenient to rename rows or columns of matrices
based on retaining only a piece of the row and/or column names.
This function provides that capability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rename_to_piece_byname(
  a,
  piece,
  margin = list(c(1, 2)),
  inf_notation = TRUE,
  notation = list(RCLabels::notations_list),
  choose_most_specific = FALSE,
  prepositions = list(RCLabels::prepositions_list)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rename_to_piece_byname_+3A_a">a</code></td>
<td>
<p>A matrix or list of matrices whose rows or columns will be renamed.</p>
</td></tr>
<tr><td><code id="rename_to_piece_byname_+3A_piece">piece</code></td>
<td>
<p>A character string indicating which piece of the row or column names to retain,
one of &quot;noun&quot;, &quot;pps&quot;, &quot;pref&quot; or &quot;suff&quot;, or a preposition,
indicating which part of the row or column name is to be retained.</p>
</td></tr>
<tr><td><code id="rename_to_piece_byname_+3A_margin">margin</code></td>
<td>
<p>As a character, the row type or column type to be renamed.
As an integer, the margin to be renamed.
Default is <code>c(1, 2)</code>, meaning that both
rows (<code>margin = 1</code>) and columns (<code>margin = 2</code>)
will be renamed.</p>
</td></tr>
<tr><td><code id="rename_to_piece_byname_+3A_inf_notation">inf_notation</code></td>
<td>
<p>A boolean that tells whether to infer notation.
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="rename_to_piece_byname_+3A_notation">notation</code></td>
<td>
<p>The notation used for row and column labels.
Default is <code>list(RCLabels::notations_list)</code>.
The default value is wrapped in a list,
because <code>RCLabels::notations_list</code> is, itself, a list.
If <code>notation</code> is not a list, unexpected behavior can result.
See <code>RCLabels</code>.</p>
</td></tr>
<tr><td><code id="rename_to_piece_byname_+3A_choose_most_specific">choose_most_specific</code></td>
<td>
<p>A boolean that indicates whether the most-specific notation
will be inferred when more than one of <code>notation</code> matches
a row or column label
and <code>allow_multiple = FALSE</code>.
When <code>FALSE</code>, the first matching notation in <code>notations</code>
is returned when <code>allow_multiple = FALSE</code>.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="rename_to_piece_byname_+3A_prepositions">prepositions</code></td>
<td>
<p>Prepositions that can be used in the row and column label.
Default is <code>RCLabels::prepositions_list</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internally, this function finds pieces of row and column names
via the <code>RCLabels</code> package.
<code>piece</code> can be anything that <code>RCLabels::get_piece()</code> understands.
Note that <code>margin</code> can be either an integer vector or
a character vector.
If <code>margin</code> is a character vector,
it is interpreted as a row or column type, and
<code>margin_from_types_byname()</code> is called internally to
resolve the integer margins of interest.
</p>
<p>Note that if row and/or column type are present,
the row and/or column type are also renamed according to <code>piece</code>.
This behavior is usually helpful.
For example,
if the prefix is requested (<code>piece = "pref"</code>) and
the row/coltype is a single word
that does not conform to the notation,
the entire row/coltype string is retained.
However, if the suffix is requested (<code>piece = "suff"</code>) and
the row/coltype is a single word
that does not conform to the notation,
an empty string (&quot;&quot;) is returned.
In those circumstances,
the caller is responsible for
setting the row/coltype if an empty string (&quot;&quot;)
is not desired.
See the examples for details.
</p>


<h3>Value</h3>

<p>A version of <code>a</code> with renamed rows and columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(c(1, 2, 
              3, 4, 
              5, 6), nrow = 3, byrow = TRUE, 
            dimnames = list(c("a -&gt; b", "r2", "r3"), c("a -&gt; b", "c -&gt; d")))
m
rename_to_piece_byname(m, piece = "pref", notation = RCLabels::arrow_notation)
m2 &lt;- m %&gt;%
  setrowtype("rows") %&gt;% setcoltype("cols")
m2
# In this example, 
# rowtype and coltype are unchanged, because the 
# whole string is considered to be the prefix.
rename_to_piece_byname(m2, piece = "pref", margin = "rows",
                       notation = RCLabels::arrow_notation)
# Here, the rowtype is set to the empty string ("")
# because there is no suffix for the type of the "rows" margin.
rename_to_piece_byname(m2, piece = "suff", margin = "rows",
                       notation = RCLabels::arrow_notation)
m3 &lt;- m2 |&gt; 
  setrowtype("Industry -&gt; Product")
m3
# Note that the rowtype becomes the prefix for the rowtype, 
# in this example "Industry".
rename_to_piece_byname(m3, piece = "pref", margin = 1,
                       notation = RCLabels::arrow_notation)
# And when a suffix is present, 
# the rowtype becomes the suffix, 
# in this example "Product".
rename_to_piece_byname(m3, piece = "suff", margin = 1,
                       notation = RCLabels::arrow_notation)
</code></pre>

<hr>
<h2 id='rename_to_pref_suff_byname'>Rename matrix rows and columns by prefix and suffix</h2><span id='topic+rename_to_pref_suff_byname'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
It can be convenient to rename rows or columns of matrices
based on retaining prefixes or suffixes.
This function provides that capability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rename_to_pref_suff_byname(a, keep, margin = c(1, 2), notation)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rename_to_pref_suff_byname_+3A_a">a</code></td>
<td>
<p>a matrix or list of matrices whose rows or columns will be renamed.</p>
</td></tr>
<tr><td><code id="rename_to_pref_suff_byname_+3A_keep">keep</code></td>
<td>
<p>one of &quot;prefix&quot; or &quot;suffix&quot; indicating which part of the row or column name to retain.</p>
</td></tr>
<tr><td><code id="rename_to_pref_suff_byname_+3A_margin">margin</code></td>
<td>
<p>one of <code>1</code>, <code>2</code>, or <code>c(1, 2)</code> where <code>1</code> indicates rows and <code>2</code> indicates columns.</p>
</td></tr>
<tr><td><code id="rename_to_pref_suff_byname_+3A_notation">notation</code></td>
<td>
<p>See <code>notation_vec()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A prefix is defined by an opening string (<code>prefix_open</code>) and a closing string (<code>prefix_close</code>).
A suffix is defined by an opening string (<code>suffix_open</code>) and a closing string (<code>suffix_close</code>).
If <code>sep</code> is provided and none of <code>prefix_open</code>, <code>prefix_close</code>, <code>suffix_open</code>, and <code>suffix_close</code> are provided,
default arguments become:
* <code>prefix_open</code>: &quot;&quot;,
* <code>prefix_close</code>: <code>sep</code>,
* <code>suffix_open</code>: <code>sep</code>, and
* <code>suffix_close</code>: &quot;&quot;.
</p>
<p>The <code>keep</code> parameter tells which portion to retain (prefixes or suffixes),
</p>
<p>If prefixes or suffixes are not found in a row and/or column name, that name is unchanged.
</p>


<h3>Value</h3>

<p><code>a</code> with potentially different row or column names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This function is superseded. 
# Instead, use `rename_to_pieces_byname()`.
# For example:
m &lt;- matrix(c(1, 2, 
              3, 4, 
              5, 6), nrow = 3, byrow = TRUE, 
            dimnames = list(c("a -&gt; b", "r2", "r3"), c("a -&gt; b", "c -&gt; d")))
m
rename_to_piece_byname(m, piece = "pref", notation = RCLabels::arrow_notation)
# Note, labels are lost, because some labels are missing a suffix.
rename_to_piece_byname(m, piece = "suff", notation = RCLabels::arrow_notation)
# Original documentation:
rename_to_pref_suff_byname(m, keep = "pref", notation = RCLabels::arrow_notation)
rename_to_pref_suff_byname(m, keep = "suff", notation = RCLabels::arrow_notation)
</code></pre>

<hr>
<h2 id='replaceNaN_byname'>Replace <code>NaN</code> values with a value</h2><span id='topic+replaceNaN_byname'></span>

<h3>Description</h3>

<p>In a matrix or within matrices in a list,
replace all <code>NaN</code> matrix values with <code>val.</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replaceNaN_byname(a, val = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replaceNaN_byname_+3A_a">a</code></td>
<td>
<p>A matrix of list of matrices in which <code>NaN</code> will be replaced by <code>val</code>.</p>
</td></tr>
<tr><td><code id="replaceNaN_byname_+3A_val">val</code></td>
<td>
<p><code>NaN</code>s are replace by <code>val.</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or list of matrices in which all <code>NaN</code> are replaced by <code>val</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>suppressWarnings(a &lt;- matrix(c(1, sqrt(-1))))
replaceNaN_byname(a)
replaceNaN_byname(a, 42)
</code></pre>

<hr>
<h2 id='rowprods_byname'>Row products, sorted by name</h2><span id='topic+rowprods_byname'></span>

<h3>Description</h3>

<p>Calculates row products (the product of all elements in a row) for a matrix.
An optional <code>colname</code> for the resulting column vector can be supplied.
If <code>colname</code> is <code>NULL</code> or <code>NA</code> (the default),
the column name is set to the column type as given by <code>coltype(a)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowprods_byname(a, colname = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowprods_byname_+3A_a">a</code></td>
<td>
<p>A matrix or list of matrices from which row products are desired.</p>
</td></tr>
<tr><td><code id="rowprods_byname_+3A_colname">colname</code></td>
<td>
<p>The Name of the output column containing row products.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A column vector of type <code>matrix</code> containing the row products of <code>a</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
M &lt;- matrix(c(1:6), ncol = 2, dimnames = list(paste0("i", 3:1), paste0("c", 1:2))) %&gt;%
  setrowtype("Industries") %&gt;% setcoltype("Products")
rowprods_byname(M)
rowprods_byname(M, "E.ktoe")
# This also works with lists
rowprods_byname(list(M, M))
rowprods_byname(list(M, M), "E.ktoe")
rowprods_byname(list(M, M), NA)
rowprods_byname(list(M, M), NULL)
DF &lt;- data.frame(M = I(list()))
DF[[1,"M"]] &lt;- M
DF[[2,"M"]] &lt;- M
rowprods_byname(DF$M[[1]])
rowprods_byname(DF$M)
ans &lt;- DF %&gt;% mutate(rs = rowprods_byname(M))
ans
ans$rs[[1]]
# Nonsensical
## Not run: rowprods_byname(NULL)
</code></pre>

<hr>
<h2 id='rowsums_byname'>Row sums, sorted by name</h2><span id='topic+rowsums_byname'></span>

<h3>Description</h3>

<p>Calculates row sums for a matrix by post-multiplying by an identity vector (containing all 1's).
In contrast to <code>rowSums</code> (which returns a <code>numeric</code> result),
the return value from <code>rowsums_byname</code> is a matrix.
An optional <code>colname</code> for the resulting column vector can be supplied.
If <code>colname</code> is <code>NULL</code> or <code>NA</code> (the default),
the column name is set to the column type as given by <code>coltype(a)</code>.
If <code>colname</code> is set to <code>NULL</code>, the column name is returned empty.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowsums_byname(a, colname = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowsums_byname_+3A_a">a</code></td>
<td>
<p>A matrix or list of matrices from which row sums are desired.</p>
</td></tr>
<tr><td><code id="rowsums_byname_+3A_colname">colname</code></td>
<td>
<p>The name of the output column containing row sums.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A column vector of type <code>matrix</code> containing the row sums of <code>m</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
rowsums_byname(42)
m &lt;- matrix(c(1:6), ncol = 2, dimnames = list(paste0("i", 3:1), paste0("c", 1:2))) %&gt;%
  setrowtype("Industries") %&gt;% setcoltype("Commodities")
m
rowsums_byname(m)
rowsums_byname(m, "E.ktoe")
# This also works with lists
rowsums_byname(list(m, m))
rowsums_byname(list(m, m), "E.ktoe")
rowsums_byname(list(m, m), NA)
rowsums_byname(list(m, m), NULL)
DF &lt;- data.frame(m = I(list()))
DF[[1,"m"]] &lt;- m
DF[[2,"m"]] &lt;- m
rowsums_byname(DF$m[[1]])
rowsums_byname(DF$m)
ans &lt;- DF %&gt;% mutate(rs = rowsums_byname(m))
ans
ans$rs[[1]]
# Nonsensical
## Not run: rowsums_byname(NULL)
</code></pre>

<hr>
<h2 id='rowtype'>Row type</h2><span id='topic+rowtype'></span>

<h3>Description</h3>

<p>Extracts row type of <code>a</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowtype(a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowtype_+3A_a">a</code></td>
<td>
<p>The object from which you want to extract row types.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The row type of <code>a</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
commoditynames &lt;- c("c1", "c2")
industrynames &lt;- c("i1", "i2")
U &lt;- matrix(1:4, ncol = 2, dimnames = list(commoditynames, industrynames)) %&gt;%
  setrowtype(rowtype = "Commodities") %&gt;% setcoltype("Industries")
rowtype(U)
# This also works for lists
rowtype(list(U,U))
</code></pre>

<hr>
<h2 id='samestructure_byname'>Test whether matrices or lists of matrices have same structure</h2><span id='topic+samestructure_byname'></span>

<h3>Description</h3>

<p>Matrices are said to have the same structure
if row and column types are identical
and
if row and column names are identical.
Values can be different.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>samestructure_byname(..., .summarise = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="samestructure_byname_+3A_...">...</code></td>
<td>
<p>Operands to be compared.</p>
</td></tr>
<tr><td><code id="samestructure_byname_+3A_.summarise">.summarise</code></td>
<td>
<p>Tells whether the operation should be accomplished
across lists (<code>FALSE</code>) or down lists (<code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if all operands have the same structure, <code>FALSE</code> otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>samestructure_byname(2, 2)
productnames &lt;- c("p1", "p2")
industrynames &lt;- c("i1", "i2")
U &lt;- matrix(1:4, ncol = 2, dimnames = list(productnames, industrynames)) %&gt;%
  setrowtype("Products") %&gt;% setcoltype("Industries")
samestructure_byname(U, U)
samestructure_byname(U, U %&gt;% setrowtype("row"))
samestructure_byname(U %&gt;% setcoltype("col"), U)
# Also works with lists
samestructure_byname(list(U, U), list(U, U))
</code></pre>

<hr>
<h2 id='select_cols_byname'>Select columns of a matrix (or list of matrices) by name</h2><span id='topic+select_cols_byname'></span>

<h3>Description</h3>

<p>Arguments indicate which columns are to be retained and which are to be removed.
For maximum flexibility, arguments are extended regex patterns
that are matched against column names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_cols_byname(
  a,
  retain_pattern = "$^",
  remove_pattern = "$^",
  ignore.case = FALSE,
  perl = FALSE,
  fixed = FALSE,
  useBytes = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_cols_byname_+3A_a">a</code></td>
<td>
<p>a matrix or a list of matrices</p>
</td></tr>
<tr><td><code id="select_cols_byname_+3A_retain_pattern">retain_pattern</code></td>
<td>
<p>an extended regex or list of extended regular expressions that specifies which columns of <code>m</code> to retain.
Default pattern (&quot;$^&quot;) retains nothing.</p>
</td></tr>
<tr><td><code id="select_cols_byname_+3A_remove_pattern">remove_pattern</code></td>
<td>
<p>an extended regex or list of extended regular expressions that specifies which columns of <code>m</code> to remove.
Default pattern (&quot;$^&quot;) removes nothing.</p>
</td></tr>
<tr><td><code id="select_cols_byname_+3A_ignore.case">ignore.case</code>, <code id="select_cols_byname_+3A_perl">perl</code>, <code id="select_cols_byname_+3A_fixed">fixed</code>, <code id="select_cols_byname_+3A_usebytes">useBytes</code></td>
<td>
<p>Arguments passed to <code>grep()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>a</code> is <code>NULL</code>, <code>NULL</code> is returned.
</p>
<p>Patterns are compared against column names using extended regex.
If no column names of <code>a</code> match the <code>retain_pattern</code>, <code>NULL</code> is returned.
If no column names of <code>a</code> match the <code>remove_pattern</code>, <code>a</code> is returned.
</p>
<p>Retaining columns takes precedence over removing columns, always.
</p>
<p>Some typical patterns are:
</p>

<ul>
<li><p>&quot;^Electricity$|^Oil$&quot;: column names that are EXACTLY &quot;Electricity&quot; or &quot;Oil&quot;.
</p>
</li>
<li><p>&quot;^Electricity|^Oil&quot;: column names that START WITH &quot;Electricity&quot; or &quot;Oil&quot;.
</p>
</li>
<li><p>&quot;Electricity|Oil&quot;: column names that CONTAIN &quot;Electricity&quot; or &quot;Oil&quot; anywhere within them.
</p>
</li></ul>

<p>Given a list of column names, a pattern can be constructed easily using the <code>make_pattern</code> function.
</p>
<p><code>RCLabels::make_or_pattern()</code> escapes regex strings using <code>Hmisc::escaprRegex()</code>.
This function assumes that <code>retain_pattern</code> and <code>remove_pattern</code> have already been
suitably escaped.
</p>
<p>Note that the default <code>retain_pattern</code> and <code>remove_pattern</code> (&quot;$^&quot;)
retain nothing and remove nothing.
</p>
<p>If the row or column labels contain &quot;[&quot; or &quot;]&quot;,
care should be taken to escape those characters.
<code>Hmisc::escapeRegex()</code> is helpful in such situations.
</p>
<p>Note that if all columns are removed from <code>a</code>, <code>NULL</code> is returned.
</p>


<h3>Value</h3>

<p>a matrix that is a subset of <code>a</code> with columns selected by <code>retain_pattern</code> and <code>remove_pattern</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(1:16, ncol = 4, dimnames=list(c(paste0("i", 1:4)), paste0("p", 1:4))) %&gt;%
  setrowtype("Industries") %&gt;% setcoltype("Commodities")
select_cols_byname(m, 
                   retain_pattern = RCLabels::make_or_pattern(c("p1", "p4"), 
                   pattern_type = "exact"))
select_cols_byname(m, 
                   remove_pattern = RCLabels::make_or_pattern(c("p1", "p3"), 
                   pattern_type = "exact"))
# Also works for lists and data frames
select_cols_byname(list(m,m), retain_pattern = "^p1$|^p4$")
</code></pre>

<hr>
<h2 id='select_rowcol_piece_byname'>Select or remove rows or columns based on pieces of the names.</h2><span id='topic+select_rowcol_piece_byname'></span>

<h3>Description</h3>

<p><code>select_rows_byname()</code> and <code>select_cols_byname()</code>
select rows and columns using regex patterns
This function performs similar actions
based on the pieces of row and column labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_rowcol_piece_byname(
  a,
  retain = NULL,
  remove = NULL,
  piece = "all",
  pattern_type = "exact",
  prepositions = RCLabels::prepositions_list,
  notation = RCLabels::notations_list,
  margin = c(1, 2)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_rowcol_piece_byname_+3A_a">a</code></td>
<td>
<p>A matrix or list of matrices whose rows or columns are to be selected.</p>
</td></tr>
<tr><td><code id="select_rowcol_piece_byname_+3A_retain">retain</code></td>
<td>
<p>The row or column names to be retained.
Default is <code>NULL</code>, meaning that removal is requested.</p>
</td></tr>
<tr><td><code id="select_rowcol_piece_byname_+3A_remove">remove</code></td>
<td>
<p>The row or column names to be removed.
Default is <code>NULL</code>, meaning that retaining is requested.</p>
</td></tr>
<tr><td><code id="select_rowcol_piece_byname_+3A_piece">piece</code></td>
<td>
<p>The piece of row or column names to be assessed.
Default is &quot;all&quot;, indicating that the entire label will be assessed.</p>
</td></tr>
<tr><td><code id="select_rowcol_piece_byname_+3A_pattern_type">pattern_type</code></td>
<td>
<p>The way to match label pieces.
<code>pattern_type</code> is passed to <code>RCLabels::make_or_pattern()</code>.
See <code>RCLabels::make_or_pattern()</code> for details.
Default is &quot;exact&quot;, meaning that exact matches are retained or removed.
Other options are &quot;leading&quot;, &quot;trailing&quot;, &quot;anywhere&quot;, and &quot;literal&quot;.</p>
</td></tr>
<tr><td><code id="select_rowcol_piece_byname_+3A_prepositions">prepositions</code></td>
<td>
<p>The prepositions that can be used for identifying pieces.
Default is <code>RCLabels::prepositions_list</code>.</p>
</td></tr>
<tr><td><code id="select_rowcol_piece_byname_+3A_notation">notation</code></td>
<td>
<p>The notation for the row and column names.
Default is <code>RCLabels::notations_list</code>, meaning that all notations known to
<code>RCLabels</code> will be assessed.</p>
</td></tr>
<tr><td><code id="select_rowcol_piece_byname_+3A_margin">margin</code></td>
<td>
<p>The margin to which row or column removal is requested.
<code>1</code> indicates rows; <code>2</code> indicates columns.
Default is <code>c(1, 2)</code>, meaning that action should be taken on both rows and columns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the <code>RCLabels</code> package to match
row and column names by pieces.
</p>
<p>To retain rows or columns, specify <code>retain</code>.
To remove rows or columns, specify <code>remove</code>.
</p>
<p>If <code>a</code> has row and column types, a string may be passed to <code>margin</code>,
in which case the margin will be resolved.
See examples.
</p>
<p><code>notation</code> may be a list of notations that could apply in <code>a</code>.
This function will try to infer the notation that applies
to row and column names.
</p>
<p>Retaining takes precedence over removing, always.
</p>
<p>Options for <code>piece</code> are
</p>

<ul>
<li><p> &quot;all&quot; (the default), meaning that the entire label will be matched,
</p>
</li>
<li><p> &quot;pref&quot;, meaning that the prefix will be matched,
</p>
</li>
<li><p> &quot;suff&quot;, meaning that the suffix will be matched,
</p>
</li>
<li><p> &quot;noun&quot;, meaning that the first part will be matched, and
</p>
</li>
<li><p> &quot;from&quot; (or another preposition), meaning that the object of that preposition will be matched.
</p>
</li></ul>

<p>If retaining or removing rows or columns results in no rows or columns remaining
in the matrix, <code>NULL</code> is returned.
</p>


<h3>Value</h3>

<p><code>a</code> with rows and/or column retained or removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(1:4, nrow = 2, ncol = 2, byrow = TRUE, 
              dimnames = list(c("r1 [to a]", "r2 [to b]"), 
                              c("c1 [from c]", "c2 [from d]"))) %&gt;% 
  setrowtype("rows") %&gt;% setcoltype("cols")
m
select_rowcol_piece_byname(m, retain = "r1", piece = "noun", 
                           notation = RCLabels::to_notation, 
                           margin = 1)
select_rowcol_piece_byname(m, retain = "b", piece = "to", 
                           notation = RCLabels::bracket_notation, 
                           margin = 1)
select_rowcol_piece_byname(m, retain = "c1", piece = "noun",
                           notation = RCLabels::bracket_notation, 
                           margin = 2)
select_rowcol_piece_byname(m, retain = "d", piece = "from", 
                           notation = RCLabels::bracket_notation, 
                           margin = 2)
select_rowcol_piece_byname(m, retain = "c", piece = "from", 
                           notation = RCLabels::bracket_notation, 
                           margin = 2)
select_rowcol_piece_byname(m, retain = "b", piece = "to", 
                           notation = RCLabels::bracket_notation, 
                           margin = "rows")
select_rowcol_piece_byname(m, retain = "c", piece = "from", 
                           notation = RCLabels::bracket_notation, 
                           margin = "cols")
</code></pre>

<hr>
<h2 id='select_rows_byname'>Select (or de-select) rows of a matrix (or list of matrices) by name</h2><span id='topic+select_rows_byname'></span>

<h3>Description</h3>

<p>Arguments indicate which rows are to be retained and which are to be removed.
For maximum flexibility, arguments are extended regex patterns
that are matched against row names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_rows_byname(
  a,
  retain_pattern = "$^",
  remove_pattern = "$^",
  ignore.case = FALSE,
  perl = FALSE,
  fixed = FALSE,
  useBytes = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_rows_byname_+3A_a">a</code></td>
<td>
<p>A matrix or a list of matrices.</p>
</td></tr>
<tr><td><code id="select_rows_byname_+3A_retain_pattern">retain_pattern</code></td>
<td>
<p>An extended regex or list of extended regular expressions that specifies which rows of <code>a</code> to retain.
Default pattern (&quot;$^&quot;) retains nothing.</p>
</td></tr>
<tr><td><code id="select_rows_byname_+3A_remove_pattern">remove_pattern</code></td>
<td>
<p>An extended regex or list of extended regular expressions that specifies which rows of <code>a</code> to remove,
Default pattern (&quot;$^&quot;) removes nothing.</p>
</td></tr>
<tr><td><code id="select_rows_byname_+3A_ignore.case">ignore.case</code>, <code id="select_rows_byname_+3A_perl">perl</code>, <code id="select_rows_byname_+3A_fixed">fixed</code>, <code id="select_rows_byname_+3A_usebytes">useBytes</code></td>
<td>
<p>Arguments passed to <code>grep()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>a</code> is <code>NULL</code>, <code>NULL</code> is returned.
</p>
<p>Patterns are compared against row names using extended regex.
If no row names of <code>a</code> match the <code>retain_pattern</code>, <code>NULL</code> is returned.
If no row names of <code>a</code> match the <code>remove_pattern</code>, <code>m</code> is returned.
Note that the default <code>retain_pattern</code> and <code>remove_pattern</code> (&quot;$^&quot;)
retain nothing and remove nothing.
</p>
<p>Retaining rows takes precedence over removing rows, always.
</p>
<p>Some typical patterns are:
</p>

<ul>
<li><p>&quot;^Electricity$|^Oil$&quot;: row names that are EXACTLY &quot;Electricity&quot; or EXACTLY &quot;Oil&quot;.
</p>
</li>
<li><p>&quot;^Electricity|^Oil&quot;: row names that START WITH &quot;Electricity&quot; or START WITH &quot;Oil&quot;.
</p>
</li>
<li><p>&quot;Electricity|Oil&quot;: row names that CONTAIN &quot;Electricity&quot; or CONTAIN &quot;Oil&quot; anywhere within them.
</p>
</li></ul>

<p>Given a list of row names, a pattern can be constructed easily using <code>RCLabels::make_or_pattern()</code>.
<code>RCLabels::make_or_pattern()</code> escapes regex strings using <code>Hmisc::escapeRegex()</code>.
This function assumes that <code>retain_pattern</code> and <code>remove_pattern</code> have already been
suitably escaped.
</p>
<p>If the row or column labels contain &quot;[&quot; or &quot;]&quot;,
care should be taken to escape those characters.
<code>Hmisc::escapeRegex()</code> is helpful in such situations.
</p>
<p>Note that if all rows are removed from <code>a</code>, <code>NULL</code> is returned.
</p>


<h3>Value</h3>

<p>A matrix that is a subset of <code>m</code> with rows selected by <code>retain_pattern</code> and <code>remove_pattern</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(1:16, ncol = 4, dimnames = list(c(paste0("i", 1:4)), paste0("p", 1:4))) %&gt;%
  setrowtype("Industries") %&gt;% setcoltype("Commodities")
select_rows_byname(m, 
                   retain_pattern = RCLabels::make_or_pattern(c("i1", "i4"),
                   pattern_type = "exact"))
select_rows_byname(m, 
                   remove_pattern = RCLabels::make_or_pattern(c("i1", "i3"), 
                   pattern_type = "exact"))
# Also works for lists and data frames
select_rows_byname(list(m, m), retain_pattern = "^i1$|^i4$")
</code></pre>

<hr>
<h2 id='selectzerocols_byname'>Select zero columns</h2><span id='topic+selectzerocols_byname'></span>

<h3>Description</h3>

<p>Matrices with columns containing all zeroes are not invertible (singular).
To diagnose this problem, it is useful to find the zero columns
of a singular matrix.
This function selects (extracts) only the zero columns of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectzerocols_byname(a, tol = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectzerocols_byname_+3A_a">a</code></td>
<td>
<p>A matrix or a list of matrices.</p>
</td></tr>
<tr><td><code id="selectzerocols_byname_+3A_tol">tol</code></td>
<td>
<p>The allowable deviation from 0 for any element.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A column is said to be a zero column if all elements are within <code>tol</code> of zero.
</p>


<h3>Value</h3>

<p><code>a</code> with only zero columns selected.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(c(1, 0, 1,
              1, 0, 1),
            dimnames = list(c("r1", "r2"), c("c1", "c2", "c3")), 
            nrow = 2, ncol = 3, byrow = TRUE) %&gt;% 
  setrowtype("rows") %&gt;% setcoltype("cols")
selectzerocols_byname(m)
</code></pre>

<hr>
<h2 id='selectzerorows_byname'>Select zero rows</h2><span id='topic+selectzerorows_byname'></span>

<h3>Description</h3>

<p>Matrices with rows containing all zeroes are not invertible (singular).
To diagnose this problem, it is useful to find the zero rows
of a singular matrix.
This function selects (extracts) only the zero rows of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectzerorows_byname(a, tol = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectzerorows_byname_+3A_a">a</code></td>
<td>
<p>A matrix or a list of matrices.</p>
</td></tr>
<tr><td><code id="selectzerorows_byname_+3A_tol">tol</code></td>
<td>
<p>The allowable deviation from 0 for any element.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A row is said to be a zero row if all elements are within <code>tol</code> of zero.
</p>


<h3>Value</h3>

<p><code>a</code> with only zero rows selected.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(c(0, 0, 1,
              0, 0, 0), 
            dimnames = list(c("r1", "r2"), c("c1", "c2", "c3")), 
            nrow = 2, ncol = 3, byrow = TRUE) %&gt;% 
  setrowtype("rows") %&gt;% setcoltype("cols")
m
selectzerorows_byname(m)
</code></pre>

<hr>
<h2 id='setcolnames_byname'>Sets column names</h2><span id='topic+setcolnames_byname'></span>

<h3>Description</h3>

<p>Sets column names in a way that is amenable to use in piping operations in a functional programming way.
if <code>a</code> is <code>NULL</code>, <code>NULL</code> is returned.
If <code>a</code> is a constant, it is converted to a matrix and <code>colnames</code> are applied.
If <code>a</code> is a matrix, <code>colnames</code> should be a vector of new column names
that is as long as the number of columns in <code>a</code>.
If <code>a</code> is a list of matrices,
<code>colnames</code> can also be a list, and it should be as long as <code>a</code>.
Or <code>colnames</code> can be a vector of column names which will be applied to every matrix in
the list of <code>a</code>.
Each item in the list should be a vector containing column names for the corresponding
matrix in <code>a</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setcolnames_byname(a, colnames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setcolnames_byname_+3A_a">a</code></td>
<td>
<p>A matrix or a list of matrices in which column names are to be set</p>
</td></tr>
<tr><td><code id="setcolnames_byname_+3A_colnames">colnames</code></td>
<td>
<p>A vector of new column names or a list of vectors of new column names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a copy of <code>a</code> with new column names
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(c(1:6), nrow = 2, dimnames = list(paste0("i", 1:2), paste0("c", 1:3))) %&gt;%
  setrowtype("Industries") %&gt;% setcoltype("Commodities")
setcolnames_byname(m, c("a", "b", "c"))
</code></pre>

<hr>
<h2 id='setcoltype'>Sets column type for a matrix or a list of matrices</h2><span id='topic+setcoltype'></span>

<h3>Description</h3>

<p>This function is a wrapper for <code>attr()</code> so that
setting can be accomplished by the pipe operator (<code style="white-space: pre;">&#8288;%&gt;%&#8288;</code>).
Column types are strings stored in the <code>coltype</code> attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setcoltype(a, coltype)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setcoltype_+3A_a">a</code></td>
<td>
<p>The matrix on which column type is to be set.</p>
</td></tr>
<tr><td><code id="setcoltype_+3A_coltype">coltype</code></td>
<td>
<p>The type of item stored in columns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>is.null(coltype)</code>, the coltype attribute is deleted
and subsequent calls to <code>coltype</code> will return <code>NULL</code>.
</p>


<h3>Value</h3>

<p><code>a</code> with <code>coltype</code> attribute set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
commoditynames &lt;- c("c1", "c2")
industrynames &lt;- c("i1", "i2")
U &lt;- matrix(1:4, ncol = 2, dimnames = list(commoditynames, industrynames))
U %&gt;% setcoltype("Industries")
# This also works for lists
setcoltype(list(U,U), coltype = "Industries")
setcoltype(list(U,U), coltype = list("Industries", "Industries"))
DF &lt;- data.frame(U = I(list()))
DF[[1,"U"]] &lt;- U
DF[[2,"U"]] &lt;- U
setcoltype(DF$U, "Industries")
DF &lt;- DF %&gt;% mutate(newcol = setcoltype(U, "Industries"))
DF$newcol[[1]]
DF$newcol[[2]]
</code></pre>

<hr>
<h2 id='setrownames_byname'>Sets row names</h2><span id='topic+setrownames_byname'></span>

<h3>Description</h3>

<p>Sets row names in a way that is amenable to use in piping operations in a functional programming way.
If <code>a</code> is <code>NULL</code>, <code>NULL</code> is returned.
If <code>a</code> is a constant, it is converted to a matrix and <code>rownames</code> are applied.
If <code>a</code> is a matrix, <code>rownames</code> should be a vector of new row names
that is as long as the number of rows in <code>a</code>.
If <code>a</code> is a list of matrices,
<code>rownames</code> can also be a list, and it should be as long <code>a</code>.
Or <code>rownames</code> can be a vector of row names which will be applied to every matrix in
the list of <code>a</code>.
Each item in the list should be a vector containing row names for the corresponding
matrix in <code>a</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setrownames_byname(a, rownames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setrownames_byname_+3A_a">a</code></td>
<td>
<p>A matrix or a list of matrices in which row names are to be set</p>
</td></tr>
<tr><td><code id="setrownames_byname_+3A_rownames">rownames</code></td>
<td>
<p>A vector of new row names or a list of vectors of new row names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a copy of <code>m</code> with new row names
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
m &lt;- matrix(c(1:6), nrow = 2, dimnames = list(paste0("i", 1:2), paste0("c", 1:3))) %&gt;%
  setrowtype("Industries") %&gt;% setcoltype("Commodities")
setrownames_byname(m, c("a", "b"))
setrownames_byname(m %&gt;% setrowtype("Industries") %&gt;% setcoltype("Commodities"), c("c", "d"))
m %&gt;% setrownames_byname(NULL)
m %&gt;% setrownames_byname(c(NA, NA))
2 %&gt;% setrownames_byname("row")
# This also works for lists
setrownames_byname(list(m,m), list(c("a", "b")))
DF &lt;- data.frame(m = I(list()))
DF[[1,"m"]] &lt;- m
DF[[2,"m"]] &lt;- m
setrownames_byname(DF$m, list(c("r1", "r2")))
setrownames_byname(DF$m, list(c("c", "d")))
DF &lt;- DF %&gt;% mutate(m = setrownames_byname(m, list(c("r1", "r2"))))
DF$m[[1]]
</code></pre>

<hr>
<h2 id='setrowtype'>Sets row type for a matrix or a list of matrices</h2><span id='topic+setrowtype'></span>

<h3>Description</h3>

<p>This function is a wrapper for <code>attr()</code> so that
setting can be accomplished by the pipe operator (<code style="white-space: pre;">&#8288;%&gt;%&#8288;</code>).
Row types are strings stored in the <code>rowtype</code> attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setrowtype(a, rowtype)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setrowtype_+3A_a">a</code></td>
<td>
<p>The matrix on which row type is to be set.</p>
</td></tr>
<tr><td><code id="setrowtype_+3A_rowtype">rowtype</code></td>
<td>
<p>The type of item stored in rows.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>is.null(rowtype)</code>, the rowtype attribute is deleted
and subsequent calls to <code>rowtype</code> will return <code>NULL</code>.
</p>


<h3>Value</h3>

<p><code>a</code> with rowtype attribute set to <code>rowtype.</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
commoditynames &lt;- c("c1", "c2")
industrynames &lt;- c("i1", "i2")
U &lt;- matrix(1:4, ncol = 2, dimnames = list(commoditynames, industrynames))
U %&gt;% setrowtype("Commodities")
# This also works for lists
setrowtype(list(U,U), rowtype = "Commodities")
setrowtype(list(U,U), rowtype = list("Commodities", "Commodities"))
DF &lt;- data.frame(U = I(list()))
DF[[1,"U"]] &lt;- U
DF[[2,"U"]] &lt;- U
setrowtype(DF$U, "Commodities")
DF &lt;- DF %&gt;% mutate(newcol = setrowtype(U, "Commodities"))
DF$newcol[[1]]
DF$newcol[[2]]
</code></pre>

<hr>
<h2 id='sort_rows_cols'>Sorts rows and columns of a matrix</h2><span id='topic+sort_rows_cols'></span>

<h3>Description</h3>

<p>Checks that row names are unique and that column names are unique.
Then, sorts the rows and columns in a way that ensures
any other matrix with the same row and column names will have
the same order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sort_rows_cols(a, margin = c(1, 2), roworder = NA, colorder = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort_rows_cols_+3A_a">a</code></td>
<td>
<p>A matrix or data frame whose rows and columns are to be sorted.</p>
</td></tr>
<tr><td><code id="sort_rows_cols_+3A_margin">margin</code></td>
<td>
<p>Specifies the subscript(s) in <code>a</code> over which sorting will occur.
<code>margin</code> has nearly the same semantic meaning as in <code>base::apply</code>.
For rows only, give <code>1</code>;
for columns only, give <code>2</code>;
for both rows and columns, give <code>c(1,2)</code>, the default value.</p>
</td></tr>
<tr><td><code id="sort_rows_cols_+3A_roworder">roworder</code></td>
<td>
<p>Specifies the order for rows with default <code>sort(rownames(a))</code>.
If <code>NA</code> (the default), default sort order is used.
Unspecified rows are removed from the output, thus providing a way to delete rows from <code>a</code>.
Extraneous row names (row names in <code>roworder</code> that do not appear in <code>a</code>) are ignored.</p>
</td></tr>
<tr><td><code id="sort_rows_cols_+3A_colorder">colorder</code></td>
<td>
<p>Specifies the order for rows with default <code>sort(colnames(a))</code>.
If <code>NA</code> (the default), default sort order is used.
Unspecified columns are removed from the output, thus providing a way to delete columns from <code>a</code>.
Extraneous column names (column names in <code>colorder</code> that do not appear in <code>a</code>) are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Default sort order is given by <code>base::sort()</code> with <code>decreasing = FALSE</code>.
</p>


<h3>Value</h3>

<p>A modified version of <code>a</code> with sorted rows and columns
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(c(1:6), nrow=3, dimnames = list(c("r3", "r5", "r1"), c("c4", "c2")))
sort_rows_cols(m)
sort_rows_cols(t(m))
sort_rows_cols(m, margin=1) # Sorts rows
sort_rows_cols(m, margin=2) # Sorts columns
v &lt;- matrix(c(1:5), ncol=1, dimnames=list(rev(paste0("r", 1:5)), "c1")) # Column vector
sort_rows_cols(v)
sort_rows_cols(v, margin = 1) # Sorts rows
sort_rows_cols(v, margin = 2) # No effect: only one column
r &lt;- matrix(c(1:4), nrow=1, dimnames=list("r1", rev(paste0("c", 1:4)))) # Row vector
sort_rows_cols(r) # Sorts columns
n &lt;- matrix(c(1,2), nrow = 1, dimnames = list(NULL, c("c2", "c1"))) # No row name
sort_rows_cols(n) # Sorts columns, because only one row.
# Also works with lists
sort_rows_cols(list(m,m)) # Sorts rows and columns for both m's.
# Sort rows only for first one, sort rows and columns for second one.  
# Row order is applied to all m's.  Column order is natural.
sort_rows_cols(a = list(m,m), margin = 1, roworder = list(c("r5", "r3", "r1")))
# Columns are sorted as default, because no colorder is given.
# roworder is ignored. 
sort_rows_cols(a = list(m,m), margin = 2, roworder = list(c("r5", "r3", "r1")))
# Both columns and rows sorted, rows by the list, columns in natural order.
sort_rows_cols(a = list(m,m), margin = c(1,2), roworder = list(c("r5", "r3", "r1")))
</code></pre>

<hr>
<h2 id='sum_byname'>Name-wise addition of matrices</h2><span id='topic+sum_byname'></span>

<h3>Description</h3>

<p>Performs a union and sorting of addend and augend row and column names prior to summation.
Zeroes are inserted for missing matrix elements.
Treats missing or <code>NULL</code> operands as <code>0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum_byname(..., .summarise = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sum_byname_+3A_...">...</code></td>
<td>
<p>Operands: constants, matrices, or lists of matrices.</p>
</td></tr>
<tr><td><code id="sum_byname_+3A_.summarise">.summarise</code></td>
<td>
<p>When <code>TRUE</code>, a operands are summed down lists.
When <code>FALSE</code> (the default), items are summed across lists.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For this function, a list of lists of operands is ambiguous.
Should the operands be summed across lists
(first items summed across all lists, second items summed across all list, etc.)
or should each list be summed along each list?
In the first case, the return object will have length equal to the length of the lists in the <code>...</code> argument.
In the second case, the return object will have length equal to the number of lists in the <code>...</code> argument.
The first case is like summing across rows of a data frame.
The second case is like summing down columns of a data frame.
The <code>summarise</code> argument distinguishes between these two cases.
The default value for <code>summarise</code> is <code>FALSE</code>, giving the first behavior.
Set <code>summarise</code> to <code>TRUE</code> to cause this function to act like <code>dplyr::summarise()</code>
for its list of arguments.
If <code>.summarise = TRUE</code>, the
data value is guaranteed to be a list.
If the call to <code>sum_byname(.summarise = TRUE)</code> is made in the context of a data frame,
the column returned is guaranteed to be a list column.
See the aggregation vignette for additional details and examples.
</p>


<h3>Value</h3>

<p>A matrix representing the name-wise sum of arguments.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
sum_byname(2, 2)
sum_byname(2, 2, 2)
sum_byname(2, 2, -2, -2)
productnames &lt;- c("p1", "p2")
industrynames &lt;- c("i1", "i2")
U &lt;- matrix(1:4, ncol = 2, dimnames = list(productnames, industrynames)) %&gt;%
  setrowtype("Products") %&gt;% setcoltype("Industries")
Y &lt;- matrix(1:4, ncol = 2, dimnames = list(rev(productnames), rev(industrynames))) %&gt;%
  setrowtype("Products") %&gt;% setcoltype("Industries")
sum_byname(U, 100)
sum_byname(200, Y)
U + Y # Non-sensical.  Row and column names not respected.
sum_byname(U, U)
sum_byname(U, Y)
sum_byname(U, U, Y, Y)
V &lt;- matrix(1:4, ncol = 2, dimnames = list(industrynames, productnames)) %&gt;%
  setrowtype("Industries") %&gt;% setcoltype("Products")
U + V # row and column names are non-sensical and blindly taken from first argument (U)
## Not run: sum_byname(U, V) # Fails, because row and column types are different
# This also works with lists
sum_byname(list(U,U), list(Y,Y))
sum_byname(list(U,U), list(100,100))
sum_byname(list(U,U), as.list(rep_len(100, 2)))
DF &lt;- data.frame(U = I(list()), Y = I(list()))
DF[[1,"U"]] &lt;- U
DF[[2,"U"]] &lt;- U
DF[[1,"Y"]] &lt;- Y
DF[[2,"Y"]] &lt;- Y
sum_byname(DF$U, DF$Y)
DF %&gt;% mutate(sums = sum_byname(U, Y))
sum_byname(U) # If only one argument, return it.
sum_byname(2, NULL) # Gives 2
sum_byname(2, NA)   # Gives NA
sum_byname(NULL, 1) # Gives 1
sum_byname(list(NULL, 1), list(1, 1))
DF2 &lt;- data.frame(U = I(list()), Y = I(list()))
DF2[[1,"U"]] &lt;- NULL
DF2[[2,"U"]] &lt;- U
DF2[[1,"Y"]] &lt;- Y
DF2[[2,"Y"]] &lt;- Y
sum_byname(DF2$U, DF2$Y)
DF3 &lt;- DF2 %&gt;% mutate(sums = sum_byname(U, Y))
DF3
DF3$sums[[1]]
DF3$sums[[2]]
</code></pre>

<hr>
<h2 id='sumall_byname'>Sum of all elements in a matrix</h2><span id='topic+sumall_byname'></span>

<h3>Description</h3>

<p>This function is equivalent to <code style="white-space: pre;">&#8288;a \%&gt;\% rowsums_byname() \%&gt;\% colsums_byname()&#8288;</code>,
but returns a single numeric value instead of a 1x1 matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sumall_byname(a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sumall_byname_+3A_a">a</code></td>
<td>
<p>The matrix whose elements are to be summed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The sum of all elements in <code>a</code> as a numeric.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
sumall_byname(42)
m &lt;- matrix(2, nrow=2, ncol=2, dimnames = list(paste0("i", 1:2), paste0("c", 1:2))) %&gt;%
  setrowtype("Industry") %&gt;% setcoltype("Commodity")
m
sumall_byname(m)
rowsums_byname(m) %&gt;% colsums_byname
# Also works for lists
sumall_byname(list(m,m))
DF &lt;- data.frame(m = I(list()))
DF[[1,"m"]] &lt;- m
DF[[2,"m"]] &lt;- m
sumall_byname(DF$m[[1]])
sumall_byname(DF$m)
res &lt;- DF %&gt;% mutate(
  sums = sumall_byname(m)
)
res$sums
sumall_byname(list(m, NULL))
</code></pre>

<hr>
<h2 id='svd_byname'>Calculate the singular value decomposition of a matrix</h2><span id='topic+svd_byname'></span>

<h3>Description</h3>

<p>The singular value decomposition decomposes matrix <strong>A</strong> into
<strong>A</strong> = <strong>U</strong> <strong>D</strong> <strong>V</strong>^T,
where <strong>U</strong> and <strong>V</strong> are orthogonal matrices and <strong>D</strong> is a diagonal matrix.
<strong>U</strong> is the left singular vectors of <strong>A</strong>.
<strong>V</strong> is the right singular vectors of <strong>A</strong>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svd_byname(a, which = c("d", "u", "v"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svd_byname_+3A_a">a</code></td>
<td>
<p>A matrix to be decomposed.</p>
</td></tr>
<tr><td><code id="svd_byname_+3A_which">which</code></td>
<td>
<p>The matrix to be returned. Default is &quot;d&quot;. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>which</code> determines the part of the singular value decomposition to be returned.
&quot;d&quot; (default) gives the <strong>D</strong> matrix.
&quot;u&quot; gives the <strong>U</strong> matrix.
&quot;v&quot; gives the <strong>V</strong> matrix (not its transpose).
</p>


<h3>Value</h3>

<p>A matrix of the singular value decomposition of <code>a</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A = matrix(c(4, 0, 
             3, -5), nrow = 2, ncol = 2, byrow = TRUE, 
           dimnames = list(c("r1", "r2"), c("c1", "c2"))) %&gt;% 
  setrowtype("Product") %&gt;% setcoltype("Industry")
A
svd_byname(A) # Gives D matrix, by default
svd_byname(A, which = "d")
svd_byname(A, which = "u")
svd_byname(A, which = "v")
</code></pre>

<hr>
<h2 id='switch_notation_byname'>Change row and column name notation</h2><span id='topic+switch_notation_byname'></span>

<h3>Description</h3>

<p>This function switches matrix row and/or column names from one type of notation to another
based on the <code>from</code> and <code>to</code> arguments.
Optionally, prefix and suffix can be <code>flip</code>ped.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>switch_notation_byname(a, margin = c(1, 2), from, to, flip = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="switch_notation_byname_+3A_a">a</code></td>
<td>
<p>A matrix or list of matrices whose row and/or column notation is to be changed.</p>
</td></tr>
<tr><td><code id="switch_notation_byname_+3A_margin">margin</code></td>
<td>
<p><code>1</code> For rows, <code>2</code> for columns, or <code>c(1, 2)</code> for both rows and columns. Default is <code>c(1, 2)</code>.</p>
</td></tr>
<tr><td><code id="switch_notation_byname_+3A_from">from</code></td>
<td>
<p>The <code>notation</code> to switch <em>away from</em>.</p>
</td></tr>
<tr><td><code id="switch_notation_byname_+3A_to">to</code></td>
<td>
<p>The <code>notation</code> to switch <em>to</em>.</p>
</td></tr>
<tr><td><code id="switch_notation_byname_+3A_flip">flip</code></td>
<td>
<p>A boolean that tells whether to also flip the notation. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrices with row and column names with switched notation, per arguments.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(c(1, 2, 
              3, 4), nrow = 2, ncol = 2, byrow = TRUE, 
            dimnames = list(c("b [a]", "d [c]"), c("f [e]", "h [g]"))) %&gt;% 
  setrowtype("Products [Industries]") %&gt;% setcoltype("Industries [Products]")
m
switch_notation_byname(m, from = RCLabels::bracket_notation, to = RCLabels::arrow_notation, 
                       flip = TRUE)
# Also works for lists.
# Note that margin must be specified as a list here.
switch_notation_byname(list(m, m), margin = list(c(1, 2)), 
                       from = RCLabels::bracket_notation, 
                       to = RCLabels::arrow_notation, flip = TRUE)
</code></pre>

<hr>
<h2 id='transpose_byname'>Transpose a matrix by name</h2><span id='topic+transpose_byname'></span>

<h3>Description</h3>

<p>Gives the transpose of a matrix or list of matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transpose_byname(a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transpose_byname_+3A_a">a</code></td>
<td>
<p>The matrix to be transposed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The transposed matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(c(11,21,31,12,22,32), ncol = 2, dimnames = list(paste0("i", 1:3), paste0("c", 1:2))) %&gt;%
  setrowtype("Industry") %&gt;% setcoltype("Commodity")
m
transpose_byname(m)
transpose_byname(list(m,m))
</code></pre>

<hr>
<h2 id='trim_rows_cols'>Trim rows and/or columns from a matrix</h2><span id='topic+trim_rows_cols'></span>

<h3>Description</h3>

<p>By default, the <code>matsbyname</code> package expands matrices
with <code>0</code> rows or columns prior to matrix operations
to ensure that rows and columns match.
There are times when trimming rows or columns is preferred
over the default behavior.
This function trims rows or columns in <code>a</code> to match
the rows or columns of <code>mat</code>.
The return value will have rows or columns of <code>a</code> removed if they do not appear in <code>mat</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trim_rows_cols(
  a = NULL,
  mat = NULL,
  margin = c(1, 2),
  warn_if_a_incomplete = TRUE,
  a_piece = "all",
  mat_piece = "all",
  notation = RCLabels::bracket_notation,
  prepositions = RCLabels::prepositions_list
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trim_rows_cols_+3A_a">a</code></td>
<td>
<p>A matrix to be trimmed.</p>
</td></tr>
<tr><td><code id="trim_rows_cols_+3A_mat">mat</code></td>
<td>
<p>The matrix to be used as the template for rows and/or columns of <code>a</code>.</p>
</td></tr>
<tr><td><code id="trim_rows_cols_+3A_margin">margin</code></td>
<td>
<p>The dimension of <code>a</code> to be trimmed. <code>1</code> means rows; <code>2</code> means columns.
Default is <code>c(1,2)</code>.</p>
</td></tr>
<tr><td><code id="trim_rows_cols_+3A_warn_if_a_incomplete">warn_if_a_incomplete</code></td>
<td>
<p>When <code>TRUE</code> (the default), a warning is emitted
if <code>a</code> is missing entries on <code>margin</code> that are present in <code>mat</code>.
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="trim_rows_cols_+3A_a_piece">a_piece</code></td>
<td>
<p>The portion of <code>a</code> labels to be used for comparison. Default is &quot;all&quot;.</p>
</td></tr>
<tr><td><code id="trim_rows_cols_+3A_mat_piece">mat_piece</code></td>
<td>
<p>The portion of <code>mat</code> labels to be used for comparison. Default is &quot;all&quot;.</p>
</td></tr>
<tr><td><code id="trim_rows_cols_+3A_notation">notation</code></td>
<td>
<p>The notation for row and column labels.
Default is <code>RCLabels::bracket_notation</code>.</p>
</td></tr>
<tr><td><code id="trim_rows_cols_+3A_prepositions">prepositions</code></td>
<td>
<p>The strings to be treated as prepositions in row and column labels.
Default is <code>RCLabels::prepositions_list</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>a</code> is <code>NULL</code>, <code>NULL</code> is returned.
If <code>mat</code> is <code>NULL</code>, <code>a</code> is returned unmodified.
If <code>mat</code> has <code>NULL</code> dimnames, <code>a</code> is returned unmodified.
If <code>mat</code> has <code>NULL</code> for dimnames on <code>margin</code>, an error is returned.
</p>
<p>A common use case for this function is to trim <code>a</code>, because it has too many
entries on <code>margin</code>s compared to <code>mat</code>.
This trimming will result in a smaller result for any mathematical operations
involving <code>a</code> and <code>mat</code>.
Typically, <code>a</code> should cover all the entries in <code>mat</code> on <code>margin</code>.
Thus, by default, this function warns if <code>a</code> is missing entries on <code>margin</code>
that are present in <code>mat</code>.
To turn off this checking behavior, set <code>warn_if_a_incomplete = FALSE</code>.
</p>
<p><code>a_piece</code> and <code>mat_piece</code>
control which part of row and column names are
compared before trimming.
The default values for <code>a_piece</code> and <code>mat_piece</code> are &quot;all&quot;,
meaning that the entire label should be matched.
Other options for <code>a_piece</code> and <code>mat_piece</code> are &quot;pref&quot; and &quot;suff&quot;,
which will match the prefix or suffix of the labels.
Alternatively, prepositions can be given such that
objects of prepositions will be matched.
Examples include &quot;from&quot; or &quot;in&quot;.
See <code><a href="RCLabels.html#topic+get_piece">RCLabels::get_piece()</a></code> for details.
</p>


<h3>Value</h3>

<p>Matrix <code>a</code> with rows or columns trimmed to match <code>mat</code>.
</p>


<h3>See Also</h3>

<p><code>RCLabels::get_piece()</code>, which is used internally.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- matrix(c(1, 2, 3, 
              4, 5, 6, 
              7, 8, 9), nrow = 3, ncol = 3, byrow = TRUE, 
            dimnames = list(c("r1", "r2", "r3"), c("c1", "c2", "c3"))) %&gt;% 
 setrowtype("rowtype") %&gt;% setcoltype("coltype")
mat &lt;- matrix(c(1, 2, 3,
                4, 5, 6), nrow = 2, ncol = 3, byrow = TRUE, 
            dimnames = list(c("r1", "bogus"), c("c1", "bogus", "c2"))) %&gt;% 
 setrowtype("rowtype") %&gt;% setcoltype("coltype")
trim_rows_cols(a, mat, margin = 1)
trim_rows_cols(a, mat, margin = 2)
trim_rows_cols(a, mat)
</code></pre>

<hr>
<h2 id='unaryapply_byname'>Apply a unary function by name</h2><span id='topic+unaryapply_byname'></span>

<h3>Description</h3>

<p><code>FUN</code> is applied to <code>a</code> using additional arguments <code>.FUNdots</code> to <code>FUN</code>.
If <code>a</code> is a list, the names of <code>a</code> are applied to the output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unaryapply_byname(
  FUN,
  a,
  .FUNdots = NULL,
  rowcoltypes = c("all", "transpose", "row", "col", "none")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unaryapply_byname_+3A_fun">FUN</code></td>
<td>
<p>a unary function to be applied &quot;by name&quot; to <code>a</code>.</p>
</td></tr>
<tr><td><code id="unaryapply_byname_+3A_a">a</code></td>
<td>
<p>the argument to <code>FUN</code>.</p>
</td></tr>
<tr><td><code id="unaryapply_byname_+3A_.fundots">.FUNdots</code></td>
<td>
<p>a list of additional named arguments passed to <code>FUN</code>.</p>
</td></tr>
<tr><td><code id="unaryapply_byname_+3A_rowcoltypes">rowcoltypes</code></td>
<td>
<p>a string that tells how to transfer row and column types of <code>a</code> to output. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code>.FUNdots</code> can be a rectangular two-dimensional list of arguments to <code>FUN</code>.
If so, <code>.FUNdots</code> is interpreted as follows:
</p>

<ul>
<li><p> The first dimension of <code>.FUNdots</code> contains named arguments to <code>FUN</code>.
</p>
</li>
<li><p> The second dimension of <code>.FUNdots</code> contains unique values of the named arguments
to be applied along the list that is <code>a</code>.
</p>
</li></ul>

<p>The length of the first dimension of <code>.FUNdots</code> is the number of arguments supplied to <code>FUN</code>.
The length of the second dimension of <code>.FUNdots</code> must be equal to the length of <code>a</code>.
</p>
<p>See <code>prepare_.FUNdots()</code> for more details on the <code>.FUNdots</code> argument.
</p>
<p>Options for the <code>rowcoltypes</code> argument are:
</p>

<ul>
<li><p> &quot;all&quot;: transfer both row and column types of <code>a</code> directly to output.
</p>
</li>
<li><p> &quot;transpose&quot;: rowtype of <code>a</code> becomes coltype of output; coltype of <code>a</code> becomes rowtype of output. &quot;transpose&quot; is helpful for <code>FUN</code>s that transpose <code>a</code> upon output.
</p>
</li>
<li><p> &quot;row&quot;: rowtype of <code>a</code> becomes both rowtype and coltype of output.
</p>
</li>
<li><p> &quot;col&quot;: coltype of <code>a</code> becomes both rowtype and coltype of output.
</p>
</li>
<li><p> &quot;none&quot;: rowtype and coltype not set by <code>unaryapply_byname</code>. Rather, <code>FUN</code> will set rowtype and coltype.
</p>
</li></ul>

<p>Note that <code>rowcoltypes</code> should not be a vector or list of strings.
Rather, it should be a single string.
</p>


<h3>Value</h3>

<p>the result of applying <code>FUN</code> &quot;by name&quot; to <code>a</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>productnames &lt;- c("p1", "p2")
industrynames &lt;- c("i1", "i2")
U &lt;- matrix(1:4, ncol = 2, dimnames = list(productnames, industrynames)) %&gt;%
  setrowtype("Products") %&gt;% setcoltype("Industries")
difference_byname(0, U)
unaryapply_byname(`-`, U)
</code></pre>

<hr>
<h2 id='vec_from_store_byname'>Create a vector with labels from a matrix and values from a vector store</h2><span id='topic+vec_from_store_byname'></span>

<h3>Description</h3>

<p>When a matrix is multiplied by a vector byname,
naming can be tricky.
There are times when pieces of the vector labels should be matched to
pieces of the matrix labels.
This function helps by performing the matching byname.
For this function, vector <code>v</code> is considered a store of values
from which the output vector is created
using special matching rules between matrix <code>a</code> and vector <code>v</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_from_store_byname(
  a,
  v,
  a_piece = "all",
  v_piece = "all",
  colname = NULL,
  margin = 1,
  notation = if (is.list(a)) {
     list(RCLabels::bracket_notation)
 } else {
    
    RCLabels::bracket_notation
 },
  prepositions = if (is.list(a)) {
     list(RCLabels::prepositions_list)
 } else {
    
    RCLabels::prepositions_list
 },
  missing = NA_real_
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_from_store_byname_+3A_a">a</code></td>
<td>
<p>A matrix from which row or column labels are taken.
Can also be a list or the name of a column in a data frame.</p>
</td></tr>
<tr><td><code id="vec_from_store_byname_+3A_v">v</code></td>
<td>
<p>A vector from which values are taken, when <code>a_piece</code> matches <code>v_piece</code>.
Can also be a list or the name of a column in a data frame.</p>
</td></tr>
<tr><td><code id="vec_from_store_byname_+3A_a_piece">a_piece</code></td>
<td>
<p>The piece of labels on <code>a</code> that is to be matched. Default is &quot;all&quot;.</p>
</td></tr>
<tr><td><code id="vec_from_store_byname_+3A_v_piece">v_piece</code></td>
<td>
<p>The piece of labels on <code>v</code> that is to be matched. Default is &quot;all&quot;.</p>
</td></tr>
<tr><td><code id="vec_from_store_byname_+3A_colname">colname</code></td>
<td>
<p>The name of the output vector's 1-sized dimension
(the only column if <code>column</code> is <code>TRUE</code>, the only row otherwise).
Default is <code>NULL</code>, meaning that the name of the 1-sized dimension in <code>v</code>
should be used.</p>
</td></tr>
<tr><td><code id="vec_from_store_byname_+3A_margin">margin</code></td>
<td>
<p>Tells whether to assess the rows (<code>1</code>) or columns (<code>2</code>) of <code>a</code>
when creating the outgoing vector.
Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="vec_from_store_byname_+3A_notation">notation</code></td>
<td>
<p>The notation for the row and column labels.
Default is <code>RCLabels::bracket_notation</code>, wrapped as a list if <code>a</code> is a list.</p>
</td></tr>
<tr><td><code id="vec_from_store_byname_+3A_prepositions">prepositions</code></td>
<td>
<p>The strings that will count for prepositions.
Default is <code>RCLabels::prepositions</code>, wrapped as a list if <code>a</code> is a list.</p>
</td></tr>
<tr><td><code id="vec_from_store_byname_+3A_missing">missing</code></td>
<td>
<p>The value used when the desired value is not found in <code>v</code>.
Default is <code>NA_real_</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output of this function is a vector
(a column vector if <code>column</code> is <code>TRUE</code>, the default;
a row vector if <code>column</code> is <code>FALSE</code>).
The label of the size = 1 dimension is taken from <code>colname</code>
(so named, because the default is to return a column vector).
The labels of the long dimension are taken from matrix <code>a</code>
(the row names of <code>a</code> if <code>column</code> is <code>TRUE</code>;
the column names of <code>a</code> if <code>column</code> is <code>FALSE</code>).
The values of the output vector are obtained from v
when <code>a_piece</code> matches <code>v_piece</code> using the <code>RCLabels</code> package.
The <code>v_piece</code>s of <code>v</code> must be unique.
The default values for <code>a_piece</code> and <code>v_piece</code> are &quot;all&quot;,
meaning that the entire label should be matched.
Other options for <code>a_piece</code> and <code>v_piece</code> are &quot;pref&quot; and &quot;suff&quot;,
which will match the prefix or suffix of the labels.
Alternatively, prepositions can be given such that
objects of prepositions will be matched.
Examples include &quot;from&quot; or &quot;in&quot;.
Row and column types from <code>v</code> are applied to the output.
If the piece given in <code>a_piece</code> is not present in row or column names of <code>a</code>,
<code>NA_real_</code> is returned.
If the piece given in <code>v_piece</code> is not present in row or column names of <code>v</code>,
<code>NA_real_</code> is returned.
</p>
<p>Note that <code>notation</code> and <code>prepositions</code> should be lists if <code>a</code> is a list
but a single value otherwise.
The default values of <code>notation</code> and <code>prepositions</code> take care of this requirement,
switching on the type of <code>a</code> (list or not).
</p>
<p>The class of the output object is determined from <code>a</code>.
If <code>a</code> is a <code>Matrix</code>, the output will be a <code>Matrix</code>.
Otherwise, the output will be a <code>matrix</code>.
</p>


<h3>Value</h3>

<p>A column vector with names from <code>a</code> and values from <code>v</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- matrix(42, nrow = 3, ncol = 5, 
            dimnames = list(c("Electricity [from b in c]", 
                              "Coal [from e in f]", 
                              "Crude oil [from Production in USA]"), 
                            c("Main activity producer electricity plants", 
                              "Wind turbines", 
                              "Oil refineries", 
                              "Coal mines", 
                              "Automobiles"))) %&gt;%
  setrowtype("Product") %&gt;% setcoltype("Industry")
a
v &lt;- matrix(1:7, nrow = 7, ncol = 1, 
            dimnames = list(c("Electricity", 
                              "Peat", 
                              "Hydro", 
                              "Crude oil",
                              "Coal", 
                              "Hard coal (if no detail)", 
                              "Brown coal"), 
                            "phi")) %&gt;%
  setrowtype("Product") %&gt;% setcoltype("phi")
v
vec_from_store_byname(a, v, a_piece = "pref")
vec_from_store_byname(a, v, a_piece = "noun")

v2 &lt;- matrix(1:7, nrow = 7, ncol = 1, 
             dimnames = list(c("Electricity", 
                               "Peat", 
                               "USA", 
                               "c",
                               "Coal", 
                               "Hard coal (if no detail)", 
                               "f"), 
                             "phi")) %&gt;%
  setrowtype("Product") %&gt;% setcoltype("phi")
vec_from_store_byname(a, v2, a_piece = "in")

# Works with lists
v3 &lt;- matrix(1:7, nrow = 7, ncol = 1, 
             dimnames = list(c("Electricity [from USA]", 
                               "Peat [from nowhere]", 
                               "Production [from GHA]", 
                               "e [from ZAF]",
                               "Coal [from AUS]", 
                               "Hard coal (if no detail) [from GBR]", 
                               "b [from Nebraska]"), 
                             "phi")) %&gt;%
  setrowtype("Product") %&gt;% setcoltype("phi")
a_list &lt;- list(a, a)
v_list &lt;- list(v3, v3)
vec_from_store_byname(a_list, v_list, a_piece = "in", v_piece = "from")

# Also works in a data frame
df &lt;- tibble::tibble(a = list(a, a, a), 
                     v = list(v3, v3, v3))
df %&gt;%
  dplyr::mutate(
    actual = vec_from_store_byname(a = a, v = v, a_piece = "in", v_piece = "from")
  )
</code></pre>

<hr>
<h2 id='vectorize_byname'>Vectorize a matrix</h2><span id='topic+vectorize_byname'></span>

<h3>Description</h3>

<p>Converts a matrix into a column vector.
Each element of the matrix becomes an entry in the column vector,
with rows named via the <code>notation</code> argument.
Callers may want to transpose the matrix first with <code>transpose_byname()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vectorize_byname(a, notation)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vectorize_byname_+3A_a">a</code></td>
<td>
<p>The matrix to be vectorized.</p>
</td></tr>
<tr><td><code id="vectorize_byname_+3A_notation">notation</code></td>
<td>
<p>A string vector created by <code>notation_vec()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>notation</code> is also applied to <code>rowtype</code> and <code>coltype</code> attributes.
</p>


<h3>Value</h3>

<p>A column vector containing all elements of <code>a</code>, with row names assigned as &quot;rowname <code>sep</code> colname&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(c(1, 5,
              4, 5),
            nrow = 2, ncol = 2, byrow = TRUE, 
            dimnames = list(c("p1", "p2"), c("i1", "i2"))) %&gt;% 
  setrowtype("Products") %&gt;% setcoltype("Industries")
m
vectorize_byname(m, notation = RCLabels::arrow_notation)
# If a single number is provided, the number will be returned as a 1x1 column vector 
# with some additional attributes.
vectorize_byname(42, notation = RCLabels::arrow_notation)
attributes(vectorize_byname(42, notation = RCLabels::arrow_notation))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
