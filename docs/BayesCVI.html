<!DOCTYPE html><html><head><title>Help for package BayesCVI</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BayesCVI}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#B_CCV.IDX'>
<p>BCVI-Correlation Cluster Validity (CCV) index</p></a></li>
<li><a href='#B_CH.IDX'>
<p>BCVI-Calinski–Harabasz (CH) index</p></a></li>
<li><a href='#B_CSL.IDX'>
<p>BCVI-Chou-Su-Lai (CSL) index</p></a></li>
<li><a href='#B_DB.IDX'>
<p>BCVI-Davies–Bouldin (DB) and DB* (DBs) indexes</p></a></li>
<li><a href='#B_DI.IDX'>
<p>BCVI-Dunn index (DI)</p></a></li>
<li><a href='#B_GC.IDX'>
<p>BCVI-The generalized C (GC) index</p></a></li>
<li><a href='#B_HF.IDX'>
<p>BCVI-HF index</p></a></li>
<li><a href='#B_KPBM.IDX'>
<p>BCVI-Modified Kernel form of Pakhira-Bandyopadhyay-Maulik (KPBM) index</p></a></li>
<li><a href='#B_KWON.IDX'>
<p>BCVI-KWON index</p></a></li>
<li><a href='#B_KWON2.IDX'>
<p>BCVI-KWON2 index</p></a></li>
<li><a href='#B_PB.IDX'>
<p>BCVI-Point biserial correlation (PB)</p></a></li>
<li><a href='#B_PBM.IDX'>
<p>BCVI-Pakhira-Bandyopadhyay-Maulik (PBM) index</p></a></li>
<li><a href='#B_SF.IDX'>
<p>BCVI-The score function</p></a></li>
<li><a href='#B_STRPBM.IDX'>
<p>BCVI-Starczewski and Pakhira-Bandyopadhyay-Maulik for crisp clustering indexes</p></a></li>
<li><a href='#B_TANG.IDX'>
<p>BCVI-Tang index</p></a></li>
<li><a href='#B_WL.IDX'>
<p>BCVI-Wu and Li (WL) index</p></a></li>
<li><a href='#B_WP.IDX'>
<p>BCVI-Wiroonsri and Preedasawakul (WP) index</p></a></li>
<li><a href='#B_Wvalid'>
<p>BCVI-Wiroonsri (WI) index</p></a></li>
<li><a href='#B_XB.IDX'>
<p>BCVI-Xie and Beni (XB) index</p></a></li>
<li><a href='#B1_data'><p>B1 Artificial Dataset</p></a></li>
<li><a href='#B2_data'><p>B2 Artificial Dataset</p></a></li>
<li><a href='#B3_data'><p>B3 Artificial Dataset</p></a></li>
<li><a href='#B4_data'><p>B4 Artificial Dataset</p></a></li>
<li><a href='#B5_data'><p>B5 Artificial Dataset</p></a></li>
<li><a href='#B6_data'><p>B6 Artificial Dataset</p></a></li>
<li><a href='#B7_data'><p>B7 Artificial Dataset</p></a></li>
<li><a href='#BayesCVIs'>
<p>Bayesian cluster validity index</p></a></li>
<li><a href='#plot_BCVI'>
<p>Plots for visualizing BCVI</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Cluster Validity Index</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Imports:</td>
<td>e1071, mclust, ggplot2, UniversalCVI</td>
</tr>
<tr>
<td>Description:</td>
<td>Algorithms for computing and generating plots with and without error bars for Bayesian cluster validity index (BCVI) (N. Wiroonsri, O. Preedasawakul (2024) &lt;<a href="https://doi.org/10.48550/arXiv.2402.02162">doi:10.48550/arXiv.2402.02162</a>&gt;) based on several underlying cluster validity indexes (CVIs) including Calinski-Harabasz, Chou-Su-Lai, Davies-Bouldin, Dunn,  Pakhira-Bandyopadhyay-Maulik, Point biserial correlation, the score function, Starczewski, and Wiroonsri indices for hard clustering, and Correlation Cluster Validity, the generalized C, HF, KWON, KWON2, Modified Pakhira-Bandyopadhyay-Maulik, Pakhira-Bandyopadhyay-Maulik, Tang, Wiroonsri-Preedasawakul, Wu-Li, and Xie-Beni indices for soft clustering. The package is compatible with K-means, fuzzy C means, EM clustering, and hierarchical clustering (single, average, and complete linkage). Though BCVI is compatible with any underlying existing CVIs, we recommend users to use either WI or WP as the underlying CVI.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-23 03:38:32 UTC; lenovo</td>
</tr>
<tr>
<td>Author:</td>
<td>Nathakhun Wiroonsri
    <a href="https://orcid.org/0000-0003-2167-9641"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Onthada Preedasawakul
    <a href="https://orcid.org/0000-0002-4186-3158"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre, aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Onthada Preedasawakul &lt;o.preedasawakul@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-26 16:20:12 UTC</td>
</tr>
</table>
<hr>
<h2 id='B_CCV.IDX'>
BCVI-Correlation Cluster Validity (CCV) index</h2><span id='topic+B_CCV.IDX'></span>

<h3>Description</h3>

<p>Compute Bayesian cluster validity index (BCVI) from two to <code>kmax</code> groups using the pearson correlation cluster validity (CCVP) and/or the spearman’s (rho) correlation cluster validity (CCVS) as the underling cluster validity index (CVI) with the user's selected Dirichlet prior parameters. The full detail of BCVI can be found in the paper Wiroonsri and Preedasawakul (2024).</p>


<h3>Usage</h3>

<pre><code class='language-R'>B_CCV.IDX(x, kmax, indexlist = "all", method = "FCM", fzm = 2,
        iter = 100, nstart = 20, alpha = "default", mult.alpha = 1/2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="B_CCV.IDX_+3A_x">x</code></td>
<td>
<p>a numeric data frame or matrix where each column is a variable to be used for cluster analysis and each row is a data point.
</p>
</td></tr>
<tr><td><code id="B_CCV.IDX_+3A_kmax">kmax</code></td>
<td>
<p>a maximum number of clusters to be considered.
</p>
</td></tr>
<tr><td><code id="B_CCV.IDX_+3A_indexlist">indexlist</code></td>
<td>
<p>a character string indicating which The generalized C index be computed (&quot;<code>all</code>&quot;,&quot;<code>CCVP</code>&quot;,&quot;<code>CCVS</code>&quot;). More than one indexes can be selected.
</p>
</td></tr>
<tr><td><code id="B_CCV.IDX_+3A_method">method</code></td>
<td>
<p>a character string indicating which clustering method to be used (<code>"FCM"</code> or <code>"EM"</code>). The default is <code>"FCM"</code>.
</p>
</td></tr>
<tr><td><code id="B_CCV.IDX_+3A_fzm">fzm</code></td>
<td>
<p>a number greater than 1 giving the degree of fuzzification for <code>method = "FCM"</code>. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="B_CCV.IDX_+3A_iter">iter</code></td>
<td>
<p>a maximum number of iterations for <code>method = "FCM"</code>. The default is <code>100</code>.
</p>
</td></tr>
<tr><td><code id="B_CCV.IDX_+3A_nstart">nstart</code></td>
<td>
<p>a maximum number of initial random sets for FCM for <code>method = "FCM"</code>. The default is <code>20</code>.
</p>
</td></tr>
<tr><td><code id="B_CCV.IDX_+3A_alpha">alpha</code></td>
<td>
<p>Dirichlet prior parameters <code class="reqn">\alpha_2,...,\alpha_k</code> where <code class="reqn">\alpha_k</code> is the parameter corresponding to &quot;the probability of having k groups&quot; (selecting each <code class="reqn">\alpha_k</code> between 0 to 30 is recommended and using the other parameter <code>mult.alpha</code> to be its multiplier. The default is <code>"default"</code>.)
</p>
</td></tr>
<tr><td><code id="B_CCV.IDX_+3A_mult.alpha">mult.alpha</code></td>
<td>
<p>the power <code class="reqn">s</code> from <code class="reqn">n^s</code> to be multiplied to the Dirichlet prior parameters <code>alpha</code> (selecting <code>mult.alpha</code> in <code>[0,1)</code> is recommended). The default is <code class="reqn">\frac{1}{2}</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>BCVI-CCV is defined as follows.
Let <br />
</p>
<p style="text-align: center;"><code class="reqn">r_k(\bf x) = \dfrac{CVI(k)-\min_j CVI(j)}{\sum_{i=2}^K (CVI(i)-\min_j CVI(j))} </code>
</p>

<p>where CVI is either CCVP or CCVS index. <br />
</p>
<p>Assume that <br />
</p>
<p style="text-align: center;"><code class="reqn">f({\bf x}|{\bf p}) = C({\bf p}) \prod_{k=2}^Kp_k^{nr_k(x)}</code>
</p>

<p>represents the conditional probability density function of the dataset given <code class="reqn">\bf p</code>, where <code class="reqn">C({\bf p})</code> is the normalizing constant. Assume further that  <code class="reqn">{\bf p}</code> follows a Dirichlet prior distribution with parameters <code class="reqn">{\bm \alpha} = (\alpha_2,\ldots,\alpha_K)</code>. The posterior distribution of <code class="reqn">\bf p</code> still remains a Dirichlet distribution with parameters <code class="reqn">(\alpha_2+nr_2({\bf x}),\ldots,\alpha_K+nr_K({\bf x}))</code>.
</p>
<p>The BCVI is then defined as  <br />
</p>
<p style="text-align: center;"><code class="reqn">BCVI(k) = E[p_k|{\bf x}] = \frac{\alpha_k + nr_k({\bf x})}{\alpha_0+n}</code>
</p>

<p>where <code class="reqn">\alpha_0 = \sum_{k=2}^K \alpha_k.</code> <br />
</p>
<p>The variance of <code class="reqn">p_k</code> can be computed as
</p>
<p style="text-align: center;"><code class="reqn">Var(p_k|{\bf x}) = \dfrac{(\alpha_k + nr_k(x))(\alpha_0 + n -\alpha_k-nr_k(x))}{(\alpha_0 + n)^2(\alpha_0 + n +1 )}.</code>
</p>



<h3>Value</h3>

<table>
<tr><td><code>BCVI</code></td>
<td>
<p>the dataframe where the first and the second columns are the number of groups <code>k</code> and BCVI<code class="reqn">(k)</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
<tr><td><code>VAR</code></td>
<td>
<p>the data frame where the first and the second columns are the number of groups <code>k</code> and the variance of <code class="reqn">p_k</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
<tr><td><code>CVI</code></td>
<td>
<p>the data frame where the first and the second columns are the number of groups <code>k</code> and the original CCVP<code class="reqn">(k)</code> or CCVS<code class="reqn">(k)</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>M. Popescu, J. C. Bezdek, T. C. Havens and J. M. Keller (2013). &quot;A Cluster Validity Framework Based on Induced Partition Dissimilarity.&quot; <a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=6246717&amp;isnumber=6340245">https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=6246717&amp;isnumber=6340245</a>
</p>
<p>N. Wiroonsri, O. Preedasawakul, &quot;A Bayesian cluster validity index&quot;, arXiv:2402.02162, 2024.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+B7_data">B7_data</a>, <a href="#topic+B_TANG.IDX">B_TANG.IDX</a>, <a href="#topic+B_XB.IDX">B_XB.IDX</a>, <a href="#topic+B_Wvalid">B_Wvalid</a>, <a href="#topic+B_DB.IDX">B_DB.IDX</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(BayesCVI)

# The data included in this package.
data = B7_data[,1:2]

# alpha
aalpha = c(20,20,20,5,5,5,0.5,0.5,0.5)

B.CCV = B_CCV.IDX(x = scale(data), kmax=10, indexlist = "CCVP", method = "FCM", fzm = 2, iter = 100,
              nstart = 20, alpha = aalpha, mult.alpha = 1/2)

# plot the BCVI-CCVP

pplot = plot_BCVI(B.CCV$CCVP)
pplot$plot_index
pplot$plot_BCVI
pplot$error_bar_plot

</code></pre>

<hr>
<h2 id='B_CH.IDX'>
BCVI-Calinski–Harabasz (CH) index
</h2><span id='topic+B_CH.IDX'></span>

<h3>Description</h3>

<p>Compute Bayesian cluster validity index (BCVI) from two to <code>kmax</code> groups using Calinski–Harabasz (CH) as the underling cluster validity index (CVI) with the user's selected Dirichlet prior parameters. The full detail of BCVI can be found in the paper Wiroonsri and Preedasawakul (2024).</p>


<h3>Usage</h3>

<pre><code class='language-R'>B_CH.IDX(x, kmax, method = "kmeans", nstart = 100, alpha = "default", mult.alpha = 1/2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="B_CH.IDX_+3A_x">x</code></td>
<td>
<p>a numeric data frame or matrix where each column is a variable to be used for cluster analysis and each row is a data point.
</p>
</td></tr>
<tr><td><code id="B_CH.IDX_+3A_kmax">kmax</code></td>
<td>
<p>a maximum number of clusters to be considered.
</p>
</td></tr>
<tr><td><code id="B_CH.IDX_+3A_method">method</code></td>
<td>
<p>a character string indicating which clustering method to be used (<code>"kmeans"</code>, <code>"hclust_complete"</code>, <code>"hclust_average"</code>, <code>"hclust_single"</code>). The default is <code>"kmeans"</code>.
</p>
</td></tr>
<tr><td><code id="B_CH.IDX_+3A_nstart">nstart</code></td>
<td>
<p>a maximum number of initial random sets for kmeans for <code>method = "kmeans"</code>. The default is <code>100</code>.
</p>
</td></tr>
<tr><td><code id="B_CH.IDX_+3A_alpha">alpha</code></td>
<td>
<p>Dirichlet prior parameters <code class="reqn">\alpha_2,...,\alpha_k</code> where <code class="reqn">\alpha_k</code> is the parameter corresponding to &quot;the probability of having k groups&quot; (selecting each <code class="reqn">\alpha_k</code> between 0 to 30 is recommended and using the other parameter <code>mult.alpha</code> to be its multiplier. The default is <code>"default"</code>.
</p>
</td></tr>
<tr><td><code id="B_CH.IDX_+3A_mult.alpha">mult.alpha</code></td>
<td>
<p>the power <code class="reqn">s</code> from <code class="reqn">n^s</code> to be multiplied to the Dirichlet prior parameters <code>alpha</code> (selecting <code>mult.alpha</code> in <code>[0,1)</code> is recommended). The default is <code class="reqn">\frac{1}{2}</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>BCVI-CH is defined as follows.
Let <br />
</p>
<p style="text-align: center;"><code class="reqn">r_k(\bf x) = \dfrac{CH(k)-\min_j CH(j)}{\sum_{i=2}^K (CH(i)-\min_j CH(j))} </code>
</p>

<p>Assume that <br />
</p>
<p style="text-align: center;"><code class="reqn">f({\bf x}|{\bf p}) = C({\bf p}) \prod_{k=2}^Kp_k^{nr_k(x)}</code>
</p>

<p>represents the conditional probability density function of the dataset given <code class="reqn">\bf p</code>, where <code class="reqn">C({\bf p})</code> is the normalizing constant. Assume further that  <code class="reqn">{\bf p}</code> follows a Dirichlet prior distribution with parameters <code class="reqn">{\bm \alpha} = (\alpha_2,\ldots,\alpha_K)</code>. The posterior distribution of <code class="reqn">\bf p</code> still remains a Dirichlet distribution with parameters <code class="reqn">(\alpha_2+nr_2({\bf x}),\ldots,\alpha_K+nr_K({\bf x}))</code>.
</p>
<p>The BCVI is then defined as  <br />
</p>
<p style="text-align: center;"><code class="reqn">BCVI(k) = E[p_k|{\bf x}] = \frac{\alpha_k + nr_k({\bf x})}{\alpha_0+n}</code>
</p>

<p>where <code class="reqn">\alpha_0 = \sum_{k=2}^K \alpha_k.</code> <br />
</p>
<p>The variance of <code class="reqn">p_k</code> can be computed as
</p>
<p style="text-align: center;"><code class="reqn">Var(p_k|{\bf x}) = \dfrac{(\alpha_k + nr_k(x))(\alpha_0 + n -\alpha_k-nr_k(x))}{(\alpha_0 + n)^2(\alpha_0 + n +1 )}.</code>
</p>



<h3>Value</h3>

<table>
<tr><td><code>BCVI</code></td>
<td>
<p>the dataframe where the first and the second columns are the number of groups <code>k</code> and BCVI<code class="reqn">(k)</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
<tr><td><code>VAR</code></td>
<td>
<p>the data frame where the first and the second columns are the number of groups <code>k</code> and the variance of <code class="reqn">p_k</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
<tr><td><code>CVI</code></td>
<td>
<p>the data frame where the first and the second columns are the number of groups <code>k</code> and the original CH<code class="reqn">(k)</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>T. Calinski, J. Harabasz, &quot;A dendrite method for cluster analysis,&quot; <em>Communications in Statistics</em>, 3, 1-27 (1974).
</p>
<p>N. Wiroonsri, O. Preedasawakul, &quot;A Bayesian cluster validity index&quot;, arXiv:2402.02162, 2024.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+B2_data">B2_data</a>, <a href="#topic+B_TANG.IDX">B_TANG.IDX</a>, <a href="#topic+B_XB.IDX">B_XB.IDX</a>, <a href="#topic+B_Wvalid">B_Wvalid</a>, <a href="#topic+B_DB.IDX">B_DB.IDX</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(BayesCVI)

# The data included in this package.
data = B2_data[,1:2]

# alpha
aalpha = c(5,5,5,20,20,20,0.5,0.5,0.5)

B.CH = B_CH.IDX(x = scale(data), kmax=10, method = "kmeans",
                nstart = 100, alpha = aalpha, mult.alpha = 1/2)

# plot the BCVI

pplot = plot_BCVI(B.CH)
pplot$plot_index
pplot$plot_BCVI
pplot$error_bar_plot

</code></pre>

<hr>
<h2 id='B_CSL.IDX'>
BCVI-Chou-Su-Lai (CSL) index</h2><span id='topic+B_CSL.IDX'></span>

<h3>Description</h3>

<p>Compute Bayesian cluster validity index (BCVI) from two to <code>kmax</code> groups using Chou-Su-Lai (CSL) as the underlying cluster validity index (CVI) and Dirichlet prior parameters of the user's choice. The full detail of BCVI can be found in the paper Wiroonsri and Preedasawakul (2024).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>B_CSL.IDX(x, kmax, method = "kmeans", nstart = 100, alpha = "default", mult.alpha = 1/2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="B_CSL.IDX_+3A_x">x</code></td>
<td>
<p>a numeric data frame or matrix where each column is a variable to be used for cluster analysis and each row is a data point.
</p>
</td></tr>
<tr><td><code id="B_CSL.IDX_+3A_kmax">kmax</code></td>
<td>
<p>a maximum number of clusters to be considered.
</p>
</td></tr>
<tr><td><code id="B_CSL.IDX_+3A_method">method</code></td>
<td>
<p>a character string indicating which clustering method to be used (<code>"kmeans"</code>, <code>"hclust_complete"</code>, <code>"hclust_average"</code>, <code>"hclust_single"</code>). The default is <code>"kmeans"</code>.
</p>
</td></tr>
<tr><td><code id="B_CSL.IDX_+3A_nstart">nstart</code></td>
<td>
<p>a maximum number of initial random sets for kmeans for <code>method = "kmeans"</code>. The default is <code>100</code>.
</p>
</td></tr>
<tr><td><code id="B_CSL.IDX_+3A_alpha">alpha</code></td>
<td>
<p>Dirichlet prior parameters <code class="reqn">\alpha_2,...,\alpha_k</code> where <code class="reqn">\alpha_k</code> is the parameter corresponding to &quot;the probability of having k groups&quot; (selecting each <code class="reqn">\alpha_k</code> between 0 to 30 is recommended and using the other parameter <code>mult.alpha</code> to be its multiplier. The default is <code>"default"</code>.
</p>
</td></tr>
<tr><td><code id="B_CSL.IDX_+3A_mult.alpha">mult.alpha</code></td>
<td>
<p>the power <code class="reqn">s</code> from <code class="reqn">n^s</code> to be multiplied to the Dirichlet prior parameters <code>alpha</code> (selecting <code>mult.alpha</code> in <code>[0,1)</code> is recommended). The default is <code class="reqn">\frac{1}{2}</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>BCVI-CSL is defined as follows.
</p>
<p>Let <br />
</p>
<p style="text-align: center;"><code class="reqn">r_k(\bf x) = \dfrac{\max_j CSL(j)- CSL(k)}{\sum_{i=2}^K (\max_j CSL(j) - CSL(i))}.</code>
</p>

<p>Assume that <br />
</p>
<p style="text-align: center;"><code class="reqn">f({\bf x}|{\bf p}) = C({\bf p}) \prod_{k=2}^Kp_k^{nr_k(x)}</code>
</p>

<p>represents the conditional probability density function of the dataset given <code class="reqn">\bf p</code>, where <code class="reqn">C({\bf p})</code> is the normalizing constant. Assume further that  <code class="reqn">{\bf p}</code> follows a Dirichlet prior distribution with parameters <code class="reqn">{\bm \alpha} = (\alpha_2,\ldots,\alpha_K)</code>. The posterior distribution of <code class="reqn">\bf p</code> still remains a Dirichlet distribution with parameters <code class="reqn">(\alpha_2+nr_2({\bf x}),\ldots,\alpha_K+nr_K({\bf x}))</code>.
</p>
<p>The BCVI is then defined as  <br />
</p>
<p style="text-align: center;"><code class="reqn">BCVI(k) = E[p_k|{\bf x}] = \frac{\alpha_k + nr_k({\bf x})}{\alpha_0+n}</code>
</p>

<p>where <code class="reqn">\alpha_0 = \sum_{k=2}^K \alpha_k.</code> <br />
</p>
<p>The variance of <code class="reqn">p_k</code> can be computed as
</p>
<p style="text-align: center;"><code class="reqn">Var(p_k|{\bf x}) = \dfrac{(\alpha_k + nr_k(x))(\alpha_0 + n -\alpha_k-nr_k(x))}{(\alpha_0 + n)^2(\alpha_0 + n +1 )}.</code>
</p>



<h3>Value</h3>

<table>
<tr><td><code>BCVI</code></td>
<td>
<p>the dataframe where the first and the second columns are the number of groups <code>k</code> and BCVI<code class="reqn">(k)</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
<tr><td><code>VAR</code></td>
<td>
<p>the data frame where the first and the second columns are the number of groups <code>k</code> and the variance of <code class="reqn">p_k</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
<tr><td><code>CVI</code></td>
<td>
<p>the data frame where the first and the second columns are the number of groups <code>k</code> and the original CSL<code class="reqn">(k)</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>C. H. Chou, M. C. Su, E. Lai, &quot;A new cluster validity measure and its application to image compression,&quot; <em>Pattern Anal Applic</em>, 7, 205-220 (2004).
</p>
<p>N. Wiroonsri, O. Preedasawakul, &quot;A Bayesian cluster validity index&quot;, arXiv:2402.02162, 2024.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+B2_data">B2_data</a>, <a href="#topic+B_TANG.IDX">B_TANG.IDX</a>, <a href="#topic+B_WP.IDX">B_WP.IDX</a>, <a href="#topic+B_Wvalid">B_Wvalid</a>, <a href="#topic+B_DB.IDX">B_DB.IDX</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(BayesCVI)

# The data included in this package.
data = B2_data[,1:2]

# alpha
aalpha = c(5,5,5,20,20,20,0.5,0.5,0.5)

B.CSL = B_CSL.IDX(x = scale(data), kmax=10, method = "kmeans",
                nstart = 100, alpha = aalpha, mult.alpha = 1/2)

# plot the BCVI

pplot = plot_BCVI(B.CSL)
pplot$plot_index
pplot$plot_BCVI
pplot$error_bar_plot
</code></pre>

<hr>
<h2 id='B_DB.IDX'>
BCVI-Davies–Bouldin (DB) and DB* (DBs) indexes
</h2><span id='topic+B_DB.IDX'></span>

<h3>Description</h3>

<p>Compute Bayesian cluster validity index (BCVI) from two to <code>kmax</code> groups using DB and/or DBs as the underling cluster validity index (CVI) with the user's selected Dirichlet prior parameters. The full detail of BCVI can be found in the paper Wiroonsri and Preedasawakul (2024).</p>


<h3>Usage</h3>

<pre><code class='language-R'>B_DB.IDX(x, kmax, method = "kmeans", indexlist = "all", p = 2, q = 2,
        nstart = 100, alpha = "default", mult.alpha = 1/2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="B_DB.IDX_+3A_x">x</code></td>
<td>
<p>a numeric data frame or matrix where each column is a variable to be used for cluster analysis and each row is a data point.
</p>
</td></tr>
<tr><td><code id="B_DB.IDX_+3A_kmax">kmax</code></td>
<td>
<p>a maximum number of clusters to be considered.
</p>
</td></tr>
<tr><td><code id="B_DB.IDX_+3A_method">method</code></td>
<td>
<p>a character string indicating which clustering method to be used (<code>"kmeans"</code>, <code>"hclust_complete"</code>, <code>"hclust_average"</code>, <code>"hclust_single"</code>). The default is <code>"kmeans"</code>.
</p>
</td></tr>
<tr><td><code id="B_DB.IDX_+3A_indexlist">indexlist</code></td>
<td>
<p>a character string indicating which cluster validity indexes to be computed (<code>"all"</code>, <code>"DB"</code>, <code>"DBs"</code>). More than one indexes can be selected.
</p>
</td></tr>
<tr><td><code id="B_DB.IDX_+3A_p">p</code></td>
<td>
<p>the power of the Minkowski distance between centroids of clusters. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="B_DB.IDX_+3A_q">q</code></td>
<td>
<p>the power of dispersion measure of a cluster. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="B_DB.IDX_+3A_nstart">nstart</code></td>
<td>
<p>a maximum number of initial random sets for kmeans for <code>method = "kmeans"</code>. The default is <code>100</code>.
</p>
</td></tr>
<tr><td><code id="B_DB.IDX_+3A_alpha">alpha</code></td>
<td>
<p>Dirichlet prior parameters <code class="reqn">\alpha_2,...,\alpha_k</code> where <code class="reqn">\alpha_k</code> is the parameter corresponding to &quot;the probability of having k groups&quot; (selecting each <code class="reqn">\alpha_k</code> between 0 to 30 is recommended and using the other parameter <code>mult.alpha</code> to be its multiplier. The default is <code>"default"</code>.)
</p>
</td></tr>
<tr><td><code id="B_DB.IDX_+3A_mult.alpha">mult.alpha</code></td>
<td>
<p>the power <code class="reqn">s</code> from <code class="reqn">n^s</code> to be multiplied to the Dirichlet prior parameters <code>alpha</code> (selecting <code>mult.alpha</code> in <code>[0,1)</code> is recommended). The default is <code class="reqn">\frac{1}{2}</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>BCVI-DB is defined as follows.
</p>
<p>Let <br />
</p>
<p style="text-align: center;"><code class="reqn">r_k(\bf x) = \dfrac{\max_j CVI(j)- CVI(k)}{\sum_{i=2}^K (\max_j CVI(j) - CVI(i))}.</code>
</p>

<p>where CVI indicates DB or DBs index. <br />
Assume that <br />
</p>
<p style="text-align: center;"><code class="reqn">f({\bf x}|{\bf p}) = C({\bf p}) \prod_{k=2}^Kp_k^{nr_k(x)}</code>
</p>

<p>represents the conditional probability density function of the dataset given <code class="reqn">\bf p</code>, where <code class="reqn">C({\bf p})</code> is the normalizing constant. Assume further that  <code class="reqn">{\bf p}</code> follows a Dirichlet prior distribution with parameters <code class="reqn">{\bm \alpha} = (\alpha_2,\ldots,\alpha_K)</code>. The posterior distribution of <code class="reqn">\bf p</code> still remains a Dirichlet distribution with parameters <code class="reqn">(\alpha_2+nr_2({\bf x}),\ldots,\alpha_K+nr_K({\bf x}))</code>.
</p>
<p>The BCVI is then defined as  <br />
</p>
<p style="text-align: center;"><code class="reqn">BCVI(k) = E[p_k|{\bf x}] = \frac{\alpha_k + nr_k({\bf x})}{\alpha_0+n}</code>
</p>

<p>where <code class="reqn">\alpha_0 = \sum_{k=2}^K \alpha_k.</code> <br />
</p>
<p>The variance of <code class="reqn">p_k</code> can be computed as
</p>
<p style="text-align: center;"><code class="reqn">Var(p_k|{\bf x}) = \dfrac{(\alpha_k + nr_k(x))(\alpha_0 + n -\alpha_k-nr_k(x))}{(\alpha_0 + n)^2(\alpha_0 + n +1 )}.</code>
</p>



<h3>Value</h3>

<table>
<tr><td><code>BCVI</code></td>
<td>
<p>the dataframe where the first and the second columns are the number of groups <code>k</code> and BCVI<code class="reqn">(k)</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
<tr><td><code>VAR</code></td>
<td>
<p>the data frame where the first and the second columns are the number of groups <code>k</code> and the variance of <code class="reqn">p_k</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
<tr><td><code>CVI</code></td>
<td>
<p>the data frame where the first and the second columns are the number of groups <code>k</code> and the original DB<code class="reqn">(k)</code> or DBs<code class="reqn">(k)</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>D. L. Davies, D. W. Bouldin, &quot;A cluster separation measure,&quot; <em>IEEE Trans Pattern Anal Machine Intell</em>, 1, 224-227 (1979).
</p>
<p>M. Kim, R. S. Ramakrishna, &quot;New indices for cluster validity assessment,&quot; <em>Pattern Recognition Letters</em>, 26, 2353-2363 (2005).
</p>
<p>N. Wiroonsri, O. Preedasawakul, &quot;A Bayesian cluster validity index&quot;, arXiv:2402.02162, 2024.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+B2_data">B2_data</a>, <a href="#topic+B_TANG.IDX">B_TANG.IDX</a>, <a href="#topic+B_WP.IDX">B_WP.IDX</a>, <a href="#topic+B_Wvalid">B_Wvalid</a>, <a href="#topic+B_DI.IDX">B_DI.IDX</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(BayesCVI)

# The data included in this package.
data = B2_data[,1:2]

# alpha
aalpha = c(5,5,5,20,20,20,0.5,0.5,0.5)

B.DB = B_DB.IDX(x = scale(data), kmax=10, method = "kmeans", indexlist = "all",
              p = 2, q = 2, nstart = 100, alpha = "default", mult.alpha = 1/2)

# plot the BCVI-DB

pplot = plot_BCVI(B.DB$DB)
pplot$plot_index
pplot$plot_BCVI
pplot$error_bar_plot

# plot the BCVI-DBs

pplot = plot_BCVI(B.DB$DBs)
pplot$plot_index
pplot$plot_BCVI
pplot$error_bar_plot
</code></pre>

<hr>
<h2 id='B_DI.IDX'>
BCVI-Dunn index (DI)</h2><span id='topic+B_DI.IDX'></span>

<h3>Description</h3>

<p>Compute Bayesian cluster validity index (BCVI) from two to <code>kmax</code> groups using Dunn index (DI) as the underling cluster validity index (CVI) with the user's selected Dirichlet prior parameters. The full detail of BCVI can be found in the paper Wiroonsri and Preedasawakul (2024).</p>


<h3>Usage</h3>

<pre><code class='language-R'>B_DI.IDX(x, kmax, method = "kmeans", nstart = 100, alpha = "default", mult.alpha = 1/2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="B_DI.IDX_+3A_x">x</code></td>
<td>
<p>a numeric data frame or matrix where each column is a variable to be used for cluster analysis and each row is a data point.
</p>
</td></tr>
<tr><td><code id="B_DI.IDX_+3A_kmax">kmax</code></td>
<td>
<p>a maximum number of clusters to be considered.
</p>
</td></tr>
<tr><td><code id="B_DI.IDX_+3A_method">method</code></td>
<td>
<p>a character string indicating which clustering method to be used (<code>"kmeans"</code>, <code>"hclust_complete"</code>, <code>"hclust_average"</code>, <code>"hclust_single"</code>). The default is <code>"kmeans"</code>.
</p>
</td></tr>
<tr><td><code id="B_DI.IDX_+3A_nstart">nstart</code></td>
<td>
<p>a maximum number of initial random sets for kmeans for <code>method = "kmeans"</code>. The default is <code>100</code>.
</p>
</td></tr>
<tr><td><code id="B_DI.IDX_+3A_alpha">alpha</code></td>
<td>
<p>Dirichlet prior parameters <code class="reqn">\alpha_2,...,\alpha_k</code> where <code class="reqn">\alpha_k</code> is the parameter corresponding to &quot;the probability of having k groups&quot; (selecting each <code class="reqn">\alpha_k</code> between 0 to 30 is recommended and using the other parameter <code>mult.alpha</code> to be its multiplier. The default is <code>"default"</code>.
</p>
</td></tr>
<tr><td><code id="B_DI.IDX_+3A_mult.alpha">mult.alpha</code></td>
<td>
<p>the power <code class="reqn">s</code> from <code class="reqn">n^s</code> to be multiplied to the Dirichlet prior parameters <code>alpha</code> (selecting <code>mult.alpha</code> in <code>[0,1)</code> is recommended). The default is <code class="reqn">\frac{1}{2}</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>BCVI-DI is defined as follows.
Let <br />
</p>
<p style="text-align: center;"><code class="reqn">r_k(\bf x) = \dfrac{DI(k)-\min_j DI(j)}{\sum_{i=2}^K (DI(i)-\min_j DI(j))} </code>
</p>

<p>Assume that <br />
</p>
<p style="text-align: center;"><code class="reqn">f({\bf x}|{\bf p}) = C({\bf p}) \prod_{k=2}^Kp_k^{nr_k(x)}</code>
</p>

<p>represents the conditional probability density function of the dataset given <code class="reqn">\bf p</code>, where <code class="reqn">C({\bf p})</code> is the normalizing constant. Assume further that  <code class="reqn">{\bf p}</code> follows a Dirichlet prior distribution with parameters <code class="reqn">{\bm \alpha} = (\alpha_2,\ldots,\alpha_K)</code>. The posterior distribution of <code class="reqn">\bf p</code> still remains a Dirichlet distribution with parameters <code class="reqn">(\alpha_2+nr_2({\bf x}),\ldots,\alpha_K+nr_K({\bf x}))</code>.
</p>
<p>The BCVI is then defined as  <br />
</p>
<p style="text-align: center;"><code class="reqn">BCVI(k) = E[p_k|{\bf x}] = \frac{\alpha_k + nr_k({\bf x})}{\alpha_0+n}</code>
</p>

<p>where <code class="reqn">\alpha_0 = \sum_{k=2}^K \alpha_k.</code> <br />
</p>
<p>The variance of <code class="reqn">p_k</code> can be computed as
</p>
<p style="text-align: center;"><code class="reqn">Var(p_k|{\bf x}) = \dfrac{(\alpha_k + nr_k(x))(\alpha_0 + n -\alpha_k-nr_k(x))}{(\alpha_0 + n)^2(\alpha_0 + n +1 )}.</code>
</p>



<h3>Value</h3>

<table>
<tr><td><code>BCVI</code></td>
<td>
<p>the dataframe where the first and the second columns are the number of groups <code>k</code> and BCVI<code class="reqn">(k)</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
<tr><td><code>VAR</code></td>
<td>
<p>the data frame where the first and the second columns are the number of groups <code>k</code> and the variance of <code class="reqn">p_k</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
<tr><td><code>CVI</code></td>
<td>
<p>the data frame where the first and the second columns are the number of groups <code>k</code> and the original DI<code class="reqn">(k)</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>J. C. Dunn, &quot;A fuzzy relative of the ISODATA process and its use in detecting compact well-separated clusters,&quot; <em>J Cybern</em>, 3(3), 32-57 (1973).
</p>
<p>N. Wiroonsri, O. Preedasawakul, &quot;A Bayesian cluster validity index&quot;, arXiv:2402.02162, 2024.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+B2_data">B2_data</a>, <a href="#topic+B_TANG.IDX">B_TANG.IDX</a>, <a href="#topic+B_XB.IDX">B_XB.IDX</a>, <a href="#topic+B_Wvalid">B_Wvalid</a>, <a href="#topic+B_DB.IDX">B_DB.IDX</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(BayesCVI)

# The data included in this package.
data = B2_data[,1:2]

# alpha
aalpha = c(5,5,5,20,20,20,0.5,0.5,0.5)

B.DI = B_DI.IDX(x = scale(data), kmax=10, method = "kmeans",
                nstart = 100, alpha = aalpha, mult.alpha = 1/2)

# plot the BCVI

pplot = plot_BCVI(B.DI)
pplot$plot_index
pplot$plot_BCVI
pplot$error_bar_plot

</code></pre>

<hr>
<h2 id='B_GC.IDX'>
BCVI-The generalized C (GC) index
</h2><span id='topic+B_GC.IDX'></span>

<h3>Description</h3>

<p>Compute Bayesian cluster validity index (BCVI) from two to <code>kmax</code> groups using all or part of GC1 GC2 GC3 and GC4 as the underling cluster validity index (CVI) with the user's selected Dirichlet prior parameters. The full detail of BCVI can be found in the paper Wiroonsri and Preedasawakul (2024).</p>


<h3>Usage</h3>

<pre><code class='language-R'>B_GC.IDX(x, kmax, indexlist = "all", method = "FCM", fzm = 2, iter = 100,
        nstart = 20, alpha = "default", mult.alpha = 1/2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="B_GC.IDX_+3A_x">x</code></td>
<td>
<p>a numeric data frame or matrix where each column is a variable to be used for cluster analysis and each row is a data point.
</p>
</td></tr>
<tr><td><code id="B_GC.IDX_+3A_kmax">kmax</code></td>
<td>
<p>a maximum number of clusters to be considered.
</p>
</td></tr>
<tr><td><code id="B_GC.IDX_+3A_indexlist">indexlist</code></td>
<td>
<p>a character string indicating which The generalized C index be computed (&quot;<code>all</code>&quot;,&quot;<code>GC1</code>&quot;,&quot;<code>GC2</code>&quot;,&quot;<code>GC3</code>&quot;,&quot;<code>GC4</code>&quot;). More than one indexes can be selected.
</p>
</td></tr>
<tr><td><code id="B_GC.IDX_+3A_method">method</code></td>
<td>
<p>a character string indicating which clustering method to be used (<code>"FCM"</code> or <code>"EM"</code>). The default is <code>"FCM"</code>.
</p>
</td></tr>
<tr><td><code id="B_GC.IDX_+3A_fzm">fzm</code></td>
<td>
<p>a number greater than 1 giving the degree of fuzzification for <code>method = "FCM"</code>. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="B_GC.IDX_+3A_iter">iter</code></td>
<td>
<p>a maximum number of iterations for <code>method = "FCM"</code>. The default is <code>100</code>.
</p>
</td></tr>
<tr><td><code id="B_GC.IDX_+3A_nstart">nstart</code></td>
<td>
<p>a maximum number of initial random sets for FCM for <code>method = "FCM"</code>. The default is <code>20</code>.
</p>
</td></tr>
<tr><td><code id="B_GC.IDX_+3A_alpha">alpha</code></td>
<td>
<p>Dirichlet prior parameters <code class="reqn">\alpha_2,...,\alpha_k</code> where <code class="reqn">\alpha_k</code> is the parameter corresponding to &quot;the probability of having k groups&quot; (selecting each <code class="reqn">\alpha_k</code> between 0 to 30 is recommended and using the other parameter <code>mult.alpha</code> to be its multiplier. The default is <code>"default"</code>.)
</p>
</td></tr>
<tr><td><code id="B_GC.IDX_+3A_mult.alpha">mult.alpha</code></td>
<td>
<p>the power <code class="reqn">s</code> from <code class="reqn">n^s</code> to be multiplied to the Dirichlet prior parameters <code>alpha</code> (selecting <code>mult.alpha</code> in <code>[0,1)</code> is recommended). The default is <code class="reqn">\frac{1}{2}</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>BCVI-GC is defined as follows.
</p>
<p>Let <br />
</p>
<p style="text-align: center;"><code class="reqn">r_k(\bf x) = \dfrac{\max_j CVI(j)- CVI(k)}{\sum_{i=2}^K (\max_j CVI(j) - CVI(i))}.</code>
</p>

<p>where CVI is one of the GC1 GC2 GC3 or GC4 index. <br />
</p>
<p>Assume that <br />
</p>
<p style="text-align: center;"><code class="reqn">f({\bf x}|{\bf p}) = C({\bf p}) \prod_{k=2}^Kp_k^{nr_k(x)}</code>
</p>

<p>represents the conditional probability density function of the dataset given <code class="reqn">\bf p</code>, where <code class="reqn">C({\bf p})</code> is the normalizing constant. Assume further that  <code class="reqn">{\bf p}</code> follows a Dirichlet prior distribution with parameters <code class="reqn">{\bm \alpha} = (\alpha_2,\ldots,\alpha_K)</code>. The posterior distribution of <code class="reqn">\bf p</code> still remains a Dirichlet distribution with parameters <code class="reqn">(\alpha_2+nr_2({\bf x}),\ldots,\alpha_K+nr_K({\bf x}))</code>.
</p>
<p>The BCVI is then defined as  <br />
</p>
<p style="text-align: center;"><code class="reqn">BCVI(k) = E[p_k|{\bf x}] = \frac{\alpha_k + nr_k({\bf x})}{\alpha_0+n}</code>
</p>

<p>where <code class="reqn">\alpha_0 = \sum_{k=2}^K \alpha_k.</code> <br />
</p>
<p>The variance of <code class="reqn">p_k</code> can be computed as
</p>
<p style="text-align: center;"><code class="reqn">Var(p_k|{\bf x}) = \dfrac{(\alpha_k + nr_k(x))(\alpha_0 + n -\alpha_k-nr_k(x))}{(\alpha_0 + n)^2(\alpha_0 + n +1 )}.</code>
</p>



<h3>Value</h3>

<table>
<tr><td><code>BCVI</code></td>
<td>
<p>the dataframe where the first and the second columns are the number of groups <code>k</code> and BCVI<code class="reqn">(k)</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
<tr><td><code>VAR</code></td>
<td>
<p>the data frame where the first and the second columns are the number of groups <code>k</code> and the variance of <code class="reqn">p_k</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
<tr><td><code>CVI</code></td>
<td>
<p>the data frame where the first and the second columns are the number of groups <code>k</code> and the original GC1<code class="reqn">(k)</code> GC2<code class="reqn">(k)</code> GC3<code class="reqn">(k)</code> GC4<code class="reqn">(k)</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>J. C. Bezdek, M. Moshtaghi, T. Runkler, and C. Leckie, “The generalized
c index for internal fuzzy cluster validity,” IEEE Transactions on Fuzzy
Systems, vol. 24, no. 6, pp. 1500–1512, 2016. <a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=7429723&amp;isnumber=7797168">https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=7429723&amp;isnumber=7797168</a>
</p>
<p>N. Wiroonsri, O. Preedasawakul, &quot;A Bayesian cluster validity index&quot;, arXiv:2402.02162, 2024.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+B7_data">B7_data</a>, <a href="#topic+B_TANG.IDX">B_TANG.IDX</a>, <a href="#topic+B_XB.IDX">B_XB.IDX</a>, <a href="#topic+B_Wvalid">B_Wvalid</a>, <a href="#topic+B_DB.IDX">B_DB.IDX</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(BayesCVI)

# The data included in this package.
data = B7_data[,1:2]

# alpha
aalpha = c(5,5,5,20,20,20,0.5,0.5,0.5)

B.GC = B_GC.IDX(x = scale(data), kmax = 10, indexlist = "GC1",
              method = "FCM", fzm = 2, iter = 100,
                nstart = 20, alpha = aalpha, mult.alpha = 1/2)

# plot the BCVI-GC1

pplot = plot_BCVI(B.GC$GC1)
pplot$plot_index
pplot$plot_BCVI
pplot$error_bar_plot

</code></pre>

<hr>
<h2 id='B_HF.IDX'>
BCVI-HF index
</h2><span id='topic+B_HF.IDX'></span>

<h3>Description</h3>

<p>Compute Bayesian cluster validity index (BCVI) from two to <code>kmax</code> groups using HF as the underling cluster validity index (CVI) with the user's selected Dirichlet prior parameters. The full detail of BCVI can be found in the paper Wiroonsri and Preedasawakul (2024).</p>


<h3>Usage</h3>

<pre><code class='language-R'>B_HF.IDX(x, kmax, method = "FCM", fzm = 2, nstart = 20,
        iter = 100, alpha = "default", mult.alpha = 1/2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="B_HF.IDX_+3A_x">x</code></td>
<td>
<p>a numeric data frame or matrix where each column is a variable to be used for cluster analysis and each row is a data point.
</p>
</td></tr>
<tr><td><code id="B_HF.IDX_+3A_kmax">kmax</code></td>
<td>
<p>a maximum number of clusters to be considered.
</p>
</td></tr>
<tr><td><code id="B_HF.IDX_+3A_method">method</code></td>
<td>
<p>a character string indicating which clustering method to be used (<code>"FCM"</code> or <code>"EM"</code>). The default is <code>"FCM"</code>.
</p>
</td></tr>
<tr><td><code id="B_HF.IDX_+3A_fzm">fzm</code></td>
<td>
<p>a number greater than 1 giving the degree of fuzzification for <code>method = "FCM"</code>. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="B_HF.IDX_+3A_nstart">nstart</code></td>
<td>
<p>a maximum number of initial random sets for FCM for <code>method = "FCM"</code>. The default is <code>20</code>.
</p>
</td></tr>
<tr><td><code id="B_HF.IDX_+3A_iter">iter</code></td>
<td>
<p>a maximum number of iterations for <code>method = "FCM"</code>. The default is <code>100</code>.
</p>
</td></tr>
<tr><td><code id="B_HF.IDX_+3A_alpha">alpha</code></td>
<td>
<p>Dirichlet prior parameters <code class="reqn">\alpha_2,...,\alpha_k</code> where <code class="reqn">\alpha_k</code> is the parameter corresponding to &quot;the probability of having k groups&quot; (selecting each <code class="reqn">\alpha_k</code> between 0 to 30 is recommended and using the other parameter <code>mult.alpha</code> to be its multiplier. The default is <code>"default"</code>.)
</p>
</td></tr>
<tr><td><code id="B_HF.IDX_+3A_mult.alpha">mult.alpha</code></td>
<td>
<p>the power <code class="reqn">s</code> from <code class="reqn">n^s</code> to be multiplied to the Dirichlet prior parameters <code>alpha</code> (selecting <code>mult.alpha</code> in <code>[0,1)</code> is recommended). The default is <code class="reqn">\frac{1}{2}</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>BCVI-HF is defined as follows.
</p>
<p>Let <br />
</p>
<p style="text-align: center;"><code class="reqn">r_k(\bf x) = \dfrac{\max_j HF(j)- HF(k)}{\sum_{i=2}^K (\max_j HF(j) - HF(i))}.</code>
</p>

<p>Assume that <br />
</p>
<p style="text-align: center;"><code class="reqn">f({\bf x}|{\bf p}) = C({\bf p}) \prod_{k=2}^Kp_k^{nr_k(x)}</code>
</p>

<p>represents the conditional probability density function of the dataset given <code class="reqn">\bf p</code>, where <code class="reqn">C({\bf p})</code> is the normalizing constant. Assume further that  <code class="reqn">{\bf p}</code> follows a Dirichlet prior distribution with parameters <code class="reqn">{\bm \alpha} = (\alpha_2,\ldots,\alpha_K)</code>. The posterior distribution of <code class="reqn">\bf p</code> still remains a Dirichlet distribution with parameters <code class="reqn">(\alpha_2+nr_2({\bf x}),\ldots,\alpha_K+nr_K({\bf x}))</code>.
</p>
<p>The BCVI is then defined as  <br />
</p>
<p style="text-align: center;"><code class="reqn">BCVI(k) = E[p_k|{\bf x}] = \frac{\alpha_k + nr_k({\bf x})}{\alpha_0+n}</code>
</p>

<p>where <code class="reqn">\alpha_0 = \sum_{k=2}^K \alpha_k.</code> <br />
</p>
<p>The variance of <code class="reqn">p_k</code> can be computed as
</p>
<p style="text-align: center;"><code class="reqn">Var(p_k|{\bf x}) = \dfrac{(\alpha_k + nr_k(x))(\alpha_0 + n -\alpha_k-nr_k(x))}{(\alpha_0 + n)^2(\alpha_0 + n +1 )}.</code>
</p>



<h3>Value</h3>

<table>
<tr><td><code>BCVI</code></td>
<td>
<p>the dataframe where the first and the second columns are the number of groups <code>k</code> and BCVI<code class="reqn">(k)</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
<tr><td><code>VAR</code></td>
<td>
<p>the data frame where the first and the second columns are the number of groups <code>k</code> and the variance of <code class="reqn">p_k</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
<tr><td><code>CVI</code></td>
<td>
<p>the data frame where the first and the second columns are the number of groups <code>k</code> and the original HF<code class="reqn">(k)</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>F. Haouas, Z. Ben Dhiaf, A. Hammouda and B. Solaiman, &quot;A new efficient fuzzy cluster validity index: Application to images clustering,&quot; 2017 IEEE International Conference on Fuzzy Systems (FUZZ-IEEE), Naples, Italy, 2017, pp. 1-6.  <a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=8015651&amp;isnumber=8015374">https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=8015651&amp;isnumber=8015374</a>
</p>
<p>N. Wiroonsri, O. Preedasawakul, &quot;A Bayesian cluster validity index&quot;, arXiv:2402.02162, 2024.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+B7_data">B7_data</a>, <a href="#topic+B_TANG.IDX">B_TANG.IDX</a>, <a href="#topic+B_WP.IDX">B_WP.IDX</a>, <a href="#topic+B_Wvalid">B_Wvalid</a>, <a href="#topic+B_DB.IDX">B_DB.IDX</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(BayesCVI)

# The data included in this package.
data = B7_data[,1:2]

# alpha
aalpha = c(5,5,5,20,20,20,0.5,0.5,0.5)

B.HF = B_HF.IDX(x = scale(data), kmax =10, method = "FCM", fzm = 2,
              nstart = 20, iter = 100, alpha = aalpha, mult.alpha = 1/2)

# plot the BCVI

pplot = plot_BCVI(B.HF)
pplot$plot_index
pplot$plot_BCVI
pplot$error_bar_plot
</code></pre>

<hr>
<h2 id='B_KPBM.IDX'>
BCVI-Modified Kernel form of Pakhira-Bandyopadhyay-Maulik (KPBM) index
</h2><span id='topic+B_KPBM.IDX'></span>

<h3>Description</h3>

<p>Compute Bayesian cluster validity index (BCVI) from two to <code>kmax</code> groups using Modified Kernel form of Pakhira-Bandyopadhyay-Maulik (KPBM) as the underling cluster validity index (CVI) with the user's selected Dirichlet prior parameters. The full detail of BCVI can be found in the paper Wiroonsri and Preedasawakul (2024).</p>


<h3>Usage</h3>

<pre><code class='language-R'>B_KPBM.IDX(x, kmax, method = "FCM", fzm = 2, nstart = 20,
          iter = 100, alpha = "default", mult.alpha = 1/2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="B_KPBM.IDX_+3A_x">x</code></td>
<td>
<p>a numeric data frame or matrix where each column is a variable to be used for cluster analysis and each row is a data point.
</p>
</td></tr>
<tr><td><code id="B_KPBM.IDX_+3A_kmax">kmax</code></td>
<td>
<p>a maximum number of clusters to be considered.
</p>
</td></tr>
<tr><td><code id="B_KPBM.IDX_+3A_method">method</code></td>
<td>
<p>a character string indicating which clustering method to be used (<code>"FCM"</code> or <code>"EM"</code>). The default is <code>"FCM"</code>.
</p>
</td></tr>
<tr><td><code id="B_KPBM.IDX_+3A_fzm">fzm</code></td>
<td>
<p>a number greater than 1 giving the degree of fuzzification for <code>method = "FCM"</code>. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="B_KPBM.IDX_+3A_nstart">nstart</code></td>
<td>
<p>a maximum number of initial random sets for FCM for <code>method = "FCM"</code>. The default is <code>20</code>.
</p>
</td></tr>
<tr><td><code id="B_KPBM.IDX_+3A_iter">iter</code></td>
<td>
<p>a maximum number of iterations for <code>method = "FCM"</code>. The default is <code>100</code>.
</p>
</td></tr>
<tr><td><code id="B_KPBM.IDX_+3A_alpha">alpha</code></td>
<td>
<p>Dirichlet prior parameters <code class="reqn">\alpha_2,...,\alpha_k</code> where <code class="reqn">\alpha_k</code> is the parameter corresponding to &quot;the probability of having k groups&quot; (selecting each <code class="reqn">\alpha_k</code> between 0 to 30 is recommended and using the other parameter <code>mult.alpha</code> to be its multiplier. The default is <code>"default"</code>.
</p>
</td></tr>
<tr><td><code id="B_KPBM.IDX_+3A_mult.alpha">mult.alpha</code></td>
<td>
<p>the power <code class="reqn">s</code> from <code class="reqn">n^s</code> to be multiplied to the Dirichlet prior parameters <code>alpha</code> (selecting <code>mult.alpha</code> in <code>[0,1)</code> is recommended). The default is <code class="reqn">\frac{1}{2}</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>BCVI-KPBM is defined as follows.
Let <br />
</p>
<p style="text-align: center;"><code class="reqn">r_k(\bf x) = \dfrac{KPBM(k)-\min_j KPBM(j)}{\sum_{i=2}^K (KPBM(i)-\min_j KPBM(j))} </code>
</p>

<p>Assume that <br />
</p>
<p style="text-align: center;"><code class="reqn">f({\bf x}|{\bf p}) = C({\bf p}) \prod_{k=2}^Kp_k^{nr_k(x)}</code>
</p>

<p>represents the conditional probability density function of the dataset given <code class="reqn">\bf p</code>, where <code class="reqn">C({\bf p})</code> is the normalizing constant. Assume further that  <code class="reqn">{\bf p}</code> follows a Dirichlet prior distribution with parameters <code class="reqn">{\bm \alpha} = (\alpha_2,\ldots,\alpha_K)</code>. The posterior distribution of <code class="reqn">\bf p</code> still remains a Dirichlet distribution with parameters <code class="reqn">(\alpha_2+nr_2({\bf x}),\ldots,\alpha_K+nr_K({\bf x}))</code>.
</p>
<p>The BCVI is then defined as  <br />
</p>
<p style="text-align: center;"><code class="reqn">BCVI(k) = E[p_k|{\bf x}] = \frac{\alpha_k + nr_k({\bf x})}{\alpha_0+n}</code>
</p>

<p>where <code class="reqn">\alpha_0 = \sum_{k=2}^K \alpha_k.</code> <br />
</p>
<p>The variance of <code class="reqn">p_k</code> can be computed as
</p>
<p style="text-align: center;"><code class="reqn">Var(p_k|{\bf x}) = \dfrac{(\alpha_k + nr_k(x))(\alpha_0 + n -\alpha_k-nr_k(x))}{(\alpha_0 + n)^2(\alpha_0 + n +1 )}.</code>
</p>



<h3>Value</h3>

<table>
<tr><td><code>BCVI</code></td>
<td>
<p>the dataframe where the first and the second columns are the number of groups <code>k</code> and BCVI<code class="reqn">(k)</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
<tr><td><code>VAR</code></td>
<td>
<p>the data frame where the first and the second columns are the number of groups <code>k</code> and the variance of <code class="reqn">p_k</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
<tr><td><code>CVI</code></td>
<td>
<p>the data frame where the first and the second columns are the number of groups <code>k</code> and the original KPBM<code class="reqn">(k)</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>C. Alok. (2010). &quot;An investigation of clustering algorithms and soft computing approaches for pattern recognition,&quot; Department of Computer Science, Assam University. <a href="http://hdl.handle.net/10603/93443">http://hdl.handle.net/10603/93443</a>
</p>
<p>N. Wiroonsri, O. Preedasawakul, &quot;A Bayesian cluster validity index&quot;, arXiv:2402.02162, 2024.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+B7_data">B7_data</a>, <a href="#topic+B_TANG.IDX">B_TANG.IDX</a>, <a href="#topic+B_WP.IDX">B_WP.IDX</a>, <a href="#topic+B_Wvalid">B_Wvalid</a>, <a href="#topic+B_DB.IDX">B_DB.IDX</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(BayesCVI)

# The data included in this package.
data = B7_data[,1:2]

# alpha
aalpha = c(5,5,5,20,20,20,0.5,0.5,0.5)

B.KPBM = B_KPBM.IDX(x = scale(data), kmax =10, method = "FCM", fzm = 2, nstart = 20,
                iter = 100, alpha = aalpha, mult.alpha = 1/2)

# plot the BCVI

pplot = plot_BCVI(B.KPBM)
pplot$plot_index
pplot$plot_BCVI
pplot$error_bar_plot
</code></pre>

<hr>
<h2 id='B_KWON.IDX'>
BCVI-KWON index
</h2><span id='topic+B_KWON.IDX'></span>

<h3>Description</h3>

<p>Compute Bayesian cluster validity index (BCVI) from two to <code>kmax</code> groups using KWON as the underling cluster validity index (CVI) with the user's selected Dirichlet prior parameters. The full detail of BCVI can be found in the paper Wiroonsri and Preedasawakul (2024).</p>


<h3>Usage</h3>

<pre><code class='language-R'>B_KWON.IDX(x, kmax, method = "FCM", fzm = 2, nstart = 20,
          iter = 100, alpha = "default", mult.alpha = 1/2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="B_KWON.IDX_+3A_x">x</code></td>
<td>
<p>a numeric data frame or matrix where each column is a variable to be used for cluster analysis and each row is a data point.
</p>
</td></tr>
<tr><td><code id="B_KWON.IDX_+3A_kmax">kmax</code></td>
<td>
<p>a maximum number of clusters to be considered.
</p>
</td></tr>
<tr><td><code id="B_KWON.IDX_+3A_method">method</code></td>
<td>
<p>a character string indicating which clustering method to be used (<code>"FCM"</code> or <code>"EM"</code>). The default is <code>"FCM"</code>.
</p>
</td></tr>
<tr><td><code id="B_KWON.IDX_+3A_fzm">fzm</code></td>
<td>
<p>a number greater than 1 giving the degree of fuzzification for <code>method = "FCM"</code>. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="B_KWON.IDX_+3A_nstart">nstart</code></td>
<td>
<p>a maximum number of initial random sets for FCM for <code>method = "FCM"</code>. The default is <code>20</code>.
</p>
</td></tr>
<tr><td><code id="B_KWON.IDX_+3A_iter">iter</code></td>
<td>
<p>a maximum number of iterations for <code>method = "FCM"</code>. The default is <code>100</code>.
</p>
</td></tr>
<tr><td><code id="B_KWON.IDX_+3A_alpha">alpha</code></td>
<td>
<p>Dirichlet prior parameters <code class="reqn">\alpha_2,...,\alpha_k</code> where <code class="reqn">\alpha_k</code> is the parameter corresponding to &quot;the probability of having k groups&quot; (selecting each <code class="reqn">\alpha_k</code> between 0 to 30 is recommended and using the other parameter <code>mult.alpha</code> to be its multiplier. The default is <code>"default"</code>.)
</p>
</td></tr>
<tr><td><code id="B_KWON.IDX_+3A_mult.alpha">mult.alpha</code></td>
<td>
<p>the power <code class="reqn">s</code> from <code class="reqn">n^s</code> to be multiplied to the Dirichlet prior parameters <code>alpha</code> (selecting <code>mult.alpha</code> in <code>[0,1)</code> is recommended). The default is <code class="reqn">\frac{1}{2}</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>BCVI-KWON is defined as follows.
</p>
<p>Let <br />
</p>
<p style="text-align: center;"><code class="reqn">r_k(\bf x) = \dfrac{\max_j KWON(j)- KWON(k)}{\sum_{i=2}^K (\max_j KWON(j) - KWON(i))}.</code>
</p>

<p>Assume that <br />
</p>
<p style="text-align: center;"><code class="reqn">f({\bf x}|{\bf p}) = C({\bf p}) \prod_{k=2}^Kp_k^{nr_k(x)}</code>
</p>

<p>represents the conditional probability density function of the dataset given <code class="reqn">\bf p</code>, where <code class="reqn">C({\bf p})</code> is the normalizing constant. Assume further that  <code class="reqn">{\bf p}</code> follows a Dirichlet prior distribution with parameters <code class="reqn">{\bm \alpha} = (\alpha_2,\ldots,\alpha_K)</code>. The posterior distribution of <code class="reqn">\bf p</code> still remains a Dirichlet distribution with parameters <code class="reqn">(\alpha_2+nr_2({\bf x}),\ldots,\alpha_K+nr_K({\bf x}))</code>.
</p>
<p>The BCVI is then defined as  <br />
</p>
<p style="text-align: center;"><code class="reqn">BCVI(k) = E[p_k|{\bf x}] = \frac{\alpha_k + nr_k({\bf x})}{\alpha_0+n}</code>
</p>

<p>where <code class="reqn">\alpha_0 = \sum_{k=2}^K \alpha_k.</code> <br />
</p>
<p>The variance of <code class="reqn">p_k</code> can be computed as
</p>
<p style="text-align: center;"><code class="reqn">Var(p_k|{\bf x}) = \dfrac{(\alpha_k + nr_k(x))(\alpha_0 + n -\alpha_k-nr_k(x))}{(\alpha_0 + n)^2(\alpha_0 + n +1 )}.</code>
</p>



<h3>Value</h3>

<table>
<tr><td><code>BCVI</code></td>
<td>
<p>the dataframe where the first and the second columns are the number of groups <code>k</code> and BCVI<code class="reqn">(k)</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
<tr><td><code>VAR</code></td>
<td>
<p>the data frame where the first and the second columns are the number of groups <code>k</code> and the variance of <code class="reqn">p_k</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
<tr><td><code>CVI</code></td>
<td>
<p>the data frame where the first and the second columns are the number of groups <code>k</code> and the original KWON<code class="reqn">(k)</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>S. H. Kwon, “Cluster validity index for fuzzy clustering,” Electronics
letters, vol. 34, no. 22, pp. 2176–2177, 1998. <a href="https://doi.org/10.1049/el%3A19981523">doi:10.1049/el:19981523</a>
</p>
<p>N. Wiroonsri, O. Preedasawakul, &quot;A Bayesian cluster validity index&quot;, arXiv:2402.02162, 2024.
</p>


<h3>See Also</h3>

<p><a href="#topic+B7_data">B7_data</a>, <a href="#topic+B_TANG.IDX">B_TANG.IDX</a>, <a href="#topic+B_WP.IDX">B_WP.IDX</a>, <a href="#topic+B_Wvalid">B_Wvalid</a>, <a href="#topic+B_DB.IDX">B_DB.IDX</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(BayesCVI)

# The data included in this package.
data = B7_data[,1:2]

# alpha
aalpha = c(5,5,5,20,20,20,0.5,0.5,0.5)

B.KWON = B_KWON.IDX(x = scale(data), kmax =10, method = "FCM", fzm = 2, nstart = 20,
                    iter = 100, alpha = aalpha, mult.alpha = 1/2)

# plot the BCVI

pplot = plot_BCVI(B.KWON)
pplot$plot_index
pplot$plot_BCVI
pplot$error_bar_plot

</code></pre>

<hr>
<h2 id='B_KWON2.IDX'>
BCVI-KWON2 index
</h2><span id='topic+B_KWON2.IDX'></span>

<h3>Description</h3>

<p>Compute Bayesian cluster validity index (BCVI) from two to <code>kmax</code> groups using KWON2 as the underling cluster validity index (CVI) with the user's selected Dirichlet prior parameters. The full detail of BCVI can be found in the paper Wiroonsri and Preedasawakul (2024).</p>


<h3>Usage</h3>

<pre><code class='language-R'>B_KWON2.IDX(x, kmax, method = "FCM", fzm = 2, nstart = 20,
          iter = 100, alpha = "default", mult.alpha = 1/2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="B_KWON2.IDX_+3A_x">x</code></td>
<td>
<p>a numeric data frame or matrix where each column is a variable to be used for cluster analysis and each row is a data point.
</p>
</td></tr>
<tr><td><code id="B_KWON2.IDX_+3A_kmax">kmax</code></td>
<td>
<p>a maximum number of clusters to be considered.
</p>
</td></tr>
<tr><td><code id="B_KWON2.IDX_+3A_method">method</code></td>
<td>
<p>a character string indicating which clustering method to be used (<code>"FCM"</code> or <code>"EM"</code>). The default is <code>"FCM"</code>.
</p>
</td></tr>
<tr><td><code id="B_KWON2.IDX_+3A_fzm">fzm</code></td>
<td>
<p>a number greater than 1 giving the degree of fuzzification for <code>method = "FCM"</code>. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="B_KWON2.IDX_+3A_nstart">nstart</code></td>
<td>
<p>a maximum number of initial random sets for FCM for <code>method = "FCM"</code>. The default is <code>20</code>.
</p>
</td></tr>
<tr><td><code id="B_KWON2.IDX_+3A_iter">iter</code></td>
<td>
<p>a maximum number of iterations for <code>method = "FCM"</code>. The default is <code>100</code>.
</p>
</td></tr>
<tr><td><code id="B_KWON2.IDX_+3A_alpha">alpha</code></td>
<td>
<p>Dirichlet prior parameters <code class="reqn">\alpha_2,...,\alpha_k</code> where <code class="reqn">\alpha_k</code> is the parameter corresponding to &quot;the probability of having k groups&quot; (selecting each <code class="reqn">\alpha_k</code> between 0 to 30 is recommended and using the other parameter <code>mult.alpha</code> to be its multiplier. The default is <code>"default"</code>.)
</p>
</td></tr>
<tr><td><code id="B_KWON2.IDX_+3A_mult.alpha">mult.alpha</code></td>
<td>
<p>the power <code class="reqn">s</code> from <code class="reqn">n^s</code> to be multiplied to the Dirichlet prior parameters <code>alpha</code> (selecting <code>mult.alpha</code> in <code>[0,1)</code> is recommended). The default is <code class="reqn">\frac{1}{2}</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>BCVI-KWON2 is defined as follows.
</p>
<p>Let <br />
</p>
<p style="text-align: center;"><code class="reqn">r_k(\bf x) = \dfrac{\max_j KWON2(j)- KWON2(k)}{\sum_{i=2}^K (\max_j KWON2(j) - KWON2(i))}.</code>
</p>

<p>Assume that <br />
</p>
<p style="text-align: center;"><code class="reqn">f({\bf x}|{\bf p}) = C({\bf p}) \prod_{k=2}^Kp_k^{nr_k(x)}</code>
</p>

<p>represents the conditional probability density function of the dataset given <code class="reqn">\bf p</code>, where <code class="reqn">C({\bf p})</code> is the normalizing constant. Assume further that  <code class="reqn">{\bf p}</code> follows a Dirichlet prior distribution with parameters <code class="reqn">{\bm \alpha} = (\alpha_2,\ldots,\alpha_K)</code>. The posterior distribution of <code class="reqn">\bf p</code> still remains a Dirichlet distribution with parameters <code class="reqn">(\alpha_2+nr_2({\bf x}),\ldots,\alpha_K+nr_K({\bf x}))</code>.
</p>
<p>The BCVI is then defined as  <br />
</p>
<p style="text-align: center;"><code class="reqn">BCVI(k) = E[p_k|{\bf x}] = \frac{\alpha_k + nr_k({\bf x})}{\alpha_0+n}</code>
</p>

<p>where <code class="reqn">\alpha_0 = \sum_{k=2}^K \alpha_k.</code> <br />
</p>
<p>The variance of <code class="reqn">p_k</code> can be computed as
</p>
<p style="text-align: center;"><code class="reqn">Var(p_k|{\bf x}) = \dfrac{(\alpha_k + nr_k(x))(\alpha_0 + n -\alpha_k-nr_k(x))}{(\alpha_0 + n)^2(\alpha_0 + n +1 )}.</code>
</p>



<h3>Value</h3>

<table>
<tr><td><code>BCVI</code></td>
<td>
<p>the dataframe where the first and the second columns are the number of groups <code>k</code> and BCVI<code class="reqn">(k)</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
<tr><td><code>VAR</code></td>
<td>
<p>the data frame where the first and the second columns are the number of groups <code>k</code> and the variance of <code class="reqn">p_k</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
<tr><td><code>CVI</code></td>
<td>
<p>the data frame where the first and the second columns are the number of groups <code>k</code> and the original KWON2<code class="reqn">(k)</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>S. H. Kwon, J. Kim, and S. H. Son, “Improved cluster validity index
for fuzzy clustering,” Electronics Letters, vol. 57, no. 21, pp. 792–794,
2021.
</p>
<p>N. Wiroonsri, O. Preedasawakul, &quot;A Bayesian cluster validity index&quot;, arXiv:2402.02162, 2024.
</p>


<h3>See Also</h3>

<p><a href="#topic+B7_data">B7_data</a>, <a href="#topic+B_TANG.IDX">B_TANG.IDX</a>, <a href="#topic+B_WP.IDX">B_WP.IDX</a>, <a href="#topic+B_Wvalid">B_Wvalid</a>, <a href="#topic+B_DB.IDX">B_DB.IDX</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(BayesCVI)

# The data included in this package.
data = B7_data[,1:2]

# alpha
aalpha = c(5,5,5,20,20,20,0.5,0.5,0.5)

B.KWON2 = B_KWON2.IDX(x = scale(data), kmax =10, method = "FCM", fzm = 2,
                  nstart = 20, iter = 100, alpha = aalpha, mult.alpha = 1/2)

# plot the BCVI

pplot = plot_BCVI(B.KWON2)
pplot$plot_index
pplot$plot_BCVI
pplot$error_bar_plot
</code></pre>

<hr>
<h2 id='B_PB.IDX'>
BCVI-Point biserial correlation (PB)</h2><span id='topic+B_PB.IDX'></span>

<h3>Description</h3>

<p>Compute Bayesian cluster validity index (BCVI) from two to <code>kmax</code> groups using Point biserial correlation (PB) as the underling cluster validity index (CVI) with the user's selected Dirichlet prior parameters. The full detail of BCVI can be found in the paper Wiroonsri and Preedasawakul (2024).</p>


<h3>Usage</h3>

<pre><code class='language-R'>B_PB.IDX(x, kmax, method = "kmeans", corr = "pearson", nstart = 100,
        alpha = "default", mult.alpha = 1/2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="B_PB.IDX_+3A_x">x</code></td>
<td>
<p>a numeric data frame or matrix where each column is a variable to be used for cluster analysis and each row is a data point.
</p>
</td></tr>
<tr><td><code id="B_PB.IDX_+3A_kmax">kmax</code></td>
<td>
<p>a maximum number of clusters to be considered.
</p>
</td></tr>
<tr><td><code id="B_PB.IDX_+3A_method">method</code></td>
<td>
<p>a character string indicating which clustering method to be used (<code>"kmeans"</code>, <code>"hclust_complete"</code>, <code>"hclust_average"</code>, <code>"hclust_single"</code>). The default is <code>"kmeans"</code>.
</p>
</td></tr>
<tr><td><code id="B_PB.IDX_+3A_corr">corr</code></td>
<td>
<p>a character string indicating which correlation coefficient is to be computed (<code>"pearson"</code>, <code>"kendall"</code> or <code>"spearman"</code>). The default is <code>"pearson"</code>.
</p>
</td></tr>
<tr><td><code id="B_PB.IDX_+3A_nstart">nstart</code></td>
<td>
<p>a maximum number of initial random sets for kmeans for <code>method = "kmeans"</code>. The default is <code>100</code>.
</p>
</td></tr>
<tr><td><code id="B_PB.IDX_+3A_alpha">alpha</code></td>
<td>
<p>Dirichlet prior parameters <code class="reqn">\alpha_2,...,\alpha_k</code> where <code class="reqn">\alpha_k</code> is the parameter corresponding to &quot;the probability of having k groups&quot; (selecting each <code class="reqn">\alpha_k</code> between 0 to 30 is recommended and using the other parameter <code>mult.alpha</code> to be its multiplier. The default is <code>"default"</code>.)
</p>
</td></tr>
<tr><td><code id="B_PB.IDX_+3A_mult.alpha">mult.alpha</code></td>
<td>
<p>the power <code class="reqn">s</code> from <code class="reqn">n^s</code> to be multiplied to the Dirichlet prior parameters <code>alpha</code> (selecting <code>mult.alpha</code> in <code>[0,1)</code> is recommended). The default is <code class="reqn">\frac{1}{2}</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>BCVI-PB is defined as follows.
Let <br />
</p>
<p style="text-align: center;"><code class="reqn">r_k(\bf x) = \dfrac{PB(k)-\min_j PB(j)}{\sum_{i=2}^K (PB(i)-\min_j PB(j))} </code>
</p>

<p>Assume that <br />
</p>
<p style="text-align: center;"><code class="reqn">f({\bf x}|{\bf p}) = C({\bf p}) \prod_{k=2}^Kp_k^{nr_k(x)}</code>
</p>

<p>represents the conditional probability density function of the dataset given <code class="reqn">\bf p</code>, where <code class="reqn">C({\bf p})</code> is the normalizing constant. Assume further that  <code class="reqn">{\bf p}</code> follows a Dirichlet prior distribution with parameters <code class="reqn">{\bm \alpha} = (\alpha_2,\ldots,\alpha_K)</code>. The posterior distribution of <code class="reqn">\bf p</code> still remains a Dirichlet distribution with parameters <code class="reqn">(\alpha_2+nr_2({\bf x}),\ldots,\alpha_K+nr_K({\bf x}))</code>.
</p>
<p>The BCVI is then defined as  <br />
</p>
<p style="text-align: center;"><code class="reqn">BCVI(k) = E[p_k|{\bf x}] = \frac{\alpha_k + nr_k({\bf x})}{\alpha_0+n}</code>
</p>

<p>where <code class="reqn">\alpha_0 = \sum_{k=2}^K \alpha_k.</code> <br />
</p>
<p>The variance of <code class="reqn">p_k</code> can be computed as
</p>
<p style="text-align: center;"><code class="reqn">Var(p_k|{\bf x}) = \dfrac{(\alpha_k + nr_k(x))(\alpha_0 + n -\alpha_k-nr_k(x))}{(\alpha_0 + n)^2(\alpha_0 + n +1 )}.</code>
</p>



<h3>Value</h3>

<table>
<tr><td><code>BCVI</code></td>
<td>
<p>the dataframe where the first and the second columns are the number of groups <code>k</code> and BCVI<code class="reqn">(k)</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
<tr><td><code>VAR</code></td>
<td>
<p>the data frame where the first and the second columns are the number of groups <code>k</code> and the variance of <code class="reqn">p_k</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
<tr><td><code>CVI</code></td>
<td>
<p>the data frame where the first and the second columns are the number of groups <code>k</code> and the original PB<code class="reqn">(k)</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>G. W. Miligan, &quot;An examination of the effect of six types of error perturbation on fifteen clustering algorithms,&quot; <em>Psychometrika</em>, 45, 325-342 (1980).
</p>
<p>N. Wiroonsri, O. Preedasawakul, &quot;A Bayesian cluster validity index&quot;, arXiv:2402.02162, 2024.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+B2_data">B2_data</a>, <a href="#topic+B_TANG.IDX">B_TANG.IDX</a>, <a href="#topic+B_WP.IDX">B_WP.IDX</a>, <a href="#topic+B_Wvalid">B_Wvalid</a>, <a href="#topic+B_DB.IDX">B_DB.IDX</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(BayesCVI)

# The data included in this package.
data = B2_data[,1:2]

# alpha
aalpha = c(5,5,5,20,20,20,0.5,0.5,0.5)

B.PB = B_PB.IDX(x = scale(data), kmax=10, method = "kmeans", corr = "pearson", nstart = 100,
                alpha = aalpha, mult.alpha = 1/2)

# plot the BCVI

pplot = plot_BCVI(B.PB)
pplot$plot_index
pplot$plot_BCVI
pplot$error_bar_plot
</code></pre>

<hr>
<h2 id='B_PBM.IDX'>
BCVI-Pakhira-Bandyopadhyay-Maulik (PBM) index
</h2><span id='topic+B_PBM.IDX'></span>

<h3>Description</h3>

<p>Compute Bayesian cluster validity index (BCVI) from two to <code>kmax</code> groups using Pakhira-Bandyopadhyay-Maulik (PBM) as the underling cluster validity index (CVI) with the user's selected Dirichlet prior parameters. The full detail of BCVI can be found in the paper Wiroonsri and Preedasawakul (2024).</p>


<h3>Usage</h3>

<pre><code class='language-R'>B_PBM.IDX(x, kmax, method = "FCM", fzm = 2, nstart = 20,
        iter = 100, alpha = "default", mult.alpha = 1/2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="B_PBM.IDX_+3A_x">x</code></td>
<td>
<p>a numeric data frame or matrix where each column is a variable to be used for cluster analysis and each row is a data point.
</p>
</td></tr>
<tr><td><code id="B_PBM.IDX_+3A_kmax">kmax</code></td>
<td>
<p>a maximum number of clusters to be considered.
</p>
</td></tr>
<tr><td><code id="B_PBM.IDX_+3A_method">method</code></td>
<td>
<p>a character string indicating which clustering method to be used (<code>"FCM"</code> or <code>"EM"</code>). The default is <code>"FCM"</code>.
</p>
</td></tr>
<tr><td><code id="B_PBM.IDX_+3A_fzm">fzm</code></td>
<td>
<p>a number greater than 1 giving the degree of fuzzification for <code>method = "FCM"</code>. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="B_PBM.IDX_+3A_nstart">nstart</code></td>
<td>
<p>a maximum number of initial random sets for FCM for <code>method = "FCM"</code>. The default is <code>20</code>.
</p>
</td></tr>
<tr><td><code id="B_PBM.IDX_+3A_iter">iter</code></td>
<td>
<p>a maximum number of iterations for <code>method = "FCM"</code>. The default is <code>100</code>.
</p>
</td></tr>
<tr><td><code id="B_PBM.IDX_+3A_alpha">alpha</code></td>
<td>
<p>Dirichlet prior parameters <code class="reqn">\alpha_2,...,\alpha_k</code> where <code class="reqn">\alpha_k</code> is the parameter corresponding to &quot;the probability of having k groups&quot; (selecting each <code class="reqn">\alpha_k</code> between 0 to 30 is recommended and using the other parameter <code>mult.alpha</code> to be its multiplier. The default is <code>"default"</code>.
</p>
</td></tr>
<tr><td><code id="B_PBM.IDX_+3A_mult.alpha">mult.alpha</code></td>
<td>
<p>the power <code class="reqn">s</code> from <code class="reqn">n^s</code> to be multiplied to the Dirichlet prior parameters <code>alpha</code> (selecting <code>mult.alpha</code> in <code>[0,1)</code> is recommended). The default is <code class="reqn">\frac{1}{2}</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>BCVI-PBM is defined as follows.
Let <br />
</p>
<p style="text-align: center;"><code class="reqn">r_k(\bf x) = \dfrac{PBM(k)-\min_j PBM(j)}{\sum_{i=2}^K (PBM(i)-\min_j PBM(j))} </code>
</p>

<p>Assume that <br />
</p>
<p style="text-align: center;"><code class="reqn">f({\bf x}|{\bf p}) = C({\bf p}) \prod_{k=2}^Kp_k^{nr_k(x)}</code>
</p>

<p>represents the conditional probability density function of the dataset given <code class="reqn">\bf p</code>, where <code class="reqn">C({\bf p})</code> is the normalizing constant. Assume further that  <code class="reqn">{\bf p}</code> follows a Dirichlet prior distribution with parameters <code class="reqn">{\bm \alpha} = (\alpha_2,\ldots,\alpha_K)</code>. The posterior distribution of <code class="reqn">\bf p</code> still remains a Dirichlet distribution with parameters <code class="reqn">(\alpha_2+nr_2({\bf x}),\ldots,\alpha_K+nr_K({\bf x}))</code>.
</p>
<p>The BCVI is then defined as  <br />
</p>
<p style="text-align: center;"><code class="reqn">BCVI(k) = E[p_k|{\bf x}] = \frac{\alpha_k + nr_k({\bf x})}{\alpha_0+n}</code>
</p>

<p>where <code class="reqn">\alpha_0 = \sum_{k=2}^K \alpha_k.</code> <br />
</p>
<p>The variance of <code class="reqn">p_k</code> can be computed as
</p>
<p style="text-align: center;"><code class="reqn">Var(p_k|{\bf x}) = \dfrac{(\alpha_k + nr_k(x))(\alpha_0 + n -\alpha_k-nr_k(x))}{(\alpha_0 + n)^2(\alpha_0 + n +1 )}.</code>
</p>



<h3>Value</h3>

<table>
<tr><td><code>BCVI</code></td>
<td>
<p>the dataframe where the first and the second columns are the number of groups <code>k</code> and BCVI<code class="reqn">(k)</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
<tr><td><code>VAR</code></td>
<td>
<p>the data frame where the first and the second columns are the number of groups <code>k</code> and the variance of <code class="reqn">p_k</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
<tr><td><code>CVI</code></td>
<td>
<p>the data frame where the first and the second columns are the number of groups <code>k</code> and the original PBM<code class="reqn">(k)</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>M. K. Pakhira, S. Bandyopadhyay, and U. Maulik, “Validity index for crisp and fuzzy clusters,” Pattern recognition, vol. 37, no. 3, pp. 487–501, 2004.
</p>
<p>N. Wiroonsri, O. Preedasawakul, &quot;A Bayesian cluster validity index&quot;, arXiv:2402.02162, 2024.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+B7_data">B7_data</a>, <a href="#topic+B_TANG.IDX">B_TANG.IDX</a>, <a href="#topic+B_WP.IDX">B_WP.IDX</a>, <a href="#topic+B_Wvalid">B_Wvalid</a>, <a href="#topic+B_DB.IDX">B_DB.IDX</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(BayesCVI)

# The data included in this package.
data = B7_data[,1:2]

# alpha
aalpha = c(5,5,5,20,20,20,0.5,0.5,0.5)

B.PBM = B_PBM.IDX(x = scale(data), kmax =10, method = "FCM", fzm = 2, nstart = 20,
                iter = 100, alpha = aalpha, mult.alpha = 1/2)

# plot the BCVI

pplot = plot_BCVI(B.PBM)
pplot$plot_index
pplot$plot_BCVI
pplot$error_bar_plot
</code></pre>

<hr>
<h2 id='B_SF.IDX'>
BCVI-The score function
</h2><span id='topic+B_SF.IDX'></span>

<h3>Description</h3>

<p>Compute Bayesian cluster validity index (BCVI) from two to <code>kmax</code> groups using the score function (SF) as the underling cluster validity index (CVI) with the user's selected Dirichlet prior parameters. The full detail of BCVI can be found in the paper Wiroonsri and Preedasawakul (2024).</p>


<h3>Usage</h3>

<pre><code class='language-R'>B_SF.IDX(x, kmax, method = "kmeans", nstart = 100, alpha = "default", mult.alpha = 1/2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="B_SF.IDX_+3A_x">x</code></td>
<td>
<p>a numeric data frame or matrix where each column is a variable to be used for cluster analysis and each row is a data point.
</p>
</td></tr>
<tr><td><code id="B_SF.IDX_+3A_kmax">kmax</code></td>
<td>
<p>a maximum number of clusters to be considered.
</p>
</td></tr>
<tr><td><code id="B_SF.IDX_+3A_method">method</code></td>
<td>
<p>a character string indicating which clustering method to be used (<code>"kmeans"</code>, <code>"hclust_complete"</code>, <code>"hclust_average"</code>, <code>"hclust_single"</code>). The default is <code>"kmeans"</code>.
</p>
</td></tr>
<tr><td><code id="B_SF.IDX_+3A_nstart">nstart</code></td>
<td>
<p>a maximum number of initial random sets for kmeans for <code>method = "kmeans"</code>. The default is <code>100</code>.
</p>
</td></tr>
<tr><td><code id="B_SF.IDX_+3A_alpha">alpha</code></td>
<td>
<p>Dirichlet prior parameters <code class="reqn">\alpha_2,...,\alpha_k</code> where <code class="reqn">\alpha_k</code> is the parameter corresponding to &quot;the probability of having k groups&quot; (selecting each <code class="reqn">\alpha_k</code> between 0 to 30 is recommended and using the other parameter <code>mult.alpha</code> to be its multiplier. The default is <code>"default"</code>.
</p>
</td></tr>
<tr><td><code id="B_SF.IDX_+3A_mult.alpha">mult.alpha</code></td>
<td>
<p>the power <code class="reqn">s</code> from <code class="reqn">n^s</code> to be multiplied to the Dirichlet prior parameters <code>alpha</code> (selecting <code>mult.alpha</code> in <code>[0,1)</code> is recommended). The default is <code class="reqn">\frac{1}{2}</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>BCVI-SF is defined as follows.
</p>
<p>Let <br />
</p>
<p style="text-align: center;"><code class="reqn">r_k(\bf x) = \dfrac{\max_j SF(j)- SF(k)}{\sum_{i=2}^K (\max_j SF(j) - SF(i))}.</code>
</p>

<p>Assume that <br />
</p>
<p style="text-align: center;"><code class="reqn">f({\bf x}|{\bf p}) = C({\bf p}) \prod_{k=2}^Kp_k^{nr_k(x)}</code>
</p>

<p>represents the conditional probability density function of the dataset given <code class="reqn">\bf p</code>, where <code class="reqn">C({\bf p})</code> is the normalizing constant. Assume further that  <code class="reqn">{\bf p}</code> follows a Dirichlet prior distribution with parameters <code class="reqn">{\bm \alpha} = (\alpha_2,\ldots,\alpha_K)</code>. The posterior distribution of <code class="reqn">\bf p</code> still remains a Dirichlet distribution with parameters <code class="reqn">(\alpha_2+nr_2({\bf x}),\ldots,\alpha_K+nr_K({\bf x}))</code>.
</p>
<p>The BCVI is then defined as  <br />
</p>
<p style="text-align: center;"><code class="reqn">BCVI(k) = E[p_k|{\bf x}] = \frac{\alpha_k + nr_k({\bf x})}{\alpha_0+n}</code>
</p>

<p>where <code class="reqn">\alpha_0 = \sum_{k=2}^K \alpha_k.</code> <br />
</p>
<p>The variance of <code class="reqn">p_k</code> can be computed as
</p>
<p style="text-align: center;"><code class="reqn">Var(p_k|{\bf x}) = \dfrac{(\alpha_k + nr_k(x))(\alpha_0 + n -\alpha_k-nr_k(x))}{(\alpha_0 + n)^2(\alpha_0 + n +1 )}.</code>
</p>



<h3>Value</h3>

<table>
<tr><td><code>BCVI</code></td>
<td>
<p>the dataframe where the first and the second columns are the number of groups <code>k</code> and BCVI<code class="reqn">(k)</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
<tr><td><code>VAR</code></td>
<td>
<p>the data frame where the first and the second columns are the number of groups <code>k</code> and the variance of <code class="reqn">p_k</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
<tr><td><code>CVI</code></td>
<td>
<p>the data frame where the first and the second columns are the number of groups <code>k</code> and the original SF<code class="reqn">(k)</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>S. Saitta, B. Raphael, I. Smith, &quot;A bounded index for cluster validity,&quot; <em>In Perner, P.: Machine Learning and Data Mining in Pattern Recognition, Lecture Notes in Computer Science</em>, 4571, Springer (2007).
</p>
<p>N. Wiroonsri, O. Preedasawakul, &quot;A Bayesian cluster validity index&quot;, arXiv:2402.02162, 2024.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+B2_data">B2_data</a>, <a href="#topic+B_TANG.IDX">B_TANG.IDX</a>, <a href="#topic+B_WP.IDX">B_WP.IDX</a>, <a href="#topic+B_Wvalid">B_Wvalid</a>, <a href="#topic+B_DB.IDX">B_DB.IDX</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(BayesCVI)

# The data included in this package.
data = B2_data[,1:2]

# alpha
aalpha = c(5,5,5,20,20,20,0.5,0.5,0.5)

B.SF = B_SF.IDX(x = scale(data), kmax=10, method = "kmeans",
                nstart = 100, alpha = aalpha, mult.alpha = 1/2)

# plot the BCVI

pplot = plot_BCVI(B.SF)
pplot$plot_index
pplot$plot_BCVI
pplot$error_bar_plot
</code></pre>

<hr>
<h2 id='B_STRPBM.IDX'>
BCVI-Starczewski and Pakhira-Bandyopadhyay-Maulik for crisp clustering indexes
</h2><span id='topic+B_STRPBM.IDX'></span>

<h3>Description</h3>

<p>Compute Bayesian cluster validity index (BCVI) from two to <code>kmax</code> groups using Starczewski (STR) and/or Pakhira-Bandyopadhyay-Maulik (PBM) as the underlying cluster validity index (CVI) and Dirichlet prior parameters of the user's choice. The full detail of BCVI can be found in the paper Wiroonsri and Preedasawakul (2024).</p>


<h3>Usage</h3>

<pre><code class='language-R'>B_STRPBM.IDX(x, kmax, method = "kmeans", indexlist = "all",
          nstart = 100, alpha = "default", mult.alpha = 1/2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="B_STRPBM.IDX_+3A_x">x</code></td>
<td>
<p>a numeric data frame or matrix where each column is a variable to be used for cluster analysis and each row is a data point.
</p>
</td></tr>
<tr><td><code id="B_STRPBM.IDX_+3A_kmax">kmax</code></td>
<td>
<p>a maximum number of clusters to be considered.
</p>
</td></tr>
<tr><td><code id="B_STRPBM.IDX_+3A_method">method</code></td>
<td>
<p>a character string indicating which clustering method to be used (<code>"kmeans"</code>, <code>"hclust_complete"</code>, <code>"hclust_average"</code>, <code>"hclust_single"</code>). The default is <code>"kmeans"</code>.
</p>
</td></tr>
<tr><td><code id="B_STRPBM.IDX_+3A_indexlist">indexlist</code></td>
<td>
<p>a character string indicating which cluster validity indexes to be computed (<code>"all"</code>, <code>"STR"</code>, <code>"PBM"</code>). More than one indexes can be selected.
</p>
</td></tr>
<tr><td><code id="B_STRPBM.IDX_+3A_nstart">nstart</code></td>
<td>
<p>a maximum number of initial random sets for kmeans for <code>method = "kmeans"</code>. The default is <code>100</code>.
</p>
</td></tr>
<tr><td><code id="B_STRPBM.IDX_+3A_alpha">alpha</code></td>
<td>
<p>Dirichlet prior parameters <code class="reqn">\alpha_2,...,\alpha_k</code> where <code class="reqn">\alpha_k</code> is the parameter corresponding to &quot;the probability of having k groups&quot; (selecting each <code class="reqn">\alpha_k</code> between 0 to 30 is recommended and using the other parameter <code>mult.alpha</code> to be its multiplier. The default is <code>"default"</code>.)
</p>
</td></tr>
<tr><td><code id="B_STRPBM.IDX_+3A_mult.alpha">mult.alpha</code></td>
<td>
<p>the power <code class="reqn">s</code> from <code class="reqn">n^s</code> to be multiplied to the Dirichlet prior parameters <code>alpha</code> (selecting <code>mult.alpha</code> in <code>[0,1)</code> is recommended). The default is <code class="reqn">\frac{1}{2}</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>BCVI-STRPBM is defined as follows.
</p>
<p>Let <br />
</p>
<p style="text-align: center;"><code class="reqn">r_k(\bf x) = \dfrac{CVI(k)-\min_j CVI(j)}{\sum_{i=2}^K (CVI(i)-\min_j CVI(j))} </code>
</p>

<p>where CVI is either STR or PBM index. <br />
Assume that <br />
</p>
<p style="text-align: center;"><code class="reqn">f({\bf x}|{\bf p}) = C({\bf p}) \prod_{k=2}^Kp_k^{nr_k(x)}</code>
</p>

<p>represents the conditional probability density function of the dataset given <code class="reqn">\bf p</code>, where <code class="reqn">C({\bf p})</code> is the normalizing constant. Assume further that  <code class="reqn">{\bf p}</code> follows a Dirichlet prior distribution with parameters <code class="reqn">{\bm \alpha} = (\alpha_2,\ldots,\alpha_K)</code>. The posterior distribution of <code class="reqn">\bf p</code> still remains a Dirichlet distribution with parameters <code class="reqn">(\alpha_2+nr_2({\bf x}),\ldots,\alpha_K+nr_K({\bf x}))</code>.
</p>
<p>The BCVI is then defined as  <br />
</p>
<p style="text-align: center;"><code class="reqn">BCVI(k) = E[p_k|{\bf x}] = \frac{\alpha_k + nr_k({\bf x})}{\alpha_0+n}</code>
</p>

<p>where <code class="reqn">\alpha_0 = \sum_{k=2}^K \alpha_k.</code> <br />
</p>
<p>The variance of <code class="reqn">p_k</code> can be computed as
</p>
<p style="text-align: center;"><code class="reqn">Var(p_k|{\bf x}) = \dfrac{(\alpha_k + nr_k(x))(\alpha_0 + n -\alpha_k-nr_k(x))}{(\alpha_0 + n)^2(\alpha_0 + n +1 )}.</code>
</p>



<h3>Value</h3>

<table>
<tr><td><code>BCVI</code></td>
<td>
<p>the dataframe where the first and the second columns are the number of groups <code>k</code> and BCVI<code class="reqn">(k)</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
<tr><td><code>VAR</code></td>
<td>
<p>the data frame where the first and the second columns are the number of groups <code>k</code> and the variance of <code class="reqn">p_k</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
<tr><td><code>CVI</code></td>
<td>
<p>the data frame where the first and the second columns are the number of groups <code>k</code> and the original STR<code class="reqn">(k)</code> or PBM<code class="reqn">(k)</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>M. K. Pakhira, S. Bandyopadhyay and U. Maulik, &quot;Validity index for crisp and fuzzy clusters,&quot; <em>Pattern Recogn</em> 37(3):487–501 (2004).
</p>
<p>A. Starczewski, &quot;A new validity index for crisp clusters,&quot; <em>Pattern Anal Applic</em> 20, 687–700 (2017).
</p>
<p>N. Wiroonsri, O. Preedasawakul, &quot;A Bayesian cluster validity index&quot;, arXiv:2402.02162, 2024.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+B2_data">B2_data</a>, <a href="#topic+B_TANG.IDX">B_TANG.IDX</a>, <a href="#topic+B_WP.IDX">B_WP.IDX</a>, <a href="#topic+B_Wvalid">B_Wvalid</a>, <a href="#topic+B_DB.IDX">B_DB.IDX</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(BayesCVI)

# The data included in this package.
data = B2_data[,1:2]

# alpha
aalpha = c(5,5,5,20,20,20,0.5,0.5,0.5)

B.STRPBM = B_STRPBM.IDX(x = scale(data), kmax=10, method = "kmeans",
            indexlist = "all", nstart = 100, alpha = aalpha, mult.alpha = 1/2)

# plot the BCVI-STR

pplot = plot_BCVI(B.STRPBM$STR)
pplot$plot_index
pplot$plot_BCVI
pplot$error_bar_plot

# plot the BCVI-PBM

pplot = plot_BCVI(B.STRPBM$PBM)
pplot$plot_index
pplot$plot_BCVI
pplot$error_bar_plot
</code></pre>

<hr>
<h2 id='B_TANG.IDX'>
BCVI-Tang index
</h2><span id='topic+B_TANG.IDX'></span>

<h3>Description</h3>

<p>Compute Bayesian cluster validity index (BCVI) from two to <code>kmax</code> groups using Tang as the underling cluster validity index (CVI) with the user's selected Dirichlet prior parameters. The full detail of BCVI can be found in the paper Wiroonsri and Preedasawakul (2024).</p>


<h3>Usage</h3>

<pre><code class='language-R'>B_TANG.IDX(x, kmax, method = "FCM", fzm = 2, nstart = 20,
          iter = 100, alpha = "default", mult.alpha = 1/2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="B_TANG.IDX_+3A_x">x</code></td>
<td>
<p>a numeric data frame or matrix where each column is a variable to be used for cluster analysis and each row is a data point.
</p>
</td></tr>
<tr><td><code id="B_TANG.IDX_+3A_kmax">kmax</code></td>
<td>
<p>a maximum number of clusters to be considered.
</p>
</td></tr>
<tr><td><code id="B_TANG.IDX_+3A_method">method</code></td>
<td>
<p>a character string indicating which clustering method to be used (<code>"FCM"</code> or <code>"EM"</code>). The default is <code>"FCM"</code>.
</p>
</td></tr>
<tr><td><code id="B_TANG.IDX_+3A_fzm">fzm</code></td>
<td>
<p>a number greater than 1 giving the degree of fuzzification for <code>method = "FCM"</code>. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="B_TANG.IDX_+3A_nstart">nstart</code></td>
<td>
<p>a maximum number of initial random sets for FCM for <code>method = "FCM"</code>. The default is <code>20</code>.
</p>
</td></tr>
<tr><td><code id="B_TANG.IDX_+3A_iter">iter</code></td>
<td>
<p>a maximum number of iterations for <code>method = "FCM"</code>. The default is <code>100</code>.
</p>
</td></tr>
<tr><td><code id="B_TANG.IDX_+3A_alpha">alpha</code></td>
<td>
<p>Dirichlet prior parameters <code class="reqn">\alpha_2,...,\alpha_k</code> where <code class="reqn">\alpha_k</code> is the parameter corresponding to &quot;the probability of having k groups&quot; (selecting each <code class="reqn">\alpha_k</code> between 0 to 30 is recommended and using the other parameter <code>mult.alpha</code> to be its multiplier. The default is <code>"default"</code>.)
</p>
</td></tr>
<tr><td><code id="B_TANG.IDX_+3A_mult.alpha">mult.alpha</code></td>
<td>
<p>the power <code class="reqn">s</code> from <code class="reqn">n^s</code> to be multiplied to the Dirichlet prior parameters <code>alpha</code> (selecting <code>mult.alpha</code> in <code>[0,1)</code> is recommended). The default is <code class="reqn">\frac{1}{2}</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>BCVI-TANG is defined as follows.
</p>
<p>Let <br />
</p>
<p style="text-align: center;"><code class="reqn">r_k(\bf x) = \dfrac{\max_j TANG(j)- TANG(k)}{\sum_{i=2}^K (\max_j TANG(j) - TANG(i))}.</code>
</p>

<p>Assume that <br />
</p>
<p style="text-align: center;"><code class="reqn">f({\bf x}|{\bf p}) = C({\bf p}) \prod_{k=2}^Kp_k^{nr_k(x)}</code>
</p>

<p>represents the conditional probability density function of the dataset given <code class="reqn">\bf p</code>, where <code class="reqn">C({\bf p})</code> is the normalizing constant. Assume further that  <code class="reqn">{\bf p}</code> follows a Dirichlet prior distribution with parameters <code class="reqn">{\bm \alpha} = (\alpha_2,\ldots,\alpha_K)</code>. The posterior distribution of <code class="reqn">\bf p</code> still remains a Dirichlet distribution with parameters <code class="reqn">(\alpha_2+nr_2({\bf x}),\ldots,\alpha_K+nr_K({\bf x}))</code>.
</p>
<p>The BCVI is then defined as  <br />
</p>
<p style="text-align: center;"><code class="reqn">BCVI(k) = E[p_k|{\bf x}] = \frac{\alpha_k + nr_k({\bf x})}{\alpha_0+n}</code>
</p>

<p>where <code class="reqn">\alpha_0 = \sum_{k=2}^K \alpha_k.</code> <br />
</p>
<p>The variance of <code class="reqn">p_k</code> can be computed as
</p>
<p style="text-align: center;"><code class="reqn">Var(p_k|{\bf x}) = \dfrac{(\alpha_k + nr_k(x))(\alpha_0 + n -\alpha_k-nr_k(x))}{(\alpha_0 + n)^2(\alpha_0 + n +1 )}.</code>
</p>



<h3>Value</h3>

<table>
<tr><td><code>BCVI</code></td>
<td>
<p>the dataframe where the first and the second columns are the number of groups <code>k</code> and BCVI<code class="reqn">(k)</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
<tr><td><code>VAR</code></td>
<td>
<p>the data frame where the first and the second columns are the number of groups <code>k</code> and the variance of <code class="reqn">p_k</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
<tr><td><code>CVI</code></td>
<td>
<p>the data frame where the first and the second columns are the number of groups <code>k</code> and the original TANG<code class="reqn">(k)</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>Y. Tang, F. Sun, and Z. Sun, “Improved validation index for fuzzy clustering,” in Proceedings of the 2005, American Control Conference, 2005., pp. 1120–1125 vol. 2, 2005. <a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=1470111&amp;isnumber=31519">https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=1470111&amp;isnumber=31519</a>
</p>
<p>N. Wiroonsri, O. Preedasawakul, &quot;A Bayesian cluster validity index&quot;, arXiv:2402.02162, 2024.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+B7_data">B7_data</a>, <a href="#topic+B_DI.IDX">B_DI.IDX</a>, <a href="#topic+B_WP.IDX">B_WP.IDX</a>, <a href="#topic+B_Wvalid">B_Wvalid</a>, <a href="#topic+B_DB.IDX">B_DB.IDX</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(BayesCVI)

# The data included in this package.
data = B7_data[,1:2]

# alpha
aalpha = c(5,5,5,20,20,20,0.5,0.5,0.5)

B.TANG = B_TANG.IDX(x = scale(data), kmax =10, method = "FCM", fzm = 2,
                  nstart = 20, iter = 100, alpha = aalpha, mult.alpha = 1/2)

# plot the BCVI

pplot = plot_BCVI(B.TANG)
pplot$plot_index
pplot$plot_BCVI
pplot$error_bar_plot
</code></pre>

<hr>
<h2 id='B_WL.IDX'>
BCVI-Wu and Li (WL) index
</h2><span id='topic+B_WL.IDX'></span>

<h3>Description</h3>

<p>Compute Bayesian cluster validity index (BCVI) from two to <code>kmax</code> groups using Wu and Li (WL) as the underling cluster validity index (CVI) with the user's selected Dirichlet prior parameters. The full detail of BCVI can be found in the paper Wiroonsri and Preedasawakul (2024).</p>


<h3>Usage</h3>

<pre><code class='language-R'>B_WL.IDX(x, kmax, method = "FCM", fzm = 2, nstart = 20,
        iter = 100, alpha = "default", mult.alpha = 1/2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="B_WL.IDX_+3A_x">x</code></td>
<td>
<p>a numeric data frame or matrix where each column is a variable to be used for cluster analysis and each row is a data point.
</p>
</td></tr>
<tr><td><code id="B_WL.IDX_+3A_kmax">kmax</code></td>
<td>
<p>a maximum number of clusters to be considered.
</p>
</td></tr>
<tr><td><code id="B_WL.IDX_+3A_method">method</code></td>
<td>
<p>a character string indicating which clustering method to be used (<code>"FCM"</code> or <code>"EM"</code>). The default is <code>"FCM"</code>.
</p>
</td></tr>
<tr><td><code id="B_WL.IDX_+3A_fzm">fzm</code></td>
<td>
<p>a number greater than 1 giving the degree of fuzzification for <code>method = "FCM"</code>. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="B_WL.IDX_+3A_nstart">nstart</code></td>
<td>
<p>a maximum number of initial random sets for FCM for <code>method = "FCM"</code>. The default is <code>20</code>.
</p>
</td></tr>
<tr><td><code id="B_WL.IDX_+3A_iter">iter</code></td>
<td>
<p>a maximum number of iterations for <code>method = "FCM"</code>. The default is <code>100</code>.
</p>
</td></tr>
<tr><td><code id="B_WL.IDX_+3A_alpha">alpha</code></td>
<td>
<p>Dirichlet prior parameters <code class="reqn">\alpha_2,...,\alpha_k</code> where <code class="reqn">\alpha_k</code> is the parameter corresponding to &quot;the probability of having k groups&quot; (selecting each <code class="reqn">\alpha_k</code> between 0 to 30 is recommended and using the other parameter <code>mult.alpha</code> to be its multiplier. The default is <code>"default"</code>.)
</p>
</td></tr>
<tr><td><code id="B_WL.IDX_+3A_mult.alpha">mult.alpha</code></td>
<td>
<p>the power <code class="reqn">s</code> from <code class="reqn">n^s</code> to be multiplied to the Dirichlet prior parameters <code>alpha</code> (selecting <code>mult.alpha</code> in <code>[0,1)</code> is recommended). The default is <code class="reqn">\frac{1}{2}</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>BCVI-WL is defined as follows.
</p>
<p>Let <br />
</p>
<p style="text-align: center;"><code class="reqn">r_k(\bf x) = \dfrac{\max_j WL(j)- WL(k)}{\sum_{i=2}^K (\max_j WL(j) - WL(i))}.</code>
</p>

<p>Assume that <br />
</p>
<p style="text-align: center;"><code class="reqn">f({\bf x}|{\bf p}) = C({\bf p}) \prod_{k=2}^Kp_k^{nr_k(x)}</code>
</p>

<p>represents the conditional probability density function of the dataset given <code class="reqn">\bf p</code>, where <code class="reqn">C({\bf p})</code> is the normalizing constant. Assume further that  <code class="reqn">{\bf p}</code> follows a Dirichlet prior distribution with parameters <code class="reqn">{\bm \alpha} = (\alpha_2,\ldots,\alpha_K)</code>. The posterior distribution of <code class="reqn">\bf p</code> still remains a Dirichlet distribution with parameters <code class="reqn">(\alpha_2+nr_2({\bf x}),\ldots,\alpha_K+nr_K({\bf x}))</code>.
</p>
<p>The BCVI is then defined as  <br />
</p>
<p style="text-align: center;"><code class="reqn">BCVI(k) = E[p_k|{\bf x}] = \frac{\alpha_k + nr_k({\bf x})}{\alpha_0+n}</code>
</p>

<p>where <code class="reqn">\alpha_0 = \sum_{k=2}^K \alpha_k.</code> <br />
</p>
<p>The variance of <code class="reqn">p_k</code> can be computed as
</p>
<p style="text-align: center;"><code class="reqn">Var(p_k|{\bf x}) = \dfrac{(\alpha_k + nr_k(x))(\alpha_0 + n -\alpha_k-nr_k(x))}{(\alpha_0 + n)^2(\alpha_0 + n +1 )}.</code>
</p>



<h3>Value</h3>

<table>
<tr><td><code>BCVI</code></td>
<td>
<p>the dataframe where the first and the second columns are the number of groups <code>k</code> and BCVI<code class="reqn">(k)</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
<tr><td><code>VAR</code></td>
<td>
<p>the data frame where the first and the second columns are the number of groups <code>k</code> and the variance of <code class="reqn">p_k</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
<tr><td><code>CVI</code></td>
<td>
<p>the data frame where the first and the second columns are the number of groups <code>k</code> and the original WL<code class="reqn">(k)</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul</p>


<h3>References</h3>

<p>C. H. Wu, C. S. Ouyang, L. W. Chen, and L. W. Lu, “A new
fuzzy clustering validity index with a median factor for centroid-based clustering,” IEEE Transactions on Fuzzy Systems, vol. 23, no. 3, pp. 701–718, 2015.<a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=6811211&amp;isnumber=7115244">https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=6811211&amp;isnumber=7115244</a>
</p>
<p>N. Wiroonsri, O. Preedasawakul, &quot;A Bayesian cluster validity index&quot;, arXiv:2402.02162, 2024.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+B7_data">B7_data</a>, <a href="#topic+B_TANG.IDX">B_TANG.IDX</a>, <a href="#topic+B_WP.IDX">B_WP.IDX</a>, <a href="#topic+B_Wvalid">B_Wvalid</a>, <a href="#topic+B_DB.IDX">B_DB.IDX</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(BayesCVI)

# The data included in this package.
data = B7_data[,1:2]

# alpha
aalpha = c(5,5,5,20,20,20,0.5,0.5,0.5)

B.WL = B_WL.IDX(x = scale(data), kmax =10, method = "FCM", fzm = 2,
              nstart = 20, iter = 100, alpha = aalpha, mult.alpha = 1/2)

# plot the BCVI

pplot = plot_BCVI(B.WL)
pplot$plot_index
pplot$plot_BCVI
pplot$error_bar_plot
</code></pre>

<hr>
<h2 id='B_WP.IDX'>
BCVI-Wiroonsri and Preedasawakul (WP) index
</h2><span id='topic+B_WP.IDX'></span>

<h3>Description</h3>

<p>Compute Bayesian cluster validity index (BCVI) from two to <code>kmax</code> groups using Wiroonsri and Preedasawakul (WP) as the underling cluster validity index (CVI) with the user's selected Dirichlet prior parameters. The full detail of BCVI can be found in the paper Wiroonsri and Preedasawakul (2024).</p>


<h3>Usage</h3>

<pre><code class='language-R'>B_WP.IDX(x, kmax, corr = "pearson", method = "FCM", fzm = 2,
        gamma = (fzm^2 * 7)/4, sampling = 1, iter = 100, nstart = 20,
        NCstart = TRUE, alpha = "default", mult.alpha = 1/2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="B_WP.IDX_+3A_x">x</code></td>
<td>
<p>a numeric data frame or matrix where each column is a variable to be used for cluster analysis and each row is a data point.
</p>
</td></tr>
<tr><td><code id="B_WP.IDX_+3A_kmax">kmax</code></td>
<td>
<p>a maximum number of clusters to be considered.
</p>
</td></tr>
<tr><td><code id="B_WP.IDX_+3A_corr">corr</code></td>
<td>
<p>a character string indicating which correlation coefficient is to be computed (<code>"pearson"</code>, <code>"kendall"</code> or <code>"spearman"</code>). The default is <code>"pearson"</code>.
</p>
</td></tr>
<tr><td><code id="B_WP.IDX_+3A_method">method</code></td>
<td>
<p>a character string indicating which clustering method to be used (<code>"FCM"</code> or <code>"EM"</code>). The default is <code>"FCM"</code>.
</p>
</td></tr>
<tr><td><code id="B_WP.IDX_+3A_fzm">fzm</code></td>
<td>
<p>a number greater than 1 giving the degree of fuzzification for <code>method = "FCM"</code>. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="B_WP.IDX_+3A_gamma">gamma</code></td>
<td>
<p>adjusted fuzziness parameter for <code>indexlist</code> = (<code>"WP"</code>, <code>"WPC"</code>, <code>"WPCI1"</code>, <code>"WPCI2"</code>). The default is computed from <code class="reqn">7fzm^2/4</code>.
</p>
</td></tr>
<tr><td><code id="B_WP.IDX_+3A_sampling">sampling</code></td>
<td>
<p>a number greater than 0 and less than or equal to 1 indicating the undersampling proportion of data to be used. This argument is intended for handling a large dataset. The default is <code>1</code>.
</p>
</td></tr>
<tr><td><code id="B_WP.IDX_+3A_iter">iter</code></td>
<td>
<p>a maximum number of iterations for <code>method = "FCM"</code>. The default is <code>100</code>.
</p>
</td></tr>
<tr><td><code id="B_WP.IDX_+3A_nstart">nstart</code></td>
<td>
<p>a maximum number of initial random sets for FCM for <code>method = "FCM"</code>. The default is <code>20</code>.
</p>
</td></tr>
<tr><td><code id="B_WP.IDX_+3A_ncstart">NCstart</code></td>
<td>
<p>logical for <code>indexlist</code> = (<code>"WP"</code>, <code>"WPC"</code>, <code>"WPCI1"</code>,<code>"WPCI2"</code>), if <code>TRUE</code>, the WP correlation at c=1 is defined as an adjusted sd of the distances between all data points and their mean. Otherwise, the WP correlation at c=1 is defined as 0.
</p>
</td></tr>
<tr><td><code id="B_WP.IDX_+3A_alpha">alpha</code></td>
<td>
<p>Dirichlet prior parameters <code class="reqn">\alpha_2,...,\alpha_k</code> where <code class="reqn">\alpha_k</code> is the parameter corresponding to &quot;the probability of having k groups&quot; (selecting each <code class="reqn">\alpha_k</code> between 0 to 30 is recommended and using the other parameter <code>mult.alpha</code> to be its multiplier. The default is <code>"default"</code>.)
</p>
</td></tr>
<tr><td><code id="B_WP.IDX_+3A_mult.alpha">mult.alpha</code></td>
<td>
<p>the power <code class="reqn">s</code> from <code class="reqn">n^s</code> to be multiplied to the Dirichlet prior parameters <code>alpha</code> (selecting <code>mult.alpha</code> in <code>[0,1)</code> is recommended). The default is <code class="reqn">\frac{1}{2}</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>BCVI-WP is defined as follows.
Let <br />
</p>
<p style="text-align: center;"><code class="reqn">r_k(\bf x) = \dfrac{WP(k)-\min_j WP(j)}{\sum_{i=2}^K (WP(i)-\min_j WP(j))} </code>
</p>

<p>Assume that <br />
</p>
<p style="text-align: center;"><code class="reqn">f({\bf x}|{\bf p}) = C({\bf p}) \prod_{k=2}^Kp_k^{nr_k(x)}</code>
</p>

<p>represents the conditional probability density function of the dataset given <code class="reqn">\bf p</code>, where <code class="reqn">C({\bf p})</code> is the normalizing constant. Assume further that  <code class="reqn">{\bf p}</code> follows a Dirichlet prior distribution with parameters <code class="reqn">{\bm \alpha} = (\alpha_2,\ldots,\alpha_K)</code>. The posterior distribution of <code class="reqn">\bf p</code> still remains a Dirichlet distribution with parameters <code class="reqn">(\alpha_2+nr_2({\bf x}),\ldots,\alpha_K+nr_K({\bf x}))</code>.
</p>
<p>The BCVI is then defined as  <br />
</p>
<p style="text-align: center;"><code class="reqn">BCVI(k) = E[p_k|{\bf x}] = \frac{\alpha_k + nr_k({\bf x})}{\alpha_0+n}</code>
</p>

<p>where <code class="reqn">\alpha_0 = \sum_{k=2}^K \alpha_k.</code> <br />
</p>
<p>The variance of <code class="reqn">p_k</code> can be computed as
</p>
<p style="text-align: center;"><code class="reqn">Var(p_k|{\bf x}) = \dfrac{(\alpha_k + nr_k(x))(\alpha_0 + n -\alpha_k-nr_k(x))}{(\alpha_0 + n)^2(\alpha_0 + n +1 )}.</code>
</p>



<h3>Value</h3>

<table>
<tr><td><code>BCVI</code></td>
<td>
<p>the dataframe where the first and the second columns are the number of groups <code>k</code> and BCVI<code class="reqn">(k)</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
<tr><td><code>VAR</code></td>
<td>
<p>the data frame where the first and the second columns are the number of groups <code>k</code> and the variance of <code class="reqn">p_k</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
<tr><td><code>CVI</code></td>
<td>
<p>the data frame where the first and the second columns are the number of groups <code>k</code> and the original WP<code class="reqn">(k)</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>N. Wiroonsri, O. Preedasawakul, &quot;A correlation-based fuzzy cluster validity index with secondary options detector,&quot; arXiv:2308.14785, 2023
</p>
<p>N. Wiroonsri, O. Preedasawakul, &quot;A Bayesian cluster validity index&quot;, arXiv:2402.02162, 2024.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+B7_data">B7_data</a>, <a href="#topic+B_TANG.IDX">B_TANG.IDX</a>, <a href="#topic+B_XB.IDX">B_XB.IDX</a>, <a href="#topic+B_Wvalid">B_Wvalid</a>, <a href="#topic+B_DB.IDX">B_DB.IDX</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(BayesCVI)

# The data included in this package.
data = B7_data[,1:2]

# alpha
aalpha = c(20,20,20,5,5,5,0.5,0.5,0.5)

B.WP = B_WP.IDX(x = scale(data), kmax =10, corr = "pearson", method = "FCM",
                fzm = 2, sampling = 1, iter = 100, nstart = 20, NCstart = TRUE,
                alpha = aalpha, mult.alpha = 1/2)

# plot the BCVI

pplot = plot_BCVI(B.WP)
pplot$plot_index
pplot$plot_BCVI
pplot$error_bar_plot
</code></pre>

<hr>
<h2 id='B_Wvalid'>
BCVI-Wiroonsri (WI) index
</h2><span id='topic+B_Wvalid'></span>

<h3>Description</h3>

<p>Compute Bayesian cluster validity index (BCVI) from two to <code>kmax</code> groups using Wiroonsri (WI) as the underling cluster validity index (CVI) with the user's selected Dirichlet prior parameters. The full detail of BCVI can be found in the paper Wiroonsri and Preedasawakul (2024).</p>


<h3>Usage</h3>

<pre><code class='language-R'>B_Wvalid(x, kmax, method = "kmeans", corr = "pearson", nstart = 100,
      sampling = 1, NCstart = TRUE, alpha = "default", mult.alpha = 1/2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="B_Wvalid_+3A_x">x</code></td>
<td>
<p>a numeric data frame or matrix where each column is a variable to be used for cluster analysis and each row is a data point.
</p>
</td></tr>
<tr><td><code id="B_Wvalid_+3A_kmax">kmax</code></td>
<td>
<p>a maximum number of clusters to be considered.
</p>
</td></tr>
<tr><td><code id="B_Wvalid_+3A_method">method</code></td>
<td>
<p>a character string indicating which clustering method to be used (<code>"kmeans"</code>, <code>"hclust_complete"</code>, <code>"hclust_average"</code>, <code>"hclust_single"</code>). The default is <code>"kmeans"</code>.
</p>
</td></tr>
<tr><td><code id="B_Wvalid_+3A_corr">corr</code></td>
<td>
<p>a character string indicating which correlation coefficient is to be computed (<code>"pearson"</code>, <code>"kendall"</code> or <code>"spearman"</code>). The default is <code>"pearson"</code>.
</p>
</td></tr>
<tr><td><code id="B_Wvalid_+3A_nstart">nstart</code></td>
<td>
<p>a maximum number of initial random sets for kmeans for <code>method = "kmeans"</code>. The default is <code>100</code>.
</p>
</td></tr>
<tr><td><code id="B_Wvalid_+3A_sampling">sampling</code></td>
<td>
<p>a number greater than 0 and less than or equal to 1 indicating the undersampling proportion of data to be used. This argument is intended for handling a large dataset. The default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="B_Wvalid_+3A_ncstart">NCstart</code></td>
<td>
<p>logical for <code>indexlist</code> includes the <code>"NC"</code>, <code>"NCI"</code>, <code>"NCI1"</code>, and <code>"NCI2"</code>), if <code>TRUE</code>, the NC correlation at <code>k=1</code> is defined as the ratio introduced in the reference. Otherwise, it is assigned as <code>0</code>.
</p>
</td></tr>
<tr><td><code id="B_Wvalid_+3A_alpha">alpha</code></td>
<td>
<p>Dirichlet prior parameters <code class="reqn">\alpha_2,...,\alpha_k</code> where <code class="reqn">\alpha_k</code> is the parameter corresponding to &quot;the probability of having k groups&quot; (selecting each <code class="reqn">\alpha_k</code> between 0 to 30 is recommended and using the other parameter <code>mult.alpha</code> to be its multiplier. The default is <code>"default"</code>.
</p>
</td></tr>
<tr><td><code id="B_Wvalid_+3A_mult.alpha">mult.alpha</code></td>
<td>
<p>the power <code class="reqn">s</code> from <code class="reqn">n^s</code> to be multiplied to the Dirichlet prior parameters <code>alpha</code> (selecting <code>mult.alpha</code> in <code>[0,1)</code> is recommended). The default is <code class="reqn">\frac{1}{2}</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>BCVI-WI is defined as follows.
Let <br />
</p>
<p style="text-align: center;"><code class="reqn">r_k(\bf x) = \dfrac{WI(k)-\min_j WI(j)}{\sum_{i=2}^K (WI(i)-\min_j WI(j))} </code>
</p>

<p>Assume that <br />
</p>
<p style="text-align: center;"><code class="reqn">f({\bf x}|{\bf p}) = C({\bf p}) \prod_{k=2}^Kp_k^{nr_k(x)}</code>
</p>

<p>represents the conditional probability density function of the dataset given <code class="reqn">\bf p</code>, where <code class="reqn">C({\bf p})</code> is the normalizing constant. Assume further that  <code class="reqn">{\bf p}</code> follows a Dirichlet prior distribution with parameters <code class="reqn">{\bm \alpha} = (\alpha_2,\ldots,\alpha_K)</code>. The posterior distribution of <code class="reqn">\bf p</code> still remains a Dirichlet distribution with parameters <code class="reqn">(\alpha_2+nr_2({\bf x}),\ldots,\alpha_K+nr_K({\bf x}))</code>.
</p>
<p>The BCVI is then defined as  <br />
</p>
<p style="text-align: center;"><code class="reqn">BCVI(k) = E[p_k|{\bf x}] = \frac{\alpha_k + nr_k({\bf x})}{\alpha_0+n}</code>
</p>

<p>where <code class="reqn">\alpha_0 = \sum_{k=2}^K \alpha_k.</code> <br />
</p>
<p>The variance of <code class="reqn">p_k</code> can be computed as
</p>
<p style="text-align: center;"><code class="reqn">Var(p_k|{\bf x}) = \dfrac{(\alpha_k + nr_k(x))(\alpha_0 + n -\alpha_k-nr_k(x))}{(\alpha_0 + n)^2(\alpha_0 + n +1 )}.</code>
</p>



<h3>Value</h3>

<table>
<tr><td><code>BCVI</code></td>
<td>
<p>the dataframe where the first and the second columns are the number of groups <code>k</code> and BCVI<code class="reqn">(k)</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
<tr><td><code>VAR</code></td>
<td>
<p>the data frame where the first and the second columns are the number of groups <code>k</code> and the variance of <code class="reqn">p_k</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
<tr><td><code>CVI</code></td>
<td>
<p>the data frame where the first and the second columns are the number of groups <code>k</code> and the original WI<code class="reqn">(k)</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>N. Wiroonsri, &quot;Clustering performance analysis using a new correlation based cluster validity index,&quot; Pattern Recognition, 145, 109910, 2024. <a href="https://doi.org/10.1016/j.patcog.2023.109910">doi:10.1016/j.patcog.2023.109910</a>
</p>
<p>N. Wiroonsri, O. Preedasawakul, &quot;A Bayesian cluster validity index&quot;, arXiv:2402.02162, 2024.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+B2_data">B2_data</a>, <a href="#topic+B_TANG.IDX">B_TANG.IDX</a>, <a href="#topic+B_WP.IDX">B_WP.IDX</a>, <a href="#topic+B_STRPBM.IDX">B_STRPBM.IDX</a>, <a href="#topic+B_DB.IDX">B_DB.IDX</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(BayesCVI)

# The data included in this package.
data = B2_data[,1:2]

# alpha
aalpha = c(5,5,5,20,20,20,0.5,0.5,0.5)

B.WI = B_Wvalid(x = scale(data), kmax = 10, method = "kmeans", corr = "pearson",
              nstart = 100, sampling = 1, NCstart = TRUE, alpha = aalpha,
              mult.alpha = 1/2)

# plot the BCVI

pplot = plot_BCVI(B.WI)
pplot$plot_index
pplot$plot_BCVI
pplot$error_bar_plot

</code></pre>

<hr>
<h2 id='B_XB.IDX'>
BCVI-Xie and Beni (XB) index
</h2><span id='topic+B_XB.IDX'></span>

<h3>Description</h3>

<p>Compute Bayesian cluster validity index (BCVI) from two to <code>kmax</code> groups using Xie and Beni (XB) as the underling cluster validity index (CVI) with the user's selected Dirichlet prior parameters. The full detail of BCVI can be found in the paper Wiroonsri and Preedasawakul (2024).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>B_XB.IDX(x, kmax, method = "FCM", fzm = 2, nstart = 20,
        iter = 100, alpha = "default", mult.alpha = 1/2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="B_XB.IDX_+3A_x">x</code></td>
<td>
<p>a numeric data frame or matrix where each column is a variable to be used for cluster analysis and each row is a data point.
</p>
</td></tr>
<tr><td><code id="B_XB.IDX_+3A_kmax">kmax</code></td>
<td>
<p>a maximum number of clusters to be considered.
</p>
</td></tr>
<tr><td><code id="B_XB.IDX_+3A_method">method</code></td>
<td>
<p>a character string indicating which clustering method to be used (<code>"FCM"</code> or <code>"EM"</code>). The default is <code>"FCM"</code>.
</p>
</td></tr>
<tr><td><code id="B_XB.IDX_+3A_fzm">fzm</code></td>
<td>
<p>a number greater than 1 giving the degree of fuzzification for <code>method = "FCM"</code>. The default is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="B_XB.IDX_+3A_nstart">nstart</code></td>
<td>
<p>a maximum number of initial random sets for FCM for <code>method = "FCM"</code>. The default is <code>20</code>.
</p>
</td></tr>
<tr><td><code id="B_XB.IDX_+3A_iter">iter</code></td>
<td>
<p>a maximum number of iterations for <code>method = "FCM"</code>. The default is <code>100</code>.
</p>
</td></tr>
<tr><td><code id="B_XB.IDX_+3A_alpha">alpha</code></td>
<td>
<p>Dirichlet prior parameters <code class="reqn">\alpha_2,...,\alpha_k</code> where <code class="reqn">\alpha_k</code> is the parameter corresponding to &quot;the probability of having k groups&quot; (selecting each <code class="reqn">\alpha_k</code> between 0 to 30 is recommended and using the other parameter <code>mult.alpha</code> to be its multiplier. The default is <code>"default"</code>.)
</p>
</td></tr>
<tr><td><code id="B_XB.IDX_+3A_mult.alpha">mult.alpha</code></td>
<td>
<p>the power <code class="reqn">s</code> from <code class="reqn">n^s</code> to be multiplied to the Dirichlet prior parameters <code>alpha</code> (selecting <code>mult.alpha</code> in <code>[0,1)</code> is recommended). The default is <code class="reqn">\frac{1}{2}</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>BCVI-XB is defined as follows.
</p>
<p>Let <br />
</p>
<p style="text-align: center;"><code class="reqn">r_k(\bf x) = \dfrac{\max_j XB(j)- XB(k)}{\sum_{i=2}^K (\max_j XB(j) - XB(i))}.</code>
</p>

<p>Assume that <br />
</p>
<p style="text-align: center;"><code class="reqn">f({\bf x}|{\bf p}) = C({\bf p}) \prod_{k=2}^Kp_k^{nr_k(x)}</code>
</p>

<p>represents the conditional probability density function of the dataset given <code class="reqn">\bf p</code>, where <code class="reqn">C({\bf p})</code> is the normalizing constant. Assume further that  <code class="reqn">{\bf p}</code> follows a Dirichlet prior distribution with parameters <code class="reqn">{\bm \alpha} = (\alpha_2,\ldots,\alpha_K)</code>. The posterior distribution of <code class="reqn">\bf p</code> still remains a Dirichlet distribution with parameters <code class="reqn">(\alpha_2+nr_2({\bf x}),\ldots,\alpha_K+nr_K({\bf x}))</code>.
</p>
<p>The BCVI is then defined as  <br />
</p>
<p style="text-align: center;"><code class="reqn">BCVI(k) = E[p_k|{\bf x}] = \frac{\alpha_k + nr_k({\bf x})}{\alpha_0+n}</code>
</p>

<p>where <code class="reqn">\alpha_0 = \sum_{k=2}^K \alpha_k.</code> <br />
</p>
<p>The variance of <code class="reqn">p_k</code> can be computed as
</p>
<p style="text-align: center;"><code class="reqn">Var(p_k|{\bf x}) = \dfrac{(\alpha_k + nr_k(x))(\alpha_0 + n -\alpha_k-nr_k(x))}{(\alpha_0 + n)^2(\alpha_0 + n +1 )}.</code>
</p>



<h3>Value</h3>

<table>
<tr><td><code>BCVI</code></td>
<td>
<p>the dataframe where the first and the second columns are the number of groups <code>k</code> and BCVI<code class="reqn">(k)</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
<tr><td><code>VAR</code></td>
<td>
<p>the data frame where the first and the second columns are the number of groups <code>k</code> and the variance of <code class="reqn">p_k</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
<tr><td><code>CVI</code></td>
<td>
<p>the data frame where the first and the second columns are the number of groups <code>k</code> and the original XB<code class="reqn">(k)</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>X. Xie and G. Beni, “A validity measure for fuzzy clustering,” IEEE
Transactions on Pattern Analysis and Machine Intelligence, vol. 13, no. 8,
pp. 841–847, 1991.
</p>
<p>N. Wiroonsri, O. Preedasawakul, &quot;A Bayesian cluster validity index&quot;, arXiv:2402.02162, 2024.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+B7_data">B7_data</a>, <a href="#topic+B_TANG.IDX">B_TANG.IDX</a>, <a href="#topic+B_WP.IDX">B_WP.IDX</a>, <a href="#topic+B_Wvalid">B_Wvalid</a>, <a href="#topic+B_DB.IDX">B_DB.IDX</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(BayesCVI)

# The data included in this package.
data = B7_data[,1:2]

# alpha
aalpha = c(5,5,5,20,20,20,0.5,0.5,0.5)

B.XB = B_XB.IDX(x = scale(data), kmax =10, method = "FCM",
              fzm = 2, nstart = 20, iter = 100, alpha = aalpha, mult.alpha = 1/2)

# plot the BCVI

pplot = plot_BCVI(B.XB)
pplot$plot_index
pplot$plot_BCVI
pplot$error_bar_plot
</code></pre>

<hr>
<h2 id='B1_data'>B1 Artificial Dataset</h2><span id='topic+B1_data'></span>

<h3>Description</h3>

<p>A <code>2</code>-dimensional dataset from Wiroonsri and Preedasawakul (2024) generated from <code>1</code> Gaussian and <code>1</code> Uniform distributions labeled as <code>1-2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>B1_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 5500 data points and 3 variables
</p>

<dl>
<dt><code>x</code></dt><dd><p>Numeric values generated from Gaussian and Uniform distributions</p>
</dd>
<dt><code>y</code></dt><dd><p>Numeric values generated from Gaussian and Uniform distributions</p>
</dd>
<dt><code>label</code></dt><dd><p>Categorical labels 1,2</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>N. Wiroonsri, O. Preedasawakul, A Bayesian cluster validity index, arXiv:2402.02162, 2024
</p>


<h3>See Also</h3>

<p><a href="#topic+B2_data">B2_data</a>, <a href="#topic+B3_data">B3_data</a>, <a href="#topic+B_WP.IDX">B_WP.IDX</a>,  <a href="#topic+B_Wvalid">B_Wvalid</a>, <a href="#topic+B_XB.IDX">B_XB.IDX</a>
</p>

<hr>
<h2 id='B2_data'>B2 Artificial Dataset</h2><span id='topic+B2_data'></span>

<h3>Description</h3>

<p>A <code>2</code>-dimensional dataset from Wiroonsri and Preedasawakul (2024) generated from <code>5</code> different Gaussian distributions labeled as <code>1-5</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>B2_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 850 data points and 3 variables
</p>

<dl>
<dt><code>x</code></dt><dd><p>Numeric values generated from Gaussian distributions</p>
</dd>
<dt><code>y</code></dt><dd><p>Numeric values generated from Gaussian distributions</p>
</dd>
<dt><code>label</code></dt><dd><p>Categorical labels 1,2,3,4,5</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>N. Wiroonsri, O. Preedasawakul, A Bayesian cluster validity index, arXiv:2402.02162, 2024
</p>


<h3>See Also</h3>

<p><a href="#topic+B1_data">B1_data</a>, <a href="#topic+B3_data">B3_data</a>, <a href="#topic+B_WP.IDX">B_WP.IDX</a>,  <a href="#topic+B_Wvalid">B_Wvalid</a>, <a href="#topic+B_XB.IDX">B_XB.IDX</a>
</p>

<hr>
<h2 id='B3_data'>B3 Artificial Dataset</h2><span id='topic+B3_data'></span>

<h3>Description</h3>

<p>A <code>2</code>-dimensional dataset from Wiroonsri and Preedasawakul (2024) generated from <code>5</code> different Gaussian distributions labeled as <code>1-5</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>B3_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 2300 data points and 3 variables
</p>

<dl>
<dt><code>x</code></dt><dd><p>Numeric values generated from Gaussian distributions</p>
</dd>
<dt><code>y</code></dt><dd><p>Numeric values generated from Gaussian distributions</p>
</dd>
<dt><code>label</code></dt><dd><p>Categorical labels 1,2,3,4,5</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>N. Wiroonsri, O. Preedasawakul, A Bayesian cluster validity index, arXiv:2402.02162, 2024
</p>


<h3>See Also</h3>

<p><a href="#topic+B2_data">B2_data</a>, <a href="#topic+B4_data">B4_data</a>, <a href="#topic+B_WP.IDX">B_WP.IDX</a>,  <a href="#topic+B_Wvalid">B_Wvalid</a>, <a href="#topic+B_XB.IDX">B_XB.IDX</a>
</p>

<hr>
<h2 id='B4_data'>B4 Artificial Dataset</h2><span id='topic+B4_data'></span>

<h3>Description</h3>

<p>A <code>2</code>-dimensional dataset from Wiroonsri and Preedasawakul (2024) generated from <code>6</code> different Gaussian distributions labeled as <code>1-6</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>B4_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 740 data points and 3 variables
</p>

<dl>
<dt><code>x</code></dt><dd><p>Numeric values generated from Gaussian distributions</p>
</dd>
<dt><code>y</code></dt><dd><p>Numeric values generated from Gaussian distributions</p>
</dd>
<dt><code>label</code></dt><dd><p>Categorical labels 1,2,3,4,5,6</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>N. Wiroonsri, O. Preedasawakul, A Bayesian cluster validity index, arXiv:2402.02162, 2024
</p>


<h3>See Also</h3>

<p><a href="#topic+B3_data">B3_data</a>, <a href="#topic+B5_data">B5_data</a>, <a href="#topic+B_WP.IDX">B_WP.IDX</a>,  <a href="#topic+B_Wvalid">B_Wvalid</a>, <a href="#topic+B_XB.IDX">B_XB.IDX</a>
</p>

<hr>
<h2 id='B5_data'>B5 Artificial Dataset</h2><span id='topic+B5_data'></span>

<h3>Description</h3>

<p>A <code>2</code>-dimensional dataset from Wiroonsri and Preedasawakul (2024) generated from <code>7</code> different Gaussian and <code>2</code> Uniform distributions labeled as <code>1-9</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>B5_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 1820 data points and 3 variables
</p>

<dl>
<dt><code>x</code></dt><dd><p>Numeric values generated from Gaussian and Uniform distributions</p>
</dd>
<dt><code>y</code></dt><dd><p>Numeric values generated from Gaussian and Uniform distributions</p>
</dd>
<dt><code>label</code></dt><dd><p>Categorical labels 1,2,3,4,5,6,7,8,9</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>N. Wiroonsri, O. Preedasawakul, A Bayesian cluster validity index, arXiv:2402.02162, 2024
</p>


<h3>See Also</h3>

<p><a href="#topic+B4_data">B4_data</a>, <a href="#topic+B6_data">B6_data</a>, <a href="#topic+B_WP.IDX">B_WP.IDX</a>,  <a href="#topic+B_Wvalid">B_Wvalid</a>, <a href="#topic+B_XB.IDX">B_XB.IDX</a>
</p>

<hr>
<h2 id='B6_data'>B6 Artificial Dataset</h2><span id='topic+B6_data'></span>

<h3>Description</h3>

<p>A <code>2</code>-dimensional dataset from Wiroonsri and Preedasawakul (2024) generated from <code>3</code> different Gaussian and <code>2</code> Uniform distributions labeled as <code>1-5</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>B6_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 1000 data points and 3 variables
</p>

<dl>
<dt><code>x</code></dt><dd><p>Numeric values generated from Gaussian and Uniform distributions</p>
</dd>
<dt><code>y</code></dt><dd><p>Numeric values generated from Gaussian and Uniform distributions</p>
</dd>
<dt><code>label</code></dt><dd><p>Categorical labels 1,2,3,4,5</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>N. Wiroonsri, O. Preedasawakul, A Bayesian cluster validity index, arXiv:2402.02162, 2024
</p>


<h3>See Also</h3>

<p><a href="#topic+B5_data">B5_data</a>, <a href="#topic+B7_data">B7_data</a>, <a href="#topic+B_WP.IDX">B_WP.IDX</a>,  <a href="#topic+B_Wvalid">B_Wvalid</a>, <a href="#topic+B_XB.IDX">B_XB.IDX</a>
</p>

<hr>
<h2 id='B7_data'>B7 Artificial Dataset</h2><span id='topic+B7_data'></span>

<h3>Description</h3>

<p>A <code>2</code>-dimensional dataset from Wiroonsri and Preedasawakul (2024) generated from <code>3</code> different Gaussian and <code>2</code> Uniform distributions labeled as <code>1-5</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>B7_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 800 data points and 3 variables
</p>

<dl>
<dt><code>x</code></dt><dd><p>Numeric values generated from Gaussian and Uniform distributions</p>
</dd>
<dt><code>y</code></dt><dd><p>Numeric values generated from Gaussian and Uniform distributions</p>
</dd>
<dt><code>label</code></dt><dd><p>Categorical labels 1,2,3,4,5</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>N. Wiroonsri, O. Preedasawakul, A Bayesian cluster validity index, arXiv:2402.02162, 2024
</p>


<h3>See Also</h3>

<p><a href="#topic+B6_data">B6_data</a>, <a href="#topic+B1_data">B1_data</a>, <a href="#topic+B_WP.IDX">B_WP.IDX</a>,  <a href="#topic+B_Wvalid">B_Wvalid</a>, <a href="#topic+B_XB.IDX">B_XB.IDX</a>
</p>

<hr>
<h2 id='BayesCVIs'>
Bayesian cluster validity index
</h2><span id='topic+BayesCVIs'></span>

<h3>Description</h3>

<p>Compute Bayesian cluster validity index (BCVI) from two to <code>kmax</code> groups using an underlying cluster validity index (CVI) and Dirichlet prior parameters of the user's choice. The full detail of BCVI can be found in the paper Wiroonsri and Preedasawakul (2024).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BayesCVIs(CVI, n, kmax, opt.pt, alpha = "default", mult.alpha = 1/2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BayesCVIs_+3A_cvi">CVI</code></td>
<td>
<p>the CVI values for <code>k</code> from <code>2</code> to <code>kmax</code> to be used as the underlying index for computing BCVI.
</p>
</td></tr>
<tr><td><code id="BayesCVIs_+3A_n">n</code></td>
<td>
<p>a number of data point.
</p>
</td></tr>
<tr><td><code id="BayesCVIs_+3A_kmax">kmax</code></td>
<td>
<p>a maximum number of clusters to be considered.
</p>
</td></tr>
<tr><td><code id="BayesCVIs_+3A_opt.pt">opt.pt</code></td>
<td>
<p>a character string indicating whether the maximum or the minimum of <code>CVI</code> specifies the optimal number of groups (<code>"min"</code> or <code>"max"</code>).
</p>
</td></tr>
<tr><td><code id="BayesCVIs_+3A_alpha">alpha</code></td>
<td>
<p>Dirichlet prior parameters <code class="reqn">\alpha_2,...,\alpha_k</code> where <code class="reqn">\alpha_k</code> is the parameter corresponding to &quot;the probability of having k groups&quot; (selecting each <code class="reqn">\alpha_k</code> between 0 to 30 is recommended and using the other parameter <code>mult.alpha</code> to be its multiplier. The default is <code>"default"</code>.)
</p>
</td></tr>
<tr><td><code id="BayesCVIs_+3A_mult.alpha">mult.alpha</code></td>
<td>
<p>the power <code class="reqn">s</code> from <code class="reqn">n^s</code> to be multiplied to the Dirichlet prior parameters <code>alpha</code> (selecting <code>mult.alpha</code> in <code>[0,1)</code> is recommended). The default is <code class="reqn">\frac{1}{2}</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>BCVI is defined as follows.
Let <br />
</p>
<p style="text-align: center;"><code class="reqn">r_k(\bf x) = \dfrac{\max_j CVI(j)- CVI(k)}{\sum_{i=2}^K (\max_j CVI(j) - CVI(i))}</code>
</p>
<p> for a CVI such that the smallest value indicates the optimal number of clusters and
</p>
<p style="text-align: center;"><code class="reqn">r_k(\bf x) = \dfrac{CVI(k)-\min_j CVI(j)}{\sum_{i=2}^K (CVI(i)-\min_j CVI(j))} </code>
</p>

<p>for a CVI such that the largest value indicates the optimal number of clusters.
Assume that <br />
</p>
<p style="text-align: center;"><code class="reqn">f({\bf x}|{\bf p}) = C({\bf p}) \prod_{k=2}^Kp_k^{nr_k(x)}</code>
</p>

<p>represents the conditional probability density function of the dataset given <code class="reqn">\bf p</code>, where <code class="reqn">C({\bf p})</code> is the normalizing constant. Assume further that  <code class="reqn">{\bf p}</code> follows a Dirichlet prior distribution with parameters <code class="reqn">{\bm \alpha} = (\alpha_2,\ldots,\alpha_K)</code>. The posterior distribution of <code class="reqn">\bf p</code> still remains a Dirichlet distribution with parameters <code class="reqn">(\alpha_2+nr_2({\bf x}),\ldots,\alpha_K+nr_K({\bf x}))</code>.
</p>
<p>The BCVI is then defined as  <br />
</p>
<p style="text-align: center;"><code class="reqn">BCVI(k) = E[p_k|{\bf x}] = \frac{\alpha_k + nr_k({\bf x})}{\alpha_0+n}</code>
</p>

<p>where <code class="reqn">\alpha_0 = \sum_{k=2}^K \alpha_k.</code> <br />
</p>
<p>The variance of <code class="reqn">p_k</code> can be computed as
</p>
<p style="text-align: center;"><code class="reqn">Var(p_k|{\bf x}) = \dfrac{(\alpha_k + nr_k(x))(\alpha_0 + n -\alpha_k-nr_k(x))}{(\alpha_0 + n)^2(\alpha_0 + n +1 )}.</code>
</p>



<h3>Value</h3>

<table>
<tr><td><code>BCVI</code></td>
<td>
<p>the dataframe where the first and the second columns are the number of groups <code>k</code> and BCVI<code class="reqn">(k)</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
<tr><td><code>VAR</code></td>
<td>
<p>the data frame where the first and the second columns are the number of groups <code>k</code> and the variance of <code class="reqn">p_k</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
<tr><td><code>CVI</code></td>
<td>
<p>the data frame where the first and the second columns are the number of groups <code>k</code> and the original CVI<code class="reqn">(k)</code>, respectively, for <code>k</code> from <code>2</code> to <code>kmax</code>.</p>
</td></tr>
<tr><td><code>opt.pt</code></td>
<td>
<p>a character string indicating whether the maximum or the minimum of <code>CVI</code> specifies the optimal number of groups (<code>"min"</code> or <code>"max"</code>) that user select.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>N. Wiroonsri, O. Preedasawakul, &quot;A Bayesian cluster validity index&quot;, arXiv:2402.02162, 2024.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+B2_data">B2_data</a>, <a href="#topic+B_TANG.IDX">B_TANG.IDX</a>, <a href="#topic+B_WP.IDX">B_WP.IDX</a>, <a href="#topic+B_Wvalid">B_Wvalid</a>, <a href="#topic+B_DB.IDX">B_DB.IDX</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# install a package for computing an underlying CVI
# install.packages("UniversalCVI")

library(UniversalCVI)
library(BayesCVI)

data = R1_data[,-3]

# Compute WP index by WP.IDX using default gamma
FCM.WP = WP.IDX(scale(data), cmax = 10, cmin = 2, corr = 'pearson', method = 'FCM', fzm = 2,
                iter = 100, nstart = 20, NCstart = TRUE)


# WP.IDX values
result = FCM.WP$WP$WPI


aalpha = c(20,20,20,5,5,5,0.5,0.5,0.5)
B.WP = BayesCVIs(CVI = result,
          n = nrow(data),
          kmax = 10,
          opt.pt = "max",
          alpha = aalpha,
          mult.alpha = 1/2)

# plot the BCVI

pplot = plot_BCVI(B.WP)
pplot$plot_index
pplot$plot_BCVI
pplot$error_bar_plot

</code></pre>

<hr>
<h2 id='plot_BCVI'>
Plots for visualizing BCVI
</h2><span id='topic+plot_BCVI'></span>

<h3>Description</h3>

<p>Plot Bayesian cluster validity index (BCVI) with and without standard deviation error bars and the underlying index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_BCVI(B.result, mult.err.bar = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_BCVI_+3A_b.result">B.result</code></td>
<td>
<p>a result from one of the functions <code>B_XB.IDX, B_Wvalid, B_WP.IDX, B_WL.IDX, B_TANG.IDX, B_STRPBM.IDX, B_SF.IDX, B_PBM.IDX, B_PB.IDX, B_KWON.IDX, B_KWON2.IDX, B_KPBM.IDX, B_HF.IDX, B_GC.IDX, B_DI.IDX, B_DB.IDX, B_CSL.IDX, B_CH.IDX, B_CCV.IDX and B_BayesCVIs.IDX</code>
</p>
</td></tr>
<tr><td><code id="plot_BCVI_+3A_mult.err.bar">mult.err.bar</code></td>
<td>

<p>a multiplier of the stadard deviations to be used for plotting error bars
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>BCVI is defined as follows.
</p>
<p>Let <br />
</p>
<p style="text-align: center;"><code class="reqn">r_k(\bf x) = \dfrac{\max_j CVI(j)- CVI(k)}{\sum_{i=2}^K (\max_j CVI(j) - CVI(i))}</code>
</p>
<p> for a cluster validity index (CVI) such that the smallest value indicates the optimal number of clusters and
</p>
<p style="text-align: center;"><code class="reqn">r_k(\bf x) = \dfrac{CVI(k)-\min_j CVI(j)}{\sum_{i=2}^K (CVI(i)-\min_j CVI(j))} </code>
</p>

<p>for a CVI such that the largest indicates the optimal number of clusters.
Assume that <br />
</p>
<p style="text-align: center;"><code class="reqn">f({\bf x}|{\bf p}) = C({\bf p}) \prod_{k=2}^Kp_k^{nr_k(x)}</code>
</p>

<p>represents the conditional probability density function of the dataset given <code class="reqn">\bf p</code>, where <code class="reqn">C({\bf p})</code> is the normalizing constant. Assume further that  <code class="reqn">{\bf p}</code> follows a Dirichlet prior distribution with parameters <code class="reqn">{\bm \alpha} = (\alpha_2,\ldots,\alpha_K)</code>. The posterior distribution of <code class="reqn">\bf p</code> still remains a Dirichlet distribution with parameters <code class="reqn">(\alpha_2+nr_2({\bf x}),\ldots,\alpha_K+nr_K({\bf x}))</code>.
</p>
<p>The BCVI is then defined as  <br />
</p>
<p style="text-align: center;"><code class="reqn">BCVI(k) = E[p_k|{\bf x}] = \frac{\alpha_k + nr_k({\bf x})}{\alpha_0+n}</code>
</p>

<p>where <code class="reqn">\alpha_0 = \sum_{k=2}^K \alpha_k.</code> <br />
</p>
<p>The variance of <code class="reqn">p_k</code> can be computed as
</p>
<p style="text-align: center;"><code class="reqn">Var(p_k|{\bf x}) = \dfrac{(\alpha_k + nr_k(x))(\alpha_0 + n -\alpha_k-nr_k(x))}{(\alpha_0 + n)^2(\alpha_0 + n +1 )}.</code>
</p>



<h3>Value</h3>

<table>
<tr><td><code>plot_index</code></td>
<td>
<p>a plot of the underlying index for the number of groups from <code class="reqn">2</code> to <code class="reqn">kmax</code> according to <code>B.result</code></p>
</td></tr>
<tr><td><code>plot_BCVI</code></td>
<td>
<p>a plot of BCVI for the number of groups from <code class="reqn">2</code> to <code class="reqn">kmax</code> according to <code>B.result</code></p>
</td></tr>
<tr><td><code>error_bar_plot</code></td>
<td>
<p>a plot of BCVI with error bars for the number of groups from <code class="reqn">2</code> to <code class="reqn">kmax</code> according to <code>B.result</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nathakhun Wiroonsri and Onthada Preedasawakul
</p>


<h3>References</h3>

<p>N. Wiroonsri, O. Preedasawakul, &quot;A Bayesian cluster validity index&quot;, arXiv:2402.02162, 2024.</p>


<h3>See Also</h3>

<p><code><a href="#topic+B_STRPBM.IDX">B_STRPBM.IDX</a>, <a href="#topic+B_TANG.IDX">B_TANG.IDX</a>, <a href="#topic+B_XB.IDX">B_XB.IDX</a>, <a href="#topic+B_Wvalid">B_Wvalid</a>, <a href="#topic+B_WP.IDX">B_WP.IDX</a>, <a href="#topic+B_DB.IDX">B_DB.IDX</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(BayesCVI)
library(UniversalCVI)

##Soft clustering

# The data included in this package.
data = B7_data[,1:2]

# alpha
aalpha = c(5,5,5,20,20,20,0.5,0.5,0.5)

B.XB = B_XB.IDX(x = scale(data), kmax =10, method = "FCM", fzm = 2,
              nstart = 20, iter = 100, alpha = aalpha, mult.alpha = 1/2)

# plot the BCVI

pplot = plot_BCVI(B.XB)
pplot$plot_index
pplot$plot_BCVI
pplot$error_bar_plot


## Hard clustering

# The data included in this package.
data = B2_data[,1:2]

K.STR = STRPBM.IDX(scale(data), kmax = 10, kmin = 2, method = "kmeans",
  indexlist = "STR", nstart = 100)

# WP.IDX values
result = K.STR$STR$STR


aalpha = c(20,20,20,5,5,5,0.5,0.5,0.5)
B.STR = BayesCVIs(CVI = result,
          n = nrow(data),
          kmax = 10,
          opt.pt = "max",
          alpha = aalpha,
          mult.alpha = 1/2)

# plot the BCVI

pplot = plot_BCVI(B.STR)
pplot$plot_index
pplot$plot_BCVI
pplot$error_bar_plot

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
