<!DOCTYPE html><html><head><title>Help for package funcharts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {funcharts}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#funcharts-package'><p>funcharts: Functional Control Charts</p></a></li>
<li><a href='#[.mfd'><p>Extract observations and/or variables from <code>mfd</code> objects.</p></a></li>
<li><a href='#air'><p>Air quality data</p></a></li>
<li><a href='#cbind_mfd'><p>Bind variables of two Multivariate Functional Data Objects</p></a></li>
<li><a href='#cont_plot'><p>Produce contribution plots</p></a></li>
<li><a href='#control_charts_pca'><p>T2 and SPE control charts for multivariate functional data</p></a></li>
<li><a href='#control_charts_pca_mfd_real_time'><p>Real-time T2 and SPE control charts for multivariate functional data</p></a></li>
<li><a href='#control_charts_sof_pc'><p>Control charts for monitoring a scalar quality characteristic adjusted for</p>
by the effect of multivariate functional covariates</a></li>
<li><a href='#control_charts_sof_pc_real_time'><p>Real-time scalar-on-function regression control charts</p></a></li>
<li><a href='#data_sim_mfd'><p>Simulate multivariate functional data</p></a></li>
<li><a href='#fof_pc'><p>Function-on-function linear regression based on principal components</p></a></li>
<li><a href='#fof_pc_real_time'><p>Get a list of function-on-function linear regression models estimated</p>
on functional data
each evolving up to an intermediate domain point.</a></li>
<li><a href='#functional_filter'><p>Finds functional componentwise outliers</p></a></li>
<li><a href='#get_mfd_array'><p>Get Multivariate Functional Data from a three-dimensional array</p></a></li>
<li><a href='#get_mfd_array_real_time'><p>Get a list of functional data objects each evolving up to</p>
an intermediate domain point.</a></li>
<li><a href='#get_mfd_df'><p>Get Multivariate Functional Data from a data frame</p></a></li>
<li><a href='#get_mfd_df_real_time'><p>Get a list of functional data objects each evolving up to</p>
an intermediate domain point.</a></li>
<li><a href='#get_mfd_fd'><p>Convert a <code>fd</code> object into a Multivariate Functional Data object.</p></a></li>
<li><a href='#get_mfd_list'><p>Get Multivariate Functional Data from a list of matrices</p></a></li>
<li><a href='#get_mfd_list_real_time'><p>Get a list of functional data objects each evolving up to</p>
an intermediate domain point.</a></li>
<li><a href='#get_ooc'><p>Get out of control observations from control charts</p></a></li>
<li><a href='#get_outliers_mfd'><p>Get outliers from multivariate functional data</p></a></li>
<li><a href='#get_sof_pc_outliers'><p>Get possible outliers of a training data set of a</p>
scalar-on-function regression model.</a></li>
<li><a href='#inprod_mfd'><p>Inner products of functional data contained in <code>mfd</code> objects.</p></a></li>
<li><a href='#inprod_mfd_diag'><p>Inner product of two multivariate functional data objects,</p>
for each observation</a></li>
<li><a href='#is.mfd'><p>Confirm Object has Class <code>mfd</code></p></a></li>
<li><a href='#lines_mfd'><p>Add the plot of a new multivariate functional data object to an existing</p>
plot.</a></li>
<li><a href='#mfd'><p>Define a Multivariate Functional Data Object</p></a></li>
<li><a href='#norm.mfd'><p>Norm of Multivariate Functional Data</p></a></li>
<li><a href='#pca_mfd'><p>Multivariate functional principal components analysis</p></a></li>
<li><a href='#pca_mfd_real_time'><p>Get a list of multivariate functional principal component analysis</p>
models estimated on functional data
each evolving up to an intermediate domain point.</a></li>
<li><a href='#plot_bifd'><p>Plot a Bivariate Functional Data Object.</p></a></li>
<li><a href='#plot_bootstrap_sof_pc'><p>Plot bootstrapped estimates of the scalar-on-function regression coefficient</p></a></li>
<li><a href='#plot_control_charts'><p>Plot control charts</p></a></li>
<li><a href='#plot_control_charts_real_time'><p>Plot real-time control charts</p></a></li>
<li><a href='#plot_mfd'><p>Plot a Multivariate Functional Data Object.</p></a></li>
<li><a href='#plot_mon'><p>Plot multivariate functional object over the training data set</p></a></li>
<li><a href='#plot_pca_mfd'><p>Plot the harmonics of a <code>pca_mfd</code> object</p></a></li>
<li><a href='#predict_fof_pc'><p>Use a function-on-function linear regression model for prediction</p></a></li>
<li><a href='#predict_sof_pc'><p>Use a scalar-on-function linear regression model for prediction</p></a></li>
<li><a href='#rbind_mfd'><p>Bind replications of two Multivariate Functional Data Objects</p></a></li>
<li><a href='#regr_cc_fof'><p>Functional Regression Control Chart</p></a></li>
<li><a href='#regr_cc_fof_real_time'><p>Real-time functional regression control chart</p></a></li>
<li><a href='#regr_cc_sof'><p>Scalar-on-Function Regression Control Chart</p></a></li>
<li><a href='#regr_cc_sof_real_time'><p>Real-time Scalar-on-Function Regression Control Chart</p></a></li>
<li><a href='#RoMFCC_PhaseI'><p>Robust Multivariate Functional Control Charts - Phase I</p></a></li>
<li><a href='#RoMFCC_PhaseII'><p>Robust Multivariate Functional Control Charts - Phase II</p></a></li>
<li><a href='#RoMFDI'><p>Robust Multivariate Functional Data Imputation (RoMFDI)</p></a></li>
<li><a href='#rpca_mfd'><p>Robust multivariate functional principal components analysis</p></a></li>
<li><a href='#scale_mfd'><p>Standardize Multivariate Functional Data.</p></a></li>
<li><a href='#sim_funcharts'><p>Simulate example data for funcharts</p></a></li>
<li><a href='#simulate_mfd'><p>Simulate a data set for funcharts</p></a></li>
<li><a href='#sof_pc'><p>Scalar-on-function linear regression based on principal components</p></a></li>
<li><a href='#sof_pc_real_time'><p>Get a list of scalar-on-function linear regression models estimated</p>
on functional data
each evolving up to an intermediate domain point.</a></li>
<li><a href='#tensor_product_mfd'><p>Tensor product of two Multivariate Functional Data objects</p></a></li>
<li><a href='#which_ooc'><p>Get the index of the out of control observations from control charts</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Functional Control Charts</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functional control charts 
    for statistical process monitoring of functional data, 
    using the methods of Capezza et al. (2020) &lt;<a href="https://doi.org/10.1002%2Fasmb.2507">doi:10.1002/asmb.2507</a>&gt; and 
    Centofanti et al. (2021) &lt;<a href="https://doi.org/10.1080%2F00401706.2020.1753581">doi:10.1080/00401706.2020.1753581</a>&gt;.
    The package is thoroughly illustrated in the paper of 
    Capezza et al (2023) &lt;<a href="https://doi.org/10.1080%2F00224065.2023.2219012">doi:10.1080/00224065.2023.2219012</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0), robustbase</td>
</tr>
<tr>
<td>Imports:</td>
<td>fda, ggplot2, rlang, parallel, tidyr, patchwork, RSpectra,
matrixStats, roahd, dplyr, stringr, fda.usc, rrcov, rofanova,
Matrix, MASS, mvtnorm</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/unina-sfere/funcharts">https://github.com/unina-sfere/funcharts</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/unina-sfere/funcharts/issues">https://github.com/unina-sfere/funcharts/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-20 13:41:21 UTC; christian.capezza</td>
</tr>
<tr>
<td>Author:</td>
<td>Christian Capezza [cre, aut],
  Fabio Centofanti [aut],
  Antonio Lepore [aut],
  Alessandra Menafoglio [aut],
  Biagio Palumbo [aut],
  Simone Vantini [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christian Capezza &lt;christian.capezza@unina.it&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-22 08:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='funcharts-package'>funcharts: Functional Control Charts</h2><span id='topic+funcharts'></span><span id='topic+funcharts-package'></span>

<h3>Description</h3>

<p>Provides functional control charts for statistical process monitoring of functional data, using the methods of Capezza et al. (2020) <a href="https://doi.org/10.1002/asmb.2507">doi:10.1002/asmb.2507</a> and Centofanti et al. (2021) <a href="https://doi.org/10.1080/00401706.2020.1753581">doi:10.1080/00401706.2020.1753581</a>. The package is thoroughly illustrated in the paper of Capezza et al (2023) <a href="https://doi.org/10.1080/00224065.2023.2219012">doi:10.1080/00224065.2023.2219012</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Christian Capezza <a href="mailto:christian.capezza@unina.it">christian.capezza@unina.it</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Fabio Centofanti
</p>
</li>
<li><p> Antonio Lepore
</p>
</li>
<li><p> Alessandra Menafoglio
</p>
</li>
<li><p> Biagio Palumbo
</p>
</li>
<li><p> Simone Vantini
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/unina-sfere/funcharts">https://github.com/unina-sfere/funcharts</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/unina-sfere/funcharts/issues">https://github.com/unina-sfere/funcharts/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+5B.mfd'>Extract observations and/or variables from <code>mfd</code> objects.</h2><span id='topic++5B.mfd'></span>

<h3>Description</h3>

<p>Extract observations and/or variables from <code>mfd</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mfd'
mfdobj[i = TRUE, j = TRUE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B.mfd_+3A_mfdobj">mfdobj</code></td>
<td>
<p>An object of class <code>mfd</code>.</p>
</td></tr>
<tr><td><code id="+2B5B.mfd_+3A_i">i</code></td>
<td>
<p>Index specifying functional observations to extract or replace.
They can be numeric, character,
or logical vectors or empty (missing) or NULL.
Numeric values are coerced to integer as by as.integer
(and hence truncated towards zero).
The can also be negative integers,
indicating functional observations to leave out of the selection.
Logical vectors indicate TRUE for the observations to select.
Character vectors will be matched
to the argument <code>fdnames[[2]]</code> of <code>mfdobj</code>,
i.e. to functional observations' names.</p>
</td></tr>
<tr><td><code id="+2B5B.mfd_+3A_j">j</code></td>
<td>
<p>Index specifying functional variables to extract or replace.
They can be numeric, logical,
or character vectors or empty (missing) or NULL.
Numeric values are coerced to integer as by as.integer
(and hence truncated towards zero).
The can also be negative integers,
indicating functional variables to leave out of the selection.
Logical vectors indicate TRUE for the variables to select.
Character vectors will be matched
to the argument <code>fdnames[[3]]</code> of <code>mfdobj</code>,
i.e. to functional variables' names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function adapts the <code>fda::"[.fd"</code>
function to be more robust and suitable
for the <code>mfd</code> class.
In fact, whatever the number of observations
or variables you want to extract,
it always returns a <code>mfd</code> object with a three-dimensional coef array.
In other words, it behaves as you would
always use the argument <code>drop=FALSE</code>.
Moreover, you can extract observations
and variables both by index numbers and by names,
as you would normally do when using
<code>`[`</code> with standard vector/matrices.
</p>


<h3>Value</h3>

<p>a <code>mfd</code> object with selected observations and variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(funcharts)
library(fda)

# In the following, we extract the first one/two observations/variables
# to see the difference with `[.fd`.
mfdobj &lt;- data_sim_mfd()
fdobj &lt;- fd(mfdobj$coefs, mfdobj$basis, mfdobj$fdnames)

# The argument `coef` in `fd`
# objects is converted to a matrix when possible.
dim(fdobj[1, 1]$coef)
# Not clear what is the second dimension:
# the number of replications or the number of variables?
dim(fdobj[1, 1:2]$coef)
dim(fdobj[1:2, 1]$coef)

# The argument `coef` in `mfd` objects is always a three-dimensional array.
dim(mfdobj[1, 1]$coef)
dim(mfdobj[1, 1:2]$coef)
dim(mfdobj[1:2, 1]$coef)

# Actually, `[.mfd` works as `[.fd` when passing also `drop = FALSE`
dim(fdobj[1, 1, drop = FALSE]$coef)
dim(fdobj[1, 1:2, drop = FALSE]$coef)
dim(fdobj[1:2, 1, drop = FALSE]$coef)

</code></pre>

<hr>
<h2 id='air'>Air quality data</h2><span id='topic+air'></span>

<h3>Description</h3>

<p>This data set has been included from the R package
<a href="https://github.com/cran/FRegSigCom/"><code>FRegSigCom</code></a>.
The original .RData file is available at
<a href="https://github.com/cran/FRegSigCom/blob/master/data/air.RData">
https://github.com/cran/FRegSigCom/blob/master/data/air.RData</a>.
</p>
<p>Data collected hourly in 355 days (days with missing values removed)
in a significantly polluted area within an Italian city.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("air")
</code></pre>


<h3>Format</h3>

<p>A list of 7 matrices with 355 rows and 24 columns:
</p>

<dl>
<dt>NO2</dt><dd><p>Hourly observation of concentration level of NO2 in 355 days</p>
</dd>
<dt>CO</dt><dd><p>Hourly observation of concentration level of CO in 355 days</p>
</dd>
<dt>NMHC</dt><dd><p>Hourly observation of concentration level of NMHC in 355 days</p>
</dd>
<dt>NOx</dt><dd><p>Hourly observation of concentration level of NOx in 355 days</p>
</dd>
<dt>C6H6</dt><dd><p>Hourly observation of concentration level of C6H6 in 355 days</p>
</dd>
<dt>temperature</dt><dd><p>Hourly observation of concentration
level of temperature in 355 days</p>
</dd>
<dt>humidity</dt><dd><p>Hourly observation of concentration
level of humidity in 355 days</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://archive.ics.uci.edu/ml/datasets/Air+quality">https://archive.ics.uci.edu/ml/datasets/Air+quality</a>
</p>


<h3>References</h3>

<p>De Vito, S., Massera E., Piga M., Martinotto L. and Di Francia G. (2008).
On field calibration of an electronic nose for
benzene estimation in an urban pollution monitoring scenario
<em>Sensors and Actuators B: Chemical</em>, 129: 50-757.
<a href="doi:10.1016/j.snb.2007.09.060">doi:10.1016/j.snb.2007.09.060</a>
</p>
<p>Xin Qi and Ruiyan Luo (2019).
Nonlinear function on function
additive model with multiple predictor curves.
<em>Statistica Sinica</em>, 29:719-739.
<a href="doi:10.5705/ss.202017.0249">doi:10.5705/ss.202017.0249</a>
</p>

<hr>
<h2 id='cbind_mfd'>Bind variables of two Multivariate Functional Data Objects</h2><span id='topic+cbind_mfd'></span>

<h3>Description</h3>

<p>Bind variables of two Multivariate Functional Data Objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cbind_mfd(mfdobj1, mfdobj2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cbind_mfd_+3A_mfdobj1">mfdobj1</code></td>
<td>
<p>An object of class mfd, with the same number of replications of mfdobj2
and different variable names with respect to mfdobj2.</p>
</td></tr>
<tr><td><code id="cbind_mfd_+3A_mfdobj2">mfdobj2</code></td>
<td>
<p>An object of class mfd, with the same number of replications of mfdobj1,
and different variable names with respect to mfdobj1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class mfd, whose replications are the same of mfdobj1 and
mfdobj2 and whose functional variables are the union of the functional
variables in mfdobj1 and mfdobj2.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(funcharts)
mfdobj1 &lt;- data_sim_mfd(nvar = 3)
mfdobj2 &lt;- data_sim_mfd(nvar = 2)
dimnames(mfdobj2$coefs)[[3]] &lt;- mfdobj2$fdnames[[3]] &lt;- c("var10", "var11")

plot_mfd(mfdobj1)
plot_mfd(mfdobj2)
mfdobj_cbind &lt;- cbind_mfd(mfdobj1, mfdobj2)
plot_mfd(mfdobj_cbind)

</code></pre>

<hr>
<h2 id='cont_plot'>Produce contribution plots</h2><span id='topic+cont_plot'></span>

<h3>Description</h3>

<p>This function produces a contribution plot from
functional control charts for
a given observation of a phase II data set, using ggplot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cont_plot(cclist, id_num, which_plot = c("T2", "spe"), print_id = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cont_plot_+3A_cclist">cclist</code></td>
<td>
<p>A <code>data.frame</code> produced by
<code><a href="#topic+control_charts_pca">control_charts_pca</a></code>, <code><a href="#topic+control_charts_sof_pc">control_charts_sof_pc</a></code>
<code><a href="#topic+regr_cc_fof">regr_cc_fof</a></code>, or <code><a href="#topic+regr_cc_sof">regr_cc_sof</a></code>.</p>
</td></tr>
<tr><td><code id="cont_plot_+3A_id_num">id_num</code></td>
<td>
<p>An index number giving the observation in the
phase II data set to be plotted, i.e. 1 for the first observation,
2 for the second, and so on.</p>
</td></tr>
<tr><td><code id="cont_plot_+3A_which_plot">which_plot</code></td>
<td>
<p>A character vector.
Each value indicates which contribution you want to plot:
</p>
<p>&quot;T2&quot; indicates contribution to the Hotelling's T2 statistic,
</p>
<p>&quot;spe&quot; indicates contribution to the squared prediction error statistic.</p>
</td></tr>
<tr><td><code id="cont_plot_+3A_print_id">print_id</code></td>
<td>
<p>A logical value, if TRUE,
it prints also the id of the observation
in the title of the ggplot.
Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot containing the contributions of functional variables to the
monitoring statistics.
Each plot is a bar plot, with bars corresponding to contribution values and
horizontal black segments denoting corresponding (empirical) upper limits.
Bars are coloured by red if contributions exceed their limit.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(funcharts)
data("air")
air &lt;- lapply(air, function(x) x[201:300, , drop = FALSE])
fun_covariates &lt;- c("CO", "temperature")
mfdobj_x &lt;- get_mfd_list(air[fun_covariates],
                         n_basis = 15,
                         lambda = 1e-2)
y &lt;- rowMeans(air$NO2)
y1 &lt;- y[1:60]
y_tuning &lt;- y[61:90]
y2 &lt;- y[91:100]
mfdobj_x1 &lt;- mfdobj_x[1:60]
mfdobj_x_tuning &lt;- mfdobj_x[61:90]
mfdobj_x2 &lt;- mfdobj_x[91:100]
mod &lt;- sof_pc(y1, mfdobj_x1)
cclist &lt;- regr_cc_sof(object = mod,
                      y_new = y2,
                      mfdobj_x_new = mfdobj_x2,
                      y_tuning = y_tuning,
                      mfdobj_x_tuning = mfdobj_x_tuning,
                      include_covariates = TRUE)
get_ooc(cclist)
cont_plot(cclist, 3)


</code></pre>

<hr>
<h2 id='control_charts_pca'>T2 and SPE control charts for multivariate functional data</h2><span id='topic+control_charts_pca'></span>

<h3>Description</h3>

<p>This function builds a data frame needed to plot
the Hotelling's T2 and squared prediction error (SPE)
control charts
based on multivariate functional principal component analysis
(MFPCA) performed
on multivariate functional data, as Capezza et al. (2020)
for the multivariate functional covariates.
The training data have already been used to fit the model.
An optional tuning data set can be provided to estimate
the control chart limits.
A phase II data set contains the observations
to be monitored with the control charts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control_charts_pca(
  pca,
  components = NULL,
  tuning_data = NULL,
  newdata,
  alpha = 0.05,
  limits = "standard",
  seed,
  nfold = 5,
  ncores = 1,
  tot_variance_explained = 0.9,
  single_min_variance_explained = 0,
  absolute_error = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="control_charts_pca_+3A_pca">pca</code></td>
<td>
<p>An object of class <code>pca_mfd</code>
obtained by doing MFPCA on the
training set of multivariate functional data.</p>
</td></tr>
<tr><td><code id="control_charts_pca_+3A_components">components</code></td>
<td>
<p>A vector of integers with the components over which
to project the multivariate functional data.
If this is not NULL, the arguments <code>single_min_variance_explained</code>
and <code>tot_variance_explained</code> are ignored.
If NULL, components are selected such that
the total fraction of variance explained by them
is at least equal to the argument <code>tot_variance_explained</code>,
where only components explaining individually a fraction of variance
at least equal to the argument <code>single_min_variance_explained</code>
are considered to be retained.
Default is NULL.</p>
</td></tr>
<tr><td><code id="control_charts_pca_+3A_tuning_data">tuning_data</code></td>
<td>
<p>An object of class <code>mfd</code> containing
the tuning set of the multivariate functional data, used to estimate the
T2 and SPE control chart limits.
If NULL, the training data, i.e. the data used to fit the MFPCA model,
are also used as the tuning data set, i.e. <code>tuning_data=pca$data</code>.
Default is NULL.</p>
</td></tr>
<tr><td><code id="control_charts_pca_+3A_newdata">newdata</code></td>
<td>
<p>An object of class <code>mfd</code> containing
the phase II set of the multivariate functional data to be monitored.</p>
</td></tr>
<tr><td><code id="control_charts_pca_+3A_alpha">alpha</code></td>
<td>
<p>If it is a number between 0 and 1,
it defines the overall type-I error probability and the Bonferroni
correction is applied by setting the type-I error probability
in the two control charts equal to <code>alpha/2</code>.
If you want to set manually the Type-I error probabilities in the
two control charts, then the argument <code>alpha</code> must be
a named list
with two elements, named <code>T2</code> and <code>spe</code>,
respectively, each containing
the desired Type I error probability of
the corresponding control chart.
Default value is 0.05.</p>
</td></tr>
<tr><td><code id="control_charts_pca_+3A_limits">limits</code></td>
<td>
<p>A character value.
If &quot;standard&quot;, it estimates the control limits on the tuning
data set. If &quot;cv&quot;, the function calculates the control limits only on the
training data using cross-validation
using <code>calculate_cv_limits</code>. Default is &quot;standard&quot;.</p>
</td></tr>
<tr><td><code id="control_charts_pca_+3A_seed">seed</code></td>
<td>
<p>If <code>limits=="cv"</code>,
since the split in the k groups is random,
you can fix a seed to ensure reproducibility.
Deprecated: use <code>set.seed()</code> before calling
the function for reproducibility.</p>
</td></tr>
<tr><td><code id="control_charts_pca_+3A_nfold">nfold</code></td>
<td>
<p>If <code>limits=="cv"</code>, this gives the number of groups k
used for k-fold cross-validation.
If it is equal to the number of observations in the training data set,
then we have
leave-one-out cross-validation.
Otherwise, this argument is ignored.</p>
</td></tr>
<tr><td><code id="control_charts_pca_+3A_ncores">ncores</code></td>
<td>
<p>If <code>limits=="cv"</code>, if you want perform the analysis
in the k groups in parallel,
give the number of cores/threads.
Otherwise, this argument is ignored.</p>
</td></tr>
<tr><td><code id="control_charts_pca_+3A_tot_variance_explained">tot_variance_explained</code></td>
<td>
<p>The minimum fraction of variance
that has to be explained
by the set of multivariate functional principal components
retained into the MFPCA model
fitted on the functional covariates.
Default is 0.9.</p>
</td></tr>
<tr><td><code id="control_charts_pca_+3A_single_min_variance_explained">single_min_variance_explained</code></td>
<td>
<p>The minimum fraction of variance
that has to be explained
by each multivariate functional principal component
such that it is retained into the MFPCA model.
Default is 0.</p>
</td></tr>
<tr><td><code id="control_charts_pca_+3A_absolute_error">absolute_error</code></td>
<td>
<p>If FALSE, the SPE statistic, which monitors the principal components
not retained in the MFPCA model, is calculated as the sum
of the integrals of the squared prediction error functions, obtained
as the difference between the actual functions and their approximation
after projection over the selected principal components.
If TRUE, the SPE statistic is calculated by replacing the square of
the prediction errors with the absolute value, as proposed by
Capizzi and Masarotto (2018).
Default value is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with as many rows as the number of
multivariate functional observations in the phase II data set and
the following columns:
</p>

<ul>
<li><p> one <code>id</code> column identifying the multivariate functional observation
in the phase II data set,
</p>
</li>
<li><p> one <code>T2</code> column containing the Hotelling T2 statistic
calculated for all observations,
</p>
</li>
<li><p> one column per each functional variable,
containing its contribution to the T2 statistic,
</p>
</li>
<li><p> one <code>spe</code> column containing the SPE statistic calculated
for all observations,
</p>
</li>
<li><p> one column per each functional variable,
containing its contribution to the SPE statistic,
</p>
</li>
<li> <p><code>T2_lim</code> gives the upper control limit of
the Hotelling's T2 control chart,
</p>
</li>
<li><p> one <code>contribution_T2_*_lim</code> column per each
functional variable giving the
limits of the contribution of that variable
to the Hotelling's T2 statistic,
</p>
</li>
<li> <p><code>spe_lim</code> gives the upper control limit of the SPE control chart
</p>
</li>
<li><p> one <code>contribution_spe*_lim</code> column per each
functional variable giving the
limits of the contribution of that variable to the SPE statistic.
</p>
</li></ul>



<h3>References</h3>

<p>Capezza C, Lepore A, Menafoglio A, Palumbo B, Vantini S. (2020)
Control charts for
monitoring ship operating conditions and CO2 emissions
based on scalar-on-function regression.
<em>Applied Stochastic Models in Business and Industry</em>,
36(3):477&ndash;500.
<a href="doi:10.1002/asmb.2507">doi:10.1002/asmb.2507</a>
</p>
<p>Capizzi, G., &amp; Masarotto, G. (2018).
Phase I distribution-free analysis with the R package dfphase1.
In <em>Frontiers in Statistical Quality Control 12 (pp. 3-19)</em>.
Springer International Publishing.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regr_cc_fof">regr_cc_fof</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(funcharts)
data("air")
air &lt;- lapply(air, function(x) x[1:220, , drop = FALSE])
fun_covariates &lt;- c("CO", "temperature")
mfdobj_x &lt;- get_mfd_list(air[fun_covariates],
                         n_basis = 15,
                         lambda = 1e-2)
y &lt;- rowMeans(air$NO2)
y1 &lt;- y[1:100]
y_tuning &lt;- y[101:200]
y2 &lt;- y[201:220]
mfdobj_x1 &lt;- mfdobj_x[1:100]
mfdobj_x_tuning &lt;- mfdobj_x[101:200]
mfdobj_x2 &lt;- mfdobj_x[201:220]
pca &lt;- pca_mfd(mfdobj_x1)
cclist &lt;- control_charts_pca(pca = pca,
                             tuning_data = mfdobj_x_tuning,
                             newdata = mfdobj_x2)
plot_control_charts(cclist)

</code></pre>

<hr>
<h2 id='control_charts_pca_mfd_real_time'>Real-time T2 and SPE control charts for multivariate functional data</h2><span id='topic+control_charts_pca_mfd_real_time'></span>

<h3>Description</h3>

<p>This function produces a list of data frames,
each of them is produced by <code><a href="#topic+control_charts_pca">control_charts_pca</a></code>
and is needed to plot control charts for monitoring
multivariate functional covariates
each evolving up to an intermediate domain point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control_charts_pca_mfd_real_time(
  pca_list,
  components_list = NULL,
  mfdobj_x_test,
  mfdobj_x_tuning = NULL,
  alpha = 0.05,
  limits = "standard",
  seed,
  nfold = NULL,
  tot_variance_explained = 0.9,
  single_min_variance_explained = 0,
  absolute_error = FALSE,
  ncores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="control_charts_pca_mfd_real_time_+3A_pca_list">pca_list</code></td>
<td>
<p>A list of lists produced by <code><a href="#topic+pca_mfd_real_time">pca_mfd_real_time</a></code>,
containing a list of multivariate functional principal component analysis
models estimated
on functional data each evolving up to an intermediate domain point.</p>
</td></tr>
<tr><td><code id="control_charts_pca_mfd_real_time_+3A_components_list">components_list</code></td>
<td>
<p>A list of components given as input to <code><a href="#topic+pca_mfd">pca_mfd</a></code>
for each intermediate domain point.</p>
</td></tr>
<tr><td><code id="control_charts_pca_mfd_real_time_+3A_mfdobj_x_test">mfdobj_x_test</code></td>
<td>
<p>A list created using
<code><a href="#topic+get_mfd_df_real_time">get_mfd_df_real_time</a></code> or
<code>get_mfd_list_real_time</code>, denoting a list of functional data objects
in the phase II monitoring data set,
each evolving up to an intermediate domain point,
with observations of the multivariate functional data.
The length of this list and <code>pca_list</code> must be equal,
and their elements in the same position in the list
must correspond to the same intermediate domain point.</p>
</td></tr>
<tr><td><code id="control_charts_pca_mfd_real_time_+3A_mfdobj_x_tuning">mfdobj_x_tuning</code></td>
<td>
<p>A list created using
<code><a href="#topic+get_mfd_df_real_time">get_mfd_df_real_time</a></code> or
<code>get_mfd_list_real_time</code>, denoting a list of functional data objects
in the tuning data set (used to estimate control chart limits),
each evolving up to an intermediate domain point,
with observations of the multivariate functional data
The length of this list and <code>pca_list</code> must be equal,
and their elements in the same position in the list
must correspond to the same intermediate domain point.
If NULL, the training data, i.e. the functional data
in <code>pca_list</code>,
are also used as the tuning data set.
Default is NULL.</p>
</td></tr>
<tr><td><code id="control_charts_pca_mfd_real_time_+3A_alpha">alpha</code></td>
<td>
<p>See <code><a href="#topic+control_charts_pca">control_charts_pca</a></code>.</p>
</td></tr>
<tr><td><code id="control_charts_pca_mfd_real_time_+3A_limits">limits</code></td>
<td>
<p>See <code><a href="#topic+control_charts_pca">control_charts_pca</a></code>.</p>
</td></tr>
<tr><td><code id="control_charts_pca_mfd_real_time_+3A_seed">seed</code></td>
<td>
<p>Deprecated: See <code><a href="#topic+control_charts_pca">control_charts_pca</a></code>.</p>
</td></tr>
<tr><td><code id="control_charts_pca_mfd_real_time_+3A_nfold">nfold</code></td>
<td>
<p>See <code><a href="#topic+control_charts_pca">control_charts_pca</a></code>.</p>
</td></tr>
<tr><td><code id="control_charts_pca_mfd_real_time_+3A_tot_variance_explained">tot_variance_explained</code></td>
<td>
<p>See <code><a href="#topic+control_charts_pca">control_charts_pca</a></code>.</p>
</td></tr>
<tr><td><code id="control_charts_pca_mfd_real_time_+3A_single_min_variance_explained">single_min_variance_explained</code></td>
<td>
<p>See <code><a href="#topic+control_charts_pca">control_charts_pca</a></code>.</p>
</td></tr>
<tr><td><code id="control_charts_pca_mfd_real_time_+3A_absolute_error">absolute_error</code></td>
<td>
<p>See <code><a href="#topic+control_charts_pca">control_charts_pca</a></code>.</p>
</td></tr>
<tr><td><code id="control_charts_pca_mfd_real_time_+3A_ncores">ncores</code></td>
<td>
<p>If you want parallelization, give the number of cores/threads
to be used when creating objects separately for different instants.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>data.frame</code>s each
produced by <code><a href="#topic+control_charts_pca">control_charts_pca</a></code>,
corresponding to a given instant.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pca_mfd_real_time">pca_mfd_real_time</a></code>, <code><a href="#topic+control_charts_pca">control_charts_pca</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(funcharts)
data("air")
air1 &lt;- lapply(air, function(x) x[1:8, , drop = FALSE])
air2 &lt;- lapply(air, function(x) x[9:10, , drop = FALSE])
mfdobj_x1_list &lt;- get_mfd_list_real_time(air1[c("CO", "temperature")],
                                         n_basis = 15,
                                         lambda = 1e-2,
                                         k_seq = c(0.5, 1))
mfdobj_x2_list &lt;- get_mfd_list_real_time(air2[c("CO", "temperature")],
                                         n_basis = 15,
                                         lambda = 1e-2,
                                         k_seq = c(0.5, 1))
pca_list &lt;- pca_mfd_real_time(mfdobj_x1_list)

cclist &lt;- control_charts_pca_mfd_real_time(
  pca_list = pca_list,
  components_list = 1:3,
  mfdobj_x_test = mfdobj_x2_list)
plot_control_charts_real_time(cclist, 1)

</code></pre>

<hr>
<h2 id='control_charts_sof_pc'>Control charts for monitoring a scalar quality characteristic adjusted for
by the effect of multivariate functional covariates</h2><span id='topic+control_charts_sof_pc'></span>

<h3>Description</h3>

<p>This function builds a data frame needed to
plot control charts
for monitoring a monitoring a scalar quality characteristic adjusted for
the effect of multivariate functional covariates based on
scalar-on-function regression,
as proposed in Capezza et al. (2020).
</p>
<p>In particular, this function provides:
</p>

<ul>
<li><p> the Hotelling's T2 control chart,
</p>
</li>
<li><p> the squared prediction error (SPE) control chart,
</p>
</li>
<li><p> the scalar regression control chart.
</p>
</li></ul>

<p>This function calls <code>control_charts_pca</code> for the control charts on
the multivariate functional covariates and <code><a href="#topic+regr_cc_sof">regr_cc_sof</a></code>
for the scalar regression control chart.
</p>
<p>The training data have already been used to fit the model.
An optional tuning data set can be provided that is used to estimate
the control chart limits.
A phase II data set contains the observations to be monitored
with the control charts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control_charts_sof_pc(
  mod,
  y_test,
  mfdobj_x_test,
  mfdobj_x_tuning = NULL,
  alpha = list(T2 = 0.0125, spe = 0.0125, y = 0.025),
  limits = "standard",
  seed,
  nfold = NULL,
  ncores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="control_charts_sof_pc_+3A_mod">mod</code></td>
<td>
<p>A list obtained as output from <code>sof_pc</code>,
i.e. a fitted scalar-on-function linear regression model.</p>
</td></tr>
<tr><td><code id="control_charts_sof_pc_+3A_y_test">y_test</code></td>
<td>
<p>A numeric vector containing the observations
of the scalar response variable
in the phase II data set.</p>
</td></tr>
<tr><td><code id="control_charts_sof_pc_+3A_mfdobj_x_test">mfdobj_x_test</code></td>
<td>
<p>An object of class <code>mfd</code> containing
the phase II data set of the functional covariates observations.</p>
</td></tr>
<tr><td><code id="control_charts_sof_pc_+3A_mfdobj_x_tuning">mfdobj_x_tuning</code></td>
<td>
<p>An object of class <code>mfd</code> containing
the tuning set of the multivariate functional data, used to estimate the
T2 and SPE control chart limits.
If NULL, the training data, i.e. the data used to fit the MFPCA model,
are also used as the tuning data set, i.e. <code>tuning_data=pca$data</code>.
Default is NULL.</p>
</td></tr>
<tr><td><code id="control_charts_sof_pc_+3A_alpha">alpha</code></td>
<td>
<p>A named list with three elements, named <code>T2</code>, <code>spe</code>,
and <code>y</code>,
respectively, each containing
the desired Type I error probability of the corresponding control chart
(<code>T2</code> corresponds to the T2 control chart,
<code>spe</code>  corresponds to the SPE control chart,
<code>y</code> corresponds to the scalar regression control chart).
Note that at the moment you have to take into account manually
the family-wise error rate and adjust
the two values accordingly. See Capezza et al. (2020)
for additional details. Default value is
<code>list(T2 = 0.0125, spe = 0.0125, y = 0.025)</code>.</p>
</td></tr>
<tr><td><code id="control_charts_sof_pc_+3A_limits">limits</code></td>
<td>
<p>A character value.
If &quot;standard&quot;, it estimates the control limits on the tuning
data set. If &quot;cv&quot;, the function calculates the control limits only on the
training data using cross-validation
using <code>calculate_cv_limits</code>. Default is &quot;standard&quot;.</p>
</td></tr>
<tr><td><code id="control_charts_sof_pc_+3A_seed">seed</code></td>
<td>
<p>If <code>limits=="cv"</code>,
since the split in the k groups is random,
you can fix a seed to ensure reproducibility.
Deprecated: use <code>set.seed()</code> before calling
the function for reproducibility.</p>
</td></tr>
<tr><td><code id="control_charts_sof_pc_+3A_nfold">nfold</code></td>
<td>
<p>If <code>limits=="cv"</code>, this gives the number of groups k
used for k-fold cross-validation.
If it is equal to the number of observations in the training data set,
then we have
leave-one-out cross-validation.
Otherwise, this argument is ignored.</p>
</td></tr>
<tr><td><code id="control_charts_sof_pc_+3A_ncores">ncores</code></td>
<td>
<p>If <code>limits=="cv"</code>, if you want perform the analysis
in the k groups in parallel,
give the number of cores/threads.
Otherwise, this argument is ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with as many rows as the number of
multivariate functional observations in the phase II data set and
the following columns:
</p>

<ul>
<li><p> one <code>id</code> column identifying the multivariate functional observation
in the phase II data set,
</p>
</li>
<li><p> one <code>T2</code> column containing the Hotelling T2 statistic calculated
for all observations,
</p>
</li>
<li><p> one column per each functional variable, containing its contribution
to the T2 statistic,
</p>
</li>
<li><p> one <code>spe</code> column containing the SPE statistic calculated
for all observations,
</p>
</li>
<li><p> one column per each functional variable, containing its contribution
to the SPE statistic,
</p>
</li>
<li> <p><code>T2_lim</code> gives the upper control limit of the
Hotelling's T2 control chart,
</p>
</li>
<li><p> one <code>contribution_T2_*_lim</code> column per each
functional variable giving the
limits of the contribution of that variable to the
Hotelling's T2 statistic,
</p>
</li>
<li> <p><code>spe_lim</code> gives the upper control limit of the SPE control chart
</p>
</li>
<li><p> one <code>contribution_spe*_lim</code> column per
each functional variable giving the
limits of the contribution of that variable to the SPE statistic.
</p>
</li>
<li> <p><code>y_hat</code>: the predictions of the response variable
corresponding to <code>mfdobj_x_new</code>,
</p>
</li>
<li> <p><code>y</code>: the same as the argument <code>y_new</code>
given as input to this function,
</p>
</li>
<li> <p><code>lwr</code>: lower limit of the <code>1-alpha</code>
prediction interval on the response,
</p>
</li>
<li> <p><code>pred_err</code>: prediction error calculated as <code>y-y_hat</code>,
</p>
</li>
<li> <p><code>pred_err_sup</code>: upper limit of the <code>1-alpha</code>
prediction interval on the prediction error,
</p>
</li>
<li> <p><code>pred_err_inf</code>: lower limit of the <code>1-alpha</code>
prediction interval on the prediction error.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+control_charts_pca">control_charts_pca</a></code>, <code><a href="#topic+regr_cc_sof">regr_cc_sof</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#' library(funcharts)
data("air")
air &lt;- lapply(air, function(x) x[201:300, , drop = FALSE])
fun_covariates &lt;- c("CO", "temperature")
mfdobj_x &lt;- get_mfd_list(air[fun_covariates],
                         n_basis = 15,
                         lambda = 1e-2)
y &lt;- rowMeans(air$NO2)
y1 &lt;- y[1:60]
y2 &lt;- y[91:100]
mfdobj_x1 &lt;- mfdobj_x[1:60]
mfdobj_x_tuning &lt;- mfdobj_x[61:90]
mfdobj_x2 &lt;- mfdobj_x[91:100]
mod &lt;- sof_pc(y1, mfdobj_x1)
cclist &lt;- control_charts_sof_pc(mod = mod,
                                y_test = y2,
                                mfdobj_x_test = mfdobj_x2,
                                mfdobj_x_tuning = mfdobj_x_tuning)
plot_control_charts(cclist)

## End(Not run)

</code></pre>

<hr>
<h2 id='control_charts_sof_pc_real_time'>Real-time scalar-on-function regression control charts</h2><span id='topic+control_charts_sof_pc_real_time'></span>

<h3>Description</h3>

<p>This function is deprecated. Use <code><a href="#topic+regr_cc_sof_real_time">regr_cc_sof_real_time</a></code>.
This function produces a list of data frames,
each of them is produced by <code><a href="#topic+control_charts_sof_pc">control_charts_sof_pc</a></code>
and is needed to plot control charts for monitoring in real time
a scalar quality characteristic adjusted for
by the effect of multivariate functional covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control_charts_sof_pc_real_time(
  mod_list,
  y_test,
  mfdobj_x_test,
  mfdobj_x_tuning = NULL,
  alpha = list(T2 = 0.0125, spe = 0.0125, y = 0.025),
  limits = "standard",
  seed,
  nfold = NULL,
  ncores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="control_charts_sof_pc_real_time_+3A_mod_list">mod_list</code></td>
<td>
<p>A list of lists produced by <code><a href="#topic+sof_pc_real_time">sof_pc_real_time</a></code>,
containing a list of scalar-on-function linear regression models estimated
on functional data each evolving up to an intermediate domain point.</p>
</td></tr>
<tr><td><code id="control_charts_sof_pc_real_time_+3A_y_test">y_test</code></td>
<td>
<p>A numeric vector containing the observations of
the scalar response variable in the phase II monitoring data set.</p>
</td></tr>
<tr><td><code id="control_charts_sof_pc_real_time_+3A_mfdobj_x_test">mfdobj_x_test</code></td>
<td>
<p>A list created using
<code><a href="#topic+get_mfd_df_real_time">get_mfd_df_real_time</a></code> or
<code>get_mfd_list_real_time</code>, denoting a list of functional data objects
in the phase II monitoring data set,
each evolving up to an intermediate domain point,
with observations of the multivariate functional covariates.
The length of this list and <code>mod_list</code> must be equal,
and their elements in the same position in the list
must correspond to the same intermediate domain point.</p>
</td></tr>
<tr><td><code id="control_charts_sof_pc_real_time_+3A_mfdobj_x_tuning">mfdobj_x_tuning</code></td>
<td>
<p>A list created using
<code><a href="#topic+get_mfd_df_real_time">get_mfd_df_real_time</a></code> or
<code>get_mfd_list_real_time</code>, denoting a list of functional data objects
in the tuning data set (used to estimate control chart limits),
each evolving up to an intermediate domain point,
with observations of the multivariate functional covariates.
The length of this list and <code>mod_list</code> must be equal,
and their elements in the same position in the list
must correspond to the same intermediate domain point.
If NULL, the training data, i.e. the functional covariates
in <code>mod_list</code>,
are also used as the tuning data set.
Default is NULL.</p>
</td></tr>
<tr><td><code id="control_charts_sof_pc_real_time_+3A_alpha">alpha</code></td>
<td>
<p>See <code><a href="#topic+control_charts_sof_pc">control_charts_sof_pc</a></code>.</p>
</td></tr>
<tr><td><code id="control_charts_sof_pc_real_time_+3A_limits">limits</code></td>
<td>
<p>See <code><a href="#topic+control_charts_sof_pc">control_charts_sof_pc</a></code>.</p>
</td></tr>
<tr><td><code id="control_charts_sof_pc_real_time_+3A_seed">seed</code></td>
<td>
<p>Deprecated: see <code><a href="#topic+control_charts_sof_pc">control_charts_sof_pc</a></code>.</p>
</td></tr>
<tr><td><code id="control_charts_sof_pc_real_time_+3A_nfold">nfold</code></td>
<td>
<p>See <code><a href="#topic+control_charts_sof_pc">control_charts_sof_pc</a></code>.</p>
</td></tr>
<tr><td><code id="control_charts_sof_pc_real_time_+3A_ncores">ncores</code></td>
<td>
<p>If you want parallelization, give the number of cores/threads
to be used when creating objects separately for different instants.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>data.frame</code>s each
produced by <code><a href="#topic+control_charts_sof_pc">control_charts_sof_pc</a></code>,
corresponding to a given instant.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sof_pc_real_time">sof_pc_real_time</a></code>, <code><a href="#topic+control_charts_sof_pc">control_charts_sof_pc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(funcharts)
data("air")
air1 &lt;- lapply(air, function(x) x[1:8, , drop = FALSE])
air2 &lt;- lapply(air, function(x) x[9:10, , drop = FALSE])
mfdobj_x1_list &lt;- get_mfd_list_real_time(air1[c("CO", "temperature")],
                                         n_basis = 15,
                                         lambda = 1e-2,
                                         k_seq = c(0.5, 1))
mfdobj_x2_list &lt;- get_mfd_list_real_time(air2[c("CO", "temperature")],
                                         n_basis = 15,
                                         lambda = 1e-2,
                                         k_seq = c(0.5, 1))
y1 &lt;- rowMeans(air1$NO2)
y2 &lt;- rowMeans(air2$NO2)
mod_list &lt;- sof_pc_real_time(y1, mfdobj_x1_list)
cclist &lt;- control_charts_sof_pc_real_time(
  mod_list = mod_list,
  y_test = y2,
  mfdobj_x_test = mfdobj_x2_list)
plot_control_charts_real_time(cclist, 1)

## End(Not run)

</code></pre>

<hr>
<h2 id='data_sim_mfd'>Simulate multivariate functional data</h2><span id='topic+data_sim_mfd'></span>

<h3>Description</h3>

<p>Simulate random coefficients and create a multivariate functional data
object of class <code>mfd</code>.
It is mainly for internal use, to check that the package functions
work.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_sim_mfd(nobs = 5, nbasis = 5, nvar = 2, seed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_sim_mfd_+3A_nobs">nobs</code></td>
<td>
<p>Number of functional observations to be simulated.</p>
</td></tr>
<tr><td><code id="data_sim_mfd_+3A_nbasis">nbasis</code></td>
<td>
<p>Number of basis functions.</p>
</td></tr>
<tr><td><code id="data_sim_mfd_+3A_nvar">nvar</code></td>
<td>
<p>Number of functional covariates.</p>
</td></tr>
<tr><td><code id="data_sim_mfd_+3A_seed">seed</code></td>
<td>
<p>Deprecated: use <code>set.seed()</code> before calling
the function for reproducibility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A simulated object of class <code>mfd</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(funcharts)
data_sim_mfd()
</code></pre>

<hr>
<h2 id='fof_pc'>Function-on-function linear regression based on principal components</h2><span id='topic+fof_pc'></span>

<h3>Description</h3>

<p>Function-on-function linear regression based on
principal components.
This function performs multivariate functional principal component analysis
(MFPCA)
to extract multivariate functional principal components
from the multivariate functional covariates as well as from the
functional response, then it builds a linear regression model
of the response scores on the
covariate scores.
Both functional covariates and response are standardized before
the regression.
See Centofanti et al. (2021) for additional details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fof_pc(
  mfdobj_y,
  mfdobj_x,
  tot_variance_explained_x = 0.95,
  tot_variance_explained_y = 0.95,
  tot_variance_explained_res = 0.95,
  components_x = NULL,
  components_y = NULL,
  type_residuals = "standard"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fof_pc_+3A_mfdobj_y">mfdobj_y</code></td>
<td>
<p>A multivariate functional data object of class
mfd denoting the functional response variable.
Although it is a multivariate functional data object, it must
have only one functional variable.</p>
</td></tr>
<tr><td><code id="fof_pc_+3A_mfdobj_x">mfdobj_x</code></td>
<td>
<p>A multivariate functional data object of class
mfd denoting the functional covariates.</p>
</td></tr>
<tr><td><code id="fof_pc_+3A_tot_variance_explained_x">tot_variance_explained_x</code></td>
<td>
<p>The minimum fraction of variance
that has to be explained
by the multivariate functional principal components retained into
the MFPCA model fitted on the functional covariates.
Default is 0.95.</p>
</td></tr>
<tr><td><code id="fof_pc_+3A_tot_variance_explained_y">tot_variance_explained_y</code></td>
<td>
<p>The minimum fraction of variance that
has to be explained
by the multivariate functional principal components retained into
the MFPCA model fitted on the functional response.
Default is 0.95.</p>
</td></tr>
<tr><td><code id="fof_pc_+3A_tot_variance_explained_res">tot_variance_explained_res</code></td>
<td>
<p>The minimum fraction of variance
that has to be explained
by the multivariate functional principal components retained into
the MFPCA model fitted on the functional residuals
of the functional regression model.
Default is 0.95.</p>
</td></tr>
<tr><td><code id="fof_pc_+3A_components_x">components_x</code></td>
<td>
<p>A vector of integers with the components over which
to project the functional covariates.
If NULL, the first components that explain a minimum fraction of variance
equal to <code>tot_variance_explained_x</code>
is selected.
#' If this is not NULL, the criteria to select components are ignored.
Default is NULL.</p>
</td></tr>
<tr><td><code id="fof_pc_+3A_components_y">components_y</code></td>
<td>
<p>A vector of integers with the components over which
to project the functional response.
If NULL, the first components that explain a minimum fraction of variance
equal to <code>tot_variance_explained_y</code>
is selected.
#' If this is not NULL, the criteria to select components are ignored.
Default is NULL.</p>
</td></tr>
<tr><td><code id="fof_pc_+3A_type_residuals">type_residuals</code></td>
<td>
<p>A character value that can be
&quot;standard&quot; or &quot;studentized&quot;.
If &quot;standard&quot;, the MFPCA on functional residuals is calculated on
the standardized covariates and response.
If &quot;studentized&quot;, the MFPCA on studentized version of
the functional residuals is calculated on the
non-standardized covariates and response.
See Centofanti et al. (2021) for additional details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following arguments:
</p>

<ul>
<li> <p><code>mod</code>: an object of class <code>lm</code> that is a linear regression model
where
the response variables are the MFPCA scores of the response variable and
the covariates are the MFPCA scores of the functional covariates.
<code>mod$coefficients</code> contains the matrix of coefficients
of the functional regression basis functions,
</p>
</li>
<li> <p><code>beta_fd</code>: a <code>bifd</code> object containing the
bivariate functional regression coefficients <code class="reqn">\beta(s,t)</code>
estimated with the function-on-function linear regression model,
</p>
</li>
<li> <p><code>fitted.values</code>: a multivariate functional data object of
class mfd with the fitted values of the
functional response observations based on the
function-on-function linear regression model,
</p>
</li>
<li> <p><code>residuals_original_scale</code>: a multivariate functional data object
of class mfd
with the functional residuals of the
function-on-function linear regression model on the original scale,
i.e. they are the difference between
<code>mfdobj_y</code> and <code>fitted.values</code>,
</p>
</li>
<li> <p><code>residuals</code>: a multivariate functional data object of class mfd
with the functional residuals of the
function-on-function linear regression model,
standardized or studentized depending on
the argument <code>type_residuals</code>,
</p>
</li>
<li> <p><code>type_residuals</code>: the same as the provided argument,
</p>
</li>
<li> <p><code>pca_x</code>: an object of class <code>pca_mfd</code>
obtained by doing MFPCA on the functional covariates,
</p>
</li>
<li> <p><code>pca_y</code>: an object of class <code>pca_mfd</code>
obtained by doing MFPCA on the functional response,
</p>
</li>
<li> <p><code>pca_res</code>: an object of class <code>pca_mfd</code>
obtained by doing MFPCA on the functional residuals,
</p>
</li>
<li> <p><code>components_x</code>: a vector of integers
with the components selected in the <code>pca_x</code> model,
</p>
</li>
<li> <p><code>components_y</code>: a vector of integers
with the components selected in the <code>pca_y</code> model,
</p>
</li>
<li> <p><code>components_res</code>: a vector of integers
with the components selected in the <code>pca_res</code> model,
</p>
</li>
<li> <p><code>y_standardized</code>: the standardized functional response
obtained doing <code>scale_mfd(mfdobj_y)</code>,
</p>
</li>
<li> <p><code>tot_variance_explained_x</code>: the same as the provided argument
</p>
</li>
<li> <p><code>tot_variance_explained_y</code>: the same as the provided argument
</p>
</li>
<li> <p><code>tot_variance_explained_res</code>: the same as the provided argument
</p>
</li>
<li> <p><code>get_studentized_residuals</code>: a function that allows
to calculate studentized residuals on new data,
given the estimated function-on-function linear regression model.
</p>
</li></ul>



<h3>References</h3>

<p>Centofanti F, Lepore A, Menafoglio A, Palumbo B, Vantini S. (2021)
Functional Regression Control Chart.
<em>Technometrics</em>, 63(3), 281&ndash;294. <a href="doi:10.1080/00401706.2020.1753581">doi:10.1080/00401706.2020.1753581</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(funcharts)
data("air")
air &lt;- lapply(air, function(x) x[1:10, , drop = FALSE])
fun_covariates &lt;- c("CO", "temperature")
mfdobj &lt;- get_mfd_list(air, lambda = 1e-2)
mfdobj_y &lt;- mfdobj[, "NO2"]
mfdobj_x &lt;- mfdobj[, fun_covariates]
mod &lt;- fof_pc(mfdobj_y, mfdobj_x)

</code></pre>

<hr>
<h2 id='fof_pc_real_time'>Get a list of function-on-function linear regression models estimated
on functional data
each evolving up to an intermediate domain point.</h2><span id='topic+fof_pc_real_time'></span>

<h3>Description</h3>

<p>This function produces a list of objects,
each of them contains the result of applying <code><a href="#topic+fof_pc">fof_pc</a></code> to
a functional response variable and multivariate functional covariates
evolved up to an intermediate domain point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fof_pc_real_time(
  mfdobj_y_list,
  mfdobj_x_list,
  tot_variance_explained_x = 0.95,
  tot_variance_explained_y = 0.95,
  tot_variance_explained_res = 0.95,
  components_x = NULL,
  components_y = NULL,
  type_residuals = "standard",
  ncores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fof_pc_real_time_+3A_mfdobj_y_list">mfdobj_y_list</code></td>
<td>
<p>A list created using
<code><a href="#topic+get_mfd_df_real_time">get_mfd_df_real_time</a></code> or
<code>get_mfd_list_real_time</code>, denoting a list of functional data objects,
each evolving up to an intermediate domain point,
with observations of the functional response variable.</p>
</td></tr>
<tr><td><code id="fof_pc_real_time_+3A_mfdobj_x_list">mfdobj_x_list</code></td>
<td>
<p>A list created using
<code><a href="#topic+get_mfd_df_real_time">get_mfd_df_real_time</a></code> or
<code>get_mfd_list_real_time</code>, denoting a list of functional data objects,
each evolving up to an intermediate domain point,
with observations of the multivariate functional covariates.</p>
</td></tr>
<tr><td><code id="fof_pc_real_time_+3A_tot_variance_explained_x">tot_variance_explained_x</code></td>
<td>
<p>See <code><a href="#topic+fof_pc">fof_pc</a></code>.</p>
</td></tr>
<tr><td><code id="fof_pc_real_time_+3A_tot_variance_explained_y">tot_variance_explained_y</code></td>
<td>
<p>See <code><a href="#topic+fof_pc">fof_pc</a></code>.</p>
</td></tr>
<tr><td><code id="fof_pc_real_time_+3A_tot_variance_explained_res">tot_variance_explained_res</code></td>
<td>
<p>See <code><a href="#topic+fof_pc">fof_pc</a></code>.</p>
</td></tr>
<tr><td><code id="fof_pc_real_time_+3A_components_x">components_x</code></td>
<td>
<p>See <code><a href="#topic+fof_pc">fof_pc</a></code>.</p>
</td></tr>
<tr><td><code id="fof_pc_real_time_+3A_components_y">components_y</code></td>
<td>
<p>See <code><a href="#topic+fof_pc">fof_pc</a></code>.</p>
</td></tr>
<tr><td><code id="fof_pc_real_time_+3A_type_residuals">type_residuals</code></td>
<td>
<p>See <code><a href="#topic+fof_pc">fof_pc</a></code>.</p>
</td></tr>
<tr><td><code id="fof_pc_real_time_+3A_ncores">ncores</code></td>
<td>
<p>If you want parallelization, give the number of cores/threads
to be used when creating objects separately for different instants.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of lists each produced by <code><a href="#topic+fof_pc">fof_pc</a></code>,
corresponding to a given instant.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fof_pc">fof_pc</a></code>,
<code><a href="#topic+get_mfd_df_real_time">get_mfd_df_real_time</a></code>,
<code><a href="#topic+get_mfd_list_real_time">get_mfd_list_real_time</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(funcharts)
data("air")
air &lt;- lapply(air, function(x) x[1:10, , drop = FALSE])
mfdobj_y_list &lt;- get_mfd_list_real_time(air["NO2"],
                                        n_basis = 15,
                                        lambda = 1e-2,
                                        k_seq = c(0.5, 0.75, 1))
mfdobj_x_list &lt;- get_mfd_list_real_time(air[c("CO", "temperature")],
                                        n_basis = 15,
                                        lambda = 1e-2,
                                        k_seq = c(0.5, 0.75, 1))
mod_list &lt;- fof_pc_real_time(mfdobj_y_list, mfdobj_x_list)

</code></pre>

<hr>
<h2 id='functional_filter'>Finds functional componentwise outliers</h2><span id='topic+functional_filter'></span>

<h3>Description</h3>

<p>It finds functional componentwise outliers
as described in Capezza et al. (2022).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>functional_filter(
  mfdobj,
  method_pca = "ROBPCA",
  alpha = 0.95,
  fev = 0.999,
  delta = 0.1,
  alpha_binom = 0.99,
  bivariate = TRUE,
  max_proportion_componentwise = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="functional_filter_+3A_mfdobj">mfdobj</code></td>
<td>
<p>A multivariate functional data object of class mfd.</p>
</td></tr>
<tr><td><code id="functional_filter_+3A_method_pca">method_pca</code></td>
<td>
<p>The method used in <code>rpca_mfd</code> to perform
robust multivariate functional principal component analysis (RoMFPCA).
See <code><a href="#topic+rpca_mfd">rpca_mfd</a></code>.</p>
</td></tr>
<tr><td><code id="functional_filter_+3A_alpha">alpha</code></td>
<td>
<p>Probability value such that only values of functional distances greater than
the <code>alpha</code>-quantile of the Chi-squared
distribution, with a number of degrees of freedom equal to the number
of principal components selected by <code>fev</code>, are considered
to determine the proportion of flagged componentwise outliers.
Default value is 0.95, as recommended by Agostinelli et al. (2015).
See Capezza et al. (2022) for more details.</p>
</td></tr>
<tr><td><code id="functional_filter_+3A_fev">fev</code></td>
<td>
<p>Number between 0 and 1 denoting the fraction
of variability that must be explained by the
principal components to be selected to calculate functional distances after
applying RoMFPCA on <code>mfdobj</code>. Default is 0.999.</p>
</td></tr>
<tr><td><code id="functional_filter_+3A_delta">delta</code></td>
<td>
<p>Number between 0 and 1 denoting the parameter of the
Binomial distribution whose <code>alpha_binom</code>-quantile
determines the threshold
used in the bivariate filter.
Given the i-th observation and the j-th functional variable,
the number of pairs flagged as functional componentwise outliers in
the i-th observation where the component (i, j) is involved
is compared against this threshold to identify additional functional
componentwise outliers to the ones found by the univariate filter.
Default is 0.1, recommended as conservative choice by Leung et al. (2017).
See Capezza et al. (2022) for more details.</p>
</td></tr>
<tr><td><code id="functional_filter_+3A_alpha_binom">alpha_binom</code></td>
<td>
<p>Probability value such that the <code>alpha</code>-quantile
of the Binomial distribution is considered as threshold
in the bivariate filter. See <code>delta</code> and Capezza et al. (2022)
for more details. Default value is 0.99.</p>
</td></tr>
<tr><td><code id="functional_filter_+3A_bivariate">bivariate</code></td>
<td>
<p>If TRUE, both univariate and bivariate filters
are applied. If FALSE, only the univariate filter is used.
Default is TRUE.</p>
</td></tr>
<tr><td><code id="functional_filter_+3A_max_proportion_componentwise">max_proportion_componentwise</code></td>
<td>
<p>If the functional filter identifies a proportion of functional
componentwise outliers larger than <code>max_proportion_componentwise</code>,
for a given observation, then it is considered as a functional casewise
outlier. Default value is 0.5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements.
The first element is an <code>mfd</code> object containing
the original observation in the <code>mfdobj</code> input, but where
the basis coefficients of the components identified as functional
componentwise outliers are replaced by NA.
The second element of the list is a list of numbers, with length equal
to the number of functional variables in <code>mfdobj</code>.
Each element of this list contains the observations of the flagged
functional componentwise outliers for the corresponding functional variable.
</p>


<h3>References</h3>

<p>Agostinelli, C., Leung, A., Yohai, V. J., and Zamar, R. H. (2015).
Robust estimation of
multivariate location and scatter in the presence of cellwise and
casewise contamination.
<em>Test</em>, 24(3):441–461.
</p>
<p>Capezza, C., Centofanti, F., Lepore, A., Palumbo, B. (2022)
Robust Multivariate Functional Control Charts.
<em>arXiv:2207.07978v</em>
</p>
<p>Leung, A., Yohai, V., and Zamar, R. (2017).
Multivariate location and scatter matrix
estimation under cellwise and casewise contamination.
<em>Computational Statistics &amp; Data Analysis</em>, 111:59–76.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(funcharts)
mfdobj &lt;- get_mfd_list(air, grid = 1:24, n_basis = 13, lambda = 1e-2)
plot_mfd(mfdobj)
out &lt;- functional_filter(mfdobj)

## End(Not run)

</code></pre>

<hr>
<h2 id='get_mfd_array'>Get Multivariate Functional Data from a three-dimensional array</h2><span id='topic+get_mfd_array'></span>

<h3>Description</h3>

<p>Get Multivariate Functional Data from a three-dimensional array
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_mfd_array(
  data_array,
  grid = NULL,
  n_basis = 30,
  n_order = 4,
  basisobj = NULL,
  Lfdobj = 2,
  lambda = NULL,
  lambda_grid = 10^seq(-10, 1, length.out = 10),
  ncores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_mfd_array_+3A_data_array">data_array</code></td>
<td>
<p>A three-dimensional array.
The first dimension corresponds to argument values,
the second to replications,
and the third to variables within replications.</p>
</td></tr>
<tr><td><code id="get_mfd_array_+3A_grid">grid</code></td>
<td>
<p>See <code><a href="#topic+get_mfd_list">get_mfd_list</a></code>.</p>
</td></tr>
<tr><td><code id="get_mfd_array_+3A_n_basis">n_basis</code></td>
<td>
<p>See <code><a href="#topic+get_mfd_list">get_mfd_list</a></code>.</p>
</td></tr>
<tr><td><code id="get_mfd_array_+3A_n_order">n_order</code></td>
<td>
<p>#' See <code><a href="#topic+get_mfd_list">get_mfd_list</a></code>.</p>
</td></tr>
<tr><td><code id="get_mfd_array_+3A_basisobj">basisobj</code></td>
<td>
<p>#' See <code><a href="#topic+get_mfd_list">get_mfd_list</a></code>.</p>
</td></tr>
<tr><td><code id="get_mfd_array_+3A_lfdobj">Lfdobj</code></td>
<td>
<p>#' See <code><a href="#topic+get_mfd_list">get_mfd_list</a></code>.</p>
</td></tr>
<tr><td><code id="get_mfd_array_+3A_lambda">lambda</code></td>
<td>
<p>See <code><a href="#topic+get_mfd_list">get_mfd_list</a></code>.</p>
</td></tr>
<tr><td><code id="get_mfd_array_+3A_lambda_grid">lambda_grid</code></td>
<td>
<p>See <code><a href="#topic+get_mfd_list">get_mfd_list</a></code>.</p>
</td></tr>
<tr><td><code id="get_mfd_array_+3A_ncores">ncores</code></td>
<td>
<p>Deprecated. See <code><a href="#topic+get_mfd_list">get_mfd_list</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>mfd</code>.
See also <code>?mfd</code> for additional details on the
multivariate functional data class.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_mfd_list">get_mfd_list</a></code>, <code><a href="#topic+get_mfd_df">get_mfd_df</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(funcharts)
library(fda)
data("CanadianWeather")
mfdobj &lt;- get_mfd_array(CanadianWeather$dailyAv[, 1:10, ],
                        lambda = 1e-5)
plot_mfd(mfdobj)

</code></pre>

<hr>
<h2 id='get_mfd_array_real_time'>Get a list of functional data objects each evolving up to
an intermediate domain point.</h2><span id='topic+get_mfd_array_real_time'></span>

<h3>Description</h3>

<p>This function produces a list functional data objects,
each evolving up to an intermediate domain point, that can be used to
estimate models that allow real-time predictions of incomplete functions,
from the current functional domain up to the end of the observation,
and to build control charts for real-time  monitoring.
</p>
<p>It calls the function <code><a href="#topic+get_mfd_array">get_mfd_array</a></code> for each domain point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_mfd_array_real_time(
  data_array,
  grid = NULL,
  n_basis = 30,
  n_order = 4,
  basisobj = NULL,
  Lfdobj = 2,
  lambda = NULL,
  lambda_grid = 10^seq(-10, 1, length.out = 10),
  k_seq = seq(from = 0.25, to = 1, length.out = 10),
  ncores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_mfd_array_real_time_+3A_data_array">data_array</code></td>
<td>
<p>See <code><a href="#topic+get_mfd_array">get_mfd_array</a></code>.</p>
</td></tr>
<tr><td><code id="get_mfd_array_real_time_+3A_grid">grid</code></td>
<td>
<p>See <code><a href="#topic+get_mfd_array">get_mfd_array</a></code>.</p>
</td></tr>
<tr><td><code id="get_mfd_array_real_time_+3A_n_basis">n_basis</code></td>
<td>
<p>See <code><a href="#topic+get_mfd_array">get_mfd_array</a></code>.</p>
</td></tr>
<tr><td><code id="get_mfd_array_real_time_+3A_n_order">n_order</code></td>
<td>
<p>See <code><a href="#topic+get_mfd_array">get_mfd_array</a></code>.</p>
</td></tr>
<tr><td><code id="get_mfd_array_real_time_+3A_basisobj">basisobj</code></td>
<td>
<p>See <code><a href="#topic+get_mfd_array">get_mfd_array</a></code>.</p>
</td></tr>
<tr><td><code id="get_mfd_array_real_time_+3A_lfdobj">Lfdobj</code></td>
<td>
<p>See <code><a href="#topic+get_mfd_array">get_mfd_array</a></code>.</p>
</td></tr>
<tr><td><code id="get_mfd_array_real_time_+3A_lambda">lambda</code></td>
<td>
<p>See <code><a href="#topic+get_mfd_array">get_mfd_array</a></code>.</p>
</td></tr>
<tr><td><code id="get_mfd_array_real_time_+3A_lambda_grid">lambda_grid</code></td>
<td>
<p>See <code><a href="#topic+get_mfd_array">get_mfd_array</a></code>.</p>
</td></tr>
<tr><td><code id="get_mfd_array_real_time_+3A_k_seq">k_seq</code></td>
<td>
<p>A vector of values between 0 and 1, containing the domain points
over which functional data are to be evaluated in real time.
If the domain is the interval (a,b), for each instant k in the sequence,
functions are evaluated in (a,k(b-a)).</p>
</td></tr>
<tr><td><code id="get_mfd_array_real_time_+3A_ncores">ncores</code></td>
<td>
<p>If you want parallelization, give the number of cores/threads
to be used when creating mfd objects separately for different instants.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>mfd</code> objects as produced by
<code><a href="#topic+get_mfd_array">get_mfd_array</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_mfd_array">get_mfd_array</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(funcharts)
library(fda)
data("CanadianWeather")
fdobj &lt;- get_mfd_array_real_time(CanadianWeather$dailyAv[, 1:5, 1:2],
                                 lambda = 1e-2)

</code></pre>

<hr>
<h2 id='get_mfd_df'>Get Multivariate Functional Data from a data frame</h2><span id='topic+get_mfd_df'></span>

<h3>Description</h3>

<p>Get Multivariate Functional Data from a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_mfd_df(
  dt,
  domain,
  arg,
  id,
  variables,
  n_basis = 30,
  n_order = 4,
  basisobj = NULL,
  Lfdobj = 2,
  lambda = NULL,
  lambda_grid = 10^seq(-10, 1, length.out = 10),
  ncores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_mfd_df_+3A_dt">dt</code></td>
<td>
<p>A <code>data.frame</code> containing the discrete data.
For each functional variable, a single column,
whose name is provided in the argument <code>variables</code>,
contains discrete values of that variable for all functional observation.
The column indicated by the argument <code>id</code>
denotes which is the functional observation in each row.
The column indicated by the argument <code>arg</code>
gives the argument value at which
the discrete values of the functional variables are observed for each row.</p>
</td></tr>
<tr><td><code id="get_mfd_df_+3A_domain">domain</code></td>
<td>
<p>A numeric vector of length 2 defining
the interval over which the functional data object
can be evaluated.</p>
</td></tr>
<tr><td><code id="get_mfd_df_+3A_arg">arg</code></td>
<td>
<p>A character variable, which is the name of
the column of the data frame <code>dt</code>
giving the argument values at which the functional variables
are evaluated for each row.</p>
</td></tr>
<tr><td><code id="get_mfd_df_+3A_id">id</code></td>
<td>
<p>A character variable indicating
which is the functional observation in each row.</p>
</td></tr>
<tr><td><code id="get_mfd_df_+3A_variables">variables</code></td>
<td>
<p>A vector of characters of the column names
of the data frame <code>dt</code>
indicating the functional variables.</p>
</td></tr>
<tr><td><code id="get_mfd_df_+3A_n_basis">n_basis</code></td>
<td>
<p>An integer variable specifying the number of basis functions;
default value is 30.
See details on basis functions.</p>
</td></tr>
<tr><td><code id="get_mfd_df_+3A_n_order">n_order</code></td>
<td>
<p>An integer specifying the order of b-splines,
which is one higher than their degree.
The default of 4 gives cubic splines.</p>
</td></tr>
<tr><td><code id="get_mfd_df_+3A_basisobj">basisobj</code></td>
<td>
<p>An object of class <code>basisfd</code> defining
the basis function expansion.
Default is <code>NULL</code>, which means that
a <code>basisfd</code> object is created by doing
<code>create.bspline.basis(rangeval = domain,
nbasis = n_basis,  norder = n_order)</code></p>
</td></tr>
<tr><td><code id="get_mfd_df_+3A_lfdobj">Lfdobj</code></td>
<td>
<p>An object of class <code>Lfd</code> defining a
linear differential operator of order m.
It is used to specify a roughness penalty through <code>fdPar</code>.
Alternatively, a nonnegative integer
specifying the order m can be given and is
passed as <code>Lfdobj</code> argument to the function <code>fdPar</code>,
which indicates that the derivative of order m is penalized.
Default value is 2, which means that the
integrated squared second derivative is penalized.</p>
</td></tr>
<tr><td><code id="get_mfd_df_+3A_lambda">lambda</code></td>
<td>
<p>A non-negative real number.
If you want to use a single specified smoothing parameter
for all functional data objects in the dataset,
this argument is passed to the function <code>fda::fdPar</code>.
Default value is NULL, in this case the smoothing parameter is chosen
by minimizing the generalized cross-validation (GCV)
criterion over the grid of values given by the argument.
See details on how smoothing parameters work.</p>
</td></tr>
<tr><td><code id="get_mfd_df_+3A_lambda_grid">lambda_grid</code></td>
<td>
<p>A vector of non-negative real numbers.
If <code>lambda</code> is provided as a single number, this argument is ignored.
If <code>lambda</code> is NULL, then this provides the grid of values
over which the optimal smoothing parameter is
searched. Default value is <code>10^seq(-10,1,l=20)</code>.</p>
</td></tr>
<tr><td><code id="get_mfd_df_+3A_ncores">ncores</code></td>
<td>
<p>If you want parallelization, give the number of cores/threads
to be used when doing GCV separately on all observations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Basis functions are created with
<code>fda::create.bspline.basis(domain, n_basis)</code>, i.e.
B-spline basis functions of order 4 with equally spaced knots
are used to create <code>mfd</code> objects.
</p>
<p>The smoothing penalty lambda is provided as
<code>fda::fdPar(bs, 2, lambda)</code>,
where bs is the basis object and 2 indicates
that the integrated squared second derivative is penalized.
</p>
<p>Rather than having a data frame with long format,
i.e. with all functional observations in a single column
for each functional variable,
if all functional observations are observed on a common equally spaced grid,
discrete data may be available in matrix form for each functional variable.
In this case, see <code>get_mfd_list</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>mfd</code>.
See also <code>?mfd</code> for additional details on the
multivariate functional data class.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_mfd_list">get_mfd_list</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(funcharts)

x &lt;- seq(1, 10, length = 25)
y11 &lt;- cos(x)
y21 &lt;- cos(2 * x)
y12 &lt;- sin(x)
y22 &lt;- sin(2 * x)
df &lt;- data.frame(id = factor(rep(1:2, each = length(x))),
                 x = rep(x, times = 2),
                 y1 = c(y11, y21),
                 y2 = c(y12, y22))

mfdobj &lt;- get_mfd_df(dt = df,
                     domain = c(1, 10),
                     arg = "x",
                     id = "id",
                     variables = c("y1", "y2"),
                     lambda = 1e-5)

</code></pre>

<hr>
<h2 id='get_mfd_df_real_time'>Get a list of functional data objects each evolving up to
an intermediate domain point.</h2><span id='topic+get_mfd_df_real_time'></span>

<h3>Description</h3>

<p>This function produces a list functional data objects,
each evolving up to an intermediate domain point, that can be used to
estimate models that allow real-time predictions of incomplete functions,
from the current functional domain up to the end of the observation,
and to build control charts for real-time  monitoring.
</p>
<p>It calls the function <code><a href="#topic+get_mfd_df">get_mfd_df</a></code> for each domain point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_mfd_df_real_time(
  dt,
  domain,
  arg,
  id,
  variables,
  n_basis = 30,
  n_order = 4,
  basisobj = NULL,
  Lfdobj = 2,
  lambda = NULL,
  lambda_grid = 10^seq(-10, 1, length.out = 10),
  k_seq = seq(from = 0.25, to = 1, length.out = 10),
  ncores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_mfd_df_real_time_+3A_dt">dt</code></td>
<td>
<p>See <code><a href="#topic+get_mfd_df">get_mfd_df</a></code>.</p>
</td></tr>
<tr><td><code id="get_mfd_df_real_time_+3A_domain">domain</code></td>
<td>
<p>See <code><a href="#topic+get_mfd_df">get_mfd_df</a></code>.</p>
</td></tr>
<tr><td><code id="get_mfd_df_real_time_+3A_arg">arg</code></td>
<td>
<p>See <code><a href="#topic+get_mfd_df">get_mfd_df</a></code>.</p>
</td></tr>
<tr><td><code id="get_mfd_df_real_time_+3A_id">id</code></td>
<td>
<p>See <code><a href="#topic+get_mfd_df">get_mfd_df</a></code>.</p>
</td></tr>
<tr><td><code id="get_mfd_df_real_time_+3A_variables">variables</code></td>
<td>
<p>See <code><a href="#topic+get_mfd_df">get_mfd_df</a></code>.</p>
</td></tr>
<tr><td><code id="get_mfd_df_real_time_+3A_n_basis">n_basis</code></td>
<td>
<p>See <code><a href="#topic+get_mfd_df">get_mfd_df</a></code>.</p>
</td></tr>
<tr><td><code id="get_mfd_df_real_time_+3A_n_order">n_order</code></td>
<td>
<p>See <code><a href="#topic+get_mfd_df">get_mfd_df</a></code>.</p>
</td></tr>
<tr><td><code id="get_mfd_df_real_time_+3A_basisobj">basisobj</code></td>
<td>
<p>See <code><a href="#topic+get_mfd_df">get_mfd_df</a></code>.</p>
</td></tr>
<tr><td><code id="get_mfd_df_real_time_+3A_lfdobj">Lfdobj</code></td>
<td>
<p>See <code><a href="#topic+get_mfd_df">get_mfd_df</a></code>.</p>
</td></tr>
<tr><td><code id="get_mfd_df_real_time_+3A_lambda">lambda</code></td>
<td>
<p>See <code><a href="#topic+get_mfd_df">get_mfd_df</a></code>.</p>
</td></tr>
<tr><td><code id="get_mfd_df_real_time_+3A_lambda_grid">lambda_grid</code></td>
<td>
<p>See <code><a href="#topic+get_mfd_df">get_mfd_df</a></code>.</p>
</td></tr>
<tr><td><code id="get_mfd_df_real_time_+3A_k_seq">k_seq</code></td>
<td>
<p>A vector of values between 0 and 1, containing the domain points
over which functional data are to be evaluated in real time.
If the domain is the interval (a,b), for each instant k in the sequence,
functions are evaluated in (a,k(b-a)).</p>
</td></tr>
<tr><td><code id="get_mfd_df_real_time_+3A_ncores">ncores</code></td>
<td>
<p>If you want parallelization, give the number of cores/threads
to be used when creating mfd objects separately for different instants.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>mfd</code> objects as produced by
<code><a href="#topic+get_mfd_df">get_mfd_df</a></code>,
corresponding to a given instant.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_mfd_df">get_mfd_df</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(funcharts)

x &lt;- seq(1, 10, length = 25)
y11 &lt;- cos(x)
y21 &lt;- cos(2 * x)
y12 &lt;- sin(x)
y22 &lt;- sin(2 * x)
df &lt;- data.frame(id = factor(rep(1:2, each = length(x))),
                 x = rep(x, times = 2),
                 y1 = c(y11, y21),
                 y2 = c(y12, y22))

mfdobj_list &lt;- get_mfd_df_real_time(dt = df,
                                    domain = c(1, 10),
                                    arg = "x",
                                    id = "id",
                                    variables = c("y1", "y2"),
                                    lambda = 1e-2)

</code></pre>

<hr>
<h2 id='get_mfd_fd'>Convert a <code>fd</code> object into a Multivariate Functional Data object.</h2><span id='topic+get_mfd_fd'></span>

<h3>Description</h3>

<p>Convert a <code>fd</code> object into a Multivariate Functional Data object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_mfd_fd(fdobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_mfd_fd_+3A_fdobj">fdobj</code></td>
<td>
<p>An object of class fd.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>mfd</code>.
See also <code>?mfd</code> for additional details on the
multivariate functional data class.
</p>


<h3>See Also</h3>

<p><code>mfd</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(funcharts)
library(fda)
bs &lt;- create.bspline.basis(nbasis = 10)
fdobj &lt;- fd(coef = 1:10, basisobj = bs)
mfdobj &lt;- get_mfd_fd(fdobj)
</code></pre>

<hr>
<h2 id='get_mfd_list'>Get Multivariate Functional Data from a list of matrices</h2><span id='topic+get_mfd_list'></span>

<h3>Description</h3>

<p>Get Multivariate Functional Data from a list of matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_mfd_list(
  data_list,
  grid = NULL,
  n_basis = 30,
  n_order = 4,
  basisobj = NULL,
  Lfdobj = 2,
  lambda = NULL,
  lambda_grid = 10^seq(-10, 1, length.out = 10),
  ncores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_mfd_list_+3A_data_list">data_list</code></td>
<td>
<p>A named list of matrices.
Names of the elements in the list denote the functional variable names.
Each matrix in the list corresponds to a functional variable.
All matrices must have the same dimension, where
the number of rows corresponds to replications, while
the number of columns corresponds to the argument values at which
functions are evaluated.</p>
</td></tr>
<tr><td><code id="get_mfd_list_+3A_grid">grid</code></td>
<td>
<p>A numeric vector, containing the argument values at which
functions are evaluated.
Its length must be equal to the number of columns
in each matrix in data_list.
Default is NULL, in this case a vector equally spaced numbers
between 0 and 1 is created,
with as many numbers as the number of columns in each matrix in data_list.</p>
</td></tr>
<tr><td><code id="get_mfd_list_+3A_n_basis">n_basis</code></td>
<td>
<p>An integer variable specifying the number of basis functions;
default value is 30.
See details on basis functions.</p>
</td></tr>
<tr><td><code id="get_mfd_list_+3A_n_order">n_order</code></td>
<td>
<p>An integer specifying the order of B-splines,
which is one higher than their degree.
The default of 4 gives cubic splines.</p>
</td></tr>
<tr><td><code id="get_mfd_list_+3A_basisobj">basisobj</code></td>
<td>
<p>An object of class <code>basisfd</code> defining the
B-spline basis function expansion.
Default is <code>NULL</code>, which means that
a <code>basisfd</code> object is created by doing
<code>create.bspline.basis(rangeval = domain,
nbasis = n_basis,  norder = n_order)</code></p>
</td></tr>
<tr><td><code id="get_mfd_list_+3A_lfdobj">Lfdobj</code></td>
<td>
<p>An object of class <code>Lfd</code> defining a linear
differential operator of order m.
It is used to specify a roughness penalty through <code>fdPar</code>.
Alternatively, a nonnegative integer specifying
the order m can be given and is
passed as <code>Lfdobj</code> argument to the function <code>fdPar</code>,
which indicates that the derivative of order m is penalized.
Default value is 2, which means that the integrated
squared second derivative is penalized.</p>
</td></tr>
<tr><td><code id="get_mfd_list_+3A_lambda">lambda</code></td>
<td>
<p>A non-negative real number.
If you want to use a single specified smoothing parameter
for all functional data objects in the dataset,
this argument is passed to the function <code>fda::fdPar</code>.
Default value is NULL, in this case the smoothing parameter is chosen
by minimizing the generalized cross-validation (GCV) criterion
over the grid of values given by the argument.
See details on how smoothing parameters work.</p>
</td></tr>
<tr><td><code id="get_mfd_list_+3A_lambda_grid">lambda_grid</code></td>
<td>
<p>A vector of non-negative real numbers.
If <code>lambda</code> is provided as a single number, this argument is ignored.
If <code>lambda</code> is NULL, then this provides
the grid of values over which the optimal smoothing parameter is
searched. Default value is <code>10^seq(-10,1,l=20)</code>.</p>
</td></tr>
<tr><td><code id="get_mfd_list_+3A_ncores">ncores</code></td>
<td>
<p>Deprecated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Basis functions are created with
<code>fda::create.bspline.basis(domain, n_basis)</code>, i.e.
B-spline basis functions of order 4 with equally spaced knots
are used to create <code>mfd</code> objects.
</p>
<p>The smoothing penalty lambda is provided as
<code>fda::fdPar(bs, 2, lambda)</code>,
where bs is the basis object and 2 indicates that
the integrated squared second derivative is penalized.
</p>
<p>Rather than having a list of matrices,
you may have a data frame with long format,
i.e. with all functional observations in a single column
for each functional variable.
In this case, see <code>get_mfd_df</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>mfd</code>.
See also <code><a href="#topic+mfd">mfd</a></code> for additional details
on the multivariate functional data class.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mfd">mfd</a></code>,
<code><a href="#topic+get_mfd_list">get_mfd_list</a></code>,
<code><a href="#topic+get_mfd_array">get_mfd_array</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(funcharts)
data("air")
# Only take first 5 multivariate functional observations
# and only two variables from air
air_small &lt;- lapply(air[c("NO2", "CO")], function(x) x[1:5, ])
mfdobj &lt;- get_mfd_list(data_list = air_small)

</code></pre>

<hr>
<h2 id='get_mfd_list_real_time'>Get a list of functional data objects each evolving up to
an intermediate domain point.</h2><span id='topic+get_mfd_list_real_time'></span>

<h3>Description</h3>

<p>This function produces a list functional data objects,
each evolving up to an intermediate domain point, that can be used to
estimate models that allow real-time predictions of incomplete functions,
from the current functional domain up to the end of the observation,
and to build control charts for real-time  monitoring.
</p>
<p>It calls the function <code><a href="#topic+get_mfd_list">get_mfd_list</a></code> for each domain point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_mfd_list_real_time(
  data_list,
  grid = NULL,
  n_basis = 30,
  n_order = 4,
  basisobj = NULL,
  Lfdobj = 2,
  lambda = NULL,
  lambda_grid = 10^seq(-10, 1, length.out = 10),
  k_seq = seq(from = 0.2, to = 1, by = 0.1),
  ncores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_mfd_list_real_time_+3A_data_list">data_list</code></td>
<td>
<p>See <code><a href="#topic+get_mfd_list">get_mfd_list</a></code>.</p>
</td></tr>
<tr><td><code id="get_mfd_list_real_time_+3A_grid">grid</code></td>
<td>
<p>See <code><a href="#topic+get_mfd_list">get_mfd_list</a></code>.</p>
</td></tr>
<tr><td><code id="get_mfd_list_real_time_+3A_n_basis">n_basis</code></td>
<td>
<p>See <code><a href="#topic+get_mfd_list">get_mfd_list</a></code>.</p>
</td></tr>
<tr><td><code id="get_mfd_list_real_time_+3A_n_order">n_order</code></td>
<td>
<p>See <code><a href="#topic+get_mfd_list">get_mfd_list</a></code>.</p>
</td></tr>
<tr><td><code id="get_mfd_list_real_time_+3A_basisobj">basisobj</code></td>
<td>
<p>See <code><a href="#topic+get_mfd_list">get_mfd_list</a></code>.</p>
</td></tr>
<tr><td><code id="get_mfd_list_real_time_+3A_lfdobj">Lfdobj</code></td>
<td>
<p>See <code><a href="#topic+get_mfd_list">get_mfd_list</a></code>.</p>
</td></tr>
<tr><td><code id="get_mfd_list_real_time_+3A_lambda">lambda</code></td>
<td>
<p>See <code><a href="#topic+get_mfd_list">get_mfd_list</a></code>.</p>
</td></tr>
<tr><td><code id="get_mfd_list_real_time_+3A_lambda_grid">lambda_grid</code></td>
<td>
<p>See <code><a href="#topic+get_mfd_df">get_mfd_df</a></code>.</p>
</td></tr>
<tr><td><code id="get_mfd_list_real_time_+3A_k_seq">k_seq</code></td>
<td>
<p>A vector of values between 0 and 1, containing the domain points
over which functional data are to be evaluated in real time.
If the domain is the interval (a,b), for each instant k in the sequence,
functions are evaluated in (a,a+k(b-a)).</p>
</td></tr>
<tr><td><code id="get_mfd_list_real_time_+3A_ncores">ncores</code></td>
<td>
<p>If you want parallelization, give the number of cores/threads
to be used when creating mfd objects separately for different instants.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>mfd</code> objects as produced by
<code><a href="#topic+get_mfd_list">get_mfd_list</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_mfd_list">get_mfd_list</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(funcharts)
data("air")
# Only take first 5 multivariate functional observations from air
air_small &lt;- lapply(air, function(x) x[1:5, ])
# Consider only 3 domain points: 0.5, 0.75, 1
mfdobj &lt;- get_mfd_list_real_time(data_list = air_small,
                                 lambda = 1e-2,
                                 k_seq = c(0.5, 0.75, 1))

</code></pre>

<hr>
<h2 id='get_ooc'>Get out of control observations from control charts</h2><span id='topic+get_ooc'></span>

<h3>Description</h3>

<p>Get out of control observations from control charts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ooc(cclist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_ooc_+3A_cclist">cclist</code></td>
<td>
<p>A <code>data.frame</code> produced by
<code><a href="#topic+control_charts_pca">control_charts_pca</a></code>, <code><a href="#topic+control_charts_sof_pc">control_charts_sof_pc</a></code>,
<code><a href="#topic+regr_cc_fof">regr_cc_fof</a></code>, or <code><a href="#topic+regr_cc_sof">regr_cc_sof</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with the same number of rows as cclist,
and the same number of columns
apart from the columns indicating control chart limits.
Each value is TRUE if the corresponding observation is in control
and FALSE otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(funcharts)
data("air")
air &lt;- lapply(air, function(x) x[201:300, , drop = FALSE])
fun_covariates &lt;- c("CO", "temperature")
mfdobj_x &lt;- get_mfd_list(air[fun_covariates],
                         n_basis = 15,
                         lambda = 1e-2)
y &lt;- rowMeans(air$NO2)
y1 &lt;- y[1:60]
y_tuning &lt;- y[61:90]
y2 &lt;- y[91:100]
mfdobj_x1 &lt;- mfdobj_x[1:60]
mfdobj_x_tuning &lt;- mfdobj_x[61:90]
mfdobj_x2 &lt;- mfdobj_x[91:100]
mod &lt;- sof_pc(y1, mfdobj_x1)
cclist &lt;- regr_cc_sof(object = mod,
                      y_new = y2,
                      mfdobj_x_new = mfdobj_x2,
                      y_tuning = y_tuning,
                      mfdobj_x_tuning = mfdobj_x_tuning,
                      include_covariates = TRUE)
get_ooc(cclist)


</code></pre>

<hr>
<h2 id='get_outliers_mfd'>Get outliers from multivariate functional data</h2><span id='topic+get_outliers_mfd'></span>

<h3>Description</h3>

<p>Get outliers from multivariate functional data
using the functional boxplot with the
modified band depth of Sun et al. (2011, 2012).
This function relies on the <code>fbplot</code> function
of the <code>roahd</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_outliers_mfd(mfdobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_outliers_mfd_+3A_mfdobj">mfdobj</code></td>
<td>
<p>A multivariate functional data object of class mfd</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the indexes of the functional observations
signaled as outliers.
</p>


<h3>References</h3>


<ul>
<li><p> Sun, Y., &amp; Genton, M. G. (2011). Functional boxplots.
<em>Journal of Computational and Graphical Statistics</em>, 20(2), 316-334.
</p>
</li>
<li><p> Sun, Y., &amp; Genton, M. G. (2012).
Adjusted functional boxplots for spatio-temporal data visualization
and outlier detection. <em>Environmetrics</em>, 23(1), 54-64.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(funcharts)
data("air")
air &lt;- lapply(air, function(x) x[1:20, , drop = FALSE])
fun_covariates &lt;- c("CO", "temperature")
mfdobj_x &lt;- get_mfd_list(air[fun_covariates], lambda = 1e-2)
get_outliers_mfd(mfdobj_x)

</code></pre>

<hr>
<h2 id='get_sof_pc_outliers'>Get possible outliers of a training data set of a
scalar-on-function regression model.</h2><span id='topic+get_sof_pc_outliers'></span>

<h3>Description</h3>

<p>Get possible outliers of a training data set of a
scalar-on-function regression model.
It sets the training data set also as tuning data set for the
calculation of control chart limits,
and as phase II data set to compare monitoring statistics
against the limits and identify
possible outliers.
This is only an empirical approach. It is advised to use methods
appropriately designed for phase I monitoring to identify outliers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_sof_pc_outliers(y, mfdobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_sof_pc_outliers_+3A_y">y</code></td>
<td>
<p>A numeric vector containing the observations of the
scalar response variable.</p>
</td></tr>
<tr><td><code id="get_sof_pc_outliers_+3A_mfdobj">mfdobj</code></td>
<td>
<p>A multivariate functional data object of class mfd
denoting the functional covariates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with the ids of functional observations
signaled as possibly anomalous.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(funcharts)
data("air")
air &lt;- lapply(air, function(x) x[1:10, , drop = FALSE])
fun_covariates &lt;- c("CO", "temperature")
mfdobj_x &lt;- get_mfd_list(air[fun_covariates], lambda = 1e-2)
y &lt;- rowMeans(air$NO2)
get_sof_pc_outliers(y, mfdobj_x)

## End(Not run)

</code></pre>

<hr>
<h2 id='inprod_mfd'>Inner products of functional data contained in <code>mfd</code> objects.</h2><span id='topic+inprod_mfd'></span>

<h3>Description</h3>

<p>Inner products of functional data contained in <code>mfd</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inprod_mfd(mfdobj1, mfdobj2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inprod_mfd_+3A_mfdobj1">mfdobj1</code></td>
<td>
<p>A multivariate functional data object of class <code>mfd</code>.</p>
</td></tr>
<tr><td><code id="inprod_mfd_+3A_mfdobj2">mfdobj2</code></td>
<td>
<p>A multivariate functional data object of class <code>mfd</code>.
It must have the same functional variables as <code>mfdobj1</code>.
If NULL, it is equal to <code>mfdobj1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <em>L^2</em> inner products are not calculated
for couples of functional data
from different functional variables.
This function is needed to calculate the
inner product in the product Hilbert space
in the case of multivariate functional data,
which for each observation is the sum of the <em>L^2</em>
inner products obtained for each functional variable.
</p>


<h3>Value</h3>

<p>a three-dimensional array of <em>L^2</em> inner products.
The first dimension is the number of functions in argument mfdobj1,
the second dimension is the same thing for argument mfdobj2,
the third dimension is the number of functional variables.
If you sum values over the third dimension,
you get a matrix of inner products
in the product Hilbert space of multivariate functional data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(funcharts)
set.seed(123)
mfdobj1 &lt;- data_sim_mfd()
mfdobj2 &lt;- data_sim_mfd()
inprod_mfd(mfdobj1)
inprod_mfd(mfdobj1, mfdobj2)
</code></pre>

<hr>
<h2 id='inprod_mfd_diag'>Inner product of two multivariate functional data objects,
for each observation</h2><span id='topic+inprod_mfd_diag'></span>

<h3>Description</h3>

<p>Inner product of two multivariate functional data objects,
for each observation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inprod_mfd_diag(mfdobj1, mfdobj2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inprod_mfd_diag_+3A_mfdobj1">mfdobj1</code></td>
<td>
<p>A multivariate functional data object of class <code>mfd</code>.</p>
</td></tr>
<tr><td><code id="inprod_mfd_diag_+3A_mfdobj2">mfdobj2</code></td>
<td>
<p>A multivariate functional data object of class <code>mfd</code>,
with the same number of functional variables and observations
as <code>mfdobj1</code>.
If NULL, then <code>mfdobj2=mfdobj1</code>. Default is NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It calculates the inner product of two
multivariate functional data objects.
The main function <code>inprod</code> of the package <code>fda</code>
calculates inner products among
all possible couples of observations.
This means that, if <code>mfdobj1</code> has <code>n1</code> observations
and <code>mfdobj2</code> has <code>n2</code> observations,
then for each variable <code>n1 X n2</code> inner products are calculated.
However, often one is interested only in calculating
the <code>n</code> inner products
between the <code>n</code> observations of <code>mfdobj1</code> and
the corresponding <code>n</code>
observations of <code>mfdobj2</code>. This function provides
this &quot;diagonal&quot; inner products only,
saving a lot of computation with respect to using
<code>fda::inprod</code> and then extracting the
diagonal elements.
Note that the code of this function calls a modified version
of <code>fda::inprod()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mfdobj &lt;- data_sim_mfd()
inprod_mfd_diag(mfdobj)

</code></pre>

<hr>
<h2 id='is.mfd'>Confirm Object has Class <code>mfd</code></h2><span id='topic+is.mfd'></span>

<h3>Description</h3>

<p>Check that an argument is a multivariate
functional data object of class <code>mfd</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.mfd(mfdobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.mfd_+3A_mfdobj">mfdobj</code></td>
<td>
<p>An object to be checked.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical value: TRUE if the class is correct, FALSE otherwise.
</p>

<hr>
<h2 id='lines_mfd'>Add the plot of a new multivariate functional data object to an existing
plot.</h2><span id='topic+lines_mfd'></span>

<h3>Description</h3>

<p>Add the plot of a new multivariate functional data object to an existing
plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lines_mfd(
  plot_mfd_obj,
  mfdobj_new,
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  na.rm = TRUE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE,
  type_mfd = "mfd",
  y_lim_equal = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lines_mfd_+3A_plot_mfd_obj">plot_mfd_obj</code></td>
<td>
<p>A plot produced by <code>link{plot_mfd}</code></p>
</td></tr>
<tr><td><code id="lines_mfd_+3A_mfdobj_new">mfdobj_new</code></td>
<td>
<p>A new multivariate functional data object of class mfd to be plotted.</p>
</td></tr>
<tr><td><code id="lines_mfd_+3A_mapping">mapping</code></td>
<td>
<p>See <code><a href="#topic+plot_mfd">plot_mfd</a></code>.</p>
</td></tr>
<tr><td><code id="lines_mfd_+3A_data">data</code></td>
<td>
<p>See <code><a href="#topic+plot_mfd">plot_mfd</a></code>.</p>
</td></tr>
<tr><td><code id="lines_mfd_+3A_stat">stat</code></td>
<td>
<p>See <code><a href="#topic+plot_mfd">plot_mfd</a></code>.</p>
</td></tr>
<tr><td><code id="lines_mfd_+3A_position">position</code></td>
<td>
<p>See <code><a href="#topic+plot_mfd">plot_mfd</a></code>.</p>
</td></tr>
<tr><td><code id="lines_mfd_+3A_na.rm">na.rm</code></td>
<td>
<p>See <code><a href="#topic+plot_mfd">plot_mfd</a></code>.</p>
</td></tr>
<tr><td><code id="lines_mfd_+3A_orientation">orientation</code></td>
<td>
<p>See <code><a href="#topic+plot_mfd">plot_mfd</a></code>.</p>
</td></tr>
<tr><td><code id="lines_mfd_+3A_show.legend">show.legend</code></td>
<td>
<p>See <code><a href="#topic+plot_mfd">plot_mfd</a></code>.</p>
</td></tr>
<tr><td><code id="lines_mfd_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>See <code><a href="#topic+plot_mfd">plot_mfd</a></code>.</p>
</td></tr>
<tr><td><code id="lines_mfd_+3A_type_mfd">type_mfd</code></td>
<td>
<p>See <code><a href="#topic+plot_mfd">plot_mfd</a></code>.</p>
</td></tr>
<tr><td><code id="lines_mfd_+3A_y_lim_equal">y_lim_equal</code></td>
<td>
<p>See <code><a href="#topic+plot_mfd">plot_mfd</a></code>.</p>
</td></tr>
<tr><td><code id="lines_mfd_+3A_...">...</code></td>
<td>
<p>See <code><a href="#topic+plot_mfd">plot_mfd</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the multivariate functional data object added to the existing
one.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(funcharts)
library(ggplot2)
mfdobj1 &lt;- data_sim_mfd()
mfdobj2 &lt;- data_sim_mfd()
p &lt;- plot_mfd(mfdobj1)
lines_mfd(p, mfdobj_new = mfdobj2)

</code></pre>

<hr>
<h2 id='mfd'>Define a Multivariate Functional Data Object</h2><span id='topic+mfd'></span>

<h3>Description</h3>

<p>This is the constructor function for objects of the mfd class.
It is a wrapper to <code>fda::<a href="fda.html#topic+fd">fd</a></code>,
but it forces the coef argument to  be
a three-dimensional array of coefficients even if
the functional data is univariate.
Moreover, it allows to include the original raw data from which
you get the smooth functional data.
Finally, it also includes the matrix of precomputed inner products
of the basis functions, which can be useful to speed up computations
when calculating inner products between functional observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mfd(coef, basisobj, fdnames = NULL, raw = NULL, id_var = NULL, B = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mfd_+3A_coef">coef</code></td>
<td>
<p>A three-dimensional array of coefficients:
</p>

<ul>
<li><p> the first dimension corresponds to basis functions.
</p>
</li>
<li><p> the second dimension corresponds to the number of
multivariate functional observations.
</p>
</li>
<li><p> the third dimension corresponds to variables.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mfd_+3A_basisobj">basisobj</code></td>
<td>
<p>A functional basis object defining the basis,
as provided to <code>fda::<a href="fda.html#topic+fd">fd</a></code>, but there is no default.</p>
</td></tr>
<tr><td><code id="mfd_+3A_fdnames">fdnames</code></td>
<td>
<p>A list of length 3, each member being a string vector
containing labels for the levels of the corresponding dimension
of the discrete data.
</p>
<p>The first dimension is for a single character indicating the argument
values,
i.e. the variable on the functional domain.
</p>
<p>The second is for replications, i.e. it denotes the functional observations.
</p>
<p>The third is for functional variables' names.</p>
</td></tr>
<tr><td><code id="mfd_+3A_raw">raw</code></td>
<td>
<p>A data frame containing the original discrete data.
Default is NULL, however, if provided, it must contain:
</p>
<p>a column (indicated by the <code>id_var</code> argument)
denoting the functional observations,
which must correspond to values in <code>fdnames[[2]]</code>,
</p>
<p>a column named as <code>fdnames[[1]]</code>,
returning the argument values of each function
</p>
<p>as many columns as the functional variables,
named as in <code>fdnames[[3]]</code>,
containing the discrete functional values for each variable.</p>
</td></tr>
<tr><td><code id="mfd_+3A_id_var">id_var</code></td>
<td>
<p>A single character value indicating the column
in the <code>raw</code> argument
containing the functional observations (as in <code>fdnames[[2]]</code>),
default is NULL.</p>
</td></tr>
<tr><td><code id="mfd_+3A_b">B</code></td>
<td>
<p>A matrix with the inner products of the basis functions.
If NULL, it is calculated from the basis object provided.
Default is NULL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To check that an object is of this class, use function is.mfd.
</p>


<h3>Value</h3>

<p>A multivariate functional data object
(i.e., having class <code>mfd</code>),
which is a list with components named
<code>coefs</code>, <code>basis</code>, and <code>fdnames</code>,
as for class <code>fd</code>,
with possibly in addition the components <code>raw</code> and <code>id_var</code>.
</p>


<h3>References</h3>

<p>Ramsay, James O., and Silverman, Bernard W. (2006),
<em>Functional Data Analysis</em>, 2nd ed., Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002),
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(funcharts)
library(fda)
set.seed(0)
nobs &lt;- 5
nbasis &lt;- 10
nvar &lt;- 2
coef &lt;- array(rnorm(nobs * nbasis * nvar), dim = c(nbasis, nobs, nvar))
bs &lt;- create.bspline.basis(rangeval = c(0, 1), nbasis = nbasis)
mfdobj &lt;- mfd(coef = coef, basisobj = bs)
plot_mfd(mfdobj)

</code></pre>

<hr>
<h2 id='norm.mfd'>Norm of Multivariate Functional Data</h2><span id='topic+norm.mfd'></span>

<h3>Description</h3>

<p>Norm of multivariate functional data contained
in a <code>mfd</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm.mfd(mfdobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norm.mfd_+3A_mfdobj">mfdobj</code></td>
<td>
<p>A multivariate functional data object of class <code>mfd</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length equal to the number of replications
in <code>mfdobj</code>,
containing the norm of each multivariate functional observation
in the product Hilbert space,
i.e. the sum of <em>L^2</em> norms for each functional variable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(funcharts)
mfdobj &lt;- data_sim_mfd()
norm.mfd(mfdobj)

</code></pre>

<hr>
<h2 id='pca_mfd'>Multivariate functional principal components analysis</h2><span id='topic+pca_mfd'></span>

<h3>Description</h3>

<p>Multivariate functional principal components analysis (MFPCA)
performed on an object of class <code>mfd</code>.
It is a wrapper to <code>fda::<a href="fda.html#topic+pca.fd">pca.fd</a></code>,
providing some additional arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pca_mfd(mfdobj, scale = TRUE, nharm = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pca_mfd_+3A_mfdobj">mfdobj</code></td>
<td>
<p>A multivariate functional data object of class mfd.</p>
</td></tr>
<tr><td><code id="pca_mfd_+3A_scale">scale</code></td>
<td>
<p>If TRUE, it scales data before doing MFPCA
using <code>scale_mfd</code>. Default is TRUE.</p>
</td></tr>
<tr><td><code id="pca_mfd_+3A_nharm">nharm</code></td>
<td>
<p>Number of multivariate functional principal components
to be calculated. Default is 20.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Modified <code>pca.fd</code> object, with
multivariate functional principal component scores summed over variables
(<code>fda::<a href="fda.html#topic+pca.fd">pca.fd</a></code> returns an array of scores
when providing a multivariate functional data object).
Moreover, the multivariate functional principal components
given in <code>harmonics</code>
are converted to the <code>mfd</code> class.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scale_mfd">scale_mfd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(funcharts)
mfdobj &lt;- data_sim_mfd()
pca_obj &lt;- pca_mfd(mfdobj)
plot_pca_mfd(pca_obj)

</code></pre>

<hr>
<h2 id='pca_mfd_real_time'>Get a list of multivariate functional principal component analysis
models estimated on functional data
each evolving up to an intermediate domain point.</h2><span id='topic+pca_mfd_real_time'></span>

<h3>Description</h3>

<p>This function produces a list of objects,
each of them contains the result of applying <code><a href="#topic+pca_mfd">pca_mfd</a></code> to
a multivariate functional data object
evolved up to an intermediate domain point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pca_mfd_real_time(mfdobj_list, scale = TRUE, nharm = 20, ncores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pca_mfd_real_time_+3A_mfdobj_list">mfdobj_list</code></td>
<td>
<p>A list created using
<code><a href="#topic+get_mfd_df_real_time">get_mfd_df_real_time</a></code> or
<code>get_mfd_list_real_time</code>, denoting a list of functional data objects,
each evolving up to an intermediate domain point,
with observations of the multivariate functional data.</p>
</td></tr>
<tr><td><code id="pca_mfd_real_time_+3A_scale">scale</code></td>
<td>
<p>See <code><a href="#topic+pca_mfd">pca_mfd</a></code>.</p>
</td></tr>
<tr><td><code id="pca_mfd_real_time_+3A_nharm">nharm</code></td>
<td>
<p>See <code><a href="#topic+pca_mfd">pca_mfd</a></code>.</p>
</td></tr>
<tr><td><code id="pca_mfd_real_time_+3A_ncores">ncores</code></td>
<td>
<p>If you want parallelization, give the number of cores/threads
to be used when creating objects separately for different instants.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of lists each produced by <code><a href="#topic+pca_mfd">pca_mfd</a></code>,
corresponding to a given instant.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pca_mfd">pca_mfd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(funcharts)
data("air")
air &lt;- lapply(air, function(x) x[1:10, , drop = FALSE])
mfdobj_list &lt;- get_mfd_list_real_time(air[c("CO", "temperature")],
                                      n_basis = 15,
                                      lambda = 1e-2,
                                      k_seq = seq(0.25, 1, length = 5))
mod_list &lt;- pca_mfd_real_time(mfdobj_list)

</code></pre>

<hr>
<h2 id='plot_bifd'>Plot a Bivariate Functional Data Object.</h2><span id='topic+plot_bifd'></span>

<h3>Description</h3>

<p>Plot an object of class <code>bifd</code> using
<code>ggplot2</code> and <code>geom_tile</code>.
The object must contain only one single functional replication.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_bifd(bifd_obj, type_plot = "raster", phi = 40, theta = 40)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_bifd_+3A_bifd_obj">bifd_obj</code></td>
<td>
<p>A bivariate functional data object of class bifd,
containing one single replication.</p>
</td></tr>
<tr><td><code id="plot_bifd_+3A_type_plot">type_plot</code></td>
<td>
<p>a character value
If &quot;raster&quot;, it plots the bivariate functional data object
as a raster image.
If &quot;contour&quot;, it produces a contour plot.
If &quot;perspective&quot;, it produces a perspective plot.
Default value is &quot;raster&quot;.</p>
</td></tr>
<tr><td><code id="plot_bifd_+3A_phi">phi</code></td>
<td>
<p>If <code>type_plot=="perspective"</code>, it is the <code>phi</code> argument
of the function <code>plot3D::persp3D</code>.</p>
</td></tr>
<tr><td><code id="plot_bifd_+3A_theta">theta</code></td>
<td>
<p>If <code>type_plot=="perspective"</code>, it is the <code>theta</code> argument
of the function <code>plot3D::persp3D</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot with a geom_tile layer providing a plot of the
bivariate functional data object as a heat map.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(funcharts)
mfdobj &lt;- data_sim_mfd(nobs = 1)
tp &lt;- tensor_product_mfd(mfdobj)
plot_bifd(tp)

</code></pre>

<hr>
<h2 id='plot_bootstrap_sof_pc'>Plot bootstrapped estimates of the scalar-on-function regression coefficient</h2><span id='topic+plot_bootstrap_sof_pc'></span>

<h3>Description</h3>

<p>Plot bootstrapped estimates of the
scalar-on-function regression coefficient
for empirical uncertainty quantification. For each iteration,
a data set is sampled with replacement
from the training data use to fit the model,
and the regression coefficient is estimated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_bootstrap_sof_pc(mod, nboot = 25, ncores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_bootstrap_sof_pc_+3A_mod">mod</code></td>
<td>
<p>A list obtained as output from <code><a href="#topic+sof_pc">sof_pc</a></code>,
i.e. a fitted scalar-on-function linear regression model.</p>
</td></tr>
<tr><td><code id="plot_bootstrap_sof_pc_+3A_nboot">nboot</code></td>
<td>
<p>Number of bootstrap replicates</p>
</td></tr>
<tr><td><code id="plot_bootstrap_sof_pc_+3A_ncores">ncores</code></td>
<td>
<p>If you want estimate the bootstrap replicates in parallel,
give the number of cores/threads.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot showing several bootstrap replicates
of the multivariate functional coefficients estimated
fitting the scalar-on-function linear model.
Gray lines indicate the different bootstrap estimates,
the black line indicate the estimate on the entire dataset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(funcharts)
data("air")
air &lt;- lapply(air, function(x) x[1:10, , drop = FALSE])
fun_covariates &lt;- c("CO", "temperature")
mfdobj_x &lt;- get_mfd_list(air[fun_covariates], lambda = 1e-2)
y &lt;- rowMeans(air$NO2)
mod &lt;- sof_pc(y, mfdobj_x)
plot_bootstrap_sof_pc(mod, nboot = 5)

</code></pre>

<hr>
<h2 id='plot_control_charts'>Plot control charts</h2><span id='topic+plot_control_charts'></span>

<h3>Description</h3>

<p>This function takes as input a data frame produced
with functions such as
<code><a href="#topic+control_charts_pca">control_charts_pca</a></code> and <code><a href="#topic+control_charts_sof_pc">control_charts_sof_pc</a></code> and
produces a ggplot with the desired control charts, i.e.
it plots a point for each
observation in the phase II data set against
the corresponding control limits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_control_charts(cclist, nobsI = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_control_charts_+3A_cclist">cclist</code></td>
<td>
<p>A <code>data.frame</code> produced by
<code><a href="#topic+control_charts_pca">control_charts_pca</a></code>, <code><a href="#topic+control_charts_sof_pc">control_charts_sof_pc</a></code>
<code><a href="#topic+regr_cc_fof">regr_cc_fof</a></code>, or <code><a href="#topic+regr_cc_sof">regr_cc_sof</a></code>.</p>
</td></tr>
<tr><td><code id="plot_control_charts_+3A_nobsi">nobsI</code></td>
<td>
<p>An integer indicating the first observations that are plotted in gray.
It is useful when one wants to plot the phase I data set together
with the phase II data. In that case, one needs to indicate the number
of phase I observations included in <code>cclist</code>.
Default is zero.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Out-of-control points are signaled by colouring them in red.
</p>


<h3>Value</h3>

<p>A ggplot with the functional control charts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(funcharts)
data("air")
air &lt;- lapply(air, function(x) x[1:100, , drop = FALSE])
fun_covariates &lt;- c("CO", "temperature")
mfdobj_x &lt;- get_mfd_list(air[fun_covariates],
                         n_basis = 15,
                         lambda = 1e-2)
mfdobj_y &lt;- get_mfd_list(air["NO2"],
                         n_basis = 15,
                         lambda = 1e-2)
mfdobj_y1 &lt;- mfdobj_y[1:60]
mfdobj_y_tuning &lt;- mfdobj_y[61:90]
mfdobj_y2 &lt;- mfdobj_y[91:100]
mfdobj_x1 &lt;- mfdobj_x[1:60]
mfdobj_x_tuning &lt;- mfdobj_x[61:90]
mfdobj_x2 &lt;- mfdobj_x[91:100]
mod_fof &lt;- fof_pc(mfdobj_y1, mfdobj_x1)
cclist &lt;- regr_cc_fof(mod_fof,
                      mfdobj_y_new = mfdobj_y2,
                      mfdobj_x_new = mfdobj_x2,
                      mfdobj_y_tuning = NULL,
                      mfdobj_x_tuning = NULL)
plot_control_charts(cclist)

</code></pre>

<hr>
<h2 id='plot_control_charts_real_time'>Plot real-time control charts</h2><span id='topic+plot_control_charts_real_time'></span>

<h3>Description</h3>

<p>This function produces a ggplot
with the desired real-time control charts.
It takes as input a list of data frames, produced
with functions such as
<code><a href="#topic+regr_cc_fof_real_time">regr_cc_fof_real_time</a></code> and
<code><a href="#topic+control_charts_sof_pc_real_time">control_charts_sof_pc_real_time</a></code>,
and the id of the observations for which real-time control charts
are desired to be plotted.
For each control chart, the solid line corresponds to the
profile of the monitoring statistic and it is compared against
control limits plotted as dashed lines.
If a line is outside its limits it is coloured in red.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_control_charts_real_time(cclist, id_num)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_control_charts_real_time_+3A_cclist">cclist</code></td>
<td>
<p>A list of data frames, produced
with functions such as
<code><a href="#topic+regr_cc_fof_real_time">regr_cc_fof_real_time</a></code> and
<code><a href="#topic+control_charts_sof_pc_real_time">control_charts_sof_pc_real_time</a></code>,</p>
</td></tr>
<tr><td><code id="plot_control_charts_real_time_+3A_id_num">id_num</code></td>
<td>
<p>An index number giving the observation in the
phase II data set to be plotted, i.e. 1 for the first observation,
2 for the second, and so on.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the line, representing the profile of the
monitoring statistic over the functional domain, is out-of-control,
then it is coloured in red.
</p>


<h3>Value</h3>

<p>A ggplot with the real-time functional control charts.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regr_cc_fof_real_time">regr_cc_fof_real_time</a></code>,
<code><a href="#topic+control_charts_sof_pc_real_time">control_charts_sof_pc_real_time</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(funcharts)
data("air")
air1 &lt;- lapply(air, function(x) x[1:8, , drop = FALSE])
air2 &lt;- lapply(air, function(x) x[9:10, , drop = FALSE])
mfdobj_x1_list &lt;- get_mfd_list_real_time(air1[c("CO", "temperature")],
                                         n_basis = 15,
                                         lambda = 1e-2,
                                         k_seq = c(0.5, 1))
mfdobj_x2_list &lt;- get_mfd_list_real_time(air2[c("CO", "temperature")],
                                         n_basis = 15,
                                         lambda = 1e-2,
                                         k_seq = c(0.5, 1))
y1 &lt;- rowMeans(air1$NO2)
y2 &lt;- rowMeans(air2$NO2)
mod_list &lt;- sof_pc_real_time(y1, mfdobj_x1_list)
cclist &lt;- regr_cc_sof_real_time(
  mod_list = mod_list,
  y_new = y2,
  mfdobj_x_new = mfdobj_x2_list,
  include_covariates = TRUE)
plot_control_charts_real_time(cclist, 1)
</code></pre>

<hr>
<h2 id='plot_mfd'>Plot a Multivariate Functional Data Object.</h2><span id='topic+plot_mfd'></span>

<h3>Description</h3>

<p>Plot an object of class <code>mfd</code> using <code>ggplot2</code>
and <code>patchwork</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_mfd(
  mfdobj,
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  na.rm = TRUE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE,
  type_mfd = "mfd",
  y_lim_equal = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_mfd_+3A_mfdobj">mfdobj</code></td>
<td>
<p>A multivariate functional data object of class mfd.</p>
</td></tr>
<tr><td><code id="plot_mfd_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings additional
to <code>x</code> and <code>y</code> as passed to the function
<code>ggplot2::geom:line</code>.</p>
</td></tr>
<tr><td><code id="plot_mfd_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> providing columns
to create additional aesthetic mappings.
It must contain a factor column &quot;id&quot; with the replication values
as in <code>mfdobj$fdnames[[2]]</code>.
If it contains a column &quot;var&quot;, this must contain
the functional variables as in <code>mfdobj$fdnames[[3]]</code>.</p>
</td></tr>
<tr><td><code id="plot_mfd_+3A_stat">stat</code></td>
<td>
<p>See <code>ggplot2::<a href="ggplot2.html#topic+geom_line">geom_line</a></code>.</p>
</td></tr>
<tr><td><code id="plot_mfd_+3A_position">position</code></td>
<td>
<p>See <code>ggplot2::<a href="ggplot2.html#topic+geom_line">geom_line</a></code>.</p>
</td></tr>
<tr><td><code id="plot_mfd_+3A_na.rm">na.rm</code></td>
<td>
<p>See <code>ggplot2::<a href="ggplot2.html#topic+geom_line">geom_line</a></code>.</p>
</td></tr>
<tr><td><code id="plot_mfd_+3A_orientation">orientation</code></td>
<td>
<p>See <code>ggplot2::<a href="ggplot2.html#topic+geom_line">geom_line</a></code>.</p>
</td></tr>
<tr><td><code id="plot_mfd_+3A_show.legend">show.legend</code></td>
<td>
<p>See <code>ggplot2::<a href="ggplot2.html#topic+geom_line">geom_line</a></code>.</p>
</td></tr>
<tr><td><code id="plot_mfd_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>See <code>ggplot2::<a href="ggplot2.html#topic+geom_line">geom_line</a></code>.</p>
</td></tr>
<tr><td><code id="plot_mfd_+3A_type_mfd">type_mfd</code></td>
<td>
<p>A character value equal to &quot;mfd&quot; or &quot;raw&quot;.
If &quot;mfd&quot;, the smoothed functional data are plotted, if &quot;raw&quot;,
the original discrete data are plotted.</p>
</td></tr>
<tr><td><code id="plot_mfd_+3A_y_lim_equal">y_lim_equal</code></td>
<td>
<p>A logical value. If <code>TRUE</code>, the limits of the y-axis
are the same for all functional variables.
If <code>FALSE</code>, limits are different for each variable.
Default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot_mfd_+3A_...">...</code></td>
<td>
<p>See <code>ggplot2::<a href="ggplot2.html#topic+geom_line">geom_line</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the multivariate functional data object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(funcharts)
library(ggplot2)
mfdobj &lt;- data_sim_mfd()
ids &lt;- mfdobj$fdnames[[2]]
df &lt;- data.frame(id = ids, first_two_obs = ids %in% c("rep1", "rep2"))
plot_mfd(mapping = aes(colour = first_two_obs),
         data = df,
         mfdobj = mfdobj)

</code></pre>

<hr>
<h2 id='plot_mon'>Plot multivariate functional object over the training data set</h2><span id='topic+plot_mon'></span>

<h3>Description</h3>

<p>This function plots selected functions in
a phase_II monitoring data set against the
corresponding training data set to be compared.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_mon(cclist, fd_train, fd_test, plot_title = FALSE, print_id = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_mon_+3A_cclist">cclist</code></td>
<td>
<p>A <code>data.frame</code> produced by
<code><a href="#topic+control_charts_pca">control_charts_pca</a></code>, <code><a href="#topic+control_charts_sof_pc">control_charts_sof_pc</a></code>
<code><a href="#topic+regr_cc_fof">regr_cc_fof</a></code>, or <code><a href="#topic+regr_cc_sof">regr_cc_sof</a></code>.</p>
</td></tr>
<tr><td><code id="plot_mon_+3A_fd_train">fd_train</code></td>
<td>
<p>An object of class <code>mfd</code> containing
the training data set of the functional variables.
They are plotted in gray in the background.</p>
</td></tr>
<tr><td><code id="plot_mon_+3A_fd_test">fd_test</code></td>
<td>
<p>An object of class <code>mfd</code> containing
the phase II data set of the functional variables to be monitored.
They are coloured in black or red on the foreground.</p>
</td></tr>
<tr><td><code id="plot_mon_+3A_plot_title">plot_title</code></td>
<td>
<p>A logical value. If <code>TRUE</code>,
it prints the title with the observation name.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot_mon_+3A_print_id">print_id</code></td>
<td>
<p>A logical value. If <code>TRUE</code>, and also <code>plot_title</code> is <code>TRUE</code>,
it prints also the id of the observation
in the title of the ggplot.
Default is <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot of the multivariate functional data.
In particular, the multivariate functional data given in
<code>fd_train</code> are plotted on
the background in gray, while the multivariate functional data given in
<code>fd_test</code> are
plotted on the foreground, the colour
of each curve is black or red depending on if that curve
was signal as anomalous by at least a contribution plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(funcharts)
data("air")
air &lt;- lapply(air, function(x) x[201:300, , drop = FALSE])
fun_covariates &lt;- c("CO", "temperature")
mfdobj_x &lt;- get_mfd_list(air[fun_covariates],
                         n_basis = 15,
                         lambda = 1e-2)
y &lt;- rowMeans(air$NO2)
y1 &lt;- y[1:60]
y_tuning &lt;- y[61:90]
y2 &lt;- y[91:100]
mfdobj_x1 &lt;- mfdobj_x[1:60]
mfdobj_x_tuning &lt;- mfdobj_x[61:90]
mfdobj_x2 &lt;- mfdobj_x[91:100]
mod &lt;- sof_pc(y1, mfdobj_x1)
cclist &lt;- regr_cc_sof(object = mod,
                      y_new = y2,
                      mfdobj_x_new = mfdobj_x2,
                      y_tuning = y_tuning,
                      mfdobj_x_tuning = mfdobj_x_tuning,
                      include_covariates = TRUE)
get_ooc(cclist)
cont_plot(cclist, 3)
plot_mon(cclist, fd_train = mfdobj_x1, fd_test = mfdobj_x2[3])

</code></pre>

<hr>
<h2 id='plot_pca_mfd'>Plot the harmonics of a <code>pca_mfd</code> object</h2><span id='topic+plot_pca_mfd'></span>

<h3>Description</h3>

<p>Plot the harmonics of a <code>pca_mfd</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_pca_mfd(pca, harm = 0, scaled = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_pca_mfd_+3A_pca">pca</code></td>
<td>
<p>A fitted multivariate functional principal component analysis
(MFPCA) object of class <code>pca_mfd</code>.</p>
</td></tr>
<tr><td><code id="plot_pca_mfd_+3A_harm">harm</code></td>
<td>
<p>A vector of integers with the harmonics to plot.
If 0, all harmonics are plotted. Default is 0.</p>
</td></tr>
<tr><td><code id="plot_pca_mfd_+3A_scaled">scaled</code></td>
<td>
<p>If TRUE, eigenfunctions are multiplied by the square root of the
corresponding eigenvalues, if FALSE the are not scaled and the
all have unit norm.
Default is FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot of the harmonics/multivariate functional
principal components contained in the object <code>pca</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(funcharts)
mfdobj &lt;- data_sim_mfd()
pca_obj &lt;- pca_mfd(mfdobj)
plot_pca_mfd(pca_obj)

</code></pre>

<hr>
<h2 id='predict_fof_pc'>Use a function-on-function linear regression model for prediction</h2><span id='topic+predict_fof_pc'></span>

<h3>Description</h3>

<p>Predict new observations of the functional response variable
and calculate the corresponding prediction error
(and their standardized or studentized version)
given new observations of functional covariates and
a fitted function-on-function linear regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_fof_pc(object, mfdobj_y_new, mfdobj_x_new)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_fof_pc_+3A_object">object</code></td>
<td>
<p>A list obtained as output from <code>fof_pc</code>,
i.e. a fitted function-on-function linear regression model.</p>
</td></tr>
<tr><td><code id="predict_fof_pc_+3A_mfdobj_y_new">mfdobj_y_new</code></td>
<td>
<p>An object of class <code>mfd</code> containing
new observations of the functional response.</p>
</td></tr>
<tr><td><code id="predict_fof_pc_+3A_mfdobj_x_new">mfdobj_x_new</code></td>
<td>
<p>An object of class <code>mfd</code> containing
new observations of the functional covariates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of mfd objects. It contains:
</p>

<ul>
<li> <p><code>pred_error</code>: the prediction error of the
standardized functional response variable,
</p>
</li>
<li> <p><code>pred_error_original_scale</code>:
the prediction error of the functional
response variable on the original scale,
</p>
</li>
<li> <p><code>y_hat_new</code>: the prediction of the
functional response observations on the original scale,
</p>
</li>
<li> <p><code>y_z_new</code>: the standardized version of the
functional response observations provided in <code>mfdobj_y_new</code>,
</p>
</li>
<li> <p><code>y_hat_z_new</code>: the prediction of the
functional response observations on the standardized/studentized scale.
</p>
</li></ul>



<h3>References</h3>

<p>Centofanti F, Lepore A, Menafoglio A, Palumbo B, Vantini S. (2021)
Functional Regression Control Chart.
<em>Technometrics</em>, 63(3), 281&ndash;294. <a href="doi:10.1080/00401706.2020.1753581">doi:10.1080/00401706.2020.1753581</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(funcharts)
data("air")
air &lt;- lapply(air, function(x) x[1:10, , drop = FALSE])
fun_covariates &lt;- c("CO", "temperature")
mfdobj_x &lt;- get_mfd_list(air[fun_covariates], lambda = 1e-2)
mfdobj_y &lt;- get_mfd_list(air["NO2"], lambda = 1e-2)
mod &lt;- fof_pc(mfdobj_y, mfdobj_x)
predict_fof_pc(mod,
               mfdobj_y_new = mfdobj_y,
               mfdobj_x_new = mfdobj_x)
</code></pre>

<hr>
<h2 id='predict_sof_pc'>Use a scalar-on-function linear regression model for prediction</h2><span id='topic+predict_sof_pc'></span>

<h3>Description</h3>

<p>Predict new observations of the scalar response variable
and calculate the corresponding prediction error,
with prediction interval limits,
given new observations of functional covariates and
a fitted scalar-on-function linear regression model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_sof_pc(
  object,
  y_new = NULL,
  mfdobj_x_new = NULL,
  alpha = 0.05,
  newdata
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_sof_pc_+3A_object">object</code></td>
<td>
<p>A list obtained as output from <code>sof_pc</code>,
i.e. a fitted scalar-on-function linear regression model.</p>
</td></tr>
<tr><td><code id="predict_sof_pc_+3A_y_new">y_new</code></td>
<td>
<p>A numeric vector containing the new observations of
the scalar response variable
to be predicted.</p>
</td></tr>
<tr><td><code id="predict_sof_pc_+3A_mfdobj_x_new">mfdobj_x_new</code></td>
<td>
<p>An object of class <code>mfd</code> containing
new observations of the functional covariates.
If NULL, it is set as the functional covariates data used for model fitting.</p>
</td></tr>
<tr><td><code id="predict_sof_pc_+3A_alpha">alpha</code></td>
<td>
<p>A numeric value indicating the Type I error
for the regression control chart
and such that this function returns the <code>1-alpha</code>
prediction interval on the response.
Default is 0.05.</p>
</td></tr>
<tr><td><code id="predict_sof_pc_+3A_newdata">newdata</code></td>
<td>
<p>Deprecated, use <code>mfdobj_x_new</code> argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with as many rows as the
number of functional replications in <code>newdata</code>,
with the following columns:
</p>

<ul>
<li> <p><code>fit</code>: the predictions of the response variable
corresponding to <code>new_data</code>,
</p>
</li>
<li> <p><code>lwr</code>:
lower limit of the <code>1-alpha</code> prediction interval
on the response, based on the assumption that it is normally distributed.
</p>
</li>
<li> <p><code>upr</code>:
upper limit of the <code>1-alpha</code> prediction interval
on the response, based on the assumption that it is normally distributed.
</p>
</li>
<li> <p><code>res</code>:
the residuals obtained as the values of <code>y_new</code> minus their
fitted values. If the scalar-on-function model has been fitted with
<code>type_residual == "studentized"</code>, then the studentized residuals
are calculated.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(funcharts)
data("air")
air &lt;- lapply(air, function(x) x[1:10, , drop = FALSE])
fun_covariates &lt;- c("CO", "temperature")
mfdobj_x &lt;- get_mfd_list(air[fun_covariates], lambda = 1e-2)
y &lt;- rowMeans(air$NO2)
mod &lt;- sof_pc(y, mfdobj_x)
predict_sof_pc(mod)

</code></pre>

<hr>
<h2 id='rbind_mfd'>Bind replications of two Multivariate Functional Data Objects</h2><span id='topic+rbind_mfd'></span>

<h3>Description</h3>

<p>Bind replications of two Multivariate Functional Data Objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbind_mfd(mfdobj1, mfdobj2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbind_mfd_+3A_mfdobj1">mfdobj1</code></td>
<td>
<p>An object of class mfd, with the same variables of mfdobj2
and different replication names with respect to mfdobj2.</p>
</td></tr>
<tr><td><code id="rbind_mfd_+3A_mfdobj2">mfdobj2</code></td>
<td>
<p>An object of class mfd, with the same variables of mfdobj1,
and different replication names with respect to mfdobj1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class mfd, whose variables are the same of mfdobj1 and
mfdobj2 and whose replications are the union of the replications
in mfdobj1 and mfdobj2.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(funcharts)
mfdobj1 &lt;- data_sim_mfd(nvar = 3, nobs = 4)
mfdobj2 &lt;- data_sim_mfd(nvar = 3, nobs = 5)
dimnames(mfdobj2$coefs)[[2]] &lt;-
  mfdobj2$fdnames[[2]] &lt;-
  c("rep11", "rep12", "rep13", "rep14", "rep15")
mfdobj_rbind &lt;- rbind_mfd(mfdobj1, mfdobj2)
plot_mfd(mfdobj_rbind)

</code></pre>

<hr>
<h2 id='regr_cc_fof'>Functional Regression Control Chart</h2><span id='topic+regr_cc_fof'></span>

<h3>Description</h3>

<p>It builds a data frame needed to plot the
Functional Regression Control Chart
introduced in Centofanti et al. (2021),
for monitoring a functional quality characteristic adjusted for
by the effect of multivariate functional covariates,
based on a fitted
function-on-function linear regression model.
The training data have already been used to fit the model.
An optional tuning data set can be provided that is used to estimate
the control chart limits.
A phase II data set contains the observations to be monitored
with the control charts.
It also allows to jointly monitor the multivariate functional covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regr_cc_fof(
  object,
  mfdobj_y_new,
  mfdobj_x_new,
  mfdobj_y_tuning = NULL,
  mfdobj_x_tuning = NULL,
  alpha = 0.05,
  include_covariates = FALSE,
  absolute_error = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regr_cc_fof_+3A_object">object</code></td>
<td>
<p>A list obtained as output from <code>fof_pc</code>,
i.e. a fitted function-on-function linear regression model.</p>
</td></tr>
<tr><td><code id="regr_cc_fof_+3A_mfdobj_y_new">mfdobj_y_new</code></td>
<td>
<p>An object of class <code>mfd</code> containing
the phase II data set of the functional response
observations to be monitored.</p>
</td></tr>
<tr><td><code id="regr_cc_fof_+3A_mfdobj_x_new">mfdobj_x_new</code></td>
<td>
<p>An object of class <code>mfd</code> containing
the phase II data set of the functional covariates
observations to be monitored.</p>
</td></tr>
<tr><td><code id="regr_cc_fof_+3A_mfdobj_y_tuning">mfdobj_y_tuning</code></td>
<td>
<p>An object of class <code>mfd</code> containing
the tuning data set of the functional response observations,
used to estimate the control chart limits.
If NULL, the training data, i.e. the data used to fit the
function-on-function linear regression model,
are also used as the tuning data set, i.e.
<code>mfdobj_y_tuning=object$pca_y$data</code>.
Default is NULL.</p>
</td></tr>
<tr><td><code id="regr_cc_fof_+3A_mfdobj_x_tuning">mfdobj_x_tuning</code></td>
<td>
<p>An object of class <code>mfd</code> containing
the tuning data set of the functional covariates observations,
used to estimate the control chart limits.
If NULL, the training data, i.e. the data used to fit the
function-on-function linear regression model,
are also used as the tuning data set, i.e.
<code>mfdobj_x_tuning=object$pca_x$data</code>.
Default is NULL.</p>
</td></tr>
<tr><td><code id="regr_cc_fof_+3A_alpha">alpha</code></td>
<td>
<p>If it is a number between 0 and 1,
it defines the overall type-I error probability.
By default, it is equal to 0.05 and the Bonferroni correction
is applied by setting the type-I error probabilities equal to
<code>alpha/2</code> in the Hotelling's T2 and SPE control charts.
If <code>include_covariates</code> is <code>TRUE</code>, i.e.,
the Hotelling's T2 and SPE control charts are built
also on the multivariate functional covariates, then the Bonferroni
correction is applied by setting the type-I error probability
in the four control charts equal to <code>alpha/4</code>.
If you want to set manually the Type-I error probabilities,
then the argument <code>alpha</code> must be a named list
with elements named as <code>T2</code>, <code>spe</code>,
<code>T2_x</code> and, <code>spe_x</code>, respectively, containing
the desired Type I error probability of
the T2 and SPE control charts for the functional response and
the multivariate functional covariates, respectively.</p>
</td></tr>
<tr><td><code id="regr_cc_fof_+3A_include_covariates">include_covariates</code></td>
<td>
<p>If TRUE, also functional covariates are monitored through
<code>control_charts_pca</code>,.
If FALSE, only the functional response, conditionally on the covariates,
is monitored.</p>
</td></tr>
<tr><td><code id="regr_cc_fof_+3A_absolute_error">absolute_error</code></td>
<td>
<p>A logical value that, if <code>include_covariates</code> is TRUE, is passed
to <code><a href="#topic+control_charts_pca">control_charts_pca</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> containing the output of the
function <code>control_charts_pca</code> applied to
the prediction errors.
</p>


<h3>References</h3>

<p>Centofanti F, Lepore A, Menafoglio A, Palumbo B, Vantini S. (2021)
Functional Regression Control Chart.
<em>Technometrics</em>, 63(3), 281&ndash;294. <a href="doi:10.1080/00401706.2020.1753581">doi:10.1080/00401706.2020.1753581</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+control_charts_pca">control_charts_pca</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(funcharts)
data("air")
air &lt;- lapply(air, function(x) x[1:100, , drop = FALSE])
fun_covariates &lt;- c("CO", "temperature")
mfdobj_x &lt;- get_mfd_list(air[fun_covariates],
                         n_basis = 15,
                         lambda = 1e-2)
mfdobj_y &lt;- get_mfd_list(air["NO2"],
                         n_basis = 15,
                         lambda = 1e-2)
mfdobj_y1 &lt;- mfdobj_y[1:60]
mfdobj_y_tuning &lt;- mfdobj_y[61:90]
mfdobj_y2 &lt;- mfdobj_y[91:100]
mfdobj_x1 &lt;- mfdobj_x[1:60]
mfdobj_x_tuning &lt;- mfdobj_x[61:90]
mfdobj_x2 &lt;- mfdobj_x[91:100]
mod_fof &lt;- fof_pc(mfdobj_y1, mfdobj_x1)
cclist &lt;- regr_cc_fof(mod_fof,
                      mfdobj_y_new = mfdobj_y2,
                      mfdobj_x_new = mfdobj_x2,
                      mfdobj_y_tuning = NULL,
                      mfdobj_x_tuning = NULL)
plot_control_charts(cclist)

</code></pre>

<hr>
<h2 id='regr_cc_fof_real_time'>Real-time functional regression control chart</h2><span id='topic+regr_cc_fof_real_time'></span>

<h3>Description</h3>

<p>This function produces a list of data frames,
each of them is produced by <code><a href="#topic+regr_cc_fof">regr_cc_fof</a></code>
and is needed to plot control charts for monitoring in real time
a functional quality characteristic adjusted for
by the effect of multivariate functional covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regr_cc_fof_real_time(
  mod_list,
  mfdobj_y_new_list,
  mfdobj_x_new_list,
  mfdobj_y_tuning_list = NULL,
  mfdobj_x_tuning_list = NULL,
  alpha = 0.05,
  include_covariates = FALSE,
  absolute_error = FALSE,
  ncores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regr_cc_fof_real_time_+3A_mod_list">mod_list</code></td>
<td>
<p>A list of lists produced by <code><a href="#topic+fof_pc_real_time">fof_pc_real_time</a></code>,
containing a list of function-on-function linear regression models estimated
on functional data each evolving up to an intermediate domain point.</p>
</td></tr>
<tr><td><code id="regr_cc_fof_real_time_+3A_mfdobj_y_new_list">mfdobj_y_new_list</code></td>
<td>
<p>A list created using
<code><a href="#topic+get_mfd_df_real_time">get_mfd_df_real_time</a></code> or
<code>get_mfd_list_real_time</code>, denoting a list of functional data objects
in the phase II monitoring data set,
each evolving up to an intermediate domain point,
with observations of the functional response variable
The length of this list and <code>mod_list</code> must be equal,
and their elements in the same position in the list
must correspond to the same intermediate domain point.</p>
</td></tr>
<tr><td><code id="regr_cc_fof_real_time_+3A_mfdobj_x_new_list">mfdobj_x_new_list</code></td>
<td>
<p>A list created using
<code><a href="#topic+get_mfd_df_real_time">get_mfd_df_real_time</a></code> or
<code>get_mfd_list_real_time</code>, denoting a list of functional data objects
in the phase II monitoring data set,
each evolving up to an intermediate domain point,
with observations of the multivariate functional covariates.
The length of this list and <code>mod_list</code> must be equal,
and their elements in the same position in the list
must correspond to the same intermediate domain point.</p>
</td></tr>
<tr><td><code id="regr_cc_fof_real_time_+3A_mfdobj_y_tuning_list">mfdobj_y_tuning_list</code></td>
<td>
<p>A list created using
<code><a href="#topic+get_mfd_df_real_time">get_mfd_df_real_time</a></code> or
<code>get_mfd_list_real_time</code>, denoting a list of functional data objects
in the tuning data set (used to estimate control chart limits),
each evolving up to an intermediate domain point,
with observations of the functional response variable.
The length of this list and <code>mod_list</code> must be equal,
and their elements in the same position in the list
must correspond to the same intermediate domain point.
If NULL, the training data, i.e. the functional response
in <code>mod_list</code>,
is also used as the tuning data set.
Default is NULL.</p>
</td></tr>
<tr><td><code id="regr_cc_fof_real_time_+3A_mfdobj_x_tuning_list">mfdobj_x_tuning_list</code></td>
<td>
<p>A list created using
<code><a href="#topic+get_mfd_df_real_time">get_mfd_df_real_time</a></code> or
<code>get_mfd_list_real_time</code>, denoting a list of functional data objects
in the tuning data set (used to estimate control chart limits),
each evolving up to an intermediate domain point,
with observations of the multivariate functional covariates.
The length of this list and <code>mod_list</code> must be equal,
and their elements in the same position in the list
must correspond to the same intermediate domain point.
If NULL, the training data, i.e. the functional covariates
in <code>mod_list</code>,
are also used as the tuning data set.
Default is NULL.</p>
</td></tr>
<tr><td><code id="regr_cc_fof_real_time_+3A_alpha">alpha</code></td>
<td>
<p>See <code><a href="#topic+regr_cc_fof">regr_cc_fof</a></code>.</p>
</td></tr>
<tr><td><code id="regr_cc_fof_real_time_+3A_include_covariates">include_covariates</code></td>
<td>
<p>See <code><a href="#topic+regr_cc_fof">regr_cc_fof</a></code>.</p>
</td></tr>
<tr><td><code id="regr_cc_fof_real_time_+3A_absolute_error">absolute_error</code></td>
<td>
<p>See <code><a href="#topic+regr_cc_fof">regr_cc_fof</a></code>.</p>
</td></tr>
<tr><td><code id="regr_cc_fof_real_time_+3A_ncores">ncores</code></td>
<td>
<p>If you want parallelization, give the number of cores/threads
to be used when creating objects separately for different instants.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>data.frame</code>s each
produced by <code><a href="#topic+regr_cc_fof">regr_cc_fof</a></code>,
corresponding to a given instant.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fof_pc_real_time">fof_pc_real_time</a></code>, <code><a href="#topic+regr_cc_fof">regr_cc_fof</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(funcharts)
data("air")
air1 &lt;- lapply(air, function(x) x[1:8, , drop = FALSE])
air2 &lt;- lapply(air, function(x) x[9:10, , drop = FALSE])
mfdobj_x1_list &lt;- get_mfd_list_real_time(air1[c("CO", "temperature")],
                                         n_basis = 15,
                                         lambda = 1e-2,
                                         k_seq = c(0.5, 1))
mfdobj_x2_list &lt;- get_mfd_list_real_time(air2[c("CO", "temperature")],
                                         n_basis = 15,
                                         lambda = 1e-2,
                                         k_seq = c(0.5, 1))
mfdobj_y1_list &lt;- get_mfd_list_real_time(air1["NO2"],
                                         n_basis = 15,
                                         lambda = 1e-2,
                                         k_seq = c(0.5, 1))
mfdobj_y2_list &lt;- get_mfd_list_real_time(air2["NO2"],
                                         n_basis = 15,
                                         lambda = 1e-2,
                                         k_seq = c(0.5, 1))
mod_list &lt;- fof_pc_real_time(mfdobj_y1_list, mfdobj_x1_list)
cclist &lt;- regr_cc_fof_real_time(
  mod_list = mod_list,
  mfdobj_y_new_list = mfdobj_y2_list,
  mfdobj_x_new_list = mfdobj_x2_list)
plot_control_charts_real_time(cclist, 1)

</code></pre>

<hr>
<h2 id='regr_cc_sof'>Scalar-on-Function Regression Control Chart</h2><span id='topic+regr_cc_sof'></span>

<h3>Description</h3>

<p>This function is deprecated. Use <code><a href="#topic+regr_cc_sof">regr_cc_sof</a></code>.
This function builds a data frame needed
to plot the scalar-on-function regression control chart,
based on a fitted function-on-function linear regression model and
proposed in Capezza et al. (2020).
If <code>include_covariates</code> is <code>TRUE</code>,
it also plots the Hotelling's T2 and
squared prediction error control charts built on the
multivariate functional covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regr_cc_sof(
  object,
  y_new,
  mfdobj_x_new,
  y_tuning = NULL,
  mfdobj_x_tuning = NULL,
  alpha = 0.05,
  parametric_limits = FALSE,
  include_covariates = FALSE,
  absolute_error = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regr_cc_sof_+3A_object">object</code></td>
<td>
<p>A list obtained as output from <code>sof_pc</code>,
i.e. a fitted scalar-on-function linear regression model.</p>
</td></tr>
<tr><td><code id="regr_cc_sof_+3A_y_new">y_new</code></td>
<td>
<p>A numeric vector containing the observations of
the scalar response variable
in the phase II data set.</p>
</td></tr>
<tr><td><code id="regr_cc_sof_+3A_mfdobj_x_new">mfdobj_x_new</code></td>
<td>
<p>An object of class <code>mfd</code> containing
the phase II data set of the functional covariates observations.</p>
</td></tr>
<tr><td><code id="regr_cc_sof_+3A_y_tuning">y_tuning</code></td>
<td>
<p>A numeric vector containing the observations of the scalar response
variable in the tuning data set.
If NULL, the training data, i.e. the data used to
fit the scalar-on-function regression model,
are also used as the tuning data set.
Default is NULL.</p>
</td></tr>
<tr><td><code id="regr_cc_sof_+3A_mfdobj_x_tuning">mfdobj_x_tuning</code></td>
<td>
<p>An object of class <code>mfd</code> containing
the tuning set of the multivariate functional data, used to estimate the
control chart limits.
If NULL, the training data, i.e. the data used to
fit the scalar-on-function regression model,
are also used as the tuning data set.
Default is NULL.</p>
</td></tr>
<tr><td><code id="regr_cc_sof_+3A_alpha">alpha</code></td>
<td>
<p>If it is a number between 0 and 1,
it defines the overall type-I error probability.
If <code>include_covariates</code> is <code>TRUE</code>, i.e.,
also the Hotelling's T2 and SPE control charts are built
on the functional covariates, then the Bonferroni
correction is applied by setting the type-I error probability
in the three control charts equal to <code>alpha/3</code>.
In this last case,
if you want to set manually the Type-I error probabilities,
then the argument <code>alpha</code> must be a named list
with three elements, named <code>T2</code>, <code>spe</code> and <code>y</code>,
respectively, each containing
the desired Type I error probability of
the corresponding control chart, where <code>y</code> refers to the
regression control chart.
Default value is 0.05.</p>
</td></tr>
<tr><td><code id="regr_cc_sof_+3A_parametric_limits">parametric_limits</code></td>
<td>
<p>If <code>TRUE</code>, the limits are calculated based on the normal distribution
assumption on the response variable, as in Capezza et al. (2020).
If <code>FALSE</code>, the limits are calculated nonparametrically as
empirical quantiles of the distribution of the residuals calculated
on the tuning data set.
The default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="regr_cc_sof_+3A_include_covariates">include_covariates</code></td>
<td>
<p>If TRUE, also functional covariates are monitored through
<code>control_charts_pca</code>,.
If FALSE, only the scalar response, conditionally on the covariates,
is monitored.</p>
</td></tr>
<tr><td><code id="regr_cc_sof_+3A_absolute_error">absolute_error</code></td>
<td>
<p>A logical value that, if <code>include_covariates</code> is TRUE, is passed
to <code><a href="#topic+control_charts_pca">control_charts_pca</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The training data have already been used to fit the model.
An additional tuning data set can be provided that is used to estimate
the control chart limits.
A phase II data set contains the observations to be monitored
with the built control charts.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with as many rows as the
number of functional replications in <code>mfdobj_x_new</code>,
with the following columns:
</p>

<ul>
<li> <p><code>y_hat</code>: the predictions of the response variable
corresponding to <code>mfdobj_x_new</code>,
</p>
</li>
<li> <p><code>y</code>: the same as the argument <code>y_new</code> given as input
to this function,
</p>
</li>
<li> <p><code>lwr</code>: lower limit of the <code>1-alpha</code> prediction interval
on the response,
</p>
</li>
<li> <p><code>pred_err</code>: prediction error calculated as <code>y-y_hat</code>,
</p>
</li>
<li> <p><code>pred_err_sup</code>: upper limit of the <code>1-alpha</code> prediction interval
on the prediction error,
</p>
</li>
<li> <p><code>pred_err_inf</code>: lower limit of the <code>1-alpha</code> prediction interval
on the prediction error.
</p>
</li></ul>



<h3>References</h3>

<p>Capezza C, Lepore A, Menafoglio A, Palumbo B, Vantini S. (2020)
Control charts for
monitoring ship operating conditions and CO2 emissions
based on scalar-on-function regression.
<em>Applied Stochastic Models in Business and Industry</em>,
36(3):477&ndash;500.
<a href="doi:10.1002/asmb.2507">doi:10.1002/asmb.2507</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(funcharts)
air &lt;- lapply(air, function(x) x[1:100, , drop = FALSE])
fun_covariates &lt;- c("CO", "temperature")
mfdobj_x &lt;- get_mfd_list(air[fun_covariates],
                         n_basis = 15,
                         lambda = 1e-2)
y &lt;- rowMeans(air$NO2)
y1 &lt;- y[1:80]
y2 &lt;- y[81:100]
mfdobj_x1 &lt;- mfdobj_x[1:80]
mfdobj_x2 &lt;- mfdobj_x[81:100]
mod &lt;- sof_pc(y1, mfdobj_x1)
cclist &lt;- regr_cc_sof(object = mod,
                      y_new = y2,
                      mfdobj_x_new = mfdobj_x2)
plot_control_charts(cclist)

</code></pre>

<hr>
<h2 id='regr_cc_sof_real_time'>Real-time Scalar-on-Function Regression Control Chart</h2><span id='topic+regr_cc_sof_real_time'></span>

<h3>Description</h3>

<p>This function builds a list of data frames,
each of them is produced by <code><a href="#topic+regr_cc_sof">regr_cc_sof</a></code>
and is needed to plot control charts for monitoring in real time
a scalar quality characteristic adjusted for
by the effect of multivariate functional covariates.
The training data have already been used to fit the model.
An additional tuning data set can be provided that is used to estimate
the control chart limits.
A phase II data set contains the observations to be monitored
with the built control charts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regr_cc_sof_real_time(
  mod_list,
  y_new,
  mfdobj_x_new_list,
  y_tuning = NULL,
  mfdobj_x_tuning_list = NULL,
  alpha = 0.05,
  parametric_limits = TRUE,
  include_covariates = FALSE,
  absolute_error = FALSE,
  ncores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regr_cc_sof_real_time_+3A_mod_list">mod_list</code></td>
<td>
<p>A list of lists produced by <code><a href="#topic+sof_pc_real_time">sof_pc_real_time</a></code>,
containing a list of scalar-on-function linear regression models estimated
on functional data each evolving up to an intermediate domain point.</p>
</td></tr>
<tr><td><code id="regr_cc_sof_real_time_+3A_y_new">y_new</code></td>
<td>
<p>A numeric vector containing the observations of
the scalar response variable in the phase II monitoring data set.</p>
</td></tr>
<tr><td><code id="regr_cc_sof_real_time_+3A_mfdobj_x_new_list">mfdobj_x_new_list</code></td>
<td>
<p>A list created using
<code><a href="#topic+get_mfd_df_real_time">get_mfd_df_real_time</a></code> or
<code>get_mfd_list_real_time</code>, denoting a list of functional data objects
in the phase II monitoring data set,
each evolving up to an intermediate domain point,
with observations of the multivariate functional covariates.
The length of this list and <code>mod_list</code> must be equal,
and their elements in the same position in the list
must correspond to the same intermediate domain point.</p>
</td></tr>
<tr><td><code id="regr_cc_sof_real_time_+3A_y_tuning">y_tuning</code></td>
<td>
<p>An optional numeric vector containing the observations of
the scalar response variable in the tuning data set.
If NULL, the training data, i.e. the scalar response
in <code>mod_list</code>,
is also used as the tuning data set.
Default is NULL.</p>
</td></tr>
<tr><td><code id="regr_cc_sof_real_time_+3A_mfdobj_x_tuning_list">mfdobj_x_tuning_list</code></td>
<td>
<p>A list created using
<code><a href="#topic+get_mfd_df_real_time">get_mfd_df_real_time</a></code> or
<code>get_mfd_list_real_time</code>, denoting a list of functional data objects
in the tuning data set (used to estimate control chart limits),
each evolving up to an intermediate domain point,
with observations of the multivariate functional covariates.
The length of this list and <code>mod_list</code> must be equal,
and their elements in the same position in the list
must correspond to the same intermediate domain point.
If NULL, the training data, i.e. the functional covariates
in <code>mod_list</code>,
are also used as the tuning data set.
Default is NULL.</p>
</td></tr>
<tr><td><code id="regr_cc_sof_real_time_+3A_alpha">alpha</code></td>
<td>
<p>See <code><a href="#topic+regr_cc_sof">regr_cc_sof</a></code>.</p>
</td></tr>
<tr><td><code id="regr_cc_sof_real_time_+3A_parametric_limits">parametric_limits</code></td>
<td>
<p>See <code><a href="#topic+regr_cc_sof">regr_cc_sof</a></code>.</p>
</td></tr>
<tr><td><code id="regr_cc_sof_real_time_+3A_include_covariates">include_covariates</code></td>
<td>
<p>See <code><a href="#topic+regr_cc_sof">regr_cc_sof</a></code>.</p>
</td></tr>
<tr><td><code id="regr_cc_sof_real_time_+3A_absolute_error">absolute_error</code></td>
<td>
<p>See <code><a href="#topic+regr_cc_sof">regr_cc_sof</a></code>.</p>
</td></tr>
<tr><td><code id="regr_cc_sof_real_time_+3A_ncores">ncores</code></td>
<td>
<p>If you want parallelization, give the number of cores/threads
to be used when creating objects separately for different instants.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>data.frame</code>s each
produced by <code><a href="#topic+regr_cc_sof">regr_cc_sof</a></code>,
corresponding to a given instant.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sof_pc_real_time">sof_pc_real_time</a></code>, <code><a href="#topic+regr_cc_sof">regr_cc_sof</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(funcharts)
data("air")
air1 &lt;- lapply(air, function(x) x[1:8, , drop = FALSE])
air2 &lt;- lapply(air, function(x) x[9:10, , drop = FALSE])
mfdobj_x1_list &lt;- get_mfd_list_real_time(air1[c("CO", "temperature")],
                                         n_basis = 15,
                                         lambda = 1e-2,
                                         k_seq = c(0.5, 1))
mfdobj_x2_list &lt;- get_mfd_list_real_time(air2[c("CO", "temperature")],
                                         n_basis = 15,
                                         lambda = 1e-2,
                                         k_seq = c(0.5, 1))
mfdobj_y1_list &lt;- get_mfd_list_real_time(air1["NO2"],
                                         n_basis = 15,
                                         lambda = 1e-2,
                                         k_seq = c(0.5, 1))
mfdobj_y2_list &lt;- get_mfd_list_real_time(air2["NO2"],
                                         n_basis = 15,
                                         lambda = 1e-2,
                                         k_seq = c(0.5, 1))
mod_list &lt;- fof_pc_real_time(mfdobj_y1_list, mfdobj_x1_list)
cclist &lt;- regr_cc_fof_real_time(
  mod_list = mod_list,
  mfdobj_y_new_list = mfdobj_y2_list,
  mfdobj_x_new_list = mfdobj_x2_list)
plot_control_charts_real_time(cclist, 1)

</code></pre>

<hr>
<h2 id='RoMFCC_PhaseI'>Robust Multivariate Functional Control Charts - Phase I</h2><span id='topic+RoMFCC_PhaseI'></span>

<h3>Description</h3>

<p>It performs Phase I of the Robust Multivariate Functional Control Chart
(RoMFCC) as proposed by Capezza et al. (2022).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RoMFCC_PhaseI(
  mfdobj,
  mfdobj_tuning = NULL,
  functional_filter_par = list(filter = TRUE),
  imputation_par = list(method_imputation = "RoMFDI"),
  pca_par = list(fev = 0.7),
  alpha = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RoMFCC_PhaseI_+3A_mfdobj">mfdobj</code></td>
<td>
<p>A multivariate functional data object of class mfd.
A functional filter is applied to this data set, then
flagged functional componentwise outliers are imputed in the
robust imputation step.
Finally robust multivariate functional principal component analysis
is applied to the imputed data set for dimension reduction.</p>
</td></tr>
<tr><td><code id="RoMFCC_PhaseI_+3A_mfdobj_tuning">mfdobj_tuning</code></td>
<td>
<p>An additional functional data object of class mfd.
After applying the filter and imputation steps on this data set,
it is used to robustly estimate the distribution of the Hotelling's T2 and
SPE statistics in order to calculate control limits
to prevent overfitting issues that could reduce the
monitoring performance of the RoMFCC.
Default is NULL, but it is strongly recommended to use a tuning data set.</p>
</td></tr>
<tr><td><code id="RoMFCC_PhaseI_+3A_functional_filter_par">functional_filter_par</code></td>
<td>
<p>A list with an argument <code>filter</code> that can be TRUE or FALSE depending
on if the functional filter step must be performed or not.
All the other arguments of this list are passed as arguments to the function
<code>functional_filter</code> in the filtering step.
All the arguments that are not passed take their default values.
See <code><a href="#topic+functional_filter">functional_filter</a></code> for all the arguments and their default
values.
Default is <code>list(filter = TRUE)</code>.</p>
</td></tr>
<tr><td><code id="RoMFCC_PhaseI_+3A_imputation_par">imputation_par</code></td>
<td>
<p>A list with an argument <code>method_imputation</code>
that can be <code>"RoMFDI"</code> or <code>"mean"</code> depending
on if the imputation step must be done by means of <code><a href="#topic+RoMFDI">RoMFDI</a></code> or
by just using the mean of each functional variable.
If <code>method_imputation = "RoMFDI"</code>,
all the other arguments of this list are passed as arguments to the function
<code>RoMFDI</code> in the imputation step.
All the arguments that are not passed take their default values.
See <code><a href="#topic+RoMFDI">RoMFDI</a></code> for all the arguments and their default
values.
Default value is <code>list(method_imputation = "RoMFDI")</code>.</p>
</td></tr>
<tr><td><code id="RoMFCC_PhaseI_+3A_pca_par">pca_par</code></td>
<td>
<p>A list with an argument <code>fev</code>, indicating a number between 0 and 1
denoting the fraction of variability that must be explained by the
principal components to be selected in the RoMFPCA step.
All the other arguments of this list are passed as arguments to the function
<code>rpca_mfd</code> in the RoMFPCA step.
All the arguments that are not passed take their default values.
See <code><a href="#topic+rpca_mfd">rpca_mfd</a></code> for all the arguments and their default
values.
Default value is <code>list(fev = 0.7)</code>.</p>
</td></tr>
<tr><td><code id="RoMFCC_PhaseI_+3A_alpha">alpha</code></td>
<td>
<p>The overall nominal type-I error probability used to set
control chart limits.
Default value is 0.05.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the following elements that are needed in Phase II:
</p>

<ul>
<li> <p><code>T2</code> the Hotelling's T2 statistic values for the Phase I data set,
</p>
</li>
<li> <p><code>SPE</code> the SPE statistic values for the Phase I data set,
</p>
</li>
<li> <p><code>T2_tun</code> the Hotelling's T2 statistic values for the tuning data set,
</p>
</li>
<li> <p><code>SPE_tun</code> the SPE statistic values for the tuning data set,
</p>
</li>
<li> <p><code>T2_lim</code> the Phase II control limit of
the Hotelling's T2 control chart,
</p>
</li>
<li> <p><code>spe_lim</code> the Phase II control limit of
the SPE control chart,
</p>
</li>
<li> <p><code>tuning</code> TRUE if the tuning data set is provided, FALSE otherwise,
</p>
</li>
<li> <p><code>mod_pca</code> the final RoMFPCA model fitted on the Phase I data set,
</p>
</li>
<li> <p><code>K</code> = K the number of selected principal components,
</p>
</li>
<li> <p><code>T_T2_inv</code> if a tuning data set is provided,
it returns the inverse of the covariance matrix
of the first <code>K</code> scores, needed to calculate the Hotelling's T2
statistic for the Phase II observations.
</p>
</li>
<li> <p><code>mean_scores_tuning_rob_mean</code> if a tuning data set is provided,
it returns the robust location estimate of the scores, needed to calculate
the Hotelling's T2 and SPE
statistics for the Phase II observations.
</p>
</li></ul>



<h3>References</h3>

<p>Capezza, C., Centofanti, F., Lepore, A., Palumbo, B. (2022)
Robust Multivariate Functional Control Charts.
<em>arXiv:2207.07978v</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(funcharts)
mfdobj &lt;- get_mfd_list(air, n_basis = 5)
nobs &lt;- dim(mfdobj$coefs)[2]
set.seed(0)
ids &lt;- sample(1:nobs)
mfdobj1 &lt;- mfdobj[ids[1:100]]
mfdobj_tuning &lt;- mfdobj[ids[101:300]]
mfdobj2 &lt;- mfdobj[ids[-(1:300)]]
mod_phase1 &lt;- RoMFCC_PhaseI(mfdobj = mfdobj1,
                            mfdobj_tuning = mfdobj_tuning)
phase2 &lt;- RoMFCC_PhaseII(mfdobj_new = mfdobj2,
                         mod_phase1 = mod_phase1)
plot_control_charts(phase2)

## End(Not run)
</code></pre>

<hr>
<h2 id='RoMFCC_PhaseII'>Robust Multivariate Functional Control Charts - Phase II</h2><span id='topic+RoMFCC_PhaseII'></span>

<h3>Description</h3>

<p>It calculates the Hotelling's and SPE monitoring statistics
needed to plot the Robust Multivariate Functional Control Chart in Phase II.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RoMFCC_PhaseII(mfdobj_new, mod_phase1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RoMFCC_PhaseII_+3A_mfdobj_new">mfdobj_new</code></td>
<td>
<p>A multivariate functional data object of class mfd, containing the
Phase II observations to be monitored.</p>
</td></tr>
<tr><td><code id="RoMFCC_PhaseII_+3A_mod_phase1">mod_phase1</code></td>
<td>
<p>Output obtained by applying the function <code>RoMFCC_PhaseI</code>
to perform Phase I. See <code><a href="#topic+RoMFCC_PhaseI">RoMFCC_PhaseI</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with as many rows as the number of
multivariate functional observations in the phase II data set and
the following columns:
</p>

<ul>
<li><p> one <code>id</code> column identifying the multivariate functional observation
in the phase II data set,
</p>
</li>
<li><p> one <code>T2</code> column containing the Hotelling T2 statistic
calculated for all observations,
</p>
</li>
<li><p> one column per each functional variable,
containing its contribution to the T2 statistic,
</p>
</li>
<li><p> one <code>spe</code> column containing the SPE statistic calculated
for all observations,
</p>
</li>
<li> <p><code>T2_lim</code> gives the upper control limit of
the Hotelling's T2 control chart,
</p>
</li>
<li> <p><code>spe_lim</code> gives the upper control limit of the SPE control chart
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(funcharts)
mfdobj &lt;- get_mfd_list(air, n_basis = 5)
nobs &lt;- dim(mfdobj$coefs)[2]
set.seed(0)
ids &lt;- sample(1:nobs)
mfdobj1 &lt;- mfdobj[ids[1:100]]
mfdobj_tuning &lt;- mfdobj[ids[101:300]]
mfdobj2 &lt;- mfdobj[ids[-(1:300)]]
mod_phase1 &lt;- RoMFCC_PhaseI(mfdobj = mfdobj1,
                            mfdobj_tuning = mfdobj_tuning)
phase2 &lt;- RoMFCC_PhaseII(mfdobj_new = mfdobj2,
                         mod_phase1 = mod_phase1)
plot_control_charts(phase2)

## End(Not run)
</code></pre>

<hr>
<h2 id='RoMFDI'>Robust Multivariate Functional Data Imputation (RoMFDI)</h2><span id='topic+RoMFDI'></span>

<h3>Description</h3>

<p>It performs Robust Multivariate Functional Data Imputation (RoMFDI)
as in Capezza et al. (2022).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RoMFDI(
  mfdobj,
  method_pca = "ROBPCA",
  fev = 0.999,
  n_dataset = 3,
  update = TRUE,
  niter_update = 10,
  alpha = 0.8
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RoMFDI_+3A_mfdobj">mfdobj</code></td>
<td>
<p>A multivariate functional data object of class mfd.</p>
</td></tr>
<tr><td><code id="RoMFDI_+3A_method_pca">method_pca</code></td>
<td>
<p>The method used in <code>rpca_mfd</code> to perform
robust multivariate functional principal component analysis (RoMFPCA).
See <code><a href="#topic+rpca_mfd">rpca_mfd</a></code>.
Default is <code>"ROBPCA"</code>.</p>
</td></tr>
<tr><td><code id="RoMFDI_+3A_fev">fev</code></td>
<td>
<p>Number between 0 and 1 denoting the proportion
of variability that must be explained by the
principal components to be selected for dimension reduction after
applying RoMFPCA on the observed components to impute the missing ones.
Default is 0.999.</p>
</td></tr>
<tr><td><code id="RoMFDI_+3A_n_dataset">n_dataset</code></td>
<td>
<p>To take into account the increased noise due to single imputation,
the proposed RoMFDI allows multiple imputation.
Due to the presence of the stochastic component in the imputation,
it is worth explicitly noting that the imputed data set
is not deterministically assigned.
Therefore, by performing several times the RoMFDI in the
imputation step of the
RoMFCC implementation, the corresponding multiple estimated
RoMFPCA models could
be combined by averaging the robustly estimated covariance functions,
thus performing a
multiple imputation strategy as suggested by Van Ginkel et al. (2007).
Default is 3.</p>
</td></tr>
<tr><td><code id="RoMFDI_+3A_update">update</code></td>
<td>
<p>The RoMFDI performs sequential imputation of missing functional
components.
If TRUE, Robust Multivariate Functional
Principal Component Analysis (RoMFPCA) <code>niter_update</code> is updated times
during the algorithm.
If FALSE, the RoMFPCA used for imputation is always the same, i.e.,
the one performed on the original data sets containing only
the observations with no missing functional components.
Default is TRUE.</p>
</td></tr>
<tr><td><code id="RoMFDI_+3A_niter_update">niter_update</code></td>
<td>
<p>The number of times the RoMFPCA is updated during the algorithm.
It applies only if update is TRUE. Default value is 10.</p>
</td></tr>
<tr><td><code id="RoMFDI_+3A_alpha">alpha</code></td>
<td>
<p>This parameter measures the fraction of outliers the
RoMFPCA algorithm should resist and is used only
if <code>method_pca</code> is <code>"ROBPCA"</code>.
Default is 0.8.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with <code>n_dataset</code> elements.
Each element is an <code>mfd</code> object containing <code>mfdobj</code> with
stochastic imputation of the missing components.
</p>


<h3>References</h3>

<p>Capezza, C., Centofanti, F., Lepore, A., Palumbo, B. (2022)
Robust Multivariate Functional Control Charts.
<em>arXiv:2207.07978v</em>
</p>
<p>Van Ginkel, J. R., Van der Ark, L. A., Sijtsma, K., and Vermunt, J. K.
(2007). Two-way
imputation: a bayesian method for estimating missing scores in tests
and questionnaires, and an accurate approximation.
<em>Computational Statistics &amp; Data Analysis</em>, 51(8):4013–-4027.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(funcharts)
mfdobj &lt;- get_mfd_list(air, grid = 1:24, n_basis = 13, lambda = 1e-2)
out &lt;- functional_filter(mfdobj)
mfdobj_imp &lt;- RoMFDI(out$mfdobj)

## End(Not run)

</code></pre>

<hr>
<h2 id='rpca_mfd'>Robust multivariate functional principal components analysis</h2><span id='topic+rpca_mfd'></span>

<h3>Description</h3>

<p>It performs robust MFPCA as described in Capezza et al. (2022).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpca_mfd(
  mfdobj,
  center = "fusem",
  scale = "funmad",
  nharm = 20,
  method = "ROBPCA",
  alpha = 0.8
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rpca_mfd_+3A_mfdobj">mfdobj</code></td>
<td>
<p>A multivariate functional data object of class mfd.</p>
</td></tr>
<tr><td><code id="rpca_mfd_+3A_center">center</code></td>
<td>
<p>If TRUE, it centers the data before doing MFPCA with respect
to the functional mean of the input data.
If <code>"fusem"</code>, it uses the functional M-estimator of location proposed
by Centofanti et al. (2023) to center the data.
Default is <code>"fusem"</code>.</p>
</td></tr>
<tr><td><code id="rpca_mfd_+3A_scale">scale</code></td>
<td>
<p>If <code>"funmad"</code>, it scales the data before doing MFPCA using
the functional normalized median absolute deviation estimator
proposed by Centofanti et al. (2023).
If TRUE, it scales data using <code>scale_mfd</code>.
Default is <code>"funmad"</code>.</p>
</td></tr>
<tr><td><code id="rpca_mfd_+3A_nharm">nharm</code></td>
<td>
<p>Number of multivariate functional principal components
to be calculated. Default is 20.</p>
</td></tr>
<tr><td><code id="rpca_mfd_+3A_method">method</code></td>
<td>
<p>If <code>"ROBPCA"</code>, MFPCA uses ROBPCA of Hubert et al. (2005),
as described in Capezza et al. (2022).
If <code>"Locantore"</code>, MFPCA uses the Spherical Principal Components
procedure proposed by Locantore et al. (1999).
If <code>"Proj"</code>, MFPCA uses the Robust Principal Components based on
Projection Pursuit algorithm of Croux and Ruiz-Gazen (2005).
method If <code>"normal"</code>, it uses <code>pca_mfd</code> on <code>mfdobj</code>.
Default is <code>"ROBPCA"</code>.</p>
</td></tr>
<tr><td><code id="rpca_mfd_+3A_alpha">alpha</code></td>
<td>
<p>This parameter measures the fraction of outliers the algorithm
should resist and is used only if <code>method</code> is <code>"ROBPCA"</code>.
Default is 0.8.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of <code>pca_mfd</code> class, as returned by the <code>pca_mfd</code>
function when performing non robust multivariate
functional principal component analysis.
</p>


<h3>References</h3>

<p>Capezza, C., Centofanti, F., Lepore, A., Palumbo, B. (2022)
Robust Multivariate Functional Control Charts.
<em>arXiv:2207.07978v</em>
</p>
<p>Centofanti, F., Colosimo, B.M., Grasso, M.L., Menafoglio, A., Palumbo, B.,
Vantini, S. (2023)
Robust functional ANOVA with application to additive manufacturing.
<em>Journal of the Royal Statistical Society Series C: Applied Statistics</em>
72(5), 1210–1234 <a href="doi:10.1093/jrsssc/qlad074">doi:10.1093/jrsssc/qlad074</a>
</p>
<p>Croux, C., Ruiz-Gazen, A. (2005).
High breakdown estimators for principal components: The projection-pursuit
approach revisited.
<em>Journal of Multivariate Analysis</em>, 95, 206–226,
<a href="doi:10.1016/j.jmva.2004.08.002">doi:10.1016/j.jmva.2004.08.002</a>.
</p>
<p>Hubert, M., Rousseeuw, P.J., Branden, K.V. (2005)
ROBPCA: A New Approach to Robust Principal Component Analysis,
<em>Technometrics</em> 47(1), 64&ndash;79, <a href="doi:10.1198/004017004000000563">doi:10.1198/004017004000000563</a>
</p>
<p>Locantore, N., Marron, J., Simpson, D., Tripoli, N., Zhang, J., Cohen K.,
K. (1999),
Robust principal components for functional data.
<em>Test</em>, 8, 1-28. <a href="doi:10.1007/BF02595862">doi:10.1007/BF02595862</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(funcharts)
dat &lt;- simulate_mfd(nobs = 20, p = 1, correlation_type_x = "Bessel")
mfdobj &lt;- get_mfd_list(dat$X_list, n_basis = 5)

# contaminate first observation
mfdobj$coefs[, 1, ] &lt;- mfdobj$coefs[, 1, ] + 0.05

# plot_mfd(mfdobj) # plot functions to see the outlier
# pca &lt;- pca_mfd(mfdobj) # non robust MFPCA
rpca &lt;- rpca_mfd(mfdobj) # robust MFPCA
# plot_pca_mfd(pca, harm = 1) # plot first eigenfunction, affected by outlier
# plot_pca_mfd(rpca, harm = 1) # plot first eigenfunction in robust case
</code></pre>

<hr>
<h2 id='scale_mfd'>Standardize Multivariate Functional Data.</h2><span id='topic+scale_mfd'></span>

<h3>Description</h3>

<p>Scale multivariate functional data contained
in an object of class <code>mfd</code>
by subtracting the mean function and dividing
by the standard deviation function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_mfd(mfdobj, center = TRUE, scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_mfd_+3A_mfdobj">mfdobj</code></td>
<td>
<p>A multivariate functional data object of class <code>mfd</code>.</p>
</td></tr>
<tr><td><code id="scale_mfd_+3A_center">center</code></td>
<td>
<p>A logical value, or a <code>fd</code> object.
When providing a logical value, if TRUE, <code>mfdobj</code> is centered,
i.e. the functional mean function is calculated and subtracted
from all observations in <code>mfdobj</code>,
if FALSE, <code>mfdobj</code> is not centered.
If <code>center</code> is a <code>fd</code> object, then this function
is used as functional mean for centering.</p>
</td></tr>
<tr><td><code id="scale_mfd_+3A_scale">scale</code></td>
<td>
<p>A logical value, or a <code>fd</code> object.
When providing a logical value, if TRUE, <code>mfdobj</code>
is scaled after possible centering,
i.e. the functional standard deviation is calculated
from all functional observations in <code>mfdobj</code> and
then the observations are divided by this calculated standard deviation,
if FALSE, <code>mfdobj</code> is not scaled.
If <code>scale</code> is a <code>fd</code> object,
then this function is used as standard deviation function for scaling.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function has been written to work similarly
as the function <code><a href="base.html#topic+scale">scale</a></code> for matrices.
When calculated, attributes <code>center</code> and <code>scale</code>
are of class <code>fd</code>
and have the same structure you get
when you use <code>fda::<a href="fda.html#topic+mean.fd">mean.fd</a></code>
and <code>fda::<a href="fda.html#topic+sd.fd">sd.fd</a></code>.
</p>


<h3>Value</h3>

<p>A standardized object of class <code>mfd</code>, with two attributes,
if calculated,
<code>center</code> and <code>scale</code>, storing the mean and
standard deviation functions used for standardization.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(funcharts)
mfdobj &lt;- data_sim_mfd()
mfdobj_scaled &lt;- scale_mfd(mfdobj)
</code></pre>

<hr>
<h2 id='sim_funcharts'>Simulate example data for funcharts</h2><span id='topic+sim_funcharts'></span>

<h3>Description</h3>

<p>Function used to simulate three data sets to illustrate the use
of <code>funcharts</code>.
It uses the function <code><a href="#topic+simulate_mfd">simulate_mfd</a></code>,
which creates a data set with three functional covariates,
a functional response generated as a function of the
three functional covariates,
and a scalar response generated as a function of the
three functional covariates.
This function generates three data sets, one for phase I,
one for tuning, i.e.,
to estimate the control chart limits, and one for phase II monitoring.
see also <code><a href="#topic+simulate_mfd">simulate_mfd</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_funcharts(nobs1 = 1000, nobs_tun = 1000, nobs2 = 60)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_funcharts_+3A_nobs1">nobs1</code></td>
<td>
<p>The number of observation to simulate in phase I. Default is 1000.</p>
</td></tr>
<tr><td><code id="sim_funcharts_+3A_nobs_tun">nobs_tun</code></td>
<td>
<p>The number of observation to simulate the tuning data set. Default is 1000.</p>
</td></tr>
<tr><td><code id="sim_funcharts_+3A_nobs2">nobs2</code></td>
<td>
<p>The number of observation to simulate in phase II. Default is 60.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with three objects, <code>datI</code> contains the phase I data,
<code>datI_tun</code> contains the tuning data,
<code>datII</code> contains the phase II data.
In the phase II data, the first group of observations are in control,
the second group of observations contains a moderate mean shift,
while the third group of observations contains a severe mean shift.
The shift types are described in the paper from Capezza et al. (2022).
</p>


<h3>References</h3>

<p>Centofanti F, Lepore A, Menafoglio A, Palumbo B, Vantini S. (2021)
Functional Regression Control Chart.
<em>Technometrics</em>, 63(3), 281&ndash;294. <a href="doi:10.1080/00401706.2020.1753581">doi:10.1080/00401706.2020.1753581</a>
</p>
<p>Capezza, C., Centofanti, F., Lepore, A., Menafoglio, A., Palumbo, B.,
&amp; Vantini, S. (2022). funcharts: Control charts for multivariate
functional data in R. arXiv preprint arXiv:2207.09321.
</p>

<hr>
<h2 id='simulate_mfd'>Simulate a data set for funcharts</h2><span id='topic+simulate_mfd'></span>

<h3>Description</h3>

<p>Function used to simulate a data set to illustrate
the use of <code>funcharts</code>.
By default, it creates a data set with three functional covariates,
a functional response generated as a function of the
three functional covariates
through a function-on-function linear model,
and a scalar response generated as a function of the
three functional covariates
through a scalar-on-function linear model.
This function covers the simulation study in Centofanti et al. (2021)
for the function-on-function case and also simulates data in a similar way
for the scalar response case.
It is possible to select the number of functional covariates,
the correlation function type for each functional covariate
and the functional response, moreover
it is possible to provide manually the mean and variance functions
for both functional covariates and the response.
In the default case, the function generates in-control data.
Additional arguments can be used to generate additional
data that are out of control,
with mean shifts according to the scenarios proposed
by Centofanti et al. (2021).
Each simulated observation of a functional variable consists of
a vector of discrete points equally spaced between 0 and 1 (by default
150 points),
generated with noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_mfd(
  nobs = 1000,
  p = 3,
  R2 = 0.97,
  shift_type_y = "0",
  shift_type_x = c("0", "0", "0"),
  correlation_type_y = "Bessel",
  correlation_type_x = c("Bessel", "Gaussian", "Exponential"),
  d_y = 0,
  d_y_scalar = 0,
  d_x = c(0, 0, 0),
  n_comp_y = 10,
  n_comp_x = 50,
  P = 500,
  ngrid = 150,
  save_beta = FALSE,
  mean_y = NULL,
  mean_x = NULL,
  variance_y = NULL,
  variance_x = NULL,
  sd_y = 0.3,
  sd_x = c(0.3, 0.05, 0.3),
  seed
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_mfd_+3A_nobs">nobs</code></td>
<td>
<p>The number of observation to simulate</p>
</td></tr>
<tr><td><code id="simulate_mfd_+3A_p">p</code></td>
<td>
<p>The number of functional covariates to simulate. Default value is 3.</p>
</td></tr>
<tr><td><code id="simulate_mfd_+3A_r2">R2</code></td>
<td>
<p>The desired coefficient of determination in the regression
in both the scalar and functional response cases,
Default is 0.97.</p>
</td></tr>
<tr><td><code id="simulate_mfd_+3A_shift_type_y">shift_type_y</code></td>
<td>
<p>The shift type for the functional response.
There are five possibilities: &quot;0&quot; if there is no shift,
&quot;A&quot;, &quot;B&quot;, &quot;C&quot; or &quot;D&quot; for the corresponding shift types
shown in Centofanti et al. (2021).
Default is &quot;0&quot;.</p>
</td></tr>
<tr><td><code id="simulate_mfd_+3A_shift_type_x">shift_type_x</code></td>
<td>
<p>A list of length <code>p</code>, indicating, for each functional covariate,
the shift type. For each element of the list,
there are five possibilities: &quot;0&quot; if there is no shift,
&quot;A&quot;, &quot;B&quot;, &quot;C&quot; or &quot;D&quot; for the corresponding shift types
shown in Centofanti et al. (2021).
By default, shift is not applied to any functional covariate.</p>
</td></tr>
<tr><td><code id="simulate_mfd_+3A_correlation_type_y">correlation_type_y</code></td>
<td>
<p>A character vector indicating the type of correlation function for
the functional response.
See  Centofanti et al. (2021)
for more details. Three possible values are available,
namely <code>"Bessel"</code>, <code>"Gaussian"</code> and <code>"Exponential"</code>.
Default value is <code>"Bessel"</code>.</p>
</td></tr>
<tr><td><code id="simulate_mfd_+3A_correlation_type_x">correlation_type_x</code></td>
<td>
<p>A list of <code>p</code> character vectors indicating
the type of correlation function for each
functional covariate.
See  Centofanti et al. (2021)
for more details. For each element of the list,
three possible values are available,
namely <code>"Bessel"</code>, <code>"Gaussian"</code> and <code>"Exponential"</code>.
Default value is <code>c("Bessel", "Gaussian", "Exponential")</code>.</p>
</td></tr>
<tr><td><code id="simulate_mfd_+3A_d_y">d_y</code></td>
<td>
<p>A number indicating the severity of the shift type for
the functional response.
Default is 0.</p>
</td></tr>
<tr><td><code id="simulate_mfd_+3A_d_y_scalar">d_y_scalar</code></td>
<td>
<p>A number indicating the severity of the shift type for
the scalar response.
Default is 0.</p>
</td></tr>
<tr><td><code id="simulate_mfd_+3A_d_x">d_x</code></td>
<td>
<p>A list of <code>p</code> numbers, each indicating the
severity of the shift type for
the corresponding functional covariate.
By default, the severity is set to zero for all functional covariates.</p>
</td></tr>
<tr><td><code id="simulate_mfd_+3A_n_comp_y">n_comp_y</code></td>
<td>
<p>A positive integer number indicating how many principal components
obtained after the eigendecomposiiton of the covariance function
of the functional response variable to retain.
Default value is 10.</p>
</td></tr>
<tr><td><code id="simulate_mfd_+3A_n_comp_x">n_comp_x</code></td>
<td>
<p>A positive integer number indicating how many principal components
obtained after the eigendecomposiiton of the covariance function
of the multivariate functional covariates variable to retain.
Default value is 50.</p>
</td></tr>
<tr><td><code id="simulate_mfd_+3A_p">P</code></td>
<td>
<p>A positive integer number indicating the number of equally spaced
grid points over which the covariance functions are discretized.
Default value is 500.</p>
</td></tr>
<tr><td><code id="simulate_mfd_+3A_ngrid">ngrid</code></td>
<td>
<p>A positive integer number indicating the number of equally spaced
grid points between zero and one
over which all functional observations are discretized before adding
noise. Default value is 150.</p>
</td></tr>
<tr><td><code id="simulate_mfd_+3A_save_beta">save_beta</code></td>
<td>
<p>If TRUE, the true regression coefficients of both the function-on-function
and the scalar-on-function models are saved.
Default is FALSE.</p>
</td></tr>
<tr><td><code id="simulate_mfd_+3A_mean_y">mean_y</code></td>
<td>
<p>The mean function of the functional response can be set manually
through this argument. If not NULL, it must be a vector of length
equal to <code>ngrid</code>, providing the values of the mean function of
the functional response discretized on <code>seq(0,1,l=ngrid)</code>.
If NULL, the mean function is generated as done in the simulation study
of Centofanti et al. (2021).
Default is NULL.</p>
</td></tr>
<tr><td><code id="simulate_mfd_+3A_mean_x">mean_x</code></td>
<td>
<p>The mean function of the functional covariates can be set manually
through this argument. If not NULL, it must be a list of vectors,
each with length equal to <code>ngrid</code>,
providing the values of the mean function of
each functional covariate discretized on <code>seq(0,1,l=ngrid)</code>.
If NULL, the mean function is generated as done in the simulation study
of Centofanti et al. (2021).
Default is NULL.</p>
</td></tr>
<tr><td><code id="simulate_mfd_+3A_variance_y">variance_y</code></td>
<td>
<p>The variance function of the functional response can be set manually
through this argument. If not NULL, it must be a vector of length
equal to <code>ngrid</code>, providing the values of the variance function of
the functional response discretized on <code>seq(0,1,l=ngrid)</code>.
If NULL, the variance function is generated as done in the simulation study
of Centofanti et al. (2021).
Default is NULL.</p>
</td></tr>
<tr><td><code id="simulate_mfd_+3A_variance_x">variance_x</code></td>
<td>
<p>The variance function of the functional covariates can be set manually
through this argument. If not NULL, it must be a list of vectors,
each with length equal to <code>ngrid</code>,
providing the values of the variance function of
each functional covariate discretized on <code>seq(0,1,l=ngrid)</code>.
If NULL, the variance function is generated as done in the simulation study
of Centofanti et al. (2021).
Default is NULL.</p>
</td></tr>
<tr><td><code id="simulate_mfd_+3A_sd_y">sd_y</code></td>
<td>
<p>A positive number indicating the standard deviation of the generated
noise with which the functional response discretized values are observed.
Default value is 0.3</p>
</td></tr>
<tr><td><code id="simulate_mfd_+3A_sd_x">sd_x</code></td>
<td>
<p>A vector of <code>p</code> positive numbers indicating the standard deviation
of the generated noise with which the
functional covariates discretized values are observed.
Default value is <code>c(0.3, 0.05, 0.3)</code>.</p>
</td></tr>
<tr><td><code id="simulate_mfd_+3A_seed">seed</code></td>
<td>
<p>Deprecated: use <code>set.seed()</code> before calling
the function for reproducibility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li> <p><code>X_list</code> is a list of <code>p</code> matrices, each with dimension
<code>nobs</code>x<code>ngrid</code>, containing the simulated
observations of the multivariate functional covariate
</p>
</li>
<li> <p><code>Y</code> is a <code>nobs</code>x<code>ngrid</code> matrix with the simulated
observations of the functional response
</p>
</li>
<li> <p><code>y_scalar</code> is a vector of length <code>nobs</code> with the simulated
observations of the scalar response
</p>
</li>
<li> <p><code>beta_fof</code>, if <code>save_beta = TRUE</code>, is a
list of <code>p</code> matrices, each with dimension <code>P</code>x<code>P</code>
with the discretized functional coefficients of the
function-on-function regression
</p>
</li>
<li> <p><code>beta_sof</code>, if <code>save_beta = TRUE</code>, is a
list of <code>p</code> vectors, each with length <code>P</code>,
with the discretized functional coefficients of the
scalar-on-function regression
</p>
</li></ul>



<h3>References</h3>

<p>Centofanti F, Lepore A, Menafoglio A, Palumbo B, Vantini S. (2021)
Functional Regression Control Chart.
<em>Technometrics</em>, 63(3), 281&ndash;294. <a href="doi:10.1080/00401706.2020.1753581">doi:10.1080/00401706.2020.1753581</a>
</p>

<hr>
<h2 id='sof_pc'>Scalar-on-function linear regression based on principal components</h2><span id='topic+sof_pc'></span>

<h3>Description</h3>

<p>Scalar-on-function linear regression based on
principal components.
This function performs multivariate functional principal component analysis
(MFPCA)
to extract multivariate functional principal components
from the multivariate functional covariates,
then it builds a linear regression model of a
scalar response variable on the
covariate scores.
Functional covariates are standardized before the regression.
See Capezza et al. (2020) for additional details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sof_pc(
  y,
  mfdobj_x,
  tot_variance_explained = 0.9,
  selection = "variance",
  single_min_variance_explained = 0,
  components = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sof_pc_+3A_y">y</code></td>
<td>
<p>A numeric vector containing the observations of the
scalar response variable.</p>
</td></tr>
<tr><td><code id="sof_pc_+3A_mfdobj_x">mfdobj_x</code></td>
<td>
<p>A multivariate functional data object of class mfd
denoting the functional covariates.</p>
</td></tr>
<tr><td><code id="sof_pc_+3A_tot_variance_explained">tot_variance_explained</code></td>
<td>
<p>The minimum fraction of variance
that has to be explained
by the set of multivariate functional principal components
retained into the MFPCA model
fitted on the functional covariates.
Default is 0.9.</p>
</td></tr>
<tr><td><code id="sof_pc_+3A_selection">selection</code></td>
<td>
<p>A character value with one of three possible values:
</p>
<p>if &quot;variance&quot;, the first M multivariate functional principal components
are retained into the MFPCA model such
that together they explain a fraction of variance greater
than <code>tot_variance_explained</code>,
</p>
<p>if &quot;PRESS&quot;, each j-th functional principal component is retained
into the MFPCA model if,
by adding it to the
set of the first j-1 functional principal components,
then the predicted residual error sum of squares (PRESS) statistic decreases,
and at the same time the fraction of variance explained
by that single component
is greater than <code>single_min_variance_explained</code>.
This criterion is used in Capezza et al. (2020).
</p>
<p>if &quot;gcv&quot;, the criterion is equal as in the previous &quot;PRESS&quot; case,
but the &quot;PRESS&quot; statistic is substituted by the
generalized cross-validation (GCV) score.
</p>
<p>Default value is &quot;variance&quot;.</p>
</td></tr>
<tr><td><code id="sof_pc_+3A_single_min_variance_explained">single_min_variance_explained</code></td>
<td>
<p>The minimum fraction of variance
that has to be explained
by each multivariate functional principal component into the
MFPCA model fitted
on the functional covariates such that it is retained into the MFPCA model.
Default is 0.</p>
</td></tr>
<tr><td><code id="sof_pc_+3A_components">components</code></td>
<td>
<p>A vector of integers with the components over which
to project the functional covariates.
If this is not NULL, the criteria to select components are ignored.
If NULL, components are selected according to
the criterion defined by <code>selection</code>.
Default is NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the following arguments:
</p>

<ul>
<li> <p><code>mod</code>: an object of class <code>lm</code> that is a linear regression
model where
the scalar response variable is <code>y</code> and
the covariates are the MFPCA scores of the functional covariates,
</p>
</li>
<li> <p><code>mod$coefficients</code> contains the matrix of coefficients of the
functional regression basis functions,
</p>
</li>
<li> <p><code>pca</code>: an object of class <code>pca_mfd</code> obtained by doing MFPCA
on the functional covariates,
</p>
</li>
<li> <p><code>beta_fd</code>: an object of class <code>mfd</code> object containing
the functional regression coefficient
<code class="reqn">\beta(t)</code> estimated with the
scalar-on-function linear regression model,
</p>
</li>
<li> <p><code>components</code>: a vector of integers with the components
selected in the <code>pca</code> model,
</p>
</li>
<li> <p><code>selection</code>: the same as the provided argument
</p>
</li>
<li> <p><code>single_min_variance_explained</code>: the same as the provided argument
</p>
</li>
<li> <p><code>tot_variance_explained</code>: the same as the provided argument
</p>
</li>
<li> <p><code>gcv</code>: a vector whose j-th element is the GCV score obtained
when retaining the first j components
in the MFPCA model.
</p>
</li>
<li> <p><code>PRESS</code>: a vector whose j-th element is the PRESS statistic
obtained when retaining the first j components
in the MFPCA model.
</p>
</li></ul>



<h3>References</h3>

<p>Capezza C, Lepore A, Menafoglio A, Palumbo B, Vantini S. (2020)
Control charts for
monitoring ship operating conditions and CO2 emissions based
on scalar-on-function regression.
<em>Applied Stochastic Models in Business and Industry</em>,
36(3):477&ndash;500.
<a href="doi:10.1002/asmb.2507">doi:10.1002/asmb.2507</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(funcharts)
data("air")
air &lt;- lapply(air, function(x) x[1:10, , drop = FALSE])
fun_covariates &lt;- c("CO", "temperature")
mfdobj_x &lt;- get_mfd_list(air[fun_covariates], lambda = 1e-2)
y &lt;- rowMeans(air$NO2)
mod &lt;- sof_pc(y, mfdobj_x)

</code></pre>

<hr>
<h2 id='sof_pc_real_time'>Get a list of scalar-on-function linear regression models estimated
on functional data
each evolving up to an intermediate domain point.</h2><span id='topic+sof_pc_real_time'></span>

<h3>Description</h3>

<p>This function produces a list of objects,
each of them contains the result of applying <code><a href="#topic+sof_pc">sof_pc</a></code> to
a scalar response variable and multivariate functional covariates
evolved up to an intermediate domain point.
See Capezza et al. (2020) for additional details on real-time monitoring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sof_pc_real_time(
  y,
  mfd_real_time_list,
  single_min_variance_explained = 0,
  tot_variance_explained = 0.9,
  selection = "PRESS",
  components = NULL,
  ncores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sof_pc_real_time_+3A_y">y</code></td>
<td>
<p>A numeric vector containing the observations of
the scalar response variable.</p>
</td></tr>
<tr><td><code id="sof_pc_real_time_+3A_mfd_real_time_list">mfd_real_time_list</code></td>
<td>
<p>A list created using
<code><a href="#topic+get_mfd_df_real_time">get_mfd_df_real_time</a></code> or
<code>get_mfd_list_real_time</code>, denoting a list of functional data objects,
each evolving up to an intermediate domain point,
with observations of the multivariate functional covariates.</p>
</td></tr>
<tr><td><code id="sof_pc_real_time_+3A_single_min_variance_explained">single_min_variance_explained</code></td>
<td>
<p>See <code><a href="#topic+sof_pc">sof_pc</a></code>.</p>
</td></tr>
<tr><td><code id="sof_pc_real_time_+3A_tot_variance_explained">tot_variance_explained</code></td>
<td>
<p>See <code><a href="#topic+sof_pc">sof_pc</a></code>.</p>
</td></tr>
<tr><td><code id="sof_pc_real_time_+3A_selection">selection</code></td>
<td>
<p>See <code><a href="#topic+sof_pc">sof_pc</a></code>.</p>
</td></tr>
<tr><td><code id="sof_pc_real_time_+3A_components">components</code></td>
<td>
<p>See <code><a href="#topic+sof_pc">sof_pc</a></code>.</p>
</td></tr>
<tr><td><code id="sof_pc_real_time_+3A_ncores">ncores</code></td>
<td>
<p>If you want parallelization, give the number of cores/threads
to be used when creating objects separately for different instants.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of lists each produced by <code><a href="#topic+sof_pc">sof_pc</a></code>,
corresponding to a given instant.
</p>


<h3>References</h3>

<p>Capezza C, Lepore A, Menafoglio A, Palumbo B, Vantini S. (2020)
Control charts for
monitoring ship operating conditions and CO2 emissions
based on scalar-on-function regression.
<em>Applied Stochastic Models in Business and Industry</em>,
36(3):477&ndash;500. <a href="doi:10.1002/asmb.2507">doi:10.1002/asmb.2507</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sof_pc">sof_pc</a></code>,
<code><a href="#topic+get_mfd_df_real_time">get_mfd_df_real_time</a></code>,
<code><a href="#topic+get_mfd_list_real_time">get_mfd_list_real_time</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(funcharts)
data("air")
air &lt;- lapply(air, function(x) x[1:10, , drop = FALSE])
mfdobj_list &lt;- get_mfd_list_real_time(air[c("CO", "temperature")],
                                      n_basis = 15,
                                      lambda = 1e-2,
                                      k_seq = c(0.5, 0.75, 1))
y &lt;- rowMeans(air$NO2)
mod_list &lt;- sof_pc_real_time(y, mfdobj_list)

</code></pre>

<hr>
<h2 id='tensor_product_mfd'>Tensor product of two Multivariate Functional Data objects</h2><span id='topic+tensor_product_mfd'></span>

<h3>Description</h3>

<p>This function returns the tensor product of two
Multivariate Functional Data objects.
Each object must contain only one replication.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tensor_product_mfd(mfdobj1, mfdobj2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tensor_product_mfd_+3A_mfdobj1">mfdobj1</code></td>
<td>
<p>A multivariate functional data object, of class <code>mfd</code>,
having only one functional observation.</p>
</td></tr>
<tr><td><code id="tensor_product_mfd_+3A_mfdobj2">mfdobj2</code></td>
<td>
<p>A multivariate functional data object, of class <code>mfd</code>,
having only one functional observation.
If NULL, it is set equal to <code>mfdobj1</code>. Default is NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>bifd</code>.
If we denote with x(s)=(x_1(s),...,x_p(s))
the vector of p functions represented by <code>mfdobj1</code> and
with y(t)=(y_1(t),...,y_q(t)) the vector of q functions
represented by <code>mfdobj2</code>,
the output is the
vector of pq bivariate functions
</p>
<p>f(s,t)=(x_1(s)y_1(t),...,x_1(s)y_q(t),
...,x_p(s)y_1(t),...,x_p(s)y_q(t)).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(funcharts)
mfdobj1 &lt;- data_sim_mfd(nobs = 1, nvar = 3)
mfdobj2 &lt;- data_sim_mfd(nobs = 1, nvar = 2)
tensor_product_mfd(mfdobj1)
tensor_product_mfd(mfdobj1, mfdobj2)

</code></pre>

<hr>
<h2 id='which_ooc'>Get the index of the out of control observations from control charts</h2><span id='topic+which_ooc'></span>

<h3>Description</h3>

<p>This function returns a list for each control chart and returns
the id of all observations that are out of control in that control chart.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which_ooc(cclist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="which_ooc_+3A_cclist">cclist</code></td>
<td>
<p>A <code>data.frame</code> produced by
<code><a href="#topic+control_charts_sof_pc">control_charts_sof_pc</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of as many <code>data.frame</code> objects as
the control charts in <code>cclist</code>.
Each data frame has two columns, the <code>n</code> contains
an index number giving the observation in the
phase II data set, i.e. 1 for the first observation,
2 for the second, and so on,
while the <code>id</code> column contains the id of the observation,
which can be general and
depends on the specific data set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(funcharts)
data("air")
air &lt;- lapply(air, function(x) x[201:300, , drop = FALSE])
fun_covariates &lt;- c("CO", "temperature")
mfdobj_x &lt;- get_mfd_list(air[fun_covariates],
                         n_basis = 15,
                         lambda = 1e-2)
y &lt;- rowMeans(air$NO2)
y1 &lt;- y[1:60]
y_tuning &lt;- y[61:90]
y2 &lt;- y[91:100]
mfdobj_x1 &lt;- mfdobj_x[1:60]
mfdobj_x_tuning &lt;- mfdobj_x[61:90]
mfdobj_x2 &lt;- mfdobj_x[91:100]
mod &lt;- sof_pc(y1, mfdobj_x1)
cclist &lt;- regr_cc_sof(object = mod,
                      y_new = y2,
                      mfdobj_x_new = mfdobj_x2,
                      y_tuning = y_tuning,
                      mfdobj_x_tuning = mfdobj_x_tuning,
                      include_covariates = TRUE)
which_ooc(cclist)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
