<!DOCTYPE html><html><head><title>Help for package OptimalGoldstandardDesigns</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {OptimalGoldstandardDesigns}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#OptimalGoldstandardDesigns'><p>OptimalGoldstandardDesigns</p></a></li>
<li><a href='#calc_ASN'><p>Helper function to calculate the average sample size</p></a></li>
<li><a href='#calc_ASNP'><p>Calculate the average placebo group sample size</p></a></li>
<li><a href='#calc_c'><p>Helper function to calculate allocation ratios from stagewise sample sizes</p></a></li>
<li><a href='#calc_conditional_local_rejection_probs'><p>Calculate the (local) conditional type I errors of both hypothesis given both interim test statistics.</p></a></li>
<li><a href='#calc_conditional_power'><p>Calculate the conditional power to reject both hypothesis given both interim test statistics.</p></a></li>
<li><a href='#calc_cumc'><p>Helper function to calculate &quot;cumulative allocation ratio&quot; from stagewise allocation ratios</p></a></li>
<li><a href='#calc_cumn'><p>Helper function to calculate cumulative sample sizes from stagewise sample sizes</p></a></li>
<li><a href='#calc_final_state_probs'><p>Helper function to calculate the final state probabilities</p></a></li>
<li><a href='#calc_gamma'><p>Helper function to calculate gamma factors from group variances and cumulative allocation ratios</p></a></li>
<li><a href='#calc_local_alphas'><p>Helper function to calculate the local type I error rates of a Design</p></a></li>
<li><a href='#calc_local_rejection_boundaries'><p>Helper function to calculate the local rejection boundaries of group sequential testing</p>
procedure associated with the hypothesis belong to the groups argument</a></li>
<li><a href='#calc_mu_vec'><p>Helper function to calculate expected value of normal test statistic vector c(Z_TP1, Z_TP2, Z_TC1, Z_TP2)</p>
under the null and alternative hypothesis given nT1, gamma and mu.</a></li>
<li><a href='#calc_mu_wo_nT1'><p>Helper function to calculate expected value of normal test statistic vector c(Z_TP1, Z_TP2, Z_TC1, Z_TP2)</p>
under the null and alternative hypothesis given nT1=1, gamma and mu.</a></li>
<li><a href='#calc_n_from_c'><p>Helper function to calculate other n's given n_1,T and allocation ratios</p></a></li>
<li><a href='#calc_nT1_wrt_bTC2e'><p>Helper function to calculate the required sample size (of the stage 1 treatment group)</p>
to achieve the target power given the bTC2e</a></li>
<li><a href='#calc_prob_reject_both'><p>Helper function to calculate the probability to reject both hypotheses</p>
given the mean of the normal test statistic vector c(Z_TP1, Z_TP2, Z_TC1, Z_TC2).</a></li>
<li><a href='#calc_prob_reject_both_singlestage'><p>Helper function to calculate the probability to reject both hypotheses</p>
given the mean of the normal test statistic vector c(Z_TP1, Z_TC1).</a></li>
<li><a href='#calc_Sigma'><p>Helper function to calculate the covariance matrix from the group variances, cumulative allocation ratios</p>
and gamma factors</a></li>
<li><a href='#calc_worst_type_I_error'><p>Helper function to calculate the maximal probability of rejecting the non-inferiority hypothesis</p>
in the testing procedure featuring nonsequential futility, given a point hypothesis for
the superiority hypothesis.</a></li>
<li><a href='#conditional_mean'><p>Calculate the conditional mean of a multivariate normal distribution</p></a></li>
<li><a href='#conditional_Sigma'><p>Calculate the conditional mean of a multivariate normal distribution</p></a></li>
<li><a href='#objective_onestage'><p>Objective function for single-stage gold-standard designs</p></a></li>
<li><a href='#objective_twostage'><p>Objective function for two-stage gold-standard designs</p></a></li>
<li><a href='#optimize_design_onestage'><p>Calculate optimal design parameters for a single-stage gold-standard design</p></a></li>
<li><a href='#optimize_design_twostage'><p>Calculate optimal design parameters for a two-stage gold-standard design</p></a></li>
<li><a href='#padd_whitespace'><p>Add whitespace padding to string</p></a></li>
<li><a href='#pmvnorm_'><p>mvtnorm::pmvnorm, but returns 0 if any lower boundary is larger than</p>
any upper boundary</a></li>
<li><a href='#pmvt_'><p>mvtnorm::pmvt, but returns 0 if any lower boundary is larger than</p>
any upper boundary</a></li>
<li><a href='#print.OneStageGoldStandardDesign'><p>Printing method for optimal single-stage goldstandard designs</p></a></li>
<li><a href='#print.TwoStageGoldStandardDesign'><p>Printing method for optimal two-stage goldstandard designs</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Design Parameter Optimization for Gold-Standard Non-Inferiority
Trials</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Methods to calculate optimal design parameters
    for one- and two-stage three-arm group-sequential gold-standard
    non-inferiority trial designs
    with or without binding or nonbinding futility boundaries,
    as described in Meis et al. (2023) &lt;<a href="https://doi.org/10.1002%2Fsim.9630">doi:10.1002/sim.9630</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>nloptr, mvtnorm, cli, dplyr, tibble, Rdpack</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), here, knitr, rmarkdown, covr, fpCompare,
mnormt, future.apply</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Collate:</td>
<td>'OptimalGoldstandardDesigns-package.R'
'pmv_upper_smaller_slower_fix.R'
'conditional_probability_functions.R'
'design_display_functions.R' 'global_constants.R'
'design_helper_functions.R' 'objective_functions.R'
'optimization_methods.R' 'table_format_functions.R'</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jan-imbi/OptimalGoldstandardDesigns">https://github.com/jan-imbi/OptimalGoldstandardDesigns</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-11 09:20:39 UTC; pn425</td>
</tr>
<tr>
<td>Author:</td>
<td>Jan Meis <a href="https://orcid.org/0000-0001-5407-7220"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jan Meis &lt;meis@imbi.uni-heidelberg.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-11 10:40:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='OptimalGoldstandardDesigns'>OptimalGoldstandardDesigns</h2><span id='topic+OptimalGoldstandardDesigns'></span><span id='topic+OptimalGoldstandardDesigns-package'></span>

<h3>Description</h3>

<p>Methods to calculate optimal design parameters
for one- and two-stage three-arm group-sequential gold-standard
non-inferiority trial designs
with or without binding or nonbinding futility boundaries,
as described in (Meis et al. 2023).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Jan Meis <a href="mailto:meis@imbi.uni-heidelberg.de">meis@imbi.uni-heidelberg.de</a> (<a href="https://orcid.org/0000-0001-5407-7220">ORCID</a>)
</p>


<h3>References</h3>

<p>Meis J, Pilz M, Herrmann C, Bokelmann B, Rauch G, Kieser M (2023).
&ldquo;Optimization of the two-stage group sequential three-arm gold-standard design for non-inferiority trials.&rdquo;
<em>Statistics in Medicine</em>, <b>42</b>(4), 536-558.
<a href="https://doi.org/10.1002/sim.9630">doi:10.1002/sim.9630</a>.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/jan-imbi/OptimalGoldstandardDesigns">https://github.com/jan-imbi/OptimalGoldstandardDesigns</a>
</p>
</li></ul>


<hr>
<h2 id='calc_ASN'>Helper function to calculate the average sample size</h2><span id='topic+calc_ASN'></span>

<h3>Description</h3>

<p>Helper function to calculate the average sample size
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_ASN(D)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_ASN_+3A_d">D</code></td>
<td>
<p>list containing all parameters of a the trial design.</p>
</td></tr>
</table>

<hr>
<h2 id='calc_ASNP'>Calculate the average placebo group sample size</h2><span id='topic+calc_ASNP'></span>

<h3>Description</h3>

<p>Calculate the average placebo group sample size
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_ASNP(D)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_ASNP_+3A_d">D</code></td>
<td>
<p>list containing all parameters of a the trial design.</p>
</td></tr>
</table>

<hr>
<h2 id='calc_c'>Helper function to calculate allocation ratios from stagewise sample sizes</h2><span id='topic+calc_c'></span>

<h3>Description</h3>

<p>Helper function to calculate allocation ratios from stagewise sample sizes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_c(D)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_c_+3A_d">D</code></td>
<td>
<p>list containing all parameters of a the trial design.</p>
</td></tr>
</table>

<hr>
<h2 id='calc_conditional_local_rejection_probs'>Calculate the (local) conditional type I errors of both hypothesis given both interim test statistics.</h2><span id='topic+calc_conditional_local_rejection_probs'></span>

<h3>Description</h3>

<p>Calculate the (local) conditional type I errors of both hypothesis given both interim test statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_conditional_local_rejection_probs(Z_TP1, Z_TC1, D, mu_vec = D$mu_vec$H0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_conditional_local_rejection_probs_+3A_z_tp1">Z_TP1</code></td>
<td>
<p>First stage Z-test statistic of the superiority test of treatment over placebo.</p>
</td></tr>
<tr><td><code id="calc_conditional_local_rejection_probs_+3A_z_tc1">Z_TC1</code></td>
<td>
<p>First stage Z-test statistic of the non-inferiority test of treatment to the active control.</p>
</td></tr>
<tr><td><code id="calc_conditional_local_rejection_probs_+3A_d">D</code></td>
<td>
<p>list containing all parameters of a the trial design.</p>
</td></tr>
<tr><td><code id="calc_conditional_local_rejection_probs_+3A_mu_vec">mu_vec</code></td>
<td>
<p>vector of means of the test statistic c(Z_TP1, Z_TP2, Z_TC1, Z_TC1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named numeric vector with both conditional type I errors.
</p>

<hr>
<h2 id='calc_conditional_power'>Calculate the conditional power to reject both hypothesis given both interim test statistics.</h2><span id='topic+calc_conditional_power'></span>

<h3>Description</h3>

<p>Calculate the conditional power to reject both hypothesis given both interim test statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_conditional_power(Z_TP1, Z_TC1, D)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_conditional_power_+3A_z_tp1">Z_TP1</code></td>
<td>
<p>First stage Z-test statistic of the superiority test of treatment over placebo.</p>
</td></tr>
<tr><td><code id="calc_conditional_power_+3A_z_tc1">Z_TC1</code></td>
<td>
<p>First stage Z-test statistic of the non-inferiority test of treatment to the active control.</p>
</td></tr>
<tr><td><code id="calc_conditional_power_+3A_d">D</code></td>
<td>
<p>list containing all parameters of a the trial design.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric value of the conditional power.
</p>

<hr>
<h2 id='calc_cumc'>Helper function to calculate &quot;cumulative allocation ratio&quot; from stagewise allocation ratios</h2><span id='topic+calc_cumc'></span>

<h3>Description</h3>

<p>Helper function to calculate &quot;cumulative allocation ratio&quot; from stagewise allocation ratios
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_cumc(D)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_cumc_+3A_d">D</code></td>
<td>
<p>list containing all parameters of a the trial design.</p>
</td></tr>
</table>

<hr>
<h2 id='calc_cumn'>Helper function to calculate cumulative sample sizes from stagewise sample sizes</h2><span id='topic+calc_cumn'></span>

<h3>Description</h3>

<p>Helper function to calculate cumulative sample sizes from stagewise sample sizes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_cumn(D)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_cumn_+3A_d">D</code></td>
<td>
<p>list containing all parameters of a the trial design.</p>
</td></tr>
</table>

<hr>
<h2 id='calc_final_state_probs'>Helper function to calculate the final state probabilities</h2><span id='topic+calc_final_state_probs'></span>

<h3>Description</h3>

<p>Helper function to calculate the final state probabilities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_final_state_probs(hypothesis = "H0", D)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_final_state_probs_+3A_hypothesis">hypothesis</code></td>
<td>
<p>string describing the hypothesis, either &quot;H0&quot; or &quot;H1&quot;.</p>
</td></tr>
<tr><td><code id="calc_final_state_probs_+3A_d">D</code></td>
<td>
<p>list containing all parameters of a the trial design.</p>
</td></tr>
</table>

<hr>
<h2 id='calc_gamma'>Helper function to calculate gamma factors from group variances and cumulative allocation ratios</h2><span id='topic+calc_gamma'></span>

<h3>Description</h3>

<p>Helper function to calculate gamma factors from group variances and cumulative allocation ratios
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_gamma(D)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_gamma_+3A_d">D</code></td>
<td>
<p>list containing all parameters of a the trial design.</p>
</td></tr>
</table>

<hr>
<h2 id='calc_local_alphas'>Helper function to calculate the local type I error rates of a Design</h2><span id='topic+calc_local_alphas'></span>

<h3>Description</h3>

<p>Helper function to calculate the local type I error rates of a Design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_local_alphas(D)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_local_alphas_+3A_d">D</code></td>
<td>
<p>list containing all parameters of a the trial design.</p>
</td></tr>
</table>

<hr>
<h2 id='calc_local_rejection_boundaries'>Helper function to calculate the local rejection boundaries of group sequential testing
procedure associated with the hypothesis belong to the groups argument</h2><span id='topic+calc_local_rejection_boundaries'></span>

<h3>Description</h3>

<p>Helper function to calculate the local rejection boundaries of group sequential testing
procedure associated with the hypothesis belong to the groups argument
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_local_rejection_boundaries(groups = "TP", D)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_local_rejection_boundaries_+3A_groups">groups</code></td>
<td>
<p>string describing the pair of groups. Either &quot;TP&quot; or &quot;TC&quot;.</p>
</td></tr>
<tr><td><code id="calc_local_rejection_boundaries_+3A_d">D</code></td>
<td>
<p>list containing all parameters of a the trial design.</p>
</td></tr>
</table>

<hr>
<h2 id='calc_mu_vec'>Helper function to calculate expected value of normal test statistic vector c(Z_TP1, Z_TP2, Z_TC1, Z_TP2)
under the null and alternative hypothesis given nT1, gamma and mu.</h2><span id='topic+calc_mu_vec'></span>

<h3>Description</h3>

<p>Helper function to calculate expected value of normal test statistic vector c(Z_TP1, Z_TP2, Z_TC1, Z_TP2)
under the null and alternative hypothesis given nT1, gamma and mu.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_mu_vec(D)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_mu_vec_+3A_d">D</code></td>
<td>
<p>list containing all parameters of a the trial design.</p>
</td></tr>
</table>

<hr>
<h2 id='calc_mu_wo_nT1'>Helper function to calculate expected value of normal test statistic vector c(Z_TP1, Z_TP2, Z_TC1, Z_TP2)
under the null and alternative hypothesis given nT1=1, gamma and mu.</h2><span id='topic+calc_mu_wo_nT1'></span>

<h3>Description</h3>

<p>This quantity is helpful when solving for the smallest n which fulfills a certain power constraint.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_mu_wo_nT1(D)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_mu_wo_nT1_+3A_d">D</code></td>
<td>
<p>list containing all parameters of a the trial design.</p>
</td></tr>
</table>

<hr>
<h2 id='calc_n_from_c'>Helper function to calculate other n's given n_1,T and allocation ratios</h2><span id='topic+calc_n_from_c'></span>

<h3>Description</h3>

<p>Helper function to calculate other n's given n_1,T and allocation ratios
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_n_from_c(nT1, D)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_n_from_c_+3A_nt1">nT1</code></td>
<td>
<p>first stage sample size of the treatment group.</p>
</td></tr>
<tr><td><code id="calc_n_from_c_+3A_d">D</code></td>
<td>
<p>list containing all parameters of a the trial design.</p>
</td></tr>
</table>

<hr>
<h2 id='calc_nT1_wrt_bTC2e'>Helper function to calculate the required sample size (of the stage 1 treatment group)
to achieve the target power given the bTC2e</h2><span id='topic+calc_nT1_wrt_bTC2e'></span>

<h3>Description</h3>

<p>Helper function to calculate the required sample size (of the stage 1 treatment group)
to achieve the target power given the bTC2e
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_nT1_wrt_bTC2e(bTC2e, D)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_nT1_wrt_bTC2e_+3A_btc2e">bTC2e</code></td>
<td>
<p>second stage critical value for the TC testing problem.</p>
</td></tr>
<tr><td><code id="calc_nT1_wrt_bTC2e_+3A_d">D</code></td>
<td>
<p>list containing all parameters of a the trial design.</p>
</td></tr>
</table>

<hr>
<h2 id='calc_prob_reject_both'>Helper function to calculate the probability to reject both hypotheses
given the mean of the normal test statistic vector c(Z_TP1, Z_TP2, Z_TC1, Z_TC2).</h2><span id='topic+calc_prob_reject_both'></span>

<h3>Description</h3>

<p>Helper function to calculate the probability to reject both hypotheses
given the mean of the normal test statistic vector c(Z_TP1, Z_TP2, Z_TC1, Z_TC2).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_prob_reject_both(mu_vec, D)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_prob_reject_both_+3A_mu_vec">mu_vec</code></td>
<td>
<p>vector of means of the test statistic c(Z_TP1, Z_TP2, Z_TC1, Z_TC1).</p>
</td></tr>
<tr><td><code id="calc_prob_reject_both_+3A_d">D</code></td>
<td>
<p>list containing all parameters of a the trial design.</p>
</td></tr>
</table>

<hr>
<h2 id='calc_prob_reject_both_singlestage'>Helper function to calculate the probability to reject both hypotheses
given the mean of the normal test statistic vector c(Z_TP1, Z_TC1).</h2><span id='topic+calc_prob_reject_both_singlestage'></span>

<h3>Description</h3>

<p>Helper function to calculate the probability to reject both hypotheses
given the mean of the normal test statistic vector c(Z_TP1, Z_TC1).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_prob_reject_both_singlestage(mu_vec, D)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_prob_reject_both_singlestage_+3A_mu_vec">mu_vec</code></td>
<td>
<p>vector of means of the test statistic c(Z_TP1, Z_TP2, Z_TC1, Z_TC1).</p>
</td></tr>
<tr><td><code id="calc_prob_reject_both_singlestage_+3A_d">D</code></td>
<td>
<p>list containing all parameters of a the trial design.</p>
</td></tr>
</table>

<hr>
<h2 id='calc_Sigma'>Helper function to calculate the covariance matrix from the group variances, cumulative allocation ratios
and gamma factors</h2><span id='topic+calc_Sigma'></span>

<h3>Description</h3>

<p>Helper function to calculate the covariance matrix from the group variances, cumulative allocation ratios
and gamma factors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_Sigma(D)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_Sigma_+3A_d">D</code></td>
<td>
<p>list containing all parameters of a the trial design.</p>
</td></tr>
</table>

<hr>
<h2 id='calc_worst_type_I_error'>Helper function to calculate the maximal probability of rejecting the non-inferiority hypothesis
in the testing procedure featuring nonsequential futility, given a point hypothesis for
the superiority hypothesis.</h2><span id='topic+calc_worst_type_I_error'></span>

<h3>Description</h3>

<p>This is required in designs with nonsequential futility testing, as choosing locally valid designs
is insufficient to gurantee type I error control.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_worst_type_I_error(bTC2e, D)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_worst_type_I_error_+3A_btc2e">bTC2e</code></td>
<td>
<p>second stage critical value for the TC testing problem.</p>
</td></tr>
<tr><td><code id="calc_worst_type_I_error_+3A_d">D</code></td>
<td>
<p>list containing all parameters of a the trial design.</p>
</td></tr>
</table>

<hr>
<h2 id='conditional_mean'>Calculate the conditional mean of a multivariate normal distribution</h2><span id='topic+conditional_mean'></span>

<h3>Description</h3>

<p>See e.g. Chapter 8.1.2 in <a href="https://www.math.uwaterloo.ca/~hwolkowi/matrixcookbook.pdf">The Matrix Cookbook</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conditional_mean(x_a, mu_a, mu_b, Sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conditional_mean_+3A_x_a">x_a</code></td>
<td>
<p>(Observed) first part of normally distributed vector.</p>
</td></tr>
<tr><td><code id="conditional_mean_+3A_mu_a">mu_a</code></td>
<td>
<p>Mean of second part of normally distributed vector.</p>
</td></tr>
<tr><td><code id="conditional_mean_+3A_mu_b">mu_b</code></td>
<td>
<p>Mean of first part of normally distributed vector.</p>
</td></tr>
<tr><td><code id="conditional_mean_+3A_sigma">Sigma</code></td>
<td>
<p>covariance matrix of test statistic vector c(Z_TP1, Z_TP2, Z_TC1, Z_TC2).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector with the conditional mean
</p>


<h3>References</h3>

<p>Petersen, K. B., &amp; Pedersen, M. S. (2008). The matrix cookbook. Technical University of Denmark, 7(15), 510.
</p>

<hr>
<h2 id='conditional_Sigma'>Calculate the conditional mean of a multivariate normal distribution</h2><span id='topic+conditional_Sigma'></span>

<h3>Description</h3>

<p>See e.g. Chapter 8.1.2 in <a href="https://www.math.uwaterloo.ca/~hwolkowi/matrixcookbook.pdf">The Matrix Cookbook</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conditional_Sigma(x_a, mu_a, mu_b, Sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conditional_Sigma_+3A_x_a">x_a</code></td>
<td>
<p>(Observed) first part of normally distributed vector.</p>
</td></tr>
<tr><td><code id="conditional_Sigma_+3A_mu_a">mu_a</code></td>
<td>
<p>Mean of second part of normally distributed vector.</p>
</td></tr>
<tr><td><code id="conditional_Sigma_+3A_mu_b">mu_b</code></td>
<td>
<p>Mean of first part of normally distributed vector.</p>
</td></tr>
<tr><td><code id="conditional_Sigma_+3A_sigma">Sigma</code></td>
<td>
<p>covariance matrix of test statistic vector c(Z_TP1, Z_TP2, Z_TC1, Z_TC2).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector with the conditional covariance matrix
</p>


<h3>References</h3>

<p>Petersen, K. B., &amp; Pedersen, M. S. (2008). The matrix cookbook. Technical University of Denmark, 7(15), 510.
</p>

<hr>
<h2 id='objective_onestage'>Objective function for single-stage gold-standard designs</h2><span id='topic+objective_onestage'></span>

<h3>Description</h3>

<p>Objective function for single-stage gold-standard designs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>objective_onestage(D)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="objective_onestage_+3A_d">D</code></td>
<td>
<p>list containing all parameters of a the trial design.</p>
</td></tr>
</table>

<hr>
<h2 id='objective_twostage'>Objective function for two-stage gold-standard designs</h2><span id='topic+objective_twostage'></span>

<h3>Description</h3>

<p>Objective function for two-stage gold-standard designs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>objective_twostage(D)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="objective_twostage_+3A_d">D</code></td>
<td>
<p>list containing all parameters of a the trial design.</p>
</td></tr>
</table>

<hr>
<h2 id='optimize_design_onestage'>Calculate optimal design parameters for a single-stage gold-standard design</h2><span id='topic+optimize_design_onestage'></span>

<h3>Description</h3>

<p>Calculate optimal design parameters for a single-stage gold-standard design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimize_design_onestage(
  cP1 = NULL,
  cC1 = NULL,
  alpha = 0.025,
  beta = 0.2,
  alternative_TP = 0.4,
  alternative_TC = 0,
  Delta = 0.2,
  varT = 1,
  varP = 1,
  varC = 1,
  round_n = TRUE,
  kappa = 0,
  objective = quote(sum(unlist(n)) + kappa * n[[1]][["P"]]),
  inner_tol_objective = 1e-07,
  mvnorm_algorithm = mvtnorm::Miwa(steps = 4097, checkCorr = FALSE, maxval = 1000),
  nloptr_x0 = NULL,
  nloptr_lb = NULL,
  nloptr_ub = NULL,
  nloptr_opts = list(algorithm = "NLOPT_LN_SBPLX", ftol_rel = 1e-09, xtol_abs = 1e-08,
    xtol_rel = 1e-07, maxeval = 1000, print_level = 0),
  print_progress = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimize_design_onestage_+3A_cp1">cP1</code></td>
<td>
<p>(numeric) allocation ratio nP1 / nT1. Parameter to be optimized if left unspecified.</p>
</td></tr>
<tr><td><code id="optimize_design_onestage_+3A_cc1">cC1</code></td>
<td>
<p>(numeric) allocation ratio nC1 / nT1. Parameter to be optimized if left unspecified.</p>
</td></tr>
<tr><td><code id="optimize_design_onestage_+3A_alpha">alpha</code></td>
<td>
<p>type I error rate.</p>
</td></tr>
<tr><td><code id="optimize_design_onestage_+3A_beta">beta</code></td>
<td>
<p>type II error rate.</p>
</td></tr>
<tr><td><code id="optimize_design_onestage_+3A_alternative_tp">alternative_TP</code></td>
<td>
<p>assumed difference between T and P under H1. Positive values favor T.</p>
</td></tr>
<tr><td><code id="optimize_design_onestage_+3A_alternative_tc">alternative_TC</code></td>
<td>
<p>assumed difference between T and C under H1. Positive values favor T.</p>
</td></tr>
<tr><td><code id="optimize_design_onestage_+3A_delta">Delta</code></td>
<td>
<p>non-inferiority margin for the test <code class="reqn">X_T - X_C \leq - \Delta</code> vs.
<code class="reqn">X_T - X_C &gt; - \Delta</code>.</p>
</td></tr>
<tr><td><code id="optimize_design_onestage_+3A_vart">varT</code></td>
<td>
<p>variance of treatment group.</p>
</td></tr>
<tr><td><code id="optimize_design_onestage_+3A_varp">varP</code></td>
<td>
<p>variance of placebo group.</p>
</td></tr>
<tr><td><code id="optimize_design_onestage_+3A_varc">varC</code></td>
<td>
<p>variance of control group.</p>
</td></tr>
<tr><td><code id="optimize_design_onestage_+3A_round_n">round_n</code></td>
<td>
<p>(logical) if TRUE, a design with integer valued sample sizes is returned.</p>
</td></tr>
<tr><td><code id="optimize_design_onestage_+3A_kappa">kappa</code></td>
<td>
<p>(numeric) penalty factor for placebo patients in the default objective function.</p>
</td></tr>
<tr><td><code id="optimize_design_onestage_+3A_objective">objective</code></td>
<td>
<p>(expression) objective criterion.</p>
</td></tr>
<tr><td><code id="optimize_design_onestage_+3A_inner_tol_objective">inner_tol_objective</code></td>
<td>
<p>(numeric) used to determine the tolerances for integrals and nuisance optimization problems
inside the objective function.</p>
</td></tr>
<tr><td><code id="optimize_design_onestage_+3A_mvnorm_algorithm">mvnorm_algorithm</code></td>
<td>
<p>algorithm for multivariate integration passed to <code><a href="mvtnorm.html#topic+pmvnorm">pmvnorm</a></code>.</p>
</td></tr>
<tr><td><code id="optimize_design_onestage_+3A_nloptr_x0">nloptr_x0</code></td>
<td>
<p>(numeric vector) starting point for optimization.</p>
</td></tr>
<tr><td><code id="optimize_design_onestage_+3A_nloptr_lb">nloptr_lb</code></td>
<td>
<p>(numeric vector) lower bound box for box constrained optimization.</p>
</td></tr>
<tr><td><code id="optimize_design_onestage_+3A_nloptr_ub">nloptr_ub</code></td>
<td>
<p>(numeric vector) upper bound box for box constrained optimization.</p>
</td></tr>
<tr><td><code id="optimize_design_onestage_+3A_nloptr_opts">nloptr_opts</code></td>
<td>
<p>(list) nloptr options. See <code><a href="nloptr.html#topic+nloptr">nloptr</a></code>.</p>
</td></tr>
<tr><td><code id="optimize_design_onestage_+3A_print_progress">print_progress</code></td>
<td>
<p>(logical) controls whether optimization progress should be visualized during the calculation.</p>
</td></tr>
<tr><td><code id="optimize_design_onestage_+3A_...">...</code></td>
<td>
<p>additional arguments passed along.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates optimal design parameters for a two-stage three-arm gold-standard
non-inferiority trial. Run <code>vignette("Introduction", package = "OptimalGoldstandardDesigns")</code>
to see some examples related to the associated paper (Meis et al. 2023).
</p>
<p>Parameters which can be optimized are the allocation ratios for all groups and stages and the
futility and efficacy boundaries of the first stage. The allocation ratios are
cT2 = nT2 / nT1, cP1 = nP1 / nT1,
cP2 = nP2 / nT1, cC1 = nC1 / nT1 and cC2 = nC2 / nT1. Here, nT1 denotes the sample size
of the treatment group in the first stage, nP2 the sample size of the placebo group in the
second stage, etc. The first stage efficacy boundaries are bTP1e for the treatment vs
placebo testing problem, and bTC1e for the treatment vs control non-inferiority testing
problem. The futility boundaries are denoted by bTP1f and bTC1f.
</p>
<p>If these parameters are left unspecified or set to NULL, they will be included into the
optimization process, otherwise they will be considered boundary constraints.
You may also supply quoted expressions as arguments for these
parameters to solve a constrained optimization problem. For example, you can supply
<code>cT2 = 1, cP2 = quote(cP1), cC2 = quote(cC1)</code> to ensure that the first and second
stage allocation ratios are equal.
</p>
<p>The design is optimized with respect to the objective criterion given by the parameter
<code>objective</code>. By default, this is the overall sample size plus an optional
penalty for the placebo group sample size, controlled by the parameter <code>kappa</code>.
</p>
<p>Designs are calculated to fulfill the following constraints: the family-wise type I error
rate is controlled at <code>alpha</code> under any combination of the two null hypotheses
<code>muT - muP = 0</code> and <code>muT - muC + Delta = 0</code>.
The power to reject both hypothesis given both alternative
hypotheses <code>muT - muP = alternative_TP</code> and <code>muT - muC + Delta = alternative_TC + Delta</code>
is at least <code>1 - beta</code>. Variances are assumed to be given by <code>varT, varP</code> and <code>varC</code>.
</p>
<p>If <code>binding_futility</code> is <code>TRUE</code>, type I error recycling is used.
If <code>always_both_futility_tests</code> is <code>TRUE</code>, it is assumed that futility tests for both
hypotheses are performed at interim, regardless of whether the treatment vs placebo null hypothesis
was successfully rejected. If <code>always_both_futility_tests</code> is <code>FALSE</code>, the futility
test for the treatment vs. control testing problem only needs to be done if the null for the
treatment vs. placebo testing problem was rejected in the first stage.
</p>


<h3>Value</h3>

<p>Design object (a list) with optimized design parameters.
</p>


<h3>References</h3>

<p>Meis J, Pilz M, Herrmann C, Bokelmann B, Rauch G, Kieser M (2023).
&ldquo;Optimization of the two-stage group sequential three-arm gold-standard design for non-inferiority trials.&rdquo;
<em>Statistics in Medicine</em>, <b>42</b>(4), 536-558.
<a href="https://doi.org/10.1002/sim.9630">doi:10.1002/sim.9630</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Should take about 2 second with the chosen accuracy
optimize_design_onestage(
  alpha = .025,
  beta = .2,
  alternative_TP = .4,
  alternative_TC = 0,
  Delta = .2,
  mvnorm_algorithm = mvtnorm::Miwa(steps = 512, checkCorr = FALSE, maxval = 1000),
  nloptr_opts = list(algorithm = "NLOPT_LN_SBPLX", ftol_rel = 1e-03, xtol_abs = 1e-08,
                     xtol_rel = 1e-07, maxeval = 1000, print_level = 0)
)

</code></pre>

<hr>
<h2 id='optimize_design_twostage'>Calculate optimal design parameters for a two-stage gold-standard design</h2><span id='topic+optimize_design_twostage'></span>

<h3>Description</h3>

<p>Calculate optimal design parameters for a two-stage gold-standard design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimize_design_twostage(
  cT2 = NULL,
  cP1 = NULL,
  cP2 = NULL,
  cC1 = NULL,
  cC2 = NULL,
  bTP1f = NULL,
  bTP1e = NULL,
  bTC1f = NULL,
  bTC1e = NULL,
  alpha = 0.025,
  beta = 0.2,
  alternative_TP = 0.4,
  alternative_TC = 0,
  Delta = 0.2,
  varT = 1,
  varP = 1,
  varC = 1,
  binding_futility = FALSE,
  always_both_futility_tests = TRUE,
  round_n = TRUE,
  lambda = 1,
  kappa = 0,
  eta = 0,
  objective = quote(sqrt(lambda)^2 * ASN[["H11"]] + (1 - sqrt(lambda)) * sqrt(lambda) *
    ASN[["H10"]] + (1 - sqrt(lambda)) * sqrt(lambda) * ASN[["H01"]] + (1 -
    sqrt(lambda))^2 * ASN[["H00"]] + kappa * (sqrt(lambda)^2 * ASNP[["H11"]] + (1 -
    sqrt(lambda)) * sqrt(lambda) * ASNP[["H10"]] + (1 - sqrt(lambda)) * sqrt(lambda) *
    ASNP[["H01"]] + (1 - sqrt(lambda))^2 * ASNP[["H00"]] + eta * cumn[[2]][["P"]]) + eta
    * (cumn[[2]][["T"]] + cumn[[2]][["P"]] + cumn[[2]][["C"]])),
  inner_tol_objective = .Machine$double.eps^0.25,
  mvnorm_algorithm = mvtnorm::Miwa(steps = 128, checkCorr = FALSE, maxval = 1000),
  nloptr_x0 = NULL,
  nloptr_lb = NULL,
  nloptr_ub = NULL,
  nloptr_opts = list(algorithm = "NLOPT_LN_SBPLX", ftol_rel = 1e-04, xtol_abs = 0.001,
    xtol_rel = 0.01, maxeval = 1000, print_level = 0),
  print_progress = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimize_design_twostage_+3A_ct2">cT2</code></td>
<td>
<p>(numeric) allocation ratio nT2 / nT1. Parameter to be optimized if left unspecified.</p>
</td></tr>
<tr><td><code id="optimize_design_twostage_+3A_cp1">cP1</code></td>
<td>
<p>(numeric) allocation ratio nP1 / nT1. Parameter to be optimized if left unspecified.</p>
</td></tr>
<tr><td><code id="optimize_design_twostage_+3A_cp2">cP2</code></td>
<td>
<p>(numeric) allocation ratio nP2 / nT1. Parameter to be optimized if left unspecified.</p>
</td></tr>
<tr><td><code id="optimize_design_twostage_+3A_cc1">cC1</code></td>
<td>
<p>(numeric) allocation ratio nC1 / nT1. Parameter to be optimized if left unspecified.</p>
</td></tr>
<tr><td><code id="optimize_design_twostage_+3A_cc2">cC2</code></td>
<td>
<p>(numeric) allocation ratio nC2 / nT1. Parameter to be optimized if left unspecified.</p>
</td></tr>
<tr><td><code id="optimize_design_twostage_+3A_btp1f">bTP1f</code></td>
<td>
<p>(numeric) first stage futility boundary for the T vs. P testing problem. Parameter to be optimized if left unspecified.</p>
</td></tr>
<tr><td><code id="optimize_design_twostage_+3A_btp1e">bTP1e</code></td>
<td>
<p>(numeric) first stage critical value for the T vs. P testing problem. Parameter to be optimized if left unspecified.</p>
</td></tr>
<tr><td><code id="optimize_design_twostage_+3A_btc1f">bTC1f</code></td>
<td>
<p>(numeric) first stage futility boundary for the T vs. C testing problem. Parameter to be optimized if left unspecified.</p>
</td></tr>
<tr><td><code id="optimize_design_twostage_+3A_btc1e">bTC1e</code></td>
<td>
<p>(numeric) first stage critical value for the T vs. C testing problem. Parameter to be optimized if left unspecified.</p>
</td></tr>
<tr><td><code id="optimize_design_twostage_+3A_alpha">alpha</code></td>
<td>
<p>type I error rate.</p>
</td></tr>
<tr><td><code id="optimize_design_twostage_+3A_beta">beta</code></td>
<td>
<p>type II error rate.</p>
</td></tr>
<tr><td><code id="optimize_design_twostage_+3A_alternative_tp">alternative_TP</code></td>
<td>
<p>assumed difference between T and P under H1. Positive values favor T.</p>
</td></tr>
<tr><td><code id="optimize_design_twostage_+3A_alternative_tc">alternative_TC</code></td>
<td>
<p>assumed difference between T and C under H1. Positive values favor T.</p>
</td></tr>
<tr><td><code id="optimize_design_twostage_+3A_delta">Delta</code></td>
<td>
<p>non-inferiority margin for the test <code class="reqn">X_T - X_C \leq - \Delta</code> vs.
<code class="reqn">X_T - X_C &gt; - \Delta</code>.</p>
</td></tr>
<tr><td><code id="optimize_design_twostage_+3A_vart">varT</code></td>
<td>
<p>variance of treatment group.</p>
</td></tr>
<tr><td><code id="optimize_design_twostage_+3A_varp">varP</code></td>
<td>
<p>variance of placebo group.</p>
</td></tr>
<tr><td><code id="optimize_design_twostage_+3A_varc">varC</code></td>
<td>
<p>variance of control group.</p>
</td></tr>
<tr><td><code id="optimize_design_twostage_+3A_binding_futility">binding_futility</code></td>
<td>
<p>(logical) controls if futility boundaries are binding.</p>
</td></tr>
<tr><td><code id="optimize_design_twostage_+3A_always_both_futility_tests">always_both_futility_tests</code></td>
<td>
<p>(logical) if true, both futility tests are performed after the first stage. If false,
a 'completely sequential' testing procedure is employed (see Appendix of (Meis et al. 2023)).</p>
</td></tr>
<tr><td><code id="optimize_design_twostage_+3A_round_n">round_n</code></td>
<td>
<p>(logical) if TRUE, a design with integer valued sample sizes is returned.</p>
</td></tr>
<tr><td><code id="optimize_design_twostage_+3A_lambda">lambda</code></td>
<td>
<p>(numeric) weight of the alternative hypothesis in the default objective function. 1-lambda is the weight
of the null hypothesis.</p>
</td></tr>
<tr><td><code id="optimize_design_twostage_+3A_kappa">kappa</code></td>
<td>
<p>(numeric) penalty factor for placebo patients in the default objective function.</p>
</td></tr>
<tr><td><code id="optimize_design_twostage_+3A_eta">eta</code></td>
<td>
<p>(numeric) penalty factor for the maximum sample size in the default objective function.</p>
</td></tr>
<tr><td><code id="optimize_design_twostage_+3A_objective">objective</code></td>
<td>
<p>(expression) objective criterion.</p>
</td></tr>
<tr><td><code id="optimize_design_twostage_+3A_inner_tol_objective">inner_tol_objective</code></td>
<td>
<p>(numeric) used to determine the tolerances for integrals and nuisance optimization problems
inside the objective function.</p>
</td></tr>
<tr><td><code id="optimize_design_twostage_+3A_mvnorm_algorithm">mvnorm_algorithm</code></td>
<td>
<p>algorithm for multivariate integration passed to <code><a href="mvtnorm.html#topic+pmvnorm">pmvnorm</a></code>.</p>
</td></tr>
<tr><td><code id="optimize_design_twostage_+3A_nloptr_x0">nloptr_x0</code></td>
<td>
<p>(numeric vector) starting point for optimization.</p>
</td></tr>
<tr><td><code id="optimize_design_twostage_+3A_nloptr_lb">nloptr_lb</code></td>
<td>
<p>(numeric vector) lower bound box for box constrained optimization.</p>
</td></tr>
<tr><td><code id="optimize_design_twostage_+3A_nloptr_ub">nloptr_ub</code></td>
<td>
<p>(numeric vector) upper bound box for box constrained optimization.</p>
</td></tr>
<tr><td><code id="optimize_design_twostage_+3A_nloptr_opts">nloptr_opts</code></td>
<td>
<p>(list) nloptr options. See <code><a href="nloptr.html#topic+nloptr">nloptr</a></code>.</p>
</td></tr>
<tr><td><code id="optimize_design_twostage_+3A_print_progress">print_progress</code></td>
<td>
<p>(logical) controls whether optimization progress should be visualized during the calculation.</p>
</td></tr>
<tr><td><code id="optimize_design_twostage_+3A_...">...</code></td>
<td>
<p>additional arguments passed along.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates optimal design parameters for a two-stage three-arm gold-standard
non-inferiority trial. Run <code>vignette("Introduction", package = "OptimalGoldstandardDesigns")</code>
to see some examples related to the associated paper (Meis et al. 2023).
</p>
<p>Parameters which can be optimized are the allocation ratios for all groups and stages and the
futility and efficacy boundaries of the first stage. The allocation ratios are
cT2 = nT2 / nT1, cP1 = nP1 / nT1,
cP2 = nP2 / nT1, cC1 = nC1 / nT1 and cC2 = nC2 / nT1. Here, nT1 denotes the sample size
of the treatment group in the first stage, nP2 the sample size of the placebo group in the
second stage, etc. The first stage efficacy boundaries are bTP1e for the treatment vs
placebo testing problem, and bTC1e for the treatment vs control non-inferiority testing
problem. The futility boundaries are denoted by bTP1f and bTC1f.
</p>
<p>If these parameters are left unspecified or set to NULL, they will be included into the
optimization process, otherwise they will be considered boundary constraints.
You may also supply quoted expressions as arguments for these
parameters to solve a constrained optimization problem. For example, you can supply
<code>cT2 = 1, cP2 = quote(cP1), cC2 = quote(cC1)</code> to ensure that the first and second
stage allocation ratios are equal.
</p>
<p>The design is optimized with respect to the objective criterion given by the parameter
<code>objective</code>. The default objective function is described in the
Subsection <em>Optimizing group sequential gold-standard designs</em> in Section 2
of (Meis et al. 2023). Additionally,
this objective includes a term to penalize the maximum sample size of a trial,
which can be controlled by the parameter <code>eta</code> (default is <code>eta=0</code>).
</p>
<p>Designs are calculated to fulfill the following constraints: the family-wise type I error
rate is controlled at <code>alpha</code> under any combination of the two null hypotheses
<code>muT - muP = 0</code> and <code>muT - muC + Delta = 0</code>.
The power to reject both hypothesis given both alternative
hypotheses <code>muT - muP = alternative_TP</code> and <code>muT - muC + Delta = alternative_TC + Delta</code>
is at least <code>1 - beta</code>. Variances are assumed to be given by <code>varT, varP</code> and <code>varC</code>.
</p>
<p>If <code>binding_futility</code> is <code>TRUE</code>, type I error recycling is used.
If <code>always_both_futility_tests</code> is <code>TRUE</code>, it is assumed that futility tests for both
hypotheses are performed at interim, regardless of whether the treatment vs placebo null hypothesis
was successfully rejected. If <code>always_both_futility_tests</code> is <code>FALSE</code>, the futility
test for the treatment vs. control testing problem only needs to be done if the null for the
treatment vs. placebo testing problem was rejected in the first stage.
</p>


<h3>Value</h3>

<p>Design object (a list) with optimized design parameters.
</p>


<h3>References</h3>

<p>Meis J, Pilz M, Herrmann C, Bokelmann B, Rauch G, Kieser M (2023).
&ldquo;Optimization of the two-stage group sequential three-arm gold-standard design for non-inferiority trials.&rdquo;
<em>Statistics in Medicine</em>, <b>42</b>(4), 536-558.
<a href="https://doi.org/10.1002/sim.9630">doi:10.1002/sim.9630</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Should take about 15 seconds.

optimize_design_twostage(
  cT2 = 1,
  cP2 = quote(cP1),
  cC2 = quote(cC1),
  bTP1f = -Inf,
  bTC1f = -Inf,
  beta = 0.2,
  alternative_TP = 0.4,
  alternative_TC = 0,
  Delta = 0.2,
  binding_futility = TRUE,
  lambda = .9,
  kappa = 1,
  nloptr_opts = list(algorithm = "NLOPT_LN_SBPLX", ftol_rel = 1e-01)
)

</code></pre>

<hr>
<h2 id='padd_whitespace'>Add whitespace padding to string</h2><span id='topic+padd_whitespace'></span>

<h3>Description</h3>

<p>Add whitespace padding to string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>padd_whitespace(str)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="padd_whitespace_+3A_str">str</code></td>
<td>
<p>a character string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string with whitespace padding until the full console width
</p>

<hr>
<h2 id='pmvnorm_'>mvtnorm::pmvnorm, but returns 0 if any lower boundary is larger than
any upper boundary</h2><span id='topic+pmvnorm_'></span>

<h3>Description</h3>

<p>mvtnorm::pmvnorm, but returns 0 if any lower boundary is larger than
any upper boundary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmvnorm_(upper, lower, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pmvnorm__+3A_upper">upper</code></td>
<td>
<p>the vector of upper limits of length n.</p>
</td></tr>
<tr><td><code id="pmvnorm__+3A_lower">lower</code></td>
<td>
<p>the vector of lower limits of length n.</p>
</td></tr>
<tr><td><code id="pmvnorm__+3A_...">...</code></td>
<td>
<p>additional parameters passed to <code><a href="mvtnorm.html#topic+pmvnorm">pmvnorm</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The evaluated distribution function is returned, if <code>keepAttr</code> is true, with attributes
</p>
<table>
<tr><td><code>error</code></td>
<td>
<p>estimated absolute error</p>
</td></tr>
<tr><td><code>msg</code></td>
<td>
<p>status message(s).</p>
</td></tr>
<tr><td><code>algorithm</code></td>
<td>
<p>a <code><a href="base.html#topic+character">character</a></code> string with <code>class(algorithm)</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="mvtnorm.html#topic+pmvnorm">pmvnorm</a></code>
</p>

<hr>
<h2 id='pmvt_'>mvtnorm::pmvt, but returns 0 if any lower boundary is larger than
any upper boundary</h2><span id='topic+pmvt_'></span>

<h3>Description</h3>

<p>mvtnorm::pmvt, but returns 0 if any lower boundary is larger than
any upper boundary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmvt_(upper, lower, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pmvt__+3A_upper">upper</code></td>
<td>
<p>the vector of upper limits of length n.</p>
</td></tr>
<tr><td><code id="pmvt__+3A_lower">lower</code></td>
<td>
<p>the vector of lower limits of length n.</p>
</td></tr>
<tr><td><code id="pmvt__+3A_...">...</code></td>
<td>
<p>additional parameters passed to <code><a href="mvtnorm.html#topic+pmvt">pmvt</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The evaluated distribution function is returned, if <code>keepAttr</code> is true, with attributes
</p>
<table>
<tr><td><code>error</code></td>
<td>
<p>estimated absolute error</p>
</td></tr>
<tr><td><code>msg</code></td>
<td>
<p>status message(s).</p>
</td></tr>
<tr><td><code>algorithm</code></td>
<td>
<p>a <code><a href="base.html#topic+character">character</a></code> string with <code>class(algorithm)</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="mvtnorm.html#topic+pmvt">pmvt</a></code>
</p>

<hr>
<h2 id='print.OneStageGoldStandardDesign'>Printing method for optimal single-stage goldstandard designs</h2><span id='topic+print.OneStageGoldStandardDesign'></span>

<h3>Description</h3>

<p>Printing method for optimal single-stage goldstandard designs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'OneStageGoldStandardDesign'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.OneStageGoldStandardDesign_+3A_x">x</code></td>
<td>
<p>An object of class OneStageGoldStandardDesign</p>
</td></tr>
<tr><td><code id="print.OneStageGoldStandardDesign_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the input x invisibly. This functions is used for its side effects, i.e. printing
design characteristics to the screen.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Should take about 2 second with the chosen accuracy
optimize_design_onestage(
  alpha = .025,
  beta = .2,
  alternative_TP = .4,
  alternative_TC = 0,
  Delta = .2,
  mvnorm_algorithm = mvtnorm::Miwa(steps = 512, checkCorr = FALSE, maxval = 1000),
  nloptr_opts = list(algorithm = "NLOPT_LN_SBPLX", ftol_rel = 1e-03, xtol_abs = 1e-08,
                     xtol_rel = 1e-07, maxeval = 1000, print_level = 0)
)

</code></pre>

<hr>
<h2 id='print.TwoStageGoldStandardDesign'>Printing method for optimal two-stage goldstandard designs</h2><span id='topic+print.TwoStageGoldStandardDesign'></span>

<h3>Description</h3>

<p>Printing method for optimal two-stage goldstandard designs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TwoStageGoldStandardDesign'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.TwoStageGoldStandardDesign_+3A_x">x</code></td>
<td>
<p>An object of class TwoStageGoldStandardDesign</p>
</td></tr>
<tr><td><code id="print.TwoStageGoldStandardDesign_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the input x invisibly. This functions is used for its side effects, i.e. printing
design characteristics to the screen.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Should take about 15 seconds.

optimize_design_twostage(
  cT2 = 1,
  cP2 = quote(cP1),
  cC2 = quote(cC1),
  bTP1f = -Inf,
  bTC1f = -Inf,
  beta = 0.2,
  alternative_TP = 0.4,
  alternative_TC = 0,
  Delta = 0.2,
  binding_futility = TRUE,
  lambda = .9,
  kappa = 1,
  nloptr_opts = list(algorithm = "NLOPT_LN_SBPLX", ftol_rel = 1e-01)
)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
