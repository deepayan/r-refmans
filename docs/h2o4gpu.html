<!DOCTYPE html><html lang="en"><head><title>Help for package h2o4gpu</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {h2o4gpu}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#h2o4gpu'><p>h2o4gpu in R</p></a></li>
<li><a href='#fit'><p>Generic Method to Train an H2O4GPU Estimator</p></a></li>
<li><a href='#fit.h2o4gpu_model'><p>Train an H2O4GPU Estimator</p></a></li>
<li><a href='#h2o4gpu.elastic_net_classifier'><p>Elastic Net Classifier</p></a></li>
<li><a href='#h2o4gpu.elastic_net_regressor'><p>Elastic Net Regressor</p></a></li>
<li><a href='#h2o4gpu.gradient_boosting_classifier'><p>Gradient Boosting Classifier</p></a></li>
<li><a href='#h2o4gpu.gradient_boosting_regressor'><p>Gradient Boosting Regressor</p></a></li>
<li><a href='#h2o4gpu.kmeans'><p>K-means Clustering</p></a></li>
<li><a href='#h2o4gpu.pca'><p>Principal Component Analysis (PCA)</p></a></li>
<li><a href='#h2o4gpu.random_forest_classifier'><p>Random Forest Classifier</p></a></li>
<li><a href='#h2o4gpu.random_forest_regressor'><p>Random Forest Regressor</p></a></li>
<li><a href='#h2o4gpu.truncated_svd'><p>Truncated Singular Value Decomposition (TruncatedSVD)</p></a></li>
<li><a href='#predict.h2o4gpu_model'><p>Make Predictions using Trained H2O4GPU Estimator</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#transform.h2o4gpu_model'><p>Transform a Dataset using Trained H2O4GPU Estimator</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Interface to 'H2O4GPU'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Interface to 'H2O4GPU' <a href="https://github.com/h2oai/h2o4gpu">https://github.com/h2oai/h2o4gpu</a>, a collection of 'GPU' solvers for machine learning algorithms.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License 2.0</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/h2oai/h2o4gpu">https://github.com/h2oai/h2o4gpu</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/h2oai/h2o4gpu/issues">https://github.com/h2oai/h2o4gpu/issues</a></td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>Python (&gt;= 3.6) with header files and shared
library; H2O4GPU (https://github.com/h2oai/h2o4gpu)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, magrittr, reticulate (&ge; 1.4)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, Matrix</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-05-17 21:43:33 UTC; navdeep</td>
</tr>
<tr>
<td>Author:</td>
<td>Yuan Tang <a href="https://orcid.org/0000-0001-5243-233X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Navdeep Gill [aut, cre],
  Erin LeDell [aut],
  Vladimir Ovsyannikov [aut],
  H2O.ai [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Navdeep Gill &lt;navdeep@h2o.ai&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-05-17 22:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='h2o4gpu'>h2o4gpu in R</h2><span id='topic+h2o4gpu'></span><span id='topic+h2o4gpu-package'></span>

<h3>Description</h3>

<p>h2o4gpu in R
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

library(h2o4gpu)

# Setup dataset
x &lt;- iris[1:4]
y &lt;- as.integer(iris$Species) - 1

# Initialize and train the classifier
model &lt;- h2o4gpu.random_forest_classifier() %&gt;% fit(x, y)

# Make predictions
predictions &lt;- model %&gt;% predict(x)


## End(Not run)
</code></pre>

<hr>
<h2 id='fit'>Generic Method to Train an H2O4GPU Estimator</h2><span id='topic+fit'></span><span id='topic+transform'></span>

<h3>Description</h3>

<p>Generic Method to Train an H2O4GPU Estimator
</p>
<p>Generic Method to Transform a Dataset using Trained H2O4GPU Estimator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit(object, ...)

transform(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_+3A_object">object</code></td>
<td>
<p>The h2o4gpu model object</p>
</td></tr>
<tr><td><code id="fit_+3A_...">...</code></td>
<td>
<p>Additional arguments (unused for now).</p>
</td></tr>
</table>

<hr>
<h2 id='fit.h2o4gpu_model'>Train an H2O4GPU Estimator</h2><span id='topic+fit.h2o4gpu_model'></span>

<h3>Description</h3>

<p>This function builds the model using the training data specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'h2o4gpu_model'
fit(object, x, y = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit.h2o4gpu_model_+3A_object">object</code></td>
<td>
<p>The h2o4gpu model object</p>
</td></tr>
<tr><td><code id="fit.h2o4gpu_model_+3A_x">x</code></td>
<td>
<p>The training data where each column represents a different predictor variable
to be used in building the model.</p>
</td></tr>
<tr><td><code id="fit.h2o4gpu_model_+3A_y">y</code></td>
<td>
<p>A vector of numeric values to be used as response variable in building the model.
Note that if the vector is character or factor, it will be converted to numeric column
(e.g. 0, 1, 2, ...) implicitly. For unsupervised models, this argument can be ignored or
specified as <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="fit.h2o4gpu_model_+3A_...">...</code></td>
<td>
<p>Additional arguments (unused for now).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

library(h2o4gpu)

# Setup dataset
x &lt;- iris[1:4]
y &lt;- as.integer(iris$Species) - 1

# Train the classifier
h2o4gpu.random_forest_classifier() %&gt;% fit(x, y)

## End(Not run)
</code></pre>

<hr>
<h2 id='h2o4gpu.elastic_net_classifier'>Elastic Net Classifier</h2><span id='topic+h2o4gpu.elastic_net_classifier'></span>

<h3>Description</h3>

<p>Elastic Net Classifier
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h2o4gpu.elastic_net_classifier(alpha = 1, l1_ratio = 0.5,
  fit_intercept = TRUE, normalize = FALSE, precompute = FALSE,
  max_iter = 5000L, copy_X = TRUE, tol = 0.01, warm_start = FALSE,
  positive = FALSE, random_state = NULL, selection = "cyclic",
  n_gpus = -1L, lambda_stop_early = TRUE, glm_stop_early = TRUE,
  glm_stop_early_error_fraction = 1, verbose = FALSE, n_threads = NULL,
  gpu_id = 0L, lambda_min_ratio = 1e-07, n_lambdas = 100L, n_folds = 5L,
  tol_seek_factor = 0.1, store_full_path = 0L, lambda_max = NULL,
  lambdas = NULL, double_precision = NULL, order = NULL,
  backend = "h2o4gpu")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="h2o4gpu.elastic_net_classifier_+3A_alpha">alpha</code></td>
<td>
<p>Constant that multiplies the penalty terms. Defaults to 1.0. See the notes for the exact mathematical meaning of this parameter.<code>alpha = 0</code> is equivalent to an ordinary least square, solved by the :class:<code>LinearRegressionSklearn</code> object. For numerical reasons, using <code>alpha = 0</code> with the <code>LassoSklearn</code> object is not advised. Given this, you should use the :class:<code>LinearRegressionSklearn</code> object.</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_classifier_+3A_l1_ratio">l1_ratio</code></td>
<td>
<p>The ElasticNetSklearn mixing parameter, with <code>0 &lt;= l1_ratio &lt;= 1</code>. For <code>l1_ratio = 0</code> the penalty is an L2 penalty. <code>For l1_ratio = 1</code> it is an L1 penalty. For <code>0 &lt; l1_ratio &lt; 1</code>, the penalty is a combination of L1 and L2.</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_classifier_+3A_fit_intercept">fit_intercept</code></td>
<td>
<p>Whether the intercept should be estimated or not. If <code>FALSE</code>, the data is assumed to be already centered.</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_classifier_+3A_normalize">normalize</code></td>
<td>
<p>This parameter is ignored when <code>fit_intercept</code> is set to FALSE. If TRUE, the regressors X will be normalized before regression by subtracting the mean and dividing by the l2-norm. If you wish to standardize, please use :class:<code>h2o4gpu.preprocessing.StandardScaler</code> before calling <code>fit</code> on an estimator with <code>normalize=FALSE</code>.</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_classifier_+3A_precompute">precompute</code></td>
<td>
<p>Whether to use a precomputed Gram matrix to speed up calculations. The Gram matrix can also be passed as argument. For sparse input this option is always <code>TRUE</code> to preserve sparsity.</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_classifier_+3A_max_iter">max_iter</code></td>
<td>
<p>The maximum number of iterations</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_classifier_+3A_copy_x">copy_X</code></td>
<td>
<p>If <code>TRUE</code>, X will be copied; else, it may be overwritten.</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_classifier_+3A_tol">tol</code></td>
<td>
<p>The tolerance for the optimization: if the updates are smaller than <code>tol</code>, the optimization code checks the dual gap for optimality and continues until it is smaller than <code>tol</code>.</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_classifier_+3A_warm_start">warm_start</code></td>
<td>
<p>When set to <code>TRUE</code>, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_classifier_+3A_positive">positive</code></td>
<td>
<p>When set to <code>TRUE</code>, forces the coefficients to be positive.</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_classifier_+3A_random_state">random_state</code></td>
<td>
<p>The seed of the pseudo random number generator that selects a random feature to update. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If NULL, the random number generator is the RandomState instance used by <code>np.random</code>. Used when <code>selection</code> == 'random'.</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_classifier_+3A_selection">selection</code></td>
<td>
<p>If set to 'random', a random coefficient is updated every iteration rather than looping over features sequentially by default. This (setting to 'random') often leads to significantly faster convergence especially when tol is higher than 1e-4.</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_classifier_+3A_n_gpus">n_gpus</code></td>
<td>
<p>Number of gpu's to use in GLM solver.</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_classifier_+3A_lambda_stop_early">lambda_stop_early</code></td>
<td>
<p>Stop early when there is no more relative improvement on train or validation.</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_classifier_+3A_glm_stop_early">glm_stop_early</code></td>
<td>
<p>Stop early when there is no more relative improvement in the primary and dual residuals for ADMM.</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_classifier_+3A_glm_stop_early_error_fraction">glm_stop_early_error_fraction</code></td>
<td>
<p>Relative tolerance for metric-based stopping criterion (stop if relative improvement is not at least this much).</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_classifier_+3A_verbose">verbose</code></td>
<td>
<p>Print verbose information to the console if set to &gt; 0.</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_classifier_+3A_n_threads">n_threads</code></td>
<td>
<p>Number of threads to use in the gpu. Each thread is an independent model builder.</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_classifier_+3A_gpu_id">gpu_id</code></td>
<td>
<p>ID of the GPU on which the algorithm should run.</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_classifier_+3A_lambda_min_ratio">lambda_min_ratio</code></td>
<td>
<p>Minimum lambda ratio to maximum lambda, used in lambda search.</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_classifier_+3A_n_lambdas">n_lambdas</code></td>
<td>
<p>Number of lambdas to be used in a search.</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_classifier_+3A_n_folds">n_folds</code></td>
<td>
<p>Number of cross validation folds.</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_classifier_+3A_tol_seek_factor">tol_seek_factor</code></td>
<td>
<p>Factor of tolerance to seek once below null model accuracy. Default is 1E-1, so seeks tolerance of 1E-3 once below null model accuracy for tol=1E-2.</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_classifier_+3A_store_full_path">store_full_path</code></td>
<td>
<p>Whether to store full solution for all alphas and lambdas. If 1, then during predict will compute best and full predictions.</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_classifier_+3A_lambda_max">lambda_max</code></td>
<td>
<p>Maximum Lambda value to use. Default is NULL, and then internally compute standard maximum</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_classifier_+3A_lambdas">lambdas</code></td>
<td>
<p>overrides n_lambdas, lambda_max, and lambda_min_ratio.</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_classifier_+3A_double_precision">double_precision</code></td>
<td>
<p>Internally set unless using _ptr methods. Value can either be 0 (float32) or 1(float64)</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_classifier_+3A_order">order</code></td>
<td>
<p>Order of data. Default is NULL, and internally determined (unless using _ptr methods) whether row 'r' or column 'c' major order.</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_classifier_+3A_backend">backend</code></td>
<td>
<p>Which backend to use. Options are 'auto', 'sklearn', 'h2o4gpu'. Saves as attribute for actual backend used.</p>
</td></tr>
</table>

<hr>
<h2 id='h2o4gpu.elastic_net_regressor'>Elastic Net Regressor</h2><span id='topic+h2o4gpu.elastic_net_regressor'></span>

<h3>Description</h3>

<p>Elastic Net Regressor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h2o4gpu.elastic_net_regressor(alpha = 1, l1_ratio = 0.5,
  fit_intercept = TRUE, normalize = FALSE, precompute = FALSE,
  max_iter = 5000L, copy_X = TRUE, tol = 0.01, warm_start = FALSE,
  positive = FALSE, random_state = NULL, selection = "cyclic",
  n_gpus = -1L, lambda_stop_early = TRUE, glm_stop_early = TRUE,
  glm_stop_early_error_fraction = 1, verbose = FALSE, n_threads = NULL,
  gpu_id = 0L, lambda_min_ratio = 1e-07, n_lambdas = 100L, n_folds = 5L,
  tol_seek_factor = 0.1, store_full_path = 0L, lambda_max = NULL,
  lambdas = NULL, double_precision = NULL, order = NULL,
  backend = "h2o4gpu")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="h2o4gpu.elastic_net_regressor_+3A_alpha">alpha</code></td>
<td>
<p>Constant that multiplies the penalty terms. Defaults to 1.0. See the notes for the exact mathematical meaning of this parameter.<code>alpha = 0</code> is equivalent to an ordinary least square, solved by the :class:<code>LinearRegressionSklearn</code> object. For numerical reasons, using <code>alpha = 0</code> with the <code>LassoSklearn</code> object is not advised. Given this, you should use the :class:<code>LinearRegressionSklearn</code> object.</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_regressor_+3A_l1_ratio">l1_ratio</code></td>
<td>
<p>The ElasticNetSklearn mixing parameter, with <code>0 &lt;= l1_ratio &lt;= 1</code>. For <code>l1_ratio = 0</code> the penalty is an L2 penalty. <code>For l1_ratio = 1</code> it is an L1 penalty. For <code>0 &lt; l1_ratio &lt; 1</code>, the penalty is a combination of L1 and L2.</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_regressor_+3A_fit_intercept">fit_intercept</code></td>
<td>
<p>Whether the intercept should be estimated or not. If <code>FALSE</code>, the data is assumed to be already centered.</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_regressor_+3A_normalize">normalize</code></td>
<td>
<p>This parameter is ignored when <code>fit_intercept</code> is set to FALSE. If TRUE, the regressors X will be normalized before regression by subtracting the mean and dividing by the l2-norm. If you wish to standardize, please use :class:<code>h2o4gpu.preprocessing.StandardScaler</code> before calling <code>fit</code> on an estimator with <code>normalize=FALSE</code>.</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_regressor_+3A_precompute">precompute</code></td>
<td>
<p>Whether to use a precomputed Gram matrix to speed up calculations. The Gram matrix can also be passed as argument. For sparse input this option is always <code>TRUE</code> to preserve sparsity.</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_regressor_+3A_max_iter">max_iter</code></td>
<td>
<p>The maximum number of iterations</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_regressor_+3A_copy_x">copy_X</code></td>
<td>
<p>If <code>TRUE</code>, X will be copied; else, it may be overwritten.</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_regressor_+3A_tol">tol</code></td>
<td>
<p>The tolerance for the optimization: if the updates are smaller than <code>tol</code>, the optimization code checks the dual gap for optimality and continues until it is smaller than <code>tol</code>.</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_regressor_+3A_warm_start">warm_start</code></td>
<td>
<p>When set to <code>TRUE</code>, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution.</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_regressor_+3A_positive">positive</code></td>
<td>
<p>When set to <code>TRUE</code>, forces the coefficients to be positive.</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_regressor_+3A_random_state">random_state</code></td>
<td>
<p>The seed of the pseudo random number generator that selects a random feature to update. If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If NULL, the random number generator is the RandomState instance used by <code>np.random</code>. Used when <code>selection</code> == 'random'.</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_regressor_+3A_selection">selection</code></td>
<td>
<p>If set to 'random', a random coefficient is updated every iteration rather than looping over features sequentially by default. This (setting to 'random') often leads to significantly faster convergence especially when tol is higher than 1e-4.</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_regressor_+3A_n_gpus">n_gpus</code></td>
<td>
<p>Number of gpu's to use in GLM solver.</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_regressor_+3A_lambda_stop_early">lambda_stop_early</code></td>
<td>
<p>Stop early when there is no more relative improvement on train or validation.</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_regressor_+3A_glm_stop_early">glm_stop_early</code></td>
<td>
<p>Stop early when there is no more relative improvement in the primary and dual residuals for ADMM.</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_regressor_+3A_glm_stop_early_error_fraction">glm_stop_early_error_fraction</code></td>
<td>
<p>Relative tolerance for metric-based stopping criterion (stop if relative improvement is not at least this much).</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_regressor_+3A_verbose">verbose</code></td>
<td>
<p>Print verbose information to the console if set to &gt; 0.</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_regressor_+3A_n_threads">n_threads</code></td>
<td>
<p>Number of threads to use in the gpu. Each thread is an independent model builder.</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_regressor_+3A_gpu_id">gpu_id</code></td>
<td>
<p>ID of the GPU on which the algorithm should run.</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_regressor_+3A_lambda_min_ratio">lambda_min_ratio</code></td>
<td>
<p>Minimum lambda ratio to maximum lambda, used in lambda search.</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_regressor_+3A_n_lambdas">n_lambdas</code></td>
<td>
<p>Number of lambdas to be used in a search.</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_regressor_+3A_n_folds">n_folds</code></td>
<td>
<p>Number of cross validation folds.</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_regressor_+3A_tol_seek_factor">tol_seek_factor</code></td>
<td>
<p>Factor of tolerance to seek once below null model accuracy. Default is 1E-1, so seeks tolerance of 1E-3 once below null model accuracy for tol=1E-2.</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_regressor_+3A_store_full_path">store_full_path</code></td>
<td>
<p>Whether to store full solution for all alphas and lambdas. If 1, then during predict will compute best and full predictions.</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_regressor_+3A_lambda_max">lambda_max</code></td>
<td>
<p>Maximum Lambda value to use. Default is NULL, and then internally compute standard maximum</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_regressor_+3A_lambdas">lambdas</code></td>
<td>
<p>overrides n_lambdas, lambda_max, and lambda_min_ratio.</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_regressor_+3A_double_precision">double_precision</code></td>
<td>
<p>Internally set unless using _ptr methods. Value can either be 0 (float32) or 1(float64)</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_regressor_+3A_order">order</code></td>
<td>
<p>Order of data. Default is NULL, and internally determined (unless using _ptr methods) whether row 'r' or column 'c' major order.</p>
</td></tr>
<tr><td><code id="h2o4gpu.elastic_net_regressor_+3A_backend">backend</code></td>
<td>
<p>Which backend to use. Options are 'auto', 'sklearn', 'h2o4gpu'. Saves as attribute for actual backend used.</p>
</td></tr>
</table>

<hr>
<h2 id='h2o4gpu.gradient_boosting_classifier'>Gradient Boosting Classifier</h2><span id='topic+h2o4gpu.gradient_boosting_classifier'></span>

<h3>Description</h3>

<p>Gradient Boosting Classifier
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h2o4gpu.gradient_boosting_classifier(loss = "deviance", learning_rate = 0.1,
  n_estimators = 100L, subsample = 1, criterion = "friedman_mse",
  min_samples_split = 2L, min_samples_leaf = 1L,
  min_weight_fraction_leaf = 0, max_depth = 3L, min_impurity_decrease = 0,
  min_impurity_split = NULL, init = NULL, random_state = NULL,
  max_features = "auto", verbose = 0L, max_leaf_nodes = NULL,
  warm_start = FALSE, presort = "auto", colsample_bytree = 1,
  num_parallel_tree = 1L, tree_method = "gpu_hist", n_gpus = -1L,
  predictor = "gpu_predictor", objective = "binary:logistic",
  booster = "gbtree", n_jobs = 1L, gamma = 0L, min_child_weight = 1L,
  max_delta_step = 0L, colsample_bylevel = 1L, reg_alpha = 0L,
  reg_lambda = 1L, scale_pos_weight = 1L, base_score = 0.5,
  missing = NULL, backend = "h2o4gpu", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="h2o4gpu.gradient_boosting_classifier_+3A_loss">loss</code></td>
<td>
<p>loss function to be optimized. 'deviance' refers to deviance (= logistic regression) for classification with probabilistic outputs. For loss 'exponential' gradient boosting recovers the AdaBoost algorithm.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_classifier_+3A_learning_rate">learning_rate</code></td>
<td>
<p>learning rate shrinks the contribution of each tree by <code>learning_rate</code>. There is a trade-off between learning_rate and n_estimators.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_classifier_+3A_n_estimators">n_estimators</code></td>
<td>
<p>The number of boosting stages to perform. Gradient boosting is fairly robust to over-fitting so a large number usually results in better performance.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_classifier_+3A_subsample">subsample</code></td>
<td>
<p>The fraction of samples to be used for fitting the individual base learners. If smaller than 1.0 this results in Stochastic Gradient Boosting. <code>subsample</code> interacts with the parameter <code>n_estimators</code>. Choosing <code>subsample &lt; 1.0</code> leads to a reduction of variance and an increase in bias.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_classifier_+3A_criterion">criterion</code></td>
<td>
<p>The function to measure the quality of a split. Supported criteria are &quot;friedman_mse&quot; for the mean squared error with improvement score by Friedman, &quot;mse&quot; for mean squared error, and &quot;mae&quot; for the mean absolute error. The default value of &quot;friedman_mse&quot; is generally the best as it can provide a better approximation in some cases.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_classifier_+3A_min_samples_split">min_samples_split</code></td>
<td>
<p>The minimum number of samples required to split an internal node:</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_classifier_+3A_min_samples_leaf">min_samples_leaf</code></td>
<td>
<p>The minimum number of samples required to be at a leaf node:</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_classifier_+3A_min_weight_fraction_leaf">min_weight_fraction_leaf</code></td>
<td>
<p>The minimum weighted fraction of the sum total of weights (of all the input samples) required to be at a leaf node. Samples have equal weight when sample_weight is not provided.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_classifier_+3A_max_depth">max_depth</code></td>
<td>
<p>maximum depth of the individual regression estimators. The maximum depth limits the number of nodes in the tree. Tune this parameter for best performance; the best value depends on the interaction of the input variables.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_classifier_+3A_min_impurity_decrease">min_impurity_decrease</code></td>
<td>
<p>A node will be split if this split induces a decrease of the impurity greater than or equal to this value.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_classifier_+3A_min_impurity_split">min_impurity_split</code></td>
<td>
<p>Threshold for early stopping in tree growth. A node will split if its impurity is above the threshold, otherwise it is a leaf.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_classifier_+3A_init">init</code></td>
<td>
<p>An estimator object that is used to compute the initial predictions. <code>init</code> has to provide <code>fit</code> and <code>predict</code>. If NULL it uses <code>loss.init_estimator</code>.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_classifier_+3A_random_state">random_state</code></td>
<td>
<p>If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If NULL, the random number generator is the RandomState instance used by <code>np.random</code>.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_classifier_+3A_max_features">max_features</code></td>
<td>
<p>The number of features to consider when looking for the best split:</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_classifier_+3A_verbose">verbose</code></td>
<td>
<p>Enable verbose output. If 1 then it prints progress and performance once in a while (the more trees the lower the frequency). If greater than 1 then it prints progress and performance for every tree.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_classifier_+3A_max_leaf_nodes">max_leaf_nodes</code></td>
<td>
<p>Grow trees with <code>max_leaf_nodes</code> in best-first fashion. Best nodes are defined as relative reduction in impurity. If NULL then unlimited number of leaf nodes.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_classifier_+3A_warm_start">warm_start</code></td>
<td>
<p>When set to <code>TRUE</code>, reuse the solution of the previous call to fit and add more estimators to the ensemble, otherwise, just erase the previous solution.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_classifier_+3A_presort">presort</code></td>
<td>
<p>Whether to presort the data to speed up the finding of best splits in fitting. Auto mode by default will use presorting on dense data and default to normal sorting on sparse data. Setting presort to true on sparse data will raise an error.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_classifier_+3A_colsample_bytree">colsample_bytree</code></td>
<td>
<p>Subsample ratio of columns when constructing each tree.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_classifier_+3A_num_parallel_tree">num_parallel_tree</code></td>
<td>
<p>Number of trees to grow per round</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_classifier_+3A_tree_method">tree_method</code></td>
<td>
<p>The tree construction algorithm used in XGBoost Distributed and external memory version only support approximate algorithm. Choices: ‘auto’, ‘exact’, ‘approx’, ‘hist’, ‘gpu_exact’, ‘gpu_hist’ ‘auto’: Use heuristic to choose faster one. - For small to medium dataset, exact greedy will be used. - For very large-dataset, approximate algorithm will be chosen. - Because old behavior is always use exact greedy in single machine, - user will get a message when approximate algorithm is chosen to notify this choice. ‘exact’: Exact greedy algorithm. ‘approx’: Approximate greedy algorithm using sketching and histogram. ‘hist’: Fast histogram optimized approximate greedy algorithm. It uses some performance improvements such as bins caching. ‘gpu_exact’: GPU implementation of exact algorithm. ‘gpu_hist’: GPU implementation of hist algorithm.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_classifier_+3A_n_gpus">n_gpus</code></td>
<td>
<p>Number of gpu's to use in GradientBoostingClassifier solver. Default is -1.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_classifier_+3A_predictor">predictor</code></td>
<td>
<p>The type of predictor algorithm to use. Provides the same results but allows the use of GPU or CPU. - 'cpu_predictor': Multicore CPU prediction algorithm. - 'gpu_predictor': Prediction using GPU. Default for 'gpu_exact' and 'gpu_hist' tree method.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_classifier_+3A_objective">objective</code></td>
<td>
<p>Specify the learning task and the corresponding learning objective or a custom objective function to be used Note: A custom objective function can be provided for the objective parameter. In this case, it should have the signature objective(y_true, y_pred) -&gt; grad, hess:</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_classifier_+3A_booster">booster</code></td>
<td>
<p>Specify which booster to use: gbtree, gblinear or dart.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_classifier_+3A_n_jobs">n_jobs</code></td>
<td>
<p>Number of parallel threads used to run xgboost.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_classifier_+3A_gamma">gamma</code></td>
<td>
<p>Minimum loss reduction required to make a further partition on a leaf node of the tree.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_classifier_+3A_min_child_weight">min_child_weight</code></td>
<td>
<p>Minimum sum of instance weight(hessian) needed in a child.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_classifier_+3A_max_delta_step">max_delta_step</code></td>
<td>
<p>Maximum delta step we allow each tree’s weight estimation to be.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_classifier_+3A_colsample_bylevel">colsample_bylevel</code></td>
<td>
<p>Subsample ratio of columns for each split, in each level.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_classifier_+3A_reg_alpha">reg_alpha</code></td>
<td>
<p>L1 regularization term on weights</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_classifier_+3A_reg_lambda">reg_lambda</code></td>
<td>
<p>L2 regularization term on weights</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_classifier_+3A_scale_pos_weight">scale_pos_weight</code></td>
<td>
<p>Balancing of positive and negative weights.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_classifier_+3A_base_score">base_score</code></td>
<td>
<p>The initial prediction score of all instances, global bias.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_classifier_+3A_missing">missing</code></td>
<td>
<p>Value in the data which needs to be present as a missing value. If NULL, defaults to np.nan.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_classifier_+3A_backend">backend</code></td>
<td>
<p>Which backend to use. Options are 'auto', 'sklearn', 'h2o4gpu'. Saves as attribute for actual backend used.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_classifier_+3A_...">...</code></td>
<td>
<p>Other parameters for XGBoost object. Full documentation of parameters can be found here: https://github.com/dmlc/xgboost/blob/master/doc/parameter.md</p>
</td></tr>
</table>

<hr>
<h2 id='h2o4gpu.gradient_boosting_regressor'>Gradient Boosting Regressor</h2><span id='topic+h2o4gpu.gradient_boosting_regressor'></span>

<h3>Description</h3>

<p>Gradient Boosting Regressor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h2o4gpu.gradient_boosting_regressor(loss = "ls", learning_rate = 0.1,
  n_estimators = 100L, subsample = 1, criterion = "friedman_mse",
  min_samples_split = 2L, min_samples_leaf = 1L,
  min_weight_fraction_leaf = 0, max_depth = 3L, min_impurity_decrease = 0,
  min_impurity_split = NULL, init = NULL, random_state = NULL,
  max_features = "auto", alpha = 0.9, verbose = 0L,
  max_leaf_nodes = NULL, warm_start = FALSE, presort = "auto",
  colsample_bytree = 1, num_parallel_tree = 1L, tree_method = "gpu_hist",
  n_gpus = -1L, predictor = "gpu_predictor", objective = "reg:linear",
  booster = "gbtree", n_jobs = 1L, gamma = 0L, min_child_weight = 1L,
  max_delta_step = 0L, colsample_bylevel = 1L, reg_alpha = 0L,
  reg_lambda = 1L, scale_pos_weight = 1L, base_score = 0.5,
  missing = NULL, backend = "h2o4gpu", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="h2o4gpu.gradient_boosting_regressor_+3A_loss">loss</code></td>
<td>
<p>loss function to be optimized. 'ls' refers to least squares regression. 'lad' (least absolute deviation) is a highly robust loss function solely based on order information of the input variables. 'huber' is a combination of the two. 'quantile' allows quantile regression (use <code>alpha</code> to specify the quantile).</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_regressor_+3A_learning_rate">learning_rate</code></td>
<td>
<p>learning rate shrinks the contribution of each tree by <code>learning_rate</code>. There is a trade-off between learning_rate and n_estimators.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_regressor_+3A_n_estimators">n_estimators</code></td>
<td>
<p>The number of boosting stages to perform. Gradient boosting is fairly robust to over-fitting so a large number usually results in better performance.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_regressor_+3A_subsample">subsample</code></td>
<td>
<p>The fraction of samples to be used for fitting the individual base learners. If smaller than 1.0 this results in Stochastic Gradient Boosting. <code>subsample</code> interacts with the parameter <code>n_estimators</code>. Choosing <code>subsample &lt; 1.0</code> leads to a reduction of variance and an increase in bias.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_regressor_+3A_criterion">criterion</code></td>
<td>
<p>The function to measure the quality of a split. Supported criteria are &quot;friedman_mse&quot; for the mean squared error with improvement score by Friedman, &quot;mse&quot; for mean squared error, and &quot;mae&quot; for the mean absolute error. The default value of &quot;friedman_mse&quot; is generally the best as it can provide a better approximation in some cases.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_regressor_+3A_min_samples_split">min_samples_split</code></td>
<td>
<p>The minimum number of samples required to split an internal node:</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_regressor_+3A_min_samples_leaf">min_samples_leaf</code></td>
<td>
<p>The minimum number of samples required to be at a leaf node:</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_regressor_+3A_min_weight_fraction_leaf">min_weight_fraction_leaf</code></td>
<td>
<p>The minimum weighted fraction of the sum total of weights (of all the input samples) required to be at a leaf node. Samples have equal weight when sample_weight is not provided.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_regressor_+3A_max_depth">max_depth</code></td>
<td>
<p>maximum depth of the individual regression estimators. The maximum depth limits the number of nodes in the tree. Tune this parameter for best performance; the best value depends on the interaction of the input variables.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_regressor_+3A_min_impurity_decrease">min_impurity_decrease</code></td>
<td>
<p>A node will be split if this split induces a decrease of the impurity greater than or equal to this value.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_regressor_+3A_min_impurity_split">min_impurity_split</code></td>
<td>
<p>Threshold for early stopping in tree growth. A node will split if its impurity is above the threshold, otherwise it is a leaf.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_regressor_+3A_init">init</code></td>
<td>
<p>An estimator object that is used to compute the initial predictions. <code>init</code> has to provide <code>fit</code> and <code>predict</code>. If NULL it uses <code>loss.init_estimator</code>.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_regressor_+3A_random_state">random_state</code></td>
<td>
<p>If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If NULL, the random number generator is the RandomState instance used by <code>np.random</code>.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_regressor_+3A_max_features">max_features</code></td>
<td>
<p>The number of features to consider when looking for the best split:</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_regressor_+3A_alpha">alpha</code></td>
<td>
<p>The alpha-quantile of the huber loss function and the quantile loss function. Only if <code>loss='huber'</code> or <code>loss='quantile'</code>.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_regressor_+3A_verbose">verbose</code></td>
<td>
<p>Enable verbose output. If 1 then it prints progress and performance once in a while (the more trees the lower the frequency). If greater than 1 then it prints progress and performance for every tree.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_regressor_+3A_max_leaf_nodes">max_leaf_nodes</code></td>
<td>
<p>Grow trees with <code>max_leaf_nodes</code> in best-first fashion. Best nodes are defined as relative reduction in impurity. If NULL then unlimited number of leaf nodes.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_regressor_+3A_warm_start">warm_start</code></td>
<td>
<p>When set to <code>TRUE</code>, reuse the solution of the previous call to fit and add more estimators to the ensemble, otherwise, just erase the previous solution.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_regressor_+3A_presort">presort</code></td>
<td>
<p>Whether to presort the data to speed up the finding of best splits in fitting. Auto mode by default will use presorting on dense data and default to normal sorting on sparse data. Setting presort to true on sparse data will raise an error.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_regressor_+3A_colsample_bytree">colsample_bytree</code></td>
<td>
<p>Subsample ratio of columns when constructing each tree.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_regressor_+3A_num_parallel_tree">num_parallel_tree</code></td>
<td>
<p>Number of trees to grow per round</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_regressor_+3A_tree_method">tree_method</code></td>
<td>
<p>The tree construction algorithm used in XGBoost Distributed and external memory version only support approximate algorithm. Choices: ‘auto’, ‘exact’, ‘approx’, ‘hist’, ‘gpu_exact’, ‘gpu_hist’ ‘auto’: Use heuristic to choose faster one. - For small to medium dataset, exact greedy will be used. - For very large-dataset, approximate algorithm will be chosen. - Because old behavior is always use exact greedy in single machine, - user will get a message when approximate algorithm is chosen to notify this choice. ‘exact’: Exact greedy algorithm. ‘approx’: Approximate greedy algorithm using sketching and histogram. ‘hist’: Fast histogram optimized approximate greedy algorithm. It uses some performance improvements such as bins caching. ‘gpu_exact’: GPU implementation of exact algorithm. ‘gpu_hist’: GPU implementation of hist algorithm.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_regressor_+3A_n_gpus">n_gpus</code></td>
<td>
<p>Number of gpu's to use in GradientBoostingRegressor solver. Default is -1.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_regressor_+3A_predictor">predictor</code></td>
<td>
<p>The type of predictor algorithm to use. Provides the same results but allows the use of GPU or CPU. - 'cpu_predictor': Multicore CPU prediction algorithm. - 'gpu_predictor': Prediction using GPU. Default for 'gpu_exact' and 'gpu_hist' tree method.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_regressor_+3A_objective">objective</code></td>
<td>
<p>Specify the learning task and the corresponding learning objective or a custom objective function to be used Note: A custom objective function can be provided for the objective parameter. In this case, it should have the signature objective(y_true, y_pred) -&gt; grad, hess:</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_regressor_+3A_booster">booster</code></td>
<td>
<p>Specify which booster to use: gbtree, gblinear or dart.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_regressor_+3A_n_jobs">n_jobs</code></td>
<td>
<p>Number of parallel threads used to run xgboost.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_regressor_+3A_gamma">gamma</code></td>
<td>
<p>Minimum loss reduction required to make a further partition on a leaf node of the tree.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_regressor_+3A_min_child_weight">min_child_weight</code></td>
<td>
<p>Minimum sum of instance weight(hessian) needed in a child.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_regressor_+3A_max_delta_step">max_delta_step</code></td>
<td>
<p>Maximum delta step we allow each tree’s weight estimation to be.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_regressor_+3A_colsample_bylevel">colsample_bylevel</code></td>
<td>
<p>Subsample ratio of columns for each split, in each level.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_regressor_+3A_reg_alpha">reg_alpha</code></td>
<td>
<p>L1 regularization term on weights</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_regressor_+3A_reg_lambda">reg_lambda</code></td>
<td>
<p>L2 regularization term on weights</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_regressor_+3A_scale_pos_weight">scale_pos_weight</code></td>
<td>
<p>Balancing of positive and negative weights.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_regressor_+3A_base_score">base_score</code></td>
<td>
<p>The initial prediction score of all instances, global bias.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_regressor_+3A_missing">missing</code></td>
<td>
<p>Value in the data which needs to be present as a missing value. If NULL, defaults to np.nan.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_regressor_+3A_backend">backend</code></td>
<td>
<p>Which backend to use. Options are 'auto', 'sklearn', 'h2o4gpu'. Saves as attribute for actual backend used.</p>
</td></tr>
<tr><td><code id="h2o4gpu.gradient_boosting_regressor_+3A_...">...</code></td>
<td>
<p>Other parameters for XGBoost object. Full documentation of parameters can be found here: https://github.com/dmlc/xgboost/blob/master/doc/parameter.md</p>
</td></tr>
</table>

<hr>
<h2 id='h2o4gpu.kmeans'>K-means Clustering</h2><span id='topic+h2o4gpu.kmeans'></span>

<h3>Description</h3>

<p>K-means Clustering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h2o4gpu.kmeans(n_clusters = 8L, init = "k-means++", n_init = 1L,
  max_iter = 300L, tol = 1e-04, precompute_distances = "auto",
  verbose = 0L, random_state = NULL, copy_x = TRUE, n_jobs = 1L,
  algorithm = "auto", gpu_id = 0L, n_gpus = -1L, do_checks = 1L,
  backend = "h2o4gpu")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="h2o4gpu.kmeans_+3A_n_clusters">n_clusters</code></td>
<td>
<p>The number of clusters to form as well as the number of centroids to generate.</p>
</td></tr>
<tr><td><code id="h2o4gpu.kmeans_+3A_init">init</code></td>
<td>
<p>Method for initialization, defaults to 'random': 'k-means++' : selects initial cluster centers for k-mean clustering in a smart way to speed up convergence. <em>Not supported yet</em> - if chosen we will use SKLearn's methods. 'random': choose k observations (rows) at random from data for the initial centroids. If an ndarray is passed, it should be of shape (n_clusters, n_features) and gives the initial centers. <em>Not supported yet</em> - if chosen we will use SKLearn's methods.</p>
</td></tr>
<tr><td><code id="h2o4gpu.kmeans_+3A_n_init">n_init</code></td>
<td>
<p>Number of time the k-means algorithm will be run with different centroid seeds. The final results will be the best output of n_init consecutive runs in terms of inertia. <em>Not supported yet</em> - always runs 1.</p>
</td></tr>
<tr><td><code id="h2o4gpu.kmeans_+3A_max_iter">max_iter</code></td>
<td>
<p>Maximum number of iterations of the algorithm.</p>
</td></tr>
<tr><td><code id="h2o4gpu.kmeans_+3A_tol">tol</code></td>
<td>
<p>Relative tolerance to declare convergence.</p>
</td></tr>
<tr><td><code id="h2o4gpu.kmeans_+3A_precompute_distances">precompute_distances</code></td>
<td>
<p>Precompute distances (faster but takes more memory). 'auto' : do not precompute distances if n_samples * n_clusters &gt; 12 million. This corresponds to about 100MB overhead per job using double precision. TRUE : always precompute distances FALSE : never precompute distances <em>Not supported yet</em> - always uses auto if running h2o4gpu version.</p>
</td></tr>
<tr><td><code id="h2o4gpu.kmeans_+3A_verbose">verbose</code></td>
<td>
<p>Logger verbosity level.</p>
</td></tr>
<tr><td><code id="h2o4gpu.kmeans_+3A_random_state">random_state</code></td>
<td>
<p>random_state for RandomState. Must be convertible to 32 bit unsigned integers.</p>
</td></tr>
<tr><td><code id="h2o4gpu.kmeans_+3A_copy_x">copy_x</code></td>
<td>
<p>When pre-computing distances it is more numerically accurate to center the data first. If copy_x is TRUE, then the original data is not modified. If FALSE, the original data is modified, and put back before the function returns, but small numerical differences may be introduced by subtracting and then adding the data mean. <em>Not supported yet</em> - always uses TRUE if running h2o4gpu version.</p>
</td></tr>
<tr><td><code id="h2o4gpu.kmeans_+3A_n_jobs">n_jobs</code></td>
<td>
<p>The number of jobs to use for the computation. This works by computing each of the n_init runs in parallel. If -1 all CPUs are used. If 1 is given, no parallel computing code is used at all, which is useful for debugging. For n_jobs below -1, (n_cpus + 1 + n_jobs) are used. Thus for n_jobs = -2, all CPUs but one are used. <em>Not supported yet</em> - CPU backend not yet implemented.</p>
</td></tr>
<tr><td><code id="h2o4gpu.kmeans_+3A_algorithm">algorithm</code></td>
<td>
<p>K-means algorithm to use. The classical EM-style algorithm is &quot;full&quot;. The &quot;elkan&quot; variation is more efficient by using the triangle inequality, but currently doesn't support sparse data. &quot;auto&quot; chooses &quot;elkan&quot; for dense data and &quot;full&quot; for sparse data. <em>Not supported yet</em> - always uses full if running h2o4gpu version.</p>
</td></tr>
<tr><td><code id="h2o4gpu.kmeans_+3A_gpu_id">gpu_id</code></td>
<td>
<p>ID of the GPU on which the algorithm should run.</p>
</td></tr>
<tr><td><code id="h2o4gpu.kmeans_+3A_n_gpus">n_gpus</code></td>
<td>
<p>Number of GPUs on which the algorithm should run. &lt; 0 means all possible GPUs on the machine. 0 means no GPUs, run on CPU.</p>
</td></tr>
<tr><td><code id="h2o4gpu.kmeans_+3A_do_checks">do_checks</code></td>
<td>
<p>If set to 0 GPU error check will not be performed.</p>
</td></tr>
<tr><td><code id="h2o4gpu.kmeans_+3A_backend">backend</code></td>
<td>
<p>Which backend to use. Options are 'auto', 'sklearn', 'h2o4gpu'. Saves as attribute for actual backend used.</p>
</td></tr>
</table>

<hr>
<h2 id='h2o4gpu.pca'>Principal Component Analysis (PCA)</h2><span id='topic+h2o4gpu.pca'></span>

<h3>Description</h3>

<p>Principal Component Analysis (PCA)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h2o4gpu.pca(n_components = 2L, copy = TRUE, whiten = FALSE,
  svd_solver = "arpack", tol = 0, iterated_power = "auto",
  random_state = NULL, verbose = FALSE, backend = "h2o4gpu",
  gpu_id = 0L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="h2o4gpu.pca_+3A_n_components">n_components</code></td>
<td>
<p>Desired dimensionality of output data</p>
</td></tr>
<tr><td><code id="h2o4gpu.pca_+3A_copy">copy</code></td>
<td>
<p>If FALSE, data passed to fit are overwritten and running fit(X).transform(X) will not yield the expected results, use fit_transform(X) instead.</p>
</td></tr>
<tr><td><code id="h2o4gpu.pca_+3A_whiten">whiten</code></td>
<td>
<p>When TRUE (FALSE by default) the <code>components_</code> vectors are multiplied by the square root of (n_samples) and divided by the singular values to ensure uncorrelated outputs with unit component-wise variances.</p>
</td></tr>
<tr><td><code id="h2o4gpu.pca_+3A_svd_solver">svd_solver</code></td>
<td>
<p>'auto' is selected by a default policy based on <code>X.shape</code> and <code>n_components</code>: if the input data is larger than 500x500 and the number of components to extract is lower than 80 percent of the smallest dimension of the data, then the more efficient 'randomized' method is enabled. Otherwise the exact full SVD is computed and optionally truncated afterwards. 'full' runs exact full SVD calling the standard LAPACK solver via <code>scipy.linalg.svd</code> and select the components by postprocessing 'arpack'runs SVD truncated to n_components calling ARPACK solver via <code>scipy.sparse.linalg.svds</code>. It requires strictly 0 &lt; n_components &lt; columns. 'randomized' runs randomized SVD by the method of Halko et al.</p>
</td></tr>
<tr><td><code id="h2o4gpu.pca_+3A_tol">tol</code></td>
<td>
<p>Tolerance for singular values computed by svd_solver == 'arpack'.</p>
</td></tr>
<tr><td><code id="h2o4gpu.pca_+3A_iterated_power">iterated_power</code></td>
<td>
<p>Number of iterations for the power method computed by svd_solver == 'randomized'.</p>
</td></tr>
<tr><td><code id="h2o4gpu.pca_+3A_random_state">random_state</code></td>
<td>
<p>If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If NULL, the random number generator is the RandomState instance used by <code>np.random</code>. Used when <code>svd_solver</code> == 'arpack' or 'randomized'.</p>
</td></tr>
<tr><td><code id="h2o4gpu.pca_+3A_verbose">verbose</code></td>
<td>
<p>Verbose or not</p>
</td></tr>
<tr><td><code id="h2o4gpu.pca_+3A_backend">backend</code></td>
<td>
<p>Which backend to use. Options are 'auto', 'sklearn', 'h2o4gpu'. Saves as attribute for actual backend used.</p>
</td></tr>
<tr><td><code id="h2o4gpu.pca_+3A_gpu_id">gpu_id</code></td>
<td>
<p>ID of the GPU on which the algorithm should run. Only used by h2o4gpu backend.</p>
</td></tr>
</table>

<hr>
<h2 id='h2o4gpu.random_forest_classifier'>Random Forest Classifier</h2><span id='topic+h2o4gpu.random_forest_classifier'></span>

<h3>Description</h3>

<p>Random Forest Classifier
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h2o4gpu.random_forest_classifier(n_estimators = 100L, criterion = "gini",
  max_depth = 3L, min_samples_split = 2L, min_samples_leaf = 1L,
  min_weight_fraction_leaf = 0, max_features = "auto",
  max_leaf_nodes = NULL, min_impurity_decrease = 0,
  min_impurity_split = NULL, bootstrap = TRUE, oob_score = FALSE,
  n_jobs = 1L, random_state = NULL, verbose = 0L, warm_start = FALSE,
  class_weight = NULL, subsample = 1, colsample_bytree = 1,
  num_parallel_tree = 1L, tree_method = "gpu_hist", n_gpus = -1L,
  predictor = "gpu_predictor", backend = "h2o4gpu")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="h2o4gpu.random_forest_classifier_+3A_n_estimators">n_estimators</code></td>
<td>
<p>The number of trees in the forest.</p>
</td></tr>
<tr><td><code id="h2o4gpu.random_forest_classifier_+3A_criterion">criterion</code></td>
<td>
<p>The function to measure the quality of a split. Supported criteria are &quot;gini&quot; for the Gini impurity and &quot;entropy&quot; for the information gain. Note: this parameter is tree-specific.</p>
</td></tr>
<tr><td><code id="h2o4gpu.random_forest_classifier_+3A_max_depth">max_depth</code></td>
<td>
<p>The maximum depth of the tree. If NULL, then nodes are expanded until all leaves are pure or until all leaves contain less than min_samples_split samples.</p>
</td></tr>
<tr><td><code id="h2o4gpu.random_forest_classifier_+3A_min_samples_split">min_samples_split</code></td>
<td>
<p>The minimum number of samples required to split an internal node:</p>
</td></tr>
<tr><td><code id="h2o4gpu.random_forest_classifier_+3A_min_samples_leaf">min_samples_leaf</code></td>
<td>
<p>The minimum number of samples required to be at a leaf node:</p>
</td></tr>
<tr><td><code id="h2o4gpu.random_forest_classifier_+3A_min_weight_fraction_leaf">min_weight_fraction_leaf</code></td>
<td>
<p>The minimum weighted fraction of the sum total of weights (of all the input samples) required to be at a leaf node. Samples have equal weight when sample_weight is not provided.</p>
</td></tr>
<tr><td><code id="h2o4gpu.random_forest_classifier_+3A_max_features">max_features</code></td>
<td>
<p>The number of features to consider when looking for the best split:</p>
</td></tr>
<tr><td><code id="h2o4gpu.random_forest_classifier_+3A_max_leaf_nodes">max_leaf_nodes</code></td>
<td>
<p>Grow trees with <code>max_leaf_nodes</code> in best-first fashion. Best nodes are defined as relative reduction in impurity. If NULL then unlimited number of leaf nodes.</p>
</td></tr>
<tr><td><code id="h2o4gpu.random_forest_classifier_+3A_min_impurity_decrease">min_impurity_decrease</code></td>
<td>
<p>A node will be split if this split induces a decrease of the impurity greater than or equal to this value.</p>
</td></tr>
<tr><td><code id="h2o4gpu.random_forest_classifier_+3A_min_impurity_split">min_impurity_split</code></td>
<td>
<p>Threshold for early stopping in tree growth. A node will split if its impurity is above the threshold, otherwise it is a leaf.</p>
</td></tr>
<tr><td><code id="h2o4gpu.random_forest_classifier_+3A_bootstrap">bootstrap</code></td>
<td>
<p>Whether bootstrap samples are used when building trees.</p>
</td></tr>
<tr><td><code id="h2o4gpu.random_forest_classifier_+3A_oob_score">oob_score</code></td>
<td>
<p>whether to use out-of-bag samples to estimate the R^2 on unseen data.</p>
</td></tr>
<tr><td><code id="h2o4gpu.random_forest_classifier_+3A_n_jobs">n_jobs</code></td>
<td>
<p>The number of jobs to run in parallel for both <code>fit</code> and <code>predict</code>. If -1, then the number of jobs is set to the number of cores.</p>
</td></tr>
<tr><td><code id="h2o4gpu.random_forest_classifier_+3A_random_state">random_state</code></td>
<td>
<p>If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If NULL, the random number generator is the RandomState instance used by <code>np.random</code>.</p>
</td></tr>
<tr><td><code id="h2o4gpu.random_forest_classifier_+3A_verbose">verbose</code></td>
<td>
<p>Controls the verbosity of the tree building process.</p>
</td></tr>
<tr><td><code id="h2o4gpu.random_forest_classifier_+3A_warm_start">warm_start</code></td>
<td>
<p>When set to <code>TRUE</code>, reuse the solution of the previous call to fit and add more estimators to the ensemble, otherwise, just fit a whole new forest.</p>
</td></tr>
<tr><td><code id="h2o4gpu.random_forest_classifier_+3A_class_weight">class_weight</code></td>
<td>
<p>&quot;balanced_subsample&quot; or NULL, optional (default=NULL) Weights associated with classes in the form <code>{class_label: weight}</code>. If not given, all classes are supposed to have weight one. For multi-output problems, a list of dicts can be provided in the same order as the columns of y.</p>
</td></tr>
<tr><td><code id="h2o4gpu.random_forest_classifier_+3A_subsample">subsample</code></td>
<td>
<p>Subsample ratio of the training instance.</p>
</td></tr>
<tr><td><code id="h2o4gpu.random_forest_classifier_+3A_colsample_bytree">colsample_bytree</code></td>
<td>
<p>Subsample ratio of columns when constructing each tree.</p>
</td></tr>
<tr><td><code id="h2o4gpu.random_forest_classifier_+3A_num_parallel_tree">num_parallel_tree</code></td>
<td>
<p>Number of trees to grow per round</p>
</td></tr>
<tr><td><code id="h2o4gpu.random_forest_classifier_+3A_tree_method">tree_method</code></td>
<td>
<p>The tree construction algorithm used in XGBoost Distributed and external memory version only support approximate algorithm. Choices: ‘auto’, ‘exact’, ‘approx’, ‘hist’, ‘gpu_exact’, ‘gpu_hist’ ‘auto’: Use heuristic to choose faster one. - For small to medium dataset, exact greedy will be used. - For very large-dataset, approximate algorithm will be chosen. - Because old behavior is always use exact greedy in single machine, - user will get a message when approximate algorithm is chosen to notify this choice. ‘exact’: Exact greedy algorithm. ‘approx’: Approximate greedy algorithm using sketching and histogram. ‘hist’: Fast histogram optimized approximate greedy algorithm. It uses some performance improvements such as bins caching. ‘gpu_exact’: GPU implementation of exact algorithm. ‘gpu_hist’: GPU implementation of hist algorithm.</p>
</td></tr>
<tr><td><code id="h2o4gpu.random_forest_classifier_+3A_n_gpus">n_gpus</code></td>
<td>
<p>Number of gpu's to use in RandomForestClassifier solver. Default is -1.</p>
</td></tr>
<tr><td><code id="h2o4gpu.random_forest_classifier_+3A_predictor">predictor</code></td>
<td>
<p>The type of predictor algorithm to use. Provides the same results but allows the use of GPU or CPU. - 'cpu_predictor': Multicore CPU prediction algorithm. - 'gpu_predictor': Prediction using GPU. Default for 'gpu_exact' and 'gpu_hist' tree method.</p>
</td></tr>
<tr><td><code id="h2o4gpu.random_forest_classifier_+3A_backend">backend</code></td>
<td>
<p>Which backend to use. Options are 'auto', 'sklearn', 'h2o4gpu'. Saves as attribute for actual backend used.</p>
</td></tr>
</table>

<hr>
<h2 id='h2o4gpu.random_forest_regressor'>Random Forest Regressor</h2><span id='topic+h2o4gpu.random_forest_regressor'></span>

<h3>Description</h3>

<p>Random Forest Regressor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h2o4gpu.random_forest_regressor(n_estimators = 100L, criterion = "mse",
  max_depth = 3L, min_samples_split = 2L, min_samples_leaf = 1L,
  min_weight_fraction_leaf = 0, max_features = "auto",
  max_leaf_nodes = NULL, min_impurity_decrease = 0,
  min_impurity_split = NULL, bootstrap = TRUE, oob_score = FALSE,
  n_jobs = 1L, random_state = NULL, verbose = 0L, warm_start = FALSE,
  subsample = 1, colsample_bytree = 1, num_parallel_tree = 1L,
  tree_method = "gpu_hist", n_gpus = -1L, predictor = "gpu_predictor",
  backend = "h2o4gpu")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="h2o4gpu.random_forest_regressor_+3A_n_estimators">n_estimators</code></td>
<td>
<p>The number of trees in the forest.</p>
</td></tr>
<tr><td><code id="h2o4gpu.random_forest_regressor_+3A_criterion">criterion</code></td>
<td>
<p>The function to measure the quality of a split. Supported criteria are &quot;mse&quot; for the mean squared error, which is equal to variance reduction as feature selection criterion, and &quot;mae&quot; for the mean absolute error.</p>
</td></tr>
<tr><td><code id="h2o4gpu.random_forest_regressor_+3A_max_depth">max_depth</code></td>
<td>
<p>The maximum depth of the tree. If NULL, then nodes are expanded until all leaves are pure or until all leaves contain less than min_samples_split samples.</p>
</td></tr>
<tr><td><code id="h2o4gpu.random_forest_regressor_+3A_min_samples_split">min_samples_split</code></td>
<td>
<p>The minimum number of samples required to split an internal node:</p>
</td></tr>
<tr><td><code id="h2o4gpu.random_forest_regressor_+3A_min_samples_leaf">min_samples_leaf</code></td>
<td>
<p>The minimum number of samples required to be at a leaf node:</p>
</td></tr>
<tr><td><code id="h2o4gpu.random_forest_regressor_+3A_min_weight_fraction_leaf">min_weight_fraction_leaf</code></td>
<td>
<p>The minimum weighted fraction of the sum total of weights (of all the input samples) required to be at a leaf node. Samples have equal weight when sample_weight is not provided.</p>
</td></tr>
<tr><td><code id="h2o4gpu.random_forest_regressor_+3A_max_features">max_features</code></td>
<td>
<p>The number of features to consider when looking for the best split:</p>
</td></tr>
<tr><td><code id="h2o4gpu.random_forest_regressor_+3A_max_leaf_nodes">max_leaf_nodes</code></td>
<td>
<p>Grow trees with <code>max_leaf_nodes</code> in best-first fashion. Best nodes are defined as relative reduction in impurity. If NULL then unlimited number of leaf nodes.</p>
</td></tr>
<tr><td><code id="h2o4gpu.random_forest_regressor_+3A_min_impurity_decrease">min_impurity_decrease</code></td>
<td>
<p>A node will be split if this split induces a decrease of the impurity greater than or equal to this value.</p>
</td></tr>
<tr><td><code id="h2o4gpu.random_forest_regressor_+3A_min_impurity_split">min_impurity_split</code></td>
<td>
<p>Threshold for early stopping in tree growth. A node will split if its impurity is above the threshold, otherwise it is a leaf.</p>
</td></tr>
<tr><td><code id="h2o4gpu.random_forest_regressor_+3A_bootstrap">bootstrap</code></td>
<td>
<p>Whether bootstrap samples are used when building trees.</p>
</td></tr>
<tr><td><code id="h2o4gpu.random_forest_regressor_+3A_oob_score">oob_score</code></td>
<td>
<p>whether to use out-of-bag samples to estimate the R^2 on unseen data.</p>
</td></tr>
<tr><td><code id="h2o4gpu.random_forest_regressor_+3A_n_jobs">n_jobs</code></td>
<td>
<p>The number of jobs to run in parallel for both <code>fit</code> and <code>predict</code>. If -1, then the number of jobs is set to the number of cores.</p>
</td></tr>
<tr><td><code id="h2o4gpu.random_forest_regressor_+3A_random_state">random_state</code></td>
<td>
<p>If int, random_state is the seed used by the random number generator; If RandomState instance, random_state is the random number generator; If NULL, the random number generator is the RandomState instance used by <code>np.random</code>.</p>
</td></tr>
<tr><td><code id="h2o4gpu.random_forest_regressor_+3A_verbose">verbose</code></td>
<td>
<p>Controls the verbosity of the tree building process.</p>
</td></tr>
<tr><td><code id="h2o4gpu.random_forest_regressor_+3A_warm_start">warm_start</code></td>
<td>
<p>When set to <code>TRUE</code>, reuse the solution of the previous call to fit and add more estimators to the ensemble, otherwise, just fit a whole new forest.</p>
</td></tr>
<tr><td><code id="h2o4gpu.random_forest_regressor_+3A_subsample">subsample</code></td>
<td>
<p>Subsample ratio of the training instance.</p>
</td></tr>
<tr><td><code id="h2o4gpu.random_forest_regressor_+3A_colsample_bytree">colsample_bytree</code></td>
<td>
<p>Subsample ratio of columns when constructing each tree.</p>
</td></tr>
<tr><td><code id="h2o4gpu.random_forest_regressor_+3A_num_parallel_tree">num_parallel_tree</code></td>
<td>
<p>Number of trees to grow per round</p>
</td></tr>
<tr><td><code id="h2o4gpu.random_forest_regressor_+3A_tree_method">tree_method</code></td>
<td>
<p>The tree construction algorithm used in XGBoost Distributed and external memory version only support approximate algorithm. Choices: ‘auto’, ‘exact’, ‘approx’, ‘hist’, ‘gpu_exact’, ‘gpu_hist’ ‘auto’: Use heuristic to choose faster one. - For small to medium dataset, exact greedy will be used. - For very large-dataset, approximate algorithm will be chosen. - Because old behavior is always use exact greedy in single machine, - user will get a message when approximate algorithm is chosen to notify this choice. ‘exact’: Exact greedy algorithm. ‘approx’: Approximate greedy algorithm using sketching and histogram. ‘hist’: Fast histogram optimized approximate greedy algorithm. It uses some performance improvements such as bins caching. ‘gpu_exact’: GPU implementation of exact algorithm. ‘gpu_hist’: GPU implementation of hist algorithm.</p>
</td></tr>
<tr><td><code id="h2o4gpu.random_forest_regressor_+3A_n_gpus">n_gpus</code></td>
<td>
<p>Number of gpu's to use in RandomForestRegressor solver. Default is -1.</p>
</td></tr>
<tr><td><code id="h2o4gpu.random_forest_regressor_+3A_predictor">predictor</code></td>
<td>
<p>The type of predictor algorithm to use. Provides the same results but allows the use of GPU or CPU. - 'cpu_predictor': Multicore CPU prediction algorithm. - 'gpu_predictor': Prediction using GPU. Default for 'gpu_exact' and 'gpu_hist' tree method.</p>
</td></tr>
<tr><td><code id="h2o4gpu.random_forest_regressor_+3A_backend">backend</code></td>
<td>
<p>Which backend to use. Options are 'auto', 'sklearn', 'h2o4gpu'. Saves as attribute for actual backend used.</p>
</td></tr>
</table>

<hr>
<h2 id='h2o4gpu.truncated_svd'>Truncated Singular Value Decomposition (TruncatedSVD)</h2><span id='topic+h2o4gpu.truncated_svd'></span>

<h3>Description</h3>

<p>Truncated Singular Value Decomposition (TruncatedSVD)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h2o4gpu.truncated_svd(n_components = 2L, algorithm = "power",
  n_iter = 100L, random_state = NULL, tol = 1e-05, verbose = FALSE,
  backend = "h2o4gpu", n_gpus = 1L, gpu_id = 0L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="h2o4gpu.truncated_svd_+3A_n_components">n_components</code></td>
<td>
<p>Desired dimensionality of output data</p>
</td></tr>
<tr><td><code id="h2o4gpu.truncated_svd_+3A_algorithm">algorithm</code></td>
<td>
<p>SVD solver to use. H2O4GPU options: Either &quot;cusolver&quot; (similar to ARPACK) or &quot;power&quot; for the power method. SKlearn options: Either &quot;arpack&quot; for the ARPACK wrapper in SciPy (scipy.sparse.linalg.svds), or &quot;randomized&quot; for the randomized algorithm due to Halko (2009).</p>
</td></tr>
<tr><td><code id="h2o4gpu.truncated_svd_+3A_n_iter">n_iter</code></td>
<td>
<p>number of iterations (only relevant for power method) Should be at most 2147483647 due to INT_MAX in C++ backend.</p>
</td></tr>
<tr><td><code id="h2o4gpu.truncated_svd_+3A_random_state">random_state</code></td>
<td>
<p>seed (NULL for auto-generated)</p>
</td></tr>
<tr><td><code id="h2o4gpu.truncated_svd_+3A_tol">tol</code></td>
<td>
<p>Tolerance for &quot;power&quot; method. Ignored by &quot;cusolver&quot;. Should be &gt; 0.0 to ensure convergence. Should be 0.0 to effectively ignore and only base convergence upon n_iter</p>
</td></tr>
<tr><td><code id="h2o4gpu.truncated_svd_+3A_verbose">verbose</code></td>
<td>
<p>Verbose or not</p>
</td></tr>
<tr><td><code id="h2o4gpu.truncated_svd_+3A_backend">backend</code></td>
<td>
<p>Which backend to use. Options are 'auto', 'sklearn', 'h2o4gpu'. Saves as attribute for actual backend used.</p>
</td></tr>
<tr><td><code id="h2o4gpu.truncated_svd_+3A_n_gpus">n_gpus</code></td>
<td>
<p>How many gpus to use. If 0, use CPU backup method. Currently SVD only uses 1 GPU, so &gt;1 has no effect compared to 1.</p>
</td></tr>
<tr><td><code id="h2o4gpu.truncated_svd_+3A_gpu_id">gpu_id</code></td>
<td>
<p>ID of the GPU on which the algorithm should run.</p>
</td></tr>
</table>

<hr>
<h2 id='predict.h2o4gpu_model'>Make Predictions using Trained H2O4GPU Estimator</h2><span id='topic+predict.h2o4gpu_model'></span>

<h3>Description</h3>

<p>This function makes predictions from new data using a trained H2O4GPU model and returns class predictions
for classification and predicted values for regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'h2o4gpu_model'
predict(object, x, type = "raw", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.h2o4gpu_model_+3A_object">object</code></td>
<td>
<p>The h2o4gpu model object</p>
</td></tr>
<tr><td><code id="predict.h2o4gpu_model_+3A_x">x</code></td>
<td>
<p>The new data where each column represents a different predictor variable to
be used in generating predictions.</p>
</td></tr>
<tr><td><code id="predict.h2o4gpu_model_+3A_type">type</code></td>
<td>
<p>One of &quot;raw&quot; or &quot;prob&quot;, indicating the type of output: predicted values or probabilities</p>
</td></tr>
<tr><td><code id="predict.h2o4gpu_model_+3A_...">...</code></td>
<td>
<p>Additional arguments (unused for now).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

library(h2o4gpu)

# Setup dataset
x &lt;- iris[1:4]
y &lt;- as.integer(iris$Species) - 1

# Initialize and train the classifier
model &lt;- h2o4gpu.random_forest_classifier() %&gt;% fit(x, y)

# Make predictions
predictions &lt;- model %&gt;% predict(x)


## End(Not run)

</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+predict'></span><span id='topic++25+3E+25'></span><span id='topic+use_condaenv'></span><span id='topic+use_python'></span><span id='topic+use_virtualenv'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>magrittr</dt><dd><p><code><a href="magrittr.html#topic++25+3E+25">%&gt;%</a></code></p>
</dd>
<dt>reticulate</dt><dd><p><code><a href="reticulate.html#topic+use_condaenv">use_condaenv</a></code>, <code><a href="reticulate.html#topic+use_python">use_python</a></code>, <code><a href="reticulate.html#topic+use_virtualenv">use_virtualenv</a></code></p>
</dd>
<dt>stats</dt><dd><p><code><a href="stats.html#topic+predict">predict</a></code></p>
</dd>
</dl>

<hr>
<h2 id='transform.h2o4gpu_model'>Transform a Dataset using Trained H2O4GPU Estimator</h2><span id='topic+transform.h2o4gpu_model'></span>

<h3>Description</h3>

<p>This function transforms the given new data using a trained H2O4GPU model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'h2o4gpu_model'
transform(object, x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transform.h2o4gpu_model_+3A_object">object</code></td>
<td>
<p>The h2o4gpu model object</p>
</td></tr>
<tr><td><code id="transform.h2o4gpu_model_+3A_x">x</code></td>
<td>
<p>The new data where each column represents a different predictor variable to
be used in generating predictions.</p>
</td></tr>
<tr><td><code id="transform.h2o4gpu_model_+3A_...">...</code></td>
<td>
<p>Additional arguments (unused for now).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

library(h2o4gpu)

# Prepare data
iris$Species &lt;- as.integer(iris$Species) # convert to numeric data

# Randomly sample 80% of the rows for the training set
set.seed(1)
train_idx &lt;- sample(1:nrow(iris), 0.8*nrow(iris)) 
train &lt;- iris[train_idx, ]
test &lt;- iris[-train_idx, ]

# Train a K-Means model
model_km &lt;- h2o4gpu.kmeans(n_clusters = 3L) %&gt;% fit(train)

# Transform test data
test_dist &lt;- model_km %&gt;% transform(test)


## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
