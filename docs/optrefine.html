<!DOCTYPE html><html><head><title>Help for package optrefine</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {optrefine}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#best_split'><p>Find the best split for a stratum</p></a></li>
<li><a href='#calc_smds'><p>Calculate standardized mean differences for initial and refined strata</p></a></li>
<li><a href='#new_strat'><p>Constructor for object of class &quot;strat&quot;</p></a></li>
<li><a href='#plot.strat'><p>Plot diagnostics for a &quot;strat&quot; object</p></a></li>
<li><a href='#print.strat'><p>Print stratification object</p></a></li>
<li><a href='#prop_strat'><p>Form propensity score strata</p></a></li>
<li><a href='#rand_pvals'><p>Generate P-values using empirical randomization null distribution</p></a></li>
<li><a href='#refine'><p>Refine initial stratification</p></a></li>
<li><a href='#rhc_X'><p>Right Heart Catheterization Data</p></a></li>
<li><a href='#split_stratum'><p>Split one stratum into multiple strata</p></a></li>
<li><a href='#strat'><p>Helper for object of class &quot;strat&quot;</p></a></li>
<li><a href='#table_rand_pvals'><p>Generate a covariate balance table from the empirical randomization null distribution</p></a></li>
<li><a href='#validate_strat'><p>Validator for object of class &quot;strat&quot;</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Optimally Refine Strata</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Splits initial strata into refined strata that optimize covariate balance. For more information, please email the author for a copy of the accompanying manuscript. To solve the linear program, the 'Gurobi' commercial optimization software is recommended, but not required. The 'gurobi' R package can be installed following the instructions at <a href="https://www.gurobi.com/documentation/9.1/refman/ins_the_r_package.html">https://www.gurobi.com/documentation/9.1/refman/ins_the_r_package.html</a>.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/kkbrum/optrefine">https://github.com/kkbrum/optrefine</a>,
<a href="https://kkbrum.github.io/optrefine/">https://kkbrum.github.io/optrefine/</a>,
<a href="https://www.gurobi.com/documentation/9.1/refman/ins_the_r_package.html">https://www.gurobi.com/documentation/9.1/refman/ins_the_r_package.html</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/kkbrum/optrefine/issues">https://github.com/kkbrum/optrefine/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), MASS, Rglpk, sampling, ggplot2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, gurobi, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-18 16:12:11 UTC; katherine</td>
</tr>
<tr>
<td>Author:</td>
<td>Katherine Brumberg
    <a href="https://orcid.org/0000-0002-5193-6250"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Katherine Brumberg &lt;kbrum@wharton.upenn.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-18 19:20:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='best_split'>Find the best split for a stratum</h2><span id='topic+best_split'></span>

<h3>Description</h3>

<p>Runs <code><a href="#topic+split_stratum">split_stratum</a>()</code> many times and selects the best result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>best_split(
  z,
  X,
  strata,
  ist,
  nc_list,
  nt_list,
  wMax = 5,
  wEach = 1,
  solver = "Rglpk",
  integer = FALSE,
  min_split = 10,
  threads = threads
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="best_split_+3A_z">z</code></td>
<td>
<p>Vector of treatment assignment</p>
</td></tr>
<tr><td><code id="best_split_+3A_x">X</code></td>
<td>
<p>Covariate matrix or data.frame</p>
</td></tr>
<tr><td><code id="best_split_+3A_strata">strata</code></td>
<td>
<p>vector of initial strata assignments; only used if <code>object</code> is not supplied.
Can be <code>NULL</code>, in which case an initial stratification using the quintiles of the
propensity score is generated using <code><a href="#topic+prop_strat">prop_strat</a>()</code> and the generated
propensity score is also added to the X matrix as an extra covariate</p>
</td></tr>
<tr><td><code id="best_split_+3A_ist">ist</code></td>
<td>
<p>the stratum to be split</p>
</td></tr>
<tr><td><code id="best_split_+3A_nc_list">nc_list</code></td>
<td>
<p>a list of choices for the <code>nc</code> parameter in <code><a href="#topic+split_stratum">split_stratum</a>()</code>.
Each element is a vector with entries corresponding to the number of control
units that should be placed in each new stratum</p>
</td></tr>
<tr><td><code id="best_split_+3A_nt_list">nt_list</code></td>
<td>
<p>a list of choices for the <code>nt</code> parameter in <code><a href="#topic+split_stratum">split_stratum</a>()</code>.
Each element is a vector with entries corresponding to the number of treated
units that should be placed in each new stratum</p>
</td></tr>
<tr><td><code id="best_split_+3A_wmax">wMax</code></td>
<td>
<p>the weight the objective places on the maximum epsilon</p>
</td></tr>
<tr><td><code id="best_split_+3A_weach">wEach</code></td>
<td>
<p>the weight the objective places on each epsilon</p>
</td></tr>
<tr><td><code id="best_split_+3A_solver">solver</code></td>
<td>
<p>character specifying the optimization software to use.
Options are &quot;Rglpk&quot; or &quot;gurobi&quot;. The default is &quot;gurobi&quot;</p>
</td></tr>
<tr><td><code id="best_split_+3A_integer">integer</code></td>
<td>
<p>boolean whether to use integer programming instead of randomized rounding.
Default is <code>FALSE</code>. It is not recommended to set this to <code>TRUE</code> as the problem may never finish</p>
</td></tr>
<tr><td><code id="best_split_+3A_min_split">min_split</code></td>
<td>
<p>a numeric specifying the minimum number of each control and treated units
to be tolerated in a stratum. Any combination of elements
from <code>nc_list</code> and <code>nt_list</code> that violate this are skipped</p>
</td></tr>
<tr><td><code id="best_split_+3A_threads">threads</code></td>
<td>
<p>how many threads to use in the optimization if using &quot;gurobi&quot; as the solver. Default will use all available threads</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements:
</p>

<ul>
<li><p>valuesIP, valuesLP: matrices containing integer and linear programming
scaled objective values for each sample size tried, with rows corresponding to the
elements of <code>nc_list</code> and columns corresponding to the elements of <code>nt_list</code>
</p>
</li>
<li><p>besti, bestj: indices of the best sample sizes in <code>nc_list</code> and in <code>nt_list</code>, respectively
</p>
</li>
<li><p>n_smds: number of standardized mean differences contributing to the objective values
(multiply the scaled objective values by this number to get the true objective values)
</p>
</li>
<li><p>n_fracs: number of units with fractional LP solutions in the best split
</p>
</li>
<li><p>rand_c_prop, rand_t_prop: proportions of the control and treated units in each
stratum that were selected with randomness for the best split
</p>
</li>
<li><p>pr: linear programming solution for the best split,
with rows corresponding to the strata and columns to the units
</p>
</li>
<li><p>selection: vector of selected strata for each unit
in the initial stratum to be split for the best split
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# Generate a small data set
set.seed(25)
samp &lt;- sample(1:nrow(rhc_X), 1000)
cov_samp &lt;- sample(1:26, 10)

# Create some strata
ps &lt;- prop_strat(z = rhc_X[samp, "z"],
                 X = rhc_X[samp, cov_samp], nstrata = 5)

# Save the sample sizes
tab &lt;- table(ps$z, ps$base_strata)

# Choose the best sample sizes among the options provided
best_split(z = ps$z, X = ps$X, strata = ps$base_strata, ist = 1,
           nc_list = list(c(floor(tab[1, 1] * 0.25), ceiling(tab[1, 1] * 0.75)),
                          c(floor(tab[1, 1] * 0.4), ceiling(tab[1, 1] * 0.6))),
           nt_list = list(c(floor(tab[2, 1] * 0.3), ceiling(tab[2, 1] * 0.7))),
           min_split = 5)
</code></pre>

<hr>
<h2 id='calc_smds'>Calculate standardized mean differences for initial and refined strata</h2><span id='topic+calc_smds'></span>

<h3>Description</h3>

<p>Summarizes initial and/or refined strata in terms of standardized mean differences (SMDs).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_smds(
  object = NULL,
  z = NULL,
  X = NULL,
  base_strata = NULL,
  refined_strata = NULL,
  abs = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_smds_+3A_object">object</code></td>
<td>
<p>an optional object of class <code>strat</code>,
typically created using <code><a href="#topic+strat">strat</a>()</code>
or as a result of a call to <code><a href="#topic+prop_strat">prop_strat</a>()</code>.
If not provided, <code>z</code> and <code>X</code> must be specified</p>
</td></tr>
<tr><td><code id="calc_smds_+3A_z">z</code></td>
<td>
<p>vector of treatment assignment; only used if <code>object</code> is not supplied</p>
</td></tr>
<tr><td><code id="calc_smds_+3A_x">X</code></td>
<td>
<p>covariate matrix/data.frame; only used if <code>object</code> is not supplied</p>
</td></tr>
<tr><td><code id="calc_smds_+3A_base_strata">base_strata</code></td>
<td>
<p>optional initial stratification for which to calculate SMDs;
only used if <code>object</code> is not supplied</p>
</td></tr>
<tr><td><code id="calc_smds_+3A_refined_strata">refined_strata</code></td>
<td>
<p>optional refined stratification for which to calculate SMDs;
only used if <code>object</code> is not supplied</p>
</td></tr>
<tr><td><code id="calc_smds_+3A_abs">abs</code></td>
<td>
<p>boolean whether to return absolute standardized mean differences or raw values.
Default is TRUE for absolute values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with two elements, &quot;base&quot; and &quot;refined&quot;, each containing
a matrix of standardized mean differences for each stratum (row) and covariate (column).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Choose 500 patients and 5 covariates to work with for the example
set.seed(15)
samp &lt;- sample(1:nrow(rhc_X), 500)
cov_samp &lt;- sample(1:26, 5)

# Let it create propensity score strata for you and then refine them
ref &lt;- refine(X = rhc_X[samp, cov_samp], z = rhc_X[samp, "z"])

# Look at covariate balance for propensity score and refined strata
calc_smds(object = ref)

</code></pre>

<hr>
<h2 id='new_strat'>Constructor for object of class &quot;strat&quot;</h2><span id='topic+new_strat'></span>

<h3>Description</h3>

<p>Creates an object of S3 class &quot;strat&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_strat(z, X, base_strata = NULL, refined_strata = NULL, details = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_strat_+3A_z">z</code></td>
<td>
<p>Vector of treatment assignment</p>
</td></tr>
<tr><td><code id="new_strat_+3A_x">X</code></td>
<td>
<p>Covariate matrix or data.frame</p>
</td></tr>
<tr><td><code id="new_strat_+3A_base_strata">base_strata</code></td>
<td>
<p>Original strata, if they exist</p>
</td></tr>
<tr><td><code id="new_strat_+3A_refined_strata">refined_strata</code></td>
<td>
<p>Refined strata, if they exist</p>
</td></tr>
<tr><td><code id="new_strat_+3A_details">details</code></td>
<td>
<p>A list of details from the linear program.
Also includes <code>X_std</code> if calculated</p>
</td></tr>
</table>

<hr>
<h2 id='plot.strat'>Plot diagnostics for a &quot;strat&quot; object</h2><span id='topic+plot.strat'></span>

<h3>Description</h3>

<p>Plots the standardized mean differences for <code>strat</code> objects in the format of Love (2002).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'strat'
plot(
  x,
  incl_none = TRUE,
  incl_base = TRUE,
  by_strata = FALSE,
  weighted_avg = FALSE,
  legend = c("No strata", "Base strata", "Refined strata"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.strat_+3A_x">x</code></td>
<td>
<p>object of S3 class 'strat'</p>
</td></tr>
<tr><td><code id="plot.strat_+3A_incl_none">incl_none</code></td>
<td>
<p>whether to plot imbalances before any stratification</p>
</td></tr>
<tr><td><code id="plot.strat_+3A_incl_base">incl_base</code></td>
<td>
<p>whether to plot imbalances for the base stratification (if one exists)</p>
</td></tr>
<tr><td><code id="plot.strat_+3A_by_strata">by_strata</code></td>
<td>
<p>whether to generate a list of plots, one for each base stratum if
<code>incl_base</code> is <code>TRUE</code>, or one for each refined stratum if <code>incl_base</code> is <code>FALSE</code>.
Not used if <code>incl_none</code> is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="plot.strat_+3A_weighted_avg">weighted_avg</code></td>
<td>
<p>whether to take the weighted average instead of the straight average
when collapsing standardized mean differences across strata. Default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="plot.strat_+3A_legend">legend</code></td>
<td>
<p>a vector of labels to use for the three stratifications on the plot.
The corresponding label for any stratification that is not to be plotted must
still be provided but will be ignored and
can be set to <code>NA</code></p>
</td></tr>
<tr><td><code id="plot.strat_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a ggplot object for the Love plot of standardized mean differences or
a list of such ggplot objects if <code>by_strata</code> is <code>TRUE</code>
</p>


<h3>References</h3>

<p>Love, T. E. (2002), &quot;Displaying covariate balance after adjustment for selection bias&quot;,
Joint Statistical Meetings, yumpu.com/en/document/read/41664623.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Choose 800 patients and 5 covariates to work with for the example
set.seed(28)
samp &lt;- sample(1:nrow(rhc_X), 800)
cov_samp &lt;- sample(1:26, 5)
ref &lt;- refine(X = rhc_X[samp, cov_samp], z = rhc_X[samp, "z"])
plot(ref)

</code></pre>

<hr>
<h2 id='print.strat'>Print stratification object</h2><span id='topic+print.strat'></span>

<h3>Description</h3>

<p>Print method for class &quot;strat&quot;.
Prints tables of numbers of control and treated units without strata and in initial and/or improved strata.
Also displays average and maximum standardized mean difference for each stratification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'strat'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.strat_+3A_x">x</code></td>
<td>
<p>object of S3 class 'strat'</p>
</td></tr>
<tr><td><code id="print.strat_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>x</code> back invisibly and prints tables and statistics to the console
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Choose 750 patients and 5 covariates to work with for the example
set.seed(21)
samp &lt;- sample(1:nrow(rhc_X), 750)
cov_samp &lt;- sample(1:26, 5)
ref &lt;- refine(X = rhc_X[samp, cov_samp], z = rhc_X[samp, "z"])
print(ref)
</code></pre>

<hr>
<h2 id='prop_strat'>Form propensity score strata</h2><span id='topic+prop_strat'></span>

<h3>Description</h3>

<p>Form initial propensity score strata
to be improved upon by <code><a href="#topic+refine">refine</a>()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prop_strat(z, X, nstrata = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prop_strat_+3A_z">z</code></td>
<td>
<p>Vector of treatment assignment</p>
</td></tr>
<tr><td><code id="prop_strat_+3A_x">X</code></td>
<td>
<p>Covariate matrix or data.frame</p>
</td></tr>
<tr><td><code id="prop_strat_+3A_nstrata">nstrata</code></td>
<td>
<p>The number of strata to form</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class &quot;strat&quot;, which is a list containing <code>z</code>,
<code>X</code> with the propensity score as an additional column, <code>base_strata</code>
(a factor of the resulting propensity score strata), and <code>details</code>,
(a list containing <code>X_std</code>, which is the standardized version of the new <code>X</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ps &lt;- prop_strat(z = rhc_X[, "z"],
                  X = rhc_X[,  !(colnames(rhc_X) %in% c("pr", "z"))])
table(rhc_X[, "z"], ps$base_strata)
</code></pre>

<hr>
<h2 id='rand_pvals'>Generate P-values using empirical randomization null distribution</h2><span id='topic+rand_pvals'></span>

<h3>Description</h3>

<p>Randomize the treatment assignment within strata to generate the randomization distribution of covariate balance
given the strata and observed covariate values. Compare the observed covariate balance to this null distribution
to calculate P-values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rand_pvals(
  object = NULL,
  z = NULL,
  X = NULL,
  base_strata = NULL,
  refined_strata = NULL,
  options = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rand_pvals_+3A_object">object</code></td>
<td>
<p>an optional object of class <code>strat</code>,
typically created using <code><a href="#topic+strat">strat</a>()</code>
or as a result of a call to <code><a href="#topic+prop_strat">prop_strat</a>()</code> or <code><a href="#topic+refine">refine</a>()</code>.
If not provided, <code>z</code> and <code>X</code> must be specified</p>
</td></tr>
<tr><td><code id="rand_pvals_+3A_z">z</code></td>
<td>
<p>vector of treatment assignment; only used if <code>object</code> is not supplied</p>
</td></tr>
<tr><td><code id="rand_pvals_+3A_x">X</code></td>
<td>
<p>covariate matrix/data.frame; only used if <code>object</code> is not supplied</p>
</td></tr>
<tr><td><code id="rand_pvals_+3A_base_strata">base_strata</code></td>
<td>
<p>optional initial stratification for which to calculate
the empirical randomization null distribution;
only used if <code>object</code> is not supplied</p>
</td></tr>
<tr><td><code id="rand_pvals_+3A_refined_strata">refined_strata</code></td>
<td>
<p>optional refined stratification for which to calculate
the empirical randomization null distribution;
only used if <code>object</code> is not supplied</p>
</td></tr>
<tr><td><code id="rand_pvals_+3A_options">options</code></td>
<td>
<p>list of additional options, listed in the <code>details</code> below</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The literature on multivariate matching has recently developed a new way of evaluating covariate imbalances,
comparing the imbalances found in an observational matched sample to
the imbalances that would have been produced in the same data by randomization
(Pimentel et al. 2015, Yu 2021).
We modify that approach for use with strata, randomizing patients within strata.
For a given stratification, we create a large number of stratified randomized experiments,
taking the actual patients in their actual strata, and randomizing them to
treatment or control with fixed within-stratum sample sizes.
</p>
<p>To investigate how the actual observational imbalance in covariates compares to
covariate imbalance in the randomized experiments built from the same strata, patients and covariates,
we look at 4 metrics&ndash; the scaled objective value, which is a weighted combination
of the maximum and the sum of all SMDs, depending on the <code>criterion</code> argument,
the maximum and average SMDs across covariates and strata,
and the average SMD across strata for each covariate individually.
For each of these metrics, we record the observational value,
the median and minimum of the randomized values,
and the proportion of randomized values more imbalanced than the observational value (the P-value).
</p>
<p>The <code>options</code> list argument can contain any of the following elements:
</p>

<ul>
<li><p>nrand: how many times to randomize the treatment assignment when forming the null distribution.
Default is 10000
</p>
</li>
<li><p>criterion: which optimization criterion to use when calculating the objective value.
Options are &quot;max&quot;, &quot;sum&quot;, or &quot;combo&quot;, referring to whether to include the
maximum standardized mean difference (SMD), the sum of all SMDs,
or a combination of the maximum and the sum. The default is &quot;combo&quot;
</p>
</li>
<li><p>wMax: how much to weight the maximum standardized mean difference compared to the sum.
Only used if criterion is set to &quot;combo&quot;. Default is 5
</p>
</li>
<li><p>incl_base: whether to include columns for the initial stratification in the table.
Default is <code>TRUE</code> if a base stratification is provided
</p>
</li></ul>



<h3>Value</h3>

<p>List with three components:
</p>

<ul>
<li><p>pvals: list containing <code>base</code> and <code>refined</code> elements, each of which is a list with randomization P-values
for the objective value (<code>NULL</code> for the base stratification),
the maximum standardized mean difference (SMD),
the average SMD across covariates and strata,
and for the average SMD across strata for each covariate (this element is a vector)
</p>
</li>
<li><p>obs_details: list containing <code>base</code> and <code>refined</code> elements, each of which is a list with
the observed values for
the objective value (<code>NULL</code> for the base stratification),
the maximum standardized mean difference (SMD),
and for the average SMD across strata for each covariate (this element is a vector)
</p>
</li>
<li><p>rand_details: list containing <code>base</code> and <code>refined</code> elements, each of which is a list with
a vector of <code>nrand</code> randomized values for
the objective value (<code>NULL</code> for the base stratification),
the maximum standardized mean difference (SMD),
and for the average SMD across strata for each covariate
(this element is a matrix with <code>nrand</code> rows and a column for each covariate)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Choose 500 patients and 5 covariates to work with for the example
set.seed(15)
samp &lt;- sample(1:nrow(rhc_X), 500)
cov_samp &lt;- sample(1:26, 5)

# Let it create propensity score strata for you and then refine them
ref &lt;- refine(X = rhc_X[samp, cov_samp], z = rhc_X[samp, "z"])

# Calculate info for covariate balance randomization distribution
rpvals &lt;- rand_pvals(object = ref, options = list(nrand = 100))

# Look at pvals before and after
rpvals$pvals
</code></pre>

<hr>
<h2 id='refine'>Refine initial stratification</h2><span id='topic+refine'></span>

<h3>Description</h3>

<p>Refine an initial stratification by splitting each stratum or specified subset of strata
into two refined strata. If no initial
stratification is provided, one is first generated
using <code><a href="#topic+prop_strat">prop_strat</a>()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>refine(object = NULL, z = NULL, X = NULL, strata = NULL, options = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="refine_+3A_object">object</code></td>
<td>
<p>an optional object of class <code>strat</code>,
typically created using <code><a href="#topic+strat">strat</a>()</code>
or as a result of a call to <code><a href="#topic+prop_strat">prop_strat</a>()</code>.
If not provided, <code>z</code> and <code>X</code> must be specified</p>
</td></tr>
<tr><td><code id="refine_+3A_z">z</code></td>
<td>
<p>vector of treatment assignment; only used if <code>object</code> is not supplied</p>
</td></tr>
<tr><td><code id="refine_+3A_x">X</code></td>
<td>
<p>covariate matrix/data.frame; only used if <code>object</code> is not supplied</p>
</td></tr>
<tr><td><code id="refine_+3A_strata">strata</code></td>
<td>
<p>vector of initial strata assignments; only used if <code>object</code> is not supplied.
Can be <code>NULL</code>, in which case an initial stratification using the quintiles of the
propensity score is generated using <code><a href="#topic+prop_strat">prop_strat</a>()</code> and the generated
propensity score is also added to the X matrix as an extra covariate</p>
</td></tr>
<tr><td><code id="refine_+3A_options">options</code></td>
<td>
<p>list containing various options described in the <code>Details</code> below</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>options</code> argument can contain any of the following elements:
</p>

<ul>
<li><p>solver: character specifying the optimization software to use.
Options are &quot;Rglpk&quot; or &quot;gurobi&quot;. The default is &quot;Rglpk&quot; unless a gurobi installation is detected,
in which case it is set to &quot;gurobi&quot;. It is recommended to use &quot;gurobi&quot; if available.
</p>
</li>
<li><p>standardize: boolean whether or not to standardize the covariates in X. Default is <code>TRUE</code>
</p>
</li>
<li><p>criterion: which optimization criterion to use.
Options are &quot;max&quot;, &quot;sum&quot;, or &quot;combo&quot;, referring to whether to optimize the
maximum standardized mean difference (SMD), the sum of all SMDs,
or a combination of the maximum and the sum. The default is &quot;combo&quot;
</p>
</li>
<li><p>integer: boolean whether to use integer programming as opposed to
randomized rounding of linear programs. Note that setting this to <code>TRUE</code>
may cause this function to never finish depending on the size of the data
and is not recommended except for tiny data sets
</p>
</li>
<li><p>wMax: how much to weight the maximum standardized mean difference compared to the sum.
Only used if criterion is set to &quot;combo&quot;. Default is 5
</p>
</li>
<li><p>ist: which strata to split. Should be a level from the specified <code>strata</code> or
a vector of multiple levels. Default is to split all strata
</p>
</li>
<li><p>minsplit: The minimum number of treated and control units to allow in a refined stratum.
Default is 10
</p>
</li>
<li><p>threads: How many threads you'd like the optimization to use if using the &quot;gurobi&quot; solver. Uses all available threads by default
</p>
</li></ul>

<p>Note that setting a seed before using this function will ensure that the results are reproducible
on the same machine, but results may vary across machines due to how the optimization solvers work.
</p>


<h3>Value</h3>

<p>Object of class &quot;strat&quot;, which is a list object with the following components:
</p>

<ul>
<li><p>z: treatment vector
</p>
</li>
<li><p>X: covariate matrix
</p>
</li>
<li><p>base_strata: initial stratification
</p>
</li>
<li><p>refined_strata: refined_stratification
</p>
</li>
<li><p>details: various details about the optimization that can be ignored in practice, but may be interesting:
</p>

<ul>
<li><p>valueIP, valueLP: integer (determined via randomized rounding, unless <code>integer</code> option set to true)
and linear programming scaled objective values
</p>
</li>
<li><p>n_fracs: number of units with fractional LP solutions
</p>
</li>
<li><p>rand_c_prop, rand_t_prop: proportions of the control and treated units in each
stratum that were selected with randomness
</p>
</li>
<li><p>pr: linear programming solution,
with rows corresponding to the strata and columns to the units
</p>
</li>
<li><p>criterion: criterion used in the optimization (see the <code>details</code> about the <code>options</code> for the optimization)
</p>
</li>
<li><p>wMax: weight placed on the maximum standardized mean difference in the optimization
(see the <code>details</code> about the <code>options</code> for the optimization)
</p>
</li>
<li><p>X_std: standardized version of <code>X</code>
</p>
</li></ul>


</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Choose 400 patients and 4 covariates to work with for the example
set.seed(15)
samp &lt;- sample(1:nrow(rhc_X), 400)
cov_samp &lt;- sample(1:26, 4)

# Let it create propensity score strata for you and then refine them
ref &lt;- refine(X = rhc_X[samp, cov_samp], z = rhc_X[samp, "z"])

# Or, specify your own initial strata
ps &lt;- prop_strat(z = rhc_X[samp, "z"],
                 X = rhc_X[samp, cov_samp], nstrata = 3)
ref &lt;- refine(X = ps$X, z = ps$z, strata = ps$base_strata)

# Can just input the output of prop_strat() directly
ref &lt;- refine(object = ps)

</code></pre>

<hr>
<h2 id='rhc_X'>Right Heart Catheterization Data</h2><span id='topic+rhc_X'></span>

<h3>Description</h3>

<p>The data in the example are from Frank Harrell's <code>Hmisc</code> package.
The data there are very similar to the
data in Connors et al. (1996), but do not exactly reproduce analyses from
that article. So, we employ the version of that analysis in the
documentation for Ruoqi Yu's <code>RBestMatch</code> package,
which attempts to be close to the analysis in Connors et al.
In Yu's version, the propensity score (her
<code>pr</code>) is built using 76 covariates, and the focus of attention is on
26 &quot;priority&quot; covariates (her <code>X</code>) and the propensity score
that were emphasized in the Connors et al. article, including those in that
article's Table 3.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rhc_X
</code></pre>


<h3>Format</h3>

<p>Matrix with 5,735 rows and 28 columns:
</p>

<dl>
<dt>aps1</dt><dd><p>APACHE score</p>
</dd>
<dt>surv2md1</dt><dd><p>Support model estimate of the prob. of surviving 2 months</p>
</dd>
<dt>age</dt><dd><p>Age</p>
</dd>
<dt>NumComorbid</dt><dd><p>Number of comorbidities</p>
</dd>
<dt>adld3p_impute</dt><dd><p>ADL with missing data imputed</p>
</dd>
<dt>adld3p_na</dt><dd><p>ADL missing</p>
</dd>
<dt>das2d3pc</dt><dd><p>DASI (Duke Activity Status Index)</p>
</dd>
<dt>temp1</dt><dd><p>Temperature</p>
</dd>
<dt>hrt1</dt><dd><p>Heart rate</p>
</dd>
<dt>meanbp1</dt><dd><p>Mean blood pressure</p>
</dd>
<dt>resp1</dt><dd><p>Respiratory rate</p>
</dd>
<dt>wblc1</dt><dd><p>WBC</p>
</dd>
<dt>pafi1</dt><dd><p>PaO2/FIO2 ratio</p>
</dd>
<dt>paco21</dt><dd><p>PaCo2</p>
</dd>
<dt>ph1</dt><dd><p>PH</p>
</dd>
<dt>crea1</dt><dd><p>Creatinine</p>
</dd>
<dt>alb1</dt><dd><p>Albumin</p>
</dd>
<dt>scoma1</dt><dd><p>Glasgow Coma Score</p>
</dd>
<dt>cat1_copd</dt><dd><p>Primary disease category COPD</p>
</dd>
<dt>cat1_mosfsep</dt><dd><p>Primary disease category MOSF w sepsis</p>
</dd>
<dt>cat1_mosfmal</dt><dd><p>Primary disease category MOSF w malignancy</p>
</dd>
<dt>cat1_chf</dt><dd><p>Primary disease category CHF</p>
</dd>
<dt>cat1_coma</dt><dd><p>Primary disease category coma</p>
</dd>
<dt>cat1_cirr</dt><dd><p>Primary disease category cirrhosis</p>
</dd>
<dt>cat1_lung</dt><dd><p>Primary disease category lung cancer</p>
</dd>
<dt>cat1_colon</dt><dd><p>Primary disease category colon cancer</p>
</dd>
<dt>pr</dt><dd><p>Propensity score using 76 covariates</p>
</dd>
<dt>z</dt><dd><p>Treatment indicator</p>
</dd>
</dl>



<h3>References</h3>

<p>Connors et al. (1996): The effectiveness of RHC in the initial
care of critically ill patients. J American Medical Association 276:889-897.
</p>
<p><a href="https://hbiostat.org/data/">https://hbiostat.org/data/</a>.
</p>

<hr>
<h2 id='split_stratum'>Split one stratum into multiple strata</h2><span id='topic+split_stratum'></span>

<h3>Description</h3>

<p>Split one stratum into multiple with specified sample sizes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_stratum(
  z,
  X,
  strata,
  ist,
  nc,
  nt,
  wMax = 5,
  wEach = 1,
  solver = "Rglpk",
  integer = FALSE,
  threads = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_stratum_+3A_z">z</code></td>
<td>
<p>Vector of treatment assignment</p>
</td></tr>
<tr><td><code id="split_stratum_+3A_x">X</code></td>
<td>
<p>Covariate matrix or data.frame</p>
</td></tr>
<tr><td><code id="split_stratum_+3A_strata">strata</code></td>
<td>
<p>vector of initial strata assignments; only used if <code>object</code> is not supplied.
Can be <code>NULL</code>, in which case an initial stratification using the quintiles of the
propensity score is generated using <code><a href="#topic+prop_strat">prop_strat</a>()</code> and the generated
propensity score is also added to the X matrix as an extra covariate</p>
</td></tr>
<tr><td><code id="split_stratum_+3A_ist">ist</code></td>
<td>
<p>the stratum to be split</p>
</td></tr>
<tr><td><code id="split_stratum_+3A_nc">nc</code></td>
<td>
<p>a vector stating how many control units to place in
each of the new split strata. The sum must be the total number of controls
in the stratum to be split</p>
</td></tr>
<tr><td><code id="split_stratum_+3A_nt">nt</code></td>
<td>
<p>a vector stating how many treated units to place in
each of the new split strata. The sum must be the total number of treated units
in the stratum to be split</p>
</td></tr>
<tr><td><code id="split_stratum_+3A_wmax">wMax</code></td>
<td>
<p>the weight the objective places on the maximum epsilon</p>
</td></tr>
<tr><td><code id="split_stratum_+3A_weach">wEach</code></td>
<td>
<p>the weight the objective places on each epsilon</p>
</td></tr>
<tr><td><code id="split_stratum_+3A_solver">solver</code></td>
<td>
<p>character specifying the optimization software to use.
Options are &quot;Rglpk&quot; or &quot;gurobi&quot;. The default is &quot;gurobi&quot;</p>
</td></tr>
<tr><td><code id="split_stratum_+3A_integer">integer</code></td>
<td>
<p>boolean whether to use integer programming instead of randomized rounding.
Default is <code>FALSE</code>. It is not recommended to set this to <code>TRUE</code> as the problem may never finish</p>
</td></tr>
<tr><td><code id="split_stratum_+3A_threads">threads</code></td>
<td>
<p>how many threads to use in the optimization if using &quot;gurobi&quot; as the solver. Default will use all available threads</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements:
</p>

<ul>
<li><p>valueIP, valueLP: integer and linear programming scaled objective values
</p>
</li>
<li><p>n_smds: number of standardized mean differences contributing to the objective values
(multiply the scaled objective values by this number to get the true objective values)
</p>
</li>
<li><p>n_fracs: the number of units with fractional linear programming solutions
</p>
</li>
<li><p>rand_c_prop, rand_t_prop: proportions of the control and treated units in each stratum
that were selected with randomness
</p>
</li>
<li><p>pr: linear programming solution, with rows corresponding to the strata and columns to the units
</p>
</li>
<li><p>selection: vector of selected strata for each unit in the initial stratum to be split
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Generate a small data set
set.seed(25)
samp &lt;- sample(1:nrow(rhc_X), 1000)
cov_samp &lt;- sample(1:26, 10)

# Create some strata
ps &lt;- prop_strat(z = rhc_X[samp, "z"],
                 X = rhc_X[samp, cov_samp], nstrata = 5)

# Save the sample sizes
tab &lt;- table(ps$z, ps$base_strata)

# Choose the best sample sizes among the options provided
split_stratum(z = ps$z, X = ps$X, strata = ps$base_strata, ist = 1,
           nc = c(floor(tab[1, 1] * 0.25), ceiling(tab[1, 1] * 0.75)),
           nt = c(floor(tab[2, 1] * 0.3), ceiling(tab[2, 1] * 0.7)))

</code></pre>

<hr>
<h2 id='strat'>Helper for object of class &quot;strat&quot;</h2><span id='topic+strat'></span>

<h3>Description</h3>

<p>Creates an object of S3 class &quot;strat&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strat(z, X, base_strata = NULL, refined_strata = NULL, details = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strat_+3A_z">z</code></td>
<td>
<p>Vector of treatment assignment</p>
</td></tr>
<tr><td><code id="strat_+3A_x">X</code></td>
<td>
<p>Covariate matrix or data.frame</p>
</td></tr>
<tr><td><code id="strat_+3A_base_strata">base_strata</code></td>
<td>
<p>Original strata, if they exist</p>
</td></tr>
<tr><td><code id="strat_+3A_refined_strata">refined_strata</code></td>
<td>
<p>Refined strata, if they exist</p>
</td></tr>
<tr><td><code id="strat_+3A_details">details</code></td>
<td>
<p>A list of details from the linear program.
Include X_std if calculated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>strat</code> if valid
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Don't need to include any stratification
strat_object &lt;- strat(z = rhc_X[, "z"], X = rhc_X[, !(colnames(rhc_X) %in% "z")])

# Can include base and/or refined stratification if desired
strat_object &lt;- strat(z = rhc_X[, "z"], X = rhc_X[, !(colnames(rhc_X) %in% "z")],
                      base_strata = rep(1, nrow(rhc_X)),
                      refined_strata = NULL)
</code></pre>

<hr>
<h2 id='table_rand_pvals'>Generate a covariate balance table from the empirical randomization null distribution</h2><span id='topic+table_rand_pvals'></span>

<h3>Description</h3>

<p>Generate a table using the information collected in <code><a href="#topic+rand_pvals">rand_pvals</a>()</code>.
See <code><a href="#topic+rand_pvals">rand_pvals</a>()</code> for more details about the methods used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_rand_pvals(
  object = NULL,
  z = NULL,
  X = NULL,
  base_strata = NULL,
  refined_strata = NULL,
  options = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table_rand_pvals_+3A_object">object</code></td>
<td>
<p>an optional object of class <code>strat</code>,
typically created using <code><a href="#topic+strat">strat</a>()</code>
or as a result of a call to <code><a href="#topic+prop_strat">prop_strat</a>()</code> or <code><a href="#topic+refine">refine</a>()</code>.
If not provided, <code>z</code> and <code>X</code> must be specified</p>
</td></tr>
<tr><td><code id="table_rand_pvals_+3A_z">z</code></td>
<td>
<p>vector of treatment assignment; only used if <code>object</code> is not supplied</p>
</td></tr>
<tr><td><code id="table_rand_pvals_+3A_x">X</code></td>
<td>
<p>covariate matrix/data.frame; only used if <code>object</code> is not supplied</p>
</td></tr>
<tr><td><code id="table_rand_pvals_+3A_base_strata">base_strata</code></td>
<td>
<p>optional initial stratification for which to calculate
the empirical randomization null distribution;
only used if <code>object</code> is not supplied</p>
</td></tr>
<tr><td><code id="table_rand_pvals_+3A_refined_strata">refined_strata</code></td>
<td>
<p>optional refined stratification for which to calculate
the empirical randomization null distribution;
only used if <code>object</code> is not supplied</p>
</td></tr>
<tr><td><code id="table_rand_pvals_+3A_options">options</code></td>
<td>
<p>list of additional options, listed in the <code>details</code> below</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>options</code> list argument can contain any of the following elements:
</p>

<ul>
<li><p>nrand: how many times to randomize the treatment assignment when forming the null distribution.
Default is 10000
</p>
</li>
<li><p>criterion: which optimization criterion to use when calculating the objective value.
Options are &quot;max&quot;, &quot;sum&quot;, or &quot;combo&quot;, referring to whether to include the
maximum standardized mean difference (SMD), the sum of all SMDs,
or a combination of the maximum and the sum. The default is &quot;combo&quot;
</p>
</li>
<li><p>wMax: how much to weight the maximum standardized mean difference compared to the sum.
Only used if criterion is set to &quot;combo&quot;. Default is 5
</p>
</li>
<li><p>incl_base: whether to include columns for the initial stratification in the table.
Default is <code>TRUE</code> if a base stratification is provided
</p>
</li>
<li><p>rand_pvals: if already calculated, the returned list of information from <code><a href="#topic+rand_pvals">rand_pvals</a>()</code>.
If <code>NULL</code>, this will be calculated
</p>
</li></ul>



<h3>Value</h3>

<p>Matrix with 4 or 8 columns, depending whether one or both of base and
refined strata are provided and the <code>incl_base</code> option.
The columns give the observed standardized mean difference or objective value,
the median and maximum across <code>nrand</code> null simulations, and the P-value which is the
proportion of the null simulations that have worse covariate balance than the observed value.
The top three rows give the scaled objective value and the average and maximum standardized mean differences across
all strata and covariates. The following rows, one for each covariate, give the standardized mean difference
for that covariate, averaged across strata. The first row for the scaled objective value is <code>NULL</code> for the base
stratification, if included, as the base stratification does not generally minimize a mathematical objective function.
</p>

<hr>
<h2 id='validate_strat'>Validator for object of class &quot;strat&quot;</h2><span id='topic+validate_strat'></span>

<h3>Description</h3>

<p>Checks validity of an object of S3 class &quot;strat&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_strat(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_strat_+3A_object">object</code></td>
<td>
<p>An object of class <code>strat</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Error or object of class <code>strat</code> if valid
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
