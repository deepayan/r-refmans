<!DOCTYPE html><html><head><title>Help for package nat.nblast</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nat.nblast}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#nat.nblast-package'><p>Neuron similarity, search and clustering tools</p></a></li>
<li><a href='#['><p>Extract parts of a sparse <code>spam</code> matrix</p></a></li>
<li><a href='#calc_dists_dotprods'><p>Calculate distances and dot products between two sets of neurons</p></a></li>
<li><a href='#calc_prob_mat'><p>Calculate probability matrix from distances and dot products between neuron</p>
segments</a></li>
<li><a href='#calc_score_matrix'><p>Calculate scoring matrix from probability matrices for matching and</p>
non-matching sets of neurons</a></li>
<li><a href='#create_scoringmatrix'><p>Create a scoring matrix given matching and non-matching sets of neurons</p></a></li>
<li><a href='#diagonal'><p>Extract diagonal terms from a variety of matrix types</p></a></li>
<li><a href='#fctraces20'><p>20 traced Drosophila neurons from Chiang et al 2011</p></a></li>
<li><a href='#fill_in_sparse_score_mat'><p>Add one or more submatrices to a sparse score matrix</p></a></li>
<li><a href='#fill_pairs_sparse_score_mat'><p>Add forwards, reverse and self scores for a pair of neurons to a sparse score matrix</p></a></li>
<li><a href='#nblast'><p>Calculate similarity score for neuron morphologies</p></a></li>
<li><a href='#nblast_allbyall'><p>Wrapper function to compute all by all NBLAST scores for a set of neurons</p></a></li>
<li><a href='#NeuriteBlast'><p>Produce similarity score for neuron morphologies</p></a></li>
<li><a href='#neuron_pairs'><p>Utility function to generate all or random pairs of neurons</p></a></li>
<li><a href='#nhclust'><p>Cluster a set of neurons</p></a></li>
<li><a href='#plot3d.hclust'><p>Methods to identify and plot groups of neurons cut from an <code>hclust</code></p>
object</a></li>
<li><a href='#show_similarity'><p>Display two neurons with segments in the query coloured by similarity</p></a></li>
<li><a href='#smat.fcwb'><p>Scoring matrices for neuron similarities in FCWB template brain</p></a></li>
<li><a href='#sparse_score_mat'><p>Convert a subset of a square score matrix to a sparse representation</p></a></li>
<li><a href='#sub_dist_mat'><p>Convert (a subset of) a raw score matrix to a distance matrix</p></a></li>
<li><a href='#sub_score_mat'><p>Return scores (or distances) for given query and target neurons</p></a></li>
<li><a href='#subset.hclust'><p>Return the labels of items in 1 or more groups cut from hclust object</p></a></li>
<li><a href='#WeightedNNBasedLinesetMatching'><p>Compute point &amp; tangent vector similarity score between two linesets</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>NeuroAnatomy Toolbox ('nat') Extension for Assessing Neuron
Similarity and Clustering</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6.7</td>
</tr>
<tr>
<td>Description:</td>
<td>Extends package 'nat' (NeuroAnatomy Toolbox) by providing a
    collection of NBLAST-related functions for neuronal morphology comparison (Costa et al. (2016) &lt;<a href="https://doi.org/10.1016%2Fj.neuron.2016.06.012">doi:10.1016/j.neuron.2016.06.012</a>&gt;).</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://natverse.org/nat.nblast/">https://natverse.org/nat.nblast/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/natverse/nat.nblast/issues">https://github.com/natverse/nat.nblast/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.15.1), rgl, methods, nat (&ge; 1.5.12)</td>
</tr>
<tr>
<td>Imports:</td>
<td>nabor, dendroextras, plyr, spam</td>
</tr>
<tr>
<td>Suggests:</td>
<td>spelling, bigmemory, ff, testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-13 18:13:58 UTC; James Manton</td>
</tr>
<tr>
<td>Author:</td>
<td>Gregory Jefferis <a href="https://orcid.org/0000-0002-0587-9355"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  James Manton <a href="https://orcid.org/0000-0001-9260-3156"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gregory Jefferis &lt;jefferis@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-14 08:20:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='nat.nblast-package'>Neuron similarity, search and clustering tools</h2><span id='topic+nat.nblast-package'></span><span id='topic+nat.nblast'></span>

<h3>Description</h3>

<p><b>nat.nblast</b> provides tools to compare neuronal morphology using the
NBLAST algorithm (Costa et al. 2016).
</p>


<h3>Similarity and search</h3>

<p>The main entry point for similarity and search functions is
<code><a href="#topic+nblast">nblast</a></code>. Traced neurons will normally be converted to the
<code><a href="nat.html#topic+dotprops">dotprops</a></code> format for search. When multiple neurons are
compared they should be in a <code><a href="nat.html#topic+neuronlist">neuronlist</a></code> object.
</p>
<p>The current NBLAST version (2) depends on a scoring matrix. Default
matrices trained using <em>Drosophila</em> neurons in the FCWB template brain
space are distributed with this package (see <code><a href="#topic+smat.fcwb">smat.fcwb</a></code>); see
<b>Scoring Matrices</b> section below for creating new scoring matrices.
</p>
<p><code>nblast</code> makes use of a more flexible but more complicated function
<code>NeuriteBlast</code> which includes several additional options. The function
<code>WeightedNNBasedLinesetMatching</code> provides the primitive functionality
of finding the nearest neighbour distances and absolute dot products for
two sets of segments. Neither of these functions are intended for end use.
</p>
<p>Calculating all by all similarity scores is facilitated by the
<code><a href="#topic+nblast_allbyall">nblast_allbyall</a></code> function which can take either a
<code><a href="nat.html#topic+neuronlist">neuronlist</a></code> as input or a character vector naming (a subset)
of neurons in a (large) <code><a href="nat.html#topic+neuronlist">neuronlist</a></code>. The
<code><a href="nat.html#topic+neuronlist">neuronlist</a></code> containing the input neurons should be resident in
memory i.e. not the <code><a href="nat.html#topic+neuronlistfh">neuronlistfh</a></code>.
</p>


<h3>Clustering</h3>

<p>Once an all by all similarity score matrix is available it can be used as
the input to a variety of clustering algorithms. <code><a href="#topic+nhclust">nhclust</a></code>
provides a convenient wrapper for R's hierarchical clustering function
<code><a href="stats.html#topic+hclust">hclust</a></code>. If you wish to use another clustering function, then
you can use the <code><a href="#topic+sub_dist_mat">sub_dist_mat</a></code> to convert a raw similarity
score matrix into a normalised distance matrix (or R <code><a href="stats.html#topic+dist">dist</a></code>
object) suitable for clustering. If you need a similarity matrix or want to
modify the normalisation then you can use <code><a href="#topic+sub_score_mat">sub_score_mat</a></code>.
</p>
<p>Note that raw NBLAST scores are not symmetric (i.e. S(A,B) is not equal to
S(B,A)) so before clustering we construct a symmetric similarity/distance
matrix <code>1/2 * ( S(A,B)/S(A,A) + S(B,A)/S(B,B) )</code>. See
<code><a href="#topic+sub_score_mat">sub_score_mat</a></code>'s documentation for details.
</p>


<h3>Cached scores</h3>

<p>Although NBLAST is fast and can be parallelised, it makes sense to cache to
disk all by all similarity scores for a group of neurons that will be
subject to repeated clustering or other analysis. The matrix can simply be
saved to disk and then reloaded using base R functions like
<code><a href="base.html#topic+save">save</a></code> and <code><a href="base.html#topic+load">load</a></code>. <code><a href="#topic+sub_score_mat">sub_score_mat</a></code> and
<code><a href="#topic+sub_dist_mat">sub_dist_mat</a></code> can be used to extract a subset of scores from
this raw score matrix. For large matrices, the <code>bigmemory</code> or
<code>ff</code> packages allow matrices to be stored on disk and portions loaded
into memory on demand. <code><a href="#topic+sub_score_mat">sub_score_mat</a></code> and
<code><a href="#topic+sub_dist_mat">sub_dist_mat</a></code> work equally well for regular in-memory matrices
and these disk-backed matrices.
</p>
<p>To give an example, for 16,129 neurons from the flycircuit.tw dataset, the
260,144,641 comparisons took about 250 hours of compute time (half a day on
~20 cores). When saved to disk as single precision (i.e. 4 bytes per score)
<code>ff</code> matrix they occupy just over 1Gb.
</p>


<h3>Calculating scoring matrices</h3>

<p>The NBLAST algorithm depends on appropriately calibrated scoring matrices.
These encapsulate the log odds ratio that a pair of segments come from two
structurally related neurons rather than two unrelated neurons, given the
observed distance and absolute dot product of the two segments. Scoring
matrices can be constructed using the <code><a href="#topic+create_scoringmatrix">create_scoringmatrix</a></code>
function, supplying a set of matching neurons and a set of non-matching
neurons. See the <code>create_scoringmatrix</code> documentation for links to
lower-level functions that provide finer control over construction of the
scoring matrix.
</p>


<h3>Package Options</h3>

<p>There is one package option <code>nat.nblast.defaultsmat</code> which is
<code>NULL</code> by default, but could for example be set to one of the scoring
matrices included with the package such as <code>"smat.fcwb"</code> or to a new
user-constructed matrix.
</p>


<h3>References</h3>

<p>Costa, M., Ostrovsky, A.D., Manton, J.D., Prohaska, S., and
Jefferis, G.S.X.E. (2014). NBLAST: Rapid, sensitive comparison of neuronal
structure and construction of neuron family databases. bioRxiv preprint.
<a href="https://doi.org/10.1101/006346">doi:10.1101/006346</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nblast">nblast</a></code>, <code><a href="#topic+smat.fcwb">smat.fcwb</a></code>,
<code><a href="#topic+nhclust">nhclust</a></code>, <code><a href="#topic+sub_dist_mat">sub_dist_mat</a></code>,
<code><a href="#topic+sub_score_mat">sub_score_mat</a></code>, <code><a href="#topic+create_scoringmatrix">create_scoringmatrix</a></code>
</p>

<hr>
<h2 id='+5B'>Extract parts of a sparse <code>spam</code> matrix</h2><span id='topic++5B'></span><span id='topic++5B+2Cspam+2Ccharacter+2Ccharacter+2Clogical-method'></span><span id='topic++5B+2Cspam+2Ccharacter+2Ccharacter+2Cmissing-method'></span><span id='topic++5B+2Cspam+2Ccharacter+2Cmissing+2Clogical-method'></span><span id='topic++5B+2Cspam+2Ccharacter+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2Cspam+2Cmissing+2Ccharacter+2Clogical-method'></span><span id='topic++5B+2Cspam+2Cmissing+2Ccharacter+2Cmissing-method'></span>

<h3>Description</h3>

<p>Extract parts of a sparse <code>spam</code> matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'spam,character,character,logical'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'spam,character,character,missing'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'spam,character,missing,logical'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'spam,character,missing,missing'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'spam,missing,character,logical'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'spam,missing,character,missing'
x[i, j, ..., drop = TRUE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B_+3A_x">x</code></td>
<td>
<p>object to extract from.</p>
</td></tr>
<tr><td><code id="+2B5B_+3A_i">i</code></td>
<td>
<p>row identifiers.</p>
</td></tr>
<tr><td><code id="+2B5B_+3A_j">j</code></td>
<td>
<p>column identifiers.</p>
</td></tr>
<tr><td><code id="+2B5B_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
<tr><td><code id="+2B5B_+3A_drop">drop</code></td>
<td>
<p>logical indicating that dimensions should be dropped.</p>
</td></tr>
</table>

<hr>
<h2 id='calc_dists_dotprods'>Calculate distances and dot products between two sets of neurons</h2><span id='topic+calc_dists_dotprods'></span>

<h3>Description</h3>

<p>Calculate distances and dot products between two sets of neurons
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_dists_dotprods(
  query_neurons,
  target_neurons,
  subset = NULL,
  ignoreSelf = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_dists_dotprods_+3A_query_neurons">query_neurons</code></td>
<td>
<p>a <code><a href="nat.html#topic+neuronlist">neuronlist</a></code> to use for calculating
distances and dot products.</p>
</td></tr>
<tr><td><code id="calc_dists_dotprods_+3A_target_neurons">target_neurons</code></td>
<td>
<p>a further <code><a href="nat.html#topic+neuronlist">neuronlist</a></code> to use for
calculating distances and dot products.</p>
</td></tr>
<tr><td><code id="calc_dists_dotprods_+3A_subset">subset</code></td>
<td>
<p>a <code><a href="base.html#topic+data.frame">data.frame</a></code> specifying which neurons in
<code>query_neurons</code> and <code>target_neurons</code> should be compared, with
columns specifying query and target neurons by name, with one row for each
pair. If unspecified, this defaults to an all-by-all comparison.</p>
</td></tr>
<tr><td><code id="calc_dists_dotprods_+3A_ignoreself">ignoreSelf</code></td>
<td>
<p>a Boolean indicating whether to ignore comparisons of a
neuron against itself (default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="calc_dists_dotprods_+3A_...">...</code></td>
<td>
<p>extra arguments to pass to <code><a href="#topic+NeuriteBlast">NeuriteBlast</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Distances and dot products are the raw inputs for constructing
scoring matrices for the NBLAST search algorithm.
</p>


<h3>Value</h3>

<p>A list, one element for for pair of neurons with a 2 column
data.frame containing one column of distances and another of absolute dot
products.
</p>

<hr>
<h2 id='calc_prob_mat'>Calculate probability matrix from distances and dot products between neuron
segments</h2><span id='topic+calc_prob_mat'></span>

<h3>Description</h3>

<p>Calculate probability matrix from distances and dot products between neuron
segments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_prob_mat(
  nndists,
  dotprods,
  distbreaks,
  dotprodbreaks = seq(0, 1, by = 0.1),
  ReturnCounts = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_prob_mat_+3A_nndists">nndists</code></td>
<td>
<p>a list of nearest-neighbour distances or a list of both
nearest-neighbour distances and dot products.</p>
</td></tr>
<tr><td><code id="calc_prob_mat_+3A_dotprods">dotprods</code></td>
<td>
<p>a list of dot products.</p>
</td></tr>
<tr><td><code id="calc_prob_mat_+3A_distbreaks">distbreaks</code></td>
<td>
<p>a vector specifying the breaks for distances in the
probability matrix.</p>
</td></tr>
<tr><td><code id="calc_prob_mat_+3A_dotprodbreaks">dotprodbreaks</code></td>
<td>
<p>a vector specifying the breaks for dot products in the
probability matrix.</p>
</td></tr>
<tr><td><code id="calc_prob_mat_+3A_returncounts">ReturnCounts</code></td>
<td>
<p>a Boolean indicating that counts should be returned
instead of the default probabilities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with columns as specified by <code>dotprodbreaks</code> and rows
as specified by <code>distbreaks</code>, containing probabilities (for default
value of <code>ReturnCounts=TRUE</code>) or counts (if <code>ReturnCounts=TRUE</code>)
for finding neuron segments with the given distance and dot product.
</p>

<hr>
<h2 id='calc_score_matrix'>Calculate scoring matrix from probability matrices for matching and
non-matching sets of neurons</h2><span id='topic+calc_score_matrix'></span>

<h3>Description</h3>

<p>Calculate scoring matrix from probability matrices for matching and
non-matching sets of neurons
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_score_matrix(matchmat, randmat, logbase = 2, epsilon = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_score_matrix_+3A_matchmat">matchmat</code></td>
<td>
<p>a probability matrix given by considering 'matching' neurons.</p>
</td></tr>
<tr><td><code id="calc_score_matrix_+3A_randmat">randmat</code></td>
<td>
<p>a probability matrix given by considering 'non-matching' or
'random' neurons.</p>
</td></tr>
<tr><td><code id="calc_score_matrix_+3A_logbase">logbase</code></td>
<td>
<p>the base to which the logarithm should be taken to produce the
final scores.</p>
</td></tr>
<tr><td><code id="calc_score_matrix_+3A_epsilon">epsilon</code></td>
<td>
<p>a pseudocount to prevent division by zero when constructing
the log odds ratio in the probability matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with with <code>class=c("scoringmatrix", "table")</code>, with
columns as specified by <code>dotprodbreaks</code> and rows as specified by
<code>distbreaks</code>, containing scores for neuron segments with the given
distance and dot product.
</p>

<hr>
<h2 id='create_scoringmatrix'>Create a scoring matrix given matching and non-matching sets of neurons</h2><span id='topic+create_scoringmatrix'></span>

<h3>Description</h3>

<p>Calculate a scoring matrix embodying the logarithm of the odds
that a matching pair of neurite segments come from a structurally related
rather than random pair of neurons. This function embodies sensible default
behaviours and is recommended for end users. More control is available by
using the individual functions listed in <b>See Also</b>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_scoringmatrix(
  matching_neurons,
  nonmatching_neurons,
  matching_subset = NULL,
  non_matching_subset = NULL,
  ignoreSelf = TRUE,
  distbreaks,
  dotprodbreaks = seq(0, 1, by = 0.1),
  logbase = 2,
  epsilon = 1e-06,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_scoringmatrix_+3A_matching_neurons">matching_neurons</code></td>
<td>
<p>a <code><a href="nat.html#topic+neuronlist">neuronlist</a></code> of matching neurons.</p>
</td></tr>
<tr><td><code id="create_scoringmatrix_+3A_nonmatching_neurons">nonmatching_neurons</code></td>
<td>
<p>a <code><a href="nat.html#topic+neuronlist">neuronlist</a></code> of non-matching
neurons.</p>
</td></tr>
<tr><td><code id="create_scoringmatrix_+3A_matching_subset">matching_subset</code>, <code id="create_scoringmatrix_+3A_non_matching_subset">non_matching_subset</code></td>
<td>
<p>data.frames indicating which pairs
of neurons in the two input neuron lists should be used to generate the
matching and null distributions. See details for the default behaviour when
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="create_scoringmatrix_+3A_ignoreself">ignoreSelf</code></td>
<td>
<p>a Boolean indicating whether to ignore comparisons of a
neuron against itself (default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="create_scoringmatrix_+3A_distbreaks">distbreaks</code></td>
<td>
<p>a vector specifying the breaks for distances in the
probability matrix.</p>
</td></tr>
<tr><td><code id="create_scoringmatrix_+3A_dotprodbreaks">dotprodbreaks</code></td>
<td>
<p>a vector specifying the breaks for dot products in the
probability matrix.</p>
</td></tr>
<tr><td><code id="create_scoringmatrix_+3A_logbase">logbase</code></td>
<td>
<p>the base to which the logarithm should be taken to produce the
final scores.</p>
</td></tr>
<tr><td><code id="create_scoringmatrix_+3A_epsilon">epsilon</code></td>
<td>
<p>a pseudocount to prevent division by zero when constructing
the log odds ratio in the probability matrix.</p>
</td></tr>
<tr><td><code id="create_scoringmatrix_+3A_...">...</code></td>
<td>
<p>extra arguments to pass to <code><a href="#topic+NeuriteBlast">NeuriteBlast</a></code> or options
for the call to <code><a href="plyr.html#topic+mlply">mlply</a></code> call that actually iterates over
neuron pairs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default <code>create_scoringmatrix</code> will use all neurons in
<code>matching_neurons</code> to create the matching distribution. This is
appropriate if all of these neurons are of a single type. If you wish to
use multiple types of neurons then you will need to specify a
<code>matching_subset</code> to indicate which pairs of neurons are of the same
type.
</p>
<p>By default <code>create_scoringmatrix</code> will use a random set of pairs from
<code>non_matching_neurons</code> to create the null distribution. The number of
random pairs will be equal to the number of matching pairs defined by
<code>matching_neurons</code> This is appropriate if non_matching_neurons
contains a large collection of neurons of different types. You may wish to
set the random seed using <code><a href="base.html#topic+set.seed">set.seed</a></code> if you want to ensure that
exactly the same (pseudo-)random pairs of neurons are used in subsequent
calls.
</p>


<h3>Value</h3>

<p>A matrix with columns as specified by <code>dotprodbreaks</code> and rows
as specified by <code>distbreaks</code>, containing log odd scores for neuron
segments with the given distance and dot product.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calc_score_matrix">calc_score_matrix</a>, <a href="#topic+calc_prob_mat">calc_prob_mat</a>,
  <a href="#topic+calc_dists_dotprods">calc_dists_dotprods</a>, <a href="#topic+neuron_pairs">neuron_pairs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# calculate scoring matrix
# bring in some mushroom body neurons
library(nat)
data(kcs20)
# convert the (connected) tracings into dotprops (point and vector)
# representation, resampling at 1 micron intervals along neuron
fctraces20.dps=dotprops(fctraces20, resample=1)
# we will use both all kcs vs all fctraces20 and fctraces20 vs fctraces20
# as random_pairs to make the null distribution
random_pairs=rbind(neuron_pairs(fctraces20), neuron_pairs(nat::kcs20, fctraces20))
# you can add .progress='natprogress' if this looks like taking a while
smat=create_scoringmatrix(kcs20, c(kcs20, fctraces20.dps),
                          non_matching_subset=random_pairs)

# now plot the scoring matrix
distbreaks=attr(smat,'distbreaks')
distbreaks=distbreaks[-length(distbreaks)]
dotprodbreaks=attr(smat,'dotprodbreaks')[-1]
# Create a function interpolating colors in the range of specified colors
jet.colors &lt;- colorRampPalette( c("blue", "green", "yellow", "red") )
# 2d filled contour plot of scoring matrix. Notice that the there is a region
# at small distances and large abs dot product with the highest log odds ratio
# i.e. most indicative of a match rather than non-match
filled.contour(x=distbreaks, y=dotprodbreaks, z=smat, col=jet.colors(20),
  main='smat: log odds ratio', xlab='distance /um', ylab='abs dot product')

# 3d perspective plot of the scoring matrix
persp3d(x=distbreaks, y=dotprodbreaks, z=smat, col=jet.colors(20)[cut(smat,20)],
xlab='distance /um', ylab='abs dot product', zlab='log odds ratio')

</code></pre>

<hr>
<h2 id='diagonal'>Extract diagonal terms from a variety of matrix types</h2><span id='topic+diagonal'></span><span id='topic+diagonal.default'></span>

<h3>Description</h3>

<p>Extract diagonal terms from a variety of matrix types
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagonal(x, indices = NULL)

## Default S3 method:
diagonal(x, indices = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagonal_+3A_x">x</code></td>
<td>
<p>A square matrix</p>
</td></tr>
<tr><td><code id="diagonal_+3A_indices">indices</code></td>
<td>
<p>specifies a subset of the diagonal using a character vector of
names, a logical vector or integer indices. The default (<code>NULL</code>)
implies all elements.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Insists that input matrix is square. Uses the <code>'diagonal'</code>
attribute when available and has specialised handling of <code>ff</code>,
<code>big.matrix</code>, <code>dgCMatrix</code> matrices. Does not check that row and
column names are identical for those matrix classes (unlike the base
<code><a href="base.html#topic+diag">diag</a></code> function, but always uses rownames.
</p>


<h3>Value</h3>

<p>a named vector containing the diagonal elements.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m=fill_in_sparse_score_mat(letters[1:5])
diagonal(m)
</code></pre>

<hr>
<h2 id='fctraces20'>20 traced Drosophila neurons from Chiang et al 2011</h2><span id='topic+fctraces20'></span>

<h3>Description</h3>

<p>This R list (which has additional class <code>neuronlist</code>) contains 15
skeletonized <em>Drosophila</em> neurons as <code>dotprops</code> objects. Original
data is due to Chiang et al. [1], who have generously shared their raw data.
Automated tracing of neuron skeletons was carried out by Lee et al [2]. Image
registration and further processing was carried out by Greg Jefferis, Marta
Costa and James Manton[3].
</p>


<h3>References</h3>

<p>[1] Chiang A.S., Lin C.Y., Chuang C.C., Chang H.M., Hsieh C.H.,
Yeh C.W., Shih C.T., Wu J.J., Wang G.T., Chen Y.C., Wu C.C., Chen G.Y.,
Ching Y.T., Lee P.C., Lin C.Y., Lin H.H., Wu C.C., Hsu H.W., Huang Y.A.,
Chen J.Y., et al. (2011). Three-dimensional reconstruction of brain-wide
wiring networks in Drosophila at single-cell resolution. Curr Biol 21 (1),
1&ndash;11. doi: <a href="https://doi.org/10.1016/j.cub.2010.11.056">doi:10.1016/j.cub.2010.11.056</a>
</p>
<p>[2] P.-C. Lee, C.-C. Chuang, A.-S. Chiang, and Y.-T. Ching. (2012).
High-throughput computer method for 3d neuronal structure reconstruction
from the image stack of the Drosophila brain and its applications. PLoS
Comput Biol, 8(9):e1002658, Sep 2012. doi:
<a href="https://doi.org/10.1371/journal.pcbi.1002658">doi:10.1371/journal.pcbi.1002658</a>.
</p>
<p>[3] NBLAST: Rapid, sensitive comparison of neuronal structure and
construction of neuron family databases. Marta Costa, Aaron D. Ostrovsky,
James D. Manton, Steffen Prohaska, Gregory S.X.E. Jefferis. bioRxiv doi:
<a href="https://doi.org/10.1101/006346">doi:10.1101/006346</a>.
</p>

<hr>
<h2 id='fill_in_sparse_score_mat'>Add one or more submatrices to a sparse score matrix</h2><span id='topic+fill_in_sparse_score_mat'></span>

<h3>Description</h3>

<p>Add one or more submatrices to a sparse score matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill_in_sparse_score_mat(sparse_matrix, ..., diag = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fill_in_sparse_score_mat_+3A_sparse_matrix">sparse_matrix</code></td>
<td>
<p>either an existing (square) sparse matrix or a character
vector of names that will be used to define an empty sparse matrix.</p>
</td></tr>
<tr><td><code id="fill_in_sparse_score_mat_+3A_...">...</code></td>
<td>
<p>Additional matrices to insert into <code>sparse_matrix</code>. Row and
column names must have matches in <code>sparse_matrix</code>.</p>
</td></tr>
<tr><td><code id="fill_in_sparse_score_mat_+3A_diag">diag</code></td>
<td>
<p>optional full diagonal for sparse matrix i.e. self-match scores.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>sparse_score_mat
</p>

<hr>
<h2 id='fill_pairs_sparse_score_mat'>Add forwards, reverse and self scores for a pair of neurons to a sparse score matrix</h2><span id='topic+fill_pairs_sparse_score_mat'></span>

<h3>Description</h3>

<p>Add forwards, reverse and self scores for a pair of neurons to a sparse score matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill_pairs_sparse_score_mat(
  sparse_matrix,
  n1,
  n2,
  dense_matrix,
  reverse = TRUE,
  self = TRUE,
  reverse_self = (reverse &amp;&amp; self)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fill_pairs_sparse_score_mat_+3A_sparse_matrix">sparse_matrix</code></td>
<td>
<p>the sparse matrix to fill in.</p>
</td></tr>
<tr><td><code id="fill_pairs_sparse_score_mat_+3A_n1">n1</code></td>
<td>
<p>the name of the query neuron.</p>
</td></tr>
<tr><td><code id="fill_pairs_sparse_score_mat_+3A_n2">n2</code></td>
<td>
<p>the name of the target neuron.</p>
</td></tr>
<tr><td><code id="fill_pairs_sparse_score_mat_+3A_dense_matrix">dense_matrix</code></td>
<td>
<p>the score matrix from which to extract scores.</p>
</td></tr>
<tr><td><code id="fill_pairs_sparse_score_mat_+3A_reverse">reverse</code></td>
<td>
<p>logical indicating that the reverse score should also be filled in (default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="fill_pairs_sparse_score_mat_+3A_self">self</code></td>
<td>
<p>logical indicating that the self-score of the query should also be filled in (used for normalised scores; default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="fill_pairs_sparse_score_mat_+3A_reverse_self">reverse_self</code></td>
<td>
<p>logical indicating that the self-score of the target should also be filled in (used for mean scores; default <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sparse matrix (of class <code><a href="spam.html#topic+spam">spam</a></code>) with the specified score entries filled.
</p>

<hr>
<h2 id='nblast'>Calculate similarity score for neuron morphologies</h2><span id='topic+nblast'></span>

<h3>Description</h3>

<p>Uses the NBLAST algorithm that compares the morphology of two neurons. For
more control over the parameters of the algorithm, see the arguments of
<code><a href="#topic+NeuriteBlast">NeuriteBlast</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nblast(
  query,
  target = getOption("nat.default.neuronlist"),
  smat = NULL,
  sd = 3,
  version = c(2, 1),
  normalised = FALSE,
  UseAlpha = FALSE,
  OmitFailures = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nblast_+3A_query">query</code></td>
<td>
<p>the query neuron.</p>
</td></tr>
<tr><td><code id="nblast_+3A_target">target</code></td>
<td>
<p>a <code><a href="nat.html#topic+neuronlist">neuronlist</a></code> to compare neuron against.
Defaults to <code>options("nat.default.neuronlist")</code>. See
<code><a href="nat.html#topic+nat-package">nat-package</a></code>.</p>
</td></tr>
<tr><td><code id="nblast_+3A_smat">smat</code></td>
<td>
<p>the scoring matrix to use (see details)</p>
</td></tr>
<tr><td><code id="nblast_+3A_sd">sd</code></td>
<td>
<p>Standard deviation to use in distance dependence of NBLAST v1
algorithm. Ignored when <code>version=2</code>.</p>
</td></tr>
<tr><td><code id="nblast_+3A_version">version</code></td>
<td>
<p>the version of the algorithm to use (the default, 2, is the
latest).</p>
</td></tr>
<tr><td><code id="nblast_+3A_normalised">normalised</code></td>
<td>
<p>whether to divide scores by the self-match score of the
query</p>
</td></tr>
<tr><td><code id="nblast_+3A_usealpha">UseAlpha</code></td>
<td>
<p>whether to weight the similarity score for each matched
segment to emphasise long range neurites rather then arbours (default:
FALSE, see <b><code>UseAlpha</code></b> section for details).</p>
</td></tr>
<tr><td><code id="nblast_+3A_omitfailures">OmitFailures</code></td>
<td>
<p>Whether to omit neurons for which <code>FUN</code> gives an
error. The default value (<code>NA</code>) will result in <code>nblast</code> stopping
with an error message the moment there is an error. For other values, see
details.</p>
</td></tr>
<tr><td><code id="nblast_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+NeuriteBlast">NeuriteBlast</a></code> or the
function used to compute scores from distances/dot products. (expert use
only).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>when <code>smat=NULL</code> <code>options("nat.nblast.defaultsmat")</code> will
be checked and if <code>NULL</code>, then <code>smat.fcwb</code> or
<code>smat_alpha.fcwb</code> will be used depending on the value of
<code>UseAlpha</code>.
</p>
<p>When <code>OmitFailures</code> is not <code>NA</code>, individual nblast calls will be
wrapped in <code>try</code> to ensure that failure for any single neuron does not
abort the whole <code>nblast</code> call. When <code>OmitFailures=FALSE</code>, missing
values will be left as <code>NA</code>. <code>OmitFailures=TRUE</code> is not (yet)
implemented. If you want to drop scores for neurons that failed you will
need to set <code>OmitFailures=FALSE</code> and then use <code><a href="stats.html#topic+na.omit">na.omit</a></code> or
similar to post-process the scores.
</p>
<p>Note that when <code>OmitFailures=FALSE</code> error messages will not be printed
because the call is wrapped as <code>try(expr, silent=TRUE)</code>.
</p>
<p>Internally, the <code><a href="plyr.html#topic+plyr">plyr</a></code> package is used to provide options for
parallelising NBLAST and displaying progress. To display a progress bar as
the scores are computed, add <code>.progress="natprogress"</code> to the
arguments (non-text progress bars are available &ndash; see
<code><a href="plyr.html#topic+create_progress_bar">create_progress_bar</a></code>). To parallelise, add
<code>.parallel=TRUE</code> to the arguments. In order to make use of parallel
calculation, you must register a parallel backend that will distribute the
computations. There are several possible backends, the simplest of which is
the multicore option made available by <code>doMC</code>, which spreads the load
across cores of the same machine. Before using this, the backend must be
registered using <code>registerDoMC</code> (see example below).
</p>


<h3>Value</h3>

<p>Named list of similarity scores.
</p>


<h3>NBLAST Versions</h3>

<p>The <code>nblast</code> version argument presently
exposes two versions of the algorithm; both use the same core procedure of
aligning two vector clouds, segment by segment, and then computing the
distance and absolute dot product between the nearest segment in the target
neuron for every segment in the query neuron. However they differ
significantly in the procedure used to calculate a score using this set of
distances and absolute dot products.
</p>
<p><b>Version 1</b> of the algorithm uses a standard deviation (argument
<code>sd</code>) as a user-supplied parameter for a negative exponential
weighting function that determines the relationship between score and the
distance between segments. This corresponds to the parameter <code class="reqn">\sigma</code>
in the weighting function:
</p>
<p><code class="reqn">f=\sqrt{|\vec{u_{i}}\cdot\vec{v_{i}}|\exp\left(-d_{i}^{2}/2\sigma^{2}\right)}</code>
</p>
<p>This is the same approach described in Kohl et al 2013 and the similarity
scores in the interval (0,1) described in that paper can exactly
recapitulated by setting <code>version=1</code> and <code>normalised=TRUE</code>.
</p>
<p><b>Version 2</b> of the algorithm is described in Costa et al 2014. This
uses a more sophisticated and principled scoring approach based on a
log-odds ratio defined by the distribution of matches and non-matches in
sample data. This information is passed to the <code>nblast</code> function in
the form of a <em>scoring matrix</em> (which can be computed by
<code><a href="#topic+create_scoringmatrix">create_scoringmatrix</a></code>); a default scoring matrix
<code><a href="#topic+smat.fcwb">smat.fcwb</a></code> has been constructed for <em>Drosophila</em> neurons.
</p>
<p><b>Which version should I use?</b> You should use version 2 if you are
working with <em>Drosophila</em> neurons or you have sufficient training data
(in the form of validated matching and random neuron pairs to construct a
scoring matrix). If this is not the case, you can always fall back to
version 1, setting the free parameter (sd or <code class="reqn">\sigma</code>) to a value that
encapsulates your understanding of the location precision of neurons in
your species/brain region of interest. In the fly brain we have used
<code class="reqn">\sigma=3</code> microns, since previous estimates of the localisation of
identifiable features of neurons (Jefferis, Potter et al 2007) are of this
order.
</p>


<h3><code>UseAlpha</code></h3>

<p>In NBLAST v2, the alpha factor for a segment
indicates whether neighbouring segments are aligned in a similar direction
(as typical for e.g. a long range axonal projection) or randomly aligned
(as typical for dendritic arbours). See Costa et al. for details. Setting
<code>UseAlpha=TRUE</code> will emphasise the axon, primary neurite etc. of a
neuron. This can be a particularly useful option e.g. when you are
searching by a traced fragment that you know or suspect to follow an axon
tract.
</p>


<h3>References</h3>

<p>Kohl, J. Ostrovsky, A.D., Frechter, S., and Jefferis, G.S.X.E
(2013). A bidirectional circuit switch reroutes pheromone signals in male
and female brains. Cell 155 (7), 1610&ndash;23
<a href="https://doi.org/10.1016/j.cell.2013.11.025">doi:10.1016/j.cell.2013.11.025</a>.
</p>
<p>Costa, M., Ostrovsky, A.D., Manton, J.D., Prohaska, S., and Jefferis,
G.S.X.E. (2014). NBLAST: Rapid, sensitive comparison of neuronal structure
and construction of neuron family databases. bioRxiv preprint.
<a href="https://doi.org/10.1101/006346">doi:10.1101/006346</a>.
</p>
<p>Jefferis G.S.X.E., Potter C.J., Chan A.M., Marin E.C., Rohlfing T., Maurer
C.R.J., and Luo L. (2007). Comprehensive maps of Drosophila higher
olfactory centers: spatially segregated fruit and pheromone representation.
Cell 128 (6), 1187&ndash;1203.
<a href="https://doi.org/10.1016/j.cell.2007.01.040">doi:10.1016/j.cell.2007.01.040</a>
</p>


<h3>See Also</h3>

<p><code><a href="nat.html#topic+nat-package">nat-package</a></code>, <code><a href="#topic+nblast_allbyall">nblast_allbyall</a></code>,
<code><a href="#topic+create_scoringmatrix">create_scoringmatrix</a></code>, <code><a href="#topic+smat.fcwb">smat.fcwb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load sample Kenyon cell data from nat package
data(kcs20, package='nat')
# search one neuron against all neurons
scores=nblast(kcs20[['GadMARCM-F000142_seg002']], kcs20)
# scores from best to worst, top hit is of course same neuron
sort(scores, decreasing = TRUE)
hist(scores, breaks=25, col='grey')
abline(v=1500, col='red')

# plot query neuron
open3d()
# plot top 3 hits (including self match with thicker lines)
plot3d(kcs20[which(sort(scores, decreasing = TRUE)&gt;1500)], lwd=c(3,1,1))
rest=names(which(scores&lt;1500))
plot3d(rest, db=kcs20, col='grey', lwd=0.5)

# normalised scores (i.e. self match = 1) of all neurons vs each other
# note use of progress bar
scores.norm=nblast(kcs20, kcs20, normalised = TRUE, .progress="natprogress")
hist(scores.norm, breaks=25, col='grey')
# produce a heatmap from normalised scores
jet.colors &lt;- colorRampPalette( c("blue", "green", "yellow", "red") )
heatmap(scores.norm, labCol = with(kcs20,type), col=jet.colors(20), symm = TRUE)

## Not run: 
# Parallelise NBLASTing across 4 cores using doMC package
library(doMC)
registerDoMC(4)
scores.norm2=nblast(kcs20, kcs20, normalised=TRUE, .parallel=TRUE)
stopifnot(all.equal(scores.norm2, scores.norm))

## End(Not run)
</code></pre>

<hr>
<h2 id='nblast_allbyall'>Wrapper function to compute all by all NBLAST scores for a set of neurons</h2><span id='topic+nblast_allbyall'></span><span id='topic+nblast_allbyall.character'></span><span id='topic+nblast_allbyall.neuronlist'></span>

<h3>Description</h3>

<p>Calls <code>nblast</code> to compute the actual scores. Can accept
either a <code><a href="nat.html#topic+neuronlist">neuronlist</a></code> or neuron names as a character vector. This is a thin
wrapper around <code>nblast</code> and its main advantage is the option of &quot;mean&quot;
normalisation for forward and reverse scores, which is the most sensible
input to give to a clustering algorithm as well as the choice of returning
a distance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nblast_allbyall(x, ...)

## S3 method for class 'character'
nblast_allbyall(x, smat = NULL, db = getOption("nat.default.neuronlist"), ...)

## S3 method for class 'neuronlist'
nblast_allbyall(
  x,
  smat = NULL,
  distance = FALSE,
  normalisation = c("raw", "normalised", "mean"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nblast_allbyall_+3A_x">x</code></td>
<td>
<p>Input neurons (<code><a href="nat.html#topic+neuronlist">neuronlist</a></code> or character vector)</p>
</td></tr>
<tr><td><code id="nblast_allbyall_+3A_...">...</code></td>
<td>
<p>Additional arguments for methods or <code>nblast</code></p>
</td></tr>
<tr><td><code id="nblast_allbyall_+3A_smat">smat</code></td>
<td>
<p>the scoring matrix to use (see details of <code><a href="#topic+nblast">nblast</a></code>
for meaning of default <code>NULL</code> value)</p>
</td></tr>
<tr><td><code id="nblast_allbyall_+3A_db">db</code></td>
<td>
<p>A <code><a href="nat.html#topic+neuronlist">neuronlist</a></code> or a character vector naming one.
Defaults to value of <code>options("nat.default.neuronlist")</code></p>
</td></tr>
<tr><td><code id="nblast_allbyall_+3A_distance">distance</code></td>
<td>
<p>logical indicating whether to return distances or scores.</p>
</td></tr>
<tr><td><code id="nblast_allbyall_+3A_normalisation">normalisation</code></td>
<td>
<p>the type of normalisation procedure that should be
carried out, selected from  <code>'raw'</code>, <code>'normalised'</code> or
<code>'mean'</code> (i.e. the average of normalised scores in both directions).
If <code>distance=TRUE</code> then this cannot be raw.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code>nat</code> already provides a function
<code><a href="#topic+nhclust">nhclust</a></code> for clustering, which is a wrapper for R's
<code>hclust</code> function. <code>nhclust</code> actually expects <b>raw</b> scores
as input.
</p>


<h3>TODO</h3>

<p>It would be a good idea in the future to implement a parallel
version of this function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nblast">nblast</a>, <a href="#topic+sub_score_mat">sub_score_mat</a>, <a href="#topic+nhclust">nhclust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(nat)
kcs20.scoremat=nblast_allbyall(kcs20)
kcs20.hclust=nhclust(scoremat=kcs20.scoremat)
plot(kcs20.hclust)
</code></pre>

<hr>
<h2 id='NeuriteBlast'>Produce similarity score for neuron morphologies</h2><span id='topic+NeuriteBlast'></span>

<h3>Description</h3>

<p>A low-level entry point to the NBLAST algorithm that compares the morphology
of a neuron with those of a list of other neurons. For most use cases, one
would probably wish to use <code><a href="#topic+nblast">nblast</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NeuriteBlast(
  query,
  target,
  targetBinds = NULL,
  normalised = FALSE,
  OmitFailures = NA,
  simplify = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NeuriteBlast_+3A_query">query</code></td>
<td>
<p>either a single query neuron or a <code><a href="nat.html#topic+neuronlist">neuronlist</a></code></p>
</td></tr>
<tr><td><code id="NeuriteBlast_+3A_target">target</code></td>
<td>
<p>a <code>neuronlist</code> to compare neuron against.</p>
</td></tr>
<tr><td><code id="NeuriteBlast_+3A_targetbinds">targetBinds</code></td>
<td>
<p>numeric indices or names with which to subset
<code>target</code>.</p>
</td></tr>
<tr><td><code id="NeuriteBlast_+3A_normalised">normalised</code></td>
<td>
<p>whether to divide scores by the self-match score of the
query</p>
</td></tr>
<tr><td><code id="NeuriteBlast_+3A_omitfailures">OmitFailures</code></td>
<td>
<p>Whether to omit neurons for which <code>FUN</code> gives an
error. The default value (<code>NA</code>) will result in <code>nblast</code> stopping
with an error message the moment there is an error. For other values, see
details.</p>
</td></tr>
<tr><td><code id="NeuriteBlast_+3A_simplify">simplify</code></td>
<td>
<p>whether to simplify the scores from a list to a vector.
<code>TRUE</code> by default. The only time you might want to set this false is
if you are collecting something other than simple scores from the search
function. See <code><a href="base.html#topic+simplify2array">simplify2array</a></code> for further details.</p>
</td></tr>
<tr><td><code id="NeuriteBlast_+3A_...">...</code></td>
<td>
<p>extra arguments to pass to the distance function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For detailed description of the <code>OmitFailures</code> argument, see
the details section of <code><a href="#topic+nblast">nblast</a></code>.
</p>


<h3>Value</h3>

<p>Named list of similarity scores.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+WeightedNNBasedLinesetMatching">WeightedNNBasedLinesetMatching</a></code>
</p>

<hr>
<h2 id='neuron_pairs'>Utility function to generate all or random pairs of neurons</h2><span id='topic+neuron_pairs'></span>

<h3>Description</h3>

<p>Utility function to generate all or random pairs of neurons
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neuron_pairs(query, target, n = NA, ignoreSelf = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neuron_pairs_+3A_query">query</code>, <code id="neuron_pairs_+3A_target">target</code></td>
<td>
<p>either <code><a href="nat.html#topic+neuronlist">neuronlist</a></code>s or character vectors of
names. If target is missing, query will be used as both query and target.</p>
</td></tr>
<tr><td><code id="neuron_pairs_+3A_n">n</code></td>
<td>
<p>number of random pairs to draw. When NA, the default, uses
<code>expand.grid</code> to draw all pairs.</p>
</td></tr>
<tr><td><code id="neuron_pairs_+3A_ignoreself">ignoreSelf</code></td>
<td>
<p>Logical indicating whether to omit pairs consisting of the
same neuron (default <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with two character vector columns, query and target.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calc_score_matrix">calc_score_matrix</a>, <a href="base.html#topic+expand.grid">expand.grid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>neuron_pairs(nat::kcs20, n=20)
</code></pre>

<hr>
<h2 id='nhclust'>Cluster a set of neurons</h2><span id='topic+nhclust'></span>

<h3>Description</h3>

<p>Given an NBLAST all by all score matrix (which may be specified by a package
default) and/or a vector of neuron identifiers use <code><a href="stats.html#topic+hclust">hclust</a></code> to
carry out a hierarchical clustering. The default value of the <code>distfun</code>
argument will handle square distance matrices and R <code>dist</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nhclust(
  neuron_names,
  method = "ward",
  scoremat = NULL,
  distfun = as.dist,
  ...,
  maxneurons = 4000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nhclust_+3A_neuron_names">neuron_names</code></td>
<td>
<p>character vector of neuron identifiers.</p>
</td></tr>
<tr><td><code id="nhclust_+3A_method">method</code></td>
<td>
<p>clustering method (default Ward's).</p>
</td></tr>
<tr><td><code id="nhclust_+3A_scoremat">scoremat</code></td>
<td>
<p>score matrix to use (see <code>sub_score_mat</code> for details of
default).</p>
</td></tr>
<tr><td><code id="nhclust_+3A_distfun">distfun</code></td>
<td>
<p>function to convert distance matrix returned by
<code>sub_dist_mat</code> into R <code>dist</code> object (default=
<code><a href="stats.html#topic+as.dist">as.dist</a></code>).</p>
</td></tr>
<tr><td><code id="nhclust_+3A_...">...</code></td>
<td>
<p>additional parameters passed to <code><a href="stats.html#topic+hclust">hclust</a></code>.</p>
</td></tr>
<tr><td><code id="nhclust_+3A_maxneurons">maxneurons</code></td>
<td>
<p>set this to a sensible value to avoid loading huge (order
N^2) distances directly into memory.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="stats.html#topic+hclust">hclust</a></code> which describes the tree
produced by the clustering process.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+hclust">hclust</a>, <a href="stats.html#topic+dist">dist</a></code>
</p>
<p>Other scoremats: 
<code><a href="#topic+sub_dist_mat">sub_dist_mat</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(nat)
kcscores=nblast_allbyall(kcs20)
hckcs=nhclust(scoremat=kcscores)
# divide hclust object into 3 groups
library(dendroextras)
dkcs=colour_clusters(hckcs, k=3)
# change dendrogram labels to neuron type, extracting this information
# from type column in the metadata data.frame attached to kcs20 neuronlist
labels(dkcs)=with(kcs20[labels(dkcs)], type)
plot(dkcs)
# 3d plot of neurons in those clusters (with matching colours)
open3d()
plot3d(hckcs, k=3, db=kcs20)
# names of neurons in 3 groups
subset(hckcs, k=3)
</code></pre>

<hr>
<h2 id='plot3d.hclust'>Methods to identify and plot groups of neurons cut from an <code>hclust</code>
object</h2><span id='topic+plot3d.hclust'></span>

<h3>Description</h3>

<p><code>plot3d.hclust</code> uses <code>plot3d</code> to plot neurons from
each group, cut from the <code>hclust</code> object, by colour.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hclust'
plot3d(
  x,
  k = NULL,
  h = NULL,
  groups = NULL,
  col = rainbow,
  colour.selected = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot3d.hclust_+3A_x">x</code></td>
<td>
<p>an <code><a href="stats.html#topic+hclust">hclust</a></code> object generated by <code><a href="#topic+nhclust">nhclust</a></code>.</p>
</td></tr>
<tr><td><code id="plot3d.hclust_+3A_k">k</code></td>
<td>
<p>number of clusters to cut from <code><a href="stats.html#topic+hclust">hclust</a></code> object.</p>
</td></tr>
<tr><td><code id="plot3d.hclust_+3A_h">h</code></td>
<td>
<p>height to cut <code><a href="stats.html#topic+hclust">hclust</a></code> object.</p>
</td></tr>
<tr><td><code id="plot3d.hclust_+3A_groups">groups</code></td>
<td>
<p>numeric vector of groups to plot.</p>
</td></tr>
<tr><td><code id="plot3d.hclust_+3A_col">col</code></td>
<td>
<p>colours for groups (directly specified or a function).</p>
</td></tr>
<tr><td><code id="plot3d.hclust_+3A_colour.selected">colour.selected</code></td>
<td>
<p>When set to <code>TRUE</code> the colour palette only
applies to the displayed cluster groups (default <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot3d.hclust_+3A_...">...</code></td>
<td>
<p>additional arguments for <code>plot3d</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the colours are in the order of the dendrogram as assigned
by <code>colour_clusters</code>.
</p>


<h3>Value</h3>

<p>A list of <code>rgl</code> IDs for plotted objects (see
<code><a href="rgl.html#topic+plot3d">plot3d</a></code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nhclust">nhclust</a>, <a href="rgl.html#topic+plot3d">plot3d</a>, <a href="dendroextras.html#topic+slice">slice</a>,
<a href="dendroextras.html#topic+colour_clusters">colour_clusters</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 20 Kenyon cells
data(kcs20, package='nat')
# calculate mean, normalised NBLAST scores
kcs20.aba=nblast_allbyall(kcs20)
kcs20.hc=nhclust(scoremat = kcs20.aba)
# plot the resultant dendrogram
plot(kcs20.hc)

# now plot the neurons in 3D coloured by cluster group
# note that specifying db explicitly could be avoided by use of the
# \code{nat.default.neuronlist} option.
plot3d(kcs20.hc, k=3, db=kcs20)

# only plot first two groups
# (will plot in same colours as when all groups are plotted)
plot3d(kcs20.hc, k=3, db=kcs20, groups=1:2)
# only plot first two groups
# (will be coloured with a two-tone palette)
plot3d(kcs20.hc, k=3, db=kcs20, groups=1:2, colour.selected=TRUE)
</code></pre>

<hr>
<h2 id='show_similarity'>Display two neurons with segments in the query coloured by similarity</h2><span id='topic+show_similarity'></span>

<h3>Description</h3>

<p>By default, the query neuron will be drawn with its segments shaded from red
to blue, with red indicating a poor match to the target segments, and blue a
good match.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_similarity(
  query,
  target,
  smat = NULL,
  cols = colorRampPalette(c("red", "yellow", "cyan", "navy")),
  col = "black",
  AbsoluteScale = FALSE,
  PlotVectors = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_similarity_+3A_query">query</code></td>
<td>
<p>a neuron to compare and colour.</p>
</td></tr>
<tr><td><code id="show_similarity_+3A_target">target</code></td>
<td>
<p>the neuron to compare against.</p>
</td></tr>
<tr><td><code id="show_similarity_+3A_smat">smat</code></td>
<td>
<p>a score matrix (if <code>NULL</code>, defaults to <code>smat.fcwb</code>).</p>
</td></tr>
<tr><td><code id="show_similarity_+3A_cols">cols</code></td>
<td>
<p>the function to use to colour the segments (e.g.
<code><a href="grDevices.html#topic+heat.colors">heat.colors</a></code>).</p>
</td></tr>
<tr><td><code id="show_similarity_+3A_col">col</code></td>
<td>
<p>the colour with which to draw the target neuron.</p>
</td></tr>
<tr><td><code id="show_similarity_+3A_absolutescale">AbsoluteScale</code></td>
<td>
<p>logical indicating whether the colours should be
calculated based on the minimum and maximum similarities for the neuron
(<code>AbsoluteScale = FALSE</code>) or on the minimum and maximum possible for
all neurons.</p>
</td></tr>
<tr><td><code id="show_similarity_+3A_plotvectors">PlotVectors</code></td>
<td>
<p>logical indicating whether the vectors of the
<code>dotprops</code> representation should be plotted. If <code>FALSE</code>, only the
points are plotted.</p>
</td></tr>
<tr><td><code id="show_similarity_+3A_...">...</code></td>
<td>
<p>extra arguments to pass to <code><a href="rgl.html#topic+plot3d">plot3d</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>show_similarity</code> is called for the side effect of drawing the
plot; a vector of object IDs is returned.
</p>


<h3>See Also</h3>

<p>The low level function <code><a href="#topic+WeightedNNBasedLinesetMatching">WeightedNNBasedLinesetMatching</a></code>
is used to retrieve the scores.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(nat)

# Pull out gamma and alpha-beta neurons
gamma_neurons &lt;- subset(kcs20, type=='gamma')
ab_neurons &lt;- subset(kcs20, type=='ab')

# Compare two alpha-beta neurons with similar branching, but dissimilar arborisation
clear3d()
show_similarity(ab_neurons[[1]], ab_neurons[[2]])

# Compare an alpha-beta and a gamma neuron with some similarities and differences
clear3d()
show_similarity(ab_neurons[[1]], gamma_neurons[[3]])

## End(Not run)
</code></pre>

<hr>
<h2 id='smat.fcwb'>Scoring matrices for neuron similarities in FCWB template brain</h2><span id='topic+smat.fcwb'></span><span id='topic+smat_alpha.fcwb'></span>

<h3>Description</h3>

<p>Scoring matrices quantify the log2 odds ratio that a segment pair with a
given distance and absolute dot product come from a pair of neurons of the
same type, rather than unrelated neurons.
</p>


<h3>Details</h3>

<p>These scoring matrices were generated using all by all pairs from 150 DL2
antennal lobe projection neurons from the FlyCircuit dataset and 5000 random
pairs from the same dataset.
</p>

<ul>
<li> <p><code>smat.fcwb</code> was trained using nearest-neighbour distance and the
tangent vector defined by the first eigen vector of the k=5 nearest
neighbours.
</p>
</li>
<li> <p><code>smat_alpha.fcwb</code> was defined as for <code>smat.fcwb</code> but weighted
by the factor <code>alpha</code> defined as (l1-l2)/(l1+l2+l3) where l1,l2,l3 are
the three eigen values.
</p>
</li></ul>

<p>Most work on the flycircuit dataset has been carried out using the
<code>smat.fcwb</code> scoring matrix although the <code>smat_alpha.fcwb</code> matrix
which emphasises the significance of matches between linear regions of the
neuron (such as axons) may have some advantages.
</p>

<hr>
<h2 id='sparse_score_mat'>Convert a subset of a square score matrix to a sparse representation</h2><span id='topic+sparse_score_mat'></span>

<h3>Description</h3>

<p>This can be useful for storing raw forwards and reverse NBLAST scores for a
set of neurons without having to store all the uncomputed elements in the
full score matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparse_score_mat(neuron_names, dense_matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparse_score_mat_+3A_neuron_names">neuron_names</code></td>
<td>
<p>a character vector of neuron names to save scores for.</p>
</td></tr>
<tr><td><code id="sparse_score_mat_+3A_dense_matrix">dense_matrix</code></td>
<td>
<p>the original, dense version of the full score matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A spare matrix, in compressed, column-oriented form, as an R object
inheriting from both <code><a href="Matrix.html#topic+CsparseMatrix-class">CsparseMatrix-class</a></code> and
<code><a href="Matrix.html#topic+generalMatrix-class">generalMatrix-class</a></code>.
</p>


<h3>See Also</h3>

<p>fill_in_sparse_score_mat
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(kcs20, package = "nat")
scores=nblast_allbyall(kcs20)
scores.3.sparse=sparse_score_mat(names(kcs20)[3], scores)
scores.3.sparse
# can also add additional submatrices
fill_in_sparse_score_mat(scores.3.sparse,scores[3:6,3:4])
</code></pre>

<hr>
<h2 id='sub_dist_mat'>Convert (a subset of) a raw score matrix to a distance matrix</h2><span id='topic+sub_dist_mat'></span>

<h3>Description</h3>

<p>This function can convert a raw score matrix returned by
<code>nblast</code> into a square distance matrix or <code>dist</code> object. It can
be used with file-backed matrices as well as regular R matrices resident in
memory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sub_dist_mat(
  neuron_names,
  scoremat = NULL,
  form = c("matrix", "dist"),
  maxneurons = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sub_dist_mat_+3A_neuron_names">neuron_names</code></td>
<td>
<p>character vector of neuron identifiers.</p>
</td></tr>
<tr><td><code id="sub_dist_mat_+3A_scoremat">scoremat</code></td>
<td>
<p>score matrix to use (see <code>sub_score_mat</code> for details of
default).</p>
</td></tr>
<tr><td><code id="sub_dist_mat_+3A_form">form</code></td>
<td>
<p>the type of object to return.</p>
</td></tr>
<tr><td><code id="sub_dist_mat_+3A_maxneurons">maxneurons</code></td>
<td>
<p>set this to a sensible value to avoid loading huge (order
N^2) distances directly into memory.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that if <code>neuron_names</code> is missing then the rownames of
<code>scoremat</code> will be used i.e. every neuron in <code>scoremat</code> will be
used.
</p>


<h3>Value</h3>

<p>return An object of class matrix or dist (as determined by the form
argument), corresponding to a subset of the distance matrix
</p>


<h3>See Also</h3>

<p>Other scoremats: 
<code><a href="#topic+nhclust">nhclust</a>()</code>
</p>

<hr>
<h2 id='sub_score_mat'>Return scores (or distances) for given query and target neurons</h2><span id='topic+sub_score_mat'></span>

<h3>Description</h3>

<p>Scores can either be returned as raw numbers, normalised such that a self-hit
has score 1, or as the average of the normalised scores in both the forwards
&amp; reverse directions (i.e. <code>|query-&gt;target| + |target-&gt;query| / 2</code>).
Distances are returned as either <code>1 - normscore</code> in the forwards
direction, or as <code>1 - normscorebar</code>, where <code>normscorebar</code> is
<code>normscore</code> averaged across both directions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sub_score_mat(
  query,
  target,
  scoremat = NULL,
  distance = FALSE,
  normalisation = c("raw", "normalised", "mean")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sub_score_mat_+3A_query">query</code>, <code id="sub_score_mat_+3A_target">target</code></td>
<td>
<p>character vectors of neuron identifiers.</p>
</td></tr>
<tr><td><code id="sub_score_mat_+3A_scoremat">scoremat</code></td>
<td>
<p>a matrix, ff matrix, <code>bigmatrix</code> or a character vector
specifying the name of an ff matrix containing the all by all score
matrix.</p>
</td></tr>
<tr><td><code id="sub_score_mat_+3A_distance">distance</code></td>
<td>
<p>logical indicating whether to return distances or scores.</p>
</td></tr>
<tr><td><code id="sub_score_mat_+3A_normalisation">normalisation</code></td>
<td>
<p>the type of normalisation procedure that should be
carried out, selected from  <code>'raw'</code>, <code>'normalised'</code> or
<code>'mean'</code> (i.e. the average of normalised scores in both directions).
If <code>distance=TRUE</code> then this cannot be raw.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+sub_dist_mat">sub_dist_mat</a></code>
</p>

<hr>
<h2 id='subset.hclust'>Return the labels of items in 1 or more groups cut from hclust object</h2><span id='topic+subset.hclust'></span>

<h3>Description</h3>

<p>Return the labels of items in 1 or more groups cut from hclust object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hclust'
subset(x, k = NULL, h = NULL, groups = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.hclust_+3A_x">x</code></td>
<td>
<p>tree like object</p>
</td></tr>
<tr><td><code id="subset.hclust_+3A_k">k</code></td>
<td>
<p>an integer scalar with the desired number of groups</p>
</td></tr>
<tr><td><code id="subset.hclust_+3A_h">h</code></td>
<td>
<p>numeric scalar with height where the tree should be cut</p>
</td></tr>
<tr><td><code id="subset.hclust_+3A_groups">groups</code></td>
<td>
<p>a vector of which groups to inspect.</p>
</td></tr>
<tr><td><code id="subset.hclust_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only one of <code>h</code> and <code>k</code> should be supplied.
</p>


<h3>Value</h3>

<p>A character vector of labels of selected items
</p>

<hr>
<h2 id='WeightedNNBasedLinesetMatching'>Compute point &amp; tangent vector similarity score between two linesets</h2><span id='topic+WeightedNNBasedLinesetMatching'></span><span id='topic+WeightedNNBasedLinesetMatching.dotprops'></span><span id='topic+WeightedNNBasedLinesetMatching.neuron'></span>

<h3>Description</h3>

<p><code>WeightedNNBasedLinesetMatching</code> is a low level function
that is called by <code><a href="#topic+nblast">nblast</a></code>. Most end users will not usually
need to call it directly. It does allow the results of an NBLAST comparison
to be inspected in further detail (see examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WeightedNNBasedLinesetMatching(target, query, ...)

## S3 method for class 'dotprops'
WeightedNNBasedLinesetMatching(target, query, UseAlpha = FALSE, ...)

## S3 method for class 'neuron'
WeightedNNBasedLinesetMatching(
  target,
  query,
  UseAlpha = FALSE,
  OnlyClosestPoints = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WeightedNNBasedLinesetMatching_+3A_target">target</code>, <code id="WeightedNNBasedLinesetMatching_+3A_query">query</code></td>
<td>
<p><code><a href="nat.html#topic+dotprops">dotprops</a></code> or <code><a href="nat.html#topic+neuron">neuron</a></code> objects to
compare (must be of the same class)</p>
</td></tr>
<tr><td><code id="WeightedNNBasedLinesetMatching_+3A_...">...</code></td>
<td>
<p>extra arguments to pass to the distance function.</p>
</td></tr>
<tr><td><code id="WeightedNNBasedLinesetMatching_+3A_usealpha">UseAlpha</code></td>
<td>
<p>Whether to scale dot product of tangent vectors (default=F)</p>
</td></tr>
<tr><td><code id="WeightedNNBasedLinesetMatching_+3A_onlyclosestpoints">OnlyClosestPoints</code></td>
<td>
<p>Whether to restrict searches to the closest points
in the target (default FALSE, only implemented for <code>dotprops</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>WeightedNNBasedLinesetMatching</code> will work with 2 objects of
class <code>dotprops</code> or <code>neuron</code>. The code to calculate scores
directly for <code>neuron</code> objects gives broadly comparable scores to that
for <code>dotprops</code> objects, but has been lightly tested. Furthermore only
objects in <code>dotprops</code> form were used in the construction of the
scoring matrices distributed in this package. It is therefore recommended
to convert <code>neuron</code> objects to <code>dotprops</code> objects using the
<code><a href="nat.html#topic+dotprops">dotprops</a></code> function.
</p>
<p><code>UseAlpha</code> determines whether the alpha values
<code>(eig1-eig2)/sum(eig1:3)</code> are passed on to
WeightedNNBasedLinesetMatching. These will be used to scale the dot
products of the direction vectors for nearest neighbour pairs.
</p>


<h3>Value</h3>

<p>Value of <code>NNDistFun</code> passed to
<code>WeightedNNBasedLinesetMatching</code>
</p>


<h3>See Also</h3>

<p><code><a href="nat.html#topic+dotprops">dotprops</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Retrieve per segment distances / absolute dot products
segvals=WeightedNNBasedLinesetMatching(kcs20[[1]], kcs20[[2]], NNDistFun=list)
names(segvals)=c("dist", "adotprod")
pairs(segvals)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
