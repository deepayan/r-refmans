<!DOCTYPE html><html><head><title>Help for package arules</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {arules}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#abbreviate'><p>Abbreviate item labels in transactions, itemMatrix and associations</p></a></li>
<li><a href='#addComplement'><p>Add Complement-items to Transactions</p></a></li>
<li><a href='#Adult'><p>Adult Data Set</p></a></li>
<li><a href='#affinity'><p>Computing Affinity Between Items</p></a></li>
<li><a href='#APappearance-class'><p>Class APappearance &mdash; Specifying the appearance Argument of Apriori to</p>
Implement Rule Templates</a></li>
<li><a href='#apriori'><p>Mining Associations with the Apriori Algorithm</p></a></li>
<li><a href='#AScontrol-classes'><p>Classes AScontrol, APcontrol, ECcontrol &mdash;</p>
Specifying the control Argument of Apriori and Eclat</a></li>
<li><a href='#ASparameter-classes'><p>Classes ASparameter, APparameter, ECparameter &mdash;</p>
Specifying the parameter Argument of APRIORI and ECLAT</a></li>
<li><a href='#associations-class'><p>Class associations &mdash; A Set of Associations</p></a></li>
<li><a href='#c'><p>Combining Association and Transaction Objects</p></a></li>
<li><a href='#confint'><p>Confidence Intervals for Interest Measures for Association Rules</p></a></li>
<li><a href='#coverage'><p>Calculate coverage for rules</p></a></li>
<li><a href='#crossTable'><p>Cross-tabulate joint occurrences across pairs of items</p></a></li>
<li><a href='#DATAFRAME'><p>Data.frame Representation for arules Objects</p></a></li>
<li><a href='#discretize'><p>Convert a Continuous Variable into a Categorical Variable</p></a></li>
<li><a href='#dissimilarity'><p>Dissimilarity Matrix Computation for Associations and Transactions</p></a></li>
<li><a href='#duplicated'><p>Find Duplicated Elements</p></a></li>
<li><a href='#eclat'><p>Mining Associations with Eclat</p></a></li>
<li><a href='#Epub'><p>The Epub Transactions Data Set</p></a></li>
<li><a href='#extract'><p>Methods for &quot;[&quot;: Extraction or Subsetting arules Objects</p></a></li>
<li><a href='#fim4r'><p>Interface to Mining Algorithms from fim4r</p></a></li>
<li><a href='#Groceries'><p>The Groceries Transactions Data Set</p></a></li>
<li><a href='#hierarchy'><p>Support for Item Hierarchies</p></a></li>
<li><a href='#hits'><p>Computing Transaction Weights With HITS</p></a></li>
<li><a href='#image'><p>Visual Inspection of Binary Incidence Matrices</p></a></li>
<li><a href='#Income'><p>The Income Data Set</p></a></li>
<li><a href='#inspect'><p>Display Associations and Transactions in Readable Form</p></a></li>
<li><a href='#interestMeasure'><p>Calculate Additional Interest Measures</p></a></li>
<li><a href='#is.closed'><p>Find Closed Itemsets</p></a></li>
<li><a href='#is.generator'><p>Find Generator Itemsets</p></a></li>
<li><a href='#is.maximal'><p>Find Maximal Itemsets</p></a></li>
<li><a href='#is.redundant'><p>Find Redundant Rules</p></a></li>
<li><a href='#is.significant'><p>Find Significant Rules</p></a></li>
<li><a href='#is.superset'><p>Find Super and Subsets</p></a></li>
<li><a href='#itemCoding'><p>Item Coding &mdash; Conversion between Item Labels and Column IDs</p></a></li>
<li><a href='#itemFrequency'><p>Getting Frequency/Support for Single Items</p></a></li>
<li><a href='#itemFrequencyPlot'><p>Creating a Item Frequencies/Support Bar Plot</p></a></li>
<li><a href='#itemMatrix-class'><p>Class itemMatrix &mdash; Sparse Binary Incidence Matrix to Represent Sets of</p>
Items</a></li>
<li><a href='#itemsets-class'><p>Class itemsets &mdash; A Set of Itemsets</p></a></li>
<li><a href='#itemwiseSetOps'><p>Itemwise Set Operations</p></a></li>
<li><a href='#LIST'><p>List Representation for Objects Based on Class itemMatrix</p></a></li>
<li><a href='#match'><p>Value Matching</p></a></li>
<li><a href='#merge'><p>Adding Items to Data</p></a></li>
<li><a href='#Mushroom'><p>The Mushroom Data Set as Transactions</p></a></li>
<li><a href='#pmml'><p>Read and Write PMML</p></a></li>
<li><a href='#predict'><p>Model Predictions</p></a></li>
<li><a href='#proximity-classes'><p>Classes dist, ar_cross_dissimilarity and ar_similarity &mdash; Proximity</p>
Matrices</a></li>
<li><a href='#random.transactions'><p>Simulate a Random Transactions</p></a></li>
<li><a href='#read'><p>Read Transaction Data</p></a></li>
<li><a href='#ruleInduction'><p>Association Rule Induction from Itemsets</p></a></li>
<li><a href='#rules-class'><p>Class rules &mdash; A Set of Rules</p></a></li>
<li><a href='#sample'><p>Random Samples and Permutations</p></a></li>
<li><a href='#sets'><p>Set Operations</p></a></li>
<li><a href='#size'><p>Number of Items in Sets</p></a></li>
<li><a href='#sort'><p>Sort Associations</p></a></li>
<li><a href='#subset'><p>Subsetting Itemsets, Rules and Transactions</p></a></li>
<li><a href='#SunBai'><p>The SunBai Weighted Transactions Data Set</p></a></li>
<li><a href='#support'><p>Support Counting for Itemsets</p></a></li>
<li><a href='#supportingTransactions'><p>Supporting Transactions</p></a></li>
<li><a href='#tidLists-class'><p>Class tidLists &mdash; Transaction ID Lists for Items/Itemsets</p></a></li>
<li><a href='#transactions-class'><p>Class transactions &mdash; Binary Incidence Matrix for Transactions</p></a></li>
<li><a href='#unique'><p>Remove Duplicated Elements from a Collection</p></a></li>
<li><a href='#weclat'><p>Mining Associations from Weighted Transaction Data with Eclat (WARM)</p></a></li>
<li><a href='#write'><p>Write Transactions or Associations to a File</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.7-7</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-28</td>
</tr>
<tr>
<td>Title:</td>
<td>Mining Association Rules and Frequent Itemsets</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides the infrastructure for representing, manipulating and analyzing 
  transaction data and patterns (frequent itemsets and association rules). 
  Also provides C implementations of the association mining algorithms Apriori and Eclat. 
  Hahsler, Gruen and Hornik (2005) &lt;<a href="https://doi.org/10.18637%2Fjss.v014.i15">doi:10.18637/jss.v014.i15</a>&gt;.</td>
</tr>
<tr>
<td>Classification/ACM:</td>
<td>G.4, H.2.8, I.5.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mhahsler/arules">https://github.com/mhahsler/arules</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mhahsler/arules/issues">https://github.com/mhahsler/arules/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0), Matrix (&ge; 1.4-0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, methods, generics, graphics, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>pmml, XML, proxy, arulesViz, arulesCBA, testthat</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Copyright:</td>
<td>The source code for Apriori and Eclat was obtained from
http://www.borgelt.net/ and is Copyright (C) 1996-2003
Christian Borgelt. All other code is Copyright (C) Michael
Hahsler, Christian Buchta, Bettina Gruen and Kurt Hornik.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Collate:</td>
<td>'AAADefs.R' 'Adult.R' 'itemMatrix.R' 'associations.R'
'transactions.R' 'tidLists.R' 'itemsets.R' 'rules.R'
'DATAFRAME.R' 'Epub.R' 'Groceries.R' 'Income.R' 'LIST.R'
'Matrix.R' 'Mushroom.R' 'SunBai.R' 'abbreviate.R'
'addComplement.R' 'appearance.R' 'apriori.R' 'c.R'
'check_installed.R' 'confint.R' 'control.R' 'coverage.R'
'crossTable.R' 'discretize.R' 'dissimilarity.R' 'duplicated.R'
'eclat.R' 'extract.R' 'fim4r.R' 'hierarchy.R' 'image.R'
'inspect.R' 'interestMeasures.R' 'is.closed.R' 'is.generator.R'
'is.maximal.R' 'is.redundant.R' 'is.significant.R'
'is.superset.R' 'itemCoding.R' 'itemFrequency.R' 'match.R'
'merge.R' 'parameter.R' 'plot.R' 'pmml.R' 'predict.R'
'random.transactions.R' 'read_write.R' 'ruleInduction.R'
'sample.R' 'sets.R' 'setsItemwise.R' 'size.R' 'sort.R'
'subset.R' 'support.R' 'supportingTransactions.R' 'unique.R'
'warm.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-28 20:44:05 UTC; hahsler</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Hahsler <a href="https://orcid.org/0000-0003-2716-1405"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Christian Buchta [aut, cph],
  Bettina Gruen [aut, cph],
  Kurt Hornik <a href="https://orcid.org/0000-0003-4198-9911"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cph],
  Christian Borgelt [ctb, cph],
  Ian Johnson [ctb],
  Makhlouf Ledmi [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Hahsler &lt;mhahsler@lyle.smu.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-29 09:00:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='abbreviate'>Abbreviate item labels in transactions, itemMatrix and associations</h2><span id='topic+abbreviate'></span><span id='topic+abbreviate+2CitemMatrix-method'></span><span id='topic+abbreviate+2Ctransactions-method'></span><span id='topic+abbreviate+2Crules-method'></span><span id='topic+abbreviate+2Citemsets-method'></span><span id='topic+abbreviate+2CtidLists-method'></span>

<h3>Description</h3>

<p>Provides the generic function and the methods to abbreviate long item labels
in transactions, associations (rules and itemsets) and transaction ID lists.
Note that <code>abbreviate()</code> is not a generic and this <span class="pkg">arules</span> defines a
generic with the <code><a href="base.html#topic+abbreviate">base::abbreviate()</a></code> as the default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abbreviate(names.arg, ...)

## S4 method for signature 'itemMatrix'
abbreviate(names.arg, minlength = 4, ..., method = "both.sides")

## S4 method for signature 'transactions'
abbreviate(names.arg, minlength = 4, ..., method = "both.sides")

## S4 method for signature 'rules'
abbreviate(names.arg, minlength = 4, ..., method = "both.sides")

## S4 method for signature 'itemsets'
abbreviate(names.arg, minlength = 4, ..., method = "both.sides")

## S4 method for signature 'tidLists'
abbreviate(names.arg, minlength = 4, ..., method = "both.sides")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abbreviate_+3A_names.arg">names.arg</code></td>
<td>
<p>an object of class <a href="#topic+transactions">transactions</a>, <a href="#topic+itemMatrix">itemMatrix</a>,
<a href="#topic+itemsets">itemsets</a>, <a href="#topic+rules">rules</a> or <a href="#topic+tidLists">tidLists</a>.</p>
</td></tr>
<tr><td><code id="abbreviate_+3A_...">...</code></td>
<td>
<p>further arguments passed on to the default abbreviation
function.</p>
</td></tr>
<tr><td><code id="abbreviate_+3A_minlength">minlength</code></td>
<td>
<p>number of characters allowed in abbreviation</p>
</td></tr>
<tr><td><code id="abbreviate_+3A_method">method</code></td>
<td>
<p>apply to level and value (both.sides)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sudheer Chelluboina and Michael Hahsler based on code by Martin
Vodenicharov.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+abbreviate">base::abbreviate()</a></code>
</p>
<p>Other associations functions: 
<code><a href="#topic+associations-class">associations-class</a></code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+duplicated">duplicated</a>()</code>,
<code><a href="#topic+extract">extract</a></code>,
<code><a href="#topic+inspect">inspect</a>()</code>,
<code><a href="#topic+is.closed">is.closed</a>()</code>,
<code><a href="#topic+is.generator">is.generator</a>()</code>,
<code><a href="#topic+is.maximal">is.maximal</a>()</code>,
<code><a href="#topic+is.redundant">is.redundant</a>()</code>,
<code><a href="#topic+is.significant">is.significant</a>()</code>,
<code><a href="#topic+is.superset">is.superset</a>()</code>,
<code><a href="#topic+itemsets-class">itemsets-class</a></code>,
<code><a href="#topic+match">match</a>()</code>,
<code><a href="#topic+rules-class">rules-class</a></code>,
<code><a href="#topic+sample">sample</a>()</code>,
<code><a href="#topic+sets">sets</a></code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+sort">sort</a>()</code>,
<code><a href="#topic+unique">unique</a>()</code>
</p>
<p>Other itemMatrix and transactions functions: 
<code><a href="#topic+crossTable">crossTable</a>()</code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+duplicated">duplicated</a>()</code>,
<code><a href="#topic+extract">extract</a></code>,
<code><a href="#topic+hierarchy">hierarchy</a></code>,
<code><a href="#topic+image">image</a>()</code>,
<code><a href="#topic+inspect">inspect</a>()</code>,
<code><a href="#topic+is.superset">is.superset</a>()</code>,
<code><a href="#topic+itemFrequencyPlot">itemFrequencyPlot</a>()</code>,
<code><a href="#topic+itemFrequency">itemFrequency</a>()</code>,
<code><a href="#topic+itemMatrix-class">itemMatrix-class</a></code>,
<code><a href="#topic+match">match</a>()</code>,
<code><a href="#topic+merge">merge</a>()</code>,
<code><a href="#topic+random.transactions">random.transactions</a>()</code>,
<code><a href="#topic+sample">sample</a>()</code>,
<code><a href="#topic+sets">sets</a></code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+supportingTransactions">supportingTransactions</a>()</code>,
<code><a href="#topic+tidLists-class">tidLists-class</a></code>,
<code><a href="#topic+transactions-class">transactions-class</a></code>,
<code><a href="#topic+unique">unique</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Adult)
inspect(head(Adult, 1))

Adult_abbr &lt;- abbreviate(Adult, 15)
inspect(head(Adult_abbr, 1))

</code></pre>

<hr>
<h2 id='addComplement'>Add Complement-items to Transactions</h2><span id='topic+addComplement'></span><span id='topic+addComplement+2Ctransactions-method'></span>

<h3>Description</h3>

<p>Provides the generic function <code>addComplement()</code> and a method for
<a href="#topic+transactions">transactions</a> to add complement items. That is,
it adds an artificial item to each transaction which does not contain the
original item. Such items are also called negative items (Antonie et al,
2014).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addComplement(x, labels, complementLabels = NULL)

## S4 method for signature 'transactions'
addComplement(x, labels, complementLabels = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addComplement_+3A_x">x</code></td>
<td>
<p>an object of class <a href="#topic+transactions">transactions</a>.</p>
</td></tr>
<tr><td><code id="addComplement_+3A_labels">labels</code></td>
<td>
<p>character strings; item labels for which complements should be
created.</p>
</td></tr>
<tr><td><code id="addComplement_+3A_complementlabels">complementLabels</code></td>
<td>
<p>character strings; labels for the artificial
complement-items. If omitted then the original label is prepended by &quot;!&quot; to
form the complement-item label.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <a href="#topic+transactions">transactions</a> with complement items
added.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>References</h3>

<p>Antonie L., Li J., Zaiane O. (2014) Negative Association Rules.
In: Aggarwal C., Han J. (eds) <em>Frequent Pattern Mining,</em> Springer
International Publishing, pp. 135-145.
<a href="https://doi.org/10.1007/978-3-319-07821-2_6">doi:10.1007/978-3-319-07821-2_6</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("Groceries")

## add a complement-items for "whole milk" and "other vegetables"
g2 &lt;- addComplement(Groceries, c("whole milk", "other vegetables"))
g2
tail(itemInfo(g2))
inspect(head(g2, 3))

## use a custom label for the complement-item
g3 &lt;- addComplement(g2, "coffee", complementLabels = "NO coffee")
inspect(head(g2, 3))

## add complements for all items (this is excessive for this dataset)
g4 &lt;- addComplement(Groceries, itemLabels(Groceries))
g4

## add complements for all items with a minimum support of 0.1
g5 &lt;- addComplement(Groceries, names(which(itemFrequency(Groceries) &gt;= 0.1)))
g5

</code></pre>

<hr>
<h2 id='Adult'>Adult Data Set</h2><span id='topic+Adult'></span><span id='topic+adult'></span><span id='topic+AdultUCI'></span>

<h3>Description</h3>

<p>The <code>AdultUCI</code> data set contains the questionnaire data of the
<em>Adult</em> database (originally called the <em>Census Income</em>
Database) formatted as a data.frame.  The <code>Adult</code> data set contains the
data already prepared and coerced to <a href="#topic+transactions">transactions</a> for
use with <span class="pkg">arules</span>.
</p>


<h3>Format</h3>

<p><code>Adult</code> is an object of class <a href="#topic+transactions">transactions</a>
with 48842 transactions
and 115 items. See below for details.
</p>
<p>The AdultUCI data set contains a data frame with 48842
observations on the following 15 variables.
</p>

<dl>
<dt>age</dt><dd><p>a numeric
vector.</p>
</dd> <dt>workclass</dt><dd><p>a factor with levels <code>Federal-gov</code>,
<code>Local-gov</code>, <code>Never-worked</code>, <code>Private</code>, <code>Self-emp-inc</code>,
<code>Self-emp-not-inc</code>, <code>State-gov</code>, and <code>Without-pay</code>.</p>
</dd>
<dt>education</dt><dd><p>an ordered factor with levels <code>Preschool</code> &lt;
<code style="white-space: pre;">&#8288;1st-4th&#8288;</code> &lt; <code style="white-space: pre;">&#8288;5th-6th&#8288;</code> &lt; <code style="white-space: pre;">&#8288;7th-8th&#8288;</code> &lt; <code style="white-space: pre;">&#8288;9th&#8288;</code> &lt; <code style="white-space: pre;">&#8288;10th&#8288;</code>
&lt; <code style="white-space: pre;">&#8288;11th&#8288;</code> &lt; <code style="white-space: pre;">&#8288;12th&#8288;</code> &lt; <code>HS-grad</code> &lt; <code>Prof-school</code> &lt;
<code>Assoc-acdm</code> &lt; <code>Assoc-voc</code> &lt; <code>Some-college</code> &lt;
<code>Bachelors</code> &lt; <code>Masters</code> &lt; <code>Doctorate</code>.</p>
</dd>
<dt>education-num</dt><dd><p>a numeric vector.</p>
</dd>
<dt>marital-status</dt><dd><p>a factor with
levels <code>Divorced</code>, <code>Married-AF-spouse</code>, <code>Married-civ-spouse</code>,
<code>Married-spouse-absent</code>, <code>Never-married</code>, <code>Separated</code>, and
<code>Widowed</code>.</p>
</dd> <dt>occupation</dt><dd><p>a factor with levels <code>Adm-clerical</code>,
<code>Armed-Forces</code>, <code>Craft-repair</code>, <code>Exec-managerial</code>,
<code>Farming-fishing</code>, <code>Handlers-cleaners</code>, <code>Machine-op-inspct</code>,
<code>Other-service</code>, <code>Priv-house-serv</code>, <code>Prof-specialty</code>,
<code>Protective-serv</code>, <code>Sales</code>, <code>Tech-support</code>, and
<code>Transport-moving</code>.</p>
</dd>
<dt>relationship</dt><dd><p>a factor with levels
<code>Husband</code>, <code style="white-space: pre;">&#8288;Not-in-family&#8288;</code>, <code>Other-relative</code>,
<code>Own-child</code>, <code>Unmarried</code>, and <code>Wife</code>.</p>
</dd>
<dt>race</dt><dd><p>a factor
with levels <code>Amer-Indian-Eskimo</code>, <code>Asian-Pac-Islander</code>,
<code>Black</code>, <code>Other</code>, and <code>White</code>.</p>
</dd>
<dt>sex</dt><dd><p>a factor with levels <code>Female</code> and <code>Male</code>.</p>
</dd>
<dt>capital-gain</dt><dd><p>a numeric vector.</p>
</dd>
<dt>capital-loss</dt><dd><p>a numeric vector.</p>
</dd> <dt>fnlwgt</dt><dd><p>a numeric vector.</p>
</dd>
<dt>hours-per-week</dt><dd><p>a numeric vector.</p>
</dd>
<dt>native-country</dt><dd><p>a factor with levels <code>Cambodia</code>, <code>Canada</code>, <code>China</code>,
<code>Columbia</code>, <code>Cuba</code>, <code>Dominican-Republic</code>, <code>Ecuador</code>,
<code>El-Salvador</code>, <code>England</code>, <code>France</code>, <code>Germany</code>,
<code>Greece</code>, <code>Guatemala</code>, <code>Haiti</code>, <code>Holand-Netherlands</code>,
<code>Honduras</code>, <code>Hong</code>, <code>Hungary</code>, <code>India</code>, <code>Iran</code>,
<code>Ireland</code>, <code>Italy</code>, <code>Jamaica</code>, <code>Japan</code>, <code>Laos</code>,
<code>Mexico</code>, <code>Nicaragua</code>, <code>Outlying-US(Guam-USVI-etc)</code>,
<code>Peru</code>, <code>Philippines</code>, <code>Poland</code>, <code>Portugal</code>,
<code>Puerto-Rico</code>, <code>Scotland</code>, <code>South</code>, <code>Taiwan</code>,
<code>Thailand</code>, <code>Trinadad&amp;Tobago</code>, <code>United-States</code>,
<code>Vietnam</code>, and <code>Yugoslavia</code>.</p>
</dd>
<dt>income</dt><dd><p>an ordered factor with
levels <code>small</code> &lt; <code>large</code>.</p>
</dd> </dl>



<h3>Details</h3>

<p>The Adult database was extracted from the census bureau database
found at <a href="https://www.census.gov/">https://www.census.gov/</a> in 1994 by Ronny Kohavi and Barry
Becker (Data Mining and Visualization, Silicon Graphics). It was originally
used to predict whether income exceeds USD 50K/yr based on census data. We
added the attribute <code>income</code> with levels <code>small</code> and <code>large</code>
(&gt;50K).
</p>
<p>We prepared the data set for association mining as shown in the section
Examples. We removed the continuous attribute <code>fnlwgt</code> (final weight).
We also eliminated <code>education-num</code> because it is just a numeric
representation of the attribute <code>education</code>.  The other 4 continuous
attributes we mapped to ordinal attributes as follows:
</p>

<ul>
<li><p> age: cut into levels <code>Young</code> (0-25), <code>Middle-aged</code> (26-45),
<code>Senior</code> (46-65) and <code>Old</code> (66+)
</p>
</li>
<li><p> hours-per-week: cut into levels <code>Part-time</code> (0-25),
<code>Full-time</code> (25-40), <code>Over-time</code>
(40-60) and <code>Too-much</code> (60+)
</p>
</li>
<li><p> capital-gain and capital-loss: each cut into levels <code>None</code> (0),
<code>Low</code> (0 &lt; median of the values greater zero &lt; max) and <code>High</code>
(&gt;=max)
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>Source</h3>

<p><a href="https://archive.ics.uci.edu/">https://archive.ics.uci.edu/</a>
</p>


<h3>References</h3>

<p>A. Asuncion &amp; D. J. Newman (2007): UCI Repository of Machine
Learning Databases.  Irvine, CA: University of California, Department of
Information and Computer Science.
</p>
<p>The data set was first cited in Kohavi, R. (1996): Scaling Up the Accuracy
of Naive-Bayes Classifiers: a Decision-Tree Hybrid.  <em>Proceedings of
the Second International Conference on Knowledge Discovery and Data Mining</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("AdultUCI")
dim(AdultUCI)
AdultUCI[1:2, ]

## remove attributes
AdultUCI[["fnlwgt"]] &lt;- NULL
AdultUCI[["education-num"]] &lt;- NULL

## map metric attributes
AdultUCI[["age"]] &lt;- ordered(cut(AdultUCI[["age"]], c(15, 25, 45, 65, 100)),
  labels = c("Young", "Middle-aged", "Senior", "Old"))

AdultUCI[["hours-per-week"]] &lt;- ordered(cut(AdultUCI[["hours-per-week"]],
  c(0,25,40,60,168)),
  labels = c("Part-time", "Full-time", "Over-time", "Workaholic"))

AdultUCI[["capital-gain"]] &lt;- ordered(cut(AdultUCI[["capital-gain"]],
  c(-Inf,0,median(AdultUCI[["capital-gain"]][AdultUCI[["capital-gain"]] &gt; 0]),
  Inf)), labels = c("None", "Low", "High"))

AdultUCI[["capital-loss"]] &lt;- ordered(cut(AdultUCI[["capital-loss"]],
  c(-Inf,0, median(AdultUCI[["capital-loss"]][AdultUCI[["capital-loss"]] &gt; 0]),
  Inf)), labels = c("None", "Low", "High"))

## create transactions
Adult &lt;- transactions(AdultUCI)
Adult

</code></pre>

<hr>
<h2 id='affinity'>Computing Affinity Between Items</h2><span id='topic+affinity'></span><span id='topic+affinity+2Cmatrix-method'></span><span id='topic+affinity+2CitemMatrix-method'></span>

<h3>Description</h3>

<p>Provides the generic function <code>affinity()</code> and methods to compute
and return a similarity matrix with the affinities between items for a set
itemsets stored in a matrix or in <a href="#topic+transactions">transactions</a> via its superclass <a href="#topic+itemMatrix">itemMatrix</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>affinity(x)

## S4 method for signature 'matrix'
affinity(x)

## S4 method for signature 'itemMatrix'
affinity(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="affinity_+3A_x">x</code></td>
<td>
<p>a matrix or an object of class <a href="#topic+itemMatrix">itemMatrix</a> or
<a href="#topic+transactions">transactions</a> containing itemsets.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Affinity between the two items <code class="reqn">i</code> and <code class="reqn">j</code> is defined by Aggarwal et
al. (2002) as </p>
<p style="text-align: center;"><code class="reqn">A(i,j) = \frac{supp(\{i,j\})}{supp(\{i\}) + supp(\{j\}) -
supp(\{i,j\})},</code>
</p>

<p>where <code class="reqn">supp(.)</code> is the support measure. Note that affinity is equivalent to the
Jaccard similarity between items.
</p>


<h3>Value</h3>

<p>returns an object of class <a href="#topic+ar_similarity-class">ar_similarity</a> which represents the
affinities between items in <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>References</h3>

<p>Charu C. Aggarwal, Cecilia Procopiuc, and Philip S. Yu (2002)
Finding localized associations in market basket data, <em>IEEE Trans. on
Knowledge and Data Engineering,</em> 14(1):51&ndash;62.
</p>


<h3>See Also</h3>

<p>Other proximity classes and functions: 
<code><a href="#topic+dissimilarity">dissimilarity</a>()</code>,
<code><a href="#topic+predict">predict</a>()</code>,
<code><a href="#topic+proximity-classes">proximity-classes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Adult")

## choose a sample, calculate affinities
s &lt;- sample(Adult, 500)
s

a &lt;- affinity(s)
image(a)
</code></pre>

<hr>
<h2 id='APappearance-class'>Class APappearance &mdash; Specifying the appearance Argument of Apriori to
Implement Rule Templates</h2><span id='topic+APappearance-class'></span><span id='topic+APappearance'></span><span id='topic+coercion-APappearance'></span><span id='topic+coerce+2CNULL+2CAPappearance-method'></span><span id='topic+coerce+2Clist+2CAPappearance-method'></span>

<h3>Description</h3>

<p>Specifies the restrictions on the associations mined by
<code><a href="#topic+apriori">apriori()</a></code>. These restrictions can implement certain aspects of
rule templates described by Klemettinen (1994).
</p>


<h3>Details</h3>

<p>Note that appearance is only supported by the implementation of
<code><a href="#topic+apriori">apriori()</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>labels</code></dt><dd><p>character vectors giving the labels of the
items which can appear in the specified place (rhs, lhs or both for rules
and items for itemsets).  none specifies, that the items mentioned there
cannot appear anywhere in the rule/itemset. Note that items cannot be
specified in more than one place (i.e., you cannot specify an item in lhs
and rhs, but have to specify it as both).</p>
</dd>
<dt><code>default</code></dt><dd><p>one of
<code>"both"</code>, <code>"lhs"</code>, <code>"rhs"</code>, <code>"none"</code>.  Specified the
default appearance for all items not explicitly mentioned in the other
elements of the list.  Leave unspecified and the code will guess the correct
setting.</p>
</dd>
<dt><code>set</code></dt><dd><p>used internally.</p>
</dd>
<dt><code>items</code></dt><dd><p>used internally.</p>
</dd>
</dl>


<h3>Objects from the Class</h3>

<p>If appearance restrictions are used, an
appearance object will be created automatically within the
<code><a href="#topic+apriori">apriori()</a></code> function using the information in the named list of
the function's <code>appearance</code> argument.  In this case, the item labels
used in the list will be automatically matched against the items in the used
<a href="#topic+transactions">transactions</a>.
</p>
<p>Objects can also be created by calls of the form <code>new("APappearance", ...)</code>.  In this case, item IDs (column numbers of the transactions incidence
matrix) have to be used instead of labels.
</p>


<h3>Coercions</h3>


<ul>
<li> <p><code>as("NULL", "APappearance")</code>
</p>
</li>
<li> <p><code>as("list", "APappearance")</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Michael Hahsler and Bettina Gruen
</p>


<h3>References</h3>

<p>Christian Borgelt (2004) <em>Apriori &mdash; Finding Association
Rules/Hyperedges with the Apriori Algorithm.</em>
<a href="https://borgelt.net/apriori.html">https://borgelt.net/apriori.html</a>
</p>
<p>M. Klemettinen, H. Mannila, P. Ronkainen, H. Toivonen and A. I. Verkamo
(1994).  Finding Interesting Rules from Large Sets of Discovered Association
Rules.  In <em>Proceedings of the Third International Conference on
Information and Knowledge Management,</em> 401&ndash;407.
</p>


<h3>See Also</h3>

<p>Other mining algorithms: 
<code><a href="#topic+AScontrol-classes">AScontrol-classes</a></code>,
<code><a href="#topic+ASparameter-classes">ASparameter-classes</a></code>,
<code><a href="#topic+apriori">apriori</a>()</code>,
<code><a href="#topic+eclat">eclat</a>()</code>,
<code><a href="#topic+fim4r">fim4r</a>()</code>,
<code><a href="#topic+ruleInduction">ruleInduction</a>()</code>,
<code><a href="#topic+weclat">weclat</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Adult")

## find only frequent itemsets which do not contain small or large income
is &lt;- apriori(Adult, parameter = list(support= 0.1, target="frequent"),
  appearance = list(none = c("income=small", "income=large")))
itemFrequency(items(is))["income=small"]
itemFrequency(items(is))["income=large"]

## find itemsets that only contain small or large income, or young age
is &lt;- apriori(Adult, parameter = list(support= 0.1, target="frequent"),
  appearance = list(items = c("income=small", "income=large", "age=Young")))
inspect(head(is))

## find only rules with income-related variables in the right-hand-side.
incomeItems &lt;- grep("^income=", itemLabels(Adult), value = TRUE)
incomeItems
rules &lt;- apriori(Adult, parameter = list(support=0.2, confidence = 0.5),
  appearance = list(rhs = incomeItems))
inspect(head(rules))

## Note: For more complicated restrictions you have to mine all rules/itemsets and
## then filter the results afterwards.
</code></pre>

<hr>
<h2 id='apriori'>Mining Associations with the Apriori Algorithm</h2><span id='topic+apriori'></span><span id='topic+APRIORI'></span><span id='topic+Apriori'></span>

<h3>Description</h3>

<p>Mine frequent itemsets, association rules or association hyperedges using
the Apriori algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apriori(data, parameter = NULL, appearance = NULL, control = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apriori_+3A_data">data</code></td>
<td>
<p>object of class <a href="#topic+transactions">transactions</a>. Any data
structure which can be coerced into transactions (e.g.,
a binary matrix, a data.frame or a tibble) can also be specified and will be
internally coerced to transactions.</p>
</td></tr>
<tr><td><code id="apriori_+3A_parameter">parameter</code></td>
<td>
<p>object of class <a href="#topic+APparameter">APparameter</a> or named
list.  The default behavior is to mine rules with minimum support of 0.1,
minimum confidence of 0.8, maximum of 10 items (maxlen), and a maximal time
for subset checking of 5 seconds (<code>maxtime</code>).</p>
</td></tr>
<tr><td><code id="apriori_+3A_appearance">appearance</code></td>
<td>
<p>object of class <a href="#topic+APappearance">APappearance</a> or named
list.  With this argument item appearance can be restricted (implements rule
templates).  By default all items can appear unrestricted.</p>
</td></tr>
<tr><td><code id="apriori_+3A_control">control</code></td>
<td>
<p>object of class <a href="#topic+APcontrol">APcontrol</a> or named list.
Controls the algorithmic performance of the mining algorithm (item sorting,
report progress (verbose), etc.)</p>
</td></tr>
<tr><td><code id="apriori_+3A_...">...</code></td>
<td>
<p>Additional arguments are for convenience added to the parameter list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Apriori algorithm (Agrawal et al, 1993) employs level-wise search for
frequent itemsets. The used C implementation of Apriori by Christian
Borgelt (2003) includes some improvements (e.g., a prefix tree and item sorting).
</p>
<p><strong>Warning about automatic conversion of matrices or data.frames to transactions.</strong>
It is preferred to create transactions manually before
calling <code>apriori()</code> to have control over item coding. This is especially
important when you are working with multiple datasets or several subsets of
the same dataset. To read about item coding, see <a href="#topic+itemCoding">itemCoding</a>.
</p>
<p>If a data.frame is specified as <code>x</code>, then the data is automatically
converted into transactions by discretizing numeric data using
<code><a href="#topic+discretizeDF">discretizeDF()</a></code> and then coercion to transactions. The discretization
may fail if the data is not well behaved.
</p>
<p><strong>Apriori only creates rules with one item in the RHS (Consequent).</strong>
The default value in <a href="#topic+APparameter">APparameter</a> for <code>minlen</code> is 1.
This meains that rules with only one item (i.e., an empty antecedent/LHS)
like
</p>
<p style="text-align: center;"><code class="reqn">\{\} =&gt; \{beer\}</code>
</p>

<p>will be created.  These rules mean that no matter what other items are
involved, the item in the RHS will appear with the probability given by the
rule's confidence (which equals the support).  If you want to avoid these
rules then use the argument <code>parameter = list(minlen = 2)</code>.
</p>
<p><strong>Notes on run time and memory usage:</strong>
If the minimum <code>support</code> is
chosen too low for the dataset, then the algorithm will try to create an
extremely large set of itemsets/rules. This will result in very long run
time and eventually the process will run out of memory.  To prevent this,
the default maximal length of itemsets/rules is restricted to 10 items (via
the parameter element <code>maxlen = 10</code>) and the time for checking subsets is
limited to 5 seconds (via <code>maxtime = 5</code>). The output will show if you hit
these limits in the &quot;checking subsets&quot; line of the output. The time limit is
only checked when the subset size increases, so it may run significantly
longer than what you specify in maxtime.  Setting <code>maxtime = 0</code> disables
the time limit.
</p>
<p>Interrupting execution with <code>Control-C/Esc</code> is not recommended.  Memory
cleanup will be prevented resulting in a memory leak. Also, interrupts are
only checked when the subset size increases, so it may take some time till
the execution actually stops.
</p>


<h3>Value</h3>

<p>Returns an object of class <a href="#topic+rules">rules</a> or
<a href="#topic+itemsets">itemsets</a>.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler and Bettina Gruen
</p>


<h3>References</h3>

<p>R. Agrawal, T. Imielinski, and A. Swami (1993) Mining
association rules between sets of items in large databases. In
<em>Proceedings of the ACM SIGMOD International Conference on Management
of Data</em>, pages 207&ndash;216, Washington D.C.
<a href="https://doi.org/10.1145/170035.170072">doi:10.1145/170035.170072</a>
</p>
<p>Christian Borgelt (2012) Frequent Item Set Mining.  <em>Wiley
Interdisciplinary Reviews: Data Mining and Knowledge Discovery</em>
2(6):437-456. J. Wiley &amp; Sons, Chichester, United Kingdom 2012.
<a href="https://doi.org/10.1002/widm.1074">doi:10.1002/widm.1074</a>
</p>
<p>Christian Borgelt and Rudolf Kruse (2002) Induction of Association Rules:
Apriori Implementation. <em>15th Conference on Computational Statistics</em>
(COMPSTAT 2002, Berlin, Germany) Physica Verlag, Heidelberg, Germany.
</p>
<p>Christian Borgelt (2003) Efficient Implementations of Apriori and Eclat.
<em>Workshop of Frequent Item Set Mining Implementations</em> (FIMI 2003,
Melbourne, FL, USA).
</p>
<p>APRIORI Implementation: <a href="https://borgelt.net/apriori.html">https://borgelt.net/apriori.html</a>
</p>


<h3>See Also</h3>

<p>Other mining algorithms: 
<code><a href="#topic+APappearance-class">APappearance-class</a></code>,
<code><a href="#topic+AScontrol-classes">AScontrol-classes</a></code>,
<code><a href="#topic+ASparameter-classes">ASparameter-classes</a></code>,
<code><a href="#topic+eclat">eclat</a>()</code>,
<code><a href="#topic+fim4r">fim4r</a>()</code>,
<code><a href="#topic+ruleInduction">ruleInduction</a>()</code>,
<code><a href="#topic+weclat">weclat</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example 1: Create transaction data and mine association rules
a_list &lt;- list(
      c("a","b","c"),
      c("a","b"),
      c("a","b","d"),
      c("c","e"),
      c("a","b","d","e")
      )

## Set transaction names
names(a_list) &lt;- paste("Tr",c(1:5), sep = "")
a_list

## Use the constructor to create transactions
trans1 &lt;- transactions(a_list)
trans1

rules &lt;- apriori(trans1)
inspect(rules)

## Example 2: Mine association rules from an existing transactions dataset
##   using different minimum support and minimum confidence thresholds
data("Adult")

rules &lt;- apriori(Adult,
	parameter = list(supp = 0.5, conf = 0.9, target = "rules"))
summary(rules)

# since ... gets automatically added to parameter, we can also write the 
#  same call shorter:
apriori(Adult, supp = 0.5, conf = 0.9, target = "rules")
</code></pre>

<hr>
<h2 id='AScontrol-classes'>Classes AScontrol, APcontrol, ECcontrol &mdash;
Specifying the control Argument of Apriori and Eclat</h2><span id='topic+AScontrol-classes'></span><span id='topic+AScontrol'></span><span id='topic+AScontrol-class'></span><span id='topic+control'></span><span id='topic+initialize+2CAScontrol-method'></span><span id='topic+show+2CAScontrol-method'></span><span id='topic+APcontrol-class'></span><span id='topic+APcontrol'></span><span id='topic+ECcontrol-class'></span><span id='topic+ECcontrol'></span><span id='topic+coerce-AScontrol'></span><span id='topic+coerce+2CNULL+2CAPcontrol-method'></span><span id='topic+coerce+2Clist+2CAPcontrol-method'></span><span id='topic+coerce+2CNULL+2CECcontrol-method'></span><span id='topic+coerce+2Clist+2CECcontrol-method'></span>

<h3>Description</h3>

<p>The <code>AScontrol</code> class holds the algorithmic parameters for the used
mining algorithms.  <code>APcontrol</code> and <code>ECcontrol</code> directly extend
<code>AScontrol</code> with additional slots for parameters only suitable for the
algorithms Apriori (<code>APcontrol</code>) and Eclat (<code>ECcontrol</code>).
</p>


<h3>Slots</h3>


<dl>
<dt><code>sort</code></dt><dd><p>an integer scalar indicating how to
sort items with respect to their frequency: (default: 2)
</p>

<ul>
<li><p> 1: ascending
</p>
</li>
<li><p> -1: descending
</p>
</li>
<li><p> 0: do not sort
</p>
</li>
<li><p> 2: ascending
</p>
</li>
<li><p> -2: descending with respect to transaction size sum
</p>
</li></ul>
</dd>
<dt><code>verbose</code></dt><dd><p>a logical indicating whether to report progress</p>
</dd>
<dt><code>filter</code></dt><dd><p>a numeric scalar indicating how to
filter unused items from transactions (default: 0.1)
</p>

<ul>
<li> <p><code class="reqn">=0</code>: do not filter items with respect to. usage in sets
</p>
</li>
<li> <p><code class="reqn">&lt;0</code>: fraction of removed items for filtering
</p>
</li>
<li> <p><code class="reqn">&gt;0</code>: take execution times ratio into account
</p>
</li></ul>
</dd>
<dt><code>tree</code></dt><dd><p>a logical indicating whether to
organize transactions as a prefix tree (default: <code>TRUE</code>)</p>
</dd>
<dt><code>heap</code></dt><dd><p>a logical indicating whether to
use heapsort instead of quicksort to sort the transactions
(default: <code>TRUE</code>)</p>
</dd>
<dt><code>memopt</code></dt><dd><p>a logical indicating whether to
minimize memory usage instead of maximize speed (default: <code>FALSE</code>)</p>
</dd>
<dt><code>load</code></dt><dd><p>a logical indicating whether to
load transactions into memory (default: <code>TRUE</code>)</p>
</dd>
<dt><code>sparse</code></dt><dd><p>a numeric value for the
threshold for sparse representation (default: 7)</p>
</dd>
</dl>


<h3>Available Slots by Subclass</h3>


<ul>
<li> <p><code>APcontrol</code>:
<code>filter</code>, <code>tree</code>, <code>heap</code>, <code>memopt</code>, <code>load</code>, <code>sort</code>, <code>verbose</code>
</p>
</li>
<li> <p><code>ECcontrol</code>:
<code>sparse</code>, <code>sort</code>, <code>verbose</code>
</p>
</li></ul>



<h3>Objects from the Class</h3>

<p>A suitable default control object will be
automatically created by the <code><a href="#topic+apriori">apriori()</a></code> or the
<code><a href="#topic+eclat">eclat()</a></code> function. By specifying a named list (names equal to
slots) as the <code>control</code> argument for <code><a href="#topic+apriori">apriori()</a></code> or
<code><a href="#topic+eclat">eclat()</a></code>, default values can be replaced with the values
in the list.
</p>
<p>Objects can also be created via coercion.
</p>


<h3>Coercions</h3>


<ul>
<li> <p><code>as("NULL", "APcontrol")</code>
</p>
</li>
<li> <p><code>as("list", "APcontrol")</code>
</p>
</li>
<li> <p><code>as("NULL", "ECcontrol")</code>
</p>
</li>
<li> <p><code>as("list", "ECcontrol")</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Michael Hahsler and Bettina Gruen
</p>


<h3>References</h3>

<p>Christian Borgelt (2004) <em>Apriori &mdash; Finding Association
Rules/Hyperedges with the Apriori Algorithm</em>.
<a href="https://borgelt.net/apriori.html">https://borgelt.net/apriori.html</a>
</p>


<h3>See Also</h3>

<p>Other mining algorithms: 
<code><a href="#topic+APappearance-class">APappearance-class</a></code>,
<code><a href="#topic+ASparameter-classes">ASparameter-classes</a></code>,
<code><a href="#topic+apriori">apriori</a>()</code>,
<code><a href="#topic+eclat">eclat</a>()</code>,
<code><a href="#topic+fim4r">fim4r</a>()</code>,
<code><a href="#topic+ruleInduction">ruleInduction</a>()</code>,
<code><a href="#topic+weclat">weclat</a>()</code>
</p>

<hr>
<h2 id='ASparameter-classes'>Classes ASparameter, APparameter, ECparameter &mdash;
Specifying the parameter Argument of APRIORI and ECLAT</h2><span id='topic+ASparameter-classes'></span><span id='topic+parameter'></span><span id='topic+initialize+2CASparameter-method'></span><span id='topic+show+2CASparameter-method'></span><span id='topic+ASparameter-class'></span><span id='topic+ASparameter'></span><span id='topic+APparameter-class'></span><span id='topic+APparameter'></span><span id='topic+initialize+2CAPparameter-method'></span><span id='topic+ECparameter-class'></span><span id='topic+ECparameter'></span><span id='topic+initialize+2CECparameter-method'></span><span id='topic+coercion'></span><span id='topic+coerce+2CNULL+2CAPparameter-method'></span><span id='topic+coerce+2Clist+2CAPparameter-method'></span><span id='topic+coerce+2CNULL+2CECparameter-method'></span><span id='topic+coerce+2Clist+2CECparameter-method'></span>

<h3>Description</h3>

<p>The <code>ASparameter</code> class holds the mining parameters (e.g., minimum
support) for the used mining algorithms.  <code>APparameter</code> and
<code>ECparameter</code> directly extend <code>ASparameter</code> with additional slots
for parameters only suitable for <code><a href="#topic+apriori">apriori()</a></code> (<code>APparameter</code>) or <code><a href="#topic+eclat">eclat()</a></code>
(<code>ECparameter</code>).
</p>


<h3>Slots</h3>


<dl>
<dt><code>support</code></dt><dd><p>a numeric value for the
minimal support of an item set (default: <code class="reqn">0.1</code>)</p>
</dd>
<dt><code>minlen</code></dt><dd><p>an integer value for the
minimal number of items per item set (default: 1 item)</p>
</dd>
<dt><code>maxlen</code></dt><dd><p>an integer value for the
maximal number of items per item set (default: 10 items)</p>
</dd>
<dt><code>target</code></dt><dd><p>a character string indicating the type of association mined.
Partial names are matched. Available targets are:
</p>

<ul>
<li> <p><code>"frequent itemsets"</code>
</p>
</li>
<li> <p><code>"maximally frequent itemsets"</code>
</p>
</li>
<li> <p><code>"generator frequent itemsets"</code>
</p>
</li>
<li> <p><code>"closed frequent itemsets"</code>
</p>
</li>
<li> <p><code>"rules"</code> only available for <a href="#topic+apriori">apriori</a>;
use <a href="#topic+ruleInduction">ruleInduction</a> for <a href="#topic+eclat">eclat</a>.
</p>
</li>
<li> <p><code>"hyperedgesets"</code> only available for <a href="#topic+apriori">apriori</a>;
see references for the definition of association hyperedgesets.
</p>
</li></ul>
</dd>
<dt><code>ext</code></dt><dd><p>a logical indicating whether to report coverage (i.e., LHS-support)
as an extended quality measure (default: <code>TRUE</code>)</p>
</dd>
<dt><code>confidence</code></dt><dd><p>a numeric value for the
minimal confidence of rules/association hyperedges (default:
<code class="reqn">0.8</code>). For frequent itemsets it is set to <code>NA</code>.</p>
</dd>
<dt><code>smax</code></dt><dd><p>a numeric value for the
maximal support of itemsets/rules/hyperedgesets (default: 1)</p>
</dd>
<dt><code>arem</code></dt><dd><p>a character string indicating the used additional rule
evaluation measure (default: <code>"none"</code>) given by one of
</p>

<ul>
<li> <p><code>"none"</code>: no additional evaluation measure
</p>
</li>
<li> <p><code>"diff"</code>: absolute confidence difference
</p>
</li>
<li> <p><code>"quot"</code>: difference of confidence quotient to 1
</p>
</li>
<li> <p><code>"aimp"</code>: absolute difference of improvement to 1
</p>
</li>
<li> <p><code>"info"</code>: information difference to prior
</p>
</li>
<li> <p><code>"chi2"</code>: normalized <code class="reqn">\chi^2</code> measure
</p>
</li></ul>

<p><strong>Note:</strong> The measure is only reported if <code>aval</code> is set to <code>TRUE</code>.
Use <code>minval</code> to set minimum thresholds on the measures.</p>
</dd>
<dt><code>aval</code></dt><dd><p>a logical indicating whether to
return the additional rule evaluation measure selected with <code>arem</code>.</p>
</dd>
<dt><code>minval</code></dt><dd><p>a numeric value for the minimal value of additional
evaluation measure selected with <code>arem</code> (default: <code class="reqn">0.1</code>)</p>
</dd>
<dt><code>originalSupport</code></dt><dd><p>a logical indicating whether to
use the original definition of minimum support
(support of the LHS and RHS of the rule). If set to <code>FALSE</code>
then the support of the LHS (also called coverage of the rule) is returned as support.
The minimum support threshold is applied to this support. (default: <code>TRUE</code>)</p>
</dd>
<dt><code>maxtime</code></dt><dd><p>Time limit in seconds for checking subsets.
<code>maxtime = 0</code> disables the time limit. (default: 5 seconds)</p>
</dd>
<dt><code>tidLists</code></dt><dd><p>a logical indicating whether <code><a href="#topic+eclat">eclat()</a></code> should
return also a list of supporting transactions IDs.
(default: <code>FALSE</code>)</p>
</dd>
</dl>


<h3>Available Slots by Subclass</h3>


<ul>
<li> <p><code>APparameter</code>:
<code>confidence</code>, <code>minval</code>, <code>smax</code>, <code>arem</code>, <code>aval</code>, <code>originalSupport</code>, <code>maxtime</code>, <code>support</code>, <code>minlen</code>, <code>maxlen</code>, <code>target</code>, <code>ext</code>
</p>
</li>
<li> <p><code>ECparameter</code>:
<code>tidLists</code>, <code>support</code>, <code>minlen</code>, <code>maxlen</code>, <code>target</code>, <code>ext</code>
</p>
</li></ul>



<h3>Objects from the Class</h3>

<p>A suitable default parameter object will be
automatically created by <code><a href="#topic+apriori">apriori()</a></code> or
<code><a href="#topic+eclat">eclat()</a></code>.  By specifying a named list (names equal to
slots) as <code>parameter</code> argument for <code><a href="#topic+apriori">apriori()</a></code> or
<code><a href="#topic+eclat">eclat()</a></code>, the default values can be replaced with the values
in the list.
</p>
<p>Objects can also be created via coercion.
</p>


<h3>Coercions</h3>


<ul>
<li> <p><code>as("NULL", "APparameter")</code>
</p>
</li>
<li> <p><code>as("list", "APparameter")</code>
</p>
</li>
<li> <p><code>as("NULL", "ECparameter")</code>
</p>
</li>
<li> <p><code>as("list", "ECparameter")</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Michael Hahsler and Bettina Gruen
</p>


<h3>References</h3>

<p>Christian Borgelt (2004) <em>Apriori &mdash; Finding Association
Rules/Hyperedges with the Apriori Algorithm</em>.
<a href="https://borgelt.net/apriori.html">https://borgelt.net/apriori.html</a>
</p>


<h3>See Also</h3>

<p>Other mining algorithms: 
<code><a href="#topic+APappearance-class">APappearance-class</a></code>,
<code><a href="#topic+AScontrol-classes">AScontrol-classes</a></code>,
<code><a href="#topic+apriori">apriori</a>()</code>,
<code><a href="#topic+eclat">eclat</a>()</code>,
<code><a href="#topic+fim4r">fim4r</a>()</code>,
<code><a href="#topic+ruleInduction">ruleInduction</a>()</code>,
<code><a href="#topic+weclat">weclat</a>()</code>
</p>

<hr>
<h2 id='associations-class'>Class associations &mdash; A Set of Associations</h2><span id='topic+associations-class'></span><span id='topic+associations'></span><span id='topic+initialize+2Cassociations-method'></span><span id='topic+show+2Cassociations-method'></span><span id='topic+t+2Cassociations-method'></span><span id='topic+summary.associations-class'></span><span id='topic+quality+2Cassociations-method'></span><span id='topic+quality'></span><span id='topic+quality+3C-+2Cassociations-method'></span><span id='topic+quality+3C-'></span><span id='topic+info+2Cassociations-method'></span><span id='topic+info'></span><span id='topic+info+3C-+2Cassociations-method'></span><span id='topic+info+3C-'></span><span id='topic+head+2Cassociations-method'></span><span id='topic+head'></span><span id='topic+tail+2Cassociations-method'></span><span id='topic+tail'></span><span id='topic+items+2Cassociations-method'></span><span id='topic+items'></span><span id='topic+items+3C-'></span><span id='topic+length+2Cassociations-method'></span><span id='topic+labels+2Cassociations-method'></span><span id='topic+plot'></span><span id='topic+plot.associations'></span><span id='topic+plot.itemMatrix'></span>

<h3>Description</h3>

<p>The <code>associations</code> class is a virtual class which is extended to
represent mining result (e.g., sets of <a href="#topic+itemsets">itemsets</a> or
<a href="#topic+rules">rules</a>). The class defines some common methods for its subclasses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'associations'
quality(x)

## S4 replacement method for signature 'associations'
quality(x) &lt;- value

## S4 method for signature 'associations'
info(x)

## S4 replacement method for signature 'associations'
info(x) &lt;- value

## S4 method for signature 'associations'
head(x, n = 6L, by = NULL, decreasing = TRUE, ...)

## S4 method for signature 'associations'
tail(x, n = 6L, by = NULL, decreasing = TRUE, ...)

## S4 method for signature 'associations'
items(x)

## S4 method for signature 'associations'
length(x)

## S4 method for signature 'associations'
labels(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="associations-class_+3A_x">x</code>, <code id="associations-class_+3A_object">object</code></td>
<td>
<p>the object.</p>
</td></tr>
<tr><td><code id="associations-class_+3A_value">value</code></td>
<td>
<p>the replacement value.</p>
</td></tr>
<tr><td><code id="associations-class_+3A_n">n</code></td>
<td>
<p>number of elements</p>
</td></tr>
<tr><td><code id="associations-class_+3A_by">by</code></td>
<td>
<p>sort by this interest measure</p>
</td></tr>
<tr><td><code id="associations-class_+3A_decreasing">decreasing</code></td>
<td>
<p>sort in decreasing order?</p>
</td></tr>
<tr><td><code id="associations-class_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implementations of <code>associations</code> store itemsets (e.g., the LHS and
RHS of a rule) as objects of class <a href="#topic+itemMatrix">itemMatrix</a> (i.e., sparse
binary matrices). Quality measures (e.g., support) are stored in a
data.frame accessible via method <code>quality()</code>.
</p>
<p>See Sections Functions and See Also to see all available methods.
</p>
<p><strong>Note:</strong> Associations can store multisets with duplicated elements. Duplicated
elements can result from combining several sets of associations.  Use
<code><a href="#topic+unique">unique()</a></code> to remove duplicate associations.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>quality(associations)</code>: returns the quality data.frame.
</p>
</li>
<li> <p><code>quality(associations) &lt;- value</code>: replaces the quality data.frame. The lengths of the vectors in the data.frame have to equal the number of associations in the set.
</p>
</li>
<li> <p><code>info(associations)</code>: returns the info list.
</p>
</li>
<li> <p><code>info(associations) &lt;- value</code>: replaces the info list.
</p>
</li>
<li> <p><code>head(associations)</code>: returns the first n associations.
</p>
</li>
<li> <p><code>tail(associations)</code>: returns the last n associations.
</p>
</li>
<li> <p><code>items(associations)</code>: dummy method. This method has to be implemented by all subclasses of associations and return the items which make up each association as an object of class <a href="#topic+itemMatrix">itemMatrix</a>.
</p>
</li>
<li> <p><code>length(associations)</code>: dummy method. This method has to be implemented by all subclasses of associations and return the number of elements in the association.
</p>
</li>
<li> <p><code>labels(associations)</code>: dummy method. This method has to be implemented by all subclasses of associations and return a vector of length(object) of labels for the elements in the association.
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>quality</code></dt><dd><p>a data.frame</p>
</dd>
<dt><code>info</code></dt><dd><p>a list</p>
</dd>
</dl>


<h3>Objects from the Class</h3>

<p>A virtual class: No objects may be created
from it.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Subclasses: <a href="#topic+rules">rules</a>, <a href="#topic+itemsets">itemsets</a>
</p>
<p>Other associations functions: 
<code><a href="#topic+abbreviate">abbreviate</a>()</code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+duplicated">duplicated</a>()</code>,
<code><a href="#topic+extract">extract</a></code>,
<code><a href="#topic+inspect">inspect</a>()</code>,
<code><a href="#topic+is.closed">is.closed</a>()</code>,
<code><a href="#topic+is.generator">is.generator</a>()</code>,
<code><a href="#topic+is.maximal">is.maximal</a>()</code>,
<code><a href="#topic+is.redundant">is.redundant</a>()</code>,
<code><a href="#topic+is.significant">is.significant</a>()</code>,
<code><a href="#topic+is.superset">is.superset</a>()</code>,
<code><a href="#topic+itemsets-class">itemsets-class</a></code>,
<code><a href="#topic+match">match</a>()</code>,
<code><a href="#topic+rules-class">rules-class</a></code>,
<code><a href="#topic+sample">sample</a>()</code>,
<code><a href="#topic+sets">sets</a></code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+sort">sort</a>()</code>,
<code><a href="#topic+unique">unique</a>()</code>
</p>

<hr>
<h2 id='c'>Combining Association and Transaction Objects</h2><span id='topic+c'></span><span id='topic+c+2CitemMatrix-method'></span><span id='topic+c+2Ctransactions-method'></span><span id='topic+c+2CtidLists-method'></span><span id='topic+c+2Crules-method'></span><span id='topic+c+2Citemsets-method'></span>

<h3>Description</h3>

<p>Provides the methods to combine several <a href="#topic+associations">associations</a> or <a href="#topic+transactions">transactions</a> objects
into a single object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'itemMatrix'
c(x, ..., recursive = FALSE)

## S4 method for signature 'transactions'
c(x, ..., recursive = FALSE)

## S4 method for signature 'tidLists'
c(x, ..., recursive = FALSE)

## S4 method for signature 'rules'
c(x, ..., recursive = FALSE)

## S4 method for signature 'itemsets'
c(x, ..., recursive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_+3A_x">x</code></td>
<td>
<p>first object.</p>
</td></tr>
<tr><td><code id="c_+3A_...">...</code></td>
<td>
<p>further objects of the same class as <code>x</code> to be combined.</p>
</td></tr>
<tr><td><code id="c_+3A_recursive">recursive</code></td>
<td>
<p>a logical. If <code>recursive = TRUE</code>, the function
recursively descends through lists combining all their elements into a
vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Combining arules objects is done by combining the rows
of <a href="#topic+itemMatrix">itemMatrix</a> objects
representing the associations or transactions.
</p>
<p>Note that <code>c()</code> can result in duplicates.
Use <code><a href="base.html#topic+union">union()</a></code> rather than <code>c()</code> to combine several mined
<a href="#topic+itemsets">itemsets</a> or <a href="#topic+rules">rules</a> into a single
set without duplicates.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other associations functions: 
<code><a href="#topic+abbreviate">abbreviate</a>()</code>,
<code><a href="#topic+associations-class">associations-class</a></code>,
<code><a href="#topic+duplicated">duplicated</a>()</code>,
<code><a href="#topic+extract">extract</a></code>,
<code><a href="#topic+inspect">inspect</a>()</code>,
<code><a href="#topic+is.closed">is.closed</a>()</code>,
<code><a href="#topic+is.generator">is.generator</a>()</code>,
<code><a href="#topic+is.maximal">is.maximal</a>()</code>,
<code><a href="#topic+is.redundant">is.redundant</a>()</code>,
<code><a href="#topic+is.significant">is.significant</a>()</code>,
<code><a href="#topic+is.superset">is.superset</a>()</code>,
<code><a href="#topic+itemsets-class">itemsets-class</a></code>,
<code><a href="#topic+match">match</a>()</code>,
<code><a href="#topic+rules-class">rules-class</a></code>,
<code><a href="#topic+sample">sample</a>()</code>,
<code><a href="#topic+sets">sets</a></code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+sort">sort</a>()</code>,
<code><a href="#topic+unique">unique</a>()</code>
</p>
<p>Other itemMatrix and transactions functions: 
<code><a href="#topic+abbreviate">abbreviate</a>()</code>,
<code><a href="#topic+crossTable">crossTable</a>()</code>,
<code><a href="#topic+duplicated">duplicated</a>()</code>,
<code><a href="#topic+extract">extract</a></code>,
<code><a href="#topic+hierarchy">hierarchy</a></code>,
<code><a href="#topic+image">image</a>()</code>,
<code><a href="#topic+inspect">inspect</a>()</code>,
<code><a href="#topic+is.superset">is.superset</a>()</code>,
<code><a href="#topic+itemFrequencyPlot">itemFrequencyPlot</a>()</code>,
<code><a href="#topic+itemFrequency">itemFrequency</a>()</code>,
<code><a href="#topic+itemMatrix-class">itemMatrix-class</a></code>,
<code><a href="#topic+match">match</a>()</code>,
<code><a href="#topic+merge">merge</a>()</code>,
<code><a href="#topic+random.transactions">random.transactions</a>()</code>,
<code><a href="#topic+sample">sample</a>()</code>,
<code><a href="#topic+sets">sets</a></code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+supportingTransactions">supportingTransactions</a>()</code>,
<code><a href="#topic+tidLists-class">tidLists-class</a></code>,
<code><a href="#topic+transactions-class">transactions-class</a></code>,
<code><a href="#topic+unique">unique</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Adult")

## combine transactions
a1 &lt;- Adult[1:10]
a2 &lt;- Adult[101:110]

aComb &lt;- c(a1, a2)
summary(aComb)

## combine rules (can contain the same rule multiple times)
r1 &lt;- apriori(Adult[1:1000])
r2 &lt;- apriori(Adult[1001:2000])
rComb &lt;- c(r1, r2)
rComb

## union of rules (a set with only unique rules: same as unique(rComb))
rUnion &lt;- union(r1,r2)
rUnion
</code></pre>

<hr>
<h2 id='confint'>Confidence Intervals for Interest Measures for Association Rules</h2><span id='topic+confint'></span><span id='topic+confint.rules'></span>

<h3>Description</h3>

<p>Defines a method to compute confidence intervals for interest measures for association <a href="#topic+rules">rules</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rules'
confint(
  object,
  parm = "oddsRatio",
  level = 0.95,
  measure = NULL,
  side = c("two.sided", "lower", "upper"),
  method = NULL,
  replications = 1000,
  smoothCounts = 0,
  transactions = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint_+3A_object">object</code></td>
<td>
<p>an object of class <a href="#topic+rules">rules</a>.</p>
</td></tr>
<tr><td><code id="confint_+3A_parm">parm</code>, <code id="confint_+3A_measure">measure</code></td>
<td>
<p>name of the interest measures (see <code><a href="#topic+interestMeasure">interestMeasure()</a></code>).
<code>measure</code> can be used instead of <code>parm</code>.</p>
</td></tr>
<tr><td><code id="confint_+3A_level">level</code></td>
<td>
<p>the confidence level required.</p>
</td></tr>
<tr><td><code id="confint_+3A_side">side</code></td>
<td>
<p>Should a two-sided confidence interval or a one-sided limit be
returned? Lower returns an interval with only a lower limit and upper
returns an interval with only an upper limit.</p>
</td></tr>
<tr><td><code id="confint_+3A_method">method</code></td>
<td>
<p>method to construct the confidence interval. The available
methods depends on the measure and the most common method is used by
default.</p>
</td></tr>
<tr><td><code id="confint_+3A_replications">replications</code></td>
<td>
<p>number of replications for method <code>"simulation"</code>. Ignored
for other methods.</p>
</td></tr>
<tr><td><code id="confint_+3A_smoothcounts">smoothCounts</code></td>
<td>
<p>pseudo count for addaptive smoothing (Laplace
smoothing). Often a pseudo counts of .5 is used for smoothing (see Detail
Section).</p>
</td></tr>
<tr><td><code id="confint_+3A_transactions">transactions</code></td>
<td>
<p>if the rules object does not contain sufficient quality
information, then a set of transactions to calculate the confidence interval
for can be specified.</p>
</td></tr>
<tr><td><code id="confint_+3A_...">...</code></td>
<td>
<p>Additional parameters are ignored with a warning.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method creates a contingency table for each rule and then constructs a
confidence interval for the specified measures.
</p>
<p>Fast confidence interval approximations are currently available for the
measures <code>"support"</code>, <code>"count"</code>, <code>"confidence"</code>, <code>"lift"</code>, <code>"oddsRatio"</code>, and <code>"phi"</code>.
For all other measures, bootstrap sampling from a multinomial distribution
is used.
</p>
<p>Haldan-Anscombe correction (Haldan, 1940; Anscombe, 1956) to avoids issues
with zero counts can be specified by <code>smoothCounts = 0.5</code>. Here .5 is
added to each count in the contingency table.
</p>


<h3>Value</h3>

<p>Returns a matrix with with one row for each rule and the two columns
named <code>"LL"</code> and <code>"UL"</code> with the interval boundaries.
The matrix has the following additional attributes:
</p>
<table>
<tr><td><code>measure</code></td>
<td>
<p> the interest measure.</p>
</td></tr>
<tr><td><code>level</code></td>
<td>
<p> the confidence level</p>
</td></tr>
<tr><td><code>side</code></td>
<td>
<p> the confidence level</p>
</td></tr>
<tr><td><code>smoothCounts</code></td>
<td>
<p> used count
smoothing. </p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p> name of the method to create the interval </p>
</td></tr>
<tr><td><code>desc</code></td>
<td>
<p> description of the used method to calculate the confidence
interval. The mentioned references can be found below. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>References</h3>

<p>Wilson, E. B. (1927). &quot;Probable inference, the law of
succession, and statistical inference&quot;.
<em>Journal of the American Statistical Association,</em> 22 (158): 209-212.
<a href="https://doi.org/10.1080/01621459.1927.10502953">doi:10.1080/01621459.1927.10502953</a>
</p>
<p>Clopper, C.; Pearson, E. S. (1934). &quot;The use of confidence or fiducial
limits illustrated in the case of the binomial&quot;. <em>Biometrika,</em> 26 (4):
404-413.
<a href="https://doi.org/10.1093/biomet/26.4.404">doi:10.1093/biomet/26.4.404</a>
</p>
<p>Doob, J. L. (1935). &quot;The Limiting Distributions of Certain Statistics&quot;.
<em>Annals of Mathematical Statistics,</em> 6: 160-169.
<a href="https://doi.org/10.1214/aoms/1177732594">doi:10.1214/aoms/1177732594</a>
</p>
<p>Fisher, R.A. (1962). &quot;Confidence limits for a cross-product ratio&quot;.
<em>Australian Journal of Statistics,</em> 4, 41.
</p>
<p>Woolf, B. (1955). &quot;On estimating the relation between blood group and
diseases&quot;. <em>Annals of Human Genetics,</em> 19, 251-253.
</p>
<p>Haldane, J.B.S. (1940). &quot;The mean and variance of the moments of chi-squared
when used as a test of homogeneity, when expectations are small&quot;.
<em>Biometrika,</em> 29, 133-134.
</p>
<p>Anscombe, F.J. (1956). &quot;On estimating binomial response relations&quot;.
<em>Biometrika,</em> 43, 461-464.
</p>


<h3>See Also</h3>

<p>Other interest measures: 
<code><a href="#topic+coverage">coverage</a>()</code>,
<code><a href="#topic+interestMeasure">interestMeasure</a>()</code>,
<code><a href="#topic+is.redundant">is.redundant</a>()</code>,
<code><a href="#topic+is.significant">is.significant</a>()</code>,
<code><a href="#topic+support">support</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Income")

# mine some rules with the consequent "language in home=english"
rules &lt;- apriori(Income, parameter = list(support = 0.5),
  appearance = list(rhs = "language in home=english"))

# calculate the confidence interval for the rules' odds ratios.
# note that we use Haldane-Anscombe correction (with smoothCounts = .5)
# to avoid issues with 0 counts in the contingency table.
ci &lt;- confint(rules, "oddsRatio",  smoothCounts = .5)
ci

# We add the odds ratio (with Haldane-Anscombe correction)
# and the confidence intervals to the quality slot of the rules.
quality(rules) &lt;- cbind(
  quality(rules),
  oddsRatio = interestMeasure(rules, "oddsRatio", smoothCounts = .5),
  oddsRatio = ci)

rules &lt;- sort(rules, by = "oddsRatio")
inspect(rules)

# use confidence intervals for lift to find rules with a lift significantly larger then 1.
# We set the confidence level to 95%, create a one-sided interval and check
# if the interval does not cover 1 (i.e., the lower limit is larger than 1).
ci &lt;- confint(rules, "lift", level = 0.95, side = "lower")
ci

inspect(rules[ci[, "LL"] &gt; 1])
</code></pre>

<hr>
<h2 id='coverage'>Calculate coverage for rules</h2><span id='topic+coverage'></span><span id='topic+coverage+2Crules-method'></span>

<h3>Description</h3>

<p>Provides the generic function and a method to calculate the
coverage (support of the left-hand-side) of <a href="#topic+rules">rules</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coverage(x, transactions = NULL, reuse = TRUE)

## S4 method for signature 'rules'
coverage(x, transactions = NULL, reuse = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coverage_+3A_x">x</code></td>
<td>
<p>the set of <a href="#topic+rules">rules</a>.</p>
</td></tr>
<tr><td><code id="coverage_+3A_transactions">transactions</code></td>
<td>
<p>the data set used to generate <code>x</code>. Only needed if the
quality slot of <code>x</code> does not contain support and confidence.</p>
</td></tr>
<tr><td><code id="coverage_+3A_reuse">reuse</code></td>
<td>
<p>reuse support and confidence stored in <code>x</code> or recompute from
transactions?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Coverage (also called cover or LHS-support) is the support of the
left-hand-side of the rule <code class="reqn">X =&gt; Y</code>, i.e., <code class="reqn">supp(X)</code>. It represents a measure of
to how often the rule can be applied.
</p>
<p>Coverage can be quickly calculated from the rule's quality measures (support and
confidence) stored in the quality slot. If these values are not present,
then the support of the LHS is counted using the data supplied in
<a href="#topic+transactions">transactions</a>.
</p>
<p>Coverage is also one of the measures available via the function
<code><a href="#topic+interestMeasure">interestMeasure()</a></code>.
</p>


<h3>Value</h3>

<p>A numeric vector of the same length as <code>x</code> containing the
coverage values for the sets in <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other interest measures: 
<code><a href="#topic+confint">confint</a>()</code>,
<code><a href="#topic+interestMeasure">interestMeasure</a>()</code>,
<code><a href="#topic+is.redundant">is.redundant</a>()</code>,
<code><a href="#topic+is.significant">is.significant</a>()</code>,
<code><a href="#topic+support">support</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Income")

## find and some rules (we only use 5 rules here) and calculate coverage
rules &lt;- apriori(Income)[1:5]
quality(rules) &lt;- cbind(quality(rules), coverage = coverage(rules))

inspect(rules)
</code></pre>

<hr>
<h2 id='crossTable'>Cross-tabulate joint occurrences across pairs of items</h2><span id='topic+crossTable'></span><span id='topic+crossTable+2CitemMatrix-method'></span>

<h3>Description</h3>

<p>Provides the generic function <code>crossTable()</code> and a method to
cross-tabulate joint occurrences across all pairs of items.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crossTable(x, ...)

## S4 method for signature 'itemMatrix'
crossTable(
  x,
  measure = c("count", "support", "probability", "lift"),
  sort = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crossTable_+3A_x">x</code></td>
<td>
<p>object to be cross-tabulated (<a href="#topic+transactions">transactions</a> or
<a href="#topic+itemMatrix">itemMatrix</a>).</p>
</td></tr>
<tr><td><code id="crossTable_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
<tr><td><code id="crossTable_+3A_measure">measure</code></td>
<td>
<p>measure to return. Default is co-occurrence counts.</p>
</td></tr>
<tr><td><code id="crossTable_+3A_sort">sort</code></td>
<td>
<p>sort the items by support.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A symmetric matrix of n x n, where n is the number of items times
in <code>x</code>. The matrix contains the co-occurrence counts between pairs of
items.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other itemMatrix and transactions functions: 
<code><a href="#topic+abbreviate">abbreviate</a>()</code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+duplicated">duplicated</a>()</code>,
<code><a href="#topic+extract">extract</a></code>,
<code><a href="#topic+hierarchy">hierarchy</a></code>,
<code><a href="#topic+image">image</a>()</code>,
<code><a href="#topic+inspect">inspect</a>()</code>,
<code><a href="#topic+is.superset">is.superset</a>()</code>,
<code><a href="#topic+itemFrequencyPlot">itemFrequencyPlot</a>()</code>,
<code><a href="#topic+itemFrequency">itemFrequency</a>()</code>,
<code><a href="#topic+itemMatrix-class">itemMatrix-class</a></code>,
<code><a href="#topic+match">match</a>()</code>,
<code><a href="#topic+merge">merge</a>()</code>,
<code><a href="#topic+random.transactions">random.transactions</a>()</code>,
<code><a href="#topic+sample">sample</a>()</code>,
<code><a href="#topic+sets">sets</a></code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+supportingTransactions">supportingTransactions</a>()</code>,
<code><a href="#topic+tidLists-class">tidLists-class</a></code>,
<code><a href="#topic+transactions-class">transactions-class</a></code>,
<code><a href="#topic+unique">unique</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Groceries")

ct &lt;- crossTable(Groceries, sort = TRUE)
ct[1:5, 1:5]

sp &lt;- crossTable(Groceries, measure = "support", sort = TRUE)
sp[1:5, 1:5]

lift &lt;- crossTable(Groceries, measure = "lift", sort = TRUE)
lift[1:5, 1:5]

</code></pre>

<hr>
<h2 id='DATAFRAME'>Data.frame Representation for arules Objects</h2><span id='topic+DATAFRAME'></span><span id='topic+DATAFRAME+2Crules-method'></span><span id='topic+DATAFRAME+2Citemsets-method'></span><span id='topic+DATAFRAME+2CitemMatrix-method'></span>

<h3>Description</h3>

<p>Provides the generic function <code>DATAFRAME()</code> and the methods to create
a data.frame representation from some arules objects.
These methods are used for the coercion to a
data.frame, but offer more control over the coercion process (item
separators, etc.).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DATAFRAME(from, ...)

## S4 method for signature 'rules'
DATAFRAME(from, separate = TRUE, ...)

## S4 method for signature 'itemsets'
DATAFRAME(from, ...)

## S4 method for signature 'itemMatrix'
DATAFRAME(from, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DATAFRAME_+3A_from">from</code></td>
<td>
<p>the object to be converted into a data.frame.</p>
</td></tr>
<tr><td><code id="DATAFRAME_+3A_...">...</code></td>
<td>
<p>further arguments are passed on to the <code>labels()</code> method defined for the object in <code>from</code>.</p>
</td></tr>
<tr><td><code id="DATAFRAME_+3A_separate">separate</code></td>
<td>
<p>logical; separate LHS and RHS in separate columns? (only for rules)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using <code>DATAFRAME()</code> is equivalent to the standard coercion
<code>as(x, "data.frame")</code>.  However, for rules, the argument <code>separate = TRUE</code>
will produce separate columns for the LHS and the RHS of the rule.
</p>
<p>Furthermore, the arguments <code>itemSep</code>, <code>setStart</code>, <code>setEnd</code>
(and <code>ruleSep</code> for <code>separate = FALSE</code>) will be passed on to the
<code>labels()</code> method for the object specified in <code>from</code>.
</p>


<h3>Value</h3>

<p>a data.frame.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other import/export: 
<code><a href="#topic+LIST">LIST</a>()</code>,
<code><a href="#topic+pmml">pmml</a></code>,
<code><a href="#topic+read">read</a></code>,
<code><a href="#topic+write">write</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Adult)
  
DATAFRAME(head(Adult))
DATAFRAME(head(Adult), setStart = '', itemSep = ' + ', setEnd = '')

rules &lt;- apriori(Adult, 
  parameter = list(supp = 0.5, conf = 0.9, target = "rules"))
rules &lt;- head(rules, by = "conf")


### default coercions (same as as(rules, "data.frame"))
DATAFRAME(rules)

DATAFRAME(rules, separate = TRUE)
DATAFRAME(rules, separate = TRUE, setStart = '', itemSep = ' + ', setEnd = '')
</code></pre>

<hr>
<h2 id='discretize'>Convert a Continuous Variable into a Categorical Variable</h2><span id='topic+discretize'></span><span id='topic+binning'></span><span id='topic+discretizeDF'></span>

<h3>Description</h3>

<p>This function implements several basic unsupervised methods to convert a
continuous variable into a categorical variable (factor) using different
binning strategies. For convenience, a whole data.frame can be discretized
(i.e., all numeric columns are discretized).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discretize(
  x,
  method = "frequency",
  breaks = 3,
  labels = NULL,
  include.lowest = TRUE,
  right = FALSE,
  dig.lab = 3,
  ordered_result = FALSE,
  infinity = FALSE,
  onlycuts = FALSE,
  categories = NULL,
  ...
)

discretizeDF(df, methods = NULL, default = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discretize_+3A_x">x</code></td>
<td>
<p>a numeric vector (continuous variable).</p>
</td></tr>
<tr><td><code id="discretize_+3A_method">method</code></td>
<td>
<p>discretization method. Available are: <code>"interval"</code> (equal
interval width), <code>"frequency"</code> (equal frequency), <code>"cluster"</code>
(k-means clustering) and <code>"fixed"</code> (categories specifies interval
boundaries).  Note that equal frequency does not achieve perfect equally
sized groups if the data contains duplicated values.</p>
</td></tr>
<tr><td><code id="discretize_+3A_breaks">breaks</code>, <code id="discretize_+3A_categories">categories</code></td>
<td>
<p>either number of categories or a vector with boundaries for
discretization (all values outside the boundaries will be set to NA).
<b><code>categories</code> is deprecated, use <code>breaks</code> instead.</b></p>
</td></tr>
<tr><td><code id="discretize_+3A_labels">labels</code></td>
<td>
<p>character vector; labels for the levels of the resulting
category. By default, labels are constructed using &quot;(a,b]&quot; interval
notation. If <code>labels = FALSE</code>, simple integer codes are returned
instead of a factor..</p>
</td></tr>
<tr><td><code id="discretize_+3A_include.lowest">include.lowest</code></td>
<td>
<p>logical; should the first interval be closed to the
left?</p>
</td></tr>
<tr><td><code id="discretize_+3A_right">right</code></td>
<td>
<p>logical; should the intervals be closed on the right (and open
on the left) or vice versa?</p>
</td></tr>
<tr><td><code id="discretize_+3A_dig.lab">dig.lab</code></td>
<td>
<p>integer; number of digits used to create labels.</p>
</td></tr>
<tr><td><code id="discretize_+3A_ordered_result">ordered_result</code></td>
<td>
<p>logical; return a ordered factor?</p>
</td></tr>
<tr><td><code id="discretize_+3A_infinity">infinity</code></td>
<td>
<p>logical; should the first/last break boundary changed to
+/-Inf?</p>
</td></tr>
<tr><td><code id="discretize_+3A_onlycuts">onlycuts</code></td>
<td>
<p>logical; return only computed interval boundaries?</p>
</td></tr>
<tr><td><code id="discretize_+3A_...">...</code></td>
<td>
<p>for method &quot;cluster&quot; further arguments are passed on to
<code>kmeans</code>.</p>
</td></tr>
<tr><td><code id="discretize_+3A_df">df</code></td>
<td>
<p>data.frame; each numeric column in the data.frame is discretized.</p>
</td></tr>
<tr><td><code id="discretize_+3A_methods">methods</code></td>
<td>
<p>named list of lists or a data.frame; the named list contains
lists of discretization parameters (see parameters of <code>discretize()</code>) for
each numeric column (see details). If no discretization is
specified for a column, then the default settings for <code>discretize()</code> are
used.  Note: the names have to match exactly.  If a data.frame is specified,
then the discretization breaks in this data.frame are applied to <code>df</code>.</p>
</td></tr>
<tr><td><code id="discretize_+3A_default">default</code></td>
<td>
<p>named list; parameters for <code>discretize()</code> used for all
columns not specified in <code>methods</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Discretize calculates breaks between intervals using various methods and
then uses <code><a href="base.html#topic+cut">base::cut()</a></code> to convert the numeric values into intervals
represented as a factor.
</p>
<p>Discretization may fail for several reasons. Some reasons are
</p>

<ul>
<li><p> A variable contains only a single value. In this case, the variable
should be dropped or directly converted into a factor with a single level
(see <a href="base.html#topic+factor">factor</a>).
</p>
</li>
<li><p> Some calculated breaks are not unique.
This can happen for method frequency with very skewed data (e.g., a large
portion of the values is 0). In this case, non-unique breaks are dropped
with a warning. It would be probably better to look at the histogram of the
data and decide on breaks for the method fixed. </p>
</li></ul>

<p><code>discretize</code> only implements unsupervised discretization. See
<code><a href="arulesCBA.html#topic+discretizeDF.supervised">arulesCBA::discretizeDF.supervised()</a></code> in package <span class="pkg">arulesCBA</span>
for supervised discretization.
</p>
<p><code>discretizeDF()</code> applies discretization to each numeric column.
Individual discretization parameters can be specified in the form:
<code>methods = list(column_name1 = list(method = ,...), column_name2 = list(...))</code>.
If no discretization method is specified for a column, then the
discretization in default is applied (<code>NULL</code> invokes the default method
in <code>discretize()</code>). The special method <code>"none"</code> can be specified
to suppress discretization for a column.
</p>


<h3>Value</h3>

<p><code>discretize()</code> returns a factor representing the
categorized continuous variable with
attribute <code>"discretized:breaks"</code> indicating the used breaks or and
<code>"discretized:method"</code> giving the used method. If <code>onlycuts = TRUE</code>
is used, a vector with the calculated interval boundaries is returned.
</p>
<p><code>discretizeDF()</code> returns a discretized data.frame.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+cut">base::cut()</a></code>,
<code><a href="arulesCBA.html#topic+discretizeDF.supervised">arulesCBA::discretizeDF.supervised()</a></code>.
</p>
<p>Other preprocessing: 
<code><a href="#topic+hierarchy">hierarchy</a></code>,
<code><a href="#topic+itemCoding">itemCoding</a></code>,
<code><a href="#topic+merge">merge</a>()</code>,
<code><a href="#topic+sample">sample</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
x &lt;- iris[,1]

### look at the distribution before discretizing
hist(x, breaks = 20, main = "Data")

def.par &lt;- par(no.readonly = TRUE) # save default
layout(mat = rbind(1:2,3:4))

### convert continuous variables into categories (there are 3 types of flowers)
### the default method is equal frequency
table(discretize(x, breaks = 3))
hist(x, breaks = 20, main = "Equal Frequency")
abline(v = discretize(x, breaks = 3, 
  onlycuts = TRUE), col = "red")
# Note: the frequencies are not exactly equal because of ties in the data 

### equal interval width
table(discretize(x, method = "interval", breaks = 3))
hist(x, breaks = 20, main = "Equal Interval length")
abline(v = discretize(x, method = "interval", breaks = 3, 
  onlycuts = TRUE), col = "red")

### k-means clustering 
table(discretize(x, method = "cluster", breaks = 3))
hist(x, breaks = 20, main = "K-Means")
abline(v = discretize(x, method = "cluster", breaks = 3, 
  onlycuts = TRUE), col = "red")

### user-specified (with labels)
table(discretize(x, method = "fixed", breaks = c(-Inf, 6, Inf), 
    labels = c("small", "large")))
hist(x, breaks = 20, main = "Fixed")
abline(v = discretize(x, method = "fixed", breaks = c(-Inf, 6, Inf), 
    onlycuts = TRUE), col = "red")

par(def.par)  # reset to default

### prepare the iris data set for association rule mining
### use default discretization
irisDisc &lt;- discretizeDF(iris)
head(irisDisc)

### discretize all numeric columns differently
irisDisc &lt;- discretizeDF(iris, default = list(method = "interval", breaks = 2, 
  labels = c("small", "large")))
head(irisDisc)

### specify discretization for the petal columns and don't discretize the others
irisDisc &lt;- discretizeDF(iris, methods = list(
  Petal.Length = list(method = "frequency", breaks = 3, 
    labels = c("short", "medium", "long")),
  Petal.Width = list(method = "frequency", breaks = 2, 
    labels = c("narrow", "wide"))
  ),
  default = list(method = "none")
  )
head(irisDisc)

### discretize new data using the same discretization scheme as the
###   data.frame supplied in methods. Note: NAs may occure if a new 
###   value falls outside the range of values observed in the 
###   originally discretized table (use argument infinity = TRUE in 
###   discretize to prevent this case.) 
discretizeDF(iris[sample(1:nrow(iris), 5),], methods = irisDisc)
</code></pre>

<hr>
<h2 id='dissimilarity'>Dissimilarity Matrix Computation for Associations and Transactions</h2><span id='topic+dissimilarity'></span><span id='topic+dist'></span><span id='topic+dissimilarity+2Cmatrix-method'></span><span id='topic+dissimilarity+2CitemMatrix-method'></span><span id='topic+dissimilarity+2Cassociations-method'></span>

<h3>Description</h3>

<p>Provides the generic function <code>dissimilarity()</code> and the methods to
compute and returns distances for binary data in a <code>matrix</code>,
<a href="#topic+transactions">transactions</a> or <a href="#topic+associations">associations</a> which
can be used for grouping and clustering. See Hahsler (2016) for an
introduction to distance-based clustering of association rules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dissimilarity(x, y = NULL, method = NULL, args = NULL, ...)

## S4 method for signature 'matrix'
dissimilarity(x, y = NULL, method = NULL, args = NULL)

## S4 method for signature 'itemMatrix'
dissimilarity(x, y = NULL, method = NULL, args = NULL, which = "transactions")

## S4 method for signature 'associations'
dissimilarity(x, y = NULL, method = NULL, args = NULL, which = "associations")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dissimilarity_+3A_x">x</code></td>
<td>
<p>the set of elements (e.g., <code>matrix</code>, <a href="#topic+itemMatrix">itemMatrix</a>, <a href="#topic+transactions">transactions</a>,
<a href="#topic+itemsets">itemsets</a>, <a href="#topic+rules">rules</a>).</p>
</td></tr>
<tr><td><code id="dissimilarity_+3A_y">y</code></td>
<td>
<p><code>NULL</code> or a second set to calculate cross dissimilarities.</p>
</td></tr>
<tr><td><code id="dissimilarity_+3A_method">method</code></td>
<td>
<p>the distance measure to be used. Implemented measures are
(defaults to <code>"jaccard"</code>):
</p>

<ul>
<li> <p><code>"affinity"</code>:
measure based on the <code><a href="#topic+affinity">affinity()</a></code>, a similarity measure between
items. It is defined as the average affinity between the items in two
transactions (see Aggarwal et al. (2002)). If <code>x</code> is not the full
transaction set <code>args</code> needs to contain either precalculated affinities
as element <code>"affinities"</code> or the transaction set as element
<code>"transactions"</code>.
</p>
</li>
<li> <p><code>"cosine"</code>: the Cosine distance.
</p>
</li>
<li> <p><code>"dice"</code>: Dice's coefficient defined by Dice (1945).
Similar to Jaccard but gives double the weight to agreeing items.
</p>
</li>
<li> <p><code>"euclidean"</code>: the Euclidean distance.
</p>
</li>
<li> <p><code>"jaccard"</code>: the number of items which occur in both elements
divided by the total number of items in the elements (Sneath, 1957).  This
measure is often also called: binary, asymmetric binary, etc.
</p>
</li>
<li> <p><code>"matching"</code>: the matching coefficient defined by
Sokal and Michener (1958). This coefficient gives the same weight to
presents and absence of items.
</p>
</li>
<li> <p><code>"pearson"</code> A distance calculated by <code class="reqn">1 - r</code>
if <code class="reqn">r&gt;1</code> and <code class="reqn">1</code> otherwise, where <code class="reqn">r</code> is the Pearson's correlation
coefficient.
</p>
</li>
<li> <p><code>"phi"</code>: same as <code>"pearson"</code>. Pearson's correlation coefficient
reduces to the phi coefficient for the 2x2 contingency tables used
here.
</p>
</li>
<li> <p><code>"toivonen"</code>: Method described in Toivonen et al. (1995).  For
rules this measure is only defined between rules with the same consequent.
The distance between two rules is defined as the number of transactions
which is covered by only one of the two rules.  The transactions used to
mine the associations has to be passed on via <code>args</code> as element
<code>"transactions"</code>.
</p>
</li>
<li> <p><code>"gupta"</code>: Method described in Gupta et al. (1999).  The
distance between two rules is defined as 1 minus the proportion of
transactions which are covered by both rules in the transactions covered by
each rule individually.  The transactions used to mine the associations has
to be passed on via <code>args</code> as element <code>"transactions"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="dissimilarity_+3A_args">args</code></td>
<td>
<p>a list of additional arguments for the methods.</p>
</td></tr>
<tr><td><code id="dissimilarity_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
<tr><td><code id="dissimilarity_+3A_which">which</code></td>
<td>
<p>a character string indicating if the dissimilarity should be
calculated between transactions/associations (default) or items (use <code>"items"</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns an object of class <code>dist</code>.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>References</h3>

<p>Aggarwal, C.C., Cecilia Procopiuc, and Philip S. Yu. (2002)
Finding localized associations in market basket data.  <em>IEEE Trans. on
Knowledge and Data Engineering</em> 14(1):51&ndash;62.
</p>
<p>Dice, L. R. (1945) Measures of the amount of ecologic association between
species. <em>Ecology</em> 26, pages 297&ndash;302.
</p>
<p>Gupta, G., Strehl, A., and Ghosh, J. (1999) Distance based clustering of
association rules. <em>In Intelligent Engineering Systems Through
Artificial Neural Networks (Proceedings of ANNIE 1999)</em>, pages 759-764. ASME
Press.
</p>
<p>Hahsler, M. (2016) Grouping association rules using lift. In C.  Iyigun, R.
Moghaddess, and A. Oztekin, editors, <em>11th INFORMS Workshop on Data Mining
and Decision Analytics</em> (DM-DA 2016).
</p>
<p>Sneath, P. H. A. (1957) Some thoughts on bacterial classification.
<em>Journal of General Microbiology</em> 17, pages 184&ndash;200.
</p>
<p>Sokal, R. R. and Michener, C. D. (1958) A statistical method for evaluating
systematic relationships. <em>University of Kansas Science Bulletin</em> 38,
pages 1409&ndash;1438.
</p>
<p>Toivonen, H., Klemettinen, M., Ronkainen, P., Hatonen, K. and Mannila H.
(1995) Pruning and grouping discovered association rules. <em>In
Proceedings of KDD'95</em>.
</p>


<h3>See Also</h3>

<p>Other proximity classes and functions: 
<code><a href="#topic+affinity">affinity</a>()</code>,
<code><a href="#topic+predict">predict</a>()</code>,
<code><a href="#topic+proximity-classes">proximity-classes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## cluster items in Groceries with support &gt; 5%
data("Groceries")

s &lt;- Groceries[, itemFrequency(Groceries) &gt; 0.05]
d_jaccard &lt;- dissimilarity(s, which = "items")
plot(hclust(d_jaccard, method = "ward.D2"), main = "Dendrogram for items")

## cluster transactions for a sample of Adult
data("Adult")
s &lt;- sample(Adult, 500)

##  calculate Jaccard distances and do hclust
d_jaccard &lt;- dissimilarity(s)
hc &lt;- hclust(d_jaccard, method = "ward.D2")
plot(hc, labels = FALSE, main = "Dendrogram for Transactions (Jaccard)")

## get 20 clusters and look at the difference of the item frequencies (bars)
## for the top 20 items) in cluster 1 compared to the data (line)
assign &lt;- cutree(hc, 20)
itemFrequencyPlot(s[assign == 1], population = s, topN = 20)

## calculate affinity-based distances between transactions and do hclust
d_affinity &lt;- dissimilarity(s, method = "affinity")
hc &lt;- hclust(d_affinity, method = "ward.D2")
plot(hc, labels = FALSE, main = "Dendrogram for Transactions (Affinity)")

## cluster association rules
rules &lt;- apriori(Adult, parameter = list(support = 0.3))
rules &lt;- subset(rules, subset = lift &gt; 2)

## use affinity to cluster rules
## Note: we need to supply the transactions (or affinities) from the
## dataset (sample).
d_affinity &lt;- dissimilarity(rules, method = "affinity",
  args = list(transactions = s))
hc &lt;- hclust(d_affinity, method = "ward.D2")
plot(hc, main = "Dendrogram for Rules (Affinity)")

## create 4 groups and inspect the rules in the first group.
assign &lt;- cutree(hc, k = 3)
inspect(rules[assign == 1])

</code></pre>

<hr>
<h2 id='duplicated'>Find Duplicated Elements</h2><span id='topic+duplicated'></span><span id='topic+duplicated+2CitemMatrix-method'></span><span id='topic+duplicated+2Crules-method'></span><span id='topic+duplicated+2Citemsets-method'></span>

<h3>Description</h3>

<p>Provides the generic function <code>duplicated()</code> and the methods to find
duplicated elements in
<a href="#topic+itemMatrix">itemMatrix</a>, <a href="#topic+associations">associations</a> and their subclasses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>duplicated(x, incomparables = FALSE, ...)

## S4 method for signature 'itemMatrix'
duplicated(x, incomparables = FALSE)

## S4 method for signature 'rules'
duplicated(x, incomparables = FALSE)

## S4 method for signature 'itemsets'
duplicated(x, incomparables = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="duplicated_+3A_x">x</code></td>
<td>
<p>an object of class <a href="#topic+itemMatrix">itemMatrix</a> or <a href="#topic+associations">associations</a>.</p>
</td></tr>
<tr><td><code id="duplicated_+3A_incomparables">incomparables</code></td>
<td>
<p>argument currently unused.</p>
</td></tr>
<tr><td><code id="duplicated_+3A_...">...</code></td>
<td>
<p>further arguments (currently unused).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector indicating duplicated elements.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other associations functions: 
<code><a href="#topic+abbreviate">abbreviate</a>()</code>,
<code><a href="#topic+associations-class">associations-class</a></code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+extract">extract</a></code>,
<code><a href="#topic+inspect">inspect</a>()</code>,
<code><a href="#topic+is.closed">is.closed</a>()</code>,
<code><a href="#topic+is.generator">is.generator</a>()</code>,
<code><a href="#topic+is.maximal">is.maximal</a>()</code>,
<code><a href="#topic+is.redundant">is.redundant</a>()</code>,
<code><a href="#topic+is.significant">is.significant</a>()</code>,
<code><a href="#topic+is.superset">is.superset</a>()</code>,
<code><a href="#topic+itemsets-class">itemsets-class</a></code>,
<code><a href="#topic+match">match</a>()</code>,
<code><a href="#topic+rules-class">rules-class</a></code>,
<code><a href="#topic+sample">sample</a>()</code>,
<code><a href="#topic+sets">sets</a></code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+sort">sort</a>()</code>,
<code><a href="#topic+unique">unique</a>()</code>
</p>
<p>Other itemMatrix and transactions functions: 
<code><a href="#topic+abbreviate">abbreviate</a>()</code>,
<code><a href="#topic+crossTable">crossTable</a>()</code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+extract">extract</a></code>,
<code><a href="#topic+hierarchy">hierarchy</a></code>,
<code><a href="#topic+image">image</a>()</code>,
<code><a href="#topic+inspect">inspect</a>()</code>,
<code><a href="#topic+is.superset">is.superset</a>()</code>,
<code><a href="#topic+itemFrequencyPlot">itemFrequencyPlot</a>()</code>,
<code><a href="#topic+itemFrequency">itemFrequency</a>()</code>,
<code><a href="#topic+itemMatrix-class">itemMatrix-class</a></code>,
<code><a href="#topic+match">match</a>()</code>,
<code><a href="#topic+merge">merge</a>()</code>,
<code><a href="#topic+random.transactions">random.transactions</a>()</code>,
<code><a href="#topic+sample">sample</a>()</code>,
<code><a href="#topic+sets">sets</a></code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+supportingTransactions">supportingTransactions</a>()</code>,
<code><a href="#topic+tidLists-class">tidLists-class</a></code>,
<code><a href="#topic+transactions-class">transactions-class</a></code>,
<code><a href="#topic+unique">unique</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Adult")

r1 &lt;- apriori(Adult[1:1000], parameter = list(support = 0.5))
r2 &lt;- apriori(Adult[1001:2000], parameter = list(support = 0.5))

## Note this creates a collection of rules from two sets of rules
r_comb &lt;- c(r1, r2)
duplicated(r_comb)
</code></pre>

<hr>
<h2 id='eclat'>Mining Associations with Eclat</h2><span id='topic+eclat'></span><span id='topic+ECLAT'></span><span id='topic+Eclat'></span>

<h3>Description</h3>

<p>Mine frequent itemsets with the Eclat algorithm.  This algorithm uses simple
intersection operations for equivalence class clustering along with
bottom-up lattice traversal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eclat(data, parameter = NULL, control = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eclat_+3A_data">data</code></td>
<td>
<p>object of class <a href="#topic+transactions">transactions</a> or any data
structure which can be coerced into transactions (e.g.,
binary matrix, data.frame).</p>
</td></tr>
<tr><td><code id="eclat_+3A_parameter">parameter</code></td>
<td>
<p>object of class <a href="#topic+ECparameter">ECparameter</a> or named
list (default values are: support 0.1 and maxlen 5)</p>
</td></tr>
<tr><td><code id="eclat_+3A_control">control</code></td>
<td>
<p>object of class <a href="#topic+ECcontrol">ECcontrol</a> or named list
for algorithmic controls.</p>
</td></tr>
<tr><td><code id="eclat_+3A_...">...</code></td>
<td>
<p>Additional arguments are added for convenience to the parameter list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calls the C implementation of the Eclat algorithm by Christian Borgelt for
mining frequent itemsets.
</p>
<p>Eclat can also return the transaction IDs for each found itemset using
<code>tidLists = TRUE</code> as a parameter and the result can be retrieved as a
<a href="#topic+tidLists">tidLists</a> object with method <code>tidLists()</code> for class
<a href="#topic+itemsets">itemsets</a>.  Note that storing transaction ID lists is
very memory intensive, creating transaction ID lists only works for minimum
support values which create a relatively small number of itemsets.  See also
<code><a href="#topic+supportingTransactions">supportingTransactions()</a></code>.
</p>
<p><code><a href="#topic+ruleInduction">ruleInduction()</a></code> can be used to generate rules from the found
itemsets.
</p>
<p>A weighted version of ECLAT is available as function <code><a href="#topic+weclat">weclat()</a></code>.
This version can be used to perform weighted association rule mining (WARM).
</p>


<h3>Value</h3>

<p>Returns an object of class <a href="#topic+itemsets">itemsets</a>.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler and Bettina Gruen
</p>


<h3>References</h3>

<p>Mohammed J. Zaki, Srinivasan Parthasarathy, Mitsunori Ogihara,
and Wei Li. (1997) <em>New algorithms for fast discovery of association
rules</em>.  KDD'97: Proceedings of the Third International Conference on
Knowledge Discovery and Data Mining, August 1997, Pages 283-286.
</p>
<p>Christian Borgelt (2003) Efficient Implementations of Apriori and Eclat.
<em>Workshop of Frequent Item Set Mining Implementations</em> (FIMI 2003,
Melbourne, FL, USA).
</p>
<p>ECLAT Implementation: <a href="https://borgelt.net/eclat.html">https://borgelt.net/eclat.html</a>
</p>


<h3>See Also</h3>

<p>Other mining algorithms: 
<code><a href="#topic+APappearance-class">APappearance-class</a></code>,
<code><a href="#topic+AScontrol-classes">AScontrol-classes</a></code>,
<code><a href="#topic+ASparameter-classes">ASparameter-classes</a></code>,
<code><a href="#topic+apriori">apriori</a>()</code>,
<code><a href="#topic+fim4r">fim4r</a>()</code>,
<code><a href="#topic+ruleInduction">ruleInduction</a>()</code>,
<code><a href="#topic+weclat">weclat</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Adult")
## Mine itemsets with minimum support of 0.1 and 5 or less items
itemsets &lt;- eclat(Adult,
		parameter = list(supp = 0.1, maxlen = 5))
itemsets

## Create rules from the frequent itemsets
rules &lt;- ruleInduction(itemsets, confidence = .9)
rules
</code></pre>

<hr>
<h2 id='Epub'>The Epub Transactions Data Set</h2><span id='topic+Epub'></span>

<h3>Description</h3>

<p>The <code>Epub</code> data set contains the download history of documents from the
electronic publication platform of the Vienna University of Economics and
Business Administration.  The data was recorded between Jan 2003 and Dec
2008.
</p>


<h3>Format</h3>

<p>Object of class <a href="#topic+transactions">transactions</a>
with 15729 transactions
and 936 items.
Item labels are document IDs of the form <code>"doc_11d"</code>.
Session IDs and time stamps for transactions are also provided as transaction information.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>Source</h3>

<p>Provided by Michael Hahsler from the custom information system ePub-WU
at <a href="https://epub.wu-wien.ac.at">https://epub.wu-wien.ac.at</a> (which has been replaced by eprint).
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
data(Epub)
inspect(head(Epub))
</code></pre>

<hr>
<h2 id='extract'>Methods for &quot;[&quot;: Extraction or Subsetting arules Objects</h2><span id='topic+extract'></span><span id='topic++22+5B-methods+22'></span><span id='topic++5B+2CitemMatrix+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+2Ctransactions+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+2CtidLists+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+2Crules+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+2Citemsets+2CANY+2CANY+2CANY-method'></span>

<h3>Description</h3>

<p>Methods for <code>"["</code>, i.e., extraction or subsetting for arules objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'itemMatrix,ANY,ANY,ANY'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'transactions,ANY,ANY,ANY'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'tidLists,ANY,ANY,ANY'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'rules,ANY,ANY,ANY'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'itemsets,ANY,ANY,ANY'
x[i, j, ..., drop = TRUE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_+3A_x">x</code></td>
<td>
<p>an object of class <a href="#topic+itemMatrix">itemMatrix</a>, <a href="#topic+transactions">transactions</a> or <a href="#topic+associations">associations</a>.</p>
</td></tr>
<tr><td><code id="extract_+3A_i">i</code></td>
<td>
<p>select rows/sets using an integer vector containing row
numbers or a logical vector.</p>
</td></tr>
<tr><td><code id="extract_+3A_j">j</code></td>
<td>
<p>select columns/items using an integer vector containing column
numbers (i.e., item IDs), a logical vector or a vector of strings containing parts of item labels.</p>
</td></tr>
<tr><td><code id="extract_+3A_...">...</code></td>
<td>
<p>further arguments are ignored.</p>
</td></tr>
<tr><td><code id="extract_+3A_drop">drop</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other associations functions: 
<code><a href="#topic+abbreviate">abbreviate</a>()</code>,
<code><a href="#topic+associations-class">associations-class</a></code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+duplicated">duplicated</a>()</code>,
<code><a href="#topic+inspect">inspect</a>()</code>,
<code><a href="#topic+is.closed">is.closed</a>()</code>,
<code><a href="#topic+is.generator">is.generator</a>()</code>,
<code><a href="#topic+is.maximal">is.maximal</a>()</code>,
<code><a href="#topic+is.redundant">is.redundant</a>()</code>,
<code><a href="#topic+is.significant">is.significant</a>()</code>,
<code><a href="#topic+is.superset">is.superset</a>()</code>,
<code><a href="#topic+itemsets-class">itemsets-class</a></code>,
<code><a href="#topic+match">match</a>()</code>,
<code><a href="#topic+rules-class">rules-class</a></code>,
<code><a href="#topic+sample">sample</a>()</code>,
<code><a href="#topic+sets">sets</a></code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+sort">sort</a>()</code>,
<code><a href="#topic+unique">unique</a>()</code>
</p>
<p>Other itemMatrix and transactions functions: 
<code><a href="#topic+abbreviate">abbreviate</a>()</code>,
<code><a href="#topic+crossTable">crossTable</a>()</code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+duplicated">duplicated</a>()</code>,
<code><a href="#topic+hierarchy">hierarchy</a></code>,
<code><a href="#topic+image">image</a>()</code>,
<code><a href="#topic+inspect">inspect</a>()</code>,
<code><a href="#topic+is.superset">is.superset</a>()</code>,
<code><a href="#topic+itemFrequencyPlot">itemFrequencyPlot</a>()</code>,
<code><a href="#topic+itemFrequency">itemFrequency</a>()</code>,
<code><a href="#topic+itemMatrix-class">itemMatrix-class</a></code>,
<code><a href="#topic+match">match</a>()</code>,
<code><a href="#topic+merge">merge</a>()</code>,
<code><a href="#topic+random.transactions">random.transactions</a>()</code>,
<code><a href="#topic+sample">sample</a>()</code>,
<code><a href="#topic+sets">sets</a></code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+supportingTransactions">supportingTransactions</a>()</code>,
<code><a href="#topic+tidLists-class">tidLists-class</a></code>,
<code><a href="#topic+transactions-class">transactions-class</a></code>,
<code><a href="#topic+unique">unique</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Adult)
Adult

## select first 10 transactions
Adult[1:10]

## select first 10 items for first 100 transactions
Adult[1:100, 1:10]

## select the first 100 transactions for the items containing
## "income" or "age=Young" in their labels
Adult[1:100, c("income=small", "income=large" ,"age=Young")]
</code></pre>

<hr>
<h2 id='fim4r'>Interface to Mining Algorithms from fim4r</h2><span id='topic+fim4r'></span><span id='topic+fpgrowth'></span><span id='topic+FPgrowth'></span><span id='topic+carpenter'></span><span id='topic+ista'></span><span id='topic+IsTa'></span><span id='topic+relim'></span><span id='topic+RElim'></span><span id='topic+sam'></span><span id='topic+SaM'></span>

<h3>Description</h3>

<p>Interfaces the algorithms implemented in fim4r. The algorithms include:
Apriori, Eclat, FPgrowth, Carpenter, IsTa, RElim and SaM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fim4r(
  transactions,
  method = NULL,
  target = "frequent",
  support = 0.1,
  confidence = 0.8,
  originalSupport = TRUE,
  appear = NULL,
  report = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fim4r_+3A_transactions">transactions</code></td>
<td>
<p>a <a href="#topic+transactions">transactions</a> object</p>
</td></tr>
<tr><td><code id="fim4r_+3A_method">method</code></td>
<td>
<p>the algorithm to be used. One of:
</p>

<ul>
<li> <p><code>"apriori"</code>, <code>"eclat"</code>, <code>"fpgrowth"</code> can mine itemsets and rules.
</p>
</li>
<li> <p><code>"relim"</code>, <code>"sam"</code> can mine itemsets.
</p>
</li>
<li> <p><code>"carpenter"</code>, <code>"ista"</code>  can only mine closed itemset.
</p>
</li></ul>
</td></tr>
<tr><td><code id="fim4r_+3A_target">target</code></td>
<td>
<p>the target type. One of: <code>"frequent"</code>,
<code>"closed"</code>, <code>"maximal"</code>, <code>"generators"</code> or <code>"rules"</code>.</p>
</td></tr>
<tr><td><code id="fim4r_+3A_support">support</code></td>
<td>
<p>a numeric value for the minimal support in the range <code class="reqn">[0,1]</code>.</p>
</td></tr>
<tr><td><code id="fim4r_+3A_confidence">confidence</code></td>
<td>
<p>a numeric value for the minimal confidence of rules in the range <code class="reqn">[0,1]</code>.</p>
</td></tr>
<tr><td><code id="fim4r_+3A_originalsupport">originalSupport</code></td>
<td>
<p>logical; Use the support threshold on the support of the whole rule (LHS and RHS).
If <code>FALSE</code>, then LHS support (i.e., coverage) is used by the support threshold.</p>
</td></tr>
<tr><td><code id="fim4r_+3A_appear">appear</code></td>
<td>
<p>Specify item appearance in rules (only for apriori, eclat, fpgrowth
and the target <code>"rules"</code>) Specify a list with two vectors (item labels and
appearance modifiers) of the same length. Appearance modifiers are:
</p>

<ul>
<li> <p><code>"-"</code> (item may not appear in a rule),
</p>
</li>
<li> <p><code>"a"</code> (item may only appear a rule antecedent/LHS),
</p>
</li>
<li> <p><code>"c"</code> (item may only appear a rule consequent/RHS),
</p>
</li>
<li> <p><code>"x"</code> (item may appear anywhere).
</p>
</li></ul>
</td></tr>
<tr><td><code id="fim4r_+3A_report">report</code></td>
<td>
<p>cannot be used via the interface.</p>
</td></tr>
<tr><td><code id="fim4r_+3A_verbose">verbose</code></td>
<td>
<p>logical; print used parameters?</p>
</td></tr>
<tr><td><code id="fim4r_+3A_...">...</code></td>
<td>
<p>further arguments are passed on to the function
the <code>fim4r::fim4r</code> function for the given method. Examples
are: <code>zmin</code>, <code>zmax</code>, <code>wgts</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Installation:</strong>
The package <span class="pkg">fim4r</span> is not available via CRAN. If needed,
the <code>fim4r()</code> function downloads and installs the current version of the
package automatically. Your system needs to have build tools installed.
</p>
<p>Build tools: You need to be able to install source packages. For Windows
users this means that you need to install the
<a href="https://cran.r-project.org/bin/windows/Rtools/">RTools</a> with a version
matching your R version.
</p>
<p><strong>Additional Notes:</strong>
</p>

<ul>
<li><p> Support and confidence are specified here in the range <code class="reqn">[0,1]</code>.
This is different from the use in  <code>fim4r</code> package where <code>supp</code> and <code>conf</code>
have the range <code class="reqn">[0, 100]</code>.
<code>arules::fim4r()</code> automatically converts support and confidence internally.
</p>
</li>
<li> <p><code>fim4r</code> methods also return the empty itemset while <code>arules</code> methods do not.
</p>
</li>
<li><p> See <code>? fim4r::fim4r</code> for help on additional available arguments. This is only available
after package <code>fim4r</code> is installed.
</p>
</li>
<li><p> Algorithm descriptions and references can be found on the
<a href="https://borgelt.net/fim4r.html">fim4r web page</a> in the References Section.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <a href="#topic+itemsets">itemsets</a> or <a href="#topic+rules">rules</a>.
</p>


<h3>References</h3>

<p>Christian Borgelt, fimi4r: Frequent Item Set Mining and Association Rule Induction for R.
<a href="https://borgelt.net/fim4r.html">https://borgelt.net/fim4r.html</a>
</p>


<h3>See Also</h3>

<p>Other mining algorithms: 
<code><a href="#topic+APappearance-class">APappearance-class</a></code>,
<code><a href="#topic+AScontrol-classes">AScontrol-classes</a></code>,
<code><a href="#topic+ASparameter-classes">ASparameter-classes</a></code>,
<code><a href="#topic+apriori">apriori</a>()</code>,
<code><a href="#topic+eclat">eclat</a>()</code>,
<code><a href="#topic+ruleInduction">ruleInduction</a>()</code>,
<code><a href="#topic+weclat">weclat</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(Adult)

# list available algorithms
fim4r()

# mine association rules with FPgrowth
r &lt;- fim4r(Adult, method = "fpgrowth", 
  target = "rules", supp = .7, conf = .8)
r
inspect(head(r, by = "lift"))

# mine closed itemsets with Carpenter or IsTa
fim4r(Adult, method = "carpenter", 
  target = "closed", supp = .7)
fim4r(Adult, method = "ista", 
  target = "closed", supp = .7)

# mine frequent itemset of length 2 (zmin and zmax = 2)
freq_2 &lt;- fim4r(Adult, method = "relim", target = "frequent", supp = .7,
  zmin = 2, zmax = 2)
inspect(freq_2)

# mine maximal frequent itemsets
mfis &lt;- fim4r(Adult, method = "sam", target = "maximal", supp = .7)
inspect(mfis)

# Examples for how to use item appearance with apriori, eclat, 
#   fpgrowth in fim4r. We first mine all rules.
inspect(fim4r(Adult, method = "fpgrowth", 
  target = "rules", supp = .8))

# ignore item "capital-gain=None"
inspect(fim4r(Adult, method = "fpgrowth", 
  target = "rules", supp = .8,
  appear = list(c("capital-gain=None"), c("-"))))

# "capital-gain=None" cannot appear in consequent (antecedent only)
inspect(fim4r(Adult, method = "fpgrowth", 
  target = "rules", supp = .8,
  appear = list(c("capital-gain=None"), c("a"))))

# "capital-gain=None" cannot appear in the antecedent
inspect(fim4r(Adult, method = "fpgrowth", 
  target = "rules", supp = .8,
  appear = list(c("capital-gain=None"), c("c"))))

# restrict the consequent to the item "capital-gain=None".
# That is, "" = all items can only appear in the antecedent with the 
# exception that "capital-gain=None" can only appear in the consequent.
inspect(fim4r(Adult, method = "fpgrowth", 
  target = "rules", supp = .8,
  appear = list(c("", "capital-gain=None"), c("a", "c"))))

## End(Not run)
</code></pre>

<hr>
<h2 id='Groceries'>The Groceries Transactions Data Set</h2><span id='topic+Groceries'></span><span id='topic+groceries'></span>

<h3>Description</h3>

<p>The <code>Groceries</code> data set contains 1 month (30 days) of real-world
point-of-sale transaction data from a typical local grocery outlet.  The
data set contains 9835 transactions and the items are aggregated to 169
categories.
</p>


<h3>Format</h3>

<p>Object of class <a href="#topic+transactions">transactions</a>.
</p>


<h3>Details</h3>

<p>If you use this data set in your paper, please cite to the paper in the
References Section.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>Source</h3>

<p>The data set is provided for arules by Michael Hahsler, Kurt Hornik
and Thomas Reutterer.
</p>


<h3>References</h3>

<p>Michael Hahsler, Kurt Hornik, and Thomas Reutterer (2006)
Implications of probabilistic data modeling for mining association rules. In
M. Spiliopoulou, R. Kruse, C. Borgelt, A. Nuernberger, and W. Gaul, editors,
<em>From Data and Information Analysis to Knowledge Engineering, Studies
in Classification, Data Analysis, and Knowledge Organization</em>, pages
598&ndash;605. Springer-Verlag.
</p>

<hr>
<h2 id='hierarchy'>Support for Item Hierarchies</h2><span id='topic+hierarchy'></span><span id='topic+addAggregate'></span><span id='topic+aggregate'></span><span id='topic+filterAggregate'></span><span id='topic+aggregate+2CitemMatrix-method'></span><span id='topic+aggregate+2Citemsets-method'></span><span id='topic+aggregate+2Crules-method'></span>

<h3>Description</h3>

<p>Functions to use item hierarchies to aggregate items at different
group levels, to perform multi-level transaction analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addAggregate(x, by, postfix = "*")

filterAggregate(x)

aggregate(x, ...)

## S4 method for signature 'itemMatrix'
aggregate(x, by)

## S4 method for signature 'itemsets'
aggregate(x, by)

## S4 method for signature 'rules'
aggregate(x, by)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hierarchy_+3A_x">x</code></td>
<td>
<p>an transactions, itemsets or rules object.</p>
</td></tr>
<tr><td><code id="hierarchy_+3A_by">by</code></td>
<td>
<p>name of a field (hierarchy level) available in
<a href="#topic+itemInfo">itemInfo</a> of <code>x</code> or a grouping vector of the same length
as items in <code>x</code> by which should be aggregated. Items with the same
group label in <code>by</code> will be aggregated into a single with that name.
Note that the grouping vector will be coerced to factor before use.</p>
</td></tr>
<tr><td><code id="hierarchy_+3A_postfix">postfix</code></td>
<td>
<p>characters added to mark group-level items.</p>
</td></tr>
<tr><td><code id="hierarchy_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Often an item hierarchy is available for <a href="#topic+transactions">transactions</a>
used for association rule
mining. For example in a supermarket dataset items like &quot;bread&quot; and &quot;beagle&quot;
might belong to the item group (category) &quot;baked goods.&quot;
</p>
<p>Transactions can store item hierarchies as additional columns in the
itemInfo data.frame (<code>"labels"</code> cannot be used since it is reserved for
the item labels).
</p>
<p><b>Aggregation:</b> To perform analysis at a group level of the item
hierarchy, <code>aggregate()</code> produces a new object with items aggregated to
a given group level. A group-level item is present if one or more of the
items in the group are present in the original object.  If rules are
aggregated, and the aggregation would lead to the same aggregated group item
in the lhs and in the rhs, then that group item is removed from the lhs.
Rules or itemsets, which are not unique after the aggregation, are also
removed. Note also that the quality measures are not applicable to the new
rules and thus are removed.  If these measures are required, then aggregate
the transactions before mining rules.
</p>
<p><b>Multi-level analysis:</b> To analyze relationships between individual
items and item groups at the same time, <code>addAggregate()</code> can be used to
create a new transactions object which contains both, the original items and
group-level items (marked with a given postfix). In association rule mining,
all items are handled the same, which means that we will produce a large
number of rules of the type:
</p>
<p><code style="white-space: pre;">&#8288;item A =&gt; group of item A&#8288;</code>
</p>
<p>with a confidence of 1. This will also happen if you mine itemsets.
<code>filterAggregate()</code> can be used to filter these spurious rules or
itemsets.
</p>


<h3>Value</h3>

<p><code>aggregate()</code> returns an object of the same class as <code>x</code>
encoded with a number of items equal to the number of unique values in
<code>by</code>. Note that for associations (itemsets and rules) the number of
associations in the returned set will most likely be reduced since several
associations might map to the same aggregated association and aggregate
returns a unique set. If several associations map to a single aggregated
association then the quality measures of one of the original associations is
randomly chosen.
</p>
<p><code>addAggregate()</code> returns a new transactions object with the original
items and the group-items added. <code>filterAggregateRules()</code> returns a new
rules object with the spurious rules remove.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other preprocessing: 
<code><a href="#topic+discretize">discretize</a>()</code>,
<code><a href="#topic+itemCoding">itemCoding</a></code>,
<code><a href="#topic+merge">merge</a>()</code>,
<code><a href="#topic+sample">sample</a>()</code>
</p>
<p>Other itemMatrix and transactions functions: 
<code><a href="#topic+abbreviate">abbreviate</a>()</code>,
<code><a href="#topic+crossTable">crossTable</a>()</code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+duplicated">duplicated</a>()</code>,
<code><a href="#topic+extract">extract</a></code>,
<code><a href="#topic+image">image</a>()</code>,
<code><a href="#topic+inspect">inspect</a>()</code>,
<code><a href="#topic+is.superset">is.superset</a>()</code>,
<code><a href="#topic+itemFrequencyPlot">itemFrequencyPlot</a>()</code>,
<code><a href="#topic+itemFrequency">itemFrequency</a>()</code>,
<code><a href="#topic+itemMatrix-class">itemMatrix-class</a></code>,
<code><a href="#topic+match">match</a>()</code>,
<code><a href="#topic+merge">merge</a>()</code>,
<code><a href="#topic+random.transactions">random.transactions</a>()</code>,
<code><a href="#topic+sample">sample</a>()</code>,
<code><a href="#topic+sets">sets</a></code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+supportingTransactions">supportingTransactions</a>()</code>,
<code><a href="#topic+tidLists-class">tidLists-class</a></code>,
<code><a href="#topic+transactions-class">transactions-class</a></code>,
<code><a href="#topic+unique">unique</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Groceries")
Groceries

## Groceries contains a hierarchy stored in itemInfo
head(itemInfo(Groceries))

## Example 1: Aggregate items using an existing hierarchy stored in itemInfo.
## We aggregate to level2 stored in Groceries. All items with the same level2 label
## will become a single item with that name.
## Note that the number of items is therefore reduced to 55
Groceries_level2 &lt;- aggregate(Groceries, by = "level2")
Groceries_level2
head(itemInfo(Groceries_level2)) ## labels are alphabetically sorted!


## compare original and aggregated transactions
inspect(head(Groceries, 2))
inspect(head(Groceries_level2, 2))

## Example 2: Aggregate using a character vector.
## We create here labels manually to organize items by their first letter.
mylevels &lt;- toupper(substr(itemLabels(Groceries), 1, 1))
head(mylevels)

Groceries_alpha &lt;- aggregate(Groceries, by = mylevels)
Groceries_alpha
inspect(head(Groceries_alpha, 2))

## Example 3: Aggregate rules
## Note: You could also directly mine rules from aggregated transactions to
## get support, lift and support
rules &lt;- apriori(Groceries, parameter = list(supp = 0.005, conf = 0.5))
rules
inspect(rules[1])

rules_level2 &lt;- aggregate(rules, by = "level2")
inspect(rules_level2[1])

## Example 4: Mine multi-level rules.
## (1) Add aggregate items. These items will have labels ending with a *
Groceries_multilevel &lt;- addAggregate(Groceries, "level2")
summary(Groceries_multilevel)
inspect(head(Groceries_multilevel))

rules &lt;- apriori(Groceries_multilevel,
  parameter = list(support = 0.01, conf = .9))
inspect(head(rules, by = "lift"))
## Note that this contains many spurious rules of type 'item X =&gt; aggregate of item X'
## with a confidence of 1 and high lift. We can filter spurious rules resulting from
## the aggregation
rules &lt;- filterAggregate(rules)
inspect(head(rules, by = "lift"))
</code></pre>

<hr>
<h2 id='hits'>Computing Transaction Weights With HITS</h2><span id='topic+hits'></span>

<h3>Description</h3>

<p>Compute the hub transaction weights for a collection
of <a href="#topic+transactions">transactions</a> using the HITS (hubs and authorities) algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hits(
  data,
  iter = 16L,
  tol = NULL,
  type = c("normed", "relative", "absolute"),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hits_+3A_data">data</code></td>
<td>
<p>an object of or coercible to class <a href="#topic+transactions">transactions</a>.</p>
</td></tr>
<tr><td><code id="hits_+3A_iter">iter</code></td>
<td>
<p>an integer value specifying the maximum number of iterations to
use.</p>
</td></tr>
<tr><td><code id="hits_+3A_tol">tol</code></td>
<td>
<p>convergence tolerance (default <code>FLT_EPSILON</code>).</p>
</td></tr>
<tr><td><code id="hits_+3A_type">type</code></td>
<td>
<p>a string value specifying the norming of the hub weights.  For
<code>"normed"</code> scale the weights to unit length (L2 norm), and for
<code>"relative"</code> to unit sum.</p>
</td></tr>
<tr><td><code id="hits_+3A_verbose">verbose</code></td>
<td>
<p>a logical specifying if progress and runtime information
should be displayed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Model a collection of <a href="#topic+transactions">transactions</a> as a bipartite graph of hubs
(transactions) and authorities (items) with unit arcs and free node weights.
That is, a transaction weight is the sum of the (normalized) weights of the
items and vice versa. The weights are estimated by iterating the model to a
steady-state using a builtin convergence tolerance of <code>FLT_EPSILON</code> for
(the change in) the norm of the vector of authorities.
</p>


<h3>Value</h3>

<p>A <code>numeric</code> vector with transaction weights for <code>data</code>.
</p>


<h3>Author(s)</h3>

<p>Christian Buchta
</p>


<h3>References</h3>

<p>K. Sun and F. Bai (2008). Mining Weighted Association Rules
without Preassigned Weights. <em>IEEE Transactions on Knowledge and Data
Engineering</em>, 4 (30), 489&ndash;495.
</p>


<h3>See Also</h3>

<p>Other weighted association mining functions: 
<code><a href="#topic+SunBai">SunBai</a></code>,
<code><a href="#topic+weclat">weclat</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(SunBai)

## calculate transaction weigths
w &lt;- hits(SunBai)
w

## add transaction weight to the dataset
transactionInfo(SunBai)[["weight"]] &lt;- w
transactionInfo(SunBai)

## calulate regular item frequencies
itemFrequency(SunBai, weighted = FALSE)

## calulate weighted item frequencies
itemFrequency(SunBai, weighted = TRUE)
</code></pre>

<hr>
<h2 id='image'>Visual Inspection of Binary Incidence Matrices</h2><span id='topic+image'></span><span id='topic+image+2CitemMatrix-method'></span><span id='topic+image+2Ctransactions-method'></span><span id='topic+image+2CtidLists-method'></span>

<h3>Description</h3>

<p>Provides <code>image()</code> methods to generate level plots to visually
inspect binary incidence matrices, i.e., objects based on
<a href="#topic+itemMatrix">itemMatrix</a> (e.g., <a href="#topic+transactions">transactions</a>, <a href="#topic+tidLists">tidLists</a>, items in
<a href="#topic+itemsets">itemsets</a> or rhs/lhs in <a href="#topic+rules">rules</a>).  These plots can be used to identify problems
in a data set (e.g., recording problems with some transactions containing
all items).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'itemMatrix'
image(x, xlab = "Items (Columns)", ylab = "Elements (Rows)", ...)

## S4 method for signature 'transactions'
image(x, xlab = "Items (Columns)", ylab = "Transactions (Rows)", ...)

## S4 method for signature 'tidLists'
image(x, xlab = "Transactions (Columns)", ylab = "Items/itemsets (Rows)", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image_+3A_x">x</code></td>
<td>
<p>the object (<a href="#topic+itemMatrix">itemMatrix</a>, <a href="#topic+transactions">transactions</a> or
<a href="#topic+tidLists">tidLists</a>).</p>
</td></tr>
<tr><td><code id="image_+3A_xlab">xlab</code>, <code id="image_+3A_ylab">ylab</code></td>
<td>
<p>labels for the plot.</p>
</td></tr>
<tr><td><code id="image_+3A_...">...</code></td>
<td>
<p>further arguments passed on to <code>image()</code> in package
<span class="pkg">Matrix</span> which in turn are passed on to <code>levelplot()</code> in
<span class="pkg">lattice</span>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p><code>image()</code> in package <span class="pkg">Matrix</span>
</p>
<p>Other itemMatrix and transactions functions: 
<code><a href="#topic+abbreviate">abbreviate</a>()</code>,
<code><a href="#topic+crossTable">crossTable</a>()</code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+duplicated">duplicated</a>()</code>,
<code><a href="#topic+extract">extract</a></code>,
<code><a href="#topic+hierarchy">hierarchy</a></code>,
<code><a href="#topic+inspect">inspect</a>()</code>,
<code><a href="#topic+is.superset">is.superset</a>()</code>,
<code><a href="#topic+itemFrequencyPlot">itemFrequencyPlot</a>()</code>,
<code><a href="#topic+itemFrequency">itemFrequency</a>()</code>,
<code><a href="#topic+itemMatrix-class">itemMatrix-class</a></code>,
<code><a href="#topic+match">match</a>()</code>,
<code><a href="#topic+merge">merge</a>()</code>,
<code><a href="#topic+random.transactions">random.transactions</a>()</code>,
<code><a href="#topic+sample">sample</a>()</code>,
<code><a href="#topic+sets">sets</a></code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+supportingTransactions">supportingTransactions</a>()</code>,
<code><a href="#topic+tidLists-class">tidLists-class</a></code>,
<code><a href="#topic+transactions-class">transactions-class</a></code>,
<code><a href="#topic+unique">unique</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Epub")

## in this data set we can see that not all
## items were available from the beginning.
image(Epub[1:1000])
</code></pre>

<hr>
<h2 id='Income'>The Income Data Set</h2><span id='topic+Income'></span><span id='topic+income'></span><span id='topic+IncomeESL'></span>

<h3>Description</h3>

<p>Survey example data from the book <em>The Elements of Statistical Learning</em>.
</p>


<h3>Format</h3>

<p>The data is provided in two formats:
</p>

<ol>
<li> <p><code>Income</code> is an object of class <a href="#topic+transactions">transactions</a>
with 6876 transactions (complete cases)
and 50 items. See below for details.
</p>
</li>
<li> <p><code>IncomeESL</code> is a data frame with 8993 observations on the
following 14 variables:
</p>
</li></ol>


<dl>
<dt>income</dt><dd><p>an ordered factor with
levels <code style="white-space: pre;">&#8288;[0,10)&#8288;</code> &lt; <code style="white-space: pre;">&#8288;[10,15)&#8288;</code> &lt; <code style="white-space: pre;">&#8288;[15,20)&#8288;</code> &lt; <code style="white-space: pre;">&#8288;[20,25)&#8288;</code> &lt;
<code style="white-space: pre;">&#8288;[25,30)&#8288;</code> &lt; <code style="white-space: pre;">&#8288;[30,40)&#8288;</code> &lt; <code style="white-space: pre;">&#8288;[40,50)&#8288;</code> &lt; <code style="white-space: pre;">&#8288;[50,75)&#8288;</code> &lt;
<code style="white-space: pre;">&#8288;75+&#8288;</code></p>
</dd>
<dt>sex</dt><dd><p>a factor with levels <code>male</code> <code>female</code></p>
</dd>
<dt>marital status</dt><dd><p>a factor with levels <code>married</code>
<code>cohabitation</code> <code>divorced</code> <code>widowed</code> <code>single</code></p>
</dd>
<dt>age</dt><dd><p>an ordered factor with levels <code>14-17</code> &lt; <code>18-24</code> &lt;
<code>25-34</code> &lt; <code>35-44</code> &lt; <code>45-54</code> &lt; <code>55-64</code> &lt; <code style="white-space: pre;">&#8288;65+&#8288;</code></p>
</dd>
<dt>education</dt><dd><p>an ordered factor with levels <code>grade &lt;9</code> &lt;
<code style="white-space: pre;">&#8288;grades 9-11&#8288;</code> &lt; <code style="white-space: pre;">&#8288;high school graduate&#8288;</code> &lt; <code>college (1-3
years)</code> &lt; <code style="white-space: pre;">&#8288;college graduate&#8288;</code> &lt; <code style="white-space: pre;">&#8288;graduate study&#8288;</code></p>
</dd>
<dt>occupation</dt><dd><p>a factor with levels <code>professional/managerial</code>
<code>sales</code> <code>laborer</code> <code>clerical/service</code> <code>homemaker</code>
<code>student</code> <code>military</code> <code>retired</code> <code>unemployed</code></p>
</dd>
<dt>years
in bay area</dt><dd><p>an ordered factor with levels <code style="white-space: pre;">&#8288;&lt;1&#8288;</code> &lt; <code>1-3</code> &lt;
<code>4-6</code> &lt; <code>7-10</code> &lt; <code style="white-space: pre;">&#8288;&gt;10&#8288;</code></p>
</dd>
<dt>dual incomes</dt><dd><p>a factor with
levels <code style="white-space: pre;">&#8288;not married&#8288;</code> <code>yes</code> <code>no</code></p>
</dd>
<dt>number in
household</dt><dd><p>an ordered factor with levels <code>1</code> &lt; <code>2</code> &lt; <code>3</code> &lt;
<code>4</code> &lt; <code>5</code> &lt; <code>6</code> &lt; <code>7</code> &lt; <code>8</code> &lt; <code style="white-space: pre;">&#8288;9+&#8288;</code></p>
</dd>
<dt>number of children</dt><dd><p>an ordered factor with levels <code>0</code> &lt; <code>1</code>
&lt; <code>2</code> &lt; <code>3</code> &lt; <code>4</code> &lt; <code>5</code> &lt; <code>6</code> &lt; <code>7</code> &lt; <code>8</code>
&lt; <code style="white-space: pre;">&#8288;9+&#8288;</code></p>
</dd> <dt>householder status</dt><dd><p>a factor with levels <code>own</code>
<code>rent</code> <code style="white-space: pre;">&#8288;live with parents/family&#8288;</code></p>
</dd>
<dt>type of home</dt><dd><p>a factor
with levels <code>house</code> <code>condominium</code> <code>apartment</code> <code>mobile
Home</code> <code>other</code></p>
</dd>
<dt>ethnic classification</dt><dd><p>a factor with levels
<code style="white-space: pre;">&#8288;american indian&#8288;</code> <code>asian</code> <code>black</code> <code style="white-space: pre;">&#8288;east indian&#8288;</code>
<code>hispanic</code> <code style="white-space: pre;">&#8288;pacific islander&#8288;</code> <code>white</code> <code>other</code></p>
</dd>
<dt>language in home</dt><dd><p>a factor with levels <code>english</code> <code>spanish</code>
<code>other</code></p>
</dd> </dl>



<h3>Details</h3>

<p>The <code>IncomeESL</code> data set originates from an example in the book
<em>The Elements of Statistical Learning</em> (see Section source).  The
data set is an extract from this survey.  It consists of 8993 instances
(obtained from the original data set with 9409 instances, by removing those
observations with the annual income missing) with 14 demographic attributes.
The data set is a good mixture of categorical and continuous variables with
a lot of missing data.  This is characteristic of data mining applications.
The Income data set contains the data already prepared and coerced to
<a href="#topic+transactions">transactions</a>.
</p>
<p>To create transactions for Income, the original data frame
in <code>IncomeESL</code> is prepared in a similar way as described in <em>The
Elements of Statistical Learning.</em> We removed cases with missing values and
cut each ordinal variable (age, education, income, years in bay area, number
in household, and number of children) at its median into two values (see
Section examples).
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>Source</h3>

<p>Impact Resources, Inc., Columbus, OH (1987).
</p>
<p>Obtained from the web site of the book: Hastie, T., Tibshirani, R. &amp;
Friedman, J. (2001) <em>The Elements of Statistical Learning</em>.
Springer-Verlag.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("IncomeESL")
IncomeESL[1:3, ]

## remove incomplete cases
IncomeESL &lt;- IncomeESL[complete.cases(IncomeESL), ]

## preparing the data set
IncomeESL[["income"]] &lt;- factor((as.numeric(IncomeESL[["income"]]) &gt; 6) +1,
  levels = 1 : 2 , labels = c("$0-$40,000", "$40,000+"))
	  
IncomeESL[["age"]] &lt;- factor((as.numeric(IncomeESL[["age"]]) &gt; 3) +1,
  levels = 1 : 2 , labels = c("14-34", "35+"))

IncomeESL[["education"]] &lt;- factor((as.numeric(IncomeESL[["education"]]) &gt; 4) +1,
  levels = 1 : 2 , labels = c("no college graduate", "college graduate"))

IncomeESL[["years in bay area"]] &lt;- factor(
  (as.numeric(IncomeESL[["years in bay area"]]) &gt; 4) +1,
  levels = 1 : 2 , labels = c("1-9", "10+"))

IncomeESL[["number in household"]] &lt;- factor(
  (as.numeric(IncomeESL[["number in household"]]) &gt; 3) +1,
  levels = 1 : 2 , labels = c("1", "2+"))

IncomeESL[["number of children"]] &lt;- factor(
  (as.numeric(IncomeESL[["number of children"]]) &gt; 1) +0,
  levels = 0 : 1 , labels = c("0", "1+"))
	
##  creating transactions
Income &lt;- transactions(IncomeESL)
Income
</code></pre>

<hr>
<h2 id='inspect'>Display Associations and Transactions in Readable Form</h2><span id='topic+inspect'></span><span id='topic+inspect+2Citemsets-method'></span><span id='topic+inspect+2Crules-method'></span><span id='topic+inspect+2Ctransactions-method'></span><span id='topic+inspect+2CitemMatrix-method'></span><span id='topic+inspect+2CtidLists-method'></span>

<h3>Description</h3>

<p>Provides the generic function <code>inspect()</code> and methods to display
<a href="#topic+associations">associations</a> and <a href="#topic+transactions">transactions</a> plus additional information formatted for
online inspection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inspect(x, ...)

## S4 method for signature 'itemsets'
inspect(x, itemSep = ", ", setStart = "{", setEnd = "}", linebreak = NULL, ...)

## S4 method for signature 'rules'
inspect(
  x,
  itemSep = ", ",
  setStart = "{",
  setEnd = "}",
  ruleSep = "=&gt;",
  linebreak = NULL,
  ...
)

## S4 method for signature 'transactions'
inspect(x, itemSep = ", ", setStart = "{", setEnd = "}", linebreak = NULL, ...)

## S4 method for signature 'itemMatrix'
inspect(x, itemSep = ", ", setStart = "{", setEnd = "}", linebreak = NULL, ...)

## S4 method for signature 'tidLists'
inspect(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inspect_+3A_x">x</code></td>
<td>
<p>a set of <a href="#topic+associations">associations</a> or <a href="#topic+transactions">transactions</a> or an <a href="#topic+itemMatrix">itemMatrix</a>.</p>
</td></tr>
<tr><td><code id="inspect_+3A_...">...</code></td>
<td>
<p>additional arguments.
can be used to customize the output:</p>
</td></tr>
<tr><td><code id="inspect_+3A_itemsep">itemSep</code></td>
<td>
<p>item separator</p>
</td></tr>
<tr><td><code id="inspect_+3A_setstart">setStart</code></td>
<td>
<p>set start symbol</p>
</td></tr>
<tr><td><code id="inspect_+3A_setend">setEnd</code></td>
<td>
<p>set end symbol</p>
</td></tr>
<tr><td><code id="inspect_+3A_linebreak">linebreak</code></td>
<td>
<p>print only one element per line in case the output lines get very long?</p>
</td></tr>
<tr><td><code id="inspect_+3A_rulesep">ruleSep</code></td>
<td>
<p>rule separator</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>inspect()</code> prints the results directly. If you need to create a data.frame
with a human readable version, then you can use <code><a href="#topic+DATAFRAME">DATAFRAME()</a></code>.
</p>


<h3>Value</h3>

<p>Nothing is returned (see the Details Section).
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler and Kurt Hornik
</p>


<h3>See Also</h3>

<p>Other associations functions: 
<code><a href="#topic+abbreviate">abbreviate</a>()</code>,
<code><a href="#topic+associations-class">associations-class</a></code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+duplicated">duplicated</a>()</code>,
<code><a href="#topic+extract">extract</a></code>,
<code><a href="#topic+is.closed">is.closed</a>()</code>,
<code><a href="#topic+is.generator">is.generator</a>()</code>,
<code><a href="#topic+is.maximal">is.maximal</a>()</code>,
<code><a href="#topic+is.redundant">is.redundant</a>()</code>,
<code><a href="#topic+is.significant">is.significant</a>()</code>,
<code><a href="#topic+is.superset">is.superset</a>()</code>,
<code><a href="#topic+itemsets-class">itemsets-class</a></code>,
<code><a href="#topic+match">match</a>()</code>,
<code><a href="#topic+rules-class">rules-class</a></code>,
<code><a href="#topic+sample">sample</a>()</code>,
<code><a href="#topic+sets">sets</a></code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+sort">sort</a>()</code>,
<code><a href="#topic+unique">unique</a>()</code>
</p>
<p>Other itemMatrix and transactions functions: 
<code><a href="#topic+abbreviate">abbreviate</a>()</code>,
<code><a href="#topic+crossTable">crossTable</a>()</code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+duplicated">duplicated</a>()</code>,
<code><a href="#topic+extract">extract</a></code>,
<code><a href="#topic+hierarchy">hierarchy</a></code>,
<code><a href="#topic+image">image</a>()</code>,
<code><a href="#topic+is.superset">is.superset</a>()</code>,
<code><a href="#topic+itemFrequencyPlot">itemFrequencyPlot</a>()</code>,
<code><a href="#topic+itemFrequency">itemFrequency</a>()</code>,
<code><a href="#topic+itemMatrix-class">itemMatrix-class</a></code>,
<code><a href="#topic+match">match</a>()</code>,
<code><a href="#topic+merge">merge</a>()</code>,
<code><a href="#topic+random.transactions">random.transactions</a>()</code>,
<code><a href="#topic+sample">sample</a>()</code>,
<code><a href="#topic+sets">sets</a></code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+supportingTransactions">supportingTransactions</a>()</code>,
<code><a href="#topic+tidLists-class">tidLists-class</a></code>,
<code><a href="#topic+transactions-class">transactions-class</a></code>,
<code><a href="#topic+unique">unique</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Adult")
rules &lt;- apriori(Adult)

## display some rules
inspect(rules[1000:1001])
inspect(rules[1000:1001], ruleSep = "~~&gt;", itemSep = " + ", setStart = "", setEnd = "",
  linebreak = FALSE)

## to get rules in readable format, use coercion or DATAFRAME with additional parameters.
as(rules[1000:1001], "data.frame")
DATAFRAME(rules[1000:1001])
DATAFRAME(rules[1000:1001], separate = TRUE, setStart = "", setEnd = "")

</code></pre>

<hr>
<h2 id='interestMeasure'>Calculate Additional Interest Measures</h2><span id='topic+interestMeasure'></span><span id='topic+interestMeasure+2Citemsets-method'></span><span id='topic+interestMeasure+2Crules-method'></span>

<h3>Description</h3>

<p>Provides the generic function <code>interestMeasure()</code> and the
methods to calculate various additional interest measures for existing sets
of <a href="#topic+itemsets">itemsets</a> or <a href="#topic+rules">rules</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interestMeasure(x, measure, transactions = NULL, reuse = TRUE, ...)

## S4 method for signature 'itemsets'
interestMeasure(x, measure, transactions = NULL, reuse = TRUE, ...)

## S4 method for signature 'rules'
interestMeasure(x, measure, transactions = NULL, reuse = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interestMeasure_+3A_x">x</code></td>
<td>
<p>a set of <a href="#topic+itemsets">itemsets</a> or <a href="#topic+rules">rules</a>.</p>
</td></tr>
<tr><td><code id="interestMeasure_+3A_measure">measure</code></td>
<td>
<p>name or vector of names of the desired interest measures (see
the Details section for available measures). If measure is missing then all available
measures are calculated.</p>
</td></tr>
<tr><td><code id="interestMeasure_+3A_transactions">transactions</code></td>
<td>
<p>the <a href="#topic+transactions">transactions</a> used to mine the associations
or a set of different transactions to calculate interest measures from
(Note: you need to set <code>reuse = FALSE</code> in the later case).</p>
</td></tr>
<tr><td><code id="interestMeasure_+3A_reuse">reuse</code></td>
<td>
<p>logical indicating if information in the quality slot should be
reuse for calculating the measures. This speeds up the process significantly
since only very little (or no) transaction counting is necessary if support,
confidence and lift are already available. Use <code>reuse = FALSE</code> to force
counting (might be very slow but is necessary if you use a different set of
transactions than was used for mining).</p>
</td></tr>
<tr><td><code id="interestMeasure_+3A_...">...</code></td>
<td>
<p>further arguments for the measure calculation. Many measures
are based on contingency table counts and zero counts can produce <code>NaN</code> values
(division by zero). This issue can be resolved by using the additional
parameter <code>smoothCounts</code> which performs additive smoothing by adds a
&quot;pseudo count&quot; of <code>smoothCounts</code> to each cell in the contingency
table. Use <code>smoothCounts = 1</code> or larger values for Laplace smoothing.
Use <code>smoothCounts = .5</code> for Haldane-Anscombe correction (Haldan, 1940; Anscombe, 1956)
which is often used for chi-squared, phi correlation and related measures.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A searchable list of definitions, equations and
references for all available interest measures can be found at
<a href="https://mhahsler.github.io/arules/docs/measures">https://mhahsler.github.io/arules/docs/measures</a>. The descriptions
are also linked in the list below.
</p>
<p>The following measures are implemented for <strong>itemsets</strong>:
</p>

<ul>
<li><p> &quot;support&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#support">Support.</a>
</p>
</li>
<li><p> &quot;count&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#count">Support Count.</a>
</p>
</li>
<li><p> &quot;allConfidence&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#allconfidence">All-Confidence.</a>
</p>
</li>
<li><p> &quot;crossSupportRatio&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#crosssupportratio">Cross-Support Ratio.</a>
</p>
</li>
<li><p> &quot;lift&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#lift">Lift.</a>
</p>
</li></ul>

<p>The following measures are implemented for <strong>rules</strong>:
</p>

<ul>
<li><p> &quot;support&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#support">Support.</a>
</p>
</li>
<li><p> &quot;confidence&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#confidence">Confidence.</a>
</p>
</li>
<li><p> &quot;lift&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#lift">Lift.</a>
</p>
</li>
<li><p> &quot;count&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#count">Support Count.</a>
</p>
</li>
<li><p> &quot;addedValue&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#addedvalue">Added Value.</a>
</p>
</li>
<li><p> &quot;boost&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#boost">Confidence Boost.</a>
</p>
</li>
<li><p> &quot;casualConfidence&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#casualconfidence">Casual Confidence.</a>
</p>
</li>
<li><p> &quot;casualSupport&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#casualsupport">Casual Support.</a>
</p>
</li>
<li><p> &quot;centeredConfidence&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#centeredconfidence">Centered Confidence.</a>
</p>
</li>
<li><p> &quot;certainty&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#certainty">Certainty Factor.</a>
</p>
</li>
<li><p> &quot;chiSquared&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#chisquared">Chi-Squared.</a> Additional parameters are: <code>significance = TRUE</code> returns the p-value of the test for independence instead of the chi-squared statistic. For p-values, substitution effects (the occurrence of one item makes the occurrence of another item less likely) can be tested using the parameter <code>complements = FALSE</code>.  Note: Correction for multiple comparisons can be done using <code><a href="stats.html#topic+p.adjust">stats::p.adjust()</a></code>.
</p>
</li>
<li><p> &quot;collectiveStrength&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#collectivestrength">Collective Strength.</a>
</p>
</li>
<li><p> &quot;confirmedConfidence&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#confirmedconfidence">Descriptive Confirmed Confidence.</a>
</p>
</li>
<li><p> &quot;conviction&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#conviction">Conviction.</a>
</p>
</li>
<li><p> &quot;cosine&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#cosine">Cosine.</a>
</p>
</li>
<li><p> &quot;counterexample&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#counterexample">Example and Counter-Example Rate.</a>
</p>
</li>
<li><p> &quot;coverage&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#coverage">Coverage.</a>
</p>
</li>
<li><p> &quot;doc&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#doc">Difference of Confidence.</a>
</p>
</li>
<li><p> &quot;fishersExactTest&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#fishersexacttest">Fisher's Exact Test.</a> By default complementary effects are mined, substitutes can be found by using the parameter <code>complements = FALSE</code>. Note that Fisher's exact test is equal to hyper-confidence with <code>significance = TRUE</code>. Correction for multiple comparisons can be done using <code><a href="stats.html#topic+p.adjust">stats::p.adjust()</a></code>.
</p>
</li>
<li><p> &quot;gini&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#gini">Gini Index.</a>
</p>
</li>
<li><p> &quot;hyperConfidence&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#hyperconfidence">Hyper-Confidence.</a> Reports the confidence level by default and the significance level if <code>significance = TRUE</code> is used. By default complementary effects are mined, substitutes (too low co-occurrence counts) can be found by using the parameter <code>complements = FALSE</code>.
</p>
</li>
<li><p> &quot;hyperLift&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#hyperlift">Hyper-Lift.</a> The used quantile can be changed using parameter <code>level</code> (default: <code>level = 0.99</code>).
</p>
</li>
<li><p> &quot;imbalance&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#imbalance">Imbalance Ratio.</a>
</p>
</li>
<li><p> &quot;implicationIndex&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#implicationindex">Implication Index.</a>
</p>
</li>
<li><p> &quot;importance&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#importance">Importance.</a>
</p>
</li>
<li><p> &quot;improvement&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#improvement">Improvement.</a> The additional parameter <code>improvementMeasure</code> (default: <code>'confidence'</code>) can be used to specify the measure used for the improvement calculation. See <a href="https://mhahsler.github.io/arules/docs/measures#generalizedImprovement">Generalized improvement</a>.
</p>
</li>
<li><p> &quot;jaccard&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#jaccard">Jaccard Coefficient.</a>
</p>
</li>
<li><p> &quot;jMeasure&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#jmeasure">J-Measure.</a>
</p>
</li>
<li><p> &quot;kappa&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#kappa">Kappa.</a>
</p>
</li>
<li><p> &quot;kulczynski&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#kulczynski">Kulczynski.</a>
</p>
</li>
<li><p> &quot;lambda&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#lambda">Lambda.</a>
</p>
</li>
<li><p> &quot;laplace&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#laplace">Laplace Corrected Confidence.</a> Parameter <code>k</code> can be used to specify the number of classes (default is 2).
</p>
</li>
<li><p> &quot;leastContradiction&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#leastcontradiction">Least Contradiction.</a>
</p>
</li>
<li><p> &quot;lerman&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#lerman">Lerman Similarity.</a>
</p>
</li>
<li><p> &quot;leverage&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#leverage">Leverage.</a>
</p>
</li>
<li><p> &quot;LIC&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#lic">Lift Increase.</a> The additional parameter <code>improvementMeasure</code> (default: <code>'lift'</code>) can be used to specify the measure used for the increase calculation.  See <a href="https://mhahsler.github.io/arules/docs/measures#ginc">Generalized increase ratio</a>.
</p>
</li>
<li><p> &quot;maxconfidence&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#maxconfidence">MaxConfidence.</a>
</p>
</li>
<li><p> &quot;mutualInformation&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#mutualinformation">Mutual Information.</a>
</p>
</li>
<li><p> &quot;oddsRatio&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#oddsratio">Odds Ratio.</a>
</p>
</li>
<li><p> &quot;phi&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#phi">Phi Correlation Coefficient.</a>
</p>
</li>
<li><p> &quot;ralambondrainy&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#ralambondrainy">Ralambondrainy.</a>
</p>
</li>
<li><p> &quot;relativeRisk&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#relativerisk">Relative Risk.</a>
</p>
</li>
<li><p> &quot;rhsSupport&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#rhssupport">Right-Hand-Side Support.</a>
</p>
</li>
<li><p> &quot;RLD&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#rld">Relative Linkage Disequilibrium.</a>
</p>
</li>
<li><p> &quot;rulePowerFactor&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#rulepowerfactor">Rule Power Factor.</a>
</p>
</li>
<li><p> &quot;sebag&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#sebag">Sebag-Schoenauer.</a>
</p>
</li>
<li><p> &quot;stdLift&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#stdlift">Standardized Lift.</a>
</p>
</li>
<li><p> &quot;table&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#table">Contingency Table.</a> Returns the four counts for the contingency table. The entries are labeled <code>n11</code>, <code>n01</code>, <code>n10</code>, and <code>n00</code> (the first subscript is for X and the second is for Y; 1 indicated presence and 0 indicates absence). If several measures are specified, then the counts have the prefix <code>table.</code>
</p>
</li>
<li><p> &quot;varyingLiaison&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#varyingliaison">Varying Rates Liaison.</a>
</p>
</li>
<li><p> &quot;yuleQ&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#yuleq">Yule's Q.</a>
</p>
</li>
<li><p> &quot;yuleY&quot;: <a href="https://mhahsler.github.io/arules/docs/measures#yuley">Yule's Y.</a>
</p>
</li></ul>



<h3>Value</h3>

<p>If only one measure is used, the function returns a numeric vector
containing the values of the interest measure for each association in the
set of associations <code>x</code>.
</p>
<p>If more than one measures are specified, the result is a data.frame
containing the different measures for each association as columns.
</p>
<p><code>NA</code> is returned for rules/itemsets for which a certain measure is not
defined.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>References</h3>

<p>Hahsler, Michael (2015). A Probabilistic Comparison of Commonly Used
Interest Measures for Association Rules, 2015, URL:
<a href="https://mhahsler.github.io/arules/docs/measures">https://mhahsler.github.io/arules/docs/measures</a>.
</p>
<p>Haldane, J.B.S. (1940). &quot;The mean and variance of the moments of chi-squared
when used as a test of homogeneity, when expectations are small&quot;.
<em>Biometrika,</em> 29, 133-134.
</p>
<p>Anscombe, F.J. (1956). &quot;On estimating binomial response relations&quot;.
<em>Biometrika,</em> 43, 461-464.
</p>


<h3>See Also</h3>

<p><a href="#topic+itemsets">itemsets</a>, <a href="#topic+rules">rules</a>
</p>
<p>Other interest measures: 
<code><a href="#topic+confint">confint</a>()</code>,
<code><a href="#topic+coverage">coverage</a>()</code>,
<code><a href="#topic+is.redundant">is.redundant</a>()</code>,
<code><a href="#topic+is.significant">is.significant</a>()</code>,
<code><a href="#topic+support">support</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("Income")
rules &lt;- apriori(Income)

## calculate a single measure and add it to the quality slot
quality(rules) &lt;- cbind(quality(rules),
	hyperConfidence = interestMeasure(rules, measure = "hyperConfidence",
	transactions = Income))

inspect(head(rules, by = "hyperConfidence"))

## calculate several measures
m &lt;- interestMeasure(rules, c("confidence", "oddsRatio", "leverage"),
	transactions = Income)
inspect(head(rules))
head(m)

## calculate all available measures for the first 5 rules and show them as a
## table with the measures as rows
t(interestMeasure(head(rules, 5), transactions = Income))

## calculate measures on a different set of transactions (I use a sample here)
## Note: reuse = TRUE (default) would just return the stored support on the
##	data set used for mining
newTrans &lt;- sample(Income, 100)
m2 &lt;- interestMeasure(rules, "support", transactions = newTrans, reuse = FALSE)
head(m2)

## calculate all available measures for the 5 frequent itemsets with highest support
its &lt;- apriori(Income, parameter = list(target = "frequent itemsets"))
its &lt;- head(its, 5, by = "support")
inspect(its)

interestMeasure(its, transactions = Income)
</code></pre>

<hr>
<h2 id='is.closed'>Find Closed Itemsets</h2><span id='topic+is.closed'></span><span id='topic+is.closed+2Citemsets-method'></span>

<h3>Description</h3>

<p>Provides the generic function and the method <code>is.closed()</code> for finding
closed itemsets.
Closed itemsets are used as a concise representation of
frequent itemsets. The closure of an itemset is its largest proper superset
which has the same support (is contained in exactly the same transactions).
An itemset is closed, if it is its own closure (Pasquier et al. 1999).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.closed(x)

## S4 method for signature 'itemsets'
is.closed(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.closed_+3A_x">x</code></td>
<td>
<p>a set of itemsets.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Closed frequent itemsets can also be mined directly using
<code><a href="#topic+apriori">apriori()</a></code> or <code><a href="#topic+eclat">eclat()</a></code> with target <code>"closed frequent itemsets"</code>.
</p>


<h3>Value</h3>

<p>a logical vector with the same length as <code>x</code> indicating for
each element in <code>x</code> if it is a closed itemset.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>References</h3>

<p>Nicolas Pasquier, Yves Bastide, Rafik Taouil, and Lotfi Lakhal
(1999). Discovering frequent closed itemsets for association rules. In
<em>Proceeding of the 7th International Conference on Database Theory</em>,
Lecture Notes In Computer Science (LNCS 1540), pages 398&ndash;416. Springer,
1999.
</p>


<h3>See Also</h3>

<p>Other postprocessing: 
<code><a href="#topic+is.generator">is.generator</a>()</code>,
<code><a href="#topic+is.maximal">is.maximal</a>()</code>,
<code><a href="#topic+is.redundant">is.redundant</a>()</code>,
<code><a href="#topic+is.significant">is.significant</a>()</code>,
<code><a href="#topic+is.superset">is.superset</a>()</code>
</p>
<p>Other associations functions: 
<code><a href="#topic+abbreviate">abbreviate</a>()</code>,
<code><a href="#topic+associations-class">associations-class</a></code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+duplicated">duplicated</a>()</code>,
<code><a href="#topic+extract">extract</a></code>,
<code><a href="#topic+inspect">inspect</a>()</code>,
<code><a href="#topic+is.generator">is.generator</a>()</code>,
<code><a href="#topic+is.maximal">is.maximal</a>()</code>,
<code><a href="#topic+is.redundant">is.redundant</a>()</code>,
<code><a href="#topic+is.significant">is.significant</a>()</code>,
<code><a href="#topic+is.superset">is.superset</a>()</code>,
<code><a href="#topic+itemsets-class">itemsets-class</a></code>,
<code><a href="#topic+match">match</a>()</code>,
<code><a href="#topic+rules-class">rules-class</a></code>,
<code><a href="#topic+sample">sample</a>()</code>,
<code><a href="#topic+sets">sets</a></code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+sort">sort</a>()</code>,
<code><a href="#topic+unique">unique</a>()</code>
</p>

<hr>
<h2 id='is.generator'>Find Generator Itemsets</h2><span id='topic+is.generator'></span><span id='topic+is.generator+2Citemsets-method'></span>

<h3>Description</h3>

<p>Provides the generic function and the method 'is.generator() for
finding generator itemsets. Generators are part of concise representations
for frequent itemsets.  A generator in a set of itemsets is an itemset that
has no subset with the same support (Liu et al, 2008). Note that the empty
set is by definition a generator, but it is typically not stored in the
itemsets in <span class="pkg">arules</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.generator(x)

## S4 method for signature 'itemsets'
is.generator(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.generator_+3A_x">x</code></td>
<td>
<p>a set of itemsets.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical vector with the same length as <code>x</code> indicating for
each element in <code>x</code> if it is a generator itemset.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>References</h3>

<p>Yves Bastide, Niolas Pasquier, Rafik Taouil, Gerd Stumme, Lotfi
Lakhal (2000). Mining Minimal Non-redundant Association Rules Using Frequent
Closed Itemsets. In <em>International Conference on Computational Logic</em>,
Lecture Notes in Computer Science (LNCS 1861). pages 972&ndash;986.
<a href="https://doi.org/10.1007/3-540-44957-4_65">doi:10.1007/3-540-44957-4_65</a>
</p>
<p>Guimei Liu, Jinyan Li, Limsoon Wong (2008). A new concise representation of
frequent itemsets using generators and a positive border.
<em>Knowledge and Information Systems</em> 17(1):35-56.
<a href="https://doi.org/10.1007/s10115-007-0111-5">doi:10.1007/s10115-007-0111-5</a>
</p>


<h3>See Also</h3>

<p>Other postprocessing: 
<code><a href="#topic+is.closed">is.closed</a>()</code>,
<code><a href="#topic+is.maximal">is.maximal</a>()</code>,
<code><a href="#topic+is.redundant">is.redundant</a>()</code>,
<code><a href="#topic+is.significant">is.significant</a>()</code>,
<code><a href="#topic+is.superset">is.superset</a>()</code>
</p>
<p>Other associations functions: 
<code><a href="#topic+abbreviate">abbreviate</a>()</code>,
<code><a href="#topic+associations-class">associations-class</a></code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+duplicated">duplicated</a>()</code>,
<code><a href="#topic+extract">extract</a></code>,
<code><a href="#topic+inspect">inspect</a>()</code>,
<code><a href="#topic+is.closed">is.closed</a>()</code>,
<code><a href="#topic+is.maximal">is.maximal</a>()</code>,
<code><a href="#topic+is.redundant">is.redundant</a>()</code>,
<code><a href="#topic+is.significant">is.significant</a>()</code>,
<code><a href="#topic+is.superset">is.superset</a>()</code>,
<code><a href="#topic+itemsets-class">itemsets-class</a></code>,
<code><a href="#topic+match">match</a>()</code>,
<code><a href="#topic+rules-class">rules-class</a></code>,
<code><a href="#topic+sample">sample</a>()</code>,
<code><a href="#topic+sets">sets</a></code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+sort">sort</a>()</code>,
<code><a href="#topic+unique">unique</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example from Liu et al (2008)
trans_list &lt;- list(
      t1 = c("a","b","c"),
      t2 = c("a","b", "c", "d"),
      t3 = c("a","d"),
      t4 = c("a","c")
      )

trans &lt;- transactions(trans_list)
its &lt;- apriori(trans, support = 1/4, target = "frequent itemsets")

is.generator(its)

</code></pre>

<hr>
<h2 id='is.maximal'>Find Maximal Itemsets</h2><span id='topic+is.maximal'></span><span id='topic+is.maximal+2CitemMatrix-method'></span><span id='topic+is.maximal+2Citemsets-method'></span><span id='topic+is.maximal+2Crules-method'></span>

<h3>Description</h3>

<p>Provides the generic function <code>is.maximal()</code> and methods for
finding maximal itemsets. Maximal frequent itemsets are used as a concise
representation of frequent itemsets. An itemset is maximal in a set if no
proper superset of the itemset is contained in the set (Zaki et al., 1997).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.maximal(x, ...)

## S4 method for signature 'itemMatrix'
is.maximal(x)

## S4 method for signature 'itemsets'
is.maximal(x)

## S4 method for signature 'rules'
is.maximal(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.maximal_+3A_x">x</code></td>
<td>
<p>the set of <a href="#topic+itemsets">itemsets</a>, <a href="#topic+rules">rules</a> or an <a href="#topic+itemMatrix">itemMatrix</a> object.</p>
</td></tr>
<tr><td><code id="is.maximal_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Maximally frequent itemsets can also be mined directly using
<code><a href="#topic+apriori">apriori()</a></code> or <code><a href="#topic+eclat">eclat()</a></code> with target &quot;maximally frequent
itemsets&quot;.
</p>
<p>We define here maximal rules, as the rules generated by maximal itemsets.
</p>


<h3>Value</h3>

<p>a logical vector with the same length as <code>x</code> indicating for
each element in <code>x</code> if it is a maximal itemset.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>References</h3>

<p>Mohammed J. Zaki, Srinivasan Parthasarathy, Mitsunori Ogihara,
and Wei Li (1997). <em>New algorithms for fast discovery of association
rules</em>. Technical Report 651, Computer Science Department, University of
Rochester, Rochester, NY 14627.
</p>


<h3>See Also</h3>

<p>Other postprocessing: 
<code><a href="#topic+is.closed">is.closed</a>()</code>,
<code><a href="#topic+is.generator">is.generator</a>()</code>,
<code><a href="#topic+is.redundant">is.redundant</a>()</code>,
<code><a href="#topic+is.significant">is.significant</a>()</code>,
<code><a href="#topic+is.superset">is.superset</a>()</code>
</p>
<p>Other associations functions: 
<code><a href="#topic+abbreviate">abbreviate</a>()</code>,
<code><a href="#topic+associations-class">associations-class</a></code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+duplicated">duplicated</a>()</code>,
<code><a href="#topic+extract">extract</a></code>,
<code><a href="#topic+inspect">inspect</a>()</code>,
<code><a href="#topic+is.closed">is.closed</a>()</code>,
<code><a href="#topic+is.generator">is.generator</a>()</code>,
<code><a href="#topic+is.redundant">is.redundant</a>()</code>,
<code><a href="#topic+is.significant">is.significant</a>()</code>,
<code><a href="#topic+is.superset">is.superset</a>()</code>,
<code><a href="#topic+itemsets-class">itemsets-class</a></code>,
<code><a href="#topic+match">match</a>()</code>,
<code><a href="#topic+rules-class">rules-class</a></code>,
<code><a href="#topic+sample">sample</a>()</code>,
<code><a href="#topic+sets">sets</a></code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+sort">sort</a>()</code>,
<code><a href="#topic+unique">unique</a>()</code>
</p>

<hr>
<h2 id='is.redundant'>Find Redundant Rules</h2><span id='topic+is.redundant'></span><span id='topic+is.redundant+2Crules-method'></span>

<h3>Description</h3>

<p>Provides the generic function <code>is.redundant()</code> and the method to find
redundant rules based on any interest measure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.redundant(x, ...)

## S4 method for signature 'rules'
is.redundant(
  x,
  measure = "confidence",
  confint = FALSE,
  level = 0.95,
  smoothCounts = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.redundant_+3A_x">x</code></td>
<td>
<p>a set of rules.</p>
</td></tr>
<tr><td><code id="is.redundant_+3A_...">...</code></td>
<td>
<p>additional arguments are passed on to
<code><a href="#topic+interestMeasure">interestMeasure()</a></code>, or, for <code>confint = TRUE</code> to
<code><a href="#topic+confint">confint()</a></code>.</p>
</td></tr>
<tr><td><code id="is.redundant_+3A_measure">measure</code></td>
<td>
<p>measure used to check for redundancy.</p>
</td></tr>
<tr><td><code id="is.redundant_+3A_confint">confint</code></td>
<td>
<p>should confidence intervals be used to the redundancy check?</p>
</td></tr>
<tr><td><code id="is.redundant_+3A_level">level</code></td>
<td>
<p>confidence level for the confidence interval. Only used when
<code>confint = TRUE</code>.</p>
</td></tr>
<tr><td><code id="is.redundant_+3A_smoothcounts">smoothCounts</code></td>
<td>
<p>adds a &quot;pseudo count&quot; to each count in the used
contingency table. This implements addaptive smoothing (Laplace smoothing)
for counts and avoids zero counts.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>Simple improvement-based redundancy:</b> (<code>confint = FALSE</code>) A rule
can be defined as redundant if a more general rules with the same or a
higher confidence exists. That is, a more specific rule is redundant if it
is only equally or even less predictive than a more general rule. A rule is
more general if it has the same RHS but one or more items removed from the
LHS. Formally, a rule <code class="reqn">X \Rightarrow Y</code> is redundant if
</p>
<p style="text-align: center;"><code class="reqn">\exists X' \subset X \quad conf(X' \Rightarrow Y) \ge conf(X
\Rightarrow Y).</code>
</p>

<p>This is equivalent to a negative or zero <em>improvement</em> as defined by
Bayardo et al. (2000).
</p>
<p>The idea of improvement can be extended other measures besides confidence.
Any other measure available for function <code><a href="#topic+interestMeasure">interestMeasure()</a></code> (e.g.,
lift or the odds ratio) can be specified in <code>measure</code>.
</p>
<p><b>Confidence interval-based redundancy:</b> (<code>confint = TRUE</code>) Li et
al (2014) propose to use the confidence interval (CI) of the odds ratio (OR)
of rules to define redundancy. A more specific rule is redundant if it does
not provide a significantly higher OR than any more general rule. Using
confidence intervals as error bounds, a more specific rule is
defined as redundant if its OR CI overlaps with the CI of any more general
rule. This type of redundancy detection removes more rules
than improvement since it takes differences in counts due to randomness in
the dataset into account.
</p>
<p>The odds ratio and the CI are based on counts which can be zero and which
leads to numerical problems. In addition to the method described by Li et al
(2014), we use additive smoothing (Laplace smoothing) to alleviate this
problem. The default setting adds 1 to each count (see
<code><a href="#topic+confint">confint()</a></code>). A different pseudocount (smoothing parameter) can be
defined using the additional parameter <code>smoothCounts</code>. Smoothing can be
disabled using <code>smoothCounts = 0</code>.
</p>
<p><strong>Warning:</strong> This approach of redundancy checking is flawed since rules with
non-overlapping CIs are
non-redundant (same result as for a 2-sample t-test), but overlapping CIs do
not automatically mean that there is no significant difference between the
two measures which leads to a higher type II error. At the same time,
multiple comparisons are performed leading to an increased type I error. If
we are more worried about missing important rules, then the type II error
is more concerning.
</p>
<p>Confidence interval-based redundancy checks can also be used for other
measures with a confidence interval like confidence (see
<code><a href="#topic+confint">confint()</a></code>).
</p>


<h3>Value</h3>

<p>returns a logical vector indicating which rules are redundant.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler and Christian Buchta
</p>


<h3>References</h3>

<p>Bayardo, R. , R. Agrawal, and D. Gunopulos (2000).
Constraint-based rule mining in large, dense databases. <em>Data Mining
and Knowledge Discovery,</em> 4(2/3):217&ndash;240.
</p>
<p>Li, J., Jixue Liu, Hannu Toivonen, Kenji Satou, Youqiang Sun, and Bingyu Sun
(2014). Discovering statistically non-redundant subgroups. Knowledge-Based
Systems. 67 (September, 2014), 315&ndash;327.
<a href="https://doi.org/10.1016/j.knosys.2014.04.030">doi:10.1016/j.knosys.2014.04.030</a>
</p>


<h3>See Also</h3>

<p>Other postprocessing: 
<code><a href="#topic+is.closed">is.closed</a>()</code>,
<code><a href="#topic+is.generator">is.generator</a>()</code>,
<code><a href="#topic+is.maximal">is.maximal</a>()</code>,
<code><a href="#topic+is.significant">is.significant</a>()</code>,
<code><a href="#topic+is.superset">is.superset</a>()</code>
</p>
<p>Other associations functions: 
<code><a href="#topic+abbreviate">abbreviate</a>()</code>,
<code><a href="#topic+associations-class">associations-class</a></code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+duplicated">duplicated</a>()</code>,
<code><a href="#topic+extract">extract</a></code>,
<code><a href="#topic+inspect">inspect</a>()</code>,
<code><a href="#topic+is.closed">is.closed</a>()</code>,
<code><a href="#topic+is.generator">is.generator</a>()</code>,
<code><a href="#topic+is.maximal">is.maximal</a>()</code>,
<code><a href="#topic+is.significant">is.significant</a>()</code>,
<code><a href="#topic+is.superset">is.superset</a>()</code>,
<code><a href="#topic+itemsets-class">itemsets-class</a></code>,
<code><a href="#topic+match">match</a>()</code>,
<code><a href="#topic+rules-class">rules-class</a></code>,
<code><a href="#topic+sample">sample</a>()</code>,
<code><a href="#topic+sets">sets</a></code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+sort">sort</a>()</code>,
<code><a href="#topic+unique">unique</a>()</code>
</p>
<p>Other interest measures: 
<code><a href="#topic+confint">confint</a>()</code>,
<code><a href="#topic+coverage">coverage</a>()</code>,
<code><a href="#topic+interestMeasure">interestMeasure</a>()</code>,
<code><a href="#topic+is.significant">is.significant</a>()</code>,
<code><a href="#topic+support">support</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("Income")

## mine some rules with the consequent "language in home=english"
rules &lt;- apriori(Income, parameter = list(support = 0.5),
  appearance = list(rhs = "language in home=english"))

## for better comparison we add Bayado's improvement and sort by improvement
quality(rules)$improvement &lt;- interestMeasure(rules, measure = "improvement")
rules &lt;- sort(rules, by = "improvement")
inspect(rules)
is.redundant(rules)

## find non-redundant rules using improvement of confidence
## Note: a few rules have a very small improvement over the rule {} =&gt; {language in home=english}
rules_non_redundant &lt;- rules[!is.redundant(rules)]
inspect(rules_non_redundant)

## use non-overlapping confidence intervals for the confidence measure instead
## Note: fewer rules have a significantly higher confidence
inspect(rules[!is.redundant(rules, measure = "confidence",
  confint = TRUE, level = 0.95)])

## find non-redundant rules using improvement of the odds ratio.
quality(rules)$oddsRatio &lt;-  interestMeasure(rules, measure = "oddsRatio", smoothCounts = .5)
inspect(rules[!is.redundant(rules, measure = "oddsRatio")])

## use the confidence interval for the odds ratio.
## We see that no rule has a significantly better odds ratio than the most general rule.
inspect(rules[!is.redundant(rules, measure = "oddsRatio",
  confint = TRUE, level = 0.95)])

##  use the confidence interval for lift
inspect(rules[!is.redundant(rules, measure = "lift",
  confint = TRUE, level = 0.95)])

</code></pre>

<hr>
<h2 id='is.significant'>Find Significant Rules</h2><span id='topic+is.significant'></span><span id='topic+is.significant+2Crules-method'></span>

<h3>Description</h3>

<p>Provides the generic functions <code>is.significant()</code> and the method to
find significant <a href="#topic+rules">rules</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.significant(x, ...)

## S4 method for signature 'rules'
is.significant(
  x,
  transactions = NULL,
  method = "fisher",
  alpha = 0.01,
  adjust = "none",
  reuse = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.significant_+3A_x">x</code></td>
<td>
<p>a set of <a href="#topic+rules">rules</a>.</p>
</td></tr>
<tr><td><code id="is.significant_+3A_...">...</code></td>
<td>
<p>further arguments are passed on to <code><a href="#topic+interestMeasure">interestMeasure()</a></code>.</p>
</td></tr>
<tr><td><code id="is.significant_+3A_transactions">transactions</code></td>
<td>
<p>optional set of <a href="#topic+transactions">transactions</a>. Only needed if not sufficient
interest measures are available in <code>x</code>. If the test should be performed
on a transaction set different then the one used for mining (use <code>reuse = FALSE</code>).</p>
</td></tr>
<tr><td><code id="is.significant_+3A_method">method</code></td>
<td>
<p>test to use. Options are <code>"fisher"</code>, <code>"chisq"</code>. Note that
the contingency table is likely to have cells with low expected values and
that thus Fisher's Exact Test might be more appropriate than the chi-squared
test.</p>
</td></tr>
<tr><td><code id="is.significant_+3A_alpha">alpha</code></td>
<td>
<p>required significance level.</p>
</td></tr>
<tr><td><code id="is.significant_+3A_adjust">adjust</code></td>
<td>
<p>method to adjust for multiple comparisons. Some options are
<code>"none"</code>, <code>"bonferroni"</code>, <code>"holm"</code>, <code>"fdr"</code>, etc. (see
<code><a href="stats.html#topic+p.adjust">stats::p.adjust()</a></code> for more methods)</p>
</td></tr>
<tr><td><code id="is.significant_+3A_reuse">reuse</code></td>
<td>
<p>logical indicating if information in the quality slot should be
reuse for calculating the measures.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implementation for association rules uses Fisher's exact test with
correction for multiple comparisons to test the null hypothesis that the LHS
and the RHS of the rule are independent.  Significant rules have a p-value
less then the specified significance level alpha (the null hypothesis of
independence is rejected). See Hahsler and Hornik (2007) for details.
</p>


<h3>Value</h3>

<p>returns a logical vector indicating which rules are significant.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>References</h3>

<p>Hahsler, Michael and Kurt Hornik (2007). New probabilistic
interest measures for association rules. <em>Intelligent Data Analysis</em>,
11(5):437&ndash;455.
<a href="https://doi.org/10.3233/IDA-2007-11502">doi:10.3233/IDA-2007-11502</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+p.adjust">stats::p.adjust()</a></code>
</p>
<p>Other interest measures: 
<code><a href="#topic+confint">confint</a>()</code>,
<code><a href="#topic+coverage">coverage</a>()</code>,
<code><a href="#topic+interestMeasure">interestMeasure</a>()</code>,
<code><a href="#topic+is.redundant">is.redundant</a>()</code>,
<code><a href="#topic+support">support</a>()</code>
</p>
<p>Other postprocessing: 
<code><a href="#topic+is.closed">is.closed</a>()</code>,
<code><a href="#topic+is.generator">is.generator</a>()</code>,
<code><a href="#topic+is.maximal">is.maximal</a>()</code>,
<code><a href="#topic+is.redundant">is.redundant</a>()</code>,
<code><a href="#topic+is.superset">is.superset</a>()</code>
</p>
<p>Other associations functions: 
<code><a href="#topic+abbreviate">abbreviate</a>()</code>,
<code><a href="#topic+associations-class">associations-class</a></code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+duplicated">duplicated</a>()</code>,
<code><a href="#topic+extract">extract</a></code>,
<code><a href="#topic+inspect">inspect</a>()</code>,
<code><a href="#topic+is.closed">is.closed</a>()</code>,
<code><a href="#topic+is.generator">is.generator</a>()</code>,
<code><a href="#topic+is.maximal">is.maximal</a>()</code>,
<code><a href="#topic+is.redundant">is.redundant</a>()</code>,
<code><a href="#topic+is.superset">is.superset</a>()</code>,
<code><a href="#topic+itemsets-class">itemsets-class</a></code>,
<code><a href="#topic+match">match</a>()</code>,
<code><a href="#topic+rules-class">rules-class</a></code>,
<code><a href="#topic+sample">sample</a>()</code>,
<code><a href="#topic+sets">sets</a></code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+sort">sort</a>()</code>,
<code><a href="#topic+unique">unique</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Income")
rules &lt;- apriori(Income, support = 0.2)
is.significant(rules)

rules[is.significant(rules)]

# Adjust P-values for multiple comparisons
rules[is.significant(rules, adjust = "bonferroni")]
</code></pre>

<hr>
<h2 id='is.superset'>Find Super and Subsets</h2><span id='topic+is.superset'></span><span id='topic+is.subset'></span><span id='topic+is.superset+2CitemMatrix-method'></span><span id='topic+is.superset+2Cassociations-method'></span><span id='topic+is.subset+2CitemMatrix-method'></span><span id='topic+is.subset+2Cassociations-method'></span>

<h3>Description</h3>

<p>Provides the generic functions <code>is.subset()</code> and <code>is.superset()</code>, and the methods
for finding super or subsets in <a href="#topic+associations">associations</a> and
<a href="#topic+itemMatrix">itemMatrix</a> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.superset(x, y = NULL, proper = FALSE, sparse = TRUE, ...)

is.subset(x, y = NULL, proper = FALSE, sparse = TRUE, ...)

## S4 method for signature 'itemMatrix'
is.superset(x, y = NULL, proper = FALSE, sparse = TRUE)

## S4 method for signature 'associations'
is.superset(x, y = NULL, proper = FALSE, sparse = TRUE)

## S4 method for signature 'itemMatrix'
is.subset(x, y = NULL, proper = FALSE, sparse = TRUE)

## S4 method for signature 'associations'
is.subset(x, y = NULL, proper = FALSE, sparse = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.superset_+3A_x">x</code>, <code id="is.superset_+3A_y">y</code></td>
<td>
<p>associations or itemMatrix objects. If <code>y = NULL</code>, the super
or subset structure within set <code>x</code> is calculated.</p>
</td></tr>
<tr><td><code id="is.superset_+3A_proper">proper</code></td>
<td>
<p>a logical indicating if all or just proper super or subsets.</p>
</td></tr>
<tr><td><code id="is.superset_+3A_sparse">sparse</code></td>
<td>
<p>a logical indicating if a sparse <code><a href="Matrix.html#topic+ngCMatrix-class">ngCMatrix</a></code>
rather than a dense logical matrix should be returned.
Sparse computation requires a
significantly smaller amount of memory and is much faster for large sets.</p>
</td></tr>
<tr><td><code id="is.superset_+3A_...">...</code></td>
<td>
<p>currently unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Determines for each element in <code>x</code> which elements in <code>y</code> are supersets
or subsets. Note that the method can be very slow and memory intensive if
<code>x</code> and/or <code>y</code> are very dense (contain many items).
</p>
<p>For rules, the union of lhs and rhs is used a the set of items.
</p>


<h3>Value</h3>

<p>returns a logical matrix or a sparse <code><a href="Matrix.html#topic+ngCMatrix-class">ngCMatrix</a></code>
with <code>length(x)</code> rows and <code>length(y)</code> columns.
Each logical row vector represents which elements in <code>y</code> are supersets
(subsets) of the corresponding element in <code>x</code>.  If either <code>x</code> or
<code>y</code> have length zero, <code>NULL</code> is returned instead of a matrix.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler and Ian Johnson
</p>


<h3>See Also</h3>

<p>Other postprocessing: 
<code><a href="#topic+is.closed">is.closed</a>()</code>,
<code><a href="#topic+is.generator">is.generator</a>()</code>,
<code><a href="#topic+is.maximal">is.maximal</a>()</code>,
<code><a href="#topic+is.redundant">is.redundant</a>()</code>,
<code><a href="#topic+is.significant">is.significant</a>()</code>
</p>
<p>Other associations functions: 
<code><a href="#topic+abbreviate">abbreviate</a>()</code>,
<code><a href="#topic+associations-class">associations-class</a></code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+duplicated">duplicated</a>()</code>,
<code><a href="#topic+extract">extract</a></code>,
<code><a href="#topic+inspect">inspect</a>()</code>,
<code><a href="#topic+is.closed">is.closed</a>()</code>,
<code><a href="#topic+is.generator">is.generator</a>()</code>,
<code><a href="#topic+is.maximal">is.maximal</a>()</code>,
<code><a href="#topic+is.redundant">is.redundant</a>()</code>,
<code><a href="#topic+is.significant">is.significant</a>()</code>,
<code><a href="#topic+itemsets-class">itemsets-class</a></code>,
<code><a href="#topic+match">match</a>()</code>,
<code><a href="#topic+rules-class">rules-class</a></code>,
<code><a href="#topic+sample">sample</a>()</code>,
<code><a href="#topic+sets">sets</a></code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+sort">sort</a>()</code>,
<code><a href="#topic+unique">unique</a>()</code>
</p>
<p>Other itemMatrix and transactions functions: 
<code><a href="#topic+abbreviate">abbreviate</a>()</code>,
<code><a href="#topic+crossTable">crossTable</a>()</code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+duplicated">duplicated</a>()</code>,
<code><a href="#topic+extract">extract</a></code>,
<code><a href="#topic+hierarchy">hierarchy</a></code>,
<code><a href="#topic+image">image</a>()</code>,
<code><a href="#topic+inspect">inspect</a>()</code>,
<code><a href="#topic+itemFrequencyPlot">itemFrequencyPlot</a>()</code>,
<code><a href="#topic+itemFrequency">itemFrequency</a>()</code>,
<code><a href="#topic+itemMatrix-class">itemMatrix-class</a></code>,
<code><a href="#topic+match">match</a>()</code>,
<code><a href="#topic+merge">merge</a>()</code>,
<code><a href="#topic+random.transactions">random.transactions</a>()</code>,
<code><a href="#topic+sample">sample</a>()</code>,
<code><a href="#topic+sets">sets</a></code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+supportingTransactions">supportingTransactions</a>()</code>,
<code><a href="#topic+tidLists-class">tidLists-class</a></code>,
<code><a href="#topic+transactions-class">transactions-class</a></code>,
<code><a href="#topic+unique">unique</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Adult")
set &lt;- eclat(Adult, parameter = list(supp = 0.8))

### find the supersets of each itemset in set
is.superset(set, set)
is.superset(set, set, sparse = FALSE)
</code></pre>

<hr>
<h2 id='itemCoding'>Item Coding &mdash; Conversion between Item Labels and Column IDs</h2><span id='topic+itemCoding'></span><span id='topic+itemcoding'></span><span id='topic+decode+2Cnumeric-method'></span><span id='topic+decode'></span><span id='topic+decode+2Clist-method'></span><span id='topic+encode'></span><span id='topic+encode+2Ccharacter-method'></span><span id='topic+encode+2Cnumeric-method'></span><span id='topic+encode+2Clist-method'></span><span id='topic+recode'></span><span id='topic+recode+2CitemMatrix-method'></span><span id='topic+recode+2Citemsets-method'></span><span id='topic+recode+2Crules-method'></span><span id='topic+compatible'></span><span id='topic+compatible+2CitemMatrix-method'></span><span id='topic+compatible+2Cassociations-method'></span>

<h3>Description</h3>

<p>The order in which items are stored in an <a href="#topic+itemMatrix">itemMatrix</a> is called the
<em>item coding</em>. The following generic functions and methods are used
to translate between the representation in the itemMatrix format
(used in transactions, rules and itemsets), item labels and numeric item IDs
(i.e., the column numbers in the itemMatrix representation).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decode(x, ...)

## S4 method for signature 'numeric'
decode(x, itemLabels)

## S4 method for signature 'list'
decode(x, itemLabels)

encode(x, ...)

## S4 method for signature 'character'
encode(x, itemLabels, itemMatrix = TRUE)

## S4 method for signature 'numeric'
encode(x, itemLabels, itemMatrix = TRUE)

## S4 method for signature 'list'
encode(x, itemLabels, itemMatrix = TRUE)

recode(x, ...)

## S4 method for signature 'itemMatrix'
recode(x, itemLabels = NULL, match = NULL)

## S4 method for signature 'itemsets'
recode(x, itemLabels = NULL, match = NULL)

## S4 method for signature 'rules'
recode(x, itemLabels = NULL, match = NULL)

compatible(x, y)

## S4 method for signature 'itemMatrix'
compatible(x, y)

## S4 method for signature 'associations'
compatible(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="itemCoding_+3A_x">x</code></td>
<td>
<p>a vector or a list of vectors of character strings (for
<code>encode()</code> or of numeric (for <code>decode()</code>), or an object of class
<a href="#topic+itemMatrix">itemMatrix</a> (for <code>recode()</code>).</p>
</td></tr>
<tr><td><code id="itemCoding_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
<tr><td><code id="itemCoding_+3A_itemlabels">itemLabels</code></td>
<td>
<p>a vector of character strings used for coding where the
position of an item label in the vector gives the item's column ID.
Alternatively, a <a href="#topic+itemMatrix">itemMatrix</a>, <a href="#topic+transactions">transactions</a> or
<a href="#topic+associations">associations</a> object can be specified and the item labels or these
objects are used.</p>
</td></tr>
<tr><td><code id="itemCoding_+3A_itemmatrix">itemMatrix</code></td>
<td>
<p>return an object of class <a href="#topic+itemMatrix">itemMatrix</a> otherwise an
object of the same class as <code>x</code> is returned.</p>
</td></tr>
<tr><td><code id="itemCoding_+3A_match">match</code></td>
<td>
<p>deprecated: used <code>itemLabels</code> instead.</p>
</td></tr>
<tr><td><code id="itemCoding_+3A_y">y</code></td>
<td>
<p>an object of class <a href="#topic+itemMatrix">itemMatrix</a>, <a href="#topic+transactions">transactions</a> or
<a href="#topic+associations">associations</a> to compare item coding to <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Item coding compatibility:</strong> When working with several datasets or different
subsets of the same dataset, combining or compare the found
itemsets or rules requires a compatible item coding.
That is, the sparse matrices representing the
items (the itemMatrix objects) have columns for the same items in exactly the
same order. The coercion to transactions with <code>transactions()</code> or
<code>as(x, "transactions")</code> will create the
item coding by adding items in the order they are encountered in the dataset. This
can lead to different item codings (different order, missing items) for even
only slightly different datasets or versions of a dataset.
Method <code>compatible()</code> can be used to check if two sets have the same item coding.
</p>
<p><strong>Defining a common item coding:</strong>
When working with many sets, then first a common item
coding should be defined by creating a vector with all possible item labels and then
specify them as <code>itemLabels</code> to create transactions with <code>transactions()</code>.
Compatible <a href="#topic+itemMatrix">itemMatrix</a> objects can be created using <code>encode()</code>.
</p>
<p><strong>Recoding and Decoding:</strong>
Two incompatible objects can be made compatible using <code>recode()</code>. Recode
one object by specifying the other object in <code>itemLabels</code>.
</p>
<p><code>decode()</code> converts from the column IDs used in the itemMatrix
representation to item labels. <code>decode()</code> is used by <code><a href="#topic+LIST">LIST()</a></code>.
</p>


<h3>Value</h3>

<p><code>recode()</code> always returns an object of the same class as <code>x</code>.
</p>
<p>For <code>encode()</code> with <code>itemMatrix = TRUE</code> an object of class
<a href="#topic+itemMatrix">itemMatrix</a> is returned.  Otherwise the result is of the same type as
<code>x</code>, e.g., a list or a vector.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LIST">LIST()</a></code>, <a href="#topic+associations">associations</a>, <a href="#topic+itemMatrix">itemMatrix</a>
</p>
<p>Other preprocessing: 
<code><a href="#topic+discretize">discretize</a>()</code>,
<code><a href="#topic+hierarchy">hierarchy</a></code>,
<code><a href="#topic+merge">merge</a>()</code>,
<code><a href="#topic+sample">sample</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Adult")

## Example 1: Manual decoding
## Extract the item coding as a vector of item labels.
iLabels &lt;- itemLabels(Adult)
head(iLabels)

## get undecoded list (itemIDs)
list &lt;- LIST(Adult[1:5], decode = FALSE)
list

## decode itemIDs by replacing them with the appropriate item label
decode(list, itemLabels = iLabels)


## Example 2: Manually create an itemMatrix using iLabels as the common item coding
data &lt;- list(
    c("income=small", "age=Young"),
    c("income=large", "age=Middle-aged")
    )

# Option a: encode to match the item coding in Adult
iM &lt;- encode(data, itemLabels = Adult)
iM
inspect(iM)
compatible(iM, Adult)

# Option b: coercion plus recode to make it compatible to Adult
#           (note: the coding has 115 item columns after recode)
iM &lt;- as(data, "itemMatrix")
iM
compatible(iM, Adult)

iM &lt;- recode(iM, itemLabels = Adult)
iM
compatible(iM, Adult)


## Example 3: use recode to make itemMatrices compatible
## select first 100 transactions and all education-related items
sub &lt;- Adult[1:100, itemInfo(Adult)$variables ==  "education"]
itemLabels(sub)
image(sub)

## After choosing only a subset of items (columns), the item coding is now
## no longer compatible with the Adult dataset
compatible(sub, Adult)

## recode to match Adult again
sub.recoded &lt;- recode(sub, itemLabels = Adult)
image(sub.recoded)


## Example 4: manually create 2 new transaction for the Adult data set
##            Note: check itemLabels(Adult) to see the available labels for items
twoTransactions &lt;- as(
    encode(list(
        c("age=Young", "relationship=Unmarried"),
        c("age=Senior")
      ), itemLabels = Adult),
    "transactions")

twoTransactions
inspect(twoTransactions)

## the same using the transactions constructor function instead
twoTransactions &lt;- transactions(
    list(
        c("age=Young", "relationship=Unmarried"),
        c("age=Senior")
    ), itemLabels = Adult)

twoTransactions
inspect(twoTransactions)

## Example 5: Use a common item coding

# Creation of transactions separately will produce different item codings
trans1 &lt;- transactions(
    list(
        c("age=Young", "relationship=Unmarried"),
        c("age=Senior")
    ))
trans1

trans2 &lt;- transactions(
    list(
        c("age=Middle-aged", "relationship=Married"),
        c("relationship=Unmarried", "age=Young")
    ))
trans2

compatible(trans1, trans2)

# produce common item coding (all item labels in the two sets)
commonItemLabels &lt;- union(itemLabels(trans1), itemLabels(trans2))
commonItemLabels

trans1 &lt;- recode(trans1, itemLabels = commonItemLabels)
trans1
trans2 &lt;- recode(trans2, itemLabels = commonItemLabels)
trans2

compatible(trans1, trans2)


## Example 6: manually create a rule using the item coding in Adult
## and calculate interest measures
aRule &lt;- new("rules",
  lhs = encode(list(c("age=Young", "relationship=Unmarried")),
    itemLabels = Adult),
  rhs = encode(list(c("income=small")),
    itemLabels = Adult)
)

## shorter version using the rules constructor
aRule &lt;- rules(
  lhs = list(c("age=Young", "relationship=Unmarried")),
  rhs = list(c("income=small")),
  itemLabels = Adult
)

quality(aRule) &lt;- interestMeasure(aRule,
  measure = c("support", "confidence", "lift"), transactions = Adult)

inspect(aRule)
</code></pre>

<hr>
<h2 id='itemFrequency'>Getting Frequency/Support for Single Items</h2><span id='topic+itemFrequency'></span><span id='topic+itemFrequency+2CitemMatrix-method'></span><span id='topic+itemFrequency+2CtidLists-method'></span>

<h3>Description</h3>

<p>Provides the generic function <code>itemFrequency()</code> and methods to get the
frequency/support for all single items in an objects based on
<a href="#topic+itemMatrix">itemMatrix</a>.  For example, it is used to get the single
item support from an object of class <a href="#topic+transactions">transactions</a>
without mining.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>itemFrequency(x, ...)

## S4 method for signature 'itemMatrix'
itemFrequency(x, type = c("relative", "absolute"), weighted = FALSE)

## S4 method for signature 'tidLists'
itemFrequency(x, type = c("relative", "absolute"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="itemFrequency_+3A_x">x</code></td>
<td>
<p>an object of class <a href="#topic+itemMatrix">itemMatrix</a> or <a href="#topic+tidLists">tidLists</a>.</p>
</td></tr>
<tr><td><code id="itemFrequency_+3A_...">...</code></td>
<td>
<p>further arguments are passed on.</p>
</td></tr>
<tr><td><code id="itemFrequency_+3A_type">type</code></td>
<td>
<p>a character string specifying if <code>"relative"</code>
frequency/support or <code>"absolute"</code> frequency/support (item counts) is
returned. (default: <code>"relative"</code>).</p>
</td></tr>
<tr><td><code id="itemFrequency_+3A_weighted">weighted</code></td>
<td>
<p>should support be weighted by transactions weights stored as
column <code>"weight"</code> in transactionInfo?</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>itemFrequency</code> returns a named numeric vector.  Each element
is the frequency/support of the corresponding item in object <code>x</code>.  The
items appear in the vector in the same order as in the binary matrix in
<code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p><code><a href="#topic+itemFrequencyPlot">itemFrequencyPlot()</a></code>
</p>
<p>Other itemMatrix and transactions functions: 
<code><a href="#topic+abbreviate">abbreviate</a>()</code>,
<code><a href="#topic+crossTable">crossTable</a>()</code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+duplicated">duplicated</a>()</code>,
<code><a href="#topic+extract">extract</a></code>,
<code><a href="#topic+hierarchy">hierarchy</a></code>,
<code><a href="#topic+image">image</a>()</code>,
<code><a href="#topic+inspect">inspect</a>()</code>,
<code><a href="#topic+is.superset">is.superset</a>()</code>,
<code><a href="#topic+itemFrequencyPlot">itemFrequencyPlot</a>()</code>,
<code><a href="#topic+itemMatrix-class">itemMatrix-class</a></code>,
<code><a href="#topic+match">match</a>()</code>,
<code><a href="#topic+merge">merge</a>()</code>,
<code><a href="#topic+random.transactions">random.transactions</a>()</code>,
<code><a href="#topic+sample">sample</a>()</code>,
<code><a href="#topic+sets">sets</a></code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+supportingTransactions">supportingTransactions</a>()</code>,
<code><a href="#topic+tidLists-class">tidLists-class</a></code>,
<code><a href="#topic+transactions-class">transactions-class</a></code>,
<code><a href="#topic+unique">unique</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Adult")
itemFrequency(Adult, type = "relative")

</code></pre>

<hr>
<h2 id='itemFrequencyPlot'>Creating a Item Frequencies/Support Bar Plot</h2><span id='topic+itemFrequencyPlot'></span><span id='topic+itemFrequencyPlot+2CitemMatrix-method'></span>

<h3>Description</h3>

<p>Provides the generic function <code>itemFrequencyPlot()</code> and the method to
create an item frequency bar plot for inspecting the item frequency
distribution for objects based on <a href="#topic+itemMatrix">itemMatrix</a> (e.g.,
<a href="#topic+transactions">transactions</a>, or items in <a href="#topic+itemsets">itemsets</a>
and <a href="#topic+rules">rules</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>itemFrequencyPlot(x, ...)

## S4 method for signature 'itemMatrix'
itemFrequencyPlot(
  x,
  type = c("relative", "absolute"),
  weighted = FALSE,
  support = NULL,
  topN = NULL,
  population = NULL,
  popCol = "black",
  popLwd = 1,
  lift = FALSE,
  horiz = FALSE,
  names = TRUE,
  cex.names = graphics::par("cex.axis"),
  xlab = NULL,
  ylab = NULL,
  mai = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="itemFrequencyPlot_+3A_x">x</code></td>
<td>
<p>the object to be plotted.</p>
</td></tr>
<tr><td><code id="itemFrequencyPlot_+3A_...">...</code></td>
<td>
<p>further arguments are passed on (see
<code><a href="graphics.html#topic+barplot">graphics::barplot()</a></code> from possible arguments).</p>
</td></tr>
<tr><td><code id="itemFrequencyPlot_+3A_type">type</code></td>
<td>
<p>a character string indicating whether item frequencies should be
displayed relative of absolute.</p>
</td></tr>
<tr><td><code id="itemFrequencyPlot_+3A_weighted">weighted</code></td>
<td>
<p>should support be weighted by transactions weights stored as
column <code>"weight"</code> in transactionInfo?</p>
</td></tr>
<tr><td><code id="itemFrequencyPlot_+3A_support">support</code></td>
<td>
<p>a numeric value. Only display items which have a support of
at least <code>support</code>. If no population is given, support is calculated
from <code>x</code> otherwise from the population. Support is interpreted relative
or absolute according to the setting of <code>type</code>.</p>
</td></tr>
<tr><td><code id="itemFrequencyPlot_+3A_topn">topN</code></td>
<td>
<p>a integer value. Only plot the <code>topN</code> items with the
highest item frequency or lift (if <code>lift = TRUE</code>).  The items are
plotted ordered by descending support.</p>
</td></tr>
<tr><td><code id="itemFrequencyPlot_+3A_population">population</code></td>
<td>
<p>object of same class as <code>x</code>; if <code>x</code> is a segment
of a population, the population mean frequency for each item can be shown as
a line in the plot.</p>
</td></tr>
<tr><td><code id="itemFrequencyPlot_+3A_popcol">popCol</code></td>
<td>
<p>plotting color for population.</p>
</td></tr>
<tr><td><code id="itemFrequencyPlot_+3A_poplwd">popLwd</code></td>
<td>
<p>line width for population.</p>
</td></tr>
<tr><td><code id="itemFrequencyPlot_+3A_lift">lift</code></td>
<td>
<p>a logical indicating whether to plot the lift ratio between
instead of frequencies. The lift ratio is gives how many times an item is
more frequent in <code>x</code> than in <code>population</code>.</p>
</td></tr>
<tr><td><code id="itemFrequencyPlot_+3A_horiz">horiz</code></td>
<td>
<p>a logical. If <code>horiz = FALSE</code> (default), the bars are
drawn vertically. If <code>TRUE</code>, the bars are drawn horizontally.</p>
</td></tr>
<tr><td><code id="itemFrequencyPlot_+3A_names">names</code></td>
<td>
<p>a logical indicating if the names (bar labels) should be
displayed?</p>
</td></tr>
<tr><td><code id="itemFrequencyPlot_+3A_cex.names">cex.names</code></td>
<td>
<p>a numeric value for the expansion factor for axis names
(bar labels).</p>
</td></tr>
<tr><td><code id="itemFrequencyPlot_+3A_xlab">xlab</code></td>
<td>
<p>a character string with the label for the x axis (use an empty
string to force no label).</p>
</td></tr>
<tr><td><code id="itemFrequencyPlot_+3A_ylab">ylab</code></td>
<td>
<p>a character string with the label for the y axis (see xlab).</p>
</td></tr>
<tr><td><code id="itemFrequencyPlot_+3A_mai">mai</code></td>
<td>
<p>a numerical vector giving the plots margin sizes in inches (see
&lsquo;? par&rsquo;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the midpoints of the drawn bars; useful for
adding to the graph.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p><code><a href="#topic+itemFrequency">itemFrequency()</a></code>
</p>
<p>Other itemMatrix and transactions functions: 
<code><a href="#topic+abbreviate">abbreviate</a>()</code>,
<code><a href="#topic+crossTable">crossTable</a>()</code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+duplicated">duplicated</a>()</code>,
<code><a href="#topic+extract">extract</a></code>,
<code><a href="#topic+hierarchy">hierarchy</a></code>,
<code><a href="#topic+image">image</a>()</code>,
<code><a href="#topic+inspect">inspect</a>()</code>,
<code><a href="#topic+is.superset">is.superset</a>()</code>,
<code><a href="#topic+itemFrequency">itemFrequency</a>()</code>,
<code><a href="#topic+itemMatrix-class">itemMatrix-class</a></code>,
<code><a href="#topic+match">match</a>()</code>,
<code><a href="#topic+merge">merge</a>()</code>,
<code><a href="#topic+random.transactions">random.transactions</a>()</code>,
<code><a href="#topic+sample">sample</a>()</code>,
<code><a href="#topic+sets">sets</a></code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+supportingTransactions">supportingTransactions</a>()</code>,
<code><a href="#topic+tidLists-class">tidLists-class</a></code>,
<code><a href="#topic+transactions-class">transactions-class</a></code>,
<code><a href="#topic+unique">unique</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Adult)

## the following example compares the item frequencies
## of people with a large income (boxes) with the average in the data set
Adult.largeIncome &lt;- Adult[Adult %in% "income=large"]

## simple plot
itemFrequencyPlot(Adult.largeIncome)

## plot with the averages of the population plotted as a line 
## (for first 72 variables/items)
itemFrequencyPlot(Adult.largeIncome[, 1:72], 
	population = Adult[, 1:72])

## plot lift ratio (frequency in x / frequency in population)
## for items with a support of 20% in the population
itemFrequencyPlot(Adult.largeIncome, 
        population = Adult, support = 0.2, 
	lift = TRUE, horiz = TRUE)

</code></pre>

<hr>
<h2 id='itemMatrix-class'>Class itemMatrix &mdash; Sparse Binary Incidence Matrix to Represent Sets of
Items</h2><span id='topic+itemMatrix-class'></span><span id='topic+itemMatrix'></span><span id='topic+initialize+2CitemMatrix-method'></span><span id='topic+show+2CitemMatrix-method'></span><span id='topic+summary+2CitemMatrix-method'></span><span id='topic+summary.itemMatrix-class'></span><span id='topic+show+2Csummary.itemMatrix-method'></span><span id='topic+dim+2CitemMatrix-method'></span><span id='topic+nitems'></span><span id='topic+nitems+2CitemMatrix-method'></span><span id='topic+length+2CitemMatrix-method'></span><span id='topic+toLongFormat'></span><span id='topic+toLongFormat+2CitemMatrix-method'></span><span id='topic+labels+2CitemMatrix-method'></span><span id='topic+itemLabels'></span><span id='topic+itemLabels+3C-'></span><span id='topic+itemLabels+2CitemMatrix-method'></span><span id='topic+itemLabels+3C-+2CitemMatrix-method'></span><span id='topic+itemInfo'></span><span id='topic+itemInfo+3C-'></span><span id='topic+itemInfo+2CitemMatrix-method'></span><span id='topic+itemInfo+3C-+2CitemMatrix-method'></span><span id='topic+itemsetInfo'></span><span id='topic+itemsetInfo+3C-'></span><span id='topic+itemsetInfo+2CitemMatrix-method'></span><span id='topic+itemsetInfo+3C-+2CitemMatrix-method'></span><span id='topic+coercion-itemMatrix'></span><span id='topic+coerce+2Cmatrix+2CitemMatrix-method'></span><span id='topic+coerce+2CitemMatrix+2Cmatrix-method'></span><span id='topic+coerce+2Clist+2CitemMatrix-method'></span><span id='topic+coerce+2CitemMatrix+2Clist-method'></span><span id='topic+coerce+2CitemMatrix+2CngCMatrix-method'></span><span id='topic+coerce+2CngCMatrix+2CitemMatrix-method'></span><span id='topic+dimnames+2CitemMatrix-method'></span><span id='topic+dimnames+3C-+2CitemMatrix+2Clist-method'></span>

<h3>Description</h3>

<p>The <code>itemMatrix</code> class is the basic building block for <a href="#topic+transactions">transactions</a>,
and <a href="#topic+associations">associations</a>.  The class contains a sparse
Matrix representation of a set of itemsets and the
corresponding item labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'itemMatrix'
summary(object, maxsum = 6, ...)

## S4 method for signature 'itemMatrix'
dim(x)

nitems(x, ...)

## S4 method for signature 'itemMatrix'
nitems(x)

## S4 method for signature 'itemMatrix'
length(x)

toLongFormat(from, ...)

## S4 method for signature 'itemMatrix'
toLongFormat(from, cols = c("ID", "item"), decode = TRUE)

## S4 method for signature 'itemMatrix'
labels(object, itemSep = ",", setStart = "{", setEnd = "}")

itemLabels(object, ...)

itemLabels(object) &lt;- value

## S4 method for signature 'itemMatrix'
itemLabels(object)

## S4 replacement method for signature 'itemMatrix'
itemLabels(object) &lt;- value

itemInfo(object)

itemInfo(object) &lt;- value

## S4 method for signature 'itemMatrix'
itemInfo(object)

## S4 replacement method for signature 'itemMatrix'
itemInfo(object) &lt;- value

itemsetInfo(object)

itemsetInfo(object) &lt;- value

## S4 method for signature 'itemMatrix'
itemsetInfo(object)

## S4 replacement method for signature 'itemMatrix'
itemsetInfo(object) &lt;- value

## S4 method for signature 'itemMatrix'
dimnames(x)

## S4 replacement method for signature 'itemMatrix,list'
dimnames(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="itemMatrix-class_+3A_object">object</code>, <code id="itemMatrix-class_+3A_x">x</code>, <code id="itemMatrix-class_+3A_from">from</code></td>
<td>
<p>the object.</p>
</td></tr>
<tr><td><code id="itemMatrix-class_+3A_maxsum">maxsum</code></td>
<td>
<p>integer, how many items should be shown for the summary?</p>
</td></tr>
<tr><td><code id="itemMatrix-class_+3A_...">...</code></td>
<td>
<p>further parameters</p>
</td></tr>
<tr><td><code id="itemMatrix-class_+3A_cols">cols</code></td>
<td>
<p>columns for the long format.</p>
</td></tr>
<tr><td><code id="itemMatrix-class_+3A_decode">decode</code></td>
<td>
<p>decode item IDs to item labels.</p>
</td></tr>
<tr><td><code id="itemMatrix-class_+3A_itemsep">itemSep</code></td>
<td>
<p>item separator symbol.</p>
</td></tr>
<tr><td><code id="itemMatrix-class_+3A_setstart">setStart</code></td>
<td>
<p>set start symbol.</p>
</td></tr>
<tr><td><code id="itemMatrix-class_+3A_setend">setEnd</code></td>
<td>
<p>set end symbol.</p>
</td></tr>
<tr><td><code id="itemMatrix-class_+3A_value">value</code></td>
<td>
<p>replacement value</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Representation</strong>
</p>
<p>Sets of itemsets are represented as a compressed sparse
binary matrix. Conceptually, columns represent items and rows are the sets/transactions.
In the compressed form, each itemset is a vector of column indices (called item
IDs) representing the items.
</p>
<p><strong>Warning:</strong> Ideally, we would store the matrix as a row-oriented sparse
matrix (<code>ngRMatrix</code>), but the <span class="pkg">Matrix</span> package provides better support for
column-oriented sparse classes (<code>ngCMatrix</code>). The matrix is therefore internally stored
in transposed form.
</p>
<p><strong>Working with several <code>itemMatrix</code> objects</strong>
</p>
<p>If you work with several <code>itemMatrix</code> objects at the same time (e.g.,
several transaction sets, lhs and rhs of a rule, etc.), then the encoding
(itemLabes and order of the items in the binary matrix) in the different
itemMatrices is important and needs to conform. See <a href="#topic+itemCoding">itemCoding</a>
to learn how to encode and recode <code>itemMatrix</code> objects.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>summary(itemMatrix)</code>: show a summary.
</p>
</li>
<li> <p><code>dim(itemMatrix)</code>: returns the number of rows
(itemsets) and columns (items in the encoding).
</p>
</li>
<li> <p><code>nitems(itemMatrix)</code>: returns the number of items in the encoding.
</p>
</li>
<li> <p><code>length(itemMatrix)</code>: returns the number of itemsets (rows) in the matrix.
</p>
</li>
<li> <p><code>toLongFormat(itemMatrix)</code>: convert the sets to long format
(a data.frame with two columns, ID and item). Column names
can be specified as a character vector of length 2 called <code>cols</code>.
</p>
</li>
<li> <p><code>labels(itemMatrix)</code>: returns labels for the itemsets.
The following arguments can be used to customize the representation
of the labels: <code>itemSep</code>, <code>setStart</code> and <code>setEnd</code>.
</p>
</li>
<li> <p><code>itemLabels(itemMatrix)</code>: returns the item labels used for encoding as a character vector.
</p>
</li>
<li> <p><code>itemLabels(itemMatrix) &lt;- value</code>: replaces the item labels used for encoding.
</p>
</li>
<li> <p><code>itemInfo(itemMatrix)</code>: returns the whole item/column information data.frame including labels.
</p>
</li>
<li> <p><code>itemInfo(itemMatrix) &lt;- value</code>: replaces the item/column info by a data.frame.
</p>
</li>
<li> <p><code>itemsetInfo(itemMatrix)</code>: returns the item set/row information data.frame.
</p>
</li>
<li> <p><code>itemsetInfo(itemMatrix) &lt;- value</code>: replaces the item set/row info by a data.frame.
</p>
</li>
<li> <p><code>dimnames(itemMatrix)</code>: returns a list with the dimname vectors.
</p>
</li>
<li> <p><code>dimnames(x = itemMatrix) &lt;- value</code>: replace the dimnames.
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>data</code></dt><dd><p>a sparse matrix of class <a href="Matrix.html#topic+ngCMatrix-class">ngCMatrix</a> representing the itemsets.
<strong>Warning:</strong> the matrix is stored in transposed form for efficiency reasons!.</p>
</dd>
<dt><code>itemInfo</code></dt><dd><p>a data.frame</p>
</dd>
<dt><code>itemsetInfo</code></dt><dd><p>a data.frame</p>
</dd>
</dl>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form
<code>new("itemMatrix", ...)</code>.  However, most of the time objects will be
created by coercion from a matrix, list or data.frame.
</p>


<h3>Coercions</h3>


<ul>
<li> <p><code>as("matrix", "itemMatrix")</code>
</p>
</li>
<li> <p><code>as("itemMatrix", "matrix")</code>
</p>
</li>
<li> <p><code>as("list", "itemMatrix")</code>
</p>
</li>
<li> <p><code>as("itemMatrix", "list")</code>
</p>
</li>
<li> <p><code>as("itemMatrix", "ngCMatrix")</code>
</p>
</li>
<li> <p><code>as("ngCMatrix", "itemMatrix")</code>
</p>
</li></ul>

<p><strong>Warning:</strong> the <code>ngCMatrix</code> representation is transposed!
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other itemMatrix and transactions functions: 
<code><a href="#topic+abbreviate">abbreviate</a>()</code>,
<code><a href="#topic+crossTable">crossTable</a>()</code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+duplicated">duplicated</a>()</code>,
<code><a href="#topic+extract">extract</a></code>,
<code><a href="#topic+hierarchy">hierarchy</a></code>,
<code><a href="#topic+image">image</a>()</code>,
<code><a href="#topic+inspect">inspect</a>()</code>,
<code><a href="#topic+is.superset">is.superset</a>()</code>,
<code><a href="#topic+itemFrequencyPlot">itemFrequencyPlot</a>()</code>,
<code><a href="#topic+itemFrequency">itemFrequency</a>()</code>,
<code><a href="#topic+match">match</a>()</code>,
<code><a href="#topic+merge">merge</a>()</code>,
<code><a href="#topic+random.transactions">random.transactions</a>()</code>,
<code><a href="#topic+sample">sample</a>()</code>,
<code><a href="#topic+sets">sets</a></code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+supportingTransactions">supportingTransactions</a>()</code>,
<code><a href="#topic+tidLists-class">tidLists-class</a></code>,
<code><a href="#topic+transactions-class">transactions-class</a></code>,
<code><a href="#topic+unique">unique</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)

## Generate a logical matrix with 5000 random itemsets for 20 items
m &lt;- matrix(runif(5000 * 20) &gt; 0.8, ncol = 20,
            dimnames = list(NULL, paste("item", c(1:20), sep = "")))
head(m)

## Coerce the logical matrix into an itemMatrix object
imatrix &lt;- as(m, "itemMatrix")
imatrix

## An itemMatrix contains a set of itemsets (each row is an itemset).
## The length of the set is the number of rows.
length(imatrix)

## The sparese matrix also has regular matrix  dimensions.
dim(imatrix)
nrow(imatrix)
ncol(imatrix)

## Subsetting: Get first 5 elements (rows) of the itemMatrix. This can be done in
## several ways.
imatrix[1:5]            ### get elements 1:5
imatrix[1:5, ]          ### Matrix subsetting for rows 1:5
head(imatrix, n = 5)    ### head()

## Get first 5 elements (rows) of the itemMatrix as list.
as(imatrix[1:5], "list")

## Get first 5 elements (rows) of the itemMatrix as matrix.
as(imatrix[1:5], "matrix")

## Get first 5 elements (rows) of the itemMatrix as sparse ngCMatrix.
## **Warning:** For efficiency reasons, the ngCMatrix is transposed! You
## can transpose it again to get the expected format.
as(imatrix[1:5], "ngCMatrix")
t(as(imatrix[1:5], "ngCMatrix"))

## Get labels for the first 5 itemsets (first default and then with
## custom formating)
labels(imatrix[1:5])
labels(imatrix[1:5], itemSep = " + ", setStart = "", setEnd = "")

## Create itemsets manually from an itemMatrix. Itemsets contain items in the form of
## an itemMatrix and additional quality measures (not supplied in the example).
is &lt;- new("itemsets", items = imatrix)
is
inspect(head(is, n = 3))


## Create rules manually. I use imatrix[4:6] for the lhs of the rules and
## imatrix[1:3] for the rhs. Rhs and lhs cannot share items so I use
## itemSetdiff here. I also assign missing values for the quality measures support
## and confidence.
rules &lt;- new("rules",
             lhs = itemSetdiff(imatrix[4:6], imatrix[1:3]),
             rhs = imatrix[1:3],
             quality = data.frame(support = c(NA, NA, NA),
                                  confidence =  c(NA, NA, NA)
          ))
rules
inspect(rules)

## Manually create a itemMatrix with an item encoding that matches imatrix (20 items in order
## item1, item2, ..., item20)
itemset_list &lt;- list(c("item1","item2"),
                     c("item3"))

imatrix_new &lt;- encode(itemset_list, itemLabels = imatrix)
imatrix_new
compatible(imatrix_new, imatrix)

</code></pre>

<hr>
<h2 id='itemsets-class'>Class itemsets &mdash; A Set of Itemsets</h2><span id='topic+itemsets-class'></span><span id='topic+itemsets'></span><span id='topic+show+2Citemsets-method'></span><span id='topic+summary+2Citemsets-method'></span><span id='topic+summary.itemsets-class'></span><span id='topic+show+2Csummary.itemsets-method'></span><span id='topic+length+2Citemsets-method'></span><span id='topic+nitems+2Citemsets-method'></span><span id='topic+labels+2Citemsets-method'></span><span id='topic+itemLabels+2Citemsets-method'></span><span id='topic+itemLabels+3C-+2Citemsets-method'></span><span id='topic+itemInfo+2Citemsets-method'></span><span id='topic+items+2Citemsets-method'></span><span id='topic+items+3C-+2Citemsets-method'></span><span id='topic+tidLists+2Citemsets-method'></span><span id='topic+coercion-itemsets'></span><span id='topic+coerce+2Citemsets+2Cdata.frame-method'></span>

<h3>Description</h3>

<p>The <code>itemsets</code> class represents a set of itemsets and the associated
quality measures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>itemsets(items, itemLabels = NULL, quality = data.frame())

## S4 method for signature 'itemsets'
summary(object, ...)

## S4 method for signature 'itemsets'
length(x)

## S4 method for signature 'itemsets'
nitems(x)

## S4 method for signature 'itemsets'
labels(object, ...)

## S4 method for signature 'itemsets'
itemLabels(object)

## S4 replacement method for signature 'itemsets'
itemLabels(object) &lt;- value

## S4 method for signature 'itemsets'
itemInfo(object)

## S4 method for signature 'itemsets'
items(x)

## S4 replacement method for signature 'itemsets'
items(x) &lt;- value

## S4 method for signature 'itemsets'
tidLists(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="itemsets-class_+3A_items">items</code></td>
<td>
<p>an <a href="#topic+itemMatrix">itemMatrix</a> or an object that can be converted using <code><a href="#topic+encode">encode()</a></code>.</p>
</td></tr>
<tr><td><code id="itemsets-class_+3A_itemlabels">itemLabels</code></td>
<td>
<p>item labels used for <code>encode()</code>.</p>
</td></tr>
<tr><td><code id="itemsets-class_+3A_quality">quality</code></td>
<td>
<p>a data.frame with quality information (one row per itemset).</p>
</td></tr>
<tr><td><code id="itemsets-class_+3A_object">object</code>, <code id="itemsets-class_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
<tr><td><code id="itemsets-class_+3A_...">...</code></td>
<td>
<p>further argments</p>
</td></tr>
<tr><td><code id="itemsets-class_+3A_value">value</code></td>
<td>
<p>replacement value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Itemsets are usually created by calling an association rule mining algorithm
like <code><a href="#topic+apriori">apriori()</a></code>.
To create itemsets manually, the itemMatrix for the items of the itemsets
can be created using <a href="#topic+itemCoding">itemCoding</a>.  An example is in the Example
section below.
</p>
<p>Mined itemsets sets contain several interest measures accessible
with the <code>quality()</code> method.  Additional measures can be
calculated via <code><a href="#topic+interestMeasure">interestMeasure()</a></code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>summary(itemsets)</code>: create a summary
</p>
</li>
<li> <p><code>length(itemsets)</code>: get the number of itemsets.
</p>
</li>
<li> <p><code>nitems(itemsets)</code>: get the number of items (columns) in the current encoding.
</p>
</li>
<li> <p><code>labels(itemsets)</code>: get the itemset labels.
</p>
</li>
<li> <p><code>itemLabels(itemsets)</code>: get the item labels.
</p>
</li>
<li> <p><code>itemLabels(itemsets) &lt;- value</code>: replace the item labels.
</p>
</li>
<li> <p><code>itemInfo(itemsets)</code>: get item info data.frame.
</p>
</li>
<li> <p><code>items(itemsets)</code>: get items as an itemMatrix.
</p>
</li>
<li> <p><code>items(itemsets) &lt;- value</code>: with a different itemMatrix.
</p>
</li>
<li> <p><code>tidLists(itemsets)</code>: get tidLists stored in the object (if any).
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>items</code></dt><dd><p>an <a href="#topic+itemMatrix">itemMatrix</a> object representing the itemsets.</p>
</dd>
<dt><code>tidLists</code></dt><dd><p>a <a href="#topic+tidLists">tidLists</a> or <code>NULL</code>.</p>
</dd>
<dt><code>quality</code></dt><dd><p>a data.frame with quality information</p>
</dd>
<dt><code>info</code></dt><dd><p>a list with mining information.</p>
</dd>
</dl>


<h3>Objects from the Class</h3>

<p>Objects are the result of calling the
functions <code><a href="#topic+apriori">apriori()</a></code> (e.g., with <code>target = "frequent itemsets"</code> in the parameter list) or <code><a href="#topic+eclat">eclat()</a></code>.
</p>
<p>Objects can also
be created by calls of the form <code>new("itemsets", ...)</code>
or by using the constructor function
<code>itemsets()</code>.
</p>


<h3>Coercions</h3>


<ul>
<li> <p><code>as("itemsets", "data.frame")</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Superclass: <a href="#topic+associations">associations</a>
</p>
<p>Other associations functions: 
<code><a href="#topic+abbreviate">abbreviate</a>()</code>,
<code><a href="#topic+associations-class">associations-class</a></code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+duplicated">duplicated</a>()</code>,
<code><a href="#topic+extract">extract</a></code>,
<code><a href="#topic+inspect">inspect</a>()</code>,
<code><a href="#topic+is.closed">is.closed</a>()</code>,
<code><a href="#topic+is.generator">is.generator</a>()</code>,
<code><a href="#topic+is.maximal">is.maximal</a>()</code>,
<code><a href="#topic+is.redundant">is.redundant</a>()</code>,
<code><a href="#topic+is.significant">is.significant</a>()</code>,
<code><a href="#topic+is.superset">is.superset</a>()</code>,
<code><a href="#topic+match">match</a>()</code>,
<code><a href="#topic+rules-class">rules-class</a></code>,
<code><a href="#topic+sample">sample</a>()</code>,
<code><a href="#topic+sets">sets</a></code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+sort">sort</a>()</code>,
<code><a href="#topic+unique">unique</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Adult")

## Mine frequent itemsets with Eclat.
fsets &lt;- eclat(Adult, parameter = list(supp = 0.5))

## Display the 5 itemsets with the highest support.
fsets.top5 &lt;- sort(fsets)[1:5]
inspect(fsets.top5)

## Get the itemsets as a list
as(items(fsets.top5), "list")

## Get the itemsets as a binary matrix
as(items(fsets.top5), "matrix")

## Get the itemsets as a sparse matrix, a ngCMatrix from package Matrix.
## Warning: for efficiency reasons, the ngCMatrix you get is transposed
as(items(fsets.top5), "ngCMatrix")

## Manually create itemsets with the item coding in the Adult dataset
## and calculate some interest measures
twoitemsets &lt;- itemsets(
  items = list(
    c("age=Young", "relationship=Unmarried"),
    c("age=Old")
  ), itemLabels = Adult)

quality(twoitemsets) &lt;- data.frame(support = interestMeasure(twoitemsets,
  measure = c("support"), transactions = Adult))

inspect(twoitemsets)
</code></pre>

<hr>
<h2 id='itemwiseSetOps'>Itemwise Set Operations</h2><span id='topic+itemwiseSetOps'></span><span id='topic+itemSetOperations'></span><span id='topic+itemUnion'></span><span id='topic+itemSetdiff'></span><span id='topic+itemIntersect'></span><span id='topic+itemUnion+2CitemMatrix+2CitemMatrix-method'></span><span id='topic+itemSetdiff+2CitemMatrix+2CitemMatrix-method'></span><span id='topic+itemIntersect+2CitemMatrix+2CitemMatrix-method'></span>

<h3>Description</h3>

<p>Provides the generic functions and the methods for itemwise set
operations on items in an <a href="#topic+itemMatrix">itemMatrix</a>. The regular set operations regard each
itemset in an <code>itemMatrix</code> as an element. Itemwise operations regard each item
as an element and operate on the items of pairs of corresponding itemsets
(first itemset in <code>x</code> with first itemset in <code>y</code>, second with second, etc.).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>itemUnion(x, y)

itemSetdiff(x, y)

itemIntersect(x, y)

## S4 method for signature 'itemMatrix,itemMatrix'
itemUnion(x, y)

## S4 method for signature 'itemMatrix,itemMatrix'
itemSetdiff(x, y)

## S4 method for signature 'itemMatrix,itemMatrix'
itemIntersect(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="itemwiseSetOps_+3A_x">x</code>, <code id="itemwiseSetOps_+3A_y">y</code></td>
<td>
<p>two <a href="#topic+itemMatrix">itemMatrix</a> objects with the same number of rows (itemsets).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <a href="#topic+itemMatrix">itemMatrix</a> is returned.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Adult")

fsets &lt;- eclat(Adult, parameter = list(supp = 0.5))
inspect(fsets[1:4])
inspect(itemUnion(items(fsets[1:2]), items(fsets[3:4])))
inspect(itemSetdiff(items(fsets[1:2]), items(fsets[3:4])))
inspect(itemIntersect(items(fsets[1:2]), items(fsets[3:4])))
</code></pre>

<hr>
<h2 id='LIST'>List Representation for Objects Based on Class itemMatrix</h2><span id='topic+LIST'></span><span id='topic+LIST+2CitemMatrix-method'></span><span id='topic+LIST+2Ctransactions-method'></span><span id='topic+LIST+2CtidLists-method'></span>

<h3>Description</h3>

<p>Provides the generic function <code>LIST()</code> and the methods to create a
list representation from objects of the classes <a href="#topic+itemMatrix">itemMatrix</a>,
<a href="#topic+transactions">transactions</a>, and <a href="#topic+tidLists">tidLists</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LIST(from, ...)

## S4 method for signature 'itemMatrix'
LIST(from, decode = TRUE)

## S4 method for signature 'transactions'
LIST(from, decode = TRUE)

## S4 method for signature 'tidLists'
LIST(from, decode = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LIST_+3A_from">from</code></td>
<td>
<p>the object to be converted into a list.</p>
</td></tr>
<tr><td><code id="LIST_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
<tr><td><code id="LIST_+3A_decode">decode</code></td>
<td>
<p>a logical controlling whether the items/transactions are
decoded from the column numbers internally used by
<a href="#topic+itemMatrix">itemMatrix</a> to the names stored in the object
<code>from</code>.  The default behavior is to decode.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using <code>LIST()</code> with <code>decode = TRUE</code> is equivalent to the standard
coercion <code>as(x, "list")</code>.  <code>LIST</code> returns the object <code>from</code>
as a list of vectors.  Each vector represents one row of the
<a href="#topic+itemMatrix">itemMatrix</a> (e.g., items in a transaction).
</p>


<h3>Value</h3>

<p>a list primitive.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other import/export: 
<code><a href="#topic+DATAFRAME">DATAFRAME</a>()</code>,
<code><a href="#topic+pmml">pmml</a></code>,
<code><a href="#topic+read">read</a></code>,
<code><a href="#topic+write">write</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Adult)

### default coercion (same as as(Adult[1:5], "list"))
LIST(Adult[1:5])

### coercion without item decoding
LIST(Adult[1:5], decode = FALSE)
</code></pre>

<hr>
<h2 id='match'>Value Matching</h2><span id='topic+match'></span><span id='topic+match+2CitemMatrix+2CitemMatrix-method'></span><span id='topic+match+2Crules+2Crules-method'></span><span id='topic+match+2Citemsets+2Citemsets-method'></span><span id='topic++25in+25+2CitemMatrix+2CitemMatrix-method'></span><span id='topic++25in+25'></span><span id='topic++25in+25+2CitemMatrix+2Ccharacter-method'></span><span id='topic++25in+25+2Cassociations+2Cassociations-method'></span><span id='topic++25pin+25+2CitemMatrix+2Ccharacter-method'></span><span id='topic++25pin+25'></span><span id='topic++25ain+25+2CitemMatrix+2Ccharacter-method'></span><span id='topic++25ain+25'></span><span id='topic++25oin+25+2CitemMatrix+2Ccharacter-method'></span><span id='topic++25oin+25'></span>

<h3>Description</h3>

<p>Provides the generic function <code>match()</code> and the methods for
<a href="#topic+associations">associations</a>, <a href="#topic+transactions">transactions</a> and <a href="#topic+itemMatrix">itemMatrix</a> objects.  <code>match()</code> returns a vector
of the positions of (first) matches of its first argument in its second.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match(x, table, nomatch = NA_integer_, incomparables = NULL)

## S4 method for signature 'itemMatrix,itemMatrix'
match(x, table, nomatch = NA_integer_, incomparables = NULL)

## S4 method for signature 'rules,rules'
match(x, table, nomatch = NA_integer_, incomparables = NULL)

## S4 method for signature 'itemsets,itemsets'
match(x, table, nomatch = NA_integer_, incomparables = NULL)

## S4 method for signature 'itemMatrix,itemMatrix'
x %in% table

## S4 method for signature 'itemMatrix,character'
x %in% table

## S4 method for signature 'associations,associations'
x %in% table

## S4 method for signature 'itemMatrix,character'
x %pin% table

## S4 method for signature 'itemMatrix,character'
x %ain% table

## S4 method for signature 'itemMatrix,character'
x %oin% table
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_+3A_x">x</code></td>
<td>
<p>an object of class <a href="#topic+itemMatrix">itemMatrix</a>, <a href="#topic+transactions">transactions</a> or
<a href="#topic+associations">associations</a>.</p>
</td></tr>
<tr><td><code id="match_+3A_table">table</code></td>
<td>
<p>a set of associations or transactions to be matched against.</p>
</td></tr>
<tr><td><code id="match_+3A_nomatch">nomatch</code></td>
<td>
<p>the value to be returned in the case when no match is found.</p>
</td></tr>
<tr><td><code id="match_+3A_incomparables">incomparables</code></td>
<td>
<p>not implemented.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>%in%</code> is a more intuitive interface as a binary operator, which
returns a logical vector indicating if there is a match or not for the items
in the itemsets (left operand) with the items in the table (right operand).
</p>
<p><span class="pkg">arules</span> defines additional binary operators for matching itemsets:
<code style="white-space: pre;">&#8288;%pin%&#8288;</code> uses <em>partial matching</em> on the table; <code style="white-space: pre;">&#8288;%ain%&#8288;</code>
itemsets have to match/include <em>all</em> items in the table; <code style="white-space: pre;">&#8288;%oin%&#8288;</code>
itemsets can <em>only</em> match/include the items in the table.  The binary
matching operators or often used in <code><a href="#topic+subset">subset()</a></code>.
</p>


<h3>Value</h3>

<p><code>match</code>: An integer vector of the same length as <code>x</code>
giving the position in <code>table</code> of the first match if there is a match,
otherwise <code>nomatch</code>.
</p>
<p><code>%in%</code>, <code style="white-space: pre;">&#8288;%pin%&#8288;</code>, <code style="white-space: pre;">&#8288;%ain%&#8288;</code>, <code style="white-space: pre;">&#8288;%oin%&#8288;</code>: A logical vector,
indicating if a match was located for each element of <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other associations functions: 
<code><a href="#topic+abbreviate">abbreviate</a>()</code>,
<code><a href="#topic+associations-class">associations-class</a></code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+duplicated">duplicated</a>()</code>,
<code><a href="#topic+extract">extract</a></code>,
<code><a href="#topic+inspect">inspect</a>()</code>,
<code><a href="#topic+is.closed">is.closed</a>()</code>,
<code><a href="#topic+is.generator">is.generator</a>()</code>,
<code><a href="#topic+is.maximal">is.maximal</a>()</code>,
<code><a href="#topic+is.redundant">is.redundant</a>()</code>,
<code><a href="#topic+is.significant">is.significant</a>()</code>,
<code><a href="#topic+is.superset">is.superset</a>()</code>,
<code><a href="#topic+itemsets-class">itemsets-class</a></code>,
<code><a href="#topic+rules-class">rules-class</a></code>,
<code><a href="#topic+sample">sample</a>()</code>,
<code><a href="#topic+sets">sets</a></code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+sort">sort</a>()</code>,
<code><a href="#topic+unique">unique</a>()</code>
</p>
<p>Other itemMatrix and transactions functions: 
<code><a href="#topic+abbreviate">abbreviate</a>()</code>,
<code><a href="#topic+crossTable">crossTable</a>()</code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+duplicated">duplicated</a>()</code>,
<code><a href="#topic+extract">extract</a></code>,
<code><a href="#topic+hierarchy">hierarchy</a></code>,
<code><a href="#topic+image">image</a>()</code>,
<code><a href="#topic+inspect">inspect</a>()</code>,
<code><a href="#topic+is.superset">is.superset</a>()</code>,
<code><a href="#topic+itemFrequencyPlot">itemFrequencyPlot</a>()</code>,
<code><a href="#topic+itemFrequency">itemFrequency</a>()</code>,
<code><a href="#topic+itemMatrix-class">itemMatrix-class</a></code>,
<code><a href="#topic+merge">merge</a>()</code>,
<code><a href="#topic+random.transactions">random.transactions</a>()</code>,
<code><a href="#topic+sample">sample</a>()</code>,
<code><a href="#topic+sets">sets</a></code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+supportingTransactions">supportingTransactions</a>()</code>,
<code><a href="#topic+tidLists-class">tidLists-class</a></code>,
<code><a href="#topic+transactions-class">transactions-class</a></code>,
<code><a href="#topic+unique">unique</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Adult")

## get unique transactions, count frequency of unique transactions
## and plot frequency of unique transactions
vals &lt;- unique(Adult)
cnts &lt;- tabulate(match(Adult, vals))
plot(sort(cnts, decreasing=TRUE))

## find all transactions which are equal to transaction 10 in Adult
which(Adult %in% Adult[10])

## for transactions we can also match directly with itemLabels.
## Find in the first 10 transactions the ones which
## contain age=Middle-aged (see help page for class itemMatrix)
Adult[1:10] %in% "age=Middle-aged"

## find all transactions which contain items that partially match "age=" (all here).
Adult[1:10] %pin% "age="

## find all transactions that only include the item "age=Middle-aged" (none here).
Adult[1:10] %oin% "age=Middle-aged"

## find al transaction which contain both items "age=Middle-aged" and "sex=Male"
Adult[1:10] %ain% c("age=Middle-aged", "sex=Male")
</code></pre>

<hr>
<h2 id='merge'>Adding Items to Data</h2><span id='topic+merge'></span><span id='topic+merge+2CitemMatrix-method'></span><span id='topic+merge+2Ctransactions-method'></span>

<h3>Description</h3>

<p>Provides the generic function <code>merge()</code> and the methods for <a href="#topic+itemMatrix">itemMatrix</a>
and <a href="#topic+transactions">transactions</a> to add new items to existing data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge(x, y, ...)

## S4 method for signature 'itemMatrix'
merge(x, y, ...)

## S4 method for signature 'transactions'
merge(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_+3A_x">x</code></td>
<td>
<p>an object of class <a href="#topic+itemMatrix">itemMatrix</a> or <a href="#topic+transactions">transactions</a>.</p>
</td></tr>
<tr><td><code id="merge_+3A_y">y</code></td>
<td>
<p>an object of the same class as <code>x</code> (or something which can be coerced
to that class).</p>
</td></tr>
<tr><td><code id="merge_+3A_...">...</code></td>
<td>
<p>further arguments; unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a new object of the same class as <code>x</code> with the items in <code>y</code>
added.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other preprocessing: 
<code><a href="#topic+discretize">discretize</a>()</code>,
<code><a href="#topic+hierarchy">hierarchy</a></code>,
<code><a href="#topic+itemCoding">itemCoding</a></code>,
<code><a href="#topic+sample">sample</a>()</code>
</p>
<p>Other itemMatrix and transactions functions: 
<code><a href="#topic+abbreviate">abbreviate</a>()</code>,
<code><a href="#topic+crossTable">crossTable</a>()</code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+duplicated">duplicated</a>()</code>,
<code><a href="#topic+extract">extract</a></code>,
<code><a href="#topic+hierarchy">hierarchy</a></code>,
<code><a href="#topic+image">image</a>()</code>,
<code><a href="#topic+inspect">inspect</a>()</code>,
<code><a href="#topic+is.superset">is.superset</a>()</code>,
<code><a href="#topic+itemFrequencyPlot">itemFrequencyPlot</a>()</code>,
<code><a href="#topic+itemFrequency">itemFrequency</a>()</code>,
<code><a href="#topic+itemMatrix-class">itemMatrix-class</a></code>,
<code><a href="#topic+match">match</a>()</code>,
<code><a href="#topic+random.transactions">random.transactions</a>()</code>,
<code><a href="#topic+sample">sample</a>()</code>,
<code><a href="#topic+sets">sets</a></code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+supportingTransactions">supportingTransactions</a>()</code>,
<code><a href="#topic+tidLists-class">tidLists-class</a></code>,
<code><a href="#topic+transactions-class">transactions-class</a></code>,
<code><a href="#topic+unique">unique</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Groceries")

## create a random item as a matrix
randomItem &lt;- sample(c(TRUE, FALSE), size = length(Groceries),replace = TRUE)
randomItem &lt;- as.matrix(randomItem)
colnames(randomItem) &lt;- "random item"
head(randomItem, 3)

## add the random item to Groceries
g2 &lt;- merge(Groceries, randomItem)
nitems(Groceries)
nitems(g2)
inspect(head(g2, 3))

</code></pre>

<hr>
<h2 id='Mushroom'>The Mushroom Data Set as Transactions</h2><span id='topic+Mushroom'></span><span id='topic+mushroom'></span>

<h3>Description</h3>

<p>The <code>Mushroom</code> <a href="#topic+transactions">transactions</a> data set includes descriptions of hypothetical samples
corresponding to 23 species of gilled mushrooms in the Agaricus and Lepiota
Family.
</p>


<h3>Format</h3>

<p>Object of class <a href="#topic+transactions">transactions</a>
with 8124 transactions
and 114 items.
</p>


<h3>Details</h3>

<p>The transaction set contains information about 8124 mushrooms (transactions).  4208
(51.8%) are edible and 3916 (48.2%) are poisonous. The data contains 22
nominal features plus the class attribute (edible or not). These features
were translated into 114 items.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>Source</h3>

<p>The data set was obtained from the UCI Machine Learning Repository
at <a href="https://archive.ics.uci.edu/ml/datasets/Mushroom">https://archive.ics.uci.edu/ml/datasets/Mushroom</a>.
</p>


<h3>References</h3>

<p>Alfred A. Knopf (1981). Mushroom records drawn from The Audubon
Society Field Guide to North American Mushrooms. G. H. Lincoff (Pres.), New
York.
</p>

<hr>
<h2 id='pmml'>Read and Write PMML</h2><span id='topic+pmml'></span><span id='topic+write.PMML'></span><span id='topic+read.PMML'></span>

<h3>Description</h3>

<p>This function reads and writes PMML representations (version 4.1) of
<a href="#topic+associations">associations</a> (<a href="#topic+itemsets">itemsets</a> and <a href="#topic+rules">rules</a>). Write delegates to package <span class="pkg">pmml</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.PMML(x, file)

read.PMML(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pmml_+3A_x">x</code></td>
<td>
<p>a <a href="#topic+rules">rules</a> or <a href="#topic+itemsets">itemsets</a> object.</p>
</td></tr>
<tr><td><code id="pmml_+3A_file">file</code></td>
<td>
<p>name of the PMML file (for <code>read.PMML()</code> also a XML root node can be
supplied).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>References</h3>

<p>PMML 4.4 - Association Rules.
<a href="https://dmg.org/pmml/v4-4/AssociationRules.html">https://dmg.org/pmml/v4-4/AssociationRules.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="pmml.html#topic+pmml">pmml::pmml()</a></code>.
</p>
<p>Other import/export: 
<code><a href="#topic+DATAFRAME">DATAFRAME</a>()</code>,
<code><a href="#topic+LIST">LIST</a>()</code>,
<code><a href="#topic+read">read</a></code>,
<code><a href="#topic+write">write</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Groceries")

rules &lt;- apriori(Groceries, parameter = list(support = 0.001))
rules &lt;- head(rules, by = "lift")
rules

### save rules as PMML
write.PMML(rules, file = "rules.xml")

### read rules back
rules2 &lt;- read.PMML("rules.xml")
rules2

### compare rules
inspect(rules[1])
inspect(rules2[1])

### clean up
unlink("rules.xml")
</code></pre>

<hr>
<h2 id='predict'>Model Predictions</h2><span id='topic+predict'></span><span id='topic+predict+2CitemMatrix-method'></span>

<h3>Description</h3>

<p>Provides the method <code>predict()</code> for <a href="#topic+itemMatrix">itemMatrix</a> (e.g.,
transactions).  Predicts the membership (nearest neighbor) of new data to
clusters represented by medoids or labeled examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict(object, ...)

## S4 method for signature 'itemMatrix'
predict(object, newdata, labels = NULL, blocksize = 200, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_+3A_object">object</code></td>
<td>
<p>clustered examples as an <a href="#topic+itemMatrix">itemMatrix</a> with cluster label specified in <code>labels</code> or medoids as an <a href="#topic+itemMatrix">itemMatrix</a> (use <code>labels = NULL</code>).</p>
</td></tr>
<tr><td><code id="predict_+3A_...">...</code></td>
<td>
<p>further arguments passed on to <code><a href="#topic+dissimilarity">dissimilarity()</a></code>. E.g.,
<code>method</code>.</p>
</td></tr>
<tr><td><code id="predict_+3A_newdata">newdata</code></td>
<td>
<p>an <a href="#topic+itemMatrix">itemMatrix</a> containing the objects to predict labels for.</p>
</td></tr>
<tr><td><code id="predict_+3A_labels">labels</code></td>
<td>
<p>an integer vector containing the labels for the examples in
<code>object</code>. The cluster labels need to be contiguous integers starting with 1.</p>
</td></tr>
<tr><td><code id="predict_+3A_blocksize">blocksize</code></td>
<td>
<p>a numeric scalar indicating how much memory predict can use
for big <code>x</code> and/or <code>y</code> (approx. in MB). 200 is only a crude
approximation for 32-bit machines (64-bit architectures need double the
blocksize in memory) and using the default Jaccard method for dissimilarity
calculation.  In general, reducing <code>blocksize</code> will decrease the memory
usage but will increase the run-time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector of the same length as <code>newdata</code> containing
the predicted labels for each element.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other proximity classes and functions: 
<code><a href="#topic+affinity">affinity</a>()</code>,
<code><a href="#topic+dissimilarity">dissimilarity</a>()</code>,
<code><a href="#topic+proximity-classes">proximity-classes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Adult")

## sample
small &lt;- sample(Adult, 500)
large &lt;- sample(Adult, 5000)

## cluster a small sample and extract the cluster lael vector
d_jaccard &lt;- dissimilarity(small)
hc &lt;- hclust(d_jaccard)
l &lt;-  cutree(hc, k=4)

## predict labels for a larger sample
labels &lt;- predict(small, large, l)

## plot the profile of the 1. cluster
itemFrequencyPlot(large[labels == 1, itemFrequency(large) &gt; 0.1])
</code></pre>

<hr>
<h2 id='proximity-classes'>Classes dist, ar_cross_dissimilarity and ar_similarity &mdash; Proximity
Matrices</h2><span id='topic+proximity-classes'></span><span id='topic+ar_similarity-class'></span><span id='topic+ar_cross_dissimilarity-class'></span>

<h3>Description</h3>

<p>Simple classes to represent proximity matrices.
</p>


<h3>Details</h3>

<p>For compatibility with
clustering functions in <code>R</code>, we represent dissimilarities as the
<code>S3</code> class <code>dist</code>.  For cross-dissimilarities and similarities, we
provide the <code>S4</code> classes <code>ar_cross_dissimilarities</code> and
<code>ar_similarities</code>.
</p>


<h3>Objects from the Class</h3>

<p><code>dist</code> objects are the result of
calling the method <code>dissimilarity()</code> with one argument or any
<code>R</code> function returning a <code style="white-space: pre;">&#8288;S3 dist&#8288;</code> object.
</p>
<p><code>ar_cross_dissimilarity</code> objects are the result of calling the method
<code>dissimilarity()</code> with two arguments, by calls of the form
<code>new("similarity", ...)</code>, or by coercion from matrix.
</p>
<p><code>ar_similarity</code> objects are the result of calling the method
<code><a href="#topic+affinity">affinity()</a></code>, by calls of the form <code>new("similarity", ...)</code>,
or by coercion from matrix.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dist">stats::dist()</a></code>, <code><a href="proxy.html#topic+dist">proxy::dist()</a></code>
</p>
<p>Other proximity classes and functions: 
<code><a href="#topic+affinity">affinity</a>()</code>,
<code><a href="#topic+dissimilarity">dissimilarity</a>()</code>,
<code><a href="#topic+predict">predict</a>()</code>
</p>

<hr>
<h2 id='random.transactions'>Simulate a Random Transactions</h2><span id='topic+random.transactions'></span><span id='topic+random.patterns'></span>

<h3>Description</h3>

<p>Simulate random <a href="#topic+transactions">transactions</a> using different methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random.transactions(
  nItems,
  nTrans,
  method = "independent",
  ...,
  verbose = FALSE
)

random.patterns(
  nItems,
  nPats = 2000,
  method = NULL,
  lPats = 4,
  corr = 0.5,
  cmean = 0.5,
  cvar = 0.1,
  iWeight = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.transactions_+3A_nitems">nItems</code></td>
<td>
<p>an integer. Number of items to simulate</p>
</td></tr>
<tr><td><code id="random.transactions_+3A_ntrans">nTrans</code></td>
<td>
<p>an integer. Number of transactions to simulate</p>
</td></tr>
<tr><td><code id="random.transactions_+3A_method">method</code></td>
<td>
<p>name of the simulation method used (see Details Section).</p>
</td></tr>
<tr><td><code id="random.transactions_+3A_...">...</code></td>
<td>
<p>further arguments used for the specific simulation method (see
details).</p>
</td></tr>
<tr><td><code id="random.transactions_+3A_verbose">verbose</code></td>
<td>
<p>report progress?</p>
</td></tr>
<tr><td><code id="random.transactions_+3A_npats">nPats</code></td>
<td>
<p>number of patterns (potential maximal frequent itemsets) used.</p>
</td></tr>
<tr><td><code id="random.transactions_+3A_lpats">lPats</code></td>
<td>
<p>average length of patterns.</p>
</td></tr>
<tr><td><code id="random.transactions_+3A_corr">corr</code></td>
<td>
<p>correlation between consecutive patterns.</p>
</td></tr>
<tr><td><code id="random.transactions_+3A_cmean">cmean</code></td>
<td>
<p>mean of  the corruption level (normal distribution).</p>
</td></tr>
<tr><td><code id="random.transactions_+3A_cvar">cvar</code></td>
<td>
<p>variance of the corruption level.</p>
</td></tr>
<tr><td><code id="random.transactions_+3A_iweight">iWeight</code></td>
<td>
<p>item selection weights to build patterns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently two simulation methods are implemented:
</p>

<ul>
<li> <p><code>"independent"</code> (Hahsler et al, 2006): All items
are treated as independent. The transaction size is determined by
<code>rpois(lambda - 1) + 1</code>, where <code>lambda</code> can be specified (defaults to 3).
Note that one subtracted from lambda and added to the size to avoid
empty transactions. The items in the transactions are randomly chosen using
the numeric probability vector <code>iProb</code> of length <code>nItems</code>
(default: 0.01 for each item).
</p>
</li>
<li> <p><code>"agrawal"</code> (see Agrawal and Srikant, 1994): This
method creates transactions with correlated items using <code>random.patters()</code>.
The simulation is a two-stage process. First, a set of <code>nPats</code> patterns
(potential maximal frequent itemsets) is generated.  The length of the
patterns is Poisson distributed with mean <code>lPats</code> and consecutive
patterns share some items controlled by the correlation parameter
<code>corr</code>.  For later use, for each pattern a pattern weight is generated
by drawing from an exponential distribution with a mean of 1 and a
corruption level is chosen from a normal distribution with mean <code>cmean</code>
and variance <code>cvar</code>.
The function returns the patterns as an <code>itemsets</code> objects which can be
supplied to <code>random.transactions()</code> as the argument <code>patterns</code>.  If
no argument <code>patterns</code> is supplied, the default values given above are
used.
</p>
<p>In the second step, the transactions are generated using the patterns.  The
length the transactions follows a Poisson distribution with mean
<code>lPats</code>. For each transaction, patterns are randomly chosen using the
pattern weights till the transaction length is reached. For each chosen
pattern, the associated corruption level is used to drop some items before
adding the pattern to the transaction.
</p>
</li></ul>



<h3>Value</h3>

<p>Returns a <code style="white-space: pre;">&#8288;ntrans x nitems&#8288;</code> <a href="#topic+transactions">transactions</a> object.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>References</h3>

<p>Michael Hahsler, Kurt Hornik, and Thomas Reutterer (2006).
Implications of probabilistic data modeling for mining association rules. In
M. Spiliopoulou, R. Kruse, C. Borgelt, A. Nuernberger, and W. Gaul, editors,
<em>From Data and Information Analysis to Knowledge Engineering, Studies
in Classification, Data Analysis, and Knowledge Organization</em>, pages
598&ndash;605. Springer-Verlag.
</p>
<p>Rakesh Agrawal and Ramakrishnan Srikant (1994). Fast algorithms for mining
association rules in large databases. In Jorge B. Bocca, Matthias Jarke, and
Carlo Zaniolo, editors, <em>Proceedings of the 20th International
Conference on Very Large Data Bases, VLDB</em>, pages 487&ndash;499, Santiago, Chile.
</p>


<h3>See Also</h3>

<p>Other itemMatrix and transactions functions: 
<code><a href="#topic+abbreviate">abbreviate</a>()</code>,
<code><a href="#topic+crossTable">crossTable</a>()</code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+duplicated">duplicated</a>()</code>,
<code><a href="#topic+extract">extract</a></code>,
<code><a href="#topic+hierarchy">hierarchy</a></code>,
<code><a href="#topic+image">image</a>()</code>,
<code><a href="#topic+inspect">inspect</a>()</code>,
<code><a href="#topic+is.superset">is.superset</a>()</code>,
<code><a href="#topic+itemFrequencyPlot">itemFrequencyPlot</a>()</code>,
<code><a href="#topic+itemFrequency">itemFrequency</a>()</code>,
<code><a href="#topic+itemMatrix-class">itemMatrix-class</a></code>,
<code><a href="#topic+match">match</a>()</code>,
<code><a href="#topic+merge">merge</a>()</code>,
<code><a href="#topic+sample">sample</a>()</code>,
<code><a href="#topic+sets">sets</a></code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+supportingTransactions">supportingTransactions</a>()</code>,
<code><a href="#topic+tidLists-class">tidLists-class</a></code>,
<code><a href="#topic+transactions-class">transactions-class</a></code>,
<code><a href="#topic+unique">unique</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate random 1000 transactions for 200 items with
## a success probability decreasing from 0.2 to 0.0001
## using the method described in Hahsler et al. (2006).
trans &lt;- random.transactions(nItems = 200, nTrans = 1000,
   lambda = 5, iProb = seq(0.2,0.0001, length=200))

## size distribution
summary(size(trans))

## display random data set
image(trans)

## use the method by Agrawal and Srikant (1994) to simulate transactions
## which contains correlated items. This should create data similar to
## T10I4D100K (we just create 100 transactions here to speed things up).
patterns &lt;- random.patterns(nItems = 1000)
summary(patterns)

trans2 &lt;- random.transactions(nItems = 1000, nTrans = 100,
   method = "agrawal", patterns = patterns)
image(trans2)

## plot data with items ordered by item frequency
image(trans2[,order(itemFrequency(trans2), decreasing=TRUE)])
</code></pre>

<hr>
<h2 id='read'>Read Transaction Data</h2><span id='topic+read'></span><span id='topic+read.transactions'></span>

<h3>Description</h3>

<p>Reads transaction data from a file and creates a
<a href="#topic+transactions">transactions</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.transactions(
  file,
  format = c("basket", "single"),
  header = FALSE,
  sep = "",
  cols = NULL,
  rm.duplicates = FALSE,
  quote = "\"'",
  skip = 0,
  encoding = "unknown"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_+3A_file">file</code></td>
<td>
<p>the file name or a connection.</p>
</td></tr>
<tr><td><code id="read_+3A_format">format</code></td>
<td>
<p>a character string indicating the format of the data set.  One
of <code>"basket"</code> or <code>"single"</code>, can be abbreviated.</p>
</td></tr>
<tr><td><code id="read_+3A_header">header</code></td>
<td>
<p>a logical value indicating whether the file contains the names
of the variables as its first line.</p>
</td></tr>
<tr><td><code id="read_+3A_sep">sep</code></td>
<td>
<p>a character string specifying how fields are separated in the
data file. The default (<code>""</code>) splits at whitespaces.</p>
</td></tr>
<tr><td><code id="read_+3A_cols">cols</code></td>
<td>
<p>For the <em>single</em> format, <code>cols</code> is a numeric or
character vector of length two giving the numbers or names of the columns
(fields) with the transaction and item ids, respectively. If character, the
first line of <code>file</code> is assumed to be a header with column names.  For
the <em>basket</em> format, <code>cols</code> can be a numeric scalar giving the
number of the column (field) with the transaction ids.  If
<code>cols = NULL</code>, the data do not contain transaction ids.</p>
</td></tr>
<tr><td><code id="read_+3A_rm.duplicates">rm.duplicates</code></td>
<td>
<p>a logical value specifying if duplicate items should be
removed from the transactions.</p>
</td></tr>
<tr><td><code id="read_+3A_quote">quote</code></td>
<td>
<p>a list of characters used as quotes when reading.</p>
</td></tr>
<tr><td><code id="read_+3A_skip">skip</code></td>
<td>
<p>number of lines to skip in the file before start reading data.</p>
</td></tr>
<tr><td><code id="read_+3A_encoding">encoding</code></td>
<td>
<p>character string indicating the encoding which is passed to
<code><a href="base.html#topic+readLines">readLines()</a></code> or <code><a href="base.html#topic+scan">scan()</a></code> (see <a href="base.html#topic+Encoding">Encoding</a> for character encoding).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <em>basket</em> format, each line in the transaction data file
represents a transaction where the items (item labels) are separated by the
characters specified by <code>sep</code>.  For <em>single</em> format, each line
corresponds to a single item, containing at least ids for the transaction
and the item.
</p>


<h3>Value</h3>

<p>Returns an object of class <a href="#topic+transactions">transactions</a>.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler and Kurt Hornik
</p>


<h3>See Also</h3>

<p>Other import/export: 
<code><a href="#topic+DATAFRAME">DATAFRAME</a>()</code>,
<code><a href="#topic+LIST">LIST</a>()</code>,
<code><a href="#topic+pmml">pmml</a></code>,
<code><a href="#topic+write">write</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create a demo file using basket format for the example
data &lt;- paste(
  "# this is some test data",
  "item1, item2",
  "item1",
  "item2, item3",
  sep="\n")
cat(data)
write(data, file = "demo_basket.txt")

## read demo data (skip the comment in the first line)
tr &lt;- read.transactions("demo_basket.txt", format = "basket", sep = ",", skip = 1)
inspect(tr)
## make always sure that the items were properly separated
itemLabels(tr)

## create a demo file using single format for the example
## column 1 contains the transaction ID and column 2 contains one item
data &lt;- paste(
  "trans1 item1",
  "trans2 item1",
  "trans2 item2",
  sep ="\n")
cat(data)
write(data, file = "demo_single.txt")

## read demo data
tr &lt;- read.transactions("demo_single.txt", format = "single", cols = c(1,2))
inspect(tr)

## create a demo file using single format with column headers
data &lt;- paste(
  "item_id;trans_id",
  "item1;trans1",
  "item1;trans2",
  "item2;trans2",
  sep ="\n")
cat(data)
write(data, file = "demo_single.txt")

## read demo data
tr &lt;- read.transactions("demo_single.txt", format = "single",
  header = TRUE, sep = ";", cols = c("trans_id", "item_id"))
inspect(tr)

## tidy up
unlink("demo_basket.txt")
unlink("demo_single.txt")
</code></pre>

<hr>
<h2 id='ruleInduction'>Association Rule Induction from Itemsets</h2><span id='topic+ruleInduction'></span><span id='topic+ruleInduction+2Citemsets-method'></span>

<h3>Description</h3>

<p>Provides the generic function <code>ruleInduction()</code> and the method to induce all association
<a href="#topic+rules">rules</a> which can be generated by the given set of <a href="#topic+itemsets">itemsets</a> from a <a href="#topic+transactions">transactions</a>
dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ruleInduction(x, ...)

## S4 method for signature 'itemsets'
ruleInduction(
  x,
  transactions = NULL,
  confidence = 0.8,
  method = c("ptree", "apriori"),
  reduce = FALSE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ruleInduction_+3A_x">x</code></td>
<td>
<p>the set of <a href="#topic+itemsets">itemsets</a> from which rules will be induced.</p>
</td></tr>
<tr><td><code id="ruleInduction_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
<tr><td><code id="ruleInduction_+3A_transactions">transactions</code></td>
<td>
<p>the <a href="#topic+transactions">transactions</a> used to mine the itemsets. Can
be omitted for method <code>"ptree"</code>,
if <code>x</code> contains a (complete set) of frequent itemsets
together with their support counts.</p>
</td></tr>
<tr><td><code id="ruleInduction_+3A_confidence">confidence</code></td>
<td>
<p>a numeric value between 0 and 1 giving the minimum confidence
threshold for the rules.</p>
</td></tr>
<tr><td><code id="ruleInduction_+3A_method">method</code></td>
<td>
<p><code>"ptree"</code> or <code>"apriori"</code></p>
</td></tr>
<tr><td><code id="ruleInduction_+3A_reduce">reduce</code></td>
<td>
<p>remove unused items to speed up the counting process?</p>
</td></tr>
<tr><td><code id="ruleInduction_+3A_verbose">verbose</code></td>
<td>
<p>report progress?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All rules that can be created using the supplied itemsets and that surpass the
specified minimum confidence threshold are returned.
<code>ruleInduction()</code> can be used to produce
closed association rules defined by Pei
et al. (2000) as rules <code style="white-space: pre;">&#8288;X =&gt; Y&#8288;</code> where both <code>X</code> and <code>Y</code> are
closed frequent itemsets. See the code example in the Example section.
</p>
<p>Rule induction implements several induction methods. The default method is <code>"ptree"</code>
</p>

<ul>
<li> <p><code>"ptree"</code> <strong>method without transactions:</strong>
No transactions are need to be specified if
<code>x</code> contains a complete set of frequent or
itemsets. The itemsets' support counts are stored in a ptree and then retrieved to
create rules and calculate rules confidence. This is very fast,
but fails because of missing
support values if <code>x</code> is not a complete set of frequent itemsets.
</p>
</li>
<li> <p><code>"ptree"</code> <strong>method with transactions:</strong>
If transactions are specified then all transactions are counted into a prefix
tree and
later retrieved to create rules from the itemsets and calculate confidence values.
This is slower, but necessary if <code>x</code> is not a complete set of frequent itemsets.
To improve speed, unused items are removed from the transaction
data before creating the prefix tree (this behavior can be changed using the
argument <code>reduce</code>). This might be slower for large transaction
data sets. However, this is highly recommended as the items are also
reordered to reduce the counting time.
</p>
</li>
<li> <p><code>"apriori"</code> <strong>method (always needs transactions):</strong>
All association rules are mined from the transactions data set using <code><a href="#topic+apriori">apriori()</a></code>
with the
smallest support found in the itemsets. In a second step, all rules which cannot
be generated from one of the itemsets are removed. This procedure is very slow,
especially for itemsets with many elements or very low support.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <a href="#topic+rules">rules</a>.
</p>


<h3>Author(s)</h3>

<p>Christian Buchta and Michael Hahsler
</p>


<h3>References</h3>

<p>Michael Hahsler, Christian Buchta, and Kurt Hornik. Selective
association rule generation. <em>Computational Statistics,</em> 23(2):303-315,
April 2008.
</p>
<p>Jian Pei, Jiawei Han, Runying Mao. CLOSET: An Efficient Algorithm for Mining
Frequent Closed Itemsets. <em>ACM SIGMOD Workshop on Research Issues in Data
Mining and Knowledge Discovery (DMKD 2000).</em>
</p>


<h3>See Also</h3>

<p>Other mining algorithms: 
<code><a href="#topic+APappearance-class">APappearance-class</a></code>,
<code><a href="#topic+AScontrol-classes">AScontrol-classes</a></code>,
<code><a href="#topic+ASparameter-classes">ASparameter-classes</a></code>,
<code><a href="#topic+apriori">apriori</a>()</code>,
<code><a href="#topic+eclat">eclat</a>()</code>,
<code><a href="#topic+fim4r">fim4r</a>()</code>,
<code><a href="#topic+weclat">weclat</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Adult")

## find all closed frequent itemsets
closed_is &lt;- apriori(Adult, target = "closed frequent itemsets", support = 0.4)
closed_is

## use rule induction to produce all closed association rules
closed_rules &lt;- ruleInduction(closed_is, transactions = Adult, verbose = TRUE)

## inspect the resulting closed rules
summary(closed_rules)
inspect(head(closed_rules, by = "lift"))

## get rules from frequent itemsets. Here, transactions does not need to be
## specified for rule induction.
frequent_is  &lt;- eclat(Adult, support = 0.4)
assoc_rules &lt;- ruleInduction(frequent_is)
assoc_rules
inspect(head(assoc_rules))

## for itemsets that are not a complete set of frequent itemsets,
## transactions need to be specified.
some_is &lt;- sample(frequent_is, 10)
some_rules &lt;- ruleInduction(some_is, transactions = Adult)
some_rules
</code></pre>

<hr>
<h2 id='rules-class'>Class rules &mdash; A Set of Rules</h2><span id='topic+rules-class'></span><span id='topic+rules'></span><span id='topic+initialize+2Crules-method'></span><span id='topic+summary+2Crules-method'></span><span id='topic+summary.rules-class'></span><span id='topic+show+2Csummary.rules-method'></span><span id='topic+length+2Crules-method'></span><span id='topic+nitems+2Crules-method'></span><span id='topic+labels+2Crules-method'></span><span id='topic+itemLabels+2Crules-method'></span><span id='topic+itemLabels+3C-+2Crules-method'></span><span id='topic+itemInfo+2Crules-method'></span><span id='topic+lhs'></span><span id='topic+lhs+2Crules-method'></span><span id='topic+lhs+3C-'></span><span id='topic+lhs+3C-+2Crules-method'></span><span id='topic+rhs'></span><span id='topic+rhs+3C-'></span><span id='topic+rhs+3C-+2Crules-method'></span><span id='topic+rhs+2Crules-method'></span><span id='topic+items+2Crules-method'></span><span id='topic+generatingItemsets'></span><span id='topic+generatingItemsets+2Crules-method'></span><span id='topic+coercion-rules'></span><span id='topic+coerce+2Crules+2Cdata.frame-method'></span>

<h3>Description</h3>

<p>Defines the <code>rules</code> class to represent a set of association rules and methods to work
with <code>rules</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rules(rhs, lhs, itemLabels = NULL, quality = data.frame())

## S4 method for signature 'rules'
summary(object, ...)

## S4 method for signature 'rules'
length(x)

## S4 method for signature 'rules'
nitems(x)

## S4 method for signature 'rules'
labels(object, ruleSep = " =&gt; ", ...)

## S4 method for signature 'rules'
itemLabels(object)

## S4 replacement method for signature 'rules'
itemLabels(object) &lt;- value

## S4 method for signature 'rules'
itemInfo(object)

lhs(x)

## S4 method for signature 'rules'
lhs(x)

lhs(x) &lt;- value

## S4 replacement method for signature 'rules'
lhs(x) &lt;- value

rhs(x)

rhs(x) &lt;- value

## S4 replacement method for signature 'rules'
rhs(x) &lt;- value

## S4 method for signature 'rules'
rhs(x)

## S4 method for signature 'rules'
items(x)

generatingItemsets(x)

## S4 method for signature 'rules'
generatingItemsets(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rules-class_+3A_rhs">rhs</code>, <code id="rules-class_+3A_lhs">lhs</code></td>
<td>
<p><a href="#topic+itemMatrix">itemMatrix</a> objects or objects that can be converted using <code><a href="#topic+encode">encode()</a></code>.</p>
</td></tr>
<tr><td><code id="rules-class_+3A_itemlabels">itemLabels</code></td>
<td>
<p>a vector of all
possible item labels (character) or a transactions object to copy the item
coding used for <code>encode()</code> (see <a href="#topic+itemCoding">itemCoding</a> for details).</p>
</td></tr>
<tr><td><code id="rules-class_+3A_quality">quality</code></td>
<td>
<p>a data.frame with quality information (one row per rule).</p>
</td></tr>
<tr><td><code id="rules-class_+3A_object">object</code>, <code id="rules-class_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
<tr><td><code id="rules-class_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
<tr><td><code id="rules-class_+3A_rulesep">ruleSep</code></td>
<td>
<p>rule separation symbol</p>
</td></tr>
<tr><td><code id="rules-class_+3A_value">value</code></td>
<td>
<p>replacement value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Mined rule sets typically contain several interest measures accessible with
the <code><a href="#topic+quality">quality()</a></code> method. Additional measures can be calculated via
<code><a href="#topic+interestMeasure">interestMeasure()</a></code>.
</p>
<p>To create rules manually, the itemMatrix for the LHS and the RHS of the
rules need to be compatible. See <a href="#topic+itemCoding">itemCoding</a> for details.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>summary(rules)</code>: create a summary
</p>
</li>
<li> <p><code>length(rules)</code>: returns the number of rules.
</p>
</li>
<li> <p><code>nitems(rules)</code>: returns the number of items used in the current encoding.
</p>
</li>
<li> <p><code>labels(rules)</code>: labels for the rules.
</p>
</li>
<li> <p><code>itemLabels(rules)</code>: returns item labels for the current encoding.
</p>
</li>
<li> <p><code>itemLabels(rules) &lt;- value</code>: change the item labels in the current encoding.
</p>
</li>
<li> <p><code>itemInfo(rules)</code>: returns the item info data.frame.
</p>
</li>
<li> <p><code>lhs(rules)</code>: returns the LHS of the rules as an <a href="#topic+itemMatrix">itemMatrix</a>.
</p>
</li>
<li> <p><code>lhs(rules) &lt;- value</code>: replaces the LHS of the rules with an <a href="#topic+itemMatrix">itemMatrix</a>.
</p>
</li>
<li> <p><code>rhs(rules) &lt;- value</code>: replaces the RHS of the rules with an <a href="#topic+itemMatrix">itemMatrix</a>.
</p>
</li>
<li> <p><code>rhs(rules)</code>: returns the RHS of the rules as an <a href="#topic+itemMatrix">itemMatrix</a>.
</p>
</li>
<li> <p><code>items(rules)</code>: returns all items in a rule (LHS and RHS) an <a href="#topic+itemMatrix">itemMatrix</a>.
</p>
</li>
<li> <p><code>generatingItemsets(rules)</code>: returns a collection of the itemsets which generated the rules, one itemset for each rule. Note that the collection can be a multiset and contain duplicated elements. Use <code><a href="#topic+unique">unique()</a></code> to remove duplicates and obtain a proper set. This method produces the same as the result as calling <code>items()</code>, but wrapped into an <a href="#topic+itemsets">itemsets</a> object with support information.
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>lhs,rhs</code></dt><dd><p><a href="#topic+itemMatrix">itemMatrix</a> representing the left-hand-side and right-hand-side of
the rules.</p>
</dd>
<dt><code>quality</code></dt><dd><p>the quality data.frame</p>
</dd>
<dt><code>info</code></dt><dd><p>a list with mining information.</p>
</dd>
</dl>


<h3>Objects from the Class</h3>

<p>Objects are the result of calling the
function <code><a href="#topic+apriori">apriori()</a></code>. Objects can also be created by calls of the
form <code>new("rules", ...)</code>
or by using the constructor function <code>rules()</code>.
</p>


<h3>Coercions</h3>


<ul>
<li> <p><code>as("rules", "data.frame")</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Superclass: <a href="#topic+associations">associations</a>
</p>
<p>Other associations functions: 
<code><a href="#topic+abbreviate">abbreviate</a>()</code>,
<code><a href="#topic+associations-class">associations-class</a></code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+duplicated">duplicated</a>()</code>,
<code><a href="#topic+extract">extract</a></code>,
<code><a href="#topic+inspect">inspect</a>()</code>,
<code><a href="#topic+is.closed">is.closed</a>()</code>,
<code><a href="#topic+is.generator">is.generator</a>()</code>,
<code><a href="#topic+is.maximal">is.maximal</a>()</code>,
<code><a href="#topic+is.redundant">is.redundant</a>()</code>,
<code><a href="#topic+is.significant">is.significant</a>()</code>,
<code><a href="#topic+is.superset">is.superset</a>()</code>,
<code><a href="#topic+itemsets-class">itemsets-class</a></code>,
<code><a href="#topic+match">match</a>()</code>,
<code><a href="#topic+sample">sample</a>()</code>,
<code><a href="#topic+sets">sets</a></code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+sort">sort</a>()</code>,
<code><a href="#topic+unique">unique</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Adult")

## Mine rules
rules &lt;- apriori(Adult, parameter = list(support = 0.3))
rules

## Select a subset of rules using partial matching on the items
## in the right-hand-side and a quality measure
rules.sub &lt;- subset(rules, subset = rhs %pin% "sex" &amp; lift &gt; 1.3)

## Display the top 3 support rules
inspect(head(rules.sub, n = 3, by = "support"))

## Display the first 3 rules
inspect(rules.sub[1:3])

## Get labels for the first 3 rules
labels(rules.sub[1:3])
labels(rules.sub[1:3], itemSep = " + ", setStart = "", setEnd="",
  ruleSep = " ---&gt; ")

## Manually create rules using the item coding in Adult and calculate some interest measures
twoRules &lt;- rules(
  lhs = list(
    c("age=Young", "relationship=Unmarried"),
    c("age=Old")
  ),
  rhs = list(
    c("income=small"),
    c("income=large")
  ),
  itemLabels = Adult
)

quality(twoRules) &lt;- interestMeasure(twoRules,
  measure = c("support", "confidence", "lift"), transactions = Adult)

inspect(twoRules)

</code></pre>

<hr>
<h2 id='sample'>Random Samples and Permutations</h2><span id='topic+sample'></span><span id='topic+sample+2CitemMatrix-method'></span><span id='topic+sample+2Cassociations-method'></span>

<h3>Description</h3>

<p>Provides the generic function <code>sample()</code> and methods to sample from <a href="#topic+transactions">transactions</a> and
<a href="#topic+associations">associations</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'itemMatrix'
sample(x, size, replace = FALSE, prob = NULL, ...)

## S4 method for signature 'associations'
sample(x, size, replace = FALSE, prob = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_+3A_x">x</code></td>
<td>
<p>object to be sampled from (a set of <a href="#topic+associations">associations</a> or
<a href="#topic+transactions">transactions</a>).</p>
</td></tr>
<tr><td><code id="sample_+3A_size">size</code></td>
<td>
<p>sample size.</p>
</td></tr>
<tr><td><code id="sample_+3A_replace">replace</code></td>
<td>
<p>a logical. Sample with replacement?</p>
</td></tr>
<tr><td><code id="sample_+3A_prob">prob</code></td>
<td>
<p>a numeric vector of probability weights.</p>
</td></tr>
<tr><td><code id="sample_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same class as <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other preprocessing: 
<code><a href="#topic+discretize">discretize</a>()</code>,
<code><a href="#topic+hierarchy">hierarchy</a></code>,
<code><a href="#topic+itemCoding">itemCoding</a></code>,
<code><a href="#topic+merge">merge</a>()</code>
</p>
<p>Other associations functions: 
<code><a href="#topic+abbreviate">abbreviate</a>()</code>,
<code><a href="#topic+associations-class">associations-class</a></code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+duplicated">duplicated</a>()</code>,
<code><a href="#topic+extract">extract</a></code>,
<code><a href="#topic+inspect">inspect</a>()</code>,
<code><a href="#topic+is.closed">is.closed</a>()</code>,
<code><a href="#topic+is.generator">is.generator</a>()</code>,
<code><a href="#topic+is.maximal">is.maximal</a>()</code>,
<code><a href="#topic+is.redundant">is.redundant</a>()</code>,
<code><a href="#topic+is.significant">is.significant</a>()</code>,
<code><a href="#topic+is.superset">is.superset</a>()</code>,
<code><a href="#topic+itemsets-class">itemsets-class</a></code>,
<code><a href="#topic+match">match</a>()</code>,
<code><a href="#topic+rules-class">rules-class</a></code>,
<code><a href="#topic+sets">sets</a></code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+sort">sort</a>()</code>,
<code><a href="#topic+unique">unique</a>()</code>
</p>
<p>Other itemMatrix and transactions functions: 
<code><a href="#topic+abbreviate">abbreviate</a>()</code>,
<code><a href="#topic+crossTable">crossTable</a>()</code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+duplicated">duplicated</a>()</code>,
<code><a href="#topic+extract">extract</a></code>,
<code><a href="#topic+hierarchy">hierarchy</a></code>,
<code><a href="#topic+image">image</a>()</code>,
<code><a href="#topic+inspect">inspect</a>()</code>,
<code><a href="#topic+is.superset">is.superset</a>()</code>,
<code><a href="#topic+itemFrequencyPlot">itemFrequencyPlot</a>()</code>,
<code><a href="#topic+itemFrequency">itemFrequency</a>()</code>,
<code><a href="#topic+itemMatrix-class">itemMatrix-class</a></code>,
<code><a href="#topic+match">match</a>()</code>,
<code><a href="#topic+merge">merge</a>()</code>,
<code><a href="#topic+random.transactions">random.transactions</a>()</code>,
<code><a href="#topic+sets">sets</a></code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+supportingTransactions">supportingTransactions</a>()</code>,
<code><a href="#topic+tidLists-class">tidLists-class</a></code>,
<code><a href="#topic+transactions-class">transactions-class</a></code>,
<code><a href="#topic+unique">unique</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Adult")

## sample with replacement
s &lt;- sample(Adult, 500, replace = TRUE)
s
</code></pre>

<hr>
<h2 id='sets'>Set Operations</h2><span id='topic+sets'></span><span id='topic+setOperations'></span><span id='topic+union.itemMatrix'></span><span id='topic+union.associations'></span><span id='topic+union+2Cassociations-method'></span><span id='topic+union+2CitemMatrix-method'></span><span id='topic+intersect.itemMatrix'></span><span id='topic+intersect.associations'></span><span id='topic+intersect+2Cassociations-method'></span><span id='topic+intersect+2CitemMatrix-method'></span><span id='topic+setequal.itemMatrix'></span><span id='topic+setequal.associations'></span><span id='topic+setequal+2Cassociations-method'></span><span id='topic+setequal+2CitemMatrix-method'></span><span id='topic+setdiff.itemMatrix'></span><span id='topic+setdiff.associations'></span><span id='topic+setdiff+2Cassociations-method'></span><span id='topic+setdiff+2CitemMatrix-method'></span><span id='topic+is.element.itemMatrix'></span><span id='topic+is.element.associations'></span><span id='topic+is.element+2Cassociations-method'></span><span id='topic+is.element+2CitemMatrix-method'></span>

<h3>Description</h3>

<p>Provides the generic functions and the methods for the set operations
<code>union()</code>, <code>intersect()</code>, <code>setequal()</code>, <code>setdiff()</code> and
<code>is.element()</code> on sets of <a href="#topic+associations">associations</a> (e.g., <a href="#topic+rules">rules</a>, <a href="#topic+itemsets">itemsets</a>) and
<a href="#topic+itemMatrix">itemMatrix</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'itemMatrix'
union(x, y, ...)

## S3 method for class 'associations'
union(x, y, ...)

## S4 method for signature 'associations'
union(x, y, ...)

## S4 method for signature 'itemMatrix'
union(x, y, ...)

## S3 method for class 'itemMatrix'
intersect(x, y, ...)

## S3 method for class 'associations'
intersect(x, y, ...)

## S4 method for signature 'associations'
intersect(x, y, ...)

## S4 method for signature 'itemMatrix'
intersect(x, y, ...)

## S3 method for class 'itemMatrix'
setequal(x, y, ...)

## S3 method for class 'associations'
setequal(x, y, ...)

## S4 method for signature 'associations'
setequal(x, y, ...)

## S4 method for signature 'itemMatrix'
setequal(x, y, ...)

## S3 method for class 'itemMatrix'
setdiff(x, y, ...)

## S3 method for class 'associations'
setdiff(x, y, ...)

## S4 method for signature 'associations'
setdiff(x, y, ...)

## S4 method for signature 'itemMatrix'
setdiff(x, y, ...)

## S3 method for class 'itemMatrix'
is.element(el, set, ...)

## S3 method for class 'associations'
is.element(el, set, ...)

## S4 method for signature 'associations'
is.element(el, set, ...)

## S4 method for signature 'itemMatrix'
is.element(el, set, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sets_+3A_x">x</code>, <code id="sets_+3A_y">y</code>, <code id="sets_+3A_el">el</code>, <code id="sets_+3A_set">set</code></td>
<td>
<p>sets of associations or itemMatrix objects.</p>
</td></tr>
<tr><td><code id="sets_+3A_...">...</code></td>
<td>
<p>Other arguments are unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Technical note: All S4 methods for set operations are defined for the class name
<code>"ANY"</code> in the signature, so they should work for all S4 classes for
which the following methods are available: <code><a href="#topic+match">match()</a></code>, <code><a href="base.html#topic+length">length()</a></code> and
<code><a href="#topic+unique">unique()</a></code>.
</p>


<h3>Value</h3>

<p><code>union()</code>, <code>intersect()</code>, <code>setequal()</code> and <code>setdiff()</code>
return an object of the same class as <code>x</code> and <code>y</code>.
</p>
<p><code>is.element()</code> returns a logic vector of length <code>el</code> indicating for
each element if it is included in <code>set</code>.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other associations functions: 
<code><a href="#topic+abbreviate">abbreviate</a>()</code>,
<code><a href="#topic+associations-class">associations-class</a></code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+duplicated">duplicated</a>()</code>,
<code><a href="#topic+extract">extract</a></code>,
<code><a href="#topic+inspect">inspect</a>()</code>,
<code><a href="#topic+is.closed">is.closed</a>()</code>,
<code><a href="#topic+is.generator">is.generator</a>()</code>,
<code><a href="#topic+is.maximal">is.maximal</a>()</code>,
<code><a href="#topic+is.redundant">is.redundant</a>()</code>,
<code><a href="#topic+is.significant">is.significant</a>()</code>,
<code><a href="#topic+is.superset">is.superset</a>()</code>,
<code><a href="#topic+itemsets-class">itemsets-class</a></code>,
<code><a href="#topic+match">match</a>()</code>,
<code><a href="#topic+rules-class">rules-class</a></code>,
<code><a href="#topic+sample">sample</a>()</code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+sort">sort</a>()</code>,
<code><a href="#topic+unique">unique</a>()</code>
</p>
<p>Other itemMatrix and transactions functions: 
<code><a href="#topic+abbreviate">abbreviate</a>()</code>,
<code><a href="#topic+crossTable">crossTable</a>()</code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+duplicated">duplicated</a>()</code>,
<code><a href="#topic+extract">extract</a></code>,
<code><a href="#topic+hierarchy">hierarchy</a></code>,
<code><a href="#topic+image">image</a>()</code>,
<code><a href="#topic+inspect">inspect</a>()</code>,
<code><a href="#topic+is.superset">is.superset</a>()</code>,
<code><a href="#topic+itemFrequencyPlot">itemFrequencyPlot</a>()</code>,
<code><a href="#topic+itemFrequency">itemFrequency</a>()</code>,
<code><a href="#topic+itemMatrix-class">itemMatrix-class</a></code>,
<code><a href="#topic+match">match</a>()</code>,
<code><a href="#topic+merge">merge</a>()</code>,
<code><a href="#topic+random.transactions">random.transactions</a>()</code>,
<code><a href="#topic+sample">sample</a>()</code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+supportingTransactions">supportingTransactions</a>()</code>,
<code><a href="#topic+tidLists-class">tidLists-class</a></code>,
<code><a href="#topic+transactions-class">transactions-class</a></code>,
<code><a href="#topic+unique">unique</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Adult")

## mine some rules
r &lt;- apriori(Adult)

## take 2 subsets
r1 &lt;- r[1:10]
r2 &lt;- r[6:15]

union(r1, r2)
intersect(r1, r2)
setequal(r1, r2)

</code></pre>

<hr>
<h2 id='size'>Number of Items in Sets</h2><span id='topic+size'></span><span id='topic+size+2CitemMatrix-method'></span><span id='topic+size+2CtidLists-method'></span><span id='topic+size+2Citemsets-method'></span><span id='topic+size+2Crules-method'></span>

<h3>Description</h3>

<p>Provides the generic function <code>size()</code> and methods to get the size of
each itemset in an <a href="#topic+itemMatrix">itemMatrix</a> or <a href="#topic+associations">associations</a>. For
example, <code>size()</code> can be used to get a vector with the number of items in each
transaction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>size(x, ...)

## S4 method for signature 'itemMatrix'
size(x)

## S4 method for signature 'tidLists'
size(x)

## S4 method for signature 'itemsets'
size(x)

## S4 method for signature 'rules'
size(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="size_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
<tr><td><code id="size_+3A_...">...</code></td>
<td>
<p>further (unused) arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a numeric vector of length <code>length(x)</code>.
Each element is the size of the corresponding element (row in the <a href="#topic+itemMatrix">itemMatrix</a>) in
object <code>x</code>. For <a href="#topic+rules">rules</a>, <code>size()</code> returns the sum of the number of
items in the LHS and the RHS.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other itemMatrix and transactions functions: 
<code><a href="#topic+abbreviate">abbreviate</a>()</code>,
<code><a href="#topic+crossTable">crossTable</a>()</code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+duplicated">duplicated</a>()</code>,
<code><a href="#topic+extract">extract</a></code>,
<code><a href="#topic+hierarchy">hierarchy</a></code>,
<code><a href="#topic+image">image</a>()</code>,
<code><a href="#topic+inspect">inspect</a>()</code>,
<code><a href="#topic+is.superset">is.superset</a>()</code>,
<code><a href="#topic+itemFrequencyPlot">itemFrequencyPlot</a>()</code>,
<code><a href="#topic+itemFrequency">itemFrequency</a>()</code>,
<code><a href="#topic+itemMatrix-class">itemMatrix-class</a></code>,
<code><a href="#topic+match">match</a>()</code>,
<code><a href="#topic+merge">merge</a>()</code>,
<code><a href="#topic+random.transactions">random.transactions</a>()</code>,
<code><a href="#topic+sample">sample</a>()</code>,
<code><a href="#topic+sets">sets</a></code>,
<code><a href="#topic+supportingTransactions">supportingTransactions</a>()</code>,
<code><a href="#topic+tidLists-class">tidLists-class</a></code>,
<code><a href="#topic+transactions-class">transactions-class</a></code>,
<code><a href="#topic+unique">unique</a>()</code>
</p>
<p>Other associations functions: 
<code><a href="#topic+abbreviate">abbreviate</a>()</code>,
<code><a href="#topic+associations-class">associations-class</a></code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+duplicated">duplicated</a>()</code>,
<code><a href="#topic+extract">extract</a></code>,
<code><a href="#topic+inspect">inspect</a>()</code>,
<code><a href="#topic+is.closed">is.closed</a>()</code>,
<code><a href="#topic+is.generator">is.generator</a>()</code>,
<code><a href="#topic+is.maximal">is.maximal</a>()</code>,
<code><a href="#topic+is.redundant">is.redundant</a>()</code>,
<code><a href="#topic+is.significant">is.significant</a>()</code>,
<code><a href="#topic+is.superset">is.superset</a>()</code>,
<code><a href="#topic+itemsets-class">itemsets-class</a></code>,
<code><a href="#topic+match">match</a>()</code>,
<code><a href="#topic+rules-class">rules-class</a></code>,
<code><a href="#topic+sample">sample</a>()</code>,
<code><a href="#topic+sets">sets</a></code>,
<code><a href="#topic+sort">sort</a>()</code>,
<code><a href="#topic+unique">unique</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Adult")
summary(size(Adult))

</code></pre>

<hr>
<h2 id='sort'>Sort Associations</h2><span id='topic+sort'></span><span id='topic+SORT'></span><span id='topic+sort+2Cassociations-method'></span>

<h3>Description</h3>

<p>Provides the method <code>sort</code> to sort elements in class
<a href="#topic+associations">associations</a> (e.g., itemsets or rules) according to the
value of measures stored in the association's slot <code>quality</code> (e.g.,
support).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'associations'
sort(x, decreasing = TRUE, na.last = NA, by = "support", order = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort_+3A_x">x</code></td>
<td>
<p>an object to be sorted.</p>
</td></tr>
<tr><td><code id="sort_+3A_decreasing">decreasing</code></td>
<td>
<p>a logical. Should the sort be increasing or decreasing?
(default is decreasing)</p>
</td></tr>
<tr><td><code id="sort_+3A_na.last">na.last</code></td>
<td>
<p>na.last is not supported for associations.  NAs are always
put last.</p>
</td></tr>
<tr><td><code id="sort_+3A_by">by</code></td>
<td>
<p>a character string specifying the quality measure stored in
<code>x</code> to be used to sort <code>x</code>. If a vector of character strings is
specified then the additional strings are used to sort <code>x</code> in case of
ties.</p>
</td></tr>
<tr><td><code id="sort_+3A_order">order</code></td>
<td>
<p>should a order vector (a permutation like <code><a href="base.html#topic+order">order()</a></code>)
be returned instead of the sorted associations?</p>
</td></tr>
<tr><td><code id="sort_+3A_...">...</code></td>
<td>
<p>Further arguments are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sort</code> is relatively slow for large sets of associations since it has
to copy and rearrange a large data structure.
With <code>order = TRUE</code> an integer vector with the
order is returned instead of the reordered associations.
</p>
<p>If only the top <code>n</code> associations are needed then <code><a href="#topic+head">head()</a></code> using
<code>by</code> performs this faster than calling <code>sort()</code> and then <code><a href="#topic+head">head()</a></code>
since it does it without copying and rearranging all the data.  <code><a href="#topic+tail">tail()</a></code>
works in the same way.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>x</code> or a permutation vector.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other associations functions: 
<code><a href="#topic+abbreviate">abbreviate</a>()</code>,
<code><a href="#topic+associations-class">associations-class</a></code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+duplicated">duplicated</a>()</code>,
<code><a href="#topic+extract">extract</a></code>,
<code><a href="#topic+inspect">inspect</a>()</code>,
<code><a href="#topic+is.closed">is.closed</a>()</code>,
<code><a href="#topic+is.generator">is.generator</a>()</code>,
<code><a href="#topic+is.maximal">is.maximal</a>()</code>,
<code><a href="#topic+is.redundant">is.redundant</a>()</code>,
<code><a href="#topic+is.significant">is.significant</a>()</code>,
<code><a href="#topic+is.superset">is.superset</a>()</code>,
<code><a href="#topic+itemsets-class">itemsets-class</a></code>,
<code><a href="#topic+match">match</a>()</code>,
<code><a href="#topic+rules-class">rules-class</a></code>,
<code><a href="#topic+sample">sample</a>()</code>,
<code><a href="#topic+sets">sets</a></code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+unique">unique</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Adult")

## Mine rules with Apriori
rules &lt;- apriori(Adult, parameter = list(supp = 0.6))

rules_by_lift &lt;- sort(rules, by = "lift")

inspect(head(rules))
inspect(head(rules_by_lift))

## A faster/less memory consuming way to get the top 5 rules according to lift
## (see Details section)
inspect(head(rules, n = 5, by = "lift"))
</code></pre>

<hr>
<h2 id='subset'>Subsetting Itemsets, Rules and Transactions</h2><span id='topic+subset'></span><span id='topic+subset+2CitemMatrix-method'></span><span id='topic+subset+2Citemsets-method'></span><span id='topic+subset+2Crules-method'></span>

<h3>Description</h3>

<p>Provides the generic function <code>subset()</code> and methods to subset
<a href="#topic+associations">associations</a> or <a href="#topic+transactions">transactions</a> (<a href="#topic+itemMatrix">itemMatrix</a>) which meet certain conditions
(e.g., contains certain items or satisfies a minimum lift).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subset(x, ...)

## S4 method for signature 'itemMatrix'
subset(x, subset, ...)

## S4 method for signature 'itemsets'
subset(x, subset, ...)

## S4 method for signature 'rules'
subset(x, subset, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset_+3A_x">x</code></td>
<td>
<p>object to be subsetted.</p>
</td></tr>
<tr><td><code id="subset_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.</p>
</td></tr>
<tr><td><code id="subset_+3A_subset">subset</code></td>
<td>
<p>logical expression indicating elements to keep.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>subset()</code> finds the rows/itemsets/rules of <code>x</code> that match the expression
given in <code>subset</code>. Parts of <code>x</code> like items, lhs, rhs and the columns in the quality data.frame (e.g., support and lift) can be directly referred to by their names
in <code>subset</code>.
</p>
<p>Important operators to select itemsets containing items specified by their
labels are
</p>

<ul>
<li> <p><a href="#topic++25in+25">%in%</a>: select itemsets matching <em>any</em> given item
</p>
</li>
<li> <p><a href="#topic++25ain+25">%ain%</a>: select only itemsets matching <em>all</em> given item
</p>
</li>
<li> <p><a href="#topic++25oin+25">%oin%</a>: select only itemsets matching <em>only</em> the given item
</p>
</li>
<li> <p><a href="#topic++25pin+25">%pin%</a>: <code>%in%</code> with <em>partial matching</em>
</p>
</li></ul>



<h3>Value</h3>

<p>An object of the same class as <code>x</code> containing only the elements
which satisfy the conditions.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Adult")
rules &lt;- apriori(Adult)

## select all rules with item "marital-status=Never-married" in 
## the right-hand-side and lift &gt; 2
rules.sub &lt;- subset(rules, subset = rhs %in% "marital-status=Never-married" 
    &amp; lift &gt; 2)

## use partial matching for all items corresponding to the variable
## "marital-status"
rules.sub &lt;- subset(rules, subset = rhs %pin% "marital-status=")

## select only rules with items "age=Young" and "workclass=Private" in
## the left-hand-side
rules.sub &lt;- subset(rules, subset = lhs %ain% 
    c("age=Young", "workclass=Private"))
</code></pre>

<hr>
<h2 id='SunBai'>The SunBai Weighted Transactions Data Set</h2><span id='topic+SunBai'></span><span id='topic+sunbai'></span>

<h3>Description</h3>

<p>A small example database for weighted association rule mining provided as an
object of class <a href="#topic+transactions">transactions</a>.
</p>


<h3>Format</h3>

<p>Object of class <a href="#topic+transactions">transactions</a> with 6 transactions and 8 items. Weights are stored as transaction information.
</p>


<h3>Details</h3>

<p>The data set contains the example database described in the paper by K. Sun
and F.Bai for illustration of the concepts of weighted association rule
mining. <code>weight</code> stored as transaction information denotes the
transaction weights obtained using the HITS algorithm.
</p>


<h3>Source</h3>

<p>K. Sun and F. Bai (2008). Mining Weighted Association Rules without
Preassigned Weights. <em>IEEE Transactions on Knowledge and Data
Engineering</em>, 4 (30), 489&ndash;495.
</p>


<h3>See Also</h3>

<p>Other weighted association mining functions: 
<code><a href="#topic+hits">hits</a>()</code>,
<code><a href="#topic+weclat">weclat</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(SunBai)
summary(SunBai)
inspect(SunBai)

transactionInfo(SunBai)
</code></pre>

<hr>
<h2 id='support'>Support Counting for Itemsets</h2><span id='topic+support'></span><span id='topic+support+2CitemMatrix-method'></span><span id='topic+support+2Cassociations-method'></span>

<h3>Description</h3>

<p>Provides the generic function <code>support()</code> and the methods to count support for
given <a href="#topic+itemMatrix">itemMatrix</a> and <a href="#topic+associations">associations</a> in a given <a href="#topic+transactions">transactions</a>
data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>support(x, transactions, ...)

## S4 method for signature 'itemMatrix'
support(
  x,
  transactions,
  type = c("relative", "absolute"),
  method = c("ptree", "tidlists"),
  reduce = FALSE,
  weighted = FALSE,
  verbose = FALSE,
  ...
)

## S4 method for signature 'associations'
support(
  x,
  transactions,
  type = c("relative", "absolute"),
  method = c("ptree", "tidlists"),
  reduce = FALSE,
  weighted = FALSE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="support_+3A_x">x</code></td>
<td>
<p>the set of itemsets for which support should be counted.</p>
</td></tr>
<tr><td><code id="support_+3A_transactions">transactions</code></td>
<td>
<p>the transaction data set used for mining.</p>
</td></tr>
<tr><td><code id="support_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
<tr><td><code id="support_+3A_type">type</code></td>
<td>
<p>a character string specifying if <code>"relative"</code> support or
<code>"absolute"</code> support (counts) are returned for the itemsets in
<code>x</code>.  (default: <code>"relative"</code>)</p>
</td></tr>
<tr><td><code id="support_+3A_method">method</code></td>
<td>
<p>use <code>"ptree"</code> or <code>"tidlists"</code>. See Details Section.</p>
</td></tr>
<tr><td><code id="support_+3A_reduce">reduce</code></td>
<td>
<p>should unused items are removed before counting?</p>
</td></tr>
<tr><td><code id="support_+3A_weighted">weighted</code></td>
<td>
<p>should support be weighted by transactions weights stored as
column <code>"weight"</code> in <code>transactionInfo</code>?</p>
</td></tr>
<tr><td><code id="support_+3A_verbose">verbose</code></td>
<td>
<p>report progress?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Normally, the support of frequent itemsets is very efficiently counted during
mining process using a set minimum support.
However, if only the support for specific itemsets (maybe itemsets with very low support)
is needed, or the support of a set of itemsets needs to be recalculated on
different <a href="#topic+transactions">transactions</a> than they were mined on, then <code>support()</code> can be used.
</p>
<p>Several methods for support counting are available:
</p>

<ul>
<li> <p><code>"ptree"</code> (default method): The counters for the itemsets
are organized in a prefix tree. The transactions are sequentially processed
and the corresponding counters in the prefix tree are incremented (see
Hahsler et al, 2008). This method is used by default since it is typically
significantly faster than transaction ID list intersection.
</p>
</li>
<li> <p><code>"tidlists"</code>: support is counted using
transaction ID list intersection which is used by several fast mining
algorithms (e.g., by Eclat). However, Support is determined for each itemset
individually which is slow for a large number of long itemsets in dense
data.
</p>
</li></ul>

<p>To speed up counting, <code>reduce = TRUE</code> can be specified in control. Unused items
are removed from the transactions before counting.
</p>


<h3>Value</h3>

<p>A numeric vector of the same length as <code>x</code> containing the
support values for the sets in <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler and Christian Buchta
</p>


<h3>References</h3>

<p>Michael Hahsler, Christian Buchta, and Kurt Hornik. Selective
association rule generation. <em>Computational Statistics</em>, 23(2):303-315,
April 2008.
</p>


<h3>See Also</h3>

<p>Other interest measures: 
<code><a href="#topic+confint">confint</a>()</code>,
<code><a href="#topic+coverage">coverage</a>()</code>,
<code><a href="#topic+interestMeasure">interestMeasure</a>()</code>,
<code><a href="#topic+is.redundant">is.redundant</a>()</code>,
<code><a href="#topic+is.significant">is.significant</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Income")

## find and some frequent itemsets
itemsets &lt;- eclat(Income)[1:5]

## inspect the support returned by eclat
inspect(itemsets)

## count support in the database
support(items(itemsets), Income)
</code></pre>

<hr>
<h2 id='supportingTransactions'>Supporting Transactions</h2><span id='topic+supportingTransactions'></span><span id='topic+supportingTransactions+2Cassociations-method'></span>

<h3>Description</h3>

<p>Find for each itemset in an <a href="#topic+associations">associations</a> object which transactions support
(i.e., contains all items in the itemset) it. The information is returned
as a <a href="#topic+tidLists">tidLists</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supportingTransactions(x, transactions, ...)

## S4 method for signature 'associations'
supportingTransactions(x, transactions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="supportingTransactions_+3A_x">x</code></td>
<td>
<p>a set of <a href="#topic+associations">associations</a> (<a href="#topic+itemsets">itemsets</a>, <a href="#topic+rules">rules</a>, etc.)</p>
</td></tr>
<tr><td><code id="supportingTransactions_+3A_transactions">transactions</code></td>
<td>
<p>an object of class <a href="#topic+transactions">transactions</a> used to mine the
associations in <code>x</code>.</p>
</td></tr>
<tr><td><code id="supportingTransactions_+3A_...">...</code></td>
<td>
<p>currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <a href="#topic+tidLists">tidLists</a> containing one transaction ID
list per association in <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other itemMatrix and transactions functions: 
<code><a href="#topic+abbreviate">abbreviate</a>()</code>,
<code><a href="#topic+crossTable">crossTable</a>()</code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+duplicated">duplicated</a>()</code>,
<code><a href="#topic+extract">extract</a></code>,
<code><a href="#topic+hierarchy">hierarchy</a></code>,
<code><a href="#topic+image">image</a>()</code>,
<code><a href="#topic+inspect">inspect</a>()</code>,
<code><a href="#topic+is.superset">is.superset</a>()</code>,
<code><a href="#topic+itemFrequencyPlot">itemFrequencyPlot</a>()</code>,
<code><a href="#topic+itemFrequency">itemFrequency</a>()</code>,
<code><a href="#topic+itemMatrix-class">itemMatrix-class</a></code>,
<code><a href="#topic+match">match</a>()</code>,
<code><a href="#topic+merge">merge</a>()</code>,
<code><a href="#topic+random.transactions">random.transactions</a>()</code>,
<code><a href="#topic+sample">sample</a>()</code>,
<code><a href="#topic+sets">sets</a></code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+tidLists-class">tidLists-class</a></code>,
<code><a href="#topic+transactions-class">transactions-class</a></code>,
<code><a href="#topic+unique">unique</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- list(
	c("a","b","c"),
	c("a","b"),
	c("a","b","d"),
	c("b","e"),
	c("b","c","e"),
	c("a","d","e"),
	c("a","c"),
	c("a","b","d"),
	c("c","e"),
	c("a","b","d","e")
	)
data &lt;- as(data, "transactions")

## mine itemsets
f &lt;- eclat(data, parameter = list(support = .2, minlen = 3))
inspect(f)

## find supporting Transactions
st &lt;- supportingTransactions(f, data)
st

as(st, "list")
</code></pre>

<hr>
<h2 id='tidLists-class'>Class tidLists &mdash; Transaction ID Lists for Items/Itemsets</h2><span id='topic+tidLists-class'></span><span id='topic+tidLists'></span><span id='topic+initialize+2CtidLists-method'></span><span id='topic+show+2CtidLists-method'></span><span id='topic+summary+2CtidLists-method'></span><span id='topic+summary.tidLists-class'></span><span id='topic+show+2Csummary.tidLists-method'></span><span id='topic+dim+2CtidLists-method'></span><span id='topic+dimnames+2CtidLists-method'></span><span id='topic+dimnames+3C-+2CtidLists+2Clist-method'></span><span id='topic+length+2CtidLists-method'></span><span id='topic+t+2CtidLists-method'></span><span id='topic+transactionInfo+2CtidLists-method'></span><span id='topic+transactionInfo+3C-+2CtidLists-method'></span><span id='topic+itemInfo+2CtidLists-method'></span><span id='topic+itemInfo+3C-+2CtidLists-method'></span><span id='topic+itemLabels+2CtidLists-method'></span><span id='topic+labels+2CtidLists-method'></span><span id='topic+coercion-tidLists'></span><span id='topic+coerce+2CtidLists+2Cmatrix-method'></span><span id='topic+coerce+2CtidLists+2Clist-method'></span><span id='topic+coerce+2Clist+2CtidLists-method'></span><span id='topic+coerce+2CtidLists+2CngCMatrix-method'></span><span id='topic+coerce+2CtidLists+2Ctransactions-method'></span><span id='topic+coerce+2Ctransactions+2CtidLists-method'></span><span id='topic+coerce+2CtidLists+2CitemMatrix-method'></span><span id='topic+coerce+2CitemMatrix+2CtidLists-method'></span>

<h3>Description</h3>

<p>Class to represent transaction ID lists and associated methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidLists(x)

## S4 method for signature 'tidLists'
summary(object, maxsum = 6, ...)

## S4 method for signature 'tidLists'
dim(x)

## S4 method for signature 'tidLists'
dimnames(x)

## S4 replacement method for signature 'tidLists,list'
dimnames(x) &lt;- value

## S4 method for signature 'tidLists'
length(x)

## S4 method for signature 'tidLists'
t(x)

## S4 method for signature 'tidLists'
transactionInfo(x)

## S4 replacement method for signature 'tidLists'
transactionInfo(x) &lt;- value

## S4 method for signature 'tidLists'
itemInfo(object)

## S4 replacement method for signature 'tidLists'
itemInfo(object) &lt;- value

## S4 method for signature 'tidLists'
itemLabels(object)

## S4 method for signature 'tidLists'
labels(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidLists-class_+3A_x">x</code>, <code id="tidLists-class_+3A_object">object</code></td>
<td>
<p>the object</p>
</td></tr>
<tr><td><code id="tidLists-class_+3A_maxsum">maxsum</code></td>
<td>
<p>maximum numbers of itemsets shown in the summary</p>
</td></tr>
<tr><td><code id="tidLists-class_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
<tr><td><code id="tidLists-class_+3A_value">value</code></td>
<td>
<p>replacement value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Transaction ID lists contains a set of lists.  Each list is associated with
an item/itemset and stores the IDs of the transactions which support the
item/itemset.
</p>
<p><code>tidLists</code> uses the class
<a href="Matrix.html#topic+nsparseMatrix-classes">Matrix::ngCMatrix</a> to efficiently store the
transaction ID lists as a sparse matrix.  Each column in the matrix
represents one transaction ID list.
</p>
<p><code>tidLists</code> can be used for different purposes.  For some operations
(e.g., support counting) it is efficient to coerce a
<a href="#topic+transactions">transactions</a> database into <code>tidLists</code> where each
list contains the transaction IDs for an item (and the support is given by
the length of the list).
</p>
<p>The implementation of the Eclat mining algorithm (which uses transaction ID
list intersection) can also produce transaction ID lists for the found
itemsets as part of the returned <a href="#topic+itemsets">itemsets</a> object.
These lists can then be used for further computation.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>summary(tidLists)</code>: create a summary
</p>
</li>
<li> <p><code>dim(tidLists)</code>: get dimensions. The rows represent the itemsets and the
columns are the transactions.
</p>
</li>
<li> <p><code>dimnames(tidLists)</code>: get dimnames
</p>
</li>
<li> <p><code>dimnames(x = tidLists) &lt;- value</code>: replace dimnames
</p>
</li>
<li> <p><code>length(tidLists)</code>: get the number of itemsets.
</p>
</li>
<li> <p><code>t(tidLists)</code>: this object is not transposable.
<code>t()</code> results in an error.
</p>
</li>
<li> <p><code>transactionInfo(tidLists)</code>: get the transaction info data.frame
</p>
</li>
<li> <p><code>transactionInfo(tidLists) &lt;- value</code>: replace the the transaction info data.frame
</p>
</li>
<li> <p><code>itemInfo(tidLists)</code>: get the item info data.frame
</p>
</li>
<li> <p><code>itemInfo(tidLists) &lt;- value</code>: replace the item info data.frame
</p>
</li>
<li> <p><code>itemLabels(tidLists)</code>: get the item labels
</p>
</li>
<li> <p><code>labels(tidLists)</code>: convert the tid lists into a text representation.
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>data</code></dt><dd><p>an object of class <a href="Matrix.html#topic+ngCMatrix-class">ngCMatrix</a> from package <span class="pkg">Matrix</span>.</p>
</dd>
<dt><code>itemInfo</code></dt><dd><p>a data.frame</p>
</dd>
<dt><code>transactionInfo</code></dt><dd><p>a data.frame</p>
</dd>
</dl>


<h3>Objects from the Class</h3>

<p>Objects are created
</p>

<ul>
<li><p> as part of the
<a href="#topic+itemsets">itemsets</a> mined by <code><a href="#topic+eclat">eclat()</a></code> with <code>tidLists = TRUE</code> in the
<a href="#topic+ECparameter">ECparameter</a> object.
</p>
</li>
<li><p> by <code><a href="#topic+supportingTransactions">supportingTransactions()</a></code>.
</p>
</li>
<li><p> by coercion from
an object of class <a href="#topic+transactions">transactions</a>.
</p>
</li>
<li><p> by calls of the form  <code>new("tidLists", ...)</code>.
</p>
</li></ul>



<h3>Coercions</h3>


<ul>
<li> <p><code>as("tidLists", "list")</code>
</p>
</li>
<li> <p><code>as("list", "tidLists")</code>
</p>
</li>
<li> <p><code>as("tidLists", "ngCMatrix")</code>
</p>
</li>
<li> <p><code>as("tidLists", "transactions")</code>
</p>
</li>
<li> <p><code>as("transactions", "tidLists")</code>
</p>
</li>
<li> <p><code>as("tidLists", "itemMatrix")</code>
</p>
</li>
<li> <p><code>as("itemMatrix", "tidLists")</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other itemMatrix and transactions functions: 
<code><a href="#topic+abbreviate">abbreviate</a>()</code>,
<code><a href="#topic+crossTable">crossTable</a>()</code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+duplicated">duplicated</a>()</code>,
<code><a href="#topic+extract">extract</a></code>,
<code><a href="#topic+hierarchy">hierarchy</a></code>,
<code><a href="#topic+image">image</a>()</code>,
<code><a href="#topic+inspect">inspect</a>()</code>,
<code><a href="#topic+is.superset">is.superset</a>()</code>,
<code><a href="#topic+itemFrequencyPlot">itemFrequencyPlot</a>()</code>,
<code><a href="#topic+itemFrequency">itemFrequency</a>()</code>,
<code><a href="#topic+itemMatrix-class">itemMatrix-class</a></code>,
<code><a href="#topic+match">match</a>()</code>,
<code><a href="#topic+merge">merge</a>()</code>,
<code><a href="#topic+random.transactions">random.transactions</a>()</code>,
<code><a href="#topic+sample">sample</a>()</code>,
<code><a href="#topic+sets">sets</a></code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+supportingTransactions">supportingTransactions</a>()</code>,
<code><a href="#topic+transactions-class">transactions-class</a></code>,
<code><a href="#topic+unique">unique</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create transaction data set.
data &lt;- list(
  c("a","b","c"),
  c("a","b"),
  c("a","b","d"),
  c("b","e"),
  c("b","c","e"),
  c("a","d","e"),
  c("a","c"),
  c("a","b","d"),
  c("c","e"),
  c("a","b","d","e")
  )
data &lt;- as(data, "transactions")
data

## convert transactions to transaction ID lists
tl &lt;- as(data, "tidLists")
tl

inspect(tl)
dim(tl)
dimnames(tl)

## inspect visually
image(tl)

## mine itemsets with transaction ID lists
f &lt;- eclat(data, parameter = list(support = 0, tidLists = TRUE))
tl2 &lt;- tidLists(f)
inspect(tl2)
</code></pre>

<hr>
<h2 id='transactions-class'>Class transactions &mdash; Binary Incidence Matrix for Transactions</h2><span id='topic+transactions-class'></span><span id='topic+transactions'></span><span id='topic+initialize+2Ctransactions-method'></span><span id='topic+show+2Ctransactions-method'></span><span id='topic+summary+2Ctransactions-method'></span><span id='topic+summary.transactions-class'></span><span id='topic+show+2Csummary.transactions-method'></span><span id='topic+toLongFormat+2Ctransactions-method'></span><span id='topic+t-transactions'></span><span id='topic+t+2Ctransactions-method'></span><span id='topic+items+2Ctransactions-method'></span><span id='topic+transactionInfo'></span><span id='topic+transactionInfo+2Ctransactions-method'></span><span id='topic+transactionInfo+3C-'></span><span id='topic+transactionInfo+3C-+2Ctransactions-method'></span><span id='topic+dimnames+2Ctransactions-method'></span><span id='topic+dimnames+3C-+2Ctransactions+2Clist-method'></span><span id='topic+coercion-transactions'></span><span id='topic+coerce+2Ctransactions+2Cmatrix-method'></span><span id='topic+coerce+2Cmatrix+2Ctransactions-method'></span><span id='topic+coerce+2Clist+2Ctransactions-method'></span><span id='topic+coerce+2Ctransactions+2Clist-method'></span><span id='topic+coerce+2Cdata.frame+2Ctransactions-method'></span><span id='topic+coerce+2Ctransactions+2Cdata.frame-method'></span><span id='topic+coerce+2CngCMatrix+2Ctransactions-method'></span>

<h3>Description</h3>

<p>The <code>transactions</code> class is a subclass of <a href="#topic+itemMatrix">itemMatrix</a> and
represents transaction data used for mining <a href="#topic+associations">associations</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transactions(
  x,
  itemLabels = NULL,
  transactionInfo = NULL,
  format = "wide",
  cols = NULL
)

## S4 method for signature 'transactions'
summary(object)

## S4 method for signature 'transactions'
toLongFormat(from, cols = c("TID", "item"), decode = TRUE)

## S4 method for signature 'transactions'
items(x)

transactionInfo(x)

## S4 method for signature 'transactions'
transactionInfo(x)

transactionInfo(x) &lt;- value

## S4 replacement method for signature 'transactions'
transactionInfo(x) &lt;- value

## S4 method for signature 'transactions'
dimnames(x)

## S4 replacement method for signature 'transactions,list'
dimnames(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transactions-class_+3A_x">x</code>, <code id="transactions-class_+3A_object">object</code>, <code id="transactions-class_+3A_from">from</code></td>
<td>
<p>the object</p>
</td></tr>
<tr><td><code id="transactions-class_+3A_itemlabels">itemLabels</code></td>
<td>
<p>a vector with labels for the items</p>
</td></tr>
<tr><td><code id="transactions-class_+3A_transactioninfo">transactionInfo</code></td>
<td>
<p>a transaction information data.frame with one row per transaction.</p>
</td></tr>
<tr><td><code id="transactions-class_+3A_format">format</code></td>
<td>
<p><code>"wide"</code> or <code>"long"</code> format?
Format wide is a regular data.frame where each row contains an object.
Format &quot;long&quot; is a data.frame with one column with transaction IDs and one with an
item (see <code>cols</code> below).</p>
</td></tr>
<tr><td><code id="transactions-class_+3A_cols">cols</code></td>
<td>
<p>a numeric or character vector of length two giving the index or names of
the columns (fields) with the transaction and item ids in the long format.</p>
</td></tr>
<tr><td><code id="transactions-class_+3A_decode">decode</code></td>
<td>
<p>translate item IDs to item labels?</p>
</td></tr>
<tr><td><code id="transactions-class_+3A_value">value</code></td>
<td>
<p>replacement value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Transactions store the presence of items in each individual transaction
as binary matrix where rows represent the transactions and columns represent the items.
<code>transactions</code> direct extends class <a href="#topic+itemMatrix">itemMatrix</a>
to store the sparse binary incidence matrix, item labels, and optionally transaction
IDs and user IDs. If you work with several transaction sets at the
same time, then the encoding (order of the items in the binary matrix) in
the different sets is important. See <a href="#topic+itemCoding">itemCoding</a> to learn how
to encode and recode transaction sets.
</p>
<p><strong>Data Preparation</strong>
</p>
<p>Data typically starts as a data.frame or a matrix and needs to be
prepared before it can be converted into <code>transactions</code> (see coercion methods in
the Methods Section and the Example Section below for details on the needed
format).
</p>
<p>Columns need to represent items which is different depending on the data type of
the column:
</p>

<ul>
<li> <p><strong>Continuous variables:</strong> Continuous variables cannot directly be represented as
items and need to be
discretized first. An item resulting from discretization might be
<code>age&gt;18</code> and the column contains only <code>TRUE</code> or <code>FALSE</code>.
Alternatively, it can be a factor with levels <code>age&lt;=18</code>,
<code style="white-space: pre;">&#8288;50=&gt;age&gt;18&#8288;</code> and <code>age&gt;50</code>. These will be automatically converted
into 3 items, one for each level. Discretization is described in functions
<code><a href="#topic+discretize">discretize()</a></code> and <code><a href="#topic+discretizeDF">discretizeDF()</a></code>.
</p>
</li>
<li> <p><strong>Logical variables:</strong> A logical variable describing a person could be
<code>tall</code> indicating if the person is tall using the values <code>TRUE</code>
and <code>FALSE</code>. The fact that the person is tall would be encoded in the
transaction containing the item <code>tall</code> while not tall persons would not
have this item. Therefore, for logical variables, the <code>TRUE</code> value is
converted into an item with the name of the variable and for the
<code>FALSE</code> values no item is created.
</p>
</li>
<li> <p><strong>Factors:</strong> Columns with nominal values
(i.e., <a href="base.html#topic+factor">factor</a>, <a href="base.html#topic+ordered">ordered</a>) are translated into a series of binary items (one for each level
constructed as <code style="white-space: pre;">&#8288;variable name = level&#8288;</code>). Items cannot represent order and this ordered factors
lose the order information. Note that nominal variables
need to be encoded as factors (and not characters or numbers). This can be
done with
</p>
<p><code>data[,"a_nominal_var"] &lt;- factor(data[,"a_nominal_var"])</code>.
</p>
<p>Complete examples for how to prepare data can be found in the man pages for
<a href="#topic+Income">Income</a> and <a href="#topic+Adult">Adult</a>.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>summary(transactions)</code>: produce a summary
</p>
</li>
<li> <p><code>toLongFormat(transactions)</code>: convert the transactions to long format
(a data.frame with two columns, tid and item). Column names can
be specified as a character vector of length 2 called <code>cols</code>.
</p>
</li>
<li> <p><code>items(transactions)</code>: get the transactions as an <a href="#topic+itemMatrix">itemMatrix</a>
</p>
</li>
<li> <p><code>transactionInfo(transactions)</code>: get the transaction info data.frame
</p>
</li>
<li> <p><code>transactionInfo(transactions) &lt;- value</code>: replace the transaction info data.frame
</p>
</li>
<li> <p><code>dimnames(transactions)</code>: get the dimnames
</p>
</li>
<li> <p><code>dimnames(x = transactions) &lt;- value</code>: set the dimnames
</p>
</li></ul>


<h3>Slots</h3>

<p>Slots are inherited from <a href="#topic+itemMatrix">itemMatrix</a>.
</p>


<h3>Objects from the Class</h3>

<p>Objects are created by:
</p>

<ul>
<li><p> coercion from objects of other classes. <code>itemLabels</code> and <code>transactionInfo</code> are
by default created from information in <code>x</code> (e.g., from row and column names).
</p>
</li>
<li><p> the constructor function <code>transactions()</code>
</p>
</li>
<li><p> by calling <code>new("transactions", ...)</code>.
</p>
</li></ul>

<p>See Examples Section for creating transactions from data.
</p>


<h3>Coercions</h3>


<ul>
<li> <p><code>as("transactions", "matrix")</code>
</p>
</li>
<li> <p><code>as("matrix", "transactions")</code>
</p>
</li>
<li> <p><code>as("list", "transactions")</code>
</p>
</li>
<li> <p><code>as("transactions", "list")</code>
</p>
</li>
<li> <p><code>as("data.frame", "transactions")</code>
</p>
</li>
<li> <p><code>as("transactions", "data.frame")</code>
</p>
</li>
<li> <p><code>as("ngCMatrix", "transactions")</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Superclass: <a href="#topic+itemMatrix">itemMatrix</a>
</p>
<p>Other itemMatrix and transactions functions: 
<code><a href="#topic+abbreviate">abbreviate</a>()</code>,
<code><a href="#topic+crossTable">crossTable</a>()</code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+duplicated">duplicated</a>()</code>,
<code><a href="#topic+extract">extract</a></code>,
<code><a href="#topic+hierarchy">hierarchy</a></code>,
<code><a href="#topic+image">image</a>()</code>,
<code><a href="#topic+inspect">inspect</a>()</code>,
<code><a href="#topic+is.superset">is.superset</a>()</code>,
<code><a href="#topic+itemFrequencyPlot">itemFrequencyPlot</a>()</code>,
<code><a href="#topic+itemFrequency">itemFrequency</a>()</code>,
<code><a href="#topic+itemMatrix-class">itemMatrix-class</a></code>,
<code><a href="#topic+match">match</a>()</code>,
<code><a href="#topic+merge">merge</a>()</code>,
<code><a href="#topic+random.transactions">random.transactions</a>()</code>,
<code><a href="#topic+sample">sample</a>()</code>,
<code><a href="#topic+sets">sets</a></code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+supportingTransactions">supportingTransactions</a>()</code>,
<code><a href="#topic+tidLists-class">tidLists-class</a></code>,
<code><a href="#topic+unique">unique</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example 1: creating transactions form a list (each element is a transaction)
a_list &lt;- list(
      c("a","b","c"),
      c("a","b"),
      c("a","b","d"),
      c("c","e"),
      c("a","b","d","e")
      )

## Set transaction names
names(a_list) &lt;- paste("Tr", c(1:5), sep = "")
a_list

## Use the constructor to create transactions
## Note: S4 coercion does the same trans1 &lt;- as(a_list, "transactions")
trans1 &lt;- transactions(a_list)
trans1

## Analyze the transactions
summary(trans1)
image(trans1)

## Example 2: creating transactions from a 0-1 matrix with 5 transactions (rows) and
##            5 items (columns)
a_matrix &lt;- matrix(
  c(1, 1, 1, 0, 0,
	   1, 1, 0, 0, 0,
	   1, 1, 0, 1, 0,
	   0, 0, 1, 0, 1,
	   1, 1, 0, 1, 1), ncol = 5)

## Set item names (columns) and transaction labels (rows)
colnames(a_matrix) &lt;- c("a", "b", "c", "d", "e")
rownames(a_matrix) &lt;- paste("Tr", c(1:5), sep = "")

a_matrix

## Create transactions
trans2 &lt;- transactions(a_matrix)
trans2
inspect(trans2)

## Example 3: creating transactions from data.frame (wide format)
a_df &lt;- data.frame(
	age   = as.factor(c( 6,   8,   NA, 9,   16)),
	grade = as.factor(c("A", "C", "F", NA, "C")),
  pass  = c(TRUE, TRUE, FALSE, TRUE, TRUE))
## Note: factors are translated differently than logicals and NAs are ignored
a_df

## Create transactions
trans3 &lt;- transactions(a_df)
inspect(trans3)

## Note that coercing the transactions back to a data.frame does not recreate the
## original data.frame, but represents the transactions as sets of items
as(trans3, "data.frame")

## Example 4: creating transactions from a data.frame with
## transaction IDs and items (long format)
a_df3 &lt;- data.frame(
  TID =  c( 1,   1,   2,   2,   2,   3 ),
  item = c("a", "b", "a", "b", "c", "b")
)
a_df3
trans4 &lt;- transactions(a_df3, format = "long", cols = c("TID", "item"))
trans4
inspect(trans4)

## convert transactions back into long format.
toLongFormat(trans4)

## Example 5: create transactions from a dataset with numeric variables
## using discretization.
data(iris)

irisDisc &lt;- discretizeDF(iris)
head(irisDisc)

trans5 &lt;- transactions(irisDisc)
trans5
inspect(head(trans5))

## Note, creating transactions without discretizing numeric variables will apply the
## default discretization and also create a warning.


## Example 6: create transactions manually (with the same item coding as in trans5)
trans6 &lt;- transactions(
  list(
    c("Sepal.Length=[4.3,5.4)", "Species=setosa"),
    c("Sepal.Length=[4.3,5.4)", "Species=setosa")
  ), itemLabels = trans5)
trans6

inspect(trans6)
</code></pre>

<hr>
<h2 id='unique'>Remove Duplicated Elements from a Collection</h2><span id='topic+unique'></span><span id='topic+unique+2CitemMatrix-method'></span><span id='topic+unique+2Cassociations-method'></span>

<h3>Description</h3>

<p>Provides the generic function <code>unique()</code> and the methods for
<a href="#topic+itemMatrix">itemMatrix</a> <a href="#topic+transactions">transactions</a>, and <a href="#topic+associations">associations</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unique(x, incomparables = FALSE, ...)

## S4 method for signature 'itemMatrix'
unique(x, incomparables = FALSE)

## S4 method for signature 'associations'
unique(x, incomparables = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unique_+3A_x">x</code></td>
<td>
<p>an object of class <a href="#topic+itemMatrix">itemMatrix</a> or <a href="#topic+associations">associations</a>.</p>
</td></tr>
<tr><td><code id="unique_+3A_incomparables">incomparables</code></td>
<td>
<p>currently unused.</p>
</td></tr>
<tr><td><code id="unique_+3A_...">...</code></td>
<td>
<p>further arguments (currently unused).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>unique()</code> uses <code><a href="#topic+duplicated">duplicated()</a></code> to return an
object with the duplicate elements removed.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>x</code> with duplicated elements
removed.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other associations functions: 
<code><a href="#topic+abbreviate">abbreviate</a>()</code>,
<code><a href="#topic+associations-class">associations-class</a></code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+duplicated">duplicated</a>()</code>,
<code><a href="#topic+extract">extract</a></code>,
<code><a href="#topic+inspect">inspect</a>()</code>,
<code><a href="#topic+is.closed">is.closed</a>()</code>,
<code><a href="#topic+is.generator">is.generator</a>()</code>,
<code><a href="#topic+is.maximal">is.maximal</a>()</code>,
<code><a href="#topic+is.redundant">is.redundant</a>()</code>,
<code><a href="#topic+is.significant">is.significant</a>()</code>,
<code><a href="#topic+is.superset">is.superset</a>()</code>,
<code><a href="#topic+itemsets-class">itemsets-class</a></code>,
<code><a href="#topic+match">match</a>()</code>,
<code><a href="#topic+rules-class">rules-class</a></code>,
<code><a href="#topic+sample">sample</a>()</code>,
<code><a href="#topic+sets">sets</a></code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+sort">sort</a>()</code>
</p>
<p>Other itemMatrix and transactions functions: 
<code><a href="#topic+abbreviate">abbreviate</a>()</code>,
<code><a href="#topic+crossTable">crossTable</a>()</code>,
<code><a href="#topic+c">c</a>()</code>,
<code><a href="#topic+duplicated">duplicated</a>()</code>,
<code><a href="#topic+extract">extract</a></code>,
<code><a href="#topic+hierarchy">hierarchy</a></code>,
<code><a href="#topic+image">image</a>()</code>,
<code><a href="#topic+inspect">inspect</a>()</code>,
<code><a href="#topic+is.superset">is.superset</a>()</code>,
<code><a href="#topic+itemFrequencyPlot">itemFrequencyPlot</a>()</code>,
<code><a href="#topic+itemFrequency">itemFrequency</a>()</code>,
<code><a href="#topic+itemMatrix-class">itemMatrix-class</a></code>,
<code><a href="#topic+match">match</a>()</code>,
<code><a href="#topic+merge">merge</a>()</code>,
<code><a href="#topic+random.transactions">random.transactions</a>()</code>,
<code><a href="#topic+sample">sample</a>()</code>,
<code><a href="#topic+sets">sets</a></code>,
<code><a href="#topic+size">size</a>()</code>,
<code><a href="#topic+supportingTransactions">supportingTransactions</a>()</code>,
<code><a href="#topic+tidLists-class">tidLists-class</a></code>,
<code><a href="#topic+transactions-class">transactions-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Adult")

r1 &lt;- apriori(Adult[1:1000], parameter = list(support = 0.5))
r2 &lt;- apriori(Adult[1001:2000], parameter = list(support = 0.5))

## Note that this produces a collection of rules from two sets
r_comb &lt;- c(r1, r2)
r_comb &lt;- unique(r_comb)
r_comb
</code></pre>

<hr>
<h2 id='weclat'>Mining Associations from Weighted Transaction Data with Eclat (WARM)</h2><span id='topic+weclat'></span><span id='topic+WARM'></span><span id='topic+warm'></span><span id='topic+WECLAT'></span>

<h3>Description</h3>

<p>Find frequent <a href="#topic+itemsets">itemsets</a> with the Eclat algorithm. This implementation uses
optimized transaction ID list joins and transaction weights to implement weighted
association rule mining (WARM).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weclat(data, parameter = NULL, control = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weclat_+3A_data">data</code></td>
<td>
<p>an object that can be coerced into an object of class
<a href="#topic+transactions">transactions</a>.</p>
</td></tr>
<tr><td><code id="weclat_+3A_parameter">parameter</code></td>
<td>
<p>an object of class <a href="#topic+ASparameter">ASparameter</a> (default
values: <code>support = 0.1</code>, <code>minlen = 1L</code>, and <code>maxlen = 5L</code>) or
a named list with corresponding components.</p>
</td></tr>
<tr><td><code id="weclat_+3A_control">control</code></td>
<td>
<p>an object of class <a href="#topic+AScontrol">AScontrol</a> (default values:
<code>verbose = TRUE</code>) or a named list with corresponding components.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Transaction weights are stored in the <a href="#topic+transactions">transactions</a> as a column called
<code>weight</code> in <a href="#topic+transactionInfo">transactionInfo</a>.
</p>
<p>The weighted support of an itemset is the sum of the weights of the
transactions that contain the itemset. An itemset is frequent if its
weighted support is equal or greater than the threshold specified by
<code>support</code> (assuming that the weights sum to one).
</p>
<p>Note that Eclat only mines (weighted) frequent itemsets. Weighted
association rules can be created using <code><a href="#topic+ruleInduction">ruleInduction()</a></code>.
</p>


<h3>Value</h3>

<p>Returns an object of class <a href="#topic+itemsets">itemsets</a>. Note that
weighted support is returned in <a href="#topic+quality">quality</a> as column <code>support</code>.
</p>


<h3>Note</h3>

<p>The C code can be interrupted by <code>CTRL-C</code>. This is convenient but comes
at the price that the code cannot clean up its internal memory.
</p>


<h3>Author(s)</h3>

<p>Christian Buchta
</p>


<h3>References</h3>

<p>G.D. Ramkumar, S. Ranka, and S. Tsur (1998).  Weighted
Association Rules: Model and Algorithm, <em>Proceedings of ACM SIGKDD.</em>
</p>


<h3>See Also</h3>

<p>Other mining algorithms: 
<code><a href="#topic+APappearance-class">APappearance-class</a></code>,
<code><a href="#topic+AScontrol-classes">AScontrol-classes</a></code>,
<code><a href="#topic+ASparameter-classes">ASparameter-classes</a></code>,
<code><a href="#topic+apriori">apriori</a>()</code>,
<code><a href="#topic+eclat">eclat</a>()</code>,
<code><a href="#topic+fim4r">fim4r</a>()</code>,
<code><a href="#topic+ruleInduction">ruleInduction</a>()</code>
</p>
<p>Other weighted association mining functions: 
<code><a href="#topic+SunBai">SunBai</a></code>,
<code><a href="#topic+hits">hits</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example 1: SunBai data
data(SunBai)
SunBai

## weights are stored in transactionInfo
transactionInfo(SunBai)

## mine weighted support itemsets using transaction support in SunBai
s &lt;- weclat(SunBai, parameter = list(support = 0.3),
		       control = list(verbose = TRUE))
inspect(sort(s))

## create rules using weighted support (satisfying a minimum
## weighted confidence of 90%).
r &lt;- ruleInduction(s, confidence = .9)
inspect(r)

## Example 2: Find association rules in weighted data
trans &lt;-  list(
    c("A", "B", "C", "D", "E"),
    c("C", "F", "G"),
    c("A", "B"),
    c("A"),
    c("C", "F", "G", "H"),
    c("A", "G", "H")
)

weight &lt;- c(5, 10, 6, 7, 5, 1)

## convert list to transactions
trans &lt;-  transactions(trans)

## add weight information
transactionInfo(trans) &lt;- data.frame(weight = weight)
inspect(trans)

## mine weighed support itemsets
s &lt;- weclat(trans, parameter = list(support = 0.3),
		       control = list(verbose = TRUE))
inspect(sort(s))

## create association rules
r &lt;- ruleInduction(s, confidence = .5)
inspect(r)
</code></pre>

<hr>
<h2 id='write'>Write Transactions or Associations to a File</h2><span id='topic+write'></span><span id='topic+write.csv'></span><span id='topic+write+2Ctransactions-method'></span><span id='topic+write+2Cassociations-method'></span>

<h3>Description</h3>

<p>Provides the generic function <code>write()</code> and the methods to write
<a href="#topic+transactions">transactions</a> or <a href="#topic+associations">associations</a> to a file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write(x, file = "", ...)

## S4 method for signature 'transactions'
write(
  x,
  file = "",
  format = c("basket", "single"),
  sep = " ",
  quote = TRUE,
  ...
)

## S4 method for signature 'associations'
write(x, file = "", sep = " ", quote = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_+3A_x">x</code></td>
<td>
<p>the <a href="#topic+transactions">transactions</a> or <a href="#topic+associations">associations</a> (<a href="#topic+rules">rules</a>, <a href="#topic+itemsets">itemsets</a>, etc.) object.</p>
</td></tr>
<tr><td><code id="write_+3A_file">file</code></td>
<td>
<p>either a character string naming a file or a connection open for
writing.  '&quot;&quot;' indicates output to the console.</p>
</td></tr>
<tr><td><code id="write_+3A_...">...</code></td>
<td>
<p>further arguments passed on to <code><a href="utils.html#topic+write.table">write.table()</a></code>.
Use <code>fileEncoding</code> to set the encoding used for
writing the file.</p>
</td></tr>
<tr><td><code id="write_+3A_format">format</code></td>
<td>
<p>format to write transactions.</p>
</td></tr>
<tr><td><code id="write_+3A_sep">sep</code></td>
<td>
<p>the field separator string. Values within each row of x are
separated by this string. Use <code>quote = TRUE</code> and <code>sep = ","</code> for
saving data as in csv format.</p>
</td></tr>
<tr><td><code id="write_+3A_quote">quote</code></td>
<td>
<p>a logical value. Quote fields?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For associations (<a href="#topic+rules">rules</a> and <a href="#topic+itemsets">itemsets</a>) <code>write()</code> first uses coercion to
data.frame to obtain a printable form of <code>x</code> and then uses
<code><a href="utils.html#topic+write.table">utils::write.table()</a></code> to write the data to disk. This is just a method to
export the rules in human-readable form. These exported associations cannot be
read back in as rules. To save and load associations in compact form, use <code><a href="base.html#topic+save">save()</a></code> and
<code><a href="base.html#topic+load">load()</a></code> from the <span class="pkg">base</span> package.  Alternatively, association can be
written to disk in PMML (Predictive Model Markup Language) via
<code><a href="#topic+write.PMML">write.PMML()</a></code>. This requires package <span class="pkg">pmml</span>.
</p>
<p>Transactions can be saved in <em>basket</em> (one line per transaction) or in <em>single</em>
(one line per item) format.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler
</p>


<h3>See Also</h3>

<p>Other import/export: 
<code><a href="#topic+DATAFRAME">DATAFRAME</a>()</code>,
<code><a href="#topic+LIST">LIST</a>()</code>,
<code><a href="#topic+pmml">pmml</a></code>,
<code><a href="#topic+read">read</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Epub")

## write the formated transactions to screen (basket format)
write(head(Epub))

## write the formated transactions to screen (single format)
write(head(Epub), format="single")

## write the formated result to file in CSV format
write(Epub, file = "data.csv", format = "single", sep = ",")

## write rules in CSV format
rules &lt;- apriori(Epub, parameter=list(support = 0.0005, conf = 0.8))
write(rules, file = "data.csv", sep = ",")

unlink("data.csv") # tidy up
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
