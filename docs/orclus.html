<!DOCTYPE html><html lang="en"><head><title>Help for package orclus</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {orclus}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#orclass'><p>Subspace clustering based local classification using ORCLUS.</p></a></li>
<li><a href='#orclus'><p>Arbitrarily ORiented projected CLUSter generation</p></a></li>
<li><a href='#predict.orclass'><p>Subspace clustering based local classification using ORCLUS.</p></a></li>
<li><a href='#predict.orclus'><p>Arbitrarily ORiented projected CLUSter generation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.2-6</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-03-17</td>
</tr>
<tr>
<td>Title:</td>
<td>Subspace Clustering Based on Arbitrarily Oriented Projected
Cluster Generation</td>
</tr>
<tr>
<td>Author:</td>
<td>Gero Szepannek</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gero Szepannek &lt;gero.szepannek@web.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to perform subspace clustering and classification. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-03-17 16:22:58 UTC; szepannek</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-03-17 22:55:34 UTC</td>
</tr>
</table>
<hr>
<h2 id='orclass'>Subspace clustering based local classification using ORCLUS.</h2><span id='topic+orclass'></span><span id='topic+orclass.default'></span><span id='topic+orclass.formula'></span><span id='topic+print.orclass'></span>

<h3>Description</h3>

<p>Function to perform local classification where the subclasses are concentrated in different subspaces of the data.</p>


<h3>Usage</h3>

<pre><code class='language-R'>orclass(x, ...)
## Default S3 method:
orclass(x, grouping, k, l, k0, a = 0.5, prior = NULL, inner.loops = 1, 
                          predict.train = "nearest", verbose = TRUE, ...)
## S3 method for class 'formula'
orclass(formula, data = NULL, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orclass_+3A_x">x</code></td>
<td>
<p>A matrix or data frame containing the explanatory variables. The method is restricted to numerical data.</p>
</td></tr>
<tr><td><code id="orclass_+3A_grouping">grouping</code></td>
<td>
<p>A factor specifying the class for each observation.</p>
</td></tr>
<tr><td><code id="orclass_+3A_formula">formula</code></td>
<td>
<p>A formula of the form <code>grouping ~ x1 + x2 + ...</code> That is, the response is the grouping factor and the right hand side specifies the (non-factor) discriminators.</p>
</td></tr>
<tr><td><code id="orclass_+3A_data">data</code></td>
<td>
<p>Data frame from which variables specified in formula are to be taken.</p>
</td></tr>  <tr><td><code id="orclass_+3A_k">k</code></td>
<td>
<p>Prespecifies the final number of clusters.</p>
</td></tr>  
<tr><td><code id="orclass_+3A_l">l</code></td>
<td>
<p>Prespecifies the dimension of the final cluster-specific subspaces (equal for all clusters).</p>
</td></tr>
<tr><td><code id="orclass_+3A_k0">k0</code></td>
<td>
<p>Initial number of clusters (that are computed in the entire data space). Must be greater than <code>k</code>. 
The number of clusters is iteratively decreased by factor <code>a</code> until the final number of <code>k</code> clusters is reached.</p>
</td></tr>  
<tr><td><code id="orclass_+3A_a">a</code></td>
<td>
<p>Prespecified factor for the cluster number reduction in each iteration step of the algorithm.</p>
</td></tr>
<tr><td><code id="orclass_+3A_prior">prior</code></td>
<td>
<p>Argument for optional specification of class prior probabilities if different from the relative class frequencies.</p>
</td></tr>
<tr><td><code id="orclass_+3A_inner.loops">inner.loops</code></td>
<td>
<p>Number of repetitive iterations (i.e. recomputation of clustering and cluster-specific subspaces) 
while the number of clusters and the subspace dimension are kept constant.</p>
</td></tr>  
<tr><td><code id="orclass_+3A_predict.train">predict.train</code></td>
<td>
<p>Character pecifying whether prediction of training data should be pursued. If <code>"nearest"</code> the class distribution in <code>orclus</code> cluster assignment is used for classification.</p>
</td></tr>           
<tr><td><code id="orclass_+3A_verbose">verbose</code></td>
<td>
<p>Logical indicating whether the iteration process sould be displayed.</p>
</td></tr>
<tr><td><code id="orclass_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each cluster the class distribution is computed.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>orclass</code>.  
</p>
<table role = "presentation">
<tr><td><code>orclus.res</code></td>
<td>
<p>Object of class <code>orclus</code> containing the resulting clusters.</p>
</td></tr>
<tr><td><code>cluster.posteriors</code></td>
<td>
<p>Matrix of clusterwise class posterior probabilities where clusters are rows and classes are coloumns.</p>
</td></tr>
<tr><td><code>cluster.priors</code></td>
<td>
<p>Vector of relative cluster frequencies weighted by class priors.</p>
</td></tr>
<tr><td><code>purity</code></td>
<td>
<p>Statistics indicating the discriminability of the identified clusters.</p>
</td></tr>
<tr><td><code>prior</code></td>
<td>
<p>Vector of class prior probabilities.</p>
</td></tr>
<tr><td><code>predict.train</code></td>
<td>
<p>Prediction of training data if specified.</p>
</td></tr>
<tr><td><code>orclass.call</code></td>
<td>
<p>(Matched) function call.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gero Szepannek</p>


<h3>References</h3>

<p>Aggarwal, C. and Yu, P. (2000): <em>Finding generalized projected clusters in high dimensional spaces</em>, 
Proceedings of ACM SIGMOD International Conference on Management of Data, pp. 70-81.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.orclass">predict.orclass</a></code>, <code><a href="#topic+orclus">orclus</a></code>, <code><a href="#topic+predict.orclus">predict.orclus</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># definition of a function for parameterized data simulation
sim.orclus &lt;- function(k = 3, nk = 100, d = 10, l = 4, 
                       sd.cl = 0.05, sd.rest = 1, locshift = 1){
  ### input parameters for data generation
  # k           number of clusters
  # nk          observations per cluster
  # d           original dimension of the data
  # l           subspace dimension where the clusters are concentrated
  # sd.cl       (within cluster subspace) standard deviations for data generation 
  # sd.rest     standard deviations in the remaining space 
  # locshift    parameter of a uniform distribution to sample different cluster means  

  x &lt;- NULL
  for(i in 1:k){
  # cluster centers
  apts &lt;- locshift*matrix(runif(l*k), ncol = l)  
  # sample points in original space
  xi.original &lt;- cbind(matrix(rnorm(nk * l, sd = sd.cl), ncol=l) + matrix(rep(apts[i,], nk), 
                              ncol = l, byrow = TRUE),
                       matrix(rnorm(nk * (d-l), sd = sd.rest), ncol = (d-l)))  
  # subspace generation
  sym.mat &lt;- matrix(nrow=d, ncol=d)
  for(m in 1:d){
    for(n in 1:m){
      sym.mat[m,n] &lt;- sym.mat[n,m] &lt;- runif(1)  
      }
    } 
  subspace &lt;- eigen(sym.mat)$vectors    
  # transformation
  xi.transformed &lt;- xi.original %*% subspace
  x &lt;- rbind(x, xi.transformed)
  }  
  clids &lt;- rep(1:k, each = nk)
  result &lt;- list(x = x, cluster = clids)
  return(result)
  }

# simulate data of 2 classes where class 1 consists of 2 subclasses
simdata &lt;- sim.orclus(k = 3, nk = 200, d = 15, l = 4, 
                      sd.cl = 0.05, sd.rest = 1, locshift = 1)

x &lt;- simdata$x
y &lt;- c(rep(1,400), rep(2,200))

res &lt;- orclass(x, y, k = 3, l = 4, k0 = 15, a = 0.75)
res

# compare results
table(res$predict.train$class, y)
</code></pre>

<hr>
<h2 id='orclus'>Arbitrarily ORiented projected CLUSter generation</h2><span id='topic+orclus'></span><span id='topic+orclus.default'></span><span id='topic+print.orclus'></span>

<h3>Description</h3>

<p>Function to perform subspace clustering where the clusters are concentrated in different cluster specific subspaces of the data.</p>


<h3>Usage</h3>

<pre><code class='language-R'>orclus(x, ...)
## Default S3 method:
orclus(x, k, l, k0, a = 0.5, inner.loops = 1, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orclus_+3A_x">x</code></td>
<td>
<p>A matrix or data frame containing the explanatory variables. The method is restricted to numerical data.</p>
</td></tr>
<tr><td><code id="orclus_+3A_k">k</code></td>
<td>
<p>Prespecifies the final number of clusters.</p>
</td></tr>  
<tr><td><code id="orclus_+3A_l">l</code></td>
<td>
<p>Prespecifies the dimension of the final cluster-specific subspaces (equal for all clusters).</p>
</td></tr>
<tr><td><code id="orclus_+3A_k0">k0</code></td>
<td>
<p>Initial number of clusters (that are computed in the entire data space). Must be greater than <code>k</code>. 
The number of clusters is iteratively decreased by factor <code>a</code> until the final number of <code>k</code> clusters is reached.</p>
</td></tr>  
<tr><td><code id="orclus_+3A_a">a</code></td>
<td>
<p>Prespecified factor for the cluster number reduction in each iteration step of the algorithm.</p>
</td></tr>  
<tr><td><code id="orclus_+3A_inner.loops">inner.loops</code></td>
<td>
<p>Number of repetitive iterations (i.e. recomputation of clustering and cluster-specific subspaces) 
while the number of clusters and the subspace dimension are kept constant.</p>
</td></tr>  
<tr><td><code id="orclus_+3A_verbose">verbose</code></td>
<td>
<p>Logical indicating whether the iteration process sould be displayed.</p>
</td></tr>
<tr><td><code id="orclus_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function performs ORCLUS subspace clustering (Aggarwal and Yu, 2000). 
Simultaneously both cluster assignments as well as cluster specific subspaces are computed.
Cluster assignments have minimal euclidean distance from the cluster centers in the corresponding subspaces. 
As an extension to the originally proposed algorithm initialization in the full data space is done by calling <code><a href="stats.html#topic+kmeans">kmeans</a></code> 
for <code>k0</code> clusters. Further, by <code>inner.loops</code> a number of repetitions during the iteration process 
for each number of clusters and subspace dimension can be specified. An outlier option has not been implemented.  
Even though increasing the initialzation parameter <code>k0</code> most strongly effects the computation time 
it should be chosen as large as possible (at least several times greater then <code>k</code>).
</p>


<h3>Value</h3>

<p>Returns an object of class <code>orclus</code>. Its structure is similar to objects resulting from calling <code><a href="stats.html#topic+kmeans">kmeans</a></code>. 
</p>
<table role = "presentation">
<tr><td><code>cluster</code></td>
<td>
<p>Returns the final cluster labels.</p>
</td></tr>
<tr><td><code>centers</code></td>
<td>
<p>A matrix where each row corresponds to a cluster center (in the original space).</p>
</td></tr>
<tr><td><code>size</code></td>
<td>
<p>The final number of observations in each cluster.</p>
</td></tr>
<tr><td><code>subspaces</code></td>
<td>
<p>List of matrices for projection of the data onto the cluster-specific supspaces by post-multiplication.</p>
</td></tr>
<tr><td><code>subspace.dimension</code></td>
<td>
<p>Dimension of the final subspaces.</p>
</td></tr>
<tr><td><code>within.projenss</code></td>
<td>
<p>Corresponds to <code>withinss</code> of <code>kmeans</code> objects: projected within cluster energies for each cluster.</p>
</td></tr>
<tr><td><code>sparsity.coefficient</code></td>
<td>
<p>Sparsity coefficient of the clustering result. 
If its value is close to 1 the subspace dimension may have been chosen too large. 
A small value close to 0 can be interpreted as a hint that a strong cluster structure has been found.</p>
</td></tr>
<tr><td><code>orclus.call</code></td>
<td>
<p>(Matched) function call.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gero Szepannek</p>


<h3>References</h3>

<p>Aggarwal, C. and Yu, P. (2000): <em>Finding generalized projected clusters in high dimensional spaces</em>, 
Proceedings of ACM SIGMOD International Conference on Management of Data, pp. 70-81.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.orclus">predict.orclus</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># generate simple artificial example of two clusters
clus1.v1 &lt;- runif(100)
clus2.v1 &lt;- runif(100) 
xample &lt;- rbind(cbind(clus1.v1, 0.5 - clus1.v1), cbind(clus2.v1, -0.5 + clus2.v1))
plot(xample, col=rep(1:2, each=100))

# try standard kmeans clustering
kmeans.res &lt;- kmeans(xample, 2)
plot(xample, col = kmeans.res$cluster)

# use orclus instead 
orclus.res &lt;- orclus(x = xample, k = 2, l = 1, k0 = 8, a = 0.5)
plot(xample, col = orclus.res$cluster)

# show data in cluster-specific subspaces
par(mfrow=c(1,2))
for(i in 1:length(orclus.res$size)) plot(xample %*% orclus.res$subspaces[[i]], 
    col = orclus.res$cluster, ylab = paste("Identified subspace for cluster",i))


### second 'more multivariate' example to play with...

# definition of a function for parameterized data simulation
sim.orclus &lt;- function(k = 3, nk = 100, d = 10, l = 4, 
                       sd.cl = 0.05, sd.rest = 1, locshift = 1){
  ### input parameters for data generation
  # k           number of clusters
  # nk          observations per cluster
  # d           original dimension of the data
  # l           subspace dimension where the clusters are concentrated
  # sd.cl       (within cluster subspace) standard deviations for data generation 
  # sd.rest     standard deviations in the remaining space 
  # locshift    parameter of a uniform distribution to sample different cluster means  

  x &lt;- NULL
  for(i in 1:k){
  # cluster centers
  apts &lt;- locshift*matrix(runif(l*k), ncol = l)  
  # sample points in original space
  xi.original &lt;- cbind(matrix(rnorm(nk * l, sd = sd.cl), ncol=l) + matrix(rep(apts[i,], nk), 
                              ncol = l, byrow = TRUE),
                       matrix(rnorm(nk * (d-l), sd = sd.rest), ncol = (d-l)))  
  # subspace generation
  sym.mat &lt;- matrix(nrow=d, ncol=d)
  for(m in 1:d){
    for(n in 1:m){
      sym.mat[m,n] &lt;- sym.mat[n,m] &lt;- runif(1)  
      }
    } 
  subspace &lt;- eigen(sym.mat)$vectors    
  # transformation
  xi.transformed &lt;- xi.original %*% subspace
  x &lt;- rbind(x, xi.transformed)
  }  
  clids &lt;- rep(1:k, each = nk)
  result &lt;- list(x = x, cluster = clids)
  return(result)
  }

# simulate data, you can play with different parameterizations...
simdata &lt;- sim.orclus(k = 3, nk = 200, d = 15, l = 4, 
                      sd.cl = 0.05, sd.rest = 1, locshift = 1)

# apply kmeans and orclus
kmeans.res2 &lt;- kmeans(simdata$x, 3)
orclus.res2 &lt;- orclus(x = simdata$x, k = 3, l = 4, k0 = 15, a = 0.75)
cat("SC: ", orclus.res2$sparsity.coefficient, "\n")

# compare results
table(kmeans.res2$cluster, simdata$cluster)
table(orclus.res2$cluster, simdata$cluster)
</code></pre>

<hr>
<h2 id='predict.orclass'>Subspace clustering based local classification using ORCLUS.</h2><span id='topic+predict.orclass'></span>

<h3>Description</h3>

<p>Assigns clusters and distances and classes for new data according to the intrinsic subspace clusters of an <code><a href="#topic+orclass">orclass</a></code> classification model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'orclass'
predict(object, newdata, type = "nearest", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.orclass_+3A_object">object</code></td>
<td>
<p>Model resulting from a call of <code><a href="#topic+orclass">orclass</a></code>.</p>
</td></tr>
<tr><td><code id="predict.orclass_+3A_newdata">newdata</code></td>
<td>
<p>A matrix or data frame to be clustered by the given model.</p>
</td></tr>
<tr><td><code id="predict.orclass_+3A_type">type</code></td>
<td>
<p>Default <code>"nearest"</code> computes relative class frequencies of nearest cluster as class posterior probabilities.</p>
</td></tr>
<tr><td><code id="predict.orclass_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>        
</table>


<h3>Details</h3>

<p>For prediction the class distribution of the <code>"nearest"</code>&quot; cluster is used.
If <code>type = "fuzzywts"</code> cluster memberships (see e.g. Bezdek, 1981) are computed based on the cluster distances of cluster assignment by  <code><a href="#topic+predict.orclus">predict.orclus</a></code>. For orclass prediction the class distributions of the clusters are weigthed using the cluster memberships of an observation.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>class</code></td>
<td>
<p>Vector of predicted class levels.</p>
</td></tr>
<tr><td><code>posterior</code></td>
<td>
<p>Matrix where coloumns contain class posterior probabilities.</p>
</td></tr>
<tr><td><code>distances</code></td>
<td>
<p>A matrix where coloumns are the distances to all cluster centers in the corresponding subspaces for the new data.</p>
</td></tr>
<tr><td><code>cluster</code></td>
<td>
<p>The resulting cluster labels for the new data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gero Szepannek</p>


<h3>References</h3>

<p>Aggarwal, C. and Yu, P. (2000): <em>Finding generalized projected clusters in high dimensional spaces</em>, 
Proceedings of ACM SIGMOD International Conference on Management of Data, pp. 70-81.
</p>
<p>Bezdek, J. (1981): <em>Pattern recognition with fuzzy objective function algorithms</em>, Kluwer Academic, Norwell, MA. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+orclass">orclass</a></code>, <code><a href="#topic+orclus">orclus</a></code>, <code><a href="#topic+predict.orclus">predict.orclus</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># definition of a function for parameterized data simulation
sim.orclus &lt;- function(k = 3, nk = 100, d = 10, l = 4, 
                       sd.cl = 0.05, sd.rest = 1, locshift = 1){
  ### input parameters for data generation
  # k           number of clusters
  # nk          observations per cluster
  # d           original dimension of the data
  # l           subspace dimension where the clusters are concentrated
  # sd.cl       (within cluster subspace) standard deviations for data generation 
  # sd.rest     standard deviations in the remaining space 
  # locshift    parameter of a uniform distribution to sample different cluster means  

  x &lt;- NULL
  for(i in 1:k){
  # cluster centers
  apts &lt;- locshift*matrix(runif(l*k), ncol = l)  
  # sample points in original space
  xi.original &lt;- cbind(matrix(rnorm(nk * l, sd = sd.cl), ncol=l) + matrix(rep(apts[i,], nk), 
                              ncol = l, byrow = TRUE),
                       matrix(rnorm(nk * (d-l), sd = sd.rest), ncol = (d-l)))  
  # subspace generation
  sym.mat &lt;- matrix(nrow=d, ncol=d)
  for(m in 1:d){
    for(n in 1:m){
      sym.mat[m,n] &lt;- sym.mat[n,m] &lt;- runif(1)  
      }
    } 
  subspace &lt;- eigen(sym.mat)$vectors    
  # transformation
  xi.transformed &lt;- xi.original %*% subspace
  x &lt;- rbind(x, xi.transformed)
  }  
  clids &lt;- rep(1:k, each = nk)
  result &lt;- list(x = x, cluster = clids)
  return(result)
  }

# simulate data of 2 classes where class 1 consists of 2 subclasses
simdata &lt;- sim.orclus(k = 3, nk = 200, d = 15, l = 4, 
                      sd.cl = 0.05, sd.rest = 1, locshift = 1)

x &lt;- simdata$x
y &lt;- c(rep(1,400), rep(2,200))

res &lt;- orclass(x, y, k = 3, l = 4, k0 = 15, a = 0.75)
prediction &lt;- predict(res, x)

# compare results
table(prediction$class, y)

</code></pre>

<hr>
<h2 id='predict.orclus'>Arbitrarily ORiented projected CLUSter generation</h2><span id='topic+predict.orclus'></span>

<h3>Description</h3>

<p>Assigns clusters and distances to cluster centers in the corresponding subspaces for new data according to a subspace clustering model of class <code><a href="#topic+orclus">orclus</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'orclus'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.orclus_+3A_object">object</code></td>
<td>
<p>Model resulting from a call of <code><a href="#topic+orclus">orclus</a></code>.</p>
</td></tr>
<tr><td><code id="predict.orclus_+3A_newdata">newdata</code></td>
<td>
<p>A matrix or data frame to be clustered by the given model.</p>
</td></tr>
<tr><td><code id="predict.orclus_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>        
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>distances</code></td>
<td>
<p>A matrix where coloumns are the distances to all cluster centers in the corresponding subspaces for the new data.</p>
</td></tr>
<tr><td><code>cluster</code></td>
<td>
<p>The resulting cluster labels for the new data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gero Szepannek</p>


<h3>References</h3>

<p>Aggarwal, C. and Yu, P. (2000): <em>Finding generalized projected clusters in high dimensional spaces</em>, 
Proceedings of ACM SIGMOD International Conference on Management of Data, pp. 70-81.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+orclus">orclus</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># generate simple artificial example of two clusters
clus1.v1 &lt;- runif(100)
clus2.v1 &lt;- runif(100) 
xample &lt;- rbind(cbind(clus1.v1, 0.5 - clus1.v1), cbind(clus2.v1, -0.5 + clus2.v1))

orclus.res &lt;- orclus(x = xample, k = 2, l = 1, k0 = 8, a = 0.5)

# generate new data and predict it using the 
newclus1.v1 &lt;- runif(100)
newclus2.v1 &lt;- runif(100) 
true.clusterids  &lt;- rep(1:2, each = 100)
xample2 &lt;- rbind(cbind(newclus1.v1, 0.5 - newclus1.v1), 
                 cbind(newclus2.v1, -0.5 + newclus2.v1))

orclus.prediction &lt;- predict(orclus.res, xample2)
table(orclus.prediction$cluster, true.clusterids)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
