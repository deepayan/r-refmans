<!DOCTYPE html><html><head><title>Help for package virtualspecies</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {virtualspecies}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#betaFun'><p>Beta response function</p></a></li>
<li><a href='#convertToPA'><p>Convert a virtual species distribution (or a suitability raster)</p>
into presence-absence</a></li>
<li><a href='#custnorm'><p>Normal function defined by extremes</p></a></li>
<li><a href='#formatFunctions'><p>Format and visualise functions used to generate virtual species with <code>generateSpFromFun</code></p></a></li>
<li><a href='#generateRandomSp'><p>Generate a random virtual species distribution from environmental variables</p></a></li>
<li><a href='#generateSpFromBCA'><p>Generate a virtual species distribution from a Between Component Analysis</p>
of environmental variables</a></li>
<li><a href='#generateSpFromFun'><p>Generate a virtual species distributions with responses to environmental</p>
variables</a></li>
<li><a href='#generateSpFromPCA'><p>Generate a virtual species distribution with a PCA of environmental variables</p></a></li>
<li><a href='#limitDistribution'><p>Limit a virtual species distribution to a defined area</p></a></li>
<li><a href='#linearFun'><p>Linear function</p></a></li>
<li><a href='#logisticFun'><p>Logistic function</p></a></li>
<li><a href='#plotResponse'><p>Visualise the response of the virtual species to environmental variables</p></a></li>
<li><a href='#plotSuitabilityToProba'><p>Visualise the function that was used to transform environmental suitability into</p>
probability of occurrence</a></li>
<li><a href='#quadraticFun'><p>Quadratic function</p></a></li>
<li><a href='#removeCollinearity'><p>Remove collinearity among variables of a raster stack</p></a></li>
<li><a href='#sampleOccurrences'><p>Sample occurrences in a virtual species distribution</p></a></li>
<li><a href='#synchroniseNA'><p>Synchronise NA values among layers of a stack</p></a></li>
<li><a href='#virtualspecies-package'><p>Generation of virtual species</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Generation of Virtual Species Distributions</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6</td>
</tr>
<tr>
<td>Author:</td>
<td>Boris Leroy [cre, aut], Christine N. Meynard [ctb], 
    Celine Bellard [ctb], Franck Courchamp [ctb], Robin Delsol [ctb], 
    Willson Gaul [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Boris Leroy &lt;leroy.boris@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a framework for generating virtual species distributions,
    a procedure increasingly used in ecology to improve species distribution
    models. This package integrates the existing methodological approaches 
    with the objective of generating virtual species distributions with 
    increased ecological realism.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2.0)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5), terra</td>
</tr>
<tr>
<td>Imports:</td>
<td>ade4, graphics, grDevices, rnaturalearth, raster, stats,
utils, viridis</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://borisleroy.com/virtualspecies/">https://borisleroy.com/virtualspecies/</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-26 19:54:33 UTC; Farewell20</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-26 20:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='betaFun'>Beta response function</h2><span id='topic+betaFun'></span>

<h3>Description</h3>

<p>Generation of a beta response curve (see references) according to the equation:
</p>
<p style="text-align: center;"><code class="reqn">k * (x - p1)^{\alpha} * (p2 - x)^{\gamma}</code>
</p>

<p>k is automatically estimated to have a maximum value of P equal to 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>betaFun(x, p1, p2, alpha, gamma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="betaFun_+3A_x">x</code></td>
<td>
<p>a numeric value or vector. The input environmental variable.</p>
</td></tr>
<tr><td><code id="betaFun_+3A_p1">p1</code></td>
<td>
<p>a numeric value or vector. Lower tolerance bound for the species</p>
</td></tr>
<tr><td><code id="betaFun_+3A_p2">p2</code></td>
<td>
<p>a a numeric value or vector. Upper tolerance bound for the species</p>
</td></tr>
<tr><td><code id="betaFun_+3A_alpha">alpha</code></td>
<td>
<p>a numeric value or vector. Parameter controlling the shape of the curve (see details)</p>
</td></tr>
<tr><td><code id="betaFun_+3A_gamma">gamma</code></td>
<td>
<p>a numeric value or vector. Parameter controlling the shape of the curve (see details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>p1 and p2 can be seen as the upper and lower critical threshold of the curve.
<code>alpha</code> and <code>gamma</code> control the shape of the curve near p1 and p2, respectively.
When <code>alpha</code> = <code>gamma</code>, the curve is symmetric. Low values of <code>alpha</code> and <code>gamma</code> 
result in smooth (&lt; 1) to plateau (&lt; 0.01) curves. Higher values result in 
peak (&gt; 10) curves. 
</p>
<p>When <code>alpha</code> &lt; <code>gamma</code>, the curve is skewed to the right.
When <code>gamma</code> &lt; <code>alpha</code>, the curve is skewed to the left.
</p>


<h3>Value</h3>

<p>a numeric value or vector resulting from the function
</p>


<h3>Author(s)</h3>

<p>Boris Leroy <a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>
</p>
<p>Maintainer: Boris Leroy <a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>
</p>


<h3>References</h3>

<p>Oksanen, J. &amp; Minchin, P.R. (2002). Continuum theory revisited: what shape 
are species responses along ecological gradients? <em>Ecological Modelling</em>
<b>157</b>:119-129.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linearFun">linearFun</a></code>, <code><a href="#topic+quadraticFun">quadraticFun</a></code>, <code><a href="#topic+custnorm">custnorm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>temp &lt;- seq(-10, 40, length = 100)
# A curve similar to a thermal performance curve
P &lt;- betaFun(x = temp, p1 = 0, p2 = 35, alpha = 0.9, gamma = 0.08)
plot(P ~ temp, type = "l")
</code></pre>

<hr>
<h2 id='convertToPA'>Convert a virtual species distribution (or a suitability raster) 
into presence-absence</h2><span id='topic+convertToPA'></span>

<h3>Description</h3>

<p>This functions converts the probabilities of presence from the output of
<code><a href="#topic+generateSpFromFun">generateSpFromFun</a></code>, <code><a href="#topic+generateSpFromPCA">generateSpFromPCA</a></code>, 
<code><a href="#topic+generateRandomSp">generateRandomSp</a></code>
or a suitability raster into
a presence-absence raster. The conversion can be threshold-based, or based
on a probability of conversion (see details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convertToPA(
  x,
  PA.method = "probability",
  prob.method = "logistic",
  beta = "random",
  alpha = -0.05,
  a = NULL,
  b = NULL,
  species.prevalence = NULL,
  plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convertToPA_+3A_x">x</code></td>
<td>
<p>the output from functions 
<code><a href="#topic+generateSpFromFun">generateSpFromFun</a></code>, <code><a href="#topic+generateSpFromPCA">generateSpFromPCA</a></code> 
or <code><a href="#topic+generateRandomSp">generateRandomSp</a></code>, or a suitability SpatRaster</p>
</td></tr>
<tr><td><code id="convertToPA_+3A_pa.method">PA.method</code></td>
<td>
<p><code>"threshold"</code> or <code>"probability"</code>. If 
<code>"threshold"</code>, then occurrence probabilities are simply converted into
presence-absence according to the threshold <code>beta</code>. If 
<code>"probability"</code>, then
probabilities are converted according to a logistic function of threshold 
<code>beta</code> and slope <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="convertToPA_+3A_prob.method">prob.method</code></td>
<td>
<p><code>"logistic"</code> or <code>"linear"</code>. Defines how 
the initial environmental suitability is translated into probabilities of 
presence/absence.</p>
</td></tr>
<tr><td><code id="convertToPA_+3A_beta">beta</code></td>
<td>
<p><code>"random"</code>, a numeric value in the range of your 
probabilities or <code>NULL</code>. This is the threshold of conversion into 
presence-absence (if <code>PA.method = "probability"</code> and 
<code>prob.method = "logistic"</code>, then beta = the inflexion point).
If <code>"random"</code>, a numeric value will be randomly generated within the range
of <code>x</code>.</p>
</td></tr>
<tr><td><code id="convertToPA_+3A_alpha">alpha</code></td>
<td>
<p><code>NULL</code> or a negative numeric value. Only useful if 
<code>PA.method = "probability"</code> and  <code>proba.method = "logistic"</code>. 
The value of <code>alpha</code> will
shape the logistic function transforming occurrences into presence-absences.
See <code><a href="#topic+logisticFun">logisticFun</a></code> and examples therein for the choice of 
<code>alpha</code></p>
</td></tr>
<tr><td><code id="convertToPA_+3A_a">a</code></td>
<td>
<p><code>NULL</code> or a  numeric value. Only useful if 
<code>PA.method = "probability"</code> and  <code>proba.method = "linear"</code>. 
Slope of the linear conversion of environmental suitability.</p>
</td></tr>
<tr><td><code id="convertToPA_+3A_b">b</code></td>
<td>
<p><code>NULL</code> or a  numeric value. Only useful if 
<code>PA.method = "probability"</code> and  <code>proba.method = "linear"</code>. 
Intercept of the linear conversion of environmental suitability.</p>
</td></tr>
<tr><td><code id="convertToPA_+3A_species.prevalence">species.prevalence</code></td>
<td>
<p><code>NULL</code> or a numeric value between 0 and 1.
The species prevalence is the proportion of sites actually occupied by the
species.</p>
</td></tr>
<tr><td><code id="convertToPA_+3A_plot">plot</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>. If <code>TRUE</code>, maps of 
probabilities
of occurrence and presence-absence will be plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><a href="http://borisleroy.com/virtualspecies_tutorial/04-presenceabsence.html">
Online tutorial for this function</a>
</p>
<p>The conversion of environmental suitability into presence - absence used to 
be
performed by selecting a threshold above which presence always occurs,
and never below. However, this approach may is unrealistic because
species may sometime be present in areas with a low probability of 
occurrence,
or be absent from areas with a high probability of occurrence. In addition,
when using a threshold you erase the previously generated response shapes: 
it all becomes threshold. Thus, this threshold approach should be avoided.
</p>
<p>A more
realistic conversion consists in converting environmental suitability into
presence -
absence with a probability function (see references). Such a probability 
conversion can be performed with two different methods here:
</p>

<ol>
<li><p>Using a logistic transformation of  environmental suitability
(see <code><a href="#topic+logisticFun">logisticFun</a></code>). A logistic function on the other hand, will 
ensure that the simulated probability is within the 0-1 range and allow easy 
control of species prevalence. However, the 
logistic function will also flatten out the relationship at the extreme 
suitability values, and narrow or broaden the intermediate probability values
depending on the slope of the logistic curve 
</p>
</li>
<li><p>Using a linear transformation of environmental suitability. A linear 
transformation will preserve the shape of the originally simulated 
occurrence-environment relationships, uniformly increasing or decreasing the
probabilities of occurrence across the landscape.</p>
</li></ol>

<p>&mdash; note &mdash;
</p>
<p>If the Virtual Species study aims at comparing simulated and predicted 
probability values, it is important to recover the correct simulated 
probability instead of directly using the initial suitability function. 
</p>
<p>Therefore, the function stores the probability of occurrence in the 
output list, under the object <code>probability.of.occurrence</code>.
The initial suitability function (before logistic or linear conversion)
will still be stored in the output list as <code>suitab.raster</code>. 
</p>
<p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;
</p>
<p><b>PROBABILISTIC CONVERSION - LOGISTIC METHOD</b>
</p>
<p>To perform the logistic transformation of environmental suitability
you have to define two of the
three following parameters:
</p>

<ul>
<li><p><code>beta</code>: the 'threshold' of the logistic function (i.e. the 
inflexion point. It should normaly be in the range of values of your 
environmental suitability.)
</p>
</li>
<li><p><code>alpha</code>: the slope of the logistic function. It should generally
be in value equal to something like 1/20 or 1/10 of your environmental 
suitability range
</p>
</li>
<li><p><code>species.prevalence</code>: the proportion of sites in which the species
occur
</p>
</li></ul>

<p>If you provide <code>beta</code> and <code>alpha</code>, the <code>species.prevalence</code>
is calculated immediately calculated after conversion into presence-absence.
</p>
<p>On the other hand, if you provide <code>species.prevalence</code> and either
<code>beta</code> or <code>alpha</code>, the function will try to determine <code>alpha</code>
(if you provided <code>beta</code>) or <code>beta</code> (if you provided <code>alpha</code>).
</p>
<p>The relationship between species prevalence, alpha and beta is dependent
on the available range of environmental conditions (see Meynard and Kaplan,
2011 and especially the Supporting Information). As a consequence, the 
desired species prevalence may not be available for the defined <code>alpha</code> 
or <code>beta</code>. In these conditions, the function will retain the 
<code>alpha</code> or
<code>beta</code> which provides the closest prevalence to your 
<code>species.prevalence</code>,
but you may also provide another value of <code>alpha</code> or <code>beta</code> to 
obtain
a closer prevalence. 
</p>
<p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;
</p>
<p><b>PROBABILISTIC CONVERSION - LINEAR METHOD </b>
</p>
<p>To perform the linear transformation of environmental suitability
you have to define *one* of the following:
</p>

<ul>
<li><p>nothing - in which case your input environmental suitability will be
used as the probability of occurrence for the Bernoulli trial (it is 
equivalent to defining a slope <code>a</code> of 1 and intercept <code>b</code> of  0.)
</p>
</li>
<li><p>the coefficients of the linear regression: slope <code>a</code> and 
intercept <code>b</code>. The transformed environmental suitability will
be used as the probability of occurrence for the Bernoulli trial.
</p>
</li>
<li><p><code>species.prevalence</code>: the proportion of sites in which the 
species occur. In this case, the function will try to find coefficients
of a linear regression which results in the requested 
<code>species.prevalence</code>
(see below).
</p>
</li></ul>
 
<p>Method used to find coefficients of a linear regression which results in the
requested <code>species.prevalence</code>:
</p>

<ol>
<li><p>The simplest linear transformation of habitat suitability would
be to just multiply the raw suitability by a constant. For example, if the 
raw average suitability in the area is 0.04, it means an expected prevalence
of 0.40. To to go from this expected prevalence of 0.04 to an expected
prevalence of 0.4, we can just multiply the raw suitability by 10. It is the
default choice, unless it results in probabilities superior to 1 or raw
suitability have values below 0, in which case the function proceeds to
method 2.
</p>
</li>
<li><p>If it does not work, then we look at the line that passes through 
(min suitability, 0) and (mean suitability, desired prevalence). For this 
line, we only need to ensure that the maximum probability of occurence is 
lower than 1. Otherwise, the function proceeds to method 3.
</p>
</li>
<li><p>If method 2 fails, then we test the line going through (mean 
suitability, desired prevalence) and (max suitability, 1). If the minimum
probability resulting from this line is greater than 0, then this method is 
correct.

</p>
</li></ol>

<p>One of these 3 lines should always work. In fact, one of the last two has to 
work, and it does not hurt to try the first one which is simpler.
</p>
<p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;
</p>
<p>In all cases, the <code>species.prevalence</code> indicated in the output is the
prevalence measured on the output presence-absence map.
</p>


<h3>Value</h3>

<p>a <code>list</code> containing 6 elements:
</p>

<ul>
<li><p><code>approach</code>: the approach used to generate the species, 
<em>i.e.</em>, <code>"response"</code>
</p>
</li>
<li><p><code>details</code>: the details and parameters used to generate the 
species
</p>
</li>
<li><p><code>suitab.raster</code>: the environmental suitability of your virtual 
species, as a Raster object 
</p>
</li>
<li><p><code>probability.of.occurrence</code>: the probability of occurrence of your 
species, based on the chosen transformation of environmental suitability,
as a Raster object 
</p>
</li>
<li><p><code>PA.conversion</code>: the parameters used to convert the suitability 
into presence-absence
</p>
</li>
<li><p><code>pa.raster</code>: the presence-absence map, as a Raster object 
containing 0 (absence) / 1 (presence) / NA
</p>
</li></ul>

<p>The structure of the virtualspecies object can be seen using <code>str()</code>
</p>


<h3>Note</h3>

<p>The approximation of <code>alpha</code> or <code>beta</code> to the chosen 
<code>species.prevalence</code> may take time if you work on very large rasters.
</p>


<h3>Author(s)</h3>

<p>Boris Leroy <a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>
</p>
<p>with help from C. N. Meynard, D.M. Kaplan, C. Bellard &amp; F. Courchamp
</p>


<h3>References</h3>

<p>Meynard C.N. &amp; Kaplan D.M. 2013. Using virtual species to study species 
distributions and model performance. 
<em>Journal of Biogeography</em> <b>40</b>:1-8
</p>
<p>Meynard C.N. &amp; Kaplan D.M. 2011. The effect of a gradual response to the 
environment on species distribution model performance.
<em>Ecography</em> <b>35</b>:499-509
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create an example stack with two environmental variables
a &lt;- matrix(rep(dnorm(1:100, 50, sd = 25)), 
            nrow = 100, ncol = 100, byrow = TRUE)
env &lt;- c(rast(a * dnorm(1:100, 50, sd = 25)),
         rast(a * 1:100))
names(env) &lt;- c("variable1", "variable2")

# Creation of the parameter list
parameters &lt;- formatFunctions(variable1 = c(fun = 'dnorm', mean = 0.00012,
                                            sd = 0.0001),
                              variable2 = c(fun = 'linearFun', a = 1, b = 0))
sp1 &lt;- generateSpFromFun(env, parameters, plot = FALSE)

# Conversion into presence-absence with a threshold-based approach
convertToPA(sp1, PA.method = "threshold", beta = 0.2,  plot = TRUE)
convertToPA(sp1, PA.method = "threshold", beta = "random", plot = TRUE)

# Conversion into presence-absence with a probability approach using logistic
# method
convertToPA(sp1, PA.method = "probability", beta = 0.4, 
              alpha = -0.05, plot = TRUE)
convertToPA(sp1, PA.method = "probability", beta = "random", 
              alpha = -0.1, plot = TRUE)
              
# Conversion into presence-absence with a probability approach using linear 
# method
convertToPA(sp1, PA.method = "probability", prob.method = "linear",
            a = 1, b = 0, plot = TRUE)         
              
              
# Conversion into presence-absence by choosing the prevalence
# Threshold method
convertToPA(sp1, PA.method = "threshold",
              species.prevalence = 0.3, plot = TRUE)
# Logistic method, with alpha provided              
convertToPA(sp1, PA.method = "probability", alpha = -0.1, 
              species.prevalence = 0.2, plot = TRUE)        
# Logistic method, with beta provided              
convertToPA(sp1, PA.method = "probability", beta = 0.5, 
              species.prevalence = 0.2, alpha = NULL, 
              plot = TRUE)    
# Linear method
convertToPA(sp1, PA.method = "probability", prob.method = "linear",
            species.prevalence = 0.2,
            plot = TRUE)              
convertToPA(sp1, PA.method = "probability", prob.method = "linear",
            species.prevalence = 0.5,
            plot = TRUE) 
convertToPA(sp1, PA.method = "probability", prob.method = "linear",
            species.prevalence = 0.8,
            plot = TRUE)                
 
# Plot the output Presence-Absence raster only             
sp1 &lt;- convertToPA(sp1, plot = FALSE)
plot(sp1$pa.raster)
</code></pre>

<hr>
<h2 id='custnorm'>Normal function defined by extremes</h2><span id='topic+custnorm'></span>

<h3>Description</h3>

<p>A modified version of the normal function based on three parameters:
</p>

<ul>
<li><p>the mean
</p>
</li>
<li><p>the absolute difference between the mean and extreme values
</p>
</li>
<li><p>the percentage of area under the curve between the specified extreme values
</p>
</li></ul>

<p>See the example for an easier understanding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>custnorm(x, mean, diff, prob)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="custnorm_+3A_x">x</code></td>
<td>
<p>a numeric value or vector. The input environmental variable.</p>
</td></tr>
<tr><td><code id="custnorm_+3A_mean">mean</code></td>
<td>
<p>a numeric value or vector. The optimum (mean) of the normal curve</p>
</td></tr>
<tr><td><code id="custnorm_+3A_diff">diff</code></td>
<td>
<p>a numeric value or vector. The absolute difference between the mean and extremes.</p>
</td></tr>
<tr><td><code id="custnorm_+3A_prob">prob</code></td>
<td>
<p>a numeric value or vector. The percentage of the area under the curve between the 
chosen extreme values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value or vector resulting from the function
</p>


<h3>Author(s)</h3>

<p>Boris Leroy <a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>, Florian David
</p>
<p>Maintainer: Boris Leroy <a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Let's define the response of a species to temperature which
#  - has an optimum at 20 degrees C
#  - occurs 99% of the time between 13 and 27 degrees C.
# In that case, mean = 20, diff = 7, and prob = 0.99

# First, we generate an arbitrary temperature variable 
# between 0 and 30 degrees C
temp &lt;- seq(0, 30, length = 1000)


# Then, we calculate the response to this variable with the chosen values
response &lt;- custnorm(x = temp, mean = 20, diff = 7, prob = .99)

plot(response ~ temp, type = "l")
</code></pre>

<hr>
<h2 id='formatFunctions'>Format and visualise functions used to generate virtual species with <code><a href="#topic+generateSpFromFun">generateSpFromFun</a></code></h2><span id='topic+formatFunctions'></span>

<h3>Description</h3>

<p>This function is a helper function to simplify the formatting of functions
for <code><a href="#topic+generateSpFromFun">generateSpFromFun</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formatFunctions(x = NULL, rescale = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formatFunctions_+3A_x">x</code></td>
<td>
<p>NULL or a <code>RasterStack</code>. If you want to visualise the functions,
provide your <code>RasterStack</code> here.</p>
</td></tr>
<tr><td><code id="formatFunctions_+3A_rescale">rescale</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>. If <code>TRUE</code>, individual response
plots are rescaled between 0 and 1 with the formula (val - min) / (max - min).</p>
</td></tr>
<tr><td><code id="formatFunctions_+3A_...">...</code></td>
<td>
<p>the parameters to be formatted. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function formats the <code>parameters</code> argument of <code><a href="#topic+generateSpFromFun">generateSpFromFun</a></code>.  
For each environmental variable, provide a vector containing the function name, and its arguments.  
</p>
<p>For example, assume we want to generate a species responding to two environmental variables bio1 and bio2.
</p>

<ul>
<li><p>The response to bio1 is a normal response (<code><a href="stats.html#topic+dnorm">dnorm</a></code>), of mean 1 and standard deviation 0.5.
</p>
</li>
<li><p>The response to bio2 is a linear response (<code><a href="#topic+linearFun">linearFun</a></code>), of slope (a) 2 and intercept (b) 5.
</p>
</li></ul>

<p>The correct writing is:
</p>
<p><code>formatFunctions(
bio1 = c(fun = "dnorm", mean = 1, sd = 0.5),
bio2 = c(fun = "linearFun", a = 2, b = 5))</code>
</p>


<h3>Warning</h3>

<p>Do not use 'x' as a name for your environmental variables.
</p>


<h3>Author(s)</h3>

<p>Boris Leroy <a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>
</p>
<p>with help from C. N. Meynard, C. Bellard &amp; F. Courchamp
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my.parameters &lt;- formatFunctions(variable1 = c(fun = 'dnorm',
                                            mean = 0.00012, sd = 0.0001),
                              variable2 = c(fun = 'linearFun', a = 1, b = 0))


my.parameters &lt;- formatFunctions(bio1 = c(fun = "logisticFun", 
                                         alpha = -12.7, beta = 68),
                                 bio2 = c(fun = "linearFun", 
                                          a = -0.03, b = 191.2),
                                 bio3 = c(fun = "dnorm", 
                                          mean = 86.4, sd = 19.1),
                                 bio4 = c(fun = "logisticFun", 
                                          alpha = 2198.5, beta = 11381.4))
## Not run: 
# An example using worldclim data
bio1.4 &lt;- getData('worldclim', var='bio', res=10)[[1:4]]
my.parameters &lt;- formatFunctions(x = bio1.4,
                                 bio1 = c(fun = "logisticFun", 
                                          alpha = -12.7, beta = 68),
                                 bio2 = c(fun = "linearFun", 
                                          a = -0.03, b = 191.2),
                                 bio3 = c(fun = "dnorm", 
                                          mean = 86.4, sd = 19.1),
                                 bio4 = c(fun = "logisticFun", 
                                          alpha = 2198.5, beta = 11381.4))

## End(Not run)
</code></pre>

<hr>
<h2 id='generateRandomSp'>Generate a random virtual species distribution from environmental variables</h2><span id='topic+generateRandomSp'></span>

<h3>Description</h3>

<p>This function generates randomly a virtual species distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateRandomSp(
  raster.stack,
  approach = "automatic",
  rescale = TRUE,
  convert.to.PA = TRUE,
  relations = c("gaussian", "linear", "logistic", "quadratic"),
  rescale.each.response = TRUE,
  realistic.sp = TRUE,
  species.type = "multiplicative",
  niche.breadth = "any",
  sample.points = FALSE,
  nb.points = 10000,
  PA.method = "probability",
  alpha = -0.1,
  adjust.alpha = TRUE,
  beta = "random",
  species.prevalence = NULL,
  plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateRandomSp_+3A_raster.stack">raster.stack</code></td>
<td>
<p>a SpatRaster object, in which each layer represent an
environmental 
variable.</p>
</td></tr>
<tr><td><code id="generateRandomSp_+3A_approach">approach</code></td>
<td>
<p><code>"automatic"</code>, <code>"random"</code>, <code>"response"</code>
or <code>"pca"</code>. This parameters defines how species will be generated. 
<code>"automatic"</code>: If less than 6 variables in <code>raster.stack</code>, a 
response approach will be used, otherwise a pca approach will be used.
<code>"random"</code>: the approach will be randomly picked. Otherwise choose
<code>"response"</code> or <code>"pca"</code>. See details.</p>
</td></tr>
<tr><td><code id="generateRandomSp_+3A_rescale">rescale</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>. If <code>TRUE</code>, the final 
probability of presence is rescaled between 0 and 1.</p>
</td></tr>
<tr><td><code id="generateRandomSp_+3A_convert.to.pa">convert.to.PA</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>. If <code>TRUE</code>, the 
virtual species distribution will also be converted into Presence-Absence.</p>
</td></tr>
<tr><td><code id="generateRandomSp_+3A_relations">relations</code></td>
<td>
<p>[response approach] a vector containing the possible types 
of response function.
The implemented type of relations are <code>"gaussian"</code>, <code>"linear"</code>,
<code>"logistic"</code> and <code>"quadratic"</code>.</p>
</td></tr>
<tr><td><code id="generateRandomSp_+3A_rescale.each.response">rescale.each.response</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>. If <code>TRUE</code>, 
the individual responses to
each environmental variable are rescaled between 0 and 1</p>
</td></tr>
<tr><td><code id="generateRandomSp_+3A_realistic.sp">realistic.sp</code></td>
<td>
<p>[response approach] <code>TRUE</code> or <code>FALSE</code>. If 
<code>TRUE</code>, the function will try to define responses that can form a viable
species. If <code>FALSE</code>, the responses will be randomly generated
(may result in environmental conditions that do not co-exist).</p>
</td></tr>
<tr><td><code id="generateRandomSp_+3A_species.type">species.type</code></td>
<td>
<p>[response approach] <code>"additive"</code> or 
<code>"multiplicative"</code>. Defines 
how the final probability of presence is calculated: if <code>"additive"</code>,
responses to each
variable are summed; if <code>"multiplicative"</code>, responses are multiplied.
See <code><a href="#topic+generateSpFromFun">generateSpFromFun</a></code></p>
</td></tr>
<tr><td><code id="generateRandomSp_+3A_niche.breadth">niche.breadth</code></td>
<td>
<p>[pca approach] <code>"any"</code>, <code>"narrow"</code> or 
<code>"wide"</code>. This parameter
defines how tolerant is the species regarding environmental conditions by 
adjusting
the standard deviations of the gaussian functions. See 
<code><a href="#topic+generateSpFromPCA">generateSpFromPCA</a></code></p>
</td></tr>
<tr><td><code id="generateRandomSp_+3A_sample.points">sample.points</code></td>
<td>
<p>[pca approach] <code>TRUE</code> of <code>FALSE</code>. If you have 
a large
raster file then use this parameter to sample a number of points equal to
<code>nb.points</code>.</p>
</td></tr>
<tr><td><code id="generateRandomSp_+3A_nb.points">nb.points</code></td>
<td>
<p>[pca approach] a numeric value. Only useful if 
<code>sample.points = TRUE</code>.
The number of sampled points from the raster, to perform the PCA. A too small
value may not be representative of the environmental conditions in your 
raster.</p>
</td></tr>
<tr><td><code id="generateRandomSp_+3A_pa.method">PA.method</code></td>
<td>
<p><code>"threshold"</code> or <code>"probability"</code>. If 
<code>"threshold"</code>, then occurrence probabilities are simply converted into
presence-absence according to the threshold <code>beta</code>. If 
<code>"probability"</code>, then
probabilities are converted according to a logistic function of threshold 
<code>beta</code> and slope <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="generateRandomSp_+3A_alpha">alpha</code></td>
<td>
<p><code>NULL</code> or a negative numeric value. Only useful if 
<code>PA.method = "probability"</code>. The value of <code>alpha</code> will
shape the logistic function transforming occurrences into presence-absences.
See <code><a href="#topic+logisticFun">logisticFun</a></code> and examples therein for the choice of 
<code>alpha</code></p>
</td></tr>
<tr><td><code id="generateRandomSp_+3A_adjust.alpha">adjust.alpha</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>. Only useful if 
<code>rescale = FALSE</code>. If  <code>adjust.alpha = TRUE</code>, then the value 
of <code>alpha</code> will
be adjusted to an appropriate value  for the range of suitabilities.</p>
</td></tr>
<tr><td><code id="generateRandomSp_+3A_beta">beta</code></td>
<td>
<p><code>"random"</code>, a numeric value in the range of your 
probabilities or <code>NULL</code>. This is the threshold of conversion into
presence-absence (= the inflexion point if <code>PA.method = "probability"</code>).
If <code>"random"</code>, a numeric value will be randomly generated within 
the range
of probabilities of occurrence. See <code><a href="#topic+convertToPA">convertToPA</a></code></p>
</td></tr>
<tr><td><code id="generateRandomSp_+3A_species.prevalence">species.prevalence</code></td>
<td>
<p><code>NULL</code> or a numeric value between 0 and 1.
The species prevalence is the proportion of sites actually occupied by the
species. See <code><a href="#topic+convertToPA">convertToPA</a></code></p>
</td></tr>
<tr><td><code id="generateRandomSp_+3A_plot">plot</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>. If <code>TRUE</code>, the generated 
virtual species will be plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><a href="http://borisleroy.com/virtualspecies_tutorial/05-randomspecies.html">
Online tutorial for this function</a>
</p>
<p>This function generate random virtual species, either using a PCA 
approach, or using
a response approach. In case of a response approach, only four response 
functions are
currently used: gaussian, linear, logistic and quadratic functions.
</p>
<p>Note that in case of numerous predictor variables, the &quot;response&quot; 
approach will
not work well because it will often generate contradicting response functions 
(e.g., mean annual temperature optimum at degrees C and temperature 
of the coldest month at
10 degrees C). In these case, it is advised to use the PCA approach 
(by default, a PCA approach
will be used if there are more than 6 predictor variables).
</p>
<p>If <code>rescale.each.response = TRUE</code>, then the probability response to each
variable will be normalised between 0 and 1 according to the following 
formula:
P.rescaled = (P - min(P)) / (max(P) - min (P)). Similarly, if 
<code>rescale = TRUE</code>,
the final environmental suitability will be rescaled between 0 and 1 
with the same formula.
</p>
<p>By default, the function will perform a probabilistic conversion into 
presence-
absence, with a randomly chosen beta threshold. If you want to customise the 
conversion parameters, you have to define <b>two</b> of the three 
following parameters:
</p>

<ul>
<li><p><code>beta</code>: the 'threshold' of the logistic function (i.e. the 
inflexion point)
</p>
</li>
<li><p><code>alpha</code>: the slope of the logistic function
</p>
</li>
<li><p><code>species.prevalence</code>: the proportion of sites in which the species
occur
</p>
</li></ul>

<p>If you provide <code>beta</code> and <code>alpha</code>, the <code>species.prevalence</code>
is calculated immediately calculated after conversion into presence-absence.
</p>
<p>As explained in <code><a href="#topic+convertToPA">convertToPA</a></code>, if you choose choose a precise
<code>species.prevalence</code>, it may not be possible to reach this particular 
value because of the availability of environmental conditions. Several
runs may be necessary to reach the desired <code>species.prevalence</code>.
</p>


<h3>Value</h3>

<p>a <code>list</code> with 3 to 5 elements (depending if the conversion 
to presence-absence was performed):
</p>

<ul>
<li><p><code>approach</code>: the approach used to generate the species, 
<em>i.e.</em>, <code>"response"</code>
</p>
</li>
<li><p><code>details</code>: the details and parameters used to generate the 
species
</p>
</li>
<li><p><code>suitab.raster</code>: the virtual species distribution, as a 
SpatRaster object containing the
environmental suitability)
</p>
</li>
<li><p><code>PA.conversion</code>: the parameters used to convert the suitability 
into presence-absence
</p>
</li>
<li><p><code>pa.raster</code>: the presence-absence map, as a SpatRaster object 
containing 0 (absence) / 1 (presence) / NA
</p>
</li></ul>

<p>The structure of the virtualspecies can object be seen using <code>str()</code>
</p>


<h3>Author(s)</h3>

<p>Boris Leroy <a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>
</p>
<p>with help from C. N. Meynard, C. Bellard &amp; F. Courchamp
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create an example stack with six environmental variables
a &lt;- matrix(rep(dnorm(1:100, 50, sd = 25)), 
            nrow = 100, ncol = 100, byrow = TRUE)
env &lt;- c(rast(a * dnorm(1:100, 50, sd = 25)),
         rast(a * 1:100),
         rast(a * logisticFun(1:100, alpha = 10, beta = 70)),
         rast(t(a)),
         rast(exp(a)),
         rast(log(a)))
names(env) &lt;- paste("Var", 1:6, sep = "")   

# More than 6 variables: by default a PCA approach will be used
generateRandomSp(env)

# Manually choosing a response approach: this may fail because it is hard
# to find a realistic species with six distinct responses to six variables

generateRandomSp(env, approach = "response")


# Randomly choosing the approach
generateRandomSp(env, approach = "random")


</code></pre>

<hr>
<h2 id='generateSpFromBCA'>Generate a virtual species distribution from a Between Component Analysis 
of environmental variables</h2><span id='topic+generateSpFromBCA'></span>

<h3>Description</h3>

<p>A Between Component Analysis is similar to a PCA, except that two sets of 
environmental conditions 
(e.g. current and future) will be used. This function is useful to generate 
species designed to test the extrapolation capacity of models, e.g.  
for climate change extrapolations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateSpFromBCA(
  raster.stack.current,
  raster.stack.future,
  rescale = TRUE,
  niche.breadth = "any",
  means = NULL,
  sds = NULL,
  bca = NULL,
  sample.points = FALSE,
  nb.points = 10000,
  plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateSpFromBCA_+3A_raster.stack.current">raster.stack.current</code></td>
<td>
<p>a SpatRaster object, in which each layer 
represent an environmental 
variable from the &quot;current&quot; time horizon.</p>
</td></tr>
<tr><td><code id="generateSpFromBCA_+3A_raster.stack.future">raster.stack.future</code></td>
<td>
<p>a SpatRaster object, in which each layer 
represent an environmental 
variable from a &quot;future&quot; time horizon.</p>
</td></tr>
<tr><td><code id="generateSpFromBCA_+3A_rescale">rescale</code></td>
<td>
<p><code>TRUE</code> of <code>FALSE</code>. Should the output suitability 
raster be
rescaled between 0 and 1?</p>
</td></tr>
<tr><td><code id="generateSpFromBCA_+3A_niche.breadth">niche.breadth</code></td>
<td>
<p><code>"any"</code>, <code>"narrow"</code> or <code>"wide"</code>. This
parameter
defines how tolerant is the species regarding environmental conditions by 
adjusting
the standard deviations of the gaussian functions. See details.</p>
</td></tr>
<tr><td><code id="generateSpFromBCA_+3A_means">means</code></td>
<td>
<p>a vector containing two numeric values. Will be used to define
the means of the gaussian response functions to the axes of the BCA.</p>
</td></tr>
<tr><td><code id="generateSpFromBCA_+3A_sds">sds</code></td>
<td>
<p>a vector containing two numeric values. Will be used to define
the standard deviations of the gaussian response functions to the axes of 
the BCA.</p>
</td></tr>
<tr><td><code id="generateSpFromBCA_+3A_bca">bca</code></td>
<td>
<p>a <code>bca</code> object. You can provide a bca object that you 
already computed yourself with 
<code><a href="#topic+generateSpFromBCA">generateSpFromBCA</a></code></p>
</td></tr>
<tr><td><code id="generateSpFromBCA_+3A_sample.points">sample.points</code></td>
<td>
<p><code>TRUE</code> of <code>FALSE</code>. If you have large
raster files then use this parameter to sample a number of points equal to
<code>nb.points</code>. However the representation of your environmental variables
will not be complete.</p>
</td></tr>
<tr><td><code id="generateSpFromBCA_+3A_nb.points">nb.points</code></td>
<td>
<p>a numeric value. Only useful if <code>sample.points = TRUE</code>.
The number of sampled points from the raster, to perform the PCA. A too small
value may not be representative of the environmental conditions in your 
rasters.</p>
</td></tr>
<tr><td><code id="generateSpFromBCA_+3A_plot">plot</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>. If <code>TRUE</code>, the generated 
virtual species will be plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates a virtual species distribution by computing a Between
Component Analysis based on two different stacks of environmental variables.
The response of the species is then simulated along the two first axes of 
the BCA with gaussian functions in the
same way as in <code><a href="#topic+generateSpFromPCA">generateSpFromPCA</a></code>.
</p>
<p>A Between Component Analysis is used to separate two sets of environmental 
conditions.
This function proceeds in 4 steps:
</p>

<ol>
<li><p>A Principal Component Analysis is generated based on both set of 
environmental conditions
</p>
</li>
<li><p>A BCA of this PCA is generated using the function 
<code><a href="ade4.html#topic+bca">bca</a></code>
from package <code>ade4</code>. Note that at this step we choose  one random point
from <code>raster.stack.future</code>,
and we use this single point as if it was a third set of environmental
conditions for the BCA. This trick allows us to subtly change the shape of 
the bca in order to
generate different types of conditions.
</p>
</li>
<li><p>Gaussian responses to the first two axes are computed
</p>
</li>
<li><p>These responses are multiplied to obtain the final environmental 
suitability</p>
</li></ol>

<p>If <code>rescale = TRUE</code>, the final environmental suitability is rescaled 
between 0 and 1,
with the formula (val - min) / (max - min).
</p>
<p>The shape of gaussian responses can be randomly generated by the function 
or defined manually by choosing
<code>means</code> and <code>sds</code>. The random generation is constrained
by the argument <code>niche.breadth</code>, which controls the range of possible 
standard deviation values. This range of values is based on
a fraction of the axis:
</p>

<ul>
<li><p><code>"any"</code>: the standard deviations can have values from 1% to 
50% of axes' ranges. For example if the first axis of the PCA ranges from 
-5 to +5,
then sd values along this axis can range from 0.1 to 5.

</p>
</li>
<li><p><code>"narrow"</code>: the standard deviations are limited between 1% and 
10% of axes' ranges. For example if the first axis of the PCA ranges from 
-5 to +5,
then sd values along this axis can range from 0.1 to 1.

</p>
</li>
<li><p><code>"wide"</code>: the standard deviations are limited between 10% and 
50% of axes' ranges. For example if the first axis of the PCA ranges from 
-5 to +5,
then sd values along this axis can range from 1 to 5.

</p>
</li></ul>

<p>If a <code>bca</code> object is provided, the output bca object will contain the 
new environments coordinates along the provided bca axes.
</p>


<h3>Value</h3>

<p>a <code>list</code> with 4 elements:
</p>

<ul>
<li><p><code>approach</code>: the approach used to generate the species, 
<em>i.e.</em>, <code>"bca"</code>
</p>
</li>
<li><p><code>details</code>: the details and parameters used to generate the 
species
</p>
</li>
<li><p><code>suitab.raster.current</code>: the virtual species distribution, as a 
SpatRaster object containing the
current environmental suitability
</p>
</li>
<li><p><code>suitab.raster.future</code>: the virtual species distribution, as a 
SpatRaster object containing the
future environmental suitability
</p>
</li></ul>

<p>The structure of the virtualspecies object can be seen using <code>str()</code>
</p>


<h3>Note</h3>

<p>To perform the BCA, the function has to transform rasters into matrices.
This may not be feasible if the chosen rasters are too large for the 
computer's memory.
In this case, you should run the function with <code>sample.points = TRUE</code> 
and set the number of points to sample with <code>nb.points</code>.
</p>


<h3>Author(s)</h3>

<p>Robin Delsol, Boris Leroy
</p>
<p>Maintainer: Boris Leroy <a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generateSpFromFun">generateSpFromFun</a></code> to generate a virtual species with
the responses to each environmental variables.<code><a href="#topic+generateSpFromPCA">generateSpFromPCA</a></code>
to generate a virtual species with
the PCA of environmental variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create two example stacks with four environmental variables each
a &lt;- matrix(rep(dnorm(1:100, 50, sd = 25)), 
            nrow = 100, ncol = 100, byrow = TRUE)

env1 &lt;- c(rast(a * dnorm(1:100, 50, sd = 25)),
          rast(a * 1:100),
          rast(a),
          rast(t(a)))
names(env1) &lt;- c("var1", "var2", "var3", "var4")
plot(env1) # Illustration of the variables

b &lt;- matrix(rep(dnorm(1:100, 25, sd = 50)), 
            nrow = 100, ncol = 100, byrow = TRUE)

env2 &lt;- c(rast(b * dnorm(1:100, 50, sd = 25)),
          rast(b * 1:100),
          rast(b),
          rast(t(b)))

names(env2) &lt;- c("var1", "var2", "var3", "var4")
plot(env2) # Illustration of the variables 

# Generating a species with the BCA

generateSpFromBCA(raster.stack.current = env1, raster.stack.future = env2)

# The left part of the plot shows the BCA and the response functions along
# the two axes.
# The top-right part shows environmental suitability of the virtual
# species in the current environment.
# The bottom-right part shows environmental suitability of the virtual
# species in the future environment. 


# Defining manually the response to axes

generateSpFromBCA(raster.stack.current = env1, raster.stack.future = env2,
           means = c(-2, 0),
           sds = c(0.6, 1.5))
   
                   
</code></pre>

<hr>
<h2 id='generateSpFromFun'>Generate a virtual species distributions with responses to environmental
variables</h2><span id='topic+generateSpFromFun'></span>

<h3>Description</h3>

<p>This function generates a virtual species distribution from a stack of
environmental
variables and a defined set of responses to each environmental parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateSpFromFun(
  raster.stack,
  parameters,
  rescale = TRUE,
  formula = NULL,
  species.type = "multiplicative",
  rescale.each.response = TRUE,
  plot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateSpFromFun_+3A_raster.stack">raster.stack</code></td>
<td>
<p>a SpatRaster object, in which each layer represent an 
environmental 
variable.</p>
</td></tr>
<tr><td><code id="generateSpFromFun_+3A_parameters">parameters</code></td>
<td>
<p>a list containing the functions of response of the species
to environmental variables with their parameters. See details.</p>
</td></tr>
<tr><td><code id="generateSpFromFun_+3A_rescale">rescale</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>. If <code>TRUE</code>, the final 
probability of presence is rescaled between 0 and 1.</p>
</td></tr>
<tr><td><code id="generateSpFromFun_+3A_formula">formula</code></td>
<td>
<p>a character string or <code>NULL</code>. The formula used to combine
partial responses into the final
environmental suitability value (e.g., <code>"layername1 + 2 * layername2 +
layername3 * layername4 etc."</code>). If <code>NULL</code> then partial responses will 
be added or multiplied according to
<code>species.type</code></p>
</td></tr>
<tr><td><code id="generateSpFromFun_+3A_species.type">species.type</code></td>
<td>
<p><code>"additive"</code> or <code>"multiplicative"</code>. Only used 
if <code>formula = NULL</code>. 
Defines how the final environmental suitability is calculated: if 
<code>"additive"</code>, responses to each
variable are summed; if <code>"multiplicative"</code>, responses are multiplied.</p>
</td></tr>
<tr><td><code id="generateSpFromFun_+3A_rescale.each.response">rescale.each.response</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>. If <code>TRUE</code>, 
the individual responses to
each environmental variable are rescaled between 0 and 1 (see details).</p>
</td></tr>
<tr><td><code id="generateSpFromFun_+3A_plot">plot</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>. If <code>TRUE</code>, the generated 
virtual species will be plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><a href="http://borisleroy.com/virtualspecies_tutorial/02-response.html">Online 
tutorial for this function</a>
</p>
<p>This function proceeds in two steps:
</p>

<ol>
<li><p>The response to each environmental variable is calculated with the 
functions provided
in <code>parameters</code>. This results in a suitability  of each variable.
</p>
<p><b>By default, each response is rescaled between 0 and 1.</b> Disable with 
<code>rescale.each.response = FALSE</code>
</p>
</li>
<li><p>The final environmental suitability is calculated according to the 
chosen <code>species.type</code>.
</p>
<p><b>By default, the final suitability is rescaled between 0 and 1.</b> 
Disable with 
<code>rescale = FALSE</code>
</p>
</li></ol>

<p>The SpatRaster stack containing environmental variables must have consistent 
names, 
because they will be checked with the <code>parameters</code>. For example, they 
can be named
var1, var2, etc. Names can be checked and set with <code>names(my.stack)</code>.
</p>
<p>The <code>parameters</code> have to be carefully created, otherwise the function 
will not work:
</p>

<ul>
<li><p>Either see <code><a href="#topic+formatFunctions">formatFunctions</a></code> to easily create your list of 
parameters
</p>
</li>
<li><p>Or create a <code>list</code> defined according to the following template:<br />
<code>list(
           var1 = list(fun = 'fun1', args = list(arg1 = ..., arg2 = ..., 
           etc.)),
           var2 = list(fun = 'fun2', args = list(arg1 = ..., arg2 = ..., 
           etc.)))</code><br />
It is important to keep the same names in the parameters as in the stack of 
environmental
variables. Similarly, argument names must be identical to argument names in 
the associated 
function (e.g., if you use <code>fun = 'dnorm'</code>, then args should look like 
<code>list(mean = 0, sd = 1)</code>).
</p>
<p>See the example section below for more examples.</p>
</li></ul>

<p>Any response function that can be applied to the environmental variables can
be chosen here. Several functions are proposed in this package:
<code><a href="#topic+linearFun">linearFun</a></code>, <code><a href="#topic+logisticFun">logisticFun</a></code> and 
<code><a href="#topic+quadraticFun">quadraticFun</a></code>.
Another classical example is the normal distribution: 
<code><a href="stats.html#topic+Normal">stats::dnorm()</a></code>.
Users can also create and use their own functions very easily.
</p>
<p>If <code>rescale.each.response = TRUE</code>, then the probability response to each
variable will be normalised between 0 and 1 according to the following 
formula:
P.rescaled = (P - min(P)) / (max(P) - min (P))
This rescaling has a strong impact on response functions, so users may 
prefer to
use <code>rescale.each.response = FALSE</code> and apply their own rescaling within
their response functions.
</p>


<h3>Value</h3>

<p>a <code>list</code> with 3 elements:
</p>

<ul>
<li><p><code>approach</code>: the approach used to generate the species, 
<em>i.e.</em>, <code>"response"</code>
</p>
</li>
<li><p><code>details</code>: the details and parameters used to generate the 
species
</p>
</li>
<li><p><code>suitab.raster</code>: the raster containing the environmental 
suitability of the virtual species
</p>
</li></ul>

<p>The structure of the virtualspecies object can be seen using <code>str()</code>
</p>


<h3>Author(s)</h3>

<p>Boris Leroy <a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>
</p>
<p>with help from C. N. Meynard, C. Bellard &amp; F. Courchamp
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generateSpFromPCA">generateSpFromPCA</a></code> to generate a virtual species with 
a PCA approach
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create an example stack with two environmental variables
a &lt;- matrix(rep(dnorm(1:100, 50, sd = 25)), 
            nrow = 100, ncol = 100, byrow = TRUE)
env &lt;- c(rast(a * dnorm(1:100, 50, sd = 25)),
         rast(a * 1:100))
names(env) &lt;- c("variable1", "variable2")
plot(env) # Illustration of the variables

# Easy creation of the parameter list:
# see in real time the shape of the response functions
parameters &lt;- formatFunctions(variable1 = c(fun = 'dnorm', mean = 1e-04, 
                                             sd = 1e-04),
                              variable2 = c(fun = 'linearFun', a = 1, b = 0))
                              
# If you provide env, then you can see the shape of response functions:
parameters &lt;- formatFunctions(x = env,
                              variable1 = c(fun = 'dnorm', mean = 1e-04, 
                                             sd = 1e-04),
                              variable2 = c(fun = 'linearFun', a = 1, b = 0))

# Generation of the virtual species
sp1 &lt;- generateSpFromFun(env, parameters)
sp1
par(mfrow = c(1, 1))
plot(sp1)


# Manual creation of the parameter list
# Note that the variable names are the same as above
parameters &lt;- list(variable1 = list(fun = 'dnorm',
                                    args = list(mean = 0.00012,
                                                sd = 0.0001)),
                   variable2 = list(fun = 'linearFun',
                                    args = list(a = 1, b = 0)))
# Generation of the virtual species
sp1 &lt;- generateSpFromFun(env, parameters, plot = TRUE)
sp1
plot(sp1)
</code></pre>

<hr>
<h2 id='generateSpFromPCA'>Generate a virtual species distribution with a PCA of environmental variables</h2><span id='topic+generateSpFromPCA'></span>

<h3>Description</h3>

<p>This functions generates a virtual species distribution by computing a
PCA among environmental variables, and simulating the response of the species
along the two first axes of the PCA. The response to axes of the PCA is 
determined with gaussian functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateSpFromPCA(
  raster.stack,
  rescale = TRUE,
  niche.breadth = "any",
  axes = c(1, 2),
  means = NULL,
  sds = NULL,
  pca = NULL,
  sample.points = FALSE,
  nb.points = 10000,
  plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateSpFromPCA_+3A_raster.stack">raster.stack</code></td>
<td>
<p>a SpatRaster object, in which each layer represent an
environmental 
variable.</p>
</td></tr>
<tr><td><code id="generateSpFromPCA_+3A_rescale">rescale</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>. Should the output suitability 
raster be
rescaled between 0 and 1?</p>
</td></tr>
<tr><td><code id="generateSpFromPCA_+3A_niche.breadth">niche.breadth</code></td>
<td>
<p><code>"any"</code>, <code>"narrow"</code> or <code>"wide"</code>. This 
parameter
defines how tolerant is the species regarding environmental conditions by
adjusting
the standard deviations of the gaussian functions. See details.</p>
</td></tr>
<tr><td><code id="generateSpFromPCA_+3A_axes">axes</code></td>
<td>
<p>a vector of values. Which axes would you like to keep in your 
PCA? 
At least 2 axes should be included (Only 1 axis currently not supported)</p>
</td></tr>
<tr><td><code id="generateSpFromPCA_+3A_means">means</code></td>
<td>
<p>a vector containing as many numeric values as axes. Will be 
used to define
the means of the gaussian response functions to the axes of the PCA.</p>
</td></tr>
<tr><td><code id="generateSpFromPCA_+3A_sds">sds</code></td>
<td>
<p>a vector containing as many numeric values as axes. Will be 
used to define
the standard deviations of the gaussian response functions to the axes of 
the PCA.</p>
</td></tr>
<tr><td><code id="generateSpFromPCA_+3A_pca">pca</code></td>
<td>
<p>a <code>dudi.pca</code> object. You can provide a pca object that you 
computed yourself with <code><a href="ade4.html#topic+dudi.pca">dudi.pca</a></code></p>
</td></tr>
<tr><td><code id="generateSpFromPCA_+3A_sample.points">sample.points</code></td>
<td>
<p><code>TRUE</code> of <code>FALSE</code>. If you have a large
raster file then use this parameter to sample a number of points equal to
<code>nb.points</code>.</p>
</td></tr>
<tr><td><code id="generateSpFromPCA_+3A_nb.points">nb.points</code></td>
<td>
<p>a numeric value. Only useful if <code>sample.points = TRUE</code>.
The number of sampled points from the raster, to perform the PCA. A too small
value may not be representative of the environmental conditions in your 
raster.</p>
</td></tr>
<tr><td><code id="generateSpFromPCA_+3A_plot">plot</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>. If <code>TRUE</code>, the generated 
virtual species will be plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><a href="http://borisleroy.com/virtualspecies_tutorial/03-PCA.html">Online 
tutorial for this function</a>
</p>
<p>This function proceeds in 3 steps:
</p>

<ol>
<li><p>A PCA of environmental conditions is generated
</p>
</li>
<li><p>Gaussian responses to the first two axes are computed
</p>
</li>
<li><p>These responses are multiplied to obtain the final environmental 
suitability</p>
</li></ol>

<p>If <code>rescale = TRUE</code>, the final environmental suitability is rescaled 
between 0 and 1,
with the formula (val - min) / (max - min).
</p>
<p>The shape of gaussian responses can be randomly generated by the function or
defined manually by choosing
<code>means</code> and <code>sds</code>. The random generation is constrained
by the argument <code>niche.breadth</code>, which controls the range of possible 
standard deviation values. This range of values is based on
a fraction of the axis:
</p>

<ul>
<li><p><code>"any"</code>: the standard deviations can have values from 1% to 
50% of axes' ranges. For example if the first axis of the PCA ranges from 
-5 to +5,
then sd values along this axis can range from 0.1 to 5.

</p>
</li>
<li><p><code>"narrow"</code>: the standard deviations are limited between 1% and 
10% of axes' ranges. For example if the first axis of the PCA ranges from 
-5 to +5,
then sd values along this axis can range from 0.1 to 1.

</p>
</li>
<li><p><code>"wide"</code>: the standard deviations are limited between 10% and 
50% of axes' ranges. For example if the first axis of the PCA ranges from 
-5 to +5,
then sd values along this axis can range from 1 to 5.

</p>
</li></ul>



<h3>Value</h3>

<p>a <code>list</code> with 3 elements:
</p>

<ul>
<li><p><code>approach</code>: the approach used to generate the species, 
<em>i.e.</em>, <code>"pca"</code>
</p>
</li>
<li><p><code>details</code>: the details and parameters used to generate 
the species
</p>
</li>
<li><p><code>suitab.raster</code>: the virtual species distribution, as a 
SpatRaster object containing the
environmental suitability
</p>
</li></ul>

<p>The structure of the virtualspecies object can be seen using <code>str()</code>
</p>


<h3>Note</h3>

<p>To perform the PCA, the function has to transform the raster into a matrix.
This may not be feasible if the raster is too large for the 
computer's memory.
In this case, you should perform the PCA on a sample of your raster with
set <code>sample.points = TRUE</code> and choose the number of points to sample 
with
<code>nb.points</code>.
</p>


<h3>Author(s)</h3>

<p>Boris Leroy <a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>
</p>
<p>with help from C. N. Meynard, C. Bellard &amp; F. Courchamp
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generateSpFromFun">generateSpFromFun</a></code> to generate a virtual species with
the responses to each environmental variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create an example stack with four environmental variables
a &lt;- matrix(rep(dnorm(1:100, 50, sd = 25)), 
            nrow = 100, ncol = 100, byrow = TRUE)
env &lt;- c(rast(a * dnorm(1:100, 50, sd = 25)),
             rast(a * 1:100),
             rast(a * logisticFun(1:100, alpha = 10, beta = 70)),
             rast(t(a)))
names(env) &lt;- c("var1", "var2", "var3", "var4")
plot(env) # Illustration of the variables





# Generating a species with the PCA

generateSpFromPCA(raster.stack = env)

# The top part of the plot shows the PCA and the response functions along
# the two axes.
# The bottom part shows the probabilities of occurrence of the virtual
# species.





# Defining manually the response to axes

generateSpFromPCA(raster.stack = env,
           means = c(-2, 0),
           sds = c(0.6, 1.5))
           
# This species can be seen as occupying intermediate altitude ranges of a
# conic mountain.


# Beyond the first two axes
generateSpFromPCA(raster.stack = env,
                  axes = c(1, 3))
                  
sp &lt;- generateSpFromPCA(raster.stack = env,
                  axes = 1:3)
plotResponse(sp, axes = c(1, 2))
plotResponse(sp, axes = c(1, 3))
plotResponse(sp, axes = c(2, 3))
           
</code></pre>

<hr>
<h2 id='limitDistribution'>Limit a virtual species distribution to a defined area</h2><span id='topic+limitDistribution'></span>

<h3>Description</h3>

<p>This function is designed to limit species distributions to a subsample of
their total distribution range. It will thus generate a species which is not
at the equilibrium with its environment (i.e., which did not occupy the full
range of suitable environmental conditions).
</p>
<p>This function basically takes any type of raster and will limit values above
0 to areas where the species is allowed to disperse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>limitDistribution(x, geographical.limit = "extent", area = NULL, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="limitDistribution_+3A_x">x</code></td>
<td>
<p>a <code>SpatRaster</code> object composed of 0, 1 and NA, or the output 
list from 
<code><a href="#topic+generateSpFromFun">generateSpFromFun</a></code>, <code><a href="#topic+generateSpFromPCA">generateSpFromPCA</a></code> 
or <code><a href="#topic+generateRandomSp">generateRandomSp</a></code></p>
</td></tr>
<tr><td><code id="limitDistribution_+3A_geographical.limit">geographical.limit</code></td>
<td>
<p><code>"country"</code>, <code>"region"</code>, 
<code>"continent"</code>, <code>"polygon"</code>, <code>"raster"</code> or <code>"extent"</code>.
The method used
to limit the distribution range: see details.</p>
</td></tr>
<tr><td><code id="limitDistribution_+3A_area">area</code></td>
<td>
<p><code>NULL</code>, a character string, a <code>polygon</code>, a 
<code>raster</code> or an <code>extent</code> object.
The area in which the distribution range will be limited: see details. 
If <code>NULL</code>
and <code>geographical.limit = "extent"</code>, then you will be asked to draw an
extent on the map.</p>
</td></tr>
<tr><td><code id="limitDistribution_+3A_plot">plot</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>. If <code>TRUE</code>, the resulting 
limited
distribution will be plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><a href="http://borisleroy.com/virtualspecies_tutorial/08-dispersallimitation.html">
Online tutorial for this function</a>
</p>
<p><b>How the function works:</b>
</p>
<p>The function will remove occurrences of the species outside the chosen area:
</p>

<ul>
<li><p>NA are kept unchanged
</p>
</li>
<li><p>0 are kept unchanged
</p>
</li>
<li><p>values &gt; 0 within the limits of <code>area</code> are kept unchanged
</p>
</li>
<li><p>values &gt; 0 outside the limits of <code>area</code> are set to 0
</p>
</li></ul>

<p><b>How to define the area in which the range is limited:</b>
</p>
<p>You can choose to limit the distribution range of the species to:
</p>

<ol>
<li><p>a particular country, region or continent (assuming your raster has
the WGS84 projection): 
</p>
<p>Set the argument
<code>geographical.limit</code> to <code>"country"</code>, <code>"region"</code> or
<code>"continent"</code>, and provide the name(s) of the associated countries,
regions or continents to <code>area</code> (see examples). 
</p>
<p>List of possible <code>area</code> names:
</p>

<ul>
<li><p>Countries: type 
<code>unique(rnaturalearth::ne_countries(returnclass ='sf')$sovereignt)</code> 
in the console
</p>
</li>
<li><p>Regions: &quot;Africa&quot;, &quot;Antarctica&quot;, &quot;Asia&quot;, &quot;Oceania&quot;, &quot;Europe&quot;, 
&quot;Americas&quot;
</p>
</li>
<li><p>Continents: &quot;Africa&quot;, &quot;Antarctica&quot;, &quot;Asia&quot;, &quot;Europe&quot;, 
&quot;North America&quot;, &quot;Oceania&quot;, &quot;South America&quot;</p>
</li></ul>


</li>
<li><p>a polygon:
</p>
<p>Set <code>geographical.limit</code> to <code>"polygon"</code>, and provide your
polygon to <code>area</code>.

</p>
</li>
<li><p>a raster:
</p>
<p>Set <code>geographical.limit</code> to <code>"raster"</code>, and provide your
raster to <code>area</code>. Your raster values should be 1 (suitable area),
0 (unsuitable area) or NA (outside your mask).

</p>
</li>
<li><p>an extent object:
</p>
<p>Set <code>geographical.limit</code> to <code>"extent"</code>, and either provide your
extent object to <code>area</code>, or leave it <code>NULL</code> to draw an extent on
the map.
</p>
</li></ol>



<h3>Value</h3>

<p>a <code>list</code> containing 7 elements:
</p>

<ul>
<li><p><code>approach</code>: the approach used to generate the species, <em>i.e.</em>, <code>"response"</code>
</p>
</li>
<li><p><code>details</code>: the details and parameters used to generate the species
</p>
</li>
<li><p><code>suitab.raster</code>: the virtual species distribution, as a Raster object containing the
environmental suitability)
</p>
</li>
<li><p><code>PA.conversion</code>: the parameters used to convert the suitability into presence-absence
</p>
</li>
<li><p><code>pa.raster</code>: the presence-absence map, as a Raster object containing 0 (absence) / 1 (presence) / NA
</p>
</li>
<li><p><code>geographical.limit</code>: the method used to
limit the distribution and the area in which the distribution is restricted
</p>
</li>
<li><p><code>occupied.area</code>: the area occupied by the virtual species as a
Raster of presence-absence
</p>
</li></ul>

<p>The structure of the virtualspecies object can be seen using <code>str()</code>
</p>


<h3>Author(s)</h3>

<p>Boris Leroy <a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>
</p>
<p>with help from C. N. Meynard, C. Bellard &amp; F. Courchamp
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create an example stack with six environmental variables
a &lt;- matrix(rep(dnorm(1:100, 50, sd = 25)), 
            nrow = 100, ncol = 100, byrow = TRUE)
env &lt;- c(rast(a * dnorm(1:100, 50, sd = 25)),
         rast(a * 1:100),
         rast(a * logisticFun(1:100, alpha = 10, beta = 70)),
         rast(t(a)),
         rast(exp(a)),
         rast(log(a)))
names(env) &lt;- paste("Var", 1:6, sep = "")   

# More than 6 variables: by default a PCA approach will be used
sp &lt;- generateRandomSp(env)

# limiting the distribution to a specific extent
limit &lt;- ext(1, 50, 1, 50)

limitDistribution(sp, area = limit)


# Example of a raster of habitat patches
habitat.raster &lt;- setValues(sp$pa.raster, 
                            sample(c(0, 1), size = ncell(sp$pa.raster), 
                            replace = TRUE))

plot(habitat.raster) # 1 = suitable habitat; 0 = unsuitable habitat
sp &lt;- limitDistribution(sp, geographical.limit = "raster", area = habitat.raster)
par(mfrow = c(2, 1))
plot(sp$pa.raster)
plot(sp$occupied.area) # Species could not occur in many cells because
# habitat patches were unsuitable
</code></pre>

<hr>
<h2 id='linearFun'>Linear function</h2><span id='topic+linearFun'></span>

<h3>Description</h3>

<p>A simple linear function of the form
</p>
<p style="text-align: center;"><code class="reqn">ax+b</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>linearFun(x, a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linearFun_+3A_x">x</code></td>
<td>
<p>a numeric value or vector</p>
</td></tr>
<tr><td><code id="linearFun_+3A_a">a</code></td>
<td>
<p>a numeric value or vector</p>
</td></tr>
<tr><td><code id="linearFun_+3A_b">b</code></td>
<td>
<p>a numeric value or vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value or vector resulting from the function
</p>


<h3>Author(s)</h3>

<p>Boris Leroy <a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>
</p>
<p>Maintainer: Boris Leroy <a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+logisticFun">logisticFun</a></code>, <code><a href="#topic+quadraticFun">quadraticFun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:100
y &lt;- linearFun(x, a = 0.5, b = 0)
plot(y ~ x, type = "l")
</code></pre>

<hr>
<h2 id='logisticFun'>Logistic function</h2><span id='topic+logisticFun'></span>

<h3>Description</h3>

<p>A simple logistic function of the form
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{{1 + e^{\frac{x - \beta}{\alpha}}}}</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>logisticFun(x, alpha, beta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logisticFun_+3A_x">x</code></td>
<td>
<p>a numeric value or vector</p>
</td></tr>
<tr><td><code id="logisticFun_+3A_alpha">alpha</code></td>
<td>
<p>a numeric value or vector</p>
</td></tr>
<tr><td><code id="logisticFun_+3A_beta">beta</code></td>
<td>
<p>a numeric value or vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The value of <code>beta</code> determines the 'threshold' of the logistic curve 
(i.e. the inflexion point).
</p>
<p>The value of <code>alpha</code> determines the slope of the curve (see examples):
</p>

<ul>
<li><p><code>alpha</code> very close to 0 will result in a threshold-like response.
</p>
</li>
<li><p>Values of <code>alpha</code> with the same order of magnitude as the range of
<code>x</code> (e.g., the range of<code>x</code> / 10) will result in a 
logistic function. 
</p>
</li>
<li><p><code>alpha</code> very far from 0 will result in a linear function.
</p>
</li></ul>



<h3>Value</h3>

<p>a numeric value or vector resulting from the function
</p>


<h3>Author(s)</h3>

<p>Boris Leroy <a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>
</p>
<p>Maintainer: Boris Leroy <a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linearFun">linearFun</a></code>, <code><a href="#topic+quadraticFun">quadraticFun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:100
y &lt;- logisticFun(x, alpha = -10, b = 50)
plot(y ~ x, type = "l")

# The effect of alpha:
y1 &lt;- logisticFun(x, alpha = -0.01, b = 50)
y2 &lt;- logisticFun(x, alpha = -10, b = 50)
y3 &lt;- logisticFun(x, alpha = -1000, b = 50)

par(mfrow = c(1, 3))
plot(y1 ~ x, type = "l", main = expression(alpha %-&gt;% 0))
plot(y2 ~ x, type = "l", main = expression(alpha %~~% range(x)/10))
plot(y3 ~ x, type = "l", main = expression(alpha %-&gt;% infinity))
</code></pre>

<hr>
<h2 id='plotResponse'>Visualise the response of the virtual species to environmental variables</h2><span id='topic+plotResponse'></span>

<h3>Description</h3>

<p>This function plots the relationships between the virtual species and the environmental variables.
It requires either the output from <code><a href="#topic+generateSpFromFun">generateSpFromFun</a></code>, <code><a href="#topic+generateSpFromPCA">generateSpFromPCA</a></code>, 
<code><a href="#topic+generateRandomSp">generateRandomSp</a></code>,
or a manually defined set of environmental variables and response functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotResponse(
  x,
  parameters = NULL,
  approach = NULL,
  rescale = NULL,
  axes.to.plot = NULL,
  no.plot.reset = FALSE,
  rescale.each.response = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotResponse_+3A_x">x</code></td>
<td>
<p>the output from <code><a href="#topic+generateSpFromFun">generateSpFromFun</a></code>, <code><a href="#topic+generateSpFromPCA">generateSpFromPCA</a></code>, 
<code><a href="#topic+generateRandomSp">generateRandomSp</a></code>, or
a raster layer/stack of environmental variables (see details for the latter).</p>
</td></tr>
<tr><td><code id="plotResponse_+3A_parameters">parameters</code></td>
<td>
<p>in case of manually defined response functions, a list 
containing the associated parameters. See details.</p>
</td></tr>
<tr><td><code id="plotResponse_+3A_approach">approach</code></td>
<td>
<p>in case of manually defined response functions, the chosen
approach: either <code>"response"</code> for a per-variable response approach, or
<code>"pca"</code> for a PCA approach.</p>
</td></tr>
<tr><td><code id="plotResponse_+3A_rescale">rescale</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>. If <code>TRUE</code>, individual response
plots are rescaled between 0 and 1.</p>
</td></tr>
<tr><td><code id="plotResponse_+3A_axes.to.plot">axes.to.plot</code></td>
<td>
<p>a vector of 2 values listing the two axes of the PCA to plot.
Only useful for a PCA species.</p>
</td></tr>
<tr><td><code id="plotResponse_+3A_no.plot.reset">no.plot.reset</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>. If <code>FALSE</code>, the plot window
will be reset to its initial state after the response has been plotted.</p>
</td></tr>
<tr><td><code id="plotResponse_+3A_rescale.each.response">rescale.each.response</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>. If <code>TRUE</code>, 
the individual responses to
each environmental variable are rescaled between 0 and 1.</p>
</td></tr>
<tr><td><code id="plotResponse_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>plot</code>. See 
<code><a href="graphics.html#topic+plot">plot</a></code> and <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you provide the output from <code><a href="#topic+generateSpFromFun">generateSpFromFun</a></code>, <code><a href="#topic+generateSpFromPCA">generateSpFromPCA</a></code> or
<code><a href="#topic+generateRandomSp">generateRandomSp</a></code>
then the function will automatically make the appropriate plots.
</p>
<p>Otherwise, you can provide a raster layer/stack of environmental variables to
<code>x</code> and a list of functions to <code>parameters</code> to perform the plot.
In that case, you have to specify the <code>approach</code>: <code>"reponse"</code> or
<code>"PCA"</code>:
</p>

<ul>
<li><p>if <code>approach = "response"</code>: Provide to <code>parameters</code> a 
<code>list</code> exactly as defined in <code><a href="#topic+generateSpFromFun">generateSpFromFun</a></code>:<br />
<code>list(
           var1 = list(fun = 'fun1', args = list(arg1 = ..., arg2 = ..., etc.)),
           var2 = list(fun = 'fun2', args = list(arg1 = ..., arg2 = ..., etc.)))</code><br />
</p>

</li>
<li><p>if <code>approach = "PCA"</code>: Provide to <code>parameters</code> a
<code>list</code> containing the following elements:
</p>

<ul>
<li><p><code>pca</code>: a <code>dudi.pca</code> object computed  with 
<code><a href="ade4.html#topic+dudi.pca">dudi.pca</a></code>
</p>
</li>
<li><p><code>means</code>: a vector containing two numeric values. Will be used to define
the means of the gaussian response functions to the axes of the PCA.
</p>
</li>
<li><p><code>sds</code> a vector containing two numeric values. Will be used to define
the standard deviations of the gaussian response functions to the axes of 
the PCA.</p>
</li></ul>


</li></ul>



<h3>Author(s)</h3>

<p>Boris Leroy <a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>
</p>
<p>with help from C. N. Meynard, C. Bellard &amp; F. Courchamp
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create an example stack with four environmental variables
a &lt;- matrix(rep(dnorm(1:100, 50, sd = 25)), 
            nrow = 100, ncol = 100, byrow = TRUE)
env &lt;- c(rast(a * dnorm(1:100, 50, sd = 25)),
         rast(a * 1:100),
         rast(a * logisticFun(1:100, alpha = 10, beta = 70)),
         rast(t(a)))
names(env) &lt;- c("var1", "var2", "var3", "var4")

# Per-variable response approach:
parameters &lt;- formatFunctions(var1 = c(fun = 'dnorm', mean = 0.00012,
                                       sd = 0.0001),
                              var2 = c(fun = 'linearFun', a = 1, b = 0),
                              var3 = c(fun = 'quadraticFun', a = -20, b = 0.2, 
                                       c = 0),
                              var4 = c(fun = 'logisticFun', alpha = -0.001, 
                                       beta = 0.002))
sp1 &lt;- generateSpFromFun(env, parameters, plot = TRUE)
plotResponse(sp1)

# PCA approach:
sp2 &lt;- generateSpFromPCA(env, plot = FALSE)
par(mfrow = c(1, 1))
plotResponse(sp2)

</code></pre>

<hr>
<h2 id='plotSuitabilityToProba'>Visualise the function that was used to transform environmental suitability into
probability of occurrence</h2><span id='topic+plotSuitabilityToProba'></span>

<h3>Description</h3>

<p>This function plots the relationships between the environmental suitability
and the probability of occurrence, which is used to generate the presence-
absence distribution. 
It requires the output from <code><a href="#topic+convertToPA">convertToPA</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSuitabilityToProba(sp, add = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSuitabilityToProba_+3A_sp">sp</code></td>
<td>
<p>the output from <code><a href="#topic+convertToPA">convertToPA</a></code>.</p>
</td></tr>
<tr><td><code id="plotSuitabilityToProba_+3A_add">add</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>. If <code>TRUE</code>, the relationship
will be added to the currently active graph.</p>
</td></tr>
<tr><td><code id="plotSuitabilityToProba_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>plot</code>. See 
<code><a href="graphics.html#topic+plot">plot</a></code> and <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Boris Leroy <a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create an example stack with two environmental variables
a &lt;- matrix(rep(dnorm(1:100, 50, sd = 25)), 
            nrow = 100, ncol = 100, byrow = TRUE)
env &lt;- c(rast(a * dnorm(1:100, 50, sd = 25)),
         rast(a * 1:100))
names(env) &lt;- c("variable1", "variable2")

parameters &lt;- formatFunctions(variable1 = c(fun = 'dnorm', mean = 1e-04, 
                                             sd = 1e-04),
                              variable2 = c(fun = 'linearFun', a = 1, b = 0))
# Generation of the virtual species
sp1 &lt;- generateSpFromFun(env, parameters)
sp1


# Converting to presence-absence, probablistic method, logistic conversion
# A species with a low prevalence:

sp1.lowprev &lt;- convertToPA(sp1, species.prevalence = 0.1)
plotSuitabilityToProba(sp1.lowprev)

# A species with a high prevalence:

sp1.highprev &lt;- convertToPA(sp1, species.prevalence = 0.9)
plotSuitabilityToProba(sp1.lowprev)

# Converting to presence-absence, probablistic method, linear conversion
# A species with a low prevalence:

sp1.lowprev &lt;- convertToPA(sp1, species.prevalence = 0.1,
                           prob.method = "linear")
plotSuitabilityToProba(sp1.highprev)

# A species with a high prevalence:

sp1.highprev &lt;- convertToPA(sp1, species.prevalence = 0.9,
                           prob.method = "linear")
plotSuitabilityToProba(sp1.highprev)

</code></pre>

<hr>
<h2 id='quadraticFun'>Quadratic function</h2><span id='topic+quadraticFun'></span>

<h3>Description</h3>

<p>A simple quadratic function of the form
</p>
<p style="text-align: center;"><code class="reqn">ax^2+bx+c</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>quadraticFun(x, a, b, c)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quadraticFun_+3A_x">x</code></td>
<td>
<p>a numeric value or vector</p>
</td></tr>
<tr><td><code id="quadraticFun_+3A_a">a</code></td>
<td>
<p>a numeric value or vector</p>
</td></tr>
<tr><td><code id="quadraticFun_+3A_b">b</code></td>
<td>
<p>a numeric value or vector</p>
</td></tr>
<tr><td><code id="quadraticFun_+3A_c">c</code></td>
<td>
<p>a numeric value or vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value or vector resulting from the function
</p>


<h3>Author(s)</h3>

<p>Boris Leroy <a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>
</p>
<p>Maintainer: Boris Leroy <a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linearFun">linearFun</a></code>, <code><a href="#topic+quadraticFun">quadraticFun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:100
y &lt;- quadraticFun(x, a = 2, b = 2, c = 3)
plot(y ~ x, type = "l")
</code></pre>

<hr>
<h2 id='removeCollinearity'>Remove collinearity among variables of a raster stack</h2><span id='topic+removeCollinearity'></span>

<h3>Description</h3>

<p>This functions analyses the correlation among variables of the provided
stack of environmental variables (using Pearson's R), and can return a 
vector containing names of variables that are not colinear, or a list
containing grouping variables according to their degree of collinearity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeCollinearity(
  raster.stack,
  multicollinearity.cutoff = 0.7,
  select.variables = FALSE,
  sample.points = FALSE,
  nb.points = 10000,
  plot = FALSE,
  method = "pearson"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="removeCollinearity_+3A_raster.stack">raster.stack</code></td>
<td>
<p>a SpatRaster object, in which each layer represent an
environmental 
variable.</p>
</td></tr>
<tr><td><code id="removeCollinearity_+3A_multicollinearity.cutoff">multicollinearity.cutoff</code></td>
<td>
<p>a numeric value corresponding to the cutoff
of correlation above which to group variables.</p>
</td></tr>
<tr><td><code id="removeCollinearity_+3A_select.variables">select.variables</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>. If <code>TRUE</code>, then the
function will choose one variable among each group to return a vector of
non correlated variables (see details). If <code>FALSE</code>, the function will 
return a list
containing the groups of correlated variables.</p>
</td></tr>
<tr><td><code id="removeCollinearity_+3A_sample.points">sample.points</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>. If you have a large
raster file then use this parameter to sample a number of points equal to
<code>nb.points</code>.</p>
</td></tr>
<tr><td><code id="removeCollinearity_+3A_nb.points">nb.points</code></td>
<td>
<p>a numeric value. Only useful if <code>sample.points = TRUE</code>.
The number of sampled points from the raster, to perform the PCA. A too small
value may not be representative of the environmental conditions in your 
raster.</p>
</td></tr>
<tr><td><code id="removeCollinearity_+3A_plot">plot</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>. If <code>TRUE</code>, the hierarchical
ascendant classification used to group variables will be plotted.</p>
</td></tr>
<tr><td><code id="removeCollinearity_+3A_method">method</code></td>
<td>
<p><code>"pearson"</code>, <code>"spearman"</code> or <code>"kendall"</code>.
The correlation method to be used. If your variables are skewed or have 
outliers (e.g. when working with precipitation variables) you should favour
the Spearman or Kendall methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the Pearson's correlation coefficient to analyse 
correlation among variables. This coefficient is then used to compute a
distance matrix, which in turn is used it compute an ascendant hierarchical
classification, with the '<em>complete</em>' method (see 
<code><a href="stats.html#topic+hclust">hclust</a></code>). If at least one correlation above the <code>
multicollinearity.cutoff</code> is detected, then the variables will be grouped
according to their degree of correlation. 
</p>
<p>If <code>select.variables = TRUE</code>, then the function will return a vector
containing variables that are not colinear.
The variables not correlated to any other variables are automatically 
included
in this vector. For each group of colinear variables, one variable will
be randomly chosen and included in this vector.
</p>


<h3>Value</h3>

<p>a vector of non correlated variables, or a list where each element is a
group of non correlated variables.
</p>


<h3>Author(s)</h3>

<p>Boris Leroy <a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>
</p>
<p>with help from C. N. Meynard, C. Bellard &amp; F. Courchamp
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create an example stack with six environmental variables
a &lt;- matrix(rep(dnorm(1:100, 50, sd = 25)), 
            nrow = 100, ncol = 100, byrow = TRUE)
env &lt;- c(rast(a * dnorm(1:100, 50, sd = 25)),
         rast(a * 1:100),
         rast(a * logisticFun(1:100, alpha = 10, beta = 70)),
         rast(t(a)),
         rast(exp(a)),
         rast(log(a)))
names(env) &lt;- paste("Var", 1:6, sep = "")   
   
# Defaults settings: cutoff at 0.7
removeCollinearity(env, plot = TRUE)

# Changing cutoff to 0.5
removeCollinearity(env, plot = TRUE, multicollinearity.cutoff = 0.5)

# Automatic selection of variables not intercorrelated
removeCollinearity(env, plot = TRUE, select.variables = TRUE)

# Assuming a very large raster file: selecting a subset of points
removeCollinearity(env, plot = TRUE, select.variables = TRUE,
                   sample.points = TRUE, nb.points = 5000)


</code></pre>

<hr>
<h2 id='sampleOccurrences'>Sample occurrences in a virtual species distribution</h2><span id='topic+sampleOccurrences'></span>

<h3>Description</h3>

<p>This function samples occurrences/records (presence only or presence-absence) 
within a species distribution, either randomly or with a sampling bias. 
The sampling bias can be defined manually or with a set of predefined 
biases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleOccurrences(
  x,
  n,
  type = "presence only",
  extract.probability = FALSE,
  sampling.area = NULL,
  detection.probability = 1,
  correct.by.suitability = FALSE,
  error.probability = 0,
  bias = "no.bias",
  bias.strength = 50,
  bias.area = NULL,
  weights = NULL,
  sample.prevalence = NULL,
  replacement = FALSE,
  plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampleOccurrences_+3A_x">x</code></td>
<td>
<p>a <code>SpatRaster</code> object or the output list from 
<code>generateSpFromFun</code>, <code>generateSpFromPCA</code>, <code>generateRandomSp</code>,
<code>convertToPA</code>
or  <code>limitDistribution</code>
The raster must contain values of 0 or 1 (or NA).</p>
</td></tr>
<tr><td><code id="sampleOccurrences_+3A_n">n</code></td>
<td>
<p>an integer. The number of occurrence points / records to sample.</p>
</td></tr>
<tr><td><code id="sampleOccurrences_+3A_type">type</code></td>
<td>
<p><code>"presence only"</code> or <code>"presence-absence"</code>. The type of 
occurrence points to sample.</p>
</td></tr>
<tr><td><code id="sampleOccurrences_+3A_extract.probability">extract.probability</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>. If <code>TRUE</code>, then
true probability at sampled locations will also be extracted</p>
</td></tr>
<tr><td><code id="sampleOccurrences_+3A_sampling.area">sampling.area</code></td>
<td>
<p>a character string, a <code>polygon</code> or an <code>extent</code>
object.
The area in which the sampling will take place. See details.</p>
</td></tr>
<tr><td><code id="sampleOccurrences_+3A_detection.probability">detection.probability</code></td>
<td>
<p>a numeric value between 0 and 1, corresponding 
to the probability of detection of the species. See details.</p>
</td></tr>
<tr><td><code id="sampleOccurrences_+3A_correct.by.suitability">correct.by.suitability</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>. If <code>TRUE</code>, 
then the probability of detection will be weighted by the suitability, such 
that cells with lower suitabilities will further decrease the chance that 
the species is detected when sampled. NOTE: this will NOT increase 
likelihood of samplings in areas of high suitability. In this case look for 
argument weights.</p>
</td></tr>
<tr><td><code id="sampleOccurrences_+3A_error.probability">error.probability</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>. Probability to 
attribute an erroneous presence (False Positive) in cells where the species 
is actually absent.</p>
</td></tr>
<tr><td><code id="sampleOccurrences_+3A_bias">bias</code></td>
<td>
<p><code>"no.bias"</code>,  <code>"country"</code>,  <code>"region"</code>,
<code>"extent"</code>,  <code>"polygon"</code> or <code>"manual"</code>. The method used to 
generate a sampling bias: see details.</p>
</td></tr>
<tr><td><code id="sampleOccurrences_+3A_bias.strength">bias.strength</code></td>
<td>
<p>a positive numeric value. The strength of the bias to be
applied in <code>area</code> (as a multiplier). Above 1, <code>area</code> will be 
oversampled. Below 1, <code>area</code> will be undersampled.</p>
</td></tr>
<tr><td><code id="sampleOccurrences_+3A_bias.area">bias.area</code></td>
<td>
<p><code>NULL</code>, a character string, a <code>polygon</code> or an 
<code>extent</code> object. The area in which the sampling will be biased: see
details. If <code>NULL</code> and <code>bias = "extent"</code>, then you will be asked to
draw an extent on the map.</p>
</td></tr>
<tr><td><code id="sampleOccurrences_+3A_weights">weights</code></td>
<td>
<p><code>NULL</code> or a raster layer. Only used if 
<code>bias = "manual"</code>. The raster of bias weights to be applied to the 
sampling of occurrences. Higher weights mean a higher probability of 
sampling. For example, species suitability raster can be entered here to
increase likelihood of sampling occurrences in areas with high suitability.</p>
</td></tr>
<tr><td><code id="sampleOccurrences_+3A_sample.prevalence">sample.prevalence</code></td>
<td>
<p><code>NULL</code> or a numeric value between 0 and 1. 
Only useful if <code>type = "presence-absence"</code>. Defines the sample
prevalence, i.e. the proportion of presences sampled. Note that the
probabilities of detection and error are applied AFTER this parameter,
so the final sample prevalence may not different if you apply probabilities
of detection and/or error</p>
</td></tr>
<tr><td><code id="sampleOccurrences_+3A_replacement">replacement</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>. If <code>TRUE</code>, multiple
samples can occur in the same cell. Can be useful to mimic real datasets 
where samplings can be duplicated or repeated in time.</p>
</td></tr>
<tr><td><code id="sampleOccurrences_+3A_plot">plot</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>. If <code>TRUE</code>, the sampled 
occurrence points will be plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><a href="http://borisleroy.com/virtualspecies_tutorial/07-sampleoccurrences.html">
Online tutorial for this function</a>
</p>
<p><b>How the function works:</b>
</p>
<p>The function randomly selects <code>n</code> cells in which samples occur. If a 
<code>bias</code> is chosen, then the selection of these cells will be biased 
according to the type and strength of bias chosen. If the sampling is of 
<code>type "presence only"</code>, then only cells where the species is present 
will be chosen. If the sampling is of <code>type "presence-absence"</code>, then 
all non-NA cells can be chosen.
</p>
<p>The function then samples the species inside the chosen cells. In cells 
where the species is present the species will always be sampled unless 
the parameter <code>detection.probability</code> is lower than 1. In that case the
species will be sampled with the associated probability of detection.
</p>
<p>In cells where the species is absent (in case of a <code>"presence-absence"</code>
sampling), the function will always assign absence unless 
<code>error.probability</code> is greater than 1. In that case, the species can be
found present with the associated probability of error. Note that this step 
happens AFTER the detection step. Hence, in cells where the species is
present but not detected, it can still be sampled due to a sampling error.
</p>
<p><b>How to restrict the sampling area:</b>
</p>
<p>Use the argument <code>sampling.area</code>:
</p>

<ul>
<li><p>Provide the name (s) (or a combination of names) of country(ies), 
region(s) or continent(s).
Examples:
</p>

<ul>
<li><p><code>sampling.area = "Africa"</code>
</p>
</li>
<li><p><code>sampling.area = c("Africa", "North America", "France")</code>
</p>
</li></ul>

</li>
<li><p>Provide a polygon (<code>SpatialPolygons</code> or 
<code>SpatialPolygonsDataFrame</code> of package <code>sp</code>)
</p>
</li>
<li><p>Provide an <code>extent</code> object
</p>
</li></ul>

<p><b>How the sampling bias works:</b>
</p>
<p>The argument <code>bias.strength</code> indicates the strength of the bias.
For example, a value of 50 will result in 50 times more samples within the
<code>bias.area</code> than outside.
Conversely, a value of 0.5 will result in half less samples within the
<code>bias.area</code> than outside.
</p>
<p><b>How to choose where the sampling is biased:</b>
</p>
<p>You can choose to bias the sampling in:
</p>

<ol>
<li><p>a particular country, region or continent (assuming your raster has
the WGS84 projection): 
</p>
<p>Set the argument
<code>bias</code> to <code>"country"</code>, <code>"region"</code> or
<code>"continent"</code>, and provide the name(s) of the associated countries,
regions or continents to <code>bias.area</code> (see examples). 
</p>
<p>List of possible <code>bias.area</code> names:
</p>

<ul>
<li><p>Countries: type 
<code>unique(rnaturalearth::ne_countries(returnclass ='sf')$sovereignt)</code> 
in the console
</p>
</li>
<li><p>Regions: &quot;Africa&quot;, &quot;Antarctica&quot;, &quot;Asia&quot;, &quot;Oceania&quot;, &quot;Europe&quot;, 
&quot;Americas&quot;
</p>
</li>
<li><p>Continents: &quot;Africa&quot;, &quot;Antarctica&quot;, &quot;Asia&quot;, &quot;Europe&quot;, 
&quot;North America&quot;, &quot;Oceania&quot;, &quot;South America&quot;</p>
</li></ul>


</li>
<li><p>a polygon:
</p>
<p>Set <code>bias</code> to <code>"polygon"</code>, and provide your
polygon to <code>area</code>.

</p>
</li>
<li><p>an extent object:
</p>
<p>Set <code>bias</code> to <code>"extent"</code>, and either provide your
extent object to <code>bias.area</code>, or leave it <code>NULL</code> to draw an extent 
on the map.
</p>
</li></ol>
 
<p>Otherwise you can enter a raster of sampling probability. It can be useful 
if you want to increase likelihood of samplings in areas of high 
suitability (simply enter the suitability raster in weights; see examples
below),
or if you want to define sampling biases manually, <em>e.g.</em> to to create
biases along roads. In that case you have to provide to <code>weights</code> a 
raster layer in which each cell contains the probability to be sampled.
</p>
<p>The <code><a href="base.html#topic+.Random.seed">.Random.seed</a></code> and <code><a href="base.html#topic+RNGkind">RNGkind</a></code> are stored as 
<code><a href="base.html#topic+attributes">attributes</a></code> when the function is called, and can be used to 
reproduce the results as shown in the examples (though
it is preferable to set the seed with <code><a href="base.html#topic+set.seed">set.seed</a></code> before calling
<code>sampleOccurrences()</code> and to then use the same value in 
<code><a href="base.html#topic+set.seed">set.seed</a></code> to reproduce results later. Note that 
reproducing the sampling will only work if the same original distribution map 
is used.
</p>


<h3>Value</h3>

<p>a <code>list</code> with 8 elements:
</p>

<ul>
<li><p><code>type</code>: type of occurrence sampled (presence-absences or 
presence-only)
</p>
</li>
<li><p><code>sample.points</code>: data.frame containing the coordinates of 
samples, true and sampled observations (i.e, 1, 0 or NA), and, if asked, the true
environmental suitability in sampled locations
</p>
</li>
<li><p><code>detection.probability</code>: the chosen probability of detection of
the virtual species
</p>
</li>
<li><p><code>error.probability</code>: the chosen probability to assign presence
in cells where the species is absent
</p>
</li>
<li><p><code>bias</code>: if a bias was chosen, then the type of bias and the
associated <code>area</code> will be included.
</p>
</li>
<li><p><code>replacement</code>: indicates whether multiple samples could occur
in the same cells
</p>
</li>
<li><p><code>original.distribution.raster</code>: the distribution raster from
which samples were drawn
</p>
</li>
<li><p><code>sample.plot</code>: a recorded plot showing the sampled points 
overlaying the original distribution.
</p>
</li></ul>



<h3>Note</h3>

<p>Setting <code>sample.prevalence</code> may at least partly
override <code>bias</code>, e.g. if <code>bias</code> is specified with <code>extent</code> to 
an area that contains no presences, but sample prevalence is set to &gt; 0, 
then cells outside of the biased sampling extent will be sampled until 
the number of presences required by <code>sample.prevalence</code> are obtained, 
after which the sampling of absences will proceed according to the specified
bias.
</p>


<h3>Author(s)</h3>

<p>Boris Leroy <a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>
Willson Gaul <a href="mailto:wgaul@hotmail.com">wgaul@hotmail.com</a>
</p>
<p>with help from C. N. Meynard, C. Bellard &amp; F. Courchamp
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create an example stack with six environmental variables
a &lt;- matrix(rep(dnorm(1:100, 50, sd = 25)), 
            nrow = 100, ncol = 100, byrow = TRUE)
env &lt;- c(rast(a * dnorm(1:100, 50, sd = 25)),
         rast(a * 1:100),
         rast(a * logisticFun(1:100, alpha = 10, beta = 70)),
         rast(t(a)),
         rast(exp(a)),
         rast(log(a)))
names(env) &lt;- paste("Var", 1:6, sep = "")   

# More than 6 variables: by default a PCA approach will be used
sp &lt;- generateRandomSp(env, niche.breadth = "wide")

# Sampling of 25 presences
sampleOccurrences(sp, n = 25)

# Sampling of 30 presences and absences
sampleOccurrences(sp, n = 30, type = "presence-absence")


# Reducing of the probability of detection
sampleOccurrences(sp, n = 30, type = "presence-absence", 
                  detection.probability = 0.5)
                  
# Further reducing in relation to environmental suitability
sampleOccurrences(sp, n = 30, type = "presence-absence", 
                  detection.probability = 0.5,
                  correct.by.suitability = TRUE)
                  
                  
# Creating sampling errors (far too much)
sampleOccurrences(sp, n = 30, type = "presence-absence", 
                  error.probability = 0.5)
                  
# Introducing a sampling bias (oversampling)
biased.area &lt;- ext(1, 50, 1, 50)
sampleOccurrences(sp, n = 50, type = "presence-absence", 
                  bias = "extent",
                  bias.area = biased.area)
# Showing the area in which the sampling is biased
plot(biased.area, add = TRUE)     

# Introducing a sampling bias (no sampling at all in the chosen area)
biased.area &lt;- ext(1, 50, 1, 50)
sampleOccurrences(sp, n = 50, type = "presence-absence", 
                  bias = "extent",
                  bias.strength = 0,
                  bias.area = biased.area)
# Showing the area in which the sampling is biased
plot(biased.area, add = TRUE)    
samps &lt;- sampleOccurrences(sp, n = 50, 
                           bias = "manual",
                           weights = sp$suitab.raster)
plot(sp$suitab.raster)
points(samps$sample.points[, c("x", "y")])

# Create a sampling bias so that more presences are sampled in areas with 
# higher suitability

  
    

# Reproduce sampling based on the saved .Random.seed from a previous result
samps &lt;- sampleOccurrences(sp, n = 100, 
                           type = "presence-absence", 
                           detection.probability = 0.7, 
                           bias = "extent", 
                           bias.strength = 50, 
                           bias.area = biased.area)
# Reset the random seed using the value saved in the attributes               
.Random.seed &lt;- attr(samps, "seed") 
reproduced_samps &lt;- sampleOccurrences(sp, n = 100, 
                                      type = "presence-absence",
                                      detection.probability = 0.7,
                                      bias = "extent",
                                      bias.strength = 50,
                                      bias.area = biased.area)
identical(samps$sample.points, reproduced_samps$sample.points)          
</code></pre>

<hr>
<h2 id='synchroniseNA'>Synchronise NA values among layers of a stack</h2><span id='topic+synchroniseNA'></span>

<h3>Description</h3>

<p>This function ensures that cells containing NAs are the same among all the
layers of a raster stack, i.e.that for any given pixel of the stack, if one layer has a NA, then 
all layers should be set to NA for that pixel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>synchroniseNA(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="synchroniseNA_+3A_x">x</code></td>
<td>
<p>a raster stack object which needs to be synchronised.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can do that in two different ways; if your computer has enough RAM a fast way will be
used; otherwise a slower but memory-safe way will be used.
</p>


<h3>Author(s)</h3>

<p>Boris Leroy <a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>
</p>
<p>with help from C. N. Meynard, C. Bellard &amp; F. Courchamp
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creation of a stack with different NAs across layers
m &lt;- matrix(nr = 10, nc = 10, 1:100)
r1 &lt;- rast(m)
r2 &lt;- rast(m)
r1[sample(1:ncell(r1), 20)] &lt;- NA
r2[sample(1:ncell(r2), 20)] &lt;- NA
s &lt;- c(r1, r2)


# Effect of the synchroniseNA() function
plot(s) # Not yet synchronised
s &lt;- synchroniseNA(s)
plot(s) # Synchronised

</code></pre>

<hr>
<h2 id='virtualspecies-package'>Generation of virtual species</h2><span id='topic+virtualspecies-package'></span>

<h3>Description</h3>

<p>This package allows generating virtual species distributions, for example
for testing species distribution modelling protocols. 
For a complete tutorial, 
see borisleroy.com/virtualspecies
</p>


<h3>Details</h3>

<p>The process of generating a virtual species distribution is divided into 
four major steps.
</p>

<ol>
<li><p>Generate a virtual species distributions from environmental variables.
This can be done by 
</p>

<ul>
<li><p>defining partial response functions to each environmental 
variable, and then combining them to compute the overall environmental 
suitability,
with <code><a href="#topic+generateSpFromFun">generateSpFromFun</a></code>
</p>
</li>
<li><p>computing a PCA among
environmental variables, and simulating the response of the species along 
the two first axes of the PCA with <code><a href="#topic+generateSpFromPCA">generateSpFromPCA</a></code></p>
</li></ul>

<p>This step can be randomised with <code><a href="#topic+generateRandomSp">generateRandomSp</a></code>

</p>
</li>
<li><p>Convert the virtual species distribution into presence-absence, with
<code><a href="#topic+convertToPA">convertToPA</a></code>
</p>
</li>
<li><p>Facultatively, introduce a distribution bias with 
<code><a href="#topic+limitDistribution">limitDistribution</a></code>
</p>
</li>
<li><p>Sample occurrence points (presence only or presence-absence) inside the
virtual species distribution, either randomly or with biases, with 
<code><a href="#topic+sampleOccurrences">sampleOccurrences</a></code>
</p>
</li></ol>

<p>There are other useful functions in the package:
</p>

<ul>
<li><p><code><a href="#topic+formatFunctions">formatFunctions</a></code>: this is a helper function to format and 
illustrate the response functions as a correct input for 
<code><a href="#topic+generateSpFromFun">generateSpFromFun</a></code>
</p>
</li>
<li><p><code><a href="#topic+plotResponse">plotResponse</a></code>: to visualise the species-environment 
relationship
of the virtual species
</p>
</li>
<li><p><code><a href="#topic+removeCollinearity">removeCollinearity</a></code>: this function can be used to remove
collinearity among variables of a stack by selecting a subset of 
non-colinear variables
</p>
</li>
<li><p><code><a href="#topic+synchroniseNA">synchroniseNA</a></code>: this function can be used to synchronise
NA values among layers of a stack
</p>
</li></ul>

<p>This packages makes use of different other packages:
</p>

<ul>
<li><p>This package makes extensive use of the package <code>terra</code> 
to obtain spatialised
environmental variables, and produce spatialised virtual 
species distributions.
</p>
</li>
<li><p><code>ade4</code> is used to generate species with a PCA approach.
</p>
</li>
<li><p><code><a href="rnaturalearth.html#topic+rnaturalearth">rnaturalearth</a></code> is used to obtain free world shapefiles, 
in order to create
dispersal limitations and sampling biases.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Boris Leroy <a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>
</p>
<p>with help from C. N. Meynard, C. Bellard &amp; F. Courchamp
</p>
<p>Maintainer: Boris Leroy <a href="mailto:leroy.boris@gmail.com">leroy.boris@gmail.com</a>
</p>


<h3>References</h3>

<p>Leroy, B. et al. 2016. virtualspecies, an R package to generate virtual 
species distributions. Ecography. 39(6):599-607
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
