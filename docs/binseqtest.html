<!DOCTYPE html><html><head><title>Help for package binseqtest</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {binseqtest}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#analyze'>
<p>Methods for calculating estimates, confidence intervals, and p-values from binary sequential boundaries</p></a></li>
<li><a href='#analyze-methods'><p>Calculate estimates, confidence intervals and p-values from binary sequential boundary</p></a></li>
<li><a href='#binseqtest-internal'><p>Internal functions</p></a></li>
<li><a href='#binseqtest-package'><p>Binary sequential tests</p></a></li>
<li><a href='#bound-class'><p>Classes for binary sequential boundaries</p></a></li>
<li><a href='#designOBF'>
<p>Design Sequential Binary Boundary</p></a></li>
<li><a href='#EN'>
<p>Expected sample size for boundary.</p></a></li>
<li><a href='#getTSalpha'>
<p>Two-sided alpha, alternative, and confidence level</p></a></li>
<li><a href='#modify'>
<p>Modify binary sequential boundary</p></a></li>
<li><a href='#plot-methods'><p>Methods for Function <code>plot</code> and <code>points</code> in Package <span class="pkg">binseqtest</span></p></a></li>
<li><a href='#powerBsb'>
<p>Power for binary sequential boundary</p></a></li>
<li><a href='#prStop'>
<p>Probabilty of Stopping</p></a></li>
<li><a href='#stopTable'>
<p>Create data frame with statistics for stopping boundary</p></a></li>
<li><a href='#summary-methods'><p>Methods for Function <code>summary</code> in Package <span class="pkg">binseqtest</span></p></a></li>
<li><a href='#unirootDiscrete'><p>Identify where a non-increasing function changes sign</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Exact Binary Sequential Designs and Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-24</td>
</tr>
<tr>
<td>Author:</td>
<td>Jenn Kirk, Michael P. Fay</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael P. Fay &lt;mfay@niaid.nih.gov&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>For a series of binary responses, create stopping boundary with exact results after stopping, allowing updating for missing assessments.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>methods, graphics, stats, clinfun</td>
</tr>
<tr>
<td>Collate:</td>
<td>'allFuncs.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-24 14:51:41 UTC; faym</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-24 15:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='analyze'>
Methods for calculating estimates, confidence intervals, and p-values from binary sequential boundaries
</h2><span id='topic+analyzeBoundNBF'></span><span id='topic+analyzeBound'></span><span id='topic+analyze'></span>

<h3>Description</h3>

<p>For routine use, these functions will not need to be called directly but are called from within the design functions (see <code><a href="#topic+designOBF">designOBF</a></code>). If needed, use <code>analyze</code> for any class representing a binary sequential boundary (see <code><a href="#topic+bound-class">bound-class</a></code>),
and the appropriate function is called.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyzeBound(object, theta0 = 0.5, stats = "all", 
    alternative = "two.sided", conf.level = 0.95, 
    tsalpha = NULL, ...)
analyzeBoundNBF(object, theta0 = 0.5, stats = "all", 
    alternative = "two.sided", conf.level = 0.95, 
    tsalpha = NULL, cipMatch = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analyze_+3A_object">object</code></td>
<td>
<p>a binary sequential boundary (for classes see <code><a href="#topic+bound-class">bound-class</a></code>)</p>
</td></tr>
<tr><td><code id="analyze_+3A_theta0">theta0</code></td>
<td>
<p>probability of success under the null</p>
</td></tr>
<tr><td><code id="analyze_+3A_stats">stats</code></td>
<td>
<p>character, either 'all' or 'pval'</p>
</td></tr>
<tr><td><code id="analyze_+3A_tsalpha">tsalpha</code></td>
<td>
<p>vector of length 2, error on either side, if present overrides alternative and conf.level (see details)</p>
</td></tr>
<tr><td><code id="analyze_+3A_alternative">alternative</code></td>
<td>
<p>character, either 'two.sided', 'less', or 'greater'</p>
</td></tr>
<tr><td><code id="analyze_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level</p>
</td></tr>
<tr><td><code id="analyze_+3A_cipmatch">cipMatch</code></td>
<td>
<p>logical, for non-binding futility boundaries, should CI match the p-values on the binding boundary</p>
</td></tr>
<tr><td><code id="analyze_+3A_...">...</code></td>
<td>
<p>further arguments to be passed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if stats='all' returns an object of class 'boundEst', otherwise returns a numeric vector of p-values</p>


<h3>See Also</h3>

<p>See  <code><a href="#topic+analyze-methods">analyze-methods</a></code>
</p>

<hr>
<h2 id='analyze-methods'>Calculate estimates, confidence intervals and p-values from binary sequential boundary</h2><span id='topic+analyze-methods'></span><span id='topic+analyze+2Cabparms-method'></span><span id='topic+analyze+2CANY-method'></span><span id='topic+analyze+2Cbound-method'></span><span id='topic+analyze+2CboundNBF-method'></span>

<h3>Description</h3>

<p>The method <code>analyze</code> calculates the estimate, confidence interval and p-values (both one-sided ones and the two-sided one)
from a binary sequential boundary. The methods works on any of the classes that represent those boundaries (see <code><a href="#topic+bound-class">bound-class</a></code>).
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "ANY")</code></dt><dd>
<p>Generic function: see <code><a href="#topic+analyze">analyze</a></code>
</p>
</dd>
<dt><code>signature(object = "abparms")</code></dt><dd>
<p>Calculate estimates, confidence intervals and p-values from 'abparms' object.
</p>
</dd>
<dt><code>signature(object = "bound")</code></dt><dd>
<p>Calculate estimates, confidence intervals and p-values from 'bound' object.
</p>
</dd>
<dt><code>signature(object = "boundNBF")</code></dt><dd>
<p>Calculate estimates, confidence intervals and p-values from 'boundNBF' object.
</p>
</dd>
</dl>

<hr>
<h2 id='binseqtest-internal'>Internal functions</h2><span id='topic+binseqtest-internal'></span><span id='topic+validAbparms'></span><span id='topic+validBound'></span><span id='topic+validBoundNBF'></span><span id='topic+validBoundEst'></span><span id='topic+abCalcK'></span><span id='topic+abtoBound'></span><span id='topic+ciCalc'></span><span id='topic+pCalc'></span><span id='topic+abBindBothCalcK'></span><span id='topic+missNAbparms'></span>

<h3>Description</h3>

<p>Internal functions, not to be called by user</p>


<h3>Usage</h3>

<pre><code class='language-R'>
validAbparms(object)
validBound(object)
validBoundEst(object)
validBoundNBF(object)

abBindBothCalcK(object)
abtoBound(from)

pCalc(S,N,K,order,theta0=.5,alternative="two.sided",ponly=FALSE)
ciCalc(S,N,K,order,type="upper",alpha=0.025)

missNAbparms(ab,missN=NULL,...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binseqtest-internal_+3A_object">object</code></td>
<td>
<p>object, usually a boundary of some class</p>
</td></tr>
<tr><td><code id="binseqtest-internal_+3A_from">from</code></td>
<td>
<p>an object of class abparms</p>
</td></tr>
<tr><td><code id="binseqtest-internal_+3A_s">S</code></td>
<td>
<p>vector of number of successes</p>
</td></tr>
<tr><td><code id="binseqtest-internal_+3A_n">N</code></td>
<td>
<p>vector of number of trials</p>
</td></tr>
<tr><td><code id="binseqtest-internal_+3A_k">K</code></td>
<td>
<p>vector of number of ways to reach each bounary point</p>
</td></tr>
<tr><td><code id="binseqtest-internal_+3A_order">order</code></td>
<td>
<p>vector of ordering of boundary points</p>
</td></tr>
<tr><td><code id="binseqtest-internal_+3A_theta0">theta0</code></td>
<td>
<p>null value of probability of success each binary random variable</p>
</td></tr>
<tr><td><code id="binseqtest-internal_+3A_alternative">alternative</code></td>
<td>
<p>character, either 'two.sided', 'less', or 'greater'</p>
</td></tr>
<tr><td><code id="binseqtest-internal_+3A_ponly">ponly</code></td>
<td>
<p>logical, should only the specific p-value type given by alternative be calculated</p>
</td></tr>
<tr><td><code id="binseqtest-internal_+3A_type">type</code></td>
<td>
<p>character, type of one-sided confidence interval to calculate, either 'upper' or 'lower'</p>
</td></tr>
<tr><td><code id="binseqtest-internal_+3A_alpha">alpha</code></td>
<td>
<p>numeric, amount of error to allow on the one side of the confidence interval</p>
</td></tr>




<tr><td><code id="binseqtest-internal_+3A_ab">ab</code></td>
<td>
<p>object of class 'abparms'</p>
</td></tr>
<tr><td><code id="binseqtest-internal_+3A_missn">missN</code></td>
<td>
<p>numeric vector, the N values where  assessments are missed</p>
</td></tr>
<tr><td><code id="binseqtest-internal_+3A_...">...</code></td>
<td>
<p>arguments passed to other functions, not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The validXX functions check that the object is a valid member of the class XX. For example, validBound checks that a bound object 
is OK by sum the probability distribution using the N,S, and K values and checking that it is within computer error of 1.  
The validity checks are run automatically by the new() function as part of the S4 implementation.
</p>
<p>The function <code>abBindBothCalcK</code> takes an abparms object and creates a bound object. It requires calculating K, which is the number of ways 
to reach each boundary point. It ignores the <code>binding</code> argument and assumes all boundaries are binding. The <code>abtoBound</code> function
uses the <code>binding</code> argument to create either a <code>bound</code> object (for <code>binding</code>='both') or a <code>boundNBF</code> object otherwise. 
Users can use the <code>as</code> function to coerce an <code>abparms</code> object to a <code>bound</code> object.  
</p>
<p>The function <code>pCalc</code> takes a boundary and calculates p-values, and outputs a vector of p-values (ponly=TRUE) or  list of 3 vectors (plower,pupper, pval). 
</p>
<p>The function <code>cCalc</code> takes a boundary and calculates one of the one sided confidence intervals as directed by the type argument (either 'upper' or 'lower'). 
</p>
<p>The functions <code>analyzeBound</code> and <code>analyzeBoundNBF</code> take objects of the 
<code>bound</code> and <code>boundNBF</code> classes and create ones of the <code>boundEst</code> and
<code>boundNBFEst</code> classes. This means basically that the confidence intervals and p-values 
are calculated that go with those bounds. 
</p>
<p>The functions <code>getAlternative</code> and <code>getTSalpha</code> get those parameters from the inputs. 
</p>
<p>The function <code>missNAbparms</code> modifies abparms objects to reflect missing assessments. This is the working function for the missN option in <code>modify</code>. 
</p>

<hr>
<h2 id='binseqtest-package'>Binary sequential tests</h2><span id='topic+binseqtest'></span><span id='topic+binseqtest-package'></span>

<h3>Description</h3>

<p>Design and analyze binary sequential tests
</p>


<h3>Details</h3>

<p>The package creates designs for testing a series of
binary responses sequentially. It allows checking after
every response, or grouped sequential tests. Gives exact
confidence intervals and p-values. Has an option for
non-binding futility boundaries.
</p>
<p>There are functions for creating the binary sequential boundaries or binary grouped sequential boundaries  (see <code><a href="#topic+designOBF">designOBF</a></code>), 
creating tables of statistics (estimates, confidence intervals, and p-values) at 
specific stopping points in the boundary (see <code>link{stopTable}</code>), modifying the boundaries (see <code><a href="#topic+modify">modify</a></code>), 
and plotting the boundaries (<code><a href="#topic+plot-methods">plot-methods</a></code>).
</p>
<p>For details see Kirk and Fay (2014).
</p>


<h3>Author(s)</h3>

<p>Jenn Kirk, Michael P. Fay
</p>


<h3>References</h3>

<p>Kirk, JL, and Fay, MP (2014). An Introduction to Practical Sequential Inferences via Single Arm Binary Response Studies Using the binseqtest R Package. (to appear in American Statistician).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create an O'Brien-Fleming-type design, with 2.5 percent error on each side with max N of 50
B&lt;-designOBF(50)
# plot it
plot(B)
# create a table for N (total samples) values between 20 and 25
stopTable(B,Nrange=c(20,25))
# modify the boundary if you missed looks at N=30 through 35
Bmod&lt;-modify(B,missN=30:35)
plot(Bmod)
</code></pre>

<hr>
<h2 id='bound-class'>Classes for binary sequential boundaries</h2><span id='topic+abparms'></span><span id='topic+abparms-class'></span><span id='topic+bound'></span><span id='topic+bound-class'></span><span id='topic+boundNBF'></span><span id='topic+boundNBF-class'></span><span id='topic+boundEst'></span><span id='topic+boundEst-class'></span>

<h3>Description</h3>

<p>There are several classes that represent binary
sequential boundaries. The most simple is the abparms
class, then comes the bounds class (which contains
abparms), then comes boundNBF class (which contains bound
class), or boundEst class (which contains bounds class),
then comes boundNBFEst (which contains boundNBF).  See
details for which slots go with which classes.
</p>


<h3>Details</h3>

<p>The simplest representation of a binary sequential
boundary is the abparms class, represented by a vector of
the total number of trials (Nk) where to stop, and denoting
stopping when number of sucesses, S, is S&gt;=b or S&lt;= a.
One sided boundaries can be represented by all NA values
for either a or b. Often times a two-sided boundary
treats one side as a superiority boundary which must be
stopped if crossed (a binding boundary), while the other
side of the boundary is a futility boundary which may be
ignored (a non-binding boundary). For example when
binding='upper', then p-values for the upper boundary are
calculated as if the lower boundaries are ignored if
crossed and stopping happens on the lower side at max(Nk)
instead, while the p-values for the lower and end
boundary points are calculated using all (lower,upper and
end) boundaries. <br /> <br /> Next is the bound class which
adds the slots N (number of trials at each boundary
point), S (number of sucesses at each point), K (number
of ways to get to each point), order (ordering of points
for p-value calculations), UL('upper','lower' or 'end').
</p>


<h3>Slots</h3>

 
<dl>
<dt><code>Nk</code>:</dt><dd><p>vector of number of samples
at boundary stopping points</p>
</dd> 
<dt><code>a</code>:</dt><dd><p> vector for
lower bound, stop if S out of Nk is less than or equal a.
NA denotes do not stop.</p>
</dd> 
<dt><code>b</code>:</dt><dd><p>vector for
upper bound, stop if S out of Nk is greater than or equal
b. NA denotes do not stop.</p>
</dd>
<dt><code>binding</code>:</dt><dd><p>character specifying which
boundary section is binding, either 'both', 'upper', or
'lower'</p>
</dd> 
<dt><code>alternative</code>:</dt><dd><p>character specifying alternative, 'two.sided', 'less', or 'greater'</p>
</dd>
<dt><code>N</code>:</dt><dd><p>vector of number of samples at boundary stopping
points</p>
</dd>
<dt><code>S</code>:</dt><dd><p>vector of number of sucesses at boundary
stopping points</p>
</dd>
<dt><code>K</code>:</dt><dd><p>vector of number of ways to get to each boundary
point</p>
</dd>
<dt><code>order</code>:</dt><dd><p>vector of ordering of points</p>
</dd>
<dt><code>UL</code>:</dt><dd><p>character vector denoting part of boundary,
either 'lower' or 'upper' or 'end'</p>
</dd>
<dt><code>estimate</code>:</dt><dd><p>vector of estimates of theta, probability of success</p>
</dd>
<dt><code>lower</code>:</dt><dd><p>vector of lower confidence intervals for theta</p>
</dd>
<dt><code>upper</code>:</dt><dd><p>vector of upper confidence intervals for theta</p>
</dd>
<dt><code>conf.level</code>:</dt><dd><p>confidence level associated with confidence intervals</p>
</dd>
<dt><code>alpha</code>:</dt><dd><p>error on either side</p>
</dd>
<dt><code>theta0</code>:</dt><dd><p>null value for theta</p>
</dd>
<dt><code>plower</code>:</dt><dd><p>vector of lower p-values</p>
</dd>
<dt><code>pupper</code>:</dt><dd><p>vector of upper p-values</p>
</dd>
<dt><code>pval</code>:</dt><dd><p>vector of p-values as directed by alternative slot</p>
</dd>
</dl>



<h3>Methods</h3>

<p>There is a <code>plot</code> and a <code>points</code> method for <code>boundEst</code> objects. 
</p>


<h3>Author(s)</h3>

<p> Jenn Kirk, Michael P. Fay</p>


<h3>Examples</h3>

<pre><code class='language-R'>new("abparms",Nk=200)
</code></pre>

<hr>
<h2 id='designOBF'>
Design Sequential Binary Boundary
</h2><span id='topic+designOBF'></span><span id='topic+designOBFpower'></span><span id='topic+designAb'></span><span id='topic+designFixed'></span><span id='topic+designFixedpower'></span><span id='topic+designSimon'></span>

<h3>Description</h3>

<p>There are several functions that create binary sequential boundaries. The function <code>designAb</code> allows great flexibility in creating 
user defined boundaries. The functions <code>designOBF</code> and <code>designOBFpower</code> create boudaries of the O-Brien-Fleming type, extending those 
boundaries to allow looks after every observation. The former (<code>designOBF</code>) uses a user defined maximum number of observations (Nmax), while 
the latter  (<code>designOBFpower</code>) uses the power argument to try to find a design with a smaller maximum that achieves the desired power. 
The functions <code>designFixed</code> and <code>designFixedpower</code> are analogous for fixed sample designs. The function <code>designSimon</code> uses the <code><a href="clinfun.html#topic+ph2simon">ph2simon</a></code>
from the <span class="pkg">clinfun</span> package to create boundaries using Simon's (1989) two-stage design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
designAb(Nk, a = NULL, b = NULL, theta0 = NULL, 
    tsalpha = NULL, alternative = "two.sided", 
    conf.level = 0.95, binding = "both")

designOBF(Nmax,theta0 = 0.5,  k = Inf,  tsalpha = NULL,
    alternative = "two.sided", conf.level = 0.95, 
    binding = "both")
designOBFpower(theta0 = 0.5, theta1=.6,  k=Inf,
    power=.9, tsalpha = NULL, alternative = "two.sided",
    conf.level = 0.95, binding = "both", allNgreater=FALSE,
    checkmax=10, maxNmax=2*ss)

designFixed(Nmax, theta0 = 0.5, tsalpha = NULL, 
    alternative = "two.sided", conf.level = 0.95)
designFixedpower(theta0 = 0.5, theta1 = 0.6, power = 0.8,
    maxNmax = Inf, tsalpha = NULL, alternative = NULL,
    conf.level = 0.95, allNgreater = FALSE)

designSimon(theta0, theta1, alpha = 0.05, beta = 0.2, 
    type = c("optimal", "minimax"), nmax=100)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="designOBF_+3A_nk">Nk</code></td>
<td>
<p>vector of unique N values where there is stopping</p>
</td></tr>
<tr><td><code id="designOBF_+3A_a">a</code></td>
<td>
<p>numeric vector with length(a)=length(Nk)-1, stop if number of successes out of Nk[i] is less than or equal to a[i] (see details)</p>
</td></tr>
<tr><td><code id="designOBF_+3A_b">b</code></td>
<td>
<p>numeric vector with length(a)=length(Nk)-1, stop if number of successes out of Nk[i] is greater than or equal to b[i] (see details)</p>
</td></tr>
<tr><td><code id="designOBF_+3A_nmax">Nmax</code></td>
<td>
<p>maximum number of observations for the design</p>
</td></tr>
<tr><td><code id="designOBF_+3A_maxnmax">maxNmax</code></td>
<td>
<p>maximum number for Nmax (see details)</p>
</td></tr>
<tr><td><code id="designOBF_+3A_k">k</code></td>
<td>
<p>number of looks at the data, Inf denotes looking after each observation</p>
</td></tr>
<tr><td><code id="designOBF_+3A_theta0">theta0</code></td>
<td>
<p>probability of success under the null</p>
</td></tr>
<tr><td><code id="designOBF_+3A_tsalpha">tsalpha</code></td>
<td>
<p>vector of length 2 with nominal significance levels for each side, if not NULL overrides <code>conf.level</code> and <code>alternative</code> 
(see <code><a href="#topic+getTSalpha">getTSalpha</a></code>)
</p>
</td></tr>
<tr><td><code id="designOBF_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level, ignored if tsalpha is not NULL</p>
</td></tr>
<tr><td><code id="designOBF_+3A_alternative">alternative</code></td>
<td>
<p>character, alternative hypothesis, either 'less', 'greater' or 'two.sided' </p>
</td></tr>
<tr><td><code id="designOBF_+3A_binding">binding</code></td>
<td>
<p>character, which sides are binding: 'both', 'upper', or 'lower'</p>
</td></tr>
<tr><td><code id="designOBF_+3A_theta1">theta1</code></td>
<td>
<p>probability of success under alternative for power calculations</p>
</td></tr>
<tr><td><code id="designOBF_+3A_power">power</code></td>
<td>
<p>nominal power, boundary strives to have power under the alternative at least equal to power</p>
</td></tr>
<tr><td><code id="designOBF_+3A_allngreater">allNgreater</code></td>
<td>
<p>logical, if TRUE max(N) will be at least as large as the fixed sample size for which all greater N have power&gt;power</p>
</td></tr>
<tr><td><code id="designOBF_+3A_checkmax">checkmax</code></td>
<td>
<p>integer, on the iteration  checkmax, check that Nmax has power at least power</p>
</td></tr>
<tr><td><code id="designOBF_+3A_alpha">alpha</code></td>
<td>
<p>one sided alpha level for test theta&gt;theta0</p>
</td></tr>
<tr><td><code id="designOBF_+3A_beta">beta</code></td>
<td>
<p>1-power, for theta1</p>
</td></tr>
<tr><td><code id="designOBF_+3A_type">type</code></td>
<td>
<p>character, type of 2-stage design, either 'optimal' or 'minimax'</p>
</td></tr>
<tr><td><code id="designOBF_+3A_nmax">nmax</code></td>
<td>
<p>maximum total sample size, cannot be higher than 1000</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>tsalpha</code>, <code>alternative</code>, and <code>conf.level</code> are input into the <code><a href="#topic+getTSalpha">getTSalpha</a></code> function to output a <code>tsalpha</code> vector. The <code>tsalpha</code> 
vector allows the nominal error to be different on each side. For details see <code><a href="#topic+getTSalpha">getTSalpha</a></code>.
</p>
<p>For <code>designAb</code>, when you do not want to stop on the lower or upper boundary at any value of Nk, the associated value of a (lower) or b (upper) should be NA. 
</p>
<p>The <code>designOBF</code> function calculates a boundary that stops whenever the B-value (Lan and Wittes, 1988) is larger than one cutoff value or smaller than a different cutoff value. 
The cutoff values are chosen so that the probability of spending alpha on the appropriate side 
is almost all spent while still rejecting at at least one end value of the boundary. 
</p>
<p>The function <code>designOBFpower</code> repeatedly calls <code>designOBF</code> and finds the design that 
gives sufficient power under a given alternative. Specifically, by setting  
Nmax to Nmaxi in <code>designOBF</code>, where Nmaxi is increased by 1 at each iteration. The initial Nmaxi is either 
the first N that gives a large enough power in the fixed sample size design (allNgreater==FALSE) or the first N such that all larger N will give enough power for fixed samples (allNgreater==TRUE). 
On the <code>(checkmax)</code>th iteration, check that the power will be large enough when Nmaxi equals Nmax (from designOBFpower call). 
So if you set <code>checkmax</code>=1 then you will
check the largest value of Nmax first, but this may be inefficient since larger values of Nmax in the <code>obf</code> call are slower.  
</p>
<p>See Kirk and Fay (2014) for an introductory paper about exact binary sequential tests using the binseqtest package.
</p>


<h3>Value</h3>

<p>a object of class <code><a href="#topic+boundEst">boundEst</a></code>
</p>


<h3>References</h3>

<p>Kirk, J, and Fay, MP (2014). An Introduction to Practical Sequential Inferences via Single Arm Binary Response Studies Using the binseqtest R Package. (to appear in American Statistician).
</p>
<p>Lan, KKG, and Wittes, J (1988). The B-Value: A Tool for Monitoring Data. Biometrics 44:579-585.
</p>
<p>Simon R. (1989). Optimal Two-Stage Designs for Phase II Clinical Trials. Controlled Clinical Trials 10, 1-10. 
</p>

<hr>
<h2 id='EN'>
Expected sample size for boundary.
</h2><span id='topic+EN'></span>

<h3>Description</h3>

<p>Calculate expected sample size for <code><a href="#topic+bound-class">bound</a></code> object, after inputing theta. </p>


<h3>Usage</h3>

<pre><code class='language-R'>EN(object, theta = 0.6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EN_+3A_object">object</code></td>
<td>
<p>a object representing a binary sequential class (<code><a href="#topic+bound-class">bound-class</a></code>)</p>
</td></tr>
<tr><td><code id="EN_+3A_theta">theta</code></td>
<td>
<p>a vector of parameters representing the probability of a success</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of expected sample sizes associated with the <code>theta</code> argument.
</p>


<h3>See Also</h3>

<p>See Also <code><a href="#topic+powerBsb">powerBsb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>B&lt;-designAb(Nk=c(20,40),a=c(5),b=c(15),theta0=.5)
En&lt;-EN(B,theta=c(.1,.5,.6))
En
</code></pre>

<hr>
<h2 id='getTSalpha'>
Two-sided alpha, alternative, and confidence level 
</h2><span id='topic+getTSalpha'></span><span id='topic+getAlternative'></span>

<h3>Description</h3>

<p>Two functions to find <code>tsalpha</code> and <code>alternative</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTSalpha(tsalpha = NULL, alternative = NULL, conf.level = NULL)
getAlternative(tsalpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTSalpha_+3A_tsalpha">tsalpha</code></td>
<td>
<p>vector of length 2 with nominal significance levels for each side, if not NULL overrides <code>conf.level</code> and <code>alternative</code> (see details)</p>
</td></tr>
<tr><td><code id="getTSalpha_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level, ignored if tsalpha is not NULL</p>
</td></tr>
<tr><td><code id="getTSalpha_+3A_alternative">alternative</code></td>
<td>
<p>character, alternative hypothesis, either 'less', 'greater' or 'two.sided' </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>tsalpha</code> is a vector of length 2 giving the nominal error for each side 
of confidence intervals. The function <code>getTSalpha</code> creates a <code>tsalpha</code> vector, allowing its creation either directly (non-null input for the argument <code>tsalpha</code>
simply outputs that same argument), or through the <code>alternative</code> and <code>conf.level</code> arguments.   
The element <code>tsalpha[1]</code> is the nominal error on the lower side, so for example if <code>tsalpha=NULL</code>, <code>alternative='greater'</code>, and<code>conf.level=.95</code>, 
then <code>getTSalpha</code> outputs the vector <code>c(0.05,0)</code>. In other words, if on rejection you want  to conclude that <code class="reqn">\theta&gt;\theta_0</code>, then you want all the nominal 
error to be on the lower side. Similarly  <code>tsalpha[2]</code> is the nominal error on the upper side,  and  <code>tsalpha=NULL</code>, <code>alternative='less'</code>, and<code>conf.level=.95</code>, 
gives <code>c(0,0.05)</code>. If <code>tsalpha=NULL</code>, <code>alternative='greater'</code>, and <code>conf.level=.95</code>, then outputs the vector <code>c(0.025,0.025)</code>.
You must supply either <code>tsalpha</code> or both <code>alternative</code> and <code>conf.level</code>. 
</p>


<h3>Value</h3>

<p><code>getTSalpha</code> returns a tsalpha vector (see details), and <code>getAlternative</code> gives the character vector for the appropriate alternative. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getTSalpha(conf.level=.95,alternative="two.sided")
getAlternative(c(0,.025))
</code></pre>

<hr>
<h2 id='modify'>
Modify binary sequential boundary
</h2><span id='topic+modify'></span>

<h3>Description</h3>

<p>Modify several different aspects of a binary sequential boundary. 
Most modifications do not change the stopping boundaries. The  exceptions are 'missN', which allows modifications for missing assessments,
and 'closeout', which allows for early stopping of the trial for administrative reasons (i.e., reasons that do not depend on the responses in the trial). 
Other modifications possible: level of the confidence intervals (using tsalpha, conf.level, or alternative), which boundaries are binding (i.e., can change from a boundary with binding futility boundaries to one with 
non-binding futility boundaries), null hypothesis value (theta0), and whether the confidence intervals should match the non-binding futility p-values on the superiority boundaries (cipMatch).  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modify(b, missN = NULL, theta0 = NULL, tsalpha = NULL,
    conf.level = NULL, alternative = NULL, cipMatch = TRUE,
    binding = NULL, closeout=NULL,  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modify_+3A_b">b</code></td>
<td>

<p>an object of class <code><a href="#topic+boundEst">boundEst</a></code> 
</p>
</td></tr>
<tr><td><code id="modify_+3A_missn">missN</code></td>
<td>

<p>a vector of missed assessments
</p>
</td></tr>
<tr><td><code id="modify_+3A_theta0">theta0</code></td>
<td>

<p>null hypothesis probability of success
</p>
</td></tr>
<tr><td><code id="modify_+3A_tsalpha">tsalpha</code></td>
<td>

<p>vector of length 2 with nominal significance level, if not NULL overrides <code>conf.level</code> and <code>alternative</code>
</p>
</td></tr>
<tr><td><code id="modify_+3A_conf.level">conf.level</code></td>
<td>

<p>confidence level, ignored if tsalpha is not NULL
</p>
</td></tr>
<tr><td><code id="modify_+3A_alternative">alternative</code></td>
<td>

<p>character, alternative hypothesis, either 'less', 'greater' or 'two.sided' 
</p>
</td></tr>
<tr><td><code id="modify_+3A_cipmatch">cipMatch</code></td>
<td>

<p>logical, for non-binding futility boundaries, should CI match the p-values on the binding boundary
</p>
</td></tr>
<tr><td><code id="modify_+3A_binding">binding</code></td>
<td>
<p>character, which sides are binding: 'both', 'upper', or 'lower'</p>
</td></tr>
<tr><td><code id="modify_+3A_closeout">closeout</code></td>
<td>
<p>total number of trials at early closeout</p>
</td></tr>
<tr><td><code id="modify_+3A_...">...</code></td>
<td>

<p>other parameters passed
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+boundEst">boundEst</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>b&lt;-designOBF(50)
bmod&lt;-modify(b,missN=30:36)
par(mfrow=c(2,1))
plot(b)
plot(bmod)
</code></pre>

<hr>
<h2 id='plot-methods'>Methods for Function <code>plot</code> and <code>points</code> in Package <span class="pkg">binseqtest</span></h2><span id='topic+plot-methods'></span><span id='topic+plot+2CboundEst+2CANY-method'></span><span id='topic+plot+2CboundEst+2Cmissing-method'></span><span id='topic+points-methods'></span><span id='topic+points+2CANY-method'></span><span id='topic+points+2CboundEst-method'></span>

<h3>Description</h3>

<p>Plot binary sequential boundaries for <code>"boundEst"</code> objects. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'boundEst,missing'
plot(x, 
    rcol = c(orange = "#E69F00", blue = "#56B4E9", green = "#009E73"), 
    rpch = c(openCircle=1, filledCircle=16, filledDiamond=18), 
    bplottype = "NS",   
    newplot = TRUE, dtext=NULL, grid=50, xlab=NULL, ylab=NULL, ...)

## S4 method for signature 'boundEst'
points(x, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot-methods_+3A_x">x</code></td>
<td>
<p>an object of class <code>"boundEst"</code> </p>
</td></tr>
<tr><td><code id="plot-methods_+3A_rcol">rcol</code></td>
<td>
<p>rejection color vector, rcol[1]=fail to reject, rcol[2]=reject, conclude theta&gt;theta0, rcol[3]=reject, conclude theta&lt; theta0 (see details)</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_rpch">rpch</code></td>
<td>
<p>rejection pch vector, correspond to same categories as rcol vector</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_bplottype">bplottype</code></td>
<td>
<p>character, either 'NS' (default), 'FS', 'NB', 'NZ', or 'NE' (see details)</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_newplot">newplot</code></td>
<td>
<p>logical, should a new plot be started? if FALSE add to existing plot (only makes sense to add to plot with the same bplottype)</p>
</td></tr> 
<tr><td><code id="plot-methods_+3A_dtext">dtext</code></td>
<td>
<p>logical, add descriptive text? if NULL only adds text when newplot=TRUE (used for bplottype='NS' or 'FS')</p>
</td></tr> 
<tr><td><code id="plot-methods_+3A_grid">grid</code></td>
<td>
<p>numeric, if maximum possible total trials&lt;=grid then add gridlines (used for bplottype='NS' or 'FS')</p>
</td></tr> 
<tr><td><code id="plot-methods_+3A_xlab">xlab</code></td>
<td>
<p>title for x axis, if NULL value depends on bplottype</p>
</td></tr> 
<tr><td><code id="plot-methods_+3A_ylab">ylab</code></td>
<td>
<p>title for y axis, if NULL value depends on bplottype</p>
</td></tr> 
<tr><td><code id="plot-methods_+3A_...">...</code></td>
<td>
<p>other arguments to the <code>plot</code> function can be passed here.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default rcol vector are good colors for distinguishing for those with color blindness. Text is printed on the unused portion of the plot, which uses the color names 
taken from the rcol vector  names. 
</p>
<p>Their are several different types of plots, selected by the <code>bplottype</code> argument, where the value is a character string with 2 characters, the first representing the 
x-axis and the second representing the y-axis. For example <code>bplottype</code>='NS' denotes N=total number of trials on the horizontal axis, and S=number of successes on the vertical 
axis. Other plots are: 'FS'=failure by successes; 'NB'=total by B-values; 'NZ'=total by Z-scores; 'NE'=total by estimates and confidence intervals. The type 'NE' is only defined 
if there are only 1 value for each N on the upper and 1 value for each N on the lower part of the boundary. Otherwise, the confidence intervals would overlap and be uninformative. 
For 'NE' the end of the boundary is not plotted because of that overlapping.  
</p>
<p>For some examples, see plot section of the vignette. The method points just calls <code>plot(x,newPlot=FALSE,...)</code>. 
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "ANY", y = "ANY")</code></dt><dd><p>Generic function: see
<code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</dd>
<dt><code>signature(x = "boundEst", y = "missing")</code></dt><dd><p>Plot
binary sequential boundaries for <code>x</code>.</p>
</dd>
<dt><code>signature(x = "ANY")</code></dt><dd><p>Generic function: see
<code><a href="graphics.html#topic+points">points</a></code>.</p>
</dd>
<dt><code>signature(x = "boundEst")</code></dt><dd><p>Add points associated with the binary sequential boundaries for <code>x</code> to a plot.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>b&lt;-designOBF(50,theta0=.5)
plot(b,bplottype="NE")
plot(b)
b2&lt;-designFixed(49,theta0=.5)
points(b2,rpch=c(17,17,17))


</code></pre>

<hr>
<h2 id='powerBsb'>
Power for binary sequential boundary
</h2><span id='topic+powerBsb'></span>

<h3>Description</h3>

<p>Calculate power from <code><a href="#topic+boundEst">boundEst</a></code> object for vector of alternatives</p>


<h3>Usage</h3>

<pre><code class='language-R'>powerBsb(object, theta = 0.6, alternative = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="powerBsb_+3A_object">object</code></td>
<td>
<p>a 'boundEst' object</p>
</td></tr>
<tr><td><code id="powerBsb_+3A_theta">theta</code></td>
<td>
<p>vector of theta values, probability of success</p>
</td></tr>
<tr><td><code id="powerBsb_+3A_alternative">alternative</code></td>
<td>
<p>character, either 'two.sided', 'less', or 'greater'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Power to reject. For alternative='greater' reject when pU&lt;tsalpha['alphaUpper'], and
for alternative='less' reject when pL&lt;tsalpha['alphaLower']. For 
alternative='two.sided' if theta[i]&gt;theta0 reject when pU&lt;tsalpha['alphaUpper'],
if theta[i]&lt;theta0 reject when pL&lt;tsalpha['alphaLower'],  if 
theta[i]==theta0 and tsalpha['alphaUpper']&lt;=tsalpha['alphaLower'] reject when pU&lt;tsalpha['alphaUpper'], and  if 
theta[i]==theta0 and tsalpha['alphaUpper']&gt;tsalpha['alphaLower'] reject when pL&lt;tsalpha['alphaLower']. 
</p>


<h3>Value</h3>

<p>a vector with power associated with the parameter vector theta
</p>


<h3>Examples</h3>

<pre><code class='language-R'>B&lt;-designAb(Nk=c(20,40),a=10,theta0=.4)
powerBsb(B,theta=c(.1,.4,.8),alternative="less")
</code></pre>

<hr>
<h2 id='prStop'>
Probabilty of Stopping
</h2><span id='topic+prStop'></span>

<h3>Description</h3>

<p>Calculates the probability of stopping at any point in a binary sequential boundary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prStop(object, theta = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prStop_+3A_object">object</code></td>
<td>

<p>an object of class <code><a href="#topic+boundEst">boundEst</a></code>  
</p>
</td></tr>
<tr><td><code id="prStop_+3A_theta">theta</code></td>
<td>

<p>probability of a positive response
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements
</p>
<table>
<tr><td><code>B</code></td>
<td>
<p>the <code>boundEst</code> object inputted</p>
</td></tr>
<tr><td><code>Nupper</code></td>
<td>
<p> vector of N values for stopping on upper boundary</p>
</td></tr>
<tr><td><code>dStopUpper</code></td>
<td>
<p> vector of probabilities for stopping at each value of Nupper</p>
</td></tr>
<tr><td><code>pStopUpper</code></td>
<td>
<p> vector of cumulative probabilities for stopping by each value of Nupper</p>
</td></tr>
<tr><td><code>Nlower</code></td>
<td>
<p> vector of N values for stopping on lower boundary</p>
</td></tr>
<tr><td><code>dStopLower</code></td>
<td>
<p> vector of probabilities for stopping at each value of NLower</p>
</td></tr>
<tr><td><code>pStopLower</code></td>
<td>
<p> vector of cumulative probabilities for stopping by each value of NLower</p>
</td></tr>
<tr><td><code>Nend</code></td>
<td>
<p>N value at the end of the boundary, i.e., max(N) </p>
</td></tr>
<tr><td><code>dStopEnd</code></td>
<td>
<p>probability of stopping at the end of the boundary</p>
</td></tr>
<tr><td><code>check</code></td>
<td>
<p>check value, should be 1 or very close to it</p>
</td></tr>
</table>


<h3>See Also</h3>

 <p><code><a href="#topic+powerBsb">powerBsb</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>b&lt;-designOBF(20,theta0=.5)
prStop(b,theta=.5)
</code></pre>

<hr>
<h2 id='stopTable'>
Create data frame with statistics for stopping boundary
</h2><span id='topic+stopTable'></span><span id='topic+print.stopTable'></span>

<h3>Description</h3>

<p>Takes boundEst object and creates data frame with p-values and confidence intervals for stopping points between <code>Nmin</code> and <code>Nmax</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stopTable(object, Nrange = c(0,Inf), 
    Srange=c(0,Inf),output="all",file="stopTableOutput.csv")

## S3 method for class 'stopTable'
print(x,digits=c(3,5),maxnprint=Inf,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stopTable_+3A_object">object</code></td>
<td>
<p>object of class <code><a href="#topic+boundEst">boundEst</a></code></p>
</td></tr>
<tr><td><code id="stopTable_+3A_nrange">Nrange</code></td>
<td>
<p>numeric vector, range of total trials to output boundary points (see details)</p>
</td></tr>
<tr><td><code id="stopTable_+3A_srange">Srange</code></td>
<td>
<p>numeric vector, range of successes  to output boundary points (see details)</p>
</td></tr>
<tr><td><code id="stopTable_+3A_output">output</code></td>
<td>
<p>character, type of output, 'all','csv', or 'print'</p>
</td></tr>

<tr><td><code id="stopTable_+3A_file">file</code></td>
<td>
<p>character, name of file to output comma separated file</p>
</td></tr>
<tr><td><code id="stopTable_+3A_x">x</code></td>
<td>
<p>object of class 'stopTable'</p>
</td></tr>
<tr><td><code id="stopTable_+3A_digits">digits</code></td>
<td>
<p>vector of length 1 or 2, first element is digits to print for estimates and confidence intervals (and p-values if length(digits)=1), 
second element is digits for p-values</p>
</td></tr>
<tr><td><code id="stopTable_+3A_maxnprint">maxnprint</code></td>
<td>
<p>number of rows to print from the table</p>
</td></tr>
<tr><td><code id="stopTable_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to print function, not needed</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Create table with statistics at selected stopping points. The arguments <code>Nrange</code> and <code>Srange</code>
select which points to output. If <code>Nrange</code> and <code>Srange</code> is of length 2, then the function selects output within the ranges of the associated N and S values.
If <code>Nrange</code> and <code>Srange</code> is of length 1,  then the function selects only output with exactly the specified values. Note that because <code>Nrange</code> is the only argument 
that starts with 'N', then <code>stopTable(object,N=41)</code> and <code>stopTable(oject,Nrange=41)</code> are equivalent. 
Output is a <code>stopTable</code> object (default), a data.frame (output='data.frame'), or a .csv file (output='csv'). The <code>print.stopTable</code>
function is an S3 print function for <code>stopTable</code> objects,  i.e., it determines the default printing to screen for those objects.
</p>


<h3>Value</h3>

<p>Either a <code>stopTable</code> object, a data.frame, or a .csv file.
The <code>stopTable</code> object is a list with elements
</p>
<table>
<tr><td><code>conf.level</code></td>
<td>
<p>confidence level=1-lowerError-upperError</p>
</td></tr>
<tr><td><code>lowerError</code></td>
<td>
<p>c.i. error on lower side</p>
</td></tr>
<tr><td><code>upperError</code></td>
<td>
<p>c.i. error on upper side</p>
</td></tr>
<tr><td><code>nullTheta</code></td>
<td>
<p>probability of success under null hypothesis</p>
</td></tr>
<tr><td><code>binding</code></td>
<td>
<p>character, which boundaries are binding: 'both', 'lower', or 'upper'</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>character, alternative hypothesis either 'two.sided', 'less', or 'greater'</p>
</td></tr> 
<tr><td><code>table</code></td>
<td>
<p> a data.frame with variables, S,N, estimate, lower (confidence limit), upper (confidence limit), pL (lower one-sided p-value), pU (upper one-sided p-value),
pts (two-sided p-value), and UL (character giving part of the boundary: 'lower', 'upper', or 'end') </p>
</td></tr>
</table>
<p>The data.frame (or .csv file) returns the table element of the <code>stopTable</code> with the other elements added as variables (or columns). 
</p>

<hr>
<h2 id='summary-methods'>Methods for Function <code>summary</code> in Package <span class="pkg">binseqtest</span></h2><span id='topic+summary-methods'></span><span id='topic+summary+2CANY-method'></span><span id='topic+summary+2CboundEst-method'></span>

<h3>Description</h3>

<p> Objects of class <code><a href="#topic+boundEst-class">boundEst</a></code> have a <code>summary</code> method. It basically calls stopTable(object) </p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "ANY")</code></dt><dd>
<p>Gives a summary of object, usually a little more calculations than associated with print or show
</p>
</dd>
<dt><code>signature(object = "boundEst")</code></dt><dd>
<p>calls <code><a href="#topic+stopTable">stopTable(object, output='print')</a></code>
</p>
</dd>
</dl>

<hr>
<h2 id='unirootDiscrete'>Identify where a non-increasing function changes sign</h2><span id='topic+unirootDiscrete'></span>

<h3>Description</h3>

<p>Let f be a non-increasing (or non-decreasing) function that changes sign within the
interval specified.  If 'pos.side'=TRUE (or FALSE) then
<code>unirootDiscrete</code> finds the value x such that  f(x) is closest
to the sign change and is positive (or negative).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unirootDiscrete(f, interval, lower = min(interval), 
    upper = max(interval), tol = 10^-5, pos.side = FALSE,
    print.steps = FALSE, maxiter = 1000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unirootDiscrete_+3A_f">f</code></td>
<td>
<p> function for which a root is needed </p>
</td></tr>
<tr><td><code id="unirootDiscrete_+3A_interval">interval</code></td>
<td>
<p>an interval giving minimum and maximum allowable values for root </p>
</td></tr>
<tr><td><code id="unirootDiscrete_+3A_lower">lower</code></td>
<td>
<p> lower bound for root </p>
</td></tr>
<tr><td><code id="unirootDiscrete_+3A_upper">upper</code></td>
<td>
<p> upper bound for root </p>
</td></tr>
<tr><td><code id="unirootDiscrete_+3A_tol">tol</code></td>
<td>
<p> absolute tolerance, abs(true root-estimated root)&lt;= tol</p>
</td></tr>
<tr><td><code id="unirootDiscrete_+3A_pos.side">pos.side</code></td>
<td>
<p>if TRUE finds value x closest to the sign change in f, such that f(x)&gt;0</p>
</td></tr>
<tr><td><code id="unirootDiscrete_+3A_print.steps">print.steps</code></td>
<td>
<p> if true prints interations</p>
</td></tr>
<tr><td><code id="unirootDiscrete_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="unirootDiscrete_+3A_...">...</code></td>
<td>
<p>additional arguments to f </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm evaluates f(x) iteratively, and the change in  'x' is halved each
iteration until the change in 'x' is less than tol. Then the root is returned according to 
the pos.side parameter.
</p>


<h3>Value</h3>

<p>A list with the folllowing elements,
</p>
<table>
<tr><td><code>iter</code></td>
<td>
<p>number of iterations (times f is evaluated)</p>
</td></tr>
<tr><td><code>f.root</code></td>
<td>
<p>value of f(x), where x is the root</p>
</td></tr>
<tr><td><code>root</code></td>
<td>
<p>the root x, where f(x)&gt;=0 if pos.side=TRUE</p>
</td></tr>
</table>
<p>...
</p>


<h3>Author(s)</h3>

<p> M.P. Fay </p>


<h3>Examples</h3>

<pre><code class='language-R'>test&lt;-function(x,parm=10.987654321){ ifelse(x&gt;=parm,1,-1) }
unirootDiscrete(test,lower=0,upper=100,tol=10^-4,pos.side=FALSE,print.steps=TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
