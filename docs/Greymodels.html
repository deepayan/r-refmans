<!DOCTYPE html><html lang="en"><head><title>Help for package Greymodels</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Greymodels}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#app_server'><p>Runs the Shiny app</p></a></li>
<li><a href='#BackgroundValues'><p>Improved background values</p></a></li>
<li><a href='#CombinedModels'><p>Combined models</p></a></li>
<li><a href='#ConfidenceInterval'><p>Confidence interval of predicted values</p>
</p></a></li>
<li><a href='#ExtendedForms'><p>Extended forms of grey models</p></a></li>
<li><a href='#IntervalMultivariable'><p>Multivariate interval sequences</p>
</p></a></li>
<li><a href='#Multivariable'><p>Multivariate sequences</p>
</p></a></li>
<li><a href='#Optimization'><p>Optimization-based grey models</p>
</p></a></li>
<li><a href='#ParametersEstimation'><p>Parameters estimation</p></a></li>
<li><a href='#Plots'><p>plots</p>
</p></a></li>
<li><a href='#ResidualModification'><p>Residual modification</p>
</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Shiny App for Grey Forecasting Model</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jahajeeah Havisha &lt;hjahajeeah@utm.ac.mu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The 'Greymodels' Shiny app is an interactive interface for statistical modelling and forecasting using grey-based models. It covers several state-of-the-art univariate and multivariate grey models. A user friendly interface allows users to easily compare the performance of different models for prediction and among others, visualize graphical plots of predicted values within user chosen confidence intervals. Chang, C. (2019) &lt;<a href="https://doi.org/10.24818%2F18423264%2F53.1.19.11">doi:10.24818/18423264/53.1.19.11</a>&gt;, Li, K., Zhang, T. (2019) &lt;<a href="https://doi.org/10.1007%2Fs12667-019-00344-0">doi:10.1007/s12667-019-00344-0</a>&gt;, Ou, S. (2012) &lt;<a href="https://doi.org/10.1016%2Fj.compag.2012.03.007">doi:10.1016/j.compag.2012.03.007</a>&gt;, Li, S., Zhou, M., Meng, W., Zhou, W. (2019) &lt;<a href="https://doi.org/10.1080%2F23307706.2019.1666310">doi:10.1080/23307706.2019.1666310</a>&gt;, Xie, N., Liu, S. (2009) &lt;<a href="https://doi.org/10.1016%2Fj.apm.2008.01.011">doi:10.1016/j.apm.2008.01.011</a>&gt;, Shao, Y., Su, H. (2012) &lt;<a href="https://doi.org/10.1016%2Fj.aasri.2012.06.003">doi:10.1016/j.aasri.2012.06.003</a>&gt;, Xie, N., Liu, S., Yang, Y., Yuan, C. (2013) &lt;<a href="https://doi.org/10.1016%2Fj.apm.2012.10.037">doi:10.1016/j.apm.2012.10.037</a>&gt;, Li, S., Miao, Y., Li, G., Ikram, M. (2020) &lt;<a href="https://doi.org/10.1016%2Fj.matcom.2019.12.020">doi:10.1016/j.matcom.2019.12.020</a>&gt;, Che, X., Luo, Y., He, Z. (2013) &lt;<a href="https://doi.org/10.4028%2Fwww.scientific.net%2FAMM.364.207">doi:10.4028/www.scientific.net/AMM.364.207</a>&gt;, Zhu, J., Xu, Y., Leng, H., Tang, H., Gong, H., Zhang, Z. (2016) &lt;<a href="https://doi.org/10.1109%2Fappeec.2016.7779929">doi:10.1109/appeec.2016.7779929</a>&gt;, Luo, Y., Liao, D. (2012) &lt;<a href="https://doi.org/10.4028%2Fwww.scientific.net%2FAMR.507.265">doi:10.4028/www.scientific.net/AMR.507.265</a>&gt;, Bilgil, H. (2020) &lt;<a href="https://doi.org/10.3934%2Fmath.2021091">doi:10.3934/math.2021091</a>&gt;, Li, D., Chang, C., Chen, W., Chen, C. (2011) &lt;<a href="https://doi.org/10.1016%2Fj.apm.2011.04.006">doi:10.1016/j.apm.2011.04.006</a>&gt;, Chen, C. (2008) &lt;<a href="https://doi.org/10.1016%2Fj.chaos.2006.08.024">doi:10.1016/j.chaos.2006.08.024</a>&gt;, Zhou, W., Pei, L. (2020) &lt;<a href="https://doi.org/10.1007%2Fs00500-019-04248-0">doi:10.1007/s00500-019-04248-0</a>&gt;, Xiao, X., Duan, H. (2020) &lt;<a href="https://doi.org/10.1016%2Fj.engappai.2019.103350">doi:10.1016/j.engappai.2019.103350</a>&gt;, Xu, N., Dang, Y. (2015) &lt;<a href="https://doi.org/10.1155%2F2015%2F606707">doi:10.1155/2015/606707</a>&gt;, Chen, P., Yu, H.(2014) &lt;<a href="https://doi.org/10.1155%2F2014%2F242809">doi:10.1155/2014/242809</a>&gt;, Zeng, B., Li, S., Meng, W., Zhang, D. (2019) &lt;<a href="https://doi.org/10.1371%2Fjournal.pone.0221333">doi:10.1371/journal.pone.0221333</a>&gt;, Liu, L., Wu, L. (2021) &lt;<a href="https://doi.org/10.1016%2Fj.apm.2020.08.080">doi:10.1016/j.apm.2020.08.080</a>&gt;, Hu, Y. (2020) &lt;<a href="https://doi.org/10.1007%2Fs00500-020-04765-3">doi:10.1007/s00500-020-04765-3</a>&gt;, Zhou, P., Ang, B., Poh, K. (2006) &lt;<a href="https://doi.org/10.1016%2Fj.energy.2005.12.002">doi:10.1016/j.energy.2005.12.002</a>&gt;, Cheng, M., Li, J., Liu, Y., Liu, B. (2020) &lt;<a href="https://doi.org/10.3390%2Fsu12020698">doi:10.3390/su12020698</a>&gt;, Wang, H., Wang, P., Senel, M., Li, T. (2019) &lt;<a href="https://doi.org/10.1155%2F2019%2F9049815">doi:10.1155/2019/9049815</a>&gt;, Ding, S., Li, R. (2020) &lt;<a href="https://doi.org/10.1155%2F2020%2F4564653">doi:10.1155/2020/4564653</a>&gt;, Zeng, B., Li, C. (2018) &lt;<a href="https://doi.org/10.1016%2Fj.cie.2018.02.042">doi:10.1016/j.cie.2018.02.042</a>&gt;, Xie, N., Liu, S. (2015) &lt;<a href="https://doi.org/10.1109%2FJSEE.2015.00013">doi:10.1109/JSEE.2015.00013</a>&gt;, Zeng, X., Yan, S., He, F., Shi, Y. (2019) &lt;<a href="https://doi.org/10.1016%2Fj.apm.2019.11.032">doi:10.1016/j.apm.2019.11.032</a>&gt;.  </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/havishaJ/Greymodels">https://github.com/havishaJ/Greymodels</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0), dplyr, Metrics, cmna, plotly</td>
</tr>
<tr>
<td>Imports:</td>
<td>shiny, shinydashboard, shinyWidgets, ggplot2, readxl,
particle.swarm.optimisation, scales, expm</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-05 11:34:16 UTC; User</td>
</tr>
<tr>
<td>Author:</td>
<td>Jahajeeah Havisha [aut, cre],
  Saib Aslam Aly [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-12-05 12:42:35 UTC</td>
</tr>
</table>
<hr>
<h2 id='app_server'>Runs the Shiny app
</h2><span id='topic+ui'></span><span id='topic+server'></span><span id='topic+run_app'></span>

<h3>Description</h3>

<p>Runs the greymodels Shiny app
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ui()
server(input, output)
run_app()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="app_server_+3A_ui">ui</code></td>
<td>
<p>Controls the layout and appearance of the greymodels shiny app</p>
</td></tr>
<tr><td><code id="app_server_+3A_input">input</code></td>
<td>
<p>Stores the current values of all of the widgets in the app</p>
</td></tr>
<tr><td><code id="app_server_+3A_output">output</code></td>
<td>
<p>Contains all of the code needed to update the R objects in the app</p>
</td></tr>
<tr><td><code id="app_server_+3A_server">server</code></td>
<td>
<p>Contains the instructions to build the greymodels shiny app</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, runs the app
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Only run this example in interactive R sessions

if (interactive()) {

library("shiny")
library("shinydashboard")
library("shinyWidgets")
library("readxl")
library("Metrics")
library("particle.swarm.optimisation")
library("cmna")
library("expm")
library("plotly")
library("ggplot2")
library("scales")
library("dplyr")

run_app &lt;- function(){

  shiny::shinyApp(ui, server, options = list(launch.browser = TRUE))
}

}
</code></pre>

<hr>
<h2 id='BackgroundValues'>Improved background values
</h2><span id='topic+BackgroundValues'></span><span id='topic+gm11'></span><span id='topic+epgm11'></span><span id='topic+tbgm11'></span><span id='topic+igm11'></span><span id='topic+gm114'></span>

<h3>Description</h3>

<p>A collection of grey forecasting models with improvements to the underlying background value <code>z</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gm11(x0)
epgm11(x0)
tbgm11(x0)
igm11(x0)
gm114(x0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BackgroundValues_+3A_x0">x0</code></td>
<td>
<p>Raw data</p>
</td></tr>
<tr><td><code id="BackgroundValues_+3A_gm11">gm11</code></td>
<td>
<p>Basic grey model</p>
</td></tr>
<tr><td><code id="BackgroundValues_+3A_epgm11">epgm11</code></td>
<td>
<p>Extrapolation-based grey model</p>
</td></tr>
<tr><td><code id="BackgroundValues_+3A_tbgm11">tbgm11</code></td>
<td>
<p>Data transformation-based grey model</p>
</td></tr>
<tr><td><code id="BackgroundValues_+3A_igm11">igm11</code></td>
<td>
<p>Improved grey model</p>
</td></tr>
<tr><td><code id="BackgroundValues_+3A_gm114">gm114</code></td>
<td>
<p>Grey model with single variable, one first-order variable, four background values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>fitted and predicted values
</p>


<h3>References</h3>

<p>Chang C (2019). Extrapolation-based Grey Model for Small-Dataset Forecasting. Economic Computation and Economic Cybernetics Studies and Research, 53(1), 171-182. DOI:10.24818/18423264/53.1.19.11.
<br />
<br />
Li K, Zhang T (2019). A Novel Grey Forecasting Model and its Application in Forecasting the Energy Consumption in Shanghai. Energy Systems, pp. 1-16. DOI:10.1007/s12667-019-00344-0.
<br />
<br />
Ou S (2012). Forecasting Agricultural Output with an Improved Grey Forecasting Model based on the Genetic Algorithm. Computers and Electronics in Agriculture, 85, 33-39. DOI:10.1016/j.compag.2012.03.007.
<br />
<br />
Li S, Zhou M, Meng W, Zhou W (2019). A new Prediction Model for Forecasting the Automobiles Ownership in China. Journal of Control and Decision, 8(2), 155-164. DOI:10.1080/23307706.2019.1666310.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># GM(1,1) model

# x0 is the original data sequence
x0 &lt;- c(2350,2465,2557,2577,2689,2739,2797,2885,2937,2996)

# Calculate AGO
  x1 &lt;- cumsum(x0)

# Determine length of x0
  n &lt;- length(x0)

# Generate background value sequence Z
  b &lt;- numeric(n)

  for (i in 1:n){
    b[i] &lt;- -(0.5*x1[i + 1] + 0.5*x1[i])
  }

  b1 &lt;- b[1:n-1]

# Create a matrix B
  B &lt;- matrix(1,nrow=n-1,ncol=2)
  B[,1] &lt;- t(t(b1[1:n-1]))

# Create matrix yn
  yn &lt;- matrix(c(x0),ncol=1)
  yn &lt;- t(t(x0[2:n]))

# Estimate parameters a and b by ordinary least squares method (OLS)
  xcap &lt;- solve (t(B)%*% B)%*% t(B) %*% yn
  a &lt;- xcap[1,1]
  b &lt;- xcap[2,1]

# Calculate fitted values
  scale_with &lt;- function(k)
  {
    (x0[1] - (b/a)) * exp(-a*k) * (1 - exp(a))
  }
  fitted &lt;- scale_with(1:n)
  x0cap &lt;- c(x0[1],fitted[1:n-1])
  x0cap

# A is the number of forecast values
  A &lt;- 4

# Predicted values
  x0cap4 &lt;- scale_with(1 : n+A-1)
  x0cap5 &lt;- tail(x0cap4,A)
  x0cap5

# Fitted and predicted values
  x0cap2 &lt;- c(x0cap,x0cap5)
  x0cap2
</code></pre>

<hr>
<h2 id='CombinedModels'>Combined models
</h2><span id='topic+CombinedModels'></span><span id='topic+ngbm11'></span><span id='topic+ggvm11'></span><span id='topic+tfdgm11'></span>

<h3>Description</h3>

<p>A collection of hybrid grey forecasting models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ngbm11(x0)
ggvm11(x0)
tfdgm11(x0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CombinedModels_+3A_x0">x0</code></td>
<td>
<p>Raw data</p>
</td></tr>
<tr><td><code id="CombinedModels_+3A_ngbm11">ngbm11</code></td>
<td>
<p>Non-linear grey Bernoulli model</p>
</td></tr>
<tr><td><code id="CombinedModels_+3A_ggvm11">ggvm11</code></td>
<td>
<p>Grey generalized Verhulst model</p>
</td></tr>
<tr><td><code id="CombinedModels_+3A_tfdgm11">tfdgm11</code></td>
<td>
<p>Traffic flow mechanics grey model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>fitted and predicted values
</p>


<h3>References</h3>

<p>Chen C (2008). Application of the Novel Nonlinear Grey Bernoulli Model for Forecasting Unemployment Rate. Chaos, Solitons and Fractals, 37(1), 278-287. DOI:10.1016/j.chaos.2006.08.024.
<br />
<br />
Zhou W, Pei L (2020). The Grey Generalized Verhulst model and its Application for Forecasting Chinese Pig Price Index. Soft Computing, 24, 4977-4990. DOI:10.1007/s00500-019-04248-0.
<br />
<br />
Xiao X, Duan H (2020). A New Grey Model for Traffic Fow Mechanisms. Engineering Applications of Artificial Intelligence, 88(2020), 103350. DOI:10.1016/j.engappai.2019.103350.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #TFDGM (1, 1) model: Traffic flow mechanics grey model

  # Input data x0
  x0 &lt;- c(129,151,132,144,119,125,127,132)
  # AGO
  x1 &lt;- cumsum(x0)

  n &lt;- length(x0)

  z &lt;- numeric(n)
  for (i in 1:n){
    z[i] &lt;- 0.5*(x1[i+1] + x1[i])
  }
  z1 &lt;- z[1:n-1]

  mat2 &lt;- matrix(c(z1),ncol=1)

  for (i in 1:n){
    z[i] &lt;- (0.5*(x1[i+1] + x1[i]))^2
  }
  z2 &lt;- z[1:n-1]

  mat1 &lt;- matrix(c(z2),ncol=1)
  mat3 &lt;- matrix(1,nrow=n-1,ncol=1)

  B &lt;- cbind(mat1, mat2, mat3)

  y &lt;- matrix(c(x0),ncol=1)
  y &lt;- t(t(x0[2:n]))

  pcap &lt;- (solve (t(B) %*% B)) %*% t(B) %*% y
  a &lt;- pcap[1,1]
  b &lt;- pcap[2,1]
  lambda &lt;- pcap[3,1]

  p &lt;- b/(2*a)
  q &lt;- ((b^2)/(4*(a^2))) - (lambda/a)

  forecast &lt;- numeric(n)
  for (k in 1:n){
    if (q == 0){
      C2 &lt;- (-1 / (x0[1] + p)) - a
      forecast[k] &lt;-  ( -1 / ((a*k) + C2) ) - p
    } else if (q &lt; 0) {
      c3 &lt;- (1/sqrt(-q)) * atan( (x0[1]+p) / sqrt(-q) ) - a
      forecast[k] &lt;-  sqrt(-q)* tan( sqrt(-q) * ( (a*k) + c3 ) ) - p
    }
  }
  x1cap &lt;- c(forecast)

  x0cap &lt;- numeric(n)
  for (i in 1:n){
    x0cap[i] &lt;- x1cap[i+1] - x1cap[i]
  }
  x0cap1 &lt;- x0cap[1:n-1]
  x0cap &lt;- c(x0[1],x0cap1)
  # Fitted values
  x0cap

  A &lt;- 4

  forecasta &lt;- numeric(n)
  for (k in 1:n+A){
    if (q == 0){
      C2 &lt;- (-1 / (x0[1] + p)) - a
      forecast[k] &lt;-  ( -1 / ((a*k) + C2) ) - p
    } else if (q &lt; 0) {
      c3 &lt;- (1/sqrt(-q)) * atan( (x0[1]+p) / sqrt(-q) ) - a
      forecasta[k] &lt;-  sqrt(-q)* tan( sqrt(-q) * ( (a*k) + c3 ) ) - p
    }
  }
  x1cap4 &lt;- c(forecasta)

  t4 &lt;- length(x1cap4)

  x0cap4 &lt;- numeric(t4)
  for (i in 1:t4-1) {
    x0cap4[i] &lt;- x1cap4[i+1] - x1cap4[i]
  }
  x0cap4 &lt;- c(x0[1],x0cap4[1:t4-1])

  # Predicted values
  x0cap5 &lt;- tail(x0cap4,A)
  x0cap5

  # Fitted &amp; Predicted values
  x0cap2 &lt;- c(x0cap,x0cap5)
  x0cap2

</code></pre>

<hr>
<h2 id='ConfidenceInterval'>Confidence interval of predicted values
</h2><span id='topic+ConfidenceInterval'></span><span id='topic+CIvalue'></span><span id='topic+CI_rm'></span><span id='topic+CI_nhmgmp'></span><span id='topic+CI_igndgm'></span><span id='topic+CI_mdbgm'></span>

<h3>Description</h3>

<p>The <code>CIvalue</code>, <code>CI_rm</code> and <code>CI_mdbgm</code> functions calculate the confidence interval of the predicted values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CIvalue(fp1,actual1,x,ci)
CI_rm(fp1,actual1,x,ci)
CI_nhmgmp(fp1,x01,x02,x,ci)
CI_igndgm(fp1,actual1,x,ci)
CI_mdbgm(fp1,actual1,x,ci)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ConfidenceInterval_+3A_fp1">fp1</code></td>
<td>
<p>Fitted and predicted values</p>
</td></tr>
<tr><td><code id="ConfidenceInterval_+3A_actual1">actual1</code></td>
<td>
<p>Raw data</p>
</td></tr>
<tr><td><code id="ConfidenceInterval_+3A_x01">x01</code></td>
<td>
<p>Raw data of variable 1</p>
</td></tr>
<tr><td><code id="ConfidenceInterval_+3A_x02">x02</code></td>
<td>
<p>Raw data of variable 2</p>
</td></tr>
<tr><td><code id="ConfidenceInterval_+3A_x">x</code></td>
<td>
<p>Number of forecasts chosen by the user</p>
</td></tr>
<tr><td><code id="ConfidenceInterval_+3A_ci">ci</code></td>
<td>
<p>The confidence level chosen by the user. Values range between 90%, 95% and 99%.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>confidence interval of predicted values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Confidence interval of predicted values for EPGM (1, 1) model

  # fp1 is the sequence of fitted and predicted values

  fp1&lt;-c(560,541.4,517.8,495.3,473.7,453.1,433.4,414.5,396.5)

  # actual1 is the original data

  actual1&lt;-c(560,540,523,500,475)

  fp2 &lt;- t(fp1)

  w &lt;- length(fp2)

  actual2 &lt;- t(actual1)

  n &lt;- length(actual2)

  fitted1 &lt;- fp2[1:n]

  fitted2 &lt;- tail(fp1,4)

  # x is the number of values to predict

  x &lt;- 4

  predicted &lt;- t(fitted2[1:x])

  t &lt;- length(predicted)

  # Performance error - Root mean square error (rmse)

  require("Metrics")

  s &lt;- rmse(actual2, fitted1)

  sse &lt;- sum((actual2 - fitted1)^2)

  mse &lt;- sse / (n - 2)

  # ci is the confidence level (90, 95, 99)

  ci &lt;- 95

  cc &lt;- (ci + 100)/200

  t.val &lt;- qt(cc, n - 2)

  # Calculate prediction interval

  u &lt;- numeric(t)
  l &lt;- numeric(t)

  for (i in 1:t) {
    u[i] = predicted[i] + (t.val * (sqrt(mse) * sqrt(i)))
    l[i] = predicted[i] - (t.val * (sqrt(mse) * sqrt(i)))
  }

  UpperBound &lt;- c(u[1:t])
  LowerBound &lt;- c(l[1:t])

  CIset &lt;- data.frame(LowerBound,UpperBound)
  CIset

</code></pre>

<hr>
<h2 id='ExtendedForms'>Extended forms of grey models
</h2><span id='topic+ExtendedForms'></span><span id='topic+dgm11'></span><span id='topic+dgm21'></span><span id='topic+odgm21'></span><span id='topic+ndgm11'></span><span id='topic+vssgm11'></span><span id='topic+gom11'></span><span id='topic+gomia11'></span><span id='topic+ungom11'></span><span id='topic+exgm11'></span><span id='topic+egm11'></span>

<h3>Description</h3>

<p>A collection of extended grey forecasting models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgm11(x0)
dgm21(x0)
odgm21(x0)
ndgm11(x0)
vssgm11(x0)
gom11(x0)
gomia11(x0)
ungom11(x0)
exgm11(x0)
egm11(k,x0,k_A,x0_A)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ExtendedForms_+3A_x0">x0</code></td>
<td>
<p>Raw data</p>
</td></tr>
<tr><td><code id="ExtendedForms_+3A_k">k</code></td>
<td>
<p>Data index of raw data</p>
</td></tr>
<tr><td><code id="ExtendedForms_+3A_x0_a">x0_A</code></td>
<td>
<p>Raw data (testing set)</p>
</td></tr>
<tr><td><code id="ExtendedForms_+3A_k_a">k_A</code></td>
<td>
<p>Data index (testing set)</p>
</td></tr>
<tr><td><code id="ExtendedForms_+3A_dgm11">dgm11</code></td>
<td>
<p>Discrete grey model with single variable, first order differential equation</p>
</td></tr>
<tr><td><code id="ExtendedForms_+3A_dgm21">dgm21</code></td>
<td>
<p>Discrete grey model with single variable, second order differential equation model</p>
</td></tr>
<tr><td><code id="ExtendedForms_+3A_odgm21">odgm21</code></td>
<td>
<p>Optimized discrete grey model with single variable, second order differential equation</p>
</td></tr>
<tr><td><code id="ExtendedForms_+3A_ndgm11">ndgm11</code></td>
<td>
<p>Non-homogeneous discrete grey model</p>
</td></tr>
<tr><td><code id="ExtendedForms_+3A_vssgm11">vssgm11</code></td>
<td>
<p>Variable speed and adaptive structure-based grey model</p>
</td></tr>
<tr><td><code id="ExtendedForms_+3A_gom11">gom11</code></td>
<td>
<p>Grey opposite-direction model based on inverse accumulation and traditional interpolation method</p>
</td></tr>
<tr><td><code id="ExtendedForms_+3A_gomia11">gomia11</code></td>
<td>
<p>Grey opposite-direction model based on inverse accumulation</p>
</td></tr>
<tr><td><code id="ExtendedForms_+3A_ungom11">ungom11</code></td>
<td>
<p>Unbiased grey opposite-direction model based on inverse accumulation</p>
</td></tr>
<tr><td><code id="ExtendedForms_+3A_exgm11">exgm11</code></td>
<td>
<p>Exponential grey model</p>
</td></tr>
<tr><td><code id="ExtendedForms_+3A_egm11">egm11</code></td>
<td>
<p>Extended grey model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>fitted and predicted values
</p>


<h3>References</h3>

<p>Xie N, Liu S (2009). Discrete Grey Forecasting Model and its Application. Applied Mathematical Modelling, 33(2), 1173-1186. DOI:10.1016/j.apm.2008.01.011.
<br />
<br />
Shao Y, Su H (2012). On Approximating Grey Model DGM (2, 1). 2012 AASRI Conference on Computational Intelligence and Bioinformatics, 1, 8-13. DOI:10.1016/j.aasri.2012.06.003.
<br />
<br />
Xie N, Liu S, Yang Y, Yuan C (2013). On Novel Grey Forecasting Model based on Non-homogeneous Index Sequence. Applied Mathematical Modelling, 37, 5059-5068. DOI:10.1016/j.apm.2012.10.037.
<br />
<br />
Li S, Miao Y, Li G, Ikram M (2020). A Novel Varistructure Grey Forecasting Model with Speed Adaptation and its Application. Mathematical and Computers in Simulation, 172, 45-70. DOI:10.1016/j.matcom.2019.12.020.
<br />
<br />
Che X, Luo Y, He Z (2013). Grey New Information GOM (1, 1) Model based Opposite-Direction Accumulated Generating and its Application. Applied Mechanics and Materials, 364, 207-210. DOI:10.4028/www.scientific.net/AMM.364.207.
<br />
<br />
Power Load Forecasting based on GOM (1, 1) Model under the Condition of Missing Data. 2016 IEEEPES Asia-Pacific Power and Energy Engineering Conference (APPEEC), pp. 2461-2464. DOI:10.1109/appeec.2016.7779929.
<br />
<br />
Luo Y, Liao D (2012). Grey New Information Unbiased GOM (1, 1) Model based on Opposite-Direction Accumulated Generating and its Application. Advanced Materials Research, 507, 265-268. DOI:10.4028/www.scientific.net/AMR.507.265.
<br />
<br />
Bilgil H (2020). New Grey Forecasting Model with its Application and Computer Code. AIMS Mathematics, 6(2), 1497-1514. DOI: 10.3934/math.2021091.
<br />
<br />
An Extended Grey Forecasting Model for Omnidirectional Forecasting considering Data Gap Difference. Applied Mathematical Modeling, 35, 5051-5058. DOI:10.1016/j.apm.2011.04.006.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # EXGM (1, 1): Exponential grey model

  # Input data x0
  x0 &lt;- c(2028,2066,2080,2112,2170,2275,2356,2428)

  # Calculate accumulated generating operation (AGO)
  x1 &lt;- cumsum(x0)

  # n is the length of sequence x0
  n &lt;- length(x0)

  # Create matrix y
  y &lt;- matrix(c(x0),ncol=1)
  y &lt;- t(t(x0[2:n]))

  b &lt;- numeric(n)
  for (i in 1:n){
    b[i] &lt;- -0.5*(x1[i+1] + x1[i])
  }
  b1 &lt;- b[1:n-1]

  # Create matrix B2
  mat1 &lt;- matrix(c(b1),ncol=1)
  mat2 &lt;- matrix(1,nrow=n-1,ncol=1)
  f &lt;- numeric(n)
  for (i in 1:n){
    f[i] &lt;- ( exp(1) - 1) * exp(-i)
  }
  f1 &lt;- f[2:n]

  mat3 &lt;- matrix(c(f1),ncol=1)
  B2 &lt;- cbind(mat1, mat2, mat3)

  # Parameters estimation (a, b and c) by ordinary least squares method (OLS)
  rcap &lt;- (solve (t(B2) %*% B2)) %*% t(B2) %*% y
  a &lt;- rcap[1,1]
  b &lt;- rcap[2,1]
  c &lt;- rcap[3,1]

  scale_with &lt;- function(k)
  {
    ( x1[1] - (b/a) - ( ( c/(a-1) )*exp(-1) ) ) * exp(a*(1-k)) + (b/a) + ( c/(a-1) )*exp(-k)
  }
  forecast1 &lt;- scale_with(1:n)
  x1cap &lt;- c(forecast1)
  x0cap1 &lt;- numeric(n)
  for (i in 1:n){
    x0cap1[i] &lt;- x1cap[i+1] - x1cap[i]
  }
  x0cap &lt;- c(x0[1],x0cap1[1:n-1])
  # Fitted values
  x0cap

  # A is the number of forecast values
  A &lt;- 4

  x1cap4 &lt;- scale_with(1 : n+A )
  t4 &lt;- length(x1cap4)
  x0cap4 &lt;- numeric(t4-1)
  for (i in 1:t4-1) {
    x0cap4[i] &lt;- x1cap4[i+1] - x1cap4[i]
  }
  x0cap4 &lt;- c(x0[1],x0cap4[1:t4-1])
  x0cap5 &lt;- tail(x0cap4,A)
  # Predicted values
  x0cap5

  x0cap2 &lt;- c(x0cap,x0cap5)
  # Fitted and predicted values
  x0cap2
</code></pre>

<hr>
<h2 id='IntervalMultivariable'>Multivariate interval sequences
</h2><span id='topic+IntervalMultivariable'></span><span id='topic+igndgm12'></span><span id='topic+mdbgm12'></span>

<h3>Description</h3>

<p>A collection of multivariate grey forecasting models based on interval number sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>igndgm12(LB,UB)
mdbgm12(x01L,x01U,x02L,x02U,x01La,x01Ua,x02La,x02Ua)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IntervalMultivariable_+3A_lb">LB</code>, <code id="IntervalMultivariable_+3A_ub">UB</code></td>
<td>
<p>Lower and upper bound of interval sequence</p>
</td></tr>
<tr><td><code id="IntervalMultivariable_+3A_x01l">x01L</code>, <code id="IntervalMultivariable_+3A_x01u">x01U</code></td>
<td>
<p>Lower and upper bound of first interval sequence (training set)</p>
</td></tr>
<tr><td><code id="IntervalMultivariable_+3A_x02l">x02L</code>, <code id="IntervalMultivariable_+3A_x02u">x02U</code></td>
<td>
<p>Lower and upper bound of second interval sequence (training set)</p>
</td></tr>
<tr><td><code id="IntervalMultivariable_+3A_x01la">x01La</code>, <code id="IntervalMultivariable_+3A_x01ua">x01Ua</code></td>
<td>
<p>Lower and upper bound of first interval sequence (testing set)</p>
</td></tr>
<tr><td><code id="IntervalMultivariable_+3A_x02la">x02La</code>, <code id="IntervalMultivariable_+3A_x02ua">x02Ua</code></td>
<td>
<p>Lower and upper bound of second interval sequence (testing set)</p>
</td></tr>
<tr><td><code id="IntervalMultivariable_+3A_igndgm12">igndgm12</code></td>
<td>
<p>Interval grey number sequence based on non-homogeneous discrete grey model</p>
</td></tr>
<tr><td><code id="IntervalMultivariable_+3A_mdbgm12">mdbgm12</code></td>
<td>
<p>Multivariate grey model based on dynamic background algorithm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>fitted and predicted values
</p>


<h3>References</h3>

<p>Xie N, Liu S (2015). Interval Grey Number Sequence Prediction by using Nonhomogeneous Exponential Discrete Grey Forecasting Model. Journal of Systems Engineering and Electronics, 26(1), 96-102. DOI:10.1109/JSEE.2015.00013.
<br />
<br />
Zeng X, Yan S, He F, Shi Y (2019). Multivariable Grey Model based on Dynamic Background Algorithm for Forecasting the Interval Sequence. Applied Mathematical Modelling, 80(23). DOI:10.1016/j.apm.2019.11.032.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #MDBGM (1, 2) model: Multivariate grey model based on dynamic background algorithm.

  # Input data
  #x01 Lower and upper bound of sequence 1
  #x02 Lower and upper bound of sequence 2

  # x01L is the lower bound of sequence 1
  x01L &lt;- c(2721,3136,3634,3374,3835,3595,3812,4488)

  # x01U is the upper bound of sequence 1
  x01U &lt;- c(3975,4349,4556,5103,5097,5124,5631,6072)

  # x02L is the lower bound of sequence
  x02L &lt;- c(24581,30070,36656,36075,42173,42074,45537,55949)

  # x02U is the upper bound of sequence 2
  x02U &lt;- c(41731,49700,55567,61684,68295,68342,73989,78194)

  x01 &lt;- cbind(x01L,x01U)
  x02 &lt;- cbind(x02L,x02U)

  # AGO
  x11L &lt;- cumsum(x01L)
  x11U &lt;- cumsum(x01U)

  x11 &lt;- cbind(x11L,x11U)

  x12L &lt;- cumsum(x02L)
  x12U &lt;- cumsum(x02U)

  x12 &lt;- cbind(x12L,x12U)

  # Length of sequence
  n &lt;- length(x01L)

  # Background values
  b &lt;- numeric(n)
  for (i in 1:n){
    b[i] &lt;- (0.5*x11L[i + 1] + 0.5*x11L[i])
    b1 &lt;- b[1:n-1]
  }
  z1L &lt;- matrix(c(b1),ncol=1)

  n &lt;- length(x01L)
  d &lt;- numeric(n)
  for (i in 1:n){
    d[i] &lt;- (0.5*x11U[i + 1] + 0.5*x11U[i])
    d1 &lt;- d[1:n-1]
  }
  z1U &lt;- matrix(c(d1),ncol=1)

  # Create matrix Y
  YL &lt;- matrix(c(x01L[2:n]),ncol=1)
  YU &lt;- matrix(c(x01U[2:n]),ncol=1)

  # Create matrix X
  mat1 &lt;- matrix(c(x12L[2:n]),ncol=1)
  mat2 &lt;- matrix(c(x12U[2:n]),ncol=1)
  mat3 &lt;- matrix(c(x11L[1:n-1]),ncol=1)
  mat4 &lt;- matrix(c(x11U[1:n-1]),ncol=1)
  mat5 &lt;- matrix(2:n,nrow=n-1,ncol=1)
  mat6 &lt;- matrix(1,nrow=n-1,ncol=1)

  X &lt;- cbind(mat1,mat2,mat3,mat4,mat5,mat6)

  # Parameters estimation by OLS - Lower
  A1 &lt;- solve (t(X) %*% X) %*% t(X) %*% YL
  miu11 &lt;- A1[1,1]
  miu12 &lt;- A1[2,1]
  gamma11 &lt;- A1[3,1]
  gamma12 &lt;- A1[4,1]
  g1 &lt;- A1[5,1]
  h1 &lt;- A1[6,1]

  # Parameters estimation by OLS - Upper
  A2 &lt;- solve (t(X) %*% X) %*% t(X) %*% YU
  miu21 &lt;- A2[1,1]
  miu22 &lt;- A2[2,1]
  gamma21 &lt;- A2[3,1]
  gamma22 &lt;- A2[4,1]
  g2 &lt;- A2[5,1]
  h2 &lt;- A2[6,1]

  # Fitted values - Lower
  scale_with &lt;- function(k)
  {
    (miu11*x12L[k]) + (miu12*x12U[k]) + (gamma11*x11L[k-1]) + (gamma12*x11U[k-1]) + (g1*k) + h1
  }
  forecast_L &lt;- scale_with(2:n)
  x0cap1L &lt;- c(x01L[1],forecast_L)

  # Fitted values - Upper
  scale_with &lt;- function(k)
  {
    (miu21*x12L[k]) + (miu22*x12U[k]) + (gamma21*x11L[k-1]) + (gamma22*x11U[k-1]) + (g2*k) + h2
  }
  forecast_U &lt;- scale_with(2:n)
  x0cap1U &lt;- c(x01U[1],forecast_U)

  # Matrix of fitted values (lower and upper)
  x0cap &lt;- matrix(c(cbind(x0cap1L,x0cap1U)),ncol=2)
  x0cap

</code></pre>

<hr>
<h2 id='Multivariable'>Multivariate sequences
</h2><span id='topic+Multivariable'></span><span id='topic+gm13'></span><span id='topic+igm13'></span><span id='topic+nhmgm1'></span><span id='topic+nhmgm2'></span><span id='topic+gmcg12'></span><span id='topic+gmc12'></span><span id='topic+dbgm12'></span>

<h3>Description</h3>

<p>A collection of grey forecasting models based on multiple variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gm13(x1,x2,x3)
igm13(x1,x2,x3)
nhmgm1(x01,x02)
nhmgm2(x01,x02)
gmcg12(x01,x02,dat_a)
gmc12(x01,x02,dat_a)
dbgm12(x01,x02,dat_a)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Multivariable_+3A_x1">x1</code>, <code id="Multivariable_+3A_x2">x2</code>, <code id="Multivariable_+3A_x3">x3</code></td>
<td>
<p>Raw data of 3 variables (training set)</p>
</td></tr>
<tr><td><code id="Multivariable_+3A_x01">x01</code>, <code id="Multivariable_+3A_x02">x02</code></td>
<td>
<p>Raw data of 2 variables (training set)</p>
</td></tr>
<tr><td><code id="Multivariable_+3A_dat_a">dat_a</code></td>
<td>
<p>Raw data of x02 (testing set)</p>
</td></tr>
<tr><td><code id="Multivariable_+3A_gm13">gm13</code></td>
<td>
<p>Grey multivariate model with first order differential equation and 3 variables</p>
</td></tr>
<tr><td><code id="Multivariable_+3A_igm13">igm13</code></td>
<td>
<p>Improved grey multivariate model with first order differential equation and 3 variables</p>
</td></tr>
<tr><td><code id="Multivariable_+3A_nhmgm1">nhmgm1</code></td>
<td>
<p>Non-homogeneous multivariate grey model with first order differential equation and 2 variables with p = 1</p>
</td></tr>
<tr><td><code id="Multivariable_+3A_nhmgm2">nhmgm2</code></td>
<td>
<p>Non-homogeneous multivariate grey model with first order differential equation and 2 variables with p = 2</p>
</td></tr>
<tr><td><code id="Multivariable_+3A_gmcg12">gmcg12</code></td>
<td>
<p>Multivariate grey convolution model with first order differential equation and 2 variables using the Gaussian rule</p>
</td></tr>
<tr><td><code id="Multivariable_+3A_gmc12">gmc12</code></td>
<td>
<p>Multivariate grey convolution model with first order differential equation and 2 variables using the trapezoidal rule</p>
</td></tr>
<tr><td><code id="Multivariable_+3A_dbgm12">dbgm12</code></td>
<td>
<p>Multivariate grey model with dynamic background value, first order differential equation and 2 variables using the Gaussian rule</p>
</td></tr>
</table>


<h3>Value</h3>

<p>fitted and predicted values
</p>


<h3>References</h3>

<p>Cheng M, Li J, Liu Y, Liu B (2020). Forecasting Clean Energy Consumption in China by 2025: Using Improved Grey Model GM (1, N). Sustainability, 12(2), 1-20. DOI:10.3390/su12020698.
<br />
<br />
Wang H, Wang P, Senel M, Li T (2019). On Novel Non-homogeneous Multivariable Grey Forecasting Model NHMGM. Mathematical Problems in Engineering, 2019, 1-13. DOI:10.1155/2019/9049815.
<br />
<br />
Ding S, Li R (2020). A New Multivariable Grey Convolution model based on Simpson's rule and its Application. Complexity, pp. 1-14. DOI:10.1155/2020/4564653.
<br />
<br />
Zeng B, Li C (2018). Improved Multivariable Grey Forecasting Model and with a Dynamic Background Value Coefficient and its Application. Computers and Industrial Engineering, 118, 278-290. DOI:10.1016/j.cie.2018.02.042.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # GMC_g (1, 2) model

  # Input raw data
  x01 &lt;- c(897,897,890,876,848,814)
  x02 &lt;- c(514,495,444,401,352,293)
  dat_a &lt;- c(514,495,444,401,352,293,269,235,201,187)

  # AGO
  x11 &lt;- cumsum(x01)
  x12 &lt;- cumsum(x02)

  n &lt;- length(x01)

  b11 &lt;- numeric(n)
  b12 &lt;- numeric(n)

  for (i in 1:n){
    b11[i] &lt;- -(0.5*x11[i + 1] + 0.5*x11[i])
    b12[i] &lt;- (0.5*x12[i + 1] + 0.5*x12[i])
  }
  b11a &lt;- b11[1:n-1]
  b12a &lt;- b12[1:n-1]

  mat1 &lt;- matrix(c(b11a),ncol=1)
  mat2 &lt;- matrix(c(b12a),ncol=1)
  mat3 &lt;- matrix(1,nrow=n-1,ncol=1)

  B &lt;- cbind(mat1, mat2, mat3)

  yn &lt;- matrix(c(x01),ncol=1)
  yn &lt;- t(t(x01[2:n]))

  xcap &lt;- solve (t(B) %*% B) %*% t(B) %*% yn

  beta1 &lt;- xcap[1,1]
  beta2 &lt;- xcap[2,1]
  u &lt;- xcap[3,1]

  fe &lt;- numeric(n)
  for (i in 1:n){
    fe[i] &lt;- beta2 * x12[i] + u
  }
  E &lt;- matrix(c(fe[1:n]),ncol =1)
  xrG &lt;- replicate(n,0)
  for (t in 2:n){
    sm &lt;- 0
    for (e in 2:t){
      sm &lt;- sm + (  (exp(-beta1*(t - e + 0.5)))) * ( 0.5 * (E[e]+ E[e-1]) )
    }
    xrG[t] &lt;- ( x01[1]*exp(-beta1*(t-1)) ) + sm
  }
  xcap1G &lt;- c(x01[1],xrG[2:n])
  fG &lt;- numeric(n-1)
  for (i in 1:n-1){
    fG[i] &lt;- (xcap1G[i+1] - xcap1G[i])
  }
  f1G &lt;- fG[1:n-1]
  x0cap &lt;- matrix(c(x01[1],f1G[1:n-1]),ncol=1)
  # Fitted values
  x0cap

  A &lt;- 4

  newx02 &lt;- as.numeric(unlist(dat_a))
  m &lt;- length(newx02)
  newx12 &lt;- cumsum(newx02)
  fe_A &lt;- numeric(m)
  for (i in 1:m){
    fe_A[i] &lt;- beta2 * newx12[i] + u
  }
  E_A &lt;- matrix(c(fe_A[1:m]),ncol =1)
  xrG_A &lt;- replicate(m,0)
  for (t in 2:m){
    sm &lt;- 0
    for (e in 2:t){
      sm &lt;- sm + (  (exp(-beta1*(t - e + 0.5)))) * ( 0.5 * (E_A[e]+ E_A[e-1]) )
    }
    xrG_A[t] &lt;- ( x01[1]*exp(-beta1*(t-1)) ) + sm
  }
  xcap1G_A &lt;- c(x01[1],xrG_A[2:m])

  fG_A &lt;- numeric(m-1)
  for (i in 1:m-1){
    fG_A[i] &lt;- (xcap1G_A[i+1] - xcap1G_A[i])
  }
  f1G_A &lt;- fG_A[1:m-1]

  x0cap4 &lt;- matrix(c(x01[1],f1G_A[1:m-1]),ncol=1)

  x0cap5 &lt;- tail(x0cap4,A)
  # Predicted values
  x0cap5

  # Fitted &amp; Predicted values
  x0cap2 &lt;- c(x0cap,x0cap5 )
  x0cap2

</code></pre>

<hr>
<h2 id='Optimization'>Optimization-based grey models
</h2><span id='topic+Optimization'></span><span id='topic+optim_psogm'></span><span id='topic+psogm11'></span><span id='topic+optim_andgm'></span><span id='topic+andgm11'></span><span id='topic+optim_egm11r'></span><span id='topic+egm11r'></span>

<h3>Description</h3>

<p>A collection of grey forecasting models using optimization techniques to find optimal parameters of grey models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optim_psogm(x0)
psogm11(x0)
optim_andgm(x0)
andgm11(x0)
optim_egm11r(x0)
egm11r(x0)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Optimization_+3A_x0">x0</code></td>
<td>
<p>Raw data</p>
</td></tr>
<tr><td><code id="Optimization_+3A_optim_psogm">optim_psogm</code></td>
<td>
<p>Parameters optimization (a and b) by particle swarm optimization(PSO)</p>
</td></tr>
<tr><td><code id="Optimization_+3A_psogm11">psogm11</code></td>
<td>
<p>Particle swarm optimization-based grey model</p>
</td></tr>
<tr><td><code id="Optimization_+3A_optim_andgm">optim_andgm</code></td>
<td>
<p>Parameters optimization (r) by PSO</p>
</td></tr>
<tr><td><code id="Optimization_+3A_andgm11">andgm11</code></td>
<td>
<p>Adjacent non-homogeneous discrete grey model</p>
</td></tr>
<tr><td><code id="Optimization_+3A_optim_egm11r">optim_egm11r</code></td>
<td>
<p>Parameters optimization (r) by PSO</p>
</td></tr>
<tr><td><code id="Optimization_+3A_egm11r">egm11r</code></td>
<td>
<p>Even form of grey model with one variable and one first order equation with accumulating generation of order r</p>
</td></tr>
</table>


<h3>Value</h3>

<p>fitted and predicted values
</p>


<h3>References</h3>

<p>Zeng B, Li S, Meng W, Zhang D (2019). An Improved Grey Prediction Model for China's Beef Comsumption Forecasting. PLOS ONE, 14(9), 1-18. DOI:10.1371/journal.pone.0221333.
<br />
<br />
Liu L, Wu L (2021). Forecasting the Renewable Energy Consumption of the European Countries by an Adjacent Non-homogeneous Grey Model. Applied Mathematical Modelling, 89, 1932-1948. DOI:10.1016/j.apm.2020.08.080.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Input raw data
x0 &lt;- c(2.8,3.8,4.6,5.2,5.7,6.0,6.2,6.92,7.77,8.92,10.06)

# Parameter optimization

library(particle.swarm.optimisation)

fitness_function &lt;- function(value)
  {
    r &lt;- value[1]

    n &lt;- length(x0)

    xr1 &lt;- numeric(n)

    for (i in 1:n){
      xr1[i] &lt;-  ( (r-1)/r ) * sum(x0[1:i]) + (1/r)*x0[i+1]
    }
    xr &lt;-  c(x0[1],xr1[1:n-1])

    mat1 &lt;-matrix(xr[1:n-1], nrow=n-1,ncol=1)
    mat2 &lt;-matrix(2:n-1, nrow=n-1,ncol=1)
    mat3 &lt;- matrix(1,nrow=n-1,ncol=1)

    B &lt;- cbind(mat1, mat2, mat3)

    y &lt;- t(t(xr[2:n]))

    rcap &lt;- (solve (t(B) %*% B)) %*% t(B) %*% y
    beta1 &lt;- rcap[1,1]
    beta2 &lt;- rcap[2,1]
    beta3 &lt;- rcap[3,1]

    scale_with &lt;- function(k)
    {
      ( beta1^k * x0[1] ) + ( ( 1 - beta1^k )/( 1 - beta1 ) ) * (beta2*k + beta3)
    }
    forecast1 &lt;- scale_with(1:n)

    xrcap &lt;- c(x0[1],forecast1)

    matrix2 &lt;- matrix("",1,n)
    matrix2 &lt;- as.numeric(matrix2)
    matrix2[1] &lt;- x0[1]

    for (i in 2:length(matrix2+1)) {
      matrix2[i] &lt;- r*xrcap[i] - (r-1)*sum(matrix2[1:i-1])
    }
    particule_result &lt;- matrix2
    fitness &lt;- -(1/n)*sum(abs((x0-particule_result)/x0)*100, na.rm=TRUE)
    return(fitness)
  }
  values_ranges &lt;- list(c(0.001,5))
  swarm &lt;- ParticleSwarm$new(pop_size = 100,
                             values_names = list("r"),
                             fitness_function = fitness_function,
                             max_it = 100,
                             acceleration_coefficient_range = list(c(0.5,1.5),c(0.5,1.5)),
                             inertia = 0.7,
                             ranges_of_values = values_ranges)
  swarm$run(plot = FALSE,verbose = FALSE,save_file = FALSE)
  swarm$swarm_best_values

  opt_r &lt;- swarm$swarm_best_values[1]
  opt_r

  n &lt;- length(x0)

  xr1r &lt;- numeric(n)
  for (i in 1:n){
    xr1r[i] &lt;-  ( (opt_r-1)/opt_r ) * sum(x0[1:i]) + (1/opt_r)*x0[i+1]
  }
  xoptr &lt;-  c(x0[1],xr1r[1:n-1])

  mat1r &lt;-matrix(xoptr[1:n-1], nrow=n-1,ncol=1)
  mat2r &lt;-matrix(2:n-1, nrow=n-1,ncol=1)
  mat3r &lt;- matrix(1,nrow=n-1,ncol=1)

  Br &lt;- cbind(mat1r, mat2r, mat3r)

  yr &lt;- t(t(xoptr[2:n]))

  rcapr &lt;- (solve (t(Br) %*% Br)) %*% t(Br) %*% yr
  beta1r &lt;- rcapr[1,1]
  beta2r &lt;- rcapr[2,1]
  beta3r &lt;- rcapr[3,1]

  scale_with &lt;- function(k)
  {
    ( beta1r^k * x0[1] ) + ( ( 1 - beta1r^k )/( 1 - beta1r ) ) * (beta2r*k + beta3r)
  }
  forecast1r &lt;- scale_with(1:n)

  xrcapr &lt;- c(x0[1],forecast1r)

  matrix2r &lt;- matrix("",1,n)
  matrix2r &lt;- as.numeric(matrix2r)

  matrix2r[1] &lt;- x0[1]

  for (i in 2:length(matrix2r+1)) {
    matrix2r[i] &lt;- opt_r*xrcapr[i] - (opt_r-1)*sum(matrix2r[1:i-1])
  }
  x0cap &lt;- c(matrix2r)
  # Fitted values
  x0cap

  A &lt;- 4

  # Predicted values
  n &lt;- length(x0)
  nn &lt;- n + A
  scale_with &lt;- function(k)
  {
    ( beta1r^k * x0[1] ) + ( ( 1 - beta1r^k )/( 1 - beta1r ) ) * (beta2r*k + beta3r)
  }
  forecast1ra &lt;- scale_with(1:nn)

  xrcapra &lt;- c(x0[1],forecast1ra)
  matrix2ra &lt;- matrix("",1,nn)
  matrix2ra &lt;- as.numeric(matrix2ra)
  matrix2ra[1] &lt;- x0[1]

  for (i in 2:length(matrix2ra+1)) {
    matrix2ra[i] &lt;- opt_r*xrcapra[i] - (opt_r-1)*sum(matrix2ra[1:i-1])
  }
  x0cap4 &lt;- c(matrix2ra)
  x0cap5 &lt;- tail(x0cap4,A)
  # Predicted values
  x0cap5

  # Fitted &amp; Predicted values
  x0cap2 &lt;- c(x0cap,x0cap5)
  x0cap2

</code></pre>

<hr>
<h2 id='ParametersEstimation'>Parameters estimation
</h2><span id='topic+ParametersEstimation'></span><span id='topic+sogm21'></span><span id='topic+ngm11k'></span><span id='topic+ngm11kc'></span><span id='topic+ongm11kc'></span>

<h3>Description</h3>

<p>A collection of grey forecasting models based on parameters estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sogm21(x0)
ngm11k(x0)
ngm11kc(x0)
ongm11kc(x0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ParametersEstimation_+3A_x0">x0</code></td>
<td>
<p>Raw data</p>
</td></tr>
<tr><td><code id="ParametersEstimation_+3A_sogm21">sogm21</code></td>
<td>
<p>Structured optimized grey model with single variable and second order differential equation</p>
</td></tr>
<tr><td><code id="ParametersEstimation_+3A_ngm11k">ngm11k</code></td>
<td>
<p>Nonlinear grey model</p>
</td></tr>
<tr><td><code id="ParametersEstimation_+3A_ngm11kc">ngm11kc</code></td>
<td>
<p>Nonlinear grey model</p>
</td></tr>
<tr><td><code id="ParametersEstimation_+3A_ongm11kc">ongm11kc</code></td>
<td>
<p>Optimized nonlinear grey model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>fitted and predicted values
</p>


<h3>References</h3>

<p>Xu N, Dang Y (2015). An Optimized Grey GM (2, 1) Model and Forecasting of Highway Subgrade Settlement. Mathematical Problems in Engineering, 2015(1), 1-6. DOI:10.1155/2015/606707.
<br />
<br />
Chen P, Yu H (2014). Foundation Settlement Prediction based on a Novel NGM Model. Mathematical Problems in Engineering 2014, 242809. DOI:10.1155/2014/242809.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # ONGM (1, 1, k, c) model: Nonlinear grey model

  # Input data x0
  x0 &lt;- c(23.36,43.19,58.73,70.87,83.71,92.91,99.73,105.08,109.73,112.19,113.45)

  # AGO
  x1 &lt;- cumsum(x0)

  tm &lt;- length(x0)

  # Create matrix y
  y &lt;- matrix(c(x0),ncol=1)
  y &lt;- t(t(x0[2:tm]))

  b &lt;- numeric(tm)
  for (i in 1:tm){
    b[i] &lt;- -0.5*(x1[i+1] + x1[i])
  }
  b1 &lt;- b[1:tm-1]

  # Create matrix B2
  mat1 &lt;- matrix(c(b1),ncol=1)
  mat2 &lt;-matrix(2:tm, nrow=tm-1,ncol=1)
  mat3 &lt;- matrix(1,nrow=tm-1,ncol=1)

  B2 &lt;- cbind(mat1, mat2, mat3)

  # Parameters estimation by OLS
  rcap &lt;- (solve (t(B2) %*% B2)) %*% t(B2) %*% y
  a &lt;- rcap[1,1]
  b &lt;- rcap[2,1]
  c &lt;- rcap[3,1]

  m &lt;- log ((2+a)/(2-a))
  n &lt;- (m*b)/a
  p &lt;- (m*c)/a - (n/a) + (n/2) + (n/m)

  scale_with &lt;- function(k)
  {
    (1-exp(a))*(x1[1]-(n/m)+(n/(m^2))-(p/m))*exp(-m*(k-1))+(n/m)
  }
  forecast1 &lt;- scale_with(2:tm)

  x0cap &lt;- c(x0[1],forecast1)
  # Fitted values
  x0cap

  A &lt;- 4

  x0cap4 &lt;- scale_with(1 : tm+A )

  x0cap5 &lt;- tail(x0cap4,A)
  # Predicted values
  x0cap5

  # Fitted &amp; Predicted values
  x0cap2 &lt;- c(x0cap,x0cap5)
  x0cap2

</code></pre>

<hr>
<h2 id='Plots'>plots
</h2><span id='topic+plots'></span><span id='topic+plotrm'></span><span id='topic+plotsmv1'></span><span id='topic+plotsmv2'></span><span id='topic+plotsigndgm'></span><span id='topic+plots_mdbgm12'></span>

<h3>Description</h3>

<p>The plots function gives an interactive plot of the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plots(x0,x0cap2,ci,model)
plotrm(x0,x0cap2,ci,model)
plotsmv1(actual1,fp1,ci,model)
plotsmv2(actual1,fitted,ci,model)
plotsigndgm(actual,pred,ci,model)
plots_mdbgm12(actual,pred,ci,model)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Plots_+3A_x0">x0</code></td>
<td>
<p>Raw data</p>
</td></tr>
<tr><td><code id="Plots_+3A_x0cap2">x0cap2</code></td>
<td>
<p>Fitted and predicted data</p>
</td></tr>
<tr><td><code id="Plots_+3A_actual">actual</code></td>
<td>
<p>Raw data of interval sequences</p>
</td></tr>
<tr><td><code id="Plots_+3A_actual1">actual1</code></td>
<td>
<p>Raw data of multi-variate sequences</p>
</td></tr>
<tr><td><code id="Plots_+3A_fp1">fp1</code></td>
<td>
<p>Fitted and predicted data of first variable</p>
</td></tr>
<tr><td><code id="Plots_+3A_fitted">fitted</code></td>
<td>
<p>Fitted data of multi-variate sequences</p>
</td></tr>
<tr><td><code id="Plots_+3A_pred">pred</code></td>
<td>
<p>Fitted and predicted data of interval sequences</p>
</td></tr>
<tr><td><code id="Plots_+3A_ci">ci</code></td>
<td>
<p>The confidence level chosen by the user. Values range between 90%, 95% and 99%.</p>
</td></tr>
<tr><td><code id="Plots_+3A_model">model</code></td>
<td>
<p>The model under considration</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plots
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Plots - EPGM (1, 1) model

  x0cap2&lt;-c(560,541.4,517.8,495.3,473.7,453.1,433.4,414.5,396.5)

  x0&lt;-c(560,540,523,500,475)

  # length of x0
  n &lt;- length(x0)

  fitted2 &lt;- t(x0cap2)

  x0cap &lt;- x0cap2[1:n]

  # Last 4 values of x0cap2
  fitted3 &lt;- tail(x0cap2,4)

  x0cap5 &lt;- fitted3

  w &lt;- length(x0cap2)
  t &lt;- length(x0cap5)

  # Performance errors
  # Root mean square error
  s &lt;- rmse(x0, x0cap)

  # Sum of square error
  sse &lt;- sum((x0 - x0cap)^2)

  # Mean square error
  mse &lt;- sse / (n - 2)

  # Calculate confidence interval
  ci &lt;- 95
  cc &lt;- (ci + 100)/200

  t.val &lt;- qt(cc, n - 2)

  u &lt;- numeric(t)
  l &lt;- numeric(t)
  for (i in 1:t) {
    u[i] = x0cap5[i] + (t.val * (sqrt(mse) * sqrt(i)))
    l[i] = x0cap5[i] - (t.val * (sqrt(mse) * sqrt(i)))
  }
  UB &lt;- c(u[1:t])
  LB &lt;- c(l[1:t])

  LB1 &lt;- c(x0cap[n],LB)
  UB2 &lt;- c(x0cap[n],UB)

  l1 &lt;- length(LB1)
  d3 &lt;- seq(1, l1, 1)
  u1 &lt;- length(UB2)
  d4 &lt;- seq(1, u1, 1)

  set3 &lt;- data.frame(x=d3, y=LB1)
  set4 &lt;- data.frame(x=d4, y=UB2)

  d0 &lt;- seq(1, n, 1)
  xy1 &lt;- data.frame(x=d0, y=x0)

  d1 &lt;- seq(1, w, 1)
  xy2 &lt;- data.frame(x=d1, y=x0cap2)

  # Create data frame
  df &lt;- rbind(xy1, xy2, set3, set4)

  # Plots
  colors &lt;- c("Raw Data"="red","Fitted&amp;Forecasts"="blue","LowerBound"="green","UpperBound"="yellow")
  CI &lt;- c(n:w)

  x=y=NULL

  p &lt;- ggplot(df) +
    theme_bw() +
    labs(title = 'EPGM (1, 1) model',x = 'Number of observation',y = 'Data Forecast &amp; Prediction') +
    scale_x_continuous(breaks=1:w) +
    scale_y_continuous(labels = scales::comma) +
    geom_point(data = xy1, aes(x = x, y = y), shape = 24, color = "black") +
    geom_point(data = xy2, aes(x = x, y = y), shape = 21, color = "black") +
    geom_point(data = set3, aes(x = CI, y = y), shape = 23, color = "black") +
    geom_point(data = set4, aes(x = CI, y = y), shape = 23, color = "black") +
    geom_line(data = xy1, aes(x = x, y = y,color = "Raw Data")) +
    geom_line(data = xy2, aes(x = x, y = y,color = "Fitted&amp;Forecasts")) +
    geom_line(data = set3, aes(x = CI, y = y,color = "LowerBound"), linetype=2) +
    geom_line(data = set4, aes(x = CI, y = y,color = "UpperBound"), linetype=2) +
    scale_color_manual(name = "Label",values = colors)
  r &lt;- ggplotly(p)
  r

</code></pre>

<hr>
<h2 id='ResidualModification'>Residual modification
</h2><span id='topic+ResidualModification'></span><span id='topic+remnantgm11'></span><span id='topic+tgm11'></span>

<h3>Description</h3>

<p>A collection of grey forecasting models based on residual grey models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remnantgm11(x0,x0_A)
tgm11(x0,x0_A)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ResidualModification_+3A_x0">x0</code></td>
<td>
<p>Raw data (training set)</p>
</td></tr>
<tr><td><code id="ResidualModification_+3A_x0_a">x0_A</code></td>
<td>
<p>Raw data (testing set)</p>
</td></tr>
<tr><td><code id="ResidualModification_+3A_remnantgm11">remnantgm11</code></td>
<td>
<p>Residual-based grey model</p>
</td></tr>
<tr><td><code id="ResidualModification_+3A_tgm11">tgm11</code></td>
<td>
<p>Trigonometric grey model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>fitted and predicted values
</p>


<h3>References</h3>

<p>Hu Y (2020). Energy Demand Forecasting using a Novel Remnant GM (1, 1) Model. Soft Computing, pp. 13903-13912. DOI:10.1007/s00500-020-04765-3.
<br />
<br />
Zhou P, Ang B, Poh K (2006). A Trigonometric Grey Prediction Approach to Forecasting Electricity Demand. Energy, 31(14), 2839-2847. DOI:10.1016/j.energy.2005.12.002.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # TGM (1, 1) model: Trigonometric grey model

  x0 &lt;- c(2350,2465,2557,2577,2689,2739,2797,2885,2937,2996)
  x0_A &lt;- c(3042,3120,3132,3237)

  x1 &lt;- cumsum(x0)

  n &lt;- length(x0)

  b &lt;- numeric(n)
  for (i in 1:n){
    b[i] &lt;- -(0.5*x1[i + 1] + 0.5*x1[i])
  }
  b1 &lt;- b[1:n-1]

  B &lt;- matrix(1,nrow=n-1,ncol=2)
  B[,1] &lt;- t(t(b1[1:n-1]))

  yn &lt;- matrix(c(x0),ncol=1)
  yn &lt;- t(t(x0[2:n]))

  xcap &lt;- solve (t(B) %*% B) %*% t(B) %*% yn
  a &lt;- xcap[1,1]
  b &lt;- xcap[2,1]

  scale_with &lt;- function(k)
  {
    (x0[1] - (b/a)) * exp(-a*k) * (1 - exp(a))
  }
  fitted &lt;- scale_with(1:n)

  x0cap &lt;- c(x0[1],fitted[1:n-1])

  x0cap_GM &lt;- c(x0cap)

  n &lt;- length(x0)

  r0 &lt;- numeric(n)

  for (i in 1:n){
    r0[i] &lt;-x0[i] - x0cap_GM[i]
  }
  R &lt;- r0[2:n]

  rn &lt;- matrix(c(R),ncol=1)

  m &lt;- length(rn)

  L &lt;- 23

  mat1 &lt;- matrix(1,nrow=n-1,ncol=1)
  mat2 &lt;-matrix(1:m,nrow=m,ncol=1)

  s &lt;- replicate(n,0)
  for (i in 1:n){
    s[i] &lt;- sin( (2*(i-1)*pi)/L )
  }
  mat3 &lt;- matrix(c(s[2:n]),ncol=1)

  c &lt;- replicate(n,0)
  for (i in 1:n){
    c[i] &lt;- cos( (2*(i-1)*pi)/L )
  }
  mat4 &lt;- matrix(c(c[2:n]),ncol=1)

  B &lt;- cbind(mat1,mat2,mat3,mat4)

  rcap &lt;- (solve (t(B) %*% B)) %*% t(B) %*% rn
  b0 &lt;- rcap[1,1]
  b1 &lt;- rcap[2,1]
  b2 &lt;- rcap[3,1]
  b3 &lt;- rcap[4,1]

  scale_with &lt;- function(k)
  {
    b0 + (b1*k) + (b2*sin( (2*pi*k)/L )) + (b3*cos( (2*pi*k)/L ))
  }
  forecast &lt;- scale_with(1:m)

  r0cap &lt;- c(0,forecast)

  xcap_tr &lt;- r0cap + x0cap_GM

  A &lt;- 4
  scale_with &lt;- function(k)
  {
    (x0[1] - (b/a)) * exp(-a*k) * (1 - exp(a))
  }
  fitted_a &lt;- scale_with(1 : n+A-1)

  x0cap_GMa &lt;- c(fitted_a)

  predicted_a &lt;- tail(x0cap_GMa,A)

  n_a &lt;- length(x0_A)

  r0_a &lt;- numeric(n_a)
  for (i in 1:n_a){
    r0_a[i] &lt;-x0_A[i] - x0cap_GMa[i]
  }
  R_a &lt;- r0_a[1:n_a]

  rn_a &lt;- matrix(c(R_a),ncol=1)

  scale_with &lt;- function(k)
  {
    b0 + (b1*k) + (b2*sin( (2*pi*k)/L )) + (b3*cos( (2*pi*k)/L ))
  }
  forecast_a &lt;- scale_with(1:m+A)

  r0cap_a &lt;- tail(forecast_a,A)

  xcap_tra &lt;- r0cap_a +  predicted_a

  x0cap5 &lt;- c(xcap_tra)
  x0cap2 &lt;- c(xcap_tr,x0cap5 )
  # Fitted and predicted values
  x0cap2

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
