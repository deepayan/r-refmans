<!DOCTYPE html><html><head><title>Help for package distanceto</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {distanceto}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#distanceto'><p>distance-to</p></a></li>
<li><a href='#distance_raster'><p>Distance to raster</p></a></li>
<li><a href='#distance_to'><p>Distance to</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Calculate Distance to Features</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Calculates distances from point locations to features.
    The usual approach for eg. resource selection function analyses is to
    generate a complete distance to features surface then sample it with your 
    observed and random points. Since these raster based approaches can be
    pretty costly with large areas, and often lead to memory issues in R, 
    the distanceto package opts to compute these distances using
    efficient, vector based approaches. As a helper, there's a decidedly 
    low-res raster based approach for visually inspecting your region's 
    distance surface. But the workhorse is distance_to.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/robitalec/distance-to">https://github.com/robitalec/distance-to</a>,
<a href="https://robitalec.github.io/distance-to/">https://robitalec.github.io/distance-to/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/robitalec/distance-to/issues">https://github.com/robitalec/distance-to/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>fasterize, knitr, rmarkdown, raster, tinytest, lwgeom</td>
</tr>
<tr>
<td>Imports:</td>
<td>sf, nabor, geodist</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-01 11:43:06 UTC; alecr</td>
</tr>
<tr>
<td>Author:</td>
<td>Alec L. Robitaille
    <a href="https://orcid.org/0000-0002-4706-1762"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alec L. Robitaille &lt;robit.alec@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-01 12:20:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='distanceto'>distance-to</h2><span id='topic+distanceto'></span><span id='topic+_PACKAGE'></span><span id='topic+distanceto-package'></span>

<h3>Description</h3>

<p>The <code>distanceto</code> package is designed to quickly sample distances from points
features to other vector layers. Normally the approach for calculating distance
to (something) involves generating distance surfaces using raster based approaches
eg. <code>raster::distance</code> or <code>gdal_proximity</code> and subsequently point sampling these
surfaces. Since raster based approaches are a costly method that frequently leads
to memory issues or long and slow run times with high resolution data or large
study sites, we have opted to compute these distances using vector based
approaches. As a helper, there's a decidedly low-res raster based approach for
visually inspecting your region's distance surface. But the workhorse is
<code>distance_to</code>.
</p>


<h3>Details</h3>

<p>The <code>distanceto</code> package provides two functions:
</p>

<ul>
<li> <p><code>distance_to</code>
</p>
</li>
<li> <p><code>distance_raster</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Alec L. Robitaille <a href="mailto:robit.alec@gmail.com">robit.alec@gmail.com</a> (<a href="https://orcid.org/0000-0002-4706-1762">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/robitalec/distance-to">https://github.com/robitalec/distance-to</a>
</p>
</li>
<li> <p><a href="https://robitalec.github.io/distance-to/">https://robitalec.github.io/distance-to/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/robitalec/distance-to/issues">https://github.com/robitalec/distance-to/issues</a>
</p>
</li></ul>


<hr>
<h2 id='distance_raster'>Distance to raster</h2><span id='topic+distance_raster'></span>

<h3>Description</h3>

<p>Generates a distance surface from layer <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance_raster(
  y,
  cellsize,
  extent = NULL,
  expand = NULL,
  measure = NULL,
  check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distance_raster_+3A_y">y</code></td>
<td>
<p>feature layer to measure distance to. Expecting an <code>sf</code> point, line
or polygon compatible with <code>sf::st_coordinates</code> such as an <code>sf</code>, <code>sfc</code>
or <code>sfg</code> object.</p>
</td></tr>
<tr><td><code id="distance_raster_+3A_cellsize">cellsize</code></td>
<td>
<p>size, in unit of projection, of pixels of output distance
surface.</p>
</td></tr>
<tr><td><code id="distance_raster_+3A_extent">extent</code></td>
<td>
<p>optional alternative extent bounding box. See details.</p>
</td></tr>
<tr><td><code id="distance_raster_+3A_expand">expand</code></td>
<td>
<p>0-1 scaling eg. 5% expansion = 0.05. See details.</p>
</td></tr>
<tr><td><code id="distance_raster_+3A_measure">measure</code></td>
<td>
<p>method used to measure geographic distances.
See <code>geodist::geodist</code> for more information. Ignored if CRS of <code>y</code>
indicates projected coordinates.</p>
</td></tr>
<tr><td><code id="distance_raster_+3A_check">check</code></td>
<td>
<p>default: TRUE. Checks the cellsize against the size
of the feature layers <code>y</code> bounding box or optional <code>extent</code> argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the distance of each pixel to the features in layer <code>y</code>.
First, generates a regular grid of points in the bounding box of <code>y</code> or
optionally provided
<code>extent</code>. Then measures the distance from each point to the nearest feature
in layer <code>y</code> using <code>distanceto::distance_to()</code>. Finally, returns the grid
of distances, rasterized using the excellent package <code>fasterize</code>.
</p>
<p>Note: this function is intended to provide a rough, low-res look at your
distance surface. The function <code>distanceto::distance_to()</code> should be used
for all precise measurements from points to features, as it avoids the
costly procedure of generating an entire distance surface by calculating
geographic distances directly between points <code>x</code> and features in layer <code>y</code>.
</p>
<p>The features in layer <code>y</code> are expected to be an <code>sf</code> object.
If the input CRS of features in layer <code>y</code> is longlat, eg. EPSG 4326,
the distance is returned as measured by <code>geodist::geodist</code>. Otherwise, if the
input CRS indicates projected coordinates, the distance measured is the
euclidean distance.
</p>
<p>The <code>extent</code> argument can be used to provide an alternative bounding box to
generate the distance surface within. This might be useful, for example, if
your features in layer <code>y</code> are in a larger area than you require or if you'd
like to generate distance surfaces with a specific extent. The <code>expand</code>
argument can be used to expand the bounding box calculated for layer <code>y</code> or
provided by argument <code>extent</code>. This is just a simple multiplier on the min
and max XY of the bounding box to generate a larger surface.
</p>


<h3>Value</h3>

<p>A distance <code>raster</code> surface.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load sf
library(sf)

# Load nc data
nc &lt;- st_read(system.file("shape/nc.shp", package="sf"))

# Select first 5 of nc
ncsub &lt;- nc[1:5,]


# Note: package 'fasterize' required for distance_raster
if (require(fasterize, quietly = TRUE)) {
  # Generate a distance raster from some of nc within extent of all of nc
  distance_raster(ncsub, 0.1, st_bbox(nc), measure = 'geodesic')
}
</code></pre>

<hr>
<h2 id='distance_to'>Distance to</h2><span id='topic+distance_to'></span>

<h3>Description</h3>

<p>Measures the distance from points x to features in layer y.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance_to(x, y, measure = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distance_to_+3A_x">x</code></td>
<td>
<p>points to measure distances from, to layer <code>y</code>. Expecting an <code>sf</code>
point compatible with <code>sf::st_coordinates</code> such as an <code>sf</code>, <code>sfc</code> or
<code>sfg</code> object with geometry type 'POINT' or 'MULTIPOINT'. CRS of <code>x</code>
should match CRS of <code>y</code>.</p>
</td></tr>
<tr><td><code id="distance_to_+3A_y">y</code></td>
<td>
<p>feature layer to measure distance to. Expecting an <code>sf</code> point, line
or polygon compatible with <code>sf::st_coordinates</code> such as an <code>sf</code>, <code>sfc</code>
or <code>sfg</code> object. CRS of <code>y</code> should match CRS of <code>x</code>.</p>
</td></tr>
<tr><td><code id="distance_to_+3A_measure">measure</code></td>
<td>
<p>method used to measure geographic distances between longlat
<code>x</code> and <code>y</code> objects. See <code>geodist::geodist</code> for more information. Ignored if
CRS of <code>x</code> and <code>y</code> indicated projected coordinates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses the function <code>nabor::knn</code> to determine the distance from each point in <code>x</code>
to the nearest feature in layer <code>y</code>. If the input CRS is longlat, eg. EPSG 4326,
the distance is returned as measured by <code>geodist::geodist</code>. Otherwise, if the
input CRS indicates projected coordinates, the distance returned is the
euclidean distance. Both <code>x</code> and <code>y</code> are expected to be <code>sf</code> objects and
the distances are returned as vector, easily added to input <code>x</code> with <code style="white-space: pre;">&#8288;$&lt;-&#8288;</code>
or other methods. If <code>y</code> is a 'POLYGON' or 'MULTIPOLYGON' object, the
distance returned for points in <code>x</code> within features in <code>y</code> are set to 0.
</p>


<h3>Value</h3>

<p>A <code>vector</code> of distances from points in <code>x</code> to features in layer <code>y</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load sf
library(sf)

# Load nc data
nc &lt;- st_read(system.file("shape/nc.shp", package="sf"))

# Set number of sampling points
npts &lt;- 1e3

# Note: package 'lwgeom' required for st_sample
if (require(lwgeom, quietly = TRUE)) {
  # Sample points in nc
  ncpts &lt;- st_sample(nc, npts)

	# Select first 5 of nc
	ncsub &lt;- nc[1:5,]

	# Measure distance from ncpts to first 5 of nc, printing result
	distance_to(ncpts, ncsub, measure = 'geodesic')

	# or add to ncpts
	ncpts$dist &lt;- distance_to(ncpts, ncsub, measure = 'geodesic')
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
