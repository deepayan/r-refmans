<!DOCTYPE html><html><head><title>Help for package mapfit</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mapfit}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mapfit-package'><p>mapfit: PH/MAP Parameter Estimation</p></a></li>
<li><a href='#AERHMMClass'><p>ErlangHMM for MAP with fixed phases</p></a></li>
<li><a href='#AHerlangClass'><p>Hyper-Erlang distribution with a fixed phase</p></a></li>
<li><a href='#as.gph'><p>Convert from HErlang to GPH</p></a></li>
<li><a href='#as.map'><p>Convert from ERHMM to MAP</p></a></li>
<li><a href='#BCpAug89'><p>Packet Trace Data</p></a></li>
<li><a href='#cf1'><p>Create CF1</p></a></li>
<li><a href='#cf1.param'><p>Create CF1 with data information</p></a></li>
<li><a href='#cf1.param.linear'><p>Determine CF1 parameters</p></a></li>
<li><a href='#cf1.param.power'><p>Determine CF1 parameters</p></a></li>
<li><a href='#CF1Class'><p>Canonical phase-type distribution</p></a></li>
<li><a href='#ctmc.st'><p>Markov stationary</p></a></li>
<li><a href='#data.frame.map.group'><p>Create group data for map</p></a></li>
<li><a href='#data.frame.map.time'><p>Create data for map</p></a></li>
<li><a href='#data.frame.phase.group'><p>Create group data for phase</p></a></li>
<li><a href='#data.frame.phase.time'><p>Create data for phase with weighted sample</p></a></li>
<li><a href='#dphase'><p>Probability density function of PH distribution</p></a></li>
<li><a href='#emoptions'><p>EM Options</p></a></li>
<li><a href='#erhmm'><p>Create ERHMM</p></a></li>
<li><a href='#erhmm.param'><p>Determine ERHMM parameters</p></a></li>
<li><a href='#ERHMMClass'><p>ErlangHMM for MAP</p></a></li>
<li><a href='#gmmpp'><p>Create GMMPP</p></a></li>
<li><a href='#GMMPPClass'><p>GMMPP: Approximation for MAP</p></a></li>
<li><a href='#gph.param'><p>Generate GPH using the information on data</p></a></li>
<li><a href='#GPHClass'><p>General phase-type distribution</p></a></li>
<li><a href='#herlang'><p>Create HErlang distribution</p></a></li>
<li><a href='#herlang.param'><p>Determine hyper-Erlang parameters</p></a></li>
<li><a href='#HErlangClass'><p>Hyper-Erlang distribution</p></a></li>
<li><a href='#map'><p>Create MAP</p></a></li>
<li><a href='#map.acf'><p>k-lag correlation of MAP</p></a></li>
<li><a href='#map.jmoment'><p>Joint moments of MAP</p></a></li>
<li><a href='#map.mmoment'><p>Marginal moments of MAP</p></a></li>
<li><a href='#map.param'><p>Generate MAP using the information on data</p></a></li>
<li><a href='#MAPClass'><p>General Markovian arrival process</p></a></li>
<li><a href='#mapfit.group'><p>MAP fitting with grouped data</p></a></li>
<li><a href='#mapfit.point'><p>MAP fitting with point data</p></a></li>
<li><a href='#mmpp'><p>Create an MMPP</p></a></li>
<li><a href='#ph'><p>Create GPH distribution</p></a></li>
<li><a href='#ph.bidiag'><p>Create a bi-diagonal PH distribution</p></a></li>
<li><a href='#ph.coxian'><p>Create a Coxian PH distribution</p></a></li>
<li><a href='#ph.mean'><p>Mean of PH distribution</p></a></li>
<li><a href='#ph.moment'><p>Moments of PH distribution</p></a></li>
<li><a href='#ph.tridiag'><p>Create a tri-diagonal PH distribution</p></a></li>
<li><a href='#ph.var'><p>Variance of PH distribution</p></a></li>
<li><a href='#phfit.3mom'><p>PH fitting with three moments</p></a></li>
<li><a href='#phfit.density'><p>PH fitting with density function</p></a></li>
<li><a href='#phfit.group'><p>PH fitting with grouped data</p></a></li>
<li><a href='#phfit.point'><p>PH fitting with point data</p></a></li>
<li><a href='#pphase'><p>Distribution function of PH distribution</p></a></li>
<li><a href='#rphase'><p>Sampling of PH distributions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Title:</td>
<td>PH/MAP Parameter Estimation</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hiroyuki Okamura &lt;okamu@hiroshima-u.ac.jp&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimation methods for phase-type
  distribution (PH) and Markovian arrival process (MAP) from
  empirical data (point and grouped data) and density function.
  The tool is based on the following researches:
  Okamura et al. (2009) &lt;<a href="https://doi.org/10.1109%2FTNET.2008.2008750">doi:10.1109/TNET.2008.2008750</a>&gt;,
  Okamura and Dohi (2009) &lt;<a href="https://doi.org/10.1109%2FQEST.2009.28">doi:10.1109/QEST.2009.28</a>&gt;,
  Okamura et al. (2011) &lt;<a href="https://doi.org/10.1016%2Fj.peva.2011.04.001">doi:10.1016/j.peva.2011.04.001</a>&gt;,
  Okamura et al. (2013) &lt;<a href="https://doi.org/10.1002%2Fasmb.1919">doi:10.1002/asmb.1919</a>&gt;,
  Horvath and Okamura (2013) &lt;<a href="https://doi.org/10.1007%2F978-3-642-40725-3_10">doi:10.1007/978-3-642-40725-3_10</a>&gt;,
  Okamura and Dohi (2016) &lt;<a href="https://doi.org/10.15807%2Fjorsj.59.72">doi:10.15807/jorsj.59.72</a>&gt;.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>R6, deformula, Matrix, methods, Rcpp</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/okamumu/mapfit">https://github.com/okamumu/mapfit</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/okamumu/mapfit/issues">https://github.com/okamumu/mapfit/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, ggplot2, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-22 08:02:30 UTC; r346502</td>
</tr>
<tr>
<td>Author:</td>
<td>Hiroyuki Okamura <a href="https://orcid.org/0000-0001-6881-0593"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-22 14:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='mapfit-package'>mapfit: PH/MAP Parameter Estimation</h2><span id='topic+mapfit'></span><span id='topic+mapfit-package'></span>

<h3>Description</h3>

<p>Estimation methods for phase-type distribution (PH) and Markovian arrival process (MAP) from empirical data (point and grouped data) and density function. The tool is based on the following researches: Okamura et al. (2009) <a href="https://doi.org/10.1109/TNET.2008.2008750">doi:10.1109/TNET.2008.2008750</a>, Okamura and Dohi (2009) <a href="https://doi.org/10.1109/QEST.2009.28">doi:10.1109/QEST.2009.28</a>, Okamura et al. (2011) <a href="https://doi.org/10.1016/j.peva.2011.04.001">doi:10.1016/j.peva.2011.04.001</a>, Okamura et al. (2013) <a href="https://doi.org/10.1002/asmb.1919">doi:10.1002/asmb.1919</a>, Horvath and Okamura (2013) <a href="https://doi.org/10.1007/978-3-642-40725-3_10">doi:10.1007/978-3-642-40725-3_10</a>, Okamura and Dohi (2016) <a href="https://doi.org/10.15807/jorsj.59.72">doi:10.15807/jorsj.59.72</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Hiroyuki Okamura <a href="mailto:okamu@hiroshima-u.ac.jp">okamu@hiroshima-u.ac.jp</a> (<a href="https://orcid.org/0000-0001-6881-0593">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/okamumu/mapfit">https://github.com/okamumu/mapfit</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/okamumu/mapfit/issues">https://github.com/okamumu/mapfit/issues</a>
</p>
</li></ul>


<hr>
<h2 id='AERHMMClass'>ErlangHMM for MAP with fixed phases</h2><span id='topic+AERHMMClass'></span>

<h3>Description</h3>

<p>ErlangHMM for MAP with fixed phases
</p>
<p>ErlangHMM for MAP with fixed phases
</p>


<h3>Details</h3>

<p>A special case of MAP.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-AERHMMClass-alpha"><code>AERHMMClass$alpha()</code></a>
</p>
</li>
<li> <p><a href="#method-AERHMMClass-shape"><code>AERHMMClass$shape()</code></a>
</p>
</li>
<li> <p><a href="#method-AERHMMClass-rate"><code>AERHMMClass$rate()</code></a>
</p>
</li>
<li> <p><a href="#method-AERHMMClass-P"><code>AERHMMClass$P()</code></a>
</p>
</li>
<li> <p><a href="#method-AERHMMClass-xi"><code>AERHMMClass$xi()</code></a>
</p>
</li>
<li> <p><a href="#method-AERHMMClass-new"><code>AERHMMClass$new()</code></a>
</p>
</li>
<li> <p><a href="#method-AERHMMClass-copy"><code>AERHMMClass$copy()</code></a>
</p>
</li>
<li> <p><a href="#method-AERHMMClass-size"><code>AERHMMClass$size()</code></a>
</p>
</li>
<li> <p><a href="#method-AERHMMClass-df"><code>AERHMMClass$df()</code></a>
</p>
</li>
<li> <p><a href="#method-AERHMMClass-print"><code>AERHMMClass$print()</code></a>
</p>
</li>
<li> <p><a href="#method-AERHMMClass-mmoment"><code>AERHMMClass$mmoment()</code></a>
</p>
</li>
<li> <p><a href="#method-AERHMMClass-jmoment"><code>AERHMMClass$jmoment()</code></a>
</p>
</li>
<li> <p><a href="#method-AERHMMClass-acf"><code>AERHMMClass$acf()</code></a>
</p>
</li>
<li> <p><a href="#method-AERHMMClass-emfit"><code>AERHMMClass$emfit()</code></a>
</p>
</li>
<li> <p><a href="#method-AERHMMClass-init"><code>AERHMMClass$init()</code></a>
</p>
</li>
<li> <p><a href="#method-AERHMMClass-clone"><code>AERHMMClass$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-AERHMMClass-alpha"></a>



<h4>Method <code>alpha()</code></h4>

<p>Get alpha
</p>


<h5>Usage</h5>

<div class="r"><pre>AERHMMClass$alpha()</pre></div>



<h5>Returns</h5>

<p>A vector of alpha
</p>


<hr>
<a id="method-AERHMMClass-shape"></a>



<h4>Method <code>shape()</code></h4>

<p>Get shape
</p>


<h5>Usage</h5>

<div class="r"><pre>AERHMMClass$shape()</pre></div>



<h5>Returns</h5>

<p>A vector of shapes
</p>


<hr>
<a id="method-AERHMMClass-rate"></a>



<h4>Method <code>rate()</code></h4>

<p>Get rate
</p>


<h5>Usage</h5>

<div class="r"><pre>AERHMMClass$rate()</pre></div>



<h5>Returns</h5>

<p>A vector of rates
</p>


<hr>
<a id="method-AERHMMClass-P"></a>



<h4>Method <code>P()</code></h4>

<p>Get P
</p>


<h5>Usage</h5>

<div class="r"><pre>AERHMMClass$P()</pre></div>



<h5>Returns</h5>

<p>A matrix of P
</p>


<hr>
<a id="method-AERHMMClass-xi"></a>



<h4>Method <code>xi()</code></h4>

<p>Get exit rates
</p>


<h5>Usage</h5>

<div class="r"><pre>AERHMMClass$xi()</pre></div>



<h5>Returns</h5>

<p>A vector of exit rates
</p>


<hr>
<a id="method-AERHMMClass-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create an AERHMM
</p>


<h5>Usage</h5>

<div class="r"><pre>AERHMMClass$new(size, erhmm)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>size</code></dt><dd><p>An integer of the number of phases</p>
</dd>
<dt><code>erhmm</code></dt><dd><p>An instance of ERHMM</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An instance of AERHMM
</p>


<hr>
<a id="method-AERHMMClass-copy"></a>



<h4>Method <code>copy()</code></h4>

<p>copy
</p>


<h5>Usage</h5>

<div class="r"><pre>AERHMMClass$copy()</pre></div>



<h5>Returns</h5>

<p>A new instance
</p>


<hr>
<a id="method-AERHMMClass-size"></a>



<h4>Method <code>size()</code></h4>

<p>The number of components
</p>


<h5>Usage</h5>

<div class="r"><pre>AERHMMClass$size()</pre></div>



<h5>Returns</h5>

<p>The number of components
</p>


<hr>
<a id="method-AERHMMClass-df"></a>



<h4>Method <code>df()</code></h4>

<p>Degrees of freedom
</p>


<h5>Usage</h5>

<div class="r"><pre>AERHMMClass$df()</pre></div>



<h5>Returns</h5>

<p>The degrees of freedom
</p>


<hr>
<a id="method-AERHMMClass-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print
</p>


<h5>Usage</h5>

<div class="r"><pre>AERHMMClass$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Others</p>
</dd>
</dl>

</div>


<hr>
<a id="method-AERHMMClass-mmoment"></a>



<h4>Method <code>mmoment()</code></h4>

<p>Marginal moments
</p>


<h5>Usage</h5>

<div class="r"><pre>AERHMMClass$mmoment(k, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>k</code></dt><dd><p>An integer of degree</p>
</dd>
<dt><code>...</code></dt><dd><p>Others</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A vector of moments
</p>


<hr>
<a id="method-AERHMMClass-jmoment"></a>



<h4>Method <code>jmoment()</code></h4>

<p>Joint moments
</p>


<h5>Usage</h5>

<div class="r"><pre>AERHMMClass$jmoment(lag, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>lag</code></dt><dd><p>An integer of lag</p>
</dd>
<dt><code>...</code></dt><dd><p>Others</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A matrix of moments
</p>


<hr>
<a id="method-AERHMMClass-acf"></a>



<h4>Method <code>acf()</code></h4>

<p>k-lag correlation
</p>


<h5>Usage</h5>

<div class="r"><pre>AERHMMClass$acf(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Others</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A vector for k-lag correlation
</p>


<hr>
<a id="method-AERHMMClass-emfit"></a>



<h4>Method <code>emfit()</code></h4>

<p>Run EM
</p>


<h5>Usage</h5>

<div class="r"><pre>AERHMMClass$emfit(data, options, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>A dataframe</p>
</dd>
<dt><code>options</code></dt><dd><p>A list of options</p>
</dd>
<dt><code>...</code></dt><dd><p>Others</p>
</dd>
</dl>

</div>


<hr>
<a id="method-AERHMMClass-init"></a>



<h4>Method <code>init()</code></h4>

<p>Initialize with data
</p>


<h5>Usage</h5>

<div class="r"><pre>AERHMMClass$init(data, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>A dataframe</p>
</dd>
<dt><code>...</code></dt><dd><p>Others</p>
</dd>
<dt><code>options</code></dt><dd><p>A list of options</p>
</dd>
</dl>

</div>


<hr>
<a id="method-AERHMMClass-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>AERHMMClass$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='AHerlangClass'>Hyper-Erlang distribution with a fixed phase</h2><span id='topic+AHerlangClass'></span>

<h3>Description</h3>

<p>Hyper-Erlang distribution with a fixed phase
</p>
<p>Hyper-Erlang distribution with a fixed phase
</p>


<h3>Details</h3>

<p>A mixture of Erlang distributions. A subclass of PH distributions.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-AHerlangClass-mixrate"><code>AHerlangClass$mixrate()</code></a>
</p>
</li>
<li> <p><a href="#method-AHerlangClass-shape"><code>AHerlangClass$shape()</code></a>
</p>
</li>
<li> <p><a href="#method-AHerlangClass-rate"><code>AHerlangClass$rate()</code></a>
</p>
</li>
<li> <p><a href="#method-AHerlangClass-new"><code>AHerlangClass$new()</code></a>
</p>
</li>
<li> <p><a href="#method-AHerlangClass-copy"><code>AHerlangClass$copy()</code></a>
</p>
</li>
<li> <p><a href="#method-AHerlangClass-size"><code>AHerlangClass$size()</code></a>
</p>
</li>
<li> <p><a href="#method-AHerlangClass-df"><code>AHerlangClass$df()</code></a>
</p>
</li>
<li> <p><a href="#method-AHerlangClass-moment"><code>AHerlangClass$moment()</code></a>
</p>
</li>
<li> <p><a href="#method-AHerlangClass-print"><code>AHerlangClass$print()</code></a>
</p>
</li>
<li> <p><a href="#method-AHerlangClass-pdf"><code>AHerlangClass$pdf()</code></a>
</p>
</li>
<li> <p><a href="#method-AHerlangClass-cdf"><code>AHerlangClass$cdf()</code></a>
</p>
</li>
<li> <p><a href="#method-AHerlangClass-ccdf"><code>AHerlangClass$ccdf()</code></a>
</p>
</li>
<li> <p><a href="#method-AHerlangClass-sample"><code>AHerlangClass$sample()</code></a>
</p>
</li>
<li> <p><a href="#method-AHerlangClass-emfit"><code>AHerlangClass$emfit()</code></a>
</p>
</li>
<li> <p><a href="#method-AHerlangClass-init"><code>AHerlangClass$init()</code></a>
</p>
</li>
<li> <p><a href="#method-AHerlangClass-clone"><code>AHerlangClass$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-AHerlangClass-mixrate"></a>



<h4>Method <code>mixrate()</code></h4>

<p>Get mixrate
</p>


<h5>Usage</h5>

<div class="r"><pre>AHerlangClass$mixrate()</pre></div>



<h5>Returns</h5>

<p>A vector of mixrate
</p>


<hr>
<a id="method-AHerlangClass-shape"></a>



<h4>Method <code>shape()</code></h4>

<p>Get shape
</p>


<h5>Usage</h5>

<div class="r"><pre>AHerlangClass$shape()</pre></div>



<h5>Returns</h5>

<p>A vector of shapes
</p>


<hr>
<a id="method-AHerlangClass-rate"></a>



<h4>Method <code>rate()</code></h4>

<p>Get rate
</p>


<h5>Usage</h5>

<div class="r"><pre>AHerlangClass$rate()</pre></div>



<h5>Returns</h5>

<p>A vector of rates
</p>


<hr>
<a id="method-AHerlangClass-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a hyper-Erlang distribution with fixed phases
</p>


<h5>Usage</h5>

<div class="r"><pre>AHerlangClass$new(size, herlang)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>size</code></dt><dd><p>An integer of the number of phases</p>
</dd>
<dt><code>herlang</code></dt><dd><p>An instance of HErlang</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An instance of AHerlang
</p>


<hr>
<a id="method-AHerlangClass-copy"></a>



<h4>Method <code>copy()</code></h4>

<p>copy
</p>


<h5>Usage</h5>

<div class="r"><pre>AHerlangClass$copy()</pre></div>



<h5>Returns</h5>

<p>A new instance
</p>


<hr>
<a id="method-AHerlangClass-size"></a>



<h4>Method <code>size()</code></h4>

<p>The number of components
</p>


<h5>Usage</h5>

<div class="r"><pre>AHerlangClass$size()</pre></div>



<h5>Returns</h5>

<p>The number of components
</p>


<hr>
<a id="method-AHerlangClass-df"></a>



<h4>Method <code>df()</code></h4>

<p>Degrees of freedom
</p>


<h5>Usage</h5>

<div class="r"><pre>AHerlangClass$df()</pre></div>



<h5>Returns</h5>

<p>The degrees of freedom
</p>


<hr>
<a id="method-AHerlangClass-moment"></a>



<h4>Method <code>moment()</code></h4>

<p>Moments of HErlang
</p>


<h5>Usage</h5>

<div class="r"><pre>AHerlangClass$moment(k, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>k</code></dt><dd><p>A value to indicate the degrees of moments. k-th moment</p>
</dd>
<dt><code>...</code></dt><dd><p>Others</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A vector of moments from 1st to k-th moments
</p>


<hr>
<a id="method-AHerlangClass-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print
</p>


<h5>Usage</h5>

<div class="r"><pre>AHerlangClass$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Others</p>
</dd>
</dl>

</div>


<hr>
<a id="method-AHerlangClass-pdf"></a>



<h4>Method <code>pdf()</code></h4>

<p>PDF
</p>


<h5>Usage</h5>

<div class="r"><pre>AHerlangClass$pdf(x, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>A vector of points</p>
</dd>
<dt><code>...</code></dt><dd><p>Others</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A vector of densities.
</p>


<hr>
<a id="method-AHerlangClass-cdf"></a>



<h4>Method <code>cdf()</code></h4>

<p>CDF
</p>


<h5>Usage</h5>

<div class="r"><pre>AHerlangClass$cdf(q, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>q</code></dt><dd><p>A vector of points</p>
</dd>
<dt><code>...</code></dt><dd><p>Others</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A vector of probabilities
</p>


<hr>
<a id="method-AHerlangClass-ccdf"></a>



<h4>Method <code>ccdf()</code></h4>

<p>Complementary CDF
</p>


<h5>Usage</h5>

<div class="r"><pre>AHerlangClass$ccdf(q, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>q</code></dt><dd><p>A vector of points</p>
</dd>
<dt><code>...</code></dt><dd><p>Others</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A vector of probabilities
</p>


<hr>
<a id="method-AHerlangClass-sample"></a>



<h4>Method <code>sample()</code></h4>

<p>Make a sample
</p>


<h5>Usage</h5>

<div class="r"><pre>AHerlangClass$sample(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Others</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A sample of HErlang
</p>


<hr>
<a id="method-AHerlangClass-emfit"></a>



<h4>Method <code>emfit()</code></h4>

<p>Run EM
</p>


<h5>Usage</h5>

<div class="r"><pre>AHerlangClass$emfit(data, options, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>A dataframe</p>
</dd>
<dt><code>options</code></dt><dd><p>A list of options</p>
</dd>
<dt><code>...</code></dt><dd><p>Others</p>
</dd>
</dl>

</div>


<hr>
<a id="method-AHerlangClass-init"></a>



<h4>Method <code>init()</code></h4>

<p>Initialize with data
</p>


<h5>Usage</h5>

<div class="r"><pre>AHerlangClass$init(data, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>A dataframe</p>
</dd>
<dt><code>...</code></dt><dd><p>Others</p>
</dd>
<dt><code>options</code></dt><dd><p>A list of options</p>
</dd>
</dl>

</div>


<hr>
<a id="method-AHerlangClass-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>AHerlangClass$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='as.gph'>Convert from HErlang to GPH</h2><span id='topic+as.gph'></span>

<h3>Description</h3>

<p>Convert from hyper-Erlang distribution to the general PH distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.gph(h)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.gph_+3A_h">h</code></td>
<td>
<p>An instance of HErlang</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of GPH
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#' ## create a hyper Erlang with specific parameters
(param &lt;- herlang(shape=c(2,3), mixrate=c(0.3,0.7), rate=c(1.0,10.0)))

## convert to a general PH
as.gph(param)

</code></pre>

<hr>
<h2 id='as.map'>Convert from ERHMM to MAP</h2><span id='topic+as.map'></span>

<h3>Description</h3>

<p>Convert from ERHMM to the general MAP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.map(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.map_+3A_x">x</code></td>
<td>
<p>An instance of ERHMM</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of MAP
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create a hyper Erlang with specific parameters
(param &lt;- erhmm(shape=c(2,3), alpha=c(0.3,0.7), rate=c(1.0,10.0)))

## convert to a general PH
as.map(param)

</code></pre>

<hr>
<h2 id='BCpAug89'>Packet Trace Data</h2><span id='topic+BCpAug89'></span>

<h3>Description</h3>

<p>The data contains packet arrivals seen on an Ethernet at the Bellcore
Morristown Research and Engineering facility. Two of the traces are LAN
traffic (with a small portion of transit WAN traffic), and two are WAN
traffic. The original trace BC-pAug89 began at 11:25 on August 29, 1989,
and ran for about 3142.82 seconds (until 1,000,000 packets had been captured).
The trace BC-pOct89 began at 11:00 on October 5, 1989, and ran for about
1759.62 seconds. These two traces captured all Ethernet packets.
The number of arrivals in the original trace is one million.
</p>


<h3>Format</h3>

<p><code>BCpAug89</code> is a vector for the inter-arrival time in seconds for 1000 arrivals.
</p>


<h3>Source</h3>

<p>The original trace data are published in http://ita.ee.lbl.gov/html/contrib/BC.html.
</p>

<hr>
<h2 id='cf1'>Create CF1</h2><span id='topic+cf1'></span>

<h3>Description</h3>

<p>Create an instance of CF1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cf1(size, alpha, rate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cf1_+3A_size">size</code></td>
<td>
<p>An integer of the number of phases</p>
</td></tr>
<tr><td><code id="cf1_+3A_alpha">alpha</code></td>
<td>
<p>A vector of initial probabilities</p>
</td></tr>
<tr><td><code id="cf1_+3A_rate">rate</code></td>
<td>
<p>A vector of rates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of CF1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create a CF1 with 5 phases
(param1 &lt;- cf1(5))

## create a CF1 with 5 phases
(param1 &lt;- cf1(size=5))

## create a CF1 with specific parameters
(param2 &lt;- cf1(alpha=c(1,0,0), rate=c(1.0,2.0,3.0)))

</code></pre>

<hr>
<h2 id='cf1.param'>Create CF1 with data information</h2><span id='topic+cf1.param'></span>

<h3>Description</h3>

<p>Crate CF1 with the first moment of a given data. This function calls cf1.param.linear
and cf1.param.power to determine CF1. After execute 5 EM steps, the model with the smallest
LLF is selected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cf1.param(data, size, options, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cf1.param_+3A_data">data</code></td>
<td>
<p>A dataframe</p>
</td></tr>
<tr><td><code id="cf1.param_+3A_size">size</code></td>
<td>
<p>An integer for the number of phases</p>
</td></tr>
<tr><td><code id="cf1.param_+3A_options">options</code></td>
<td>
<p>A list of options for EM steps</p>
</td></tr>
<tr><td><code id="cf1.param_+3A_...">...</code></td>
<td>
<p>Others. This can provide additional options for EM steps.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate group data
dat &lt;- data.frame.phase.group(c(1,2,0,4), seq(0,10,length.out=5))

## Create an instance of CF1
p &lt;- cf1.param(data=dat, size=5)

</code></pre>

<hr>
<h2 id='cf1.param.linear'>Determine CF1 parameters</h2><span id='topic+cf1.param.linear'></span>

<h3>Description</h3>

<p>Determine CF1 parameters based on the linear rule.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cf1.param.linear(size, mean, s)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cf1.param.linear_+3A_size">size</code></td>
<td>
<p>An integer of the number of phases</p>
</td></tr>
<tr><td><code id="cf1.param.linear_+3A_mean">mean</code></td>
<td>
<p>A value of mean of data</p>
</td></tr>
<tr><td><code id="cf1.param.linear_+3A_s">s</code></td>
<td>
<p>A value of fraction of minimum and maximum rates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of alpha and rate
</p>

<hr>
<h2 id='cf1.param.power'>Determine CF1 parameters</h2><span id='topic+cf1.param.power'></span>

<h3>Description</h3>

<p>Determine CF1 parameters based on the power rule.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cf1.param.power(size, mean, s)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cf1.param.power_+3A_size">size</code></td>
<td>
<p>An integer of the number of phases</p>
</td></tr>
<tr><td><code id="cf1.param.power_+3A_mean">mean</code></td>
<td>
<p>A value of mean of data</p>
</td></tr>
<tr><td><code id="cf1.param.power_+3A_s">s</code></td>
<td>
<p>A value of fraction of minimum and maximum rates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of alpha and rate
</p>

<hr>
<h2 id='CF1Class'>Canonical phase-type distribution</h2><span id='topic+CF1Class'></span>

<h3>Description</h3>

<p>Canonical phase-type distribution
</p>
<p>Canonical phase-type distribution
</p>


<h3>Details</h3>

<p>A continuous distribution dominated by a continuous-time Markov chain.
A random time is given by an absorbing time. In the CF1 (canonical form 1),
the infinitesimal generator is given by a bi-diagonal matrix, and whose order
is determined by the ascending order.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+GPHClass">mapfit::GPHClass</a></code> -&gt; <code>CF1Class</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-CF1Class-rate"><code>CF1Class$rate()</code></a>
</p>
</li>
<li> <p><a href="#method-CF1Class-new"><code>CF1Class$new()</code></a>
</p>
</li>
<li> <p><a href="#method-CF1Class-copy"><code>CF1Class$copy()</code></a>
</p>
</li>
<li> <p><a href="#method-CF1Class-print"><code>CF1Class$print()</code></a>
</p>
</li>
<li> <p><a href="#method-CF1Class-sample"><code>CF1Class$sample()</code></a>
</p>
</li>
<li> <p><a href="#method-CF1Class-emfit"><code>CF1Class$emfit()</code></a>
</p>
</li>
<li> <p><a href="#method-CF1Class-init"><code>CF1Class$init()</code></a>
</p>
</li>
<li> <p><a href="#method-CF1Class-clone"><code>CF1Class$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mapfit" data-topic="GPHClass" data-id="Q"><a href='../../mapfit/html/GPHClass.html#method-GPHClass-Q'><code>mapfit::GPHClass$Q()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mapfit" data-topic="GPHClass" data-id="alpha"><a href='../../mapfit/html/GPHClass.html#method-GPHClass-alpha'><code>mapfit::GPHClass$alpha()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mapfit" data-topic="GPHClass" data-id="ccdf"><a href='../../mapfit/html/GPHClass.html#method-GPHClass-ccdf'><code>mapfit::GPHClass$ccdf()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mapfit" data-topic="GPHClass" data-id="cdf"><a href='../../mapfit/html/GPHClass.html#method-GPHClass-cdf'><code>mapfit::GPHClass$cdf()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mapfit" data-topic="GPHClass" data-id="df"><a href='../../mapfit/html/GPHClass.html#method-GPHClass-df'><code>mapfit::GPHClass$df()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mapfit" data-topic="GPHClass" data-id="moment"><a href='../../mapfit/html/GPHClass.html#method-GPHClass-moment'><code>mapfit::GPHClass$moment()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mapfit" data-topic="GPHClass" data-id="pdf"><a href='../../mapfit/html/GPHClass.html#method-GPHClass-pdf'><code>mapfit::GPHClass$pdf()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mapfit" data-topic="GPHClass" data-id="size"><a href='../../mapfit/html/GPHClass.html#method-GPHClass-size'><code>mapfit::GPHClass$size()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mapfit" data-topic="GPHClass" data-id="xi"><a href='../../mapfit/html/GPHClass.html#method-GPHClass-xi'><code>mapfit::GPHClass$xi()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-CF1Class-rate"></a>



<h4>Method <code>rate()</code></h4>

<p>Get rate
</p>


<h5>Usage</h5>

<div class="r"><pre>CF1Class$rate()</pre></div>



<h5>Returns</h5>

<p>An instance of rate
</p>


<hr>
<a id="method-CF1Class-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a CF1
</p>


<h5>Usage</h5>

<div class="r"><pre>CF1Class$new(alpha, rate)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>alpha</code></dt><dd><p>A vector of initial probability</p>
</dd>
<dt><code>rate</code></dt><dd><p>A vector of rates</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An instance of CF1
</p>


<hr>
<a id="method-CF1Class-copy"></a>



<h4>Method <code>copy()</code></h4>

<p>copy
</p>


<h5>Usage</h5>

<div class="r"><pre>CF1Class$copy()</pre></div>



<h5>Returns</h5>

<p>A new instance
</p>


<hr>
<a id="method-CF1Class-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print
</p>


<h5>Usage</h5>

<div class="r"><pre>CF1Class$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Others</p>
</dd>
</dl>

</div>


<hr>
<a id="method-CF1Class-sample"></a>



<h4>Method <code>sample()</code></h4>

<p>Generate a sample of CF1
</p>


<h5>Usage</h5>

<div class="r"><pre>CF1Class$sample(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Others</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A sample of CF1
</p>


<hr>
<a id="method-CF1Class-emfit"></a>



<h4>Method <code>emfit()</code></h4>

<p>Run EM
</p>


<h5>Usage</h5>

<div class="r"><pre>CF1Class$emfit(data, options, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>A dataframe</p>
</dd>
<dt><code>options</code></dt><dd><p>A list of options</p>
</dd>
<dt><code>...</code></dt><dd><p>Others</p>
</dd>
</dl>

</div>


<hr>
<a id="method-CF1Class-init"></a>



<h4>Method <code>init()</code></h4>

<p>Initialize with data
</p>


<h5>Usage</h5>

<div class="r"><pre>CF1Class$init(data, options, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>A dataframe</p>
</dd>
<dt><code>options</code></dt><dd><p>A list of options</p>
</dd>
<dt><code>...</code></dt><dd><p>Others</p>
</dd>
</dl>

</div>


<hr>
<a id="method-CF1Class-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>CF1Class$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='ctmc.st'>Markov stationary</h2><span id='topic+ctmc.st'></span>

<h3>Description</h3>

<p>Compute the stationary vector with GTH
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctmc.st(Q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctmc.st_+3A_q">Q</code></td>
<td>
<p>DTMC/CTMC kernel</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The stationary vector of DTMC/CTMC
</p>

<hr>
<h2 id='data.frame.map.group'>Create group data for map</h2><span id='topic+data.frame.map.group'></span>

<h3>Description</h3>

<p>Provide the data.frame for group data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.frame.map.group(counts, breaks, intervals, instants)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data.frame.map.group_+3A_counts">counts</code></td>
<td>
<p>A vector of the number of samples</p>
</td></tr>
<tr><td><code id="data.frame.map.group_+3A_breaks">breaks</code></td>
<td>
<p>A vector of break points</p>
</td></tr>
<tr><td><code id="data.frame.map.group_+3A_intervals">intervals</code></td>
<td>
<p>A vector of differences of time</p>
</td></tr>
<tr><td><code id="data.frame.map.group_+3A_instants">instants</code></td>
<td>
<p>A vector meaning whether a sample is observed at the end of break.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t &lt;- c(1,1,1,1,1)
n &lt;- c(1,3,0,0,1)

dat &lt;- data.frame.map.group(counts=n, intervals=t)
mean(dat)
print(dat)

</code></pre>

<hr>
<h2 id='data.frame.map.time'>Create data for map</h2><span id='topic+data.frame.map.time'></span>

<h3>Description</h3>

<p>Provide a data.frame with samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.frame.map.time(time, intervals)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data.frame.map.time_+3A_time">time</code></td>
<td>
<p>A vector for cumulative time</p>
</td></tr>
<tr><td><code id="data.frame.map.time_+3A_intervals">intervals</code></td>
<td>
<p>A vector for time intervals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe
</p>


<h3>Note</h3>


<ul>
<li><p> If both time and intervals are used, time is used.
</p>
</li>
<li><p> map.time is given by a special case of map.group.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(10)

dat &lt;- data.frame.map.time(time=x)
mean(dat)
print(dat)

</code></pre>

<hr>
<h2 id='data.frame.phase.group'>Create group data for phase</h2><span id='topic+data.frame.phase.group'></span>

<h3>Description</h3>

<p>Provide the data.frame for group data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.frame.phase.group(counts, breaks, intervals, instants)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data.frame.phase.group_+3A_counts">counts</code></td>
<td>
<p>A vector of the number of samples</p>
</td></tr>
<tr><td><code id="data.frame.phase.group_+3A_breaks">breaks</code></td>
<td>
<p>A vector of break points</p>
</td></tr>
<tr><td><code id="data.frame.phase.group_+3A_intervals">intervals</code></td>
<td>
<p>A vector of differences of time</p>
</td></tr>
<tr><td><code id="data.frame.phase.group_+3A_instants">instants</code></td>
<td>
<p>A vector meaning whether a sample is observed at the end of break.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- data.frame.phase.group(counts=c(1,2,1,1,0,0,1,4))
print(dat)
mean(dat)

</code></pre>

<hr>
<h2 id='data.frame.phase.time'>Create data for phase with weighted sample</h2><span id='topic+data.frame.phase.time'></span>

<h3>Description</h3>

<p>Provide a data.frame with weighted samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.frame.phase.time(x, weights)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data.frame.phase.time_+3A_x">x</code></td>
<td>
<p>A vector of point (quantiles)</p>
</td></tr>
<tr><td><code id="data.frame.phase.time_+3A_weights">weights</code></td>
<td>
<p>A vector of weights</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe
</p>


<h3>Note</h3>

<p>The point time is sorted and their differences are stored as the column of <code>time</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(10)
w &lt;- runif(10)

dat &lt;- data.frame.phase.time(x=x, weights=w)
print(dat)
mean(dat)

</code></pre>

<hr>
<h2 id='dphase'>Probability density function of PH distribution</h2><span id='topic+dphase'></span>

<h3>Description</h3>

<p>Compute the probability density function (p.d.f.) for a given PH distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dphase(x, ph, log = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dphase_+3A_x">x</code></td>
<td>
<p>A numeric vector of quantiles.</p>
</td></tr>
<tr><td><code id="dphase_+3A_ph">ph</code></td>
<td>
<p>An instance of PH distribution.</p>
</td></tr>
<tr><td><code id="dphase_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, densities y are returned as log(y)</p>
</td></tr>
<tr><td><code id="dphase_+3A_...">...</code></td>
<td>
<p>Others.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of densities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create a PH with specific parameters
(phdist &lt;- ph(alpha=c(1,0,0),
              Q=rbind(c(-4,2,0),c(2,-5,1),c(1,0,-1)),
              xi=c(2,2,0)))

## p.d.f. for 0, 0.1, ..., 1
dphase(x=seq(0, 1, 0.1), ph=phdist)

</code></pre>

<hr>
<h2 id='emoptions'>EM Options</h2><span id='topic+emoptions'></span>

<h3>Description</h3>

<p>A list of options for EM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emoptions()
</code></pre>


<h3>Value</h3>

<p>A list of options with default values
</p>

<hr>
<h2 id='erhmm'>Create ERHMM</h2><span id='topic+erhmm'></span>

<h3>Description</h3>

<p>Create an instance of ERHMM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>erhmm(
  size,
  shape,
  alpha = rep(1/length(shape), length(shape)),
  rate = rep(1, length(shape)),
  P = matrix(1/length(shape), length(shape), length(shape))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="erhmm_+3A_size">size</code></td>
<td>
<p>An integer of the number of phases</p>
</td></tr>
<tr><td><code id="erhmm_+3A_shape">shape</code></td>
<td>
<p>A vector of shape parameters</p>
</td></tr>
<tr><td><code id="erhmm_+3A_alpha">alpha</code></td>
<td>
<p>A vector of initial probability (alpha)</p>
</td></tr>
<tr><td><code id="erhmm_+3A_rate">rate</code></td>
<td>
<p>A vector of rate parameters</p>
</td></tr>
<tr><td><code id="erhmm_+3A_p">P</code></td>
<td>
<p>A matrix of transition probabilities</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of ERHMM
</p>


<h3>Note</h3>

<p>If shape is given, shape is used even though size is set.
</p>

<hr>
<h2 id='erhmm.param'>Determine ERHMM parameters</h2><span id='topic+erhmm.param'></span>

<h3>Description</h3>

<p>Determine ERHMM parameters with k-means.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>erhmm.param(data, skel, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="erhmm.param_+3A_data">data</code></td>
<td>
<p>A dataframe</p>
</td></tr>
<tr><td><code id="erhmm.param_+3A_skel">skel</code></td>
<td>
<p>An instance of ERHMM used as a skeleton</p>
</td></tr>
<tr><td><code id="erhmm.param_+3A_...">...</code></td>
<td>
<p>Others</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of ERHMM
</p>

<hr>
<h2 id='ERHMMClass'>ErlangHMM for MAP</h2><span id='topic+ERHMMClass'></span>

<h3>Description</h3>

<p>ErlangHMM for MAP
</p>
<p>ErlangHMM for MAP
</p>


<h3>Details</h3>

<p>A special case of MAP.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ERHMMClass-alpha"><code>ERHMMClass$alpha()</code></a>
</p>
</li>
<li> <p><a href="#method-ERHMMClass-shape"><code>ERHMMClass$shape()</code></a>
</p>
</li>
<li> <p><a href="#method-ERHMMClass-rate"><code>ERHMMClass$rate()</code></a>
</p>
</li>
<li> <p><a href="#method-ERHMMClass-P"><code>ERHMMClass$P()</code></a>
</p>
</li>
<li> <p><a href="#method-ERHMMClass-xi"><code>ERHMMClass$xi()</code></a>
</p>
</li>
<li> <p><a href="#method-ERHMMClass-new"><code>ERHMMClass$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ERHMMClass-copy"><code>ERHMMClass$copy()</code></a>
</p>
</li>
<li> <p><a href="#method-ERHMMClass-size"><code>ERHMMClass$size()</code></a>
</p>
</li>
<li> <p><a href="#method-ERHMMClass-df"><code>ERHMMClass$df()</code></a>
</p>
</li>
<li> <p><a href="#method-ERHMMClass-print"><code>ERHMMClass$print()</code></a>
</p>
</li>
<li> <p><a href="#method-ERHMMClass-mmoment"><code>ERHMMClass$mmoment()</code></a>
</p>
</li>
<li> <p><a href="#method-ERHMMClass-jmoment"><code>ERHMMClass$jmoment()</code></a>
</p>
</li>
<li> <p><a href="#method-ERHMMClass-acf"><code>ERHMMClass$acf()</code></a>
</p>
</li>
<li> <p><a href="#method-ERHMMClass-emfit"><code>ERHMMClass$emfit()</code></a>
</p>
</li>
<li> <p><a href="#method-ERHMMClass-init"><code>ERHMMClass$init()</code></a>
</p>
</li>
<li> <p><a href="#method-ERHMMClass-clone"><code>ERHMMClass$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-ERHMMClass-alpha"></a>



<h4>Method <code>alpha()</code></h4>

<p>Get alpha
</p>


<h5>Usage</h5>

<div class="r"><pre>ERHMMClass$alpha()</pre></div>



<h5>Returns</h5>

<p>A vector of alpha
</p>


<hr>
<a id="method-ERHMMClass-shape"></a>



<h4>Method <code>shape()</code></h4>

<p>Get shape
</p>


<h5>Usage</h5>

<div class="r"><pre>ERHMMClass$shape()</pre></div>



<h5>Returns</h5>

<p>A vector of shapes
</p>


<hr>
<a id="method-ERHMMClass-rate"></a>



<h4>Method <code>rate()</code></h4>

<p>Get rate
</p>


<h5>Usage</h5>

<div class="r"><pre>ERHMMClass$rate()</pre></div>



<h5>Returns</h5>

<p>A vector of rates
</p>


<hr>
<a id="method-ERHMMClass-P"></a>



<h4>Method <code>P()</code></h4>

<p>Get P
</p>


<h5>Usage</h5>

<div class="r"><pre>ERHMMClass$P()</pre></div>



<h5>Returns</h5>

<p>A matrix of P
</p>


<hr>
<a id="method-ERHMMClass-xi"></a>



<h4>Method <code>xi()</code></h4>

<p>Get exit rates
</p>


<h5>Usage</h5>

<div class="r"><pre>ERHMMClass$xi()</pre></div>



<h5>Returns</h5>

<p>A vector of exit rates
</p>


<hr>
<a id="method-ERHMMClass-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create an ERHMM
</p>


<h5>Usage</h5>

<div class="r"><pre>ERHMMClass$new(alpha, shape, rate, P, xi)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>alpha</code></dt><dd><p>A vector of initial probability</p>
</dd>
<dt><code>shape</code></dt><dd><p>A vector of shape parameters</p>
</dd>
<dt><code>rate</code></dt><dd><p>A vector of rate parameters</p>
</dd>
<dt><code>P</code></dt><dd><p>A matrix of transition probabilities</p>
</dd>
<dt><code>xi</code></dt><dd><p>An exit rate vector</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An instance of ERHMM
</p>


<hr>
<a id="method-ERHMMClass-copy"></a>



<h4>Method <code>copy()</code></h4>

<p>copy
</p>


<h5>Usage</h5>

<div class="r"><pre>ERHMMClass$copy()</pre></div>



<h5>Returns</h5>

<p>A new instance
</p>


<hr>
<a id="method-ERHMMClass-size"></a>



<h4>Method <code>size()</code></h4>

<p>The number of components
</p>


<h5>Usage</h5>

<div class="r"><pre>ERHMMClass$size()</pre></div>



<h5>Returns</h5>

<p>The number of components
</p>


<hr>
<a id="method-ERHMMClass-df"></a>



<h4>Method <code>df()</code></h4>

<p>Degrees of freedom
</p>


<h5>Usage</h5>

<div class="r"><pre>ERHMMClass$df()</pre></div>



<h5>Returns</h5>

<p>The degrees of freedom
</p>


<hr>
<a id="method-ERHMMClass-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print
</p>


<h5>Usage</h5>

<div class="r"><pre>ERHMMClass$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Others</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ERHMMClass-mmoment"></a>



<h4>Method <code>mmoment()</code></h4>

<p>Marginal moments
</p>


<h5>Usage</h5>

<div class="r"><pre>ERHMMClass$mmoment(k, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>k</code></dt><dd><p>An integer of degree</p>
</dd>
<dt><code>...</code></dt><dd><p>Others</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A vector of moments
</p>


<hr>
<a id="method-ERHMMClass-jmoment"></a>



<h4>Method <code>jmoment()</code></h4>

<p>Joint moments
</p>


<h5>Usage</h5>

<div class="r"><pre>ERHMMClass$jmoment(lag, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>lag</code></dt><dd><p>An integer of lag</p>
</dd>
<dt><code>...</code></dt><dd><p>Others</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A matrix of moments
</p>


<hr>
<a id="method-ERHMMClass-acf"></a>



<h4>Method <code>acf()</code></h4>

<p>k-lag correlation
</p>


<h5>Usage</h5>

<div class="r"><pre>ERHMMClass$acf(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Others</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A vector for k-lag correlation
</p>


<hr>
<a id="method-ERHMMClass-emfit"></a>



<h4>Method <code>emfit()</code></h4>

<p>Run EM
</p>


<h5>Usage</h5>

<div class="r"><pre>ERHMMClass$emfit(data, options, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>A dataframe</p>
</dd>
<dt><code>options</code></dt><dd><p>A list of options</p>
</dd>
<dt><code>...</code></dt><dd><p>Others</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ERHMMClass-init"></a>



<h4>Method <code>init()</code></h4>

<p>Initialize with data
</p>


<h5>Usage</h5>

<div class="r"><pre>ERHMMClass$init(data, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>A dataframe</p>
</dd>
<dt><code>...</code></dt><dd><p>Others</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ERHMMClass-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ERHMMClass$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='gmmpp'>Create GMMPP</h2><span id='topic+gmmpp'></span>

<h3>Description</h3>

<p>Create an instance of GMMPP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmmpp(size, alpha, D0, D1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gmmpp_+3A_size">size</code></td>
<td>
<p>An integer for the number of phases</p>
</td></tr>
<tr><td><code id="gmmpp_+3A_alpha">alpha</code></td>
<td>
<p>A vector of initial probability</p>
</td></tr>
<tr><td><code id="gmmpp_+3A_d0">D0</code></td>
<td>
<p>An infinitesimal generator without arrivals</p>
</td></tr>
<tr><td><code id="gmmpp_+3A_d1">D1</code></td>
<td>
<p>An infinitesimal generator with arrivals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of GMMPP
</p>


<h3>Note</h3>

<p>This function can omit several patterns of arguments. For example, <code>map(5)</code>
omit the arguments <code>alpha</code>, <code>Q</code> and <code>xi</code>. In this case, the default values are
assigned to them.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create a map (full matrix) with 5 phases
(param1 &lt;- gmmpp(5))

## create a map with specific parameters
(param2 &lt;- gmmpp(alpha=c(1,0,0),
              D0=rbind(c(-4,2,0),c(2,-5,1),c(1,0,-1)),
              D1=rbind(c(2,0,0),c(0,2,0),c(0,0,0))))

</code></pre>

<hr>
<h2 id='GMMPPClass'>GMMPP: Approximation for MAP</h2><span id='topic+GMMPPClass'></span>

<h3>Description</h3>

<p>GMMPP: Approximation for MAP
</p>
<p>GMMPP: Approximation for MAP
</p>


<h3>Details</h3>

<p>A point process dominated by a continuous-time Markov chain.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+MAPClass">mapfit::MAPClass</a></code> -&gt; <code>GMMPPClass</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GMMPPClass-new"><code>GMMPPClass$new()</code></a>
</p>
</li>
<li> <p><a href="#method-GMMPPClass-copy"><code>GMMPPClass$copy()</code></a>
</p>
</li>
<li> <p><a href="#method-GMMPPClass-emfit"><code>GMMPPClass$emfit()</code></a>
</p>
</li>
<li> <p><a href="#method-GMMPPClass-clone"><code>GMMPPClass$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mapfit" data-topic="MAPClass" data-id="D0"><a href='../../mapfit/html/MAPClass.html#method-MAPClass-D0'><code>mapfit::MAPClass$D0()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mapfit" data-topic="MAPClass" data-id="D1"><a href='../../mapfit/html/MAPClass.html#method-MAPClass-D1'><code>mapfit::MAPClass$D1()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mapfit" data-topic="MAPClass" data-id="acf"><a href='../../mapfit/html/MAPClass.html#method-MAPClass-acf'><code>mapfit::MAPClass$acf()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mapfit" data-topic="MAPClass" data-id="alpha"><a href='../../mapfit/html/MAPClass.html#method-MAPClass-alpha'><code>mapfit::MAPClass$alpha()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mapfit" data-topic="MAPClass" data-id="df"><a href='../../mapfit/html/MAPClass.html#method-MAPClass-df'><code>mapfit::MAPClass$df()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mapfit" data-topic="MAPClass" data-id="init"><a href='../../mapfit/html/MAPClass.html#method-MAPClass-init'><code>mapfit::MAPClass$init()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mapfit" data-topic="MAPClass" data-id="jmoment"><a href='../../mapfit/html/MAPClass.html#method-MAPClass-jmoment'><code>mapfit::MAPClass$jmoment()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mapfit" data-topic="MAPClass" data-id="mmoment"><a href='../../mapfit/html/MAPClass.html#method-MAPClass-mmoment'><code>mapfit::MAPClass$mmoment()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mapfit" data-topic="MAPClass" data-id="print"><a href='../../mapfit/html/MAPClass.html#method-MAPClass-print'><code>mapfit::MAPClass$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mapfit" data-topic="MAPClass" data-id="size"><a href='../../mapfit/html/MAPClass.html#method-MAPClass-size'><code>mapfit::MAPClass$size()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mapfit" data-topic="MAPClass" data-id="xi"><a href='../../mapfit/html/MAPClass.html#method-MAPClass-xi'><code>mapfit::MAPClass$xi()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-GMMPPClass-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a MAP
</p>


<h5>Usage</h5>

<div class="r"><pre>GMMPPClass$new(alpha, D0, D1, xi)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>alpha</code></dt><dd><p>A vector of initial probability</p>
</dd>
<dt><code>D0</code></dt><dd><p>An infinitesimal generator</p>
</dd>
<dt><code>D1</code></dt><dd><p>An infinitesimal generator</p>
</dd>
<dt><code>xi</code></dt><dd><p>An exit rate vector</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An instance of MAP
</p>


<hr>
<a id="method-GMMPPClass-copy"></a>



<h4>Method <code>copy()</code></h4>

<p>copy
</p>


<h5>Usage</h5>

<div class="r"><pre>GMMPPClass$copy()</pre></div>



<h5>Returns</h5>

<p>A new instance
</p>


<hr>
<a id="method-GMMPPClass-emfit"></a>



<h4>Method <code>emfit()</code></h4>

<p>Run EM
</p>


<h5>Usage</h5>

<div class="r"><pre>GMMPPClass$emfit(data, options, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>A dataframe</p>
</dd>
<dt><code>options</code></dt><dd><p>A list of options</p>
</dd>
<dt><code>...</code></dt><dd><p>Others</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GMMPPClass-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>GMMPPClass$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='gph.param'>Generate GPH using the information on data</h2><span id='topic+gph.param'></span>

<h3>Description</h3>

<p>Generate GPH randomly and adjust parameters to fit its first moment to
the first moment of data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gph.param(data, skel, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gph.param_+3A_data">data</code></td>
<td>
<p>A dataframe</p>
</td></tr>
<tr><td><code id="gph.param_+3A_skel">skel</code></td>
<td>
<p>An instance of skeleton of GPH.</p>
</td></tr>
<tr><td><code id="gph.param_+3A_...">...</code></td>
<td>
<p>Others</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of GPH
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create data
wsample &lt;- rweibull(10, shape=2)
(dat &lt;- data.frame.phase.time(x=wsample))

## Generate PH that is fitted to dat
(model &lt;- gph.param(data=dat, skel=ph(5)))

</code></pre>

<hr>
<h2 id='GPHClass'>General phase-type distribution</h2><span id='topic+GPHClass'></span>

<h3>Description</h3>

<p>General phase-type distribution
</p>
<p>General phase-type distribution
</p>


<h3>Details</h3>

<p>A continuous distribution dominated by a continuous-time Markov chain.
A random time is given by an absorbing time.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GPHClass-alpha"><code>GPHClass$alpha()</code></a>
</p>
</li>
<li> <p><a href="#method-GPHClass-Q"><code>GPHClass$Q()</code></a>
</p>
</li>
<li> <p><a href="#method-GPHClass-xi"><code>GPHClass$xi()</code></a>
</p>
</li>
<li> <p><a href="#method-GPHClass-new"><code>GPHClass$new()</code></a>
</p>
</li>
<li> <p><a href="#method-GPHClass-copy"><code>GPHClass$copy()</code></a>
</p>
</li>
<li> <p><a href="#method-GPHClass-size"><code>GPHClass$size()</code></a>
</p>
</li>
<li> <p><a href="#method-GPHClass-df"><code>GPHClass$df()</code></a>
</p>
</li>
<li> <p><a href="#method-GPHClass-moment"><code>GPHClass$moment()</code></a>
</p>
</li>
<li> <p><a href="#method-GPHClass-print"><code>GPHClass$print()</code></a>
</p>
</li>
<li> <p><a href="#method-GPHClass-pdf"><code>GPHClass$pdf()</code></a>
</p>
</li>
<li> <p><a href="#method-GPHClass-cdf"><code>GPHClass$cdf()</code></a>
</p>
</li>
<li> <p><a href="#method-GPHClass-ccdf"><code>GPHClass$ccdf()</code></a>
</p>
</li>
<li> <p><a href="#method-GPHClass-sample"><code>GPHClass$sample()</code></a>
</p>
</li>
<li> <p><a href="#method-GPHClass-emfit"><code>GPHClass$emfit()</code></a>
</p>
</li>
<li> <p><a href="#method-GPHClass-init"><code>GPHClass$init()</code></a>
</p>
</li>
<li> <p><a href="#method-GPHClass-clone"><code>GPHClass$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-GPHClass-alpha"></a>



<h4>Method <code>alpha()</code></h4>

<p>Get alpha
</p>


<h5>Usage</h5>

<div class="r"><pre>GPHClass$alpha()</pre></div>



<h5>Returns</h5>

<p>A vector of alpha
</p>


<hr>
<a id="method-GPHClass-Q"></a>



<h4>Method <code>Q()</code></h4>

<p>Get Q
</p>


<h5>Usage</h5>

<div class="r"><pre>GPHClass$Q()</pre></div>



<h5>Returns</h5>

<p>A matrix of Q
</p>


<hr>
<a id="method-GPHClass-xi"></a>



<h4>Method <code>xi()</code></h4>

<p>Get xi
</p>


<h5>Usage</h5>

<div class="r"><pre>GPHClass$xi()</pre></div>



<h5>Returns</h5>

<p>A vector of xi
</p>


<hr>
<a id="method-GPHClass-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a GPH
</p>


<h5>Usage</h5>

<div class="r"><pre>GPHClass$new(alpha, Q, xi)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>alpha</code></dt><dd><p>A vector of initial probability</p>
</dd>
<dt><code>Q</code></dt><dd><p>An infinitesimal generator</p>
</dd>
<dt><code>xi</code></dt><dd><p>An exit rate vector</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An instance of GPH
</p>


<hr>
<a id="method-GPHClass-copy"></a>



<h4>Method <code>copy()</code></h4>

<p>copy
</p>


<h5>Usage</h5>

<div class="r"><pre>GPHClass$copy()</pre></div>



<h5>Returns</h5>

<p>A new instance
</p>


<hr>
<a id="method-GPHClass-size"></a>



<h4>Method <code>size()</code></h4>

<p>The number of phases
</p>


<h5>Usage</h5>

<div class="r"><pre>GPHClass$size()</pre></div>



<h5>Returns</h5>

<p>The number of phases
</p>


<hr>
<a id="method-GPHClass-df"></a>



<h4>Method <code>df()</code></h4>

<p>Degrees of freedom
</p>


<h5>Usage</h5>

<div class="r"><pre>GPHClass$df()</pre></div>



<h5>Returns</h5>

<p>The degrees of freedom
</p>


<hr>
<a id="method-GPHClass-moment"></a>



<h4>Method <code>moment()</code></h4>

<p>Moments of GPH
</p>


<h5>Usage</h5>

<div class="r"><pre>GPHClass$moment(k, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>k</code></dt><dd><p>A value to indicate the degrees of moments. k-th moment</p>
</dd>
<dt><code>...</code></dt><dd><p>Others</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A vector of moments from 1st to k-th moments
</p>


<hr>
<a id="method-GPHClass-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print
</p>


<h5>Usage</h5>

<div class="r"><pre>GPHClass$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Others</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GPHClass-pdf"></a>



<h4>Method <code>pdf()</code></h4>

<p>PDF
</p>


<h5>Usage</h5>

<div class="r"><pre>GPHClass$pdf(x, poisson.eps = 1e-08, ufactor = 1.01, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>A vector of points</p>
</dd>
<dt><code>poisson.eps</code></dt><dd><p>A value of tolerance error for uniformization</p>
</dd>
<dt><code>ufactor</code></dt><dd><p>A value of uniformization factor</p>
</dd>
<dt><code>...</code></dt><dd><p>Others</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A vector of densities.
</p>


<hr>
<a id="method-GPHClass-cdf"></a>



<h4>Method <code>cdf()</code></h4>

<p>CDF
</p>


<h5>Usage</h5>

<div class="r"><pre>GPHClass$cdf(x, poisson.eps = 1e-08, ufactor = 1.01, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>A vector of points</p>
</dd>
<dt><code>poisson.eps</code></dt><dd><p>A value of tolerance error for uniformization</p>
</dd>
<dt><code>ufactor</code></dt><dd><p>A value of uniformization factor</p>
</dd>
<dt><code>...</code></dt><dd><p>Others</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A vector of probabilities
</p>


<hr>
<a id="method-GPHClass-ccdf"></a>



<h4>Method <code>ccdf()</code></h4>

<p>Complementary CDF
</p>


<h5>Usage</h5>

<div class="r"><pre>GPHClass$ccdf(x, poisson.eps = 1e-08, ufactor = 1.01, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>A vector of points</p>
</dd>
<dt><code>poisson.eps</code></dt><dd><p>A value of tolerance error for uniformization</p>
</dd>
<dt><code>ufactor</code></dt><dd><p>A value of uniformization factor</p>
</dd>
<dt><code>...</code></dt><dd><p>Others</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A vector of probabilities
</p>


<hr>
<a id="method-GPHClass-sample"></a>



<h4>Method <code>sample()</code></h4>

<p>Make a sample
</p>


<h5>Usage</h5>

<div class="r"><pre>GPHClass$sample(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Others</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A sample of GPH
</p>


<hr>
<a id="method-GPHClass-emfit"></a>



<h4>Method <code>emfit()</code></h4>

<p>Run EM
</p>


<h5>Usage</h5>

<div class="r"><pre>GPHClass$emfit(data, options, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>A dataframe</p>
</dd>
<dt><code>options</code></dt><dd><p>A list of options</p>
</dd>
<dt><code>...</code></dt><dd><p>Others</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GPHClass-init"></a>



<h4>Method <code>init()</code></h4>

<p>Initialize with data
</p>


<h5>Usage</h5>

<div class="r"><pre>GPHClass$init(data, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>A dataframe</p>
</dd>
<dt><code>...</code></dt><dd><p>Others</p>
</dd>
<dt><code>options</code></dt><dd><p>A list of options</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GPHClass-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>GPHClass$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Note</h3>

<p>This function provides the values of p.d.f. for PH distribution with
the uniformization technique.
</p>
<p>This function provides the values of c.d.f. for PH distribution with
the uniformization technique.
</p>
<p>This function provides the values of complementary c.d.f. for
PH distribution with the uniformization technique.
</p>

<hr>
<h2 id='herlang'>Create HErlang distribution</h2><span id='topic+herlang'></span>

<h3>Description</h3>

<p>Create an instance of Hyper-Erlang distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>herlang(
  size,
  shape,
  mixrate = rep(1/length(shape), length(shape)),
  rate = rep(1, length(shape))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="herlang_+3A_size">size</code></td>
<td>
<p>An integer of the number of phases</p>
</td></tr>
<tr><td><code id="herlang_+3A_shape">shape</code></td>
<td>
<p>A vector of shape parameters</p>
</td></tr>
<tr><td><code id="herlang_+3A_mixrate">mixrate</code></td>
<td>
<p>A vector of initial probability (mixrate)</p>
</td></tr>
<tr><td><code id="herlang_+3A_rate">rate</code></td>
<td>
<p>A vector of rate parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of HErlang
</p>


<h3>Note</h3>

<p>If shape is given, shape is used even though size is set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create a hyper Erlang consisting of two Erlang
## with shape parameters 2 and 3.
(param1 &lt;- herlang(shape=c(2,3)))

## create a hyper Erlang with specific parameters
(param2 &lt;- herlang(shape=c(2,3), mixrate=c(0.3,0.7), rate=c(1.0,10.0)))

## convert to a general PH
as.gph(param2)

## p.d.f. for 0, 0.1, ..., 1
(dphase(x=seq(0, 1, 0.1), ph=param2))

## c.d.f. for 0, 0.1, ..., 1
(pphase(q=seq(0, 1, 0.1), ph=param2))

## generate 10 samples
(rphase(n=10, ph=param2))

</code></pre>

<hr>
<h2 id='herlang.param'>Determine hyper-Erlang parameters</h2><span id='topic+herlang.param'></span>

<h3>Description</h3>

<p>Determine the hyper-Erlang parameters with k-means.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>herlang.param(data, shape, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="herlang.param_+3A_data">data</code></td>
<td>
<p>A dataframe</p>
</td></tr>
<tr><td><code id="herlang.param_+3A_shape">shape</code></td>
<td>
<p>A vector of shape parameters</p>
</td></tr>
<tr><td><code id="herlang.param_+3A_...">...</code></td>
<td>
<p>Others</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of HErlang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create data
wsample &lt;- rweibull(10, shape=2)
(dat &lt;- data.frame.phase.time(x=wsample))

## Generate PH that is fitted to dat
(model &lt;- herlang.param(data=dat, shape=c(1,2,3)))

</code></pre>

<hr>
<h2 id='HErlangClass'>Hyper-Erlang distribution</h2><span id='topic+HErlangClass'></span>

<h3>Description</h3>

<p>Hyper-Erlang distribution
</p>
<p>Hyper-Erlang distribution
</p>


<h3>Details</h3>

<p>A mixture of Erlang distributions. A subclass of PH distributions.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-HErlangClass-mixrate"><code>HErlangClass$mixrate()</code></a>
</p>
</li>
<li> <p><a href="#method-HErlangClass-shape"><code>HErlangClass$shape()</code></a>
</p>
</li>
<li> <p><a href="#method-HErlangClass-rate"><code>HErlangClass$rate()</code></a>
</p>
</li>
<li> <p><a href="#method-HErlangClass-new"><code>HErlangClass$new()</code></a>
</p>
</li>
<li> <p><a href="#method-HErlangClass-copy"><code>HErlangClass$copy()</code></a>
</p>
</li>
<li> <p><a href="#method-HErlangClass-size"><code>HErlangClass$size()</code></a>
</p>
</li>
<li> <p><a href="#method-HErlangClass-df"><code>HErlangClass$df()</code></a>
</p>
</li>
<li> <p><a href="#method-HErlangClass-moment"><code>HErlangClass$moment()</code></a>
</p>
</li>
<li> <p><a href="#method-HErlangClass-print"><code>HErlangClass$print()</code></a>
</p>
</li>
<li> <p><a href="#method-HErlangClass-pdf"><code>HErlangClass$pdf()</code></a>
</p>
</li>
<li> <p><a href="#method-HErlangClass-cdf"><code>HErlangClass$cdf()</code></a>
</p>
</li>
<li> <p><a href="#method-HErlangClass-ccdf"><code>HErlangClass$ccdf()</code></a>
</p>
</li>
<li> <p><a href="#method-HErlangClass-sample"><code>HErlangClass$sample()</code></a>
</p>
</li>
<li> <p><a href="#method-HErlangClass-emfit"><code>HErlangClass$emfit()</code></a>
</p>
</li>
<li> <p><a href="#method-HErlangClass-init"><code>HErlangClass$init()</code></a>
</p>
</li>
<li> <p><a href="#method-HErlangClass-clone"><code>HErlangClass$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-HErlangClass-mixrate"></a>



<h4>Method <code>mixrate()</code></h4>

<p>Get mixrate
</p>


<h5>Usage</h5>

<div class="r"><pre>HErlangClass$mixrate()</pre></div>



<h5>Returns</h5>

<p>A vector of mixrate
</p>


<hr>
<a id="method-HErlangClass-shape"></a>



<h4>Method <code>shape()</code></h4>

<p>Get shape
</p>


<h5>Usage</h5>

<div class="r"><pre>HErlangClass$shape()</pre></div>



<h5>Returns</h5>

<p>A vector of shapes
</p>


<hr>
<a id="method-HErlangClass-rate"></a>



<h4>Method <code>rate()</code></h4>

<p>Get rate
</p>


<h5>Usage</h5>

<div class="r"><pre>HErlangClass$rate()</pre></div>



<h5>Returns</h5>

<p>A vector of rates
</p>


<hr>
<a id="method-HErlangClass-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a hyper-Erlang distribution
</p>


<h5>Usage</h5>

<div class="r"><pre>HErlangClass$new(mixrate, shape, rate)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>mixrate</code></dt><dd><p>A vector of initial probability</p>
</dd>
<dt><code>shape</code></dt><dd><p>A vector of shape parameters</p>
</dd>
<dt><code>rate</code></dt><dd><p>A vector of rate parameters</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An instance of HErlang
</p>


<hr>
<a id="method-HErlangClass-copy"></a>



<h4>Method <code>copy()</code></h4>

<p>copy
</p>


<h5>Usage</h5>

<div class="r"><pre>HErlangClass$copy()</pre></div>



<h5>Returns</h5>

<p>A new instance
</p>


<hr>
<a id="method-HErlangClass-size"></a>



<h4>Method <code>size()</code></h4>

<p>The number of components
</p>


<h5>Usage</h5>

<div class="r"><pre>HErlangClass$size()</pre></div>



<h5>Returns</h5>

<p>The number of components
</p>


<hr>
<a id="method-HErlangClass-df"></a>



<h4>Method <code>df()</code></h4>

<p>Degrees of freedom
</p>


<h5>Usage</h5>

<div class="r"><pre>HErlangClass$df()</pre></div>



<h5>Returns</h5>

<p>The degrees of freedom
</p>


<hr>
<a id="method-HErlangClass-moment"></a>



<h4>Method <code>moment()</code></h4>

<p>Moments of HErlang
</p>


<h5>Usage</h5>

<div class="r"><pre>HErlangClass$moment(k, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>k</code></dt><dd><p>A value to indicate the degrees of moments. k-th moment</p>
</dd>
<dt><code>...</code></dt><dd><p>Others</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A vector of moments from 1st to k-th moments
</p>


<hr>
<a id="method-HErlangClass-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print
</p>


<h5>Usage</h5>

<div class="r"><pre>HErlangClass$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Others</p>
</dd>
</dl>

</div>


<hr>
<a id="method-HErlangClass-pdf"></a>



<h4>Method <code>pdf()</code></h4>

<p>PDF
</p>


<h5>Usage</h5>

<div class="r"><pre>HErlangClass$pdf(x, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>A vector of points</p>
</dd>
<dt><code>...</code></dt><dd><p>Others</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A vector of densities.
</p>


<hr>
<a id="method-HErlangClass-cdf"></a>



<h4>Method <code>cdf()</code></h4>

<p>CDF
</p>


<h5>Usage</h5>

<div class="r"><pre>HErlangClass$cdf(q, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>q</code></dt><dd><p>A vector of points</p>
</dd>
<dt><code>...</code></dt><dd><p>Others</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A vector of probabilities
</p>


<hr>
<a id="method-HErlangClass-ccdf"></a>



<h4>Method <code>ccdf()</code></h4>

<p>Complementary CDF
</p>


<h5>Usage</h5>

<div class="r"><pre>HErlangClass$ccdf(q, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>q</code></dt><dd><p>A vector of points</p>
</dd>
<dt><code>...</code></dt><dd><p>Others</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A vector of probabilities
</p>


<hr>
<a id="method-HErlangClass-sample"></a>



<h4>Method <code>sample()</code></h4>

<p>Make a sample
</p>


<h5>Usage</h5>

<div class="r"><pre>HErlangClass$sample(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Others</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A sample of HErlang
</p>


<hr>
<a id="method-HErlangClass-emfit"></a>



<h4>Method <code>emfit()</code></h4>

<p>Run EM
</p>


<h5>Usage</h5>

<div class="r"><pre>HErlangClass$emfit(data, options, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>A dataframe</p>
</dd>
<dt><code>options</code></dt><dd><p>A list of options</p>
</dd>
<dt><code>...</code></dt><dd><p>Others</p>
</dd>
</dl>

</div>


<hr>
<a id="method-HErlangClass-init"></a>



<h4>Method <code>init()</code></h4>

<p>Initialize with data
</p>


<h5>Usage</h5>

<div class="r"><pre>HErlangClass$init(data, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>A dataframe</p>
</dd>
<dt><code>...</code></dt><dd><p>Others</p>
</dd>
<dt><code>options</code></dt><dd><p>A list of options</p>
</dd>
</dl>

</div>


<hr>
<a id="method-HErlangClass-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>HErlangClass$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='map'>Create MAP</h2><span id='topic+map'></span>

<h3>Description</h3>

<p>Create an instance of MAP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map(size, alpha, D0, D1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map_+3A_size">size</code></td>
<td>
<p>An integer for the number of phases</p>
</td></tr>
<tr><td><code id="map_+3A_alpha">alpha</code></td>
<td>
<p>A vector of initial probability</p>
</td></tr>
<tr><td><code id="map_+3A_d0">D0</code></td>
<td>
<p>An infinitesimal generator without arrivals</p>
</td></tr>
<tr><td><code id="map_+3A_d1">D1</code></td>
<td>
<p>An infinitesimal generator with arrivals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of MAP
</p>


<h3>Note</h3>

<p>This function can omit several patterns of arguments. For example, <code>map(5)</code>
omit the arguments <code>alpha</code>, <code>D0</code> <code>D1</code> and <code>xi</code>. In this case, the default values are
assigned to them.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create a map (full matrix) with 5 phases
(param1 &lt;- map(5))

## create a map with specific parameters
(param2 &lt;- map(alpha=c(1,0,0),
              D0=rbind(c(-4,2,0),c(2,-5,1),c(1,0,-1)),
              D1=rbind(c(2,0,0),c(0,2,0),c(0,0,0))))

</code></pre>

<hr>
<h2 id='map.acf'>k-lag correlation of MAP</h2><span id='topic+map.acf'></span>

<h3>Description</h3>

<p>Compute k-lag correlation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map.acf(map, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map.acf_+3A_map">map</code></td>
<td>
<p>An instance of MAP</p>
</td></tr>
<tr><td><code id="map.acf_+3A_...">...</code></td>
<td>
<p>Others</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of k-lag correlation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create an MAP with specific parameters
(param1 &lt;- map(alpha=c(1,0,0),
               D0=rbind(c(-4,2,0),c(2,-5,1),c(1,0,-4)),
               D1=rbind(c(1,1,0),c(1,0,1),c(2,0,1))))

## create an ER-HMM with specific parameters
(param2 &lt;- erhmm(shape=c(2,3), alpha=c(0.3,0.7),
                 rate=c(1.0,10.0),
                 P=rbind(c(0.3, 0.7), c(0.1, 0.9))))

map.acf(map=param1)
map.acf(map=param2)

</code></pre>

<hr>
<h2 id='map.jmoment'>Joint moments of MAP</h2><span id='topic+map.jmoment'></span>

<h3>Description</h3>

<p>Compute joint moments for a given MAP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map.jmoment(lag, map, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map.jmoment_+3A_lag">lag</code></td>
<td>
<p>An integer for lag</p>
</td></tr>
<tr><td><code id="map.jmoment_+3A_map">map</code></td>
<td>
<p>An instance of MAP</p>
</td></tr>
<tr><td><code id="map.jmoment_+3A_...">...</code></td>
<td>
<p>Others</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of moments
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create an MAP with specific parameters
(param1 &lt;- map(alpha=c(1,0,0),
               D0=rbind(c(-4,2,0),c(2,-5,1),c(1,0,-4)),
               D1=rbind(c(1,1,0),c(1,0,1),c(2,0,1))))

## create an ER-HMM with specific parameters
(param2 &lt;- erhmm(shape=c(2,3), alpha=c(0.3,0.7),
                 rate=c(1.0,10.0),
                 P=rbind(c(0.3, 0.7), c(0.1, 0.9))))

map.jmoment(lag=1, map=param1)
map.jmoment(lag=1, map=param2)

</code></pre>

<hr>
<h2 id='map.mmoment'>Marginal moments of MAP</h2><span id='topic+map.mmoment'></span>

<h3>Description</h3>

<p>Compute up to k-th marginal moments for a given MAP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map.mmoment(k, map, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map.mmoment_+3A_k">k</code></td>
<td>
<p>An integer for the moments to be computed</p>
</td></tr>
<tr><td><code id="map.mmoment_+3A_map">map</code></td>
<td>
<p>An instance of MAP</p>
</td></tr>
<tr><td><code id="map.mmoment_+3A_...">...</code></td>
<td>
<p>Others</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of moments
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create an MAP with specific parameters
(param1 &lt;- map(alpha=c(1,0,0),
               D0=rbind(c(-4,2,0),c(2,-5,1),c(1,0,-4)),
               D1=rbind(c(1,1,0),c(1,0,1),c(2,0,1))))

## create an ER-HMM with specific parameters
(param2 &lt;- erhmm(shape=c(2,3), alpha=c(0.3,0.7),
                 rate=c(1.0,10.0),
                 P=rbind(c(0.3, 0.7), c(0.1, 0.9))))

map.mmoment(k=3, map=param1)
map.mmoment(k=3, map=param2)

</code></pre>

<hr>
<h2 id='map.param'>Generate MAP using the information on data</h2><span id='topic+map.param'></span>

<h3>Description</h3>

<p>Generate MAP randomly and adjust parameters to fit its first moment to
the first moment of data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map.param(data, skel, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map.param_+3A_data">data</code></td>
<td>
<p>A dataframe</p>
</td></tr>
<tr><td><code id="map.param_+3A_skel">skel</code></td>
<td>
<p>An instance of skeleton of MAP</p>
</td></tr>
<tr><td><code id="map.param_+3A_...">...</code></td>
<td>
<p>Others</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of MAP
</p>

<hr>
<h2 id='MAPClass'>General Markovian arrival process</h2><span id='topic+MAPClass'></span>

<h3>Description</h3>

<p>General Markovian arrival process
</p>
<p>General Markovian arrival process
</p>


<h3>Details</h3>

<p>A point process dominated by a continuous-time Markov chain.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-MAPClass-alpha"><code>MAPClass$alpha()</code></a>
</p>
</li>
<li> <p><a href="#method-MAPClass-D0"><code>MAPClass$D0()</code></a>
</p>
</li>
<li> <p><a href="#method-MAPClass-D1"><code>MAPClass$D1()</code></a>
</p>
</li>
<li> <p><a href="#method-MAPClass-xi"><code>MAPClass$xi()</code></a>
</p>
</li>
<li> <p><a href="#method-MAPClass-new"><code>MAPClass$new()</code></a>
</p>
</li>
<li> <p><a href="#method-MAPClass-copy"><code>MAPClass$copy()</code></a>
</p>
</li>
<li> <p><a href="#method-MAPClass-size"><code>MAPClass$size()</code></a>
</p>
</li>
<li> <p><a href="#method-MAPClass-df"><code>MAPClass$df()</code></a>
</p>
</li>
<li> <p><a href="#method-MAPClass-print"><code>MAPClass$print()</code></a>
</p>
</li>
<li> <p><a href="#method-MAPClass-mmoment"><code>MAPClass$mmoment()</code></a>
</p>
</li>
<li> <p><a href="#method-MAPClass-jmoment"><code>MAPClass$jmoment()</code></a>
</p>
</li>
<li> <p><a href="#method-MAPClass-acf"><code>MAPClass$acf()</code></a>
</p>
</li>
<li> <p><a href="#method-MAPClass-emfit"><code>MAPClass$emfit()</code></a>
</p>
</li>
<li> <p><a href="#method-MAPClass-init"><code>MAPClass$init()</code></a>
</p>
</li>
<li> <p><a href="#method-MAPClass-clone"><code>MAPClass$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-MAPClass-alpha"></a>



<h4>Method <code>alpha()</code></h4>

<p>Get alpha
</p>


<h5>Usage</h5>

<div class="r"><pre>MAPClass$alpha()</pre></div>



<h5>Returns</h5>

<p>A vector of alpha
</p>


<hr>
<a id="method-MAPClass-D0"></a>



<h4>Method <code>D0()</code></h4>

<p>Get D0
</p>


<h5>Usage</h5>

<div class="r"><pre>MAPClass$D0()</pre></div>



<h5>Returns</h5>

<p>A matrix of D0
</p>


<hr>
<a id="method-MAPClass-D1"></a>



<h4>Method <code>D1()</code></h4>

<p>Get D1
</p>


<h5>Usage</h5>

<div class="r"><pre>MAPClass$D1()</pre></div>



<h5>Returns</h5>

<p>A matrix of D1
</p>


<hr>
<a id="method-MAPClass-xi"></a>



<h4>Method <code>xi()</code></h4>

<p>Get xi
</p>


<h5>Usage</h5>

<div class="r"><pre>MAPClass$xi()</pre></div>



<h5>Returns</h5>

<p>A vector of xi
</p>


<hr>
<a id="method-MAPClass-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a MAP
</p>


<h5>Usage</h5>

<div class="r"><pre>MAPClass$new(alpha, D0, D1, xi)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>alpha</code></dt><dd><p>A vector of initial probability</p>
</dd>
<dt><code>D0</code></dt><dd><p>An infinitesimal generator</p>
</dd>
<dt><code>D1</code></dt><dd><p>An infinitesimal generator</p>
</dd>
<dt><code>xi</code></dt><dd><p>An exit rate vector</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An instance of MAP
</p>


<hr>
<a id="method-MAPClass-copy"></a>



<h4>Method <code>copy()</code></h4>

<p>copy
</p>


<h5>Usage</h5>

<div class="r"><pre>MAPClass$copy()</pre></div>



<h5>Returns</h5>

<p>A new instance
</p>


<hr>
<a id="method-MAPClass-size"></a>



<h4>Method <code>size()</code></h4>

<p>The number of phases
</p>


<h5>Usage</h5>

<div class="r"><pre>MAPClass$size()</pre></div>



<h5>Returns</h5>

<p>The number of phases
</p>


<hr>
<a id="method-MAPClass-df"></a>



<h4>Method <code>df()</code></h4>

<p>Degrees of freedom
</p>


<h5>Usage</h5>

<div class="r"><pre>MAPClass$df()</pre></div>



<h5>Returns</h5>

<p>The degrees of freedom
</p>


<hr>
<a id="method-MAPClass-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print
</p>


<h5>Usage</h5>

<div class="r"><pre>MAPClass$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Others</p>
</dd>
</dl>

</div>


<hr>
<a id="method-MAPClass-mmoment"></a>



<h4>Method <code>mmoment()</code></h4>

<p>Marginal moments
</p>


<h5>Usage</h5>

<div class="r"><pre>MAPClass$mmoment(k, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>k</code></dt><dd><p>An integer of degree</p>
</dd>
<dt><code>...</code></dt><dd><p>Others</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A vector of moments
</p>


<hr>
<a id="method-MAPClass-jmoment"></a>



<h4>Method <code>jmoment()</code></h4>

<p>Joint moments
</p>


<h5>Usage</h5>

<div class="r"><pre>MAPClass$jmoment(lag, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>lag</code></dt><dd><p>An integer of lag</p>
</dd>
<dt><code>...</code></dt><dd><p>Others</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A matrix of moments
</p>


<hr>
<a id="method-MAPClass-acf"></a>



<h4>Method <code>acf()</code></h4>

<p>k-lag correlation
</p>


<h5>Usage</h5>

<div class="r"><pre>MAPClass$acf(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Others</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A vector for k-lag correlation
</p>


<hr>
<a id="method-MAPClass-emfit"></a>



<h4>Method <code>emfit()</code></h4>

<p>Run EM
</p>


<h5>Usage</h5>

<div class="r"><pre>MAPClass$emfit(data, options, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>A dataframe</p>
</dd>
<dt><code>options</code></dt><dd><p>A list of options</p>
</dd>
<dt><code>...</code></dt><dd><p>Others</p>
</dd>
</dl>

</div>


<hr>
<a id="method-MAPClass-init"></a>



<h4>Method <code>init()</code></h4>

<p>Initialize with data
</p>


<h5>Usage</h5>

<div class="r"><pre>MAPClass$init(data, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>A dataframe</p>
</dd>
<dt><code>...</code></dt><dd><p>Others</p>
</dd>
</dl>

</div>


<hr>
<a id="method-MAPClass-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>MAPClass$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='mapfit.group'>MAP fitting with grouped data</h2><span id='topic+mapfit.group'></span>

<h3>Description</h3>

<p>Estimates MAP parameters from grouped data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapfit.group(map, counts, breaks, intervals, instants, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mapfit.group_+3A_map">map</code></td>
<td>
<p>An object of R6 class. The estimation algorithm is selected depending on this class.</p>
</td></tr>
<tr><td><code id="mapfit.group_+3A_counts">counts</code></td>
<td>
<p>A vector of the number of points in intervals.</p>
</td></tr>
<tr><td><code id="mapfit.group_+3A_breaks">breaks</code></td>
<td>
<p>A vector for a sequence of points of boundaries of intervals.
This is equivalent to <code>c(0,cumsum(intervals))</code>.
If this is missing, it is assigned to <code>0:length(counts)</code>.</p>
</td></tr>
<tr><td><code id="mapfit.group_+3A_intervals">intervals</code></td>
<td>
<p>A vector of time lengths for intervals.
This is equivalent to <code>diff(breaks)</code>).
If this is missing, it is assigned to <code>rep(1,length(counts))</code>.</p>
</td></tr>
<tr><td><code id="mapfit.group_+3A_instants">instants</code></td>
<td>
<p>A vector of integers to indicate whether sample is drawn at
the last of interval. If instant is 1, a sample is drawn at the last of interval.
If instant is 0, no sample is drawn at the last of interval.
By using instant, point data can be expressed by grouped data.
If instant is missing, it is given by <code>rep(0L,length(counts))</code>, i.e.,
there are no samples at the last of interval.</p>
</td></tr>
<tr><td><code id="mapfit.group_+3A_...">...</code></td>
<td>
<p>Further options for EM steps.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with components, which is an object of S3 class <code>mapfit.result</code>;
</p>
<table>
<tr><td><code>model</code></td>
<td>
<p>an object for estimated MAP class.</p>
</td></tr>
<tr><td><code>llf</code></td>
<td>
<p>a value of the maximum log-likelihood.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>a value of degrees of freedom of the model.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>a value of Akaike information criterion.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>the number of iterations.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>a logical value for the convergence of estimation algorithm.</p>
</td></tr>
<tr><td><code>ctime</code></td>
<td>
<p>computation time (user time).</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>an object for data class</p>
</td></tr>
<tr><td><code>aerror</code></td>
<td>
<p>a value of absolute error for llf at the last step of algorithm.</p>
</td></tr>
<tr><td><code>rerror</code></td>
<td>
<p>a value of relative error for llf at the last step of algorithm.</p>
</td></tr>
<tr><td><code>options</code></td>
<td>
<p>a list of options used in the fitting.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## load trace data
data(BCpAug89)
BCpAug89s &lt;- head(BCpAug89, 50)

## make grouped data
BCpAug89.group &lt;- hist(cumsum(BCpAug89s),
                         breaks=seq(0, 0.15, 0.005),
                         plot=FALSE)
                         
## MAP fitting for general MAP
(result1 &lt;- mapfit.group(map=map(2),
                        counts=BCpAug89.group$counts,
                        breaks=BCpAug89.group$breaks))
## MAP fitting for MMPP
(result2 &lt;- mapfit.group(map=mmpp(2),
                         counts=BCpAug89.group$counts,
                         breaks=BCpAug89.group$breaks))
                         
## MAP fitting with approximate MMPP
(result3 &lt;- mapfit.group(map=gmmpp(2),
                         counts=BCpAug89.group$counts,
                         breaks=BCpAug89.group$breaks))

## marginal moments for estimated MAP
map.mmoment(k=3, map=result1$model)
map.mmoment(k=3, map=result2$model)
map.mmoment(k=3, map=result3$model)

## joint moments for estimated MAP
map.jmoment(lag=1, map=result1$model)
map.jmoment(lag=1, map=result2$model)
map.jmoment(lag=1, map=result3$model)

## lag-k correlation
map.acf(map=result1$model)
map.acf(map=result2$model)
map.acf(map=result3$model)

</code></pre>

<hr>
<h2 id='mapfit.point'>MAP fitting with point data</h2><span id='topic+mapfit.point'></span>

<h3>Description</h3>

<p>Estimates MAP parameters from point data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapfit.point(map, x, intervals, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mapfit.point_+3A_map">map</code></td>
<td>
<p>An object for MAP. The estimation algorithm is selected depending on this class.</p>
</td></tr>
<tr><td><code id="mapfit.point_+3A_x">x</code></td>
<td>
<p>A vector for point data.</p>
</td></tr>
<tr><td><code id="mapfit.point_+3A_intervals">intervals</code></td>
<td>
<p>A vector for intervals.</p>
</td></tr>
<tr><td><code id="mapfit.point_+3A_...">...</code></td>
<td>
<p>Further options for fitting methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with components, which is an object of S3 class <code>mapfit.result</code>;
</p>
<table>
<tr><td><code>model</code></td>
<td>
<p>an object for estimated PH class.</p>
</td></tr>
<tr><td><code>llf</code></td>
<td>
<p>a value of the maximum log-likelihood.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>a value of degrees of freedom of the model.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>a value of Akaike information criterion.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>the number of iterations.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>a logical value for the convergence of estimation algorithm.</p>
</td></tr>
<tr><td><code>ctime</code></td>
<td>
<p>computation time (user time).</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>an object for data class</p>
</td></tr>
<tr><td><code>aerror</code></td>
<td>
<p>a value of absolute error for llf at the last step of algorithm.</p>
</td></tr>
<tr><td><code>rerror</code></td>
<td>
<p>a value of relative error for llf at the last step of algorithm.</p>
</td></tr>
<tr><td><code>options</code></td>
<td>
<p>a list of options used for fitting.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## load trace data
data(BCpAug89)
BCpAug89s &lt;- head(BCpAug89, 50)

## MAP fitting for general MAP
(result1 &lt;- mapfit.point(map=map(2), x=cumsum(BCpAug89s)))

## MAP fitting for MMPP
(result2 &lt;- mapfit.point(map=mmpp(2), x=cumsum(BCpAug89s)))

## MAP fitting for ER-HMM
(result3 &lt;- mapfit.point(map=erhmm(3), x=cumsum(BCpAug89s)))

## marginal moments for estimated MAP
map.mmoment(k=3, map=result1$model)
map.mmoment(k=3, map=result2$model)
map.mmoment(k=3, map=result3$model)

## joint moments for estimated MAP
map.jmoment(lag=1, map=result1$model)
map.jmoment(lag=1, map=result2$model)
map.jmoment(lag=1, map=result3$model)

## lag-k correlation
map.acf(map=result1$model)
map.acf(map=result2$model)
map.acf(map=result3$model)

</code></pre>

<hr>
<h2 id='mmpp'>Create an MMPP</h2><span id='topic+mmpp'></span>

<h3>Description</h3>

<p>Create an instance of MMPP (Markov-Modulated Poisson Process)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mmpp(size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mmpp_+3A_size">size</code></td>
<td>
<p>An integer for the number of phases</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of MMPP
</p>


<h3>Note</h3>

<p>MMPP is a MAP whose D1 is given by a diagonal matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create an MMPP with 5 phases
(param1 &lt;- mmpp(5))

</code></pre>

<hr>
<h2 id='ph'>Create GPH distribution</h2><span id='topic+ph'></span>

<h3>Description</h3>

<p>Create an instance of GPH
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ph(size, alpha, Q, xi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ph_+3A_size">size</code></td>
<td>
<p>An integer for the number of phases</p>
</td></tr>
<tr><td><code id="ph_+3A_alpha">alpha</code></td>
<td>
<p>A vector of initial probability</p>
</td></tr>
<tr><td><code id="ph_+3A_q">Q</code></td>
<td>
<p>An infinitesimal generator</p>
</td></tr>
<tr><td><code id="ph_+3A_xi">xi</code></td>
<td>
<p>An exit rate vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of GPH
</p>


<h3>Note</h3>

<p>This function can omit several patterns of arguments. For example, <code>ph(5)</code>
omit the arguments <code>alpha</code>, <code>Q</code> and <code>xi</code>. In this case, the default values are
assigned to them.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create a PH (full matrix) with 5 phases
(param1 &lt;- ph(5))

## create a PH (full matrix) with 5 phases
(param1 &lt;- ph(size=5))

## create a PH with specific parameters
(param2 &lt;- ph(alpha=c(1,0,0),
              Q=rbind(c(-4,2,0),c(2,-5,1),c(1,0,-1)),
              xi=c(2,2,0)))

</code></pre>

<hr>
<h2 id='ph.bidiag'>Create a bi-diagonal PH distribution</h2><span id='topic+ph.bidiag'></span>

<h3>Description</h3>

<p>Create an instance of bi-diagonal PH distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ph.bidiag(size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ph.bidiag_+3A_size">size</code></td>
<td>
<p>An integer for the number of phases</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of bi-diagonal PH distribution
</p>


<h3>Note</h3>

<p>Bi-diagonal PH distribution is the PH distribution whose infinitesimal
generator is given by a upper bi-diagonal matrix. This is similar to
canonical form 1. But there is no restriction on the order for diagonal
elements.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create a bidiagonal PH with 5 phases
(param1 &lt;- ph.bidiag(5))

</code></pre>

<hr>
<h2 id='ph.coxian'>Create a Coxian PH distribution</h2><span id='topic+ph.coxian'></span>

<h3>Description</h3>

<p>Create an instance of coxian PH distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ph.coxian(size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ph.coxian_+3A_size">size</code></td>
<td>
<p>An integer for the number of phases</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of coxian PH distribution
</p>


<h3>Note</h3>

<p>Coxian PH distribution is the PH distribution whose infinitesimal
generator is given by a upper bi-diagonal matrix. This is also called
canonical form 3.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create a Coxian PH with 5 phases
(param1 &lt;- ph.coxian(5))

</code></pre>

<hr>
<h2 id='ph.mean'>Mean of PH distribution</h2><span id='topic+ph.mean'></span>

<h3>Description</h3>

<p>Compute the mean of a given PH distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ph.mean(ph, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ph.mean_+3A_ph">ph</code></td>
<td>
<p>An instance of PH distribution</p>
</td></tr>
<tr><td><code id="ph.mean_+3A_...">...</code></td>
<td>
<p>Others</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A value of mean
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create a PH with specific parameters
(param1 &lt;- ph(alpha=c(1,0,0), 
              Q=rbind(c(-4,2,0),c(2,-5,1),c(1,0,-1)), 
              xi=c(2,2,0)))

## create a CF1 with specific parameters
(param2 &lt;- cf1(alpha=c(1,0,0), rate=c(1.0,2.0,3.0)))

## create a hyper Erlang with specific parameters
(param3 &lt;- herlang(shape=c(2,3), mixrate=c(0.3,0.7), rate=c(1.0,10.0)))

## mean
ph.mean(param1)
ph.mean(param2)
ph.mean(param3)

</code></pre>

<hr>
<h2 id='ph.moment'>Moments of PH distribution</h2><span id='topic+ph.moment'></span>

<h3>Description</h3>

<p>Generate moments up to k-th moments for a given PH distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ph.moment(k, ph, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ph.moment_+3A_k">k</code></td>
<td>
<p>An integer for the moments to be computed</p>
</td></tr>
<tr><td><code id="ph.moment_+3A_ph">ph</code></td>
<td>
<p>An instance of PH distribution</p>
</td></tr>
<tr><td><code id="ph.moment_+3A_...">...</code></td>
<td>
<p>Others</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of moments
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create a PH with specific parameters
(param1 &lt;- ph(alpha=c(1,0,0), 
              Q=rbind(c(-4,2,0),c(2,-5,1),c(1,0,-1)), 
              xi=c(2,2,0)))

## create a CF1 with specific parameters
(param2 &lt;- cf1(alpha=c(1,0,0), rate=c(1.0,2.0,3.0)))

## create a hyper Erlang with specific parameters
(param3 &lt;- herlang(shape=c(2,3), mixrate=c(0.3,0.7), rate=c(1.0,10.0)))

## up to 5 moments 
ph.moment(5, param1)
ph.moment(5, param2)
ph.moment(5, param3)

</code></pre>

<hr>
<h2 id='ph.tridiag'>Create a tri-diagonal PH distribution</h2><span id='topic+ph.tridiag'></span>

<h3>Description</h3>

<p>Create an instance of tri-diagonal PH distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ph.tridiag(size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ph.tridiag_+3A_size">size</code></td>
<td>
<p>An integer for the number of phases</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of tri-diagonal PH distribution
</p>


<h3>Note</h3>

<p>Tri-diagonal PH distribution is the PH distribution whose infinitesimal
generator is given by a tri-diagonal matrix (band matrix).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create a tridiagonal PH with 5 phases
(param1 &lt;- ph.tridiag(5))

</code></pre>

<hr>
<h2 id='ph.var'>Variance of PH distribution</h2><span id='topic+ph.var'></span>

<h3>Description</h3>

<p>Compute the variance of a given PH distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ph.var(ph, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ph.var_+3A_ph">ph</code></td>
<td>
<p>An instance of PH distribution</p>
</td></tr>
<tr><td><code id="ph.var_+3A_...">...</code></td>
<td>
<p>Others</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A value of variance
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create a PH with specific parameters
(param1 &lt;- ph(alpha=c(1,0,0), 
              Q=rbind(c(-4,2,0),c(2,-5,1),c(1,0,-1)), 
              xi=c(2,2,0)))

## create a CF1 with specific parameters
(param2 &lt;- cf1(alpha=c(1,0,0), rate=c(1.0,2.0,3.0)))

## create a hyper Erlang with specific parameters
(param3 &lt;- herlang(shape=c(2,3), mixrate=c(0.3,0.7), rate=c(1.0,10.0)))

## variance
ph.var(param1)
ph.var(param2)
ph.var(param3)

</code></pre>

<hr>
<h2 id='phfit.3mom'>PH fitting with three moments</h2><span id='topic+phfit.3mom'></span>

<h3>Description</h3>

<p>Estimates PH parameters from three moments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phfit.3mom(
  m1,
  m2,
  m3,
  method = c("Osogami06", "Bobbio05"),
  max.phase = 50,
  epsilon = sqrt(.Machine$double.eps)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phfit.3mom_+3A_m1">m1</code></td>
<td>
<p>A value of the first moment.</p>
</td></tr>
<tr><td><code id="phfit.3mom_+3A_m2">m2</code></td>
<td>
<p>A value of the second moment.</p>
</td></tr>
<tr><td><code id="phfit.3mom_+3A_m3">m3</code></td>
<td>
<p>A value of the third moment.</p>
</td></tr>
<tr><td><code id="phfit.3mom_+3A_method">method</code></td>
<td>
<p>The name of moment matching method.</p>
</td></tr>
<tr><td><code id="phfit.3mom_+3A_max.phase">max.phase</code></td>
<td>
<p>An integer for the maximum number of phases in the method
&quot;Osogami06&quot;.</p>
</td></tr>
<tr><td><code id="phfit.3mom_+3A_epsilon">epsilon</code></td>
<td>
<p>A value of precision in the method &quot;Osogami06&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of GPH.
</p>


<h3>Note</h3>

<p>The method &quot;Osogami06&quot; checks the first three moments on whether there
exists a PH whose three moments match to them. In such case, the method
&quot;Bobbio05&quot; often returns an error.
</p>


<h3>References</h3>

<p>Osogami, T. and Harchol-Balter, M. (2006)
Closed Form Solutions for Mapping General Distributions to Minimal PH Distributions.
<em>Performance Evaluation</em>, <b>63</b>(6), 524&ndash;552.
</p>
<p>Bobbio, A., Horvath, A. and Telek, M. (2005)
Matching Three Moments with Minimal Acyclic Phase Type Distributions.
<em>Stochastic Models</em>, <b>21</b>(2-3), 303&ndash;326.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Three moment matching
## Moments of Weibull(shape=2, scale=1); (0.886227, 1.0, 1.32934)
(result1 &lt;- phfit.3mom(0.886227, 1.0, 1.32934))

## Three moment matching
## Moments of Weibull(shape=2, scale=1); (0.886227, 1.0, 1.32934)
(result2 &lt;- phfit.3mom(0.886227, 1.0, 1.32934, method="Bobbio05"))

## mean
ph.mean(result1)
ph.mean(result2)

## variance
ph.var(result1)
ph.var(result2)

## up to 5 moments 
ph.moment(5, result1)
ph.moment(5, result2)

</code></pre>

<hr>
<h2 id='phfit.density'>PH fitting with density function</h2><span id='topic+phfit.density'></span>

<h3>Description</h3>

<p>Estimates PH parameters from density function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phfit.density(
  ph,
  f,
  deformula = deformula.zeroinf,
  weight.zero = 1e-12,
  weight.reltol = 1e-08,
  start.divisions = 8,
  max.iter = 12,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phfit.density_+3A_ph">ph</code></td>
<td>
<p>An object of R6 class. The estimation algorithm is selected depending on this class.</p>
</td></tr>
<tr><td><code id="phfit.density_+3A_f">f</code></td>
<td>
<p>A function object for a density function.</p>
</td></tr>
<tr><td><code id="phfit.density_+3A_deformula">deformula</code></td>
<td>
<p>An object for formulas of numerical integration.
It is not necessary to change it when the density function is defined on
the positive domain [0,infinity).</p>
</td></tr>
<tr><td><code id="phfit.density_+3A_weight.zero">weight.zero</code></td>
<td>
<p>A absolute value which is regarded as zero in numerical integration.</p>
</td></tr>
<tr><td><code id="phfit.density_+3A_weight.reltol">weight.reltol</code></td>
<td>
<p>A value for precision of numerical integration.</p>
</td></tr>
<tr><td><code id="phfit.density_+3A_start.divisions">start.divisions</code></td>
<td>
<p>A value for starting value of divisions in deformula.</p>
</td></tr>
<tr><td><code id="phfit.density_+3A_max.iter">max.iter</code></td>
<td>
<p>A value for the maximum number of iterations to increase divisions in deformula.</p>
</td></tr>
<tr><td><code id="phfit.density_+3A_...">...</code></td>
<td>
<p>Options for EM steps, which is also used to send the arguments to density function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with components, which is an object of S3 class <code>phfit.result</code>;
</p>
<table>
<tr><td><code>model</code></td>
<td>
<p>an object for estimated PH class.</p>
</td></tr>
<tr><td><code>llf</code></td>
<td>
<p>a value of the maximum log-likelihood (a negative value of the cross entropy).</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>a value of degrees of freedom of the model.</p>
</td></tr>
<tr><td><code>KL</code></td>
<td>
<p>a value of Kullback-Leibler divergence.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>the number of iterations.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>a logical value for the convergence of estimation algorithm.</p>
</td></tr>
<tr><td><code>ctime</code></td>
<td>
<p>computation time (user time).</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>an object for data class</p>
</td></tr>
<tr><td><code>aerror</code></td>
<td>
<p>a value of absolute error for llf at the last step of algorithm.</p>
</td></tr>
<tr><td><code>rerror</code></td>
<td>
<p>a value of relative error for llf at the last step of algorithm.</p>
</td></tr>
<tr><td><code>options</code></td>
<td>
<p>a list of options.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Any of density function can be applied to the argument <code>f</code>, where
<code>f</code> should be defined <code>f &lt;- function(x, ...)</code>.
The first argument of <code>f</code> should be an integral parameter.
The other parameters are set in the argument <code>...</code> of <code>phfit.density</code>.
The truncated density function can also be used directly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>####################
##### truncated density
####################

## PH fitting for general PH
(result1 &lt;- phfit.density(ph=ph(2), f=dnorm, mean=3, sd=1))

## PH fitting for CF1
(result2 &lt;- phfit.density(ph=cf1(2), f=dnorm, mean=3, sd=1))

## PH fitting for hyper Erlang
(result3 &lt;- phfit.density(ph=herlang(3), f=dnorm, mean=3, sd=1))

## mean
ph.mean(result1$model)
ph.mean(result2$model)
ph.mean(result3$model)

## variance
ph.var(result1$model)
ph.var(result2$model)
ph.var(result3$model)

## up to 5 moments 
ph.moment(5, result1$model)
ph.moment(5, result2$model)
ph.moment(5, result3$model)

</code></pre>

<hr>
<h2 id='phfit.group'>PH fitting with grouped data</h2><span id='topic+phfit.group'></span>

<h3>Description</h3>

<p>Estimates PH parameters from grouped data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phfit.group(ph, counts, breaks, intervals, instants, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phfit.group_+3A_ph">ph</code></td>
<td>
<p>An object of R6 class. The estimation algorithm is selected depending on this class.</p>
</td></tr>
<tr><td><code id="phfit.group_+3A_counts">counts</code></td>
<td>
<p>A vector of the number of points in intervals.</p>
</td></tr>
<tr><td><code id="phfit.group_+3A_breaks">breaks</code></td>
<td>
<p>A vector for a sequence of points of boundaries of intervals.
This is equivalent to <code>c(0,cumsum(intervals))</code>.
If this is missing, it is assigned to <code>0:length(counts)</code>.</p>
</td></tr>
<tr><td><code id="phfit.group_+3A_intervals">intervals</code></td>
<td>
<p>A vector of time lengths for intervals.
This is equivalent to <code>diff(breaks)</code>).
If this is missing, it is assigned to <code>rep(1,length(counts))</code>.</p>
</td></tr>
<tr><td><code id="phfit.group_+3A_instants">instants</code></td>
<td>
<p>A vector of integers to indicate whether sample is drawn at
the last of interval. If instant is 1, a sample is drawn at the last of interval.
If instant is 0, no sample is drawn at the last of interval.
By using instant, point data can be expressed by grouped data.
If instant is missing, it is given by <code>rep(0L,length(counts))</code>, i.e.,
there are no samples at the last of interval.</p>
</td></tr>
<tr><td><code id="phfit.group_+3A_...">...</code></td>
<td>
<p>Further options for EM steps.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with components, which is an object of S3 class <code>phfit.result</code>;
</p>
<table>
<tr><td><code>model</code></td>
<td>
<p>an object for estimated PH class.</p>
</td></tr>
<tr><td><code>llf</code></td>
<td>
<p>a value of the maximum log-likelihood.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>a value of degrees of freedom of the model.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>a value of Akaike information criterion.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>the number of iterations.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>a logical value for the convergence of estimation algorithm.</p>
</td></tr>
<tr><td><code>ctime</code></td>
<td>
<p>computation time (user time).</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>an object for data class</p>
</td></tr>
<tr><td><code>aerror</code></td>
<td>
<p>a value of absolute error for llf at the last step of algorithm.</p>
</td></tr>
<tr><td><code>rerror</code></td>
<td>
<p>a value of relative error for llf at the last step of algorithm.</p>
</td></tr>
<tr><td><code>options</code></td>
<td>
<p>a list of options used in the fitting.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>In this method, we can handle truncated data using <code>NA</code> and <code>Inf</code>;
<code>phfit.group(ph=cf1(5), counts=c(countsdata, NA), breaks=c(breakdata, +Inf))</code>
<code>NA</code> means missing of count data at the corresponding interval, and <code>Inf</code> is allowed to put
the last of breaks or intervals which represents a special interval [the last break point,infinity).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## make sample
wsample &lt;- rweibull(n=100, shape=2, scale=1)
wgroup &lt;- hist(x=wsample, breaks="fd", plot=FALSE)

## PH fitting for general PH
(result1 &lt;- phfit.group(ph=ph(2), counts=wgroup$counts, breaks=wgroup$breaks))

## PH fitting for CF1
(result2 &lt;- phfit.group(ph=cf1(2), counts=wgroup$counts, breaks=wgroup$breaks))

## PH fitting for hyper Erlang
(result3 &lt;- phfit.group(ph=herlang(3), counts=wgroup$counts, breaks=wgroup$breaks))

## mean
ph.mean(result1$model)
ph.mean(result2$model)
ph.mean(result3$model)

## variance
ph.var(result1$model)
ph.var(result2$model)
ph.var(result3$model)

## up to 5 moments 
ph.moment(5, result1$model)
ph.moment(5, result2$model)
ph.moment(5, result3$model)

</code></pre>

<hr>
<h2 id='phfit.point'>PH fitting with point data</h2><span id='topic+phfit.point'></span>

<h3>Description</h3>

<p>Estimates PH parameters from point data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phfit.point(ph, x, weights, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phfit.point_+3A_ph">ph</code></td>
<td>
<p>An object of R6 class for PH. The estimation algorithm is selected depending on this class.</p>
</td></tr>
<tr><td><code id="phfit.point_+3A_x">x</code></td>
<td>
<p>A vector for point data.</p>
</td></tr>
<tr><td><code id="phfit.point_+3A_weights">weights</code></td>
<td>
<p>A vector of weights for points.</p>
</td></tr>
<tr><td><code id="phfit.point_+3A_...">...</code></td>
<td>
<p>Further options for fitting methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with components, which is an object of S3 class <code>phfit.result</code>;
</p>
<table>
<tr><td><code>model</code></td>
<td>
<p>an object for estimated PH class.</p>
</td></tr>
<tr><td><code>llf</code></td>
<td>
<p>a value of the maximum log-likelihood.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>a value of degrees of freedom of the model.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>a value of Akaike information criterion.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>the number of iterations.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>a logical value for the convergence of estimation algorithm.</p>
</td></tr>
<tr><td><code>ctime</code></td>
<td>
<p>computation time (user time).</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>an object for data class</p>
</td></tr>
<tr><td><code>aerror</code></td>
<td>
<p>a value of absolute error for llf at the last step of algorithm.</p>
</td></tr>
<tr><td><code>rerror</code></td>
<td>
<p>a value of relative error for llf at the last step of algorithm.</p>
</td></tr>
<tr><td><code>options</code></td>
<td>
<p>a list of options used for fitting.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## make sample
wsample &lt;- rweibull(n=100, shape=2, scale=1)

## PH fitting for general PH
(result1 &lt;- phfit.point(ph=ph(2), x=wsample))

## PH fitting for CF1
(result2 &lt;- phfit.point(ph=cf1(2), x=wsample))

## PH fitting for hyper Erlang
(result3 &lt;- phfit.point(ph=herlang(3), x=wsample))

## mean
ph.mean(result1$model)
ph.mean(result2$model)
ph.mean(result3$model)

## variance
ph.var(result1$model)
ph.var(result2$model)
ph.var(result3$model)

## up to 5 moments 
ph.moment(5, result1$model)
ph.moment(5, result2$model)
ph.moment(5, result3$model)

</code></pre>

<hr>
<h2 id='pphase'>Distribution function of PH distribution</h2><span id='topic+pphase'></span>

<h3>Description</h3>

<p>Compute the cumulative distribution function (c.d.f.) for a given PH distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pphase(q, ph, lower.tail = TRUE, log.p = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pphase_+3A_q">q</code></td>
<td>
<p>A numeric vector of quantiles.</p>
</td></tr>
<tr><td><code id="pphase_+3A_ph">ph</code></td>
<td>
<p>An instance of PH distribution.</p>
</td></tr>
<tr><td><code id="pphase_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE, probabilities are P(X &lt;= x), otherwise P(X &gt; x).</p>
</td></tr>
<tr><td><code id="pphase_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are returned as log(p).</p>
</td></tr>
<tr><td><code id="pphase_+3A_...">...</code></td>
<td>
<p>Others</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of densities
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create a PH with specific parameters
(phdist &lt;- ph(alpha=c(1,0,0),
              Q=rbind(c(-4,2,0),c(2,-5,1),c(1,0,-1)),
              xi=c(2,2,0)))

## c.d.f. for 0, 0.1, ..., 1
pphase(q=seq(0, 1, 0.1), ph=phdist)

</code></pre>

<hr>
<h2 id='rphase'>Sampling of PH distributions</h2><span id='topic+rphase'></span>

<h3>Description</h3>

<p>Generate a sample from a given PH distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rphase(n, ph, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rphase_+3A_n">n</code></td>
<td>
<p>An integer of the number of samples.</p>
</td></tr>
<tr><td><code id="rphase_+3A_ph">ph</code></td>
<td>
<p>An instance of PH distribution.</p>
</td></tr>
<tr><td><code id="rphase_+3A_...">...</code></td>
<td>
<p>Others</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of samples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create a PH with specific parameters
(phdist &lt;- ph(alpha=c(1,0,0),
              Q=rbind(c(-4,2,0),c(2,-5,1),c(1,0,-1)),
              xi=c(2,2,0)))

## generate 10 samples
rphase(n=10, ph=phdist)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
