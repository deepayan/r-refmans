<!DOCTYPE html><html><head><title>Help for package BurStFin</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BurStFin}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#alpha.proxy'><p> Compute and Plot Alpha Proxy</p></a></li>
<li><a href='#factor.model.stat'><p> Estimate Variance Matrix via Statistical Factors</p></a></li>
<li><a href='#fitted.statfacmodBurSt'><p> Variance Matrix From Statistical Factor Model</p></a></li>
<li><a href='#partial.rainbow'><p> Create Palette Function for Part of Rainbow</p></a></li>
<li><a href='#slideWeight'><p> Generate Time Weights Flexiibly</p></a></li>
<li><a href='#threeDarr'>
<p>Combine matrices into 3D array</p></a></li>
<li><a href='#var.add.benchmark'><p> Expand a Variance Matrix to Include a Benchmark</p></a></li>
<li><a href='#var.relative.benchmark'><p> Transform a Variance Matrix to be Relative to a Benchmark</p></a></li>
<li><a href='#var.shrink.eqcor'><p>Ledoit-Wolf Shrinkage Variance Estimate</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-04-16</td>
</tr>
<tr>
<td>Title:</td>
<td>Burns Statistics Financial</td>
</tr>
<tr>
<td>Author:</td>
<td>Burns Statistics</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pat Burns &lt;patrick@burns-stat.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>stats</td>
</tr>
<tr>
<td>Description:</td>
<td>A suite of functions for finance, including the estimation
	of variance matrices via a statistical factor model or
	Ledoit-Wolf shrinkage.</td>
</tr>
<tr>
<td>License:</td>
<td>Unlimited</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.burns-stat.com/">https://www.burns-stat.com/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-18 11:53:41 UTC; alfre</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-18 12:12:29 UTC</td>
</tr>
</table>
<hr>
<h2 id='alpha.proxy'> Compute and Plot Alpha Proxy </h2><span id='topic+alpha.proxy'></span>

<h3>Description</h3>

<p>Computes (and possibly generates a contour plot of) the alpha proxy &ndash; a
measure of the effect that volatility and correlation have on the
utility of the investor.
As the name might suggest, it is in the same units as alpha (that is,
expected returns).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alpha.proxy(weight = 0.2, vol.man = 0.2, vol.bench = 0.2, 
	vol.other = 0.2, cor.man = 0.2, cor.bench = 0.2, 
	plot.it = TRUE, transpose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alpha.proxy_+3A_weight">weight</code></td>
<td>
 
<p>a number or vector of the fraction of the value of the investor's
entire portfolio that is given to the manager.
</p>
</td></tr>
<tr><td><code id="alpha.proxy_+3A_vol.man">vol.man</code></td>
<td>
 
<p>a number or vector giving the volatility of the manager's portfolio.
</p>
</td></tr>
<tr><td><code id="alpha.proxy_+3A_vol.bench">vol.bench</code></td>
<td>
 
<p>a number or vector giving the volatility of the benchmark.
</p>
</td></tr>
<tr><td><code id="alpha.proxy_+3A_vol.other">vol.other</code></td>
<td>
 
<p>a number or vector giving the volatility of the rest of the portfolio.
</p>
</td></tr>
<tr><td><code id="alpha.proxy_+3A_cor.man">cor.man</code></td>
<td>
 
<p>a number or vector giving the correlation between the manager's
portfolio and the rest of the investor's portfolio.
</p>
</td></tr>
<tr><td><code id="alpha.proxy_+3A_cor.bench">cor.bench</code></td>
<td>
 
<p>a number or vector giving the correlation between the benchmark
and the rest of the investor's portfolio.
</p>
</td></tr>
<tr><td><code id="alpha.proxy_+3A_plot.it">plot.it</code></td>
<td>
 
<p>logical value.
If <code>TRUE</code> and two of the arguments above have length greater
than 1, then a contour plot is created.
</p>
</td></tr>
<tr><td><code id="alpha.proxy_+3A_transpose">transpose</code></td>
<td>
 
<p>logical value.
If <code>TRUE</code>, then the variables on the axes of the contour
plot are switched.
</p>
</td></tr>
<tr><td><code id="alpha.proxy_+3A_...">...</code></td>
<td>
 
<p>additional arguments to <code>filled.contour</code> may be given.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of the alpha proxies (in basis points)
if less than 2 of the first 6 arguments have length more than 1.
</p>
<p>Otherwise it is a list (returned invisibly if <code>plot.it</code> is <code>TRUE</code>)
with the following components:
</p>
<table>
<tr><td><code>x</code></td>
<td>

<p>one of the vectors of inputs.
</p>
</td></tr>
<tr><td><code>y</code></td>
<td>

<p>the other vector of inputs.
</p>
</td></tr>
<tr><td><code>z</code></td>
<td>

<p>a matrix of the computed alpha proxies where rows correspond to
the values in <code>x</code> and the columns correspond to <code>y</code>.
The values are given in basis points.
</p>
</td></tr>
<tr><td><code>call</code></td>
<td>

<p>a character string of the image of the command that created
the object.
</p>
</td></tr>
</table>


<h3>Side Effects </h3>

<p>if <code>plot.it</code> is <code>TRUE</code>, then a contour plot is created.
</p>
<p>An error occurs if more than 2 of the first 6 arguments have length
greater than 1.
</p>


<h3>Details </h3>

<p>The first 6 arguments are the variables that determine the alpha proxy.
The investor is faced with the decision of hiring the manager for some
portion (the weight) of the portfolio rather than using a replication
of the benchmark.
If the alpha proxy is positive, then the volatility and correlation of
the manager's portfolio is improving whatever outperformance the manager
may have (or is offsetting the losses).
</p>


<h3>Revision </h3>

<p>This help was last revised 2010 January 05.
</p>


<h3>References</h3>

 
<p>Burns, Patrick (2003). &quot;Portfolio Sharpening&quot;. Working Paper,
Burns Statistics http://www.burns-stat.com/.
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+partial.rainbow">partial.rainbow</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># return vector of alpha proxies
alpha.proxy(weigh=.05, vol.man=.17, cor.man=seq(0, .2, len=21))

# create a contour plot
alpha.proxy(weigh=.05, vol.man=seq(.15, .25, len=20), 
	cor.man=seq(0, .2, len=21))

# commands used to create figures in the paper
alpha.proxy(vol.man=seq(.15, .25, len=50), weight=seq(.01, .7, leng=60), 
        color.palette=partial.rainbow(start=0, end=.32))

alpha.proxy(cor.man=seq(0, .3, len=50), weight=seq(.01, .7, leng=60), 
        color.palette=partial.rainbow(start=.07))

alpha.proxy(cor.man=seq(0, .3, len=50), vol.man=seq(.15, .25, leng=60), 
        color.palette=partial.rainbow(start=0))
</code></pre>

<hr>
<h2 id='factor.model.stat'> Estimate Variance Matrix via Statistical Factors </h2><span id='topic+factor.model.stat'></span>

<h3>Description</h3>

<p>Creates a variance matrix based on the principal components of the
variables that have no missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>factor.model.stat(x, weights = seq(0.5, 1.5, length.out = nobs), 
	output = "full", center = TRUE, frac.var = 0.5, iter.max = 1, 
	nfac.miss = 1, full.min = 20, reg.min = 40, sd.min = 20, 
	quan.sd = 0.9, tol = 0.001, zero.load = FALSE, 
	range.factors = c(0, Inf), constant.returns.okay = FALSE, 
	specific.floor = 0.1, floor.type = "quantile", verbose=2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="factor.model.stat_+3A_x">x</code></td>
<td>
 
<p>required.
A numeric matrix. 
The rows are observations and the columns are the variables.
In finance, this will be a matrix of returns where the rows are
times and the columns are assets.
For the default value of <code>weights</code> the most recent observation
should be the last row.
The number of columns may exceed the number of rows, and missing
values are accepted.
A column may even have all missing values.
</p>
</td></tr>
<tr><td><code id="factor.model.stat_+3A_weights">weights</code></td>
<td>
 
<p>a vector of observation weights, or <code>NULL</code>.
</p>
<p>Equal weights can be specified with <code>NULL</code> or with a 
single positive number.
</p>
<p>Otherwise, the length must be equal to either 
the original number of rows
in <code>x</code> or the number of rows in <code>x</code> minus the number
of rows that contain all missing values.
</p>
</td></tr>
<tr><td><code id="factor.model.stat_+3A_output">output</code></td>
<td>
 
<p>a character string indicating the form of the result.
It must partially match one of: <code>"full"</code>, <code>"systematic"</code>,
<code>"specific"</code> or <code>"factor"</code>.
</p>
</td></tr>
<tr><td><code id="factor.model.stat_+3A_center">center</code></td>
<td>
 
<p>either a logical value or a numeric vector with length equal to
the number of columns in <code>x</code>.
If <code>center</code> is <code>TRUE</code>, then the mean of each column is 
used as the center.
If <code>center</code> is <code>FALSE</code>, then the center for each variable
is taken to be zero.
</p>
</td></tr>
<tr><td><code id="factor.model.stat_+3A_frac.var">frac.var</code></td>
<td>
 
<p>a control on the number of factors to use &ndash; the number of factors
is chosen so that the factors account for (just over) <code>frac.var</code>
of the total variability.
</p>
</td></tr>
<tr><td><code id="factor.model.stat_+3A_iter.max">iter.max</code></td>
<td>
 
<p>the maximum number of times to iterate the search for 
principal factors of the variables with complete data.
</p>
</td></tr>
<tr><td><code id="factor.model.stat_+3A_nfac.miss">nfac.miss</code></td>
<td>
 
<p>a vector of integers giving the number of factors to use in regressions
for variables with missing values.
The number of factors used is equal to the i-th element of 
<code>nfac.miss</code> where i is the number of missing values for the
variable.
Thus the values in the vector should be non-increasing.
The last value is used when the number of missing values is greater
than the length of <code>nfac.miss</code>.
</p>
</td></tr>
<tr><td><code id="factor.model.stat_+3A_full.min">full.min</code></td>
<td>
 
<p>an integer giving the minimum number of variables that must have
complete data.
</p>
</td></tr>
<tr><td><code id="factor.model.stat_+3A_reg.min">reg.min</code></td>
<td>
 
<p>the minimum number of non-missing values for a variable in order
for a regression to be performed on the variable.
</p>
</td></tr>
<tr><td><code id="factor.model.stat_+3A_sd.min">sd.min</code></td>
<td>
 
<p>the minimum number of non-missing values for a variable in order
for the standard deviation to be estimated from the data.
</p>
</td></tr>
<tr><td><code id="factor.model.stat_+3A_quan.sd">quan.sd</code></td>
<td>
 
<p>the quantile of the standard deviations to use for the standard
deviation of variables that do not have enough data for the standard
deviation to be estimated.
</p>
</td></tr>
<tr><td><code id="factor.model.stat_+3A_tol">tol</code></td>
<td>
 
<p>a number giving the tolerance for the principal factor convergence
(using the assets with full data).
If the maximum change in uniquenesses (in the correlation scale) is
less than <code>tol</code> from one iteration to the next, then convergence
is assumed and the iterations end.
</p>
</td></tr>
<tr><td><code id="factor.model.stat_+3A_zero.load">zero.load</code></td>
<td>
 
<p>a logical value.
If <code>TRUE</code>, then loadings for variables with missing values are
zero except for those estimated by regression.
If <code>FALSE</code>, then loadings for variables with missing values are
the average loading for the factor (when they are not estimated
by regression).
</p>
</td></tr>
<tr><td><code id="factor.model.stat_+3A_range.factors">range.factors</code></td>
<td>
 
<p>a numeric vector that gives the maximum and minimum number of
factors that are allowed to be used.
</p>
</td></tr>
<tr><td><code id="factor.model.stat_+3A_constant.returns.okay">constant.returns.okay</code></td>
<td>
 
<p>a logical vector: if <code>TRUE</code>, then a column with all of its
non-missing values equal does not cause an error.
</p>
<p>if the true variance is thought to be non-zero, then
a better alternative to setting this to <code>TRUE</code> is to set all
the values in the column of <code>x</code> to be <code>NA</code>.
</p>
</td></tr>
<tr><td><code id="factor.model.stat_+3A_specific.floor">specific.floor</code></td>
<td>
 
<p>a number indicating how much uniquenesses should be adjusted upwards.
The meaning of this number depends on the value of the
<code>floor.type</code> argument.
</p>
</td></tr>
<tr><td><code id="factor.model.stat_+3A_floor.type">floor.type</code></td>
<td>
 
<p>a character string that partially matches one of:
<code>"quantile"</code> or <code>"fraction"</code>.
</p>
<p>If the value is <code>"quantile"</code>, then all uniquenesses are
made to be at least as big as the <code>specific.floor</code> quantile
of the uniquenesses.
</p>
<p>If the value is <code>"fraction"</code>, then all uniqueness are made
to be at least <code>specific.floor</code>.
</p>
</td></tr>
<tr><td><code id="factor.model.stat_+3A_verbose">verbose</code></td>
<td>
 
<p>a number indicating the level of warning messages desired.
This currently controls warnings:
</p>
<p>If at least 1, then a warning will be issued if all the values
in <code>x</code> are non-negative.  
In finance this is an indication that prices rather than returns
are input (an easy mistake to make).
</p>
<p>If at least 1, then a warning will be issued if there are any
assets with constant returns (unless <code>constant.returns.okay</code>
is <code>FALSE</code> in which case an error is thrown).
</p>
<p>If at least 2, then a warning will be issued if there are any
specific variances that are adjusted from being negative.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if <code>output</code> is <code>"full"</code>, then a variance matrix with dimensions
equal to the number of columns in the input <code>x</code>.
This has two additional attributes: <code>number.of.factors</code> that says
how many factors are used in the model, and <code>timestamp</code> that gives
the date and time that the object was created.
</p>
<p>if <code>output</code> is <code>"systematic"</code>, then a matrix with dimensions
equal to the number of columns in the input <code>x</code> that contains
the systematic portion of the variance matrix.
</p>
<p>if <code>output</code> is <code>"specific"</code>, then a diagonal matrix with dimensions
equal to the number of columns in the input <code>x</code> that contains
the specific variance portion of the variance matrix.
The full variance matrix is the sum of the systematic and specific matrices.
</p>
<p>If <code>output</code> is <code>"factor"</code>, then an object of class
<code>"statfacmodBurSt"</code> which is a list with components:
</p>
<table>
<tr><td><code>loadings</code></td>
<td>

<p>a matrix of the loadings for the correlation matrix.
</p>
</td></tr>
<tr><td><code>uniquenesses</code></td>
<td>

<p>the uniquenesses for the correlation matrix.
That is, the proportion of the variance that is not explained
by the factors.
</p>
<p>Note that if there are uniquenesses that have been modified
via the <code>specific.floor</code> argument, then the actual proportion
is the stated proportion divided by one plus the modification.
</p>
</td></tr>
<tr><td><code>sdev</code></td>
<td>

<p>the standard deviations for the variables.
</p>
<p>Note that if there are uniquenesses that have been modified
via the <code>specific.floor</code> argument, then the corresponding
standard deviations in <code>sdev</code> are smaller than the actual
standard deviations in the answer.
</p>
</td></tr>
<tr><td><code>constant.names</code></td>
<td>

<p>A character vector giving the names of the variables that are
constant (if any).
</p>
</td></tr>
<tr><td><code>cumulative.variance.fraction</code></td>
<td>

<p>numeric vector giving the cumulative fraction of the variance 
explained by (all) the factors.
</p>
</td></tr>
<tr><td><code>timestamp</code></td>
<td>

<p>character string giving the date and time the calculation
was completed.
</p>
</td></tr>
<tr><td><code>call</code></td>
<td>

<p>an image of the call that created the object.
</p>
</td></tr>
</table>


<h3>Details </h3>

<p>Observations that are missing on all variables are deleted. 
Then a principal components factor model is estimated 
with the variables that have complete data.
</p>
<p>For variables that have missing values, the standard deviation is estimated
when there are enough obeservations otherwise a given quantile of the 
standard deviations of the other assets is used as the estimate.
The loadings for these variables are set to be either 
the average loading for the variables with no missing data, or zero. 
The loadings for the most important factors are modified by performing a 
regression with the non-missing data for each variable (if there is enough
data to do the regression).
</p>
<p>The treatment of variables with missing values can be quite important.
You may well benefit from specializing how missing values are handled to
your particular problem.
To do this, set the output to <code>"factor"</code> &ndash; then you can modify the
loadings (and per force the uniquenesses), and the standard deviations to
fit your situation.
This may include taking sectors and countries into account, for example.
</p>
<p>The default settings for missing value treatment are suitable for creating
a variance matrix for long-only portfolio optimization &ndash; high volatility
and average correlation.
Take note that the proper treatment of missing values is HIGHLY dependent on
the use to which the variance matrix is to be put.
</p>
<p>OBSERVATION WEIGHTS.
Time weights are quite helpful for estimating variances from returns.
The default weighting seems to perform reasonably well over a range of
situations.
</p>
<p>FACTOR MODEL TO FULL MODEL.
This class of object has a method for <code>fitted</code> which
returns the variance matrix corresponding to the factor model representation.
</p>


<h3>Warning </h3>

<p>The default value for <code>weights</code> assumes that the last row is the most
recent observation and the first observation is the most ancient observation.
</p>


<h3>Research Issues </h3>

<p>The method of handling missing values used in the function has not
been well studied.
It seems not to be the worst approach, but undoubtedly can be improved.
</p>
<p>The default method of boosting the result away from singularity
is completely unstudied.
For optimization it is wise to move away from singularity, just how to do
that best seems like a research question.
</p>


<h3>Revision </h3>

<p>This help was last revised 2014 March 09.
</p>


<h3>Author(s)</h3>

<p> Burns Statistics </p>


<h3>See Also</h3>

 <p><code><a href="#topic+fitted.statfacmodBurSt">fitted.statfacmodBurSt</a></code>, 
<code><a href="#topic+var.shrink.eqcor">var.shrink.eqcor</a></code>, <code>cov.wt</code>,
<code><a href="#topic+slideWeight">slideWeight</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
varian1 &lt;- factor.model.stat(retmat)

varfac &lt;- factor.model.stat(retmat, nfac=0, zero=TRUE, output="fact")

varian2 &lt;- fitted(varfac) # get matrix from factor model

varian3 &lt;- factor.model.stat(retmat, nfac=rep(c(5,3,1), c(20,40,1)))

## End(Not run)
</code></pre>

<hr>
<h2 id='fitted.statfacmodBurSt'> Variance Matrix From Statistical Factor Model </h2><span id='topic+fitted.statfacmodBurSt'></span>

<h3>Description</h3>

<p>Takes a statistical factor model object and produces the variance matrix
that it represents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'statfacmodBurSt'
fitted(object, output = "full", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.statfacmodBurSt_+3A_object">object</code></td>
<td>
 
<p>an object of class <code>statfacmodBurSt</code>.
</p>
</td></tr>
<tr><td><code id="fitted.statfacmodBurSt_+3A_output">output</code></td>
<td>
 
<p>a character string that must partially match one of:
<code>"full"</code>, <code>"systematic"</code>, <code>"specific"</code>.
</p>
</td></tr>
<tr><td><code id="fitted.statfacmodBurSt_+3A_...">...</code></td>
<td>
 
<p>not used, but allows methods for inheriting objects to have
additional arguments.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric matrix of the variance represented by the factor model, or the
systematic or specific variance portion of the model.
</p>
<p>This has two additional attributes:
</p>
<table>
<tr><td><code>number.of.factors</code></td>
<td>

<p>the number of factors used in the model.
</p>
</td></tr>
<tr><td><code>timestamp</code></td>
<td>

<p>the date and time at which the model was originally created.
</p>
</td></tr>
</table>


<h3>Revision </h3>

<p>This help was last revised 2012 February 12.
</p>


<h3>Author(s)</h3>

<p> Burns Statistics </p>


<h3>See Also</h3>

 
<p><code><a href="#topic+factor.model.stat">factor.model.stat</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
varfac &lt;- factor.model.stat(retmat, zero=TRUE, output="factor")
# perhaps modify loadings and uniquenesses for missing values
varian2 &lt;- fitted(varfac) # get variance matrix from factor model

specif &lt;- fitted(varfac, output="specific") # diagonal matrix

## End(Not run)

</code></pre>

<hr>
<h2 id='partial.rainbow'> Create Palette Function for Part of Rainbow</h2><span id='topic+partial.rainbow'></span>

<h3>Description</h3>

<p>Returns a function suitable as the <code>color.palette</code> argument
to <code>filled.contour</code> that contains a specified portion of the
rainbow.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partial.rainbow(start = 0, end = 0.35)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partial.rainbow_+3A_start">start</code></td>
<td>
 
<p>a number giving where the colors should start.
Valid numbers range from 0 (red) to 1 (also red).
</p>
</td></tr>
<tr><td><code id="partial.rainbow_+3A_end">end</code></td>
<td>
 
<p>a number giving where the colors should end.
Valid numbers range from 0 (red) to 1 (also red).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function similar to <code>rainbow</code> but with the <code>start</code>
and <code>end</code> arguments (possibly) changed.
</p>


<h3>Details </h3>

<p>This function was made to facilitate the construction of contour
plots in the <code>alpha.proxy</code> function, but is of general use.
</p>


<h3>Revision </h3>

<p>This help was last revised 2010 January 05.
</p>


<h3>References</h3>

 
<p>Burns, Patrick (2003). &quot;Portfolio Sharpening&quot;. Working Paper,
Burns Statistics http://www.burns-stat.com/.
</p>


<h3>See Also</h3>

 
<p><code><a href="grDevices.html#topic+rainbow">rainbow</a></code>, <code><a href="graphics.html#topic+filled.contour">filled.contour</a></code>, <code><a href="#topic+alpha.proxy">alpha.proxy</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ap1 &lt;- alpha.proxy(cor.man=seq(0, .3, len=50), 
	vol.man=seq(.15, .25, leng=60), plot=FALSE)
filled.contour(ap1, color.palette=partial.rainbow(start=.05, end=.3))
</code></pre>

<hr>
<h2 id='slideWeight'> Generate Time Weights Flexiibly</h2><span id='topic+slideWeight'></span>

<h3>Description</h3>

<p>Returns a vector of weights between 1 and 0 (inclusive).
The general form is: some recent weights are 1, some early weights are 0, 
and weights between these vary linearly.
It is allowable for no points to be specified as 0 or 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slideWeight(n, fractions = c(0, 1), observations = NULL, 
	locations = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slideWeight_+3A_n">n</code></td>
<td>
 
<p>the length of the result &ndash; the number of observations.
</p>
</td></tr>
<tr><td><code id="slideWeight_+3A_fractions">fractions</code></td>
<td>
 
<p>length 2 numeric vector giving the fraction of the way 
between 0 and <code>n</code> where the ends of the linear slide 
should be.
There is no requirement that the fractions need to be between 0 and 1.
</p>
<p>This is ignored if <code>observations</code> or <code>locations</code> is given.
</p>
</td></tr>
<tr><td><code id="slideWeight_+3A_observations">observations</code></td>
<td>
 
<p>length 2 numeric vector giving the number of observations that 
should be 1 and the number of observations that should have 
any weight.
The smaller is taken to be the former and the larger as the latter.
</p>
</td></tr>
<tr><td><code id="slideWeight_+3A_locations">locations</code></td>
<td>
 
<p>length 2 numeric vector giving the locations (subscripts) for the
ends of the linear slide.
The smaller number is the index of the last 0, 
the larger is the index of the last value smaller than 1.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector of length <code>n</code> with values within the range
of 0 and 1 (inclusive).
The values are non-decreasing &ndash; meaning put more weight on more
recent observations.
</p>


<h3>Details </h3>

<p>The arguments <code>fractions</code>, <code>observations</code> and <code>locations</code>
are all to control where the ends of the weights strictly between 0 and 1 are.
Only one of them is used.
<code>locations</code> takes precedence.
<code>fractions</code> is used if neither of the other two are given.
</p>
<p>This is suitable to give as the <code>weights</code> argument to 
<code>var.shrink.eqcor</code> and <code>factor.model.stat</code>.
</p>


<h3>Revision </h3>

<p>This help was last revised 2014 March 09.
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+var.shrink.eqcor">var.shrink.eqcor</a></code>, <code><a href="#topic+factor.model.stat">factor.model.stat</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># examples assume number of observations is 200

# all weights either 0 or 1
rollwin50 &lt;- slideWeight(200, observations=c(50,50))

# 50 with full weight, 100 more with partial weight
swght50.150 &lt;- slideWeight(200, observations=c(50, 150))

# approximately default weights of var.shrink.eqcor and factor.model.stat
lindec3 &lt;- slideWeight(200, fractions=c(-1/2, 3/2))
</code></pre>

<hr>
<h2 id='threeDarr'> 
Combine matrices into 3D array
</h2><span id='topic+threeDarr'></span>

<h3>Description</h3>

<p>Returns a three-dimensional array given one or more matrices
and instructions on how to combine them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>threeDarr(..., rep = 1, union = TRUE, slicenames = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="threeDarr_+3A_...">...</code></td>
<td>
 
<p>one or more matrices.
</p>
</td></tr>
<tr><td><code id="threeDarr_+3A_rep">rep</code></td>
<td>
 
<p>an integer saying how many times to replicate the slices.
</p>
</td></tr>
<tr><td><code id="threeDarr_+3A_union">union</code></td>
<td>
 
<p>logical value: if <code>TRUE</code>, then the union of row and column
names is created in the output.
If <code>FALSE</code>, then the intersection is done.
</p>
</td></tr>
<tr><td><code id="threeDarr_+3A_slicenames">slicenames</code></td>
<td>
 
<p>a character vector with length equal to the number of slices
in the resulting array.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an array with the first two dimensions being the union or
intersection of the first two dimensions of the input matrices,
and third dimension equal to the number of input matrices times
the number of replications.
</p>


<h3>Details </h3>

<p>The full name of arguments <code>rep</code>, <code>union</code> and <code>slicenames</code>
must be given (no abbreviations)
because they come after the three-dots construct.
</p>


<h3>Revision </h3>

<p>This help was last revised 2012 January 22.
</p>


<h3>See Also</h3>

 
<p>More general functionality of this sort can be found in the
<code>abind</code> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
multiple.var &lt;- threeDarr(var1, var2, slicenames=c("standardVar", "crashVar"))

reparr &lt;- threeDarr(matrix1, rep=3)

## End(Not run)
</code></pre>

<hr>
<h2 id='var.add.benchmark'> Expand a Variance Matrix to Include a Benchmark </h2><span id='topic+var.add.benchmark'></span>

<h3>Description</h3>

<p>Takes a variance matrix (or 3-dimensional array) and a vector of weights 
for the benchmark.
An object like the input is returned which includes a new asset 
representing the benchmark.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var.add.benchmark(variance, benchmark.weights, name = "benchmark",
	sum.to.one = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var.add.benchmark_+3A_variance">variance</code></td>
<td>
 
<p>required.
A variance matrix or a three-dimensional array 
where each slice of the third dimension is a variance matrix.
This must have dimnames which specify the assets, and it must
include all of the assets named in <code>benchmark.weights</code>.
</p>
</td></tr>
<tr><td><code id="var.add.benchmark_+3A_benchmark.weights">benchmark.weights</code></td>
<td>
 
<p>required.
A named vector giving the weights of the constituents of the benchmark.
</p>
</td></tr>
<tr><td><code id="var.add.benchmark_+3A_name">name</code></td>
<td>
 
<p>character string to be used as the asset name for the benchmark.
</p>
</td></tr>
<tr><td><code id="var.add.benchmark_+3A_sum.to.one">sum.to.one</code></td>
<td>
 
<p>logical vector stating whether to check and enforce that 
<code>benchmark.weights</code> sums to one.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix or array similar to the input <code>variance</code>, but including
an additional asset.
</p>


<h3>Details </h3>

<p>The (absolute value of) the weights ideally sum to one.
You can give it weights that do not sum to one (perhaps they sum to 100
or the market cap of the benchmark), but you will get a warning that the
weights are being adjusted.
</p>
<p>If your &quot;benchmark&quot; is something that doesn't sum to 1 (such as 
portfolio weights minus benchmark weights), then set the <code>sum.to.one</code>
argument to <code>FALSE</code>.
</p>


<h3>Revision </h3>

<p>This help was last revised 2012 January 20.
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+var.relative.benchmark">var.relative.benchmark</a></code>, <code><a href="#topic+var.shrink.eqcor">var.shrink.eqcor</a></code>,
<code><a href="#topic+factor.model.stat">factor.model.stat</a></code>, <code><a href="#topic+threeDarr">threeDarr</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
varian.ben &lt;- var.add.benchmark(varian, ftse.constituents, "ftse100")

## End(Not run)

var.orig &lt;- array(c(400, 32, 24, 32, 64, 9.6, 24, 9.6, 144), c(3,3),
	list(c("equities", "bonds", "commodities"), 
	c("equities", "bonds", "commodities")))
var.aa &lt;- var.add.benchmark(var.orig, c(equities=.6, bonds=.4), "e60b40")
</code></pre>

<hr>
<h2 id='var.relative.benchmark'> Transform a Variance Matrix to be Relative to a Benchmark </h2><span id='topic+var.relative.benchmark'></span>

<h3>Description</h3>

<p>Returns a matrix (or 3-dimensional array) with dimensions 
one smaller than the input.
The returned variance is relative to the benchmark.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var.relative.benchmark(variance, benchmark)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var.relative.benchmark_+3A_variance">variance</code></td>
<td>
 
<p>required.
A variance matrix or a three-dimensional array 
where each slice of the third dimension is a variance matrix.
</p>
</td></tr>
<tr><td><code id="var.relative.benchmark_+3A_benchmark">benchmark</code></td>
<td>
 
<p>required.
A character string naming which asset in <code>variance</code> is to be
used as the benchmark.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix or array similar to the input <code>variance</code>, but with one
less asset and containing variances that are relative to that asset.
</p>
<p>There is a <code>call</code> attribute which gives the command that created
the object (and hence the benchmark to which the object is relative).
</p>


<h3>Revision </h3>

<p>This help was last revised 2012 January 20.
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+var.add.benchmark">var.add.benchmark</a></code>, <code><a href="#topic+var.shrink.eqcor">var.shrink.eqcor</a></code>,
<code><a href="#topic+factor.model.stat">factor.model.stat</a></code>, <code><a href="#topic+threeDarr">threeDarr</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>var.orig &lt;- array(c(400, 32, 24, 32, 64, 9.6, 24, 9.6, 144), c(3,3),
	list(c("equities", "bonds", "commodities"), 
	c("equities", "bonds", "commodities")))
var.aa &lt;- var.add.benchmark(var.orig, c(equities=.6, bonds=.4), "e60b40")

var.rel &lt;- var.relative.benchmark(var.aa, "e60b40")
</code></pre>

<hr>
<h2 id='var.shrink.eqcor'>Ledoit-Wolf Shrinkage Variance Estimate </h2><span id='topic+var.shrink.eqcor'></span>

<h3>Description</h3>

<p>Returns a variance matrix that shrinks towards the equal correlation 
matrix &ndash; a Ledoit-Wolf estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var.shrink.eqcor(x, weights = seq(0.5, 1.5, length = nt), shrink = NULL, 
	center = TRUE, vol.shrink = 0, sd.min = 20, quan.sd = 0.9, 
	tol = 1e-4, compatible = FALSE, verbose=2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var.shrink.eqcor_+3A_x">x</code></td>
<td>
 
<p>required.
A numeric matrix.
The rows are observations and the columns are the variables.
In finance, this will be a matrix of returns where the rows are
times and the columns are assets.
For the default value of <code>weights</code> the most recent observation
should be the last row.
The number of columns may exceed the number of rows, and missing
values are accepted.
A column may even have all missing values.
</p>
</td></tr>
<tr><td><code id="var.shrink.eqcor_+3A_weights">weights</code></td>
<td>
 
<p>a numeric vector giving the observation weights, or <code>NULL</code>.
</p>
<p>Equal weights can be specified with <code>NULL</code> or with a 
single positive number.
</p>
<p>Otherwise, this must be a
vector of non-negative numbers that is as long as the number
of observations (rows of <code>x</code>).
</p>
</td></tr>
<tr><td><code id="var.shrink.eqcor_+3A_shrink">shrink</code></td>
<td>

<p>either <code>NULL</code> meaning the shrinkage will be estimated,
or a single number meant to be in the range of zero to one.
</p>
</td></tr>
<tr><td><code id="var.shrink.eqcor_+3A_center">center</code></td>
<td>

<p>either a single logical value, or a numeric vector as long as
the number of columns of <code>x</code>.
This gives the expected value of each column. 
A value of <code>TRUE</code> means the (weighted) mean of the columns
of <code>x</code> is used.
A value of <code>FALSE</code> means zero is used.
</p>
</td></tr>
<tr><td><code id="var.shrink.eqcor_+3A_vol.shrink">vol.shrink</code></td>
<td>
 
<p>a number between zero and one (inclusive) that says how much to
shrink the standard deviations towards the mean standard deviation.
</p>
</td></tr>
<tr><td><code id="var.shrink.eqcor_+3A_sd.min">sd.min</code></td>
<td>
 
<p>a single integer giving the minimum number of observations needed
in a column of <code>x</code> for the estimated standard deviation to be
used.
</p>
</td></tr>
<tr><td><code id="var.shrink.eqcor_+3A_quan.sd">quan.sd</code></td>
<td>
 
<p>a single number in the range of zero to one (inclusive) that says
what quantile of the (used) standard deviations to use as the
estimate of standard deviation for columns without enough (or any)
data.
</p>
</td></tr>
<tr><td><code id="var.shrink.eqcor_+3A_tol">tol</code></td>
<td>
 
<p>a single number indicating how large the smallest eigenvalues
of the answer should be.
All eigenvalues are made to be no smaller than <code>tol</code> times the
maximum eigenvalue.
</p>
</td></tr>
<tr><td><code id="var.shrink.eqcor_+3A_compatible">compatible</code></td>
<td>
 
<p>a logical value.
If <code>TRUE</code>, then the variance is scaled by the number of
observations rather than one less than the number of observations,
and there will be a warning if <code>weights</code> are not all the same.
This makes the results compatible with Ledoit-Wolf computations
and with the <code>cov.shrink</code> function in package <code>tawny</code>.
This also makes the variances smaller, which is not necessarily
a good thing.
</p>
</td></tr>
<tr><td><code id="var.shrink.eqcor_+3A_verbose">verbose</code></td>
<td>
 
<p>a number indicating the level of warning messages desired.
This currently controls only one warning:
</p>
<p>If at least 1, then a warning will be issued if all the values
in <code>x</code> are non-negative.  
In finance this is an indication that prices rather than returns
are input (an easy mistake to make).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an estimate of the variance matrix of <code>x</code>.
The sample variance is shrunk towards equal correlation.
</p>
<p>This has two additional attributes:
</p>
<table>
<tr><td><code>shrink</code></td>
<td>

<p>the estimated or input amount of shrinkage towards the equal
correlation matrix from the sample variance.
</p>
</td></tr>
<tr><td><code>timedate</code></td>
<td>

<p>the date and time at which the computation was done.
</p>
</td></tr>
</table>


<h3>Details </h3>

<p>Time weights are quite helpful for estimating variances from returns.
The default weighting seems to perform reasonably well over a range of
situations.
However, time weighting was not studied for this estimator.
</p>


<h3>Warning </h3>

<p>The default value for <code>weights</code> assumes that the last row is the most
recent observation and the first observation is the most ancient observation.
</p>


<h3>Research Issues </h3>

<p>The method of handling missing values used in the function has not
been studied (at all).
</p>
<p>The method of boosting the result away from singularity
is completely unstudied.
For optimization it is wise to move away from singularity, just how to do
that best seems like a research question.
The method used boosts the smallest eigenvalues, it might be better
to increase the diagonal.
</p>


<h3>Revision </h3>

<p>This help was last revised 2014 March 09.
</p>


<h3>Author(s)</h3>

<p> Burns Statistics </p>


<h3>References</h3>

 
<p>Olivier Ledoit and Michael Wolf (2004) &quot;Honey, I shrunk the sample 
covariance matrix&quot;. The Journal of Portfolio Management, volume 30,
number 4.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+factor.model.stat">factor.model.stat</a></code>, <code>cov.wt</code>,
<code><a href="#topic+slideWeight">slideWeight</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
var1 &lt;- var.shrink.eqcor(return.matrix)

var.unweighted &lt;- var.shrink.eqcor(return.matrix, weights=1)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
