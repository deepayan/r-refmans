<!DOCTYPE html><html lang="en"><head><title>Help for package SwimmeR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SwimmeR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#+25notin+25'><p>&quot;Not in&quot; function</p></a></li>
<li><a href='#add_event_dummy_row'><p>Add dummy entry rows</p></a></li>
<li><a href='#add_row_numbers'><p>Add row numbers to raw results</p></a></li>
<li><a href='#age_format'><p>Formatting yyy-mm ages as years</p></a></li>
<li><a href='#age_format_helper'><p>Helper function for formatting yyy-mm ages as years, enables vectorization of</p>
<code>age_format</code></a></li>
<li><a href='#clean_events'><p>Regularizes event names</p></a></li>
<li><a href='#coalesce_many'><p>Combined paired sets of columns following a join operation</p></a></li>
<li><a href='#coalesce_many_helper'><p>Combined paired sets of columns following a join operation</p></a></li>
<li><a href='#collect_relay_swimmers'><p>Collects relay swimmers as a data frame within <code>swim_parse</code></p></a></li>
<li><a href='#collect_relay_swimmers_old'><p>Collects relay swimmers as a data frame within <code>swim_parse_old</code></p></a></li>
<li><a href='#collect_relay_swimmers_omega'><p>Collects relay swimmers as a data frame within <code>swim_parse_omega</code></p></a></li>
<li><a href='#collect_relay_swimmers_splash'><p>Collects relay swimmers as a data frame within <code>swim_parse_splash</code></p></a></li>
<li><a href='#correct_split_distance'><p>Changes lengths associated with splits to new values</p></a></li>
<li><a href='#correct_split_distance_helper'><p>Changes lengths associated with splits to new values</p></a></li>
<li><a href='#course_convert'><p>Swimming Course Converter</p></a></li>
<li><a href='#course_convert_DF'><p>Course converter, returns data frame - defunct</p></a></li>
<li><a href='#course_convert_helper'><p>Swimming Course Convertor Helper</p></a></li>
<li><a href='#discard_errors'><p>Discards elements of list that have an error value from <code>purrr::safely</code>.</p></a></li>
<li><a href='#dive_place'><p>Adds places to diving results</p></a></li>
<li><a href='#draw_bracket'><p>Creates a bracket for tournaments involving 5 to 64 teams, single elimination</p></a></li>
<li><a href='#event_parse'><p>Pulls out event labels from text</p></a></li>
<li><a href='#event_parse_ISL'><p>Pulls out event labels from text</p></a></li>
<li><a href='#fill_down'><p>Fills NA values with previous non-NA value</p></a></li>
<li><a href='#fill_left'><p>Shifts non-NA values to left in data frame</p></a></li>
<li><a href='#fold'><p>Fold a vector onto itself</p></a></li>
<li><a href='#format_results'><p>Formats data for analysis within <code>swim_parse</code></p></a></li>
<li><a href='#generate_row_to_add'><p>Create a one-line data frame containing an entry to be appended to an</p>
in-progress data frame of all entries</a></li>
<li><a href='#get_mode'><p>Find the mode (most commonly occurring) element of a list</p></a></li>
<li><a href='#heat_parse_omega'><p>Pulls out heat labels from text</p></a></li>
<li><a href='#hy3_parse'><p>Parses Hy-Tek .hy3 files</p></a></li>
<li><a href='#hy3_places'><p>Helper for reading prelims and finals places from Hy-Tek .hy3 files</p></a></li>
<li><a href='#hy3_times'><p>Helper for reading prelims and finals times from Hy-Tek .hy3 files</p></a></li>
<li><a href='#hytek_clean_strings'><p>Cleans input strings</p></a></li>
<li><a href='#hytek_length_3_DQ_sort'><p>Sort data in DQ lists of length 3 within <code>hytek_swim_parse</code></p></a></li>
<li><a href='#hytek_length_3_sort'><p>Sort data in lists of length 3 within <code>hytek_swim_parse</code></p></a></li>
<li><a href='#hytek_length_4_DQ_sort'><p>Sort data in DQ lists of length 4 within <code>hytek_swim_parse</code></p></a></li>
<li><a href='#hytek_length_4_sort'><p>Sort data in lists of length 4 within <code>hytek_swim_parse</code></p></a></li>
<li><a href='#hytek_length_5_sort'><p>Sort data in lists of length 5 within <code>hytek_swim_parse</code></p></a></li>
<li><a href='#hytek_length_6_sort'><p>Sort data in lists of length 6 within <code>hytek_swim_parse</code></p></a></li>
<li><a href='#hytek_length_7_sort'><p>Sort data in lists of length 7 within <code>hytek_swim_parse</code></p></a></li>
<li><a href='#hytek_length_8_sort'><p>Sort data in lists of length 8 within <code>hytek_swim_parse</code></p></a></li>
<li><a href='#hytek_length_9_sort'><p>Sort data in lists of length 9 within <code>hytek_swim_parse</code></p></a></li>
<li><a href='#interleave_results'><p>Helper for reading interleaving prelims and finals results</p></a></li>
<li><a href='#is_link_broken'><p>Determines if a link is valid</p></a></li>
<li><a href='#King200Breast'><p>Results for Lilly King's 200 Breaststrokes</p></a></li>
<li><a href='#lines_sort'><p>Sorts and collects lines by performance and row number</p></a></li>
<li><a href='#list_breaker'><p>Breaks out lists of lists by sub-list length</p></a></li>
<li><a href='#list_to_list_names'><p>Initialize a named list of lists</p></a></li>
<li><a href='#list_transform'><p>Transform list of lists into data frame</p></a></li>
<li><a href='#make_lineup'><p>Determine optimal entries against a given opponent lineup</p></a></li>
<li><a href='#make_lineup_helper'><p>Determine optimal entries against a given opponent lineup</p></a></li>
<li><a href='#make_lineup_helper_2'><p>Assign overpowered entries</p></a></li>
<li><a href='#mmss_format'><p>Formatting seconds as mm:ss.hh</p></a></li>
<li><a href='#na_pad'><p>Pads shorter lists in a list-of-lists with <code>NA</code>s such that all lists are</p>
the same length</a></li>
<li><a href='#name_reorder'><p>Orders all names as &quot;Firstname Lastname&quot;</p></a></li>
<li><a href='#place'><p>Add places to results</p></a></li>
<li><a href='#reaction_times_parse'><p>Pulls out reaction times from text</p></a></li>
<li><a href='#read_htm'><p>Read in html files of swimming results</p></a></li>
<li><a href='#read_hy3'><p>Read in hy3 files of swimming results</p></a></li>
<li><a href='#read_pdf'><p>Read in pdf files of swimming results</p></a></li>
<li><a href='#Read_Results'><p>Reads swimming and diving results into a list of strings in preparation for</p>
parsing with <code>swim_parse</code></a></li>
<li><a href='#read_results_flag'><p>used to indicate that results have been read in with <code>read_results</code></p>
prior to being parsed by <code>swim_parse</code></a></li>
<li><a href='#replacement_entries'><p>Replaces superseded rows</p></a></li>
<li><a href='#results_score'><p>Scores a swim meet</p></a></li>
<li><a href='#sec_format'><p>Formatting mm:ss.tt times as seconds</p></a></li>
<li><a href='#sec_format_helper'><p>Helper function for formatting mm:ss.hh times as seconds, used to enable</p>
vectorized operation of <code>sec_format</code></a></li>
<li><a href='#splash_clean_strings'><p>Cleans input strings</p></a></li>
<li><a href='#splash_collect_splits'><p>Collects Splash format splits</p></a></li>
<li><a href='#splash_determine_indent_length'><p>Determines indent length for data within <code>swim_parse_splash</code></p></a></li>
<li><a href='#splash_length_10_sort'><p>Sort data in lists of length 10 within <code>splash_swim_parse</code></p></a></li>
<li><a href='#splash_length_11_sort'><p>Sort data in lists of length 11 within <code>splash_swim_parse</code></p></a></li>
<li><a href='#splash_length_12_sort'><p>Sort data in lists of length 12 within <code>splash_swim_parse</code></p></a></li>
<li><a href='#splash_length_4_sort'><p>Sort data in lists of length 4 within <code>spash_swim_parse</code></p></a></li>
<li><a href='#splash_length_5_sort'><p>Sort data in lists of length 5 within <code>spash_swim_parse</code></p></a></li>
<li><a href='#splash_length_6_sort'><p>Sort data in lists of length 6 within <code>spash_swim_parse</code></p></a></li>
<li><a href='#splash_length_7_sort'><p>Sort data in lists of length 7 within <code>spash_swim_parse</code></p></a></li>
<li><a href='#splash_length_8_sort'><p>Sort data in lists of length 8 within <code>spash_swim_parse</code></p></a></li>
<li><a href='#splash_length_9_sort'><p>Sort data in lists of length 9 within <code>spash_swim_parse</code></p></a></li>
<li><a href='#splits_parse'><p>Collects splits within <code>swim_parse</code></p></a></li>
<li><a href='#splits_parse_ISL'><p>Collects splits within <code>swim_parse_ISL</code></p></a></li>
<li><a href='#splits_parse_omega_relays'><p>Collects splits for relays within <code>swim_parse_omega</code></p></a></li>
<li><a href='#splits_parse_splash'><p>Collects splits within <code>swim_parse_splash</code> for Splash results</p></a></li>
<li><a href='#splits_parse_splash_helper_1'><p>Produces data frames of splits within <code>swim_parse_splash</code> for Splash</p>
results</a></li>
<li><a href='#splits_parse_splash_helper_2'><p>Produces data frames of splits within <code>swim_parse_splash</code> for Splash</p>
results</a></li>
<li><a href='#splits_parse_splash_relays'><p>Collects splits for relays within <code>swim_parse_splash</code></p></a></li>
<li><a href='#splits_reform'><p>Adds together splits and compares to listed finals time to see if they match.</p></a></li>
<li><a href='#splits_rename_omega'><p>Advances split names by one split_length</p></a></li>
<li><a href='#splits_to_cumulative'><p>Converts splits from lap to cumulative format</p></a></li>
<li><a href='#splits_to_cumulative_helper_recalc'><p>Helper function for converting lap splits to cumulative splits</p></a></li>
<li><a href='#splits_to_lap'><p>Converts splits from cumulative to lap format</p></a></li>
<li><a href='#splits_to_lap_helper_recalc'><p>Helper function for converting cumulative splits to lap splits</p></a></li>
<li><a href='#Swim_Parse'><p>Formats swimming and diving data read with <code>read_results</code> into a data</p>
frame</a></li>
<li><a href='#swim_parse_hytek'><p>Formats Hytek style swimming and diving data read with <code>read_results</code></p>
into a data frame</a></li>
<li><a href='#swim_parse_ISL'><p>Formats swimming results from the International Swim League ('ISL') read with</p>
<code>read_results</code> into a data frame</a></li>
<li><a href='#swim_parse_old'><p>Formats swimming and diving data read with <code>read_results</code> into a data</p>
frame</a></li>
<li><a href='#swim_parse_omega'><p>Formats Omega style swimming and diving data read with <code>read_results</code></p>
into a data frame</a></li>
<li><a href='#swim_parse_samms'><p>Formats swimming and diving data read with <code>read_results</code> into a</p>
dataframe</a></li>
<li><a href='#swim_parse_splash'><p>Formats Splash style swimming and diving data read with <code>read_results</code></p>
into a data frame</a></li>
<li><a href='#swim_place'><p>Add places to swimming results</p></a></li>
<li><a href='#SwimmeR-defunct'><p>Defunct functions in SwimmeR</p></a></li>
<li><a href='#SwimmeR-deprecated'><p>Deprecated functions in SwimmeR</p></a></li>
<li><a href='#tie_rescore'><p>Rescore to account for ties</p></a></li>
<li><a href='#toptimes_parse_hytek'><p>Formats Hytek style swimming and diving Top Times reports read with</p>
<code>read_results</code> into a data frame</a></li>
<li><a href='#undo_interleave'><p>Undoes interleaving of lists</p></a></li>
<li><a href='#update_rank_helper'><p>Create a one-line data frame containing an entry to be appended to an</p>
in-progress data frame of all entries</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Data Import, Cleaning, and Conversions for Swimming Results</td>
</tr>
<tr>
<td>Version:</td>
<td>0.14.2</td>
</tr>
<tr>
<td>Description:</td>
<td>The goal of the 'SwimmeR' package is to provide means of acquiring, and then analyzing, data from swimming (and diving) competitions.  To that end 'SwimmeR' allows results to be read in from .html sources, like 'Hy-Tek' real time results pages, '.pdf' files, 'ISL' results, 'Omega' results, and (on a development basis) '.hy3' files.  Once read in, 'SwimmeR' can convert swimming times (performances) between the computationally useful format of seconds reported to the '100ths' place (e.g. 95.37), and the conventional reporting format (1:35.37) used in the swimming community.  'SwimmeR' can also score meets in a variety of formats with user defined point values, convert times between courses ('LCM', 'SCM', 'SCY') and draw single elimination brackets, as well as providing a suite of tools for working cleaning swimming data.  This is a developmental package, not yet mature.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Imports:</td>
<td>purrr, dplyr, stringr, utils, rvest, pdftools, magrittr, xml2,
readr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0), knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-24 01:03:47 UTC; Greg</td>
</tr>
<tr>
<td>Author:</td>
<td>Greg Pilgrim <a href="https://orcid.org/0000-0001-7831-442X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Caitlin Baldwin [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Greg Pilgrim &lt;gpilgrim2670@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-24 13:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='+25notin+25'>&quot;Not in&quot; function</h2><span id='topic++25notin+25'></span><span id='topic++25+21in+25'></span>

<h3>Description</h3>

<p>The opposite of '
'FALSE' otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %notin% y

x %!in% y
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25notin+2B25_+3A_x">x</code></td>
<td>
<p>a value</p>
</td></tr>
<tr><td><code id="+2B25notin+2B25_+3A_y">y</code></td>
<td>
<p>a list of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 'TRUE' or 'FALSE'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>"a" %!in% c("a", "b", "c")
"a" %notin% c("b", "c")

</code></pre>

<hr>
<h2 id='add_event_dummy_row'>Add dummy entry rows</h2><span id='topic+add_event_dummy_row'></span>

<h3>Description</h3>

<p>If a team does not have a full compliment, defined by <code>max_entries</code>, of
athletes in a given event then dummy rows containing blank entries need to be
added to that event
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_event_dummy_row(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_event_dummy_row_+3A_x">x</code></td>
<td>
<p>a list of data frames containing event results that need dummy
entries added</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list of data frames each with a dummy entry row added
</p>

<hr>
<h2 id='add_row_numbers'>Add row numbers to raw results</h2><span id='topic+add_row_numbers'></span>

<h3>Description</h3>

<p>Takes the output of <code>read_results</code> and adds row numbers to it
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_row_numbers(text)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_row_numbers_+3A_text">text</code></td>
<td>
<p>output from <code>read_results</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a data frame with event names and row numbers to eventually
be recombined with swimming results inside <code>swim_parse</code>
</p>


<h3>See Also</h3>

<p><code>add_row_numbers</code> is a helper function inside
<code><a href="#topic+swim_parse">swim_parse</a></code>
</p>

<hr>
<h2 id='age_format'>Formatting yyy-mm ages as years</h2><span id='topic+age_format'></span>

<h3>Description</h3>

<p>Takes a character string (or list) representing an age as years-months (e.g.
13-06 for 13 years, 6 months) and converts it to a character value (13.5) or
a list of values representing ages in years.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>age_format(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="age_format_+3A_x">x</code></td>
<td>
<p>A character vector of ages in yyy-mm format (e.g. 93-03) to be
converted to years (93.25)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the value of the string <code>x</code> which represents an age in
yyy-mm format (93-03) and converts it to years (93.25)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+age_format_helper">age_format_helper</a></code> <code>age_format</code> uses
<code>age_format_helper</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>age_format("13-06")
age_format(c("13-06", "25-03", NA))

</code></pre>

<hr>
<h2 id='age_format_helper'>Helper function for formatting yyy-mm ages as years, enables vectorization of
<code>age_format</code></h2><span id='topic+age_format_helper'></span>

<h3>Description</h3>

<p>Helper function for formatting yyy-mm ages as years, enables vectorization of
<code>age_format</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>age_format_helper(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="age_format_helper_+3A_x">x</code></td>
<td>
<p>A character vector of age(s) in yyyy-mm format (e.g. 13-06) to be
converted to years (13.5)</p>
</td></tr>
</table>

<hr>
<h2 id='clean_events'>Regularizes event names</h2><span id='topic+clean_events'></span>

<h3>Description</h3>

<p>XXX
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_events(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clean_events_+3A_x">x</code></td>
<td>
<p>a character vector of event names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector of event names with naming conventions enforced to
regularize event names
</p>

<hr>
<h2 id='coalesce_many'>Combined paired sets of columns following a join operation</h2><span id='topic+coalesce_many'></span>

<h3>Description</h3>

<p>Combined paired sets of columns following a join operation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coalesce_many(df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coalesce_many_+3A_df">df</code></td>
<td>
<p>a data frame following a join and thereby containing paired columns
of the form Col_1.x, Col_1.y</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a data frame with all sets of paired columns combined into
single columns and named as, for example, Col_1, Col_2 etc.
</p>


<h3>See Also</h3>

<p><code>coalesce_many</code> runs inside
<code><a href="#topic+swim_parse_splash">swim_parse_splash</a></code>
</p>

<hr>
<h2 id='coalesce_many_helper'>Combined paired sets of columns following a join operation</h2><span id='topic+coalesce_many_helper'></span>

<h3>Description</h3>

<p>This function is intended to be mapped over a sequence <code>i</code> inside the
function <code><a href="#topic+coalesce_many">coalesce_many</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coalesce_many_helper(df, new_split_names, i)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coalesce_many_helper_+3A_df">df</code></td>
<td>
<p>a data frame following a join and thereby containing paired columns
of the form Col_1.x, Col_1.y</p>
</td></tr>
<tr><td><code id="coalesce_many_helper_+3A_new_split_names">new_split_names</code></td>
<td>
<p>a list of desired column names, e.g. Col_1, Col_2</p>
</td></tr>
<tr><td><code id="coalesce_many_helper_+3A_i">i</code></td>
<td>
<p>a number between 1 and the length of <code>new_split_names</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a data frame with one set of paired columns combined into a
single column and named based on <code>new_split_names</code>
</p>


<h3>See Also</h3>

<p><code>coalesce_many_helper</code> runs inside
<code><a href="#topic+coalesce_many">coalesce_many</a></code>
</p>

<hr>
<h2 id='collect_relay_swimmers'>Collects relay swimmers as a data frame within <code>swim_parse</code></h2><span id='topic+collect_relay_swimmers'></span>

<h3>Description</h3>

<p>Collects relay swimmers as a data frame within <code>swim_parse</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collect_relay_swimmers(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="collect_relay_swimmers_+3A_x">x</code></td>
<td>
<p>output from <code>read_results</code> followed by <code>add_row_numbers</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a data frame of relay swimmers and the associated performance row number
</p>


<h3>See Also</h3>

<p><code>collect_relay_swimmers_data</code> runs inside of <code>swim_parse</code>
</p>

<hr>
<h2 id='collect_relay_swimmers_old'>Collects relay swimmers as a data frame within <code>swim_parse_old</code></h2><span id='topic+collect_relay_swimmers_old'></span>

<h3>Description</h3>

<p>Depreciated version associated with depreciated version of <code>swim_parse_old</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collect_relay_swimmers_old(x, typo_2 = typo, replacement_2 = replacement)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="collect_relay_swimmers_old_+3A_x">x</code></td>
<td>
<p>output from <code>read_results</code> followed by <code>add_row_numbers</code></p>
</td></tr>
<tr><td><code id="collect_relay_swimmers_old_+3A_typo_2">typo_2</code></td>
<td>
<p>list of typos from <code>swim_parse</code></p>
</td></tr>
<tr><td><code id="collect_relay_swimmers_old_+3A_replacement_2">replacement_2</code></td>
<td>
<p>list of replacements for typos from <code>swim_parse</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a data frame of relay swimmers and the associated performance row number
</p>


<h3>See Also</h3>

<p><code>collect_relay_swimmers</code> runs inside of <code>swim_parse</code>
</p>

<hr>
<h2 id='collect_relay_swimmers_omega'>Collects relay swimmers as a data frame within <code>swim_parse_omega</code></h2><span id='topic+collect_relay_swimmers_omega'></span>

<h3>Description</h3>

<p>Collects relay swimmers as a data frame within <code>swim_parse_omega</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collect_relay_swimmers_omega(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="collect_relay_swimmers_omega_+3A_x">x</code></td>
<td>
<p>output from <code>read_results</code> followed by <code>add_row_numbers</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a data frame of relay swimmers and the associated performance
row number
</p>


<h3>See Also</h3>

<p><code>collect_relay_swimmers_data</code> runs inside of
<code>swim_parse_omega</code>
</p>

<hr>
<h2 id='collect_relay_swimmers_splash'>Collects relay swimmers as a data frame within <code>swim_parse_splash</code></h2><span id='topic+collect_relay_swimmers_splash'></span>

<h3>Description</h3>

<p>Collects relay swimmers as a data frame within <code>swim_parse_splash</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collect_relay_swimmers_splash(x, relay_indent = Indent_Length)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="collect_relay_swimmers_splash_+3A_x">x</code></td>
<td>
<p>output from <code>read_results</code> followed by <code>add_row_numbers</code></p>
</td></tr>
<tr><td><code id="collect_relay_swimmers_splash_+3A_relay_indent">relay_indent</code></td>
<td>
<p>the number of spaces relay swimmer lines are indented
compared to regular swimmer lines</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a data frame of relay swimmers and the associated performance
row number
</p>


<h3>See Also</h3>

<p><code>collect_relay_swimmers_data</code> runs inside of
<code>swim_parse_splash</code>
</p>

<hr>
<h2 id='correct_split_distance'>Changes lengths associated with splits to new values</h2><span id='topic+correct_split_distance'></span><span id='topic+correct_split_length'></span>

<h3>Description</h3>

<p>Useful for dealing with meets where some events are split by 50 and others by
25.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correct_split_distance(df, new_split_length, events)

correct_split_length(df, new_split_length, events)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="correct_split_distance_+3A_df">df</code></td>
<td>
<p>a data frame having some split columns (Split_50, Split_100 etc.)</p>
</td></tr>
<tr><td><code id="correct_split_distance_+3A_new_split_length">new_split_length</code></td>
<td>
<p>split length to rename split columns based on</p>
</td></tr>
<tr><td><code id="correct_split_distance_+3A_events">events</code></td>
<td>
<p>list of events to correct splits for</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame where all events named in the <code>events</code> parameter
have their split column labels adjusted to reflect <code>new_split_length</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(Name = c("Lilly King", "Caeleb Dressel"),
Event = c("Women 100 Meter Breaststroke", "Men 50 Yard Freestyle"),
Split_50 = c("29.80", "8.48"),
Split_100 = c("34.33", "9.15"))

df %&gt;% correct_split_distance(
 new_split_length = 25,
 events = c("Men 50 Yard Freestyle")
)

</code></pre>

<hr>
<h2 id='correct_split_distance_helper'>Changes lengths associated with splits to new values</h2><span id='topic+correct_split_distance_helper'></span>

<h3>Description</h3>

<p>Useful for dealing with meets where some events are split by 50 and others by
25.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correct_split_distance_helper(df_helper, new_split_length_helper)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="correct_split_distance_helper_+3A_df_helper">df_helper</code></td>
<td>
<p>a data frame having some split columns (Split_50, Split_100
etc.)</p>
</td></tr>
<tr><td><code id="correct_split_distance_helper_+3A_new_split_length_helper">new_split_length_helper</code></td>
<td>
<p>split length to rename split columns based on</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame where all values have been pushed left, replacing 'NA's,
and all columns containing only 'NA's have been removed
</p>


<h3>See Also</h3>

<p><code>correct_split_distance_helper</code> is a helper function inside
<code>correct_split_distance</code>
</p>

<hr>
<h2 id='course_convert'>Swimming Course Converter</h2><span id='topic+course_convert'></span>

<h3>Description</h3>

<p>Used to convert times between Long Course Meters, Short Course Meters and
Short Course Yards
</p>


<h3>Usage</h3>

<pre><code class='language-R'>course_convert(time, event, course, course_to, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="course_convert_+3A_time">time</code></td>
<td>
<p>A time, or vector of times to convert.  Can be in either seconds
(numeric, <code>95.97</code>) format or swim (character, <code>"1:35.97"</code>) format</p>
</td></tr>
<tr><td><code id="course_convert_+3A_event">event</code></td>
<td>
<p>The event swum as <code>"100 Fly"</code>, <code>"200 IM"</code>, <code>"400
Free"</code>, <code>"50 Back"</code>, <code>"200 Breast"</code> etc.</p>
</td></tr>
<tr><td><code id="course_convert_+3A_course">course</code></td>
<td>
<p>The course in which the time was swum as <code>"LCM"</code>,
<code>"SCM"</code> or <code>"SCY"</code></p>
</td></tr>
<tr><td><code id="course_convert_+3A_course_to">course_to</code></td>
<td>
<p>The course to convert the time to as <code>"LCM"</code>,
<code>"SCM"</code> or <code>"SCY"</code></p>
</td></tr>
<tr><td><code id="course_convert_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> will return a data frame containing columns </p>
 <ul>
<li>
<p>Time </p>
</li>
<li><p> Course </p>
</li>
<li><p> Course_To </p>
</li>
<li><p> Event </p>
</li>
<li><p> Time_Converted_sec
</p>
</li>
<li><p> Time_Converted_mmss </p>
</li></ul>
<p>.  If <code>FALSE</code> (the default) will return only a converted time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the <code>time</code> for a specified <code>event</code> and
<code>course</code> converted to a time for the specified <code>course_to</code> in
swimming format OR a data frame containing columns </p>
 <ul>
<li>
<p>Time </p>
</li>
<li><p> Course </p>
</li>
<li><p> Course_To </p>
</li>
<li><p> Event </p>
</li>
<li><p> Time_Converted_sec
</p>
</li>
<li><p> Time_Converted_mmss </p>
</li></ul>
<p> depending on the value of <code>verbose</code>
</p>


<h3>Note</h3>

<p>Relays are not presently supported.
</p>


<h3>References</h3>

<p>Uses the USA swimming age group method described here:
<a href="https://support.gomotionapp.com/en/articles/6457476-how-to-perform-course-conversion-factoring-of-times">https://support.gomotionapp.com/en/articles/6457476-how-to-perform-course-conversion-factoring-of-times</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>course_convert(time = "1:35.93", event = "200 Free", course = "SCY", course_to = "LCM")
course_convert(time = 95.93, event = "200 Free", course = "scy", course_to = "lcm")
course_convert(time = 53.89, event = "100 Fly", course = "scm", course_to = "scy")

</code></pre>

<hr>
<h2 id='course_convert_DF'>Course converter, returns data frame - defunct</h2><span id='topic+course_convert_DF'></span><span id='topic+course_convert_df'></span>

<h3>Description</h3>

<p>Used to convert times between Long Course Meters, Short Course Meters and
Short Course Yards, returns data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>course_convert_DF(time, event, course, course_to)

course_convert_df(time, event, course, course_to)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="course_convert_DF_+3A_time">time</code></td>
<td>
<p>A time, or vector of times to convert.  Can be in either seconds
(numeric, <code>95.97</code>) format or swim (character, <code>"1:35.97"</code>) format</p>
</td></tr>
<tr><td><code id="course_convert_DF_+3A_event">event</code></td>
<td>
<p>The event swum as <code>"100 Fly"</code>, <code>"200 IM"</code>, <code>"400
Free"</code>, <code>"50 Back"</code>, <code>"200 Breast"</code> etc.</p>
</td></tr>
<tr><td><code id="course_convert_DF_+3A_course">course</code></td>
<td>
<p>The course in which the time was swum as <code>"LCM"</code>,
<code>"SCM"</code> or <code>"SCY"</code></p>
</td></tr>
<tr><td><code id="course_convert_DF_+3A_course_to">course_to</code></td>
<td>
<p>The course to convert the time to as <code>"LCM"</code>,
<code>"SCM"</code> or <code>"SCY"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a data frame including columns: </p>
 <ul>
<li>
<p>Time </p>
</li>
<li><p> Course </p>
</li>
<li><p> Course_To </p>
</li>
<li><p> Event </p>
</li>
<li><p> Time_Converted_sec
</p>
</li>
<li><p> Time_Converted_mmss </p>
</li></ul>



<h3>Note</h3>

<p>Relays are not presently supported.
</p>


<h3>References</h3>

<p>Uses the USA swimming age group method described here
<a href="https://support.gomotionapp.com/en/articles/6457476-how-to-perform-course-conversion-factoring-of-times">https://support.gomotionapp.com/en/articles/6457476-how-to-perform-course-conversion-factoring-of-times</a>
</p>

<hr>
<h2 id='course_convert_helper'>Swimming Course Convertor Helper</h2><span id='topic+course_convert_helper'></span>

<h3>Description</h3>

<p>Used to convert times between Long Course Meters, Short Course Meters and
Short Course Yards
</p>


<h3>Usage</h3>

<pre><code class='language-R'>course_convert_helper(time, event, course, course_to, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="course_convert_helper_+3A_time">time</code></td>
<td>
<p>A time, or vector of times to convert.  Can be in either seconds
(numeric, <code>95.97</code>) format or swim (character, <code>"1:35.97"</code>) format</p>
</td></tr>
<tr><td><code id="course_convert_helper_+3A_event">event</code></td>
<td>
<p>The event swum as <code>"100 Fly"</code>, <code>"200 IM"</code>, <code>"400
Free"</code>, <code>"50 Back"</code>, <code>"200 Breast"</code> etc.</p>
</td></tr>
<tr><td><code id="course_convert_helper_+3A_course">course</code></td>
<td>
<p>The course in which the time was swum as <code>"LCM"</code>,
<code>"SCM"</code> or <code>"SCY"</code></p>
</td></tr>
<tr><td><code id="course_convert_helper_+3A_course_to">course_to</code></td>
<td>
<p>The course to convert the time to as <code>"LCM"</code>,
<code>"SCM"</code> or <code>"SCY"</code></p>
</td></tr>
<tr><td><code id="course_convert_helper_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> will return a data frame containing columns </p>
 <ul>
<li>
<p>Time </p>
</li>
<li><p> Course </p>
</li>
<li><p> Course_To </p>
</li>
<li><p> Event </p>
</li>
<li><p> Time_Converted_sec
</p>
</li>
<li><p> Time_Converted_mmss </p>
</li></ul>
<p>.  If <code>FALSE</code> (the default) will return only a converted time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the <code>time</code> for a specified <code>event</code> and
<code>course</code> converted to a time for the specified <code>course_to</code> in
swimming format OR a data frame containing columns </p>
 <ul>
<li>
<p>Time </p>
</li>
<li><p> Course </p>
</li>
<li><p> Course_To </p>
</li>
<li><p> Event </p>
</li>
<li><p> Time_Converted_sec
</p>
</li>
<li><p> Time_Converted_mmss </p>
</li></ul>
<p> depending on the value of <code>verbose</code>
</p>


<h3>See Also</h3>

<p><code>course_convert_helper</code> is a helper function inside <code><a href="#topic+course_convert">course_convert</a></code>
</p>

<hr>
<h2 id='discard_errors'>Discards elements of list that have an error value from <code>purrr::safely</code>.</h2><span id='topic+discard_errors'></span>

<h3>Description</h3>

<p>Used in scrapping, when <code>swim_parse</code> is applied over a list of results
using <code>purrr::map</code> the result is a list of two element lists. The first
element is the results, the second element is an error register.  This
function removes all elements where the error register is not NULL, and then
returns the results (first element) of the remaining lists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discard_errors(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="discard_errors_+3A_x">x</code></td>
<td>
<p>a list of lists from <code>purrr::map</code> and <code>purrr:safely</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of lists where sub lists containing a non-NULL error have been
discarded and error elements have been removed from all remaining sub lists
</p>


<h3>Examples</h3>

<pre><code class='language-R'>result_1 &lt;- data.frame(result = c(1, 2, 3))
error &lt;- NULL

list_1 &lt;- list(result_1, error)
names(list_1) &lt;- c("result", "error")

result_2 &lt;- data.frame(result = c(4, 5, 6))
error &lt;- "result is corrupt"

list_2 &lt;- list(result_2, error)
names(list_2) &lt;- c("result", "error")

list_of_lists &lt;- list(list_1, list_2)
discard_errors(list_of_lists)

</code></pre>

<hr>
<h2 id='dive_place'>Adds places to diving results</h2><span id='topic+dive_place'></span>

<h3>Description</h3>

<p>Places are awarded on the basis of score, with highest score winning.  Ties
are placed as ties (both athletes get 2nd etc.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dive_place(
  df,
  score_col = Finals,
  max_place = NULL,
  keep_nonscoring = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dive_place_+3A_df">df</code></td>
<td>
<p>a data frame with results from <code>swim_parse</code>, including only
diving results (not swimming)</p>
</td></tr>
<tr><td><code id="dive_place_+3A_score_col">score_col</code></td>
<td>
<p>the name of a column in <code>df</code> containing scores on which
to place (order) performances</p>
</td></tr>
<tr><td><code id="dive_place_+3A_max_place">max_place</code></td>
<td>
<p>highest place value that scores #' @param score_col the name
of a column in <code>df</code> containing scores on which to place (order)
performances</p>
</td></tr>
<tr><td><code id="dive_place_+3A_keep_nonscoring">keep_nonscoring</code></td>
<td>
<p>are athletes in places greater than <code>max_place</code>
be retained in the data frame.  Either <code>TRUE</code> or <code>FALSE</code></p>
</td></tr>
<tr><td><code id="dive_place_+3A_verbose">verbose</code></td>
<td>
<p>should warning messages be posted.  Default is <code>TRUE</code> and
should rarely be changed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame modified so that places have been appended based on diving
score
</p>


<h3>See Also</h3>

<p><code>dive_place</code> is a helper function used inside of
<code>results_score</code>
</p>

<hr>
<h2 id='draw_bracket'>Creates a bracket for tournaments involving 5 to 64 teams, single elimination</h2><span id='topic+draw_bracket'></span>

<h3>Description</h3>

<p>Will draw a single elimination bracket for the appropriate number of teams,
inserting first round byes for higher seeds as needed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_bracket(
  teams,
  title = "Championship Bracket",
  text_size = 0.7,
  round_two = NULL,
  round_three = NULL,
  round_four = NULL,
  round_five = NULL,
  round_six = NULL,
  champion = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="draw_bracket_+3A_teams">teams</code></td>
<td>
<p>a list of teams, ordered by desired seed, to place in bracket.
Must be between 5 and 64 inclusive.  Teams must have unique names</p>
</td></tr>
<tr><td><code id="draw_bracket_+3A_title">title</code></td>
<td>
<p>bracket title</p>
</td></tr>
<tr><td><code id="draw_bracket_+3A_text_size">text_size</code></td>
<td>
<p>number passed to <code>cex</code> in plotting</p>
</td></tr>
<tr><td><code id="draw_bracket_+3A_round_two">round_two</code></td>
<td>
<p>a list of teams advancing to the second round (need not be in
order)</p>
</td></tr>
<tr><td><code id="draw_bracket_+3A_round_three">round_three</code></td>
<td>
<p>a list of teams advancing to the third round (need not be
in order)</p>
</td></tr>
<tr><td><code id="draw_bracket_+3A_round_four">round_four</code></td>
<td>
<p>a list of teams advancing to the forth round (need not be in
order)</p>
</td></tr>
<tr><td><code id="draw_bracket_+3A_round_five">round_five</code></td>
<td>
<p>a list of teams advancing to the fifth round (need not be in
order)</p>
</td></tr>
<tr><td><code id="draw_bracket_+3A_round_six">round_six</code></td>
<td>
<p>a list of teams advancing to the fifth round (need not be in
order)</p>
</td></tr>
<tr><td><code id="draw_bracket_+3A_champion">champion</code></td>
<td>
<p>the name of the overall champion team (there can be only one)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot of a bracket for the teams, with results and titles as
specified
</p>


<h3>References</h3>

<p>based on <code>draw.bracket</code> from the seemingly now defunct
<code>mRchmadness</code> package by Eli Shayer and Saber Powers and used per the
terms of that package's GPL-2 license
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
teams &lt;- c("red", "orange", "yellow", "green", "blue", "indigo", "violet")
round_two &lt;- c("red", "yellow", "blue", "indigo")
round_three &lt;- c("red", "blue")
champion &lt;- "red"
draw_bracket(teams = teams,
             round_two = round_two,
             round_three = round_three,
             champion = champion)

## End(Not run)

</code></pre>

<hr>
<h2 id='event_parse'>Pulls out event labels from text</h2><span id='topic+event_parse'></span>

<h3>Description</h3>

<p>Locates event labels in text of results output from <code>read_results</code> and
their associated row numbers.  The resulting data frame is joined back into
results to include event names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>event_parse(text)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="event_parse_+3A_text">text</code></td>
<td>
<p>output from <code>read_results</code> followed by
<code>add_row_numbers</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a data frame with event names and row numbers to eventually
be recombined with swimming results inside <code>swim_parse</code>
</p>


<h3>See Also</h3>

<p><code>event_parse</code> is a helper function inside
<code><a href="#topic+swim_parse">swim_parse</a></code>
</p>

<hr>
<h2 id='event_parse_ISL'>Pulls out event labels from text</h2><span id='topic+event_parse_ISL'></span>

<h3>Description</h3>

<p>Locates event labels in text of 'ISL' results output from <code>read_results</code>
and their associated row numbers.  The resulting data frame is joined back
into results to include event names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>event_parse_ISL(text)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="event_parse_ISL_+3A_text">text</code></td>
<td>
<p>output from <code>read_results</code> followed by
<code>add_row_numbers</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a data frame with event names and row numbers to eventually
be recombined with swimming results inside <code>swim_parse_ISL</code>
</p>


<h3>See Also</h3>

<p><code>event_parse_ISL</code> is a helper function inside
<code><a href="#topic+swim_parse_ISL">swim_parse_ISL</a></code>
</p>

<hr>
<h2 id='fill_down'>Fills NA values with previous non-NA value</h2><span id='topic+fill_down'></span>

<h3>Description</h3>

<p>This is a base approximation of <code>tidyr::fill()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill_down(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fill_down_+3A_x">x</code></td>
<td>
<p>a list having some number of non-NA values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list where NA values have been replaced with the closest previous
non-NA value
</p>


<h3>See Also</h3>

<p><code>fill_down</code> is a helper function inside <code>lines_sort</code>
</p>

<hr>
<h2 id='fill_left'>Shifts non-NA values to left in data frame</h2><span id='topic+fill_left'></span>

<h3>Description</h3>

<p>Moves non-NA data left into NA spaces, then removes all columns that contain
only NA values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill_left(df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fill_left_+3A_df">df</code></td>
<td>
<p>a data frame having some 'NA' values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame where all values have been pushed left, replacing 'NA's,
and all columns containing only 'NA's have been removed
</p>


<h3>See Also</h3>

<p><code>fill_left</code> is a helper function inside <code>lines_sort</code> and
<code>splits_parse</code>
</p>

<hr>
<h2 id='fold'>Fold a vector onto itself</h2><span id='topic+fold'></span>

<h3>Description</h3>

<p>Fold a vector onto itself
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fold(x, block.size = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fold_+3A_x">x</code></td>
<td>
<p>a vector</p>
</td></tr>
<tr><td><code id="fold_+3A_block.size">block.size</code></td>
<td>
<p>the size of groups in which to block the data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a new vector in the following order: first block, last block, second
block, second-to-last block, ...
</p>


<h3>References</h3>

<p>from the seemingly now defunct <code>mRchmadness</code> package by Eli
Shayer and Saber Powers and used per the terms of that package's GPL-2
license
</p>

<hr>
<h2 id='format_results'>Formats data for analysis within <code>swim_parse</code></h2><span id='topic+format_results'></span>

<h3>Description</h3>

<p>Takes the output of <code>read_results</code> and, inside of <code>swim_parse</code>,
removes &quot;special&quot; strings like DQ and SCR from results, replacing them with
NA.  Also ensures that all athletes have a Finals, by moving over
Prelims.  This makes later analysis much easier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_results(df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="format_results_+3A_df">df</code></td>
<td>
<p>a data frame of results at the end of <code>swim_parse</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a formatted data frame
</p>


<h3>See Also</h3>

<p><code>splits_parse</code> runs inside <code><a href="#topic+swim_parse">swim_parse</a></code> on the
output of <code><a href="#topic+read_results">read_results</a></code> with row numbers from
<code><a href="#topic+add_row_numbers">add_row_numbers</a></code>
</p>

<hr>
<h2 id='generate_row_to_add'>Create a one-line data frame containing an entry to be appended to an
in-progress data frame of all entries</h2><span id='topic+generate_row_to_add'></span>

<h3>Description</h3>

<p>Create a one-line data frame containing an entry to be appended to an
in-progress data frame of all entries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_row_to_add(df_helper_2, e_rank_helper_2, k, e_helper)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_row_to_add_+3A_df_helper_2">df_helper_2</code></td>
<td>
<p>a  master data frame of athlete ranks by event</p>
</td></tr>
<tr><td><code id="generate_row_to_add_+3A_e_rank_helper_2">e_rank_helper_2</code></td>
<td>
<p>a data frame of candidate athlete entries to add to a
given event</p>
</td></tr>
<tr><td><code id="generate_row_to_add_+3A_k">k</code></td>
<td>
<p>an integer denoting which element of e_rank_helper is under
evaluation for addition.  Should be 1, 2, 3 or 4 depending on the minimum
number of entries</p>
</td></tr>
<tr><td><code id="generate_row_to_add_+3A_e_helper">e_helper</code></td>
<td>
<p>the event for which entries are being evaluated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a one row data frame containing an improved entry
</p>

<hr>
<h2 id='get_mode'>Find the mode (most commonly occurring) element of a list</h2><span id='topic+get_mode'></span>

<h3>Description</h3>

<p>Determines which element of list appears most frequently.  Based on
<code>base::which.max()</code>, so if multiple values appear with the same
frequency will return the first one.  Ignores <code>NA</code> values. In the
context of swimming data is often used to clean team names, as in the Lilly
King example below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_mode(x, type = "first")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_mode_+3A_x">x</code></td>
<td>
<p>A list.  <code>NA</code> elements will be ignored.</p>
</td></tr>
<tr><td><code id="get_mode_+3A_type">type</code></td>
<td>
<p>a character string of either <code>"first"</code> or <code>"all"</code> which
determines behavior for ties.  Setting <code>type = "first"</code> (the default)
will return the element that appears most often and appears first in list
<code>x</code>.  Setting <code>type = "all"</code> will return all elements that appear
most frequently.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the element of <code>x</code> which appears most frequently.  Ties go to
the lowest index, so the element which appears first.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- c("a", "a", "b", "c")
get_mode(a)
ab &lt;- c("a", "a", "b", "b", "c") # returns "a", not "b"
get_mode(ab)
#' ab &lt;- c("a", "a", "b", "b", "c") # returns "a" and "b"
get_mode(ab, type = "all")
a_na &lt;- c("a", "a", NA, NA, "c")
get_mode(a_na)
numbs &lt;- c(1, 1, 1, 2, 2, 2, 3, NA)
get_mode(numbs, type = "all")

Name &lt;- c(rep("Lilly King", 5))
Team &lt;- c(rep("IU", 2), "Indiana", "IUWSD", "Indiana University")
df &lt;- data.frame(Name, Team, stringsAsFactors = FALSE)
df$Team &lt;- get_mode(df$Team)

</code></pre>

<hr>
<h2 id='heat_parse_omega'>Pulls out heat labels from text</h2><span id='topic+heat_parse_omega'></span>

<h3>Description</h3>

<p>Locates heat labels in text of results output from <code>read_results</code> and
their associated row numbers.  The resulting data frame is joined back into
results to include heat numbers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heat_parse_omega(text)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="heat_parse_omega_+3A_text">text</code></td>
<td>
<p>output from <code>read_results</code> followed by
<code>add_row_numbers</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a data frame with heat names and row numbers to eventually
be recombined with swimming results inside <code>swim_parse_omega</code>
</p>


<h3>See Also</h3>

<p><code>heat_parse_omega</code> is a helper function inside
<code><a href="#topic+swim_parse_omega">swim_parse_omega</a></code>
</p>

<hr>
<h2 id='hy3_parse'>Parses Hy-Tek .hy3 files</h2><span id='topic+hy3_parse'></span>

<h3>Description</h3>

<p>Helper function used inside 'swim_parse' for dealing with Hy-Tek .hy3 files.
Can have more columns than other 'swim_parse' outputs, because .hy3 files can
contain more data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hy3_parse(
  file,
  avoid = avoid_minimal,
  typo = typo_default,
  replacement = replacement_default
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hy3_parse_+3A_file">file</code></td>
<td>
<p>output from <code>read_results</code></p>
</td></tr>
<tr><td><code id="hy3_parse_+3A_avoid">avoid</code></td>
<td>
<p>a list of strings.  Rows in <code>x</code> containing these strings
will not be included. For example &quot;Pool:&quot;, often used to label pool
records, could be passed to <code>avoid</code>.  The default is
<code>avoid_default</code>, which contains many strings similar to &quot;Pool:&quot;, such
as &quot;STATE:&quot; and &quot;Qual:&quot;.  Users can supply their own lists to <code>avoid</code>.</p>
</td></tr>
<tr><td><code id="hy3_parse_+3A_typo">typo</code></td>
<td>
<p>a list of strings that are typos in the original results.
<code>swim_parse</code> is particularly sensitive to accidental double spaces, so
&quot;Central  High School&quot;, with two spaces between &quot;Central&quot; and &quot;High&quot; is a
problem, which can be fixed.  Pass &quot;Central High School&quot; to <code>typo</code>.
Unexpected commas as also an issue, for example &quot;Texas, University of&quot;
should be fixed using <code>typo</code> and <code>replacement</code></p>
</td></tr>
<tr><td><code id="hy3_parse_+3A_replacement">replacement</code></td>
<td>
<p>a list of fixes for the strings in <code>typo</code>.  Here one
could pass &quot;Central High School&quot; (one space between &quot;Central&quot; and &quot;High&quot;)
and &quot;Texas&quot; to <code>replacement</code> fix the issues described in <code>typo</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a data frame with columns <code>Name</code>, <code>Place</code>,
<code>Age</code>, <code>Team</code>, <code>Prelims</code>, <code>Finals</code>, &amp;
<code>Event</code>.  May also contain <code>Seed_Time</code>, <code>USA_ID</code>, and/or
<code>Birthdate</code>.  Note all swims will have a <code>Finals</code>, even if
that time was actually swam in the prelims (i.e. a swimmer did not qualify
for finals).  This is so that final results for an event can be generated
from just one column.
</p>


<h3>See Also</h3>

<p><code>parse_hy3</code> must be run on the output of
<code><a href="#topic+read_results">read_results</a></code>
</p>
<p><code>parse_hy3</code> runs inside of <code><a href="#topic+swim_parse">swim_parse</a></code>
</p>

<hr>
<h2 id='hy3_places'>Helper for reading prelims and finals places from Hy-Tek .hy3 files</h2><span id='topic+hy3_places'></span>

<h3>Description</h3>

<p>Used to pull prelims and finals places from .hy3 files as part of parsing them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hy3_places(
  file,
  type = c("prelims", "relay_prelims", "finals", "relay_finals")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hy3_places_+3A_file">file</code></td>
<td>
<p>an output of read_results, from an .hy3 file</p>
</td></tr>
<tr><td><code id="hy3_places_+3A_type">type</code></td>
<td>
<p>type of times, either &quot;prelims&quot;, &quot;relay_prelims&quot;, &quot;finals&quot; or &quot;relay_finals&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame where column 1 is times and column 2 is row number
</p>


<h3>See Also</h3>

<p><code>hy3_places</code> is run inside of <code><a href="#topic+hy3_parse">hy3_parse</a></code>
</p>

<hr>
<h2 id='hy3_times'>Helper for reading prelims and finals times from Hy-Tek .hy3 files</h2><span id='topic+hy3_times'></span>

<h3>Description</h3>

<p>Used to pull prelims and finals times from .hy3 files as part of parsing them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hy3_times(file, type = c("prelims", "relay_prelims", "finals", "relay_finals"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hy3_times_+3A_file">file</code></td>
<td>
<p>an output of read_results, from an .hy3 file</p>
</td></tr>
<tr><td><code id="hy3_times_+3A_type">type</code></td>
<td>
<p>type of times, either &quot;prelims&quot;, &quot;relay_prelims&quot;, &quot;finals&quot; or &quot;relay_finals&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame where column 1 is times and column 2 is row number
</p>


<h3>See Also</h3>

<p><code>hy3_times</code> is run inside of <code><a href="#topic+hy3_parse">hy3_parse</a></code>
</p>

<hr>
<h2 id='hytek_clean_strings'>Cleans input strings</h2><span id='topic+hytek_clean_strings'></span>

<h3>Description</h3>

<p>Cleans input from <code>read_results</code> is passed to <code>hytek_swim_parse</code>
to remove unnneded characters and otherwise set it up for sorting.  Input is
in the form of character strings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hytek_clean_strings(x, time_score_string = Time_Score_String)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hytek_clean_strings_+3A_x">x</code></td>
<td>
<p>a list of character strings</p>
</td></tr>
<tr><td><code id="hytek_clean_strings_+3A_time_score_string">time_score_string</code></td>
<td>
<p>a regex string for matching results (times and
scores) but not special strings like DQ</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list of character strings that have been cleaned in
preparation for parsing/sorting
</p>
<p>#' @seealso <code>hytek_clean_strings</code> runs inside of
<code>hytek_parse_splash</code>
</p>

<hr>
<h2 id='hytek_length_3_DQ_sort'>Sort data in DQ lists of length 3 within <code>hytek_swim_parse</code></h2><span id='topic+hytek_length_3_DQ_sort'></span>

<h3>Description</h3>

<p>Sort data in DQ lists of length 3 within <code>hytek_swim_parse</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hytek_length_3_DQ_sort(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hytek_length_3_DQ_sort_+3A_x">x</code></td>
<td>
<p>a list of lists containing DQ results with all sub-lists having
length 3 strings</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a formatted data frame to be combined with others to make the
output of <code>hytek_swim_parse</code>
</p>

<hr>
<h2 id='hytek_length_3_sort'>Sort data in lists of length 3 within <code>hytek_swim_parse</code></h2><span id='topic+hytek_length_3_sort'></span>

<h3>Description</h3>

<p>Sort data in lists of length 3 within <code>hytek_swim_parse</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hytek_length_3_sort(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hytek_length_3_sort_+3A_x">x</code></td>
<td>
<p>a list of lists with all sub-lists having length 3
strings</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a formatted data frame to be combined with others to make the
output of <code>hytek_swim_parse</code>
</p>

<hr>
<h2 id='hytek_length_4_DQ_sort'>Sort data in DQ lists of length 4 within <code>hytek_swim_parse</code></h2><span id='topic+hytek_length_4_DQ_sort'></span>

<h3>Description</h3>

<p>Sort data in DQ lists of length 4 within <code>hytek_swim_parse</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hytek_length_4_DQ_sort(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hytek_length_4_DQ_sort_+3A_x">x</code></td>
<td>
<p>a list of lists containing DQ results with all sub-lists having
length 4 strings</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a formatted data frame to be combined with others to make the
output of <code>hytek_swim_parse</code>
</p>

<hr>
<h2 id='hytek_length_4_sort'>Sort data in lists of length 4 within <code>hytek_swim_parse</code></h2><span id='topic+hytek_length_4_sort'></span>

<h3>Description</h3>

<p>Sort data in lists of length 4 within <code>hytek_swim_parse</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hytek_length_4_sort(x, time_score_specials_string = Time_Score_Specials_String)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hytek_length_4_sort_+3A_x">x</code></td>
<td>
<p>a list of lists with all sub-lists having length 4
strings</p>
</td></tr>
<tr><td><code id="hytek_length_4_sort_+3A_time_score_specials_string">time_score_specials_string</code></td>
<td>
<p>a regex string for matching results - i.e.
times, diving scores and 'specials' like DQ</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a formatted data frame to be combined with others to make the
output of <code>hytek_swim_parse</code>
</p>

<hr>
<h2 id='hytek_length_5_sort'>Sort data in lists of length 5 within <code>hytek_swim_parse</code></h2><span id='topic+hytek_length_5_sort'></span>

<h3>Description</h3>

<p>Sort data in lists of length 5 within <code>hytek_swim_parse</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hytek_length_5_sort(
  x,
  name_string = Name_String,
  age_string = Age_String,
  para_string = Para_String,
  time_score_specials_string = Time_Score_Specials_String
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hytek_length_5_sort_+3A_x">x</code></td>
<td>
<p>a list of lists with all sub-lists having length 5
strings</p>
</td></tr>
<tr><td><code id="hytek_length_5_sort_+3A_name_string">name_string</code></td>
<td>
<p>a regex string for matching athlete names</p>
</td></tr>
<tr><td><code id="hytek_length_5_sort_+3A_age_string">age_string</code></td>
<td>
<p>a regex string for matching athlete ages</p>
</td></tr>
<tr><td><code id="hytek_length_5_sort_+3A_para_string">para_string</code></td>
<td>
<p>a regex string for matching Paralympics classification
strings</p>
</td></tr>
<tr><td><code id="hytek_length_5_sort_+3A_time_score_specials_string">time_score_specials_string</code></td>
<td>
<p>a regex string for matching results - i.e.
times, diving scores and 'specials' like DQ</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a formatted data frame to be combined with others to make the
output of <code>hytek_swim_parse</code>
</p>

<hr>
<h2 id='hytek_length_6_sort'>Sort data in lists of length 6 within <code>hytek_swim_parse</code></h2><span id='topic+hytek_length_6_sort'></span>

<h3>Description</h3>

<p>Sort data in lists of length 6 within <code>hytek_swim_parse</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hytek_length_6_sort(
  x,
  name_string = Name_String,
  age_string = Age_String,
  para_string = Para_String,
  time_score_specials_string = Time_Score_Specials_String
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hytek_length_6_sort_+3A_x">x</code></td>
<td>
<p>a list of lists with all sub-lists having length 6
strings</p>
</td></tr>
<tr><td><code id="hytek_length_6_sort_+3A_name_string">name_string</code></td>
<td>
<p>a regex string for matching athlete names</p>
</td></tr>
<tr><td><code id="hytek_length_6_sort_+3A_age_string">age_string</code></td>
<td>
<p>a regex string for matching athlete ages</p>
</td></tr>
<tr><td><code id="hytek_length_6_sort_+3A_para_string">para_string</code></td>
<td>
<p>a regex string for matching Paralympics classification
strings</p>
</td></tr>
<tr><td><code id="hytek_length_6_sort_+3A_time_score_specials_string">time_score_specials_string</code></td>
<td>
<p>a regex string for matching results - i.e.
times, diving scores and 'specials' like DQ</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a formatted data frame to be combined with others to make the
output of <code>hytek_swim_parse</code>
</p>

<hr>
<h2 id='hytek_length_7_sort'>Sort data in lists of length 7 within <code>hytek_swim_parse</code></h2><span id='topic+hytek_length_7_sort'></span>

<h3>Description</h3>

<p>Sort data in lists of length 7 within <code>hytek_swim_parse</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hytek_length_7_sort(
  x,
  brit_id_string = Brit_ID_String,
  para_string = Para_String,
  age_string = Age_String,
  time_score_specials_string = Time_Score_Specials_String
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hytek_length_7_sort_+3A_x">x</code></td>
<td>
<p>a list of lists with all sub-lists having length 7</p>
</td></tr>
<tr><td><code id="hytek_length_7_sort_+3A_brit_id_string">brit_id_string</code></td>
<td>
<p>a regex string for matching British swimming IDs</p>
</td></tr>
<tr><td><code id="hytek_length_7_sort_+3A_para_string">para_string</code></td>
<td>
<p>a regex string for matching Paralympics classification
strings</p>
</td></tr>
<tr><td><code id="hytek_length_7_sort_+3A_age_string">age_string</code></td>
<td>
<p>a regex string for matching athlete ages</p>
</td></tr>
<tr><td><code id="hytek_length_7_sort_+3A_time_score_specials_string">time_score_specials_string</code></td>
<td>
<p>a regex string for matching results - i.e.
times, diving scores and 'specials' like DQ</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a formatted data frame to be combined with others to make the
output of <code>hytek_swim_parse</code>
</p>

<hr>
<h2 id='hytek_length_8_sort'>Sort data in lists of length 8 within <code>hytek_swim_parse</code></h2><span id='topic+hytek_length_8_sort'></span>

<h3>Description</h3>

<p>Sort data in lists of length 8 within <code>hytek_swim_parse</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hytek_length_8_sort(
  x,
  brit_id_string = Brit_ID_String,
  para_string = Para_String,
  age_string = Age_String,
  time_score_specials_string = Time_Score_Specials_String
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hytek_length_8_sort_+3A_x">x</code></td>
<td>
<p>a list of lists with all sub-lists having length 8</p>
</td></tr>
<tr><td><code id="hytek_length_8_sort_+3A_brit_id_string">brit_id_string</code></td>
<td>
<p>a regex string for matching British swimming IDs</p>
</td></tr>
<tr><td><code id="hytek_length_8_sort_+3A_para_string">para_string</code></td>
<td>
<p>a regex string for matching Paralympics classification
strings</p>
</td></tr>
<tr><td><code id="hytek_length_8_sort_+3A_age_string">age_string</code></td>
<td>
<p>a regex string for matching athlete ages</p>
</td></tr>
<tr><td><code id="hytek_length_8_sort_+3A_time_score_specials_string">time_score_specials_string</code></td>
<td>
<p>a regex string for matching results - i.e.
times, diving scores and 'specials' like DQ</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a formatted data frame to be combined with others to make the
output of <code>hytek_swim_parse</code>
</p>

<hr>
<h2 id='hytek_length_9_sort'>Sort data in lists of length 9 within <code>hytek_swim_parse</code></h2><span id='topic+hytek_length_9_sort'></span>

<h3>Description</h3>

<p>Sort data in lists of length 9 within <code>hytek_swim_parse</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hytek_length_9_sort(
  x,
  brit_id_string = Brit_ID_String,
  para_string = Para_String,
  age_string = Age_String,
  time_score_specials_string = Time_Score_Specials_String
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hytek_length_9_sort_+3A_x">x</code></td>
<td>
<p>a list of lists with all sub-lists having length 9</p>
</td></tr>
<tr><td><code id="hytek_length_9_sort_+3A_brit_id_string">brit_id_string</code></td>
<td>
<p>a regex string for matching British swimming IDs</p>
</td></tr>
<tr><td><code id="hytek_length_9_sort_+3A_para_string">para_string</code></td>
<td>
<p>a regex string for matching Paralympics classification
strings</p>
</td></tr>
<tr><td><code id="hytek_length_9_sort_+3A_age_string">age_string</code></td>
<td>
<p>a regex string for matching athlete ages</p>
</td></tr>
<tr><td><code id="hytek_length_9_sort_+3A_time_score_specials_string">time_score_specials_string</code></td>
<td>
<p>a regex string for matching results - i.e.
times, diving scores and 'specials' like DQ</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a formatted data frame to be combined with others to make the
output of <code>hytek_swim_parse</code>
</p>

<hr>
<h2 id='interleave_results'>Helper for reading interleaving prelims and finals results</h2><span id='topic+interleave_results'></span>

<h3>Description</h3>

<p>Interleaves times or places based on row number ranges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interleave_results(entries, results, type = c("individual", "relay"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interleave_results_+3A_entries">entries</code></td>
<td>
<p>a data frame containing columns for minimum and maximum row
number (usually 'Row_Min' and 'Row_Max').  Times or places will be
interleaved into this data frame.</p>
</td></tr>
<tr><td><code id="interleave_results_+3A_results">results</code></td>
<td>
<p>a data frame containing times (or places) in column 1 (or
other values to be interleaved) and row numbers in column 2 (usually
'Row_Numb').</p>
</td></tr>
<tr><td><code id="interleave_results_+3A_type">type</code></td>
<td>
<p>either &quot;individual&quot; or &quot;relay&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a modified version of 'entries' with values from 'results'
interleaved on the basis of row number
</p>


<h3>See Also</h3>

<p><code>interleave_results</code> is a helper function used in
<code><a href="#topic+hy3_parse">hy3_parse</a></code>
</p>

<hr>
<h2 id='is_link_broken'>Determines if a link is valid</h2><span id='topic+is_link_broken'></span>

<h3>Description</h3>

<p>Used in testing links to external data, specifically inside of internal
package tests. Attempts to connect to link for the length of duration (in s).
If it fails it returns <code>FALSE</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_link_broken(link_to_test, duration = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_link_broken_+3A_link_to_test">link_to_test</code></td>
<td>
<p>a link</p>
</td></tr>
<tr><td><code id="is_link_broken_+3A_duration">duration</code></td>
<td>
<p>the lowest row number</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the link works, <code>FALSE</code> if it fails
</p>

<hr>
<h2 id='King200Breast'>Results for Lilly King's 200 Breaststrokes</h2><span id='topic+King200Breast'></span>

<h3>Description</h3>

<p>Lilly King's 200 Breaststroke swims from her NCAA career
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(King200Breast)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"data.frame"</code>
</p>


<h3>Source</h3>

<p><a href="https://www.usaswimming.org/times/ncaa/ncaa-division-i">NCAA
Times Database</a>
</p>

<hr>
<h2 id='lines_sort'>Sorts and collects lines by performance and row number</h2><span id='topic+lines_sort'></span>

<h3>Description</h3>

<p>Collects all lines, (for example containing splits or relay swimmers)
associated with a particular performance (a swim) into a data frame with the
appropriate row number for that performance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lines_sort(x, min_row = minimum_row, to_wide = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lines_sort_+3A_x">x</code></td>
<td>
<p>a list of character strings including performances, with tow numbers
added by <code>add_row_numbers</code></p>
</td></tr>
<tr><td><code id="lines_sort_+3A_min_row">min_row</code></td>
<td>
<p>the lowest row number</p>
</td></tr>
<tr><td><code id="lines_sort_+3A_to_wide">to_wide</code></td>
<td>
<p>should the data frame x be converted to wide format?  Default
is <code>TRUE</code> as used in Hytek and Omega results.  Use <code>FALSE</code> in
Splash results</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with <code>Row_Numb</code> as the first column.  Other columns
are performance elements, like splits or relay swimmers, both in order of
occurrence left to right
</p>


<h3>See Also</h3>

<p><code>lines_sort</code> is a helper function inside <code>splits_parse</code>
and <code>swim_parse_ISL</code>
</p>

<hr>
<h2 id='list_breaker'>Breaks out lists of lists by sub-list length</h2><span id='topic+list_breaker'></span>

<h3>Description</h3>

<p>XXXXXX
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_breaker(x, len)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="list_breaker_+3A_x">x</code></td>
<td>
<p>a list of lists, with at least some sub-lists having length
<code>len</code></p>
</td></tr>
<tr><td><code id="list_breaker_+3A_len">len</code></td>
<td>
<p>an numeric value for the length of sub-lists that
<code>list_breaker</code> should break out.  Must be a whole number.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list of lists, with all sub-lists having length <code>len</code>
</p>

<hr>
<h2 id='list_to_list_names'>Initialize a named list of lists</h2><span id='topic+list_to_list_names'></span>

<h3>Description</h3>

<p>Convert a single list to a list of lists, with the names of the lists taken
from the original list, <code>list_of_names</code>.  The new lists will all have a
single value, initialized as <code>value</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_to_list_names(list_of_names, value = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="list_to_list_names_+3A_list_of_names">list_of_names</code></td>
<td>
<p>a list of values, likely strings, to be the names of
sub-lists in a new list of lists</p>
</td></tr>
<tr><td><code id="list_to_list_names_+3A_value">value</code></td>
<td>
<p>a value to initialize elements of all sub-lists to. Defaults to
<code>0</code>.  If <code>value</code> has multiple elements those elements will become
sub-list elements</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list of lists with sub-list names from <code>list_of_names</code>
and first elements from <code>value</code>.  Used inside <code>determine_entries</code>
</p>

<hr>
<h2 id='list_transform'>Transform list of lists into data frame</h2><span id='topic+list_transform'></span>

<h3>Description</h3>

<p>Converts list of lists, with all sub-lists having the same number of elements
into a data frame where each sub-list is a row and each element a column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_transform(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="list_transform_+3A_x">x</code></td>
<td>
<p>a list of lists, with all sub-lists having the same length</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame where each sub-list is a row and each element of that
sub-list is a column
</p>


<h3>See Also</h3>

<p><code>list_transform</code> is a helper function used inside of
<code>swim_parse</code>, <code>swim_parse_ISL</code>, <code>event_parse</code> and
<code>event_parse_ISL</code>
</p>

<hr>
<h2 id='make_lineup'>Determine optimal entries against a given opponent lineup</h2><span id='topic+make_lineup'></span>

<h3>Description</h3>

<p>Determine optimal entries against a given opponent lineup
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_lineup(
  df,
  op_df,
  point_values,
  result_col,
  events = NULL,
  max_entries = NULL,
  max_ind_entries = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_lineup_+3A_df">df</code></td>
<td>
<p>a data frame of times for the team to be entered.  Must contain
column <code>Event</code> with the same event naming convention as <code>op_df</code>,
a column with name matching <code>result_col</code> containing times or diving
scores, and a column called <code>Name</code> containing athlete names</p>
</td></tr>
<tr><td><code id="make_lineup_+3A_op_df">op_df</code></td>
<td>
<p>a data frame containing the opponent lineup.  Must contain
column <code>Event</code> with the same event naming convention as <code>df</code>,
a column with name matching <code>result_col</code> containing times or diving
scores, and a column called <code>Name</code> containing athlete names</p>
</td></tr>
<tr><td><code id="make_lineup_+3A_point_values">point_values</code></td>
<td>
<p>either a recognized string or a list of numeric values
containing the points awarded by place.  Recognized strings are
<code>"hs_four_lane"</code>, <code>"hs_six_lane"</code>, <code>"ncaa_six_lane"</code></p>
</td></tr>
<tr><td><code id="make_lineup_+3A_result_col">result_col</code></td>
<td>
<p>the name of a column, present in both <code>df</code> and
<code>op_df</code> that contains times and/or diving scores</p>
</td></tr>
<tr><td><code id="make_lineup_+3A_events">events</code></td>
<td>
<p>a list of events.  If no list is entered then <code>events</code>
will be taken from <code>unique(op_df$Event)</code></p>
</td></tr>
<tr><td><code id="make_lineup_+3A_max_entries">max_entries</code></td>
<td>
<p>the number of entries a team is permitted per race.
usually half the number of lanes in the competition pool</p>
</td></tr>
<tr><td><code id="make_lineup_+3A_max_ind_entries">max_ind_entries</code></td>
<td>
<p>the number of indivdual events a given athlete may
enter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame of optimal entries based on <code>df</code> and <code>op_df</code>
</p>

<hr>
<h2 id='make_lineup_helper'>Determine optimal entries against a given opponent lineup</h2><span id='topic+make_lineup_helper'></span>

<h3>Description</h3>

<p>Matches athletes into events.  Each event is filled by the least capable
(slowest) swimmer who can win or place in that event. For example if Team A
has six breaststrokers at 57.00, 58.00, 59.00 and three 1:00.00s and Team B
has three breaststrokers, all 1:01.00 then Team A's entries will be the three
1:00.00s because they're sufficient to win.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_lineup_helper(
  i,
  df_helper,
  op_df_helper,
  end_seq,
  max_ind_entries_helper = 2,
  result_col_helper = result_col
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_lineup_helper_+3A_i">i</code></td>
<td>
<p>a sequential list of numbers incremented by 1.  Used to index
function.</p>
</td></tr>
<tr><td><code id="make_lineup_helper_+3A_df_helper">df_helper</code></td>
<td>
<p>a data frame of times for the team to be entered.  Must
contain column <code>Event</code> with the same event naming convention as
<code>op_df</code>, a column with name matching <code>result_col</code> containing times
or diving scores, and a column called <code>Name</code> containing athlete names</p>
</td></tr>
<tr><td><code id="make_lineup_helper_+3A_op_df_helper">op_df_helper</code></td>
<td>
<p>a data frame containing the opponent lineup.  Must
contain column <code>Event</code> with the same event naming convention as
<code>df</code>, a column with name matching <code>result_col</code> containing times or
diving scores, and a column called <code>Name</code> containing athlete names</p>
</td></tr>
<tr><td><code id="make_lineup_helper_+3A_end_seq">end_seq</code></td>
<td>
<p>how many events score</p>
</td></tr>
<tr><td><code id="make_lineup_helper_+3A_max_ind_entries_helper">max_ind_entries_helper</code></td>
<td>
<p>a numeric value denoting the maximum number of
individual events that may be entered by a single athlete</p>
</td></tr>
<tr><td><code id="make_lineup_helper_+3A_result_col_helper">result_col_helper</code></td>
<td>
<p>name of column with results in it</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame containing athletes entered into events
</p>

<hr>
<h2 id='make_lineup_helper_2'>Assign overpowered entries</h2><span id='topic+make_lineup_helper_2'></span>

<h3>Description</h3>

<p>Matches athletes into events again, this time vs. the output of
<code>make_lineup_helper</code>.  For example if Team A has six breaststrokers at
57.00, 58.00, 59.00 and three 1:00.00s and Team B has three breaststrokers,
all 1:01.00 then following <code>make_lineup_helper</code> Team A's entries will be
the three 1:00.00s because they're sufficient to win.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_lineup_helper_2(
  i,
  df_helper,
  in_progress_entries_df,
  events_competed_helper = Events_Competed,
  max_entries_helper = max_entries,
  max_ind_entries_helper = max_ind_entries
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_lineup_helper_2_+3A_i">i</code></td>
<td>
<p>a sequential list of numbers incremented by 1.  Used to index
function.</p>
</td></tr>
<tr><td><code id="make_lineup_helper_2_+3A_df_helper">df_helper</code></td>
<td>
<p>a data frame of all times to be entered for a given team.
Must contain column <code>Event</code> with the same event naming convention as
<code>op_df</code>, a column with name matching <code>result_col</code> containing times
or diving scores, and a column called <code>Name</code> containing athlete names</p>
</td></tr>
<tr><td><code id="make_lineup_helper_2_+3A_in_progress_entries_df">in_progress_entries_df</code></td>
<td>
<p>a data frame containing the output of
<code>make_lineup_helper</code>, which is the minimum power set of entries</p>
</td></tr>
<tr><td><code id="make_lineup_helper_2_+3A_events_competed_helper">events_competed_helper</code></td>
<td>
<p>a list of lists containing all the events a
given athlete is competing in.  Sub-lists are named with the athlete name.</p>
</td></tr>
<tr><td><code id="make_lineup_helper_2_+3A_max_entries_helper">max_entries_helper</code></td>
<td>
<p>a numeric value denoting the maximum number of
athletes a team may enter in a given event</p>
</td></tr>
<tr><td><code id="make_lineup_helper_2_+3A_max_ind_entries_helper">max_ind_entries_helper</code></td>
<td>
<p>a numeric value denoting the maximum number of
individual events that may be entered by a single athlete</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Here though Team A's three 1:00.00s will be replaced by their 57.00, 58.00
and 59.00 breaststrokers.  These entries are &quot;overpowered&quot; but better reflect
an actual set of entries.  Not using <code>make_lineup_helper_2</code> often
results in a team's best athletes not competing
</p>


<h3>Value</h3>

<p>a data frame containing entries updated to be as powerful as possible
</p>

<hr>
<h2 id='mmss_format'>Formatting seconds as mm:ss.hh</h2><span id='topic+mmss_format'></span>

<h3>Description</h3>

<p>Takes a numeric item or list of numeric items representing seconds (e.g.
95.37) and converts to a character string or list of strings in swimming
format (&quot;1:35.37&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mmss_format(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mmss_format_+3A_x">x</code></td>
<td>
<p>A number of seconds to be converted to swimming format</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the number of seconds <code>x</code> converted to conventional swimming
format mm:ss.hh
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sec_format">sec_format</a></code> <code>mmss_format</code> is the reverse of
<code>sec_format</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mmss_format(95.37)
mmss_format(200.95)
mmss_format(59.47)
mmss_format(c(95.37, 200.95, 59.47, NA))

</code></pre>

<hr>
<h2 id='na_pad'>Pads shorter lists in a list-of-lists with <code>NA</code>s such that all lists are
the same length</h2><span id='topic+na_pad'></span>

<h3>Description</h3>

<p>Adds <code>NA</code> values to the end of each list in a list of lists such that
they all become the length of the longest list.  The longest list will not
have any <code>NA</code>s added to it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>na_pad(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="na_pad_+3A_x">x</code></td>
<td>
<p>a list of lists, with sub-lists having different lengths</p>
</td></tr>
<tr><td><code id="na_pad_+3A_y">y</code></td>
<td>
<p>a list of the number of <code>NA</code> values to append to each sub-list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of lists with each sub-list the same length
</p>

<hr>
<h2 id='name_reorder'>Orders all names as &quot;Firstname Lastname&quot;</h2><span id='topic+name_reorder'></span>

<h3>Description</h3>

<p>Names are sometimes listed as Firstname Lastname, and sometimes as Lastname,
Firstname.  The <code>names_reorder</code> function converts all names to Firstname
Lastname based on comma position. The reverse, going to Lastname, Firstname
is not possible because some athletes have multiple first names or multiple
last names and without the comma to differentiate between the two a
distinction cannot be made.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>name_reorder(x, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="name_reorder_+3A_x">x</code></td>
<td>
<p>a data frame output from <code>swim_parse</code> containing a column
called <code>Name</code> with some names as Lastname, Firstname</p>
</td></tr>
<tr><td><code id="name_reorder_+3A_verbose">verbose</code></td>
<td>
<p>defaults to <code>FALSE</code>.  If set to <code>TRUE</code> and if
<code>x</code> is a data frame then returned data frame will include columns
<code>First_Name</code> and <code>Last_Name</code> extracted as best as possible from
<code>Name</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with a column <code>Name_Reorder</code>, or a list, containing
strings reordered as Firstname Lastname in addition to all other columns in
input <code>df</code>.  Can also contain columns <code>First_Name</code> and
<code>Last_Name</code> depending on value of <code>verbose</code> argument
</p>


<h3>Examples</h3>

<pre><code class='language-R'>name_reorder(
data.frame(
Name = c("King, Lilly",
 "Lilly King",
 NA,
 "Richards Ross, Sanya",
 "Phelps, Michael F")),
verbose = TRUE
)
name_reorder(c("King, Lilly", "Lilly King", NA, "Richards Ross, Sanya"))

</code></pre>

<hr>
<h2 id='place'>Add places to results</h2><span id='topic+place'></span>

<h3>Description</h3>

<p>Places are awarded on the basis of time, with fastest (lowest) time winning.
For diving places are awarded on the basis of score, with the highest score
winning.
Ties are placed as ties (both athletes get 2nd etc.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>place(
  df,
  result_col = Finals,
  max_place = NULL,
  event_type = "ind",
  max_relays_per_team = 1,
  keep_nonscoring = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="place_+3A_df">df</code></td>
<td>
<p>a data frame with results from <code>swim_parse</code>, including
swimming and/or diving results.  <code>df</code> must contain a column called
<code>Event</code></p>
</td></tr>
<tr><td><code id="place_+3A_result_col">result_col</code></td>
<td>
<p>the name of a column in <code>df</code> containing times and/or
scores on which to place (order) performances.  Default is <code>Finals</code></p>
</td></tr>
<tr><td><code id="place_+3A_max_place">max_place</code></td>
<td>
<p>highest place value that scores</p>
</td></tr>
<tr><td><code id="place_+3A_event_type">event_type</code></td>
<td>
<p>either <code>"ind"</code> for individual or <code>"relay"</code> for
relays</p>
</td></tr>
<tr><td><code id="place_+3A_max_relays_per_team">max_relays_per_team</code></td>
<td>
<p>an integer value denoting the number of relays a
team may score (usually 1)</p>
</td></tr>
<tr><td><code id="place_+3A_keep_nonscoring">keep_nonscoring</code></td>
<td>
<p>are athletes in places greater than <code>max_place</code>
be retained in the data frame.  Either <code>TRUE</code> or <code>FALSE</code></p>
</td></tr>
<tr><td><code id="place_+3A_verbose">verbose</code></td>
<td>
<p>should warning messages be posted.  Default is <code>TRUE</code> and
should rarely be changed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame modified so that places have been appended based on
swimming time and/or diving score
</p>


<h3>See Also</h3>

<p><code>swim_place</code> is a helper function used inside of
<code>results_score</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  df &lt;- data.frame( Place = c(1, 1, 1, 1, 1, 1), Name = c("Sally Swimfast",
  "Bonnie Bubbles", "Kylie Kicker", "Riley Ripit", "Nathan Nosplash", "Tim
  Tuck"), Team = c("KVAC", "UBAM", "MERC", "Upstate Diving", "Nickel City
  Splash", "Finger Lakes Diving"), Event = c(rep("Women 200 Freestyle", 3),
  rep("Boys 1 mtr Diving", 3)), Prelims = c("2:00.00", "1:59.99", "2:01.50",
  "300.00", "305.00", "200.00"), Finals = c("1:58.00", "1:59.50", "2:00.50",
  "310.00", "307.00", "220.00"), Meet = c("Summer 2021", "Fall 2020", "Champs
  2020","Regional Champs 2021", "Other Regional Champs 2021", "City Champs
  2021" ))

df %&gt;%
  place() %&gt;%
  dplyr::arrange(Event)

df %&gt;%
  place(result_col = Prelims) %&gt;%
  dplyr::arrange(Event)

df %&gt;%
  place(result_col = "Prelims") %&gt;%
  dplyr::arrange(Event)

</code></pre>

<hr>
<h2 id='reaction_times_parse'>Pulls out reaction times from text</h2><span id='topic+reaction_times_parse'></span>

<h3>Description</h3>

<p>Locates reaction times in text of results output from <code>read_results</code> and
their associated row numbers.  The resulting data frame is joined back into
results to include reaction times
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reaction_times_parse(text)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reaction_times_parse_+3A_text">text</code></td>
<td>
<p>output from <code>read_results</code> followed by
<code>add_row_numbers</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a data frame with reaction times and row numbers to
eventually be recombined with swimming results inside <code>swim_parse</code>
</p>


<h3>See Also</h3>

<p><code>reaction_times_parse</code> is a helper function inside
<code><a href="#topic+swim_parse">swim_parse</a></code>
</p>

<hr>
<h2 id='read_htm'>Read in html files of swimming results</h2><span id='topic+read_htm'></span>

<h3>Description</h3>

<p>Read in html files of swimming results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_htm(x, node_helper)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_htm_+3A_x">x</code></td>
<td>
<p>an .html, .htm or .aspx location containing swimming results.  Must be
formatted in a &quot;normal&quot; fashion - see vignette</p>
</td></tr>
<tr><td><code id="read_htm_+3A_node_helper">node_helper</code></td>
<td>
<p>receives <code>node</code> from <code>read_results</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list of results, with &quot;read_results_flag&quot; added as the
first element of the list
</p>

<hr>
<h2 id='read_hy3'>Read in hy3 files of swimming results</h2><span id='topic+read_hy3'></span>

<h3>Description</h3>

<p>Read in hy3 files of swimming results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_hy3(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_hy3_+3A_x">x</code></td>
<td>
<p>an unzipped hy3 file containing swimming results.  Must be
formatted in a &quot;normal&quot; fashion - see vignette</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list of results, with &quot;read_results_flag&quot; added as the
first element of the list
</p>

<hr>
<h2 id='read_pdf'>Read in pdf files of swimming results</h2><span id='topic+read_pdf'></span>

<h3>Description</h3>

<p>Based on pdftools, this function can be temperamental
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_pdf(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_pdf_+3A_x">x</code></td>
<td>
<p>a .pdf or .aspx location containing swimming results.  Must be
formatted in a &quot;normal&quot; fashion - see vignette</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list of results, with &quot;read_results_flag&quot; added as the
first element of the list
</p>

<hr>
<h2 id='Read_Results'>Reads swimming and diving results into a list of strings in preparation for
parsing with <code>swim_parse</code></h2><span id='topic+Read_Results'></span><span id='topic+read_results'></span>

<h3>Description</h3>

<p>Outputs list of strings to be processed by <code>swim_parse</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Read_Results(file, node = "pre")

read_results(file, node = "pre")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Read_Results_+3A_file">file</code></td>
<td>
<p>a pdf, url or Hytek .hy3 file containing swimming
results.  Must be formatted in a &quot;normal&quot; fashion - see vignette</p>
</td></tr>
<tr><td><code id="Read_Results_+3A_node">node</code></td>
<td>
<p>a CSS node where html results are stored.  Required for html
results.  Default is &quot;pre&quot;, which nearly always works.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list of strings containing the information from
<code>file</code>.  Should then be parsed with <code>swim_parse</code>
</p>


<h3>See Also</h3>

<p><code>read_results</code> is meant to be followed by
<code><a href="#topic+swim_parse">swim_parse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
link &lt;-
  "http://www.nyhsswim.com/Results/Boys/2008/NYS/Single.htm", node = "pre"
read_results(link)
## End(Not run)

</code></pre>

<hr>
<h2 id='read_results_flag'>used to indicate that results have been read in with <code>read_results</code>
prior to being parsed by <code>swim_parse</code></h2><span id='topic+read_results_flag'></span>

<h3>Description</h3>

<p>Used to insure that <code>read_results</code> has been run on a data source prior
to running <code>swim_parse</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_results_flag(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_results_flag_+3A_x">x</code></td>
<td>
<p>a list of results, line by line</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns list x, with &quot;read_results_flag&quot; added as the first element
of the list
</p>

<hr>
<h2 id='replacement_entries'>Replaces superseded rows</h2><span id='topic+replacement_entries'></span>

<h3>Description</h3>

<p>Replaces superseded rows
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replacement_entries(x, j_helper, row_to_add_replacement, e_df_replacement)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="replacement_entries_+3A_x">x</code></td>
<td>
<p>a data frame of entries, either df_helper_2 or Entries</p>
</td></tr>
<tr><td><code id="replacement_entries_+3A_j_helper">j_helper</code></td>
<td>
<p>an integer denoting which element of e_df_replacement is
under test for removal.  Should be 1, 2, 3 or 4 depending on the minimum
number of entries</p>
</td></tr>
<tr><td><code id="replacement_entries_+3A_row_to_add_replacement">row_to_add_replacement</code></td>
<td>
<p>a row containing an improved entry that should
be added to x</p>
</td></tr>
<tr><td><code id="replacement_entries_+3A_e_df_replacement">e_df_replacement</code></td>
<td>
<p>a data frame of entries that may be replaced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame containing entries updated to include new rows from
row_to_add_replacement and to not contain rows from e_df_replacement, based
on j_helper
</p>

<hr>
<h2 id='results_score'>Scores a swim meet</h2><span id='topic+results_score'></span>

<h3>Description</h3>

<p>Used to add a <code>Points</code> column with point values for each place.  Can
either score &quot;timed finals&quot; type meets where any athlete can get any place,
or &quot;prelims-finals&quot;, type meets, where placing is restricted by prelim
performance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>results_score(
  results,
  events = NULL,
  meet_type = c("timed_finals", "prelims_finals"),
  lanes = c(4, 6, 8, 10),
  scoring_heats = c(1, 2, 3),
  point_values,
  max_relays_per_team = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="results_score_+3A_results">results</code></td>
<td>
<p>an output from <code>swim_parse</code></p>
</td></tr>
<tr><td><code id="results_score_+3A_events">events</code></td>
<td>
<p>list of events</p>
</td></tr>
<tr><td><code id="results_score_+3A_meet_type">meet_type</code></td>
<td>
<p>how to score based on <code>timed_finals</code>, where any place
is possible, or <code>prelims_finals</code> where athletes are locked into heats
for scoring purposes</p>
</td></tr>
<tr><td><code id="results_score_+3A_lanes">lanes</code></td>
<td>
<p>number of lanes in to the pool, for purposes of heat</p>
</td></tr>
<tr><td><code id="results_score_+3A_scoring_heats">scoring_heats</code></td>
<td>
<p>number of heats which score (if 1 only A final scores,
if 2 A and B final score etc.)</p>
</td></tr>
<tr><td><code id="results_score_+3A_point_values">point_values</code></td>
<td>
<p>Either a list of point values for each scoring place or
one of the following recognized strings: <code>"hs_four_lane"</code>,
<code>"hs_six_lane"</code>, <code>"ncaa_six_lane"</code>,
<code>"championship_8_lane_2_heat"</code> or <code>"championship_8_lane_3_heat"</code></p>
</td></tr>
<tr><td><code id="results_score_+3A_max_relays_per_team">max_relays_per_team</code></td>
<td>
<p>the number of relays a team is allowed to score
(usually 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>results with point values in a column called <code>Points</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
file &lt;-
system.file("extdata", "BigTen_WSWIM_2018.pdf", package = "SwimmeR")
BigTenRaw &lt;- read_results(file)

BigTen &lt;- swim_parse(
  BigTenRaw,
  typo = c(
    "^\\s{1,}\\*",
    "^\\s{1,}(\\d{1,2})\\s{2,}",
    ",\\s{1,}University\\s{1,}of",
    "University\\s{1,}of\\s{1,}",
    "\\s{1,}University",
    "SR\\s{2,}",
    "JR\\s{2,}",
    "SO\\s{2,}",
    "FR\\s{2,}"
  ),
  replacement = c(" ",
                  "  \\1 ",
                  "", "", "",
                  "SR ",
                  "JR ",
                  "SO ",
                  "FR "),
  avoid = c("B1G", "Pool")
)

BigTen &lt;- BigTen %&gt;%
  dplyr::filter(
    stringr::str_detect(Event, "Time Trial") == FALSE,
    stringr::str_detect(Event, "Swim-off") == FALSE
  ) %&gt;%
  dplyr::mutate(Team = dplyr::case_when(Team == "Wisconsin, Madi" ~ "Wisconsin",
                                          TRUE ~ Team))

# begin results_score portion
df &lt;- BigTen %&gt;%
  results_score(
    events = unique(BigTen$Event),
    meet_type = "prelims_finals",
    lanes = 8,
    scoring_heats = 3,
    point_values = c(
      32, 28, 27, 26, 25, 24, 23, 22, 20, 17, 16, 15, 14, 13, 12, 11, 9, 7,
       6, 5, 4, 3, 2, 1)
  )
 
## End(Not run)

</code></pre>

<hr>
<h2 id='sec_format'>Formatting mm:ss.tt times as seconds</h2><span id='topic+sec_format'></span>

<h3>Description</h3>

<p>Takes a character string (or list) representing time in swimming format (e.g.
1:35.37) and converts it to a numeric value (95.37) or a list of values
representing seconds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sec_format(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sec_format_+3A_x">x</code></td>
<td>
<p>A character vector of time(s) in swimming format (e.g. 1:35.93) to
be converted to seconds (95.93)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the value of the string <code>x</code> which represents a time in
swimming format (mm:ss.hh) and converts it to seconds
</p>


<h3>See Also</h3>

<p><code>sec_format</code> is the reverse of <code><a href="#topic+mmss_format">mmss_format</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sec_format("1:35.93")
sec_format("16:45.19")
sec_format("25.43")
sec_format(c("1:35.93", "16:45.19", "25.43"))
sec_format(c("1:35.93", "16:45.19", NA, "25.43", ":55.23"))

</code></pre>

<hr>
<h2 id='sec_format_helper'>Helper function for formatting mm:ss.hh times as seconds, used to enable
vectorized operation of <code>sec_format</code></h2><span id='topic+sec_format_helper'></span>

<h3>Description</h3>

<p>Helper function for formatting mm:ss.hh times as seconds, used to enable
vectorized operation of <code>sec_format</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sec_format_helper(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sec_format_helper_+3A_x">x</code></td>
<td>
<p>A character vector of time(s) in swimming format (e.g. 1:35.93) to
be converted to seconds (95.93)</p>
</td></tr>
</table>

<hr>
<h2 id='splash_clean_strings'>Cleans input strings</h2><span id='topic+splash_clean_strings'></span>

<h3>Description</h3>

<p>Cleans input from <code>read_results</code> is passed to <code>splash_swim_parse</code>
to remove unnneded characters and otherwise set it up for sorting.  Input is
in the form of character strings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splash_clean_strings(
  x,
  indent_length = Indent_Length,
  time_score_string = Time_Score_String,
  record_string = Record_String,
  header_string = Header_String,
  sponsorship_string = Sponsorship_String,
  reaction_string = Reaction_String,
  rule_string = Rule_String
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splash_clean_strings_+3A_x">x</code></td>
<td>
<p>a list of character strings</p>
</td></tr>
<tr><td><code id="splash_clean_strings_+3A_indent_length">indent_length</code></td>
<td>
<p>a numeric value denoting the number of spaces some
results are indented by.  <code>indent_length</code> is determined by
<code>splash_determine_indent_length</code>. Must be a whole number.</p>
</td></tr>
<tr><td><code id="splash_clean_strings_+3A_time_score_string">time_score_string</code></td>
<td>
<p>a regex string for matching results (times and
scores) but not special strings like DQ</p>
</td></tr>
<tr><td><code id="splash_clean_strings_+3A_record_string">record_string</code></td>
<td>
<p>a regex string for matching denoted records, rather than
results</p>
</td></tr>
<tr><td><code id="splash_clean_strings_+3A_header_string">header_string</code></td>
<td>
<p>a regex string from matching splash headers/footers
included in result documents</p>
</td></tr>
<tr><td><code id="splash_clean_strings_+3A_sponsorship_string">sponsorship_string</code></td>
<td>
<p>a regex string for matching sponsorship text within
result documents</p>
</td></tr>
<tr><td><code id="splash_clean_strings_+3A_reaction_string">reaction_string</code></td>
<td>
<p>a regex string for matching reaction times</p>
</td></tr>
<tr><td><code id="splash_clean_strings_+3A_rule_string">rule_string</code></td>
<td>
<p>a regex string for matching rule text e.g. 'Rule 4.24'
that sometimes accompanies DQs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list of character strings that have been cleaned in
preparation for parsing/sorting
</p>
<p>#' @seealso <code>splash_clean_strings</code> runs inside of
<code>swim_parse_splash</code>
</p>

<hr>
<h2 id='splash_collect_splits'>Collects Splash format splits</h2><span id='topic+splash_collect_splits'></span>

<h3>Description</h3>

<p>Collects splits and breaks them into a distance and a time, with a
corresponding row number
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splash_collect_splits(df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splash_collect_splits_+3A_df">df</code></td>
<td>
<p>a data frame containing two columns, <code>V1</code> is row numbers and
<code>Dummy</code> as a string combining split distance and split time</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with three columns, <code>V1</code>, <code>Split_Distance</code> and
<code>Split</code>
</p>

<hr>
<h2 id='splash_determine_indent_length'>Determines indent length for data within <code>swim_parse_splash</code></h2><span id='topic+splash_determine_indent_length'></span>

<h3>Description</h3>

<p>In Splash results there are two line types that are of interest and don't
begin with either a place or a special string (DNS, DSQ etc.).  These are
ties and relays swimmers.  Relay swimmers are indented further than ties.
This function determines the number of spaces, called indent length, prior to
a tie row, plus a pad of four spaces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splash_determine_indent_length(x, time_score_string)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splash_determine_indent_length_+3A_x">x</code></td>
<td>
<p>output from <code>read_results</code> followed by <code>add_row_numbers</code></p>
</td></tr>
<tr><td><code id="splash_determine_indent_length_+3A_time_score_string">time_score_string</code></td>
<td>
<p>a regular expression as a string that describes
swimming times and diving scores</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a number indicating the number of spaces preceding an
athlete's name in a tie row
</p>


<h3>See Also</h3>

<p><code>splash_determine_indent_length</code> runs inside of
<code>swim_parse_splash</code>
</p>

<hr>
<h2 id='splash_length_10_sort'>Sort data in lists of length 10 within <code>splash_swim_parse</code></h2><span id='topic+splash_length_10_sort'></span>

<h3>Description</h3>

<p>Sort data in lists of length 10 within <code>splash_swim_parse</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splash_length_10_sort(
  x,
  time_score_string = Time_Score_String,
  time_score_specials_string = Time_Score_Specials_String
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splash_length_10_sort_+3A_x">x</code></td>
<td>
<p>a list of lists with all sub-lists having length 10</p>
</td></tr>
<tr><td><code id="splash_length_10_sort_+3A_time_score_string">time_score_string</code></td>
<td>
<p>a regex string for matching results (times and
scores) but not special strings like DQ</p>
</td></tr>
<tr><td><code id="splash_length_10_sort_+3A_time_score_specials_string">time_score_specials_string</code></td>
<td>
<p>a regex string for matching results - i.e.
times, diving scores and 'specials' like DQ</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a formatted data frame to be combined with others to make the
output of <code>splash_swim_parse</code>
</p>

<hr>
<h2 id='splash_length_11_sort'>Sort data in lists of length 11 within <code>splash_swim_parse</code></h2><span id='topic+splash_length_11_sort'></span>

<h3>Description</h3>

<p>Sort data in lists of length 11 within <code>splash_swim_parse</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splash_length_11_sort(
  x,
  time_score_specials_string = Time_Score_Specials_String
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splash_length_11_sort_+3A_x">x</code></td>
<td>
<p>a list of lists with all sub-lists having length 11</p>
</td></tr>
<tr><td><code id="splash_length_11_sort_+3A_time_score_specials_string">time_score_specials_string</code></td>
<td>
<p>a regex string for matching results - i.e.
times, diving scores and 'specials' like DQ</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a formatted data frame to be combined with others to make the
output of <code>splash_swim_parse</code>
</p>

<hr>
<h2 id='splash_length_12_sort'>Sort data in lists of length 12 within <code>splash_swim_parse</code></h2><span id='topic+splash_length_12_sort'></span>

<h3>Description</h3>

<p>Sort data in lists of length 12 within <code>splash_swim_parse</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splash_length_12_sort(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splash_length_12_sort_+3A_x">x</code></td>
<td>
<p>a list of lists with all sub-lists having length 12</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a formatted data frame to be combined with others to make the
output of <code>splash_swim_parse</code>
</p>

<hr>
<h2 id='splash_length_4_sort'>Sort data in lists of length 4 within <code>spash_swim_parse</code></h2><span id='topic+splash_length_4_sort'></span>

<h3>Description</h3>

<p>Sort data in lists of length 4 within <code>spash_swim_parse</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splash_length_4_sort(
  x,
  name_string = Name_String,
  time_score_specials_string = Time_Score_Specials_String
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splash_length_4_sort_+3A_x">x</code></td>
<td>
<p>a list of lists with all sub-lists having length 4</p>
</td></tr>
<tr><td><code id="splash_length_4_sort_+3A_name_string">name_string</code></td>
<td>
<p>a regex string for matching athlete names</p>
</td></tr>
<tr><td><code id="splash_length_4_sort_+3A_time_score_specials_string">time_score_specials_string</code></td>
<td>
<p>a regex string for matching results - i.e.
times, diving scores and 'specials' like DQ</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a formatted data frame to be combined with others to make the
output of <code>splash_swim_parse</code>
</p>

<hr>
<h2 id='splash_length_5_sort'>Sort data in lists of length 5 within <code>spash_swim_parse</code></h2><span id='topic+splash_length_5_sort'></span>

<h3>Description</h3>

<p>Sort data in lists of length 5 within <code>spash_swim_parse</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splash_length_5_sort(
  x,
  name_string = Name_String,
  time_score_specials_string = Time_Score_Specials_String
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splash_length_5_sort_+3A_x">x</code></td>
<td>
<p>a list of lists with all sub-lists having length 5</p>
</td></tr>
<tr><td><code id="splash_length_5_sort_+3A_name_string">name_string</code></td>
<td>
<p>a regex string for matching athlete names</p>
</td></tr>
<tr><td><code id="splash_length_5_sort_+3A_time_score_specials_string">time_score_specials_string</code></td>
<td>
<p>a regex string for matching results - i.e.
times, diving scores and 'specials' like DQ</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a formatted data frame to be combined with others to make the
output of <code>splash_swim_parse</code>
</p>

<hr>
<h2 id='splash_length_6_sort'>Sort data in lists of length 6 within <code>spash_swim_parse</code></h2><span id='topic+splash_length_6_sort'></span>

<h3>Description</h3>

<p>Sort data in lists of length 6 within <code>spash_swim_parse</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splash_length_6_sort(
  x,
  time_score_specials_string = Time_Score_Specials_String
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splash_length_6_sort_+3A_x">x</code></td>
<td>
<p>a list of lists with all sub-lists having length 6</p>
</td></tr>
<tr><td><code id="splash_length_6_sort_+3A_time_score_specials_string">time_score_specials_string</code></td>
<td>
<p>a regex string for matching results - i.e.
times, diving scores and 'specials' like DQ</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a formatted data frame to be combined with others to make the
output of <code>splash_swim_parse</code>
</p>

<hr>
<h2 id='splash_length_7_sort'>Sort data in lists of length 7 within <code>spash_swim_parse</code></h2><span id='topic+splash_length_7_sort'></span>

<h3>Description</h3>

<p>Sort data in lists of length 7 within <code>spash_swim_parse</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splash_length_7_sort(
  x,
  time_score_string = Time_Score_String,
  time_score_specials_string = Time_Score_Specials_String
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splash_length_7_sort_+3A_x">x</code></td>
<td>
<p>a list of lists with all sub-lists having length 7</p>
</td></tr>
<tr><td><code id="splash_length_7_sort_+3A_time_score_string">time_score_string</code></td>
<td>
<p>a regex string for matching results (times and
scores) but not special strings like DQ</p>
</td></tr>
<tr><td><code id="splash_length_7_sort_+3A_time_score_specials_string">time_score_specials_string</code></td>
<td>
<p>a regex string for matching results - i.e.
times, diving scores and 'specials' like DQ</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a formatted data frame to be combined with others to make the
output of <code>splash_swim_parse</code>
</p>

<hr>
<h2 id='splash_length_8_sort'>Sort data in lists of length 8 within <code>spash_swim_parse</code></h2><span id='topic+splash_length_8_sort'></span>

<h3>Description</h3>

<p>Sort data in lists of length 8 within <code>spash_swim_parse</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splash_length_8_sort(
  x,
  time_score_string = Time_Score_String,
  time_score_specials_string = Time_Score_Specials_String
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splash_length_8_sort_+3A_x">x</code></td>
<td>
<p>a list of lists with all sub-lists having length 8</p>
</td></tr>
<tr><td><code id="splash_length_8_sort_+3A_time_score_string">time_score_string</code></td>
<td>
<p>a regex string for matching results (times and
scores) but not special strings like DQ</p>
</td></tr>
<tr><td><code id="splash_length_8_sort_+3A_time_score_specials_string">time_score_specials_string</code></td>
<td>
<p>a regex string for matching results - i.e.
times, diving scores and 'specials' like DQ</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a formatted data frame to be combined with others to make the
output of <code>splash_swim_parse</code>
</p>

<hr>
<h2 id='splash_length_9_sort'>Sort data in lists of length 9 within <code>spash_swim_parse</code></h2><span id='topic+splash_length_9_sort'></span>

<h3>Description</h3>

<p>Sort data in lists of length 9 within <code>spash_swim_parse</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splash_length_9_sort(
  x,
  heat_lane_string = Heat_Lane_String,
  time_score_string = Time_Score_String,
  time_score_specials_string = Time_Score_Specials_String
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splash_length_9_sort_+3A_x">x</code></td>
<td>
<p>a list of lists with all sub-lists having length 9</p>
</td></tr>
<tr><td><code id="splash_length_9_sort_+3A_heat_lane_string">heat_lane_string</code></td>
<td>
<p>a regex string for matching heat-lane pairs</p>
</td></tr>
<tr><td><code id="splash_length_9_sort_+3A_time_score_string">time_score_string</code></td>
<td>
<p>a regex string for matching results (times and
scores) but not special strings like DQ</p>
</td></tr>
<tr><td><code id="splash_length_9_sort_+3A_time_score_specials_string">time_score_specials_string</code></td>
<td>
<p>a regex string for matching results - i.e.
times, diving scores and 'specials' like DQ</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a formatted data frame to be combined with others to make the
output of <code>splash_swim_parse</code>
</p>

<hr>
<h2 id='splits_parse'>Collects splits within <code>swim_parse</code></h2><span id='topic+splits_parse'></span>

<h3>Description</h3>

<p>Takes the output of <code>read_results</code> and, inside of <code>swim_parse</code>,
extracts split times and associated row numbers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splits_parse(text, split_len = split_length)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splits_parse_+3A_text">text</code></td>
<td>
<p>output of <code>read_results</code> with row numbers appended by
<code>add_row_numbers</code></p>
</td></tr>
<tr><td><code id="splits_parse_+3A_split_len">split_len</code></td>
<td>
<p>length of pool at which splits are measured - usually 25 or
50</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a data frame with split times and row numbers
</p>


<h3>See Also</h3>

<p><code>splits_parse</code> runs inside <code><a href="#topic+swim_parse">swim_parse</a></code> on the
output of <code><a href="#topic+read_results">read_results</a></code> with row numbers from
<code><a href="#topic+add_row_numbers">add_row_numbers</a></code>
</p>

<hr>
<h2 id='splits_parse_ISL'>Collects splits within <code>swim_parse_ISL</code></h2><span id='topic+splits_parse_ISL'></span>

<h3>Description</h3>

<p>Takes the output of <code>read_results</code> and, inside of <code>swim_parse_ISL</code>,
extracts split times and associated row numbers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splits_parse_ISL(text)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splits_parse_ISL_+3A_text">text</code></td>
<td>
<p>output of <code>read_results</code> with tow numbers appended by
<code>add_row_numbers</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a data frame with split times and row numbers
</p>


<h3>See Also</h3>

<p><code>splits_parse_ISL</code> runs inside <code><a href="#topic+swim_parse_ISL">swim_parse_ISL</a></code> on
the output of <code><a href="#topic+read_results">read_results</a></code> with row numbers from
<code><a href="#topic+add_row_numbers">add_row_numbers</a></code>
</p>

<hr>
<h2 id='splits_parse_omega_relays'>Collects splits for relays within <code>swim_parse_omega</code></h2><span id='topic+splits_parse_omega_relays'></span>

<h3>Description</h3>

<p>Takes the output of <code>read_results</code> and, inside of
<code>swim_parse_omega</code>, extracts split times and associated row numbers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splits_parse_omega_relays(text, split_len = split_length_omega)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splits_parse_omega_relays_+3A_text">text</code></td>
<td>
<p>output of <code>read_results</code> with row numbers appended by
<code>add_row_numbers</code></p>
</td></tr>
<tr><td><code id="splits_parse_omega_relays_+3A_split_len">split_len</code></td>
<td>
<p>length of pool at which splits are measured - usually 25 or
50</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a data frame with split times and row numbers
</p>


<h3>See Also</h3>

<p><code>splits_parse</code> runs inside <code><a href="#topic+swim_parse_omega">swim_parse_omega</a></code> on
the output of <code><a href="#topic+read_results">read_results</a></code> with row numbers from
<code><a href="#topic+add_row_numbers">add_row_numbers</a></code>
</p>

<hr>
<h2 id='splits_parse_splash'>Collects splits within <code>swim_parse_splash</code> for Splash results</h2><span id='topic+splits_parse_splash'></span>

<h3>Description</h3>

<p>Takes the output of <code>read_results</code> and, inside of
<code>swim_parse_splash</code>, extracts split times and associated row numbers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splits_parse_splash(raw_results)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splits_parse_splash_+3A_raw_results">raw_results</code></td>
<td>
<p>output of <code>read_results</code> with row numbers appended by
<code>add_row_numbers</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a data frame with split times and row numbers
</p>


<h3>See Also</h3>

<p><code>splits_parse</code> runs inside <code><a href="#topic+swim_parse_splash">swim_parse_splash</a></code> on
the output of <code><a href="#topic+read_results">read_results</a></code> with row numbers from
<code><a href="#topic+add_row_numbers">add_row_numbers</a></code>
</p>

<hr>
<h2 id='splits_parse_splash_helper_1'>Produces data frames of splits within <code>swim_parse_splash</code> for Splash
results</h2><span id='topic+splits_parse_splash_helper_1'></span>

<h3>Description</h3>

<p>Converts strings of splits and row numbers into data frames with a row number
column (V1) and a splits column (Split_XX)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splits_parse_splash_helper_1(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splits_parse_splash_helper_1_+3A_data">data</code></td>
<td>
<p>a list of lists containing splits and row numbers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a data frame with split times and row numbers
</p>


<h3>See Also</h3>

<p><code>splits_parse_splash_helper_1</code> runs inside
<code><a href="#topic+splits_parse_splash">splits_parse_splash</a></code>
</p>

<hr>
<h2 id='splits_parse_splash_helper_2'>Produces data frames of splits within <code>swim_parse_splash</code> for Splash
results</h2><span id='topic+splits_parse_splash_helper_2'></span>

<h3>Description</h3>

<p>Converts strings of splits and row numbers into data frames with a row number
column (V1) and a splits column (Split_XX)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splits_parse_splash_helper_2(data, split_distances, i)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splits_parse_splash_helper_2_+3A_data">data</code></td>
<td>
<p>a list of lists containing splits and row numbers</p>
</td></tr>
<tr><td><code id="splits_parse_splash_helper_2_+3A_split_distances">split_distances</code></td>
<td>
<p>a list of distances for splits, e.g. &quot;50m&quot;, &quot;100m&quot;</p>
</td></tr>
<tr><td><code id="splits_parse_splash_helper_2_+3A_i">i</code></td>
<td>
<p>a number between 1 and the length of <code>split_distances</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a data frame with split times and row numbers
</p>


<h3>See Also</h3>

<p><code>splits_parse_splash_helper_2</code> runs inside
<code><a href="#topic+splits_parse_splash">splits_parse_splash</a></code>
</p>

<hr>
<h2 id='splits_parse_splash_relays'>Collects splits for relays within <code>swim_parse_splash</code></h2><span id='topic+splits_parse_splash_relays'></span>

<h3>Description</h3>

<p>Takes the output of <code>read_results</code> and, inside of <code>swim_parse_splash</code>,
extracts split times and associated row numbers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splits_parse_splash_relays(text, split_len = split_length_splash)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splits_parse_splash_relays_+3A_text">text</code></td>
<td>
<p>output of <code>read_results</code> with row numbers appended by
<code>add_row_numbers</code></p>
</td></tr>
<tr><td><code id="splits_parse_splash_relays_+3A_split_len">split_len</code></td>
<td>
<p>length of pool at which splits are measured - usually 25 or
50</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a dataframe with split times and row numbers
</p>


<h3>See Also</h3>

<p><code>splits_parse</code> runs inside <code><a href="#topic+swim_parse_splash">swim_parse_splash</a></code> on the
output of <code><a href="#topic+read_results">read_results</a></code> with row numbers from
<code><a href="#topic+add_row_numbers">add_row_numbers</a></code>
</p>

<hr>
<h2 id='splits_reform'>Adds together splits and compares to listed finals time to see if they match.</h2><span id='topic+splits_reform'></span>

<h3>Description</h3>

<p>Used in testing the workings for <code>split_parse</code> inside test-splits.R.
Note that even properly handled splits may not match the finals time due to
issues in the source material. Sometimes splits aren't fully recorded in the
source. Some relays also will not match due to the convention of reporting
splits by swimmer (see vignette for more details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splits_reform(df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splits_reform_+3A_df">df</code></td>
<td>
<p>a data frame output from <code>swim_parse</code> created with <code>splits
= TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with a column <code>not_matching</code> containing <code>TRUE</code>
if the splits for that swim match the finals time and <code>FALSE</code> if they
do not
</p>

<hr>
<h2 id='splits_rename_omega'>Advances split names by one split_length</h2><span id='topic+splits_rename_omega'></span>

<h3>Description</h3>

<p>Used to adjust names of splits inside <code>swim_parse_omega</code> to account for
50 split not being correctly captured
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splits_rename_omega(x, split_len = split_length_omega)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splits_rename_omega_+3A_x">x</code></td>
<td>
<p>a string to rename, from columns output by <code>splits_parse</code></p>
</td></tr>
<tr><td><code id="splits_rename_omega_+3A_split_len">split_len</code></td>
<td>
<p>distance for each split</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns string iterated up by split_length
</p>


<h3>See Also</h3>

<p><code>splits_rename_omega</code> runs inside
<code><a href="#topic+swim_parse_omega">swim_parse_omega</a></code> on the output of <code><a href="#topic+splits_parse">splits_parse</a></code>
</p>

<hr>
<h2 id='splits_to_cumulative'>Converts splits from lap to cumulative format</h2><span id='topic+splits_to_cumulative'></span>

<h3>Description</h3>

<p>Cumulative splits are when each split is the total elapsed time at a given
distance.  For example, if an athlete swims the first 50 of a 200 yard race
in 25.00 seconds (lap and cumulative split), and the second 50 (i.e. the 100
lap split) in 30.00 seconds the cumulative 100 split is 25.00 + 30.00 =
55.00.  Some swimming results are reported with lap splits (preferred), but
others use cumulative splits.  This function converts lap splits to
cumulative splits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splits_to_cumulative(df, threshold = Inf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splits_to_cumulative_+3A_df">df</code></td>
<td>
<p>a data frame containing results with splits in lap format.  Must
be formatted in a &quot;normal&quot; SwimmeR fashion - see vignette</p>
</td></tr>
<tr><td><code id="splits_to_cumulative_+3A_threshold">threshold</code></td>
<td>
<p>a numeric value above which a split is taken to be
cumulative.  Default is <code>Inf</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with all splits in lap form
</p>


<h3>See Also</h3>

<p><code>splits_to_cumulative</code> is the reverse of
<code><a href="#topic+splits_to_lap">splits_to_lap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
df &lt;- data.frame(Place = rep(1, 2),
                Name = c("Lenore Lap", "Casey Cumulative"),
                Team = rep("KVAC", 2),
                Event = rep("Womens 200 Freestyle", 2),
                Finals = rep("1:58.00", 2),
                Split_50 = rep("28.00", 2),
                Split_100 = c("31.00", "59.00"),
                Split_150 = c("30.00", "1:29.00"),
                Split_200 = c("29.00", "1:58.00")
               )

 # since one entry is in lap time and the other is cumulative, need to
 # set threshold value

 # not setting threshold will produce bad results by attempting to convert
 # Casey Cumulative's splits, which are already in cumulative
 # format, into cumulative format again

 df %&gt;%
   splits_to_cumulative()

 df %&gt;%
   splits_to_cumulative(threshold = 20)

 
## End(Not run)
</code></pre>

<hr>
<h2 id='splits_to_cumulative_helper_recalc'>Helper function for converting lap splits to cumulative splits</h2><span id='topic+splits_to_cumulative_helper_recalc'></span>

<h3>Description</h3>

<p>Helper function for converting lap splits to cumulative splits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splits_to_cumulative_helper_recalc(
  df,
  i,
  split_cols = split_cols,
  threshold = threshold
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splits_to_cumulative_helper_recalc_+3A_df">df</code></td>
<td>
<p>a data frame containing splits in lap format</p>
</td></tr>
<tr><td><code id="splits_to_cumulative_helper_recalc_+3A_i">i</code></td>
<td>
<p>list of values to iterate along</p>
</td></tr>
<tr><td><code id="splits_to_cumulative_helper_recalc_+3A_split_cols">split_cols</code></td>
<td>
<p>list of columns containing splits</p>
</td></tr>
<tr><td><code id="splits_to_cumulative_helper_recalc_+3A_threshold">threshold</code></td>
<td>
<p>a numeric value below which a split is taken to be
lap</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of data frames with all splits in cumulative format for a
particular event, each with a single split column converted to cumulative
format
</p>

<hr>
<h2 id='splits_to_lap'>Converts splits from cumulative to lap format</h2><span id='topic+splits_to_lap'></span>

<h3>Description</h3>

<p>Cumulative splits are when each split is the total elapsed time at a given
distance.  For example, if an athlete swims the first 50 of a 200 yard race
in 25.00 seconds (lap and cumulative split), and the second 50 (i.e. the 100
lap split) in 30.00 seconds the cumulative 100 split is 25.00 + 30.00 =
55.00.  Some swimming results are reported with lap splits (preferred), but
others use cumulative splits.  This function converts cumulative splits to
lap splits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splits_to_lap(df, threshold = -Inf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splits_to_lap_+3A_df">df</code></td>
<td>
<p>a data frame containing results with splits in cumulative format.
Must be formatted in a &quot;normal&quot; SwimmeR fashion - see vignette</p>
</td></tr>
<tr><td><code id="splits_to_lap_+3A_threshold">threshold</code></td>
<td>
<p>a numeric value below which a split is taken to be
cumulative.  Default is <code>-Inf</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with all splits in lap form
</p>


<h3>See Also</h3>

<p><code>splits_to_lap</code> is the reverse of
<code><a href="#topic+splits_to_cumulative">splits_to_cumulative</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
df &lt;- data.frame(Place = 1,
                Name = "Sally Swimfast",
                Team = "KVAC",
                Event = "Womens 200 Freestyle",
                Finals_Time = "1:58.00",
                Split_50 = "28.00",
                Split_100 = "59.00",
                Split_150 = "1:31.00",
                Split_200 = "1:58.00")

df %&gt;%
 splits_to_lap

df &lt;- data.frame(Place = rep(1, 2),
                Name = c("Lenore Lap", "Casey Cumulative"),
                Team = rep("KVAC", 2),
                Event = rep("Womens 200 Freestyle", 2),
                Finals_Time = rep("1:58.00", 2),
                Split_50 = rep("28.00", 2),
                Split_100 = c("31.00", "59.00"),
                Split_150 = c("30.00", "1:29.00"),
                Split_200 = c("29.00", "1:58.00")
               )

 # since one entry is in lap time and the other is cumulative, need to
 # set threshold value

 # not setting threshold will produce bad results by attempting to convert
 # Lenore Lap's splits, which are already in lap format, into lap format
 # again

 df %&gt;%
   splits_to_lap()

 df %&gt;%
   splits_to_lap(threshold = 35)

 
## End(Not run)
</code></pre>

<hr>
<h2 id='splits_to_lap_helper_recalc'>Helper function for converting cumulative splits to lap splits</h2><span id='topic+splits_to_lap_helper_recalc'></span>

<h3>Description</h3>

<p>Helper function for converting cumulative splits to lap splits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splits_to_lap_helper_recalc(
  df,
  i,
  split_cols = split_cols,
  threshold = threshold
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splits_to_lap_helper_recalc_+3A_df">df</code></td>
<td>
<p>a data frame containing splits in cumulative format</p>
</td></tr>
<tr><td><code id="splits_to_lap_helper_recalc_+3A_i">i</code></td>
<td>
<p>list of values to iterate along</p>
</td></tr>
<tr><td><code id="splits_to_lap_helper_recalc_+3A_split_cols">split_cols</code></td>
<td>
<p>list of columns containing splits</p>
</td></tr>
<tr><td><code id="splits_to_lap_helper_recalc_+3A_threshold">threshold</code></td>
<td>
<p>a numeric value above which a split is taken to be
cumulative</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of data frames with all splits in lap format for a particular
event, each with a single split column converted to lap format
</p>

<hr>
<h2 id='Swim_Parse'>Formats swimming and diving data read with <code>read_results</code> into a data
frame</h2><span id='topic+Swim_Parse'></span><span id='topic+swim_parse'></span>

<h3>Description</h3>

<p>Takes the output of <code>read_results</code> and cleans it, yielding a data frame
of swimming (and diving) results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Swim_Parse(
  file,
  avoid = NULL,
  typo = typo_default,
  replacement = replacement_default,
  format_results = TRUE,
  splits = FALSE,
  split_length = 50,
  relay_swimmers = FALSE
)

swim_parse(
  file,
  avoid = NULL,
  typo = typo_default,
  replacement = replacement_default,
  format_results = TRUE,
  splits = FALSE,
  split_length = 50,
  relay_swimmers = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Swim_Parse_+3A_file">file</code></td>
<td>
<p>output from <code>read_results</code></p>
</td></tr>
<tr><td><code id="Swim_Parse_+3A_avoid">avoid</code></td>
<td>
<p>a list of strings.  Rows in <code>file</code> containing these strings
will not be included. For example &quot;Pool:&quot;, often used to label pool
records, could be passed to <code>avoid</code>.  The default is
<code>avoid_default</code>, which contains many strings similar to &quot;Pool:&quot;, such
as &quot;STATE:&quot; and &quot;Qual:&quot;.  Users can supply their own lists to <code>avoid</code>.
<code>avoid</code> is handled before <code>typo</code> and <code>replacement</code>.</p>
</td></tr>
<tr><td><code id="Swim_Parse_+3A_typo">typo</code></td>
<td>
<p>a list of strings that are typos in the original results.
<code>swim_parse</code> is particularly sensitive to accidental double spaces, so
&quot;Central  High School&quot;, with two spaces between &quot;Central&quot; and &quot;High&quot; is a
problem, which can be fixed.  Pass &quot;Central  High School&quot; to <code>typo</code>.
Unexpected commas as also an issue, for example &quot;Texas, University of&quot;
should be fixed using <code>typo</code> and <code>replacement</code></p>
</td></tr>
<tr><td><code id="Swim_Parse_+3A_replacement">replacement</code></td>
<td>
<p>a list of fixes for the strings in <code>typo</code>.  Here one
could pass &quot;Central High School&quot; (one space between &quot;Central&quot; and &quot;High&quot;)
and &quot;Texas&quot; to <code>replacement</code> fix the issues described in <code>typo</code></p>
</td></tr>
<tr><td><code id="Swim_Parse_+3A_format_results">format_results</code></td>
<td>
<p>should the results be formatted for analysis (special
strings like <code>"DQ"</code> replaced with <code>NA</code>, <code>Finals</code> as
definitive column)?  Default is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="Swim_Parse_+3A_splits">splits</code></td>
<td>
<p>either <code>TRUE</code> or the default, <code>FALSE</code> - should
<code>swim_parse</code> attempt to include splits.</p>
</td></tr>
<tr><td><code id="Swim_Parse_+3A_split_length">split_length</code></td>
<td>
<p>either <code>25</code> or the default, <code>50</code>, the length of
pool at which splits are recorded.  Not all results are internally
consistent on this issue - some have races with splits by 50 and other
races with splits by 25.</p>
</td></tr>
<tr><td><code id="Swim_Parse_+3A_relay_swimmers">relay_swimmers</code></td>
<td>
<p>either <code>TRUE</code> or the default, <code>FALSE</code> -
should relay swimmers be reported.  Relay swimmers are reported in separate
columns named <code>Relay_Swimmer_1</code> etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a data frame with columns <code>Name</code>, <code>Place</code>,
<code>Age</code>, <code>Team</code>, <code>Prelims</code>, <code>Finals</code>,
<code>Points</code>, <code>Event</code> &amp; <code>DQ</code>.  Note all swims will have a
<code>Finals</code>, even if that time was actually swam in the prelims
(i.e. a swimmer did not qualify for finals).  This is so that final results
for an event can be generated from just one column.
</p>


<h3>See Also</h3>

<p><code>swim_parse</code> must be run on the output of
<code><a href="#topic+read_results">read_results</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
swim_parse(read_results("http://www.nyhsswim.com/Results/Boys/2008/NYS/Single.htm", node = "pre"),
 typo = c("-1NORTH ROCKL"), replacement = c("1-NORTH ROCKL"),
 splits = TRUE,
 relay_swimmers = TRUE)
 
## End(Not run)
## Not run: 
swim_parse(read_results("inst/extdata/Texas-Florida-Indiana.pdf"),
 typo =  c("Indiana  University", ", University of"), replacement = c("Indiana University", ""),
 splits = TRUE,
 relay_swimmers = TRUE)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='swim_parse_hytek'>Formats Hytek style swimming and diving data read with <code>read_results</code>
into a data frame</h2><span id='topic+swim_parse_hytek'></span>

<h3>Description</h3>

<p>Takes the output of <code>read_results</code> and cleans it, yielding a data frame
of swimming (and diving) results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swim_parse_hytek(
  file_hytek,
  avoid_hytek = avoid,
  typo_hytek = typo,
  replacement_hytek = replacement,
  format_results = TRUE,
  splits = FALSE,
  split_length_hytek = split_length,
  relay_swimmers_hytek = relay_swimmers
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="swim_parse_hytek_+3A_file_hytek">file_hytek</code></td>
<td>
<p>output from <code>read_results</code></p>
</td></tr>
<tr><td><code id="swim_parse_hytek_+3A_avoid_hytek">avoid_hytek</code></td>
<td>
<p>a list of strings.  Rows in <code>file_hytek</code> containing
these strings will not be included. For example &quot;Pool:&quot;, often used to
label pool records, could be passed to <code>avoid_hytek</code>.  The default is
<code>avoid_default</code>, which contains many strings similar to &quot;Pool:&quot;, such
as &quot;STATE:&quot; and &quot;Qual:&quot;.  Users can supply their own lists to
<code>avoid_hytek</code>. <code>avoid_hytek</code> is handled before <code>typo_hytek</code>
and <code>replacement_hytek</code>.</p>
</td></tr>
<tr><td><code id="swim_parse_hytek_+3A_typo_hytek">typo_hytek</code></td>
<td>
<p>a list of strings that are typos in the original results.
<code>swim_parse</code> is particularly sensitive to accidental double spaces, so
&quot;Central  High School&quot;, with two spaces between &quot;Central&quot; and &quot;High&quot; is a
problem, which can be fixed.  Pass &quot;Central  High School&quot; to
<code>typo_hytek</code>. Unexpected commas as also an issue, for example &quot;Texas,
University of&quot; should be fixed using <code>typo_hytek</code> and
<code>replacement_hytek</code></p>
</td></tr>
<tr><td><code id="swim_parse_hytek_+3A_replacement_hytek">replacement_hytek</code></td>
<td>
<p>a list of fixes for the strings in
<code>typo_hytek</code>.  Here one could pass &quot;Central High School&quot; (one space
between &quot;Central&quot; and &quot;High&quot;) and &quot;Texas&quot; to <code>replacement_hytek</code> fix
the issues described in <code>typo_hytek</code></p>
</td></tr>
<tr><td><code id="swim_parse_hytek_+3A_format_results">format_results</code></td>
<td>
<p>should the results be formatted for analysis (special
strings like <code>"DQ"</code> replaced with <code>NA</code>, <code>Finals</code> as
definitive column)?  Default is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="swim_parse_hytek_+3A_splits">splits</code></td>
<td>
<p>either <code>TRUE</code> or the default, <code>FALSE</code> - should
<code>swim_parse</code> attempt to include splits.</p>
</td></tr>
<tr><td><code id="swim_parse_hytek_+3A_split_length_hytek">split_length_hytek</code></td>
<td>
<p>either <code>25</code> or the default, <code>50</code>, the
length of pool at which splits are recorded.  Not all results are
internally consistent on this issue - some have races with splits by 50 and
other races with splits by 25.</p>
</td></tr>
<tr><td><code id="swim_parse_hytek_+3A_relay_swimmers_hytek">relay_swimmers_hytek</code></td>
<td>
<p>should names of relay swimmers be captured?
Default is <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a data frame with columns <code>Name</code>, <code>Place</code>,
<code>Age</code>, <code>Team</code>, <code>Prelims</code>, <code>Finals</code>,
<code>Points</code>, <code>Event</code> &amp; <code>DQ</code>.  Note all swims will have a
<code>Finals</code>, even if that time was actually swam in the prelims
(i.e. a swimmer did not qualify for finals).  This is so that final results
for an event can be generated from just one column.
</p>


<h3>See Also</h3>

<p><code>swim_parse_hytek</code> must be run on the output of
<code><a href="#topic+read_results">read_results</a></code>
</p>

<hr>
<h2 id='swim_parse_ISL'>Formats swimming results from the International Swim League ('ISL') read with
<code>read_results</code> into a data frame</h2><span id='topic+swim_parse_ISL'></span><span id='topic+Swim_Parse_ISL'></span>

<h3>Description</h3>

<p>Takes the output of <code>read_results</code> and cleans it, yielding a data frame
of 'ISL' swimming results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swim_parse_ISL(file, splits = FALSE, relay_swimmers = FALSE)

Swim_Parse_ISL(file, splits = FALSE, relay_swimmers = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="swim_parse_ISL_+3A_file">file</code></td>
<td>
<p>output from <code>read_results</code></p>
</td></tr>
<tr><td><code id="swim_parse_ISL_+3A_splits">splits</code></td>
<td>
<p>should splits be included, default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="swim_parse_ISL_+3A_relay_swimmers">relay_swimmers</code></td>
<td>
<p>should relay swimmers be included as separate columns,
default is <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a data frame of ISL results
</p>


<h3>Author(s)</h3>

<p>Greg Pilgrim <a href="mailto:gpilgrim2670@gmail.com">gpilgrim2670@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code>swim_parse_ISL</code> must be run on the output of
<code><a href="#topic+read_results">read_results</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
swim_parse_ISL(
read_results(
"https://isl.global/wp-content/uploads/2019/11/isl_college_park_results_day_2.pdf"),
splits = TRUE,
relay_swimmers = TRUE)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='swim_parse_old'>Formats swimming and diving data read with <code>read_results</code> into a data
frame</h2><span id='topic+swim_parse_old'></span>

<h3>Description</h3>

<p>Takes the output of <code>read_results</code> and cleans it, yielding a data frame
of swimming (and diving) results.  Old version, retired in dev build on Dec
21, 2020 and release version 0.7.0
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swim_parse_old(
  file,
  avoid = avoid_default,
  typo = typo_default,
  replacement = replacement_default,
  splits = FALSE,
  split_length = 50,
  relay_swimmers = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="swim_parse_old_+3A_file">file</code></td>
<td>
<p>output from <code>read_results</code></p>
</td></tr>
<tr><td><code id="swim_parse_old_+3A_avoid">avoid</code></td>
<td>
<p>a list of strings.  Rows in <code>file</code> containing these strings
will not be included. For example &quot;Pool:&quot;, often used to label pool
records, could be passed to <code>avoid</code>.  The default is
<code>avoid_default</code>, which contains many strings similar to &quot;Pool:&quot;, such
as &quot;STATE:&quot; and &quot;Qual:&quot;.  Users can supply their own lists to <code>avoid</code>.</p>
</td></tr>
<tr><td><code id="swim_parse_old_+3A_typo">typo</code></td>
<td>
<p>a list of strings that are typos in the original results.
<code>swim_parse_old</code> is particularly sensitive to accidental double
spaces, so &quot;Central  High School&quot;, with two spaces between &quot;Central&quot; and
&quot;High&quot; is a problem, which can be fixed.  Pass &quot;Central  High School&quot; to
<code>typo</code>.  Unexpected commas as also an issue, for example &quot;Texas,
University of&quot; should be fixed using <code>typo</code> and <code>replacement</code></p>
</td></tr>
<tr><td><code id="swim_parse_old_+3A_replacement">replacement</code></td>
<td>
<p>a list of fixes for the strings in <code>typo</code>.  Here one
could pass &quot;Central High School&quot; (one space between &quot;Central&quot; and &quot;High&quot;)
and &quot;Texas&quot; to <code>replacement</code> fix the issues described in <code>typo</code></p>
</td></tr>
<tr><td><code id="swim_parse_old_+3A_splits">splits</code></td>
<td>
<p>either <code>TRUE</code> or the default, <code>FALSE</code> - should
<code>swim_parse_old</code> attempt to include splits.</p>
</td></tr>
<tr><td><code id="swim_parse_old_+3A_split_length">split_length</code></td>
<td>
<p>either <code>25</code> or the default, <code>50</code>, the length of
pool at which splits are recorded.  Not all results are internally
consistent on this issue - some have races with splits by 50 and other
races with splits by 25.</p>
</td></tr>
<tr><td><code id="swim_parse_old_+3A_relay_swimmers">relay_swimmers</code></td>
<td>
<p>either <code>TRUE</code> or the default, <code>FALSE</code> -
should relay swimmers be reported.  Relay swimmers are reported in separate
columns named <code>Relay_Swimmer_1</code> etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a data frame with columns <code>Name</code>, <code>Place</code>,
<code>Age</code>, <code>Team</code>, <code>Prelims_Time</code>, <code>Finals_Time</code>,
<code>Points</code>, <code>Event</code> &amp; <code>DQ</code>.  Note all swims will have a
<code>Finals_Time</code>, even if that time was actually swam in the prelims
(i.e. a swimmer did not qualify for finals).  This is so that final results
for an event can be generated from just one column.
</p>


<h3>See Also</h3>

<p><code>swim_parse_old</code> must be run on the output of
<code><a href="#topic+read_results">read_results</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
swim_parse_old(
 read_results("http://www.nyhsswim.com/Results/Boys/2008/NYS/Single.htm", node = "pre"),
  typo = c("-1NORTH ROCKL"), replacement = c("1-NORTH ROCKL"),
  splits = TRUE,
  relay_swimmers = TRUE)
 
## End(Not run)
## Not run: 
swim_parse_old(read_results("inst/extdata/Texas-Florida-Indiana.pdf"),
 typo =  c("Indiana  University", ", University of"), replacement = c("Indiana University", ""),
 splits = TRUE,
 relay_swimmers = TRUE)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='swim_parse_omega'>Formats Omega style swimming and diving data read with <code>read_results</code>
into a data frame</h2><span id='topic+swim_parse_omega'></span>

<h3>Description</h3>

<p>Takes the output of <code>read_results</code> and cleans it, yielding a data frame
of swimming (and diving) results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swim_parse_omega(
  file_omega,
  avoid_omega = avoid,
  typo_omega = typo,
  replacement_omega = replacement,
  format_results = TRUE,
  splits = FALSE,
  split_length_omega = split_length,
  relay_swimmers_omega = relay_swimmers
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="swim_parse_omega_+3A_file_omega">file_omega</code></td>
<td>
<p>output from <code>read_results</code></p>
</td></tr>
<tr><td><code id="swim_parse_omega_+3A_avoid_omega">avoid_omega</code></td>
<td>
<p>a list of strings.  Rows in <code>file_omega</code> containing
these strings will not be included. For example &quot;Pool:&quot;, often used to
label pool records, could be passed to <code>avoid_omega</code>.  The default is
<code>avoid_default</code>, which contains many strings similar to &quot;Pool:&quot;, such
as &quot;STATE:&quot; and &quot;Qual:&quot;.  Users can supply their own lists to
<code>avoid_omega</code>. <code>avoid_omega</code> is handled before <code>typo_omega</code>
and <code>replacement_omega</code>.</p>
</td></tr>
<tr><td><code id="swim_parse_omega_+3A_typo_omega">typo_omega</code></td>
<td>
<p>a list of strings that are typos in the original results.
<code>swim_parse</code> is particularly sensitive to accidental double spaces, so
&quot;Central  High School&quot;, with two spaces between &quot;Central&quot; and &quot;High&quot; is a
problem, which can be fixed.  Pass &quot;Central  High School&quot; to
<code>typo_omega</code>. Unexpected commas as also an issue, for example &quot;Texas,
University of&quot; should be fixed using <code>typo_omega</code> and
<code>replacement_omega</code></p>
</td></tr>
<tr><td><code id="swim_parse_omega_+3A_replacement_omega">replacement_omega</code></td>
<td>
<p>a list of fixes for the strings in
<code>typo_omega</code>.  Here one could pass &quot;Central High School&quot; (one space
between &quot;Central&quot; and &quot;High&quot;) and &quot;Texas&quot; to <code>replacement_omega</code> fix
the issues described in <code>typo_omega</code></p>
</td></tr>
<tr><td><code id="swim_parse_omega_+3A_format_results">format_results</code></td>
<td>
<p>should the results be formatted for analysis (special
strings like <code>"DQ"</code> replaced with <code>NA</code>, <code>Finals</code> as
definitive column)?  Default is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="swim_parse_omega_+3A_splits">splits</code></td>
<td>
<p>either <code>TRUE</code> or the default, <code>FALSE</code> - should
<code>swim_parse</code> attempt to include splits.</p>
</td></tr>
<tr><td><code id="swim_parse_omega_+3A_split_length_omega">split_length_omega</code></td>
<td>
<p>either <code>25</code> or the default, <code>50</code>, the
length of pool at which splits are recorded.  Not all results are
internally consistent on this issue - some have races with splits by 50 and
other races with splits by 25.</p>
</td></tr>
<tr><td><code id="swim_parse_omega_+3A_relay_swimmers_omega">relay_swimmers_omega</code></td>
<td>
<p>should names of relay swimmers be captured?
Default is <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a data frame with columns <code>Name</code>, <code>Place</code>,
<code>Age</code>, <code>Team</code>, <code>Prelims</code>, <code>Finals</code>,
<code>Points</code>, <code>Event</code> &amp; <code>DQ</code>.  Note all swims will have a
<code>Finals</code>, even if that time was actually swam in the prelims
(i.e. a swimmer did not qualify for finals).  This is so that final results
for an event can be generated from just one column.
</p>


<h3>See Also</h3>

<p><code>swim_parse_omega</code> must be run on the output of
<code><a href="#topic+read_results">read_results</a></code>
</p>

<hr>
<h2 id='swim_parse_samms'>Formats swimming and diving data read with <code>read_results</code> into a
dataframe</h2><span id='topic+swim_parse_samms'></span>

<h3>Description</h3>

<p>Takes the output of <code>read_results</code> of S.A.M.M.S. results and cleans it,
yielding a dataframe of swimming (and diving) results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swim_parse_samms(
  file_samms,
  avoid_samms = avoid,
  typo_samms = typo,
  replacement_samms = replacement,
  format_samms = format_results
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="swim_parse_samms_+3A_file_samms">file_samms</code></td>
<td>
<p>output from <code>read_results</code> of S.A.M.M.S. style results</p>
</td></tr>
<tr><td><code id="swim_parse_samms_+3A_avoid_samms">avoid_samms</code></td>
<td>
<p>a list of strings.  Rows in <code>file</code> containing these
strings will not be included. For example &quot;Pool:&quot;, often used to label pool
records, could be passed to <code>avoid</code>.  The default is
<code>avoid_default</code>, which contains many strings similar to &quot;Pool:&quot;, such
as &quot;STATE:&quot; and &quot;Qual:&quot;.  Users can supply their own lists to <code>avoid</code>.</p>
</td></tr>
<tr><td><code id="swim_parse_samms_+3A_typo_samms">typo_samms</code></td>
<td>
<p>a list of strings that are typos in the original results.
<code>swim_parse</code> is particularly sensitive to accidental double spaces, so
&quot;Central  High School&quot;, with two spaces between &quot;Central&quot; and &quot;High&quot; is a
problem, which can be fixed.  Pass &quot;Central  High School&quot; to <code>typo</code>.
Unexpected commas as also an issue, for example &quot;Texas, University of&quot;
should be fixed using <code>typo</code> and <code>replacement</code></p>
</td></tr>
<tr><td><code id="swim_parse_samms_+3A_replacement_samms">replacement_samms</code></td>
<td>
<p>a list of fixes for the strings in <code>typo</code>.
Here one could pass &quot;Central High School&quot; (one space between &quot;Central&quot; and
&quot;High&quot;) and &quot;Texas&quot; to <code>replacement</code> fix the issues described in
<code>typo</code></p>
</td></tr>
<tr><td><code id="swim_parse_samms_+3A_format_samms">format_samms</code></td>
<td>
<p>should the data be formatted for analysis (special
strings like <code>"DQ"</code> replaced with <code>NA</code>, <code>Finals</code> as
definitive column)?  Default is <code>TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a data frame with columns <code>Name</code>, <code>Place</code>,
<code>Age</code>, <code>Team</code>, <code>Prelims</code>, <code>Finals</code>,
<code>Event</code> &amp; <code>DQ</code>.  Note all swims will have a <code>Finals</code>,
even if that time was actually swam in the prelims (i.e. a swimmer did not
qualify for finals).  This is so that final results for an event can be
generated from just one column.
</p>


<h3>See Also</h3>

<p><code>swim_parse</code> must be run on the output of
<code><a href="#topic+read_results">read_results</a></code>
</p>

<hr>
<h2 id='swim_parse_splash'>Formats Splash style swimming and diving data read with <code>read_results</code>
into a data frame</h2><span id='topic+swim_parse_splash'></span>

<h3>Description</h3>

<p>Takes the output of <code>read_results</code> and cleans it, yielding a data frame
of swimming (and diving) results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swim_parse_splash(
  file_splash,
  avoid_splash = avoid,
  typo_splash = typo,
  replacement_splash = replacement,
  format_results = TRUE,
  splits = FALSE,
  split_length_splash = split_length,
  relay_swimmers_splash = relay_swimmers
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="swim_parse_splash_+3A_file_splash">file_splash</code></td>
<td>
<p>output from <code>read_results</code></p>
</td></tr>
<tr><td><code id="swim_parse_splash_+3A_avoid_splash">avoid_splash</code></td>
<td>
<p>a list of strings.  Rows in <code>file_splash</code> containing
these strings will not be included. For example &quot;Pool:&quot;, often used to
label pool records, could be passed to <code>avoid_splash</code>.  The default is
<code>avoid_default</code>, which contains many strings similar to &quot;Pool:&quot;, such
as &quot;STATE:&quot; and &quot;Qual:&quot;.  Users can supply their own lists to
<code>avoid_splash</code>. <code>avoid_splash</code> is handled before <code>typo_splash</code>
and <code>replacement_splash</code>.</p>
</td></tr>
<tr><td><code id="swim_parse_splash_+3A_typo_splash">typo_splash</code></td>
<td>
<p>a list of strings that are typos in the original results.
<code>swim_parse</code> is particularly sensitive to accidental double spaces, so
&quot;Central  High School&quot;, with two spaces between &quot;Central&quot; and &quot;High&quot; is a
problem, which can be fixed.  Pass &quot;Central  High School&quot; to
<code>typo_splash</code>. Unexpected commas as also an issue, for example &quot;Texas,
University of&quot; should be fixed using <code>typo_splash</code> and
<code>replacement_splash</code></p>
</td></tr>
<tr><td><code id="swim_parse_splash_+3A_replacement_splash">replacement_splash</code></td>
<td>
<p>a list of fixes for the strings in
<code>typo_splash</code>.  Here one could pass &quot;Central High School&quot; (one space
between &quot;Central&quot; and &quot;High&quot;) and &quot;Texas&quot; to <code>replacement_splash</code> fix
the issues described in <code>typo_splash</code></p>
</td></tr>
<tr><td><code id="swim_parse_splash_+3A_format_results">format_results</code></td>
<td>
<p>should the results be formatted for analysis (special
strings like <code>"DQ"</code> replaced with <code>NA</code>, <code>Finals</code> as
definitive column)?  Default is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="swim_parse_splash_+3A_splits">splits</code></td>
<td>
<p>either <code>TRUE</code> or the default, <code>FALSE</code> - should
<code>swim_parse</code> attempt to include splits.</p>
</td></tr>
<tr><td><code id="swim_parse_splash_+3A_split_length_splash">split_length_splash</code></td>
<td>
<p>either <code>25</code> or the default, <code>50</code>, the
length of pool at which splits are recorded.  Not all results are
internally consistent on this issue - some have races with splits by 50 and
other races with splits by 25.</p>
</td></tr>
<tr><td><code id="swim_parse_splash_+3A_relay_swimmers_splash">relay_swimmers_splash</code></td>
<td>
<p>should names of relay swimmers be captured?
Default is <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a data frame with columns <code>Name</code>, <code>Place</code>,
<code>Age</code>, <code>Team</code>, <code>Prelims</code>, <code>Finals</code>,
<code>Points</code>, <code>Event</code> &amp; <code>DQ</code>.  Note all swims will have a
<code>Finals</code>, even if that time was actually swam in the prelims
(i.e. a swimmer did not qualify for finals).  This is so that final results
for an event can be generated from just one column.
</p>


<h3>See Also</h3>

<p><code>swim_parse_splash</code> must be run on the output of
<code><a href="#topic+read_results">read_results</a></code>
</p>

<hr>
<h2 id='swim_place'>Add places to swimming results</h2><span id='topic+swim_place'></span>

<h3>Description</h3>

<p>Places are awarded on the basis of time, with fastest (lowest) time winning.
Ties are placed as ties (both athletes get 2nd etc.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swim_place(
  df,
  time_col = Finals,
  max_place = NULL,
  event_type = "ind",
  max_relays_per_team = 1,
  keep_nonscoring = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="swim_place_+3A_df">df</code></td>
<td>
<p>a data frame with results from <code>swim_parse</code>, including only
swimming results (not diving)</p>
</td></tr>
<tr><td><code id="swim_place_+3A_time_col">time_col</code></td>
<td>
<p>the name of a column in <code>df</code> containing times on which
to place (order) performances.  Default is <code>Finals</code></p>
</td></tr>
<tr><td><code id="swim_place_+3A_max_place">max_place</code></td>
<td>
<p>highest place value that scores</p>
</td></tr>
<tr><td><code id="swim_place_+3A_event_type">event_type</code></td>
<td>
<p>either <code>"ind"</code> for individual or <code>"relay"</code> for
relays</p>
</td></tr>
<tr><td><code id="swim_place_+3A_max_relays_per_team">max_relays_per_team</code></td>
<td>
<p>an integer value denoting the number of relays a
team may score (usually 1)</p>
</td></tr>
<tr><td><code id="swim_place_+3A_keep_nonscoring">keep_nonscoring</code></td>
<td>
<p>are athletes in places greater than <code>max_place</code>
be retained in the data frame.  Either <code>TRUE</code> or <code>FALSE</code></p>
</td></tr>
<tr><td><code id="swim_place_+3A_verbose">verbose</code></td>
<td>
<p>should warning messages be posted.  Default is <code>TRUE</code> and
should rarely be changed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame modified so that places have been appended based on
swimming time
</p>


<h3>See Also</h3>

<p><code>swim_place</code> is a helper function used inside of
<code>results_score</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  df &lt;- data.frame(Place = c(1, 1, 1),
               Name = c("Sally Swimfast", "Bonnie Bubbles", "Kylie Kicker"),
               Team = c("KVAC", "UBAM", "MERC"),
               Event = rep("Women 200 Freestyle", 3),
               Prelims = c("2:00.00", "1:59.99", "2:01.50"),
               Finals = c("1:58.00", "1:59.50", "2:00.50"),
               Meet = c("Summer 2021", "Fall 2020", "Champs 2020"))

df %&gt;%
  swim_place()

df %&gt;%
  swim_place(time_col = Prelims)

df %&gt;%
  swim_place(time_col = "Prelims")

</code></pre>

<hr>
<h2 id='SwimmeR-defunct'>Defunct functions in SwimmeR</h2><span id='topic+SwimmeR-defunct'></span>

<h3>Description</h3>

<p>These functions have been made defunct (removed) from <code>SwimmeR</code>.
</p>


<h3>Details</h3>

 <ul>
<li> <p><code><a href="#topic+course_convert_DF">course_convert_DF</a></code>: This function is defunct,
and has been removed from <code>SwimmeR</code>.  Instead
please use <code>course_convert(verbose = TRUE)</code> </p>
</li></ul>


<hr>
<h2 id='SwimmeR-deprecated'>Deprecated functions in SwimmeR</h2><span id='topic+SwimmeR-deprecated'></span>

<h3>Description</h3>

<p>These functions still work but will be removed (defunct) in upcoming versions.
</p>

<hr>
<h2 id='tie_rescore'>Rescore to account for ties</h2><span id='topic+tie_rescore'></span>

<h3>Description</h3>

<p>Rescoring to average point values for ties.  Ties are placed as ties (both
athletes get 2nd etc.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tie_rescore(df, point_values, lanes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tie_rescore_+3A_df">df</code></td>
<td>
<p>a data frame with results from <code>swim_parse</code>, with places from
<code>swim_place</code> and/or <code>dive_place</code></p>
</td></tr>
<tr><td><code id="tie_rescore_+3A_point_values">point_values</code></td>
<td>
<p>a named list of point values for each scoring place</p>
</td></tr>
<tr><td><code id="tie_rescore_+3A_lanes">lanes</code></td>
<td>
<p>number of scoring lanes in the pool</p>
</td></tr>
</table>


<h3>Value</h3>

<p>df modified so that places have been appended based on swimming time
</p>


<h3>See Also</h3>

<p><code>tie_rescore</code> is a helper function used inside of
<code>results_score</code>
</p>

<hr>
<h2 id='toptimes_parse_hytek'>Formats Hytek style swimming and diving Top Times reports read with
<code>read_results</code> into a data frame</h2><span id='topic+toptimes_parse_hytek'></span>

<h3>Description</h3>

<p>Takes the output of <code>read_results</code> and cleans it, yielding a data frame
of swimming (and diving) top times
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toptimes_parse_hytek(
  file_hytek_toptimes,
  avoid_hytek_toptimes = avoid,
  typo_hytek_toptimes = typo,
  replacement_hytek_toptimes = replacement
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="toptimes_parse_hytek_+3A_file_hytek_toptimes">file_hytek_toptimes</code></td>
<td>
<p>output from <code>read_results</code></p>
</td></tr>
<tr><td><code id="toptimes_parse_hytek_+3A_avoid_hytek_toptimes">avoid_hytek_toptimes</code></td>
<td>
<p>a list of strings.  Rows in
<code>file_hytek_toptimes</code> containing these strings will not be included.
For example &quot;Pool:&quot;, often used to label pool records, could be passed to
<code>avoid_hytek_toptimes</code>.  The default is <code>avoid_default</code>, which
contains many strings similar to &quot;Pool:&quot;, such as &quot;STATE:&quot; and &quot;Qual:&quot;.
Users can supply their own lists to <code>avoid_hytek_toptimes</code>.
<code>avoid_hytek_toptimes</code> is handled before <code>typo_hytek_toptimes</code>
and <code>replacement_hytek_toptimes</code>.</p>
</td></tr>
<tr><td><code id="toptimes_parse_hytek_+3A_typo_hytek_toptimes">typo_hytek_toptimes</code></td>
<td>
<p>a list of strings that are typos in the original
results. <code>swim_parse</code> is particularly sensitive to accidental double
spaces, so &quot;Central  High School&quot;, with two spaces between &quot;Central&quot; and
&quot;High&quot; is a problem, which can be fixed.  Pass &quot;Central  High School&quot; to
<code>typo_hytek_toptimes</code>. Unexpected commas as also an issue, for example
&quot;Texas, University of&quot; should be fixed using <code>typo_hytek_toptimes</code> and
<code>replacement_hytek_toptimes</code></p>
</td></tr>
<tr><td><code id="toptimes_parse_hytek_+3A_replacement_hytek_toptimes">replacement_hytek_toptimes</code></td>
<td>
<p>a list of fixes for the strings in
<code>typo_hytek</code>.  Here one could pass &quot;Central High School&quot; (one space
between &quot;Central&quot; and &quot;High&quot;) and &quot;Texas&quot; to
<code>replacement_hytek_toptimes</code> fix the issues described in
<code>typo_hytek_toptimes</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a data frame with columns <code>Rank</code>, <code>Result</code>,
<code>Name</code>, <code>Age</code>, <code>Date</code> <code>Meet</code> &amp; <code>Event</code>.  Top Times
reports do not designate Team.
</p>


<h3>See Also</h3>

<p><code>toptimes_parse_hytek</code> must be run on the output of
<code><a href="#topic+read_results">read_results</a></code>
</p>

<hr>
<h2 id='undo_interleave'>Undoes interleaving of lists</h2><span id='topic+undo_interleave'></span>

<h3>Description</h3>

<p>If two lists have been interleaved this function will return the lists
separated and then concatenated
</p>


<h3>Usage</h3>

<pre><code class='language-R'>undo_interleave(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="undo_interleave_+3A_x">x</code></td>
<td>
<p>a list to be un-interleaved</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list comprising the interleaved components of <code>x</code> joined into
one list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>l &lt;- c("A", "D", "B", "E", "C", "F")
undo_interleave(l)
</code></pre>

<hr>
<h2 id='update_rank_helper'>Create a one-line data frame containing an entry to be appended to an
in-progress data frame of all entries</h2><span id='topic+update_rank_helper'></span>

<h3>Description</h3>

<p>Create a one-line data frame containing an entry to be appended to an
in-progress data frame of all entries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_rank_helper(
  rank_helper_2,
  e_rank_helper_2,
  k,
  e_helper,
  events_remaining_helper
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_rank_helper_+3A_rank_helper_2">rank_helper_2</code></td>
<td>
<p>a  master data frame of athlete ranks by event</p>
</td></tr>
<tr><td><code id="update_rank_helper_+3A_e_rank_helper_2">e_rank_helper_2</code></td>
<td>
<p>a data frame of candidate athlete entries to add to a
given event</p>
</td></tr>
<tr><td><code id="update_rank_helper_+3A_k">k</code></td>
<td>
<p>an integer denoting which element of e_rank_helper is under
evaluation for addition.  Should be 1, 2, 3 or 4 depending on the minimum
number of entries</p>
</td></tr>
<tr><td><code id="update_rank_helper_+3A_e_helper">e_helper</code></td>
<td>
<p>the event for which entries are being evaluated</p>
</td></tr>
<tr><td><code id="update_rank_helper_+3A_events_remaining_helper">events_remaining_helper</code></td>
<td>
<p>a data frame with two columns, <code>Name</code> and
<code>Events_Remaining</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a one row data frame containing an improved entry
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
