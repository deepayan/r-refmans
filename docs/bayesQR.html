<!DOCTYPE html><html><head><title>Help for package bayesQR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bayesQR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bayesQR'><p> Bayesian quantile regression</p></a></li>
<li><a href='#Churn'><p>Customer Churn Data</p></a></li>
<li><a href='#plot.bayesQR'><p> Produce quantile plots or traceplots with <code>plot.bayesQR</code></p></a></li>
<li><a href='#predict.bayesQR'><p> Calculate predicted probabilities for binary quantile regression</p></a></li>
<li><a href='#print.bayesQR'><p> Prints the contents of <code>bayesQR</code> object to the console</p></a></li>
<li><a href='#print.bayesQR.summary'><p> Prints the contents of <code>bayesQR.summary</code> object to the console</p></a></li>
<li><a href='#prior'><p> Create prior for Bayesian quantile regression</p></a></li>
<li><a href='#Prostate'><p>Prostate Cancer Data</p></a></li>
<li><a href='#summary.bayesQR'><p> Summarize the output of the <code>bayesQR</code> function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-08</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Quantile Regression</td>
</tr>
<tr>
<td>Author:</td>
<td>Dries F. Benoit, Rahim Al-Hamzawi, Keming Yu, Dirk Van den Poel</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dries F. Benoit &lt;Dries.Benoit@UGent.be&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2), graphics, methods, stats, utils</td>
</tr>
<tr>
<td>Description:</td>
<td>Bayesian quantile regression using the asymmetric Laplace distribution, both continuous as well as binary dependent variables are supported. The package consists of implementations of the methods of Yu &amp; Moyeed (2001) &lt;<a href="https://doi.org/10.1016%2FS0167-7152%2801%2900124-9">doi:10.1016/S0167-7152(01)00124-9</a>&gt;, Benoit &amp; Van den Poel (2012) &lt;<a href="https://doi.org/10.1002%2Fjae.1216">doi:10.1002/jae.1216</a>&gt; and Al-Hamzawi, Yu &amp; Benoit (2012) &lt;<a href="https://doi.org/10.1177%2F1471082X1101200304">doi:10.1177/1471082X1101200304</a>&gt;. To speed up the calculations, the Markov Chain Monte Carlo core of all algorithms is programmed in Fortran and called from R.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-08 17:13:35 UTC; dfbenoit</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-08 17:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bayesQR'> Bayesian quantile regression </h2><span id='topic+bayesQR'></span>

<h3>Description</h3>

<p><code>bayesQR</code> implements a Bayesian method for estimating quantile regression  models (see references).
To improve the speed of the routine, the Markov Chain Monte Carlo (MCMC) part of the algorithm is programmed in Fortran and is called from within the R function <code>bayesQR</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  bayesQR(formula, data, quantile, alasso, normal.approx, ndraw, keep, prior)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bayesQR_+3A_formula">formula</code></td>
<td>
<p> a symbolic description of the model to be fit. </p>
</td></tr>
<tr><td><code id="bayesQR_+3A_data">data</code></td>
<td>
<p> an optional data frame containing the variables in the model. </p>
</td></tr>
<tr><td><code id="bayesQR_+3A_quantile">quantile</code></td>
<td>
<p> numerical scalar or vector containing quantile(s) of interest (default=0.5). </p>
</td></tr>
<tr><td><code id="bayesQR_+3A_alasso">alasso</code></td>
<td>
<p> logical flag for adaptive lasso variable selection (default=FALSE). </p>
</td></tr>
<tr><td><code id="bayesQR_+3A_normal.approx">normal.approx</code></td>
<td>
<p> logical flag for normal approximation of posterior distribution (default=TRUE). </p>
</td></tr>
<tr><td><code id="bayesQR_+3A_ndraw">ndraw</code></td>
<td>
<p> number of MCMC draws. </p>
</td></tr>
<tr><td><code id="bayesQR_+3A_keep">keep</code></td>
<td>
<p> thinning parameter, i.e. keep every keepth draw (default=1). </p>
</td></tr>
<tr><td><code id="bayesQR_+3A_prior">prior</code></td>
<td>
<p> an S3 object of class <code>"prior"</code>. If omitted, a diffuse prior will be assumed (see <code><a href="#topic+prior">prior</a></code>). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>bayesQR</code> can estimate four types of models, depending on whether the dependent variable is continuous or binary and whether adaptive lasso variable selection is used.
</p>

<ul>
<li><p> Continuous dependent variable without adaptive lasso variable selection:
</p>

<table>
<tr>
 <td style="text-align: left;">
    Model:  </td><td style="text-align: left;"> y = X<em>beta</em> + e </td>
</tr>
<tr>
 <td style="text-align: left;">
            </td><td style="text-align: left;"> <em>e ~ ALD(location=0, scale=sigma, quantile=p)</em> </td>
</tr>
<tr>
 <td style="text-align: left;">
    Priors: </td><td style="text-align: left;"> <em>beta ~ N(beta0, V0)</em> </td>
</tr>
<tr>
 <td style="text-align: left;">
            </td><td style="text-align: left;"> <em>sigma ~ invGamma(shape0,scale0)</em> </td>
</tr>
<tr>
 <td style="text-align: left;">
  	</td>
</tr>

</table>

</li>
<li><p> Continuous dependent variable with adaptive lasso variable selection:
</p>

<table>
<tr>
 <td style="text-align: left;">
    Model:  </td><td style="text-align: left;"> y = X<em>beta</em> + e </td>
</tr>
<tr>
 <td style="text-align: left;">
            </td><td style="text-align: left;"> <em>e ~ ALD(location=0, scale=sigma, quantile=p)</em> </td>
</tr>
<tr>
 <td style="text-align: left;">
    Priors: </td><td style="text-align: left;"> <em>beta ~ ALD(location=0, scale=sigma/lambda, p=0.5)</em> </td>
</tr>
<tr>
 <td style="text-align: left;">
            </td><td style="text-align: left;"> <em>sigma ~ InvGamma(shape=sigma_shape, scale=sigma_scale)</em> </td>
</tr>
<tr>
 <td style="text-align: left;">
            </td><td style="text-align: left;"> <em>(lambda/sigma)^2 ~ Gamma(shape=etasq_shape, scale=etasq_scale)</em> </td>
</tr>
<tr>
 <td style="text-align: left;">
  	</td>
</tr>

</table>

</li>
<li><p> Binary dependent variable without adaptive lasso variable selection:
</p>

<table>
<tr>
 <td style="text-align: left;">
    Model:  </td><td style="text-align: left;"> y* = X<em>beta</em> + e </td>
</tr>
<tr>
 <td style="text-align: left;">
            </td><td style="text-align: left;"> <em>e ~ ALD(location=0, scale=1, quantile=p)</em> </td>
</tr>
<tr>
 <td style="text-align: left;">
            </td><td style="text-align: left;"> <em>y = 1, if (y* &gt; 0); y = 0, otherwise</em> </td>
</tr>
<tr>
 <td style="text-align: left;">
    Priors: </td><td style="text-align: left;"> <em>beta ~ N(beta0, V0)</em> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td>
</tr>

</table>

</li>
<li><p> Binary dependent variable with adaptive lasso variable selection:
</p>

<table>
<tr>
 <td style="text-align: left;">
    Model:  </td><td style="text-align: left;"> y* = X<em>beta</em> + e </td>
</tr>
<tr>
 <td style="text-align: left;">
            </td><td style="text-align: left;"> <em>e ~ ALD(location=0, scale=1, quantile=p)</em> </td>
</tr>
<tr>
 <td style="text-align: left;">
            </td><td style="text-align: left;"> <em>y = 1, if (y* &gt; 0); y = 0, otherwise</em> </td>
</tr>
<tr>
 <td style="text-align: left;">
    Priors: </td><td style="text-align: left;"> <em>beta ~ ALD(location=0, scale=1/lambda, p=0.5)</em> </td>
</tr>
<tr>
 <td style="text-align: left;">
            </td><td style="text-align: left;"> <em>lambda^2 ~ Gamma(shape=lambdasq_shape, scale=lambdasq_scale)</em> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td>
</tr>

</table>

</li></ul>



<h3>Value</h3>

<p>An object of class <code>bayesQR</code>, basically a list of lists.
For every estimated quantile a list is created containing the following elements:
</p>
<table>
<tr><td><code>method</code></td>
<td>
<p> a string containing the method that was used, i.e. indicating whether the dependent variable was continuous or binary and whether adaptive lasso variable selection was used. </p>
</td></tr>
<tr><td><code>normal.approx</code></td>
<td>
<p> logical flag for normal approximation of posterior distribution. </p>
</td></tr>
<tr><td><code>quantile</code></td>
<td>
<p> the quantile that was estimated. </p>
</td></tr>
<tr><td><code>names</code></td>
<td>
<p> character vector containing the names of the independent variables in the model. </p>
</td></tr>
<tr><td><code>betadraw</code></td>
<td>
<p> ndraw/keep x nvar(X) matrix of beta draws. </p>
</td></tr>
<tr><td><code>sigmadraw</code></td>
<td>
<p> ndraw/keep vector of sigma draws (only in case of continuous dependent variable). </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dries F. Benoit, Rahim Al-Hamzawi, Keming Yu and Dirk Van den Poel
</p>


<h3>References</h3>

  
<ul>
<li><p> Paper about the bayesQR package:
</p>
<p>Benoit, D.F and Van den Poel, D. (2017). bayesQR: A Bayesian Approach to Quantile Regression, <em>Journal of Statistical Software</em>, 76(7), 1-32. &lt;doi:10.18637/jss.v076.i07&gt;<br />
</p>
</li>
<li><p> Continuous dependent variable without adaptive lasso variable selection:
</p>
<p>Yu, K. and Moyeed, R. (2001). Bayesian quantile regression, <em>Statistics and Probability Letters</em>, 54, 437-447. &lt;doi:10.1016/S0167-7152(01)00124-9&gt;
</p>
<p>Also see: <br />
Kozumi, H. and Kobayashi, G. (2011). Gibbs sampling methods for Bayesian quantile regression, <em>Journal of Statistical Computation and Simulation</em>, 81(11), 1565-1578. &lt;doi:10.1080/00949655.2010.496117&gt;<br />
</p>
</li>
<li><p> Continuous dependent variable with adaptive lasso variable selection:
</p>
<p>Alhamzawi, R., Yu, K. and Benoit, D.F. (2012). Bayesian adaptive LASSO quantile regression, <em>Statistical Modelling</em>, 12(3), 279-297. &lt;doi:10.1177/1471082X1101200304&gt;
</p>
<p>Also see: <br />
Li, Q., Xi, R. and Lin, N. (2010). Bayesian Regularized Quantile Regression. <em>Bayesian Analysis</em>, 5, 1-24. &lt;doi:10.1214/10-BA521&gt;<br />
</p>
</li>
<li><p> Binary dependent variable without adaptive lasso variable selection:
</p>
<p>Benoit, D.F. and Van den Poel, D. (2012). Binary quantile regression: A Bayesian approach based on the asymmetric Laplace distribution, <em>Journal of Applied Econometrics</em>, 27(7), 1174-1188. &lt;doi:10.1002/jae.1216&gt;<br />
</p>
</li>
<li><p> Binary dependent variable with adaptive lasso variable selection:
</p>
<p>Al-Hamzawi, R., Benoit, D.F. and Yu, K. (2012). Bayesian lasso binary quantile regression. <em>Computational Statistics</em>, 28(6), 2861-2873. &lt;doi:10.1007/s00180-013-0439-0&gt;
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Simulate data from heteroskedastic regression
set.seed(66)
n &lt;- 200
X &lt;- runif(n=n,min=0,max=10)
X &lt;- X
y &lt;- 1 + 2*X + rnorm(n=n, mean=0, sd=.6*X)

# Estimate series of quantile regressions with adaptive lasso
# NOTE: to limit execution time of the example, ndraw is set
#       to a very low value. Set value to 5000 for a better
#       approximation of the posterior distirubtion.
out &lt;- bayesQR(y~X, quantile=c(.05,.25,.5,.75,.95), alasso=TRUE, ndraw=500)

# Initiate plot
## Plot datapoints
plot(X, y, main="", cex=.6, xlab="X")

## Add quantile regression lines to the plot (exclude first 500 burn-in draws)
sum &lt;- summary(out, burnin=50)
for (i in 1:length(sum)){
  abline(a=sum[[i]]$betadraw[1,1],b=sum[[i]]$betadraw[2,1],lty=i,col=i)
}

# Estimate and plot OLS model
outOLS = lm(y~X)
abline(outOLS,lty=1,lwd=2,col=6)

# Add legend to plot
legend(x=0,y=max(y),legend=c(.05,.25,.50,.75,.95,"OLS"),lty=c(1,2,3,4,5,1),
       lwd=c(1,1,1,1,1,2),col=c(1:6),title="Quantile")
</code></pre>

<hr>
<h2 id='Churn'>Customer Churn Data</h2><span id='topic+Churn'></span>

<h3>Description</h3>

<p>This dataset is a stratified random sample from all active customers (at the end of June 2006) of a European financial services company. The dependent variable in this dataset is the churn behavior of the customers in the period from July 1st until December 31th 2006. Here a churned customer is defined as someone who closed all his/her bank accounts with the company. Note that all predictor variables are standardized. This dataset is a small subset of the dataset used in Benoit and Van den Poel (2013). The dataset is structured as a dataframe with 400 observations and 5 variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Churn")</code></pre>


<h3>Format</h3>

<p>The data frame has the following components:
</p>

<ul>
<li> <p><b>churn</b> : churn (yes/no) 
</p>
</li>
<li> <p><b>gender</b> : gender of the customer (male = 1) 
</p>
</li>
<li> <p><b>Social_Class_Score</b> : social class of the customer 
</p>
</li>
<li> <p><b>lor</b> : length of relationship with the customer 
</p>
</li>
<li> <p><b>recency</b> : number of days since last purchase 
</p>
</li></ul>



<h3>Source</h3>

<p>Benoit, D.F. and Van den Poel, D. (2013). Quantile regression for database marketing: methods and applications. In: Coussement, K., De Bock, K.W. and Neslin, S.A. (eds.). <em>Advanced database marketing: Innovative methodologies and applications for managing customer relationships</em>. Gower Publishing: London (UK). &lt;doi:10.4324/9781315565682&gt;
</p>


<h3>References</h3>

<p>Benoit, D.F. and Van den Poel, D. (2013). Quantile regression for database marketing: methods and applications. In: Coussement, K., De Bock, K.W. and Neslin, S.A. (eds.). <em>Advanced database marketing: Innovative methodologies and applications for managing customer relationships</em>. Gower Publishing: London (UK). &lt;doi:10.4324/9781315565682&gt;
</p>
<p>Benoit, D.F and Van den Poel, D. (2017). bayesQR: A Bayesian Approach to Quantile Regression, <em>Journal of Statistical Software</em>, 76(7), 1-32. &lt;doi:10.18637/jss.v076.i07&gt;
</p>

<hr>
<h2 id='plot.bayesQR'> Produce quantile plots or traceplots with <code>plot.bayesQR</code> </h2><span id='topic+plot.bayesQR'></span>

<h3>Description</h3>

<p><code>plot.bayesQR</code> is an S3 method that produces quantile plots, traceplots or posterior histograms based on the estimates obtained by the <code>bayesQR</code> function. 
For quantile plots, note that the more quantiles are estimated with <code>bayesQR</code>, the more detailed the quantile plot will be.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'bayesQR'
plot(x, var=NULL, quantile=NULL, burnin=0, credint=c(0.025,0.975), plottype=NULL, 
main=NULL, xlab=NULL, ylab=NULL, xlim=NULL, ylim=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bayesQR_+3A_x">x</code></td>
<td>
<p> an output object of the <code>bayesQR</code> function, i.e. an S3 object of class bayesQR. </p>
</td></tr>
<tr><td><code id="plot.bayesQR_+3A_var">var</code></td>
<td>
<p> vector containing the index or name of the variable(s) that has to be plotted (default=all variables). </p>
</td></tr>
<tr><td><code id="plot.bayesQR_+3A_quantile">quantile</code></td>
<td>
<p> vector containing the quantile(s) that has to be plotted (default=all quantiles). </p>
</td></tr>
<tr><td><code id="plot.bayesQR_+3A_burnin">burnin</code></td>
<td>
<p> the number of burnin draws that should be discared (default=0, meaning all draws are included). </p>
</td></tr>
<tr><td><code id="plot.bayesQR_+3A_credint">credint</code></td>
<td>
<p> the width of the credible interval (default=c(0.025, 0.975)). </p>
</td></tr>
<tr><td><code id="plot.bayesQR_+3A_plottype">plottype</code></td>
<td>
<p> should be &lsquo;quantile&rsquo;, &lsquo;trace&rsquo; or &lsquo;hist&rsquo;. </p>
</td></tr>
<tr><td><code id="plot.bayesQR_+3A_main">main</code></td>
<td>
<p> Main title of the plot (default=&quot;&quot;).  </p>
</td></tr>
<tr><td><code id="plot.bayesQR_+3A_xlab">xlab</code></td>
<td>
<p> Label of the x-axis; if omitted, the value chosen based on the input data. </p>
</td></tr>
<tr><td><code id="plot.bayesQR_+3A_ylab">ylab</code></td>
<td>
<p> Label of the y-axis; if omitted, the value chosen based on the input data. </p>
</td></tr>
<tr><td><code id="plot.bayesQR_+3A_xlim">xlim</code></td>
<td>
<p> Plot region of the x-axis; if omitted, the value chosen based on the input data. </p>
</td></tr>
<tr><td><code id="plot.bayesQR_+3A_ylim">ylim</code></td>
<td>
<p> Plot region of the y-axis; if omitted, the value chosen based on the input data. </p>
</td></tr>
<tr><td><code id="plot.bayesQR_+3A_...">...</code></td>
<td>
<p> additional arguments that are passed to the generic <code>plot</code> function </p>
</td></tr>
</table>


<h3>Details</h3>

<p>A quantile plot shows how the value of the regression parameter changes over a range of quantiles together with the associated credible interval.
When the normal approximation was requested, the credible regions represent the adjusted credible intervals.
Note that the more quantiles are estimated, the more detailed the quantile plot will be.
The minimum number of quantiles to plot is 2.
A posterior histogram provides a graphical representation of the marginal posterior distribution of the regression parameters.
When the normal approximation was requested, the histogram will be overlaid with the adjusted credible intervals.
A traceplot gives the evolution of the MCMC chain and can be used as graphical check of convergence.
Note that more formal checks of convergence exist (see, for example, the <span class="pkg">coda</span> package).
</p>


<h3>Value</h3>

<p>A (series of) quantile plot(s) or a (series of) traceplot(s). 
</p>


<h3>Author(s)</h3>

<p>Dries F. Benoit
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate data from heteroskedastic regression
set.seed(66)
n &lt;- 200
X &lt;- runif(n=n,min=0,max=10)
X &lt;- X
y &lt;- 1 + 2*X + rnorm(n=n, mean=0, sd=.6*X)

# Analyze 5 quantiles using default prior
# NOTE: to limit execution time of the example, ndraw is set
#       to a very low value. Set value to 5000 for a better
#       approximation of the posterior distirubtion.
out &lt;- bayesQR(y ~ X, quantile=c(.05,.25,.5,.75,.95), ndraw=500)

# Check traceplot of first variable of .75 quantile regression 
plot(out, var=1, quantile=.75, plottype="trace")

# Check posterior histogram of first variable of .5 quantile regression 
plot(out, var=1, quantile=.5, plottype="hist")

# Create default quantile plot of first variable
plot(out, var=1, plottype="quantile")

# Create quantile plot of second variable with 90% credible interval
plot(out, var="X", credint=c(.05, .95), plottype="quantile", main="This is an example")
</code></pre>

<hr>
<h2 id='predict.bayesQR'> Calculate predicted probabilities for binary quantile regression </h2><span id='topic+predict.bayesQR'></span>

<h3>Description</h3>

<p><code>predict.bayesQR</code> is an S3 method that calculates predicted probabilities for binary quantile regression, both with or without adaptive lasso.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'bayesQR'
predict(object, X, burnin=0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.bayesQR_+3A_object">object</code></td>
<td>
<p> an output object of the <code>bayesQR</code> function, S3 class bayesQR, with binary dependent variable, with or without adaptive lasso. At leas 9 estimated quantiles are required. </p>
</td></tr>
<tr><td><code id="predict.bayesQR_+3A_x">X</code></td>
<td>
<p> matrix of predictors (should be of the same type as the variables used to estimate the model). </p>
</td></tr>
<tr><td><code id="predict.bayesQR_+3A_burnin">burnin</code></td>
<td>
<p> the number of burnin draws that should be discared (default=0, meaning all draws are included). </p>
</td></tr>
<tr><td><code id="predict.bayesQR_+3A_...">...</code></td>
<td>
<p> additional parameters passed to the generic <code>predict</code> function. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>predict.bayesQR</code> is an S3 method that calculates the predicted probabilities based on a matrix of predictors <em>X</em> and an object containing the parameter estimates of a sequence of binary quantile regressions.
The rationale behind the approach is described in Kordas (2006) and applied in Migueis, V.L., Benoit, D.F. and Van den Poel, D. (2012).
Note that the more quantiles are estimated, the more fine-grained the predicted probabilities will be. 
</p>


<h3>Value</h3>

<p>A vector containing the predicted probabilities.
</p>


<h3>Author(s)</h3>

<p>Dries F. Benoit
</p>


<h3>References</h3>

<p>Kordas, G. (2006). Binary regression quantiles, <em>Journal of Applied Econometrics</em>, <b>21</b>(3), 387-407.
<br />
<br />
Migueis, V.L., Benoit, D.F. and Van den Poel, D. (2012). Enhanced decision support in credit scoring using Bayesian binary quantile regression, <em>Journal of the Operational Research Society</em>, (<em>in press</em>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate data from binary regression model
set.seed(1234)
n &lt;- 200
X &lt;- matrix(runif(n=n*2, min=-5, max=5),ncol=2)
ystar &lt;- cbind(1,X)%*% c(1,1.5,-.5) + rnorm(n=n, mean=0, sd=abs(2*X[,1]))
y &lt;- as.numeric(ystar&gt;0)

# Estimate a sequence of binary quantile regression models
# NOTE: to limit execution time of the example, ndraw is set
#       to a very low value. Set value to 4000 for a better
#       approximation of the posterior distirubtion.
out &lt;- bayesQR(y ~ X, quantile=seq(.1,.9,.1), ndraw=400)

# Calculate predicted probabilities
pred &lt;- predict(object=out, X=cbind(1,X), burnin=20)

# Make histogram of predicted probabilities 
hist(pred,breaks=10)

# Calculate Percentage Correclty Classified (PCC)
mean(y==as.numeric(pred&gt;.5))

# Compare with logit model
mylogit &lt;- glm(y ~ X, family=binomial(logit))

# Make histogram of predicted probabilities 
hist(mylogit$fit,breaks=10)

# Calculate Percentage Correclty Classified (PCC)
mean(y==as.numeric(mylogit$fit&gt;.5))
</code></pre>

<hr>
<h2 id='print.bayesQR'> Prints the contents of <code>bayesQR</code> object to the console </h2><span id='topic+print.bayesQR'></span>

<h3>Description</h3>

<p><code>print.bayesQR</code> is an S3 method that prints the content of an S3 object of class <code>bayesQR</code> to the console. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'bayesQR'
print(x, digits=3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.bayesQR_+3A_x">x</code></td>
<td>
<p> an output object of the <code>bayesQR</code> function, i.e. an S3 object of class <code>bayesQR</code>. </p>
</td></tr>
<tr><td><code id="print.bayesQR_+3A_digits">digits</code></td>
<td>
<p> the number of printed digits of the estimates (default=3). </p>
</td></tr>
<tr><td><code id="print.bayesQR_+3A_...">...</code></td>
<td>
<p> additional arguments that are passed to the generic <code>print</code> function </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Formatted output of a <code>bayesQR</code> object.
</p>


<h3>Author(s)</h3>

<p>Dries F. Benoit
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate data from heteroskedastic regression
set.seed(666)
n &lt;- 200
X &lt;- runif(n=n,min=0,max=10)
y &lt;- 1 + 2*X + rnorm(n=n, mean=0, sd=.6*X)

# Analyze 0.5 quantile using default prior
out &lt;- bayesQR(y ~ X, ndraw=5000) 

# Print the bayesQR object
print(out)
</code></pre>

<hr>
<h2 id='print.bayesQR.summary'> Prints the contents of <code>bayesQR.summary</code> object to the console </h2><span id='topic+print.bayesQR.summary'></span>

<h3>Description</h3>

<p><code>print.bayesQR.summary</code> is an S3 method that prints the content of an S3 object of class <code>bayesQR.summary</code> to the console. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'bayesQR.summary'
print(x, digits=3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.bayesQR.summary_+3A_x">x</code></td>
<td>
<p> an output object of the <code>summary.bayesQR</code> function, i.e. an S3 object of class <code>bayesQR.summary</code>. </p>
</td></tr>
<tr><td><code id="print.bayesQR.summary_+3A_digits">digits</code></td>
<td>
<p> the number of printed digits of the estimates (default=3). </p>
</td></tr>
<tr><td><code id="print.bayesQR.summary_+3A_...">...</code></td>
<td>
<p> additional arguments that are passed to the generic <code>print</code> function </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Formatted output of a <code>bayesQR.summary</code> object.
</p>


<h3>Author(s)</h3>

<p>Dries F. Benoit
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate data from heteroskedastic regression
set.seed(666)
n &lt;- 200
X &lt;- runif(n=n,min=0,max=10)
y &lt;- 1 + 2*X + rnorm(n=n, mean=0, sd=.6*X)

# Analyze 0.5 quantile using default prior and adaptive lasso
out &lt;- bayesQR(y ~ X, alasso=TRUE, ndraw=5000) 

# Return Bayes estimates and credible intervals 
sum &lt;- summary(out, burnin=1000)

# Print the bayesQR.summary object
sum
</code></pre>

<hr>
<h2 id='prior'> Create prior for Bayesian quantile regression </h2><span id='topic+prior'></span>

<h3>Description</h3>

<p><code>prior</code> creates an S3 object of class <code>bayesQR.prior</code> that contains all necessary prior information to estimate a Bayesian quantile regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  prior(formula, data, alasso, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prior_+3A_formula">formula</code></td>
<td>
<p> a symbolic description of the model to be fit. </p>
</td></tr>
<tr><td><code id="prior_+3A_data">data</code></td>
<td>
<p> an optional data frame containing the variables in the model. </p>
</td></tr>
<tr><td><code id="prior_+3A_alasso">alasso</code></td>
<td>
<p> logical flag for adaptive lasso variable selection (default=FALSE). </p>
</td></tr>
<tr><td><code id="prior_+3A_...">...</code></td>
<td>
<p> the prior parameters that are dependent on the method that is used. If omitted, a standard diffuse prior will be used (see details section). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>prior</code> builds the prior for four types of models, depending on whether the dependent variable is continuous or binary and whether adaptive lasso variable selection is used. 
Every non-specified prior parameter will get the default value.
</p>
<p>Continuous dependent variable without adaptive lasso variable selection:
</p>

<ul>
<li> <p><b>beta0</b> : nvar(X) x 1 vector of prior means (default: 0)
</p>
</li>
<li> <p><b>V0</b> : nvar(X) x nvar(X) prior covariance matrix (default: 100*diag(ncol(X)))
</p>
</li>
<li> <p><b>shape0</b> : shape parameter for inverse Gamma prior for sigma (default: 0.01)
</p>
</li>
<li> <p><b>scale0</b> : scale parameter for inverse Gamma prior for sigma (default: 0.01)
</p>
</li></ul>

<p>Continuous dependent variable with adaptive lasso variable selection:
</p>

<ul>
<li> <p><b>sigma_shape</b> : shape parameter for the inverse gamma prior on sigma (default: 0.01)
</p>
</li>
<li> <p><b>sigma_scale</b> : scale parameter for the inverse gamma prior on sigma (default: 0.01)
</p>
</li>
<li> <p><b>etasq_shape</b> : shape parameter for the gamma prior on etasq (default: 0.01)
</p>
</li>
<li> <p><b>etasq_scale</b> : scale parameter for the gamma prior on etasq (default: 0.01)
</p>
</li></ul>

<p>Binary dependent variable without adaptive lasso variable selection:
</p>

<ul>
<li> <p><b>beta0</b> : nvar(X) x 1 vector of prior means (default: 0)
</p>
</li>
<li> <p><b>V0</b> : nvar(X) x nvar(X) prior covariance matrix (default: 100*diag(ncol(X)))
</p>
</li></ul>

<p>Binary dependent variable with adaptive lasso variable selection:
</p>

<ul>
<li> <p><b>lambdasq_shape</b> : shape parameter for the gamma prior on lambdasq (default: 0.01)
</p>
</li>
<li> <p><b>lambdasq_scale</b> : scale parameter for the gamma prior on lambdasq (default: 0.01)
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code>bayesQR</code>, basically a list containing the following elements:
</p>
<table>
<tr><td><code>method</code></td>
<td>
<p> a string containing the method that was used, i.e. indicating whether the dependent variable was continuous or binary and whether adaptive lasso variable selection was used. </p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p> the prior parameters that are dependent on the method that is used (see details section). </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dries F. Benoit
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the Prostate cancer dataset
data(Prostate)

# Create informative prior object
prior &lt;- prior(lpsa~., data=Prostate, beta0=rep(5,9), V0=diag(9)) 

# Investigate structure of bayesQR.prior object
str(prior)

# Estimate the model parameters with informative prior
out &lt;- bayesQR(lpsa~., data=Prostate, prior=prior, ndraw=5000)

# Print results
summary(out)
</code></pre>

<hr>
<h2 id='Prostate'>Prostate Cancer Data</h2><span id='topic+Prostate'></span>

<h3>Description</h3>

<p>These data come from a study that examined the correlation between the
level of prostate specific antigen and a number of clinical measures
in men who were about to receive a radical prostatectomy.  It is a data
frame with 97 rows and 9 columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Prostate")</code></pre>


<h3>Format</h3>

<p>The data frame has the following components:
</p>

<ul>
<li> <p><b>lcavol</b> : log(cancer volume)
</p>
</li>
<li> <p><b>lweight</b> : log(prostate weight)
</p>
</li>
<li> <p><b>age</b> : age
</p>
</li>
<li> <p><b>lbph</b> : log(benign prostatic hyperplasia amount)
</p>
</li>
<li> <p><b>svi</b> : seminal vesicle invasion
</p>
</li>
<li> <p><b>lcp</b> : log(capsular penetration)
</p>
</li>
<li> <p><b>gleason</b> : Gleason score
</p>
</li>
<li> <p><b>pgg45</b> : percentage Gleason scores 4 or 5
</p>
</li>
<li> <p><b>lpsa</b> : log(prostate specific antigen)
</p>
</li></ul>



<h3>Source</h3>

<p>Stamey, T.A., Kabalin, J.N., McNeal, J.E., Johnstone, I.M., Freiha,
F., Redwine, E.A. and Yang, N. (1989).
Prostate specific antigen in the diagnosis and treatment of
adenocarcinoma of the prostate: II. radical prostatectomy treated
patients,
<em>Journal of Urology</em> <b>141</b>(5), 1076&ndash;1083.
</p>


<h3>References</h3>

<p>Stamey, T.A., Kabalin, J.N., McNeal, J.E., Johnstone, I.M., Freiha,
F., Redwine, E.A. and Yang, N. (1989).
Prostate specific antigen in the diagnosis and treatment of adenocarcinoma 
of the prostate: II. radical prostatectomy treated patients,
<em>Journal of Urology</em>, <b>141</b>(5), 1076&ndash;1083.
<br />
<br />
This dataset also appears in the R-package: <em>lasso2</em>. <br />
Lokhorst, J., Venables, B. and Turlach, B. (2011).
lasso2: L1 contstrained estimation aka 'lasso',
published on R CRAN website: 
<em>http://cran.r-project.org/web/packages/lasso2/index.html</em>.
</p>

<hr>
<h2 id='summary.bayesQR'> Summarize the output of the <code>bayesQR</code> function </h2><span id='topic+summary.bayesQR'></span>

<h3>Description</h3>

<p><code>summary.bayesQR</code> is an S3 method that summarizes the output of the <code>bayesQR</code> function in an object of class bayesQR.summary.
For every estimated beta and sigma, this object contains the Bayes estimate and the posterior credible interval is calculated. 
The object also contains other relevant information about the estimation procedure, such as the quantile, the variable names, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'bayesQR'
summary(object, burnin=0, credint=c(.025,.975), quantile=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.bayesQR_+3A_object">object</code></td>
<td>
<p> an output object of the <code>bayesQR</code> function, i.e. an S3 object of class bayesQR. </p>
</td></tr>
<tr><td><code id="summary.bayesQR_+3A_burnin">burnin</code></td>
<td>
<p> the number of burnin draws that should be discarded (default=0, meaning all draws are included). </p>
</td></tr>
<tr><td><code id="summary.bayesQR_+3A_credint">credint</code></td>
<td>
<p> the width of the credible interval (default=c(0.025, 0.975)). </p>
</td></tr>
<tr><td><code id="summary.bayesQR_+3A_quantile">quantile</code></td>
<td>
<p> the quantile(s) of the quantile regressions that have to be summarized (default: all estimated quantiles in QRobj). </p>
</td></tr>
<tr><td><code id="summary.bayesQR_+3A_...">...</code></td>
<td>
<p> additional arguments passed to the generic <code>summary</code> function. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>bayesQR.summary</code>, basically a list including elements:
</p>
<table>
<tr><td><code>method</code></td>
<td>
<p> a string containing the method that was used, i.e. indicating whether the dependent variable was continuous or binary and whether adaptive lasso variable selection was used. </p>
</td></tr>
<tr><td><code>normal.approx</code></td>
<td>
<p> logical flag for normal approximation of posterior distribution. </p>
</td></tr>
<tr><td><code>quantile</code></td>
<td>
<p> the quantile that was estimated. </p>
</td></tr>
<tr><td><code>names</code></td>
<td>
<p> character vector containing the names of the independent variables in the model. </p>
</td></tr>
<tr><td><code>burnin</code></td>
<td>
<p> the number of burnin draws that were discarded. </p>
</td></tr>
<tr><td><code>retained</code></td>
<td>
<p> the number of draws that were retained and used to calculate the summary statistics. </p>
</td></tr>
<tr><td><code>credint</code></td>
<td>
<p> the width of the credible interval. </p>
</td></tr>
<tr><td><code>betadraw</code></td>
<td>
<p> the Bayes estimate, credible interval and, if <code>normal.approx=TRUE</code>, the adjusted credible intervals of the beta draws. </p>
</td></tr>
<tr><td><code>sigmadraw</code></td>
<td>
<p> the Bayes estimate and credible interval of the sigma draws. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dries F. Benoit
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the Prostate cancer dataset
data(Churn)

# Estimate the model parameters with default prior
out &lt;- bayesQR(churn~gender+recency, data=Churn, ndraw=2000)

# Return Bayes estimates and credible intervals 
sum &lt;- summary(out, burnin=1000)

# Inspect structure of bayesQR.summary object
str(sum)

# Print bayesQR.summary object
sum
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
