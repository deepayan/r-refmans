<!DOCTYPE html><html><head><title>Help for package DRomics</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DRomics}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bmdboot'><p>Computation of confidence interval on benchmark doses by bootstrap</p></a></li>
<li><a href='#bmdcalc'><p>Computation of benchmark doses for responsive items</p></a></li>
<li><a href='#bmdfilter'><p>Filtering BMDs according to estimation quality</p></a></li>
<li><a href='#bmdplot'><p>BMD plot optionally with confidence intervals on BMD</p></a></li>
<li><a href='#bmdplotwithgradient'><p>BMD plot with color gradient</p></a></li>
<li><a href='#continuousanchoringdata'><p>Import and check of continuous anchoring apical data</p></a></li>
<li><a href='#continuousomicdata'><p>Import and check of continuous omic data (e.g. metabolomic data)</p></a></li>
<li><a href='#curvesplot'><p>Plot of fitted curves</p></a></li>
<li><a href='#drcfit'><p>Dose response modelling for responsive items</p></a></li>
<li><a href='#ecdfplotwithCI'><p>ECDF plot of a variable with given confidence intervals on this variable</p></a></li>
<li><a href='#ecdfquantileplot'><p>ECDF plot of a given quantile of a variable calculated by group</p></a></li>
<li><a href='#formatdata4DRomics'><p>Build an R object that can be used as data input in DRomics</p></a></li>
<li><a href='#itemselect'><p>Selection of significantly responsive items</p></a></li>
<li><a href='#microarraydata'><p>Import, check and normalization of single-channel microarray data</p></a></li>
<li><a href='#PCAdataplot'><p>Performs and plots the results of a PCA on omic data</p></a></li>
<li><a href='#RNAseqdata'><p>Import, check and normalization and transformation of RNAseq data</p></a></li>
<li><a href='#Scenedesmus'><p>Concentration-response effect of triclosan in Scenedesmus vacuolatus</p></a></li>
<li><a href='#selectgroups'><p>Selection of groups on which to focus</p></a></li>
<li><a href='#sensitivityplot'><p>Plot of a summary of BMD values per group of items</p></a></li>
<li><a href='#targetplot'><p>Dose-reponse plot for target items</p></a></li>
<li><a href='#trendplot'><p>Plot of the repartition of trends per group</p></a></li>
<li><a href='#zebraf'><p>Transcriptomic dose-response to ionizing radiation in zebrafish with batch effect</p></a></li>
<li><a href='#Zhou'><p>Dose-response kidney transcriptomic effect of Tetrachloroethylene in mouse</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Dose Response for Omics</td>
</tr>
<tr>
<td>Version:</td>
<td>2.5-2</td>
</tr>
<tr>
<td>Description:</td>
<td>Several functions are provided for dose-response (or concentration-response) characterization from omics data. 'DRomics' is especially dedicated to omics data obtained using a typical dose-response design, favoring a great number of tested doses (or concentrations) rather than a great number of replicates (no need of replicates). 'DRomics' provides functions 1) to check, normalize and or transform data, 2) to select monotonic or biphasic significantly responding items (e.g. probes, metabolites), 3) to choose the best-fit model among a predefined family of monotonic and biphasic models to describe each selected item, 4) to derive a benchmark dose or concentration and a typology of response from each fitted curve. In the available version data are supposed to be single-channel microarray data in log2, RNAseq data in raw counts, or already pretreated continuous omics data (such as metabolomic data) in log scale. In order to link responses across biological levels based on a common method, 'DRomics' also handles apical data as long as they are continuous and follow a normal distribution for each dose or concentration, with a common standard error. For further details see Delignette-Muller et al (2023) &lt;<a href="https://doi.org/10.24072%2Fpcjournal.325">doi:10.24072/pcjournal.325</a>&gt; and Larras et al (2018) &lt;<a href="https://doi.org/10.1021%2Facs.est.8b04752">doi:10.1021/acs.est.8b04752</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), limma, utils, grDevices, DESeq2,
SummarizedExperiment</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, ggplot2, ggfortify, rlang</td>
</tr>
<tr>
<td>Suggests:</td>
<td>parallel, shiny, shinyBS, shinycssloaders, shinyjs,
shinyWidgets, sortable, testthat, knitr, rmarkdown, sva,
VennDiagram, plotly, svglite</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>BuildVignettes:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://lbbe.univ-lyon1.fr/fr/dromics">https://lbbe.univ-lyon1.fr/fr/dromics</a>,
<a href="https://aursiber.github.io/DRomics/">https://aursiber.github.io/DRomics/</a></td>
</tr>
<tr>
<td>Contact:</td>
<td>Marie-Laure Delignette-Muller
&lt;marielaure.delignettemuller@vetagro-sup.fr&gt;</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/aursiber/DRomics/issues">https://github.com/aursiber/DRomics/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-31 08:31:39 UTC; siberchicot</td>
</tr>
<tr>
<td>Author:</td>
<td>Marie-Laure Delignette-Muller
    <a href="https://orcid.org/0000-0001-5453-3994"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Elise Billoir <a href="https://orcid.org/0000-0001-9012-3298"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Floriane Larras [ctb],
  Aurelie Siberchicot
    <a href="https://orcid.org/0000-0002-7638-8318"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Aurelie Siberchicot &lt;aurelie.siberchicot@univ-lyon1.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-31 09:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bmdboot'>Computation of confidence interval on benchmark doses by bootstrap</h2><span id='topic+bmdboot'></span><span id='topic+print.bmdboot'></span><span id='topic+plot.bmdboot'></span>

<h3>Description</h3>

<p>Computes  95 percent confidence intervals on x-fold and z-SD benchmark doses by bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bmdboot(r, items = r$res$id, niter = 1000, 
                    conf.level = 0.95, 
                    tol = 0.5, progressbar = TRUE, 
                    parallel = c("no", "snow", "multicore"), ncpus)

## S3 method for class 'bmdboot'
print(x, ...)

## S3 method for class 'bmdboot'
plot(x, BMDtype = c("zSD", "xfold"), remove.infinite = TRUE,
                   by = c("none", "trend", "model", "typology"), 
                   CI.col = "blue", BMD_log_transfo = TRUE,  ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bmdboot_+3A_r">r</code></td>
<td>
<p>An object of class <code>"bmdcalc"</code> returned by the function <code>bmdcalc</code>.</p>
</td></tr>
<tr><td><code id="bmdboot_+3A_items">items</code></td>
<td>
<p>A character vector specifying the identifiers of the items for which you want the
computation of confidence intervals. 
If omitted the computation is done for all the items.</p>
</td></tr>
<tr><td><code id="bmdboot_+3A_niter">niter</code></td>
<td>
<p>The number of samples drawn by bootstrap.</p>
</td></tr>
<tr><td><code id="bmdboot_+3A_conf.level">conf.level</code></td>
<td>
<p>Confidence level of the intervals.</p>
</td></tr>
<tr><td><code id="bmdboot_+3A_tol">tol</code></td>
<td>
<p>The tolerance in term of proportion of bootstrap samples
on which the fit of the model is successful (if this proportion is below the tolerance,
NA values are given for the limits of the confidence interval.</p>
</td></tr>
<tr><td><code id="bmdboot_+3A_progressbar">progressbar</code></td>
<td>
<p>If <code>TRUE</code> a progress bar is used to follow the bootstrap process.</p>
</td></tr>
<tr><td><code id="bmdboot_+3A_parallel">parallel</code></td>
<td>
<p>The type of parallel operation to be used, <code>"snow"</code> or <code>"multicore"</code>
(the second one not being available on Windows),
or <code>"no"</code> if no parallel operation.</p>
</td></tr>
<tr><td><code id="bmdboot_+3A_ncpus">ncpus</code></td>
<td>
<p>Number of processes to be used in parallel operation : 
typically one would fix it to the number of available CPUs.</p>
</td></tr>
<tr><td><code id="bmdboot_+3A_x">x</code></td>
<td>
<p>An object of class <code>"bmdboot"</code>.</p>
</td></tr>
<tr><td><code id="bmdboot_+3A_bmdtype">BMDtype</code></td>
<td>
<p>The type of BMD to plot, <code>"zSD"</code> (default choice) or <code>"xfold"</code>.</p>
</td></tr>
<tr><td><code id="bmdboot_+3A_remove.infinite">remove.infinite</code></td>
<td>
<p>If TRUE the confidence intervals with non finite upper bound are not plotted.</p>
</td></tr>
<tr><td><code id="bmdboot_+3A_by">by</code></td>
<td>
<p>If not at <code>"none"</code> the plot is split by the indicated factor (<code>"trend"</code>,
<code>"model"</code> or <code>"typology"</code>).</p>
</td></tr>
<tr><td><code id="bmdboot_+3A_ci.col">CI.col</code></td>
<td>
<p>The color to draw the confidence intervals.</p>
</td></tr>
<tr><td><code id="bmdboot_+3A_bmd_log_transfo">BMD_log_transfo</code></td>
<td>
<p>If TRUE, default option, a log transformation of the BMD is used in the plot.</p>
</td></tr>
<tr><td><code id="bmdboot_+3A_...">...</code></td>
<td>
<p>Further arguments passed to graphical or print functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Non-parametric bootstrapping is used, where mean centered residuals are bootstrapped. 
For each item, bootstrapped parameter estimates are obtained by fitting the model on each of the resampled data sets. If the fitting procedure fails to converge in more than tol*100% of the cases, NA values are given for the confidence interval. Otherwise, bootstraped
BMD are computed from bootstrapped parameter estimates using the same method as 
in <code><a href="#topic+bmdcalc">bmdcalc</a></code>.
Confidence intervals on BMD are then
computed using percentiles of the bootstrapped BMDs.
For example 95 percent confidence intervals are 
computed using 2.5 and 97.5 percentiles of the bootstrapped BMDs. 
In cases where the bootstrapped BMD cannot be estimated as
not reached at the highest tested dose or not reachable due to model asymptotes,
it was given an infinite value <code>Inf</code>, so as to enable the computation
of the lower limit of the BMD confidence interval if a sufficient number of bootstrapped BMD values were estimated
to finite values.
</p>


<h3>Value</h3>

 
<p><code>bmdboot</code> returns an object of class <code>"bmdboot"</code>, a list with 3 components:
</p>
<table>
<tr><td><code>res</code></td>
<td>
<p> a data frame reporting the results of the fit, BMD computation and bootstrap
on each specified item sorted in the ascending order of the adjusted p-values. The different columns correspond to 
the identifier of each item (<code>id</code>), the row number of this item in the initial data set (<code>irow</code>), 
the adjusted p-value of the selection step (<code>adjpvalue</code>), the name of the best fit model (<code>model</code>), 
the number of fitted parameters (<code>nbpar</code>), the values of the parameters <code>b</code>, <code>c</code>, <code>d</code>, 
<code>e</code> and <code>f</code>, (<code>NA</code> for non used parameters), the residual standard deviation (<code>SDres</code>), 
the typology of the curve (<code>typology</code>, (16 class typology described in the help of the <code>drcfit</code> 
function)), the rough trend of the curve (<code>trend</code>) defined with four classes 
(U, bell, increasing or decreasing shape), the theoretical y value at the control (<code>y0</code>),
the theoretical y value at the maximal dose <code>yatdosemax</code>), 
the theoretical y range for x within the range of tested doses 
(<code>yrange</code>), the maximal absolute y change (up or down) from the control(<code>maxychange</code>) 
and for biphasic curves 
the x value at which their extremum is reached (<code>xextrem</code>)
and the corresponding y value (<code>yextrem</code>), the BMD-zSD value (<code>BMD.zSD</code>)
with the corresponding BMR-zSD value (reached or not, <code>BMR.zSD</code>) and 
the BMD-xfold value (<code>BMD.xfold</code>)
with the corresponding BMR-xfold value (reached or not, <code>BMR.xfold</code>), 
<code>BMD.zSD.lower</code> and  <code>BMD.zSD.upper</code> the lower and upper bounds of the 
confidence intervals of the BMD-zSD value, 
<code>BMD.xfold.lower</code> and  <code>BMD.xfold.upper</code> the lower and upper bounds of the
confidence intervals of the BMD-xfold value and
<code>nboot.successful</code> the number of successful fits on bootstrapped samples for each item.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>Value of z given in input to define the BMD-zSD.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>Value of x given in input as a percentage to define the BMD-xfold.</p>
</td></tr>
<tr><td><code>tol</code></td>
<td>
<p>The tolerance given in input in term of tolerated proportion of failures of
fit on bootstrapped samples.</p>
</td></tr>
<tr><td><code>niter</code></td>
<td>
<p>The number of samples drawn by bootstrap (given in input).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Marie-Laure Delignette-Muller
</p>


<h3>References</h3>

 
<p>Huet S, Bouvier A, Poursat M-A, Jolivet E (2003) Statistical tools for nonlinear regression: a practical guide with S-PLUS and R examples. Springer, Berlin, Heidelberg, New York.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+bmdcalc">bmdcalc</a></code> for details about the computation of benchmark doses.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># (1) a toy example (a very small subsample of a microarray data set) 
#
datafilename &lt;- system.file("extdata", "transcripto_very_small_sample.txt",
   package = "DRomics")

# to test the package on a small but not very small data set
# use the following commented line
# datafilename &lt;- system.file("extdata", "transcripto_sample.txt", package = "DRomics")

o &lt;- microarraydata(datafilename, check = TRUE, norm.method = "cyclicloess")
s_quad &lt;- itemselect(o, select.method = "quadratic", FDR = 0.001)
f &lt;- drcfit(s_quad, progressbar = TRUE)
r &lt;- bmdcalc(f)
set.seed(1234) # to get reproducible results with a so small number of iterations
(b &lt;- bmdboot(r, niter = 5)) # with a non reasonable value for niter 
# !!!! TO GET CORRECT RESULTS
# !!!! niter SHOULD BE FIXED FAR LARGER , e.g. to 1000 
# !!!! but the run will be longer 
b$res
plot(b) # plot of BMD.zSD after removing of BMDs with infinite upper bounds


# same plot in raw scale (without log transformation of BMD values)
plot(b, BMD_log_transfo = FALSE)

# plot of BMD.zSD without removing of BMDs 
# with infinite upper bounds
plot(b, remove.infinite = FALSE) 



# bootstrap on only a subsample of items
# with a greater number of iterations

chosenitems &lt;- r$res$id[1:5] 
(b.95 &lt;- bmdboot(r, items = chosenitems,
                     niter = 1000, progressbar = TRUE))
b.95$res

# Plot of fits with BMD values  and confidence intervals
# with the default BMD.zSD
plot(f, items = chosenitems, BMDoutput = b.95, BMDtype = "zSD")
# with the default BMD.xfold 
plot(f, items = chosenitems, BMDoutput = b.95, BMDtype = "xfold")

# same bootstrap but changing the default confidence level (0.95) to 0.90
(b.90 &lt;- bmdboot(r, items = chosenitems,
                       niter = 1000, conf.level = 0.9, progressbar = TRUE))
b.90$res






# (2) an example on a microarray data set (a subsample of a greater data set) 
#

datafilename &lt;- system.file("extdata", "transcripto_sample.txt", package="DRomics")

(o &lt;- microarraydata(datafilename, check = TRUE, norm.method = "cyclicloess"))
(s_quad &lt;- itemselect(o, select.method = "quadratic", FDR = 0.001))
(f &lt;- drcfit(s_quad, progressbar = TRUE))
(r &lt;- bmdcalc(f))
(b &lt;- bmdboot(r, niter = 100)) # niter to put at 1000 for a better precision

# different plots of BMD-zSD
plot(b)
plot(b, by = "trend") 
plot(b, by = "model") 
plot(b, by = "typology") 

# a plot of BMD-xfold (by default BMD-zSD is plotted)
plot(b, BMDtype = "xfold") 


# (3) Comparison of parallel and non parallel implementations 
#

# to be tested with a greater number of iterations
if(!requireNamespace("parallel", quietly = TRUE)) {
   if(parallel::detectCores() &gt; 1) {
      system.time(b1 &lt;- bmdboot(r, niter = 100, progressbar = TRUE))
      system.time(b2 &lt;- bmdboot(r, niter = 100, progressbar = FALSE, parallel = "snow", ncpus = 2))
}}


</code></pre>

<hr>
<h2 id='bmdcalc'>Computation of benchmark doses for responsive items</h2><span id='topic+bmdcalc'></span><span id='topic+print.bmdcalc'></span><span id='topic+plot.bmdcalc'></span>

<h3>Description</h3>

<p>Computes x-fold and z-SD benchmark doses for each responsive item using the best fit dose-reponse model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bmdcalc(f, z = 1, x = 10, minBMD, ratio2switchinlog = 100)

## S3 method for class 'bmdcalc'
print(x, ...)

## S3 method for class 'bmdcalc'
plot(x, BMDtype = c("zSD", "xfold"), 
            plottype = c("ecdf", "hist", "density"), 
            by = c("none", "trend", "model", "typology"),
            hist.bins = 30, BMD_log_transfo = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bmdcalc_+3A_f">f</code></td>
<td>
<p>An object of class <code>"drcfit"</code> returned by the function <code>drcfit</code>.</p>
</td></tr>
<tr><td><code id="bmdcalc_+3A_z">z</code></td>
<td>
<p>Value of z defining the BMD-zSD as the dose at which the response is reaching 
y0 +/- z * SD, with y0 the level at the control given by the dose-response fitted model and SD the 
residual standard deviation of the dose-response fitted model.</p>
</td></tr>
<tr><td><code id="bmdcalc_+3A_x">x</code></td>
<td>
<p>Value of x given as a percentage and defining the BMD-xfold as 
the dose at which the response is reaching 
y0 +/- (x/100) * y0, with y0 the level at the control given by the dose-response fitted model.
</p>
<p>For <code>print</code> and <code>plot</code> functions, an object of class <code>"bmdcalc"</code>.</p>
</td></tr>
<tr><td><code id="bmdcalc_+3A_minbmd">minBMD</code></td>
<td>
<p>minimal value for calculated BMDs, so a value considered negligible
compared to the tested doses. If not given by the user this argument is fixed
at the minimal non null tested dose divided by 100.</p>
</td></tr>
<tr><td><code id="bmdcalc_+3A_ratio2switchinlog">ratio2switchinlog</code></td>
<td>
<p>ratio between maximal and minimal tested doses above which
the numerical computation (when the use of <code><a href="stats.html#topic+uniroot">uniroot</a></code> is necessary) 
of the BMD is performed 
on a log scale of dose.</p>
</td></tr>
<tr><td><code id="bmdcalc_+3A_bmdtype">BMDtype</code></td>
<td>
<p>The type of BMD to plot, <code>"zSD"</code> (default choice) or <code>"xfold"</code>.</p>
</td></tr>
<tr><td><code id="bmdcalc_+3A_plottype">plottype</code></td>
<td>
<p>The type plot, <code>"ecdf"</code> for an empirical cumulative distribution plot 
(default choice), <code>"hist"</code> for a histogram or <code>"density"</code> for a density plot.</p>
</td></tr>
<tr><td><code id="bmdcalc_+3A_by">by</code></td>
<td>
<p>If different from <code>"none"</code> the plot is split by trend (if <code>"trend"</code>), by model (if <code>"model"</code>) or by typology (if <code>"typology"</code>).</p>
</td></tr>
<tr><td><code id="bmdcalc_+3A_hist.bins">hist.bins</code></td>
<td>
<p>The number of bins, only used for histogram(s).</p>
</td></tr>
<tr><td><code id="bmdcalc_+3A_bmd_log_transfo">BMD_log_transfo</code></td>
<td>
<p>If TRUE, default option, a log transformation of the BMD is used in the plot.</p>
</td></tr>
<tr><td><code id="bmdcalc_+3A_...">...</code></td>
<td>
<p> further arguments passed to graphical or print functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The two types of benchmark doses (BMD) proposed by the EFSA (2017)
were computed for each responsive item using 
the best fit dose-reponse model previously obtained using the <code><a href="#topic+drcfit">drcfit</a></code> function
(see Larras et al. 2018 for details):
</p>

<ul>
<li><p> the BMD-zSD defined as the dose at which the response is reaching 
y0 +/- z * SD, with y0 the level at the control given by the dose-response model, SD the 
residual standard deviation of the dose response model fit and z given as an input 
(<code>z</code> fixed to 1  by default),
</p>
</li>
<li><p> the BMD-xfold defined as the dose at which the response is reaching 
y0 +/- (x/100) * y0, with y0 the level at the control given by the dose-response fitted model 
and x the percentage given as an input (<code>x</code> fixed at 10 by default.)
</p>
</li></ul>

<p>When there is no analytical solution for the BMD, it is numerically searched along the fitted 
curve using the <code><a href="stats.html#topic+uniroot">uniroot</a></code> function.
</p>
<p>In cases where the BMD cannot be reached due to the asymptote at high doses, <code>NaN</code> is returned.
In cases where the BMD is not reached at the highest tested dose, <code>NA</code> is returned.
Very low BMD values obtained by extrapolation between
0 and the smallest non null tested dose, 
that correspond to very sensitive items (that we do not want to exclude),
are thresholded at minBMD, an argument by default fixed at the smallest non null 
tested dose divided by 100, but that can be fixed by the user as what he
considers to be a negligible dose.
</p>


<h3>Value</h3>

 
<p><code>bmdcalc</code> returns an object of class <code>"bmdcalc"</code>, a list with 4 components:
</p>
<table>
<tr><td><code>res</code></td>
<td>
<p> a data frame reporting the results of the fit and BMD computation
on each selected item sorted in the ascending order of the adjusted p-values returned by function <code>itemselect</code>. The different columns correspond to the identifier of each item (<code>id</code>), the row number of this item in the initial data set (<code>irow</code>), the adjusted p-value of the selection step (<code>adjpvalue</code>), the name of the best fit model (<code>model</code>), the number of fitted parameters (<code>nbpar</code>), the values of the parameters <code>b</code>, <code>c</code>, <code>d</code>, <code>e</code> and <code>f</code>, (<code>NA</code> for non used parameters), the residual standard deviation (<code>SDres</code>), the typology of the curve (<code>typology</code>, (16 class typology described in the help of the <code>drcfit</code> 
function)), the
rough trend of the curve (<code>trend</code>) defined with four classes (U, bell, increasing or decreasing shape), the
theoretical y value at the control (<code>y0</code>),
the theoretical y value at the maximal dose <code>yatdosemax</code>),
the theoretical y range 
for x within the range of tested doses 
(<code>yrange</code>), the maximal absolute y change (up or down) from the control(<code>maxychange</code>) and 
for biphasic curves 
the x value at which their extremum is reached (<code>xextrem</code>)
and the corresponding y value (<code>yextrem</code>), the BMD-zSD value (<code>BMD.zSD</code>)
with the corresponding BMR-zSD value (reached or not, <code>BMR.zSD</code>) and 
the BMD-xfold value (<code>BMD.xfold</code>)
with the corresponding BMR-xfold value (reached or not, <code>BMR.xfold</code>).</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>Value of z given in input to define the BMD-zSD.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>Value of x given in input as a percentage to define the BMD-xfold.</p>
</td></tr>
<tr><td><code>minBMD</code></td>
<td>
<p>minimal value for calculated BMDs given in input or fixed
at the minimal non null tested dose divided by 100.</p>
</td></tr>
<tr><td><code>ratio2switchinlog</code></td>
<td>
<p>ratio between maximal and minimal tested doses above which
the numerical computations are performed in a log scale (as given in input).</p>
</td></tr>
<tr><td><code>omicdata</code></td>
<td>
<p> The corresponding object given in input 
(component of itemselect).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Marie-Laure Delignette-Muller and Elise Billoir
</p>


<h3>References</h3>

 
<p>EFSA Scientific Committee, Hardy A, Benford D, Halldorsson T, Jeger MJ, Knutsen KH,
... &amp; Schlatter JR  (2017). Update: use of the benchmark dose approach in risk assessment.
EFSA Journal, 15(1), e04658.
</p>
<p>Larras F, Billoir E, Baillard V, Siberchicot A, Scholz S, Wubet T, Tarkka M,
Schmitt-Jansen M and Delignette-Muller ML (2018). DRomics: a turnkey tool to support 
the use of the dose-response framework for omics data in ecological risk assessment. 
Environmental science &amp; technology.<a href="https://doi.org/10.1021/acs.est.8b04752">doi:10.1021/acs.est.8b04752</a>
</p>


<h3>See Also</h3>

<p>See <code><a href="stats.html#topic+uniroot">uniroot</a></code> for details about the function used for the numerical 
search of the benchmark dose for cases where there is no analytical solution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# (1) a toy example (a very small subsample of a microarray data set) 
#
datafilename &lt;- system.file("extdata", "transcripto_very_small_sample.txt", package="DRomics")

# to test the package on a small (for a quick calculation) but not very small data set
# use the following commented line
# datafilename &lt;- system.file("extdata", "transcripto_sample.txt", package="DRomics")

(o &lt;- microarraydata(datafilename, check = TRUE, norm.method = "cyclicloess"))
(s_quad &lt;- itemselect(o, select.method = "quadratic", FDR = 0.01))
(f &lt;- drcfit(s_quad, progressbar = TRUE))
(r &lt;- bmdcalc(f))
plot(r) 


# same plot in raw scale of BMD (without log transformation of BMD values)
plot(r, BMD_log_transfo = FALSE) 

# changing the values of z and x for BMD calculation
(rb &lt;- bmdcalc(f, z = 2, x = 50))
plot(rb)



# Plot of fits with BMD values 

# example with the BMD-1SD
plot(f, BMDoutput = r, BMDtype = "zSD")

# example with the BMD-2SD
plot(f, BMDoutput = rb, BMDtype = "zSD")

# example with the BMD-xfold with x = 10 percent
plot(f, BMDoutput = r, BMDtype = "xfold")


# (2) an example on a microarray data set (a subsample of a greater data set) 
#

datafilename &lt;- system.file("extdata", "transcripto_sample.txt", package="DRomics")

# to test the package on a small (for a quick calculation) but not very small data set
# use the following commented line
# datafilename &lt;- system.file("extdata", "transcripto_sample.txt", package="DRomics")

(o &lt;- microarraydata(datafilename, check = TRUE, norm.method = "cyclicloess"))
(s_quad &lt;- itemselect(o, select.method = "quadratic", FDR = 0.01))
(f &lt;- drcfit(s_quad, progressbar = TRUE))
(r &lt;- bmdcalc(f))
plot(r) 

# different plots of BMD-zSD

plot(r, plottype = "hist") 
plot(r, plottype = "density") 
plot(r, plottype = "density", by = "trend") 
plot(r, plottype = "ecdf", by = "trend") 
plot(r, plottype = "ecdf", by = "model") 
plot(r, plottype = "ecdf", by = "typology") 

# a plot of BMD-xfold (by default BMD-zSD is plotted)
plot(r, BMDtype = "xfold", plottype = "hist", by = "typology", hist.bins = 10) 


</code></pre>

<hr>
<h2 id='bmdfilter'>Filtering BMDs according to estimation quality</h2><span id='topic+bmdfilter'></span>

<h3>Description</h3>

<p>Filtering BMDs in DRomics workflow output according to estimation quality,
to retain the best estimated BMDs for subsequent biological annotation and interpretation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bmdfilter(res, 
              BMDfilter = c("definedCI", "finiteCI", "definedBMD", "none"),
              BMDtype = c("zSD", "xfold"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bmdfilter_+3A_res">res</code></td>
<td>
<p>The dataframe of results provided by 
<code><a href="#topic+bmdboot">bmdboot</a></code> or <code><a href="#topic+bmdcalc">bmdcalc</a></code> (<code>res</code>) 
or a subset of this data frame. 
</p>
<p>Even if this function is intended to be used just after the calculation
of BMD values, before the biological annotation, it can also be used
within the interpretation workflow, on an extended dataframe
with additional columns coming for example from the biological annotation of items, 
and with some lines replicated for items with more than one annotation. 
</p>
<p>In any case the dataframe
must at least contain the column giving the BMD values (<code>BMD.zSD</code> or <code>BMD.xfold</code>
depending on the chosen BMDtype), identification of each curve (<code>id</code>),
and if <code>BMDfilter</code> is set to <code>"CIdefined"</code> or <code>"CIfinite"</code>,
the columns <code>BMD.zSD.lower</code>, <code>BMD.zSD.upper</code> or
<code>BMD.xfold.lower</code>, <code>BMD.xfold.upper</code> depending on the argument <code>BMDtype</code>.</p>
</td></tr>
<tr><td><code id="bmdfilter_+3A_bmdfilter">BMDfilter</code></td>
<td>
<p>If not <code>"none"</code>, the type of filter applied, based on BMD estimation.
If <code>"definedCI"</code> (default choice), all items for which point and interval estimates
of the BMD were successfully calculated are retained 
(so items for which the bootstrap procedure failed are excluded). 
If <code>"finiteCI"</code>, all items for which point and interval estimates of the BMD 
were successfully calculated and gave values within the range of tested/observed doses are retained.
If <code>"definedBMD"</code>, all items for which the point estimate of the BMD 
was estimated at a value within the range of tested/observed doses are retained. 
</p>
</td></tr>
<tr><td><code id="bmdfilter_+3A_bmdtype">BMDtype</code></td>
<td>
<p>The type of BMD used for the previously
described filtering procedure, <code>"zSD"</code> (default choice) or <code>"xfold"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using the argument <code>BMDfilter</code> three filters are proposed to retain
only the items associated to the best estimated BMD values.
By default we recommend to retain only the items for which the BMD and its
confidence interval are defined (using <code>"CIdefined"</code>) 
(so excluding items for which the bootstrap procedure failed).
One can be even more restrictive by 
retaining items only if the BMD confidence interval is within the range of
tested/observed doses (using <code>"CIfinite"</code>), or less restrictive 
(using <code>"BMDIdefined"</code>) requiring that the BMD
point estimate only must be defined within the range of tested/observed doses 
(let us recall that in the <code><a href="#topic+bmdcalc">bmdcalc</a></code> output, 
if it is not the case the BMD is coded <code>NA</code>).
</p>
<p>We propose an option <code>"none"</code> only in case, in the future, we add
other filters not based on the BMD.
</p>


<h3>Value</h3>

 
<p>A dataframe corresponding to a subset of res given in input, that 
can be used for biological annotation and further exploration.
</p>


<h3>Author(s)</h3>

 
<p>Marie-Laure Delignette-Muller
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+selectgroups">selectgroups</a></code>, <code><a href="#topic+bmdboot">bmdboot</a></code> and 
<code><a href="#topic+bmdcalc">bmdcalc</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# (1) a toy example 
# on a very small subsample of a microarray data set
# and a very smal number of bootstrap iterations 
# (clearly not sufficient, but it is just for illustration)
#
datafilename &lt;- system.file("extdata", "transcripto_very_small_sample.txt",
                            package = "DRomics")

# to test the package on a small but not very small data set
# use the following commented line
# datafilename &lt;- system.file("extdata", "transcripto_sample.txt", package = "DRomics")

o &lt;- microarraydata(datafilename, check = TRUE, norm.method = "cyclicloess")
s_quad &lt;- itemselect(o, select.method = "quadratic", FDR = 0.05)
f &lt;- drcfit(s_quad, progressbar = TRUE)
r &lt;- bmdcalc(f)
set.seed(1234) # to get reproducible results with a so small number of iterations
(b &lt;- bmdboot(r, niter = 10)) # with a non reasonable value for niter

# !!!! TO GET CORRECT RESULTS
# !!!! niter SHOULD BE FIXED FAR LARGER , e.g. to 1000 
# !!!! but the run will be longer

### (1.a) Examples on BMD.xfold (with some undefined BMD.xfold values)

# Plot of BMDs with no filtering
subres &lt;- bmdfilter(b$res, BMDfilter = "none")
bmdplot(subres, BMDtype = "xfold", point.size = 3, add.CI = TRUE)

# Plot of items with defined BMD point estimate
subres &lt;- bmdfilter(b$res, BMDtype = "xfold", BMDfilter = "definedBMD")
bmdplot(subres, BMDtype = "xfold", point.size = 3, add.CI = TRUE)

# Plot of items with defined BMD point estimate and CI bounds
subres &lt;- bmdfilter(b$res, BMDtype = "xfold", BMDfilter = "definedCI")
bmdplot(subres, BMDtype = "xfold", point.size = 3, add.CI = TRUE)

# Plot of items with finite BMD point estimate and CI bounds
subres &lt;- bmdfilter(b$res, BMDtype = "xfold", BMDfilter = "finiteCI") 
bmdplot(subres, BMDtype = "xfold", point.size = 3, add.CI = TRUE)



### (1.b) Examples on BMD.zSD (with no undefined BMD.zSD values)

# Plot of BMDs with no filtering
subres &lt;- bmdfilter(b$res, BMDfilter = "none")
bmdplot(subres, BMDtype = "zSD", point.size = 3, add.CI = TRUE)

# Plot items with defined BMD point estimate (the same on this ex.)
subres &lt;- bmdfilter(b$res, BMDtype = "zSD", BMDfilter = "definedBMD")
bmdplot(subres, BMDtype = "zSD", point.size = 3, add.CI = TRUE)

# Plot of items with defined BMD point estimate and CI bounds
subres &lt;- bmdfilter(b$res, BMDtype = "zSD", BMDfilter = "definedCI")
bmdplot(subres, BMDtype = "zSD", point.size = 3, add.CI = TRUE)

# Plot of items with finite BMD point estimate and CI bounds
subres &lt;- bmdfilter(b$res, BMDtype = "zSD", BMDfilter = "finiteCI") 
bmdplot(subres, BMDtype = "zSD", point.size = 3, add.CI = TRUE)


</code></pre>

<hr>
<h2 id='bmdplot'>BMD plot optionally with confidence intervals on BMD</h2><span id='topic+bmdplot'></span>

<h3>Description</h3>

<p>Provides an ECDF plot of BMD values optionally with confidence intervals on each BMD value
and/or labels of items.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bmdplot(extendedres, BMDtype = c("zSD", "xfold"),
                                  add.CI = FALSE, 
                                   facetby, facetby2, 
                                   shapeby,  colorby,
                                   point.size = 1.5,
                                   point.alpha = 0.8,
                                   line.size = 0.5, 
                                   line.alpha = 0.8,
                                   ncol4faceting, 
                                   add.label = FALSE, label.size = 2,
                                    BMD_log_transfo = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bmdplot_+3A_extendedres">extendedres</code></td>
<td>
<p>the dataframe of results provided by 
<code><a href="#topic+plot.bmdcalc">plot.bmdcalc</a></code> or <code><a href="#topic+plot.bmdboot">plot.bmdboot</a></code> (<code>res</code>) 
or a subset of this data frame (selected lines). This dataframe can be extended 
with additional columns coming for example from the functional annotation of items, and some lines 
can be replicated if their corresponding item has more than one annotation. 
This dataframe
must at least contain the column giving the BMD values (<code>BMD.zSD</code> or <code>BMD.xfold</code>
depending of chosen BMDtype), identification of each curve (<code>id</code>),
and if <code>add.CI</code> is TRUE,
the columns <code>BMD.zSD.lower</code>, <code>BMD.zSD.upper</code> or
<code>BMD.xfold.lower</code>, <code>BMD.xfold.upper</code> depending of the argument <code>BMDtype</code>.</p>
</td></tr>
<tr><td><code id="bmdplot_+3A_bmdtype">BMDtype</code></td>
<td>
<p>The type of BMD to plot, <code>"zSD"</code> (default choice) or <code>"xfold"</code>.</p>
</td></tr>
<tr><td><code id="bmdplot_+3A_add.ci">add.CI</code></td>
<td>
<p>If <code>TRUE</code> (default choice at FALSE) for each item the confidence interval is added.</p>
</td></tr>
<tr><td><code id="bmdplot_+3A_facetby">facetby</code></td>
<td>
<p>optional argument naming the column of <code>extendedres</code> chosen 
to split the plot in facets using <code>ggplot2::facet_wrap</code> (no split if omitted).</p>
</td></tr>
<tr><td><code id="bmdplot_+3A_facetby2">facetby2</code></td>
<td>
<p>optional argument naming the column of <code>extendedres</code> chosen 
as an additional argument to split the plot in facets using 
<code>ggplot2::facet_grid</code>, with columns defined by <code>facetby</code>
and rows defined by <code>facetby2</code> (no split if omitted).</p>
</td></tr>
<tr><td><code id="bmdplot_+3A_shapeby">shapeby</code></td>
<td>
<p>optional argument naming the column of <code>extendedres</code> chosen 
to shape the BMD points (no difference if shapeby if omitted).</p>
</td></tr>
<tr><td><code id="bmdplot_+3A_colorby">colorby</code></td>
<td>
<p>optional argument naming the column of <code>extendedres</code> chosen 
to color the BMD points (no difference if colorby if omitted).</p>
</td></tr>
<tr><td><code id="bmdplot_+3A_point.size">point.size</code></td>
<td>
<p>Size of the BMD points.</p>
</td></tr>
<tr><td><code id="bmdplot_+3A_point.alpha">point.alpha</code></td>
<td>
<p>Transparency of the points.</p>
</td></tr>
<tr><td><code id="bmdplot_+3A_line.size">line.size</code></td>
<td>
<p>Width of the lines.</p>
</td></tr>
<tr><td><code id="bmdplot_+3A_line.alpha">line.alpha</code></td>
<td>
<p>Transparency of the lines.</p>
</td></tr>
<tr><td><code id="bmdplot_+3A_ncol4faceting">ncol4faceting</code></td>
<td>
<p>Number of columns for facetting (not used if <code>facetby2</code> 
is also provided.</p>
</td></tr>
<tr><td><code id="bmdplot_+3A_add.label">add.label</code></td>
<td>
<p>Points are replaced  by labels of items if TRUE.</p>
</td></tr>
<tr><td><code id="bmdplot_+3A_label.size">label.size</code></td>
<td>
<p>Size of labels if add.label is TRUE.</p>
</td></tr>
<tr><td><code id="bmdplot_+3A_bmd_log_transfo">BMD_log_transfo</code></td>
<td>
<p>If TRUE, default option, a log transformation of the BMD is used in the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>BMD values are plotted as an ECDF plot, as with <code><a href="#topic+plot.bmdcalc">plot.bmdcalc</a></code>
using <code>"ecdf"</code> as <code>plottype</code> with confidence intervals on each BMD value
and/or labels of items if requested. The optional use of columns to code for shape and/or 
facets for each item is particularly intended to give a view of all the dose-response 
per group (e.g. metabolic pathways). Those groups must be coded in a column
of <code>extendedres</code>. In case where one item is allocated to more than one group
during the annotation process, the line of this item must be replicated in 
<code>extendedres</code> as many times as the number of annotation groups in which it was
allocated.
</p>


<h3>Value</h3>

 
<p>a ggplot object.
</p>


<h3>Author(s)</h3>

 
<p>Marie-Laure Delignette-Muller
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+plot.bmdcalc">plot.bmdcalc</a></code>, <code><a href="#topic+plot.bmdboot">plot.bmdboot</a></code> and 
<code><a href="#topic+ecdfplotwithCI">ecdfplotwithCI</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# (1)
# Plot of BMD values with color dose-response gradient
# faceted by metabolic pathway (from annotation of the selected items)
# and shaped by dose-response trend

# An example from the paper published by Larras et al. 2020
# in Journal of Hazardous Materials
# https://doi.org/10.1016/j.jhazmat.2020.122727
# A example of plot obtained with this function is in Figure 5 in Larras et al. 2020

# the dataframe with metabolomic results (output $res of bmdcalc() or bmdboot() functions)
resfilename &lt;- system.file("extdata", "triclosanSVmetabres.txt", package="DRomics")
res &lt;- read.table(resfilename, header = TRUE, stringsAsFactors = TRUE)
str(res)

# the dataframe with annotation of each item identified in the previous file
# each item may have more than one annotation (-&gt; more than one line)
annotfilename &lt;- system.file("extdata", "triclosanSVmetabannot.txt", package="DRomics")
annot &lt;- read.table(annotfilename, header = TRUE, stringsAsFactors = TRUE)
str(annot)

# Merging of both previous dataframes
# in order to obtain an extenderes dataframe
metabextendedres &lt;- merge(x = res, y = annot, by.x = "id", by.y = "metab.code")
head(metabextendedres)


### (1.a) BMDplot by pathway shaped by trend
bmdplot(metabextendedres, BMDtype = "zSD",
                     facetby = "path_class", 
                       shapeby = "trend") 



### (1.b) BMDplot by pathway with items labels
bmdplot(metabextendedres, BMDtype = "zSD",
                     facetby = "path_class", 
                       add.label = TRUE,
                       label.size = 2) 

### (1.c) BMDplot by pathway with confidence intervals
bmdplot(metabextendedres, BMDtype = "zSD",
                     facetby = "path_class", 
                       add.CI = TRUE) 

### (1.d) BMDplot by pathway with confidence intervals 
#         in BMD raw scale (not default log scale)
bmdplot(metabextendedres, BMDtype = "zSD",
                     facetby = "path_class",
                     add.CI = TRUE,
                     BMD_log_transfo = FALSE) 

### (1.e) BMDplot by pathway with confidence intervals 
#         colored by trend and playing with graphical parameters
bmdplot(metabextendedres, BMDtype = "zSD",
                     facetby = "path_class",
                     add.CI = TRUE,
                     colorby = "trend", 
                     point.size = 2,
                     point.alpha = 0.5,
                     line.size = 0.8,
                     line.alpha = 0.5) 


# (2) 
# An example with two molecular levels
#
# Import the dataframe with transcriptomic results 
contigresfilename &lt;- system.file("extdata", "triclosanSVcontigres.txt", package = "DRomics")
contigres &lt;- read.table(contigresfilename, header = TRUE, stringsAsFactors = TRUE)
str(contigres)

# Import the dataframe with functional annotation (or any other descriptor/category 
# you want to use, here KEGG pathway classes) 
contigannotfilename &lt;- system.file("extdata", "triclosanSVcontigannot.txt", package = "DRomics")
contigannot &lt;- read.table(contigannotfilename, header = TRUE, stringsAsFactors = TRUE)
str(contigannot)

# Merging of both previous dataframes   
contigextendedres &lt;- merge(x = contigres, y = contigannot, by.x = "id", by.y = "contig")
# to see the structure of this dataframe
str(contigextendedres)

### Merge metabolomic and transcriptomic results
extendedres &lt;- rbind(metabextendedres, contigextendedres)
extendedres$molecular.level &lt;- factor(c(rep("metabolites", nrow(metabextendedres)),
                              rep("contigs", nrow(contigextendedres))))
str(extendedres)

### BMD plot per pathway with molecular level coding for color
bmdplot(extendedres, BMDtype = "zSD",
                     facetby = "path_class",
                     colorby = "molecular.level",
                     point.alpha = 0.3) 

### BMD plot per pathway and per molecular level 
# for a selection of pathways
chosen_path_class &lt;- c("Membrane transport", "Lipid metabolism")
ischosen &lt;- is.element(extendedres$path_class, chosen_path_class)
bmdplot(extendedres[ischosen, ], BMDtype = "zSD",
                     facetby = "path_class",
                     facetby2 = "molecular.level",
                     colorby = "trend",
                     point.size = 2,
                     add.CI = TRUE) 




</code></pre>

<hr>
<h2 id='bmdplotwithgradient'>BMD plot with color gradient</h2><span id='topic+bmdplotwithgradient'></span>

<h3>Description</h3>

<p>Provides an ECDF plot of BMD values with a horizontal color gradient coding, for each item,
for the theoretical signal as a function of the dose (concentration).
The idea is to display the amplitude and the intensity of the response of each item
on the BMD ECDF plot, in addition to the BMD ordered values. This plot is of interest especially when not too much items are presented. To maximize the lisibility of the plot, one can manually pre-select items based on its own criteria (e.g. functional group of interest).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bmdplotwithgradient(extendedres, BMDtype = c("zSD", "xfold"),
                                   xmin, xmax, y0shift = TRUE, scaling = TRUE,
                                   facetby, facetby2, 
                                   shapeby, npoints = 50, 
                                   line.size, point.size = 1,
                                   ncol4faceting, limits4colgradient,
                                   lowercol = "darkblue", uppercol = "darkred",
                                   add.label, label.size = 2,
                                   BMD_log_transfo = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bmdplotwithgradient_+3A_extendedres">extendedres</code></td>
<td>
<p>the dataframe of results provided by bmdcalc (res) 
or a subset of this data frame (selected lines). This dataframe can be extended 
with additional columns coming for example from the functional annotation of items, and some lines 
can be replicated if their corresponding item has more than one annotation. 
This extended dataframe
must at least contain the column giving the BMD values (<code>BMD.zSD</code> or <code>BMD.xfold</code>
depending of chosen BMDtype), identification of each curve (<code>id</code>),
the column <code>model</code> naming the fitted model and the values of 
the parameters (columns <code>b</code>, <code>c</code>, <code>d</code>, <code>e</code>, <code>f</code>).</p>
</td></tr>
<tr><td><code id="bmdplotwithgradient_+3A_bmdtype">BMDtype</code></td>
<td>
<p>The type of BMD to plot, <code>"zSD"</code> (default choice) or <code>"xfold"</code>.</p>
</td></tr>
<tr><td><code id="bmdplotwithgradient_+3A_xmin">xmin</code></td>
<td>
<p>Optional minimal dose/concentration for definition of the x range.</p>
</td></tr>
<tr><td><code id="bmdplotwithgradient_+3A_xmax">xmax</code></td>
<td>
<p>Optional maximal dose/concentration for definition of the x range (can be defined 
as <code>max(f$omicdata$dose)</code> with <code>f</code> the output of <code>drcfit()</code> for example).</p>
</td></tr>
<tr><td><code id="bmdplotwithgradient_+3A_y0shift">y0shift</code></td>
<td>
<p>If <code>TRUE</code> (default choice) for each item the signal is shifted
to have the theoretical signal at the control at 0.</p>
</td></tr>
<tr><td><code id="bmdplotwithgradient_+3A_scaling">scaling</code></td>
<td>
<p>If <code>TRUE</code>, default choice, for each item the signal is shifted
to have the theoretical signal at the control at 0 and scaled by dividing by 
the maximal absolute signal change (up or down) from the signal at the control
<code>maxychange</code>.</p>
</td></tr>
<tr><td><code id="bmdplotwithgradient_+3A_facetby">facetby</code></td>
<td>
<p>optional argument naming the column of <code>extendedres</code> chosen 
to split the plot in facets using <code>ggplot2::facet_wrap</code> (no split if omitted).</p>
</td></tr>
<tr><td><code id="bmdplotwithgradient_+3A_facetby2">facetby2</code></td>
<td>
<p>optional argument naming the column of <code>extendedres</code> chosen 
as an additional argument to split the plot in facets using 
<code>ggplot2::facet_grid</code>, with columns defined by <code>facetby</code>
and rows defined by <code>facetby2</code> (no split if omitted).</p>
</td></tr>
<tr><td><code id="bmdplotwithgradient_+3A_shapeby">shapeby</code></td>
<td>
<p>optional argument naming the column of <code>extendedres</code> chosen 
to shape the BMD points (no difference if shapeby if omitted).</p>
</td></tr>
<tr><td><code id="bmdplotwithgradient_+3A_npoints">npoints</code></td>
<td>
<p>Number of points computed on each curve in order to define the 
signal color gradient (= number of doses or concentrations for which the theoretical
signal is computed from the fitted model for each item).</p>
</td></tr>
<tr><td><code id="bmdplotwithgradient_+3A_line.size">line.size</code></td>
<td>
<p>Size of the horizontal lines for plotting each signal color gradient.</p>
</td></tr>
<tr><td><code id="bmdplotwithgradient_+3A_point.size">point.size</code></td>
<td>
<p>Size of the BMD points.</p>
</td></tr>
<tr><td><code id="bmdplotwithgradient_+3A_ncol4faceting">ncol4faceting</code></td>
<td>
<p>Number of columns for facetting (not used if <code>facetby2</code> 
is also provided.</p>
</td></tr>
<tr><td><code id="bmdplotwithgradient_+3A_limits4colgradient">limits4colgradient</code></td>
<td>
<p>Optional vector giving minimal and maximal value of the signal
for the color gradient.</p>
</td></tr>
<tr><td><code id="bmdplotwithgradient_+3A_lowercol">lowercol</code></td>
<td>
<p>Chosen color for the lower values of the signal.</p>
</td></tr>
<tr><td><code id="bmdplotwithgradient_+3A_uppercol">uppercol</code></td>
<td>
<p>Chosen color for the upper values of the signal.</p>
</td></tr>
<tr><td><code id="bmdplotwithgradient_+3A_add.label">add.label</code></td>
<td>
<p>Points are replaced  by labels of items if TRUE.</p>
</td></tr>
<tr><td><code id="bmdplotwithgradient_+3A_label.size">label.size</code></td>
<td>
<p>Size of labels if add.label is TRUE.</p>
</td></tr>
<tr><td><code id="bmdplotwithgradient_+3A_bmd_log_transfo">BMD_log_transfo</code></td>
<td>
<p>If TRUE, the default option, a log transformation of the BMD is used in the plot. 
This option cannot be used with a null value of xmin in input.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>BMD values are plotted as an ECDF plot, as with <code><a href="#topic+plot.bmdcalc">plot.bmdcalc</a></code>
using &quot;ecdf&quot; as plottype. In addition is plotted an horizontal color gradient 
for each item coding for the signal level at each dose 
(or concentration). The optional use of columns to code for shape and/or 
facets for each item is particularly intended to give a view of all the dose-response 
per group (e.g. metabolic pathways). Those groups must be coded in a column
of extendedres. In case where one item is allocated to more than one group
during the annotation process, the line of this item must be replicated in 
extendedres as many times as the number of annotation groups in which it was
allocated.
</p>
<p>For each item of the extended dataframe, the name of the model 
(column <code>model</code>) and the values of 
the parameters (columns <code>b</code>, <code>c</code>, <code>d</code>, <code>e</code>, <code>f</code>)
are used to compute theoretical dose-response curves, and so the 
corresponding signal color gradient, in the range <code>[xmin ; xmax].</code>
</p>


<h3>Value</h3>

 
<p>a ggplot object.
</p>


<h3>Author(s)</h3>

 
<p>Marie-Laure Delignette-Muller
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+plot.bmdcalc">plot.bmdcalc</a></code> and <code><a href="#topic+plot.bmdboot">plot.bmdboot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# (1) 
# A toy example on a very small subsample of a microarray data set
datafilename &lt;- system.file("extdata", "transcripto_very_small_sample.txt", package="DRomics")

o &lt;- microarraydata(datafilename, check = TRUE, norm.method = "cyclicloess")
s_quad &lt;- itemselect(o, select.method = "quadratic", FDR = 0.01)
f &lt;- drcfit(s_quad, progressbar = TRUE)
r &lt;- bmdcalc(f)

# Plot of all the BMD values with color dose-response gradient 
#
bmdplotwithgradient(r$res, BMDtype = "zSD")  




# Same plot without signal scaling
# 
bmdplotwithgradient(r$res, BMDtype = "zSD", scaling = FALSE) 

# Plot of all the BMD values with color dose-response gradient 
# with definition of xmax from the maximal tested dose
#
bmdplotwithgradient(r$res, BMDtype = "zSD",
                    xmax = max(f$omicdata$dose)) 

# Add of item labels
bmdplotwithgradient(r$res, BMDtype = "zSD",
                    xmax = max(f$omicdata$dose), add.label = TRUE) 

# The same plot in raw scale (we can fix xmin at 0 in this case) 
#
bmdplotwithgradient(r$res, BMDtype = "zSD", xmin = 0,
                    BMD_log_transfo = FALSE) 

# The same plot in log scale with defining xmin and xmax at a chosen values 
#
bmdplotwithgradient(r$res, BMDtype = "zSD",
                    xmin =  min(f$omicdata$dose[f$omicdata$dose != 0] / 2), 
                    xmax = max(f$omicdata$dose),
                    BMD_log_transfo = TRUE) 

# Plot of all the BMD values with color dose-response gradient 
# faceted by response trend and shaped by model
#
bmdplotwithgradient(r$res, BMDtype = "zSD",
                      facetby = "trend", shapeby = "model") 
                      
# same plot changing the names of the facets 
levels(r$res$trend)
levels(r$res$trend) &lt;- c("bell shape", "decreasing", "increasing", "U shape")

bmdplotwithgradient(r$res, BMDtype = "zSD",
                      facetby = "trend", shapeby = "model")

# same plot changing the labels of the legends 
# and inversing the two guides
if (require(ggplot2)) bmdplotwithgradient(r$res, BMDtype = "zSD",
                      facetby = "trend", shapeby = "model") + 
                      labs(col = "signal value", shape = "model") +
                      guides(colour = guide_colourbar(order = 1),
                      shape = guide_legend(order = 2))
                      
# (2)
# Plot of BMD values with color dose-response gradient
# faceted by metabolic pathway (from annotation of the selected items)
# and shaped by dose-response trend

# An example from the paper published by Larras et al. 2020
# in Journal of Hazardous Materials
# https://doi.org/10.1016/j.jhazmat.2020.122727
# A example of plot obtained with this function is in Figure 5 in Larras et al. 2020


# the dataframe with metabolomic results (output $res of bmdcalc() or bmdboot() functions)
resfilename &lt;- system.file("extdata", "triclosanSVmetabres.txt", package="DRomics")
res &lt;- read.table(resfilename, header = TRUE, stringsAsFactors = TRUE)
str(res)

# the dataframe with annotation of each item identified in the previous file
# each item may have more than one annotation (-&gt; more than one line)
annotfilename &lt;- system.file("extdata", "triclosanSVmetabannot.txt", package="DRomics")
annot &lt;- read.table(annotfilename, header = TRUE, stringsAsFactors = TRUE)
str(annot)

# Merging of both previous dataframes
# in order to obtain an extenderes dataframe
extendedres &lt;- merge(x = res, y = annot, by.x = "id", by.y = "metab.code")
head(extendedres)


### (2.a) BMDplot with gradient by pathway
bmdplotwithgradient(extendedres, BMDtype = "zSD",
                     facetby = "path_class", 
                     xmax = 7.76, # maximal tested dose in those data
                       shapeby = "trend") 

### (2.a) BMDplot with gradient by pathway without scaling
bmdplotwithgradient(extendedres, BMDtype = "zSD",
                     facetby = "path_class", xmax = 7.76,
                       shapeby = "trend", scaling = FALSE) 


# (2.b) BMDplot with gradient by pathway
# forcing the limits of the colour gradient at other 
# values than observed minimal and maximal values of the signal
bmdplotwithgradient(extendedres, BMDtype = "zSD",
                      facetby = "path_class", 
                       shapeby = "trend",
                       limits4colgradient = c(-1, 1)) 

# (2.c) The same example changing the gradient colors and the line size
bmdplotwithgradient(extendedres, BMDtype = "zSD",
                      facetby = "path_class", 
                       shapeby = "trend",
                       line.size = 3, 
                       lowercol = "darkgreen", uppercol = "orange") 

# (2.d) The same example with only lipid metabolism pathclass
# and identification of the metabolites
LMres &lt;- extendedres[extendedres$path_class == "Lipid metabolism", ]
bmdplotwithgradient(LMres, BMDtype = "zSD",
                       line.size = 3, 
                       add.label = TRUE, label.size = 3) 


# (3) 
# An example on a microarray data set (a subsample of a greater data set)
#
datafilename &lt;- system.file("extdata", "transcripto_sample.txt", package="DRomics")

(o &lt;- microarraydata(datafilename, check = TRUE, norm.method = "cyclicloess"))
(s_quad &lt;- itemselect(o, select.method = "quadratic", FDR = 0.001))
(f &lt;- drcfit(s_quad, progressbar = TRUE))
(r &lt;- bmdcalc(f))

bmdplotwithgradient(r$res, BMDtype = "zSD",
                      facetby = "trend", 
                      shapeby = "model") 
# without scaling
bmdplotwithgradient(r$res, BMDtype = "zSD",
                      scaling = FALSE, facetby = "trend", 
                      shapeby = "model") 


</code></pre>

<hr>
<h2 id='continuousanchoringdata'>Import and check of continuous anchoring apical data</h2><span id='topic+continuousanchoringdata'></span><span id='topic+print.continuousanchoringdata'></span><span id='topic+plot.continuousanchoringdata'></span>

<h3>Description</h3>

<p>Continuous anchoring apical data are imported from a .txt file 
(internally imported using the function <code><a href="utils.html#topic+read.table">read.table</a></code>)
and checked or from a R object of class <code>data.frame</code>
(see the description 
of argument <code>file</code> for the required format
of data). 
No transformation is provided in this function.
If needed the pretreatment of data must be done before importation of data, 
so that they can be directly modelled using a normal 
error model. This strong hypothesis is required both for selection of responsive endpoints
and for dose-reponse modelling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>continuousanchoringdata(file, backgrounddose, check = TRUE)

## S3 method for class 'continuousanchoringdata'
print(x, ...)
## S3 method for class 'continuousanchoringdata'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="continuousanchoringdata_+3A_file">file</code></td>
<td>
<p>The name of the .txt file (e.g. <code>"mydata.txt"</code>)
containing one row per endpoint, with the first column corresponding to the identifier of each endpoint, 
and the other columns giving the measured values
of the endpoint for each replicate at each dose or concentration. 
In the first line, after a name for the endpoint column, we must have the tested
doses or concentrations in a numeric format for the corresponding replicate 
(for example, if there are triplicates for each treatment, 
the first line could be &quot;endpoint&quot;, 0, 0, 0, 0.1, 0.1, 0.1, etc.). 
This file is imported within the function using the function
<code><a href="utils.html#topic+read.table">read.table</a></code> with its default field separator (sep argument) and 
its default decimal separator (dec argument at &quot;.&quot;).
Alternatively an R object of class <code>data.frame</code> can be directly given in input, 
corresponding to the output
of <code>read.table(file, header = FALSE)</code> on a file described as above. The two
alternatives are illustrated below in examples.</p>
</td></tr>
<tr><td><code id="continuousanchoringdata_+3A_backgrounddose">backgrounddose</code></td>
<td>
<p>This argument must be used when there is no dose at zero in the data, to prevent the calculation of the BMD by extrapolation. All doses below or equal to the value given in backgrounddose will be fixed at 0, so as to be considered at the background level of exposition.</p>
</td></tr>
<tr><td><code id="continuousanchoringdata_+3A_check">check</code></td>
<td>
<p>If TRUE the format of the input file is checked.</p>
</td></tr>
<tr><td><code id="continuousanchoringdata_+3A_x">x</code></td>
<td>
<p>An object of class <code>"continuousanchoringdata"</code>.</p>
</td></tr>
<tr><td><code id="continuousanchoringdata_+3A_...">...</code></td>
<td>
<p> further arguments passed to print or plot functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function imports the data, checks their format  
(see the description 
of argument <code>file</code> for the required format
of data) and gives in the <code>print</code> information
that should help the user to check that the coding of data is correct : the tested doses (or concentrations) 
the number of replicates for each dose, the number of endpoints. 
</p>


<h3>Value</h3>

 
<p><code>continuousanchoringdata</code> returns an object of class &quot;continuousanchoringdata&quot;, a list with 5 components:
</p>
<table>
<tr><td><code>data</code></td>
<td>
<p> the numeric matrix of responses of each item in each replicate
(one line per item, one column per replicate)  </p>
</td></tr>
<tr><td><code>dose</code></td>
<td>
<p> the numeric vector of the tested doses or concentrations corresponding
to each column of data</p>
</td></tr>
<tr><td><code>item</code></td>
<td>
<p> the character vector of the identifiers of the endpoints, corresponding to
each line of data</p>
</td></tr>
<tr><td><code>design</code></td>
<td>
<p> a table with the experimental design (tested doses and number of 
replicates for each dose) for control by the user</p>
</td></tr>
<tr><td><code>data.mean</code></td>
<td>
<p> the numeric matrix of mean responses of each item per dose (mean 
of the corresponding replicates) (one line per item, one column per unique value 
of the dose</p>
</td></tr>
<tr><td><code>containsNA</code></td>
<td>
<p> TRUE if the data set contains NA values</p>
</td></tr>
</table>
<p>The print of a <code>continuousanchoringdata</code> object gives the tested doses (or concentrations) 
and number of replicates for each dose, the number of items, the identifiers 
of the first 20 items (for check of good coding of data) and the normalization method.
The plot of a <code>continuousanchoringdata</code> object shows the data distribution for each dose or concentration and replicate.
</p>


<h3>Author(s)</h3>

 
<p>Marie-Laure Delignette-Muller
</p>


<h3>See Also</h3>

<p>See  <code><a href="utils.html#topic+read.table">read.table</a></code> the function used to import data, and
<code><a href="#topic+microarraydata">microarraydata</a></code>, <code><a href="#topic+RNAseqdata">RNAseqdata</a></code> and <code><a href="#topic+continuousomicdata">continuousomicdata</a></code> for other types of data.</p>


<h3>Examples</h3>

<pre><code class='language-R'># (1) import and check of continuous anchoring data 
# (an example with two apical endpoints of an example given in the package (see ?Scenedesmus))
#
datafilename &lt;- system.file("extdata", "apical_anchoring.txt", package = "DRomics")

o &lt;- continuousanchoringdata(datafilename, backgrounddose = 0.1, check = TRUE)
# It is here necessary to define the background dose as there is no dose at 0 in the data
# The BMD cannot be computed without defining the background level

print(o)

plot(o)

# If you want to use your own data set just replace datafilename, 
# the first argument of continuousanchoringdata(), 
# by the name of your data file (e.g. "mydata.txt")
# 
# You should take care that the field separator of this data file is one
# of the default field separators recognised by the read.table() function
# when it is used with its default field separator (sep argument)
# Tabs are recommended.

# Use of an R object of class data.frame
# on the same example (see ?Scenedesmus for details)
data(Scenedesmus_apical)
o &lt;- continuousanchoringdata(Scenedesmus_apical, backgrounddose = 0.1)
print(o)

plot(o)



</code></pre>

<hr>
<h2 id='continuousomicdata'>Import and check of continuous omic data (e.g. metabolomic data)</h2><span id='topic+continuousomicdata'></span><span id='topic+metabolomicdata'></span><span id='topic+print.continuousomicdata'></span><span id='topic+plot.continuousomicdata'></span>

<h3>Description</h3>

<p>Metabolomic or other continuous omics data are imported from a .txt file 
(internally imported using the function <code><a href="utils.html#topic+read.table">read.table</a></code>)
and checked or from a R object of class <code>data.frame</code>
(see the description 
of argument <code>file</code> for the required format
of data). 
No normalization nor transformation is provided in this function.
The pretreatment of such continuous omic data data must be done before importation of data, 
and data must be imported in log scale if needed (imperative for example for metabolomic data),
so that they can be directly modelled using a normal 
error model. This strong hypothesis is required both for selection of items and for dose-reponse modelling.
As an example, a basic procedure for this pre-treatment of metabolomic data could follow
the three steps described thereafter:
i) removing of metabolites for which the proportion of missing data 
(non detections) across all the samples is too high 
(more than 20 to 50 percents according to your tolerance level);
ii) retrieving of missing values data using half minimum method 
(i.e. half of the minimum value found for a metabolite across all samples);
iii) log-transformation of values.
If a scaling to the total intensity (normalization by sum of signals 
in each sample) or another normalization is necessary and pertinent, 
we recommend to do it before those three previously decribed steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>continuousomicdata(file, backgrounddose, check = TRUE)
metabolomicdata(file, backgrounddose, check = TRUE)

## S3 method for class 'continuousomicdata'
print(x, ...)
## S3 method for class 'continuousomicdata'
plot(x, range4boxplot = 1e6, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="continuousomicdata_+3A_file">file</code></td>
<td>
<p>The name of the .txt file (e.g. <code>"mydata.txt"</code>)
containing one row per item, with the first column corresponding to the identifier of each item, 
and the other columns giving the responses
of the item for each replicate at each dose or concentration. 
In the first line, after a name for the identifier column, we must have the tested
doses or concentrations in a numeric format for the corresponding replicate 
(for example, if there are triplicates for each treatment, 
the first line could be &quot;item&quot;, 0, 0, 0, 0.1, 0.1, 0.1, etc.). 
This file is imported within the function using the function
<code><a href="utils.html#topic+read.table">read.table</a></code> with its default field separator (sep argument)and 
its default decimal separator (dec argument at &quot;.&quot;).
Alternatively an R object of class <code>data.frame</code> can be directly given in input, 
corresponding to the output
of <code>read.table(file, header = FALSE)</code> on a file described as above. The two
alternatives are illustrated below in examples.</p>
</td></tr>
<tr><td><code id="continuousomicdata_+3A_backgrounddose">backgrounddose</code></td>
<td>
<p>This argument must be used when there is no dose at zero in the data, to prevent the calculation of the BMD by extrapolation. All doses below  or equal to the value given in backgrounddose will be fixed at 0, so as to be considered at the background level of exposition.</p>
</td></tr>
<tr><td><code id="continuousomicdata_+3A_check">check</code></td>
<td>
<p>If TRUE the format of the input file is checked.</p>
</td></tr>
<tr><td><code id="continuousomicdata_+3A_x">x</code></td>
<td>
<p>An object of class <code>"continuousomicdata"</code>.</p>
</td></tr>
<tr><td><code id="continuousomicdata_+3A_range4boxplot">range4boxplot</code></td>
<td>
<p>An argument passed to boxplot(), fixed by default at 1e6 
to prevent the producing of very large plot files due to many outliers. 
Can be put at 1.5 to obtain more classical boxplots.</p>
</td></tr>
<tr><td><code id="continuousomicdata_+3A_...">...</code></td>
<td>
<p> further arguments passed to print or plot functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function imports the data, checks their format  
(see the description 
of argument <code>file</code> for the required format
of data) and gives in the <code>print</code> information
that should help the user to check that the coding of data is correct : 
the tested doses (or concentrations), 
the number of replicates for each dose, the number of items and the identifiers 
of the first 20 items. 
</p>
<p><code>metabolomicdata()</code> is the first name we gave to this function. 
We renamed it <code>continuousomicdata</code> (while keeping the first name available) 
to offer its use to other
continuous omic data such as proteomics data or RT-QPCR data. Nevertheless
one should take care of the scale in which such data are imported in DRomics.
A transformation may be needed to enable the use of a normal error model 
in each step of the DRomics workflow (from selection of items to modelling and 
BMD calculation)
</p>


<h3>Value</h3>

 
<p><code>continuousomicdata()</code> returns an object of class &quot;continuousomicdata&quot;, 
a list with 5 components:
</p>
<table>
<tr><td><code>data</code></td>
<td>
<p> the numeric matrix of responses of each item in each replicate
(one line per item, one column per replicate)  </p>
</td></tr>
<tr><td><code>dose</code></td>
<td>
<p> the numeric vector of the tested doses or concentrations corresponding
to each column of data</p>
</td></tr>
<tr><td><code>item</code></td>
<td>
<p> the character vector of the identifiers of the items, corresponding to
each line of data</p>
</td></tr>
<tr><td><code>design</code></td>
<td>
<p> a table with the experimental design (tested doses and number of 
replicates for each dose) for control by the user</p>
</td></tr>
<tr><td><code>data.mean</code></td>
<td>
<p> the numeric matrix of mean responses of each item per dose (mean 
of the corresponding replicates) (one line per item, one column per unique value 
of the dose</p>
</td></tr>
<tr><td><code>containsNA</code></td>
<td>
<p> TRUE if the data set contains NA values</p>
</td></tr>
</table>
<p>The print of a <code>continuousomicdata</code> object gives the tested doses (or concentrations) 
and number of replicates for each dose, the number of items, the identifiers 
of the first 20 items (for check of good coding of data) and the normalization method.
The plot of a <code>continuousomicdata</code> object shows the data distribution for each dose or concentration and replicate.
</p>


<h3>Author(s)</h3>

 
<p>Marie-Laure Delignette-Muller
</p>


<h3>See Also</h3>

<p>See  <code><a href="utils.html#topic+read.table">read.table</a></code> the function used to import data, and
<code><a href="#topic+microarraydata">microarraydata</a></code>, <code><a href="#topic+RNAseqdata">RNAseqdata</a></code> and
<code><a href="#topic+continuousanchoringdata">continuousanchoringdata</a></code> for other types of data.</p>


<h3>Examples</h3>

<pre><code class='language-R'># (1) import and check of metabolomic data 
# (an example on a subsample of a greater data set given in the package (see ?Scenedesmus))
#
datafilename &lt;- system.file("extdata", "metabolo_sample.txt", package = "DRomics")
o &lt;- continuousomicdata(datafilename)
print(o)
plot(o)
PCAdataplot(o)

# if you want to skip the check of data
o &lt;- continuousomicdata(datafilename, check = FALSE)


# If you want to use your own data set just replace datafilename, 
# the first argument of metabolomicdata(), 
# by the name of your data file (e.g. "mydata.txt")
# 
# You should take care that the field separator of this data file is one
# of the default field separators recognised by the read.table() function
# when it is used with its default field separator (sep argument)
# Tabs are recommended.

# Use of an R object of class data.frame
# An example using the complete data set
# Scenedesmus_metab (see ?Scenedesmus for details)
data(Scenedesmus_metab)
(o &lt;- continuousomicdata(Scenedesmus_metab))
plot(o)


</code></pre>

<hr>
<h2 id='curvesplot'>Plot of fitted curves</h2><span id='topic+curvesplot'></span>

<h3>Description</h3>

<p>Provides a plot of all the fitted curves from a dataframe of the main workflow
results, possibly extended with 
additional information (e.g. groups from functional annotation) used to color and/or split the curves. </p>


<h3>Usage</h3>

<pre><code class='language-R'>curvesplot(extendedres, xmin = 0, xmax, y0shift = TRUE, scaling = TRUE,
                       facetby, facetby2, free.y.scales = FALSE, ncol4faceting,
                       colorby, removelegend = FALSE,  
                        npoints = 500, line.size = 0.5, 
                        line.alpha = 0.8, dose_log_transfo = FALSE,
                       addBMD = TRUE, BMDtype = c("zSD", "xfold"), 
                       point.size = 1, point.alpha = 0.8)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curvesplot_+3A_extendedres">extendedres</code></td>
<td>
<p>the dataframe of results provided by bmdcalc (res) or drcfit (fitres) 
or a subset of this data frame (selected lines). This dataframe can be extended 
with additional columns coming for example from the annotation of items, and some lines 
can be replicated if their corresponding item has more than one annotation. 
This extended dataframe
must at least contain the column giving the identification of each curve (<code>id</code>),
the column <code>model</code> naming the fitted model and the values of 
the parameters (columns <code>b</code>, <code>c</code>, <code>d</code>, <code>e</code>, <code>f</code>).</p>
</td></tr>
<tr><td><code id="curvesplot_+3A_xmin">xmin</code></td>
<td>
<p>Minimal dose/concentration for definition of the x range (by default 0).</p>
</td></tr>
<tr><td><code id="curvesplot_+3A_xmax">xmax</code></td>
<td>
<p>Maximal dose/concentration for definition of the x range (can be defined 
as <code>max(f$omicdata$dose)</code> with <code>f</code> the output of <code>drcfit()</code>).</p>
</td></tr>
<tr><td><code id="curvesplot_+3A_y0shift">y0shift</code></td>
<td>
<p>If <code>TRUE</code> (default choice) curves are all shifted to have the theoretical
signal at the control at 0.</p>
</td></tr>
<tr><td><code id="curvesplot_+3A_scaling">scaling</code></td>
<td>
<p>If <code>TRUE</code>, deafult choice, curves are all shifted to have the theoretical
signal at the control at 0 <code>y0</code> and scaled by dividing by 
the maximal absolute signal change (up or down) from the signal at the control
<code>maxychange</code>.</p>
</td></tr>
<tr><td><code id="curvesplot_+3A_facetby">facetby</code></td>
<td>
<p>optional argument naming the column of <code>extendedres</code> chosen 
to split the plot in facets (no split if omitted).</p>
</td></tr>
<tr><td><code id="curvesplot_+3A_facetby2">facetby2</code></td>
<td>
<p>optional argument naming the column of <code>extendedres</code> chosen 
as an additional argument to split the plot in facets using 
<code>ggplot2::facet_grid</code>, with columns defined by <code>facetby</code>
and rows defined by <code>facetby2</code> (no split if omitted).</p>
</td></tr>
<tr><td><code id="curvesplot_+3A_free.y.scales">free.y.scales</code></td>
<td>
<p>if TRUE the y scales are free in the different facets.</p>
</td></tr>
<tr><td><code id="curvesplot_+3A_ncol4faceting">ncol4faceting</code></td>
<td>
<p>Number of columns for facetting (not used if <code>facetby2</code> 
is also provided.</p>
</td></tr>
<tr><td><code id="curvesplot_+3A_colorby">colorby</code></td>
<td>
<p>optional argument naming the column of <code>extendedres</code> chosen 
to color the curves (no color if omitted).</p>
</td></tr>
<tr><td><code id="curvesplot_+3A_removelegend">removelegend</code></td>
<td>
<p>If <code>TRUE</code> the color legend is removed (useful if the number
of colors is great).</p>
</td></tr>
<tr><td><code id="curvesplot_+3A_npoints">npoints</code></td>
<td>
<p>Number of points computed on each curve to plot it.</p>
</td></tr>
<tr><td><code id="curvesplot_+3A_line.size">line.size</code></td>
<td>
<p>Width of the lines for plotting curves.</p>
</td></tr>
<tr><td><code id="curvesplot_+3A_line.alpha">line.alpha</code></td>
<td>
<p>Transparency of the lines for plotting curves.</p>
</td></tr>
<tr><td><code id="curvesplot_+3A_dose_log_transfo">dose_log_transfo</code></td>
<td>
<p>If TRUE a log transformation of the dose is used in the plot. 
This option needs a definition of a strictly positive value of xmin in input.</p>
</td></tr>
<tr><td><code id="curvesplot_+3A_addbmd">addBMD</code></td>
<td>
<p>If TRUE points are added on the curve at BMD-BMR values (requires to have
BMD and BMD values in the first argument extendedres).</p>
</td></tr>
<tr><td><code id="curvesplot_+3A_bmdtype">BMDtype</code></td>
<td>
<p>The type of BMD to add, <code>"zSD"</code> (default choice) or <code>"xfold"</code>.</p>
</td></tr>
<tr><td><code id="curvesplot_+3A_point.size">point.size</code></td>
<td>
<p>Size of the BMD-BMR points added on the curves.</p>
</td></tr>
<tr><td><code id="curvesplot_+3A_point.alpha">point.alpha</code></td>
<td>
<p>Transparency of the BMD-BMR points added on the curves.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each item of the extended dataframe, the name of the model 
(column <code>model</code>) and the values of 
the parameters (columns <code>b</code>, <code>c</code>, <code>d</code>, <code>e</code>, <code>f</code>)
are used to compute theoretical dose-response curves in the range 
<code>[xmin ; xmax].</code>
</p>


<h3>Value</h3>

 
<p>a ggplot object.
</p>


<h3>Author(s)</h3>

 
<p>Marie-Laure Delignette-Muller
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+plot.bmdboot">plot.bmdboot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# (1) A toy example on a very small subsample of a microarray data set) 
#
datafilename &lt;- system.file("extdata", "transcripto_very_small_sample.txt", 
  package = "DRomics")

o &lt;- microarraydata(datafilename, check = TRUE, norm.method = "cyclicloess")
s_quad &lt;- itemselect(o, select.method = "quadratic", FDR = 0.01)
f &lt;- drcfit(s_quad, progressbar = TRUE)

# (1.a) 
# Default plot of all the curves 
#
curvesplot(f$fitres, xmax = max(f$omicdata$dose), addBMD = FALSE)


# the equivalent using the output of bmdcalc
# which enables the add of BMD values
r &lt;- bmdcalc(f)
curvesplot(r$res, xmax = max(f$omicdata$dose), addBMD = TRUE)

# use of line size, point size, transparency
curvesplot(r$res, xmax = max(f$omicdata$dose), 
  line.alpha = 0.2, line.size = 1,
  addBMD = TRUE, point.alpha = 0.3, point.size = 1.8)

# the same plot with dose in log scale (need xmin != 0 in input)
curvesplot(r$res, xmin = 0.1, xmax = max(f$omicdata$dose),
  dose_log_transfo = TRUE, addBMD = TRUE)

# plot of curves colored by models
curvesplot(r$res, xmax = max(f$omicdata$dose), colorby = "model")

# plot of curves facetted by item
curvesplot(r$res, xmax = max(f$omicdata$dose), facetby = "id")

# plot of curves facetted by trends
curvesplot(r$res, xmax = max(f$omicdata$dose), facetby = "trend")

# the same plot with free y scales
curvesplot(r$res, xmax = max(f$omicdata$dose), facetby = "trend",
  free.y.scales =  TRUE)
  
# (1.b) 
# Plot of all the curves without shifting y0 values to 0
# and without scaling
curvesplot(f$fitres, xmax = max(f$omicdata$dose),  addBMD = FALSE,
  scaling = FALSE, y0shift = FALSE)

# (1.c) 
# Plot of all the curves colored by model, with one facet per trend
#
curvesplot(f$fitres, xmax = max(f$omicdata$dose), addBMD = FALSE,
  facetby = "trend", colorby = "model")

# changing the number of columns
curvesplot(f$fitres, xmax = max(f$omicdata$dose), addBMD = FALSE, 
  facetby = "trend", colorby = "model", ncol4faceting = 4)

# playing with size and transparency of lines
curvesplot(f$fitres, xmax = max(f$omicdata$dose), addBMD = FALSE,
  facetby = "trend", colorby = "model", 
  line.size = 0.5, line.alpha = 0.8)
curvesplot(f$fitres, xmax = max(f$omicdata$dose),  addBMD = FALSE,
  facetby = "trend", colorby = "model", 
  line.size = 0.8, line.alpha = 0.2)
curvesplot(f$fitres, xmax = max(f$omicdata$dose),  addBMD = FALSE,
  facetby = "trend", line.size = 1, line.alpha = 0.2)
  
# (2) an example on a microarray data set (a subsample of a greater data set)
#
datafilename &lt;- system.file("extdata", "transcripto_sample.txt", package="DRomics")

(o &lt;- microarraydata(datafilename, check = TRUE, norm.method = "cyclicloess"))
(s_quad &lt;- itemselect(o, select.method = "quadratic", FDR = 0.001))
(f &lt;- drcfit(s_quad, progressbar = TRUE))
(r &lt;- bmdcalc(f))

# plot split by trend and model with BMR-BMD points added on curves
# adding transparency
curvesplot(r$res, xmax = max(f$omicdata$dose), 
  line.alpha = 0.2, line.size = 0.8,
  addBMD = TRUE, point.alpha = 0.2, point.size = 1.5,
  facetby = "trend", facetby2 = "model")

# same plot without scaling 
curvesplot(r$res, xmax = max(f$omicdata$dose), 
  line.alpha = 0.2, line.size = 0.8,
  addBMD = TRUE, point.alpha = 0.2, point.size = 1.5,
  scaling = FALSE, facetby = "trend", facetby2 = "model")

# (3) An example from data published by Larras et al. 2020
# in Journal of Hazardous Materials
# https://doi.org/10.1016/j.jhazmat.2020.122727

# a dataframe with metabolomic results (output $res of bmdcalc() or bmdboot() functions)
resfilename &lt;- system.file("extdata", "triclosanSVmetabres.txt", package="DRomics")
res &lt;- read.table(resfilename, header = TRUE, stringsAsFactors = TRUE)
str(res)

# a dataframe with annotation of each item identified in the previous file
# each item may have more than one annotation (-&gt; more than one line)
annotfilename &lt;- system.file("extdata", "triclosanSVmetabannot.txt", package="DRomics")
annot &lt;- read.table(annotfilename, header = TRUE, stringsAsFactors = TRUE)
str(annot)

# Merging of both previous dataframes
# in order to obtain an extenderes dataframe
# bootstrap results and annotation
extendedres &lt;- merge(x = res, y = annot, by.x = "id", by.y = "metab.code")
head(extendedres)

# Plot of the dose-response curves by pathway colored by trend
# with BMR-BMD points added on curves
curvesplot(extendedres, facetby = "path_class", npoints = 100, line.size = 0.5,
  colorby = "trend", xmin = 0, xmax = 8, addBMD = TRUE) 

# Plot of the dose-response curves without scaling, by pathway colored by trend
curvesplot(extendedres, facetby = "path_class", npoints = 100, line.size = 0.5,
  colorby = "trend", scaling = FALSE, xmin = 0, xmax = 8) 

# Plot of the dose-response curves split by pathway and by trend
# for a selection pathway
chosen_path_class &lt;- c("Membrane transport", "Lipid metabolism")
ischosen &lt;- is.element(extendedres$path_class, chosen_path_class)
curvesplot(extendedres[ischosen, ],
  facetby = "trend", facetby2 = "path_class",
  npoints = 100, line.size = 0.5, xmin = 0, xmax = 8) 

# Plot of the dose-response curves for a specific pathway
# in this example the "lipid metabolism" pathclass
LMres &lt;- extendedres[extendedres$path_class == "Lipid metabolism", ]
curvesplot(LMres, facetby = "id", npoints = 100, line.size = 0.8,
  colorby = "trend", xmin = 0, xmax = 8) 

</code></pre>

<hr>
<h2 id='drcfit'>Dose response modelling for responsive items</h2><span id='topic+drcfit'></span><span id='topic+print.drcfit'></span><span id='topic+plot.drcfit'></span><span id='topic+plotfit2pdf'></span>

<h3>Description</h3>

<p>Fits dose reponse models to responsive items.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drcfit(itemselect, 
  information.criterion = c("AICc", "BIC", "AIC"), 
  postfitfilter = TRUE, preventsfitsoutofrange = TRUE, 
  enablesfequal0inGP = TRUE, enablesfequal0inLGP = TRUE,
  progressbar = TRUE, parallel = c("no", "snow", "multicore"), ncpus)

## S3 method for class 'drcfit'
print(x, ...)

## S3 method for class 'drcfit'
plot(x, items, 
  plot.type = c("dose_fitted", "dose_residuals","fitted_residuals"), 
  dose_log_transfo = TRUE, BMDoutput, BMDtype = c("zSD", "xfold"), ...)
   
plotfit2pdf(x, items, 
  plot.type = c("dose_fitted", "dose_residuals", "fitted_residuals"), 
  dose_log_transfo = TRUE, BMDoutput, BMDtype = c("zSD", "xfold"),
  nrowperpage = 6, ncolperpage = 4, path2figs = getwd())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drcfit_+3A_itemselect">itemselect</code></td>
<td>
<p>An object of class <code>"itemselect"</code> returned by the function <code>itemselect</code>.</p>
</td></tr>
<tr><td><code id="drcfit_+3A_information.criterion">information.criterion</code></td>
<td>
<p>The information criterion used to select the best fit model, <code>"AICc"</code> as recommended and default
choice (the corrected version of the AIC that is recommended
for small samples (see Burnham and Anderson 2004), <code>"BIC"</code> or <code>"AIC"</code>.</p>
</td></tr>
<tr><td><code id="drcfit_+3A_postfitfilter">postfitfilter</code></td>
<td>
<p>If <code>TRUE</code> fits with significant trends on residuals 
(showing a global significant quadratic trend of the residuals
as a function of the dose (in rank-scale)) are considered as failures and so eliminated.
It is strongly recommended to let it at <code>TRUE</code>, its default value.</p>
</td></tr>
<tr><td><code id="drcfit_+3A_preventsfitsoutofrange">preventsfitsoutofrange</code></td>
<td>
<p>If <code>TRUE</code> fits of Gaussian or log-Gaussian models
that give an extremum value outside the range of the observed signal for an item
are eliminated from the candidate models for this item, 
before the choice of the best.
It is strongly recommended to let it at <code>TRUE</code>, its default value.</p>
</td></tr>
<tr><td><code id="drcfit_+3A_enablesfequal0ingp">enablesfequal0inGP</code></td>
<td>
<p>If <code>TRUE</code> when the fit of a Gauss-probit model with 5 parameters
is successful, its simplified version with <code>f = 0</code> is also fitted and included in the candidate
models. This submodel of the log-Gauss-probit model corresponds to the probit model.
We recommend to let this argument at <code>TRUE</code>, its default value, in order to prevent
overfitting, and prefer the description of a monotonic curve
when the parameter f is not necessary to model the data according to the information criterion.</p>
</td></tr>
<tr><td><code id="drcfit_+3A_enablesfequal0inlgp">enablesfequal0inLGP</code></td>
<td>
<p>If <code>TRUE</code> when the fit of a log-Gauss-probit model with 5 parameters
is successful, its simplified version with <code>f = 0</code> is also fitted and included in the candidate
models. This submodel of the log-Gauss-probit model corresponds to the log-probit model.
We recommend to let this argument at <code>TRUE</code>, its default value, in order to prevent
overfitting and prefer the description of a monotonic curve
when the parameter f is not necessary to model the data according to the information criterion.</p>
</td></tr>
<tr><td><code id="drcfit_+3A_progressbar">progressbar</code></td>
<td>
<p>If <code>TRUE</code> a progress bar is used to follow the fitting process.</p>
</td></tr>
<tr><td><code id="drcfit_+3A_parallel">parallel</code></td>
<td>
<p>The type of parallel operation to be used, <code>"snow"</code> or <code>"multicore"</code>
(the second one not being available on Windows),
or <code>"no"</code> if no parallel operation.</p>
</td></tr>
<tr><td><code id="drcfit_+3A_ncpus">ncpus</code></td>
<td>
<p>Number of processes to be used in parallel operation : 
typically one would fix it to the number of available CPUs.</p>
</td></tr>
<tr><td><code id="drcfit_+3A_x">x</code></td>
<td>
<p>An object of class <code>"drcfit"</code>.</p>
</td></tr>
<tr><td><code id="drcfit_+3A_items">items</code></td>
<td>
<p>Argument of the <code>plot.drcfit</code> function : the number of the first fits to
plot (20 items max) or the character vector
specifying the identifiers of the items to plot (20 items max).</p>
</td></tr>
<tr><td><code id="drcfit_+3A_plot.type">plot.type</code></td>
<td>
<p>The type of plot, by default <code>"dose_fitted"</code> for the plot of 
fitted curves with the observed points added to the plot and the observed means at each dose
added as black plain circles, <code>"dose_residuals"</code> for the plot of the residuals as function
of the dose, and <code>"fitted_residuals"</code> for the plot of the residuals as function of 
the fitted value.</p>
</td></tr>
<tr><td><code id="drcfit_+3A_dose_log_transfo">dose_log_transfo</code></td>
<td>
<p>By default at <code>TRUE</code> to use a log transformation
for the dose axis (only used if the dose is in x-axis, so not
for <code>plot.type</code> <code>"fitted_residuals"</code>).</p>
</td></tr>
<tr><td><code id="drcfit_+3A_bmdoutput">BMDoutput</code></td>
<td>
<p>Argument that can be used to add BMD values
and optionally their confidence intervals on a plot of type <code>"dose_fitted"</code>.
To do that you must previously apply <code><a href="#topic+bmdcalc">bmdcalc</a></code> and optionally
<code><a href="#topic+bmdboot">bmdboot</a></code>
on <code>x</code> of class <code>drcfit</code> 
and then give in this argument the output of <code><a href="#topic+bmdcalc">bmdcalc</a></code> or
<code><a href="#topic+bmdboot">bmdboot</a></code>.</p>
</td></tr>
<tr><td><code id="drcfit_+3A_bmdtype">BMDtype</code></td>
<td>
<p>The type of BMD to add on the plot, <code>"zSD"</code> (default choice) or   <code>"xfold"</code> (only used if BMDoutput is not missing).</p>
</td></tr>
<tr><td><code id="drcfit_+3A_nrowperpage">nrowperpage</code></td>
<td>
<p>Number of rows of plots when plots are saved in a pdf file using
plotfit2pdf() (passed to <code>facet_wrap()</code>).</p>
</td></tr>
<tr><td><code id="drcfit_+3A_ncolperpage">ncolperpage</code></td>
<td>
<p>Number of columns of plots when plots are saved in a pdf file using
plotfit2pdf() (passed to <code>facet_wrap()</code>).</p>
</td></tr>
<tr><td><code id="drcfit_+3A_path2figs">path2figs</code></td>
<td>
<p>File path when plots are saved in a pdf file using plotfit2pdf()</p>
</td></tr>
<tr><td><code id="drcfit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to graphical or print functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each selected item, five dose-response models (linear, Hill, exponential, 
Gauss-probit and log-Gauss-probit, see Larras et al. 2018
for their definition) are fitted by non linear regression,
using the <code><a href="stats.html#topic+nls">nls</a></code> function. If a fit of a biphasic model gives a extremum
value out of the range of the observed signal, it is eliminated (this may happen in rare cases,
especially on observational data  when the number of samples is high and the dose in uncontrolled,
if doses are not distributed all along the dose range).
The best fit is chosen as the one giving the lowest AICc 
(or BIC or AIC) value. The use of the AICc (second-order Akaike criterion)
instead of the AIC
is strongly recommended to prevent the overfitting that may occur with dose-response designs
with a small number of data points (Hurvich and Tsai, 1989; Burnham and Anderson DR, 2004). 
Note that in the extremely rare cases where the number of 
data points would be great, the AIC would converge to the AICc and both procedures would be equivalent.
Items with the best AICc value not lower than the AICc value of the null model (constant model) minus 2
are eliminated. Items with the best fit showing a global significant quadratic trend of the residuals
as a function of the dose (in rank-scale) are also eliminated (the best fit is considered as 
not reliable in such cases). 
</p>
<p>Each retained item is classified in four classes by its global trend,
which can be used to roughly describe the shape of each dose-response curve:
</p>

<ul>
<li><p> inc for increasing curves,
</p>
</li>
<li><p> dec for decreasing curves ,
</p>
</li>
<li><p> U for U-shape curves,
</p>
</li>
<li><p> bell for bell-shape curves.
</p>
</li></ul>

<p>Some curves fitted by a Gauss-probit model can be classified as increasing or decreasing when the 
dose value at which their extremum is reached is at zero or if their simplified version with <code>f = 0</code>
is retained (corresponding to the probit model).
Some curves fitted by a log-Gauss-probit model can be classified as increasing or decreasing 
if their simplified version with <code>f = 0</code>
is retained (corresponding to the log-probit model).
</p>
<p>Each retained item is thus classified in a 16 class typology depending of the
chosen model and of its parameter values : 
</p>

<ul>
<li><p> H.inc for increasing Hill curves,
</p>
</li>
<li><p> H.dec for decreasing Hill curves,
</p>
</li>
<li><p> L.inc for increasing linear curves,
</p>
</li>
<li><p> L.dec for decreasing linear curves,
</p>
</li>
<li><p> E.inc.convex for increasing convex exponential curves,
</p>
</li>
<li><p> E.dec.concave for decreasing concave exponential curves,
</p>
</li>
<li><p> E.inc.concave for increasing concave exponential curves,
</p>
</li>
<li><p> E.dec.convex for decreasing convex exponential curves,
</p>
</li>
<li><p> GP.U for U-shape Gauss-probit curves,
</p>
</li>
<li><p> GP.bell for bell-shape Gauss-probit curves,
</p>
</li>
<li><p> GP.inc for increasing Gauss-probit curves,
</p>
</li>
<li><p> GP.dec for decreasing Gauss-probit curves,
</p>
</li>
<li><p> lGP.U for U-shape log-Gauss-probit curves,
</p>
</li>
<li><p> lGP.bell for bell-shape log-Gauss-probit curves.
</p>
</li>
<li><p> lGP.inc for increasing log-Gauss-probit curves,
</p>
</li>
<li><p> lGP.dec for decreasing log-Gauss-probit curves,
</p>
</li></ul>



<h3>Value</h3>

 
<p><code>drcfit</code> returns an object of class <code>"drcfit"</code>, a list with 4 components:
</p>
<table>
<tr><td><code>fitres</code></td>
<td>
<p> a data frame reporting the results of the fit on each selected item 
for which a successful fit is reached (one line per item) sorted in the ascending order of the adjusted p-values returned by function <code>itemselect</code>. The different columns correspond to the identifier of each item (<code>id</code>), the row number of this item in the initial data set (<code>irow</code>), the adjusted p-value of the selection step (<code>adjpvalue</code>), the name of the best fit model (<code>model</code>), the number of fitted parameters (<code>nbpar</code>), the values of the parameters <code>b</code>, <code>c</code>, <code>d</code>, <code>e</code> and <code>f</code>, (<code>NA</code> for non used parameters), the residual standard deviation (<code>SDres</code>), the typology of the curve (<code>typology</code>), the
rough trend of the curve (<code>trend</code>) defined with four classes (U, bell, increasing or decreasing shape), the
theoretical y value at the control <code>y0</code>), the
theoretical y value at the maximal dose <code>yatdosemax</code>), the theoretical y range for x within the range of 
tested doses (<code>yrange</code>), the maximal absolute y change (up or down) from the control(<code>maxychange</code>) 
and for biphasic curves 
the x value at which their extremum is reached (<code>xextrem</code>) 
and the corresponding y value (<code>yextrem</code>).
</p>
</td></tr>
<tr><td><code>omicdata</code></td>
<td>
<p>The object containing all the data, as given in input of <code>itemselect()</code>
which is also a component of the output of <code>itemselect()</code>.</p>
</td></tr>
<tr><td><code>information.criterion</code></td>
<td>
<p>The information criterion used to select the best fit model as given in input.</p>
</td></tr>
<tr><td><code>information.criterion.val</code></td>
<td>
<p>A data frame reporting the IC values (AICc, BIC or AIC) values for each selected item (one line per item) and each fitted model (one colum per model with the IC value fixed at <code>Inf</code> when the fit failed).</p>
</td></tr>
<tr><td><code>n.failure</code></td>
<td>
<p>The number of previously selected items on which the workflow failed to fit an acceptable model.</p>
</td></tr>
<tr><td><code>unfitres</code></td>
<td>
<p>A data frame reporting the results on each selected item 
for which no successful fit is reached (one line per item) sorted in the ascending order of the adjusted p-values returned by function <code>itemselect</code>. The different columns correspond to the identifier of each item (<code>id</code>), the row number of this item in the initial data set (<code>irow</code>), the adjusted p-value of the selection step (<code>adjpvalue</code>), and code for the reason of the fitting failure (<code>cause</code>, equal to <code>"constant.model"</code> if the best fit model is a constant model or <code>"trend.in.residuals"</code> if the best fit model is rejected due to quadratic trend on residuals.)</p>
</td></tr>
<tr><td><code>residualtests</code></td>
<td>
<p>A data frame of P-values of the tests performed on residuals,
on the mean trend (<code>resimeantrendP</code> ) and on the variance trend (<code>resivartrendP</code>). The first one tests a global significant quadratic trend of the residuals as a function of the dose in rank-scale (used to
eliminate unreliable fits) and the second one a global significant quadratic trend of the residuals in absolute value as a function of the dose in rank-scale
(used to alert in case of heteroscedasticity).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

 
<p>Marie-Laure Delignette-Muller
</p>


<h3>References</h3>

 
<p>Burnham, KP, Anderson DR (2004). Multimodel inference: understanding AIC and BIC in model selection. Sociological methods &amp; research, 33(2), 261-304.
</p>
<p>Hurvich, CM, Tsai, CL (1989). Regression and time series model selection in small samples. Biometrika, 76(2), 297-307.
</p>
<p>Larras F, Billoir E, Baillard V, Siberchicot A, Scholz S, Wubet T, Tarkka M,
Schmitt-Jansen M and Delignette-Muller ML (2018). DRomics: a turnkey tool to support the use of the dose-response framework for omics data in ecological risk assessment. Environmental science &amp; technology.<a href="https://doi.org/10.1021/acs.est.8b04752">doi:10.1021/acs.est.8b04752</a>
</p>


<h3>See Also</h3>

<p>See <code><a href="stats.html#topic+nls">nls</a></code> for details about the non linear regression function and 
<code><a href="#topic+targetplot">targetplot</a></code> to plot target items (even if non responsive or unfitted).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# (1) a toy example (a very small subsample of a microarray data set) 
#
datafilename &lt;- system.file("extdata", "transcripto_very_small_sample.txt", package = "DRomics")

# to test the package on a small (for a quick calculation) but not very small data set
# use the following commented line
# datafilename &lt;- system.file("extdata", "transcripto_sample.txt", package = "DRomics")

o &lt;- microarraydata(datafilename, check = TRUE, norm.method = "cyclicloess")
s_quad &lt;- itemselect(o, select.method = "quadratic", FDR = 0.05)
(f &lt;- drcfit(s_quad, progressbar = TRUE))

# Default plot
plot(f)

# The same plot without log transformation of the doses 
# (in raw scale of doses)
plot(f, dose_log_transfo = FALSE)

# The same plot in x log scale choosing x limits for plot
if (require(ggplot2))
  plot(f, dose_log_transfo = TRUE) + 
    scale_x_log10(limits = c(0.1, 10))

# Plot of residuals as function of the dose
plot(f, plot.type = "dose_residuals")

# Same plot of residuals without log transformation of the doses
plot(f, plot.type = "dose_residuals", dose_log_transfo = FALSE)

# plot of residuals as function of the fitted value
plot(f, plot.type = "fitted_residuals")


# (2) an example on a microarray data set (a subsample of a greater data set) 
#
datafilename &lt;- system.file("extdata", "transcripto_sample.txt", package = "DRomics")

(o &lt;- microarraydata(datafilename, check = TRUE, norm.method = "cyclicloess"))
(s_quad &lt;- itemselect(o, select.method = "quadratic", FDR = 0.05))
(f &lt;- drcfit(s_quad, progressbar = TRUE))

# Default plot
plot(f)

# save all plots to pdf using plotfit2pdf()
plotfit2pdf(f, path2figs = tempdir())
plotfit2pdf(f, plot.type = "fitted_residuals", 
  nrowperpage = 9, ncolperpage = 6, path2figs = tempdir())

# Plot of the fit of the first 12 most responsive items
plot(f, items = 12)

# Plot of the chosen items in the chosen order
plot(f, items = c("301.2", "363.1", "383.1"))

# Look at the table of results for successful fits
head(f$fitres)

# Look at the table of results for unsuccessful fits
head(f$unfitres)

# count the number of unsuccessful fits for each cause
table(f$unfitres$cause)


# (3) Comparison of parallel and non paralell implementations on a larger selection of items
#
if(!requireNamespace("parallel", quietly = TRUE)) {
  if(parallel::detectCores() &gt; 1) {
    s_quad &lt;- itemselect(o, select.method = "quadratic", FDR = 0.05)
    system.time(f1 &lt;- drcfit(s_quad, progressbar = TRUE))
    system.time(f2 &lt;- drcfit(s_quad, progressbar = FALSE, parallel = "snow", ncpus = 2))
}}

</code></pre>

<hr>
<h2 id='ecdfplotwithCI'>ECDF plot of a variable with given confidence intervals on this variable</h2><span id='topic+ecdfplotwithCI'></span>

<h3>Description</h3>

<p>Provides an ECDF plot of a variable, with x-error bars for given confidence 
intervals on this variable, possibly partitioned by groups. 
In the context of this package this function is intended to be
used with the BMD as the variable and with groups defined by the user
from functional annotation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ecdfplotwithCI(variable, CI.lower, CI.upper, by, CI.col = "blue", 
CI.alpha = 1, add.point = TRUE, point.size = 1, point.type = 16)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ecdfplotwithCI_+3A_variable">variable</code></td>
<td>
<p>A numeric vector of the variable to plot. In the context of the package this variable
may be a BMD.</p>
</td></tr>
<tr><td><code id="ecdfplotwithCI_+3A_ci.lower">CI.lower</code></td>
<td>
<p>A corresponding numeric vector (same length) with the lower bounds of the confidence intervals.</p>
</td></tr>
<tr><td><code id="ecdfplotwithCI_+3A_ci.upper">CI.upper</code></td>
<td>
<p>A corresponding numeric vector (same length) with the upper bounds of the confidence intervals.</p>
</td></tr>
<tr><td><code id="ecdfplotwithCI_+3A_by">by</code></td>
<td>
<p>A factor of the same length for split of the plot by this factor (no split if omitted).
In the context of this package this factor may code for groups defined by the user from functional
annotation.</p>
</td></tr>
<tr><td><code id="ecdfplotwithCI_+3A_ci.col">CI.col</code></td>
<td>
<p>The color to draw the confidence intervals (unique color) of a factor coding for the color.</p>
</td></tr>
<tr><td><code id="ecdfplotwithCI_+3A_ci.alpha">CI.alpha</code></td>
<td>
<p>Optional transparency of the lines used to draw the confidence intervals.</p>
</td></tr>
<tr><td><code id="ecdfplotwithCI_+3A_add.point">add.point</code></td>
<td>
<p>If <code>TRUE</code> points are added to confidence intervals.</p>
</td></tr>
<tr><td><code id="ecdfplotwithCI_+3A_point.size">point.size</code></td>
<td>
<p>Size of the added points in case <code>add.point</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="ecdfplotwithCI_+3A_point.type">point.type</code></td>
<td>
<p>Shape of the added points in case <code>add.point</code> is <code>TRUE</code>
defined as an integer coding for a unique common shape or
as a factor coding for the shape.</p>
</td></tr>
</table>


<h3>Value</h3>

 
<p>a ggplot object.
</p>


<h3>Author(s)</h3>

 
<p>Marie-Laure Delignette-Muller
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+plot.bmdboot">plot.bmdboot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# (1) a toy example (a very small subsample of a microarray data set) 
#
datafilename &lt;- system.file("extdata", "transcripto_very_small_sample.txt",
package="DRomics")
o &lt;- microarraydata(datafilename, check = TRUE, norm.method = "cyclicloess")
s_quad &lt;- itemselect(o, select.method = "quadratic", FDR = 0.001)
f &lt;- drcfit(s_quad, progressbar = TRUE)
r &lt;- bmdcalc(f)
set.seed(1) # to get reproducible results with a so small number of iterations
b &lt;- bmdboot(r, niter = 5) # with a non reasonable value for niter 
# !!!! TO GET CORRECT RESULTS
# !!!! niter SHOULD BE FIXED FAR LARGER , e.g. to 1000 
# !!!! but the run will be longer 

# manual ecdf plot of the bootstrap results as an ecdf distribution 
# on BMD, plot that could also be obtained with plot(b) 
# in this simple case
#
a &lt;- b$res[is.finite(b$res$BMD.zSD.upper), ]
ecdfplotwithCI(variable = a$BMD.zSD, CI.lower = a$BMD.zSD.lower, 
              CI.upper = a$BMD.zSD.upper, CI.col = "red")



# (2) An example from data published by Larras et al. 2020
# in Journal of Hazardous Materials
# https://doi.org/10.1016/j.jhazmat.2020.122727

# This function can also be used to go deeper in the exploration of the biological 
# meaning of the responses. Here is an example linking the DRomics outputs 
# with the functional annotation of the responding metabolites of the microalgae 
# Scenedesmus vacuolatus to the biocide triclosan. 
# This extra step uses a dataframe previously built by the user which links the items
# to the biological information of interest (e.g. KEGG pathways).

# importation of a dataframe with metabolomic results 
# (output $res of bmdcalc() or bmdboot() functions)
resfilename &lt;- system.file("extdata", "triclosanSVmetabres.txt", package="DRomics")
res &lt;- read.table(resfilename, header = TRUE, stringsAsFactors = TRUE)
str(res)

# importation of a dataframe with annotation of each item
# identified in the previous file (this dataframe must be previously built by the user)
# each item may have more than one annotation (-&gt; more than one line)
annotfilename &lt;- system.file("extdata", "triclosanSVmetabannot.txt", package="DRomics")
annot &lt;- read.table(annotfilename, header = TRUE, stringsAsFactors = TRUE)
str(annot)

# Merging of both previous dataframes
# in order to obtain an extenderes dataframe
# bootstrap results and annotation
annotres &lt;- merge(x = res, y = annot, by.x = "id", by.y = "metab.code")
head(annotres)

### an ECDFplot with confidence intervals by pathway
# with color coding for dose-response trend
ecdfplotwithCI(variable = annotres$BMD.zSD, 
               CI.lower = annotres$BMD.zSD.lower, 
               CI.upper = annotres$BMD.zSD.upper, 
               by = annotres$path_class,
               CI.col = annotres$trend) 


# (3) an example on a microarray data set (a subsample of a greater data set) 
#
datafilename &lt;- system.file("extdata", "transcripto_sample.txt", package="DRomics")

(o &lt;- microarraydata(datafilename, check = TRUE, norm.method = "cyclicloess"))
(s_quad &lt;- itemselect(o, select.method = "quadratic", FDR = 0.001))
(f &lt;- drcfit(s_quad, progressbar = TRUE))
(r &lt;- bmdcalc(f))
(b &lt;- bmdboot(r, niter = 100)) # niter to put at 1000 for a better precision

# (3.a) 
# manual ecdf plot of the bootstrap results as an ecdf distribution 
# on BMD for each trend
# plot that could also be obtained with plot(b, by = "trend") 
# in this simple case
#
a &lt;- b$res[is.finite(b$res$BMD.zSD.upper), ]
ecdfplotwithCI(variable = a$BMD.zSD, CI.lower = a$BMD.zSD.lower, 
              CI.upper = a$BMD.zSD.upper, by = a$trend, CI.col = "red")

# (3.b)
# ecdf plot of the bootstrap results as an ecdf distribution 
# on BMD for each model
# with the color of the confidence intervals coding for the trend
#
ecdfplotwithCI(variable = a$BMD.zSD, CI.lower = a$BMD.zSD.lower, 
              CI.upper = a$BMD.zSD.upper, by = a$model, CI.col = a$trend)

# changing the size of the points and the transparency of CI lines
ecdfplotwithCI(variable = a$BMD.zSD, CI.lower = a$BMD.zSD.lower, 
              CI.upper = a$BMD.zSD.upper, by = a$model, CI.col = a$trend,
              CI.alpha = 0.5, point.size = 0.5)

# with the model coding for the type of points
ecdfplotwithCI(variable = a$BMD.zSD, CI.lower = a$BMD.zSD.lower, 
              CI.upper = a$BMD.zSD.upper, CI.col = a$trend,
              CI.alpha = 0.5, point.size = 0.5, point.type = a$model)


# (3.c)
# ecdf plot of the bootstrap results as an ecdf distribution on 
# on BMD_L (lower value of the confidence interval) for each trend
# 
ecdfplotwithCI(variable = a$BMD.zSD.lower, CI.lower = a$BMD.zSD.lower, 
              CI.upper = a$BMD.zSD.upper, by = a$model, CI.col = a$trend, 
              add.point = FALSE)
  

</code></pre>

<hr>
<h2 id='ecdfquantileplot'>ECDF plot of a given quantile of a variable calculated by group</h2><span id='topic+ecdfquantileplot'></span>

<h3>Description</h3>

<p>Plots a given quantile of a variable calculated by group as an ECDF plot with points sized by the numbers of items per group.
In the context of this package this function is intended to be
used with the BMD as the variable and with groups defined by the user
from functional annotation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ecdfquantileplot(variable, by, quantile.prob = 0.5, title)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ecdfquantileplot_+3A_variable">variable</code></td>
<td>
<p>A numeric vector corresponding to the variable on which we want to calculate the given quantile by group. In the context of the package this variable
may be a BMD.</p>
</td></tr>
<tr><td><code id="ecdfquantileplot_+3A_by">by</code></td>
<td>
<p>A factor of the same length defining the groups. In the context of this package this factor may code for groups defined by the user from functional annotation.</p>
</td></tr>
<tr><td><code id="ecdfquantileplot_+3A_quantile.prob">quantile.prob</code></td>
<td>
<p>The probability (in ]0, 1[) defining the quantile to calculate on each group.</p>
</td></tr>
<tr><td><code id="ecdfquantileplot_+3A_title">title</code></td>
<td>
<p>An optional title for the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The given quantile is calculated for each group (e.g.from all items of a metabolic pathway) 
using function <code><a href="stats.html#topic+quantile">quantile</a></code> and plotted as an ECDF plot. In this ECDF plot of quantiles each point is sized according to the number of items in the corresponding group (e.g. metabolic pathway). 
We recommend the use of the new function 
<code><a href="#topic+sensitivityplot">sensitivityplot</a></code> that may be more convenient and that offers more options. 
</p>


<h3>Value</h3>

 
<p>a ggplot object.
</p>


<h3>Author(s)</h3>

 
<p>Marie-Laure Delignette-Muller
</p>


<h3>See Also</h3>

<p>See <code><a href="stats.html#topic+quantile">quantile</a></code> and <code><a href="#topic+sensitivityplot">sensitivityplot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# (1) An example from data published by Larras et al. 2020
# in Journal of Hazardous Materials
# https://doi.org/10.1016/j.jhazmat.2020.122727

# a dataframe with metabolomic results (output $res of bmdcalc() or bmdboot() functions)
resfilename &lt;- system.file("extdata", "triclosanSVmetabres.txt", package="DRomics")
res &lt;- read.table(resfilename, header = TRUE, stringsAsFactors = TRUE)
str(res)

# a dataframe with annotation of each item identified in the previous file
# each item may have more than one annotation (-&gt; more than one line)
annotfilename &lt;- system.file("extdata", "triclosanSVmetabannot.txt", package="DRomics")
annot &lt;- read.table(annotfilename, header = TRUE, stringsAsFactors = TRUE)
str(annot)

# Merging of both previous dataframes
# in order to obtain an extenderes dataframe
# bootstrap results and annotation
annotres &lt;- merge(x = res, y = annot, by.x = "id", by.y = "metab.code")
head(annotres)

### an ECDFplot of quantiles of BMD-zSD calculated by pathway
ecdfquantileplot(variable = annotres$BMD.zSD, 
               by = annotres$path_class,
               quantile.prob = 0.25) 
 
# same plot in log10 dose scale (not interesting on this example
# but could be on another one) 
if (require(ggplot2))
  ecdfquantileplot(variable = annotres$BMD.zSD, 
               by = annotres$path_class,
               quantile.prob = 0.25) + scale_y_log10() 


</code></pre>

<hr>
<h2 id='formatdata4DRomics'>Build an R object that can be used as data input in DRomics</h2><span id='topic+formatdata4DRomics'></span>

<h3>Description</h3>

<p>Build an R object that can be used as data input in data importation function from
two inputs: the nitems x nsamples matrix coding for the signal and the 
nsamples vector of doses 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formatdata4DRomics(signalmatrix, dose, samplenames)   
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formatdata4DRomics_+3A_signalmatrix">signalmatrix</code></td>
<td>
<p>the matrix of the data with one row for each item and one column
for each sample. The row names of this matrix will be taken to identify
the items.
Depending of the type of measured signal, look at the help of the corresponding
importation function especially to check that you use the good scale of data
<code><a href="#topic+RNAseqdata">RNAseqdata</a></code>, <code><a href="#topic+microarraydata">microarraydata</a></code>, <code><a href="#topic+continuousomicdata">continuousomicdata</a></code> and
<code><a href="#topic+continuousanchoringdata">continuousanchoringdata</a></code>.</p>
</td></tr>
<tr><td><code id="formatdata4DRomics_+3A_dose">dose</code></td>
<td>
<p>a numeric vector giving the dose for each sample.</p>
</td></tr>
<tr><td><code id="formatdata4DRomics_+3A_samplenames">samplenames</code></td>
<td>
<p>a character vector giving the names of the samples 
(optional argument - if not given, the col names of signalmatrix are taken as sample names).</p>
</td></tr>
</table>


<h3>Value</h3>

 
<p>an R object that corresponds to a dataframe that can be passed as input in the 
first argument of the data importation functions <code><a href="#topic+RNAseqdata">RNAseqdata</a></code>, 
<code><a href="#topic+microarraydata">microarraydata</a></code>, <code><a href="#topic+continuousomicdata">continuousomicdata</a></code> or
<code><a href="#topic+continuousanchoringdata">continuousanchoringdata</a></code>.
</p>


<h3>Author(s)</h3>

 
<p>Marie-Laure Delignette-Muller
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+RNAseqdata">RNAseqdata</a></code>, <code><a href="#topic+microarraydata">microarraydata</a></code>,
<code><a href="#topic+continuousomicdata">continuousomicdata</a></code> and
<code><a href="#topic+continuousanchoringdata">continuousanchoringdata</a></code> especially for specification of
the required scale of data in each case.</p>


<h3>Examples</h3>

<pre><code class='language-R'># (1) load of data
#
data(zebraf)
str(zebraf)

# (2) formating of data for use in DRomics
# 
data4DRomics &lt;- formatdata4DRomics(signalmatrix = zebraf$counts, 
                           dose = zebraf$dose)

# (3) Normalization and transformation of data 
#
o &lt;- RNAseqdata(data4DRomics)
plot(o)


</code></pre>

<hr>
<h2 id='itemselect'>Selection of significantly responsive items</h2><span id='topic+itemselect'></span><span id='topic+print.itemselect'></span>

<h3>Description</h3>

<p>Significantly responsive items are selected using one of the three proposed methods: 
a quadratic trend test, a linear trend test or an ANOVA-based test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>itemselect(omicdata, select.method = c("quadratic", "linear", "ANOVA"), 
  FDR = 0.05, max.ties.prop = 0.2)   

## S3 method for class 'itemselect'
print(x, nfirstitems = 20, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="itemselect_+3A_omicdata">omicdata</code></td>
<td>
<p>An object of class <code>"microarraydata"</code>, <code>"RNAseqdata"</code>,
<code>"metabolomicdata"</code> or <code>"continuousanchoringdata"</code> respectively returned by 
functions <code>microarraydata</code>, <code>RNAseqdata</code>, 
<code>metabolomicdata</code> or <code>continuousanchoringdata</code>.</p>
</td></tr>
<tr><td><code id="itemselect_+3A_select.method">select.method</code></td>
<td>
<p><code>"quadratic"</code> for a 
quadratic trend test on dose ranks, <code>"linear"</code> for a linear trend test on dose ranks and <code>"ANOVA"</code> for 
an ANOVA-type test (see details for further explaination).</p>
</td></tr>
<tr><td><code id="itemselect_+3A_fdr">FDR</code></td>
<td>
<p>The threshold in term of FDR (False Discovery Rate) for selecting responsive items.</p>
</td></tr>
<tr><td><code id="itemselect_+3A_max.ties.prop">max.ties.prop</code></td>
<td>
<p>The maximal tolerated proportion of tied values for each item, 
above which the item cannot be selected (must be in ]0, 0.5], 
and by default fixed at 0.2 - see details for a description of this filtering step).</p>
</td></tr>
<tr><td><code id="itemselect_+3A_x">x</code></td>
<td>
<p>An object of class <code>"itemselect"</code>.</p>
</td></tr>
<tr><td><code id="itemselect_+3A_nfirstitems">nfirstitems</code></td>
<td>
<p>The maximum number of selected items to print.</p>
</td></tr>
<tr><td><code id="itemselect_+3A_...">...</code></td>
<td>
<p> further arguments passed to print function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The selection of responsive items is performed using the <code>limma</code> package
for microarray and continuous omics data (such as metabolomics), the <code>DESeq2</code> package for
RNAseq data and the <code>lm</code> function for continuous anchoring data. 
Three methods are proposed (as described below). Within <code>limma</code> those methods are implemented using functions <code>lmFit</code>,  
<code>eBayes</code> and <code>topTable</code> with p-values ajusted for multiple 
testing using the Benjamini-Hochberg method (also called q-values), with the false discovery rate given in
input (argument <code>FDR</code>). 
Within <code>DESeq2</code> those methods
are implemented using functions <code>DESeqDataSetFromMatrix</code>,  
<code>DESeq</code> and <code>results</code> with p-values ajusted for multiple 
testing using the Benjamini-Hochberg method (also called q-values), with the false discovery rate given in
input (argument <code>FDR</code>). 
For continuous anchoring data, the <code>lm</code> and <code>anova</code> functions are used 
to fit the model and compare it to the null model, and the pvalues are then corrected using
the function <code>p.adjust</code> with the Benjamini-Hochberg method.
</p>

<ul>
<li><p> The ANOVA_based test (<code>"ANOVA"</code>) is classically used for 
selection of omics data in the general case but it requires many replicates per dose
to be efficient, and is thus not really suited for a dose-response design.
</p>
</li>
<li><p> The linear trend test (<code>"linear"</code>) aims at detecting monotonic trends from dose-response designs,
whatever the number of replicates per dose. 
As proposed by Tukey (1985), it tests the global significance of
a linear model describing the response as a function of the dose in rank-scale.
</p>
</li>
<li><p> The quadratic trend test (<code>"quadratic"</code>)  
tests the global significance of a quadratic model describing the response as a function of the dose in rank-scale.
It is a variant of the linear trend method that aims at detecting monotonic and non monotonic trends from a dose-response designs, whatever the number of replicates per dose (default chosen method).
</p>
</li></ul>

<p>After the use of one this previously described tests, 
a filter based on the proportion of tied values is also performed whatever the type of data, assuming 
tied values correspond to a minimal common value at which non detections were imputed. 
All items having a proportion of such tied minimal values above the input argument
<code>max.ties.prop</code> are eliminated from the selection.
</p>


<h3>Value</h3>

 
<p><code>itemselect</code> returns an object of class <code>"itemselect"</code>, a list with 5 components:
</p>
<table>
<tr><td><code>adjpvalue</code></td>
<td>
<p> the vector of the p-values adjusted by the Benjamini-Hochberg method 
(also called q-values) for selected items 
(adjpvalue inferior to FDR) sorted in ascending order</p>
</td></tr>
<tr><td><code>selectindex</code></td>
<td>
<p> the corresponding vector of row indices of selected items in the object omicdata </p>
</td></tr>
<tr><td><code>omicdata</code></td>
<td>
<p>The corresponding object of class <code>"microarraydata"</code>,
<code>"RNAseqdata"</code>, <code>"continuousomicdata"</code> or <code>"continuousanchoringdata"</code>
given in input.</p>
</td></tr>
<tr><td><code>select.method</code></td>
<td>
<p>The selection method given in input.</p>
</td></tr>
<tr><td><code>FDR</code></td>
<td>
<p>The threshold in term of FDR given in input.</p>
</td></tr>
</table>
<p>The print of a <code>"itemselect"</code> object gives the number of selected items and the 
identifiers of the 20 most responsive items.
</p>


<h3>Author(s)</h3>

 
<p>Marie-Laure Delignette-Muller
</p>


<h3>References</h3>

 
<p>Tukey JW, Ciminera JL and Heyse JF (1985), <em>Testing the statistical certainty of a response to increasing doses of a drug</em>. Biometrics, 295-301.
</p>
<p>Ritchie ME, Phipson B, Wu D, Hu Y, Law CW, Shi W, and Smyth, GK (2015), <em>limma powers differential expression analyses for RNA-sequencing and microarray studies</em>. Nucleic Acids Research 43, e47.
</p>
<p>Love MI, Huber W, and Anders S (2014), <em>Moderated estimation of fold change and dispersion for RNA-seq data with DESeq2</em>. Genome biology, 15(12), 550.
</p>


<h3>See Also</h3>

<p>See <code>lmFit</code>, <code>eBayes</code> and <code>topTable</code>
for details about the used functions of the <code>limma</code> package and 
<code>DESeqDataSetFromMatrix</code>,
<code>DESeq</code> and <code>results</code>
for details about the used functions of the <code>DESeq2</code> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# (1) an example on a microarray data set (a subsample of a greater data set) 
#     
datafilename &lt;- system.file("extdata", "transcripto_sample.txt", package="DRomics")

(o &lt;- microarraydata(datafilename, check = TRUE, norm.method = "cyclicloess"))

# 1.a using the quadratic trend test
#
(s_quad &lt;- itemselect(o, select.method = "quadratic", FDR = 0.05))
print(s_quad, nfirstitems = 30)

# to get the names of all the selected items
(selecteditems &lt;- s_quad$omicdata$item[s_quad$selectindex]) 



# 1.b using the linear trend test
#
(s_lin &lt;- itemselect(o, select.method = "linear", FDR = 0.05))

# 1.c using the ANOVA-based test
#
(s_ANOVA &lt;- itemselect(o, select.method = "ANOVA", FDR = 0.05))

# 1.d using the quadratic trend test with a smaller false discovery rate
#
(s_quad.2 &lt;- itemselect(o, select.method = "quadratic", FDR = 0.001))


</code></pre>

<hr>
<h2 id='microarraydata'>Import, check and normalization of single-channel microarray data</h2><span id='topic+microarraydata'></span><span id='topic+omicdata'></span><span id='topic+print.microarraydata'></span><span id='topic+plot.microarraydata'></span>

<h3>Description</h3>

<p>Single-channel microarray data in log2 are imported from a .txt file 
(internally imported using the function <code><a href="utils.html#topic+read.table">read.table</a></code>), 
checked or from a R object of class <code>data.frame</code> 
(see the description 
of argument <code>file</code> for the required format
of data)and normalized (between arrays
normalization).
<code>omicdata</code> is a deprecated version of <code>microarraydata</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>microarraydata(file, backgrounddose, check = TRUE, 
  norm.method = c("cyclicloess", "quantile", "scale", "none"))
  
omicdata(file, backgrounddose, check = TRUE, 
  norm.method = c("cyclicloess", "quantile", "scale", "none"))

## S3 method for class 'microarraydata'
print(x, ...)
## S3 method for class 'microarraydata'
plot(x, range4boxplot = 1e6, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="microarraydata_+3A_file">file</code></td>
<td>
<p>The name of the .txt file (e.g. <code>"mydata.txt"</code>)
containing one row per item, with the first column corresponding to the identifier of each item, 
and the other columns giving the responses
of the item for each replicate at each dose or concentration. 
In the first line, after a name for the identifier column, we must have the tested
doses or concentrations in a numeric format for the corresponding replicate 
(for example, if there are triplicates for each treatment, 
the first line could be &quot;item&quot;, 0, 0, 0, 0.1, 0.1, 0.1, etc.). 
This file is imported within the function using the function
<code><a href="utils.html#topic+read.table">read.table</a></code> with its default field separator (sep argument) and 
its default decimal separator (dec argument at &quot;.&quot;).
Alternatively an R object of class <code>data.frame</code> can be directly given in input, 
corresponding to the output
of <code>read.table(file, header = FALSE)</code> on a file described as above. </p>
</td></tr>
<tr><td><code id="microarraydata_+3A_backgrounddose">backgrounddose</code></td>
<td>
<p>This argument must be used when there is no dose at zero in the data, to prevent the calculation of the BMD by extrapolation. All doses below  or equal to the value given in backgrounddose will be fixed at 0, so as to be considered at the background level of exposition.</p>
</td></tr>
<tr><td><code id="microarraydata_+3A_check">check</code></td>
<td>
<p>If TRUE the format of the input file is checked.</p>
</td></tr>
<tr><td><code id="microarraydata_+3A_norm.method">norm.method</code></td>
<td>
<p>If <code>"none"</code> no normalization is performed, else a 
normalization is performed using the function normalizeBetweenArrays of the 
<code>limma</code> package using the specified method.</p>
</td></tr>
<tr><td><code id="microarraydata_+3A_x">x</code></td>
<td>
<p>An object of class <code>"microarraydata"</code>.</p>
</td></tr>
<tr><td><code id="microarraydata_+3A_range4boxplot">range4boxplot</code></td>
<td>
<p>An argument passed to boxplot(), fixed by default at 1e6 
to prevent the producing of very large plot files due to many outliers. 
Can be put at 1.5 to obtain more classical boxplots.</p>
</td></tr>
<tr><td><code id="microarraydata_+3A_...">...</code></td>
<td>
<p> further arguments passed to print or plot functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function imports the data, checks their format (see the description 
of argument <code>file</code> for the required format
of data) and gives in the <code>print</code> information
that should help the user to check that the coding of data is correct : the tested doses (or concentrations) 
the number of replicates for each dose, the number of items, the identifiers 
of the first 20 items. If the argument <code>norm.method</code> is not <code>"none"</code>,
data are normalized using the function <code>normalizeBetweenArrays</code> of the 
<code>limma</code> package using the specified method : <code>"cyclicloess"</code> (default choice), 
<code>"quantile"</code> or <code>"scale"</code>.
</p>


<h3>Value</h3>

 
<p><code>microarraydata</code> returns an object of class &quot;microarraydata&quot;, a list with 7 components:
</p>
<table>
<tr><td><code>data</code></td>
<td>
<p> the numeric matrix of normalized responses of each item in each replicate
(one line per item, one column per replicate)  </p>
</td></tr>
<tr><td><code>dose</code></td>
<td>
<p> the numeric vector of the tested doses or concentrations corresponding
to each column of data</p>
</td></tr>
<tr><td><code>item</code></td>
<td>
<p> the character vector of the identifiers of the items, corresponding to
each line of data</p>
</td></tr>
<tr><td><code>design</code></td>
<td>
<p> a table with the experimental design (tested doses and number of 
replicates for each dose) for control by the user</p>
</td></tr>
<tr><td><code>data.mean</code></td>
<td>
<p> the numeric matrix of mean responses of each item per dose (mean 
of the corresponding replicates) (one line per item, one column per unique value 
of the dose</p>
</td></tr>
<tr><td><code>norm.method</code></td>
<td>
<p>The normalization method specified in input</p>
</td></tr>
<tr><td><code>data.beforenorm</code></td>
<td>
<p> the numeric matrix of responses of each item in each replicate
(one line per item, one column per replicate) before normalization  </p>
</td></tr>
<tr><td><code>containsNA</code></td>
<td>
<p>always at FALSE as microarray data are not allowed to contain 
NA values</p>
</td></tr>
</table>
<p>The print of a <code>microarraydata</code> object gives the tested doses (or concentrations) 
and number of replicates for each dose, the number of items, the identifiers 
of the first 20 items (for check of good coding of data) and the normalization method.
The plot of a <code>microarraydata</code> object shows the data distribution for each dose or concentration and replicate before and after normalization.
</p>


<h3>Author(s)</h3>

 
<p>Marie-Laure Delignette-Muller
</p>


<h3>References</h3>

 
<p>Ritchie ME, Phipson B, Wu D, Hu Y, Law CW, Shi W, and Smyth, GK (2015), <em>limma powers differential expression analyses for RNA-sequencing and microarray studies</em>. Nucleic Acids Research 43, e47.
</p>


<h3>See Also</h3>

<p>See <code><a href="utils.html#topic+read.table">read.table</a></code> the function used to import data, 
<code>normalizeBetweenArrays</code> for details about the normalization and 
<code><a href="#topic+RNAseqdata">RNAseqdata</a></code>, <code><a href="#topic+continuousomicdata">continuousomicdata</a></code> and
<code><a href="#topic+continuousanchoringdata">continuousanchoringdata</a></code> for other types of data.</p>


<h3>Examples</h3>

<pre><code class='language-R'># (1) import, check and normalization of microarray data 
# (an example on a subsample of a greater data set published in Larras et al. 2018
# Transcriptomic effect of triclosan in the chlorophyte Scenedesmus vacuolatus)
datafilename &lt;- system.file("extdata", "transcripto_very_small_sample.txt", 
  package="DRomics")
o &lt;- microarraydata(datafilename, check = TRUE, norm.method = "cyclicloess")
print(o)
plot(o)
PCAdataplot(o)
PCAdataplot(o, label = TRUE)


# If you want to use your own data set just replace datafilename, 
# the first argument of microarraydata(), 
# by the name of your data file (e.g. "mydata.txt")
# 
# You should take care that the field separator of this data file is one
# of the default field separators recognised by the read.table() function
# when it is used with its default field separator (sep argument)
# Tabs are recommended.



# (2) normalization with other methods
(o.2 &lt;- microarraydata(datafilename, check = TRUE, norm.method = "quantile"))
plot(o.2)
(o.3 &lt;- microarraydata(datafilename, check = TRUE, norm.method = "scale"))
plot(o.3)


</code></pre>

<hr>
<h2 id='PCAdataplot'>Performs and plots the results of a PCA on omic data</h2><span id='topic+PCAdataplot'></span>

<h3>Description</h3>

<p>Provides a two dimensional plot (two first components) of a principal 
component analysis (PCA) performed on omic data after normalization
and/or transformation, to check the promiximity of samples exposed
to the same dose and optionally the presence/absence of 
a potential batch effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCAdataplot(omicdata, batch, label)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PCAdataplot_+3A_omicdata">omicdata</code></td>
<td>
<p>An object of class <code>"microarraydata"</code>, <code>"RNAseqdata"</code> or
<code>"continuousomicdata"</code> respectively returned by 
functions <code>microarraydata</code>, <code>RNAseqdata</code> or
<code>continuousomicdata</code>.</p>
</td></tr>
<tr><td><code id="PCAdataplot_+3A_batch">batch</code></td>
<td>
<p>Optionnally a factor coding for a potential batch effect
(factor of length the number of samples in the dataset).</p>
</td></tr>
<tr><td><code id="PCAdataplot_+3A_label">label</code></td>
<td>
<p>Could be FALSE (default choice), TRUE or a character vector defining 
the sample names. In the two last cases, the points are replaced  
by labels of samples (so the batch 
cannot be identified by the shape of points, but may appear in the sample names.</p>
</td></tr>
</table>


<h3>Value</h3>

 
<p>a ggplot object.
</p>


<h3>Author(s)</h3>

 
<p>Marie-Laure Delignette-Muller
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# (1) on a microarray dataset
# 
datafilename &lt;- system.file("extdata", "transcripto_very_small_sample.txt", 
  package="DRomics")
o &lt;- microarraydata(datafilename, check = TRUE, norm.method = "cyclicloess")
print(o)
plot(o)
PCAdataplot(o)
PCAdataplot(o, label = TRUE)
samplenames &lt;- paste("sample", 1:ncol(o$data), sep = "")
PCAdataplot(o, label = samplenames)



# (2) an example on an RNAseq dataset with a potential batch effect 
#
data(zebraf)
str(zebraf)
data4DRomics &lt;- formatdata4DRomics(signalmatrix = zebraf$counts, 
                           dose = zebraf$dose)
o &lt;- RNAseqdata(data4DRomics, transfo.method = "vst")
PCAdataplot(o, batch = zebraf$batch)
PCAdataplot(o, label = TRUE)


</code></pre>

<hr>
<h2 id='RNAseqdata'>Import, check and normalization and transformation of RNAseq data</h2><span id='topic+RNAseqdata'></span><span id='topic+print.RNAseqdata'></span><span id='topic+plot.RNAseqdata'></span>

<h3>Description</h3>

<p>RNAseq data in raw counts (integer values) are imported from a .txt file 
(internally imported using the function <code><a href="utils.html#topic+read.table">read.table</a></code>), 
checked or from a R object of class <code>data.frame</code> 
(see the description 
of argument <code>file</code> for the required format
of data), 
normalized with respect to library size and tranformed in 
a log2 scale using
variance stabilizing transformation or regularized logarithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RNAseqdata(file, backgrounddose, check = TRUE, transfo.method, 
          transfo.blind = TRUE, round.counts = FALSE)

## S3 method for class 'RNAseqdata'
print(x, ...)
## S3 method for class 'RNAseqdata'
plot(x, range4boxplot = 1e6, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RNAseqdata_+3A_file">file</code></td>
<td>
<p>The name of the .txt file (e.g. <code>"mydata.txt"</code>)
containing one row per item, with the first column corresponding to the identifier of each item, 
and the other columns giving the responses
of the item for each replicate at each dose or concentration. 
In the first line, after a name for the identifier column, we must have the tested
doses or concentrations in a numeric format for the corresponding replicate 
(for example, if there are triplicates for each treatment, 
the first line could be &quot;item&quot;, 0, 0, 0, 0.1, 0.1, 0.1, etc.). 
This file is imported within the function using the function
<code><a href="utils.html#topic+read.table">read.table</a></code> with its default field separator (sep argument) and 
its default decimal separator (dec argument at &quot;.&quot;).
Alternatively an R object of class <code>data.frame</code> can be directly given in input, 
corresponding to the output
of <code>read.table(file, header = FALSE)</code> on a file described as above. The two
alternatives are illustrated below in examples.</p>
</td></tr>
<tr><td><code id="RNAseqdata_+3A_backgrounddose">backgrounddose</code></td>
<td>
<p>This argument must be used when there is no dose at zero in the data, to prevent the calculation of the BMD by extrapolation. All doses below  or equal to the value given in backgrounddose will be fixed at 0, so as to be considered at the background level of exposition.</p>
</td></tr>
<tr><td><code id="RNAseqdata_+3A_check">check</code></td>
<td>
<p>If TRUE the format of the input file is checked.</p>
</td></tr>
<tr><td><code id="RNAseqdata_+3A_transfo.method">transfo.method</code></td>
<td>
<p>The method chosen to transform raw counts in a log2 scale
using the
<code>DESeq2</code>: <code>"rlog"</code> for regularized logarithm or
<code>"vst"</code> for variance stabilizing transformation. If missing, default value
defined at <code>"rlog"</code> for datasets with less than 30 samples and at <code>"vst"</code> if not</p>
</td></tr>
<tr><td><code id="RNAseqdata_+3A_transfo.blind">transfo.blind</code></td>
<td>
<p>Argument given to function <code>rlog</code> or <code>vst</code>,
see <code>rlog</code> and <code>vst</code> for an explaination, by default
at <code>TRUE</code> as in the <code>DESeq2</code> package .</p>
</td></tr>
<tr><td><code id="RNAseqdata_+3A_round.counts">round.counts</code></td>
<td>
<p>Put it to TRUE if your counts come from Kallisto or Salmon
in order to round them before treatment with <code>DESeq2</code>.</p>
</td></tr>
<tr><td><code id="RNAseqdata_+3A_x">x</code></td>
<td>
<p>An object of class <code>"RNAseqdata"</code>.</p>
</td></tr>
<tr><td><code id="RNAseqdata_+3A_range4boxplot">range4boxplot</code></td>
<td>
<p>An argument passed to boxplot(), fixed by default at 1e6 
to prevent the producing of very large plot files due to many outliers. 
Can be put at 1.5 to obtain more classical boxplots.</p>
</td></tr>
<tr><td><code id="RNAseqdata_+3A_...">...</code></td>
<td>
<p> further arguments passed to print or plot functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function imports the data, checks their format (see the description 
of argument <code>file</code> for the required format
of data) and gives in the <code>print</code> information
that should help the user to check that the coding of data is correct : the tested doses (or concentrations) 
the number of replicates for each dose, the number of items, the identifiers 
of the first 20 items. Data are normalized with respect to library size
and tranformed using functions <code>rlog</code> or <code>vst</code> of the 
<code>DESeq2</code> package depending on the specified method : <code>"rlog"</code> 
(recommended default choice) or 
<code>"vst"</code>.
</p>


<h3>Value</h3>

 
<p><code>RNAseqdata</code> returns an object of class &quot;RNAseqdata&quot;, a list with 7 components:
</p>
<table>
<tr><td><code>data</code></td>
<td>
<p> the numeric matrix of normalized and transformed
responses of each item in each replicate
(one line per item, one column per replicate)  </p>
</td></tr>
<tr><td><code>dose</code></td>
<td>
<p> the numeric vector of the tested doses or concentrations corresponding
to each column of data</p>
</td></tr>
<tr><td><code>item</code></td>
<td>
<p> the character vector of the identifiers of the items, corresponding to
each line of data</p>
</td></tr>
<tr><td><code>design</code></td>
<td>
<p> a table with the experimental design (tested doses and number of 
replicates for each dose) for control by the user</p>
</td></tr>
<tr><td><code>data.mean</code></td>
<td>
<p> the numeric matrix of mean responses of each item per dose (mean 
of the corresponding replicates) (one line per item, one column per unique value 
of the dose</p>
</td></tr>
<tr><td><code>transfo.method</code></td>
<td>
<p>The transformation method specified in input</p>
</td></tr>
<tr><td><code>raw.counts</code></td>
<td>
<p> the numeric matrix of non transformed responses (raw counts)
of each item in each replicate
(one line per item, one column per replicate) before normalization  </p>
</td></tr>
<tr><td><code>containsNA</code></td>
<td>
<p>always at FALSE as RNAseq data are not allowed to contain 
NA values</p>
</td></tr>
</table>
<p>The print of a <code>RNAseqdata</code> object gives the tested doses (or concentrations) 
and number of replicates for each dose, the number of items, the identifiers 
of the first 20 items (for check of good coding of data) and the tranformation method.
The plot of a <code>RNAseqdata</code> object shows the data distribution for each dose or concentration and replicate before and after normalization and tranformation.
</p>


<h3>Author(s)</h3>

 
<p>Marie-Laure Delignette-Muller
</p>


<h3>References</h3>

 
<p>Love MI, Huber W, and Anders S (2014), <em>Moderated estimation of fold change and dispersion for RNA-seq data with DESeq2</em>. Genome biology, 15(12), 550.</p>


<h3>See Also</h3>

<p>See <code><a href="utils.html#topic+read.table">read.table</a></code> the function used to import data,
<code>rlog</code> and <code>vst</code> for details about the 
transformation methods and 
<code><a href="#topic+microarraydata">microarraydata</a></code>, <code><a href="#topic+continuousomicdata">continuousomicdata</a></code> and
<code><a href="#topic+continuousanchoringdata">continuousanchoringdata</a></code> for other types of data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># (1) import, check, normalization and transformation of RNAseq data 
# An example on a subsample of a data set published by Zhou et al. 2017
# Effect on mouse kidney transcriptomes of tetrachloroethylene
# (see ? Zhou for details)
#
datafilename &lt;- system.file("extdata", "RNAseq_sample.txt", package="DRomics")
(o &lt;- RNAseqdata(datafilename, check = TRUE, transfo.method = "vst"))
plot(o)

# If you want to use your own data set just replace datafilename, 
# the first argument of RNAseqdata(), 
# by the name of your data file (e.g. "mydata.txt")
# 
# You should take care that the field separator of this data file is one
# of the default field separators recognised by the read.table() function
# when it is used with its default field separator (sep argument)
# Tabs are recommended.

# Use of an R object of class data.frame
# below the same example taking a subsample of the data set
# Zhou_kidney_pce (see ?Zhou for details)
data(Zhou_kidney_pce)
subsample &lt;- Zhou_kidney_pce[1:1000, ]
(o &lt;- RNAseqdata(subsample, check = TRUE, transfo.method = "vst"))
plot(o)
PCAdataplot(o)


# (2) transformation with two methods on the whole data set

data(Zhou_kidney_pce)

# variance stabilizing tranformation
(o1 &lt;- RNAseqdata(Zhou_kidney_pce, check = TRUE, transfo.method = "vst"))
plot(o1)

# regularized logarithm
(o2 &lt;- RNAseqdata(Zhou_kidney_pce, check = TRUE, transfo.method = "rlog"))
plot(o2)

# variance stabilizing tranformation (blind to the experimental design)
(o3 &lt;- RNAseqdata(Zhou_kidney_pce, check = TRUE, transfo.method = "vst",
      transfo.blind = TRUE))
plot(o3)

# regularized logarithm
(o4 &lt;- RNAseqdata(Zhou_kidney_pce, check = TRUE, transfo.method = "rlog",
      transfo.blind = TRUE))
plot(o4)




</code></pre>

<hr>
<h2 id='Scenedesmus'>Concentration-response effect of triclosan in Scenedesmus vacuolatus</h2><span id='topic+Scenedesmus'></span><span id='topic+Scenedesmus_metab'></span><span id='topic+Scenedesmus_apical'></span>

<h3>Description</h3>

<p>Metabolomic and apical data sets for the effect of triclosan in the chlorophyte Scenedesmus vacuolatus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Scenedesmus_metab)
data(Scenedesmus_apical)
</code></pre>


<h3>Format</h3>

 
<p><code>Scenedesmus_metab</code> contains one row per metabolite, with the first column corresponding to the identifier of each metabolite, and the other columns giving the log10 tranformed area under the curve for each 
replicate at each concentration. 
In the first line, after the name for the identifier column, we have the tested concentrations for each corresponding replicate.
</p>
<p><code>Scenedesmus_apical</code> contains one row per apical endpoint, with the first column corresponding to the identifier of each endpoint, and the other columns giving the measured
value of this each endpoint for each 
replicate at each concentration. 
In the first line, after the name for the identifier column, we have the tested concentrations for each corresponding replicate.
</p>


<h3>Source</h3>

 
<p>Larras, F., Billoir, E., Scholz, S., Tarkka, M., Wubet, T., Delignette-Muller, M. L., &amp; Schmitt-Jansen, M. (2020). A multi-omics concentration-response framework uncovers novel understanding of triclosan effects in the chlorophyte Scenedesmus vacuolatus. <em>Journal of Hazardous Materials</em>, 122727.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># (1.1) load of metabolomics data
#
data(Scenedesmus_metab)
head(Scenedesmus_metab)
str(Scenedesmus_metab)



# (1.2) import and check of metabolomics data
#
(o_metab &lt;- continuousomicdata(Scenedesmus_metab))
plot(o_metab)

# (2.1) load of apical data
#
data(Scenedesmus_apical)
head(Scenedesmus_apical)
str(Scenedesmus_apical)

# (2.2) import and check of apical data
#
(o_apical &lt;- continuousanchoringdata(Scenedesmus_apical, backgrounddose = 0.1))
# It is here necessary to define the background dose as there is no dose at 0 in the data
# The BMD cannot be computed without defining the background level
plot(o_apical)

# (2.3) selection of responsive endpoints on apical data
#
(s_apical &lt;- itemselect(o_apical, select.method = "quadratic", FDR = 0.05))

# (2.4) fit of dose-response models on apical data
#
(f_apical &lt;- drcfit(s_apical, progressbar = TRUE))
f_apical$fitres
plot(f_apical) 
plot(f_apical, dose_log_trans = TRUE)
plot(f_apical, plot.type = "dose_residuals")

# (2.5) Benchmark dose calculation on apical data
#
r_apical &lt;- bmdcalc(f_apical, z = 1)
r_apical$res



</code></pre>

<hr>
<h2 id='selectgroups'>Selection of groups on which to focus</h2><span id='topic+selectgroups'></span>

<h3>Description</h3>

<p>Selection of groups (e.g. corresponding to different biological annotations)
on which to focus,
based on their sensitivity (BMD summary value) and their representativeness
(number of items in each group).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectgroups(extendedres, group, explev,
   BMDmax, BMDtype = c("zSD", "xfold"), 
   BMDsummary = c("first.quartile", "median" ),
   nitemsmin = 3, keepallexplev = FALSE)
   
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectgroups_+3A_extendedres">extendedres</code></td>
<td>
<p>the dataframe of results provided by drcfit (fitres)
or bmdcalc (res) 
or a subset of this data frame (selected lines). This dataframe should be extended 
with additional columns coming for the group (for example from the biological
annotation of items) and optionnally for another experimental level 
(for example the molecular level),
and some lines 
can be replicated if their corresponding item has more than one annotation.</p>
</td></tr>
<tr><td><code id="selectgroups_+3A_group">group</code></td>
<td>
<p>the name of the column of <code>extendedres</code> coding for the groups.</p>
</td></tr>
<tr><td><code id="selectgroups_+3A_explev">explev</code></td>
<td>
<p>optional argument naming the column of <code>extendedres</code> 
coding for the experimental level.</p>
</td></tr>
<tr><td><code id="selectgroups_+3A_bmdmax">BMDmax</code></td>
<td>
<p>maximum for the BMD summary value used to limit the groups to 
the most sensitive 
(optional input : if missing there is no selection based on the BMD).</p>
</td></tr>
<tr><td><code id="selectgroups_+3A_bmdtype">BMDtype</code></td>
<td>
<p>the type of BMD used for the selection on the BMD, 
<code>"zSD"</code> (default choice) or <code>"xfold"</code>.</p>
</td></tr>
<tr><td><code id="selectgroups_+3A_bmdsummary">BMDsummary</code></td>
<td>
<p>the type of summary used for the selection based on the BMD, 
<code>"first.quartile"</code> (default choice of the first quartile of BMD values per group)
or <code>"median"</code> (for choice of median of BMD values per group).</p>
</td></tr>
<tr><td><code id="selectgroups_+3A_nitemsmin">nitemsmin</code></td>
<td>
<p>minimum for the number of items per group to limit the groups
to the most represented (can be put at 1 if you do not want to select on this
number: not recommended.</p>
</td></tr>
<tr><td><code id="selectgroups_+3A_keepallexplev">keepallexplev</code></td>
<td>
<p>If TRUE (default value at FALSE), if a group is selected
for at least one experimental level, it will be kept in the selection at all 
the experimental levels.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will provide a subset of the input <code>extendedres</code> corresponding
to groups for which the number of items representing the group is greater 
than or equal to 
<code>nitemsmin</code> and if <code>BMDmax</code> is secified, 
for which the BMD summary value is less than or equal to <code>BMDmax</code>.
When there is more than one experimental level (<code>explev</code> specified), 
the selection of groups 
is made separately at each experimental level: so a group may be selected
at one experimental level and removed at another one.
This function eliminates rows with NA values for the chosen BMD 
(of <code>BMDtype</code>) before performing the the selection.
</p>


<h3>Value</h3>

 
<p>a dataframe corresponding to a subset of extendedres given in input, that 
can be used for further exploration using for example <code><a href="#topic+bmdplot">bmdplot</a></code>,
<code><a href="#topic+bmdplotwithgradient">bmdplotwithgradient</a></code>,
<code><a href="#topic+trendplot">trendplot</a></code> and <code><a href="#topic+sensitivityplot">sensitivityplot</a></code>.
</p>


<h3>Author(s)</h3>

 
<p>Marie-Laure Delignette-Muller
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+bmdfilter">bmdfilter</a></code>, <code><a href="#topic+bmdplot">bmdplot</a></code>, <code><a href="#topic+bmdplotwithgradient">bmdplotwithgradient</a></code>, 
<code><a href="#topic+trendplot">trendplot</a></code> and <code><a href="#topic+sensitivityplot">sensitivityplot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# (1)

# An example from the paper published by Larras et al. 2020
# in Journal of Hazardous Materials
# https://doi.org/10.1016/j.jhazmat.2020.122727

# the dataframe with metabolomic results 
resfilename &lt;- system.file("extdata", "triclosanSVmetabres.txt", package="DRomics")
res &lt;- read.table(resfilename, header = TRUE, stringsAsFactors = TRUE)
str(res)

# the dataframe with annotation of each item identified in the previous file
# each item may have more than one annotation (-&gt; more than one line)
annotfilename &lt;- system.file("extdata", "triclosanSVmetabannot.txt", package="DRomics")
annot &lt;- read.table(annotfilename, header = TRUE, stringsAsFactors = TRUE)
str(annot)

# Merging of both previous dataframes
# in order to obtain an extenderes dataframe
extendedres &lt;- merge(x = res, y = annot, by.x = "id", by.y = "metab.code")
head(extendedres)


# (1) Sensitivity by pathway
# (1.a) before selection
sensitivityplot(extendedres, BMDtype = "zSD",
                group = "path_class", 
                BMDsummary = "first.quartile")
# (1.b) after selection on representativeness
extendedres.b &lt;- selectgroups(extendedres, 
                         group = "path_class", 
                         nitemsmin = 10)
sensitivityplot(extendedres.b, BMDtype = "zSD",
                group = "path_class", 
                BMDsummary = "first.quartile")
                

# (1.c) after selection on sensitivity
extendedres.c &lt;- selectgroups(extendedres, 
                         group = "path_class", 
                         BMDmax = 1.25, 
                         BMDtype = "zSD", 
                         BMDsummary = "first.quartile",
                         nitemsmin = 1)
sensitivityplot(extendedres.c, BMDtype = "zSD",
                group = "path_class", 
                BMDsummary = "first.quartile")

# (1.d) after selection on representativeness and sensitivity 
extendedres.d &lt;- selectgroups(extendedres, 
                         group = "path_class", 
                         BMDmax = 1.25, 
                         BMDtype = "zSD", 
                         BMDsummary = "first.quartile",
                         nitemsmin = 10)
sensitivityplot(extendedres.d, BMDtype = "zSD",
                group = "path_class", 
                BMDsummary = "first.quartile")

# (2) 
# An example with two molecular levels
#
### Rename metabolomic results
metabextendedres &lt;- extendedres

# Import the dataframe with transcriptomic results 
contigresfilename &lt;- system.file("extdata", "triclosanSVcontigres.txt", package = "DRomics")
contigres &lt;- read.table(contigresfilename, header = TRUE, stringsAsFactors = TRUE)
str(contigres)

# Import the dataframe with functional annotation (or any other descriptor/category 
# you want to use, here KEGG pathway classes) 
contigannotfilename &lt;- system.file("extdata", "triclosanSVcontigannot.txt", package = "DRomics")
contigannot &lt;- read.table(contigannotfilename, header = TRUE, stringsAsFactors = TRUE)
str(contigannot)

# Merging of both previous dataframes   
contigextendedres &lt;- merge(x = contigres, y = contigannot, by.x = "id", by.y = "contig")
# to see the structure of this dataframe
str(contigextendedres)

### Merge metabolomic and transcriptomic results
extendedres &lt;- rbind(metabextendedres, contigextendedres)
extendedres$molecular.level &lt;- factor(c(rep("metabolites", nrow(metabextendedres)),
                              rep("contigs", nrow(contigextendedres))))
str(extendedres)

# optional inverse alphabetic ordering of groups for the plot
extendedres$path_class &lt;- factor(extendedres$path_class, 
                levels = sort(levels(extendedres$path_class), decreasing = TRUE))
### (2.1) sensitivity plot of both molecular levels before and after selection of 
#   most sensitive groups
sensitivityplot(extendedres, BMDtype = "zSD",
                group = "path_class", colorby = "molecular.level",
                BMDsummary = "first.quartile")
extendedres.2 &lt;- selectgroups(extendedres, 
                         group = "path_class",
                         explev = "molecular.level",
                         BMDmax = 1, 
                         BMDtype = "zSD", 
                         BMDsummary = "first.quartile",
                         nitemsmin = 1)
sensitivityplot(extendedres.2, BMDtype = "zSD",
                group = "path_class", , colorby = "molecular.level",
                BMDsummary = "first.quartile")
### (2.2) same selection but keeping all the experimental as soon
# as the selection criterion is met for at least one experimental level
extendedres.3 &lt;- selectgroups(extendedres, 
                         group = "path_class",
                         explev = "molecular.level",
                         BMDmax = 1, 
                         BMDtype = "zSD", 
                         BMDsummary = "first.quartile",
                         nitemsmin = 1,
                         keepallexplev = TRUE)
extendedres.2
extendedres.3
sensitivityplot(extendedres.3, BMDtype = "zSD",
                group = "path_class", colorby = "molecular.level",
                BMDsummary = "first.quartile")




</code></pre>

<hr>
<h2 id='sensitivityplot'>Plot of a summary of BMD values per group of items</h2><span id='topic+sensitivityplot'></span>

<h3>Description</h3>

<p>Plot of a summary of BMD values per group of items 
(with groups defined for example from biological annotation), 
with groups ordered by values of the chosen summary (as an ECDF plot)
or ordered as they are in the definition of the factor coding for them,
with points sized by the numbers of items per group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sensitivityplot(extendedres, BMDtype = c("zSD", "xfold"),
                group, ECDF_plot = TRUE, colorby,
                BMDsummary = c("first.quartile", "median" , "median.and.IQR"),
                BMD_log_transfo = TRUE,
                line.size = 0.5, line.alpha = 0.5, point.alpha = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sensitivityplot_+3A_extendedres">extendedres</code></td>
<td>
<p>the dataframe of results provided by bmdcalc (res)  
or a subset of this data frame (selected lines). This dataframe can be extended 
with additional columns coming for example from the annotation of items, and some lines 
can be replicated if their corresponding item has more than one annotation. 
This extended dataframe
must at least contain the column giving the chosen BMD values
on which to compute the sensitivity (column <code>BMD.zSD</code> or <code>BMD.xfold</code>).</p>
</td></tr>
<tr><td><code id="sensitivityplot_+3A_bmdtype">BMDtype</code></td>
<td>
<p>The type of BMD used, <code>"zSD"</code> (default choice) or <code>"xfold"</code>.</p>
</td></tr>
<tr><td><code id="sensitivityplot_+3A_group">group</code></td>
<td>
<p>the name of the column of extendedres coding for the groups
on which we want to estimate a global sensitivity. 
If <code>ECDF_plot</code> is FALSE, this column should be a factor ordered as you want 
the groups to appear in the plot from bottom up.</p>
</td></tr>
<tr><td><code id="sensitivityplot_+3A_ecdf_plot">ECDF_plot</code></td>
<td>
<p>if TRUE (default choice) groups appear ordered by 
values of the BMD summary value
from the bottom up, else they are ordered as their corresponding levels in the factor
given in <code>group</code>. If <code>colorby</code> is given, <code>ECDF_plot</code> is fixed to FALSE.</p>
</td></tr>
<tr><td><code id="sensitivityplot_+3A_colorby">colorby</code></td>
<td>
<p>optional argument naming the column of <code>extendedres</code> coding for 
an additional level of grouping that will be materialized by the color. 
If not missing,  <code>ECDF_plot</code> is fixed to FALSE.</p>
</td></tr>
<tr><td><code id="sensitivityplot_+3A_bmdsummary">BMDsummary</code></td>
<td>
<p>The type of summary used for sensitivity plot, 
<code>"first.quartile"</code> (default choice)
for the plot of first quartiles of BMD values per group, 
<code>"median"</code> for the plot of medians of BMD values per group
and <code>"median.and.IQR"</code> for the plot of medians with an interval corresponding
to the inter-quartile range (IQR).</p>
</td></tr>
<tr><td><code id="sensitivityplot_+3A_bmd_log_transfo">BMD_log_transfo</code></td>
<td>
<p>If TRUE, default choice, a log transformation of the BMD is used in the plot.</p>
</td></tr>
<tr><td><code id="sensitivityplot_+3A_line.size">line.size</code></td>
<td>
<p>Width of the lines.</p>
</td></tr>
<tr><td><code id="sensitivityplot_+3A_line.alpha">line.alpha</code></td>
<td>
<p>Transparency of the lines.</p>
</td></tr>
<tr><td><code id="sensitivityplot_+3A_point.alpha">point.alpha</code></td>
<td>
<p>Transparency of the points.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The chosen summary is calculated on the BMD values for each group 
(groups can be for example defined as pathways from biological annotation of items)
and plotted as an ECDF plot (ordered by the BMD summary) or in the order of the levels of the factor defining
the groups from bottom to up. In this plot each point is sized according to the number of items in the corresponding group. Optionally a different levels 
(e.g. different molecular levels in a multi-omics approach) can be coded by different colors.</p>


<h3>Value</h3>

 
<p>a ggplot object.
</p>


<h3>Author(s)</h3>

 
<p>Marie-Laure Delignette-Muller
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+ecdfquantileplot">ecdfquantileplot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# (1) An example from data published by Larras et al. 2020
# in Journal of Hazardous Materials
# https://doi.org/10.1016/j.jhazmat.2020.122727

# a dataframe with metabolomic results (output $res of bmdcalc() or bmdboot() functions)
resfilename &lt;- system.file("extdata", "triclosanSVmetabres.txt", package="DRomics")
res &lt;- read.table(resfilename, header = TRUE, stringsAsFactors = TRUE)
str(res)

# a dataframe with annotation of each item identified in the previous file
# each item may have more than one annotation (-&gt; more than one line)
annotfilename &lt;- system.file("extdata", "triclosanSVmetabannot.txt", package="DRomics")
annot &lt;- read.table(annotfilename, header = TRUE, stringsAsFactors = TRUE)
str(annot)

# Merging of both previous dataframes
# in order to obtain an extenderes dataframe
# bootstrap results and annotation
annotres &lt;- merge(x = res, y = annot, by.x = "id", by.y = "metab.code")
head(annotres)

### an ECDFplot of 25th quantiles of BMD-zSD calculated by pathway
sensitivityplot(annotres, BMDtype = "zSD",
                            group = "path_class", 
                            BMDsummary = "first.quartile")



# same plot in raw BMD scale (so not in log scale) 
sensitivityplot(annotres, BMDtype = "zSD",
                            group = "path_class",  
                            BMDsummary = "first.quartile",
                            BMD_log_transfo = FALSE)

### Plot of 25th quantiles of BMD-zSD calculated by pathway
### in the order of the levels as defined in the group input
levels(annotres$path_class)
sensitivityplot(annotres, BMDtype = "zSD",
                            group = "path_class", ECDF_plot = FALSE, 
                            BMDsummary = "first.quartile")

### an ECDFplot of medians of BMD-zSD calculated by pathway
sensitivityplot(annotres, BMDtype = "zSD",
                            group = "path_class",  
                            BMDsummary = "median")

### an ECDFplot of medians of BMD-zSD calculated by pathway
### with addition of interquartile ranges (IQRs) 
sensitivityplot(annotres, BMDtype = "zSD",
                            group = "path_class",  
                            BMDsummary = "median.and.IQR") 

### The same plot playing with graphical parameters 
sensitivityplot(annotres, BMDtype = "zSD",
                            group = "path_class",  
                            BMDsummary = "median.and.IQR",
                            line.size = 1.5, line.alpha = 0.4, point.alpha = 1) 
                           

# (2) 
# An example with two molecular levels
#
### Rename metabolomic results
metabextendedres &lt;- annotres

# Import the dataframe with transcriptomic results 
contigresfilename &lt;- system.file("extdata", "triclosanSVcontigres.txt", package = "DRomics")
contigres &lt;- read.table(contigresfilename, header = TRUE, stringsAsFactors = TRUE)
str(contigres)

# Import the dataframe with functional annotation (or any other descriptor/category 
# you want to use, here KEGG pathway classes) 
contigannotfilename &lt;- system.file("extdata", "triclosanSVcontigannot.txt", package = "DRomics")
contigannot &lt;- read.table(contigannotfilename, header = TRUE, stringsAsFactors = TRUE)
str(contigannot)

# Merging of both previous dataframes   
contigextendedres &lt;- merge(x = contigres, y = contigannot, by.x = "id", by.y = "contig")
# to see the structure of this dataframe
str(contigextendedres)

### Merge metabolomic and transcriptomic results
extendedres &lt;- rbind(metabextendedres, contigextendedres)
extendedres$molecular.level &lt;- factor(c(rep("metabolites", nrow(metabextendedres)),
                              rep("contigs", nrow(contigextendedres))))
str(extendedres)

### Plot of 25th quantiles of BMD-zSD calculated by pathway
### and colored by molecular level
# optional inverse alphabetic ordering of groups for the plot
extendedres$path_class &lt;- factor(extendedres$path_class, 
                levels = sort(levels(extendedres$path_class), 
                decreasing = TRUE))
sensitivityplot(extendedres, BMDtype = "zSD",
                            group = "path_class", colorby = "molecular.level", 
                            BMDsummary = "first.quartile")

### Plot of medians and IQRs of BMD-zSD calculated by pathway
### and colored by molecular level
sensitivityplot(extendedres, BMDtype = "zSD",
                            group = "path_class", colorby = "molecular.level", 
                            BMDsummary = "median.and.IQR",
                            line.size = 1.2, line.alpha = 0.4, 
                            point.alpha = 0.8) 


</code></pre>

<hr>
<h2 id='targetplot'>Dose-reponse plot for target items</h2><span id='topic+targetplot'></span>

<h3>Description</h3>

<p>Plots dose-response raw data of target items (whether or not their response is considered significant)
with fitted curves if available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>targetplot(items, f, add.fit = TRUE, dose_log_transfo = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="targetplot_+3A_items">items</code></td>
<td>
<p>A character vector
specifying the identifiers of the items to plot.</p>
</td></tr>
<tr><td><code id="targetplot_+3A_f">f</code></td>
<td>
<p>An object of class <code>"drcfit"</code>.</p>
</td></tr>
<tr><td><code id="targetplot_+3A_add.fit">add.fit</code></td>
<td>
<p>If <code>TRUE</code> the fitted curve is added for items which were selected as responsive items 
and for which a best fit model was obtained.</p>
</td></tr>
<tr><td><code id="targetplot_+3A_dose_log_transfo">dose_log_transfo</code></td>
<td>
<p>If <code>TRUE</code>, default choice, a log transformation is used on the dose axis.</p>
</td></tr>
</table>


<h3>Value</h3>

 
<p>a ggplot object.
</p>


<h3>Author(s)</h3>

 
<p>Marie-Laure Delignette-Muller
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+plot.drcfit">plot.drcfit</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# A toy example on a very small subsample of a microarray data set) 
#
datafilename &lt;- system.file("extdata", "transcripto_very_small_sample.txt", 
package="DRomics")

o &lt;- microarraydata(datafilename, check = TRUE, norm.method = "cyclicloess")
s_quad &lt;- itemselect(o, select.method = "quadratic", FDR = 0.01)
f &lt;- drcfit(s_quad, progressbar = TRUE)

# Plot of chosen items with fitted curves when available 
#
targetitems &lt;- c("88.1", "1", "3", "15")
targetplot(targetitems, f = f)



# The same plot in raw scale instead of default log scale
#
targetplot(targetitems, f = f, dose_log_transfo = FALSE)

# The same plot in x log scale choosing x limits for plot
if (require(ggplot2))
targetplot(targetitems, f = f, dose_log_transfo = TRUE) + 
        scale_x_log10(limits = c(0.1, 10))

# The same plot without fitted curves 
#
targetplot(targetitems, f = f, add.fit = FALSE)


</code></pre>

<hr>
<h2 id='trendplot'>Plot of the repartition of trends per group</h2><span id='topic+trendplot'></span>

<h3>Description</h3>

<p>Provides a plot of the repartition of dose-response trends per group
of items.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trendplot(extendedres, group, facetby, ncol4faceting, add.color = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trendplot_+3A_extendedres">extendedres</code></td>
<td>
<p>the dataframe of results provided by drcfit (fitres)
or bmdcalc (res) 
or a subset of this data frame (selected lines). This dataframe should be extended 
with additional columns coming for the group (for example from the functional
annotation of items) and/or for another level (for example the molecular level),
and some lines 
can be replicated if their corresponding item has more than one annotation. 
This extended dataframe
must at least contain as results of the dose-response modelling
the column giving the trend (<code>trend</code>).</p>
</td></tr>
<tr><td><code id="trendplot_+3A_group">group</code></td>
<td>
<p>the name of the column of <code>extendedres</code> coding for the groups
on which we want to see the repartition of dose-response trends. 
This column should be a factor ordered as you want the groups to appear
in the plot from bottom up.</p>
</td></tr>
<tr><td><code id="trendplot_+3A_facetby">facetby</code></td>
<td>
<p>optional argument naming the column of <code>extendedres</code> chosen 
to split the plot in facets using <code>ggplot2::facet_wrap</code> (no split if omitted).</p>
</td></tr>
<tr><td><code id="trendplot_+3A_ncol4faceting">ncol4faceting</code></td>
<td>
<p>number of columns for faceting.</p>
</td></tr>
<tr><td><code id="trendplot_+3A_add.color">add.color</code></td>
<td>
<p>if TRUE a color is added coding for the trend.</p>
</td></tr>
</table>


<h3>Value</h3>

 
<p>a ggplot object.
</p>


<h3>Author(s)</h3>

 
<p>Marie-Laure Delignette-Muller
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+bmdplotwithgradient">bmdplotwithgradient</a></code> and <code><a href="#topic+curvesplot">curvesplot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# (1)

# An example from the paper published by Larras et al. 2020
# in Journal of Hazardous Materials
# https://doi.org/10.1016/j.jhazmat.2020.122727

# the dataframe with metabolomic results 
resfilename &lt;- system.file("extdata", "triclosanSVmetabres.txt", package="DRomics")
res &lt;- read.table(resfilename, header = TRUE, stringsAsFactors = TRUE)
str(res)

# the dataframe with annotation of each item identified in the previous file
# each item may have more than one annotation (-&gt; more than one line)
annotfilename &lt;- system.file("extdata", "triclosanSVmetabannot.txt", package="DRomics")
annot &lt;- read.table(annotfilename, header = TRUE, stringsAsFactors = TRUE)
str(annot)

# Merging of both previous dataframes
# in order to obtain an extenderes dataframe
extendedres &lt;- merge(x = res, y = annot, by.x = "id", by.y = "metab.code")
head(extendedres)


# (1.a) Trendplot by pathway
trendplot(extendedres, group = "path_class") 



# (1.b) Trendplot by pathway without color
trendplot(extendedres, group = "path_class", add.color = FALSE) 

# (1.c) Reordering of the groups before plotting
extendedres$path_class &lt;- factor(extendedres$path_class, 
                levels = sort(levels(extendedres$path_class), decreasing = TRUE))
trendplot(extendedres, group = "path_class", add.color = FALSE) 

# (2) 
# An example with two molecular levels
#
### Rename metabolomic results
metabextendedres &lt;- extendedres

# Import the dataframe with transcriptomic results 
contigresfilename &lt;- system.file("extdata", "triclosanSVcontigres.txt", package = "DRomics")
contigres &lt;- read.table(contigresfilename, header = TRUE, stringsAsFactors = TRUE)
str(contigres)

# Import the dataframe with functional annotation (or any other descriptor/category 
# you want to use, here KEGG pathway classes) 
contigannotfilename &lt;- system.file("extdata", "triclosanSVcontigannot.txt", package = "DRomics")
contigannot &lt;- read.table(contigannotfilename, header = TRUE, stringsAsFactors = TRUE)
str(contigannot)

# Merging of both previous dataframes   
contigextendedres &lt;- merge(x = contigres, y = contigannot, by.x = "id", by.y = "contig")
# to see the structure of this dataframe
str(contigextendedres)

### Merge metabolomic and transcriptomic results
extendedres &lt;- rbind(metabextendedres, contigextendedres)
extendedres$molecular.level &lt;- factor(c(rep("metabolites", nrow(metabextendedres)),
                              rep("contigs", nrow(contigextendedres))))
str(extendedres)

### trend plot of both molecular levels
# optional inverse alphabetic ordering of groups for the plot
extendedres$path_class &lt;- factor(extendedres$path_class, 
                levels = sort(levels(extendedres$path_class), decreasing = TRUE))
trendplot(extendedres, group = "path_class", facetby = "molecular.level") 




</code></pre>

<hr>
<h2 id='zebraf'>Transcriptomic dose-response to ionizing radiation in zebrafish with batch effect</h2><span id='topic+zebraf'></span>

<h3>Description</h3>

<p>A sample of an RNAseq data set of the dose-response to the chronic exposure to ionizing radiation of zebrafish embryo from fertilization and up to 48 hours post-fertilization with the corresponding batch effect of the experiment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(zebraf)
</code></pre>


<h3>Format</h3>

 
<p><code>zebraf</code> contains a list of three objects, <code>zebraf$counts</code> an integer matrix of counts of reads 
(1000 rows for a sample pf 1000 transcripts and 16 columns for the 16 sampels), <code>zebraf$dose</code>, a numeric vector coding for the dose of each sample 
and <code>zebraf$batch</code> a factor coding for the batch of each sample.
</p>


<h3>Source</h3>

 
<p>Murat El Houdigui, S., Adam-Guillermin, C., Loro, G., Arcanjo, C., Frelon, S., Floriani, M., ... &amp; Armant, O. 2019. A systems biology approach reveals neuronal and muscle developmental defects after chronic exposure to ionising radiation in zebrafish. <em>Scientific reports</em>, <b>9(1)</b>, 1-15.
</p>


<h3>References</h3>

 
<p>Zhang, Y., Parmigiani, G., &amp; Johnson, W. E. (2020). ComBat-seq: batch effect adjustment for RNA-seq count data. NAR genomics and bioinformatics, 2(3), lqaa078.</p>


<h3>See Also</h3>

<p>See <a href="https://github.com/zhangyuqing/ComBat-seq">https://github.com/zhangyuqing/ComBat-seq</a> for indication of use 
of the ComBat_seq function of the sva package 
for batch effect correction and <code><a href="#topic+formatdata4DRomics">formatdata4DRomics</a></code> a function 
that can be used to format those data before use of the DRomics workflow.</p>


<h3>Examples</h3>

<pre><code class='language-R'># (1) load of data
#
data(zebraf)
str(zebraf)

# (2) formating of data for use in DRomics
# 
data4DRomics &lt;- formatdata4DRomics(signalmatrix = zebraf$counts, 
                           dose = zebraf$dose)

# (3) Normalization and transformation of data followed
# by PCA plot with vizualisation of the batch effect
#
o &lt;- RNAseqdata(data4DRomics, transfo.method = "vst")
PCAdataplot(o, batch = zebraf$batch)


PCAdataplot(o, label = TRUE)

# (4) Batch effect correction using ComBat_seq{sva}
#

if(!requireNamespace("sva", quietly = TRUE)) {
BECcounts &lt;- ComBat_seq(as.matrix(o$raw.counts), 
                        batch = as.factor(zebraf$batch), 
                        group = as.factor(o$dose)) 
BECdata4DRomics &lt;- formatdata4DRomics(signalmatrix = BECcounts, 
                                   dose = o$dose)
(o.BEC &lt;- RNAseqdata(BECdata4DRomics, transfo.method = "vst"))
plot(o.BEC)
PCAdataplot(o.BEC, batch = zebraf$batch)
PCAdataplot(o.BEC, label = TRUE)
}



</code></pre>

<hr>
<h2 id='Zhou'>Dose-response kidney transcriptomic effect of Tetrachloroethylene in mouse</h2><span id='topic+Zhou'></span><span id='topic+Zhou_kidney_pce'></span>

<h3>Description</h3>

<p>RNAseq data set for the effect of Tetrachloroethylene (PCE) on mouse kidney. This environmental contaminant was administered by gavage in aqueous vehicle to male B6C3F1/J mice, within a dose-reponse design
including five doses plus the control.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Zhou_kidney_pce)
</code></pre>


<h3>Format</h3>

 
<p><code>Zhou_kidney_pce</code> contains one row per transcript, with the first column corresponding to the identifier of each transcript, and the other columns giving the count of reads for each replicate at each dose. In the first line, after the name for the identifier column, we have the tested doses for each corresponding replicate.
</p>


<h3>Source</h3>

 
<p>Zhou, Y. H., Cichocki, J. A., Soldatow, V. Y., Scholl, E. H., Gallins, P. J., Jima, D., ... &amp; Rusyn, I. 2017. Comparative dose-response analysis of liver and kidney transcriptomic effects of trichloroethylene and tetrachloroethylene in B6C3F1 mouse. <em>Toxicological sciences</em>, <b>160(1)</b>, 95-110.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># (1) load of data
#
data(Zhou_kidney_pce)
head(Zhou_kidney_pce)
str(Zhou_kidney_pce)



# (2) import, check, normalization and transformation of a sample
# of one of those datasets
#
d &lt;- Zhou_kidney_pce[1:501, ]
(o &lt;- RNAseqdata(d))
plot(o)


# (3) analysis of the whole dataset (for kidney and PCE)
# (may be long to run)

d &lt;- Zhou_kidney_pce
(o &lt;- RNAseqdata(d))
plot(o)
(s &lt;- itemselect(o, select.method = "quadratic", FDR = 0.01))
(f &lt;- drcfit(s, progressbar = TRUE))
head(f$fitres)

plot(f) 
plot(f, dose_log_trans = TRUE)
plot(f, plot.type = "dose_residuals")

r &lt;- bmdcalc(f, z = 1)
plot(r) 
plot(r, by = "trend")
head(r$res)



</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
