<!DOCTYPE html><html><head><title>Help for package metatools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {metatools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#add_labels'><p>Apply labels to multiple variables on a data frame</p></a></li>
<li><a href='#add_variables'><p>Add Missing Variables</p></a></li>
<li><a href='#build_from_derived'><p>Build a dataset from derived</p></a></li>
<li><a href='#build_qnam'><p>Build the observations for a single QNAM</p></a></li>
<li><a href='#check_ct_col'><p>Check Control Terminology for a Single Column</p></a></li>
<li><a href='#check_ct_data'><p>Check Control Terminology for a Dataset</p></a></li>
<li><a href='#check_variables'><p>Check Variable Names</p></a></li>
<li><a href='#combine_supp'><p>Combine the Domain and Supplemental Qualifier</p></a></li>
<li><a href='#convert_var_to_fct'><p>Convert Variable to Factor with Levels Set by Control Terms</p></a></li>
<li><a href='#create_cat_var'><p>Create Categorical Variable from Codelist</p></a></li>
<li><a href='#create_subgrps'><p>Create Subgroups</p></a></li>
<li><a href='#create_var_from_codelist'><p>Create Variable from Codelist</p></a></li>
<li><a href='#drop_unspec_vars'><p>Drop Unspecified Variables</p></a></li>
<li><a href='#get_bad_ct'><p>Gets vector of control terminology which should be there</p></a></li>
<li><a href='#make_supp_qual'><p>Make Supplemental Qualifier</p></a></li>
<li><a href='#metatools_example'><p>Get path to pkg example</p></a></li>
<li><a href='#order_cols'><p>Sort Columns by Order</p></a></li>
<li><a href='#remove_labels'><p>Remove labels to multiple variables on a data frame</p></a></li>
<li><a href='#set_variable_labels'><p>Apply labels to a data frame using a metacore object</p></a></li>
<li><a href='#sort_by_key'><p>Sort Rows by Key Sequence</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Enable the Use of 'metacore' to Help Create and Check Dataset</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.5</td>
</tr>
<tr>
<td>Description:</td>
<td>Uses the metadata information stored in 'metacore' objects to check and build metadata associated columns.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, metacore (&ge; 0.0.4), purrr, rlang, stringr, tidyr,
tibble, magrittr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), haven, covr, safetyData, admiral.test</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://pharmaverse.github.io/metatools/">https://pharmaverse.github.io/metatools/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/pharmaverse/metatools/issues">https://github.com/pharmaverse/metatools/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-13 09:03:49 UTC; christinafillmore</td>
</tr>
<tr>
<td>Author:</td>
<td>Christina Fillmore
    <a href="https://orcid.org/0000-0003-0595-2302"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Mike Stackhouse <a href="https://orcid.org/0000-0001-6030-723X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  GlaxoSmithKline LLC [cph, fnd],
  F. Hoffmann-La Roche AG [cph, fnd],
  Atorus Research LLC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christina Fillmore &lt;christina.e.fillmore@gsk.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-13 10:00:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling 'rhs(lhs)'.
</p>

<hr>
<h2 id='add_labels'>Apply labels to multiple variables on a data frame</h2><span id='topic+add_labels'></span>

<h3>Description</h3>

<p>This function allows a user to apply several labels to a dataframe at once.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_labels(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_labels_+3A_data">data</code></td>
<td>
<p>A data.frame or tibble</p>
</td></tr>
<tr><td><code id="add_labels_+3A_...">...</code></td>
<td>
<p>Named parameters in the form of variable = 'label'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data with variable labels applied
</p>


<h3>Examples</h3>

<pre><code class='language-R'>add_labels(
    mtcars,
    mpg = "Miles Per Gallon",
    cyl = "Cylinders"
  )

</code></pre>

<hr>
<h2 id='add_variables'>Add Missing Variables</h2><span id='topic+add_variables'></span>

<h3>Description</h3>

<p>This function adds in missing columns according to the type set in the
metacore object. All values in the new columns will be missing, but typed
correctly. If unable to recognize the type in the metacore object will return
a logical type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_variables(dataset, metacore, dataset_name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_variables_+3A_dataset">dataset</code></td>
<td>
<p>Dataset to add columns to. If all variables are present no
columns will be added.</p>
</td></tr>
<tr><td><code id="add_variables_+3A_metacore">metacore</code></td>
<td>
<p>metacore object that only contains the specifications for the
dataset of interest.</p>
</td></tr>
<tr><td><code id="add_variables_+3A_dataset_name">dataset_name</code></td>
<td>
<p>Optional string to specify the dataset. This is only
needed if the metacore object provided hasn't already been subsetted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The given dataset with any additional columns added
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(metacore)
library(haven)
library(dplyr)
load(metacore_example("pilot_ADaM.rda"))
spec &lt;- metacore %&gt;% select_dataset("ADSL")
data &lt;- read_xpt(metatools_example("adsl.xpt")) %&gt;%
   select(-TRTSDT, -TRT01P, -TRT01PN)
add_variables(data, spec)
</code></pre>

<hr>
<h2 id='build_from_derived'>Build a dataset from derived</h2><span id='topic+build_from_derived'></span>

<h3>Description</h3>

<p>This function builds a dataset out of the columns that just need to be pulled
through. So any variable that has a derivation in the format of
'dataset.variable' will be pulled through to create the new dataset. When
there are multiple datasets present, they will be joined by the shared
&lsquo;key_seq' variables. These columns are often called &rsquo;Predecessors' in ADaM,
but this is not universal so that is optional to specify.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_from_derived(
  metacore,
  ds_list,
  dataset_name = NULL,
  predecessor_only = TRUE,
  keep = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_from_derived_+3A_metacore">metacore</code></td>
<td>
<p>metacore object that contains the specifications for the
dataset of interest.</p>
</td></tr>
<tr><td><code id="build_from_derived_+3A_ds_list">ds_list</code></td>
<td>
<p>Named list of datasets that are needed to build the from</p>
</td></tr>
<tr><td><code id="build_from_derived_+3A_dataset_name">dataset_name</code></td>
<td>
<p>Optional string to specify the dataset that is being
built. This is only needed if the metacore object provided hasn't already
been subsetted.</p>
</td></tr>
<tr><td><code id="build_from_derived_+3A_predecessor_only">predecessor_only</code></td>
<td>
<p>By default 'FALSE', but if 'TRUE' will only use
derivations with the origin of 'Predecessor'</p>
</td></tr>
<tr><td><code id="build_from_derived_+3A_keep">keep</code></td>
<td>
<p>Boolean to determine if the original columns should be kept. By
default 'FALSE', so only the ADaM columns are kept. If 'TRUE' the resulting
dataset will have all the ADaM columns as well as any SDTM column that were
renamed in the ADaM (i.e 'ARM' and 'TRT01P' will be in the resulting
dataset)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataset
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(metacore)
library(haven)
library(magrittr)
load(metacore_example("pilot_ADaM.rda"))
spec &lt;- metacore %&gt;% select_dataset("ADSL")
ds_list &lt;- list(DM = read_xpt(metatools_example("dm.xpt")))
build_from_derived(spec, ds_list, predecessor_only = FALSE)
</code></pre>

<hr>
<h2 id='build_qnam'>Build the observations for a single QNAM</h2><span id='topic+build_qnam'></span>

<h3>Description</h3>

<p>Build the observations for a single QNAM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_qnam(dataset, qnam, qlabel, idvar, qeval, qorig)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_qnam_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset</p>
</td></tr>
<tr><td><code id="build_qnam_+3A_qnam">qnam</code></td>
<td>
<p>QNAM value</p>
</td></tr>
<tr><td><code id="build_qnam_+3A_qlabel">qlabel</code></td>
<td>
<p>QLABEL value</p>
</td></tr>
<tr><td><code id="build_qnam_+3A_idvar">idvar</code></td>
<td>
<p>IDVAR variable name (provided as a string)</p>
</td></tr>
<tr><td><code id="build_qnam_+3A_qeval">qeval</code></td>
<td>
<p>QEVAL value to be populated for this QNAM</p>
</td></tr>
<tr><td><code id="build_qnam_+3A_qorig">qorig</code></td>
<td>
<p>QORIG value to be populated for this QNAM</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Observations structured in SUPP format
</p>

<hr>
<h2 id='check_ct_col'>Check Control Terminology for a Single Column</h2><span id='topic+check_ct_col'></span>

<h3>Description</h3>

<p>This function checks the column in the dataset only contains the control
terminology as defined by the metacore specification
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_ct_col(data, metacore, var, na_acceptable = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_ct_col_+3A_data">data</code></td>
<td>
<p>Data to check</p>
</td></tr>
<tr><td><code id="check_ct_col_+3A_metacore">metacore</code></td>
<td>
<p>A metacore object to get the codelist from. If the variable
has different codelists for different datasets the metacore object will
need to be subsetted using 'select_dataset' from the metacore package.</p>
</td></tr>
<tr><td><code id="check_ct_col_+3A_var">var</code></td>
<td>
<p>Name of variable to check</p>
</td></tr>
<tr><td><code id="check_ct_col_+3A_na_acceptable">na_acceptable</code></td>
<td>
<p>Logical value, set to 'NULL' by default, so the
acceptability of missing values is based on if the core for the variable is
&quot;Required&quot; in the 'metacore' object. If set to 'TRUE' then will pass check
if values are in the control terminology or are missing. If set to
'FALSE'then NA will not be acceptable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Given data if column only contains control terms. If not, will error
given the values which should not be in the column
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(metacore)
library(haven)
library(magrittr)
load(metacore_example("pilot_ADaM.rda"))
spec &lt;- metacore %&gt;% select_dataset("ADSL")
data &lt;- read_xpt(metatools_example("adsl.xpt"))
check_ct_col(data, spec, TRT01PN)
check_ct_col(data, spec, "TRT01PN")
</code></pre>

<hr>
<h2 id='check_ct_data'>Check Control Terminology for a Dataset</h2><span id='topic+check_ct_data'></span>

<h3>Description</h3>

<p>This function checks that all columns in the dataset only contains the
control terminology as defined by the metacore specification
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_ct_data(data, metacore, na_acceptable = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_ct_data_+3A_data">data</code></td>
<td>
<p>Dataset to check</p>
</td></tr>
<tr><td><code id="check_ct_data_+3A_metacore">metacore</code></td>
<td>
<p>metacore object that contains the specifications for the
dataset of interest. If any variable has different codelists for different
datasets the metacore object will need to be subsetted using
'select_dataset' from the metacore package.</p>
</td></tr>
<tr><td><code id="check_ct_data_+3A_na_acceptable">na_acceptable</code></td>
<td>
<p>Logical value, set to 'NULL' by default, so the
acceptability of missing values is based on if the core for the variable is
&quot;Required&quot; in the 'metacore' object. If set to 'TRUE' then will
pass check if values are in the control terminology or are missing. If set
to 'FALSE'then NA will not be acceptable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Given data if all columns pass. It will error otherwise
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(haven)
library(metacore)
library(magrittr)
load(metacore_example("pilot_ADaM.rda"))
spec &lt;- metacore %&gt;% select_dataset("ADSL")
data &lt;- read_xpt(metatools_example("adsl.xpt"))
check_ct_data(data, spec)
</code></pre>

<hr>
<h2 id='check_variables'>Check Variable Names</h2><span id='topic+check_variables'></span>

<h3>Description</h3>

<p>This function checks the variables in the dataset against the variables
defined in the metacore specifications. If everything matches the function
will return 'TRUE' and a message starting everything is as expected. If there
are additional or missing variables and error will explain the discrepancies
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_variables(data, metacore, dataset_name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_variables_+3A_data">data</code></td>
<td>
<p>Dataset to check</p>
</td></tr>
<tr><td><code id="check_variables_+3A_metacore">metacore</code></td>
<td>
<p>metacore object that only contains the specifications for the
dataset of interest.</p>
</td></tr>
<tr><td><code id="check_variables_+3A_dataset_name">dataset_name</code></td>
<td>
<p>Optional string to specify the dataset. This is only
needed if the metacore object provided hasn't already been subsetted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>message if the dataset matches the specification and the dataset, and error otherwise
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(haven)
library(metacore)
library(magrittr)
load(metacore_example("pilot_ADaM.rda"))
spec &lt;- metacore %&gt;% select_dataset("ADSL")
data &lt;- read_xpt(metatools_example("adsl.xpt"))
check_variables(data, spec)
</code></pre>

<hr>
<h2 id='combine_supp'>Combine the Domain and Supplemental Qualifier</h2><span id='topic+combine_supp'></span>

<h3>Description</h3>

<p>Combine the Domain and Supplemental Qualifier
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_supp(dataset, supp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_supp_+3A_dataset">dataset</code></td>
<td>
<p>Domain dataset</p>
</td></tr>
<tr><td><code id="combine_supp_+3A_supp">supp</code></td>
<td>
<p>Supplemental Qualifier dataset</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataset with the supp variables added to it
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(safetyData)
library(tibble)
combine_supp(sdtm_ae, sdtm_suppae)  %&gt;% as_tibble()
</code></pre>

<hr>
<h2 id='convert_var_to_fct'>Convert Variable to Factor with Levels Set by Control Terms</h2><span id='topic+convert_var_to_fct'></span>

<h3>Description</h3>

<p>This functions takes a dataset, a metacore object and a variable name. Then
looks at the metacore object for the control terms for the given variable and
uses that to convert the variable to a factor with those levels. If the
control terminology is a code list, the code column will be used. The
function fails if the control terminology is an external library
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_var_to_fct(data, metacore, var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_var_to_fct_+3A_data">data</code></td>
<td>
<p>A dataset containing the variable to be modified</p>
</td></tr>
<tr><td><code id="convert_var_to_fct_+3A_metacore">metacore</code></td>
<td>
<p>A metacore object to get the codelist from. If the
variable has different codelists for different datasets the metacore object
will need to be subsetted using 'select_dataset' from the metacore package</p>
</td></tr>
<tr><td><code id="convert_var_to_fct_+3A_var">var</code></td>
<td>
<p>Name of variable to change</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataset with variable changed to a factor
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(metacore)
library(haven)
library(dplyr)
load(metacore_example("pilot_ADaM.rda"))
spec &lt;- metacore %&gt;% select_dataset("ADSL")
dm &lt;- read_xpt(metatools_example("dm.xpt")) %&gt;%
  select(USUBJID, SEX, ARM)
# Variable with codelist control terms
convert_var_to_fct(dm, spec, SEX)
# Variable with permitted value control terms
convert_var_to_fct(dm, spec, ARM)
</code></pre>

<hr>
<h2 id='create_cat_var'>Create Categorical Variable from Codelist</h2><span id='topic+create_cat_var'></span>

<h3>Description</h3>

<p>Using the grouping from either the 'decode_var' or 'code_var' and a reference
variable ('ref_var') it will create a categorical variable and the numeric
version of that categorical variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_cat_var(data, metacore, ref_var, grp_var, num_grp_var = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_cat_var_+3A_data">data</code></td>
<td>
<p>Dataset with reference variable in it</p>
</td></tr>
<tr><td><code id="create_cat_var_+3A_metacore">metacore</code></td>
<td>
<p>A metacore object to get the codelist from. If the
variable has different codelists for different datasets the metacore object
will need to be subsetted using 'select_dataset' from the metacore package.</p>
</td></tr>
<tr><td><code id="create_cat_var_+3A_ref_var">ref_var</code></td>
<td>
<p>Name of variable to be used as the reference i.e AGE when
creating AGEGR1</p>
</td></tr>
<tr><td><code id="create_cat_var_+3A_grp_var">grp_var</code></td>
<td>
<p>Name of the new grouped variable</p>
</td></tr>
<tr><td><code id="create_cat_var_+3A_num_grp_var">num_grp_var</code></td>
<td>
<p>Name of the new numeric decode for the grouped variable.
This is optional if no value given no variable will be created</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataset with new column added
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(metacore)
library(haven)
library(dplyr)
load(metacore_example("pilot_ADaM.rda"))
spec &lt;- metacore %&gt;% select_dataset("ADSL")
dm &lt;- read_xpt(metatools_example("dm.xpt")) %&gt;%
  select(USUBJID, AGE)
# Grouping Column Only
create_cat_var(dm, spec, AGE, AGEGR1)
# Grouping Column and Numeric Decode
create_cat_var(dm, spec, AGE, AGEGR1, AGEGR1N)
</code></pre>

<hr>
<h2 id='create_subgrps'>Create Subgroups</h2><span id='topic+create_subgrps'></span>

<h3>Description</h3>

<p>Create Subgroups
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_subgrps(ref_vec, grp_defs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_subgrps_+3A_ref_vec">ref_vec</code></td>
<td>
<p>Vector of numeric values</p>
</td></tr>
<tr><td><code id="create_subgrps_+3A_grp_defs">grp_defs</code></td>
<td>
<p>Vector of strings with groupings defined. Format must be
either: &lt;00, &gt;=00, 00-00, or  00-&lt;00</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector of the values in the subgroups
</p>


<h3>Examples</h3>

<pre><code class='language-R'>create_subgrps(c(1:10), c("&lt;2", "2-5", "&gt;5"))
create_subgrps(c(1:10), c("&lt;=2", "&gt;2-5", "&gt;5"))
create_subgrps(c(1:10), c("&lt;2", "2-&lt;5", "&gt;=5"))
</code></pre>

<hr>
<h2 id='create_var_from_codelist'>Create Variable from Codelist</h2><span id='topic+create_var_from_codelist'></span>

<h3>Description</h3>

<p>This functions uses code/decode pairs from a metacore object to create new
variables in the data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_var_from_codelist(
  data,
  metacore,
  input_var,
  out_var,
  decode_to_code = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_var_from_codelist_+3A_data">data</code></td>
<td>
<p>Dataset that contains the input variable</p>
</td></tr>
<tr><td><code id="create_var_from_codelist_+3A_metacore">metacore</code></td>
<td>
<p>A metacore object to get the codelist from. If the 'out_var'
has different codelists for different datasets the metacore object will
need to be subsetted using 'select_dataset' from the metacore package.</p>
</td></tr>
<tr><td><code id="create_var_from_codelist_+3A_input_var">input_var</code></td>
<td>
<p>Name of the variable that will be translated for the new
column</p>
</td></tr>
<tr><td><code id="create_var_from_codelist_+3A_out_var">out_var</code></td>
<td>
<p>Name of the output variable. Note: the grouping will always be
from the code of the codelist associates with 'out_var'</p>
</td></tr>
<tr><td><code id="create_var_from_codelist_+3A_decode_to_code">decode_to_code</code></td>
<td>
<p>Direction of the translation. By default assumes the
'input_var' is the decode column of the codelist. Set to 'FALSE' if the
'input_var' is the code column of the codelist</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataset with a new column added
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(metacore)
library(tibble)
data &lt;- tribble(
  ~USUBJID, ~VAR1, ~VAR2,
  1, "M", "Male",
  2, "F", "Female",
  3, "F", "Female",
  4, "U", "Unknown",
  5, "M", "Male",
)
spec &lt;- spec_to_metacore(metacore_example("p21_mock.xlsx"), quiet = TRUE)
create_var_from_codelist(data, spec, VAR2, SEX)
create_var_from_codelist(data, spec, "VAR2", "SEX")
create_var_from_codelist(data, spec, VAR1, SEX, decode_to_code = FALSE)
</code></pre>

<hr>
<h2 id='drop_unspec_vars'>Drop Unspecified Variables</h2><span id='topic+drop_unspec_vars'></span>

<h3>Description</h3>

<p>This function drops all unspecified variables. It will throw and error if the
dataset does not contain all expected variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_unspec_vars(dataset, metacore, dataset_name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop_unspec_vars_+3A_dataset">dataset</code></td>
<td>
<p>Dataset to change</p>
</td></tr>
<tr><td><code id="drop_unspec_vars_+3A_metacore">metacore</code></td>
<td>
<p>metacore object that only contains the specifications for the
dataset of interest.</p>
</td></tr>
<tr><td><code id="drop_unspec_vars_+3A_dataset_name">dataset_name</code></td>
<td>
<p>Optional string to specify the dataset. This is only
needed if the metacore object provided hasn't already been subsetted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataset with only specified columns
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(metacore)
library(haven)
library(dplyr)
load(metacore_example("pilot_ADaM.rda"))
spec &lt;- metacore %&gt;% select_dataset("ADSL")
data &lt;- read_xpt(metatools_example("adsl.xpt")) %&gt;%
  select(USUBJID, SITEID) %&gt;%
  mutate(foo = "Hello")
drop_unspec_vars(data, spec)
</code></pre>

<hr>
<h2 id='get_bad_ct'>Gets vector of control terminology which should be there</h2><span id='topic+get_bad_ct'></span>

<h3>Description</h3>

<p>This function checks the column in the dataset only contains the control
terminology as defined by the metacore specification. It will return all
values not found in the control terminology
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_bad_ct(data, metacore, var, na_acceptable = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_bad_ct_+3A_data">data</code></td>
<td>
<p>Data to check</p>
</td></tr>
<tr><td><code id="get_bad_ct_+3A_metacore">metacore</code></td>
<td>
<p>A metacore object to get the codelist from. If the variable
has different codelists for different datasets the metacore object will
need to be subsetted using 'select_dataset' from the metacore package.</p>
</td></tr>
<tr><td><code id="get_bad_ct_+3A_var">var</code></td>
<td>
<p>Name of variable to check</p>
</td></tr>
<tr><td><code id="get_bad_ct_+3A_na_acceptable">na_acceptable</code></td>
<td>
<p>Logical value, set to 'NULL' by default, so the
acceptability of missing values is based on if the core for the variable is
&quot;Required&quot; in the 'metacore' object. If set to 'TRUE' then will pass check
if values are in the control terminology or are missing. If set to
'FALSE'then NA will not be acceptable.e</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector
</p>

<hr>
<h2 id='make_supp_qual'>Make Supplemental Qualifier</h2><span id='topic+make_supp_qual'></span>

<h3>Description</h3>

<p>Make Supplemental Qualifier
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_supp_qual(dataset, metacore, dataset_name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_supp_qual_+3A_dataset">dataset</code></td>
<td>
<p>dataset the supp will be pulled from</p>
</td></tr>
<tr><td><code id="make_supp_qual_+3A_metacore">metacore</code></td>
<td>
<p>A subsetted metacore object to get the supp information from.
If not already subsetted then a 'dataset_name' will need to be provided</p>
</td></tr>
<tr><td><code id="make_supp_qual_+3A_dataset_name">dataset_name</code></td>
<td>
<p>optional name of dataset</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a CDISC formatted SUPP dataset
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(metacore)
library(safetyData)
library(tibble)
load(metacore_example("pilot_SDTM.rda"))
spec &lt;- metacore %&gt;% select_dataset("AE")
ae &lt;- combine_supp(sdtm_ae, sdtm_suppae)
make_supp_qual(ae, spec) %&gt;% as_tibble()
</code></pre>

<hr>
<h2 id='metatools_example'>Get path to pkg example</h2><span id='topic+metatools_example'></span>

<h3>Description</h3>

<p>pkg comes bundled with a number of sample files in its 'inst/extdata'
directory. This function make them easy to access
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metatools_example(file = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metatools_example_+3A_file">file</code></td>
<td>
<p>Name of file. If 'NULL', the example files will be listed.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>metatools_example()
metatools_example("dm.xpt")
</code></pre>

<hr>
<h2 id='order_cols'>Sort Columns by Order</h2><span id='topic+order_cols'></span>

<h3>Description</h3>

<p>This function sorts the dataset according to the order found in the
metacore object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order_cols(data, metacore, dataset_name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="order_cols_+3A_data">data</code></td>
<td>
<p>Dataset to sort</p>
</td></tr>
<tr><td><code id="order_cols_+3A_metacore">metacore</code></td>
<td>
<p>metacore object that contains the specifications for the
dataset of interest.</p>
</td></tr>
<tr><td><code id="order_cols_+3A_dataset_name">dataset_name</code></td>
<td>
<p>Optional string to specify the dataset. This is only
needed if the metacore object provided hasn't already been subsetted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataset with ordered columns
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(metacore)
library(haven)
library(magrittr)
load(metacore_example("pilot_ADaM.rda"))
spec &lt;- metacore %&gt;% select_dataset("ADSL")
data &lt;- read_xpt(metatools_example("adsl.xpt"))
order_cols(data, spec)
</code></pre>

<hr>
<h2 id='remove_labels'>Remove labels to multiple variables on a data frame</h2><span id='topic+remove_labels'></span>

<h3>Description</h3>

<p>This function allows a user to removes all labels to a dataframe at once.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_labels(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_labels_+3A_data">data</code></td>
<td>
<p>A data.frame or tibble</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data with variable labels applied
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(haven)
data &lt;- read_xpt(metatools_example("adsl.xpt"))
remove_labels(data)

</code></pre>

<hr>
<h2 id='set_variable_labels'>Apply labels to a data frame using a metacore object</h2><span id='topic+set_variable_labels'></span>

<h3>Description</h3>

<p>This function leverages metadata available in a metacore object to apply
labels to a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_variable_labels(data, metacore, dataset_name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_variable_labels_+3A_data">data</code></td>
<td>
<p>A dataframe or tibble upon which labels will be applied</p>
</td></tr>
<tr><td><code id="set_variable_labels_+3A_metacore">metacore</code></td>
<td>
<p>metacore object that contains the specifications for the
dataset of interest.</p>
</td></tr>
<tr><td><code id="set_variable_labels_+3A_dataset_name">dataset_name</code></td>
<td>
<p>Optional string to specify the dataset. This is only
needed if the metacore object provided hasn't already been subsetted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe with labels applied
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mc &lt;- metacore::spec_to_metacore(
        metacore::metacore_example("p21_mock.xlsx"),
        quiet=TRUE
        )
dm &lt;- haven::read_xpt(metatools_example("dm.xpt"))
set_variable_labels(dm, mc, dataset_name = "DM")
</code></pre>

<hr>
<h2 id='sort_by_key'>Sort Rows by Key Sequence</h2><span id='topic+sort_by_key'></span>

<h3>Description</h3>

<p>This function sorts the dataset according to the key sequence found in the
metacore object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sort_by_key(data, metacore, dataset_name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort_by_key_+3A_data">data</code></td>
<td>
<p>Dataset to sort</p>
</td></tr>
<tr><td><code id="sort_by_key_+3A_metacore">metacore</code></td>
<td>
<p>metacore object that contains the specifications for the
dataset of interest.</p>
</td></tr>
<tr><td><code id="sort_by_key_+3A_dataset_name">dataset_name</code></td>
<td>
<p>Optional string to specify the dataset. This is only
needed if the metacore object provided hasn't already been subsetted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataset with ordered columns
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(metacore)
library(haven)
library(magrittr)
load(metacore_example("pilot_ADaM.rda"))
spec &lt;- metacore %&gt;% select_dataset("ADSL")
data &lt;- read_xpt(metatools_example("adsl.xpt"))
sort_by_key(data, spec)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
