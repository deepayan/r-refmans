<!DOCTYPE html><html lang="en"><head><title>Help for package qtlpoly</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {qtlpoly}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#B2721'><p>Autotetraploid potato dataset</p></a></li>
<li><a href='#breeding_values'><p>Prediction of QTL-based breeding values from REMIM model</p></a></li>
<li><a href='#feim'><p>Fixed-effect interval mapping (FEIM)</p></a></li>
<li><a href='#fit_model'><p>Fits multiple QTL models</p></a></li>
<li><a href='#fit_model2'><p>Fits multiple QTL models</p></a></li>
<li><a href='#hexafake'><p>Simulated autohexaploid dataset.</p></a></li>
<li><a href='#maps4x'><p>Autotetraploid potato map</p></a></li>
<li><a href='#maps6x'><p>Simulated autohexaploid map</p></a></li>
<li><a href='#mmer_adapted'><p>Adapt to sommer MNR core function</p></a></li>
<li><a href='#modify_qtl'><p>Modify QTL model</p></a></li>
<li><a href='#null_model'><p>Null model</p></a></li>
<li><a href='#null_model2'><p>Null model</p></a></li>
<li><a href='#optimize_qtl'><p>Model optimization</p></a></li>
<li><a href='#permutations'><p>Fixed-effect interval mapping (FEIM) model permutations</p></a></li>
<li><a href='#pheno4x'><p>Autotetraploid potato phenotypes</p></a></li>
<li><a href='#pheno6x'><p>Simulated phenotypes</p></a></li>
<li><a href='#plot_profile'><p>Logarithm of <em>P</em>-value (LOP) profile plots</p></a></li>
<li><a href='#plot_qtl'><p>QTL heritability and significance plot</p></a></li>
<li><a href='#plot_sint'><p>QTLs with respective support interval plots</p></a></li>
<li><a href='#profile_qtl'><p>QTL profiling</p></a></li>
<li><a href='#qtl_effects'><p>QTL allele effect estimation</p></a></li>
<li><a href='#read_data'><p>Read genotypic and phenotypic data</p></a></li>
<li><a href='#read_data2'><p>Read genotypic and phenotypic data</p></a></li>
<li><a href='#remim'><p>Random-effect multiple interval mapping (REMIM)</p></a></li>
<li><a href='#remim2'><p>Random-effect multiple interval mapping (REMIM)</p></a></li>
<li><a href='#search_qtl'><p>QTL forward search</p></a></li>
<li><a href='#simulate_qtl'><p>Simulations of multiple QTL</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Random-Effect Multiple QTL Mapping in Autopolyploids</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.4</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gabriel de Siqueira Gesteira &lt;gdesiqu@ncsu.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Performs random-effect multiple interval mapping (REMIM) in full-sib families of autopolyploid species based on restricted maximum likelihood (REML) estimation and score statistics, as described in Pereira et al. (2020) &lt;<a href="https://doi.org/10.1534%2Fgenetics.120.303080">doi:10.1534/genetics.120.303080</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://gabrielgesteira.github.io/QTLpoly/">https://gabrielgesteira.github.io/QTLpoly/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/gabrielgesteira/QTLpoly/issues">https://github.com/gabrielgesteira/QTLpoly/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>xz</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2 (&ge; 3.1), abind (&ge; 1.4), MASS (&ge; 7.3), gtools (&ge;
3.9.2), CompQuadForm, Matrix, RLRsim, mvtnorm, nlme, quadprog,
parallel, doParallel, foreach, stats, methods, mappoly, Rcpp
(&ge; 0.12.19)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppProgress</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, devtools, knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-20 18:48:26 UTC; gdesiqu</td>
</tr>
<tr>
<td>Author:</td>
<td>Guilherme da Silva Pereira
    <a href="https://orcid.org/0000-0002-7106-8630"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Marcelo Mollinari <a href="https://orcid.org/0000-0002-7001-8498"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Gabriel de Siqueira Gesteira
    <a href="https://orcid.org/0000-0002-4106-7346"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb, cre],
  Zhao-Bang Zeng <a href="https://orcid.org/0000-0002-3115-1149"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Long Qu [ctb] (R code for variance component tests using score
    statistics in R/varComp.R),
  Giovanny Covarrubias-Pazaran [ctb] (C code for fitting mixed models
    with REML estimation in src/MNR.cpp)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-25 20:50:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='B2721'>Autotetraploid potato dataset</h2><span id='topic+B2721'></span>

<h3>Description</h3>

<p>A dataset of the B2721 population which derived from a cross between 
two tetraploid potato varieties: Atlantic × B1829-5.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>B2721
</code></pre>


<h3>Format</h3>

<p>An object of class <code>mappoly.data</code> from the package <span class="pkg">mappoly</span>.
</p>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Mollinari M, Garcia AAF (2019) Linkage analysis and haplotype phasing in experimental autopolyploid populations with high ploidy level using hidden Markov models, <em>G3: Genes|Genomes|Genetics</em> 9 (10): 3297-3314. <a href="https://doi.org/10.1534/g3.119.400378">doi:10.1534/g3.119.400378</a>
</p>
<p>Pereira GS, Gemenet DC, Mollinari M, Olukolu BA, Wood JC, Mosquera V, Gruneberg WJ, Khan A, Buell CR, Yencho GC, Zeng ZB (2020) Multiple QTL mapping in autopolyploids: a random-effect model approach with application in a hexaploid sweetpotato full-sib population, <em>Genetics</em> 215 (3): 579-595. <a href="https://doi.org/10.1534/genetics.120.303080">doi:10.1534/genetics.120.303080</a>.
</p>
<p>Pereira GS, Mollinari M, Schumann MJ, Clough ME, Zeng ZB, Yencho C (2021) The recombination landscape and multiple QTL mapping in a <em>Solanum tuberosum</em> cv. ‘Atlantic’-derived F_1 population. Heredity. <a href="https://doi.org/10.1038/s41437-021-00416-x">doi:10.1038/s41437-021-00416-x</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mappoly)
print(B2721)
</code></pre>

<hr>
<h2 id='breeding_values'>Prediction of QTL-based breeding values from REMIM model</h2><span id='topic+breeding_values'></span><span id='topic+plot.qtlpoly.bvalues'></span>

<h3>Description</h3>

<p>Computes breeding values for each genotyped individual based on multiple QTL models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>breeding_values(data, fitted)

## S3 method for class 'qtlpoly.bvalues'
plot(x, pheno.col = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="breeding_values_+3A_data">data</code></td>
<td>
<p>an object of class <code>qtlpoly.data</code>.</p>
</td></tr>
<tr><td><code id="breeding_values_+3A_fitted">fitted</code></td>
<td>
<p>an object of class <code>qtlpoly.fitted</code>.</p>
</td></tr>
<tr><td><code id="breeding_values_+3A_x">x</code></td>
<td>
<p>an object of class <code>qtlpoly.bvalues</code> to be plotted.</p>
</td></tr>
<tr><td><code id="breeding_values_+3A_pheno.col">pheno.col</code></td>
<td>
<p>a numeric vector with the phenotype column numbers to be plotted; if <code>NULL</code>, all phenotypes from <code>'data'</code> will be included.</p>
</td></tr>
<tr><td><code id="breeding_values_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>qtlpoly.bvalues</code> which is a list of <code>results</code> for each trait containing the following components:
</p>
<table role = "presentation">
<tr><td><code>pheno.col</code></td>
<td>
<p>a phenotype column number.</p>
</td></tr>
<tr><td><code>y.hat</code></td>
<td>
<p>a column matrix of breeding value for each individual.</p>
</td></tr>
</table>
<p>A <span class="pkg">ggplot2</span> histogram with the distribution of breeding values.
</p>


<h3>Author(s)</h3>

<p>Guilherme da Silva Pereira, <a href="mailto:gdasilv@ncsu.edu">gdasilv@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Pereira GS, Gemenet DC, Mollinari M, Olukolu BA, Wood JC, Mosquera V, Gruneberg WJ, Khan A, Buell CR, Yencho GC, Zeng ZB (2020) Multiple QTL mapping in autopolyploids: a random-effect model approach with application in a hexaploid sweetpotato full-sib population, <em>Genetics</em> 215 (3): 579-595. <a href="https://doi.org/10.1534/genetics.120.303080">doi:10.1534/genetics.120.303080</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_data">read_data</a></code>, <code><a href="#topic+fit_model">fit_model</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  # Estimate conditional probabilities using mappoly package
  library(mappoly)
  library(qtlpoly)
  genoprob4x = lapply(maps4x[c(5)], calc_genoprob) #5,7
  data = read_data(ploidy = 4, geno.prob = genoprob4x, pheno = pheno4x, step = 1)

  # Search for QTL
  remim.mod = remim(data = data, pheno.col = 1, w.size = 15, sig.fwd = 0.0011493379,
sig.bwd = 0.0002284465, d.sint = 1.5, n.clusters = 1)

  # Fit model
  fitted.mod = fit_model(data = data, model = remim.mod, probs = "joint", polygenes = "none")

  # Predict genotypic values
  y.hat = breeding_values(data = data, fitted = fitted.mod)
  plot(y.hat)
  
  
</code></pre>

<hr>
<h2 id='feim'>Fixed-effect interval mapping (FEIM)</h2><span id='topic+feim'></span><span id='topic+print.qtlpoly.feim'></span>

<h3>Description</h3>

<p>Performs interval mapping using the single-QTL, fixed-effect model proposed by Hackett et al. (2001).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feim(
  data = data,
  pheno.col = NULL,
  w.size = 15,
  sig.lod = 7,
  d.sint = 1.5,
  plot = NULL,
  verbose = TRUE
)

## S3 method for class 'qtlpoly.feim'
print(x, pheno.col = NULL, sint = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="feim_+3A_data">data</code></td>
<td>
<p>an object of class <code>qtlpoly.data</code>.</p>
</td></tr>
<tr><td><code id="feim_+3A_pheno.col">pheno.col</code></td>
<td>
<p>a numeric vector with the phenotype columns to be analyzed; if <code>NULL</code> (default), all phenotypes from <code>'data'</code> will be included.</p>
</td></tr>
<tr><td><code id="feim_+3A_w.size">w.size</code></td>
<td>
<p>a number representing the window size (in centiMorgans) to be avoided on either side of QTL already in the model when looking for a new QTL, e.g. 15 (default).</p>
</td></tr>
<tr><td><code id="feim_+3A_sig.lod">sig.lod</code></td>
<td>
<p>the vector of desired significance LOD thresholds (usually permutation-based) for declaring a QTL for each trait, e.g. 5 (default); if a single value is provided, the same LOD threshold will be applied to all traits.</p>
</td></tr>
<tr><td><code id="feim_+3A_d.sint">d.sint</code></td>
<td>
<p>a <code class="reqn">d</code> value to subtract from logarithm of the odds (<code class="reqn">LOD-d</code>) for support interval calculation, e.g. <code class="reqn">d=1.5</code> (default) represents approximate 95% support interval.</p>
</td></tr>
<tr><td><code id="feim_+3A_plot">plot</code></td>
<td>
<p>a suffix for the file's name containing plots of every algorithm step, e.g. &quot;remim&quot; (default); if <code>NULL</code>, no file is produced.</p>
</td></tr>
<tr><td><code id="feim_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default), current progress is shown; if <code>FALSE</code>, no output is produced.</p>
</td></tr>
<tr><td><code id="feim_+3A_x">x</code></td>
<td>
<p>an object of class <code>qtlpoly.feim</code> to be printed.</p>
</td></tr>
<tr><td><code id="feim_+3A_sint">sint</code></td>
<td>
<p>whether <code>"upper"</code> or <code>"lower"</code> support intervals should be printed; if <code>NULL</code> (default), QTL peak information will be printed.</p>
</td></tr>
<tr><td><code id="feim_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>qtlpoly.feim</code> which contains a list of <code>results</code> for each trait with the following components:
</p>
<table role = "presentation">
<tr><td><code>pheno.col</code></td>
<td>
<p>a phenotype column number.</p>
</td></tr>
<tr><td><code>LRT</code></td>
<td>
<p>a vector containing LRT values.</p>
</td></tr>
<tr><td><code>LOD</code></td>
<td>
<p>a vector containing LOD scores.</p>
</td></tr>
<tr><td><code>AdjR2</code></td>
<td>
<p>a vector containing adjusted <code class="reqn">R^2</code>.</p>
</td></tr>
<tr><td><code>qtls</code></td>
<td>
<p>a data frame with information from the mapped QTL.</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>a data frame with information from the lower support interval of mapped QTL.</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p>a data frame with information from the upper support interval of mapped QTL.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Guilherme da Silva Pereira, <a href="mailto:gdasilv@ncsu.edu">gdasilv@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Pereira GS, Gemenet DC, Mollinari M, Olukolu BA, Wood JC, Mosquera V, Gruneberg WJ, Khan A, Buell CR, Yencho GC, Zeng ZB (2020) Multiple QTL mapping in autopolyploids: a random-effect model approach with application in a hexaploid sweetpotato full-sib population, <em>Genetics</em> 215 (3): 579-595. <a href="https://doi.org/10.1534/genetics.120.303080">doi:10.1534/genetics.120.303080</a>.
</p>
<p>Hackett CA, Bradshaw JE, McNicol JW (2001) Interval mapping of quantitative trait loci in autotetraploid species, <em>Genetics</em> 159: 1819-1832.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+permutations">permutations</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Estimate conditional probabilities using mappoly package
  library(mappoly)
  library(qtlpoly)
  genoprob4x = lapply(maps4x[c(5)], calc_genoprob)
  data = read_data(ploidy = 4, geno.prob = genoprob4x, pheno = pheno4x, step = 5)

  # Perform remim
  feim.mod = feim(data = data, sig.lod = 7)

</code></pre>

<hr>
<h2 id='fit_model'>Fits multiple QTL models</h2><span id='topic+fit_model'></span><span id='topic+summary.qtlpoly.fitted'></span>

<h3>Description</h3>

<p>Fits alternative multiple QTL models by performing variance component estimation using REML.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_model(
  data,
  model,
  probs = "joint",
  polygenes = "none",
  keep = TRUE,
  verbose = TRUE,
  pheno.col = NULL
)

## S3 method for class 'qtlpoly.fitted'
summary(object, pheno.col = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_model_+3A_data">data</code></td>
<td>
<p>an object of class <code>qtlpoly.data</code>.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_model">model</code></td>
<td>
<p>an object of class <code>qtlpoly.profile</code> or <code>qtlpoly.remim</code>.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_probs">probs</code></td>
<td>
<p>a character string indicating if either <code>"joint"</code> (genotypes) or <code>"marginal"</code> (parental gametes) conditional probabilities should be used.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_polygenes">polygenes</code></td>
<td>
<p>a character string indicating if either <code>"none"</code>, <code>"most"</code> or <code>"all"</code> QTL should be used as polygenes.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_keep">keep</code></td>
<td>
<p>if <code>TRUE</code> (default), stores all matrices and estimates from fitted model; if <code>FALSE</code>, nothing is stored.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default), current progress is shown; if
<code>FALSE</code>, no output is produced.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_pheno.col">pheno.col</code></td>
<td>
<p>a numeric vector with the phenotype column numbers to be summarized; if <code>NULL</code> (default), all phenotypes from <code>'data'</code> will be included.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_object">object</code></td>
<td>
<p>an object of class <code>qtlpoly.fitted</code> to be summarized.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>qtlpoly.fitted</code> which contains a list of <code>results</code> for each trait with the following components:
</p>
<table role = "presentation">
<tr><td><code>pheno.col</code></td>
<td>
<p>a phenotype column number.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>a <span class="pkg">sommer</span> object of class <code>mmer</code>.</p>
</td></tr>
<tr><td><code>qtls</code></td>
<td>
<p>a data frame with information from the mapped QTL.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Guilherme da Silva Pereira, <a href="mailto:gdasilv@ncsu.edu">gdasilv@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome-assisted prediction of quantitative traits using the R package sommer. <em>PLoS ONE</em> 11 (6): 1–15. <a href="https://doi.org/10.1371/journal.pone.0156744">doi:10.1371/journal.pone.0156744</a>.
</p>
<p>Pereira GS, Gemenet DC, Mollinari M, Olukolu BA, Wood JC, Mosquera V, Gruneberg WJ, Khan A, Buell CR, Yencho GC, Zeng ZB (2020) Multiple QTL mapping in autopolyploids: a random-effect model approach with application in a hexaploid sweetpotato full-sib population, <em>Genetics</em> 215 (3): 579-595. <a href="https://doi.org/10.1534/genetics.120.303080">doi:10.1534/genetics.120.303080</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_data">read_data</a></code>, <code><a href="#topic+remim">remim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  # Estimate conditional probabilities using mappoly package
  library(mappoly)
  library(qtlpoly)
  genoprob4x = lapply(maps4x[c(5)], calc_genoprob)
  data = read_data(ploidy = 4, geno.prob = genoprob4x, pheno = pheno4x, step = 1)

  # Search for QTL
  remim.mod = remim(data = data, pheno.col = 1, w.size = 15, sig.fwd = 0.0011493379,
sig.bwd = 0.0002284465, d.sint = 1.5, n.clusters = 1)

  # Fit model
  fitted.mod = fit_model(data=data, model=remim.mod, probs="joint", polygenes="none")
  

</code></pre>

<hr>
<h2 id='fit_model2'>Fits multiple QTL models</h2><span id='topic+fit_model2'></span>

<h3>Description</h3>

<p>Fits alternative multiple QTL models by performing variance component estimation using REML.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_model2(
  data,
  model,
  probs = "joint",
  polygenes = "none",
  keep = TRUE,
  verbose = TRUE,
  pheno.col = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_model2_+3A_data">data</code></td>
<td>
<p>an object of class <code>qtlpoly.data</code>.</p>
</td></tr>
<tr><td><code id="fit_model2_+3A_model">model</code></td>
<td>
<p>an object of class <code>qtlpoly.profile</code> or <code>qtlpoly.remim</code>.</p>
</td></tr>
<tr><td><code id="fit_model2_+3A_probs">probs</code></td>
<td>
<p>a character string indicating if either <code>"joint"</code> (genotypes) or <code>"marginal"</code> (parental gametes) conditional probabilities should be used.</p>
</td></tr>
<tr><td><code id="fit_model2_+3A_polygenes">polygenes</code></td>
<td>
<p>a character string indicating if either <code>"none"</code>, <code>"most"</code> or <code>"all"</code> QTL should be used as polygenes.</p>
</td></tr>
<tr><td><code id="fit_model2_+3A_keep">keep</code></td>
<td>
<p>if <code>TRUE</code> (default), stores all matrices and estimates from fitted model; if <code>FALSE</code>, nothing is stored.</p>
</td></tr>
<tr><td><code id="fit_model2_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default), current progress is shown; if
<code>FALSE</code>, no output is produced.</p>
</td></tr>
<tr><td><code id="fit_model2_+3A_pheno.col">pheno.col</code></td>
<td>
<p>a numeric vector with the phenotype column numbers to be summarized; if <code>NULL</code> (default), all phenotypes from <code>'data'</code> will be included.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>qtlpoly.fitted</code> which contains a list of <code>results</code> for each trait with the following components:
</p>
<table role = "presentation">
<tr><td><code>pheno.col</code></td>
<td>
<p>a phenotype column number.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>a <span class="pkg">sommer</span> object of class <code>mmer</code>.</p>
</td></tr>
<tr><td><code>qtls</code></td>
<td>
<p>a data frame with information from the mapped QTL.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Guilherme da Silva Pereira, <a href="mailto:gdasilv@ncsu.edu">gdasilv@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome-assisted prediction of quantitative traits using the R package sommer. <em>PLoS ONE</em> 11 (6): 1–15. <a href="https://doi.org/10.1371/journal.pone.0156744">doi:10.1371/journal.pone.0156744</a>.
</p>
<p>Pereira GS, Gemenet DC, Mollinari M, Olukolu BA, Wood JC, Mosquera V, Gruneberg WJ, Khan A, Buell CR, Yencho GC, Zeng ZB (2020) Multiple QTL mapping in autopolyploids: a random-effect model approach with application in a hexaploid sweetpotato full-sib population, <em>Genetics</em> 215 (3): 579-595. <a href="https://doi.org/10.1534/genetics.120.303080">doi:10.1534/genetics.120.303080</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_data">read_data</a></code>, <code><a href="#topic+remim">remim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  # Estimate conditional probabilities using mappoly package
  library(mappoly)
  library(qtlpoly)
  genoprob4x = lapply(maps4x[c(5)], calc_genoprob)
  data = read_data(ploidy = 4, geno.prob = genoprob4x, pheno = pheno4x, step = 1)

  # Search for QTL
  remim.mod = remim(data = data, pheno.col = 1, w.size = 15, sig.fwd = 0.0011493379,
sig.bwd = 0.0002284465, d.sint = 1.5, n.clusters = 1)

  # Fit model
  fitted.mod = fit_model(data=data, model=remim.mod, probs="joint", polygenes="none")
  

</code></pre>

<hr>
<h2 id='hexafake'>Simulated autohexaploid dataset.</h2><span id='topic+hexafake'></span>

<h3>Description</h3>

<p>A dataset of a hypothetical autohexaploid full-sib population 
containing three homology groups
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hexafake
</code></pre>


<h3>Format</h3>

<p>An object of class <code>mappoly.data</code> which contains a
list with the following components:
</p>

<dl>
<dt>plody</dt><dd><p>ploidy level = 6</p>
</dd>
<dt>n.ind</dt><dd><p>number individuals = 300</p>
</dd>
<dt>n.mrk</dt><dd><p>total number of markers = 1500</p>
</dd>
<dt>ind.names</dt><dd><p>the names of the individuals</p>
</dd>
<dt>mrk.names</dt><dd><p>the names of the markers</p>
</dd>
<dt>dosage.p1</dt><dd><p>a vector containing the dosage in
parent P for all <code>n.mrk</code> markers</p>
</dd>
<dt>dosage.p2</dt><dd><p>a vector containing the dosage in
parent Q for all <code>n.mrk</code> markers</p>
</dd>
<dt>chrom</dt><dd><p>a vector indicating the chromosome each marker
belongs. Zero indicates that the marker was not assigned to any
chromosome</p>
</dd>
<dt>genome.pos</dt><dd><p>Physical position of the markers into the
sequence</p>
</dd>
<dt>geno.dose</dt><dd><p>a matrix containing the dosage for each markers (rows) 
for each individual (columns). Missing data are represented by 
<code>ploidy_level + 1 = 7</code></p>
</dd>
<dt>n.phen</dt><dd><p>There are no phenotypes in this simulation</p>
</dd>
<dt>phen</dt><dd><p>There are no phenotypes in this simulation</p>
</dd>
<dt>chisq.pval</dt><dd><p>vector containing p-values for all markers associated to 
the chi-square test for the expected segregation patterns 
under Mendelian segregation</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Mollinari M, Garcia AAF (2019) Linkage analysis and haplotype phasing in experimental autopolyploid populations with high ploidy level using hidden Markov models, <em>G3: Genes|Genomes|Genetics</em> 9 (10): 3297-3314. <a href="https://doi.org/10.1534/g3.119.400378">doi:10.1534/g3.119.400378</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mappoly)
plot(hexafake)
</code></pre>

<hr>
<h2 id='maps4x'>Autotetraploid potato map</h2><span id='topic+maps4x'></span>

<h3>Description</h3>

<p>A real autotetraploid potato map containing 12 homology groups from a tetraploid potato full-sib family (Atlantic x B1829-5).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maps4x
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"mappoly.map"</code> from the package <span class="pkg">mappoly</span>, which is a list of 12 linkage groups (LGs)
</p>


<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Pereira GS, Gemenet DC, Mollinari M, Olukolu BA, Wood JC, Mosquera V, Gruneberg WJ, Khan A, Buell CR, Yencho GC, Zeng ZB (2019) Multiple QTL mapping in autopolyploids: a random-effect model approach with application in a hexaploid sweetpotato full-sib population, <em>Genetics</em> 215 (3): 579-595. <a href="https://doi.org/10.1534/genetics.120.303080">doi:10.1534/genetics.120.303080</a>.
</p>
<p>Mollinari M, Garcia AAF (2019) Linkage analysis and haplotype phasing in experimental autopolyploid populations with high ploidy level using hidden Markov models, <em>G3: Genes|Genomes|Genetics</em> 9 (10): 3297-3314. <a href="https://doi.org/10.1534/g3.119.400378">doi:10.1534/g3.119.400378</a>
</p>
<p>Pereira GS, Mollinari M, Schumann MJ, Clough ME, Zeng ZB, Yencho C (2021) The recombination landscape and multiple QTL mapping in a <em>Solanum tuberosum</em> cv. ‘Atlantic’-derived F_1 population. Heredity. <a href="https://doi.org/10.1038/s41437-021-00416-x">doi:10.1038/s41437-021-00416-x</a>.
</p>


<h3>See Also</h3>

<p><code><a href="mappoly.html#topic+hexafake">hexafake</a></code>, <code><a href="#topic+pheno6x">pheno6x</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mappoly)
plot_map_list(maps4x)
</code></pre>

<hr>
<h2 id='maps6x'>Simulated autohexaploid map</h2><span id='topic+maps6x'></span>

<h3>Description</h3>

<p>A simulated map containing three homology groups of a hypotetical cross between two autohexaploid individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maps6x
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"mappoly.map"</code> from the package <span class="pkg">mappoly</span>, which is a list of three linkage groups (LGs):
</p>

<dl>
<dt>LG 1</dt><dd><p>538 markers distributed along 112.2 cM</p>
</dd>
<dt>LG 2</dt><dd><p>329 markers distributed along 54.6 cM</p>
</dd>
<dt>LG 3</dt><dd><p>443 markers distributed along 98.2 cM</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Marcelo Mollinari, <a href="mailto:mmollin@ncsu.edu">mmollin@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Pereira GS, Gemenet DC, Mollinari M, Olukolu BA, Wood JC, Mosquera V, Gruneberg WJ, Khan A, Buell CR, Yencho GC, Zeng ZB (2019) Multiple QTL mapping in autopolyploids: a random-effect model approach with application in a hexaploid sweetpotato full-sib population, <em>Genetics</em> 215 (3): 579-595. <a href="https://doi.org/10.1534/genetics.120.303080">doi:10.1534/genetics.120.303080</a>.
</p>
<p>Mollinari M, Garcia AAF (2019) Linkage analysis and haplotype phasing in experimental autopolyploid populations with high ploidy level using hidden Markov models, <em>G3: Genes|Genomes|Genetics</em> 9 (10): 3297-3314. <a href="https://doi.org/10.1534/g3.119.400378">doi:10.1534/g3.119.400378</a>
</p>


<h3>See Also</h3>

<p><code><a href="mappoly.html#topic+hexafake">hexafake</a></code>, <code><a href="#topic+pheno6x">pheno6x</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mappoly)
plot_map_list(maps6x)
</code></pre>

<hr>
<h2 id='mmer_adapted'>Adapt to sommer MNR core function</h2><span id='topic+mmer_adapted'></span>

<h3>Description</h3>

<p>Adapts genomic incidence and relationship (varcov) matrices to run using sommer's C++ core function (v. 4.0 or higher)
Function adapted from sommer v. 3.6 (Author: Giovanny Covarrubias-Pazaran)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mmer_adapted(
  Y,
  X = NULL,
  Z = NULL,
  R = NULL,
  W = NULL,
  method = "NR",
  init = NULL,
  iters = 20,
  tolpar = 0.001,
  tolparinv = 1e-06,
  draw = FALSE,
  silent = FALSE,
  constraint = TRUE,
  EIGEND = FALSE,
  forced = NULL,
  IMP = FALSE,
  complete = TRUE,
  check.model = TRUE,
  restrained = NULL,
  REML = TRUE,
  init.equal = TRUE,
  date.warning = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Author(s)</h3>

<p>Gabriel de Siqueira Gesteira, <a href="mailto:gdesiqu@ncsu.edu">gdesiqu@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Covarrubias-Pazaran G (2016) Genome-assisted prediction of quantitative traits using the R package sommer. <em>PLoS ONE</em> 11 (6): 1–15. <a href="https://doi.org/10.1371/journal.pone.0156744">doi:10.1371/journal.pone.0156744</a>.
</p>
<p>Pereira GS, Gemenet DC, Mollinari M, Olukolu BA, Wood JC, Mosquera V, Gruneberg WJ, Khan A, Buell CR, Yencho GC, Zeng ZB (2020) Multiple QTL mapping in autopolyploids: a random-effect model approach with application in a hexaploid sweetpotato full-sib population, <em>Genetics</em> 215 (3): 579-595. <a href="https://doi.org/10.1534/genetics.120.303080">doi:10.1534/genetics.120.303080</a>.
</p>

<hr>
<h2 id='modify_qtl'>Modify QTL model</h2><span id='topic+modify_qtl'></span><span id='topic+print.qtlpoly.modify'></span>

<h3>Description</h3>

<p>Adds or removes QTL manually from a given model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modify_qtl(
  model,
  pheno.col = NULL,
  add.qtl = NULL,
  drop.qtl = NULL,
  verbose = TRUE
)

## S3 method for class 'qtlpoly.modify'
print(x, pheno.col = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modify_qtl_+3A_model">model</code></td>
<td>
<p>an object of class <code>qtlpoly.model</code> containing the QTL to be modified.</p>
</td></tr>
<tr><td><code id="modify_qtl_+3A_pheno.col">pheno.col</code></td>
<td>
<p>a phenotype column number whose model will be modified or printed.</p>
</td></tr>
<tr><td><code id="modify_qtl_+3A_add.qtl">add.qtl</code></td>
<td>
<p>a marker position number to be added.</p>
</td></tr>
<tr><td><code id="modify_qtl_+3A_drop.qtl">drop.qtl</code></td>
<td>
<p>a marker position number to be removed.</p>
</td></tr>
<tr><td><code id="modify_qtl_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default), current progress is shown; if <code>FALSE</code>, no output is produced.</p>
</td></tr>
<tr><td><code id="modify_qtl_+3A_x">x</code></td>
<td>
<p>an object of class <code>qtlpoly.modify</code> to be printed.</p>
</td></tr>
<tr><td><code id="modify_qtl_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>qtlpoly.modify</code> which contains a list of <code>results</code> for each trait with the following components:
</p>
<table role = "presentation">
<tr><td><code>pheno.col</code></td>
<td>
<p>a phenotype column number.</p>
</td></tr>
<tr><td><code>stat</code></td>
<td>
<p>a vector containing values from score statistics.</p>
</td></tr>
<tr><td><code>pval</code></td>
<td>
<p>a vector containing <em>p</em>-values from score statistics.</p>
</td></tr>
<tr><td><code>qtls</code></td>
<td>
<p>a data frame with information from the mapped QTL.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Guilherme da Silva Pereira, <a href="mailto:gdasilv@ncsu.edu">gdasilv@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Pereira GS, Gemenet DC, Mollinari M, Olukolu BA, Wood JC, Mosquera V, Gruneberg WJ, Khan A, Buell CR, Yencho GC, Zeng ZB (2020) Multiple QTL mapping in autopolyploids: a random-effect model approach with application in a hexaploid sweetpotato full-sib population, <em>Genetics</em> 215 (3): 579-595. <a href="https://doi.org/10.1534/genetics.120.303080">doi:10.1534/genetics.120.303080</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_data">read_data</a></code>, <code><a href="#topic+remim">remim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  # Estimate conditional probabilities using mappoly package
  library(mappoly)
  library(qtlpoly)
  genoprob4x = lapply(maps4x[c(5)], calc_genoprob)
  data = read_data(ploidy = 4, geno.prob = genoprob4x, pheno = pheno4x, step = 1)

  # Search for QTL
  remim.mod = remim(data = data, pheno.col = 1, w.size = 15, sig.fwd = 0.0011493379,
sig.bwd = 0.0002284465, d.sint = 1.5, n.clusters = 1)

  # Modify model
  modified.mod = modify_qtl(model = remim.mod, pheno.col = 1, drop.qtl = 18)
  

</code></pre>

<hr>
<h2 id='null_model'>Null model</h2><span id='topic+null_model'></span><span id='topic+print.qtlpoly.null'></span>

<h3>Description</h3>

<p>Creates a null model (with no QTL) for each trait.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>null_model(
  data,
  offset.data = NULL,
  pheno.col = NULL,
  n.clusters = NULL,
  plot = NULL,
  verbose = TRUE
)

## S3 method for class 'qtlpoly.null'
print(x, pheno.col = NULL, ...)

## S3 method for class 'qtlpoly.null'
print(x, pheno.col = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="null_model_+3A_data">data</code></td>
<td>
<p>an object of class <code>qtlpoly.data</code>.</p>
</td></tr>
<tr><td><code id="null_model_+3A_offset.data">offset.data</code></td>
<td>
<p>a data frame with the same dimensions of <code>data$pheno</code> containing offset variables; if <code>NULL</code> (default), no offset variables are considered.</p>
</td></tr>
<tr><td><code id="null_model_+3A_pheno.col">pheno.col</code></td>
<td>
<p>a numeric vector with the phenotype columns to be analyzed; if <code>NULL</code>, all phenotypes from <code>'data'</code> will be included.</p>
</td></tr>
<tr><td><code id="null_model_+3A_n.clusters">n.clusters</code></td>
<td>
<p>number of parallel processes to spawn.</p>
</td></tr>
<tr><td><code id="null_model_+3A_plot">plot</code></td>
<td>
<p>a suffix for the file's name containing simple plots of every QTL search round, e.g. &quot;null&quot; (default); if <code>NULL</code>, no file is produced.</p>
</td></tr>
<tr><td><code id="null_model_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default), current progress is shown; if <code>FALSE</code>, no output is produced.</p>
</td></tr>
<tr><td><code id="null_model_+3A_x">x</code></td>
<td>
<p>an object of class <code>qtlpoly.null</code> to be printed.</p>
</td></tr>
<tr><td><code id="null_model_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>qtlpoly.null</code> which contains a list of <code>results</code> for each trait with the following components:
</p>
<table role = "presentation">
<tr><td><code>pheno.col</code></td>
<td>
<p>a phenotype column number.</p>
</td></tr>
<tr><td><code>stat</code></td>
<td>
<p>a vector containing values from score statistics.</p>
</td></tr>
<tr><td><code>pval</code></td>
<td>
<p>a vector containing <em>p</em>-values from score statistics.</p>
</td></tr>
<tr><td><code>qtls</code></td>
<td>
<p>a data frame with information from the mapped QTL (<code>NULL</code> at this point).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Guilherme da Silva Pereira, <a href="mailto:gdasilv@ncsu.edu">gdasilv@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Pereira GS, Gemenet DC, Mollinari M, Olukolu BA, Wood JC, Mosquera V, Gruneberg WJ, Khan A, Buell CR, Yencho GC, Zeng ZB (2020) Multiple QTL mapping in autopolyploids: a random-effect model approach with application in a hexaploid sweetpotato full-sib population, <em>Genetics</em> 215 (3): 579-595. <a href="https://doi.org/10.1534/genetics.120.303080">doi:10.1534/genetics.120.303080</a>.
</p>
<p>Qu L, Guennel T, Marshall SL (2013) Linear score tests for variance components in linear mixed models and applications to genetic association studies. <em>Biometrics</em> 69 (4): 883–92.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_data">read_data</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  # Estimate conditional probabilities using mappoly package
  library(mappoly)
  library(qtlpoly)
  genoprob4x = lapply(maps4x[c(5)], calc_genoprob)
  data = read_data(ploidy = 4, geno.prob = genoprob4x, pheno = pheno4x, step = 1)

  # Build null models
  null.mod = null_model(data = data, pheno.col = 1, n.clusters = 1)
  

</code></pre>

<hr>
<h2 id='null_model2'>Null model</h2><span id='topic+null_model2'></span>

<h3>Description</h3>

<p>Creates a null model (with no QTL) for each trait.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>null_model2(
  data,
  offset.data = NULL,
  pheno.col = NULL,
  n.clusters = NULL,
  plot = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="null_model2_+3A_data">data</code></td>
<td>
<p>an object of class <code>qtlpoly.data</code>.</p>
</td></tr>
<tr><td><code id="null_model2_+3A_offset.data">offset.data</code></td>
<td>
<p>a data frame with the same dimensions of <code>data$pheno</code> containing offset variables; if <code>NULL</code> (default), no offset variables are considered.</p>
</td></tr>
<tr><td><code id="null_model2_+3A_pheno.col">pheno.col</code></td>
<td>
<p>a numeric vector with the phenotype columns to be analyzed; if <code>NULL</code>, all phenotypes from <code>'data'</code> will be included.</p>
</td></tr>
<tr><td><code id="null_model2_+3A_n.clusters">n.clusters</code></td>
<td>
<p>number of parallel processes to spawn.</p>
</td></tr>
<tr><td><code id="null_model2_+3A_plot">plot</code></td>
<td>
<p>a suffix for the file's name containing simple plots of every QTL search round, e.g. &quot;null&quot; (default); if <code>NULL</code>, no file is produced.</p>
</td></tr>
<tr><td><code id="null_model2_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default), current progress is shown; if <code>FALSE</code>, no output is produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>qtlpoly.null</code> which contains a list of <code>results</code> for each trait with the following components:
</p>
<table role = "presentation">
<tr><td><code>pheno.col</code></td>
<td>
<p>a phenotype column number.</p>
</td></tr>
<tr><td><code>stat</code></td>
<td>
<p>a vector containing values from score statistics.</p>
</td></tr>
<tr><td><code>pval</code></td>
<td>
<p>a vector containing <em>p</em>-values from score statistics.</p>
</td></tr>
<tr><td><code>qtls</code></td>
<td>
<p>a data frame with information from the mapped QTL (<code>NULL</code> at this point).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Guilherme da Silva Pereira, <a href="mailto:gdasilv@ncsu.edu">gdasilv@ncsu.edu</a>, Gabriel de Siqueira Gesteira, <a href="mailto:gdesiqu@ncsu.edu">gdesiqu@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Pereira GS, Gemenet DC, Mollinari M, Olukolu BA, Wood JC, Mosquera V, Gruneberg WJ, Khan A, Buell CR, Yencho GC, Zeng ZB (2020) Multiple QTL mapping in autopolyploids: a random-effect model approach with application in a hexaploid sweetpotato full-sib population, <em>Genetics</em> 215 (3): 579-595. <a href="https://doi.org/10.1534/genetics.120.303080">doi:10.1534/genetics.120.303080</a>.
</p>
<p>Qu L, Guennel T, Marshall SL (2013) Linear score tests for variance components in linear mixed models and applications to genetic association studies. <em>Biometrics</em> 69 (4): 883–92.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_data">read_data</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  # Estimate conditional probabilities using mappoly package
  library(mappoly)
  library(qtlpoly)
  genoprob4x = lapply(maps4x[c(5)], calc_genoprob)
  data = read_data(ploidy = 4, geno.prob = genoprob4x, pheno = pheno4x, step = 1)

  # Build null models
  null.mod = null_model(data = data, pheno.col = 1, n.clusters = 1)
  

</code></pre>

<hr>
<h2 id='optimize_qtl'>Model optimization</h2><span id='topic+optimize_qtl'></span><span id='topic+print.qtlpoly.optimize'></span>

<h3>Description</h3>

<p>Tests each QTL at a time and updates its position (if it changes) or drops the QTL (if non-significant).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimize_qtl(
  data,
  offset.data = NULL,
  model,
  sig.bwd = 0.05,
  score.null = NULL,
  polygenes = FALSE,
  n.clusters = NULL,
  plot = NULL,
  verbose = TRUE
)

## S3 method for class 'qtlpoly.optimize'
print(x, pheno.col = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optimize_qtl_+3A_data">data</code></td>
<td>
<p>an object of class <code>qtlpoly.data</code>.</p>
</td></tr>
<tr><td><code id="optimize_qtl_+3A_offset.data">offset.data</code></td>
<td>
<p>a data frame with the same dimensions of <code>data$pheno</code> containing offset variables; if <code>NULL</code> (default), no offset variables are considered.</p>
</td></tr>
<tr><td><code id="optimize_qtl_+3A_model">model</code></td>
<td>
<p>an object of class <code>qtlpoly.model</code> containing the QTL to be optimized.</p>
</td></tr>
<tr><td><code id="optimize_qtl_+3A_sig.bwd">sig.bwd</code></td>
<td>
<p>the desired score-based <em>p</em>-value threshold for backward elimination, e.g. 0.0001 (default).</p>
</td></tr>
<tr><td><code id="optimize_qtl_+3A_score.null">score.null</code></td>
<td>
<p>an object of class <code>qtlpoly.null</code> with results of score statistics from resampling.</p>
</td></tr>
<tr><td><code id="optimize_qtl_+3A_polygenes">polygenes</code></td>
<td>
<p>if <code>TRUE</code> all QTL but the one being tested are treated as a single polygenic effect, if <code>FALSE</code> (default) all QTL effect variances have to estimated.</p>
</td></tr>
<tr><td><code id="optimize_qtl_+3A_n.clusters">n.clusters</code></td>
<td>
<p>number of parallel processes to spawn.</p>
</td></tr>
<tr><td><code id="optimize_qtl_+3A_plot">plot</code></td>
<td>
<p>a suffix for the file's name containing plots of every QTL optimization round, e.g. &quot;optimize&quot; (default); if <code>NULL</code>, no file is produced.</p>
</td></tr>
<tr><td><code id="optimize_qtl_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default), current progress is shown; if <code>FALSE</code>, no output is produced.</p>
</td></tr>
<tr><td><code id="optimize_qtl_+3A_x">x</code></td>
<td>
<p>an object of class <code>qtlpoly.optimize</code> to be printed.</p>
</td></tr>
<tr><td><code id="optimize_qtl_+3A_pheno.col">pheno.col</code></td>
<td>
<p>a numeric vector with the phenotype columns to be printed; if <code>NULL</code>, all phenotypes from <code>'data'</code> will be included.</p>
</td></tr>
<tr><td><code id="optimize_qtl_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>qtlpoly.optimize</code> which contains a list of <code>results</code> for each trait with the following components:
</p>
<table role = "presentation">
<tr><td><code>pheno.col</code></td>
<td>
<p>a phenotype column number.</p>
</td></tr>
<tr><td><code>stat</code></td>
<td>
<p>a vector containing values from score statistics.</p>
</td></tr>
<tr><td><code>pval</code></td>
<td>
<p>a vector containing <em>p</em>-values from score statistics.</p>
</td></tr>
<tr><td><code>qtls</code></td>
<td>
<p>a data frame with information from the mapped QTL.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Guilherme da Silva Pereira, <a href="mailto:gdasilv@ncsu.edu">gdasilv@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Pereira GS, Gemenet DC, Mollinari M, Olukolu BA, Wood JC, Mosquera V, Gruneberg WJ, Khan A, Buell CR, Yencho GC, Zeng ZB (2020) Multiple QTL mapping in autopolyploids: a random-effect model approach with application in a hexaploid sweetpotato full-sib population, <em>Genetics</em> 215 (3): 579-595. <a href="https://doi.org/10.1534/genetics.120.303080">doi:10.1534/genetics.120.303080</a>.
</p>
<p>Qu L, Guennel T, Marshall SL (2013) Linear score tests for variance components in linear mixed models and applications to genetic association studies. <em>Biometrics</em> 69 (4): 883–92.
</p>
<p>Zou F, Fine JP, Hu J, Lin DY (2004) An efficient resampling method for assessing genome-wide statistical significance in mapping quantitative trait loci. <em>Genetics</em> 168 (4): 2307-16. <a href="https://doi.org/10.1534/genetics.104.031427">doi:10.1534/genetics.104.031427</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_data">read_data</a></code>, <code><a href="#topic+null_model">null_model</a></code>, <code><a href="#topic+search_qtl">search_qtl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  # Estimate conditional probabilities using mappoly package
  library(mappoly)
  library(qtlpoly)
  genoprob4x = lapply(maps4x[c(5)], calc_genoprob)
  data = read_data(ploidy = 4, geno.prob = genoprob4x, pheno = pheno4x, step = 1)

  # Build null model
  null.mod = null_model(data = data, pheno.col = 1,n.clusters = 1)

  # Perform forward search
  search.mod = search_qtl(data = data, model = null.mod,
w.size = 15, sig.fwd = 0.01, n.clusters = 1)

  # Optimize model
  optimize.mod = optimize_qtl(data = data, model = search.mod, sig.bwd = 0.0001, n.clusters = 1)
  

</code></pre>

<hr>
<h2 id='permutations'>Fixed-effect interval mapping (FEIM) model permutations</h2><span id='topic+permutations'></span><span id='topic+print.qtlpoly.perm'></span><span id='topic+plot.qtlpoly.perm'></span>

<h3>Description</h3>

<p>Stores maximum LOD scores for a number of permutations of given phenotypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permutations(
  data,
  offset.data = NULL,
  pheno.col = NULL,
  n.sim = 1000,
  probs = c(0.9, 0.95),
  n.clusters = NULL,
  seed = 123,
  verbose = TRUE
)

## S3 method for class 'qtlpoly.perm'
print(x, pheno.col = NULL, probs = c(0.9, 0.95), ...)

## S3 method for class 'qtlpoly.perm'
plot(x, pheno.col = NULL, probs = c(0.9, 0.95), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="permutations_+3A_data">data</code></td>
<td>
<p>an object of class <code>qtlpoly.data</code>.</p>
</td></tr>
<tr><td><code id="permutations_+3A_offset.data">offset.data</code></td>
<td>
<p>a subset of the data object to be used in permutation calculations.</p>
</td></tr>
<tr><td><code id="permutations_+3A_pheno.col">pheno.col</code></td>
<td>
<p>a numeric vector with the phenotype columns to be analyzed; if <code>NULL</code> (default), all phenotypes from <code>'data'</code> will be included.</p>
</td></tr>
<tr><td><code id="permutations_+3A_n.sim">n.sim</code></td>
<td>
<p>a number of simulations, e.g. 1000 (default).</p>
</td></tr>
<tr><td><code id="permutations_+3A_probs">probs</code></td>
<td>
<p>a vector of probability values in [0, 1] representing the quantiles, e.g. c(0.90, 0.95) for the 90% and 95% quantiles.</p>
</td></tr>
<tr><td><code id="permutations_+3A_n.clusters">n.clusters</code></td>
<td>
<p>a number of parallel processes to spawn.</p>
</td></tr>
<tr><td><code id="permutations_+3A_seed">seed</code></td>
<td>
<p>an integer for the <code>set.seed()</code> function; if <code>NULL</code>, no reproducible seeds are set.</p>
</td></tr>
<tr><td><code id="permutations_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default), current progress is shown; if <code>FALSE</code>, no output is produced.</p>
</td></tr>
<tr><td><code id="permutations_+3A_x">x</code></td>
<td>
<p>an object of class <code>qtlpoly.perm</code> to be printed or plotted.</p>
</td></tr>
<tr><td><code id="permutations_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>qtlpoly.perm</code> which contains a list of <code>results</code> for each trait with the maximum LOD score per permutation.
</p>
<p>LOD score thresholds for given quantiles for each trait.
</p>
<p>A <span class="pkg">ggplot2</span> histogram with the distribution of ordered maximum LOD scores and thresholds for given quantiles for each trait.
</p>


<h3>Author(s)</h3>

<p>Guilherme da Silva Pereira, <a href="mailto:gdasilv@ncsu.edu">gdasilv@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Churchill GA, Doerge RW (1994) Empirical threshold values for quantitative trait mapping, <em>Genetics</em> 138: 963-971.
</p>
<p>Pereira GS, Gemenet DC, Mollinari M, Olukolu BA, Wood JC, Mosquera V, Gruneberg WJ, Khan A, Buell CR, Yencho GC, Zeng ZB (2020) Multiple QTL mapping in autopolyploids: a random-effect model approach with application in a hexaploid sweetpotato full-sib population, <em>Genetics</em> 215 (3): 579-595. <a href="https://doi.org/10.1534/genetics.120.303080">doi:10.1534/genetics.120.303080</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+feim">feim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  # Estimate conditional probabilities using mappoly package
  library(mappoly)
  library(qtlpoly)
  genoprob4x = lapply(maps4x[c(5)], calc_genoprob)
  data = read_data(ploidy = 4, geno.prob = genoprob4x, pheno = pheno4x, step = 1)

  # Perform permutations
  perm = permutations(data = data, pheno.col = 1, n.sim = 10, n.clusters = 1)
  

</code></pre>

<hr>
<h2 id='pheno4x'>Autotetraploid potato phenotypes</h2><span id='topic+pheno4x'></span>

<h3>Description</h3>

<p>A subset of phenotypes from a tetraploid potato full-sib family (Atlantic x B1829-5).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pheno4x
</code></pre>


<h3>Format</h3>

<p>A data frame of phenotypes with 156 named individuals in rows and three named phenotypes in columns, which are:
</p>

<dl>
<dt>FM07</dt><dd><p>Foliage maturity evaluated in 2007.</p>
</dd>
<dt>FM08</dt><dd><p>Foliage maturity evaluated in 2008.</p>
</dd>
<dt>FM14</dt><dd><p>Foliage maturity evaluated in 2014.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Guilherme da Silva Pereira, <a href="mailto:gdasilv@ncsu.edu">gdasilv@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Pereira GS, Gemenet DC, Mollinari M, Olukolu BA, Wood JC, Mosquera V, Gruneberg WJ, Khan A, Buell CR, Yencho GC, Zeng ZB (2020) Multiple QTL mapping in autopolyploids: a random-effect model approach with application in a hexaploid sweetpotato full-sib population, <em>Genetics</em> 215 (3): 579-595. <a href="https://doi.org/10.1534/genetics.120.303080">doi:10.1534/genetics.120.303080</a>.
</p>
<p>Pereira GS, Mollinari M, Schumann MJ, Clough ME, Zeng ZB, Yencho C (2021) The recombination landscape and multiple QTL mapping in a <em>Solanum tuberosum</em> cv. ‘Atlantic’-derived F_1 population. Heredity. <a href="https://doi.org/10.1038/s41437-021-00416-x">doi:10.1038/s41437-021-00416-x</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(pheno4x)
</code></pre>

<hr>
<h2 id='pheno6x'>Simulated phenotypes</h2><span id='topic+pheno6x'></span>

<h3>Description</h3>

<p>A simulated data set of phenotypes for a hipotetical autohexaploid species map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pheno6x
</code></pre>


<h3>Format</h3>

<p>A data frame of phenotypes with 300 named individuals in rows and three named phenotypes in columns, which are:
</p>

<dl>
<dt>T32</dt><dd><p>3 QTLs, with heritabilities of 0.20 (LG 1 at 32.03 cM), 0.15 (LG 1 at 95.02 cM) and 0.30 (LG 2 at 40.01 cM).</p>
</dd>
<dt>T17</dt><dd><p>1 QTL, with heritability of 0.15 (LG 3 at 34.51 cM).</p>
</dd>
<dt>T45</dt><dd><p>no QTLs.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Guilherme da Silva Pereira, <a href="mailto:gdasilv@ncsu.edu">gdasilv@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Pereira GS, Gemenet DC, Mollinari M, Olukolu BA, Wood JC, Mosquera V, Gruneberg WJ, Khan A, Buell CR, Yencho GC, Zeng ZB (2019) Multiple QTL mapping in autopolyploids: a random-effect model approach with application in a hexaploid sweetpotato full-sib population, <em>Genetics</em> 215 (3): 579-595. <a href="https://doi.org/10.1534/genetics.120.303080">doi:10.1534/genetics.120.303080</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate_qtl">simulate_qtl</a></code>, <code><a href="#topic+pheno4x">pheno4x</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(pheno6x)
</code></pre>

<hr>
<h2 id='plot_profile'>Logarithm of <em>P</em>-value (LOP) profile plots</h2><span id='topic+plot_profile'></span>

<h3>Description</h3>

<p>Plots profiled logarithm of score-based <em>P</em>-values (LOP) from individual or combined traits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_profile(
  data = data,
  model = model,
  pheno.col = NULL,
  sup.int = FALSE,
  main = NULL,
  legend = "bottom",
  ylim = NULL,
  grid = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_profile_+3A_data">data</code></td>
<td>
<p>an object of class <code>qtlpoly.data</code>.</p>
</td></tr>
<tr><td><code id="plot_profile_+3A_model">model</code></td>
<td>
<p>an object of class <code>qtlpoly.profile</code> or <code>qtlpoly.remim</code>.</p>
</td></tr>
<tr><td><code id="plot_profile_+3A_pheno.col">pheno.col</code></td>
<td>
<p>a numeric vector with the phenotype column numbers to be plotted; if <code>NULL</code>, all phenotypes from <code>'data'</code> will be included.</p>
</td></tr>
<tr><td><code id="plot_profile_+3A_sup.int">sup.int</code></td>
<td>
<p>if <code>TRUE</code>, support interval are shown as shaded areas; if <code>FALSE</code> (default), no support interval is show.</p>
</td></tr>
<tr><td><code id="plot_profile_+3A_main">main</code></td>
<td>
<p>a character string with the main title; if <code>NULL</code>, no title is shown.</p>
</td></tr>
<tr><td><code id="plot_profile_+3A_legend">legend</code></td>
<td>
<p>legend position (either &quot;bottom&quot;, &quot;top&quot;, &quot;left&quot; or &quot;right&quot;); if <code>NULL</code>, no legend is shown.</p>
</td></tr>
<tr><td><code id="plot_profile_+3A_ylim">ylim</code></td>
<td>
<p>a numeric value pair supplying the limits of y-axis, e.g. c(0,10); if <code>NULL</code> (default), limits will be provided automatically.</p>
</td></tr>
<tr><td><code id="plot_profile_+3A_grid">grid</code></td>
<td>
<p>if <code>TRUE</code>, profiles will be organized in rows (one per trait); if <code>FALSE</code> (default), profiles will appear superimposed. Only effective when plotting profiles from more than one trait.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <span class="pkg">ggplot2</span> with the LOP profiles for each trait.
</p>


<h3>Author(s)</h3>

<p>Guilherme da Silva Pereira, <a href="mailto:gdasilv@ncsu.edu">gdasilv@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Pereira GS, Gemenet DC, Mollinari M, Olukolu BA, Wood JC, Mosquera V, Gruneberg WJ, Khan A, Buell CR, Yencho GC, Zeng ZB (2020) Multiple QTL mapping in autopolyploids: a random-effect model approach with application in a hexaploid sweetpotato full-sib population, <em>Genetics</em> 215 (3): 579-595. <a href="https://doi.org/10.1534/genetics.120.303080">doi:10.1534/genetics.120.303080</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+profile_qtl">profile_qtl</a></code>,  <code><a href="#topic+remim">remim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  # Estimate conditional probabilities using mappoly package
  library(mappoly)
  library(qtlpoly)
  genoprob4x = lapply(maps4x[c(5)], calc_genoprob)
  data = read_data(ploidy = 4, geno.prob = genoprob4x, pheno = pheno4x, step = 1)

  # Search for QTL
  remim.mod = remim(data = data, pheno.col = 1, w.size = 15, sig.fwd = 0.0011493379,
sig.bwd = 0.0002284465, d.sint = 1.5, n.clusters = 1)

  # Plot profile
  plot_profile(data = data, model = remim.mod, grid = FALSE)
  

</code></pre>

<hr>
<h2 id='plot_qtl'>QTL heritability and significance plot</h2><span id='topic+plot_qtl'></span>

<h3>Description</h3>

<p>Creates a plot where dot sizes and colors represent the QTLs heritabilities and their <em>p</em>-values, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_qtl(
  data = data,
  model = model,
  fitted = fitted,
  pheno.col = NULL,
  main = NULL,
  drop.pheno = TRUE,
  drop.lgs = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_qtl_+3A_data">data</code></td>
<td>
<p>an object of class <code>qtlpoly.data</code>.</p>
</td></tr>
<tr><td><code id="plot_qtl_+3A_model">model</code></td>
<td>
<p>an object of class <code>qtlpoly.profile</code> or <code>qtlpoly.remim</code>.</p>
</td></tr>
<tr><td><code id="plot_qtl_+3A_fitted">fitted</code></td>
<td>
<p>an object of class <code>qtlpoly.fitted</code>.</p>
</td></tr>
<tr><td><code id="plot_qtl_+3A_pheno.col">pheno.col</code></td>
<td>
<p>the desired phenotype column numbers to be plotted. The order here specifies the order of plotting (from top to bottom.)</p>
</td></tr>
<tr><td><code id="plot_qtl_+3A_main">main</code></td>
<td>
<p>plot title; if <code>NULL</code> (the default), no title is shown.</p>
</td></tr>
<tr><td><code id="plot_qtl_+3A_drop.pheno">drop.pheno</code></td>
<td>
<p>if <code>FALSE</code>, shows the names of all traits from <code>pheno.col</code>, even of those with no QTLs; if <code>TRUE</code> (the default), shows only the traits with QTL(s).</p>
</td></tr>
<tr><td><code id="plot_qtl_+3A_drop.lgs">drop.lgs</code></td>
<td>
<p>if <code>FALSE</code>, shows all linkage groups, even those with no QTL; if <code>TRUE</code> (the default), shows only the linkage groups with QTL(s).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <span class="pkg">ggplot2</span> with dots representing the QTLs.
</p>


<h3>Author(s)</h3>

<p>Guilherme da Silva Pereira, <a href="mailto:gdasilv@ncsu.edu">gdasilv@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Pereira GS, Gemenet DC, Mollinari M, Olukolu BA, Wood JC, Mosquera V, Gruneberg WJ, Khan A, Buell CR, Yencho GC, Zeng ZB (2020) Multiple QTL mapping in autopolyploids: a random-effect model approach with application in a hexaploid sweetpotato full-sib population, <em>Genetics</em> 215 (3): 579-595. <a href="https://doi.org/10.1534/genetics.120.303080">doi:10.1534/genetics.120.303080</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_data">read_data</a></code>, <code><a href="#topic+remim">remim</a></code>, <code><a href="#topic+fit_model">fit_model</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  # Estimate conditional probabilities using mappoly package
  library(mappoly)
  library(qtlpoly)
  genoprob4x = lapply(maps4x[c(5)], calc_genoprob)
  data = read_data(ploidy = 4, geno.prob = genoprob4x, pheno = pheno4x, step = 1)

  # Search for QTL
  remim.mod = remim(data = data, pheno.col = 1, w.size = 15, sig.fwd = 0.0011493379,
sig.bwd = 0.0002284465, d.sint = 1.5, n.clusters = 1)

  # Fit model
  fitted.mod = fit_model(data, remim.mod, probs="joint", polygenes="none")

  # Plot QTL
  plot_qtl(data, remim.mod, fitted.mod)
  
</code></pre>

<hr>
<h2 id='plot_sint'>QTLs with respective support interval plots</h2><span id='topic+plot_sint'></span>

<h3>Description</h3>

<p>Creates a plot where colored bars represent the support intervals for QTL peaks (black dots).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_sint(data, model, pheno.col = NULL, main = NULL, drop = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_sint_+3A_data">data</code></td>
<td>
<p>an object of class <code>qtlpoly.data</code>.</p>
</td></tr>
<tr><td><code id="plot_sint_+3A_model">model</code></td>
<td>
<p>an object of class <code>qtlpoly.profile</code> or <code>qtlpoly.remim</code>.</p>
</td></tr>
<tr><td><code id="plot_sint_+3A_pheno.col">pheno.col</code></td>
<td>
<p>a numeric vector with the phenotype column numbers to be plotted; if <code>NULL</code>, all phenotypes from <code>'data'</code> will be included.</p>
</td></tr>
<tr><td><code id="plot_sint_+3A_main">main</code></td>
<td>
<p>a character string with the main title; if <code>NULL</code>, no title will be shown.</p>
</td></tr>
<tr><td><code id="plot_sint_+3A_drop">drop</code></td>
<td>
<p>if <code>TRUE</code>, phenotypes with no QTL will be dropped; if <code>FALSE</code> (default), all phenotypes will be shown.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <span class="pkg">ggplot2</span> with QTL bars for each linkage group.
</p>


<h3>Author(s)</h3>

<p>Guilherme da Silva Pereira, <a href="mailto:gdasilv@ncsu.edu">gdasilv@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Pereira GS, Gemenet DC, Mollinari M, Olukolu BA, Wood JC, Mosquera V, Gruneberg WJ, Khan A, Buell CR, Yencho GC, Zeng ZB (2020) Multiple QTL mapping in autopolyploids: a random-effect model approach with application in a hexaploid sweetpotato full-sib population, <em>Genetics</em> 215 (3): 579-595. <a href="https://doi.org/10.1534/genetics.120.303080">doi:10.1534/genetics.120.303080</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_data">read_data</a></code>, <code><a href="#topic+remim">remim</a></code>, <code><a href="#topic+profile_qtl">profile_qtl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  # Estimate conditional probabilities using mappoly package
  library(mappoly)
  library(qtlpoly)
  genoprob4x = lapply(maps4x[c(5)], calc_genoprob)
  data = read_data(ploidy = 4, geno.prob = genoprob4x, pheno = pheno4x, step = 1)

  # Search for QTL
  remim.mod = remim(data = data, pheno.col = 1, w.size = 15, sig.fwd = 0.0011493379,
sig.bwd = 0.0002284465, d.sint = 1.5, n.clusters = 1)

  # Plot support intervals
  plot_sint(data = data, model = remim.mod)
  
</code></pre>

<hr>
<h2 id='profile_qtl'>QTL profiling</h2><span id='topic+profile_qtl'></span><span id='topic+print.qtlpoly.profile'></span>

<h3>Description</h3>

<p>Generates the score-based genome-wide profile conditional to the selected QTL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>profile_qtl(
  data,
  model,
  d.sint = 1.5,
  polygenes = FALSE,
  n.clusters = NULL,
  plot = NULL,
  verbose = TRUE
)

## S3 method for class 'qtlpoly.profile'
print(x, pheno.col = NULL, sint = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="profile_qtl_+3A_data">data</code></td>
<td>
<p>an object of class <code>qtlpoly.data</code>.</p>
</td></tr>
<tr><td><code id="profile_qtl_+3A_model">model</code></td>
<td>
<p>an object of class <code>qtlpoly.model</code> containing the QTL to be profiled.</p>
</td></tr>
<tr><td><code id="profile_qtl_+3A_d.sint">d.sint</code></td>
<td>
<p>a <code class="reqn">d</code> value to subtract from logarithm of <em>p</em>-value (<code class="reqn">LOP-d</code>) for support interval calculation, e.g. <code class="reqn">d=1.5</code> (default) represents approximate 95% support interval.</p>
</td></tr>
<tr><td><code id="profile_qtl_+3A_polygenes">polygenes</code></td>
<td>
<p>if <code>TRUE</code> all QTL but the one being tested are treated as a single polygenic effect, if <code>FALSE</code> (default) all QTL effect variances have to estimated.</p>
</td></tr>
<tr><td><code id="profile_qtl_+3A_n.clusters">n.clusters</code></td>
<td>
<p>number of parallel processes to spawn.</p>
</td></tr>
<tr><td><code id="profile_qtl_+3A_plot">plot</code></td>
<td>
<p>a suffix for the file's name containing plots of every QTL profiling round, e.g. &quot;profile&quot; (default); if <code>NULL</code>, no file is produced.</p>
</td></tr>
<tr><td><code id="profile_qtl_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default), current progress is shown; if <code>FALSE</code>, no output is produced.</p>
</td></tr>
<tr><td><code id="profile_qtl_+3A_x">x</code></td>
<td>
<p>an object of class <code>qtlpoly.profile</code> to be printed.</p>
</td></tr>
<tr><td><code id="profile_qtl_+3A_pheno.col">pheno.col</code></td>
<td>
<p>a numeric vector with the phenotype column numbers to be plotted; if <code>NULL</code>, all phenotypes from <code>'data'</code> will be included.</p>
</td></tr>
<tr><td><code id="profile_qtl_+3A_sint">sint</code></td>
<td>
<p>whether <code>"upper"</code> or <code>"lower"</code> support intervals should be printed; if <code>NULL</code> (default), only QTL peak information will be printed.</p>
</td></tr>
<tr><td><code id="profile_qtl_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>qtlpoly.profile</code> which contains a list of <code>results</code> for each trait with the following components:
</p>
<table role = "presentation">
<tr><td><code>pheno.col</code></td>
<td>
<p>a phenotype column number.</p>
</td></tr>
<tr><td><code>stat</code></td>
<td>
<p>a vector containing values from score statistics.</p>
</td></tr>
<tr><td><code>pval</code></td>
<td>
<p>a vector containing <em>p</em>-values from score statistics.</p>
</td></tr>
<tr><td><code>qtls</code></td>
<td>
<p>a data frame with information from the mapped QTL.</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>a data frame with information from the lower support interval of mapped QTL.</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p>a data frame with information from the upper support interval of mapped QTL.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Guilherme da Silva Pereira, <a href="mailto:gdasilv@ncsu.edu">gdasilv@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Pereira GS, Gemenet DC, Mollinari M, Olukolu BA, Wood JC, Mosquera V, Gruneberg WJ, Khan A, Buell CR, Yencho GC, Zeng ZB (2020) Multiple QTL mapping in autopolyploids: a random-effect model approach with application in a hexaploid sweetpotato full-sib population, <em>Genetics</em> 215 (3): 579-595. <a href="https://doi.org/10.1534/genetics.120.303080">doi:10.1534/genetics.120.303080</a>.
</p>
<p>Qu L, Guennel T, Marshall SL (2013) Linear score tests for variance components in linear mixed models and applications to genetic association studies. <em>Biometrics</em> 69 (4): 883–92.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  # Estimate conditional probabilities using mappoly package
  library(mappoly)
  library(qtlpoly)
  genoprob4x = lapply(maps4x[c(5)], calc_genoprob)
  data = read_data(ploidy = 4, geno.prob = genoprob4x, pheno = pheno4x, step = 1)

  # Build null model
  null.mod = null_model(data, pheno.col = 1, n.clusters = 1)

  # Perform forward search
  search.mod = search_qtl(data = data, model = null.mod,
w.size = 15, sig.fwd = 0.01, n.clusters = 1)

  # Optimize model
  optimize.mod = optimize_qtl(data = data, model = search.mod, sig.bwd = 0.0001, n.clusters = 1)

  # Profile model
  profile.mod = profile_qtl(data = data, model = optimize.mod, d.sint = 1.5, n.clusters = 1)
  

</code></pre>

<hr>
<h2 id='qtl_effects'>QTL allele effect estimation</h2><span id='topic+qtl_effects'></span><span id='topic+plot.qtlpoly.effects'></span>

<h3>Description</h3>

<p>Computes allele specific and allele combination (within-parent) heritable effects from multiple QTL models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qtl_effects(ploidy = 6, fitted, pheno.col = NULL, verbose = TRUE)

## S3 method for class 'qtlpoly.effects'
plot(x, pheno.col = NULL, p1 = "P1", p2 = "P2", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qtl_effects_+3A_ploidy">ploidy</code></td>
<td>
<p>a numeric value of ploidy level of the cross (currently, only 2, 4 or 6).</p>
</td></tr>
<tr><td><code id="qtl_effects_+3A_fitted">fitted</code></td>
<td>
<p>a fitted multiple QTL model of class <code>qtlpoly.fitted</code>.</p>
</td></tr>
<tr><td><code id="qtl_effects_+3A_pheno.col">pheno.col</code></td>
<td>
<p>a numeric vector with the phenotype column numbers to be plotted; if <code>NULL</code>, all phenotypes from <code>'fitted'</code> will be included.</p>
</td></tr>
<tr><td><code id="qtl_effects_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default), current progress is shown; if <code>FALSE</code>, no output is produced.</p>
</td></tr>
<tr><td><code id="qtl_effects_+3A_x">x</code></td>
<td>
<p>an object of class <code>qtlpoly.effects</code> to be plotted.</p>
</td></tr>
<tr><td><code id="qtl_effects_+3A_p1">p1</code></td>
<td>
<p>a character string with the first parent name, e.g. <code>"P1"</code> (default).</p>
</td></tr>
<tr><td><code id="qtl_effects_+3A_p2">p2</code></td>
<td>
<p>a character string with the second parent name, e.g. <code>"P2"</code> (default).</p>
</td></tr>
<tr><td><code id="qtl_effects_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>qtlpoly.effects</code> which is a list of <code>results</code> for each containing the following components:
</p>
<table role = "presentation">
<tr><td><code>pheno.col</code></td>
<td>
<p>a phenotype column number.</p>
</td></tr>
<tr><td><code>y.hat</code></td>
<td>
<p>a vector with the predicted values.</p>
</td></tr>
</table>
<p>A <span class="pkg">ggplot2</span> barplot with parental allele and allele combination effects.
</p>


<h3>Author(s)</h3>

<p>Guilherme da Silva Pereira, <a href="mailto:gdasilv@ncsu.edu">gdasilv@ncsu.edu</a>, with modifications by Gabriel Gesteira, <a href="mailto:gdesiqu@ncsu.edu">gdesiqu@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Pereira GS, Gemenet DC, Mollinari M, Olukolu BA, Wood JC, Mosquera V, Gruneberg WJ, Khan A, Buell CR, Yencho GC, Zeng ZB (2020) Multiple QTL mapping in autopolyploids: a random-effect model approach with application in a hexaploid sweetpotato full-sib population, <em>Genetics</em> 215 (3): 579-595. <a href="https://doi.org/10.1534/genetics.120.303080">doi:10.1534/genetics.120.303080</a>.
</p>
<p>Kempthorne O (1955) The correlation between relatives in a simple autotetraploid population, <em>Genetics</em> 40: 168-174.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_data">read_data</a></code>, <code><a href="#topic+remim">remim</a></code>, <code><a href="#topic+fit_model">fit_model</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  # Estimate conditional probabilities using mappoly package
  library(mappoly)
  library(qtlpoly)
  genoprob4x = lapply(maps4x[c(5)], calc_genoprob)
  data = read_data(ploidy = 4, geno.prob = genoprob4x, pheno = pheno4x, step = 1)

  # Search for QTL
  remim.mod = remim(data = data, pheno.col = 1, w.size = 15, sig.fwd = 0.0011493379,
sig.bwd = 0.0002284465, d.sint = 1.5, n.clusters = 1)

  # Fit model
  fitted.mod = fit_model(data, model=remim.mod, probs="joint", polygenes="none")

  # Estimate effects
  est.effects = qtl_effects(ploidy = 4, fitted = fitted.mod, pheno.col = 1)

  # Plot results
  plot(est.effects)
  
  
</code></pre>

<hr>
<h2 id='read_data'>Read genotypic and phenotypic data</h2><span id='topic+read_data'></span><span id='topic+print.qtlpoly.data'></span>

<h3>Description</h3>

<p>Reads files in specific formats and creates a <code>qtlpoly.data</code> object to be used in subsequent analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_data(
  ploidy = 6,
  geno.prob,
  geno.dose = NULL,
  double.reduction = FALSE,
  pheno,
  weights = NULL,
  step = 1,
  verbose = TRUE
)

## S3 method for class 'qtlpoly.data'
print(x, detailed = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_data_+3A_ploidy">ploidy</code></td>
<td>
<p>a numeric value of ploidy level of the cross.</p>
</td></tr>
<tr><td><code id="read_data_+3A_geno.prob">geno.prob</code></td>
<td>
<p>an object of class <code>mappoly.genoprob</code> from <span class="pkg">mappoly</span>.</p>
</td></tr>
<tr><td><code id="read_data_+3A_geno.dose">geno.dose</code></td>
<td>
<p>an object of class <code>mappoly.data</code> from <span class="pkg">mappoly</span>.</p>
</td></tr>
<tr><td><code id="read_data_+3A_double.reduction">double.reduction</code></td>
<td>
<p>if <code>TRUE</code>, double reduction genotypes are taken into account; if <code>FALSE</code>, no double reduction genotypes are considered.</p>
</td></tr>
<tr><td><code id="read_data_+3A_pheno">pheno</code></td>
<td>
<p>a data frame of phenotypes (columns) with individual names (rows) identical to individual names in <code>geno.prob</code> and/or <code>geno.dose</code> object.</p>
</td></tr>
<tr><td><code id="read_data_+3A_weights">weights</code></td>
<td>
<p>a data frame of phenotype weights (columns) with individual names (rows) identical to individual names in <code>pheno</code> object.</p>
</td></tr>
<tr><td><code id="read_data_+3A_step">step</code></td>
<td>
<p>a numeric value of step size (in centiMorgans) where tests will be performed, e.g. 1 (default); if <code>NULL</code>, tests will be performed at every marker.</p>
</td></tr>
<tr><td><code id="read_data_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default), current progress is shown; if <code>FALSE</code>, no output is produced.</p>
</td></tr>
<tr><td><code id="read_data_+3A_x">x</code></td>
<td>
<p>an object of class <code>qtlpoly.data</code> to be printed.</p>
</td></tr>
<tr><td><code id="read_data_+3A_detailed">detailed</code></td>
<td>
<p>if <code>TRUE</code>, detailed information on linkage groups and phenotypes in shown; if <code>FALSE</code>, no details are printed.</p>
</td></tr>
<tr><td><code id="read_data_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>qtlpoly.data</code> which is a list containing the following components:
</p>
<table role = "presentation">
<tr><td><code>ploidy</code></td>
<td>
<p>a scalar with ploidy level.</p>
</td></tr>
<tr><td><code>nlgs</code></td>
<td>
<p>a scalar with the number of linkage groups.</p>
</td></tr>
<tr><td><code>nind</code></td>
<td>
<p>a scalar with the number of individuals.</p>
</td></tr>
<tr><td><code>nmrk</code></td>
<td>
<p>a scalar with the number of marker positions.</p>
</td></tr>
<tr><td><code>nphe</code></td>
<td>
<p>a scalar with the number of phenotypes.</p>
</td></tr>
<tr><td><code>lgs.size</code></td>
<td>
<p>a vector with linkage group sizes.</p>
</td></tr>
<tr><td><code>cum.size</code></td>
<td>
<p>a vector with cumulative linkage group sizes.</p>
</td></tr>
<tr><td><code>lgs.nmrk</code></td>
<td>
<p>a vector with number of marker positions per linkage group.</p>
</td></tr>
<tr><td><code>cum.nmrk</code></td>
<td>
<p>a vector with cumulative number of marker positions per linkage group.</p>
</td></tr>
<tr><td><code>lgs</code></td>
<td>
<p>a list with selected marker positions per linkage group.</p>
</td></tr>
<tr><td><code>lgs.all</code></td>
<td>
<p>a list with all marker positions per linkage group.</p>
</td></tr>
<tr><td><code>step</code></td>
<td>
<p>a scalar with the step size.</p>
</td></tr>
<tr><td><code>pheno</code></td>
<td>
<p>a data frame with phenotypes.</p>
</td></tr>
<tr><td><code>G</code></td>
<td>
<p>a list of relationship matrices for each marker position.</p>
</td></tr>
<tr><td><code>Z</code></td>
<td>
<p>a list of conditional probability matrices for each marker position for genotypes.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>a list of conditional probability matrices for each marker position for alleles.</p>
</td></tr>
<tr><td><code>Pi</code></td>
<td>
<p>a matrix of identical-by-descent shared alleles among genotypes.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Guilherme da Silva Pereira, <a href="mailto:gdasilv@ncsu.edu">gdasilv@ncsu.edu</a>, with minor updates by Gabriel de Siqueira Gesteira, <a href="mailto:gdesiqu@ncsu.edu">gdesiqu@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Pereira GS, Gemenet DC, Mollinari M, Olukolu BA, Wood JC, Mosquera V, Gruneberg WJ, Khan A, Buell CR, Yencho GC, Zeng ZB (2020) Multiple QTL mapping in autopolyploids: a random-effect model approach with application in a hexaploid sweetpotato full-sib population, <em>Genetics</em> 215 (3): 579-595. <a href="https://doi.org/10.1534/genetics.120.303080">doi:10.1534/genetics.120.303080</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+maps6x">maps6x</a></code>, <code><a href="#topic+pheno6x">pheno6x</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  # Estimate conditional probabilities using mappoly package
  library(mappoly)
  library(qtlpoly)
  genoprob4x = lapply(maps4x[c(5)], calc_genoprob)
  data = read_data(ploidy = 4, geno.prob = genoprob4x, pheno = pheno4x, step = 1)
  
</code></pre>

<hr>
<h2 id='read_data2'>Read genotypic and phenotypic data</h2><span id='topic+read_data2'></span>

<h3>Description</h3>

<p>Reads files in specific formats and creates a <code>qtlpoly.data</code> object to be used in subsequent analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_data2(
  ploidy = 6,
  geno.prob,
  geno.dose = NULL,
  double.reduction = FALSE,
  pheno,
  weights = NULL,
  step = 1,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_data2_+3A_ploidy">ploidy</code></td>
<td>
<p>a numeric value of ploidy level of the cross.</p>
</td></tr>
<tr><td><code id="read_data2_+3A_geno.prob">geno.prob</code></td>
<td>
<p>an object of class <code>mappoly.genoprob</code> from <span class="pkg">mappoly</span>.</p>
</td></tr>
<tr><td><code id="read_data2_+3A_geno.dose">geno.dose</code></td>
<td>
<p>an object of class <code>mappoly.data</code> from <span class="pkg">mappoly</span>.</p>
</td></tr>
<tr><td><code id="read_data2_+3A_double.reduction">double.reduction</code></td>
<td>
<p>if <code>TRUE</code>, double reduction genotypes are taken into account; if <code>FALSE</code>, no double reduction genotypes are considered.</p>
</td></tr>
<tr><td><code id="read_data2_+3A_pheno">pheno</code></td>
<td>
<p>a data frame of phenotypes (columns) with individual names (rows) identical to individual names in <code>geno.prob</code> and/or <code>geno.dose</code> object.</p>
</td></tr>
<tr><td><code id="read_data2_+3A_weights">weights</code></td>
<td>
<p>a data frame of phenotype weights (columns) with individual names (rows) identical to individual names in <code>pheno</code> object.</p>
</td></tr>
<tr><td><code id="read_data2_+3A_step">step</code></td>
<td>
<p>a numeric value of step size (in centiMorgans) where tests will be performed, e.g. 1 (default); if <code>NULL</code>, tests will be performed at every marker.</p>
</td></tr>
<tr><td><code id="read_data2_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default), current progress is shown; if <code>FALSE</code>, no output is produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>qtlpoly.data</code> which is a list containing the following components:
</p>
<table role = "presentation">
<tr><td><code>ploidy</code></td>
<td>
<p>a scalar with ploidy level.</p>
</td></tr>
<tr><td><code>nlgs</code></td>
<td>
<p>a scalar with the number of linkage groups.</p>
</td></tr>
<tr><td><code>nind</code></td>
<td>
<p>a scalar with the number of individuals.</p>
</td></tr>
<tr><td><code>nmrk</code></td>
<td>
<p>a scalar with the number of marker positions.</p>
</td></tr>
<tr><td><code>nphe</code></td>
<td>
<p>a scalar with the number of phenotypes.</p>
</td></tr>
<tr><td><code>lgs.size</code></td>
<td>
<p>a vector with linkage group sizes.</p>
</td></tr>
<tr><td><code>cum.size</code></td>
<td>
<p>a vector with cumulative linkage group sizes.</p>
</td></tr>
<tr><td><code>lgs.nmrk</code></td>
<td>
<p>a vector with number of marker positions per linkage group.</p>
</td></tr>
<tr><td><code>cum.nmrk</code></td>
<td>
<p>a vector with cumulative number of marker positions per linkage group.</p>
</td></tr>
<tr><td><code>lgs</code></td>
<td>
<p>a list with selected marker positions per linkage group.</p>
</td></tr>
<tr><td><code>lgs.all</code></td>
<td>
<p>a list with all marker positions per linkage group.</p>
</td></tr>
<tr><td><code>step</code></td>
<td>
<p>a scalar with the step size.</p>
</td></tr>
<tr><td><code>pheno</code></td>
<td>
<p>a data frame with phenotypes.</p>
</td></tr>
<tr><td><code>G</code></td>
<td>
<p>a list of relationship matrices for each marker position.</p>
</td></tr>
<tr><td><code>Z</code></td>
<td>
<p>a list of conditional probability matrices for each marker position for genotypes.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>a list of conditional probability matrices for each marker position for alleles.</p>
</td></tr>
<tr><td><code>Pi</code></td>
<td>
<p>a matrix of identical-by-descent shared alleles among genotypes.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Guilherme da Silva Pereira, <a href="mailto:gdasilv@ncsu.edu">gdasilv@ncsu.edu</a>, Gabriel de Siqueira Gesteira, <a href="mailto:gdesiqu@ncsu.edu">gdesiqu@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Pereira GS, Gemenet DC, Mollinari M, Olukolu BA, Wood JC, Mosquera V, Gruneberg WJ, Khan A, Buell CR, Yencho GC, Zeng ZB (2020) Multiple QTL mapping in autopolyploids: a random-effect model approach with application in a hexaploid sweetpotato full-sib population, <em>Genetics</em> 215 (3): 579-595. <a href="https://doi.org/10.1534/genetics.120.303080">doi:10.1534/genetics.120.303080</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+maps6x">maps6x</a></code>, <code><a href="#topic+pheno6x">pheno6x</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  # Estimate conditional probabilities using mappoly package
  library(mappoly)
  library(qtlpoly)
  genoprob4x = lapply(maps4x[c(5)], calc_genoprob)
  data = read_data(ploidy = 4, geno.prob = genoprob4x, pheno = pheno4x, step = 1)
  
</code></pre>

<hr>
<h2 id='remim'>Random-effect multiple interval mapping (REMIM)</h2><span id='topic+remim'></span><span id='topic+print.qtlpoly.remim'></span>

<h3>Description</h3>

<p>Automatic function that performs REMIM algorithm using score statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remim(
  data,
  pheno.col = NULL,
  w.size = 15,
  sig.fwd = 0.01,
  sig.bwd = 1e-04,
  score.null = NULL,
  d.sint = 1.5,
  polygenes = FALSE,
  n.clusters = NULL,
  n.rounds = Inf,
  plot = NULL,
  verbose = TRUE
)

## S3 method for class 'qtlpoly.remim'
print(x, pheno.col = NULL, sint = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remim_+3A_data">data</code></td>
<td>
<p>an object of class <code>qtlpoly.data</code>.</p>
</td></tr>
<tr><td><code id="remim_+3A_pheno.col">pheno.col</code></td>
<td>
<p>a numeric vector with the phenotype columns to be analyzed or printed; if <code>NULL</code> (default), all phenotypes from <code>'data'</code> will be included.</p>
</td></tr>
<tr><td><code id="remim_+3A_w.size">w.size</code></td>
<td>
<p>the window size (in centiMorgans) to avoid on either side of QTL already in the model when looking for a new QTL, e.g. 15 (default).</p>
</td></tr>
<tr><td><code id="remim_+3A_sig.fwd">sig.fwd</code></td>
<td>
<p>the desired score-based significance level for forward search, e.g. 0.01 (default).</p>
</td></tr>
<tr><td><code id="remim_+3A_sig.bwd">sig.bwd</code></td>
<td>
<p>the desired score-based significance level for backward elimination, e.g. 0.001 (default).</p>
</td></tr>
<tr><td><code id="remim_+3A_score.null">score.null</code></td>
<td>
<p>an object of class <code>qtlpoly.null</code> with results of score statistics from resampling.</p>
</td></tr>
<tr><td><code id="remim_+3A_d.sint">d.sint</code></td>
<td>
<p>a <code class="reqn">d</code> value to subtract from logarithm of <em>p</em>-value (<code class="reqn">LOP-d</code>) for support interval calculation, e.g. <code class="reqn">d=1.5</code> (default) represents approximate 95% support interval.</p>
</td></tr>
<tr><td><code id="remim_+3A_polygenes">polygenes</code></td>
<td>
<p>if <code>TRUE</code> all QTL already in the model are treated as a single polygenic effect; if <code>FALSE</code> (default) all QTL effect variances have to estimated.</p>
</td></tr>
<tr><td><code id="remim_+3A_n.clusters">n.clusters</code></td>
<td>
<p>number of parallel processes to spawn.</p>
</td></tr>
<tr><td><code id="remim_+3A_n.rounds">n.rounds</code></td>
<td>
<p>number of search rounds; if <code>Inf</code> (default) forward search will stop when no more significant positions can be found.</p>
</td></tr>
<tr><td><code id="remim_+3A_plot">plot</code></td>
<td>
<p>a suffix for the file's name containing plots of every algorithm step, e.g. &quot;remim&quot;; if <code>NULL</code> (default), no file is produced.</p>
</td></tr>
<tr><td><code id="remim_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default), current progress is shown; if <code>FALSE</code>, no output is produced.</p>
</td></tr>
<tr><td><code id="remim_+3A_x">x</code></td>
<td>
<p>an object of class <code>qtlpoly.remim</code> to be printed.</p>
</td></tr>
<tr><td><code id="remim_+3A_sint">sint</code></td>
<td>
<p>whether <code>"upper"</code> or <code>"lower"</code> support intervals should be printed; if <code>NULL</code> (default), only QTL peak information will be printed.</p>
</td></tr>
<tr><td><code id="remim_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>qtlpoly.remim</code> which contains a list of <code>results</code> for each trait with the following components:
</p>
<table role = "presentation">
<tr><td><code>pheno.col</code></td>
<td>
<p>a phenotype column number.</p>
</td></tr>
<tr><td><code>stat</code></td>
<td>
<p>a vector containing values from score statistics.</p>
</td></tr>
<tr><td><code>pval</code></td>
<td>
<p>a vector containing <em>p</em>-values from score statistics.</p>
</td></tr>
<tr><td><code>qtls</code></td>
<td>
<p>a data frame with information from the mapped QTL.</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>a data frame with information from the lower support interval of mapped QTL.</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p>a data frame with information from the upper support interval of mapped QTL.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Guilherme da Silva Pereira, <a href="mailto:gdasilv@ncsu.edu">gdasilv@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Kao CH, Zeng ZB, Teasdale RD (1999) Multiple interval mapping for quantitative trait loci. <em>Genetics</em> 152 (3): 1203–16. 
</p>
<p>Pereira GS, Gemenet DC, Mollinari M, Olukolu BA, Wood JC, Mosquera V, Gruneberg WJ, Khan A, Buell CR, Yencho GC, Zeng ZB (2020) Multiple QTL mapping in autopolyploids: a random-effect model approach with application in a hexaploid sweetpotato full-sib population, <em>Genetics</em> 215 (3): 579-595. <a href="https://doi.org/10.1534/genetics.120.303080">doi:10.1534/genetics.120.303080</a>.
</p>
<p>Qu L, Guennel T, Marshall SL (2013) Linear score tests for variance components in linear mixed models and applications to genetic association studies. <em>Biometrics</em> 69 (4): 883–92.
</p>
<p>Zou F, Fine JP, Hu J, Lin DY (2004) An efficient resampling method for assessing genome-wide statistical significance in mapping quantitative trait loci. <em>Genetics</em> 168 (4): 2307-16. <a href="https://doi.org/10.1534/genetics.104.031427">doi:10.1534/genetics.104.031427</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_data">read_data</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  # Estimate conditional probabilities using mappoly package
  library(mappoly)
  library(qtlpoly)
  genoprob4x = lapply(maps4x[c(5)], calc_genoprob)
  data = read_data(ploidy = 4, geno.prob = genoprob4x, pheno = pheno4x, step = 1)

  # Search for QTL
  remim.mod = remim(data = data, pheno.col = 1, w.size = 15, sig.fwd = 0.0011493379,
sig.bwd = 0.0002284465, d.sint = 1.5, n.clusters = 1)
  

</code></pre>

<hr>
<h2 id='remim2'>Random-effect multiple interval mapping (REMIM)</h2><span id='topic+remim2'></span>

<h3>Description</h3>

<p>Automatic function that performs REMIM algorithm using score statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remim2(
  data,
  pheno.col = NULL,
  w.size = 15,
  sig.fwd = 0.01,
  sig.bwd = 1e-04,
  score.null = NULL,
  d.sint = 1.5,
  polygenes = FALSE,
  n.clusters = NULL,
  n.rounds = Inf,
  plot = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remim2_+3A_data">data</code></td>
<td>
<p>an object of class <code>qtlpoly.data</code>.</p>
</td></tr>
<tr><td><code id="remim2_+3A_pheno.col">pheno.col</code></td>
<td>
<p>a numeric vector with the phenotype columns to be analyzed or printed; if <code>NULL</code> (default), all phenotypes from <code>'data'</code> will be included.</p>
</td></tr>
<tr><td><code id="remim2_+3A_w.size">w.size</code></td>
<td>
<p>the window size (in centiMorgans) to avoid on either side of QTL already in the model when looking for a new QTL, e.g. 15 (default).</p>
</td></tr>
<tr><td><code id="remim2_+3A_sig.fwd">sig.fwd</code></td>
<td>
<p>the desired score-based significance level for forward search, e.g. 0.01 (default).</p>
</td></tr>
<tr><td><code id="remim2_+3A_sig.bwd">sig.bwd</code></td>
<td>
<p>the desired score-based significance level for backward elimination, e.g. 0.001 (default).</p>
</td></tr>
<tr><td><code id="remim2_+3A_score.null">score.null</code></td>
<td>
<p>an object of class <code>qtlpoly.null</code> with results of score statistics from resampling.</p>
</td></tr>
<tr><td><code id="remim2_+3A_d.sint">d.sint</code></td>
<td>
<p>a <code class="reqn">d</code> value to subtract from logarithm of <em>p</em>-value (<code class="reqn">LOP-d</code>) for support interval calculation, e.g. <code class="reqn">d=1.5</code> (default) represents approximate 95% support interval.</p>
</td></tr>
<tr><td><code id="remim2_+3A_polygenes">polygenes</code></td>
<td>
<p>if <code>TRUE</code> all QTL already in the model are treated as a single polygenic effect; if <code>FALSE</code> (default) all QTL effect variances have to estimated.</p>
</td></tr>
<tr><td><code id="remim2_+3A_n.clusters">n.clusters</code></td>
<td>
<p>number of parallel processes to spawn.</p>
</td></tr>
<tr><td><code id="remim2_+3A_n.rounds">n.rounds</code></td>
<td>
<p>number of search rounds; if <code>Inf</code> (default) forward search will stop when no more significant positions can be found.</p>
</td></tr>
<tr><td><code id="remim2_+3A_plot">plot</code></td>
<td>
<p>a suffix for the file's name containing plots of every algorithm step, e.g. &quot;remim&quot;; if <code>NULL</code> (default), no file is produced.</p>
</td></tr>
<tr><td><code id="remim2_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default), current progress is shown; if <code>FALSE</code>, no output is produced.</p>
</td></tr>
<tr><td><code id="remim2_+3A_sint">sint</code></td>
<td>
<p>whether <code>"upper"</code> or <code>"lower"</code> support intervals should be printed; if <code>NULL</code> (default), only QTL peak information will be printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>qtlpoly.remim</code> which contains a list of <code>results</code> for each trait with the following components:
</p>
<table role = "presentation">
<tr><td><code>pheno.col</code></td>
<td>
<p>a phenotype column number.</p>
</td></tr>
<tr><td><code>stat</code></td>
<td>
<p>a vector containing values from score statistics.</p>
</td></tr>
<tr><td><code>pval</code></td>
<td>
<p>a vector containing <em>p</em>-values from score statistics.</p>
</td></tr>
<tr><td><code>qtls</code></td>
<td>
<p>a data frame with information from the mapped QTL.</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>a data frame with information from the lower support interval of mapped QTL.</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p>a data frame with information from the upper support interval of mapped QTL.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Guilherme da Silva Pereira, <a href="mailto:gdasilv@ncsu.edu">gdasilv@ncsu.edu</a>, Getúlio Caixeta Ferreira, <a href="mailto:getulio.caifer@gmail.com">getulio.caifer@gmail.com</a>
</p>


<h3>References</h3>

<p>Kao CH, Zeng ZB, Teasdale RD (1999) Multiple interval mapping for quantitative trait loci. <em>Genetics</em> 152 (3): 1203–16. 
</p>
<p>Pereira GS, Gemenet DC, Mollinari M, Olukolu BA, Wood JC, Mosquera V, Gruneberg WJ, Khan A, Buell CR, Yencho GC, Zeng ZB (2020) Multiple QTL mapping in autopolyploids: a random-effect model approach with application in a hexaploid sweetpotato full-sib population, <em>Genetics</em> 215 (3): 579-595. <a href="https://doi.org/10.1534/genetics.120.303080">doi:10.1534/genetics.120.303080</a>.
</p>
<p>Qu L, Guennel T, Marshall SL (2013) Linear score tests for variance components in linear mixed models and applications to genetic association studies. <em>Biometrics</em> 69 (4): 883–92.
</p>
<p>Zou F, Fine JP, Hu J, Lin DY (2004) An efficient resampling method for assessing genome-wide statistical significance in mapping quantitative trait loci. <em>Genetics</em> 168 (4): 2307-16. <a href="https://doi.org/10.1534/genetics.104.031427">doi:10.1534/genetics.104.031427</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_data">read_data</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  # Estimate conditional probabilities using mappoly package
  library(mappoly)
  library(qtlpoly)
  genoprob4x = lapply(maps4x[c(5)], calc_genoprob)
  data = read_data(ploidy = 4, geno.prob = genoprob4x, pheno = pheno4x, step = 1)

  # Search for QTL
  remim.mod = remim2(data = data, pheno.col = 1, w.size = 15, sig.fwd = 0.0011493379,
sig.bwd = 0.0002284465, d.sint = 1.5, n.clusters = 1)
  

</code></pre>

<hr>
<h2 id='search_qtl'>QTL forward search</h2><span id='topic+search_qtl'></span><span id='topic+print.qtlpoly.search'></span>

<h3>Description</h3>

<p>Searches for QTL and adds them one at a time to a multiple random-effect QTL model based on score statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_qtl(
  data,
  offset.data = NULL,
  model,
  w.size = 15,
  sig.fwd = 0.2,
  score.null = NULL,
  polygenes = FALSE,
  n.rounds = Inf,
  n.clusters = NULL,
  plot = NULL,
  verbose = TRUE
)

## S3 method for class 'qtlpoly.search'
print(x, pheno.col = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="search_qtl_+3A_data">data</code></td>
<td>
<p>an object of class <code>qtlpoly.data</code>.</p>
</td></tr>
<tr><td><code id="search_qtl_+3A_offset.data">offset.data</code></td>
<td>
<p>a data frame with the same dimensions of <code>data$pheno</code> containing offset variables; if <code>NULL</code> (default), no offset variables are considered.</p>
</td></tr>
<tr><td><code id="search_qtl_+3A_model">model</code></td>
<td>
<p>an object of class <code>qtlpoly.model</code> from which a forward search will start.</p>
</td></tr>
<tr><td><code id="search_qtl_+3A_w.size">w.size</code></td>
<td>
<p>the window size (in cM) to avoid on either side of QTL already in the model when looking for a new QTL.</p>
</td></tr>
<tr><td><code id="search_qtl_+3A_sig.fwd">sig.fwd</code></td>
<td>
<p>the desired score-based <em>p</em>-value threshold for forward search, e.g. 0.01 (default).</p>
</td></tr>
<tr><td><code id="search_qtl_+3A_score.null">score.null</code></td>
<td>
<p>an object of class <code>qtlpoly.null</code> with results of score statistics from resampling.</p>
</td></tr>
<tr><td><code id="search_qtl_+3A_polygenes">polygenes</code></td>
<td>
<p>if <code>TRUE</code> all QTL but the one being tested are treated as a single polygenic effect; if <code>FALSE</code> (default) all QTL effect variances have to estimated.</p>
</td></tr>
<tr><td><code id="search_qtl_+3A_n.rounds">n.rounds</code></td>
<td>
<p>number of search rounds; if <code>Inf</code> (default) forward search will stop when no more significant positions can be found.</p>
</td></tr>
<tr><td><code id="search_qtl_+3A_n.clusters">n.clusters</code></td>
<td>
<p>number of parallel processes to spawn.</p>
</td></tr>
<tr><td><code id="search_qtl_+3A_plot">plot</code></td>
<td>
<p>a suffix for the file's name containing plots of every QTL search round, e.g. &quot;search&quot; (default); if <code>NULL</code>, no file is produced.</p>
</td></tr>
<tr><td><code id="search_qtl_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default), current progress is shown; if <code>FALSE</code>, no output is produced.</p>
</td></tr>
<tr><td><code id="search_qtl_+3A_x">x</code></td>
<td>
<p>an object of class <code>qtlpoly.search</code> to be printed.</p>
</td></tr>
<tr><td><code id="search_qtl_+3A_pheno.col">pheno.col</code></td>
<td>
<p>a numeric vector with the phenotype column numbers to be printed; if <code>NULL</code>, all phenotypes from <code>'data'</code> will be included.</p>
</td></tr>
<tr><td><code id="search_qtl_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>qtlpoly.search</code> which contains a list of <code>results</code> for each trait with the following components:
</p>
<table role = "presentation">
<tr><td><code>pheno.col</code></td>
<td>
<p>a phenotype column number.</p>
</td></tr>
<tr><td><code>stat</code></td>
<td>
<p>a vector containing values from score statistics.</p>
</td></tr>
<tr><td><code>pval</code></td>
<td>
<p>a vector containing <em>p</em>-values from score statistics.</p>
</td></tr>
<tr><td><code>qtls</code></td>
<td>
<p>a data frame with information from the mapped QTL.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Guilherme da Silva Pereira, <a href="mailto:gdasilv@ncsu.edu">gdasilv@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Pereira GS, Gemenet DC, Mollinari M, Olukolu BA, Wood JC, Mosquera V, Gruneberg WJ, Khan A, Buell CR, Yencho GC, Zeng ZB (2020) Multiple QTL mapping in autopolyploids: a random-effect model approach with application in a hexaploid sweetpotato full-sib population, <em>Genetics</em> 215 (3): 579-595. <a href="https://doi.org/10.1534/genetics.120.303080">doi:10.1534/genetics.120.303080</a>.
</p>
<p>Qu L, Guennel T, Marshall SL (2013) Linear score tests for variance components in linear mixed models and applications to genetic association studies. <em>Biometrics</em> 69 (4): 883–92.
</p>
<p>Zou F, Fine JP, Hu J, Lin DY (2004) An efficient resampling method for assessing genome-wide statistical significance in mapping quantitative trait loci. <em>Genetics</em> 168 (4): 2307-16. <a href="https://doi.org/10.1534/genetics.104.031427">doi:10.1534/genetics.104.031427</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_data">read_data</a></code>, <code><a href="#topic+null_model">null_model</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  # Estimate conditional probabilities using mappoly package
  library(mappoly)
  library(qtlpoly)
  genoprob4x = lapply(maps4x[c(5)], calc_genoprob)
  data = read_data(ploidy = 4, geno.prob = genoprob4x, pheno = pheno4x, step = 1)

  # Build null model
  null.mod = null_model(data, pheno.col = 1, n.clusters = 1)

  # Perform forward search
  search.mod = search_qtl(data, model = null.mod, w.size = 15, sig.fwd = 0.01, n.clusters = 1)
  

</code></pre>

<hr>
<h2 id='simulate_qtl'>Simulations of multiple QTL</h2><span id='topic+simulate_qtl'></span><span id='topic+print.qtlpoly.simul'></span>

<h3>Description</h3>

<p>Simulate new phenotypes with a given number of QTL and creates new object with the same structure of class <code>qtlpoly.data</code> from an existing genetic map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_qtl(
  data,
  mu = 0,
  h2.qtl = c(0.3, 0.2, 0.1),
  var.error = 1,
  linked = FALSE,
  n.sim = 1000,
  missing = TRUE,
  w.size = 20,
  seed = 123,
  verbose = TRUE
)

## S3 method for class 'qtlpoly.simul'
print(x, detailed = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_qtl_+3A_data">data</code></td>
<td>
<p>an object of class <code>qtlpoly.data</code>.</p>
</td></tr>
<tr><td><code id="simulate_qtl_+3A_mu">mu</code></td>
<td>
<p>simulated phenotype mean, e.g. 0 (default).</p>
</td></tr>
<tr><td><code id="simulate_qtl_+3A_h2.qtl">h2.qtl</code></td>
<td>
<p>vector with QTL heritabilities, e.g. <code>c(0.3, 0.2, 0.1)</code> for three QTL (default); if <code>NULL</code>, only error is simulated.</p>
</td></tr>
<tr><td><code id="simulate_qtl_+3A_var.error">var.error</code></td>
<td>
<p>simulated error variance, e.g. 1 (default).</p>
</td></tr>
<tr><td><code id="simulate_qtl_+3A_linked">linked</code></td>
<td>
<p>if <code>TRUE</code> (default), at least two QTL will be linked; if <code>FALSE</code>, QTL will be randomly assigned along the genetic map. Linkage is defined by a genetic distance smaller than the selected <code>w.size</code>.</p>
</td></tr>
<tr><td><code id="simulate_qtl_+3A_n.sim">n.sim</code></td>
<td>
<p>number of simulations, e.g. 1000 (default).</p>
</td></tr>
<tr><td><code id="simulate_qtl_+3A_missing">missing</code></td>
<td>
<p>if <code>TRUE</code> (default), phenotypes are simulated with the same number of missing data observed in <code>data$pheno</code>.</p>
</td></tr>
<tr><td><code id="simulate_qtl_+3A_w.size">w.size</code></td>
<td>
<p>the window size (in centiMorgans) between two (linked) QTL, e.g. 20 (default).</p>
</td></tr>
<tr><td><code id="simulate_qtl_+3A_seed">seed</code></td>
<td>
<p>integer for the <code>set.seed()</code> function.</p>
</td></tr>
<tr><td><code id="simulate_qtl_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default), current progress is shown; if <code>FALSE</code>, no output is produced.</p>
</td></tr>
<tr><td><code id="simulate_qtl_+3A_x">x</code></td>
<td>
<p>an object of class <code>qtlpoly.sim</code> to be printed.</p>
</td></tr>
<tr><td><code id="simulate_qtl_+3A_detailed">detailed</code></td>
<td>
<p>if <code>TRUE</code>, detailed information on linkage groups and phenotypes in shown; if <code>FALSE</code>, no details are printed.</p>
</td></tr>
<tr><td><code id="simulate_qtl_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>qtlpoly.sim</code> which contains a list of <code>results</code> with the same structure of class <code>qtlpoly.data</code>.
</p>


<h3>Author(s)</h3>

<p>Guilherme da Silva Pereira, <a href="mailto:gdasilv@ncsu.edu">gdasilv@ncsu.edu</a>
</p>


<h3>References</h3>

<p>Pereira GS, Gemenet DC, Mollinari M, Olukolu BA, Wood JC, Mosquera V, Gruneberg WJ, Khan A, Buell CR, Yencho GC, Zeng ZB (2020) Multiple QTL mapping in autopolyploids: a random-effect model approach with application in a hexaploid sweetpotato full-sib population, <em>Genetics</em> 215 (3): 579-595. <a href="https://doi.org/10.1534/genetics.120.303080">doi:10.1534/genetics.120.303080</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_data">read_data</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  # Estimate conditional probabilities using mappoly package
  library(mappoly)
  library(qtlpoly)
  genoprob4x = lapply(maps4x[c(5)], calc_genoprob)
  data = read_data(ploidy = 4, geno.prob = genoprob4x, pheno = pheno4x, step = 1)

  # Simulate new phenotypes
  sim.dat = simulate_qtl(data = data, n.sim = 1)
  sim.dat
  

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
