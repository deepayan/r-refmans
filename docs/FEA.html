<!DOCTYPE html><html><head><title>Help for package FEA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {FEA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ApplyBC.2d'><p>ApplyBC.2d</p></a></li>
<li><a href='#AutoAdjust.2d'><p>AutoAdjust.2d</p></a></li>
<li><a href='#beamApplyBC'><p>beamApplyBC</p></a></li>
<li><a href='#beamBC'><p>Boundary conditions applied to each node. Obtained from function: beamApplyBC</p></a></li>
<li><a href='#beamDime'><p>Dimensional data for beam elements. Includes area, length, aspect ratio, angles and lengths of elements. Obtained from function: beamDimensions</p></a></li>
<li><a href='#beamDimensions'><p>beamDimensions</p></a></li>
<li><a href='#beamElementMat'><p>beamElementMat</p></a></li>
<li><a href='#beamEmat'><p>List of element matrices for each element. Obtained from function: beamElementMat</p></a></li>
<li><a href='#beamExMat'><p>List of element matrices for each element. Obtained from function: beamElementMat</p></a></li>
<li><a href='#beamExpandEM'><p>beamExpandEM</p></a></li>
<li><a href='#beamForceVector'><p>beamForceVector</p></a></li>
<li><a href='#beamFV'><p>Load vector produced from function function: beamForceVector</p></a></li>
<li><a href='#beamGeo'><p>Sample geometry for beam. Includes shape, discretization table, boundary conditions, thickness, and material details.</p></a></li>
<li><a href='#beamGLforce'><p>Global and Local loading force matrices obtained from function: beamGLForces</p></a></li>
<li><a href='#beamGLForces'><p>beamGLForces</p></a></li>
<li><a href='#beamGlobalEM'><p>beamGlobalEM</p></a></li>
<li><a href='#beamGloMat'><p>Global element matrix, obtained from function: beamGlobalEM</p></a></li>
<li><a href='#beamND'><p>Global nodal displacement, obtained from function: beamNodeDis</p></a></li>
<li><a href='#beamNodeDis'><p>beamNodeDis</p></a></li>
<li><a href='#beamPlotSystem'><p>beamPlotSystem</p></a></li>
<li><a href='#beamReducedEM'><p>beamReducedEM</p></a></li>
<li><a href='#beamREM'><p>Reduced element matrix calculated from the expanded element matrix. Obtained from function: beamReducedEM</p></a></li>
<li><a href='#beamStress'><p>beamStress</p></a></li>
<li><a href='#beamStressResult'><p>FEA results for the beam model. Obtained from function: beamStress</p></a></li>
<li><a href='#beamsUDL'><p>Uniformly distributed load on beam surface</p></a></li>
<li><a href='#beamUDL'><p>beamUDL</p></a></li>
<li><a href='#bound'><p>Boundary conditions applied to each node. Obtained from function: ApplyBC</p></a></li>
<li><a href='#Cart'><p>Sample geometry. Matrix with x and y coordinates for initial shape.</p></a></li>
<li><a href='#cleanpoly'><p>Cleaned nodal distribution in and on polygon. Obtained from function: Threshpts</p></a></li>
<li><a href='#dime'><p>Dimensional data for mesh elements. Includes area, length, aspect ratio, angles and lengths of elements. Obtained from function: Dimensions</p></a></li>
<li><a href='#Dimensions.2d'><p>Dimensions.2d</p></a></li>
<li><a href='#displacN'><p>Global nodal displacement, obtained from function: NodeDis</p></a></li>
<li><a href='#ElementMat.2d'><p>ElementMat.2d</p></a></li>
<li><a href='#EulerBeamFEA'><p>EulerBeamFEA</p></a></li>
<li><a href='#ExpandEM.2d'><p>ExpandEM.2d</p></a></li>
<li><a href='#ExpandSFT.2d'><p>ExpandSFT.2d</p></a></li>
<li><a href='#expSurf'><p>Expanded element matrix for surface forces. Obtained from function: ExpandSFT</p></a></li>
<li><a href='#fea_EM'><p>List of element matrices for each element. Obtained from function: ElementMat</p></a></li>
<li><a href='#fea_ExEM'><p>List of large expanded element matrices calculated from the element matrix. Obtained from function: ExpandEM</p></a></li>
<li><a href='#fea_result'><p>FEA results. Produces list with results from local stresses including Stress, Strain, and Stress from Strain. Obtained from function: LocalStress</p></a></li>
<li><a href='#FEMStrain.2d'><p>FEMStrain.2d</p></a></li>
<li><a href='#FEMStress.2d'><p>FEMStress.2d</p></a></li>
<li><a href='#ForceVector.2d'><p>ForceVector.2d</p></a></li>
<li><a href='#glfor'><p>Global and Local loading force matrices obtained from function: GLForces</p></a></li>
<li><a href='#GLForces.2d'><p>GLForces.2d</p></a></li>
<li><a href='#GlobalMat.2d'><p>GlobalMat.2d</p></a></li>
<li><a href='#gloMat'><p>Global element matrix, obtained from function: GlobalMat</p></a></li>
<li><a href='#load'><p>Load vector produced from function function: ForceVector</p></a></li>
<li><a href='#LocalStress.2d'><p>LocalStress.2d</p></a></li>
<li><a href='#ManualAdjust.2d'><p>ManualAdjust.2d</p></a></li>
<li><a href='#NodeDis.2d'><p>NodeDis.2d</p></a></li>
<li><a href='#PlotSystem.2d'><p>PlotSystem.2d</p></a></li>
<li><a href='#polyshape'><p>Sample geometry converted into a 2D polygon. Polygon data that specifies all coordinate, coordinates that are within the geometry and coordinates that construct the lines of the geometry. Obtained from function: SinglePoly</p></a></li>
<li><a href='#reduc_EM'><p>Reduced element matrix calculated from the expanded element matrix. Obtained from function: ReducedEM</p></a></li>
<li><a href='#reduc_SF'><p>Reduced surface force matrix calculated from expanded element matrix. Obtained from function: ReducedSF</p></a></li>
<li><a href='#ReducedEM.2d'><p>ReducedEM.2d</p></a></li>
<li><a href='#ReducedSF.2d'><p>ReducedSF.2d</p></a></li>
<li><a href='#SinglePoly.2d'><p>SinglePoly.2d</p></a></li>
<li><a href='#SurfaceTraction.2d'><p>SurfaceTraction.2d</p></a></li>
<li><a href='#SurfTrac'><p>List of element matrices with surface traction. Obtained from function: SurfaceTraction</p></a></li>
<li><a href='#ThreshPts.2d'><p>ThreshPts.2d</p></a></li>
<li><a href='#triangulate0.2d'><p>triangulate0.2d</p></a></li>
<li><a href='#triMesh'><p>Meshed coordinate points obtained from function: triangulate0</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Finite Element Modeling for R</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.2</td>
</tr>
<tr>
<td>Author:</td>
<td>Henna D. Bhramdat</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Henna D. Bhramdat &lt;bhramdath@ufl.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Finite element modeling of beam structures and 2D geometries using constant strain triangles. Applies material properties and boundary conditions (load and constraint) to generate a finite element model. The model produces stress, strain, and nodal displacements; a heat map is available to demonstrate regions where output variables are high or low.  Also provides options for creating a triangular mesh of 2D geometries. Package developed with reference to: Bathe, K. J. (1996). Finite Element Procedures.[ISBN 978-0-9790049-5-7] &ndash; Seshu, P. (2012). Textbook of Finite Element Analysis. [ISBN-978-81-203-2315-5] &ndash; Mustapha, K. B. (2018). Finite Element Computations in Mechanics with R. [ISBN 9781315144474].</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>geometry, geosphere, ptinpoly, sp, MASS, graphics</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-10 22:19:46 UTC; Henna</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-10 22:33:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='ApplyBC.2d'>ApplyBC.2d</h2><span id='topic+ApplyBC.2d'></span>

<h3>Description</h3>

<p>Boundary constraint for element centroids based on coordinate points. For the x &amp; y direction per centroid create matrix with boundary 1(unfixed) or 0(fixed).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ApplyBC.2d(meshP, BoundConx, BoundCony)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ApplyBC.2d_+3A_meshp">meshP</code></td>
<td>
<p>Matrix (2 x n) containing coordinate points of the mesh</p>
</td></tr>
<tr><td><code id="ApplyBC.2d_+3A_boundconx">BoundConx</code></td>
<td>
<p>Boundary constraint for nodes in the x-direction</p>
</td></tr>
<tr><td><code id="ApplyBC.2d_+3A_boundcony">BoundCony</code></td>
<td>
<p>Boundary constraint for nodes in the y-direction</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with constraint parameters applied to each node in the x and y directions. Formatted for use in reduced element matrix.
</p>
<table>
<tr><td><code>NodeKnownL</code></td>
<td>
<p>Constraint parameters</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(triMesh)

meshP = triMesh$MeshPts$p
BoundConx = BoundCony = numeric(NROW(meshP))
BoundConx[1:NROW(meshP)] = BoundCony[1:NROW(meshP)] = 1
BoundConx[c(10, 11, 12)] = BoundCony[c(10, 11, 12)] = 0

bound = ApplyBC.2d(meshP, BoundConx, BoundCony)

</code></pre>

<hr>
<h2 id='AutoAdjust.2d'>AutoAdjust.2d</h2><span id='topic+AutoAdjust.2d'></span>

<h3>Description</h3>

<p>Allows for automatic refinement of the triangular mesh generated based on given parameters. Will remove elements that are outside the margin of the geometry.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AutoAdjust.2d(meshP, meshT, edge, centroid, AspectR, AR)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AutoAdjust.2d_+3A_meshp">meshP</code></td>
<td>
<p>Matrix (2 x n) containing coordinate points of the mesh nodes.</p>
</td></tr>
<tr><td><code id="AutoAdjust.2d_+3A_mesht">meshT</code></td>
<td>
<p>Matrix (3 x n) containing the number of the coordinate point that forms a given triangle within the mesh.</p>
</td></tr>
<tr><td><code id="AutoAdjust.2d_+3A_edge">edge</code></td>
<td>
<p>Coordinate points of the initial geometry.</p>
</td></tr>
<tr><td><code id="AutoAdjust.2d_+3A_centroid">centroid</code></td>
<td>
<p>Matrix (2 x n) of triangle elements.</p>
</td></tr>
<tr><td><code id="AutoAdjust.2d_+3A_aspectr">AspectR</code></td>
<td>
<p>Aspect ratio of each triangle element.</p>
</td></tr>
<tr><td><code id="AutoAdjust.2d_+3A_ar">AR</code></td>
<td>
<p>maximum desired aspect ratio, numeric value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Generates new mesh and centroid tables
</p>
<table>
<tr><td><code>Meshpts</code></td>
<td>
<p>Includes both new mesh coordinate points and triangulation of points.</p>
</td></tr>
<tr><td><code>Centroids</code></td>
<td>
<p>Centroid positions for each triangle element.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(triMesh)
data(polyshape)
data(dime)

meshP = triMesh$MeshPts$p
meshT = triMesh$MeshPts$T
edge =  polyshape$Line
centroid = triMesh$Centroids
AspectR = dime$AspectRatio
AR = 10

auto = AutoAdjust.2d(meshP, meshT, edge, centroid, AspectR, AR)

</code></pre>

<hr>
<h2 id='beamApplyBC'>beamApplyBC</h2><span id='topic+beamApplyBC'></span>

<h3>Description</h3>

<p>Boundary constraint for element centroids based on coordinate points. For the x &amp; y direction per centroid create matrix with boundary 1(unfixed) or 0(fixed).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beamApplyBC(beamP, BCtran, BCrot)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beamApplyBC_+3A_beamp">beamP</code></td>
<td>
<p>Matrix (2 x n) of beam coordinates.</p>
</td></tr>
<tr><td><code id="beamApplyBC_+3A_bctran">BCtran</code></td>
<td>
<p>Boundary constraint for nodes to translate in x or y directions. Input as a non-matrix column.</p>
</td></tr>
<tr><td><code id="beamApplyBC_+3A_bcrot">BCrot</code></td>
<td>
<p>Boundary constraint for nodes to rotate. Input as a non-matrix column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with constraint parameters applied to each node for directional translation and rotation. Formatted for use in reduced element matrix.
</p>
<table>
<tr><td><code>NodeKnownL</code></td>
<td>
<p>Matrix (1 x n) of constraint parameters</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(beamGeo)

beamBC = beamApplyBC(beamGeo$beamP, beamGeo$BCtran, beamGeo$BCrot)

</code></pre>

<hr>
<h2 id='beamBC'>Boundary conditions applied to each node. Obtained from function: beamApplyBC</h2><span id='topic+beamBC'></span>

<h3>Description</h3>

<p>Boundary conditions applied to each node. Obtained from function: beamApplyBC
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beamBC
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 8 rows and 1 columns.
</p>

<hr>
<h2 id='beamDime'>Dimensional data for beam elements. Includes area, length, aspect ratio, angles and lengths of elements. Obtained from function: beamDimensions</h2><span id='topic+beamDime'></span>

<h3>Description</h3>

<p>Dimensional data for beam elements. Includes area, length, aspect ratio, angles and lengths of elements. Obtained from function: beamDimensions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beamDime
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 7.
</p>

<hr>
<h2 id='beamDimensions'>beamDimensions</h2><span id='topic+beamDimensions'></span>

<h3>Description</h3>

<p>Calculates input dimensions needed for beam finite element.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beamDimensions(Y, G, Nu, beamP, beamT, thick,  fx, fy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beamDimensions_+3A_y">Y</code></td>
<td>
<p>Elastic modulus value for material (Pa).</p>
</td></tr>
<tr><td><code id="beamDimensions_+3A_g">G</code></td>
<td>
<p>Shear modulus value for material (Pa). If using Euler-Bernoulli model, G = 0.</p>
</td></tr>
<tr><td><code id="beamDimensions_+3A_nu">Nu</code></td>
<td>
<p>Poisson's ratio value for material.</p>
</td></tr>
<tr><td><code id="beamDimensions_+3A_beamp">beamP</code></td>
<td>
<p>Matrix (2 x n) of beam coordinates.</p>
</td></tr>
<tr><td><code id="beamDimensions_+3A_beamt">beamT</code></td>
<td>
<p>Matrix (2 x n) containing the number of the coordinate point as shown in beamP that connect to form a given beam (Discretization table).</p>
</td></tr>
<tr><td><code id="beamDimensions_+3A_thick">thick</code></td>
<td>
<p>Thickness of the beam</p>
</td></tr>
<tr><td><code id="beamDimensions_+3A_fx">fx</code></td>
<td>
<p>Load value (newtons) in the x direction.</p>
</td></tr>
<tr><td><code id="beamDimensions_+3A_fy">fy</code></td>
<td>
<p>Load value (newtons) in the y direction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Calculates values needed for both Timoshenko-Ehrenfest and Euler-Bernoulli beam theories.
</p>
<table>
<tr><td><code>k</code></td>
<td>
<p>Timoshenko-Ehrenfest correction</p>
</td></tr>
<tr><td><code>Length</code></td>
<td>
<p>Beam length</p>
</td></tr>
<tr><td><code>Angle</code></td>
<td>
<p>Beam angle within the plane</p>
</td></tr>
<tr><td><code>MomentofInertia</code></td>
<td>
<p>Moment of Inertia for each beam</p>
</td></tr>
<tr><td><code>Displacement</code></td>
<td>
<p>Displacement under Timoshenko-Ehernfest beam theory</p>
</td></tr>
<tr><td><code>RotationAngle</code></td>
<td>
<p>Angle of rotation</p>
</td></tr>
<tr><td><code>StiffnessAngle</code></td>
<td>
<p>Stiffness angle</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(beamGeo)

DOF = 4
n = NROW(beamGeo$beamT)
thick = matrix(c(0.039149, 0.03, 0.0246625), ncol = 1, nrow = n) #height(thickness) of beam

beamDime = beamDimensions(beamGeo$Y, beamGeo$G, beamGeo$Nu, beamGeo$beamP, beamGeo$beamT,
                          beamGeo$thick, beamGeo$fx, beamGeo$fy)

</code></pre>

<hr>
<h2 id='beamElementMat'>beamElementMat</h2><span id='topic+beamElementMat'></span>

<h3>Description</h3>

<p>Generates element stiffness matrix for beams.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beamElementMat(beamP, beamT, Y, Length, MoI)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beamElementMat_+3A_beamp">beamP</code></td>
<td>
<p>Matrix (2 x n) of beam coordinates.</p>
</td></tr>
<tr><td><code id="beamElementMat_+3A_beamt">beamT</code></td>
<td>
<p>Matrix (2 x n) containing the number of the coordinate point as shown in beamP that connect to form a given beam (Discretization table).</p>
</td></tr>
<tr><td><code id="beamElementMat_+3A_y">Y</code></td>
<td>
<p>Elastic modulus value for material.</p>
</td></tr>
<tr><td><code id="beamElementMat_+3A_length">Length</code></td>
<td>
<p>Length of beams.</p>
</td></tr>
<tr><td><code id="beamElementMat_+3A_moi">MoI</code></td>
<td>
<p>Moment of inertia for each beam segment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Generates initial element matrix needed for the finite element model.
</p>
<table>
<tr><td><code>beamEmat</code></td>
<td>
<p>An element matrix of the beam</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(beamGeo)
data(beamDime)

Length = beamDime$Length
MoI = beamDime$MomentofInertia

beamEmat = beamElementMat(beamGeo$beamP, beamGeo$beamT, beamGeo$Y, Length, MoI)

</code></pre>

<hr>
<h2 id='beamEmat'>List of element matrices for each element. Obtained from function: beamElementMat</h2><span id='topic+beamEmat'></span>

<h3>Description</h3>

<p>List of element matrices for each element. Obtained from function: beamElementMat
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beamEmat
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 3.
</p>

<hr>
<h2 id='beamExMat'>List of element matrices for each element. Obtained from function: beamElementMat</h2><span id='topic+beamExMat'></span>

<h3>Description</h3>

<p>List of element matrices for each element. Obtained from function: beamElementMat
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beamExMat
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 3.
</p>

<hr>
<h2 id='beamExpandEM'>beamExpandEM</h2><span id='topic+beamExpandEM'></span>

<h3>Description</h3>

<p>Expanded element matrix for beam.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beamExpandEM(beamP, beamT, ElementMat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beamExpandEM_+3A_beamp">beamP</code></td>
<td>
<p>Matrix (2 x n) of beam coordinates.</p>
</td></tr>
<tr><td><code id="beamExpandEM_+3A_beamt">beamT</code></td>
<td>
<p>Matrix (2 x n) containing the number of the coordinate point as shown in beamP that connect to form a given beam (Discretization table).</p>
</td></tr>
<tr><td><code id="beamExpandEM_+3A_elementmat">ElementMat</code></td>
<td>
<p>Element stiffness matrix list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>produces large (n x n) element matrix from initial element matrix.
</p>
<table>
<tr><td><code>beamExMat</code></td>
<td>
<p>The expanded element matrix</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(beamGeo)
data(beamEmat)

ElementMat = beamEmat
beamExMat =  beamExpandEM(beamGeo$beamP, beamGeo$beamT, ElementMat)

</code></pre>

<hr>
<h2 id='beamForceVector'>beamForceVector</h2><span id='topic+beamForceVector'></span>

<h3>Description</h3>

<p>Creates a matrix of loads for beams in the x &amp; y direction for each load unconstrained node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beamForceVector(beamP, fx, fy, NodeKnownL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beamForceVector_+3A_beamp">beamP</code></td>
<td>
<p>Matrix (2 x n) of beam coordinates.</p>
</td></tr>
<tr><td><code id="beamForceVector_+3A_fx">fx</code></td>
<td>
<p>Load vector (newtons) in the x-direction.</p>
</td></tr>
<tr><td><code id="beamForceVector_+3A_fy">fy</code></td>
<td>
<p>Load vector (newtons) in the y-direction.</p>
</td></tr>
<tr><td><code id="beamForceVector_+3A_nodeknownl">NodeKnownL</code></td>
<td>
<p>Data frame with constraint parameters applied to each node in the x and y directions. Formatted for use in reduced element matrix. Generated from ApplyBC function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Produces a matrix with loading parameters for each node.
</p>
<table>
<tr><td><code>ReducedFV</code></td>
<td>
<p>Reduced force vector matrix containing the model load parameters.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(beamGeo)
data(beamUDL)

NodeKnownL = beamBC
FV = beamForceVector(beamGeo$beamP, beamGeo$fx, beamGeo$fy, NodeKnownL)

</code></pre>

<hr>
<h2 id='beamFV'>Load vector produced from function function: beamForceVector</h2><span id='topic+beamFV'></span>

<h3>Description</h3>

<p>Load vector produced from function function: beamForceVector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beamFV
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 5 rows and 1 columns.
</p>

<hr>
<h2 id='beamGeo'>Sample geometry for beam. Includes shape, discretization table, boundary conditions, thickness, and material details.</h2><span id='topic+beamGeo'></span>

<h3>Description</h3>

<p>Sample geometry for beam. Includes shape, discretization table, boundary conditions, thickness, and material details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beamGeo
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 12.
</p>

<hr>
<h2 id='beamGLforce'>Global and Local loading force matrices obtained from function: beamGLForces</h2><span id='topic+beamGLforce'></span>

<h3>Description</h3>

<p>Global and Local loading force matrices obtained from function: beamGLForces
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beamGLforce
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.
</p>

<hr>
<h2 id='beamGLForces'>beamGLForces</h2><span id='topic+beamGLForces'></span>

<h3>Description</h3>

<p>Uses nodal displacements to determine global and local forces at each node
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beamGLForces(beamP, beamT, Y, MoI, Length, GMat, BUDL, BND)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beamGLForces_+3A_beamp">beamP</code></td>
<td>
<p>Matrix (2 x n) of beam coordinates.</p>
</td></tr>
<tr><td><code id="beamGLForces_+3A_beamt">beamT</code></td>
<td>
<p>Matrix (2 x n) containing the number of the coordinate point as shown in beamP that connect to form a given beam (Discretization table).</p>
</td></tr>
<tr><td><code id="beamGLForces_+3A_y">Y</code></td>
<td>
<p>Elastic Modulus of material</p>
</td></tr>
<tr><td><code id="beamGLForces_+3A_moi">MoI</code></td>
<td>
<p>Moment of Inertia</p>
</td></tr>
<tr><td><code id="beamGLForces_+3A_length">Length</code></td>
<td>
<p>Length of beam</p>
</td></tr>
<tr><td><code id="beamGLForces_+3A_gmat">GMat</code></td>
<td>
<p>Global stiffness matrix</p>
</td></tr>
<tr><td><code id="beamGLForces_+3A_budl">BUDL</code></td>
<td>
<p>Column matrix for beam distributed load</p>
</td></tr>
<tr><td><code id="beamGLForces_+3A_bnd">BND</code></td>
<td>
<p>beam nodal displacement, output from function &quot;beamNodeDis&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrices of global and local forces. (Results in kN)
</p>
<table>
<tr><td><code>GForce</code></td>
<td>
<p>Large global force matrix.</p>
</td></tr>
<tr><td><code>Lforce</code></td>
<td>
<p>Large local force matrix.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(beamGeo)
data(beamDime)
data(beamsUDL)
data(beamND)
data(beamGloMat)

Length = beamDime$Length
MoI = beamDime$MomentofInertia
BUDL = beamsUDL
BND = beamND
GMat = beamGloMat

GLforce = beamGLForces(beamGeo$beamP, beamGeo$beamT, beamGeo$Y, MoI, Length, GMat, BUDL, BND)

</code></pre>

<hr>
<h2 id='beamGlobalEM'>beamGlobalEM</h2><span id='topic+beamGlobalEM'></span>

<h3>Description</h3>

<p>Generates global stiffness matrix for beams.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beamGlobalEM(beamExEM)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beamGlobalEM_+3A_beamexem">beamExEM</code></td>
<td>
<p>Expanded Element Matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Produces large (n x n) global matrix
</p>
<table>
<tr><td><code>GlobalMat</code></td>
<td>
<p>Global matrix</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(beamExMat)

beamExEM = beamExMat
GMat = beamGlobalEM(beamExEM)

</code></pre>

<hr>
<h2 id='beamGloMat'>Global element matrix, obtained from function: beamGlobalEM</h2><span id='topic+beamGloMat'></span>

<h3>Description</h3>

<p>Global element matrix, obtained from function: beamGlobalEM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beamGloMat
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 8 rows and 8 columns.
</p>

<hr>
<h2 id='beamND'>Global nodal displacement, obtained from function: beamNodeDis</h2><span id='topic+beamND'></span>

<h3>Description</h3>

<p>Global nodal displacement, obtained from function: beamNodeDis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beamND
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 3.
</p>

<hr>
<h2 id='beamNodeDis'>beamNodeDis</h2><span id='topic+beamNodeDis'></span>

<h3>Description</h3>

<p>Calculates global nodal displacements of beam.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beamNodeDis(beamP, BCtran, BCrot, REM, NodeKnownL, ForceV)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beamNodeDis_+3A_beamp">beamP</code></td>
<td>
<p>Matrix (2 x n) of beam coordinates.</p>
</td></tr>
<tr><td><code id="beamNodeDis_+3A_bctran">BCtran</code></td>
<td>
<p>Boundary constraint for nodes to translate in x or y directions.</p>
</td></tr>
<tr><td><code id="beamNodeDis_+3A_bcrot">BCrot</code></td>
<td>
<p>Boundary constraint for nodes to rotate.</p>
</td></tr>
<tr><td><code id="beamNodeDis_+3A_rem">REM</code></td>
<td>
<p>Reduced element matrix, returned from function ReducedEM.</p>
</td></tr>
<tr><td><code id="beamNodeDis_+3A_nodeknownl">NodeKnownL</code></td>
<td>
<p>data frame with constraint parameters applied to each node in the x and y directions. Formatted for use in reduced element matrix. Generated from ApplyBC function.</p>
</td></tr>
<tr><td><code id="beamNodeDis_+3A_forcev">ForceV</code></td>
<td>
<p>Reduced force vector matrix containing the model load parameters. Returned from function ForceVector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Produces tables with new node coordinates that are produced by the geometry under an applied load.
</p>
<table>
<tr><td><code>NodeDis</code></td>
<td>
<p>Nodal displacement</p>
</td></tr>
<tr><td><code>GlobalND</code></td>
<td>
<p>Nodal displacement in the global environment</p>
</td></tr>
<tr><td><code>GlobalNDMatrix</code></td>
<td>
<p>Nodal displacement in the global environment as a reduced matrix</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(beamGeo)
data(beamFV)
data(beamREM)
data(beamBC)

ForceV = beamFV
REM = beamREM
NodeKnownL = beamBC

beamND = beamNodeDis(beamGeo$beamP, beamGeo$BCtran, beamGeo$BCrot, REM, NodeKnownL, ForceV)

</code></pre>

<hr>
<h2 id='beamPlotSystem'>beamPlotSystem</h2><span id='topic+beamPlotSystem'></span>

<h3>Description</h3>

<p>Generates heat map for given stress or strain on the beam geometry. Threshold values for the color must be assigned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beamPlotSystem(beamP, beamT, PlotVal, a, b, c, d, e, f, g, h, i, j,
                  Oc, ac, bc, cc, dc, ec, fc, gc, hc, ic, jc, LWD)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beamPlotSystem_+3A_beamp">beamP</code></td>
<td>
<p>Matrix (2 x n) of beam coordinates.</p>
</td></tr>
<tr><td><code id="beamPlotSystem_+3A_beamt">beamT</code></td>
<td>
<p>Matrix (2 x n) containing the number of the coordinate point as shown in beamP that connect to form a given beam (Discretization table).</p>
</td></tr>
<tr><td><code id="beamPlotSystem_+3A_plotval">PlotVal</code></td>
<td>
<p>Value to be plotted, either stress or strain, return from function beamLocalStress function.</p>
</td></tr>
<tr><td><code id="beamPlotSystem_+3A_a">a</code></td>
<td>
<p>Threshold 1</p>
</td></tr>
<tr><td><code id="beamPlotSystem_+3A_b">b</code></td>
<td>
<p>Threshold 2</p>
</td></tr>
<tr><td><code id="beamPlotSystem_+3A_c">c</code></td>
<td>
<p>Threshold 3</p>
</td></tr>
<tr><td><code id="beamPlotSystem_+3A_d">d</code></td>
<td>
<p>Threshold 4</p>
</td></tr>
<tr><td><code id="beamPlotSystem_+3A_e">e</code></td>
<td>
<p>Threshold 5</p>
</td></tr>
<tr><td><code id="beamPlotSystem_+3A_f">f</code></td>
<td>
<p>Threshold 6</p>
</td></tr>
<tr><td><code id="beamPlotSystem_+3A_g">g</code></td>
<td>
<p>Threshold 7</p>
</td></tr>
<tr><td><code id="beamPlotSystem_+3A_h">h</code></td>
<td>
<p>Threshold 8</p>
</td></tr>
<tr><td><code id="beamPlotSystem_+3A_i">i</code></td>
<td>
<p>Threshold 9</p>
</td></tr>
<tr><td><code id="beamPlotSystem_+3A_j">j</code></td>
<td>
<p>Threshold 10</p>
</td></tr>
<tr><td><code id="beamPlotSystem_+3A_oc">Oc</code></td>
<td>
<p>Color for all zero values</p>
</td></tr>
<tr><td><code id="beamPlotSystem_+3A_ac">ac</code></td>
<td>
<p>Color 1</p>
</td></tr>
<tr><td><code id="beamPlotSystem_+3A_bc">bc</code></td>
<td>
<p>Color 2</p>
</td></tr>
<tr><td><code id="beamPlotSystem_+3A_cc">cc</code></td>
<td>
<p>Color 3</p>
</td></tr>
<tr><td><code id="beamPlotSystem_+3A_dc">dc</code></td>
<td>
<p>Color 4</p>
</td></tr>
<tr><td><code id="beamPlotSystem_+3A_ec">ec</code></td>
<td>
<p>Color 5</p>
</td></tr>
<tr><td><code id="beamPlotSystem_+3A_fc">fc</code></td>
<td>
<p>Color 6</p>
</td></tr>
<tr><td><code id="beamPlotSystem_+3A_gc">gc</code></td>
<td>
<p>Color 7</p>
</td></tr>
<tr><td><code id="beamPlotSystem_+3A_hc">hc</code></td>
<td>
<p>Color 8</p>
</td></tr>
<tr><td><code id="beamPlotSystem_+3A_ic">ic</code></td>
<td>
<p>Color 9</p>
</td></tr>
<tr><td><code id="beamPlotSystem_+3A_jc">jc</code></td>
<td>
<p>Color 10</p>
</td></tr>
<tr><td><code id="beamPlotSystem_+3A_lwd">LWD</code></td>
<td>
<p>Line (beam) width</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot of colored beam based on the plot value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(beamGeo)
data(beamStressResult)

PlotVal = beamStressResult

Oc = "slateblue"; ac = "steelblue2"; bc = "cyan2"; cc = "palegreen2";
dc = "darkolivegreen1"; ec = "lemonchiffon"; fc = "lightgoldenrod1";
gc = "gold"; hc= "lightsalmon"; ic= "tomato"; jc= "firebrick3"

a = 1e5;  b = 5e5;  c = 1e6;  d = 5e6;  e = 1e7;  f = 5e7;  g = 1e8;  h = 5e8; i = 1e9; j =5e9
beamPlotSystem(beamGeo$beamP, beamGeo$beamT, PlotVal, a, b, c, d, e, f, g, h, i, j, Oc,
ac, bc, cc, dc, ec, fc, gc, hc, ic, jc, LWD = 4)

</code></pre>

<hr>
<h2 id='beamReducedEM'>beamReducedEM</h2><span id='topic+beamReducedEM'></span>

<h3>Description</h3>

<p>Reduced stiffness matrix - use boundary condition to reduce matrix to smaller form by removing systems that are bound.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beamReducedEM(GMat, NodeKnownL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beamReducedEM_+3A_gmat">GMat</code></td>
<td>
<p>Global stiffness matrix</p>
</td></tr>
<tr><td><code id="beamReducedEM_+3A_nodeknownl">NodeKnownL</code></td>
<td>
<p>data frame with constraint parameters applied to each node in the x and y directions. Formatted for use in reduced element matrix. Generated from ApplyBC function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Produces a large matrix.
</p>
<table>
<tr><td><code>ReducedEM</code></td>
<td>
<p>Reduced element matrix.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(beamBC)
data(beamGloMat)

NodeKnownL = beamBC
GMat = beamGloMat
beamREM = beamReducedEM(GMat, NodeKnownL)

</code></pre>

<hr>
<h2 id='beamREM'>Reduced element matrix calculated from the expanded element matrix. Obtained from function: beamReducedEM</h2><span id='topic+beamREM'></span>

<h3>Description</h3>

<p>Reduced element matrix calculated from the expanded element matrix. Obtained from function: beamReducedEM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beamREM
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 5 rows and 5 columns.
</p>

<hr>
<h2 id='beamStress'>beamStress</h2><span id='topic+beamStress'></span>

<h3>Description</h3>

<p>Calculates local stress and strain for beam elements
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beamStress(beamP, beamT, Y, Length, MoI, RotAng, BND)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beamStress_+3A_beamp">beamP</code></td>
<td>
<p>Matrix (2 x n) of beam coordinates.</p>
</td></tr>
<tr><td><code id="beamStress_+3A_beamt">beamT</code></td>
<td>
<p>Matrix (2 x n) containing the number of the coordinate point as shown in beamP that connect to form a given beam (Discretization table).</p>
</td></tr>
<tr><td><code id="beamStress_+3A_y">Y</code></td>
<td>
<p>Value of Young's (Elastic) modulus</p>
</td></tr>
<tr><td><code id="beamStress_+3A_length">Length</code></td>
<td>
<p>Length of beam</p>
</td></tr>
<tr><td><code id="beamStress_+3A_moi">MoI</code></td>
<td>
<p>Moment of Inertia</p>
</td></tr>
<tr><td><code id="beamStress_+3A_rotang">RotAng</code></td>
<td>
<p>Angle of rotation</p>
</td></tr>
<tr><td><code id="beamStress_+3A_bnd">BND</code></td>
<td>
<p>Global nodal displacement matrix, return from function beamNodeDis</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Completes FEM by calculating values of stress and strain, produces three (3) [3 x n] matrix.
</p>
<table>
<tr><td><code>BendingStress</code></td>
<td>
<p>Bending Stress</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(beamGeo)
data(beamGLforce)

Length = beamDime$Length
MoI = beamDime$MomentofInertia
RotAng = beamDime$Angle
BND = beamND

beamBendStress = beamStress(beamGeo$beamP, beamGeo$beamT, beamGeo$Y, Length, MoI, RotAng, BND)

</code></pre>

<hr>
<h2 id='beamStressResult'>FEA results for the beam model. Obtained from function: beamStress</h2><span id='topic+beamStressResult'></span>

<h3>Description</h3>

<p>FEA results for the beam model. Obtained from function: beamStress
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beamStressResult
</code></pre>


<h3>Format</h3>

<p>An object of class <code>numeric</code> of length 3.
</p>

<hr>
<h2 id='beamsUDL'>Uniformly distributed load on beam surface</h2><span id='topic+beamsUDL'></span>

<h3>Description</h3>

<p>Uniformly distributed load on beam surface
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beamsUDL
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 3.
</p>

<hr>
<h2 id='beamUDL'>beamUDL</h2><span id='topic+beamUDL'></span>

<h3>Description</h3>

<p>Uniformly distributes load over the length of the beam.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beamUDL(beamP, beamT, Length, fx, fy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beamUDL_+3A_beamp">beamP</code></td>
<td>
<p>Matrix (2 x n) of beam coordinates.</p>
</td></tr>
<tr><td><code id="beamUDL_+3A_beamt">beamT</code></td>
<td>
<p>Matrix (2 x n) containing the number of the coordinate point as shown in beamP that connect to form a given beam (Discretization table).</p>
</td></tr>
<tr><td><code id="beamUDL_+3A_length">Length</code></td>
<td>
<p>Length of beam.</p>
</td></tr>
<tr><td><code id="beamUDL_+3A_fx">fx</code></td>
<td>
<p>Load value (newtons) in the x direction.</p>
</td></tr>
<tr><td><code id="beamUDL_+3A_fy">fy</code></td>
<td>
<p>Load value (newtons) in the y direction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Produces matrix representing uniformly distributed load on beam
</p>
<table>
<tr><td><code>DLMatrix</code></td>
<td>
<p>Column matrix for beam distributed load</p>
</td></tr>
<tr><td><code>ExpandedDLMatrix</code></td>
<td>
<p>Expanded beam distribution load</p>
</td></tr>
<tr><td><code>ReductedDLMatrix</code></td>
<td>
<p>Reduced beam distribution load</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(beamGeo)
data(beamDime)

Length = beamDime$Length
beamUDL = beamUDL(beamGeo$beamP, beamGeo$beamT, Length, beamGeo$fx, beamGeo$fy)

</code></pre>

<hr>
<h2 id='bound'>Boundary conditions applied to each node. Obtained from function: ApplyBC</h2><span id='topic+bound'></span>

<h3>Description</h3>

<p>Boundary conditions applied to each node. Obtained from function: ApplyBC
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bound
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 100 rows and 1 columns.
</p>

<hr>
<h2 id='Cart'>Sample geometry. Matrix with x and y coordinates for initial shape.</h2><span id='topic+Cart'></span>

<h3>Description</h3>

<p>Sample geometry. Matrix with x and y coordinates for initial shape.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Cart
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 11 rows and 2 columns.
</p>

<hr>
<h2 id='cleanpoly'>Cleaned nodal distribution in and on polygon. Obtained from function: Threshpts</h2><span id='topic+cleanpoly'></span>

<h3>Description</h3>

<p>Cleaned nodal distribution in and on polygon. Obtained from function: Threshpts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cleanpoly
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.
</p>

<hr>
<h2 id='dime'>Dimensional data for mesh elements. Includes area, length, aspect ratio, angles and lengths of elements. Obtained from function: Dimensions</h2><span id='topic+dime'></span>

<h3>Description</h3>

<p>Dimensional data for mesh elements. Includes area, length, aspect ratio, angles and lengths of elements. Obtained from function: Dimensions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dime
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 6.
</p>

<hr>
<h2 id='Dimensions.2d'>Dimensions.2d</h2><span id='topic+Dimensions.2d'></span>

<h3>Description</h3>

<p>Calculates dimensional values for each triangular element, including truss length &amp; angles, distance from nodal point to centroid, aspect ratio of each triangle element, and area of the triangle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dimensions.2d(meshP, meshT, centroid)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dimensions.2d_+3A_meshp">meshP</code></td>
<td>
<p>Matrix (2 x n) containing coordinate points of the mesh nodes.</p>
</td></tr>
<tr><td><code id="Dimensions.2d_+3A_mesht">meshT</code></td>
<td>
<p>Matrix (3 x n) containing the number of the coordinate point that forms a given triangle within the mesh.</p>
</td></tr>
<tr><td><code id="Dimensions.2d_+3A_centroid">centroid</code></td>
<td>
<p>Matrix (2 x n) containing coordinate points of the centroid of each triangular element.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Evaluation of triangle elements truss, angle, and area.
</p>
<table>
<tr><td><code>Truss</code></td>
<td>
<p>Nodal pairs that form each truss.</p>
</td></tr>
<tr><td><code>TrussLength</code></td>
<td>
<p>Distance between each paired nodes forming a truss, its length.</p>
</td></tr>
<tr><td><code>Dist2Cent</code></td>
<td>
<p>Shortest distance from truss to triangle centroid.</p>
</td></tr>
<tr><td><code>Truss angle</code></td>
<td>
<p>Angles of the triangle created from truss meeting.</p>
</td></tr>
<tr><td><code>AspectRatio</code></td>
<td>
<p>Aspect ratio of triangle elements.</p>
</td></tr>
<tr><td><code>Area</code></td>
<td>
<p>Area within triangle elements.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(triMesh)
data(polyshape)

meshP = triMesh$MeshPts$p
meshT = triMesh$MeshPts$T
centroid = triMesh$Centroids

dime = Dimensions.2d(meshP, meshT, centroid)

</code></pre>

<hr>
<h2 id='displacN'>Global nodal displacement, obtained from function: NodeDis</h2><span id='topic+displacN'></span>

<h3>Description</h3>

<p>Global nodal displacement, obtained from function: NodeDis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>displacN
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.
</p>

<hr>
<h2 id='ElementMat.2d'>ElementMat.2d</h2><span id='topic+ElementMat.2d'></span>

<h3>Description</h3>

<p>Generates an element stiffness matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ElementMat.2d(meshP, meshT, Nu, Y, Thick)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ElementMat.2d_+3A_meshp">meshP</code></td>
<td>
<p>Matrix (2 x n) containing coordinate points of the mesh nodes.</p>
</td></tr>
<tr><td><code id="ElementMat.2d_+3A_mesht">meshT</code></td>
<td>
<p>Matrix (3 x n) containing the number of the coordinate point that forms a given triangle within the mesh.</p>
</td></tr>
<tr><td><code id="ElementMat.2d_+3A_nu">Nu</code></td>
<td>
<p>Value of Poisson's ratio for each element</p>
</td></tr>
<tr><td><code id="ElementMat.2d_+3A_y">Y</code></td>
<td>
<p>Value of Young's (Elastic) modulus for each element</p>
</td></tr>
<tr><td><code id="ElementMat.2d_+3A_thick">Thick</code></td>
<td>
<p>Value of the thickness of the mesh, a positive value must be given.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Generates initial element matrix needed for the finite element model.
</p>
<table>
<tr><td><code>EMPStress</code></td>
<td>
<p>An element matrix of the geometry under stress.</p>
</td></tr>
<tr><td><code>EMPStrain</code></td>
<td>
<p>An element matrix of the geometry under strain.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(triMesh)

meshP = triMesh$MeshPts$p
meshT = triMesh$MeshPts$T
Y = matrix(20e9, nrow = NROW(meshT))
Nu = matrix(0.45, nrow = NROW(meshT))
Thick = 0.001
DOF = 6

fea_EM = ElementMat.2d(meshP, meshT, Nu, Y, Thick)

</code></pre>

<hr>
<h2 id='EulerBeamFEA'>EulerBeamFEA</h2><span id='topic+EulerBeamFEA'></span>

<h3>Description</h3>

<p>Calculates stress in beam structures using the Euler-Bernoulli beam theory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EulerBeamFEA(Y, beamP, beamT, fx, fy, BCtran, BCrot, Length, MoI, RotAng)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EulerBeamFEA_+3A_y">Y</code></td>
<td>
<p>Elastic modulus value for material (Pa).</p>
</td></tr>
<tr><td><code id="EulerBeamFEA_+3A_beamp">beamP</code></td>
<td>
<p>Matrix (2 x n) of beam coordinates.</p>
</td></tr>
<tr><td><code id="EulerBeamFEA_+3A_beamt">beamT</code></td>
<td>
<p>Matrix (2 x n) containing the number of the coordinate point as shown in beamP that connect to form a given beam (Discretization table).</p>
</td></tr>
<tr><td><code id="EulerBeamFEA_+3A_fx">fx</code></td>
<td>
<p>Load value (newtons) in the x direction.</p>
</td></tr>
<tr><td><code id="EulerBeamFEA_+3A_fy">fy</code></td>
<td>
<p>Load value (newtons) in the y direction.</p>
</td></tr>
<tr><td><code id="EulerBeamFEA_+3A_bctran">BCtran</code></td>
<td>
<p>Boundary constraint for nodes to translate in x or y directions. Input as a non-matrix column.</p>
</td></tr>
<tr><td><code id="EulerBeamFEA_+3A_bcrot">BCrot</code></td>
<td>
<p>Boundary constraint for nodes to rotate. Input as a non-matrix column.</p>
</td></tr>
<tr><td><code id="EulerBeamFEA_+3A_length">Length</code></td>
<td>
<p>Length of beam.</p>
</td></tr>
<tr><td><code id="EulerBeamFEA_+3A_moi">MoI</code></td>
<td>
<p>Moment of inertia for each beam segment.</p>
</td></tr>
<tr><td><code id="EulerBeamFEA_+3A_rotang">RotAng</code></td>
<td>
<p>Angle of rotation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Calculates local forces and stresses, as well as bending stress for beams following the Euler-Bernoulli beam theory.
</p>
<table>
<tr><td><code>Stress</code></td>
<td>
<p>Local stress at node</p>
</td></tr>
<tr><td><code>LocalLoad</code></td>
<td>
<p>Local load at node</p>
</td></tr>
<tr><td><code>BendingStress</code></td>
<td>
<p>Bending Stress</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(beamGeo)
data(beamDime)

Length = beamDime$Length
MoI = beamDime$MomentofInertia
RotAng = beamDime$Angle

beamFEA = EulerBeamFEA(beamGeo$Y, beamGeo$beamP, beamGeo$beamT, beamGeo$fx, beamGeo$fy,
                       beamGeo$BCtran, beamGeo$BCrot, Length, MoI, RotAng)

</code></pre>

<hr>
<h2 id='ExpandEM.2d'>ExpandEM.2d</h2><span id='topic+ExpandEM.2d'></span>

<h3>Description</h3>

<p>Generates the expanded element matrix, which represents the contribution of individual finite elements towards the global structural matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExpandEM.2d(meshP, meshT, centroid, EMatrixlist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExpandEM.2d_+3A_meshp">meshP</code></td>
<td>
<p>Matrix (2 x n) containing coordinate points of the mesh nodes.</p>
</td></tr>
<tr><td><code id="ExpandEM.2d_+3A_mesht">meshT</code></td>
<td>
<p>Matrix (3 x n) containing the number of the coordinate point that forms a given triangle within the mesh.</p>
</td></tr>
<tr><td><code id="ExpandEM.2d_+3A_centroid">centroid</code></td>
<td>
<p>Matrix (2 x n) containing coordinate points of the centroid of each triangular element.</p>
</td></tr>
<tr><td><code id="ExpandEM.2d_+3A_ematrixlist">EMatrixlist</code></td>
<td>
<p>EMPStress or EMPStrain generated from ElementMat function. List of element matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Produces large (n x n) matrix.
</p>
<table>
<tr><td><code>ExpandedMat</code></td>
<td>
<p>The expanded element matrix</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(triMesh)
data(fea_EM)

meshP = triMesh$MeshPts$p
meshT = triMesh$MeshPts$T
centroid = triMesh$Centroids
EMatrixlist = fea_EM$EMPStress

fea_ExEM = ExpandEM.2d(meshP, meshT, centroid, EMatrixlist)

</code></pre>

<hr>
<h2 id='ExpandSFT.2d'>ExpandSFT.2d</h2><span id='topic+ExpandSFT.2d'></span>

<h3>Description</h3>

<p>Generates expanded surface force element matrix from SurfaceTraction function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExpandSFT.2d(meshP, meshT, SurfTrac)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExpandSFT.2d_+3A_meshp">meshP</code></td>
<td>
<p>Matrix (2 x n) containing coordinate points of the mesh nodes.</p>
</td></tr>
<tr><td><code id="ExpandSFT.2d_+3A_mesht">meshT</code></td>
<td>
<p>Matrix (3 x n) containing the number of the coordinate point that forms a given triangle within the mesh.</p>
</td></tr>
<tr><td><code id="ExpandSFT.2d_+3A_surftrac">SurfTrac</code></td>
<td>
<p>List of surface forces.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Produces a large (n x n) element matrix of surface forces.
</p>
<table>
<tr><td><code>ExpandedSurf</code></td>
<td>
<p>Expanded surface force element matrix.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(triMesh)
data(SurfTrac)

meshT = triMesh$MeshPts$T
meshP = triMesh$MeshPts$p

expSurf = ExpandSFT.2d(meshP, meshT, SurfTrac)

</code></pre>

<hr>
<h2 id='expSurf'>Expanded element matrix for surface forces. Obtained from function: ExpandSFT</h2><span id='topic+expSurf'></span>

<h3>Description</h3>

<p>Expanded element matrix for surface forces. Obtained from function: ExpandSFT
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expSurf
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 50.
</p>

<hr>
<h2 id='fea_EM'>List of element matrices for each element. Obtained from function: ElementMat</h2><span id='topic+fea_EM'></span>

<h3>Description</h3>

<p>List of element matrices for each element. Obtained from function: ElementMat
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fea_EM
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.
</p>

<hr>
<h2 id='fea_ExEM'>List of large expanded element matrices calculated from the element matrix. Obtained from function: ExpandEM</h2><span id='topic+fea_ExEM'></span>

<h3>Description</h3>

<p>List of large expanded element matrices calculated from the element matrix. Obtained from function: ExpandEM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fea_ExEM
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 78.
</p>

<hr>
<h2 id='fea_result'>FEA results. Produces list with results from local stresses including Stress, Strain, and Stress from Strain. Obtained from function: LocalStress</h2><span id='topic+fea_result'></span>

<h3>Description</h3>

<p>FEA results. Produces list with results from local stresses including Stress, Strain, and Stress from Strain. Obtained from function: LocalStress
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fea_result
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 3.
</p>

<hr>
<h2 id='FEMStrain.2d'>FEMStrain.2d</h2><span id='topic+FEMStrain.2d'></span>

<h3>Description</h3>

<p>Creates a complete finite element model using strain for a given 2D mesh under specified boundary conditions (constrain and load).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FEMStrain.2d(meshP, meshT, centroid, BoundConx, BoundCony, SFShear,
SFTensile, Length, area, Fx, Fy, Y, Nu, Thick)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FEMStrain.2d_+3A_meshp">meshP</code></td>
<td>
<p>Matrix (2 x n) containing coordinate points of the mesh nodes.</p>
</td></tr>
<tr><td><code id="FEMStrain.2d_+3A_mesht">meshT</code></td>
<td>
<p>Matrix (3 x n) containing the number of the coordinate point that forms a given triangle within the mesh.</p>
</td></tr>
<tr><td><code id="FEMStrain.2d_+3A_centroid">centroid</code></td>
<td>
<p>Matrix (2 x n) containing coordinate points of the centroid of each triangular element.</p>
</td></tr>
<tr><td><code id="FEMStrain.2d_+3A_boundconx">BoundConx</code></td>
<td>
<p>Boundary constraint for nodes in the x-direction</p>
</td></tr>
<tr><td><code id="FEMStrain.2d_+3A_boundcony">BoundCony</code></td>
<td>
<p>Boundary constraint for nodes in the y-direction</p>
</td></tr>
<tr><td><code id="FEMStrain.2d_+3A_sfshear">SFShear</code></td>
<td>
<p>Magnitude of positive shear traction; if there is no surface traction then SFShear = 0</p>
</td></tr>
<tr><td><code id="FEMStrain.2d_+3A_sftensile">SFTensile</code></td>
<td>
<p>Magnitude of tensile surface traction; if there is no surface traction then SFTensile = 0</p>
</td></tr>
<tr><td><code id="FEMStrain.2d_+3A_length">Length</code></td>
<td>
<p>Truss length</p>
</td></tr>
<tr><td><code id="FEMStrain.2d_+3A_area">area</code></td>
<td>
<p>Triangle element area</p>
</td></tr>
<tr><td><code id="FEMStrain.2d_+3A_fx">Fx</code></td>
<td>
<p>Load vector for the x-direction</p>
</td></tr>
<tr><td><code id="FEMStrain.2d_+3A_fy">Fy</code></td>
<td>
<p>Load vector for the y-direction</p>
</td></tr>
<tr><td><code id="FEMStrain.2d_+3A_y">Y</code></td>
<td>
<p>Value of Young's (Elastic) modulus</p>
</td></tr>
<tr><td><code id="FEMStrain.2d_+3A_nu">Nu</code></td>
<td>
<p>Value of Poisson's ratio</p>
</td></tr>
<tr><td><code id="FEMStrain.2d_+3A_thick">Thick</code></td>
<td>
<p>Value of the thickness of the mesh, a value must be given.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Completes the FEM to generate values of stress and strain and nodal displacement.
</p>
<table>
<tr><td><code>NodeDisplacement</code></td>
<td>
<p>Node displacement on each axis</p>
</td></tr>
<tr><td><code>LocalStress</code></td>
<td>
<p>Stress as calucated from stress, strain, and stress from strain. Three (3) [3 x n] matrices where [x, y, tau]</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data(triMesh)
data(dime)

meshP = triMesh$MeshPts$p
meshT = triMesh$MeshPts$T
centroid = triMesh$Centroids
Y = matrix(20e9, nrow = NROW(meshT))
Nu = matrix(0.45, nrow = NROW(meshT))
Thick = 0.001
DOF = 6
BoundConx = BoundCony = numeric(NROW(meshP))
BoundConx[1:NROW(meshP)] = BoundCony[1:NROW(meshP)] = 1
BoundConx[c(10, 11, 12)] = BoundCony[c(10, 11, 12)] = 0
SFShear = 0
SFTensile = 0
Length = dime$TrussLength
area = dime$Area
Fx = 10
Fy = 10

fea_strain = FEMStrain.2d(meshP, meshT, centroid, BoundConx, BoundCony, SFShear, SFTensile,
             Length, area, Fx, Fy, Y, Nu, Thick)


</code></pre>

<hr>
<h2 id='FEMStress.2d'>FEMStress.2d</h2><span id='topic+FEMStress.2d'></span>

<h3>Description</h3>

<p>Creates a complete finite element model using stress for a given 2D mesh under specified boundary conditions (constrain and load).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FEMStress.2d(meshP, meshT, centroid, BoundConx, BoundCony, SFShear,
SFTensile, Length, area, Fx, Fy,  Y, Nu, Thick)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FEMStress.2d_+3A_meshp">meshP</code></td>
<td>
<p>Matrix (2 x n) containing coordinate points of the mesh nodes.</p>
</td></tr>
<tr><td><code id="FEMStress.2d_+3A_mesht">meshT</code></td>
<td>
<p>Matrix (3 x n) containing the number of the coordinate point that forms a given triangle within the mesh.</p>
</td></tr>
<tr><td><code id="FEMStress.2d_+3A_centroid">centroid</code></td>
<td>
<p>Matrix (2 x n) containing coordinate points of the centroid of each triangular element.</p>
</td></tr>
<tr><td><code id="FEMStress.2d_+3A_boundconx">BoundConx</code></td>
<td>
<p>Boundary constraint for nodes in the x-direction</p>
</td></tr>
<tr><td><code id="FEMStress.2d_+3A_boundcony">BoundCony</code></td>
<td>
<p>Boundary constraint for nodes in the y-direction</p>
</td></tr>
<tr><td><code id="FEMStress.2d_+3A_sfshear">SFShear</code></td>
<td>
<p>Magnitude of positive shear traction; if there is no surface traction then SFShear = 0</p>
</td></tr>
<tr><td><code id="FEMStress.2d_+3A_sftensile">SFTensile</code></td>
<td>
<p>Magnitude of tensile surface traction; if there is no surface traction then SFTensile = 0</p>
</td></tr>
<tr><td><code id="FEMStress.2d_+3A_length">Length</code></td>
<td>
<p>Truss length</p>
</td></tr>
<tr><td><code id="FEMStress.2d_+3A_area">area</code></td>
<td>
<p>Triangle element area</p>
</td></tr>
<tr><td><code id="FEMStress.2d_+3A_fx">Fx</code></td>
<td>
<p>Load vector for the x-direction</p>
</td></tr>
<tr><td><code id="FEMStress.2d_+3A_fy">Fy</code></td>
<td>
<p>Load vector for the y-direction</p>
</td></tr>
<tr><td><code id="FEMStress.2d_+3A_y">Y</code></td>
<td>
<p>Value of Young's (Elastic) modulus</p>
</td></tr>
<tr><td><code id="FEMStress.2d_+3A_nu">Nu</code></td>
<td>
<p>Value of Poisson's ratio</p>
</td></tr>
<tr><td><code id="FEMStress.2d_+3A_thick">Thick</code></td>
<td>
<p>Value of the thickness of the mesh, a value must be given.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Completes the FEM to generate values of stress and strain and nodal displacement.
</p>
<table>
<tr><td><code>NodeDisplacement</code></td>
<td>
<p>Node displacement on each axis</p>
</td></tr>
<tr><td><code>LocalStress</code></td>
<td>
<p>Stress as calucated from stress, strain, and stress from strain. Three (3) [3 x n] matrices where [x, y, tau]</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data(triMesh)
data(dime)

meshP = triMesh$MeshPts$p
meshT = triMesh$MeshPts$T
centroid = triMesh$Centroids
Y = matrix(20e9, nrow = NROW(meshT))
Nu = matrix(0.45, nrow = NROW(meshT))
Thick = 0.001
DOF = 6
BoundConx = BoundCony = numeric(NROW(meshP))
BoundConx[1:NROW(meshP)] = BoundCony[1:NROW(meshP)] = 1
BoundConx[c(10, 11, 12)] = BoundCony[c(10, 11, 12)] = 0
SFShear = 0
SFTensile = 0
Length = dime$TrussLength
area = dime$Area
Fx = 10
Fy = 10

fea_stress = FEMStress.2d(meshP, meshT, centroid, BoundConx, BoundCony, SFShear, SFTensile,
             Length, area, Fx, Fy, Y, Nu, Thick)


</code></pre>

<hr>
<h2 id='ForceVector.2d'>ForceVector.2d</h2><span id='topic+ForceVector.2d'></span>

<h3>Description</h3>

<p>Creates a matrix of loads in the x &amp; y direction for each load unconstrained node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ForceVector.2d(Fx, Fy, RSF, meshP, NodeKnownL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ForceVector.2d_+3A_fx">Fx</code></td>
<td>
<p>Load vector for the x-direction</p>
</td></tr>
<tr><td><code id="ForceVector.2d_+3A_fy">Fy</code></td>
<td>
<p>Load vector for the y-direction</p>
</td></tr>
<tr><td><code id="ForceVector.2d_+3A_rsf">RSF</code></td>
<td>
<p>If surface traction is present assign value as the ReducedSF matrix; if there is no surface traction set RSF = 0</p>
</td></tr>
<tr><td><code id="ForceVector.2d_+3A_meshp">meshP</code></td>
<td>
<p>Matrix (2 x n) containing coordinate points of the mesh nodes.</p>
</td></tr>
<tr><td><code id="ForceVector.2d_+3A_nodeknownl">NodeKnownL</code></td>
<td>
<p>data frame with constraint parameters applied to each node in the x and y directions. Formatted for use in reduced element matrix. Generated from ApplyBC function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Produces a matrix with loading parameters for each node.
</p>
<table>
<tr><td><code>ReducedFV</code></td>
<td>
<p>Reduced force vector matrix containing the model load parameters.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(triMesh)
data(reduc_SF)
data(bound)

meshP = triMesh$MeshPts$p
RSF = reduc_SF
Fx = 10
Fy = 10
NodeKnownL = bound

load = ForceVector.2d(Fx, Fy, RSF, meshP, NodeKnownL)

</code></pre>

<hr>
<h2 id='glfor'>Global and Local loading force matrices obtained from function: GLForces</h2><span id='topic+glfor'></span>

<h3>Description</h3>

<p>Global and Local loading force matrices obtained from function: GLForces
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glfor
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.
</p>

<hr>
<h2 id='GLForces.2d'>GLForces.2d</h2><span id='topic+GLForces.2d'></span>

<h3>Description</h3>

<p>Uses nodal displacements to determine global and local forces at each node
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GLForces.2d(meshP, meshT, GMat, GlobalND, EMatrixlist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GLForces.2d_+3A_meshp">meshP</code></td>
<td>
<p>Matrix (2 x n) containing coordinate points of the mesh nodes.</p>
</td></tr>
<tr><td><code id="GLForces.2d_+3A_mesht">meshT</code></td>
<td>
<p>Matrix (3 x n) containing the number of the coordinate point that forms a given triangle within the mesh.</p>
</td></tr>
<tr><td><code id="GLForces.2d_+3A_gmat">GMat</code></td>
<td>
<p>Global matrix</p>
</td></tr>
<tr><td><code id="GLForces.2d_+3A_globalnd">GlobalND</code></td>
<td>
<p>Global nodal displacement</p>
</td></tr>
<tr><td><code id="GLForces.2d_+3A_ematrixlist">EMatrixlist</code></td>
<td>
<p>Element matrix list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrices of global and local forces
</p>
<table>
<tr><td><code>GForce</code></td>
<td>
<p>Large global force matrix.</p>
</td></tr>
<tr><td><code>Lforce</code></td>
<td>
<p>Large local force matrix.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(triMesh)
data(gloMat)
data(displacN)
data(fea_EM)

meshP = triMesh$MeshPts$p
meshT = triMesh$MeshPts$T
GMat = gloMat
GlobalND = displacN$GlobalND
EMatrixlist = fea_EM$EMPStress

glfor = GLForces.2d(meshP, meshT, GMat, GlobalND, EMatrixlist)

</code></pre>

<hr>
<h2 id='GlobalMat.2d'>GlobalMat.2d</h2><span id='topic+GlobalMat.2d'></span>

<h3>Description</h3>

<p>Generates global stiffness matrix - once established, the expanded element matrix must be combined to create the global structural stiffness matrix by adding the expanded matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GlobalMat.2d(meshP, meshT, ExEM)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GlobalMat.2d_+3A_meshp">meshP</code></td>
<td>
<p>Matrix (2 x n) containing coordinate points of the mesh nodes.</p>
</td></tr>
<tr><td><code id="GlobalMat.2d_+3A_mesht">meshT</code></td>
<td>
<p>Matrix (3 x n) containing the number of the coordinate point that forms a given triangle within the mesh.</p>
</td></tr>
<tr><td><code id="GlobalMat.2d_+3A_exem">ExEM</code></td>
<td>
<p>Expanded element matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Produces large (n x n) global matrix
</p>
<table>
<tr><td><code>GlobalMat</code></td>
<td>
<p>Global matrix</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(triMesh)
data(fea_ExEM)

meshP = triMesh$MeshPts$p
meshT = triMesh$MeshPts$T
ExEM = fea_ExEM

gloMat = GlobalMat.2d(meshP, meshT, ExEM)

</code></pre>

<hr>
<h2 id='gloMat'>Global element matrix, obtained from function: GlobalMat</h2><span id='topic+gloMat'></span>

<h3>Description</h3>

<p>Global element matrix, obtained from function: GlobalMat
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gloMat
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 100 rows and 100 columns.
</p>

<hr>
<h2 id='load'>Load vector produced from function function: ForceVector</h2><span id='topic+load'></span>

<h3>Description</h3>

<p>Load vector produced from function function: ForceVector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 94 rows and 1 columns.
</p>

<hr>
<h2 id='LocalStress.2d'>LocalStress.2d</h2><span id='topic+LocalStress.2d'></span>

<h3>Description</h3>

<p>Calculates local stress and strain for triangular elements of the mesh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LocalStress.2d(meshP, meshT, Y, Nu, GlobalND)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LocalStress.2d_+3A_meshp">meshP</code></td>
<td>
<p>Matrix (2 x n) containing coordinate points of the mesh nodes.</p>
</td></tr>
<tr><td><code id="LocalStress.2d_+3A_mesht">meshT</code></td>
<td>
<p>Matrix (3 x n) containing the number of the coordinate point that forms a given triangle within the mesh.</p>
</td></tr>
<tr><td><code id="LocalStress.2d_+3A_y">Y</code></td>
<td>
<p>Value of Young's (Elastic) modulus</p>
</td></tr>
<tr><td><code id="LocalStress.2d_+3A_nu">Nu</code></td>
<td>
<p>Value of Poisson's ratio</p>
</td></tr>
<tr><td><code id="LocalStress.2d_+3A_globalnd">GlobalND</code></td>
<td>
<p>Global nodal displacement, return from function NodeDis</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Completes FEM by calculating values of stress and strain, produces three (3) [3 x n] matrix.
</p>
<table>
<tr><td><code>Strain</code></td>
<td>
<p>Calculated strain. [x, y, tau]</p>
</td></tr>
<tr><td><code>Stress</code></td>
<td>
<p>Calculated stress in pascals. [x, y, tau]</p>
</td></tr>
<tr><td><code>StressStrain</code></td>
<td>
<p>Stress as calucated from strain. [x, y, tau]</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
data(triMesh)
data(displacN)

meshP = triMesh$MeshPts$p
meshT = triMesh$MeshPts$T
Y = matrix(20e9, nrow = NROW(meshT))
Nu = matrix(0.45, nrow = NROW(meshT))
GlobalND = displacN$GlobalND

fea_result = LocalStress.2d(meshP, meshT, Y, Nu, GlobalND)


</code></pre>

<hr>
<h2 id='ManualAdjust.2d'>ManualAdjust.2d</h2><span id='topic+ManualAdjust.2d'></span>

<h3>Description</h3>

<p>Allows for manual refinement of the triangular mesh generated based on given parameters. Will remove triangle elements that are identified in the input (loc).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ManualAdjust.2d(meshP, meshT, edge, centroid, loc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ManualAdjust.2d_+3A_meshp">meshP</code></td>
<td>
<p>Matrix (2 x n) containing coordinate points of the mesh nodes.</p>
</td></tr>
<tr><td><code id="ManualAdjust.2d_+3A_mesht">meshT</code></td>
<td>
<p>Matrix (3 x n) containing the number of the coordinate point that forms a given triangle within the mesh.</p>
</td></tr>
<tr><td><code id="ManualAdjust.2d_+3A_edge">edge</code></td>
<td>
<p>Coordinate points of the initial geometry.</p>
</td></tr>
<tr><td><code id="ManualAdjust.2d_+3A_centroid">centroid</code></td>
<td>
<p>Matrix (2 x n) of triangle elements.</p>
</td></tr>
<tr><td><code id="ManualAdjust.2d_+3A_loc">loc</code></td>
<td>
<p>String containing the number of the meshT matrix row of the triangle chosen to be removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Generates new mesh and centroid tables
</p>
<table>
<tr><td><code>Meshpts</code></td>
<td>
<p>Includes both new mesh coordinate points and triangulation of points.</p>
</td></tr>
<tr><td><code>Centroids</code></td>
<td>
<p>Centroid positions for each triangle element.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(triMesh)
data(polyshape)

meshP = triMesh$MeshPts$p
meshT = triMesh$MeshPts$T
edge =  polyshape$Line
centroid = triMesh$Centroids
loc = c(7, 35, 17)

ManualAdjust.2d(meshP, meshT, edge, centroid, loc)

</code></pre>

<hr>
<h2 id='NodeDis.2d'>NodeDis.2d</h2><span id='topic+NodeDis.2d'></span>

<h3>Description</h3>

<p>Calculates global nodal displacements
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NodeDis.2d(meshP, REM, ForceV, NodeKnownL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NodeDis.2d_+3A_meshp">meshP</code></td>
<td>
<p>Matrix (2 x n) containing coordinate points of the mesh nodes.</p>
</td></tr>
<tr><td><code id="NodeDis.2d_+3A_rem">REM</code></td>
<td>
<p>Reduced element matrix, returned from function ReducedEM.</p>
</td></tr>
<tr><td><code id="NodeDis.2d_+3A_forcev">ForceV</code></td>
<td>
<p>Reduced force vector matrix containing the model load parameters. Returned from function ForceVector.</p>
</td></tr>
<tr><td><code id="NodeDis.2d_+3A_nodeknownl">NodeKnownL</code></td>
<td>
<p>data frame with constraint parameters applied to each node in the x and y directions. Formatted for use in reduced element matrix. Generated from ApplyBC function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Produces tables with new node coordinates that are produced by the geometry under an applied load.
</p>
<table>
<tr><td><code>NodeDis</code></td>
<td>
<p>Nodal displacement</p>
</td></tr>
<tr><td><code>GlobalND</code></td>
<td>
<p>Nodal displacement in the global environment</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(triMesh)
data(load)
data(reduc_EM)
data(bound)

meshP = triMesh$MeshPts$p
REM = reduc_EM
ForceV = load
NodeKnownL = bound

displacN = NodeDis.2d(meshP, REM, ForceV, NodeKnownL)

</code></pre>

<hr>
<h2 id='PlotSystem.2d'>PlotSystem.2d</h2><span id='topic+PlotSystem.2d'></span>

<h3>Description</h3>

<p>Generates heat map for given stress or strain on the geometry. Threshold values for the color must be assigned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotSystem.2d(meshP, meshT, PlotVal, a, b, c, d, e, f, g, h, i, j,
                  Oc, ac, bc, cc, dc, ec, fc, gc, hc, ic, jc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotSystem.2d_+3A_meshp">meshP</code></td>
<td>
<p>Matrix (2 x n) containing coordinate points of the mesh nodes.</p>
</td></tr>
<tr><td><code id="PlotSystem.2d_+3A_mesht">meshT</code></td>
<td>
<p>Matrix (3 x n) containing the number of the coordinate point that forms a given triangle within the mesh.</p>
</td></tr>
<tr><td><code id="PlotSystem.2d_+3A_plotval">PlotVal</code></td>
<td>
<p>Value to be plotted, either stress or strain, return from function LocalStress function.</p>
</td></tr>
<tr><td><code id="PlotSystem.2d_+3A_a">a</code></td>
<td>
<p>Threshold 1</p>
</td></tr>
<tr><td><code id="PlotSystem.2d_+3A_b">b</code></td>
<td>
<p>Threshold 2</p>
</td></tr>
<tr><td><code id="PlotSystem.2d_+3A_c">c</code></td>
<td>
<p>Threshold 3</p>
</td></tr>
<tr><td><code id="PlotSystem.2d_+3A_d">d</code></td>
<td>
<p>Threshold 4</p>
</td></tr>
<tr><td><code id="PlotSystem.2d_+3A_e">e</code></td>
<td>
<p>Threshold 5</p>
</td></tr>
<tr><td><code id="PlotSystem.2d_+3A_f">f</code></td>
<td>
<p>Threshold 6</p>
</td></tr>
<tr><td><code id="PlotSystem.2d_+3A_g">g</code></td>
<td>
<p>Threshold 7</p>
</td></tr>
<tr><td><code id="PlotSystem.2d_+3A_h">h</code></td>
<td>
<p>Threshold 8</p>
</td></tr>
<tr><td><code id="PlotSystem.2d_+3A_i">i</code></td>
<td>
<p>Threshold 9</p>
</td></tr>
<tr><td><code id="PlotSystem.2d_+3A_j">j</code></td>
<td>
<p>Threshold 10</p>
</td></tr>
<tr><td><code id="PlotSystem.2d_+3A_oc">Oc</code></td>
<td>
<p>Color 0</p>
</td></tr>
<tr><td><code id="PlotSystem.2d_+3A_ac">ac</code></td>
<td>
<p>Color 1</p>
</td></tr>
<tr><td><code id="PlotSystem.2d_+3A_bc">bc</code></td>
<td>
<p>Color 2</p>
</td></tr>
<tr><td><code id="PlotSystem.2d_+3A_cc">cc</code></td>
<td>
<p>Color 3</p>
</td></tr>
<tr><td><code id="PlotSystem.2d_+3A_dc">dc</code></td>
<td>
<p>Color 4</p>
</td></tr>
<tr><td><code id="PlotSystem.2d_+3A_ec">ec</code></td>
<td>
<p>Color 5</p>
</td></tr>
<tr><td><code id="PlotSystem.2d_+3A_fc">fc</code></td>
<td>
<p>Color 6</p>
</td></tr>
<tr><td><code id="PlotSystem.2d_+3A_gc">gc</code></td>
<td>
<p>Color 7</p>
</td></tr>
<tr><td><code id="PlotSystem.2d_+3A_hc">hc</code></td>
<td>
<p>Color 8</p>
</td></tr>
<tr><td><code id="PlotSystem.2d_+3A_ic">ic</code></td>
<td>
<p>Color 9</p>
</td></tr>
<tr><td><code id="PlotSystem.2d_+3A_jc">jc</code></td>
<td>
<p>Color 10</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot of colored polygon with mesh colored based on the plot value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(triMesh)
data(fea_result)

meshP = triMesh$MeshPts$p
meshT = triMesh$MeshPts$T
PlotVal = abs(fea_result$Stress[,1])
Oc = "slateblue"; ac = "steelblue2"; bc = "cyan2"; cc = "palegreen2";
dc = "darkolivegreen1"; ec = "lemonchiffon"; fc = "lightgoldenrod1"; gc = "gold";
hc= "lightsalmon"; ic= "tomato"; jc= "firebrick3"
a = 1e5;  b = 5e5;  c = 1e6;  d = 5e6;  e = 1e7;  f = 5e7;  g = 1e8;  h = 5e8; i = 1e9; j =5e9

PlotSystem.2d(meshP, meshT, PlotVal, a, b, c, d, e, f, g, h, i, j,
           Oc, ac, bc, cc, dc, ec, fc, gc, hc, ic, jc)


</code></pre>

<hr>
<h2 id='polyshape'>Sample geometry converted into a 2D polygon. Polygon data that specifies all coordinate, coordinates that are within the geometry and coordinates that construct the lines of the geometry. Obtained from function: SinglePoly</h2><span id='topic+polyshape'></span>

<h3>Description</h3>

<p>Sample geometry converted into a 2D polygon. Polygon data that specifies all coordinate, coordinates that are within the geometry and coordinates that construct the lines of the geometry. Obtained from function: SinglePoly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polyshape
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 3.
</p>

<hr>
<h2 id='reduc_EM'>Reduced element matrix calculated from the expanded element matrix. Obtained from function: ReducedEM</h2><span id='topic+reduc_EM'></span>

<h3>Description</h3>

<p>Reduced element matrix calculated from the expanded element matrix. Obtained from function: ReducedEM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduc_EM
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 94 rows and 94 columns.
</p>

<hr>
<h2 id='reduc_SF'>Reduced surface force matrix calculated from expanded element matrix. Obtained from function: ReducedSF</h2><span id='topic+reduc_SF'></span>

<h3>Description</h3>

<p>Reduced surface force matrix calculated from expanded element matrix. Obtained from function: ReducedSF
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduc_SF
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 100 rows and 1 columns.
</p>

<hr>
<h2 id='ReducedEM.2d'>ReducedEM.2d</h2><span id='topic+ReducedEM.2d'></span>

<h3>Description</h3>

<p>Reduced stiffness matrix - use boundary condition to reduce matrix to smaller form by removing systems that are bound.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReducedEM.2d(GMat, NodeKnownL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ReducedEM.2d_+3A_gmat">GMat</code></td>
<td>
<p>Global stiffness matrix</p>
</td></tr>
<tr><td><code id="ReducedEM.2d_+3A_nodeknownl">NodeKnownL</code></td>
<td>
<p>data frame with constraint parameters applied to each node in the x and y directions. Formatted for use in reduced element matrix. Generated from ApplyBC function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Produces a large matrix.
</p>
<table>
<tr><td><code>ReducedEM</code></td>
<td>
<p>Reduced element matrix.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(gloMat)
data(bound)
GMat = gloMat
NodeKnownL = bound
reduc_EM = ReducedEM.2d(GMat, NodeKnownL)

</code></pre>

<hr>
<h2 id='ReducedSF.2d'>ReducedSF.2d</h2><span id='topic+ReducedSF.2d'></span>

<h3>Description</h3>

<p>Reduced matrix of surface forces
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReducedSF.2d(meshP, ExSurf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ReducedSF.2d_+3A_meshp">meshP</code></td>
<td>
<p>Matrix (2 x n) containing coordinate points of the mesh nodes.</p>
</td></tr>
<tr><td><code id="ReducedSF.2d_+3A_exsurf">ExSurf</code></td>
<td>
<p>Expanded surface matrix, output from ExpandSFT</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Produces a large matrix.
</p>
<table>
<tr><td><code>RSF</code></td>
<td>
<p>Produces a large, reduced surface force matrix</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(triMesh)
data(expSurf)
meshP = triMesh$MeshPts$p
ExSurf = expSurf
reduc_SF = ReducedSF.2d(meshP, ExSurf)

</code></pre>

<hr>
<h2 id='SinglePoly.2d'>SinglePoly.2d</h2><span id='topic+SinglePoly.2d'></span>

<h3>Description</h3>

<p>Generates a mesh for polygon with a single continuous geometry
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SinglePoly.2d(x, y, ptDS, ptDL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SinglePoly.2d_+3A_x">x</code></td>
<td>
<p>X-coordinates for geometry.</p>
</td></tr>
<tr><td><code id="SinglePoly.2d_+3A_y">y</code></td>
<td>
<p>Y-coordinates for geometry.</p>
</td></tr>
<tr><td><code id="SinglePoly.2d_+3A_ptds">ptDS</code></td>
<td>
<p>Density of points desired within the geometry.</p>
</td></tr>
<tr><td><code id="SinglePoly.2d_+3A_ptdl">ptDL</code></td>
<td>
<p>Density of points desired at the perimeter of the geometry.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Coordinate points of nodes distributed within and on the line of a given geometry.
</p>
<table>
<tr><td><code>AllCoords</code></td>
<td>
<p>all coordinate points distributed across the geometry.</p>
</td></tr>
<tr><td><code>Within</code></td>
<td>
<p>all coordinate points within the geometry ONLY.</p>
</td></tr>
<tr><td><code>Line</code></td>
<td>
<p>all coordinate points that lay on the perimeter of the geometry ONLY.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(Cart)

x = Cart[,1]
y= Cart[,2]
ptDS = 30
ptDL = 20

polyshape = SinglePoly.2d(x, y, ptDS, ptDL)

</code></pre>

<hr>
<h2 id='SurfaceTraction.2d'>SurfaceTraction.2d</h2><span id='topic+SurfaceTraction.2d'></span>

<h3>Description</h3>

<p>Element Surface Traction - generates the column matrix for uniformly distributed surface traction. If surface traction is not present, assign SFTensile and SFShear a value of 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SurfaceTraction.2d(meshP, SFTensile, SFShear, Length, Thick, area)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SurfaceTraction.2d_+3A_meshp">meshP</code></td>
<td>
<p>Matrix (2 x n) containing coordinate points of the mesh nodes.</p>
</td></tr>
<tr><td><code id="SurfaceTraction.2d_+3A_sftensile">SFTensile</code></td>
<td>
<p>Magnitude of tensile surface traction</p>
</td></tr>
<tr><td><code id="SurfaceTraction.2d_+3A_sfshear">SFShear</code></td>
<td>
<p>Magnitude of positive shear traction</p>
</td></tr>
<tr><td><code id="SurfaceTraction.2d_+3A_length">Length</code></td>
<td>
<p>Truss length</p>
</td></tr>
<tr><td><code id="SurfaceTraction.2d_+3A_thick">Thick</code></td>
<td>
<p>Triangle element thickness</p>
</td></tr>
<tr><td><code id="SurfaceTraction.2d_+3A_area">area</code></td>
<td>
<p>Triangle element area</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of element matrices containing surface forces.
</p>
<table>
<tr><td><code>SurfT</code></td>
<td>
<p>List of surface forces for each element.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(triMesh)
data(dime)

meshP = triMesh$MeshPts$p
SFShear = 0
SFTensile = 0
Thick = 0.001
Length = dime$TrussLength
area = dime$Area

SurfTrac = SurfaceTraction.2d(meshP, SFTensile, SFShear, Length, Thick, area)

</code></pre>

<hr>
<h2 id='SurfTrac'>List of element matrices with surface traction. Obtained from function: SurfaceTraction</h2><span id='topic+SurfTrac'></span>

<h3>Description</h3>

<p>List of element matrices with surface traction. Obtained from function: SurfaceTraction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SurfTrac
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 50.
</p>

<hr>
<h2 id='ThreshPts.2d'>ThreshPts.2d</h2><span id='topic+ThreshPts.2d'></span>

<h3>Description</h3>

<p>Clean node distribution within or outside of geometry. Optional function for complex geometries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ThreshPts.2d(coords, thresh, edge)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ThreshPts.2d_+3A_coords">coords</code></td>
<td>
<p>Nodal coordinates</p>
</td></tr>
<tr><td><code id="ThreshPts.2d_+3A_thresh">thresh</code></td>
<td>
<p>Threshold for point removal. Ranges include: 500000-50000000</p>
</td></tr>
<tr><td><code id="ThreshPts.2d_+3A_edge">edge</code></td>
<td>
<p>Coordinate points of the initial geometry.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Coordinate points of valid nodes.
</p>
<table>
<tr><td><code>CleanedNodes</code></td>
<td>
<p>Matrix of new nodes that abide by given threshold rules.</p>
</td></tr>
<tr><td><code>NodeReport</code></td>
<td>
<p>Report identifying with nodes were kept and which were removed.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(polyshape)

coords = polyshape$Within
thresh = 5000000
edge = polyshape$Line

cleanpoly = ThreshPts.2d(coords, thresh, edge)

</code></pre>

<hr>
<h2 id='triangulate0.2d'>triangulate0.2d</h2><span id='topic+triangulate0.2d'></span>

<h3>Description</h3>

<p>Triangulation by Delaunayn algorithm. Automatically generates a triangular mesh for a geometry containing nodal points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triangulate0.2d(u0, edge)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triangulate0.2d_+3A_u0">u0</code></td>
<td>
<p>Matrix (2 x n) of node coordinates within the geometry.</p>
</td></tr>
<tr><td><code id="triangulate0.2d_+3A_edge">edge</code></td>
<td>
<p>Matrix (2 x n) of coordinate points on the perimeter of the geometry.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Produces data for generated mesh.
</p>
<table>
<tr><td><code>Meshpts</code></td>
<td>
<p>Includes both new mesh coordinate points and triangulation of points.</p>
</td></tr>
<tr><td><code>Centroids</code></td>
<td>
<p>Centroid positions for each triangle element.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(cleanpoly)
data(polyshape)

u0 = cleanpoly$CleanedNodes
edge = polyshape$Line

triMesh = triangulate0.2d(u0, edge)

</code></pre>

<hr>
<h2 id='triMesh'>Meshed coordinate points obtained from function: triangulate0</h2><span id='topic+triMesh'></span>

<h3>Description</h3>

<p>Meshed coordinate points obtained from function: triangulate0
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triMesh
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
