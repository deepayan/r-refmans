<!DOCTYPE html><html lang="en-GB"><head><title>Help for package moocore</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {moocore}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#moocore-package'><p>moocore: Core Mathematical Functions for Multi-Objective Optimization</p></a></li>
<li><a href='#as_double_matrix'><p>Convert input to a matrix with <code>"double"</code> storage mode (<code>base::storage.mode()</code>).</p></a></li>
<li><a href='#attsurf2df'><p>Convert a list of attainment surfaces to a single EAF <code>data.frame</code>.</p></a></li>
<li><a href='#choose_eafdiff'><p>Interactively choose according to empirical attainment function differences</p></a></li>
<li><a href='#compute_eaf_call'><p>Same as <code>eaf()</code> but performs no checks and does not transform the input or</p>
the output. This function should be used by other packages that want to
avoid redundant checks and transformations.</a></li>
<li><a href='#compute_eafdiff_call'><p>Same as <code>eafdiff()</code> but performs no checks and does not transform the input</p>
or the output. This function should be used by other packages that want to
avoid redundant checks and transformations.</a></li>
<li><a href='#CPFs'><p>Conditional Pareto fronts obtained from Gaussian processes simulations.</p></a></li>
<li><a href='#eaf'><p>Exact computation of the EAF in 2D or 3D</p></a></li>
<li><a href='#eaf_as_list'><p>Convert an EAF data frame to a list of data frames, where each element</p>
of the list is one attainment surface. The function <code>attsurf2df()</code> can be
used to convert the list into a single data frame.</a></li>
<li><a href='#eafdiff'><p>Compute empirical attainment function differences</p></a></li>
<li><a href='#epsilon'><p>Epsilon metric</p></a></li>
<li><a href='#hv_contributions'><p>Hypervolume contribution of a set of points</p></a></li>
<li><a href='#HybridGA'><p>Results of Hybrid GA on Vanzyl and Richmond water networks</p></a></li>
<li><a href='#hypervolume'><p>Hypervolume metric</p></a></li>
<li><a href='#igd'><p>Inverted Generational Distance (IGD and IGD+) and Averaged Hausdorff Distance</p></a></li>
<li><a href='#is_nondominated'><p>Identify, remove and rank dominated points according to Pareto optimality</p></a></li>
<li><a href='#largest_eafdiff'><p>Identify largest EAF differences</p></a></li>
<li><a href='#normalise'><p>Normalise points</p></a></li>
<li><a href='#rbind_datasets'><p>Combine datasets <code>x</code> and <code>y</code> by row taking care of making all sets unique.</p></a></li>
<li><a href='#read_datasets'><p>Read several data sets</p></a></li>
<li><a href='#SPEA2minstoptimeRichmond'><p>Results of SPEA2 when minimising electrical cost and maximising the</p>
minimum idle time of pumps on Richmond water network.</a></li>
<li><a href='#SPEA2relativeRichmond'><p>Results of SPEA2 with relative time-controlled triggers on Richmond water</p>
network.</a></li>
<li><a href='#SPEA2relativeVanzyl'><p>Results of SPEA2 with relative time-controlled triggers on Vanzyl's</p>
water network.</a></li>
<li><a href='#tpls50x20_1_MWT'><p>Various strategies of Two-Phase Local Search applied to the Permutation</p>
Flowshop Problem with Makespan and Weighted Tardiness objectives.</a></li>
<li><a href='#transform_maximise'><p>Transform matrix according to maximise parameter</p></a></li>
<li><a href='#vorobT'><p>Vorob'ev computations</p></a></li>
<li><a href='#whv_hype'><p>Approximation of the (weighted) hypervolume by Monte-Carlo sampling (2D only)</p></a></li>
<li><a href='#whv_rect'><p>Compute (total) weighted hypervolume given a set of rectangles</p></a></li>
<li><a href='#write_datasets'><p>Write data sets</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Core Mathematical Functions for Multi-Objective Optimization</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Fast implementation of mathematical operations and performance metrics for multi-objective optimization, including filtering and ranking of dominated vectors according to Pareto optimality, computation of the empirical attainment function, V.G. da Fonseca, C.M. Fonseca, A.O. Hall (2001) &lt;<a href="https://doi.org/10.1007%2F3-540-44719-9_15">doi:10.1007/3-540-44719-9_15</a>&gt;, hypervolume metric, C.M. Fonseca, L. Paquete, M. López-Ibáñez (2006) &lt;<a href="https://doi.org/10.1109%2FCEC.2006.1688440">doi:10.1109/CEC.2006.1688440</a>&gt;, epsilon indicator, inverted generational distance, and  Vorob'ev threshold, expectation and deviation, M. Binois, D. Ginsbourger, O. Roustant (2015) &lt;<a href="https://doi.org/10.1016%2Fj.ejor.2014.07.032">doi:10.1016/j.ejor.2014.07.032</a>&gt;, among others.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>matrixStats, Rdpack</td>
</tr>
<tr>
<td>Suggests:</td>
<td>doctest (&ge; 0.2.0), knitr, spelling, testthat (&ge; 3.0.0),
withr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-2">LGPL-2</a> | <a href="https://www.r-project.org/Licenses/LGPL-2.1">LGPL-2.1</a> | <a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a> [expanded from: LGPL (&ge; 2)]</td>
</tr>
<tr>
<td>Copyright:</td>
<td>file COPYRIGHTS</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/multi-objective/moocore/issues">https://github.com/multi-objective/moocore/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://multi-objective.github.io/moocore/r/">https://multi-objective.github.io/moocore/r/</a>,
<a href="https://github.com/multi-objective/moocore/tree/main/r">https://github.com/multi-objective/moocore/tree/main/r</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>true</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>rmarkdown, reshape2, ggplot2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-17 16:11:12 UTC; manu</td>
</tr>
<tr>
<td>Author:</td>
<td>Manuel López-Ibáñez
    <a href="https://orcid.org/0000-0001-9974-1295"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Carlos Fonseca [ctb],
  Luís Paquete [ctb],
  Andreia P. Guerreiro [ctb],
  Mickaël Binois [ctb],
  Michael H. Buselli [cph] (AVL-tree library),
  Wessel Dankers [cph] (AVL-tree library),
  NumPy Developers [cph] (RNG and ziggurat constants),
  Jean-Sebastien Roy [cph] (mt19937 library),
  Makoto Matsumoto [cph] (mt19937 library),
  Takuji Nishimura [cph] (mt19937 library)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Manuel López-Ibáñez &lt;manuel.lopez-ibanez@manchester.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-18 04:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='moocore-package'>moocore: Core Mathematical Functions for Multi-Objective Optimization</h2><span id='topic+moocore'></span><span id='topic+moocore-package'></span>

<h3>Description</h3>

<p>Fast implementation of mathematical operations and performance metrics for multi-objective optimization, including filtering and ranking of dominated vectors according to Pareto optimality, computation of the empirical attainment function, V.G. da Fonseca, C.M. Fonseca, A.O. Hall (2001) doi: <a href="https://doi.org/10.1007/3-540-44719-9_15">10.1007/3-540-44719-9_15</a>, hypervolume metric, C.M. Fonseca, L. Paquete, M. López-Ibáñez (2006) doi: <a href="https://doi.org/10.1109/CEC.2006.1688440">10.1109/CEC.2006.1688440</a>, epsilon indicator, inverted generational distance, and Vorob'ev threshold, expectation and deviation, M. Binois, D. Ginsbourger, O. Roustant (2015) doi: <a href="https://doi.org/10.1016/j.ejor.2014.07.032">10.1016/j.ejor.2014.07.032</a>, among others.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Manuel López-Ibáñez <a href="mailto:manuel.lopez-ibanez@manchester.ac.uk">manuel.lopez-ibanez@manchester.ac.uk</a> (<a href="https://orcid.org/0000-0001-9974-1295">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Carlos Fonseca [contributor]
</p>
</li>
<li><p> Luís Paquete [contributor]
</p>
</li>
<li><p> Andreia P. Guerreiro [contributor]
</p>
</li>
<li><p> Mickaël Binois [contributor]
</p>
</li>
<li><p> Michael H. Buselli (AVL-tree library) [copyright holder]
</p>
</li>
<li><p> Wessel Dankers (AVL-tree library) [copyright holder]
</p>
</li>
<li><p> NumPy Developers (RNG and ziggurat constants) [copyright holder]
</p>
</li>
<li><p> Jean-Sebastien Roy (mt19937 library) [copyright holder]
</p>
</li>
<li><p> Makoto Matsumoto (mt19937 library) [copyright holder]
</p>
</li>
<li><p> Takuji Nishimura (mt19937 library) [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://multi-objective.github.io/moocore/r/">https://multi-objective.github.io/moocore/r/</a>
</p>
</li>
<li> <p><a href="https://github.com/multi-objective/moocore/tree/main/r">https://github.com/multi-objective/moocore/tree/main/r</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/multi-objective/moocore/issues">https://github.com/multi-objective/moocore/issues</a>
</p>
</li></ul>


<hr>
<h2 id='as_double_matrix'>Convert input to a matrix with <code>"double"</code> storage mode (<code><a href="base.html#topic+mode">base::storage.mode()</a></code>).</h2><span id='topic+as_double_matrix'></span>

<h3>Description</h3>

<p>Convert input to a matrix with <code>"double"</code> storage mode (<code><a href="base.html#topic+mode">base::storage.mode()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_double_matrix(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_double_matrix_+3A_x">x</code></td>
<td>
<p><code>data.frame()</code>|<code>matrix()</code><br /> A numerical data frame or matrix with at least 1 row and 2 columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> is coerced to a numerical <code>matrix()</code>.
</p>

<hr>
<h2 id='attsurf2df'>Convert a list of attainment surfaces to a single EAF <code>data.frame</code>.</h2><span id='topic+attsurf2df'></span>

<h3>Description</h3>

<p>Convert a list of attainment surfaces to a single EAF <code>data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>attsurf2df(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="attsurf2df_+3A_x">x</code></td>
<td>
<p><code>list()</code><br /> List of <code>data.frames</code> or matrices. The names of the list
give the percentiles of the attainment surfaces.  This is the format
returned by <code><a href="#topic+eaf_as_list">eaf_as_list()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame()</code><br /> Data frame with as many columns as objectives and an additional column <code>percentiles</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eaf_as_list">eaf_as_list()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(SPEA2relativeRichmond)
attsurfs &lt;- eaf_as_list(eaf(SPEA2relativeRichmond, percentiles = c(0,50,100)))
str(attsurfs)
eaf_df &lt;- attsurf2df(attsurfs)
str(eaf_df)
</code></pre>

<hr>
<h2 id='choose_eafdiff'>Interactively choose according to empirical attainment function differences</h2><span id='topic+choose_eafdiff'></span>

<h3>Description</h3>

<p>Interactively choose according to empirical attainment function differences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>choose_eafdiff(x, left = stop("'left' must be either TRUE or FALSE"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="choose_eafdiff_+3A_x">x</code></td>
<td>
<p><code>matrix()</code><br /> Matrix of rectangles representing EAF differences
returned by <code><a href="#topic+eafdiff">eafdiff()</a></code> with <code>rectangles=TRUE</code>.</p>
</td></tr>
<tr><td><code id="choose_eafdiff_+3A_left">left</code></td>
<td>
<p><code>logical(1)</code><br /> With <code>left=TRUE</code> return the rectangles with
positive differences, otherwise return those with negative differences but
differences are converted to positive.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>matrix()</code> where the first 4 columns give the coordinates of two
corners of each rectangle and the last column. In both cases, the last
column gives the positive differences in favor of the chosen side.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
extdata_dir &lt;- system.file(package="moocore", "extdata")
A1 &lt;- read_datasets(file.path(extdata_dir, "wrots_l100w10_dat"))
A2 &lt;- read_datasets(file.path(extdata_dir, "wrots_l10w100_dat"))
# Choose A1
rectangles &lt;- eafdiff(A1, A2, intervals = 5, rectangles = TRUE)
rectangles &lt;- choose_eafdiff(rectangles, left = TRUE)
reference &lt;- c(max(A1[, 1], A2[, 1]), max(A1[, 2], A2[, 2]))
x &lt;- split.data.frame(A1[,1:2], A1[,3])
hv_A1 &lt;- sapply(split.data.frame(A1[, 1:2], A1[, 3]),
                 hypervolume, reference=reference)
hv_A2 &lt;- sapply(split.data.frame(A2[, 1:2], A2[, 3]),
                 hypervolume, reference=reference)
print(fivenum(hv_A1))
print(fivenum(hv_A2))
whv_A1 &lt;- sapply(split.data.frame(A1[, 1:2], A1[, 3]),
                 whv_rect, rectangles=rectangles, reference=reference)
whv_A2 &lt;- sapply(split.data.frame(A2[, 1:2], A2[, 3]),
                 whv_rect, rectangles=rectangles, reference=reference)
print(fivenum(whv_A1))
print(fivenum(whv_A2))


</code></pre>

<hr>
<h2 id='compute_eaf_call'>Same as <code><a href="#topic+eaf">eaf()</a></code> but performs no checks and does not transform the input or
the output. This function should be used by other packages that want to
avoid redundant checks and transformations.</h2><span id='topic+compute_eaf_call'></span>

<h3>Description</h3>

<p>Same as <code><a href="#topic+eaf">eaf()</a></code> but performs no checks and does not transform the input or
the output. This function should be used by other packages that want to
avoid redundant checks and transformations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_eaf_call(x, cumsizes, percentiles)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_eaf_call_+3A_x">x</code></td>
<td>
<p><code>matrix()</code>|<code>data.frame()</code><br /> Matrix or data frame of numerical
values, where each row gives the coordinates of a point. If <code>sets</code> is
missing, the last column of <code>x</code> gives the sets.</p>
</td></tr>
<tr><td><code id="compute_eaf_call_+3A_cumsizes">cumsizes</code></td>
<td>
<p><code>integer()</code><br /> Cumulative size of the different sets of points in <code>x</code>.</p>
</td></tr>
<tr><td><code id="compute_eaf_call_+3A_percentiles">percentiles</code></td>
<td>
<p><code>numeric()</code><br /> Vector indicating which percentiles are computed.
<code>NULL</code> computes all.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame()</code><br /> A data frame containing the exact representation of
EAF. The last column gives the percentile that corresponds to each
point. If groups is not <code>NULL</code>, then an additional column indicates to
which group the point belongs.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as_double_matrix">as_double_matrix()</a></code> <code><a href="#topic+transform_maximise">transform_maximise()</a></code>
</p>

<hr>
<h2 id='compute_eafdiff_call'>Same as <code><a href="#topic+eafdiff">eafdiff()</a></code> but performs no checks and does not transform the input
or the output. This function should be used by other packages that want to
avoid redundant checks and transformations.</h2><span id='topic+compute_eafdiff_call'></span>

<h3>Description</h3>

<p>Same as <code><a href="#topic+eafdiff">eafdiff()</a></code> but performs no checks and does not transform the input
or the output. This function should be used by other packages that want to
avoid redundant checks and transformations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_eafdiff_call(x, y, cumsizes_x, cumsizes_y, intervals, ret)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_eafdiff_call_+3A_x">x</code>, <code id="compute_eafdiff_call_+3A_y">y</code></td>
<td>
<p><code>matrix</code>|<code>data.frame()</code><br /> Data frames corresponding to the input data of
left and right sides, respectively. Each data frame has at least three
columns, the last one is the set of each point. See also
<code><a href="#topic+read_datasets">read_datasets()</a></code>.</p>
</td></tr>
<tr><td><code id="compute_eafdiff_call_+3A_cumsizes_x">cumsizes_x</code>, <code id="compute_eafdiff_call_+3A_cumsizes_y">cumsizes_y</code></td>
<td>
<p>Cumulative size of the different sets of points in <code>x</code> and <code>y</code>.</p>
</td></tr>
<tr><td><code id="compute_eafdiff_call_+3A_intervals">intervals</code></td>
<td>
<p><code>integer(1)</code><br /> The absolute range of the differences
<code class="reqn">[0, 1]</code> is partitioned into the number of intervals provided.</p>
</td></tr>
<tr><td><code id="compute_eafdiff_call_+3A_ret">ret</code></td>
<td>
<p>(<code>"points"|"rectangles"|"polygons"</code>)<br /> The format of the returned EAF differences.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>With <code>rectangle=FALSE</code>, a <code>data.frame</code> containing points where there
is a transition in the value of the EAF differences.  With
<code>rectangle=TRUE</code>, a <code>matrix</code> where the first 4 columns give the
coordinates of two corners of each rectangle. In both cases, the last
column gives the difference in terms of sets in <code>x</code> minus sets in <code>y</code> that
attain each point (i.e., negative values are differences in favour <code>y</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as_double_matrix">as_double_matrix()</a></code> <code><a href="#topic+transform_maximise">transform_maximise()</a></code>
</p>

<hr>
<h2 id='CPFs'>Conditional Pareto fronts obtained from Gaussian processes simulations.</h2><span id='topic+CPFs'></span>

<h3>Description</h3>

<p>The data has the only goal of providing an example of use of <code><a href="#topic+vorobT">vorobT()</a></code> and
<code><a href="#topic+vorobDev">vorobDev()</a></code>. It has been obtained by fitting two Gaussian processes on 20
observations of a bi-objective problem, before generating conditional
simulation of both GPs at different locations and extracting non-dominated
values of coupled simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CPFs
</code></pre>


<h3>Format</h3>

<p>A data frame with 2967 observations on the following 3 variables.
</p>

<dl>
<dt><code>f1</code></dt><dd><p>first objective values.</p>
</dd>
<dt><code>f2</code></dt><dd><p>second objective values.</p>
</dd>
<dt><code>set</code></dt><dd><p>indices of corresponding conditional Pareto fronts.</p>
</dd>
</dl>



<h3>Source</h3>

<p>M Binois, D Ginsbourger, O Roustant (2015).
&ldquo;Quantifying uncertainty on Pareto fronts with Gaussian process conditional simulations.&rdquo;
<em>European Journal of Operational Research</em>, <b>243</b>(2), 386&ndash;394.
doi: <a href="https://doi.org/10.1016/j.ejor.2014.07.032">10.1016/j.ejor.2014.07.032</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(CPFs)
vorobT(CPFs, reference = c(2, 200))
</code></pre>

<hr>
<h2 id='eaf'>Exact computation of the EAF in 2D or 3D</h2><span id='topic+eaf'></span>

<h3>Description</h3>

<p>This function computes the EAF given a set of 2D or 3D points and a vector <code>set</code>
that indicates to which set each point belongs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eaf(x, sets, percentiles = NULL, maximise = FALSE, groups = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eaf_+3A_x">x</code></td>
<td>
<p><code>matrix()</code>|<code>data.frame()</code><br /> Matrix or data frame of numerical
values, where each row gives the coordinates of a point. If <code>sets</code> is
missing, the last column of <code>x</code> gives the sets.</p>
</td></tr>
<tr><td><code id="eaf_+3A_sets">sets</code></td>
<td>
<p><code>integer()</code><br /> A vector that indicates the set of each point in <code>x</code>. If
missing, the last column of <code>x</code> is used instead.</p>
</td></tr>
<tr><td><code id="eaf_+3A_percentiles">percentiles</code></td>
<td>
<p><code>numeric()</code><br /> Vector indicating which percentiles are computed.
<code>NULL</code> computes all.</p>
</td></tr>
<tr><td><code id="eaf_+3A_maximise">maximise</code></td>
<td>
<p><code>logical()</code><br /> Whether the objectives must be maximised
instead of minimised. Either a single logical value that applies to all
objectives or a vector of logical values, with one value per objective.</p>
</td></tr>
<tr><td><code id="eaf_+3A_groups">groups</code></td>
<td>
<p><code>factor()</code><br /> Indicates that the EAF must be computed separately for data
belonging to different groups.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame()</code><br /> A data frame containing the exact representation of
EAF. The last column gives the percentile that corresponds to each
point. If groups is not <code>NULL</code>, then an additional column indicates to
which group the point belongs.
</p>


<h3>Note</h3>

<p>There are several examples of data sets in
<code>system.file(package="moocore","extdata")</code>.  The current implementation
only supports two and three dimensional points.
</p>


<h3>Author(s)</h3>

<p>Manuel López-Ibáñez
</p>


<h3>References</h3>

<p>Viviane Grunert da Fonseca, Carlos
M. Fonseca, Andreia
O. Hall (2001).
&ldquo;Inferential Performance Assessment of Stochastic Optimisers and the Attainment Function.&rdquo;
In Eckart Zitzler, Kalyanmoy Deb, Lothar Thiele, Carlos
A. Coello Coello, David Corne (eds.), <em> Evolutionary Multi-criterion Optimization, EMO 2001</em>, volume 1993 of <em>Lecture Notes in Computer Science</em>, 213&ndash;225.
Springer, Berlin~/ Heidelberg.
doi: <a href="https://doi.org/10.1007/3-540-44719-9_15">10.1007/3-540-44719-9_15</a>.
</p>
<p>Carlos
M. Fonseca, Andreia
P. Guerreiro, Manuel López-Ibáñez, Luís Paquete (2011).
&ldquo;On the Computation of the Empirical Attainment Function.&rdquo;
In R
H
C Takahashi, Kalyanmoy Deb, Elizabeth
F. Wanner, Salvatore Greco (eds.), <em> Evolutionary Multi-criterion Optimization, EMO 2011</em>, volume 6576 of <em>Lecture Notes in Computer Science</em>, 106&ndash;120.
Springer, Berlin~/ Heidelberg.
doi: <a href="https://doi.org/10.1007/978-3-642-19893-9_8">10.1007/978-3-642-19893-9_8</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_datasets">read_datasets()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>extdata_path &lt;- system.file(package="moocore", "extdata")

x &lt;- read_datasets(file.path(extdata_path, "example1_dat"))
# Compute full EAF (sets is the last column)
str(eaf(x))

# Compute only best, median and worst
str(eaf(x[,1:2], sets = x[,3], percentiles = c(0, 50, 100)))

x &lt;- read_datasets(file.path(extdata_path, "spherical-250-10-3d.txt"))
y &lt;- read_datasets(file.path(extdata_path, "uniform-250-10-3d.txt"))
x &lt;- rbind(data.frame(x, groups = "spherical"),
           data.frame(y, groups = "uniform"))
# Compute only median separately for each group
z &lt;- eaf(x[,1:3], sets = x[,4], groups = x[,5], percentiles = 50)
str(z)
</code></pre>

<hr>
<h2 id='eaf_as_list'>Convert an EAF data frame to a list of data frames, where each element
of the list is one attainment surface. The function <code><a href="#topic+attsurf2df">attsurf2df()</a></code> can be
used to convert the list into a single data frame.</h2><span id='topic+eaf_as_list'></span>

<h3>Description</h3>

<p>Convert an EAF data frame to a list of data frames, where each element
of the list is one attainment surface. The function <code><a href="#topic+attsurf2df">attsurf2df()</a></code> can be
used to convert the list into a single data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eaf_as_list(eaf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eaf_as_list_+3A_eaf">eaf</code></td>
<td>
<p><code>data.frame()</code>|<code>matrix()</code><br /> Data frame or matrix that represents the EAF.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list()</code><br /> A list of data frames. Each <code>data.frame</code> represents one attainment surface.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eaf">eaf()</a></code> <code><a href="#topic+attsurf2df">attsurf2df()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>extdata_path &lt;- system.file(package="moocore", "extdata")
x &lt;- read_datasets(file.path(extdata_path, "example1_dat"))
attsurfs &lt;- eaf_as_list(eaf(x, percentiles = c(0, 50, 100)))
str(attsurfs)
</code></pre>

<hr>
<h2 id='eafdiff'>Compute empirical attainment function differences</h2><span id='topic+eafdiff'></span>

<h3>Description</h3>

<p>Calculate the differences between the empirical attainment functions of two
data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eafdiff(x, y, intervals = NULL, maximise = FALSE, rectangles = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eafdiff_+3A_x">x</code>, <code id="eafdiff_+3A_y">y</code></td>
<td>
<p><code>matrix</code>|<code>data.frame()</code><br /> Data frames corresponding to the input data of
left and right sides, respectively. Each data frame has at least three
columns, the last one is the set of each point. See also
<code><a href="#topic+read_datasets">read_datasets()</a></code>.</p>
</td></tr>
<tr><td><code id="eafdiff_+3A_intervals">intervals</code></td>
<td>
<p><code>integer(1)</code><br /> The absolute range of the differences
<code class="reqn">[0, 1]</code> is partitioned into the number of intervals provided.</p>
</td></tr>
<tr><td><code id="eafdiff_+3A_maximise">maximise</code></td>
<td>
<p><code>logical()</code><br /> Whether the objectives must be maximised
instead of minimised. Either a single logical value that applies to all
objectives or a vector of logical values, with one value per objective.</p>
</td></tr>
<tr><td><code id="eafdiff_+3A_rectangles">rectangles</code></td>
<td>
<p><code>logical(1)</code><br /> If TRUE, the output is in the form of rectangles of the same color.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the differences between the EAFs of two
data sets.
</p>


<h3>Value</h3>

<p>With <code>rectangle=FALSE</code>, a <code>data.frame</code> containing points where there
is a transition in the value of the EAF differences.  With
<code>rectangle=TRUE</code>, a <code>matrix</code> where the first 4 columns give the
coordinates of two corners of each rectangle. In both cases, the last
column gives the difference in terms of sets in <code>x</code> minus sets in <code>y</code> that
attain each point (i.e., negative values are differences in favour <code>y</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_datasets">read_datasets()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A1 &lt;- read_datasets(text='
 3 2
 2 3

 2.5 1
 1 2

 1 2
')

A2 &lt;- read_datasets(text='
 4 2.5
 3 3
 2.5 3.5

 3 3
 2.5 3.5

 2 1
')
d &lt;- eafdiff(A1, A2)
str(d)
d









d &lt;- eafdiff(A1, A2, rectangles = TRUE)
str(d)
d











</code></pre>

<hr>
<h2 id='epsilon'>Epsilon metric</h2><span id='topic+epsilon'></span><span id='topic+epsilon_additive'></span><span id='topic+epsilon_mult'></span>

<h3>Description</h3>

<p>Computes the epsilon metric, either additive or multiplicative.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>epsilon_additive(x, reference, maximise = FALSE)

epsilon_mult(x, reference, maximise = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="epsilon_+3A_x">x</code></td>
<td>
<p><code>matrix()</code>|<code>data.frame()</code><br /> Matrix or data frame of numerical
values, where each row gives the coordinates of a point.</p>
</td></tr>
<tr><td><code id="epsilon_+3A_reference">reference</code></td>
<td>
<p><code>matrix</code>|<code>data.frame</code><br /> Reference set as a matrix or
data.frame of numerical values.</p>
</td></tr>
<tr><td><code id="epsilon_+3A_maximise">maximise</code></td>
<td>
<p><code>logical()</code><br /> Whether the objectives must be maximised
instead of minimised. Either a single logical value that applies to all
objectives or a vector of logical values, with one value per objective.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The epsilon metric of a set <code class="reqn">A</code> with respect to a reference set <code class="reqn">R</code>
is defined as
</p>
<p style="text-align: center;"><code class="reqn">epsilon(A,R) = \max_{r \in R} \min_{a \in A} \max_{1 \leq i \leq n} epsilon(a_i, r_i)</code>
</p>

<p>where <code class="reqn">a</code> and <code class="reqn">b</code> are objective vectors and, in the case of
minimization of objective <code class="reqn">i</code>, <code class="reqn">epsilon(a_i,b_i)</code> is computed as
<code class="reqn">a_i/b_i</code> for the multiplicative variant (respectively, <code class="reqn">a_i - b_i</code>
for the additive variant), whereas in the case of maximization of objective
<code class="reqn">i</code>, <code class="reqn">epsilon(a_i,b_i) = b_i/a_i</code> for the multiplicative variant
(respectively, <code class="reqn">b_i - a_i</code> for the additive variant). This allows
computing a single value for problems where some objectives are to be
maximized while others are to be minimized. Moreover, a lower value
corresponds to a better approximation set, independently of the type of
problem (minimization, maximization or mixed). However, the meaning of the
value is different for each objective type. For example, imagine that
objective 1 is to be minimized and objective 2 is to be maximized, and the
multiplicative epsilon computed here for <code class="reqn">epsilon(A,R) = 3</code>. This means
that <code class="reqn">A</code> needs to be multiplied by 1/3 for all <code class="reqn">a_1</code> values and by 3
for all <code class="reqn">a_2</code> values in order to weakly dominate <code class="reqn">R</code>. The
computation of the multiplicative version for negative values doesn't make
sense.
</p>
<p>Computation of the epsilon indicator requires <code class="reqn">O(n \cdot |A| \cdot
|R|)</code>, where <code class="reqn">n</code> is the number of objectives (dimension of vectors).
</p>


<h3>Value</h3>

<p><code>numeric(1)</code><br /> A single numerical value.
</p>


<h3>Author(s)</h3>

<p>Manuel López-Ibáñez
</p>


<h3>References</h3>

<p>Eckart Zitzler, Lothar Thiele, Marco Laumanns, Carlos
M. Fonseca, Viviane Grunert da Fonseca (2003).
&ldquo;Performance Assessment of Multiobjective Optimizers: an Analysis and Review.&rdquo;
<em>IEEE Transactions on Evolutionary Computation</em>, <b>7</b>(2), 117&ndash;132.
doi: <a href="https://doi.org/10.1109/TEVC.2003.810758">10.1109/TEVC.2003.810758</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Fig 6 from Zitzler et al. (2003).
A1 &lt;- matrix(c(9,2,8,4,7,5,5,6,4,7), ncol=2, byrow=TRUE)
A2 &lt;- matrix(c(8,4,7,5,5,6,4,7), ncol=2, byrow=TRUE)
A3 &lt;- matrix(c(10,4,9,5,8,6,7,7,6,8), ncol=2, byrow=TRUE)
if (requireNamespace("graphics", quietly = TRUE)) {
   plot(A1, xlab=expression(f[1]), ylab=expression(f[2]),
        panel.first=grid(nx=NULL), pch=4, cex=1.5, xlim = c(0,10), ylim=c(0,8))
   points(A2, pch=0, cex=1.5)
   points(A3, pch=1, cex=1.5)
   legend("bottomleft", legend=c("A1", "A2", "A3"), pch=c(4,0,1),
          pt.bg="gray", bg="white", bty = "n", pt.cex=1.5, cex=1.2)
}
epsilon_mult(A1, A3) # A1 epsilon-dominates A3 =&gt; e = 9/10 &lt; 1
epsilon_mult(A1, A2) # A1 weakly dominates A2 =&gt; e = 1
epsilon_mult(A2, A1) # A2 is epsilon-dominated by A1 =&gt; e = 2 &gt; 1

# A more realistic example
extdata_path &lt;- system.file(package="moocore","extdata")
path.A1 &lt;- file.path(extdata_path, "ALG_1_dat.xz")
path.A2 &lt;- file.path(extdata_path, "ALG_2_dat.xz")
A1 &lt;- read_datasets(path.A1)[,1:2]
A2 &lt;- read_datasets(path.A2)[,1:2]
ref &lt;- filter_dominated(rbind(A1, A2))
epsilon_additive(A1, ref)
epsilon_additive(A2, ref)
# Multiplicative version of epsilon metric
ref &lt;- filter_dominated(rbind(A1, A2))
epsilon_mult(A1, ref)
epsilon_mult(A2, ref)
</code></pre>

<hr>
<h2 id='hv_contributions'>Hypervolume contribution of a set of points</h2><span id='topic+hv_contributions'></span>

<h3>Description</h3>

<p>Computes the hypervolume contribution of each point given a set of points
with respect to a given reference point assuming minimization of all
objectives.  Dominated points have zero contribution. Duplicated points have
zero contribution even if not dominated, because removing one of them does
not change the hypervolume dominated by the remaining set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hv_contributions(x, reference, maximise = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hv_contributions_+3A_x">x</code></td>
<td>
<p><code>matrix()</code>|<code>data.frame()</code><br /> Matrix or data frame of numerical
values, where each row gives the coordinates of a point.</p>
</td></tr>
<tr><td><code id="hv_contributions_+3A_reference">reference</code></td>
<td>
<p><code>numeric()</code><br /> Reference point as a vector of numerical
values.</p>
</td></tr>
<tr><td><code id="hv_contributions_+3A_maximise">maximise</code></td>
<td>
<p><code>logical()</code><br /> Whether the objectives must be maximised
instead of minimised. Either a single logical value that applies to all
objectives or a vector of logical values, with one value per objective.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric()</code><br /> A numerical vector
</p>


<h3>Author(s)</h3>

<p>Manuel López-Ibáñez
</p>


<h3>References</h3>

<p>Carlos
M. Fonseca, Luís Paquete, Manuel López-Ibáñez (2006).
&ldquo;An improved dimension-sweep algorithm for the hypervolume indicator.&rdquo;
In <em>Proceedings of  the 2006 Congress on Evolutionary Computation (CEC 2006)</em>, 1157&ndash;1163.
doi: <a href="https://doi.org/10.1109/CEC.2006.1688440">10.1109/CEC.2006.1688440</a>.
</p>
<p>Nicola Beume, Carlos
M. Fonseca, Manuel López-Ibáñez, Luís Paquete, Jan Vahrenhold (2009).
&ldquo;On the complexity of computing the hypervolume indicator.&rdquo;
<em>IEEE Transactions on Evolutionary Computation</em>, <b>13</b>(5), 1075&ndash;1082.
doi: <a href="https://doi.org/10.1109/TEVC.2009.2015575">10.1109/TEVC.2009.2015575</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hypervolume">hypervolume()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(SPEA2minstoptimeRichmond)
# The second objective must be maximized
# We calculate the hypervolume contribution of each point of the union of all sets.
hv_contributions(SPEA2minstoptimeRichmond[, 1:2], reference = c(250, 0),
            maximise = c(FALSE, TRUE))

# Duplicated points show zero contribution above, even if not
# dominated. However, filter_dominated removes all duplicates except
# one. Hence, there are more points below with nonzero contribution.
hv_contributions(filter_dominated(SPEA2minstoptimeRichmond[, 1:2], maximise = c(FALSE, TRUE)),
                 reference = c(250, 0), maximise = c(FALSE, TRUE))

</code></pre>

<hr>
<h2 id='HybridGA'>Results of Hybrid GA on Vanzyl and Richmond water networks</h2><span id='topic+HybridGA'></span>

<h3>Description</h3>

<p>Results of Hybrid GA on Vanzyl and Richmond water networks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HybridGA
</code></pre>


<h3>Format</h3>

<p>A list with two data frames, each of them with three columns, as
produced by <code><a href="#topic+read_datasets">read_datasets()</a></code>.
</p>

<dl>
<dt><code style="white-space: pre;">&#8288;$vanzyl&#8288;</code></dt><dd><p>data frame of results on Vanzyl network</p>
</dd>
<dt><code style="white-space: pre;">&#8288;$richmond&#8288;</code></dt><dd><p>data frame of results on Richmond
network. The second column is filled with <code>NA</code></p>
</dd>
</dl>



<h3>Source</h3>

<p>Manuel López-Ibáñez (2009).
<em>Operational Optimisation of Water Distribution Networks</em>.
Ph.D. thesis, School of Engineering and the Built Environment, Edinburgh Napier University, UK.
<a href="https://lopez-ibanez.eu/publications#LopezIbanezPhD">https://lopez-ibanez.eu/publications#LopezIbanezPhD</a>..
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(HybridGA)
print(HybridGA$vanzyl)
print(HybridGA$richmond)
</code></pre>

<hr>
<h2 id='hypervolume'>Hypervolume metric</h2><span id='topic+hypervolume'></span>

<h3>Description</h3>

<p>Compute the hypervolume metric with respect to a given reference point
assuming minimization of all objectives. For 2D and 3D, the algorithm used
(Fonseca et al. 2006; Beume et al. 2009) has <code class="reqn">O(n \log n)</code>
complexity. For 4D or higher, the algorithm (Fonseca et al. 2006)
has <code class="reqn">O(n^{d-2} \log n)</code> time and linear space complexity in the
worst-case, but experimental results show that the pruning techniques used
may reduce the time complexity even further.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hypervolume(x, reference, maximise = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hypervolume_+3A_x">x</code></td>
<td>
<p><code>matrix()</code>|<code>data.frame()</code><br /> Matrix or data frame of numerical
values, where each row gives the coordinates of a point.</p>
</td></tr>
<tr><td><code id="hypervolume_+3A_reference">reference</code></td>
<td>
<p><code>numeric()</code><br /> Reference point as a vector of numerical
values.</p>
</td></tr>
<tr><td><code id="hypervolume_+3A_maximise">maximise</code></td>
<td>
<p><code>logical()</code><br /> Whether the objectives must be maximised
instead of minimised. Either a single logical value that applies to all
objectives or a vector of logical values, with one value per objective.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric(1)</code><br /> A single numerical value.
</p>


<h3>Author(s)</h3>

<p>Manuel López-Ibáñez
</p>


<h3>References</h3>

<p>Nicola Beume, Carlos
M. Fonseca, Manuel López-Ibáñez, Luís Paquete, Jan Vahrenhold (2009).
&ldquo;On the complexity of computing the hypervolume indicator.&rdquo;
<em>IEEE Transactions on Evolutionary Computation</em>, <b>13</b>(5), 1075&ndash;1082.
doi: <a href="https://doi.org/10.1109/TEVC.2009.2015575">10.1109/TEVC.2009.2015575</a>.<br /><br /> Carlos
M. Fonseca, Luís Paquete, Manuel López-Ibáñez (2006).
&ldquo;An improved dimension-sweep algorithm for the hypervolume indicator.&rdquo;
In <em>Proceedings of  the 2006 Congress on Evolutionary Computation (CEC 2006)</em>, 1157&ndash;1163.
doi: <a href="https://doi.org/10.1109/CEC.2006.1688440">10.1109/CEC.2006.1688440</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(SPEA2minstoptimeRichmond)
# The second objective must be maximized
# We calculate the hypervolume of the union of all sets.
hypervolume(SPEA2minstoptimeRichmond[, 1:2], reference = c(250, 0),
            maximise = c(FALSE, TRUE))

</code></pre>

<hr>
<h2 id='igd'>Inverted Generational Distance (IGD and IGD+) and Averaged Hausdorff Distance</h2><span id='topic+igd'></span><span id='topic+IGDX'></span><span id='topic+igd_plus'></span><span id='topic+avg_hausdorff_dist'></span>

<h3>Description</h3>

<p>Functions to compute the inverted generational distance (IGD and IGD+) and
the averaged Hausdorff distance between nondominated sets of points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>igd(x, reference, maximise = FALSE)

igd_plus(x, reference, maximise = FALSE)

avg_hausdorff_dist(x, reference, maximise = FALSE, p = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="igd_+3A_x">x</code></td>
<td>
<p><code>matrix()</code>|<code>data.frame()</code><br /> Matrix or data frame of numerical
values, where each row gives the coordinates of a point.</p>
</td></tr>
<tr><td><code id="igd_+3A_reference">reference</code></td>
<td>
<p><code>matrix</code>|<code>data.frame</code><br /> Reference set as a matrix or
data.frame of numerical values.</p>
</td></tr>
<tr><td><code id="igd_+3A_maximise">maximise</code></td>
<td>
<p><code>logical()</code><br /> Whether the objectives must be maximised
instead of minimised. Either a single logical value that applies to all
objectives or a vector of logical values, with one value per objective.</p>
</td></tr>
<tr><td><code id="igd_+3A_p">p</code></td>
<td>
<p><code>integer(1)</code><br /> Hausdorff distance parameter (default: <code>1L</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generational distance (GD) of a set <code class="reqn">A</code> is defined as the distance
between each point <code class="reqn">a \in A</code> and the closest point <code class="reqn">r</code> in a
reference set <code class="reqn">R</code>, averaged over the size of <code class="reqn">A</code>. Formally,
</p>
<p style="text-align: center;"><code class="reqn">GD_p(A,R) = \left(\frac{1}{|A|}\sum_{a\in A}\min_{r\in R} d(a,r)^p\right)^{\frac{1}{p}} </code>
</p>

<p>where the distance in our implementation is the Euclidean distance:
</p>
<p style="text-align: center;"><code class="reqn">d(a,r) = \sqrt{\sum_{k=1}^M (a_k - r_k)^2} </code>
</p>

<p>The inverted generational distance (IGD) is calculated as <code class="reqn">IGD_p(A,R) = GD_p(R,A)</code>.
</p>
<p>The modified inverted generational distanced (IGD+) was proposed by
Ishibuchi et al. (2015) to ensure that IGD+ is weakly Pareto compliant,
similarly to <code><a href="#topic+epsilon_additive">epsilon_additive()</a></code> or <code><a href="#topic+epsilon_mult">epsilon_mult()</a></code>. It modifies the
distance measure as:
</p>
<p style="text-align: center;"><code class="reqn">d^+(r,a) = \sqrt{\sum_{k=1}^M (\max\{r_k - a_k, 0\})^2}</code>
</p>

<p>The average Hausdorff distance (<code class="reqn">\Delta_p</code>) was proposed by
Schütze et al. (2012) and it is calculated as:
</p>
<p style="text-align: center;"><code class="reqn">\Delta_p(A,R) = \max\{ IGD_p(A,R), IGD_p(R,A) \}</code>
</p>

<p>IGDX (Zhou et al. 2009) is the application of IGD to decision vectors
instead of objective vectors to measure closeness and diversity in decision
space. One can use the functions <code>igd()</code> or <code>igd_plus()</code> (recommended)
directly, just passing the decision vectors as <code>data</code>.
</p>
<p>There are different formulations of the GD and IGD metrics in the literature
that differ on the value of <code class="reqn">p</code>, on the distance metric used and on
whether the term <code class="reqn">|A|^{-1}</code> is inside (as above) or outside the exponent
<code class="reqn">1/p</code>.  GD was first proposed by Van Veldhuizen and Lamont (1998) with <code class="reqn">p=2</code> and
the term <code class="reqn">|A|^{-1}</code> outside the exponent. IGD seems to have been
mentioned first by Coello Coello and Reyes-Sierra (2004), however, some people also used the
name D-metric for the same concept with <code class="reqn">p=1</code> and later papers have
often used IGD/GD with <code class="reqn">p=1</code>. Schütze et al. (2012) proposed to
place the term <code class="reqn">|A|^{-1}</code> inside the exponent, as in the formulation
shown above.  This has a significant effect for GD and less so for IGD given
a constant reference set. IGD+ also follows this formulation.  We refer to
Ishibuchi et al. (2015) and Bezerra et al. (2017) for a more detailed
historical perspective and a comparison of the various variants.
</p>
<p>Following Ishibuchi et al. (2015), we always use <code class="reqn">p=1</code> in our
implementation of IGD and IGD+ because (1) it is the setting most used in
recent works; (2) it makes irrelevant whether the term <code class="reqn">|A|^{-1}</code> is
inside or outside the exponent <code class="reqn">1/p</code>; and (3) the meaning of IGD becomes
the average Euclidean distance from each reference point to its nearest
objective vector. It is also slightly faster to compute.
</p>
<p>GD should never be used directly to compare the quality of approximations to
a Pareto front, as it often contradicts Pareto optimality (it is not weakly
Pareto-compliant). We recommend IGD+ instead of IGD, since the latter
contradicts Pareto optimality in some cases (see examples below) whereas
IGD+ is weakly Pareto-compliant, but we implement IGD here because it is
still popular due to historical reasons.
</p>
<p>The average Hausdorff distance (<code class="reqn">\Delta_p(A,R)</code>) is also not weakly
Pareto-compliant, as shown in the examples below.
</p>


<h3>Value</h3>

<p><code>numeric(1)</code><br /> A single numerical value.
</p>


<h3>Author(s)</h3>

<p>Manuel López-Ibáñez
</p>


<h3>References</h3>

<p>Leonardo
C.
T. Bezerra, Manuel López-Ibáñez, Thomas Stützle (2017).
&ldquo;An Empirical Assessment of the Properties of Inverted Generational Distance Indicators on Multi- and Many-objective Optimization.&rdquo;
In Heike Trautmann, Günter Rudolph, Kathrin Klamroth, Oliver Schütze, Margaret
M. Wiecek, Yaochu Jin, Christian Grimme (eds.), <em> Evolutionary Multi-criterion Optimization, EMO 2017</em>, volume 10173 of <em>Lecture Notes in Computer Science</em>, 31&ndash;45.
Springer International Publishing,  Cham, Switzerland.
doi: <a href="https://doi.org/10.1007/978-3-319-54157-0_3">10.1007/978-3-319-54157-0_3</a>.<br /><br /> Carlos
A. Coello Coello, Margarita Reyes-Sierra (2004).
&ldquo;A Study of the Parallelization of a Coevolutionary Multi-objective Evolutionary Algorithm.&rdquo;
In Raúl Monroy, Gustavo Arroyo-Figueroa, Luis
Enrique Sucar, Humberto Sossa (eds.), <em>Proceedings of MICAI</em>, volume 2972 of <em>Lecture Notes in Artificial Intelligence</em>, 688&ndash;697.
Springer,  Heidelberg, Germany.<br /><br /> Hisao Ishibuchi, Hiroyuki Masuda, Yuki Tanigaki, Yusuke Nojima (2015).
&ldquo;Modified Distance Calculation in Generational Distance and Inverted Generational Distance.&rdquo;
In António Gaspar-Cunha, Carlos
Henggeler Antunes, Carlos
A. Coello Coello (eds.), <em> Evolutionary Multi-criterion Optimization, EMO 2015 Part I</em>, volume 9018 of <em>Lecture Notes in Computer Science</em>, 110&ndash;125.
Springer,  Heidelberg, Germany.<br /><br /> Oliver Schütze, X Esquivel, A Lara, Carlos
A. Coello Coello (2012).
&ldquo;Using the Averaged Hausdorff Distance as a Performance Measure in Evolutionary Multiobjective Optimization.&rdquo;
<em>IEEE Transactions on Evolutionary Computation</em>, <b>16</b>(4), 504&ndash;522.<br /><br /> David
A. Van Veldhuizen, Gary
B. Lamont (1998).
&ldquo;Evolutionary Computation and Convergence to a Pareto Front.&rdquo;
In John
R. Koza (ed.), <em>Late Breaking Papers at the Genetic Programming 1998 Conference</em>, 221&ndash;228.<br /><br /> A Zhou, Qingfu Zhang, Yaochu Jin (2009).
&ldquo;Approximating the set of Pareto-optimal solutions in both the decision and objective spaces by an estimation of distribution algorithm.&rdquo;
<em>IEEE Transactions on Evolutionary Computation</em>, <b>13</b>(5), 1167&ndash;1189.
doi: <a href="https://doi.org/10.1109/TEVC.2009.2021467">10.1109/TEVC.2009.2021467</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 4 from Ishibuchi et al. (2015)
ref &lt;- matrix(c(10,0,6,1,2,2,1,6,0,10), ncol=2, byrow=TRUE)
A &lt;- matrix(c(4,2,3,3,2,4), ncol=2, byrow=TRUE)
B &lt;- matrix(c(8,2,4,4,2,8), ncol=2, byrow=TRUE)
if (requireNamespace("graphics", quietly = TRUE)) {
   plot(ref, xlab=expression(f[1]), ylab=expression(f[2]),
        panel.first=grid(nx=NULL), pch=23, bg="gray", cex=1.5)
   points(A, pch=1, cex=1.5)
   points(B, pch=19, cex=1.5)
   legend("topright", legend=c("Reference", "A", "B"), pch=c(23,1,19),
          pt.bg="gray", bg="white", bty = "n", pt.cex=1.5, cex=1.2)
}
cat("A is better than B in terms of Pareto optimality,\n however, IGD(A)=",
    igd(A, ref), "&gt; IGD(B)=", igd(B, ref),
    "and AvgHausdorff(A)=", avg_hausdorff_dist(A, ref),
    "&gt; AvgHausdorff(A)=", avg_hausdorff_dist(B, ref),
    ", which both contradict Pareto optimality.\nBy contrast, IGD+(A)=",
    igd_plus(A, ref), "&lt; IGD+(B)=", igd_plus(B, ref), ", which is correct.\n")
# A less trivial example.
extdata_path &lt;- system.file(package="moocore","extdata")
path.A1 &lt;- file.path(extdata_path, "ALG_1_dat.xz")
path.A2 &lt;- file.path(extdata_path, "ALG_2_dat.xz")
A1 &lt;- read_datasets(path.A1)[,1:2]
A2 &lt;- read_datasets(path.A2)[,1:2]
ref &lt;- filter_dominated(rbind(A1, A2))
igd(A1, ref)
igd(A2, ref)

# IGD+ (Pareto compliant)
igd_plus(A1, ref)
igd_plus(A2, ref)

# Average Haussdorff distance
avg_hausdorff_dist(A1, ref)
avg_hausdorff_dist(A2, ref)
</code></pre>

<hr>
<h2 id='is_nondominated'>Identify, remove and rank dominated points according to Pareto optimality</h2><span id='topic+is_nondominated'></span><span id='topic+filter_dominated'></span><span id='topic+pareto_rank'></span>

<h3>Description</h3>

<p>Identify nondominated points with <code>is_nondominated()</code> and remove dominated
ones with <code>filter_dominated()</code>.
</p>
<p><code>pareto_rank()</code> ranks points according to Pareto-optimality,
which is also called nondominated sorting (Deb et al. 2002).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_nondominated(x, maximise = FALSE, keep_weakly = FALSE)

filter_dominated(x, maximise = FALSE, keep_weakly = FALSE)

pareto_rank(x, maximise = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_nondominated_+3A_x">x</code></td>
<td>
<p><code>matrix()</code>|<code>data.frame()</code><br /> Matrix or data frame of numerical
values, where each row gives the coordinates of a point.</p>
</td></tr>
<tr><td><code id="is_nondominated_+3A_maximise">maximise</code></td>
<td>
<p><code>logical()</code><br /> Whether the objectives must be maximised
instead of minimised. Either a single logical value that applies to all
objectives or a vector of logical values, with one value per objective.</p>
</td></tr>
<tr><td><code id="is_nondominated_+3A_keep_weakly">keep_weakly</code></td>
<td>
<p>If <code>FALSE</code>, return <code>FALSE</code> for any duplicates
of nondominated points.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pareto_rank()</code> is meant to be used like <code>rank()</code>, but it
assigns ranks according to Pareto dominance. Duplicated points are kept on
the same front. When <code>ncol(data) == 2</code>, the code uses the <code class="reqn">O(n
  \log n)</code> algorithm by Jensen (2003).
</p>


<h3>Value</h3>

<p><code><a href="#topic+is_nondominated">is_nondominated()</a></code> returns a logical vector of the same length
as the number of rows of <code>data</code>, where <code>TRUE</code> means that the
point is not dominated by any other point.
</p>
<p><code>filter_dominated</code> returns a matrix or data.frame with only mutually nondominated points.
</p>
<p><code>pareto_rank()</code> returns an integer vector of the same length as
the number of rows of <code>data</code>, where each value gives the rank of each
point.
</p>


<h3>Author(s)</h3>

<p>Manuel López-Ibáñez
</p>


<h3>References</h3>

<p>Kalyanmoy Deb, A Pratap, S Agarwal, T Meyarivan (2002).
&ldquo;A fast and elitist multi-objective genetic algorithm: NSGA-II.&rdquo;
<em>IEEE Transactions on Evolutionary Computation</em>, <b>6</b>(2), 182&ndash;197.
doi: <a href="https://doi.org/10.1109/4235.996017">10.1109/4235.996017</a>.<br /><br /> M
T Jensen (2003).
&ldquo;Reducing the run-time complexity of multiobjective EAs: The NSGA-II and other algorithms.&rdquo;
<em>IEEE Transactions on Evolutionary Computation</em>, <b>7</b>(5), 503&ndash;515.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>S = matrix(c(1,1,0,1,1,0,1,0), ncol = 2, byrow = TRUE)
is_nondominated(S)

is_nondominated(S, maximise = TRUE)

filter_dominated(S)

filter_dominated(S, keep_weakly = TRUE)

path_A1 &lt;- file.path(system.file(package="moocore"),"extdata","ALG_1_dat.xz")
set &lt;- read_datasets(path_A1)[,1:2]
is_nondom &lt;- is_nondominated(set)
cat("There are ", sum(is_nondom), " nondominated points\n")

if (requireNamespace("graphics", quietly = TRUE)) {
   plot(set, col = "blue", type = "p", pch = 20)
   ndset &lt;- filter_dominated(set)
   points(ndset[order(ndset[,1]),], col = "red", pch = 21)
}

ranks &lt;- pareto_rank(set)
str(ranks)
if (requireNamespace("graphics", quietly = TRUE)) {
   colors &lt;- colorRampPalette(c("red","yellow","springgreen","royalblue"))(max(ranks))
   plot(set, col = colors[ranks], type = "p", pch = 20)
}
</code></pre>

<hr>
<h2 id='largest_eafdiff'>Identify largest EAF differences</h2><span id='topic+largest_eafdiff'></span>

<h3>Description</h3>

<p>Given a list of datasets, return the indexes of the pair with the largest
EAF differences according to the method proposed by Diaz and López-Ibáñez (2021).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>largest_eafdiff(x, maximise = FALSE, intervals = 5L, reference, ideal = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="largest_eafdiff_+3A_x">x</code></td>
<td>
<p><code>list()</code><br /> A list of matrices or data frames with at least 3 columns (last column indicates the set).</p>
</td></tr>
<tr><td><code id="largest_eafdiff_+3A_maximise">maximise</code></td>
<td>
<p><code>logical()</code><br /> Whether the objectives must be maximised
instead of minimised. Either a single logical value that applies to all
objectives or a vector of logical values, with one value per objective.</p>
</td></tr>
<tr><td><code id="largest_eafdiff_+3A_intervals">intervals</code></td>
<td>
<p><code>integer(1)</code><br /> The absolute range of the differences
<code class="reqn">[0, 1]</code> is partitioned into the number of intervals provided.</p>
</td></tr>
<tr><td><code id="largest_eafdiff_+3A_reference">reference</code></td>
<td>
<p><code>numeric()</code><br /> Reference point as a vector of numerical
values.</p>
</td></tr>
<tr><td><code id="largest_eafdiff_+3A_ideal">ideal</code></td>
<td>
<p><code>numeric()</code><br /> Ideal point as a vector of numerical values.  If
<code>NULL</code>, it is calculated as minimum (or maximum if maximising that
objective) of each objective in the input data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list()</code><br /> A list with two components <code>pair</code> and <code>value</code>.
</p>


<h3>References</h3>

<p>Juan
Esteban Diaz, Manuel López-Ibáñez (2021).
&ldquo;Incorporating Decision-Maker's Preferences into the Automatic Configuration of Bi-Objective Optimisation Algorithms.&rdquo;
<em>European Journal of Operational Research</em>, <b>289</b>(3), 1209&ndash;1222.
doi: <a href="https://doi.org/10.1016/j.ejor.2020.07.059">10.1016/j.ejor.2020.07.059</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># FIXME: This example is too large, we need a smaller one.
data(tpls50x20_1_MWT)
nadir &lt;- apply(tpls50x20_1_MWT[,2:3], 2L, max)
x &lt;- largest_eafdiff(split.data.frame(tpls50x20_1_MWT[,2:4], tpls50x20_1_MWT[, 1L]),
                     reference = nadir)
str(x)

</code></pre>

<hr>
<h2 id='normalise'>Normalise points</h2><span id='topic+normalise'></span>

<h3>Description</h3>

<p>Normalise points per coordinate to a range, e.g., <code>c(1,2)</code>, where the
minimum value will correspond to 1 and the maximum to 2. If bounds are
given, they are used for the normalisation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalise(x, to_range = c(1, 2), lower = NA, upper = NA, maximise = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normalise_+3A_x">x</code></td>
<td>
<p><code>matrix()</code>|<code>data.frame()</code><br /> Matrix or data frame of numerical
values, where each row gives the coordinates of a point.</p>
</td></tr>
<tr><td><code id="normalise_+3A_to_range">to_range</code></td>
<td>
<p><code>numerical(2)</code><br /> Normalise values to this range. If the objective is
maximised, it is normalised to <code>c(to_range[1], to_range[0])</code>
instead.</p>
</td></tr>
<tr><td><code id="normalise_+3A_lower">lower</code>, <code id="normalise_+3A_upper">upper</code></td>
<td>
<p><code>numerical()</code><br /> Bounds on the values. If <code>NA</code>, the maximum and minimum
values of each coordinate are used.</p>
</td></tr>
<tr><td><code id="normalise_+3A_maximise">maximise</code></td>
<td>
<p><code>logical()</code><br /> Whether the objectives must be maximised
instead of minimised. Either a single logical value that applies to all
objectives or a vector of logical values, with one value per objective.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>matrix()</code><br /> A numerical matrix
</p>


<h3>Author(s)</h3>

<p>Manuel López-Ibáñez
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(SPEA2minstoptimeRichmond)
# The second objective must be maximized
head(SPEA2minstoptimeRichmond[, 1:2])

head(normalise(SPEA2minstoptimeRichmond[, 1:2], maximise = c(FALSE, TRUE)))

head(normalise(SPEA2minstoptimeRichmond[, 1:2], to_range = c(0,1), maximise = c(FALSE, TRUE)))

</code></pre>

<hr>
<h2 id='rbind_datasets'>Combine datasets <code>x</code> and <code>y</code> by row taking care of making all sets unique.</h2><span id='topic+rbind_datasets'></span>

<h3>Description</h3>

<p>Combine datasets <code>x</code> and <code>y</code> by row taking care of making all sets unique.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbind_datasets(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rbind_datasets_+3A_x">x</code>, <code id="rbind_datasets_+3A_y">y</code></td>
<td>
<p><code>matrix</code>|<code>data.frame()</code><br /> Each dataset has at least three
columns, the last one is the set of each point. See also
<code><a href="#topic+read_datasets">read_datasets()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;matrix()|&#8288;</code>data.frame()'<br /> A dataset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(f1 = 5:10, f2 = 10:5, set = 1:6)
y &lt;- data.frame(f1 = 15:20, f2 = 20:15, set = 1:6)
rbind_datasets(x,y)
</code></pre>

<hr>
<h2 id='read_datasets'>Read several data sets</h2><span id='topic+read_datasets'></span>

<h3>Description</h3>

<p>Reads a text file in table format and creates a matrix from it. The file
may contain several sets, separated by empty lines. Lines starting by
<code>'#'</code> are considered comments and treated as empty lines. The function
adds an additional column <code>set</code> to indicate to which set each row
belongs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_datasets(file, col_names, text)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_datasets_+3A_file">file</code></td>
<td>
<p><code>character()</code><br /> Filename that contains the data.  Each row
of the table appears as one line of the file.  If it does not contain an
<em>absolute</em> path, the file name is <em>relative</em> to the current
working directory, <code><a href="base.html#topic+getwd">base::getwd()</a></code>.  Tilde-expansion is
performed where supported.  Files compressed with <code>xz</code> are supported.</p>
</td></tr>
<tr><td><code id="read_datasets_+3A_col_names">col_names</code></td>
<td>
<p><code>character()</code><br /> Vector of optional names for the variables.  The
default is to use &lsquo;<span class="samp">&#8288;"V"&#8288;</span>&rsquo; followed by the column number.</p>
</td></tr>
<tr><td><code id="read_datasets_+3A_text">text</code></td>
<td>
<p><code>character()</code><br /> If <code>file</code> is not supplied and this is,
then data are read from the value of <code>text</code> via a text connection.
Notice that a literal string can be used to include (small) data sets
within R code.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>matrix()</code><br /> A numerical matrix of the
data in the file. An extra column <code>set</code> is added to indicate to
which set each row belongs.
</p>


<h3>Warning</h3>

<p>A known limitation is that the input file must use newline characters
native to the host system, otherwise they will be, possibly silently,
misinterpreted. In GNU/Linux the program <code>dos2unix</code> may be used
to fix newline characters.
</p>


<h3>Note</h3>

<p>There are several examples of data sets in
<code>system.file(package="moocore","extdata")</code>.
</p>


<h3>Author(s)</h3>

<p>Manuel López-Ibáñez
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+read.table">utils::read.table()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>extdata_path &lt;- system.file(package="moocore","extdata")
A1 &lt;- read_datasets(file.path(extdata_path,"ALG_1_dat.xz"))
str(A1)

read_datasets(text="1 2\n3 4\n\n5 6\n7 8\n", col_names=c("obj1", "obj2"))

</code></pre>

<hr>
<h2 id='SPEA2minstoptimeRichmond'>Results of SPEA2 when minimising electrical cost and maximising the
minimum idle time of pumps on Richmond water network.</h2><span id='topic+SPEA2minstoptimeRichmond'></span>

<h3>Description</h3>

<p>Results of SPEA2 when minimising electrical cost and maximising the
minimum idle time of pumps on Richmond water network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SPEA2minstoptimeRichmond
</code></pre>


<h3>Format</h3>

<p>A data frame as produced by <code><a href="#topic+read_datasets">read_datasets()</a></code>. The second
column measures time in seconds and corresponds to a maximisation problem.
</p>


<h3>Source</h3>

<p>Manuel López-Ibáñez (2009).
<em>Operational Optimisation of Water Distribution Networks</em>.
Ph.D. thesis, School of Engineering and the Built Environment, Edinburgh Napier University, UK.
<a href="https://lopez-ibanez.eu/publications#LopezIbanezPhD">https://lopez-ibanez.eu/publications#LopezIbanezPhD</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(SPEA2minstoptimeRichmond)
str(SPEA2minstoptimeRichmond)
</code></pre>

<hr>
<h2 id='SPEA2relativeRichmond'>Results of SPEA2 with relative time-controlled triggers on Richmond water
network.</h2><span id='topic+SPEA2relativeRichmond'></span>

<h3>Description</h3>

<p>Results of SPEA2 with relative time-controlled triggers on Richmond water
network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SPEA2relativeRichmond
</code></pre>


<h3>Format</h3>

<p>A data frame as produced by <code><a href="#topic+read_datasets">read_datasets()</a></code>.
</p>


<h3>Source</h3>

<p>Manuel López-Ibáñez (2009).
<em>Operational Optimisation of Water Distribution Networks</em>.
Ph.D. thesis, School of Engineering and the Built Environment, Edinburgh Napier University, UK.
<a href="https://lopez-ibanez.eu/publications#LopezIbanezPhD">https://lopez-ibanez.eu/publications#LopezIbanezPhD</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(SPEA2relativeRichmond)
str(SPEA2relativeRichmond)
</code></pre>

<hr>
<h2 id='SPEA2relativeVanzyl'>Results of SPEA2 with relative time-controlled triggers on Vanzyl's
water network.</h2><span id='topic+SPEA2relativeVanzyl'></span>

<h3>Description</h3>

<p>Results of SPEA2 with relative time-controlled triggers on Vanzyl's
water network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SPEA2relativeVanzyl
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 107 rows and 3 columns.
</p>


<h3>Source</h3>

<p>Manuel López-Ibáñez (2009).
<em>Operational Optimisation of Water Distribution Networks</em>.
Ph.D. thesis, School of Engineering and the Built Environment, Edinburgh Napier University, UK.
<a href="https://lopez-ibanez.eu/publications#LopezIbanezPhD">https://lopez-ibanez.eu/publications#LopezIbanezPhD</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(SPEA2relativeVanzyl)
str(SPEA2relativeVanzyl)
</code></pre>

<hr>
<h2 id='tpls50x20_1_MWT'>Various strategies of Two-Phase Local Search applied to the Permutation
Flowshop Problem with Makespan and Weighted Tardiness objectives.</h2><span id='topic+tpls50x20_1_MWT'></span>

<h3>Description</h3>

<p>Various strategies of Two-Phase Local Search applied to the Permutation
Flowshop Problem with Makespan and Weighted Tardiness objectives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tpls50x20_1_MWT
</code></pre>


<h3>Format</h3>

<p>A data frame with 1511 observations of  4 variables:
</p>

<dl>
<dt><code>algorithm</code></dt><dd><p>TPLS search strategy</p>
</dd>
<dt><code>Makespan</code></dt><dd><p>first objective values.</p>
</dd>
<dt><code>WeightedTardiness</code></dt><dd><p>second objective values.</p>
</dd>
<dt><code>set</code></dt><dd><p>indices of corresponding conditional Pareto fronts.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Jérémie Dubois-Lacoste, Manuel López-Ibáñez, Thomas Stützle (2011).
&ldquo;Improving the Anytime Behavior of Two-Phase Local Search.&rdquo;
<em>Annals of Mathematics and Artificial Intelligence</em>, <b>61</b>(2), 125&ndash;154.
doi: <a href="https://doi.org/10.1007/s10472-011-9235-0">10.1007/s10472-011-9235-0</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tpls50x20_1_MWT)
str(tpls50x20_1_MWT)
</code></pre>

<hr>
<h2 id='transform_maximise'>Transform matrix according to maximise parameter</h2><span id='topic+transform_maximise'></span>

<h3>Description</h3>

<p>Transform matrix according to maximise parameter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_maximise(x, maximise)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transform_maximise_+3A_x">x</code></td>
<td>
<p><code>matrix()</code>|<code>data.frame()</code><br /> Matrix or data frame of numerical
values, where each row gives the coordinates of a point.</p>
</td></tr>
<tr><td><code id="transform_maximise_+3A_maximise">maximise</code></td>
<td>
<p><code>logical()</code><br /> Whether the objectives must be maximised
instead of minimised. Either a single logical value that applies to all
objectives or a vector of logical values, with one value per objective.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> transformed such that every column where <code>maximise</code> is <code>TRUE</code> is multiplied by <code>-1</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(f1=1:10, f2=101:110)
rownames(x) &lt;- letters[1:10]
transform_maximise(x, maximise=c(FALSE,TRUE))
transform_maximise(x, maximise=TRUE)
x &lt;- as.matrix(x)
transform_maximise(x, maximise=c(FALSE,TRUE))
transform_maximise(x, maximise=TRUE)

</code></pre>

<hr>
<h2 id='vorobT'>Vorob'ev computations</h2><span id='topic+vorobT'></span><span id='topic+vorobDev'></span>

<h3>Description</h3>

<p>Compute Vorob'ev threshold, expectation and deviation. Also, displaying the
symmetric deviation function is possible.  The symmetric deviation
function is the probability for a given target in the objective space to
belong to the symmetric difference between the Vorob'ev expectation and a
realization of the (random) attained set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vorobT(x, sets, reference, maximise = FALSE)

vorobDev(x, sets, reference, VE = NULL, maximise = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vorobT_+3A_x">x</code></td>
<td>
<p><code>matrix()</code>|<code>data.frame()</code><br /> Matrix or data frame of numerical
values, where each row gives the coordinates of a point. If <code>sets</code> is
missing, the last column of <code>x</code> gives the sets.</p>
</td></tr>
<tr><td><code id="vorobT_+3A_sets">sets</code></td>
<td>
<p><code>integer()</code><br /> A vector that indicates the set of each point in <code>x</code>. If
missing, the last column of <code>x</code> is used instead.</p>
</td></tr>
<tr><td><code id="vorobT_+3A_reference">reference</code></td>
<td>
<p><code>numeric()</code><br /> Reference point as a vector of numerical
values.</p>
</td></tr>
<tr><td><code id="vorobT_+3A_maximise">maximise</code></td>
<td>
<p><code>logical()</code><br /> Whether the objectives must be maximised
instead of minimised. Either a single logical value that applies to all
objectives or a vector of logical values, with one value per objective.</p>
</td></tr>
<tr><td><code id="vorobT_+3A_ve">VE</code></td>
<td>
<p><code>matrix()</code><br /> Vorob'ev expectation, e.g., as returned by <code><a href="#topic+vorobT">vorobT()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>vorobT</code> returns a list with elements <code>threshold</code>,
<code>VE</code>, and <code>avg_hyp</code> (average hypervolume)
</p>
<p><code>vorobDev</code> returns the Vorob'ev deviation.
</p>


<h3>Author(s)</h3>

<p>Mickael Binois
</p>


<h3>References</h3>

<p>M Binois, D Ginsbourger, O Roustant (2015).
&ldquo;Quantifying uncertainty on Pareto fronts with Gaussian process conditional simulations.&rdquo;
<em>European Journal of Operational Research</em>, <b>243</b>(2), 386&ndash;394.
doi: <a href="https://doi.org/10.1016/j.ejor.2014.07.032">10.1016/j.ejor.2014.07.032</a>.
</p>
<p>C. Chevalier (2013), Fast uncertainty reduction strategies relying on
Gaussian process models, University of Bern, PhD thesis.
</p>
<p>Ilya Molchanov (2005).
<em>Theory of Random Sets</em>.
Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(CPFs)
res &lt;- vorobT(CPFs, reference = c(2, 200))
res$threshold
res$avg_hyp
# Now print Vorob'ev deviation
VD &lt;- vorobDev(CPFs, VE = res$VE, reference = c(2, 200))
VD
</code></pre>

<hr>
<h2 id='whv_hype'>Approximation of the (weighted) hypervolume by Monte-Carlo sampling (2D only)</h2><span id='topic+whv_hype'></span>

<h3>Description</h3>

<p>Return an estimation of the hypervolume of the space dominated by the input
data following the procedure described by Auger et al. (2009). A
weight distribution describing user preferences may be specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>whv_hype(
  x,
  reference,
  ideal,
  maximise = FALSE,
  dist = "uniform",
  nsamples = 100000L,
  seed = NULL,
  mu = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="whv_hype_+3A_x">x</code></td>
<td>
<p><code>matrix()</code>|<code>data.frame()</code><br /> Matrix or data frame of numerical
values, where each row gives the coordinates of a point.</p>
</td></tr>
<tr><td><code id="whv_hype_+3A_reference">reference</code></td>
<td>
<p><code>numeric()</code><br /> Reference point as a vector of numerical
values.</p>
</td></tr>
<tr><td><code id="whv_hype_+3A_ideal">ideal</code></td>
<td>
<p><code>numeric()</code><br /> Ideal point as a vector of numerical values.</p>
</td></tr>
<tr><td><code id="whv_hype_+3A_maximise">maximise</code></td>
<td>
<p><code>logical()</code><br /> Whether the objectives must be maximised
instead of minimised. Either a single logical value that applies to all
objectives or a vector of logical values, with one value per objective.</p>
</td></tr>
<tr><td><code id="whv_hype_+3A_dist">dist</code></td>
<td>
<p><code>character(1)</code><br /> weight distribution type. See Details.</p>
</td></tr>
<tr><td><code id="whv_hype_+3A_nsamples">nsamples</code></td>
<td>
<p><code>integer(1)</code><br /> number of samples for Monte-Carlo sampling.</p>
</td></tr>
<tr><td><code id="whv_hype_+3A_seed">seed</code></td>
<td>
<p><code>integer(1)</code><br /> random seed.</p>
</td></tr>
<tr><td><code id="whv_hype_+3A_mu">mu</code></td>
<td>
<p><code>numeric()</code><br /> parameter of the weight distribution. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The current implementation only supports 2 objectives.
</p>
<p>A weight distribution  (Auger et al. 2009) can be provided via the <code>dist</code> argument. The ones currently supported are:
</p>

<ul>
<li> <p><code>"uniform"</code> corresponds to the default hypervolume (unweighted).
</p>
</li>
<li> <p><code>"point"</code> describes a goal in the objective space, where the parameter <code>mu</code> gives the coordinates of the goal. The resulting weight distribution is a multivariate normal distribution centred at the goal.
</p>
</li>
<li> <p><code>"exponential"</code> describes an exponential distribution with rate parameter <code>1/mu</code>, i.e., <code class="reqn">\lambda = \frac{1}{\mu}</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>A single numerical value.
</p>


<h3>References</h3>

<p>Anne Auger, Johannes Bader, Dimo Brockhoff, Eckart Zitzler (2009).
&ldquo;Articulating User Preferences in Many-Objective Problems by Sampling the Weighted Hypervolume.&rdquo;
In Franz Rothlauf (ed.), <em>Proceedings of  the Genetic and Evolutionary Computation Conference, GECCO 2009</em>, 555&ndash;562.
ACM Press,  New York, NY.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_datasets">read_datasets()</a></code>, <code><a href="#topic+eafdiff">eafdiff()</a></code>, <code><a href="#topic+whv_rect">whv_rect()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>whv_hype(matrix(2, ncol=2), reference = 4, ideal = 1, seed = 42)
whv_hype(matrix(c(3,1), ncol=2), reference = 4, ideal = 1, seed = 42)
whv_hype(matrix(2, ncol=2), reference = 4, ideal = 1, seed = 42,
         dist = "exponential", mu=0.2)
whv_hype(matrix(c(3,1), ncol=2), reference = 4, ideal = 1, seed = 42,
         dist = "exponential", mu=0.2)
whv_hype(matrix(2, ncol=2), reference = 4, ideal = 1, seed = 42,
         dist = "point", mu=c(2.9,0.9))
whv_hype(matrix(c(3,1), ncol=2), reference = 4, ideal = 1, seed = 42,
         dist = "point", mu=c(2.9,0.9))
</code></pre>

<hr>
<h2 id='whv_rect'>Compute (total) weighted hypervolume given a set of rectangles</h2><span id='topic+whv_rect'></span><span id='topic+total_whv_rect'></span>

<h3>Description</h3>

<p>Calculates the hypervolume weighted by a set of rectangles (with zero weight
outside the rectangles). The function <code><a href="#topic+total_whv_rect">total_whv_rect()</a></code> calculates the
total weighted hypervolume as <code><a href="#topic+hypervolume">hypervolume()</a></code><code> + scalefactor * abs(prod(reference - ideal)) * whv_rect()</code>. The details of the computation
are given by Diaz and López-Ibáñez (2021).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>whv_rect(x, rectangles, reference, maximise = FALSE)

total_whv_rect(
  x,
  rectangles,
  reference,
  maximise = FALSE,
  ideal = NULL,
  scalefactor = 0.1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="whv_rect_+3A_x">x</code></td>
<td>
<p><code>matrix()</code>|<code>data.frame()</code><br /> Matrix or data frame of numerical
values, where each row gives the coordinates of a point.</p>
</td></tr>
<tr><td><code id="whv_rect_+3A_rectangles">rectangles</code></td>
<td>
<p><code>matrix()</code><br /> Weighted rectangles that will bias the
computation of the hypervolume. Maybe generated by <code><a href="#topic+eafdiff">eafdiff()</a></code> with
<code>rectangles=TRUE</code> or by <code><a href="#topic+choose_eafdiff">choose_eafdiff()</a></code>.</p>
</td></tr>
<tr><td><code id="whv_rect_+3A_reference">reference</code></td>
<td>
<p><code>numeric()</code><br /> Reference point as a vector of numerical
values.</p>
</td></tr>
<tr><td><code id="whv_rect_+3A_maximise">maximise</code></td>
<td>
<p><code>logical()</code><br /> Whether the objectives must be maximised
instead of minimised. Either a single logical value that applies to all
objectives or a vector of logical values, with one value per objective.</p>
</td></tr>
<tr><td><code id="whv_rect_+3A_ideal">ideal</code></td>
<td>
<p><code>numeric()</code><br /> Ideal point as a vector of numerical values.  If
<code>NULL</code>, it is calculated as minimum (or maximum if maximising that
objective) of each objective in the input data.</p>
</td></tr>
<tr><td><code id="whv_rect_+3A_scalefactor">scalefactor</code></td>
<td>
<p><code>numeric(1)</code><br /> Real value within <code class="reqn">(0,1]</code> that scales
the overall weight of the differences. This is parameter psi (<code class="reqn">\psi</code>)
in Diaz and López-Ibáñez (2021).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>TODO
</p>


<h3>Value</h3>

<p><code>numeric(1)</code><br /> A single numerical value.
</p>


<h3>References</h3>

<p>Juan
Esteban Diaz, Manuel López-Ibáñez (2021).
&ldquo;Incorporating Decision-Maker's Preferences into the Automatic Configuration of Bi-Objective Optimisation Algorithms.&rdquo;
<em>European Journal of Operational Research</em>, <b>289</b>(3), 1209&ndash;1222.
doi: <a href="https://doi.org/10.1016/j.ejor.2020.07.059">10.1016/j.ejor.2020.07.059</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_datasets">read_datasets()</a></code>, <code><a href="#topic+eafdiff">eafdiff()</a></code>, <code><a href="#topic+choose_eafdiff">choose_eafdiff()</a></code>, <code><a href="#topic+whv_hype">whv_hype()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rectangles &lt;- as.matrix(read.table(header=FALSE, text='
 1.0  3.0  2.0  Inf    1
 2.0  3.5  2.5  Inf    2
 2.0  3.0  3.0  3.5    3
'))
whv_rect (matrix(2, ncol=2), rectangles, reference = 6)
whv_rect (matrix(c(2, 1), ncol=2), rectangles, reference = 6)
whv_rect (matrix(c(1, 2), ncol=2), rectangles, reference = 6)

total_whv_rect (matrix(2, ncol=2), rectangles, reference = 6, ideal = c(1,1))
total_whv_rect (matrix(c(2, 1), ncol=2), rectangles, reference = 6, ideal = c(1,1))
total_whv_rect (matrix(c(1, 2), ncol=2), rectangles, reference = 6, ideal = c(1,1))

</code></pre>

<hr>
<h2 id='write_datasets'>Write data sets</h2><span id='topic+write_datasets'></span>

<h3>Description</h3>

<p>Write data sets to a file in the same format as <code><a href="#topic+read_datasets">read_datasets()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_datasets(x, file = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write_datasets_+3A_x">x</code></td>
<td>
<p><code>matrix</code>|<code>data.frame()</code><br /> Dataset with at least three
columns, the last one is the set of each point. See also
<code><a href="#topic+read_datasets">read_datasets()</a></code>.</p>
</td></tr>
<tr><td><code id="write_datasets_+3A_file">file</code></td>
<td>
<p>Either a character string naming a file or a connection open for
writing. <code>""</code> indicates output to the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+write.table">utils::write.table()</a></code>, <code><a href="#topic+read_datasets">read_datasets()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- read_datasets(text="1 2\n3 4\n\n5 6\n7 8\n", col_names=c("obj1", "obj2"))
write_datasets(x)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
