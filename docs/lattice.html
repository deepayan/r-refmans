<!DOCTYPE html><html><head><title>Help for package lattice</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="/home/deepayan/Rinstall/R-devel/lib/R/doc/html/R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lattice}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#A_01_Lattice'><p>Lattice Graphics</p></a></li>
<li><a href='#B_00_xyplot'><p>Common Bivariate Trellis Plots</p></a></li>
<li><a href='#B_01_xyplot.ts'><p>Time series plotting methods</p></a></li>
<li><a href='#B_02_barchart.table'><p>table methods for barchart and dotplot</p></a></li>
<li><a href='#B_03_histogram'><p>Histograms and Kernel Density Plots</p></a></li>
<li><a href='#B_04_qqmath'><p>Q-Q Plot with Theoretical Distribution</p></a></li>
<li><a href='#B_05_qq'><p> Quantile-Quantile Plots of Two Samples</p></a></li>
<li><a href='#B_06_levelplot'><p>Level plots and contour plots</p></a></li>
<li><a href='#B_07_cloud'><p>3d Scatter Plot and Wireframe Surface Plot</p></a></li>
<li><a href='#B_08_splom'><p>Scatter Plot Matrices</p></a></li>
<li><a href='#B_09_tmd'><p>Tukey Mean-Difference Plot</p></a></li>
<li><a href='#B_10_rfs'><p> Residual and Fit Spread Plots</p></a></li>
<li><a href='#B_11_oneway'><p> Fit One-way Model</p></a></li>
<li><a href='#C_01_trellis.device'><p> Initializing Trellis Displays</p></a></li>
<li><a href='#C_02a_standard.theme'><p> Built-in Graphical Themes</p></a></li>
<li><a href='#C_02b_trellis.par.get'><p> Graphical Parameters for Trellis Displays</p></a></li>
<li><a href='#C_03_simpleTheme'><p> Function to generate a simple theme</p></a></li>
<li><a href='#C_04_lattice.options'><p> Low-level Options Controlling Behaviour of Lattice</p></a></li>
<li><a href='#C_05_print.trellis'><p>Plot and Summarize Trellis Objects</p></a></li>
<li><a href='#C_06_update.trellis'><p>Retrieve and Update Trellis Object</p></a></li>
<li><a href='#C_07_shingles'><p>shingles</p></a></li>
<li><a href='#D_draw.colorkey'><p>Produce a colorkey typically for levelplot</p></a></li>
<li><a href='#D_draw.key'><p>Produce a Legend or Key</p></a></li>
<li><a href='#D_level.colors'>
<p>A function to compute false colors representing a numeric or</p>
categorical variable</a></li>
<li><a href='#D_make.groups'><p> Grouped data from multiple vectors</p></a></li>
<li><a href='#D_simpleKey'><p> Function to generate a simple key</p></a></li>
<li><a href='#D_strip.default'><p>Default Trellis Strip Function</p></a></li>
<li><a href='#D_trellis.object'><p>A Trellis Plot Object</p></a></li>
<li><a href='#E_interaction'><p>Functions to Interact with Lattice Plots</p></a></li>
<li><a href='#F_1_panel.barchart'><p> Default Panel Function for barchart</p></a></li>
<li><a href='#F_1_panel.bwplot'><p> Default Panel Function for bwplot</p></a></li>
<li><a href='#F_1_panel.cloud'><p> Default Panel Function for cloud</p></a></li>
<li><a href='#F_1_panel.densityplot'><p> Default Panel Function for densityplot</p></a></li>
<li><a href='#F_1_panel.dotplot'><p> Default Panel Function for dotplot</p></a></li>
<li><a href='#F_1_panel.histogram'><p> Default Panel Function for histogram</p></a></li>
<li><a href='#F_1_panel.levelplot'><p> Panel Functions for levelplot and contourplot</p></a></li>
<li><a href='#F_1_panel.pairs'><p> Default Superpanel Function for splom</p></a></li>
<li><a href='#F_1_panel.parallel'><p> Default Panel Function for parallel</p></a></li>
<li><a href='#F_1_panel.qqmath'><p> Default Panel Function for qqmath</p></a></li>
<li><a href='#F_1_panel.stripplot'><p> Default Panel Function for stripplot</p></a></li>
<li><a href='#F_1_panel.xyplot'><p> Default Panel Function for xyplot</p></a></li>
<li><a href='#F_2_llines'><p>Replacements of traditional graphics functions</p></a></li>
<li><a href='#F_2_panel.functions'><p>Useful Panel Function Components</p></a></li>
<li><a href='#F_2_panel.loess'><p>Panel Function to Add a LOESS Smooth</p></a></li>
<li><a href='#F_2_panel.qqmathline'><p>Useful panel function with qqmath</p></a></li>
<li><a href='#F_2_panel.smoothScatter'><p>Lattice panel function analogous to smoothScatter</p></a></li>
<li><a href='#F_2_panel.spline'><p>Panel Function to Add a Spline Smooth</p></a></li>
<li><a href='#F_2_panel.superpose'><p> Panel Function for Display Marked by groups</p></a></li>
<li><a href='#F_2_panel.violin'><p> Panel Function to create Violin Plots</p></a></li>
<li><a href='#F_3_prepanel.default'><p> Default Prepanel Functions</p></a></li>
<li><a href='#F_3_prepanel.functions'><p> Useful Prepanel Function for Lattice</p></a></li>
<li><a href='#G_axis.default'><p>Default axis annotation utilities</p></a></li>
<li><a href='#G_banking'><p>Banking</p></a></li>
<li><a href='#G_latticeParseFormula'><p>Parse Trellis formula</p></a></li>
<li><a href='#G_packet.panel.default'><p>Associating Packets with Panels</p></a></li>
<li><a href='#G_panel.axis'><p>Panel Function for Drawing Axis Ticks and Labels</p></a></li>
<li><a href='#G_panel.number'><p>Accessing Auxiliary Information During Plotting</p></a></li>
<li><a href='#G_Rows'><p>Extract rows from a list</p></a></li>
<li><a href='#G_utilities.3d'><p> Utility functions for 3-D plots</p></a></li>
<li><a href='#H_barley'><p> Yield data from a Minnesota barley trial</p></a></li>
<li><a href='#H_environmental'><p> Atmospheric environmental conditions in New York City</p></a></li>
<li><a href='#H_ethanol'><p> Engine exhaust fumes from burning ethanol</p></a></li>
<li><a href='#H_melanoma'><p> Melanoma skin cancer incidence</p></a></li>
<li><a href='#H_singer'><p> Heights of New York Choral Society singers</p></a></li>
<li><a href='#H_USMortality'><p> Mortality Rates in US by Cause and Gender</p></a></li>
<li><a href='#I_lset'><p>Interface to modify Trellis Settings - Defunct</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.22-6</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-20</td>
</tr>
<tr>
<td>Priority:</td>
<td>recommended</td>
</tr>
<tr>
<td>Title:</td>
<td>Trellis Graphics for R</td>
</tr>
<tr>
<td>Description:</td>
<td>A powerful and elegant high-level data visualization
  system inspired by Trellis graphics, with an emphasis on
  multivariate data. Lattice is sufficient for typical graphics needs,
  and is also flexible enough to handle most nonstandard requirements.
  See ?Lattice for an introduction.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>KernSmooth, MASS, latticeExtra, colorspace</td>
</tr>
<tr>
<td>Imports:</td>
<td>grid, grDevices, graphics, stats, utils</td>
</tr>
<tr>
<td>Enhances:</td>
<td>chron, zoo</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://lattice.r-forge.r-project.org/">https://lattice.r-forge.r-project.org/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/deepayan/lattice/issues">https://github.com/deepayan/lattice/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-20 03:08:45 UTC; deepayan</td>
</tr>
<tr>
<td>Author:</td>
<td>Deepayan Sarkar <a href="https://orcid.org/0000-0003-4107-1553"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Felix Andrews [ctb],
  Kevin Wright [ctb] (documentation),
  Neil Klepeis [ctb],
  Johan Larsson [ctb] (miscellaneous improvements),
  Zhijian (Jason) Wen [cph] (filled contour code),
  Paul Murrell [ctb],
  Stefan Eng [ctb] (violin plot improvements),
  Achim Zeileis [ctb] (modern colors),
  Alexandre Courtiol [ctb] (generics for larrows, lpolygon, lrect and lsegments)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Deepayan Sarkar &lt;deepayan.sarkar@r-project.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-20 06:10:02 UTC</td>
</tr>
<tr>
<td>Built:</td>
<td>R 4.4.0; x86_64-pc-linux-gnu; 2024-03-26 07:22:55 UTC; unix</td>
</tr>
</table>
<hr>
<h2 id='A_01_Lattice'>Lattice Graphics</h2><span id='topic+Lattice'></span><span id='topic+lattice'></span><span id='topic+lattice-package'></span>

<h3>Description</h3>

<p>The <span class="pkg">lattice</span> add-on package is an implementation of Trellis
graphics for <span class="rlang"><b>R</b></span>.  It is a powerful and elegant high-level data
visualization system with an emphasis on multivariate data.  It is
designed to meet most typical graphics needs with minimal tuning, but
can also be easily extended to handle most nonstandard requirements.
</p>


<h3>Details</h3>

<p>Trellis Graphics, originally developed for S and S-PLUS at the Bell
Labs, is a framework for data visualization developed by R. A. Becker,
W. S. Cleveland, et al, extending ideas presented in Cleveland's 1993
book <em>Visualizing Data</em>.  The Lattice API is based on the
original design in S, but extends it in many ways.
</p>
<p>The Lattice user interface primarily consists of several
&lsquo;high-level&rsquo; generic functions (listed below in the &ldquo;See
Also&rdquo; section), each designed to create a particular type of display
by default.  Although the functions produce different output, they
share many common features, reflected in several common arguments that
affect the resulting displays in similar ways.  These arguments are
extensively (sometimes only) documented in the help page for
<code><a href="#topic+xyplot">xyplot</a></code>, which also includes a discussion of the
important topics of <em>conditioning</em> and control of the Trellis
layout.  Features specific to other high-level functions are
documented in their respective help pages.
</p>
<p>Lattice employs an extensive system of user-controllable settings to
determine the look and feel of the displays it produces.  To learn how
to use and customize the graphical parameters used by lattice, see
<code><a href="#topic+trellis.par.set">trellis.par.set</a></code>.  For other settings, see
<code><a href="#topic+lattice.options">lattice.options</a></code>.  The default graphical settings are
(potentially) different for different graphical devices.  To learn how
to initialize new devices with the desired settings or change the
settings of the current device, see <code><a href="#topic+trellis.device">trellis.device</a></code>.
</p>
<p>It is usually unnecessary, but sometimes important to be able to plot
multiple lattice plots on a single page.  Such capabilities are
described in the <code><a href="#topic+print.trellis">print.trellis</a></code> help page.  See
<code><a href="#topic+update.trellis">update.trellis</a></code> to learn about manipulating a
<code>"trellis"</code> object.  Tools to augment lattice plots after they
are drawn (including <code><a href="graphics.html#topic+locator">locator</a></code>-like functionality) are
described in the <code><a href="#topic+trellis.focus">trellis.focus</a></code> help page.
</p>
<p>The online documentation accompanying the package is complete, and
effort has been made to present the help pages in a logical sequence,
so that one can learn how to use lattice by reading the PDF reference
manual available at <a href="https://cran.r-project.org/package=lattice">https://cran.r-project.org/package=lattice</a>.
However, the format in which the online documentation is written and
the breadth of topics covered necessarily makes it somewhat terse and
less than ideal as a first introduction.  For a more gentle
introduction, a book on lattice is available as part of Springer's
&lsquo;Use R&rsquo; series; see the &ldquo;References&rdquo; section below.
</p>





<h3>Note</h3>

<p>High-level <span class="pkg">lattice</span> functions like <code><a href="#topic+xyplot">xyplot</a></code> are
different from traditional <span class="rlang"><b>R</b></span> graphics functions in that they do not
perform any plotting themselves.  Instead, they return an object, of
class <code>"trellis"</code>, which has to be then
<code><a href="#topic+print.trellis">print</a></code>-ed or
<code><a href="#topic+print.trellis">plot</a></code>-ted to create the actual
plot.  Due to <span class="rlang"><b>R</b></span>'s automatic printing rule, it is usually not
necessary to explicitly carry out the second step, and <span class="pkg">lattice</span>
functions appear to behave like their traditional counterparts.
However, the automatic plotting is suppressed when the high-level
functions are called inside another function (most often
<code>source</code>) or in other contexts where automatic printing is
suppressed (e.g., <code><a href="base.html#topic+for">for</a></code> or <code><a href="base.html#topic+while">while</a></code> loops).  In
such situations, an explicit call to <code>print</code> or <code>plot</code> is
required.
</p>
<p>The <span class="pkg">lattice</span> package is based on the Grid graphics engine and
requires the <span class="pkg">grid</span> add-on package.  One consquence of this is
that it is not (readily) compatible with traditional <span class="rlang"><b>R</b></span> graphics
tools.  In particular, changing <code>par()</code> settings usually has no
effect on Lattice plots; <span class="pkg">lattice</span> provides its own interface for
querying and modifying an extensive set of graphical and non-graphical
settings.
</p>


<h3>Author(s)</h3>

<p>Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>References</h3>

<p>Sarkar, Deepayan (2008) <em>Lattice: Multivariate Data
Visualization with R</em>, Springer.  ISBN: 978-0-387-75968-5
<a href="http://lmdvr.r-forge.r-project.org/">http://lmdvr.r-forge.r-project.org/</a>
</p>
<p>Cleveland, William .S. (1993) <em>Visualizing Data</em>, Hobart Press,
Summit, New Jersey.
</p>
<p>Becker, R. A. and Cleveland, W. S. and Shyu, M. J. (1996).  &ldquo;The
Visual Design and Control of Trellis Display&rdquo;, <em>Journal of
Computational and Graphical Statistics</em>, <b>5(2)</b>, 123&ndash;155.
</p>
<p>Bell Lab's Trellis Page contains several documents outlining the use
of Trellis graphics; these provide a holistic introduction to
the Trellis paradigm:
<a href="http://web.archive.org/web/20081020164041/http://cm.bell-labs.com/cm/ms/departments/sia/project/trellis/display.writing.html">http://web.archive.org/web/20081020164041/http://cm.bell-labs.com/cm/ms/departments/sia/project/trellis/display.writing.html</a>
</p>


<h3>See Also</h3>

<p>The following is a list of high-level functions in the <span class="pkg">lattice</span>
package and their default displays.  In all cases, the actual display
is produced by the so-called &ldquo;panel&rdquo; function, which has a
suitable default, but can be substituted by an user defined function
to create customized displays.  In many cases, the default panel
function will itself have many optional arguments to customize its
output.  The default panel functions are named as
&ldquo;<code>panel.</code>&rdquo; followed by the name of the corresponding
high-level function; i.e., the default panel function for
<code><a href="#topic+xyplot">xyplot</a></code> is <code><a href="#topic+panel.xyplot">panel.xyplot</a></code>, the one for
<code><a href="#topic+histogram">histogram</a></code> is <code><a href="#topic+panel.histogram">panel.histogram</a></code>, etc.  Each
default panel function has a separate help page, linked from the help
pages of the corresponding high-level function.  Although documented
separately, arguments to these panel functions can be supplied
directly to the high-level functions, which will pass on the arguments
appropriately.
</p>
<p><b>Univariate:</b>
</p>

<dl>
<dt><code><a href="#topic+barchart">barchart</a></code>:</dt><dd><p> Bar plots. </p>
</dd>
<dt><code><a href="#topic+bwplot">bwplot</a></code>:</dt><dd><p> Box-and-whisker plots. </p>
</dd>
<dt><code><a href="#topic+densityplot">densityplot</a></code>:</dt><dd><p> Kernel density estimates. </p>
</dd>
<dt><code><a href="#topic+dotplot">dotplot</a></code>:</dt><dd><p> Cleveland dot plots. </p>
</dd>
<dt><code><a href="#topic+histogram">histogram</a></code>:</dt><dd><p> Histograms. </p>
</dd>
<dt><code><a href="#topic+qqmath">qqmath</a></code>:</dt><dd><p> Theretical quantile plots. </p>
</dd>
<dt><code><a href="#topic+stripplot">stripplot</a></code>:</dt><dd><p> One-dimensional scatterplots. </p>
</dd>
</dl>

<p><b>Bivariate:</b>
</p>

<dl>
<dt><code><a href="#topic+qq">qq</a></code>:</dt><dd><p> Quantile plots for comparing two distributions. </p>
</dd>
<dt><code><a href="#topic+xyplot">xyplot</a></code>:</dt><dd><p> Scatterplots and time-series plots (and potentially a lot more). </p>
</dd>
</dl>

<p><b>Trivariate:</b>
</p>

<dl>
<dt><code><a href="#topic+levelplot">levelplot</a></code>:</dt><dd><p> Level plots (similar to <code><a href="Matrix.html#topic+image">image</a></code> plots). </p>
</dd>
<dt><code><a href="#topic+contourplot">contourplot</a></code>:</dt><dd><p> Contour plots. </p>
</dd>
<dt><code><a href="#topic+cloud">cloud</a></code>:</dt><dd><p> Three-dimensional scatter plots. </p>
</dd>
<dt><code><a href="#topic+wireframe">wireframe</a></code>:</dt><dd><p> Three-dimensional surface plots (similar to <code><a href="graphics.html#topic+persp">persp</a></code> plots). </p>
</dd>
</dl>

<p><b>Hypervariate:</b>
</p>

<dl>
<dt><code><a href="#topic+splom">splom</a></code>:</dt><dd><p> Scatterplot matrices. </p>
</dd>
<dt><code><a href="#topic+parallel">parallel</a></code>:</dt><dd><p> Parallel coordinate plots. </p>
</dd>
</dl>

<p><b>Miscellaneous:</b>
</p>

<dl>
<dt><code><a href="#topic+rfs">rfs</a></code>:</dt><dd><p> Residual and fitted value plots (also see <code><a href="#topic+oneway">oneway</a></code>). </p>
</dd>
<dt><code><a href="#topic+tmd">tmd</a></code>:</dt><dd><p> Tukey Mean-Difference plots. </p>
</dd>
</dl>

<p>In addition, there are several panel functions that do little by
themselves, but can be useful components of custom panel functions.
These are documented in <code><a href="#topic+panel.functions">panel.functions</a></code>.  Lattice also
provides a collection of convenience functions that correspond to the
traditional graphics primitives <code><a href="graphics.html#topic+lines">lines</a></code>,
<code><a href="graphics.html#topic+points">points</a></code>, etc.  These are implemented using Grid graphics,
but try to be as close to the traditional versions as possible in
terms of their argument list.  These functions have names like
<code><a href="#topic+llines">llines</a></code> or <code><a href="#topic+panel.lines">panel.lines</a></code> and are often useful
when writing (or porting from S-PLUS code) nontrivial panel functions.
</p>
<p>Finally, many useful enhancements that extend the Lattice system are
available in the <span class="pkg">latticeExtra</span> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

## Show brief history of changes to lattice, including
## a summary of new features.

RShowDoc("NEWS", package = "lattice")

## End(Not run)
</code></pre>

<hr>
<h2 id='B_00_xyplot'>Common Bivariate Trellis Plots</h2><span id='topic+xyplot'></span><span id='topic+xyplot.formula'></span><span id='topic+xyplot.data.frame'></span><span id='topic+barchart'></span><span id='topic+barchart.formula'></span><span id='topic+barchart.data.frame'></span><span id='topic+barchart.numeric'></span><span id='topic+barchart.default'></span><span id='topic+bwplot'></span><span id='topic+bwplot.formula'></span><span id='topic+bwplot.data.frame'></span><span id='topic+bwplot.numeric'></span><span id='topic+dotplot'></span><span id='topic+dotplot.formula'></span><span id='topic+dotplot.data.frame'></span><span id='topic+dotplot.numeric'></span><span id='topic+dotplot.default'></span><span id='topic+stripplot'></span><span id='topic+stripplot.formula'></span><span id='topic+stripplot.data.frame'></span><span id='topic+stripplot.numeric'></span>

<h3>Description</h3>

<p>This help page documents several commonly used high-level Lattice
functions.  <code>xyplot</code> produces bivariate scatterplots or
time-series plots, <code>bwplot</code> produces box-and-whisker plots,
<code>dotplot</code> produces Cleveland dot plots, <code>barchart</code> produces
bar plots, and <code>stripplot</code> produces one-dimensional scatterplots.
All these functions, along with other high-level Lattice functions,
respond to a common set of arguments that control conditioning,
layout, aspect ratio, legends, axis annotation, and many other details
in a consistent manner.  These arguments are described extensively in
this help page, and should be used as the reference for other
high-level functions as well.
</p>
<p>For control and customization of the actual display in each panel, the
help page of the respective default panel function will often be more
informative.  In particular, these help pages describe many arguments
commonly used when calling the corresponding high-level function but
are specific to them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xyplot(x, data, ...)
dotplot(x, data, ...)
barchart(x, data, ...)
stripplot(x, data, ...)
bwplot(x, data, ...)

## S3 method for class 'formula'
xyplot(x,
       data,
       allow.multiple = is.null(groups) || outer,
       outer = !is.null(groups),
       auto.key = lattice.getOption("default.args")$auto.key,
       aspect = "fill",
       panel = lattice.getOption("panel.xyplot"),
       prepanel = NULL,
       scales = list(),
       strip = TRUE,
       groups = NULL,
       xlab,
       xlim,
       ylab,
       ylim,
       drop.unused.levels = lattice.getOption("drop.unused.levels"),
       ...,
       lattice.options = NULL,
       default.scales,
       default.prepanel = lattice.getOption("prepanel.default.xyplot"),
       subscripts = !is.null(groups),
       subset = TRUE)

## S3 method for class 'data.frame'
xyplot(x, data = NULL, formula = data, ...)

## S3 method for class 'formula'
dotplot(x,
        data,
        panel = lattice.getOption("panel.dotplot"),
        default.prepanel = lattice.getOption("prepanel.default.dotplot"),
        ...)

## S3 method for class 'data.frame'
dotplot(x, data = NULL, formula = data, ...)

## S3 method for class 'formula'
barchart(x,
         data,
         panel = lattice.getOption("panel.barchart"),
         default.prepanel = lattice.getOption("prepanel.default.barchart"),
         box.ratio = 2,
         ...)

## S3 method for class 'data.frame'
barchart(x, data = NULL, formula = data, ...)

## S3 method for class 'formula'
stripplot(x,
          data,
          panel = lattice.getOption("panel.stripplot"),
          default.prepanel = lattice.getOption("prepanel.default.stripplot"),
          ...)

## S3 method for class 'data.frame'
stripplot(x, data = NULL, formula = data, ...)

## S3 method for class 'formula'
bwplot(x,
       data,
       allow.multiple = is.null(groups) || outer,
       outer = FALSE,
       auto.key = lattice.getOption("default.args")$auto.key,
       aspect = "fill",
       panel = lattice.getOption("panel.bwplot"),
       prepanel = NULL,
       scales = list(),
       strip = TRUE,
       groups = NULL,
       xlab,
       xlim,
       ylab,
       ylim,
       box.ratio = 1,
       horizontal = NULL,
       drop.unused.levels = lattice.getOption("drop.unused.levels"),
       ...,
       lattice.options = NULL,
       default.scales,
       default.prepanel = lattice.getOption("prepanel.default.bwplot"),
       subscripts = !is.null(groups),
       subset = TRUE)

## S3 method for class 'data.frame'
bwplot(x, data = NULL, formula = data, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="B_00_xyplot_+3A_x">x</code></td>
<td>

<p>All high-level function in <span class="pkg">lattice</span> are generic.  <code>x</code> is
the object on which method dispatch is carried out.
</p>
<p>For the <code>"formula"</code> methods, <code>x</code> must be a formula
describing the primary variables (used for the per-panel display)
and the optional conditioning variables (which define the subsets
plotted in different panels) to be used in the plot.  Conditioning
is described in the &ldquo;Details&rdquo; section below.  
</p>
<p>For the functions documented here, the formula is generally of the
form <code>y ~ x | g1 * g2 * ...</code> (or equivalently, <code>y ~ x |
    g1 + g2 + ...</code>), indicating that plots of <code>y</code> (on the y-axis)
versus <code>x</code> (on the x-axis) should be produced conditional on
the variables <code>g1, g2, ...</code>.  Here <code>x</code> and <code>y</code> are
the primary variables, and <code>g1, g2, ...</code> are the conditioning
variables.  The conditioning variables may be omitted to give a
formula of the form <code>y ~ x</code>, in which case the plot will
consist of a single panel with the full dataset.  The formula can
also involve expressions, e.g., <code>sqrt()</code>, <code>log()</code>, etc.
See the <code>data</code> argument below for rules regarding evaluation of
the terms in the formula.
</p>
<p>With the exception of <code>xyplot</code>, the functions documented here
may also be supplied a formula of the form <code> ~ x | g1 * g2 *
    ...</code>.  In that case, <code>y</code> defaults to <code>names(x)</code> if
<code>x</code> is named, and a factor with a single level otherwise.
</p>
<p>Cases where <code>x</code> is not a formula is handled by appropriate
methods.  The <code>numeric</code> methods are equivalent to a call with
no left hand side and no conditioning variables in the formula.  For
<code>barchart</code> and <code>dotplot</code>, non-trivial methods exist for
tables and arrays, documented at <code><a href="#topic+barchart.table">barchart.table</a></code>.
</p>
<p>The conditioning variables <code>g1, g2, ...</code> must be either
factors or shingles.  Shingles provide a way of using numeric
variables for conditioning; see the help page of
<code><a href="#topic+shingle">shingle</a></code> for details. Like factors, they have a
<code>"levels"</code> attribute, which is used in producing the
conditional plots.  If necessary, numeric conditioning variables are
converted to shingles using the <code>shingle</code> function; however,
using <code><a href="#topic+equal.count">equal.count</a></code> may be more appropriate in many
cases.  Character variables are coerced to factors.
</p>





<p><b>Extended formula interface:</b> As a useful extension of the
interface described above, the primary variable terms (both the LHS
<code>y</code> and RHS <code>x</code>) may consist of multiple terms separated
by a &lsquo;+&rsquo; sign, e.g., <code>y1 + y2 ~ x | a * b</code>.  This
formula would be taken to mean that the user wants to plot both
<code>y1 ~ x | a * b</code> and <code>y2 ~ x | a * b</code>, but with the
<code>y1 ~ x</code> and <code>y2 ~ x</code> superposed in each panel.  The two
groups will be distinguished by different graphical parameters.
This is essentially what the <code>groups</code> argument (see below)
would produce, if <code>y1</code> and <code>y2</code> were concatenated to
produce a longer vector, with the <code>groups</code> argument being an
indicator of which rows come from which variable.  In fact, this is
exactly what is done internally using the <code><a href="stats.html#topic+reshape">reshape</a></code>
function. This feature cannot be used in conjunction with the
<code>groups</code> argument.
</p>
<p>To interpret <code>y1 + y2</code> as a sum, one can either set
<code>allow.multiple=FALSE</code> or use <code>I(y1+y2)</code>.
</p>
<p>A variation on this feature is when the <code>outer</code> argument is set
to <code>TRUE</code>. In that case, the plots are not superposed in each
panel, but instead separated into different panels (as if a new
conditioning variable had been added).
</p>
<p><b>Primary variables:</b> The <code>x</code> and <code>y</code> variables should
both be numeric in <code>xyplot</code>, and an attempt is made to coerce
them if not. However, if either is a factor, the levels of that
factor are used as axis labels. In the other four functions
documented here, exactly one of <code>x</code> and <code>y</code> should be
numeric, and the other a factor or shingle. Which of these will
happen is determined by the <code>horizontal</code> argument &mdash; if
<code>horizontal=TRUE</code>, then <code>y</code> will be coerced to be a factor
or shingle, otherwise <code>x</code>. The default value of
<code>horizontal</code> is <code>FALSE</code> if <code>x</code> is a factor or
shingle, <code>TRUE</code> otherwise. (The functionality provided by
<code>horizontal=FALSE</code> is not S-compatible.)
</p>
<p>Note that the <code>x</code> argument used to be called <code>formula</code> in
earlier versions (when the high-level functions were not generic and
the formula method was essentially the only method).  This is no
longer allowed.  It is recommended that this argument not be named
in any case, but instead be the first (unnamed) argument.
</p>
</td></tr>
<tr><td><code id="B_00_xyplot_+3A_data">data</code></td>
<td>

<p>For the <code>formula</code> methods, a data frame (or more precisely,
anything that is a valid <code>envir</code> argument in
<code><a href="base.html#topic+eval">eval</a></code>, e.g., a list or an environment) containing values
for any variables in the formula, as well as <code>groups</code> and
<code>subset</code> if applicable.  If not found in <code>data</code>, or if
<code>data</code> is unspecified, the variables are looked for in the
environment of the formula.  For other methods (where <code>x</code> is
not a formula), <code>data</code> is usually ignored, often with a warning
if it is explicitly specified.
</p>
</td></tr>
<tr><td><code id="B_00_xyplot_+3A_formula">formula</code></td>
<td>

<p>The formula to be used for the <code>"data.frame"</code> methods. See
documentation for argument <code>x</code> for details.
</p>
</td></tr>
<tr><td><code id="B_00_xyplot_+3A_allow.multiple">allow.multiple</code></td>
<td>

<p>Logical flag specifying whether the extended formula interface
described above should be in effect.  Defaults to <code>TRUE</code>
whenever sensible.
</p>
</td></tr>
<tr><td><code id="B_00_xyplot_+3A_outer">outer</code></td>
<td>

<p>Logical flag controlling what happens with formulas using the
extended interface described above (see the entry for <code>x</code> for
details).  Defaults to <code>FALSE</code>, except when <code>groups</code> is
explicitly specified or grouping does not make sense for the default
panel function.
</p>
</td></tr>
<tr><td><code id="B_00_xyplot_+3A_box.ratio">box.ratio</code></td>
<td>

<p>Applicable to <code>barchart</code> and <code>bwplot</code>.  Specifies the
ratio of the width of the rectangles to the inter-rectangle space.
See also the <code>box.width</code> argument in the respective default
panel functions.
</p>
</td></tr>
<tr><td><code id="B_00_xyplot_+3A_horizontal">horizontal</code></td>
<td>

<p>Logical flag applicable to <code>bwplot</code>, <code>dotplot</code>,
<code>barchart</code>, and <code>stripplot</code>. Determines which of <code>x</code>
and <code>y</code> is to be a factor or shingle (<code>y</code> if TRUE,
<code>x</code> otherwise).  Defaults to <code>FALSE</code> if <code>x</code> is a
factor or shingle, <code>TRUE</code> otherwise. This argument is used to
process the arguments to these high-level functions, but more
importantly, it is passed as an argument to the panel function,
which is expected to use it as appropriate.
</p>
<p>A potentially useful component of <code>scales</code> in this case may be
<code>abbreviate = TRUE</code>, in which case long labels which would
usually overlap will be abbreviated. <code>scales</code> could also
contain a <code>minlength</code> argument in this case, which would be
passed to the <code>abbreviate</code> function.
</p>
</td></tr>








</table>
<p><b>Common arguments: </b> The following arguments are common to all
the functions documented here, as well as most other high-level
Trellis functions. These are not documented elsewhere, except to
override the usage given here.
</p>
<table>
<tr><td><code id="B_00_xyplot_+3A_panel">panel</code></td>
<td>

<p>Once the subset of rows defined by each unique combination of the
levels of the grouping variables are obtained (see
&ldquo;Details&rdquo;), the corresponding <code>x</code> and <code>y</code> variables
(or other variables, as appropriate, in the case of other high-level
functions) are passed on to be plotted in each panel. The actual
plotting is done by the function specified by the <code>panel</code>
argument.  The argument may be a function object or a character
string giving the name of a predefined function.  Each high-level
function has its own default panel function, named as
&ldquo;<code>panel.</code>&rdquo; followed by the name of the corresponding
high-level function (e.g., <code><a href="#topic+panel.xyplot">panel.xyplot</a></code>,
<code><a href="#topic+panel.barchart">panel.barchart</a></code>, etc).
</p>
<p>Much of the power of Trellis Graphics comes from the ability to
define customized panel functions.  A panel function appropriate for
the functions described here would usually expect arguments named
<code>x</code> and <code>y</code>, which would be provided by the conditioning
process.  It can also have other arguments. It is useful to know in
this context that all arguments passed to a high-level Lattice
function (such as <code>xyplot</code>) that are not recognized by it are
passed through to the panel function. It is thus generally good
practice when defining panel functions to allow a <code>...</code>
argument. Such extra arguments typically control graphical
parameters, but other uses are also common. See documentation for
individual panel functions for specifics.
</p>
<p>Note that unlike in S-PLUS, it is not guaranteed that panel
functions will be supplied only numeric vectors for the <code>x</code> and
<code>y</code> arguments; they can be factors as well (but not
shingles).  Panel functions need to handle this case, which in most
cases can be done by simply coercing them to numeric.
</p>
<p>Technically speaking, panel functions must be written using Grid
graphics functions.  However, knowledge of Grid is usually not
necessary to construct new custom panel functions, as there are
several predefined panel functions which can help; for example,
<code>panel.grid</code>, <code>panel.loess</code>, etc.  There are also some
grid-compatible replacements of commonly used traditional graphics
functions useful for this purpose.  For example, <code>lines</code> can be
replaced by <code>llines</code> (or equivalently, <code>panel.lines</code>).
Note that traditional graphics functions like <code>lines</code> will not
work in a lattice panel function.
</p>
<p>One case where a bit more is required of the panel function is when
the <code>groups</code> argument is not <code>NULL</code>.  In that case, the
panel function should also accept arguments named <code>groups</code> and
<code>subscripts</code> (see below for details).  A useful panel function
predefined for use in such cases is <code><a href="#topic+panel.superpose">panel.superpose</a></code>,
which can be combined with different <code>panel.groups</code> functions
to determine what is plotted for each group.  See the
&ldquo;Examples&rdquo; section for an interaction plot constructed in
this way.  Several other panel functions can also handle the
<code>groups</code> argument, including the default ones for
<code>xyplot</code>, <code>barchart</code>, <code>dotplot</code>, and
<code>stripplot</code>.
</p>
<p>Even when <code>groups</code> is not present, the panel function can have
<code>subscripts</code> as a formal argument.  In either case, the
<code>subscripts</code> argument passed to the panel function are the
indices of the <code>x</code> and <code>y</code> data for that panel in the
original <code>data</code>, BEFORE taking into account the effect of
the <code>subset</code> argument.  Note that <code>groups</code> remains
unaffected by any subsetting operations, so
<code>groups[subscripts]</code> gives the values of <code>groups</code> that
correspond to the data in that panel.
</p>
<p>This interpretation of <code>subscripts</code> does not hold when the
extended formula interface is in use (i.e., when
<code>allow.multiple</code> is in effect).  A comprehensive description
would be too complicated (details can be found in the source code of
the function <code>latticeParseFormula</code>), but in short, the extended
interface works by creating an artificial grouping variable that is
longer than the original data frame, and consequently,
<code>subscripts</code> needs to refer to rows beyond those in the
original data.  To further complicate matters, the artificial
grouping variable is created after any effect of <code>subset</code>, in
which case <code>subscripts</code> may have no relationship with
corresponding rows in the original data frame.
</p>
<p>One can also use functions called <code><a href="#topic+panel.number">panel.number</a></code> and
<code><a href="#topic+packet.number">packet.number</a></code>, representing panel order and packet
order respectively, inside the panel function (as well as the strip
function or while interacting with a lattice display using
<code><a href="#topic+trellis.focus">trellis.focus</a></code> etc).  Both provide a simple integer
index indicating which panel is currently being drawn, but differ in
how the count is calculated.  The panel number is a simple
incremental counter that starts with 1 and is incremented each time
a panel is drawn.  The packet number on the other hand indexes the
combination of levels of the conditioning variables that is
represented by that panel.  The two indices coincide unless the
order of conditioning variables is permuted and/or the plotting
order of levels within one or more conditioning variables is altered
(using <code>perm.cond</code> and <code>index.cond</code> respectively), in
which case <code>packet.number</code> gives the index corresponding to the
&lsquo;natural&rsquo; ordering of that combination of levels of the
conditioning variables.
</p>
<p><code><a href="#topic+panel.xyplot">panel.xyplot</a></code> has an argument called <code>type</code> which
is worth mentioning here because it is quite frequently used (and as
mentioned above, can be passed to <code>xyplot</code> directly).  In the
event that a <code>groups</code> variable is used,
<code><a href="#topic+panel.xyplot">panel.xyplot</a></code> calls <code><a href="#topic+panel.superpose">panel.superpose</a></code>,
arguments of which can also be passed directly to <code>xyplot</code>.
Panel functions for <code>bwplot</code> and friends should have an
argument called <code>horizontal</code> to account for the cases when
<code>x</code> is the factor or shingle.
</p>
</td></tr>





<tr><td><code id="B_00_xyplot_+3A_aspect">aspect</code></td>
<td>

<p>This argument controls the physical aspect ratio of the panels,
which is usually the same for all the panels. It can be specified as
a ratio (vertical size/horizontal size) or as a character string.
In the latter case, legitimate values are <code>"fill"</code> (the
default) which tries to make the panels as big as possible to fill
the available space; <code>"xy"</code>, which computes the aspect ratio
based on the 45 degree banking rule (see <code><a href="#topic+banking">banking</a></code>); and
<code>"iso"</code> for isometric scales, where the relation between
physical distance on the device and distance in the data scale are
forced to be the same for both axes.
</p>
<p>If a <code>prepanel</code> function is specified and it returns components
<code>dx</code> and <code>dy</code>, these are used for banking calculations.
Otherwise, values from the default prepanel function are used.  Not
all default prepanel functions produce sensible banking
calculations.
</p>
</td></tr>
<tr><td><code id="B_00_xyplot_+3A_groups">groups</code></td>
<td>

<p>A variable or expression to be evaluated in <code>data</code>, expected to
act as a grouping variable within each panel, typically used to
distinguish different groups by varying graphical parameters like
color and line type.  Formally, if <code>groups</code> is specified, then
<code>groups</code> along with <code>subscripts</code> is passed to the panel
function, which is expected to handle these arguments.  For high
level functions where grouping is appropriate, the default panel
functions can handle grouping.
</p>
<p>It is very common to use a key (legend) when a grouping variable is
specified.  See entries for <code>key</code>, <code>auto.key</code> and
<code><a href="#topic+simpleKey">simpleKey</a></code> for how to draw a key.
</p>
</td></tr>
<tr><td><code id="B_00_xyplot_+3A_auto.key">auto.key</code></td>
<td>

<p>A logical, or a list containing components to be used as arguments
to <code><a href="#topic+simpleKey">simpleKey</a></code>. The default can be set using
<code><a href="#topic+lattice.options">lattice.options</a></code>.
</p>
<p><code>auto.key = TRUE</code> is equivalent to <code>auto.key = list()</code>, in
which case <code><a href="#topic+simpleKey">simpleKey</a></code> is called with a set of default
arguments (which may depend on the relevant high-level function).
Most valid components to the <code>key</code> argument can be specified in
this manner, as <code><a href="#topic+simpleKey">simpleKey</a></code> will simply add unrecognized
arguments to the list it produces.
</p>
<p><code>auto.key</code> is typically used to automatically produce a
suitable legend in conjunction with a grouping variable.  If
<code>auto.key = TRUE</code>, a suitable legend will be drawn if a
<code>groups</code> argument is also provided, and not otherwise.  In list
form, <code>auto.key</code> will modify the default legend thus produced.
For example, <code>auto.key=list(columns = 2)</code> will create a legend
split into two columns (<code>columns</code> is documented in the entry
for <code>key</code>).
</p>
<p>More precisely, if <code>auto.key</code> is not <code>FALSE</code>,
<code>groups</code> is non-null, and there is no <code>key</code> or
<code>legend</code> argument specified in the call, a key is created with
<code>simpleKey</code> with <code>levels(groups)</code> as the first
(<code>text</code>) argument. (Note: this may not work in all high-level
functions, but it does work for the ones where grouping makes sense
with the default panel function).  If <code>auto.key</code> is provided as
a list and includes a <code>text</code> component, then that is used
instead as the text labels in the key, and the key is drawn even if
<code>groups</code> is not specified.
</p>
<p>Note that <code>simpleKey</code> uses the default settings (see
<code><a href="#topic+trellis.par.get">trellis.par.get</a></code>) to determine the graphical parameters
in the key, so the resulting legend will be meaningful only if the
same settings are used in the plot as well.  The <code>par.settings</code>
argument, possibly in conjunction with <code><a href="#topic+simpleTheme">simpleTheme</a></code>,
may be useful to temporarily modify the default settings for this
purpose.
</p>
<p>One disadvantage to using <code>key</code> (or even <code>simpleKey</code>)
directly is that the graphical parameters used in the key are
absolutely determined at the time when the <code>"trellis"</code> object
is created. Consequently, if a plot once created is
re-<code>plot</code>-ted with different settings, the original parameter
settings will be used for the key even though the new settings are
used for the actual display. However, with <code>auto.key</code>, the key
is actually created at plotting time, so the settings will match.
</p>
</td></tr>
<tr><td><code id="B_00_xyplot_+3A_prepanel">prepanel</code></td>
<td>

<p>A function that takes the same arguments as the <code>panel</code>
function and returns a list, possibly containing components named
<code>xlim</code>, <code>ylim</code>, <code>dx</code>, and <code>dy</code> (and less
frequently, <code>xat</code> and <code>yat</code>).  The return value of a
user-supplied prepanel function need not contain all these
components; in case some are missing, they are replaced by the
component-wise defaults.
</p>
<p>The <code>xlim</code> and <code>ylim</code> components are similar to the high
level <code>xlim</code> and <code>ylim</code> arguments (i.e., they are usually
a numeric vector of length 2 defining a range, or a
character vector representing levels of a factor).  If the
<code>xlim</code> and <code>ylim</code> arguments are not explicitly specified
(possibly as components in <code>scales</code>) in the high-level call,
then the actual limits of the panels are guaranteed to include the
limits returned by the prepanel function.  This happens globally if
the <code>relation</code> component of <code>scales</code> is <code>"same"</code>, and
on a per-panel basis otherwise.
</p>
<p>The <code>dx</code> and <code>dy</code> components are used for banking
computations in case <code>aspect</code> is specified as <code>"xy"</code>.  See
documentation of <code><a href="#topic+banking">banking</a></code> for details.
</p>
<p>If <code>xlim</code> or <code>ylim</code> is a character vector (which is
appropriate when the corresponding variable is a factor), this
implicitly indicates that the scale should include the first
<code>n</code> integers, where <code>n</code> is the length of <code>xlim</code> or
<code>ylim</code>, as the case may be.  The elements of the character
vector are used as the default labels for these <code>n</code> integers.
Thus, to make this information consistent between panels, the
<code>xlim</code> or <code>ylim</code> values should represent all the levels of
the corresponding factor, even if some are not used within that
particular panel.
</p>
<p>In such cases, an additional component <code>xat</code> or <code>yat</code> may
be returned by the <code>prepanel</code> function, which should be a
subset of <code>1:n</code>, indicating which of the <code>n</code> values
(levels) are actually represented in the panel.  This is useful when
calculating the limits with <code>relation="free"</code> or
<code>relation="sliced"</code> in <code>scales</code>.
</p>
<p>The prepanel function is responsible for providing a meaningful
return value when the <code>x</code>, <code>y</code> (etc.) variables are
zero-length vectors.  When nothing else is appropriate, values of NA
should be returned for the <code>xlim</code> and <code>ylim</code> components.
</p>
</td></tr>
<tr><td><code id="B_00_xyplot_+3A_strip">strip</code></td>
<td>

<p>A logical flag or function.  If <code>FALSE</code>, strips are not drawn.
Otherwise, strips are drawn using the <code>strip</code> function, which
defaults to <code>strip.default</code>.  See documentation of
<code><a href="#topic+strip.default">strip.default</a></code> to see the arguments that are available
to the strip function.  This description also applies to the
<code>strip.left</code> argument (see <code>...</code> below), which can be
used to draw strips on the left of each panel (useful for wide short
panels, e.g., in time-series plots).
</p>
</td></tr>
<tr><td><code id="B_00_xyplot_+3A_xlab">xlab</code></td>
<td>

<p>Character or expression (or a <code>"grob"</code>) giving label(s) for the
x-axis.  Generally defaults to the expression for <code>x</code> in the
formula defining the plot.  Can be specified as <code>NULL</code> to omit
the label altogether.  Finer control is possible, as described in
the entry for <code>main</code>, with the modification that if the
<code>label</code> component is omitted from the list, it is replaced by
the default <code>xlab</code>.
</p>
</td></tr>
<tr><td><code id="B_00_xyplot_+3A_ylab">ylab</code></td>
<td>

<p>Character or expression (or <code>"grob"</code>) giving label for the
y-axis.  Generally defaults to the expression for <code>y</code> in the
formula defining the plot.  Finer control is possible, see entries
for <code>main</code> and <code>xlab</code>.
</p>
</td></tr>
<tr><td><code id="B_00_xyplot_+3A_scales">scales</code></td>
<td>

<p>Generally a list determining how the x- and y-axes (tick marks and
labels) are drawn.  The list contains parameters in
<code>name=value</code> form, and may also contain two other lists called
<code>x</code> and <code>y</code> of the same form (described below).
Components of <code>x</code> and <code>y</code> affect the respective axes only,
while those in <code>scales</code> affect both.  When parameters are
specified in both lists, the values in <code>x</code> or <code>y</code> are
used.  Note that certain high-level functions have defaults that are
specific to a particular axis (e.g., <code>bwplot</code> has
<code>alternating=FALSE</code> for the categorical axis only); these can
only be overridden by an entry in the corresponding component of
<code>scales</code>.
</p>
<p>As a special exception, <code>scales</code> (or its <code>x</code> and <code>y</code>
components) can also be a character string, in which case it is
interpreted as the <code>relation</code> component.
</p>
<p>The possible components are :
</p>

<dl>
<dt><code>relation</code></dt><dd>
<p>A character string that determines how axis limits are
calculated for each panel.  Possible values are <code>"same"</code>
(default), <code>"free"</code> and <code>"sliced"</code>.  For
<code>relation="same"</code>, the same limits, usually large enough to
encompass all the data, are used for all the panels.  For
<code>relation="free"</code>, limits for each panel is determined by
just the points in that panel.  Behavior for
<code>relation="sliced"</code> is similar, except that the length (max
- min) of the scales are constrained to remain the same across
panels.
</p>
<p>The determination of what axis limits are suitable for each
panel can be controlled by the <code>prepanel</code> function, which
can be overridden by <code>xlim</code>, <code>ylim</code> or
<code>scales$limits</code> (except when <code>relation="sliced"</code>, in
which case explicitly specified limits are ignored with a
warning).  When <code>relation</code> is <code>"free"</code>, <code>xlim</code> or
<code>ylim</code> can be a list, in which case it is treated as if its
components were the limit values obtained from the prepanel
calculations for each panel (after being replicated if
necessary).
</p>
</dd>
<dt><code>tick.number</code></dt><dd>
<p>An integer, giving the suggested number of intervals between
ticks.  This is ignored for a factor, shingle, or character
vector, for in these cases there is no natural rule for leaving
out some of the labels. But see <code>xlim</code>.
</p>
</dd>
<dt><code>draw</code></dt><dd>
<p>A logical flag, defaulting to <code>TRUE</code>, that determines
whether to draw the axis (i.e., tick marks and labels) at all.
</p>
</dd>
<dt><code>alternating</code></dt><dd>
<p>Usually a logical flag specifying whether axis labels should
alternate from one side of the group of panels to the other.
For finer control, <code>alternating</code> can also be a vector
(replicated to be as long as the number of rows or columns per
page) consisting of the following numbers
</p>

<ul>
<li><p> 0: do not draw tick labels
</p>
</li>
<li><p> 1: bottom/left
</p>
</li>
<li><p> 2: top/right
</p>
</li>
<li><p> 3: both.
</p>
</li></ul>

<p><code>alternating</code> applies only when <code>relation="same"</code>.
The default is <code>TRUE</code>, or equivalently, <code>c(1, 2)</code>
</p>
</dd>
<dt><code>limits</code></dt><dd>
<p>Same as <code>xlim</code> and <code>ylim</code>.
</p>
</dd>
<dt><code>at</code></dt><dd>
<p>The location of tick marks along the axis (in native
coordinates), or a list as long as the number of panels
describing tick locations for each panel.
</p>
</dd>
<dt><code>labels</code></dt><dd>
<p>Vector of labels (characters or expressions) to go along with
<code>at</code>. Can also be a list like <code>at</code>.
</p>
</dd>
<dt><code>cex</code></dt><dd>
<p>A numeric multiplier to control character sizes for axis labels.
Can be a vector of length 2, to control left/bottom and
right/top labels separately.
</p>
</dd>
<dt><code>font</code>, <code>fontface</code>, <code>fontfamily</code></dt><dd>
<p>Specifies the font to be used for axis labels.
</p>
</dd>
<dt><code>lineheight</code></dt><dd>
<p>Specifies the line height parameter (height of line as a
multiple of the size of text); relevant for multi-line labels.
(This is currently ignored for <code><a href="#topic+cloud">cloud</a></code>.)
</p>
</dd>
<dt><code>tck</code></dt><dd>
<p>Usually a numeric scalar controlling the length of tick marks.
Can also be a vector of length 2, to control the length of
left/bottom and right/top tick marks separately.
</p>
</dd>
<dt><code>col</code></dt><dd>
<p>Color of tick marks and labels.
</p>
</dd>
<dt><code>rot</code></dt><dd>
<p>Angle (in degrees) by which the axis labels are to be rotated.
Can be a vector of length 2, to control left/bottom and
right/top axes separately.
</p>
</dd>
<dt><code>abbreviate</code></dt><dd>
<p>A logical flag, indicating whether to abbreviate the labels
using the <code><a href="base.html#topic+abbreviate">abbreviate</a></code> function.  Can be useful for
long labels (e.g., in factors), especially on the x-axis.
</p>
</dd>
<dt><code>minlength</code></dt><dd>
<p>Argument passed to <code><a href="base.html#topic+abbreviate">abbreviate</a></code> if
<code>abbreviate=TRUE</code>.
</p>
</dd>
<dt><code>log</code></dt><dd>
<p>Controls whether the corresponding variable (<code>x</code> or
<code>y</code>) will be log transformed before being passed to the
panel function.  Defaults to <code>FALSE</code>, in which case the
data are not transformed.  Other possible values are any number
that works as a base for taking logarithm, <code>TRUE</code> (which is
equivalent to 10), and <code>"e"</code> (for the natural logarithm).
As a side effect, the corresponding axis is labeled differently.
Note that this is in reality a transformation of the data, not
the axes.  Other than the axis labeling, using this feature is
no different than transforming the data in the formula; e.g.,
<code>scales=list(x = list(log = 2))</code> is equivalent to <code>y ~
          log2(x)</code>.
</p>
<p>See entry for <code>equispaced.log</code> below for details on how to
control axis labeling.
</p>





</dd>
<dt><code>equispaced.log</code></dt><dd>
<p>A logical flag indicating whether tick mark locations should be
equispaced when &lsquo;log scales&rsquo; are in use.  Defaults to
<code>TRUE</code>.
</p>
<p>Tick marks are always labeled in the original (untransformed)
scale, but this makes the choice of tick mark locations
nontrivial.  If <code>equispaced.log</code> is <code>FALSE</code>, the
choice made is similar to how log scales are annotated in
traditional graphics.  If <code>TRUE</code>, tick mark locations are
chosen as &lsquo;pretty&rsquo; equispaced values in the transformed
scale, and labeled in the form <code>"base^loc"</code>, where
<code>base</code> is the base of the logarithm transformation, and
<code>loc</code> are the locations in the transformed scale.
</p>
<p>See also <code>xscale.components.logpower</code> in the
<span class="pkg">latticeExtra</span> package.
</p>
</dd>
<dt><code>format</code></dt><dd>
<p>The <code>format</code> to use for POSIXct variables. See
<code><a href="base.html#topic+strptime">strptime</a></code> for description of valid values.
</p>
</dd>
<dt><code>axs</code></dt><dd>
<p>A character string, <code>"r"</code> (default) or <code>"i"</code>.  In the
latter case, the axis limits are calculated as the exact data
range, instead of being padded on either side. (May not always
work as expected.)
</p>
</dd>
</dl>

<p>Note that much of the function of <code>scales</code> is accomplished by
<code>pscales</code> in <code><a href="#topic+splom">splom</a></code>.
</p>
</td></tr>
<tr><td><code id="B_00_xyplot_+3A_subscripts">subscripts</code></td>
<td>

<p>A logical flag specifying whether or not a vector named
<code>subscripts</code> should be passed to the panel function.  Defaults
to <code>FALSE</code>, unless <code>groups</code> is specified, or if the panel
function accepts an argument named <code>subscripts</code>.  This argument
is useful if one wants the subscripts to be passed on even if these
conditions do not hold; a typical example is when one wishes to
augment a Lattice plot after it has been drawn, e.g., using
<code><a href="#topic+panel.identify">panel.identify</a></code>.
</p>
</td></tr>
<tr><td><code id="B_00_xyplot_+3A_subset">subset</code></td>
<td>

<p>An expression that evaluates to a logical or integer indexing
vector.  Like <code>groups</code>, it is evaluated in <code>data</code>.  Only
the resulting rows of <code>data</code> are used for the plot.  If
<code>subscripts</code> is <code>TRUE</code>, the subscripts provided to the
panel function will be indices referring to the rows of <code>data</code>
prior to the subsetting.  Whether levels of factors in the data
frame that are unused after the subsetting will be dropped depends
on the <code>drop.unused.levels</code> argument.
</p>
</td></tr>
<tr><td><code id="B_00_xyplot_+3A_xlim">xlim</code></td>
<td>

<p>Normally a numeric vector (or a DateTime object) of length 2 giving
left and right limits for the x-axis, or a character vector,
expected to denote the levels of <code>x</code>.  The latter form is
interpreted as a range containing c(1, length(xlim)), with the
character vector determining labels at tick positions
<code>1:length(xlim)</code>.
</p>
<p><code>xlim</code> could also be a list, with as many components as the
number of panels (recycled if necessary), with each component as
described above.  This is meaningful only when
<code>scales$x$relation</code> is <code>"free"</code>, in which case these are
treated as if they were the corresponding limit components returned
by prepanel calculations.
</p>
</td></tr>
<tr><td><code id="B_00_xyplot_+3A_ylim">ylim</code></td>
<td>
<p> Similar to <code>xlim</code>, applied to the y-axis. </p>
</td></tr>
<tr><td><code id="B_00_xyplot_+3A_drop.unused.levels">drop.unused.levels</code></td>
<td>

<p>A logical flag indicating whether the unused levels of factors will
be dropped, usually relevant when a subsetting operation is
performed or an <code><a href="base.html#topic+interaction">interaction</a></code> is created.  Unused levels
are usually dropped, but it is sometimes appropriate to suppress
dropping to preserve a useful layout.  For finer control, this
argument could also be list containing components <code>cond</code> and
<code>data</code>, both logical, indicating desired behavior for
conditioning variables and primary variables respectively.  The
default is given by <code>lattice.getOption("drop.unused.levels")</code>,
which is initially set to <code>TRUE</code> for both components.  Note
that this argument does not control dropping of levels of the
<code>groups</code> argument.
</p>
</td></tr>
<tr><td><code id="B_00_xyplot_+3A_default.scales">default.scales</code></td>
<td>

<p>A list giving the default values of <code>scales</code> for a particular
high-level function.  This is rarely of interest to the end-user,
but may be helpful when defining other functions that act as a
wrapper to one of the high-level Lattice functions.
</p>
</td></tr>
<tr><td><code id="B_00_xyplot_+3A_default.prepanel">default.prepanel</code></td>
<td>

<p>A function or character string giving the name of a function that
serves as the (component-wise) fallback prepanel function when the
<code>prepanel</code> argument is not specified, or does not return all
necessary components.  The main purpose of this argument is to
enable the defaults to be overridden through the use of
<code><a href="#topic+lattice.options">lattice.options</a></code>.
</p>
</td></tr>
<tr><td><code id="B_00_xyplot_+3A_lattice.options">lattice.options</code></td>
<td>

<p>A list that could be supplied to <code><a href="#topic+lattice.options">lattice.options</a></code>.
These options are applied temporarily for the duration of the call,
after which the settings revert back to what they were before.  The
options are retained along with the object and reused during
plotting.  This enables the user to attach options settings to the
trellis object itself rather than change the settings globally.  See
also the <code>par.settings</code> argument described below for a similar
treatment of graphical settings.
</p>
</td></tr>
<tr><td><code id="B_00_xyplot_+3A_...">...</code></td>
<td>

<p>Further arguments, usually not directly processed by the high-level
functions documented here, but instead passed on to other
functions. Such arguments can be broadly categorized into two types:
those that affect all high-level Lattice functions in a similar
manner, and those that are meant for the specific panel function
being used.
</p>
<p>The first group of arguments are processed by a common, unexported
function called <code>trellis.skeleton</code>.  These arguments affect all
high-level functions, but are only documented here (except to
override the behaviour described here).  All other arguments
specified in a high-level call, specifically those neither described
here nor in the help page of the relevant high-level function, are
passed unchanged to the panel function used.  By convention, the
default panel function used for any high-level function is named as
&ldquo;<code>panel.</code>&rdquo; followed by the name of the high-level
function; for example, the default panel function for <code>bwplot</code>
is <code>panel.bwplot</code>.  In practical terms, this means that in
addition to the help page of the high-level function being used, the
user should also consult the help page of the corresponding panel
function for arguments that may be specified in the high-level call.
</p>
<p>The effect of the first group of common arguments are as follows:
</p>

<dl>
<dt><code>as.table</code>:</dt><dd>
<p>A logical flag that controls the order in which panels should be
displayed: if <code>FALSE</code> (the default), panels are drawn left to
right, bottom to top (as in a graph); if <code>TRUE</code>, left to
right, top to bottom (as in a table).
</p>
</dd>
<dt><code>between</code>:</dt><dd>
<p>A list with components <code>x</code> and <code>y</code> (both usually 0 by
default), numeric vectors specifying the space between the
panels (units are character heights). <code>x</code> and <code>y</code> are
repeated to account for all panels in a page and any extra
components are ignored. The result is used for all pages in a
multi page display.  In other words, it is not possible to use
different <code>between</code> values for different pages.
</p>
</dd>
<dt><code>key</code>:</dt><dd>
<p>A list that defines a legend to be drawn on the plot.  This list
is used as an argument to the <code><a href="#topic+draw.key">draw.key</a></code> function,
which produces a <code>"grob"</code> (grid object) eventually plotted
by the print method for <code>"trellis"</code> objects.  The structure
of the legend is constrained in the ways described below.
</p>
<p>Although such a list can be and often is created explicitly, it
is also possible to generate such a list using the
<code><a href="#topic+simpleKey">simpleKey</a></code> function; the latter is more convenient
but less flexible.  The <code>auto.key</code> argument can be even
more convenient for the most common situation where legends are
used, namely, in conjunction with a grouping variable.  To use
more than one legend, or to have arbitrary legends not
constrained by the structure imposed by <code>key</code>, use the
<code>legend</code> argument.
</p>
<p>The position of the key can be controlled in either of two
possible ways. If a component called <code>space</code> is present,
the key is positioned outside the plot region, in one of the
four sides, determined by the value of <code>space</code>, which can
be one of <code>"top"</code>, <code>"bottom"</code>, <code>"left"</code> and
<code>"right"</code>.  Alternatively, the key can be positioned inside
the plot region by specifying components <code>x</code>, <code>y</code> and
<code>corner</code>. <code>x</code> and <code>y</code> determine the location of
the corner of the key given by <code>corner</code>, which is usually
one of <code>c(0,0)</code>, <code>c(1,0)</code>, <code>c(1,1)</code> and
<code>c(0,1)</code>, which denote the corners of the unit square.
Fractional values are also allowed, in which case <code>x</code> and
<code>y</code> determine the position of an arbitrary point inside (or
outside for values outside the unit interval) the key.
</p>
<p><code>x</code> and <code>y</code> should be numbers between 0 and 1, giving
coordinates with respect to the &ldquo;display area&rdquo;.
Depending on the value of the <code>"legend.bbox"</code> option (see
<code><a href="#topic+lattice.getOption">lattice.getOption</a></code>), this can be either the full
figure region (<code>"full"</code>), or just the region that bounds
the panels and strips (<code>"panel"</code>).
</p>
<p>The key essentially consists of a number of columns, possibly
divided into blocks, each containing some rows.  The contents of the
key are determined by (possibly repeated) components named
<code>"rectangles"</code>, <code>"lines"</code>, <code>"points"</code> or
<code>"text"</code>.  Each of these must be lists with relevant graphical
parameters (see later) controlling their appearance.  The <code>key</code>
list itself can contain graphical parameters, these would be used if
relevant graphical components are omitted from the other components.
</p>
<p>The length (number of rows) of each such column (except
<code>"text"</code>s) is taken to be the largest of the lengths of the
graphical components, including the ones specified outside (see
the entry for <code>rep</code> below for details on this). The
<code>"text"</code> component must have a character or expression
vector as its first component, to be used as labels.  The length
of this vector determines the number of rows.
</p>
<p>The graphical components that can be included in <code>key</code> and
also in the components named <code>"text"</code>, <code>"lines"</code>,
<code>"points"</code> and <code>"rectangles"</code> (as appropriate) are:
</p>

<ul>
<li> <p><code>cex=1</code> (text, lines, points)
</p>
</li>
<li> <p><code>col="black"</code> (text, rectangles, lines, points)
</p>
</li>
<li> <p><code>alpha=1</code> (text, rectangles, lines, points)
</p>
</li>
<li> <p><code>fill="transparent"</code> (lines, points)
</p>
</li>
<li> <p><code>lty=1</code> (lines)
</p>
</li>
<li> <p><code>lwd=1</code> (lines, points)
</p>
</li>
<li> <p><code>font=1</code> (text, points)
</p>
</li>
<li> <p><code>fontface</code> (text, points)
</p>
</li>
<li> <p><code>fontfamily</code> (text, points)
</p>
</li>
<li> <p><code>pch=8</code> (lines, points)
</p>
</li>
<li> <p><code>adj=0</code> (text)
</p>
</li>
<li> <p><code>type="l"</code> (lines)
</p>
</li>
<li> <p><code>size=5</code> (rectangles, lines)
</p>
</li>
<li> <p><code>height=1</code> (rectangles)
</p>
</li>
<li> <p><code>lineheight=1</code> (text)
</p>
</li>
<li> <p><code>angle=0</code> (rectangles, but ignored)
</p>
</li>
<li> <p><code>density=-1</code> (rectangles, but ignored)
</p>
</li></ul>

<p>In addition, the component <code>border</code> can be included inside
the <code>"rect"</code> component to control the border color of the
rectangles; when specified at the top level, <code>border</code>
controls the border of the entire key (see below).
</p>
<p><code>angle</code> and <code>density</code> are unimplemented.  <code>size</code>
determines the width of columns of rectangles and lines in
character widths. <code>type</code> is relevant for lines; <code>"l"</code>
denotes a line, <code>"p"</code> denotes a point, and <code>"b"</code> and
<code>"o"</code> both denote both together. <code>height</code> gives
heights of rectangles as a fraction of the default.
</p>
<p>Other possible components of <code>key</code> are:
</p>

<dl>
<dt><code>reverse.rows</code></dt><dd>
<p>Logical flag, defaulting to <code>FALSE</code>.  If <code>TRUE</code>,
all components are reversed <em>after</em> being replicated
(the details of which may depend on the value of
<code>rep</code>).  This is useful in certain situations, e.g.,
with a grouped <code>barchart</code> with <code>stack = TRUE</code> with
the categorical variable on the vertical axis, where the
bars in the plot will usually be ordered from bottom to top,
but the corresponding legend will have the levels from top
to bottom unless <code>reverse.rows = TRUE</code>.  Note that in
this case, unless all columns have the same number or rows,
they will no longer be aligned.
</p>
</dd>
<dt><code>between</code></dt><dd>
<p>Numeric vector giving the amount of space (character widths)
surrounding each column (split equally on both sides).
</p>
</dd>
<dt><code>title</code></dt><dd>
<p>String or expression giving a title for the key.
</p>
</dd>
<dt><code>rep</code></dt><dd>
<p>Logical flag, defaults to <code>TRUE</code>.  By default, it is
assumed that all columns in the key (except the
<code>"text"</code>s) will have the same number of rows, and all
components are replicated to be as long as the longest. This
can be suppressed by specifying <code>rep=FALSE</code>, in which
case the length of each column will be determined by
components of that column alone.
</p>
</dd>
<dt><code>cex.title</code></dt><dd>
<p>Zoom factor for the title.
</p>
</dd>
<dt><code>lines.title</code></dt><dd>
<p>The amount of vertical space to be occupied by the title in
lines (in multiples of itself).  Defaults to 2.
</p>
</dd>
<dt><code>padding.text</code></dt><dd>
<p>The amount of space (padding) to be used above and below
each row containing text, in multiples of the default, which
is currently <code>0.2 * "lines"</code>.  This padding is in
addition to the normal height of any row that contains text,
which is the minimum amount necessary to contain all the
text entries.
</p>
</dd>
<dt><code>background</code></dt><dd>
<p>Background color for the legend.  Defaults to the global
background color.
</p>
</dd>
<dt><code>alpha.background</code></dt><dd>
<p>An alpha transparency value between 0 and 1 for the
background.
</p>
</dd>
<dt><code>border</code></dt><dd>
<p>Either a color for the border, or a logical flag.  In the
latter case, the border color is black if <code>border</code> is
<code>TRUE</code>, and no border is drawn if it is <code>FALSE</code>
(the default).
</p>
</dd>
<dt><code>transparent=FALSE</code></dt><dd>
<p>Logical flag, whether legend should have a transparent
background.
</p>
</dd>
<dt><code>just</code></dt><dd>
<p>A character or numeric vector of length one or two giving
horizontal and vertical justification for the placement of
the legend.  See <code><a href="grid.html#topic+grid.layout">grid.layout</a></code>
for more precise details.
</p>
</dd>
<dt><code>columns</code></dt><dd>
<p>The number of column-blocks (drawn side by side) the legend
is to be divided into.
</p>
</dd>
<dt><code>between.columns</code></dt><dd>
<p>Space between column blocks, in addition to <code>between</code>.
</p>
</dd>
<dt><code>divide</code></dt><dd>
<p>Number of point symbols to divide each line when <code>type</code> is
<code>"b"</code> or <code>"o"</code> in <code>lines</code>.
</p>
</dd>
</dl>

</dd>
<dt><code>legend</code>:</dt><dd>
<p>The legend argument can be useful if one wants to place more
than one key.  It also allows the use of arbitrary
<code>"grob"</code>s (grid objects) as legends.
</p>
<p>If used, <code>legend</code> must be a list, with an arbitrary number
of components.  Each component must be named one of
<code>"left"</code>, <code>"right"</code>, <code>"top"</code>, <code>"bottom"</code>, or
<code>"inside"</code>.  The name <code>"inside"</code> can be repeated, but
not the others.  This name will be used to determine the
location for that component, and is similar to the <code>space</code>
component of <code>key</code>.  If <code>key</code> (or <code>colorkey</code> for
<code><a href="#topic+levelplot">levelplot</a></code> and <code><a href="#topic+wireframe">wireframe</a></code>) is
specified, their <code>space</code> component must not conflict with
the name of any component of <code>legend</code>.
</p>
<p>Each component of <code>legend</code> must have a component called
<code>fun</code>.  This can be a <code>"grob"</code>, or a function (or the
name of a function) that produces a <code>"grob"</code> when called.
If this function expects any arguments, they must be supplied as
a list in another component called <code>args</code>.  For components
named <code>"inside"</code>, there can be additional components called
<code>x</code>, <code>y</code> and <code>corner</code>, which work in the same way
as for <code>key</code>.
</p>
</dd>
<dt><code>page</code>:</dt><dd>
<p>A function of one argument (page number) to be called after
drawing each page.  The function must be
&lsquo;grid-compliant&rsquo;, and is called with the whole display
area as the default viewport.
</p>
</dd>
<dt><code>xlab.top</code>, <code>ylab.right</code>:</dt><dd>
<p>Labels for the x-axis on top, and y-axis on the right.  Similar
to <code>xlab</code> and <code>ylab</code>, but less commonly used.
</p>
</dd>
<dt><code>main</code>:</dt><dd>
<p>Typically a character string or expression describing the main
title to be placed on top of each page.  Defaults to
<code>NULL</code>.
</p>
<p><code>main</code> (as well as <code>xlab</code>, <code>ylab</code> and <code>sub</code>)
is usually a character string or an expression that gets used as
the label, but can also be a list that controls further details.
Expressions are treated as specification of LaTeX-like markup as
described in <code><a href="grDevices.html#topic+plotmath">plotmath</a></code>.  The label can be a vector,
in which case the components will be spaced out horizontally (or
vertically for <code>ylab</code>).  This feature can be used to
provide column or row labels rather than a single axis label.
</p>
<p>When <code>main</code> (etc.) is a list, the actual label should be
specified as the <code>label</code> component (which may be unnamed if
it is the first component).  The label can be missing, in which
case the default will be used (<code>xlab</code> and <code>ylab</code>
usually have defaults, but <code>main</code> and <code>sub</code> do not).
Further named arguments are passed on to
<code><a href="grid.html#topic+grid.text">textGrob</a></code>; this can include
arguments controlling positioning like <code>just</code> and
<code>rot</code> as well as graphical parameters such as <code>col</code>
and <code>font</code> (see <code><a href="grid.html#topic+gpar">gpar</a></code> for a full
list).
</p>
<p><code>main</code>, <code>sub</code>, <code>xlab</code>, <code>ylab</code>,
<code>xlab.top</code>, and <code>ylab.right</code> can also be arbitrary
<code>"grob"</code>s (grid graphical objects).
</p>
</dd>
<dt><code>sub</code>:</dt><dd>
<p>Character string or expression (or a list or <code>"grob"</code>) for
a subtitle to be placed at the bottom of each page.  See entry
for <code>main</code> for finer control options.
</p>
</dd>
<dt><code>par.strip.text</code>:</dt><dd>
<p>A list of parameters to control the appearance of strip text.
Notable components are <code>col</code>, <code>cex</code>, <code>font</code>, and
<code>lines</code>.  The first three control graphical parameters
while the last is a means of altering the height of the strips.
This can be useful, for example, if the strip labels (derived
from factor levels, say) are double height (i.e., contains
<code>"\n"</code>-s) or if the default height seems too small or too
large.
</p>
<p>Additionally, the <code>lineheight</code> component can control the
space between multiple lines.  The labels can be abbreviated
when shown by specifying <code>abbreviate = TRUE</code>, in which case
the components <code>minlength</code> and <code>dot</code> (passed along to
the <code><a href="base.html#topic+abbreviate">abbreviate</a></code> function) can be specified to
control the details of how this is done.
</p>
</dd>
<dt><code>layout</code>:</dt><dd>
<p>In general, a conditioning plot in Lattice consists of several
panels arranged in a rectangular array, possibly spanning
multiple pages. <code>layout</code> determines this arrangement.
</p>
<p><code>layout</code> is a numeric vector of length 2 or 3 giving the
number of columns, rows, and pages (optional) in a multipanel
display.  By default, the number of columns is the number of
levels of the first conditioning variable and the number of rows
is the number of levels of the second conditioning variable.  If
there is only one conditioning variable, the default layout
vector is <code>c(0,n)</code>, where <code>n</code> is the number of levels
of the given vector.  Any time the first value in the layout
vector is 0, the second value is used as the desired number of
panels per page and the actual layout is computed from this,
taking into account the aspect ratio of the panels and the
device dimensions (via <code><a href="graphics.html#topic+par">par</a>("din")</code>).  If <code>NA</code>
is specified for the number of rows or columns (but not both),
that dimension will be filled out according to the number of
panels.
</p>
<p>The number of pages is by default set to as many as is required
to plot all the panels, and so rarely needs to be specified.
However, in certain situations the default calculation may be
incorrect, and in that case the number of pages needs to be
specified explicitly.
</p>





</dd>
<dt><code>skip</code>:</dt><dd>
<p>A logical vector (default <code>FALSE</code>), replicated to be as
long as the number of panels (spanning all pages).  For elements
that are <code>TRUE</code>, the corresponding panel position is
skipped; i.e., nothing is plotted in that position.  The panel
that was supposed to be drawn there is now drawn in the next
available panel position, and the positions of all the
subsequent panels are bumped up accordingly.  This may be useful
for arranging plots in an informative manner.
</p>
</dd>
<dt><code>strip.left</code>:</dt><dd>
<p><code>strip.left</code> can be used to draw strips on the left of each
panel, which can be useful for wide short panels, as in
time-series (or similar) plots.  See the entry for <code>strip</code>
for detailed usage.
</p>
</dd>
<dt><code>xlab.default</code>, <code>ylab.default</code>:</dt><dd>
<p>Fallback default for <code>xlab</code> and <code>ylab</code> when they are
not specified.  If <code>NULL</code>, the defaults are parsed from the
Trellis formula.  This is rarely useful for the end-user, but
can be helpful when developing new Lattice functions.
</p>
</dd>
<dt><code>xscale.components</code>, <code>yscale.components</code>:</dt><dd>
<p>Functions that determine axis annotation for the x and y axes
respectively.  See documentation for
<code><a href="#topic+xscale.components.default">xscale.components.default</a></code>, the default values of
these arguments, to learn more.
</p>
</dd>
<dt><code>axis</code>:</dt><dd>
<p>Function responsible for drawing axis annotation.  See
documentation for <code><a href="#topic+axis.default">axis.default</a></code>, the default value
of this argument, to learn more.
</p>
</dd>
<dt><code>perm.cond</code>:</dt><dd>
<p>An integer vector, a permutation of <code>1:n</code>, where <code>n</code>
is the number of conditioning variables.  By default, the order
in which panels are drawn depends on the order of the
conditioning variables specified in the formula.
<code>perm.cond</code> can modify this order.  If the trellis display
is thought of as an <code>n</code>-dimensional array, then during
printing, its dimensions are permuted using <code>perm.cond</code> as
the <code>perm</code> argument does in <code><a href="base.html#topic+aperm">aperm</a></code>.
</p>
</dd>
<dt><code>index.cond</code>:</dt><dd>
<p>Whereas <code>perm.cond</code> permutes the dimensions of the
multidimensional array of panels, <code>index.cond</code> can be used
to subset (or reorder) margins of that array.  <code>index.cond</code>
can be a list or a function, with behavior in each case
described below.
</p>
<p>The panel display order within each conditioning variable
depends on the order of their levels.  <code>index.cond</code> can be
used to choose a &lsquo;subset&rsquo; (in the R sense) of these
levels, which is then used as the display order for that
variable.  If <code>index.cond</code> is a list, it has to be as long
as the number of conditioning variables, and the <code>i</code>-th
component has to be a valid indexing vector for
<code>levels(g_i)</code>, where <code>g_i</code> is the <code>i</code>-th
conditioning variable in the plot (note that these levels may
not contain all levels of the original variable, depending on
the effects of the <code>subset</code> and <code>drop.unused.levels</code>
arguments).  In particular, this indexing may repeat levels, or
drop some altogether.  The result of this indexing determines
the order of panels within that conditioning variable. To keep
the order of a particular variable unchanged, the corresponding
component must be set to <code>TRUE</code>.
</p>
<p>Note that the components of <code>index.cond</code> are interpreted in
the order of the conditioning variables in the original call,
and is not affected by <code>perm.cond</code>.
</p>
<p>Another possibility is to specify <code>index.cond</code> as a
function.  In this case, this function is called once for each
panel, potentially with all arguments that are passed to the
panel function for that panel.  (More specifically, if this
function has a <code>...</code> argument, then all panel arguments
are passed, otherwise, only named arguments that match are
passed.)  If there is only one conditioning variable, the levels
of that variable are then sorted so that these values are in
ascending order.  For multiple conditioning variables, the order
for each variable is determined by first taking the average over
all other conditioning variables.
</p>
<p>Although they can be supplied in high-level function calls
directly, it is more typical to use <code>perm.cond</code> and
<code>index.cond</code> to update an existing <code>"trellis"</code> object,
thus allowing it to be displayed in a different arrangement
without re-calculating the data subsets that go into each panel.
In the <code><a href="#topic+update.trellis">update.trellis</a></code> method, both can be set to
<code>NULL</code>, which reverts these back to their defaults.
</p>
</dd>
<dt><code>par.settings</code>:</dt><dd>
<p>A list that could be supplied to <code><a href="#topic+trellis.par.set">trellis.par.set</a></code>.
When the resulting object is plotted, these options are applied
temporarily for the duration of the plotting, after which the
settings revert back to what they were before.  This enables the
user to attach some display settings to the trellis object
itself rather than change the settings globally.  See also the
<code>lattice.options</code> argument described above for a similar
treatment of non-graphical options.
</p>
</dd>
<dt><code>plot.args</code>:</dt><dd>
<p>A list containing possible arguments to
<code><a href="#topic+plot.trellis">plot.trellis</a></code>, which will be used by the
<code>plot</code> or <code>print</code> methods when drawing the object,
unless overridden explicitly.  This enables the user to attach
such arguments to the trellis object itself.  Partial matching
is not performed.
</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Details</h3>

<p>The high-level functions documented here, as well as other high-level
Lattice functions, are generic, with the <code>formula</code> method usually
doing the most substantial work.  The structure of the plot that is
produced is mostly controlled by the formula (implicitly in the case
of the non-formula methods).  For each unique combination of the
levels of the conditioning variables <code>g1, g2, ...</code>, a separate
&ldquo;packet&rdquo; is produced, consisting of the points <code>(x,y)</code> for
the subset of the data defined by that combination.  The display can
be thought of as a three-dimensional array of panels, consisting of one
two-dimensional matrix per page.  The dimensions of this array are
determined by the <code>layout</code> argument.  If there are no
conditioning variables, the plot produced consists of a single packet.
Each packet usually corresponds to one panel, but this is not strictly
necessary (see the entry for <code>index.cond</code> above).
</p>
<p>The coordinate system used by <span class="pkg">lattice</span> by default is like a
graph, with the origin at the bottom left, with axes increasing to the
right and top.  In particular, panels are by default drawn starting
from the bottom left corner, going right and then up, unless
<code>as.table = TRUE</code>, in which case panels are drawn from the top
left corner, going right and then down.  It is possible to set a
global preference for the table-like arrangement by changing the
default to <code>as.table=TRUE</code>; this can be done by setting
<code>lattice.options(default.args = list(as.table = TRUE))</code>.  Default
values can be set in this manner for the following arguments:
<code>as.table</code>, <code>aspect</code>, <code>between</code>, <code>page</code>,
<code>main</code>, <code>sub</code>, <code>par.strip.text</code>, <code>layout</code>,
<code>skip</code> and <code>strip</code>.  Note that these global defaults are
sometimes overridden by individual functions.
</p>
<p>The order of the panels depends on the order in which the conditioning
variables are specified, with <code>g1</code> varying fastest, followed by
<code>g2</code>, and so on. Within a conditioning variable, the order
depends on the order of the levels (which for factors is usually in
alphabetical order).  Both of these orders can be modified using the
<code>index.cond</code> and <code>perm.cond</code> arguments, possibly using the
<code><a href="#topic+update.trellis">update</a></code> (and other related)
method(s).
</p>


<h3>Value</h3>

<p>The high-level functions documented here, as well as other high-level
Lattice functions, return an object of class <code>"trellis"</code>.  The
<code><a href="#topic+update.trellis">update</a></code> method can be used to
subsequently update components of the object, and the
<code><a href="#topic+print.trellis">print</a></code> method (usually called by
default) will plot it on an appropriate plotting device.
</p>


<h3>Note</h3>

<p>Most of the arguments documented here are also applicable for the
other high-level functions in the <span class="pkg">lattice</span> package. These are not
described in any detail elsewhere unless relevant, and this should be
considered the canonical documentation for such arguments.
</p>
<p>Any arguments passed to these functions and not recognized by them
will be passed to the panel function. Most predefined panel functions
have arguments that customize its output. These arguments are
described only in the help pages for these panel functions, but can
usually be supplied as arguments to the high-level plot.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>References</h3>

<p>Sarkar, Deepayan (2008) <em>Lattice: Multivariate Data Visualization
with R</em>, Springer.  <a href="http://lmdvr.r-forge.r-project.org/">http://lmdvr.r-forge.r-project.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lattice">Lattice</a></code> for an overview of the package, as well as
<code><a href="#topic+barchart.table">barchart.table</a></code>,
<code><a href="#topic+print.trellis">print.trellis</a></code>,
<code><a href="#topic+shingle">shingle</a></code>,
<code><a href="#topic+banking">banking</a></code>,
<code><a href="stats.html#topic+reshape">reshape</a></code>,
<code><a href="#topic+panel.xyplot">panel.xyplot</a></code>,
<code><a href="#topic+panel.bwplot">panel.bwplot</a></code>,
<code><a href="#topic+panel.barchart">panel.barchart</a></code>,
<code><a href="#topic+panel.dotplot">panel.dotplot</a></code>,
<code><a href="#topic+panel.stripplot">panel.stripplot</a></code>,
<code><a href="#topic+panel.superpose">panel.superpose</a></code>,
<code><a href="#topic+panel.loess">panel.loess</a></code>,
<code><a href="#topic+panel.average">panel.average</a></code>,
<code><a href="#topic+strip.default">strip.default</a></code>,
<code><a href="#topic+simpleKey">simpleKey</a></code>
<code><a href="#topic+trellis.par.set">trellis.par.set</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(stats)

## Tonga Trench Earthquakes

Depth &lt;- equal.count(quakes$depth, number=8, overlap=.1)
xyplot(lat ~ long | Depth, data = quakes)
update(trellis.last.object(),
       strip = strip.custom(strip.names = TRUE, strip.levels = TRUE),
       par.strip.text = list(cex = 0.75),
       aspect = "iso")

## Extended formula interface 

xyplot(Sepal.Length + Sepal.Width ~ Petal.Length + Petal.Width | Species,
       data = iris, scales = "free", layout = c(2, 2),
       auto.key = list(x = .75, y = .75, corner = c(0.5, 0.5)))

## user defined panel functions

states &lt;- data.frame(state.x77,
                     state.name = dimnames(state.x77)[[1]],
                     state.region = state.region)
xyplot(Murder ~ Population | state.region, data = states,
       snames = states$state.name,
       panel = function(x, y, subscripts, snames) {
           panel.text(x = x, y = y, labels = snames[subscripts], cex = 1,
                      fontfamily = "HersheySans")
       })

## Stacked bar chart

barchart(yield ~ variety | site, data = barley,
         groups = year, layout = c(1,6), stack = TRUE,
         auto.key = list(space = "right"),
         ylab = "Barley Yield (bushels/acre)",
         scales = list(x = list(rot = 45)))

bwplot(voice.part ~ height, data = singer, xlab = "Height (inches)")

dotplot(variety ~ yield | year * site, data=barley)

## Grouped dot plot showing anomaly at Morris

dotplot(variety ~ yield | site, data = barley, groups = year,
        key = simpleKey(levels(barley$year), space = "right"),
        xlab = "Barley Yield (bushels/acre) ",
        aspect=0.5, layout = c(1,6), ylab=NULL)

stripplot(voice.part ~ jitter(height), data = singer, aspect = 1,
          jitter.data = TRUE, xlab = "Height (inches)")

## Interaction Plot

xyplot(decrease ~ treatment, OrchardSprays, groups = rowpos,
       type = "a",
       auto.key =
       list(space = "right", points = FALSE, lines = TRUE))

## longer version with no x-ticks

## Not run: 
bwplot(decrease ~ treatment, OrchardSprays, groups = rowpos,
       panel = "panel.superpose",
       panel.groups = "panel.linejoin",
       xlab = "treatment",
       key = list(lines = Rows(trellis.par.get("superpose.line"),
                  c(1:7, 1)),
                  text = list(lab = as.character(unique(OrchardSprays$rowpos))),
                  columns = 4, title = "Row position"))

## End(Not run)

</code></pre>

<hr>
<h2 id='B_01_xyplot.ts'>Time series plotting methods</h2><span id='topic+xyplot.ts'></span>

<h3>Description</h3>

<p>This function handles time series plotting, including cut-and-stack plots.
Examples are given of superposing, juxtaposing and styling
different time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ts'
xyplot(x, data = NULL,
       screens = if (superpose) 1 else colnames(x),
       ...,
       superpose = FALSE,
       cut = FALSE,
       type = "l",
       col = NULL,
       lty = NULL,
       lwd = NULL,
       pch = NULL,
       cex = NULL,
       fill = NULL,
       auto.key = superpose,
       panel = if (superpose) "panel.superpose"
               else "panel.superpose.plain",
       par.settings = list(),
       layout = NULL, as.table = TRUE,
       xlab = "Time", ylab = NULL,
       default.scales = list(y = list(relation =
           if (missing(cut)) "free" else "same")))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="B_01_xyplot.ts_+3A_x">x</code></td>
<td>

<p>an object of class <code><a href="stats.html#topic+ts">ts</a></code>, which may be multi-variate,
i.e. have a matrix structure with multiple columns.
</p>
</td></tr>
<tr><td><code id="B_01_xyplot.ts_+3A_data">data</code></td>
<td>

<p>not used, and must be left as <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="B_01_xyplot.ts_+3A_...">...</code></td>
<td>

<p>additional arguments passed to <code><a href="#topic+xyplot">xyplot</a></code>,
which may pass them on to <code><a href="#topic+panel.xyplot">panel.xyplot</a></code>.
</p>
</td></tr>
<tr><td><code id="B_01_xyplot.ts_+3A_screens">screens</code></td>
<td>

<p>factor (or coerced to factor) whose levels specify which
panel each series is to be plotted in.  <code>screens = c(1, 2, 1)</code>
would plot series 1, 2 and 3 in panels 1, 2 and 1. May also be a
named list, see Details below.
</p>
</td></tr>
<tr><td><code id="B_01_xyplot.ts_+3A_superpose">superpose</code></td>
<td>

<p>overlays all series in one panel (via <code>screens = 1</code>) and uses
grouped style settings (from
<code>trellis.par.get("superpose.line")</code>, etc). Note that this is
just a convenience argument: its only action is to change the
default values of other arguments.
</p>
</td></tr>
<tr><td><code id="B_01_xyplot.ts_+3A_cut">cut</code></td>
<td>

<p>defines a cut-and-stack plot. <code>cut</code> can be a <code>list</code> of
arguments to the function <code><a href="#topic+equal.count">equal.count</a></code>,
i.e. <code>number</code> (number of intervals to divide into)
and <code>overlap</code> (the fraction of overlap between cuts, default
0.5). If <code>cut</code> is numeric this is passed as the
<code>number</code> argument.
</p>
<p><code>cut = TRUE</code> tries to choose an appropriate number of cuts (up
to a maximum of 6), using <code><a href="#topic+banking">banking</a></code>, and assuming a square
plot region. This should have the effect of minimising wasted space
when <code>aspect = "xy"</code>.
</p>
</td></tr>
<tr><td><code id="B_01_xyplot.ts_+3A_type">type</code>, <code id="B_01_xyplot.ts_+3A_col">col</code>, <code id="B_01_xyplot.ts_+3A_lty">lty</code>, <code id="B_01_xyplot.ts_+3A_lwd">lwd</code>, <code id="B_01_xyplot.ts_+3A_pch">pch</code>, <code id="B_01_xyplot.ts_+3A_cex">cex</code>, <code id="B_01_xyplot.ts_+3A_fill">fill</code></td>
<td>

<p>graphical arguments, which are processed and eventually passed to
<code><a href="#topic+panel.xyplot">panel.xyplot</a></code>.
These arguments can also be vectors or (named) lists, see Details
for more information.
</p>
</td></tr>
<tr><td><code id="B_01_xyplot.ts_+3A_auto.key">auto.key</code></td>
<td>

<p>a logical, or a list describing how to draw a key. See the
<code>auto.key</code> entry in <code><a href="#topic+xyplot">xyplot</a></code>. The default here is
to draw lines, not points, and any specified style arguments should
show up automatically.
</p>
</td></tr>
<tr><td><code id="B_01_xyplot.ts_+3A_panel">panel</code></td>
<td>

<p>the panel function. It is recommended to leave this alone, but one
can pass a <code>panel.groups</code> argument which is handled by
<code><a href="#topic+panel.superpose">panel.superpose</a></code> for each series. 
</p>
</td></tr>
<tr><td><code id="B_01_xyplot.ts_+3A_par.settings">par.settings</code></td>
<td>

<p>style settings beyond the standard <code>col</code>, <code>lty</code>,
<code>lwd</code>, etc; see <code><a href="#topic+trellis.par.set">trellis.par.set</a></code> and
<code><a href="#topic+simpleTheme">simpleTheme</a></code>.
</p>
</td></tr>
<tr><td><code id="B_01_xyplot.ts_+3A_layout">layout</code></td>
<td>

<p>numeric vector of length 2 specifying number of columns and rows in
the plot. The default is to fill columns with up to 6 rows.
</p>
</td></tr>
<tr><td><code id="B_01_xyplot.ts_+3A_as.table">as.table</code></td>
<td>

<p>to draw panels from top to bottom. The order is determined by the
order of columns in <code>x</code>.
</p>
</td></tr>
<tr><td><code id="B_01_xyplot.ts_+3A_xlab">xlab</code>, <code id="B_01_xyplot.ts_+3A_ylab">ylab</code></td>
<td>

<p>X axis and Y axis labels; see <code><a href="#topic+xyplot">xyplot</a></code>. Note in
particular that <code>ylab</code> may be a character vector, in which case the
labels are spaced out equally, to correspond to the panels;
but <em>NOTE</em> in this case the vector should be reversed OR the
argument <code>as.table</code> set to <code>FALSE</code>. 
</p>
</td></tr>
<tr><td><code id="B_01_xyplot.ts_+3A_default.scales">default.scales</code></td>
<td>

<p><code>scales</code> specification. The default is set to have
<code>"free"</code> Y axis scales unless <code>cut</code> is given.
Note, users should pass the <code>scales</code> argument rather than
<code>default.scales</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The handling of several graphical parameters is more
flexible for multivariate series. These parameters can be
vectors of the same length as the number of series plotted or
are recycled if shorter. They can also be (partially) named list, e.g.,
<code>list(A = c(1,2), c(3,4))</code> in which <code>c(3, 4)</code> is the
default value and <code>c(1, 2)</code> the value only for series <code>A</code>.
The <code>screens</code> argument can be specified in a similar way.
</p>

<p>Some examples are given below.
</p>


<h3>Value</h3>

<p>An object of class <code>"trellis"</code>. The
<code><a href="#topic+update.trellis">update</a></code> method can be used to
update components of the object and the
<code><a href="#topic+print.trellis">print</a></code> method (usually called by
default) will plot it on an appropriate plotting device.
</p>


<h3>Author(s)</h3>

<p>Gabor Grothendieck, Achim Zeileis, Deepayan Sarkar and Felix Andrews
<a href="mailto:felix@nfrac.org">felix@nfrac.org</a>.
</p>
<p>The first two authors developed <code>xyplot.ts</code> in their <span class="pkg">zoo</span>
package, including the <code>screens</code> approach. The third author
developed a different <code>xyplot.ts</code> for cut-and-stack plots in the
<span class="pkg">latticeExtra</span> package. The final author fused these together.
</p>


<h3>References</h3>

<p>Sarkar, Deepayan (2008) <em>Lattice: Multivariate Data
Visualization with R</em>, Springer.
<a href="http://lmdvr.r-forge.r-project.org/">http://lmdvr.r-forge.r-project.org/</a> (cut-and-stack plots)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xyplot">xyplot</a></code>,
<code><a href="#topic+panel.xyplot">panel.xyplot</a></code>,
<code><a href="stats.html#topic+plot.ts">plot.ts</a></code>,
<code><a href="stats.html#topic+ts">ts</a></code>,
<code><a href="zoo.html#topic+xyplot.zoo">xyplot.zoo</a></code> in the <span class="pkg">zoo</span> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xyplot(ts(c(1:10,10:1)))

### Figure 14.1 from Sarkar (2008)
xyplot(sunspot.year, aspect = "xy",
       strip = FALSE, strip.left = TRUE,
       cut = list(number = 4, overlap = 0.05))

### A multivariate example; first juxtaposed, then superposed
xyplot(EuStockMarkets, scales = list(y = "same"))
xyplot(EuStockMarkets, superpose = TRUE, aspect = "xy", lwd = 2,
    type = c("l","g"), ylim = c(0, max(EuStockMarkets)))

### Examples using screens (these two are identical)
xyplot(EuStockMarkets, screens = c(rep("Continental", 3), "UK"))
xyplot(EuStockMarkets, screens = list(FTSE = "UK", "Continental"))

### Automatic group styles
xyplot(EuStockMarkets, screens = list(FTSE = "UK", "Continental"),
    superpose = TRUE)

xyplot(EuStockMarkets, screens = list(FTSE = "UK", "Continental"),
    superpose = TRUE, xlim = extendrange(1996:1998),
    par.settings = standard.theme(color = FALSE))

### Specifying styles for series by name
xyplot(EuStockMarkets, screens = list(FTSE = "UK", "Continental"),
    col = list(DAX = "red", FTSE = "blue", "black"), auto.key = TRUE)

xyplot(EuStockMarkets, screens = list(FTSE = "UK", "Continental"),
    col = list(DAX = "red"), lty = list(SMI = 2), lwd = 1:2,
    auto.key = TRUE)

### Example with simpler data, few data points
set.seed(1)
z &lt;- ts(cbind(a = 1:5, b = 11:15, c = 21:25) + rnorm(5))
xyplot(z, screens = 1)
xyplot(z, screens = list(a = "primary (a)", "other (b &amp; c)"),
  type = list(a = c("p", "h"), b = c("p", "s"), "o"),
  pch = list(a = 2, c = 3), auto.key = list(type = "o"))
</code></pre>

<hr>
<h2 id='B_02_barchart.table'>table methods for barchart and dotplot</h2><span id='topic+barchart.table'></span><span id='topic+barchart.array'></span><span id='topic+barchart.matrix'></span><span id='topic+dotplot.table'></span><span id='topic+dotplot.array'></span><span id='topic+dotplot.matrix'></span>

<h3>Description</h3>

<p>Contingency tables are often displayed using bar charts and dot plots.
These methods operate directly on tables, bypassing the need to
convert them to data frames for use with the formula interface.
Matrices and arrays are also supported, by coercing them to tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'table'
barchart(x, data, groups = TRUE,
         origin = 0, stack = TRUE, ..., horizontal = TRUE)

## S3 method for class 'array'
barchart(x, data, ...)

## S3 method for class 'matrix'
barchart(x, data, ...)

## S3 method for class 'table'
dotplot(x, data, groups = TRUE, ..., horizontal = TRUE)

## S3 method for class 'array'
dotplot(x, data, ...)

## S3 method for class 'matrix'
dotplot(x, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="B_02_barchart.table_+3A_x">x</code></td>
<td>

<p>A <code>table</code>, <code>array</code> or <code>matrix</code> object.
</p>
</td></tr>
<tr><td><code id="B_02_barchart.table_+3A_data">data</code></td>
<td>

<p>Should not be specified. If specified, will be ignored with a
warning.
</p>
</td></tr>
<tr><td><code id="B_02_barchart.table_+3A_groups">groups</code></td>
<td>

<p>A logical flag, indicating whether to use the last dimension as a
grouping variable in the display.
</p>
</td></tr>
<tr><td><code id="B_02_barchart.table_+3A_origin">origin</code>, <code id="B_02_barchart.table_+3A_stack">stack</code></td>
<td>

<p>Arguments to <code><a href="#topic+panel.barchart">panel.barchart</a></code>.  The defaults for the
<code>table</code> method are different.
</p>
</td></tr>
<tr><td><code id="B_02_barchart.table_+3A_horizontal">horizontal</code></td>
<td>

<p>Logical flag, indicating whether the plot should be horizontal (with
the categorical variable on the y-axis) or vertical.
</p>
</td></tr>
<tr><td><code id="B_02_barchart.table_+3A_...">...</code></td>
<td>

<p>Other arguments, passed to the underlying <code>formula</code> method.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first dimension is used as the variable on the categorical axis.
The last dimension is optionally used as a grouping variable (to
produce stacked barcharts by default).  All other dimensions are used
as conditioning variables.  The order of these variables cannot be
altered (except by permuting the original argument beforehand using
<code><a href="base.html#topic+t">t</a></code> or <code><a href="base.html#topic+aperm">aperm</a></code>).  For more flexibility, use
the formula method after converting the table to a data frame using
the relevant <code><a href="base.html#topic+table">as.data.frame</a></code> method.
</p>


<h3>Value</h3>

<p>An object of class <code>"trellis"</code>. The
<code><a href="#topic+update.trellis">update</a></code> method can be used to
update components of the object and the
<code><a href="#topic+print.trellis">print</a></code> method (usually called by
default) will plot it on an appropriate plotting device.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+barchart">barchart</a></code>, <code><a href="base.html#topic+t">t</a></code>, <code><a href="base.html#topic+aperm">aperm</a></code>,
<code><a href="base.html#topic+table">table</a></code>, <code><a href="#topic+panel.barchart">panel.barchart</a></code>,
<code><a href="#topic+Lattice">Lattice</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>barchart(Titanic, scales = list(x = "free"),
         auto.key = list(title = "Survived"))
</code></pre>

<hr>
<h2 id='B_03_histogram'>Histograms and Kernel Density Plots</h2><span id='topic+histogram'></span><span id='topic+histogram.factor'></span><span id='topic+histogram.numeric'></span><span id='topic+histogram.formula'></span><span id='topic+histogram.data.frame'></span><span id='topic+densityplot'></span><span id='topic+densityplot.numeric'></span><span id='topic+densityplot.formula'></span><span id='topic+densityplot.data.frame'></span><span id='topic+do.breaks'></span>

<h3>Description</h3>

<p>Draw Histograms and Kernel Density Plots, possibly conditioned on
other variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
histogram(x, data, ...)
densityplot(x, data, ...)

## S3 method for class 'formula'
histogram(x,
          data,
          allow.multiple, outer = TRUE,
          auto.key = lattice.getOption("default.args")$auto.key,
          aspect = "fill",
          panel = lattice.getOption("panel.histogram"),
          prepanel, scales, strip, groups,
          xlab, xlim, ylab, ylim,
          type = c("percent", "count", "density"),
          nint = if (is.factor(x)) nlevels(x)
          else round(log2(length(x)) + 1),
          endpoints = extend.limits(range(as.numeric(x),
                          finite = TRUE), prop = 0.04),
          breaks,
          equal.widths = TRUE,
          drop.unused.levels =
              lattice.getOption("drop.unused.levels"),
          ...,
          lattice.options = NULL,
          default.scales = list(),
          default.prepanel =
              lattice.getOption("prepanel.default.histogram"),
          subscripts,
          subset)

## S3 method for class 'data.frame'
histogram(x, data = NULL, formula = data, ...)

## S3 method for class 'numeric'
histogram(x, data = NULL, xlab, ...)

## S3 method for class 'factor'
histogram(x, data = NULL, xlab, ...)

## S3 method for class 'formula'
densityplot(x,
            data,
            allow.multiple = is.null(groups) || outer,
            outer = !is.null(groups),
            auto.key = lattice.getOption("default.args")$auto.key,
            aspect = "fill",
            panel = lattice.getOption("panel.densityplot"),
            prepanel, scales, strip, groups, weights,
            xlab, xlim, ylab, ylim,
            bw, adjust, kernel, window, width, give.Rkern,
            n = 512, from, to, cut, na.rm,
            drop.unused.levels =
                lattice.getOption("drop.unused.levels"),
            ...,
            lattice.options = NULL,
            default.scales = list(),
            default.prepanel =
                lattice.getOption("prepanel.default.densityplot"),
            subscripts,
            subset)

## S3 method for class 'data.frame'
densityplot(x, data = NULL, formula = data, ...)

## S3 method for class 'numeric'
densityplot(x, data = NULL, xlab, ...)

do.breaks(endpoints, nint)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="B_03_histogram_+3A_x">x</code></td>
<td>

<p>The object on which method dispatch is carried out.
</p>
<p>For the <code>formula</code> method, <code>x</code> can be a formula of the form
<code>~ x | g1 * g2 * ...</code>, indicating that histograms or kernel
density estimates of the <code>x</code> variable should be produced
conditioned on the levels of the (optional) variables <code>g1</code>,
<code>g2</code>, ....  <code>x</code> should be numeric (or possibly a factor
in the case of <code>histogram</code>), and each of <code>g1</code>, <code>g2</code>,
... should be either factors or shingles.
</p>
<p>As a special case, the right hand side of the formula can contain
more than one term separated by &lsquo;+&rsquo; signs (e.g., <code>~ x1 +
    x2 | g1 * g2</code>).  What happens in this case is described in the
documentation for <code><a href="#topic+xyplot">xyplot</a></code>.  Note that in either form,
all the terms in the formula must have the same length after
evaluation.
</p>
<p>For the <code>numeric</code> and <code>factor</code> methods, <code>x</code> is the
variable whose histogram or Kernel density estimate is drawn.
Conditioning is not allowed in these cases.
</p>
</td></tr>
<tr><td><code id="B_03_histogram_+3A_data">data</code></td>
<td>

<p>For the <code>formula</code> method, an optional data source (usually a
data frame) in which variables are to be evaluated (see
<code><a href="#topic+xyplot">xyplot</a></code> for details).  <code>data</code> should not be
specified for the other methods, and is ignored with a warning if it
is.
</p>
</td></tr>
<tr><td><code id="B_03_histogram_+3A_formula">formula</code></td>
<td>

<p>The formula to be used for the <code>"data.frame"</code> methods. See
documentation for argument <code>x</code> for details.
</p>
</td></tr>
<tr><td><code id="B_03_histogram_+3A_type">type</code></td>
<td>

<p>A character string indicating the type of histogram that is to be
drawn.  <code>"percent"</code> and <code>"count"</code> give relative frequency
and frequency histograms respectively, and can be misleading when
breakpoints are not equally spaced. <code>"density"</code> produces a
density histogram.
</p>
<p><code>type</code> defaults to <code>"density"</code> when the breakpoints are
unequally spaced, and when <code>breaks</code> is <code>NULL</code> or a
function, and to <code>"percent"</code> otherwise.
</p>
</td></tr>
<tr><td><code id="B_03_histogram_+3A_nint">nint</code></td>
<td>

<p>An integer specifying the number of histogram bins, applicable only
when <code>breaks</code> is unspecified or <code>NULL</code> in the call.
Ignored when the variable being plotted is a factor.
</p>
</td></tr>
<tr><td><code id="B_03_histogram_+3A_endpoints">endpoints</code></td>
<td>

<p>A numeric vector of length 2 indicating the range of x-values that
is to be covered by the histogram.  This applies only when
<code>breaks</code> is unspecified and the variable being plotted is not a
factor.  In <code>do.breaks</code>, this specifies the interval that is to
be divided up.
</p>
</td></tr>
<tr><td><code id="B_03_histogram_+3A_breaks">breaks</code></td>
<td>

<p>Usually a numeric vector of length (number of bins + 1) defining the
breakpoints of the bins.  Note that when breakpoints are not equally
spaced, the only value of <code>type</code> that makes sense is density.
</p>
<p>When <code>breaks</code> is unspecified, the value of
<code>lattice.getOption("histogram.breaks")</code> is first checked.  If
this value is <code>NULL</code>, then the default is to use
</p>
<pre>
      breaks = seq_len(1 + nlevels(x)) - 0.5
    </pre>
<p>when <code>x</code> is a factor, and 
</p>
<pre>
      breaks = do.breaks(endpoints, nint)
    </pre>
<p>otherwise.  Breakpoints calculated in such a manner are used in all
panels.  If the retrieved value is not <code>NULL</code>, or if
<code>breaks</code> is explicitly specified, it affects the display in
each panel independently.  Valid values are those accepted as the
<code>breaks</code> argument in <code><a href="graphics.html#topic+hist">hist</a></code>.  In particular, this
allows specification of <code>breaks</code> as an integer giving the
number of bins (similar to <code>nint</code>), as a character string
denoting a method, or as a function.
</p>
<p>When specified explicitly, a special value of <code>breaks</code> is
<code>NULL</code>, in which case the number of bins is determined by
<code>nint</code> and then breakpoints are chosen according to the value
of <code>equal.widths</code>.
</p>
</td></tr>
<tr><td><code id="B_03_histogram_+3A_equal.widths">equal.widths</code></td>
<td>

<p>A logical flag, relevant only when <code>breaks=NULL</code>.  If
<code>TRUE</code>, equally spaced bins will be selected, otherwise,
approximately equal area bins will be selected (typically producing
unequally spaced breakpoints).
</p>
</td></tr>
<tr><td><code id="B_03_histogram_+3A_n">n</code></td>
<td>

<p>Integer, giving the number of points at which the kernel density is
to be evaluated.  Passed on as an argument to <code><a href="stats.html#topic+density">density</a></code>.
</p>
</td></tr>
<tr><td><code id="B_03_histogram_+3A_panel">panel</code></td>
<td>

<p>A function, called once for each panel, that uses the packet (subset
of panel variables) corresponding to the panel to create a display.
The default panel functions <code><a href="#topic+panel.histogram">panel.histogram</a></code> and
<code><a href="#topic+panel.densityplot">panel.densityplot</a></code> are documented separately, and have
arguments that can be used to customize its output in various ways.
Such arguments can usually be directly supplied to the high-level
function.
</p>
</td></tr>
<tr><td><code id="B_03_histogram_+3A_allow.multiple">allow.multiple</code>, <code id="B_03_histogram_+3A_outer">outer</code></td>
<td>
<p> See <code><a href="#topic+xyplot">xyplot</a></code>. </p>
</td></tr>
<tr><td><code id="B_03_histogram_+3A_auto.key">auto.key</code></td>
<td>
<p> See <code><a href="#topic+xyplot">xyplot</a></code>. </p>
</td></tr>
<tr><td><code id="B_03_histogram_+3A_aspect">aspect</code></td>
<td>
<p> See <code><a href="#topic+xyplot">xyplot</a></code>. </p>
</td></tr>
<tr><td><code id="B_03_histogram_+3A_prepanel">prepanel</code></td>
<td>
<p> See <code><a href="#topic+xyplot">xyplot</a></code>. </p>
</td></tr>
<tr><td><code id="B_03_histogram_+3A_scales">scales</code></td>
<td>
<p> See <code><a href="#topic+xyplot">xyplot</a></code>. </p>
</td></tr>
<tr><td><code id="B_03_histogram_+3A_strip">strip</code></td>
<td>
<p> See <code><a href="#topic+xyplot">xyplot</a></code>. </p>
</td></tr>
<tr><td><code id="B_03_histogram_+3A_groups">groups</code></td>
<td>

<p>See <code><a href="#topic+xyplot">xyplot</a></code>.  Note that the default panel function for
<code>histogram</code> does not support grouped displays, whereas the one
for <code>densityplot</code> does.
</p>
</td></tr>
<tr><td><code id="B_03_histogram_+3A_xlab">xlab</code>, <code id="B_03_histogram_+3A_ylab">ylab</code></td>
<td>
<p> See <code><a href="#topic+xyplot">xyplot</a></code>. </p>
</td></tr>
<tr><td><code id="B_03_histogram_+3A_xlim">xlim</code>, <code id="B_03_histogram_+3A_ylim">ylim</code></td>
<td>
<p> See <code><a href="#topic+xyplot">xyplot</a></code>. </p>
</td></tr>
<tr><td><code id="B_03_histogram_+3A_drop.unused.levels">drop.unused.levels</code></td>
<td>
<p> See <code><a href="#topic+xyplot">xyplot</a></code>. </p>
</td></tr>
<tr><td><code id="B_03_histogram_+3A_lattice.options">lattice.options</code></td>
<td>
<p> See <code><a href="#topic+xyplot">xyplot</a></code>. </p>
</td></tr>
<tr><td><code id="B_03_histogram_+3A_default.scales">default.scales</code></td>
<td>
<p> See <code><a href="#topic+xyplot">xyplot</a></code>. </p>
</td></tr>
<tr><td><code id="B_03_histogram_+3A_subscripts">subscripts</code></td>
<td>
<p> See <code><a href="#topic+xyplot">xyplot</a></code>. </p>
</td></tr>
<tr><td><code id="B_03_histogram_+3A_subset">subset</code></td>
<td>
<p> See <code><a href="#topic+xyplot">xyplot</a></code>. </p>
</td></tr>
<tr><td><code id="B_03_histogram_+3A_default.prepanel">default.prepanel</code></td>
<td>

<p>Fallback prepanel function.  See <code><a href="#topic+xyplot">xyplot</a></code>.
</p>
</td></tr>
<tr><td><code id="B_03_histogram_+3A_weights">weights</code></td>
<td>
<p> numeric vector of weights for the density
calculations, evaluated in the non-standard manner used for
<code>groups</code> and terms in the formula, if any.  If this is
specified, it is subsetted using <code>subscripts</code> inside the panel
function to match it to the corresponding <code>x</code> values.
</p>
<p>At the time of writing, <code>weights</code> do not work in conjunction
with an extended formula specification (this is not too hard to fix,
so just bug the maintainer if you need this feature).
</p>
</td></tr>
<tr><td><code id="B_03_histogram_+3A_bw">bw</code>, <code id="B_03_histogram_+3A_adjust">adjust</code>, <code id="B_03_histogram_+3A_width">width</code></td>
<td>

<p>Arguments controlling bandwidth.  Passed on as arguments to
<code><a href="stats.html#topic+density">density</a></code>.
</p>
</td></tr>
<tr><td><code id="B_03_histogram_+3A_kernel">kernel</code>, <code id="B_03_histogram_+3A_window">window</code></td>
<td>

<p>The choice of kernel.  Passed on as arguments to
<code><a href="stats.html#topic+density">density</a></code>.  
</p>
</td></tr>
<tr><td><code id="B_03_histogram_+3A_give.rkern">give.Rkern</code></td>
<td>

<p>Logical flag, passed on as argument to <code><a href="stats.html#topic+density">density</a></code>.
This argument is made available only for ease of implementation, and
will produce an error if <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="B_03_histogram_+3A_from">from</code>, <code id="B_03_histogram_+3A_to">to</code>, <code id="B_03_histogram_+3A_cut">cut</code></td>
<td>
 
<p>Controls range over which density is evaluated.  Passed on as
arguments to <code><a href="stats.html#topic+density">density</a></code>.
</p>
</td></tr>
<tr><td><code id="B_03_histogram_+3A_na.rm">na.rm</code></td>
<td>

<p>Logical flag specifying whether <code>NA</code> values should be ignored.
Passed on as argument to <code><a href="stats.html#topic+density">density</a></code>, but unlike in
<code>density</code>, the default is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="B_03_histogram_+3A_...">...</code></td>
<td>
<p> Further arguments.  See corresponding entry in
<code><a href="#topic+xyplot">xyplot</a></code> for non-trivial details.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>histogram</code> draws Conditional Histograms, and <code>densityplot</code>
draws Conditional Kernel Density Plots.  The default panel function
uses the <code><a href="stats.html#topic+density">density</a></code> function to compute the density
estimate, and all arguments accepted by <code>density</code> can be
specified in the call to <code>densityplot</code> to control the output.
See documentation of <code>density</code> for details.
</p>
<p>These and all other high level Trellis functions have several
arguments in common. These are extensively documented only in the
help page for <code>xyplot</code>, which should be consulted to learn more
detailed usage.
</p>
<p><code>do.breaks</code> is an utility function that calculates breakpoints
given an interval and the number of pieces to break it into.
</p>


<h3>Value</h3>

<p>An object of class <code>"trellis"</code>. The
<code><a href="#topic+update.trellis">update</a></code> method can be used to
update components of the object and the
<code><a href="#topic+print.trellis">print</a></code> method (usually called by
default) will plot it on an appropriate plotting device.
</p>


<h3>Note</h3>

<p>The form of the arguments accepted by the default panel function
<code>panel.histogram</code> is different from that in S-PLUS. Whereas
S-PLUS calculates the heights inside <code>histogram</code> and passes only
the breakpoints and the heights to the panel function, <span class="pkg">lattice</span>
simply passes along the original variable <code>x</code> along with the
breakpoints. This approach is more flexible; see the example below
with an estimated density superimposed over the histogram.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>References</h3>

<p>Sarkar, Deepayan (2008) <em>Lattice: Multivariate Data
Visualization with R</em>, Springer.
<a href="http://lmdvr.r-forge.r-project.org/">http://lmdvr.r-forge.r-project.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xyplot">xyplot</a></code>,
<code><a href="#topic+panel.histogram">panel.histogram</a></code>,
<code><a href="stats.html#topic+density">density</a></code>,
<code><a href="#topic+panel.densityplot">panel.densityplot</a></code>,
<code><a href="#topic+panel.mathdensity">panel.mathdensity</a></code>,
<code><a href="#topic+Lattice">Lattice</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(stats)
histogram( ~ height | voice.part, data = singer, nint = 17,
          endpoints = c(59.5, 76.5), layout = c(2,4), aspect = 1,
          xlab = "Height (inches)")

histogram( ~ height | voice.part, data = singer,
          xlab = "Height (inches)", type = "density",
          panel = function(x, ...) {
              panel.histogram(x, ...)
              panel.mathdensity(dmath = dnorm, col = "black",
                                args = list(mean=mean(x),sd=sd(x)))
          } )

densityplot( ~ height | voice.part, data = singer, layout = c(2, 4),  
            xlab = "Height (inches)", bw = 5)
</code></pre>

<hr>
<h2 id='B_04_qqmath'>Q-Q Plot with Theoretical Distribution</h2><span id='topic+qqmath'></span><span id='topic+qqmath.formula'></span><span id='topic+qqmath.data.frame'></span><span id='topic+qqmath.numeric'></span>

<h3>Description</h3>

<p>Draw quantile-Quantile plots of a sample against a theoretical
distribution, possibly conditioned on other variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qqmath(x, data, ...)

## S3 method for class 'formula'
qqmath(x,
       data,
       allow.multiple = is.null(groups) || outer,
       outer = !is.null(groups),
       distribution = qnorm,
       f.value = NULL,
       auto.key = lattice.getOption("default.args")$auto.key,
       aspect = "fill",
       panel = lattice.getOption("panel.qqmath"),
       prepanel = NULL,
       scales, strip, groups,
       xlab, xlim, ylab, ylim,
       drop.unused.levels = lattice.getOption("drop.unused.levels"),
       ...,
       lattice.options = NULL,
       default.scales = list(),
       default.prepanel = lattice.getOption("prepanel.default.qqmath"),
       subscripts,
       subset)

## S3 method for class 'data.frame'
qqmath(x, data = NULL, formula = data, ...)

## S3 method for class 'numeric'
qqmath(x, data = NULL, ylab, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="B_04_qqmath_+3A_x">x</code></td>
<td>

<p>The object on which method dispatch is carried out.
</p>
<p>For the <code>"formula"</code> method, <code>x</code> should be a formula of the
form <code>~ x | g1 * g2 * ...</code>, where <code>x</code> should be a
numeric variable.  For the <code>"numeric"</code> method, <code>x</code> should
be a numeric vector.
</p>
</td></tr>
<tr><td><code id="B_04_qqmath_+3A_data">data</code></td>
<td>

<p>For the <code>formula</code> method, an optional data source (usually a
data frame) in which variables are to be evaluated (see
<code><a href="#topic+xyplot">xyplot</a></code> for details).  <code>data</code> should not be
specified for the other methods, and is ignored with a warning if it
is.
</p>
</td></tr>
<tr><td><code id="B_04_qqmath_+3A_formula">formula</code></td>
<td>

<p>The formula to be used for the <code>"data.frame"</code> methods. See
documentation for argument <code>x</code> for details.
</p>
</td></tr>
<tr><td><code id="B_04_qqmath_+3A_distribution">distribution</code></td>
<td>

<p>A quantile function that takes a vector of probabilities as argument
and produces the corresponding quantiles from a theoretical
distribution.  Possible values are <code><a href="stats.html#topic+qnorm">qnorm</a></code>,
<code><a href="stats.html#topic+qunif">qunif</a></code>, etc.  Distributions with other required
arguments need to be provided as user-defined functions (see example
with <code><a href="stats.html#topic+qt">qt</a></code>).
</p>
</td></tr>
<tr><td><code id="B_04_qqmath_+3A_f.value">f.value</code></td>
<td>

<p>An optional numeric vector of probabilities, quantiles corresponding
to which should be plotted.  This can also be a function of a single
integer (representing sample size) that returns such a numeric
vector.  A typical value for this argument is the function
<code>ppoints</code>, which is also the S-PLUS default.  If specified, the
probabilities generated by this function is used for the plotted
quantiles, through the <code><a href="stats.html#topic+quantile">quantile</a></code> function for the
sample, and the function specified as the <code>distribution</code>
argument for the theoretical distribution.
</p>
<p><code>f.value</code> defaults to <code>NULL</code>, which has the effect of
using <code>ppoints</code> for the quantiles of the theoretical
distribution, but the exact data values for the sample.  This is
similar to what happens for <code>qqnorm</code>, but different from the
S-PLUS default of <code>f.value=ppoints</code>.
</p>
<p>For large <code>x</code>, this argument can be used to restrict the number
of points plotted.  See also the <code>tails.n</code> argument in
<code><a href="#topic+panel.qqmath">panel.qqmath</a></code>.
</p>
</td></tr>
<tr><td><code id="B_04_qqmath_+3A_panel">panel</code></td>
<td>

<p>A function, called once for each panel, that uses the packet (subset
of panel variables) corresponding to the panel to create a display.
The default panel function <code><a href="#topic+panel.qqmath">panel.qqmath</a></code> is documented
separately, and has arguments that can be used to customize its
output in various ways.  Such arguments can usually be directly
supplied to the high-level function.
</p>
</td></tr>
<tr><td><code id="B_04_qqmath_+3A_allow.multiple">allow.multiple</code>, <code id="B_04_qqmath_+3A_outer">outer</code></td>
<td>
<p> See <code><a href="#topic+xyplot">xyplot</a></code>. </p>
</td></tr>
<tr><td><code id="B_04_qqmath_+3A_auto.key">auto.key</code></td>
<td>
<p> See <code><a href="#topic+xyplot">xyplot</a></code>. </p>
</td></tr>
<tr><td><code id="B_04_qqmath_+3A_aspect">aspect</code></td>
<td>
<p> See <code><a href="#topic+xyplot">xyplot</a></code>. </p>
</td></tr>
<tr><td><code id="B_04_qqmath_+3A_prepanel">prepanel</code></td>
<td>
<p> See <code><a href="#topic+xyplot">xyplot</a></code>. </p>
</td></tr>
<tr><td><code id="B_04_qqmath_+3A_scales">scales</code></td>
<td>
<p> See <code><a href="#topic+xyplot">xyplot</a></code>. </p>
</td></tr>
<tr><td><code id="B_04_qqmath_+3A_strip">strip</code></td>
<td>
<p> See <code><a href="#topic+xyplot">xyplot</a></code>. </p>
</td></tr>
<tr><td><code id="B_04_qqmath_+3A_groups">groups</code></td>
<td>
<p> See <code><a href="#topic+xyplot">xyplot</a></code>.  </p>
</td></tr>
<tr><td><code id="B_04_qqmath_+3A_xlab">xlab</code>, <code id="B_04_qqmath_+3A_ylab">ylab</code></td>
<td>
<p> See <code><a href="#topic+xyplot">xyplot</a></code>. </p>
</td></tr>
<tr><td><code id="B_04_qqmath_+3A_xlim">xlim</code>, <code id="B_04_qqmath_+3A_ylim">ylim</code></td>
<td>
<p> See <code><a href="#topic+xyplot">xyplot</a></code>. </p>
</td></tr>
<tr><td><code id="B_04_qqmath_+3A_drop.unused.levels">drop.unused.levels</code></td>
<td>
<p> See <code><a href="#topic+xyplot">xyplot</a></code>. </p>
</td></tr>
<tr><td><code id="B_04_qqmath_+3A_lattice.options">lattice.options</code></td>
<td>
<p> See <code><a href="#topic+xyplot">xyplot</a></code>. </p>
</td></tr>
<tr><td><code id="B_04_qqmath_+3A_default.scales">default.scales</code></td>
<td>
<p> See <code><a href="#topic+xyplot">xyplot</a></code>. </p>
</td></tr>
<tr><td><code id="B_04_qqmath_+3A_subscripts">subscripts</code></td>
<td>
<p> See <code><a href="#topic+xyplot">xyplot</a></code>. </p>
</td></tr>
<tr><td><code id="B_04_qqmath_+3A_subset">subset</code></td>
<td>
<p> See <code><a href="#topic+xyplot">xyplot</a></code>. </p>
</td></tr>
<tr><td><code id="B_04_qqmath_+3A_default.prepanel">default.prepanel</code></td>
<td>

<p>Fallback prepanel function.  See <code><a href="#topic+xyplot">xyplot</a></code>.
</p>
</td></tr>
<tr><td><code id="B_04_qqmath_+3A_...">...</code></td>
<td>

<p>Further arguments.  See corresponding entry in <code><a href="#topic+xyplot">xyplot</a></code>
for non-trivial details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>qqmath</code> produces Q-Q plots of the given sample against a
theoretical distribution.  The default behaviour of <code>qqmath</code> is
different from the corresponding S-PLUS function, but is similar to
<code>qqnorm</code>.  See the entry for <code>f.value</code> for specifics.
</p>
<p>The implementation details are also different from S-PLUS.  In
particular, all the important calculations are done by the panel (and
prepanel function) and not <code>qqmath</code> itself.  In fact, both the
arguments <code>distribution</code> and <code>f.value</code> are passed unchanged
to the panel and prepanel function.  This allows, among other things,
display of grouped Q-Q plots, which are often useful.  See the help
page for <code><a href="#topic+panel.qqmath">panel.qqmath</a></code> for further details.
</p>
<p>This and all other high level Trellis functions have several arguments
in common. These are extensively documented only in the help page for
<code><a href="#topic+xyplot">xyplot</a></code>, which should be consulted to learn more detailed
usage.
</p>


<h3>Value</h3>

<p>An object of class <code>"trellis"</code>. The
<code><a href="#topic+update.trellis">update</a></code> method can be used to
update components of the object and the
<code><a href="#topic+print.trellis">print</a></code> method (usually called by
default) will plot it on an appropriate plotting device.
</p>


<h3>Author(s)</h3>

<p>Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+xyplot">xyplot</a></code>, <code><a href="#topic+panel.qqmath">panel.qqmath</a></code>,
<code><a href="#topic+panel.qqmathline">panel.qqmathline</a></code>, <code><a href="#topic+prepanel.qqmathline">prepanel.qqmathline</a></code>,
<code><a href="#topic+Lattice">Lattice</a></code>, <code><a href="stats.html#topic+quantile">quantile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qqmath(~ rnorm(100), distribution = function(p) qt(p, df = 10))
qqmath(~ height | voice.part, aspect = "xy", data = singer,
       prepanel = prepanel.qqmathline,
       panel = function(x, ...) {
          panel.qqmathline(x, ...)
          panel.qqmath(x, ...)
       })
vp.comb &lt;-
    factor(sapply(strsplit(as.character(singer$voice.part), split = " "),
                  "[", 1),
           levels = c("Bass", "Tenor", "Alto", "Soprano"))
vp.group &lt;-
    factor(sapply(strsplit(as.character(singer$voice.part), split = " "),
                  "[", 2))
qqmath(~ height | vp.comb, data = singer,
       groups = vp.group, auto.key = list(space = "right"),
       aspect = "xy",
       prepanel = prepanel.qqmathline,
       panel = function(x, ...) {
          panel.qqmathline(x, ...)
          panel.qqmath(x, ...)
       })
</code></pre>

<hr>
<h2 id='B_05_qq'> Quantile-Quantile Plots of Two Samples </h2><span id='topic+qq'></span><span id='topic+qq.formula'></span><span id='topic+qq.data.frame'></span>

<h3>Description</h3>

<p>Quantile-Quantile plots for comparing two Distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qq(x, data, ...)

## S3 method for class 'formula'
qq(x, data, aspect = "fill", 
   panel = lattice.getOption("panel.qq"),
   prepanel, scales, strip, 
   groups, xlab, xlim, ylab, ylim, f.value = NULL, 
   drop.unused.levels = lattice.getOption("drop.unused.levels"),
   ...,
   lattice.options = NULL,
   qtype = 7,
   default.scales = list(),
   default.prepanel = lattice.getOption("prepanel.default.qq"),
   subscripts,
   subset)

## S3 method for class 'data.frame'
qq(x, data = NULL, formula = data, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="B_05_qq_+3A_x">x</code></td>
<td>

<p>The object on which method dispatch is carried out.
</p>
<p>For the <code>"formula"</code> method, <code>x</code> should be a formula of the
form <code>y ~ x | g1 * g2 * ...</code>, where <code>x</code> should be a
numeric variable, and <code>y</code> a factor, shingle, character, or
numeric variable, with the restriction that there must be exactly
two levels of <code>y</code>, which divide the values of <code>x</code> into two
groups.  Quantiles for these groups will be plotted against each
other along the two axes.
</p>
</td></tr>
<tr><td><code id="B_05_qq_+3A_data">data</code></td>
<td>

<p>For the <code>formula</code> method, an optional data source (usually a
data frame) in which variables are to be evaluated (see
<code><a href="#topic+xyplot">xyplot</a></code> for details).
</p>



</td></tr>
<tr><td><code id="B_05_qq_+3A_formula">formula</code></td>
<td>

<p>The formula to be used for the <code>"data.frame"</code> method. See
documentation for argument <code>x</code> for details.
</p>
</td></tr>
<tr><td><code id="B_05_qq_+3A_f.value">f.value</code></td>
<td>

<p>An optional numeric vector of probabilities, quantiles corresponding
to which should be plotted.  This can also be a function of a single
integer (representing sample size) that returns such a numeric
vector.  A typical value for this argument is the function
<code>ppoints</code>, which is also the S-PLUS default.  If specified, the
probabilities generated by this function is used for the plotted
quantiles, through the <code>quantile</code> function.
</p>
<p><code>f.value</code> defaults to <code>NULL</code>, which is equivalent to
</p>
<pre>
      f.value = function(n) ppoints(n, a = 1)
    </pre>
<p>This has the effect of including the minimum and maximum data values
in the computed quantiles. This is similar to what happens for
<code>qqplot</code> but different from the default behaviour of <code>qq</code>
in S-PLUS.
</p>
<p>For large <code>x</code>, this argument can be used to restrict the number
of quantiles plotted.
</p>
</td></tr>
<tr><td><code id="B_05_qq_+3A_panel">panel</code></td>
<td>

<p>A function, called once for each panel, that uses the packet (subset
of panel variables) corresponding to the panel to create a display.
The default panel function <code><a href="#topic+panel.qq">panel.qq</a></code> is documented
separately, and has arguments that can be used to customize its
output in various ways.  Such arguments can usually be directly
supplied to the high-level function.
</p>
</td></tr>
<tr><td><code id="B_05_qq_+3A_qtype">qtype</code></td>
<td>
<p> The <code>type</code> argument for <code><a href="stats.html#topic+quantile">quantile</a></code>. </p>
</td></tr>
<tr><td><code id="B_05_qq_+3A_aspect">aspect</code></td>
<td>
<p> See <code><a href="#topic+xyplot">xyplot</a></code>. </p>
</td></tr>
<tr><td><code id="B_05_qq_+3A_prepanel">prepanel</code></td>
<td>
<p> See <code><a href="#topic+xyplot">xyplot</a></code>. </p>
</td></tr>
<tr><td><code id="B_05_qq_+3A_scales">scales</code></td>
<td>
<p> See <code><a href="#topic+xyplot">xyplot</a></code>. </p>
</td></tr>
<tr><td><code id="B_05_qq_+3A_strip">strip</code></td>
<td>
<p> See <code><a href="#topic+xyplot">xyplot</a></code>. </p>
</td></tr>
<tr><td><code id="B_05_qq_+3A_groups">groups</code></td>
<td>
<p> See <code><a href="#topic+xyplot">xyplot</a></code>.  </p>
</td></tr>
<tr><td><code id="B_05_qq_+3A_xlab">xlab</code>, <code id="B_05_qq_+3A_ylab">ylab</code></td>
<td>
<p> See <code><a href="#topic+xyplot">xyplot</a></code>. </p>
</td></tr>
<tr><td><code id="B_05_qq_+3A_xlim">xlim</code>, <code id="B_05_qq_+3A_ylim">ylim</code></td>
<td>
<p> See <code><a href="#topic+xyplot">xyplot</a></code>. </p>
</td></tr>
<tr><td><code id="B_05_qq_+3A_drop.unused.levels">drop.unused.levels</code></td>
<td>
<p> See <code><a href="#topic+xyplot">xyplot</a></code>. </p>
</td></tr>
<tr><td><code id="B_05_qq_+3A_lattice.options">lattice.options</code></td>
<td>
<p> See <code><a href="#topic+xyplot">xyplot</a></code>. </p>
</td></tr>
<tr><td><code id="B_05_qq_+3A_default.scales">default.scales</code></td>
<td>
<p> See <code><a href="#topic+xyplot">xyplot</a></code>. </p>
</td></tr>
<tr><td><code id="B_05_qq_+3A_subscripts">subscripts</code></td>
<td>
<p> See <code><a href="#topic+xyplot">xyplot</a></code>. </p>
</td></tr>
<tr><td><code id="B_05_qq_+3A_subset">subset</code></td>
<td>
<p> See <code><a href="#topic+xyplot">xyplot</a></code>. </p>
</td></tr>
<tr><td><code id="B_05_qq_+3A_default.prepanel">default.prepanel</code></td>
<td>

<p>Fallback prepanel function.  See <code><a href="#topic+xyplot">xyplot</a></code>.
</p>
</td></tr>
<tr><td><code id="B_05_qq_+3A_...">...</code></td>
<td>

<p>Further arguments.  See corresponding entry in <code><a href="#topic+xyplot">xyplot</a></code>
for non-trivial details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>qq</code> produces Q-Q plots of two samples.  The default behaviour of
<code>qq</code> is different from the corresponding S-PLUS function. See the
entry for <code>f.value</code> for specifics.
</p>
<p>This and all other high level Trellis functions have several
arguments in common. These are extensively documented only in the
help page for <code>xyplot</code>, which should be consulted to learn more
detailed usage.
</p>


<h3>Value</h3>

<p>An object of class <code>"trellis"</code>. The
<code><a href="#topic+update.trellis">update</a></code> method can be used to
update components of the object and the
<code><a href="#topic+print.trellis">print</a></code> method (usually called by
default) will plot it on an appropriate plotting device.
</p>


<h3>Author(s)</h3>

<p>Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+xyplot">xyplot</a></code>, <code><a href="#topic+panel.qq">panel.qq</a></code>,
<code><a href="#topic+qqmath">qqmath</a></code>, <code><a href="#topic+Lattice">Lattice</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qq(voice.part ~ height, aspect = 1, data = singer,
   subset = (voice.part == "Bass 2" | voice.part == "Tenor 1"))
</code></pre>

<hr>
<h2 id='B_06_levelplot'>Level plots and contour plots</h2><span id='topic+levelplot'></span><span id='topic+contourplot'></span><span id='topic+levelplot.formula'></span><span id='topic+levelplot.data.frame'></span><span id='topic+contourplot.formula'></span><span id='topic+contourplot.data.frame'></span><span id='topic+levelplot.table'></span><span id='topic+contourplot.table'></span><span id='topic+levelplot.array'></span><span id='topic+contourplot.array'></span><span id='topic+levelplot.matrix'></span><span id='topic+contourplot.matrix'></span>

<h3>Description</h3>

<p>Draws false color level plots and contour plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>levelplot(x, data, ...)
contourplot(x, data, ...)

## S3 method for class 'formula'
levelplot(x,
          data,
          allow.multiple = is.null(groups) || outer,
          outer = TRUE,
          aspect = "fill",
          panel = if (useRaster) lattice.getOption("panel.levelplot.raster")
                  else lattice.getOption("panel.levelplot"),
          prepanel = NULL,
          scales = list(),
          strip = TRUE,
          groups = NULL,
          xlab,
          xlim,
          ylab,
          ylim,
          at,
          cuts = 15,
          pretty = FALSE,
          region = TRUE,
          drop.unused.levels =
              lattice.getOption("drop.unused.levels"),
          ...,
          useRaster = FALSE,
          lattice.options = NULL,
          default.scales = list(),
          default.prepanel =
              lattice.getOption("prepanel.default.levelplot"),
          colorkey = region,
          col.regions,
          alpha.regions,
          subset = TRUE)

## S3 method for class 'formula'
contourplot(x,
            data,
            panel = lattice.getOption("panel.contourplot"),
            default.prepanel =
                lattice.getOption("prepanel.default.contourplot"),
            cuts = 7,
            labels = TRUE,
            contour = TRUE,
            pretty = TRUE,
            region = FALSE,
            ...)

## S3 method for class 'data.frame'
levelplot(x, data = NULL, formula = data, ...)

## S3 method for class 'data.frame'
contourplot(x, data = NULL, formula = data, ...)

## S3 method for class 'table'
levelplot(x, data = NULL, aspect = "iso", ..., xlim, ylim)

## S3 method for class 'table'
contourplot(x, data = NULL, aspect = "iso", ..., xlim, ylim)

## S3 method for class 'matrix'
levelplot(x, data = NULL, aspect = "iso",
          ..., xlim, ylim,
          row.values = seq_len(nrow(x)),
          column.values = seq_len(ncol(x)))

## S3 method for class 'matrix'
contourplot(x, data = NULL, aspect = "iso",
            ..., xlim, ylim,
            row.values = seq_len(nrow(x)),
            column.values = seq_len(ncol(x)))


## S3 method for class 'array'
levelplot(x, data = NULL, ...)

## S3 method for class 'array'
contourplot(x, data = NULL, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="B_06_levelplot_+3A_x">x</code></td>
<td>

<p>for the <code>formula</code> method, a formula of the form <code>z ~ x * y
      | g1 * g2 * ...</code>, where <code>z</code> is a numeric response, and
<code>x</code>, <code>y</code> are numeric values evaluated on a rectangular
grid.  <code>g1, g2, ...</code> are optional conditional variables, and
must be either factors or shingles if present.
</p>
<p>Calculations are based on the assumption that all x and y values are
evaluated on a grid (defined by their unique values). The function
will not return an error if this is not true, but the display might
not be meaningful.  However, the x and y values need not be equally
spaced.
</p>
<p>Both <code>levelplot</code> and <code>wireframe</code> have methods for
<code>matrix</code>, <code>array</code>, and <code>table</code> objects, in which case
<code>x</code> provides the <code>z</code> vector described above, while its
rows and columns are interpreted as the <code>x</code> and <code>y</code>
vectors respectively.  This is similar to the form used in
<code>filled.contour</code> and <code>image</code>.  For higher-dimensional
arrays and tables, further dimensions are used as conditioning
variables.  Note that the dimnames may be duplicated; this is
handled by calling <code><a href="base.html#topic+make.unique">make.unique</a></code> to make the names
unique (although the original labels are used for the x- and
y-axes).
</p>
</td></tr>
<tr><td><code id="B_06_levelplot_+3A_data">data</code></td>
<td>

<p>For the <code>formula</code> methods, an optional data frame in which
variables in the formula (as well as <code>groups</code> and
<code>subset</code>, if any) are to be evaluated.  Usually ignored with a
warning in other cases.
</p>
</td></tr>
<tr><td><code id="B_06_levelplot_+3A_formula">formula</code></td>
<td>

<p>The formula to be used for the <code>"data.frame"</code> methods. See
documentation for argument <code>x</code> for details.
</p>
</td></tr>
<tr><td><code id="B_06_levelplot_+3A_row.values">row.values</code>, <code id="B_06_levelplot_+3A_column.values">column.values</code></td>
<td>
<p> Optional vectors of values that
define the grid when <code>x</code> is a matrix.  <code>row.values</code> and
<code>column.values</code> must have the same lengths as <code>nrow(x)</code>
and <code>ncol(x)</code> respectively.  By default, row and column
numbers. </p>
</td></tr>
<tr><td><code id="B_06_levelplot_+3A_panel">panel</code></td>
<td>

<p>panel function used to create the display, as described in
<code><a href="#topic+xyplot">xyplot</a></code>
</p>
</td></tr>
<tr><td><code id="B_06_levelplot_+3A_aspect">aspect</code></td>
<td>

<p>For the <code>matrix</code> methods, the default aspect ratio is chosen to
make each cell square.  The usual default is <code>aspect="fill"</code>,
as described in <code><a href="#topic+xyplot">xyplot</a></code>.
</p>
</td></tr>
<tr><td><code id="B_06_levelplot_+3A_at">at</code></td>
<td>

<p>A numeric vector giving breakpoints along the range of
<code>z</code>. Contours (if any) will be drawn at these heights, and the
regions in between would be colored using <code>col.regions</code>.  In
the latter case, values outside the range of <code>at</code> will not be
drawn at all.  This serves as a way to limit the range of the data
shown, similar to what a <code>zlim</code> argument might have been used
for.  However, this also means that when supplying <code>at</code>
explicitly, one has to be careful to include values outside the
range of <code>z</code> to ensure that all the data are shown.
</p>
<p><code>at</code> can have length one only if <code>region=FALSE</code>.  
</p>
</td></tr>
<tr><td><code id="B_06_levelplot_+3A_col.regions">col.regions</code></td>
<td>
<p> color vector to be used if regions is TRUE. The
general idea is that this should be a color vector of moderately
large length (longer than the number of regions. By default this is
100). It is expected that this vector would be gradually varying in
color (so that nearby colors would be similar). When the colors are
actually chosen, they are chosen to be equally spaced along this
vector.  When there are more regions than colors in
<code>col.regions</code>, the colors are recycled.  The actual color
assignment is performed by <code><a href="#topic+level.colors">level.colors</a></code>, which is
documented separately.
</p>
</td></tr>
<tr><td><code id="B_06_levelplot_+3A_alpha.regions">alpha.regions</code></td>
<td>

<p>Numeric, specifying alpha transparency (works only on some devices)
</p>
</td></tr>
<tr><td><code id="B_06_levelplot_+3A_colorkey">colorkey</code></td>
<td>

<p>A logical flag specifying whether a colorkey is to be drawn
alongside the plot, or a list describing the colorkey. The list may
contain the following components:
</p>

<dl>
<dt><code>space</code>:</dt><dd>
<p>location of the colorkey, can be one of <code>"left"</code>,
<code>"right"</code>, <code>"top"</code> and <code>"bottom"</code>.  Defaults to
<code>"right"</code>.
</p>
</dd>
<dt><code>x</code>, <code>y</code>:</dt><dd><p> location, currently unused </p>
</dd>
<dt><code>col</code>:</dt><dd>
<p>A color ramp specification, as in the <code>col.regions</code>
argument in <code><a href="#topic+level.colors">level.colors</a></code>
</p>
</dd>
<dt><code>at</code>:</dt><dd>
<p>A numeric vector specifying where the colors change. must be of
length 1 more than the col vector.
</p>
</dd>
<dt><code>tri.lower</code>, <code>tri.upper</code>:</dt><dd>
<p>Logical or numeric controlling whether the first and last
intervals should be triangular instead of rectangular. With the
default value (<code>NA</code>), this happens only if the
corresponding extreme <code>at</code> values are <code>-Inf</code> or
<code>Inf</code> respectively, and the triangles occupy 5% of the
total length of the color key. If numeric and between 0 and
0.25, these give the corresponding fraction, which is again 5%
when specified as <code>TRUE</code>.
</p>
</dd>
<dt><code>labels</code>:</dt><dd>
<p>A character vector for labelling the <code>at</code> values, or more
commonly, a list describing characteristics of the labels.  This
list may include components <code>labels</code>, <code>at</code>,
<code>cex</code>, <code>col</code>, <code>rot</code>, <code>font</code>, <code>fontface</code>
and <code>fontfamily</code>.
</p>
</dd>
<dt><code>title</code>:</dt><dd>
<p>Usually a character vector or expression providing a title for
the colorkey, or a list controlling the title in further detail,
or an arbitrary <code>"grob"</code>. For details of how the list form
is interpreted, see the entry for <code>main</code> in
<code><a href="#topic+xyplot">xyplot</a></code>; generally speaking, the actual label
should be specified as the <code>label</code> component (which may be
unnamed if it is the first component), and the remaining
arguments are used as appropriate in a call to
<code><a href="grid.html#topic+grid.text">textGrob</a></code>.
</p>
<p>Further control of the placement of the title is possible
through the component <code>title.control</code>. In particular, if a
<code>rot</code> component is not specified, its default depends on
the value of <code>title.control$side</code> (0 for top or bottom, and
90 for left or right).
</p>
<p><code>title</code> defaults to <code>NULL</code>, which means no title is drawn.
</p>
</dd>
<dt><code>title.control</code>:</dt><dd>
<p>A list providing control over the placement of a title, if
specified. Currently two components are honoured: <code>side</code>
can take values <code>"top"</code>, <code>"bottom"</code>, <code>"left"</code>,
and <code>"right"</code>, and specifies the side of the colorkey on
which the title is to be placed. Defaults to the value of the
<code>"space"</code> component. <code>padding</code> is a multiplier for the
default amount of padding between the title and the colorkey.
</p>
</dd>
<dt><code>tick.number</code>:</dt><dd><p> The approximate number of ticks desired. </p>
</dd>
<dt><code>tck</code>:</dt><dd><p> A (scalar) multipler for tick lengths. </p>
</dd>
<dt><code>corner</code>:</dt><dd><p> Interacts with x, y; currently unimplemented </p>
</dd>
<dt><code>width</code>:</dt><dd><p> The width of the key </p>
</dd>
<dt><code>height</code>:</dt><dd><p> The length of key as a fraction of the
appropriate side of plot.
</p>
</dd> 
<dt><code>raster</code>:</dt><dd><p> A logical flag indicating whether the
colorkey should be rendered as a raster image using
<code><a href="grid.html#topic+grid.raster">grid.raster</a></code>.  See also
<code><a href="#topic+panel.levelplot.raster">panel.levelplot.raster</a></code>.
</p>
</dd>
<dt><code>interpolate</code>:</dt><dd><p> Logical flag, passed to
<code><a href="grid.html#topic+rasterGrob">rasterGrob</a></code> when <code>raster=TRUE</code>. </p>
</dd>
<dt><code>axis.line</code>:</dt><dd><p> A list giving graphical parameters for
the color key boundary and tick marks.  Defaults to
<code>trellis.par.get("axis.line")</code>.  </p>
</dd>
<dt><code>axis.text</code>:</dt><dd><p> A list giving graphical parameters for
the tick mark labels on the color key.  Defaults to
<code>trellis.par.get("axis.text")</code>.  </p>
</dd>
</dl>

</td></tr>
<tr><td><code id="B_06_levelplot_+3A_contour">contour</code></td>
<td>

<p>A logical flag, indicating whether to draw contour lines.
</p>
</td></tr>
<tr><td><code id="B_06_levelplot_+3A_cuts">cuts</code></td>
<td>

<p>The number of levels the range of <code>z</code> would be divided into.
</p>
</td></tr>
<tr><td><code id="B_06_levelplot_+3A_labels">labels</code></td>
<td>

<p>Typically a logical indicating whether contour lines should be
labelled, but other possibilities for more sophisticated control
exists.  Details are documented in the help page for
<code><a href="#topic+panel.levelplot">panel.levelplot</a></code>, to which this argument is passed on
unchanged.  That help page also documents the <code>label.style</code>
argument, which affects how the labels are rendered.
</p>
</td></tr>
<tr><td><code id="B_06_levelplot_+3A_pretty">pretty</code></td>
<td>

<p>A logical flag, indicating whether to use pretty cut locations and
labels. 
</p>
</td></tr>
<tr><td><code id="B_06_levelplot_+3A_region">region</code></td>
<td>

<p>A logical flag, indicating whether regions between contour lines
should be filled as in a level plot.
</p>
</td></tr>
<tr><td><code id="B_06_levelplot_+3A_allow.multiple">allow.multiple</code>, <code id="B_06_levelplot_+3A_outer">outer</code>, <code id="B_06_levelplot_+3A_prepanel">prepanel</code>, <code id="B_06_levelplot_+3A_scales">scales</code>, <code id="B_06_levelplot_+3A_strip">strip</code>, <code id="B_06_levelplot_+3A_groups">groups</code>, <code id="B_06_levelplot_+3A_xlab">xlab</code>, <code id="B_06_levelplot_+3A_xlim">xlim</code>, <code id="B_06_levelplot_+3A_ylab">ylab</code>, <code id="B_06_levelplot_+3A_ylim">ylim</code>, <code id="B_06_levelplot_+3A_drop.unused.levels">drop.unused.levels</code>, <code id="B_06_levelplot_+3A_lattice.options">lattice.options</code>, <code id="B_06_levelplot_+3A_default.scales">default.scales</code>, <code id="B_06_levelplot_+3A_subset">subset</code></td>
<td>

<p>These arguments are described in the help page for
<code><a href="#topic+xyplot">xyplot</a></code>.
</p>
</td></tr>
<tr><td><code id="B_06_levelplot_+3A_default.prepanel">default.prepanel</code></td>
<td>

<p>Fallback prepanel function.  See <code><a href="#topic+xyplot">xyplot</a></code>.
</p>
</td></tr>
<tr><td><code id="B_06_levelplot_+3A_...">...</code></td>
<td>

<p>Further arguments may be supplied.  Some are processed by
<code>levelplot</code> or <code>contourplot</code>, and those that are
unrecognized are passed on to the panel function.
</p>
</td></tr>
<tr><td><code id="B_06_levelplot_+3A_useraster">useRaster</code></td>
<td>

<p>A logical flag indicating whether raster representations should be
used, both for the false color image and the color key (if present).
Effectively, setting this to <code>TRUE</code> changes the default panel
function from <code><a href="#topic+panel.levelplot">panel.levelplot</a></code> to
<code><a href="#topic+panel.levelplot.raster">panel.levelplot.raster</a></code>, and sets the default value of
<code>colorkey$raster</code> to <code>TRUE</code>.
</p>
<p>Note that <code><a href="#topic+panel.levelplot.raster">panel.levelplot.raster</a></code> provides only a
subset of the features of <code><a href="#topic+panel.levelplot">panel.levelplot</a></code>, but setting
<code>useRaster=TRUE</code> will not check whether any of the additional
features have been requested.
</p>
<p>Not all devices support raster images.  For devices that appear to
lack support, <code>useRaster=TRUE</code> will be ignored with a warning.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These and all other high level Trellis functions have several
arguments in common. These are extensively documented only in the
help page for <code>xyplot</code>, which should be consulted to learn more
detailed usage.
</p>
<p>Other useful arguments are mentioned in the help page for the default
panel function <code><a href="#topic+panel.levelplot">panel.levelplot</a></code> (these are formally
arguments to the panel function, but can be specified in the high
level calls directly).
</p>


<h3>Value</h3>

<p>An object of class <code>"trellis"</code>. The
<code><a href="#topic+update.trellis">update</a></code> method can be used to
update components of the object and the
<code><a href="#topic+print.trellis">print</a></code> method (usually called by
default) will plot it on an appropriate plotting device.
</p>


<h3>Author(s)</h3>

<p>Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>References</h3>

<p>Sarkar, Deepayan (2008) <em>Lattice: Multivariate Data
Visualization with R</em>, Springer.
<a href="http://lmdvr.r-forge.r-project.org/">http://lmdvr.r-forge.r-project.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xyplot">xyplot</a></code>, <code><a href="#topic+Lattice">Lattice</a></code>,
<code><a href="#topic+panel.levelplot">panel.levelplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(pi/4, 5 * pi, length.out = 100)
y &lt;- seq(pi/4, 5 * pi, length.out = 100)
r &lt;- as.vector(sqrt(outer(x^2, y^2, "+")))
grid &lt;- expand.grid(x=x, y=y)
grid$z &lt;- cos(r^2) * exp(-r/(pi^3))
levelplot(z ~ x * y, grid, cuts = 50, scales=list(log="e"), xlab="",
          ylab="", main="Weird Function", sub="with log scales",
          colorkey = FALSE, region = TRUE)
## triangular end-points in color key, with a title
levelplot(z ~ x * y, grid, col.regions = hcl.colors(10),
          at = c(-Inf, seq(-0.8, 0.8, by = 0.2), Inf))

#S-PLUS example
require(stats)
attach(environmental)
ozo.m &lt;- loess((ozone^(1/3)) ~ wind * temperature * radiation,
       parametric = c("radiation", "wind"), span = 1, degree = 2)
w.marginal &lt;- seq(min(wind), max(wind), length.out = 50)
t.marginal &lt;- seq(min(temperature), max(temperature), length.out = 50)
r.marginal &lt;- seq(min(radiation), max(radiation), length.out = 4)
wtr.marginal &lt;- list(wind = w.marginal, temperature = t.marginal,
        radiation = r.marginal)
grid &lt;- expand.grid(wtr.marginal)
grid[, "fit"] &lt;- c(predict(ozo.m, grid))
contourplot(fit ~ wind * temperature | radiation, data = grid,
            cuts = 10, region = TRUE,
            xlab = "Wind Speed (mph)",
            ylab = "Temperature (F)",
            main = "Cube Root Ozone (cube root ppb)")
detach()
</code></pre>

<hr>
<h2 id='B_07_cloud'>3d Scatter Plot and Wireframe Surface Plot</h2><span id='topic+cloud'></span><span id='topic+wireframe'></span><span id='topic+cloud.formula'></span><span id='topic+cloud.data.frame'></span><span id='topic+cloud.matrix'></span><span id='topic+cloud.table'></span><span id='topic+wireframe.formula'></span><span id='topic+wireframe.data.frame'></span><span id='topic+wireframe.matrix'></span>

<h3>Description</h3>

<p>Generic functions to draw 3d scatter plots and surfaces.  The
<code>"formula"</code> methods do most of the actual work.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cloud(x, data, ...)
wireframe(x, data, ...)

## S3 method for class 'formula'
cloud(x,
      data,
      allow.multiple = is.null(groups) || outer,
      outer = FALSE,
      auto.key = lattice.getOption("default.args")$auto.key,
      aspect = c(1,1),
      panel.aspect = 1,
      panel = lattice.getOption("panel.cloud"),
      prepanel = NULL,
      scales = list(),
      strip = TRUE,
      groups = NULL,
      xlab,
      ylab,
      zlab,
      xlim = if (is.factor(x)) levels(x) else range(x, finite = TRUE),
      ylim = if (is.factor(y)) levels(y) else range(y, finite = TRUE),
      zlim = if (is.factor(z)) levels(z) else range(z, finite = TRUE),
      at,
      drape = FALSE,
      pretty = FALSE,
      drop.unused.levels,
      ...,
      lattice.options = NULL,
      default.scales =
      list(distance = c(1, 1, 1),
           arrows = TRUE,
           axs = axs.default),
      default.prepanel = lattice.getOption("prepanel.default.cloud"),
      colorkey,
      col.regions,
      alpha.regions,
      cuts = 70,
      subset = TRUE,
      axs.default = "r")

## S3 method for class 'data.frame'
cloud(x, data = NULL, formula = data, ...)

## S3 method for class 'formula'
wireframe(x,
          data,
          panel = lattice.getOption("panel.wireframe"),
          default.prepanel = lattice.getOption("prepanel.default.wireframe"),
          ...)

## S3 method for class 'data.frame'
wireframe(x, data = NULL, formula = data, ...)

## S3 method for class 'matrix'
cloud(x, data = NULL, type = "h", 
      zlab = deparse(substitute(x)), aspect, ...,
      xlim, ylim, row.values, column.values)

## S3 method for class 'table'
cloud(x, data = NULL, groups = FALSE,
      zlab = deparse(substitute(x)),
      type = "h", ...)

## S3 method for class 'matrix'
wireframe(x, data = NULL,
          zlab = deparse(substitute(x)), aspect, ...,
          xlim, ylim, row.values, column.values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="B_07_cloud_+3A_x">x</code></td>
<td>

<p>The object on which method dispatch is carried out.
</p>
<p>For the <code>"formula"</code> methods, a formula of the form <code>z ~ x
      * y | g1 * g2 * ...</code>, where <code>z</code> is a numeric response, and
<code>x</code>, <code>y</code> are numeric values. <code>g1, g2, ...</code>, if
present, are conditioning variables used for conditioning, and must
be either factors or shingles. In the case of <code>wireframe</code>,
calculations are based on the assumption that the <code>x</code> and
<code>y</code> values are evaluated on a rectangular grid defined by their
unique values.  The grid points need not be equally spaced.
</p>
<p>For <code>wireframe</code>, <code>x</code>, <code>y</code> and <code>z</code> may also be
matrices (of the same dimension), in which case they are taken to
represent a 3-D surface parametrized on a 2-D grid (e.g., a sphere).
Conditioning is not possible with this feature. See details below.
</p>
<p>Missing values are allowed, either as <code>NA</code> values in the
<code>z</code> vector, or missing rows in the data frame (note however
that in that case the X and Y grids will be determined only by the
available values). For a grouped display (producing multiple
surfaces), missing rows are not allowed, but <code>NA</code>-s in <code>z</code>
are.
</p>
<p>Both <code>wireframe</code> and <code>cloud</code> have methods for
<code>matrix</code> objects, in which case <code>x</code> provides the
<code>z</code> vector described above, while its rows and columns are
interpreted as the <code>x</code> and <code>y</code> vectors respectively.  This
is similar to the form used in <code>persp</code>.
</p>
</td></tr>
<tr><td><code id="B_07_cloud_+3A_data">data</code></td>
<td>

<p>For the <code>"formula"</code> methods, an optional data frame in which
variables in the formula (as well as <code>groups</code> and
<code>subset</code>, if any) are to be evaluated.  <code>data</code> should not
be specified except when using the <code>"formula"</code> method.
</p>
</td></tr>
<tr><td><code id="B_07_cloud_+3A_formula">formula</code></td>
<td>

<p>The formula to be used for the <code>"data.frame"</code> methods. See
documentation for argument <code>x</code> for details.
</p>
</td></tr>
<tr><td><code id="B_07_cloud_+3A_row.values">row.values</code>, <code id="B_07_cloud_+3A_column.values">column.values</code></td>
<td>
<p> Optional vectors of values that
define the grid when <code>x</code> is a matrix.  <code>row.values</code> and
<code>column.values</code> must have the same lengths as <code>nrow(x)</code>
and <code>ncol(x)</code> respectively.  By default, row and column
numbers.
</p>
</td></tr>
<tr><td><code id="B_07_cloud_+3A_allow.multiple">allow.multiple</code>, <code id="B_07_cloud_+3A_outer">outer</code>, <code id="B_07_cloud_+3A_auto.key">auto.key</code>, <code id="B_07_cloud_+3A_prepanel">prepanel</code>, <code id="B_07_cloud_+3A_strip">strip</code>, <code id="B_07_cloud_+3A_groups">groups</code>, <code id="B_07_cloud_+3A_xlab">xlab</code>, <code id="B_07_cloud_+3A_xlim">xlim</code>, <code id="B_07_cloud_+3A_ylab">ylab</code>, <code id="B_07_cloud_+3A_ylim">ylim</code>, <code id="B_07_cloud_+3A_drop.unused.levels">drop.unused.levels</code>, <code id="B_07_cloud_+3A_lattice.options">lattice.options</code>, <code id="B_07_cloud_+3A_default.scales">default.scales</code>, <code id="B_07_cloud_+3A_subset">subset</code></td>
<td>

<p>These arguments are documented in the help page for
<code><a href="#topic+xyplot">xyplot</a></code>.  For the <code>cloud.table</code> method,
<code>groups</code> must be a logical indicating whether the last
dimension should be used as a grouping variable as opposed to a
conditioning variable.  This is only relevant if the table has more
than 2 dimensions.
</p>
</td></tr>
<tr><td><code id="B_07_cloud_+3A_type">type</code></td>
<td>

<p>type of display in <code>cloud</code> (see <code><a href="#topic+panel.3dscatter">panel.3dscatter</a></code>
for details).  Defaults to <code>"h"</code> for the <code>matrix</code> method.
</p>
</td></tr>
<tr><td><code id="B_07_cloud_+3A_aspect">aspect</code>, <code id="B_07_cloud_+3A_panel.aspect">panel.aspect</code></td>
<td>

<p>Unlike other high level functions, <code>aspect</code> is taken to be a
numeric vector of length 2, giving the relative aspects of the
y-size/x-size and z-size/x-size of the enclosing cube.  The usual
role of the <code>aspect</code> argument in determining the aspect ratio
of the panel (see <code><a href="#topic+xyplot">xyplot</a></code> for details) is played by
<code>panel.aspect</code>, except that it can only be a numeric value.
</p>
<p>For the <code>matrix</code> methods, the default y/x aspect is
<code>ncol(x) / nrow(x)</code> and the z/x aspect is the smaller of the
y/x aspect and 1.
</p>
</td></tr>
<tr><td><code id="B_07_cloud_+3A_panel">panel</code></td>
<td>

<p>panel function used to create the display.  See
<code><a href="#topic+panel.cloud">panel.cloud</a></code> for (non-trivial) details.
</p>
</td></tr>
<tr><td><code id="B_07_cloud_+3A_default.prepanel">default.prepanel</code></td>
<td>

<p>Fallback prepanel function.  See <code><a href="#topic+xyplot">xyplot</a></code>.
</p>
</td></tr>
<tr><td><code id="B_07_cloud_+3A_scales">scales</code></td>
<td>

<p>a list describing the scales.  As with other high level functions
(see <code><a href="#topic+xyplot">xyplot</a></code> for details), this list can contain
parameters in name=value form.  It can also contain components with
the special names <code>x</code>, <code>y</code> and <code>z</code>, which can be
similar lists with axis-specific values overriding the ones
specified in <code>scales</code>. 
</p>
<p>The most common use for this argument is to set <code>arrows=FALSE</code>,
which causes tick marks and labels to be used instead of arrows
being drawn (the default).  Both can be suppressed by
<code>draw=FALSE</code>.  Another special component is <code>distance</code>,
which specifies the relative distance of the axis label from the
bounding box.  If specified as a component of <code>scales</code> (as
opposed to one of <code>scales$z</code> etc), this can be (and is recycled
if not) a vector of length 3, specifying distances for the x, y and
z labels respectively.
</p>
<p>Other components that work in the <code>scales</code> argument of
<code>xyplot</code> etc. should also work here (as long as they make
sense), including explicit specification of tick mark locations and
labels.  (Not everything is implemented yet, but if you find
something that should work but does not, feel free to bug the
maintainer.)
</p>
<p>Note, however, that for these functions <code>scales</code> cannot contain
information that is specific to particular panels.  If you really
need that, consider using the <code>scales.3d</code> argument of
<code>panel.cloud</code>.
</p>
</td></tr>
<tr><td><code id="B_07_cloud_+3A_axs.default">axs.default</code></td>
<td>

<p>Unlike 2-D display functions, <code>cloud</code> does not expand the
bounding box to slightly beyound the range of the data, even though
it should.  This is primarily because this is the natural behaviour
in <code>wireframe</code>, which uses the same code.  <code>axs.default</code>
is intended to provide a different default for <code>cloud</code>.
However, this feature has not yet been implemented.
</p>
</td></tr>
<tr><td><code id="B_07_cloud_+3A_zlab">zlab</code></td>
<td>

<p>Specifies a label describing the z variable in ways similar to
<code>xlab</code> and <code>ylab</code> (i.e. &ldquo;grob&rdquo;, character string,
expression or list) in other high level functions.  Additionally, if
<code>zlab</code> (and <code>xlab</code> and <code>ylab</code>) is a list, it can
contain a component called <code>rot</code>, controlling the rotation for
the label
</p>
</td></tr>
<tr><td><code id="B_07_cloud_+3A_zlim">zlim</code></td>
<td>

<p>limits for the z-axis. Similar to <code>xlim</code> and <code>ylim</code> in
other high level functions
</p>
</td></tr>
<tr><td><code id="B_07_cloud_+3A_drape">drape</code></td>
<td>

<p>logical, whether the wireframe is to be draped in color. If
<code>TRUE</code>, the height of a facet is used to determine its color in
a manner similar to the coloring scheme used in
<code><a href="#topic+levelplot">levelplot</a></code>.  Otherwise, the background color is used to
color the facets.  This argument is ignored if <code>shade = TRUE</code>
(see <code><a href="#topic+panel.3dwire">panel.3dwire</a></code>).
</p>
</td></tr>
<tr><td><code id="B_07_cloud_+3A_at">at</code>, <code id="B_07_cloud_+3A_col.regions">col.regions</code>, <code id="B_07_cloud_+3A_alpha.regions">alpha.regions</code></td>
<td>

<p>these arguments are analogous to those in
<code><a href="#topic+levelplot">levelplot</a></code>. if <code>drape=TRUE</code>, <code>at</code> gives the
vector of cutpoints where the colors change, and <code>col.regions</code>
the vector of colors to be used in that case.  <code>alpha.regions</code>
determines the alpha-transparency on supporting devices.  These are
passed down to the panel function, and also used in the colorkey if
appropriate.  The default for <code>col.regions</code> and
<code>alpha.regions</code> is derived from the Trellis setting
<code>"regions"</code>
</p>
</td></tr>
<tr><td><code id="B_07_cloud_+3A_cuts">cuts</code></td>
<td>

<p>if <code>at</code> is unspecified, the approximate number of cutpoints if
<code>drape=TRUE</code>
</p>
</td></tr>
<tr><td><code id="B_07_cloud_+3A_pretty">pretty</code></td>
<td>

<p>whether automatic choice of cutpoints should be prettfied
</p>
</td></tr>
<tr><td><code id="B_07_cloud_+3A_colorkey">colorkey</code></td>
<td>

<p>logical indicating whether a color key should be drawn
alongside, or a list describing such a key.  See
<code><a href="#topic+levelplot">levelplot</a></code> for details.
</p>
</td></tr>
<tr><td><code id="B_07_cloud_+3A_...">...</code></td>
<td>

<p>Any number of other arguments can be specified, and are passed to
the panel function.  In particular, the arguments <code>distance</code>,
<code>perspective</code>, <code>screen</code> and <code>R.mat</code> are very
important in determining the 3-D display.  The argument <code>shade</code>
can be useful for <code>wireframe</code> calls, and controls shading of
the rendered surface.  These arguments are described in detail in
the help page for <code><a href="#topic+panel.cloud">panel.cloud</a></code>.
</p>
<p>Additionally, an argument called <code>zoom</code> may be specified, which
should be a numeric scalar to be interpreted as a scale factor by
which the projection is magnified.  This can be useful to get the
variable names into the plot.  This argument is actually only used
by the default prepanel function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions produce three dimensional plots in each panel (as long
as the default panel functions are used).  The orientation is obtained
as follows: the data are scaled to fall within a bounding box that is
contained in the [-0.5, 0.5] cube (even smaller for non-default values
of <code>aspect</code>).  The viewing direction is given by a sequence of
rotations specified by the <code>screen</code> argument, starting from the
positive Z-axis. The viewing point (camera) is located at a distance
of <code>1/distance</code> from the origin. If <code>perspective=FALSE</code>,
<code>distance</code> is set to 0 (i.e., the viewing point is at an infinite
distance).
</p>
<p><code>cloud</code> draws a 3-D Scatter Plot, while <code>wireframe</code> draws a
3-D surface (usually evaluated on a grid). Multiple surfaces can be
drawn by <code>wireframe</code> using the <code>groups</code> argument (although
this is of limited use because the display is incorrect when the
surfaces intersect). Specifying <code>groups</code> with <code>cloud</code>
results in a <code>panel.superpose</code>-like effect (via
<code><a href="#topic+panel.3dscatter">panel.3dscatter</a></code>).
</p>
<p><code>wireframe</code> can optionally render the surface as being
illuminated by a light source (no shadows though). Details can be
found in the help page for <code><a href="#topic+panel.3dwire">panel.3dwire</a></code>. Note that
although arguments controlling these are actually arguments for the
panel function, they can be supplied to <code>cloud</code> and
<code>wireframe</code> directly.
</p>
<p>For single panel plots, <code>wireframe</code> can also plot parametrized
3-D surfaces (i.e., functions of the form f(u,v) = (x(u,v), y(u,v),
z(u,v)), where values of (u,v) lie on a rectangle. The simplest
example of this sort of surface is a sphere parametrized by latitude
and longitude. This can be achieved by calling <code>wireframe</code> with a
formula <code>x</code> of the form <code>z~x*y</code>, where <code>x</code>, <code>y</code>
and <code>z</code> are all matrices of the same dimension, representing the
values of x(u,v), y(u,v) and z(u,v) evaluated on a discrete
rectangular grid (the actual values of (u,v) are irrelevant).
</p>
<p>When this feature is used, the heights used to calculate <code>drape</code>
colors or shading colors are no longer the <code>z</code> values, but the
distances of <code>(x,y,z)</code> from the origin.
</p>
<p>Note that this feature does not work with <code>groups</code>,
<code>subscripts</code>, <code>subset</code>, etc. Conditioning variables are also
not supported in this case.
</p>
<p>The algorithm for identifying which edges of the bounding box are
&lsquo;behind&rsquo; the points doesn't work in some extreme
situations. Also, <code><a href="#topic+panel.cloud">panel.cloud</a></code> tries to figure out the
optimal location of the arrows and axis labels automatically, but can
fail on occasion (especially when the view is from &lsquo;below&rsquo; the
data). This can be manually controlled by the <code>scpos</code> argument in
<code><a href="#topic+panel.cloud">panel.cloud</a></code>.
</p>
<p>These and all other high level Trellis functions have several other
arguments in common. These are extensively documented only in the
help page for <code><a href="#topic+xyplot">xyplot</a></code>, which should be consulted to learn
more detailed usage.
</p>


<h3>Value</h3>

<p>An object of class <code>"trellis"</code>. The
<code><a href="#topic+update.trellis">update</a></code> method can be used to
update components of the object and the
<code><a href="#topic+print.trellis">print</a></code> method (usually called by
default) will plot it on an appropriate plotting device.
</p>


<h3>Note</h3>

<p> There is a known problem with grouped <code>wireframe</code> displays
when the (x, y) coordinates represented in the data do not represent
the full evaluation grid.  The problem occurs whether the grouping is
specified through the <code>groups</code> argument or through the formula
interface, and currently causes memory access violations.  Depending
on the circumstances, this is manifested either as a meaningless plot
or a crash.  To work around the problem, it should be enough to have
a row in the data frame for each grid point, with an <code>NA</code>
response (<code>z</code>) in rows that were previously missing.  </p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>References</h3>

<p>Sarkar, Deepayan (2008) <em>Lattice: Multivariate Data
Visualization with R</em>, Springer.
<a href="http://lmdvr.r-forge.r-project.org/">http://lmdvr.r-forge.r-project.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lattice">Lattice</a></code> for an overview of the package, as well as 
<code><a href="#topic+xyplot">xyplot</a></code>, <code><a href="#topic+levelplot">levelplot</a></code>,
<code><a href="#topic+panel.cloud">panel.cloud</a></code>.
</p>
<p>For interaction, see <code><a href="#topic+panel.identify.cloud">panel.identify.cloud</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## volcano  ## 87 x 61 matrix
wireframe(volcano, shade = TRUE,
          aspect = c(61/87, 0.4),
          light.source = c(10,0,10))

g &lt;- expand.grid(x = 1:10, y = 5:15, gr = 1:2)
g$z &lt;- log((g$x^g$gr + g$y^2) * g$gr)
wireframe(z ~ x * y, data = g, groups = gr,
          scales = list(arrows = FALSE),
          drape = TRUE, colorkey = TRUE,
          screen = list(z = 30, x = -60))

cloud(Sepal.Length ~ Petal.Length * Petal.Width | Species, data = iris,
      screen = list(x = -90, y = 70), distance = .4, zoom = .6)

## cloud.table

cloud(prop.table(Titanic, margin = 1:3),
      type = c("p", "h"), strip = strip.custom(strip.names = TRUE),
      scales = list(arrows = FALSE, distance = 2), panel.aspect = 0.7,
      zlab = "Proportion")[, 1]

## transparent axes

par.set &lt;-
    list(axis.line = list(col = "transparent"),
         clip = list(panel = "off"))
print(cloud(Sepal.Length ~ Petal.Length * Petal.Width, 
            data = iris, cex = .8, 
            groups = Species, 
            main = "Stereo",
            screen = list(z = 20, x = -70, y = 3),
            par.settings = par.set,
            scales = list(col = "black")),
      split = c(1,1,2,1), more = TRUE)
print(cloud(Sepal.Length ~ Petal.Length * Petal.Width,
            data = iris, cex = .8, 
            groups = Species,
            main = "Stereo",
            screen = list(z = 20, x = -70, y = 0),
            par.settings = par.set,
            scales = list(col = "black")),
      split = c(2,1,2,1))

</code></pre>

<hr>
<h2 id='B_08_splom'>Scatter Plot Matrices</h2><span id='topic+splom'></span><span id='topic+parallel'></span><span id='topic+parallelplot'></span><span id='topic+splom.matrix'></span><span id='topic+splom.data.frame'></span><span id='topic+parallelplot.matrix'></span><span id='topic+parallelplot.data.frame'></span><span id='topic+splom.formula'></span><span id='topic+parallelplot.formula'></span>

<h3>Description</h3>

<p>Draw Conditional Scatter Plot Matrices and Parallel Coordinate Plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splom(x, data, ...)
parallelplot(x, data, ...)

## S3 method for class 'formula'
splom(x,
      data,
      auto.key = lattice.getOption("default.args")$auto.key,
      aspect = 1,
      between = list(x = 0.5, y = 0.5),
      panel = lattice.getOption("panel.splom"),
      prepanel,
      scales,
      strip,
      groups,
      xlab,
      xlim,
      ylab = NULL,
      ylim,
      superpanel = lattice.getOption("panel.pairs"),
      pscales = 5,
      varnames = NULL,
      drop.unused.levels,
      ...,
      lattice.options = NULL,
      default.scales,
      default.prepanel = lattice.getOption("prepanel.default.splom"),
      subset = TRUE)
## S3 method for class 'formula'
parallelplot(x,
         data,
         auto.key = lattice.getOption("default.args")$auto.key,
         aspect = "fill",
         between = list(x = 0.5, y = 0.5),
         panel = lattice.getOption("panel.parallel"),
         prepanel,
         scales,
         strip,
         groups,
         xlab = NULL,
         xlim,
         ylab = NULL,
         ylim,
         varnames = NULL,
         horizontal.axis = TRUE,
         drop.unused.levels,
         ...,
         lattice.options = NULL,
         default.scales,
         default.prepanel = lattice.getOption("prepanel.default.parallel"),
         subset = TRUE)

## S3 method for class 'data.frame'
splom(x, data = NULL, ..., groups = NULL, subset = TRUE)
## S3 method for class 'matrix'
splom(x, data = NULL, ..., groups = NULL, subset = TRUE)

## S3 method for class 'matrix'
parallelplot(x, data = NULL, ..., groups = NULL, subset = TRUE)
## S3 method for class 'data.frame'
parallelplot(x, data = NULL, ..., groups = NULL, subset = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="B_08_splom_+3A_x">x</code></td>
<td>

<p>The object on which method dispatch is carried out.
</p>
<p>For the <code>"formula"</code> method, a formula describing the structure
of the plot, which should be of the form <code>~ x | g1 * g2 *
      ...</code>, where <code>x</code> is a data frame or matrix.  Each of
<code>g1,g2,...</code> must be either factors or shingles. The
conditioning variables <code>g1, g2, ...</code> may be omitted.
</p>
<p>For the <code>data.frame</code> methods, a data frame.
</p>
</td></tr>
<tr><td><code id="B_08_splom_+3A_data">data</code></td>
<td>

<p>For the <code>formula</code> methods, an optional data frame in which
variables in the formula (as well as <code>groups</code> and
<code>subset</code>, if any) are to be evaluated.
</p>
</td></tr>
<tr><td><code id="B_08_splom_+3A_aspect">aspect</code></td>
<td>
 
<p>aspect ratio of each panel (and subpanel), square by default for
<code>splom</code>.
</p>
</td></tr>
<tr><td><code id="B_08_splom_+3A_between">between</code></td>
<td>
 
<p>to avoid confusion between panels and subpanels, the default is to
show the panels of a splom plot with space between them.
</p>
</td></tr>
<tr><td><code id="B_08_splom_+3A_panel">panel</code></td>
<td>

<p>For <code>parallelplot</code>, this has the usual interpretation, i.e., a
function that creates the display within each panel.
</p>
<p>For <code>splom</code>, the terminology is slightly complicated. The role
played by the panel function in most other high-level functions is
played here by the <code>superpanel</code> function, which is responsible
for the display for each conditional data subset. <code>panel</code> is
simply an argument to the default <code>superpanel</code> function
<code>panel.pairs</code>, and is passed on to it unchanged. It is used
there to create each pairwise display. See <code><a href="#topic+panel.pairs">panel.pairs</a></code>
for more useful options.
</p>
</td></tr>
<tr><td><code id="B_08_splom_+3A_superpanel">superpanel</code></td>
<td>
 
<p>function that sets up the splom display, by default as a scatterplot
matrix.
</p>
</td></tr>
<tr><td><code id="B_08_splom_+3A_pscales">pscales</code></td>
<td>
 
<p>a numeric value or a list, meant to be a less functional substitute
for the <code>scales</code> argument in <code>xyplot</code> etc. This argument
is passed to the <code>superpanel</code> function, and is handled by the
default superpanel function <code>panel.pairs</code>. The help page for
the latter documents this argument in more detail.
</p>
</td></tr>
<tr><td><code id="B_08_splom_+3A_varnames">varnames</code></td>
<td>
 
<p>A character or expression vector or giving names to be used for the
variables in <code>x</code>. By default, the column names of <code>x</code>.
</p>
</td></tr>
<tr><td><code id="B_08_splom_+3A_horizontal.axis">horizontal.axis</code></td>
<td>
<p>logical indicating whether the parallel axes should
be laid out horizontally (<code>TRUE</code>) or vertically (<code>FALSE</code>).
</p>
</td></tr>
<tr><td><code id="B_08_splom_+3A_auto.key">auto.key</code>, <code id="B_08_splom_+3A_prepanel">prepanel</code>, <code id="B_08_splom_+3A_scales">scales</code>, <code id="B_08_splom_+3A_strip">strip</code>, <code id="B_08_splom_+3A_groups">groups</code>, <code id="B_08_splom_+3A_xlab">xlab</code>, <code id="B_08_splom_+3A_xlim">xlim</code>, <code id="B_08_splom_+3A_ylab">ylab</code>, <code id="B_08_splom_+3A_ylim">ylim</code>, <code id="B_08_splom_+3A_drop.unused.levels">drop.unused.levels</code>, <code id="B_08_splom_+3A_lattice.options">lattice.options</code>, <code id="B_08_splom_+3A_default.scales">default.scales</code>, <code id="B_08_splom_+3A_subset">subset</code></td>
<td>
<p> See <code><a href="#topic+xyplot">xyplot</a></code> </p>
</td></tr>
<tr><td><code id="B_08_splom_+3A_default.prepanel">default.prepanel</code></td>
<td>

<p>Fallback prepanel function.  See <code><a href="#topic+xyplot">xyplot</a></code>.
</p>
</td></tr>
<tr><td><code id="B_08_splom_+3A_...">...</code></td>
<td>
<p> Further arguments.  See corresponding entry in
<code><a href="#topic+xyplot">xyplot</a></code> for non-trivial details.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>splom</code> produces Scatter Plot Matrices.  The role usually played
by <code>panel</code> is taken over by <code>superpanel</code>, which takes a data
frame subset and is responsible for plotting it.  It is called with
the coordinate system set up to have both x- and y-limits from
<code>0.5</code> to <code>ncol(z) + 0.5</code>.  The only built-in option
currently available is <code><a href="#topic+panel.pairs">panel.pairs</a></code>, which calls a
further panel function for each pair <code>(i, j)</code> of variables in
<code>z</code> inside a rectangle of unit width and height centered at
<code>c(i, j)</code> (see <code><a href="#topic+panel.pairs">panel.pairs</a></code> for details).
</p>
<p>Many of the finer customizations usually done via arguments to high
level function like <code>xyplot</code> are instead done by
<code>panel.pairs</code> for <code>splom</code>. These include control of axis
limits, tick locations and prepanel calcultions. If you are trying to
fine-tune your <code>splom</code> plot, definitely look at the
<code><a href="#topic+panel.pairs">panel.pairs</a></code> help page. The <code>scales</code> argument is
usually not very useful in <code>splom</code>, and trying to change it may
have undesired effects.
</p>
<p><code><a href="#topic+parallelplot">parallelplot</a></code> draws Parallel Coordinate Plots. (Difficult to
describe, see example.)
</p>
<p>These and all other high level Trellis functions have several
arguments in common. These are extensively documented only in the
help page for <code>xyplot</code>, which should be consulted to learn more
detailed usage.
</p>


<h3>Value</h3>

<p>An object of class <code>"trellis"</code>. The
<code><a href="#topic+update.trellis">update</a></code> method can be used to
update components of the object and the
<code><a href="#topic+print.trellis">print</a></code> method (usually called by
default) will plot it on an appropriate plotting device.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+xyplot">xyplot</a></code>, <code><a href="#topic+Lattice">Lattice</a></code>, <code><a href="#topic+panel.pairs">panel.pairs</a></code>,
<code><a href="#topic+panel.parallel">panel.parallel</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>super.sym &lt;- trellis.par.get("superpose.symbol")
splom(~iris[1:4], groups = Species, data = iris,
      panel = panel.superpose,
      key = list(title = "Three Varieties of Iris",
                 columns = 3, 
                 points = list(pch = super.sym$pch[1:3],
                 col = super.sym$col[1:3]),
                 text = list(c("Setosa", "Versicolor", "Virginica"))))
splom(~iris[1:3]|Species, data = iris, 
      layout=c(2,2), pscales = 0,
      varnames = c("Sepal\nLength", "Sepal\nWidth", "Petal\nLength"),
      page = function(...) {
          ltext(x = seq(.6, .8, length.out = 4), 
                y = seq(.9, .6, length.out = 4), 
                labels = c("Three", "Varieties", "of", "Iris"),
                cex = 2)
      })
parallelplot(~iris[1:4] | Species, iris) 
parallelplot(~iris[1:4], iris, groups = Species,
             horizontal.axis = FALSE, scales = list(x = list(rot = 90)))
</code></pre>

<hr>
<h2 id='B_09_tmd'>Tukey Mean-Difference Plot</h2><span id='topic+tmd'></span><span id='topic+tmd.formula'></span><span id='topic+tmd.data.frame'></span><span id='topic+tmd.trellis'></span><span id='topic+prepanel.tmd.default'></span><span id='topic+prepanel.tmd.qqmath'></span><span id='topic+panel.tmd.default'></span><span id='topic+panel.tmd.qqmath'></span>

<h3>Description</h3>

<p><code>tmd</code> Creates Tukey Mean-Difference Plots from a trellis object
returned by <code>xyplot</code>, <code>qq</code> or <code>qqmath</code>.  The prepanel
and panel functions are used as appropriate.  The <code>formula</code> and
<code>data.frame</code> methods for <code>tmd</code> are provided for convenience,
and simply call <code>tmd</code> on the object created by the corresponding
<code>xyplot</code> methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tmd(object, ...)

## S3 method for class 'trellis'
tmd(object,
    xlab = "mean",
    ylab = "difference",
    panel, 
    prepanel, 
    ...)

prepanel.tmd.qqmath(x,
             f.value = NULL,
             distribution = qnorm,
             qtype = 7,
             groups = NULL,
             subscripts, ...)
panel.tmd.qqmath(x,
             f.value = NULL,
             distribution = qnorm,
             qtype = 7,
             groups = NULL, 
             subscripts, ...,
             identifier = "tmd")
panel.tmd.default(x, y, groups = NULL, ...,
                  identifier = "tmd")
prepanel.tmd.default(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="B_09_tmd_+3A_object">object</code></td>
<td>
<p> An object of class <code>"trellis"</code> returned by
<code>xyplot</code>, <code>qq</code> or <code>qqmath</code>.  </p>
</td></tr>
<tr><td><code id="B_09_tmd_+3A_xlab">xlab</code></td>
<td>
<p> x label</p>
</td></tr>
<tr><td><code id="B_09_tmd_+3A_ylab">ylab</code></td>
<td>
<p> y label</p>
</td></tr>
<tr><td><code id="B_09_tmd_+3A_panel">panel</code></td>
<td>
<p> panel function to be used.  See details below.  </p>
</td></tr>
<tr><td><code id="B_09_tmd_+3A_prepanel">prepanel</code></td>
<td>
<p> prepanel function.  See details below.  </p>
</td></tr>
<tr><td><code id="B_09_tmd_+3A_f.value">f.value</code>, <code id="B_09_tmd_+3A_distribution">distribution</code>, <code id="B_09_tmd_+3A_qtype">qtype</code></td>
<td>
<p>see <code><a href="#topic+panel.qqmath">panel.qqmath</a></code>.  </p>
</td></tr>
<tr><td><code id="B_09_tmd_+3A_groups">groups</code>, <code id="B_09_tmd_+3A_subscripts">subscripts</code></td>
<td>
<p>see <code><a href="#topic+xyplot">xyplot</a></code>.  </p>
</td></tr>
<tr><td><code id="B_09_tmd_+3A_x">x</code>, <code id="B_09_tmd_+3A_y">y</code></td>
<td>
<p> data as passed to panel functions in original call.  </p>
</td></tr>
<tr><td><code id="B_09_tmd_+3A_...">...</code></td>
<td>
<p> other arguments</p>
</td></tr>
<tr><td><code id="B_09_tmd_+3A_identifier">identifier</code></td>
<td>

<p>A character string that is prepended to the names of grobs
that are created by this panel function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Tukey Mean-difference plot is produced by modifying the (x,y)
values of each panel as follows: the new coordinates are given by
<code>x=(x+y)/2</code> and <code>y=y-x</code>, which are then plotted.  The
default panel function(s) add a reference line at <code>y=0</code> as well.
</p>
<p><code>tmd</code> acts on the a <code>"trellis"</code> object, not on the actual plot
this object would have produced.  As such, it only uses the arguments
supplied to the panel function in the original call, and completely
ignores what the original panel function might have done with this
data.  <code>tmd</code> uses these panel arguments to set up its own scales
(using its <code>prepanel</code> argument) and display (using
<code>panel</code>).  It is thus important to provide suitable prepanel and
panel functions to <code>tmd</code> depending on the original call.
</p>
<p>Such functions currently exist for <code>xyplot</code>, <code>qq</code> (the ones
with <code>default</code> in their name) and <code>qqmath</code>, as listed in the
usage section above.  These assume the default displays for the
corresponding high-level call.  If unspecified, the <code>prepanel</code> and
<code>panel</code> arguments default to suitable choices.
</p>
<p><code>tmd</code> uses the <code>update</code> method for <code>"trellis"</code> objects,
which processes all extra arguments supplied to <code>tmd</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"trellis"</code>. The
<code><a href="#topic+update.trellis">update</a></code> method can be used to
update components of the object and the
<code><a href="#topic+print.trellis">print</a></code> method (usually called by
default) will plot it on an appropriate plotting device.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>See Also</h3>

 <p><code><a href="#topic+qq">qq</a></code>, <code><a href="#topic+qqmath">qqmath</a></code>, <code><a href="#topic+xyplot">xyplot</a></code>,
<code><a href="#topic+Lattice">Lattice</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmd(qqmath(~height | voice.part, data = singer))
</code></pre>

<hr>
<h2 id='B_10_rfs'> Residual and Fit Spread Plots</h2><span id='topic+rfs'></span>

<h3>Description</h3>

<p>Plots fitted values and residuals (via qqmath) on a common scale for
any object that has methods for fitted values and residuals. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rfs(model, layout=c(2, 1), xlab="f-value", ylab=NULL,
    distribution = qunif,
    panel, prepanel, strip, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="B_10_rfs_+3A_model">model</code></td>
<td>
<p>a fitted model object with methods <code>fitted.values</code>
and <code>residuals</code>. Can be the value returned by <code>oneway</code> </p>
</td></tr>
<tr><td><code id="B_10_rfs_+3A_layout">layout</code></td>
<td>
<p>default layout is c(2,1)  </p>
</td></tr>
<tr><td><code id="B_10_rfs_+3A_xlab">xlab</code></td>
<td>
<p>defaults to <code>"f.value"</code> </p>
</td></tr>
<tr><td><code id="B_10_rfs_+3A_distribution">distribution</code></td>
<td>
<p>the distribution function to be used for <code>qqmath</code></p>
</td></tr>
<tr><td><code id="B_10_rfs_+3A_ylab">ylab</code>, <code id="B_10_rfs_+3A_panel">panel</code>, <code id="B_10_rfs_+3A_prepanel">prepanel</code>, <code id="B_10_rfs_+3A_strip">strip</code></td>
<td>
<p> See <code><a href="#topic+xyplot">xyplot</a></code> </p>
</td></tr>
<tr><td><code id="B_10_rfs_+3A_...">...</code></td>
<td>
<p> other arguments, passed on to <code><a href="#topic+qqmath">qqmath</a></code>.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"trellis"</code>. The
<code><a href="#topic+update.trellis">update</a></code> method can be used to
update components of the object and the
<code><a href="#topic+print.trellis">print</a></code> method (usually called by
default) will plot it on an appropriate plotting device.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+oneway">oneway</a></code>, <code><a href="#topic+qqmath">qqmath</a></code>,
<code><a href="#topic+xyplot">xyplot</a></code>, <code><a href="#topic+Lattice">Lattice</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rfs(oneway(height ~ voice.part, data = singer, spread = 1), aspect = 1)
</code></pre>

<hr>
<h2 id='B_11_oneway'> Fit One-way Model</h2><span id='topic+oneway'></span>

<h3>Description</h3>

<p>Fits a One-way model to univariate data grouped by a factor, the
result often being displayed using <code>rfs</code> 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oneway(formula, data, location=mean, spread=function(x) sqrt(var(x)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="B_11_oneway_+3A_formula">formula</code></td>
<td>
<p> formula of the form <code>y ~ x</code> where <code>y</code> is the
numeric response and <code>x</code> is the grouping factor
</p>
</td></tr>
<tr><td><code id="B_11_oneway_+3A_data">data</code></td>
<td>
<p> data frame in which the model is to be evaluated </p>
</td></tr>
<tr><td><code id="B_11_oneway_+3A_location">location</code></td>
<td>
<p> function or numeric giving the location statistic to
be used for centering the observations, e.g. <code>median</code>, 0 (to
avoid centering).
</p>
</td></tr>
<tr><td><code id="B_11_oneway_+3A_spread">spread</code></td>
<td>
<p> function or numeric giving the spread statistic to
be used for scaling the observations, e.g. <code>sd</code>, 1 (to
avoid scaling).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components
</p>

<dl>
<dt><code>location</code></dt><dd><p> vector of locations for each group.</p>
</dd>
<dt><code>spread</code></dt><dd><p> vector of spreads for each group.</p>
</dd>
<dt><code>fitted.values</code></dt><dd><p> vector of locations for each observation.</p>
</dd>
<dt><code>residuals</code></dt><dd><p> residuals (<code>y - fitted.values</code>).</p>
</dd>
<dt><code>scaled.residuals</code></dt><dd><p>residuals scaled by <code>spread</code> for their
group</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+rfs">rfs</a></code>, <code><a href="#topic+Lattice">Lattice</a></code> </p>

<hr>
<h2 id='C_01_trellis.device'> Initializing Trellis Displays </h2><span id='topic+trellis.device'></span>

<h3>Description</h3>

<p>Initialization of a display device with appropriate graphical
parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trellis.device(device = getOption("device"),
               color = !(dev.name == "postscript"),
               theme = lattice.getOption("default.theme"),
               new = TRUE,
               retain = FALSE,
               ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="C_01_trellis.device_+3A_device">device</code></td>
<td>
<p> function (or the name of one as a character string)
that starts a device.  Admissible values depend on the platform and
how <span class="rlang"><b>R</b></span> was compiled (see <code><a href="grDevices.html#topic+Devices">Devices</a></code>), but usually
<code>"pdf"</code>, <code>"postscript"</code>, <code>"png"</code>, <code>"jpeg"</code> and
at least one of <code>"X11"</code>, <code>"windows"</code> and <code>"quartz"</code>
will be available.
</p>
</td></tr>
<tr><td><code id="C_01_trellis.device_+3A_color">color</code></td>
<td>
<p> logical, whether the initial settings should be color or
black and white.  Defaults to <code>FALSE</code> for postscript devices,
<code>TRUE</code> otherwise.  Note that this only applies to the initial
choice of colors, which can be overridden using <code>theme</code> or
subsequent calls to <code><a href="#topic+trellis.par.set">trellis.par.set</a></code> (and by arguments
supplied directly in high level calls for some settings).
</p>
</td></tr>
<tr><td><code id="C_01_trellis.device_+3A_theme">theme</code></td>
<td>
<p> list of components that changes the settings of the
device opened, or, a function that when called produces such a
list.  The function name can be supplied as a quoted string.  These
settings are only used to modify the default settings (determined by
other arguments), and need not contain all possible parameters.
</p>
<p>A possible use of this argument is to change the default settings by 
specifying <code>lattice.options(default.theme = "col.whitebg")</code>. 
For back-compatibility, this is initially (when lattice is loaded)
set to <code>getOption(lattice.theme)</code>.
</p>
<p>If <code>theme</code> is a function, it will not be supplied any
arguments, however, it is guaranteed that a device will already be
open when it is called, so one may use <code>.Device</code> inside the
function to ascertain what device has been opened.
</p>
</td></tr>
<tr><td><code id="C_01_trellis.device_+3A_new">new</code></td>
<td>
<p> logical flag indicating whether a new device should be
started.  If <code>FALSE</code>, the options for the current device are
changed to the defaults determined by the other arguments.
</p>
</td></tr>
<tr><td><code id="C_01_trellis.device_+3A_retain">retain</code></td>
<td>

<p>logical. If <code>TRUE</code> and a setting for this device already
exists, then that is used instead of the defaults for this
device. By default, pre-existing settings are overwritten (and
lost).
</p>
</td></tr>
<tr><td><code id="C_01_trellis.device_+3A_name">name</code></td>
<td>
<p> name of the device for which the setting is required, as
returned by <code>.Device</code>
</p>
</td></tr>
<tr><td><code id="C_01_trellis.device_+3A_...">...</code></td>
<td>
<p> additional parameters to be passed to the <code>device</code>
function, most commonly <code>file</code> for non-screen devices, as well
as <code>height</code>, <code>width</code>, etc.  See the help file for
individual devices for admissible arguments.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>trellis.device</code> function sets up an R graphics device for
use with lattice graphics, by opening the device if necessary, and
defining a set of associated graphical parameters (colors, line types,
fonts, etc.).
</p>
<p>Even if a device is opened without calling <code>trellis.device</code>, for
example, by calling a device function directly, <code>trellis.device</code>
is still called automatically when a <code>"trellis"</code> object is
plotted. The default graphical settings used in this case can be
customized using <code><a href="#topic+lattice.options">lattice.options</a></code>.  It is therefore
rarely necessary for the user to call <code>trellis.device</code>
explicitly.
</p>


<h3>Value</h3>

<p>None; <code>trellis.device</code> is called for the side effect of opening a
device and / or setting associated graphical parameters.
</p>


<h3>Note</h3>

<p>Earlier versions of <code>trellis.device</code> had a <code>bg</code> argument to
set the background color, but this is no longer supported.  If
supplied, the <code>bg</code> argument will be passed on to the device
function; however, this will have no effect on the Trellis settings.
It is rarely meaningful to change the background alone; if you feel
the need to change the background, consider using the <code>theme</code>
argument instead.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>References</h3>

<p>Sarkar, Deepayan (2008) <em>Lattice: Multivariate Data
Visualization with R</em>, Springer.
<a href="http://lmdvr.r-forge.r-project.org/">http://lmdvr.r-forge.r-project.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lattice">Lattice</a></code> for an overview of the <code>lattice</code> package.
</p>
<p><code><a href="grDevices.html#topic+Devices">Devices</a></code> for valid choices of <code>device</code> on your
platform.
</p>
<p><code><a href="#topic+standard.theme">standard.theme</a></code> for the default theme and alternatives.
</p>

<hr>
<h2 id='C_02a_standard.theme'> Built-in Graphical Themes </h2><span id='topic+standard.theme'></span><span id='topic+classic.theme'></span><span id='topic+canonical.theme'></span><span id='topic+custom_theme'></span><span id='topic+col.whitebg'></span>

<h3>Description</h3>

<p>Built-in graphical parameter settings. These mainly differ in their
choice of colors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standard.theme(name, color = TRUE,
               symbol = palette.colors(palette = "Okabe-Ito")[c(6, 2, 4, 7, 3, 5, 8)],
               fill   = NULL,
               region = hcl.colors(14, palette = "YlGnBu", rev = TRUE),
               reference = "gray90",
               bg = "transparent",
               fg = "black",
               ...)
canonical.theme(...)
custom_theme(symbol, fill, region,
             reference = "gray90", bg = "transparent", fg = "black",
             strip.bg = rep("gray95", 7), strip.fg = rep("gray70", 7),
             ...)
classic.theme(name, color)
col.whitebg()

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="C_02a_standard.theme_+3A_name">name</code></td>
<td>
<p> character string giving the name of the device for which
the setting is required, as returned by <code>.Device</code>. This is only
used by <code>classic.theme</code> to allow device-specific setting. It is
retained in <code>standard.theme</code> for back-compatibilty, but its use
is not recommended.
</p>
</td></tr>
<tr><td><code id="C_02a_standard.theme_+3A_color">color</code></td>
<td>
<p> logical, whether the initial settings should be color or
black and white.
</p>
</td></tr>
<tr><td><code id="C_02a_standard.theme_+3A_symbol">symbol</code></td>
<td>
<p>vector of colors to be used for symbols and lines.</p>
</td></tr>
<tr><td><code id="C_02a_standard.theme_+3A_fill">fill</code></td>
<td>
<p>vector of colors to be used as fill colors, e.g., in bar
charts and histograms. The default of <code>NULL</code> in
<code>standard.theme</code> results in lightened versions of the symbol
colors to be used.
</p>
</td></tr>
<tr><td><code id="C_02a_standard.theme_+3A_region">region</code></td>
<td>
<p>vector of colors to be used to create a color ramp,
typically used by <code><a href="#topic+levelplot">levelplot</a></code>
</p>
</td></tr>
<tr><td><code id="C_02a_standard.theme_+3A_reference">reference</code></td>
<td>
<p> color, to be used for reference lines. </p>
</td></tr>
<tr><td><code id="C_02a_standard.theme_+3A_fg">fg</code></td>
<td>
<p> color, to be used for foreground elements such as axes and
labels. </p>
</td></tr>
<tr><td><code id="C_02a_standard.theme_+3A_bg">bg</code></td>
<td>
<p> color, to be used as background. </p>
</td></tr>
<tr><td><code id="C_02a_standard.theme_+3A_strip.bg">strip.bg</code></td>
<td>
<p> color, to be used as strip background. </p>
</td></tr>
<tr><td><code id="C_02a_standard.theme_+3A_strip.fg">strip.fg</code></td>
<td>
<p> color, to be used as strip foreground. </p>
</td></tr>
<tr><td><code id="C_02a_standard.theme_+3A_...">...</code></td>
<td>
<p> additional arguments, passed on to other functions as
appropriate. In particular, additional arguments provided to
<code>standard.theme</code> will be passed on to <code>custom_theme</code>, and
these may include non-color parameters that will be used to modify
the resulting theme via <code><a href="#topic+simpleTheme">simpleTheme</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Trellis Graphics functions obtain the default values of various
graphical parameters (colors, line types, fonts, etc.) from a
customizable &ldquo;settings&rdquo; list (see <code><a href="#topic+trellis.par.set">trellis.par.set</a></code>
for details).  This functionality is analogous to <code><a href="graphics.html#topic+par">par</a></code>
for standard <span class="rlang"><b>R</b></span> graphics and, together with
<code><a href="#topic+lattice.options">lattice.options</a></code>, mostly supplants it (<code><a href="graphics.html#topic+par">par</a></code>
settings are mostly ignored by Lattice).  Unlike <code><a href="graphics.html#topic+par">par</a></code>,
Trellis settings can be controlled separately for each different
device type (but not concurrently for different instances of the same
device).
</p>
<p>The functions documented in this page produce such graphical settings
(a.k.a. themes), usually to be used with <code><a href="#topic+trellis.device">trellis.device</a></code>
or <code><a href="#topic+trellis.par.set">trellis.par.set</a></code>.
</p>
<p><code>classic.theme</code> and <code>col.whitebg</code> produce predefined themes
that are not recommended for routine use but are retained for
compatibility.
</p>
<p>The <code>classic.theme</code> function was intended to provide device
specific settings (e.g. light colors on a grey background for screen
devices, dark colors or black and white for print devices) and was
used to obtain defaults prior to <span class="rlang"><b>R</b></span> 2.3.0.  However, these settings
are not always appropriate, due to the variety of platforms and
hardware settings on which <span class="rlang"><b>R</b></span> is used, as well as the fact that a plot
created on a particular device may be subsequently used in many
different ways.  For this reason, common device-agnostic defaults were
used for all devices from <span class="rlang"><b>R</b></span> 2.3.0 onwards.
</p>
<p>Since <span class="rlang"><b>R</b></span> 4.3.0, a new set of defaults given by <code>standard.theme</code>
is used. The defaults are based on HCL palettes, but customization of
the palettes is allowed.  Earlier behaviour can be reinstated by
setting <code>classic.theme</code> as the default <code>theme</code> argument,
e.g., by putting
<code>lattice.options(default.theme = classic.theme("pdf"))</code>
in a startup script (see the entry for <code>theme</code> in
<code><a href="#topic+trellis.device">trellis.device</a></code> for details).
</p>
<p><code>custom_theme</code> is the workhorse function called by
<code>standard.theme</code>. <code>canonical.theme</code> is an alias for
<code>standard.theme</code>.
</p>


<h3>Value</h3>

<p>A list of components defining graphical parameter settings for Lattice
displays. It is used internally in <code>trellis.device</code>, and can also
be used as the <code>theme</code> argument to <code>trellis.par.set</code>
</p>
<p><code>col.whitebg</code> returns a similar (but smaller) list that is
suitable as the <code>theme</code> argument to <code>trellis.device</code> and
<code><a href="#topic+trellis.par.set">trellis.par.set</a></code>.  It contains settings values which
provide colors suitable for plotting on a white background.  Note that
the name <code>col.whitebg</code> is somewhat of a misnomer, since it
actually sets the background to transparent rather than white.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>References</h3>

<p>Sarkar, Deepayan (2008) <em>Lattice: Multivariate Data
Visualization with R</em>, Springer.
<a href="http://lmdvr.r-forge.r-project.org/">http://lmdvr.r-forge.r-project.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lattice">Lattice</a></code> for an overview of the <code>lattice</code> package.
</p>
<p><code><a href="grDevices.html#topic+Devices">Devices</a></code> for valid choices of <code>device</code> on your
platform.
</p>
<p><code><a href="#topic+trellis.par.get">trellis.par.get</a></code> and <code><a href="#topic+trellis.par.set">trellis.par.set</a></code> can be
used to query and modify the settings <em>after</em> a device has been
initialized.  The <code>par.settings</code> argument to high level
functions, described in <code><a href="#topic+xyplot">xyplot</a></code>, can be used to attach
transient settings to a <code>"trellis"</code> object.
</p>

<hr>
<h2 id='C_02b_trellis.par.get'> Graphical Parameters for Trellis Displays </h2><span id='topic+trellis.par.get'></span><span id='topic+trellis.par.set'></span><span id='topic+show.settings'></span>

<h3>Description</h3>

<p>Functions used to query, display and modify graphical parameters for
fine control of Trellis displays.  Modifications are made to the
settings for the currently active device only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trellis.par.set(name, value, ..., theme, warn = TRUE, strict = FALSE)
trellis.par.get(name = NULL)
show.settings(x = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="C_02b_trellis.par.get_+3A_name">name</code></td>
<td>

<p>A character string giving the name of a component.  If unspecified
in <code>trellis.par.get()</code>, the return value is a named list
containing all the current settings (this can be used to get the
valid values for <code>name</code>).
</p>
</td></tr>
<tr><td><code id="C_02b_trellis.par.get_+3A_value">value</code></td>
<td>

<p>a list giving the desired value of the component. Components that
are already defined as part of the current settings but are not
mentioned in <code>value</code> will remain unchanged.
</p>
</td></tr>
<tr><td><code id="C_02b_trellis.par.get_+3A_theme">theme</code></td>
<td>

<p>a list decribing how to change the settings, similar to what is
returned by <code>trellis.par.get()</code>.  This is purely for
convenience, allowing multiple calls to <code>trellis.par.set</code> to be
condensed into one.  The name of each component must be a valid
<code>name</code> as described above, with the corresponding value a valid
<code>value</code> as described above.
</p>
<p>As in <code><a href="#topic+trellis.device">trellis.device</a></code>, <code>theme</code> can also be a
function that produces such a list when called.  The function name
can be supplied as a quoted string.
</p>
</td></tr>
<tr><td><code id="C_02b_trellis.par.get_+3A_...">...</code></td>
<td>

<p>Multiple settings can be specified in <code>name = value</code> form.
Equivalent to calling with <code>theme = list(...)</code>
</p>
</td></tr>
<tr><td><code id="C_02b_trellis.par.get_+3A_warn">warn</code></td>
<td>

<p>A logical flag, indicating whether a warning should be issued when
<code>trellis.par.get</code> is called when no graphics device is open.
</p>
</td></tr>
<tr><td><code id="C_02b_trellis.par.get_+3A_strict">strict</code></td>
<td>

<p>Usually a logical flag, indicating whether the <code>value</code> should
be interpreted strictly.  Usually, assignment of value to the
corresponding named component is fuzzy in the sense that
sub-components that are absent from <code>value</code> but not currently
<code>NULL</code> are retained.  By specifying <code>strict = TRUE</code>, such
values will be removed.
</p>
<p>An even stricter interpretation is allowed by specifying
<code>strict</code> as a numeric value larger than <code>1</code>.  In that
case, top-level components not specified in the call will also be
removed.  This is primarily for internal use.
</p>
</td></tr>
<tr><td><code id="C_02b_trellis.par.get_+3A_x">x</code></td>
<td>

<p>optional list of components that change the settings (any valid
value of <code>theme</code>).  These are used to modify the current
settings (obtained by <code>trellis.par.get</code>) before they are
displayed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The various graphical parameters (color, line type, background etc)
that control the look and feel of Trellis displays are highly
customizable. Also, R can produce graphics on a number of devices, and
it is expected that a different set of parameters would be more suited
to different devices. These parameters are stored internally in a
variable named <code>lattice.theme</code>, which is a list whose components
define settings for particular devices. The components are idenified
by the name of the device they represent (as obtained by
<code>.Device</code>), and are created as and when new devices are opened
for the first time using <code>trellis.device</code> (or Lattice plots are
drawn on a device for the first time in that session).
</p>
<p>The initial settings for each device defaults to values appropriate
for that device. In practice, this boils down to three distinct
settings, one for screen devices like <code>x11</code> and <code>windows</code>,
one for black and white plots (mostly useful for <code>postscript</code>)
and one for color printers (color <code>postcript</code>, <code>pdf</code>).
</p>
<p>Once a device is open, its settings can be modified. When another
instance of the same device is opened later using
<code>trellis.device</code>, the settings for that device are reset to its
defaults, unless otherwise specified in the call to
<code>trellis.device</code>. But settings for different devices are treated
separately, i.e., opening a postscript device will not alter the x11
settings, which will remain in effect whenever an x11 device is
active.
</p>
<p>The functions <code>trellis.par.*</code> are meant to be interfaces to the
global settings. They always apply on the settings for the currently
ACTIVE device.
</p>
<p><code>trellis.par.get</code>, called without any arguments, returns the full
list of settings for the active device. With the <code>name</code> argument
present, it returns that component only. <code>trellis.par.get</code> sets
the value of the <code>name</code> component of the current active device
settings to <code>value</code>.
</p>
<p><code>trellis.par.get</code> is usually used inside trellis functions to get
graphical parameters before plotting. Modifications by users via
<code>trellis.par.set</code> is traditionally done as follows:
</p>
<p><code>add.line &lt;- trellis.par.get("add.line")</code>
</p>
<p><code>add.line$col &lt;- "red"</code>
</p>
<p><code>trellis.par.set("add.line", add.line)</code>
</p>
<p>More convenient (but not S compatible) ways to do this are
</p>
<p><code>trellis.par.set(list(add.line = list(col = "red")))</code>
</p>
<p>and
</p>
<p><code>trellis.par.set(add.line = list(col = "red"))</code>
</p>
<p>The actual list of the components in <code>trellis.settings</code> has not
been finalized, so I'm not attempting to list them here. The current
value can be obtained by <code>print(trellis.par.get())</code>. Most names
should be self-explanatory.
</p>
<p><code>show.settings</code> provides a graphical display summarizing some of
the values in the current settings.
</p>


<h3>Value</h3>

<p><code>trellis.par.get</code> returns a list giving parameters for that
component. If <code>name</code> is missing, it returns the full list.
</p>
<p>Most of the settings are graphical parameters that control various
elements of a lattice plot.  For details, see the examples below.  The
more unusual settings are described here.
</p>

<dl>
<dt><code>grid.pars</code></dt><dd><p> Grid graphical parameters that are in effect
globally unless overridden by specific settings.</p>
</dd>
<dt><code>fontsize</code></dt><dd><p> A list of two components (each a numeric scalar),
<code>text</code> and <code>points</code>, for text and symbols
respectively.
</p>
</dd> 
<dt><code>clip</code></dt><dd><p> A list of two components (each a character string,
either <code>"on"</code> or <code>"off"</code>), <code>panel</code> and
<code>strip</code>.
</p>
</dd> 
<dt><code>axis.components</code></dt><dd><p> A list with four components (<code>left</code>,
<code>top</code>, <code>right</code>, <code>bottom</code>), each a list giving numeric
mutlipliers named <code>tck</code>, <code>pad1</code>, and <code>pad2</code> for
corresponding grid layout units. </p>
</dd>
<dt><code>layout.heights</code></dt><dd><p> A list with numeric multipliers for
grid layout heights. </p>
</dd>
<dt><code>layout.widths</code></dt><dd><p> A list with numeric multipliers for
grid layout widths. </p>
</dd>
</dl>



<h3>Note</h3>

<p>In some ways, <code>trellis.par.get</code> and <code>trellis.par.set</code>
together are a replacement for the <code><a href="graphics.html#topic+par">par</a></code> function used in
traditional R graphics.  In particular, changing <code>par</code> settings
has little (if any) effect on lattice output.  Since lattice plots are
implemented using Grid graphics, its parameter system <em>does</em> have
an effect unless overridden by a suitable lattice parameter setting.
Such parameters can be specified as part of a lattice theme by
including them in the <code>grid.pars</code> component (see
<code><a href="grid.html#topic+gpar">gpar</a></code> for a list of valid parameter names).
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+trellis.device">trellis.device</a></code>, <code><a href="#topic+Lattice">Lattice</a></code>,
<code><a href="grid.html#topic+gpar">gpar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>show.settings()

tp &lt;- trellis.par.get()

unusual &lt;- c("grid.pars", "fontsize", "clip", "axis.components",
             "layout.heights", "layout.widths")

for (u in unusual) tp[[u]] &lt;- NULL
names.tp &lt;- lapply(tp, names)
unames &lt;- sort(unique(unlist(names.tp)))
ans &lt;- matrix(0, nrow = length(names.tp), ncol = length(unames))
rownames(ans) &lt;- names(names.tp)
colnames(ans) &lt;- unames
for (i in seq_along(names.tp))
    ans[i, ] &lt;- as.numeric(unames %in% names.tp[[i]])
ans &lt;- ans[, order(-colSums(ans))]
ans &lt;- ans[order(rowSums(ans)), ]
ans[ans == 0] &lt;- NA

levelplot(t(ans), colorkey = FALSE, 
          scales = list(x = list(rot = 90)),
          panel = function(x, y, z, ...) {
              panel.abline(v = unique(as.numeric(x)), 
                           h = unique(as.numeric(y)), 
                           col = "darkgrey")
              panel.xyplot(x, y, pch = 16 * z, ...)
          },
          xlab = "Graphical parameters", 
          ylab = "Setting names")

</code></pre>

<hr>
<h2 id='C_03_simpleTheme'> Function to generate a simple theme </h2><span id='topic+simpleTheme'></span>

<h3>Description</h3>

<p>Simple interface to generate a list appropriate as a theme, typically
used as the <code>par.settings</code> argument in a high level call
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simpleTheme(col, alpha, 
            cex, pch, lty, lwd, font, fill, border,
            col.points, col.line, 
            alpha.points, alpha.line)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="C_03_simpleTheme_+3A_col">col</code>, <code id="C_03_simpleTheme_+3A_col.points">col.points</code>, <code id="C_03_simpleTheme_+3A_col.line">col.line</code></td>
<td>

<p>A color specification.  <code>col</code> is used for components
<code>"plot.symbol"</code>, <code>"plot.line"</code>, <code>"plot.polygon"</code>,
<code>"superpose.symbol"</code>, <code>"superpose.line"</code>, and
<code>"superpose.polygon"</code>.  <code>col.points</code> overrides
<code>col</code>, but is used only for <code>"plot.symbol"</code> and
<code>"superpose.symbol"</code>.  Similarly, <code>col.line</code> overrides
<code>col</code> for <code>"plot.line"</code> and <code>"superpose.line"</code>.
The arguments can be vectors, but only the first component is used
for scalar targets (i.e., the ones without <code>"superpose"</code> in
their name).
</p>
</td></tr>
<tr><td><code id="C_03_simpleTheme_+3A_alpha">alpha</code>, <code id="C_03_simpleTheme_+3A_alpha.points">alpha.points</code>, <code id="C_03_simpleTheme_+3A_alpha.line">alpha.line</code></td>
<td>

<p>A numeric alpha transparency specification.  The same rules as
<code>col</code>, etc., apply.
</p>
</td></tr>
<tr><td><code id="C_03_simpleTheme_+3A_cex">cex</code>, <code id="C_03_simpleTheme_+3A_pch">pch</code>, <code id="C_03_simpleTheme_+3A_font">font</code></td>
<td>
<p> Parameters for points.  Applicable for
components <code>plot.symbol</code> (for which only the first component is
used) and <code>superpose.symbol</code> (for which the arguments can be
vectors).
</p>
</td></tr>
<tr><td><code id="C_03_simpleTheme_+3A_lty">lty</code>, <code id="C_03_simpleTheme_+3A_lwd">lwd</code></td>
<td>
<p> Parameters for lines.  Applicable for
components <code>plot.line</code> (for which only the first component is
used) and <code>superpose.line</code> (for which the arguments can be
vectors).
</p>
</td></tr>
<tr><td><code id="C_03_simpleTheme_+3A_fill">fill</code></td>
<td>
<p> fill color, applicable for components <code>plot.symbol</code>,
<code>plot.polygon</code>, <code>superpose.symbol</code>, and
<code>superpose.polygon</code>.  </p>
</td></tr>
<tr><td><code id="C_03_simpleTheme_+3A_border">border</code></td>
<td>
<p> border color, applicable for components
<code>plot.polygon</code> and <code>superpose.polygon</code>.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The appearance of a lattice display depends partly on the
&ldquo;theme&rdquo; active when the display is plotted (see
<code><a href="#topic+trellis.device">trellis.device</a></code> for details).  This theme is used to
obtain defaults for various graphical parameters, and in particular,
the <code>auto.key</code> argument works on the premise that the same source
is used for both the actual graphical encoding and the legend.  The
easiest way to specify custom settings for a particular display is to
use the <code>par.settings</code> argument, which is usually tedious to
construct as it is a nested list.  The <code>simpleTheme</code> function can
be used in such situations as a wrapper that generates a suitable list
given parameters in simple <code>name=value</code> form, with the nesting
made implicit.  This is less flexible, but straightforward and
sufficient in most situations.
</p>


<h3>Value</h3>

<p>A list that would work as the <code>theme</code> argument to
<code><a href="#topic+trellis.device">trellis.device</a></code> and <code><a href="#topic+trellis.par.set">trellis.par.set</a></code>, or
as the <code>par.settings</code> argument to any high level lattice function
such as <code><a href="#topic+xyplot">xyplot</a></code>.
</p>


<h3>Author(s)</h3>

<p>Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a>, based on a
suggestion from John Maindonald.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trellis.device">trellis.device</a></code>, <code><a href="#topic+xyplot">xyplot</a></code>,
<code><a href="#topic+Lattice">Lattice</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
str(simpleTheme(pch = 16))

dotplot(variety ~ yield | site, data = barley, groups = year,
        auto.key = list(space = "right"),
        par.settings = simpleTheme(pch = 16),
        xlab = "Barley Yield (bushels/acre) ",
        aspect=0.5, layout = c(1,6))

</code></pre>

<hr>
<h2 id='C_04_lattice.options'> Low-level Options Controlling Behaviour of Lattice </h2><span id='topic+lattice.options'></span><span id='topic+lattice.getOption'></span>

<h3>Description</h3>

<p>Functions to handle settings used by lattice.  Their main purpose is
to make code maintainance easier, and users normally should not need
to use these functions.  However, fine control at this level maybe
useful in certain cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lattice.options(...)
lattice.getOption(name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="C_04_lattice.options_+3A_name">name</code></td>
<td>
<p> character giving the name of a setting </p>
</td></tr>
<tr><td><code id="C_04_lattice.options_+3A_...">...</code></td>
<td>

<p>new options can be defined, or existing ones modified, using one or
more arguments of the form <code>name = value</code> or by passing a list
of such tagged values.  Existing values can be retrieved by
supplying the names (as character strings) of the components as
unnamed arguments.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are modeled on <code>options</code> and <code>getOption</code>,
and behave similarly for the most part.  Some of the available
components are documented here, but not all.  The purpose of the ones
not documented are either fairly obvious, or not of interest to the
end-user.
</p>

<dl>
<dt><code>panel.error</code></dt><dd>
<p>A function, or <code>NULL</code>.  If the former, every call to the
panel function will be wrapped inside <code><a href="base.html#topic+tryCatch">tryCatch</a></code> with
the specified function as an error handler.  The default is to use
the <code><a href="#topic+panel.error">panel.error</a></code> function.  This prevents the plot
from failing due to errors in a single panel, and leaving the grid
operations in an unmanageable state.  If set to <code>NULL</code>,
errors in panel functions will not be caught using
<code>tryCatch</code>.
</p>
</dd>
<dt><code>save.object</code></dt><dd>
<p>Logical flag indicating whether a <code>"trellis"</code> object should
be saved when plotted for subsequent retrieval and further
manipulation.  Defaults to <code>TRUE</code>.
</p>
</dd>
<dt><code>layout.widths</code>, <code>layout.heights</code></dt><dd><p> Controls details
of the default space allocation in the grid layout created in the
course of plotting a <code>"trellis"</code> object.  Each named
component is a list of arguments to the <span class="pkg">grid</span> function
<code><a href="grid.html#topic+unit">unit</a></code> (<code>x</code>, <code>units</code>, and optionally
<code>data</code>).
</p>
<p>Usually not of interest to the end-user, who should instead use
the similiarly named component in the graphical settings,
modifiable using <code><a href="#topic+trellis.par.set">trellis.par.set</a></code>.
</p>
</dd>
<dt><code>drop.unused.levels</code></dt><dd><p> A list of two components named
<code>cond</code> and <code>data</code>, both logical flags.  The flags
indicate whether the unused levels of factors (conditioning
variables and primary variables respectively) will be dropped,
which is usually relevant when a subsetting operation is performed
or an 'interaction' is created.  See <code><a href="#topic+xyplot">xyplot</a></code> for more
details.  Note that this does not control dropping of levels of
the 'groups' argument.
</p>
</dd>
<dt><code>legend.bbox</code></dt><dd>
<p>A character string, either <code>"full"</code> or <code>"panel"</code>.  This
determines the interpretation of <code>x</code> and <code>y</code> when
<code>space="inside"</code> in <code>key</code> (determining the legend; see
<code><a href="#topic+xyplot">xyplot</a></code>): either the full figure region ('&quot;full&quot;'),
or just the region that bounds the panels and strips ('&quot;panel&quot;').
</p>
</dd>
<dt><code>default.args</code></dt><dd><p> A list giving default values for various
standard arguments: <code>as.table</code>, <code>auto.key</code>,
<code>aspect</code>, <code>between</code>, <code>grid</code>, <code>skip</code>,
<code>strip</code>, <code>xscale.components</code>, <code>yscale.components</code>,
and <code>axis</code>.  </p>
</dd>
<dt><code>highlight.gpar</code></dt><dd><p> A list giving arguments to
<code><a href="grid.html#topic+gpar">gpar</a></code> used to highlight a viewport chosen using
<code><a href="#topic+trellis.focus">trellis.focus</a></code>.
</p>
</dd>
<dt><code>banking</code></dt><dd><p> The banking function. See
<code><a href="#topic+banking">banking</a></code>. </p>
</dd>
<dt><code>axis.padding</code></dt><dd><p> List with components named
<code>"numeric"</code> and <code>"factor"</code>, both scalar numbers.
Panel limits are extended by this amount, to provide padding
for numeric and factor scales respectively.  The value for
numeric is multiplicative, whereas factor is additive. </p>
</dd>
<dt><code>skip.boundary.labels</code></dt><dd><p> Numeric scalar between 0 and 1.
Tick marks that are too close to the limits are not drawn unless
explicitly requested.  The limits are contracted by this
proportion, and anything outside is skipped. </p>
</dd>
<dt><code>interaction.sep</code></dt><dd><p> The separator for creating
interactions with the extended formula interface (see
<code><a href="#topic+xyplot">xyplot</a></code>).
</p>
</dd>
<dt><code>optimize.grid</code></dt><dd><p> Logical flag, <code>FALSE</code> by
default. Complicated grid unit calculations can be slow. Sometimes
these can be optimized at the cost of potential loss of
accuracy. This option controls whether such optimization should be
applied.
</p>
</dd>
<dt><code>axis.units</code></dt><dd><p> List determining default units for axis
components.  Should not be of interest to the end-user.
</p>
</dd>
</dl>

<p>In addition, there is an option for the default prepanel and panel
function for each high-level function; e.g., <code>panel.xyplot</code> and
<code>prepanel.default.xyplot</code> for <code><a href="#topic+xyplot">xyplot</a></code>.  The options
for the others have similarly patterned names.
</p>


<h3>Value</h3>

<p><code>lattice.getOption</code> returns the value of a single component,
whereas <code>lattice.options</code> always returns a list with one or more
named components.  When changing the values of components, the old
values of the modified components are returned by
<code>lattice.options</code>.  If called without any arguments, the full
list is returned. 
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+options">options</a></code>, <code><a href="#topic+trellis.device">trellis.device</a></code>,
<code><a href="#topic+trellis.par.get">trellis.par.get</a></code>, <code><a href="#topic+Lattice">Lattice</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>names(lattice.options())
str(lattice.getOption("layout.widths"), max.level = 2)

## Not run: 
## change default settings for subsequent plots
lattice.options(default.args = list(as.table = TRUE,
                                    grid = TRUE,
                                    auto.key = TRUE))

## End(Not run)

</code></pre>

<hr>
<h2 id='C_05_print.trellis'>Plot and Summarize Trellis Objects</h2><span id='topic+print.trellis'></span><span id='topic+plot.trellis'></span><span id='topic+summary.trellis'></span><span id='topic+dim.trellis'></span><span id='topic+dimnames.trellis'></span><span id='topic+panel.error'></span>

<h3>Description</h3>

<p>The <code>print</code> and <code>plot</code> methods produce a graph from a
<code>"trellis"</code> object.  The <code>print</code> method is necessary for
automatic plotting.  <code>plot</code> method is essentially
an alias, provided for convenience.  The <code>summary</code> method
gives a textual summary of the object.  <code>dim</code> and <code>dimnames</code>
describe the cross-tabulation induced by conditioning.
<code>panel.error</code> is the default handler used when an error occurs
while executing the panel function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trellis'
plot(x, position, split,
     more = FALSE, newpage = TRUE,
     packet.panel = packet.panel.default, 
     draw.in = NULL,
     panel.height = lattice.getOption("layout.heights")$panel,
     panel.width = lattice.getOption("layout.widths")$panel,
     save.object = lattice.getOption("save.object"),
     panel.error = lattice.getOption("panel.error"),
     prefix,
     ...)
## S3 method for class 'trellis'
print(x, ...)

## S3 method for class 'trellis'
summary(object, ...)

## S3 method for class 'trellis'
dim(x)
## S3 method for class 'trellis'
dimnames(x)

panel.error(e)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="C_05_print.trellis_+3A_x">x</code>, <code id="C_05_print.trellis_+3A_object">object</code></td>
<td>
<p> an object of class <code>"trellis"</code></p>
</td></tr>
<tr><td><code id="C_05_print.trellis_+3A_position">position</code></td>
<td>
<p> a vector of 4 numbers, typically c(xmin, ymin, xmax,
ymax) that give the lower-left and upper-right corners of a
rectangle in which the Trellis plot of x is to be positioned. The
coordinate system for this rectangle is [0-1] in both the x and y
directions.
</p>
</td></tr>
<tr><td><code id="C_05_print.trellis_+3A_split">split</code></td>
<td>
<p> a vector of 4 integers, c(x,y,nx,ny) , that says to
position the current plot at the x,y position in a regular array of
nx by ny plots. (Note: this has origin at top left)
</p>
</td></tr>
<tr><td><code id="C_05_print.trellis_+3A_more">more</code></td>
<td>
<p> A logical specifying whether more plots will follow on
this page.
</p>
</td></tr>
<tr><td><code id="C_05_print.trellis_+3A_newpage">newpage</code></td>
<td>
<p> A logical specifying whether the plot should be on a
new page. This option is specific to lattice, and is useful for
including lattice plots in an arbitrary grid viewport (see the
details section).
</p>
</td></tr>
<tr><td><code id="C_05_print.trellis_+3A_packet.panel">packet.panel</code></td>
<td>
<p> a function that determines which packet (data
subset) is plotted in which panel.  Panels are always drawn in an
order such that columns vary the fastest, then rows and then pages.
This function determines, given the column, row and page and other
relevant information, the packet (if any) which should be used in
that panel.  By default, the association is determnined by matching
panel order with packet order, which is determined by varying the
first conditioning variable the fastest, then the second, and so
on.  This association rule is encoded in the default, namely the
function <code><a href="#topic+packet.panel.default">packet.panel.default</a></code>, whose help page details
the arguments supplied to whichever function is specified as the
<code>packet.panel</code> argument.
</p>
</td></tr>
<tr><td><code id="C_05_print.trellis_+3A_draw.in">draw.in</code></td>
<td>

<p>An optional (grid) viewport (used as the <code>name</code> argument in
<code>downViewport</code>) in which the plot is to be drawn.  If
specified, the <code>newpage</code> argument is ignored.  This feature is
not well-tested.
</p>
</td></tr>
<tr><td><code id="C_05_print.trellis_+3A_panel.width">panel.width</code>, <code id="C_05_print.trellis_+3A_panel.height">panel.height</code></td>
<td>

<p>lists with 2 components, that should be valid <code>x</code> and
<code>units</code> arguments to <code>unit()</code> (the <code>data</code> argument
cannot be specified currently, but can be considered for addition if
needed).  The resulting <code>unit</code> object will be the width/height
of each panel in the Lattice plot. These arguments can be used to
explicitly control the dimensions of the panel, rather than letting
them expand to maximize available space.  Vector widths are allowed,
and can specify unequal lengths across rows or columns.
</p>
<p>Note that this option should not be used in conjunction with
non-default values of the <code>aspect</code> argument in the original
high level call (no error will be produced, but the resulting
behaviour is undefined).
</p>
</td></tr>
<tr><td><code id="C_05_print.trellis_+3A_save.object">save.object</code></td>
<td>

<p>logical, specifying whether the object being printed is to be
saved.  The last object thus saved can be subsequently retrieved.
This is an experimental feature that should allow access to a
panel's data after the plot is done, making it possible to enhance
the plot after the fact.  This also allows the user to invoke the
<code>update</code> method on the current plot, even if it was not
assigned to a variable explicitly.  For more details, see
<code><a href="#topic+trellis.focus">trellis.focus</a></code>.
</p>
</td></tr>
<tr><td><code id="C_05_print.trellis_+3A_panel.error">panel.error</code></td>
<td>

<p>a function, or a character string naming a function, that is to be
executed when an error occurs during the execution of the panel
function.  The error is caught (using <code><a href="base.html#topic+tryCatch">tryCatch</a></code>) and
supplied as the only argument to <code>panel.error</code>.  The default
behaviour (implemented as the <code>panel.error</code> function) is to
print the corresponding error message in the panel and continue.  To
stop execution on error, use <code>panel.error = stop</code>.
</p>
<p>Normal error recovery and debugging tools are unhelpful when
<code>tryCatch</code> is used.  <code>tryCatch</code> can be completely bypassed
by setting <code>panel.error</code> to NULL.
</p>
</td></tr>
<tr><td><code id="C_05_print.trellis_+3A_prefix">prefix</code></td>
<td>

<p>A character string acting as a prefix identifying the plot of a
<code>"trellis"</code> object, primarily used in constructing viewport and
grob names, to distinguish similar viewports if a page contains
multiple plots.  The default is based on the serial number of the
current plot on the current page (specifically, <code>"plot_01"</code>,
<code>"plot_02"</code>, etc.).  If supplied explicitly, this must be a
valid <span class="rlang"><b>R</b></span> symbol name (briefly, it must start with a letter or a
period followed by a letter) and must not contain the grid path
separator (currently <code>"::"</code>).
</p>
</td></tr>
<tr><td><code id="C_05_print.trellis_+3A_e">e</code></td>
<td>
<p> an error condition caught by <code><a href="base.html#topic+tryCatch">tryCatch</a></code></p>
</td></tr>
<tr><td><code id="C_05_print.trellis_+3A_...">...</code></td>
<td>

<p>extra arguments, ignored by the <code>print</code> method.  All arguments
to the <code>plot</code> method are passed on to the <code>print</code> method.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the default print method for objects of class
<code>"trellis"</code>, produced by calls to functions like <code>xyplot</code>,
<code>bwplot</code> etc. It is usually called automatically when a trellis
object is produced. It can also be called explicitly to control plot
positioning by means of the arguments <code>split</code> and
<code>position</code>.
</p>
<p>When <code>newpage = FALSE</code>, the current grid viewport is treated as
the plotting area, making it possible to embed a Lattice plot inside
an arbitrary grid viewport.  The <code>draw.in</code> argument provides an
alternative mechanism that may be simpler to use.
</p>
<p>The print method uses the information in <code>x</code> (the object to be
printed) to produce a display using the Grid graphics engine. At the
heart of the plot is a grid layout, of which the entries of most
interest to the user are the ones containing the display panels.
</p>
<p>Unlike in older versions of Lattice (and Grid), the grid display tree
is retained after the plot is produced, making it possible to access
individual viewport locations and make additions to the plot.  For
more details and a lattice level interface to these viewports, see
<code><a href="#topic+trellis.focus">trellis.focus</a></code>.
</p>


<h3>Note</h3>

<p>Unlike S-PLUS, trying to position a multipage display (using
<code>position</code> and/or <code>split</code>) will mess things up.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Lattice">Lattice</a></code>, <code><a href="grid.html#topic+unit">unit</a></code>,
<code><a href="#topic+update.trellis">update.trellis</a></code>, <code><a href="#topic+trellis.focus">trellis.focus</a></code>,
<code><a href="#topic+packet.panel.default">packet.panel.default</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
p11 &lt;- histogram( ~ height | voice.part, data = singer, xlab="Height")
p12 &lt;- densityplot( ~ height | voice.part, data = singer, xlab = "Height")
p2 &lt;- histogram( ~ height, data = singer, xlab = "Height")


## simple positioning by split
print(p11, split=c(1,1,1,2), more=TRUE)
print(p2, split=c(1,2,1,2))

## Combining split and position:
print(p11, position = c(0,0,.75,.75), split=c(1,1,1,2), more=TRUE)
print(p12, position = c(0,0,.75,.75), split=c(1,2,1,2), more=TRUE)
print(p2, position = c(.5,.75,1,1), more=FALSE)

## Using seekViewport

## repeat same plot, with different polynomial fits in each panel
xyplot(Armed.Forces ~ Year, longley, index.cond = list(rep(1, 6)),
       layout = c(3, 2),
       panel = function(x, y, ...)
       {
           panel.xyplot(x, y, ...)
           fm &lt;- lm(y ~ poly(x, panel.number()))
           llines(x, predict(fm))
       })

## Not run: 
grid::seekViewport(trellis.vpname("panel", 1, 1))
cat("Click somewhere inside the first panel:\n")
ltext(grid::grid.locator(), lab = "linear")

## End(Not run)

grid::seekViewport(trellis.vpname("panel", 1, 1))
grid::grid.text("linear")

grid::seekViewport(trellis.vpname("panel", 2, 1))
grid::grid.text("quadratic")

grid::seekViewport(trellis.vpname("panel", 3, 1))
grid::grid.text("cubic")

grid::seekViewport(trellis.vpname("panel", 1, 2))
grid::grid.text("degree 4")

grid::seekViewport(trellis.vpname("panel", 2, 2))
grid::grid.text("degree 5")

grid::seekViewport(trellis.vpname("panel", 3, 2))
grid::grid.text("degree 6")
</code></pre>

<hr>
<h2 id='C_06_update.trellis'>Retrieve and Update Trellis Object</h2><span id='topic+update.trellis'></span><span id='topic++5B.trellis'></span><span id='topic+t.trellis'></span><span id='topic+trellis.last.object'></span>

<h3>Description</h3>

<p>Update method for objects of class <code>"trellis"</code>, and a way to retrieve
the last printed trellis object (that was saved).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'trellis'
update(object,
       panel,
       aspect,
       as.table,
       between,
       key,
       auto.key,
       legend,
       layout,
       main,
       page,
       par.strip.text,
       prepanel,
       scales,
       skip,
       strip,
       strip.left,
       sub,
       xlab,
       ylab,
       xlab.top,
       ylab.right,
       xlim,
       ylim,
       xscale.components,
       yscale.components,
       axis,
       par.settings,
       plot.args,
       lattice.options,
       index.cond,
       perm.cond,
       ...)

## S3 method for class 'trellis'
t(x)

## S3 method for class 'trellis'
x[i, j, ..., drop = FALSE]

trellis.last.object(..., prefix)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="C_06_update.trellis_+3A_object">object</code>, <code id="C_06_update.trellis_+3A_x">x</code></td>
<td>

<p>The object to be updated, of class <code>"trellis"</code>.
</p>
</td></tr>
<tr><td><code id="C_06_update.trellis_+3A_i">i</code>, <code id="C_06_update.trellis_+3A_j">j</code></td>
<td>
<p> indices to be used.  Names are not currently allowed. </p>
</td></tr>
<tr><td><code id="C_06_update.trellis_+3A_drop">drop</code></td>
<td>

<p>logical, whether dimensions with only one level are to be dropped.
Currently ignored, behaves as if it were <code>FALSE</code>.
</p>
</td></tr>



<tr><td><code id="C_06_update.trellis_+3A_panel">panel</code>, <code id="C_06_update.trellis_+3A_aspect">aspect</code>, <code id="C_06_update.trellis_+3A_as.table">as.table</code>, <code id="C_06_update.trellis_+3A_between">between</code>, <code id="C_06_update.trellis_+3A_key">key</code>, <code id="C_06_update.trellis_+3A_auto.key">auto.key</code>, <code id="C_06_update.trellis_+3A_legend">legend</code>, <code id="C_06_update.trellis_+3A_layout">layout</code>, <code id="C_06_update.trellis_+3A_main">main</code>, <code id="C_06_update.trellis_+3A_page">page</code>, <code id="C_06_update.trellis_+3A_par.strip.text">par.strip.text</code>, <code id="C_06_update.trellis_+3A_prepanel">prepanel</code>, <code id="C_06_update.trellis_+3A_scales">scales</code>, <code id="C_06_update.trellis_+3A_skip">skip</code>, <code id="C_06_update.trellis_+3A_strip">strip</code>, <code id="C_06_update.trellis_+3A_strip.left">strip.left</code>, <code id="C_06_update.trellis_+3A_sub">sub</code>, <code id="C_06_update.trellis_+3A_xlab">xlab</code>, <code id="C_06_update.trellis_+3A_ylab">ylab</code>, <code id="C_06_update.trellis_+3A_xlab.top">xlab.top</code>, <code id="C_06_update.trellis_+3A_ylab.right">ylab.right</code>, <code id="C_06_update.trellis_+3A_xlim">xlim</code>, <code id="C_06_update.trellis_+3A_ylim">ylim</code>, <code id="C_06_update.trellis_+3A_xscale.components">xscale.components</code>, <code id="C_06_update.trellis_+3A_yscale.components">yscale.components</code>, <code id="C_06_update.trellis_+3A_axis">axis</code>, <code id="C_06_update.trellis_+3A_par.settings">par.settings</code>, <code id="C_06_update.trellis_+3A_plot.args">plot.args</code>, <code id="C_06_update.trellis_+3A_lattice.options">lattice.options</code>, <code id="C_06_update.trellis_+3A_index.cond">index.cond</code>, <code id="C_06_update.trellis_+3A_perm.cond">perm.cond</code>, <code id="C_06_update.trellis_+3A_...">...</code></td>
<td>

<p>arguments that will be used to update <code>object</code>. See details
below. 
</p>
</td></tr>
<tr><td><code id="C_06_update.trellis_+3A_prefix">prefix</code></td>
<td>

<p>A character string acting as a prefix identifying the plot of a
<code>"trellis"</code> object.  Only relevant when a particular page is
occupied by more than one plot.  Defaults to the value appropriate
for the last <code>"trellis"</code> object printed.  See
<code><a href="#topic+trellis.focus">trellis.focus</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All high level lattice functions such as <code>xyplot</code> produce an
object of (S3) class <code>"trellis"</code>, which is usually displayed by its
<code>print</code> method. However, the object itself can be manipulated and
modified to a large extent using the <code>update</code> method, and then
re-displayed as needed.
</p>
<p>Most arguments to high level functions can also be supplied to the
<code>update</code> method as well, with some exceptions. Generally
speaking, anything that would needs to change the data within each
panel is a no-no (this includes the <code>formula, data, groups,
    subscripts</code> and <code>subset</code>). Everything else is technically game,
though might not be implemented yet. If you find something missing
that you wish to have, feel free to make a request.
</p>
<p>Not all arguments accepted by a Lattice function are processed by
<code>update</code>, but the ones listed above should work.  The purpose of
these arguments are described in the help page for
<code><a href="#topic+xyplot">xyplot</a></code>.  Any other argument is added to the list of
arguments to be passed to the <code>panel</code> function. Because of their
somewhat special nature, updates to objects produced by <code>cloud</code>
and <code>wireframe</code> do not work very well yet.
</p>
<p>The <code>"["</code> method is a convenient shortcut for updating
<code>index.cond</code>.  The <code>t</code> method is a convenient shortcut for
updating <code>perm.cond</code> in the special (but frequent) case where
there are exactly two conditioning variables, when it has the effect
of switching (&lsquo;transposing&rsquo;) their order.
</p>
<p>The print method for <code>"trellis"</code> objects optionally saves the
object after printing it.  If this feature is enabled,
<code>trellis.last.object</code> can retrieve it.  By default, the last
object plotted is retrieved, but if multiple objects are plotted on
the current page, then others can be retrieved using the appropriate
<code>prefix</code> argument.  If <code><a href="#topic+trellis.last.object">trellis.last.object</a></code> is
called with arguments, these are used to update the retrieved object
before returning it.
</p>


<h3>Value</h3>

<p>An object of class <code>trellis</code>, by default plotted by
<code>print.trellis</code>.  <code>trellis.last.object</code> returns
<code>NULL</code> is no saved object is available.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+trellis.object">trellis.object</a></code>, <code><a href="#topic+Lattice">Lattice</a></code>,
<code><a href="#topic+xyplot">xyplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spots &lt;- by(sunspots, gl(235, 12, labels = 1749:1983), mean)
old.options &lt;- lattice.options(save.object = TRUE)
xyplot(spots ~ 1749:1983, xlab = "", type = "l",
       scales = list(x = list(alternating = 2)),
       main = "Average Yearly Sunspots")
update(trellis.last.object(), aspect = "xy")
trellis.last.object(xlab = "Year")
lattice.options(old.options)
</code></pre>

<hr>
<h2 id='C_07_shingles'>shingles</h2><span id='topic+equal.count'></span><span id='topic+plot.shingle'></span><span id='topic+print.shingle'></span><span id='topic+as.character.shingleLevel'></span><span id='topic+print.shingleLevel'></span><span id='topic+summary.shingle'></span><span id='topic+as.data.frame.shingle'></span><span id='topic+as.factorOrShingle'></span><span id='topic+as.shingle'></span><span id='topic++5B.shingle'></span><span id='topic+is.shingle'></span><span id='topic+shingle'></span>

<h3>Description</h3>

<p>Functions to handle shingles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shingle(x, intervals=sort(unique(x)))
equal.count(x, ...)
as.shingle(x)
is.shingle(x)

## S3 method for class 'shingle'
plot(x, panel, xlab, ylab, ...)

## S3 method for class 'shingle'
print(x, showValues = TRUE, ...)

## S3 method for class 'shingleLevel'
as.character(x, ...)

## S3 method for class 'shingleLevel'
print(x, ...)

## S3 method for class 'shingle'
summary(object, showValues = FALSE, ...)



## S3 method for class 'shingle'
x[subset, drop = FALSE]
as.factorOrShingle(x, subset, drop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="C_07_shingles_+3A_x">x</code></td>
<td>

<p>numeric variable or R object, shingle in <code>plot.shingle</code> and
<code>x[]</code>. An object (list of intervals) of class &quot;shingleLevel&quot; in
<code>print.shingleLevel</code>
</p>
</td></tr>
<tr><td><code id="C_07_shingles_+3A_object">object</code></td>
<td>
<p> shingle object to be summarized</p>
</td></tr>
<tr><td><code id="C_07_shingles_+3A_showvalues">showValues</code></td>
<td>
<p> logical, whether to print the numeric part. If
FALSE, only the intervals are printed</p>
</td></tr>




<tr><td><code id="C_07_shingles_+3A_intervals">intervals</code></td>
<td>
<p> numeric vector or matrix with 2 columns</p>
</td></tr>
<tr><td><code id="C_07_shingles_+3A_subset">subset</code></td>
<td>
<p>logical vector</p>
</td></tr>
<tr><td><code id="C_07_shingles_+3A_drop">drop</code></td>
<td>
<p>whether redundant shingle levels are to be dropped</p>
</td></tr>
<tr><td><code id="C_07_shingles_+3A_panel">panel</code>, <code id="C_07_shingles_+3A_xlab">xlab</code>, <code id="C_07_shingles_+3A_ylab">ylab</code></td>
<td>
<p> standard Trellis arguments (see
<code><a href="#topic+xyplot">xyplot</a></code> ) </p>
</td></tr>
<tr><td><code id="C_07_shingles_+3A_...">...</code></td>
<td>
<p> other arguments, passed down as appropriate.  For
example, extra arguments to <code>equal.count</code> are passed on to
<code>co.intervals</code>.  graphical parameters can be passed as
arguments to the <code>plot</code> method.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A shingle is a data structure used in Trellis, and is a generalization
of factors to &lsquo;continuous&rsquo; variables.  It consists of a numeric
vector along with some possibly overlapping intervals. These intervals
are the &lsquo;levels&rsquo; of the shingle.  The <code>levels</code> and
<code>nlevels</code> functions, usually applicable to factors, also work on
shingles.  The implementation of shingles is slightly different from
S.
</p>
<p>There are print methods for shingles, as well as for printing the
result of <code>levels()</code> applied to a shingle.  For use in labelling,
the <code>as.character</code> method can be used to convert levels of a
shingle to character strings.
</p>
<p><code>equal.count</code> converts <code>x</code> to a shingle using the equal
count algorithm.  This is essentially a wrapper around
<code>co.intervals</code>.  All arguments are passed to <code>co.intervals</code>.
</p>
<p><code>shingle</code> creates a shingle using the given <code>intervals</code>. If
<code>intervals</code> is a vector, these are used to form 0 length
intervals.
</p>
<p><code>as.shingle</code> returns <code>shingle(x)</code> if <code>x</code> is not a
shingle.
</p>
<p><code>is.shingle</code> tests whether <code>x</code> is a shingle.
</p>
<p><code>plot.shingle</code> displays the ranges of shingles via
rectangles. <code>print.shingle</code> and <code>summary.shingle</code> describe
the shingle object.
</p>


<h3>Value</h3>

<p><code>x$intervals</code> for <code>levels.shingle(x)</code>, 
logical for <code>is.shingle</code>, an object of class <code>"trellis"</code> for
<code>plot</code> (printed by default by <code>print.trellis</code>), and 
an object of class <code>"shingle"</code> for the others.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+xyplot">xyplot</a></code>,
<code><a href="graphics.html#topic+co.intervals">co.intervals</a></code>, <code><a href="#topic+Lattice">Lattice</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- equal.count(rnorm(50))
plot(z)
print(z)
print(levels(z))

</code></pre>

<hr>
<h2 id='D_draw.colorkey'>Produce a colorkey typically for levelplot</h2><span id='topic+draw.colorkey'></span>

<h3>Description</h3>

<p>Creates (and optionally draws) a grid frame grob representing a color
key that can be placed in other grid-based plots. Primarily used by
<code>levelplot</code> when a color key is requested.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw.colorkey(key, draw = FALSE, vp = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="D_draw.colorkey_+3A_key">key</code></td>
<td>

<p>A list determining the key. See documentation for <code><a href="#topic+levelplot">levelplot</a></code>,
in particular the section describing the <code>colorkey</code> argument,
for details.
</p>
</td></tr>
<tr><td><code id="D_draw.colorkey_+3A_draw">draw</code></td>
<td>
<p> A scalar logical, indicating whether the grob is to be drawn. </p>
</td></tr>
<tr><td><code id="D_draw.colorkey_+3A_vp">vp</code></td>
<td>
<p> The viewport in which to draw the grob, if applicable. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A grid frame object (that inherits from <code>"grob"</code>)
</p>


<h3>Author(s)</h3>

<p>Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+xyplot">xyplot</a></code>, <code><a href="#topic+levelplot">levelplot</a></code></p>

<hr>
<h2 id='D_draw.key'>Produce a Legend or Key</h2><span id='topic+draw.key'></span>

<h3>Description</h3>

<p>Produces (and possibly draws) a Grid frame grob which is a legend (aka 
key) that can be placed in other Grid plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw.key(key, draw=FALSE, vp=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="D_draw.key_+3A_key">key</code></td>
<td>
<p> A list determining the key. See documentation for
<code>xyplot</code>, in particular the section describing the <code>key</code>
argument, for details.
</p>
</td></tr>
<tr><td><code id="D_draw.key_+3A_draw">draw</code></td>
<td>
<p> logical, whether the grob is to be drawn. </p>
</td></tr>
<tr><td><code id="D_draw.key_+3A_vp">vp</code></td>
<td>
<p> viewport </p>
</td></tr>
<tr><td><code id="D_draw.key_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Grid frame object (that inherits from &lsquo;grob&rsquo;).
</p>


<h3>Author(s)</h3>

<p>Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+xyplot">xyplot</a></code></p>

<hr>
<h2 id='D_level.colors'>
A function to compute false colors representing a numeric or
categorical variable
</h2><span id='topic+level.colors'></span>

<h3>Description</h3>

<p>Calculates false colors from a numeric variable (including factors,
using their numeric codes) given a color scheme and breakpoints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>level.colors(x, at, col.regions, colors = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="D_level.colors_+3A_x">x</code></td>
<td>
<p> A numeric or <code><a href="base.html#topic+factor">factor</a></code> variable. </p>
</td></tr>
<tr><td><code id="D_level.colors_+3A_at">at</code></td>
<td>
<p> A numeric variable of breakpoints defining intervals along
the range of <code>x</code>. </p>
</td></tr>
<tr><td><code id="D_level.colors_+3A_col.regions">col.regions</code></td>
<td>
<p> A specification of the colors to be assigned to
each interval defined by <code>at</code>.  This could be either a vector
of colors, or a function that produces a vector of colors when
called with a single argument giving the number of colors.   See
details below. </p>
</td></tr>
<tr><td><code id="D_level.colors_+3A_colors">colors</code></td>
<td>
<p> logical indicating whether colors should be computed
and returned.  If <code>FALSE</code>, only the indices representing which
interval (among those defined by <code>at</code>) each value in <code>x</code>
falls into is returned.  </p>
</td></tr>
<tr><td><code id="D_level.colors_+3A_...">...</code></td>
<td>
<p> Extra arguments, ignored. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>at</code> has length n, then it defines n-1 intervals.  Values of
<code>x</code> outside the range of <code>at</code> are not assigned to an
interval, and the return value is <code>NA</code> for such values.
</p>
<p>Colors are chosen by assigning a color to each of the n-1 intervals.
If <code>col.regions</code> is a palette function (such as
<code><a href="grDevices.html#topic+topo.colors">topo.colors</a></code>, or the result of calling
<code><a href="grDevices.html#topic+colorRampPalette">colorRampPalette</a></code>), it is called with n-1 as an argument
to obtain the colors.  Otherwise, if there are exactly n-1 colors in
<code>col.regions</code>, these get assigned to the intervals.  If there are
fewer than n-1 colors, <code>col.regions</code> gets recycled.  If there are
more, a more or less equally spaced (along the length of
<code>col.regions</code>) subset is chosen.
</p>


<h3>Value</h3>

<p>A vector of the same length as <code>x</code>.  Depending on the
<code>colors</code> argument, this could be either a vector of colors (in
a form usable by <span class="rlang"><b>R</b></span>), or a vector of integer indices representing
which interval the values of <code>x</code> fall in.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:deepayan.sarkar@r-project.org">deepayan.sarkar@r-project.org</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+levelplot">levelplot</a></code>, <code><a href="grDevices.html#topic+colorRampPalette">colorRampPalette</a></code>.  </p>


<h3>Examples</h3>

<pre><code class='language-R'>
depth.col &lt;-
    with(quakes, 
         level.colors(depth, at = do.breaks(range(depth), 30),
                      col.regions = hcl.colors))


xyplot(lat ~ long | equal.count(stations), quakes,
       strip = strip.custom(var.name = "Stations"),
       colours = depth.col,
       panel = function(x, y, colours, subscripts, ...) {
           panel.xyplot(x, y, pch = 21, col = "transparent",
                        fill = colours[subscripts], ...)
       })

</code></pre>

<hr>
<h2 id='D_make.groups'> Grouped data from multiple vectors </h2><span id='topic+make.groups'></span>

<h3>Description</h3>

<p>Combines two or more vectors, possibly of different lengths, producing
a data frame with a second column indicating which of these vectors
that row came from.  This is mostly useful for getting data into a
form suitable for use in high level Lattice functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.groups(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="D_make.groups_+3A_...">...</code></td>
<td>

<p>one or more vectors of the same type (coercion is attempted if not),
or one or more data frames with similar columns, with possibly
differing number of rows.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>When all the input arguments are vectors, a data frame with two
columns
</p>

<dl>
<dt><code>data</code></dt><dd>
<p>all the vectors supplied, concatenated
</p>
</dd>
<dt><code>which</code></dt><dd>
<p>factor indicating which vector the corresponding <code>data</code> value
came from
</p>
</dd>
</dl>

<p>When all the input arguments are data frames, the result of
<code><a href="base.html#topic+rbind">rbind</a></code> applied to them, along with an additional
<code>which</code> column as described above.
</p>


<h3>Author(s)</h3>

<p>Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Lattice">Lattice</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>sim.dat &lt;-
    make.groups(uniform = runif(200),
                exponential = rexp(175),
                lognormal = rlnorm(150),
                normal = rnorm(125))
qqmath( ~ data | which, sim.dat, scales = list(y = "free"))
</code></pre>

<hr>
<h2 id='D_simpleKey'> Function to generate a simple key </h2><span id='topic+simpleKey'></span>

<h3>Description</h3>

<p>Simple interface to generate a list appropriate for <code>draw.key</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simpleKey(text, points = TRUE,
          rectangles = FALSE,
          lines = FALSE,
          col, cex, alpha, font,
          fontface, fontfamily, 
          lineheight, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="D_simpleKey_+3A_text">text</code></td>
<td>

<p>character or expression vector, to be used as labels for levels of
the grouping variable
</p>
</td></tr>
<tr><td><code id="D_simpleKey_+3A_points">points</code></td>
<td>
<p> logical </p>
</td></tr>
<tr><td><code id="D_simpleKey_+3A_rectangles">rectangles</code></td>
<td>
<p> logical </p>
</td></tr>
<tr><td><code id="D_simpleKey_+3A_lines">lines</code></td>
<td>
<p> logical </p>
</td></tr>
<tr><td><code id="D_simpleKey_+3A_col">col</code>, <code id="D_simpleKey_+3A_cex">cex</code>, <code id="D_simpleKey_+3A_alpha">alpha</code>, <code id="D_simpleKey_+3A_font">font</code>, <code id="D_simpleKey_+3A_fontface">fontface</code>, <code id="D_simpleKey_+3A_fontfamily">fontfamily</code>, <code id="D_simpleKey_+3A_lineheight">lineheight</code></td>
<td>

<p>Used as top-level components of the list produced, to be used for
the text labels. Defaults to the values in
<code>trellis.par.get("add.text")</code>
</p>
</td></tr>
<tr><td><code id="D_simpleKey_+3A_...">...</code></td>
<td>

<p>further arguments added to the list, eventually passed to
<code>draw.key</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A lattice plot can include a legend (key) if an appropriate list is
specified as the <code>key</code> argument to a high level Lattice function
such as <code>xyplot</code>. This key can be very flexible, but that
flexibility comes at a cost: this list needs to be fairly complicated
even in simple situations.  <code>simpleKey</code> is designed as a useful
shortcut in the common case of a key drawn in conjunction with a
grouping variable, using the default graphical settings.
</p>
<p>The <code>simpleKey</code> function produces a suitable <code>key</code> argument
using a simpler interface.  The resulting list will use the
<code>text</code> argument as a text component, along with at most one set
each of points, rectangles, and lines.  The number of entries (rows)
in the key will be the length of the <code>text</code> component.  The
graphical parameters for the additional components will be derived
from the default graphical settings (wherein lies the simplification,
as otherwise these would have to be provided explicitly).
</p>
<p>Calling <code>simpleKey</code> directly is usually unnecessary.  It is most
commonly invoked (during the plotting of the <code>"trellis"</code> object)
when the <code>auto.key</code> argument is supplied in a high-level plot
with a <code>groups</code> argument.  In that case, the <code>text</code> argument
of <code>simpleKey</code> defaults to <code>levels(groups)</code>, and the
defaults for the other arguments depend on the relevant high-level
function.  Note that these defaults can be overridden by supplying
<code>auto.key</code> as a list containing the replacement values.
</p>


<h3>Value</h3>

<p>A list that would work as the <code>key</code> argument to
<code><a href="#topic+xyplot">xyplot</a></code>, etc.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Lattice">Lattice</a></code>, <code><a href="#topic+draw.key">draw.key</a></code>,
<code><a href="#topic+trellis.par.get">trellis.par.get</a></code>, and
<code><a href="#topic+xyplot">xyplot</a></code>, specifically the entry for <code>auto.key</code>.
</p>

<hr>
<h2 id='D_strip.default'>Default Trellis Strip Function</h2><span id='topic+strip.default'></span><span id='topic+strip.custom'></span>

<h3>Description</h3>

<p><code>strip.default</code> is the function that draws the strips by default
in Trellis plots.  Users can write their own strip functions, but most
commonly this involves calling <code>strip.default</code> with a slightly
different arguments.  <code>strip.custom</code> provides a convenient way to
obtain new strip functions that differ from <code>strip.default</code> only
in the default values of certain arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strip.default(which.given,
              which.panel,
              var.name,
              factor.levels,
              shingle.intervals,
              strip.names = c(FALSE, TRUE),
              strip.levels = c(TRUE, FALSE),
              sep = " : ",
              style = 1,
              horizontal = TRUE,
              bg = trellis.par.get("strip.background")$col[which.given],
              fg = trellis.par.get("strip.shingle")$col[which.given],
              par.strip.text = trellis.par.get("add.text"))
strip.custom(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="D_strip.default_+3A_which.given">which.given</code></td>
<td>
<p> integer index specifying which of the conditioning
variables this strip corresponds to. 
</p>
</td></tr>
<tr><td><code id="D_strip.default_+3A_which.panel">which.panel</code></td>
<td>
<p> vector of integers as long as the number of
conditioning variables. The contents are indices specifying the
current levels of each of the conditioning variables (thus, this
would be unique for each distinct packet).  This is identical to the
return value of <code><a href="#topic+which.packet">which.packet</a></code>, which is a more accurate
name.
</p>
</td></tr>






<tr><td><code id="D_strip.default_+3A_var.name">var.name</code></td>
<td>
<p> vector of character strings or expressions as long as
the number of conditioning variables.  The contents are interpreted
as names for the conditioning variables.  Whether they are shown on
the strip depends on the values of <code>strip.names</code> and
<code>style</code> (see below).  By default, the names are shown for
shingles, but not for factors.
</p>
</td></tr>
<tr><td><code id="D_strip.default_+3A_factor.levels">factor.levels</code></td>
<td>
<p> vector of character strings or expressions
giving the levels of the conditioning variable currently being
drawn.  For more than one conditioning variable, this will vary with
<code>which.given</code>.  Whether these levels are shown on the strip
depends on the values of <code>strip.levels</code> and <code>style</code> (see
below).  <code>factor.levels</code> may be specified for both factors and
shingles (despite the name), but by default they are shown only for
factors.  If shown, the labels may optionally be abbreviated by
specifying suitable components in <code>par.strip.text</code> (see
<code><a href="#topic+xyplot">xyplot</a></code>)
</p>
</td></tr>
<tr><td><code id="D_strip.default_+3A_shingle.intervals">shingle.intervals</code></td>
<td>
<p>if the current strip corresponds to a shingle,
this should be a 2-column matrix giving the levels of the shingle.
(of the form that would be produced by <b>printing</b>
<code>levels(shingle)</code>). Otherwise, it should be <code>NULL</code>
</p>
</td></tr>
<tr><td><code id="D_strip.default_+3A_strip.names">strip.names</code></td>
<td>
<p> a logical vector of length 2, indicating whether
or not the name of the conditioning variable that corresponds to the
strip being drawn is to be written on the strip. The two components
give the values for factors and shingles respectively.
</p>
<p>This argument is ignored for a factor when <code>style</code> is not one
of 1 and 3.
</p>
</td></tr>
<tr><td><code id="D_strip.default_+3A_strip.levels">strip.levels</code></td>
<td>
<p> a logical vector of length 2, indicating whether
or not the level of the conditioning variable that corresponds to
the strip being drawn is to be written on the strip.  The two
components give the values for factors and shingles respectively.
</p>
</td></tr>
<tr><td><code id="D_strip.default_+3A_sep">sep</code></td>
<td>
<p> character or expression, serving as a separator if the
name and level are both to be shown.
</p>
</td></tr>
<tr><td><code id="D_strip.default_+3A_style">style</code></td>
<td>
<p> integer, with values 1, 2, 3, 4 and 5 currently
supported, controlling how the current level of a factor is encoded.
Ignored for shingles (actually, when <code>shingle.intervals</code> is
non-null.  
</p>
<p>The best way to find out what effect the value of <code>style</code> has
is to try them out. Here is a short description: for a style value
of 1, the strip is colored in the background color with the strip
text (as determined by other arguments) centered on it. A value of 3
is the same, except that a part of the strip is colored in the
foreground color, indicating the current level of the factor. For
styles 2 and 4, the part corresponding to the current level remains
colored in the foreground color, however, for style = 2, the
remaining part is not colored at all, whereas for 4, it is colored
with the background color. For both these, the names of all the
levels of the factor are placed on the strip from left to right.
Styles 5 and 6 produce the same effect (they are subtly different in
S, this implementation corresponds to 5), they are similar to style
1, except that the strip text is not centered, it is instead
positioned according to the current level.
</p>
<p>Note that unlike S-PLUS, the default value of <code>style</code> is 1.
<code>strip.names</code> and <code>strip.levels</code> have no effect if
<code>style</code> is not 1 or 3.
</p>
</td></tr>
<tr><td><code id="D_strip.default_+3A_horizontal">horizontal</code></td>
<td>
<p> logical, specifying whether the labels etc should
be horizontal.  <code>horizontal=FALSE</code> is useful for strips on the
left of panels using <code>strip.left=TRUE</code> </p>
</td></tr>
<tr><td><code id="D_strip.default_+3A_par.strip.text">par.strip.text</code></td>
<td>
<p> list with parameters controlling the text on
each strip, with components <code>col</code>, <code>cex</code>, <code>font</code>,
etc.
</p>
</td></tr>
<tr><td><code id="D_strip.default_+3A_bg">bg</code></td>
<td>
<p> strip background color. </p>
</td></tr>
<tr><td><code id="D_strip.default_+3A_fg">fg</code></td>
<td>
<p> strip foreground color. </p>
</td></tr>
<tr><td><code id="D_strip.default_+3A_...">...</code></td>
<td>

<p>arguments to be passed on to <code>strip.default</code>, overriding
whatever value it would have normally assumed
</p>
</td></tr>
</table>


<h3>Details</h3>

<p> default strip function for trellis functions. Useful 
mostly because of the <code>style</code> argument &mdash; non-default styles
are often more informative, especially when the names of the levels
of the factor <code>x</code> are small. Traditional use is as
<code>strip = function(...) strip.default(style=2,...)</code>, though
this can be simplified by the use of <code>strip.custom</code>.
</p>


<h3>Value</h3>

<p><code>strip.default</code> is called for its side-effect, which is to draw a
strip appropriate for multi-panel Trellis conditioning plots.
<code>strip.custom</code> returns a function that is similar to
<code>strip.default</code>, but with different defaults for the arguments
specified in the call.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+xyplot">xyplot</a></code>, <code><a href="#topic+Lattice">Lattice</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Traditional use
xyplot(Petal.Length ~ Petal.Width | Species, iris,
       strip = function(..., style) strip.default(..., style = 4))

## equivalent call using strip.custom
xyplot(Petal.Length ~ Petal.Width | Species, iris,
       strip = strip.custom(style = 4))

xyplot(Petal.Length ~ Petal.Width | Species, iris,
       strip = FALSE,
       strip.left = strip.custom(style = 4, horizontal = FALSE))
</code></pre>

<hr>
<h2 id='D_trellis.object'>A Trellis Plot Object</h2><span id='topic+trellis.object'></span>

<h3>Description</h3>

<p>This class of objects is returned by high level lattice functions, and
is usually plotted by default by its
<code><a href="#topic+print.trellis">print</a></code> method.
</p>


<h3>Details</h3>

<p>A trellis object, as returned by high level lattice functions like
<code><a href="#topic+xyplot">xyplot</a></code>, is a list with the <code>"class"</code> attribute set
to <code>"trellis"</code>.  Many of the components of this list are simply
the arguments to the high level function that produced the object.
Among them are: <code>as.table</code>, <code>layout</code>, <code>page</code>,
<code>panel</code>, <code>prepanel</code>, <code>main</code>, <code>sub</code>,
<code>par.strip.text</code>, <code>strip</code>, <code>skip</code>, <code>xlab</code>
<code>ylab</code>, <code>par.settings</code>, <code>lattice.options</code> and
<code>plot.args</code>.  Some other typical components are:
</p>

<dl>
<dt><code>formula</code></dt><dd>
<p>the Trellis formula used in the call
</p>
</dd>
<dt><code>index.cond</code></dt><dd>
<p>list with index for each of the conditioning variables
</p>
</dd>
<dt><code>perm.cond</code></dt><dd>
<p>permutation of the order of the conditioning variables
</p>
</dd>
<dt><code>aspect.fill</code></dt><dd>
<p>logical, whether <code>aspect</code> is <code>"fill"</code>
</p>
</dd>
<dt><code>aspect.ratio</code></dt><dd>
<p>numeric, aspect ratio to be used if <code>aspect.fill</code> is
<code>FALSE</code>
</p>
</dd>
<dt><code>call</code></dt><dd><p> call that generated the object. </p>
</dd>
<dt><code>condlevels</code></dt><dd>
<p>list with levels of the conditioning variables
</p>
</dd>
<dt><code>legend</code></dt><dd>
<p>list describing the legend(s) to be drawn
</p>
</dd>
<dt><code>panel.args</code></dt><dd>
<p>a list as long as the number of panels, each element being a list
itself, containing the arguments in named form to be passed to the
panel function in that panel.
</p>
</dd>
<dt><code>panel.args.common</code></dt><dd>
<p>a list containing the arguments common to all the panel functions
in <code>name=value</code> form
</p>
</dd>
<dt><code>x.scales</code></dt><dd>
<p>list describing x-scale, can consist of several other lists,
paralleling panel.args, if x-relation is not <code>"same"</code>
</p>
</dd>
<dt><code>y.scales</code></dt><dd>
<p>list describing y-scale, similar to <code>x.scales</code>
</p>
</dd>
<dt><code>x.between</code></dt><dd><p> numeric vector of interpanel x-space </p>
</dd>
<dt><code>y.between</code></dt><dd><p> numeric vector of interpanel y-space </p>
</dd>
<dt><code>x.limits</code></dt><dd>
<p>numeric vector of length 2 or list, giving x-axis limits
</p>
</dd>
<dt><code>y.limits</code></dt><dd><p> similar to <code>x.limits</code> </p>
</dd>
<dt><code>packet.sizes</code></dt><dd>
<p>array recording the number of observations in each packet
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Lattice">Lattice</a></code>, <code><a href="#topic+xyplot">xyplot</a></code>,
<code><a href="#topic+print.trellis">print.trellis</a></code>
</p>

<hr>
<h2 id='E_interaction'>Functions to Interact with Lattice Plots</h2><span id='topic+panel.identify'></span><span id='topic+panel.identify.qqmath'></span><span id='topic+panel.identify.cloud'></span><span id='topic+panel.link.splom'></span><span id='topic+panel.brush.splom'></span><span id='topic+trellis.focus'></span><span id='topic+trellis.unfocus'></span><span id='topic+trellis.switchFocus'></span><span id='topic+trellis.panelArgs'></span><span id='topic+trellis.vpname'></span><span id='topic+trellis.grobname'></span>

<h3>Description</h3>

<p>The classic Trellis paradigm is to plot the whole object at once,
without the possibility of interacting with it afterwards.  However,
by keeping track of the grid viewports where the panels and strips are
drawn, it is possible to go back to them afterwards and enhance them
one panel at a time.  These functions provide convenient interfaces to
help in this.  Note that these are still experimental and the exact
details may change in future.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.identify(x, y = NULL,
               subscripts = seq_along(x),
               labels = subscripts, 
               n = length(x), offset = 0.5,
               threshold = 18, ## in points, roughly 0.25 inches
               panel.args = trellis.panelArgs(),
               ...)
panel.identify.qqmath(x, distribution, groups, subscripts, labels,
                      panel.args = trellis.panelArgs(),
                      ...)
panel.identify.cloud(x, y, z, subscripts,
                     perspective, distance, 
                     xlim, ylim, zlim,
                     screen, R.mat, aspect, scales.3d,
                     ...,
                     panel.3d.identify,
                     n = length(subscripts),
                     offset = 0.5,
                     threshold = 18,
                     labels = subscripts,
                     panel.args = trellis.panelArgs())
panel.link.splom(threshold = 18, verbose = getOption("verbose"), ...)
panel.brush.splom(threshold = 18, verbose = getOption("verbose"), ...)


trellis.vpname(name = c("position", "split", "split.location", "toplevel",
                        "figure", "panel", "strip", "strip.left",
                        "legend", "legend.region", "main", "sub",
                        "xlab", "ylab", "xlab.top", "ylab.right", "page"),
               column, row,
               side = c("left", "top", "right", "bottom", "inside"),
               clip.off = FALSE, prefix)
trellis.grobname(name,
                 type = c("", "panel", "strip", "strip.left",
                          "key", "colorkey"),
                 group = 0,
                 which.given = lattice.getStatus("current.which.given",
                                                 prefix = prefix),
                 which.panel = lattice.getStatus("current.which.panel",
                                                 prefix = prefix),
                 column = lattice.getStatus("current.focus.column",
                                            prefix = prefix),
                 row = lattice.getStatus("current.focus.row",
                                         prefix = prefix),
                 prefix = lattice.getStatus("current.prefix"))
trellis.focus(name, column, row, side, clip.off,
              highlight = interactive(), ..., prefix,
              guess = TRUE, verbose = getOption("verbose"))
trellis.switchFocus(name, side, clip.off, highlight, ..., prefix)
trellis.unfocus()
trellis.panelArgs(x, packet.number)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="E_interaction_+3A_x">x</code>, <code id="E_interaction_+3A_y">y</code>, <code id="E_interaction_+3A_z">z</code></td>
<td>
<p> variables defining the contents of the panel.  In the
case of <code>trellis.panelArgs</code>, a <code>"trellis"</code> object. </p>
</td></tr>
<tr><td><code id="E_interaction_+3A_n">n</code></td>
<td>

<p>the number of points to identify by default (overridden by a right
click)
</p>
</td></tr>
<tr><td><code id="E_interaction_+3A_subscripts">subscripts</code></td>
<td>

<p>an optional vector of integer indices associated with each point.
See details below.
</p>
</td></tr>
<tr><td><code id="E_interaction_+3A_labels">labels</code></td>
<td>

<p>an optional vector of labels associated with each point.  Defaults
to <code>subscripts</code>
</p>
</td></tr>
<tr><td><code id="E_interaction_+3A_distribution">distribution</code>, <code id="E_interaction_+3A_groups">groups</code></td>
<td>
<p> typical panel arguments of
<code><a href="#topic+panel.qqmath">panel.qqmath</a></code>.  These will usually be obtained from
<code>panel.args</code>
</p>
</td></tr>
<tr><td><code id="E_interaction_+3A_offset">offset</code></td>
<td>

<p>the labels are printed either below, above, to the left or to the
right of the identified point, depending on the relative location of
the mouse click. The <code>offset</code> specifies (in &quot;char&quot; units) how
far from the identified point the labels should be printed.
</p>
</td></tr>
<tr><td><code id="E_interaction_+3A_threshold">threshold</code></td>
<td>

<p>threshold in grid's <code>"points"</code> units. Points further than these
from the mouse click position are not considered
</p>
</td></tr>
<tr><td><code id="E_interaction_+3A_panel.args">panel.args</code></td>
<td>

<p>list that contains components names <code>x</code> (and usually <code>y</code>),
to be used if <code>x</code> is missing.  Typically, when called after
<code>trellis.focus</code>, this would appropriately be the arguments
passed to that panel.
</p>
</td></tr>
<tr><td><code id="E_interaction_+3A_perspective">perspective</code>, <code id="E_interaction_+3A_distance">distance</code>, <code id="E_interaction_+3A_xlim">xlim</code>, <code id="E_interaction_+3A_ylim">ylim</code>, <code id="E_interaction_+3A_zlim">zlim</code>, <code id="E_interaction_+3A_screen">screen</code>, <code id="E_interaction_+3A_r.mat">R.mat</code>, <code id="E_interaction_+3A_aspect">aspect</code>, <code id="E_interaction_+3A_scales.3d">scales.3d</code></td>
<td>

<p>arguments as passed to <code><a href="#topic+panel.cloud">panel.cloud</a></code>.  These are
required to recompute the relevant three-dimensional projections in
<code>panel.identify.cloud</code>.
</p>
</td></tr>
<tr><td><code id="E_interaction_+3A_panel.3d.identify">panel.3d.identify</code></td>
<td>

<p>the function that is responsible for the actual interaction once the
data rescaling and rotation computations have been done.  By
default, an internal function similar to <code>panel.identify</code> is
used.
</p>
</td></tr>
<tr><td><code id="E_interaction_+3A_name">name</code></td>
<td>

<p>A character string indicating which viewport or grob we are looking
for.  Although these do not necessarily provide access to all
viewports and grobs created by a lattice plot, they cover most of
the ones that end-users may find interesting.
</p>
<p><code>trellis.vpname</code> and <code>trellis.focus</code> deal with viewport
names only, and only accept the values explicitly listed above.
<code>trellis.grobname</code> is meant to create names for grobs, and can
currently accept any value.
</p>
<p>If <code>name</code>, as well as <code>column</code> and <code>row</code> is missing
in a call to <code>trellis.focus</code>, the user can click inside a panel
(or an associated strip) to focus on that panel.  Note however that
this assumes equal width and height for each panel, and may not work
when this is not true.
</p>
<p>When <code>name</code> is <code>"panel"</code>, <code>"strip"</code>, or
<code>"strip.left"</code>, <code>column</code> and <code>row</code> must also be
specified.  When <code>name</code> is <code>"legend"</code>, <code>side</code> must
also be specified.
</p>
</td></tr>
<tr><td><code id="E_interaction_+3A_column">column</code>, <code id="E_interaction_+3A_row">row</code></td>
<td>

<p>integers, indicating position of the panel or strip that should be
assigned focus in the Trellis layout. Rows are usually calculated
from the bottom up, unless the plot was created with
<code>as.table=TRUE</code>
</p>
</td></tr>
<tr><td><code id="E_interaction_+3A_guess">guess</code></td>
<td>

<p>logical.  If <code>TRUE</code>, and the display has only one panel, that
panel will be automatically selected by a call to
<code>trellis.focus</code>.
</p>
</td></tr>
<tr><td><code id="E_interaction_+3A_side">side</code></td>
<td>

<p>character string, relevant only for legends (i.e., when
<code>name="legend"</code>), indicating their position.  Partial specification
is allowed, as long as it is unambiguous.
</p>
</td></tr>
<tr><td><code id="E_interaction_+3A_clip.off">clip.off</code></td>
<td>

<p>logical, whether clipping should be off, relevant when <code>name</code>
is <code>"panel"</code> or <code>"strip"</code>.  This is necessary if axes are
to be drawn outside the panel or strip.  Note that setting
<code>clip.off=FALSE</code> does not necessarily mean that clipping is on;
that is determined by conditions in effect during printing.
</p>
</td></tr>
<tr><td><code id="E_interaction_+3A_type">type</code></td>
<td>

<p>A character string specifying whether the grob is specific to
a particular panel or strip.
</p>
<p>When <code>type</code> is <code>"panel"</code>, <code>"strip"</code>, or
<code>"strip.left"</code>, information about the panel is added to the
grob name.
</p>
</td></tr>
<tr><td><code id="E_interaction_+3A_group">group</code></td>
<td>

<p>An integer specifying whether the grob is specific to a particular
group within the plot.
</p>
<p>When <code>group</code> is greater than zero, information about the
group is added to the grob name.
</p>
</td></tr>
<tr><td><code id="E_interaction_+3A_which.given">which.given</code>, <code id="E_interaction_+3A_which.panel">which.panel</code></td>
<td>

<p>integers, indicating which conditional variable is being
represented (within a strip) and the current levels of
the conditional variables.
</p>
<p>When <code>which.panel</code> has length greater than 1,
and the <code>type</code> is <code>"strip"</code> or <code>"strip.left"</code>,
information about the conditional variable is added to
the grob name.
</p>
</td></tr>
<tr><td><code id="E_interaction_+3A_prefix">prefix</code></td>
<td>

<p>A character string acting as a prefix identifying the plot of a
<code>"trellis"</code> object, primarily used to distinguish otherwise
equivalent viewports in different plots. This only becomes relevant
when a particular page is occupied by more than one plot.  Defaults
to the value appropriate for the last <code>"trellis"</code> object
printed, as determined by the <code>prefix</code> argument in
<code><a href="#topic+print.trellis">print.trellis</a></code>.
</p>
<p>Users should not usually need to supply a value for this argument
except to interact with an existing plot other than the one plotted
last.
</p>
<p>For <code>switchFocus</code>, ignored except when it does not match the
prefix of the currently active plot, in which case an error occurs.
</p>
</td></tr>
<tr><td><code id="E_interaction_+3A_highlight">highlight</code></td>
<td>

<p>logical, whether the viewport being assigned focus should be
highlighted.  For <code>trellis.focus</code>, the default is <code>TRUE</code>
in interactive mode, and <code>trellis.switchFocus</code> by default
preserves the setting currently active.
</p>
</td></tr>
<tr><td><code id="E_interaction_+3A_packet.number">packet.number</code></td>
<td>

<p>integer, which panel to get data from.  See
<code><a href="#topic+packet.number">packet.number</a></code> for details on how this is calculated
</p>
</td></tr>
<tr><td><code id="E_interaction_+3A_verbose">verbose</code></td>
<td>
<p> whether details  will be printed </p>
</td></tr>
<tr><td><code id="E_interaction_+3A_...">...</code></td>
<td>

<p>For <code>panel.identify.qqmath</code>, extra parameters are passed on to
<code>panel.identify</code>.  For <code>panel.identify</code>, extra arguments
are treated as graphical parameters and are used for labelling.  For
<code>trellis.focus</code> and <code>trellis.switchFocus</code>, these are used
(in combination with <code><a href="#topic+lattice.options">lattice.options</a></code>) for highlighting
the chosen viewport if so requested.  Graphical parameters can be
supplied for <code>panel.link.splom</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>panel.identify</code> is similar to <code><a href="graphics.html#topic+identify">identify</a></code>.  When
called, it waits for the user to identify points (in the panel being
drawn) via mouse clicks.  Clicks other than left-clicks terminate the
procedure.  Although it is possible to call it as part of the panel
function, it is more typical to use it to identify points after
plotting the whole object, in which case a call to
<code>trellis.focus</code> first is necessary.
</p>
<p><code>panel.link.splom</code> is meant for use with <code><a href="#topic+splom">splom</a></code>,
and requires a panel to be chosen using <code>trellis.focus</code> before it
is called.  Clicking on a point causes that and the corresponding
proections in other pairwise scatter plots to be highlighted.
<code>panel.brush.splom</code> is a (misnamed) alias for
<code>panel.link.splom</code>, retained for back-compatibility.
</p>
<p><code>panel.identify.qqmath</code> is a specialized wrapper meant for use
with the display produced by <code><a href="#topic+qqmath">qqmath</a></code>.
<code>panel.identify.qqmath</code> is a specialized wrapper meant for use
with the display produced by <code><a href="#topic+cloud">cloud</a></code>.  It would be unusual
to call them except in a context where default panel function
arguments are available through <code>trellis.panelArgs</code> (see below).
</p>
<p>One way in which <code>panel.identify</code> etc. are different from
<code><a href="graphics.html#topic+identify">identify</a></code> is in how it uses the <code>subscripts</code>
argument.  In general, when one identifies points in a panel, one
wants to identify the origin in the data frame used to produce the
plot, and not within that particular panel.  This information is
available to the panel function, but only in certain situations.  One
way to ensure that <code>subscripts</code> is available is to specify
<code>subscripts = TRUE</code> in the high level call such as <code>xyplot</code>.
If <code>subscripts</code> is not explicitly specified in the call to
<code>panel.identify</code>, but is available in <code>panel.args</code>, then
those values will be used.  Otherwise, they default to
<code>seq_along(x)</code>.  In either case, the final return value will be
the subscripts that were marked.
</p>
<p>The process of printing (plotting) a Trellis object builds up a grid
layout with named viewports which can then be accessed to modify the
plot further.  While full flexibility can only be obtained by using
grid functions directly, a few lattice functions are available for the
more common tasks.
</p>
<p><code>trellis.focus</code> can be used to move to a particular panel or
strip, identified by its position in the array of panels.  It can also
be used to focus on the viewport corresponding to one of the labels or
a legend, though such usage would be less useful.  The exact
viewport is determined by the <code>name</code> along with the other
arguments, not all of which are relevant for all names.  Note that
when more than one object is plotted on a page, <code>trellis.focus</code>
will always go to the plot that was created last.  For more
flexibility, use grid functions directly (see note below).
</p>
<p>After a successful call to <code>trellis.focus</code>, the desired viewport
(typically panel or strip area) will be made the &lsquo;current&rsquo;
viewport (plotting area), which can then be enhanced by calls to
standard lattice panel functions as well as grid functions.
</p>
<p>It is quite common to have the layout of panels chosen when a
<code>"trellis"</code> object is drawn, and not before then.  Information on
the layout (specifically, how many rows and columns, and which packet
belongs in which position in this layout) is retained for the last
<code>"trellis"</code> object plotted, and is available through
<code>trellis.currentLayout</code>.
</p>
<p><code>trellis.unfocus</code> unsets the focus, and makes the top level
viewport the current viewport.
</p>
<p><code>trellis.switchFocus</code> is a convenience function to switch from
one viewport to another, while preserving the current <code>row</code> and
<code>column</code>.  Although the rows and columns only make sense for
panels and strips, they would be preserved even when the user switches
to some other viewport (where row/column is irrelevant) and then
switches back.
</p>
<p>Once a panel or strip is in focus, <code>trellis.panelArgs</code> can be
used to retrieve the arguments that were available to the panel
function at that position.  In this case, it can be called without
arguments as </p>
<pre>trellis.panelArgs()</pre>
<p>This usage is also allowed when a <code>"trellis"</code> object is being
printed, e.g. inside the panel functions or the axis function (but not
inside the prepanel function).  <code>trellis.panelArgs</code> can also
retrieve the panel arguments from any <code>"trellis"</code> object.  Note
that for this usage, one needs to specify the <code>packet.number</code> (as
described under the <code>panel</code> entry in <code><a href="#topic+xyplot">xyplot</a></code>) and
not the position in the layout, because a layout determines the panel
only <b>after</b> the object has been printed.
</p>
<p>It is usually not necessary to call <code>trellis.vpname</code> and
<code>trellis.grobname</code> directly.  However, they can be useful in
generating appropriate names in a portable way when using grid
functions to interact with the plots directly, as described in the
note below.
</p>


<h3>Value</h3>

<p><code>panel.identify</code> returns an integer vector containing the
subscripts of the identified points (see details above).  The
equivalent of <code>identify</code> with <code>pos=TRUE</code> is not yet
implemented, but can be considered for addition if requested.
</p>
<p><code>trellis.panelArgs</code> returns a named list of arguments that were
available to the panel function for the chosen panel.
</p>
<p><code>trellis.vpname</code> and <code>trellis.grobname</code> return character
strings.
</p>
<p><code>trellis.focus</code> has a meaningful return value only if it has been
used to focus on a panel interactively, in which case the return value
is a list with components <code>col</code> and <code>row</code> giving the column
and row positions respectively of the chosen panel, unless the choice
was cancelled (by a right click), in which case the return value is
<code>NULL</code>.  If click was outside a panel, both <code>col</code> and
<code>row</code> are set to 0.
</p>


<h3>Note</h3>

<p>The viewports created by lattice are accessible to the user through
<code>trellis.focus</code> as described above.  Functions from the grid
package can also be used directly.  For example,
<code><a href="grid.html#topic+current.viewport">current.vpTree</a></code> can be used to
inspect the current viewport tree and
<code><a href="grid.html#topic+viewports">seekViewport</a></code> or
<code><a href="grid.html#topic+viewports">downViewport</a></code> can be used to navigate to
these viewports.  For such usage, <code>trellis.vpname</code> and
<code>trellis.grobname</code> provides a portable way to access the
appropriate viewports and grobs by name.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a>.  Felix
Andrews provided initial implementations of
<code>panel.identify.qqmath</code> and support for focusing on panels
interctively.
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+identify">identify</a></code>, <code><a href="#topic+Lattice">Lattice</a></code>,
<code><a href="#topic+print.trellis">print.trellis</a></code>, <code><a href="#topic+trellis.currentLayout">trellis.currentLayout</a></code>,
<code><a href="grid.html#topic+current.viewport">current.vpTree</a></code>,
<code><a href="grid.html#topic+viewports">viewports</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
xyplot(1:10 ~ 1:10)
trellis.focus("panel", 1, 1)
panel.identify()

## End(Not run)

xyplot(Petal.Length ~ Sepal.Length | Species, iris, layout = c(2, 2))
Sys.sleep(1)

trellis.focus("panel", 1, 1)
do.call("panel.lmline", trellis.panelArgs())
Sys.sleep(0.5)
trellis.unfocus()

trellis.focus("panel", 2, 1)
do.call("panel.lmline", trellis.panelArgs())
Sys.sleep(0.5)
trellis.unfocus()

trellis.focus("panel", 1, 2)
do.call("panel.lmline", trellis.panelArgs())
Sys.sleep(0.5)
trellis.unfocus()


## choosing loess smoothing parameter

p &lt;- xyplot(dist ~ speed, cars)

panel.loessresid &lt;-
    function(x = panel.args$x,
             y = panel.args$y,
             span,
             panel.args = trellis.panelArgs())
{
    fm &lt;- loess(y ~ x, span = span)
    xgrid &lt;- do.breaks(current.panel.limits()$xlim, 50)
    ygrid &lt;- predict(fm, newdata = data.frame(x = xgrid))
    panel.lines(xgrid, ygrid)
    pred &lt;- predict(fm)
    ## center residuals so that they fall inside panel
    resids &lt;- y - pred + mean(y)
    fm.resid &lt;- loess.smooth(x, resids, span = span)
    ##panel.points(x, resids, col = 1, pch = 4)
    panel.lines(fm.resid, col = 1)
}


spans &lt;- c(0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8)
update(p, index.cond = list(rep(1, length(spans))))
panel.locs &lt;- trellis.currentLayout()

i &lt;- 1

for (row in 1:nrow(panel.locs))
    for (column in 1:ncol(panel.locs))
    if (panel.locs[row, column] &gt; 0)
{
    trellis.focus("panel", row = row, column = column,
                  highlight = FALSE)
    panel.loessresid(span = spans[i])
    grid::grid.text(paste("span = ", spans[i]),
                    x = 0.25,
                    y = 0.75,
                    default.units = "npc")
    trellis.unfocus()
    i &lt;- i + 1
}


</code></pre>

<hr>
<h2 id='F_1_panel.barchart'> Default Panel Function for barchart</h2><span id='topic+panel.barchart'></span>

<h3>Description</h3>

<p>Default panel function for <code>barchart</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.barchart(x, y, box.ratio = 1, box.width,
               horizontal = TRUE,
               origin = NULL, reference = TRUE,
               stack = FALSE,
               groups = NULL, 
               col = if (is.null(groups)) plot.polygon$col
                     else superpose.polygon$col,
               border = if (is.null(groups)) plot.polygon$border
                        else superpose.polygon$border,
               lty = if (is.null(groups)) plot.polygon$lty
                     else superpose.polygon$lty, 
               lwd = if (is.null(groups)) plot.polygon$lwd
                     else superpose.polygon$lwd,
               ..., identifier = "barchart")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="F_1_panel.barchart_+3A_x">x</code></td>
<td>
<p> Extent of Bars. By default, bars start at left of panel,
unless <code>origin</code> is specified, in which case they start there.
</p>
</td></tr>
<tr><td><code id="F_1_panel.barchart_+3A_y">y</code></td>
<td>
<p> Horizontal location of bars. Possibly a factor. </p>
</td></tr>
<tr><td><code id="F_1_panel.barchart_+3A_box.ratio">box.ratio</code></td>
<td>
<p> Ratio of bar width to inter-bar space. </p>
</td></tr>
<tr><td><code id="F_1_panel.barchart_+3A_box.width">box.width</code></td>
<td>
<p> Thickness of bars in absolute units; overrides
<code>box.ratio</code>.  Useful for specifying thickness when the
categorical variable is not a factor, as use of <code>box.ratio</code>
alone cannot achieve a thickness greater than 1. </p>
</td></tr>
<tr><td><code id="F_1_panel.barchart_+3A_horizontal">horizontal</code></td>
<td>

<p>Logical flag. If FALSE, the plot is &lsquo;transposed&rsquo; in the sense
that the behaviours of x and y are switched. x is now the
&lsquo;factor&rsquo;.  Interpretation of other arguments change
accordingly. See documentation of <code><a href="#topic+bwplot">bwplot</a></code> for a fuller
explanation.
</p>
</td></tr>
<tr><td><code id="F_1_panel.barchart_+3A_origin">origin</code></td>
<td>
<p> The origin for the bars.  For grouped displays with
<code>stack = TRUE</code>, this argument is ignored and the origin set to
0.  Otherwise, defaults to <code>NULL</code>, in which case bars start at
the left (or bottom) end of a panel.  This choice is somewhat
unfortuntate, as it can be misleading, but is the default for
historical reasons.  For tabular (or similar) data, <code>origin =
      0</code> is usually more appropriate; if not, one should reconsider the
use of a bar chart in the first place (dot plots are often a good
alternative).
</p>
</td></tr>
<tr><td><code id="F_1_panel.barchart_+3A_reference">reference</code></td>
<td>
<p> Logical, whether a reference line is to be drawn at
the origin.
</p>
</td></tr>
<tr><td><code id="F_1_panel.barchart_+3A_stack">stack</code></td>
<td>
<p> logical, relevant when groups is non-null. If
<code>FALSE</code> (the default), bars for different values of the
grouping variable are drawn side by side, otherwise they are
stacked.
</p>
</td></tr>
<tr><td><code id="F_1_panel.barchart_+3A_groups">groups</code></td>
<td>
<p> Optional grouping variable. </p>
</td></tr>
<tr><td><code id="F_1_panel.barchart_+3A_col">col</code>, <code id="F_1_panel.barchart_+3A_border">border</code>, <code id="F_1_panel.barchart_+3A_lty">lty</code>, <code id="F_1_panel.barchart_+3A_lwd">lwd</code></td>
<td>

<p>Graphical parameters for the bars. By default, the trellis parameter
<code>plot.polygon</code> is used if there is no grouping variable, otherwise
<code>superpose.polygon</code> is used.  <code>col</code> gives the fill color,
<code>border</code> the border color, and <code>lty</code> and <code>lwd</code> the
line type and width of the borders.
</p>
</td></tr>
<tr><td><code id="F_1_panel.barchart_+3A_...">...</code></td>
<td>
<p> Extra arguments will be accepted but ignored. </p>
</td></tr>
<tr><td><code id="F_1_panel.barchart_+3A_identifier">identifier</code></td>
<td>

<p>A character string that is prepended to the names of grobs
that are created by this panel function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A barchart is drawn in the panel. Note that most arguments controlling
the display can be supplied to the high-level <code>barchart</code> call
directly.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+barchart">barchart</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
barchart(yield ~ variety | site, data = barley,
         groups = year, layout = c(1,6), origin = 0,
         ylab = "Barley Yield (bushels/acre)",
         scales = list(x = list(abbreviate = TRUE,
                                minlength = 5)))

</code></pre>

<hr>
<h2 id='F_1_panel.bwplot'> Default Panel Function for bwplot </h2><span id='topic+panel.bwplot'></span>

<h3>Description</h3>

<p>This is the default panel function for <code>bwplot</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.bwplot(x, y, box.ratio = 1,
             box.width = box.ratio / (1 + box.ratio),
             horizontal = TRUE,
             pch, col, alpha, cex, 
             font, fontfamily, fontface, 
             fill, varwidth = FALSE,
             notch = FALSE, notch.frac = 0.5,
             ...,
             levels.fos,
             stats = boxplot.stats,
             coef = 1.5,
             do.out = TRUE,
             identifier = "bwplot")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="F_1_panel.bwplot_+3A_x">x</code>, <code id="F_1_panel.bwplot_+3A_y">y</code></td>
<td>
<p> numeric vector or factor. Boxplots drawn for each unique value of
<code>y</code> (<code>x</code>) if <code>horizontal</code> is <code>TRUE</code> (<code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="F_1_panel.bwplot_+3A_box.ratio">box.ratio</code></td>
<td>
<p> ratio of box thickness to inter box space</p>
</td></tr>
<tr><td><code id="F_1_panel.bwplot_+3A_box.width">box.width</code></td>
<td>
<p> thickness of box in absolute units; overrides
<code>box.ratio</code>.  Useful for specifying thickness when the
categorical variable is not a factor, as use of <code>box.ratio</code>
alone cannot achieve a thickness greater than 1. </p>
</td></tr>
<tr><td><code id="F_1_panel.bwplot_+3A_horizontal">horizontal</code></td>
<td>

<p>logical. If FALSE, the plot is &lsquo;transposed&rsquo; in the sense that
the behaviours of x and y are switched. x is now the
&lsquo;factor&rsquo;.  Interpretation of other arguments change
accordingly. See documentation of <code><a href="#topic+bwplot">bwplot</a></code> for a fuller
explanation.
</p>
</td></tr>
<tr><td><code id="F_1_panel.bwplot_+3A_pch">pch</code>, <code id="F_1_panel.bwplot_+3A_col">col</code>, <code id="F_1_panel.bwplot_+3A_alpha">alpha</code>, <code id="F_1_panel.bwplot_+3A_cex">cex</code>, <code id="F_1_panel.bwplot_+3A_font">font</code>, <code id="F_1_panel.bwplot_+3A_fontfamily">fontfamily</code>, <code id="F_1_panel.bwplot_+3A_fontface">fontface</code></td>
<td>
<p> graphical
parameters controlling the dot.  <code>pch="|"</code> is treated
specially, by replacing the dot with a line (similar to
<code><a href="graphics.html#topic+boxplot">boxplot</a></code>)
</p>
</td></tr>
<tr><td><code id="F_1_panel.bwplot_+3A_fill">fill</code></td>
<td>
<p> color to fill the boxplot</p>
</td></tr>
<tr><td><code id="F_1_panel.bwplot_+3A_varwidth">varwidth</code></td>
<td>
<p> logical. If TRUE, widths of boxplots are proportional
to the number of points used in creating it.</p>
</td></tr>
<tr><td><code id="F_1_panel.bwplot_+3A_notch">notch</code></td>
<td>
<p> if <code>notch</code> is <code>TRUE</code>, a notch is drawn in each
side of the boxes.  If the notches of two plots do not overlap this
is &lsquo;strong evidence&rsquo; that the two medians differ (Chambers et
al., 1983, p. 62).  See <code><a href="grDevices.html#topic+boxplot.stats">boxplot.stats</a></code> for the
calculations used. </p>
</td></tr>
<tr><td><code id="F_1_panel.bwplot_+3A_notch.frac">notch.frac</code></td>
<td>
<p> numeric in (0,1). When <code>notch=TRUE</code>, the
fraction of the box width that the notches should use. </p>
</td></tr>
<tr><td><code id="F_1_panel.bwplot_+3A_stats">stats</code></td>
<td>
<p> a function, defaulting to <code><a href="grDevices.html#topic+boxplot.stats">boxplot.stats</a></code>,
that accepts a numeric vector and returns a list similar to the
return value of <code>boxplot.stats</code>.  The function must accept
arguments <code>coef</code> and <code>do.out</code> even if they do not use
them (a <code>...</code> argument is good enough).  This function is
used to determine the box and whisker plot.  </p>
</td></tr>
<tr><td><code id="F_1_panel.bwplot_+3A_coef">coef</code>, <code id="F_1_panel.bwplot_+3A_do.out">do.out</code></td>
<td>
<p> passed to <code>stats</code></p>
</td></tr>
<tr><td><code id="F_1_panel.bwplot_+3A_levels.fos">levels.fos</code></td>
<td>
<p> numeric values corresponding to positions of the
factor or shingle variable.  For internal use. </p>
</td></tr>
<tr><td><code id="F_1_panel.bwplot_+3A_...">...</code></td>
<td>

<p>further arguments, ignored.
</p>
</td></tr>
<tr><td><code id="F_1_panel.bwplot_+3A_identifier">identifier</code></td>
<td>

<p>A character string that is prepended to the names of grobs
that are created by this panel function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates Box and Whisker plot of <code>x</code> for every level of
<code>y</code> (or the other way round if <code>horizontal=FALSE</code>).  By
default, the actual boxplot statistics are calculated using
<code>boxplot.stats</code>.  Note that most arguments controlling the
display can be supplied to the high-level <code>bwplot</code> call directly.
</p>


<p>Although the graphical parameters for the dot representing the median
can be controlled by optional arguments, many others can not.  These
parameters are obtained from the relevant settings parameters
(<code>"box.rectangle"</code> for the box, <code>"box.umbrella"</code> for the
whiskers and <code>"plot.symbol"</code> for the outliers).
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+bwplot">bwplot</a></code>, <code><a href="grDevices.html#topic+boxplot.stats">boxplot.stats</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bwplot(voice.part ~ height, data = singer,
       xlab = "Height (inches)",
       panel = function(...) {
           panel.grid(v = -1, h = 0)
           panel.bwplot(...)
       },
       par.settings = list(plot.symbol = list(pch = 4)))

bwplot(voice.part ~ height, data = singer,
       xlab = "Height (inches)",
       notch = TRUE, pch = "|")


</code></pre>

<hr>
<h2 id='F_1_panel.cloud'> Default Panel Function for cloud </h2><span id='topic+panel.cloud'></span><span id='topic+panel.wireframe'></span><span id='topic+panel.3dscatter'></span><span id='topic+panel.3dwire'></span><span id='topic+makeShadePalette'></span>

<h3>Description</h3>

<p>Default panel functions controlling <code>cloud</code> and
<code>wireframe</code> displays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.cloud(x, y, subscripts, z,
            groups = NULL,
            perspective = TRUE,
            distance = if (perspective) 0.2 else 0, 
            xlim, ylim, zlim,
            panel.3d.cloud = "panel.3dscatter",
            panel.3d.wireframe = "panel.3dwire",
            screen = list(z = 40, x = -60),
            R.mat = diag(4), aspect = c(1, 1),
            par.box = NULL,
            xlab, ylab, zlab,
            xlab.default, ylab.default, zlab.default,
            scales.3d,
            proportion = 0.6,
            wireframe = FALSE,
            scpos,
            ...,
            at,
            identifier = "cloud")
panel.wireframe(...)
panel.3dscatter(x, y, z, rot.mat, distance,
                groups, type = "p",
                xlim, ylim, zlim,
                xlim.scaled, ylim.scaled, zlim.scaled,
                zero.scaled,
                col, col.point, col.line,
                lty, lwd, cex, pch, fill,
                cross, ..., .scale = FALSE, subscripts,
                identifier = "3dscatter")
panel.3dwire(x, y, z, rot.mat = diag(4), distance,
             shade = FALSE,
             shade.colors.palette = trellis.par.get("shade.colors")$palette,
             light.source = c(0, 0, 1000),
             xlim, ylim, zlim, 
             xlim.scaled,
             ylim.scaled,
             zlim.scaled,
             col = if (shade) "transparent" else "black",
             lty = 1, lwd = 1,
             alpha,
             col.groups = superpose.polygon$col,
             polynum = 100,
             ...,
             .scale = FALSE,
             drape = FALSE,
             at,
             col.regions = regions$col,
             alpha.regions = regions$alpha,
             identifier = "3dwire")
makeShadePalette(col.regions, ..., min = 0.05, pref = 0.75)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="F_1_panel.cloud_+3A_x">x</code>, <code id="F_1_panel.cloud_+3A_y">y</code>, <code id="F_1_panel.cloud_+3A_z">z</code></td>
<td>

<p>numeric (or possibly factors) vectors representing the data to be
displayed. The interpretation depends on the context.  For
<code>panel.cloud</code> these are essentially the same as the data passed
to the high level plot (except if <code>formula</code> was a matrix, the
appropriate <code>x</code> and <code>y</code> vectors are generated).  By the
time they are passed to <code>panel.3dscatter</code> and
<code>panel.3dwire</code>, they have been appropriately subsetted (using
<code>subscripts</code>) and scaled (to lie inside a bounding box, usually
the [-0.5, 0.5] cube).
</p>
<p>Further, for <code>panel.3dwire</code>, <code>x</code> and <code>y</code> are shorter
than <code>z</code> and represent the sorted locations defining a
rectangular grid. Also in this case, <code>z</code> may be a matrix if the
display is grouped, with each column representing one surface.
</p>
<p>In <code>panel.cloud</code> (called from <code>wireframe</code>) and
<code>panel.3dwire</code>, <code>x</code>, <code>y</code> and <code>z</code> could also be
matrices (of the same dimension) when they represent a 3-D surface
parametrized on a 2-D grid.
</p>
</td></tr>
<tr><td><code id="F_1_panel.cloud_+3A_subscripts">subscripts</code></td>
<td>

<p>index specifying which points to draw. The same <code>x</code>, <code>y</code>
and <code>z</code> values (representing the whole data) are passed to
<code>panel.cloud</code> for each panel.  <code>subscripts</code> specifies the
subset of rows to be used for the particular panel.
</p>
</td></tr>
<tr><td><code id="F_1_panel.cloud_+3A_groups">groups</code></td>
<td>

<p>specification of a grouping variable, passed down from the high
level functions.
</p>
</td></tr>
<tr><td><code id="F_1_panel.cloud_+3A_perspective">perspective</code></td>
<td>

<p>logical, whether to plot a perspective view. Setting this to
<code>FALSE</code> is equivalent to setting <code>distance</code> to 0
</p>
</td></tr>
<tr><td><code id="F_1_panel.cloud_+3A_distance">distance</code></td>
<td>

<p>numeric, between 0 and 1, controls amount of perspective. The
distance of the viewing point from the origin (in the transformed
coordinate system) is <code>1 / distance</code>. This is described in a
little more detail in the documentation for <code><a href="#topic+cloud">cloud</a></code>
</p>
</td></tr>
<tr><td><code id="F_1_panel.cloud_+3A_screen">screen</code></td>
<td>

<p>A list determining the sequence of rotations to be applied to the
data before being plotted. The initial position starts with the
viewing point along the positive z-axis, and the x and y axes in the
usual position. Each component of the list should be named one of
<code>"x"</code>, <code>"y"</code> or <code>"z"</code> (repetitions are allowed), with
their values indicating the amount of rotation about that axis in
degrees.
</p>
</td></tr>
<tr><td><code id="F_1_panel.cloud_+3A_r.mat">R.mat</code></td>
<td>

<p>initial rotation matrix in homogeneous coordinates, to be applied to
the data before <code>screen</code> rotates the view further.
</p>
</td></tr>
<tr><td><code id="F_1_panel.cloud_+3A_par.box">par.box</code></td>
<td>

<p>graphical parameters for box, namely, col, lty and lwd. By default
obtained from the parameter <code>box.3d</code>.
</p>
</td></tr>
<tr><td><code id="F_1_panel.cloud_+3A_xlim">xlim</code>, <code id="F_1_panel.cloud_+3A_ylim">ylim</code>, <code id="F_1_panel.cloud_+3A_zlim">zlim</code></td>
<td>

<p>limits for the respective axes. As with other lattice functions,
these could each be a numeric 2-vector or a character vector
indicating levels of a factor.
</p>
</td></tr>
<tr><td><code id="F_1_panel.cloud_+3A_panel.3d.cloud">panel.3d.cloud</code>, <code id="F_1_panel.cloud_+3A_panel.3d.wireframe">panel.3d.wireframe</code></td>
<td>

<p>functions that draw the data-driven part of the plot (as opposed to
the bounding box and scales) in <code>cloud</code> and
<code>wireframe</code>. This function is called after the &lsquo;back&rsquo; of
the bounding box is drawn, but before the &lsquo;front&rsquo; is drawn.
</p>
<p>Any user-defined custom display would probably want to change these
functions. The intention is to pass as much information to this
function as might be useful (not all of which are used by the
defaults). In particular, these functions can expect arguments
called <code>xlim</code>, <code>ylim</code>, <code>zlim</code> which give the bounding
box ranges in the original data scale and <code>xlim.scaled</code>,
<code>ylim.scaled</code>, <code>zlim.scaled</code> which give the bounding box
ranges in the transformed scale. More arguments can be considered on
request.
</p>
</td></tr>
<tr><td><code id="F_1_panel.cloud_+3A_aspect">aspect</code></td>
<td>
<p> aspect as in <code>cloud</code> </p>
</td></tr>
<tr><td><code id="F_1_panel.cloud_+3A_xlab">xlab</code>, <code id="F_1_panel.cloud_+3A_ylab">ylab</code>, <code id="F_1_panel.cloud_+3A_zlab">zlab</code></td>
<td>

<p>Labels, have to be lists. Typically the user will not manipulate
these, but instead control this via arguments to <code>cloud</code>
directly.
</p>
</td></tr>
<tr><td><code id="F_1_panel.cloud_+3A_xlab.default">xlab.default</code></td>
<td>
<p> for internal use  </p>
</td></tr>
<tr><td><code id="F_1_panel.cloud_+3A_ylab.default">ylab.default</code></td>
<td>
<p> for internal use  </p>
</td></tr>
<tr><td><code id="F_1_panel.cloud_+3A_zlab.default">zlab.default</code></td>
<td>
<p> for internal use  </p>
</td></tr>
<tr><td><code id="F_1_panel.cloud_+3A_scales.3d">scales.3d</code></td>
<td>
<p> list defining the scales </p>
</td></tr>
<tr><td><code id="F_1_panel.cloud_+3A_proportion">proportion</code></td>
<td>

<p>numeric scalar, gives the length of arrows as a proportion of the
sides
</p>
</td></tr>
<tr><td><code id="F_1_panel.cloud_+3A_scpos">scpos</code></td>
<td>

<p>A list with three components x, y and z (each a scalar integer),
describing which of the 12 sides of the cube the scales should be
drawn. The defaults should be OK. Valid values are x: 1, 3, 9, 11;
y: 8, 5, 7, 6 and z: 4, 2, 10, 12. (See comments in the source code
of <code>panel.cloud</code> to see the details of this enumeration.)
</p>
</td></tr>
<tr><td><code id="F_1_panel.cloud_+3A_wireframe">wireframe</code></td>
<td>
<p>logical, indicating whether this is a wireframe plot</p>
</td></tr>
<tr><td><code id="F_1_panel.cloud_+3A_drape">drape</code></td>
<td>

<p>logical, whether the facets will be colored by height, in a manner
similar to <code>levelplot</code>.  This is ignored if <code>shade=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="F_1_panel.cloud_+3A_at">at</code></td>
<td>

<p>When <code>drape = TRUE</code> in <code><a href="#topic+wireframe">wireframe</a></code>, the facets
defining the surface are colored as a function of (average) height,
similar to <code><a href="#topic+levelplot">levelplot</a></code>.  <code>at</code> is a numeric vector
giving the breakpoints along the z-axis where colors change.
</p>
</td></tr>
<tr><td><code id="F_1_panel.cloud_+3A_col.regions">col.regions</code></td>
<td>

<p>vector of colors to be used in conjunction with <code>at</code> when
<code>drape = TRUE</code>.
</p>
<p>In <code>makeShadePalette</code>, which can be used to define a shading
palette (see below), <code>col.regions</code> is an initial vector
defining the base color (as a function of height) that is then
adjusted according to irradiance and reflectance.
</p>
</td></tr>
<tr><td><code id="F_1_panel.cloud_+3A_alpha.regions">alpha.regions</code></td>
<td>
<p> numeric scalar controlling transparency when
<code>drape = TRUE</code>.
</p>
</td></tr>
<tr><td><code id="F_1_panel.cloud_+3A_rot.mat">rot.mat</code></td>
<td>

<p>4x4 transformation matrix in homogeneous coordinates. This gives the
rotation matrix combining the <code>screen</code> and <code>R.mat</code>
arguments to <code><a href="#topic+panel.cloud">panel.cloud</a></code>
</p>
</td></tr>
<tr><td><code id="F_1_panel.cloud_+3A_type">type</code></td>
<td>

<p>Character vector, specifying type of cloud plot. Can include one or
more of <code>"p"</code>, <code>"l"</code>, <code>"h"</code> or <code>"b"</code>. <code>"p"</code>
and <code>"l"</code> mean &lsquo;points&rsquo; and &lsquo;lines&rsquo; respectively,
and <code>"b"</code> means &lsquo;both&rsquo;.  <code>"h"</code> stands for
&lsquo;histogram&rsquo;, and causes a line to be drawn from each point to
the X-Y plane (i.e., the plane representing <code>z = 0</code>), or the
lower (or upper) bounding box face, whichever is closer.
</p>
</td></tr>
<tr><td><code id="F_1_panel.cloud_+3A_xlim.scaled">xlim.scaled</code>, <code id="F_1_panel.cloud_+3A_ylim.scaled">ylim.scaled</code>, <code id="F_1_panel.cloud_+3A_zlim.scaled">zlim.scaled</code></td>
<td>

<p>axis limits (after being scaled to the bounding box) 
</p>
</td></tr>
<tr><td><code id="F_1_panel.cloud_+3A_zero.scaled">zero.scaled</code></td>
<td>

<p>z-axis location (after being scaled to the bounding box) of the X-Y
plane in the original data scale, to which lines will be dropped (if
within range) from each point when <code>type = "h"</code>
</p>
</td></tr>
<tr><td><code id="F_1_panel.cloud_+3A_cross">cross</code></td>
<td>

<p>logical, defaults to <code>TRUE</code> if <code>pch = "+"</code>.
<code>panel.3dscatter</code> can represent each point by a 3d
&lsquo;cross&rsquo; of sorts (it's much easier to understand looking at
an example than from a description). This is different from the
usual <code>pch</code> argument, and reflects the depth of the points and
the orientation of the axes. This argument indicates whether this
feature will be used.
</p>
<p>This is useful for two reasons. It can be set to <code>FALSE</code> to use
<code>"+"</code> as the plotting character in the regular sense. It can
also be used to force this feature in grouped displays.
</p>
</td></tr>
<tr><td><code id="F_1_panel.cloud_+3A_shade">shade</code></td>
<td>

<p>logical, indicating whether the surface is to be colored using an
illumination model with a single light source
</p>
</td></tr>
<tr><td><code id="F_1_panel.cloud_+3A_shade.colors.palette">shade.colors.palette</code></td>
<td>

<p>a function (or the name of one) that is supposed to calculate the
color of a facet when shading is being used. Three pieces of
information are available to the function: first, the cosine of the
angle between the incident light ray and the normal to the surface
(representing foreshortening); second, the cosine of half the angle
between the reflected ray and the viewing direction (useful for
non-Lambertian surfaces); and third, the scaled (average) height of
that particular facet with respect to the total plot z-axis limits.
</p>
<p>All three numbers should be between 0 and 1. The
<code>shade.colors.palette</code> function should return a valid
color. The default function is obtained from the trellis settings
using <code>makeShadePalette</code>.
</p>
</td></tr>
<tr><td><code id="F_1_panel.cloud_+3A_min">min</code></td>
<td>
<p> numeric, between 0 and 1, giving a minimum saturation in
<code>makeShadePalette</code>
</p>
</td></tr>
<tr><td><code id="F_1_panel.cloud_+3A_pref">pref</code></td>
<td>
<p> numeric, giving a power that is applied to reflectance
value before it is used to &lsquo;darken&rsquo; the colors.
</p>
</td></tr>
<tr><td><code id="F_1_panel.cloud_+3A_light.source">light.source</code></td>
<td>

<p>a 3-vector representing (in cartesian coordinates) the light
source. This is relative to the viewing point being (0, 0,
1/distance) (along the positive z-axis), keeping in mind that all
observations are bounded within the [-0.5, 0.5] cube
</p>
</td></tr>
<tr><td><code id="F_1_panel.cloud_+3A_polynum">polynum</code></td>
<td>

<p>quadrilateral faces are drawn in batches of <code>polynum</code> at a
time. Drawing too few at a time increases the total number of calls
to the underlying <code>grid.polygon</code> function, which affects
speed. Trying to draw too many at once may be unnecessarily memory
intensive. This argument controls the trade-off.
</p>
</td></tr>
<tr><td><code id="F_1_panel.cloud_+3A_col.groups">col.groups</code></td>
<td>
<p>colors for different groups</p>
</td></tr>
<tr><td><code id="F_1_panel.cloud_+3A_col">col</code>, <code id="F_1_panel.cloud_+3A_col.point">col.point</code>, <code id="F_1_panel.cloud_+3A_col.line">col.line</code>, <code id="F_1_panel.cloud_+3A_lty">lty</code>, <code id="F_1_panel.cloud_+3A_lwd">lwd</code>, <code id="F_1_panel.cloud_+3A_cex">cex</code>, <code id="F_1_panel.cloud_+3A_pch">pch</code>, <code id="F_1_panel.cloud_+3A_fill">fill</code>, <code id="F_1_panel.cloud_+3A_alpha">alpha</code></td>
<td>

<p>Graphical parameters.  Some other arguments (such as <code>lex</code> for
line width) may also be passed through the <code>...</code> argument.
</p>
</td></tr>
<tr><td><code id="F_1_panel.cloud_+3A_...">...</code></td>
<td>
<p> other parameters, passed down when appropriate</p>
</td></tr>
<tr><td><code id="F_1_panel.cloud_+3A_.scale">.scale</code></td>
<td>

<p>Logical flag, indicating whether <code>x</code>, <code>y</code>, and <code>z</code>
should be assumed to be in the original data scale and hence scaled
before being plotted.  <code>x</code>, <code>y</code>, and <code>z</code> are usually
already scaled.  However, setting <code>.scale=TRUE</code> may be helpful
for calls to <code>panel.3dscatter</code> and <code>panel.3dwire</code> in
user-supplied panel functions.
</p>
</td></tr>
<tr><td><code id="F_1_panel.cloud_+3A_identifier">identifier</code></td>
<td>

<p>A character string that is prepended to the names of grobs
that are created by this panel function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions together are responsible for the content drawn inside
each panel in <code>cloud</code> and <code>wireframe</code>.
<code>panel.wireframe</code> is a wrapper to <code>panel.cloud</code>, which does
the actual work.
</p>
<p><code>panel.cloud</code> is responsible for drawing the content that does
not depend on the data, namely, the bounding box, the arrows/scales,
etc. At some point, depending on whether <code>wireframe</code> is TRUE, it
calls either <code>panel.3d.wireframe</code> or <code>panel.3d.cloud</code>, which
draws the data-driven part of the plot.
</p>
<p>The arguments accepted by these two functions are different, since
they have essentially different purposes. For cloud, the data is
unstructured, and <code>x</code>, <code>y</code> and <code>z</code> are all passed to
the <code>panel.3d.cloud</code> function. For wireframe, on the other hand,
<code>x</code> and <code>y</code> are increasing vectors with unique values,
defining a rectangular grid. <code>z</code> must be a matrix with
<code>length(x) * length(y)</code> rows, and as many columns as the number
of groups.
</p>
<p><code>panel.3dscatter</code> is the default <code>panel.3d.cloud</code> function.
It has a <code>type</code> argument similar to <code><a href="#topic+panel.xyplot">panel.xyplot</a></code>,
and supports grouped displays. It tries to honour depth ordering,
i.e., points and lines closer to the camera are drawn later,
overplotting more distant ones. (Of course there is no absolute
ordering for line segments, so an ad hoc ordering is used. There is no
hidden point removal.)
</p>
<p><code>panel.3dwire</code> is the default <code>panel.3d.wireframe</code>
function. It calculates polygons corresponding to the facets one by
one, but waits till it has collected information about <code>polynum</code>
facets, and draws them all at once. This avoids the overhead of
drawing <code>grid.polygon</code> repeatedly, speeding up the rendering
considerably. If <code>shade = TRUE</code>, these attempt to color the
surface as being illuminated from a light source at
<code>light.source</code>. <code>palette.shade</code> is a simple function that
provides the deafult shading colors
</p>
<p>Multiple surfaces are drawn if <code>groups</code> is non-null in the call
to <code>wireframe</code>, however, the algorithm is not sophisticated
enough to render intersecting surfaces correctly.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+cloud">cloud</a></code>, <code><a href="#topic+utilities.3d">utilities.3d</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>wireframe(volcano, shade = TRUE,
          shade.colors.palette = makeShadePalette(hcl.colors(10, "Inferno"),
                                                  pref = 0.2))
wireframe(volcano, shade = TRUE,
          shade.colors.palette = makeShadePalette(hcl.colors(10, "Dark Mint"),
                                                  pref = 0.2))
wireframe(volcano, shade = TRUE,
          shade.colors.palette = makeShadePalette(hcl.colors(10, "Harmonic"),
                                                  pref = 0.2))
</code></pre>

<hr>
<h2 id='F_1_panel.densityplot'> Default Panel Function for densityplot </h2><span id='topic+panel.densityplot'></span>

<h3>Description</h3>

<p>This is the default panel function for <code><a href="#topic+densityplot">densityplot</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.densityplot(x, darg, plot.points = "jitter",
                  ref = FALSE,
                  groups = NULL,
                  weights = NULL,
                  jitter.amount,
                  type, ...,
                  grid = lattice.getOption("default.args")$grid,
                  identifier = "density")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="F_1_panel.densityplot_+3A_x">x</code></td>
<td>
<p> data points for which density is to be estimated </p>
</td></tr>
<tr><td><code id="F_1_panel.densityplot_+3A_darg">darg</code></td>
<td>

<p>list of arguments to be passed to the <code><a href="stats.html#topic+density">density</a></code>
function. Typically, this should be a list with zero or more of the
following components : <code>bw</code>, <code>adjust</code>, <code>kernel</code>,
<code>window</code>, <code>width</code>, <code>give.Rkern</code>, <code>n</code>,
<code>from</code>, <code>to</code>, <code>cut</code>, <code>na.rm</code> (see
<code><a href="stats.html#topic+density">density</a></code> for details)
</p>
</td></tr> 
<tr><td><code id="F_1_panel.densityplot_+3A_plot.points">plot.points</code></td>
<td>

<p>logical specifying whether or not the data points should be plotted
along with the estimated density.  Alternatively, a character string
specifying how the points should be plotted.  Meaningful values are
<code>"rug"</code>, in which case <code><a href="#topic+panel.rug">panel.rug</a></code> is used to plot
a &lsquo;rug&rsquo;, and <code>"jitter"</code>, in which case the points are
jittered vertically to better distinguish overlapping points.
</p>
</td></tr>
<tr><td><code id="F_1_panel.densityplot_+3A_ref">ref</code></td>
<td>
<p> logical, whether to draw x-axis </p>
</td></tr>
<tr><td><code id="F_1_panel.densityplot_+3A_groups">groups</code></td>
<td>
<p> an optional grouping variable.  If present,
<code><a href="#topic+panel.superpose">panel.superpose</a></code> will be used instead to display each
subgroup </p>
</td></tr>
<tr><td><code id="F_1_panel.densityplot_+3A_weights">weights</code></td>
<td>
<p> numeric vector of weights for the density
calculations.  If this is specified, the <code>...</code> part must
also include a <code>subscripts</code> argument that matches the weights
to <code>x</code>.  </p>
</td></tr>
<tr><td><code id="F_1_panel.densityplot_+3A_jitter.amount">jitter.amount</code></td>
<td>

<p>when <code>plot.points="jitter"</code>, the value to use as the
<code>amount</code> argument to <code><a href="base.html#topic+jitter">jitter</a></code>.
</p>
</td></tr>
<tr><td><code id="F_1_panel.densityplot_+3A_type">type</code></td>
<td>
<p><code>type</code> argument used to plot points, if requested.
This is not expected to be useful, it is available mostly to protect
a <code>type</code> argument, if specified, from affecting the density
curve.
</p>
</td></tr>
<tr><td><code id="F_1_panel.densityplot_+3A_...">...</code></td>
<td>
<p> extra graphical parameters.  Note that additional
arguments to <code><a href="#topic+panel.rug">panel.rug</a></code> cannot be passed on through
<code>panel.densityplot</code>. </p>
</td></tr>
<tr><td><code id="F_1_panel.densityplot_+3A_grid">grid</code></td>
<td>

<p>A logical flag, character string, or list specifying whether and how
a background grid should be drawn.  In its general form, <code>grid</code>
can be a list of arguments to be supplied to
<code><a href="#topic+panel.grid">panel.grid</a></code>, which is called with those arguments.
Three shortcuts are available:
</p>

<dl>
<dt><code>TRUE</code>:</dt><dd><p> roughly equivalent to <code>list(h = -1, v = -1)</code> </p>
</dd>
<dt><code>"h"</code>:</dt><dd><p> roughly equivalent to <code>list(h = -1, v = 0)</code> </p>
</dd>
<dt><code>"v"</code>:</dt><dd><p> roughly equivalent to <code>list(h = 0, v = -1)</code> </p>
</dd>
</dl>

<p>No grid is drawn if <code>grid = FALSE</code>.
</p>
</td></tr>
<tr><td><code id="F_1_panel.densityplot_+3A_identifier">identifier</code></td>
<td>

<p>A character string that is prepended to the names of grobs
that are created by this panel function.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+densityplot">densityplot</a></code>,
<code><a href="base.html#topic+jitter">jitter</a></code>
</p>

<hr>
<h2 id='F_1_panel.dotplot'> Default Panel Function for dotplot</h2><span id='topic+panel.dotplot'></span>

<h3>Description</h3>

<p>Default panel function for <code>dotplot</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.dotplot(x, y, horizontal = TRUE,
              pch, col, lty, lwd, col.line,
              levels.fos,
              groups = NULL,
              ...,
              grid = lattice.getOption("default.args")$grid,
              identifier = "dotplot")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="F_1_panel.dotplot_+3A_x">x</code>, <code id="F_1_panel.dotplot_+3A_y">y</code></td>
<td>
<p> variables to be plotted in the panel. Typically y is the
&lsquo;factor&rsquo; </p>
</td></tr>
<tr><td><code id="F_1_panel.dotplot_+3A_horizontal">horizontal</code></td>
<td>
<p> logical. If FALSE, the plot is &lsquo;transposed&rsquo;
in the sense that the behaviours of x and y are switched. x is now
the &lsquo;factor&rsquo;.  Interpretation of other arguments change
accordingly. See documentation of <code><a href="#topic+bwplot">bwplot</a></code> for a fuller
explanation.
</p>
</td></tr>
<tr><td><code id="F_1_panel.dotplot_+3A_pch">pch</code>, <code id="F_1_panel.dotplot_+3A_col">col</code>, <code id="F_1_panel.dotplot_+3A_lty">lty</code>, <code id="F_1_panel.dotplot_+3A_lwd">lwd</code>, <code id="F_1_panel.dotplot_+3A_col.line">col.line</code></td>
<td>
<p> graphical parameters</p>
</td></tr>
<tr><td><code id="F_1_panel.dotplot_+3A_levels.fos">levels.fos</code></td>
<td>
<p> locations where reference lines will be drawn </p>
</td></tr>
<tr><td><code id="F_1_panel.dotplot_+3A_groups">groups</code></td>
<td>
<p> grouping variable (affects graphical parameters)</p>
</td></tr>
<tr><td><code id="F_1_panel.dotplot_+3A_...">...</code></td>
<td>

<p>extra parameters, passed to <code>panel.xyplot</code> which is responsible
for drawing the foreground points (<code>panel.dotplot</code> only draws
the background reference lines).
</p>
</td></tr>
<tr><td><code id="F_1_panel.dotplot_+3A_grid">grid</code></td>
<td>

<p>A logical flag, or list specifying whether and how a background grid
should be drawn.  In its general form <code>grid</code> can be a list of
arguments to be supplied to <code><a href="#topic+panel.grid">panel.grid</a></code>, which is
called with those arguments. If <code>FALSE</code>, no grid lines are
drawn. <code>grid = TRUE</code> is roughly equivalent to <code>list(h = 0,
    v = -1)</code> if <code>horizontal = TRUE</code> and <code>list(h = -1, v = 0)</code>
if <code>horizontal = FALSE</code>. In other words, grid lines are drawn
only for the numeric axis, as reference lines for the categorical
axis are drawn regardless of the value of <code>grid</code>.
</p>
</td></tr>
<tr><td><code id="F_1_panel.dotplot_+3A_identifier">identifier</code></td>
<td>

<p>A character string that is prepended to the names of grobs
that are created by this panel function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates (possibly grouped) Dotplot of <code>x</code> against <code>y</code> or
vice versa
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+dotplot">dotplot</a></code></p>

<hr>
<h2 id='F_1_panel.histogram'> Default Panel Function for histogram </h2><span id='topic+panel.histogram'></span>

<h3>Description</h3>

<p>This is the default panel function for <code>histogram</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.histogram(x,
                breaks,
                equal.widths = TRUE,
                type = "density",
                nint = round(log2(length(x)) + 1), 
                alpha, col, border, lty, lwd,
                ...,
                identifier = "histogram")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="F_1_panel.histogram_+3A_x">x</code></td>
<td>
<p> The data points for which the histogram is to be drawn</p>
</td></tr> 
<tr><td><code id="F_1_panel.histogram_+3A_breaks">breaks</code></td>
<td>
<p> The breakpoints for the histogram</p>
</td></tr>
<tr><td><code id="F_1_panel.histogram_+3A_equal.widths">equal.widths</code></td>
<td>
<p> logical used when <code>breaks==NULL</code> </p>
</td></tr>
<tr><td><code id="F_1_panel.histogram_+3A_type">type</code></td>
<td>
<p> Type of histogram, possible values being <code>"percent"</code>,
<code>"density"</code> and <code>"count"</code></p>
</td></tr>
<tr><td><code id="F_1_panel.histogram_+3A_nint">nint</code></td>
<td>
<p> Number of bins for the histogram </p>
</td></tr>
<tr><td><code id="F_1_panel.histogram_+3A_alpha">alpha</code>, <code id="F_1_panel.histogram_+3A_col">col</code>, <code id="F_1_panel.histogram_+3A_border">border</code>, <code id="F_1_panel.histogram_+3A_lty">lty</code>, <code id="F_1_panel.histogram_+3A_lwd">lwd</code></td>
<td>

<p>graphical parameters for bars; defaults are obtained from the
<code>plot.polygon</code> settings.
</p>
</td></tr>
<tr><td><code id="F_1_panel.histogram_+3A_...">...</code></td>
<td>
<p> other arguments, passed to <code><a href="graphics.html#topic+hist">hist</a></code> when
deemed appropriate </p>
</td></tr>
<tr><td><code id="F_1_panel.histogram_+3A_identifier">identifier</code></td>
<td>

<p>A character string that is prepended to the names of grobs
that are created by this panel function.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+histogram">histogram</a></code></p>

<hr>
<h2 id='F_1_panel.levelplot'> Panel Functions for levelplot and contourplot </h2><span id='topic+panel.levelplot'></span><span id='topic+panel.contourplot'></span><span id='topic+panel.levelplot.raster'></span>

<h3>Description</h3>

<p>These are the default panel functions for <code><a href="#topic+levelplot">levelplot</a></code> and
<code>contourplot</code>.  Also documented is an alternative raster-based
panel function for use with <code>levelplot</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.levelplot(x, y, z, 
                subscripts,
                at = pretty(z),
                shrink,
                labels,
                label.style = c("mixed", "flat", "align"),
                contour = FALSE,
                region = TRUE,
                col = add.line$col,
                lty = add.line$lty,
                lwd = add.line$lwd,
                border = "transparent",
                border.lty = 1,
                border.lwd = 0.1,
                ...,
                region.type = c("grid", "contour"),
                col.regions = regions$col,
                alpha.regions = regions$alpha,
                identifier = "levelplot")
panel.contourplot(...)

panel.levelplot.raster(x, y, z, 
                       subscripts,
                       at = pretty(z),
                       ...,
                       col.regions = regions$col,
                       alpha.regions = regions$alpha,
                       interpolate = FALSE,
                       identifier = "levelplot")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="F_1_panel.levelplot_+3A_x">x</code>, <code id="F_1_panel.levelplot_+3A_y">y</code>, <code id="F_1_panel.levelplot_+3A_z">z</code></td>
<td>
<p> Variables defining the plot. </p>
</td></tr>
<tr><td><code id="F_1_panel.levelplot_+3A_subscripts">subscripts</code></td>
<td>

<p>Integer vector indicating what subset of <code>x</code>, <code>y</code> and
<code>z</code> to draw.
</p>
</td></tr>
<tr><td><code id="F_1_panel.levelplot_+3A_at">at</code></td>
<td>

<p>Numeric vector giving breakpoints along the range of
<code>z</code>.  See <code><a href="#topic+levelplot">levelplot</a></code> for details.
</p>
</td></tr>
<tr><td><code id="F_1_panel.levelplot_+3A_shrink">shrink</code></td>
<td>

<p>Either a numeric vector of length 2 (meant to work as both x and y
components), or a list with components x and y which are numeric
vectors of length 2.  This allows the rectangles to be scaled
proportional to the z-value. The specification can be made
separately for widths (x) and heights (y).  The elements of the
length 2 numeric vector gives the minimum and maximum proportion of
shrinkage (corresponding to min and max of z).
</p>
</td></tr>
<tr><td><code id="F_1_panel.levelplot_+3A_labels">labels</code></td>
<td>

<p>Either a logical scalar indicating whether the labels are to be
drawn, or a character or expression vector giving the labels
associated with the <code>at</code> values.  Alternatively, <code>labels</code>
can be a list with the following components:
</p>

<dl>
<dt><code>labels</code>:</dt><dd><p> a character or expression vector giving the
labels.  This can be omitted, in which case the defaults will be
used. </p>
</dd>
<dt><code>col, cex, alpha</code>:</dt><dd><p> graphical parameters for label
texts </p>
</dd>
<dt><code>fontfamily, fontface, font</code>:</dt><dd><p> font used for the
labels </p>
</dd>
</dl>

</td></tr>
<tr><td><code id="F_1_panel.levelplot_+3A_label.style">label.style</code></td>
<td>

<p>Controls how label positions and rotation are determined.  A value
of <code>"flat"</code> causes the label to be positioned where the contour
is flattest, and the label is not rotated.  A value of
<code>"align"</code> causes the label to be drawn as far from the
boundaries as possible, and the label is rotated to align with the
contour at that point.  The default is to mix these approaches,
preferring the flattest location unless it is too close to the
boundaries.
</p>
</td></tr>
<tr><td><code id="F_1_panel.levelplot_+3A_contour">contour</code></td>
<td>

<p>A logical flag, specifying whether contour lines should be drawn.
</p>
</td></tr>
<tr><td><code id="F_1_panel.levelplot_+3A_region">region</code></td>
<td>

<p>A logical flag, specifying whether inter-contour regions should be
filled with appropriately colored rectangles.
</p>
</td></tr>
<tr><td><code id="F_1_panel.levelplot_+3A_col">col</code>, <code id="F_1_panel.levelplot_+3A_lty">lty</code>, <code id="F_1_panel.levelplot_+3A_lwd">lwd</code></td>
<td>
<p> Graphical parameters for contour lines. </p>
</td></tr>
<tr><td><code id="F_1_panel.levelplot_+3A_border">border</code></td>
<td>
<p> Border color for rectangles used when <code>region=TRUE</code>. </p>
</td></tr>
<tr><td><code id="F_1_panel.levelplot_+3A_border.lty">border.lty</code>, <code id="F_1_panel.levelplot_+3A_border.lwd">border.lwd</code></td>
<td>
<p> Graphical parameters for the border</p>
</td></tr>

<tr><td><code id="F_1_panel.levelplot_+3A_...">...</code></td>
<td>
<p> Extra parameters. </p>
</td></tr>
<tr><td><code id="F_1_panel.levelplot_+3A_region.type">region.type</code></td>
<td>

<p>A character string, one of <code>"grid"</code> and <code>"contour"</code>. The
former (the default) uses a grid of rectangles to display the
colors for the level plot; the latter uses a grid of polygons, mimicking
the behavior of <code><a href="graphics.html#topic+filled.contour">filled.contour</a></code>, which gives a smoother
appearance at the cost of increased processing time.
</p>
<p>The <code>"contour"</code> option requires <code>x</code> and <code>y</code> to be
complete, in the sense that it must include all possible
combinations in the underlying grid. However, <code>z</code> values are
allowed to be missing.
</p>
</td></tr>
<tr><td><code id="F_1_panel.levelplot_+3A_col.regions">col.regions</code></td>
<td>

<p>A vector of colors, or a function to produce a vecor of colors, to
be used if <code>region=TRUE</code>.  Each interval defined by <code>at</code>
is assigned a color, so the number of colors actually used is one
less than the length of <code>at</code>.  See <code><a href="#topic+level.colors">level.colors</a></code>
for details on how the color assignment is done.
</p>
</td></tr>
<tr><td><code id="F_1_panel.levelplot_+3A_alpha.regions">alpha.regions</code></td>
<td>

<p>numeric scalar controlling transparency of facets
</p>
</td></tr>
<tr><td><code id="F_1_panel.levelplot_+3A_interpolate">interpolate</code></td>
<td>
<p> logical, passed to <code><a href="grid.html#topic+grid.raster">grid.raster</a></code>. </p>
</td></tr>
<tr><td><code id="F_1_panel.levelplot_+3A_identifier">identifier</code></td>
<td>

<p>A character string that is prepended to the names of grobs
that are created by this panel function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The same panel function is used for both <code>levelplot</code> and
<code>contourplot</code> (which differ only in default values of some
arguments). <code>panel.contourplot</code> is a simple wrapper to
<code>panel.levelplot</code>.
</p>
<p>When <code>contour=TRUE</code>, the <code>contourLines</code> function is used to
calculate the contour lines.
</p>
<p><code>panel.levelplot.raster</code> is an alternative panel function that
uses the raster drawing abilities in R 2.11.0 and higher (through
<code><a href="grid.html#topic+grid.raster">grid.raster</a></code>).  It has fewer options (e.g., can only
render data on an equispaced grid), but can be more efficient.  When
using <code>panel.levelplot.raster</code>, it may be desirable to render the
color key in the same way.  This is possible, but must be done
separately; see <code><a href="#topic+levelplot">levelplot</a></code> for details.
</p>


<h3>Author(s)</h3>

<p>Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a>.
</p>
<p>The functionality of <code>region.type = "contour"</code> is based on code
borrowed from the <span class="pkg">gridGraphics</span> package, written by Zhijian
(Jason) Wen and Paul Murrell and ported to lattice by Johan Larsson.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+levelplot">levelplot</a></code>,
<code><a href="#topic+level.colors">level.colors</a></code>,
<code><a href="grDevices.html#topic+contourLines">contourLines</a></code>,
<code><a href="graphics.html#topic+filled.contour">filled.contour</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(grid)

levelplot(rnorm(10) ~ 1:10 + sort(runif(10)), panel = panel.levelplot)

suppressWarnings(plot(levelplot(rnorm(10) ~ 1:10 + sort(runif(10)),
                                panel = panel.levelplot.raster,
                                interpolate = TRUE)))

levelplot(volcano, panel = panel.levelplot.raster)

levelplot(volcano, panel = panel.levelplot.raster,
          col.regions = hcl.colors, cuts = 30, interpolate = TRUE)

</code></pre>

<hr>
<h2 id='F_1_panel.pairs'> Default Superpanel Function for splom</h2><span id='topic+panel.pairs'></span><span id='topic+diag.panel.splom'></span>

<h3>Description</h3>

<p>This is the default superpanel function for <code>splom</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.pairs(z,
            panel = lattice.getOption("panel.splom"),
            lower.panel = panel,
            upper.panel = panel,
            diag.panel = "diag.panel.splom",
            as.matrix = FALSE,
            groups = NULL,
            panel.subscripts,
            subscripts,
            pscales = 5,
            prepanel.limits = scale_limits,
            varnames = colnames(z),
            varname.col, varname.cex, varname.font,
            varname.fontfamily, varname.fontface,
            axis.text.col, axis.text.cex, axis.text.font,
            axis.text.fontfamily, axis.text.fontface,
            axis.text.lineheight,
            axis.line.col, axis.line.lty, axis.line.lwd,
            axis.line.alpha, axis.line.tck,
            ...)
diag.panel.splom(x = NULL,
                 varname = NULL, limits, at = NULL, labels = NULL,
                 draw = TRUE, tick.number = 5,
                 varname.col, varname.cex,
                 varname.lineheight, varname.font,
                 varname.fontfamily, varname.fontface,
                 axis.text.col, axis.text.alpha,
                 axis.text.cex, axis.text.font, 
                 axis.text.fontfamily, axis.text.fontface,
                 axis.text.lineheight, 
                 axis.line.col, axis.line.alpha,
                 axis.line.lty, axis.line.lwd,
                 axis.line.tck,
                 ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="F_1_panel.pairs_+3A_z">z</code></td>
<td>
<p> The data frame used for the plot.</p>
</td></tr>
<tr><td><code id="F_1_panel.pairs_+3A_panel">panel</code>, <code id="F_1_panel.pairs_+3A_lower.panel">lower.panel</code>, <code id="F_1_panel.pairs_+3A_upper.panel">upper.panel</code></td>
<td>

<p>The panel function used to display each pair of variables. If
specified, <code>lower.panel</code> and <code>upper.panel</code> are used for
panels below and above the diagonal respectively.
</p>
<p>In addition to extra arguments not recognized by <code>panel.pairs</code>,
the list of arguments passed to the panel function also includes
arguments named <code>i</code> and <code>j</code>, with values indicating the
row and column of the scatterplot matrix being plotted.
</p>
</td></tr>
<tr><td><code id="F_1_panel.pairs_+3A_diag.panel">diag.panel</code></td>
<td>

<p>The panel function used for the diagonals. See arguments to
<code>diag.panel.splom</code> to know what arguments this function is
passed when called. Use <code>diag.panel=NULL</code> to suppress plotting
on the diagonal panels.
</p>
</td></tr>
<tr><td><code id="F_1_panel.pairs_+3A_as.matrix">as.matrix</code></td>
<td>

<p>logical. If <code>TRUE</code>, the layout of the panels will have origin
on the top left instead of bottom left (similar to
<code>pairs</code>). This is in essence the same functionality as provided
by <code>as.table</code> for the panel layout
</p>
</td></tr>
<tr><td><code id="F_1_panel.pairs_+3A_groups">groups</code></td>
<td>
<p> Grouping variable, if any </p>
</td></tr>
<tr><td><code id="F_1_panel.pairs_+3A_panel.subscripts">panel.subscripts</code></td>
<td>

<p>logical specifying whether the panel function accepts an argument
named <code>subscripts</code>.
</p>
</td></tr>
<tr><td><code id="F_1_panel.pairs_+3A_subscripts">subscripts</code></td>
<td>
<p> The indices of the rows of <code>z</code> that are to be
displayed in this (super)panel.
</p>
</td></tr>
<tr><td><code id="F_1_panel.pairs_+3A_pscales">pscales</code></td>
<td>
<p> Controls axis labels, passed down from <code>splom</code>.
If <code>pscales</code> is a single number, it indicates the approximate
number of equally-spaced ticks that should appear on each axis.  If
<code>pscales</code> is a list, it should have one component for each
column in <code>z</code>, each of which itself a list with the following
valid components:
</p>
<p><code>at</code>: a numeric vector specifying tick locations
</p>
<p><code>labels</code>: character vector labels to go with at
</p>
<p><code>limits</code>: numeric 2-vector specifying axis limits (should be
made more flexible at some point to handle factors)
</p>
<p>These are specifications on a per-variable basis, and used on all
four sides in the diagonal cells used for labelling.  Factor
variables are labelled with the factor names.  Use <code>pscales=0</code>
to supress the axes entirely.
</p>
</td></tr>
<tr><td><code id="F_1_panel.pairs_+3A_prepanel.limits">prepanel.limits</code></td>
<td>

<p>A function to calculate suitable axis limits given a single argument
<code>x</code> containing a data vector. The return value of the function
should be similar to the <code>xlim</code> or <code>ylim</code> argument
documented in <code><a href="#topic+xyplot">xyplot</a></code>; that is, it should be a numeric
or DateTime vector of length 2 defining a range, or a character
vector representing levels of a factor.
</p>
<p>Most high-level lattice plots (such as <code>xyplot</code>) use the
<code>prepanel</code> function for deciding on axis limits from data.
This function serves a similar function by calculating the
per-variable limits.  These limits can be overridden by the
corresponding <code>limits</code> component in the <code>pscales</code> list.
</p>
</td></tr>
<tr><td><code id="F_1_panel.pairs_+3A_x">x</code></td>
<td>

<p>data vector corresponding to that row / column (which will be the
same for diagonal &lsquo;panels&rsquo;).
</p>
</td></tr>
<tr><td><code id="F_1_panel.pairs_+3A_varname">varname</code></td>
<td>
<p> (scalar) character string or expression that is to be
written centred within the panel
</p>
</td></tr>
<tr><td><code id="F_1_panel.pairs_+3A_limits">limits</code></td>
<td>

<p>numeric of length 2, or, vector of characters, specifying the scale
for that panel (used to calculate tick locations when missing)
</p>
</td></tr>
<tr><td><code id="F_1_panel.pairs_+3A_at">at</code></td>
<td>
<p> locations of tick marks</p>
</td></tr>
<tr><td><code id="F_1_panel.pairs_+3A_labels">labels</code></td>
<td>
<p> optional labels for tick marks</p>
</td></tr>
<tr><td><code id="F_1_panel.pairs_+3A_draw">draw</code></td>
<td>

<p>A logical flag specifying whether to draw the tick marks and labels.
If <code>FALSE</code>, variable names are shown but axis annotation is
omitted. 
</p>
</td></tr>
<tr><td><code id="F_1_panel.pairs_+3A_tick.number">tick.number</code></td>
<td>

<p>A Numeric scalar giving the suggested number of tick marks.
</p>
</td></tr>
<tr><td><code id="F_1_panel.pairs_+3A_varnames">varnames</code></td>
<td>
 
<p>A character or expression vector or giving names to be used for the
variables in <code>x</code>. By default, the column names of <code>x</code>.
</p>
</td></tr>
<tr><td><code id="F_1_panel.pairs_+3A_varname.col">varname.col</code></td>
<td>
<p> Color for the variable name in each diagonal
panel.  See <code><a href="grid.html#topic+gpar">gpar</a></code> for details on this and the
other graphical parameters listed below. </p>
</td></tr>
<tr><td><code id="F_1_panel.pairs_+3A_varname.cex">varname.cex</code></td>
<td>

<p>Size multiplier for the variable name in each diagonal panel.
</p>
</td></tr> 
<tr><td><code id="F_1_panel.pairs_+3A_varname.lineheight">varname.lineheight</code></td>
<td>

<p>Line height for the variable name in each diagonal panel.
</p>
</td></tr>
<tr><td><code id="F_1_panel.pairs_+3A_varname.font">varname.font</code>, <code id="F_1_panel.pairs_+3A_varname.fontfamily">varname.fontfamily</code>, <code id="F_1_panel.pairs_+3A_varname.fontface">varname.fontface</code></td>
<td>

<p>Font specification for the variable name in each diagonal panel.
</p>
</td></tr>
<tr><td><code id="F_1_panel.pairs_+3A_axis.text.col">axis.text.col</code></td>
<td>
<p> Color for axis label text. </p>
</td></tr> 
<tr><td><code id="F_1_panel.pairs_+3A_axis.text.cex">axis.text.cex</code></td>
<td>
<p> Size multiplier for axis label text. </p>
</td></tr> 
<tr><td><code id="F_1_panel.pairs_+3A_axis.text.font">axis.text.font</code>, <code id="F_1_panel.pairs_+3A_axis.text.fontfamily">axis.text.fontfamily</code>, <code id="F_1_panel.pairs_+3A_axis.text.fontface">axis.text.fontface</code></td>
<td>

<p>Font specification for axis label text.
</p>
</td></tr> 
<tr><td><code id="F_1_panel.pairs_+3A_axis.text.lineheight">axis.text.lineheight</code></td>
<td>
<p> Line height for axis label text. </p>
</td></tr> 
<tr><td><code id="F_1_panel.pairs_+3A_axis.text.alpha">axis.text.alpha</code></td>
<td>
<p> Alpha-transparency for axis label text. </p>
</td></tr> 
<tr><td><code id="F_1_panel.pairs_+3A_axis.line.col">axis.line.col</code></td>
<td>
<p> Color for the axes. </p>
</td></tr> 
<tr><td><code id="F_1_panel.pairs_+3A_axis.line.lty">axis.line.lty</code></td>
<td>
<p> Line type for the axes. </p>
</td></tr> 
<tr><td><code id="F_1_panel.pairs_+3A_axis.line.lwd">axis.line.lwd</code></td>
<td>
<p> Line width for the axes. </p>
</td></tr> 
<tr><td><code id="F_1_panel.pairs_+3A_axis.line.alpha">axis.line.alpha</code></td>
<td>
<p> Alpha-transparency for the axes. </p>
</td></tr> 
<tr><td><code id="F_1_panel.pairs_+3A_axis.line.tck">axis.line.tck</code></td>
<td>

<p>A numeric multiplier for the length of tick marks in diagonal
panels.
</p>
</td></tr>
<tr><td><code id="F_1_panel.pairs_+3A_...">...</code></td>
<td>

<p>Further arguments, passed on to <code>panel</code>, <code>lower.panel</code>,
<code>upper.panel</code>, and <code>diag.panel</code> from <code>panel.pairs</code>.
Currently ignored by <code>diag.panel.splom</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>panel.pairs</code> is the function that is actually used as the panel
function in a <code>"trellis"</code> object produced by <code>splom</code>.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+splom">splom</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
Cmat &lt;- outer(1:6,1:6,
              function(i,j) hcl.colors(11)[i+j-1]) ## rainbow(11, start=.12, end=.5)[i+j-1])

splom(~diag(6), as.matrix = TRUE,
      panel = function(x, y, i, j, ...) {
          panel.fill(Cmat[i,j])
          panel.text(.5,.5, paste("(",i,",",j,")",sep=""))
      })

</code></pre>

<hr>
<h2 id='F_1_panel.parallel'> Default Panel Function for parallel </h2><span id='topic+panel.parallel'></span>

<h3>Description</h3>

<p>This is the default panel function for <code>parallel</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.parallel(x, y, z, subscripts,
               groups = NULL,
               col, lwd, lty, alpha,
               common.scale = FALSE,
               lower,
               upper,
               ...,
               horizontal.axis = TRUE,
               identifier = "parallel")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="F_1_panel.parallel_+3A_x">x</code>, <code id="F_1_panel.parallel_+3A_y">y</code></td>
<td>
<p> dummy variables, ignored. </p>
</td></tr>
<tr><td><code id="F_1_panel.parallel_+3A_z">z</code></td>
<td>

<p>The data frame used for the plot.  Each column will be coerced to
numeric before being plotted, and an error will be issued if this
fails.
</p>
</td></tr>
<tr><td><code id="F_1_panel.parallel_+3A_subscripts">subscripts</code></td>
<td>

<p>The indices of the rows of <code>z</code> that are to be displyed in this
panel.
</p>
</td></tr>
<tr><td><code id="F_1_panel.parallel_+3A_groups">groups</code></td>
<td>

<p>An optional grouping variable.  If specified, different groups are
distinguished by use of different graphical parameters (i.e., rows
of <code>z</code> in the same group share parameters).
</p>
</td></tr>
<tr><td><code id="F_1_panel.parallel_+3A_col">col</code>, <code id="F_1_panel.parallel_+3A_lwd">lwd</code>, <code id="F_1_panel.parallel_+3A_lty">lty</code>, <code id="F_1_panel.parallel_+3A_alpha">alpha</code></td>
<td>

<p>graphical parameters (defaults to the settings for
<code>superpose.line</code>).  If <code>groups</code> is non-null, these
parameters used one for each group.  Otherwise, they are recycled
and used to distinguish between rows of the data frame <code>z</code>.
</p>
</td></tr>
<tr><td><code id="F_1_panel.parallel_+3A_common.scale">common.scale</code></td>
<td>

<p>logical, whether a common scale should be used columns of <code>z</code>.
Defaults to <code>FALSE</code>, in which case the horizontal range for
each column is different (as determined by <code>lower</code> and
<code>upper</code>).
</p>
</td></tr>
<tr><td><code id="F_1_panel.parallel_+3A_lower">lower</code>, <code id="F_1_panel.parallel_+3A_upper">upper</code></td>
<td>

<p>numeric vectors replicated to be as long as the number of columns in
<code>z</code>.  Determines the lower and upper bounds to be used for
scaling the corresponding columns of <code>z</code> after coercing them to
numeric.  Defaults to the minimum and maximum of each column.
Alternatively, these could be functions (to be applied on each
column) that return a scalar.
</p>
</td></tr>
<tr><td><code id="F_1_panel.parallel_+3A_...">...</code></td>
<td>
<p> other arguments (ignored) </p>
</td></tr>
<tr><td><code id="F_1_panel.parallel_+3A_horizontal.axis">horizontal.axis</code></td>
<td>
<p>logical indicating whether the parallel axes should
be laid out horizontally (<code>TRUE</code>) or vertically (<code>FALSE</code>).
</p>
</td></tr>
<tr><td><code id="F_1_panel.parallel_+3A_identifier">identifier</code></td>
<td>

<p>A character string that is prepended to the names of grobs
that are created by this panel function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p> Produces parallel coordinate plots, which are easier to
understand from an example than through a verbal description.  See
example for <code><a href="#topic+parallel">parallel</a></code>
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>References</h3>

<p>Inselberg, Alfred (2009) <em>Parallel Coordinates: Visual
Multidimensional Geometry and Its Applications</em>, Springer. ISBN:
978-0-387-21507-5.
</p>
<p>Inselberg, A. (1985) &ldquo;The Plane with Parallel Coordinates&rdquo;,
<em>The Visual Computer</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+parallel">parallel</a></code></p>

<hr>
<h2 id='F_1_panel.qqmath'> Default Panel Function for qqmath </h2><span id='topic+panel.qqmath'></span>

<h3>Description</h3>

<p>This is the default panel function for <code>qqmath</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.qqmath(x, f.value = NULL,
             distribution = qnorm,
             qtype = 7,
             groups = NULL, ...,
             tails.n = 0,
             identifier = "qqmath")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="F_1_panel.qqmath_+3A_x">x</code></td>
<td>

<p>vector (typically numeric, coerced if not) of data values to be used
in the panel.
</p>
</td></tr>
<tr><td><code id="F_1_panel.qqmath_+3A_f.value">f.value</code>, <code id="F_1_panel.qqmath_+3A_distribution">distribution</code></td>
<td>

<p>Defines how quantiles are calculated.  See <code><a href="#topic+qqmath">qqmath</a></code> for
details.
</p>
</td></tr>
<tr><td><code id="F_1_panel.qqmath_+3A_qtype">qtype</code></td>
<td>

<p>The <code>type</code> argument to be used in <code><a href="stats.html#topic+quantile">quantile</a></code>
</p>
</td></tr>
<tr><td><code id="F_1_panel.qqmath_+3A_groups">groups</code></td>
<td>

<p>An optional grouping variable.  Within each panel, one Q-Q plot is
produced for every level of this grouping variable, differentiated
by different graphical parameters.
</p>
</td></tr>
<tr><td><code id="F_1_panel.qqmath_+3A_...">...</code></td>
<td>

<p>Further arguments, often graphical parameters, eventually passed on
to <code><a href="#topic+panel.xyplot">panel.xyplot</a></code>.  Arguments <code>grid</code> and
<code>abline</code> of <code>panel.xyplot</code> may be particularly useful.
</p>
</td></tr>
<tr><td><code id="F_1_panel.qqmath_+3A_tails.n">tails.n</code></td>
<td>

<p>number of data points to represent exactly on each tail of the
distribution. This reproduces the effect of <code>f.value = NULL</code>
for the extreme data values, while approximating the remaining
data. It has no effect if <code>f.value = NULL</code>.
If <code>tails.n</code> is given, <code>qtype</code> is forced to be 1.
</p>
</td></tr>
<tr><td><code id="F_1_panel.qqmath_+3A_identifier">identifier</code></td>
<td>

<p>A character string that is prepended to the names of grobs
that are created by this panel function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a Q-Q plot of the data and the theoretical distribution given
by <code>distribution</code>.  Note that most of the arguments controlling
the display can be supplied directly to the high-level <code>qqmath</code>
call.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+qqmath">qqmath</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0)
xx &lt;- rt(10000, df = 10)
qqmath(~ xx, pch = "+", distribution = qnorm,
       grid = TRUE, abline = c(0, 1),
       xlab.top = c("raw", "ppoints(100)", "tails.n = 50"),
       panel = function(..., f.value) {
           switch(panel.number(),
                  panel.qqmath(..., f.value = NULL),
                  panel.qqmath(..., f.value = ppoints(100)),
                  panel.qqmath(..., f.value = ppoints(100), tails.n = 50))
       }, layout = c(3, 1))[c(1,1,1)]
</code></pre>

<hr>
<h2 id='F_1_panel.stripplot'> Default Panel Function for stripplot </h2><span id='topic+panel.stripplot'></span>

<h3>Description</h3>

<p>This is the default panel function for <code>stripplot</code>. Also see
<code>panel.superpose</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.stripplot(x, y, jitter.data = FALSE,
                factor = 0.5, amount = NULL,
                horizontal = TRUE, groups = NULL,
                ...,
                grid = lattice.getOption("default.args")$grid,
                identifier = "stripplot")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="F_1_panel.stripplot_+3A_x">x</code>, <code id="F_1_panel.stripplot_+3A_y">y</code></td>
<td>
<p> coordinates of points to be plotted</p>
</td></tr>
<tr><td><code id="F_1_panel.stripplot_+3A_jitter.data">jitter.data</code></td>
<td>
<p> whether points should be jittered to avoid
overplotting.  The actual jittering is performed inside
<code><a href="#topic+panel.xyplot">panel.xyplot</a></code>, using its <code>jitter.x</code> or
<code>jitter.y</code> argument (depending on the value of
<code>horizontal</code>).  </p>
</td></tr>
<tr><td><code id="F_1_panel.stripplot_+3A_factor">factor</code>, <code id="F_1_panel.stripplot_+3A_amount">amount</code></td>
<td>
<p>amount of jittering, see <code><a href="base.html#topic+jitter">jitter</a></code></p>
</td></tr>
<tr><td><code id="F_1_panel.stripplot_+3A_horizontal">horizontal</code></td>
<td>
<p> logical. If FALSE, the plot is &lsquo;transposed&rsquo;
in the sense that the behaviours of x and y are switched. x is now
the &lsquo;factor&rsquo;.  Interpretation of other arguments change
accordingly. See documentation of <code><a href="#topic+bwplot">bwplot</a></code> for a fuller
explanation.
</p>
</td></tr>
<tr><td><code id="F_1_panel.stripplot_+3A_groups">groups</code></td>
<td>
<p> optional grouping variable </p>
</td></tr>
<tr><td><code id="F_1_panel.stripplot_+3A_...">...</code></td>
<td>
<p> additional arguments, passed on to
<code><a href="#topic+panel.xyplot">panel.xyplot</a></code> </p>
</td></tr>
<tr><td><code id="F_1_panel.stripplot_+3A_grid">grid</code></td>
<td>

<p>A logical flag, character string, or list specifying whether and how
a background grid should be drawn.  In its general form, <code>grid</code>
can be a list of arguments to be supplied to
<code><a href="#topic+panel.grid">panel.grid</a></code>, which is called with those arguments.
Three shortcuts are available:
</p>

<dl>
<dt><code>TRUE</code>:</dt><dd><p> roughly equivalent to <code>list(h = -1, v = -1)</code> </p>
</dd>
<dt><code>"h"</code>:</dt><dd><p> roughly equivalent to <code>list(h = -1, v = 0)</code> </p>
</dd>
<dt><code>"v"</code>:</dt><dd><p> roughly equivalent to <code>list(h = 0, v = -1)</code> </p>
</dd>
</dl>

<p>No grid is drawn if <code>grid = FALSE</code>.
</p>
</td></tr>
<tr><td><code id="F_1_panel.stripplot_+3A_identifier">identifier</code></td>
<td>

<p>A character string that is prepended to the names of grobs
that are created by this panel function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p> Creates stripplot (one dimensional scatterplot) of <code>x</code>
for each level of <code>y</code> (or vice versa, depending on the value of
<code>horizontal</code>)
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+stripplot">stripplot</a></code>, <code><a href="base.html#topic+jitter">jitter</a></code></p>

<hr>
<h2 id='F_1_panel.xyplot'> Default Panel Function for xyplot </h2><span id='topic+panel.xyplot'></span><span id='topic+panel.splom'></span><span id='topic+panel.qq'></span>

<h3>Description</h3>

<p>This is the default panel function for <code>xyplot</code>. Also see
<code>panel.superpose</code>.  The default panel functions for
<code>splom</code> and <code>qq</code> are essentially the same function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.xyplot(x, y, type = "p",
             groups = NULL,
             pch, col, col.line, col.symbol,
             font, fontfamily, fontface,
             lty, cex, fill, lwd,
             horizontal = FALSE, ...,
             smooth = NULL,
             grid = lattice.getOption("default.args")$grid,
             abline = NULL,
             jitter.x = FALSE, jitter.y = FALSE,
             factor = 0.5, amount = NULL,
             identifier = "xyplot")
panel.splom(..., identifier = "splom")
panel.qq(..., identifier = "qq")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="F_1_panel.xyplot_+3A_x">x</code>, <code id="F_1_panel.xyplot_+3A_y">y</code></td>
<td>
<p> variables to be plotted in the scatterplot </p>
</td></tr>
<tr><td><code id="F_1_panel.xyplot_+3A_type">type</code></td>
<td>
<p> character vector controlling how <code>x</code> and <code>y</code>
are to be plotted. Can consist of one or more of the following:
<code>"p"</code>, <code>"l"</code>, <code>"h"</code>, <code>"b"</code>, <code>"o"</code>,
<code>"s"</code>, <code>"S"</code>, <code>"g"</code>, <code>"r"</code>, <code>"a"</code>, 
<code>"smooth"</code>, and <code>"spline"</code>.  If <code>type</code> has more than
one element, an attempt is made to combine the effect of each of the
components.
</p>
<p>The behaviour if any of the first five are included in <code>type</code>
is similar to the effect of the corresponding <code>type</code> in
<code><a href="graphics.html#topic+plot">plot</a></code>: <code>"p"</code> and <code>"l"</code> stand for points and
lines respectively; <code>"b"</code> and <code>"o"</code> (for &lsquo;overlay&rsquo;)
plot both; <code>"h"</code> draws vertical (or horizontal if
<code>horizontal = TRUE</code>) line segments from the points to the
origin.  Types <code>"s"</code> and <code>"S"</code> are like <code>"l"</code> in the
sense that they join consecutive points, but instead of being joined
by a straight line, points are connected by a vertical and a
horizontal segment forming a &lsquo;step&rsquo;, with the vertical
segment coming first for <code>"s"</code>, and the horizontal segment
coming first for <code>"S"</code>.  Types <code>"s"</code> and <code>"S"</code> sort
the values along one of the axes (depending on <code>horizontal</code>);
this is unlike the behavior in <code>plot</code>. For the latter behavior,
use <code>type = "s"</code> with <code>panel = panel.points</code>.
</p>
<p>Type <code>"g"</code> adds a reference grid using <code><a href="#topic+panel.grid">panel.grid</a></code>
in the background, but using the <code>grid</code> argument is now the
preferred way to do so.
</p>
<p>The remaining values of <code>type</code> lead to various types of
smoothing. This can also be achieved using the <code>smooth</code>
argument, or by calling the relevant panel functions directly. The
panel functions provide finer control over graphical and other
parameters, but using <code>smooth</code> or <code>type</code> is convenient for
simple usage. Using <code>smooth</code> is recommended, but <code>type</code> is
also supported for backwards compatibility.
</p>
<p>Type <code>"r"</code> adds a linear regression line, <code>"smooth"</code> adds
a loess fit, <code>"spline"</code> adds a cubic smoothing spline fit, and
<code>"a"</code> draws line segments joining the average <code>y</code> value
for each distinct <code>x</code> value. See <code>smooth</code> for details.
</p>
<p>See <code>example(xyplot)</code> and <code>demo(lattice)</code> for examples.
</p>
</td></tr>
<tr><td><code id="F_1_panel.xyplot_+3A_groups">groups</code></td>
<td>
<p> an optional grouping variable.  If present,
<code><a href="#topic+panel.superpose">panel.superpose</a></code> will be used instead to display each
subgroup </p>
</td></tr>
<tr><td><code id="F_1_panel.xyplot_+3A_col">col</code>, <code id="F_1_panel.xyplot_+3A_col.line">col.line</code>, <code id="F_1_panel.xyplot_+3A_col.symbol">col.symbol</code></td>
<td>

<p>default colours are obtained from <code>plot.symbol</code> and
<code>plot.line</code> using <code><a href="#topic+trellis.par.get">trellis.par.get</a></code>.
</p>
</td></tr>
<tr><td><code id="F_1_panel.xyplot_+3A_font">font</code>, <code id="F_1_panel.xyplot_+3A_fontface">fontface</code>, <code id="F_1_panel.xyplot_+3A_fontfamily">fontfamily</code></td>
<td>

<p>font used when <code>pch</code> is a character
</p>
</td></tr>
<tr><td><code id="F_1_panel.xyplot_+3A_pch">pch</code>, <code id="F_1_panel.xyplot_+3A_lty">lty</code>, <code id="F_1_panel.xyplot_+3A_cex">cex</code>, <code id="F_1_panel.xyplot_+3A_lwd">lwd</code>, <code id="F_1_panel.xyplot_+3A_fill">fill</code></td>
<td>

<p>other graphical parameters.  <code>fill</code> serves the purpose of
<code>bg</code> in <code><a href="graphics.html#topic+points">points</a></code> for certain values of <code>pch</code>
</p>
</td></tr>
<tr><td><code id="F_1_panel.xyplot_+3A_horizontal">horizontal</code></td>
<td>

<p>A logical flag controlling the orientation for certain
<code>type</code>'s, e.g., <code>"h"</code>, <code>"s"</code>, ans <code>"S"</code> and the
result of smoothing.
</p>
</td></tr>
<tr><td><code id="F_1_panel.xyplot_+3A_...">...</code></td>
<td>

<p>Extra arguments, if any, for <code>panel.xyplot</code>.  Usually passed on
as graphical parameters to low level plotting functions, or to the
panel functions performing smoothing, if applicable.
</p>
</td></tr>
<tr><td><code id="F_1_panel.xyplot_+3A_smooth">smooth</code></td>
<td>
<p> If specificied, indicates the type of smooth to be
added. Can be a character vector containing one or more values from
<code>"lm"</code>, <code>"loess"</code>, <code>"spline"</code>, and
<code>"average"</code>. Can also be a logical flag; <code>TRUE</code> is
interpreted as <code>"loess"</code>. Each of these result in calling a
corresponding panel function as described below; the <code>smooth</code>
argument simply provides a convenient shortcut.
</p>
<p><code>"lm"</code> adds a linear regression line (same as
<code><a href="#topic+panel.lmline">panel.lmline</a></code>, except for default graphical
parameters). <code>"loess"</code> adds a loess fit (same as
<code><a href="#topic+panel.loess">panel.loess</a></code>).  <code>"spline"</code> adds a cubic smoothing
spline fit (same as <code><a href="#topic+panel.spline">panel.spline</a></code>).  <code>"average"</code>
has the effect of calling <code><a href="#topic+panel.average">panel.average</a></code>, which in
conjunction with a <code>groups</code> argument can be useful for creating
interaction plots.
</p>
<p>Normally, smoothing is performed with the <code>y</code> variable as the
response and the <code>x</code> variable as the predictor.  However, the
roles of <code>x</code> and <code>y</code> are reversed if <code>horizontal =
    TRUE</code>.
</p>
</td></tr>
<tr><td><code id="F_1_panel.xyplot_+3A_grid">grid</code></td>
<td>

<p>A logical flag, character string, or list specifying whether and how
a background grid should be drawn.  This provides the same
functionality as <code>type="g"</code>, but is the preferred alternative
as the effect <code>type="g"</code> is conceptually different from that of
other <code>type</code> values (which are all data-dependent).  Using the
<code>grid</code> argument also allows more flexibility.
</p>
<p>Most generally, <code>grid</code> can be a list of arguments to be
supplied to <code><a href="#topic+panel.grid">panel.grid</a></code>, which is called with those
arguments.  Three shortcuts are available:
</p>

<dl>
<dt><code>TRUE</code>:</dt><dd><p> roughly equivalent to <code>list(h = -1, v = -1)</code> </p>
</dd>
<dt><code>"h"</code>:</dt><dd><p> roughly equivalent to <code>list(h = -1, v = 0)</code> </p>
</dd>
<dt><code>"v"</code>:</dt><dd><p> roughly equivalent to <code>list(h = 0, v = -1)</code> </p>
</dd>
</dl>

<p>No grid is drawn if <code>grid = FALSE</code>.
</p>
</td></tr>
<tr><td><code id="F_1_panel.xyplot_+3A_abline">abline</code></td>
<td>

<p>A numeric vector or more generally a list containing arguments that
are used to call <code><a href="#topic+panel.abline">panel.abline</a></code>. If specified as a
numeric vector, <code>abline</code> is used as the first unnamed argument
to <code><a href="#topic+panel.abline">panel.abline</a></code>.  This allows arguments of the form
<code>abline = c(0, 1)</code>, which adds the diagonal line, or
<code>abline = coef(fm)</code> to fit the regression line from a fitted
mode. Use the list form for finer control; e.g., <code>abline =
    list(h = 0, v = 0, col = "grey")</code>.
</p>
<p>For more flexibility, use <code><a href="#topic+panel.abline">panel.abline</a></code> directly.
</p>
</td></tr>
<tr><td><code id="F_1_panel.xyplot_+3A_jitter.x">jitter.x</code>, <code id="F_1_panel.xyplot_+3A_jitter.y">jitter.y</code></td>
<td>
<p> logical, whether the data should be
jittered before being plotted. </p>
</td></tr>
<tr><td><code id="F_1_panel.xyplot_+3A_factor">factor</code>, <code id="F_1_panel.xyplot_+3A_amount">amount</code></td>
<td>
<p> controls amount of jittering. </p>
</td></tr>
<tr><td><code id="F_1_panel.xyplot_+3A_identifier">identifier</code></td>
<td>

<p>A character string that is prepended to the names of grobs
that are created by this panel function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates scatterplot of <code>x</code> and <code>y</code>, with various
modifications possible via the type argument. <code>panel.qq</code> draws a
45 degree line before calling <code>panel.xyplot</code>.
</p>
<p>Note that most of the arguments controlling the display can be
supplied directly to the high-level (e.g. <code><a href="#topic+xyplot">xyplot</a></code>) call.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+panel.superpose">panel.superpose</a></code>,
<code><a href="#topic+xyplot">xyplot</a></code>,
<code><a href="#topic+splom">splom</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
types.plain &lt;- c("p", "l", "o", "r", "g", "s", "S", "h", "a", "smooth")
types.horiz &lt;- c("s", "S", "h", "a", "smooth")
horiz &lt;- rep(c(FALSE, TRUE), c(length(types.plain), length(types.horiz)))

types &lt;- c(types.plain, types.horiz)

x &lt;- sample(seq(-10, 10, length.out = 15), 30, TRUE)
y &lt;- x + 0.25 * (x + 1)^2 + rnorm(length(x), sd = 5)

xyplot(y ~ x | gl(1, length(types)),
       xlab = "type", 
       ylab = list(c("horizontal=TRUE", "horizontal=FALSE"), y = c(1/6, 4/6)),
       as.table = TRUE, layout = c(5, 3),
       between = list(y = c(0, 1)),
       strip = function(...) {
           panel.fill(trellis.par.get("strip.background")$col[1])
           type &lt;- types[panel.number()]
           grid::grid.text(label = sprintf('"%s"', type), 
                           x = 0.5, y = 0.5)
           grid::grid.rect()
       },
       scales = list(alternating = c(0, 2), tck = c(0, 0.7), draw = FALSE),
       par.settings = 
       list(layout.widths = list(strip.left = c(1, 0, 0, 0, 0))),
       panel = function(...) {
           type &lt;- types[panel.number()]
           horizontal &lt;- horiz[panel.number()]
           panel.xyplot(..., 
                        type = type,
                        horizontal = horizontal)
       })[rep(1, length(types))]

</code></pre>

<hr>
<h2 id='F_2_llines'>Replacements of traditional graphics functions</h2><span id='topic+larrows'></span><span id='topic+llines'></span><span id='topic+lpoints'></span><span id='topic+lpolygon'></span><span id='topic+lpolypath'></span><span id='topic+lrect'></span><span id='topic+lsegments'></span><span id='topic+ltext'></span><span id='topic+larrows.default'></span><span id='topic+llines.default'></span><span id='topic+lpoints.default'></span><span id='topic+lpolygon.default'></span><span id='topic+lpolypath.default'></span><span id='topic+lrect.default'></span><span id='topic+lsegments.default'></span><span id='topic+ltext.default'></span><span id='topic+lplot.xy'></span><span id='topic+panel.arrows'></span><span id='topic+panel.lines'></span><span id='topic+panel.points'></span><span id='topic+panel.polygon'></span><span id='topic+panel.polypath'></span><span id='topic+panel.rect'></span><span id='topic+panel.segments'></span><span id='topic+panel.text'></span>

<h3>Description</h3>

<p>These functions are intended to replace common low level traditional
graphics functions, primarily for use in panel functions.  The
originals can not be used (at least not easily) because lattice panel
functions need to use grid graphics.  Low level drawing functions in
grid can be used directly as well, and is often more flexible.  These
functions are provided for convenience and portability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lplot.xy(xy, type, pch, lty, col, cex, lwd,
         font, fontfamily, fontface,
         col.line, col.symbol, alpha, fill,
         origin = 0, ..., identifier, name.type)

larrows(...)
llines(x, ...)
lpoints(x, ...)
lpolygon(x, ...)
lpolypath(x, ...)
lrect(...)
lsegments(...)
ltext(x, ...)

## Default S3 method:
larrows(x0 = NULL, y0 = NULL, x1, y1, x2 = NULL, y2 = NULL,
        angle = 30, code = 2, length = 0.25, unit = "inches",
        ends = switch(code, "first", "last", "both"),
        type = "open",
        col = add.line$col,
        alpha = add.line$alpha,
        lty = add.line$lty,
        lwd = add.line$lwd,
        fill = NULL, 
        font, fontface,
        ..., identifier, name.type)
## Default S3 method:
llines(x, y = NULL, type = "l",
        col, alpha, lty, lwd, ..., identifier, name.type)
## Default S3 method:
lpoints(x, y = NULL, type = "p", col, pch, alpha, fill,
        font, fontfamily, fontface, cex, ..., identifier, name.type) 
## Default S3 method:
lpolygon(x, y = NULL,
        border = "black", col = "transparent", fill = NULL, 
        font, fontface,
        ...,
        rule = c("none", "winding", "evenodd"),
        identifier, name.type)        
## Default S3 method:
lpolypath(x, y = NULL,
         border = "black", col = "transparent", fill = NULL, 
         font, fontface,
         ...,
         rule = c("winding", "evenodd"),
         identifier, name.type)        
## Default S3 method:
ltext(x, y = NULL, labels = seq_along(x),
        col, alpha, cex, srt = 0,
        lineheight, font, fontfamily, fontface,
        adj = c(0.5, 0.5), pos = NULL, offset = 0.5, ..., identifier, name.type)  
## Default S3 method:
lrect(xleft, ybottom, xright, ytop,
        x = (xleft + xright) / 2,
        y = (ybottom + ytop) / 2,
        width = xright - xleft,
        height = ytop - ybottom,
        col = "transparent",
        border = "black",
        lty = 1, lwd = 1, alpha = 1,
        just = "center",
        hjust = NULL, vjust = NULL,
        font, fontface,
        ..., identifier, name.type)
## Default S3 method:
lsegments(x0, y0, x1, y1, x2, y2,
        col, alpha, lty, lwd,
        font, fontface, ..., identifier, name.type)

panel.arrows(...)
panel.lines(...)
panel.points(...)
panel.polygon(...)
panel.rect(...)
panel.segments(...)
panel.text(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="F_2_llines_+3A_x">x</code>, <code id="F_2_llines_+3A_y">y</code>, <code id="F_2_llines_+3A_x0">x0</code>, <code id="F_2_llines_+3A_y0">y0</code>, <code id="F_2_llines_+3A_x1">x1</code>, <code id="F_2_llines_+3A_y1">y1</code>, <code id="F_2_llines_+3A_x2">x2</code>, <code id="F_2_llines_+3A_y2">y2</code>, <code id="F_2_llines_+3A_xy">xy</code></td>
<td>
<p> locations. <code>x2</code> and
<code>y2</code> are available for for S compatibility.  </p>
</td></tr>
<tr><td><code id="F_2_llines_+3A_length">length</code>, <code id="F_2_llines_+3A_unit">unit</code></td>
<td>

<p>determines extent of arrow head.  <code>length</code> specifies the length
in terms of <code>unit</code>, which can be any valid grid unit as long as
it doesn't need a <code>data</code> argument.  <code>unit</code> defaults to
inches, which is the only option in the base version of the
function, <code><a href="graphics.html#topic+arrows">arrows</a></code>.  </p>
</td></tr>
<tr><td><code id="F_2_llines_+3A_angle">angle</code>, <code id="F_2_llines_+3A_code">code</code>, <code id="F_2_llines_+3A_type">type</code>, <code id="F_2_llines_+3A_labels">labels</code>, <code id="F_2_llines_+3A_srt">srt</code>, <code id="F_2_llines_+3A_adj">adj</code>, <code id="F_2_llines_+3A_pos">pos</code>, <code id="F_2_llines_+3A_offset">offset</code></td>
<td>
<p> arguments
controlling behaviour.  See respective base functions for details.
For <code>larrows</code> and <code>panel.larrows</code>, <code>type</code> is either
<code>"open"</code> or <code>"closed"</code>, indicating the type of
arrowhead. </p>
</td></tr>
<tr><td><code id="F_2_llines_+3A_ends">ends</code></td>
<td>
<p> serves the same function as <code>code</code>, using
descriptive names rather than integer codes.  If specified, this
overrides <code>code</code></p>
</td></tr>
<tr><td><code id="F_2_llines_+3A_col">col</code>, <code id="F_2_llines_+3A_alpha">alpha</code>, <code id="F_2_llines_+3A_lty">lty</code>, <code id="F_2_llines_+3A_lwd">lwd</code>, <code id="F_2_llines_+3A_fill">fill</code>, <code id="F_2_llines_+3A_pch">pch</code>, <code id="F_2_llines_+3A_cex">cex</code>, <code id="F_2_llines_+3A_lineheight">lineheight</code>, <code id="F_2_llines_+3A_font">font</code>, <code id="F_2_llines_+3A_fontfamily">fontfamily</code>, <code id="F_2_llines_+3A_fontface">fontface</code>, <code id="F_2_llines_+3A_col.line">col.line</code>, <code id="F_2_llines_+3A_col.symbol">col.symbol</code>, <code id="F_2_llines_+3A_border">border</code></td>
<td>
<p> graphical
parameters.  <code>fill</code> applies to points when <code>pch</code> is in
<code>21:25</code> and specifies the fill color, similar to the <code>bg</code>
argument in the base graphics function <code><a href="graphics.html#topic+points">points</a></code>. For
devices that support alpha-transparency, a numeric argument
<code>alpha</code> between 0 and 1 can controls transparency.  Be careful
with this, since for devices that do not support alpha-transparency,
nothing will be drawn at all if this is set to anything other than
0.
</p>
<p><code>fill</code>, <code>font</code> and <code>fontface</code> are included in
<code>lrect</code>, <code>larrows</code>, <code>lpolygon</code>, and <code>lsegments</code>
only to ensure that they are not passed down (as <code><a href="grid.html#topic+gpar">gpar</a></code>
does not like them).
</p>
</td></tr>
<tr><td><code id="F_2_llines_+3A_origin">origin</code></td>
<td>
<p> for <code>type="h"</code> or <code>type="H"</code>, the value to
which lines drop down. </p>
</td></tr>
<tr><td><code id="F_2_llines_+3A_xleft">xleft</code>, <code id="F_2_llines_+3A_ybottom">ybottom</code>, <code id="F_2_llines_+3A_xright">xright</code>, <code id="F_2_llines_+3A_ytop">ytop</code></td>
<td>
<p> see <code><a href="graphics.html#topic+rect">rect</a></code></p>
</td></tr>
<tr><td><code id="F_2_llines_+3A_width">width</code>, <code id="F_2_llines_+3A_height">height</code>, <code id="F_2_llines_+3A_just">just</code>, <code id="F_2_llines_+3A_hjust">hjust</code>, <code id="F_2_llines_+3A_vjust">vjust</code></td>
<td>
<p> finer control over
rectangles, see <code><a href="grid.html#topic+grid.rect">grid.rect</a></code> </p>
</td></tr>
<tr><td><code id="F_2_llines_+3A_...">...</code></td>
<td>
<p> extra arguments, passed on to lower level functions as
appropriate.  </p>
</td></tr>
<tr><td><code id="F_2_llines_+3A_rule">rule</code></td>
<td>
<p> character string specifying how <code>NA</code> values are
interpreted for polygons and paths. This is mainly intended for
paths (via <code><a href="grid.html#topic+grid.path">grid.path</a></code>), but can also be specified for
polygons for convenience.
</p>
<p>For polygons, the default rule is <code>"none"</code>, which treats
<code>NA</code>-separated segments as separate polygons. This value is
only valid for polygons. For the other rules (<code>"winding"</code> or
<code>"evenodd"</code>) these segments are interpreted as subpaths,
possibly representing holes, of a single path, and are rendered
using <code><a href="grid.html#topic+grid.path">grid.path</a></code>. Support and rendering speed may
depend on the device being used.
</p>
</td></tr>
<tr><td><code id="F_2_llines_+3A_identifier">identifier</code></td>
<td>

<p>A character string that is prepended to the name of the grob
that is created.
</p>
</td></tr>
<tr><td><code id="F_2_llines_+3A_name.type">name.type</code></td>
<td>

<p>A character value indicating whether the name of the grob
should have panel or strip information added to it.
Typically either <code>"panel"</code>, <code>"strip"</code>,
<code>"strip.left"</code>, or <code>""</code> (for no extra information).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are meant to be grid replacements of the corresponding
base R graphics functions, to allow existing Trellis code to be used
with minimal modification.  The functions <code>panel.*</code> are
essentally identical to the <code>l*</code> versions, are recommended for
use in new code (as opposed to ported code) as they have more readable
names.
</p>
<p>See the documentation of the base functions for usage. Not all
arguments are always supported. All these correspond to the default
methods only.


</p>


<h3>Note</h3>

<p>There is a new <code>type="H"</code> option wherever appropriate, which is
similar to <code>type="h"</code>, but with horizontal lines.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+points">points</a></code>, <code><a href="graphics.html#topic+lines">lines</a></code>, <code><a href="graphics.html#topic+rect">rect</a></code>,
<code><a href="graphics.html#topic+text">text</a></code>, <code><a href="graphics.html#topic+segments">segments</a></code>, <code><a href="graphics.html#topic+arrows">arrows</a></code>,
<code><a href="#topic+Lattice">Lattice</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
SD &lt;- 0.1
t &lt;- seq(0, 2*pi, length.out = 50) + rnorm(50, sd = SD)
d &lt;- list(x = c(cos(t), NA, rev(0.5 * cos(t))) + rnorm(101, sd = SD),
          y = c(sin(t), NA, rev(0.5 * sin(t))) + rnorm(101, sd = SD))


## rectangles
xyplot(y ~ x, d, panel = panel.rect, col = 4, alpha = 0.5, width = 0.1, height = 0.1)

## points and lines
xyplot(y ~ x, d, panel = panel.lines, col = 4, alpha = 0.5,
       type = "o", pch = 16)

## polygons and paths (with holes)
xyplot(y ~ x, d, panel = panel.polygon, col = 4, alpha = 0.5, rule = "evenodd")

## Example adapted from https://journal.r-project.org/articles/RJ-2012-017/
x &lt;- c(.1, .5, .9, NA, .4, .5, .6, NA, .4, .6, .5)
y &lt;- c(.1, .8, .1, NA, .5, .4, .5, NA, .3, .3, .2)
d &lt;- data.frame(x = x, y = y)
xyplot(y ~ x, data = d, panel = panel.polygon,  rule = "none", col = "grey")
xyplot(y ~ x, data = d, panel = panel.polypath, rule = "winding", col = "grey")
xyplot(y ~ x, data = d, panel = panel.polypath, rule = "evenodd", col = "grey")

</code></pre>

<hr>
<h2 id='F_2_panel.functions'>Useful Panel Function Components</h2><span id='topic+panel.functions'></span><span id='topic+panel.abline'></span><span id='topic+panel.refline'></span><span id='topic+panel.curve'></span><span id='topic+panel.fill'></span><span id='topic+panel.grid'></span><span id='topic+panel.mathdensity'></span><span id='topic+panel.rug'></span><span id='topic+panel.lmline'></span><span id='topic+panel.average'></span><span id='topic+panel.linejoin'></span>

<h3>Description</h3>

<p>These are predefined panel functions available in lattice for use in
constructing new panel functions (often on-the-fly).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
panel.abline(a = NULL, b = 0,
             h = NULL, v = NULL,
             reg = NULL, coef = NULL,
             col, col.line, lty, lwd, alpha, type,
             ...,
             reference = FALSE,
             identifier = "abline")
panel.refline(...) 

panel.curve(expr, from, to, n = 101,
            curve.type = "l",
            col, lty, lwd, type,
            ...,
            identifier = "curve")
panel.rug(x = NULL, y = NULL,
          regular = TRUE, 
          start = if (regular) 0 else 0.97,
          end = if (regular) 0.03 else 1,
          x.units = rep("npc", 2),
          y.units = rep("npc", 2),
          col, col.line, lty, lwd, alpha,
          ...,
          identifier = "rug")
panel.average(x, y, fun = mean, horizontal = TRUE,
              lwd, lty, col, col.line, type,
              ...,
              identifier = "linejoin")
panel.linejoin(x, y, fun = mean, horizontal = TRUE,
               lwd, lty, col, col.line, type,
               ...,
               identifier = "linejoin")





panel.fill(col, border, ..., identifier = "fill")
panel.grid(h=3, v=3, col, col.line, lty, lwd, x, y, ..., identifier = "grid")
panel.lmline(x, y, ..., identifier = "lmline")
panel.mathdensity(dmath = dnorm, args = list(mean=0, sd=1),
                  n = 50, col, col.line, lwd, lty, type,
                  ..., identifier = "mathdensity")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="F_2_panel.functions_+3A_x">x</code>, <code id="F_2_panel.functions_+3A_y">y</code></td>
<td>
<p> Variables defining the contents of the panel.
In <code>panel.grid</code> these are optional and are used only to choose
an appropriate method of <code><a href="base.html#topic+pretty">pretty</a></code>.
</p>
</td></tr>
<tr><td><code id="F_2_panel.functions_+3A_a">a</code>, <code id="F_2_panel.functions_+3A_b">b</code></td>
<td>
<p> Coefficients of the line to be added by
<code>panel.abline</code>.  <code>a</code> can be a vector of length 2,
representing the coefficients of the line to be added, in which case
<code>b</code> should be missing.  <code>a</code> can also be an appropriate
&lsquo;regression&rsquo; object, i.e., an object which has a
<code><a href="stats.html#topic+coef">coef</a></code> method that returns a length 2 numeric vector.
The corresponding line will be plotted.  The <code>reg</code> argument
overrides <code>a</code> if specified.
</p>
</td></tr>
<tr><td><code id="F_2_panel.functions_+3A_coef">coef</code></td>
<td>
<p> Coefficients of the line to be added as a vector of
length 2.
</p>
</td></tr>
<tr><td><code id="F_2_panel.functions_+3A_reg">reg</code></td>
<td>
<p> A (linear) regression object, with a <code><a href="stats.html#topic+coef">coef</a></code>
method that gives the coefficints of the corresponding regression
line. </p>
</td></tr>
<tr><td><code id="F_2_panel.functions_+3A_h">h</code>, <code id="F_2_panel.functions_+3A_v">v</code></td>
<td>
<p> For <code>panel.abline</code>, these are numeric vectors giving
locations respectively of horizontal and vertical lines to be added
to the plot, in native coordinates.
</p>
<p>For <code>panel.grid</code>, these usually specify the number of
horizontal and vertical reference lines to be added to the plot.
Alternatively, they can be negative numbers.  <code>h=-1</code> and
<code>v=-1</code> are intended to make the grids aligned with the axis
labels.  This doesn't always work; all that actually happens is that
the locations are chosen using <code>pretty</code>, which is also how the
label positions are chosen in the most common cases (but not for
factor variables, for instance).  <code>h</code> and <code>v</code> can be
negative numbers other than <code>-1</code>, in which case <code>-h</code> and
<code>-v</code> (as appropriate) is supplied as the <code>n</code> argument to
<code><a href="base.html#topic+pretty">pretty</a></code>.
</p>
<p>If <code>x</code> and/or <code>y</code> are specified in <code>panel.grid</code>, they
will be used to select an appropriate method for
<code><a href="base.html#topic+pretty">pretty</a></code>.  This is particularly useful while plotting
date-time objects.
</p>
</td></tr>
<tr><td><code id="F_2_panel.functions_+3A_reference">reference</code></td>
<td>
<p> A logical flag determining whether the default
graphical parameters for <code>panel.abline</code> should be taken from
the &ldquo;reference.line&rdquo; parameter settings.  The default is to
take them from the &ldquo;add.line&rdquo; settings.  The
<code>panel.refline</code> function is a wrapper around
<code>panel.abline</code> that calls it with <code>reference = TRUE</code>.
</p>
</td></tr>
<tr><td><code id="F_2_panel.functions_+3A_expr">expr</code></td>
<td>
<p> An expression considered as a function of <code>x</code>, or a
function, to be plotted as a curve.   </p>
</td></tr>
<tr><td><code id="F_2_panel.functions_+3A_n">n</code></td>
<td>
<p> The number of points to use for drawing the curve. </p>
</td></tr>
<tr><td><code id="F_2_panel.functions_+3A_from">from</code>, <code id="F_2_panel.functions_+3A_to">to</code></td>
<td>
<p> optional lower and upper x-limits of curve. If
missing, limits of current panel are used
</p>
</td></tr>
<tr><td><code id="F_2_panel.functions_+3A_curve.type">curve.type</code></td>
<td>
<p> Type of curve (<code>"p"</code> for points, etc), passed
to <code><a href="#topic+llines">llines</a></code>
</p>
</td></tr>
<tr><td><code id="F_2_panel.functions_+3A_regular">regular</code></td>
<td>
<p> A logical flag indicating whether the &lsquo;rug&rsquo; is
to be drawn on the &lsquo;regular&rsquo; side (left / bottom) or not
(right / top).  </p>
</td></tr>
<tr><td><code id="F_2_panel.functions_+3A_start">start</code>, <code id="F_2_panel.functions_+3A_end">end</code></td>
<td>
<p> endpoints of rug segments, in normalized parent
coordinates (between 0 and 1).  Defaults depend on value of
<code>regular</code>, and cover 3% of the panel width and height. </p>
</td></tr>
<tr><td><code id="F_2_panel.functions_+3A_x.units">x.units</code>, <code id="F_2_panel.functions_+3A_y.units">y.units</code></td>
<td>

<p>Character vectors, replicated to be of length two.  Specifies the
(grid) units associated with <code>start</code> and <code>end</code> above.
<code>x.units</code> and <code>y.units</code> are for the rug on the x-axis and
y-axis respectively (and thus are associated with <code>start</code> and
<code>end</code> values on the y and x scales respectively).
</p>
</td></tr>
<tr><td><code id="F_2_panel.functions_+3A_col">col</code>, <code id="F_2_panel.functions_+3A_col.line">col.line</code>, <code id="F_2_panel.functions_+3A_lty">lty</code>, <code id="F_2_panel.functions_+3A_lwd">lwd</code>, <code id="F_2_panel.functions_+3A_alpha">alpha</code>, <code id="F_2_panel.functions_+3A_border">border</code></td>
<td>
<p> Graphical parameters. </p>
</td></tr>
<tr><td><code id="F_2_panel.functions_+3A_type">type</code></td>
<td>
<p> Usually ignored by the panel functions documented here;
the argument is present only to make sure an explicitly specified
<code>type</code> argument (perhaps meant for another function) does not
affect the display.
</p>
</td></tr>
<tr><td><code id="F_2_panel.functions_+3A_fun">fun</code></td>
<td>
<p> The function that will be applied to the subset of
<code>x</code> values (or <code>y</code> if <code>horizontal</code> is <code>FALSE</code>)
determined by the unique values of <code>y</code> (<code>x</code>). </p>
</td></tr>
<tr><td><code id="F_2_panel.functions_+3A_horizontal">horizontal</code></td>
<td>
<p> A logical flag. If <code>FALSE</code>, the plot is
&lsquo;transposed&rsquo; in the sense that the roles of <code>x</code> and
<code>y</code> are switched; <code>x</code> is now the &lsquo;factor&rsquo;.
Interpretation of other arguments change accordingly. See
documentation of <code><a href="#topic+bwplot">bwplot</a></code> for a fuller explanation.
</p>
</td></tr>
<tr><td><code id="F_2_panel.functions_+3A_dmath">dmath</code></td>
<td>
<p> A vectorized function that produces density values given
a numeric vector named <code>x</code>, e.g., <code><a href="stats.html#topic+dnorm">dnorm</a></code>.
</p>
</td></tr>
<tr><td><code id="F_2_panel.functions_+3A_args">args</code></td>
<td>
<p> A list giving additional arguments to be passed to
<code>dmath</code>.
</p>
</td></tr>
<tr><td><code id="F_2_panel.functions_+3A_...">...</code></td>
<td>
<p> Further arguments, typically graphical parameters,
passed on to other low-level functions as appropriate.  Color can
usually be specified by <code>col</code>, <code>col.line</code>, and
<code>col.symbol</code>, the last two overriding the first for lines and
points respectively.
</p>
</td></tr>
<tr><td><code id="F_2_panel.functions_+3A_identifier">identifier</code></td>
<td>

<p>A character string that is prepended to the names of grobs
that are created by this panel function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>panel.abline</code> adds a line of the form <code>y = a + b * x</code>, or
vertical and/or horizontal lines.  Graphical parameters are obtained
from the &ldquo;add.line&rdquo; settings by default.  <code>panel.refline</code>
is similar, but uses the &ldquo;reference.line&rdquo; settings for the
defaults.
</p>
<p><code>panel.grid</code> draws a reference grid.
</p>
<p><code>panel.curve</code> adds a curve, similar to what <code><a href="graphics.html#topic+curve">curve</a></code>
does with <code>add = TRUE</code>.  Graphical parameters for the curve are
obtained from the &ldquo;add.line&rdquo; setting.
</p>
<p><code>panel.average</code> treats one of <code>x</code> and <code>y</code> as a factor
(according to the value of <code>horizontal</code>), calculates <code>fun</code>
applied to the subsets of the other variable determined by each unique
value of the factor, and joins them by a line.  Can be used in
conjunction with <code>panel.xyplot</code>, and more commonly with
<code><a href="#topic+panel.superpose">panel.superpose</a></code> to produce interaction plots.
</p>
<p><code>panel.linejoin</code> is an alias for <code>panel.average</code>.  It is
retained for back-compatibility, and may go away in future.
</p>
<p><code>panel.mathdensity</code> plots a (usually theoretical) probability
density function.  This can be useful in conjunction with
<code>histogram</code> and <code>densityplot</code> to visually assess goodness of
fit (note, however, that <code>qqmath</code> is more suitable for this).
</p>
<p><code>panel.rug</code> adds a <em>rug</em> representation of the (marginal)
data to the panel, much like <code><a href="graphics.html#topic+rug">rug</a></code>.
</p>
<p><code>panel.lmline(x, y)</code> is equivalent to
<code>panel.abline(lm(y ~ x))</code>.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>See Also</h3>

<p><a href="#topic+Lattice">Lattice</a>, <code><a href="#topic+panel.axis">panel.axis</a></code>, <code><a href="#topic+panel.identify">panel.identify</a></code>
<code><a href="graphics.html#topic+identify">identify</a></code>, <code><a href="#topic+trellis.par.set">trellis.par.set</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Interaction Plot

bwplot(yield ~ site, barley, groups = year,
       panel = function(x, y, groups, subscripts, ...) {
           panel.grid(h = -1, v = 0)
           panel.stripplot(x, y, ..., jitter.data = TRUE, grid = FALSE,
                           groups = groups, subscripts = subscripts)
           panel.superpose(x, y, ..., panel.groups = panel.average, grid = FALSE,
                           groups = groups, subscripts = subscripts)
       },
       auto.key = list(points = FALSE, lines = TRUE, columns = 2))

## Superposing a fitted normal density on a Histogram

histogram( ~ height | voice.part, data = singer, layout = c(2, 4),
          type = "density", border = "transparent", col.line = "grey60",
          xlab = "Height (inches)",
          ylab = "Density Histogram\n with Normal Fit",
          panel = function(x, ...) {
              panel.histogram(x, ...)
              panel.mathdensity(dmath = dnorm,
                                args = list(mean = mean(x), sd = sd(x)), ...)
          } )


</code></pre>

<hr>
<h2 id='F_2_panel.loess'>Panel Function to Add a LOESS Smooth</h2><span id='topic+panel.loess'></span>

<h3>Description</h3>

<p>A predefined panel function that can be used to add a LOESS smooth
based on the provided data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
panel.loess(x, y, span = 2/3, degree = 1,
            family = c("symmetric", "gaussian"),
            evaluation = 50,
            lwd, lty, col, col.line, type,
            horizontal = FALSE,
            ..., identifier = "loess")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="F_2_panel.loess_+3A_x">x</code>, <code id="F_2_panel.loess_+3A_y">y</code></td>
<td>
<p> Variables defining the data to be used. </p>
</td></tr>
<tr><td><code id="F_2_panel.loess_+3A_lwd">lwd</code>, <code id="F_2_panel.loess_+3A_lty">lty</code>, <code id="F_2_panel.loess_+3A_col">col</code>, <code id="F_2_panel.loess_+3A_col.line">col.line</code></td>
<td>
<p> Graphical parameters for the added
line.  <code>col.line</code> overrides <code>col</code>. </p>
</td></tr>
<tr><td><code id="F_2_panel.loess_+3A_type">type</code></td>
<td>
<p> Ignored.  The argument is present only to make sure that
an explicitly specified <code>type</code> argument (perhaps meant for
another function) does not affect the display.  </p>
</td></tr>
<tr><td><code id="F_2_panel.loess_+3A_span">span</code>, <code id="F_2_panel.loess_+3A_degree">degree</code>, <code id="F_2_panel.loess_+3A_family">family</code>, <code id="F_2_panel.loess_+3A_evaluation">evaluation</code></td>
<td>
<p> Arguments to
<code><a href="stats.html#topic+loess.smooth">loess.smooth</a></code>, for which <code>panel.loess</code> is
essentially a wrapper.
</p>
</td></tr>
<tr><td><code id="F_2_panel.loess_+3A_horizontal">horizontal</code></td>
<td>

<p>A logical flag controlling which variable is to be treated as the
predictor (by default <code>x</code>) and which as the response (by
default <code>y</code>).  If <code>TRUE</code>, the plot is &lsquo;transposed&rsquo;
in the sense that <code>y</code> becomes the predictor and <code>x</code> the
response.  (The name &lsquo;horizontal&rsquo; may seem an odd choice for
this argument, and originates from similar usage in
<code><a href="#topic+bwplot">bwplot</a></code>).
</p>
</td></tr>
<tr><td><code id="F_2_panel.loess_+3A_...">...</code></td>
<td>
<p> Extra arguments, passed on to
<code><a href="#topic+panel.lines">panel.lines</a></code>.
</p>
</td></tr>
<tr><td><code id="F_2_panel.loess_+3A_identifier">identifier</code></td>
<td>

<p>A character string that is prepended to the names of grobs
that are created by this panel function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object returned by <code><a href="stats.html#topic+scatter.smooth">loess.smooth</a></code>.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>See Also</h3>

<p><a href="#topic+Lattice">Lattice</a>,
<code><a href="stats.html#topic+scatter.smooth">loess.smooth</a></code>,
<code><a href="#topic+prepanel.loess">prepanel.loess</a></code>  
</p>

<hr>
<h2 id='F_2_panel.qqmathline'>Useful panel function with qqmath</h2><span id='topic+panel.qqmathline'></span>

<h3>Description</h3>

<p>Useful panel function with qqmath. Draws a line passing through the
points (usually) determined by the .25 and .75 quantiles of the sample
and the theoretical distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.qqmathline(x, y = x,
                 distribution = qnorm,
                 probs = c(0.25, 0.75),
                 qtype = 7,
                 groups = NULL, 
                 ...,
                 identifier = "qqmathline")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="F_2_panel.qqmathline_+3A_x">x</code></td>
<td>
<p> The original sample, possibly reduced to a fewer number of
quantiles, as determined by the <code>f.value</code> argument to
<code>qqmath</code>
</p>
</td></tr>
<tr><td><code id="F_2_panel.qqmathline_+3A_y">y</code></td>
<td>

<p>an alias for <code>x</code> for backwards compatibility
</p>
</td></tr>
<tr><td><code id="F_2_panel.qqmathline_+3A_distribution">distribution</code></td>
<td>

<p>quantile function for reference theoretical distribution.
</p>
</td></tr>
<tr><td><code id="F_2_panel.qqmathline_+3A_probs">probs</code></td>
<td>

<p>numeric vector of length two, representing probabilities.
Corresponding quantile pairs define the line drawn.
</p>
</td></tr>
<tr><td><code id="F_2_panel.qqmathline_+3A_qtype">qtype</code></td>
<td>

<p>the <code>type</code> of quantile computation used in
<code><a href="stats.html#topic+quantile">quantile</a></code>
</p>
</td></tr>
<tr><td><code id="F_2_panel.qqmathline_+3A_groups">groups</code></td>
<td>

<p>optional grouping variable.  If non-null, a line will be drawn for
each group.
</p>
</td></tr>
<tr><td><code id="F_2_panel.qqmathline_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
<tr><td><code id="F_2_panel.qqmathline_+3A_identifier">identifier</code></td>
<td>

<p>A character string that is prepended to the names of grobs
that are created by this panel function.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+prepanel.qqmathline">prepanel.qqmathline</a></code>,
<code><a href="#topic+qqmath">qqmath</a></code>,
<code><a href="stats.html#topic+quantile">quantile</a></code>
</p>

<hr>
<h2 id='F_2_panel.smoothScatter'>Lattice panel function analogous to smoothScatter</h2><span id='topic+panel.smoothScatter'></span>

<h3>Description</h3>

<p>This function allows the user to place <code>smoothScatter</code> plots in
lattice graphics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.smoothScatter(x, y = NULL,
                    nbin = 64, cuts = 255,
                    bandwidth,
                    col.regions,
                    colramp,
                    nrpoints = 100,
                    transformation = function(x) x^0.25,
                    pch = ".",
                    cex = 1, col="black",
                    range.x,
                    ...,
                    raster = FALSE,
                    subscripts,
                    identifier = "smoothScatter")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="F_2_panel.smoothScatter_+3A_x">x</code></td>
<td>
<p>Numeric vector containing x-values or n by 2 matrix containing x
and y values.</p>
</td></tr>
<tr><td><code id="F_2_panel.smoothScatter_+3A_y">y</code></td>
<td>
<p>Numeric vector containing y-values (optional). The length of <code>x</code>
must be the same as that of <code>y</code>.</p>
</td></tr>
<tr><td><code id="F_2_panel.smoothScatter_+3A_nbin">nbin</code></td>
<td>
<p>Numeric vector of length 1 (for both directions) or
2 (for x and y separately) containing the number of equally spaced
grid points for the density estimation.</p>
</td></tr>
<tr><td><code id="F_2_panel.smoothScatter_+3A_cuts">cuts</code></td>
<td>
<p> number of cuts defining the color gradient </p>
</td></tr>
<tr><td><code id="F_2_panel.smoothScatter_+3A_bandwidth">bandwidth</code></td>
<td>
<p>Numeric vector: the smoothing bandwidth.  If missing,
these functions come up with a more or less useful guess.  This
parameter then gets passed on to the function
<code><a href="KernSmooth.html#topic+bkde2D">bkde2D</a></code>.</p>
</td></tr>
<tr><td><code id="F_2_panel.smoothScatter_+3A_col.regions">col.regions</code></td>
<td>
<p> character vector of colors, or a function
producing such a vector. Defaults to the <code>col</code> component of the
<code>regions</code> setting of the current theme. </p>
</td></tr>
<tr><td><code id="F_2_panel.smoothScatter_+3A_colramp">colramp</code></td>
<td>
<p> Function accepting an integer <code>n</code> as an argument
and returning <code>n</code> colors. If missing, the default is derived
from <code>col.regions</code> with the following modification: if
<code>col.regions</code> is a vector of colors, it is prepended by
<code>"white"</code> before being converted into a function using
<code><a href="grDevices.html#topic+colorRampPalette">colorRampPalette</a></code>. </p>
</td></tr>
<tr><td><code id="F_2_panel.smoothScatter_+3A_nrpoints">nrpoints</code></td>
<td>
<p>Numeric vector of length 1 giving number of points to
be superimposed on the density image. The first <code>nrpoints</code> points
from those areas of lowest regional densities will be plotted. Adding
points to the plot allows for the identification of outliers.
If all points are to be plotted, choose <code>nrpoints = Inf</code>.</p>
</td></tr>
<tr><td><code id="F_2_panel.smoothScatter_+3A_transformation">transformation</code></td>
<td>
<p>Function that maps the density scale to the color scale.</p>
</td></tr>
<tr><td><code id="F_2_panel.smoothScatter_+3A_pch">pch</code>, <code id="F_2_panel.smoothScatter_+3A_cex">cex</code></td>
<td>
<p> graphical parameters for the <code>nrpoints</code>
&ldquo;outlying&rdquo; points shown in the display </p>
</td></tr>
<tr><td><code id="F_2_panel.smoothScatter_+3A_range.x">range.x</code></td>
<td>
<p>see  <code><a href="KernSmooth.html#topic+bkde2D">bkde2D</a></code> for details.</p>
</td></tr>
<tr><td><code id="F_2_panel.smoothScatter_+3A_col">col</code></td>
<td>
<p><code><a href="graphics.html#topic+points">points</a></code> color parameter</p>
</td></tr>
<tr><td><code id="F_2_panel.smoothScatter_+3A_...">...</code></td>
<td>
<p>Further arguments that are passed on to
<code><a href="#topic+panel.levelplot">panel.levelplot</a></code>.</p>
</td></tr>
<tr><td><code id="F_2_panel.smoothScatter_+3A_raster">raster</code></td>
<td>
<p> logical; if <code>TRUE</code>,
<code><a href="#topic+panel.levelplot.raster">panel.levelplot.raster</a></code> is used, making potentially
smaller output files. </p>
</td></tr>
<tr><td><code id="F_2_panel.smoothScatter_+3A_subscripts">subscripts</code></td>
<td>
<p> ignored, but necessary for handling of ... in
certain situations.  Likely to be removed in future. </p>
</td></tr>
<tr><td><code id="F_2_panel.smoothScatter_+3A_identifier">identifier</code></td>
<td>

<p>A character string that is prepended to the names of grobs
that are created by this panel function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This replicates the display part of the <code>smoothScatter</code>
function by replacing standard graphics calls by grid-compatible ones.
</p>


<h3>Value</h3>

<p>The function is called for its side effects, namely the production
of the appropriate plots on a graphics device.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:deepayan.sarkar@r-project.org">deepayan.sarkar@r-project.org</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
ddf &lt;- as.data.frame(matrix(rnorm(40000), ncol = 4) + 1.5 * rnorm(10000))
ddf[, c(2,4)] &lt;- (-ddf[, c(2,4)])
xyplot(V1 ~ V2 + V3, ddf, outer = TRUE,
       panel = panel.smoothScatter, aspect = "iso")
## argument to panel.levelplot
xyplot(V1 ~ V2, ddf, panel = panel.smoothScatter, cuts = 10,
       region.type = "contour")
splom(ddf, panel = panel.smoothScatter, nbin = 64, raster = TRUE)

</code></pre>

<hr>
<h2 id='F_2_panel.spline'>Panel Function to Add a Spline Smooth</h2><span id='topic+panel.spline'></span>

<h3>Description</h3>

<p>A predefined panel function that can be used to add a spline smooth
based on the provided data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.spline(x, y, npoints = 101,
             lwd = plot.line$lwd,
             lty = plot.line$lty,
             col, col.line = plot.line$col,
             type,
             horizontal = FALSE, ...,
             keep.data = FALSE,
             identifier = "spline")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="F_2_panel.spline_+3A_x">x</code>, <code id="F_2_panel.spline_+3A_y">y</code></td>
<td>
<p> Variables defining the data to be used. </p>
</td></tr>
<tr><td><code id="F_2_panel.spline_+3A_npoints">npoints</code></td>
<td>
<p> The number of equally spaced points within the range
of the predictor at which the fitted model is evaluated for
plotting.
</p>
</td></tr>
<tr><td><code id="F_2_panel.spline_+3A_lwd">lwd</code>, <code id="F_2_panel.spline_+3A_lty">lty</code>, <code id="F_2_panel.spline_+3A_col">col</code>, <code id="F_2_panel.spline_+3A_col.line">col.line</code></td>
<td>
<p> Graphical parameters for the added
line.  <code>col.line</code> overrides <code>col</code>. </p>
</td></tr>
<tr><td><code id="F_2_panel.spline_+3A_type">type</code></td>
<td>
<p> Ignored.  The argument is present only to make sure that
an explicitly specified <code>type</code> argument (perhaps meant for
another function) does not affect the display.  </p>
</td></tr>
<tr><td><code id="F_2_panel.spline_+3A_horizontal">horizontal</code></td>
<td>

<p>A logical flag controlling which variable is to be treated as the
predictor (by default <code>x</code>) and which as the response (by
default <code>y</code>).  If <code>TRUE</code>, the plot is &lsquo;transposed&rsquo;
in the sense that <code>y</code> becomes the predictor and <code>x</code> the
response.  (The name &lsquo;horizontal&rsquo; may seem an odd choice for
this argument, and originates from similar usage in
<code><a href="#topic+bwplot">bwplot</a></code>).
</p>
</td></tr>
<tr><td><code id="F_2_panel.spline_+3A_keep.data">keep.data</code></td>
<td>
<p> Passed on to <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>.  The
default here (<code>FALSE</code>) is different, and results in the
original data not being retained in the fitted spline model.  It may
be useful to set this to <code>TRUE</code> if the return value of
<code>panel.spline</code>, which is the fitted model as returned by
<code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>, is to be used for subsequent
computations.  </p>
</td></tr>
<tr><td><code id="F_2_panel.spline_+3A_...">...</code></td>
<td>
<p> Extra arguments, passed on to
<code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code> and <code><a href="#topic+panel.lines">panel.lines</a></code> as
appropriate.  </p>
</td></tr>
<tr><td><code id="F_2_panel.spline_+3A_identifier">identifier</code></td>
<td>

<p>A character string that is prepended to the names of grobs
that are created by this panel function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The fitted model as returned by <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>See Also</h3>

<p><a href="#topic+Lattice">Lattice</a>,
<code><a href="stats.html#topic+scatter.smooth">smooth.spline</a></code>,
<code><a href="#topic+prepanel.spline">prepanel.spline</a></code>  
</p>

<hr>
<h2 id='F_2_panel.superpose'> Panel Function for Display Marked by groups </h2><span id='topic+panel.superpose'></span><span id='topic+panel.superpose.2'></span><span id='topic+panel.superpose.plain'></span>

<h3>Description</h3>

<p>These are panel functions for Trellis displays useful when a grouping
variable is specified for use within panels. The <code>x</code> (and
<code>y</code> where appropriate) variables are plotted with different
graphical parameters for each distinct value of the grouping variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.superpose(x, y = NULL, subscripts, groups,
                panel.groups = "panel.xyplot",
                ...,
                col, col.line, col.symbol,
                pch, cex, fill, font,
                fontface, fontfamily,
                lty, lwd, alpha,
                type = "p",
                grid = lattice.getOption("default.args")$grid,
                distribute.type = FALSE)
panel.superpose.2(..., distribute.type = TRUE)

panel.superpose.plain(...,
                      col, col.line, col.symbol,
                      pch, cex, fill, font,
                      fontface, fontfamily,
                      lty, lwd, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="F_2_panel.superpose_+3A_x">x</code>, <code id="F_2_panel.superpose_+3A_y">y</code></td>
<td>

<p>Coordinates of the points to be displayed.  Usually numeric.
</p>
</td></tr>
<tr><td><code id="F_2_panel.superpose_+3A_panel.groups">panel.groups</code></td>
<td>

<p>The panel function to be used for each subgroup of points.  Defaults
to <code>panel.xyplot</code>.
</p>
<p>To be able to distinguish between different levels of the
originating group inside <code>panel.groups</code>, it will be supplied
two special arguments called <code>group.number</code> and
<code>group.value</code> which will hold the numeric code and factor level
corresponding to the current level of <code>groups</code>.  No special
care needs to be taken when writing a <code>panel.groups</code> function
if this feature is not used.
</p>
</td></tr>
<tr><td><code id="F_2_panel.superpose_+3A_subscripts">subscripts</code></td>
<td>

<p>An integer vector of subscripts giving indices of the <code>x</code> and
<code>y</code> values in the original data source.  See the corresponding
entry in <code><a href="#topic+xyplot">xyplot</a></code> for details.
</p>
</td></tr>
<tr><td><code id="F_2_panel.superpose_+3A_groups">groups</code></td>
<td>

<p>A grouping variable.  Different graphical parameters will be used to
plot the subsets of observations given by each distinct value of
<code>groups</code>. The default graphical parameters are obtained from
the <code>"superpose.symbol"</code> and <code>"superpose.line"</code> settings
using <code><a href="#topic+trellis.par.get">trellis.par.get</a></code> wherever appropriate.
</p>
</td></tr>
<tr><td><code id="F_2_panel.superpose_+3A_type">type</code></td>
<td>
<p> Usually a character vector specifying how each group
should be drawn.  Formally, it is passed on to the
<code>panel.groups</code> function, which must know what to do with it.
By default, <code>panel.groups</code> is <code><a href="#topic+panel.xyplot">panel.xyplot</a></code>, whose
help page describes the admissible values.
</p>
<p>The functions <code>panel.superpose</code> and <code>panel.superpose.2</code>
differ only in the default value of <code>distribute.type</code>, which
controls the way the <code>type</code> argument is interpreted.  If
<code>distribute.type = FALSE</code>, then the interpretation is the same
as for <code>panel.xyplot</code> for each of the unique groups.  In other
words, if <code>type</code> is a vector, all the individual components are
honoured concurrently.  If <code>distribute.type = TRUE</code>,
<code>type</code> is replicated to be as long as the number of unique
values in <code>groups</code>, and one component used for the points
corresponding to the each different group.  Even in this case, it is
possible to request multiple types per group, specifying <code>type</code>
as a list, each component being the desired <code>type</code> vector for
the corresponding group.
</p>
<p>If <code>distribute.type = FALSE</code>, any occurrence of <code>"g"</code> in
<code>type</code> causes a grid to be drawn, and all such occurrences are
removed before <code>type</code> is passed on to <code>panel.groups</code>.
</p>
</td></tr>
<tr><td><code id="F_2_panel.superpose_+3A_grid">grid</code></td>
<td>
<p> Logical flag specifying whether a background reference
grid should be drawn.  See <code><a href="#topic+panel.xyplot">panel.xyplot</a></code> for details. </p>
</td></tr>
<tr><td><code id="F_2_panel.superpose_+3A_col">col</code></td>
<td>
<p> A vector color specification.  See Details. </p>
</td></tr>
<tr><td><code id="F_2_panel.superpose_+3A_col.line">col.line</code></td>
<td>
<p> A vector color specification.  See Details. </p>
</td></tr>
<tr><td><code id="F_2_panel.superpose_+3A_col.symbol">col.symbol</code></td>
<td>
<p> A vector color specification.  See Details. </p>
</td></tr>
<tr><td><code id="F_2_panel.superpose_+3A_pch">pch</code></td>
<td>
<p> A vector plotting character specification.  See Details. </p>
</td></tr>
<tr><td><code id="F_2_panel.superpose_+3A_cex">cex</code></td>
<td>
<p> A vector size factor specification.  See Details. </p>
</td></tr>
<tr><td><code id="F_2_panel.superpose_+3A_fill">fill</code></td>
<td>
<p> A vector fill color specification.  See Details. </p>
</td></tr>
<tr><td><code id="F_2_panel.superpose_+3A_font">font</code>, <code id="F_2_panel.superpose_+3A_fontface">fontface</code>, <code id="F_2_panel.superpose_+3A_fontfamily">fontfamily</code></td>
<td>
<p> A vector color specification.  See Details. </p>
</td></tr>
<tr><td><code id="F_2_panel.superpose_+3A_lty">lty</code></td>
<td>
<p> A vector color specification.  See Details. </p>
</td></tr>
<tr><td><code id="F_2_panel.superpose_+3A_lwd">lwd</code></td>
<td>
<p> A vector color specification.  See Details. </p>
</td></tr>
<tr><td><code id="F_2_panel.superpose_+3A_alpha">alpha</code></td>
<td>
<p> A vector alpha-transparency specification.  See Details. </p>
</td></tr>
<tr><td><code id="F_2_panel.superpose_+3A_...">...</code></td>
<td>
<p> Extra arguments.  Passed down to <code>panel.superpose</code>
from <code>panel.superpose.2</code>, and to <code>panel.groups</code> from
<code>panel.superpose</code>.
</p>
</td></tr>
<tr><td><code id="F_2_panel.superpose_+3A_distribute.type">distribute.type</code></td>
<td>
<p>logical controlling interpretation of the
<code>type</code> argument.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>panel.superpose</code> divides up the <code>x</code> (and optionally
<code>y</code>) variable(s) by the unique values of
<code>groups[subscripts]</code>, and plots each subset with different
graphical parameters.  The graphical parameters (<code>col.symbol</code>,
<code>pch</code>, etc.) are usually supplied as suitable atomic vectors, but
can also be lists.  When <code>panel.groups</code> is called for the
<code>i</code>-th level of <code>groups</code>, the corresponding element of each
graphical parameter is passed to it.  In the list form, the individual
components can themselves be vectors.
</p>
<p>The actual plot for each subgroup is created by the
<code>panel.groups</code> function.  With the default <code>panel.groups</code>,
the <code>col</code> argument is overridden by <code>col.line</code> and
<code>col.symbol</code> for lines and points respectively, which default to
the <code>"superpose.line"</code> and <code>"superpose.symbol"</code> settings.
However, <code>col</code> will still be supplied as an argument to
<code>panel.groups</code> functions that make use of it, with a default of
<code>"black"</code>.  The defaults of other graphical parameters are also
taken from the <code>"superpose.line"</code> and <code>"superpose.symbol"</code>
settings as appropriate.  The <code>alpha</code> parameter takes it default
from the <code>"superpose.line"</code> setting.
</p>
<p><code>panel.superpose</code> and <code>panel.superpose.2</code> differ essentially
in how <code>type</code> is interpreted by default.  The default behaviour
in <code>panel.superpose</code> is the opposite of that in S, which is the
same as that of <code>panel.superpose.2</code>.
</p>
<p><code>panel.superpose.plain</code> is the same as <code>panel.superpose</code>,
except that the default settings for the style arguments are the
same for all groups and are taken from the default plot style.
It is used in <code><a href="#topic+xyplot.ts">xyplot.ts</a></code>.
</p>


<h3>Author(s)</h3>

<p>Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a>
(<code>panel.superpose.2</code> originally contributed by Neil Klepeis)
</p>


<h3>See Also</h3>

<p>Different functions when used as <code>panel.groups</code> gives different
types of plots, for example <code><a href="#topic+panel.xyplot">panel.xyplot</a></code>,
<code><a href="#topic+panel.dotplot">panel.dotplot</a></code> and <code><a href="#topic+panel.average">panel.average</a></code> (This can
be used to produce interaction plots).
</p>
<p>See <code><a href="#topic+Lattice">Lattice</a></code> for an overview of the package, and
<code><a href="#topic+xyplot">xyplot</a></code> for common arguments (in particular, the
discussion of the extended formula interface and the <code>groups</code>
argument).
</p>

<hr>
<h2 id='F_2_panel.violin'> Panel Function to create Violin Plots </h2><span id='topic+panel.violin'></span>

<h3>Description</h3>

<p>This is a panel function that can create a violin plot.  It is
typically used in a high-level call to <code>bwplot</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
panel.violin(x, y, box.ratio = 1, box.width,
             horizontal = TRUE,
             alpha, border, lty, lwd, col,
             varwidth = FALSE,
             bw, adjust, kernel, window, 
             width, n = 50, from, to, cut,
             na.rm, ...,
             identifier = "violin")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="F_2_panel.violin_+3A_x">x</code>, <code id="F_2_panel.violin_+3A_y">y</code></td>
<td>

<p>numeric vector or factor. Violin plots are drawn for each unique
value of <code>y</code> (<code>x</code>) if <code>horizontal</code> is <code>TRUE</code>
(<code>FALSE</code>)
</p>
</td></tr>
<tr><td><code id="F_2_panel.violin_+3A_box.ratio">box.ratio</code></td>
<td>

<p>ratio of the thickness of each violin and inter violin space
</p>
</td></tr>
<tr><td><code id="F_2_panel.violin_+3A_box.width">box.width</code></td>
<td>
<p> thickness of the violins in absolute units;
overrides <code>box.ratio</code>.  Useful for specifying thickness when
the categorical variable is not a factor, as use of <code>box.ratio</code>
alone cannot achieve a thickness greater than 1. </p>
</td></tr>
<tr><td><code id="F_2_panel.violin_+3A_horizontal">horizontal</code></td>
<td>

<p>logical. If FALSE, the plot is &lsquo;transposed&rsquo; in the sense that
the behaviours of <code>x</code> and <code>y</code> are switched.  <code>x</code> is
now the &lsquo;factor&rsquo;. See documentation of <code><a href="#topic+bwplot">bwplot</a></code>
for a fuller explanation.
</p>
</td></tr>
<tr><td><code id="F_2_panel.violin_+3A_alpha">alpha</code>, <code id="F_2_panel.violin_+3A_border">border</code>, <code id="F_2_panel.violin_+3A_lty">lty</code>, <code id="F_2_panel.violin_+3A_lwd">lwd</code>, <code id="F_2_panel.violin_+3A_col">col</code></td>
<td>

<p>graphical parameters controlling the violin.  Defaults are taken
from the <code>"plot.polygon"</code> settings.
</p>
</td></tr>
<tr><td><code id="F_2_panel.violin_+3A_varwidth">varwidth</code></td>
<td>

<p>logical. If <code>FALSE</code>, the densities are scaled separately for
each group, so that the maximum value of the density reaches the
limit of the allocated space for each violin (as determined by
<code>box.ratio</code>).  If <code>TRUE</code>, densities across violins will
have comparable scale.
</p>
</td></tr>
<tr><td><code id="F_2_panel.violin_+3A_bw">bw</code>, <code id="F_2_panel.violin_+3A_adjust">adjust</code>, <code id="F_2_panel.violin_+3A_kernel">kernel</code>, <code id="F_2_panel.violin_+3A_window">window</code>, <code id="F_2_panel.violin_+3A_width">width</code>, <code id="F_2_panel.violin_+3A_n">n</code>, <code id="F_2_panel.violin_+3A_from">from</code>, <code id="F_2_panel.violin_+3A_to">to</code>, <code id="F_2_panel.violin_+3A_cut">cut</code>, <code id="F_2_panel.violin_+3A_na.rm">na.rm</code></td>
<td>

<p>arguments to <code><a href="stats.html#topic+density">density</a></code>, passed on as appropriate </p>
</td></tr>
<tr><td><code id="F_2_panel.violin_+3A_...">...</code></td>
<td>

<p>arguments passed on to <code>density</code>.
</p>
</td></tr>
<tr><td><code id="F_2_panel.violin_+3A_identifier">identifier</code></td>
<td>

<p>A character string that is prepended to the names of grobs
that are created by this panel function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates Violin plot of <code>x</code> for every level of <code>y</code>. Note that
most arguments controlling the display can be supplied to the
high-level (typically <code>bwplot</code>) call directly.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+bwplot">bwplot</a></code>, <code><a href="stats.html#topic+density">density</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bwplot(voice.part ~ height, singer,
       panel = function(..., box.ratio) {
           panel.violin(..., col = "transparent",
                        varwidth = FALSE, box.ratio = box.ratio)
           panel.bwplot(..., fill = NULL, box.ratio = .1)
       } )

</code></pre>

<hr>
<h2 id='F_3_prepanel.default'> Default Prepanel Functions </h2><span id='topic+prepanel.default.bwplot'></span><span id='topic+prepanel.default.histogram'></span><span id='topic+prepanel.default.qq'></span><span id='topic+prepanel.default.xyplot'></span><span id='topic+prepanel.default.cloud'></span><span id='topic+prepanel.default.levelplot'></span><span id='topic+prepanel.default.qqmath'></span><span id='topic+prepanel.default.densityplot'></span><span id='topic+prepanel.default.parallel'></span><span id='topic+prepanel.default.splom'></span>

<h3>Description</h3>

<p>These prepanel functions are used as fallback defaults in various
high level plot functions in Lattice.  These are rarely useful to
normal users but may be helpful in developing new displays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
prepanel.default.bwplot(x, y, horizontal, nlevels, origin, stack, ...)
prepanel.default.histogram(x, breaks, equal.widths, type, nint, ...)
prepanel.default.qq(x, y, ...)
prepanel.default.xyplot(x, y, type, subscripts, groups, ...)
prepanel.default.cloud(perspective, distance,
                       xlim, ylim, zlim,
                       screen = list(z = 40, x = -60),
                       R.mat = diag(4),
                       aspect = c(1, 1), panel.aspect = 1,
                       ..., zoom = 0.8)
prepanel.default.levelplot(x, y, subscripts, ...)
prepanel.default.qqmath(x, f.value, distribution, qtype,
                        groups, subscripts, ..., tails.n = 0)
prepanel.default.densityplot(x, darg, groups, weights, subscripts, ...)
prepanel.default.parallel(x, y, z, ..., horizontal.axis)
prepanel.default.splom(z, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="F_3_prepanel.default_+3A_x">x</code>, <code id="F_3_prepanel.default_+3A_y">y</code></td>
<td>
<p>x and y values, numeric or factor</p>
</td></tr>
<tr><td><code id="F_3_prepanel.default_+3A_horizontal">horizontal</code></td>
<td>
<p> logical, applicable when one of the variables is to
be treated as categorical (factor or shingle).
</p>
</td></tr>
<tr><td><code id="F_3_prepanel.default_+3A_horizontal.axis">horizontal.axis</code></td>
<td>
<p> logical indicating whether the
parallel axes should be laid out horizontally (<code>TRUE</code>) or
vertically (<code>FALSE</code>).
</p>
</td></tr>
<tr><td><code id="F_3_prepanel.default_+3A_nlevels">nlevels</code></td>
<td>
<p> number of levels of such a categorical variable. </p>
</td></tr>
<tr><td><code id="F_3_prepanel.default_+3A_origin">origin</code>, <code id="F_3_prepanel.default_+3A_stack">stack</code></td>
<td>
<p> for barcharts or the <code>type="h"</code> plot type</p>
</td></tr>
<tr><td><code id="F_3_prepanel.default_+3A_breaks">breaks</code>, <code id="F_3_prepanel.default_+3A_equal.widths">equal.widths</code>, <code id="F_3_prepanel.default_+3A_type">type</code>, <code id="F_3_prepanel.default_+3A_nint">nint</code></td>
<td>
<p> details of histogram
calculations.  <code>type</code> has a different meaning in
<code>prepanel.default.xyplot</code> (see <code><a href="#topic+panel.xyplot">panel.xyplot</a></code>)
</p>
</td></tr>
<tr><td><code id="F_3_prepanel.default_+3A_groups">groups</code>, <code id="F_3_prepanel.default_+3A_subscripts">subscripts</code></td>
<td>
<p> See <code><a href="#topic+xyplot">xyplot</a></code>.  Whenever
appropriate, calculations are done separately for each group and
then combined.  </p>
</td></tr>
<tr><td><code id="F_3_prepanel.default_+3A_weights">weights</code></td>
<td>
<p> numeric vector of weights for the density
calculations.  If this is specified, it is subsetted by
<code>subscripts</code> to match it to <code>x</code>.  </p>
</td></tr>
<tr><td><code id="F_3_prepanel.default_+3A_perspective">perspective</code>, <code id="F_3_prepanel.default_+3A_distance">distance</code>, <code id="F_3_prepanel.default_+3A_xlim">xlim</code>, <code id="F_3_prepanel.default_+3A_ylim">ylim</code>, <code id="F_3_prepanel.default_+3A_zlim">zlim</code>, <code id="F_3_prepanel.default_+3A_screen">screen</code>, <code id="F_3_prepanel.default_+3A_r.mat">R.mat</code>, <code id="F_3_prepanel.default_+3A_aspect">aspect</code>, <code id="F_3_prepanel.default_+3A_panel.aspect">panel.aspect</code>, <code id="F_3_prepanel.default_+3A_zoom">zoom</code></td>
<td>
<p> see <code><a href="#topic+panel.cloud">panel.cloud</a></code></p>
</td></tr>
<tr><td><code id="F_3_prepanel.default_+3A_f.value">f.value</code>, <code id="F_3_prepanel.default_+3A_distribution">distribution</code>, <code id="F_3_prepanel.default_+3A_tails.n">tails.n</code></td>
<td>
<p> see <code>panel.qqmath</code> </p>
</td></tr>
<tr><td><code id="F_3_prepanel.default_+3A_darg">darg</code></td>
<td>
<p> list of arguments passed to <code><a href="stats.html#topic+density">density</a></code></p>
</td></tr>
<tr><td><code id="F_3_prepanel.default_+3A_z">z</code></td>
<td>
<p> see <code><a href="#topic+panel.parallel">panel.parallel</a></code> and <code><a href="#topic+panel.pairs">panel.pairs</a></code> </p>
</td></tr>
<tr><td><code id="F_3_prepanel.default_+3A_qtype">qtype</code></td>
<td>
<p> type of <code><a href="stats.html#topic+quantile">quantile</a></code></p>
</td></tr>
<tr><td><code id="F_3_prepanel.default_+3A_...">...</code></td>
<td>
<p> other arguments, usually ignored </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components <code>xlim</code>, <code>ylim</code>, <code>dx</code> and
<code>dy</code>, and possibly <code>xat</code> and <code>yat</code>, the first two being
used to calculate panel axes limits, the last two for banking
computations.  The form of these components are described in the help
page for <code><a href="#topic+xyplot">xyplot</a></code>.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+xyplot">xyplot</a></code>, <code><a href="#topic+banking">banking</a></code>, <code><a href="#topic+Lattice">Lattice</a></code>.
See documentation of corresponding panel functions for more details
about the arguments.
</p>

<hr>
<h2 id='F_3_prepanel.functions'> Useful Prepanel Function for Lattice</h2><span id='topic+prepanel.lmline'></span><span id='topic+prepanel.loess'></span><span id='topic+prepanel.spline'></span><span id='topic+prepanel.qqmathline'></span>

<h3>Description</h3>

<p>These are predefined prepanel functions available in Lattice.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepanel.lmline(x, y, ...)
prepanel.qqmathline(x, y = x, distribution = qnorm,
                    probs = c(0.25, 0.75), qtype = 7,
                    groups, subscripts,
                    ...) 
prepanel.loess(x, y, span, degree, family, evaluation,
               horizontal = FALSE, ...)
prepanel.spline(x, y, npoints = 101, 
                horizontal = FALSE, ...,
                keep.data = FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="F_3_prepanel.functions_+3A_x">x</code>, <code id="F_3_prepanel.functions_+3A_y">y</code></td>
<td>
<p>x and y values, numeric or factor</p>
</td></tr>
<tr><td><code id="F_3_prepanel.functions_+3A_distribution">distribution</code></td>
<td>
<p> quantile function for theoretical
distribution. This is automatically passed in when this is used as a
prepanel function in <code>qqmath</code>.
</p>
</td></tr>
<tr><td><code id="F_3_prepanel.functions_+3A_qtype">qtype</code></td>
<td>
<p> type of <code><a href="stats.html#topic+quantile">quantile</a></code></p>
</td></tr>
<tr><td><code id="F_3_prepanel.functions_+3A_probs">probs</code></td>
<td>

<p>numeric vector of length two, representing probabilities.  If used
with <code>aspect="xy"</code>, the aspect ratio will be chosen to make the
line passing through the corresponding quantile pairs as close to 45
degrees as possible.
</p>
</td></tr>
<tr><td><code id="F_3_prepanel.functions_+3A_span">span</code>, <code id="F_3_prepanel.functions_+3A_degree">degree</code>, <code id="F_3_prepanel.functions_+3A_family">family</code>, <code id="F_3_prepanel.functions_+3A_evaluation">evaluation</code></td>
<td>
<p> Arguments controlling the
underlying <code><a href="stats.html#topic+loess">loess</a></code> smooth. </p>
</td></tr>
<tr><td><code id="F_3_prepanel.functions_+3A_horizontal">horizontal</code>, <code id="F_3_prepanel.functions_+3A_npoints">npoints</code></td>
<td>
<p> See documentation for corresponding panel
function.
</p>
</td></tr>
<tr><td><code id="F_3_prepanel.functions_+3A_keep.data">keep.data</code></td>
<td>
<p> Ignored. Present to capture argument of the same
name in <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>. </p>
</td></tr>
<tr><td><code id="F_3_prepanel.functions_+3A_groups">groups</code>, <code id="F_3_prepanel.functions_+3A_subscripts">subscripts</code></td>
<td>
<p> See <code><a href="#topic+xyplot">xyplot</a></code>.  Whenever
appropriate, calculations are done separately for each group and
then combined.  </p>
</td></tr>
<tr><td><code id="F_3_prepanel.functions_+3A_...">...</code></td>
<td>
<p> Other arguments.  These are passed on to other functions
if appropriate (in particular, <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>), and
ignored otherwise. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>All these prepanel functions compute the limits to be large enough to
contain all points as well as the relevant smooth.
</p>
<p>In addition, <code>prepanel.lmline</code> computes the <code>dx</code> and
<code>dy</code> such that it reflects the slope of the linear regression
line; for <code>prepanel.qqmathline</code>, this is the slope of the line
passing through the quantile pairs specified by <code>probs</code>.  For
<code>prepanel.loess</code> and <code>prepanel.spline</code>, <code>dx</code> and
<code>dy</code> reflect the piecewise slopes of the nonlinear smooth.
</p>


<h3>Value</h3>

<p>usually a list with components <code>xlim</code>, <code>ylim</code>, <code>dx</code> and
<code>dy</code>, the first two being used to calculate panel axes limits,
the last two for banking computations.  The form of these components
are described under <code><a href="#topic+xyplot">xyplot</a></code>.  There are also several
prepanel functions that serve as the default for high level functions,
see <code><a href="#topic+prepanel.default.xyplot">prepanel.default.xyplot</a></code>
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>See Also</h3>

<p><a href="#topic+Lattice">Lattice</a>, <code><a href="#topic+xyplot">xyplot</a></code>, <code><a href="#topic+banking">banking</a></code>,
<code><a href="#topic+panel.loess">panel.loess</a></code>, <code><a href="#topic+panel.spline">panel.spline</a></code>.
</p>

<hr>
<h2 id='G_axis.default'>Default axis annotation utilities</h2><span id='topic+axis.default'></span><span id='topic+xscale.components.default'></span><span id='topic+yscale.components.default'></span>

<h3>Description</h3>

<p>Lattice funtions provide control over how the plot axes are annotated
through a common interface.  There are two levels of control.  The
<code>xscale.components</code> and <code>yscale.components</code> arguments can be
functions that determine tick mark locations and labels given a
packet.  For more direct control, the <code>axis</code> argument can be a
function that actually draws the axes.  The functions documented here
are the defaults for these arguments.  They can additonally be used as
components of user written replacements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xscale.components.default(lim,
                          packet.number = 0,
                          packet.list = NULL,
                          top = TRUE,
                          ...)
yscale.components.default(lim,
                          packet.number = 0,
                          packet.list = NULL,
                          right = TRUE,
                          ...)
axis.default(side = c("top", "bottom", "left", "right"),
             scales, components, as.table,
             labels = c("default", "yes", "no"),
             ticks = c("default", "yes", "no"),
             ..., prefix)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="G_axis.default_+3A_lim">lim</code></td>
<td>
<p> the range of the data in that packet (data subset
corresponding to a combination of levels of the conditioning
variable).  The range is not necessarily numeric; e.g. for factors,
they could be character vectors representing levels, and for the
various date-time representations, they could be vectors of length 2
with the corresponding class. </p>
</td></tr>
<tr><td><code id="G_axis.default_+3A_packet.number">packet.number</code></td>
<td>
<p> which packet (counted according to the packet
order, described in <code><a href="#topic+print.trellis">print.trellis</a></code>) is being
processed.  In cases where all panels have the same limits, this
function is called only once (rather than once for each packet), in
which case this argument will have the value <code>0</code>.
</p>
</td></tr>
<tr><td><code id="G_axis.default_+3A_packet.list">packet.list</code></td>
<td>
<p> list, as long as the number of packets, giving
all the actual packets.  Specifically, each component is the
list of arguments given to the panel function when and if that
packet is drawn in a panel.  (This has not yet been implemented.) </p>
</td></tr>
<tr><td><code id="G_axis.default_+3A_top">top</code>, <code id="G_axis.default_+3A_right">right</code></td>
<td>
<p> the value of the <code>top</code> and <code>right</code>
components of the result, as appropriate.  See below for
interpretation.</p>
</td></tr>
<tr><td><code id="G_axis.default_+3A_side">side</code></td>
<td>
<p> on which side the axis is to be drawn.  The usual partial
matching rules apply.  </p>
</td></tr>
<tr><td><code id="G_axis.default_+3A_scales">scales</code></td>
<td>
<p> the appropriate component of the <code>scales</code> argument
supplied to the high level function, suitably standardized. </p>
</td></tr>
<tr><td><code id="G_axis.default_+3A_components">components</code></td>
<td>
<p> list, similar to those produced by
<code>xscale.components.default</code> and
<code>yscale.components.default</code>.  </p>
</td></tr>
<tr><td><code id="G_axis.default_+3A_as.table">as.table</code></td>
<td>
<p> the <code>as.table</code> argument in the high level
function.  </p>
</td></tr>
<tr><td><code id="G_axis.default_+3A_labels">labels</code></td>
<td>
<p> whether labels are to be drawn.  By default, the rules
determined by <code>scales</code> are used.  </p>
</td></tr>
<tr><td><code id="G_axis.default_+3A_ticks">ticks</code></td>
<td>
<p> whether labels are to be drawn.  By default, the rules
determined by <code>scales</code> are used.  </p>
</td></tr>
<tr><td><code id="G_axis.default_+3A_...">...</code></td>
<td>
<p> many other arguments may be supplied, and are passed on
to other internal functions. </p>
</td></tr>
<tr><td><code id="G_axis.default_+3A_prefix">prefix</code></td>
<td>

<p>A character string identifying the plot being drawn (see
<code><a href="#topic+print.trellis">print.trellis</a></code>).  Used to retrieve location of current
panel in the overall layout, so that axes can be drawn
appropriately.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are part of a new API introduced in lattice 0.14 to
provide the user more control over how axis annotation is done.  While
the API has been designed in anticipation of use that was previously
unsupported, the implementation has initially focused on reproducing
existing capabilities, rather than test new features.  At the time of
writing, several features are unimplemented.  If you require them,
please contact the maintainer.
</p>


<h3>Value</h3>

<p><code>xscale.components.default</code> and <code>yscale.components.default</code>
return a list of the form suitable as the <code>components</code> argument
of <code>axis.default</code>.  Valid components in the return value of
<code>xscale.components.default</code> are:
</p>

<dl>
<dt><code>num.limit</code></dt><dd><p> A numeric limit for the box. </p>
</dd>
<dt><code>bottom</code></dt><dd><p> A list with two elements, <code>ticks</code> and
<code>labels</code>.  <code>ticks</code> must be a list with components
<code>at</code> and <code>tck</code> which give the location and lengths of tick
marks.  <code>tck</code> can be a vector, and will be recycled to be as
long as <code>at</code>.  <code>labels</code> must be a list with components
<code>at</code>, <code>labels</code>, and <code>check.overlap</code>.  <code>at</code> and
<code>labels</code> give the location and labels of the tick labels; this
is usually the same as the location of the ticks, but is not
required to be so.  <code>check.overlap</code> is a logical flag
indicating whether overlapping of labels should be avoided by
omitting some of the labels while rendering.  </p>
</dd>
<dt><code>top</code></dt><dd><p> This can be a logical flag; if <code>TRUE</code>,
<code>top</code> is treated as being the same as <code>bottom</code>; if
<code>FALSE</code>, axis annotation for the top axis is omitted.
Alternatively, <code>top</code> can be a list like <code>bottom</code>.
</p>
</dd>
</dl>

<p>Valid components in the return value of
<code>yscale.components.default</code> are <code>left</code> and <code>right</code>.
Their interpretations are analogous to (respectively) the
<code>bottom</code> and <code>top</code> components described above.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Lattice">Lattice</a></code>,
<code><a href="#topic+xyplot">xyplot</a></code>, 
<code><a href="#topic+print.trellis">print.trellis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
str(xscale.components.default(c(0, 1)))

set.seed(36872)
rln &lt;- rlnorm(100)

densityplot(rln, 
            scales = list(x = list(log = 2), alternating = 3),
            xlab = "Simulated lognormal variates",
            xscale.components = function(...) {
                ans &lt;- xscale.components.default(...)
                ans$top &lt;- ans$bottom
                ans$bottom$labels$labels &lt;- parse(text = ans$bottom$labels$labels)
                ans$top$labels$labels &lt;-
                    if (require(MASS))
                        fractions(2^(ans$top$labels$at))
                    else
                        2^(ans$top$labels$at)
                ans
            })


## Direct use of axis to show two temperature scales (Celcius and
## Fahrenheit).  This does not work for multi-row plots, and doesn't
## do automatic allocation of space


F2C &lt;- function(f) 5 * (f - 32) / 9 
C2F &lt;- function(c) 32 + 9 * c / 5 

axis.CF &lt;-
    function(side, ...) 
{
    ylim &lt;- current.panel.limits()$ylim
    switch(side,
           left = {
               prettyF &lt;- pretty(ylim)
               labF &lt;- parse(text = sprintf("%s ~ degree * F", prettyF))
               panel.axis(side = side, outside = TRUE,
                          at = prettyF, labels = labF)
           },
           right = {
               prettyC &lt;- pretty(F2C(ylim))
               labC &lt;- parse(text = sprintf("%s ~ degree * C", prettyC))
               panel.axis(side = side, outside = TRUE,
                          at = C2F(prettyC), labels = labC)
           },
           axis.default(side = side, ...))
}

xyplot(nhtemp ~ time(nhtemp), aspect = "xy", type = "o",
       scales = list(y = list(alternating = 3)),
       axis = axis.CF, xlab = "Year", ylab = "Temperature", 
       main = "Yearly temperature in New Haven, CT")

## version using yscale.components

yscale.components.CF &lt;-
    function(...)
{
    ans &lt;- yscale.components.default(...)
    ans$right &lt;- ans$left
    ans$left$labels$labels &lt;-
        parse(text = sprintf("%s ~ degree * F", ans$left$labels$at))
    prettyC &lt;- pretty(F2C(ans$num.limit))
    ans$right$ticks$at &lt;- C2F(prettyC)
    ans$right$labels$at &lt;- C2F(prettyC)
    ans$right$labels$labels &lt;-
        parse(text = sprintf("%s ~ degree * C", prettyC))
    ans
}
      

xyplot(nhtemp ~ time(nhtemp), aspect = "xy", type = "o",
       scales = list(y = list(alternating = 3)),
       yscale.components = yscale.components.CF,
       xlab = "Year", ylab = "Temperature", 
       main = "Yearly temperature in New Haven, CT")


</code></pre>

<hr>
<h2 id='G_banking'>Banking</h2><span id='topic+banking'></span>

<h3>Description</h3>

<p>Calculates banking slope
</p>


<h3>Usage</h3>

<pre><code class='language-R'>banking(dx, dy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="G_banking_+3A_dx">dx</code>, <code id="G_banking_+3A_dy">dy</code></td>
<td>
<p> vector of consecutive x, y differences. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>banking</code> is the banking function used when
<code>aspect = "xy"</code> in high level Trellis functions. It is usually not
very meaningful except with <code>xyplot</code>.  It considers the
absolute slopes (based on <code>dx</code> and <code>dy</code>) and returns a value
which when adjusted by the panel scale limits will make the median of
the above absolute slopes correspond to a 45 degree line.
</p>
<p>This function was inspired by the discussion of banking in the
documentation for Trellis Graphics available at Bell Labs' website
(see <code><a href="#topic+Lattice">Lattice</a></code>), but is most likely identical to an
algorithm described by Cleveland et al (see below).  It is
not clear (to the author) whether this is the algorithm used in
S-PLUS.  Alternative banking rules, implemented as a similar function,
can be used as a drop-in replacement by suitably modifying
<code>lattice.options("banking")</code>.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>References</h3>

<p>Cleveland, William S. and McGill, Marylyn E. and McGill, Robert (1988)
&ldquo;The Shape Parameter of a Two-variable Graph&rdquo;, <em>Journal of
the American Statistical Association</em>, <b>83</b>, 289&ndash;300.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lattice">Lattice</a></code>, <code><a href="#topic+xyplot">xyplot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## with and without banking

plot &lt;- xyplot(sunspot.year ~ 1700:1988, xlab = "", type = "l",
               scales = list(x = list(alternating = 2)),
               main = "Yearly Sunspots")
print(plot, position = c(0, .3, 1, .9), more = TRUE)
print(update(plot, aspect = "xy", main = "", xlab = "Year"),
      position = c(0, 0, 1, .3))

## cut-and-stack plot (see also xyplot.ts)

xyplot(sunspot.year ~ time(sunspot.year) | equal.count(time(sunspot.year)), 
       xlab = "", type = "l", aspect = "xy", strip = FALSE,
       scales = list(x = list(alternating = 2, relation = "sliced")),
       as.table = TRUE, main = "Yearly Sunspots")

</code></pre>

<hr>
<h2 id='G_latticeParseFormula'>Parse Trellis formula</h2><span id='topic+latticeParseFormula'></span>

<h3>Description</h3>

<p>this function is used by high level Lattice functions like
<code>xyplot</code> to parse the formula argument and evaluate various
components of the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latticeParseFormula(model, data, dimension = 2,
                    subset = TRUE, groups = NULL,
                    multiple, outer,
                    subscripts,
                    drop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="G_latticeParseFormula_+3A_model">model</code></td>
<td>

<p>the model/formula to be parsed.  This can be in either of two
possible forms, one for 2d and one for 3d formulas, determined by
the <code>dimension</code> argument. The 2d formulas are of the form
<code>y ~ x| g1 * ... *gn</code>, and the 3d formulas are of the form
<code>z ~ x * y | g1 * ...* gn</code>. In the first form, <code>y</code> may
be omitted. The conditioning variables <code>g1, ...,gn</code> can be
omitted in either case.
</p>
</td></tr>
<tr><td><code id="G_latticeParseFormula_+3A_data">data</code></td>
<td>
<p> the environment/dataset where the variables in the 
formula are evaluated.
</p>
</td></tr>
<tr><td><code id="G_latticeParseFormula_+3A_dimension">dimension</code></td>
<td>
<p> dimension of the model, see above</p>
</td></tr>
<tr><td><code id="G_latticeParseFormula_+3A_subset">subset</code></td>
<td>
<p> index for choosing a subset of the data frame </p>
</td></tr>
<tr><td><code id="G_latticeParseFormula_+3A_groups">groups</code></td>
<td>
<p> the grouping variable, if present</p>
</td></tr>
<tr><td><code id="G_latticeParseFormula_+3A_multiple">multiple</code>, <code id="G_latticeParseFormula_+3A_outer">outer</code></td>
<td>

<p>logicals, determining how a &lsquo;+&rsquo; in the y and x components of
the formula are processed. See <code><a href="#topic+xyplot">xyplot</a></code> for details
</p>
</td></tr>
<tr><td><code id="G_latticeParseFormula_+3A_subscripts">subscripts</code></td>
<td>
<p> logical, whether subscripts are to be calculated </p>
</td></tr>
<tr><td><code id="G_latticeParseFormula_+3A_drop">drop</code></td>
<td>

<p>logical or list, similar to the <code>drop.unused.levels</code> argument
in <code><a href="#topic+xyplot">xyplot</a></code>, indicating whether unused levels of
conditioning factors and data variables that are factors are to be
dropped.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p> returns a list with several components, including <code>left,
    right, left.name, right.name, condition</code> for 2-D, and <code>left,
    right.x, right.y, left.name, right.x.name, right.y.name, condition</code>
for 3-D. Other possible components are groups, subscr
</p>


<h3>Author(s)</h3>

<p>Saikat DebRoy, Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+xyplot">xyplot</a></code>, <code><a href="#topic+Lattice">Lattice</a></code>
</p>

<hr>
<h2 id='G_packet.panel.default'>Associating Packets with Panels</h2><span id='topic+packet.panel.default'></span>

<h3>Description</h3>

<p>When a <code>"trellis"</code> object is plotted, panels are always drawn in
an order such that columns vary the fastest, then rows and then pages.
An optional function can be specified that determines, given the
column, row and page and other relevant information, the packet (if
any) which should be used in that panel.  The function documented here
implements the default behaviour, which is to match panel order with
packet order, determined by varying the first conditioning variable
the fastest, then the second, and so on.  This matching is performed
after any reordering and/or permutation of the conditioning variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
packet.panel.default(layout, condlevels, page, row, column,
                     skip, all.pages.skip = TRUE) 

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="G_packet.panel.default_+3A_layout">layout</code></td>
<td>
<p> the <code>layout</code> argument in high level functions,
suitably standardized.  </p>
</td></tr>
<tr><td><code id="G_packet.panel.default_+3A_condlevels">condlevels</code></td>
<td>
<p> a list of levels of conditioning variables, after
relevant permutations and/or reordering of levels </p>
</td></tr>
<tr><td><code id="G_packet.panel.default_+3A_page">page</code>, <code id="G_packet.panel.default_+3A_row">row</code>, <code id="G_packet.panel.default_+3A_column">column</code></td>
<td>
<p> the location of the panel in the coordinate
system of pages, rows and columns.  </p>
</td></tr>
<tr><td><code id="G_packet.panel.default_+3A_skip">skip</code></td>
<td>
<p> the <code>skip</code> argument in high level functions </p>
</td></tr>
<tr><td><code id="G_packet.panel.default_+3A_all.pages.skip">all.pages.skip</code></td>
<td>
<p> whether <code>skip</code> should be replicated over
all pages.  If <code>FALSE</code>, <code>skip</code> will be replicated to be
only as long as the number of positions on a page, and that
template will be used for all pages. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A suitable combination of levels of the conditioning variables in the
form of a numeric vector as long as the number of conditioning
variables, with each element an integer indexing the levels of the
corresponding variable.  Specifically, if the return value is
<code>p</code>, then the <code>i</code>-th conditioning variable will have level
<code>condlevels[[i]][p[i]]</code>.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>See Also</h3>

 <p><code><a href="#topic+Lattice">Lattice</a></code>, <code><a href="#topic+xyplot">xyplot</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
packet.panel.page &lt;- function(n)
{
    ## returns a function that when used as the 'packet.panel'
    ## argument in print.trellis plots page number 'n' only
    function(layout, page, ...) {
        stopifnot(layout[3] == 1)
        packet.panel.default(layout = layout, page = n, ...)
    }
}

data(mtcars)
HP &lt;- equal.count(mtcars$hp, 6)
p &lt;- 
    xyplot(mpg ~ disp | HP * factor(cyl),
           mtcars, layout = c(0, 6, 1))

print(p, packet.panel = packet.panel.page(1))
print(p, packet.panel = packet.panel.page(2))

</code></pre>

<hr>
<h2 id='G_panel.axis'>Panel Function for Drawing Axis Ticks and Labels</h2><span id='topic+panel.axis'></span><span id='topic+current.panel.limits'></span>

<h3>Description</h3>

<p><code>panel.axis</code> is the function used by lattice to draw axes. It is
typically not used by users, except those wishing to create advanced
annotation. Keep in mind issues of clipping when trying to use it as
part of the panel function. <code>current.panel.limits</code> can be used to
retrieve a panel's x and y limits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.axis(side = c("bottom", "left", "top", "right"),
           at,
           labels = TRUE,
           draw.labels = TRUE,
           check.overlap = FALSE,
           outside = FALSE,
           ticks = TRUE,
           half = !outside,
           which.half,
           tck = as.numeric(ticks),
           rot = if (is.logical(labels)) 0 else c(90, 0),
           text.col, text.alpha, text.cex, text.font,
           text.fontfamily, text.fontface, text.lineheight,
           line.col, line.lty, line.lwd, line.alpha)

current.panel.limits(unit = "native")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="G_panel.axis_+3A_side">side</code></td>
<td>

<p>A character string indicating which side axes are to be drawn
on. Partial specification is allowed.
</p>
</td></tr>
<tr><td><code id="G_panel.axis_+3A_at">at</code></td>
<td>

<p>Numeric vector giving location of labels. Can be missing, in which
case they are computed from the native coordinates of the active
viewport.
</p>
</td></tr>
<tr><td><code id="G_panel.axis_+3A_labels">labels</code></td>
<td>

<p>The labels to go along with <code>at</code>, as a character vector or a
vector of expressions. This only makes sense provided <code>at</code> is
explicitly specified, as otherwise the provided labels may not match
the computed <code>at</code> values. Alternatively, <code>labels</code> can be a
logical flag: If <code>TRUE</code>, the labels are derived from <code>at</code>,
otherwise, labels are empty.
</p>
</td></tr>
<tr><td><code id="G_panel.axis_+3A_draw.labels">draw.labels</code></td>
<td>

<p>A logical indicating whether labels are to be drawn.
</p>
</td></tr>
<tr><td><code id="G_panel.axis_+3A_check.overlap">check.overlap</code></td>
<td>

<p>A logical, whether to check for overlapping of labels.  This also has
the effect of removing <code>at</code> values that are &lsquo;too close&rsquo;
to the limits.
</p>
</td></tr>
<tr><td><code id="G_panel.axis_+3A_outside">outside</code></td>
<td>

<p>A logical flag, indicating whether to draw the labels outside the
panel or inside. Note that <code>outside=TRUE</code> will only have a visible
effect if clipping is disabled for the viewport (panel).
</p>
</td></tr>
<tr><td><code id="G_panel.axis_+3A_ticks">ticks</code></td>
<td>
<p> Logical flag, whether to draw the tickmarks. </p>
</td></tr>
<tr><td><code id="G_panel.axis_+3A_half">half</code></td>
<td>

<p>Logical flag, indicating whether only around half the scales will be
drawn for each side.  This is primarily used for axis labeling in
<code><a href="#topic+splom">splom</a></code>. 
</p>
</td></tr>
<tr><td><code id="G_panel.axis_+3A_which.half">which.half</code></td>
<td>

<p>Character string, either <code>"lower"</code> or <code>"upper"</code>,
indicating which half is to be used for tick locations if <code>half
    = TRUE</code>.  Defaults to whichever is suitable for <code><a href="#topic+splom">splom</a></code>.
</p>
</td></tr>
<tr><td><code id="G_panel.axis_+3A_tck">tck</code></td>
<td>

<p>A numeric scalar multiplier for tick length.  Can be negative, in
which case the ticks point inwards. 
</p>
</td></tr>
<tr><td><code id="G_panel.axis_+3A_rot">rot</code></td>
<td>

<p>Rotation angle(s) for labels in degrees. Can be a vector of length 2
for x- and y-axes.
</p>
</td></tr>
<tr><td><code id="G_panel.axis_+3A_text.col">text.col</code></td>
<td>

<p>Color for the axis label text.  See <code><a href="grid.html#topic+gpar">gpar</a></code> for
more details on this and the other graphical parameters listed
below.
</p>
</td></tr>
<tr><td><code id="G_panel.axis_+3A_text.alpha">text.alpha</code></td>
<td>
<p> Alpha-transparency value for the axis label text. </p>
</td></tr>
<tr><td><code id="G_panel.axis_+3A_text.cex">text.cex</code></td>
<td>
<p> Size multiplier for the axis label text. </p>
</td></tr>
<tr><td><code id="G_panel.axis_+3A_text.font">text.font</code>, <code id="G_panel.axis_+3A_text.fontfamily">text.fontfamily</code>, <code id="G_panel.axis_+3A_text.fontface">text.fontface</code></td>
<td>
<p> Font for the axis label text. </p>
</td></tr>
<tr><td><code id="G_panel.axis_+3A_text.lineheight">text.lineheight</code></td>
<td>
<p> Line height for the axis label text. </p>
</td></tr>
<tr><td><code id="G_panel.axis_+3A_line.col">line.col</code></td>
<td>
<p> Color for the axis label text. </p>
</td></tr>
<tr><td><code id="G_panel.axis_+3A_line.lty">line.lty</code></td>
<td>
<p> Color for the axis. </p>
</td></tr>
<tr><td><code id="G_panel.axis_+3A_line.lwd">line.lwd</code></td>
<td>
<p> Color for the axis. </p>
</td></tr>
<tr><td><code id="G_panel.axis_+3A_line.alpha">line.alpha</code></td>
<td>
<p> Alpha-transparency value for the axis. </p>
</td></tr>
<tr><td><code id="G_panel.axis_+3A_unit">unit</code></td>
<td>
<p> Which grid <code><a href="grid.html#topic+unit">unit</a></code> the values
should be in. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>panel.axis</code> can draw axis tick marks inside or outside a
panel (more precisely, a grid viewport). It honours the (native) axis
scales. Used in <code><a href="#topic+panel.pairs">panel.pairs</a></code> for <code><a href="#topic+splom">splom</a></code>, as
well as for all the usual axis drawing by the print method for
<code>"trellis"</code> objects. It can also be used to enhance plots
&lsquo;after the fact&rsquo; by adding axes.
</p>


<h3>Value</h3>

<p><code>current.panel.limits</code> returns a list with components <code>xlim</code>
and <code>ylim</code>, which are both numeric vectors of length 2, giving
the scales of the current panel (viewport).  The values correspond to
the unit system specified by <code><a href="grid.html#topic+unit">unit</a></code>, by default
<code>"native"</code>.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Lattice">Lattice</a></code>, <code><a href="#topic+xyplot">xyplot</a></code>,
<code><a href="#topic+trellis.focus">trellis.focus</a></code>, <code><a href="grid.html#topic+unit">unit</a></code>
</p>

<hr>
<h2 id='G_panel.number'>Accessing Auxiliary Information During Plotting</h2><span id='topic+current.row'></span><span id='topic+current.column'></span><span id='topic+packet.number'></span><span id='topic+panel.number'></span><span id='topic+which.packet'></span><span id='topic+trellis.currentLayout'></span>

<h3>Description</h3>

<p>Control over lattice plots are provided through a collection of user
specifiable functions that perform various tasks during the plotting.
Not all information is available to all functions.  The functions
documented here attempt to provide a consistent interface to access
relevant information from within these user specified functions,
namely those specified as the <code>panel</code>, <code>strip</code> and
<code>axis</code> functions.  Note that this information is not available to
the <code>prepanel</code> function, which is executed prior to the actual
plotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
current.row(prefix)
current.column(prefix)
panel.number(prefix)
packet.number(prefix)
which.packet(prefix)

trellis.currentLayout(which = c("packet", "panel"), prefix)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="G_panel.number_+3A_which">which</code></td>
<td>

<p>whether return value (a matrix) should contain panel numbers or
packet numbers, which are usually, but not necessarily, the same
(see below for details).
</p>
</td></tr>
<tr><td><code id="G_panel.number_+3A_prefix">prefix</code></td>
<td>

<p>A character string acting as a prefix identifying the plot of a
<code>"trellis"</code> object.  Only relevant when a particular page is
occupied by more than one plot.  Defaults to the value appropriate
for the last <code>"trellis"</code> object printed.  See
<code><a href="#topic+trellis.focus">trellis.focus</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>trellis.currentLayout</code> returns a matrix with as many rows and
columns as in the layout of panels in the current plot.  Entries in
the matrix are integer indices indicating which packet (or panel; see
below) occupies that position, with 0 indicating the absence of a
panel.  <code>current.row</code> and <code>current.column</code> return integer
indices specifying which row and column in the layout are currently
active.  <code>panel.number</code> returns an integer counting which panel
is being drawn (starting from 1 for the first panel, a.k.a. the panel
order).  <code>packet.number</code> gives the packet number according to the
packet order, which is determined by varying the first conditioning
variable the fastest, then the second, and so on.  <code>which.packet</code>
returns the combination of levels of the conditioning variables in the
form of a numeric vector as long as the number of conditioning
variables, with each element an integer indexing the levels of the
corresponding variable.
</p>


<h3>Note</h3>

<p>The availability of these functions make redundant some features
available in earlier versions of lattice, namely optional arguments
called <code>panel.number</code> and <code>packet.number</code> that were made
available to <code>panel</code> and <code>strip</code>.  If you have written such
functions, it should be enough to replace instances of
<code>panel.number</code> and <code>packet.number</code> by the corresponding
function calls.  You should also remove <code>panel.number</code> and
<code>packet.number</code> from the argument list of your function to avoid
a warning.
</p>
<p>If these accessor functions are not enough for your needs, feel free
to contact the maintainer and ask for more.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Lattice">Lattice</a></code>, <code><a href="#topic+xyplot">xyplot</a></code>
</p>

<hr>
<h2 id='G_Rows'>Extract rows from a list</h2><span id='topic+Rows'></span>

<h3>Description</h3>

<p>Convenience function to extract subset of a list. Usually used in
creating keys.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rows(x, which)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="G_Rows_+3A_x">x</code></td>
<td>
<p> list with each member a vector of the same length </p>
</td></tr>
<tr><td><code id="G_Rows_+3A_which">which</code></td>
<td>
<p> index for members of <code>x</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list similar to <code>x</code>, with each <code>x[[i]]</code> replaced by
<code>x[[i]][which]</code>
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+xyplot">xyplot</a></code>, <code><a href="#topic+Lattice">Lattice</a></code></p>

<hr>
<h2 id='G_utilities.3d'> Utility functions for 3-D plots </h2><span id='topic+utilities.3d'></span><span id='topic+palette.shade'></span><span id='topic+ltransform3dMatrix'></span><span id='topic+ltransform3dto3d'></span>

<h3>Description</h3>

<p>These are (related to) the default panel functions for <code>cloud</code>
and <code>wireframe</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ltransform3dMatrix(screen, R.mat)
ltransform3dto3d(x, R.mat, dist)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="G_utilities.3d_+3A_x">x</code></td>
<td>

<p><code>x</code> can be a numeric matrix with 3 rows for
<code>ltransform3dto3d</code>
</p>
</td></tr>
<tr><td><code id="G_utilities.3d_+3A_screen">screen</code></td>
<td>
<p>list, as described in <code><a href="#topic+panel.cloud">panel.cloud</a></code></p>
</td></tr>
<tr><td><code id="G_utilities.3d_+3A_r.mat">R.mat</code></td>
<td>
<p>4x4 transformation matrix in homogeneous
coordinates</p>
</td></tr>
<tr><td><code id="G_utilities.3d_+3A_dist">dist</code></td>
<td>
<p>controls transformation to account for
perspective viewing</p>
</td></tr>










</table>


<h3>Details</h3>

<p><code>ltransform3dMatrix</code> and <code>ltransform3dto3d</code> are utility
functions to help in computation of projections. These functions are
used inside the panel functions for <code>cloud</code> and
<code>wireframe</code>. They may be useful in user-defined panel functions
as well.
</p>
<p>The first function takes a list of the form of the <code>screen</code>
argument in <code>cloud</code> and <code>wireframe</code> and a <code>R.mat</code>, a
4x4 transformation matrix in homogeneous coordinates, to return a new
4x4 transformation matrix that is the result of applying <code>R.mat</code>
followed by the rotations in <code>screen</code>. The second function
applies a 4x4 transformation matrix in homogeneous coordinates to a
3xn matrix representing points in 3-D space, and optionally does some
perspective computations. (There has been no testing with non-trivial
transformation matrices, and my knowledge of the homogeneous
coordinate system is very limited, so there may be bugs here.)
</p>











<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+cloud">cloud</a></code>, <code><a href="#topic+panel.cloud">panel.cloud</a></code></p>

<hr>
<h2 id='H_barley'> Yield data from a Minnesota barley trial </h2><span id='topic+barley'></span>

<h3>Description</h3>

<p>Total yield in bushels per acre for 10 varieties at 6 sites in each of
two years.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>barley</code></pre>


<h3>Format</h3>

<p>A data frame with 120 observations on the following 4 variables.
</p>

<dl>
<dt>yield</dt><dd><p>Yield (averaged across three blocks) in bushels/acre.</p>
</dd>
<dt>variety</dt><dd><p>Factor with levels <code>"Svansota"</code>, <code>"No. 462"</code>,
<code>"Manchuria"</code>, <code>"No. 475"</code>, <code>"Velvet"</code>,
<code>"Peatland"</code>, <code>"Glabron"</code>, <code>"No. 457"</code>,
<code>"Wisconsin No. 38"</code>, <code>"Trebi"</code>.</p>
</dd>
<dt>year</dt><dd><p>Factor with levels <code>1932</code>, <code>1931</code></p>
</dd>
<dt>site</dt><dd><p>Factor with 6 levels:  <code>"Grand Rapids"</code>,
<code>"Duluth"</code>, <code>"University Farm"</code>, <code>"Morris"</code>,
<code>"Crookston"</code>, <code>"Waseca"</code></p>
</dd>
</dl>



<h3>Details</h3>

<p>These data are yields in bushels per acre, of 10 varieties of barley
grown in 1/40 acre plots at University Farm, St. Paul, and at the five
branch experiment stations located at Waseca, Morris, Crookston, Grand
Rapids, and Duluth (all in Minnesota).  The varieties were grown in
three randomized blocks at each of the six  stations during 1931 and
1932, different land being used each year of the test.
</p>
<p>Immer et al. (1934) present the data for each Year*Site*Variety*Block.
The data here is the average yield across the three blocks.
</p>
<p>Immer et al. (1934) refer (once) to the experiment as being conducted
in 1930 and 1931, then later refer to it (repeatedly) as being
conducted in 1931 and 1932.  Later authors have continued the
confusion.
</p>
<p>Cleveland (1993) suggests that the data for the Morris site may have
had the years switched.
</p>


<h3>Author(s)</h3>

<p>Documentation contributed by Kevin Wright.
</p>


<h3>Source</h3>

<p>Immer, R. F., H. K. Hayes, and LeRoy Powers. (1934).  Statistical
Determination of Barley Varietal Adaptation.  <em>Journal of the
American Society of Agronomy</em>, <b>26</b>, 403&ndash;419.
</p>
<p>Wright, Kevin (2013). Revisiting Immer's Barley Data. <em>The
American Statistician</em>, <b>67(3)</b>, 129&ndash;133.
</p>


<h3>References</h3>

<p>Cleveland, William S. (1993) <em>Visualizing Data</em>.  Hobart Press,
Summit, New Jersey.
</p>
<p>Fisher, R. A. (1971) <em>The Design of Experiments</em>.  Hafner, New
York, 9th edition.
</p>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+immer">immer</a></code> in the MASS package for data from the
same experiment 
(expressed as total yield for 3 blocks) for a subset of varieties.</p>


<h3>Examples</h3>

<pre><code class='language-R'># Graphic suggesting the Morris data switched the years 1931 and 1932
# Figure 1.1 from Cleveland
dotplot(variety ~ yield | site, data = barley, groups = year,
        key = simpleKey(levels(barley$year), space = "right"),
        xlab = "Barley Yield (bushels/acre) ",
        aspect=0.5, layout = c(1,6), ylab=NULL)
</code></pre>

<hr>
<h2 id='H_environmental'> Atmospheric environmental conditions in New York City </h2><span id='topic+environmental'></span>

<h3>Description</h3>

<p>Daily measurements of ozone concentration, wind speed, temperature and
solar radiation in New York City from May to September of 1973.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>environmental</code></pre>


<h3>Format</h3>

<p>A data frame with 111 observations on the following 4 variables.
</p>

<dl>
<dt>ozone</dt><dd><p>Average ozone concentration (of hourly measurements) of
in parts per billion.</p>
</dd>
<dt>radiation</dt><dd><p>Solar radiation (from 08:00 to 12:00) in langleys.</p>
</dd>
<dt>temperature</dt><dd><p>Maximum daily emperature in degrees Fahrenheit.</p>
</dd>
<dt>wind</dt><dd><p>Average wind speed (at 07:00 and 10:00) in miles per hour.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Documentation contributed by Kevin Wright.
</p>


<h3>Source</h3>

<p>Bruntz, S. M., W. S. Cleveland, B. Kleiner, and J. L. Warner.  (1974).
The Dependence of Ambient Ozone on Solar Radiation, Wind, Temperature,
and Mixing Height.  In <em>Symposium on Atmospheric Diffusion and
Air Pollution</em>, pages 125&ndash;128.  American Meterological Society,
Boston.
</p>


<h3>References</h3>

<p>Cleveland, William S. (1993) <em>Visualizing Data</em>.  Hobart Press,
Summit, New Jersey.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Scatter plot matrix with loess lines
splom(~environmental,
  panel=function(x,y){
    panel.xyplot(x,y)
    panel.loess(x,y)
  }
)


# Conditioned plot similar to figure 5.3 from Cleveland
attach(environmental)
Temperature &lt;- equal.count(temperature, 4, 1/2)
Wind &lt;- equal.count(wind, 4, 1/2)
xyplot((ozone^(1/3)) ~ radiation | Temperature * Wind,
  aspect=1,
	prepanel = function(x, y) 
		prepanel.loess(x, y, span = 1),
	panel = function(x, y){
		panel.grid(h = 2, v = 2)
		panel.xyplot(x, y, cex = .5)
		panel.loess(x, y, span = 1)
	},
	xlab = "Solar radiation (langleys)",
	ylab = "Ozone (cube root ppb)")
detach()

# Similar display using the coplot function
with(environmental,{
  coplot((ozone^.33) ~ radiation | temperature * wind,
  number=c(4,4),
  panel = function(x, y, ...) panel.smooth(x, y, span = .8, ...),
  xlab="Solar radiation (langleys)",
  ylab="Ozone (cube root ppb)")
})
</code></pre>

<hr>
<h2 id='H_ethanol'> Engine exhaust fumes from burning ethanol </h2><span id='topic+ethanol'></span>

<h3>Description</h3>

<p>Ethanol fuel was burned in a single-cylinder engine.  For various
settings of the engine compression and equivalence ratio, the
emissions of nitrogen oxides were recorded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ethanol</code></pre>


<h3>Format</h3>

<p>A data frame with 88 observations on the following 3 variables.
</p>

<dl>
<dt>NOx</dt><dd><p>Concentration of nitrogen oxides (NO and NO2) in
micrograms/J.</p>
</dd>
<dt>C</dt><dd><p>Compression ratio of the engine.</p>
</dd>
<dt>E</dt><dd><p>Equivalence ratio&ndash;a measure of the richness of the air and
ethanol fuel mixture.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Documentation contributed by Kevin Wright.
</p>


<h3>Source</h3>

<p>Brinkman, N.D. (1981) Ethanol Fuel&mdash;A Single-Cylinder Engine Study of
Efficiency and Exhaust Emissions. <em>SAE transactions</em>,
<b>90</b>, 1410&ndash;1424.
</p>


<h3>References</h3>

<p>Cleveland, William S. (1993) <em>Visualizing Data</em>.  Hobart Press,
Summit, New Jersey.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Constructing panel functions on the fly
EE &lt;- equal.count(ethanol$E, number=9, overlap=1/4)
xyplot(NOx ~ C | EE, data = ethanol,
       prepanel = function(x, y) prepanel.loess(x, y, span = 1),
       xlab = "Compression ratio", ylab = "NOx (micrograms/J)",
       panel = function(x, y) {
           panel.grid(h=-1, v= 2)
           panel.xyplot(x, y, grid = FALSE)
           panel.loess(x, y, span = 1)
       },
       aspect = "xy")

# Wireframe loess surface fit.  See Figure 4.61 from Cleveland.
require(stats)
with(ethanol, {
  eth.lo &lt;- loess(NOx ~ C * E, span = 1/3, parametric = "C", 
                  drop.square = "C", family="symmetric")
  eth.marginal &lt;- list(C = seq(min(C), max(C), length.out = 25), 
                       E = seq(min(E), max(E), length.out = 25))
  eth.grid &lt;- expand.grid(eth.marginal)
  eth.fit &lt;- predict(eth.lo, eth.grid)
  wireframe(eth.fit ~ eth.grid$C * eth.grid$E,
            shade=TRUE,
	    screen = list(z = 40, x = -60, y=0),
	    distance = .1,
	    xlab = "C", ylab = "E", zlab = "NOx")
})
</code></pre>

<hr>
<h2 id='H_melanoma'> Melanoma skin cancer incidence </h2><span id='topic+melanoma'></span>

<h3>Description</h3>

<p>These data from the Connecticut Tumor Registry present
age-adjusted numbers of melanoma skin-cancer incidences per
100,000 people in Connectict for the years from 1936 to 1972.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>melanoma</code></pre>


<h3>Format</h3>

<p>A data frame with 37 observations on the following 2 variables.
</p>

<dl>
<dt>year</dt><dd><p>Years 1936 to 1972.</p>
</dd>
<dt>incidence</dt><dd><p>Rate of melanoma cancer per 100,000 population.</p>
</dd>
</dl>



<h3>Note</h3>

<p>This dataset is not related to the <code><a href="boot.html#topic+melanoma">melanoma</a></code>
dataset in the <b>boot</b> package with the same name.
</p>
<p>The S-PLUS 6.2 help for the melanoma data says that the incidence rate is
per <em>million</em>, but this is not consistent with data found at the
National Cancer Institute (<a href="https://www.cancer.gov/">https://www.cancer.gov/</a>).
</p>


<h3>Author(s)</h3>

<p>Documentation contributed by Kevin Wright.
</p>


<h3>Source</h3>

<p>Houghton, A., E. W. Munster, and M. V. Viola.  (1978).  Increased
Incidence of Malignant Melanoma After Peaks of Sunspot Activity.
<em>The Lancet</em>, <b>8</b>, 759&ndash;760.
</p>


<h3>References</h3>

<p>Cleveland, William S. (1993) <em>Visualizing Data</em>.  Hobart Press,
Summit, New Jersey.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Time-series plot.  Figure 3.64 from Cleveland.
xyplot(incidence ~ year,
  data = melanoma,
	aspect = "xy",
	panel = function(x, y)
		panel.xyplot(x, y, type="o", pch = 16),
	ylim = c(0, 6),
	xlab = "Year",
	ylab = "Incidence")
</code></pre>

<hr>
<h2 id='H_singer'> Heights of New York Choral Society singers </h2><span id='topic+singer'></span>

<h3>Description</h3>

<p>Heights in inches of the singers in the New York Choral Society in
1979.  The data are grouped according to voice part.  The vocal range
for each voice part increases in pitch according to the following
order: Bass 2, Bass 1, Tenor 2, Tenor 1, Alto 2, Alto 1, Soprano 2,
Soprano 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>singer</code></pre>


<h3>Format</h3>

<p>A data frame with 235 observations on the following 2 variables.
</p>

<dl>
<dt>height</dt><dd><p>Height in inches of the singers.</p>
</dd>
<dt>voice.part</dt><dd><p>(Unordered) factor with levels &quot;<code>Bass 2</code>&quot;,
&quot;<code>Bass 1</code>&quot;, &quot;<code>Tenor 2</code>&quot;, &quot;<code>Tenor 1</code>&quot;, &quot;<code>Alto 2</code>&quot;,
&quot;<code>Alto 1</code>&quot;, &quot;<code>Soprano 2</code>&quot;, &quot;<code>Soprano 1</code>&quot;.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Documentation contributed by Kevin Wright.
</p>


<h3>Source</h3>

<p>Chambers, J.M., W. S. Cleveland, B. Kleiner, and P. A. Tukey. (1983).
<em>Graphical Methods for Data Analysis</em>.  Chapman and Hall, New York.
</p>


<h3>References</h3>

<p>Cleveland, William S. (1993) <em>Visualizing Data</em>.  Hobart Press,
Summit, New Jersey.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Separate histogram for each voice part (Figure 1.2 from Cleveland)
histogram(~ height | voice.part,
          data = singer,
          aspect = 1,
          layout = c(2, 4), 
          nint = 15,
          xlab = "Height (inches)")

# Quantile-Quantile plot (Figure 2.11 from Cleveland)
qqmath(~ height | voice.part,
       data = singer,
       aspect = 1, 
       layout = c(2,4),
       prepanel = prepanel.qqmathline,
       panel = function(x, ...) {
         panel.grid()
         panel.qqmathline(x, ...)
         panel.qqmath(x, ..., grid = FALSE)
       },
       xlab = "Unit Normal Quantile",
       ylab="Height (inches)")
</code></pre>

<hr>
<h2 id='H_USMortality'> Mortality Rates in US by Cause and Gender </h2><span id='topic+USMortality'></span><span id='topic+USRegionalMortality'></span>

<h3>Description</h3>

<p>These datasets record mortality rates across all ages in the USA by
cause of death, sex, and rural/urban status, 2011&ndash;2013. The two
datasets represent the national aggregate rates and the region-wise
rates for each administrative region under the Department of Health
and Human Services (HHS).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>USMortality
USRegionalMortality
</code></pre>


<h3>Format</h3>

<p><code>USRegionalMortality</code> is a data frame with 400 observations on
the following 6 variables.
</p>

<dl>
<dt><code>Region</code></dt><dd><p>A factor specifying HHS Region. See details.</p>
</dd>
<dt><code>Status</code></dt><dd><p>A factor with levels <code>Rural</code> and <code>Urban</code></p>
</dd>
<dt><code>Sex</code></dt><dd><p>A factor with levels <code>Female</code> and <code>Male</code></p>
</dd>
<dt><code>Cause</code></dt><dd><p>Cause of death. A factor with levels
<code>Alzheimers</code>, <code>Cancer</code>, <code>Cerebrovascular diseases</code>,
<code>Diabetes</code>, <code>Flu and pneumonia</code>, <code>Heart disease</code>,
<code>Lower respiratory</code>, <code>Nephritis</code>, <code>Suicide</code>, and
<code>Unintentional injuries</code></p>
</dd>
<dt><code>Rate</code></dt><dd><p>Age-adjusted death rate per 100,000 population</p>
</dd>
<dt><code>SE</code></dt><dd><p>Standard error for the rate</p>
</dd>
</dl>

<p><code>USMortality</code> is a data frame with 40 observations, containing
the same variables with the exception of <code>Region</code>.
</p>


<h3>Details</h3>

<p> The region-wise data give estimated rates separately for each
of 10 HHS regions. The location of the regional offices and their
coverage area, available from
<a href="https://www.hhs.gov/about/agencies/iea/regional-offices/index.html">https://www.hhs.gov/about/agencies/iea/regional-offices/index.html</a>,
is given below.
</p>

<dl>
<dt>HHS Region 01 - Boston: </dt><dd><p> Connecticut, Maine, Massachusetts,
New Hampshire, Rhode Island, and Vermont </p>
</dd>
<dt> HHS Region 02 - New York: </dt><dd><p> New Jersey, New York, Puerto
Rico, and the Virgin Islands </p>
</dd>
<dt>HHS Region 03 - Philadelphia: </dt><dd><p> Delaware, District of
Columbia, Maryland, Pennsylvania, Virginia, and West Virginia</p>
</dd>
<dt>HHS Region 04 - Atlanta: </dt><dd><p> Alabama, Florida, Georgia, Kentucky,
Mississippi, North Carolina, South Carolina, and Tennessee</p>
</dd>
<dt>HHS Region 05 - Chicago: </dt><dd><p> Illinois, Indiana, Michigan,
Minnesota, Ohio, and Wisconsin</p>
</dd>
<dt>HHS Region 06 - Dallas: </dt><dd><p> Arkansas, Louisiana, New Mexico,
Oklahoma, and Texas </p>
</dd>
<dt>HHS Region 07 - Kansas City: </dt><dd><p> Iowa, Kansas, Missouri, and
Nebraska</p>
</dd>
<dt>HHS Region 08 - Denver: </dt><dd><p> Colorado, Montana, North Dakota,
South Dakota, Utah, and Wyoming</p>
</dd>
<dt>HHS Region 09 - San Francisco: </dt><dd><p> Arizona, California, Hawaii,
Nevada, American Samoa, Commonwealth of the Northern Mariana
Islands, Federated States of Micronesia, Guam, Marshall Islands,
and Republic of Palau</p>
</dd>
<dt>HHS Region 10 - Seattle: </dt><dd><p> Alaska, Idaho, Oregon, and
Washington</p>
</dd> </dl>
 

<h3>References</h3>

<p>Rural Health Reform Policy Research Center. _Exploring Rural and Urban
Mortality Differences_, August 2015 Bethesda, MD. 
<a href="https://ruralhealth.und.edu/projects/health-reform-policy-research-center/rural-urban-mortality">https://ruralhealth.und.edu/projects/health-reform-policy-research-center/rural-urban-mortality</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dotplot(reorder(Cause, Rate) ~ Rate | Status,
        data = USMortality, groups = Sex, grid = FALSE,
        par.settings = simpleTheme(pch = 16), auto.key = list(columns = 2),
        scales = list(x = list(log = TRUE, equispaced.log = FALSE)))
dotplot(reorder(Cause, Rate):Sex ~ Rate | Status,
        data = USRegionalMortality, groups = Sex, auto.key = FALSE,
        scales = list(x = list(log = TRUE, equispaced.log = FALSE)))
</code></pre>

<hr>
<h2 id='I_lset'>Interface to modify Trellis Settings - Defunct</h2><span id='topic+lset'></span>

<h3>Description</h3>

<p>A (hopefully) simpler alternative to <code>trellis.par.get/set</code>.  This
is deprecated, and the same functionality is now available with
<code>trellis.par.set</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lset(theme = col.whitebg())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="I_lset_+3A_theme">theme</code></td>
<td>
<p> a list decribing how to change the settings of the
current active device. Valid components are those in the list
returned by <code>trellis.par.get()</code>. Each component must itself be
a list, with one or more of the appropriate components (need not
have all components). Changes are made to the settings for the
currently active device only.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a></p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
