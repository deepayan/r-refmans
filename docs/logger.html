<!DOCTYPE html><html><head><title>Help for package logger</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {logger}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25except+25'><p>Try to evaluate an expressions and evaluate another expression on exception</p></a></li>
<li><a href='#appender_async'><p>Delays executing the actual appender function to the future in a background process to avoid blocking the main R session</p></a></li>
<li><a href='#appender_console'><p>Append log record to stderr</p></a></li>
<li><a href='#appender_file'><p>Append log messages to a file</p></a></li>
<li><a href='#appender_kinesis'><p>Send log messages to a Amazon Kinesis stream</p></a></li>
<li><a href='#appender_pushbullet'><p>Send log messages to Pushbullet</p></a></li>
<li><a href='#appender_slack'><p>Send log messages to a Slack channel</p></a></li>
<li><a href='#appender_stdout'><p>Append log record to stdout</p></a></li>
<li><a href='#appender_syslog'><p>Send log messages to the POSIX system log</p></a></li>
<li><a href='#appender_syslognet'><p>Send log messages to a network syslog server</p></a></li>
<li><a href='#appender_tee'><p>Append log messages to a file and stdout as well</p></a></li>
<li><a href='#appender_telegram'><p>Send log messages to a Telegram chat</p></a></li>
<li><a href='#appender_void'><p>Dummy appender not delivering the log record to anywhere</p></a></li>
<li><a href='#as.loglevel'><p>Convert R object into a logger log-level</p></a></li>
<li><a href='#catch_base_log'><p>Catch the log header</p></a></li>
<li><a href='#colorize_by_log_level'><p>Colorize string by the related log level</p></a></li>
<li><a href='#delete_logger_index'><p>Delete an index from a logger namespace</p></a></li>
<li><a href='#deparse_to_one_line'><p>Deparse and join all lines into a single line</p></a></li>
<li><a href='#fail_on_missing_package'><p>Check if R package can be loaded and fails loudly otherwise</p></a></li>
<li><a href='#fallback_namespace'><p>Checks if provided namespace exists and falls back to global if not</p></a></li>
<li><a href='#formatter_glue'><p>Apply <code>glue</code> to convert R objects into a character vector</p></a></li>
<li><a href='#formatter_glue_or_sprintf'><p>Apply <code>glue</code> and <code>sprintf</code></p></a></li>
<li><a href='#formatter_glue_safe'><p>Apply <code>glue_safe</code> to convert R objects into a character vector</p></a></li>
<li><a href='#formatter_json'><p>Transforms all passed R objects into a JSON list</p></a></li>
<li><a href='#formatter_logging'><p>Mimic the default formatter used in the <span class="pkg">logging</span> package</p></a></li>
<li><a href='#formatter_pander'><p>Formats R objects with pander</p></a></li>
<li><a href='#formatter_paste'><p>Concatenate R objects into a character vector via <code>paste</code></p></a></li>
<li><a href='#formatter_sprintf'><p>Apply <code>sprintf</code> to convert R objects into a character vector</p></a></li>
<li><a href='#get_logger_definitions'><p>Find the logger definition(s) specified for the current namespace with a fallback to the global namespace</p></a></li>
<li><a href='#get_logger_meta_variables'><p>Collect useful information about the logging environment to be used in log messages</p></a></li>
<li><a href='#grayscale_by_log_level'><p>Render a string with light/dark gray based on the related log level</p></a></li>
<li><a href='#layout_blank'><p>Format a log record by including the raw message without anything added or modified</p></a></li>
<li><a href='#layout_glue'><p>Format a log message with <code>glue</code></p></a></li>
<li><a href='#layout_glue_colors'><p>Format a log message with <code>glue</code> and ANSI escape codes to add colors</p></a></li>
<li><a href='#layout_glue_generator'><p>Generate log layout function using common variables available via glue syntax</p></a></li>
<li><a href='#layout_json'><p>Generate log layout function rendering JSON</p></a></li>
<li><a href='#layout_json_parser'><p>Generate log layout function rendering JSON after merging meta fields with parsed list from JSON message</p></a></li>
<li><a href='#layout_logging'><p>Format a log record as the logging package does by default</p></a></li>
<li><a href='#layout_simple'><p>Format a log record by concatenating the log level, timestamp and message</p></a></li>
<li><a href='#layout_syslognet'><p>Format a log record for syslognet</p></a></li>
<li><a href='#log_appender'><p>Get or set log record appender function</p></a></li>
<li><a href='#log_config_setter'><p>Base Logging Function</p></a></li>
<li><a href='#log_errors'><p>Injects a logger call to standard errors</p></a></li>
<li><a href='#log_eval'><p>Evaluate an expression and log results</p></a></li>
<li><a href='#log_failure'><p>Logs the error message to console before failing</p></a></li>
<li><a href='#log_formatter'><p>Get or set log message formatter</p></a></li>
<li><a href='#log_layout'><p>Get or set log record layout</p></a></li>
<li><a href='#log_level'><p>Log a message with given log level</p></a></li>
<li><a href='#log_messages'><p>Injects a logger call to standard messages</p></a></li>
<li><a href='#log_namespaces'><p>Looks up logger namespaces</p></a></li>
<li><a href='#log_separator'><p>Logs a long line to stand out from the console</p></a></li>
<li><a href='#log_shiny_input_changes'><p>Auto logging input changes in Shiny app</p></a></li>
<li><a href='#log_threshold'><p>Get or set log level threshold</p></a></li>
<li><a href='#log_tictoc'><p>Tic-toc logging</p></a></li>
<li><a href='#log_warnings'><p>Injects a logger call to standard warnings</p></a></li>
<li><a href='#log_with_separator'><p>Logs a message in a very visible way</p></a></li>
<li><a href='#logger'><p>Generate logging utility</p></a></li>
<li><a href='#OFF'><p>Log levels</p></a></li>
<li><a href='#skip_formatter'><p>Skip the formatter function</p></a></li>
<li><a href='#top_env_name'><p>Returns the name of the top level environment from which the logger was called</p></a></li>
<li><a href='#validate_log_level'><p>Assure valid log level</p></a></li>
<li><a href='#warn_if_globalCallingHandlers_is_not_available'><p>Warn to update R to 4+</p></a></li>
<li><a href='#with_log_threshold'><p>Evaluate R expression with a temporarily updated log level threshold</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Lightweight, Modern and Flexible Logging Utility</td>
</tr>
<tr>
<td>Description:</td>
<td>Inspired by the the 'futile.logger' R package and 'logging' Python module, this utility provides a flexible and extensible way of formatting and delivering log messages with low overhead.</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-03</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://daroczig.github.io/logger/">https://daroczig.github.io/logger/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/daroczig/logger/issues">https://github.com/daroczig/logger/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/AGPL-3">AGPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>glue, pander, jsonlite, crayon, slackr (&ge; 1.4.1),
RPushbullet, telegram, testthat, covr, knitr, rmarkdown,
devtools, roxygen2, parallel, rsyslog, shiny, callr, txtq,
botor, R.utils, syslognet</td>
</tr>
<tr>
<td>Enhances:</td>
<td>logging, futile.logger, log4r</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-05 14:10:49 UTC; daroczig</td>
</tr>
<tr>
<td>Author:</td>
<td>Gergely Daróczi <a href="https://orcid.org/0000-0003-3149-8537"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  System1 [fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gergely Daróczi &lt;daroczig@rapporter.net&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-05 16:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25except+25'>Try to evaluate an expressions and evaluate another expression on exception</h2><span id='topic++25except+25'></span>

<h3>Description</h3>

<p>Try to evaluate an expressions and evaluate another expression on exception
</p>


<h3>Usage</h3>

<pre><code class='language-R'>try %except% except
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25except+2B25_+3A_try">try</code></td>
<td>
<p>R expression</p>
</td></tr>
<tr><td><code id="+2B25except+2B25_+3A_except">except</code></td>
<td>
<p>fallback R expression to be evaluated if <code>try</code> fails</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Suppress log messages in the <code>except</code> namespace if you don't want to throw a <code>WARN</code> log message on the exception branch.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>everything %except% 42
everything &lt;- '640kb'
everything %except% 42

FunDoesNotExist(1:10) %except% sum(1:10) / length(1:10)
FunDoesNotExist(1:10) %except% (sum(1:10) / length(1:10))
FunDoesNotExist(1:10) %except% MEAN(1:10) %except% mean(1:10)
FunDoesNotExist(1:10) %except% (MEAN(1:10) %except% mean(1:10))
</code></pre>

<hr>
<h2 id='appender_async'>Delays executing the actual appender function to the future in a background process to avoid blocking the main R session</h2><span id='topic+appender_async'></span>

<h3>Description</h3>

<p>Delays executing the actual appender function to the future in a background process to avoid blocking the main R session
</p>


<h3>Usage</h3>

<pre><code class='language-R'>appender_async(
  appender,
  batch = 1,
  namespace = "async_logger",
  init = function() log_info("Background process started")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="appender_async_+3A_appender">appender</code></td>
<td>
<p>a  <code><a href="#topic+log_appender">log_appender</a></code> function with a <code>generator</code> attribute (TODO note not required, all fn will be passed if not)</p>
</td></tr>
<tr><td><code id="appender_async_+3A_batch">batch</code></td>
<td>
<p>number of records to process from the queue at once</p>
</td></tr>
<tr><td><code id="appender_async_+3A_namespace">namespace</code></td>
<td>
<p><code>logger</code> namespace to use for logging messages on starting up the background process</p>
</td></tr>
<tr><td><code id="appender_async_+3A_init">init</code></td>
<td>
<p>optional function to run in the background process that is useful to set up the environment required for logging, eg if the <code>appender</code> function requires some extra packages to be loaded or some environment variables to be set etc</p>
</td></tr>
</table>


<h3>Value</h3>

<p>function taking <code>lines</code> argument
</p>


<h3>Note</h3>

<p>This functionality depends on the <span class="pkg">txtq</span> and <span class="pkg">callr</span> packages. The R session's temp folder is used for staging files (message queue and other forms of communication between the parent and child processes).
</p>


<h3>See Also</h3>

<p>This function is to be used with an actual <code><a href="#topic+log_appender">log_appender</a></code>, for example <code><a href="#topic+appender_console">appender_console</a></code>, <code><a href="#topic+appender_file">appender_file</a></code>, <code><a href="#topic+appender_tee">appender_tee</a></code>, <code><a href="#topic+appender_pushbullet">appender_pushbullet</a></code>, <code><a href="#topic+appender_telegram">appender_telegram</a></code>, <code><a href="#topic+appender_syslog">appender_syslog</a></code> or <code><a href="#topic+appender_kinesis">appender_kinesis</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
appender_file_slow &lt;- function(file) {
  force(file)
  function(lines) {
    Sys.sleep(1)
    cat(lines, sep = '\n', file = file, append = TRUE)
  }
}

## log what's happening in the background
log_threshold(TRACE, namespace = 'async_logger')
log_appender(appender_console, namespace = 'async_logger')

## start async appender
t &lt;- tempfile()
log_info('Logging in the background to {t}')
my_appender &lt;- appender_async(appender_file_slow(file = t))

## use async appender
log_appender(my_appender)
log_info('Was this slow?')
system.time(for (i in 1:25) log_info(i))

readLines(t)
Sys.sleep(10)
readLines(t)

## check on the async appender (debugging, you will probably never need this)
attr(my_appender, 'async_writer_queue')$count()
attr(my_appender, 'async_writer_queue')$log()

attr(my_appender, 'async_writer_process')$get_pid()
attr(my_appender, 'async_writer_process')$get_state()
attr(my_appender, 'async_writer_process')$poll_process(1)
attr(my_appender, 'async_writer_process')$read()

attr(my_appender, 'async_writer_process')$is_alive()
attr(my_appender, 'async_writer_process')$read_error()

## End(Not run)
</code></pre>

<hr>
<h2 id='appender_console'>Append log record to stderr</h2><span id='topic+appender_console'></span><span id='topic+appender_stderr'></span>

<h3>Description</h3>

<p>Append log record to stderr
</p>


<h3>Usage</h3>

<pre><code class='language-R'>appender_console(lines)

appender_stderr(lines)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="appender_console_+3A_lines">lines</code></td>
<td>
<p>character vector</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>This is a <code><a href="#topic+log_appender">log_appender</a></code>, for alternatives, see eg <code><a href="#topic+appender_stdout">appender_stdout</a></code>, <code><a href="#topic+appender_file">appender_file</a></code>, <code><a href="#topic+appender_tee">appender_tee</a></code>, <code><a href="#topic+appender_slack">appender_slack</a></code>, <code><a href="#topic+appender_pushbullet">appender_pushbullet</a></code>, <code><a href="#topic+appender_telegram">appender_telegram</a></code>, <code><a href="#topic+appender_syslog">appender_syslog</a></code>, <code><a href="#topic+appender_kinesis">appender_kinesis</a></code> and <code><a href="#topic+appender_async">appender_async</a></code> for evaluate any <code><a href="#topic+log_appender">log_appender</a></code> function in a background process.
</p>

<hr>
<h2 id='appender_file'>Append log messages to a file</h2><span id='topic+appender_file'></span>

<h3>Description</h3>

<p>Log messages are written to a file with basic log rotation: when max number of lines or bytes is defined to be other than <code>Inf</code>, then the log file is renamed with a <code>.1</code> suffix and a new log file is created. The renaming happens recursively (eg <code>logfile.1</code> renamed to <code>logfile.2</code>) until the specified <code>max_files</code>, then the oldest file (<code>logfile.{max_files-1}</code>) is deleted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>appender_file(
  file,
  append = TRUE,
  max_lines = Inf,
  max_bytes = Inf,
  max_files = 1L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="appender_file_+3A_file">file</code></td>
<td>
<p>path</p>
</td></tr>
<tr><td><code id="appender_file_+3A_append">append</code></td>
<td>
<p>boolean passed to <code>cat</code> defining if the file should be overwritten with the most recent log message instead of appending</p>
</td></tr>
<tr><td><code id="appender_file_+3A_max_lines">max_lines</code></td>
<td>
<p>numeric specifying the maximum number of lines allowed in a file before rotating</p>
</td></tr>
<tr><td><code id="appender_file_+3A_max_bytes">max_bytes</code></td>
<td>
<p>numeric specifying the maximum number of bytes allowed in a file before rotating</p>
</td></tr>
<tr><td><code id="appender_file_+3A_max_files">max_files</code></td>
<td>
<p>integer specifying the maximum number of files to be used in rotation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>function taking <code>lines</code> argument
</p>


<h3>See Also</h3>

<p>This is generator function for <code><a href="#topic+log_appender">log_appender</a></code>, for alternatives, see eg <code><a href="#topic+appender_console">appender_console</a></code>, <code><a href="#topic+appender_tee">appender_tee</a></code>, <code><a href="#topic+appender_slack">appender_slack</a></code>, <code><a href="#topic+appender_pushbullet">appender_pushbullet</a></code>, <code><a href="#topic+appender_telegram">appender_telegram</a></code>, <code><a href="#topic+appender_syslog">appender_syslog</a></code>, <code><a href="#topic+appender_kinesis">appender_kinesis</a></code> and <code><a href="#topic+appender_async">appender_async</a></code> for evaluate any <code><a href="#topic+log_appender">log_appender</a></code> function in a background process.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## ##########################################################################
## simple example logging to a file
t &lt;- tempfile()
log_appender(appender_file(t))
for (i in 1:25) log_info(i)
readLines(t)

## ##########################################################################
## more complex example of logging to file
## rotated after every 3rd line up to max 5 files

## create a folder storing the log files
t &lt;- tempfile(); dir.create(t)
f &lt;- file.path(t, 'log')

## define the file logger with log rotation enabled
log_appender(appender_file(f, max_lines = 3, max_files = 5L))

## log 25 messages
for (i in 1:25) log_info(i)

## see what was logged
lapply(list.files(t, full.names = TRUE), function(t) {
  cat('\n##', t, '\n')
  cat(readLines(t), sep = '\n')
})

## enable internal logging to see what's actually happening in the logrotate steps
log_threshold(TRACE, namespace = '.logger')
## run the above commands again

## End(Not run)
</code></pre>

<hr>
<h2 id='appender_kinesis'>Send log messages to a Amazon Kinesis stream</h2><span id='topic+appender_kinesis'></span>

<h3>Description</h3>

<p>Send log messages to a Amazon Kinesis stream
</p>


<h3>Usage</h3>

<pre><code class='language-R'>appender_kinesis(stream)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="appender_kinesis_+3A_stream">stream</code></td>
<td>
<p>name of the Kinesis stream</p>
</td></tr>
</table>


<h3>Value</h3>

<p>function taking <code>lines</code> and optional <code>partition_key</code> argument
</p>


<h3>Note</h3>

<p>This functionality depends on the <span class="pkg">botor</span> package.
</p>


<h3>See Also</h3>

<p>This is generator function for <code><a href="#topic+log_appender">log_appender</a></code>, for alternatives, see eg <code><a href="#topic+appender_console">appender_console</a></code>, <code><a href="#topic+appender_file">appender_file</a></code>, <code><a href="#topic+appender_tee">appender_tee</a></code>, <code><a href="#topic+appender_pushbullet">appender_pushbullet</a></code>, <code><a href="#topic+appender_telegram">appender_telegram</a></code>, <code><a href="#topic+appender_syslog">appender_syslog</a></code> and <code><a href="#topic+appender_async">appender_async</a></code> for evaluate any <code><a href="#topic+log_appender">log_appender</a></code> function in a background process.
</p>

<hr>
<h2 id='appender_pushbullet'>Send log messages to Pushbullet</h2><span id='topic+appender_pushbullet'></span>

<h3>Description</h3>

<p>Send log messages to Pushbullet
</p>


<h3>Usage</h3>

<pre><code class='language-R'>appender_pushbullet(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="appender_pushbullet_+3A_...">...</code></td>
<td>
<p>parameters passed to <code>pbPost</code>, such as <code>recipients</code> or <code>apikey</code>, although it's probably much better to set all these in the <code>~/.rpushbullet.json</code> as per package docs at <a href="http://dirk.eddelbuettel.com/code/rpushbullet.html">http://dirk.eddelbuettel.com/code/rpushbullet.html</a></p>
</td></tr>
</table>


<h3>Note</h3>

<p>This functionality depends on the <span class="pkg">RPushbullet</span> package.
</p>


<h3>See Also</h3>

<p>This is generator function for <code><a href="#topic+log_appender">log_appender</a></code>, for alternatives, see eg <code><a href="#topic+appender_console">appender_console</a></code>, <code><a href="#topic+appender_file">appender_file</a></code>, <code><a href="#topic+appender_tee">appender_tee</a></code>, <code><a href="#topic+appender_slack">appender_slack</a></code>, <code><a href="#topic+appender_telegram">appender_telegram</a></code>, <code><a href="#topic+appender_syslog">appender_syslog</a></code>, <code><a href="#topic+appender_kinesis">appender_kinesis</a></code> and <code><a href="#topic+appender_async">appender_async</a></code> for evaluate any <code><a href="#topic+log_appender">log_appender</a></code> function in a background process.
</p>

<hr>
<h2 id='appender_slack'>Send log messages to a Slack channel</h2><span id='topic+appender_slack'></span>

<h3>Description</h3>

<p>Send log messages to a Slack channel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>appender_slack(
  channel = Sys.getenv("SLACK_CHANNEL"),
  username = Sys.getenv("SLACK_USERNAME"),
  icon_emoji = Sys.getenv("SLACK_ICON_EMOJI"),
  api_token = Sys.getenv("SLACK_API_TOKEN"),
  preformatted = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="appender_slack_+3A_channel">channel</code></td>
<td>
<p>Slack channel name with a hashtag prefix for public channel and no prefix for private channels</p>
</td></tr>
<tr><td><code id="appender_slack_+3A_username">username</code></td>
<td>
<p>Slack (bot) username</p>
</td></tr>
<tr><td><code id="appender_slack_+3A_icon_emoji">icon_emoji</code></td>
<td>
<p>optional override for the bot icon</p>
</td></tr>
<tr><td><code id="appender_slack_+3A_api_token">api_token</code></td>
<td>
<p>Slack API token</p>
</td></tr>
<tr><td><code id="appender_slack_+3A_preformatted">preformatted</code></td>
<td>
<p>use code tags around the message?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>function taking <code>lines</code> argument
</p>


<h3>Note</h3>

<p>This functionality depends on the <span class="pkg">slackr</span> package.
</p>


<h3>See Also</h3>

<p>This is generator function for <code><a href="#topic+log_appender">log_appender</a></code>, for alternatives, see eg <code><a href="#topic+appender_console">appender_console</a></code>, <code><a href="#topic+appender_file">appender_file</a></code>, <code><a href="#topic+appender_tee">appender_tee</a></code>, <code><a href="#topic+appender_pushbullet">appender_pushbullet</a></code>, <code><a href="#topic+appender_telegram">appender_telegram</a></code>, <code><a href="#topic+appender_syslog">appender_syslog</a></code>, <code><a href="#topic+appender_kinesis">appender_kinesis</a></code> and <code><a href="#topic+appender_async">appender_async</a></code> for evaluate any <code><a href="#topic+log_appender">log_appender</a></code> function in a background process.
</p>

<hr>
<h2 id='appender_stdout'>Append log record to stdout</h2><span id='topic+appender_stdout'></span>

<h3>Description</h3>

<p>Append log record to stdout
</p>


<h3>Usage</h3>

<pre><code class='language-R'>appender_stdout(lines)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="appender_stdout_+3A_lines">lines</code></td>
<td>
<p>character vector</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>This is a <code><a href="#topic+log_appender">log_appender</a></code>, for alternatives, see eg <code><a href="#topic+appender_console">appender_console</a></code>, <code><a href="#topic+appender_file">appender_file</a></code>, <code><a href="#topic+appender_tee">appender_tee</a></code>, <code><a href="#topic+appender_slack">appender_slack</a></code>, <code><a href="#topic+appender_pushbullet">appender_pushbullet</a></code>
</p>

<hr>
<h2 id='appender_syslog'>Send log messages to the POSIX system log</h2><span id='topic+appender_syslog'></span>

<h3>Description</h3>

<p>Send log messages to the POSIX system log
</p>


<h3>Usage</h3>

<pre><code class='language-R'>appender_syslog(identifier, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="appender_syslog_+3A_identifier">identifier</code></td>
<td>
<p>A string identifying the process.</p>
</td></tr>
<tr><td><code id="appender_syslog_+3A_...">...</code></td>
<td>
<p>Further arguments passed on to <code><a href="rsyslog.html#topic+open_syslog">open_syslog</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>function taking <code>lines</code> argument
</p>


<h3>Note</h3>

<p>This functionality depends on the <span class="pkg">rsyslog</span> package.
</p>


<h3>See Also</h3>

<p>This is generator function for <code><a href="#topic+log_appender">log_appender</a></code>, for alternatives, see eg <code><a href="#topic+appender_console">appender_console</a></code>, <code><a href="#topic+appender_file">appender_file</a></code>, <code><a href="#topic+appender_tee">appender_tee</a></code>, <code><a href="#topic+appender_pushbullet">appender_pushbullet</a></code>, <code><a href="#topic+appender_telegram">appender_telegram</a></code>, <code><a href="#topic+appender_kinesis">appender_kinesis</a></code> and <code><a href="#topic+appender_async">appender_async</a></code> for evaluate any <code><a href="#topic+log_appender">log_appender</a></code> function in a background process.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (requireNamespace("rsyslog", quietly = TRUE)) {
  log_appender(appender_syslog("test"))
  log_info("Test message.")
}

## End(Not run)
</code></pre>

<hr>
<h2 id='appender_syslognet'>Send log messages to a network syslog server</h2><span id='topic+appender_syslognet'></span>

<h3>Description</h3>

<p>Send log messages to a network syslog server
</p>


<h3>Usage</h3>

<pre><code class='language-R'>appender_syslognet(identifier, server, port = 601L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="appender_syslognet_+3A_identifier">identifier</code></td>
<td>
<p>program/function identification (string).</p>
</td></tr>
<tr><td><code id="appender_syslognet_+3A_server">server</code></td>
<td>
<p>machine where syslog daemon runs (string).</p>
</td></tr>
<tr><td><code id="appender_syslognet_+3A_port">port</code></td>
<td>
<p>port where syslog daemon listens (integer).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function taking a <code>lines</code> argument.
</p>


<h3>Note</h3>

<p>This functionality depends on the <span class="pkg">syslognet</span> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (requireNamespace("syslognet", quietly = TRUE)) {
  log_appender(appender_syslognet("test_app", 'remoteserver'))
  log_info("Test message.")
}

## End(Not run)
</code></pre>

<hr>
<h2 id='appender_tee'>Append log messages to a file and stdout as well</h2><span id='topic+appender_tee'></span>

<h3>Description</h3>

<p>This appends log messages to both console and a file. The same rotation options are available as in <code><a href="#topic+appender_file">appender_file</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>appender_tee(
  file,
  append = TRUE,
  max_lines = Inf,
  max_bytes = Inf,
  max_files = 1L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="appender_tee_+3A_file">file</code></td>
<td>
<p>path</p>
</td></tr>
<tr><td><code id="appender_tee_+3A_append">append</code></td>
<td>
<p>boolean passed to <code>cat</code> defining if the file should be overwritten with the most recent log message instead of appending</p>
</td></tr>
<tr><td><code id="appender_tee_+3A_max_lines">max_lines</code></td>
<td>
<p>numeric specifying the maximum number of lines allowed in a file before rotating</p>
</td></tr>
<tr><td><code id="appender_tee_+3A_max_bytes">max_bytes</code></td>
<td>
<p>numeric specifying the maximum number of bytes allowed in a file before rotating</p>
</td></tr>
<tr><td><code id="appender_tee_+3A_max_files">max_files</code></td>
<td>
<p>integer specifying the maximum number of files to be used in rotation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>function taking <code>lines</code> argument
</p>


<h3>See Also</h3>

<p>This is generator function for <code><a href="#topic+log_appender">log_appender</a></code>, for alternatives, see eg <code><a href="#topic+appender_console">appender_console</a></code>, <code><a href="#topic+appender_file">appender_file</a></code>, <code><a href="#topic+appender_slack">appender_slack</a></code>, <code><a href="#topic+appender_pushbullet">appender_pushbullet</a></code>, <code><a href="#topic+appender_telegram">appender_telegram</a></code>, <code><a href="#topic+appender_syslog">appender_syslog</a></code>, <code><a href="#topic+appender_kinesis">appender_kinesis</a></code> and <code><a href="#topic+appender_async">appender_async</a></code> for evaluate any <code><a href="#topic+log_appender">log_appender</a></code> function in a background process.
</p>

<hr>
<h2 id='appender_telegram'>Send log messages to a Telegram chat</h2><span id='topic+appender_telegram'></span>

<h3>Description</h3>

<p>Send log messages to a Telegram chat
</p>


<h3>Usage</h3>

<pre><code class='language-R'>appender_telegram(
  chat_id = Sys.getenv("TELEGRAM_CHAT_ID"),
  bot_token = Sys.getenv("TELEGRAM_BOT_TOKEN"),
  parse_mode = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="appender_telegram_+3A_chat_id">chat_id</code></td>
<td>
<p>Unique identifier for the target chat or username of the target channel (in the format @channelusername)</p>
</td></tr>
<tr><td><code id="appender_telegram_+3A_bot_token">bot_token</code></td>
<td>
<p>Telegram Authorization token</p>
</td></tr>
<tr><td><code id="appender_telegram_+3A_parse_mode">parse_mode</code></td>
<td>
<p>Message parse mode. Allowed values: Markdown or HTML</p>
</td></tr>
</table>


<h3>Value</h3>

<p>function taking <code>lines</code> argument
</p>


<h3>Note</h3>

<p>This functionality depends on the <span class="pkg">telegram</span> package.
</p>


<h3>See Also</h3>

<p>This is generator function for <code><a href="#topic+log_appender">log_appender</a></code>, for alternatives, see eg <code><a href="#topic+appender_console">appender_console</a></code>, <code><a href="#topic+appender_file">appender_file</a></code>, <code><a href="#topic+appender_tee">appender_tee</a></code>, <code><a href="#topic+appender_pushbullet">appender_pushbullet</a></code>, <code><a href="#topic+appender_syslog">appender_syslog</a></code>, <code><a href="#topic+appender_kinesis">appender_kinesis</a></code> and <code><a href="#topic+appender_async">appender_async</a></code> for evaluate any <code><a href="#topic+log_appender">log_appender</a></code> function in a background process.
</p>

<hr>
<h2 id='appender_void'>Dummy appender not delivering the log record to anywhere</h2><span id='topic+appender_void'></span>

<h3>Description</h3>

<p>Dummy appender not delivering the log record to anywhere
</p>


<h3>Usage</h3>

<pre><code class='language-R'>appender_void(lines)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="appender_void_+3A_lines">lines</code></td>
<td>
<p>character vector</p>
</td></tr>
</table>

<hr>
<h2 id='as.loglevel'>Convert R object into a logger log-level</h2><span id='topic+as.loglevel'></span>

<h3>Description</h3>

<p>Convert R object into a logger log-level
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.loglevel(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.loglevel_+3A_x">x</code></td>
<td>
<p>string or integer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>pander log-level, e.g. <code>INFO</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as.loglevel(INFO)
as.loglevel(400L)
as.loglevel(400)
</code></pre>

<hr>
<h2 id='catch_base_log'>Catch the log header</h2><span id='topic+catch_base_log'></span>

<h3>Description</h3>

<p>Catch the log header
</p>


<h3>Usage</h3>

<pre><code class='language-R'>catch_base_log(
  level,
  namespace,
  .topcall = sys.call(-1),
  .topenv = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="catch_base_log_+3A_level">level</code></td>
<td>
<p>see <code><a href="#topic+log_levels">log_levels</a></code></p>
</td></tr>
<tr><td><code id="catch_base_log_+3A_namespace">namespace</code></td>
<td>
<p>string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
catch_base_log(INFO, NA_character_)
logger &lt;- layout_glue_generator(format = '{node}/{pid}/{namespace}/{fn} {time} {level}: {msg}')
log_layout(logger)
catch_base_log(INFO, NA_character_)
fun &lt;- function() catch_base_log(INFO, NA_character_)
fun()
catch_base_log(INFO, NA_character_, .topcall = call('funLONG'))

## End(Not run)
</code></pre>

<hr>
<h2 id='colorize_by_log_level'>Colorize string by the related log level</h2><span id='topic+colorize_by_log_level'></span>

<h3>Description</h3>

<p>Adding color to a string to be used in terminal output. Supports ANSI standard colors 8 or 256.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colorize_by_log_level(msg, level)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colorize_by_log_level_+3A_msg">msg</code></td>
<td>
<p>string</p>
</td></tr>
<tr><td><code id="colorize_by_log_level_+3A_level">level</code></td>
<td>
<p>see <code><a href="#topic+log_levels">log_levels</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>string with ANSI escape code
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
cat(colorize_by_log_level(FATAL, 'foobar'), '\n')
cat(colorize_by_log_level(ERROR, 'foobar'), '\n')
cat(colorize_by_log_level(WARN, 'foobar'), '\n')
cat(colorize_by_log_level(SUCCESS, 'foobar'), '\n')
cat(colorize_by_log_level(INFO, 'foobar'), '\n')
cat(colorize_by_log_level(DEBUG, 'foobar'), '\n')
cat(colorize_by_log_level(TRACE, 'foobar'), '\n')

## End(Not run)
</code></pre>

<hr>
<h2 id='delete_logger_index'>Delete an index from a logger namespace</h2><span id='topic+delete_logger_index'></span>

<h3>Description</h3>

<p>Delete an index from a logger namespace
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete_logger_index(namespace = "global", index)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete_logger_index_+3A_namespace">namespace</code></td>
<td>
<p>logger namespace</p>
</td></tr>
<tr><td><code id="delete_logger_index_+3A_index">index</code></td>
<td>
<p>index of the logger within the namespace</p>
</td></tr>
</table>

<hr>
<h2 id='deparse_to_one_line'>Deparse and join all lines into a single line</h2><span id='topic+deparse_to_one_line'></span>

<h3>Description</h3>

<p>Calling <code>deparse</code> and joining all the returned lines into a
single line, separated by whitespace, and then cleaning up all the
duplicated whitespace (except for excessive whitespace in strings
between single or double quotes).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deparse_to_one_line(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deparse_to_one_line_+3A_x">x</code></td>
<td>
<p>object to <code>deparse</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>string
</p>

<hr>
<h2 id='fail_on_missing_package'>Check if R package can be loaded and fails loudly otherwise</h2><span id='topic+fail_on_missing_package'></span>

<h3>Description</h3>

<p>Check if R package can be loaded and fails loudly otherwise
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fail_on_missing_package(pkg, min_version)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fail_on_missing_package_+3A_pkg">pkg</code></td>
<td>
<p>string</p>
</td></tr>
<tr><td><code id="fail_on_missing_package_+3A_min_version">min_version</code></td>
<td>
<p>optional minimum version needed</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
f &lt;- function() fail_on_missing_package('foobar')
f()
g &lt;- function() fail_on_missing_package('stats')
g()

## End(Not run)
</code></pre>

<hr>
<h2 id='fallback_namespace'>Checks if provided namespace exists and falls back to global if not</h2><span id='topic+fallback_namespace'></span>

<h3>Description</h3>

<p>Checks if provided namespace exists and falls back to global if not
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fallback_namespace(namespace)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fallback_namespace_+3A_namespace">namespace</code></td>
<td>
<p>string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string
</p>

<hr>
<h2 id='formatter_glue'>Apply <code>glue</code> to convert R objects into a character vector</h2><span id='topic+formatter_glue'></span>

<h3>Description</h3>

<p>Apply <code>glue</code> to convert R objects into a character vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formatter_glue(
  ...,
  .logcall = sys.call(),
  .topcall = sys.call(-1),
  .topenv = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formatter_glue_+3A_...">...</code></td>
<td>
<p>passed to <code>glue</code> for the text interpolation</p>
</td></tr>
<tr><td><code id="formatter_glue_+3A_.logcall">.logcall</code></td>
<td>
<p>the logging call being evaluated (useful in formatters and layouts when you want to have access to the raw, unevaluated R expression)</p>
</td></tr>
<tr><td><code id="formatter_glue_+3A_.topcall">.topcall</code></td>
<td>
<p>R expression from which the logging function was called (useful in formatters and layouts to extract the calling function's name or arguments)</p>
</td></tr>
<tr><td><code id="formatter_glue_+3A_.topenv">.topenv</code></td>
<td>
<p>original frame of the <code>.topcall</code> calling function where the formatter function will be evaluated and that is used to look up the <code>namespace</code> as well via <code>logger:::top_env_name</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector
</p>


<h3>Note</h3>

<p>Although this is the default log message formatter function, but when <span class="pkg">glue</span> is not installed, <code><a href="#topic+formatter_sprintf">formatter_sprintf</a></code> will be used as a fallback.
</p>


<h3>See Also</h3>

<p>This is a <code><a href="#topic+log_formatter">log_formatter</a></code>, for alternatives, see <code><a href="#topic+formatter_paste">formatter_paste</a></code>, <code><a href="#topic+formatter_sprintf">formatter_sprintf</a></code>, <code><a href="#topic+formatter_glue_or_sprintf">formatter_glue_or_sprintf</a></code>, <code><a href="#topic+formatter_glue_safe">formatter_glue_safe</a></code>, <code><a href="#topic+formatter_logging">formatter_logging</a></code>, <code><a href="#topic+formatter_json">formatter_json</a></code>, <code><a href="#topic+formatter_pander">formatter_pander</a></code> and <code><a href="#topic+skip_formatter">skip_formatter</a></code> for marking a string not to apply the formatter on it.
</p>

<hr>
<h2 id='formatter_glue_or_sprintf'>Apply <code>glue</code> and <code>sprintf</code></h2><span id='topic+formatter_glue_or_sprintf'></span>

<h3>Description</h3>

<p>The best of both words: using both formatter functions in your log messages, which can be useful eg if you are migrating from <code>sprintf</code> formatted log messages to <code>glue</code> or similar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formatter_glue_or_sprintf(
  msg,
  ...,
  .logcall = sys.call(),
  .topcall = sys.call(-1),
  .topenv = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formatter_glue_or_sprintf_+3A_msg">msg</code></td>
<td>
<p>passed to <code>sprintf</code> as <code>fmt</code> or handled as part of <code>...</code> in <code>glue</code></p>
</td></tr>
<tr><td><code id="formatter_glue_or_sprintf_+3A_...">...</code></td>
<td>
<p>passed to <code>glue</code> for the text interpolation</p>
</td></tr>
<tr><td><code id="formatter_glue_or_sprintf_+3A_.logcall">.logcall</code></td>
<td>
<p>the logging call being evaluated (useful in formatters and layouts when you want to have access to the raw, unevaluated R expression)</p>
</td></tr>
<tr><td><code id="formatter_glue_or_sprintf_+3A_.topcall">.topcall</code></td>
<td>
<p>R expression from which the logging function was called (useful in formatters and layouts to extract the calling function's name or arguments)</p>
</td></tr>
<tr><td><code id="formatter_glue_or_sprintf_+3A_.topenv">.topenv</code></td>
<td>
<p>original frame of the <code>.topcall</code> calling function where the formatter function will be evaluated and that is used to look up the <code>namespace</code> as well via <code>logger:::top_env_name</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this function tries to be smart when passing arguments to <code>glue</code> and <code>sprintf</code>, but might fail with some edge cases, and returns an unformatted string.
</p>


<h3>Value</h3>

<p>character vector
</p>


<h3>See Also</h3>

<p>This is a <code><a href="#topic+log_formatter">log_formatter</a></code>, for alternatives, see <code><a href="#topic+formatter_paste">formatter_paste</a></code>, <code><a href="#topic+formatter_sprintf">formatter_sprintf</a></code>, <code><a href="#topic+formatter_glue">formatter_glue</a></code>, <code><a href="#topic+formatter_glue_safe">formatter_glue_safe</a></code>, <code><a href="#topic+formatter_logging">formatter_logging</a></code>, <code><a href="#topic+formatter_json">formatter_json</a></code>, <code><a href="#topic+formatter_pander">formatter_pander</a></code> and <code><a href="#topic+skip_formatter">skip_formatter</a></code> for marking a string not to apply the formatter on it.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
formatter_glue_or_sprintf("{a} + {b} = %s", a = 2, b = 3, 5)
formatter_glue_or_sprintf("{pi} * {2} = %s", pi*2)
formatter_glue_or_sprintf("{pi} * {2} = {pi*2}")

formatter_glue_or_sprintf("Hi ", "{c('foo', 'bar')}, did you know that 2*4={2*4}")
formatter_glue_or_sprintf("Hi {c('foo', 'bar')}, did you know that 2*4={2*4}")
formatter_glue_or_sprintf("Hi {c('foo', 'bar')}, did you know that 2*4=%s", 2*4)
formatter_glue_or_sprintf("Hi %s, did you know that 2*4={2*4}", c('foo', 'bar'))
formatter_glue_or_sprintf("Hi %s, did you know that 2*4=%s", c('foo', 'bar'), 2*4)

## End(Not run)
</code></pre>

<hr>
<h2 id='formatter_glue_safe'>Apply <code>glue_safe</code> to convert R objects into a character vector</h2><span id='topic+formatter_glue_safe'></span>

<h3>Description</h3>

<p>Apply <code>glue_safe</code> to convert R objects into a character vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formatter_glue_safe(
  ...,
  .logcall = sys.call(),
  .topcall = sys.call(-1),
  .topenv = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formatter_glue_safe_+3A_...">...</code></td>
<td>
<p>passed to <code>glue_safe</code> for the text interpolation</p>
</td></tr>
<tr><td><code id="formatter_glue_safe_+3A_.logcall">.logcall</code></td>
<td>
<p>the logging call being evaluated (useful in formatters and layouts when you want to have access to the raw, unevaluated R expression)</p>
</td></tr>
<tr><td><code id="formatter_glue_safe_+3A_.topcall">.topcall</code></td>
<td>
<p>R expression from which the logging function was called (useful in formatters and layouts to extract the calling function's name or arguments)</p>
</td></tr>
<tr><td><code id="formatter_glue_safe_+3A_.topenv">.topenv</code></td>
<td>
<p>original frame of the <code>.topcall</code> calling function where the formatter function will be evaluated and that is used to look up the <code>namespace</code> as well via <code>logger:::top_env_name</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector
</p>


<h3>See Also</h3>

<p>This is a <code><a href="#topic+log_formatter">log_formatter</a></code>, for alternatives, see <code><a href="#topic+formatter_glue">formatter_glue</a></code>, <code><a href="#topic+formatter_paste">formatter_paste</a></code>, <code><a href="#topic+formatter_sprintf">formatter_sprintf</a></code>, <code><a href="#topic+formatter_glue">formatter_glue</a></code>, <code><a href="#topic+formatter_glue_or_sprintf">formatter_glue_or_sprintf</a></code>, <code><a href="#topic+formatter_logging">formatter_logging</a></code>, <code><a href="#topic+formatter_json">formatter_json</a></code>, <code><a href="#topic+formatter_pander">formatter_pander</a></code> and <code><a href="#topic+skip_formatter">skip_formatter</a></code> for marking a string not to apply the formatter on it.
</p>

<hr>
<h2 id='formatter_json'>Transforms all passed R objects into a JSON list</h2><span id='topic+formatter_json'></span>

<h3>Description</h3>

<p>Transforms all passed R objects into a JSON list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formatter_json(
  ...,
  .logcall = sys.call(),
  .topcall = sys.call(-1),
  .topenv = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formatter_json_+3A_...">...</code></td>
<td>
<p>passed to <code>toJSON</code> wrapped into a <code>list</code></p>
</td></tr>
<tr><td><code id="formatter_json_+3A_.logcall">.logcall</code></td>
<td>
<p>the logging call being evaluated (useful in formatters and layouts when you want to have access to the raw, unevaluated R expression)</p>
</td></tr>
<tr><td><code id="formatter_json_+3A_.topcall">.topcall</code></td>
<td>
<p>R expression from which the logging function was called (useful in formatters and layouts to extract the calling function's name or arguments)</p>
</td></tr>
<tr><td><code id="formatter_json_+3A_.topenv">.topenv</code></td>
<td>
<p>original frame of the <code>.topcall</code> calling function where the formatter function will be evaluated and that is used to look up the <code>namespace</code> as well via <code>logger:::top_env_name</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector
</p>


<h3>Note</h3>

<p>This functionality depends on the <span class="pkg">jsonlite</span> package.
</p>


<h3>See Also</h3>

<p>This is a <code><a href="#topic+log_formatter">log_formatter</a></code> potentially to be used with <code><a href="#topic+layout_json_parser">layout_json_parser</a></code>, for alternatives, see <code><a href="#topic+formatter_paste">formatter_paste</a></code>, <code><a href="#topic+formatter_sprintf">formatter_sprintf</a></code>, <code><a href="#topic+formatter_glue">formatter_glue</a></code>, <code><a href="#topic+formatter_glue_safe">formatter_glue_safe</a></code>, <code><a href="#topic+formatter_glue_or_sprintf">formatter_glue_or_sprintf</a></code>, <code><a href="#topic+formatter_logging">formatter_logging</a></code>, <code><a href="#topic+formatter_pander">formatter_pander</a></code> and <code><a href="#topic+skip_formatter">skip_formatter</a></code> for marking a string not to apply the formatter on it.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
log_formatter(formatter_json)
log_layout(layout_json_parser())
log_info(everything = 42)
log_info(mtcars = mtcars, species = iris$Species)

## End(Not run)
</code></pre>

<hr>
<h2 id='formatter_logging'>Mimic the default formatter used in the <span class="pkg">logging</span> package</h2><span id='topic+formatter_logging'></span>

<h3>Description</h3>

<p>The <span class="pkg">logging</span> package uses a formatter that behaves differently when the input is a string or other R object. If the first argument is a string, then <code><a href="base.html#topic+sprintf">sprintf</a></code> is being called &ndash; otherwise it does something like <code><a href="#topic+log_eval">log_eval</a></code> and logs the R expression(s) and the result(s) as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formatter_logging(
  ...,
  .logcall = sys.call(),
  .topcall = sys.call(-1),
  .topenv = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formatter_logging_+3A_...">...</code></td>
<td>
<p>string and further params passed to <code>sprintf</code> or R expressions to be evaluated</p>
</td></tr>
<tr><td><code id="formatter_logging_+3A_.logcall">.logcall</code></td>
<td>
<p>the logging call being evaluated (useful in formatters and layouts when you want to have access to the raw, unevaluated R expression)</p>
</td></tr>
<tr><td><code id="formatter_logging_+3A_.topcall">.topcall</code></td>
<td>
<p>R expression from which the logging function was called (useful in formatters and layouts to extract the calling function's name or arguments)</p>
</td></tr>
<tr><td><code id="formatter_logging_+3A_.topenv">.topenv</code></td>
<td>
<p>original frame of the <code>.topcall</code> calling function where the formatter function will be evaluated and that is used to look up the <code>namespace</code> as well via <code>logger:::top_env_name</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector
</p>


<h3>See Also</h3>

<p>This is a <code><a href="#topic+log_formatter">log_formatter</a></code>, for alternatives, see <code><a href="#topic+formatter_paste">formatter_paste</a></code>, <code><a href="#topic+formatter_glue">formatter_glue</a></code>, <code><a href="#topic+formatter_glue_safe">formatter_glue_safe</a></code>, <code><a href="#topic+formatter_glue_or_sprintf">formatter_glue_or_sprintf</a></code>, <code><a href="#topic+formatter_json">formatter_json</a></code>, <code><a href="#topic+formatter_pander">formatter_pander</a></code> and <code><a href="#topic+skip_formatter">skip_formatter</a></code> for marking a string not to apply the formatter on it.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
log_formatter(formatter_logging)
log_info('42')
log_info(42)
log_info(4+2)
log_info('foo %s', 'bar')
log_info('vector %s', 1:3)
log_info(12, 1+1, 2 * 2)

## End(Not run)
</code></pre>

<hr>
<h2 id='formatter_pander'>Formats R objects with pander</h2><span id='topic+formatter_pander'></span>

<h3>Description</h3>

<p>Formats R objects with pander
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formatter_pander(
  x,
  ...,
  .logcall = sys.call(),
  .topcall = sys.call(-1),
  .topenv = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formatter_pander_+3A_x">x</code></td>
<td>
<p>object to be logged</p>
</td></tr>
<tr><td><code id="formatter_pander_+3A_...">...</code></td>
<td>
<p>optional parameters passed to <code>pander</code></p>
</td></tr>
<tr><td><code id="formatter_pander_+3A_.logcall">.logcall</code></td>
<td>
<p>the logging call being evaluated (useful in formatters and layouts when you want to have access to the raw, unevaluated R expression)</p>
</td></tr>
<tr><td><code id="formatter_pander_+3A_.topcall">.topcall</code></td>
<td>
<p>R expression from which the logging function was called (useful in formatters and layouts to extract the calling function's name or arguments)</p>
</td></tr>
<tr><td><code id="formatter_pander_+3A_.topenv">.topenv</code></td>
<td>
<p>original frame of the <code>.topcall</code> calling function where the formatter function will be evaluated and that is used to look up the <code>namespace</code> as well via <code>logger:::top_env_name</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector
</p>


<h3>Note</h3>

<p>This functionality depends on the <span class="pkg">pander</span> package.
</p>


<h3>See Also</h3>

<p>This is a <code><a href="#topic+log_formatter">log_formatter</a></code>, for alternatives, see <code><a href="#topic+formatter_paste">formatter_paste</a></code>, <code><a href="#topic+formatter_sprintf">formatter_sprintf</a></code>, <code><a href="#topic+formatter_glue">formatter_glue</a></code>, <code><a href="#topic+formatter_glue_safe">formatter_glue_safe</a></code>, <code><a href="#topic+formatter_glue_or_sprintf">formatter_glue_or_sprintf</a></code>, <code><a href="#topic+formatter_logging">formatter_logging</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
log_formatter(formatter_pander)
log_info('42')
log_info(42)
log_info(4+2)
log_info(head(iris))
log_info(head(iris), style = 'simple')
log_info(lm(hp ~ wt, mtcars))

## End(Not run)
</code></pre>

<hr>
<h2 id='formatter_paste'>Concatenate R objects into a character vector via <code>paste</code></h2><span id='topic+formatter_paste'></span>

<h3>Description</h3>

<p>Concatenate R objects into a character vector via <code>paste</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formatter_paste(
  ...,
  .logcall = sys.call(),
  .topcall = sys.call(-1),
  .topenv = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formatter_paste_+3A_...">...</code></td>
<td>
<p>passed to <code>paste</code></p>
</td></tr>
<tr><td><code id="formatter_paste_+3A_.logcall">.logcall</code></td>
<td>
<p>the logging call being evaluated (useful in formatters and layouts when you want to have access to the raw, unevaluated R expression)</p>
</td></tr>
<tr><td><code id="formatter_paste_+3A_.topcall">.topcall</code></td>
<td>
<p>R expression from which the logging function was called (useful in formatters and layouts to extract the calling function's name or arguments)</p>
</td></tr>
<tr><td><code id="formatter_paste_+3A_.topenv">.topenv</code></td>
<td>
<p>original frame of the <code>.topcall</code> calling function where the formatter function will be evaluated and that is used to look up the <code>namespace</code> as well via <code>logger:::top_env_name</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector
</p>


<h3>See Also</h3>

<p>This is a <code><a href="#topic+log_formatter">log_formatter</a></code>, for alternatives, see <code><a href="#topic+formatter_sprintf">formatter_sprintf</a></code>, <code><a href="#topic+formatter_glue">formatter_glue</a></code>, <code><a href="#topic+formatter_glue_safe">formatter_glue_safe</a></code>, <code><a href="#topic+formatter_glue_or_sprintf">formatter_glue_or_sprintf</a></code>, <code><a href="#topic+formatter_logging">formatter_logging</a></code>, <code><a href="#topic+formatter_json">formatter_json</a></code>, <code><a href="#topic+formatter_pander">formatter_pander</a></code> and <code><a href="#topic+skip_formatter">skip_formatter</a></code> for marking a string not to apply the formatter on it.
</p>

<hr>
<h2 id='formatter_sprintf'>Apply <code>sprintf</code> to convert R objects into a character vector</h2><span id='topic+formatter_sprintf'></span>

<h3>Description</h3>

<p>Apply <code>sprintf</code> to convert R objects into a character vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formatter_sprintf(
  fmt,
  ...,
  .logcall = sys.call(),
  .topcall = sys.call(-1),
  .topenv = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formatter_sprintf_+3A_fmt">fmt</code></td>
<td>
<p>passed to <code>sprintf</code></p>
</td></tr>
<tr><td><code id="formatter_sprintf_+3A_...">...</code></td>
<td>
<p>passed to <code>sprintf</code></p>
</td></tr>
<tr><td><code id="formatter_sprintf_+3A_.logcall">.logcall</code></td>
<td>
<p>the logging call being evaluated (useful in formatters and layouts when you want to have access to the raw, unevaluated R expression)</p>
</td></tr>
<tr><td><code id="formatter_sprintf_+3A_.topcall">.topcall</code></td>
<td>
<p>R expression from which the logging function was called (useful in formatters and layouts to extract the calling function's name or arguments)</p>
</td></tr>
<tr><td><code id="formatter_sprintf_+3A_.topenv">.topenv</code></td>
<td>
<p>original frame of the <code>.topcall</code> calling function where the formatter function will be evaluated and that is used to look up the <code>namespace</code> as well via <code>logger:::top_env_name</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector
</p>


<h3>See Also</h3>

<p>This is a <code><a href="#topic+log_formatter">log_formatter</a></code>, for alternatives, see <code><a href="#topic+formatter_paste">formatter_paste</a></code>, <code><a href="#topic+formatter_glue">formatter_glue</a></code>, <code><a href="#topic+formatter_glue_safe">formatter_glue_safe</a></code>, <code><a href="#topic+formatter_glue_or_sprintf">formatter_glue_or_sprintf</a></code>, <code><a href="#topic+formatter_logging">formatter_logging</a></code>, <code><a href="#topic+formatter_json">formatter_json</a></code>, <code><a href="#topic+formatter_pander">formatter_pander</a></code> and <code><a href="#topic+skip_formatter">skip_formatter</a></code> for marking a string not to apply the formatter on it.
</p>

<hr>
<h2 id='get_logger_definitions'>Find the logger definition(s) specified for the current namespace with a fallback to the global namespace</h2><span id='topic+get_logger_definitions'></span>

<h3>Description</h3>

<p>Find the logger definition(s) specified for the current namespace with a fallback to the global namespace
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_logger_definitions(namespace = NA_character_, .topenv = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_logger_definitions_+3A_namespace">namespace</code></td>
<td>
<p>override the default / auto-picked namespace with a custom string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of function(s)
</p>

<hr>
<h2 id='get_logger_meta_variables'>Collect useful information about the logging environment to be used in log messages</h2><span id='topic+get_logger_meta_variables'></span>

<h3>Description</h3>

<p>Available variables to be used in the log formatter functions, eg in <code><a href="#topic+layout_glue_generator">layout_glue_generator</a></code>:
</p>

<ul>
<li><p> levelr: log level as an R object, eg <code><a href="#topic+INFO">INFO</a></code>
</p>
</li>
<li><p> level: log level as a string, eg <code><a href="#topic+INFO">INFO</a></code>
</p>
</li>
<li><p> time: current time as <code>POSIXct</code>
</p>
</li>
<li><p> node: name by which the machine is known on the network as reported by <code>Sys.info</code>
</p>
</li>
<li><p> arch: machine type, typically the CPU architecture
</p>
</li>
<li><p> os_name: Operating System's name
</p>
</li>
<li><p> os_release: Operating System's release
</p>
</li>
<li><p> os_version: Operating System's version
</p>
</li>
<li><p> user: name of the real user id as reported by <code>Sys.info</code>
</p>
</li>
<li><p> pid: the process identification number of the R session
</p>
</li>
<li><p> node: name by which the machine is known on the network as reported by <code>Sys.info</code>
</p>
</li>
<li><p> r_version: R's major and minor version as a string
</p>
</li>
<li><p> ns: namespace usually defaults to <code>global</code> or the name of the holding R package of the calling the logging function
</p>
</li>
<li><p> ns_pkg_version: the version of <code>ns</code> when it's a package
</p>
</li>
<li><p> ans: same as <code>ns</code> if there's a defined <code><a href="#topic+logger">logger</a></code> for the namespace, otherwise a fallback namespace (eg usually <code>global</code>)
</p>
</li>
<li><p> topenv: the name of the top environment from which the parent call was called (eg R package name or <code>GlobalEnv</code>)
</p>
</li>
<li><p> call: parent call (if any) calling the logging function
</p>
</li>
<li><p> fn: function's (if any) name calling the logging function
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>get_logger_meta_variables(
  log_level = NULL,
  namespace = NA_character_,
  .logcall = sys.call(),
  .topcall = sys.call(-1),
  .topenv = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_logger_meta_variables_+3A_log_level">log_level</code></td>
<td>
<p>log level as per <code><a href="#topic+log_levels">log_levels</a></code></p>
</td></tr>
<tr><td><code id="get_logger_meta_variables_+3A_namespace">namespace</code></td>
<td>
<p>string referring to the <code>logger</code> environment / config to be used to override the target of the message record to be used instead of the default namespace, which is defined by the R package name from which the logger was called, and falls back to a common, global namespace.</p>
</td></tr>
<tr><td><code id="get_logger_meta_variables_+3A_.logcall">.logcall</code></td>
<td>
<p>the logging call being evaluated (useful in formatters and layouts when you want to have access to the raw, unevaluated R expression)</p>
</td></tr>
<tr><td><code id="get_logger_meta_variables_+3A_.topcall">.topcall</code></td>
<td>
<p>R expression from which the logging function was called (useful in formatters and layouts to extract the calling function's name or arguments)</p>
</td></tr>
<tr><td><code id="get_logger_meta_variables_+3A_.topenv">.topenv</code></td>
<td>
<p>original frame of the <code>.topcall</code> calling function where the formatter function will be evaluated and that is used to look up the <code>namespace</code> as well via <code>logger:::top_env_name</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>


<h3>See Also</h3>

<p><code><a href="#topic+layout_glue_generator">layout_glue_generator</a></code>
</p>

<hr>
<h2 id='grayscale_by_log_level'>Render a string with light/dark gray based on the related log level</h2><span id='topic+grayscale_by_log_level'></span>

<h3>Description</h3>

<p>Adding color to a string to be used in terminal output. Supports ANSI standard colors 8 or 256.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grayscale_by_log_level(msg, level)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grayscale_by_log_level_+3A_msg">msg</code></td>
<td>
<p>string</p>
</td></tr>
<tr><td><code id="grayscale_by_log_level_+3A_level">level</code></td>
<td>
<p>see <code><a href="#topic+log_levels">log_levels</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>string with ANSI escape code
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
cat(grayscale_by_log_level(FATAL, 'foobar'), '\n')
cat(grayscale_by_log_level(ERROR, 'foobar'), '\n')
cat(grayscale_by_log_level(WARN, 'foobar'), '\n')
cat(grayscale_by_log_level(SUCCESS, 'foobar'), '\n')
cat(grayscale_by_log_level(INFO, 'foobar'), '\n')
cat(grayscale_by_log_level(DEBUG, 'foobar'), '\n')
cat(grayscale_by_log_level(TRACE, 'foobar'), '\n')

## End(Not run)
</code></pre>

<hr>
<h2 id='layout_blank'>Format a log record by including the raw message without anything added or modified</h2><span id='topic+layout_blank'></span>

<h3>Description</h3>

<p>Format a log record by including the raw message without anything added or modified
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_blank(
  level,
  msg,
  namespace = NA_character_,
  .logcall = sys.call(),
  .topcall = sys.call(-1),
  .topenv = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_blank_+3A_level">level</code></td>
<td>
<p>log level, see <code><a href="#topic+log_levels">log_levels</a></code> for more details</p>
</td></tr>
<tr><td><code id="layout_blank_+3A_msg">msg</code></td>
<td>
<p>string message</p>
</td></tr>
<tr><td><code id="layout_blank_+3A_namespace">namespace</code></td>
<td>
<p>string referring to the <code>logger</code> environment / config to be used to override the target of the message record to be used instead of the default namespace, which is defined by the R package name from which the logger was called, and falls back to a common, global namespace.</p>
</td></tr>
<tr><td><code id="layout_blank_+3A_.logcall">.logcall</code></td>
<td>
<p>the logging call being evaluated (useful in formatters and layouts when you want to have access to the raw, unevaluated R expression)</p>
</td></tr>
<tr><td><code id="layout_blank_+3A_.topcall">.topcall</code></td>
<td>
<p>R expression from which the logging function was called (useful in formatters and layouts to extract the calling function's name or arguments)</p>
</td></tr>
<tr><td><code id="layout_blank_+3A_.topenv">.topenv</code></td>
<td>
<p>original frame of the <code>.topcall</code> calling function where the formatter function will be evaluated and that is used to look up the <code>namespace</code> as well via <code>logger:::top_env_name</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector
</p>


<h3>See Also</h3>

<p>This is a <code><a href="#topic+log_layout">log_layout</a></code>, for alternatives, see <code><a href="#topic+layout_simple">layout_simple</a></code>, <code><a href="#topic+layout_glue_colors">layout_glue_colors</a></code>, <code><a href="#topic+layout_json">layout_json</a></code>, or generator functions such as <code><a href="#topic+layout_glue_generator">layout_glue_generator</a></code>
</p>

<hr>
<h2 id='layout_glue'>Format a log message with <code>glue</code></h2><span id='topic+layout_glue'></span>

<h3>Description</h3>

<p>By default, this layout includes the log level of the log record as per <code><a href="#topic+log_levels">log_levels</a></code>, the current timestamp and the actual log message &ndash; that you can override via calling <code><a href="#topic+layout_glue_generator">layout_glue_generator</a></code> directly. For colorized output, see <code><a href="#topic+layout_glue_colors">layout_glue_colors</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_glue(
  level,
  msg,
  namespace = NA_character_,
  .logcall = sys.call(),
  .topcall = sys.call(-1),
  .topenv = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_glue_+3A_level">level</code></td>
<td>
<p>log level, see <code><a href="#topic+log_levels">log_levels</a></code> for more details</p>
</td></tr>
<tr><td><code id="layout_glue_+3A_msg">msg</code></td>
<td>
<p>string message</p>
</td></tr>
<tr><td><code id="layout_glue_+3A_namespace">namespace</code></td>
<td>
<p>string referring to the <code>logger</code> environment / config to be used to override the target of the message record to be used instead of the default namespace, which is defined by the R package name from which the logger was called, and falls back to a common, global namespace.</p>
</td></tr>
<tr><td><code id="layout_glue_+3A_.logcall">.logcall</code></td>
<td>
<p>the logging call being evaluated (useful in formatters and layouts when you want to have access to the raw, unevaluated R expression)</p>
</td></tr>
<tr><td><code id="layout_glue_+3A_.topcall">.topcall</code></td>
<td>
<p>R expression from which the logging function was called (useful in formatters and layouts to extract the calling function's name or arguments)</p>
</td></tr>
<tr><td><code id="layout_glue_+3A_.topenv">.topenv</code></td>
<td>
<p>original frame of the <code>.topcall</code> calling function where the formatter function will be evaluated and that is used to look up the <code>namespace</code> as well via <code>logger:::top_env_name</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector
</p>


<h3>See Also</h3>

<p>This is a <code><a href="#topic+log_layout">log_layout</a></code>, for alternatives, see <code><a href="#topic+layout_blank">layout_blank</a></code>, <code><a href="#topic+layout_simple">layout_simple</a></code>, <code><a href="#topic+layout_glue_colors">layout_glue_colors</a></code>, <code><a href="#topic+layout_json">layout_json</a></code>, <code><a href="#topic+layout_json_parser">layout_json_parser</a></code>, or generator functions such as <code><a href="#topic+layout_glue_generator">layout_glue_generator</a></code>
</p>

<hr>
<h2 id='layout_glue_colors'>Format a log message with <code>glue</code> and ANSI escape codes to add colors</h2><span id='topic+layout_glue_colors'></span>

<h3>Description</h3>

<p>Format a log message with <code>glue</code> and ANSI escape codes to add colors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_glue_colors(
  level,
  msg,
  namespace = NA_character_,
  .logcall = sys.call(),
  .topcall = sys.call(-1),
  .topenv = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_glue_colors_+3A_level">level</code></td>
<td>
<p>log level, see <code><a href="#topic+log_levels">log_levels</a></code> for more details</p>
</td></tr>
<tr><td><code id="layout_glue_colors_+3A_msg">msg</code></td>
<td>
<p>string message</p>
</td></tr>
<tr><td><code id="layout_glue_colors_+3A_namespace">namespace</code></td>
<td>
<p>string referring to the <code>logger</code> environment / config to be used to override the target of the message record to be used instead of the default namespace, which is defined by the R package name from which the logger was called, and falls back to a common, global namespace.</p>
</td></tr>
<tr><td><code id="layout_glue_colors_+3A_.logcall">.logcall</code></td>
<td>
<p>the logging call being evaluated (useful in formatters and layouts when you want to have access to the raw, unevaluated R expression)</p>
</td></tr>
<tr><td><code id="layout_glue_colors_+3A_.topcall">.topcall</code></td>
<td>
<p>R expression from which the logging function was called (useful in formatters and layouts to extract the calling function's name or arguments)</p>
</td></tr>
<tr><td><code id="layout_glue_colors_+3A_.topenv">.topenv</code></td>
<td>
<p>original frame of the <code>.topcall</code> calling function where the formatter function will be evaluated and that is used to look up the <code>namespace</code> as well via <code>logger:::top_env_name</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector
</p>


<h3>Note</h3>

<p>This functionality depends on the <span class="pkg">crayon</span> package.
</p>


<h3>See Also</h3>

<p>This is a <code><a href="#topic+log_layout">log_layout</a></code>, for alternatives, see <code><a href="#topic+layout_blank">layout_blank</a></code>, <code><a href="#topic+layout_simple">layout_simple</a></code>, <code><a href="#topic+layout_glue">layout_glue</a></code>, <code><a href="#topic+layout_json">layout_json</a></code>, <code><a href="#topic+layout_json_parser">layout_json_parser</a></code>, or generator functions such as <code><a href="#topic+layout_glue_generator">layout_glue_generator</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
log_layout(layout_glue_colors)
log_threshold(TRACE)
log_info('Starting the script...')
log_debug('This is the second line')
log_trace('That is being placed right after the first one.')
log_warn('Some errors might come!')
log_error('This is a problem')
log_debug('Getting an error is usually bad')
log_error('This is another problem')
log_fatal('The last problem.')

## End(Not run)
</code></pre>

<hr>
<h2 id='layout_glue_generator'>Generate log layout function using common variables available via glue syntax</h2><span id='topic+layout_glue_generator'></span>

<h3>Description</h3>

<p><code>format</code> is passed to <code>glue</code> with access to the below variables:
</p>

<ul>
<li><p> msg: the actual log message
</p>
</li>
<li><p> further variables set by <code><a href="#topic+get_logger_meta_variables">get_logger_meta_variables</a></code>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>layout_glue_generator(
  format = "{level} [{format(time, \"%Y-%m-%d %H:%M:%S\")}] {msg}"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_glue_generator_+3A_format">format</code></td>
<td>
<p><code>glue</code>-flavored layout of the message using the above variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>function taking <code>level</code> and <code>msg</code> arguments - keeping the original call creating the generator in the <code>generator</code> attribute that is returned when calling <code><a href="#topic+log_layout">log_layout</a></code> for the currently used layout
</p>


<h3>See Also</h3>

<p>See example calls from <code><a href="#topic+layout_glue">layout_glue</a></code> and <code><a href="#topic+layout_glue_colors">layout_glue_colors</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
example_layout &lt;- layout_glue_generator(
  format = '{node}/{pid}/{ns}/{ans}/{topenv}/{fn} {time} {level}: {msg}')
example_layout(INFO, 'try {runif(1)}')

log_layout(example_layout)
log_info('try {runif(1)}')

## End(Not run)
</code></pre>

<hr>
<h2 id='layout_json'>Generate log layout function rendering JSON</h2><span id='topic+layout_json'></span>

<h3>Description</h3>

<p>Generate log layout function rendering JSON
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_json(
  fields = c("time", "level", "ns", "ans", "topenv", "fn", "node", "arch", "os_name",
    "os_release", "os_version", "pid", "user", "msg")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_json_+3A_fields">fields</code></td>
<td>
<p>character vector of field names to be included in the JSON</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector
</p>


<h3>Note</h3>

<p>This functionality depends on the <span class="pkg">jsonlite</span> package.
</p>


<h3>See Also</h3>

<p>This is a <code><a href="#topic+log_layout">log_layout</a></code>, for alternatives, see <code><a href="#topic+layout_blank">layout_blank</a></code>, <code><a href="#topic+layout_simple">layout_simple</a></code>, <code><a href="#topic+layout_glue">layout_glue</a></code>, <code><a href="#topic+layout_glue_colors">layout_glue_colors</a></code>, <code><a href="#topic+layout_json_parser">layout_json_parser</a></code>,  or generator functions such as <code><a href="#topic+layout_glue_generator">layout_glue_generator</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
log_layout(layout_json())
log_info(42)
log_info('ok {1:3} + {1:3} = {2*(1:3)}')

## End(Not run)
</code></pre>

<hr>
<h2 id='layout_json_parser'>Generate log layout function rendering JSON after merging meta fields with parsed list from JSON message</h2><span id='topic+layout_json_parser'></span>

<h3>Description</h3>

<p>Generate log layout function rendering JSON after merging meta fields with parsed list from JSON message
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_json_parser(
  fields = c("time", "level", "ns", "ans", "topenv", "fn", "node", "arch", "os_name",
    "os_release", "os_version", "pid", "user")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_json_parser_+3A_fields">fields</code></td>
<td>
<p>character vector of field names to be included in the JSON</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This functionality depends on the <span class="pkg">jsonlite</span> package.
</p>


<h3>See Also</h3>

<p>This is a <code><a href="#topic+log_layout">log_layout</a></code> potentially to be used with <code><a href="#topic+formatter_json">formatter_json</a></code>, for alternatives, see <code><a href="#topic+layout_simple">layout_simple</a></code>, <code><a href="#topic+layout_glue">layout_glue</a></code>, <code><a href="#topic+layout_glue_colors">layout_glue_colors</a></code>, <code><a href="#topic+layout_json">layout_json</a></code> or generator functions such as <code><a href="#topic+layout_glue_generator">layout_glue_generator</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
log_formatter(formatter_json)
log_info(everything = 42)
log_layout(layout_json_parser())
log_info(everything = 42)
log_layout(layout_json_parser(fields = c('time', 'node')))
log_info(cars = row.names(mtcars), species = unique(iris$Species))

## End(Not run)
</code></pre>

<hr>
<h2 id='layout_logging'>Format a log record as the logging package does by default</h2><span id='topic+layout_logging'></span>

<h3>Description</h3>

<p>Format a log record as the logging package does by default
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_logging(
  level,
  msg,
  namespace = NA_character_,
  .logcall = sys.call(),
  .topcall = sys.call(-1),
  .topenv = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_logging_+3A_level">level</code></td>
<td>
<p>log level, see <code><a href="#topic+log_levels">log_levels</a></code> for more details</p>
</td></tr>
<tr><td><code id="layout_logging_+3A_msg">msg</code></td>
<td>
<p>string message</p>
</td></tr>
<tr><td><code id="layout_logging_+3A_namespace">namespace</code></td>
<td>
<p>string referring to the <code>logger</code> environment / config to be used to override the target of the message record to be used instead of the default namespace, which is defined by the R package name from which the logger was called, and falls back to a common, global namespace.</p>
</td></tr>
<tr><td><code id="layout_logging_+3A_.logcall">.logcall</code></td>
<td>
<p>the logging call being evaluated (useful in formatters and layouts when you want to have access to the raw, unevaluated R expression)</p>
</td></tr>
<tr><td><code id="layout_logging_+3A_.topcall">.topcall</code></td>
<td>
<p>R expression from which the logging function was called (useful in formatters and layouts to extract the calling function's name or arguments)</p>
</td></tr>
<tr><td><code id="layout_logging_+3A_.topenv">.topenv</code></td>
<td>
<p>original frame of the <code>.topcall</code> calling function where the formatter function will be evaluated and that is used to look up the <code>namespace</code> as well via <code>logger:::top_env_name</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector
</p>


<h3>See Also</h3>

<p>This is a <code><a href="#topic+log_layout">log_layout</a></code>, for alternatives, see <code><a href="#topic+layout_blank">layout_blank</a></code>, <code><a href="#topic+layout_glue">layout_glue</a></code>, <code><a href="#topic+layout_glue_colors">layout_glue_colors</a></code>, <code><a href="#topic+layout_json">layout_json</a></code>, <code><a href="#topic+layout_json_parser">layout_json_parser</a></code>, or generator functions such as <code><a href="#topic+layout_glue_generator">layout_glue_generator</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
log_layout(layout_logging)
log_info(42)
log_info(42, namespace = 'everything')

devtools::load_all(system.file('demo-packages/logger-tester-package', package = 'logger'))
logger_tester_function(INFO, 42)

## End(Not run)
</code></pre>

<hr>
<h2 id='layout_simple'>Format a log record by concatenating the log level, timestamp and message</h2><span id='topic+layout_simple'></span>

<h3>Description</h3>

<p>Format a log record by concatenating the log level, timestamp and message
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_simple(
  level,
  msg,
  namespace = NA_character_,
  .logcall = sys.call(),
  .topcall = sys.call(-1),
  .topenv = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_simple_+3A_level">level</code></td>
<td>
<p>log level, see <code><a href="#topic+log_levels">log_levels</a></code> for more details</p>
</td></tr>
<tr><td><code id="layout_simple_+3A_msg">msg</code></td>
<td>
<p>string message</p>
</td></tr>
<tr><td><code id="layout_simple_+3A_namespace">namespace</code></td>
<td>
<p>string referring to the <code>logger</code> environment / config to be used to override the target of the message record to be used instead of the default namespace, which is defined by the R package name from which the logger was called, and falls back to a common, global namespace.</p>
</td></tr>
<tr><td><code id="layout_simple_+3A_.logcall">.logcall</code></td>
<td>
<p>the logging call being evaluated (useful in formatters and layouts when you want to have access to the raw, unevaluated R expression)</p>
</td></tr>
<tr><td><code id="layout_simple_+3A_.topcall">.topcall</code></td>
<td>
<p>R expression from which the logging function was called (useful in formatters and layouts to extract the calling function's name or arguments)</p>
</td></tr>
<tr><td><code id="layout_simple_+3A_.topenv">.topenv</code></td>
<td>
<p>original frame of the <code>.topcall</code> calling function where the formatter function will be evaluated and that is used to look up the <code>namespace</code> as well via <code>logger:::top_env_name</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector
</p>


<h3>See Also</h3>

<p>This is a <code><a href="#topic+log_layout">log_layout</a></code>, for alternatives, see <code><a href="#topic+layout_blank">layout_blank</a></code>, <code><a href="#topic+layout_glue">layout_glue</a></code>, <code><a href="#topic+layout_glue_colors">layout_glue_colors</a></code>, <code><a href="#topic+layout_json">layout_json</a></code>, <code><a href="#topic+layout_json_parser">layout_json_parser</a></code>, or generator functions such as <code><a href="#topic+layout_glue_generator">layout_glue_generator</a></code>
</p>

<hr>
<h2 id='layout_syslognet'>Format a log record for syslognet</h2><span id='topic+layout_syslognet'></span>

<h3>Description</h3>

<p>Format a log record for syslognet.
This function converts the logger log level to a
log severity level according to RFC 5424 &quot;The Syslog Protocol&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_syslognet(
  level,
  msg,
  namespace = NA_character_,
  .logcall = sys.call(),
  .topcall = sys.call(-1),
  .topenv = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_syslognet_+3A_level">level</code></td>
<td>
<p>log level, see <code><a href="#topic+log_levels">log_levels</a></code> for more details</p>
</td></tr>
<tr><td><code id="layout_syslognet_+3A_msg">msg</code></td>
<td>
<p>string message</p>
</td></tr>
<tr><td><code id="layout_syslognet_+3A_namespace">namespace</code></td>
<td>
<p>string referring to the <code>logger</code> environment / config to be used to override the target of the message record to be used instead of the default namespace, which is defined by the R package name from which the logger was called, and falls back to a common, global namespace.</p>
</td></tr>
<tr><td><code id="layout_syslognet_+3A_.logcall">.logcall</code></td>
<td>
<p>the logging call being evaluated (useful in formatters and layouts when you want to have access to the raw, unevaluated R expression)</p>
</td></tr>
<tr><td><code id="layout_syslognet_+3A_.topcall">.topcall</code></td>
<td>
<p>R expression from which the logging function was called (useful in formatters and layouts to extract the calling function's name or arguments)</p>
</td></tr>
<tr><td><code id="layout_syslognet_+3A_.topenv">.topenv</code></td>
<td>
<p>original frame of the <code>.topcall</code> calling function where the formatter function will be evaluated and that is used to look up the <code>namespace</code> as well via <code>logger:::top_env_name</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with a severity attribute.
</p>

<hr>
<h2 id='log_appender'>Get or set log record appender function</h2><span id='topic+log_appender'></span>

<h3>Description</h3>

<p>Get or set log record appender function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_appender(appender = NULL, namespace = "global", index = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log_appender_+3A_appender">appender</code></td>
<td>
<p>function delivering a log record to the destination, eg <code><a href="#topic+appender_console">appender_console</a></code>, <code><a href="#topic+appender_file">appender_file</a></code> or <code><a href="#topic+appender_tee">appender_tee</a></code>, default NULL</p>
</td></tr>
<tr><td><code id="log_appender_+3A_namespace">namespace</code></td>
<td>
<p>logger namespace</p>
</td></tr>
<tr><td><code id="log_appender_+3A_index">index</code></td>
<td>
<p>index of the logger within the namespace</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+logger">logger</a></code>, <code><a href="#topic+log_threshold">log_threshold</a></code>, <code><a href="#topic+log_layout">log_layout</a></code> and <code><a href="#topic+log_formatter">log_formatter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## change appender to "tee" that writes to the console and a file as well
t &lt;- tempfile()
log_appender(appender_tee(t))
log_info(42)
log_info(42:44)
readLines(t)

## poor man's tee by stacking loggers in the namespace
t &lt;- tempfile()
log_appender(appender_console)
log_appender(appender_file(t), index = 2)
log_info(42)
readLines(t)

## End(Not run)
</code></pre>

<hr>
<h2 id='log_config_setter'>Base Logging Function</h2><span id='topic+log_config_setter'></span>

<h3>Description</h3>

<p>Base Logging Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_config_setter(fun_name, arg, namespace, index)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log_config_setter_+3A_fun_name">fun_name</code></td>
<td>
<p>string a full name of log function</p>
</td></tr>
<tr><td><code id="log_config_setter_+3A_arg">arg</code></td>
<td>
<p>see <code><a href="#topic+log_levels">log_levels</a></code></p>
</td></tr>
<tr><td><code id="log_config_setter_+3A_namespace">namespace</code></td>
<td>
<p>logger namespace</p>
</td></tr>
<tr><td><code id="log_config_setter_+3A_index">index</code></td>
<td>
<p>index of the logger within the namespace</p>
</td></tr>
</table>


<h3>Value</h3>

<p>currently set or return log function property
</p>

<hr>
<h2 id='log_errors'>Injects a logger call to standard errors</h2><span id='topic+log_errors'></span>

<h3>Description</h3>

<p>This function uses <code>trace</code> to add a <code>log_error</code> function call when <code>stop</code> is called to log the error messages with the <code>logger</code> layout and appender.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_errors(muffle = getOption("logger_muffle_errors", FALSE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log_errors_+3A_muffle">muffle</code></td>
<td>
<p>if TRUE, the error is not thrown after being logged</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
log_errors()
stop('foobar')

## End(Not run)
</code></pre>

<hr>
<h2 id='log_eval'>Evaluate an expression and log results</h2><span id='topic+log_eval'></span>

<h3>Description</h3>

<p>Evaluate an expression and log results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_eval(expr, level = TRACE, multiline = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log_eval_+3A_expr">expr</code></td>
<td>
<p>R expression to be evaluated while logging the expression itself along with the result</p>
</td></tr>
<tr><td><code id="log_eval_+3A_level">level</code></td>
<td>
<p><code><a href="#topic+log_levels">log_levels</a></code></p>
</td></tr>
<tr><td><code id="log_eval_+3A_multiline">multiline</code></td>
<td>
<p>setting to <code>FALSE</code> will print both the expression (enforced to be on one line by removing line-breaks if any) and its result on a single line separated by <code>=&gt;</code>, while setting to <code>TRUE</code> will log the expression and the result in separate sections reserving line-breaks and rendering the printed results</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
log_eval(pi * 2, level = INFO)

## lowering the log level threshold so that we don't have to set a higher level in log_eval
log_threshold(TRACE)
log_eval(x &lt;- 4)
log_eval(sqrt(x))

## log_eval can be called in-line as well as returning the return value of the expression
x &lt;- log_eval(mean(runif(1e3)))
x

## https://twitter.com/krlmlr/status/1067864829547999232
f &lt;- sqrt
g &lt;- mean
x &lt;- 1:31
log_eval(f(g(x)), level = INFO)
log_eval(y &lt;- f(g(x)), level = INFO)

## returning a function
log_eval(f &lt;- sqrt)
log_eval(f)

## evaluating something returning a wall of "text"
log_eval(f &lt;- log_eval)
log_eval(f &lt;- log_eval, multiline = TRUE)

## doing something computationally intensive
log_eval(system.time(for(i in 1:100) mad(runif(1000))), multiline = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='log_failure'>Logs the error message to console before failing</h2><span id='topic+log_failure'></span>

<h3>Description</h3>

<p>Logs the error message to console before failing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_failure(expression)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log_failure_+3A_expression">expression</code></td>
<td>
<p>call</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
log_failure('foobar')
log_failure(foobar)

## End(Not run)
</code></pre>

<hr>
<h2 id='log_formatter'>Get or set log message formatter</h2><span id='topic+log_formatter'></span>

<h3>Description</h3>

<p>Get or set log message formatter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_formatter(formatter = NULL, namespace = "global", index = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log_formatter_+3A_formatter">formatter</code></td>
<td>
<p>function defining how R objects are converted into a single string, eg <code><a href="#topic+formatter_paste">formatter_paste</a></code>, <code><a href="#topic+formatter_sprintf">formatter_sprintf</a></code>, <code><a href="#topic+formatter_glue">formatter_glue</a></code>, <code><a href="#topic+formatter_glue_or_sprintf">formatter_glue_or_sprintf</a></code>, <code><a href="#topic+formatter_logging">formatter_logging</a></code>, default NULL</p>
</td></tr>
<tr><td><code id="log_formatter_+3A_namespace">namespace</code></td>
<td>
<p>logger namespace</p>
</td></tr>
<tr><td><code id="log_formatter_+3A_index">index</code></td>
<td>
<p>index of the logger within the namespace</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+logger">logger</a></code>, <code><a href="#topic+log_threshold">log_threshold</a></code>, <code><a href="#topic+log_appender">log_appender</a></code> and <code><a href="#topic+log_layout">log_layout</a></code>
</p>

<hr>
<h2 id='log_layout'>Get or set log record layout</h2><span id='topic+log_layout'></span>

<h3>Description</h3>

<p>Get or set log record layout
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_layout(layout = NULL, namespace = "global", index = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log_layout_+3A_layout">layout</code></td>
<td>
<p>function defining the structure of a log record, eg <code><a href="#topic+layout_simple">layout_simple</a></code>, <code><a href="#topic+layout_glue">layout_glue</a></code> or <code><a href="#topic+layout_glue_colors">layout_glue_colors</a></code>, <code><a href="#topic+layout_json">layout_json</a></code>, or generator functions such as <code><a href="#topic+layout_glue_generator">layout_glue_generator</a></code>, default NULL</p>
</td></tr>
<tr><td><code id="log_layout_+3A_namespace">namespace</code></td>
<td>
<p>logger namespace</p>
</td></tr>
<tr><td><code id="log_layout_+3A_index">index</code></td>
<td>
<p>index of the logger within the namespace</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+logger">logger</a></code>, <code><a href="#topic+log_threshold">log_threshold</a></code>, <code><a href="#topic+log_appender">log_appender</a></code> and <code><a href="#topic+log_formatter">log_formatter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
log_layout(layout_json())
log_info(42)

## End(Not run)
</code></pre>

<hr>
<h2 id='log_level'>Log a message with given log level</h2><span id='topic+log_level'></span><span id='topic+log_fatal'></span><span id='topic+log_error'></span><span id='topic+log_warn'></span><span id='topic+log_success'></span><span id='topic+log_info'></span><span id='topic+log_debug'></span><span id='topic+log_trace'></span>

<h3>Description</h3>

<p>Log a message with given log level
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_level(level, ..., namespace = NA_character_,
  .logcall = sys.call(), .topcall = sys.call(-1), .topenv = parent.frame())

log_trace(..., namespace = NA_character_,
  .logcall = sys.call(), .topcall = sys.call(-1), .topenv = parent.frame())

log_debug(..., namespace = NA_character_,
  .logcall = sys.call(), .topcall = sys.call(-1), .topenv = parent.frame())

log_info(..., namespace = NA_character_,
  .logcall = sys.call(), .topcall = sys.call(-1), .topenv = parent.frame())

log_success(..., namespace = NA_character_,
  .logcall = sys.call(), .topcall = sys.call(-1), .topenv = parent.frame())

log_warn(..., namespace = NA_character_,
  .logcall = sys.call(), .topcall = sys.call(-1), .topenv = parent.frame())

log_error(..., namespace = NA_character_,
  .logcall = sys.call(), .topcall = sys.call(-1), .topenv = parent.frame())

log_fatal(..., namespace = NA_character_,
  .logcall = sys.call(), .topcall = sys.call(-1), .topenv = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log_level_+3A_level">level</code></td>
<td>
<p>log level, see <code><a href="#topic+log_levels">log_levels</a></code> for more details</p>
</td></tr>
<tr><td><code id="log_level_+3A_...">...</code></td>
<td>
<p>R objects that can be converted to a character vector via the active message formatter function</p>
</td></tr>
<tr><td><code id="log_level_+3A_namespace">namespace</code></td>
<td>
<p>string referring to the <code>logger</code> environment / config to be used to override the target of the message record to be used instead of the default namespace, which is defined by the R package name from which the logger was called, and falls back to a common, global namespace.</p>
</td></tr>
<tr><td><code id="log_level_+3A_.logcall">.logcall</code></td>
<td>
<p>the logging call being evaluated (useful in formatters and layouts when you want to have access to the raw, unevaluated R expression)</p>
</td></tr>
<tr><td><code id="log_level_+3A_.topcall">.topcall</code></td>
<td>
<p>R expression from which the logging function was called (useful in formatters and layouts to extract the calling function's name or arguments)</p>
</td></tr>
<tr><td><code id="log_level_+3A_.topenv">.topenv</code></td>
<td>
<p>original frame of the <code>.topcall</code> calling function where the formatter function will be evaluated and that is used to look up the <code>namespace</code> as well via <code>logger:::top_env_name</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisible <code>list</code> of <code>logger</code> objects. See <code><a href="#topic+logger">logger</a></code> for more details on the format/
</p>


<h3>See Also</h3>

<p><code><a href="#topic+logger">logger</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
log_level(INFO, 'hi there')
log_info('hi there')

## output omitted
log_debug('hi there')

## lower threshold and retry
log_threshold(TRACE)
log_debug('hi there')

## multiple lines
log_info('ok {1:3} + {1:3} = {2*(1:3)}')

log_layout(layout_json())
log_info('ok {1:3} + {1:3} = {2*(1:3)}')

## note for the JSON output, glue is not automatically applied
log_info(glue::glue('ok {1:3} + {1:3} = {2*(1:3)}'))

## End(Not run)
</code></pre>

<hr>
<h2 id='log_messages'>Injects a logger call to standard messages</h2><span id='topic+log_messages'></span>

<h3>Description</h3>

<p>This function uses <code>trace</code> to add a <code>log_info</code> function call when <code>message</code> is called to log the informative messages with the <code>logger</code> layout and appender.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_messages()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
log_messages()
message('hi there')

## End(Not run)
</code></pre>

<hr>
<h2 id='log_namespaces'>Looks up logger namespaces</h2><span id='topic+log_namespaces'></span>

<h3>Description</h3>

<p>Looks up logger namespaces
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_namespaces()
</code></pre>


<h3>Value</h3>

<p>character vector of namespace names
</p>

<hr>
<h2 id='log_separator'>Logs a long line to stand out from the console</h2><span id='topic+log_separator'></span>

<h3>Description</h3>

<p>Logs a long line to stand out from the console
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_separator(
  level = INFO,
  namespace = NA_character_,
  separator = "=",
  width = 80,
  .topcall = sys.call()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log_separator_+3A_level">level</code></td>
<td>
<p>log level, see <code><a href="#topic+log_levels">log_levels</a></code> for more details</p>
</td></tr>
<tr><td><code id="log_separator_+3A_namespace">namespace</code></td>
<td>
<p>string referring to the <code>logger</code> environment / config to be used to override the target of the message record to be used instead of the default namespace, which is defined by the R package name from which the logger was called, and falls back to a common, global namespace.</p>
</td></tr>
<tr><td><code id="log_separator_+3A_separator">separator</code></td>
<td>
<p>character to be used as a separator</p>
</td></tr>
<tr><td><code id="log_separator_+3A_width">width</code></td>
<td>
<p>max width of message &ndash; longer text will be wrapped into multiple lines</p>
</td></tr>
<tr><td><code id="log_separator_+3A_.topcall">.topcall</code></td>
<td>
<p>R expression from which the logging function was called (useful in formatters and layouts to extract the calling function's name or arguments)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+log_with_separator">log_with_separator</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>log_separator()
log_separator(ERROR, separator = '!', width = 60)
log_separator(ERROR, separator = '!', width = 100)
logger &lt;- layout_glue_generator(format = '{node}/{pid}/{namespace}/{fn} {time} {level}: {msg}')
log_layout(logger)
log_separator(ERROR, separator = '!', width = 100)
log_layout(layout_blank)
log_separator(ERROR, separator = '!', width = 80)
</code></pre>

<hr>
<h2 id='log_shiny_input_changes'>Auto logging input changes in Shiny app</h2><span id='topic+log_shiny_input_changes'></span>

<h3>Description</h3>

<p>This is to be called in the <code>server</code> section of the Shiny app.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_shiny_input_changes(
  input,
  level = INFO,
  namespace = NA_character_,
  excluded_inputs = character()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log_shiny_input_changes_+3A_input">input</code></td>
<td>
<p>passed from Shiny's <code>server</code></p>
</td></tr>
<tr><td><code id="log_shiny_input_changes_+3A_level">level</code></td>
<td>
<p>log level</p>
</td></tr>
<tr><td><code id="log_shiny_input_changes_+3A_namespace">namespace</code></td>
<td>
<p>the name of the namespace</p>
</td></tr>
<tr><td><code id="log_shiny_input_changes_+3A_excluded_inputs">excluded_inputs</code></td>
<td>
<p>character vector of input names to exclude from logging</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(shiny)

ui &lt;- bootstrapPage(
    numericInput('mean', 'mean', 0),
    numericInput('sd', 'sd', 1),
    textInput('title', 'title', 'title'),
    textInput('foo', 'This is not used at all, still gets logged', 'foo'),
    passwordInput('password', 'Password not to be logged', 'secret'),
    plotOutput('plot')
)

server &lt;- function(input, output) {

    logger::log_shiny_input_changes(input, excluded_inputs = 'password')

    output$plot &lt;- renderPlot({
        hist(rnorm(1e3, input$mean, input$sd), main = input$title)
    })

}

shinyApp(ui = ui, server = server)

## End(Not run)
</code></pre>

<hr>
<h2 id='log_threshold'>Get or set log level threshold</h2><span id='topic+log_threshold'></span>

<h3>Description</h3>

<p>Get or set log level threshold
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_threshold(level = NULL, namespace = "global", index = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log_threshold_+3A_level">level</code></td>
<td>
<p>see <code><a href="#topic+log_levels">log_levels</a></code></p>
</td></tr>
<tr><td><code id="log_threshold_+3A_namespace">namespace</code></td>
<td>
<p>logger namespace</p>
</td></tr>
<tr><td><code id="log_threshold_+3A_index">index</code></td>
<td>
<p>index of the logger within the namespace</p>
</td></tr>
</table>


<h3>Value</h3>

<p>currently set log level threshold
</p>


<h3>See Also</h3>

<p><code><a href="#topic+logger">logger</a></code>, <code><a href="#topic+log_layout">log_layout</a></code>, <code><a href="#topic+log_formatter">log_formatter</a></code>, <code><a href="#topic+log_appender">log_appender</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## check the currently set log level threshold
log_threshold()

## change the log level threshold to WARN
log_threshold(WARN)
log_info(1)
log_warn(2)

## add another logger with a lower log level threshold and check the number of logged messages
log_threshold(INFO, index = 2)
log_info(1)
log_warn(2)

## set the log level threshold in all namespaces to ERROR
log_threshold(ERROR, namespace =  log_namespaces())

## End(Not run)
</code></pre>

<hr>
<h2 id='log_tictoc'>Tic-toc logging</h2><span id='topic+log_tictoc'></span>

<h3>Description</h3>

<p>Tic-toc logging
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_tictoc(..., level = INFO, namespace = NA_character_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log_tictoc_+3A_...">...</code></td>
<td>
<p>passed to <code>log_level</code></p>
</td></tr>
<tr><td><code id="log_tictoc_+3A_level">level</code></td>
<td>
<p>see <code><a href="#topic+log_levels">log_levels</a></code></p>
</td></tr>
<tr><td><code id="log_tictoc_+3A_namespace">namespace</code></td>
<td>
<p>x</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thanks to Neal Fultz for the idea and original implementation!
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
log_tictoc('warming up')
Sys.sleep(0.1)
log_tictoc('running')
Sys.sleep(0.1)
log_tictoc('running')
Sys.sleep(runif(1))
log_tictoc('and running')

## End(Not run)
</code></pre>

<hr>
<h2 id='log_warnings'>Injects a logger call to standard warnings</h2><span id='topic+log_warnings'></span>

<h3>Description</h3>

<p>This function uses <code>trace</code> to add a <code>log_warn</code> function call when <code>warning</code> is called to log the warning messages with the <code>logger</code> layout and appender.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_warnings(muffle = getOption("logger_muffle_warnings", FALSE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log_warnings_+3A_muffle">muffle</code></td>
<td>
<p>if TRUE, the warning is not shown after being logged</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
log_warnings()
for (i in 1:5) { Sys.sleep(runif(1)); warning(i) }

## End(Not run)
</code></pre>

<hr>
<h2 id='log_with_separator'>Logs a message in a very visible way</h2><span id='topic+log_with_separator'></span>

<h3>Description</h3>

<p>Logs a message in a very visible way
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_with_separator(
  ...,
  level = INFO,
  namespace = NA_character_,
  separator = "=",
  width = 80
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log_with_separator_+3A_...">...</code></td>
<td>
<p>R objects that can be converted to a character vector via the active message formatter function</p>
</td></tr>
<tr><td><code id="log_with_separator_+3A_level">level</code></td>
<td>
<p>log level, see <code><a href="#topic+log_levels">log_levels</a></code> for more details</p>
</td></tr>
<tr><td><code id="log_with_separator_+3A_namespace">namespace</code></td>
<td>
<p>string referring to the <code>logger</code> environment / config to be used to override the target of the message record to be used instead of the default namespace, which is defined by the R package name from which the logger was called, and falls back to a common, global namespace.</p>
</td></tr>
<tr><td><code id="log_with_separator_+3A_separator">separator</code></td>
<td>
<p>character to be used as a separator</p>
</td></tr>
<tr><td><code id="log_with_separator_+3A_width">width</code></td>
<td>
<p>max width of message &ndash; longer text will be wrapped into multiple lines</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+log_separator">log_separator</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>log_with_separator('An important message')
log_with_separator('Some critical KPI down!!!', separator = '$')
log_with_separator('This message is worth a {1e3} words')
log_with_separator(paste(
  'A very important message with a bunch of extra words that will',
  'eventually wrap into a multi-line message for our quite nice demo :wow:'))
log_with_separator(paste(
  'A very important message with a bunch of extra words that will',
  'eventually wrap into a multi-line message for our quite nice demo :wow:'),
  width = 60)
log_with_separator('Boo!', level = FATAL)
log_layout(layout_blank)
log_with_separator('Boo!', level = FATAL)
logger &lt;- layout_glue_generator(format = '{node}/{pid}/{namespace}/{fn} {time} {level}: {msg}')
log_layout(logger)
log_with_separator('Boo!', level = FATAL, width = 120)
</code></pre>

<hr>
<h2 id='logger'>Generate logging utility</h2><span id='topic+logger'></span>

<h3>Description</h3>

<p>A logger consists of a log level <code>threshold</code>, a log message <code>formatter</code> function, a log record <code>layout</code> formatting function and the <code>appender</code> function deciding on the destination of the log record. For more details, see the package <code>README.md</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logger(threshold, formatter, layout, appender)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logger_+3A_threshold">threshold</code></td>
<td>
<p>omit log messages below this <code><a href="#topic+log_levels">log_levels</a></code></p>
</td></tr>
<tr><td><code id="logger_+3A_formatter">formatter</code></td>
<td>
<p>function pre-processing the message of the log record when it's not wrapped in a <code><a href="#topic+skip_formatter">skip_formatter</a></code> call</p>
</td></tr>
<tr><td><code id="logger_+3A_layout">layout</code></td>
<td>
<p>function rendering the layout of the actual log record</p>
</td></tr>
<tr><td><code id="logger_+3A_appender">appender</code></td>
<td>
<p>function writing the log record</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, a general logger definition is created when loading the <code>logger</code> package, that uses
</p>

<ol>
<li> <p><code><a href="#topic+INFO">INFO</a></code> (or as per the <code>LOGGER_LOG_LEVEL</code> environment variable override) as the log level threshold
</p>
</li>
<li> <p><code><a href="#topic+layout_simple">layout_simple</a></code> as the layout function showing the log level, timestamp and log message
</p>
</li>
<li> <p><code><a href="#topic+formatter_glue">formatter_glue</a></code> (or <code><a href="#topic+formatter_sprintf">formatter_sprintf</a></code> if <span class="pkg">glue</span> is not installed) as the default formatter function transforming the R objects to be logged to a character vector
</p>
</li>
<li> <p><code><a href="#topic+appender_console">appender_console</a></code> as the default log record destination
</p>
</li></ol>



<h3>Value</h3>

<p>A function taking the log <code>level</code> to compare with the set threshold, all the <code>...</code> arguments passed to the formatter function, besides the standard <code>namespace</code>, <code>.logcall</code>, <code>.topcall</code> and <code>.topenv</code> arguments (see <code><a href="#topic+log_level">log_level</a></code> for more details). The function invisibly returns a list including the original <code>level</code>, <code>namespace</code>, all <code>...</code> transformed to a list as <code>params</code>, the log <code>message</code> (after calling the <code>formatter</code> function) and the log <code>record</code> (after calling the <code>layout</code> function), and a list of <code>handlers</code> with the <code>formatter</code>, <code>layout</code> and <code>appender</code> functions.
</p>


<h3>Note</h3>

<p>It's quite unlikely that you need to call this function directly, but instead set the logger parameters and functions at <code><a href="#topic+log_threshold">log_threshold</a></code>, <code><a href="#topic+log_formatter">log_formatter</a></code>, <code><a href="#topic+log_layout">log_layout</a></code> and <code><a href="#topic+log_appender">log_appender</a></code> and then call <code><a href="#topic+log_levels">log_levels</a></code> and its derivatives, such as <code><a href="#topic+log_info">log_info</a></code> directly.
</p>


<h3>References</h3>

<p>For more details, see the Anatomy of a Log Request vignette at <a href="https://daroczig.github.io/logger/articles/anatomy.html">https://daroczig.github.io/logger/articles/anatomy.html</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
do.call(logger, logger:::namespaces$global[[1]])(INFO, 42)
do.call(logger, logger:::namespaces$global[[1]])(INFO, '{pi}')
x &lt;- 42
do.call(logger, logger:::namespaces$global[[1]])(INFO, '{x}^2 = {x^2}')

## End(Not run)
</code></pre>

<hr>
<h2 id='OFF'>Log levels</h2><span id='topic+OFF'></span><span id='topic+log_levels'></span><span id='topic+FATAL'></span><span id='topic+ERROR'></span><span id='topic+WARN'></span><span id='topic+SUCCESS'></span><span id='topic+INFO'></span><span id='topic+DEBUG'></span><span id='topic+TRACE'></span>

<h3>Description</h3>

<p>The standard Apache logj4 log levels plus a custom level for <code>SUCCESS</code>. For the full list of these log levels and suggested usage, check the below Details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TRACE

DEBUG

INFO

SUCCESS

WARN

ERROR

FATAL

OFF
</code></pre>


<h3>Format</h3>

<p>An object of class <code>loglevel</code> (inherits from <code>integer</code>) of length 1.
</p>


<h3>Details</h3>

<p>List of supported log levels:
</p>

<ol>
<li> <p><code>OFF</code> No events will be logged
</p>
</li>
<li> <p><code>FATAL</code> Severe error that will prevent the application from continuing
</p>
</li>
<li> <p><code>ERROR</code> An error in the application, possibly recoverable
</p>
</li>
<li> <p><code>WARN</code> An event that might possible lead to an error
</p>
</li>
<li> <p><code>SUCCESS</code> An explicit success event above the INFO level that you want to log
</p>
</li>
<li> <p><code>INFO</code> An event for informational purposes
</p>
</li>
<li> <p><code>DEBUG</code> A general debugging event
</p>
</li>
<li> <p><code>TRACE</code> A fine-grained debug message, typically capturing the flow through the application.
</p>
</li></ol>



<h3>References</h3>

<p><a href="https://logging.apache.org/log4j/2.x/javadoc/log4j-api/org/apache/logging/log4j/Level.html">https://logging.apache.org/log4j/2.x/javadoc/log4j-api/org/apache/logging/log4j/Level.html</a>, <a href="https://logging.apache.org/log4j/2.x/manual/customloglevels.html">https://logging.apache.org/log4j/2.x/manual/customloglevels.html</a>
</p>

<hr>
<h2 id='skip_formatter'>Skip the formatter function</h2><span id='topic+skip_formatter'></span>

<h3>Description</h3>

<p>Adds the <code>skip_formatter</code> attribute to an object so that logger will skip calling the formatter function(s). This is useful if you want to preprocess the log message with a custom function instead of the active formatter function(s). Note that the <code>message</code> should be a string, and <code>skip_formatter</code> should be the only input for the logging function to make this work.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skip_formatter(message, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skip_formatter_+3A_message">message</code></td>
<td>
<p>character vector directly passed to the appender function in <code><a href="#topic+logger">logger</a></code></p>
</td></tr>
<tr><td><code id="skip_formatter_+3A_...">...</code></td>
<td>
<p>should be never set</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector  with <code>skip_formatter</code> attribute set to <code>TRUE</code>
</p>

<hr>
<h2 id='top_env_name'>Returns the name of the top level environment from which the logger was called</h2><span id='topic+top_env_name'></span>

<h3>Description</h3>

<p>Returns the name of the top level environment from which the logger was called
</p>


<h3>Usage</h3>

<pre><code class='language-R'>top_env_name(.topenv = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="top_env_name_+3A_.topenv">.topenv</code></td>
<td>
<p>call environment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string
</p>

<hr>
<h2 id='validate_log_level'>Assure valid log level</h2><span id='topic+validate_log_level'></span>

<h3>Description</h3>

<p>Assure valid log level
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_log_level(level)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_log_level_+3A_level">level</code></td>
<td>
<p><code><a href="#topic+log_levels">log_levels</a></code> object or string representation</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+log_levels">log_levels</a></code> object
</p>

<hr>
<h2 id='warn_if_globalCallingHandlers_is_not_available'>Warn to update R to 4+</h2><span id='topic+warn_if_globalCallingHandlers_is_not_available'></span>

<h3>Description</h3>

<p>Warn to update R to 4+
</p>


<h3>Usage</h3>

<pre><code class='language-R'>warn_if_globalCallingHandlers_is_not_available()
</code></pre>

<hr>
<h2 id='with_log_threshold'>Evaluate R expression with a temporarily updated log level threshold</h2><span id='topic+with_log_threshold'></span>

<h3>Description</h3>

<p>Evaluate R expression with a temporarily updated log level threshold
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_log_threshold(
  expression,
  threshold = ERROR,
  namespace = "global",
  index = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with_log_threshold_+3A_expression">expression</code></td>
<td>
<p>R command</p>
</td></tr>
<tr><td><code id="with_log_threshold_+3A_threshold">threshold</code></td>
<td>
<p><code><a href="#topic+log_levels">log_levels</a></code></p>
</td></tr>
<tr><td><code id="with_log_threshold_+3A_namespace">namespace</code></td>
<td>
<p>logger namespace</p>
</td></tr>
<tr><td><code id="with_log_threshold_+3A_index">index</code></td>
<td>
<p>index of the logger within the namespace</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
log_threshold(TRACE)
log_trace('Logging everything!')
x &lt;- with_log_threshold({
  log_info('Now we are temporarily suppressing eg INFO messages')
  log_warn('WARN')
  log_debug('Debug messages are suppressed as well')
  log_error('ERROR')
  invisible(42)
}, threshold = WARN)
x
log_trace('DONE')

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
