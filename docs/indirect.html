<!DOCTYPE html><html><head><title>Help for package indirect</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {indirect}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#checkX'><p>Helper function that checks for sensible covariate matrix.</p></a></li>
<li><a href='#CNdiag'><p>Function to check condition number diagnostic.</p></a></li>
<li><a href='#designLink'><p>Create list with information for the elicitation session</p></a></li>
<li><a href='#dGompertzNorm'><p>density for Gompertz transformed univariate Gaussian</p></a></li>
<li><a href='#dLogitNorm'><p>density for logit transformed univariate Gaussian</p></a></li>
<li><a href='#elicitPt'><p>Function to create or update elicitation at a given design point.</p></a></li>
<li><a href='#indirect'><p>indirect: A package for assisting indirect elicitation of priors for generalised linear models.</p></a></li>
<li><a href='#makeSweave'><p>Function to create summary document from a saved elicitation record.</p></a></li>
<li><a href='#muSigma'><p>Function to estimate mean and covariance for unknown parameters</p>
<code class="reqn">\beta</code>.</a></li>
<li><a href='#mV'><p>Helper function that translates elicited quantiles of target into independent</p>
conditional means normal prior for a defined inverse link function.</a></li>
<li><a href='#pdist'><p>Helper function that gives the probability distribution function for design</p>
point.</a></li>
<li><a href='#plotDesignPoint'><p>Plot elicited data, fitted marginals or model output</p></a></li>
<li><a href='#saveRecord'><p>Function to save elicitation record.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Elicitation of Independent Conditional Means Priors for
Generalised Linear Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-02-09</td>
</tr>
<tr>
<td>Author:</td>
<td>Geoffrey R. Hosack</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Geoff Hosack &lt;geoff.hosack@csiro.au&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions are provided to facilitate prior elicitation for Bayesian generalised linear models using independent conditional means priors. The package supports the elicitation of multivariate normal priors for generalised linear models. The approach can be applied to indirect elicitation for a generalised linear model that is linear in the parameters. The package is designed such that the facilitator executes functions within the R console during the elicitation session to provide graphical and numerical feedback at each design point. Various methodologies for eliciting fractiles (equivalently, percentiles or quantiles) are supported, including versions of the approach of Hosack et al. (2017) &lt;<a href="https://doi.org/10.1016%2Fj.ress.2017.06.011">doi:10.1016/j.ress.2017.06.011</a>&gt;. For example, experts may be asked to provide central credible intervals that correspond to a certain probability. Or experts may be allowed to vary the probability allocated to the central credible interval for each design point. Additionally, a median may or may not be elicited. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, gplots</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tools, utils</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-02-09 05:12:00 UTC; hos06b</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-02-09 05:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='checkX'>Helper function that checks for sensible covariate matrix.</h2><span id='topic+checkX'></span>

<h3>Description</h3>

<p>Helper function that checks for sensible covariate matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkX(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkX_+3A_x">X</code></td>
<td>
<p>numeric matrix of covariates, <code class="reqn">n</code> design points by <code class="reqn">p</code>
covariates, for a given model and design points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>throws an error if not full rank.
</p>

<hr>
<h2 id='CNdiag'>Function to check condition number diagnostic.</h2><span id='topic+CNdiag'></span>

<h3>Description</h3>

<p>This function calculates the condition number of  the rescaled <code class="reqn">n x
p</code> design matrix <code class="reqn">X</code> such that each column has unit length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CNdiag(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CNdiag_+3A_x">X</code></td>
<td>
<p>Design matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar giving the condition number of the rescaled design matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(rnorm(16), nrow = 4)
CNdiag(X)
</code></pre>

<hr>
<h2 id='designLink'>Create list with information for the elicitation session</h2><span id='topic+designLink'></span>

<h3>Description</h3>

<p>This builds the structure that will store elicited data. The linear predictor
has a normal prior <code class="reqn">g(\theta) ~ N(m, V)</code>, <code class="reqn">\theta</code> is the elicitation
target. Link functions <code class="reqn">g(.)</code>: <code>logit</code>, <code>log</code>, <code>cloglog</code>, 
<code>identity</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>designLink(
  design,
  link = "identity",
  target = "Target",
  CI.prob = 1/2,
  expertID = "Expert",
  facilitator = "Facilitator",
  rapporteur = "none",
  intro.comments = "This is a record of the elicitation session.",
  fit.method = "KL"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="designLink_+3A_design">design</code></td>
<td>
<p>a dataframe with covariate values that will be displayed to the
expert(s) during the elicitation session.</p>
</td></tr>
<tr><td><code id="designLink_+3A_link">link</code></td>
<td>
<p>character <code>logit</code>, <code>log</code>, <code>cloglog</code>, 
<code>identity</code></p>
</td></tr>
<tr><td><code id="designLink_+3A_target">target</code></td>
<td>
<p>character, name of target parameter of elicitation exercise</p>
</td></tr>
<tr><td><code id="designLink_+3A_ci.prob">CI.prob</code></td>
<td>
<p>numeric, a fraction between 0 and 1 that defines probability 
attributed to central credible interval. For example, 1/2 for a central 
credible interval of probability 0.5, or 1/3 for a central credible 
interval of probablity 0.333... The default is probability 1/2.</p>
</td></tr>
<tr><td><code id="designLink_+3A_expertid">expertID</code></td>
<td>
<p>character, identifier for expert or group of experts</p>
</td></tr>
<tr><td><code id="designLink_+3A_facilitator">facilitator</code></td>
<td>
<p>character, facilitator identifier</p>
</td></tr>
<tr><td><code id="designLink_+3A_rapporteur">rapporteur</code></td>
<td>
<p>character, rapporteur identifier. Default &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="designLink_+3A_intro.comments">intro.comments</code></td>
<td>
<p>character, text with any prefacing comments. This may 
include, for example, the definition of the target parameter for the 
elictation session. Beware of non-ASCII text and special characters, which 
may affect the ability to save the elicitation record with function <code><a href="#topic+saveRecord">saveRecord</a></code>
or create a summary report with function <code><a href="#topic+makeSweave">makeSweave</a></code>
if called by the function <code><a href="#topic+makeSweave">makeSweave</a></code> may affect ability to render  by
means of <code><a href="utils.html#topic+Sweave">Sweave</a></code> or <code>knitr</code> etc.</p>
</td></tr>
<tr><td><code id="designLink_+3A_fit.method">fit.method</code></td>
<td>
<p>character, method used to fit conditional means prior: 
<code>KL</code> (default), <code>moment</code>, <code>SS</code> (see vignette and
<code><a href="#topic+mV">mV</a></code> for more information on these options)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assumption: at least two fractiles selected from the median, upper and lower 
bounds of hte central credible interval of probability <code>CI.prob</code> will be
elicited at each design point. The probabilities assigned to the central 
credible intervals  can vary across design points. The argument 
<code>CI.prob</code> can later be adjusted by design point during the elicitation 
exercise, see function <code><a href="#topic+elicitPt">elicitPt</a></code>. In the first instance, it is
set to a global value specified by <code>CI.prob</code> in function
<code><a href="#topic+designLink">designLink</a></code> with default value <code class="reqn">0.5</code>.
</p>


<h3>Value</h3>

<p>list of <code>design</code> with entries: <code>theta</code>, a <code class="reqn">n x 4</code> 
matrix with columns that give lower, median and upper quantiles followed by
<code>CI.prob</code> and <code class="reqn">n</code> equal to the number of design points 
(scenarios); <code>link</code>, the link function used; <code>target</code>; 
<code>expert</code> <code>facilitator</code>; <code>rapporteur</code>; <code>date</code>; 
<code>intro.comments</code>; <code>fit.method</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(c(1, 1, 0, 1), nrow = 2) # design
Z &lt;- designLink(design = X, link = "logit", target = "target",
 CI.prob = 1/2, expertID = "Expert", facilitator = "facilitator")
</code></pre>

<hr>
<h2 id='dGompertzNorm'>density for Gompertz transformed univariate Gaussian</h2><span id='topic+dGompertzNorm'></span>

<h3>Description</h3>

<p>density for Gompertz transformed univariate Gaussian
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dGompertzNorm(x, mu, sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dGompertzNorm_+3A_x">x</code></td>
<td>
<p>numeric real</p>
</td></tr>
<tr><td><code id="dGompertzNorm_+3A_mu">mu</code></td>
<td>
<p>numeric real</p>
</td></tr>
<tr><td><code id="dGompertzNorm_+3A_sigma">sigma</code></td>
<td>
<p>numeric real positive</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tranformed density on support (0, 1)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mu &lt;- -1
sigma &lt;- 1
z &lt;- rnorm(10000, mu, sigma)
hist(1 - exp(-exp(z)), freq = FALSE)
curve(dGompertzNorm(x, mu = mu, sigma = sigma), col = 'red', add = TRUE, from = 0.01, to = 0.99)
integrate(function(x) dGompertzNorm(x, mu = mu, sigma = sigma), lower = 0, upper = 1) # equals 1
</code></pre>

<hr>
<h2 id='dLogitNorm'>density for logit transformed univariate Gaussian</h2><span id='topic+dLogitNorm'></span>

<h3>Description</h3>

<p>density for logit transformed univariate Gaussian
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dLogitNorm(x, mu, sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dLogitNorm_+3A_x">x</code></td>
<td>
<p>numeric real</p>
</td></tr>
<tr><td><code id="dLogitNorm_+3A_mu">mu</code></td>
<td>
<p>numeric real</p>
</td></tr>
<tr><td><code id="dLogitNorm_+3A_sigma">sigma</code></td>
<td>
<p>numeric real positive</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tranformed density on support (0, 1)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mu &lt;- -1
sigma &lt;- 1
z &lt;- rnorm(10000, mu, sigma)
hist(exp(z)/(1 + exp(z)), freq = FALSE)
curve(dLogitNorm(x, mu = mu, sigma = sigma), col = 'red', add = TRUE, from = 0.01, to = 0.99)
integrate(function(x) dLogitNorm(x, mu = mu, sigma = sigma), lower = 0, upper = 1) # equals 1
</code></pre>

<hr>
<h2 id='elicitPt'>Function to create or update elicitation at a given design point.</h2><span id='topic+elicitPt'></span>

<h3>Description</h3>

<p>Function to create or update elicitation at a given design point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elicitPt(
  Z,
  design.pt = NULL,
  lower.CI.bound = NA,
  median = NA,
  upper.CI.bound = NA,
  CI.prob = NULL,
  comment = " "
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elicitPt_+3A_z">Z</code></td>
<td>
<p>list of <code>design</code> with entries: <code>theta</code>, a <code class="reqn">n x 4</code> 
matrix with columns that give lower, median and upper quantiles of the 
central credible interval followed by the probability <code>CI.prob</code> 
allocated to the interval; <code>link</code>, the link function used; and 
<code>target</code>. This list object is created by <code><a href="#topic+designLink">designLink</a></code></p>
</td></tr>
<tr><td><code id="elicitPt_+3A_design.pt">design.pt</code></td>
<td>
<p>single integer that denotes design point of interest</p>
</td></tr>
<tr><td><code id="elicitPt_+3A_lower.ci.bound">lower.CI.bound</code></td>
<td>
<p>scalar that gives the lower bound of the central 
credible interval, default <code>NA</code>.</p>
</td></tr>
<tr><td><code id="elicitPt_+3A_median">median</code></td>
<td>
<p>scalar value, default <code>NA</code></p>
</td></tr>
<tr><td><code id="elicitPt_+3A_upper.ci.bound">upper.CI.bound</code></td>
<td>
<p>scalar that gives the upper bound of the central 
credible interval, default <code>NA</code>.</p>
</td></tr>
<tr><td><code id="elicitPt_+3A_ci.prob">CI.prob</code></td>
<td>
<p>numeric, a fraction between 0 and 1 that defines probability 
attributed to central credible interval. For example, 1/2 for quartiles or
1/3 for tertiles. Default <code>NULL</code> uses the initial <code>CI.prob</code> as
defined by <code><a href="#topic+designLink">designLink</a></code>.</p>
</td></tr>
<tr><td><code id="elicitPt_+3A_comment">comment</code></td>
<td>
<p>character, ASCII text providing contributed commentary associated 
with elicitation design point. It is recommended to avoid special characters
such as quotation marks etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>Z</code>, a list of <code>design</code> with entries: <code>theta</code>, a 
<code class="reqn">n x 4</code> matrix with columns that give lower, median and upper quantiles
followed by <code>CI.prob</code>  with updated entries for row specified by
argument <code>design.pt</code>; <code>link</code>, the link function used; and
<code>target</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(c(1, 1, 0, 1), nrow = 2) # design
Z &lt;- designLink(design = X)
Z &lt;- elicitPt(Z, design.pt = 1,
  lower.CI.bound = -1,
  median = 0,
  upper.CI.bound = 1,
  comment = "A completed elicitation scenario.")
</code></pre>

<hr>
<h2 id='indirect'>indirect: A package for assisting indirect elicitation of priors for generalised linear models.</h2><span id='topic+indirect'></span>

<h3>Description</h3>

<p>The <code>indirect</code> package provides three categories of functions: elicitation
functions, fitting functions and visualisation functions.
</p>


<h3>Elicitation functions</h3>

<p>These are the functions that are used to 
record expert opinion. This is where edits will be made and so on. The key 
function is <code><a href="#topic+designLink">designLink</a></code>, which defines a list object that contains
information about the design and elicitation. The elicitations are recorded and updated
via function <code><a href="#topic+elicitPt">elicitPt</a></code>.
</p>


<h3>Fitting functions</h3>

<p>These are generally helper functions except for the function 
<code><a href="#topic+muSigma">muSigma</a></code> that is used for estimating the mean vector and covariance 
matrix of the unknown coefficients for the multivariate normal prior. Helper functions 
include <code><a href="#topic+mV">mV</a></code> for the elicited moments of conditional means priors.
</p>


<h3>Visualisation functions</h3>

<p>These are functions for visualisation. The
core function is <code><a href="#topic+plotDesignPoint">plotDesignPoint</a></code>.
</p>


<h3>References</h3>

<p>Hosack, G. R., Hayes, K. R., &amp; Barry, S. C. (2017). Prior elicitation 
for Bayesian generalised linear models with application to risk control option assessment. 
Reliability Engineering and System Safety, 167:351-361. doi:10.1016/j.ress.2017.06.011
</p>

<hr>
<h2 id='makeSweave'>Function to create summary document from a saved elicitation record.</h2><span id='topic+makeSweave'></span>

<h3>Description</h3>

<p>Creates a Sweave file that can be used to generate a pdf document of the 
summary report.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeSweave(
  filename.rds = "",
  reportname = "",
  title = "Elicitation record",
  contact.details = "none",
  fitted.fractiles = TRUE,
  cumul.prob.bounds = c(0.05, 0.95)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeSweave_+3A_filename.rds">filename.rds</code></td>
<td>
<p>character, filename of the record saved as an RDS object,
see <code>?saveRDS</code>.</p>
</td></tr>
<tr><td><code id="makeSweave_+3A_reportname">reportname</code></td>
<td>
<p>character, filename without extension to be used for the 
generated Sweave (<code>.Rnw</code>) file. The Sweave file supports the creation
of report (<code>.pdf</code>) documentation and accompanying files such as the
<code>.tex</code> file generated by using <code><a href="utils.html#topic+Sweave">Sweave</a></code> followed by
<code>tools::texi2pdf()</code>.</p>
</td></tr>
<tr><td><code id="makeSweave_+3A_title">title</code></td>
<td>
<p>character, a title for the report</p>
</td></tr>
<tr><td><code id="makeSweave_+3A_contact.details">contact.details</code></td>
<td>
<p>character, an email address or other mechanism by 
which the expert may contact the facilitator or rapporteur</p>
</td></tr>
<tr><td><code id="makeSweave_+3A_fitted.fractiles">fitted.fractiles</code></td>
<td>
<p>logical or numeric vector. A logical value of
<code>FALSE</code> will not plot any fitted fractiles from the fitted subjective
probability distribution. A logical value of <code>TRUE</code> will plot the
fitted fractiles that correspond to the final iteration of the raw elicited
fractiles. Alternatively, a numeric vector can specify arbitrary fractiles
for plotting from the fitted distribution, e.g., <code>c(1/10, 1/4, 1/2,
3/4, 9/10)</code></p>
</td></tr>
<tr><td><code id="makeSweave_+3A_cumul.prob.bounds">cumul.prob.bounds</code></td>
<td>
<p>numeric vector that specifies the upper and lower 
plot bounds determined by this credible interval. The default is the 0.90 
central credible interval, <code>c(0.05, 0.95)</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:  
X &lt;- matrix(c(1, 1, 0, 1), nrow = 2) # design
Z &lt;- designLink(design = X)
Z &lt;- elicitPt(Z, design.pt = 1,
  lower.CI.bound = -1,
  median = 0,
  upper.CI.bound = 1,
  comment = "A completed elicitation scenario.")
tmp.rds &lt;- tempfile(pattern = "record", fileext =".rds")
saveRecord(Z, file = tmp.rds)
tmpReport &lt;- tempfile(pattern = "report")
makeSweave(filename.rds = tmp.rds, reportname = tmpReport)
setwd(tempdir())
utils::Sweave(paste0(tmpReport, ".Rnw"))
tools::texi2pdf(paste0(tmpReport, ".tex")) 

## End(Not run)
</code></pre>

<hr>
<h2 id='muSigma'>Function to estimate mean and covariance for unknown parameters 
<code class="reqn">\beta</code>.</h2><span id='topic+muSigma'></span>

<h3>Description</h3>

<p>Function to estimate mean and covariance for unknown parameters 
<code class="reqn">\beta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>muSigma(Z, X = NULL, fit.method = "KL", wls.method = "default")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="muSigma_+3A_z">Z</code></td>
<td>
<p>list of design points and link function that is an output of 
function <code>designLink</code></p>
</td></tr>
<tr><td><code id="muSigma_+3A_x">X</code></td>
<td>
<p>model matrix for model formula and design points. The covariates 
must correspond to the description of design points in <code>Z</code>, but can be
transformed etc. If <code>NULL</code> then <code>X</code> will be coerced by applying 
<code>as.matrix()</code> to <code>Z$design</code>. The matrix <code>X</code> should be full 
rank when subsetted to the elicited design points. If a column of <code>X</code> 
has the name <code>offset</code> then this column is treated as an offset during 
estimation</p>
</td></tr>
<tr><td><code id="muSigma_+3A_fit.method">fit.method</code></td>
<td>
<p>character, <code>moment</code>, <code>KL</code>. See <code><a href="#topic+mV">mV</a></code>. Default
is <code>KL</code>.</p>
</td></tr>
<tr><td><code id="muSigma_+3A_wls.method">wls.method</code></td>
<td>
<p>character giving the numerical solution method: <code>QR</code>, 
using the QR decomposition, <code>SVD</code>, using the singular value 
decomposition, or option <code>default</code> that uses <code>solve()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of <code>mu</code>, numeric vector of location parameters for the 
normal prior; <code>Sigma</code>, the covariance matrix; and <code>log.like</code>, a 
scalar
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(c(1, 1, 0, 1), nrow = 2) # design
Z &lt;- designLink(design = X)
Z &lt;- elicitPt(Z, design.pt = 1,
  lower.CI.bound = -1,
  median = 0,
  upper.CI.bound = 1,
  comment = "The first completed elicitation scenario.")
Z &lt;- elicitPt(Z, design.pt = 2,
  lower.CI.bound = -2,
  median = 1,
  upper.CI.bound = 2,
  comment = "The second completed elicitation scenario.")
prior &lt;- muSigma(Z, X, fit.method = "KL")
prior$mu
prior$Sigma   
</code></pre>

<hr>
<h2 id='mV'>Helper function that translates elicited quantiles of target into independent
conditional means normal prior for a defined inverse link function.</h2><span id='topic+mV'></span>

<h3>Description</h3>

<p>The default for <code>fit.method</code> is option <code>KL</code>. This option uses an 
objective function that minimises a discretised directed divergence from a 
cumulative distribution implied by raw elicited fractiles to a normal 
conditional mean prior for the linear predictor. An alterative method 
<code>moment</code> assigns the location parameter of the normal conditional mean 
prior to the elicited median on the linear predictor scale. The variance 
parameter is estimated as <code class="reqn">V = ((g(f_u) - g(f_l)/(qnorm(u) -
qnorm(l)))^2</code>, where <code class="reqn">l</code> is the probability associated with the fractile
<code class="reqn">f_l</code> that defines the lower bound for the central credible interval and 
<code class="reqn">u</code> is the probability associated with the fractile <code class="reqn">f_u</code> that
defines the upper bound for the central credible interval. This is also used
to initialise the optimisation for the <code>KL</code> method. Another optimsation 
method that minimises the sum of squares is also available as method 
<code>SS</code>. See the vignette for more details on the choice of objective 
function for <code>KL</code> and <code>SS</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mV(Z, fit.method = "KL")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mV_+3A_z">Z</code></td>
<td>
<p>list object that contains matrix <code>theta</code> of elicitations and
character <code>link</code>, see <code><a href="#topic+plotDesignPoint">plotDesignPoint</a></code></p>
</td></tr>
<tr><td><code id="mV_+3A_fit.method">fit.method</code></td>
<td>
<p>character, <code>moment</code>, <code>KL</code>, <code>SS</code>. Default is
<code>KL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with vector of means <code>m</code> and diagonal covariance matrix 
<code>V</code>.
</p>

<hr>
<h2 id='pdist'>Helper function that gives the probability distribution function for design 
point.</h2><span id='topic+pdist'></span>

<h3>Description</h3>

<p>Helper function that gives the probability distribution function for design 
point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdist(x, Z, design.pt = NULL, fit.method = "KL")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdist_+3A_x">x</code></td>
<td>
<p>numeric: coordinate</p>
</td></tr>
<tr><td><code id="pdist_+3A_z">Z</code></td>
<td>
<p>list of design points and link function, see <code><a href="#topic+designLink">designLink</a></code></p>
</td></tr>
<tr><td><code id="pdist_+3A_design.pt">design.pt</code></td>
<td>
<p>integer: design point</p>
</td></tr>
<tr><td><code id="pdist_+3A_fit.method">fit.method</code></td>
<td>
<p>character: method for fit in <code><a href="#topic+mV">mV</a></code>, default is <code>KL</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># design matrix: two scenarios
X &lt;- matrix(c(1, 1, 0, 1), nrow = 2) 
rownames(X) &lt;- c("scenario1", "scenario2")
colnames(X) &lt;- c("covariate1", "covariate2")
#' # logit link
# central credible intervals with probability = 1/2
Z &lt;- designLink(design = X, link = "logit", CI.prob = 0.5)
#' # lower and upper quartiles and median
Z &lt;- indirect::elicitPt(Z, design.pt = 1, 
  lower.CI.bound = 0.2,
  median = 0.4,
  upper.CI.bound = 0.6,
  comment = "Completed.")
indirect::plotDesignPoint(Z, design.pt = 1,   
  elicited.fractiles = TRUE, theta.bounds = c(0, 1),
  fitted.fractiles = TRUE, fitted.curve = TRUE)
  
# probability that target is below 0.1 and
# probability that target is below 0.9   
indirect::pdist(c(0.1, 0.9), Z, design.pt = 1)
</code></pre>

<hr>
<h2 id='plotDesignPoint'>Plot elicited data, fitted marginals or model output</h2><span id='topic+plotDesignPoint'></span>

<h3>Description</h3>

<p>Plot elicited data, fitted marginals or model output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotDesignPoint(
  Z,
  X = NULL,
  design.pt = NULL,
  elicited.fractiles = TRUE,
  fitted.fractiles = FALSE,
  fitted.curve = FALSE,
  CI.prob = NULL,
  estimated.probs = NULL,
  modelled.fractiles = FALSE,
  modelled.curve = FALSE,
  cumul.prob.bounds = c(0.05, 0.95),
  theta.bounds = NULL,
  ylim.max = NULL,
  xlog = FALSE,
  design.table = TRUE,
  n.pts = 101
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotDesignPoint_+3A_z">Z</code></td>
<td>
<p>list object that contains matrix <code>theta</code> of elicitations,
character <code>link</code> and character <code>target</code> as initialised by
<code><a href="#topic+designLink">designLink</a></code> and updated by <code><a href="#topic+elicitPt">elicitPt</a></code></p>
</td></tr>
<tr><td><code id="plotDesignPoint_+3A_x">X</code></td>
<td>
<p>design matrix (can be <code>NULL</code>, unless modelled output is
requested)</p>
</td></tr>
<tr><td><code id="plotDesignPoint_+3A_design.pt">design.pt</code></td>
<td>
<p>single integer that denotes design point of interest</p>
</td></tr>
<tr><td><code id="plotDesignPoint_+3A_elicited.fractiles">elicited.fractiles</code></td>
<td>
<p>logical, plot vertical lines for elicited 
fractiles?</p>
</td></tr>
<tr><td><code id="plotDesignPoint_+3A_fitted.fractiles">fitted.fractiles</code></td>
<td>
<p>logical, plot vertical lines for fitted conditional
mean prior fractiles for this design point? Alternatively, a numeric vector of arbitrary fractiles to be
plotted from the fitted elicitation distribution. If <code>TRUE</code> then the
fractiles corresponding to the median, upper and lower level central CI
are plotted</p>
</td></tr>
<tr><td><code id="plotDesignPoint_+3A_fitted.curve">fitted.curve</code></td>
<td>
<p>logical plot fitted conditional mean prior density for this design point?</p>
</td></tr>
<tr><td><code id="plotDesignPoint_+3A_ci.prob">CI.prob</code></td>
<td>
<p>numeric scalar, locally specified probability assigned to the
elicited central credible interval of the current design point. Defaults to
<code>NULL</code> in which case the global value initially assigned by
<code><a href="#topic+designLink">designLink</a></code> or as updated by <code><a href="#topic+elicitPt">elicitPt</a></code> is used</p>
</td></tr>
<tr><td><code id="plotDesignPoint_+3A_estimated.probs">estimated.probs</code></td>
<td>
<p>numeric vector of values for which estimated
probabilities are to be estimated from the fitted elicitation 
distribution for the target theta. Default is <code>NULL</code>. 
The result is output to the console.</p>
</td></tr>
<tr><td><code id="plotDesignPoint_+3A_modelled.fractiles">modelled.fractiles</code></td>
<td>
<p>logical, plot vertical lines for modelled 
fractiles from the conditional mean prior distribution fit to
all design points? This option requires a design matrix <code>X</code> of full column rank.</p>
</td></tr>
<tr><td><code id="plotDesignPoint_+3A_modelled.curve">modelled.curve</code></td>
<td>
<p>logical, plot modelled conditional mean prior density for
the entire model? This option requires a design matrix <code>X</code> of full column rank.</p>
</td></tr>
<tr><td><code id="plotDesignPoint_+3A_cumul.prob.bounds">cumul.prob.bounds</code></td>
<td>
<p>numeric vector of length two, giving plot bounds by 
cumulative probability. This argument is ignored if there is not enough data
to fit a parametric distribution or if <code>theta.bounds</code> is not <code>NULL</code></p>
</td></tr>
<tr><td><code id="plotDesignPoint_+3A_theta.bounds">theta.bounds</code></td>
<td>
<p>numeric vector giving support of response for plotting
purposes (can be <code>NULL</code>). This will overwrite <code>cumul.prob.bounds</code>,
if applicable</p>
</td></tr>
<tr><td><code id="plotDesignPoint_+3A_ylim.max">ylim.max</code></td>
<td>
<p>numeric maximum value of y-axis (can be <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="plotDesignPoint_+3A_xlog">xlog</code></td>
<td>
<p>logical log x-axis</p>
</td></tr>
<tr><td><code id="plotDesignPoint_+3A_design.table">design.table</code></td>
<td>
<p>logical include design dataframe, elicited fractiles and 
modelled or fitted fractiles</p>
</td></tr>
<tr><td><code id="plotDesignPoint_+3A_n.pts">n.pts</code></td>
<td>
<p>numeric giving number of point to evalate density curve (if 
plotted)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot to the current device. See <code>dev.cur()</code> to check.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># design matrix: two scenarios
X &lt;- matrix(c(1, 1, 0, 1), nrow = 2) 
rownames(X) &lt;- c("scenario1", "scenario2")
colnames(X) &lt;- c("covariate1", "covariate2")

# logit link
# central credible intervals with probability = 1/2
Z &lt;- designLink(design = X, link = "logit", CI.prob = 0.5)

# 1st design point
# no elicited fractiles
indirect::plotDesignPoint(Z, design.pt = 1) 
# elicited median
Z &lt;- indirect::elicitPt(Z, design.pt = 1, 
  lower.CI.bound = NA,
  median = 0.4,
  upper.CI.bound = NA,
  CI.prob = NULL)
indirect::plotDesignPoint(Z, design.pt = 1,   
  elicited.fractiles = TRUE, theta.bounds = c(0, 1))
# lower and upper quartiles and median
Z &lt;- indirect::elicitPt(Z, design.pt = 1, 
  lower.CI.bound = 0.2,
  median = 0.4,
  upper.CI.bound = 0.6,
  comment = "Completed.")
indirect::plotDesignPoint(Z, design.pt = 1,   
  elicited.fractiles = TRUE, theta.bounds = c(0, 1),
  fitted.fractiles = TRUE, fitted.curve = TRUE)
indirect::plotDesignPoint(Z, design.pt = 1,   
  elicited.fractiles = TRUE, theta.bounds = c(0, 1),
  fitted.fractiles = c(1/10, 1/4, 1/2, 3/4, 9/10), 
  fitted.curve = TRUE)   
  
# second design point   
# central credible intervals with probability = 1/3 
# elicit upper and lower tertiles
Z &lt;- elicitPt(Z, design.pt = 2,
  lower.CI.bound = 0.1,
  upper.CI.bound = 0.3,
  CI.prob = 1/3,
  comment = "Switched to tertiles.")
indirect::plotDesignPoint(Z, design.pt = 2,   
  elicited.fractiles = TRUE, theta.bounds = c(0, 1))   
indirect::plotDesignPoint(Z, design.pt = 2,   
  elicited.fractiles = TRUE, theta.bounds = c(0, 1),
  fitted.fractiles = TRUE, fitted.curve = TRUE)
indirect::plotDesignPoint(Z, design.pt = 2,   
  elicited.fractiles = TRUE, theta.bounds = c(0, 1),
  fitted.fractiles = c(1/10, 1/3, 1/2, 2/3, 9/10), 
  fitted.curve = TRUE) 
</code></pre>

<hr>
<h2 id='saveRecord'>Function to save elicitation record.</h2><span id='topic+saveRecord'></span>

<h3>Description</h3>

<p>Function to save elicitation record.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveRecord(
  designLink.obj,
  conclusion.comments = "This concludes the elicitation record.",
  file = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saveRecord_+3A_designlink.obj">designLink.obj</code></td>
<td>
<p>list object initally created by function <code><a href="#topic+designLink">designLink</a></code> 
and subsequently updated by function <code><a href="#topic+elicitPt">elicitPt</a></code></p>
</td></tr>
<tr><td><code id="saveRecord_+3A_conclusion.comments">conclusion.comments</code></td>
<td>
<p>character, comments to conclude session. Beware of
non-ASCII text and special characters, which may affect ability to save or
generate a <code>Sweave</code> document by using <code><a href="#topic+makeSweave">makeSweave</a></code></p>
</td></tr>
<tr><td><code id="saveRecord_+3A_file">file</code></td>
<td>
<p>character providing filename.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an RDS file is created with filename <code>file</code>. A timestamp is
added to <code>designLink.obj</code> using <code>Sys.time()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
X &lt;- matrix(c(1, 1, 0, 1), nrow = 2) # design
Z &lt;- designLink(design = X)
tmp &lt;- tempfile(pattern = "report", fileext =".rds")
saveRecord(Z, file = tmp)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
