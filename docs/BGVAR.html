<!DOCTYPE html><html><head><title>Help for package BGVAR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BGVAR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BGVAR-package'><p>BGVAR: Bayesian Global Vector Autoregressions</p></a></li>
<li><a href='#add_shockinfo'><p>Adding shocks to 'shockinfo' argument</p></a></li>
<li><a href='#avg.pair.cc'><p>Average Pairwise Cross-Sectional Correlations</p></a></li>
<li><a href='#bgvar'><p>Estimation of Bayesian GVAR</p></a></li>
<li><a href='#coef'><p>Extract Model Coefficients of Bayesian GVAR</p></a></li>
<li><a href='#conv.diag'><p>MCMC Convergence Diagnostics</p></a></li>
<li><a href='#dic'><p>Deviance Information Criterion</p></a></li>
<li><a href='#eerData'><p>Example data set to replicate Feldkircher and Huber (2016)</p></a></li>
<li><a href='#excel_to_list'><p>Read Data from Excel</p></a></li>
<li><a href='#fevd'><p>Forecast Error Variance Decomposition</p></a></li>
<li><a href='#fitted'><p>Extract Fitted Values of Bayesian GVAR</p></a></li>
<li><a href='#get_shockinfo'><p>Create <code>shockinfo</code> argument</p></a></li>
<li><a href='#gfevd'><p>Generalized Forecast Error Variance Decomposition</p></a></li>
<li><a href='#hd'><p>Historical Decomposition</p></a></li>
<li><a href='#irf'><p>Impulse Response Function</p></a></li>
<li><a href='#list_to_matrix'><p>Convert Input List to Matrix</p></a></li>
<li><a href='#logLik'><p>Extract Log-likelihood of Bayesian GVAR</p></a></li>
<li><a href='#lps'><p>Compute Log-Predictive Scores</p></a></li>
<li><a href='#matrix_to_list'><p>Convert Input Matrix to List</p></a></li>
<li><a href='#monthlyData'><p>Monthly EU / G8 countries macroeconomic dataset</p></a></li>
<li><a href='#pesaranData'><p>pesaranData</p></a></li>
<li><a href='#plot'><p>Graphical Summary of Output Created with <code>bgvar</code></p></a></li>
<li><a href='#predict'><p>Predictions</p></a></li>
<li><a href='#resid.corr.test'><p>Residual Autocorrelation Test</p></a></li>
<li><a href='#residuals'><p>Extract Residuals of Bayesian GVAR</p></a></li>
<li><a href='#rmse'><p>Compute Root Mean Squared Errors</p></a></li>
<li><a href='#summary'><p>Summary of Bayesian GVAR</p></a></li>
<li><a href='#testdata'><p>Example data set to show functionality of the package</p></a></li>
<li><a href='#vcov'><p>Extract Variance-covariance Matrix of Bayesian GVAR</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Global Vector Autoregressions</td>
</tr>
<tr>
<td>Version:</td>
<td>2.5.5</td>
</tr>
<tr>
<td>Author:</td>
<td>Maximilian Boeck <a href="https://orcid.org/0000-0001-6024-8305"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Martin Feldkircher
    <a href="https://orcid.org/0000-0002-5511-9215"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Florian Huber <a href="https://orcid.org/0000-0002-2896-7921"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Darjus Hosszejni <a href="https://orcid.org/0000-0002-3803-691X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Maximilian Boeck &lt;maximilian.boeck@unibocconi.it&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimation of Bayesian Global Vector Autoregressions (BGVAR) with different prior setups and the possibility to introduce stochastic volatility. Built-in priors include the Minnesota, the stochastic search variable selection and Normal-Gamma (NG) prior. For a reference see also Crespo Cuaresma, J., Feldkircher, M. and F. Huber (2016) "Forecasting with Global Vector Autoregressive Models: a Bayesian Approach", Journal of Applied Econometrics, Vol. 31(7), pp. 1371-1391 &lt;<a href="https://doi.org/10.1002%2Fjae.2504">doi:10.1002/jae.2504</a>&gt;. Post-processing functions allow for doing predictions, structurally identify the model with short-run or sign-restrictions and compute impulse response functions, historical decompositions and forecast error variance decompositions. Plotting functions are also available. The package has a companion paper: Boeck, M., Feldkircher, M. and F. Huber (2022) "BGVAR: Bayesian Global Vector Autoregressions with Shrinkage Priors in R", Journal of Statistical Software, Vol. 104(9), pp. 1-28 &lt;<a href="https://doi.org/10.18637%2Fjss.v104.i09">doi:10.18637/jss.v104.i09</a>&gt;.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mboeck11/BGVAR">https://github.com/mboeck11/BGVAR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mboeck11/BGVAR/issues">https://github.com/mboeck11/BGVAR/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>Imports:</td>
<td>abind, bayesm, coda, GIGrvg, graphics, knitr, MASS, Matrix,
methods, parallel, Rcpp (&ge; 1.0.3), RcppParallel, readxl,
stats, stochvol (&ge; 3.0.3), utils, xts, zoo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, testthat (&ge; 2.1.0)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppProgress, RcppParallel, stochvol,
GIGrvg</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-13 15:37:22 UTC; mboeck</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-13 22:30:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='BGVAR-package'>BGVAR: Bayesian Global Vector Autoregressions</h2><span id='topic+BGVAR-package'></span>

<h3>Description</h3>

<p>The Bayesian Global Vector Autoregression (BGVAR) package allows to estimate Global Vector Autoregressions and consists of various tools for predicting and doing structural analysis.
</p>


<h3>Details</h3>

<p>It provides a fully Bayesian implementation of Global Vector Autoregressions. It utilizes Markov chain Monte Carlo (MCMC) samplers to conduct inference by obtaining draws from the posterior distribution of parameters. One of the main advantages is the implementation of different shrinkage prior setups for estimating the model. The packages consists thus of various post-processing functions to carry out predictions or structural analysis. It is possible to perform structural identification via short-run or sign/zero restrictions. The available structural tools comprise impulse response functions, historical decompositions and forecast error variance decompositions. For all the aforementioned tools plotting functions are implemented. Furthermore, various functions of the package are intended to inspect the convergence properties of the MCMC chain and to do model evaluation. The main focus of this paper is to show the functionality of <code>BGVAR</code>. In addition, it provides a brief mathematical description of the model, an overview of the implemented sampling scheme, and several illustrative examples using global macroeconomic data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bgvar">bgvar</a></code> for estimating a Bayesian GVAR.
<code><a href="#topic+predict">predict</a></code> for doing predictions with a Bayesian GVAR.
<code><a href="#topic+irf">irf</a></code> for doing impulse response analysis with a Bayesian GVAR.
</p>

<hr>
<h2 id='add_shockinfo'>Adding shocks to 'shockinfo' argument</h2><span id='topic+add_shockinfo'></span>

<h3>Description</h3>

<p>Adds automatically rows to 'shockinfo' data.frame for appropriate use in <code>irf</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_shockinfo(shockinfo=NULL, shock=NULL, restriction=NULL, sign=NULL, horizon=NULL, 
prob=NULL, scale=NULL, global=NULL, horizon.fillup=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_shockinfo_+3A_shockinfo">shockinfo</code></td>
<td>
<p>Dataframe to append shocks. If <code>shockinfo=NULL</code> appropriate dataframe for sign-restrictions will be created.</p>
</td></tr>
<tr><td><code id="add_shockinfo_+3A_shock">shock</code></td>
<td>
<p>String element. Variable of interest for structural shock. Only possible to add restrictions to one structural shock at a time.</p>
</td></tr>
<tr><td><code id="add_shockinfo_+3A_restriction">restriction</code></td>
<td>
<p>Character vector with variables that are supposed to be sign restricted.</p>
</td></tr>
<tr><td><code id="add_shockinfo_+3A_sign">sign</code></td>
<td>
<p>Character vector with signs.</p>
</td></tr>
<tr><td><code id="add_shockinfo_+3A_horizon">horizon</code></td>
<td>
<p>Numeric vector with horizons to which restriction should hold. Set <code>horizon.fillup</code> to <code>FALSE</code> to just restrict one specific horizon.</p>
</td></tr>
<tr><td><code id="add_shockinfo_+3A_prob">prob</code></td>
<td>
<p>Number between zero and one determining the probability with which restriction is supposed to hold.</p>
</td></tr>
<tr><td><code id="add_shockinfo_+3A_scale">scale</code></td>
<td>
<p>Scaling parameter.</p>
</td></tr>
<tr><td><code id="add_shockinfo_+3A_global">global</code></td>
<td>
<p>If set to <code>TRUE</code>, shock is defined as global shock.</p>
</td></tr>
<tr><td><code id="add_shockinfo_+3A_horizon.fillup">horizon.fillup</code></td>
<td>
<p>Default set to <code>TRUE</code>, horizon specified up to given horizon. Otherwise just one specific horizon is restricted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is only possible for sign restriction, hence if <code>ident="sign"</code> in <code>get_shockinfo()</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+irf">irf</a></code>
</p>

<hr>
<h2 id='avg.pair.cc'>Average Pairwise Cross-Sectional Correlations</h2><span id='topic+avg.pair.cc'></span>

<h3>Description</h3>

<p>Computes average pairwise cross-sectional correlations of the data and the country models' residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>avg.pair.cc(object, digits=3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="avg.pair.cc_+3A_object">object</code></td>
<td>
<p>Either an object of class <code>bgvar</code> or residuals of class <code>bgvar.res</code>.</p>
</td></tr>
<tr><td><code id="avg.pair.cc_+3A_digits">digits</code></td>
<td>
<p>Number of digits that should be used to print output to the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If used for analyzing the country models' residuals, <code>avg.pair.cc</code> computes for each country and a given variable, the average cross-sectional correlation (either for the data or for the residuals). In theory, including foreign variables should soak up cross-sectional residual dependence and  correlation of the residuals should be small. Otherwise dynamic analysis, especially using GIRFs, might lead to invalid results. See Dees et al. (2007) for more details.
</p>


<h3>Value</h3>

<p>Returns a list with the following elements
</p>
<table>
<tr><td><code>data.cor</code></td>
<td>
<p> is a matrix containing in the rows the cross-sections and in the columns the cross-sectional pairwise correlations of the data per variable.</p>
</td></tr>
<tr><td><code>resid.cor</code></td>
<td>
<p> is a matrix containing in the rows the cross-sections and in the columns the cross-sectional pairwise correlations of the country models' residuals per variable.</p>
</td></tr>
<tr><td><code>resid.corG</code></td>
<td>
<p> is a matrix containing in the rows the cross-sections and in the columns the cross-sectional pairwise correlations of the global models' residuals per variable. Only available when <code>avg.pair.cc</code> has been applied to a <code>bgvar.res</code> object from <code>residuals</code>.</p>
</td></tr>
<tr><td><code>data.res</code></td>
<td>
<p> is a summary object showing the number and percentage of correlations &lt;0.1, between 0.1-0.2, 0.2-0.5 and &lt;0.5 per variable of the data.</p>
</td></tr>
<tr><td><code>res.res</code></td>
<td>
<p> is a summary object showing the number and percentage of correlations &lt;0.1, between 0.1-0.2, 0.2-0.5 and &lt;0.5 per variable of the country models' residuals. This is also what is used by <code>print.bgvar</code>.</p>
</td></tr>
<tr><td><code>res.resG</code></td>
<td>
<p> is a summary object showing the number and percentage of correlations &lt;0.1, between 0.1-0.2, 0.2-0.5 and &lt;0.5 per variable of the global models' residuals. Only available when <code>avg.pair.cc</code> has been applied to a <code>bgvar. res</code> object from <code>residuals</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Martin Feldkircher
</p>


<h3>References</h3>

<p>Dees, S., Di Mauro F., Pesaran, M. H. and Smith, L. V. (2007) <em>Exploring the international linkages of the euro area: A global VAR analysis.</em> Journal of Applied Econometrics, Vol. 22, pp. 1-38.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bgvar">bgvar</a></code> for estimation of a <code>bgvar</code> object.
<code><a href="#topic+residuals">residuals</a></code> for calculating the residuals from a <code>bgvar</code> object and creating a <code>bgvar.res</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(BGVAR)
data(testdata)
model.mn &lt;- bgvar(Data=testdata,W=W.test,plag=1,SV=TRUE,
                  draws=100,burnin=100,prior="MN")
avg.pair.cc(model.mn)

res &lt;- residuals(model.mn)
avg.pair.cc(res)

</code></pre>

<hr>
<h2 id='bgvar'>Estimation of Bayesian GVAR</h2><span id='topic+bgvar'></span>

<h3>Description</h3>

<p>Estimates a Bayesian GVAR with either the Stochastic Search Variable Selection (SSVS), the Minnesota prior (MN), the Normal-Gamma (NG), or the Horseshoe (HS) prior. All specifications can be estimated with stochastic volatility.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgvar(Data, W, plag=1, draws=5000, burnin=5000, prior="NG", SV=TRUE, hold.out=0, thin=1, 
      hyperpara=NULL, eigen=TRUE, Ex=NULL, trend=FALSE, expert=NULL, verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bgvar_+3A_data">Data</code></td>
<td>
<p>Either a </p>

<dl>
<dt><code>list object</code></dt><dd><p> of length <code>N</code> that contains the data. Each element of the list refers to a country/entity. The number of columns (i.e., variables) in each country model can be different. The <code>T</code> rows (i.e., number of time observations), however, need to be the same for each country. Country and variable names are not allowed to contain a dot <code>.</code> (i.e., a dot) since this is our naming convention.</p>
</dd>
<dt><code>matrix object</code></dt><dd><p> of dimension <code>T</code> times <code>K</code>, with <code>K</code> denoting the sum of all endogenous variables of the system. The column names should consist of two parts, separated by a <code>.</code> (i.e., a dot). The first part should denote the country / entity name and the second part the name of the variable. Country and variable names are not allowed to contain a <code>.</code> (i.e., a dot).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="bgvar_+3A_w">W</code></td>
<td>
<p>An N times N weight matrix with 0 elements on the diagonal and row sums that sum up to unity or a list of weight matrices.</p>
</td></tr>
<tr><td><code id="bgvar_+3A_plag">plag</code></td>
<td>
<p>Number of lags used. Either a single value for domestic and weakly exogenous, or a vector of length two. Default set to <code>plag=1</code>.</p>
</td></tr>
<tr><td><code id="bgvar_+3A_draws">draws</code></td>
<td>
<p>Number of retained draws. Default set to <code>draws=5000</code>.</p>
</td></tr>
<tr><td><code id="bgvar_+3A_burnin">burnin</code></td>
<td>
<p>Number of burn-ins. Default set to <code>burnin=5000</code>.</p>
</td></tr>
<tr><td><code id="bgvar_+3A_prior">prior</code></td>
<td>
<p>Either <code>SSVS</code> for the Stochastic Search Variable Selection prior, <code>MN</code> for the Minnesota prior, <code>NG</code> for the Normal-Gamma prior or <code>HS</code> for the Horseshoe prior. See Details below.</p>
</td></tr>
<tr><td><code id="bgvar_+3A_sv">SV</code></td>
<td>
<p>If set to <code>TRUE</code>, models are fitted with stochastic volatility using the <code>stochvol</code> package. Due to storage issues, not the whole history of the <code>T</code> variance covariance matrices are kept, only the median. Consequently, the <code>BGVAR</code> package shows only one set of impulse responses (with variance covariance matrix based on mean sample point volatilities) instead of <code>T</code> sets. Specify <code>SV=FALSE</code> to turn SV off.</p>
</td></tr>
<tr><td><code id="bgvar_+3A_hold.out">hold.out</code></td>
<td>
<p>Defines the hold-out sample. Default without hold-out sample, thus set to zero.</p>
</td></tr>
<tr><td><code id="bgvar_+3A_thin">thin</code></td>
<td>
<p>Is a thinning interval of the MCMC chain. As a rule of thumb, workspaces get large if draws/thin&gt;500. Default set to <code>thin=1</code>.</p>
</td></tr>
<tr><td><code id="bgvar_+3A_hyperpara">hyperpara</code></td>
<td>
<p>Is a list object that defines the hyperparameters when the prior is set to either <code>MN</code>, <code>SSVS</code>, <code>NG</code>, or <code>HS</code>. </p>

<dl>
<dt><code>a_1</code></dt><dd><p> is the prior hyperparameter for the inverted gamma prior (shape) (set a_1 = b_1 to a small value for the standard uninformative prior). Default is set to <code>a_1=0.01</code>.</p>
</dd>
<dt><code>b_1</code></dt><dd><p> is the prior hyperparameter for the inverted gamma prior (rate). Default is set to <code>b_1=0.01</code>.</p>
</dd>
<dt><code>prmean</code></dt><dd><p> Prior mean on the first lag of the autoregressive coefficients, standard value is <code>prmean=1</code> for non-stationary data. Prior mean for the remaining autoregressive coefficients automatically set to 0.</p>
</dd>
<dt><code>bmu</code></dt><dd><p> If <code>SV=TRUE</code>, this is the prior hyperparameter for the mean of the the mean of the log-volatilities. Default is <code>bmu=0</code>.</p>
</dd>
<dt><code>Bmu</code></dt><dd><p> If <code>SV=TRUE</code>, this is the prior hyperparameter for the variance of the mean of the log-volatilities. Default is <code>Bmu=100</code>.</p>
</dd>
<dt><code>a0</code></dt><dd><p> If <code>SV=TRUE</code>, this is the hyperparameter of the shape1 parameter for the Beta prior on the persistence parameter of the log-volatilities. Default is <code>a0=25</code>.</p>
</dd>
<dt><code>b0</code></dt><dd><p> If <code>SV=TRUE</code>, this is the hyperparameter of the shape2 parameter for the Beta prior on the persistence parameter of the log-volatilities. Default is <code>b0=1.5</code>.</p>
</dd>
<dt><code>Bsigma</code></dt><dd><p> If <code>SV=TRUE</code>, this is the hyperparameter for the Gamma prior on the variance of the log-volatilities. Default is set to <code>Bsigma=1</code>.</p>
</dd>
<dt>&quot;MN&quot;</dt><dd>
<dl>
<dt><code>shrink1</code></dt><dd><p> Starting value of <code>shrink1</code>. Default set to 0.1.</p>
</dd>
<dt><code>shrink2</code></dt><dd><p> Starting value of <code>shrink2</code>. Default set to 0.2.</p>
</dd>
<dt><code>shrink3</code></dt><dd><p> Hyperparameter of <code>shrink3</code>. Default set to 100.</p>
</dd>
<dt><code>shrink4</code></dt><dd><p> Starting value of <code>shrink4</code>. Default set to 0.1.</p>
</dd>
</dl>
</dd>
<dt>&quot;SSVS&quot;</dt><dd>
<dl>
<dt><code>tau0</code></dt><dd><p> is the prior variance associated with the normal prior on the regression coefficients if a variable is NOT included (spike, tau0 should be close to zero).</p>
</dd>
<dt><code>tau1</code></dt><dd><p> is the prior variance associated with the normal prior on the regression coefficients if a variable is  included (slab, tau1 should be large).</p>
</dd>
<dt><code>kappa0</code></dt><dd><p> is the prior variance associated with the normal prior on the covariances if a covariance equals zero (spike, kappa0 should be close to zero).</p>
</dd>
<dt><code>kappa1</code></dt><dd><p>  is the prior variance associated with the normal prior on the covariances if a covariance is  unequal to zero (slab, kappa1 should be large).</p>
</dd>
<dt><code>p_i</code></dt><dd><p> is the prior inclusion probability for each regression coefficient whether it is included in the model (default set to <code>p_i=0.5</code>).</p>
</dd>
<dt><code>q_ij</code></dt><dd><p> is the prior inclusion probability for each covariance whether it is included in the model (default set to <code>q_ij=0.5</code>).</p>
</dd>
</dl>
</dd>
<dt>&quot;NG&quot;:</dt><dd>
<dl>
<dt><code>e_lambda</code></dt><dd><p> Prior hyperparameter for the Gamma prior on the lag-specific shrinkage components, standard value is <code>e_lambda=1.5</code>.</p>
</dd>
<dt><code>d_lambda</code></dt><dd><p> Prior hyperparameter for the Gamma prior on the lag-specific shrinkage components, standard value is <code>d_lambda=1</code>.</p>
</dd>
<dt><code>tau_theta</code></dt><dd><p> Parameter of the Normal-Gamma prior that governs the heaviness of the tails of the prior distribution. A value of <code>tau_theta=1</code> would lead to the Bayesian LASSO. Default value differs per entity and set to <code>tau_theta=1/log(M)</code>, where <code>M</code> is the number of endogenous variables per entity.</p>
</dd>
<dt><code>sample_tau</code></dt><dd><p> If set to <code>TRUE</code> <code>tau_theta</code> is sampled.</p>
</dd>
</dl>
</dd>
<dt>&quot;HS&quot;:</dt><dd><p> No additional hyperparameter needs to be elicited for the horseshoe prior.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="bgvar_+3A_eigen">eigen</code></td>
<td>
<p>Set to TRUE if you want to compute the largest eigenvalue of the companion matrix for each posterior draw. If the modulus of the eigenvalue is significantly larger than unity, the model is unstable. Unstable draws exceeding an eigenvalue of one are then excluded. If <code>eigen</code> is set to a numeric value, then this corresponds to the maximum eigenvalue. The default is set to 1.05 (which excludes all posterior draws for which the eigenvalue of the companion matrix was larger than 1.05 in modulus).</p>
</td></tr>
<tr><td><code id="bgvar_+3A_ex">Ex</code></td>
<td>
<p>For including truly exogenous variables to the model. Either a </p>

<dl>
<dt><code>list object</code></dt><dd><p> of maximum length <code>N</code> that contains the data. Each element of the list refers to a country/entity and has to match the country/entity names in <code>Data</code>. If no truly exogenous variables are added to the respective country/entity model, omit the entry. The <code>T</code> rows (i.e., number of time observations), however, need to be the same for each country. Country and variable names are not allowed to contain a dot <code>.</code> (i.e., a dot) since this is our naming convention.</p>
</dd>
<dt><code>matrix object</code></dt><dd><p> of dimension <code>T</code> times number of truly exogenous variables. The column names should consist of two parts, separated by a <code>.</code> (i.e., a dot). The first part should denote the country / entity name and the second part the name of the variable. Country and variable names are not allowed to contain a <code>.</code> (i.e., a dot).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="bgvar_+3A_trend">trend</code></td>
<td>
<p>If set to <code>TRUE</code> a deterministic trend is added to the country models.</p>
</td></tr>
<tr><td><code id="bgvar_+3A_expert">expert</code></td>
<td>
<p>Expert settings, must be provided as list. Default is set to <code>NULL</code>.</p>

<dl>
<dt><code>variable.list</code></dt><dd><p> In case <code>W</code> is a list of weight matrices, specify here which set of variables should be weighted by which weighting matrix. Default is <code>NULL</code>.</p>
</dd>
<dt><code>OE.weights</code></dt><dd><p> Default value is set to <code>NULL</code>. Can be used to provide information of how to handle additional country models (other entities). Additional country models can be used to endogenously determine variables that are (weakly) exogenous for the majority of the other country models. As examples, one could think of an additional oil price model (see also Mohaddes and Raissi 2019) or a model for the joint euro area monetary policy (see also Georgiadis 2015; Feldkircher, Gruber and Huber (2020)). The data for these additional country models has to be contained in <code>Data</code>. The number of additional country models is unlimited. Each list entry of <code>OE.weights</code> has to be named similar to the name of the additional country model contained in <code>Data</code>. Each slot of <code>OE.weight</code> has to contain the following information: </p>

<dl>
<dt><code>weights</code></dt><dd><p> Vector of weights with names relating to the countries for which data should be aggregated. Can also relate to a subset of countries contained in the data.</p>
</dd>
<dt><code>variables</code></dt><dd><p> Vector of variables names that should be included in the additional country model. Variables that are not contained in the data slot of the extra country model are assumed to be weakly exogenous for the additional country model (aggregated with <code>weight</code>).</p>
</dd>
<dt><code>exo</code></dt><dd><p> Vector of variable names that should be fed into the other countries as (weakly) exogenous variables.</p>
</dd>
</dl>
</dd>
<dt><code>Wex.restr</code></dt><dd><p> Character vector containing variables that should be excluded from being used as weakly exogenous from all unit models. An example that has often been used in the literature is to place these restrictions on nominal exchange rates. Default is <code>NULL</code> in which case all weakly exogenous variables are treated symmetrically.</p>
</dd>
<dt><code>save.country.store</code></dt><dd><p> If set to <code>TRUE</code> then function also returns the container of all draws of the individual country models. Significantly raises object size of output and default is thus set to <code>FALSE</code>.</p>
</dd>
<dt><code>save.shrink.store</code></dt><dd><p>If set to <code>TRUE</code> the function also inspects posterior output of shrinkage coefficients. Default set to <code>FALSE</code>.</p>
</dd>
<dt><code>save.vola.store</code></dt><dd><p>If set to <code>TRUE</code> the function also inspects posterior output of coefficients associated with the volatility process. Default set to <code>FALSE</code>.</p>
</dd>
<dt><code>use_R</code></dt><dd><p> Boolean whether estimation should fall back on <code>R</code> version, otherwise <code>Rcpp</code> version is used (default).</p>
</dd>
<dt><code>applyfun</code></dt><dd><p> In case <code>use_R=TRUE</code>, this allows for user-specific apply function, which has to have the same interface than <code>lapply</code>. If <code>cores=NULL</code> then <code>lapply</code> is used, if set to a numeric either <code>parallel::parLapply()</code> is used on Windows platforms and <code>parallel::mclapply()</code> on non-Windows platforms.</p>
</dd>
<dt><code>cores</code></dt><dd><p> Numeric specifying the number of cores which should be used, also <code>all</code> and <code>half</code> is possible. By default only one core is used.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="bgvar_+3A_verbose">verbose</code></td>
<td>
<p>If set to <code>FALSE</code> it suppresses printing messages to the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We provide three priors, the Minnesota labeled <code>MN</code>, the Stochastic Search Variable Selection prior labeled <code>SSVS</code> and the Normal-Gamma prior labeled <code>NG</code>. The first one has been implemented for global VARs in Feldkircher and Huber (2016) and the second one in Crespo Cuaresma et al. (2016), while the last one has been introduced to VAR modeling in Huber and Feldkircher (2019).
Please consult these references for more details on the specification. In the following we will briefly explain the difference between the three priors. The Minnesota prior pushes the variables in the country-specific VAR towards their unconditional stationary mean, or toward a situation where there is at least one unit root present. The SSVS prior is a form of a 'spike' and 'slab' prior. Variable selection is based on the probability of assigning the corresponding regression coefficient to the 'slab' component. If a regression coefficient is non informative, the 'spike' component pushes the associated posterior estimate more strongly towards zero. Otherwise, the slab component resembles a non-informative prior that has little impact on the posterior. Following George et. al. (2008) we set the prior variances for the normal distribution in a semi-automatic fashion. This implies scaling the mixture normal with the OLS standard errors of the coefficients for the full model. The NG prior is a form of global-local shrinkage prior. Hence, the local component shrinks each coefficient towards zero if there is no information for the associated dependent variable. Otherwise, the prior exerts a fat-tail structure such that deviations from zero are possible. The global component is present for each lag, thus capturing the idea that higher lags should be shrunk more aggressively towards zero.
</p>


<h3>Value</h3>

<p>Returns a list of class <code>bgvar</code> with the following elements: </p>

<dl>
<dt><code>args</code></dt><dd><p> is a list object that contains the arguments submitted to function <code>bgvar</code>.</p>
</dd>
<dt><code>xglobal</code></dt><dd><p> is a matrix object of dimension T times N (T # of observations, K # of variables in the system).</p>
</dd>
<dt><code>gW</code></dt><dd><p> is the global weight matrix. It is a list, with <code>N</code> entries, each of which contains the weight matrix of each country.</p>
</dd>
<dt><code>country.res</code></dt><dd><p> is a matrix that contains the posterior mean of the  country models' residuals. The residuals have been obtained as a running mean and thus always relate to the full set of posterior draws. This implies that in case you have opted for trimming the draws the residuals do not correspond to the posterior draws of the &quot;trimmed&quot; coefficients. This is a storage problem, rather than a statistical problem. Experiments, however, show that residual properties (autocorrelation, cross-sectional correlation) of trimmed and reported residuals are close.</p>
</dd>
<dt><code>stacked results</code></dt><dd>
<dl>
<dt><code>S_large</code></dt><dd><p> is a three-dimensional array (K times K times draws) of the (block-diagonal) posterior variance covariance matrix.</p>
</dd>
<dt><code>F_large</code></dt><dd><p> is a four-dimensional array (K times K times lags times draws) of the coefficients.</p>
</dd>
<dt><code>Ginv_large</code></dt><dd><p> is a three-dimensional array (K times K times draws) of the inverse of the G matrix.</p>
</dd>
<dt><code>A_large</code></dt><dd><p> is a three-dimensional array (K times K+1 times draws) of the posterior estimates for the K coefficients plus a global constant.</p>
</dd>
<dt><code>F.eigen</code></dt><dd><p> in case <code>eigen="TRUE"</code>, returns a vector that contains for each posterior draw the modulus of the largest eigenvalue of the companion matrix.</p>
</dd>
<dt><code>trim.info</code></dt><dd><p> is a character vector. Contains information regarding the nr. of stable draws out of total (thinned) draws. Experience shows that a maximum eigenvalue of <code>1.05</code> seems a reasonable choice when working with data in levels to generate stable impulse responses.</p>
</dd>
</dl>
</dd>
<dt><code>cc.results</code></dt><dd><p> each entry of this list contains an list object of length <code>N</code>. Each entry in the list corresponds to one country model and contains one of the following posterior medians.
</p>

<dl>
<dt><code>coeffs</code></dt><dd><p> contains in each entry the matrix with the posterior median of the estimated coefficients. Columns of the matrix correspond to an equation in the country model (i.e., the dependent variable) and rows to coefficient estimates of the explanatory variables.</p>
</dd>
<dt><code>sig</code></dt><dd><p> contains in each entry the variance-covariance matrix for each point in time. If <code>SV=FALSE</code> all entries along the time dimension are the same.</p>
</dd>
<dt><code>theta</code></dt><dd><p> contains in each entry the estimated prior variances for the coefficients. Explains how much shrinkage is induced on each coefficient depending on the prior setup.</p>
</dd>
<dt><code>res</code></dt><dd><p> contains in each entry a matrix of dimension (T-p  times K) with the posterior median of the residuals of the cross-country models.</p>
</dd>
<dt><code>shrink</code></dt><dd><p> in case <code>prior="MN"</code> each entry contains the estimated shrinkage parameters.</p>
</dd>
<dt><code>PIP</code></dt><dd><p> in case <code>prior="SSVS"</code> returns a list object. The first slot in the list <code>PIP.cc</code>, is a list of length <code>N</code> and contains the posterior inclusion probabilities of the country models. The second slot in the list, named <code>PIP.avg</code> yields simple averages (over the country models where a particular variable has been included) of the posterior inclusion probabilities.</p>
</dd>
<dt><code>lambda2</code></dt><dd><p> in case <code>prior="NG"</code> each entry contains the estimated global shrinkage parameters. It is a matrix of dimension (p+1 times 3). Columns refer to the endogenous, weakly exogenous and shrinkage parameters for the covariances. Rows correspond to different degree of shrinkage per lag of the variables starting with the contemporaneous lag (only for weakly exogenous variables). In case of the covariances just one global shrinkage parameter is estimated.</p>
</dd>
<dt><code>tau</code></dt><dd><p> in case <code>prior="NG"</code> each entry contains the estimated parameter that governs the heaviness of the tails of the marginal prior distribution of the coefficients associated to endogenous variables. Structure is the same as <code>lambda2</code>.</p>
</dd>
</dl>
</dd></dl>



<h3>Author(s)</h3>

<p>Maximilian Boeck, Martin Feldkircher, Florian Huber
</p>


<h3>References</h3>

<p>Boeck, M., Feldkircher, M. and F. Huber (2022) BGVAR: Bayesian Global Vector Autoregressions with Shrinkage Priors in R. <em>Journal of Statistical Software</em>, Vol. 104(9), pp. 1-28.
</p>
<p>Crespo Cuaresma, J., Feldkircher, M. and F. Huber (2016) Forecasting with Global Vector Autoregressive Models: A Bayesian Approach. <em>Journal of Applied Econometrics</em>, Vol. 31(7), pp. 1371-1391.
</p>
<p>Doan, T. R., Litterman, B. R. and C. A. Sims (1984) Forecasting and Conditional Projection Using Realistic Prior Distributions. <em>Econometric Reviews</em>, Vol. 3, pp. 1-100.
</p>
<p>Dovern, J., Feldkircher, M. and F. Huber (2016) Does joint modelling of the world economy pay off? Evaluating multivariate forecasts from a Bayesian GVAR. <em>Journal of Economic Dynamics and Control</em>, Vol. 70, pp. 86-100.
</p>
<p>Feldkircher, M. and F. Huber (2016) The International Transmission of US Shocks - Evidence from Bayesian Global Vector Autoregressions. <em>European Economic Review</em>, Vol. 81, pp. 167-188.
</p>
<p>Feldkircher, M. Gruber, T. and F. Huber (2020) International effects of a compression of euro area yield curves. <em>Journal of Banking &amp; Finance</em>, Vol. 113, pp. 11-14.
</p>
<p>George, E.I., Sun, D. and S. Ni (2008) Bayesian stochastic search for var model restrictions. <em>Journal of Econometrics</em>, Vol. 142, pp. 553-580.
</p>
<p>Georgiadis, G. (2015) Examining asymmetries in the transmission of monetary policy in the euro area: Evidence from a mixed cross-section global VAR model. <em>European Economic Review</em>, Vol. 75, pp. 195-215.
</p>
<p>Huber, F. and M. Feldkircher (2016) Adaptive Shrinkage in Bayesian Vector Autoregressive Models. <em>Journal of Business and Economic Statistics</em>, Vol. 37(1), pp. 27-39.
</p>
<p>Mohaddes, K. and M. Raissi (2018). Compilation, Revision and Updating of the Global VAR (GVAR) Database, 1979Q2-2016Q4. University of Cambridge: Faculty of Economics (mimeo).
</p>
<p>Mohaddes, K. and M. Raissi (2019) The US oil supply revolution and the global economy. <em>Empirical Economics</em>, Vol. 57, pp. 515-546.
</p>
<p>Pesaran, M.H., Schuermann T. and S.M. Weiner (2004) Modeling Regional Interdependencies Using a Global Error-Correcting Macroeconometric Model. <em>Journal of Business and Economic Statistics</em>, Vol. 22, pp. 129-162.
</p>
<p>Sims, C. A. (1992) Bayesian Inference for Multivariate Time Series with Trend. <em>Mimeo</em>, presented at the American statistical Association meeting.
</p>
<p>Sims, C.A. and T. Zha (1998) Bayesian Methods for Dynamic Multivariate Models. <em>International Economic Review</em>, Vol. 39, pp. 949-968.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(BGVAR)
data(testdata)
hyperpara &lt;- list(tau0=0.1,tau1=3,kappa0=0.1,kappa1=7,a_1=0.01,b_1=0.01,p_i=0.5,q_ij=0.5)
model.ssvs &lt;- bgvar(Data=testdata,W=W.test,plag=1,draws=100,burnin=100,
                    prior="SSVS",SV=FALSE,hyperpara=hyperpara,thin=1)
## Not run: 
library(BGVAR)
# replicate Feldkircher and Huber (2016) using trade based weights
data(eerData)
hyperpara &lt;- list(tau0=0.1,tau1=3,kappa0=0.1,kappa1=7,a_1=0.01,b_1=0.01,p_i=0.5,q_ij=0.5)
model.ssvs &lt;- bgvar(Data=eerData,W=W.trade0012,plag=1,draws=100,burnin=100,
                    prior="SSVS",SV=FALSE,hyperpara=hyperpara,thin=1)
print(model.ssvs)

# use different weight matrices
variable.list&lt;-list();variable.list$real&lt;-c("y","Dp","tb");variable.list$fin&lt;-c("stir","ltir","rer")
model.mn &lt;- bgvar(Data=eerData, W=W.list[c("tradeW.0012","finW0711")], plag=1, draws=200, 
                  burnin=100,prior="MN",SV=TRUE,thin=2,expert=list(variable.list=variable.list))
print(model.mn)

data(monthlyData)
cN = names(EB.weights$weights)
Data = monthlyData[c(cN,"EB","OC")]
W = W[cN,cN]
OC.weights$weights = OC.weights$weights[cN]
OE.weights &lt;- list(EB=EB.weights, OC=OC.weights)
hyperpara&lt;-list(d_lambda = 0.01, e_lambda = 0.01,e_lambda=1.5,d_lambda=1, 
                prmean=0,a_1=0.01,b_1=0.01,tau_theta=.6,sample_tau=FALSE)
model.ssvs &lt;- bgvar(Data=Data,W=W,plag=2,draws=100,burnin=100,prior="SSVS",
                    hyperpara=hyperpara,eigen=TRUE,SV=TRUE,expert=list(OE.weights=OE.weights))
print(model.ssvs)

## End(Not run)
</code></pre>

<hr>
<h2 id='coef'>Extract Model Coefficients of Bayesian GVAR</h2><span id='topic+coef'></span><span id='topic+coef.bgvar'></span><span id='topic+coefficients.bgvar'></span>

<h3>Description</h3>

<p>Extracts the global model coefficients for <code>bgvar</code> for certain quantiles of the posterior distribution. <code>coefficients</code> is an <em>alias</em> for it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bgvar'
coef(object, ..., quantile = 0.5)

## S3 method for class 'bgvar'
coefficients(object, ..., quantile = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef_+3A_object">object</code></td>
<td>
<p>An object of class <code>bgvar</code>.</p>
</td></tr>
<tr><td><code id="coef_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
<tr><td><code id="coef_+3A_quantile">quantile</code></td>
<td>
<p>reported quantiles. Default is set to the median.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an <code>q</code> times <code>K</code> times <code>K</code> times <code>p</code> array of the global coefficients, where <code>q</code> is the number of specified quantiles (this dimension is dropped if <code>q=1</code>), <code>K</code> the number of endogenous variables and <code>p</code> number of lags.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bgvar">bgvar</a></code> for estimation of a <code>bgvar</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(BGVAR)
data(testdata)
model.ng &lt;- bgvar(Data=testdata,W=W.test,plag=1,draws=100,burnin=100)
coef(model.ng)


coefficients(model.ng)

</code></pre>

<hr>
<h2 id='conv.diag'>MCMC Convergence Diagnostics</h2><span id='topic+conv.diag'></span>

<h3>Description</h3>

<p>This function computes Geweke's Convergence diagnostic making use of the <code>coda</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conv.diag(object, crit.val=1.96)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conv.diag_+3A_object">object</code></td>
<td>
<p>A fitted <code>bgvar</code> object.</p>
</td></tr>
<tr><td><code id="conv.diag_+3A_crit.val">crit.val</code></td>
<td>
<p>Critical value used for test statistic.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Geweke (1992) proposed a convergence diagnostic for Markov chains based on a test for equality of the means of the first and last part of a Markov chain (by default we use the first 10% and the last 50%). If the samples are drawn from the stationary distribution of the chain, the two means are equal and Geweke's statistic has an asymptotically standard normal distribution. The test statistic is a standard Z-score: the difference between the two sample means divided by its estimated standard error. The standard error is estimated from the spectral density at zero and so takes into account any autocorrelation.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>bgvar.CD</code>. This is a list with </p>

<dl>
<dt><code>geweke.z</code></dt><dd><p> Z-scores for a test of equality of means between the first and last parts of the chain. A separate statistic is calculated for each variable in each chain.</p>
</dd>
<dt><code>perc</code></dt><dd><p> is the percentage of Z-scores exceeding <code>crit.val</code> (in absolute terms).</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Martin Feldkircher
</p>


<h3>References</h3>

<p>Geweke, J. (1992) Evaluating the accuracy of sampling-based approaches to calculating posterior moments. <em>Bayesian Statistics</em> 4 (edited by JM Bernado, JO Berger, AP Dawid and AFM Smith). Clarendon Press, Oxford, UK.
</p>


<h3>See Also</h3>

<p><code><a href="coda.html#topic+geweke.diag">geweke.diag</a></code> in the <code>coda</code> package.
<code><a href="#topic+bgvar">bgvar</a></code> for estimation of a <code>bgvar</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(BGVAR)
data(testdata)
model.mn &lt;- bgvar(Data=testdata,W=W.test,plag=1,draws=200,burnin=200,prior="MN")
geweke &lt;- conv.diag(model.mn)

</code></pre>

<hr>
<h2 id='dic'>Deviance Information Criterion</h2><span id='topic+dic'></span><span id='topic+dic.bgvar'></span>

<h3>Description</h3>

<p>Computes the Deviance information criterion for an object <code>bgvar</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dic(object, ...)

## S3 method for class 'bgvar'
dic(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dic_+3A_object">object</code></td>
<td>
<p>An object of class <code>bgvar</code>.</p>
</td></tr>
<tr><td><code id="dic_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric value with the corresponding DIC.
</p>


<h3>Author(s)</h3>

<p>Maximilian Boeck
</p>


<h3>References</h3>

<p>Spiegelhalter, D. J. and Best, N. G., Carlin, B. P. and Linde, A. (2002) <em>Bayesian measures of model complexity and fit.</em> Journal of the Royal Statistical Society, Series B, Vol. 64(4), pp. 583-639.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bgvar">bgvar</a></code> for estimation of a <code>bgvar</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(BGVAR)
data(testdata)
model.mn &lt;- bgvar(Data=testdata,W=W.test,plag=1,draws=100,burnin=100,prior="MN")
dic(model.mn)

</code></pre>

<hr>
<h2 id='eerData'>Example data set to replicate Feldkircher and Huber (2016)</h2><span id='topic+eerData'></span><span id='topic+W.list'></span><span id='topic+W.trade0012'></span><span id='topic+USexpectations'></span>

<h3>Description</h3>

<p>This data set contains 76 quarterly observations by country, spanning the period from 1995Q1 to 2013Q4. The country coverage is 43 countries and the Euro area (EA) as a regional aggregate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eerData
</code></pre>


<h3>Format</h3>

<p>The data loads two objects <code>eerData</code>, which is a list object of length <code>N</code> (i.e, the number of countries) and <code>W.trade0012</code>, which is an <code>N</code> times <code>N</code> weight matrix with rowsums summing up to unity and zero elements on its diagonal. The global variable, oil prices, is included in the US country model as e.g., in Dees et al. (2007). The countries are abbreviated using ISO-2 codes. The weight matrix corresponds to average annual bilateral trade flows (including services) over the period from 2000 to 2012.<code>eerData</code> contains the country data, for more details, see below:
</p>

<dl>
<dt><code>W.trade0012</code></dt><dd><p> Weight matrix based on trade flows, rowsums equal unity.</p>
</dd>
<dt><code>W.list</code></dt><dd><p> List of ten weight matrices, described in Feldkircher and Huber (2016).</p>
</dd>
<dt><code>eerData</code></dt><dd><p> is a list object of length <code>N</code> containing </p>

<dl>
<dt><code>y</code></dt><dd><p> Real GDP, average of 2005=100. Seasonally adjusted, in logarithms.</p>
</dd>
<dt><code>Dp</code></dt><dd><p> Consumer prices (period-on-period). CPI seasonally adjusted, in logarithm.</p>
</dd>
<dt><code>stir</code></dt><dd><p> Short-term interest rate, typically 3-months money market rate.</p>
</dd>
<dt><code>ltir</code></dt><dd><p> Long-term interest rates, typically 10-year government bond yields.</p>
</dd>
<dt><code>reer</code></dt><dd><p> Real effective exchange rate, deflated by consumer prices.</p>
</dd>
<dt><code>tb</code></dt><dd><p> Trade balance (ratio of real exports to real imports).</p>
</dd>
<dt><code>poil</code></dt><dd><p> Price of oil, seasonally adjusted, in logarithms.</p>
</dd>
</dl>
</dd>
<dt><code>USexpectations</code></dt><dd><p> is a time series object containing US expectations data: </p>

<dl>
<dt><code>y_t+4</code></dt><dd><p> Four-quarter ahead expectation of Real GDP growth.</p>
</dd>
<dt><code>Dp_t+4</code></dt><dd><p> Four-quarter ahead expectation of consumer price inflation.</p>
</dd>
<dt><code>stir_t+4</code></dt><dd><p> Four-quarter ahead expectation of short-term interest rates.</p>
</dd>
</dl>
</dd>
</dl>


<hr>
<h2 id='excel_to_list'>Read Data from Excel</h2><span id='topic+excel_to_list'></span>

<h3>Description</h3>

<p>Reads a spreadsheet from excel and converts it to a list for use of <code>bgvar</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>excel_to_list(file, first_column_as_time=TRUE, skipsheet=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="excel_to_list_+3A_file">file</code></td>
<td>
<p>A path to the file.</p>
</td></tr>
<tr><td><code id="excel_to_list_+3A_first_column_as_time">first_column_as_time</code></td>
<td>
<p>Logical indicating whether the first column indicates the time.</p>
</td></tr>
<tr><td><code id="excel_to_list_+3A_skipsheet">skipsheet</code></td>
<td>
<p>If one or more sheets should be skipped for reading, this can be provided with this argument. Either a vector of numeric indices or a vector of strings.</p>
</td></tr>
<tr><td><code id="excel_to_list_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that each sheet has to be named for a respective country. Column names are used as variable names. Reader uses the <code>readxl</code> R package, hence additional arguments can be passed to the function. Furthermore, if <code>first_column_as_time=TRUE</code> then the column name has also to be time.
</p>


<h3>Value</h3>

<p>Returns a list of length <code>N</code> which contains each a matrix of size T times k, where T are time periods and k variables per entity.
</p>


<h3>Author(s)</h3>

<p>Maximilian Boeck
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bgvar">bgvar</a></code> for estimation of a <code>bgvar</code> object.
</p>

<hr>
<h2 id='fevd'>Forecast Error Variance Decomposition</h2><span id='topic+fevd'></span><span id='topic+fevd.bgvar.irf'></span>

<h3>Description</h3>

<p>This function calculates the forecast error variance decomposition (FEVDs) for Cholesky and sign-identified shocks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fevd(x, rotation.matrix=NULL, var.slct=NULL, verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fevd_+3A_x">x</code></td>
<td>
<p>an object of class <code>bgvar.irf</code>.</p>
</td></tr>
<tr><td><code id="fevd_+3A_rotation.matrix">rotation.matrix</code></td>
<td>
<p>If <code>NULL</code> and the <code>x</code> has been fitted via sign restrictions, the rotation matrix is used that minimizes the distance to the median impulse responses at the posterior median.</p>
</td></tr>
<tr><td><code id="fevd_+3A_var.slct">var.slct</code></td>
<td>
<p>character vector that contains the variables for which forecast error variance decomposition should be performed. If <code>NULL</code> the FEVD is computed for the whole system, which is very time consuming.</p>
</td></tr>
<tr><td><code id="fevd_+3A_verbose">verbose</code></td>
<td>
<p>If set to <code>FALSE</code> it suppresses printing messages to the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since the calculations are very time consuming, the FEVDs are based on the posterior median only (as opposed to calculating FEVDs for each MCMC sweep). In case the underlying shock has been identified via sign restrictions, the rotation matrix corresponds to the one that fulfills the sign restrictions at the posterior median of the estimated coefficients. More precisely, the algorithm searches for 50 rotation matrices that fulfill the sign restrictions at the <em>posterior median</em> of the coefficients and then singles out the rotation matrix that minimizes the distance to the median of the impulse responses as suggested in Fry and Pagan (2011).
</p>


<h3>Value</h3>

<p>Returns a list with two elements </p>

<dl>
<dt><code>FEVD</code></dt><dd><p>  an array of size (K times horizon times N), where K are all variables in the system, horizon is the specified impulse response horizon and N is the size of the decomposed structural variables (if <code>var.slct=NULL</code> then K=N).</p>
</dd>
<dt><code>xglobal</code></dt><dd><p> used data of the model.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Maximilian Boeck, Martin Feldkircher, Florian Huber
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bgvar">bgvar</a></code>, <code><a href="#topic+irf">irf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
</code></pre>

<hr>
<h2 id='fitted'>Extract Fitted Values of Bayesian GVAR</h2><span id='topic+fitted'></span><span id='topic+fitted.bgvar'></span>

<h3>Description</h3>

<p>Extracts the fitted values for <code>bgvar</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bgvar'
fitted(object, ..., global = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted_+3A_object">object</code></td>
<td>
<p>An object of class <code>bgvar</code>.</p>
</td></tr>
<tr><td><code id="fitted_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
<tr><td><code id="fitted_+3A_global">global</code></td>
<td>
<p>If <code>global=TRUE</code> global fitted values are returned otherwise country fitted values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an <code>T</code> times <code>K</code> matrix, where <code>T</code> is the number of observations and <code>K</code> number of endogenous variables.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bgvar">bgvar</a></code> for estimation of a <code>bgvar</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(BGVAR)
data(testdata)
model.ng &lt;- bgvar(Data=testdata,W=W.test,plag=1,draws=100,burnin=100)
fitted(model.ng)

</code></pre>

<hr>
<h2 id='get_shockinfo'>Create <code>shockinfo</code> argument</h2><span id='topic+get_shockinfo'></span>

<h3>Description</h3>

<p>Creates dummy <code>shockinfo</code> argument for appropriate use in  <code>irf</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_shockinfo(ident="chol", nr_rows=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_shockinfo_+3A_ident">ident</code></td>
<td>
<p>Definition of identification scheme, either <code>chol</code>, <code>girf</code> or <code>sign</code>.</p>
</td></tr>
<tr><td><code id="get_shockinfo_+3A_nr_rows">nr_rows</code></td>
<td>
<p>Number of rows in the created dataframe.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on the identification scheme a different <code>shockinfo</code> argument in the <code>irf</code> function is needed. To handle this convenient, an appropriate data.frame with is created with this function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+irf">irf</a></code>
</p>

<hr>
<h2 id='gfevd'>Generalized Forecast Error Variance Decomposition</h2><span id='topic+gfevd'></span><span id='topic+gfevd.bgvar'></span>

<h3>Description</h3>

<p>This function calculates a complete generalized forecast error variance decomposition (GFEVDs) based on generalized impulse response functions akin to Lanne-Nyberg (2016). The Lanne-Nyberg (2016) corrected GFEVD sum up to unity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gfevd(x, n.ahead=24, running=TRUE, applyfun=NULL, cores=NULL, verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gfevd_+3A_x">x</code></td>
<td>
<p>an object of class <code>bgvar</code>.</p>
</td></tr>
<tr><td><code id="gfevd_+3A_n.ahead">n.ahead</code></td>
<td>
<p>the forecast horizon.</p>
</td></tr>
<tr><td><code id="gfevd_+3A_running">running</code></td>
<td>
<p>Default is set to <code>TRUE</code> and implies that only a running mean over the posterior draws is calculated. A full analysis including posterior bounds is likely to cause memory issues.</p>
</td></tr>
<tr><td><code id="gfevd_+3A_applyfun">applyfun</code></td>
<td>
<p>Allows for user-specific apply function, which has to have the same interface than <code>lapply</code>. If <code>cores=NULL</code> then <code>lapply</code> is used, if set to a numeric either <code>parallel::parLapply()</code> is used on Windows platforms and <code>parallel::mclapply()</code> on non-Windows platforms.</p>
</td></tr>
<tr><td><code id="gfevd_+3A_cores">cores</code></td>
<td>
<p>Specifies the number of cores which should be used. Default is set to <code>NULL</code> and <code>applyfun</code> is used.</p>
</td></tr>
<tr><td><code id="gfevd_+3A_verbose">verbose</code></td>
<td>
<p>If set to <code>FALSE</code> it suppresses printing messages to the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with two elements </p>

<dl>
<dt><code>GFEVD</code></dt><dd><p> a three or four-dimensional array, with the first dimension referring to the K time series that are decomposed into contributions of K time series (second dimension) for <code>n.ahead</code> forecast horizons. In case <code>running=TRUE</code> only the posterior mean else also its 16% and 84% credible intervals is contained in the fourth dimension.</p>
</dd>
<dt><code>xglobal</code></dt><dd><p> used data of the model.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Maximilian Boeck, Martin Feldkircher
</p>


<h3>References</h3>

<p>Lanne, M. and H. Nyberg (2016) <em>Generalized Forecast Error Variance Decomposition for Linear and Nonlinear Multivariate Models.</em> Oxford Bulletin of Economics and Statistics, Vol. 78(4), pp. 595-603.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bgvar">bgvar</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
</code></pre>

<hr>
<h2 id='hd'>Historical Decomposition</h2><span id='topic+hd'></span><span id='topic+hd.bgvar.irf'></span>

<h3>Description</h3>

<p>A function that calculates historical decomposition (HD) of the time series and the structural error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hd(x, rotation.matrix=NULL, verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hd_+3A_x">x</code></td>
<td>
<p>an item fitted by <code>irf</code>.</p>
</td></tr>
<tr><td><code id="hd_+3A_rotation.matrix">rotation.matrix</code></td>
<td>
<p>If <code>NULL</code> and the <code>irf.bgvar</code> object has been fitted via sign restrictions, the rotation matrix is used that minimizes the distance to the median impulse responses at the posterior median.</p>
</td></tr>
<tr><td><code id="hd_+3A_verbose">verbose</code></td>
<td>
<p>If set to <code>FALSE</code> it suppresses printing messages to the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To save computational time as well as due to storage limits, both functions are based on the posterior median (as opposed to calculating HDs and the structural error for each draw of the MCMC chain). In case the shock has been identified via sign restrictions, a rotation matrix has to be selected to calculate both statistics. If not specified otherwise (via <code>R</code>), the algorithm searches for 50 rotation matrices that fulfill the sign restrictions at the <em>posterior median</em> of the coefficients and then singles out the rotation matrix that minimizes the distance to the median of the impulse responses as suggested in Fry and Pagan (2011).
</p>


<h3>Value</h3>

<p>Returns a list with the following objects </p>

<dl>
<dt><code>hd_array</code></dt><dd><p> is a three-dimensional array with the first dimension referring to the K time series, the second to the T observations and the third dimensions containing the contribution of the shocks in explaining historically deviations in the time series from their trend. The third dimension is K+3, since the last three entries contain the contributions of the constant, the initial condition and a residual component that the contributions sum up to the original time series. If a trend i specified in the model the third dimension is K+3 with trend ordered after the constant.</p>
</dd>
<dt><code>struc.shcok</code></dt><dd><p> contains the structural shock.</p>
</dd>
<dt><code>x</code></dt><dd><p> is a matrix object that contains the original time series, which is of dimension K times (T-plag).</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Maximilian Boeck, Martin Feldkircher, Florian Huber
</p>


<h3>References</h3>

<p>Fry, R. and A. Pagan (2011) <em>Sign restrictions in Structural Vector Autoregressions: A Critical Review</em>. Journal of Economic Literature, Vol. 49(4), pp. 938-960.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bgvar">bgvar</a></code> and <code><a href="#topic+irf">irf</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
</code></pre>

<hr>
<h2 id='irf'>Impulse Response Function</h2><span id='topic+irf'></span><span id='topic+irf.bgvar'></span>

<h3>Description</h3>

<p>This function calculates three alternative ways of dynamic responses, namely generalized impulse response functions (GIRFs) as in Pesaran and Shin (1998), orthogonalized impulse response functions using a Cholesky decomposition and finally impulse response functions given a set of user-specified sign restrictions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irf(x, n.ahead=24, shockinfo=NULL, quantiles=NULL, 
    expert=NULL, verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="irf_+3A_x">x</code></td>
<td>
<p>Object of class <code>bgvar</code>.</p>
</td></tr>
<tr><td><code id="irf_+3A_n.ahead">n.ahead</code></td>
<td>
<p>Forecasting horizon.</p>
</td></tr>
<tr><td><code id="irf_+3A_shockinfo">shockinfo</code></td>
<td>
<p>Dataframe with additional information about the nature of shocks. Depending on the <code>ident</code> argument, the dataframe has to be specified differently. In order to get a dummy version for each identification scheme use <code><a href="#topic+get_shockinfo">get_shockinfo</a></code>.</p>
</td></tr>
<tr><td><code id="irf_+3A_quantiles">quantiles</code></td>
<td>
<p>Numeric vector with posterior quantiles. Default is set to compute median along with 68%/80%/90% confidence intervals.</p>
</td></tr>
<tr><td><code id="irf_+3A_expert">expert</code></td>
<td>
<p>Expert settings, must be provided as list. Default is set to <code>NULL</code>.</p>

<dl>
<dt><code>MaxTries</code></dt><dd><p> Numeric specifying maximal number of tries for finding a rotation matrix with sign-restrictions. Attention: setting this number very large may results in very long computational times. Default is set to <code>MaxTries=100</code>.</p>
</dd>
<dt><code>save.store</code></dt><dd><p> If set to <code>TRUE</code> the full posterior of both, impulses responses and rotation matrices, are returned. Default is set to <code>FALSE</code> in order to save storage.</p>
</dd>
<dt><code>use_R</code></dt><dd><p> Boolean whether IRF computation should fall back on <code>R</code> version, otherwise <code>Rcpp</code> version is used.</p>
</dd>
<dt><code>applyfun</code></dt><dd><p> In case <code>use_R=TRUE</code>, this allows for user-specific apply function, which has to have the same interface than <code>lapply</code>. If <code>cores=NULL</code> then <code>lapply</code> is used, if set to a numeric either <code>parallel::parLapply()</code> is used on Windows platforms and <code>parallel::mclapply()</code> on non-Windows platforms.</p>
</dd>
<dt><code>cores</code></dt><dd><p> Numeric specifying the number of cores which should be used, also <code>all</code> and <code>half</code> is possible. By default only one core is used.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="irf_+3A_verbose">verbose</code></td>
<td>
<p>If set to <code>FALSE</code> it suppresses printing messages to the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of class <code>bgvar.irf</code> with the following elements: </p>

<dl>
<dt><code>posterior</code></dt><dd><p> Four-dimensional array (K times n.ahead times number of shocks times Q) that contains Q quantiles of the posterior distribution of the impulse response functions.</p>
</dd>
<dt><code>shockinfo</code></dt><dd><p> Dataframe with details on identification specification.</p>
</dd>
<dt><code>rot.nr</code></dt><dd><p> In case identification is based on sign restrictions (i.e., <code>ident="sign"</code>), this provides the number of rotation matrices found for the number of posterior draws (save*save_thin).</p>
</dd>
<dt><code>struc.obj</code></dt><dd><p> List object that contains posterior quantitites needed when calculating historical decomposition and structural errors via <code>hd.decomp</code>.</p>

<dl>
<dt><code>A</code></dt><dd><p> Median posterior of global coefficient matrix.</p>
</dd>
<dt><code>Ginv</code></dt><dd><p> Median posterior of matrix <code>Ginv</code>, which describes contemporaneous relationships between countries.</p>
</dd>
<dt><code>S</code></dt><dd><p> Posterior median of matrix with country variance-covariance matrices on the main diagonal.</p>
</dd>
<dt><code>Rmed</code></dt><dd><p> Posterior rotation matrix if <code>ident="sign"</code>.</p>
</dd>
</dl>
</dd>
<dt><code>model.obj</code></dt><dd><p> List object that contains model-specific information, in particular</p>

<dl>
<dt><code>xglobal</code></dt><dd><p> Data of the model.</p>
</dd>
<dt><code>lags</code></dt><dd><p> Lag specification of the model.</p>
</dd>
</dl>
</dd>
<dt><code>IRF_store</code></dt><dd><p> Four-dimensional array (K times n.ahead times number of shock times draws) which stores the whole posterior distribution. Exists only if <code>save.store=TRUE</code>.</p>
</dd>
<dt><code>R_store</code></dt><dd><p> Three-dimensional array (K times K times draws) which stores all rotation matrices. Exists only if <code>save.store=TRUE</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Maximilian Boeck, Martin Feldkircher, Florian Huber
</p>


<h3>References</h3>

<p>Arias, J.E., Rubio-Ramirez, J.F, and D.F. Waggoner (2018) <em>Inference Based on SVARs Identified with Sign and Zero Restrictions: Theory and Applications.</em> Econometrica Vol. 86(2), pp. 685-720.
</p>
<p>D'Amico, S. and T. B. King (2017) <em>What Does Anticipated Monetary Policy Do?</em> Federal Reserve Bank of Chicago Working paper series, Nr. 2015-10.
</p>
<p>Pesaran, H.M. and Y. Shin (1998) <em>Generalized impulse response analysis in linear multivariate models.</em> Economics Letters, Volume 58, Issue 1, p. 17-29.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bgvar">bgvar</a></code>, <code><a href="#topic+get_shockinfo">get_shockinfo</a></code>, <code><a href="#topic+add_shockinfo">add_shockinfo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldpar &lt;- par(no.readonly = TRUE)
# First example, a US monetary policy shock, quarterly data
library(BGVAR)
data(testdata)
# US monetary policy shock
model.eer&lt;-bgvar(Data=testdata, W=W.test, draws=100, burnin=100, 
                 plag=1, prior="SSVS", eigen=TRUE)

# generalized impulse responses
shockinfo&lt;-get_shockinfo("girf")
shockinfo$shock&lt;-"US.stir"; shockinfo$scale&lt;--100

irf.girf.us.mp&lt;-irf(model.eer, n.ahead=24, shockinfo=shockinfo)

# cholesky identification
shockinfo&lt;-get_shockinfo("chol")
shockinfo$shock&lt;-"US.stir"; shockinfo$scale&lt;--100

irf.chol.us.mp&lt;-irf(model.eer, n.ahead=24, shockinfo=shockinfo)

# sign restrictions
shockinfo &lt;- get_shockinfo("sign")
shockinfo &lt;- add_shockinfo(shockinfo, shock="US.stir", restriction=c("US.y","US.Dp"), 
                           sign=c("&lt;","&lt;"), horizon=c(1,1), scale=1, prob=1)
irf.sign.us.mp&lt;-irf(model.eer, n.ahead=24, shockinfo=shockinfo)


# sign restrictions
shockinfo &lt;- get_shockinfo("sign")
shockinfo &lt;- add_shockinfo(shockinfo, shock="US.stir", restriction=c("US.y","US.Dp"), 
sign=c("&lt;","&lt;"), horizon=c(1,1), scale=1, prob=1)
irf.sign.us.mp&lt;-irf(model.eer, n.ahead=24, shockinfo=shockinfo)

#' # sign restrictions with relaxed cross-country restrictions
shockinfo &lt;- get_shockinfo("sign")
# restriction for other countries holds to 75\%
shockinfo &lt;- add_shockinfo(shockinfo, shock="US.stir", restriction=c("US.y","EA.y","UK.y"), 
                           sign=c("&lt;","&lt;","&lt;"), horizon=1, scale=1, prob=c(1,0.75,0.75))
shockinfo &lt;- add_shockinfo(shockinfo, shock="US.stir", restriction=c("US.Dp","EA.Dp","UK.Dp"),
                           sign=c("&lt;","&lt;","&lt;"), horizon=1, scale=1, prob=c(1,0.75,0.75))
irf.sign.us.mp&lt;-irf(model.eer, n.ahead=20, shockinfo=shockinfo)

</code></pre>

<hr>
<h2 id='list_to_matrix'>Convert Input List to Matrix</h2><span id='topic+list_to_matrix'></span>

<h3>Description</h3>

<p>Converts a list to an appropriate input matrix for use of <code>bgvar</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_to_matrix(datalist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list_to_matrix_+3A_datalist">datalist</code></td>
<td>
<p>A list of length <code>N</code> which contains each a matrix of size T times k, where T are time periods and k variables per entity.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note the naming convention. Columns should indicate entity and variable name, separated by a dot, e.g. <code>US.y</code>.
</p>


<h3>Value</h3>

<p>Returns a matrix of size T times K (number of time periods times number of total variables).
</p>


<h3>Author(s)</h3>

<p>Maximilian Boeck
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bgvar">bgvar</a></code> for estimation of a <code>bgvar</code> object.
</p>

<hr>
<h2 id='logLik'>Extract Log-likelihood of Bayesian GVAR</h2><span id='topic+logLik'></span><span id='topic+logLik.bgvar'></span>

<h3>Description</h3>

<p>Extracts Log-Likelihood for <code>bgvar</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bgvar'
logLik(object, ..., quantile = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik_+3A_object">object</code></td>
<td>
<p>An object of class <code>bgvar</code>.</p>
</td></tr>
<tr><td><code id="logLik_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
<tr><td><code id="logLik_+3A_quantile">quantile</code></td>
<td>
<p>Reported quantiles. Default is set to median.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an vector of dimension <code>q</code> (number of specified quantiles) of global log-likelihoods.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bgvar">bgvar</a></code> for estimation of a <code>bgvar</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(BGVAR)
data(testdata)
model.ng &lt;- bgvar(Data=testdata,W=W.test,plag=1,draws=100,burnin=100)
logLik(model.ng)

</code></pre>

<hr>
<h2 id='lps'>Compute Log-Predictive Scores</h2><span id='topic+lps'></span><span id='topic+lps.bgvar.pred'></span>

<h3>Description</h3>

<p>Computes and prints log-predictive score of an object of class <code>bgvar.predict</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bgvar.pred'
lps(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lps_+3A_object">object</code></td>
<td>
<p>An object of class <code>bgvar.predict</code>.</p>
</td></tr>
<tr><td><code id="lps_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>bgvar.lps</code>, which is a matrix of dimension h times K, whereas h is the forecasting horizon and K is the number of variables in the system.
</p>


<h3>Author(s)</h3>

<p>Maximilian Boeck, Martin Feldkircher
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(BGVAR)
data(testdata)
model.ssvs.eer&lt;-bgvar(Data=testdata,W=W.test,draws=100,burnin=100,
                      plag=1,prior="SSVS",eigen=TRUE,hold.out=8)
fcast &lt;- predict(model.ssvs.eer,n.ahead=8,save.store=TRUE)
lps &lt;- lps(fcast)
</code></pre>

<hr>
<h2 id='matrix_to_list'>Convert Input Matrix to List</h2><span id='topic+matrix_to_list'></span>

<h3>Description</h3>

<p>Converts a big input matrix to an appropriate list for use of <code>bgvar</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix_to_list(datamat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix_to_list_+3A_datamat">datamat</code></td>
<td>
<p>A matrix of size T times K, where T are time periods and K total amount of variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note the naming convention. Columns should indicate entity and variable name, separated by a dot, e.g. <code>US.y</code>.
</p>


<h3>Value</h3>

<p>returns a list of length <code>N</code> (number of entities).
</p>


<h3>Author(s)</h3>

<p>Maximilian Boeck
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bgvar">bgvar</a></code> for estimation of a <code>bgvar</code> object.
</p>

<hr>
<h2 id='monthlyData'>Monthly EU / G8 countries macroeconomic dataset</h2><span id='topic+monthlyData'></span><span id='topic+EB.weights'></span><span id='topic+OC.weights'></span><span id='topic+W'></span>

<h3>Description</h3>

<p>This data set contains monthly observations on industrial production, consumer price indices, short- and long-term interest rates, the nominal exchange rate against the euro and equity prices. The time period covered is from January 2001 to June 2021 and the country coverage amounts to 31 countries &ndash; roughly corresponding to EU member states and G-8 countries, a country model to model common monetary policy in the euro area and an oil price model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>monthlyData
</code></pre>


<h3>Format</h3>

<p>The data loads four objects <code>monthly.data</code>, which is a list object of length <code>N+2</code> (i.e, the number of countries, the ECB country model and an oil price model), <code>W</code>, which is an <code>N</code> times <code>N</code> weight matrix with rowsums summing up to unity and zero elements on its diagonal. The countries are abbreviated using ISO-2 codes. The weight matrix corresponds to average annual input output flows for the <code>N</code> countries over the period from 2000 to 2014. The data are from the world input output table database (<a href="https://www.rug.nl/ggdc/valuechain/wiod/">https://www.rug.nl/ggdc/valuechain/wiod/</a>) and are fully described in Timmerman et al. (2015). Akin to Georgiadis (2015), interest setting in the euro area is modeled by a Taylor rule that includes ppp-weighted output and prices of euro area countries. The euro area interest rate enters other country models as an additional exogeneous variable. For more details, see below:
</p>

<dl>
<dt>W</dt><dd><p><code>N</code> times <code>N</code> weight matrix, rowsums equal unity and the <code>i,jth</code> element reflecting flows from unit <code>i</code> to unit  <code>j</code>.</p>
</dd>
<dt><code>EB.weights</code></dt><dd><p>To model the common monetary policy in the euro area, it is possible to augment the GVAR countries by a country model for the ECB. It is important that this country model is labeled 'EB'. Akin to Georgidas (2015) we use a Taylor rule to determine interest rates in the euro area. The Taylor rule typically relates short-term interest rates to a weighted average of output (<code>ip</code> and prices <code>p</code>). <code>EB.weights</code> is a list whith the first slot containing a vector of weights to aggregate single euro area countrys' output and price figures. In the example using the <code>monthlyData</code> set, we use purchasing power parity weights, averaged over the sample period. The second slot contains a character vector that specifies the variables which should enter the Taylor rule (typicall output and prices).</p>
</dd>
<dt><code>OC.weights</code></dt><dd><p>This feature is very similar to <code>EB.weights</code> above and should be specified if an own-standing unit model for the oil price should be included &ndash; as opposed to having oil prices attached to a particular country model, as is standard in the literature. It is important that the country model is labeled 'OC'. Again,  <code>OC.weights</code> is a list of length 2, the first slot should be a vector of weights to aggregate variables, second one the variables to aggregate. The vector of weights should have country names attached to it. In the example using the <code>monthlyData</code> set, we use purchasing power parity weights to aggregate world output to resemble demand for oil.</p>
</dd>
<dt><code>monthlyData</code></dt><dd><p> is a list object of length <code>N</code> containing </p>

<dl>
<dt><code>y</code></dt><dd><p> Industrial production index, in real terms, logarithmic transform and seasonally adjusted.</p>
</dd>
<dt><code>p</code></dt><dd><p> Harmonized Consumer Price Index (HCPI) for EU member states, for other countries Consumer Price Index. Data in logarithmic transform and seasonally adjusted.</p>
</dd>
<dt><code>stir</code></dt><dd><p> Short-term interest rate, typically 3 months money market rate.</p>
</dd>
<dt><code>EAstir</code></dt><dd><p> Short-term interest rate, typically 3 months money market rate (3 months euribor).</p>
</dd>
<dt><code>ltir</code></dt><dd><p> Long term interest rates, typically 10-year government bond yields.</p>
</dd>
<dt><code>eur_er</code></dt><dd><p> Nominal exchange rate against the euro in logarithmic transform. An increase implies an appreciation of the euro. </p>
</dd>
<dt><code>eq</code></dt><dd><p> Equity price index, in logarithmic transform.</p>
</dd>
<dt><code>poil</code></dt><dd><p> Price of oil, seasonally adjusted, in logarithms.</p>
</dd>
<dt><code>qoil</code></dt><dd><p> World oil production of crude oil, in thousands of barrels per day, in logarithms.</p>
</dd></dl>
</dd>
</dl>



<h3>References</h3>

<p>Georgiadis, G. (2015) Examining asymmetries in the transmission of monetary policy in the euro area: Evidence from a mixed cross-section global VAR model. In: European Economic Review, Vol. 75, pp. 195-215.
</p>
<p>Timmer, M. P., Dietzenbacher, E., Los, B., Stehrer, R. and de Vries, G. J. (2015) An Illustrated User Guide to the World Input–Output Database: the Case of Global Automotive Production. In: Review of International Economics, Vol. 23, pp. 575–605.
</p>

<hr>
<h2 id='pesaranData'>pesaranData</h2><span id='topic+pesaranData'></span><span id='topic+pesaranDiff'></span><span id='topic+W.8016'></span><span id='topic+tA'></span><span id='topic+dominant'></span>

<h3>Description</h3>

<p>This data set contains quarterly observations by country, spanning the period from 1979Q2 to 2019Q4. It can be downloaded from <a href="https://www.mohaddes.org/gvar">https://www.mohaddes.org/gvar</a>. The country coverage is 28 countries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pesaranData
</code></pre>


<h3>Format</h3>

<p>The data loads <code>pesaranData</code>, which is a list object of length <code>N</code> (i.e, the number of countries) and contains the country-level data as described in Mohaddes and Raissi (2020). The countries are abbreviated using ISO-2 codes. Furthermore, we also provide two datasets with first differences of some variables in <code>pesaranDiff</code>. <code>dominant</code> contains data that is considered global. <code>tA</code> is a three-dimensional array that contains <code>N</code> times <code>N</code> annual trade flow matrices over the period from 1980 to 2016. This array can be used to construct weight matrices. For more details, see below:
</p>

<dl>
<dt><code>W.8016</code></dt><dd><p> Weight matrix for the <code>pesaran.level</code> and <code>pesaran.diff</code> data sets, based on averaged trade flows covering the period 1980 to 2016 (based on <code>tA</code>).</p>
</dd>
<dt><code>tA</code></dt><dd><p> Three-dimensional array that contains the yearly, bilateral trade flows, which were used to construct <code>W.8016</code>.</p>
</dd>
<dt><code>peseranData</code></dt><dd><p> List object of length <code>N</code> containing </p>

<dl>
<dt><code>y</code></dt><dd><p> Real GDP.</p>
</dd>
<dt><code>Dp</code></dt><dd><p> Consumer price inflation.</p>
</dd>
<dt><code>r</code></dt><dd><p> Short-term interest rate, typically 3-months money market rate.</p>
</dd>
<dt><code>lr</code></dt><dd><p> Long-term interest rate.</p>
</dd>
<dt><code>eq</code></dt><dd><p> Equity prices.</p>
</dd>
<dt><code>ep</code></dt><dd><p> Exchange rate vis a vis the US dollar, deflated by the domestic CPI.</p>
</dd></dl>
</dd>
<dt><code>pesaranDiff</code></dt><dd><p> List object of length <code>N</code> containing </p>

<dl>
<dt><code>y</code></dt><dd><p> Growth rate of real GDP.</p>
</dd>
<dt><code>Dp</code></dt><dd><p> First differences of consumer price inflation.</p>
</dd>
<dt><code>r</code></dt><dd><p> First differences of short-term interest rate, typically 3-months money market rate.</p>
</dd>
<dt><code>lr</code></dt><dd><p> Long-term interest rate.</p>
</dd>
<dt><code>eq</code></dt><dd><p> Equity prices.</p>
</dd>
<dt><code>ep</code></dt><dd><p> Exchange rate vis a vis the US dollar, deflated by the domestic CPI.</p>
</dd></dl>
</dd>
<dt><code>dominant</code></dt><dd><p> Data set containing global variables: </p>

<dl>
<dt><code>poil</code></dt><dd><p> Oil prices.</p>
</dd>
<dt><code>pmetal</code></dt><dd><p> Metal price index.</p>
</dd>
<dt><code>pmat</code></dt><dd><p> Agricultural price index.</p>
</dd></dl>
</dd>
</dl>



<h3>References</h3>

<p>Mohaddes, K. and M. Raissi (2018). Compilation, Revision and Updating of the Global VAR (GVAR) Database, 1979Q2-2016Q4. University of Cambridge: Faculty of Economics (mimeo).
</p>

<hr>
<h2 id='plot'>Graphical Summary of Output Created with <code>bgvar</code></h2><span id='topic+plot'></span><span id='topic+plot.bgvar'></span><span id='topic+plot.bgvar.resid'></span><span id='topic+plot.bgvar.pred'></span><span id='topic+plot.bgvar.irf'></span><span id='topic+plot.bgvar.fevd'></span>

<h3>Description</h3>

<p>Plotting function for fitted values, residuals, predictions, impulse responses and forecast error variance decompositions created with the <code>BGVAR</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bgvar'
plot(x, ..., resp = NULL, global = TRUE)

## S3 method for class 'bgvar.resid'
plot(x, ..., resp = NULL, global = TRUE)

## S3 method for class 'bgvar.pred'
plot(x, ..., resp = NULL, cut = 40, quantiles = c(0.1, 0.16, 0.5, 0.84, 0.9))

## S3 method for class 'bgvar.irf'
plot(
  x,
  ...,
  resp = NULL,
  shock = 1,
  quantiles = c(0.1, 0.16, 0.5, 0.84, 0.9),
  cumulative = FALSE
)

## S3 method for class 'bgvar.fevd'
plot(x, ..., resp, k.max = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>Either an object of class <code>bgvar</code>, <code>bgvar.res</code>, <code>bgvar.irf</code>, <code>bgvar.predict</code> or <code>bgvar.fevd</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>Additional arguments; set graphical parameters.</p>
</td></tr>
<tr><td><code id="plot_+3A_resp">resp</code></td>
<td>
<p>Specify either a specific variable, a specific country or a specific variable in a specific country which should be plotted. If set to <code>NULL</code> all countries is plotted.</p>
</td></tr>
<tr><td><code id="plot_+3A_global">global</code></td>
<td>
<p>If <code>global=TRUE</code> global residuals are plotted, otherwise country residuals.</p>
</td></tr>
<tr><td><code id="plot_+3A_cut">cut</code></td>
<td>
<p>Length of series to be plotted before prediction begins.</p>
</td></tr>
<tr><td><code id="plot_+3A_quantiles">quantiles</code></td>
<td>
<p>Numeric vector with posterior quantiles. Default is set to plot median along with 68%/80% confidence intervals.</p>
</td></tr>
<tr><td><code id="plot_+3A_shock">shock</code></td>
<td>
<p>Specify the shock which should be plotted.</p>
</td></tr>
<tr><td><code id="plot_+3A_cumulative">cumulative</code></td>
<td>
<p>Default is set to <code>FALSE</code>. If <code>cumulative=TRUE</code> cumulative impulse response functions are plotted.</p>
</td></tr>
<tr><td><code id="plot_+3A_k.max">k.max</code></td>
<td>
<p>plots the k series with the highest for the decomposition of <code>resp</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>


<h3>Author(s)</h3>

<p>Maximilian Boeck, Martin Feldkircher
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# example for class 'bgvar'
plot(model.ssvs, resp=c("EA.y","US.Dp"))


# example for class 'bgvar.resid'
res &lt;- residuals(model.ssvs)
plot(res, resp="EA.y")


# example for class 'bgvar.pred'
fcast &lt;- predict(model.ssvs,n.ahead=8)
plot(fcast, resp="y", cut=20)


# example for class 'bgvar.irf'
shockinfo &lt;- get_shockinfo("chol")
shockinfo$shock &lt;- "US.stir"; shockinfo$scale &lt;- +1
irf.chol&lt;-irf(model.ssvs, n.ahead=24, shockinfo=shockinfo)
plot(irf.chol, resp="US")


# example for class 'bgvar.fevd'
fevd.us=fevd(irf.chol,var.slct=c("US.stir"))
plot(fevd.us, resp="US.stir", k.max=10)

</code></pre>

<hr>
<h2 id='predict'>Predictions</h2><span id='topic+predict'></span><span id='topic+predict.bgvar'></span>

<h3>Description</h3>

<p>A function that computes predictions and conditional predictions based on a object of class <code>bgvar</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bgvar'
predict(
  object,
  ...,
  n.ahead = 1,
  constr = NULL,
  constr_sd = NULL,
  quantiles = NULL,
  save.store = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_+3A_object">object</code></td>
<td>
<p>An object of class <code>bgvar</code>.</p>
</td></tr>
<tr><td><code id="predict_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
<tr><td><code id="predict_+3A_n.ahead">n.ahead</code></td>
<td>
<p>Forecast horizon.</p>
</td></tr>
<tr><td><code id="predict_+3A_constr">constr</code></td>
<td>
<p>Matrix containing the conditional forecasts of size horizon times K, where horizon corresponds to the forecast horizon specified in <code>pred.obj</code>, while K is the number of variables in the system. The ordering of the variables have to correspond the ordering of the variables in the system. Rest is just set to NA.</p>
</td></tr>
<tr><td><code id="predict_+3A_constr_sd">constr_sd</code></td>
<td>
<p>Matrix containing the standard deviations around the conditional forecasts. Must have the same size as <code>constr</code>.</p>
</td></tr>
<tr><td><code id="predict_+3A_quantiles">quantiles</code></td>
<td>
<p>Numeric vector with posterior quantiles. Default is set to compute median along with 68%/80%/90% confidence intervals.</p>
</td></tr>
<tr><td><code id="predict_+3A_save.store">save.store</code></td>
<td>
<p>If set to <code>TRUE</code> the full distribution is returned. Default is set to <code>FALSE</code> in order to save storage.</p>
</td></tr>
<tr><td><code id="predict_+3A_verbose">verbose</code></td>
<td>
<p>If set to <code>FALSE</code> it suppresses printing messages to the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Predictions are performed up to an horizon of <code>n.ahead</code>. Note that conditional forecasts need a fully identified system. Therefore this function utilizes short-run restrictions via the Cholesky decomposition on the global solution of the variance-covariance matrix of the Bayesian GVAR.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>bgvar.pred</code> with the following elements </p>

<dl>
<dt><code>fcast</code></dt><dd><p> is a K times n.ahead times Q-dimensional array that contains  Q quantiles of the posterior predictive distribution.</p>
</dd>
<dt><code>xglobal</code></dt><dd><p> is a matrix object of dimension T times N (T # of observations, K # of variables in the system).</p>
</dd>
<dt><code>n.ahead</code></dt><dd><p> specified forecast horizon.</p>
</dd>
<dt><code>lps.stats</code></dt><dd><p> is an array object of dimension K times 2 times n.ahead and contains the mean and standard deviation of the log-predictive scores for each variable and each forecast horizon.</p>
</dd>
<dt><code>hold.out</code></dt><dd><p> if <code>h</code> is not set to zero, this contains the hold-out sample.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Maximilian Boeck, Martin Feldkircher, Florian Huber
</p>


<h3>References</h3>

<p>Jarocinski, M. (2010) <em>Conditional forecasts and uncertainty about forecasts revisions in vector autoregressions.</em> Economics Letters, Vol. 108(3), pp. 257-259.
</p>
<p>Waggoner, D., F. and T. Zha (1999) <em>Conditional Forecasts in Dynamic Multivariate Models.</em> Review of Economics and Statistics, Vol. 81(4), pp. 639-561.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(BGVAR)
data(testdata)
model.ssvs &lt;- bgvar(Data=testdata,W=W.test,plag=1,draws=100,burnin=100,
                    prior="SSVS")
fcast &lt;- predict(model.ssvs, n.ahead=8)

# conditional predictions
# et up constraints matrix of dimension n.ahead times K
constr &lt;- matrix(NA,nrow=8,ncol=ncol(model.ssvs$xglobal))
colnames(constr) &lt;- colnames(model.ssvs$xglobal)
constr[1:5,"US.Dp"] &lt;- model.ssvs$xglobal[76,"US.Dp"]

# add uncertainty to conditional forecasts
constr_sd &lt;- matrix(NA,nrow=8,ncol=ncol(model.ssvs$xglobal))
colnames(constr_sd) &lt;- colnames(model.ssvs$xglobal)
constr_sd[1:5,"US.Dp"] &lt;- 0.001

fcast_cond &lt;- predict(model.ssvs, n.ahead=8, constr=constr, constr_sd=constr_sd)
</code></pre>

<hr>
<h2 id='resid.corr.test'>Residual Autocorrelation Test</h2><span id='topic+resid.corr.test'></span>

<h3>Description</h3>

<p>An F-test for serial autocorrelation in the residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resid.corr.test(obj, lag.cor=1, alpha=0.95, dig1=5, dig2=3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resid.corr.test_+3A_obj">obj</code></td>
<td>
<p>An object of class <code>bgvar</code>.</p>
</td></tr>
<tr><td><code id="resid.corr.test_+3A_lag.cor">lag.cor</code></td>
<td>
<p>The order of serial correlation to be tested for. Default is set to <code>lag.cor=1</code>.</p>
</td></tr>
<tr><td><code id="resid.corr.test_+3A_alpha">alpha</code></td>
<td>
<p>Significance level of test. Default is set to <code>alpha=0.95</code>.</p>
</td></tr>
<tr><td><code id="resid.corr.test_+3A_dig1">dig1</code></td>
<td>
<p>Number of digits to display F-statistics and its critical values.</p>
</td></tr>
<tr><td><code id="resid.corr.test_+3A_dig2">dig2</code></td>
<td>
<p>Number of digits to display p-values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is the F-test of the familiar Lagrange Multiplier (LM) statistic (see Godfrey 1978a, 1978b), also known as the 'modified LM' statistic. The null hypothesis is that <code class="reqn">rho</code>, the autoregressive parameter on the residuals, equals 0 indicating absence of serial autocorrelation. For higher order serial correlation, the null is that all <code class="reqn">rho</code>'s jointly are 0. The test is implemented as in Vanessa Smith's and Alessandra Galesi's &rdquo;GVAR toolbox 2.0 User Guide&rdquo;, page 129.
</p>


<h3>Value</h3>

<p>Returns a list with the following objects </p>

<dl>
<dt><code>Fstat</code></dt><dd><p> contains a list of length <code>N</code> with the associated F-statistic for each variable in each country.</p>
</dd>
<dt><code>resTest</code></dt><dd><p> contains a matrix of size 2N times K+3, with the F-statistics for each country and each variable.</p>
</dd>
<dt><code>p.res</code></dt><dd><p> contains a table which summarizes the output.</p>
</dd>
<dt><code>pL</code></dt><dd><p> contains a list of length <code>N</code> with the associated p-values for each variable in each country.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Martin Feldkircher
</p>


<h3>References</h3>

<p>Godfrey, L.G. (1978a) <em>Testing Against General Autoregressive and Moving Average Error Models When the Regressors Include Lagged Dependent Variables.</em> Econometrica, 46, pp. 1293-1302.
Godfrey, L.G. (1978b) <em>Testing for Higher Order Serial Correlation in Regression Equations When the Regressors Include Lagged Dependent Variables.</em> Econometrica, 46, pp. 1303-1310.
Smith, L. V. and A. Galesi (2014) <em>GVAR Toolbox 2.0 User Guide</em>, available at <a href="https://sites.google.com/site/gvarmodelling/gvar-toolbox">https://sites.google.com/site/gvarmodelling/gvar-toolbox</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bgvar">bgvar</a></code> for estimation of a <code>bgvar</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(BGVAR)
data(testdata)
model.ng &lt;- bgvar(Data=testdata,W=W.test,draws=100,burnin=100)
resid.corr.test(model.ng)

</code></pre>

<hr>
<h2 id='residuals'>Extract Residuals of Bayesian GVAR</h2><span id='topic+residuals'></span><span id='topic+residuals.bgvar'></span><span id='topic+resid.bgvar'></span>

<h3>Description</h3>

<p>Calculate residuals of the global model and the country models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bgvar'
residuals(object, ...)

## S3 method for class 'bgvar'
resid(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals_+3A_object">object</code></td>
<td>
<p>A fitted <code>bgvar</code> object.</p>
</td></tr>
<tr><td><code id="residuals_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates residuals of the global and the country models based on a <code>bgvar</code> object. Country models' residuals are equivalent to output generated by the <code>print.bgvar</code> function in case no trimming has been used. If trimming was invoked to discard unstable draws output of both functions might differ since <code>print.bgvar</code> calculates residuals as a running mean to save storage which is based on the <em>whole</em> set of posterior draws (including discarded draws). In this case it is recommended to recalculate the residuals with <code>residuals.bgvar</code> and re-do the serial autocorrelation or average pairwise cross-correlation analysis using functions <code>resid.corr.test</code> and <code>avg.pair.cc</code>.
</p>


<h3>Value</h3>

<p>Returns a list with the following arguments </p>

<dl>
<dt><code>global</code></dt><dd><p> A (T-p) times K times draws/thin array containing the residuals of the global model.</p>
</dd>
<dt><code>country</code></dt><dd><p> A (T-p) times K times draws/thin array containing the residuals of the country models.</p>
</dd>
<dt><code>Data</code></dt><dd><p> A (T-p) times K matrix containing the data of the model.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Maximilian Boeck, Martin Feldkircher
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bgvar">bgvar</a></code> for estimation of a <code>bgvar</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(BGVAR)
data(testdata)
model.ng &lt;- bgvar(Data=testdata,W=W.test,plag=1,draws=100,burnin=100)
resid(model.ng)


resid(model.ng)

</code></pre>

<hr>
<h2 id='rmse'>Compute Root Mean Squared Errors</h2><span id='topic+rmse'></span><span id='topic+rmse.bgvar.pred'></span>

<h3>Description</h3>

<p>Computes and prints root mean squared errors (RMSEs) of an object of class <code>bgvar.predict</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bgvar.pred'
rmse(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmse_+3A_object">object</code></td>
<td>
<p>An object of class <code>bgvar.predict</code>.</p>
</td></tr>
<tr><td><code id="rmse_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>bgvar.rmse</code>, which is a matrix of dimension h times K, whereas h is the forecasting horizon and K is the number of variables in the system.
</p>


<h3>Author(s)</h3>

<p>Maximilian Boeck, Martin Feldkircher
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(BGVAR)
data(testdata)
model.ssvs.eer&lt;-bgvar(Data=testdata,W=W.test,draws=100,burnin=100,
                      plag=1,prior="SSVS",eigen=TRUE,hold.out=8)
fcast &lt;- predict(model.ssvs.eer,n.ahead=8,save.store=TRUE)
rmse &lt;- rmse(fcast)
</code></pre>

<hr>
<h2 id='summary'>Summary of Bayesian GVAR</h2><span id='topic+summary'></span><span id='topic+summary.bgvar'></span>

<h3>Description</h3>

<p>Output gives model information as well as some descriptive statistics on convergence properties, likelihood, serial autocorrelation in the errors and the average pairwise autocorrelation of cross-country residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bgvar'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_+3A_object">object</code></td>
<td>
<p>An object of class <code>bgvar</code>.</p>
</td></tr>
<tr><td><code id="summary_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>


<h3>Author(s)</h3>

<p>Maximilian Boeck
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bgvar">bgvar</a></code> to estimate a <code>bgvar</code> object.
<code><a href="#topic+avg.pair.cc">avg.pair.cc</a></code> to compute average pairwise cross-country correlation of cross-country residuals separately.
<code><a href="#topic+resid.corr.test">resid.corr.test</a></code> to compute F-test on first-order autocorrelation of cross-country residuals separately.
</p>

<hr>
<h2 id='testdata'>Example data set to show functionality of the package</h2><span id='topic+testdata'></span><span id='topic+W.test'></span>

<h3>Description</h3>

<p>This data set is a subset of <code>eerData</code> containing just three countries with 76 quarterly observations, spanning the period from 1995Q1 to 2013Q4. The country coverage are the United States, the United Kingdom and the Euro area (EA) as a regional aggregate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testdata
</code></pre>


<h3>Format</h3>

<p>The data loads two objects <code>eerDatasmall</code>, which is a list object of length <code>N</code> (i.e, the number of countries) and <code>W.trade0012</code>, which is an <code>N</code> times <code>N</code> weight matrix with rowsums summing up to unity and zero elements on its diagonal. The global variable, oil prices, is included in the US country model as e.g., in Dees et al. (2007). The countries are abbreviated using ISO-2 codes. The weight matrix corresponds to average annual bilateral trade flows (including services) over the period from 2000 to 2012.<code>eerDatasmall</code> contains the country data, for more details, see below:
</p>

<dl>
<dt><code>W.test</code></dt><dd><p> Weight matrix based on trade flows, rowsums equal unity.</p>
</dd>
<dt><code>testdata</code></dt><dd><p> List object of length <code>N</code> containing </p>

<dl>
<dt><code>y</code></dt><dd><p> Real GDP, average of 2005=100. Seasonally adjusted, in logarithms.</p>
</dd>
<dt><code>Dp</code></dt><dd><p> Consumer prices (period-on-period). CPI seasonally adjusted, in logarithm.</p>
</dd>
<dt><code>stir</code></dt><dd><p> Short-term interest rate, typically 3-months money market rate.</p>
</dd>
<dt><code>ltir</code></dt><dd><p> Long-term interest rates, typically 10-year government bond yields.</p>
</dd>
<dt><code>reer</code></dt><dd><p> Real effective exchange rate, deflated by consumer prices.</p>
</dd>
<dt><code>tb</code></dt><dd><p> Trade balance (ratio of real exports to real imports).</p>
</dd>
<dt><code>poil</code></dt><dd><p> Price of oil, seasonally adjusted, in logarithms.</p>
</dd></dl>

</dd>
</dl>


<hr>
<h2 id='vcov'>Extract Variance-covariance Matrix of Bayesian GVAR</h2><span id='topic+vcov'></span><span id='topic+vcov.bgvar'></span>

<h3>Description</h3>

<p>Extracts the global variance-covariance matrix for <code>bgvar</code> for certain quantiles of the posterior distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bgvar'
vcov(object, ..., quantile = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov_+3A_object">object</code></td>
<td>
<p>An object of class <code>bgvar</code>.</p>
</td></tr>
<tr><td><code id="vcov_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
<tr><td><code id="vcov_+3A_quantile">quantile</code></td>
<td>
<p>Reported quantiles. Default is set to median.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an <code>q</code> times <code>K</code> times <code>K</code> array of the global variance-covariance matrix, where <code>q</code> is the number of specified quantiles (this dimension is dropped if <code>q=1</code>) and  <code>K</code> the number of endogenous variables.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bgvar">bgvar</a></code> for estimation of a <code>bgvar</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(BGVAR)
data(testdata)
model.ng &lt;- bgvar(Data=testdata,W=W.test,plag=1,draws=100,burnin=100)
vcov(model.ng)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
