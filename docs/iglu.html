<!DOCTYPE html><html><head><title>Help for package iglu</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {iglu}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#above_percent'><p>Calculate percentage of values above target thresholds</p></a></li>
<li><a href='#active_percent'><p>Calculate percentage of time CGM was active</p></a></li>
<li><a href='#adrr'><p>Calculate average daily risk range (ADRR)</p></a></li>
<li><a href='#agp'><p>Display Ambulatory Glucose Profile (AGP) statistics for selected subject</p></a></li>
<li><a href='#agp_metrics'><p>Calculate metrics for the Ambulatory Glucose Profile (AGP)</p></a></li>
<li><a href='#all_metrics'><p>Calculate all metrics in iglu</p></a></li>
<li><a href='#auc'><p>Calculate Area Under Curve AUC</p></a></li>
<li><a href='#below_percent'><p>Calculate percentage below targeted values</p></a></li>
<li><a href='#calculate_sleep_wake'><p>Calculate metrics for values inside and/or outside a specified time range.</p></a></li>
<li><a href='#CGMS2DayByDay'><p>Interpolate glucose value on an equally spaced grid from day to day</p></a></li>
<li><a href='#cogi'><p>Calculate Continuous Glucose Monitoring Index (COGI) values</p></a></li>
<li><a href='#conga'><p>Continuous Overall Net Glycemic Action (CONGA)</p></a></li>
<li><a href='#cv_glu'><p>Calculate Coefficient of Variation (CV) of glucose levels</p></a></li>
<li><a href='#cv_measures'><p>Calculate Coefficient of Variation subtypes</p></a></li>
<li><a href='#ea1c'><p>Calculate eA1C</p></a></li>
<li><a href='#epicalc_profile'><p>Display Episode Calculation statistics for selected subject</p></a></li>
<li><a href='#episode_calculation'><p>Calculates Hypo/Hyperglycemic episodes with summary statistics</p></a></li>
<li><a href='#example_data_1_subject'><p>Example CGM data for one subject with Type II diabetes</p></a></li>
<li><a href='#example_data_5_subject'><p>Example CGM data for 5 subjects with Type II diabetes</p></a></li>
<li><a href='#example_data_hall'><p>Example data from Hall et al. (2018)</p></a></li>
<li><a href='#example_meals_hall'><p>Example mealtimes data from Hall et al. (2018)</p></a></li>
<li><a href='#gmi'><p>Calculate GMI</p></a></li>
<li><a href='#grade'><p>Calculate mean GRADE score</p></a></li>
<li><a href='#grade_eugly'><p>Percentage of GRADE score attributable to target range</p></a></li>
<li><a href='#grade_hyper'><p>Percentage of GRADE score attributable to hyperglycemia</p></a></li>
<li><a href='#grade_hypo'><p>Percentage of GRADE score attributable to hypoglycemia</p></a></li>
<li><a href='#gri'><p>Calculate Glycemia Risk Index (GRI)</p></a></li>
<li><a href='#gvp'><p>Calculate Glucose Variability Percentage (GVP)</p></a></li>
<li><a href='#hbgi'><p>Calculate High Blood Glucose Index (HBGI)</p></a></li>
<li><a href='#hist_roc'><p>Plot histogram of Rate of Change values (ROC)</p></a></li>
<li><a href='#hyper_index'><p>Calculate Hyperglycemia Index</p></a></li>
<li><a href='#hypo_index'><p>Calculate Hypoglycemia Index</p></a></li>
<li><a href='#igc'><p>Calculate Index of Glycemic Control</p></a></li>
<li><a href='#iglu_shiny'><p>Run IGLU Shiny App</p></a></li>
<li><a href='#in_range_percent'><p>Calculate percentage in targeted value ranges</p></a></li>
<li><a href='#iqr_glu'><p>Calculate glucose level iqr</p></a></li>
<li><a href='#j_index'><p>Calculate J-index</p></a></li>
<li><a href='#lbgi'><p>Calculate Low Blood Glucose Index (LBGI)</p></a></li>
<li><a href='#m_value'><p>Calculate the M-value</p></a></li>
<li><a href='#mad_glu'><p>Calculate Median Absolute Deviation (MAD)</p></a></li>
<li><a href='#mag'><p>Calculate the Mean Absolute Glucose (MAG)</p></a></li>
<li><a href='#mage'><p>Calculate Mean Amplitude of Glycemic Excursions</p></a></li>
<li><a href='#mage_ma_single'><p>Calculates Mean Amplitude of Glycemic Excursions (see &quot;mage&quot;)</p></a></li>
<li><a href='#meal_metrics'><p>Calculate Meal Metrics</p></a></li>
<li><a href='#mean_glu'><p>Calculate mean glucose level</p></a></li>
<li><a href='#median_glu'><p>Calculate median glucose level</p></a></li>
<li><a href='#metrics_heatmap'><p>Create a heatmap of metric values by subject based on hierarchical clustering order</p></a></li>
<li><a href='#modd'><p>Calculate mean difference between glucose values obtained at the same time</p>
of day (MODD)</a></li>
<li><a href='#optimized_iglu_functions'><p>Optimized Calculations of Time Dependent iglu Metrics</p></a></li>
<li><a href='#pgs'><p>Calculate Personal Glycemic State (PGS)</p></a></li>
<li><a href='#plot_agp'><p>Plot Ambulatory Glucose Profile (AGP) modal day</p></a></li>
<li><a href='#plot_daily'><p>Plot daily glucose profiles</p></a></li>
<li><a href='#plot_glu'><p>Plot time series and lasagna plots of glucose measurements</p></a></li>
<li><a href='#plot_lasagna'><p>Lasagna plot of glucose values for multiple subjects</p></a></li>
<li><a href='#plot_lasagna_1subject'><p>Lasagna plot of glucose values for 1 subject aligned across times of day</p></a></li>
<li><a href='#plot_ranges'><p>Plot Time in Ranges as a bar plot</p></a></li>
<li><a href='#plot_roc'><p>Plot time series of glucose colored by rate of change</p></a></li>
<li><a href='#process_data'><p>Data Pre-Processor</p></a></li>
<li><a href='#quantile_glu'><p>Calculate glucose level quantiles</p></a></li>
<li><a href='#range_glu'><p>Calculate glucose level range</p></a></li>
<li><a href='#read_raw_data'><p>Read raw data from a variety of common sensors.</p></a></li>
<li><a href='#roc'><p>Calculate the Rate of Change at each time point (ROC)</p></a></li>
<li><a href='#sd_glu'><p>Calculate sd glucose level</p></a></li>
<li><a href='#sd_measures'><p>Calculate SD subtypes</p></a></li>
<li><a href='#sd_roc'><p>Calculate the standard deviation of the rate of change</p></a></li>
<li><a href='#summary_glu'><p>Calculate summary glucose level</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Interpreting Glucose Data from Continuous Glucose Monitors</td>
</tr>
<tr>
<td>Version:</td>
<td>4.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements a wide range of metrics for measuring glucose control and glucose variability based on continuous glucose monitoring data. The list of implemented metrics is summarized in Rodbard (2009) &lt;<a href="https://doi.org/10.1089%2Fdia.2009.0015">doi:10.1089/dia.2009.0015</a>&gt;. Additional visualization tools include time-series plots, lasagna plots and ambulatory glucose profile report. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>caTools, dplyr, DT, ggplot2, ggpubr, gridExtra, hms,
lubridate, magrittr, patchwork, pheatmap, scales, shiny, stats,
tibble, tidyr, utils, zoo, gtable, grid, plotly</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://irinagain.github.io/iglu/">https://irinagain.github.io/iglu/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/irinagain/iglu/issues">https://github.com/irinagain/iglu/issues</a></td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-23 17:27:25 UTC; irinagn</td>
</tr>
<tr>
<td>Author:</td>
<td>Elizabeth Chun [aut],
  Steve Broll [aut],
  David Buchanan [aut],
  John Muschelli <a href="https://orcid.org/0000-0001-6469-1750"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Nathaniel Fernandes [aut],
  Jung Hoon Seo [ctb],
  Johnathan Shih [ctb],
  Jacek Urbanek [ctb],
  John Schwenck [ctb],
  Marielle Hicban [ctb],
  Mary Martin [ctb],
  Pratik Patel [ctb],
  Meyappan Ashok [ctb],
  Nhan Nguyen [ctb],
  Irina Gaynanova <a href="https://orcid.org/0000-0002-4116-0268"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Irina Gaynanova &lt;irinagn@umich.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-23 17:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='above_percent'>Calculate percentage of values above target thresholds</h2><span id='topic+above_percent'></span>

<h3>Description</h3>

<p>The function above_percent produces a tibble object with values equal to
the percentage of glucose measurements above target values. The output columns
correspond to the subject id followed by the target values and the
output rows correspond to the subjects. The values will be between 0
(no measurements) and 100 (all measurements).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>above_percent(data, targets_above = c(140, 180, 250))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="above_percent_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;,
or numeric vector of glucose values.</p>
</td></tr>
<tr><td><code id="above_percent_+3A_targets_above">targets_above</code></td>
<td>
<p>Numeric vector of glucose thresholds. Glucose values from
data argument will be compared to each value in the targets_above vector.
Default list is (140, 180, 250).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tibble object with 1 row for each subject, a column for subject id and
column for each target value is returned. NA's will be omitted from the glucose
values in calculation of percent.
</p>


<h3>Value</h3>

<p>If a data.frame object is passed, then a tibble object with
a column for subject id and then a column for each target value is returned. If a vector of glucose
values is passed, then a tibble object without the subject id is returned.
as.numeric() can be wrapped around the latter to output a numeric vector.
</p>


<h3>References</h3>

<p>Rodbard (2009) Interpretation of continuous glucose monitoring data:
glycemic variability and quality of glycemic control,
<em>Diabetes Technology and Therapeutics</em> <strong>11</strong> .55-67,
<a href="https://doi.org/10.1089/dia.2008.0132">doi:10.1089/dia.2008.0132</a>.
</p>


<h3>See Also</h3>

<p>plot_ranges()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(example_data_1_subject)

above_percent(example_data_1_subject)
above_percent(example_data_1_subject, targets_above = c(100, 150, 180))

data(example_data_5_subject)

above_percent(example_data_5_subject)
above_percent(example_data_5_subject, targets_above = c(70, 170))

</code></pre>

<hr>
<h2 id='active_percent'>Calculate percentage of time CGM was active</h2><span id='topic+active_percent'></span>

<h3>Description</h3>

<p>The function active_percent produces 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>active_percent(data, dt0 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="active_percent_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;.</p>
</td></tr>
<tr><td><code id="active_percent_+3A_dt0">dt0</code></td>
<td>
<p>The time frequency for interpolated aligned grid in minutes, the default will match the CGM meter's frequency (e.g. 5 min for Dexcom).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function active_percent produces a tibble object with values equal to the
percentage of time the CGM was active, the total number of observed days, the start date and the end date. For example, if a CGM's (5 min frequency) times were 0, 5, 10, 15 and
glucose values were missing at time 5, then percentage of time the CGM was active is 75
The output columns correspond to the subject id, the percentage of time for which the CGM was active, the number of days of measurements, the start date and the end date of measurements.
The output rows correspond to the subjects.
The values of above_percent are always between 0
</p>


<h3>Value</h3>

<p>If a data.frame object is passed, then a tibble object with five columns: subject id,
corresponding active_percent value, duration of measurement period in days, start date, and end date.
</p>


<h3>Author(s)</h3>

<p>Pratik Patel, Irina Gaynanova
</p>


<h3>References</h3>

<p>Danne et al. (2017) International Consensus on Use of
Continuous Glucose Monitoring
<em>Diabetes Care</em> <strong>40</strong> .1631-1640,
<a href="https://doi.org/10.2337/dc17-1600">doi:10.2337/dc17-1600</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(example_data_1_subject)

active_percent(example_data_1_subject)

data(example_data_5_subject)

active_percent(example_data_5_subject)
active_percent(example_data_5_subject, dt0 = 5)

</code></pre>

<hr>
<h2 id='adrr'>Calculate average daily risk range (ADRR)</h2><span id='topic+adrr'></span>

<h3>Description</h3>

<p>The function adrr produces ADRR values in a tibble object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adrr(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adrr_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tibble object with 1 row for each subject, a column for subject id and
a column for ADRR values is returned. NA glucose values are
omitted from the calculation of the ADRR values.
</p>
<p>ADRR is the average sum of HBGI corresponding to the highest glucose
value and LBGI corresponding to the lowest glucose value for each day,
with the average taken over the daily sums. If there are no high glucose or
no low glucose values, then 0 will be substituted for the HBGI value or the
LBGI value, respectively, for that day.
</p>


<h3>Value</h3>

<p>A tibble object with two columns: subject id and corresponding
ADRR value.
</p>


<h3>References</h3>

<p>Kovatchev et al. (2006) Evaluation of a New Measure of Blood Glucose Variability in,
Diabetes
<em>Diabetes care</em> <strong>29</strong> .2433-2438,
<a href="https://doi.org/10.2337/dc06-1085">doi:10.2337/dc06-1085</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(example_data_1_subject)
adrr(example_data_1_subject)

data(example_data_5_subject)
adrr(example_data_5_subject)

</code></pre>

<hr>
<h2 id='agp'>Display Ambulatory Glucose Profile (AGP) statistics for selected subject</h2><span id='topic+agp'></span>

<h3>Description</h3>

<p>Display Ambulatory Glucose Profile (AGP) statistics for selected subject
</p>


<h3>Usage</h3>

<pre><code class='language-R'>agp(data, maxd = 14, inter_gap = 45, dt0 = NULL, tz = "", daily = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="agp_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;. Should only be data for 1 subject. In case multiple subject ids are detected, a warning is produced and only 1st subject is used.</p>
</td></tr>
<tr><td><code id="agp_+3A_maxd">maxd</code></td>
<td>
<p>Number of days to plot, default is the last 14 days, or if
less than 14 days of data are available, all days are plotted.</p>
</td></tr>
<tr><td><code id="agp_+3A_inter_gap">inter_gap</code></td>
<td>
<p>The maximum allowable gap (in minutes) for interpolation. The values will not be interpolated between the glucose measurements that are more than inter_gap minutes apart. The default value is 45 min.</p>
</td></tr>
<tr><td><code id="agp_+3A_dt0">dt0</code></td>
<td>
<p>The time frequency for interpolation in minutes, the default will match the CGM meter's frequency (e.g. 5 min for Dexcom).</p>
</td></tr>
<tr><td><code id="agp_+3A_tz">tz</code></td>
<td>
<p>A character string specifying the time zone to be used. System-specific (see <code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code>), but &quot; &quot; is the current time zone, and &quot;GMT&quot; is UTC (Universal Time, Coordinated). Invalid values are most commonly treated as UTC, on some platforms with a warning.</p>
</td></tr>
<tr><td><code id="agp_+3A_daily">daily</code></td>
<td>
<p>Logical indicator whether AGP should include separate daily plots. The default value is TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot displaying glucose measurements range, selected glucose statistics (average glucose, Glucose Management Indicator, 
</p>


<h3>References</h3>

<p>Johnson et al. (2019) Utilizing the Ambulatory Glucose Profile to Standardize and
Implement Continuous Glucose Monitoring in Clinical Practice,
<em>Diabetes Technology and Therapeutics</em> <strong>21:S2</strong> S2-17-S2-25,
<a href="https://doi.org/10.1089/dia.2019.0034">doi:10.1089/dia.2019.0034</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(example_data_1_subject)
agp(example_data_1_subject, daily = FALSE)
</code></pre>

<hr>
<h2 id='agp_metrics'>Calculate metrics for the Ambulatory Glucose Profile (AGP)</h2><span id='topic+agp_metrics'></span>

<h3>Description</h3>

<p>The function agp_metrics runs the following functions
and combines them into a tibble object: active_percent, mean_glu, gmi,
cv_glu, below_percent, in_range_percent, above_percent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>agp_metrics(data, shinyformat = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="agp_metrics_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;.</p>
</td></tr>
<tr><td><code id="agp_metrics_+3A_shinyformat">shinyformat</code></td>
<td>
<p>Logical indicating whether the output should be formatted for the single subject
AGP page in shiny. Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses recommended cutoffs of 54, 70, 180, and 250 mg/dL for calculation.
</p>
<p>If shinyformat = FALSE (default), returns a tibble object with 1 row for each subject, and 12 columns:
a column for subject id,
a column for start date,
a column for end date,
a column for number of days,
a column for active_percent,
a column for Mean value,
a column for gmi value,
a column for cv value,
a column for below_54 value,
a column for below_70 value,
a column for in_range_70_180 value,
a column for above_180 value,
a column for above_250 value.
If shinyformat = TRUE, a tibble with 2 columns: metric and value, is returned.
This output is used when generating the single subject AGP shiny page.
</p>


<h3>Value</h3>

<p>By default, a tibble object with 1 row for each subject, and 13 columns is returned:
a column for subject id,
a column for start date,
a column for end date,
a column for number of days,
a column for active_percent,
a column for Mean value,
a column for gmi value,
a column for cv value,
a column for below_54 value,
a column for below_70 value,
a column for in_range_70_180 value,
a column for above_180 value,
a column for above_250 value,
</p>


<h3>References</h3>

<p>Johnson et al. (2019) Utilizing the Ambulatory Glucose Profile to Standardize and
Implement Continuous Glucose Monitoring in Clinical Practice,
<em>Diabetes Technology and Therapeutics</em> <strong>21:S2</strong> S2-17-S2-25,
<a href="https://doi.org/10.1089/dia.2019.0034">doi:10.1089/dia.2019.0034</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(example_data_1_subject)
agp_metrics(example_data_1_subject)

</code></pre>

<hr>
<h2 id='all_metrics'>Calculate all metrics in iglu</h2><span id='topic+all_metrics'></span>

<h3>Description</h3>

<p>The function all_metrics runs all of the iglu metrics, and returns the results with
one column per metric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_metrics(
  data,
  dt0 = NULL,
  inter_gap = 45,
  tz = "",
  timelag = 15,
  lag = 1,
  metrics_to_include = c("all", "consensus_only")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all_metrics_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;.</p>
</td></tr>
<tr><td><code id="all_metrics_+3A_dt0">dt0</code></td>
<td>
<p>The time frequency for interpolation in minutes, the default will match the CGM meter's frequency (e.g. 5 min for Dexcom).</p>
</td></tr>
<tr><td><code id="all_metrics_+3A_inter_gap">inter_gap</code></td>
<td>
<p>The maximum allowable gap (in minutes) for interpolation. The values will not be interpolated between the glucose measurements that are more than inter_gap minutes apart. The default value is 45 min.</p>
</td></tr>
<tr><td><code id="all_metrics_+3A_tz">tz</code></td>
<td>
<p>A character string specifying the time zone to be used. System-specific (see <code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code>), but &quot; &quot; is the current time zone, and &quot;GMT&quot; is UTC (Universal Time, Coordinated). Invalid values are most commonly treated as UTC, on some platforms with a warning.</p>
</td></tr>
<tr><td><code id="all_metrics_+3A_timelag">timelag</code></td>
<td>
<p>Integer indicating the time period (# minutes) over which rate
of change is calculated. Default is 15, e.g. rate of change is the change in
glucose over the past 15 minutes divided by 15.</p>
</td></tr>
<tr><td><code id="all_metrics_+3A_lag">lag</code></td>
<td>
<p>Integer indicating which lag (# days) to use. Default is 1.</p>
</td></tr>
<tr><td><code id="all_metrics_+3A_metrics_to_include">metrics_to_include</code></td>
<td>
<p>Returns all metrics computed by iglu or all on the consensus list (Battelino 2023)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All iglu functions are calculated within the all_metrics function, and the resulting tibble
is returned with one row per subject and a column for each metric. Time dependent functions are
calculated together using the function optimized_iglu_functions with two exceptions:
PGS and episodes are calculated within all_metrics because their structure does not
align with optimized_iglu_functions. Note that episodes related outputs included in all_metrics are only
average episodes per day. To get the average duration and glucose, please use the standalone
episodes function
</p>
<p>For metric specific information, please see the corresponding function documentation.
</p>


<h3>Value</h3>

<p>A tibble object with 1 row per subject and one column per metric is returned.
</p>


<h3>References</h3>

<p>Battelino T, Alexander CM, Amiel SA, et al. Continuous glucose monitoring and metrics for clinical trials: an international consensus statement.
<em>Lancet Diabetes Endocrinol.</em>  <strong>2023;11(1):</strong>42-57.
<a href="https://doi.org/10.1016/S2213-8587%2822%2900319-9">doi:10.1016/S2213-8587(22)00319-9</a>.
</p>
<p># Specify the meter frequency and change the interpolation gap to 30 min
all_metrics(example_data_1_subject, dt0 = 5, inter_gap = 30)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(example_data_1_subject)
all_metrics(example_data_1_subject)

</code></pre>

<hr>
<h2 id='auc'>Calculate Area Under Curve AUC</h2><span id='topic+auc'></span>

<h3>Description</h3>

<p>The function auc produces hourly average AUC for each subject.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auc(data, tz="")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auc_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;, or numeric vector of glucose values.</p>
</td></tr>
<tr><td><code id="auc_+3A_tz">tz</code></td>
<td>
<p>String value of time zone.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tibble object with 1 row for each subject, a column for subject id and
a column for hourly average AUC values is returned. NA glucose values are
omitted from the calculation of the AUC.
</p>
<p>AUC is calculated using the formula: (dt0/60) * ((gl[2:length(gl)] + gl[1:(length(gl)-1)])/2),
where dt0/60 is the frequency of the cgm measurements in hours and gl are the glucose values.
</p>
<p>This formula is based off the Trapezoidal Rule: (time[2]-time[1] * ((glucose[1]+glucose[2])/2)).
</p>


<h3>Value</h3>

<p>If a data.frame object is passed, then a tibble object with
two columns: subject id and corresponding hourly average AUC value is returned.
</p>
<p>AUC is calculated for every hour using the trapezoidal rule,
then hourly average AUC is calculated for each 24 hour period,
then the mean of hourly average AUC across all 24 hour periods
is returned as overall hourly average AUC.
</p>


<h3>References</h3>

<p>Danne et al. (2017) International Consensus on Use of Continuous Glucose Monitoring,
<em>Diabetes Care</em> <strong>40</strong> .1631-1640,
<a href="https://doi.org/10.2337/dc17-1600">doi:10.2337/dc17-1600</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(example_data_1_subject)
auc(example_data_1_subject)

</code></pre>

<hr>
<h2 id='below_percent'>Calculate percentage below targeted values</h2><span id='topic+below_percent'></span>

<h3>Description</h3>

<p>The function below_percent produces a tibble object with values equal to
the percentage of glucose measurements below target values. The output columns
correspond to the subject id followed by the target values and the output rows
correspond to the subjects. The values will be between 0 (no measurements)
and 100 (all measurements).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>below_percent(data, targets_below = c(54, 70))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="below_percent_+3A_data">data</code></td>
<td>
<p>DataFrame with column names (&quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;),
or numeric vector of glucose values.</p>
</td></tr>
<tr><td><code id="below_percent_+3A_targets_below">targets_below</code></td>
<td>
<p>Numeric vector of glucose thresholds. Glucose values from
data argument will be compared to each value in the targets_below vector.
Default list is (54, 70).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tibble object with 1 row for each subject, a column for subject id and
column for each target value is returned. NA's will be omitted from the glucose
values in calculation of percent.
</p>


<h3>Value</h3>

<p>If a data.frame object is passed, then a tibble object with
a column for subject id and then a column for each target value is returned. If a vector of glucose
values is passed, then a tibble object without the subject id is returned.
as.numeric() can be wrapped around the latter to output a numeric vector.
</p>


<h3>References</h3>

<p>Rodbard (2009) Interpretation of continuous glucose monitoring data:
glycemic variability and quality of glycemic control,
<em>Diabetes Technology and Therapeutics</em> <strong>11</strong> .55-67,
<a href="https://doi.org/10.1089/dia.2008.0132">doi:10.1089/dia.2008.0132</a>.
</p>


<h3>See Also</h3>

<p>plot_ranges()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(example_data_1_subject)

below_percent(example_data_1_subject)
below_percent(example_data_1_subject, targets_below = c(50, 100, 180))

data(example_data_5_subject)

below_percent(example_data_5_subject)
below_percent(example_data_5_subject, targets_below = c(80, 180))

</code></pre>

<hr>
<h2 id='calculate_sleep_wake'>Calculate metrics for values inside and/or outside a specified time range.</h2><span id='topic+calculate_sleep_wake'></span>

<h3>Description</h3>

<p>This function applies a given function to a subset of data filtered by time of day.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_sleep_wake(
  data,
  FUN,
  sleep_start = 0,
  sleep_end = 6,
  calculate = c("sleep", "wake", "both"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_sleep_wake_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;.</p>
</td></tr>
<tr><td><code id="calculate_sleep_wake_+3A_fun">FUN</code></td>
<td>
<p>Function to be applied to the filtered data.</p>
</td></tr>
<tr><td><code id="calculate_sleep_wake_+3A_sleep_start">sleep_start</code></td>
<td>
<p>Numeric between 0-24 signifying the hour at which the time range should start.</p>
</td></tr>
<tr><td><code id="calculate_sleep_wake_+3A_sleep_end">sleep_end</code></td>
<td>
<p>Numeric between 0-24 signifying the hour at which the time range should end.</p>
</td></tr>
<tr><td><code id="calculate_sleep_wake_+3A_calculate">calculate</code></td>
<td>
<p>String determining whether FUN should be applied to values inside or outside the time range. Both separately is an option</p>
</td></tr>
<tr><td><code id="calculate_sleep_wake_+3A_...">...</code></td>
<td>
<p>Optional arguments which will be passed to FUN</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of the same return type as FUN, with the same column names as FUN will be returned.
If calculate = &quot;both&quot;, there will be columns for FUN applied to both inside and outside values,
with either &quot;in range&quot; or &quot;out of range&quot; append to signify whether the statistic was calculated on values
which were inside the time range or outside the range.
</p>
<p>FUN is found by a call to match.fun and typically is either a function or a character string
specifying a function to be searched for from the environment of the call to apply.
Arguments in ... cannot have the same name as any of the other arguments, and care may be needed to avoid partial matching to FUN.
FUN is applied to the data after the data is filtered based on whether its hour falls within the given range.
If sleep_start is an integer, all times within that hour will be included in the range, but if sleep_end is an integer
only times up to that hour will be included in the range.
If sleep_start is after sleep_end, the data will be filtered to include all hours after sleep_start and all times before sleep_end.
</p>


<h3>Value</h3>

<p>An object of the same return type as FUN, with columns corresponding to the values returned by FUN. Separated for values inside or outside the time range, if calculate = both.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(example_data_1_subject)
calculate_sleep_wake(example_data_1_subject, sd_glu, calculate = "sleep")

data(example_data_5_subject)
calculate_sleep_wake(example_data_5_subject, cogi, targets = c(80, 150),
weights = c(.3,.2,.5), calculate = "wake")
calculate_sleep_wake(example_data_5_subject, sd_measures, sleep_start = 2,
sleep_end = 8, calculate = "both")

</code></pre>

<hr>
<h2 id='CGMS2DayByDay'>Interpolate glucose value on an equally spaced grid from day to day</h2><span id='topic+CGMS2DayByDay'></span>

<h3>Description</h3>

<p>Interpolate glucose value on an equally spaced grid from day to day
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CGMS2DayByDay(data, dt0 = NULL, inter_gap = 45, tz = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CGMS2DayByDay_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;. Should only be data for 1 subject. In case multiple subject ids are detected, a warning is produced and only 1st subject is used.</p>
</td></tr>
<tr><td><code id="CGMS2DayByDay_+3A_dt0">dt0</code></td>
<td>
<p>The time frequency for interpolation in minutes, the default will match the CGM meter's frequency (e.g. 5 min for Dexcom).</p>
</td></tr>
<tr><td><code id="CGMS2DayByDay_+3A_inter_gap">inter_gap</code></td>
<td>
<p>The maximum allowable gap (in minutes) for interpolation. The values will not be interpolated between the glucose measurements that are more than inter_gap minutes apart. The default value is 45 min.</p>
</td></tr>
<tr><td><code id="CGMS2DayByDay_+3A_tz">tz</code></td>
<td>
<p>A character string specifying the time zone to be used. System-specific (see <code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code>), but &quot; &quot; is the current time zone, and &quot;GMT&quot; is UTC (Universal Time, Coordinated). Invalid values are most commonly treated as UTC, on some platforms with a warning.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with
</p>
<table>
<tr><td><code>gd2d</code></td>
<td>
<p>A matrix of glucose values with each row corresponding to a new day, and each column corresponding to time</p>
</td></tr>
<tr><td><code>actual_dates</code></td>
<td>
<p>A vector of dates corresponding to the rows of <code>gd2d</code></p>
</td></tr>
<tr><td><code>dt0</code></td>
<td>
<p>Time frequency of the resulting grid, in minutes</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
CGMS2DayByDay(example_data_1_subject)

</code></pre>

<hr>
<h2 id='cogi'>Calculate Continuous Glucose Monitoring Index (COGI) values</h2><span id='topic+cogi'></span>

<h3>Description</h3>

<p>The function COGI produces cogi values in a tibble object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cogi(data, targets = c(70, 180), weights = c(.5,.35,.15))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cogi_+3A_data">data</code></td>
<td>
<p>DataFrame with column names (&quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;),
or numeric vector of glucose values.</p>
</td></tr>
<tr><td><code id="cogi_+3A_targets">targets</code></td>
<td>
<p>Numeric vector of two glucose values for threshold. Glucose values from
data argument will be compared to each value in the targets vector to determine the
time in range and time below range for COGI. The lower value will be used for determining
time below range.
Default list is (70, 180).</p>
</td></tr>
<tr><td><code id="cogi_+3A_weights">weights</code></td>
<td>
<p>Numeric vector of three weights to be applied to time in range, time below range
and glucose variability, respectively. The default list is (.5,.35,.15)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tibble object with 1 row for each subject, a column for subject id and
column for each target value is returned. NA's will be omitted from the glucose
values in calculation of cogi.
</p>


<h3>Value</h3>

<p>If a data.frame object is passed, then a tibble object with
a column for subject id and then a column for each target value is returned. If a vector of glucose
values is passed, then a tibble object without the subject id is returned.
as.numeric() can be wrapped around the latter to output a numeric vector.
</p>


<h3>References</h3>

<p>Leelarathna (2020) Evaluating Glucose Control With a Novel Composite
Continuous Glucose Monitoring Index,
<em>Diabetes Technology and Therapeutics</em> <strong>14(2)</strong> 277-284,
<a href="https://doi.org/10.1177/1932296819838525">doi:10.1177/1932296819838525</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(example_data_1_subject)

cogi(example_data_1_subject)
cogi(example_data_1_subject, targets = c(50, 140), weights = c(.3,.6,.1))

data(example_data_5_subject)

cogi(example_data_5_subject)
cogi(example_data_5_subject, targets = c(80, 180), weights = c(.2,.4,.4))

</code></pre>

<hr>
<h2 id='conga'>Continuous Overall Net Glycemic Action (CONGA)</h2><span id='topic+conga'></span>

<h3>Description</h3>

<p>The function conga produces CONGA values a tibble object for any n hours apart.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conga(data, n = 24, tz = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conga_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;.</p>
</td></tr>
<tr><td><code id="conga_+3A_n">n</code></td>
<td>
<p>An integer specifying how many hours prior to an observation should be used in the CONGA calculation. The default value is set to n = 24 hours</p>
</td></tr>
<tr><td><code id="conga_+3A_tz">tz</code></td>
<td>
<p>A character string specifying the time zone to be used. System-specific (see <code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code>), but &quot; &quot; is the current time zone, and &quot;GMT&quot; is UTC (Universal Time, Coordinated). Invalid values are most commonly treated as UTC, on some platforms with a warning.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tibble object with 1 row for each subject, a column for subject id and
a column for the CONGA values is returned.
</p>
<p>Missing values will be linearly interpolated when close enough to non-missing values.
</p>
<p>CONGA is the standard deviation of the difference between glucose values that are exactly n hours apart. CONGA is computed by taking the standard deviation of differences in measurements separated by n hours.
</p>


<h3>Value</h3>

<p>A tibble object with two columns: subject id and corresponding CONGA value.
</p>


<h3>References</h3>

<p>McDonnell et al. (2005) : A novel approach to continuous glucose analysis
utilizing glycemic variation
<em>Diabetes Technology and Therapeutics</em> <strong>7</strong> .253-263,
<a href="https://doi.org/10.1089/dia.2005.7.253">doi:10.1089/dia.2005.7.253</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(example_data_1_subject)
conga(example_data_1_subject)

data(example_data_5_subject)
conga(example_data_5_subject)

</code></pre>

<hr>
<h2 id='cv_glu'>Calculate Coefficient of Variation (CV) of glucose levels</h2><span id='topic+cv_glu'></span>

<h3>Description</h3>

<p>The function cv_glu produces CV values in a tibble object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv_glu(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv_glu_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;,
or numeric vector of glucose values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tibble object with 1 row for each subject, a column for subject id and
a column for CV values is returned. NA glucose values are
omitted from the calculation of the CV.
</p>
<p>CV (Coefficient of Variation) is calculated by <code class="reqn">100 * sd(BG) / mean(BG)</code>
Where BG is the list of all Blood Glucose measurements for a subject.
</p>


<h3>Value</h3>

<p>If a data.frame object is passed, then a tibble object with
two columns: subject id and corresponding CV value is returned. If a vector of glucose
values is passed, then a tibble object with just the CV value is returned.
as.numeric() can be wrapped around the latter to output just a numeric value.
</p>


<h3>References</h3>

<p>Rodbard (2009) Interpretation of continuous glucose monitoring data:
glycemic variability and quality of glycemic control,
<em>Diabetes Technology and Therapeutics</em> <strong>11</strong> .55-67,
<a href="https://doi.org/10.1089/dia.2008.0132">doi:10.1089/dia.2008.0132</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(example_data_1_subject)
cv_glu(example_data_1_subject)

data(example_data_5_subject)
cv_glu(example_data_5_subject)

</code></pre>

<hr>
<h2 id='cv_measures'>Calculate Coefficient of Variation subtypes</h2><span id='topic+cv_measures'></span>

<h3>Description</h3>

<p>The function cv_measures produces CV subtype values in a tibble object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv_measures(data, dt0 = NULL, inter_gap = 45, tz = "" )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv_measures_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;. Should only be data for 1 subject. In case multiple subject ids are detected, a warning is produced and only 1st subject is used.</p>
</td></tr>
<tr><td><code id="cv_measures_+3A_dt0">dt0</code></td>
<td>
<p>The time frequency for interpolation in minutes, the default will match the CGM meter's frequency (e.g. 5 min for Dexcom).</p>
</td></tr>
<tr><td><code id="cv_measures_+3A_inter_gap">inter_gap</code></td>
<td>
<p>The maximum allowable gap (in minutes) for interpolation. The values will not be interpolated between the glucose measurements that are more than inter_gap minutes apart. The default value is 45 min.</p>
</td></tr>
<tr><td><code id="cv_measures_+3A_tz">tz</code></td>
<td>
<p>A character string specifying the time zone to be used. System-specific (see <code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code>), but &quot; &quot; is the current time zone, and &quot;GMT&quot; is UTC (Universal Time, Coordinated). Invalid values are most commonly treated as UTC, on some platforms with a warning.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tibble object with 1 row for each subject, a column for subject id and
a column for each cv subtype values is returned.
</p>
<p>Missing values will be linearly interpolated when close enough to non-missing values.
</p>

<ol>
<li><p> CVmean:
</p>
<p>Calculated by first taking the coefficient of variation of each day's glucose measurements,
then taking the mean of all the coefficient of variation. That is, for x
days we compute cv_1 ... cv_x daily coefficient of variations and calculate
<code class="reqn">1/x * \sum [(cv_i)]</code>
</p>
</li>
<li><p> CVsd:
</p>
<p>Calculated by first taking the coefficient of variation of each day's glucose measurements,
then taking the standard deviation of all the coefficient of variations. That is, for d
days we compute cv_1 ... cv_d daily coefficient of variations and calculate SD([cv_1, cv_2, ... cv_d])
</p>
</li></ol>



<h3>Value</h3>

<p>When a data.frame object is passed, then a tibble object with
three columns: subject id and corresponding CV subtype values is returned.
</p>


<h3>References</h3>

<p>Umpierrez, et.al. (2018) Glycemic Variability: How to Measure and Its Clinical
Implication for Type 2 Diabetes
<em>The American Journal of Medical Sciences</em> <strong>356</strong> .518-527,
<a href="https://doi.org/10.1016/j.amjms.2018.09.010">doi:10.1016/j.amjms.2018.09.010</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(example_data_1_subject)
cv_measures(example_data_1_subject)

data(example_data_5_subject)
cv_measures(example_data_5_subject)

</code></pre>

<hr>
<h2 id='ea1c'>Calculate eA1C</h2><span id='topic+ea1c'></span>

<h3>Description</h3>

<p>The function ea1c produces eA1C values in a tibble object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ea1c(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ea1c_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;,
or numeric vector of glucose values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tibble object with 1 row for each subject, a column for subject id and
a column for eA1C values is returned. NA glucose values are
omitted from the calculation of the eA1C.
</p>
<p>eA1C score is calculated by <code class="reqn">(46.7+mean(BG))/28.7</code>
where BG is the vector of Blood Glucose Measurements (mg/dL).
</p>


<h3>Value</h3>

<p>If a data.frame object is passed, then a tibble object with
two columns: subject id and corresponding eA1C is returned. If a vector of glucose
values is passed, then a tibble object with just the eA1C value is returned.
as.numeric() can be wrapped around the latter to output just a numeric value.
</p>


<h3>Author(s)</h3>

<p>Marielle Hicban
</p>


<h3>References</h3>

<p>Nathan (2008) Translating the A1C assay into estimated average glucose
values
<em>Hormone and Metabolic Research</em> <strong>31</strong> .1473-1478,
<a href="https://doi.org/10.2337/dc08-0545">doi:10.2337/dc08-0545</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(example_data_1_subject)
ea1c(example_data_1_subject)

data(example_data_5_subject)
ea1c(example_data_5_subject)

</code></pre>

<hr>
<h2 id='epicalc_profile'>Display Episode Calculation statistics for selected subject</h2><span id='topic+epicalc_profile'></span>

<h3>Description</h3>

<p>Display Episode Calculation statistics for selected subject
</p>


<h3>Usage</h3>

<pre><code class='language-R'>epicalc_profile(
  data,
  lv1_hypo = 70,
  lv2_hypo = 54,
  lv1_hyper = 180,
  lv2_hyper = 250,
  dur_length = 15,
  end_length = 15,
  subject = NULL,
  dt0 = NULL,
  inter_gap = 45,
  tz = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="epicalc_profile_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;. Should only be data for 1 subject. In case multiple subject ids are detected, a warning is produced and only 1st subject is used.</p>
</td></tr>
<tr><td><code id="epicalc_profile_+3A_lv1_hypo">lv1_hypo</code></td>
<td>
<p>Numeric value specifying a hypoglycemia threshold for level 1</p>
</td></tr>
<tr><td><code id="epicalc_profile_+3A_lv2_hypo">lv2_hypo</code></td>
<td>
<p>Numeric value specifying a hypoglycemia threshold for level 2</p>
</td></tr>
<tr><td><code id="epicalc_profile_+3A_lv1_hyper">lv1_hyper</code></td>
<td>
<p>Numeric value specifying a hyperglycemia threshold for level 1</p>
</td></tr>
<tr><td><code id="epicalc_profile_+3A_lv2_hyper">lv2_hyper</code></td>
<td>
<p>Numeric value specifying a hyperglycemia threshold for level 2</p>
</td></tr>
<tr><td><code id="epicalc_profile_+3A_dur_length">dur_length</code></td>
<td>
<p>Numeric value specifying the minimum duration in minutes to be
considered an episode. Note dur_length should be a multiple of the data recording
interval otherwise the function will round up to the nearest multiple. Default
is 15 minutes to match consensus.</p>
</td></tr>
<tr><td><code id="epicalc_profile_+3A_end_length">end_length</code></td>
<td>
<p>Numeric value specifying the minimum duration in minutes of
improved glycemia for an episode to end. Default is equal to dur_length to match consensus.</p>
</td></tr>
<tr><td><code id="epicalc_profile_+3A_subject">subject</code></td>
<td>
<p>String corresponding to subject id</p>
</td></tr>
<tr><td><code id="epicalc_profile_+3A_dt0">dt0</code></td>
<td>
<p>The time frequency for interpolation in minutes, the default will match the CGM meter's frequency (e.g. 5 min for Dexcom).</p>
</td></tr>
<tr><td><code id="epicalc_profile_+3A_inter_gap">inter_gap</code></td>
<td>
<p>The maximum allowable gap (in minutes) for interpolation. The values will not be interpolated between the glucose measurements that are more than inter_gap minutes apart. The default value is 45 min.</p>
</td></tr>
<tr><td><code id="epicalc_profile_+3A_tz">tz</code></td>
<td>
<p>A character string specifying the time zone to be used. System-specific (see <code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code>), but &quot; &quot; is the current time zone, and &quot;GMT&quot; is UTC (Universal Time, Coordinated). Invalid values are most commonly treated as UTC, on some platforms with a warning.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot displaying (1) the statistics for the episodes and (2) the episodes colored by level.
</p>


<h3>Author(s)</h3>

<p>Johnathan Shih, Jung Hoon Seo, Elizabeth Chun
</p>


<h3>See Also</h3>

<p>episode_calculation()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>epicalc_profile(example_data_1_subject)

</code></pre>

<hr>
<h2 id='episode_calculation'>Calculates Hypo/Hyperglycemic episodes with summary statistics</h2><span id='topic+episode_calculation'></span>

<h3>Description</h3>

<p>The function determines episodes or events, calculates summary statistics,
and optionally returns data with episode label columns added
</p>


<h3>Usage</h3>

<pre><code class='language-R'>episode_calculation(
  data,
  lv1_hypo = 70,
  lv2_hypo = 54,
  lv1_hyper = 180,
  lv2_hyper = 250,
  dur_length = 15,
  end_length = 15,
  return_data = FALSE,
  dt0 = NULL,
  inter_gap = 45,
  tz = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="episode_calculation_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;. Should only be data for 1 subject. In case multiple subject ids are detected, a warning is produced and only 1st subject is used.</p>
</td></tr>
<tr><td><code id="episode_calculation_+3A_lv1_hypo">lv1_hypo</code></td>
<td>
<p>Numeric value specifying a hypoglycemia threshold for level 1</p>
</td></tr>
<tr><td><code id="episode_calculation_+3A_lv2_hypo">lv2_hypo</code></td>
<td>
<p>Numeric value specifying a hypoglycemia threshold for level 2</p>
</td></tr>
<tr><td><code id="episode_calculation_+3A_lv1_hyper">lv1_hyper</code></td>
<td>
<p>Numeric value specifying a hyperglycemia threshold for level 1</p>
</td></tr>
<tr><td><code id="episode_calculation_+3A_lv2_hyper">lv2_hyper</code></td>
<td>
<p>Numeric value specifying a hyperglycemia threshold for level 2</p>
</td></tr>
<tr><td><code id="episode_calculation_+3A_dur_length">dur_length</code></td>
<td>
<p>Numeric value specifying the minimum duration in minutes to be
considered an episode. Note dur_length should be a multiple of the data recording
interval otherwise the function will round up to the nearest multiple. Default
is 15 minutes to match consensus.</p>
</td></tr>
<tr><td><code id="episode_calculation_+3A_end_length">end_length</code></td>
<td>
<p>Numeric value specifying the minimum duration in minutes of
improved glycemia for an episode to end. Default is equal to dur_length to match consensus.</p>
</td></tr>
<tr><td><code id="episode_calculation_+3A_return_data">return_data</code></td>
<td>
<p>Boolean indicating whether to also return data with episode labels.
Defaults to FALSE which means only episode summary statistics will be returned</p>
</td></tr>
<tr><td><code id="episode_calculation_+3A_dt0">dt0</code></td>
<td>
<p>The time frequency for interpolation in minutes, the default will match the CGM meter's frequency (e.g. 5 min for Dexcom).</p>
</td></tr>
<tr><td><code id="episode_calculation_+3A_inter_gap">inter_gap</code></td>
<td>
<p>The maximum allowable gap (in minutes) for interpolation. The values will not be interpolated between the glucose measurements that are more than inter_gap minutes apart. The default value is 45 min.</p>
</td></tr>
<tr><td><code id="episode_calculation_+3A_tz">tz</code></td>
<td>
<p>A character string specifying the time zone to be used. System-specific (see <code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code>), but &quot; &quot; is the current time zone, and &quot;GMT&quot; is UTC (Universal Time, Coordinated). Invalid values are most commonly treated as UTC, on some platforms with a warning.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We follow the definition of episodes given in the 2023 consensus by Battelino et al.
Note we have classified lv2 as a subset of lv1 since we find the consensus to be
slightly ambiguous. For lv1 exclusive of lv2, please see lv1_excl which summarises
episodes that were exclusively lv1 and did not cross the lv2 threshold. Also note,
hypo extended refers to episodes that are &gt;120 consecutive minutes below lv1 hypo
and ends with at least 15 minutes of normoglycemia. For more details on each category
please see the reference below (Battelino et al 2023).
</p>


<h3>Value</h3>

<p>If return_data is FALSE, a single dataframe with columns:
</p>
<table>
<tr><td><code>id</code></td>
<td>
<p>Subject id</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Type of episode - either hypoglycemia or hyperglycemia</p>
</td></tr>
<tr><td><code>level</code></td>
<td>
<p>Level of episode - one of lv1, lv2, extended, lv1_excl</p>
</td></tr>
<tr><td><code>avg_ep_per_day</code></td>
<td>
<p>Average number of episodes per day calculated as
(total # episodes)/(recording time in days (24hrs))</p>
</td></tr>
<tr><td><code>avg_ep_duration</code></td>
<td>
<p>Average duration of episodes in minutes</p>
</td></tr>
<tr><td><code>avg_ep_gl</code></td>
<td>
<p>Average glucose in the episode in mg/dL</p>
</td></tr>
<tr><td><code>total_episodes</code></td>
<td>
<p>Total number of episodes in the subject's glucose trace</p>
</td></tr>
</table>
<p>If return_data is TRUE, returns a list where the first entry is the episode summary dataframe
(see above) and the second entry is the input data with episode labels added. Note
the data returned here has been interpolated using the CGMS2DayByDay() function.
Mostly for use with epicalc_profile function. Format of the second list entry is:
</p>
<table>
<tr><td><code>id</code></td>
<td>
<p>Subject id</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>Interpolated timestamps</p>
</td></tr>
<tr><td><code>gl</code></td>
<td>
<p>glucose in mg/dL</p>
</td></tr>
<tr><td><code>[episode_label]</code></td>
<td>
<p>One column per episode label - i.e. lv1_hypo, lv2_hypo, lv1_hyper, lv2_hyper, ext_hypo.
0 means not this type of episode, a positive integer label is assigned to each episode.
Note the labels are *not* unique by subject only unique by segment</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elizabeth Chun, Jung Hoon Seo, Johnathan Shih
</p>


<h3>References</h3>

<p>Battelino et al. (2023): Continuous glucose monitoring and metrics for clinical
trials: an international consensus statement
<em>Lancet Diabetes &amp; Endocrinology</em> <strong>11(1)</strong> .42-57,
<a href="https://doi.org/10.1016/s2213-8587%2822%2900319-9">doi:10.1016/s2213-8587(22)00319-9</a>.
</p>


<h3>See Also</h3>

<p>epicalc_profile()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>episode_calculation(example_data_5_subject, lv1_hypo=100, lv1_hyper= 120)

</code></pre>

<hr>
<h2 id='example_data_1_subject'>Example CGM data for one subject with Type II diabetes</h2><span id='topic+example_data_1_subject'></span>

<h3>Description</h3>

<p>Dexcom G4 CGM measurements from 1 subject with Type II diabetes, this is a subset of <a href="#topic+example_data_5_subject">example_data_5_subject</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_data_1_subject
</code></pre>


<h3>Format</h3>

<p>A data.frame with 2915 rows and 3 columns, which are:
</p>

<dl>
<dt>id</dt><dd><p>identifier of subject</p>
</dd>
<dt>time</dt><dd><p>5-10 minute time value</p>
</dd>
<dt>gl</dt><dd><p>glucose level</p>
</dd>
</dl>


<hr>
<h2 id='example_data_5_subject'>Example CGM data for 5 subjects with Type II diabetes</h2><span id='topic+example_data_5_subject'></span>

<h3>Description</h3>

<p>Dexcom G4 CGM measurements for 5 subjects with Type II diabetes.
These data are part of a larger study sample that consisted of patients with Type 2
diabetes recruited from the general community. To be eligible, patients with Type 2 diabetes, not using insulin therapy and with a glycosylated hemoglobin (<code class="reqn">HbA_{1c}</code>) value at least 6.5
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_data_5_subject
</code></pre>


<h3>Format</h3>

<p>A data.frame with 13866 rows and 3 columns, which are:
</p>

<dl>
<dt>id</dt><dd><p>identifier of subject</p>
</dd>
<dt>time</dt><dd><p>date and time stamp</p>
</dd>
<dt>gl</dt><dd><p>glucose level as measured by CGM (mg/dL)</p>
</dd>
</dl>


<hr>
<h2 id='example_data_hall'>Example data from Hall et al. (2018)</h2><span id='topic+example_data_hall'></span>

<h3>Description</h3>

<p>Dexcom G4 CGM measurements for 19 subjects from the Hall
publicly available dataset. Chosen as a subset of all subjects to be only those
with diabetes or pre-diabetes. Primarily intended for use with example_meals_hall
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_data_hall
</code></pre>


<h3>Format</h3>

<p>a data.frame with 34890 rows and 4 columns, which are:
</p>

<dl>
<dt>id</dt><dd><p>identifier of subject</p>
</dd>
<dt>time</dt><dd><p>date and time stamp</p>
</dd>
<dt>gl</dt><dd><p>glucose level as measured by CGM (mg/dL)</p>
</dd>
<dt>diagnosis</dt><dd><p>character indicating diabetes diagnosis: diabetic or pre-diabetic</p>
</dd>
</dl>



<h3>Details</h3>

<p>This dataset can be used along with the example_meals_hall dataset in this package
to calculate meal_metrics.
</p>


<h3>References</h3>

<p>Hall et al. (2018) : Glucotypes reveal new patterns of glucose dysregulation
<em>Plos Biology</em> <strong>16</strong> (7): 3:e2005143
<a href="https://doi.org/10.1371/journal.pbio.2005143">doi:10.1371/journal.pbio.2005143</a>.
</p>

<hr>
<h2 id='example_meals_hall'>Example mealtimes data from Hall et al. (2018)</h2><span id='topic+example_meals_hall'></span>

<h3>Description</h3>

<p>Example of mealtimes data format for meal_metrics function,
corresponds to example_data_hall data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_meals_hall
</code></pre>


<h3>Format</h3>

<p>A data.frame with 9 rows and 3 columns, which are:
</p>

<dl>
<dt>id</dt><dd><p>identifier of subject</p>
</dd>
<dt>meal</dt><dd><p>meal type identifier</p>
</dd>
<dt>mealtime</dt><dd><p>time of meal</p>
</dd>
</dl>



<h3>Details</h3>

<p>There are 3 types of meals available: Cereal Flakes (CF), Peanut Butter
Sandwich (PB), and Protein Bar (Bar). The number after the abbreviation
refers to the replication number for the original study. For more details
on nutritional differences, please see the original study reference.
</p>
<p>This dataset should be used along with example_data_hall to calculate meal_metrics.
</p>


<h3>References</h3>

<p>Hall et al. (2018) : Glucotypes reveal new patterns of glucose dysregulation
<em>Plos Biology</em> <strong>16</strong> (7): 3:e2005143
<a href="https://doi.org/10.1371/journal.pbio.2005143">doi:10.1371/journal.pbio.2005143</a>.
</p>

<hr>
<h2 id='gmi'>Calculate GMI</h2><span id='topic+gmi'></span>

<h3>Description</h3>

<p>The function gmi produces GMI values in a tibble object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmi(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gmi_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;,
or numeric vector of glucose values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tibble object with 1 row for each subject, a column for subject id and
a column for GMI values is returned. NA glucose values are
omitted from the calculation of the GMI.
</p>
<p>GMI score is calculated by <code class="reqn">3.31 + (.02392*mean(BG))</code>
where BG is the vector of Blood Glucose Measurements (mg/dL).
</p>


<h3>Value</h3>

<p>If a data.frame object is passed, then a tibble object with
two columns: subject id and corresponding GMI is returned. If a vector of glucose
values is passed, then a tibble object with just the GMI value is returned.
as.numeric() can be wrapped around the latter to output just a numeric value.
</p>


<h3>References</h3>

<p>Bergenstal (2018) Glucose Management Indicator (GMI): A New Term for
Estimating A1C From Continuous Glucose Monitoring
<em>Hormone and Metabolic Research</em> <strong>41</strong> .2275-2280,
<a href="https://doi.org/10.2337/dc18-1581">doi:10.2337/dc18-1581</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(example_data_1_subject)
gmi(example_data_1_subject)

data(example_data_5_subject)
gmi(example_data_5_subject)

</code></pre>

<hr>
<h2 id='grade'>Calculate mean GRADE score</h2><span id='topic+grade'></span>

<h3>Description</h3>

<p>The function grade produces GRADE score values in a tibble object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grade(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grade_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;,
or numeric vector of glucose values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tibble object with 1 row for each subject, a column for subject id and
a column for GRADE values is returned. NA glucose values are
omitted from the calculation of the GRADE.
</p>
<p>GRADE score is calculated by <code class="reqn">1/n * \sum [425 *
(log(log(BG_i / 18)) + .16)^2]</code>
Where <code class="reqn">BG_i</code> is the ith Blood Glucose measurement and n is the total
number of measurements.
</p>


<h3>Value</h3>

<p>If a data.frame object is passed, then a tibble object with
two columns: subject id and corresponding GRADE value is returned. If a vector of glucose
values is passed, then a tibble object with just the GRADE value is returned.
as.numeric() can be wrapped around the latter to output just a numeric value.
</p>


<h3>References</h3>

<p>Hill et al. (2007): A method for assessing quality of control
from glucose profiles
<em>Diabetic Medicine</em> <strong>24</strong> .753-758,
<a href="https://doi.org/10.1111/j.1464-5491.2007.02119.x">doi:10.1111/j.1464-5491.2007.02119.x</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(example_data_1_subject)
grade(example_data_1_subject)

data(example_data_5_subject)
grade(example_data_5_subject)

</code></pre>

<hr>
<h2 id='grade_eugly'>Percentage of GRADE score attributable to target range</h2><span id='topic+grade_eugly'></span>

<h3>Description</h3>

<p>The function grade_eugly produces %GRADE euglycemia values in a tibble object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grade_eugly(data, lower = 70, upper = 140)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grade_eugly_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;,
or numeric vector of glucose values.</p>
</td></tr>
<tr><td><code id="grade_eugly_+3A_lower">lower</code></td>
<td>
<p>Lower bound used for hypoglycemia cutoff, in mg/dL. Default is 70</p>
</td></tr>
<tr><td><code id="grade_eugly_+3A_upper">upper</code></td>
<td>
<p>Upper bound used for hyperglycemia cutoff, in mg/dL. Default is 140.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tibble object with 1 row for each subject, a column for subject id and
a column for %GRADE euglycemia values is returned. NA glucose values are
omitted from the calculation of the %GRADE euglycemia values.
</p>
<p>%GRADE euglycemia is determined by calculating the percentage of GRADE score (see grade
function) attributed to values in the target range, i.e. values not below
hypoglycemic or above hyperglycemic cutoffs.
</p>


<h3>Value</h3>

<p>If a data.frame object is passed, then a tibble object with
two columns: subject id and corresponding %GRADE euglycemia value is returned. If a vector of glucose
values is passed, then a tibble object with just the %GRADE euglycemia value is returned.
as.numeric() can be wrapped around the latter to output just a numeric value.
</p>


<h3>References</h3>

<p>Hill et al. (2007): A method for assessing quality of control
from glucose profiles
<em>Diabetic Medicine</em> <strong>24</strong> .753-758,
<a href="https://doi.org/10.1111/j.1464-5491.2007.02119.x">doi:10.1111/j.1464-5491.2007.02119.x</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(example_data_1_subject)
grade_eugly(example_data_1_subject)
grade_eugly(example_data_1_subject, lower = 80, upper = 180)

data(example_data_5_subject)
grade_eugly(example_data_5_subject)
grade_eugly(example_data_5_subject, lower = 80, upper = 160)

</code></pre>

<hr>
<h2 id='grade_hyper'>Percentage of GRADE score attributable to hyperglycemia</h2><span id='topic+grade_hyper'></span>

<h3>Description</h3>

<p>The function grade_hyper produces %GRADE hyperglycemia values in a tibble object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grade_hyper(data, upper = 140)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grade_hyper_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;,
or numeric vector of glucose values.</p>
</td></tr>
<tr><td><code id="grade_hyper_+3A_upper">upper</code></td>
<td>
<p>Upper bound used for hyperglycemia cutoff, in mg/dL. Default is 140.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tibble object with 1 row for each subject, a column for subject id and
a column for %GRADE hyperglycemia values is returned. NA glucose values are
omitted from the calculation of the %GRADE hyperglycemia values.
</p>
<p>%GRADE hyperglycemia is determined by calculating the percentage of
GRADE score (see grade function) attributed to hyperglycemic glucose values.
</p>


<h3>Value</h3>

<p>If a data.frame object is passed, then a tibble object with
two columns: subject id and corresponding %GRADE hyperglycemia value is returned. If a vector of glucose
values is passed, then a tibble object with just the %GRADE hyperglycemia value is returned.
as.numeric() can be wrapped around the latter to output just a numeric value.
</p>


<h3>References</h3>

<p>Hill et al. (2007): A method for assessing quality of control
from glucose profiles
<em>Diabetic Medicine</em> <strong>24</strong> .753-758,
<a href="https://doi.org/10.1111/j.1464-5491.2007.02119.x">doi:10.1111/j.1464-5491.2007.02119.x</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(example_data_1_subject)
grade_hyper(example_data_1_subject)
grade_hyper(example_data_1_subject, upper = 180)

data(example_data_5_subject)
grade_hyper(example_data_5_subject)
grade_hyper(example_data_5_subject, upper = 160)

</code></pre>

<hr>
<h2 id='grade_hypo'>Percentage of GRADE score attributable to hypoglycemia</h2><span id='topic+grade_hypo'></span>

<h3>Description</h3>

<p>The function grade_hypo produces %GRADE hypoglycemia values in a tibble object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grade_hypo(data, lower = 80)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grade_hypo_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;,
or numeric vector of glucose values.</p>
</td></tr>
<tr><td><code id="grade_hypo_+3A_lower">lower</code></td>
<td>
<p>Lower bound used for hypoglycemia cutoff, in mg/dL. Default is 80</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tibble object with 1 row for each subject, a column for subject id and
a column for %GRADE hypoglycemia values is returned. NA glucose values are
omitted from the calculation of the %GRADE hypoglycemia values.
</p>
<p>%GRADE hypoglycemia is determined by calculating the percentage of
GRADE score (see grade function) attributed to hypoglycemic glucose values.
</p>


<h3>Value</h3>

<p>If a data.frame object is passed, then a tibble object with
two columns: subject id and corresponding %GRADE hypoglycemia value is returned. If a vector of glucose
values is passed, then a tibble object with just the %GRADE hypoglycemia value is returned.
as.numeric() can be wrapped around the latter to output just a numeric value.
</p>


<h3>References</h3>

<p>Hill et al. (2007): A method for assessing quality of control
from glucose profiles
<em>Diabetic Medicine</em> <strong>24</strong> .753-758,
<a href="https://doi.org/10.1111/j.1464-5491.2007.02119.x">doi:10.1111/j.1464-5491.2007.02119.x</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(example_data_1_subject)
grade_hypo(example_data_1_subject)
grade_hypo(example_data_1_subject, lower = 70)

data(example_data_5_subject)
grade_hypo(example_data_5_subject)
grade_hypo(example_data_5_subject, lower = 65)

</code></pre>

<hr>
<h2 id='gri'>Calculate Glycemia Risk Index (GRI)</h2><span id='topic+gri'></span>

<h3>Description</h3>

<p>The function gri produces a tibble object with values equal to
the glycemia risk index (GRI) metric. The output columns are subject id and
GRI value. ' The output rows correspond to subjects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gri(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gri_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;,
or numeric vector of glucose values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tibble object with 1 row for each subject, a column for subject id and
column for GRI is returned. The formula for GRI is as follows:
</p>
<p><code class="reqn">(3.0 × VLow) + (2.4 × Low) + (1.6 × VHigh) + (0.8 × High)</code>
</p>
<p>where VLow, Low, VHigh, and High correspond to the percent of glucose values
in the ranges &lt;54 mg/dL, 54-70 mg/dL, &gt;250 mg/dL, and 180-250 mg/dL respectively.
The maximum allowed value for GRI is 100%, any calculated values higher than
100 are capped.
</p>


<h3>Value</h3>

<p>A tibble object with columns for subject id and GRI value. Rows
correspond to individual subjects.
</p>


<h3>Author(s)</h3>

<p>Elizabeth Chun
</p>


<h3>References</h3>

<p>Klonoff et al. (2022) A Glycemia Risk Index (GRI) of Hypoglycemia and Hyperglycemia
for Continuous Glucose Monitoring Validated by Clinician Ratings.
<em>J Diabetes Sci Technol</em>
<a href="https://doi.org/10.1177/19322968221085273">doi:10.1177/19322968221085273</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(example_data_1_subject)
gri(example_data_1_subject)

data(example_data_5_subject)
gri(example_data_5_subject)

</code></pre>

<hr>
<h2 id='gvp'>Calculate Glucose Variability Percentage (GVP)</h2><span id='topic+gvp'></span>

<h3>Description</h3>

<p>The function mad produces GVP values in a tibble object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gvp(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gvp_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tibble object with 1 row for each subject, a column for subject id and
a column for GVP values is returned. NA glucose values are
omitted from the calculation of the GVP.
</p>
<p>GVP is calculated by dividing the total length of the line of the glucose trace
by the length of a perfectly flat trace. The formula for this is
<code class="reqn">sqrt(diff^2+dt0^2)/(n*dt0)</code>, where diff is the change in
Blood Glucose measurements from one reading to the next,
dt0 is the time gap between measurements and n is the number of glucose readings
</p>


<h3>Value</h3>

<p>A tibble object with two columns:
subject id and corresponding GVP value.
</p>


<h3>Author(s)</h3>

<p>David Buchanan, Mary Martin
</p>


<h3>References</h3>

<p>Peyser et al. (2017) Glycemic Variability Percentage: A Novel Method for Assessing
Glycemic Variability from Continuous Glucose Monitor Data.
<em>Diabetes Technol Ther</em> <strong>20</strong>(1):6–16,
<a href="https://doi.org/10.1089/dia.2017.0187">doi:10.1089/dia.2017.0187</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(example_data_1_subject)
gvp(example_data_1_subject)

data(example_data_5_subject)
gvp(example_data_5_subject)

</code></pre>

<hr>
<h2 id='hbgi'>Calculate High Blood Glucose Index (HBGI)</h2><span id='topic+hbgi'></span>

<h3>Description</h3>

<p>The function hbgi produces HBGI values in a tibble object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hbgi(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hbgi_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;,
or numeric vector of glucose values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tibble object with 1 row for each subject, a column for subject id and
a column for HBGI values is returned. NA glucose values are
omitted from the calculation of the HBGI.
</p>
<p>HBGI is calculated by <code class="reqn">1/n * \sum (10 * fbg_i ^2)</code>,
where <code class="reqn">fbg_i = max(0, 1.509 * (log(BG_i)^{1.084} - 5.381)</code>,
BG_i is the ith Blood Glucose measurement for a subject, and
n is the total number of measurements for that subject.
</p>


<h3>Value</h3>

<p>If a data.frame object is passed, then a tibble object with
two columns: subject id and corresponding HBGI value is returned. If a vector of glucose
values is passed, then a tibble object with just the HBGI value is returned.
as.numeric() can be wrapped around the latter to output just a numeric value.
</p>


<h3>References</h3>

<p>Kovatchev et al. (2006) Evaluation of a New Measure of Blood Glucose Variability in,
Diabetes
<em>Diabetes care</em> <strong>29</strong> .2433-2438,
<a href="https://doi.org/10.2337/dc06-1085">doi:10.2337/dc06-1085</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(example_data_1_subject)
hbgi(example_data_1_subject)

data(example_data_5_subject)
hbgi(example_data_5_subject)

</code></pre>

<hr>
<h2 id='hist_roc'>Plot histogram of Rate of Change values (ROC)</h2><span id='topic+hist_roc'></span>

<h3>Description</h3>

<p>The function hist_roc produces a histogram plot of ROC values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hist_roc(data, subjects = NULL, timelag = 15, dt0 = NULL, inter_gap = 45, tz = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hist_roc_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;.</p>
</td></tr>
<tr><td><code id="hist_roc_+3A_subjects">subjects</code></td>
<td>
<p>String or list of strings corresponding to subject names
in 'id' column of data. Default is all subjects.</p>
</td></tr>
<tr><td><code id="hist_roc_+3A_timelag">timelag</code></td>
<td>
<p>Integer indicating the time period (# minutes) over which rate
of change is calculated. Default is 15, e.g. rate of change is the change in
glucose over the past 15 minutes divided by 15.</p>
</td></tr>
<tr><td><code id="hist_roc_+3A_dt0">dt0</code></td>
<td>
<p>The time frequency for interpolation in minutes, the default will match the CGM meter's frequency (e.g. 5 min for Dexcom).</p>
</td></tr>
<tr><td><code id="hist_roc_+3A_inter_gap">inter_gap</code></td>
<td>
<p>The maximum allowable gap (in minutes) for interpolation. The values will not be interpolated between the glucose measurements that are more than inter_gap minutes apart. The default value is 45 min.</p>
</td></tr>
<tr><td><code id="hist_roc_+3A_tz">tz</code></td>
<td>
<p>A character string specifying the time zone to be used. System-specific (see <code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code>), but &quot; &quot; is the current time zone, and &quot;GMT&quot; is UTC (Universal Time, Coordinated). Invalid values are most commonly treated as UTC, on some platforms with a warning.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the default, a histogram is produced for each subject displaying the ROC values
colored by ROC categories defined as follows. The breaks for the categories are:
c(-Inf, -3, -2, -1, 1, 2, 3, Inf) where the glucose is in mg/dl and the ROC values are in mg/dl/min.
A ROC of -5 mg/dl/min will thus be placed in the first category and colored accordingly.
</p>


<h3>Value</h3>

<p>A histogram of ROC values per subject
</p>


<h3>Author(s)</h3>

<p>Elizabeth Chun, David Buchanan
</p>


<h3>References</h3>

<p>Clarke et al. (2009) Statistical Tools to Analyze Continuous Glucose Monitor Data,
Diabetes
<em>Diabetes Technology and Therapeutics</em> <strong>11</strong> S45-S54,
<a href="https://doi.org/10.1089/dia.2008.0138">doi:10.1089/dia.2008.0138</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_roc">plot_roc</a></code> for reference paper on ROC categories.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(example_data_1_subject)
hist_roc(example_data_1_subject)

data(example_data_5_subject)
hist_roc(example_data_5_subject)
hist_roc(example_data_5_subject, subjects = 'Subject 3')

</code></pre>

<hr>
<h2 id='hyper_index'>Calculate Hyperglycemia Index</h2><span id='topic+hyper_index'></span>

<h3>Description</h3>

<p>The function hyper_index produces Hyperglycemia Index values in a tibble object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hyper_index(data, ULTR = 140, a = 1.1, c = 30)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hyper_index_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;,
or numeric vector of glucose values.</p>
</td></tr>
<tr><td><code id="hyper_index_+3A_ultr">ULTR</code></td>
<td>
<p>Upper Limit of Target Range, default value is 140 mg/dL.</p>
</td></tr>
<tr><td><code id="hyper_index_+3A_a">a</code></td>
<td>
<p>Exponent, generally in the range from 1.0 to 2.0, default value is 1.1.</p>
</td></tr>
<tr><td><code id="hyper_index_+3A_c">c</code></td>
<td>
<p>Scaling factor, to display Hyperglycemia Index, Hypoglycemia Index, and IGC on approximately the same numerical range as measurements of HBGI, LBGI and GRADE, default value is 30.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tibble object with 1 row for each subject, a column for subject id and
a column for the Hyperglycemia Index values is returned. NA glucose values are
omitted from the calculation of the Hyperglycemia Index values.
</p>
<p>Hyperglycemia Index is calculated by <code class="reqn">n/c * \sum [(hyperBG_j-ULTR) ^{a}]</code>
Here n is the total number of Blood Glucose measurements (excluding NA values), <code class="reqn">hyperBG_j</code>
is the jth Blood Glucose measurement above the ULTR cutoff, a is an exponent, and c is a scaling factor.
</p>


<h3>Value</h3>

<p>If a data.frame object is passed, then a tibble object with
two columns: subject id and corresponding Hyperglycemia Index value is returned. If a vector of glucose
values is passed, then a tibble object with just the Hyperglycemia Index value is returned.
as.numeric() can be wrapped around the latter to output just a numeric value.
</p>


<h3>References</h3>

<p>Rodbard (2009) Interpretation of continuous glucose monitoring data:
glycemic variability and quality of glycemic control,
<em>Diabetes Technology and Therapeutics</em> <strong>11</strong> .55-67,
<a href="https://doi.org/10.1089/dia.2008.0132">doi:10.1089/dia.2008.0132</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(example_data_1_subject)
hyper_index(example_data_1_subject)
hyper_index(example_data_1_subject, ULTR = 160)

data(example_data_5_subject)
hyper_index(example_data_5_subject)
hyper_index(example_data_5_subject, ULTR = 150)

</code></pre>

<hr>
<h2 id='hypo_index'>Calculate Hypoglycemia Index</h2><span id='topic+hypo_index'></span>

<h3>Description</h3>

<p>The function hypo_index produces Hypoglycemia index values in a tibble object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hypo_index(data, LLTR = 80, b = 2, d = 30)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hypo_index_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;,
or numeric vector of glucose values.</p>
</td></tr>
<tr><td><code id="hypo_index_+3A_lltr">LLTR</code></td>
<td>
<p>Lower Limit of Target Range, default value is 80 mg/dL.</p>
</td></tr>
<tr><td><code id="hypo_index_+3A_b">b</code></td>
<td>
<p>Exponent, generally in the range from 1.0 to 2.0, default value is 2.</p>
</td></tr>
<tr><td><code id="hypo_index_+3A_d">d</code></td>
<td>
<p>Scaling factor,to display Hyperglycemia Index, Hypoglycemia Index, and IGC on approximately the same numerical range as measurements of HBGI, LBGI and GRADE, default value is 30.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tibble object with 1 row for each subject, a column for subject id and
a column for the Hypoglycemia Index values is returned. NA glucose values are
omitted from the calculation of the Hypoglycemia Index values.
</p>
<p>Hypoglycemia Index is calculated by <code class="reqn">n/d * \sum [(LLTR-hypoBG_j)^{b}]</code>
Here n is the total number of Blood Glucose measurements (excluding NA values),
and <code class="reqn">hypoBG_j</code> is the jth Blood Glucose measurement below the LLTR cutoff, b is an exponent, and d is a scaling factor.
</p>


<h3>Value</h3>

<p>If a data.frame object is passed, then a tibble object with
two columns: subject id and corresponding Hypoglycemia Index value is returned. If a vector of glucose
values is passed, then a tibble object with just the Hypoglycemia Index value is returned.
as.numeric() can be wrapped around the latter to output just a numeric value.
</p>


<h3>References</h3>

<p>Rodbard (2009) Interpretation of continuous glucose monitoring data:
glycemic variability and quality of glycemic control,
<em>Diabetes Technology and Therapeutics</em> <strong>11</strong> .55-67,
<a href="https://doi.org/10.1089/dia.2008.0132">doi:10.1089/dia.2008.0132</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(example_data_1_subject)
hypo_index(example_data_1_subject, LLTR = 60)

data(example_data_5_subject)
hypo_index(example_data_5_subject)
hypo_index(example_data_5_subject, LLTR = 70)

</code></pre>

<hr>
<h2 id='igc'>Calculate Index of Glycemic Control</h2><span id='topic+igc'></span>

<h3>Description</h3>

<p>The function igc produces IGC values in a tibble object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>igc(data, LLTR = 80, ULTR = 140, a = 1.1, b = 2, c = 30, d = 30)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="igc_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;,
or numeric vector of glucose values.</p>
</td></tr>
<tr><td><code id="igc_+3A_lltr">LLTR</code></td>
<td>
<p>Lower Limit of Target Range, default value is 80 mg/dL.</p>
</td></tr>
<tr><td><code id="igc_+3A_ultr">ULTR</code></td>
<td>
<p>Upper Limit of Target Range, default value is 140 mg/dL.</p>
</td></tr>
<tr><td><code id="igc_+3A_a">a</code></td>
<td>
<p>Exponent, generally in the range from 1.0 to 2.0, default value is 1.1.</p>
</td></tr>
<tr><td><code id="igc_+3A_b">b</code></td>
<td>
<p>Exponent, generally in the range from 1.0 to 2.0, default value is 2.</p>
</td></tr>
<tr><td><code id="igc_+3A_c">c</code></td>
<td>
<p>Scaling factor, to display Hyperglycemia Index, Hypoglycemia Index, and IGC on approximately the same numerical range as measurements of HBGI, LBGI and GRADE, default value is 30.</p>
</td></tr>
<tr><td><code id="igc_+3A_d">d</code></td>
<td>
<p>Scaling factor,to display Hyperglycemia Index, Hypoglycemia Index, and IGC on approximately the same numerical range as measurements of HBGI, LBGI and GRADE, default value is 30.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tibble object with 1 row for each subject, a column for subject id and
a column for the IGC values is returned.
</p>
<p>IGC is calculated by taking the sum of the Hyperglycemia
Index and the Hypoglycemia index. See <code><a href="#topic+hypo_index">hypo_index</a></code> and
<code><a href="#topic+hyper_index">hyper_index</a></code>.
</p>


<h3>Value</h3>

<p>A tibble object with two columns: subject id and corresponding IGC value.
</p>


<h3>References</h3>

<p>Rodbard (2009) Interpretation of continuous glucose monitoring data:
glycemic variability and quality of glycemic control,
<em>Diabetes Technology and Therapeutics</em> <strong>11</strong> .55-67,
<a href="https://doi.org/10.1089/dia.2008.0132">doi:10.1089/dia.2008.0132</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(example_data_1_subject)
igc(example_data_1_subject)
igc(example_data_1_subject, ULTR = 160)

data(example_data_5_subject)
igc(example_data_5_subject)
igc(example_data_5_subject, LLTR = 75, ULTR = 150)

</code></pre>

<hr>
<h2 id='iglu_shiny'>Run IGLU Shiny App</h2><span id='topic+iglu_shiny'></span>

<h3>Description</h3>

<p>Run IGLU Shiny App
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iglu_shiny()
</code></pre>

<hr>
<h2 id='in_range_percent'>Calculate percentage in targeted value ranges</h2><span id='topic+in_range_percent'></span>

<h3>Description</h3>

<p>The function in_range_percent produces a tibble object with values equal to
the percentage of glucose measurements in ranges of target values. The
output columns correspond to subject id followed by the target value ranges,
and the rows correspond to the subjects. The values will be between 0
(no measurements) and 100 (all measurements).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>in_range_percent(data, target_ranges = list(c(70, 180), c(63, 140)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="in_range_percent_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;,
or numeric vector of glucose values.</p>
</td></tr>
<tr><td><code id="in_range_percent_+3A_target_ranges">target_ranges</code></td>
<td>
<p>List of target value ranges wrapped in an r 'list' structure.
Default list of ranges is ((70, 180), (63, 140)) mg/dL, where the range (70, 180) is recommended to assess glycemic control for subjects with type 1 or type 2 diabetes, and (63, 140) is recommended for assessment of glycemic control during pregnancy; see Battelino et al. (2019)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tibble object with 1 row for each subject, a column for subject id and
column for each range of target values is returned. NA's will be omitted from the glucose
values in calculation of percent.
</p>
<p>in_range_percent will only work properly if the target_ranges argument is a list
of paired values in the format list(c(a1,b1), c(a2,b2), ...). The paired
values can be ordered (min, max) or (max, min). See the Examples section
for proper usage.
</p>


<h3>Value</h3>

<p>If a data.frame object is passed, then a tibble object with
a column for subject id and then a column for each target value is returned. If a vector of glucose
values is passed, then a tibble object without the subject id is returned.
as.numeric() can be wrapped around the latter to output a numeric vector.
</p>


<h3>References</h3>

<p>Rodbard (2009) Interpretation of continuous glucose monitoring data:
glycemic variability and quality of glycemic control,
<em>Diabetes Technology and Therapeutics</em> <strong>11</strong> .55-67,
<a href="https://doi.org/10.1089/dia.2008.0132">doi:10.1089/dia.2008.0132</a>.
</p>
<p>Battelino et al. (2019) Clinical targets for continuous glucose monitoring data interpretation: recommendations from the international consensus on time in range. <em>Diabetes Care</em>  <strong>42</strong>(8):1593-603, <a href="https://doi.org/10.2337/dci19-0028">doi:10.2337/dci19-0028</a>
</p>


<h3>See Also</h3>

<p>plot_ranges()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(example_data_1_subject)

in_range_percent(example_data_1_subject)
in_range_percent(example_data_1_subject, target_ranges = list(c(50, 100), c(200,
300), c(80, 140)))

data(example_data_5_subject)

in_range_percent(example_data_5_subject)
in_range_percent(example_data_1_subject, target_ranges = list(c(60, 120), c(140,
250)))

</code></pre>

<hr>
<h2 id='iqr_glu'>Calculate glucose level iqr</h2><span id='topic+iqr_glu'></span>

<h3>Description</h3>

<p>The function iqr_glu outputs the distance between the 25th
percentile and the 25th percentile of the glucose values in a tibble object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iqr_glu(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iqr_glu_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;,
or numeric vector of glucose values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tibble object with 1 row for each subject, a column for subject id and
a column for the IQR values is returned. NA glucose values are
omitted from the calculation of the IQR.
</p>


<h3>Value</h3>

<p>If a data.frame object is passed, then a tibble object with
two columns: subject id and corresponding IQR value is returned. If a vector of glucose
values is passed, then a tibble object with just the IQR value is returned.
as.numeric() can be wrapped around the latter to output just a numeric value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(example_data_1_subject)
iqr_glu(example_data_1_subject)

data(example_data_5_subject)
iqr_glu(example_data_5_subject)

</code></pre>

<hr>
<h2 id='j_index'>Calculate J-index</h2><span id='topic+j_index'></span>

<h3>Description</h3>

<p>The function j_index produces J-Index values a tibble object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>j_index(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="j_index_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;,
or numeric vector of glucose values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tibble object with 1 row for each subject, a column for subject id and
a column for J-Index values is returned. NA glucose values are
omitted from the calculation of the J-Index.
</p>
<p>J-Index score is calculated by <code class="reqn">.001 * [mean(BG) + sd(BG)]^2</code>
where BG is the list of Blood Glucose Measurements.
</p>


<h3>Value</h3>

<p>If a data.frame object is passed, then a tibble object with
two columns: subject id and corresponding J-Index value is returned. If a vector of glucose
values is passed, then a tibble object with just the J-Index value is returned.
as.numeric() can be wrapped around the latter to output just a numeric value.
</p>


<h3>References</h3>

<p>Wojcicki (1995) &quot;J&quot;-index. A new proposition of the assessment
of current glucose control in diabetic patients
<em>Hormone and Metabolic Research</em> <strong>27</strong> .41-42,
<a href="https://doi.org/10.1055/s-2007-979906">doi:10.1055/s-2007-979906</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(example_data_1_subject)
j_index(example_data_1_subject)

data(example_data_5_subject)
j_index(example_data_5_subject)

</code></pre>

<hr>
<h2 id='lbgi'>Calculate Low Blood Glucose Index (LBGI)</h2><span id='topic+lbgi'></span>

<h3>Description</h3>

<p>The function lbgi produces LBGI values in a tibble object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lbgi(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lbgi_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;,
or numeric vector of glucose values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tibble object with 1 row for each subject, a column for subject id and
a column for LBGI values is returned. NA glucose values are
omitted from the calculation of the LBGI.
</p>
<p>LBGI is calculated by <code class="reqn">1/n * \sum (10 * fbg_i ^2)</code>,
where <code class="reqn">fbg_i = min(0, 1.509 * (log(BG_i)^{1.084} - 5.381)</code>,
BG_i is the ith Blood Glucose measurement for a subject, and
n is the total number of measurements for that subject.
</p>


<h3>Value</h3>

<p>If a data.frame object is passed, then a tibble object with
two columns: subject id and corresponding LBGI value is returned. If a vector of glucose
values is passed, then a tibble object with just the LBGI value is returned.
as.numeric() can be wrapped around the latter to output just a numeric value.
</p>


<h3>References</h3>

<p>Kovatchev et al. (2006) Evaluation of a New Measure of Blood Glucose Variability in,
Diabetes
<em>Diabetes care</em> <strong>29</strong> .2433-2438,
<a href="https://doi.org/10.2337/dc06-1085">doi:10.2337/dc06-1085</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(example_data_1_subject)
lbgi(example_data_1_subject)

data(example_data_5_subject)
lbgi(example_data_5_subject)

</code></pre>

<hr>
<h2 id='m_value'>Calculate the M-value</h2><span id='topic+m_value'></span>

<h3>Description</h3>

<p>Calculates the M-value of Schlichtkrull et al. (1965) for
each subject in the data, where the M-value is the mean of the logarithmic
transformation of the deviation from a reference value. Produces a tibble
object with subject id and M-values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>m_value(data, r = 90)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="m_value_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;,
or numeric vector of glucose values.</p>
</td></tr>
<tr><td><code id="m_value_+3A_r">r</code></td>
<td>
<p>A reference value corresponding to basal glycemia in normal
subjects; default is 90 mg/dL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tibble object with 1 row for each subject, a column for subject id and
a column for the M-values is returned. NA glucose values are
omitted from the calculation of the M-value.
</p>
<p>M-value is computed by averaging the transformed glucose values, where each
transformed value is equal to <code class="reqn">|10 * log_10(glucose/r)|^3</code>, where r is the specified reference value.
</p>


<h3>Value</h3>

<p>If a data.frame object is passed, then a tibble object with
two columns: subject id and corresponding M-value is returned. If a vector of glucose
values is passed, then a tibble object with just the M-value is returned.
as.numeric() can be wrapped around the latter to output just a numeric value.
</p>


<h3>References</h3>

<p>Schlichtkrull J, Munck O, Jersild M. (1965) The M-value, an index of
blood-sugar control in diabetics.
<em>Acta Medica Scandinavica</em> <strong>177</strong> .95-102.
<a href="https://doi.org/10.1111/j.0954-6820.1965.tb01810.x">doi:10.1111/j.0954-6820.1965.tb01810.x</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(example_data_5_subject)

m_value(example_data_5_subject)
m_value(example_data_5_subject, r = 100)

</code></pre>

<hr>
<h2 id='mad_glu'>Calculate Median Absolute Deviation (MAD)</h2><span id='topic+mad_glu'></span>

<h3>Description</h3>

<p>The function mad produces MAD values in a tibble object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mad_glu(data, constant = 1.4826)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mad_glu_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;,
or numeric vector of glucose values.</p>
</td></tr>
<tr><td><code id="mad_glu_+3A_constant">constant</code></td>
<td>
<p>Numeric object which will be multipled by the MAD value. Defaults to 1.4826.
Reasons for this default value can be seen in the details section of the documentation of r's base mad method</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tibble object with 1 row for each subject, a column for subject id and
a column for MAD values is returned. NA glucose values are
omitted from the calculation of the MAD.
</p>
<p>MAD is calculated by taking the median of the difference of the
glucose readings from their median and multiplying it by a scaling factor
<code class="reqn">1.4826*median(|gl-median(gl)|)</code>, where gl is the list of Blood Glucose measurements.
</p>


<h3>Value</h3>

<p>If a data.frame object is passed, then a tibble object with
two columns: subject id and corresponding MAD value is returned. If a vector of glucose
values is passed, then a tibble object with just the MAD value is returned.
as.numeric() can be wrapped around the latter to output just a numeric value.
</p>


<h3>Author(s)</h3>

<p>David Buchanan, Marielle Hicban
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(example_data_1_subject)
mad_glu(example_data_1_subject)

data(example_data_5_subject)
mad_glu(example_data_5_subject)

</code></pre>

<hr>
<h2 id='mag'>Calculate the Mean Absolute Glucose (MAG)</h2><span id='topic+mag'></span>

<h3>Description</h3>

<p>The function mag calculates the mean absolute glucose or MAG.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mag(data, n = 60, dt0 = NULL, inter_gap = 45, tz = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mag_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;.</p>
</td></tr>
<tr><td><code id="mag_+3A_n">n</code></td>
<td>
<p>Integer giving the desired interval in minutes over which to calculate
the change in glucose. Default is 60 to have hourly (60 minutes) intervals.</p>
</td></tr>
<tr><td><code id="mag_+3A_dt0">dt0</code></td>
<td>
<p>The time frequency for interpolation in minutes, the default will match the CGM meter's frequency (e.g. 5 min for Dexcom).</p>
</td></tr>
<tr><td><code id="mag_+3A_inter_gap">inter_gap</code></td>
<td>
<p>The maximum allowable gap (in minutes) for interpolation. The values will not be interpolated between the glucose measurements that are more than inter_gap minutes apart. The default value is 45 min.</p>
</td></tr>
<tr><td><code id="mag_+3A_tz">tz</code></td>
<td>
<p>A character string specifying the time zone to be used. System-specific (see <code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code>), but &quot; &quot; is the current time zone, and &quot;GMT&quot; is UTC (Universal Time, Coordinated). Invalid values are most commonly treated as UTC, on some platforms with a warning.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tibble object with a column for subject id and a column for MAG values is
returned.
</p>
<p>The glucose values are linearly interpolated over a time grid starting at the
beginning of the first day of data and ending on the last day of data. Then, MAG
is calculated as <code class="reqn">\frac{|\Delta BG|}{\Delta t}</code> where <code class="reqn">|\Delta BG|</code> is
the sum of the absolute change in blood glucose calculated for each interval as specified
by n, default n = 60 for hourly change in blood glucose. The sum is then divided by
<code class="reqn">\Delta t</code> which is the total time in hours.
</p>


<h3>Value</h3>

<p>A tibble object with two columns: subject id and MAG value
</p>


<h3>Author(s)</h3>

<p>Elizabeth Chun
</p>


<h3>References</h3>

<p>Hermanides et al. (2010) Glucose Variability is Associated with Intensive Care Unit
Mortaility,
<em>Critical Care Medicine</em> <strong>38(3)</strong> 838-842,
<a href="https://doi.org/10.1097/CCM.0b013e3181cc4be9">doi:10.1097/CCM.0b013e3181cc4be9</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(example_data_1_subject)
mag(example_data_1_subject)

data(example_data_5_subject)
mag(example_data_5_subject)

</code></pre>

<hr>
<h2 id='mage'>Calculate Mean Amplitude of Glycemic Excursions</h2><span id='topic+mage'></span>

<h3>Description</h3>

<p>The function calculates MAGE values and can optionally return a plot of the glucose trace.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mage(
  data,
  version = c("ma", "naive"),
  sd_multiplier = 1,
  short_ma = 5,
  long_ma = 32,
  return_type = c("num", "df"),
  direction = c("avg", "service", "max", "plus", "minus"),
  dt0 = NULL,
  tz = "",
  inter_gap = 45,
  max_gap = 180,
  plot = FALSE,
  title = NA,
  xlab = NA,
  ylab = NA,
  show_ma = FALSE,
  show_excursions = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mage_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot; OR numeric vector of glucose values.</p>
</td></tr>
<tr><td><code id="mage_+3A_version">version</code></td>
<td>
<p>Either <code>'ma'</code> or <code>'naive'</code>. <strong>Default: 'ma'.</strong> Chooses which version of the MAGE algorithm to use. <code>'ma'</code> algorithm is more accurate, and is the default. Earlier versions of iglu package (&lt;=2.0.0) used <code>'naive'</code>.</p>
</td></tr>
<tr><td><code id="mage_+3A_sd_multiplier">sd_multiplier</code></td>
<td>
<p>A numeric value that can change the sd value used to determine size of
glycemic excursions used in the calculation. This is the only parameter that
can be specified for <code>version = "naive"</code>, and it is ignored if <code>version = "ma"</code>.</p>
</td></tr>
<tr><td><code id="mage_+3A_short_ma">short_ma</code></td>
<td>
<p>Integer for period length of the short moving average. <strong>Default: 5.</strong> Must be positive and less than &quot;long_ma&quot;. (Recommended &lt;15)</p>
</td></tr>
<tr><td><code id="mage_+3A_long_ma">long_ma</code></td>
<td>
<p>Integer for period length for the long moving average. <strong>Default: 32.</strong> Must be positive and greater than &quot;short_ma&quot;. (Recommended &gt;20)</p>
</td></tr>
<tr><td><code id="mage_+3A_return_type">return_type</code></td>
<td>
<p>One of &quot;num&quot; or &quot;df&quot;. <strong>Default: &quot;num&quot;.</strong> Will return either a single number for the &quot;MAGE over the entire trace&quot; (weighted by segment length) or a DataFrame with the MAGE value for each segment (see the MAGE vignette for discussion of handling gaps by splitting trace into multiple segments).</p>
</td></tr>
<tr><td><code id="mage_+3A_direction">direction</code></td>
<td>
<p>One of &quot;avg&quot;, &quot;service&quot;, &quot;max&quot;, &quot;plus&quot;, or &quot;minus&quot;. <strong>Default: &quot;avg&quot;.</strong> Algorithm will calculate one of the following: MAGE+ (nadir to peak), MAGE- (peak to nadir), MAGEavg = avg(MAGE+, MAGE-), MAGEmax = max(MAGE+, MAGE-), or automatically choose MAGE+/MAGE- based on the first countable excursion (i.e., &quot;service&quot;). NOTE: the selection of peak-to-nadir or nadir-to-peak is chosen independently on each segment, thus MAGEservice may choose peak-to-nadir on one segment and nadir-to-peak on another, for example.</p>
</td></tr>
<tr><td><code id="mage_+3A_dt0">dt0</code></td>
<td>
<p>The time frequency for interpolation in minutes, the default will match the CGM meter's frequency (e.g. 5 min for Dexcom).</p>
</td></tr>
<tr><td><code id="mage_+3A_tz">tz</code></td>
<td>
<p>A character string specifying the time zone to be used. System-specific (see <code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code>), but &quot; &quot; is the current time zone, and &quot;GMT&quot; is UTC (Universal Time, Coordinated). Invalid values are most commonly treated as UTC, on some platforms with a warning.</p>
</td></tr>
<tr><td><code id="mage_+3A_inter_gap">inter_gap</code></td>
<td>
<p>The maximum allowable gap (in minutes) for interpolation. The values will not be interpolated between the glucose measurements that are more than inter_gap minutes apart. The default value is 45 min.</p>
</td></tr>
<tr><td><code id="mage_+3A_max_gap">max_gap</code></td>
<td>
<p>Integer for the maximum length of a gap in minutes before the trace is split into segments and MAGE is calculated on each segment independently. <strong>Default: 180.</strong></p>
</td></tr>
<tr><td><code id="mage_+3A_plot">plot</code></td>
<td>
<p>Boolean. <strong>Default: FALSE.</strong> If TRUE, returns a plot that visualizes all identified peaks and nadirs, excursions, and  missing gaps. An interactive GUI can be loaded with <code>plot_type = 'plotly'</code>.</p>
</td></tr>
<tr><td><code id="mage_+3A_title">title</code></td>
<td>
<p>Title for the ggplot. <strong>Default: &quot;Glucose Trace - Subject [ID]&quot;.</strong></p>
</td></tr>
<tr><td><code id="mage_+3A_xlab">xlab</code></td>
<td>
<p>Label for x-axis of ggplot. <strong>Default: &quot;Time&quot;.</strong></p>
</td></tr>
<tr><td><code id="mage_+3A_ylab">ylab</code></td>
<td>
<p>Label for y-axis of ggplot. <strong>Default: &quot;Glucose Level&quot;.</strong></p>
</td></tr>
<tr><td><code id="mage_+3A_show_ma">show_ma</code></td>
<td>
<p>Boolean. <strong>Default: FALSE.</strong> If TRUE, plots the moving average lines on the plot.</p>
</td></tr>
<tr><td><code id="mage_+3A_show_excursions">show_excursions</code></td>
<td>
<p>Boolean. <strong>Default: TRUE.</strong> If TRUE, shows identified excursions as arrows from peak-to-nadir/nadir-to-peak on the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If version <code>'ma'</code> is selected, the function computationally emulates the manual method for calculating the mean amplitude of glycemic excursions (MAGE) first suggested in &quot;Mean Amplitude of Glycemic Excursions, a Measure of Diabetic Instability&quot;, (Service, 1970). For this version, glucose values will be interpolated over a uniform time grid prior to calculation.
</p>
<p><code>'ma'</code> is a more accurate algorithm that uses the crosses of a short and long moving average to identify intervals where a peak/nadir might exist. Then, the height from one peak/nadir to the next nadir/peak is calculated from the _original_ (not moving average) glucose values.
</p>
<p><code>'naive'</code> algorithm calculates MAGE by taking the mean of absolute glucose differences (between each value and the mean) that are greater than the standard deviation. A multiplier can be added to the standard deviation using the <code>sd_multiplier</code> argument.
</p>


<h3>Value</h3>

<p>A tibble object with two columns: the subject id and corresponding MAGE value.
If a vector of glucose values is passed, then a tibble object with just the MAGE value
is returned.
</p>
<p>In <code>version = "ma"</code>, if <code>plot = TRUE</code>, a list of ggplots will
be returned with one plot per subject. To return an interactive plot, use iglu::mage_ma_single with <code>plot_type='plotly'</code> on each subject individually.
</p>


<h3>References</h3>

<p>Service et al. (1970) Mean amplitude of glycemic excursions, a measure of diabetic instability
<em>Diabetes</em>  <strong>19</strong> .644-655,
<a href="https://doi.org/10.2337/diab.19.9.644">doi:10.2337/diab.19.9.644</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(example_data_5_subject)
mage(example_data_5_subject, version = 'ma')
</code></pre>

<hr>
<h2 id='mage_ma_single'>Calculates Mean Amplitude of Glycemic Excursions (see &quot;mage&quot;)</h2><span id='topic+mage_ma_single'></span>

<h3>Description</h3>

<p>This function is an internal function used by &quot;mage&quot;. The function will calculate the Mean Amplitude of Glycemic Excursions (MAGE) on <strong>all</strong> the values of the inputted data set. To calculate separate MAGE values for a group of subjects, use the &quot;mage&quot; function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mage_ma_single(
  data,
  short_ma = 5,
  long_ma = 32,
  return_type = c("num", "df"),
  direction = c("avg", "service", "max", "plus", "minus"),
  dt0 = NULL,
  tz = "",
  inter_gap = 45,
  max_gap = 180,
  plot = FALSE,
  title = NA,
  xlab = NA,
  ylab = NA,
  show_ma = FALSE,
  show_excursions = TRUE,
  plot_type = c("ggplot", "plotly")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mage_ma_single_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;. Should only be data for 1 subject. In case multiple subject ids are detected, a warning is produced and only 1st subject is used.</p>
</td></tr>
<tr><td><code id="mage_ma_single_+3A_short_ma">short_ma</code></td>
<td>
<p>Integer for period length of the short moving average. <strong>Default: 5.</strong> Must be positive and less than &quot;long_ma&quot;. (Recommended &lt;15)</p>
</td></tr>
<tr><td><code id="mage_ma_single_+3A_long_ma">long_ma</code></td>
<td>
<p>Integer for period length for the long moving average. <strong>Default: 32.</strong> Must be positive and greater than &quot;short_ma&quot;. (Recommended &gt;20)</p>
</td></tr>
<tr><td><code id="mage_ma_single_+3A_return_type">return_type</code></td>
<td>
<p>One of &quot;num&quot; or &quot;df&quot;. <strong>Default: &quot;num&quot;.</strong> Will return either a single number for the &quot;MAGE over the entire trace&quot; (weighted by segment length) or a DataFrame with the MAGE value for each segment (see the MAGE vignette for discussion of handling gaps by splitting trace into multiple segments).</p>
</td></tr>
<tr><td><code id="mage_ma_single_+3A_direction">direction</code></td>
<td>
<p>One of &quot;avg&quot;, &quot;service&quot;, &quot;max&quot;, &quot;plus&quot;, or &quot;minus&quot;. <strong>Default: &quot;avg&quot;.</strong> Algorithm will calculate one of the following: MAGE+ (nadir to peak), MAGE- (peak to nadir), MAGEavg = avg(MAGE+, MAGE-), MAGEmax = max(MAGE+, MAGE-), or automatically choose MAGE+/MAGE- based on the first countable excursion (i.e., &quot;service&quot;). NOTE: the selection of peak-to-nadir or nadir-to-peak is chosen independently on each segment, thus MAGEservice may choose peak-to-nadir on one segment and nadir-to-peak on another, for example.</p>
</td></tr>
<tr><td><code id="mage_ma_single_+3A_dt0">dt0</code></td>
<td>
<p>The time frequency for interpolation in minutes, the default will match the CGM meter's frequency (e.g. 5 min for Dexcom).</p>
</td></tr>
<tr><td><code id="mage_ma_single_+3A_tz">tz</code></td>
<td>
<p>A character string specifying the time zone to be used. System-specific (see <code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code>), but &quot; &quot; is the current time zone, and &quot;GMT&quot; is UTC (Universal Time, Coordinated). Invalid values are most commonly treated as UTC, on some platforms with a warning.</p>
</td></tr>
<tr><td><code id="mage_ma_single_+3A_inter_gap">inter_gap</code></td>
<td>
<p>The maximum allowable gap (in minutes) for interpolation. The values will not be interpolated between the glucose measurements that are more than inter_gap minutes apart. The default value is 45 min.</p>
</td></tr>
<tr><td><code id="mage_ma_single_+3A_max_gap">max_gap</code></td>
<td>
<p>Integer for the maximum length of a gap in minutes before the trace is split into segments and MAGE is calculated on each segment independently. <strong>Default: 180.</strong></p>
</td></tr>
<tr><td><code id="mage_ma_single_+3A_plot">plot</code></td>
<td>
<p>Boolean. <strong>Default: FALSE.</strong> If TRUE, returns a plot that visualizes all identified peaks and nadirs, excursions, and  missing gaps. An interactive GUI can be loaded with <code>plot_type = 'plotly'</code>.</p>
</td></tr>
<tr><td><code id="mage_ma_single_+3A_title">title</code></td>
<td>
<p>Title for the ggplot. <strong>Default: &quot;Glucose Trace - Subject [ID]&quot;.</strong></p>
</td></tr>
<tr><td><code id="mage_ma_single_+3A_xlab">xlab</code></td>
<td>
<p>Label for x-axis of ggplot. <strong>Default: &quot;Time&quot;.</strong></p>
</td></tr>
<tr><td><code id="mage_ma_single_+3A_ylab">ylab</code></td>
<td>
<p>Label for y-axis of ggplot. <strong>Default: &quot;Glucose Level&quot;.</strong></p>
</td></tr>
<tr><td><code id="mage_ma_single_+3A_show_ma">show_ma</code></td>
<td>
<p>Boolean. <strong>Default: FALSE.</strong> If TRUE, plots the moving average lines on the plot.</p>
</td></tr>
<tr><td><code id="mage_ma_single_+3A_show_excursions">show_excursions</code></td>
<td>
<p>Boolean. <strong>Default: TRUE.</strong> If TRUE, shows identified excursions as arrows from peak-to-nadir/nadir-to-peak on the plot.</p>
</td></tr>
<tr><td><code id="mage_ma_single_+3A_plot_type">plot_type</code></td>
<td>
<p>One of &quot;ggplot&quot; or &quot;plotly&quot;. <strong>Default: &quot;gglplot&quot;.</strong> Returns either a ggplot (static image) or Plotly chart (interactive GUI).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See &quot;mage&quot;.
</p>


<h3>Value</h3>

<p>A ggplot or Plotly chart if <code>plot = TRUE</code>, depending on <code>plot_type</code>. Otherwise, a numeric MAGE value for the inputted glucose trace or a DataFrame with the MAGE values on each segment, depending on <code>return_type</code>.
</p>


<h3>Author(s)</h3>

<p>Nathaniel J. Fernandes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(example_data_1_subject)
mage_ma_single(
   example_data_1_subject,
   short_ma = 4,
   long_ma = 24,
   direction = 'plus')

mage_ma_single(
   example_data_1_subject,
   inter_gap = 300)

mage_ma_single(
   example_data_1_subject,
   plot=TRUE,
   title="Patient X",
   xlab="Time",
   ylab="Glucose Level (mg/dL)",
   show_ma=FALSE)
</code></pre>

<hr>
<h2 id='meal_metrics'>Calculate Meal Metrics</h2><span id='topic+meal_metrics'></span>

<h3>Description</h3>

<p>The function meal_metrics calculates three simple glucose meal metrics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meal_metrics(data, mealtimes, before_win = 1, after_win = 3,
recovery_win = 1, interpolate = TRUE, adjust_mealtimes = TRUE, dt0 = NULL,
inter_gap = 45, tz = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meal_metrics_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;. Should only be data for 1 subject. In case multiple subject ids are detected, a warning is produced and only 1st subject is used.</p>
</td></tr>
<tr><td><code id="meal_metrics_+3A_mealtimes">mealtimes</code></td>
<td>
<p>Either a vector of mealtimes, corresponding
to data being from a single subject, OR a dataframe with at least 2 columns labeled
id and mealtime. Optionally the mealtimes dataframe can include a column labeled meal,
giving the meal type (helps to compensate for overlapping meals)</p>
</td></tr>
<tr><td><code id="meal_metrics_+3A_before_win">before_win</code></td>
<td>
<p>integer specifying number of hours to extend window before meal</p>
</td></tr>
<tr><td><code id="meal_metrics_+3A_after_win">after_win</code></td>
<td>
<p>integer specifying number of hours to extend window after meal</p>
</td></tr>
<tr><td><code id="meal_metrics_+3A_recovery_win">recovery_win</code></td>
<td>
<p>interger specifying number of hours for recovery beyond after window</p>
</td></tr>
<tr><td><code id="meal_metrics_+3A_interpolate">interpolate</code></td>
<td>
<p>Boolean to indicate if CGM data should be interpolated or not.
Default set to FALSE due to time intensive nature of interpolation. Parameters dt0,
inter_gap, and tz will only be used if interpolate is set to TRUE.</p>
</td></tr>
<tr><td><code id="meal_metrics_+3A_adjust_mealtimes">adjust_mealtimes</code></td>
<td>
<p>Boolean to indicate if function should attempt to align
mealtimes with CGM data times. This is important if mealtimes and CGM data times
are not exactly aligned, because the function will return NA's for mealtimes
that don't match with a corresponding CGM time stamp.</p>
</td></tr>
<tr><td><code id="meal_metrics_+3A_dt0">dt0</code></td>
<td>
<p>The time frequency for interpolation in minutes, the default will match the CGM meter's frequency (e.g. 5 min for Dexcom).</p>
</td></tr>
<tr><td><code id="meal_metrics_+3A_inter_gap">inter_gap</code></td>
<td>
<p>The maximum allowable gap (in minutes) for interpolation. The values will not be interpolated between the glucose measurements that are more than inter_gap minutes apart. The default value is 45 min.</p>
</td></tr>
<tr><td><code id="meal_metrics_+3A_tz">tz</code></td>
<td>
<p>A character string specifying the time zone to be used. System-specific (see <code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code>), but &quot; &quot; is the current time zone, and &quot;GMT&quot; is UTC (Universal Time, Coordinated). Invalid values are most commonly treated as UTC, on some platforms with a warning.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tibble object is returned with three metrics calculated for each mealtime.
The last three columns of the output correspond to the three metrics: deltag
refers to <code class="reqn">\Delta G</code>, deltat is <code class="reqn">\Delta T</code>, and basereco is % Baseline recovery.
If no meal column is given in the original data, one will be automatically generated
with a unique number for each meal.
</p>


<h3>Value</h3>

<p>A tibble object with 6 columns will be returned: id, time, meal, deltag,
deltat, and basereco.
</p>


<h3>References</h3>

<p>Service, F. John. (2013) Glucose Variability, <em>Diabetes</em>
<strong>62(5)</strong>: 1398-1404, <a href="https://doi.org/10.2337/db12-1396">doi:10.2337/db12-1396</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(example_data_hall)
data(example_meals_hall)
meal_metrics(example_data_hall, example_meals_hall)
meal_metrics(example_data_hall, example_meals_hall)

</code></pre>

<hr>
<h2 id='mean_glu'>Calculate mean glucose level</h2><span id='topic+mean_glu'></span>

<h3>Description</h3>

<p>The function mean_glu is a wrapper for the base function
mean(). Output is a tibble object with subject id and mean values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_glu(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_glu_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;,
or numeric vector of glucose values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tibble object with 1 row for each subject, a column for subject id and
a column for the mean values is returned. NA glucose values are
omitted from the  calculation of the mean.
</p>


<h3>Value</h3>

<p>If a data.frame object is passed, then a tibble object with
two columns: subject id and corresponding mean value is returned. If a vector of glucose
values is passed, then a tibble object with just the mean value is returned.
as.numeric() can be wrapped around the latter to output just a numeric value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(example_data_1_subject)
mean_glu(example_data_1_subject)

data(example_data_5_subject)
mean_glu(example_data_5_subject)

</code></pre>

<hr>
<h2 id='median_glu'>Calculate median glucose level</h2><span id='topic+median_glu'></span>

<h3>Description</h3>

<p>The function median_glu is a wrapper for the base function
median(). Output is a tibble object with subject id and median values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>median_glu(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="median_glu_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;,
or numeric vector of glucose values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tibble object with 1 row for each subject, a column for subject id and
a column for the median values is returned. NA glucose values are
omitted from the  calculation of the median.
</p>


<h3>Value</h3>

<p>If a data.frame object is passed, then a tibble object with
two columns: subject id and corresponding median value is returned. If a vector of glucose
values is passed, then a tibble object with just the median value is returned.
as.numeric() can be wrapped around the latter to output just a numeric value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(example_data_1_subject)
median_glu(example_data_1_subject)

data(example_data_5_subject)
median_glu(example_data_5_subject)

</code></pre>

<hr>
<h2 id='metrics_heatmap'>Create a heatmap of metric values by subject based on hierarchical clustering order</h2><span id='topic+metrics_heatmap'></span>

<h3>Description</h3>

<p>Create a heatmap of metric values by subject based on hierarchical clustering order
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metrics_heatmap(
  data = NULL,
  metrics = NULL,
  metric_cluster = 6,
  clustering_method = "complete",
  clustering_distance_metrics = "correlation",
  clustering_distance_subjects = "correlation"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metrics_heatmap_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;.</p>
</td></tr>
<tr><td><code id="metrics_heatmap_+3A_metrics">metrics</code></td>
<td>
<p>precalculated metric values, with first column corresponding to subject id. If 'NULL', the metrics are calculated from supplied 'data' using <code><a href="#topic+all_metrics">all_metrics</a></code></p>
</td></tr>
<tr><td><code id="metrics_heatmap_+3A_metric_cluster">metric_cluster</code></td>
<td>
<p>number of visual metric clusters, default value is 6</p>
</td></tr>
<tr><td><code id="metrics_heatmap_+3A_clustering_method">clustering_method</code></td>
<td>
<p>the agglomeration method for hierarchical clustering, accepts same values as <code><a href="stats.html#topic+hclust">hclust</a></code>, default value is 'complete'</p>
</td></tr>
<tr><td><code id="metrics_heatmap_+3A_clustering_distance_metrics">clustering_distance_metrics</code></td>
<td>
<p>the distance measure for metrics clustering, accepts same values as <code><a href="stats.html#topic+dist">dist</a></code>, default value is 'correlation' distance</p>
</td></tr>
<tr><td><code id="metrics_heatmap_+3A_clustering_distance_subjects">clustering_distance_subjects</code></td>
<td>
<p>the distance measure for subjects clustering, accepts same values as <code><a href="stats.html#topic+dist">dist</a></code>, default value is 'correlation' distance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A heatmap of metrics by subjects generated via <code>pheatmap</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Using default (all metrics)
# metrics_heatmap(example_data_5_subject)

# Using pre-calculated sd metrics only
mecs = sd_measures(example_data_5_subject)
metrics_heatmap(metrics = mecs)
</code></pre>

<hr>
<h2 id='modd'>Calculate mean difference between glucose values obtained at the same time
of day (MODD)</h2><span id='topic+modd'></span>

<h3>Description</h3>

<p>The function modd produces MODD values in a tibble object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modd(data, lag = 1, tz = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modd_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;.</p>
</td></tr>
<tr><td><code id="modd_+3A_lag">lag</code></td>
<td>
<p>Integer indicating which lag (# days) to use. Default is 1.</p>
</td></tr>
<tr><td><code id="modd_+3A_tz">tz</code></td>
<td>
<p>A character string specifying the time zone to be used. System-specific (see <code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code>), but &quot; &quot; is the current time zone, and &quot;GMT&quot; is UTC (Universal Time, Coordinated). Invalid values are most commonly treated as UTC, on some platforms with a warning.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tibble object with 1 row for each subject, a column for subject id and
a column for the MODD values is returned.
</p>
<p>Missing values will be linearly interpolated when close enough to non-missing values.
</p>
<p>MODD is calculated by taking the mean of absolute differences between
measurements at the same time 1 day away, or more if lag parameter
is set to an integer &gt; 1.
</p>


<h3>Value</h3>

<p>A tibble object with two columns: subject id and corresponding MODD value.
</p>


<h3>References</h3>

<p>Service, F. J. &amp; Nelson, R. L. (1980) Characteristics of glycemic stability.
<em>Diabetes care</em> <strong>3</strong> .58-62,
<a href="https://doi.org/10.2337/diacare.3.1.58">doi:10.2337/diacare.3.1.58</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(example_data_1_subject)
modd(example_data_1_subject)
modd(example_data_1_subject, lag = 2)

data(example_data_5_subject)
modd(example_data_5_subject, lag = 2)

</code></pre>

<hr>
<h2 id='optimized_iglu_functions'>Optimized Calculations of Time Dependent iglu Metrics</h2><span id='topic+optimized_iglu_functions'></span>

<h3>Description</h3>

<p>The function optimized_iglu_functions optimizes the calculation of all time dependent iglu
metrics by extracting the CGMS2DayByDay calculation and passing the result into each function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimized_iglu_functions(data, dt0 = NULL, inter_gap = 45, tz = "", timelag = 15, lag = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimized_iglu_functions_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;.</p>
</td></tr>
<tr><td><code id="optimized_iglu_functions_+3A_dt0">dt0</code></td>
<td>
<p>The time frequency for interpolation in minutes, the default will match the CGM meter's frequency (e.g. 5 min for Dexcom).</p>
</td></tr>
<tr><td><code id="optimized_iglu_functions_+3A_inter_gap">inter_gap</code></td>
<td>
<p>The maximum allowable gap (in minutes) for interpolation. The values will not be interpolated between the glucose measurements that are more than inter_gap minutes apart. The default value is 45 min.</p>
</td></tr>
<tr><td><code id="optimized_iglu_functions_+3A_tz">tz</code></td>
<td>
<p>A character string specifying the time zone to be used. System-specific (see <code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code>), but &quot; &quot; is the current time zone, and &quot;GMT&quot; is UTC (Universal Time, Coordinated). Invalid values are most commonly treated as UTC, on some platforms with a warning.</p>
</td></tr>
<tr><td><code id="optimized_iglu_functions_+3A_timelag">timelag</code></td>
<td>
<p>Integer indicating the time period (# minutes) over which rate
of change is calculated. Default is 15, e.g. rate of change is the change in
glucose over the past 15 minutes divided by 15.</p>
</td></tr>
<tr><td><code id="optimized_iglu_functions_+3A_lag">lag</code></td>
<td>
<p>Integer indicating which lag (# days) to use. Default is 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a tibble object with 1 row for each subject and a column for each metric. This
function includes time dependent iglu metrics only. For metric specific information,
please see the corresponding function documentation.
</p>


<h3>Value</h3>

<p>If a data.frame object is passed, then a tibble object with 1 row for each subject
and one column for each metric is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(example_data_1_subject)
optimized_iglu_functions(example_data_1_subject)

# Pass some arguments to possibly change the defaults
optimized_iglu_functions(example_data_1_subject, dt0 = 5, inter_gap = 30)

data(example_data_5_subject)
optimized_iglu_functions(example_data_5_subject)

</code></pre>

<hr>
<h2 id='pgs'>Calculate Personal Glycemic State (PGS)</h2><span id='topic+pgs'></span>

<h3>Description</h3>

<p>The function mad produces PGS values in a tibble object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pgs(data, dur_length = 20, end_length = 30)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pgs_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;. Should only be data for 1 subject. In case multiple subject ids are detected, a warning is produced and only 1st subject is used.</p>
</td></tr>
<tr><td><code id="pgs_+3A_dur_length">dur_length</code></td>
<td>
<p>Numeric value specifying the minimum duration in minutes to
be considered an episode. Note dur_length should be a multiple of the data recording
interval otherwise the function will round up to the nearest multiple.
Default is 20 minutes to match the original PGS definition.</p>
</td></tr>
<tr><td><code id="pgs_+3A_end_length">end_length</code></td>
<td>
<p>Numeric value specifying the minimum duration in minutes of
improved glycemia for an episode to end.
Default is 30 minutes to match original PGS definition.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tibble object with 1 row for each subject, a column for subject id and
a column for GVP values is returned. NA glucose values are
omitted from the calculation. Note that the duration thresholds for episodes
are NOT the same as the episode_calculation defaults. The defaults chosen for
PGS are those that match the original PGS paper definition, while the
episode_calculation defaults match the consensus.
</p>


<h3>Value</h3>

<p>A tibble object with two columns:
subject id and corresponding PGS value.
</p>


<h3>Author(s)</h3>

<p>Elizabeth Chun
</p>


<h3>References</h3>

<p>Hirsch et al. (2017): A Simple Composite Metric for the Assessment of Glycemic
Status from Continuous Glucose Monitoring Data: Implications for Clinical Practice
and the Artificial Pancreas
<em>Diabetes Technol Ther</em> <strong>19(S3)</strong> .S38-S48,
<a href="https://doi.org/10.1089/dia.2017.0080">doi:10.1089/dia.2017.0080</a>.
</p>


<h3>See Also</h3>

<p>episode_calculation()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(example_data_1_subject)
pgs(example_data_1_subject)


</code></pre>

<hr>
<h2 id='plot_agp'>Plot Ambulatory Glucose Profile (AGP) modal day</h2><span id='topic+plot_agp'></span>

<h3>Description</h3>

<p>The function plot_agp produces an AGP plot that collapses all data into a single 24 hr &quot;modal day&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_agp(data, LLTR = 70, ULTR = 180, smooth = TRUE, span = 0.3, dt0 = NULL,
inter_gap = 45, tz = "", title = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_agp_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;. Should only be data for 1 subject. In case multiple subject ids are detected, a warning is produced and only 1st subject is used.</p>
</td></tr>
<tr><td><code id="plot_agp_+3A_lltr">LLTR</code></td>
<td>
<p>Lower Limit of Target Range, default value is 70 mg/dL.</p>
</td></tr>
<tr><td><code id="plot_agp_+3A_ultr">ULTR</code></td>
<td>
<p>Upper Limit of Target Range, default value is 180 mg/dL.</p>
</td></tr>
<tr><td><code id="plot_agp_+3A_smooth">smooth</code></td>
<td>
<p>Boolean indicating whether quantiles should be smoothed before plotting, default is TRUE</p>
</td></tr>
<tr><td><code id="plot_agp_+3A_span">span</code></td>
<td>
<p>Optional parameter indicating span for loess smoothing. Default is 0.3, larger values result in more smoothing,
recommended to choose between 0.1 to 0.7.</p>
</td></tr>
<tr><td><code id="plot_agp_+3A_dt0">dt0</code></td>
<td>
<p>The time frequency for interpolation in minutes, the default will match the CGM meter's frequency (e.g. 5 min for Dexcom).</p>
</td></tr>
<tr><td><code id="plot_agp_+3A_inter_gap">inter_gap</code></td>
<td>
<p>The maximum allowable gap (in minutes) for interpolation. The values will not be interpolated between the glucose measurements that are more than inter_gap minutes apart. The default value is 45 min.</p>
</td></tr>
<tr><td><code id="plot_agp_+3A_tz">tz</code></td>
<td>
<p>A character string specifying the time zone to be used. System-specific (see <code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code>), but &quot; &quot; is the current time zone, and &quot;GMT&quot; is UTC (Universal Time, Coordinated). Invalid values are most commonly treated as UTC, on some platforms with a warning.</p>
</td></tr>
<tr><td><code id="plot_agp_+3A_title">title</code></td>
<td>
<p>Indicator whether the title of the plot should display the subject ID. The default is FALSE (no title).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only a single subject's data may be plotted. If smooth = TRUE, then the quantiles are
loess smoothed with the specified span before plotting. The horizontal green lines represent the target range,
default is 70-180 mg/dL. The black line is the median glucose value for each time of day. The dark blue shaded area
represents 50% of glucose values - those between the 25th and 75 quantiles. The light
blue shaded area shows 90% of the glucose values - those between the 5th and 95th quantiles.
Additionally, the percents shown on the right hand side of the plot show which quantiles each line refers to -
e.g. the line ending at 95% is the line corresponding to the 95th quantiles of glucose values.
</p>


<h3>Value</h3>

<p>Plot of a 24 hr modal day collapsing all data to a single day.
</p>


<h3>Author(s)</h3>

<p>Elizabeth Chun
</p>


<h3>References</h3>

<p>Johnson et al. (2019) Utilizing the Ambulatory Glucose Profile to Standardize and
Implement Continuous Glucose Monitoring in Clinical Practice,
<em>Diabetes Technology and Therapeutics</em> <strong>21:S2</strong> S2-17-S2-25,
<a href="https://doi.org/10.1089/dia.2019.0034">doi:10.1089/dia.2019.0034</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(example_data_1_subject)
plot_agp(example_data_1_subject)

</code></pre>

<hr>
<h2 id='plot_daily'>Plot daily glucose profiles</h2><span id='topic+plot_daily'></span>

<h3>Description</h3>

<p>The function plot_daily plots daily glucose time series profiles for a single subject.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_daily(data, maxd = 14, LLTR = 70, ULTR = 180, inter_gap = 45, tz = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_daily_+3A_data">data</code></td>
<td>
<p>DataFrame with column names (&quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;).</p>
</td></tr>
<tr><td><code id="plot_daily_+3A_maxd">maxd</code></td>
<td>
<p>Number of days to plot, default is the last 14 days, or if
less than 14 days of data are available, all days are plotted.</p>
</td></tr>
<tr><td><code id="plot_daily_+3A_lltr">LLTR</code></td>
<td>
<p>Lower Limit of Target Range, default value is 70 mg/dL.</p>
</td></tr>
<tr><td><code id="plot_daily_+3A_ultr">ULTR</code></td>
<td>
<p>Upper Limit of Target Range, default value is 180 mg/dL.</p>
</td></tr>
<tr><td><code id="plot_daily_+3A_inter_gap">inter_gap</code></td>
<td>
<p>The maximum allowable gap (in minutes). Gaps larger than
this will not be connected in the time series plot. The default value is 45 minutes.</p>
</td></tr>
<tr><td><code id="plot_daily_+3A_tz">tz</code></td>
<td>
<p>A character string specifying the time zone to be used. System-specific (see <code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code>), but &quot; &quot; is the current time zone, and &quot;GMT&quot; is UTC (Universal Time, Coordinated). Invalid values are most commonly treated as UTC, on some platforms with a warning.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only a single subject's data may be plotted. The black line shows the glucose values.
The shaded gray area shows the target range, default 70-180 mg/dL. Areas of the curve
above the ULTR are shaded yellow, while areas below the LLTR are shaded red.
</p>


<h3>Value</h3>

<p>Daily glucose time series plots for a single subject
</p>


<h3>Author(s)</h3>

<p>Elizabeth Chun
</p>


<h3>References</h3>

<p>Johnson et al. (2019) Utilizing the Ambulatory Glucose Profile to Standardize and
Implement Continuous Glucose Monitoring in Clinical Practice,
<em>Diabetes Technology and Therapeutics</em> <strong>21:S2</strong> S2-17-S2-25,
<a href="https://doi.org/10.1089/dia.2019.0034">doi:10.1089/dia.2019.0034</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(example_data_1_subject)
plot_daily(example_data_1_subject)
plot_daily(example_data_1_subject, LLTR = 100, ULTR = 140)

</code></pre>

<hr>
<h2 id='plot_glu'>Plot time series and lasagna plots of glucose measurements</h2><span id='topic+plot_glu'></span>

<h3>Description</h3>

<p>The function plot_glu supports several plotting methods for both single and multiple
subject data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_glu(
  data,
  plottype = c("tsplot", "lasagna"),
  datatype = c("all", "average", "single"),
  lasagnatype = c("unsorted", "timesorted"),
  LLTR = 70,
  ULTR = 180,
  subjects = NULL,
  inter_gap = 45,
  tz = "",
  color_scheme = c("blue-red", "red-orange"),
  log = F
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_glu_+3A_data">data</code></td>
<td>
<p>DataFrame with column names (&quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;).</p>
</td></tr>
<tr><td><code id="plot_glu_+3A_plottype">plottype</code></td>
<td>
<p>String corresponding to the desired plot type. Options are
'tsplot' for a time series plot and 'lasagna' for a lasagna plot. See the
&lsquo;lasagnatype' parameter for further options corresponding to the &rsquo;lasagna' 'plottype'.
Default is 'tsplot'.</p>
</td></tr>
<tr><td><code id="plot_glu_+3A_datatype">datatype</code></td>
<td>
<p>String corresponding to data aggregation used for plotting, currently supported options are 'all' which plots all glucose measurements within the first <code>maxd</code> days for each subject, and 'average' which plots average 24 hour glucose values across days for each subject</p>
</td></tr>
<tr><td><code id="plot_glu_+3A_lasagnatype">lasagnatype</code></td>
<td>
<p>String corresponding to plot type when using <code>datatype = "average"</code>, currently supported options are 'unsorted' for an unsorted lasagna plot, 'timesorted' for a lasagna plot with glucose values sorted within each time point across subjects, and '&lsquo;subjectsorted'&rsquo; for a lasagna plot with glucose values sorted within each subject across time points.</p>
</td></tr>
<tr><td><code id="plot_glu_+3A_lltr">LLTR</code></td>
<td>
<p>Lower Limit of Target Range, default value is 70 mg/dL.</p>
</td></tr>
<tr><td><code id="plot_glu_+3A_ultr">ULTR</code></td>
<td>
<p>Upper Limit of Target Range, default value is 180 mg/dL.</p>
</td></tr>
<tr><td><code id="plot_glu_+3A_subjects">subjects</code></td>
<td>
<p>String or list of strings corresponding to subject names
in 'id' column of data. Default is all subjects.</p>
</td></tr>
<tr><td><code id="plot_glu_+3A_inter_gap">inter_gap</code></td>
<td>
<p>The maximum allowable gap (in minutes). Gaps larger than
this will not be connected in the time series plot. The default value is 45 minutes.</p>
</td></tr>
<tr><td><code id="plot_glu_+3A_tz">tz</code></td>
<td>
<p>A character string specifying the time zone to be used. System-specific (see <code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code>), but &quot; &quot; is the current time zone, and &quot;GMT&quot; is UTC (Universal Time, Coordinated). Invalid values are most commonly treated as UTC, on some platforms with a warning.</p>
</td></tr>
<tr><td><code id="plot_glu_+3A_color_scheme">color_scheme</code></td>
<td>
<p>String corresponding to the chosen color scheme when the &lsquo;plottype' is &rsquo;lasagna'. By default, 'blue-red' scheme is used, with the values below &lsquo;LLTR' colored in shades of blue, and values above 'ULTR' colored in shades of red. The alternative &rsquo;red-orange' scheme mimics AGP output from <code><a href="#topic+agp">agp</a></code> with low values colored in red, in-range values colored in green, and high values colored in yellow and orange.</p>
</td></tr>
<tr><td><code id="plot_glu_+3A_log">log</code></td>
<td>
<p>Logical value indicating whether log10 of glucose values should be taken, default value is FALSE.
When log = TRUE, the glucose values, LLTR, and ULTR will all be log transformed, and time series plots will
be on a semilogarithmic scale.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the default option 'tsplot', a time series graph for each subject is
produced with hypo- and hyperglycemia cutoffs shown as horizontal red lines.
The time series plots for all subjects chosen (all by default) are displayed
on a grid.
</p>
<p>The 'lasagna' plot type works best when the datatype argument is set to average.
</p>


<h3>Value</h3>

<p>Any output from the plot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(example_data_1_subject)
plot_glu(example_data_1_subject)

data(example_data_5_subject)
plot_glu(example_data_5_subject, subjects = 'Subject 2')
plot_glu(example_data_5_subject, plottype = 'tsplot', tz = 'EST', LLTR = 70, ULTR = 150)
plot_glu(example_data_5_subject, plottype = 'lasagna', lasagnatype = 'timesorted')

</code></pre>

<hr>
<h2 id='plot_lasagna'>Lasagna plot of glucose values for multiple subjects</h2><span id='topic+plot_lasagna'></span>

<h3>Description</h3>

<p>Lasagna plot of glucose values for multiple subjects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_lasagna(
  data,
  datatype = c("all", "average"),
  lasagnatype = c("unsorted", "timesorted", "subjectsorted"),
  maxd = 14,
  limits = c(50, 500),
  midpoint = 105,
  LLTR = 70,
  ULTR = 180,
  dt0 = NULL,
  inter_gap = 45,
  tz = "",
  color_scheme = c("blue-red", "red-orange"),
  log = F
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_lasagna_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;.</p>
</td></tr>
<tr><td><code id="plot_lasagna_+3A_datatype">datatype</code></td>
<td>
<p>String corresponding to data aggregation used for plotting, currently supported options are 'all' which plots all glucose measurements within the first <code>maxd</code> days for each subject, and 'average' which plots average 24 hour glucose values across days for each subject</p>
</td></tr>
<tr><td><code id="plot_lasagna_+3A_lasagnatype">lasagnatype</code></td>
<td>
<p>String corresponding to plot type when using <code>datatype = "average"</code>, currently supported options are 'unsorted' for an unsorted lasagna plot, 'timesorted' for a lasagna plot with glucose values sorted within each time point across subjects, and '&lsquo;subjectsorted'&rsquo; for a lasagna plot with glucose values sorted within each subject across time points.</p>
</td></tr>
<tr><td><code id="plot_lasagna_+3A_maxd">maxd</code></td>
<td>
<p>For datatype &quot;all&quot;, maximal number of days to be plotted from the study. The default value is 14 days (2 weeks).</p>
</td></tr>
<tr><td><code id="plot_lasagna_+3A_limits">limits</code></td>
<td>
<p>The minimal and maximal glucose values for coloring grid which is gradient from blue (minimal) to red (maximal), see <code><a href="ggplot2.html#topic+scale_fill_gradient2">scale_fill_gradient2</a></code>)</p>
</td></tr>
<tr><td><code id="plot_lasagna_+3A_midpoint">midpoint</code></td>
<td>
<p>The glucose value serving as midpoint of the diverging gradient scale (see <code><a href="ggplot2.html#topic+scale_fill_gradient2">scale_fill_gradient2</a></code>). The default value is 105 mg/dL. The values above are colored in red, and below in blue in the default color_scheme, which can be adjusted.</p>
</td></tr>
<tr><td><code id="plot_lasagna_+3A_lltr">LLTR</code></td>
<td>
<p>Lower Limit of Target Range, default value is 70 mg/dL.</p>
</td></tr>
<tr><td><code id="plot_lasagna_+3A_ultr">ULTR</code></td>
<td>
<p>Upper Limit of Target Range, default value is 180 mg/dL.</p>
</td></tr>
<tr><td><code id="plot_lasagna_+3A_dt0">dt0</code></td>
<td>
<p>The time frequency for interpolated aligned grid in minutes, the default will match the CGM meter's frequency (e.g. 5 min for Dexcom).</p>
</td></tr>
<tr><td><code id="plot_lasagna_+3A_inter_gap">inter_gap</code></td>
<td>
<p>The maximum allowable gap (in minutes) for interpolation of
NA glucose values. The values will not be interpolated between
the glucose measurements that are more than inter_gap minutes apart.
The default value is 45 min.</p>
</td></tr>
<tr><td><code id="plot_lasagna_+3A_tz">tz</code></td>
<td>
<p>A character string specifying the time zone to be used. System-specific (see <code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code>), but &quot; &quot; is the current time zone, and &quot;GMT&quot; is UTC (Universal Time, Coordinated). Invalid values are most commonly treated as UTC, on some platforms with a warning.</p>
</td></tr>
<tr><td><code id="plot_lasagna_+3A_color_scheme">color_scheme</code></td>
<td>
<p>String corresponding to the chosen color scheme. By default, 'blue-red' scheme is used, with the values below &lsquo;LLTR' colored in shades of blue, and values above 'ULTR' colored in shades of red. The alternative &rsquo;red-orange' scheme mimics AGP output from <code><a href="#topic+agp">agp</a></code> with low values colored in red, in-range values colored in green, and high values colored in yellow and orange.</p>
</td></tr>
<tr><td><code id="plot_lasagna_+3A_log">log</code></td>
<td>
<p>Logical value indicating whether log10 of glucose values should be taken, default value is FALSE.
When log = TRUE the glucose values, limits, midpoint, LLTR, and ULTR will all be log transformed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object corresponding to lasagna plot
</p>


<h3>References</h3>

<p>Swihart et al. (2010) Lasagna Plots: A Saucy Alternative to Spaghetti Plots, <em>Epidemiology</em> <strong>21</strong>(5), 621-625, <a href="https://doi.org/10.1097/EDE.0b013e3181e5b06a">doi:10.1097/EDE.0b013e3181e5b06a</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot_lasagna(example_data_5_subject, datatype = "average", lasagnatype = 'timesorted', tz = "EST")
plot_lasagna(example_data_5_subject, lasagnatype = "subjectsorted", LLTR = 100, tz = "EST")

</code></pre>

<hr>
<h2 id='plot_lasagna_1subject'>Lasagna plot of glucose values for 1 subject aligned across times of day</h2><span id='topic+plot_lasagna_1subject'></span>

<h3>Description</h3>

<p>Lasagna plot of glucose values for 1 subject aligned across times of day
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_lasagna_1subject(
  data,
  lasagnatype = c("unsorted", "timesorted", "daysorted"),
  limits = c(50, 500),
  midpoint = 105,
  LLTR = 70,
  ULTR = 180,
  dt0 = NULL,
  inter_gap = 45,
  tz = "",
  color_scheme = c("blue-red", "red-orange"),
  log = F
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_lasagna_1subject_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;.</p>
</td></tr>
<tr><td><code id="plot_lasagna_1subject_+3A_lasagnatype">lasagnatype</code></td>
<td>
<p>String corresponding to plot type, currently supported
options are 'unsorted' for an unsorted single-subject lasagna plot, 'timesorted' for a lasagna plot with glucose values sorted within each time point across days, and 'daysorted' for a lasagna plot with glucose values sorted within each day across time points.</p>
</td></tr>
<tr><td><code id="plot_lasagna_1subject_+3A_limits">limits</code></td>
<td>
<p>The minimal and maximal glucose values for coloring grid which is gradient from blue (minimal) to red (maximal), see <code><a href="ggplot2.html#topic+scale_fill_gradient2">scale_fill_gradient2</a></code>)</p>
</td></tr>
<tr><td><code id="plot_lasagna_1subject_+3A_midpoint">midpoint</code></td>
<td>
<p>The glucose value serving as midpoint of the diverging gradient scale (see <code><a href="ggplot2.html#topic+scale_fill_gradient2">scale_fill_gradient2</a></code>). The default value is 105 mg/dL. The values above are colored in red, and below in blue in the default color_scheme, which can be adjusted.</p>
</td></tr>
<tr><td><code id="plot_lasagna_1subject_+3A_lltr">LLTR</code></td>
<td>
<p>Lower Limit of Target Range, default value is 70 mg/dL.</p>
</td></tr>
<tr><td><code id="plot_lasagna_1subject_+3A_ultr">ULTR</code></td>
<td>
<p>Upper Limit of Target Range, default value is 180 mg/dL.</p>
</td></tr>
<tr><td><code id="plot_lasagna_1subject_+3A_dt0">dt0</code></td>
<td>
<p>The time frequency for interpolated aligned grid in minutes, the default will match the CGM meter's frequency (e.g. 5 min for Dexcom).</p>
</td></tr>
<tr><td><code id="plot_lasagna_1subject_+3A_inter_gap">inter_gap</code></td>
<td>
<p>The maximum allowable gap (in minutes) for interpolation of
NA glucose values. The values will not be interpolated between
the glucose measurements that are more than inter_gap minutes apart.
The default value is 45 min.</p>
</td></tr>
<tr><td><code id="plot_lasagna_1subject_+3A_tz">tz</code></td>
<td>
<p>A character string specifying the time zone to be used. System-specific (see <code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code>), but &quot; &quot; is the current time zone, and &quot;GMT&quot; is UTC (Universal Time, Coordinated). Invalid values are most commonly treated as UTC, on some platforms with a warning.</p>
</td></tr>
<tr><td><code id="plot_lasagna_1subject_+3A_color_scheme">color_scheme</code></td>
<td>
<p>String corresponding to the chosen color scheme. By default, 'blue-red' scheme is used, with the values below &lsquo;LLTR' colored in shades of blue, and values above 'ULTR' colored in shades of red. The alternative &rsquo;red-orange' scheme mimics AGP output from <code><a href="#topic+agp">agp</a></code> with low values colored in red, in-range values colored in green, and high values colored in yellow and orange.</p>
</td></tr>
<tr><td><code id="plot_lasagna_1subject_+3A_log">log</code></td>
<td>
<p>Logical value indicating whether log of glucose values should be taken, default values is FALSE.
When log = TRUE the glucose values, limits, midpoint, LLTR, and ULTR will all be log transformed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object corresponding to lasagna plot
</p>


<h3>References</h3>

<p>Swihart et al. (2010) Lasagna Plots: A Saucy Alternative to Spaghetti Plots, <em>Epidemiology</em> <strong>21</strong>(5), 621-625, <a href="https://doi.org/10.1097/EDE.0b013e3181e5b06a">doi:10.1097/EDE.0b013e3181e5b06a</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot_lasagna_1subject(example_data_1_subject)
plot_lasagna_1subject(example_data_1_subject, color_scheme = 'red-orange')
plot_lasagna_1subject(example_data_1_subject, lasagnatype = 'timesorted')
plot_lasagna_1subject(example_data_1_subject, lasagnatype = 'daysorted')
plot_lasagna_1subject(example_data_1_subject, log = TRUE)

</code></pre>

<hr>
<h2 id='plot_ranges'>Plot Time in Ranges as a bar plot</h2><span id='topic+plot_ranges'></span>

<h3>Description</h3>

<p>The function plot_ranges produces a barplot showing the percent of time in glucose ranges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_ranges(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_ranges_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;. Should only be data for 1 subject. In case multiple subject ids are detected, a warning is produced and only 1st subject is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only a single subject's data may be used. There are four ranges: very low (below 54 mg/dL),
low (54-69 mg/dL), target range (70-180 mg/dL), high (181-250 mg/dL), and very high (above 250 mg/dL).
This plot is meant to be used as part of the Ambulatory Glucose Profile (AGP)
</p>


<h3>Value</h3>

<p>Single subject bar chart showing percent in different glucose ranges.
</p>


<h3>Author(s)</h3>

<p>Elizabeth Chun
</p>


<h3>References</h3>

<p>Johnson et al. (2019) Utilizing the Ambulatory Glucose Profile to Standardize and
Implement Continuous Glucose Monitoring in Clinical Practice,
<em>Diabetes Technology and Therapeutics</em> <strong>21:S2</strong> S2-17-S2-25,
<a href="https://doi.org/10.1089/dia.2019.0034">doi:10.1089/dia.2019.0034</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(example_data_1_subject)
plot_ranges(example_data_1_subject)

</code></pre>

<hr>
<h2 id='plot_roc'>Plot time series of glucose colored by rate of change</h2><span id='topic+plot_roc'></span>

<h3>Description</h3>

<p>The function plot_roc produces a time series plot of glucose values colored
by categorized rate of change values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_roc(data, subjects = NULL, timelag = 15, dt0 = NULL, inter_gap = 45, tz = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_roc_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;.</p>
</td></tr>
<tr><td><code id="plot_roc_+3A_subjects">subjects</code></td>
<td>
<p>String or list of strings corresponding to subject names
in 'id' column of data. Default is all subjects.</p>
</td></tr>
<tr><td><code id="plot_roc_+3A_timelag">timelag</code></td>
<td>
<p>Integer indicating the time period (# minutes) over which rate
of change is calculated. Default is 15, e.g. rate of change is the change in
glucose over the past 15 minutes divided by 15.</p>
</td></tr>
<tr><td><code id="plot_roc_+3A_dt0">dt0</code></td>
<td>
<p>The time frequency for interpolation in minutes, the default will match the CGM meter's frequency (e.g. 5 min for Dexcom).</p>
</td></tr>
<tr><td><code id="plot_roc_+3A_inter_gap">inter_gap</code></td>
<td>
<p>The maximum allowable gap (in minutes) for interpolation. The values will not be interpolated between the glucose measurements that are more than inter_gap minutes apart. The default value is 45 min.</p>
</td></tr>
<tr><td><code id="plot_roc_+3A_tz">tz</code></td>
<td>
<p>A character string specifying the time zone to be used. System-specific (see <code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code>), but &quot; &quot; is the current time zone, and &quot;GMT&quot; is UTC (Universal Time, Coordinated). Invalid values are most commonly treated as UTC, on some platforms with a warning.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the default, a time series is produced for each subject in which the glucose values are
plotted and colored by ROC categories defined as follows. The breaks for the categories are:
c(-Inf, -3, -2, -1, 1, 2, 3, Inf) where the glucose is in mg/dl and the ROC values are in mg/dl/min.
A ROC of -5 mg/dl/min will thus be placed in the first category and colored accordingly. The breaks
for the categories come from the reference paper below.
</p>


<h3>Value</h3>

<p>A time series of glucose values colored by ROC categories per subject
</p>


<h3>Author(s)</h3>

<p>Elizabeth Chun, David Buchanan
</p>


<h3>References</h3>

<p>Klonoff, D. C., &amp; Kerr, D. (2017)  A Simplified Approach Using Rate of Change Arrows to
Adjust Insulin With Real-Time Continuous Glucose Monitoring.
<em>Journal of Diabetes Science and Technology</em> <strong>11(6)</strong> 1063-1069,
<a href="https://doi.org/10.1177/1932296817723260">doi:10.1177/1932296817723260</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(example_data_1_subject)
plot_roc(example_data_1_subject)

data(example_data_5_subject)
plot_roc(example_data_5_subject, subjects = 'Subject 5')

</code></pre>

<hr>
<h2 id='process_data'>Data Pre-Processor</h2><span id='topic+process_data'></span>

<h3>Description</h3>

<p>A helper function to assist in pre-processing the user-supplied
input data for use with other functions.
Typically, this function will process the data and return another dataframe.
This function ensures that the returned data will be compitable with every
function within the <code>iglu</code> package. All NAs will be removed. See Vignette for further details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_data(data, id, timestamp, glu, time_parser = as.POSIXct)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="process_data_+3A_data">data</code></td>
<td>
<p>User-supplied dataset containing continuous glucose monitor data. Must
contain data for time and glucose readings at a minimum. Accepted formats are dataframe and tibble.</p>
</td></tr>
<tr><td><code id="process_data_+3A_id">id</code></td>
<td>
<p>Optional column name (character string) corresponding to subject id column.
If no value is passed, an id of 1 will be assigned to the data.</p>
</td></tr>
<tr><td><code id="process_data_+3A_timestamp">timestamp</code></td>
<td>
<p>Required column name (character string) corresponding to time values in data. The dates can be
in any format parsable by as.POSIXct, or any format accepted by the parser passed to time_parser. See time_parser param for an explanation
on how to handle arbitrary formats.</p>
</td></tr>
<tr><td><code id="process_data_+3A_glu">glu</code></td>
<td>
<p>Required column name (character string) corresponding to blood glucose values, mg/dl</p>
</td></tr>
<tr><td><code id="process_data_+3A_time_parser">time_parser</code></td>
<td>
<p>Optional function used to convert datetime strings to time objects. Defaults to as.POSIXct.
If your times are in a format not parsable by as.POSIXct, you can parse a custom format by passing
function(time_string) {strptime(time_string, format = &lt;format string&gt;)} as the time_parser parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A dataframe with the columns &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot; will be returned. All NAs will be removed.
If there is a mention of &quot;mmol/l&quot; in the glucose column name, the glucose values will be multipled by 18 to convert to mg/dl
Based on John Schwenck's data_process for his bp package
https://github.com/johnschwenck/bp
</p>


<h3>Value</h3>

<p>A processed dataframe object that cooperates with every other
function within the iglu package - all column names and formats comply.
</p>


<h3>Author(s)</h3>

<p>David Buchanan, John Schwenck
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("example_data_1_subject")

# Process example data
processed &lt;- process_data(example_data_1_subject, id = "id", timestamp = "time", glu = "gl")

processed

data("example_data_5_subject")

# Process example data
processed_5subj &lt;- process_data(example_data_5_subject, id = "id", timestamp = "time", glu = "gl")

processed_5subj

</code></pre>

<hr>
<h2 id='quantile_glu'>Calculate glucose level quantiles</h2><span id='topic+quantile_glu'></span>

<h3>Description</h3>

<p>The function quantile_glu is a wrapper for the base function quantile(). Output
is a tibble object with columns for subject id and each of the quantiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantile_glu(data, quantiles = c(0, 25, 50, 75, 100))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile_glu_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;,
or numeric vector of glucose values.</p>
</td></tr>
<tr><td><code id="quantile_glu_+3A_quantiles">quantiles</code></td>
<td>
<p>List of quantile values between 0 and 100.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tibble object with 1 row for each subject, a column for subject id and
a column for each quantile is returned. NA glucose values are
omitted from the calculation of the quantiles.
</p>
<p>The values are scaled from 0-1 to 0-100 to be consistent in output with
above_percent, below_percent, and in_range_percent.
</p>
<p>The command quantile_glu(...) / 100 will scale each element down from 0-100
to 0-1.
</p>


<h3>Value</h3>

<p>If a data.frame object is passed, then a tibble object with
a column for subject id and then a column for each quantile value is returned. If a vector of glucose
values is passed, then a tibble object without the subject id is returned.
as.numeric() can be wrapped around the latter to output a numeric vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(example_data_1_subject)

quantile_glu(example_data_1_subject)
quantile_glu(example_data_1_subject, quantiles = c(0, 33, 66, 100))

data(example_data_5_subject)

quantile_glu(example_data_5_subject)
quantile_glu(example_data_5_subject, quantiles = c(0, 10, 90, 100))
</code></pre>

<hr>
<h2 id='range_glu'>Calculate glucose level range</h2><span id='topic+range_glu'></span>

<h3>Description</h3>

<p>The function range_glu outputs the distance between minimum
and maximum glucose values per subject in a tibble object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>range_glu(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="range_glu_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;,
or numeric vector of glucose values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tibble object with 1 row for each subject, a column for subject id and
a column for the range values is returned. NA glucose values are
omitted from the calculation of the range.
</p>


<h3>Value</h3>

<p>If a data.frame object is passed, then a tibble object with
two columns: subject id and corresponding range value is returned. If a vector of glucose
values is passed, then a tibble object with just the range value is returned.
as.numeric() can be wrapped around the latter to output just a numeric value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(example_data_1_subject)
range_glu(example_data_1_subject)

data(example_data_5_subject)
range_glu(example_data_5_subject)

</code></pre>

<hr>
<h2 id='read_raw_data'>Read raw data from a variety of common sensors.</h2><span id='topic+read_raw_data'></span>

<h3>Description</h3>

<p>Helper function to assist in reading data directly from sensor outputs. Should return a dataframe in correct format
for use with the rest of the <code>iglu</code> package. Assumes all data will be readable with base R read.csv function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_raw_data(
  filename,
  sensor = c("dexcom", "libre", "librepro", "asc", "ipro"),
  id = "filename",
  tz = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_raw_data_+3A_filename">filename</code></td>
<td>
<p>String matching the name of the data to be read. Assumed to be .csv</p>
</td></tr>
<tr><td><code id="read_raw_data_+3A_sensor">sensor</code></td>
<td>
<p>String naming the type of sensor the data was exported from.
Must be one of &quot;dexcom&quot;, &quot;libre&quot;, &quot;librepro&quot;, &quot;asc&quot;, or &quot;ipro&quot;.</p>
</td></tr>
<tr><td><code id="read_raw_data_+3A_id">id</code></td>
<td>
<p>String indicating subject id. Defaults to &quot;filename&quot;.
A value of &quot;read&quot; will cause the program to attempt to read the subject id from the file. A value of &quot;filename&quot; will cause the
program to use the basename of the filename (i.e. filename without any directory information) with .csv removed, as subject id.
A value of &quot;default&quot; will cause the program to use whichever of &quot;read&quot; or &quot;filename&quot; that is default for that specific sensor.
Any other string will be treated as the unique id for the entire file.
</p>
<p>Note the asc reader currently does not support id=&quot;read&quot;</p>
</td></tr>
<tr><td><code id="read_raw_data_+3A_tz">tz</code></td>
<td>
<p>A character string specifying the time zone to be used. System-specific (see <code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code>), but &quot; &quot; is the current time zone, and &quot;GMT&quot; is UTC (Universal Time, Coordinated). Invalid values are most commonly treated as UTC, on some platforms with a warning.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A dataframe object with the columns &quot;id&quot;, &quot;time&quot; and &quot;gl&quot; and one row per reading will be returned. For the libre reader,
if the phrase &quot;mmol/l&quot; is found in the column names, the glucose values will be multiplied by 18.
Assumes .csv format for all data.
Sensor formats change with ongoing development, so these functions may become depreciated.
If any issues are encountered, contact the package maintainer. This is currently Irina Gaynanova,
who can be reached at <a href="mailto:irinag@stat.tamu.edu">irinag@stat.tamu.edu</a>
Heavily derived from the readers avaiable in the cgmanalysis package's cleandata function.
</p>


<h3>Value</h3>

<p>A dataframe containing the data read from the named file.
</p>


<h3>Author(s)</h3>

<p>David Buchanan
</p>


<h3>References</h3>

<p>Vigers et al. (2019) cgmanalysis: An R package for descriptive analysis of continuous glucose monitor data
<em>PLoS ONE</em> <strong>14(10)</strong>: e0216851,
<a href="https://doi.org/10.1371/journal.pone.0216851">doi:10.1371/journal.pone.0216851</a>
</p>

<hr>
<h2 id='roc'>Calculate the Rate of Change at each time point (ROC)</h2><span id='topic+roc'></span>

<h3>Description</h3>

<p>The function roc produces rate of change values in a tibble object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roc(data, timelag = 15, dt0 = NULL, inter_gap = 45, tz = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roc_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;.</p>
</td></tr>
<tr><td><code id="roc_+3A_timelag">timelag</code></td>
<td>
<p>Integer indicating the time period (# minutes) over which rate
of change is calculated. Default is 15, e.g. rate of change is the change in
glucose over the past 15 minutes divided by 15.</p>
</td></tr>
<tr><td><code id="roc_+3A_dt0">dt0</code></td>
<td>
<p>The time frequency for interpolation in minutes, the default will match the CGM meter's frequency (e.g. 5 min for Dexcom).</p>
</td></tr>
<tr><td><code id="roc_+3A_inter_gap">inter_gap</code></td>
<td>
<p>The maximum allowable gap (in minutes) for interpolation. The values will not be interpolated between the glucose measurements that are more than inter_gap minutes apart. The default value is 45 min.</p>
</td></tr>
<tr><td><code id="roc_+3A_tz">tz</code></td>
<td>
<p>A character string specifying the time zone to be used. System-specific (see <code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code>), but &quot; &quot; is the current time zone, and &quot;GMT&quot; is UTC (Universal Time, Coordinated). Invalid values are most commonly treated as UTC, on some platforms with a warning.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tibble object with a column for subject id and a column for ROC values is
returned. A ROC value is returned for each time point for all the subjects. Thus
multiple rows are returned for each subject. If the rate of change cannot be
calculated, the function will return NA for that point.
</p>
<p>The glucose values are linearly interpolated over a time grid starting at the
beginning of the first day of data and ending on the last day of data. Because
of this, there may be many NAs at the beginning and the end of the roc values
for each subject. These NAs are a result of interpolated time points that do
not have recorded glucose values near them because recording had either not
yet begun for the day or had already ended.
</p>
<p>The ROC is calculated as <code class="reqn">\frac{BG(t_i) - BG(t_{i-1})}{t_i - t_{i-1}}</code>
where BG_i is the Blood Glucose measurement at time <code class="reqn">t_i</code> and <code class="reqn">BG_{i-1}</code> is the
Blood Glucose measurement at time <code class="reqn">t_{i-1}</code>. The time difference between the points,
<code class="reqn">t_i - t_{i-1}</code>, is selectable and set at a default of 15 minutes.
</p>


<h3>Value</h3>

<p>A tibble object with two columns: subject id and rate of change values
</p>


<h3>Author(s)</h3>

<p>Elizabeth Chun, David Buchanan
</p>


<h3>References</h3>

<p>Clarke et al. (2009) Statistical Tools to Analyze Continuous Glucose Monitor Data,
Diabetes
<em>Diabetes Technology and Therapeutics</em> <strong>11</strong> S45-S54,
<a href="https://doi.org/10.1089/dia.2008.0138">doi:10.1089/dia.2008.0138</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(example_data_1_subject)
roc(example_data_1_subject)
roc(example_data_1_subject, timelag = 10)

data(example_data_5_subject)
roc(example_data_5_subject)

</code></pre>

<hr>
<h2 id='sd_glu'>Calculate sd glucose level</h2><span id='topic+sd_glu'></span>

<h3>Description</h3>

<p>The function sd_glu is a wrapper for the base function
sd(). Output is a tibble object with subject id and sd values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sd_glu(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sd_glu_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;,
or numeric vector of glucose values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tibble object with 1 row for each subject, a column for subject id and
a column for the sd values is returned. NA glucose values are
omitted from the calculation of the sd.
</p>


<h3>Value</h3>

<p>If a data.frame object is passed, then a tibble object with
two columns: subject id and corresponding sd value is returned. If a vector of glucose
values is passed, then a tibble object with just the sd value is returned.
as.numeric() can be wrapped around the latter to output just a numeric value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(example_data_1_subject)
sd_glu(example_data_1_subject)

data(example_data_5_subject)
sd_glu(example_data_5_subject)

</code></pre>

<hr>
<h2 id='sd_measures'>Calculate SD subtypes</h2><span id='topic+sd_measures'></span>

<h3>Description</h3>

<p>The function sd_measures produces SD subtype values in a tibble object
with a row for each subject and columns corresponding to id followed by
each SD subtype.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sd_measures(data,dt0 = NULL, inter_gap = 45, tz = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sd_measures_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;.</p>
</td></tr>
<tr><td><code id="sd_measures_+3A_dt0">dt0</code></td>
<td>
<p>The time frequency for interpolation in minutes, the default will match the CGM meter's frequency (e.g. 5 min for Dexcom).</p>
</td></tr>
<tr><td><code id="sd_measures_+3A_inter_gap">inter_gap</code></td>
<td>
<p>The maximum allowable gap (in minutes) for interpolation. The values will not be interpolated between the glucose measurements that are more than inter_gap minutes apart. The default value is 45 min.</p>
</td></tr>
<tr><td><code id="sd_measures_+3A_tz">tz</code></td>
<td>
<p>A character string specifying the time zone to be used. System-specific (see <code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code>), but &quot; &quot; is the current time zone, and &quot;GMT&quot; is UTC (Universal Time, Coordinated). Invalid values are most commonly treated as UTC, on some platforms with a warning.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tibble object with 1 row for each subject, a column for subject id and
a column for each SD subtype values is returned.
</p>
<p>Missing values will be linearly interpolated when close enough to non-missing values.
</p>

<ol>
<li><p> SDw - vertical within days:
</p>
<p>Calculated by first taking the standard deviation of each day's glucose measurements,
then taking the mean of all the standard deviations. That is, for d
days we compute <code class="reqn">SD_1 ... SD_d</code> daily standard deviations and calculate
<code class="reqn">1/d * \sum [(SD_i)]</code>
</p>
</li>
<li><p> SDhhmm - between time points:
</p>
<p>Also known as SDhh:mm. Calculated by taking the mean glucose values at each time point in the grid across days,
and taking the standard deviation of those mans. That is, for t time points
we compute <code class="reqn">X_t</code> means for each time point and then compute <code class="reqn">SD([X_1, X_2, ... X_t])</code>.
</p>
</li>
<li><p> SDwsh - within series:
</p>
<p>Also known as SDws h. Calculated by taking the hour-long intervals starting at every point in the interpolated
grid, computing the standard deviation of the points in each hour-long interval, and then
finding the mean of those standard deviations. That is, for n time points compute
<code class="reqn">SD_1 ... SD_n</code>, where <code class="reqn">SD_i</code> is the standard deviation of the glucose values <code class="reqn">[X_i, X_{i+1}, ... X_{i+k}]</code>
corresponding to hour-long window starting at observation <code class="reqn">X_i</code>, the number of observations in the window k depends on CGM meter frequency. Then, take
<code class="reqn">1/n * \sum [(SD_i)]</code>.
</p>
</li>
<li><p> SDdm - horizontal sd:
</p>
<p>Calculated by taking the daily mean glucose values, and then taking the standard deviation
of those daily means. That is, for d days we take <code class="reqn">X_1 ... X_d</code> daily means, and then compute
<code class="reqn">SD([X_1, X_2, ... X_d])</code>.
</p>
</li>
<li><p> SDb -  between days, within timepoints:
</p>
<p>Calculated by taking the standard deviation of the glucose values across days for each time point,
and then taking the mean of those standard deviations.
That is, for t time points take <code class="reqn">SD_1 ... SD_t</code> standard deviations, and then compute
<code class="reqn">1/t * \sum[(SD_i)]</code>
</p>
</li>
<li><p> SDbdm - between days, within timepoints, corrected for changes in daily means:
</p>
<p>Also known as SDb // dm. Calculated by subtracting the daily mean from each glucose value, then taking the standard deviation
of the corrected glucose values across days for each time point, and then taking the mean of those
standard deviations.
That is, for t time points take <code class="reqn">SD_1 ... SD_t</code> standard deviations, and then compute
<code class="reqn">1/t * \sum[(SD_i)]</code>. where <code class="reqn">SD_i</code> is the standard deviation of d daily values at the
1st time point, where each value is the dth measurement for the ith time point subtracted by
the mean of all glucose values for day d.
</p>
</li></ol>



<h3>Value</h3>

<p>A tibble object with a column for id and a column for each of the six SD subtypes.
</p>


<h3>References</h3>

<p>Rodbard (2009) New and Improved Methods to Characterize Glycemic Variability
Using Continuous Glucose Monitoring
<em>Diabetes Technology and Therapeutics</em> <strong>11</strong> .551-565,
<a href="https://doi.org/10.1089/dia.2009.0015">doi:10.1089/dia.2009.0015</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(example_data_1_subject)
sd_measures(example_data_1_subject)

</code></pre>

<hr>
<h2 id='sd_roc'>Calculate the standard deviation of the rate of change</h2><span id='topic+sd_roc'></span>

<h3>Description</h3>

<p>The function sd_roc produces the standard deviation of the rate of change
values in a tibble object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sd_roc(data, timelag = 15, dt0 = NULL, inter_gap = 45, tz = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sd_roc_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;.</p>
</td></tr>
<tr><td><code id="sd_roc_+3A_timelag">timelag</code></td>
<td>
<p>Integer indicating the time period (# minutes) over which rate
of change is calculated. Default is 15, e.g. rate of change is the change in
glucose over the past 15 minutes divided by 15.</p>
</td></tr>
<tr><td><code id="sd_roc_+3A_dt0">dt0</code></td>
<td>
<p>The time frequency for interpolation in minutes, the default will match the CGM meter's frequency (e.g. 5 min for Dexcom).</p>
</td></tr>
<tr><td><code id="sd_roc_+3A_inter_gap">inter_gap</code></td>
<td>
<p>The maximum allowable gap (in minutes) for interpolation. The values will not be interpolated between the glucose measurements that are more than inter_gap minutes apart. The default value is 45 min.</p>
</td></tr>
<tr><td><code id="sd_roc_+3A_tz">tz</code></td>
<td>
<p>A character string specifying the time zone to be used. System-specific (see <code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code>), but &quot; &quot; is the current time zone, and &quot;GMT&quot; is UTC (Universal Time, Coordinated). Invalid values are most commonly treated as UTC, on some platforms with a warning.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tibble object with one row for each subject, a column for subject id
and a column for the standard deviation of the rate of change.
</p>
<p>When calculating rate of change, missing values will be linearly interpolated
when close enough to non-missing values.
</p>
<p>Calculated by taking the standard deviation of all the ROC values for each
individual subject. NA rate of change values are omitted from the
standard deviation calculation.
</p>


<h3>Value</h3>

<p>A tibble object with two columns: subject id and standard deviation
of the rate of change values for each subject.
</p>


<h3>Author(s)</h3>

<p>Elizabeth Chun, David Buchanan
</p>


<h3>References</h3>

<p>Clarke et al. (2009) Statistical Tools to Analyze Continuous Glucose Monitor Data,
Diabetes
<em>Diabetes Technology and Therapeutics</em> <strong>11</strong> S45-S54,
<a href="https://doi.org/10.1089/dia.2008.0138">doi:10.1089/dia.2008.0138</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(example_data_1_subject)
sd_roc(example_data_1_subject)
sd_roc(example_data_1_subject, timelag = 10)

data(example_data_5_subject)
sd_roc(example_data_5_subject)
sd_roc(example_data_5_subject, timelag = 10)

</code></pre>

<hr>
<h2 id='summary_glu'>Calculate summary glucose level</h2><span id='topic+summary_glu'></span>

<h3>Description</h3>

<p>The function summary_glu is a wrapper for the base function
summary(). Output is a tibble object with subject id and the summary value:
Minimum, 1st Quantile, Median, Mean, 3rd Quantile and Max.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_glu(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_glu_+3A_data">data</code></td>
<td>
<p>DataFrame object with column names &quot;id&quot;, &quot;time&quot;, and &quot;gl&quot;,
or numeric vector of glucose values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tibble object with 1 row for each subject, a column for subject id and
a column for each of summary values is returned. NA glucose values are
omitted from the  calculation of the summary values.
</p>


<h3>Value</h3>

<p>If a data.frame object is passed, then a tibble object with
a column for subject id and then a column for each summary value is returned. If a vector of glucose
values is passed, then a tibble object without the subject id is returned.
as.numeric() can be wrapped around the latter to output a numeric vector with
values in order of Min, 1st Quantile, Median, Mean, 3rd Quantile and Max.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(example_data_1_subject)
summary_glu(example_data_1_subject)

data(example_data_5_subject)
summary_glu(example_data_5_subject)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
