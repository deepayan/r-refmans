<!DOCTYPE html><html><head><title>Help for package vegclust</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {vegclust}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#vegclust-package'>
<p>Fuzzy Clustering of Vegetation Data</p>
Functions for fuzzy and hard clustering of vegetation data</a></li>
<li><a href='#as.memb'>
<p>Turns into membership matrix</p></a></li>
<li><a href='#as.vegclust'>
<p>Turns into vegclust objects</p></a></li>
<li><a href='#CAP'>
<p>Cumulative abundance profile (CAP)</p></a></li>
<li><a href='#CAS'>
<p>Cumulative abundance surface (CAS)</p></a></li>
<li><a href='#clustcentroid'>
<p>Cluster centers of a classification</p></a></li>
<li><a href='#clustconst'>
<p>Constancy table of a classification</p></a></li>
<li><a href='#clustvar'>
<p>Cluster variance</p></a></li>
<li><a href='#concordance'>
<p>Concordance between two classifications</p></a></li>
<li><a href='#conformveg'>
<p>Conform two community data tables</p></a></li>
<li><a href='#crossmemb'>
<p>Cross-table of two fuzzy classifications</p></a></li>
<li><a href='#defuzzify'>
<p>Defuzzifies a fuzzy partition</p></a></li>
<li><a href='#hcr'>
<p>Heterogeneity-constrained random resampling (HCR)</p></a></li>
<li><a href='#hier.vegclust'>
<p>Clustering with several number of clusters</p></a></li>
<li><a href='#incr.vegclust'>
<p>Noise clustering with increasing number of clusters</p></a></li>
<li><a href='#interclustdist'>
<p>Calculates the distance between pairs of cluster centroids</p></a></li>
<li><a href='#medreg'><p>Regeneration of Mediterranean vegetation data set</p></a></li>
<li><a href='#plot.CAP'>
<p>Draws cummulative abundance profiles</p></a></li>
<li><a href='#plot.CAS'>
<p>Draws a cummulative abundance surface</p></a></li>
<li><a href='#plot.mvegclust'>
<p>Plots clustering results</p></a></li>
<li><a href='#relate.levels'>
<p>Relates two clustering level results.</p></a></li>
<li><a href='#stratifyvegdata'>
<p>Reshapes community data from individual into stratified form</p></a></li>
<li><a href='#treedata'><p>Synthetic vegetation data set with tree data</p></a></li>
<li><a href='#vegclass'>
<p>Classifies vegetation communities</p></a></li>
<li><a href='#vegclust'>
<p>Vegetation clustering methods</p></a></li>
<li><a href='#vegclust2kmeans'>
<p>Reshapes as kmeans object</p></a></li>
<li><a href='#vegclustIndex'>
<p>Compute fuzzy evaluation statistics</p></a></li>
<li><a href='#vegdiststruct'>
<p>Structural and compositional dissimilarity</p></a></li>
<li><a href='#wetland'><p>Wetland vegetation data set</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fuzzy Clustering of Vegetation Data</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-08-24</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of functions to: (1) perform fuzzy clustering of vegetation data (De Caceres et al, 2010) &lt;<a href="https://doi.org/10.1111%2Fj.1654-1103.2010.01211.x">doi:10.1111/j.1654-1103.2010.01211.x</a>&gt;; (2) to assess ecological community similarity on the basis of structure and composition (De Caceres et al, 2013) &lt;<a href="https://doi.org/10.1111%2F2041-210X.12116">doi:10.1111/2041-210X.12116</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>vegan</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://emf-creaf.github.io/vegclust/">https://emf-creaf.github.io/vegclust/</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>utils, knitr</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-24 10:03:22 UTC; miquel</td>
</tr>
<tr>
<td>Author:</td>
<td>Miquel De Cáceres [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Miquel De Cáceres &lt;miquelcaceres@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-25 08:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='vegclust-package'>
Fuzzy Clustering of Vegetation Data
Functions for fuzzy and hard clustering of vegetation data
</h2><span id='topic+vegclust-package'></span>

<h3>Description</h3>

<p>A set of functions to: (1) perform fuzzy clustering of vegetation data (De Caceres et al, 2010) &lt;doi:10.1111/j.1654-1103.2010.01211.x&gt;; (2) to assess ecological community similarity on the basis of structure and composition (De Caceres et al, 2013) &lt;doi:10.1111/2041-210X.12116&gt;.
This package contains functions used to perform fuzzy and hard clustering of vegetation data under different models.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> vegclust</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Fuzzy Clustering of Vegetation Data</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.0.2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2022-08-24</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> c(
	person('Miquel', 'De Cáceres', role=c('aut','cre'),
	email='miquelcaceres@gmail.com'))</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> A set of functions to: (1) perform fuzzy clustering of vegetation data (De Caceres et al, 2010) &lt;doi:10.1111/j.1654-1103.2010.01211.x&gt;; (2) to assess ecological community similarity on the basis of structure and composition (De Caceres et al, 2013) &lt;doi:10.1111/2041-210X.12116&gt;.</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 3.4.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> vegan</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://emf-creaf.github.io/vegclust/</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
Encoding: </td><td style="text-align: left;"> UTF-8</td>
</tr>
<tr>
 <td style="text-align: left;">
NeedsCompilation: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
RoxygenNote: </td><td style="text-align: left;"> 7.1.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> knitr, rmarkdown</td>
</tr>
<tr>
 <td style="text-align: left;">
VignetteBuilder: </td><td style="text-align: left;"> utils, knitr</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Miquel De Cáceres [aut, cre]</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Miquel De Cáceres &lt;miquelcaceres@gmail.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
CAP                     Cumulative abundance profile (CAP)
CAS                     Cumulative abundance surface (CAS)
as.memb                 Turns into membership matrix
as.vegclust             Turns into vegclust objects
clustcentroid           Cluster centers of a classification
clustconst              Constancy table of a classification
clustvar                Cluster variance
concordance             Concordance between two classifications
conformveg              Conform two community data tables
crossmemb               Cross-table of two fuzzy classifications
defuzzify               Defuzzifies a fuzzy partition
hcr                     Heterogeneity-constrained random resampling
                        (HCR)
hier.vegclust           Clustering with several number of clusters
incr.vegclust           Noise clustering with increasing number of
                        clusters
interclustdist          Calculates the distance between pairs of
                        cluster centroids
medreg                  Regeneration of Mediterranean vegetation data
                        set
plot.CAP                Draws cummulative abundance profiles
plot.CAS                Draws a cummulative abundance surface
plot.mvegclust          Plots clustering results
relate.levels           Relates two clustering level results.
stratifyvegdata         Reshapes community data from individual into
                        stratified form
treedata                Synthetic vegetation data set with tree data
vegclass                Classifies vegetation communities
vegclust                Vegetation clustering methods
vegclust-package        Fuzzy Clustering of Vegetation Data Functions
                        for fuzzy and hard clustering of vegetation
                        data
vegclust2kmeans         Reshapes as kmeans object
vegclustIndex           Compute fuzzy evaluation statistics
vegdiststruct           Structural and compositional dissimilarity
wetland                 Wetland vegetation data set
</pre>


<h3>Author(s)</h3>

<p>NA
Maintainer: NA 
</p>


<h3>References</h3>

<p>De Caceres, M., Font, X, Oliva, F. (2010) The management of numerical vegetation classifications with fuzzy clustering methods. Journal of Vegetation Science 21 (6): 1138-1151.
</p>
<p>De Cáceres, M., Legendre, P., &amp; He, F. 2013. Dissimilarity measurements and the size structure of ecological communities (D. Faith, Ed.). Methods in Ecology and Evolution 4: 1167–1177.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Loads data  
data(wetland)
  
## This equals the chord transformation 
wetland.chord = as.data.frame(sweep(as.matrix(wetland), 1, 
                              sqrt(rowSums(as.matrix(wetland)^2)), "/"))

## Create noise clustering with 3 clusters. Perform 10 starts from random seeds 
## and keep the best solution
wetland.nc = vegclust(wetland.chord, mobileCenters=3, m = 1.2, dnoise=0.75, 
                      method="NC", nstart=10)
</code></pre>

<hr>
<h2 id='as.memb'>
Turns into membership matrix
</h2><span id='topic+as.memb'></span>

<h3>Description</h3>

<p>Attempts to turn its cluster vector argument into a membership matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.memb(cluster)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.memb_+3A_cluster">cluster</code></td>
<td>

<p>A vector indicating the hard membership of each object in <code>x</code> to a set of groups. Can contain <code>NA</code> values.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An matrix with as many rows as the length of <code>cluster</code> and as many columns as different cluster levels. <code>NA</code> values will have zero membership to all clusters
</p>


<h3>Author(s)</h3>

<p>Miquel De Cáceres, CREAF.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vegclust">vegclust</a></code>, <code><a href="#topic+vegclass">vegclass</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as.memb(factor(c(1,2,NA)))
</code></pre>

<hr>
<h2 id='as.vegclust'>
Turns into vegclust objects
</h2><span id='topic+as.vegclust'></span>

<h3>Description</h3>

<p>Attempts to turn its arguments into a <code><a href="#topic+vegclust">vegclust</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.vegclust(x, y, method="KM", m=1.0, dnoise=NULL, eta=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.vegclust_+3A_x">x</code></td>
<td>

<p>A site-by-species data matrix (raw mode), or a site-by-site distance matrix (distance mode).
</p>
</td></tr>
<tr><td><code id="as.vegclust_+3A_y">y</code></td>
<td>

<p>A vector indicating the cluster that each object in <code>x</code> belongs to. Alternatively, a fuzzy/hard site-by-group matrix of membership values.
</p>
</td></tr>
<tr><td><code id="as.vegclust_+3A_method">method</code></td>
<td>

<p>A clustering model from which <code>y</code> was obtained (normally &quot;KM&quot;). Current accepted models are:
</p>

<ul>
<li><p><code>"KM"</code>: K-means or hard c-means (MacQueen 1967)
</p>
</li>
<li><p><code>"KMdd"</code>: Hard c-medoids (Krishnapuram et al. 1999)
</p>
</li>
<li><p><code>"FCM"</code>: Fuzzy c-means (Bezdek 1981)
</p>
</li>
<li><p><code>"FCMdd"</code>: Fuzzy c-medoids (Krishnapuram et al. 1999)
</p>
</li>
<li><p><code>"NC"</code>: Noise clustering (Dave and Krishnapuram 1997)
</p>
</li>
<li><p><code>"NCdd"</code>: Noise clustering with medoids
</p>
</li>
<li><p><code>"HNC"</code>: Hard noise clustering
</p>
</li>
<li><p><code>"HNCdd"</code>: Hard noise clustering with medoids
</p>
</li>
<li><p><code>"PCM"</code>: Possibilistic c-means (Krishnapuram and Keller 1993)
</p>
</li>
<li><p><code>"PCMdd"</code>: Possibilistic c-medoids
</p>
</li></ul>

</td></tr>
<tr><td><code id="as.vegclust_+3A_m">m</code></td>
<td>

<p>The fuzziness exponent to be used, relevant for all fuzzy models (FCM, FCMdd, NC, NCdd, PCM and PCMdd)
</p>
</td></tr>
<tr><td><code id="as.vegclust_+3A_dnoise">dnoise</code></td>
<td>

<p>The distance to the noise cluster, relevant for noise clustering models (NC, HNC, NCdd and HNCdd). 
</p>
</td></tr>
<tr><td><code id="as.vegclust_+3A_eta">eta</code></td>
<td>

<p>A vector of reference distances, relevant for possibilistic models (PCM and PCMdd). 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to generate <code><a href="#topic+vegclust">vegclust</a></code> objects which can then be used in <code><a href="#topic+vegclass">vegclass</a></code> to classify new data. If the input classification is hard (i.e. yes/no membership), cluster centers are calculated as multivariate means, and the method for assigning new data is assumed to be k-means (<code>"KM"</code>), i.e. plots will be assigned to the nearest cluster center. If community data is given as site-by-species data matrix the cluster centroids are added as <code>mobileCenters</code> in the <code><a href="#topic+vegclust">vegclust</a></code> object. Centroids will not be computed if community data is given as a site-by-site dissimilarity matrix. Moreover, current implementation does not allow <code>y</code> to be a membership matrix when <code>x</code> is a distance matrix.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+vegclust">vegclust</a></code>.
</p>


<h3>Author(s)</h3>

<p>Miquel De Cáceres, CREAF.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vegclust">vegclust</a></code>, <code><a href="#topic+vegclass">vegclass</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Loads data  
data(wetland)

## This equals the chord transformation 
## (see also  \code{\link{decostand}} in package vegan)
wetland.chord = as.data.frame(sweep(as.matrix(wetland), 1, 
                              sqrt(rowSums(as.matrix(wetland)^2)), "/"))

## Splits wetland data into two matrices of 30x27 and 11x22
wetland.30 = wetland.chord[1:30,]
wetland.30 = wetland.30[,colSums(wetland.30)&gt;0]
dim(wetland.30)
wetland.11 = wetland.chord[31:41,]
wetland.11 = wetland.11[,colSums(wetland.11)&gt;0] 
dim(wetland.11)

## Performs a K-means clustering of the data set with 30 sites
wetland.km = kmeans(wetland.30, centers=3, nstart=10)

## Transforms the 'external' classification of 30 sites into a 'vegclust' object
wetland.30.vc = as.vegclust(wetland.30, wetland.km$cluster)

## Assigns the second set of sites according to the (k-means) membership rule 
## That is, sites are assigned to the cluster whose cluster centroids is nearest.
wetland.11.km = vegclass(wetland.30.vc, wetland.11)

## A similar 'vegclust' object is obtained when using the distance mode...
wetland.d.vc = as.vegclust(dist(wetland.30), wetland.km$cluster)

## which can be also used to produce the assignment of the second set of objects
wetland.d.11 = as.data.frame(as.matrix(dist(wetland.chord)))[31:41,1:30]
wetland.d.11.km = vegclass(wetland.d.vc,wetland.d.11)
</code></pre>

<hr>
<h2 id='CAP'>
Cumulative abundance profile (CAP)
</h2><span id='topic+CAP'></span><span id='topic+CAP2matrix'></span><span id='topic+CAPcenters'></span><span id='topic+CAPquantile'></span>

<h3>Description</h3>

<p>Functions to calculate cumulative abundance profiles (CAPs), to build matrices from them, and to summarize several profiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CAP(x, transform=NULL, verbose=FALSE)
CAP2matrix(CAP, type="cumulative",classWeights=NULL)
CAPcenters(CAP, y=NULL)
CAPquantile(CAP, q = 0.5, y = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CAP_+3A_x">x</code></td>
<td>
<p>A stratified vegetation data set (see function <code><a href="#topic+stratifyvegdata">stratifyvegdata</a></code>).</p>
</td></tr>
<tr><td><code id="CAP_+3A_transform">transform</code></td>
<td>
<p>A function or the name of a function to be applied to each cumulative abundance value.</p>
</td></tr>
<tr><td><code id="CAP_+3A_verbose">verbose</code></td>
<td>
<p>A logical flag to indicate extra output.</p>
</td></tr>
<tr><td><code id="CAP_+3A_cap">CAP</code></td>
<td>
<p>An object of class '<code>CAP</code>'.</p>
</td></tr>
<tr><td><code id="CAP_+3A_type">type</code></td>
<td>
<p>The type of information that the resulting matrix should contain. Either <code>"profile"</code>, <code>"abundance"</code> or <code>"volume"</code>.</p>
</td></tr>
<tr><td><code id="CAP_+3A_classweights">classWeights</code></td>
<td>
<p>A numerical vector containing the weight for size class. If <code>NULL</code>, then all classes are assumed to have the same weight.</p>
</td></tr>
<tr><td><code id="CAP_+3A_y">y</code></td>
<td>
<p>A vector used as a factor to calculate average or quantile profiles per each level. Alternatively, an object of class <code><a href="#topic+vegclust">vegclust</a></code> for which CAP centroids or medoids are desired.</p>
</td></tr>
<tr><td><code id="CAP_+3A_q">q</code></td>
<td>
<p>Probability value for which the quantile is desired. By default the median is given.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>CAP</code> replaces the abundance value of a size class by the sum of abundances in this and larger size classes (strata). Thus, upper classes contain smaller abundance values than lower classes, creating a cumulative abundance profile. Function <code>CAP2matrix</code> takes an object of class '<code>CAP</code>' and returns a data matrix, where values differ depending on parameter <code>type</code>: (1) <code>type="cumulative"</code> simply reshapes the '<code>CAP</code>' object (a list) into a matrix with as many rows as plot records and where columns are organized in blocks (there are as many blocks as species and each block has as many columns as size classes); (2) <code>type="total"</code> returns a plot-by-species matrix where each value is the total abundance of the species in the plot (i.e. the CAP value at the ground level); (3) <code>type="volume"</code> returns a plot-by-species matrix where each value is the sum of CAP values across size classes (a measure of the &quot;volume&quot; occupied by the species in the plot). When provided, <code>classWeights</code> are used to weight size classes of the cumulative abundance profiles (for (1) and (3) only). Function <code>CAPcenters</code> calculates the average abundance profile for a set of plot records. If <code>y</code> is a factor, it is used to speficy groups of samples for which average profiles are to be calculated. If <code>y</code> is an object of class '<code><a href="#topic+vegclust">vegclust</a></code>' then the function returns the CAP centroids or medoids corresponding to the clustering result. Function <code>CAPquantile</code> calculates a quantile profile for a set of CAPs. The usage of <code>y</code> is the same as for <code>CAPcenters</code>.
</p>


<h3>Value</h3>

<p>Function <code>CAP</code> returns an object of class '<code>CAP</code>', similar to objects of class '<code>stratifiedvegdata</code>' but where abundance values of upper size classes have beed added to those of lower size classes. Function <code>CAP2matrix</code> returns a matrix with species as rows (columns depend on the value of <code>type</code>). Functions <code>CAPcenters</code> and <code>CAPquantile</code> return an object of class '<code>CAP</code>'.
</p>


<h3>Author(s)</h3>

<p>Miquel De Cáceres, CREAF.
</p>


<h3>References</h3>

<p>De Cáceres, M., Legendre, P. &amp; He, F. (2013) Dissimilarity measurements and the size structure of ecological communities. Methods in Ecology and Evolution 4: 1167-1177.
</p>
<p>De Cáceres, M., Coll, L., Martín-Alcón, S., González-Olabarria, J.R. (submitted) A general method for the classification of forest stands using structure and composition.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stratifyvegdata">stratifyvegdata</a></code>, <code><a href="#topic+plot.CAP">plot.CAP</a></code>, <code><a href="#topic+vegdiststruct">vegdiststruct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load stratified data
data(medreg)

## Check that 'medreg' has correct class
class(medreg)

## Look at the data for the third plot
medreg[[3]]

## Create cumulative abundance profile (CAP) for each plot
medreg.CAP = CAP(medreg)

## Look at the profile of the third plot
medreg.CAP[[3]]

## Create matrix with species abundances
medreg.X = CAP2matrix(medreg.CAP, type="total")
head(medreg.X)

## Generate and plot average profile
average.CAP = CAPcenters(medreg.CAP)
plot(average.CAP)

## Generate and plot median profile
median.CAP = CAPquantile(medreg.CAP, q = 0.5)
plot(median.CAP)

</code></pre>

<hr>
<h2 id='CAS'>
Cumulative abundance surface (CAS)
</h2><span id='topic+CAS'></span><span id='topic+CASmargin'></span><span id='topic+CAS2matrix'></span><span id='topic+CAScenters'></span><span id='topic+CASquantile'></span>

<h3>Description</h3>

<p>Functions to calculate cumulative abundance surfaces (CASs), to build matrices from them, and to summarize several CASs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CAS(x, transform=NULL, verbose=FALSE)
CASmargin(CAS, margin=1, verbose=FALSE)
CAS2matrix(CAS, type="cumulative",classWeights=NULL)
CAScenters(CAS, y=NULL)
CASquantile(CAS, q = 0.5, y = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CAS_+3A_x">x</code></td>
<td>
<p>An object of class 'doublestratifiedvegdata' (see function <code><a href="#topic+stratifyvegdata">stratifyvegdata</a></code>).</p>
</td></tr>
<tr><td><code id="CAS_+3A_transform">transform</code></td>
<td>
<p>A function or the name of a function to be applied to each cumulative abundance value.</p>
</td></tr>
<tr><td><code id="CAS_+3A_verbose">verbose</code></td>
<td>
<p>A logical flag to indicate extra output.</p>
</td></tr>
<tr><td><code id="CAS_+3A_cas">CAS</code></td>
<td>
<p>An object of class '<code>CAS</code>'.</p>
</td></tr>
<tr><td><code id="CAS_+3A_margin">margin</code></td>
<td>
<p>Indicates whether marginalization should be done in primary (<code>margin = 1</code>) or secondary (<code>margin = 2</code>) size classes.</p>
</td></tr>
<tr><td><code id="CAS_+3A_type">type</code></td>
<td>
<p>The type of information that the resulting matrix should contain (either <code>"cummulative"</code> or <code>"total"</code>).</p>
</td></tr>
<tr><td><code id="CAS_+3A_classweights">classWeights</code></td>
<td>
<p>A numerical matrix containing the weight for each combination of size classes. If <code>NULL</code>, then all classes are assumed to have the same weight.</p>
</td></tr>
<tr><td><code id="CAS_+3A_y">y</code></td>
<td>
<p>A vector used as a factor to calculate average or quantile surfaces per each level. Alternatively, an object of class <code><a href="#topic+vegclust">vegclust</a></code> for which CAS centroids or medoids are desired.</p>
</td></tr>
<tr><td><code id="CAS_+3A_q">q</code></td>
<td>
<p>Probability value for which the quantile is desired. By default the median is given.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>CAS</code> replaces the abundance value of each combination of size classes by the sum of abundances in this and larger size classes. This creates a cumulative abundance surface (similar to a bivariant cummulative distribution function). Function <code>CASmargin</code> takes an object of class '<code>CAS</code>' and returns an object of class '<code>CAP</code>' that corresponds marginal profile in either the primary or the secondary size classes. Function <code>CAS2matrix</code> takes an object of class '<code>CAS</code>' and returns a data matrix, where values differ depending on parameter <code>type</code>: (1) <code>type="cummulative"</code> simply reshapes the '<code>CAS</code>' object (a list) into a matrix with as many rows as plot records and where columns are organized in blocks (there are as many blocks as species and each block has as many columns as combinations of size classes); (2) <code>type="total"</code> returns a plot-by-species matrix where each value is the total abundance of the species in the plot (i.e. the CAS value at the ground level). When provided, <code>classWeights</code> are used to weight size classes of the cumulative abundance surfaces (for (1) only). Function <code>CAScenters</code> calculates the average abundance surface for a set of plot records. If <code>y</code> is a factor, it is used to speficy groups of samples for which average profiles are to be calculated. If <code>y</code> is an object of class '<code><a href="#topic+vegclust">vegclust</a></code>' then the function returns the CAS centroids or medoids corresponding to the clustering result. Function <code>CASquantile</code> calculates a quantile surface for a set of CASs. The usage of <code>y</code> is the same as for <code>CAScenters</code>.
</p>


<h3>Value</h3>

<p>Function <code>CAS</code> returns an object of class '<code>CAS</code>', similar to objects of class '<code>doublestratifiedvegdata</code>' but where abundance values of upper size classes have beed added to those of lower size classes. Function <code>CAS2matrix</code> returns a matrix with species as rows (columns depend on the value of <code>type</code>). Functions <code>CAScenters</code> and <code>CASquantile</code> return an object of class '<code>CAS</code>'.
</p>


<h3>Author(s)</h3>

<p>Miquel De Cáceres, CREAF.
</p>


<h3>References</h3>

<p>De Cáceres, M., Legendre, P. &amp; He, F. (2013) Dissimilarity measurements and the size structure of ecological communities. Methods in Ecology and Evolution 4: 1167-1177.
</p>
<p>De Cáceres, M., Coll, L., Martín-Alcón, S., González-Olabarria, J.R. (submitted) A general method for the classification of forest stands using structure and composition.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stratifyvegdata">stratifyvegdata</a></code>, <code><a href="#topic+plot.CAS">plot.CAS</a></code>, <code><a href="#topic+vegdiststruct">vegdiststruct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load tree data
data(treedata)

## Define stratum thresholds (4 strata)
heights = seq(0,4, by=0.5)
diameters = seq(0,2, by=0.5)


## Stratify tree data using heights and diameters as structural variables
X = stratifyvegdata(treedata, sizes1=heights, sizes2=diameters, plotColumn="plotID",
                    speciesColumn="species", size1Column="height", size2Column="diam",
                    counts=TRUE)
X[[2]]

## Build cummulative abundance surface
Y = CAS(X)

Y[[2]]

##  Extracts the first and second marginal (i.e. CAP on heights or diameters respectively)
Y.M1 = CASmargin(Y, margin = 1)
Y.M1[[2]]

Y.M2 = CASmargin(Y, margin = 2)
Y.M2[[2]]

##  For comparison we calculate the same profiles using the stratifyvegdata and CAP functions
Y1 = CAP(stratifyvegdata(treedata, sizes1=heights, plotColumn="plotID",
                    speciesColumn="species", size1Column="height",
                    counts=TRUE))                   
Y1[[2]]
Y2 = CAP(stratifyvegdata(treedata, sizes1=diameters, plotColumn="plotID",
                    speciesColumn="species", size1Column="diam",
                    counts=TRUE))                   
Y2[[2]]

##  Compare Y.M1[[2]] with Y1[[2]] and Y.M2[[2]] with Y2[[2]]
</code></pre>

<hr>
<h2 id='clustcentroid'>
Cluster centers of a classification
</h2><span id='topic+clustcentroid'></span><span id='topic+clustmedoid'></span>

<h3>Description</h3>

<p>Function <code>clustcentroid</code> calculates the centroid (multivariate average) coordinates of a classification. Function <code>clustmedoid</code> determines the medoid (object whose average dissimilarity to all the other objects is minimal) for each cluster in the classification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustcentroid(x, y, m = 1)
clustmedoid(x, y, m = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clustcentroid_+3A_x">x</code></td>
<td>

<p>Community data, a site-by-species data frame. In function <code>clustmedoid</code>, <code>x</code> can alternatively be an object of class <code><a href="stats.html#topic+dist">dist</a></code> (otherwise, the dissimilarity measure is assumed to be the Euclidean distance). 
</p>
</td></tr>
<tr><td><code id="clustcentroid_+3A_y">y</code></td>
<td>

<p>It can be (a) A vector indicating the cluster that each object in <code>x</code> belongs to; (b) a fuzzy/hard site-by-group matrix of membership values; (c) an object of class <code><a href="#topic+vegclust">vegclust</a></code> or <code><a href="#topic+vegclass">vegclass</a></code>
</p>
</td></tr>
<tr><td><code id="clustcentroid_+3A_m">m</code></td>
<td>
<p>Fuzziness exponent, only effective when <code>y</code> is a fuzzy membership matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function <code>clustcentroid</code> returns a group-by-species matrix containing species average abundance values (i.e. the coordinates of each cluster centroid). Function <code>clustmedoid</code> returns a vector of indices (medoids).
</p>


<h3>Note</h3>

<p>In order to assign new plot record data into a predefined set of classes, one should use functions <code><a href="#topic+as.vegclust">as.vegclust</a></code> and <code><a href="#topic+vegclass">vegclass</a></code> instead.
</p>


<h3>Author(s)</h3>

<p>Miquel De Cáceres, CREAF
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.vegclust">as.vegclust</a></code>, <code><a href="#topic+vegclass">vegclass</a></code>, <code><a href="#topic+vegclust">vegclust</a></code>, <code><a href="stats.html#topic+kmeans">kmeans</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Loads stats
library(stats)
  
## Loads data
data(wetland)
  
## This equals the chord transformation 
## (see also \code{\link{decostand}} in package 'vegan')
wetland.chord = as.data.frame(sweep(as.matrix(wetland), 1,
                              sqrt(rowSums(as.matrix(wetland)^2)), "/"))

## Performs a K-means clustering
wetland.km = kmeans(wetland.chord, centers=3, nstart=10)

## Gets the coordinates corresponding to the centroids of KM clusters
clustcentroid(wetland.chord, y=wetland.km$cluster)

## Gets the object indices corresponding to the medoids of KM clusters
clustmedoid(wetland.chord, y=wetland.km$cluster)

</code></pre>

<hr>
<h2 id='clustconst'>
Constancy table of a classification
</h2><span id='topic+clustconst'></span><span id='topic+summary.clustconst'></span>

<h3>Description</h3>

<p>Allows studying the constancy table (i.e. the frequency of species in each class) of a classification represented in the form of a membership data matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustconst(x, memb)
## S3 method for class 'clustconst'
summary(object, mode="all", name=NULL, sort=TRUE, minconst=0.5, digits=3, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clustconst_+3A_x">x</code></td>
<td>

<p>Community data, a site by species data frame.
</p>
</td></tr>
<tr><td><code id="clustconst_+3A_memb">memb</code></td>
<td>

<p>An site-by-group matrix indicating the (hard or fuzzy) membership of each object in <code>x</code> to a set of groups.
</p>
</td></tr>
<tr><td><code id="clustconst_+3A_object">object</code></td>
<td>
<p>An object of class 'clustconst'.</p>
</td></tr>
<tr><td><code id="clustconst_+3A_mode">mode</code></td>
<td>
<p>Use <code>mode="all"</code> to print the constancy table, <code>mode="cluster"</code> to print constancy values for one cluster, and <code>mode="species"</code>, to print constancy values for one species.</p>
</td></tr>
<tr><td><code id="clustconst_+3A_name">name</code></td>
<td>
<p>A string with the name of a cluster (in <code>mode="cluster"</code>), or the name of a species (in <code>mode="species"</code>).</p>
</td></tr>
<tr><td><code id="clustconst_+3A_sort">sort</code></td>
<td>
<p>A flag to indicate whether constancy table should be sorted in descending order.</p>
</td></tr>
<tr><td><code id="clustconst_+3A_minconst">minconst</code></td>
<td>
<p>A threshold used to limit the values shown.</p>
</td></tr>
<tr><td><code id="clustconst_+3A_digits">digits</code></td>
<td>
<p>The number of digits for rounding.</p>
</td></tr>
<tr><td><code id="clustconst_+3A_...">...</code></td>
<td>
<p>Additional parameters for summary (actually not used).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The constancy value of a species in a vegetation unit is the relative frequency of occurrence of the species in plot records that belong to the unit. In case of a fuzzy vegetation unit the constancy value is the sum of memberships of sites that contain the species divided by the sum of memberships of all sites. Use the 'summary' function to obtain information about: (1) which species are more frequent on a given vegetation unit; (2) which vegetation units have higher frequencies of a given target species. Additionally, the 'summary' function can sort a constancy table if <code>mode="all"</code> and <code>sort=TRUE</code> are indicated.
</p>


<h3>Value</h3>

<p>Function <code>clustconst</code> returns an object of type 'clustconst', in fact a data frame with the constancy value of each species (rows) on each cluster (column).
</p>


<h3>Author(s)</h3>

<p>Miquel De Cáceres, CREAF
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vegclust">vegclust</a></code>, <code><a href="stats.html#topic+kmeans">kmeans</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Loads stats
library(stats)  

## Loads data  
data(wetland)
  
## This equals the chord transformation 
## (see also \code{\link{decostand}} in package 'vegan')
wetland.chord = as.data.frame(sweep(as.matrix(wetland), 1, 
                              sqrt(rowSums(as.matrix(wetland)^2)), "/"))

## Performs a K-means clustering
wetland.km = kmeans(wetland.chord, centers=3, nstart=10)

## Gets constancy table of KM (i.e. hard) clusters
c=clustconst(wetland.chord, memb=as.memb(wetland.km$cluster))

## Prints constancy values ordered and store the result in d
d=summary(c, mode="all")

## Prints the most frequent species in the first cluster
summary(c, mode="cluster", name=names(c)[1])
</code></pre>

<hr>
<h2 id='clustvar'>
Cluster variance
</h2><span id='topic+clustvar'></span>

<h3>Description</h3>

<p>Computes the variation in community composition (i.e. beta diversity) found within the sites of a set of hard or fuzzy clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustvar(x, cluster = NULL, defuzzify=FALSE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clustvar_+3A_x">x</code></td>
<td>

<p>Community data. Either a site-by-species matrix or a site-by-site matrix of compositional distances between sites  (i.e., an object of class <code><a href="stats.html#topic+dist">dist</a></code>). Alternatively, this can be an object of class <code><a href="#topic+vegclust">vegclust</a></code> or <code><a href="#topic+vegclass">vegclass</a></code>, and in this case it is unnecessary to provide <code>cluster</code>.
</p>
</td></tr>
<tr><td><code id="clustvar_+3A_cluster">cluster</code></td>
<td>

<p>A vector indicating the hard membership of each object in <code>x</code> to a set of groups.
</p>
</td></tr>
<tr><td><code id="clustvar_+3A_defuzzify">defuzzify</code></td>
<td>

<p>A flag indicating whether fuzzy memberships should be defuzzified (see function <code><a href="#topic+defuzzify">defuzzify</a></code>). Only applies to the case where an object of class <code><a href="#topic+vegclust">vegclust</a></code> or <code><a href="#topic+vegclass">vegclass</a></code> is supplied in <code>x</code>.
</p>
</td></tr>
<tr><td><code id="clustvar_+3A_...">...</code></td>
<td>

<p>Additional parameters for function <code><a href="#topic+defuzzify">defuzzify</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used in two ways:
</p>

<ul>
<li><p>if <code>x</code> is a data matrix (site by species or distances among sites) and <code>cluster</code> is <code>null</code>, the function assumes a single cluster of all points in <code>x</code>. When <code>cluster</code> is provided, the function computes cluster variance for each (hard) group and this computation implies setting the centroid of the group. Cluster variance is defined as the average squared distance to the centroid.
</p>
</li>
<li>
<p>If <code>x</code> is an object of class <code><a href="#topic+vegclust">vegclust</a></code> or <code><a href="#topic+vegclass">vegclass</a></code>, the function uses the information contained there (distances to cluster centers, memberships and exponent of fuzziness) in order to compute cluster variances. Cluster centers do not need to be recomputed, and the distances to cluster centers are used directly. For centroid-based cluster models (KM, FCM, NC, HNC and PCM) the variance is defined as the average squared distance to the centroid. For medoid-based cluster models (KMdd, FCMdd, NCdd, HNCdd and PCMdd) the variance is defined as average distance to the medoid. The variance for both mobile and fixed clusters is returned. Additionally, membership matrices may be defuzzified if <code>defuzzify=TRUE</code>. 

</p>
</li></ul>



<h3>Value</h3>

<p>A double value (for one cluster) or a vector of values, one per each cluster.
</p>


<h3>Author(s)</h3>

<p>Miquel De Cáceres, CREAF
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vegclust">vegclust</a></code>, <code><a href="stats.html#topic+kmeans">kmeans</a></code>,<code><a href="#topic+defuzzify">defuzzify</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Loads data  
data(wetland)

## This equals the chord transformation 
## (see also \code{\link{decostand}} in package 'vegan')
wetland.chord = as.data.frame(sweep(as.matrix(wetland), 1, 
                              sqrt(rowSums(as.matrix(wetland)^2)), "/"))

## Create noise clustering with 3 clusters. Perform 10 starts from random seeds 
## and keep the best solution
wetland.nc = vegclust(wetland.chord, mobileCenters=3, m = 1.2, dnoise=0.75, 
                      method="NC", nstart=10)

## Gets cluster variance of fuzzy clusters
clustvar(wetland.nc)

## Gets cluster variance of fuzzy clusters after defuzzification
clustvar(wetland.nc, defuzzify=TRUE)

## Similar to the previous, this gets cluster variance of defuzzified (i.e. hard) clusters
clustvar(wetland.chord, cluster=defuzzify(wetland.nc)$cluster)

## Gets cluster variance of K-means (i.e. hard) clusters
clustvar(wetland.chord, cluster=kmeans(wetland.chord, centers=3, nstart=10)$cluster)

</code></pre>

<hr>
<h2 id='concordance'>
Concordance between two classifications
</h2><span id='topic+concordance'></span>

<h3>Description</h3>

<p>Computes an index to compare two classifications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>concordance(x, y, method="adjustedRand",...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="concordance_+3A_x">x</code>, <code id="concordance_+3A_y">y</code></td>
<td>
<p> Classification vector or membership matrix. Alternatively, objects of type <code><a href="#topic+vegclust">vegclust</a></code> or <code><a href="#topic+vegclass">vegclass</a></code>.</p>
</td></tr>
<tr><td><code id="concordance_+3A_method">method</code></td>
<td>
<p>A string vector to indicate the desired indices (see details).</p>
</td></tr>
<tr><td><code id="concordance_+3A_...">...</code></td>
<td>

<p>Additional parameters for function <code><a href="#topic+defuzzify">defuzzify</a></code>, which will be called if <code>x</code> or <code>y</code> are of type <code>matrix</code>, <code><a href="#topic+vegclust">vegclust</a></code> or <code><a href="#topic+vegclass">vegclass</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Several indices for comparison of partitions are available:
</p>

<ul>
<li><p><code>method="Rand"</code>: Rand (1971) index.
</p>
</li>
<li><p><code>method="adjustedRand"</code>: Rand index adjusted for random effects (Hubert &amp; Arabie 1985).
</p>
</li>
<li><p><code>method="Wallace"</code>: Wallace (1983) index (for asymmetrical comparisons). This index (and its adjusted version) is useful to quantify how much <code>x</code> is nested into <code>y</code>.
</p>
</li>
<li><p><code>method="adjustedWallace"</code>: Wallace index adjusted for random effects (Pinto et al. 2008).
</p>
</li></ul>



<h3>Value</h3>

<p>A numeric vector with the desired index values.
</p>


<h3>Author(s)</h3>

<p>Miquel De Cáceres, CREAF
</p>


<h3>References</h3>

<p>Hubert, L. &amp; Arabie, P. (1985). Comparing partitions. Journal of Classification, 2, 193–218.
</p>
<p>Pinto, F.R., Melo-Cristino, J. &amp; Ramirez, M. (2008). A confidence interval for the wallace coefficient of concordance and its application to microbial typing methods. PLoS ONE, 3.
</p>
<p>Rand, W.M. (1971). Objective Criteria for the Evaluation of Clustering Methods. Journal of the American Statistical Association, 66, 846–850.
</p>
<p>Wallace, D.L. (1983). A method for comparing two hierarchical clusterings: Comment. Journal of the American Statistical Association, 78, 569–576.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vegclust">vegclust</a></code>, <code><a href="#topic+vegclass">vegclass</a></code>, <code><a href="#topic+defuzzify">defuzzify</a></code>
</p>

<hr>
<h2 id='conformveg'>
Conform two community data tables
</h2><span id='topic+conformveg'></span>

<h3>Description</h3>

<p>Conforms two community data tables to have the same set of columns (species)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conformveg(x, y, fillvalue = 0, verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conformveg_+3A_x">x</code></td>
<td>

<p>Community data, a site-by-species matrix.
</p>
</td></tr>
<tr><td><code id="conformveg_+3A_y">y</code></td>
<td>

<p>Community data, a site-by-species matrix.
</p>
</td></tr>
<tr><td><code id="conformveg_+3A_fillvalue">fillvalue</code></td>
<td>

<p>The value to be used to fill new entries in inflated matrices.
</p>
</td></tr>
<tr><td><code id="conformveg_+3A_verbose">verbose</code></td>
<td>

<p>Displays information about the number of species shared between <code>x</code> and <code>y</code>, as well as the number of species that are in one of the data tables but not in the other.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function adds to <code>x</code> as many new columns as columns of <code>y</code> that are not in <code>x</code>. The same is done for <code>y</code>, so the two tables have the same set of columns when they are returned. 
</p>


<h3>Value</h3>

<p>A list with the two inflated matrices <code>x</code> and <code>y</code>.
</p>


<h3>Author(s)</h3>

<p>Miquel De Cáceres, Centre Tecnologic Forestal de Catalunya.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vegclust">vegclust</a></code>, <code><a href="#topic+vegclass">vegclass</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Loads data (38 columns and 33 species)
data(wetland)
dim(wetland)

## Splits wetland data into two matrices of 30x27 and 11x22
wetland.30 = wetland[1:30,]
wetland.30 = wetland.30[,colSums(wetland.30)&gt;0]
dim(wetland.30)
wetland.11 = wetland[31:41,]
wetland.11 = wetland.11[,colSums(wetland.11)&gt;0] 
dim(wetland.11)

## Conforms the two matrices so they can eventually be merged
wetland.cf = conformveg(wetland.30, wetland.11)
dim(wetland.cf$x)
dim(wetland.cf$y)
names(wetland.cf$x)==names(wetland.cf$y)
</code></pre>

<hr>
<h2 id='crossmemb'>
Cross-table of two fuzzy classifications
</h2><span id='topic+crossmemb'></span>

<h3>Description</h3>

<p>Calculates a cross-tabulated matrix relating two fuzzy membership matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crossmemb(x, y, relativize = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crossmemb_+3A_x">x</code></td>
<td>
<p>A site-by-group fuzzy membership matrix. Alternatively, an object of class 'vegclust' or 'vegclass'.</p>
</td></tr>
<tr><td><code id="crossmemb_+3A_y">y</code></td>
<td>
<p>A site-by-group fuzzy membership matrix. Alternatively, an object of class 'vegclust' or 'vegclass'.</p>
</td></tr>
<tr><td><code id="crossmemb_+3A_relativize">relativize</code></td>
<td>
<p>If <code>TRUE</code> expresses the cross-tabulated values as proportions of cluster size in <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cross-tabulated matrix comparing the two classifications. In general, each cell's value is the (fuzzy) number of objects that in <code>x</code> are assigned to the cluster corresponding to the row and in <code>y</code> are assigned to the cluster corresponding to the column. If <code>relativize=TRUE</code> then the values of each row are divided by the (fuzzy) size of the corresponding cluster in <code>x</code>. 
</p>


<h3>Author(s)</h3>

<p>Miquel De Cáceres, CREAF.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+defuzzify">defuzzify</a></code>, <code><a href="#topic+vegclust">vegclust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Loads data  
data(wetland)
  
## This equals the chord transformation 
## (see also  \code{\link{decostand}} in package vegan)
wetland.chord = as.data.frame(sweep(as.matrix(wetland), 1, 
                              sqrt(rowSums(as.matrix(wetland)^2)), "/"))


## Create clustering with 3 clusters. Perform 10 starts from random seeds 
## and keep the best solution. Try both FCM and NC methods:
wetland.fcm = vegclust(wetland.chord, mobileCenters=3, m = 1.2, method="FCM", nstart=10)
wetland.nc = vegclust(wetland.chord, mobileCenters=3, m = 1.2, dnoise=0.75, method="NC", 
                      nstart=10)

## Compare the results
crossmemb(wetland.fcm, wetland.nc, relativize=FALSE)
</code></pre>

<hr>
<h2 id='defuzzify'>
Defuzzifies a fuzzy partition
</h2><span id='topic+defuzzify'></span>

<h3>Description</h3>

<p>Transforms a fuzzy classification into a crisp (hard) classification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>defuzzify(object, method = "max", alpha = 0.5, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="defuzzify_+3A_object">object</code></td>
<td>
<p>A site-by-group fuzzy membership matrix. Alternatively, an object of class 'vegclust' or 'vegclass'.</p>
</td></tr>
<tr><td><code id="defuzzify_+3A_method">method</code></td>
<td>
<p>Either <code>"max"</code> to choose for the maximum membership value across clusters, or <code>"cut"</code> for an alpha-cut.</p>
</td></tr>
<tr><td><code id="defuzzify_+3A_alpha">alpha</code></td>
<td>
<p>Threshold for the alpha-cut, bounded between 0 and 1.</p>
</td></tr>
<tr><td><code id="defuzzify_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>TRUE</code> removes the objects that do not belong to any cluster when using <code>method="cut"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Alpha-cut means that memberships lower than alpha are transformed into 0 while memberships higher than alpha are transformed into 1. This means that if alpha values are low (i.e. close to 0), an object may belong to more than one group after defuzzification. These will generate a concatenation of cluster names in the output <code>cluster</code> vector and a row with sum more than one in the <code>memb</code> matrix). Similarly, if alpha is high (i.e. close to 1) there are objects that may be left unclassified. These will get <code>NA</code> in the <code>cluster</code> vector and zero row in the <code>memb</code> matrix.
</p>


<h3>Value</h3>

<p>A list with the following items:
</p>
<table>
<tr><td><code>memb</code></td>
<td>
<p>A data frame with the hard membership partition.</p>
</td></tr>
<tr><td><code>cluster</code></td>
<td>
<p>A vector (factor) with the name of the cluster for each object.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Miquel De Cáceres, CREAF.
</p>


<h3>References</h3>

<p>Davé, R. N. and R. Krishnapuram (1997) Robust clustering methods: a unified view. IEEE Transactions on Fuzzy Systems 5, 270-293.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vegclust">vegclust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Loads data  
data(wetland)
  
## This equals the chord transformation 
## (see also  \code{\link{decostand}} in package vegan)
wetland.chord = as.data.frame(sweep(as.matrix(wetland), 1, 
                              sqrt(rowSums(as.matrix(wetland)^2)), "/"))

## Create noise clustering with 3 clusters. Perform 10 starts from random seeds 
## and keep the best solution
wetland.nc = vegclust(wetland.chord, mobileCenters=3, m = 1.2, dnoise=0.75, 
                      method="NC", nstart=10)

## Defuzzification using an alpha-cut (alpha=0.5)
wetland.nc.df = defuzzify(wetland.nc$memb, method="cut")

## Cluster vector, with 'N' for objects that are unclassified, 
## and 'NA' for objects that are intermediate
print(wetland.nc.df$cluster)

## Hard membership matrix (site 22 does not get any cluster assigned)
print(wetland.nc.df$memb)

</code></pre>

<hr>
<h2 id='hcr'>
Heterogeneity-constrained random resampling (HCR) 
</h2><span id='topic+hcr'></span>

<h3>Description</h3>

<p>Returns a set of indices of the original data set that maximizes the mean and minimizes the variance of the distances between pairs of plot records.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hcr(d, nout, nsampl=1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hcr_+3A_d">d</code></td>
<td>

<p>An object of class <code><a href="stats.html#topic+dist">dist</a></code> containing the distance values between pairs of sites (plot records).
</p>
</td></tr>
<tr><td><code id="hcr_+3A_nout">nout</code></td>
<td>
<p>The number of sites (plot records) to be chosen among those available in <code>d</code>.</p>
</td></tr>
<tr><td><code id="hcr_+3A_nsampl">nsampl</code></td>
<td>
<p>The number of resampling trials to be compared.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Many subsets of the input data are selected randomly. These subsets are sorted by decreasing mean dissimilarity between pairs of plot records, and then sorted again by increasing variance of these dissimilarities. Ranks from both sortings are summed for each subset, and the subset with the lowest summed rank is considered as the most representative.
</p>


<h3>Value</h3>

<p>Returns a vector containing the indices of the selected sites (plot records) to be used for sub-setting the original table.
</p>


<h3>Author(s)</h3>

<p>Miquel De Cáceres, CREAF
</p>


<h3>References</h3>

<p>Lengyel, A., Chytry, M., Tichy, L. (2011) Heterogeneity-constrained random resampling of phytosociological databases. Journal of Vegetation Science 22: 175-183.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Loads data (38 columns and 33 species)
data(wetland)
dim(wetland)
  
## Constructs the chord distance matrix
## (see also  \code{\link{decostand}} in package vegan)
wetland.chord =dist(as.data.frame(sweep(as.matrix(wetland), 1, 
                    sqrt(rowSums(as.matrix(wetland)^2)), "/")))

## Performs HCR resampling. Returns indices of objects
sel = hcr(wetland.chord, nout=20, nsampl=1000)

## Prints the names of the plot records
print(row.names(wetland)[sel])

## Subset the original distance matrix
sel.chord = as.dist(as.matrix(wetland.chord)[sel,sel])
</code></pre>

<hr>
<h2 id='hier.vegclust'>
Clustering with several number of clusters
</h2><span id='topic+hier.vegclust'></span><span id='topic+random.vegclust'></span><span id='topic+hier.vegclustdist'></span><span id='topic+random.vegclustdist'></span>

<h3>Description</h3>

<p>Performs several runs of function 'vegclust' (or 'vegclustdist') on a community data matrix (or distance matrix) using different number of clusters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hier.vegclust(x, hclust, cmin=2,cmax=20, min.size=NULL, verbose=TRUE, ...)
hier.vegclustdist(x, hclust, cmin=2,cmax=20, min.size=NULL, verbose=TRUE, ...)
random.vegclust(x, cmin=2, cmax=20, nstart=10, min.size=NULL, verbose=TRUE, ...)
random.vegclustdist(x, cmin=2, cmax=20, nstart=10, min.size=NULL, verbose=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hier.vegclust_+3A_x">x</code></td>
<td>

<p>For <code>hier.vegclust</code> and random.vegclust, a site (rows) by species (columns) matrix or data frame. For <code>hier.vegclustdist</code> and random.vegclustdist, a square distance matrix.
</p>
</td></tr>
<tr><td><code id="hier.vegclust_+3A_hclust">hclust</code></td>
<td>

<p>A hierarchical clustering represented in an object of type <code><a href="stats.html#topic+hclust">hclust</a></code>.
</p>
</td></tr>
<tr><td><code id="hier.vegclust_+3A_cmin">cmin</code></td>
<td>

<p>Number of minimum mobile clusters.
</p>
</td></tr>
<tr><td><code id="hier.vegclust_+3A_cmax">cmax</code></td>
<td>

<p>Number of maximum mobile clusters.
</p>
</td></tr>
<tr><td><code id="hier.vegclust_+3A_nstart">nstart</code></td>
<td>

<p>A number indicating how many random trials should be performed for each number of groups
</p>
</td></tr>
<tr><td><code id="hier.vegclust_+3A_min.size">min.size</code></td>
<td>

<p>If <code>min.size != NULL</code>, it specifies the minimum size of clusters. If some clusters are smaller, the algorithm will return the solutions corresponding to lower numbers of clusters.
</p>
</td></tr>
<tr><td><code id="hier.vegclust_+3A_verbose">verbose</code></td>
<td>

<p>Flag used to print which number of clusters is currently running.
</p>
</td></tr>
<tr><td><code id="hier.vegclust_+3A_...">...</code></td>
<td>

<p>Additional parameters for function <code><a href="#topic+vegclust">vegclust</a></code> or <code><a href="#topic+vegclustdist">vegclustdist</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>hier.vegclust</code> takes starting cluster configurations from cuts of a dendrogram given by object <code>hclust</code>. Function <code>random.vegclust</code> chooses random objects as cluster centroids and for each number of clusters performs <code>nstart</code> trials. Functions <code>hier.vegclustdist</code> and <code>random.vegclustdist</code> are analogous to <code>hier.vegclust</code> and <code>random.vegclust</code> but accept distance matrices as input.
</p>


<h3>Value</h3>

<p>Returns an object of type 'mvegclust' (multiple vegclust), which contains a list vector with objects of type <code><a href="#topic+vegclust">vegclust</a></code>.
</p>


<h3>Author(s)</h3>

<p>Miquel De Cáceres, CREAF
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vegclust">vegclust</a></code>, <code><a href="#topic+vegclustdist">vegclustdist</a></code>, <code><a href="#topic+vegclass">vegclass</a></code>, <code><a href="#topic+defuzzify">defuzzify</a></code>, <code><a href="stats.html#topic+hclust">hclust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Loads data  
data(wetland)
  
## This equals the chord transformation 
## (see also  \code{\link{decostand}} in package vegan)
wetland.chord = as.data.frame(sweep(as.matrix(wetland), 1, 
                              sqrt(rowSums(as.matrix(wetland)^2)), "/"))

## Create noise clustering from hierarchical clustering at different number of clusters
wetland.hc = hclust(dist(wetland.chord),method="ward") 
wetland.nc1 = hier.vegclust(wetland.chord, wetland.hc, cmin=2, cmax=5, 
                            m = 1.2, dnoise=0.75, method="NC")

## Create noise clustering from random seeds at different levels
wetland.nc2 = random.vegclust(wetland.chord, cmin=2, cmax=5, nstart=10,
                              m = 1.2, dnoise=0.75, method="NC")
</code></pre>

<hr>
<h2 id='incr.vegclust'>
Noise clustering with increasing number of clusters
</h2><span id='topic+incr.vegclust'></span>

<h3>Description</h3>

<p>Performs several runs of function 'vegclust' on a community data matrix using an increasing number of clusters until some conditions are met.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>incr.vegclust(x, method="NC", ini.fixed.centers = NULL, 
              min.size = 10, max.var=NULL, alpha = 0.5, 
              nstart=100, fix.previous = TRUE, dnoise=0.75, m=1.0,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="incr.vegclust_+3A_x">x</code></td>
<td>

<p>Community data table. A site (rows) by species (columns) matrix or data frame.
</p>
</td></tr>
<tr><td><code id="incr.vegclust_+3A_method">method</code></td>
<td>

<p>A clustering model. Current accepted models are of the noise clustering family: 
</p>

<ul>
<li><p><code>"NC"</code>: Noise clustering (Dave and Krishnapuram 1997)
</p>
</li>
<li><p><code>"NCdd"</code>: Noise clustering with medoids
</p>
</li>
<li><p><code>"HNC"</code>: Hard noise clustering
</p>
</li>
<li><p><code>"HNCdd"</code>: Hard noise clustering with medoids
</p>
</li></ul>
  
</td></tr>
<tr><td><code id="incr.vegclust_+3A_ini.fixed.centers">ini.fixed.centers</code></td>
<td>

<p>The coordinates of initial fixed cluster centers. These will be used as <code>fixedCenters</code> in all calls to <code><a href="#topic+vegclust">vegclust</a></code>. If <code>method="NCdd"</code> or <code>method="HNCdd"</code> then <code>ini.fixed.centers</code> can be specified as a vector of indices for medoids.
</p>
</td></tr>
<tr><td><code id="incr.vegclust_+3A_min.size">min.size</code></td>
<td>

<p>The minimum size (cardinality) of clusters. If any of the current k clusters does not have enough members the algorithm will stop and return the solution with k-1 clusters.
</p>
</td></tr>
<tr><td><code id="incr.vegclust_+3A_max.var">max.var</code></td>
<td>

<p>The maximum variance allowed for clusters (see function <code><a href="#topic+clustvar">clustvar</a></code>). If specified, the algorithm will stop when any of the clusters is at the same time small and has large variance. If <code>max.var = NULL</code> then this criterion is not used.
</p>
</td></tr>
<tr><td><code id="incr.vegclust_+3A_alpha">alpha</code></td>
<td>

<p>Criterion to choose cluster seeds from the noise class. Specifically, an object is considered as cluster seed if the membership to the noise class is larger than <code>alpha</code>.
</p>
</td></tr>
<tr><td><code id="incr.vegclust_+3A_nstart">nstart</code></td>
<td>

<p>A number indicating how many random trials should be performed for number of groups. Each random trial uses the k-1 cluster centers plus the coordinates of the current cluster seed as initial solution for <code><a href="#topic+vegclust">vegclust</a></code>. Thus, if there are less cluster seed candidates than <code>nstart</code>, then not all runs are conducted.
</p>
</td></tr>
<tr><td><code id="incr.vegclust_+3A_fix.previous">fix.previous</code></td>
<td>

<p>Flag used to indicate that the cluster centers found when determining k-1 clusters are fixed when determining k clusters.
</p>
</td></tr>
<tr><td><code id="incr.vegclust_+3A_m">m</code></td>
<td>

<p>The fuzziness exponent.
</p>
</td></tr>
<tr><td><code id="incr.vegclust_+3A_dnoise">dnoise</code></td>
<td>

<p>The distance to the noise cluster. 
</p>
</td></tr>
<tr><td><code id="incr.vegclust_+3A_...">...</code></td>
<td>

<p>Additional parameters for function <code><a href="#topic+vegclust">vegclust</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>hier.vegclust</code> takes starting cluster configurations from cuts of a dendrogram given by object <code>hclust</code>. Function <code>random.vegclust</code> chooses random objects as cluster centroids and for each number of clusters performs <code>nstart</code> trials.
</p>


<h3>Value</h3>

<p>Returns an object of class <code><a href="#topic+vegclust">vegclust</a></code>; or <code>NULL</code> if the initial cluster does not contain enough members.
</p>


<h3>Author(s)</h3>

<p>Miquel De Cáceres, CREAF
</p>


<h3>References</h3>

<p>Davé, R. N. and R. Krishnapuram (1997) Robust clustering methods: a unified view. IEEE Transactions on Fuzzy Systems 5, 270-293.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vegclust">vegclust</a></code>,<code><a href="#topic+hier.vegclust">hier.vegclust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Loads data  
data(wetland)
  
## This equals the chord transformation 
## (see also \code{\link{decostand}} in package 'vegan')
wetland.chord = as.data.frame(sweep(as.matrix(wetland), 1,
                              sqrt(rowSums(as.matrix(wetland)^2)), "/"))

## Call incremental noise clustering 
wetland.nc = incr.vegclust(wetland.chord, method="NC", m = 1.2, dnoise=0.75, 
                           min.size=5)

## Inspect cluster sizes
print(wetland.nc$size)

</code></pre>

<hr>
<h2 id='interclustdist'>
Calculates the distance between pairs of cluster centroids 
</h2><span id='topic+interclustdist'></span>

<h3>Description</h3>

<p>Calculates the distance between pairs of cluster centroids, given a distance matrix and a cluster vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interclustdist(x, cluster)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interclustdist_+3A_x">x</code></td>
<td>

<p>A site-by-site data matrix or an object of class <code><a href="stats.html#topic+dist">dist</a></code> containing the distance values between pairs of sites (plot records).
</p>
</td></tr>
<tr><td><code id="interclustdist_+3A_cluster">cluster</code></td>
<td>

<p>A vector indicating the hard membership of each object in <code>x</code> to a set of groups. Can contain <code>NA</code> values.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="stats.html#topic+dist">dist</a></code> containing the distances between cluster centers.
</p>


<h3>Author(s)</h3>

<p>Miquel De Cáceres, CREAF
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##TO BE DONE##
</code></pre>

<hr>
<h2 id='medreg'>Regeneration of Mediterranean vegetation data set</h2><span id='topic+medreg'></span>

<h3>Description</h3>

<p>A stratified vegetation data set containing with several plot records laid to assess vegetation recovery three years after a wildfire. Collected in 2012 by Miquel De Caceres and Albert Petit in Horta de Sant Joan (Catalonia, Spain).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(medreg)</code></pre>


<h3>Format</h3>

<p>An object of class 'stratifiedvegdata' with 96 elements (plots), each of them consisting of a data.frame where rows correspond to species groups and columns correspond to vegetation strata. Abundance values are percentage cover.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CAP">CAP</a></code>, <code><a href="#topic+plot.CAP">plot.CAP</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(medreg)
</code></pre>

<hr>
<h2 id='plot.CAP'>
Draws cummulative abundance profiles
</h2><span id='topic+plot.CAP'></span><span id='topic+plot.stratifiedvegdata'></span>

<h3>Description</h3>

<p>Create plots used to inspect one or more cumulative abundance profiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CAP'
plot(x, sizes=NULL, species=NULL, plots=NULL, switchAxes=FALSE, 
                   add=FALSE, drawAxes = TRUE, xlab="", ylab="", type="s",...)
## S3 method for class 'stratifiedvegdata'
plot(x, sizes=NULL, species=NULL, plots=NULL, switchAxes=FALSE, 
                   add=FALSE, drawAxes = TRUE, xlab="", ylab="", type="s",...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.CAP_+3A_x">x</code></td>
<td>
<p>An object returned from function <code><a href="#topic+CAP">CAP</a></code> or an object of class <code>stratifiedvegdata</code> (see documentation for function <code><a href="#topic+stratifyvegdata">stratifyvegdata</a></code>).</p>
</td></tr>
<tr><td><code id="plot.CAP_+3A_sizes">sizes</code></td>
<td>
<p>A vector containing the size values associated to each size class. If <code>NULL</code> the y-axis will be defined using the size class order in <code>x</code>.</p>
</td></tr>
<tr><td><code id="plot.CAP_+3A_species">species</code></td>
<td>
<p>A vector of strings indicating the species whose profile is to be drawn. If <code>NULL</code> all species are plotted.</p>
</td></tr>
<tr><td><code id="plot.CAP_+3A_plots">plots</code></td>
<td>
<p>A vector indicating the plot records whose profile is to be drawn. Can be a <code>character</code> vector (for plot names), a <code>numeric</code> vector (for plot indices) or a <code>logical</code> vector (for TRUE/FALSE selection). If <code>NULL</code> all plot records are plotted.</p>
</td></tr>
<tr><td><code id="plot.CAP_+3A_switchaxes">switchAxes</code></td>
<td>
<p>A flag indicating whether ordinate and abscissa axes should be interchanged.</p>
</td></tr>
<tr><td><code id="plot.CAP_+3A_add">add</code></td>
<td>
<p>A flag indicating whether profiles should be drawn on top of current drawing area. If <code>add=FALSE</code> a new plot is created.</p>
</td></tr>
<tr><td><code id="plot.CAP_+3A_drawaxes">drawAxes</code></td>
<td>
<p>A flag indicating whether axes should be drawn.</p>
</td></tr>
<tr><td><code id="plot.CAP_+3A_xlab">xlab</code></td>
<td>
<p>String label for the x axis.</p>
</td></tr>
<tr><td><code id="plot.CAP_+3A_ylab">ylab</code></td>
<td>
<p>String label for the y axis.</p>
</td></tr>
<tr><td><code id="plot.CAP_+3A_type">type</code></td>
<td>
<p>Type of plot to be drawn (&quot;p&quot; for points, &quot;l&quot; for lines, &quot;s&quot; for steps, ...).</p>
</td></tr>
<tr><td><code id="plot.CAP_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Miquel De Cáceres, CREAF
</p>


<h3>References</h3>

<p>De Cáceres, M., Legendre, P. &amp; He, F. (2013) Dissimilarity measurements and the size structure of ecological communities. Methods in Ecology and Evolution 4: 1167-1177.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CAP">CAP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load stratified data
data(medreg)

## Check that 'medreg' has correct class
class(medreg)

## Create cumulative abundance profile (CAP) for each plot
medreg.CAP = CAP(medreg)

## Draw the stratified data and profile corresponding to the third plot
plot(medreg, plots="3")
plot(medreg.CAP, plots="3")

## Look at the plot and CAP of the same plot
medreg[["3"]]
medreg.CAP[["3"]]
</code></pre>

<hr>
<h2 id='plot.CAS'>
Draws a cummulative abundance surface
</h2><span id='topic+plot.CAS'></span>

<h3>Description</h3>

<p>Create plots used to inspect one or more cumulative abundance profiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CAS'
plot(x, plot=NULL, species=NULL, sizes1=NULL, sizes2 = NULL, 
                   palette = colorRampPalette(c( "light blue","light green","white", 
                   "yellow","orange","red")), zlim=NULL,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.CAS_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+CAS">CAS</a></code>.</p>
</td></tr>
<tr><td><code id="plot.CAS_+3A_plot">plot</code></td>
<td>
<p>A string indicating the plot record whose surface is to be drawn.</p>
</td></tr>
<tr><td><code id="plot.CAS_+3A_species">species</code></td>
<td>
<p>A string indicating the species whose profile is to be drawn.</p>
</td></tr>
<tr><td><code id="plot.CAS_+3A_sizes1">sizes1</code></td>
<td>
<p>A vector containing the size values associated to each primary size class. If <code>NULL</code> the x-axis will be defined using the primary size class order in <code>x</code>.</p>
</td></tr>
<tr><td><code id="plot.CAS_+3A_sizes2">sizes2</code></td>
<td>
<p>A vector containing the size values associated to each secondary size class. If <code>NULL</code> the y-axis will be defined using the secondary size class order in <code>x</code>.</p>
</td></tr>
<tr><td><code id="plot.CAS_+3A_palette">palette</code></td>
<td>
<p>Color palette for z values.</p>
</td></tr>
<tr><td><code id="plot.CAS_+3A_zlim">zlim</code></td>
<td>
<p>The limits for the z-axis.</p>
</td></tr>
<tr><td><code id="plot.CAS_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters for function <code><a href="graphics.html#topic+persp">persp</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Miquel De Cáceres, CREAF
</p>


<h3>References</h3>

<p>De Cáceres, M., Legendre, P. &amp; He, F. (2013) Dissimilarity measurements and the size structure of ecological communities. Methods in Ecology and Evolution 4: 1167-1177.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CAS">CAS</a></code>, <code><a href="graphics.html#topic+persp">persp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create synthetic tree data
pl = rep(1,100) # All trees in the same plot
sp = ifelse(runif(100)&gt;0.5,1,2) # Random species identity (species 1 or 2)
h=rgamma(100,10,2) # Heights (m)
d = rpois(100, lambda=h^2) # Diameters (cm)
m = data.frame(plot=pl,species=sp, height=h,diameter=d) 
m$ba = pi*(m$diameter/200)^2
print(head(m))

## Size classes
heights = seq(0,4, by=.25)^2 # Quadratic classes
diams = seq(0,130, by=5) # Linear classes

## Stratify tree data
X&lt;-stratifyvegdata(m, sizes1=heights, sizes2=diams, 
                   plotColumn = "plot", speciesColumn = "species", 
                   size1Column = "height", size2Column = "diameter", 
                   abundanceColumn = "ba")


## Build cummulative abundance surface
Y = CAS(X)

## Plot the surface of species '1' in plot '1' using heights and diameters
plot(Y, species=1, sizes1=heights[-1], xlab="height (m)", 
     ylab="diameter (cm)", sizes2=diams[-1], zlab="Basal area (m2)",
     zlim = c(0,6), main="Species 1")
</code></pre>

<hr>
<h2 id='plot.mvegclust'>
Plots clustering results 
</h2><span id='topic+plot.mvegclust'></span>

<h3>Description</h3>

<p>Create plots used to study vegclust clustering results for an increasing number of clusters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvegclust'
plot(x, type="hnc", excludeFixed=TRUE, verbose=FALSE, ylim=NULL, 
                         xlab=NULL, ylab=NULL, maxvar=0.6, minsize=20,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mvegclust_+3A_x">x</code></td>
<td>
<p>An object returned from functions <code><a href="#topic+hier.vegclust">hier.vegclust</a></code> or <code><a href="#topic+random.vegclust">random.vegclust</a></code>.</p>
</td></tr>
<tr><td><code id="plot.mvegclust_+3A_type">type</code></td>
<td>
<p>A string indicating the type of plot desired. Current accepted values are &quot;hnc&quot;,&quot;hmemb&quot;,&quot;var&quot;,&quot;hcs&quot; and &quot;valid&quot;.</p>
</td></tr>
<tr><td><code id="plot.mvegclust_+3A_excludefixed">excludeFixed</code></td>
<td>
<p>A flag to indicate whether clusters with fixed centroids should be excluded from plots.</p>
</td></tr>
<tr><td><code id="plot.mvegclust_+3A_verbose">verbose</code></td>
<td>
<p>A flag to print extra information.</p>
</td></tr>
<tr><td><code id="plot.mvegclust_+3A_ylim">ylim</code></td>
<td>
<p>A vector with the limits for the y axis.</p>
</td></tr>
<tr><td><code id="plot.mvegclust_+3A_xlab">xlab</code></td>
<td>
<p>String label for the x axis.</p>
</td></tr>
<tr><td><code id="plot.mvegclust_+3A_ylab">ylab</code></td>
<td>
<p>String label for the y axis.</p>
</td></tr>
<tr><td><code id="plot.mvegclust_+3A_maxvar">maxvar</code></td>
<td>
<p>Maximum cluster variance allowed for the <code>type="valid"</code> plot.</p>
</td></tr>
<tr><td><code id="plot.mvegclust_+3A_minsize">minsize</code></td>
<td>
<p>Minimum cluster size allowed for the <code>type="valid"</code> plot.</p>
</td></tr>
<tr><td><code id="plot.mvegclust_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Different information is returned depending on the type of plot chosen.
</p>


<h3>Author(s)</h3>

<p>Miquel De Cáceres, CREAF
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Loads data  
data(wetland)
  
## This equals the chord transformation 
## (see also \code{\link{decostand}} in package 'vegan')
wetland.chord = as.data.frame(sweep(as.matrix(wetland), 1, 
                              sqrt(rowSums(as.matrix(wetland)^2)), "/"))

## Create noise clustering from hierarchical clustering at different number of clusters
wetland.hc = hclust(dist(wetland.chord),method="ward") 
wetland.nc = hier.vegclust(wetland.chord, wetland.hc, cmin=2, cmax=5, m = 1.2, 
                           dnoise=0.75, method="NC")

## Plot changes in the number of objects falling into the noise cluster
plot(wetland.nc, type="hnc")

## Plots the number of objects falling into "true" clusters, 
## the number of objects considered intermediate, 
## and the number of objects falling into the noise
plot(wetland.nc, type="hmemb")

## Plot minimum, maximum and average cluster size
plot(wetland.nc, type="hcs")

## Plot minimum, maximum and average cluster variance
plot(wetland.nc, type="var")

## Plot number of groups with high variance, low membership or both
plot(wetland.nc, type="valid")
</code></pre>

<hr>
<h2 id='relate.levels'>
Relates two clustering level results.
</h2><span id='topic+relate.levels'></span>

<h3>Description</h3>

<p>Analyzes how lower level clusters are assigned into upper level ones. The analysis is made for several number of clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relate.levels(lower, upper, defuzzify = FALSE, excludeFixed = FALSE, verbose=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relate.levels_+3A_lower">lower</code></td>
<td>
<p> A list of objects of type <code><a href="#topic+vegclust">vegclust</a></code> or <code><a href="#topic+vegclass">vegclass</a></code> that represent classifications at a finer level of resolution.</p>
</td></tr>
<tr><td><code id="relate.levels_+3A_upper">upper</code></td>
<td>
<p> A list of objects of type <code><a href="#topic+vegclust">vegclust</a></code> or <code><a href="#topic+vegclass">vegclass</a></code> that represent classifications at an broader level of resolution.</p>
</td></tr>
<tr><td><code id="relate.levels_+3A_defuzzify">defuzzify</code></td>
<td>
<p> A logical flag used to indicate whether the result of calling <code><a href="#topic+crossmemb">crossmemb</a></code> should be deffuzified.</p>
</td></tr>
<tr><td><code id="relate.levels_+3A_excludefixed">excludeFixed</code></td>
<td>
<p>A logical used to indicate whether fixed clusters should be excluded from the comparison of levels.</p>
</td></tr>
<tr><td><code id="relate.levels_+3A_verbose">verbose</code></td>
<td>
<p> A flag used to ask for extra screen output.</p>
</td></tr>
<tr><td><code id="relate.levels_+3A_...">...</code></td>
<td>

<p>Additional parameters for function <code><a href="#topic+defuzzify">defuzzify</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each pair of <code>vegclust</code> (or <code>vegclass</code>) objects in <code>upper</code> and <code>lower</code>, the function calls function <code><a href="#topic+crossmemb">crossmemb</a></code> and then, if asked, deffuzifies the resulting memberships (by calling function <code><a href="#topic+defuzzify">defuzzify</a></code>) and several quantities are calculated (see 'value' section).
</p>


<h3>Value</h3>

<p>A list with several data frames (see below). In each of them, the rows are items of <code>upper</code> and columns are items of <code>lower</code>. The names of rows and columns are the number of clusters of each <code><a href="#topic+vegclust">vegclust</a></code> (or <code>vegclass</code>) object.
</p>
<table>
<tr><td><code>nnoise</code></td>
<td>
<p>The number of low level clusters that are assigned to the Noise class (for <code>upper</code> objects using Noise clustering). </p>
</td></tr>
<tr><td><code>maxnoise</code></td>
<td>
<p>The maximum membership value of low level clusters to the Noise class (for <code>upper</code> objects using Noise clustering). </p>
</td></tr>
<tr><td><code>minmaxall</code></td>
<td>
<p>The minimum value (across upper level clusters) of the maximum membership value observed among the lower level clusters. </p>
</td></tr>
<tr><td><code>minallsize</code></td>
<td>
<p>The minimum value (across upper level clusters) of the sum of membership values across lower level clusters. </p>
</td></tr>
<tr><td><code>empty</code></td>
<td>
<p>The number of upper level clusters (mobile or fixed) that do not have any member among the lower level clusters. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Miquel De Cáceres, CREAF
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vegclust">vegclust</a></code>, <code><a href="#topic+vegclass">vegclass</a></code>, <code><a href="#topic+defuzzify">defuzzify</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Loads data  
data(wetland)
  
## This equals the chord transformation 
## (see also  \code{\link{decostand}} in package vegan)
wetland.chord = as.data.frame(sweep(as.matrix(wetland), 1,
                              sqrt(rowSums(as.matrix(wetland)^2)), "/"))

## Create noise clustering from hierarchical clustering at different number of cluster
wetland.hc = hclust(dist(wetland.chord),method="ward") 
wetland.nc1 = hier.vegclust(wetland.chord, wetland.hc, cmin=2, cmax=6, m = 1.2, 
                            dnoise=0.75, method="NC")
wetland.nc2 = hier.vegclust(wetland.chord, wetland.hc, cmin=2, cmax=4, m = 1.2, 
                            dnoise=0.85, method="NC")

## Studies the assignment of levels
relate.levels(wetland.nc1, wetland.nc2, method="cut")
</code></pre>

<hr>
<h2 id='stratifyvegdata'>
Reshapes community data from individual into stratified form
</h2><span id='topic+stratifyvegdata'></span><span id='topic+as.stratifiedvegdata'></span>

<h3>Description</h3>

<p>Function <code>stratifyvegdata</code> reshapes individual abundance values into species abundance values per size class or combination of size classes. Function <code>as.stratifiedvegdata</code> checks if the input list has appropriate properties and turns it into an object of class '<code>stratifiedvegdata</code>'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stratifyvegdata(x, sizes1, sizes2 = NULL, treeSel=NULL, spcodes = NULL, 
                plotColumn="plot", speciesColumn = "species", 
                abundanceColumn="abundance", size1Column = "size", size2Column = NULL, 
                cumulative=FALSE, counts=FALSE, mergeSpecies=FALSE, verbose=FALSE)
as.stratifiedvegdata(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stratifyvegdata_+3A_x">x</code></td>
<td>
<p>A data frame containing individual plant data. Individuals are in rows, while measurements are in columns.</p>
</td></tr>
<tr><td><code id="stratifyvegdata_+3A_sizes1">sizes1</code></td>
<td>
<p>A numerical vector containing the breaks for primary size classes in ascending order.</p>
</td></tr>
<tr><td><code id="stratifyvegdata_+3A_sizes2">sizes2</code></td>
<td>
<p>A numerical vector containing the breaks for secondary size classes in ascending order.</p>
</td></tr>
<tr><td><code id="stratifyvegdata_+3A_treesel">treeSel</code></td>
<td>
<p>A logical vector specifying which rows in <code>x</code> to be used. By default (<code>treeSel = NULL</code>) all rows are taken.</p>
</td></tr>
<tr><td><code id="stratifyvegdata_+3A_spcodes">spcodes</code></td>
<td>
<p>A character vector indicating the codes of species to be used for stratification (species codes beyond those appearing in <code>x</code> are possible). If <code>spcodes = NULL</code> then all species in <code>x</code> are used.</p>
</td></tr>
<tr><td><code id="stratifyvegdata_+3A_plotcolumn">plotColumn</code></td>
<td>
<p>The name of the column in <code>x</code> that contains plot identifiers.</p>
</td></tr>
<tr><td><code id="stratifyvegdata_+3A_speciescolumn">speciesColumn</code></td>
<td>
<p>The name of the column in <code>x</code> that contains species names.</p>
</td></tr>
<tr><td><code id="stratifyvegdata_+3A_abundancecolumn">abundanceColumn</code></td>
<td>
<p>The name of the column in <code>x</code> that contains abundance values.</p>
</td></tr>
<tr><td><code id="stratifyvegdata_+3A_size1column">size1Column</code></td>
<td>
<p>The name of the column in <code>x</code> that contains values for primary size classes.</p>
</td></tr>
<tr><td><code id="stratifyvegdata_+3A_size2column">size2Column</code></td>
<td>
<p>The name of the column in <code>x</code> that contains values for secondary size classes.</p>
</td></tr>
<tr><td><code id="stratifyvegdata_+3A_cumulative">cumulative</code></td>
<td>
<p>A flag to indicate that cumulative abundance profiles or surfaces are desired.</p>
</td></tr>
<tr><td><code id="stratifyvegdata_+3A_counts">counts</code></td>
<td>
<p>A flag to indicate that the output should be individual counts instead of added abundance values.</p>
</td></tr>
<tr><td><code id="stratifyvegdata_+3A_mergespecies">mergeSpecies</code></td>
<td>
<p>A flag to indicate that species identity should be ignored. This leads to analyzing the structure of biomass disregarding species identity.</p>
</td></tr>
<tr><td><code id="stratifyvegdata_+3A_verbose">verbose</code></td>
<td>
<p>A logical flag to indicate extra output.</p>
</td></tr>
<tr><td><code id="stratifyvegdata_+3A_x">X</code></td>
<td>
<p>A list with as many elements as plot records. Each element should be of class 'matrix' or 'data.frame' with species in rows and strata in columns. Furthermore, the number of rows (species) and columns (strata) should be the same for all elements.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each individual (row) in <code>x</code>, <code>stratifyvegdata</code> assigns it to the size class (stratum) containing its size. The corresponding abundance value (e.g. crown cover) of the individual is added to the abundance of the corresponding species at the size class (stratum). If <code>sizes2</code> and <code>size2Column</code> are supplied, the function assigns each individual (row) in <code>x</code> to the combination of size classes (e.g. tree height and diameter). 
</p>


<h3>Value</h3>

<p>Both functions return an object of class '<code>stratifiedvegdata</code>', which is a list of matrices, one for each plot record. Each element (matrix) has as many rows as species and as many columns as size classes (i.e., as many as elements in vector <code>sizes1</code>). Columns are named starting with 'S' and continuing with the size class (stratum) number. If <code>mergeSpecies=TRUE</code> then all matrices have a single row (whose name is <code>"all"</code>). If <code>sizes2</code> and <code>size2Column</code> are supplied to <code>stratifyvegdata</code>, the function returns an object of class '<code>doublestratifiedvegdata</code>', which is a list of arrays, one for each plot record. Each element (array) has three dimensions corresponding to species, primary sizes (number of elements in in vector <code>sizes1</code>) and secondary sizes (number of elements in in vector <code>sizes2</code>). If <code>cumulative=TRUE</code> then the function returns cumulative abundances (see <code><a href="#topic+CAP">CAP</a></code> and <code><a href="#topic+CAS">CAS</a></code>).
</p>


<h3>Author(s)</h3>

<p>Miquel De Cáceres, CREAF.
</p>


<h3>References</h3>

<p>De Cáceres, M., Legendre, P. &amp; He, F. (2013) Dissimilarity measurements and the size structure of ecological communities. Methods in Ecology and Evolution 4: 1167-1177.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+reshape">reshape</a></code>, <code><a href="#topic+CAP">CAP</a></code>, <code><a href="#topic+CAS">CAS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load tree data
data(treedata)

## Inspect tree data
head(treedata)

## Define stratum thresholds (4 strata)
heights = seq(0,4, by=0.5)
diameters = seq(0,2, by=0.5)

## Stratify tree data using heights as structural variable
X = stratifyvegdata(treedata, sizes1=heights, plotColumn="plotID",
                    speciesColumn="species", size1Column="height", counts=TRUE)

## Inspect the second plot record
X[[2]]

## Stratify tree data using heights as structural variable and cover as abundance
Y = stratifyvegdata(treedata, sizes1=heights, plotColumn="plotID",
                    speciesColumn="species", size1Column="height", 
                    abundanceColumn="cover")
Y[[2]]

## Stratify tree data using heights and diameters as structural variables
Z = stratifyvegdata(treedata, sizes1=heights, sizes2=diameters, plotColumn="plotID",
                    speciesColumn="species", size1Column="height", size2Column="diam",
                    counts=TRUE)
Z[[2]]



</code></pre>

<hr>
<h2 id='treedata'>Synthetic vegetation data set with tree data</h2><span id='topic+treedata'></span>

<h3>Description</h3>

<p>A synthetic data set used to illustrate the stratification of data originally collected on an individual basis (e.g. forest inventory).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(treedata)</code></pre>


<h3>Format</h3>

<p>A data frame where each row corresponds to a different tree. Columns are plot code, species identity, tree height, tree diameter and cover value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stratifyvegdata">stratifyvegdata</a></code></p>

<hr>
<h2 id='vegclass'>
Classifies vegetation communities 
</h2><span id='topic+vegclass'></span>

<h3>Description</h3>

<p>Classifies vegetation communities into a previous fuzzy or hard classification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vegclass(y, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vegclass_+3A_y">y</code></td>
<td>

<p>An object of class <code><a href="#topic+vegclust">vegclust</a></code> that represents a previous knowledge.
</p>
</td></tr>
<tr><td><code id="vegclass_+3A_x">x</code></td>
<td>

<p>Community data to be classified, in form of a site by species matrix (if the vegclust object is in <code>raw</code> mode) or a data frame containing the distances between the new sites in rows and the old sites in columns (if the vegclust object is in <code>distance</code> mode).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the classification model specified in <code>y</code> to classify the communities (rows) in <code>x</code>. When vegclust is in <code>raw</code> mode, the function calls first to <code><a href="#topic+conformveg">conformveg</a></code> in order to cope with different sets of species. See the help of <code><a href="#topic+as.vegclust">as.vegclust</a></code> to see an example of <code>vegclass</code> with distance matrices.
</p>


<h3>Value</h3>

<p>Returns an object of type <code>vegclass</code> with the following items:
</p>
<table>
<tr><td><code>method</code></td>
<td>
<p>The clustering model used in <code>y</code></p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>The fuzziness exponent in <code>y</code></p>
</td></tr>
<tr><td><code>dnoise</code></td>
<td>
<p>The distance to the noise cluster used for noise clustering (models NC, NCdd, HNC, HNCdd). This is set to <code>NULL</code> for other models.</p>
</td></tr>
<tr><td><code>eta</code></td>
<td>
<p> The reference distance vector used for possibilistic clustering (models PCM and PCMdd). This is set to <code>NULL</code> for other models.</p>
</td></tr>
<tr><td><code>memb</code></td>
<td>
<p>The fuzzy membership matrix.</p>
</td></tr>
<tr><td><code>dist2clusters</code></td>
<td>
<p>The matrix of object distances to cluster centers.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Miquel De Cáceres, CREAF.
</p>


<h3>References</h3>

<p>Davé, R. N. and R. Krishnapuram (1997) Robust clustering methods: a unified view. IEEE Transactions on Fuzzy Systems 5, 270-293.
</p>
<p>Bezdek, J. C. (1981) Pattern recognition with fuzzy objective functions. Plenum Press, New York.
</p>
<p>Krishnapuram, R. and J. M. Keller. (1993) A possibilistic approach to clustering. IEEE transactions on fuzzy systems 1, 98-110.
</p>
<p>De Cáceres, M., Font, X, Oliva, F. (2010) The management of numerical vegetation classifications with fuzzy clustering methods [Related software]. Journal of Vegetation Science 21 (6): 1138-1151.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vegclust">vegclust</a></code>, <code><a href="#topic+as.vegclust">as.vegclust</a></code>, <code><a href="stats.html#topic+kmeans">kmeans</a></code>, <code><a href="#topic+conformveg">conformveg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Loads data (38 columns and 33 species)
data(wetland)
dim(wetland)
  
## This equals the chord transformation 
## (see also  \code{\link{decostand}} in package vegan)
wetland.chord = as.data.frame(sweep(as.matrix(wetland), 1, 
                              sqrt(rowSums(as.matrix(wetland)^2)), "/"))

## Splits wetland data into two matrices of 30x27 and 11x22
wetland.30 = wetland.chord[1:30,]
wetland.30 = wetland.30[,colSums(wetland.30)&gt;0]
dim(wetland.30)
wetland.11 = wetland.chord[31:41,]
wetland.11 = wetland.11[,colSums(wetland.11)&gt;0] 
dim(wetland.11)

## Create noise clustering with 3 clusters from the data set with 30 sites. 
wetland.30.nc = vegclust(wetland.30, mobileCenters=3, m = 1.2, dnoise=0.75,
                         method="NC", nstart=10)

## Cardinality of fuzzy clusters (i.e., the number of objects belonging to)
wetland.30.nc$size

## Classifies the second set of sites according to the clustering of the first set
wetland.11.nc = vegclass(wetland.30.nc, wetland.11)

## Fuzzy membership matrix
wetland.11.nc$memb

## Obtains hard membership vector, with 'N' for objects that are unclassified
defuzzify(wetland.11.nc$memb)$cluster

</code></pre>

<hr>
<h2 id='vegclust'>
Vegetation clustering methods
</h2><span id='topic+vegclust'></span><span id='topic+vegclustdist'></span>

<h3>Description</h3>

<p>Performs hard or fuzzy clustering of vegetation data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vegclust(x, mobileCenters, fixedCenters = NULL, method="NC", m = 2, dnoise = NULL, 
        eta = NULL, alpha=0.001, iter.max=100, nstart=1, maxminJ = 10, seeds=NULL, 
        verbose=FALSE)
vegclustdist(x, mobileMemb, fixedDistToCenters = NULL, method="NC", m = 2, dnoise = NULL, 
            eta = NULL, alpha=0.001, iter.max=100, nstart=1, seeds=NULL, verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vegclust_+3A_x">x</code></td>
<td>

<p>Community data. A site-by-species matrix or data frame (for <code>vegclust</code>) or a site-by-site dissimilarity matrix or <code><a href="stats.html#topic+dist">dist</a></code> object (for <code>vegclustdist</code>).
</p>
</td></tr>
<tr><td><code id="vegclust_+3A_mobilecenters">mobileCenters</code></td>
<td>

<p>A number, a vector of seeds, or coordinates for mobile clusters.
</p>
</td></tr>
<tr><td><code id="vegclust_+3A_fixedcenters">fixedCenters</code></td>
<td>

<p>A matrix or data frame with coordinates for fixed (non-mobile) clusters.
</p>
</td></tr>
<tr><td><code id="vegclust_+3A_mobilememb">mobileMemb</code></td>
<td>

<p>A number, a vector of seeds, or starting memberships for mobile clusters.
</p>
</td></tr>
<tr><td><code id="vegclust_+3A_fixeddisttocenters">fixedDistToCenters</code></td>
<td>

<p>A matrix or data frame with the distances to fixed cluster centers.
</p>
</td></tr>
<tr><td><code id="vegclust_+3A_method">method</code></td>
<td>

<p>A clustering model. Current accepted models are: 
</p>

<ul>
<li><p><code>"KM"</code>: K-means or hard c-means (MacQueen 1967)
</p>
</li>
<li><p><code>"KMdd"</code>: Hard c-medoids (Krishnapuram et al. 1999)
</p>
</li>
<li><p><code>"FCM"</code>: Fuzzy c-means (Bezdek 1981)
</p>
</li>
<li><p><code>"FCMdd"</code>: Fuzzy c-medoids (Krishnapuram et al. 1999)
</p>
</li>
<li><p><code>"NC"</code>: Noise clustering (Dave and Krishnapuram 1997)
</p>
</li>
<li><p><code>"NCdd"</code>: Noise clustering with medoids
</p>
</li>
<li><p><code>"HNC"</code>: Hard noise clustering
</p>
</li>
<li><p><code>"HNCdd"</code>: Hard noise clustering with medoids
</p>
</li>
<li><p><code>"PCM"</code>: Possibilistic c-means (Krishnapuram and Keller 1993)
</p>
</li>
<li><p><code>"PCMdd"</code>: Possibilistic c-medoids
</p>
</li></ul>

</td></tr>
<tr><td><code id="vegclust_+3A_m">m</code></td>
<td>

<p>The fuzziness exponent to be used (this is relevant for all models except for kmeans)
</p>
</td></tr>
<tr><td><code id="vegclust_+3A_dnoise">dnoise</code></td>
<td>

<p>The distance to the noise cluster, relevant for noise clustering (NC). 
</p>
</td></tr>
<tr><td><code id="vegclust_+3A_eta">eta</code></td>
<td>

<p>A vector of reference distances, relevant for possibilistic C-means (PCM). 
</p>
</td></tr>
<tr><td><code id="vegclust_+3A_alpha">alpha</code></td>
<td>

<p>Threshold used to stop iterations. The maximum difference in the membership matrix of the current vs. the previous iteration will be compared to this value.
</p>
</td></tr>
<tr><td><code id="vegclust_+3A_iter.max">iter.max</code></td>
<td>

<p>The maximum number of iterations allowed.
</p>
</td></tr>
<tr><td><code id="vegclust_+3A_nstart">nstart</code></td>
<td>

<p>If <code>mobileCenters</code> or <code>mobileMemb</code> is a number, how many random sets should be chosen?
</p>
</td></tr>
<tr><td><code id="vegclust_+3A_maxminj">maxminJ</code></td>
<td>

<p>When random starts are used, these will stop if at least <code>maxminJ</code> runs ended up in the same functional value.
</p>
</td></tr>
<tr><td><code id="vegclust_+3A_seeds">seeds</code></td>
<td>

<p>If <code>mobileCenters</code> or <code>mobileMemb</code> is a number, a vector indicating which objects are potential initial centers. If <code>NULL</code> all objects are valid seeds.
</p>
</td></tr>
<tr><td><code id="vegclust_+3A_verbose">verbose</code></td>
<td>

<p>Flag to print extra output.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions <code>vegclust</code> and <code>vegclustdist</code> try to generalize the <code><a href="stats.html#topic+kmeans">kmeans</a></code> function in <code>stats</code> in three ways. 
</p>
<p>Firstly, they allows different clustering models. Clustering models can be divided in (a) fuzzy or hard; (b) centroid-based or medoid-based; (c) Partitioning (KM and FCM family), noise clustering (NC family), and possibilistic clustering (PCM and PCMdd). The reader should refer to the original publications to better understand the differences between models. 
</p>
<p>Secondly, users can specify fixed clusters (that is, centroids that do not change their positions during iterations). Fixed clusters are intended to be used when some clusters were previously defined and new data has been collected. One may allow some of these new data points to form new clusters, while some other points will be assigned to the original clusters. In the case of models with cluster repulsion (such as KM, FCM or NC) the new (mobile) clusters are not allowed to 'push' the fixed ones. As a result, mobile clusters will occupy new regions of the reference space. 
</p>
<p>Thirdly, <code>vegclustdist</code> implements the distance-based equivalent of <code>vegclust</code>. The results of <code>vegclust</code> and <code>vegclustdist</code> will be the same (if seeds are equal) if the distance matrix is calculated using the Euclidean distance (see function <code><a href="stats.html#topic+dist">dist</a></code>). Otherwise, the equivalence holds by resorting on principal coordinates analysis.
</p>
<p>Note that all data frames or matrices used as input of <code>vegclust</code> should be defined on the same space of species (see <code><a href="#topic+conformveg">conformveg</a></code>). Unlike <code><a href="stats.html#topic+kmeans">kmeans</a></code>, which allows different specific algorithms, here updates of prototypes (centroids or medoids) are done after all objects have been reassigned (Forgy 1965). In order to obtain hard cluster definitions, users can apply the function <code><a href="#topic+defuzzify">defuzzify</a></code> to the <code>vegclust</code> object.
</p>


<h3>Value</h3>

<p>Returns an object of type <code>vegclust</code> with the following items:
</p>
<table>
<tr><td><code>mode</code></td>
<td>
<p><code>raw</code> for function <code>vegclust</code> and <code>dist</code> for function <code>vegclustdist</code>.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The clustering model used</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>The fuzziness exponent used (<code>m=1</code> in case of kmeans)</p>
</td></tr>
<tr><td><code>dnoise</code></td>
<td>
<p>The distance to the noise cluster used for noise clustering (NC, HNC, NCdd or HNCdd). This is set to <code>NULL</code> for other models.</p>
</td></tr>
<tr><td><code>eta</code></td>
<td>
<p> The reference distance vector used for possibilistic clustering (PCM or PCMdd). This is set to <code>NULL</code> for other models.</p>
</td></tr>
<tr><td><code>memb</code></td>
<td>
<p>The fuzzy membership matrix. Columns starting with &quot;M&quot; indicate mobile clusters, whereas columns starting with &quot;F&quot; indicate fixed clusters.</p>
</td></tr>
<tr><td><code>mobileCenters</code></td>
<td>
<p>If <code>vegclust</code> is used, this contains a data frame with the coordinates of the mobile centers (centroids or medoids). If <code>vegclustdist</code> is used, it will contain the indices of mobile medoids for models KMdd, FCMdd, HNCdd, NCdd and PCMdd; or <code>NULL</code> otherwise.</p>
</td></tr>
<tr><td><code>fixedCenters</code></td>
<td>
<p>If <code>vegclust</code> is used, this contains a data frame with the coordinates of the fixed centers (centroids or medoids). If <code>vegclustdist</code> is used, it will contain the indices of fixed medoids for models KMdd, FCMdd, HNCdd, NCdd and PCMdd; or <code>NULL</code> otherwise.</p>
</td></tr>
<tr><td><code>dist2clusters</code></td>
<td>
<p>The matrix of object distances to cluster centers. Columns starting with &quot;M&quot; indicate mobile clusters, whereas columns starting with &quot;F&quot; indicate fixed clusters.</p>
</td></tr>
<tr><td><code>withinss</code></td>
<td>
<p>In the case of methods KM, FCM, NC, PCM and HNC it contains the within-cluster sum of squares for each cluster (squared distances to cluster center weighted by membership). In the case of methods KMdd, FCMdd, NCdd, HNCdd and PCMdd it contains the sum of distances to each cluster (weighted by membership).</p>
</td></tr>
<tr><td><code>size</code></td>
<td>
<p>The number of objects belonging to each cluster. In case of fuzzy clusters the sum of memberships is given.</p>
</td></tr>
<tr><td><code>functional</code></td>
<td>
<p>The objective function value (the minimum value attained after all iterations).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Miquel De Cáceres, CREAF
</p>


<h3>References</h3>

<p>Forgy, E. W. (1965) Cluster analysis of multivariate data: efficiency vs interpretability of classifications. Biometrics 21, 768-769.
</p>
<p>MacQueen, J. (1967) Some methods for classification and analysis of multivariate observations. In Proceedings of the Fifth Berkeley Symposium on Mathematical Statistics and Probability, eds L. M. Le Cam and J. Neyman, 1, pp. 281-297. Berkeley, CA: University of California Press.
</p>
<p>Davé, R. N. and R. Krishnapuram (1997) Robust clustering methods: a unified view. IEEE Transactions on Fuzzy Systems 5, 270-293.
</p>
<p>Bezdek, J. C. (1981) Pattern recognition with fuzzy objective functions. Plenum Press, New York.
</p>
<p>Krishnapuram, R., Joshi, A., &amp; Yi, L. (1999). A Fuzzy relative of the k-medoids algorithm with application to web document and snippet clustering. IEEE International Fuzzy Systems (pp. 1281–1286). 
</p>
<p>Krishnapuram, R. and J. M. Keller. (1993) A possibilistic approach to clustering. IEEE transactions on fuzzy systems 1, 98-110.
</p>
<p>De Cáceres, M., Font, X, Oliva, F. (2010) The management of numerical vegetation classifications with fuzzy clustering methods. Journal of Vegetation Science 21 (6): 1138-1151.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hier.vegclust">hier.vegclust</a></code>,<code><a href="#topic+incr.vegclust">incr.vegclust</a></code>,<code><a href="stats.html#topic+kmeans">kmeans</a></code>,<code><a href="#topic+vegclass">vegclass</a></code>,<code><a href="#topic+defuzzify">defuzzify</a></code>,<code><a href="#topic+clustvar">clustvar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Loads data  
data(wetland)
  
## This equals the chord transformation 
## (see also 'decostand' in package vegan)
wetland.chord = as.data.frame(sweep(as.matrix(wetland), 1, 
                              sqrt(rowSums(as.matrix(wetland)^2)), "/"))

## Create noise clustering with 3 clusters. Perform 10 starts from random seeds 
## and keep the best solution
wetland.nc = vegclust(wetland.chord, mobileCenters=3, m = 1.2, dnoise=0.75, 
                      method="NC", nstart=10)

## Fuzzy membership matrix
wetland.nc$memb

## Cardinality of fuzzy clusters (i.e., the number of objects belonging to each cluster)
wetland.nc$size

## Obtains hard membership vector, with 'N' for objects that are unclassified
defuzzify(wetland.nc$memb)$cluster

## The same result is obtained with a matrix of chord distances
wetland.d = dist(wetland.chord)
wetland.d.nc = vegclustdist(wetland.d, mobileMemb=3, m = 1.2, dnoise=0.75, 
                            method="NC", nstart=10)
</code></pre>

<hr>
<h2 id='vegclust2kmeans'>
Reshapes as kmeans object
</h2><span id='topic+vegclust2kmeans'></span>

<h3>Description</h3>

<p>This function casts an object of class <code><a href="#topic+vegclust">vegclust</a></code> into an object of class <code><a href="stats.html#topic+kmeans">kmeans</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vegclust2kmeans(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vegclust2kmeans_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+vegclust">vegclust</a></code> to be casted, where <code>method="KM"</code> and <code>mode="raw"</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Miquel De Cáceres, CREAF
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vegclust">vegclust</a></code>, <code><a href="stats.html#topic+kmeans">kmeans</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Loads data  
data(wetland)
  
## This equals the chord transformation 
## (see also  \code{\link{decostand}} in package vegan)
wetland.chord = as.data.frame(sweep(as.matrix(wetland), 1, 
                              sqrt(rowSums(as.matrix(wetland)^2)), "/"))

## Create noise clustering with 3 clusters. Perform 10 starts from random seeds 
wetland.vc = vegclust(wetland.chord, mobileCenters=3, 
                      method="KM", nstart=10)

## Reshapes as kmeans object
wetland.km = vegclust2kmeans(wetland.vc)
wetland.km
</code></pre>

<hr>
<h2 id='vegclustIndex'>
Compute fuzzy evaluation statistics
</h2><span id='topic+vegclustIndex'></span>

<h3>Description</h3>

<p>Computes several evaluation statistics on the fuzzy clustering results on objects of class <code><a href="#topic+vegclust">vegclust</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vegclustIndex(y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vegclustIndex_+3A_y">y</code></td>
<td>

<p>An object of class <code><a href="#topic+vegclust">vegclust</a></code> or a membership matrix.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These statistics were conceived to be computed on fuzzy partitions, such as the ones coming from Fuzzy C-means (Bezdek 1981). Maximum values of PCN or minimum values of PEN can be used as criteria to choose the number of clusters. 
</p>


<h3>Value</h3>

<p>Returns an vector of four values: partition coefficient (PC), normalized partition coefficient (PCN), partition entropy (PE) and normalized partition entropy (PEN).
</p>


<h3>Author(s)</h3>

<p>Miquel De Cáceres, CREAF.
</p>


<h3>References</h3>

<p>Bezdek, J. C. (1981) Pattern recognition with fuzzy objective functions. Plenum Press, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vegclust">vegclust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Loads data  
data(wetland)
  
## This equals the chord transformation 
## (see also  \code{\link{decostand}} in package vegan)
wetland.chord = as.data.frame(sweep(as.matrix(wetland), 1, 
                              sqrt(rowSums(as.matrix(wetland)^2)), "/"))
                              
## Create noise clustering with 2, 3 and 4 clusters. Perform 10 starts from random seeds 
## and keep the best solutions
wetland.fcm2 = vegclust(wetland.chord, mobileCenters=2, m = 1.2, method="FCM", nstart=10)
wetland.fcm3 = vegclust(wetland.chord, mobileCenters=3, m = 1.2, method="FCM", nstart=10)
wetland.fcm4 = vegclust(wetland.chord, mobileCenters=4, m = 1.2, method="FCM", nstart=10)

## Compute statistics. Both PCN and PEN indicate that three groups are more advisable 
## than 2 or 4.
print(vegclustIndex(wetland.fcm2))
print(vegclustIndex(wetland.fcm3))
print(vegclustIndex(wetland.fcm4))

</code></pre>

<hr>
<h2 id='vegdiststruct'>
Structural and compositional dissimilarity
</h2><span id='topic+vegdiststruct'></span>

<h3>Description</h3>

<p>Function to calculate the dissimilarity between ecological communities taking into account both their composition and the size of organisms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vegdiststruct(x, y=NULL, paired=FALSE, type="cumulative", method="bray", 
              transform=NULL, classWeights=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vegdiststruct_+3A_x">x</code></td>
<td>
<p>A stratified vegetation data set (see function <code><a href="#topic+stratifyvegdata">stratifyvegdata</a></code>), a set of cummulative abundance profiles (see function <code><a href="#topic+CAP">CAP</a></code>) or a set of cummulative abundance surfaces (see function <code><a href="#topic+CAS">CAS</a></code>).</p>
</td></tr>
<tr><td><code id="vegdiststruct_+3A_y">y</code></td>
<td>
<p>A second stratified vegetation data set (see function <code><a href="#topic+stratifyvegdata">stratifyvegdata</a></code>), a second set of cummulative abundance profiles (see function <code><a href="#topic+CAP">CAP</a></code>) or a second set of cummulative abundance surfaces (see function <code><a href="#topic+CAS">CAS</a></code>) against which object <code>x</code> should be compared.</p>
</td></tr>
<tr><td><code id="vegdiststruct_+3A_paired">paired</code></td>
<td>
<p>Only relevant when <code>y != NULL</code>. If <code>paired = TRUE</code> pairwise comparisons are calculated between elements in <code>x</code> and <code>y</code> (and <code>x</code> and <code>y</code> need to be of the same length). If <code>paired = FALSE</code> then all objects in <code>x</code> are compared to all objects in <code>y</code>.</p>
</td></tr>
<tr><td><code id="vegdiststruct_+3A_type">type</code></td>
<td>
<p>Whether dissimilarities between pairs of sites should be calculated from differences in cummulative abundance (<code>"cumulative"</code>), in total abundance (<code>"total"</code>) or in volumes of cumulative abundance profiles (<code>"volume"</code>).</p>
</td></tr>
<tr><td><code id="vegdiststruct_+3A_method">method</code></td>
<td>
<p>The dissimilarity coefficient to calculate (see details).</p>
</td></tr>
<tr><td><code id="vegdiststruct_+3A_transform">transform</code></td>
<td>
<p>A function or the name of a function to be applied to each cumulative abundance value.</p>
</td></tr>
<tr><td><code id="vegdiststruct_+3A_classweights">classWeights</code></td>
<td>
<p>A numerical vector or a matrix containing the weight of each size class or combination of size classes (see functions <code><a href="#topic+CAP2matrix">CAP2matrix</a></code> and <code><a href="#topic+CAS2matrix">CAS2matrix</a></code>). If <code>NULL</code>, then the function assumes classes of equal weight.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The six different coefficients available are described in De Caceres et al. (2013): (1) <code>method="bray"</code> for percentage difference (alias Bray-Curtis dissimilarity); (2) <code>method="ruzicka"</code> for Ruzicka index (a generalization of Jaccard); (3) <code>method="kulczynski"</code> for the Kulczynski dissimilarity index; (4) <code>method="ochiai"</code> for the complement of a quantitative generalization of Ochiai index of similarity; (5) <code>method="canberra"</code> for the Canberra index (Adkins form); (6) <code>method="relman"</code> for the relativized Manhattan coefficient (Whittaker's index of association). Currently, the function also supports (7) <code>method="manhattan"</code> for the city block metric.
</p>


<h3>Value</h3>

<p>Returns an object of class '<code><a href="stats.html#topic+dist">dist</a></code>'.
</p>


<h3>Author(s)</h3>

<p>Miquel De Cáceres, CREAF.
</p>


<h3>References</h3>

<p>De Cáceres, M., Legendre, P. &amp; He, F. (2013) Dissimilarity measurements and the size structure of ecological communities. Methods in Ecology and Evolution 4: 1167-1177.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stratifyvegdata">stratifyvegdata</a></code>, <code><a href="vegan.html#topic+vegdist">vegdist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load stratified data
data(medreg)

## Check that 'medreg' has correct class
class(medreg)

## Create cumulative abundance profile (CAP) for each plot
medreg.CAP = CAP(medreg)

## Create dissimilarity (percentage difference) matrix using profiles
medreg.D = vegdiststruct(medreg, method="bray")

## Create dissimilarity (percentage difference) matrix using abundances
medreg.D2 = vegdiststruct(medreg, method="bray", type="total")

## Calculate correlation
cor(as.vector(medreg.D), as.vector(medreg.D2))

</code></pre>

<hr>
<h2 id='wetland'>Wetland vegetation data set</h2><span id='topic+wetland'></span>

<h3>Description</h3>

<p>Vegetation of the Adelaide river alluvial plain (Australia). This data set was published by Bowman &amp; Wilson (1987) and used in Dale (1988) to compare fuzzy classification approaches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wetland)</code></pre>


<h3>Format</h3>

<p>A data frame with 41 sites (rows) and 33 species (columns). Abundance values are represented in abundance classes.
</p>


<h3>Source</h3>

<p>Bowman, D. M. J. S. and B. A. Wilson. 1986. Wetland vegetation pattern on the Adelaide River flood plain, Northern Territory, Australia. Proceedings of the Royal Society of Queensland 97:69-77.
</p>


<h3>References</h3>

<p>Dale, M. B. 1988. Some fuzzy approaches to phytosociology. Ideals and instances. Folia geobotanica et phytotaxonomica 23:239-274.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wetland)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
