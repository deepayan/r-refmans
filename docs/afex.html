<!DOCTYPE html><html><head><title>Help for package afex</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {afex}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#afex_aov-methods'><p>Methods for afex_aov objects</p></a></li>
<li><a href='#afex_options'><p>Set/get global afex options</p></a></li>
<li><a href='#afex_plot'><p>m-way Plot with Error Bars and Raw Data</p></a></li>
<li><a href='#afex-package'><p>Analysis of Factorial Experiments</p></a></li>
<li><a href='#aov_car'><p>Convenient ANOVA estimation for factorial designs</p></a></li>
<li><a href='#compare.2.vectors'><p>Compare two vectors using various tests.</p></a></li>
<li><a href='#ems'><p>Expected values of mean squares for factorial designs</p>
</p>
<p>Implements the Cornfield-Tukey algorithm for deriving the expected values of the mean squares for factorial designs.</p></a></li>
<li><a href='#fhch2010'><p>Data from Freeman, Heathcote, Chalmers, &amp; Hockley (2010)</p></a></li>
<li><a href='#ks2013.3'><p>Data from Klauer &amp; Singmann (2013, Experiment 3)</p></a></li>
<li><a href='#laptop_urry'><p>Replication of Laptop Note Taking Study (Urry et al. 2021, Psych. Science)</p></a></li>
<li><a href='#md_12.1'><p>Data 12.1 from Maxwell &amp; Delaney</p></a></li>
<li><a href='#md_15.1'><p>Data 15.1 / 11.5 from Maxwell &amp; Delaney</p></a></li>
<li><a href='#md_16.1'><p>Data 16.1 / 10.9 from Maxwell &amp; Delaney</p></a></li>
<li><a href='#md_16.4'><p>Data 16.4 from Maxwell &amp; Delaney</p></a></li>
<li><a href='#mixed'><p>p-values for fixed effects of mixed-model via lme4::lmer()</p></a></li>
<li><a href='#nice'><p>Make nice ANOVA table for printing.</p></a></li>
<li><a href='#obk.long'><p>O'Brien Kaiser's Repeated-Measures Dataset with Covariate</p></a></li>
<li><a href='#predict.afex_aov'><p>Predict method for <code>afex_aov</code> objects</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#residuals.afex_aov'><p>Extract Residuals and Fitted Values from <code>afex_aov</code> objects</p></a></li>
<li><a href='#round_ps'><p>Helper functions for rounding p-values</p></a></li>
<li><a href='#set_sum_contrasts'><p>Set global contrasts</p></a></li>
<li><a href='#sk2011.1'><p>Data from Singmann &amp; Klauer (2011, Experiment 1)</p></a></li>
<li><a href='#sk2011.2'><p>Data from Singmann &amp; Klauer (2011, Experiment 2)</p></a></li>
<li><a href='#stroop'><p>Stroop data from Lin et al. (2020, Psych. Science)</p></a></li>
<li><a href='#test_levene'><p>Deprecated functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Analysis of Factorial Experiments</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), lme4 (&ge; 1.1-8)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>emmeans (&ge; 1.4), coin, xtable, parallel, plyr, optimx,
nloptr, knitr, rmarkdown, R.rsp, lattice, latticeExtra,
multcomp, testthat, mlmRev, dplyr, tidyr, dfoptim, Matrix,
psychTools, ggplot2, MEMSS, effects, carData, ggbeeswarm, nlme,
cowplot, jtools, ggpubr, ggpol, MASS, glmmTMB, brms, rstanarm,
statmod, performance (&ge; 0.7.2), see (&ge; 0.6.4), ez,
ggResidpanel, grid, vdiffr</td>
</tr>
<tr>
<td>Imports:</td>
<td>pbkrtest (&ge; 0.4-1), lmerTest (&ge; 3.0-0), car, reshape2,
stats, methods, utils</td>
</tr>
<tr>
<td>Description:</td>
<td>Convenience functions for analyzing factorial experiments using ANOVA or
         mixed models. aov_ez(), aov_car(), and aov_4() allow specification of
         between, within (i.e., repeated-measures), or mixed (i.e., split-plot) 
         ANOVAs for data in long format (i.e., one observation per row),
         automatically aggregating multiple observations per individual and cell 
         of the design. mixed() fits mixed models using lme4::lmer() and computes 
         p-values for all fixed effects using either Kenward-Roger or Satterthwaite 
         approximation for degrees of freedom (LMM only), parametric bootstrap 
         (LMMs and GLMMs), or likelihood ratio tests (LMMs and GLMMs). 
         afex_plot() provides a high-level interface for interaction or one-way 
         plots using ggplot2, combining raw data and model estimates. afex uses 
         type 3 sums of squares as default (imitating commercial statistical software).</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://afex.singmann.science/">https://afex.singmann.science/</a>, <a href="https://github.com/singmann/afex">https://github.com/singmann/afex</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/singmann/afex/issues">https://github.com/singmann/afex/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, R.rsp</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3-1</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-25 13:36:03 UTC; singm</td>
</tr>
<tr>
<td>Author:</td>
<td>Henrik Singmann <a href="https://orcid.org/0000-0002-4842-3657"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Ben Bolker [aut],
  Jake Westfall [aut],
  Frederik Aust <a href="https://orcid.org/0000-0003-4900-788X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Mattan S. Ben-Shachar [aut],
  Søren Højsgaard [ctb],
  John Fox [ctb],
  Michael A. Lawrence [ctb],
  Ulf Mertens [ctb],
  Jonathon Love [ctb],
  Russell Lenth [ctb],
  Rune Haubo Bojesen Christensen [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Henrik Singmann &lt;singmann@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-25 14:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='afex_aov-methods'>Methods for afex_aov objects</h2><span id='topic+afex_aov-methods'></span><span id='topic+anova.afex_aov'></span><span id='topic+print.afex_aov'></span><span id='topic+summary.afex_aov'></span><span id='topic+recover_data.afex_aov'></span><span id='topic+emm_basis.afex_aov'></span>

<h3>Description</h3>

<p>Methods defined for objects returned from the ANOVA functions
<code><a href="#topic+aov_car">aov_car</a></code> et al. of class <code>afex_aov</code> containing both the
ANOVA fitted via <code>car::Anova</code> and base R's <code>aov</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'afex_aov'
anova(
  object,
  es = afex_options("es_aov"),
  observed = NULL,
  correction = afex_options("correction_aov"),
  MSE = TRUE,
  intercept = FALSE,
  p_adjust_method = NULL,
  sig_symbols = attr(object$anova_table, "sig_symbols"),
  ...
)

## S3 method for class 'afex_aov'
print(x, ...)

## S3 method for class 'afex_aov'
summary(object, ...)

recover_data.afex_aov(object, ..., model = afex_options("emmeans_model"))

emm_basis.afex_aov(
  object,
  trms,
  xlev,
  grid,
  ...,
  model = afex_options("emmeans_model")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="afex_aov-methods_+3A_object">object</code>, <code id="afex_aov-methods_+3A_x">x</code></td>
<td>
<p>object of class <code>afex_aov</code> as returned from
<code><a href="#topic+aov_car">aov_car</a></code> and related functions.</p>
</td></tr>
<tr><td><code id="afex_aov-methods_+3A_es">es</code></td>
<td>
<p>Effect Size to be reported. The default is given by
<code>afex_options("es_aov")</code>, which is initially set to <code>"ges"</code>
(i.e., reporting generalized eta-squared, see details). Also supported is
partial eta-squared (<code>"pes"</code>) or <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="afex_aov-methods_+3A_observed">observed</code></td>
<td>
<p>character vector referring to the observed (i.e., non
manipulated) variables/effects in the design. Important for calculation of
generalized eta-squared (ignored if <code>es</code> is not <code>"ges"</code>), see
details.</p>
</td></tr>
<tr><td><code id="afex_aov-methods_+3A_correction">correction</code></td>
<td>
<p>Character. Which sphericity correction of the degrees of
freedom should be reported for the within-subject factors.  The default is
given by <code>afex_options("correction_aov")</code>, which is initially set to
<code>"GG"</code> corresponding to the Greenhouse-Geisser correction. Possible
values are <code>"GG"</code>, <code>"HF"</code> (i.e., Hyunh-Feldt correction), and
<code>"none"</code> (i.e., no correction).</p>
</td></tr>
<tr><td><code id="afex_aov-methods_+3A_mse">MSE</code></td>
<td>
<p>logical. Should the column containing the Mean Sqaured Error (MSE)
be displayed? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="afex_aov-methods_+3A_intercept">intercept</code></td>
<td>
<p>logical. Should intercept (if present) be included in the
ANOVA table? Default is <code>FALSE</code> which hides the intercept.</p>
</td></tr>
<tr><td><code id="afex_aov-methods_+3A_p_adjust_method">p_adjust_method</code></td>
<td>
<p><code>character</code> indicating if p-values for individual
effects should be adjusted for multiple comparisons (see
<a href="stats.html#topic+p.adjust">p.adjust</a> and details).</p>
</td></tr>
<tr><td><code id="afex_aov-methods_+3A_sig_symbols">sig_symbols</code></td>
<td>
<p>Character. What should be the symbols designating
significance? When entering an vector with <code>length(sig.symbol) &lt; 4</code>
only those elements of the default (<code>c(" +", " *", " **", " ***")</code>)
will be replaced. <code>sig_symbols = ""</code> will display the stars but not
the <code>+</code>, <code>sig_symbols = rep("", 4)</code> will display no symbols. The
default is given by <code>afex_options("sig_symbols")</code>.</p>
</td></tr>
<tr><td><code id="afex_aov-methods_+3A_...">...</code></td>
<td>
<p>further arguments passed through, see description of return value
for details.</p>
</td></tr>
<tr><td><code id="afex_aov-methods_+3A_model">model</code></td>
<td>
<p>argument for <code><a href="emmeans.html#topic+emmeans">emmeans</a>()</code> and related
functions that allows to choose on which model the follow-up tests for
ANOVAs with repeated-measures factors are based. <code>"multivariate"</code> (the
default) uses the <code>lm</code> model and <code>"univariate"</code> uses the
<code>aov</code> model. Default given by <code>afex_options("emmeans_mode")</code>.
Multivariate tests likely work better for unbalanced data and provide a
better correction for violations of sphericity.</p>
</td></tr>
<tr><td><code id="afex_aov-methods_+3A_trms">trms</code>, <code id="afex_aov-methods_+3A_xlev">xlev</code>, <code id="afex_aov-methods_+3A_grid">grid</code></td>
<td>
<p>same as for <code><a href="emmeans.html#topic+emm_basis">emm_basis</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Exploratory ANOVA, for which no detailed hypotheses have been specified a
priori, harbor a multiple comparison problem (Cramer et al., 2015). To avoid
an inflation of familywise Type I error rate, results need to be corrected
for multiple comparisons using <code>p_adjust_method</code>. <code>p_adjust_method</code>
defaults to the method specified in the call to <code><a href="#topic+aov_car">aov_car</a></code> in
<code>anova_table</code>. If no method was specified and <code>p_adjust_method =
NULL</code> p-values are not adjusted.
</p>


<h3>Value</h3>


<dl>
<dt><code>anova</code></dt><dd><p>Returns an ANOVA table of class <code>c("anova",
  "data.frame")</code>. Information such as effect size (<code>es</code>) or
df-correction are calculated each time this method is called.</p>
</dd>
<dt><code>summary</code></dt><dd><p>For ANOVAs containing within-subject factors it
returns the full output of the within-subject tests: the uncorrected
results, results containing Greenhousse-Geisser and Hyunh-Feldt correction,
and the results of the Mauchly test of sphericity (all achieved via
<code>summary.Anova.mlm</code>). For other ANOVAs, the <code>anova</code> table is
simply returned.</p>
</dd>
<dt><code>print</code></dt><dd><p>Prints (and invisibly returns) the ANOVA table as
constructed from <code><a href="#topic+nice">nice</a></code> (i.e., as strings rounded nicely).
Arguments in <code>...</code> are passed to <code>nice</code> allowing to pass
arguments such as <code>es</code> and <code>correction</code>.</p>
</dd>
<dt><code>recover_data</code> and <code>emm_basis</code></dt><dd><p>Provide the backbone for
using <code><a href="emmeans.html#topic+emmeans">emmeans</a></code> and related functions from
<span class="pkg">emmeans</span> directly on <code>afex_aov</code> objects by returning a
<code><a href="emmeans.html#topic+emmGrid-class">emmGrid-class</a></code> object. Should not be called directly
but through the functionality provided by <span class="pkg">emmeans</span>.</p>
</dd>
</dl>



<h3>References</h3>

<p>Cramer, A. O. J., van Ravenzwaaij, D., Matzke, D., Steingroever, H., Wetzels,
R., Grasman, R. P. P. P., ... Wagenmakers, E.-J. (2015). Hidden multiplicity
in exploratory multiway ANOVA: Prevalence and remedies.  <em>Psychonomic
Bulletin &amp; Review</em>, 1-8. <a href="https://doi.org/10.3758/s13423-015-0913-5">doi:10.3758/s13423-015-0913-5</a>
</p>


<h3>See Also</h3>

<p><code>residuals</code> and <code>fitted</code> methods also exists for
<code>afex_aov</code> objects, see: <code><a href="#topic+residuals.afex_aov">residuals.afex_aov</a></code>.
</p>

<hr>
<h2 id='afex_options'>Set/get global afex options</h2><span id='topic+afex_options'></span>

<h3>Description</h3>

<p>Global afex options are used, for example, by <code><a href="#topic+aov_car">aov_car</a></code> (et al.)
and <code><a href="#topic+mixed">mixed</a></code>. But can be changed in each functions directly using
an argument (which has precedence over the global options).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>afex_options(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="afex_options_+3A_...">...</code></td>
<td>
<p>One of four: (1) nothing, then returns all options as a list; (2)
a name of an option element, then returns its' value; (3) a name-value pair
which sets the corresponding option to the new value (and returns nothing),
(4) a list with option-value pairs which sets all the corresponding
arguments. The example show all possible cases.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following arguments are currently set:
</p>

<ul>
<li> <p><code>check_contrasts</code> should contrasts be checked and changed to
sum-to-zero contrasts? Default is <code>TRUE</code>.
</p>
</li>
<li> <p><code>type</code> type of sums-of-squares to be used for testing effects,
default is 3 which reports Type 3 tests.
</p>
</li>
<li> <p><code>method_mixed</code>: Method used to obtain p-values in
<code><a href="#topic+mixed">mixed</a></code>, default is <code>"KR"</code> (which will change to
<code>"LRT"</code> soon). (<code>mixed()</code> only)
</p>
</li>
<li> <p><code>es_aov</code>: Effect size reported for ANOVAs (see
<code><a href="#topic+aov_car">aov_car</a></code>), default is <code>"ges"</code> (generalized eta-squared).
</p>
</li>
<li> <p><code>correction_aov</code>: Correction used for within-subjects factors with
more than two levels for ANOVAs  (see <code><a href="#topic+aov_car">aov_car</a></code> or
<code><a href="#topic+nice">nice</a></code>), default is <code>"GG"</code> (Greenhouse-Geisser correction).
(ANOVA functions only)
</p>
</li>
<li> <p><code>emmeans_model</code>: Which model should be used by <span class="pkg">emmeans</span> for
follow-up analysis of ANOVAs (i.e., objects pf class <code>"afex_aov"</code>)?
Default is <code>"univariate"</code> which uses the <code>aov</code> model object (if
present). The other option is <code>"multivariate"</code> which uses the <code>lm</code>
model object (which is an object of class <code>"mlm"</code> in case
repeated-measures factors are present).
</p>
</li>
<li> <p><code>include_aov</code>: Should the <code>aov</code> model be included into ANOVA objects of class <code>"afex_aov"</code>? Setting this to <code>FALSE</code> can lead to considerable speed improvements.
</p>
</li>
<li> <p><code>factorize</code>: Should between subject factors be factorized (with
note) before running the analysis? Default is <code>TRUE</code>. (ANOVA functions
only)
</p>
</li>
<li> <p><code>sig_symbols</code>: Default significant symbols used for ANOVA and
<code>mixed</code> printing. Default is<code>c(" +", " *", " **", " ***")</code>.
</p>
</li>
<li> <p><code>lmer_function</code>: Which <code>lmer</code> function should <code>mixed</code> or
<code>lmer_alt</code> use. The default is <code>"lmerTest"</code> which uses
<code><a href="lmerTest.html#topic+lmer">lmer</a></code>, <code>"lme4"</code> is also possible which uses
<code><a href="lme4.html#topic+lmer">lmer</a></code>. Note that <code>mixed</code> methods <code>"KR"</code> and
<code>"S"</code> only work with <code>"lmerTest"</code>. For the other methods,
<code>"lme4"</code> could be minimally faster, but does not allow to use
<code>lmerTest::anova()</code>.
</p>
</li>
<li> <p><code>return_aov</code>: Return value of the ANOVA functions (see
<code><a href="#topic+aov_car">aov_car</a></code>), default is <code>"nice"</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>depends on input, see above.
</p>


<h3>Note</h3>

<p>All options are saved in the global R <code><a href="base.html#topic+options">options</a></code> with prefix
<code>afex.</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>afex_options() # see all options

afex_options("return_aov") #get single option

aop &lt;- afex_options() # save current options

## Not run: 
# change options
afex_options(return_aov = "nice")
afex_options("return_aov") #get single option
afex_options(return_aov = "nice", method_mixed = "LRT")
afex_options("method_mixed") #get single option
# do something

## End(Not run)
afex_options(aop) # reset options

</code></pre>

<hr>
<h2 id='afex_plot'>m-way Plot with Error Bars and Raw Data</h2><span id='topic+afex_plot'></span><span id='topic+afex_plot.afex_aov'></span><span id='topic+afex_plot.mixed'></span><span id='topic+afex_plot.merMod'></span><span id='topic+afex_plot.default'></span><span id='topic+interaction_plot'></span><span id='topic+oneway_plot'></span>

<h3>Description</h3>

<p>Plots results from factorial experiments. Estimated marginal 
means and error bars are plotted in the foreground, raw data is plotted in 
the background. Error bars can be based on different standard errors (e.g.,
model-based, within-subjects, between-subjects). Functions described here
return a <span class="pkg">ggplot2</span> plot object, thus allowing further customization of
the plot.
</p>
<p><code>afex_plot</code> is the user friendly function that does data preparation
and plotting. It also allows to only return the prepared data (<code>return
  = "data"</code>).
</p>
<p><code>interaction_plot</code> does the plotting when a <code>trace</code> factor is
present. <code>oneway_plot</code> does the plotting when a <code>trace</code> factor is
absent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>afex_plot(object, ...)

## S3 method for class 'afex_aov'
afex_plot(
  object,
  x,
  trace,
  panel,
  mapping,
  error = "model",
  error_ci = TRUE,
  error_level = 0.95,
  error_arg = list(width = 0),
  data_plot = TRUE,
  data_geom,
  data_alpha = 0.5,
  data_color = "darkgrey",
  data_arg = list(),
  point_arg = list(),
  line_arg = list(),
  emmeans_arg = list(),
  dodge = 0.5,
  return = "plot",
  factor_levels = list(),
  legend_title,
  ...
)

## S3 method for class 'mixed'
afex_plot(
  object,
  x,
  trace,
  panel,
  mapping,
  id,
  error = "model",
  error_ci = TRUE,
  error_level = 0.95,
  error_arg = list(width = 0),
  data_plot = TRUE,
  data_geom,
  data_alpha = 0.5,
  data_color = "darkgrey",
  data_arg = list(),
  point_arg = list(),
  line_arg = list(),
  emmeans_arg = list(),
  dodge = 0.5,
  return = "plot",
  factor_levels = list(),
  legend_title,
  ...
)

## S3 method for class 'merMod'
afex_plot(
  object,
  x,
  trace,
  panel,
  mapping,
  id,
  error = "model",
  error_ci = TRUE,
  error_level = 0.95,
  error_arg = list(width = 0),
  data_plot = TRUE,
  data_geom,
  data_alpha = 0.5,
  data_color = "darkgrey",
  data_arg = list(),
  point_arg = list(),
  line_arg = list(),
  emmeans_arg = list(),
  dodge = 0.5,
  return = "plot",
  factor_levels = list(),
  legend_title,
  ...
)

## Default S3 method:
afex_plot(
  object,
  x,
  trace,
  panel,
  mapping,
  id,
  dv,
  data,
  within_vars,
  between_vars,
  error = "model",
  error_ci = TRUE,
  error_level = 0.95,
  error_arg = list(width = 0),
  data_plot = TRUE,
  data_geom,
  data_alpha = 0.5,
  data_color = "darkgrey",
  data_arg = list(),
  point_arg = list(),
  line_arg = list(),
  emmeans_arg = list(),
  dodge = 0.5,
  return = "plot",
  factor_levels = list(),
  legend_title,
  ...
)

interaction_plot(
  means,
  data,
  mapping = c("shape", "lineytpe"),
  error_plot = TRUE,
  error_arg = list(width = 0),
  data_plot = TRUE,
  data_geom = ggplot2::geom_point,
  data_alpha = 0.5,
  data_color = "darkgrey",
  data_arg = list(),
  point_arg = list(),
  line_arg = list(),
  dodge = 0.5,
  legend_title,
  col_x = "x",
  col_y = "y",
  col_trace = "trace",
  col_panel = "panel",
  col_lower = "lower",
  col_upper = "upper"
)

oneway_plot(
  means,
  data,
  mapping = "",
  error_plot = TRUE,
  error_arg = list(width = 0),
  data_plot = TRUE,
  data_geom = ggbeeswarm::geom_beeswarm,
  data_alpha = 0.5,
  data_color = "darkgrey",
  data_arg = list(),
  point_arg = list(),
  legend_title,
  col_x = "x",
  col_y = "y",
  col_panel = "panel",
  col_lower = "lower",
  col_upper = "upper"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="afex_plot_+3A_object">object</code></td>
<td>
<p><code>afex_aov</code>, <code>mixed</code>, <code>merMod</code> or other model
object supported by <span class="pkg">emmeans</span> (for further examples see:
<code>vignette("afex_plot_supported_models")</code>).</p>
</td></tr>
<tr><td><code id="afex_plot_+3A_...">...</code></td>
<td>
<p>currently ignored.</p>
</td></tr>
<tr><td><code id="afex_plot_+3A_x">x</code></td>
<td>
<p>A <code>character</code> vector or one-sided <code>formula</code> specifying the
factor names of the predictors displayed on the x-axis. <code>mapping</code>
specifies further mappings for these factors if <code>trace</code> is missing.</p>
</td></tr>
<tr><td><code id="afex_plot_+3A_trace">trace</code></td>
<td>
<p>An optional <code>character</code> vector or one-sided <code>formula</code>
specifying the factor names of the predictors connected by the same line.
<code>mapping</code> specifies further mappings for these factors.</p>
</td></tr>
<tr><td><code id="afex_plot_+3A_panel">panel</code></td>
<td>
<p>An optional <code>character</code> vector or one-sided <code>formula</code> 
specifying the factor names of the predictors shown in different panels.</p>
</td></tr>
<tr><td><code id="afex_plot_+3A_mapping">mapping</code></td>
<td>
<p>A <code>character</code> vector specifying which aesthetic mappings 
should be applied to either the <code>trace</code> factors (if <code>trace</code> is 
specified) or the <code>x</code> factors. Useful options are any combination of 
<code>"shape"</code>, <code>"color"</code>, <code>"linetype"</code>, or also <code>"fill"</code> 
(see examples). The default (i.e., missing) uses <code>c("shape", 
"linetype")</code> if <code>trace</code> is specified and <code>""</code> otherwise (i.e., no
additional aesthetic). If specific mappings should not be applied to
specific graphical elements, one can override those via the corresponding
further arguments. For example, for <code>data_arg</code> the default is
<code>list(color = "darkgrey")</code> which prevents that <code>"color"</code> is
mapped onto points in the background.</p>
</td></tr>
<tr><td><code id="afex_plot_+3A_error">error</code></td>
<td>
<p>A scalar <code>character</code> vector specifying on which standard 
error the error bars should be based. Default is <code>"model"</code>, which
plots model-based standard errors. Further options are: <code>"none"</code> (or 
<code>NULL</code>), <code>"mean"</code>, <code>"within"</code> (or <code>"CMO"</code>), and 
<code>"between"</code>. See details.</p>
</td></tr>
<tr><td><code id="afex_plot_+3A_error_ci">error_ci</code></td>
<td>
<p>Logical. Should error bars plot confidence intervals
(=<code>TRUE</code>, the default) or standard errors (=<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="afex_plot_+3A_error_level">error_level</code></td>
<td>
<p>Numeric value between 0 and 1 determing the width of the
confidence interval. Default is .95 corresponding to a 95% confidence
interval.</p>
</td></tr>
<tr><td><code id="afex_plot_+3A_error_arg">error_arg</code></td>
<td>
<p>A <code>list</code> of further arguments passed to 
<code><a href="ggplot2.html#topic+geom_errorbar">geom_errorbar</a></code>, which draws the errorsbars. Default 
is <code>list(width = 0)</code> which suppresses the vertical bars at the end of 
the error bar.</p>
</td></tr>
<tr><td><code id="afex_plot_+3A_data_plot">data_plot</code></td>
<td>
<p><code>logical</code>. Should raw data be plotted in the 
background? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="afex_plot_+3A_data_geom">data_geom</code></td>
<td>
<p>Geom <code>function</code> or <code>list</code> of geom functions used
for plotting data in background. The default (missing) uses
<code><a href="ggplot2.html#topic+geom_point">geom_point</a></code> if <code>trace</code> is specified, otherwise
<code><a href="ggbeeswarm.html#topic+geom_beeswarm">geom_beeswarm</a></code> (a good alternative in case of many
data points is <code>ggbeeswarm::geom_quasirandom</code>) . See examples fo
further options.</p>
</td></tr>
<tr><td><code id="afex_plot_+3A_data_alpha">data_alpha</code></td>
<td>
<p>numeric <code>alpha</code> value between 0 and 1 passed to
<code>data_geom</code>. Default is <code>0.5</code> which correspond to semitransparent
data points in the background such that overlapping data points are plotted
darker. If <code>NULL</code> it is not passed to <code>data_geom</code>, and can be set
via <code>data_arg</code>.</p>
</td></tr>
<tr><td><code id="afex_plot_+3A_data_color">data_color</code></td>
<td>
<p>color that should be used for the data in the background.
Default is <code>"darkgrey"</code>. If <code>NULL</code> it is not passed to
<code>data_geom</code>, and can be set via <code>data_arg</code>. Ignored if
<code>"color"</code> or <code>"colour"</code> in <code>mapping</code>.</p>
</td></tr>
<tr><td><code id="afex_plot_+3A_data_arg">data_arg</code></td>
<td>
<p>A <code>list</code> of further arguments passed to
<code>data_geom</code>. Can also be a <code>list</code> of <code>list</code>s, in case
<code>data_geom</code> is a <code>list</code> of multiple geoms, which allows having
separate argument lists per <code>data_geom</code>.</p>
</td></tr>
<tr><td><code id="afex_plot_+3A_point_arg">point_arg</code>, <code id="afex_plot_+3A_line_arg">line_arg</code></td>
<td>
<p>A <code>list</code> of further arguments passed to 
<code><a href="ggplot2.html#topic+geom_point">geom_point</a></code> or <code><a href="ggplot2.html#topic+geom_line">geom_line</a></code> which
draw the points and lines in the foreground. Default is <code>list()</code>.
<code>line_arg</code> is only used if <code>trace</code> is specified.</p>
</td></tr>
<tr><td><code id="afex_plot_+3A_emmeans_arg">emmeans_arg</code></td>
<td>
<p>A <code>list</code> of further arguments passed to 
<code><a href="emmeans.html#topic+emmeans">emmeans</a></code>. Of particular importance for ANOVAs is 
<code>model</code>, see <code><a href="#topic+afex_aov-methods">afex_aov-methods</a></code>.</p>
</td></tr>
<tr><td><code id="afex_plot_+3A_dodge">dodge</code></td>
<td>
<p>Numerical amount of dodging of factor-levels on x-axis. Default 
is <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="afex_plot_+3A_return">return</code></td>
<td>
<p>A scalar <code>character</code> specifying what should be returned. 
The default <code>"plot"</code> returns the <span class="pkg">ggplot2</span> plot. The other option 
<code>"data"</code> returns a list with two <code>data.frame</code>s containing the 
data used for plotting: <code>means</code> contains the means and standard errors
for the foreground, <code>data</code> contains the raw data in the background.</p>
</td></tr>
<tr><td><code id="afex_plot_+3A_factor_levels">factor_levels</code></td>
<td>
<p>A <code>list</code> of new factor levels that should be used
in the plot. The name of each list entry needs to correspond to one of the
factors in the plot. Each list element can optionally be a named character
vector where the name corresponds to the old factor level and the value to
the new factor level. Named vectors allow two things: (1) updating only a
subset of factor levels (if only a subset of levels is specified) and (2)
reordering (and renaming) the factor levels, as order of names within a
list element are the order that will be used for plotting. If specified,
emits a <code>message</code> with <code>old -&gt; new</code> factor levels.</p>
</td></tr>
<tr><td><code id="afex_plot_+3A_legend_title">legend_title</code></td>
<td>
<p>A scalar <code>character</code> vector with a new title for the
legend.</p>
</td></tr>
<tr><td><code id="afex_plot_+3A_id">id</code></td>
<td>
<p>An optional <code>character</code> vector specifying over which variables
the raw data should be aggregated. Only relevant for <code>mixed</code>, 
<code>merMod</code>, and <code>default</code> method. The default (missing) uses all 
random effects grouping factors (for <code>mixed</code> and <code>merMod</code> method)
or assumes all data points are independent. This can lead to many data
points. <code>error = "within"</code> or <code>error = "between"</code> require that
<code>id</code> is of length 1. See examples.</p>
</td></tr>
<tr><td><code id="afex_plot_+3A_dv">dv</code></td>
<td>
<p>An optional scalar <code>character</code> vector giving the name of the
column containing the dependent variable for the <code>afex_plot.default</code>
method. If missing, the function attempts to take it from the <code>call</code>
slot of <code>object</code>. This is also used as y-axis label.</p>
</td></tr>
<tr><td><code id="afex_plot_+3A_data">data</code></td>
<td>
<p>For the <code>afex_plot.default</code> method, an optional
<code>data.frame</code> containing the raw data used for fitting the model and
which will be used as basis for the data points in the background. If
missing, it will be attempted to obtain it from the model via
<code><a href="emmeans.html#topic+recover_data">recover_data</a></code>. For the plotting functions, a
<code>data.frame</code> with the data that has to be passed and contains the
background data points.</p>
</td></tr>
<tr><td><code id="afex_plot_+3A_within_vars">within_vars</code>, <code id="afex_plot_+3A_between_vars">between_vars</code></td>
<td>
<p>For the <code>afex_plot.default</code> method, an
optional <code>character</code> vector specifying which variables should be
treated as within-subjects (or repeated-measures) factors and which as
between-subjects (or independen-sampels) factors. If one of the two
arguments is given, all other factors are assumed to fall into the other
category.</p>
</td></tr>
<tr><td><code id="afex_plot_+3A_means">means</code></td>
<td>
<p><code>data.frame</code>s used for plotting of the plotting
functions.</p>
</td></tr>
<tr><td><code id="afex_plot_+3A_error_plot">error_plot</code></td>
<td>
<p><code>logical</code>. Should error bars be plotted? Only used in 
plotting functions. To suppress plotting of error bars use <code>error =
"none"</code> in <code>afex_plot</code>.</p>
</td></tr>
<tr><td><code id="afex_plot_+3A_col_y">col_y</code>, <code id="afex_plot_+3A_col_x">col_x</code>, <code id="afex_plot_+3A_col_trace">col_trace</code>, <code id="afex_plot_+3A_col_panel">col_panel</code></td>
<td>
<p>A scalar <code>character</code> string 
specifying the name of the corresponding column containing the information
used for plotting. Each column needs to exist in both the <code>means</code> and
the <code>data</code> <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="afex_plot_+3A_col_lower">col_lower</code>, <code id="afex_plot_+3A_col_upper">col_upper</code></td>
<td>
<p>A scalar <code>character</code> string specifying the 
name of the columns containing lower and upper bounds for the error bars. 
These columns need to exist in <code>means</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>afex_plot</code> obtains the estimated marginal means via 
<code><a href="emmeans.html#topic+emmeans">emmeans</a></code> and aggregates the raw data to the same 
level. It then calculates the desired confidence interval or standard error
(see below) and passes the prepared data to one of the two plotting
functions: <code>interaction_plot</code> when <code>trace</code> is specified and 
<code>oneway_plot</code> otherwise.
</p>


<h4>Error Bars</h4>

<p>Error bars provide a grahical representation of the
variability of the estimated means and should be routinely added to results
figures. However, there exist several possibilities which particular 
measure of variability to use. Because of this, any figure depicting error 
bars should be accompanied by a note detailing which measure the error bars
shows. The present functions allow plotting of different types of
confidence intervals (if <code>error_ci = TRUE</code>, the default) or standard 
errors (if <code>error_ci = FALSE</code>).
</p>
<p>A further complication is that readers routinely misinterpret confidence
intervals. The most common error is to assume that non-overlapping error
bars indicate a significant difference (e.g., Belia et al., 2005). This is
often too strong an assumption. (see e.g., Cumming &amp; Finch, 2005; Knol et
al., 2011; Schenker &amp; Gentleman, 2005). For example, in a fully
between-subjects design in which the error bars depict 95% confidence
intervals and groups are of approximately equal size and have equal
variance, even error bars that overlap by as much as 50% still correspond
to <em>p</em> &lt; .05. Error bars that are just touching roughly correspond to
<em>p</em> = .01.
</p>
<p>In the case of designs involving repeated-measures factors the usual
confidence intervals or standard errors (i.e., model-based confidence
intervals or intervals based on the standard error of the mean) cannot be
used to gauge significant differences as this requires knowledge about the
correlation between measures. One popular alternative in the psychological
literature are intervals based on within-subjects standard
errors/confidence intervals (e.g., Cousineau &amp; O'Brien, 2014). These
attempt to control for the correlation across individuals and thereby allow
judging differences between repeated-measures condition. As a downside,
when using within-subjects intervals no comparisons across between-subjects
conditions or with respect to a fixed-value are possible anymore.
</p>
<p>In the case of a mixed-design, no single type of error bar is possible that
allows comparison across all conditions. Likewise, for mixed models
involving multiple <em>crossed</em> random effects, no single set of error
bars (or even data aggregation) adequately represent the true varibility in
the data and adequately allows for &quot;inference by eye&quot;. Therefore, special
care is necessary in such cases. One possiblity is to avoid error bars
altogether and plot only the raw data in the background (with <code>error =
  "none"</code>). The raw data in the background still provides a visual impression
of the variability in the data and the precision of the mean estimate, but
does not as easily suggest an incorrect inferences. Another possibility is
to use the model-based standard error and note in the figure caption that
it does not permit comparisons across repeated-measures factors.
</p>
<p>The following &quot;rules of eye&quot; (Cumming and Finch, 2005) hold, when permitted
by design (i.e., within-subjects bars for within-subjects comparisons;
other variants for between-subjects comparisons), and groups are
approximately equal in size and variance. Note that for more complex
designs ususally analyzed with mixed models, such as designs involving
complicated dependencies across data points, these rules of thumbs may be
highly misleading.
</p>

<ul>
<li>  <p><em>p</em> &lt; .05 when the overlap of the 95% confidence intervals
(CIs) is no more than about half the average margin of error, that is,
when proportion overlap is about .50 or less.
</p>
</li>
<li> <p><em>p</em> &lt; .01 when the two CIs do not overlap, that is, when
proportion overlap is about 0 or there is a positive gap.
</p>
</li>
<li>  <p><em>p</em> &lt; .05 when the gap between standard error (SE) bars is at
least about the size of the average SE, that is, when the proportion gap
is about 1 or greater.
</p>
</li>
<li> <p><em>p</em> &lt; .01 when the proportion gap between SE bars is about 2
or more.
</p>
</li></ul>
   



<h4>Implemented Standard Errors</h4>

<p>The following lists the 
implemented approaches to calculate confidence intervals (CIs) and standard
errors (SEs). CIs are based on the SEs using the <em>t</em>-distribution with
degrees of freedom based on the cell or group size. For ANOVA models,
<code>afex_plot</code> attempts to warn in case the chosen approach is misleading
given the design (e.g., model-based error bars for purely
within-subjects plots). For <code>mixed</code> models, no such warnings are
produced, but users should be aware that all options beside <code>"model"</code>
are not actually appropriate and have only heuristic value. But then again,
<code>"model"</code> based error bars do not permit comparisons for factors
varying within one of the random-effects grouping factors (i.e., factors
for which random-slopes should be estimated).
</p>

<dl>
<dt><code>"model"</code></dt><dd><p>Uses model-based CIs and SEs. For ANOVAs, the
variant based on the <code>lm</code> or <code>mlm</code> model (i.e.,
<code>emmeans_arg = list(model = "multivariate")</code>) seems generally
preferrable.</p>
</dd>
<dt><code>"mean"</code></dt><dd><p>Calculates the standard error of the mean for
each cell ignoring any repeated-measures factors.</p>
</dd>
<dt><code>"within"</code> or <code>"CMO"</code></dt><dd><p>Calculates within-subjects SEs
using the Cosineau-Morey-O'Brien (Cousineau &amp; O'Brien, 2014) method. This
method is based on a double normalization of the data. SEs and CIs are
then calculated independently for each cell (i.e., if the desired output
contains between-subjects factors, SEs are calculated for each cell
including the between-subjects factors).</p>
</dd>
<dt><code>"between"</code></dt><dd><p>First aggregates the data per participant and 
then calculates the SEs for each between-subjects condition. Results in 
one SE and <em>t</em>-quantile for all conditions in purely within-subjects
designs.</p>
</dd>
<dt><code>"none"</code> or <code>NULL</code></dt><dd><p>Suppresses calculation of SEs and
plots no error bars.</p>
</dd>
</dl>

<p>For <code>mixed</code> models, the within-subjects/repeated-measures factors are
relative to the chosen <code>id</code> effects grouping factor. They are
automatically detected based on the random-slopes of the random-effects
grouping factor in <code>id</code>. All other factors are treated as
independent-samples or between-subjects factors.
</p>



<h3>Value</h3>

<p>Returns a <span class="pkg">ggplot2</span> plot (i.e., object of class <code>c("gg",
  "ggplot")</code>) unless <code>return = "data"</code>.
</p>


<h3>Note</h3>

<p>Only the DV/response variable can be called <code>y</code>, but no
factor/variable used for plotting.
</p>


<h3>References</h3>

<p>Belia, S., Fidler, F., Williams, J., &amp; Cumming, G. (2005).
Researchers Misunderstand Confidence Intervals and Standard Error Bars.
<em>Psychological Methods</em>, 10(4), 389-396.
https://doi.org/10.1037/1082-989X.10.4.389
</p>
<p>Cousineau, D., &amp; O'Brien, F. (2014). Error bars in within-subject designs:
a comment on Baguley (2012). <em>Behavior Research Methods</em>, 46(4),
1149-1151. https://doi.org/10.3758/s13428-013-0441-z
</p>
<p>Cumming, G., &amp; Finch, S. (2005). Inference by Eye: Confidence Intervals and
How to Read Pictures of Data. <em>American Psychologist</em>, 60(2), 170-180.
https://doi.org/10.1037/0003-066X.60.2.170
</p>
<p>Knol, M. J., Pestman, W. R., &amp; Grobbee, D. E. (2011). The (mis)use of
overlap of confidence intervals to assess effect modification.
<em>European Journal of Epidemiology</em>, 26(4), 253-254.
https://doi.org/10.1007/s10654-011-9563-8
</p>
<p>Schenker, N., &amp; Gentleman, J. F. (2001). On Judging the Significance of
Differences by Examining the Overlap Between Confidence Intervals.
<em>The American Statistician</em>, 55(3), 182-186.
https://doi.org/10.1198/000313001317097960
</p>


<h3>Examples</h3>

<pre><code class='language-R'># note: use library("ggplot") to avoid "ggplot2::" in the following

##################################################################
##                2-factor Within-Subject Design                ##
##################################################################

data(md_12.1)
aw &lt;- aov_ez("id", "rt", md_12.1, within = c("angle", "noise"))

##---------------------------------------------------------------
##                    Basic Interaction Plots                   -
##---------------------------------------------------------------

## all examples require emmeans and ggplot2:
if (requireNamespace("emmeans") &amp;&amp; requireNamespace("ggplot2")) {

afex_plot(aw, x = "angle", trace = "noise") 
# or: afex_plot(aw, x = ~angle, trace = ~noise)

afex_plot(aw, x = "noise", trace = "angle")

### For within-subject designs, using within-subject CIs is better:
afex_plot(aw, x = "angle", trace = "noise", error = "within") 
(p1 &lt;- afex_plot(aw, x = "noise", trace = "angle", error = "within"))

## use different themes for nicer graphs:
p1 + ggplot2::theme_bw()
}
## Not run: 
p1 + ggplot2::theme_light()
p1 + ggplot2::theme_minimal()
p1 + jtools::theme_apa()
p1 + ggpubr::theme_pubr()

### set theme globally for R session:
ggplot2::theme_set(ggplot2::theme_bw())

### There are several ways to deal with overlapping points in the background besides alpha
# Using the default data geom and ggplot2::position_jitterdodge
afex_plot(aw, x = "noise", trace = "angle", error = "within", dodge = 0.3,
          data_arg = list(
            position = 
              ggplot2::position_jitterdodge(
                jitter.width = 0, 
                jitter.height = 5, 
                dodge.width = 0.3  ## needs to be same as dodge
                )))

# Overlapping points are shown as larger points using geom_count
afex_plot(aw, x = "noise", trace = "angle", error = "within", dodge = 0.5,
                data_geom = ggplot2::geom_count)

# Using ggbeeswarm::geom_quasirandom (overlapping points shown in violin shape)
afex_plot(aw, x = "noise", trace = "angle", error = "within", dodge = 0.5,
          data_geom = ggbeeswarm::geom_quasirandom,
          data_arg = list(
            dodge.width = 0.5,  ## needs to be same as dodge
            cex = 0.8, 
            width = 0.05  ## small value ensure data points match means
            ))

# Using ggbeeswarm::geom_beeswarm (overlapping points are adjacent on y-axis)
afex_plot(aw, x = "noise", trace = "angle", error = "within", dodge = 0.5,
          data_geom = ggbeeswarm::geom_beeswarm,
          data_arg = list(
            dodge.width = 0.5,  ## needs to be same as dodge
            cex = 0.8))

# Do not display points, but use a violinplot: ggplot2::geom_violin
afex_plot(aw, x = "noise", trace = "angle", error = "within", 
          data_geom = ggplot2::geom_violin, 
          data_arg = list(width = 0.5))

# violinplots with color: ggplot2::geom_violin
afex_plot(aw, x = "noise", trace = "angle", error = "within", 
          mapping = c("linetype", "shape", "fill"),
          data_geom = ggplot2::geom_violin, 
          data_arg = list(width = 0.5))

# do not display points, but use a boxplot: ggplot2::geom_boxplot
afex_plot(aw, x = "noise", trace = "angle", error = "within", 
          data_geom = ggplot2::geom_boxplot, 
          data_arg = list(width = 0.3))
          
# combine points with boxplot: ggpol::geom_boxjitter
afex_plot(aw, x = "noise", trace = "angle", error = "within", 
          data_geom = ggpol::geom_boxjitter, 
          data_arg = list(width = 0.3))
## hides error bars!

# nicer variant of ggpol::geom_boxjitter
afex_plot(aw, x = "noise", trace = "angle", error = "within", 
          mapping = c("shape", "fill"),
          data_geom = ggpol::geom_boxjitter, 
          data_arg = list(
            width = 0.3, 
            jitter.params = list(width = 0, height = 10),
            outlier.intersect = TRUE),
          point_arg = list(size = 2.5), 
          error_arg = list(linewidth = 1.5, width = 0))

# nicer variant of ggpol::geom_boxjitter without lines
afex_plot(aw, x = "noise", trace = "angle", error = "within", dodge = 0.7,
          mapping = c("shape", "fill"),
          data_geom = ggpol::geom_boxjitter, 
          data_arg = list(
            width = 0.5, 
            jitter.params = list(width = 0, height = 10),
            outlier.intersect = TRUE),
          point_arg = list(size = 2.5), 
          line_arg = list(linetype = 0),
          error_arg = list(linewidth = 1.5, width = 0))

### we can also use multiple geoms for the background by passing a list of geoms
afex_plot(aw, x = "noise", trace = "angle", error = "within", 
          data_geom = list(
            ggplot2::geom_violin, 
            ggplot2::geom_point
          ))

## with separate extra arguments:

afex_plot(aw, x = "noise", trace = "angle", error = "within", 
          dodge = 0.5,
          data_geom = list(
            ggplot2::geom_violin, 
            ggplot2::geom_point
          ), 
          data_arg = list(
            list(width = 0.4),
            list(position = 
                   ggplot2::position_jitterdodge(
                     jitter.width = 0, 
                     jitter.height = 5, 
                     dodge.width = 0.5  ## needs to be same as dodge
                   )))
          )

## End(Not run)


##---------------------------------------------------------------
##                        One-Way Plots                         -
##---------------------------------------------------------------

## Not run: 
afex_plot(aw, x = "angle", error = "within") ## default

## with color we need larger points
afex_plot(aw, x = "angle", mapping = "color", error = "within", 
          point_arg = list(size = 2.5), 
          error_arg = list(linewidth = 1.5, width = 0.05)) 

afex_plot(aw, x = "angle", error = "within", data_geom = ggpol::geom_boxjitter)

## nicer
afex_plot(aw, x = "angle", error = "within", data_geom = ggpol::geom_boxjitter, 
          mapping = "fill", data_alpha = 0.7, 
          data_arg = list(
            width = 0.6, 
            jitter.params = list(width = 0.07, height = 10),
            outlier.intersect = TRUE
          ),
          point_arg = list(size = 2.5), 
          error_arg = list(linewidth = 1.5, width = 0.05))

## we can use multiple geoms with separate argument lists:
afex_plot(aw, x = "angle", error = "within", 
          data_geom = 
            list(ggplot2::geom_violin, ggplot2::geom_boxplot), 
          data_arg = 
            list(list(width = 0.7), list(width = 0.1)))

## we can add a line connecting the means using geom_point(aes(group = 1)):
afex_plot(aw, x = "angle", error = "within") +
  ggplot2::geom_line(ggplot2::aes(group = 1))

## we can also add lines connecting the individual data-point in the bg.
# to deal with overlapping points, we use geom_count and make means larger
afex_plot(aw, x = "angle", error = "within", 
          data_geom = list(ggplot2::geom_count, ggplot2::geom_line), 
          data_arg = list(list(), list(mapping = ggplot2::aes(group = id))), 
          point_arg = list(size = 2.5), 
          error_arg = list(width = 0, linewidth = 1.5)) +
  ggplot2::geom_line(ggplot2::aes(group = 1), linewidth = 1.5)

## One-way plots also supports panels:
afex_plot(aw, x = "angle", panel = "noise", error = "within")

## And panels with lines:
afex_plot(aw, x = "angle", panel = "noise", error = "within") +
  ggplot2::geom_line(ggplot2::aes(group = 1))


## For more complicated plots it is easier to attach ggplot2:
library("ggplot2")

## We can hide geoms by plotting them in transparent colour and add them
## afterward to use a mapping not directly supported. 
## For example, the next plot adds a line to a one-way plot with panels, but 
## with all geoms in the foreground having a colour conditional on the panel.

afex_plot(aw, x = "angle", panel = "noise", error = "within", 
          point_arg = list(color = "transparent"), 
          error_arg = list(color = "transparent")) +
  geom_point(aes(color = panel)) +
  geom_linerange(aes(color = panel, ymin = lower, ymax = upper)) + 
  geom_line(aes(group = 1, color = panel)) +
  guides(color = guide_legend(title = "NOISE"))
## Note that we need to use guides explicitly, otherwise the legend title would 
## be "panel". legend_title does not work in this case.

##---------------------------------------------------------------
##                      Other Basic Options                     -
##---------------------------------------------------------------

## relabel factor levels via factor_levels (with message)
afex_plot(aw, x = "noise", trace = "angle", 
          factor_levels = list(angle = c("0°", "4°", "8°"),
                               noise = c("Absent", "Present")))

## factor_levels allows named vectors which enable reordering the factor levels 
### and renaming subsets of levels:
afex_plot(aw, x = "noise", trace = "angle", 
          factor_levels = list(
            angle = c(X8 = "8°", X4 = "4°", X0 = "0°"),
            noise = c(present = "Present")
          )
)


## Change title of legend
afex_plot(aw, x = "noise", trace = "angle", 
          legend_title = "Noise Condition")

## for plots with few factor levels, smaller dodge might be better:
afex_plot(aw, x = "angle", trace = "noise", dodge = 0.25) 

#################################################################
##                    4-factor Mixed Design                    ##
#################################################################

data(obk.long, package = "afex")
a1 &lt;- aov_car(value ~ treatment * gender + Error(id/(phase*hour)), 
              data = obk.long, observed = "gender")

## too difficult to see anything
afex_plot(a1, ~phase*hour, ~treatment) +
  ggplot2::theme_light()

## better
afex_plot(a1, ~hour, ~treatment, ~phase) +
  ggplot2::theme_light()

## even better
afex_plot(a1, ~hour, ~treatment, ~phase, 
          dodge = 0.65, 
          data_arg = list(
            position = 
              ggplot2::position_jitterdodge(
                jitter.width = 0, 
                jitter.height = 0.2, 
                dodge.width = 0.65  ## needs to be same as dodge
                ),
            color = "darkgrey")) +
  ggplot2::theme_classic()

# with color instead of linetype to separate trace factor
afex_plot(a1, ~hour, ~treatment, ~phase, 
          mapping = c("shape", "color"),
          dodge = 0.65, 
          data_arg = list(
            position = 
              ggplot2::position_jitterdodge(
                jitter.width = 0, 
                jitter.height = 0.2, 
                dodge.width = 0.65  ## needs to be same as dodge
                ))) +
  ggplot2::theme_light()

# only color to separate trace factor
afex_plot(a1, ~hour, ~treatment, ~phase, 
          mapping = c("color"),
          dodge = 0.65, 
          data_color = NULL,  ## needs to be set to NULL to avoid error
          data_arg = list(
            position = 
              ggplot2::position_jitterdodge(
                jitter.width = 0, 
                jitter.height = 0.2, 
                dodge.width = 0.65  ## needs to be same as dodge
                ))) +
  ggplot2::theme_classic()


## plot involving all 4 factors:
afex_plot(a1, ~hour, ~treatment, ~gender+phase, 
          dodge = 0.65, 
          data_arg = list(
            position = 
              ggplot2::position_jitterdodge(
                jitter.width = 0, 
                jitter.height = 0.2, 
                dodge.width = 0.65  ## needs to be same as dodge
                ),
            color = "darkgrey")) +
  ggplot2::theme_bw()


##---------------------------------------------------------------
##              Different Standard Errors Available             -
##---------------------------------------------------------------

## purely within-design
cbind(
  afex_plot(a1, ~phase, ~hour, 
            error = "model", return = "data")$means[,c("phase", "hour", "y", "SE")],
  multivariate = afex_plot(a1, ~phase, ~hour,
                           error = "model", return = "data")$means$error,
  mean = afex_plot(a1, ~phase, ~hour, 
                    error = "mean", return = "data")$means$error,
  within = afex_plot(a1, ~phase, ~hour, 
                     error = "within", return = "data")$means$error,
  between = afex_plot(a1, ~phase, ~hour, 
                      error = "between", return = "data")$means$error)
## mixed design
cbind(
  afex_plot(a1, ~phase, ~treatment, 
            error = "model", return = "data")$means[,c("phase", "treatment", "y", "SE")],
  multivariate = afex_plot(a1, ~phase, ~treatment,
                           error = "model", return = "data")$means$error,
  mean = afex_plot(a1, ~phase, ~treatment, 
                    error = "mean", return = "data")$means$error,
  within = afex_plot(a1, ~phase, ~treatment, 
                     error = "within", return = "data")$means$error,
  between = afex_plot(a1, ~phase, ~treatment, 
                      error = "between", return = "data")$means$error)

## End(Not run)

##################################################################
##                         Mixed Models                         ##
##################################################################
if (requireNamespace("MEMSS") &amp;&amp; 
    requireNamespace("emmeans") &amp;&amp; 
    requireNamespace("ggplot2")) {

data("Machines", package = "MEMSS") 
m1 &lt;- mixed(score ~ Machine + (Machine|Worker), data=Machines)
pairs(emmeans::emmeans(m1, "Machine"))
# contrast   estimate       SE df t.ratio p.value
# A - B     -7.966667 2.420850  5  -3.291  0.0481
# A - C    -13.916667 1.540100  5  -9.036  0.0007
# B - C     -5.950000 2.446475  5  -2.432  0.1253

## Default (i.e., model-based) error bars suggest no difference between Machines.
## This contrasts with pairwise comparisons above.
afex_plot(m1, "Machine")

## Impression from within-subject error bars is more in line with pattern of differences.
afex_plot(m1, "Machine", error = "within")
}

## Not run: 
data("fhch2010") # load 
fhch &lt;- droplevels(fhch2010[ fhch2010$correct,]) # remove errors
### following model should take less than a minute to fit:
mrt &lt;- mixed(log_rt ~ task*stimulus*frequency + (stimulus*frequency||id)+
               (task||item), fhch, method = "S", expand_re = TRUE)

## way too many points in background:
afex_plot(mrt, "stimulus", "frequency", "task") 

## better to restrict plot of data to one random-effects grouping variable
afex_plot(mrt, "stimulus", "frequency", "task", id = "id")
## when plotting data from a single random effect, different error bars are possible:
afex_plot(mrt, "stimulus", "frequency", "task", id = "id", error = "within")
afex_plot(mrt, "stimulus", "frequency", "task", id = "id", error = "mean")

## compare visual impression with:
pairs(emmeans::emmeans(mrt, c("stimulus", "frequency"), by = "task"))

## same logic also possible for other random-effects grouping factor
afex_plot(mrt, "stimulus", "frequency", "task", id = "item")
## within-item error bars are misleading here. task is sole within-items factor.
afex_plot(mrt, "stimulus", "frequency", "task", id = "item", error = "within")
## CIs based on standard error of mean look small, but not unreasonable given results.
afex_plot(mrt, "stimulus", "frequency", "task", id = "item", error = "mean")

### compare distribution of individual data for different random effects:
## requires package cowplot
p_id &lt;- afex_plot(mrt, "stimulus", "frequency", "task", id = "id", 
                  error = "within", dodge = 0.7,
                  data_geom = ggplot2::geom_violin, 
                  mapping = c("shape", "fill"),
                  data_arg = list(width = 0.7)) +
  ggplot2::scale_shape_manual(values = c(4, 17)) +
  ggplot2::labs(title = "ID")

p_item &lt;- afex_plot(mrt, "stimulus", "frequency", "task", id = "item", 
          error = "within", dodge = 0.7,
          data_geom = ggplot2::geom_violin, 
          mapping = c("shape", "fill"),
          data_arg = list(width = 0.7)) +
  ggplot2::scale_shape_manual(values = c(4, 17)) +
  ggplot2::labs(title = "Item")

### see: https://cran.r-project.org/package=cowplot/vignettes/shared_legends.html
p_comb &lt;- cowplot::plot_grid(
  p_id + ggplot2::theme_light() + ggplot2::theme(legend.position="none"),
  p_item + ggplot2::theme_light() + ggplot2::theme(legend.position="none")
  )
legend &lt;- cowplot::get_legend(p_id + ggplot2::theme(legend.position="bottom"))
cowplot::plot_grid(p_comb, legend, 
                   ncol = 1, 
                   rel_heights = c(1, 0.1))

##----------------------------------------------------------------
##                    Support for lme4::lmer                     -
##----------------------------------------------------------------

Oats &lt;- nlme::Oats
## afex_plot does currently not support implicit nesting: (1|Block/Variety)
## Instead, we need to create the factor explicitly
Oats$VarBlock &lt;- Oats$Variety:Oats$Block
Oats.lmer &lt;- lmer(yield ~ Variety * factor(nitro) + (1|VarBlock) + (1|Block),
                        data = Oats)
afex_plot(Oats.lmer, "nitro", "Variety")
afex_plot(Oats.lmer, "nitro", panel = "Variety")

##################################################################
##     Default Method works for Models Supported by emmeans     ##
##################################################################

## lm
warp.lm &lt;- lm(breaks ~ wool * tension, data = warpbreaks)
afex_plot(warp.lm, "tension")
afex_plot(warp.lm, "tension", "wool")

## poisson glm
ins &lt;- data.frame(
    n = c(500, 1200, 100, 400, 500, 300),
    size = factor(rep(1:3,2), labels = c("S","M","L")),
    age = factor(rep(1:2, each = 3)),
    claims = c(42, 37, 1, 101, 73, 14))
ins.glm &lt;- glm(claims ~ size + age + offset(log(n)), 
               data = ins, family = "poisson")
afex_plot(ins.glm, "size", "age")

## binomial glm adapted from ?predict.glm
ldose &lt;- factor(rep(0:5, 2))
numdead &lt;- c(1, 4, 9, 13, 18, 20, 0, 2, 6, 10, 12, 16)
sex &lt;- factor(rep(c("M", "F"), c(6, 6)))
SF &lt;- numdead/20  ## dv should be a vector, no matrix
budworm.lg &lt;- glm(SF ~ sex*ldose, family = binomial, 
                  weights = rep(20, length(numdead)))
afex_plot(budworm.lg, "ldose")
afex_plot(budworm.lg, "ldose", "sex") ## data point is hidden behind mean!
afex_plot(budworm.lg, "ldose", "sex", 
          data_arg = list(size = 4, color = "red"))

## nlme mixed model
data(Oats, package = "nlme")
Oats$nitro &lt;- factor(Oats$nitro)
oats.1 &lt;- nlme::lme(yield ~ nitro * Variety, 
                    random = ~ 1 | Block / Variety,
                    data = Oats)
afex_plot(oats.1, "nitro", "Variety", data = Oats)
afex_plot(oats.1, "nitro", "Variety", data = Oats, id = "Block")
afex_plot(oats.1, "nitro", data = Oats)
afex_plot(oats.1, "nitro", data = Oats, id = c("Block", "Variety"))
afex_plot(oats.1, "nitro", data = Oats, id = "Block")


## End(Not run)
</code></pre>

<hr>
<h2 id='afex-package'>Analysis of Factorial Experiments</h2><span id='topic+afex'></span><span id='topic+afex-package'></span>

<h3>Description</h3>

<p>Convenience functions for analyzing factorial experiments using ANOVA or
         mixed models. aov_ez(), aov_car(), and aov_4() allow specification of
         between, within (i.e., repeated-measures), or mixed (i.e., split-plot) 
         ANOVAs for data in long format (i.e., one observation per row),
         automatically aggregating multiple observations per individual and cell 
         of the design. mixed() fits mixed models using lme4::lmer() and computes 
         p-values for all fixed effects using either Kenward-Roger or Satterthwaite 
         approximation for degrees of freedom (LMM only), parametric bootstrap 
         (LMMs and GLMMs), or likelihood ratio tests (LMMs and GLMMs). 
         afex_plot() provides a high-level interface for interaction or one-way 
         plots using ggplot2, combining raw data and model estimates. afex uses 
         type 3 sums of squares as default (imitating commercial statistical software).
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> afex</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Analysis of Factorial Experiments</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 3.5.0), lme4 (&gt;= 1.1-8)</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> emmeans (&gt;= 1.4),
coin,
xtable,
parallel,
plyr,
optimx,
nloptr,
knitr,
rmarkdown,
R.rsp,
lattice,
latticeExtra,
multcomp,
testthat,
mlmRev,
dplyr,
tidyr,
dfoptim,
Matrix,
psychTools,
ggplot2,
MEMSS,
effects,
carData,
ggbeeswarm,
nlme,
cowplot,
jtools,
ggpubr,
ggpol,
MASS,
glmmTMB,
brms,
rstanarm,
statmod,
performance (&gt;= 0.7.2),
see (&gt;= 0.6.4),
ez,
ggResidpanel,
grid,
vdiffr</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> pbkrtest (&gt;= 0.4-1), lmerTest (&gt;= 3.0-0), car, reshape2, stats, methods, utils</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Convenience functions for analyzing factorial experiments using ANOVA or
         mixed models. aov_ez(), aov_car(), and aov_4() allow specification of
         between, within (i.e., repeated-measures), or mixed (i.e., split-plot) 
         ANOVAs for data in long format (i.e., one observation per row),
         automatically aggregating multiple observations per individual and cell 
         of the design. mixed() fits mixed models using lme4::lmer() and computes 
         p-values for all fixed effects using either Kenward-Roger or Satterthwaite 
         approximation for degrees of freedom (LMM only), parametric bootstrap 
         (LMMs and GLMMs), or likelihood ratio tests (LMMs and GLMMs). 
         afex_plot() provides a high-level interface for interaction or one-way 
         plots using ggplot2, combining raw data and model estimates. afex uses 
         type 3 sums of squares as default (imitating commercial statistical software).</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://afex.singmann.science/, https://github.com/singmann/afex</td>
</tr>
<tr>
 <td style="text-align: left;">
BugReports: </td><td style="text-align: left;"> https://github.com/singmann/afex/issues</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;=2)</td>
</tr>
<tr>
 <td style="text-align: left;">
Encoding: </td><td style="text-align: left;"> UTF-8</td>
</tr>
<tr>
 <td style="text-align: left;">
VignetteBuilder: </td><td style="text-align: left;"> knitr, R.rsp</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> c(person(given="Henrik", family="Singmann", role=c("aut", "cre"),
          email="singmann@gmail.com", comment=c(ORCID="0000-0002-4842-3657")),
         person(given="Ben", family="Bolker", role=c("aut")), 
         person(given="Jake",family="Westfall", role=c("aut")), 
         person(given="Frederik", family="Aust", role=c("aut"), 
          comment = c(ORCID = "0000-0003-4900-788X")),
         person(given="Mattan S.",family="Ben-Shachar", role=c("aut")), 
         person(given="Søren", family="Højsgaard", role=c("ctb")),
         person(given="John", family="Fox", role=c("ctb")), 
         person(given="Michael A.", family="Lawrence", role=c("ctb")), 
         person(given="Ulf", family="Mertens", role=c("ctb")), 
         person(given="Jonathon", family="Love", role=c("ctb")), 
         person(given="Russell", family="Lenth", role=c("ctb")), 
         person(given="Rune", family="Haubo Bojesen Christensen", role=c("ctb")))</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.3-1</td>
</tr>
<tr>
 <td style="text-align: left;">
RoxygenNote: </td><td style="text-align: left;"> 7.3.1</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyData: </td><td style="text-align: left;"> true</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Henrik Singmann [aut, cre] (&lt;https://orcid.org/0000-0002-4842-3657&gt;),
  Ben Bolker [aut],
  Jake Westfall [aut],
  Frederik Aust [aut] (&lt;https://orcid.org/0000-0003-4900-788X&gt;),
  Mattan S. Ben-Shachar [aut],
  Søren Højsgaard [ctb],
  John Fox [ctb],
  Michael A. Lawrence [ctb],
  Ulf Mertens [ctb],
  Jonathon Love [ctb],
  Russell Lenth [ctb],
  Rune Haubo Bojesen Christensen [ctb]</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Henrik Singmann &lt;singmann@gmail.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Henrik Singmann <a href="mailto:singmann@gmail.com">singmann@gmail.com</a> (<a href="https://orcid.org/0000-0002-4842-3657">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Ben Bolker
</p>
</li>
<li><p> Jake Westfall
</p>
</li>
<li><p> Frederik Aust (<a href="https://orcid.org/0000-0003-4900-788X">ORCID</a>)
</p>
</li>
<li><p> Mattan S. Ben-Shachar
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Søren Højsgaard [contributor]
</p>
</li>
<li><p> John Fox [contributor]
</p>
</li>
<li><p> Michael A. Lawrence [contributor]
</p>
</li>
<li><p> Ulf Mertens [contributor]
</p>
</li>
<li><p> Jonathon Love [contributor]
</p>
</li>
<li><p> Russell Lenth [contributor]
</p>
</li>
<li><p> Rune Haubo Bojesen Christensen [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://afex.singmann.science/">https://afex.singmann.science/</a>
</p>
</li>
<li> <p><a href="https://github.com/singmann/afex">https://github.com/singmann/afex</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/singmann/afex/issues">https://github.com/singmann/afex/issues</a>
</p>
</li></ul>


<hr>
<h2 id='aov_car'>Convenient ANOVA estimation for factorial designs</h2><span id='topic+aov_car'></span><span id='topic+aov_4'></span><span id='topic+aov_ez'></span>

<h3>Description</h3>

<p>These functions allow convenient specification of any type of ANOVAs (i.e.,
purely within-subjects ANOVAs, purely between-subjects ANOVAs, and mixed
between-within or split-plot ANOVAs) for data in the <strong>long</strong> format
(i.e., one observation per row). If the data has more than one observation
per individual and cell of the design (e.g., multiple responses per
condition), the data will be automatically aggregated. The default settings
reproduce results from commercial statistical packages such as SPSS or SAS.
<code>aov_ez</code> is called specifying the factors as character vectors,
<code>aov_car</code> is called using a formula similar to <code><a href="stats.html#topic+aov">aov</a></code>
specifying an error strata for the within-subject factor(s), and <code>aov_4</code>
is called with a <span class="pkg">lme4</span>-like formula (all ANOVA functions return
identical results). The returned object can be passed to e.g., <span class="pkg">emmeans</span>
for further analysis (e.g., follow-up tests, contrasts, plotting, etc.).
These functions employ <code><a href="car.html#topic+Anova">Anova</a></code> (from the <span class="pkg">car</span> package)
to provide test of effects avoiding the somewhat unhandy format of
<code>car::Anova</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aov_car(
  formula,
  data,
  fun_aggregate = NULL,
  type = afex_options("type"),
  factorize = afex_options("factorize"),
  observed = NULL,
  anova_table = list(),
  include_aov = afex_options("include_aov"),
  return = afex_options("return_aov"),
  ...
)

aov_4(
  formula,
  data,
  observed = NULL,
  fun_aggregate = NULL,
  type = afex_options("type"),
  factorize = afex_options("factorize"),
  return = afex_options("return_aov"),
  anova_table = list(),
  include_aov = afex_options("include_aov"),
  ...,
  print.formula = FALSE
)

aov_ez(
  id,
  dv,
  data,
  between = NULL,
  within = NULL,
  covariate = NULL,
  observed = NULL,
  fun_aggregate = NULL,
  transformation,
  type = afex_options("type"),
  factorize = afex_options("factorize"),
  return = afex_options("return_aov"),
  anova_table = list(),
  include_aov = afex_options("include_aov"),
  ...,
  print.formula = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aov_car_+3A_formula">formula</code></td>
<td>
<p>A formula specifying the ANOVA model similar to
<code><a href="stats.html#topic+aov">aov</a></code> (for <code>aov_car</code> or similar to <code>lme4:lmer</code> for
<code>aov_4</code>). Must include an error term (i.e., <code>Error(id/...)</code> for
<code>aov_car</code> or <code>(...|id)</code> for <code>aov_4</code>). Note that the
within-subject factors do not need to be outside the Error term (this
contrasts with <code>aov</code>). See Details.</p>
</td></tr>
<tr><td><code id="aov_car_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> containing the data. Mandatory.</p>
</td></tr>
<tr><td><code id="aov_car_+3A_fun_aggregate">fun_aggregate</code></td>
<td>
<p>The function for aggregating the data before running the
ANOVA if there is more than one observation per individual and cell of the
design. The default <code>NULL</code> issues a warning if aggregation is
necessary and uses <code><a href="base.html#topic+mean">mean</a></code>. Pass <code>mean</code> directly to avoid
the warning.</p>
</td></tr>
<tr><td><code id="aov_car_+3A_type">type</code></td>
<td>
<p>The type of sums of squares for the ANOVA. The default is given
by <code>afex_options("type")</code>, which is <strong>initially set to 3</strong>.
Passed to <code><a href="car.html#topic+Anova">Anova</a></code>. Possible values are <code>"II"</code>,
<code>"III"</code>, <code>2</code>, or <code>3</code>.</p>
</td></tr>
<tr><td><code id="aov_car_+3A_factorize">factorize</code></td>
<td>
<p>logical. Should between subject factors be factorized (with
note) before running the analysis. The default is given by
<code>afex_options("factorize")</code>, which is initially <code>TRUE</code>. If one
wants to run an ANCOVA, this needs to be set to <code>FALSE</code> (in which case
centering on 0 is checked on numeric variables).</p>
</td></tr>
<tr><td><code id="aov_car_+3A_observed">observed</code></td>
<td>
<p><code>character</code> vector indicating which of the variables are
observed (i.e, measured) as compared to experimentally manipulated. The
default effect size reported (generalized eta-squared) requires correct
specification of the observed (in contrast to manipulated) variables.</p>
</td></tr>
<tr><td><code id="aov_car_+3A_anova_table">anova_table</code></td>
<td>
<p><code>list</code> of further arguments passed to function
producing the ANOVA table.  Arguments such as <code>es</code> (effect size) or
<code>correction</code>  are passed to either <code>anova.afex_aov</code> or
<code>nice</code>. Note that those settings can also be changed once an object of
class <code>afex_aov</code> is created by invoking the <code>anova</code> method
directly.</p>
</td></tr>
<tr><td><code id="aov_car_+3A_include_aov">include_aov</code></td>
<td>
<p>Boolean. Allows suppressing the calculation of the aov
object. If TRUE the aov model is part of the returned <code>afex_aov</code>
object. <code>FALSE</code> (the default) prevents this potentially costly
calculation. Especially for designs with larger N and within-subjects
factors, this is highly advisable. Follow-up analyses using <span class="pkg">emmeans</span>
using the <code>univariate</code> model (which is not recommended) require the
aov model and TRUE.</p>
</td></tr>
<tr><td><code id="aov_car_+3A_return">return</code></td>
<td>
<p>What should be returned? The default is given by
<code>afex_options("return_aov")</code>, which is initially <code>"afex_aov"</code>,
returning an S3 object of class <code>afex_aov</code> for which various
<a href="#topic+afex_aov-methods">methods</a> exist (see there and below for more
details). Other values are currently still supported for backward
compatibility.</p>
</td></tr>
<tr><td><code id="aov_car_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>fun_aggregate</code>.</p>
</td></tr>
<tr><td><code id="aov_car_+3A_print.formula">print.formula</code></td>
<td>
<p><code>aov_ez</code> and <code>aov_4</code> are wrapper for
<code>aov_car</code>. This boolean argument indicates whether the formula in the
call to <code>car.aov</code> should be printed.</p>
</td></tr>
<tr><td><code id="aov_car_+3A_id">id</code></td>
<td>
<p><code>character</code> vector (of length 1) indicating the subject
identifier column in <code>data</code>.</p>
</td></tr>
<tr><td><code id="aov_car_+3A_dv">dv</code></td>
<td>
<p><code>character</code> vector (of length 1) indicating the column
containing the <strong>dependent variable</strong> in <code>data</code>.</p>
</td></tr>
<tr><td><code id="aov_car_+3A_between">between</code></td>
<td>
<p><code>character</code> vector indicating the
<strong>between</strong>-subject(s) factor(s)/column(s) in <code>data</code>. Default is
<code>NULL</code> indicating no between-subjects factors.</p>
</td></tr>
<tr><td><code id="aov_car_+3A_within">within</code></td>
<td>
<p><code>character</code> vector indicating the
<strong>within</strong>-subject(s)(or repeated-measures) factor(s)/column(s) in
<code>data</code>.  Default is <code>NULL</code> indicating no within-subjects factors.</p>
</td></tr>
<tr><td><code id="aov_car_+3A_covariate">covariate</code></td>
<td>
<p><code>character</code> vector indicating the between-subject(s)
covariate(s) (i.e., column(s)) in <code>data</code>. Default is <code>NULL</code>
indicating no covariates. Please note that <code>factorize</code> needs to be set
to <code>FALSE</code> in case the covariate is numeric and should be treated as
such.</p>
</td></tr>
<tr><td><code id="aov_car_+3A_transformation">transformation</code></td>
<td>
<p>In <code>aov_ez</code>, a <code>character</code> vector (of length 
1) indicating the name of a transformation to apply to <code>dv</code> before 
fitting the model. If missing, no transformation is applied. In 
<code>aov_car</code> and <code>aov_4</code>, a response transformation may be 
incorporated in the left-hand side of <code>formula</code>.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Details of ANOVA Specification</h4>

 <p><code>aov_ez</code> will concatenate
all between-subject factors using <code>*</code> (i.e., producing all main effects
and interactions) and all covariates by <code>+</code> (i.e., adding only the main
effects to the existing between-subject factors). The within-subject factors
do fully interact with all between-subject factors and covariates. This is
essentially identical to the behavior of SPSS's <code>glm</code> function.
</p>
<p>The <code>formula</code>s for <code>aov_car</code> or <code>aov_4</code> must contain a single
<code>Error</code> term specifying the <code>ID</code> column and potential
within-subject factors (you can use <code><a href="#topic+mixed">mixed</a></code> for running
mixed-effects models with multiple error terms). Factors outside the
<code>Error</code> term are treated as between-subject factors (the within-subject
factors specified in the <code>Error</code> term are ignored outside the
<code>Error</code> term; in other words, it is not necessary to specify them
outside the <code>Error</code> term, see Examples).<br /> Suppressing the intercept
(i.e, via <code>0 +</code> or <code>- 1</code>) is ignored. Specific specifications of
effects (e.g., excluding terms with <code>-</code> or using <code>^</code>) could be okay
but is not tested. Using the <code><a href="base.html#topic+I">I</a></code> or <code><a href="stats.html#topic+poly">poly</a></code> function
within the formula is not tested and not supported!
</p>
<p>To run an ANCOVA you need to set <code>factorize = FALSE</code> and make sure that
all variables have the correct type (i.e., factors are factors and numeric
variables are numeric and centered).
</p>
<p>Note that the default behavior is to include calculation of the effect size
generalized eta-squared for which <strong>all non-manipluated (i.e.,
observed)</strong> variables need to be specified via the <code>observed</code> argument to
obtain correct results. When changing the effect size to <code>"pes"</code>
(partial eta-squared) or <code>"none"</code> via <code>anova_table</code> this becomes
unnecessary.
</p>
<p>Factor contrasts will be set to <code>"contr.sum"</code> for all between-subject
factors if default contrasts are not equal to <code>"contr.sum"</code> or
<code>attrib(factor, "contrasts") != "contr.sum"</code>. (within-subject factors
are hard-coded <code>"contr.sum"</code>.) </p>



<h4>Statistical Issues</h4>

 <p><strong>Type 3 sums of squares are default
in <span class="pkg">afex</span>.</strong> While some authors argue that so-called type 3 sums of
squares are dangerous and/or problematic (most notably Venables, 2000), they
are the default in many commercial statistical application such as SPSS or
SAS. Furthermore, statisticians with an applied perspective recommend type 3
tests (e.g., Maxwell and Delaney, 2004). Consequently, they are the default
for the ANOVA functions described here. For some more discussion on this
issue see <a href="https://stats.stackexchange.com/q/6208/442">here</a>.
</p>
<p>Note that lower order effects (e.g., main effects) in type 3 ANOVAs are only
meaningful with
<a href="https://stats.oarc.ucla.edu/other/mult-pkg/faq/general/faqwhat-is-effect-coding/">effects
coding</a>. Therefore, contrasts are set to <code><a href="stats.html#topic+contr.sum">contr.sum</a></code> which
ensures meaningful results. For a discussion of the other (non-recommended)
coding schemes see
<a href="https://stats.oarc.ucla.edu/r/library/r-library-contrast-coding-systems-for-categorical-variables/">here</a>.
</p>



<h4>Follow-Up Contrasts and Post-Hoc Tests</h4>

<p> The S3 object returned
per default can be directly passed to <code>emmeans::emmeans</code> for further
analysis. This allows to test any type of contrasts that might be of interest
independent of whether or not this contrast involves between-subject
variables, within-subject variables, or a combination thereof. The general
procedure to run those contrasts is the following (see Examples for a full
example):
</p>

<ol>
<li><p> Estimate an <code>afex_aov</code> object with the function returned here. For example: <code>x &lt;- aov_car(dv ~ a*b + (id/c), d)</code>
</p>
</li>
<li><p> Obtain a <code><a href="emmeans.html#topic+emmGrid-class">emmGrid-class</a></code> object by running <code><a href="emmeans.html#topic+emmeans">emmeans</a></code> on the <code>afex_aov</code> object from step 1 using the factors involved in the contrast. For example: <code>r &lt;- emmeans(x, ~a:c)</code>
</p>
</li>
<li><p> Create a list containing the desired contrasts on the reference grid object from step 2. For example: <code>con1 &lt;- list(a_x = c(-1, 1, 0, 0, 0, 0), b_x = c(0, 0, -0.5, -0.5, 0, 1))</code>
</p>
</li>
<li><p> Test the contrast on the reference grid using <code><a href="emmeans.html#topic+contrast">contrast</a></code>. For example: <code>contrast(r, con1)</code>
</p>
</li>
<li><p> To control for multiple testing p-value adjustments can be specified. For example the Bonferroni-Holm correction: <code>contrast(r, con1, adjust = "holm")</code>
</p>
</li></ol>

<p>Note that <span class="pkg">emmeans</span> allows for a variety of advanced settings and
simplifications, for example: all pairwise comparison of a single factor
using one command (e.g., <code>emmeans(x, "a", contr = "pairwise")</code>) or
advanced control for multiple testing by passing objects to <span class="pkg">multcomp</span>.
A comprehensive overview of the functionality is provided in the
accompanying vignettes (see
<a href="https://CRAN.R-project.org/package=emmeans">here</a>).
</p>
<p>Since version 1.0, <span class="pkg">afex</span> per default uses the <code>multivariate</code> model
(i.e., the <code>lm</code> slot of the <code>afex_aov</code> object) for follow-up tests
with <span class="pkg">emmeans</span>. Compared to the <code>univariate</code> model (i.e., the
<code>aov</code> slot), this can handle unbalanced data and addresses sphericity
better. To use the older (and not recommended) <code>model = "univariate"</code>
make sure to set <code>include_aov = TRUE</code> when estimating the ANOVA.
</p>
<p>Starting with <span class="pkg">afex</span> version 0.22, <span class="pkg">emmeans</span> is <em>not</em>
loaded/attached automatically when loading <span class="pkg">afex</span>. Therefore,
<span class="pkg">emmeans</span> now needs to be loaded by the user via
<code>library("emmeans")</code> or <code>require("emmeans")</code>.
</p>
  


<h4>Methods for <code>afex_aov</code> Objects</h4>

<p> A full overview over the
methods provided for <code>afex_aov</code> objects is provided in the corresponding
help page: <code><a href="#topic+afex_aov-methods">afex_aov-methods</a></code>. The probably most important ones
for end-users are <code>summary</code>, <code>anova</code>, and <code><a href="#topic+nice">nice</a></code>.
</p>
<p>The <code>summary</code> method returns, for ANOVAs containing within-subject
(repeated-measures) factors with more than two levels, the complete
univariate analysis: Results without df-correction, the Greenhouse-Geisser
corrected results, the Hyunh-Feldt corrected results, and the results of the
Mauchly test for sphericity.
</p>
<p>The <code>anova</code> method returns a <code>data.frame</code> of class <code>"anova"</code>
containing the ANOVA table in numeric form (i.e., the one in slot
<code>anova_table</code> of a <code>afex_aov</code>). This method has arguments such as
<code>correction</code> and <code>es</code> and can be used to obtain an ANOVA table with
different correction than the one initially specified.
</p>
<p>The <code><a href="#topic+nice">nice</a></code> method also returns a <code>data.frame</code>, but rounds
most values and transforms them into characters for nice printing. Also has
arguments like <code>correction</code> and <code>es</code> which can be used to obtain an
ANOVA table with different correction than the one initially specified. </p>



<h3>Value</h3>

<p><code>aov_car</code>, <code>aov_4</code>, and <code>aov_ez</code> are wrappers for
<code><a href="car.html#topic+Anova">Anova</a></code> and <code><a href="stats.html#topic+aov">aov</a></code>, the return value is
dependent on the <code>return</code> argument. Per default, an S3 object of class
<code>"afex_aov"</code> is returned containing the following slots:
</p>

<dl>
<dt><code>"anova_table"</code></dt><dd><p>An ANOVA table of class <code>c("anova",
   "data.frame")</code>.</p>
</dd>
<dt><code>"aov"</code></dt><dd><p><code>aov</code> object returned from <code><a href="stats.html#topic+aov">aov</a></code> 
(should not be used to evaluate significance of effects, but can be passed
to <code>emmeans</code> for post-hoc tests).</p>
</dd>
<dt><code>"Anova"</code></dt><dd><p>object returned from <code><a href="car.html#topic+Anova">Anova</a></code>, an 
object of class <code>"Anova.mlm"</code> (if within-subjects factors are present)
or of class <code>c("anova", "data.frame")</code>.</p>
</dd>
<dt><code>"lm"</code></dt><dd><p>the object fitted with <code>lm</code> and passed to
<code>Anova</code> (i.e., an object of class <code>"lm"</code> or <code>"mlm"</code>). Also
returned if <code>return = "lm"</code>.</p>
</dd>
<dt><code>"data"</code></dt><dd><p>a list containing: (1) <code>long</code> (the possibly
aggregated data in long format used for <code>aov</code>), <code>wide</code> (the data
used to fit the <code>lm</code> object), and <code>idata</code> (if within-subject
factors are present, the <code>idata</code> argument passed to
<code>car::Anova</code>). Also returned if <code>return = "data"</code>.</p>
</dd>
</dl>

<p>In addition, the object has the following attributes: <code>"dv"</code>,
<code>"id"</code>, <code>"within"</code>, <code>"between"</code>, and <code>"type"</code>.
</p>
<p>The <a href="#topic+afex_aov-methods">print</a> method for <code>afex_aov</code> objects
(invisibly) returns (and prints) the same as if <code>return</code> is
<code>"nice"</code>: a nice ANOVA table (produced by <code><a href="#topic+nice">nice</a></code>) with the
following columns: <code>Effect</code>, <code>df</code>, <code>MSE</code> (mean-squared
errors), <code>F</code> (potentially with significant symbols), <code>ges</code>
(generalized eta-squared), <code>p</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>aov_4()</code>: Allows definition of ANOVA-model using
<code>lme4::lmer</code>-like Syntax (but still fits a standard ANOVA).
</p>
</li>
<li> <p><code>aov_ez()</code>: Allows definition of ANOVA-model using character strings.
</p>
</li></ul>


<h3>Note</h3>

<p>Calculation of ANOVA models via <code>aov</code> (which is done per default)
can be comparatively slow and produce comparatively large objects for
ANOVAs with many within-subjects factors or levels. To avoid this
calculation set <code>include_aov = FALSE</code>. You can also disable this
globally with: <code>afex_options(include_aov = FALSE)</code>
</p>
<p>The id variable and variables entered as within-subjects (i.e.,
repeated-measures) factors are silently converted to factors. Levels of
within-subject factors are converted to valid variable names using
<code><a href="base.html#topic+make.names">make.names</a>(...,unique=TRUE)</code>. Unused factor levels are
silently dropped on all variables.
</p>
<p>Contrasts attached to a factor as an attribute are probably not preserved
and not supported.
</p>
<p>The workhorse is <code>aov_car</code>. <code>aov_4</code> and <code>aov_ez</code> only
construe and pass an appropriate formula to <code>aov_car</code>. Use
<code>print.formula = TRUE</code> to view this formula.
</p>
<p>In contrast to <code><a href="stats.html#topic+aov">aov</a></code> <code>aov_car</code> assumes that all factors to
the right of <code>/</code> in the <code>Error</code> term are belonging together.
Consequently, <code>Error(id/(a*b))</code> and <code>Error(id/a*b)</code> are identical
(which is not true for <code><a href="stats.html#topic+aov">aov</a></code>).
</p>


<h3>Author(s)</h3>

<p>Henrik Singmann
</p>
<p>The design of these functions was influenced by <code><a href="ez.html#topic+ezANOVA">ezANOVA</a></code>
from package <span class="pkg">ez</span>.
</p>


<h3>References</h3>

<p>Cramer, A. O. J., van Ravenzwaaij, D., Matzke, D., Steingroever,
H., Wetzels, R., Grasman, R. P. P. P., ... Wagenmakers, E.-J. (2015).
Hidden multiplicity in exploratory multiway ANOVA: Prevalence and remedies.
<em>Psychonomic Bulletin &amp; Review</em>, 1-8. <a href="https://doi.org/10.3758/s13423-015-0913-5">doi:10.3758/s13423-015-0913-5</a>
</p>
<p>Maxwell, S. E., &amp; Delaney, H. D. (2004). <em>Designing Experiments and
Analyzing Data: A Model-Comparisons Perspective</em>. Mahwah, N.J.: Lawrence
Erlbaum Associates.
</p>
<p>Venables, W.N. (2000). <em>Exegeses on linear models</em>. Paper presented to
the S-Plus User's Conference, Washington DC, 8-9 October 1998, Washington,
DC. Available from: <a href="http://www.stats.ox.ac.uk/pub/MASS3/Exegeses.pdf">http://www.stats.ox.ac.uk/pub/MASS3/Exegeses.pdf</a>
</p>


<h3>See Also</h3>

<p>Various methods for objects of class <code>afex_aov</code> are available:
<code><a href="#topic+afex_aov-methods">afex_aov-methods</a></code>
</p>
<p><code><a href="#topic+nice">nice</a></code> creates the nice ANOVA tables which is by default printed.
See also there for a slightly longer discussion of the available effect
sizes.
</p>
<p><code><a href="#topic+mixed">mixed</a></code> provides a (formula) interface for obtaining p-values for
mixed-models via <span class="pkg">lme4</span>. The functions presented here do not estimate
mixed models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##########################
## 1: Specifying ANOVAs ##
##########################

# Example using a purely within-subjects design 
# (Maxwell &amp; Delaney, 2004, Chapter 12, Table 12.5, p. 578):
data(md_12.1)
aov_ez("id", "rt", md_12.1, within = c("angle", "noise"), 
       anova_table=list(correction = "none", es = "none"))

# Default output
aov_ez("id", "rt", md_12.1, within = c("angle", "noise"))       


# examples using obk.long (see ?obk.long), a long version of the OBrienKaiser
# dataset (car package). Data is a split-plot or mixed design: contains both
# within- and between-subjects factors.
data(obk.long, package = "afex")

# estimate mixed ANOVA on the full design:
aov_car(value ~ treatment * gender + Error(id/(phase*hour)), 
        data = obk.long, observed = "gender")

aov_4(value ~ treatment * gender + (phase*hour|id), 
        data = obk.long, observed = "gender")

aov_ez("id", "value", obk.long, between = c("treatment", "gender"), 
        within = c("phase", "hour"), observed = "gender")

# the three calls return the same ANOVA table:
# Anova Table (Type 3 tests)
# 
# Response: value
#                         Effect          df   MSE         F  ges p.value
# 1                    treatment       2, 10 22.81    3.94 + .198    .055
# 2                       gender       1, 10 22.81    3.66 + .115    .085
# 3             treatment:gender       2, 10 22.81      2.86 .179    .104
# 4                        phase 1.60, 15.99  5.02 16.13 *** .151   &lt;.001
# 5              treatment:phase 3.20, 15.99  5.02    4.85 * .097    .013
# 6                 gender:phase 1.60, 15.99  5.02      0.28 .003    .709
# 7       treatment:gender:phase 3.20, 15.99  5.02      0.64 .014    .612
# 8                         hour 1.84, 18.41  3.39 16.69 *** .125   &lt;.001
# 9               treatment:hour 3.68, 18.41  3.39      0.09 .002    .979
# 10                 gender:hour 1.84, 18.41  3.39      0.45 .004    .628
# 11       treatment:gender:hour 3.68, 18.41  3.39      0.62 .011    .641
# 12                  phase:hour 3.60, 35.96  2.67      1.18 .015    .335
# 13        treatment:phase:hour 7.19, 35.96  2.67      0.35 .009    .930
# 14           gender:phase:hour 3.60, 35.96  2.67      0.93 .012    .449
# 15 treatment:gender:phase:hour 7.19, 35.96  2.67      0.74 .019    .646
# ---
# Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘+’ 0.1 ‘ ’ 1
# 
# Sphericity correction method: GG 

# "numeric" variables are per default converted to factors (as long as factorize
# = TRUE):
obk.long$hour2 &lt;- as.numeric(as.character(obk.long$hour))

# gives same results as calls before
aov_car(value ~ treatment * gender + Error(id/phase*hour2), 
        data = obk.long, observed = c("gender"))


# ANCOVA: adding a covariate (necessary to set factorize = FALSE)
aov_car(value ~ treatment * gender + age + Error(id/(phase*hour)), 
        data = obk.long, observed = c("gender", "age"), factorize = FALSE)

aov_4(value ~ treatment * gender + age + (phase*hour|id), 
        data = obk.long, observed = c("gender", "age"), factorize = FALSE)

aov_ez("id", "value", obk.long, between = c("treatment", "gender"), 
        within = c("phase", "hour"), covariate = "age", 
        observed = c("gender", "age"), factorize = FALSE)


# aggregating over one within-subjects factor (phase), with warning:
aov_car(value ~ treatment * gender + Error(id/hour), data = obk.long, 
        observed = "gender")

aov_ez("id", "value", obk.long, c("treatment", "gender"), "hour", 
       observed = "gender")

# aggregating over both within-subjects factors (again with warning),
# only between-subjects factors:
aov_car(value ~ treatment * gender + Error(id), data = obk.long, 
        observed = c("gender"))
aov_4(value ~ treatment * gender + (1|id), data = obk.long, 
      observed = c("gender"))
aov_ez("id", "value", obk.long, between = c("treatment", "gender"), 
       observed = "gender")

# only within-subject factors (ignoring between-subjects factors)
aov_car(value ~ Error(id/(phase*hour)), data = obk.long)
aov_4(value ~ (phase*hour|id), data = obk.long)
aov_ez("id", "value", obk.long, within = c("phase", "hour"))

### changing defaults of ANOVA table:

# no df-correction &amp; partial eta-squared:
aov_car(value ~ treatment * gender + Error(id/(phase*hour)), 
        data = obk.long, anova_table = list(correction = "none", es = "pes"))

# no df-correction and no MSE
aov_car(value ~ treatment * gender + Error(id/(phase*hour)), 
        data = obk.long,observed = "gender", 
        anova_table = list(correction = "none", MSE = FALSE))

# add p-value adjustment for all effects (see Cramer et al., 2015, PB&amp;R)
aov_ez("id", "value", obk.long, between = "treatment", 
       within = c("phase", "hour"), 
       anova_table = list(p_adjust_method = "holm"))


###########################
## 2: Follow-up Analysis ##
###########################

# use data as above
data(obk.long, package = "afex")

# 1. obtain afex_aov object:
a1 &lt;- aov_ez("id", "value", obk.long, between = c("treatment", "gender"), 
        within = c("phase", "hour"), observed = "gender")


if (requireNamespace("ggplot2") &amp; requireNamespace("emmeans")) {
# 1b. plot data using afex_plot function, for more see: 
## vignette("afex_plot_introduction", package = "afex")

## default plot uses multivariate model-based CIs
afex_plot(a1, "hour", "gender", c("treatment", "phase"))

  
a1b &lt;- aov_ez("id", "value", obk.long, between = c("treatment", "gender"), 
        within = c("phase", "hour"), observed = "gender", 
        include_aov = TRUE)
## you can use a univariate model and CIs if you refit the model with the aov
## slot
afex_plot(a1b, "hour", "gender", c("treatment", "phase"), 
          emmeans_arg = list(model = "univariate"))

## in a mixed between-within designs, no error-bars might be preferrable:
afex_plot(a1, "hour", "gender", c("treatment", "phase"), error = "none")
}

if (requireNamespace("emmeans")) {
library("emmeans")  # package emmeans needs to be attached for follow-up tests.

# 2. obtain reference grid object (default uses multivariate model):
r1 &lt;- emmeans(a1, ~treatment +phase)
r1

# 3. create list of contrasts on the reference grid:
c1 &lt;- list(
  A_B_pre = c(rep(0, 6), 0, -1, 1),  # A versus B for pretest
  A_B_comb = c(-0.5, 0.5, 0, -0.5, 0.5, 0, 0, 0, 0), # A vs. B for post and follow-up combined
  effect_post = c(0, 0, 0, -1, 0.5, 0.5, 0, 0, 0), # control versus A&amp;B post
  effect_fup = c(-1, 0.5, 0.5, 0, 0, 0, 0, 0, 0), # control versus A&amp;B follow-up
  effect_comb = c(-0.5, 0.25, 0.25, -0.5, 0.25, 0.25, 0, 0, 0) # control versus A&amp;B combined
)

# 4. test contrasts on reference grid:
contrast(r1, c1)

# same as before, but using Bonferroni-Holm correction for multiple testing:
contrast(r1, c1, adjust = "holm")

# 2. (alternative): all pairwise comparisons of treatment:
emmeans(a1, "treatment", contr = "pairwise")
}

#######################
## 3: Other examples ##
#######################
data(obk.long, package = "afex")

# replicating ?Anova using aov_car:
obk_anova &lt;- aov_car(value ~ treatment * gender + Error(id/(phase*hour)), 
        data = obk.long, type = 2)
# in contrast to aov you do not need the within-subject factors outside Error()

str(obk_anova, 1, give.attr = FALSE)
# List of 5
#  $ anova_table:Classes ‘anova’ and 'data.frame':	15 obs. of  6 variables:
#  $ aov        : NULL
#  $ Anova      :List of 14
#  $ lm         :List of 13
#  $ data       :List of 3

obk_anova$Anova
# Type II Repeated Measures MANOVA Tests: Pillai test statistic
#                             Df test stat approx F num Df den Df    Pr(&gt;F)    
# (Intercept)                  1   0.96954   318.34      1     10 6.532e-09 ***
# treatment                    2   0.48092     4.63      2     10 0.0376868 *  
# gender                       1   0.20356     2.56      1     10 0.1409735    
# treatment:gender             2   0.36350     2.86      2     10 0.1044692    
# phase                        1   0.85052    25.61      2      9 0.0001930 ***
# treatment:phase              2   0.68518     2.61      4     20 0.0667354 .  
# gender:phase                 1   0.04314     0.20      2      9 0.8199968    
# treatment:gender:phase       2   0.31060     0.92      4     20 0.4721498    
# hour                         1   0.93468    25.04      4      7 0.0003043 ***
# treatment:hour               2   0.30144     0.35      8     16 0.9295212    
# gender:hour                  1   0.29274     0.72      4      7 0.6023742    
# treatment:gender:hour        2   0.57022     0.80      8     16 0.6131884    
# phase:hour                   1   0.54958     0.46      8      3 0.8324517    
# treatment:phase:hour         2   0.66367     0.25     16      8 0.9914415    
# gender:phase:hour            1   0.69505     0.85      8      3 0.6202076    
# treatment:gender:phase:hour  2   0.79277     0.33     16      8 0.9723693    
# ---
# Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

</code></pre>

<hr>
<h2 id='compare.2.vectors'>Compare two vectors using various tests.</h2><span id='topic+compare.2.vectors'></span>

<h3>Description</h3>

<p>Compares two vectors <code>x</code> and <code>y</code> using t-test, Welch-test (also known as Satterthwaite), Wilcoxon-test, and a permutation test implemented in <span class="pkg">coin</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare.2.vectors(x, y, paired = FALSE, na.rm = FALSE, 
     tests = c("parametric", "nonparametric"), coin = TRUE, 
     alternative = "two.sided", 
     perm.distribution, 
     wilcox.exact = NULL, wilcox.correct = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare.2.vectors_+3A_x">x</code></td>
<td>
<p>a (non-empty) numeric vector of data values.</p>
</td></tr>
<tr><td><code id="compare.2.vectors_+3A_y">y</code></td>
<td>
<p>a (non-empty) numeric vector of data values.</p>
</td></tr>
<tr><td><code id="compare.2.vectors_+3A_paired">paired</code></td>
<td>
<p>a logical whether the data is paired. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="compare.2.vectors_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Should <code>NA</code> be removed?  Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="compare.2.vectors_+3A_tests">tests</code></td>
<td>
<p>Which tests to report, parametric or nonparamteric? The default <code>c("parametric", "nonparametric")</code> reports both. See details. (Arguments may be abbreviated).</p>
</td></tr>
<tr><td><code id="compare.2.vectors_+3A_coin">coin</code></td>
<td>
<p>logical or character. Should (permutation) tests from the <span class="pkg">coin</span> package be reported? Default is <code>TRUE</code> corresponding to all implemented tests. <code>FALSE</code> calculates no tests from <span class="pkg">coin</span>. A character vector may include any of the following (potentially abbreviated) implemented tests (see also Details): <code>c("permutation", "Wilcoxon", "median")</code></p>
</td></tr>
<tr><td><code id="compare.2.vectors_+3A_alternative">alternative</code></td>
<td>
<p>a character, the alternative hypothesis must be one of <code>"two.sided"</code> (default), <code>"greater"</code> or <code>"less"</code>. You can specify just the initial letter, will be passed to all functions.</p>
</td></tr>
<tr><td><code id="compare.2.vectors_+3A_perm.distribution">perm.distribution</code></td>
<td>
<p><code>distribution</code> argument to <span class="pkg">coin</span>, see <code><a href="coin.html#topic+NullDistribution">NullDistribution</a></code> or , <code><a href="coin.html#topic+IndependenceTest">IndependenceTest</a></code>. If missing, defaults to <code>coin::approximate(100000)</code> indicating an approximation of the excat conditional distribution with 100.000 Monte Carlo samples. One can use <code>"exact"</code> for small samples and if <code>paired = FALSE</code>.</p>
</td></tr>
<tr><td><code id="compare.2.vectors_+3A_wilcox.exact">wilcox.exact</code></td>
<td>
<p><code>exact</code> argument to <code><a href="stats.html#topic+wilcox.test">wilcox.test</a></code>.</p>
</td></tr>
<tr><td><code id="compare.2.vectors_+3A_wilcox.correct">wilcox.correct</code></td>
<td>
<p><code>correct</code> argument to <code><a href="stats.html#topic+wilcox.test">wilcox.test</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>parametric</code> tests (currently) only contain the <em>t</em>-test and Welch/Statterwaithe/Smith/unequal variance <em>t</em>-test implemented in <code><a href="stats.html#topic+t.test">t.test</a></code>. The latter one is only displayed if <code>paired = FALSE</code>. 
</p>
<p>The <code>nonparametric</code> tests (currently) contain the Wilcoxon test implemented in <code><a href="stats.html#topic+wilcox.test">wilcox.test</a></code> (<code>stats::Wilcoxon</code>) and (if <code>coin = TRUE</code>) the following tests implemented in <span class="pkg">coin</span>: 
</p>

<ul>
<li><p> a <code>permutation</code> test <code><a href="coin.html#topic+oneway_test">oneway_test</a></code> (the only test in this selction not using a rank transformation),
</p>
</li>
<li><p> the <code>Wilcoxon</code> test <code><a href="coin.html#topic+wilcox_test">wilcox_test</a></code> (<code>coin::Wilcoxon</code>), and 
</p>
</li>
<li><p> the <code>median</code> test <code><a href="coin.html#topic+median_test">median_test</a></code>. 
</p>
</li></ul>

<p>Note that the two implementations of the Wilcoxon test probably differ. This is due to differences in the calculation of the Null distributions.
</p>


<h3>Value</h3>

<p>a list with up to two elements (i.e., <code>paramteric</code> and/or <code>nonparamteric</code>) each containing  a <code>data.frame</code> with the following columns: <code>test</code>, <code>test.statistic</code>, <code>test.value</code>, <code>test.df</code>, <code>p</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
with(sleep, compare.2.vectors(extra[group == 1], extra[group == 2]))

# gives:
## $parametric
##    test test.statistic test.value test.df       p
## 1     t              t     -1.861   18.00 0.07919
## 2 Welch              t     -1.861   17.78 0.07939
## 
## $nonparametric
##              test test.statistic test.value test.df       p
## 1 stats::Wilcoxon              W     25.500      NA 0.06933
## 2     permutation              Z     -1.751      NA 0.08154
## 3  coin::Wilcoxon              Z     -1.854      NA 0.06487
## 4          median              Z     -1.744      NA 0.17867

# compare with:
with(sleep, compare.2.vectors(extra[group == 1], extra[group == 2], 
                              alternative = "less"))

with(sleep, compare.2.vectors(extra[group == 1], extra[group == 2], 
                              alternative = "greater"))

# doesn't make much sense as the data is not paired, but whatever:
with(sleep, compare.2.vectors(extra[group == 1], extra[group == 2], 
                              paired = TRUE))

# from ?t.test:
compare.2.vectors(1:10,y=c(7:20, 200))

</code></pre>

<hr>
<h2 id='ems'>Expected values of mean squares for factorial designs
Implements the Cornfield-Tukey algorithm for deriving the expected values of the mean squares for factorial designs.</h2><span id='topic+ems'></span>

<h3>Description</h3>

<p>Expected values of mean squares for factorial designs
</p>
<p>Implements the Cornfield-Tukey algorithm for deriving the expected values of the mean squares for factorial designs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ems(design, nested = NULL, random = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ems_+3A_design">design</code></td>
<td>
<p>A <code>formula</code> object specifying the factors in the design (except residual error, which is always implicitly included). The left hand side of the <code>~</code> is the symbol that will be used to denote the number of replications per lowest-level factor combination (I usually use &quot;r&quot; or &quot;n&quot;). The right hand side should include all fixed and random factors separated by <code>*</code>. Factor names should be single letters.</p>
</td></tr>
<tr><td><code id="ems_+3A_nested">nested</code></td>
<td>
<p>A <code>character</code> vector, where each element is of the form <code>"A/B"</code>, indicating that the levels of factor B are nested under the levels of factor A.</p>
</td></tr>
<tr><td><code id="ems_+3A_random">random</code></td>
<td>
<p>A <code>character</code> string indicating, without spaces or any separating characters, which of the factors specified in the design are random.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The returned value is a formatted table where the rows represent the mean squares, the columns represent the variance components that comprise the various mean squares, and the entries in each cell represent the terms that are multiplied and summed to form the expectation of the mean square for that row. Each term is either the lower-case version of one of the experimental factors, which indicates the number of levels for that factor, or a &quot;1&quot;, which means the variance component for that column is contributes to the mean square but is not multiplied by anything else.
</p>


<h3>Note</h3>

<p>Names for factors or parameters should only be of length 1 as they are simply concatenated in the returned table.
</p>


<h3>Author(s)</h3>

<p>Jake Westfall
</p>


<h3>See Also</h3>

<p>A detailed description with explanation of the example can be found <a href="https://web.archive.org/web/20210805121242/http://www.talkstats.com/threads/share-your-functions-code.18603/page-9#post-82050">elsewhere</a> (note that the <code>design</code> argument of the function described at the link behaves slightly different).
</p>
<p>Example applications of this function can be found here: <a href="https://stats.stackexchange.com/a/122662/442">https://stats.stackexchange.com/a/122662/442</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 2x2 mixed anova
# A varies between-subjects, B varies within-subjects
ems(r ~ A*B*S, nested="A/S", random="S")

# Clark (1973) example
# random Subjects, random Words, fixed Treatments
ems(r ~ S*W*T, nested="T/W", random="SW")

# EMSs for Clark design if Words are fixed
ems(r ~ S*W*T, nested="T/W", random="S")

</code></pre>

<hr>
<h2 id='fhch2010'>Data from Freeman, Heathcote, Chalmers, &amp; Hockley (2010)</h2><span id='topic+fhch2010'></span>

<h3>Description</h3>

<p>Lexical decision and word naming latencies for 300 words and 300 nonwords presented in Freeman, Heathcote, Chalmers, and Hockley (2010). The study had one between-subjects factors, <code>"task"</code> with two levels (<code>"naming"</code> or <code>"lexdec"</code>), and four within-subjects factors: <code>"stimulus"</code> type with two levels (<code>"word"</code> or <code>"nonword"</code>), word <code>"density"</code> and word <code>"frequency"</code> each with two levels (<code>"low"</code> and <code>"high"</code>) and stimulus <code>"length"</code> with three levels (4, 5, and 6).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fhch2010
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 13,222 obs. of 9 variables:
</p>

<dl>
<dt>id</dt><dd><p>participant id, <code>factor</code></p>
</dd>
<dt>task</dt><dd><p><code>factor</code> with two levels indicating which task was performed: <code>"naming"</code> or <code>"lexdec"</code></p>
</dd>
<dt>stimulus</dt><dd><p><code>factor</code> indicating whether the shown stimulus was a <code>"word"</code> or <code>"nonword"</code></p>
</dd>
<dt>density</dt><dd><p><code>factor</code> indicating the neighborhood density of presented items with two levels: <code>"low"</code> and <code>"high"</code>. Density is defined as the number of words that differ from a base word by one letter or phoneme.</p>
</dd>
<dt>frequency</dt><dd><p><code>factor</code> indicating the word frequency of presented items with two levels: <code>"low"</code> (i.e., words that occur less often in natural language) and <code>"high"</code> (i.e., words that occur more often in natural language).</p>
</dd>
<dt>length</dt><dd><p><code>factor</code> with 3 levels (4, 5, or 6) indicating the number of characters of presented stimuli.</p>
</dd>
<dt>item</dt><dd><p><code>factor</code> with 600 levels: 300 words and 300 nonwords</p>
</dd>
<dt>rt</dt><dd><p>response time in seconds</p>
</dd>
<dt>log_rt</dt><dd><p>natural logarithm of response time in seconds</p>
</dd>
<dt>correct</dt><dd><p>boolean indicating whether or not the response in the lexical decision task was correct or incorrect (incorrect responses of the naming task are not part of the data).</p>
</dd>
</dl>



<h3>Details</h3>

<p>In the lexical-decision condition (N = 25), subjects indicated whether each item was a word or a nonword, by pressing either the left (labeled word) or right (labeled nonword) outermost button on a 6-button response pad. The next study item appeared immediately after the lexical decision response was given. In the naming condition (N = 20), subjects were asked to name each item aloud, and items remained on screen for 3 s. Naming time was recorded by a voice key.
</p>
<p>Items consisted of 300 words, 75 in each set making up a factorial combination of high and low density and frequency, and 300 nonwords, with equal numbers of 4, 5, and 6 letter items in each set.
</p>


<h3>Source</h3>

<p>Freeman, E., Heathcote, A., Chalmers, K., &amp; Hockley, W. (2010). Item effects in recognition memory for words. Journal of Memory and Language, 62(1), 1-18. http://doi.org/10.1016/j.jml.2009.09.004
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("fhch2010")
str(fhch2010)

a1 &lt;- aov_ez("id", "log_rt", fhch2010, between = "task", 
             within = c("density", "frequency", "length", "stimulus"))
nice(a1)

if (requireNamespace("emmeans") &amp;&amp; requireNamespace("ggplot2")) {
  afex_plot(a1, "length", "frequency", c("task", "stimulus"), error = "within")
  
  afex_plot(a1, "density", "frequency", c("task", "stimulus"), error = "within")
}


## Not run: 
a2 &lt;- aov_ez("id", "rt", fhch2010, between = "task", 
             within = c("density", "frequency", "length", "stimulus"))
nice(a2)

if (requireNamespace("emmeans") &amp;&amp; requireNamespace("ggplot2")) {
  afex_plot(a2, "length", "frequency", c("task", "stimulus"), error = "within")
  
  afex_plot(a2, "density", "frequency", c("task", "stimulus"), error = "within")
}

## End(Not run)
</code></pre>

<hr>
<h2 id='ks2013.3'>Data from Klauer &amp; Singmann (2013, Experiment 3)</h2><span id='topic+ks2013.3'></span>

<h3>Description</h3>

<p>Klauer and Singmann (2013) attempted to replicate an hypothesis of Morsanyi and Handley (2012) according to which individuals have an intuitive sense of logicality. Specifically, Morsanyi and Handley apparently provided evidence that the logical status of syllogisms (i.e., valid or invalid) affects participants liking ratings of the conclusion of syllogisms. Conclusions from valid syllogisms (e.g., Some snakes are poisonous. No poisonous animals are obbs. Some snakes are not obbs.) received higher liking ratings than conclusions from invalid syllogisms (e.g.,  No ice creams are vons. Some vons are hot. Some ice creams are not hot.). It is important to noted that in the experiments participants were simply shown the premises and conclusion in succession, they were not asked whether or not the conclusion follows or to generate their own conclusion. Their task was simply to judge how much they liked the &quot;final&quot; statement (i.e., the conclusion).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ks2013.3
</code></pre>


<h3>Format</h3>

<p>A data.frame with 1440 rows and 6 variables.
</p>


<h3>Details</h3>

<p>In their Experiment 3 Klauer and Singmann (2013) tested the idea that this finding was a consequence of the materials used and not an effect intuitive logic. More specifically, they observed that in the original study by Morsanyi and Handley (2012) a specific content always appeared with the same logical status. For example, the &quot;ice-cream&quot; content only ever appeared as an invalid syllogism as in the example above but never in a valid syllogism. In other words, content was perfectly confounded with logical status in the original study. To test this they compared a condition in which the logical status was confounded with the content (the &quot;fixed&quot; condition) with a condition in which the contents were randomly assigned to a logical status across participants (the &quot;random&quot; condition). For example, the ice-cream content was, across participants, equally like to appear in the invalid form as given above or in the following valid form: No hot things are vons. Some vons are ice creams. Conclusion Some ice creams are not hot.
</p>
<p>The data.frame contains the raw responses of all 60 participants (30 per condition) reported in Klauer &amp; Singmann (2013). Each participants provided 24 responses, 12 to valid and 12 to invalid syllogisms. Furthermore, 8 syllogisms had a believable conclusion (e.g., Some ice creams are not hot.), 8 had an abstract conclusion (e.g., Some snakes are not obbs.), and 8 had an unbelievable conclusion (e.g., Some animals are not monkeys.). The number of the contents corresponds to the numbering given in Morsanyi and Handley (2012, p. 616).
</p>


<h3>Source</h3>

<p>Klauer, K. C., &amp; Singmann, H. (2013). Does logic feel good? Testing for intuitive detection of logicality in syllogistic reasoning. Journal of Experimental Psychology: Learning, Memory, and Cognition, 39(4), 1265-1273. http://doi.org/10.1037/a0030530
</p>
<p>Morsanyi, K., &amp; Handley, S. J. (2012). Logic feels so good-I like it! Evidence for intuitive detection of logicality in syllogistic reasoning. Journal of Experimental Psychology: Learning, Memory, and Cognition, 38(3), 596-616. http://doi.org/10.1037/a0026099
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("ks2013.3")

# replicate results reported in Klauer &amp; Singmann (2013, p. 1270)

aov_ez("id", "response", ks2013.3, between = "condition",
       within = c("believability", "validity"))

aov_ez("id", "response", subset(ks2013.3, condition == "fixed"),
       within = c("believability", "validity"))

aov_ez("id", "response", subset(ks2013.3, condition == "random"),
       within = c("believability", "validity"))
</code></pre>

<hr>
<h2 id='laptop_urry'>Replication of Laptop Note Taking Study (Urry et al. 2021, Psych. Science)</h2><span id='topic+laptop_urry'></span>

<h3>Description</h3>

<p>Original abstract: 
In this direct replication of Mueller and Oppenheimer’s (2014) Study 1,
participants watched a lecture while taking notes with a laptop (n = 74) or
longhand (n = 68). After a brief distraction and without the opportunity to
study, they took a quiz. As in the original study, laptop participants took
notes containing more words spoken verbatim by the lecturer and more words
overall than did longhand participants. However, laptop participants did not
perform better than longhand participants on the quiz.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>laptop_urry
</code></pre>


<h3>Format</h3>

<p>A data frame with 142 rows and 6 variables:
</p>

<dl>
<dt>pid</dt><dd><p>participant id, factor with 142 levels</p>
</dd>
<dt>condition</dt><dd><p>experimental condition (laptop, longhand), factor with 2 levels</p>
</dd>
<dt>talk</dt><dd><p>TED talk seen by participant, factor with 5 levels</p>
</dd>
<dt>overall</dt><dd><p>overall memory score ranging from 0 (= no memory) to 100 (= perfect memory).</p>
</dd>
<dt>factual</dt><dd><p>memory score on the factual questions ranging from 0 (= no memory) to 100 (= perfect memory).</p>
</dd>
<dt>conceptual</dt><dd><p>memory score on the conceptual questions ranging from 0 (= no memory) to 100 (= perfect memory).</p>
</dd>
</dl>



<h3>Details</h3>

<p>Own description:
</p>
<p>Heather Urry and 87 of her undergraduate and graduate students (yes, all 87
students are co-authors!) compared the effectiveness of taking notes on a
laptop versus longhand (i.e., pen and paper) for learning from lectures. 142
participants (which differed from the 88 authors) first viewed one of several
15 minutes lectures (TED talks) during which they were asked to take notes
either on a laptop or with pen and paper. Participants were randomly assigned
to either the laptop (N = 68) or longhand condition (N = 74). After a 30
minutes delay, participants were quizzed on the content of the lecture. There
were two types of questions, factual and conceptual questions. The answers
from each participant were then independently rated from several raters
(which agreed very strongly with each other) using a standardised scoring key
producing one memory score per participant and questions type ranging from 0
(= no memory) to 100 (= perfect memory). We also aggregated the two different
scores into one overall memory score.
</p>


<h3>Source</h3>

<p>Urry, H. L., Crittle, C. S., Floerke, V. A., Leonard, M. Z., Perry,
C. S., Akdilek, N., Albert, E. R., Block, A. J., Bollinger, C. A., Bowers,
E. M., Brody, R. S., Burk, K. C., Burnstein, A., Chan, A. K., Chan, P. C.,
Chang, L. J., Chen, E., Chiarawongse, C. P., Chin, G., … Zarrow, J. E.
(2021). Don’t Ditch the Laptop Just Yet: A Direct Replication of Mueller
and Oppenheimer’s (2014) Study 1 Plus Mini Meta-Analyses Across Similar
Studies. *Psychological Science*, 0956797620965541.
<a href="https://doi.org/10.1177/0956797620965541">doi:10.1177/0956797620965541</a>
</p>

<hr>
<h2 id='md_12.1'>Data 12.1 from Maxwell &amp; Delaney</h2><span id='topic+md_12.1'></span>

<h3>Description</h3>

<p>Hypothetical Reaction Time Data for 2 x 3 Perceptual Experiment: Example data for chapter 12 of Maaxwell and Delaney (2004, Table 12.1, p. 574) in long format. Has two within.subjects factors: angle and noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>md_12.1
</code></pre>


<h3>Format</h3>

<p>A data.frame with 60 rows and 4 variables.
</p>


<h3>Details</h3>

<p>Description from pp. 573:
</p>
<p>Suppose that a perceptual psychologist studying the visual system was interested in determining the
extent to which interfering visual stimuli slow the ability to recognize letters. Subjects are
brought into a laboratory and seated in front of a tachistoscope. Subjects are told that they will 
see either the letter T or the letter I displayed on the screen. In some trials, the letter appears 
by itself, but in other trials, the target letter is embedded in a group of other letters. This 
variation in the display constitutes the first factor, which is referred to as noise. The noise 
factor has two levels?absent and present. The other factor varied by the experimenter is where in 
the display the target letter appears. This factor, which is called angle, has three levels. The 
target letter is either shown at the center of the screen (i.e., 0° off-center, where the subject 
has been instructed to fixate), 4° off-center or 8° off-center (in each case, the deviation from the 
center varies randomly between left and right). Table 12.1 presents hypothetical data for 10 
subjects. As usual, the sample size is kept small to make the calculations easier to follow. The 
dependent measure is reaction time (latency), measured in milliseconds (ms), required by a subject 
to identify the correct target letter. Notice that each subject has six scores, one for each 
combination of the 2 x 3 design. In an actual perceptual experiment, each of these six scores would 
itself be the mean score for that subject across a number of trials in the particular condition. 
Although &quot;trials&quot; could be used as a third within-subjects factor in such a situation, more 
typically trials are simply averaged over to obtain a more stable measure of the individual's 
performance in each condition.
</p>


<h3>Source</h3>

<p>Maxwell, S. E., &amp; Delaney, H. D. (2004). Designing experiments and analyzing data: a model-comparisons perspective. Mahwah, N.J.: Lawrence Erlbaum Associates. p. 574
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(md_12.1)

# Table 12.5 (p. 578):
aov_ez("id", "rt", md_12.1, within = c("angle", "noise"), 
       args.return=list(correction = "none", es = "none"))


</code></pre>

<hr>
<h2 id='md_15.1'>Data 15.1 / 11.5 from Maxwell &amp; Delaney</h2><span id='topic+md_15.1'></span>

<h3>Description</h3>

<p>Hypothetical IQ Data from 12 children at 4 time points: Example data for chapter 11/15 of Maxwell and Delaney (2004, Table 15.1, p. 766) in long format. Has two one within-subjects factor: time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>md_15.1
</code></pre>


<h3>Format</h3>

<p>A data.frame with 48 rows and 4 variables.
</p>


<h3>Details</h3>

<p>Description from pp. 534:
</p>
<p>The data show that 12 subjects have been observed in each of 4 conditions. To make the example easier to discuss, let's suppose that the 12 subjects are children who have been observed at 30, 36, 42, and 48 months of age. In each case, the dependent variable is the child's age-normed general cognitive score on the McCarthy Scales of Children's Abilities. Although the test is normed so that the mean score is independent of age for the general population, our 12 children may come from a population in which cognitive abilities are either growing more rapidly or less rapidly than average. Indeed, this is the hypothesis our data allow us to address. In other words, although the sample means suggest that the children's cognitive abilities are growing, a significance test is needed if we want to rule out sampling error as a likely explanation for the observed differences.
</p>
<p>To replicate the results in chapter 15 several different contrasts need to be applied, see Examples.
</p>
<p><code>time</code> is time in months (centered at 0) and <code>timecat</code> is the same as a categorical variable.
</p>


<h3>Author(s)</h3>

<p>R code for examples written by Ulf Mertens and Henrik Singmann
</p>


<h3>Source</h3>

<p>Maxwell, S. E., &amp; Delaney, H. D. (2004). Designing experiments and analyzing data: a model-comparisons perspective. Mahwah, N.J.: Lawrence Erlbaum Associates. p. 766
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### replicate results from Table 15.2 to 15.6 (Maxwell &amp; Delaney, 2004, pp. 774)
data(md_15.1)

### ANOVA results (Table 15.2)
aov_4(iq ~ timecat + (timecat|id),data=md_15.1, anova_table=list(correction = "none"))

### Table 15.3 (random intercept only)
# we need to set the base level on the last level:
contrasts(md_15.1$timecat) &lt;- contr.treatment(4, base = 4)
# "Type 3 Tests of Fixed Effects"
(t15.3 &lt;- mixed(iq ~ timecat + (1|id),data=md_15.1, check.contrasts=FALSE))
# "Solution for Fixed Effects" and "Covariance Parameter Estimates"
summary(t15.3$full.model)

### make Figure 15.2
plot(NULL, NULL, ylim = c(80, 140), xlim = c(30, 48), ylab = "iq", xlab = "time")
plyr::d_ply(md_15.1, plyr::.(id), function(x) lines(as.numeric(as.character(x$timecat)), x$iq))

### Table 15.4, page 789
# random intercept plus slope
(t15.4 &lt;- mixed(iq ~ timecat + (1+time|id),data=md_15.1, check.contrasts=FALSE))
summary(t15.4$full.model)

### Table 15.5, page 795
# set up polynomial contrasts for timecat
contrasts(md_15.1$timecat) &lt;- contr.poly
# fit all parameters separately
(t15.5 &lt;- mixed(iq ~ timecat + (1+time|id), data=md_15.1, check.contrasts=FALSE,
                  per.parameter="timecat"))
# quadratic trend is considerably off, conclusions stay the same.


### Table 15.6, page 797
# growth curve model
(t15.6 &lt;- mixed(iq ~ time + (1+time|id),data=md_15.1))
summary(t15.6$full.model)

</code></pre>

<hr>
<h2 id='md_16.1'>Data 16.1 / 10.9 from Maxwell &amp; Delaney</h2><span id='topic+md_16.1'></span>

<h3>Description</h3>

<p>Hypothetical Reaction Time Data for 2 x 3 Perceptual Experiment: Example data for chapter 12 of Maaxwell and Delaney (2004, Table 12.1, p. 574) in long format. Has two within.subjects factors: angle and noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>md_16.1
</code></pre>


<h3>Format</h3>

<p>A data.frame with 24 rows and 3 variables.
</p>


<h3>Details</h3>

<p>Description from pp. 829:
</p>
<p>As brief background, the goal of the study here is to examine the extent to which female and male clinical psychology graduate student trainees may assign different severity ratings to clients at initial intake. Three female and 3 male graduate students are randomly selected to participate and each is randomly assigned four clients with whom to do an intake interview, after which each clinical trainee assigns a severity rating to each client, producing the data shown in Table 16.1.
</p>
<p>Note that I changed the labeling of the id slightly, so that they are now labeled from 1 to 6. Furthermore, I changed the contrasts of sex to <code>contr.treatment</code> to replicate the exact results of Table 16.3 (p. 837).
</p>


<h3>Source</h3>

<p>Maxwell, S. E., &amp; Delaney, H. D. (2004). Designing experiments and analyzing data: a model-comparisons perspective. Mahwah, N.J.: Lawrence Erlbaum Associates. p. 574
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### replicate results from Table 16.3 (Maxwell &amp; Delaney, 2004, p. 837)
data(md_16.1)

# original results need treatment contrasts:
(mixed1_orig &lt;- mixed(severity ~ sex + (1|id), md_16.1, check.contrasts=FALSE))
summary(mixed1_orig$full.model)

# p-values stay the same with afex default contrasts (contr.sum),
# but estimates and t-values for the fixed effects parameters change.
(mixed1 &lt;- mixed(severity ~ sex + (1|id), md_16.1))
summary(mixed1$full.model)

</code></pre>

<hr>
<h2 id='md_16.4'>Data 16.4 from Maxwell &amp; Delaney</h2><span id='topic+md_16.4'></span>

<h3>Description</h3>

<p>Data from a hypothetical inductive reasoning study.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>md_16.4
</code></pre>


<h3>Format</h3>

<p>A data.frame with 24 rows and 3 variables.
</p>


<h3>Details</h3>

<p>Description from pp. 841:
</p>
<p>Suppose an educational psychologist has developed an intervention to teach inductive reasoning skills to school children. She decides to test the efficacy of her intervention by conducting a randomized design. Three classrooms of students are randomly assigned to the treatment condition, and 3 other classrooms are assigned to the control.
</p>
<p>Table 16.4 shows hypothetical data collected from 29 children who participated in the study assessing the effectiveness of the intervention to increase inductive reasoning skills. We want to call your attention to several aspects of the data. First, the 15 children with condition values of 0 received the control, whereas the 14 children with condition values of 1 received the treatment. Second, 4 of the children in the control condition were students in control Classroom 1, 6 of them were students in control Classroom 2, and 5 were students in control Classroom 3. Along similar lines, 3 of the children in the treatment condition were students in treatment Classroom 1, 5 were students in treatment Classroom 2, and 6 were students in treatment Classroom 3. It is essential to understand that there are a total of six classrooms here; we have coded classroom from 1 to 3 for control as well as treatment, because we will indicate to PROC MIXED that classroom is nested under treatment. Third, scores on the dependent variable appear in the rightmost column under the variable label &quot;induct.&quot;
</p>
<p>Note that it would make a lot more sense to change the labeling of room from 1 to 3 nested within cond to 1 to 6. However, I keep this in line with the original. The random effects term in the call to mixed is therefore a little bit uncommon.#'
</p>


<h3>Source</h3>

<p>Maxwell, S. E., &amp; Delaney, H. D. (2004). Designing experiments and analyzing data: a model-comparisons perspective. Mahwah, N.J.: Lawrence Erlbaum Associates. p. 574
</p>


<h3>Examples</h3>

<pre><code class='language-R'># data for next examples (Maxwell &amp; Delaney, Table 16.4)
data(md_16.4)
str(md_16.4)

### replicate results from Table 16.6 (Maxwell &amp; Delaney, 2004, p. 845)
# p-values (almost) hold:
(mixed2 &lt;- mixed(induct ~ cond + (1|room:cond), md_16.4))
# (1|room:cond) is needed because room is nested within cond.


</code></pre>

<hr>
<h2 id='mixed'>p-values for fixed effects of mixed-model via lme4::lmer()</h2><span id='topic+mixed'></span><span id='topic+lmer_alt'></span>

<h3>Description</h3>

<p>Estimates mixed models with <span class="pkg">lme4</span> and calculates p-values
for all fixed effects. The default method <code>"KR"</code> (= Kenward-Roger) as
well as  <code>method="S"</code> (Satterthwaite) support LMMs and estimate the
model with <code><a href="lmerTest.html#topic+lmer">lmer</a></code> and then pass it to the
<code><a href="lmerTest.html#topic+lmerTest">lmerTest</a></code> <code>anova</code> method (or
<code><a href="car.html#topic+Anova">Anova</a></code>). The other methods (<code>"LRT"</code> =
likelihood-ratio tests and <code>"PB"</code> = parametric bootstrap) support both
LMMs (estimated via <code><a href="lme4.html#topic+lmer">lmer</a></code>) and GLMMs (i.e., with
<code>family</code> argument which invokes estimation via
<code><a href="lme4.html#topic+glmer">glmer</a></code>) and estimate a full model and restricted models
in which the parameters corresponding to one effect (i.e., model term) are
withhold (i.e., fixed to 0). Per default tests are based on Type 3 sums of
squares. <code>print</code>, <code>nice</code>, <code>anova</code>, and <code>summary</code>
methods for the returned object of class <code>"mixed"</code> are available.
<code>summary</code> invokes the default <span class="pkg">lme4</span> summary method and shows
parameters instead of effects.
</p>
<p><code>lmer_alt</code> is simply a wrapper for mixed that only returns the
<code>"lmerModLmerTest"</code> or <code>"merMod"</code> object and correctly uses the
<code>||</code> notation for removing correlations among factors. This function
otherwise behaves like <code>g/lmer</code> (as for <code>mixed</code>, it calls
<code>glmer</code> as soon as a <code>family</code> argument is present). Use
<code><a href="#topic+afex_options">afex_options</a></code><code>("lmer_function")</code> to set which function
for estimation should be used. This option determines the class of the
returned object (i.e., <code>"lmerModLmerTest"</code> or <code>"merMod"</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixed(
  formula,
  data,
  type = afex_options("type"),
  method = afex_options("method_mixed"),
  per_parameter = NULL,
  args_test = list(),
  test_intercept = FALSE,
  check_contrasts = afex_options("check_contrasts"),
  expand_re = FALSE,
  all_fit = FALSE,
  set_data_arg = afex_options("set_data_arg"),
  progress = interactive(),
  cl = NULL,
  return = "mixed",
  sig_symbols = afex_options("sig_symbols"),
  ...
)

lmer_alt(formula, data, check_contrasts = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixed_+3A_formula">formula</code></td>
<td>
<p>a formula describing the full mixed-model to be fitted. As
this formula is passed to <code>lmer</code>, it needs at least one random term.</p>
</td></tr>
<tr><td><code id="mixed_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> containing the data. Should have all the
variables present in <code>fixed</code>, <code>random</code>, and <code>dv</code> as columns.</p>
</td></tr>
<tr><td><code id="mixed_+3A_type">type</code></td>
<td>
<p>type of test on which effects are based. Default is to use type 3
tests, taken from <code><a href="#topic+afex_options">afex_options</a></code>.</p>
</td></tr>
<tr><td><code id="mixed_+3A_method">method</code></td>
<td>
<p>character vector indicating which methods for obtaining
p-values should be used: <code>"S"</code> corresponds to the Satterthwaite
approximation for degrees of freedom (via <code>lmerTest</code>, only
LMMs), <code>"KR"</code> corresponds to the Kenward-Roger approximation for
degrees of freedom (only LMMs), <code>"PB"</code> calculates p-values based on
parametric bootstrap, <code>"LRT"</code> calculates p-values via the likelihood
ratio tests implemented in the <code>anova</code> method for <code>merMod</code>
objects (only recommended for models with many [i.e., &gt; 50] levels for the
random factors). The default (currently <code>"S"</code>) is taken from
<code><a href="#topic+afex_options">afex_options</a></code>. For historical compatibility <code>"nested-KR"</code>
is also supported which was the default KR-method in previous versions.</p>
</td></tr>
<tr><td><code id="mixed_+3A_per_parameter">per_parameter</code></td>
<td>
<p><code>character</code> vector specifying for which variable
tests should be run for each parameter (instead for the overall effect).
Can be useful e.g., for testing ordered factors. Uses <code><a href="base.html#topic+grep">grep</a></code>
for selecting parameters among the fixed effects so regular expressions
(<code><a href="base.html#topic+regex">regex</a></code>) are possible. See Examples.</p>
</td></tr>
<tr><td><code id="mixed_+3A_args_test">args_test</code></td>
<td>
<p><code>list</code> of arguments passed to the function calculating
the p-values. See Details.</p>
</td></tr>
<tr><td><code id="mixed_+3A_test_intercept">test_intercept</code></td>
<td>
<p>logical. Whether or not the intercept should also be
fitted and tested for significance. Default is <code>FALSE</code>. Only relevant
if <code>type = 3</code>.</p>
</td></tr>
<tr><td><code id="mixed_+3A_check_contrasts">check_contrasts</code></td>
<td>
<p><code>logical</code>. Should contrasts be checked and (if
necessary) changed to <code>"contr.sum"</code>? See Details. The default
(<code>"TRUE"</code>) is taken from <code><a href="#topic+afex_options">afex_options</a></code>.</p>
</td></tr>
<tr><td><code id="mixed_+3A_expand_re">expand_re</code></td>
<td>
<p>logical. Should random effects terms be expanded (i.e.,
factors transformed into numerical variables) before fitting with
<code>(g)lmer</code>? Allows to use &quot;||&quot; notation with factors.</p>
</td></tr>
<tr><td><code id="mixed_+3A_all_fit">all_fit</code></td>
<td>
<p>logical. Should <code><a href="lme4.html#topic+allFit">allFit</a></code> be used to fit each
model with each available optimization algorithm and the results that
provided the best fit in each case be used? Warning: This can dramatically
increase the optimization time. Adds two new attributes to the returned
object designating which algorithm was selected and the log-likelihoods for
each algorithm. Note that only warnings from the initial fit are emitted
during fitting. The warnings of the chosen models are emitted when printing
the returned object.</p>
</td></tr>
<tr><td><code id="mixed_+3A_set_data_arg">set_data_arg</code></td>
<td>
<p><code>logical</code>. Should the data argument in the slot
<code>call</code> of the <code>merMod</code> object returned from <code>lmer</code> be set to
the passed data argument? If <code>FALSE</code> (currently the default) the name
will be <code>data</code>. <code>TRUE</code> may be helpful when fitted objects are
used afterwards (e.g., compared using <code>anova</code> or when using the
<code>effects</code> package, see examples). <span class="pkg">emmeans</span> functions appear to
work better with <code>FALSE</code>. Default is given by
afex_options(&quot;set_data_arg&quot;).</p>
</td></tr>
<tr><td><code id="mixed_+3A_progress">progress</code></td>
<td>
<p>if <code>TRUE</code>, shows progress with a text progress bar and
other status messages during estimation. The default is to set <code>TRUE</code>
for interactive usage and <code>FALSE</code> for non-interactive usage.</p>
</td></tr>
<tr><td><code id="mixed_+3A_cl">cl</code></td>
<td>
<p>A vector identifying a cluster; used for distributing the
estimation of the different models using several cores (if seveal models
are calculated). See examples. If <code>ckeck_contrasts = TRUE</code>, mixed sets
the current contrasts (<code>getOption("contrasts")</code>) at the nodes. Note
this does <em>not</em> distribute calculation of p-values (e.g., when using
<code>method = "PB"</code>) across the cluster. Use <code>args_test</code> for this.</p>
</td></tr>
<tr><td><code id="mixed_+3A_return">return</code></td>
<td>
<p>the default is to return an object of class <code>"mixed"</code>.
<code>return = "merMod"</code> will skip the calculation of all submodels and
p-values and simply return the full model estimated with <code>lmer</code> (note
that somewhat unintuiviely, the returned object can either be of class
<code>"lmerModLmerTest"</code> or of class <code>"merMod"</code>, depending on the
value of <code><a href="#topic+afex_options">afex_options</a></code><code>("lmer_function")</code>). Can be useful
in combination with <code>expand_re = TRUE</code> which allows to use &quot;||&quot; with
factors. <code>return = "data"</code> will not fit any models but just return the
data that would have been used for estimating the model (note that the data
is also part of the returned object).</p>
</td></tr>
<tr><td><code id="mixed_+3A_sig_symbols">sig_symbols</code></td>
<td>
<p>Character. What should be the symbols designating
significance? When entering an vector with <code>length(sig.symbol) &lt; 4</code>
only those elements of the default (<code>c(" +", " *", " **", " ***")</code>)
will be replaced. <code>sig_symbols = ""</code> will display the stars but not
the <code>+</code>, <code>sig_symbols = rep("", 4)</code> will display no symbols. The
default is given by <code>afex_options("sig_symbols")</code>.</p>
</td></tr>
<tr><td><code id="mixed_+3A_...">...</code></td>
<td>
<p>further arguments (such as <code>weights</code>, <code>family</code>, or
<code>control</code>) passed to <code><a href="#topic+lmer">lmer</a></code>/<code><a href="lme4.html#topic+glmer">glmer</a></code>. Note that
additional data (e.g., <code>weights</code>) need to be passed fully and not only
by name (e.g., <code>weights = df$weights</code> and not <code>weights =
weights</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For an introduction to mixed-modeling for experimental designs see
our chapter
(<a href="http://singmann.org/download/publications/singmann_kellen-introduction-mixed-models.pdf">Singmann
&amp; Kellen, in press</a>) or Barr, Levy, Scheepers, &amp; Tily (2013). Arguments for
using the Kenward-Roger approximation for obtaining p-values are given by
Judd, Westfall, and Kenny (2012). Further introductions to mixed-modeling
for experimental designs are given by Baayen and colleagues (Baayen, 2008;
Baayen, Davidson &amp; Bates, 2008; Baayen &amp; Milin, 2010). Specific
recommendations on which random effects structure to specify for
confirmatory tests can be found in Barr and colleagues (2013) and Barr
(2013), but also see Bates et al. (2015).
</p>


<h4>p-value Calculations</h4>

<p>When <code>method = "KR"</code> (implemented via
<code><a href="pbkrtest.html#topic+KRmodcomp">KRmodcomp</a></code>), the Kenward-Roger approximation for
degrees-of-freedom is calculated using <code><a href="lmerTest.html#topic+lmerTest">lmerTest</a></code> (if
<code>test_intercept=FALSE</code>) or <code><a href="car.html#topic+Anova">Anova</a></code> (if
<code>test_intercept=TRUE</code>), which is only applicable to linear-mixed models
(LMMs). The test statistic in the output is an F-value (<code>F</code>). A similar
method that requires less RAM is <code>method = "S"</code> which calculates the
Satterthwaite approximation for degrees-of-freedom via
<code><a href="lmerTest.html#topic+lmerTest">lmerTest</a></code> and is also only applicable to LMMs.
<code>method = "KR"</code> or <code>method = "S"</code> provide the best control for
Type 1 errors for LMMs (Luke, 2017).
</p>
<p><code>method = "PB"</code> calculates p-values using parametric bootstrap using
<code><a href="pbkrtest.html#topic+PBmodcomp">PBmodcomp</a></code>. This can be used for linear and also
generalized linear mixed models (GLMMs) by specifying a
<code><a href="stats.html#topic+family">family</a></code> argument to <code>mixed</code>. Note that you should
specify further arguments to <code>PBmodcomp</code> via <code>args_test</code>,
especially <code>nsim</code> (the number of simulations to form the reference
distribution) or <code>cl</code> (for using multiple cores). For other arguments
see <code><a href="pbkrtest.html#topic+PBmodcomp">PBmodcomp</a></code>. Note that <code>REML</code> (argument to
<code>[g]lmer</code>) will be set to <code>FALSE</code> if method is <code>PB</code>.
</p>
<p><code>method = "LRT"</code> calculates p-values via likelihood ratio tests
implemented in the <code>anova</code> method for <code>"merMod"</code> objects. This is
the method recommended by Barr et al. (2013; which did not test the other
methods implemented here). Using likelihood ratio tests is only recommended
for models with many levels for the random effects (&gt; 50), but can be pretty
helpful in case the other methods fail (due to memory and/or time
limitations). The
<a href="http://bbolker.github.io/mixedmodels-misc/glmmFAQ.html">lme4 faq</a> also
recommends the other methods over likelihood ratio tests. </p>



<h4>Implementation Details</h4>

<p>For methods <code>"KR"</code> and <code>"S"</code> type 3 and 2 tests are implemented as
in <code><a href="car.html#topic+Anova">Anova</a></code>.
</p>
<p>For all other methods, type 3 tests are obtained by comparing a model in
which only the tested effect is excluded with the full model (containing all
effects). For method <code>"nested-KR"</code> (which was the default in previous
versions) this corresponds to the (type 3) Wald tests given by
<code>car::Anova</code> for <code>"lmerMod"</code> models. The submodels in which the
tested effect is excluded are obtained by manually creating a model matrix
which is then fitted in <code>"lme4"</code>.
</p>
<p>Type 2 tests are truly sequential. They are obtained by comparing a model in
which the tested effect and all higher oder effect (e.g., all three-way
interactions for testing a two-way interaction) are excluded with a model in
which only effects up to the order of the tested effect are present and all
higher order effects absent. In other words, there are multiple full models,
one for each order of effects. Consequently, the results for lower order
effects are identical of whether or not higher order effects are part of the
model or not. This latter feature is not consistent with classical ANOVA
type 2 tests but a consequence of the sequential tests (and
<a href="https://stat.ethz.ch/pipermail/r-sig-mixed-models/2012q3/018992.html">I
didn't find a better way</a> of implementing the Type 2 tests). This
<strong>does not</strong> correspond to the (type 2) Wald test reported by
<code>car::Anova</code>.
</p>
<p>If <code>check_contrasts = TRUE</code>, contrasts will be set to
<code>"contr.sum"</code> for all factors in the formula if default contrasts are
not equal to <code>"contr.sum"</code> or <code>attrib(factor, "contrasts") !=
 "contr.sum"</code>. Furthermore, the current contrasts (obtained via
<code>getOption("contrasts")</code>) will be set at the cluster nodes if <code>cl</code>
is not <code>NULL</code>. </p>



<h4>Expand Random Effects</h4>

 <p><code>expand_re = TRUE</code> allows to expand
the random effects structure before passing it to <code>lmer</code>. This allows
to disable estimation of correlation among random effects for random effects
term containing factors using the <code>||</code> notation which may aid in
achieving model convergence (see Bates et al., 2015). This is achieved by
first creating a model matrix for each random effects term individually,
rename and append the so created columns to the data that will be fitted,
replace the actual random effects term with the so created variables
(concatenated with +), and then fit the model. The variables are renamed by
prepending all variables with rei (where i is the number of the random
effects term) and replacing &quot;:&quot; with &quot;_by_&quot;.
</p>
<p><code>lmer_alt</code> is simply a wrapper for <code>mixed</code> that is intended to
behave like <code>lmer</code> (or <code>glmer</code> if a <code>family</code> argument is
present), but also allows the use of <code>||</code> with factors (by always using
<code>expand_re = TRUE</code>). This means that <code>lmer_alt</code> per default does
not enforce a specific contrast on factors and only returns the
<code>"lmerModLmerTest"</code> or <code>"merMod"</code> object without calculating any
additional models or p-values (this is achieved by setting <code>return =
 "merMod"</code>). Note that it most likely differs from <code>g/lmer</code> in how it
handles missing values so it is recommended to only pass data without
missing values to it!
</p>
<p>One consequence of using <code>expand_re = TRUE</code> is that the data that is
fitted will not be the same as the passed data.frame which can lead to
problems with e.g., the <code>predict</code> method. However, the actual data used
for fitting is also returned as part of the <code>mixed</code> object so can be
used from there. Note that the <code>set_data_arg</code> can be used to change
whether the <code>data</code> argument in the call to <code>g/lmer</code> is set to
<code>data</code> (the default) or the name of the data argument passed by the
user. </p>



<h3>Value</h3>

<p>An object of class <code>"mixed"</code> (i.e., a list) with the following
elements:
</p>

<ol>
<li> <p><code>anova_table</code> a data.frame containing the statistics returned
from <code><a href="pbkrtest.html#topic+KRmodcomp">KRmodcomp</a></code>. The <code>stat</code> column in this
data.frame gives the value of the test statistic, an F-value for
<code>method = "KR"</code> and a chi-square value for the other two methods.
</p>
</li>
<li> <p><code>full_model</code> the <code>"lmerModLmerTest"</code> or <code>"merMod"</code>
object returned from estimating the full model. Use
<code><a href="#topic+afex_options">afex_options</a></code><code>("lmer_function")</code> for setting which
function for estimation should be used. The possible options are
<code>"lmerTest"</code> (the default returning an object of class
<code>"lmerModLmerTest"</code>) and <code>"lme4"</code> returning an object of class
(<code>"merMod"</code>). Note that in case a <code>family</code> argument is present
an object of class <code>"glmerMod"</code> is always returned.
</p>
</li>
<li> <p><code>restricted_models</code> a list of <code>"g/lmerMod"</code> (or 
<code>"lmerModLmerTest"</code>) objects from estimating the restricted models
(i.e., each model lacks the corresponding effect)
</p>
</li>
<li> <p><code>tests</code> a list of objects returned by the function for 
obtaining the p-values.
</p>
</li>
<li> <p><code>data</code> The data used for estimation (i.e., after excluding 
missing rows and applying expand_re if requested).
</p>
</li>
<li> <p><code>call</code> The matched call.
</p>
</li></ol>

<p>It also has the following attributes, <code>"type"</code> and <code>"method"</code>. And
the attributes <code>"all_fit_selected"</code> and <code>"all_fit_logLik"</code> if
<code>all_fit=TRUE</code>.
</p>
<p>Two similar methods exist for objects of class <code>"mixed"</code>: <code>print</code>
and <code>anova</code>. They print a nice version of the <code>anova_table</code> element
of the returned object (which is also invisibly returned). This methods omit
some columns and nicely round the other columns. The following columns are
always printed:
</p>

<ol>
<li> <p><code>Effect</code> name of effect
</p>
</li>
<li> <p><code>p.value</code> estimated p-value for the effect
</p>
</li></ol>

<p>For LMMs with <code>method="KR"</code> or <code>method="S"</code> the following further
columns are returned (note: the Kenward-Roger correction does two separate
things: (1) it computes an effective number for the denominator df; (2) it
scales the statistic by a calculated amount, see also
<a href="https://stackoverflow.com/a/25612960/289572">https://stackoverflow.com/a/25612960/289572</a>):
</p>

<ol>
<li> <p><code>F</code> computed F statistic
</p>
</li>
<li> <p><code>ndf</code> numerator degrees of freedom (number of parameters used
for the effect)
</p>
</li>
<li> <p><code>ddf</code> denominator degrees of freedom (effective residual 
degrees of freedom for testing the effect), computed from the
Kenward-Roger correction using <code>pbkrtest::KRmodcomp</code>
</p>
</li>
<li> <p><code>F.scaling</code> scaling of F-statistic computing from Kenward-Roger 
approximation (only printed if <code>method="nested-KR"</code>)
</p>
</li></ol>

<p>For models with <code>method="LRT"</code> the following further columns are
returned:
</p>

<ol>
<li> <p><code>df.large</code> degrees of freedom (i.e., estimated paramaters) for 
full model (i.e., model containing the corresponding effect)
</p>
</li>
<li> <p><code>df.small</code> degrees of freedom (i.e., estimated paramaters) for 
restricted model (i.e., model without the corresponding effect)
</p>
</li>
<li> <p><code>chisq</code> 2 times the difference in likelihood (obtained with 
<code>logLik</code>) between full and restricted model
</p>
</li>
<li> <p><code>df</code> difference in degrees of freedom between full and 
restricted model (p-value is based on these df).
</p>
</li></ol>

<p>For models with <code>method="PB"</code> the following further column is returned:
</p>

<ol>
<li> <p><code>stat</code> 2 times the difference in likelihood (obtained with 
<code>logLik</code>) between full and restricted model (i.e., a chi-square
value).
</p>
</li></ol>

<p>Note that  <code>anova</code> can also be called with additional mixed and/or
<code>merMod</code> objects. In this casethe full models are passed on to
<code>anova.merMod</code> (with <code>refit=FALSE</code>, which differs from the default
of <code>anova.merMod</code>) which produces the known LRT tables.
</p>
<p>The <code>summary</code> method for objects of class <code>mixed</code> simply calls
<code><a href="lme4.html#topic+summary.merMod">summary.merMod</a></code> on the full model.
</p>
<p>If <code>return = "merMod"</code> (or when invoking <code>lmer_alt</code>), an object of
class <code>"lmerModLmerTest"</code> or of class <code>"merMod"</code> (depending on the
value of <code><a href="#topic+afex_options">afex_options</a></code><code>("lmer_function")</code>), as returned
from <code>g/lmer</code>, is returned. The default behavior is to return an object
of class <code>"lmerModLmerTest"</code> estimated via <code><a href="lmerTest.html#topic+lmer">lmer</a></code>.
</p>


<h3>Note</h3>

<p>When <code>method = "KR"</code>, obtaining p-values is known to crash due too
insufficient memory or other computational limitations (especially with
complex random effects structures). In these cases, the other methods
should be used. The RAM demand is a problem especially on 32 bit Windows
which only supports up to 2 or 3GB RAM (see
<a href="https://CRAN.R-project.org/bin/windows/base/rw-FAQ.html">R Windows
FAQ</a>). Then it is probably a good idea to use methods &quot;S&quot;, &quot;LRT&quot;, or &quot;PB&quot;.
</p>
<p><code>"mixed"</code> will throw a message if numerical variables are not centered
on 0, as main effects (of other variables then the numeric one) can be hard
to interpret if numerical variables appear in interactions. See Dalal &amp;
Zickar (2012).
</p>
<p>Per default <code>mixed</code> uses <code><a href="lmerTest.html#topic+lmer">lmer</a></code>, this can be
changed to <code><a href="lme4.html#topic+lmer">lmer</a></code> by calling:
<code>afex_options(lmer_function = "lme4")</code>
</p>
<p>Formulas longer than 500 characters will most likely fail due to the use of
<code><a href="base.html#topic+deparse">deparse</a></code>.
</p>
<p>Please report bugs or unexpected behavior by opening a guthub issue:
<a href="https://github.com/singmann/afex/issues">https://github.com/singmann/afex/issues</a>
</p>


<h3>Author(s)</h3>

<p>Henrik Singmann with contributions from
<a href="https://stackoverflow.com/q/11335923/289572">Ben Bolker and Joshua
Wiley</a>.
</p>


<h3>References</h3>

<p>Baayen, R. H. (2008). <em>Analyzing linguistic data: a
practical introduction to statistics using R</em>. Cambridge, UK; New York:
Cambridge University Press.
</p>
<p>Baayen, R. H., Davidson, D. J., &amp; Bates, D. M. (2008). Mixed-effects
modeling with crossed random effects for subjects and items. <em>Journal
of Memory and Language</em>, 59(4), 390-412. <a href="https://doi.org/10.1016/j.jml.2007.12.005">doi:10.1016/j.jml.2007.12.005</a>
</p>
<p>Baayen, R. H., &amp; Milin, P. (2010). Analyzing Reaction Times.
<em>International Journal of Psychological Research</em>, 3(2), 12-28.
</p>
<p>Barr, D. J. (2013). Random effects structure for testing interactions in
linear mixed-effects models. <em>Frontiers in Quantitative Psychology and
Measurement</em>, 328. <a href="https://doi.org/10.3389/fpsyg.2013.00328">doi:10.3389/fpsyg.2013.00328</a>
</p>
<p>Barr, D. J., Levy, R., Scheepers, C., &amp; Tily, H. J. (2013). Random effects
structure for confirmatory hypothesis testing: Keep it maximal.
<em>Journal of Memory and Language</em>, 68(3), 255-278.
<a href="https://doi.org/10.1016/j.jml.2012.11.001">doi:10.1016/j.jml.2012.11.001</a>
</p>
<p>Bates, D., Kliegl, R., Vasishth, S., &amp; Baayen, H. (2015).
<em>Parsimonious Mixed Models</em>. arXiv:1506.04967 [stat]. Retrieved from
<a href="https://arxiv.org/abs/1506.04967">https://arxiv.org/abs/1506.04967</a>
</p>
<p>Dalal, D. K., &amp; Zickar, M. J. (2012). Some Common Myths About Centering
Predictor Variables in Moderated Multiple Regression and Polynomial
Regression. <em>Organizational Research Methods</em>, 15(3), 339-362.
<a href="https://doi.org/10.1177/1094428111430540">doi:10.1177/1094428111430540</a>
</p>
<p>Judd, C. M., Westfall, J., &amp; Kenny, D. A. (2012). Treating stimuli as a
random factor in social psychology: A new and comprehensive solution to a
pervasive but largely ignored problem. <em>Journal of Personality and
Social Psychology</em>, 103(1), 54-69. <a href="https://doi.org/10.1037/a0028347">doi:10.1037/a0028347</a>
</p>
<p>Luke, S. (2017). Evaluating significance in linear mixed-effects models in
R. <em>Behavior Research Methods</em>.
<a href="https://doi.org/10.3758/s13428-016-0809-y">doi:10.3758/s13428-016-0809-y</a>
</p>
<p>Maxwell, S. E., &amp; Delaney, H. D. (2004). <em>Designing experiments and
analyzing data: a model-comparisons perspective.</em> Mahwah, N.J.: Lawrence
Erlbaum Associates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aov_ez">aov_ez</a></code> and <code><a href="#topic+aov_car">aov_car</a></code> for convenience
functions to analyze experimental desIgns with classical ANOVA or ANCOVA
wrapping <code><a href="car.html#topic+Anova">Anova</a></code>.
</p>
<p>see the following for the data sets from Maxwell and Delaney (2004) used
and more examples: <code><a href="#topic+md_15.1">md_15.1</a></code>, <code><a href="#topic+md_16.1">md_16.1</a></code>, and
<code><a href="#topic+md_16.4">md_16.4</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##################################
## Simple Examples (from MEMSS) ##
##################################

if (requireNamespace("MEMSS")) {
data("Machines", package = "MEMSS") 

# simple model with random-slopes for repeated-measures factor
m1 &lt;- mixed(score ~ Machine + (Machine|Worker), data=Machines)
m1

# suppress correlations among random effect parameters with || and expand_re = TRUE
m2 &lt;- mixed(score ~ Machine + (Machine||Worker), data=Machines, expand_re = TRUE)
m2

## compare:
summary(m1)$varcor
summary(m2)$varcor
# for wrong solution see: 
# summary(lmer(score ~ Machine + (Machine||Worker), data=Machines))$varcor

if (requireNamespace("emmeans")) {
# follow-up tests
library("emmeans")  # package emmeans needs to be attached for follow-up tests.
(emm1 &lt;- emmeans(m1, "Machine"))
pairs(emm1, adjust = "holm") # all pairwise comparisons
con1 &lt;- list(
  c1 = c(1, -0.5, -0.5), # 1 versus other 2
  c2 = c(0.5, -1, 0.5) # 1 and 3 versus  2
)
contrast(emm1, con1, adjust = "holm")

if (requireNamespace("ggplot2")) {
# plotting 
afex_plot(m1, "Machine") ## default uses model-based CIs
## within-subjects CIs somewhat more in line with pairwirse comparisons:
afex_plot(m1, "Machine", error = "within") 

## less differences between CIs for model without correlations:
afex_plot(m2, "Machine")
afex_plot(m2, "Machine", error = "within")
}}}

## Not run: 
#######################
### Further Options ###
#######################

## Multicore:

require(parallel)
(nc &lt;- detectCores()) # number of cores
cl &lt;- makeCluster(rep("localhost", nc)) # make cluster
# to keep track of what the function is doindg redirect output to outfile:
# cl &lt;- makeCluster(rep("localhost", nc), outfile = "cl.log.txt")

data("Machines", package = "MEMSS") 
## There are two ways to use multicore:

# 1. Obtain fits with multicore (e.g. for likelihood ratio tests, LRT):
mixed(score ~ Machine + (Machine|Worker), data=Machines, cl = cl, 
      method = "LRT")

# 2. Obtain PB samples via multicore: 
mixed(score ~ Machine + (Machine|Worker), data=Machines,
 method = "PB", args_test = list(nsim = 50, cl = cl)) # better use 500 or 1000 

## Both ways can be combined:
# 2. Obtain PB samples via multicore: 
mixed(score ~ Machine + (Machine|Worker), data=Machines, cl = cl,
 method = "PB", args_test = list(nsim = 50, cl = cl))

#### use all_fit = TRUE and expand_re = TRUE:
data("sk2011.2") # data described in more detail below
sk2_aff &lt;- droplevels(sk2011.2[sk2011.2$what == "affirmation",])

require(optimx) # uses two more algorithms
sk2_aff_b &lt;- mixed(response ~ instruction*type+(inference*type||id), sk2_aff,
               expand_re = TRUE, all_fit = TRUE, method = "LRT")
attr(sk2_aff_b, "all_fit_selected")
attr(sk2_aff_b, "all_fit_logLik")

# considerably faster with multicore:
clusterEvalQ(cl, library(optimx)) # need to load optimx in cluster
sk2_aff_b2 &lt;- mixed(response ~ instruction*type+(inference*type||id), sk2_aff,
               expand_re = TRUE, all_fit = TRUE, cl=cl, method = "LRT")
attr(sk2_aff_b2, "all_fit_selected")
attr(sk2_aff_b2, "all_fit_logLik")


stopCluster(cl)


## End(Not run)

###################################################
## Replicating Maxwell &amp; Delaney (2004) Examples ##
###################################################
## Not run: 

### replicate results from Table 15.4 (Maxwell &amp; Delaney, 2004, p. 789)
data(md_15.1)
# random intercept plus random slope
(t15.4a &lt;- mixed(iq ~ timecat + (1+time|id),data=md_15.1))

# to also replicate exact parameters use treatment.contrasts and the last level as base level:
contrasts(md_15.1$timecat) &lt;- contr.treatment(4, base = 4)
(t15.4b &lt;- mixed(iq ~ timecat + (1+time|id),data=md_15.1, check_contrasts=FALSE))
summary(t15.4a)  # gives "wrong" parameters extimates
summary(t15.4b)  # identical parameters estimates

# for more examples from chapter 15 see ?md_15.1

### replicate results from Table 16.3 (Maxwell &amp; Delaney, 2004, p. 837)
data(md_16.1)

# original results need treatment contrasts:
(mixed1_orig &lt;- mixed(severity ~ sex + (1|id), md_16.1, check_contrasts=FALSE))
summary(mixed1_orig$full_model)

# p-value stays the same with afex default contrasts (contr.sum),
# but estimates and t-values for the fixed effects parameters change.
(mixed1 &lt;- mixed(severity ~ sex + (1|id), md_16.1))
summary(mixed1$full_model)


# data for next examples (Maxwell &amp; Delaney, Table 16.4)
data(md_16.4)
str(md_16.4)

### replicate results from Table 16.6 (Maxwell &amp; Delaney, 2004, p. 845)
# Note that (1|room:cond) is needed because room is nested within cond.
# p-value (almost) holds.
(mixed2 &lt;- mixed(induct ~ cond + (1|room:cond), md_16.4))
# (differences are dut to the use of Kenward-Roger approximation here,
# whereas M&amp;W's p-values are based on uncorrected df.)

# again, to obtain identical parameter and t-values, use treatment contrasts:
summary(mixed2) # not identical

# prepare new data.frame with contrasts:
md_16.4b &lt;- within(md_16.4, cond &lt;- C(cond, contr.treatment, base = 2))
str(md_16.4b)

# p-value stays identical:
(mixed2_orig &lt;- mixed(induct ~ cond + (1|room:cond), md_16.4b, 
                      check_contrasts=FALSE))
summary(mixed2_orig$full_model) # replicates parameters


### replicate results from Table 16.7 (Maxwell &amp; Delaney, 2004, p. 851)
# F-values (almost) hold, p-values (especially for skill) are off
(mixed3 &lt;- mixed(induct ~ cond + skill + (1|room:cond), md_16.4))

# however, parameters are perfectly recovered when using the original contrasts:
mixed3_orig &lt;- mixed(induct ~ cond + skill + (1|room:cond), md_16.4b, 
                     check_contrasts=FALSE)
summary(mixed3_orig)


### replicate results from Table 16.10 (Maxwell &amp; Delaney, 2004, p. 862)
# for this we need to center cog:
md_16.4b$cog &lt;- scale(md_16.4b$cog, scale=FALSE)

# F-values and p-values are relatively off:
(mixed4 &lt;- mixed(induct ~ cond*cog + (cog|room:cond), md_16.4b))
# contrast has a relatively important influence on cog
(mixed4_orig &lt;- mixed(induct ~ cond*cog + (cog|room:cond), md_16.4b, 
                      check_contrasts=FALSE))

# parameters are again almost perfectly recovered:
summary(mixed4_orig)

## End(Not run)

###########################
## Full Analysis Example ##
###########################

## Not run: 
### split-plot experiment (Singmann &amp; Klauer, 2011, Exp. 2)
## between-factor: instruction
## within-factor: inference &amp; type
## hypothesis: three-way interaction
data("sk2011.2")

# use only affirmation problems (S&amp;K also splitted the data like this)
sk2_aff &lt;- droplevels(sk2011.2[sk2011.2$what == "affirmation",])

# set up model with maximal by-participant random slopes 
sk_m1 &lt;- mixed(response ~ instruction*inference*type+(inference*type|id), sk2_aff)

sk_m1 # prints ANOVA table with nicely rounded numbers (i.e., as characters)
nice(sk_m1)  # returns the same but without printing potential warnings
anova(sk_m1) # returns and prints numeric ANOVA table (i.e., not-rounded)
summary(sk_m1) # lmer summary of full model

# same model but using Kenward-Roger approximation of df
# very similar results but slower
sk_m1b &lt;- mixed(response ~ instruction*inference*type+(inference*type|id), 
                sk2_aff, method="KR")
nice(sk_m1b)
# identical results as:
anova(sk_m1$full_model)

# suppressing correlation among random slopes: very similar results, but
# significantly faster and often less convergence warnings.
sk_m2 &lt;- mixed(response ~ instruction*inference*type+(inference*type||id), sk2_aff,
               expand_re = TRUE)
sk_m2

## mixed objects can be passed to emmeans
library("emmeans")  # however, package emmeans needs to be attached first

# emmeans also approximate df which takes time with default Kenward-Roger
emm_options(lmer.df = "Kenward-Roger") # default setting, slow
emm_options(lmer.df = "Satterthwaite") # faster setting, preferrable
emm_options(lmer.df = "asymptotic") # the fastest, df = infinity


# recreates basically Figure 4 (S&amp;K, 2011, upper panel)
# only the 4th and 6th x-axis position are flipped
afex_plot(sk_m1, x = c("type", "inference"), trace = "instruction")

# set up reference grid for custom contrasts:
(rg1 &lt;- emmeans(sk_m1, c("instruction", "type", "inference")))

# set up contrasts on reference grid:
contr_sk2 &lt;- list(
  ded_validity_effect = c(rep(0, 4), 1, rep(0, 5), -1, 0),
  ind_validity_effect = c(rep(0, 5), 1, rep(0, 5), -1),
  counter_MP = c(rep(0, 4), 1, -1, rep(0, 6)),
  counter_AC = c(rep(0, 10), 1, -1)
)

# test the main double dissociation (see S&amp;K, p. 268)
contrast(rg1, contr_sk2, adjust = "holm")
# all effects are significant.

## End(Not run)

####################
## Other Examples ##
####################

## Not run: 

# use the obk.long data (not reasonable, no random slopes)
data(obk.long)
mixed(value ~ treatment * phase + (1|id), obk.long)

# Examples for using the per.parameter argument 
# note, require method = "nested-KR", "LRT", or "PB" 
# also we use custom contrasts
data(obk.long, package = "afex")
obk.long$hour &lt;- ordered(obk.long$hour)
contrasts(obk.long$phase) &lt;- "contr.sum"
contrasts(obk.long$treatment) &lt;- "contr.sum" 

# tests only the main effect parameters of hour individually per parameter.
mixed(value ~ treatment*phase*hour +(1|id), per_parameter = "^hour$", 
      data = obk.long, method = "nested-KR", check_contrasts = FALSE)

# tests all parameters including hour individually
mixed(value ~ treatment*phase*hour +(1|id), per_parameter = "hour", 
      data = obk.long, method = "nested-KR", check_contrasts = FALSE)

# tests all parameters individually
mixed(value ~ treatment*phase*hour +(1|id), per_parameter = ".", 
      data = obk.long, method = "nested-KR", check_contrasts = FALSE)

# example data from package languageR: Lexical decision latencies elicited from
# 21 subjects for 79 English concrete nouns, with variables linked to subject or
# word.
data(lexdec, package = "languageR")

# using the simplest model
m1 &lt;- mixed(RT ~ Correct + Trial + PrevType * meanWeight + 
    Frequency + NativeLanguage * Length + (1|Subject) + (1|Word), data = lexdec)
m1
# Mixed Model Anova Table (Type 3 tests, S-method)
# 
# Model: RT ~ Correct + Trial + PrevType * meanWeight + Frequency + NativeLanguage * 
# Model:     Length + (1 | Subject) + (1 | Word)
# Data: lexdec
#                  Effect         df         F p.value
# 1               Correct 1, 1627.67   8.16 **    .004
# 2                 Trial 1, 1591.92   7.58 **    .006
# 3              PrevType 1, 1605.05      0.17    .680
# 4            meanWeight   1, 74.37 14.85 ***   &lt;.001
# 5             Frequency   1, 75.06 56.54 ***   &lt;.001
# 6        NativeLanguage   1, 27.12      0.70    .412
# 7                Length   1, 74.80   8.70 **    .004
# 8   PrevType:meanWeight 1, 1600.79    6.19 *    .013
# 9 NativeLanguage:Length 1, 1554.49 14.24 ***   &lt;.001
# ---
# Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘+’ 0.1 ‘ ’ 1

# Fitting a GLMM using parametric bootstrap:
require("mlmRev") # for the data, see ?Contraception

gm1 &lt;- mixed(use ~ age + I(age^2) + urban + livch + (1 | district), method = "PB",
 family = binomial, data = Contraception, args_test = list(nsim = 10))
## note that nsim = 10 is way too low for all real examples!


## End(Not run)

## Not run: 
#####################################
## Interplay with effects packages ##
#####################################

data("Machines", package = "MEMSS") 
# simple model with random-slopes for repeated-measures factor
m1 &lt;- mixed(score ~ Machine + (Machine|Worker), data=Machines, 
            set_data_arg = TRUE) ## necessary for it to work!
  
library("effects")

Effect("Machine", m1$full_model) # not correct:
#  Machine effect
# Machine
#        A        B        C 
# 59.65000 52.35556 60.32222 

# compare:
emmeans::emmeans(m1, "Machine")
 # Machine   emmean       SE  df asymp.LCL asymp.UCL
 # A       52.35556 1.680711 Inf  49.06142  55.64969
 # B       60.32222 3.528546 Inf  53.40640  67.23804
 # C       66.27222 1.806273 Inf  62.73199  69.81245

## necessary to set contr.sum globally:
set_sum_contrasts()
Effect("Machine", m1$full_model)
#  Machine effect
# Machine
#        A        B        C 
# 52.35556 60.32222 66.27222 

plot(Effect("Machine", m1$full_model))

## End(Not run)
</code></pre>

<hr>
<h2 id='nice'>Make nice ANOVA table for printing.</h2><span id='topic+nice'></span><span id='topic+nice.afex_aov'></span><span id='topic+nice.anova'></span><span id='topic+nice.mixed'></span><span id='topic+print.nice_table'></span>

<h3>Description</h3>

<p>This generic function produces a nice ANOVA table for printing for objects of
class. <code>nice_anova</code> takes an object from <code><a href="car.html#topic+Anova">Anova</a></code>
possible created by the convenience functions <code><a href="#topic+aov_ez">aov_ez</a></code> or
<code><a href="#topic+aov_car">aov_car</a></code>. When within-subject factors are present, either
sphericity corrected or uncorrected degrees of freedom can be reported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nice(object, ...)

## S3 method for class 'afex_aov'
nice(
  object,
  es = attr(object$anova_table, "es"),
  observed = attr(object$anova_table, "observed"),
  correction = attr(object$anova_table, "correction"),
  MSE = NULL,
  intercept = NULL,
  p_adjust_method = attr(object$anova_table, "p_adjust_method"),
  sig_symbols = attr(object$anova_table, "sig_symbols"),
  round_ps = attr(object$anova_table, "round_ps"),
  ...
)

## S3 method for class 'anova'
nice(
  object,
  MSE = NULL,
  intercept = NULL,
  sig_symbols = attr(object, "sig_symbols"),
  round_ps = attr(object, "round_ps"),
  sig.symbols,
  ...
)

## S3 method for class 'mixed'
nice(
  object,
  sig_symbols = attr(object$anova_table, "sig_symbols"),
  round_ps = attr(object$anova_table, "round_ps"),
  ...
)

## S3 method for class 'nice_table'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nice_+3A_object">object</code>, <code id="nice_+3A_x">x</code></td>
<td>
<p>An object of class <code>"afex_aov"</code> (see
<code><a href="#topic+aov_car">aov_car</a></code>) or of class <code>"mixed"</code> (see <code><a href="#topic+mixed">mixed</a></code>)
as returned from the <span class="pkg">afex</span> functions. Alternatively, an object of
class <code>"Anova.mlm"</code> or <code>"anova"</code> as returned from
<code><a href="car.html#topic+Anova">Anova</a></code>.</p>
</td></tr>
<tr><td><code id="nice_+3A_...">...</code></td>
<td>
<p>currently ignored.</p>
</td></tr>
<tr><td><code id="nice_+3A_es">es</code></td>
<td>
<p>Effect Size to be reported. The default is given by
<code>afex_options("es_aov")</code>, which is initially set to <code>"ges"</code>
(i.e., reporting generalized eta-squared, see details). Also supported is
partial eta-squared (<code>"pes"</code>) or <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="nice_+3A_observed">observed</code></td>
<td>
<p>character vector referring to the observed (i.e., non
manipulated) variables/effects in the design. Important for calculation of
generalized eta-squared (ignored if <code>es</code> is not <code>"ges"</code>), see
details.</p>
</td></tr>
<tr><td><code id="nice_+3A_correction">correction</code></td>
<td>
<p>Character. Which sphericity correction of the degrees of
freedom should be reported for the within-subject factors.  The default is
given by <code>afex_options("correction_aov")</code>, which is initially set to
<code>"GG"</code> corresponding to the Greenhouse-Geisser correction. Possible
values are <code>"GG"</code>, <code>"HF"</code> (i.e., Hyunh-Feldt correction), and
<code>"none"</code> (i.e., no correction).</p>
</td></tr>
<tr><td><code id="nice_+3A_mse">MSE</code></td>
<td>
<p>logical. Should the column containing the Mean Sqaured Error (MSE)
be displayed? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="nice_+3A_intercept">intercept</code></td>
<td>
<p>logical. Should intercept (if present) be included in the
ANOVA table? Default is <code>FALSE</code> which hides the intercept.</p>
</td></tr>
<tr><td><code id="nice_+3A_p_adjust_method">p_adjust_method</code></td>
<td>
<p><code>character</code> indicating if p-values for individual
effects should be adjusted for multiple comparisons (see
<a href="stats.html#topic+p.adjust">p.adjust</a> and details). The default <code>NULL</code> corresponds to
no adjustment.</p>
</td></tr>
<tr><td><code id="nice_+3A_sig_symbols">sig_symbols</code></td>
<td>
<p>Character. What should be the symbols designating
significance? When entering an vector with <code>length(sig.symbol) &lt; 4</code>
only those elements of the default (<code>c(" +", " *", " **", " ***")</code>)
will be replaced. <code>sig_symbols = ""</code> will display the stars but not
the <code>+</code>, <code>sig_symbols = rep("", 4)</code> will display no symbols. The
default is given by <code>afex_options("sig_symbols")</code>.</p>
</td></tr>
<tr><td><code id="nice_+3A_round_ps">round_ps</code></td>
<td>
<p>Function that should be used for rounding p-values. The
default is given by <code>afex_options("round_ps")</code>.</p>
</td></tr>
<tr><td><code id="nice_+3A_sig.symbols">sig.symbols</code></td>
<td>
<p>deprecated argument, only for backwards compatibility, use
<code>"sig_symbols"</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The returned <code>data.frame</code> is print-ready when adding to a
document with proper methods. Either directly via <span class="pkg">knitr</span> or similar
approaches such as via package <span class="pkg">xtable</span> (nowadays <span class="pkg">knitr</span> is
probably the best approach, see <a href="https://yihui.org/knitr/">here</a>).
<span class="pkg">xtable</span> converts a <code>data.frame</code> into LaTeX code with many
possible options (e.g., allowing for <code>"longtable"</code> or
<code>"sidewaystable"</code>), see <code><a href="xtable.html#topic+xtable">xtable</a></code> and
<code><a href="xtable.html#topic+print.xtable">print.xtable</a></code>. See Examples.
</p>
<p>Conversion functions to other formats (such as HTML, ODF, or Word) can be
found at the
<a href="https://CRAN.R-project.org/view=ReproducibleResearch">Reproducible
Research Task View</a>.
</p>
<p>The default reports generalized eta squared (Olejnik &amp; Algina, 2003), the
&quot;recommended effect size for repeated measured designs&quot; (Bakeman, 2005).
Note that it is important that all measured variables (as opposed to
experimentally manipulated variables), such as e.g., age, gender, weight,
..., must be declared via <code>observed</code> to obtain the correct effect size
estimate. Partial eta squared (<code>"pes"</code>) does not require this.
</p>
<p>Exploratory ANOVA, for which no detailed hypotheses have been specified a
priori, harbor a multiple comparison problem (Cramer et al., 2015). To
avoid an inflation of familywise Type I error rate, results need to be
corrected for multiple comparisons using <code>p_adjust_method</code>.
<code>p_adjust_method</code> defaults to the method specified in the call to
<code><a href="#topic+aov_car">aov_car</a></code> in <code>anova_table</code>. If no method was specified and
<code>p_adjust_method = NULL</code> p-values are not adjusted.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> of class <code>nice_table</code> with the ANOVA table
consisting of characters. The columns that are always present are:
<code>Effect</code>, <code>df</code> (degrees of freedom), <code>F</code>, and <code>p</code>.
</p>
<p><code>ges</code> contains the generalized eta-squared effect size measure
(Bakeman, 2005), <code>pes</code> contains partial eta-squared (if requested).
</p>


<h3>Author(s)</h3>

<p>The code for calculating generalized eta-squared was written by Mike
Lawrence.<br /> Everything else was written by Henrik Singmann.
</p>


<h3>References</h3>

<p>Bakeman, R. (2005). Recommended effect size statistics for
repeated measures designs. <em>Behavior Research Methods</em>, 37(3),
379-384. <a href="https://doi.org/10.3758/BF03192707">doi:10.3758/BF03192707</a>
</p>
<p>Cramer, A. O. J., van Ravenzwaaij, D., Matzke, D., Steingroever, H.,
Wetzels, R., Grasman, R. P. P. P., ... Wagenmakers, E.-J. (2015). Hidden
multiplicity in exploratory multiway ANOVA: Prevalence and remedies.
<em>Psychonomic Bulletin &amp; Review</em>, 1-8.
<a href="https://doi.org/10.3758/s13423-015-0913-5">doi:10.3758/s13423-015-0913-5</a>
</p>
<p>Olejnik, S., &amp; Algina, J. (2003). Generalized Eta and Omega Squared
Statistics: Measures of Effect Size for Some Common Research Designs.
<em>Psychological Methods</em>, 8(4), 434-447.
<a href="https://doi.org/10.1037/1082-989X.8.4.434">doi:10.1037/1082-989X.8.4.434</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aov_ez">aov_ez</a></code> and <code><a href="#topic+aov_car">aov_car</a></code> are the convenience
functions to create the object appropriate for <code>nice_anova</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## example from Olejnik &amp; Algina (2003)
# "Repeated Measures Design" (pp. 439):
data(md_12.1)
# create object of class afex_aov:
rmd &lt;- aov_ez("id", "rt", md_12.1, within = c("angle", "noise"))
rmd
nice(rmd)
str(nice(rmd))
# use different es:
nice(rmd, es = "pes") # noise: .82
nice(rmd, es = "ges") # noise: .39

# same data other approach:
rmd2 &lt;- aov_ez("id", "rt", md_12.1, within = c("angle", "noise"), 
               anova_table=list(correction = "none", es = "none"))
nice(rmd2)
nice(rmd2, correction = "GG")
nice(rmd2, correction = "GG", es = "ges")

# exampel using obk.long (see ?obk.long), a long version of the OBrienKaiser dataset from car.
data(obk.long)
# create object of class afex_aov:
tmp.aov &lt;- aov_car(value ~ treatment * gender + Error(id/phase*hour), data = obk.long)

nice(tmp.aov, observed = "gender")

nice(tmp.aov, observed = "gender", sig_symbols = rep("", 4))

## Not run: 
# use package ascii or xtable for formatting of tables ready for printing.

full &lt;- nice(tmp.aov, observed = "gender")

require(ascii)
print(ascii(full, include.rownames = FALSE, caption = "ANOVA 1"), type = "org")

require(xtable)
print.xtable(xtable(full, caption = "ANOVA 2"), include.rownames = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='obk.long'>O'Brien Kaiser's Repeated-Measures Dataset with Covariate</h2><span id='topic+obk.long'></span>

<h3>Description</h3>

<p>This is the long version of the <code>OBrienKaiser</code> dataset from the <span class="pkg">car</span> pakage adding a random covariate <code>age</code>. Originally the dataset ist taken from O'Brien and Kaiser (1985). The description from <code><a href="carData.html#topic+OBrienKaiser">OBrienKaiser</a></code> says: &quot;These contrived repeated-measures data are taken from O'Brien and Kaiser (1985). The data are from an imaginary study in which 16 female and male subjects, who are divided into three treatments, are measured at a pretest, postest, and a follow-up session; during each session, they are measured at five occasions at intervals of one hour. The design, therefore, has two between-subject and two within-subject factors.&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obk.long
</code></pre>


<h3>Format</h3>

<p>A data frame with 240 rows and 7 variables.
</p>


<h3>Source</h3>

<p>O'Brien, R. G., &amp; Kaiser, M. K. (1985). MANOVA method for analyzing repeated measures designs: An extensive primer. <em>Psychological Bulletin</em>, 97, 316-333. doi:10.1037/0033-2909.97.2.316
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The dataset is constructed as follows:
data("OBrienKaiser", package = "carData")
set.seed(1)
OBrienKaiser2 &lt;- within(OBrienKaiser, {
		id &lt;- factor(1:nrow(OBrienKaiser))
		age &lt;- scale(sample(18:35, nrow(OBrienKaiser), replace = TRUE), scale = FALSE)})
attributes(OBrienKaiser2$age) &lt;- NULL # needed or resahpe2::melt throws an error.
OBrienKaiser2$age &lt;- as.numeric(OBrienKaiser2$age)
obk.long &lt;- reshape2::melt(OBrienKaiser2, id.vars = c("id", "treatment", "gender", "age"))
obk.long[,c("phase", "hour")] &lt;- lapply(as.data.frame(do.call(rbind,
        strsplit(as.character(obk.long$variable), "\\."),)), factor)
obk.long &lt;- obk.long[,c("id", "treatment", "gender", "age", "phase", "hour", "value")]
obk.long &lt;- obk.long[order(obk.long$id),]
rownames(obk.long) &lt;- NULL
str(obk.long)
## 'data.frame':   240 obs. of  7 variables:
##  $ id       : Factor w/ 16 levels "1","2","3","4",..: 1 1 1 1 1 1 1 1 1 1 ...
##  $ treatment: Factor w/ 3 levels "control","A",..: 1 1 1 1 1 1 1 1 1 1 ...
##  $ gender   : Factor w/ 2 levels "F","M": 2 2 2 2 2 2 2 2 2 2 ...
##  $ age      : num  -4.75 -4.75 -4.75 -4.75 -4.75 -4.75 -4.75 -4.75 -4.75 -4.75 ...
##  $ phase    : Factor w/ 3 levels "fup","post","pre": 3 3 3 3 3 2 2 2 2 2 ...
##  $ hour     : Factor w/ 5 levels "1","2","3","4",..: 1 2 3 4 5 1 2 3 4 5 ...
##  $ value    : num  1 2 4 2 1 3 2 5 3 2 ...
head(obk.long)
##    id treatment gender   age phase hour value
## 1  1   control      M -4.75   pre    1     1
## 2  1   control      M -4.75   pre    2     2
## 3  1   control      M -4.75   pre    3     4
## 4  1   control      M -4.75   pre    4     2
## 5  1   control      M -4.75   pre    5     1
## 6  1   control      M -4.75  post    1     3
</code></pre>

<hr>
<h2 id='predict.afex_aov'>Predict method for <code>afex_aov</code> objects</h2><span id='topic+predict.afex_aov'></span>

<h3>Description</h3>

<p>Predicted values based on <code>afex_aov</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'afex_aov'
predict(object, newdata, append = FALSE, colname_predict = ".predict", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.afex_aov_+3A_object">object</code></td>
<td>
<p><code>afex_aov</code> object.</p>
</td></tr>
<tr><td><code id="predict.afex_aov_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame in which to look for variables with
which to predict. If omitted, the fitted values are used.</p>
</td></tr>
<tr><td><code id="predict.afex_aov_+3A_append">append</code></td>
<td>
<p>If set to <code>TRUE</code> returns the residuals/fitted values
appended as an additional column to the long data. Recommended when data
was aggregated across within conditions.</p>
</td></tr>
<tr><td><code id="predict.afex_aov_+3A_colname_predict">colname_predict</code></td>
<td>
<p>Name of the appended column when <code>append = TRUE</code>.</p>
</td></tr>
<tr><td><code id="predict.afex_aov_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of predicted values corresponding to the data in
<code>object$data$long</code> or to <code>newdata</code>, or if <code>append = TRUE</code> a
data frame with an additional column of predicted values.
</p>


<h3>Author(s)</h3>

<p>Mattan S. Ben-Shachar
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(obk.long, package = "afex")

# estimate mixed ANOVA on the full design:
fit &lt;- aov_ez("id", "value", obk.long, between = c("treatment", "gender"), 
              within = c("phase", "hour"), observed = "gender")

new_data &lt;- expand.grid(
  treatment = "A",
  gender = "F",
  phase = c("pre", "post"),
  hour = c(1, 5)
)

predict(fit, newdata = new_data)
predict(fit, newdata = new_data, append = TRUE)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+lmer'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>lmerTest</dt><dd><p><code><a href="lmerTest.html#topic+lmer">lmer</a></code></p>
</dd>
</dl>

<hr>
<h2 id='residuals.afex_aov'>Extract Residuals and Fitted Values from <code>afex_aov</code> objects</h2><span id='topic+residuals.afex_aov'></span><span id='topic+fitted.afex_aov'></span>

<h3>Description</h3>

<p>Extract Residuals and Fitted Values from <code>afex_aov</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'afex_aov'
residuals(object, append = FALSE, colname_residuals = ".residuals", ...)

## S3 method for class 'afex_aov'
fitted(object, append = FALSE, colname_fitted = ".fitted", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.afex_aov_+3A_object">object</code></td>
<td>
<p><code>afex_aov</code> object.</p>
</td></tr>
<tr><td><code id="residuals.afex_aov_+3A_append">append</code></td>
<td>
<p>If set to <code>TRUE</code> returns the residuals/fitted values
appended as an additional column to the long data. Recommended when data
was aggregated across within conditions.</p>
</td></tr>
<tr><td><code id="residuals.afex_aov_+3A_colname_residuals">colname_residuals</code>, <code id="residuals.afex_aov_+3A_colname_fitted">colname_fitted</code></td>
<td>
<p>Name of the appended column when
<code>append = TRUE</code>.</p>
</td></tr>
<tr><td><code id="residuals.afex_aov_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to
<code>residuals.lm</code>/<code>fitted.lm</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of residuals/fitted values corresponding to the data in
<code>object$data$long</code>, or if <code>append = TRUE</code> a data frame with an
additional column of residuals/fitted values.
</p>


<h3>Author(s)</h3>

<p>Mattan S. Ben-Shachar
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Setup ANOVAs
data(obk.long, package = "afex")
between &lt;- aov_car(value ~ treatment*gender + Error(id), data = obk.long)
within &lt;- aov_car(value ~ 1 + Error(id/(phase*hour)), data = obk.long)
mixed &lt;- aov_car(value ~ treatment * gender + Error(id/(phase*hour)), data = obk.long)

# All residuals call produce the message that the data was changed during calculation.
residuals(within)
residuals(mixed)
residuals(between)

## Get residuals plus data used for fitting: 
residuals(within, append = TRUE)
residuals(mixed, append = TRUE)
residuals(between, append = TRUE)

### in case data is correctly ordered before fitting, this message is not shown

## between data:
obk2 &lt;- aggregate(value ~ gender + treatment + id , data = obk.long, FUN = mean)
between2 &lt;- aov_car(value ~ treatment*gender + Error(id), data = obk2)

residuals(between2) ## no message
all.equal(obk2, between2$data$long[,colnames(obk2)]) ## TRUE

# Therefore okay:
obk2$residuals &lt;- residuals(between2)

## within data
obk3 &lt;- obk.long[with(obk.long, order(id, phase, hour)), ]
within2 &lt;- aov_car(value ~ 1 + Error(id/(phase*hour)), data = obk3)
residuals(within2) ## no message, because order is correct
# Therefore okay:
obk3$residuals &lt;- residuals(within2)

## Same for fitted values:
# (show message)
fitted(within)
fitted(mixed)
fitted(between)

## Get fitted values plus data used for fitting: 
fitted(within, append = TRUE)
fitted(mixed, append = TRUE)
fitted(between, append = TRUE)

## No message:
fitted(between2)
fitted(within2)

#### residuals() and fitted() methods can be used for plotting
### requires package ggResidpanel
if (require("ggResidpanel")) {
  resid_auxpanel(residuals = residuals(mixed), predicted = fitted(mixed))
  
  ## Not run: 
  ## suppress Messages:
  suppressMessages(
    resid_auxpanel(residuals = residuals(mixed), predicted = fitted(mixed))
  )
  
## End(Not run)
}
</code></pre>

<hr>
<h2 id='round_ps'>Helper functions for rounding p-values</h2><span id='topic+round_ps'></span><span id='topic+round_ps_apa'></span>

<h3>Description</h3>

<p>These functions return a character vector of p-values that are rounded as
described below and without the leading zero before the decimal point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>round_ps(x)

round_ps_apa(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="round_ps_+3A_x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>round_ps</code> p-values are rounded in a sane way: .99 - .01 to two
digits, &lt; .01 to three digits, &lt; .001 to four digits.
</p>
<p>For <code>round_ps_apa</code> p-values are rounded following APA guidelines: .999 -
.001 to three digits, and &lt; .001 for values below this threshold.
</p>


<h3>Value</h3>

<p>A character vector with the same length as x.
</p>


<h3>Note</h3>

<p>These functions are useful in <code><a href="#topic+nice">nice</a></code> and the default is set
via <code><a href="#topic+afex_options">afex_options</a></code>.
</p>


<h3>Author(s)</h3>

<p>Henrik Singmann
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(10)
y &lt;- runif(10, 0, .01)

round_ps(x)
round_ps_apa(x)

round_ps(y)
round_ps_apa(y)

round_ps(0.0000000099)
round_ps_apa(0.0000000099)

</code></pre>

<hr>
<h2 id='set_sum_contrasts'>Set global contrasts</h2><span id='topic+set_sum_contrasts'></span><span id='topic+set_deviation_contrasts'></span><span id='topic+set_effects_contrasts'></span><span id='topic+set_treatment_contrasts'></span><span id='topic+set_default_contrasts'></span>

<h3>Description</h3>

<p>These functions are simple wrappers to set contrasts globally via <code>options(contrasts = ...)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_sum_contrasts()

set_deviation_contrasts()

set_effects_contrasts()

set_default_contrasts()

set_treatment_contrasts()
</code></pre>


<h3>Details</h3>

<p><code>set_deviation_contrasts</code> and <code>set_effects_contrasts</code> are wrappers for <code>set_sum_contrasts</code>. Likewise, <code>set_default_contrasts</code> is a wrapper to <code>set_treatment_contrasts()</code>.
</p>


<h3>Value</h3>

<p>nothing. These functions are called for their side effects to change the global options.
</p>

<hr>
<h2 id='sk2011.1'>Data from Singmann &amp; Klauer (2011, Experiment 1)</h2><span id='topic+sk2011.1'></span>

<h3>Description</h3>

<p>Singmann and Klauer (2011) were interested in whether or not conditional reasoning can be explained by a single process or whether multiple processes are necessary to explain it. To provide evidence for multiple processes we aimed to establish a double dissociation of two variables: instruction type and problem type. Instruction type was manipulated between-subjects, one group of participants received  deductive instructions (i.e., to treat the premises as given and only draw necessary conclusions) and a second group of participants received probabilistic instructions (i.e., to reason as in an everyday situation; we called this &quot;inductive instruction&quot; in the manuscript). Problem type consisted of two different orthogonally crossed variables that were manipulated within-subjects, validity of the problem (formally valid or formally invalid) and plausibility of the problem (inferences which were consisted with the background knowledge versus problems that were inconsistent with the background knowledge). The critical comparison across the two conditions was among problems which were valid and implausible with problems that were invalid and plausible. For example, the next problem was invalid and plausible:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sk2011.1
</code></pre>


<h3>Format</h3>

<p>A data.frame with 640 rows and 9 variables.
</p>


<h3>Details</h3>

<p>If a person is wet, then the person fell into a swimming pool.  <br />
A person fell into a swimming pool.  <br />
How valid is the conclusion/How likely is it that the person is wet?
</p>
<p>For those problems we predicted that under deductive instructions responses should be lower (as the conclusion does not necessarily follow from the premises) as under probabilistic instructions. For the valid but implausible problem, an example is presented next, we predicted the opposite pattern:
</p>
<p>If a person is wet, then the person fell into a swimming pool.    <br />
A person is wet.  <br />
How valid is the conclusion/How likely is it that the person fell into a swimming pool?
</p>
<p>Our study also included valid and plausible and invalid and implausible problems. 
</p>
<p>Note that the factor 'plausibility' is not present in the original manuscript, there it is a results of a combination of other factors.
</p>


<h3>Source</h3>

<p>Singmann, H., &amp; Klauer, K. C. (2011). Deductive and inductive conditional inferences: Two modes of reasoning. Thinking &amp; Reasoning, 17(3), 247-281. doi:10.1080/13546783.2011.572718
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sk2011.1)

# Table 1 (p. 264):
aov_ez("id", "response", sk2011.1[ sk2011.1$what == "affirmation",], 
       within = c("inference", "type"), between = "instruction", 
       anova_table=(es = "pes"))
aov_ez("id", "response", sk2011.1[ sk2011.1$what == "denial",], 
       within = c("inference", "type"), between = "instruction", 
       anova_table=(es = "pes"))

 
</code></pre>

<hr>
<h2 id='sk2011.2'>Data from Singmann &amp; Klauer (2011, Experiment 2)</h2><span id='topic+sk2011.2'></span>

<h3>Description</h3>

<p>Singmann and Klauer (2011) were interested in whether or not conditional reasoning can be explained by a single process or whether multiple processes are necessary to explain it. To provide evidence for multiple processes we aimed to establish a double dissociation of two variables: instruction type and problem type. Instruction type was manipulated between-subjects, one group of participants received  deductive instructions (i.e., to treat the premises as given and only draw necessary conclusions) and a second group of participants received probabilistic instructions (i.e., to reason as in an everyday situation; we called this &quot;inductive instruction&quot; in the manuscript). Problem type consisted of two different orthogonally crossed variables that were manipulated within-subjects, validity of the problem (formally valid or formally invalid) and type of the problem. Problem type consistent of three levels: prological problems (i.e., problems in which background knowledge suggested to accept valid but reject invalid conclusions), neutral problems (i.e., in which background knowledge suggested to reject all problems), and counterlogical problems (i.e., problems in which background knowledge suggested to reject valid but accept invalid conclusions).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sk2011.2
</code></pre>


<h3>Format</h3>

<p>A data.frame with 2268 rows and 9 variables.
</p>


<h3>Details</h3>

<p>This data set contains 63 participants in contrast to the originally reported 56 participants. The additional participants were not included in the original studies as they did not meet the inclusion criteria (i.e., no students, prior education in logic, or participated in a similar experiment). The IDs of those additional participants are: 7, 8, 9, 12, 17, 24, 30. The excluded participant reported in the paper has ID 16.
</p>
<p>content has the following levels (C = content/conditional):<br />
1 = Wenn eine Person in ein Schwimmbecken gefallen ist, dann ist sie nass.<br />
2 = Wenn ein Hund Flöhe hat, dann kratzt er sich hin und wieder.<br />
3 = Wenn eine Seifenblase mit einer Nadel gestochen wurde, dann platzt sie.<br />
4 = Wenn ein Mädchen Geschlechtsverkehr vollzogen hat, dann ist es schwanger.<br />
5 = Wenn eine Pflanze ausreichend gegossen wird, dann bleibt sie grün.<br />
6 = Wenn sich eine Person die Zähne putzt, dann bekommt sie KEIN Karies.<br />
7 = Wenn eine Person viel Cola trinkt, dann nimmt sie an Gewicht zu.<br />
8 = Wenn eine Person die Klimaanlage angeschaltet hat, dann fröstelt sie.<br />
9 = Wenn eine Person viel lernt, dann wird sie in der Klausur eine gute Note erhalten.
</p>


<h3>Source</h3>

<p>Singmann, H., &amp; Klauer, K. C. (2011). Deductive and inductive conditional inferences: Two modes of reasoning. Thinking &amp; Reasoning, 17(3), 247-281. doi:10.1080/13546783.2011.572718
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sk2011.2")

## remove excluded participants:

sk2_final &lt;- droplevels(sk2011.2[!(sk2011.2$id %in% c(7, 8, 9, 12, 16, 17, 24, 30)),])
str(sk2_final)

## Table 2 (inference = problem):
aov_ez("id", "response", sk2_final[sk2_final$what == "affirmation",], 
       between = "instruction", within = c("inference", "type"),
       anova_table=list(es = "pes"))

aov_ez("id", "response", sk2_final[sk2_final$what == "denial",], 
       between = "instruction", within = c("inference", "type"),
       anova_table=list(es = "pes"))

# Recreate Figure 4 (corrected version):

sk2_aff &lt;- droplevels(sk2_final[sk2_final$what == "affirmation",])
sk2_aff$type2 &lt;- factor(sk2_aff$inference:sk2_aff$type, levels = c("MP:prological", 
                            "MP:neutral", "MP:counterlogical", "AC:counterlogical", 
                            "AC:neutral", "AC:prological"))
a1_b &lt;- aov_ez("id", "response", sk2_aff, 
       between = "instruction", within = c("type2"))

sk2_den &lt;- droplevels(sk2_final[sk2_final$what == "denial",])
sk2_den$type2 &lt;- factor(sk2_den$inference:sk2_den$type, levels = c("MT:prological", 
                            "MT:neutral", "MT:counterlogical", "DA:counterlogical", 
                            "DA:neutral","DA:prological"))
a2_b &lt;- aov_ez("id", "response", sk2_den, 
       between = "instruction", within = c("type2"))

if (requireNamespace("emmeans") &amp;&amp; requireNamespace("ggplot2")) {
  afex_plot(a1_b,"type2", "instruction") + 
    ggplot2::coord_cartesian(ylim = c(0, 100))
  afex_plot(a2_b,"type2", "instruction") + 
    ggplot2::coord_cartesian(ylim = c(0, 100))
}
</code></pre>

<hr>
<h2 id='stroop'>Stroop data from Lin et al. (2020, Psych. Science)</h2><span id='topic+stroop'></span>

<h3>Description</h3>

<p>Lin, Saunders, Friese, Evans, and Inzlicht (2020) investigated ego depletion.
An initial high-demand task was followed by a Stroop task. The data of the
Stroop task from all 4 of their studies is included here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stroop
</code></pre>


<h3>Format</h3>

<p>A data frame with 246600 rows and 7 variables:
</p>

<dl>
<dt>pno</dt><dd><p>participant id (preceded by study id), factor with 685 levels</p>
</dd>
<dt>condition</dt><dd><p>experimental condition (control/low demand, deplete/high demand), factor with 2 levels</p>
</dd>
<dt>study</dt><dd><p>study number (1, 2, 3, 4), factor with 4 levels</p>
</dd>
<dt>trialnum</dt><dd><p>trial number</p>
</dd>
<dt>congruency</dt><dd><p>Stroop congruency (congruent, incongruent), factor with 2 levels</p>
</dd>
<dt>acc</dt><dd><p>accuracy (0: error, 1: correct)</p>
</dd>
<dt>rt</dt><dd><p>reaction time (seconds)</p>
</dd>
</dl>



<h3>Details</h3>

<p>Their abstract: People feel tired or depleted after exerting mental effort.
But even preregistered studies often fail to find effects of exerting effort
on behavioral performance in the laboratory or elucidate the underlying
psychology. We tested a new paradigm in four preregistered within-subjects
studies (N = 686). An initial high-demand task reliably elicited very strong
effort phenomenology compared with a low-demand task. Afterward, participants
completed a Stroop task. We used drift-diffusion modeling to obtain the
boundary (response caution) and drift-rate (information-processing speed)
parameters. Bayesian analyses indicated that the high-demand manipulation
reduced boundary but not drift rate. Increased effort sensations further
predicted reduced boundary. However, our demand manipulation did not affect
subsequent inhibition, as assessed with traditional Stroop behavioral
measures and additional diffusion-model analyses for conflict tasks. Thus,
effort exertion reduced response caution rather than inhibitory control,
suggesting that after exerting effort, people disengage and become
uninterested in exerting further effort.
</p>


<h3>Source</h3>

<p>Lin, H., Saunders, B., Friese, M., Evans, N. J., &amp; Inzlicht, M.
(2020). Strong Effort Manipulations Reduce Response Caution: A
Preregistered Reinvention of the Ego-Depletion Paradigm. *Psychological
Science*, <a href="https://doi.org/10.1177/0956797620904990">doi:10.1177/0956797620904990</a>
</p>

<hr>
<h2 id='test_levene'>Deprecated functions</h2><span id='topic+test_levene'></span><span id='topic+afex-deprecated'></span><span id='topic+test_sphericity'></span>

<h3>Description</h3>

<p>These functions have been renamed or moved and deprecated in <span class="pkg">afex</span>:
<code>test_levene()</code> (use <code><a href="performance.html#topic+check_homogeneity">check_homogeneity</a>()</code>),
<code>test_sphericity()</code> (use <code><a href="performance.html#topic+check_sphericity">check_sphericity</a>()</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_levene(...)

test_sphericity(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_levene_+3A_...">...</code></td>
<td>
<p>arguments passed from the old functions of the style
<code>foo.bar()</code> to the new functions <code>foo_bar()</code></p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
