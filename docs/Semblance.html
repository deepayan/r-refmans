<!DOCTYPE html><html><head><title>Help for package Semblance</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Semblance}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#computeSemblanceOneFeature'><p>Compute semblance when there is only one feature, given as a vector x.</p></a></li>
<li><a href='#computeSemblanceOneFeature_Gini'><p>Compute semblance when there is only one feature, given as a vector x, but weight the feature by its Gini coefficient. Use for data with strictly positive values.</p></a></li>
<li><a href='#makeUpperLower'><p>Make the upper triangular part the same as the lower triangular part.</p></a></li>
<li><a href='#ranksem'><p>Compute Semblance For a Given Input Matrix or Data Frame</p></a></li>
<li><a href='#ranksem_Gini'><p>Compute Gini-weighted Semblance</p></a></li>
<li><a href='#repCol'><p>Make a matrix by repeating vector v into n columns</p></a></li>
<li><a href='#repRow'><p>Make a matrix by repeating vector v into n rows</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Data-Driven Similarity Kernel on Probability Spaces</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Divyansh Agarwal &lt;divyansh@upenn.edu&gt;
        Nancy R. Zhang &lt;nzh@wharton.upenn.edu&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Divyansh Agarwal &lt;divyansh@upenn.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>We present a rank-based Mercer kernel to compute a pair-wise similarity metric corresponding to informative representation of data. We tailor the development of a kernel to encode our prior knowledge about the data distribution over a probability space. The philosophical concept behind our construction is that objects whose feature values fall on the extreme of that feature’s probability mass distribution are more similar to each other, than objects whose feature values lie closer to the mean. Semblance emphasizes features whose values lie far away from the mean of their probability distribution. The kernel relies on properties empirically determined from the data and does not assume an underlying distribution. The use of feature ranks on a probability space ensures that Semblance is computational efficacious, robust to outliers, and statistically stable, thus making it widely applicable algorithm for pattern analysis. The output from the kernel is a square, symmetric matrix that gives proximity values between pairs of observations.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>fields (&ge; 9.6), PerformanceAnalytics (&ge; 1.5.2), DescTools
(&ge; 0.99.26), msos (&ge; 1.1.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>kernlab</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-01-25 13:16:35 UTC; divyanshagarwal</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-01-25 13:40:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='computeSemblanceOneFeature'>Compute semblance when there is only one feature, given as a vector x.</h2><span id='topic+computeSemblanceOneFeature'></span>

<h3>Description</h3>

<p>Compute semblance when there is only one feature, given as a vector x.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeSemblanceOneFeature(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeSemblanceOneFeature_+3A_x">x</code></td>
<td>
<p>a vector of observations for whom a given feature has been measured or estimated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a Semblance metric for only one feature measured for several observations
</p>

<hr>
<h2 id='computeSemblanceOneFeature_Gini'>Compute semblance when there is only one feature, given as a vector x, but weight the feature by its Gini coefficient. Use for data with strictly positive values.</h2><span id='topic+computeSemblanceOneFeature_Gini'></span>

<h3>Description</h3>

<p>Compute semblance when there is only one feature, given as a vector x, but weight the feature by its Gini coefficient. Use for data with strictly positive values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeSemblanceOneFeature_Gini(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeSemblanceOneFeature_Gini_+3A_x">x</code></td>
<td>
<p>a vector of observations for whom a given feature has been measured or estimated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a Semblance metric for only one feature measured for several observations
</p>

<hr>
<h2 id='makeUpperLower'>Make the upper triangular part the same as the lower triangular part.</h2><span id='topic+makeUpperLower'></span>

<h3>Description</h3>

<p>Make the upper triangular part the same as the lower triangular part.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeUpperLower(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeUpperLower_+3A_m">m</code></td>
<td>
<p>a matrix whose upper traingular part needs to be created using the lower traingular part</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix where the upper triangular part the same as the lower triangular part
</p>

<hr>
<h2 id='ranksem'>Compute Semblance For a Given Input Matrix or Data Frame</h2><span id='topic+ranksem'></span>

<h3>Description</h3>

<p>Kernel methods can operate in a high-dimensional, implicit feature space with low computational cost. Here, we present
a rank-based Mercer kernel to compute a pair-wise similarity metric, corresponding to informative representation of data. We tailor
the development of a kernel to encode our prior knowledge about the data distribution over a probability space. The
philosophical concept behind our construction is that objects whose feature values fall on the extreme of that feature’s probability
mass distribution are more similar to each other, than objects whose feature values lie closer to the mean. This idea
represents a fundamentally novel way of assessing similarity between two observations. Our kernel (henceforth called ’Semblance’)
naturally lends itself to the construction of a distance metric that emphasizes features whose values lie far away
from the mean of their probability distribution. Semblance relies on properties empirically determined from the data and
does not assume an underlying distribution. The use of feature ranks on a probability space ensures that Semblance is
computational efficacious, robust to outliers, and statistically stable, thus making it widely applicable algorithm for
pattern analysis. This R package accompanies the research article &quot;Semblance: A Data-driven Kernel Redefines the Notion of Similarity&quot;, to appear in Science Advances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ranksem(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ranksem_+3A_x">X</code></td>
<td>
<p>a matrix X with n observations and m features, whose Semblance Gram Matrix is to be computed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The resultant Gram Matrix after applying Semblance kernel to the input
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulation Example when the user inputs a matrix with single-cell gene expression data
ngenes = 10
ncells = 10
nclust = 2
mu=c(100, 0) #mean in cluster 1, cluster 2 for informative genes
sigma=c(0.01, 1) #stdev in cluster 1, cluster 2 for informative genes
size.rare.clust = 0.1
prop.info.genes = 0.2
n.info.genes=round(prop.info.genes*ngenes)
n.clust1.cells = round(ncells*size.rare.clust)
mu1=c(rep(mu[1]*sigma[2], n.info.genes), rep(0, ngenes-n.info.genes))
mu2=c(rep(mu[2]*sigma[2], n.info.genes), rep(0, ngenes-n.info.genes))
sig1=c(rep(sigma[1], n.info.genes), rep(1, ngenes-n.info.genes))
sig2=c(rep(sigma[2], n.info.genes), rep(1, ngenes-n.info.genes))
X=matrix(ncol=ngenes, nrow=ncells, data=0)
for(i in 1:n.clust1.cells){
  X[i,] = rnorm(ngenes, mean=mu1, sd=sig1)
}
for(i in (n.clust1.cells+1):ncells){
  X[i,] = rnorm(ngenes, mean=mu2, sd=sig2)
}
#Compute kernels/distances
rks=ranksem(X)
</code></pre>

<hr>
<h2 id='ranksem_Gini'>Compute Gini-weighted Semblance</h2><span id='topic+ranksem_Gini'></span>

<h3>Description</h3>

<p>Compute Gini-weighted Semblance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ranksem_Gini(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ranksem_Gini_+3A_x">X</code></td>
<td>
<p>a matrix X with n observations and m features, whose Semblance Gram Matrix is to be computed. While computing this Gram Matrix, each feature is weighed by the Gini index for efficient feature selection.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The resultant Gini-weighted Gram Matrix after applying Semblance kernel to the input
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulation Example when the user inputs a matrix with single-cell gene expression data
ngenes = 10
ncells = 10
nclust = 2
mu=c(5, 1) #mean in cluster 1, cluster 2 for informative genes
sigma=c(2, 1) #stdev in cluster 1, cluster 2 for informative genes
size.rare.clust = 0.2
prop.info.genes = 0.2
n.info.genes=round(prop.info.genes*ngenes)
n.clust1.cells = round(ncells*size.rare.clust)
mu1=c(rep(mu[1]*sigma[2], n.info.genes), rep(0, ngenes-n.info.genes))
mu2=c(rep(mu[2]*sigma[2], n.info.genes), rep(0, ngenes-n.info.genes))
sig1=c(rep(sigma[1], n.info.genes), rep(1, ngenes-n.info.genes))
sig2=c(rep(sigma[2], n.info.genes), rep(1, ngenes-n.info.genes))
X=matrix(ncol=ngenes, nrow=ncells, data=0)
for(i in 1:n.clust1.cells){
  X[i,] = rnorm(ngenes, mean=mu1, sd=sig1)
}
for(i in (n.clust1.cells+1):ncells){
  X[i,] = rnorm(ngenes, mean=mu2, sd=sig2)
}
Noise &lt;- matrix(rnorm(prod(dim(X)), mean=2, sd=0.4), nrow = 10)
X = X + Noise
#Compute kernels/distances
rks=ranksem_Gini(X)
</code></pre>

<hr>
<h2 id='repCol'>Make a matrix by repeating vector v into n columns</h2><span id='topic+repCol'></span>

<h3>Description</h3>

<p>Make a matrix by repeating vector v into n columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repCol(v, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="repCol_+3A_v">v</code></td>
<td>
<p>a vector to be operated on</p>
</td></tr>
<tr><td><code id="repCol_+3A_n">n</code></td>
<td>
<p>number of columns the vector will be repeated over</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with repeated columns
</p>

<hr>
<h2 id='repRow'>Make a matrix by repeating vector v into n rows</h2><span id='topic+repRow'></span>

<h3>Description</h3>

<p>Make a matrix by repeating vector v into n rows
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repRow(v, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="repRow_+3A_v">v</code></td>
<td>
<p>a vector to be operated on</p>
</td></tr>
<tr><td><code id="repRow_+3A_n">n</code></td>
<td>
<p>number of rows the vector will be repeated over</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with repeated rows
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
