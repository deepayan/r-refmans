<!DOCTYPE html><html><head><title>Help for package stplanr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {stplanr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#stplanr-package'><p><strong>stplanr: Sustainable Transport Planning with R</strong></p></a></li>
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#angle_diff'><p>Calculate the angular difference between lines and a predefined bearing</p></a></li>
<li><a href='#bbox_scale'><p>Scale a bounding box</p></a></li>
<li><a href='#bind_sf'><p>Rapid row-binding of sf objects</p></a></li>
<li><a href='#cents_sf'><p>Spatial points representing home locations</p></a></li>
<li><a href='#destinations_sf'><p>Example destinations data</p></a></li>
<li><a href='#flow'><p>Data frame of commuter flows</p></a></li>
<li><a href='#flow_dests'><p>Data frame of invented</p>
commuter flows with destinations in a different layer than the origins</a></li>
<li><a href='#flowlines_sf'><p>Spatial lines dataset of commuter flows</p></a></li>
<li><a href='#geo_bb'><p>Flexible function to generate bounding boxes</p></a></li>
<li><a href='#geo_bb_matrix'><p>Create matrix representing the spatial bounds of an object</p></a></li>
<li><a href='#geo_buffer'><p>Perform a buffer operation on a temporary projected CRS</p></a></li>
<li><a href='#geo_code'><p>Convert text strings into points on the map</p></a></li>
<li><a href='#geo_length'><p>Calculate line length of line with geographic or projected CRS</p></a></li>
<li><a href='#geo_projected'><p>Perform GIS functions on a temporary, projected version of a spatial object</p></a></li>
<li><a href='#geo_select_aeq'><p>Select a custom projected CRS for the area of interest</p></a></li>
<li><a href='#geo_toptail'><p>Clip the first and last n metres of SpatialLines</p></a></li>
<li><a href='#gsection'><p>Function to split overlapping SpatialLines into segments</p></a></li>
<li><a href='#is_linepoint'><p>Identify lines that are points</p></a></li>
<li><a href='#islines'><p>Do the intersections between two geometries create lines?</p></a></li>
<li><a href='#line_bearing'><p>Find the bearing of straight lines</p></a></li>
<li><a href='#line_breakup'><p>Break up line objects into shorter segments</p></a></li>
<li><a href='#line_cast'><p>Convert multilinestring object into linestrings</p></a></li>
<li><a href='#line_midpoint'><p>Find the mid-point of lines</p></a></li>
<li><a href='#line_segment'><p>Divide an sf object with LINESTRING geometry into regular segments</p></a></li>
<li><a href='#line_via'><p>Add geometry columns representing a route via intermediary points</p></a></li>
<li><a href='#line2df'><p>Convert geographic line objects to a data.frame with from and to coords</p></a></li>
<li><a href='#line2points'><p>Convert a spatial (linestring) object to points</p></a></li>
<li><a href='#mats2line'><p>Convert 2 matrices to lines</p></a></li>
<li><a href='#n_vertices'><p>Retrieve the number of vertices in sf objects</p></a></li>
<li><a href='#od_aggregate_from'><p>Summary statistics of trips originating from zones in OD data</p></a></li>
<li><a href='#od_aggregate_to'><p>Summary statistics of trips arriving at destination zones in OD data</p></a></li>
<li><a href='#od_coords'><p>Create matrices representing origin-destination coordinates</p></a></li>
<li><a href='#od_coords2line'><p>Convert origin-destination coordinates into desire lines</p></a></li>
<li><a href='#od_data_lines'><p>Example of desire line representations of origin-destination data from UK Census</p></a></li>
<li><a href='#od_data_routes'><p>Example segment-level route data</p></a></li>
<li><a href='#od_data_sample'><p>Example of origin-destination data from UK Census</p></a></li>
<li><a href='#od_id'><p>Combine two ID values to create a single ID number</p></a></li>
<li><a href='#od_id_order'><p>Generate ordered ids of OD pairs so lowest is always first</p>
This function is slow on large datasets, see szudzik_pairing for faster alternative</a></li>
<li><a href='#od_oneway'><p>Aggregate od pairs they become non-directional</p></a></li>
<li><a href='#od_to_odmatrix'><p>Convert origin-destination data from long to wide format</p></a></li>
<li><a href='#od2line'><p>Convert origin-destination data to spatial lines</p></a></li>
<li><a href='#od2odf'><p>Extract coordinates from OD data</p></a></li>
<li><a href='#odmatrix_to_od'><p>Convert origin-destination data from wide to long format</p></a></li>
<li><a href='#onewaygeo'><p>Aggregate flows so they become non-directional (by geometry - the slow way)</p></a></li>
<li><a href='#osm_net_example'><p>Example of OpenStreetMap road network</p></a></li>
<li><a href='#overline'><p>Convert series of overlapping lines into a route network</p></a></li>
<li><a href='#overline_intersection'><p>Convert series of overlapping lines into a route network</p></a></li>
<li><a href='#points2flow'><p>Convert a series of points into geographical flows</p></a></li>
<li><a href='#points2line'><p>Convert a series of points, or a matrix of coordinates, into a line</p></a></li>
<li><a href='#points2odf'><p>Convert a series of points into a dataframe of origins and destinations</p></a></li>
<li><a href='#quadrant'><p>Split a spatial object into quadrants</p></a></li>
<li><a href='#read_table_builder'><p>Import and format Australian Bureau of Statistics (ABS) TableBuilder files</p></a></li>
<li><a href='#rnet_add_node'><p>Add a node to route network</p></a></li>
<li><a href='#rnet_boundary_points'><p>Get points at the beginner and end of linestrings</p></a></li>
<li><a href='#rnet_breakup_vertices'><p>Break up an sf object with LINESTRING geometry.</p></a></li>
<li><a href='#rnet_connected'><p>Keep only segments connected to the largest group in a network</p></a></li>
<li><a href='#rnet_cycleway_intersection'><p>Example of cycleway intersection data showing problems for SpatialLinesNetwork objects</p></a></li>
<li><a href='#rnet_get_nodes'><p>Extract nodes from route network</p></a></li>
<li><a href='#rnet_group'><p>Assign segments in a route network to groups</p></a></li>
<li><a href='#rnet_join'><p>Join route networks</p></a></li>
<li><a href='#rnet_merge'><p>Merge route networks, keeping attributes with aggregating functions</p></a></li>
<li><a href='#rnet_overpass'><p>Example of overpass data showing problems for SpatialLinesNetwork objects</p></a></li>
<li><a href='#rnet_roundabout'><p>Example of roundabout data showing problems for SpatialLinesNetwork objects</p></a></li>
<li><a href='#rnet_subset'><p>Subset one route network based on overlaps with another</p></a></li>
<li><a href='#route'><p>Plan routes on the transport network</p></a></li>
<li><a href='#route_average_gradient'><p>Return average gradient across a route</p></a></li>
<li><a href='#route_bikecitizens'><p>Get a route from the BikeCitizens web service</p></a></li>
<li><a href='#route_dodgr'><p>Route on local data using the dodgr package</p></a></li>
<li><a href='#route_google'><p>Find shortest path using Google services</p></a></li>
<li><a href='#route_nearest_point'><p>Find nearest route to a given point</p></a></li>
<li><a href='#route_network_sf'><p>Spatial lines dataset representing a route network</p></a></li>
<li><a href='#route_network_small'><p>Spatial lines dataset representing a small route network</p></a></li>
<li><a href='#route_osrm'><p>Plan routes on the transport network using the OSRM server</p></a></li>
<li><a href='#route_rolling_average'><p>Return smoothed averages of vector</p></a></li>
<li><a href='#route_rolling_diff'><p>Return smoothed differences between vector values</p></a></li>
<li><a href='#route_rolling_gradient'><p>Calculate rolling average gradient from elevation data at segment level</p></a></li>
<li><a href='#route_sequential_dist'><p>Calculate the sequential distances between sequential coordinate pairs</p></a></li>
<li><a href='#route_slope_matrix'><p>Calculate the gradient of line segments from a matrix of coordinates</p></a></li>
<li><a href='#route_slope_vector'><p>Calculate the gradient of line segments from distance and elevation vectors</p></a></li>
<li><a href='#route_split'><p>Split route in two at point on or near network</p></a></li>
<li><a href='#route_split_id'><p>Split route based on the id or coordinates of one of its vertices</p></a></li>
<li><a href='#routes_fast_sf'><p>Spatial lines dataset of commuter flows on the travel network</p></a></li>
<li><a href='#routes_slow_sf'><p>Spatial lines dataset of commuter flows on the travel network</p></a></li>
<li><a href='#stplanr-deprecated'><p>Deprecated functions in stplanr</p></a></li>
<li><a href='#toptail_buff'><p>Clip the beginning and ends of <code>sf</code> LINESTRING objects</p></a></li>
<li><a href='#zones_sf'><p>Spatial polygons of home locations for flow analysis.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Sustainable Transport Planning</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robin Lovelace &lt;rob00x@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for transport planning with an emphasis on spatial
    transport data and non-motorized modes. Create geographic "desire
    lines" from origin-destination (OD) data (building on the 'od'
    package); calculate routes on the transport network locally and via
    interfaces to routing services such as <a href="https://cyclestreets.net/">https://cyclestreets.net/</a>;
    calculate route segment attributes such as bearing.  The package
    implements the 'travel flow aggregration' method described in Morgan
    and Lovelace (2020) &lt;<a href="https://doi.org/10.1177%2F2399808320942779">doi:10.1177/2399808320942779</a>&gt;.  Further
    information on the package's aim and scope can be found in the
    vignettes and in a paper in the R Journal (Lovelace and Ellison 2018)
    &lt;<a href="https://doi.org/10.32614%2FRJ-2018-053">doi:10.32614/RJ-2018-053</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ropensci/stplanr">https://github.com/ropensci/stplanr</a>,
<a href="https://docs.ropensci.org/stplanr/">https://docs.ropensci.org/stplanr/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ropensci/stplanr/issues">https://github.com/ropensci/stplanr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>curl (&ge; 3.2), data.table, dplyr (&ge; 0.7.6), httr (&ge; 1.3.1),
jsonlite (&ge; 1.5), lwgeom (&ge; 0.1.4), magrittr, methods, nabor
(&ge; 0.5.0), od, pbapply, Rcpp (&ge; 0.12.1), rlang (&ge; 0.2.2), sf
(&ge; 0.6.3), sfheaders</td>
</tr>
<tr>
<td>Suggests:</td>
<td>cyclestreets, dodgr (&ge; 0.2.15), geodist, igraph (&ge; 1.2.2),
knitr (&ge; 1.20), leaflet, mapsapi, opentripplanner, osrm, pct,
rmarkdown (&ge; 1.10), testthat (&ge; 2.0.0), tmap</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-15 07:58:02 UTC; robin</td>
</tr>
<tr>
<td>Author:</td>
<td>Robin Lovelace <a href="https://orcid.org/0000-0001-5679-6536"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Richard Ellison [aut],
  Malcolm Morgan <a href="https://orcid.org/0000-0002-9488-9183"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Barry Rowlingson [ctb],
  Nick Bearman [ctb],
  Nikolai Berkoff [ctb],
  Scott Chamberlain [rev] (Scott reviewed the package for rOpenSci, see
    https://github.com/ropensci/onboarding/issues/10),
  Mark Padgham [ctb],
  Zhao Wang <a href="https://orcid.org/0000-0002-4054-0533"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Andrea Gilardi <a href="https://orcid.org/0000-0002-9424-7439"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-15 08:22:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='stplanr-package'><strong>stplanr: Sustainable Transport Planning with R</strong></h2><span id='topic+stplanr-package'></span><span id='topic+stplanr'></span>

<h3>Description</h3>

<p>The stplanr package provides functions to access
and analyse data for transportation research, including origin-destination analysis,
route allocation and modelling travel patterns.
</p>


<h3>Author(s)</h3>

<p>Robin Lovelace <a href="mailto:rob00x@gmail.com">rob00x@gmail.com</a>
</p>


<h3>See Also</h3>

<p><a href="https://github.com/ropensci/stplanr">https://github.com/ropensci/stplanr</a>
</p>

<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>?magrittr</code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='angle_diff'>Calculate the angular difference between lines and a predefined bearing</h2><span id='topic+angle_diff'></span>

<h3>Description</h3>

<p>This function was designed to find lines that are close to parallel and perpendicular
to some pre-defined route. It can return results that are absolute (contain information
on the direction of turn, i.e. + or - values for clockwise/anticlockwise),
bidirectional (which mean values greater than +/- 90 are impossible).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>angle_diff(l, angle, bidirectional = FALSE, absolute = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="angle_diff_+3A_l">l</code></td>
<td>
<p>A spatial lines object</p>
</td></tr>
<tr><td><code id="angle_diff_+3A_angle">angle</code></td>
<td>
<p>an angle in degrees relative to North, with 90 being East and -90 being West.
(direction of rotation is ignored).</p>
</td></tr>
<tr><td><code id="angle_diff_+3A_bidirectional">bidirectional</code></td>
<td>
<p>Should the result be returned in a bidirectional format?
Default is FALSE. If TRUE, the same line in the oposite direction would have the same bearing</p>
</td></tr>
<tr><td><code id="angle_diff_+3A_absolute">absolute</code></td>
<td>
<p>If TRUE (the default) only positive values can be returned</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Building on the convention used in in the <code>bearing()</code> function from the
<code>geosphere</code> package and in many applications,
North is definied as 0, East as 90 and West as -90.
</p>


<h3>See Also</h3>

<p>Other lines: 
<code><a href="#topic+geo_toptail">geo_toptail</a>()</code>,
<code><a href="#topic+is_linepoint">is_linepoint</a>()</code>,
<code><a href="#topic+line2df">line2df</a>()</code>,
<code><a href="#topic+line2points">line2points</a>()</code>,
<code><a href="#topic+line_bearing">line_bearing</a>()</code>,
<code><a href="#topic+line_breakup">line_breakup</a>()</code>,
<code><a href="#topic+line_midpoint">line_midpoint</a>()</code>,
<code><a href="#topic+line_segment">line_segment</a>()</code>,
<code><a href="#topic+line_via">line_via</a>()</code>,
<code><a href="#topic+mats2line">mats2line</a>()</code>,
<code><a href="#topic+n_vertices">n_vertices</a>()</code>,
<code><a href="#topic+onewaygeo">onewaygeo</a>()</code>,
<code><a href="#topic+points2line">points2line</a>()</code>,
<code><a href="#topic+toptail_buff">toptail_buff</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lib_versions &lt;- sf::sf_extSoftVersion()
lib_versions
# fails on some systems (with early versions of PROJ)
if (lib_versions[3] &gt;= "6.3.1") {
  # Find all routes going North-South
  lines_sf &lt;- od2line(od_data_sample, zones = zones_sf)
  angle_diff(lines_sf[2, ], angle = 0)
  angle_diff(lines_sf[2:3, ], angle = 0)
}
</code></pre>

<hr>
<h2 id='bbox_scale'>Scale a bounding box</h2><span id='topic+bbox_scale'></span>

<h3>Description</h3>

<p>Takes a bounding box as an input and outputs a bounding box of a different size, centred at the same point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bbox_scale(bb, scale_factor)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bbox_scale_+3A_bb">bb</code></td>
<td>
<p>Bounding box object</p>
</td></tr>
<tr><td><code id="bbox_scale_+3A_scale_factor">scale_factor</code></td>
<td>
<p>Numeric vector determining how much the bounding box will grow or shrink.
Two numbers refer to extending the bounding box in x and y dimensions, respectively.
If the value is 1, the output size will be the same as the input.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other geo: 
<code><a href="#topic+bind_sf">bind_sf</a>()</code>,
<code><a href="#topic+geo_bb_matrix">geo_bb_matrix</a>()</code>,
<code><a href="#topic+geo_bb">geo_bb</a>()</code>,
<code><a href="#topic+geo_buffer">geo_buffer</a>()</code>,
<code><a href="#topic+geo_length">geo_length</a>()</code>,
<code><a href="#topic+geo_projected">geo_projected</a>()</code>,
<code><a href="#topic+geo_select_aeq">geo_select_aeq</a>()</code>,
<code><a href="#topic+quadrant">quadrant</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bb &lt;- matrix(c(-1.55, 53.80, -1.50, 53.83), nrow = 2)
bb1 &lt;- bbox_scale(bb, scale_factor = 1.05)
bb2 &lt;- bbox_scale(bb, scale_factor = c(2, 1.05))
bb3 &lt;- bbox_scale(bb, 0.1)
plot(x = bb2[1, ], y = bb2[2, ])
points(bb1[1, ], bb1[2, ])
points(bb3[1, ], bb3[2, ])
points(bb[1, ], bb[2, ], col = "red")
</code></pre>

<hr>
<h2 id='bind_sf'>Rapid row-binding of sf objects</h2><span id='topic+bind_sf'></span>

<h3>Description</h3>

<p>Rapid row-binding of sf objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bind_sf(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bind_sf_+3A_x">x</code></td>
<td>
<p>List of sf objects to combine</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An sf data frame
</p>


<h3>See Also</h3>

<p>Other geo: 
<code><a href="#topic+bbox_scale">bbox_scale</a>()</code>,
<code><a href="#topic+geo_bb_matrix">geo_bb_matrix</a>()</code>,
<code><a href="#topic+geo_bb">geo_bb</a>()</code>,
<code><a href="#topic+geo_buffer">geo_buffer</a>()</code>,
<code><a href="#topic+geo_length">geo_length</a>()</code>,
<code><a href="#topic+geo_projected">geo_projected</a>()</code>,
<code><a href="#topic+geo_select_aeq">geo_select_aeq</a>()</code>,
<code><a href="#topic+quadrant">quadrant</a>()</code>
</p>

<hr>
<h2 id='cents_sf'>Spatial points representing home locations</h2><span id='topic+cents_sf'></span>

<h3>Description</h3>

<p>These points represent population-weighted centroids of Medium Super Output Area (MSOA) zones within a 1 mile radius of of my home when I was writing this package.
</p>


<h3>Format</h3>

<p>A spatial dataset with 8 rows and 5 columns
</p>


<h3>Details</h3>


<ul>
<li><p> geo_code the official code of the zone
</p>
</li>
<li><p> MSOA11NM name zone name
</p>
</li>
<li><p> percent_fem the percent female
</p>
</li>
<li><p> avslope average gradient of the zone
</p>
</li></ul>

<p>Cents was generated from the data repository pct-data: https://github.com/npct/pct-data. This data was accessed from within the pct repo: https://github.com/npct/pct, using the following code:
</p>


<h3>See Also</h3>

<p>Other data: 
<code><a href="#topic+destinations_sf">destinations_sf</a></code>,
<code><a href="#topic+flow_dests">flow_dests</a></code>,
<code><a href="#topic+flowlines_sf">flowlines_sf</a></code>,
<code><a href="#topic+flow">flow</a></code>,
<code><a href="#topic+od_data_lines">od_data_lines</a></code>,
<code><a href="#topic+od_data_routes">od_data_routes</a></code>,
<code><a href="#topic+od_data_sample">od_data_sample</a></code>,
<code><a href="#topic+osm_net_example">osm_net_example</a></code>,
<code><a href="#topic+read_table_builder">read_table_builder</a>()</code>,
<code><a href="#topic+route_network_sf">route_network_sf</a></code>,
<code><a href="#topic+route_network_small">route_network_small</a></code>,
<code><a href="#topic+routes_fast_sf">routes_fast_sf</a></code>,
<code><a href="#topic+routes_slow_sf">routes_slow_sf</a></code>,
<code><a href="#topic+zones_sf">zones_sf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cents_sf
</code></pre>

<hr>
<h2 id='destinations_sf'>Example destinations data</h2><span id='topic+destinations_sf'></span>

<h3>Description</h3>

<p>This dataset represents trip destinations on a different geographic
level than the origins stored in the object <code>cents_sf</code>.
</p>


<h3>Format</h3>

<p>A spatial dataset with 87 features
</p>


<h3>See Also</h3>

<p>Other data: 
<code><a href="#topic+cents_sf">cents_sf</a></code>,
<code><a href="#topic+flow_dests">flow_dests</a></code>,
<code><a href="#topic+flowlines_sf">flowlines_sf</a></code>,
<code><a href="#topic+flow">flow</a></code>,
<code><a href="#topic+od_data_lines">od_data_lines</a></code>,
<code><a href="#topic+od_data_routes">od_data_routes</a></code>,
<code><a href="#topic+od_data_sample">od_data_sample</a></code>,
<code><a href="#topic+osm_net_example">osm_net_example</a></code>,
<code><a href="#topic+read_table_builder">read_table_builder</a>()</code>,
<code><a href="#topic+route_network_sf">route_network_sf</a></code>,
<code><a href="#topic+route_network_small">route_network_small</a></code>,
<code><a href="#topic+routes_fast_sf">routes_fast_sf</a></code>,
<code><a href="#topic+routes_slow_sf">routes_slow_sf</a></code>,
<code><a href="#topic+zones_sf">zones_sf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>destinations_sf
</code></pre>

<hr>
<h2 id='flow'>Data frame of commuter flows</h2><span id='topic+flow'></span>

<h3>Description</h3>

<p>This dataset represents commuter flows (work travel) between origin
and destination zones.
The data is from the UK and is available as open data:
<a href="https://wicid.ukdataservice.ac.uk/">https://wicid.ukdataservice.ac.uk/</a>.
</p>


<h3>Format</h3>

<p>A data frame with 49 rows and 15 columns
</p>


<h3>Details</h3>

<p>The variables are as follows:
</p>

<ul>
<li><p> Area.of.residence. id of origin zone
</p>
</li>
<li><p> Area.of.workplace id of destination zone
</p>
</li>
<li><p> All. Travel to work flows by all modes
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;[,4:15]&#8288;</code>. Flows for different modes
</p>
</li>
<li><p> id. unique id of flow
</p>
</li></ul>

<p>Although these variable names are unique to UK data, the data
structure is generalisable and typical of flow data from any source.
The key variables are the origin and destination ids, which link to
the georeferenced spatial objects.
</p>


<h3>See Also</h3>

<p>Other data: 
<code><a href="#topic+cents_sf">cents_sf</a></code>,
<code><a href="#topic+destinations_sf">destinations_sf</a></code>,
<code><a href="#topic+flow_dests">flow_dests</a></code>,
<code><a href="#topic+flowlines_sf">flowlines_sf</a></code>,
<code><a href="#topic+od_data_lines">od_data_lines</a></code>,
<code><a href="#topic+od_data_routes">od_data_routes</a></code>,
<code><a href="#topic+od_data_sample">od_data_sample</a></code>,
<code><a href="#topic+osm_net_example">osm_net_example</a></code>,
<code><a href="#topic+read_table_builder">read_table_builder</a>()</code>,
<code><a href="#topic+route_network_sf">route_network_sf</a></code>,
<code><a href="#topic+route_network_small">route_network_small</a></code>,
<code><a href="#topic+routes_fast_sf">routes_fast_sf</a></code>,
<code><a href="#topic+routes_slow_sf">routes_slow_sf</a></code>,
<code><a href="#topic+zones_sf">zones_sf</a></code>
</p>
<p>Other data: 
<code><a href="#topic+cents_sf">cents_sf</a></code>,
<code><a href="#topic+destinations_sf">destinations_sf</a></code>,
<code><a href="#topic+flow_dests">flow_dests</a></code>,
<code><a href="#topic+flowlines_sf">flowlines_sf</a></code>,
<code><a href="#topic+od_data_lines">od_data_lines</a></code>,
<code><a href="#topic+od_data_routes">od_data_routes</a></code>,
<code><a href="#topic+od_data_sample">od_data_sample</a></code>,
<code><a href="#topic+osm_net_example">osm_net_example</a></code>,
<code><a href="#topic+read_table_builder">read_table_builder</a>()</code>,
<code><a href="#topic+route_network_sf">route_network_sf</a></code>,
<code><a href="#topic+route_network_small">route_network_small</a></code>,
<code><a href="#topic+routes_fast_sf">routes_fast_sf</a></code>,
<code><a href="#topic+routes_slow_sf">routes_slow_sf</a></code>,
<code><a href="#topic+zones_sf">zones_sf</a></code>
</p>

<hr>
<h2 id='flow_dests'>Data frame of invented
commuter flows with destinations in a different layer than the origins</h2><span id='topic+flow_dests'></span>

<h3>Description</h3>

<p>Data frame of invented
commuter flows with destinations in a different layer than the origins
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(flow_dests)
</code></pre>


<h3>Format</h3>

<p>A data frame with 49 rows and 15 columns
</p>


<h3>See Also</h3>

<p>Other data: 
<code><a href="#topic+cents_sf">cents_sf</a></code>,
<code><a href="#topic+destinations_sf">destinations_sf</a></code>,
<code><a href="#topic+flowlines_sf">flowlines_sf</a></code>,
<code><a href="#topic+flow">flow</a></code>,
<code><a href="#topic+od_data_lines">od_data_lines</a></code>,
<code><a href="#topic+od_data_routes">od_data_routes</a></code>,
<code><a href="#topic+od_data_sample">od_data_sample</a></code>,
<code><a href="#topic+osm_net_example">osm_net_example</a></code>,
<code><a href="#topic+read_table_builder">read_table_builder</a>()</code>,
<code><a href="#topic+route_network_sf">route_network_sf</a></code>,
<code><a href="#topic+route_network_small">route_network_small</a></code>,
<code><a href="#topic+routes_fast_sf">routes_fast_sf</a></code>,
<code><a href="#topic+routes_slow_sf">routes_slow_sf</a></code>,
<code><a href="#topic+zones_sf">zones_sf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# This is how the dataset was constructed
flow_dests &lt;- flow
flow_dests$Area.of.workplace &lt;- sample(x = destinations$WZ11CD, size = nrow(flow))
flow_dests &lt;- dplyr::rename(flow_dests, WZ11CD = Area.of.workplace)
devtools::use_data(flow_dests)

## End(Not run)
</code></pre>

<hr>
<h2 id='flowlines_sf'>Spatial lines dataset of commuter flows</h2><span id='topic+flowlines_sf'></span>

<h3>Description</h3>

<p>Flow data after conversion to a spatial format..
</p>


<h3>Format</h3>

<p>A spatial lines dataset with 49 rows and 15 columns
</p>


<h3>See Also</h3>

<p>Other data: 
<code><a href="#topic+cents_sf">cents_sf</a></code>,
<code><a href="#topic+destinations_sf">destinations_sf</a></code>,
<code><a href="#topic+flow_dests">flow_dests</a></code>,
<code><a href="#topic+flow">flow</a></code>,
<code><a href="#topic+od_data_lines">od_data_lines</a></code>,
<code><a href="#topic+od_data_routes">od_data_routes</a></code>,
<code><a href="#topic+od_data_sample">od_data_sample</a></code>,
<code><a href="#topic+osm_net_example">osm_net_example</a></code>,
<code><a href="#topic+read_table_builder">read_table_builder</a>()</code>,
<code><a href="#topic+route_network_sf">route_network_sf</a></code>,
<code><a href="#topic+route_network_small">route_network_small</a></code>,
<code><a href="#topic+routes_fast_sf">routes_fast_sf</a></code>,
<code><a href="#topic+routes_slow_sf">routes_slow_sf</a></code>,
<code><a href="#topic+zones_sf">zones_sf</a></code>
</p>

<hr>
<h2 id='geo_bb'>Flexible function to generate bounding boxes</h2><span id='topic+geo_bb'></span><span id='topic+bb2poly'></span>

<h3>Description</h3>

<p>Takes a geographic object or bounding box as an input and outputs a bounding box,
represented as a bounding box, corner points or rectangular polygon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geo_bb(
  shp,
  scale_factor = 1,
  distance = 0,
  output = c("polygon", "points", "bb")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geo_bb_+3A_shp">shp</code></td>
<td>
<p>Spatial object</p>
</td></tr>
<tr><td><code id="geo_bb_+3A_scale_factor">scale_factor</code></td>
<td>
<p>Numeric vector determining how much the bounding box will grow or shrink.
Two numbers refer to extending the bounding box in x and y dimensions, respectively.
If the value is 1, the output size will be the same as the input.</p>
</td></tr>
<tr><td><code id="geo_bb_+3A_distance">distance</code></td>
<td>
<p>Distance in metres to extend the bounding box by</p>
</td></tr>
<tr><td><code id="geo_bb_+3A_output">output</code></td>
<td>
<p>Type of object returned (polygon by default)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>bb_scale
</p>
<p>Other geo: 
<code><a href="#topic+bbox_scale">bbox_scale</a>()</code>,
<code><a href="#topic+bind_sf">bind_sf</a>()</code>,
<code><a href="#topic+geo_bb_matrix">geo_bb_matrix</a>()</code>,
<code><a href="#topic+geo_buffer">geo_buffer</a>()</code>,
<code><a href="#topic+geo_length">geo_length</a>()</code>,
<code><a href="#topic+geo_projected">geo_projected</a>()</code>,
<code><a href="#topic+geo_select_aeq">geo_select_aeq</a>()</code>,
<code><a href="#topic+quadrant">quadrant</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>shp &lt;- routes_fast_sf
shp_bb &lt;- geo_bb(shp, distance = 100)
plot(shp_bb, col = "red", reset = FALSE)
plot(geo_bb(routes_fast_sf, scale_factor = 0.8), col = "green", add = TRUE)
plot(routes_fast_sf$geometry, add = TRUE)
geo_bb(shp, output = "point")
</code></pre>

<hr>
<h2 id='geo_bb_matrix'>Create matrix representing the spatial bounds of an object</h2><span id='topic+geo_bb_matrix'></span>

<h3>Description</h3>

<p>Converts a range of spatial data formats into a matrix representing the bounding box
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geo_bb_matrix(shp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geo_bb_matrix_+3A_shp">shp</code></td>
<td>
<p>Spatial object</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other geo: 
<code><a href="#topic+bbox_scale">bbox_scale</a>()</code>,
<code><a href="#topic+bind_sf">bind_sf</a>()</code>,
<code><a href="#topic+geo_bb">geo_bb</a>()</code>,
<code><a href="#topic+geo_buffer">geo_buffer</a>()</code>,
<code><a href="#topic+geo_length">geo_length</a>()</code>,
<code><a href="#topic+geo_projected">geo_projected</a>()</code>,
<code><a href="#topic+geo_select_aeq">geo_select_aeq</a>()</code>,
<code><a href="#topic+quadrant">quadrant</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>geo_bb_matrix(routes_fast_sf)
geo_bb_matrix(cents_sf[1, ])
geo_bb_matrix(c(-2, 54))
geo_bb_matrix(sf::st_coordinates(cents_sf))
</code></pre>

<hr>
<h2 id='geo_buffer'>Perform a buffer operation on a temporary projected CRS</h2><span id='topic+geo_buffer'></span>

<h3>Description</h3>

<p>This function solves the problem that buffers will not be circular when used on
non-projected data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geo_buffer(shp, dist = NULL, width = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geo_buffer_+3A_shp">shp</code></td>
<td>
<p>A spatial object with a geographic CRS (e.g. WGS84)
around which a buffer should be drawn</p>
</td></tr>
<tr><td><code id="geo_buffer_+3A_dist">dist</code></td>
<td>
<p>The distance (in metres) of the buffer (when buffering simple features)</p>
</td></tr>
<tr><td><code id="geo_buffer_+3A_width">width</code></td>
<td>
<p>The distance (in metres) of the buffer (when buffering sp objects)</p>
</td></tr>
<tr><td><code id="geo_buffer_+3A_...">...</code></td>
<td>
<p>Arguments passed to the buffer (see <code>?sf::st_buffer</code> for details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Requires recent version of PROJ (&gt;= 6.3.0).
Buffers on <code>sf</code> objects with geographic (lon/lat) coordinates can also
be done with the <a href="https://r-spatial.github.io/s2/"><code>s2</code></a> package.
</p>


<h3>See Also</h3>

<p>Other geo: 
<code><a href="#topic+bbox_scale">bbox_scale</a>()</code>,
<code><a href="#topic+bind_sf">bind_sf</a>()</code>,
<code><a href="#topic+geo_bb_matrix">geo_bb_matrix</a>()</code>,
<code><a href="#topic+geo_bb">geo_bb</a>()</code>,
<code><a href="#topic+geo_length">geo_length</a>()</code>,
<code><a href="#topic+geo_projected">geo_projected</a>()</code>,
<code><a href="#topic+geo_select_aeq">geo_select_aeq</a>()</code>,
<code><a href="#topic+quadrant">quadrant</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lib_versions &lt;- sf::sf_extSoftVersion()
lib_versions
if (lib_versions[3] &gt;= "6.3.1") {
  buff_sf &lt;- geo_buffer(routes_fast_sf, dist = 50)
  plot(buff_sf$geometry)
  geo_buffer(routes_fast_sf$geometry, dist = 50)
}
</code></pre>

<hr>
<h2 id='geo_code'>Convert text strings into points on the map</h2><span id='topic+geo_code'></span>

<h3>Description</h3>

<p>Generate a lat/long pair from data using Google's geolocation API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geo_code(
  address,
  service = "nominatim",
  base_url = "https://maps.google.com/maps/api/geocode/json",
  return_all = FALSE,
  pat = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geo_code_+3A_address">address</code></td>
<td>
<p>Text string representing the address you want to geocode</p>
</td></tr>
<tr><td><code id="geo_code_+3A_service">service</code></td>
<td>
<p>Which service to use? Nominatim by default</p>
</td></tr>
<tr><td><code id="geo_code_+3A_base_url">base_url</code></td>
<td>
<p>The base url to query</p>
</td></tr>
<tr><td><code id="geo_code_+3A_return_all">return_all</code></td>
<td>
<p>Should the request return all information returned by Google Maps?
The default is <code>FALSE</code>: to return only two numbers: the longitude and latitude, in that order</p>
</td></tr>
<tr><td><code id="geo_code_+3A_pat">pat</code></td>
<td>
<p>Personal access token</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
geo_code(address = "Hereford")
geo_code("LS7 3HB")
geo_code("hereford", return_all = TRUE)
# needs api key in .Renviron
geo_code("hereford", service = "google", pat = Sys.getenv("GOOGLE"), return_all = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='geo_length'>Calculate line length of line with geographic or projected CRS</h2><span id='topic+geo_length'></span>

<h3>Description</h3>

<p>Takes a line (represented in sf or sp classes)
and returns a numeric value representing distance in meters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geo_length(shp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geo_length_+3A_shp">shp</code></td>
<td>
<p>A spatial line object</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other geo: 
<code><a href="#topic+bbox_scale">bbox_scale</a>()</code>,
<code><a href="#topic+bind_sf">bind_sf</a>()</code>,
<code><a href="#topic+geo_bb_matrix">geo_bb_matrix</a>()</code>,
<code><a href="#topic+geo_bb">geo_bb</a>()</code>,
<code><a href="#topic+geo_buffer">geo_buffer</a>()</code>,
<code><a href="#topic+geo_projected">geo_projected</a>()</code>,
<code><a href="#topic+geo_select_aeq">geo_select_aeq</a>()</code>,
<code><a href="#topic+quadrant">quadrant</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lib_versions &lt;- sf::sf_extSoftVersion()
lib_versions
if (lib_versions[3] &gt;= "6.3.1") {
  geo_length(routes_fast_sf)
}
</code></pre>

<hr>
<h2 id='geo_projected'>Perform GIS functions on a temporary, projected version of a spatial object</h2><span id='topic+geo_projected'></span><span id='topic+gprojected'></span>

<h3>Description</h3>

<p>This function performs operations on projected data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geo_projected(shp, fun, crs, silent, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geo_projected_+3A_shp">shp</code></td>
<td>
<p>A spatial object with a geographic (WGS84) coordinate system</p>
</td></tr>
<tr><td><code id="geo_projected_+3A_fun">fun</code></td>
<td>
<p>A function to perform on the projected object (e.g. from the sf package)</p>
</td></tr>
<tr><td><code id="geo_projected_+3A_crs">crs</code></td>
<td>
<p>An optional coordinate reference system (if not provided it is set
automatically by <code><a href="#topic+geo_select_aeq">geo_select_aeq()</a></code>)</p>
</td></tr>
<tr><td><code id="geo_projected_+3A_silent">silent</code></td>
<td>
<p>A binary value for printing the CRS details (default: TRUE)</p>
</td></tr>
<tr><td><code id="geo_projected_+3A_...">...</code></td>
<td>
<p>Arguments to pass to <code>fun</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other geo: 
<code><a href="#topic+bbox_scale">bbox_scale</a>()</code>,
<code><a href="#topic+bind_sf">bind_sf</a>()</code>,
<code><a href="#topic+geo_bb_matrix">geo_bb_matrix</a>()</code>,
<code><a href="#topic+geo_bb">geo_bb</a>()</code>,
<code><a href="#topic+geo_buffer">geo_buffer</a>()</code>,
<code><a href="#topic+geo_length">geo_length</a>()</code>,
<code><a href="#topic+geo_select_aeq">geo_select_aeq</a>()</code>,
<code><a href="#topic+quadrant">quadrant</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lib_versions &lt;- sf::sf_extSoftVersion()
lib_versions
# fails on some systems (with early versions of PROJ)
if (lib_versions[3] &gt;= "6.3.1") {
  shp &lt;- routes_fast_sf[2:4, ]
  geo_projected(shp, sf::st_buffer, dist = 100)
}
</code></pre>

<hr>
<h2 id='geo_select_aeq'>Select a custom projected CRS for the area of interest</h2><span id='topic+geo_select_aeq'></span>

<h3>Description</h3>

<p>This function takes a spatial object with a geographic (WGS84)
CRS and returns a custom projected CRS focussed on the centroid of the object.
This function is especially useful for using units of metres in all directions
for data collected anywhere in the world.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geo_select_aeq(shp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geo_select_aeq_+3A_shp">shp</code></td>
<td>
<p>A spatial object with a geographic (WGS84) coordinate system</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is based on this stackexchange answer:
<a href="https://gis.stackexchange.com/questions/121489">https://gis.stackexchange.com/questions/121489</a>
</p>


<h3>See Also</h3>

<p>Other geo: 
<code><a href="#topic+bbox_scale">bbox_scale</a>()</code>,
<code><a href="#topic+bind_sf">bind_sf</a>()</code>,
<code><a href="#topic+geo_bb_matrix">geo_bb_matrix</a>()</code>,
<code><a href="#topic+geo_bb">geo_bb</a>()</code>,
<code><a href="#topic+geo_buffer">geo_buffer</a>()</code>,
<code><a href="#topic+geo_length">geo_length</a>()</code>,
<code><a href="#topic+geo_projected">geo_projected</a>()</code>,
<code><a href="#topic+quadrant">quadrant</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>shp &lt;- zones_sf
geo_select_aeq(shp)
</code></pre>

<hr>
<h2 id='geo_toptail'>Clip the first and last n metres of SpatialLines</h2><span id='topic+geo_toptail'></span><span id='topic+toptail'></span>

<h3>Description</h3>

<p>Takes lines and removes the start and end point, to a distance determined
by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geo_toptail(l, toptail_dist, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geo_toptail_+3A_l">l</code></td>
<td>
<p>An <code>sf</code> object representing lines</p>
</td></tr>
<tr><td><code id="geo_toptail_+3A_toptail_dist">toptail_dist</code></td>
<td>
<p>The distance (in metres) to top and tail the line by.
Can either be a single value or a vector of the same length as the
SpatialLines object.</p>
</td></tr>
<tr><td><code id="geo_toptail_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>sf::st_buffer()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: see the function
<a href="https://github.com/ropensci/stplanr/blob/v1.0.0/R/toptail.R"><code>toptailgs()</code></a>
in stplanr v0.8.5 for an implementation that uses the geosphere
package.
</p>


<h3>See Also</h3>

<p>Other lines: 
<code><a href="#topic+angle_diff">angle_diff</a>()</code>,
<code><a href="#topic+is_linepoint">is_linepoint</a>()</code>,
<code><a href="#topic+line2df">line2df</a>()</code>,
<code><a href="#topic+line2points">line2points</a>()</code>,
<code><a href="#topic+line_bearing">line_bearing</a>()</code>,
<code><a href="#topic+line_breakup">line_breakup</a>()</code>,
<code><a href="#topic+line_midpoint">line_midpoint</a>()</code>,
<code><a href="#topic+line_segment">line_segment</a>()</code>,
<code><a href="#topic+line_via">line_via</a>()</code>,
<code><a href="#topic+mats2line">mats2line</a>()</code>,
<code><a href="#topic+n_vertices">n_vertices</a>()</code>,
<code><a href="#topic+onewaygeo">onewaygeo</a>()</code>,
<code><a href="#topic+points2line">points2line</a>()</code>,
<code><a href="#topic+toptail_buff">toptail_buff</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lib_versions &lt;- sf::sf_extSoftVersion()
lib_versions
# dont test due to issues with sp classes on some set-ups
if (lib_versions[3] &gt;= "6.3.1") {
  l &lt;- routes_fast_sf[2:4, ]
  l_top_tail &lt;- geo_toptail(l, 300)
  l_top_tail
  plot(sf::st_geometry(l_top_tail))
  plot(sf::st_geometry(geo_toptail(l, 600)), lwd = 9, add = TRUE)
}
</code></pre>

<hr>
<h2 id='gsection'>Function to split overlapping SpatialLines into segments</h2><span id='topic+gsection'></span>

<h3>Description</h3>

<p>Divides SpatialLinesDataFrame objects into separate Lines.
Each new Lines object is the aggregate of a single number
of aggregated lines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsection(sl, buff_dist = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsection_+3A_sl">sl</code></td>
<td>
<p>SpatialLinesDataFrame with overlapping Lines to split by
number of overlapping features.</p>
</td></tr>
<tr><td><code id="gsection_+3A_buff_dist">buff_dist</code></td>
<td>
<p>A number specifying the distance in meters of the buffer to be used to crop lines before running the operation.
If the distance is zero (the default) touching but non-overlapping lines may be aggregated.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other rnet: 
<code><a href="#topic+islines">islines</a>()</code>,
<code><a href="#topic+overline">overline</a>()</code>,
<code><a href="#topic+rnet_breakup_vertices">rnet_breakup_vertices</a>()</code>,
<code><a href="#topic+rnet_group">rnet_group</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lib_versions &lt;- sf::sf_extSoftVersion()
lib_versions
# fails on some systems (with early versions of PROJ)
if (lib_versions[3] &gt;= "6.3.1") {
  sl &lt;- routes_fast_sf[2:4, ]
  rsec &lt;- gsection(sl)
  length(rsec) # sections
  plot(rsec, col = seq(length(rsec)))
  rsec &lt;- gsection(sl, buff_dist = 50)
  length(rsec) # 4 features: issue
  plot(rsec, col = seq(length(rsec)))
}
</code></pre>

<hr>
<h2 id='is_linepoint'>Identify lines that are points</h2><span id='topic+is_linepoint'></span>

<h3>Description</h3>

<p>OD matrices often contain 'intrazonal' flows, where the origin is the same point as the
destination. This function can help identify such intrazonal OD pairs, using 2 criteria:
the total number of vertices (2 or fewer) and whether the origin and destination are the same.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_linepoint(l)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_linepoint_+3A_l">l</code></td>
<td>
<p>A spatial lines object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a boolean vector. TRUE means that the associated line is in fact a point
(has no distance). This can be useful for removing data that will not be plotted.
</p>


<h3>See Also</h3>

<p>Other lines: 
<code><a href="#topic+angle_diff">angle_diff</a>()</code>,
<code><a href="#topic+geo_toptail">geo_toptail</a>()</code>,
<code><a href="#topic+line2df">line2df</a>()</code>,
<code><a href="#topic+line2points">line2points</a>()</code>,
<code><a href="#topic+line_bearing">line_bearing</a>()</code>,
<code><a href="#topic+line_breakup">line_breakup</a>()</code>,
<code><a href="#topic+line_midpoint">line_midpoint</a>()</code>,
<code><a href="#topic+line_segment">line_segment</a>()</code>,
<code><a href="#topic+line_via">line_via</a>()</code>,
<code><a href="#topic+mats2line">mats2line</a>()</code>,
<code><a href="#topic+n_vertices">n_vertices</a>()</code>,
<code><a href="#topic+onewaygeo">onewaygeo</a>()</code>,
<code><a href="#topic+points2line">points2line</a>()</code>,
<code><a href="#topic+toptail_buff">toptail_buff</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>islp &lt;- is_linepoint(flowlines_sf)
nrow(flowlines_sf)
sum(islp)
# Remove invisible 'linepoints'
nrow(flowlines_sf[!islp, ])
</code></pre>

<hr>
<h2 id='islines'>Do the intersections between two geometries create lines?</h2><span id='topic+islines'></span>

<h3>Description</h3>

<p>This is a function required in <code><a href="#topic+overline">overline()</a></code>. It identifies
whether sets of lines overlap (beyond shared points) or
not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>islines(g1, g2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="islines_+3A_g1">g1</code></td>
<td>
<p>A spatial object</p>
</td></tr>
<tr><td><code id="islines_+3A_g2">g2</code></td>
<td>
<p>A spatial object</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other rnet: 
<code><a href="#topic+gsection">gsection</a>()</code>,
<code><a href="#topic+overline">overline</a>()</code>,
<code><a href="#topic+rnet_breakup_vertices">rnet_breakup_vertices</a>()</code>,
<code><a href="#topic+rnet_group">rnet_group</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# sf implementation
islines(routes_fast_sf[2, ], routes_fast_sf[3, ])
islines(routes_fast_sf[2, ], routes_fast_sf[22, ])

## End(Not run)
</code></pre>

<hr>
<h2 id='line_bearing'>Find the bearing of straight lines</h2><span id='topic+line_bearing'></span>

<h3>Description</h3>

<p>This function returns the
bearing (in degrees relative to north) of lines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>line_bearing(l, bidirectional = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="line_bearing_+3A_l">l</code></td>
<td>
<p>A spatial lines object</p>
</td></tr>
<tr><td><code id="line_bearing_+3A_bidirectional">bidirectional</code></td>
<td>
<p>Should the result be returned in a bidirectional format?
Default is FALSE. If TRUE, the same line in the oposite direction would have the same bearing</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a boolean vector. TRUE means that the associated line is in fact a point
(has no distance). This can be useful for removing data that will not be plotted.
</p>


<h3>See Also</h3>

<p>Other lines: 
<code><a href="#topic+angle_diff">angle_diff</a>()</code>,
<code><a href="#topic+geo_toptail">geo_toptail</a>()</code>,
<code><a href="#topic+is_linepoint">is_linepoint</a>()</code>,
<code><a href="#topic+line2df">line2df</a>()</code>,
<code><a href="#topic+line2points">line2points</a>()</code>,
<code><a href="#topic+line_breakup">line_breakup</a>()</code>,
<code><a href="#topic+line_midpoint">line_midpoint</a>()</code>,
<code><a href="#topic+line_segment">line_segment</a>()</code>,
<code><a href="#topic+line_via">line_via</a>()</code>,
<code><a href="#topic+mats2line">mats2line</a>()</code>,
<code><a href="#topic+n_vertices">n_vertices</a>()</code>,
<code><a href="#topic+onewaygeo">onewaygeo</a>()</code>,
<code><a href="#topic+points2line">points2line</a>()</code>,
<code><a href="#topic+toptail_buff">toptail_buff</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lib_versions &lt;- sf::sf_extSoftVersion()
lib_versions
# fails on some systems (with early versions of PROJ)
if (lib_versions[3] &gt;= "6.3.1") {
  bearings_sf_1_9 &lt;- line_bearing(flowlines_sf[1:5, ])
  bearings_sf_1_9 # lines of 0 length have NaN bearing
  line_bearing(flowlines_sf[1:5, ], bidirectional = TRUE)
}
</code></pre>

<hr>
<h2 id='line_breakup'>Break up line objects into shorter segments</h2><span id='topic+line_breakup'></span>

<h3>Description</h3>

<p>This function breaks up a LINESTRING geometries into smaller pieces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>line_breakup(l, z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="line_breakup_+3A_l">l</code></td>
<td>
<p>An sf object with LINESTRING geometry</p>
</td></tr>
<tr><td><code id="line_breakup_+3A_z">z</code></td>
<td>
<p>An sf object with <code>POLYGON</code> geometry or a number representing the
resolution of grid cells used to break up the linestring objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An sf object with LINESTRING geometry created after breaking up the
input object.
</p>


<h3>See Also</h3>

<p>Other lines: 
<code><a href="#topic+angle_diff">angle_diff</a>()</code>,
<code><a href="#topic+geo_toptail">geo_toptail</a>()</code>,
<code><a href="#topic+is_linepoint">is_linepoint</a>()</code>,
<code><a href="#topic+line2df">line2df</a>()</code>,
<code><a href="#topic+line2points">line2points</a>()</code>,
<code><a href="#topic+line_bearing">line_bearing</a>()</code>,
<code><a href="#topic+line_midpoint">line_midpoint</a>()</code>,
<code><a href="#topic+line_segment">line_segment</a>()</code>,
<code><a href="#topic+line_via">line_via</a>()</code>,
<code><a href="#topic+mats2line">mats2line</a>()</code>,
<code><a href="#topic+n_vertices">n_vertices</a>()</code>,
<code><a href="#topic+onewaygeo">onewaygeo</a>()</code>,
<code><a href="#topic+points2line">points2line</a>()</code>,
<code><a href="#topic+toptail_buff">toptail_buff</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
z &lt;- zones_sf$geometry
l &lt;- routes_fast_sf$geometry[2]
l_split &lt;- line_breakup(l, z)
l
l_split
sf::st_length(l)
sum(sf::st_length(l_split))
plot(z)
plot(l, add = TRUE, lwd = 9, col = "grey")
plot(l_split, add = TRUE, col = 1:length(l_split))
</code></pre>

<hr>
<h2 id='line_cast'>Convert multilinestring object into linestrings</h2><span id='topic+line_cast'></span>

<h3>Description</h3>

<p>Without losing vertices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>line_cast(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="line_cast_+3A_x">x</code></td>
<td>
<p>Linestring object</p>
</td></tr>
</table>

<hr>
<h2 id='line_midpoint'>Find the mid-point of lines</h2><span id='topic+line_midpoint'></span>

<h3>Description</h3>

<p>Find the mid-point of lines
</p>


<h3>Usage</h3>

<pre><code class='language-R'>line_midpoint(l, tolerance = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="line_midpoint_+3A_l">l</code></td>
<td>
<p>A spatial lines object</p>
</td></tr>
<tr><td><code id="line_midpoint_+3A_tolerance">tolerance</code></td>
<td>
<p>The tolerance used to break lines at verteces.
See <code><a href="lwgeom.html#topic+st_linesubstring">lwgeom::st_linesubstring()</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other lines: 
<code><a href="#topic+angle_diff">angle_diff</a>()</code>,
<code><a href="#topic+geo_toptail">geo_toptail</a>()</code>,
<code><a href="#topic+is_linepoint">is_linepoint</a>()</code>,
<code><a href="#topic+line2df">line2df</a>()</code>,
<code><a href="#topic+line2points">line2points</a>()</code>,
<code><a href="#topic+line_bearing">line_bearing</a>()</code>,
<code><a href="#topic+line_breakup">line_breakup</a>()</code>,
<code><a href="#topic+line_segment">line_segment</a>()</code>,
<code><a href="#topic+line_via">line_via</a>()</code>,
<code><a href="#topic+mats2line">mats2line</a>()</code>,
<code><a href="#topic+n_vertices">n_vertices</a>()</code>,
<code><a href="#topic+onewaygeo">onewaygeo</a>()</code>,
<code><a href="#topic+points2line">points2line</a>()</code>,
<code><a href="#topic+toptail_buff">toptail_buff</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>l = routes_fast_sf[2:5, ]
plot(l$geometry, col = 2:5)
midpoints = line_midpoint(l)
plot(midpoints, add = TRUE)
</code></pre>

<hr>
<h2 id='line_segment'>Divide an sf object with LINESTRING geometry into regular segments</h2><span id='topic+line_segment'></span>

<h3>Description</h3>

<p>This function keeps the attributes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>line_segment(l, n_segments = NA, segment_length = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="line_segment_+3A_l">l</code></td>
<td>
<p>A spatial lines object</p>
</td></tr>
<tr><td><code id="line_segment_+3A_n_segments">n_segments</code></td>
<td>
<p>The number of segments to divide the line into</p>
</td></tr>
<tr><td><code id="line_segment_+3A_segment_length">segment_length</code></td>
<td>
<p>The approximate length of segments in the output (overides n_segments if set)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other lines: 
<code><a href="#topic+angle_diff">angle_diff</a>()</code>,
<code><a href="#topic+geo_toptail">geo_toptail</a>()</code>,
<code><a href="#topic+is_linepoint">is_linepoint</a>()</code>,
<code><a href="#topic+line2df">line2df</a>()</code>,
<code><a href="#topic+line2points">line2points</a>()</code>,
<code><a href="#topic+line_bearing">line_bearing</a>()</code>,
<code><a href="#topic+line_breakup">line_breakup</a>()</code>,
<code><a href="#topic+line_midpoint">line_midpoint</a>()</code>,
<code><a href="#topic+line_via">line_via</a>()</code>,
<code><a href="#topic+mats2line">mats2line</a>()</code>,
<code><a href="#topic+n_vertices">n_vertices</a>()</code>,
<code><a href="#topic+onewaygeo">onewaygeo</a>()</code>,
<code><a href="#topic+points2line">points2line</a>()</code>,
<code><a href="#topic+toptail_buff">toptail_buff</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>l &lt;- routes_fast_sf[2, ]
l_seg2 &lt;- line_segment(l = l, n_segments = 2)
l_seg3 &lt;- line_segment(l = l, n_segments = 3)
l_seg_100 &lt;- line_segment(l = l, segment_length = 100)
l_seg_2000 &lt;- line_segment(l = l, segment_length = 2000)
plot(sf::st_geometry(l_seg2), col = 1:2, lwd = 5)
plot(sf::st_geometry(l_seg3), col = 1:3, lwd = 5)
plot(sf::st_geometry(l_seg_100), col = seq(nrow(l_seg_100)), lwd = 5)
plot(sf::st_geometry(l_seg_2000), col = seq(nrow(l_seg_100)), lwd = 5)
# Multiple lines
l &lt;- routes_fast_sf[2:4, ]
l_seg_multi = line_segment(l, segment_length = 1000)
plot(sf::st_geometry(l_seg_multi), col = seq(nrow(l_seg_100)), lwd = 5)
</code></pre>

<hr>
<h2 id='line_via'>Add geometry columns representing a route via intermediary points</h2><span id='topic+line_via'></span>

<h3>Description</h3>

<p>Takes an origin (A) and destination (B), represented by the linestring <code>l</code>,
and generates 3 extra geometries based on points <code>p</code>:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>line_via(l, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="line_via_+3A_l">l</code></td>
<td>
<p>A spatial lines object</p>
</td></tr>
<tr><td><code id="line_via_+3A_p">p</code></td>
<td>
<p>A spatial points object</p>
</td></tr>
</table>


<h3>Details</h3>


<ol>
<li><p> From A to P1 (P1 being the nearest point to A)
</p>
</li>
<li><p> From P1 to P2 (P2 being the nearest point to B)
</p>
</li>
<li><p> From P2 to B
</p>
</li></ol>



<h3>See Also</h3>

<p>Other lines: 
<code><a href="#topic+angle_diff">angle_diff</a>()</code>,
<code><a href="#topic+geo_toptail">geo_toptail</a>()</code>,
<code><a href="#topic+is_linepoint">is_linepoint</a>()</code>,
<code><a href="#topic+line2df">line2df</a>()</code>,
<code><a href="#topic+line2points">line2points</a>()</code>,
<code><a href="#topic+line_bearing">line_bearing</a>()</code>,
<code><a href="#topic+line_breakup">line_breakup</a>()</code>,
<code><a href="#topic+line_midpoint">line_midpoint</a>()</code>,
<code><a href="#topic+line_segment">line_segment</a>()</code>,
<code><a href="#topic+mats2line">mats2line</a>()</code>,
<code><a href="#topic+n_vertices">n_vertices</a>()</code>,
<code><a href="#topic+onewaygeo">onewaygeo</a>()</code>,
<code><a href="#topic+points2line">points2line</a>()</code>,
<code><a href="#topic+toptail_buff">toptail_buff</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
l &lt;- flowlines_sf[2:4, ]
p &lt;- destinations_sf
lv &lt;- line_via(l, p)
lv
# library(mapview)
# mapview(lv) +
#    mapview(lv$leg_orig, col = "red")
plot(lv[3], lwd = 9, reset = FALSE)
plot(lv$leg_orig, col = "red", lwd = 5, add = TRUE)
plot(lv$leg_via, col = "black", add = TRUE)
plot(lv$leg_dest, col = "green", lwd = 5, add = TRUE)
</code></pre>

<hr>
<h2 id='line2df'>Convert geographic line objects to a data.frame with from and to coords</h2><span id='topic+line2df'></span>

<h3>Description</h3>

<p>This function returns a data frame with fx and fy and tx and ty variables
representing the beginning and end points of spatial line features respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>line2df(l)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="line2df_+3A_l">l</code></td>
<td>
<p>A spatial lines object</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other lines: 
<code><a href="#topic+angle_diff">angle_diff</a>()</code>,
<code><a href="#topic+geo_toptail">geo_toptail</a>()</code>,
<code><a href="#topic+is_linepoint">is_linepoint</a>()</code>,
<code><a href="#topic+line2points">line2points</a>()</code>,
<code><a href="#topic+line_bearing">line_bearing</a>()</code>,
<code><a href="#topic+line_breakup">line_breakup</a>()</code>,
<code><a href="#topic+line_midpoint">line_midpoint</a>()</code>,
<code><a href="#topic+line_segment">line_segment</a>()</code>,
<code><a href="#topic+line_via">line_via</a>()</code>,
<code><a href="#topic+mats2line">mats2line</a>()</code>,
<code><a href="#topic+n_vertices">n_vertices</a>()</code>,
<code><a href="#topic+onewaygeo">onewaygeo</a>()</code>,
<code><a href="#topic+points2line">points2line</a>()</code>,
<code><a href="#topic+toptail_buff">toptail_buff</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>line2df(routes_fast_sf[5:6, ]) # beginning and end of routes
</code></pre>

<hr>
<h2 id='line2points'>Convert a spatial (linestring) object to points</h2><span id='topic+line2points'></span><span id='topic+line2pointsn'></span><span id='topic+line2vertices'></span>

<h3>Description</h3>

<p>The number of points will be double the number of lines with <code>line2points</code>. A
closely related function, <code>line2pointsn</code> returns all the points that were
line vertices. The points corresponding with a given line, <code>i</code>, will be
<code>(2*i):((2*i)+1)</code>. The last function, <code>line2vertices</code>, returns all the points
that are vertices but not nodes. If the input <code>l</code> object is composed by only
1 LINESTRING with 2 POINTS, then it returns an empty <code>sf</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>line2points(l, ids = rep(1:nrow(l)))

line2pointsn(l)

line2vertices(l)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="line2points_+3A_l">l</code></td>
<td>
<p>An <code>sf</code> object or a <code>SpatialLinesDataFrame</code> from the older <code>sp</code> package</p>
</td></tr>
<tr><td><code id="line2points_+3A_ids">ids</code></td>
<td>
<p>Vector of ids (by default <code>1:nrow(l)</code>)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other lines: 
<code><a href="#topic+angle_diff">angle_diff</a>()</code>,
<code><a href="#topic+geo_toptail">geo_toptail</a>()</code>,
<code><a href="#topic+is_linepoint">is_linepoint</a>()</code>,
<code><a href="#topic+line2df">line2df</a>()</code>,
<code><a href="#topic+line_bearing">line_bearing</a>()</code>,
<code><a href="#topic+line_breakup">line_breakup</a>()</code>,
<code><a href="#topic+line_midpoint">line_midpoint</a>()</code>,
<code><a href="#topic+line_segment">line_segment</a>()</code>,
<code><a href="#topic+line_via">line_via</a>()</code>,
<code><a href="#topic+mats2line">mats2line</a>()</code>,
<code><a href="#topic+n_vertices">n_vertices</a>()</code>,
<code><a href="#topic+onewaygeo">onewaygeo</a>()</code>,
<code><a href="#topic+points2line">points2line</a>()</code>,
<code><a href="#topic+toptail_buff">toptail_buff</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>l &lt;- routes_fast_sf[2, ]
lpoints &lt;- line2points(l)
plot(l$geometry)
plot(lpoints, add = TRUE)
# test all vertices:
plot(l$geometry)
lpoints2 &lt;- line2pointsn(l)
plot(lpoints2$geometry, add = TRUE)

# extract only internal vertices
l_internal_vertices &lt;- line2vertices(l)
plot(sf::st_geometry(l), reset = FALSE)
plot(l_internal_vertices, add = TRUE)
# The boundary points are missing
</code></pre>

<hr>
<h2 id='mats2line'>Convert 2 matrices to lines</h2><span id='topic+mats2line'></span>

<h3>Description</h3>

<p>Convert 2 matrices to lines
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mats2line(mat1, mat2, crs = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mats2line_+3A_mat1">mat1</code></td>
<td>
<p>Matrix representing origins</p>
</td></tr>
<tr><td><code id="mats2line_+3A_mat2">mat2</code></td>
<td>
<p>Matrix representing destinations</p>
</td></tr>
<tr><td><code id="mats2line_+3A_crs">crs</code></td>
<td>
<p>Number representing the coordinate system of the data, e.g. 4326</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other lines: 
<code><a href="#topic+angle_diff">angle_diff</a>()</code>,
<code><a href="#topic+geo_toptail">geo_toptail</a>()</code>,
<code><a href="#topic+is_linepoint">is_linepoint</a>()</code>,
<code><a href="#topic+line2df">line2df</a>()</code>,
<code><a href="#topic+line2points">line2points</a>()</code>,
<code><a href="#topic+line_bearing">line_bearing</a>()</code>,
<code><a href="#topic+line_breakup">line_breakup</a>()</code>,
<code><a href="#topic+line_midpoint">line_midpoint</a>()</code>,
<code><a href="#topic+line_segment">line_segment</a>()</code>,
<code><a href="#topic+line_via">line_via</a>()</code>,
<code><a href="#topic+n_vertices">n_vertices</a>()</code>,
<code><a href="#topic+onewaygeo">onewaygeo</a>()</code>,
<code><a href="#topic+points2line">points2line</a>()</code>,
<code><a href="#topic+toptail_buff">toptail_buff</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m1 &lt;- matrix(c(1, 2, 1, 2), ncol = 2)
m2 &lt;- matrix(c(9, 9, 9, 1), ncol = 2)
l &lt;- mats2line(m1, m2)
class(l)
l
lsf &lt;- sf::st_sf(l, crs = 4326)
class(lsf)
plot(lsf)
# mapview::mapview(lsf)
</code></pre>

<hr>
<h2 id='n_vertices'>Retrieve the number of vertices in sf objects</h2><span id='topic+n_vertices'></span>

<h3>Description</h3>

<p>Returns a vector of the same length as the number of sf objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_vertices(l)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_vertices_+3A_l">l</code></td>
<td>
<p>An sf object with LINESTRING geometry</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other lines: 
<code><a href="#topic+angle_diff">angle_diff</a>()</code>,
<code><a href="#topic+geo_toptail">geo_toptail</a>()</code>,
<code><a href="#topic+is_linepoint">is_linepoint</a>()</code>,
<code><a href="#topic+line2df">line2df</a>()</code>,
<code><a href="#topic+line2points">line2points</a>()</code>,
<code><a href="#topic+line_bearing">line_bearing</a>()</code>,
<code><a href="#topic+line_breakup">line_breakup</a>()</code>,
<code><a href="#topic+line_midpoint">line_midpoint</a>()</code>,
<code><a href="#topic+line_segment">line_segment</a>()</code>,
<code><a href="#topic+line_via">line_via</a>()</code>,
<code><a href="#topic+mats2line">mats2line</a>()</code>,
<code><a href="#topic+onewaygeo">onewaygeo</a>()</code>,
<code><a href="#topic+points2line">points2line</a>()</code>,
<code><a href="#topic+toptail_buff">toptail_buff</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>l = routes_fast_sf
n_vertices(l)
n_vertices(zones_sf)
</code></pre>

<hr>
<h2 id='od_aggregate_from'>Summary statistics of trips originating from zones in OD data</h2><span id='topic+od_aggregate_from'></span>

<h3>Description</h3>

<p>This function takes a data frame of OD data and
returns a data frame reporting summary statistics for each unique zone of origin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>od_aggregate_from(flow, attrib = NULL, FUN = sum, ..., col = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="od_aggregate_from_+3A_flow">flow</code></td>
<td>
<p>A data frame representing origin-destination data.
The first two columns of this data frame should correspond
to the first column of the data in the zones. Thus in <code><a href="#topic+cents_sf">cents_sf()</a></code>,
the first column is geo_code. This corresponds to the first two columns
of <code><a href="#topic+flow">flow()</a></code>.</p>
</td></tr>
<tr><td><code id="od_aggregate_from_+3A_attrib">attrib</code></td>
<td>
<p>character, column names in sl to be aggregated</p>
</td></tr>
<tr><td><code id="od_aggregate_from_+3A_fun">FUN</code></td>
<td>
<p>A function to summarise OD data by</p>
</td></tr>
<tr><td><code id="od_aggregate_from_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>FUN</code></p>
</td></tr>
<tr><td><code id="od_aggregate_from_+3A_col">col</code></td>
<td>
<p>The column that the OD dataset is grouped by
(1 by default, the first column usually represents the origin)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It has some default settings: the default summary statistic is <code>sum()</code> and the
first column in the OD data is assumed to represent the zone of origin.
By default, if <code>attrib</code> is not set, it summarises all numeric columns.
</p>


<h3>See Also</h3>

<p>Other od: 
<code><a href="#topic+od2line">od2line</a>()</code>,
<code><a href="#topic+od2odf">od2odf</a>()</code>,
<code><a href="#topic+od_aggregate_to">od_aggregate_to</a>()</code>,
<code><a href="#topic+od_coords2line">od_coords2line</a>()</code>,
<code><a href="#topic+od_coords">od_coords</a>()</code>,
<code><a href="#topic+od_id_order">od_id_order</a>()</code>,
<code><a href="#topic+od_id">od_id</a></code>,
<code><a href="#topic+od_oneway">od_oneway</a>()</code>,
<code><a href="#topic+od_to_odmatrix">od_to_odmatrix</a>()</code>,
<code><a href="#topic+odmatrix_to_od">odmatrix_to_od</a>()</code>,
<code><a href="#topic+points2flow">points2flow</a>()</code>,
<code><a href="#topic+points2odf">points2odf</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>od_aggregate_from(flow)
</code></pre>

<hr>
<h2 id='od_aggregate_to'>Summary statistics of trips arriving at destination zones in OD data</h2><span id='topic+od_aggregate_to'></span>

<h3>Description</h3>

<p>This function takes a data frame of OD data and
returns a data frame reporting summary statistics for each unique zone of destination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>od_aggregate_to(flow, attrib = NULL, FUN = sum, ..., col = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="od_aggregate_to_+3A_flow">flow</code></td>
<td>
<p>A data frame representing origin-destination data.
The first two columns of this data frame should correspond
to the first column of the data in the zones. Thus in <code><a href="#topic+cents_sf">cents_sf()</a></code>,
the first column is geo_code. This corresponds to the first two columns
of <code><a href="#topic+flow">flow()</a></code>.</p>
</td></tr>
<tr><td><code id="od_aggregate_to_+3A_attrib">attrib</code></td>
<td>
<p>character, column names in sl to be aggregated</p>
</td></tr>
<tr><td><code id="od_aggregate_to_+3A_fun">FUN</code></td>
<td>
<p>A function to summarise OD data by</p>
</td></tr>
<tr><td><code id="od_aggregate_to_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>FUN</code></p>
</td></tr>
<tr><td><code id="od_aggregate_to_+3A_col">col</code></td>
<td>
<p>The column that the OD dataset is grouped by
(1 by default, the first column usually represents the origin)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It has some default settings: it assumes the destination ID column is the 2nd
and the default summary statistic is <code>sum()</code>.
By default, if <code>attrib</code> is not set, it summarises all numeric columns.
</p>


<h3>See Also</h3>

<p>Other od: 
<code><a href="#topic+od2line">od2line</a>()</code>,
<code><a href="#topic+od2odf">od2odf</a>()</code>,
<code><a href="#topic+od_aggregate_from">od_aggregate_from</a>()</code>,
<code><a href="#topic+od_coords2line">od_coords2line</a>()</code>,
<code><a href="#topic+od_coords">od_coords</a>()</code>,
<code><a href="#topic+od_id_order">od_id_order</a>()</code>,
<code><a href="#topic+od_id">od_id</a></code>,
<code><a href="#topic+od_oneway">od_oneway</a>()</code>,
<code><a href="#topic+od_to_odmatrix">od_to_odmatrix</a>()</code>,
<code><a href="#topic+odmatrix_to_od">odmatrix_to_od</a>()</code>,
<code><a href="#topic+points2flow">points2flow</a>()</code>,
<code><a href="#topic+points2odf">points2odf</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>od_aggregate_to(flow)
</code></pre>

<hr>
<h2 id='od_coords'>Create matrices representing origin-destination coordinates</h2><span id='topic+od_coords'></span>

<h3>Description</h3>

<p>This function takes a wide range of input data types (spatial lines, points or text strings)
and returns a matrix of coordinates representing origin (fx, fy) and destination (tx, ty) points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>od_coords(from = NULL, to = NULL, l = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="od_coords_+3A_from">from</code></td>
<td>
<p>An object representing origins
(if lines are provided as the first argument, from is assigned to <code>l</code>)</p>
</td></tr>
<tr><td><code id="od_coords_+3A_to">to</code></td>
<td>
<p>An object representing destinations</p>
</td></tr>
<tr><td><code id="od_coords_+3A_l">l</code></td>
<td>
<p>Only needed if from and to are empty, in which case this
should be a spatial object representing desire lines</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other od: 
<code><a href="#topic+od2line">od2line</a>()</code>,
<code><a href="#topic+od2odf">od2odf</a>()</code>,
<code><a href="#topic+od_aggregate_from">od_aggregate_from</a>()</code>,
<code><a href="#topic+od_aggregate_to">od_aggregate_to</a>()</code>,
<code><a href="#topic+od_coords2line">od_coords2line</a>()</code>,
<code><a href="#topic+od_id_order">od_id_order</a>()</code>,
<code><a href="#topic+od_id">od_id</a></code>,
<code><a href="#topic+od_oneway">od_oneway</a>()</code>,
<code><a href="#topic+od_to_odmatrix">od_to_odmatrix</a>()</code>,
<code><a href="#topic+odmatrix_to_od">odmatrix_to_od</a>()</code>,
<code><a href="#topic+points2flow">points2flow</a>()</code>,
<code><a href="#topic+points2odf">points2odf</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>od_coords(from = c(0, 52), to = c(1, 53)) # lon/lat coordinates
od_coords(cents_sf[1:3, ], cents_sf[2:4, ]) # sf points
# od_coords("Hereford", "Leeds") # geocode locations
od_coords(flowlines_sf[1:3, ])
</code></pre>

<hr>
<h2 id='od_coords2line'>Convert origin-destination coordinates into desire lines</h2><span id='topic+od_coords2line'></span>

<h3>Description</h3>

<p>Convert origin-destination coordinates into desire lines
</p>


<h3>Usage</h3>

<pre><code class='language-R'>od_coords2line(odc, crs = 4326, remove_duplicates = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="od_coords2line_+3A_odc">odc</code></td>
<td>
<p>A data frame or matrix representing the coordinates
of origin-destination data. The first two columns represent the
coordinates of the origin (typically longitude and latitude) points;
the third and fourth columns represent the coordinates of the destination
(in the same CRS). Each row represents travel from origin to destination.</p>
</td></tr>
<tr><td><code id="od_coords2line_+3A_crs">crs</code></td>
<td>
<p>A number representing the coordinate reference system
of the result, 4326 by default.</p>
</td></tr>
<tr><td><code id="od_coords2line_+3A_remove_duplicates">remove_duplicates</code></td>
<td>
<p>Should rows with duplicated rows be removed? <code>TRUE</code> by default.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other od: 
<code><a href="#topic+od2line">od2line</a>()</code>,
<code><a href="#topic+od2odf">od2odf</a>()</code>,
<code><a href="#topic+od_aggregate_from">od_aggregate_from</a>()</code>,
<code><a href="#topic+od_aggregate_to">od_aggregate_to</a>()</code>,
<code><a href="#topic+od_coords">od_coords</a>()</code>,
<code><a href="#topic+od_id_order">od_id_order</a>()</code>,
<code><a href="#topic+od_id">od_id</a></code>,
<code><a href="#topic+od_oneway">od_oneway</a>()</code>,
<code><a href="#topic+od_to_odmatrix">od_to_odmatrix</a>()</code>,
<code><a href="#topic+odmatrix_to_od">odmatrix_to_od</a>()</code>,
<code><a href="#topic+points2flow">points2flow</a>()</code>,
<code><a href="#topic+points2odf">points2odf</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>odf &lt;- od_coords(l = flowlines_sf)
odlines &lt;- od_coords2line(odf)
odlines &lt;- od_coords2line(odf, crs = 4326)
plot(odlines)
x_coords &lt;- 1:3
n &lt;- 50
d &lt;- data.frame(lapply(1:4, function(x) sample(x_coords, n, replace = TRUE)))
names(d) &lt;- c("fx", "fy", "tx", "ty")
l &lt;- od_coords2line(d)
plot(l)
nrow(l)
l_with_duplicates &lt;- od_coords2line(d, remove_duplicates = FALSE)
plot(l_with_duplicates)
nrow(l_with_duplicates)
</code></pre>

<hr>
<h2 id='od_data_lines'>Example of desire line representations of origin-destination data from UK Census</h2><span id='topic+od_data_lines'></span>

<h3>Description</h3>

<p>Derived from <code>od_data_sample</code> showing movement between points represented in <code>cents_sf</code>
</p>


<h3>Format</h3>

<p>A data frame (tibble) object
</p>


<h3>See Also</h3>

<p>Other data: 
<code><a href="#topic+cents_sf">cents_sf</a></code>,
<code><a href="#topic+destinations_sf">destinations_sf</a></code>,
<code><a href="#topic+flow_dests">flow_dests</a></code>,
<code><a href="#topic+flowlines_sf">flowlines_sf</a></code>,
<code><a href="#topic+flow">flow</a></code>,
<code><a href="#topic+od_data_routes">od_data_routes</a></code>,
<code><a href="#topic+od_data_sample">od_data_sample</a></code>,
<code><a href="#topic+osm_net_example">osm_net_example</a></code>,
<code><a href="#topic+read_table_builder">read_table_builder</a>()</code>,
<code><a href="#topic+route_network_sf">route_network_sf</a></code>,
<code><a href="#topic+route_network_small">route_network_small</a></code>,
<code><a href="#topic+routes_fast_sf">routes_fast_sf</a></code>,
<code><a href="#topic+routes_slow_sf">routes_slow_sf</a></code>,
<code><a href="#topic+zones_sf">zones_sf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>od_data_lines
</code></pre>

<hr>
<h2 id='od_data_routes'>Example segment-level route data</h2><span id='topic+od_data_routes'></span>

<h3>Description</h3>

<p>See <code>data-raw/generate-data.Rmd</code> for details on how this was created.
The dataset shows routes between origins and destinations represented in
<code>od_data_lines</code>
</p>


<h3>Format</h3>

<p>A data frame (tibble) object
</p>


<h3>See Also</h3>

<p>Other data: 
<code><a href="#topic+cents_sf">cents_sf</a></code>,
<code><a href="#topic+destinations_sf">destinations_sf</a></code>,
<code><a href="#topic+flow_dests">flow_dests</a></code>,
<code><a href="#topic+flowlines_sf">flowlines_sf</a></code>,
<code><a href="#topic+flow">flow</a></code>,
<code><a href="#topic+od_data_lines">od_data_lines</a></code>,
<code><a href="#topic+od_data_sample">od_data_sample</a></code>,
<code><a href="#topic+osm_net_example">osm_net_example</a></code>,
<code><a href="#topic+read_table_builder">read_table_builder</a>()</code>,
<code><a href="#topic+route_network_sf">route_network_sf</a></code>,
<code><a href="#topic+route_network_small">route_network_small</a></code>,
<code><a href="#topic+routes_fast_sf">routes_fast_sf</a></code>,
<code><a href="#topic+routes_slow_sf">routes_slow_sf</a></code>,
<code><a href="#topic+zones_sf">zones_sf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>od_data_routes
</code></pre>

<hr>
<h2 id='od_data_sample'>Example of origin-destination data from UK Census</h2><span id='topic+od_data_sample'></span>

<h3>Description</h3>

<p>See <code>data-raw/generate-data.Rmd</code> for details on how this was created.
</p>


<h3>Format</h3>

<p>A data frame (tibble) object
</p>


<h3>See Also</h3>

<p>Other data: 
<code><a href="#topic+cents_sf">cents_sf</a></code>,
<code><a href="#topic+destinations_sf">destinations_sf</a></code>,
<code><a href="#topic+flow_dests">flow_dests</a></code>,
<code><a href="#topic+flowlines_sf">flowlines_sf</a></code>,
<code><a href="#topic+flow">flow</a></code>,
<code><a href="#topic+od_data_lines">od_data_lines</a></code>,
<code><a href="#topic+od_data_routes">od_data_routes</a></code>,
<code><a href="#topic+osm_net_example">osm_net_example</a></code>,
<code><a href="#topic+read_table_builder">read_table_builder</a>()</code>,
<code><a href="#topic+route_network_sf">route_network_sf</a></code>,
<code><a href="#topic+route_network_small">route_network_small</a></code>,
<code><a href="#topic+routes_fast_sf">routes_fast_sf</a></code>,
<code><a href="#topic+routes_slow_sf">routes_slow_sf</a></code>,
<code><a href="#topic+zones_sf">zones_sf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>od_data_sample
</code></pre>

<hr>
<h2 id='od_id'>Combine two ID values to create a single ID number</h2><span id='topic+od_id'></span><span id='topic+od_id_szudzik'></span><span id='topic+od_id_max_min'></span><span id='topic+od_id_character'></span>

<h3>Description</h3>

<p>Combine two ID values to create a single ID number
</p>


<h3>Usage</h3>

<pre><code class='language-R'>od_id_szudzik(x, y, ordermatters = FALSE)

od_id_max_min(x, y)

od_id_character(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="od_id_+3A_x">x</code></td>
<td>
<p>a vector of numeric, character, or factor values</p>
</td></tr>
<tr><td><code id="od_id_+3A_y">y</code></td>
<td>
<p>a vector of numeric, character, or factor values</p>
</td></tr>
<tr><td><code id="od_id_+3A_ordermatters">ordermatters</code></td>
<td>
<p>logical, does the order of values matter to pairing, default = FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In OD data it is common to have many 'oneway' flows from &quot;A to B&quot; and &quot;B to A&quot;.
It can be useful to group these an have a single ID that represents pairs of IDs
with or without directionality, so they contain 'twoway' or bi-directional values.
</p>
<p><code style="white-space: pre;">&#8288;od_id*&#8288;</code> functions take two vectors of equal length and return a vector of IDs,
which are unique for each combination but the same for twoway flows.
</p>

<ul>
<li><p> the Szudzik pairing function, on two vectors of equal
length. It returns a vector of ID numbers.
</p>
</li></ul>

<p>This function superseeds od_id_order as it is faster on large datasets
</p>


<h3>See Also</h3>

<p>Other od: 
<code><a href="#topic+od2line">od2line</a>()</code>,
<code><a href="#topic+od2odf">od2odf</a>()</code>,
<code><a href="#topic+od_aggregate_from">od_aggregate_from</a>()</code>,
<code><a href="#topic+od_aggregate_to">od_aggregate_to</a>()</code>,
<code><a href="#topic+od_coords2line">od_coords2line</a>()</code>,
<code><a href="#topic+od_coords">od_coords</a>()</code>,
<code><a href="#topic+od_id_order">od_id_order</a>()</code>,
<code><a href="#topic+od_oneway">od_oneway</a>()</code>,
<code><a href="#topic+od_to_odmatrix">od_to_odmatrix</a>()</code>,
<code><a href="#topic+odmatrix_to_od">odmatrix_to_od</a>()</code>,
<code><a href="#topic+points2flow">points2flow</a>()</code>,
<code><a href="#topic+points2odf">points2odf</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(d &lt;- od_data_sample[2:9, 1:2])
(id &lt;- od_id_character(d[[1]], d[[2]]))
duplicated(id)
od_id_szudzik(d[[1]], d[[2]])
od_id_max_min(d[[1]], d[[2]])
</code></pre>

<hr>
<h2 id='od_id_order'>Generate ordered ids of OD pairs so lowest is always first
This function is slow on large datasets, see szudzik_pairing for faster alternative</h2><span id='topic+od_id_order'></span>

<h3>Description</h3>

<p>Generate ordered ids of OD pairs so lowest is always first
This function is slow on large datasets, see szudzik_pairing for faster alternative
</p>


<h3>Usage</h3>

<pre><code class='language-R'>od_id_order(x, id1 = names(x)[1], id2 = names(x)[2])
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="od_id_order_+3A_x">x</code></td>
<td>
<p>A data frame or SpatialLinesDataFrame, representing an OD matrix</p>
</td></tr>
<tr><td><code id="od_id_order_+3A_id1">id1</code></td>
<td>
<p>Optional (it is assumed to be the first column)
text string referring to the name of the variable containing
the unique id of the origin</p>
</td></tr>
<tr><td><code id="od_id_order_+3A_id2">id2</code></td>
<td>
<p>Optional (it is assumed to be the second column)
text string referring to the name of the variable containing
the unique id of the destination</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other od: 
<code><a href="#topic+od2line">od2line</a>()</code>,
<code><a href="#topic+od2odf">od2odf</a>()</code>,
<code><a href="#topic+od_aggregate_from">od_aggregate_from</a>()</code>,
<code><a href="#topic+od_aggregate_to">od_aggregate_to</a>()</code>,
<code><a href="#topic+od_coords2line">od_coords2line</a>()</code>,
<code><a href="#topic+od_coords">od_coords</a>()</code>,
<code><a href="#topic+od_id">od_id</a></code>,
<code><a href="#topic+od_oneway">od_oneway</a>()</code>,
<code><a href="#topic+od_to_odmatrix">od_to_odmatrix</a>()</code>,
<code><a href="#topic+odmatrix_to_od">odmatrix_to_od</a>()</code>,
<code><a href="#topic+points2flow">points2flow</a>()</code>,
<code><a href="#topic+points2odf">points2odf</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(id1 = c(1, 1, 2, 2, 3), id2 = c(1, 2, 3, 1, 4))
od_id_order(x) # 4th line switches id1 and id2 so stplanr.key is in order
</code></pre>

<hr>
<h2 id='od_oneway'>Aggregate od pairs they become non-directional</h2><span id='topic+od_oneway'></span>

<h3>Description</h3>

<p>For example, sum total travel in both directions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>od_oneway(
  x,
  attrib = names(x[-c(1:2)])[vapply(x[-c(1:2)], is.numeric, TRUE)],
  id1 = names(x)[1],
  id2 = names(x)[2],
  stplanr.key = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="od_oneway_+3A_x">x</code></td>
<td>
<p>A data frame or SpatialLinesDataFrame, representing an OD matrix</p>
</td></tr>
<tr><td><code id="od_oneway_+3A_attrib">attrib</code></td>
<td>
<p>A vector of column numbers or names, representing variables to be aggregated.
By default, all numeric variables are selected.
aggregate</p>
</td></tr>
<tr><td><code id="od_oneway_+3A_id1">id1</code></td>
<td>
<p>Optional (it is assumed to be the first column)
text string referring to the name of the variable containing
the unique id of the origin</p>
</td></tr>
<tr><td><code id="od_oneway_+3A_id2">id2</code></td>
<td>
<p>Optional (it is assumed to be the second column)
text string referring to the name of the variable containing
the unique id of the destination</p>
</td></tr>
<tr><td><code id="od_oneway_+3A_stplanr.key">stplanr.key</code></td>
<td>
<p>Optional key of unique OD pairs regardless of the order,
e.g., as generated by <code><a href="#topic+od_id_max_min">od_id_max_min()</a></code> or <code><a href="#topic+od_id_szudzik">od_id_szudzik()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Flow data often contains movement in two directions: from point A to point B
and then from B to A. This can be problematic for transport planning, because
the magnitude of flow along a route can be masked by flows the other direction.
If only the largest flow in either direction is captured in an analysis, for
example, the true extent of travel will by heavily under-estimated for
OD pairs which have similar amounts of travel in both directions.
Flows in both direction are often represented by overlapping lines with
identical geometries which can be confusing
for users and are difficult to plot.
</p>


<h3>Value</h3>

<p><code>oneway</code> outputs a data frame (or <code>sf</code> data frame) with rows containing
results for the user-selected attribute values that have been aggregated.
</p>


<h3>See Also</h3>

<p>Other od: 
<code><a href="#topic+od2line">od2line</a>()</code>,
<code><a href="#topic+od2odf">od2odf</a>()</code>,
<code><a href="#topic+od_aggregate_from">od_aggregate_from</a>()</code>,
<code><a href="#topic+od_aggregate_to">od_aggregate_to</a>()</code>,
<code><a href="#topic+od_coords2line">od_coords2line</a>()</code>,
<code><a href="#topic+od_coords">od_coords</a>()</code>,
<code><a href="#topic+od_id_order">od_id_order</a>()</code>,
<code><a href="#topic+od_id">od_id</a></code>,
<code><a href="#topic+od_to_odmatrix">od_to_odmatrix</a>()</code>,
<code><a href="#topic+odmatrix_to_od">odmatrix_to_od</a>()</code>,
<code><a href="#topic+points2flow">points2flow</a>()</code>,
<code><a href="#topic+points2odf">points2odf</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(od_min &lt;- od_data_sample[c(1, 2, 9), 1:6])
(od_oneway &lt;- od_oneway(od_min))
# (od_oneway_old = onewayid(od_min, attrib = 3:6)) # old implementation
nrow(od_oneway) &lt; nrow(od_min) # result has fewer rows
sum(od_min$all) == sum(od_oneway$all) # but the same total flow
od_oneway(od_min, attrib = "all")
attrib &lt;- which(vapply(flow, is.numeric, TRUE))
flow_oneway &lt;- od_oneway(flow, attrib = attrib)
colSums(flow_oneway[attrib]) == colSums(flow[attrib]) # test if the colSums are equal
# Demonstrate the results from oneway and onewaygeo are identical
flow_oneway_sf &lt;- od_oneway(flowlines_sf)
plot(flow_oneway_sf$geometry, lwd = flow_oneway_sf$All / mean(flow_oneway_sf$All))
</code></pre>

<hr>
<h2 id='od_to_odmatrix'>Convert origin-destination data from long to wide format</h2><span id='topic+od_to_odmatrix'></span>

<h3>Description</h3>

<p>This function takes a data frame representing travel between origins
(with origin codes in <code>name_orig</code>, typically the 1st column)
and destinations
(with destination codes in <code>name_dest</code>, typically the second column) and returns a matrix
with cell values (from <code>attrib</code>, the third column by default) representing travel between
origins and destinations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>od_to_odmatrix(flow, attrib = 3, name_orig = 1, name_dest = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="od_to_odmatrix_+3A_flow">flow</code></td>
<td>
<p>A data frame representing flows between origin and destinations</p>
</td></tr>
<tr><td><code id="od_to_odmatrix_+3A_attrib">attrib</code></td>
<td>
<p>A number or character string representing the column containing the attribute data
of interest from the <code>flow</code> data frame</p>
</td></tr>
<tr><td><code id="od_to_odmatrix_+3A_name_orig">name_orig</code></td>
<td>
<p>A number or character string representing the zone of origin</p>
</td></tr>
<tr><td><code id="od_to_odmatrix_+3A_name_dest">name_dest</code></td>
<td>
<p>A number or character string representing the zone of destination</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other od: 
<code><a href="#topic+od2line">od2line</a>()</code>,
<code><a href="#topic+od2odf">od2odf</a>()</code>,
<code><a href="#topic+od_aggregate_from">od_aggregate_from</a>()</code>,
<code><a href="#topic+od_aggregate_to">od_aggregate_to</a>()</code>,
<code><a href="#topic+od_coords2line">od_coords2line</a>()</code>,
<code><a href="#topic+od_coords">od_coords</a>()</code>,
<code><a href="#topic+od_id_order">od_id_order</a>()</code>,
<code><a href="#topic+od_id">od_id</a></code>,
<code><a href="#topic+od_oneway">od_oneway</a>()</code>,
<code><a href="#topic+odmatrix_to_od">odmatrix_to_od</a>()</code>,
<code><a href="#topic+points2flow">points2flow</a>()</code>,
<code><a href="#topic+points2odf">points2odf</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>od_to_odmatrix(flow)
od_to_odmatrix(flow[1:9, ])
od_to_odmatrix(flow[1:9, ], attrib = "Bicycle")
</code></pre>

<hr>
<h2 id='od2line'>Convert origin-destination data to spatial lines</h2><span id='topic+od2line'></span>

<h3>Description</h3>

<p>Origin-destination ('OD') flow data is often provided
in the form of 1 line per flow with zone codes of origin and destination
centroids. This can be tricky to plot and link-up with geographical data.
This function makes the task easier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>od2line(
  flow,
  zones,
  destinations = NULL,
  zone_code = names(zones)[1],
  origin_code = names(flow)[1],
  dest_code = names(flow)[2],
  zone_code_d = NA,
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="od2line_+3A_flow">flow</code></td>
<td>
<p>A data frame representing origin-destination data.
The first two columns of this data frame should correspond
to the first column of the data in the zones. Thus in <code><a href="#topic+cents_sf">cents_sf()</a></code>,
the first column is geo_code. This corresponds to the first two columns
of <code><a href="#topic+flow">flow()</a></code>.</p>
</td></tr>
<tr><td><code id="od2line_+3A_zones">zones</code></td>
<td>
<p>A spatial object representing origins (and destinations
if no separate destinations object is provided) of travel.</p>
</td></tr>
<tr><td><code id="od2line_+3A_destinations">destinations</code></td>
<td>
<p>A spatial object
representing destinations of travel flows.</p>
</td></tr>
<tr><td><code id="od2line_+3A_zone_code">zone_code</code></td>
<td>
<p>Name of the variable in <code>zones</code> containing the ids of the zone.
By default this is the first column names in the zones.</p>
</td></tr>
<tr><td><code id="od2line_+3A_origin_code">origin_code</code></td>
<td>
<p>Name of the variable in <code>flow</code> containing the ids of the zone of origin.
By default this is the first column name in the flow input dataset.</p>
</td></tr>
<tr><td><code id="od2line_+3A_dest_code">dest_code</code></td>
<td>
<p>Name of the variable in <code>flow</code> containing the ids of the zone of destination.
By default this is the second column name in the flow input dataset or the first column name in the
destinations if that is set.</p>
</td></tr>
<tr><td><code id="od2line_+3A_zone_code_d">zone_code_d</code></td>
<td>
<p>Name of the variable in <code>destinations</code> containing the ids of the zone.
By default this is the first column names in the destinations.</p>
</td></tr>
<tr><td><code id="od2line_+3A_silent">silent</code></td>
<td>
<p>TRUE by default, setting it to TRUE will show you the matching columns</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Origin-destination (OD) data is often provided
in the form of 1 line per OD pair, with zone codes of the trip origin in the first
column and the zone codes of the destination in the second column
(see the <a href="https://docs.ropensci.org/stplanr/articles/stplanr-od.html"><code>vignette("stplanr-od")</code></a>) for details.
<code>od2line()</code> creates a spatial (linestring) object representing movement from the origin
to the destination for each OD pair.
It takes data frame containing
origin and destination cones (<code>flow</code>) that match the first column in a
a spatial (polygon or point) object (<code>zones</code>).
</p>


<h3>See Also</h3>

<p>Other od: 
<code><a href="#topic+od2odf">od2odf</a>()</code>,
<code><a href="#topic+od_aggregate_from">od_aggregate_from</a>()</code>,
<code><a href="#topic+od_aggregate_to">od_aggregate_to</a>()</code>,
<code><a href="#topic+od_coords2line">od_coords2line</a>()</code>,
<code><a href="#topic+od_coords">od_coords</a>()</code>,
<code><a href="#topic+od_id_order">od_id_order</a>()</code>,
<code><a href="#topic+od_id">od_id</a></code>,
<code><a href="#topic+od_oneway">od_oneway</a>()</code>,
<code><a href="#topic+od_to_odmatrix">od_to_odmatrix</a>()</code>,
<code><a href="#topic+odmatrix_to_od">odmatrix_to_od</a>()</code>,
<code><a href="#topic+points2flow">points2flow</a>()</code>,
<code><a href="#topic+points2odf">points2odf</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>od_data &lt;- stplanr::flow[1:20, ]
l &lt;- od2line(flow = od_data, zones = cents_sf)
plot(sf::st_geometry(cents_sf))
plot(l, lwd = l$All / mean(l$All), add = TRUE)
</code></pre>

<hr>
<h2 id='od2odf'>Extract coordinates from OD data</h2><span id='topic+od2odf'></span>

<h3>Description</h3>

<p>Extract coordinates from OD data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>od2odf(flow, zones)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="od2odf_+3A_flow">flow</code></td>
<td>
<p>A data frame representing origin-destination data.
The first two columns of this data frame should correspond
to the first column of the data in the zones. Thus in <code><a href="#topic+cents_sf">cents_sf()</a></code>,
the first column is geo_code. This corresponds to the first two columns
of <code><a href="#topic+flow">flow()</a></code>.</p>
</td></tr>
<tr><td><code id="od2odf_+3A_zones">zones</code></td>
<td>
<p>A spatial object representing origins (and destinations
if no separate destinations object is provided) of travel.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Origin-destination (OD) data is often provided
in the form of 1 line per OD pair, with zone codes of the trip origin in the first
column and the zone codes of the destination in the second column
(see the <a href="https://docs.ropensci.org/stplanr/articles/stplanr-od.html"><code>vignette("stplanr-od")</code></a>) for details.
<code>od2odf()</code> creates an 'origin-destination data frame', with columns containing
origin and destination codes (<code>flow</code>) that match the first column in a
a spatial (polygon or point <code>sf</code>) object (<code>zones</code>).
</p>
<p>The function returns a data frame with coordinates for the origin and destination.
</p>


<h3>See Also</h3>

<p>Other od: 
<code><a href="#topic+od2line">od2line</a>()</code>,
<code><a href="#topic+od_aggregate_from">od_aggregate_from</a>()</code>,
<code><a href="#topic+od_aggregate_to">od_aggregate_to</a>()</code>,
<code><a href="#topic+od_coords2line">od_coords2line</a>()</code>,
<code><a href="#topic+od_coords">od_coords</a>()</code>,
<code><a href="#topic+od_id_order">od_id_order</a>()</code>,
<code><a href="#topic+od_id">od_id</a></code>,
<code><a href="#topic+od_oneway">od_oneway</a>()</code>,
<code><a href="#topic+od_to_odmatrix">od_to_odmatrix</a>()</code>,
<code><a href="#topic+odmatrix_to_od">odmatrix_to_od</a>()</code>,
<code><a href="#topic+points2flow">points2flow</a>()</code>,
<code><a href="#topic+points2odf">points2odf</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>od2odf(flow[1:2, ], zones_sf)
</code></pre>

<hr>
<h2 id='odmatrix_to_od'>Convert origin-destination data from wide to long format</h2><span id='topic+odmatrix_to_od'></span>

<h3>Description</h3>

<p>This function takes a matrix representing travel between origins
(with origin codes in the <code>rownames</code> of the matrix)
and destinations
(with destination codes in the <code>colnames</code> of the matrix)
and returns a data frame representing origin-destination pairs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>odmatrix_to_od(odmatrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="odmatrix_to_od_+3A_odmatrix">odmatrix</code></td>
<td>
<p>A matrix with row and columns representing origin and destination zone codes
and cells representing the flow between these zones.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns a data frame with rows ordered by origin and then destination
zone code values and with names <code>orig</code>, <code>dest</code> and <code>flow</code>.
</p>


<h3>See Also</h3>

<p>Other od: 
<code><a href="#topic+od2line">od2line</a>()</code>,
<code><a href="#topic+od2odf">od2odf</a>()</code>,
<code><a href="#topic+od_aggregate_from">od_aggregate_from</a>()</code>,
<code><a href="#topic+od_aggregate_to">od_aggregate_to</a>()</code>,
<code><a href="#topic+od_coords2line">od_coords2line</a>()</code>,
<code><a href="#topic+od_coords">od_coords</a>()</code>,
<code><a href="#topic+od_id_order">od_id_order</a>()</code>,
<code><a href="#topic+od_id">od_id</a></code>,
<code><a href="#topic+od_oneway">od_oneway</a>()</code>,
<code><a href="#topic+od_to_odmatrix">od_to_odmatrix</a>()</code>,
<code><a href="#topic+points2flow">points2flow</a>()</code>,
<code><a href="#topic+points2odf">points2odf</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>odmatrix &lt;- od_to_odmatrix(flow)
odmatrix_to_od(odmatrix)
flow[1:9, 1:3]
odmatrix_to_od(od_to_odmatrix(flow[1:9, 1:3]))
</code></pre>

<hr>
<h2 id='onewaygeo'>Aggregate flows so they become non-directional (by geometry - the slow way)</h2><span id='topic+onewaygeo'></span>

<h3>Description</h3>

<p>Flow data often contains movement in two directions: from point A to point B
and then from B to A. This can be problematic for transport planning, because
the magnitude of flow along a route can be masked by flows the other direction.
If only the largest flow in either direction is captured in an analysis, for
example, the true extent of travel will by heavily under-estimated for
OD pairs which have similar amounts of travel in both directions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>onewaygeo(x, attrib)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="onewaygeo_+3A_x">x</code></td>
<td>
<p>A dataset containing linestring geometries</p>
</td></tr>
<tr><td><code id="onewaygeo_+3A_attrib">attrib</code></td>
<td>
<p>A text string containing the name of the line's attribute to
aggregate or a numeric vector of the columns to be aggregated</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function aggregates directional flows into non-directional flows,
potentially halving the number of lines objects and reducing the number
of overlapping lines to zero.
</p>


<h3>Value</h3>

<p><code>onewaygeo</code> outputs a SpatialLinesDataFrame with single lines
and user-selected attribute values that have been aggregated. Only lines
with a distance (i.e. not intra-zone flows) are included
</p>


<h3>See Also</h3>

<p>Other lines: 
<code><a href="#topic+angle_diff">angle_diff</a>()</code>,
<code><a href="#topic+geo_toptail">geo_toptail</a>()</code>,
<code><a href="#topic+is_linepoint">is_linepoint</a>()</code>,
<code><a href="#topic+line2df">line2df</a>()</code>,
<code><a href="#topic+line2points">line2points</a>()</code>,
<code><a href="#topic+line_bearing">line_bearing</a>()</code>,
<code><a href="#topic+line_breakup">line_breakup</a>()</code>,
<code><a href="#topic+line_midpoint">line_midpoint</a>()</code>,
<code><a href="#topic+line_segment">line_segment</a>()</code>,
<code><a href="#topic+line_via">line_via</a>()</code>,
<code><a href="#topic+mats2line">mats2line</a>()</code>,
<code><a href="#topic+n_vertices">n_vertices</a>()</code>,
<code><a href="#topic+points2line">points2line</a>()</code>,
<code><a href="#topic+toptail_buff">toptail_buff</a>()</code>
</p>

<hr>
<h2 id='osm_net_example'>Example of OpenStreetMap road network</h2><span id='topic+osm_net_example'></span>

<h3>Description</h3>

<p>Example of OpenStreetMap road network
</p>


<h3>Format</h3>

<p>An sf object
</p>


<h3>See Also</h3>

<p>Other data: 
<code><a href="#topic+cents_sf">cents_sf</a></code>,
<code><a href="#topic+destinations_sf">destinations_sf</a></code>,
<code><a href="#topic+flow_dests">flow_dests</a></code>,
<code><a href="#topic+flowlines_sf">flowlines_sf</a></code>,
<code><a href="#topic+flow">flow</a></code>,
<code><a href="#topic+od_data_lines">od_data_lines</a></code>,
<code><a href="#topic+od_data_routes">od_data_routes</a></code>,
<code><a href="#topic+od_data_sample">od_data_sample</a></code>,
<code><a href="#topic+read_table_builder">read_table_builder</a>()</code>,
<code><a href="#topic+route_network_sf">route_network_sf</a></code>,
<code><a href="#topic+route_network_small">route_network_small</a></code>,
<code><a href="#topic+routes_fast_sf">routes_fast_sf</a></code>,
<code><a href="#topic+routes_slow_sf">routes_slow_sf</a></code>,
<code><a href="#topic+zones_sf">zones_sf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>osm_net_example
</code></pre>

<hr>
<h2 id='overline'>Convert series of overlapping lines into a route network</h2><span id='topic+overline'></span><span id='topic+overline2'></span>

<h3>Description</h3>

<p>This function takes a series of overlapping lines and converts them into a
single route network.
</p>
<p>This function is intended as a replacement for overline() and is significantly faster
especially on large datasets. However, it also uses more memory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overline(
  sl,
  attrib,
  ncores = 1,
  simplify = TRUE,
  regionalise = 1e+09,
  quiet = ifelse(nrow(sl) &lt; 1000, TRUE, FALSE),
  fun = sum
)

overline2(
  sl,
  attrib,
  ncores = 1,
  simplify = TRUE,
  regionalise = 1e+07,
  quiet = ifelse(nrow(sl) &lt; 1000, TRUE, FALSE),
  fun = sum
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overline_+3A_sl">sl</code></td>
<td>
<p>A spatial object representing routes on a transport network</p>
</td></tr>
<tr><td><code id="overline_+3A_attrib">attrib</code></td>
<td>
<p>character, column names in sl to be aggregated</p>
</td></tr>
<tr><td><code id="overline_+3A_ncores">ncores</code></td>
<td>
<p>integer, how many cores to use in parallel processing, default = 1</p>
</td></tr>
<tr><td><code id="overline_+3A_simplify">simplify</code></td>
<td>
<p>logical, if TRUE group final segments back into lines, default = TRUE</p>
</td></tr>
<tr><td><code id="overline_+3A_regionalise">regionalise</code></td>
<td>
<p>integer, during simplification regonalisation is used if the number of segments exceeds this value</p>
</td></tr>
<tr><td><code id="overline_+3A_quiet">quiet</code></td>
<td>
<p>Should the the function omit messages? <code>NULL</code> by default,
which means the output will only be shown if <code>sl</code> has more than 1000 rows.</p>
</td></tr>
<tr><td><code id="overline_+3A_fun">fun</code></td>
<td>
<p>Named list of functions to summaries the attributes by? <code>sum</code> is the default.
<code>list(sum = sum, average = mean)</code> will summarise all <code>attrib</code>utes by sum and mean.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function can be used to estimate the amount of transport 'flow' at the
route segment level based on input datasets from routing services, for
example linestring geometries created with the <code>route()</code> function.
</p>
<p>The <code>overline()</code> function breaks each line into many straight
segments and then looks for duplicated segments. Attributes are summed for
all duplicated segments, and if simplify is TRUE the segments with identical
attributes are recombined into linestrings.
</p>
<p>The following arguments only apply to the <code>sf</code> implementation of <code>overline()</code>:
</p>

<ul>
<li> <p><code>ncores</code>, the number of cores to use in parallel processing
</p>
</li>
<li> <p><code>simplify</code>, should the final segments be converted back into longer lines? The default
setting is <code>TRUE</code>. <code>simplify = FALSE</code> results in straight line segments consisting
of only 2 vertices (the start and end point),
resulting in a data frame with many more rows than the simplified results (see examples).
</p>
</li>
<li> <p><code>regionalise</code> the threshold number of rows above which
regionalisation is used (see details).
</p>
</li></ul>

<p>For <code>sf</code> objects Regionalisation breaks the dataset into a 10 x 10 grid and
then performed the simplification across each grid. This significantly
reduces computation time for large datasets, but slightly increases the final
file size. For smaller datasets it increases computation time slightly but
reduces memory usage and so may also be useful.
</p>
<p>A known limitation of this method is that overlapping segments of different
lengths are not aggregated. This can occur when lines stop halfway down a
road. Typically these errors are small, but some artefacts may remain within
the resulting data.
</p>
<p>For very large datasets nrow(x) &gt; 1000000, memory usage can be significant.
In these cases is is possible to overline subsets of the dataset, rbind the
results together, and then overline again, to produce a final result.
</p>
<p>Multicore support is only enabled for the regionalised simplification stage
as it does not help with other stages.
</p>


<h3>Value</h3>

<p>An <code>sf</code> object representing a route network
</p>


<h3>Author(s)</h3>

<p>Barry Rowlingson
</p>
<p>Malcolm Morgan
</p>


<h3>References</h3>

<p>Morgan M and Lovelace R (2020). Travel flow aggregation: Nationally scalable methods
for interactive and online visualisation of transport behaviour at the road network level.
Environment and Planning B: Urban Analytics and City Science. July 2020.
<a href="https://doi.org/10.1177/2399808320942779">doi:10.1177/2399808320942779</a>.
</p>
<p>Rowlingson, B (2015). Overlaying lines and aggregating their values for overlapping
segments. Reproducible question from <a href="https://gis.stackexchange.com">https://gis.stackexchange.com</a>. See
<a href="https://gis.stackexchange.com/questions/139681/">https://gis.stackexchange.com/questions/139681/</a>.
</p>


<h3>See Also</h3>

<p>Other rnet: 
<code><a href="#topic+gsection">gsection</a>()</code>,
<code><a href="#topic+islines">islines</a>()</code>,
<code><a href="#topic+rnet_breakup_vertices">rnet_breakup_vertices</a>()</code>,
<code><a href="#topic+rnet_group">rnet_group</a>()</code>
</p>
<p>Other rnet: 
<code><a href="#topic+gsection">gsection</a>()</code>,
<code><a href="#topic+islines">islines</a>()</code>,
<code><a href="#topic+rnet_breakup_vertices">rnet_breakup_vertices</a>()</code>,
<code><a href="#topic+rnet_group">rnet_group</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sl &lt;- routes_fast_sf[2:4, ]
sl$All &lt;- flowlines_sf$All[2:4]
rnet &lt;- overline(sl = sl, attrib = "All")
nrow(sl)
nrow(rnet)
plot(rnet)
rnet_mean &lt;- overline(sl, c("All", "av_incline"), fun = list(mean = mean, sum = sum))
plot(rnet_mean, lwd = rnet_mean$All_sum / mean(rnet_mean$All_sum))
rnet_sf_raw &lt;- overline(sl, attrib = "length", simplify = FALSE)
nrow(rnet_sf_raw)
summary(n_vertices(rnet_sf_raw))
plot(rnet_sf_raw)
rnet_sf_raw$n &lt;- 1:nrow(rnet_sf_raw)
plot(rnet_sf_raw[10:25, ])
</code></pre>

<hr>
<h2 id='overline_intersection'>Convert series of overlapping lines into a route network</h2><span id='topic+overline_intersection'></span>

<h3>Description</h3>

<p>This function takes overlapping <code>LINESTRING</code>s stored in an
<code>sf</code> object and returns a route network composed of non-overlapping
geometries and aggregated values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overline_intersection(sl, attrib, fun = sum)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overline_intersection_+3A_sl">sl</code></td>
<td>
<p>An <code>sf</code> <code>LINESTRING</code> object with overlapping elements</p>
</td></tr>
<tr><td><code id="overline_intersection_+3A_attrib">attrib</code></td>
<td>
<p>character, column names in sl to be aggregated</p>
</td></tr>
<tr><td><code id="overline_intersection_+3A_fun">fun</code></td>
<td>
<p>Named list of functions to summaries the attributes by? <code>sum</code> is the default.
<code>list(sum = sum, average = mean)</code> will summarise all <code>attrib</code>utes by sum and mean.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>routes_fast_sf$value &lt;- 1
sl &lt;- routes_fast_sf[4:6, ]
attrib &lt;- c("value", "length")
rnet &lt;- overline_intersection(sl = sl, attrib)
plot(rnet, lwd = rnet$value)
# A larger example
sl &lt;- routes_fast_sf[4:7, ]
rnet &lt;- overline_intersection(sl = sl, attrib = c("value", "length"))
plot(rnet, lwd = rnet$value)
rnet_sf &lt;- overline(routes_fast_sf[4:7, ], attrib = c("value", "length"))
plot(rnet_sf, lwd = rnet_sf$value)

# An even larger example (not shown, takes time to run)
# rnet = overline_intersection(routes_fast_sf, attrib = c("value", "length"))
# rnet_sf &lt;- overline(routes_fast_sf, attrib = c("value", "length"), buff_dist = 10)
# plot(rnet$geometry, lwd = rnet$value * 2, col = "grey")
# plot(rnet_sf$geometry,  lwd = rnet_sf$value, add = TRUE)
</code></pre>

<hr>
<h2 id='points2flow'>Convert a series of points into geographical flows</h2><span id='topic+points2flow'></span>

<h3>Description</h3>

<p>Takes a series of geographical points and converts them into a spatial (linestring) object
representing the potential flows, or 'spatial interaction', between every combination
of points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>points2flow(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="points2flow_+3A_p">p</code></td>
<td>
<p>A spatial (point) object</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other od: 
<code><a href="#topic+od2line">od2line</a>()</code>,
<code><a href="#topic+od2odf">od2odf</a>()</code>,
<code><a href="#topic+od_aggregate_from">od_aggregate_from</a>()</code>,
<code><a href="#topic+od_aggregate_to">od_aggregate_to</a>()</code>,
<code><a href="#topic+od_coords2line">od_coords2line</a>()</code>,
<code><a href="#topic+od_coords">od_coords</a>()</code>,
<code><a href="#topic+od_id_order">od_id_order</a>()</code>,
<code><a href="#topic+od_id">od_id</a></code>,
<code><a href="#topic+od_oneway">od_oneway</a>()</code>,
<code><a href="#topic+od_to_odmatrix">od_to_odmatrix</a>()</code>,
<code><a href="#topic+odmatrix_to_od">odmatrix_to_od</a>()</code>,
<code><a href="#topic+points2odf">points2odf</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>flow_sf &lt;- points2flow(cents_sf[1:4, ])
plot(flow_sf)
</code></pre>

<hr>
<h2 id='points2line'>Convert a series of points, or a matrix of coordinates, into a line</h2><span id='topic+points2line'></span>

<h3>Description</h3>

<p>This function makes that makes the creation of <code>sf</code>
objects with LINESTRING geometries easy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>points2line(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="points2line_+3A_p">p</code></td>
<td>
<p>A spatial (points) obect or matrix representing the coordinates of points.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other lines: 
<code><a href="#topic+angle_diff">angle_diff</a>()</code>,
<code><a href="#topic+geo_toptail">geo_toptail</a>()</code>,
<code><a href="#topic+is_linepoint">is_linepoint</a>()</code>,
<code><a href="#topic+line2df">line2df</a>()</code>,
<code><a href="#topic+line2points">line2points</a>()</code>,
<code><a href="#topic+line_bearing">line_bearing</a>()</code>,
<code><a href="#topic+line_breakup">line_breakup</a>()</code>,
<code><a href="#topic+line_midpoint">line_midpoint</a>()</code>,
<code><a href="#topic+line_segment">line_segment</a>()</code>,
<code><a href="#topic+line_via">line_via</a>()</code>,
<code><a href="#topic+mats2line">mats2line</a>()</code>,
<code><a href="#topic+n_vertices">n_vertices</a>()</code>,
<code><a href="#topic+onewaygeo">onewaygeo</a>()</code>,
<code><a href="#topic+toptail_buff">toptail_buff</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>l_sf &lt;- points2line(cents_sf)
plot(l_sf)
</code></pre>

<hr>
<h2 id='points2odf'>Convert a series of points into a dataframe of origins and destinations</h2><span id='topic+points2odf'></span>

<h3>Description</h3>

<p>Takes a series of geographical points and converts them into a data.frame
representing the potential flows, or 'spatial interaction', between every combination
of points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>points2odf(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="points2odf_+3A_p">p</code></td>
<td>
<p>A spatial points object</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other od: 
<code><a href="#topic+od2line">od2line</a>()</code>,
<code><a href="#topic+od2odf">od2odf</a>()</code>,
<code><a href="#topic+od_aggregate_from">od_aggregate_from</a>()</code>,
<code><a href="#topic+od_aggregate_to">od_aggregate_to</a>()</code>,
<code><a href="#topic+od_coords2line">od_coords2line</a>()</code>,
<code><a href="#topic+od_coords">od_coords</a>()</code>,
<code><a href="#topic+od_id_order">od_id_order</a>()</code>,
<code><a href="#topic+od_id">od_id</a></code>,
<code><a href="#topic+od_oneway">od_oneway</a>()</code>,
<code><a href="#topic+od_to_odmatrix">od_to_odmatrix</a>()</code>,
<code><a href="#topic+odmatrix_to_od">odmatrix_to_od</a>()</code>,
<code><a href="#topic+points2flow">points2flow</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>points2odf(cents_sf)
</code></pre>

<hr>
<h2 id='quadrant'>Split a spatial object into quadrants</h2><span id='topic+quadrant'></span>

<h3>Description</h3>

<p>Returns a character vector of NE, SE, SW, NW corresponding to north-east, south-east
quadrants respectively. If number_out is TRUE, returns numbers from 1:4, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quadrant(x, cent = NULL, number_out = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quadrant_+3A_x">x</code></td>
<td>
<p>Object of class sf</p>
</td></tr>
<tr><td><code id="quadrant_+3A_cent">cent</code></td>
<td>
<p>The centrepoint of the region of interest.
Quadrants will be defined based on this point.
By default this will be the geographic centroid of the zones.</p>
</td></tr>
<tr><td><code id="quadrant_+3A_number_out">number_out</code></td>
<td>
<p>Should the result be returned as a number?</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other geo: 
<code><a href="#topic+bbox_scale">bbox_scale</a>()</code>,
<code><a href="#topic+bind_sf">bind_sf</a>()</code>,
<code><a href="#topic+geo_bb_matrix">geo_bb_matrix</a>()</code>,
<code><a href="#topic+geo_bb">geo_bb</a>()</code>,
<code><a href="#topic+geo_buffer">geo_buffer</a>()</code>,
<code><a href="#topic+geo_length">geo_length</a>()</code>,
<code><a href="#topic+geo_projected">geo_projected</a>()</code>,
<code><a href="#topic+geo_select_aeq">geo_select_aeq</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = zones_sf
(quads &lt;- quadrant(x))
plot(x$geometry, col = factor(quads))
</code></pre>

<hr>
<h2 id='read_table_builder'>Import and format Australian Bureau of Statistics (ABS) TableBuilder files</h2><span id='topic+read_table_builder'></span>

<h3>Description</h3>

<p>Import and format Australian Bureau of Statistics (ABS) TableBuilder files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_table_builder(dataset, filetype = "csv", sheet = 1, removeTotal = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_table_builder_+3A_dataset">dataset</code></td>
<td>
<p>Either a dataframe containing the original data from
TableBuilder or a character string containing the path of the
unzipped TableBuilder file.</p>
</td></tr>
<tr><td><code id="read_table_builder_+3A_filetype">filetype</code></td>
<td>
<p>A character string containing the filetype. Valid values
are 'csv', 'legacycsv' and 'xlsx' (default = 'csv'). Required even when
dataset is a dataframe. Use 'legacycsv' for csv files derived from earlier
versions of TableBuilder for which csv outputs were csv versions of the
xlsx files. Current csv output from TableBuilder follow a more standard
csv format.</p>
</td></tr>
<tr><td><code id="read_table_builder_+3A_sheet">sheet</code></td>
<td>
<p>An integer value containing the index of the sheet in the
xlsx file (default = 1).</p>
</td></tr>
<tr><td><code id="read_table_builder_+3A_removetotal">removeTotal</code></td>
<td>
<p>A boolean value. If TRUE removes the rows and columns
with totals (default = TRUE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Australian Bureau of Statistics (ABS) provides customised tables for
census and other datasets in a format that is difficult to use in R
because it contains rows with additional information.
This function imports the original (unzipped) TableBuilder files in .csv
or .xlsx format before creating an R dataframe with the data.
</p>
<p>Note: we recommend using the
<a href="https://github.com/mattcowgill/readabs">readabs</a>
package for this purpose.
</p>


<h3>See Also</h3>

<p>Other data: 
<code><a href="#topic+cents_sf">cents_sf</a></code>,
<code><a href="#topic+destinations_sf">destinations_sf</a></code>,
<code><a href="#topic+flow_dests">flow_dests</a></code>,
<code><a href="#topic+flowlines_sf">flowlines_sf</a></code>,
<code><a href="#topic+flow">flow</a></code>,
<code><a href="#topic+od_data_lines">od_data_lines</a></code>,
<code><a href="#topic+od_data_routes">od_data_routes</a></code>,
<code><a href="#topic+od_data_sample">od_data_sample</a></code>,
<code><a href="#topic+osm_net_example">osm_net_example</a></code>,
<code><a href="#topic+route_network_sf">route_network_sf</a></code>,
<code><a href="#topic+route_network_small">route_network_small</a></code>,
<code><a href="#topic+routes_fast_sf">routes_fast_sf</a></code>,
<code><a href="#topic+routes_slow_sf">routes_slow_sf</a></code>,
<code><a href="#topic+zones_sf">zones_sf</a></code>
</p>

<hr>
<h2 id='rnet_add_node'>Add a node to route network</h2><span id='topic+rnet_add_node'></span>

<h3>Description</h3>

<p>Add a node to route network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rnet_add_node(rnet, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rnet_add_node_+3A_rnet">rnet</code></td>
<td>
<p>A route network of the type generated by <code>overline()</code></p>
</td></tr>
<tr><td><code id="rnet_add_node_+3A_p">p</code></td>
<td>
<p>A point represented by an <code>sf</code> object the will split the <code>route</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>sample_routes &lt;- routes_fast_sf[2:6, NULL]
sample_routes$value &lt;- rep(1:3, length.out = 5)
rnet &lt;- overline2(sample_routes, attrib = "value")
p &lt;- sf::st_sfc(sf::st_point(c(-1.540, 53.826)), crs = sf::st_crs(rnet))
r_split &lt;- route_split(rnet, p)
plot(rnet$geometry, lwd = rnet$value * 5, col = "grey")
plot(p, cex = 9, add = TRUE)
plot(r_split, col = 1:nrow(r_split), add = TRUE, lwd = r_split$value)
</code></pre>

<hr>
<h2 id='rnet_boundary_points'>Get points at the beginner and end of linestrings</h2><span id='topic+rnet_boundary_points'></span><span id='topic+rnet_boundary_df'></span><span id='topic+rnet_boundary_unique'></span><span id='topic+rnet_boundary_points_lwgeom'></span><span id='topic+rnet_duplicated_vertices'></span>

<h3>Description</h3>

<p>Get points at the beginner and end of linestrings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rnet_boundary_points(rnet)

rnet_boundary_df(rnet)

rnet_boundary_unique(rnet)

rnet_boundary_points_lwgeom(rnet)

rnet_duplicated_vertices(rnet, n = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rnet_boundary_points_+3A_rnet">rnet</code></td>
<td>
<p>An sf or sfc object with LINESTRING geometry representing a route
network.</p>
</td></tr>
<tr><td><code id="rnet_boundary_points_+3A_n">n</code></td>
<td>
<p>The minimum number of time a vertex must be duplicated to be returned</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>has_sfheaders &lt;- requireNamespace("sfheaders", quietly = TRUE)
if(has_sfheaders) {
rnet &lt;- rnet_roundabout
bp1 &lt;- rnet_boundary_points(rnet)
bp2 &lt;- line2points(rnet) # slower version with lwgeom
bp3 &lt;- rnet_boundary_points_lwgeom(rnet) # slower version with lwgeom
bp4 &lt;- rnet_boundary_unique(rnet)
nrow(bp1)
nrow(bp3)
identical(sort(sf::st_coordinates(bp1)), sort(sf::st_coordinates(bp2)))
identical(sort(sf::st_coordinates(bp3)), sort(sf::st_coordinates(bp4)))
plot(rnet$geometry)
plot(bp3, add = TRUE)
}
</code></pre>

<hr>
<h2 id='rnet_breakup_vertices'>Break up an sf object with LINESTRING geometry.</h2><span id='topic+rnet_breakup_vertices'></span>

<h3>Description</h3>

<p>This function breaks up a LINESTRING geometry into multiple LINESTRING(s). It
is used mainly for preserving routability of an object that is
created using Open Street Map data. See details,
<a href="https://github.com/ropensci/stplanr/issues/282">stplanr/issues/282</a>, and
<a href="https://github.com/ropensci/stplanr/issues/416">stplanr/issues/416</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rnet_breakup_vertices(rnet, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rnet_breakup_vertices_+3A_rnet">rnet</code></td>
<td>
<p>An sf or sfc object with LINESTRING geometry representing a route
network.</p>
</td></tr>
<tr><td><code id="rnet_breakup_vertices_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. If TRUE, the function prints additional messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A LINESTRING geometry is broken-up when one of the two following conditions
are met:
</p>

<ol>
<li><p> two or more LINESTRINGS share a POINT which is a boundary point for some
LINESTRING(s), but not all of them (see the rnet_roundabout example);
</p>
</li>
<li><p> two or more LINESTRINGS share a POINT which is not in the boundary of any
LINESTRING (see the rnet_cycleway_intersection example).
</p>
</li></ol>

<p>The problem with the first example is that, according to algorithm behind
<code>SpatialLinesNetwork()</code>, two LINESTRINGS are connected if and only if they
share at least one point in their boundaries. The roads and the roundabout
are clearly connected in the &quot;real&quot; world but the corresponding LINESTRING
objects do not share two distinct boundary points. In fact, by Open Street
Map standards, a roundabout is represented as a closed and circular
LINESTRING, and this implies that the roundabout is not connected to the
other roads according to <code>SpatialLinesNetwork()</code> definition. By the same
reasoning, the roads in the second example are clearly connected in the
&quot;real&quot; world, but they do not share any point in their boundaries. This
function is used to solve this type of problem.
</p>


<h3>Value</h3>

<p>An sf or sfc object with LINESTRING geometry created after breaking
up the input object.
</p>


<h3>See Also</h3>

<p>Other rnet: 
<code><a href="#topic+gsection">gsection</a>()</code>,
<code><a href="#topic+islines">islines</a>()</code>,
<code><a href="#topic+overline">overline</a>()</code>,
<code><a href="#topic+rnet_group">rnet_group</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
def_par &lt;- par(no.readonly = TRUE)
par(mar = rep(0, 4))

# Check the geometry of the roundabout example. The dots represent the
# boundary points of the LINESTRINGS. The "isolated" red point in the
# top-left is the boundary point of the roundabout, and it is not shared
# with any other street.
plot(st_geometry(rnet_roundabout), lwd = 2, col = rainbow(nrow(rnet_roundabout)))
boundary_points &lt;- st_geometry(line2points(rnet_roundabout))
points_cols &lt;- rep(rainbow(nrow(rnet_roundabout)), each = 2)
plot(boundary_points, pch = 16, add = TRUE, col = points_cols, cex = 2)

# Clean the roundabout example.
rnet_roundabout_clean &lt;- rnet_breakup_vertices(rnet_roundabout)
plot(st_geometry(rnet_roundabout_clean), lwd = 2, col = rainbow(nrow(rnet_roundabout_clean)))
boundary_points &lt;- st_geometry(line2points(rnet_roundabout_clean))
points_cols &lt;- rep(rainbow(nrow(rnet_roundabout_clean)), each = 2)
plot(boundary_points, pch = 16, add = TRUE, col = points_cols)
# The roundabout is now routable since it was divided into multiple pieces
# (one for each colour), which, according to SpatialLinesNetwork() function,
# are connected.

# Check the geometry of the overpasses example. This example is used to test
# that this function does not create any spurious intersection.
plot(st_geometry(rnet_overpass), lwd = 2, col = rainbow(nrow(rnet_overpass)))
boundary_points &lt;- st_geometry(line2points(rnet_overpass))
points_cols &lt;- rep(rainbow(nrow(rnet_overpass)), each = 2)
plot(boundary_points, pch = 16, add = TRUE, col = points_cols, cex = 2)
# At the moment the network is not routable since one of the underpasses is
# not connected to the other streets.

# Check interactively.
# mapview::mapview(rnet_overpass)

# Clean the network. It should not create any spurious intersection between
# roads located at different heights.
rnet_overpass_clean &lt;- rnet_breakup_vertices(rnet_overpass)
plot(st_geometry(rnet_overpass_clean), lwd = 2, col = rainbow(nrow(rnet_overpass_clean)))
# Check interactively.
# mapview::mapview(rnet_overpass)

# Check the geometry of the cycleway_intersection example. The black dots
# represent the boundary points and we can see that the two roads are not
# connected according to SpatialLinesNetwork() function.
plot(
  rnet_cycleway_intersection$geometry,
  lwd = 2,
  col = rainbow(nrow(rnet_cycleway_intersection)),
  cex = 2
)
plot(st_geometry(line2points(rnet_cycleway_intersection)), pch = 16, add = TRUE)
# Check interactively
# mapview::mapview(rnet_overpass)

# Clean the rnet object and plot the result.
rnet_cycleway_intersection_clean &lt;- rnet_breakup_vertices(rnet_cycleway_intersection)
plot(
  rnet_cycleway_intersection_clean$geometry,
  lwd = 2,
  col = rainbow(nrow(rnet_cycleway_intersection_clean)),
  cex = 2
)
plot(st_geometry(line2points(rnet_cycleway_intersection_clean)), pch = 16, add = TRUE)

par(def_par)
</code></pre>

<hr>
<h2 id='rnet_connected'>Keep only segments connected to the largest group in a network</h2><span id='topic+rnet_connected'></span>

<h3>Description</h3>

<p>This function takes an sf object representing a road network and
returns only the parts of the network that are in the largest group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rnet_connected(rnet)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rnet_connected_+3A_rnet">rnet</code></td>
<td>
<p>An sf object representing a road network</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An sf object representing the largest group in the network
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rnet &lt;- rnet_breakup_vertices(stplanr::osm_net_example)
rnet_largest_group &lt;- rnet_connected(rnet)
plot(rnet$geometry)
plot(rnet_largest_group$geometry)
</code></pre>

<hr>
<h2 id='rnet_cycleway_intersection'>Example of cycleway intersection data showing problems for SpatialLinesNetwork objects</h2><span id='topic+rnet_cycleway_intersection'></span>

<h3>Description</h3>

<p>See <code>data-raw/rnet_cycleway_intersection</code> for details on how this was created.
</p>


<h3>Format</h3>

<p>A sf object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rnet_cycleway_intersection
</code></pre>

<hr>
<h2 id='rnet_get_nodes'>Extract nodes from route network</h2><span id='topic+rnet_get_nodes'></span>

<h3>Description</h3>

<p>Extract nodes from route network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rnet_get_nodes(rnet, p = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rnet_get_nodes_+3A_rnet">rnet</code></td>
<td>
<p>A route network of the type generated by <code>overline()</code></p>
</td></tr>
<tr><td><code id="rnet_get_nodes_+3A_p">p</code></td>
<td>
<p>A point represented by an <code>sf</code> object the will split the <code>route</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>rnet_get_nodes(route_network_sf)
</code></pre>

<hr>
<h2 id='rnet_group'>Assign segments in a route network to groups</h2><span id='topic+rnet_group'></span><span id='topic+rnet_group.default'></span><span id='topic+rnet_group.sfc'></span><span id='topic+rnet_group.sf'></span>

<h3>Description</h3>

<p>This function assigns linestring features, many of which in an
<code>sf</code> object can form route networks, into groups.
By default, the function <code>igraph::clusters()</code> is used to determine
group membership, but any <code style="white-space: pre;">&#8288;igraph::cluster*()&#8288;</code> function can be used.
See examples and the web page
<a href="https://igraph.org/r/doc/communities.html">igraph.org/r/doc/communities.html</a>
for more information. From that web page, the following clustering
functions are available:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rnet_group(rnet, ...)

## Default S3 method:
rnet_group(rnet, ...)

## S3 method for class 'sfc'
rnet_group(
  rnet,
  cluster_fun = igraph::clusters,
  d = NULL,
  as.undirected = TRUE,
  ...
)

## S3 method for class 'sf'
rnet_group(
  rnet,
  cluster_fun = igraph::clusters,
  d = NULL,
  as.undirected = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rnet_group_+3A_rnet">rnet</code></td>
<td>
<p>An sf, sfc, or sfNetwork object representing a route network.</p>
</td></tr>
<tr><td><code id="rnet_group_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods.</p>
</td></tr>
<tr><td><code id="rnet_group_+3A_cluster_fun">cluster_fun</code></td>
<td>
<p>The clustering function to use. Various clustering functions
are available in the <code>igraph</code> package. Default: <code><a href="igraph.html#topic+components">igraph::clusters()</a></code>.</p>
</td></tr>
<tr><td><code id="rnet_group_+3A_d">d</code></td>
<td>
<p>Optional distance variable used to classify segments that are
close (within a certain distance specified by <code>d</code>) to each other but not
necessarily touching</p>
</td></tr>
<tr><td><code id="rnet_group_+3A_as.undirected">as.undirected</code></td>
<td>
<p>Coerce the graph created internally into an undirected
graph with <code><a href="igraph.html#topic+as.directed">igraph::as.undirected()</a></code>? TRUE by default, which enables use
of a wider range of clutering functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code style="white-space: pre;">&#8288;cluster_edge_betweenness, cluster_fast_greedy, cluster_label_prop,&#8288;</code>
<code style="white-space: pre;">&#8288;cluster_leading_eigen, cluster_louvain, cluster_optimal, cluster_spinglass, cluster_walktrap&#8288;</code>
</p>


<h3>Value</h3>

<p>If the input rnet is an sf/sfc object, it returns an integer vector
reporting the groups of each network element. If the input is an sfNetwork
object, it returns an sfNetwork object with an extra column called
rnet_group representing the groups of each network element. In the latter
case, the connectivity of the spatial object is derived from the sfNetwork
object.
</p>


<h3>See Also</h3>

<p>Other rnet: 
<code><a href="#topic+gsection">gsection</a>()</code>,
<code><a href="#topic+islines">islines</a>()</code>,
<code><a href="#topic+overline">overline</a>()</code>,
<code><a href="#topic+rnet_breakup_vertices">rnet_breakup_vertices</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rnet &lt;- rnet_breakup_vertices(stplanr::osm_net_example)
rnet$group &lt;- rnet_group(rnet)
plot(rnet["group"])
# mapview::mapview(rnet["group"])
rnet$group_25m &lt;- rnet_group(rnet, d = 25)
plot(rnet["group_25m"])
rnet$group_walktrap &lt;- rnet_group(rnet, igraph::cluster_walktrap)
plot(rnet["group_walktrap"])
rnet$group_louvain &lt;- rnet_group(rnet, igraph::cluster_louvain)
plot(rnet["group_louvain"])
rnet$group_fast_greedy &lt;- rnet_group(rnet, igraph::cluster_fast_greedy)
plot(rnet["group_fast_greedy"])
</code></pre>

<hr>
<h2 id='rnet_join'>Join route networks</h2><span id='topic+rnet_join'></span>

<h3>Description</h3>

<p>This is a spatial join function that is enables adding columns to a
'target' route network from a 'source' route
network that contains the base geometry, e.g. from OSM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rnet_join(
  rnet_x,
  rnet_y,
  dist = 5,
  length_y = TRUE,
  key_column = 1,
  subset_x = TRUE,
  dist_subset = NULL,
  segment_length = 0,
  endCapStyle = "FLAT",
  contains = TRUE,
  max_angle_diff = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rnet_join_+3A_rnet_x">rnet_x</code></td>
<td>
<p>Target route network, the output will have the same geometries
as features in this object.</p>
</td></tr>
<tr><td><code id="rnet_join_+3A_rnet_y">rnet_y</code></td>
<td>
<p>Source route network. Columns from this route network object will
be copied across to the new network.</p>
</td></tr>
<tr><td><code id="rnet_join_+3A_dist">dist</code></td>
<td>
<p>The buffer width around rnet_y in meters. 1 m by default.</p>
</td></tr>
<tr><td><code id="rnet_join_+3A_length_y">length_y</code></td>
<td>
<p>Add a new column called <code>length_y</code>? Useful when joining based on
length of segments (e.g. weighted mean). <code>TRUE</code> by default.</p>
</td></tr>
<tr><td><code id="rnet_join_+3A_key_column">key_column</code></td>
<td>
<p>The index of the key (unique identifier) column in <code>rnet_x</code>.</p>
</td></tr>
<tr><td><code id="rnet_join_+3A_subset_x">subset_x</code></td>
<td>
<p>Subset the source route network by the target network before
creating buffers? This can lead to faster and better results. Default:
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="rnet_join_+3A_dist_subset">dist_subset</code></td>
<td>
<p>The buffer distance in m to apply when breaking up the
source object <code>rnet_y</code>. Default: 5.</p>
</td></tr>
<tr><td><code id="rnet_join_+3A_segment_length">segment_length</code></td>
<td>
<p>Should the source route network be split?
<code>0</code> by default, meaning no splitting. Values above 0 split the source
into linestrings with a max distance. Around 5 (m) may be a sensible
default for many use cases, the smaller the value the slower the process.</p>
</td></tr>
<tr><td><code id="rnet_join_+3A_endcapstyle">endCapStyle</code></td>
<td>
<p>Type of buffer. See <code>?sf::st_buffer</code> for details</p>
</td></tr>
<tr><td><code id="rnet_join_+3A_contains">contains</code></td>
<td>
<p>Should the join be based on <code>sf::st_contains</code> or <code>sf::st_intersects</code>?
<code>TRUE</code> by default. If <code>FALSE</code> the centroid of each segment of <code>rnet_y</code> is
used for the join. Note: this can result in incorrectly assigning values
on sideroads, as documented in <a href="https://github.com/ropensci/stplanr/issues/520">#520</a>.</p>
</td></tr>
<tr><td><code id="rnet_join_+3A_max_angle_diff">max_angle_diff</code></td>
<td>
<p>The maximum angle difference between x and y nets for a value
to be returned</p>
</td></tr>
<tr><td><code id="rnet_join_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>rnet_subset</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output is an sf object containing polygons representing
buffers around the route network in <code>rnet_x</code>.
The examples below demonstrate how to join attributes from
a route network object created with the function <code><a href="#topic+overline">overline()</a></code> onto
OSM geometries.
</p>
<p>Note: The main purpose of this function is to join an ID from <code>rnet_x</code>
onto <code>rnet_y</code>. Subsequent steps, e.g. with <code><a href="dplyr.html#topic+mutate-joins">dplyr::inner_join()</a></code>
are needed to join the attributes back onto <code>rnet_x</code>.
There are rarely 1-to-1 relationships between spatial network geometries
so we take care when using this function.
</p>
<p>See <a href="https://github.com/ropensci/stplanr/issues/505">#505</a> for details
and a link to an interactive example of inputs and outputs shown below.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
library(dplyr)
# Uncomment for interactive examples:
plot(st_geometry(route_network_small))
plot(osm_net_example$geometry, lwd = 5, col = "grey", add = TRUE)
plot(route_network_small["flow"], add = TRUE)
rnetj = rnet_join(osm_net_example, route_network_small, dist = 9)
rnetj2 = rnet_join(osm_net_example, route_network_small, dist = 9, segment_length = 10)
# library(mapview)
# mapview(rnetj, zcol = "flow") +
#   mapview(rnetj2, zcol = "flow") +
#   mapview(route_network_small, zcol = "flow")
plot(sf::st_geometry(rnetj))
plot(rnetj["flow"], add = TRUE)
plot(rnetj2["flow"], add = TRUE)
plot(route_network_small["flow"], add = TRUE)
summary(rnetj2$length_y)
rnetj_summary = rnetj2 %&gt;%
  filter(!is.na(length_y)) %&gt;%
  sf::st_drop_geometry() %&gt;%
  group_by(osm_id) %&gt;%
    summarise(
      flow = weighted.mean(flow, length_y, na.rm = TRUE),
      )
osm_joined_rnet = dplyr::left_join(osm_net_example, rnetj_summary)
plot(sf::st_geometry(route_network_small))
plot(route_network_small["flow"], lwd = 3, add = TRUE)
plot(sf::st_geometry(osm_joined_rnet), add = TRUE)
# plot(osm_joined_rnet[c("flow")], lwd = 9, add = TRUE)
# Improve fit between geometries and performance by subsetting rnet_x
osm_subset = rnet_subset(osm_net_example, route_network_small, dist = 5)
osm_joined_rnet = dplyr::left_join(osm_subset, rnetj_summary)
plot(route_network_small["flow"])
# plot(osm_joined_rnet[c("flow")])
# mapview(joined_network) +
#   mapview(route_network_small)
</code></pre>

<hr>
<h2 id='rnet_merge'>Merge route networks, keeping attributes with aggregating functions</h2><span id='topic+rnet_merge'></span>

<h3>Description</h3>

<p>Merge route networks, keeping attributes with aggregating functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rnet_merge(rnet_x, rnet_y, dist = 5, funs = NULL, sum_flows = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rnet_merge_+3A_rnet_x">rnet_x</code></td>
<td>
<p>Target route network, the output will have the same geometries
as features in this object.</p>
</td></tr>
<tr><td><code id="rnet_merge_+3A_rnet_y">rnet_y</code></td>
<td>
<p>Source route network. Columns from this route network object will
be copied across to the new network.</p>
</td></tr>
<tr><td><code id="rnet_merge_+3A_dist">dist</code></td>
<td>
<p>The buffer width around rnet_y in meters. 1 m by default.</p>
</td></tr>
<tr><td><code id="rnet_merge_+3A_funs">funs</code></td>
<td>
<p>A named list of functions to apply to named columns, e.g.:
<code>list(flow = sum, length = mean)</code>. The default is to sum all numeric
columns.</p>
</td></tr>
<tr><td><code id="rnet_merge_+3A_sum_flows">sum_flows</code></td>
<td>
<p>Should flows be summed? <code>TRUE</code> by default.</p>
</td></tr>
<tr><td><code id="rnet_merge_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>rnet_join</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An sf object with the same geometry as <code>rnet_x</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The source object:
rnet_y = route_network_small["flow"]
# The target object
rnet_x = rnet_subset(osm_net_example[1], rnet_y)
plot(rnet_x$geometry, lwd = 5)
plot(rnet_y$geometry, add = TRUE, col = "red", lwd = 2)
rnet_y$quietness = rnorm(nrow(rnet_y))
funs = list(flow = sum, quietness = mean)
rnet_merged = rnet_merge(rnet_x[1], rnet_y[c("flow", "quietness")],
                         dist = 9, segment_length = 20, funs = funs)
plot(rnet_y$geometry, lwd = 5, col = "lightgrey")
plot(rnet_merged["flow"], add = TRUE, lwd = 2)

# # Larger example
# system("gh release list")
# system("gh release upload v1.0.2 rnet_*")
# List the files released in v1.0.2:
# system("gh release download v1.0.2")
# rnet_x = sf::read_sf("rnet_x_ed.geojson")
# rnet_y = sf::read_sf("rnet_y_ed.geojson")
# rnet_merged = rnet_merge(rnet_x, rnet_y, dist = 9, segment_length = 20, funs = funs)
</code></pre>

<hr>
<h2 id='rnet_overpass'>Example of overpass data showing problems for SpatialLinesNetwork objects</h2><span id='topic+rnet_overpass'></span>

<h3>Description</h3>

<p>See <code>data-raw/rnet_overpass.R</code> for details on how this was created.
</p>


<h3>Format</h3>

<p>A sf object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rnet_overpass
</code></pre>

<hr>
<h2 id='rnet_roundabout'>Example of roundabout data showing problems for SpatialLinesNetwork objects</h2><span id='topic+rnet_roundabout'></span>

<h3>Description</h3>

<p>See <code>data-raw/rnet_roundabout.R</code> for details on how this was created.
</p>


<h3>Format</h3>

<p>A sf object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rnet_roundabout
</code></pre>

<hr>
<h2 id='rnet_subset'>Subset one route network based on overlaps with another</h2><span id='topic+rnet_subset'></span>

<h3>Description</h3>

<p>Subset one route network based on overlaps with another
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rnet_subset(
  rnet_x,
  rnet_y,
  dist = 10,
  crop = TRUE,
  min_length = 20,
  rm_disconnected = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rnet_subset_+3A_rnet_x">rnet_x</code></td>
<td>
<p>The route network to be subset</p>
</td></tr>
<tr><td><code id="rnet_subset_+3A_rnet_y">rnet_y</code></td>
<td>
<p>The subsetting route network</p>
</td></tr>
<tr><td><code id="rnet_subset_+3A_dist">dist</code></td>
<td>
<p>The buffer width around y in meters. 1 m by default.</p>
</td></tr>
<tr><td><code id="rnet_subset_+3A_crop">crop</code></td>
<td>
<p>Crop <code>rnet_x</code>? <code>TRUE</code> is the default</p>
</td></tr>
<tr><td><code id="rnet_subset_+3A_min_length">min_length</code></td>
<td>
<p>Segments shorter than this multiple of dist
<em>and</em> which were longer
before the cropping process will be removed. 3 by default.</p>
</td></tr>
<tr><td><code id="rnet_subset_+3A_rm_disconnected">rm_disconnected</code></td>
<td>
<p>Remove ways that are</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>rnet_x = osm_net_example[1]
rnet_y = route_network_small["flow"]
plot(rnet_x$geometry, lwd = 5)
plot(rnet_y$geometry, add = TRUE, col = "red", lwd = 3)
rnet_x_subset = rnet_subset(rnet_x, rnet_y)
plot(rnet_x_subset, add = TRUE, col = "blue")
</code></pre>

<hr>
<h2 id='route'>Plan routes on the transport network</h2><span id='topic+route'></span>

<h3>Description</h3>

<p>Takes origins and destinations, finds the optimal routes between them
and returns the result as a spatial (sf or sp) object.
The definition of optimal depends on the routing function used
</p>


<h3>Usage</h3>

<pre><code class='language-R'>route(
  from = NULL,
  to = NULL,
  l = NULL,
  route_fun = cyclestreets::journey,
  wait = 0,
  n_print = 10,
  list_output = FALSE,
  cl = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="route_+3A_from">from</code></td>
<td>
<p>An object representing origins
(if lines are provided as the first argument, from is assigned to <code>l</code>)</p>
</td></tr>
<tr><td><code id="route_+3A_to">to</code></td>
<td>
<p>An object representing destinations</p>
</td></tr>
<tr><td><code id="route_+3A_l">l</code></td>
<td>
<p>A spatial (linestring) object</p>
</td></tr>
<tr><td><code id="route_+3A_route_fun">route_fun</code></td>
<td>
<p>A routing function to be used for converting the lines to routes</p>
</td></tr>
<tr><td><code id="route_+3A_wait">wait</code></td>
<td>
<p>How long to wait between routes?
0 seconds by default, can be useful when sending requests to rate limited APIs.</p>
</td></tr>
<tr><td><code id="route_+3A_n_print">n_print</code></td>
<td>
<p>A number specifying how frequently progress updates
should be shown</p>
</td></tr>
<tr><td><code id="route_+3A_list_output">list_output</code></td>
<td>
<p>If FALSE (default) assumes spatial (linestring) object output.
Set to TRUE to save output as a list.</p>
</td></tr>
<tr><td><code id="route_+3A_cl">cl</code></td>
<td>
<p>Cluster</p>
</td></tr>
<tr><td><code id="route_+3A_...">...</code></td>
<td>
<p>Arguments passed to the routing function</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other routes: 
<code><a href="#topic+route_dodgr">route_dodgr</a>()</code>,
<code><a href="#topic+route_osrm">route_osrm</a>()</code>
</p>
<p>Other routes: 
<code><a href="#topic+route_dodgr">route_dodgr</a>()</code>,
<code><a href="#topic+route_osrm">route_osrm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Todo: add examples
</code></pre>

<hr>
<h2 id='route_average_gradient'>Return average gradient across a route</h2><span id='topic+route_average_gradient'></span>

<h3>Description</h3>

<p>This function assumes that elevations and distances are in the same units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>route_average_gradient(elevations, distances)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="route_average_gradient_+3A_elevations">elevations</code></td>
<td>
<p>Elevations, e.g. those provided by the <code>cyclestreets</code> package</p>
</td></tr>
<tr><td><code id="route_average_gradient_+3A_distances">distances</code></td>
<td>
<p>Distances, e.g. those provided by the <code>cyclestreets</code> package</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other route_funs: 
<code><a href="#topic+route_rolling_average">route_rolling_average</a>()</code>,
<code><a href="#topic+route_rolling_diff">route_rolling_diff</a>()</code>,
<code><a href="#topic+route_rolling_gradient">route_rolling_gradient</a>()</code>,
<code><a href="#topic+route_sequential_dist">route_sequential_dist</a>()</code>,
<code><a href="#topic+route_slope_matrix">route_slope_matrix</a>()</code>,
<code><a href="#topic+route_slope_vector">route_slope_vector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r1 &lt;- od_data_routes[od_data_routes$route_number == 2, ]
elevations &lt;- r1$elevations
distances &lt;- r1$distances
route_average_gradient(elevations, distances) # an average of a 4% gradient
</code></pre>

<hr>
<h2 id='route_bikecitizens'>Get a route from the BikeCitizens web service</h2><span id='topic+route_bikecitizens'></span>

<h3>Description</h3>

<p>See <a href="https://map.bikecitizens.net/gb-leeds#/!/1/1/53.8265,-1.576195/53.80025,-1.51577">bikecitizens.net</a>
for an interactive version of the routing engine used by BikeCitizens.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>route_bikecitizens(
  from = NULL,
  to = NULL,
  base_url = "https://map.bikecitizens.net/api/v1/locations/route.json",
  cccode = "gb-leeds",
  routing_profile = "balanced",
  bike_profile = "citybike",
  from_lat = 53.8265,
  from_lon = -1.576195,
  to_lat = 53.80025,
  to_lon = -1.51577
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="route_bikecitizens_+3A_from">from</code></td>
<td>
<p>A numeric vector representing the start point</p>
</td></tr>
<tr><td><code id="route_bikecitizens_+3A_to">to</code></td>
<td>
<p>A numeric vector representing the end point</p>
</td></tr>
<tr><td><code id="route_bikecitizens_+3A_base_url">base_url</code></td>
<td>
<p>The base URL for the routes</p>
</td></tr>
<tr><td><code id="route_bikecitizens_+3A_cccode">cccode</code></td>
<td>
<p>The city code for the routes</p>
</td></tr>
<tr><td><code id="route_bikecitizens_+3A_routing_profile">routing_profile</code></td>
<td>
<p>What type of routing to use?</p>
</td></tr>
<tr><td><code id="route_bikecitizens_+3A_bike_profile">bike_profile</code></td>
<td>
<p>What type of bike?</p>
</td></tr>
<tr><td><code id="route_bikecitizens_+3A_from_lat">from_lat</code></td>
<td>
<p>Latitude of origin</p>
</td></tr>
<tr><td><code id="route_bikecitizens_+3A_from_lon">from_lon</code></td>
<td>
<p>Longitude of origin</p>
</td></tr>
<tr><td><code id="route_bikecitizens_+3A_to_lat">to_lat</code></td>
<td>
<p>Latitude of destination</p>
</td></tr>
<tr><td><code id="route_bikecitizens_+3A_to_lon">to_lon</code></td>
<td>
<p>Longitude of destination</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the bikecitizens.R file in the data-raw directory of the package's
development repository for details on usage and examples.
</p>

<hr>
<h2 id='route_dodgr'>Route on local data using the dodgr package</h2><span id='topic+route_dodgr'></span>

<h3>Description</h3>

<p>Route on local data using the dodgr package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>route_dodgr(from = NULL, to = NULL, l = NULL, net = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="route_dodgr_+3A_from">from</code></td>
<td>
<p>An object representing origins
(if lines are provided as the first argument, from is assigned to <code>l</code>)</p>
</td></tr>
<tr><td><code id="route_dodgr_+3A_to">to</code></td>
<td>
<p>An object representing destinations</p>
</td></tr>
<tr><td><code id="route_dodgr_+3A_l">l</code></td>
<td>
<p>A spatial (linestring) object</p>
</td></tr>
<tr><td><code id="route_dodgr_+3A_net">net</code></td>
<td>
<p>sf object representing the route network</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other routes: 
<code><a href="#topic+route_osrm">route_osrm</a>()</code>,
<code><a href="#topic+route">route</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("dodgr")) {
  from &lt;- c(-1.5327, 53.8006) # from &lt;- geo_code("pedallers arms leeds")
  to &lt;- c(-1.5279, 53.8044) # to &lt;- geo_code("gzing")
  # next 4 lines were used to generate `stplanr::osm_net_example`
  # pts &lt;- rbind(from, to)
  # colnames(pts) &lt;- c("X", "Y")
  # net &lt;- dodgr::dodgr_streetnet(pts = pts, expand = 0.1)
  # osm_net_example &lt;- net[c("highway", "name", "lanes", "maxspeed")]
  r &lt;- route_dodgr(from, to, net = osm_net_example)
  plot(osm_net_example$geometry)
  plot(r$geometry, add = TRUE, col = "red", lwd = 5)
}
</code></pre>

<hr>
<h2 id='route_google'>Find shortest path using Google services</h2><span id='topic+route_google'></span>

<h3>Description</h3>

<p>Find the shortest path using Google's services.
See the <code>mapsapi</code> package for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>route_google(from, to, mode = "walking", key = Sys.getenv("GOOGLE"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="route_google_+3A_from">from</code></td>
<td>
<p>An object representing origins
(if lines are provided as the first argument, from is assigned to <code>l</code>)</p>
</td></tr>
<tr><td><code id="route_google_+3A_to">to</code></td>
<td>
<p>An object representing destinations</p>
</td></tr>
<tr><td><code id="route_google_+3A_mode">mode</code></td>
<td>
<p>Mode of transport, walking (default), bicycling, transit, or driving</p>
</td></tr>
<tr><td><code id="route_google_+3A_key">key</code></td>
<td>
<p>Google key. By default it is <code>Sys.getenv("GOOGLE")</code>. Set it with:
<code>usethis::edit_r_environ()</code>.</p>
</td></tr>
<tr><td><code id="route_google_+3A_...">...</code></td>
<td>
<p>Arguments passed to the routing function</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
from &lt;- "university of leeds"
to &lt;- "pedallers arms leeds"
r &lt;- route(from, to, route_fun = cyclestreets::journey)
plot(r)
# r_google &lt;- route(from, to, route_fun = mapsapi::mp_directions) # fails
r_google1 &lt;- route_google(from, to)
plot(r_google1)
r_google &lt;- route(from, to, route_fun = route_google)

## End(Not run)
</code></pre>

<hr>
<h2 id='route_nearest_point'>Find nearest route to a given point</h2><span id='topic+route_nearest_point'></span>

<h3>Description</h3>

<p>This function was written as a drop-in replacement for <code>sf::st_nearest_feature()</code>,
which only works with recent versions of GEOS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>route_nearest_point(r, p, id_out = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="route_nearest_point_+3A_r">r</code></td>
<td>
<p>The input route object from which the nearest route is to be found</p>
</td></tr>
<tr><td><code id="route_nearest_point_+3A_p">p</code></td>
<td>
<p>The point whose nearest route will be found</p>
</td></tr>
<tr><td><code id="route_nearest_point_+3A_id_out">id_out</code></td>
<td>
<p>Should the index of the matching feature be returned? <code>FALSE</code> by default</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- routes_fast_sf[2:6, NULL]
p &lt;- sf::st_sfc(sf::st_point(c(-1.540, 53.826)), crs = sf::st_crs(r))
route_nearest_point(r, p, id_out = TRUE)
r_nearest &lt;- route_nearest_point(r, p)
plot(r$geometry)
plot(p, add = TRUE)
plot(r_nearest, lwd = 5, add = TRUE)
</code></pre>

<hr>
<h2 id='route_network_sf'>Spatial lines dataset representing a route network</h2><span id='topic+route_network_sf'></span>

<h3>Description</h3>

<p>The flow of commuters using different segments of the road network represented in the
<code><a href="#topic+flowlines_sf">flowlines_sf()</a></code> and <code><a href="#topic+routes_fast_sf">routes_fast_sf()</a></code> datasets
</p>


<h3>Format</h3>

<p>A spatial lines dataset 80 rows and 1 column
</p>


<h3>See Also</h3>

<p>Other data: 
<code><a href="#topic+cents_sf">cents_sf</a></code>,
<code><a href="#topic+destinations_sf">destinations_sf</a></code>,
<code><a href="#topic+flow_dests">flow_dests</a></code>,
<code><a href="#topic+flowlines_sf">flowlines_sf</a></code>,
<code><a href="#topic+flow">flow</a></code>,
<code><a href="#topic+od_data_lines">od_data_lines</a></code>,
<code><a href="#topic+od_data_routes">od_data_routes</a></code>,
<code><a href="#topic+od_data_sample">od_data_sample</a></code>,
<code><a href="#topic+osm_net_example">osm_net_example</a></code>,
<code><a href="#topic+read_table_builder">read_table_builder</a>()</code>,
<code><a href="#topic+route_network_small">route_network_small</a></code>,
<code><a href="#topic+routes_fast_sf">routes_fast_sf</a></code>,
<code><a href="#topic+routes_slow_sf">routes_slow_sf</a></code>,
<code><a href="#topic+zones_sf">zones_sf</a></code>
</p>

<hr>
<h2 id='route_network_small'>Spatial lines dataset representing a small route network</h2><span id='topic+route_network_small'></span>

<h3>Description</h3>

<p>The flow between randomly selected vertices on the <code>osm_net_example</code>.
See <code>data-raw/route_network_small.R</code> for details.
</p>


<h3>Format</h3>

<p>A spatial lines dataset with one column: flow
</p>


<h3>See Also</h3>

<p>Other data: 
<code><a href="#topic+cents_sf">cents_sf</a></code>,
<code><a href="#topic+destinations_sf">destinations_sf</a></code>,
<code><a href="#topic+flow_dests">flow_dests</a></code>,
<code><a href="#topic+flowlines_sf">flowlines_sf</a></code>,
<code><a href="#topic+flow">flow</a></code>,
<code><a href="#topic+od_data_lines">od_data_lines</a></code>,
<code><a href="#topic+od_data_routes">od_data_routes</a></code>,
<code><a href="#topic+od_data_sample">od_data_sample</a></code>,
<code><a href="#topic+osm_net_example">osm_net_example</a></code>,
<code><a href="#topic+read_table_builder">read_table_builder</a>()</code>,
<code><a href="#topic+route_network_sf">route_network_sf</a></code>,
<code><a href="#topic+routes_fast_sf">routes_fast_sf</a></code>,
<code><a href="#topic+routes_slow_sf">routes_slow_sf</a></code>,
<code><a href="#topic+zones_sf">zones_sf</a></code>
</p>

<hr>
<h2 id='route_osrm'>Plan routes on the transport network using the OSRM server</h2><span id='topic+route_osrm'></span>

<h3>Description</h3>

<p>This function is a simplified and (because it uses GeoJSON not binary polyline format)
slower R interface to OSRM routing services compared with the excellent
<code><a href="osrm.html#topic+osrmRoute">osrm::osrmRoute()</a></code> function (which can be used via the <code><a href="#topic+route">route()</a></code>) function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>route_osrm(
  from,
  to,
  osrm.server = "https://routing.openstreetmap.de/",
  osrm.profile = "foot"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="route_osrm_+3A_from">from</code></td>
<td>
<p>An object representing origins
(if lines are provided as the first argument, from is assigned to <code>l</code>)</p>
</td></tr>
<tr><td><code id="route_osrm_+3A_to">to</code></td>
<td>
<p>An object representing destinations</p>
</td></tr>
<tr><td><code id="route_osrm_+3A_osrm.server">osrm.server</code></td>
<td>
<p>The base URL of the routing server.
getOption(&quot;osrm.server&quot;) by default.</p>
</td></tr>
<tr><td><code id="route_osrm_+3A_osrm.profile">osrm.profile</code></td>
<td>
<p>The routing profile to use, e.g. &quot;car&quot;, &quot;bike&quot; or &quot;foot&quot;
(when using the routing.openstreetmap.de test server).
getOption(&quot;osrm.profile&quot;) by default.</p>
</td></tr>
<tr><td><code id="route_osrm_+3A_profile">profile</code></td>
<td>
<p>Which routing profile to use? One of &quot;foot&quot; (default)
&quot;bike&quot; or &quot;car&quot; for the default open server.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other routes: 
<code><a href="#topic+route_dodgr">route_dodgr</a>()</code>,
<code><a href="#topic+route">route</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Examples no longer working due to API being down
# l1 = od_data_lines[49, ]
# l1m = od_coords(l1)
# from = l1m[, 1:2]
# to = l1m[, 3:4]
# if(curl::has_internet()) {
# r_foot = route_osrm(from, to)
# r_bike = route_osrm(from, to, osrm.profile = "bike")
# r_car = route_osrm(from, to, osrm.profile = "car")
# plot(r_foot$geometry, lwd = 9, col = "grey")
# plot(r_bike, col = "blue", add = TRUE)
# plot(r_car, col = "red", add = TRUE)
# }

</code></pre>

<hr>
<h2 id='route_rolling_average'>Return smoothed averages of vector</h2><span id='topic+route_rolling_average'></span>

<h3>Description</h3>

<p>This function calculates a simple rolling mean in base R.
It is useful for calculating route characteristics such as mean
distances of segments and changes in gradient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>route_rolling_average(x, n = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="route_rolling_average_+3A_x">x</code></td>
<td>
<p>Numeric vector to smooth</p>
</td></tr>
<tr><td><code id="route_rolling_average_+3A_n">n</code></td>
<td>
<p>The window size of the smoothing function.
The default, 3, will take the mean of values before, after and including
each value.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other route_funs: 
<code><a href="#topic+route_average_gradient">route_average_gradient</a>()</code>,
<code><a href="#topic+route_rolling_diff">route_rolling_diff</a>()</code>,
<code><a href="#topic+route_rolling_gradient">route_rolling_gradient</a>()</code>,
<code><a href="#topic+route_sequential_dist">route_sequential_dist</a>()</code>,
<code><a href="#topic+route_slope_matrix">route_slope_matrix</a>()</code>,
<code><a href="#topic+route_slope_vector">route_slope_vector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- od_data_routes$elevations[od_data_routes$route_number == 2]
y
route_rolling_average(y)
route_rolling_average(y, n = 1)
route_rolling_average(y, n = 2)
route_rolling_average(y, n = 3)
</code></pre>

<hr>
<h2 id='route_rolling_diff'>Return smoothed differences between vector values</h2><span id='topic+route_rolling_diff'></span>

<h3>Description</h3>

<p>This function calculates a simple rolling mean in base R. It is useful for
calculating route characteristics such as mean distances of segments and
changes in gradient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>route_rolling_diff(x, lag = 1, abs = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="route_rolling_diff_+3A_x">x</code></td>
<td>
<p>Numeric vector to smooth</p>
</td></tr>
<tr><td><code id="route_rolling_diff_+3A_lag">lag</code></td>
<td>
<p>The window size of the smoothing function. The default, 3, will take
the mean of values before, after and including each value.</p>
</td></tr>
<tr><td><code id="route_rolling_diff_+3A_abs">abs</code></td>
<td>
<p>Should the absolute (always positive) change be returned? True by default</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other route_funs: 
<code><a href="#topic+route_average_gradient">route_average_gradient</a>()</code>,
<code><a href="#topic+route_rolling_average">route_rolling_average</a>()</code>,
<code><a href="#topic+route_rolling_gradient">route_rolling_gradient</a>()</code>,
<code><a href="#topic+route_sequential_dist">route_sequential_dist</a>()</code>,
<code><a href="#topic+route_slope_matrix">route_slope_matrix</a>()</code>,
<code><a href="#topic+route_slope_vector">route_slope_vector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r1 &lt;- od_data_routes[od_data_routes$route_number == 2, ]
y &lt;- r1$elevations
route_rolling_diff(y, lag = 1)
route_rolling_diff(y, lag = 2)
r1$elevations_diff_1 &lt;- route_rolling_diff(y, lag = 1)
r1$elevations_diff_n &lt;- route_rolling_diff(y, lag = 1, abs = FALSE)
d &lt;- cumsum(r1$distances) - r1$distances / 2
diff_above_mean &lt;- r1$elevations_diff_1 + mean(y)
diff_above_mean_n &lt;- r1$elevations_diff_n + mean(y)
plot(c(0, cumsum(r1$distances)), c(y, y[length(y)]), ylim = c(80, 130))
lines(c(0, cumsum(r1$distances)), c(y, y[length(y)]))
points(d, diff_above_mean)
points(d, diff_above_mean_n, col = "blue")
abline(h = mean(y))
</code></pre>

<hr>
<h2 id='route_rolling_gradient'>Calculate rolling average gradient from elevation data at segment level</h2><span id='topic+route_rolling_gradient'></span>

<h3>Description</h3>

<p>Calculate rolling average gradient from elevation data at segment level
</p>


<h3>Usage</h3>

<pre><code class='language-R'>route_rolling_gradient(elevations, distances, lag = 1, n = 2, abs = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="route_rolling_gradient_+3A_elevations">elevations</code></td>
<td>
<p>Elevations, e.g. those provided by the <code>cyclestreets</code> package</p>
</td></tr>
<tr><td><code id="route_rolling_gradient_+3A_distances">distances</code></td>
<td>
<p>Distances, e.g. those provided by the <code>cyclestreets</code> package</p>
</td></tr>
<tr><td><code id="route_rolling_gradient_+3A_lag">lag</code></td>
<td>
<p>The window size of the smoothing function. The default, 3, will take
the mean of values before, after and including each value.</p>
</td></tr>
<tr><td><code id="route_rolling_gradient_+3A_n">n</code></td>
<td>
<p>The window size of the smoothing function.
The default, 3, will take the mean of values before, after and including
each value.</p>
</td></tr>
<tr><td><code id="route_rolling_gradient_+3A_abs">abs</code></td>
<td>
<p>Should the absolute (always positive) change be returned? True by default</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other route_funs: 
<code><a href="#topic+route_average_gradient">route_average_gradient</a>()</code>,
<code><a href="#topic+route_rolling_average">route_rolling_average</a>()</code>,
<code><a href="#topic+route_rolling_diff">route_rolling_diff</a>()</code>,
<code><a href="#topic+route_sequential_dist">route_sequential_dist</a>()</code>,
<code><a href="#topic+route_slope_matrix">route_slope_matrix</a>()</code>,
<code><a href="#topic+route_slope_vector">route_slope_vector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r1 &lt;- od_data_routes[od_data_routes$route_number == 2, ]
y &lt;- r1$elevations
distances &lt;- r1$distances
route_rolling_gradient(y, distances)
route_rolling_gradient(y, distances, abs = FALSE)
route_rolling_gradient(y, distances, n = 3)
route_rolling_gradient(y, distances, n = 4)
r1$elevations_diff_1 &lt;- route_rolling_diff(y, lag = 1)
r1$rolling_gradient &lt;- route_rolling_gradient(y, distances, n = 2)
r1$rolling_gradient3 &lt;- route_rolling_gradient(y, distances, n = 3)
r1$rolling_gradient4 &lt;- route_rolling_gradient(y, distances, n = 4)
d &lt;- cumsum(r1$distances) - r1$distances / 2
diff_above_mean &lt;- r1$elevations_diff_1 + mean(y)
par(mfrow = c(2, 1))
plot(c(0, cumsum(r1$distances)), c(y, y[length(y)]), ylim = c(80, 130))
lines(c(0, cumsum(r1$distances)), c(y, y[length(y)]))
points(d, diff_above_mean)
abline(h = mean(y))
rg &lt;- r1$rolling_gradient
rg[is.na(rg)] &lt;- 0
plot(c(0, d), c(0, rg), ylim = c(0, 0.2))
points(c(0, d), c(0, r1$rolling_gradient3), col = "blue")
points(c(0, d), c(0, r1$rolling_gradient4), col = "grey")
par(mfrow = c(1, 1))
</code></pre>

<hr>
<h2 id='route_sequential_dist'>Calculate the sequential distances between sequential coordinate pairs</h2><span id='topic+route_sequential_dist'></span>

<h3>Description</h3>

<p>Calculate the sequential distances between sequential coordinate pairs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>route_sequential_dist(m, lonlat = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="route_sequential_dist_+3A_m">m</code></td>
<td>
<p>Matrix containing coordinates and elevations</p>
</td></tr>
<tr><td><code id="route_sequential_dist_+3A_lonlat">lonlat</code></td>
<td>
<p>Are the coordinates in lon/lat order? <code>TRUE</code> by default</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other route_funs: 
<code><a href="#topic+route_average_gradient">route_average_gradient</a>()</code>,
<code><a href="#topic+route_rolling_average">route_rolling_average</a>()</code>,
<code><a href="#topic+route_rolling_diff">route_rolling_diff</a>()</code>,
<code><a href="#topic+route_rolling_gradient">route_rolling_gradient</a>()</code>,
<code><a href="#topic+route_slope_matrix">route_slope_matrix</a>()</code>,
<code><a href="#topic+route_slope_vector">route_slope_vector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(0, 2, 3, 4, 5, 9)
y &lt;- c(0, 0, 0, 0, 0, 1)
m &lt;- cbind(x, y)
route_sequential_dist(m)
</code></pre>

<hr>
<h2 id='route_slope_matrix'>Calculate the gradient of line segments from a matrix of coordinates</h2><span id='topic+route_slope_matrix'></span>

<h3>Description</h3>

<p>Calculate the gradient of line segments from a matrix of coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>route_slope_matrix(m, e = m[, 3], lonlat = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="route_slope_matrix_+3A_m">m</code></td>
<td>
<p>Matrix containing coordinates and elevations</p>
</td></tr>
<tr><td><code id="route_slope_matrix_+3A_e">e</code></td>
<td>
<p>Elevations in same units as x (assumed to be metres)</p>
</td></tr>
<tr><td><code id="route_slope_matrix_+3A_lonlat">lonlat</code></td>
<td>
<p>Are the coordinates in lon/lat order? <code>TRUE</code> by default</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other route_funs: 
<code><a href="#topic+route_average_gradient">route_average_gradient</a>()</code>,
<code><a href="#topic+route_rolling_average">route_rolling_average</a>()</code>,
<code><a href="#topic+route_rolling_diff">route_rolling_diff</a>()</code>,
<code><a href="#topic+route_rolling_gradient">route_rolling_gradient</a>()</code>,
<code><a href="#topic+route_sequential_dist">route_sequential_dist</a>()</code>,
<code><a href="#topic+route_slope_vector">route_slope_vector</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(0, 2, 3, 4, 5, 9)
y &lt;- c(0, 0, 0, 0, 0, 9)
z &lt;- c(1, 2, 2, 4, 3, 1) / 10
m &lt;- cbind(x, y, z)
plot(x, z, ylim = c(-0.5, 0.5), type = "l")
(gx &lt;- route_slope_vector(x, z))
(gxy &lt;- route_slope_matrix(m, lonlat = FALSE))
abline(h = 0, lty = 2)
points(x[-length(x)], gx, col = "red")
points(x[-length(x)], gxy, col = "blue")
title("Distance (in x coordinates) elevation profile",
  sub = "Points show calculated gradients of subsequent lines"
)
</code></pre>

<hr>
<h2 id='route_slope_vector'>Calculate the gradient of line segments from distance and elevation vectors</h2><span id='topic+route_slope_vector'></span>

<h3>Description</h3>

<p>Calculate the gradient of line segments from distance and elevation vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>route_slope_vector(x, e)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="route_slope_vector_+3A_x">x</code></td>
<td>
<p>Vector of locations</p>
</td></tr>
<tr><td><code id="route_slope_vector_+3A_e">e</code></td>
<td>
<p>Elevations in same units as x (assumed to be metres)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other route_funs: 
<code><a href="#topic+route_average_gradient">route_average_gradient</a>()</code>,
<code><a href="#topic+route_rolling_average">route_rolling_average</a>()</code>,
<code><a href="#topic+route_rolling_diff">route_rolling_diff</a>()</code>,
<code><a href="#topic+route_rolling_gradient">route_rolling_gradient</a>()</code>,
<code><a href="#topic+route_sequential_dist">route_sequential_dist</a>()</code>,
<code><a href="#topic+route_slope_matrix">route_slope_matrix</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(0, 2, 3, 4, 5, 9)
e &lt;- c(1, 2, 2, 4, 3, 1) / 10
route_slope_vector(x, e)
</code></pre>

<hr>
<h2 id='route_split'>Split route in two at point on or near network</h2><span id='topic+route_split'></span>

<h3>Description</h3>

<p>Split route in two at point on or near network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>route_split(r, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="route_split_+3A_r">r</code></td>
<td>
<p>An <code>sf</code> object with one feature containing a linestring geometry to be split</p>
</td></tr>
<tr><td><code id="route_split_+3A_p">p</code></td>
<td>
<p>A point represented by an <code>sf</code> object the will split the <code>route</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An sf object with 2 feature
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sample_routes &lt;- routes_fast_sf[2:6, NULL]
r &lt;- sample_routes[2, ]
p &lt;- sf::st_sfc(sf::st_point(c(-1.540, 53.826)), crs = sf::st_crs(r))
plot(r$geometry, lwd = 9, col = "grey")
plot(p, add = TRUE)
r_split &lt;- route_split(r, p)
plot(r_split, col = c("red", "blue"), add = TRUE)
</code></pre>

<hr>
<h2 id='route_split_id'>Split route based on the id or coordinates of one of its vertices</h2><span id='topic+route_split_id'></span>

<h3>Description</h3>

<p>Split route based on the id or coordinates of one of its vertices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>route_split_id(r, id = NULL, p = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="route_split_id_+3A_r">r</code></td>
<td>
<p>An <code>sf</code> object with one feature containing a linestring geometry to be split</p>
</td></tr>
<tr><td><code id="route_split_id_+3A_id">id</code></td>
<td>
<p>The index of the point on the number to be split</p>
</td></tr>
<tr><td><code id="route_split_id_+3A_p">p</code></td>
<td>
<p>A point represented by an <code>sf</code> object the will split the <code>route</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>sample_routes &lt;- routes_fast_sf[2:6, 3]
r &lt;- sample_routes[2, ]
id &lt;- round(n_vertices(r) / 2)
r_split &lt;- route_split_id(r, id = id)
plot(r$geometry, lwd = 9, col = "grey")
plot(r_split, col = c("red", "blue"), add = TRUE)
</code></pre>

<hr>
<h2 id='routes_fast_sf'>Spatial lines dataset of commuter flows on the travel network</h2><span id='topic+routes_fast_sf'></span>

<h3>Description</h3>

<p>Simulated travel route allocated to the transport network
representing the 'fastest' between <code>cents_sf</code>
objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>routes_fast_sf
</code></pre>


<h3>Format</h3>

<p>A spatial lines dataset with 49 rows and 15 columns
</p>


<h3>See Also</h3>

<p>Other data: 
<code><a href="#topic+cents_sf">cents_sf</a></code>,
<code><a href="#topic+destinations_sf">destinations_sf</a></code>,
<code><a href="#topic+flow_dests">flow_dests</a></code>,
<code><a href="#topic+flowlines_sf">flowlines_sf</a></code>,
<code><a href="#topic+flow">flow</a></code>,
<code><a href="#topic+od_data_lines">od_data_lines</a></code>,
<code><a href="#topic+od_data_routes">od_data_routes</a></code>,
<code><a href="#topic+od_data_sample">od_data_sample</a></code>,
<code><a href="#topic+osm_net_example">osm_net_example</a></code>,
<code><a href="#topic+read_table_builder">read_table_builder</a>()</code>,
<code><a href="#topic+route_network_sf">route_network_sf</a></code>,
<code><a href="#topic+route_network_small">route_network_small</a></code>,
<code><a href="#topic+routes_slow_sf">routes_slow_sf</a></code>,
<code><a href="#topic+zones_sf">zones_sf</a></code>
</p>

<hr>
<h2 id='routes_slow_sf'>Spatial lines dataset of commuter flows on the travel network</h2><span id='topic+routes_slow_sf'></span>

<h3>Description</h3>

<p>Simulated travel route allocated to the transport network
representing the 'quietest' between <code>cents_sf</code>.
</p>


<h3>Format</h3>

<p>A spatial lines dataset 49 rows and 15 columns
</p>


<h3>See Also</h3>

<p>Other data: 
<code><a href="#topic+cents_sf">cents_sf</a></code>,
<code><a href="#topic+destinations_sf">destinations_sf</a></code>,
<code><a href="#topic+flow_dests">flow_dests</a></code>,
<code><a href="#topic+flowlines_sf">flowlines_sf</a></code>,
<code><a href="#topic+flow">flow</a></code>,
<code><a href="#topic+od_data_lines">od_data_lines</a></code>,
<code><a href="#topic+od_data_routes">od_data_routes</a></code>,
<code><a href="#topic+od_data_sample">od_data_sample</a></code>,
<code><a href="#topic+osm_net_example">osm_net_example</a></code>,
<code><a href="#topic+read_table_builder">read_table_builder</a>()</code>,
<code><a href="#topic+route_network_sf">route_network_sf</a></code>,
<code><a href="#topic+route_network_small">route_network_small</a></code>,
<code><a href="#topic+routes_fast_sf">routes_fast_sf</a></code>,
<code><a href="#topic+zones_sf">zones_sf</a></code>
</p>

<hr>
<h2 id='stplanr-deprecated'>Deprecated functions in stplanr</h2><span id='topic+stplanr-deprecated'></span>

<h3>Description</h3>

<p>These functions are depreciated and will be removed:
</p>

<hr>
<h2 id='toptail_buff'>Clip the beginning and ends of <code>sf</code> LINESTRING objects</h2><span id='topic+toptail_buff'></span>

<h3>Description</h3>

<p>Takes lines and removes the start and end point, to a distance determined
by the nearest <code>buff</code> polygon border.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toptail_buff(l, buff, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toptail_buff_+3A_l">l</code></td>
<td>
<p>An <code>sf</code> object representing lines</p>
</td></tr>
<tr><td><code id="toptail_buff_+3A_buff">buff</code></td>
<td>
<p>An <code>sf</code> object with POLYGON geometry to buffer the linestring.</p>
</td></tr>
<tr><td><code id="toptail_buff_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>sf::st_buffer()</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other lines: 
<code><a href="#topic+angle_diff">angle_diff</a>()</code>,
<code><a href="#topic+geo_toptail">geo_toptail</a>()</code>,
<code><a href="#topic+is_linepoint">is_linepoint</a>()</code>,
<code><a href="#topic+line2df">line2df</a>()</code>,
<code><a href="#topic+line2points">line2points</a>()</code>,
<code><a href="#topic+line_bearing">line_bearing</a>()</code>,
<code><a href="#topic+line_breakup">line_breakup</a>()</code>,
<code><a href="#topic+line_midpoint">line_midpoint</a>()</code>,
<code><a href="#topic+line_segment">line_segment</a>()</code>,
<code><a href="#topic+line_via">line_via</a>()</code>,
<code><a href="#topic+mats2line">mats2line</a>()</code>,
<code><a href="#topic+n_vertices">n_vertices</a>()</code>,
<code><a href="#topic+onewaygeo">onewaygeo</a>()</code>,
<code><a href="#topic+points2line">points2line</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>l &lt;- routes_fast_sf
buff &lt;- zones_sf
r_toptail &lt;- toptail_buff(l, buff)
nrow(l)
nrow(r_toptail)
plot(zones_sf$geometry)
plot(l$geometry, add = TRUE)
plot(r_toptail$geometry, lwd = 5, add = TRUE)
</code></pre>

<hr>
<h2 id='zones_sf'>Spatial polygons of home locations for flow analysis.</h2><span id='topic+zones_sf'></span>

<h3>Description</h3>

<p>These correspond to the <code>cents_sf</code> data.
</p>


<h3>Details</h3>


<ul>
<li><p> geo_code. the official code of the zone
</p>
</li></ul>



<h3>See Also</h3>

<p>Other data: 
<code><a href="#topic+cents_sf">cents_sf</a></code>,
<code><a href="#topic+destinations_sf">destinations_sf</a></code>,
<code><a href="#topic+flow_dests">flow_dests</a></code>,
<code><a href="#topic+flowlines_sf">flowlines_sf</a></code>,
<code><a href="#topic+flow">flow</a></code>,
<code><a href="#topic+od_data_lines">od_data_lines</a></code>,
<code><a href="#topic+od_data_routes">od_data_routes</a></code>,
<code><a href="#topic+od_data_sample">od_data_sample</a></code>,
<code><a href="#topic+osm_net_example">osm_net_example</a></code>,
<code><a href="#topic+read_table_builder">read_table_builder</a>()</code>,
<code><a href="#topic+route_network_sf">route_network_sf</a></code>,
<code><a href="#topic+route_network_small">route_network_small</a></code>,
<code><a href="#topic+routes_fast_sf">routes_fast_sf</a></code>,
<code><a href="#topic+routes_slow_sf">routes_slow_sf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
zones_sf
plot(zones_sf)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
