<!DOCTYPE html><html><head><title>Help for package ppseq</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ppseq}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#calc_decision_rules'><p>Calculate a decision rule table for interim monitoring of a pre-specified</p>
design</a></li>
<li><a href='#calc_next'><p>Calculate response probability for the next patient</p></a></li>
<li><a href='#calc_posterior'><p>Calculate a single posterior probability</p></a></li>
<li><a href='#calc_predictive'><p>Calculate a single posterior predictive probability</p></a></li>
<li><a href='#calibrate_posterior_threshold'><p>Calibrate the posterior probability threshold</p></a></li>
<li><a href='#calibrate_thresholds'><p>Calibrate according to posterior probability threshold and predictive</p>
probability threshold with interim futility monitoring</a></li>
<li><a href='#eval_thresh'><p>Evaluate a single dataset for a single pp_threshold and ppp_threshold</p>
combination</a></li>
<li><a href='#one_sample_cal_tbl'><p>Output from a one-sample call to <code>calibrate_thresholds</code></p></a></li>
<li><a href='#one_sample_decision_tbl'><p>Output from a one-sample call to <code>calc_decision_rules</code></p></a></li>
<li><a href='#optimize_design'><p>Function to setup usage of <code>optimize_design.calibrate_thresholds</code></p></a></li>
<li><a href='#optimize_design.calibrate_thresholds'><p>Custom optimization method for <code>calibrate_thresholds</code> objects</p></a></li>
<li><a href='#plot.calc_decision_rules'><p>Plot method for <code>calc_decision_rules</code> objects</p></a></li>
<li><a href='#plot.calibrate_thresholds'><p>Plot method for <code>calibrate_thresholds</code> objects</p></a></li>
<li><a href='#ppseq-package'><p>ppseq: Design Clinical Trials using Sequential Predictive Probability Monitoring</p></a></li>
<li><a href='#print.calibrate_thresholds'><p>Print method for <code>calibrate_thresholds</code> objects</p></a></li>
<li><a href='#sim_dat1'><p>Simulate a single dataset based on the response probability(ies), the total</p>
sample size(s), and the interim look schedule(s)</a></li>
<li><a href='#sim_single_trial'><p>Simulate a single trial with posterior probability monitoring</p></a></li>
<li><a href='#two_sample_cal_tbl'><p>Output from a two-sample call to <code>calibrate_thresholds</code></p></a></li>
<li><a href='#two_sample_decision_tbl'><p>Output from a two-sample call to <code>calc_decision_rules</code></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Design Clinical Trials using Sequential Predictive Probability
Monitoring</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions are available to calibrate designs over a range of posterior and predictive thresholds, to plot the various design options, and to obtain the operating characteristics of optimal accuracy and optimal efficiency designs.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/zabore/ppseq">https://github.com/zabore/ppseq</a>, <a href="https://www.emilyzabor.com/ppseq/">https://www.emilyzabor.com/ppseq/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/zabore/ppseq/issues">https://github.com/zabore/ppseq/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, gt, knitr, rmarkdown, spelling, testthat (&ge; 3.0.0),
vdiffr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, furrr, ggplot2, plotly, purrr, tibble, patchwork, tidyr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-23 14:25:38 UTC; zabore2</td>
</tr>
<tr>
<td>Author:</td>
<td>Emily C. Zabor <a href="https://orcid.org/0000-0002-1402-4498"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Brian P. Hobbs [aut],
  Michael J. Kane <a href="https://orcid.org/0000-0003-1899-6662"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Emily C. Zabor &lt;zabore2@ccf.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-23 15:00:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='calc_decision_rules'>Calculate a decision rule table for interim monitoring of a pre-specified
design</h2><span id='topic+calc_decision_rules'></span>

<h3>Description</h3>

<p>This function will take the posterior and predictive thresholds
for a pre-specified design with a given null response rate and fixed interim
looks and total sample size, and return the decision rules at each interim
analysis and the end of the trial. Intended for use after selecting an
optimal design using the functions <code>calibrate_thresholds</code> and
<code>optimize_design</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_decision_rules(
  n,
  N,
  theta,
  ppp,
  p0,
  direction = "greater",
  delta = NULL,
  prior = c(0.5, 0.5),
  S = 5000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_decision_rules_+3A_n">n</code></td>
<td>
<p>matrix containing the total number of patients accrued so far at
each interim look in the standard of care (column 1) and experimental
(column 2) arms for two-sample case; vector of sample size accrued so far
at each interim look for one-sample case. The last value should be equal to
the total sample size at the end of the trial.
If only a single look will be done
at the end of the trial, this can be a vector specifying the total sample
size c(N0, N1) for the two-sample case or an integer specifying the total
sample size N for the one-sample case</p>
</td></tr>
<tr><td><code id="calc_decision_rules_+3A_n">N</code></td>
<td>
<p>the total planned sample size at the end of the trial, c(N0, N1)
for two-sample case; integer of total planned sample size at end of trial N
for one-sample case</p>
</td></tr>
<tr><td><code id="calc_decision_rules_+3A_theta">theta</code></td>
<td>
<p>The target posterior probability. e.g. Efficacy decision if
P(p1 &gt; p0) &gt; theta for the two-sample case with greater direction.</p>
</td></tr>
<tr><td><code id="calc_decision_rules_+3A_ppp">ppp</code></td>
<td>
<p>The target predictive probability. e.g. Stop the trial if the
predictive probability falls below this target.</p>
</td></tr>
<tr><td><code id="calc_decision_rules_+3A_p0">p0</code></td>
<td>
<p>The target value to compare to in the one-sample case. Set to NULL
for the two-sample case.</p>
</td></tr>
<tr><td><code id="calc_decision_rules_+3A_direction">direction</code></td>
<td>
<p>&quot;greater&quot; (default) if interest is in P(p1 &gt; p0) and &quot;less&quot;
if interest is in P(p1 &lt; p0) for two-sample case. For one-sample case,
&quot;greater&quot; if interest is in P(p &gt; p0) and &quot;less&quot; if interest is in P(p &lt; p0).</p>
</td></tr>
<tr><td><code id="calc_decision_rules_+3A_delta">delta</code></td>
<td>
<p>clinically meaningful difference between groups.
Typically 0 for two-sample case. NULL for one-sample case (default).</p>
</td></tr>
<tr><td><code id="calc_decision_rules_+3A_prior">prior</code></td>
<td>
<p>hyperparameters of prior beta distribution.
Beta(0.5, 0.5) is default</p>
</td></tr>
<tr><td><code id="calc_decision_rules_+3A_s">S</code></td>
<td>
<p>number of samples, default is 5000</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In the one-sample case, returns a tibble with n at each look, r at
each look, and ppp, the associated posterior predictive probability.
Stop the trial at that look if the number of observed responses is &lt;=r.
At the end of the trial, the treatment is considered promising if the number
of observed responses is &gt;r.
In the two-sample case, returns a tibble with n0 and n1, the number
enrolled subjects in the control and experimental arms at each look,
respectively, r0 and r1, the number of possible responses in the control and
experimental arms at each look, respectively, and ppp, the associated
posterior predictive probability. For a given value of r0, stop the trial if
the number of observed responses in the experimental arm is &lt;=r1. At the end
of the trial, the treatment is considered promising if the number of
observed responses in the experimental arm is &gt;r1 for a given r0.
Any NA value in either table represents an
interim look where there is no number of responses that would lead to
stopping the trial.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)

# One-sample case
calc_decision_rules(
  n = seq(5, 25, 5), 
  N = 25, 
  theta = 0.86, 
  ppp = 0.2, 
  p0 = 0.1, 
  S = 50
  )

# Two-sample case
calc_decision_rules(
  n = cbind(seq(5, 25, 5), seq(5, 25, 5)), 
  N = c(25, 25),
  theta = 0.86, 
  ppp = 0.2, 
  p0 = NULL, 
  direction = "greater", 
  delta = 0, 
  S = 50
  )

</code></pre>

<hr>
<h2 id='calc_next'>Calculate response probability for the next patient</h2><span id='topic+calc_next'></span>

<h3>Description</h3>

<p>This function is meant to be used in the context of a
clinical trial with a binary endpoint. For the two-sample case, the total
number of events in the standard-of-care arm is y0 and the total number of
events in the experimental arm is y1. The function samples from the posterior
beta distribution based on the data and the prior beta hyperparameters, and
returns the empiric mean and bootstrap confidence interval for the next
patient. The empiric mean represents the probability of the binary outcome
occurring in the next patient.
The one-sample case is also available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_next(y, n, prior = c(0.5, 0.5), S = 5000, interval = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_next_+3A_y">y</code></td>
<td>
<p>number of events observed so far. Vector of length two c(y0, y1)
for the two-sample case; integer y for the one-sample case.</p>
</td></tr>
<tr><td><code id="calc_next_+3A_n">n</code></td>
<td>
<p>sample size observed so far. Vector of length two c(n0, n1)
for the two-sample case; integer n for the one-sample case.</p>
</td></tr>
<tr><td><code id="calc_next_+3A_prior">prior</code></td>
<td>
<p>vector of length two containing hyperparameters of the prior
beta distribution. c(0.5, 0.5) is default, for the Beta(0.5, 0.5)
distribution.</p>
</td></tr>
<tr><td><code id="calc_next_+3A_s">S</code></td>
<td>
<p>number of samples, default is 5000</p>
</td></tr>
<tr><td><code id="calc_next_+3A_interval">interval</code></td>
<td>
<p>a value between 0 and 1 indicating the width of the desired
interval, default is 0.95</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a tibble with the group indicator (for the two-sample case
only), the empiric mean, the bootstrap confidence interval, and the
specified width of the confidence interval.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)

# One-sample case
calc_next(
  y = 27, 
  n = 100,
  S = 100
  )

# Two-sample case
calc_next(
  y = c(14, 23), 
  n = c(100, 100),
  S = 100
  )

</code></pre>

<hr>
<h2 id='calc_posterior'>Calculate a single posterior probability</h2><span id='topic+calc_posterior'></span>

<h3>Description</h3>

<p>This function is meant to be used in the context of a
clinical trial with a binary endpoint. For the two-sample case, the total
number of events in the standard-of-care arm is y0 and the total number of
events in the experimental arm is y1. The function samples from the posterior
beta distribution based on the data and the prior beta hyperparameters, and
returns the posterior probability that p1 is greater than (or less than) p0
given the data. The one-sample case is also available, in which a target p0
must be specified and the function returns the posterior probability that
p is greater than (or less than) p0 given the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_posterior(
  y,
  n,
  p0,
  direction = "greater",
  delta = NULL,
  prior = c(0.5, 0.5),
  S = 5000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_posterior_+3A_y">y</code></td>
<td>
<p>number of events observed so far. Vector of length two c(y0, y1)
for the two-sample case; integer y for the one-sample case.</p>
</td></tr>
<tr><td><code id="calc_posterior_+3A_n">n</code></td>
<td>
<p>sample size observed so far. Vector of length two c(n0, n1)
for the two-sample case; integer n for the one-sample case.</p>
</td></tr>
<tr><td><code id="calc_posterior_+3A_p0">p0</code></td>
<td>
<p>the target value to compare to in the one-sample case. Set to NULL
for the two-sample case.</p>
</td></tr>
<tr><td><code id="calc_posterior_+3A_direction">direction</code></td>
<td>
<p>&quot;greater&quot; (default) if interest is in P(p1 &gt; p0) in the
two-sample case or P(p &gt; p0) in the one-sample case; &quot;less&quot;
if interest is in P(p1 &lt; p0) for the two-sample case or P(p &lt; p0) for the
one-sample case.</p>
</td></tr>
<tr><td><code id="calc_posterior_+3A_delta">delta</code></td>
<td>
<p>clinically meaningful difference between groups.
Typically 0 for the two-sample case. NULL for one-sample case (default).</p>
</td></tr>
<tr><td><code id="calc_posterior_+3A_prior">prior</code></td>
<td>
<p>vector of length two containing hyperparameters of the prior
beta distribution. c(0.5, 0.5) is default, for the Beta(0.5, 0.5)
distribution.</p>
</td></tr>
<tr><td><code id="calc_posterior_+3A_s">S</code></td>
<td>
<p>number of samples, default is 5000</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the numeric posterior probability
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)

# One-sample case
calc_posterior(
  y = 27, 
  n = 100, 
  p0 = 0.2
  )

# Two-sample case
calc_posterior(
  y = c(14, 23), 
  n = c(100, 100), 
  p0 = NULL, 
  delta = 0
  )

</code></pre>

<hr>
<h2 id='calc_predictive'>Calculate a single posterior predictive probability</h2><span id='topic+calc_predictive'></span>

<h3>Description</h3>

<p>This function is meant to be used in the context of a
clinical trial with a binary endpoint. The goal is to calculate the posterior
predictive probability of success at the end of a trial, given the data
available at an interim analysis. For the two-sample case the number of events
observed at interim analysis, the sample size at interim analysis,
and the total planned sample size are denoted y0, n0, and N0 in
the standard-of-care arm and y1, n1, and N1 in the experimental arm.
For the one-sample case, the number of events observed at interim analysis,
the sample size at interim analysis, and the total planned sample size are
denoted y, n, and N.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_predictive(
  y,
  n,
  p0,
  N,
  direction = "greater",
  delta = NULL,
  prior = c(0.5, 0.5),
  S = 5000,
  theta = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_predictive_+3A_y">y</code></td>
<td>
<p>number of events observed so far. Vector of length two c(y0, y1)
for the two-sample case; integer y for the one-sample case.</p>
</td></tr>
<tr><td><code id="calc_predictive_+3A_n">n</code></td>
<td>
<p>sample size observed so far. Vector of length two c(n0, n1)
for the two-sample case; integer n for the one-sample case.</p>
</td></tr>
<tr><td><code id="calc_predictive_+3A_p0">p0</code></td>
<td>
<p>the target value to compare to in the one-sample case. Set to NULL
for the two-sample case.</p>
</td></tr>
<tr><td><code id="calc_predictive_+3A_n">N</code></td>
<td>
<p>the total planned sample size at the end of the trial. Vector of
length two c(N0, N1) for the two-sample case; integer N for the one-sample
case.</p>
</td></tr>
<tr><td><code id="calc_predictive_+3A_direction">direction</code></td>
<td>
<p>&quot;greater&quot; (default) if interest is in P(p1 &gt; p0) in the
two-sample case or P(p &gt; p0) in the one-sample case; &quot;less&quot;
if interest is in P(p1 &lt; p0) for the two-sample case or P(p &lt; p0) for the
one-sample case.</p>
</td></tr>
<tr><td><code id="calc_predictive_+3A_delta">delta</code></td>
<td>
<p>clinically meaningful difference between groups.
Typically 0 for the two-sample case. NULL for one-sample case (default).</p>
</td></tr>
<tr><td><code id="calc_predictive_+3A_prior">prior</code></td>
<td>
<p>vector of length two containing hyperparameters of the prior
beta distribution. c(0.5, 0.5) is default, for the Beta(0.5, 0.5)
distribution.</p>
</td></tr>
<tr><td><code id="calc_predictive_+3A_s">S</code></td>
<td>
<p>number of samples, default is 5000</p>
</td></tr>
<tr><td><code id="calc_predictive_+3A_theta">theta</code></td>
<td>
<p>The target posterior probability. e.g. Efficacy decision if
P(p1 &gt; p0) &gt; theta for the two-sample case with greater direction.
Default is 0.95.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the numeric posterior predictive probability
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)

# Setting S = 100 for speed, in practice you would want a much larger sample

# One-sample case 
calc_predictive(
  y = 14, 
  n = 50, 
  p0 = 0.2, 
  N = 100, 
  S = 100
  )

# Two-sample case 
calc_predictive(
  y = c(7, 12), 
  n = c(50, 50), 
  p0 = NULL, 
  N = c(100, 100),
  delta = 0,
  S = 100
  )

</code></pre>

<hr>
<h2 id='calibrate_posterior_threshold'>Calibrate the posterior probability threshold</h2><span id='topic+calibrate_posterior_threshold'></span>

<h3>Description</h3>

<p>This function is meant to be used in the context of a
clinical trial with a binary endpoint. For a vector of possible posterior
decision thresholds, the function simulates many trials and then calculates
the average number of times the posterior probability exceeds a given
threshold. In a null case, this will result in the type I error at a given
threshold. In an alternative case, this will result in the power at a given
threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibrate_posterior_threshold(
  p,
  N,
  p0,
  direction = "greater",
  delta = NULL,
  prior = c(0.5, 0.5),
  S = 5000,
  theta
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calibrate_posterior_threshold_+3A_p">p</code></td>
<td>
<p>vector of length two containing the probability of event in
the standard of care and experimental arm c(p0, p1) for the two-sample case;
integer of event probability for one-sample case</p>
</td></tr>
<tr><td><code id="calibrate_posterior_threshold_+3A_n">N</code></td>
<td>
<p>vector of length two containing the total sample size c(N0, N1)
for two-sample case; integer of sample size so far N for one-sample case</p>
</td></tr>
<tr><td><code id="calibrate_posterior_threshold_+3A_p0">p0</code></td>
<td>
<p>The target value to compare to in the one-sample case. Set to
NULL for the two-sample case.</p>
</td></tr>
<tr><td><code id="calibrate_posterior_threshold_+3A_direction">direction</code></td>
<td>
<p>&quot;greater&quot; (default) if interest is in p(p1 &gt; p0) and &quot;less&quot;
if interest is in p(p1 &lt; p0) for two-sample case. For one-sample case,
&quot;greater&quot; if interest is in p(p &gt; p0) and &quot;less&quot; if interest is in p(p &lt; p0).</p>
</td></tr>
<tr><td><code id="calibrate_posterior_threshold_+3A_delta">delta</code></td>
<td>
<p>clinically meaningful difference between groups.
Typically 0 for the two-sample case. NULL for the one-sample case (default).</p>
</td></tr>
<tr><td><code id="calibrate_posterior_threshold_+3A_prior">prior</code></td>
<td>
<p>hyperparameters of prior beta distribution.
Beta(0.5, 0.5) is default</p>
</td></tr>
<tr><td><code id="calibrate_posterior_threshold_+3A_s">S</code></td>
<td>
<p>number of samples drawn from the posterior, and number of simulated
trials. Default is 5000</p>
</td></tr>
<tr><td><code id="calibrate_posterior_threshold_+3A_theta">theta</code></td>
<td>
<p>The target posterior probability thresholds to consider.
Integer or vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a tibble with the posterior probability threshold(s) and
associated proportion of positive trials.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)

# Setting S = 100 for speed, in practice you would want a much larger sample

# One-sample case
calibrate_posterior_threshold(
  p = 0.1,
  N = 50,
  p0 = 0.1,
  S = 100,
  theta = c(0.9, 0.95)
  )

# Two-sample case
calibrate_posterior_threshold(
  p = c(0.1, 0.1),
  N = c(50, 50),
  p0 = NULL,
  delta = 0,
  S = 100,
  theta = c(0.9, 0.95)
  )
  
</code></pre>

<hr>
<h2 id='calibrate_thresholds'>Calibrate according to posterior probability threshold and predictive
probability threshold with interim futility monitoring</h2><span id='topic+calibrate_thresholds'></span>

<h3>Description</h3>

<p>This function is meant to be used in the context of a
clinical trial with a binary endpoint. For every combination of the provided
posterior thresholds and predictive thresholds, the function simulates many
trials and then calculates the average number of times a trial was positive.
In the null case, this is the type I error for the given thresholds.
In the alternative case, this is the power for the given thresholds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibrate_thresholds(
  p_null,
  p_alt,
  n,
  N,
  pp_threshold,
  ppp_threshold,
  direction = "greater",
  delta = NULL,
  monitoring = "futility",
  prior = c(0.5, 0.5),
  S = 5000,
  nsim = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calibrate_thresholds_+3A_p_null">p_null</code></td>
<td>
<p>vector of length two containing the probability of event in
the standard of care and experimental arm c(p0, p1) for the two-sample case
for the null scenario;
integer of event probability for one-sample case</p>
</td></tr>
<tr><td><code id="calibrate_thresholds_+3A_p_alt">p_alt</code></td>
<td>
<p>vector of length two containing the probability of event in
the standard of care and experimental arm c(p0, p1) for the two-sample case
for the alternative scenario;
integer of event probability for one-sample case</p>
</td></tr>
<tr><td><code id="calibrate_thresholds_+3A_n">n</code></td>
<td>
<p>matrix containing the total number of patients accrued so far at
each interim look in the standard of care (column 1) and experimental
(column 2) arms for two-sample case; vector of sample size accrued so far
at each interim look for one-sample case. The last value should be equal to
the total sample size at the end of the trial.
If only a single look will be done
at the end of the trial, this can be a vector specifying the total sample
size c(N0, N1) for the two-sample case or an integer specifying the total
sample size N for the one-sample case</p>
</td></tr>
<tr><td><code id="calibrate_thresholds_+3A_n">N</code></td>
<td>
<p>the total planned sample size at the end of the trial, c(N0, N1)
for two-sample case; integer of total planned sample size at end of trial N
for one-sample case</p>
</td></tr>
<tr><td><code id="calibrate_thresholds_+3A_pp_threshold">pp_threshold</code></td>
<td>
<p>the posterior probability threshold of interest</p>
</td></tr>
<tr><td><code id="calibrate_thresholds_+3A_ppp_threshold">ppp_threshold</code></td>
<td>
<p>the posterior predictive probability threshold of
interest for futility monitoring</p>
</td></tr>
<tr><td><code id="calibrate_thresholds_+3A_direction">direction</code></td>
<td>
<p>&quot;greater&quot; (default) if interest is in p(p1 &gt; p0) and &quot;less&quot;
if interest is in p(p1 &lt; p0) for two-sample case. For one-sample case,
&quot;greater&quot; if interest is in p(p &gt; p0) and &quot;less&quot; if interest is in p(p &lt; p0).</p>
</td></tr>
<tr><td><code id="calibrate_thresholds_+3A_delta">delta</code></td>
<td>
<p>clinically meaningful difference between groups.
Typically 0 for the two-sample case. NULL for the one-sample case (default).</p>
</td></tr>
<tr><td><code id="calibrate_thresholds_+3A_monitoring">monitoring</code></td>
<td>
<p>the type of interim monitoring to be performed. One of
&quot;futility&quot; or &quot;efficacy&quot;. Default is &quot;futility&quot;.</p>
</td></tr>
<tr><td><code id="calibrate_thresholds_+3A_prior">prior</code></td>
<td>
<p>hyperparameters of prior beta distribution.
Beta(0.5, 0.5) is default</p>
</td></tr>
<tr><td><code id="calibrate_thresholds_+3A_s">S</code></td>
<td>
<p>number of samples drawn from the posterior. Default is 5000</p>
</td></tr>
<tr><td><code id="calibrate_thresholds_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulated trial datasets.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing a
</p>

<ol>
<li><p> a tibble 'res_summary' containing the posterior probability threshold
(pp_threshold), the predictive probability threshold (ppp_threshold),
the mean sample size under the null (mean_n0_null and mean_n1_null
for two-sample case; mean_n1_null for one-sample case), the proportion of
positive trials under the null (prop_pos_null), the proportion of trials
stopped early under the null (prop_stopped_null), the mean sample
size under the alternative (mean_n0_alt and mean_n1_alt
for two-sample case; mean_n1_alt for one-sample case), the proportion of
positive trials under the alternative (prop_pos_alt), the proportion of
trials stopped early under the alternative (prop_stopped_alt)
</p>
</li>
<li><p> 'call_list' containing the original function call
</p>
</li>
<li><p> 'calibrate_thresholds_inputs' a list containing the inputs to the
original function call
</p>
</li></ol>

<p>The proportion of positive trials will be a measure of the type I error
for a null setting, and a measure of the power in the alternative setting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# One-sample case
set.seed(123)

calibrate_thresholds(
  p_null = 0.1, 
  p_alt = 0.4,
  n = seq(5, 15, 5), 
  N = 15,
  pp_threshold = c(0.85, 0.9),
  ppp_threshold = c(0.1, 0.2),
  S = 10, 
  nsim = 10
  )

# Two-sample case
set.seed(456)

calibrate_thresholds(
  p_null = c(0.1, 0.1), 
  p_alt = c(0.1, 0.5),
  n = cbind(seq(5, 15, 5), seq(5, 15, 5)), 
  N = c(15, 15),
  pp_threshold = c(0.8, 0.85),
  ppp_threshold = c(0.2, 0.3),
  delta = 0,
  S = 10, 
  nsim = 10
  )

</code></pre>

<hr>
<h2 id='eval_thresh'>Evaluate a single dataset for a single pp_threshold and ppp_threshold
combination</h2><span id='topic+eval_thresh'></span>

<h3>Description</h3>

<p>Helper function for calibrate_thresholds() function that
evaluates a single combination of a pp_threshold and a ppp_threshold for a
single dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_thresh(
  data,
  pp_threshold,
  ppp_threshold,
  p0,
  N,
  direction = "greater",
  delta = NULL,
  monitoring = "futility",
  prior = c(0.5, 0.5),
  S = 5000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_thresh_+3A_data">data</code></td>
<td>
<p>the name of the dataset</p>
</td></tr>
<tr><td><code id="eval_thresh_+3A_pp_threshold">pp_threshold</code></td>
<td>
<p>the posterior probability threshold of interest</p>
</td></tr>
<tr><td><code id="eval_thresh_+3A_ppp_threshold">ppp_threshold</code></td>
<td>
<p>the posterior probability threshold of interest for
futility monitoring</p>
</td></tr>
<tr><td><code id="eval_thresh_+3A_p0">p0</code></td>
<td>
<p>The target value to compare to in the one-sample case. Set to
NULL for the two-sample case.</p>
</td></tr>
<tr><td><code id="eval_thresh_+3A_n">N</code></td>
<td>
<p>the total planned sample size at the end of the trial, c(N0, N1)
for two-sample case; integer of total planned sample size at end of trial N
for one-sample case</p>
</td></tr>
<tr><td><code id="eval_thresh_+3A_direction">direction</code></td>
<td>
<p>&quot;greater&quot; (default) if interest is in P(p1 &gt; p0) and &quot;less&quot;
if interest is in P(p1 &lt; p0) for two-sample case. For one-sample case,
&quot;greater&quot; if interest is in P(p &gt; p0) and &quot;less&quot; if interest is in P(p &lt; p0).</p>
</td></tr>
<tr><td><code id="eval_thresh_+3A_delta">delta</code></td>
<td>
<p>clinically meaningful difference between groups.
Typically 0 for the two-sample case. NULL for the one-sample case (default).</p>
</td></tr>
<tr><td><code id="eval_thresh_+3A_monitoring">monitoring</code></td>
<td>
<p>the type of interim monitoring to be performed. One of
&quot;futility&quot; or &quot;efficacy&quot;. Default is &quot;futility&quot;.</p>
</td></tr>
<tr><td><code id="eval_thresh_+3A_prior">prior</code></td>
<td>
<p>hyperparameters of prior beta distribution.
Beta(0.5, 0.5) is default</p>
</td></tr>
<tr><td><code id="eval_thresh_+3A_s">S</code></td>
<td>
<p>number of samples, default is 5000</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a tibble with the total sample size at the end of the
trial, the number of responses observed at the end of the trial, the
pp_threshold considered, the ppp_threshold considered, the observed
predictive probability generated from calc_predictive(), and an indicator
for whether the trial was positive or not at the end
</p>

<hr>
<h2 id='one_sample_cal_tbl'>Output from a one-sample call to <code>calibrate_thresholds</code></h2><span id='topic+one_sample_cal_tbl'></span>

<h3>Description</h3>

<p>This .rda file contains output from a one-sample call to
<code>calibrate_thresholds()</code>.
See the vignette titled &quot;One-sample expansion cohort&quot; for a description of
the input parameters used, or run
<code>one_sample_cal_tbl$inputs</code>
to see a list of the original function inputs. For use in testing
functions and in vignettes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(one_sample_cal_tbl)
</code></pre>


<h3>Format</h3>

<p>A list containing a
</p>

<ol>
<li><p> a tibble 'res_summary' containing the posterior probability threshold
(pp_threshold); the predictive probability threshold (ppp_threshold);
the mean sample size under the null (mean_n1_null) and alternative
(mean_n1_alt) response rates; the proportion of positive trials under
the null (prop_pos_null) and alternative (prop_pos_alt) response rates; and
the proportion of trials stopped under the null (prop_stopped_null) and
alternative (prop_stopped_alt) response rates
</p>
</li>
<li><p> 'call_list' containing the original function call
</p>
</li>
<li><p> 'inputs' a list containing the inputs to the
original function call
</p>
</li></ol>


<hr>
<h2 id='one_sample_decision_tbl'>Output from a one-sample call to <code>calc_decision_rules</code></h2><span id='topic+one_sample_decision_tbl'></span>

<h3>Description</h3>

<p>This .rda file contains output from a one-sample call to
<code>calc_decision_rules()</code>.
See the vignette titled &quot;One-sample expansion cohort&quot; for a description of
the input parameters used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(one_sample_decision_tbl)
</code></pre>


<h3>Format</h3>

<p>A tibble containing n, the number of patients enrolled at each
futility monitoring point; r, the number of responses at which we would
stop the trial at a given look if the number of observed responses is &lt;=r,
or at the end of the trial the treatment is considered promising if the
number of observed responses is &gt;r; and ppp, the predictive probability at
each given look
</p>

<hr>
<h2 id='optimize_design'>Function to setup usage of <code>optimize_design.calibrate_thresholds</code></h2><span id='topic+optimize_design'></span>

<h3>Description</h3>

<p>Function to setup usage of <code>optimize_design.calibrate_thresholds</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimize_design(x, type1_range = c(0, 1), minimum_power = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimize_design_+3A_x">x</code></td>
<td>
<p>an object of class 'calibrate_thresholds', usually returned by the
<code>calibrate_thresholds</code> function</p>
</td></tr>
<tr><td><code id="optimize_design_+3A_type1_range">type1_range</code></td>
<td>
<p>a vector specifying the minimum and maximum acceptable
type I error. Specify NULL to return the full range of resulting type I
error. Defaults to c(0, 1) to return all results.</p>
</td></tr>
<tr><td><code id="optimize_design_+3A_minimum_power">minimum_power</code></td>
<td>
<p>a numeric between 0 and 1 specifying the minimum
acceptable power. Specify NULL to return the full range of resulting power.
Defaults to 0 to return all results.</p>
</td></tr>
<tr><td><code id="optimize_design_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='optimize_design.calibrate_thresholds'>Custom optimization method for <code>calibrate_thresholds</code> objects</h2><span id='topic+optimize_design.calibrate_thresholds'></span>

<h3>Description</h3>

<p>Determines the optimal designs based on a variety of criteria.
The optimal efficiency design is the one with the shortest Euclidean
distance to the upper left point on a plot of the average sample size under
the null by the average sample size under the alternative. The optimal
accuracy design is the one with the shortest Euclidean distance to the
upper left point on a plot of the type I error by the power.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'calibrate_thresholds'
optimize_design(
  x,
  type1_range = c(0, 1),
  minimum_power = 0,
  w_type1 = 1,
  w_power = 1,
  w_Nnull = 1,
  w_Nalt = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimize_design.calibrate_thresholds_+3A_x">x</code></td>
<td>
<p>an object of class 'calibrate_thresholds', usually returned by the
<code>calibrate_thresholds</code> function</p>
</td></tr>
<tr><td><code id="optimize_design.calibrate_thresholds_+3A_type1_range">type1_range</code></td>
<td>
<p>a vector specifying the minimum and maximum acceptable
type I error. Specify NULL to return the full range of resulting type I
error. Defaults to c(0, 1) to return all results.</p>
</td></tr>
<tr><td><code id="optimize_design.calibrate_thresholds_+3A_minimum_power">minimum_power</code></td>
<td>
<p>a numeric between 0 and 1 specifying the minimum
acceptable power. Specify NULL to return the full range of resulting power.
Defaults to 0 to return all results.</p>
</td></tr>
<tr><td><code id="optimize_design.calibrate_thresholds_+3A_w_type1">w_type1</code></td>
<td>
<p>a user-specified weight on the type 1 error.
Defaults to 1 for no weighting.</p>
</td></tr>
<tr><td><code id="optimize_design.calibrate_thresholds_+3A_w_power">w_power</code></td>
<td>
<p>a user-specified weight on the power.
Defaults to 1 for no weighting.</p>
</td></tr>
<tr><td><code id="optimize_design.calibrate_thresholds_+3A_w_nnull">w_Nnull</code></td>
<td>
<p>a user-specified weight on the average sample size under the
null. Defaults to 1 for no weighting.</p>
</td></tr>
<tr><td><code id="optimize_design.calibrate_thresholds_+3A_w_nalt">w_Nalt</code></td>
<td>
<p>a user-specified weight on the average sample size under the
alternative. Defaults to 1 for no weighting.</p>
</td></tr>
<tr><td><code id="optimize_design.calibrate_thresholds_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length two containing details of the optimal efficiency
and optimal accuracy designs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Setting S = 50 and nsim = 50 for speed
# In practice you would want a much larger sample and more simulations

# One-sample case
set.seed(123)

cal_tbl1 &lt;- calibrate_thresholds(
  p_null = 0.1, 
  p_alt = 0.4,
  n = seq(5, 15, 5), 
  N = 15,
  pp_threshold = c(0.85, 0.9),
  ppp_threshold = c(0.1, 0.2),
  S = 10, 
  nsim = 10
  )

optimize_design(cal_tbl1)


# Two-sample case
set.seed(456)

cal_tbl2 &lt;- calibrate_thresholds(
  p_null = c(0.1, 0.1), 
  p_alt = c(0.1, 0.5),
  n = cbind(seq(5, 15, 5), seq(5, 15, 5)), 
  N = c(15, 15),
  pp_threshold = c(0.8, 0.85),
  ppp_threshold = c(0.2, 0.3),
  delta = 0,
  S = 10, 
  nsim = 10
  )

optimize_design(cal_tbl2)

</code></pre>

<hr>
<h2 id='plot.calc_decision_rules'>Plot method for <code>calc_decision_rules</code> objects</h2><span id='topic+plot.calc_decision_rules'></span>

<h3>Description</h3>

<p>Returns a plot of decision rules from the results of
<code>calc_decision_rules</code> that can interactively show when to stop and
when to proceed at the various interim analyses
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'calc_decision_rules'
plot(x, plotly = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.calc_decision_rules_+3A_x">x</code></td>
<td>
<p>an object of class 'calc_decision_rules', usually returned by the
<code>calc_decision_rules</code> function</p>
</td></tr>
<tr><td><code id="plot.calc_decision_rules_+3A_plotly">plotly</code></td>
<td>
<p>should the plot be rendered in plotly? (Default is TRUE)</p>
</td></tr>
<tr><td><code id="plot.calc_decision_rules_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In the one-sample case, a heatmap plot with number enrolled on the
x-axis and number of responses on the y-axis. In the two-sample case, a
grid of heatmap plots. Each plot is a combination of the number enrolled so
far in the experimental and control arms. The x-axis is the number of
responses in the control arm and the y-axis is the number of responses in
the experimental arm.
Green indicates combinations where the trial would proceed and red indicates
combinations where the trial would stop.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)

# Two-sample case
dec_tbl &lt;- calc_decision_rules(
  n = cbind(seq(5, 15, 5), seq(5, 15, 5)),
  N = c(15, 15),
  theta = 0.86,
  ppp = 0.2,
  p0 = NULL,
  direction = "greater",
  delta = 0,
  S = 50
)

plot(dec_tbl, plotly = FALSE)

</code></pre>

<hr>
<h2 id='plot.calibrate_thresholds'>Plot method for <code>calibrate_thresholds</code> objects</h2><span id='topic+plot.calibrate_thresholds'></span>

<h3>Description</h3>

<p>Returns two interactive <code>plotly</code> plots (if plotly=TRUE)
or two static <code>ggplot2</code> plots (if plotly=FALSE) to compare results
from various designs generated from a call to <code>calibrate_thresholds</code>
based on various criteria, and to assist in selecting an optimal design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'calibrate_thresholds'
plot(x, type1_range = c(0, 1), minimum_power = 0, plotly = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.calibrate_thresholds_+3A_x">x</code></td>
<td>
<p>an object of class 'calibrate_thresholds', usually returned by the
<code>calibrate_thresholds</code> function</p>
</td></tr>
<tr><td><code id="plot.calibrate_thresholds_+3A_type1_range">type1_range</code></td>
<td>
<p>a vector specifying the minimum and maximum acceptable
type I error. Specify c(0, 1) to return the full range of resulting type I
error. Defaults to c(0, 1)</p>
</td></tr>
<tr><td><code id="plot.calibrate_thresholds_+3A_minimum_power">minimum_power</code></td>
<td>
<p>a numeric between 0 and 1 specifying the minimum
acceptable power. Specify 0 to return the full range of resulting power.
Defaults to 0.</p>
</td></tr>
<tr><td><code id="plot.calibrate_thresholds_+3A_plotly">plotly</code></td>
<td>
<p>a logical indicator of whether you want the plots returned as
interactive plotly plots or non-interactive ggplots. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="plot.calibrate_thresholds_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plots of the average sample size under the null by the average
sample size under the alternative, and the type I error by the power for
designs meeting the specified <code>type1_range</code> and
<code>minimum_power</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Setting S = 50 and nsim = 50 for speed
# In practice you would want a much larger sample and more simulations

set.seed(123)

# One-sample case
cal_tbl1 &lt;- calibrate_thresholds(
  p_null = 0.1,
  p_alt = 0.4,
  n = seq(5, 15, 5),
  N = 15,
  pp_threshold = c(0.85, 0.9),
  ppp_threshold = c(0.1, 0.2),
  S = 10,
  nsim = 10
  )

plot(cal_tbl1, type1_range = c(0.01, 0.2), minimum_power = 0.7)

</code></pre>

<hr>
<h2 id='ppseq-package'>ppseq: Design Clinical Trials using Sequential Predictive Probability Monitoring</h2><span id='topic+ppseq'></span><span id='topic+ppseq-package'></span>

<h3>Description</h3>

<p>Functions are available to calibrate designs over a range of posterior and predictive thresholds, to plot the various design options, and to obtain the operating characteristics of optimal accuracy and optimal efficiency designs.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Emily C. Zabor <a href="mailto:zabore2@ccf.org">zabore2@ccf.org</a> (<a href="https://orcid.org/0000-0002-1402-4498">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Brian P. Hobbs
</p>
</li>
<li><p> Michael J. Kane <a href="mailto:michael.kane@yale.edu">michael.kane@yale.edu</a> (<a href="https://orcid.org/0000-0003-1899-6662">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/zabore/ppseq">https://github.com/zabore/ppseq</a>
</p>
</li>
<li> <p><a href="https://www.emilyzabor.com/ppseq/">https://www.emilyzabor.com/ppseq/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/zabore/ppseq/issues">https://github.com/zabore/ppseq/issues</a>
</p>
</li></ul>


<hr>
<h2 id='print.calibrate_thresholds'>Print method for <code>calibrate_thresholds</code> objects</h2><span id='topic+print.calibrate_thresholds'></span>

<h3>Description</h3>

<p>By default prints only the res_summary table from an object of
class 'calibrate_thresholds'. The table can be limited to a range of type 1
error and a minimum value of power using the arguments 'type1_range' and
'minimum_power' respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'calibrate_thresholds'
print(x, type1_range = c(0, 1), minimum_power = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.calibrate_thresholds_+3A_x">x</code></td>
<td>
<p>an object of class 'calibrate_thresholds', usually returned by the
<code>calibrate_thresholds</code> function</p>
</td></tr>
<tr><td><code id="print.calibrate_thresholds_+3A_type1_range">type1_range</code></td>
<td>
<p>a vector specifying the minimum and maximum acceptable
type I error. Specify c(0, 1) to return the full range of resulting type I
error. Defaults to c(0, 1)</p>
</td></tr>
<tr><td><code id="print.calibrate_thresholds_+3A_minimum_power">minimum_power</code></td>
<td>
<p>a numeric between 0 and 1 specifying the minimum
acceptable power. Specify 0 to return the full range of resulting power.
Defaults to 0.</p>
</td></tr>
<tr><td><code id="print.calibrate_thresholds_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)

cal_tbl1 &lt;- calibrate_thresholds(
  p_null = 0.1,
  p_alt = 0.4,
  n = seq(5, 15, 5),
  N = 15,
  pp_threshold = c(0.85, 0.9),
  ppp_threshold = c(0.1, 0.2),
  S = 10,
  nsim = 10
  )

print(cal_tbl1)
print(cal_tbl1, type1_range = c(0.05, 0.1), minimum_power = 0.9)

</code></pre>

<hr>
<h2 id='sim_dat1'>Simulate a single dataset based on the response probability(ies), the total
sample size(s), and the interim look schedule(s)</h2><span id='topic+sim_dat1'></span>

<h3>Description</h3>

<p>Helper function for calibrate_thresholds() function that
generates a single dataset of n and response count at each look based on the
response probability(ies)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_dat1(p, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_dat1_+3A_p">p</code></td>
<td>
<p>vector of length two containing the probability of event in
the standard of care and experimental arm c(p0, p1) for the two-sample case;
integer of event probability for one-sample case</p>
</td></tr>
<tr><td><code id="sim_dat1_+3A_n">n</code></td>
<td>
<p>matrix containing the total number of patients accrued so far at
each interim look in the standard of care (column 1) and experimental
(column 2) arms for two-sample case; vector of sample size accrued so far
at each interim look for one-sample case. The last value should be equal to
the total sample size at the end of the trial.
If only a single look will be done
at the end of the trial, this can be a vector specifying the total sample
size c(N0, N1) for the two-sample case or an integer specifying the total
sample size N for the one-sample case</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a tibble with n0, n1, y0, y1 for the two-sample case and
a tibble with n1 and y1 for the one-sample case
</p>

<hr>
<h2 id='sim_single_trial'>Simulate a single trial with posterior probability monitoring</h2><span id='topic+sim_single_trial'></span>

<h3>Description</h3>

<p>This function is meant to be used in the context of a
clinical trial with a binary endpoint. The goal is to simulate event counts
from the binomial distribution based on the number of patients
accrued at each interim look, and calculate the posterior predictive
probability of success (or futility) at the end of a trial,
given the data available at each interim analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_single_trial(
  p,
  n,
  p0,
  N,
  direction = "greater",
  delta = NULL,
  prior = c(0.5, 0.5),
  S = 5000,
  theta = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_single_trial_+3A_p">p</code></td>
<td>
<p>vector of length two containing the probability of event in
the standard of care and experimental arm c(p0, p1) for the two-sample case;
integer of event probability for one-sample case</p>
</td></tr>
<tr><td><code id="sim_single_trial_+3A_n">n</code></td>
<td>
<p>matrix containing the total number of patients accrued so far at
each interim look in the standard of care (column 1) and experimental
(column 2) arms for two-sample case; vector of sample size accrued so far
at each interim look for one-sample case. The last value should be equal to
the total sample size at the end of the trial.
If only a single look will be done
at the end of the trial, this can be a vector specifying the total sample
size c(N0, N1) for the two-sample case or an integer specifying the total
sample size N for the one-sample case.</p>
</td></tr>
<tr><td><code id="sim_single_trial_+3A_p0">p0</code></td>
<td>
<p>The target value to compare to in the one-sample case</p>
</td></tr>
<tr><td><code id="sim_single_trial_+3A_n">N</code></td>
<td>
<p>the total planned sample size at the end of the trial, c(N0, N1)
for two-sample case; integer of total planned sample size at end of trial N
for one-sample case</p>
</td></tr>
<tr><td><code id="sim_single_trial_+3A_direction">direction</code></td>
<td>
<p>&quot;greater&quot; (default) if interest is in P(p1 &gt; p0) and &quot;less&quot;
if interest is in P(p1 &lt; p0) for two-sample case. For one-sample case,
&quot;greater&quot; if interest is in P(p &gt; p0) and &quot;less&quot; if interest is in P(p &lt; p0).</p>
</td></tr>
<tr><td><code id="sim_single_trial_+3A_delta">delta</code></td>
<td>
<p>clinically meaningful difference between groups.
Typically 0 for the two-sample case. NULL for the one-sample case (default).</p>
</td></tr>
<tr><td><code id="sim_single_trial_+3A_prior">prior</code></td>
<td>
<p>hyperparameters of prior beta distribution.
Beta(0.5, 0.5) is default</p>
</td></tr>
<tr><td><code id="sim_single_trial_+3A_s">S</code></td>
<td>
<p>number of samples, default is 5000</p>
</td></tr>
<tr><td><code id="sim_single_trial_+3A_theta">theta</code></td>
<td>
<p>The target posterior probability. e.g. Efficacy decision if
P(p1 &gt; p0) &gt; theta for the two-sample case with greater direction.
Default is 0.95. Can be a vector if interest is in selecting from among a
variety of thresholds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a tibble with pp_threshold (i.e. theta, the target posterior
probability), number of responses, sample size,
posterior probability, and posterior predictive probability at each
look
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)

# Setting S = 100 for speed, in practice you would want a much larger sample

# One-sample case
sim_single_trial(
  p = 0.3, 
  n = c(5, 10),  
  p0 = 0.1, 
  N = 25, 
  S = 100
  )

# Two-sample case 
sim_single_trial(
  p = c(0.1, 0.3), 
  n = cbind(c(5, 10), c(5, 10)), 
  p0 = NULL, 
  N = c(50, 50), 
  delta = 0, 
  S = 100
  )
  
</code></pre>

<hr>
<h2 id='two_sample_cal_tbl'>Output from a two-sample call to <code>calibrate_thresholds</code></h2><span id='topic+two_sample_cal_tbl'></span>

<h3>Description</h3>

<p>This .rda file contains output from a two-sample call to
<code>calibrate_thresholds()</code>.
See the vignette titled &quot;Two-sample randomized trial&quot; for a description of
the input parameters used, or run
<code>two_sample_cal_tbl$inputs</code>
to see a list of the original function inputs. For use in testing
functions and in vignettes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(two_sample_cal_tbl)
</code></pre>


<h3>Format</h3>

<p>A list containing a
</p>

<ol>
<li><p> a tibble 'res_summary' containing the posterior probability threshold
(pp_threshold); the predictive probability threshold (ppp_threshold);
the mean sample size under the null (mean_n0_null and mean_n1_null)
and alternative (mean_n0_alt and mean_n1_alt) response rates;
the proportion of positive trials under the null (prop_pos_null)
and alternative (prop_pos_alt) response rates; and the proportion of trials
stopped under the null (prop_stopped_null) and alternative (prop_stopped_alt)
response rates.
</p>
</li>
<li><p> 'call_list' containing the original function call
</p>
</li>
<li><p> 'inputs' a list containing the inputs to the
original function call
</p>
</li></ol>


<hr>
<h2 id='two_sample_decision_tbl'>Output from a two-sample call to <code>calc_decision_rules</code></h2><span id='topic+two_sample_decision_tbl'></span>

<h3>Description</h3>

<p>This .rda file contains output from a two-sample call to
<code>calc_decision_rules()</code>.
See the vignette titled &quot;Two-sample randomized trail&quot; for a description of
the input parameters used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(two_sample_decision_tbl)
</code></pre>


<h3>Format</h3>

<p>A tibble containing n, the number of patients enrolled at each
futility monitoring point; r, the number of responses at which we would
stop the trial at a given look if the number of observed responses is &lt;=r,
or at the end of the trial the treatment is considered promising if the
number of observed responses is &gt;r; and ppp, the predictive probability at
each given look
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
