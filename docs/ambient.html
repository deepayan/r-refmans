<!DOCTYPE html><html lang="en"><head><title>Help for package ambient</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ambient}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ambient-package'><p>ambient: A Generator of Multidimensional Noise</p></a></li>
<li><a href='#billow'><p>Billow (cloud-like, lumpy) fractal</p></a></li>
<li><a href='#clamped'><p>Clamped fractal</p></a></li>
<li><a href='#curl_noise'><p>Generate curl noise</p></a></li>
<li><a href='#fbm'><p>Fractional Brownian Motion fractal</p></a></li>
<li><a href='#fracture'><p>Create fractals of a noise or pattern</p></a></li>
<li><a href='#gen_checkerboard'><p>Generate a checkerboard pattern</p></a></li>
<li><a href='#gen_spheres'><p>Generate a pattern of concentric spheres</p></a></li>
<li><a href='#gen_waves'><p>Generate a wave pattern</p></a></li>
<li><a href='#gradient_noise'><p>Calculate the gradient of a scalar field</p></a></li>
<li><a href='#long_grid'><p>Create a long format grid</p></a></li>
<li><a href='#modifications'><p>Simply value modifications</p></a></li>
<li><a href='#noise_blue'><p>Blue noise generator</p></a></li>
<li><a href='#noise_cubic'><p>Cubic noise generator</p></a></li>
<li><a href='#noise_perlin'><p>Perlin noise generator</p></a></li>
<li><a href='#noise_simplex'><p>Simplex noise generator</p></a></li>
<li><a href='#noise_value'><p>Value noise generator</p></a></li>
<li><a href='#noise_white'><p>White noise generator</p></a></li>
<li><a href='#noise_worley'><p>Worley (cell) noise generator</p></a></li>
<li><a href='#ridged'><p>Ridged-Multi fractal</p></a></li>
<li><a href='#trans_affine'><p>Apply linear transformation to a long_grid</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Generator of Multidimensional Noise</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Lin Pedersen &lt;thomasp85@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Generation of natural looking noise has many application within 
    simulation, procedural generation, and art, to name a few. The 'ambient' 
    package provides an interface to the 'FastNoise' C++ library and allows for
    efficient generation of perlin, simplex, worley, cubic, value, and white 
    noise with optional perturbation in either 2, 3, or 4 (in case of simplex and
    white noise) dimensions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++11</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>rlang, grDevices, graphics, stats</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>cpp11 (&ge; 0.4.2)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://ambient.data-imaginist.com">https://ambient.data-imaginist.com</a>,
<a href="https://github.com/thomasp85/ambient">https://github.com/thomasp85/ambient</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/thomasp85/ambient/issues">https://github.com/thomasp85/ambient/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-05 07:17:52 UTC; thomas</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Lin Pedersen
    <a href="https://orcid.org/0000-0002-5147-4711"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre, aut],
  Jordan Peck [aut] (Developer of FastNoise)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-08 11:12:56 UTC</td>
</tr>
</table>
<hr>
<h2 id='ambient-package'>ambient: A Generator of Multidimensional Noise</h2><span id='topic+ambient'></span><span id='topic+ambient-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Generation of natural looking noise has many application within simulation, procedural generation, and art, to name a few. The 'ambient' package provides an interface to the 'FastNoise' C++ library and allows for efficient generation of perlin, simplex, worley, cubic, value, and white noise with optional perturbation in either 2, 3, or 4 (in case of simplex and white noise) dimensions.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Thomas Lin Pedersen <a href="mailto:thomasp85@gmail.com">thomasp85@gmail.com</a> (<a href="https://orcid.org/0000-0002-5147-4711">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Jordan Peck (Developer of FastNoise)
</p>
</li></ul>



<h3>References</h3>

<p><a href="https://github.com/Auburn/FastNoiseLite">https://github.com/Auburn/FastNoiseLite</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://ambient.data-imaginist.com">https://ambient.data-imaginist.com</a>
</p>
</li>
<li> <p><a href="https://github.com/thomasp85/ambient">https://github.com/thomasp85/ambient</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/thomasp85/ambient/issues">https://github.com/thomasp85/ambient/issues</a>
</p>
</li></ul>


<hr>
<h2 id='billow'>Billow (cloud-like, lumpy) fractal</h2><span id='topic+billow'></span>

<h3>Description</h3>

<p>The billow fractal is a slight modification of the <code><a href="#topic+fbm">fbm()</a></code> fractal. Before
adding the new layer onto the last, the new layer is modified by taking the
absolute value, multiplying by 2, and subtracting one. The result is that the
new value will not contain negative values and so will always add on top of
the old values. This function is intended to be used in conjunction with
<code><a href="#topic+fracture">fracture()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>billow(base, new, strength, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="billow_+3A_base">base</code></td>
<td>
<p>The prior values to modify</p>
</td></tr>
<tr><td><code id="billow_+3A_new">new</code></td>
<td>
<p>The new values to modify <code>base</code> with</p>
</td></tr>
<tr><td><code id="billow_+3A_strength">strength</code></td>
<td>
<p>A value to modify <code>new</code> with before applying it to <code>base</code></p>
</td></tr>
<tr><td><code id="billow_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other Fractal functions: 
<code><a href="#topic+clamped">clamped</a>()</code>,
<code><a href="#topic+fbm">fbm</a>()</code>,
<code><a href="#topic+ridged">ridged</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grid &lt;- long_grid(seq(1, 10, length.out = 1000), seq(1, 10, length.out = 1000))

grid$simplex &lt;- fracture(gen_simplex, billow, octaves = 8, x = grid$x,
                         y = grid$y)
plot(grid, simplex)

</code></pre>

<hr>
<h2 id='clamped'>Clamped fractal</h2><span id='topic+clamped'></span>

<h3>Description</h3>

<p>This fractal is a slight variation of <code><a href="#topic+fbm">fbm()</a></code> fractal. Before adding the new
octave to the cumulated values it will clamp it between a minimum and maximum
value. This function is intended to be used in conjunction with <code><a href="#topic+fracture">fracture()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clamped(base, new, strength, min = 0, max = Inf, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clamped_+3A_base">base</code></td>
<td>
<p>The prior values to modify</p>
</td></tr>
<tr><td><code id="clamped_+3A_new">new</code></td>
<td>
<p>The new values to modify <code>base</code> with</p>
</td></tr>
<tr><td><code id="clamped_+3A_strength">strength</code></td>
<td>
<p>A value to modify <code>new</code> with before applying it to <code>base</code></p>
</td></tr>
<tr><td><code id="clamped_+3A_min">min</code>, <code id="clamped_+3A_max">max</code></td>
<td>
<p>The upper and lower bounds of the noise values</p>
</td></tr>
<tr><td><code id="clamped_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other Fractal functions: 
<code><a href="#topic+billow">billow</a>()</code>,
<code><a href="#topic+fbm">fbm</a>()</code>,
<code><a href="#topic+ridged">ridged</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grid &lt;- long_grid(seq(1, 10, length.out = 1000), seq(1, 10, length.out = 1000))

grid$simplex &lt;- fracture(gen_simplex, clamped, octaves = 8, x = grid$x,
                         y = grid$y)
plot(grid, simplex)

</code></pre>

<hr>
<h2 id='curl_noise'>Generate curl noise</h2><span id='topic+curl_noise'></span>

<h3>Description</h3>

<p>One of the use cases for fractal noise is to simulate natural phenomena.
perlin/simplex noise are e.g. often used to create flow fields, but this can
be problematic as they are not divergence-free (particles will concentrate at
sinks/gutters in the field). An approach to avoid this is to take the curl of
a field instead. The curl operator is ensured to produce divergence-free
output, when supplied with continuous fields such as those generated by
simplex and perlin noise. The end result is a field that is incompressible,
thus modelling fluid dynamics quite well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curl_noise(
  generator,
  x,
  y,
  z = NULL,
  ...,
  seed = NULL,
  delta = NULL,
  mod = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="curl_noise_+3A_generator">generator</code></td>
<td>
<p>The noise generating function, such as <a href="#topic+gen_simplex">gen_simplex</a>, or
<code><a href="#topic+fracture">fracture()</a></code></p>
</td></tr>
<tr><td><code id="curl_noise_+3A_x">x</code>, <code id="curl_noise_+3A_y">y</code>, <code id="curl_noise_+3A_z">z</code></td>
<td>
<p>The coordinates to generate the curl for as unquoted expressions</p>
</td></tr>
<tr><td><code id="curl_noise_+3A_...">...</code></td>
<td>
<p>Further arguments to <code>generator</code></p>
</td></tr>
<tr><td><code id="curl_noise_+3A_seed">seed</code></td>
<td>
<p>A seed for the generator. For 2D curl the seed is a single
integer and for 3D curl it must be a vector of 3 integers. If <code>NULL</code> the
seeds will be random.</p>
</td></tr>
<tr><td><code id="curl_noise_+3A_delta">delta</code></td>
<td>
<p>The offset to use for the partial derivative of the <code>generator</code>.
If <code>NULL</code>, it will be set as 1e-4 of the largest range of the dimensions.</p>
</td></tr>
<tr><td><code id="curl_noise_+3A_mod">mod</code></td>
<td>
<p>A modification function taking the coordinates along with the
output of the <code>generator</code> call and allow modifications of it prior to
calculating the curl. The function will get the coordinates as well as a
<code>value</code> holding the generator output for each coordinate. If the curl is
requested in 2D the value will be a numeric vector and <code>mod()</code> should return
a numeric vector of the same length. IF the curl is requested in 3D the value
is a list of three numeric vectors (x, y, and z) and <code>mod()</code> should return a
list of three vectors of the same length. Passing NULL will use the generator
values unmodified.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Bridson, Robert. Hourihan, Jim. Nordenstam, Marcus (2007). <em>Curl-noise for procedural fluid flow</em>.
ACM Transactions on Graphics 26(3): 46. doi:10.1145/1275808.1276435.
</p>


<h3>See Also</h3>

<p>Other derived values: 
<code><a href="#topic+gradient_noise">gradient_noise</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grid &lt;- long_grid(seq(0, 1, l = 100), seq(0, 1, l = 100))

# Use one of the generators
grid$curl &lt;- curl_noise(gen_simplex, x = grid$x, y = grid$y)
plot(grid$x, grid$y, type = 'n')
segments(grid$x, grid$y, grid$x + grid$curl$x / 100, grid$y + grid$curl$y / 100)

# If the curl of fractal noise is needed, pass in `fracture` instead
grid$curl &lt;- curl_noise(fracture, x = grid$x, y = grid$y, noise = gen_simplex,
                        fractal = fbm, octaves = 4)
plot(grid$x, grid$y, type = 'n')
segments(grid$x, grid$y, grid$x + grid$curl$x / 500, grid$y + grid$curl$y / 500)

</code></pre>

<hr>
<h2 id='fbm'>Fractional Brownian Motion fractal</h2><span id='topic+fbm'></span>

<h3>Description</h3>

<p>This is the archetypal fractal used when generating perlin noise. It works
simply by adding successive values together to create a final value. As the
succesive values are often calculated at increasing frequencies and the
strength is often decreasing, it will create the impression of ever-smaller
details as you zoom in. This function is intended to be used in conjunction
with <code><a href="#topic+fracture">fracture()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fbm(base, new, strength, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fbm_+3A_base">base</code></td>
<td>
<p>The prior values to modify</p>
</td></tr>
<tr><td><code id="fbm_+3A_new">new</code></td>
<td>
<p>The new values to modify <code>base</code> with</p>
</td></tr>
<tr><td><code id="fbm_+3A_strength">strength</code></td>
<td>
<p>A value to modify <code>new</code> with before applying it to <code>base</code></p>
</td></tr>
<tr><td><code id="fbm_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other Fractal functions: 
<code><a href="#topic+billow">billow</a>()</code>,
<code><a href="#topic+clamped">clamped</a>()</code>,
<code><a href="#topic+ridged">ridged</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grid &lt;- long_grid(seq(1, 10, length.out = 1000), seq(1, 10, length.out = 1000))

grid$simplex &lt;- fracture(gen_simplex, fbm, octaves = 8, x = grid$x, y = grid$y)
plot(grid, simplex)

</code></pre>

<hr>
<h2 id='fracture'>Create fractals of a noise or pattern</h2><span id='topic+fracture'></span>

<h3>Description</h3>

<p>This function allows you to create fractals of a given noise or pattern
generator by calculating it repeatedly at changing frequency and combining
the results based on a fractal function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fracture(
  noise,
  fractal,
  octaves,
  gain = ~./2,
  frequency = ~. * 2,
  seed = NULL,
  ...,
  fractal_args = list(),
  gain_init = 1,
  freq_init = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fracture_+3A_noise">noise</code></td>
<td>
<p>The noise function to create a fractal from. Must have a
<code>frequency</code> argument.</p>
</td></tr>
<tr><td><code id="fracture_+3A_fractal">fractal</code></td>
<td>
<p>The fractal function to combine the generated values with. Can
be one of the provided ones or a self-made function. If created by hand it
must have the following arguments:
</p>

<ul>
<li> <p><code>base</code>: The current noise values
</p>
</li>
<li> <p><code>new</code>: The new noise values to combine with <code>base</code>
</p>
</li>
<li> <p><code>strength</code>: The value from <code>gain</code> corresponding to the index of <code>new</code>
</p>
</li>
<li> <p><code>octave</code>: The index of <code>new</code>
</p>
</li></ul>

<p>And must return a numeric vector of the same length as <code>new</code></p>
</td></tr>
<tr><td><code id="fracture_+3A_octaves">octaves</code></td>
<td>
<p>The number of generated values to combine</p>
</td></tr>
<tr><td><code id="fracture_+3A_gain">gain</code></td>
<td>
<p>The intensity of the generated values at each octave. The
interpretation of this is up to the fractal function. Usually the intensity
will gradually fall as the frequency increases. Can either be a vector of
values or a (lambda) function that returns a new value based on the prior,
e.g. <code>~ . / 2</code>. The default is often a good starting point though e.g.
<code><a href="#topic+ridged">ridged()</a></code> fractal has been designed with a special gain function.</p>
</td></tr>
<tr><td><code id="fracture_+3A_frequency">frequency</code></td>
<td>
<p>The frequency to use at each octave. Can either be a vector
of values or a function that returns a new value based on the prior. See
<code>gain</code>.</p>
</td></tr>
<tr><td><code id="fracture_+3A_seed">seed</code></td>
<td>
<p>A seed for the noise generator. Will be expanded to the number of
octaves so each gets a unique seed.</p>
</td></tr>
<tr><td><code id="fracture_+3A_...">...</code></td>
<td>
<p>arguments to pass on to <code>generator</code></p>
</td></tr>
<tr><td><code id="fracture_+3A_fractal_args">fractal_args</code></td>
<td>
<p>Additional arguments to <code>fractal</code> as a named list</p>
</td></tr>
<tr><td><code id="fracture_+3A_gain_init">gain_init</code>, <code id="fracture_+3A_freq_init">freq_init</code></td>
<td>
<p>The gain and frequency for the first octave if
<code>gain</code> and/or <code>frequency</code> are given as a function.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>ambient comes with a range of build in fractal functions: <code><a href="#topic+fbm">fbm()</a></code>,
<code><a href="#topic+billow">billow()</a></code>, <code><a href="#topic+ridged">ridged()</a></code>, <code><a href="#topic+clamped">clamped()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grid &lt;- long_grid(seq(1, 10, length.out = 1000), seq(1, 10, length.out = 1000))

# When noise is generated by it's own it doesn't have fractal properties
grid$clean_perlin &lt;- gen_perlin(grid$x, grid$y)
plot(grid, clean_perlin)

# Use fracture to apply a fractal algorithm to the noise
grid$fractal_perlin &lt;- fracture(gen_perlin, fbm, octaves = 8,
                                x = grid$x, y = grid$y)
plot(grid, fractal_perlin)

</code></pre>

<hr>
<h2 id='gen_checkerboard'>Generate a checkerboard pattern</h2><span id='topic+gen_checkerboard'></span>

<h3>Description</h3>

<p>This generator supplies 0 or 1 value depending on the provided coordinates
position on a checkerboard. The <code>frequency</code> determines the number of squares
per unit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_checkerboard(x, y = NULL, z = NULL, t = NULL, frequency = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gen_checkerboard_+3A_x">x</code>, <code id="gen_checkerboard_+3A_y">y</code>, <code id="gen_checkerboard_+3A_z">z</code>, <code id="gen_checkerboard_+3A_t">t</code></td>
<td>
<p>The coordinates to get pattern from</p>
</td></tr>
<tr><td><code id="gen_checkerboard_+3A_frequency">frequency</code></td>
<td>
<p>The frequency of the generator</p>
</td></tr>
<tr><td><code id="gen_checkerboard_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector
</p>


<h3>See Also</h3>

<p>Other Pattern generators: 
<code><a href="#topic+gen_spheres">gen_spheres</a>()</code>,
<code><a href="#topic+gen_waves">gen_waves</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grid &lt;- long_grid(seq(1, 10, length.out = 1000), seq(1, 10, length.out = 1000))
grid$chess &lt;- gen_checkerboard(grid$x, grid$y)

plot(grid, chess)

</code></pre>

<hr>
<h2 id='gen_spheres'>Generate a pattern of concentric spheres</h2><span id='topic+gen_spheres'></span>

<h3>Description</h3>

<p>This generator creates a pattern of concentric circles centered at 0.
Depending on how many dimensions you supply it can be used to generate
cylinders and circles as well. The output value is the shortest distance to
the nearest sphere normalised to be between -1 and 1. The frequency
determines the radius multiplier for each unit sphere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_spheres(x, y = NULL, z = NULL, t = NULL, frequency = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gen_spheres_+3A_x">x</code>, <code id="gen_spheres_+3A_y">y</code>, <code id="gen_spheres_+3A_z">z</code>, <code id="gen_spheres_+3A_t">t</code></td>
<td>
<p>The coordinates to get pattern from</p>
</td></tr>
<tr><td><code id="gen_spheres_+3A_frequency">frequency</code></td>
<td>
<p>The frequency of the generator</p>
</td></tr>
<tr><td><code id="gen_spheres_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector
</p>


<h3>See Also</h3>

<p>Other Pattern generators: 
<code><a href="#topic+gen_checkerboard">gen_checkerboard</a>()</code>,
<code><a href="#topic+gen_waves">gen_waves</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grid &lt;- long_grid(seq(1, 10, length.out = 1000), seq(1, 10, length.out = 1000))
grid$circles &lt;- gen_spheres(grid$x, grid$y)
grid$cylinders &lt;- gen_spheres(grid$x)

plot(grid, circles)
plot(grid, cylinders)

</code></pre>

<hr>
<h2 id='gen_waves'>Generate a wave pattern</h2><span id='topic+gen_waves'></span>

<h3>Description</h3>

<p>This generator generates multidimensional waves based on <a href="base.html#topic+cos">cos</a> to the
distance to the center. This means that you can create ripple waves or
parallel waves depending on how many dimensions you provide. The output is
scaled between -1 and 1 and the frequency determines the number of waves per
unit. The result is much like <code><a href="#topic+gen_spheres">gen_spheres()</a></code> but has smooth transitions at
each extreme.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_waves(x, y = NULL, z = NULL, t = NULL, frequency = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gen_waves_+3A_x">x</code>, <code id="gen_waves_+3A_y">y</code>, <code id="gen_waves_+3A_z">z</code>, <code id="gen_waves_+3A_t">t</code></td>
<td>
<p>The coordinates to get pattern from</p>
</td></tr>
<tr><td><code id="gen_waves_+3A_frequency">frequency</code></td>
<td>
<p>The frequency of the generator</p>
</td></tr>
<tr><td><code id="gen_waves_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector
</p>


<h3>See Also</h3>

<p>Other Pattern generators: 
<code><a href="#topic+gen_checkerboard">gen_checkerboard</a>()</code>,
<code><a href="#topic+gen_spheres">gen_spheres</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grid &lt;- long_grid(seq(1, 10, length.out = 1000), seq(1, 10, length.out = 1000))
grid$ripple &lt;- gen_waves(grid$x, grid$y)
grid$wave &lt;- gen_waves(grid$x)

plot(grid, ripple)
plot(grid, wave)

</code></pre>

<hr>
<h2 id='gradient_noise'>Calculate the gradient of a scalar field</h2><span id='topic+gradient_noise'></span>

<h3>Description</h3>

<p>The gradient of a scalar field such as those generated by the different noise
algorithms in ambient is a vector field encoding the direction to move to get
the strongest increase in value. The vectors generated have the properties of
being perpendicular on the contour line drawn through that point. Take note
that the returned vector field flows upwards, i.e. points toward the steepest
ascend, rather than what is normally expected in a gravitational governed
world.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gradient_noise(
  generator,
  x,
  y,
  z = NULL,
  t = NULL,
  ...,
  seed = NULL,
  delta = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gradient_noise_+3A_generator">generator</code></td>
<td>
<p>The noise generating function, such as <a href="#topic+gen_simplex">gen_simplex</a>, or
<code><a href="#topic+fracture">fracture()</a></code></p>
</td></tr>
<tr><td><code id="gradient_noise_+3A_x">x</code>, <code id="gradient_noise_+3A_y">y</code>, <code id="gradient_noise_+3A_z">z</code>, <code id="gradient_noise_+3A_t">t</code></td>
<td>
<p>The coordinates to generate the gradient for as unquoted expressions</p>
</td></tr>
<tr><td><code id="gradient_noise_+3A_...">...</code></td>
<td>
<p>Further arguments to <code>generator</code></p>
</td></tr>
<tr><td><code id="gradient_noise_+3A_seed">seed</code></td>
<td>
<p>A seed for the generator.</p>
</td></tr>
<tr><td><code id="gradient_noise_+3A_delta">delta</code></td>
<td>
<p>The offset to use for the partial derivative of the <code>generator</code>.
If <code>NULL</code>, it will be set as 1e-4 of the largest range of the dimensions.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other derived values: 
<code><a href="#topic+curl_noise">curl_noise</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grid &lt;- long_grid(seq(0, 1, l = 100), seq(0, 1, l = 100))

# Use one of the generators
grid$gradient &lt;- gradient_noise(gen_simplex, x = grid$x, y = grid$y)
plot(grid$x, grid$y, type = 'n')
segments(grid$x, grid$y, grid$x + grid$gradient$x / 100, grid$y + grid$gradient$y / 100)

</code></pre>

<hr>
<h2 id='long_grid'>Create a long format grid</h2><span id='topic+long_grid'></span><span id='topic+grid_cell'></span><span id='topic+as.array.long_grid'></span><span id='topic+as.matrix.long_grid'></span><span id='topic+as.raster.long_grid'></span><span id='topic+slice_at'></span>

<h3>Description</h3>

<p>This function creates a 1-4 dimensional grid in long format, with the cell
positions encoded in the <code>x</code>, <code>y</code>, <code>z</code>, and <code>t</code> columns. A long_cell object
is the base class for the tidy interface to ambient, and allows a very
flexible approach to pattern generation at the expense of slightly lower
performance than the <code style="white-space: pre;">&#8288;noise_*&#8288;</code> functions that maps directly to the underlying
C++ code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>long_grid(x, y = NULL, z = NULL, t = NULL)

grid_cell(grid, dim, ...)

## S3 method for class 'long_grid'
as.array(x, value, ...)

## S3 method for class 'long_grid'
as.matrix(x, value, ...)

## S3 method for class 'long_grid'
as.raster(x, value, ...)

slice_at(grid, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="long_grid_+3A_x">x</code>, <code id="long_grid_+3A_y">y</code>, <code id="long_grid_+3A_z">z</code>, <code id="long_grid_+3A_t">t</code></td>
<td>
<p>For <code>long_grid()</code> vectors of grid cell positions for each
dimension. The final dimensionality of the object is determined by how many
arguments are given. For <code>slice_at()</code> an integer defining the index at the
given dimension to extract.</p>
</td></tr>
<tr><td><code id="long_grid_+3A_grid">grid</code></td>
<td>
<p>A long_grid object</p>
</td></tr>
<tr><td><code id="long_grid_+3A_dim">dim</code></td>
<td>
<p>The dimension to get the cell index at, either as an integer or
string.</p>
</td></tr>
<tr><td><code id="long_grid_+3A_...">...</code></td>
<td>
<p>Arguments passed on to methods (ignored)</p>
</td></tr>
<tr><td><code id="long_grid_+3A_value">value</code></td>
<td>
<p>The unquoted value to use for filling out the array/matrix</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>grid &lt;- long_grid(1:10, seq(0, 1, length = 6), c(3, 6))

# Get which row each cell belongs to
grid_cell(grid, 2) # equivalent to grid_cell(grid, 'y')

# Convert the long_grid to an array and fill with the x position
as.array(grid, x)

# Extract the first column
slice_at(grid, x = 1)

# Convert the first column to a matrix filled with y position
as.matrix(slice_at(grid, x = 1), y)

</code></pre>

<hr>
<h2 id='modifications'>Simply value modifications</h2><span id='topic+modifications'></span><span id='topic+blend'></span><span id='topic+normalise'></span><span id='topic+normalize'></span><span id='topic+cap'></span>

<h3>Description</h3>

<p>Most modifications of values in a long_grid are quite simple due to the
wealth of vectorised functions avaliable in R. ambient provides a little
selection of handy functions to compliment these
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blend(x, y, mask)

normalise(x, from = range(x), to = c(0, 1))

normalize(x, from = range(x), to = c(0, 1))

cap(x, lower = 0, upper = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modifications_+3A_x">x</code>, <code id="modifications_+3A_y">y</code></td>
<td>
<p>Values to modify</p>
</td></tr>
<tr><td><code id="modifications_+3A_mask">mask</code></td>
<td>
<p>A vector of the same length as <code>x</code> and <code>y</code>. Assumed to be between
0 and 1 (values outside of this range is capped). The closer to 1 the more of
<code>x</code> will be used and the closer to 0 the more of <code>y</code> will be used</p>
</td></tr>
<tr><td><code id="modifications_+3A_from">from</code></td>
<td>
<p>The range of <code>x</code> to use for normalisation</p>
</td></tr>
<tr><td><code id="modifications_+3A_to">to</code></td>
<td>
<p>The output domain to normalise to</p>
</td></tr>
<tr><td><code id="modifications_+3A_lower">lower</code>, <code id="modifications_+3A_upper">upper</code></td>
<td>
<p>The lower and upper bounds to cap to</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>grid &lt;- long_grid(seq(1, 10, length.out = 1000), seq(1, 10, length.out = 1000))
grid$chess &lt;- gen_checkerboard(grid$x, grid$y)
grid$noise &lt;- gen_perlin(grid$x, grid$y)
grid$ripple &lt;- gen_waves(grid$x, grid$y)

# Blend two values based on a third
grid$mix &lt;- blend(grid$noise, grid$ripple, grid$chess)
plot(grid, mix)

# Cap values between 0 and 1
plot(grid, cap(noise))

</code></pre>

<hr>
<h2 id='noise_blue'>Blue noise generator</h2><span id='topic+noise_blue'></span>

<h3>Description</h3>

<p>Blue noise is a form of noise that has weak low-frequency. This means that
it is devoid of larger structures and can be blurred to an even gray. Blue
noise in ambient is calculated using the popular Void-and-cluster method
developed by Ulichney. Calculating blue noise is much more computationally
expensive than e.g. white noise so ambient does not provide a <code>gen_blue()</code>
generator, only the <code>noise_blue()</code> texture function. Computation time
increases linearly with the number of pixels in the texture and can get
prohibitly long very soon. However, blue noise is tile-able so a good
suggestion is to try tiling e.g. a 64x64 texture to the desired dimensions
and see if that suffices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noise_blue(dim, sd = 10, seed_frac = 0.1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="noise_blue_+3A_dim">dim</code></td>
<td>
<p>The dimensions (height, width, (and depth, (and time))) of the
noise to be generated. The length determines the dimensionality of the noise.</p>
</td></tr>
<tr><td><code id="noise_blue_+3A_sd">sd</code></td>
<td>
<p>The standard deviation of the gaussian filter to apply during the
search for clusters and voids.</p>
</td></tr>
<tr><td><code id="noise_blue_+3A_seed_frac">seed_frac</code></td>
<td>
<p>The fraction of pixels to seed the algorithm with during
start</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>noise_white()</code> a vector if <code>length(dim) == 1</code>, matrix if
<code>length(dim) == 2</code> or an array if <code>length(dim) &gt;= 3</code>.
</p>


<h3>References</h3>

<p>R. A. Ulichney (1993). <em>Void-and-cluster method for dither array generation</em>. Proc. SPIE 1913, Human Vision, Visual Processing, and Digital Display IV
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Basic use
noise &lt;- noise_blue(c(64, 64))

plot(as.raster(normalise(noise)))

</code></pre>

<hr>
<h2 id='noise_cubic'>Cubic noise generator</h2><span id='topic+noise_cubic'></span><span id='topic+gen_cubic'></span>

<h3>Description</h3>

<p>Cubic noise is a pretty simple alternative to perlin and simplex noise. In
essence it takes a low resolution white noise and scales it up using cubic
interpolation. This approach means that while cubic noise is smooth, it is
much more random than perlin and simplex noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noise_cubic(
  dim,
  frequency = 0.01,
  fractal = "fbm",
  octaves = 3,
  lacunarity = 2,
  gain = 0.5,
  pertubation = "none",
  pertubation_amplitude = 1
)

gen_cubic(x, y = NULL, z = NULL, frequency = 1, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="noise_cubic_+3A_dim">dim</code></td>
<td>
<p>The dimensions (height, width, (and depth)) of the noise to be
generated. The length determines the dimensionality of the noise.</p>
</td></tr>
<tr><td><code id="noise_cubic_+3A_frequency">frequency</code></td>
<td>
<p>Determines the granularity of the features in the noise.</p>
</td></tr>
<tr><td><code id="noise_cubic_+3A_fractal">fractal</code></td>
<td>
<p>The fractal type to use. Either <code>'none'</code>, <code>'fbm'</code> (default),
<code>'billow'</code>, or <code>'rigid-multi'</code>. It is suggested that you experiment with the
different types to get a feel for how they behaves.</p>
</td></tr>
<tr><td><code id="noise_cubic_+3A_octaves">octaves</code></td>
<td>
<p>The number of noise layers used to create the fractal noise.
Ignored if <code>fractal = 'none'</code>. Defaults to <code>3</code>.</p>
</td></tr>
<tr><td><code id="noise_cubic_+3A_lacunarity">lacunarity</code></td>
<td>
<p>The frequency multiplier between successive noise layers
when building fractal noise. Ignored if <code>fractal = 'none'</code>. Defaults to <code>2</code>.</p>
</td></tr>
<tr><td><code id="noise_cubic_+3A_gain">gain</code></td>
<td>
<p>The relative strength between successive noise layers when
building fractal noise. Ignored if <code>fractal = 'none'</code>. Defaults to <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="noise_cubic_+3A_pertubation">pertubation</code></td>
<td>
<p>The pertubation to use. Either <code>'none'</code> (default),
<code>'normal'</code>, or <code>'fractal'</code>. Defines the displacement (warping) of the noise,
with <code>'normal'</code> giving a smooth warping and <code>'fractal'</code> giving a more eratic
warping.</p>
</td></tr>
<tr><td><code id="noise_cubic_+3A_pertubation_amplitude">pertubation_amplitude</code></td>
<td>
<p>The maximal pertubation distance from the
origin. Ignored if <code>pertubation = 'none'</code>. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="noise_cubic_+3A_x">x</code>, <code id="noise_cubic_+3A_y">y</code>, <code id="noise_cubic_+3A_z">z</code></td>
<td>
<p>Coordinates to get noise value from</p>
</td></tr>
<tr><td><code id="noise_cubic_+3A_seed">seed</code></td>
<td>
<p>The seed to use for the noise. If <code>NULL</code> a random seed will be
used</p>
</td></tr>
<tr><td><code id="noise_cubic_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>noise_cubic()</code> a matrix if <code>length(dim) == 2</code> or an array if
<code>length(dim) == 3</code>. For <code>gen_cubic()</code> a numeric vector matching the length of
the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Basic use
noise &lt;- noise_cubic(c(100, 100))

plot(as.raster(normalise(noise)))

# Using the generator
grid &lt;- long_grid(seq(1, 10, length.out = 1000), seq(1, 10, length.out = 1000))
grid$noise &lt;- gen_cubic(grid$x, grid$y)
plot(grid, noise)

</code></pre>

<hr>
<h2 id='noise_perlin'>Perlin noise generator</h2><span id='topic+noise_perlin'></span><span id='topic+gen_perlin'></span>

<h3>Description</h3>

<p>This function generates either 2 or 3 dimensional perlin noise, with optional
pertubation and fractality. Perlin noise is one of the most well known
gradient noise algorithms and have been used extensively as the basis for
generating landscapes and textures, as well as within generative art.
The algorithm was developed by Ken Perlin in 1983.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noise_perlin(
  dim,
  frequency = 0.01,
  interpolator = "quintic",
  fractal = "fbm",
  octaves = 3,
  lacunarity = 2,
  gain = 0.5,
  pertubation = "none",
  pertubation_amplitude = 1
)

gen_perlin(
  x,
  y = NULL,
  z = NULL,
  frequency = 1,
  seed = NULL,
  interpolator = "quintic",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="noise_perlin_+3A_dim">dim</code></td>
<td>
<p>The dimensions (height, width, (and depth)) of the noise to be
generated. The length determines the dimensionality of the noise.</p>
</td></tr>
<tr><td><code id="noise_perlin_+3A_frequency">frequency</code></td>
<td>
<p>Determines the granularity of the features in the noise.</p>
</td></tr>
<tr><td><code id="noise_perlin_+3A_interpolator">interpolator</code></td>
<td>
<p>How should values between sampled points be calculated?
Either <code>'linear'</code>, <code>'hermite'</code>, or <code>'quintic'</code> (default), ranging from lowest
to highest quality.</p>
</td></tr>
<tr><td><code id="noise_perlin_+3A_fractal">fractal</code></td>
<td>
<p>The fractal type to use. Either <code>'none'</code>, <code>'fbm'</code> (default),
<code>'billow'</code>, or <code>'rigid-multi'</code>. It is suggested that you experiment with the
different types to get a feel for how they behaves.</p>
</td></tr>
<tr><td><code id="noise_perlin_+3A_octaves">octaves</code></td>
<td>
<p>The number of noise layers used to create the fractal noise.
Ignored if <code>fractal = 'none'</code>. Defaults to <code>3</code>.</p>
</td></tr>
<tr><td><code id="noise_perlin_+3A_lacunarity">lacunarity</code></td>
<td>
<p>The frequency multiplier between successive noise layers
when building fractal noise. Ignored if <code>fractal = 'none'</code>. Defaults to <code>2</code>.</p>
</td></tr>
<tr><td><code id="noise_perlin_+3A_gain">gain</code></td>
<td>
<p>The relative strength between successive noise layers when
building fractal noise. Ignored if <code>fractal = 'none'</code>. Defaults to <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="noise_perlin_+3A_pertubation">pertubation</code></td>
<td>
<p>The pertubation to use. Either <code>'none'</code> (default),
<code>'normal'</code>, or <code>'fractal'</code>. Defines the displacement (warping) of the noise,
with <code>'normal'</code> giving a smooth warping and <code>'fractal'</code> giving a more eratic
warping.</p>
</td></tr>
<tr><td><code id="noise_perlin_+3A_pertubation_amplitude">pertubation_amplitude</code></td>
<td>
<p>The maximal pertubation distance from the
origin. Ignored if <code>pertubation = 'none'</code>. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="noise_perlin_+3A_x">x</code>, <code id="noise_perlin_+3A_y">y</code>, <code id="noise_perlin_+3A_z">z</code></td>
<td>
<p>Coordinates to get noise value from</p>
</td></tr>
<tr><td><code id="noise_perlin_+3A_seed">seed</code></td>
<td>
<p>The seed to use for the noise. If <code>NULL</code> a random seed will be
used</p>
</td></tr>
<tr><td><code id="noise_perlin_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>noise_perlin()</code> a matrix if <code>length(dim) == 2</code> or an array if
<code>length(dim) == 3</code>. For <code>gen_perlin()</code> a numeric vector matching the length of
the input.
</p>


<h3>References</h3>

<p>Perlin, Ken (1985). <em>An Image Synthesizer</em>. SIGGRAPH Comput. Graph. 19
(0097-8930): 287–296. doi:10.1145/325165.325247.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Basic use
noise &lt;- noise_perlin(c(100, 100))

plot(as.raster(normalise(noise)))

# Using the generator
grid &lt;- long_grid(seq(1, 10, length.out = 1000), seq(1, 10, length.out = 1000))
grid$noise &lt;- gen_perlin(grid$x, grid$y)
plot(grid, noise)

</code></pre>

<hr>
<h2 id='noise_simplex'>Simplex noise generator</h2><span id='topic+noise_simplex'></span><span id='topic+gen_simplex'></span>

<h3>Description</h3>

<p>Simplex noise has been developed by Ken Perlin, the inventor of perlin noise,
in order to address some of the shortcomings he saw in perlin noise. Compared
to perlin noise, simplex noise has lower computational complexity, making it
feasable for dimensions above 3 and has no directional artifacts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noise_simplex(
  dim,
  frequency = 0.01,
  interpolator = "quintic",
  fractal = "fbm",
  octaves = 3,
  lacunarity = 2,
  gain = 0.5,
  pertubation = "none",
  pertubation_amplitude = 1
)

gen_simplex(x, y = NULL, z = NULL, t = NULL, frequency = 1, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="noise_simplex_+3A_dim">dim</code></td>
<td>
<p>The dimensions (height, width, (and depth, (and time))) of the
noise to be generated. The length determines the dimensionality of the noise.</p>
</td></tr>
<tr><td><code id="noise_simplex_+3A_frequency">frequency</code></td>
<td>
<p>Determines the granularity of the features in the noise.</p>
</td></tr>
<tr><td><code id="noise_simplex_+3A_interpolator">interpolator</code></td>
<td>
<p>How should values between sampled points be calculated?
Either <code>'linear'</code>, <code>'hermite'</code>, or <code>'quintic'</code> (default), ranging from lowest
to highest quality.</p>
</td></tr>
<tr><td><code id="noise_simplex_+3A_fractal">fractal</code></td>
<td>
<p>The fractal type to use. Either <code>'none'</code>, <code>'fbm'</code> (default),
<code>'billow'</code>, or <code>'rigid-multi'</code>. It is suggested that you experiment with the
different types to get a feel for how they behaves.</p>
</td></tr>
<tr><td><code id="noise_simplex_+3A_octaves">octaves</code></td>
<td>
<p>The number of noise layers used to create the fractal noise.
Ignored if <code>fractal = 'none'</code>. Defaults to <code>3</code>.</p>
</td></tr>
<tr><td><code id="noise_simplex_+3A_lacunarity">lacunarity</code></td>
<td>
<p>The frequency multiplier between successive noise layers
when building fractal noise. Ignored if <code>fractal = 'none'</code>. Defaults to <code>2</code>.</p>
</td></tr>
<tr><td><code id="noise_simplex_+3A_gain">gain</code></td>
<td>
<p>The relative strength between successive noise layers when
building fractal noise. Ignored if <code>fractal = 'none'</code>. Defaults to <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="noise_simplex_+3A_pertubation">pertubation</code></td>
<td>
<p>The pertubation to use. Either <code>'none'</code> (default),
<code>'normal'</code>, or <code>'fractal'</code>. Defines the displacement (warping) of the noise,
with <code>'normal'</code> giving a smooth warping and <code>'fractal'</code> giving a more eratic
warping.</p>
</td></tr>
<tr><td><code id="noise_simplex_+3A_pertubation_amplitude">pertubation_amplitude</code></td>
<td>
<p>The maximal pertubation distance from the
origin. Ignored if <code>pertubation = 'none'</code>. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="noise_simplex_+3A_x">x</code>, <code id="noise_simplex_+3A_y">y</code>, <code id="noise_simplex_+3A_z">z</code>, <code id="noise_simplex_+3A_t">t</code></td>
<td>
<p>Coordinates to get noise value from</p>
</td></tr>
<tr><td><code id="noise_simplex_+3A_seed">seed</code></td>
<td>
<p>The seed to use for the noise. If <code>NULL</code> a random seed will be
used</p>
</td></tr>
<tr><td><code id="noise_simplex_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>noise_simplex()</code> a matrix if <code>length(dim) == 2</code> or an array if
<code>length(dim) &gt;= 3</code>. For <code>gen_simplex()</code> a numeric vector matching the length of
the input.
</p>


<h3>References</h3>

<p>Ken Perlin, (2001) <em>Noise hardware</em>. In Real-Time Shading SIGGRAPH Course Notes, Olano M., (Ed.)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Basic use
noise &lt;- noise_simplex(c(100, 100))

plot(as.raster(normalise(noise)))

# Using the generator
grid &lt;- long_grid(seq(1, 10, length.out = 1000), seq(1, 10, length.out = 1000))
grid$noise &lt;- gen_simplex(grid$x, grid$y)
plot(grid, noise)

</code></pre>

<hr>
<h2 id='noise_value'>Value noise generator</h2><span id='topic+noise_value'></span><span id='topic+gen_value'></span>

<h3>Description</h3>

<p>Value noise is a simpler version of cubic noise that uses linear
interpolation between neighboring grid points. This creates a more distinct
smooth checkerboard pattern than cubic noise, where interpolation takes all
the surrounding grid points into accout.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noise_value(
  dim,
  frequency = 0.01,
  interpolator = "quintic",
  fractal = "fbm",
  octaves = 3,
  lacunarity = 2,
  gain = 0.5,
  pertubation = "none",
  pertubation_amplitude = 1
)

gen_value(
  x,
  y = NULL,
  z = NULL,
  frequency = 1,
  seed = NULL,
  interpolator = "quintic",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="noise_value_+3A_dim">dim</code></td>
<td>
<p>The dimensions (height, width, (and depth)) of the noise to be
generated. The length determines the dimensionality of the noise.</p>
</td></tr>
<tr><td><code id="noise_value_+3A_frequency">frequency</code></td>
<td>
<p>Determines the granularity of the features in the noise.</p>
</td></tr>
<tr><td><code id="noise_value_+3A_interpolator">interpolator</code></td>
<td>
<p>How should values between sampled points be calculated?
Either <code>'linear'</code>, <code>'hermite'</code>, or <code>'quintic'</code> (default), ranging from lowest
to highest quality.</p>
</td></tr>
<tr><td><code id="noise_value_+3A_fractal">fractal</code></td>
<td>
<p>The fractal type to use. Either <code>'none'</code>, <code>'fbm'</code> (default),
<code>'billow'</code>, or <code>'rigid-multi'</code>. It is suggested that you experiment with the
different types to get a feel for how they behaves.</p>
</td></tr>
<tr><td><code id="noise_value_+3A_octaves">octaves</code></td>
<td>
<p>The number of noise layers used to create the fractal noise.
Ignored if <code>fractal = 'none'</code>. Defaults to <code>3</code>.</p>
</td></tr>
<tr><td><code id="noise_value_+3A_lacunarity">lacunarity</code></td>
<td>
<p>The frequency multiplier between successive noise layers
when building fractal noise. Ignored if <code>fractal = 'none'</code>. Defaults to <code>2</code>.</p>
</td></tr>
<tr><td><code id="noise_value_+3A_gain">gain</code></td>
<td>
<p>The relative strength between successive noise layers when
building fractal noise. Ignored if <code>fractal = 'none'</code>. Defaults to <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="noise_value_+3A_pertubation">pertubation</code></td>
<td>
<p>The pertubation to use. Either <code>'none'</code> (default),
<code>'normal'</code>, or <code>'fractal'</code>. Defines the displacement (warping) of the noise,
with <code>'normal'</code> giving a smooth warping and <code>'fractal'</code> giving a more eratic
warping.</p>
</td></tr>
<tr><td><code id="noise_value_+3A_pertubation_amplitude">pertubation_amplitude</code></td>
<td>
<p>The maximal pertubation distance from the
origin. Ignored if <code>pertubation = 'none'</code>. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="noise_value_+3A_x">x</code>, <code id="noise_value_+3A_y">y</code>, <code id="noise_value_+3A_z">z</code></td>
<td>
<p>Coordinates to get noise value from</p>
</td></tr>
<tr><td><code id="noise_value_+3A_seed">seed</code></td>
<td>
<p>The seed to use for the noise. If <code>NULL</code> a random seed will be
used</p>
</td></tr>
<tr><td><code id="noise_value_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>noise_value()</code> a matrix if <code>length(dim) == 2</code> or an array if
<code>length(dim) == 3</code>. For <code>gen_value()</code> a numeric vector matching the length of
the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Basic use
noise &lt;- noise_value(c(100, 100))

plot(as.raster(normalise(noise)))

# Using the generator
grid &lt;- long_grid(seq(1, 10, length.out = 1000), seq(1, 10, length.out = 1000))
grid$noise &lt;- gen_value(grid$x, grid$y)
plot(grid, noise)

</code></pre>

<hr>
<h2 id='noise_white'>White noise generator</h2><span id='topic+noise_white'></span><span id='topic+gen_white'></span>

<h3>Description</h3>

<p>White noise is a random noise with equal intensities at different
frequencies. It is most well-known as what appeared on old televisions when
no signal was found.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noise_white(
  dim,
  frequency = 0.01,
  pertubation = "none",
  pertubation_amplitude = 1
)

gen_white(x, y = NULL, z = NULL, t = NULL, frequency = 1, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="noise_white_+3A_dim">dim</code></td>
<td>
<p>The dimensions (height, width, (and depth, (and time))) of the
noise to be generated. The length determines the dimensionality of the noise.</p>
</td></tr>
<tr><td><code id="noise_white_+3A_frequency">frequency</code></td>
<td>
<p>Determines the granularity of the features in the noise.</p>
</td></tr>
<tr><td><code id="noise_white_+3A_pertubation">pertubation</code></td>
<td>
<p>The pertubation to use. Either <code>'none'</code> (default),
<code>'normal'</code>, or <code>'fractal'</code>. Defines the displacement (warping) of the noise,
with <code>'normal'</code> giving a smooth warping and <code>'fractal'</code> giving a more eratic
warping.</p>
</td></tr>
<tr><td><code id="noise_white_+3A_pertubation_amplitude">pertubation_amplitude</code></td>
<td>
<p>The maximal pertubation distance from the
origin. Ignored if <code>pertubation = 'none'</code>. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="noise_white_+3A_x">x</code>, <code id="noise_white_+3A_y">y</code>, <code id="noise_white_+3A_z">z</code>, <code id="noise_white_+3A_t">t</code></td>
<td>
<p>Coordinates to get noise value from</p>
</td></tr>
<tr><td><code id="noise_white_+3A_seed">seed</code></td>
<td>
<p>The seed to use for the noise. If <code>NULL</code> a random seed will be
used</p>
</td></tr>
<tr><td><code id="noise_white_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>noise_white()</code> a matrix if <code>length(dim) == 2</code> or an array if
<code>length(dim) &gt;= 3</code>. For <code>gen_white()</code> a numeric vector matching the length of
the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Basic use
noise &lt;- noise_white(c(100, 100))

plot(as.raster(normalise(noise)))

# Using the generator
grid &lt;- long_grid(seq(1, 10, length.out = 1000), seq(1, 10, length.out = 1000))
grid$noise &lt;- gen_white(grid$x, grid$y)
plot(grid, noise)

</code></pre>

<hr>
<h2 id='noise_worley'>Worley (cell) noise generator</h2><span id='topic+noise_worley'></span><span id='topic+gen_worley'></span>

<h3>Description</h3>

<p>Worley noise, sometimes called cell (or cellular) noise, is quite distinct
due to it's kinship to voronoi tesselation. It is created by sampling random
points in space and then for any point in space measure the distance to the
closest point. The noise can be modified further by changing either the
distance measure or by combining multiple distances. The noise algorithm was
developed by Steven Worley in 1996 and has been used to simulated water and
stone textures among other things.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noise_worley(
  dim,
  frequency = 0.01,
  distance = "euclidean",
  fractal = "none",
  octaves = 3,
  lacunarity = 2,
  gain = 0.5,
  value = "cell",
  distance_ind = c(1, 2),
  jitter = 0.45,
  pertubation = "none",
  pertubation_amplitude = 1
)

gen_worley(
  x,
  y = NULL,
  z = NULL,
  frequency = 1,
  seed = NULL,
  distance = "euclidean",
  value = "cell",
  distance_ind = c(1, 2),
  jitter = 0.45,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="noise_worley_+3A_dim">dim</code></td>
<td>
<p>The dimensions (height, width, (and depth)) of the noise to be
generated. The length determines the dimensionality of the noise.</p>
</td></tr>
<tr><td><code id="noise_worley_+3A_frequency">frequency</code></td>
<td>
<p>Determines the granularity of the features in the noise.</p>
</td></tr>
<tr><td><code id="noise_worley_+3A_distance">distance</code></td>
<td>
<p>The distance measure to use, either <code>'euclidean'</code> (default),
<code>'manhattan'</code>, or <code>'natural'</code> (a mix of the two)</p>
</td></tr>
<tr><td><code id="noise_worley_+3A_fractal">fractal</code></td>
<td>
<p>The fractal type to use. Either <code>'none'</code>, <code>'fbm'</code> (default),
<code>'billow'</code>, or <code>'rigid-multi'</code>. It is suggested that you experiment with the
different types to get a feel for how they behaves.</p>
</td></tr>
<tr><td><code id="noise_worley_+3A_octaves">octaves</code></td>
<td>
<p>The number of noise layers used to create the fractal noise.
Ignored if <code>fractal = 'none'</code>. Defaults to <code>3</code>.</p>
</td></tr>
<tr><td><code id="noise_worley_+3A_lacunarity">lacunarity</code></td>
<td>
<p>The frequency multiplier between successive noise layers
when building fractal noise. Ignored if <code>fractal = 'none'</code>. Defaults to <code>2</code>.</p>
</td></tr>
<tr><td><code id="noise_worley_+3A_gain">gain</code></td>
<td>
<p>The relative strength between successive noise layers when
building fractal noise. Ignored if <code>fractal = 'none'</code>. Defaults to <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="noise_worley_+3A_value">value</code></td>
<td>
<p>The noise value to return. Either
</p>

<ul>
<li> <p><code>'value'</code> (default) A random value associated with the closest point
</p>
</li>
<li> <p><code>'distance'</code> The distance to the closest point
</p>
</li>
<li> <p><code>'distance2'</code> The distance to the nth closest point (n given by
<code>distance_ind[1]</code>)
</p>
</li>
<li> <p><code>'distance2add'</code> Addition of the distance to the nth and mth closest point given in <code>distance_ind</code>
</p>
</li>
<li> <p><code>'distance2sub'</code> Substraction of the distance to the nth and mth closest point given in <code>distance_ind</code>
</p>
</li>
<li> <p><code>'distance2mul'</code> Multiplication of the distance to the nth and mth closest point given in <code>distance_ind</code>
</p>
</li>
<li> <p><code>'distance2div'</code> Division of the distance to the nth and mth closest point given in <code>distance_ind</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="noise_worley_+3A_distance_ind">distance_ind</code></td>
<td>
<p>Reference to the nth and mth closest points that should
be used when calculating <code>value</code>.</p>
</td></tr>
<tr><td><code id="noise_worley_+3A_jitter">jitter</code></td>
<td>
<p>The maximum distance a point can move from its start position
during sampling of cell points.</p>
</td></tr>
<tr><td><code id="noise_worley_+3A_pertubation">pertubation</code></td>
<td>
<p>The pertubation to use. Either <code>'none'</code> (default),
<code>'normal'</code>, or <code>'fractal'</code>. Defines the displacement (warping) of the noise,
with <code>'normal'</code> giving a smooth warping and <code>'fractal'</code> giving a more eratic
warping.</p>
</td></tr>
<tr><td><code id="noise_worley_+3A_pertubation_amplitude">pertubation_amplitude</code></td>
<td>
<p>The maximal pertubation distance from the
origin. Ignored if <code>pertubation = 'none'</code>. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="noise_worley_+3A_x">x</code>, <code id="noise_worley_+3A_y">y</code>, <code id="noise_worley_+3A_z">z</code></td>
<td>
<p>Coordinates to get noise value from</p>
</td></tr>
<tr><td><code id="noise_worley_+3A_seed">seed</code></td>
<td>
<p>The seed to use for the noise. If <code>NULL</code> a random seed will be
used</p>
</td></tr>
<tr><td><code id="noise_worley_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>noise_worley()</code> a matrix if <code>length(dim) == 2</code> or an array if
<code>length(dim) == 3</code>. For <code>gen_worley()</code> a numeric vector matching the length of
the input.
</p>


<h3>References</h3>

<p>Worley, Steven (1996). <em>A cellular texture basis function</em>. Proceedings of the 23rd annual conference on computer graphics and interactive techniques. pp. 291–294. ISBN 0-89791-746-4
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Basic use
noise &lt;- noise_worley(c(100, 100))

plot(as.raster(normalise(noise)))

# Using the generator and another value metric
grid &lt;- long_grid(seq(1, 10, length.out = 1000), seq(1, 10, length.out = 1000))
grid$noise &lt;- gen_worley(grid$x, grid$y, value = 'distance')
plot(grid, noise)

</code></pre>

<hr>
<h2 id='ridged'>Ridged-Multi fractal</h2><span id='topic+ridged'></span><span id='topic+rigid'></span><span id='topic+rigid-multi'></span><span id='topic+spectral_gain'></span>

<h3>Description</h3>

<p>This fractal is slightly more complex than the regular <code><a href="#topic+fbm">fbm()</a></code> fractal. It
uses the prior octave to modify the values of the current octave before
adding it to the cumulating values. The result of this is that the final
values will show steep hills and larger smooth areas, resembling mountain
ranges. This function is intended to be used in conjunction with
<code><a href="#topic+fracture">fracture()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ridged(base, new, strength, octave, offset = 1, gain = 2, ...)

spectral_gain(h = 1, lacunarity = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ridged_+3A_base">base</code></td>
<td>
<p>The prior values to modify</p>
</td></tr>
<tr><td><code id="ridged_+3A_new">new</code></td>
<td>
<p>The new values to modify <code>base</code> with</p>
</td></tr>
<tr><td><code id="ridged_+3A_strength">strength</code></td>
<td>
<p>A value to modify <code>new</code> with before applying it to <code>base</code></p>
</td></tr>
<tr><td><code id="ridged_+3A_octave">octave</code></td>
<td>
<p>The current octave</p>
</td></tr>
<tr><td><code id="ridged_+3A_offset">offset</code></td>
<td>
<p>The new values are first modified by <code>(offset - abs(new))^2</code></p>
</td></tr>
<tr><td><code id="ridged_+3A_gain">gain</code></td>
<td>
<p>A value to multiply the old octave by before using it to modify
the new octave</p>
</td></tr>
<tr><td><code id="ridged_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="ridged_+3A_h">h</code></td>
<td>
<p>Each successive gain is raised to the power of <code>-h</code></p>
</td></tr>
<tr><td><code id="ridged_+3A_lacunarity">lacunarity</code></td>
<td>
<p>A multiplier to apply to the previous value before raising
it to the power of <code>-h</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ridged fractal was designed with a slightly more complex gain sequence
in mind, and while any sequence or generator would work <code><a href="#topic+fracture">fracture()</a></code> should
be called with <code>gain = spectral_gain()</code> to mimick the original intention of
the fractal.
</p>


<h3>See Also</h3>

<p>Other Fractal functions: 
<code><a href="#topic+billow">billow</a>()</code>,
<code><a href="#topic+clamped">clamped</a>()</code>,
<code><a href="#topic+fbm">fbm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grid &lt;- long_grid(seq(1, 10, length.out = 1000), seq(1, 10, length.out = 1000))

grid$simplex &lt;- fracture(gen_simplex, ridged, octaves = 8,
                         gain = spectral_gain(), x = grid$x, y = grid$y)
plot(grid, simplex)

</code></pre>

<hr>
<h2 id='trans_affine'>Apply linear transformation to a long_grid</h2><span id='topic+trans_affine'></span><span id='topic+rotate'></span><span id='topic+stretch'></span><span id='topic+shear'></span><span id='topic+translate'></span><span id='topic+reflect'></span>

<h3>Description</h3>

<p>This function allows you to calculate linear transformations of coordinates
in a long_grid object. You can either pass in a transformation matrix or a
trans object as produced by <code>ggforce::linear_trans(...)</code>. The latter makes it
easy to stack multiple transformations into one, but require the ggforce
package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trans_affine(x, y, ...)

rotate(angle = 0)

stretch(x0 = 0, y0 = 0)

shear(x0 = 0, y0 = 0)

translate(x0 = 0, y0 = 0)

reflect(x0 = 0, y0 = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trans_affine_+3A_x">x</code>, <code id="trans_affine_+3A_y">y</code></td>
<td>
<p>The coordinates to transform</p>
</td></tr>
<tr><td><code id="trans_affine_+3A_...">...</code></td>
<td>
<p>A sequence of transformations</p>
</td></tr>
<tr><td><code id="trans_affine_+3A_angle">angle</code></td>
<td>
<p>An angle in radians</p>
</td></tr>
<tr><td><code id="trans_affine_+3A_x0">x0</code></td>
<td>
<p>the transformation magnitude in the x-direction</p>
</td></tr>
<tr><td><code id="trans_affine_+3A_y0">y0</code></td>
<td>
<p>the transformation magnitude in the x-direction</p>
</td></tr>
</table>


<h3>Linear Transformations</h3>

<p>The following transformation matrix constructors are supplied, but you can
also provide your own 3x3 matrices to <code>translate()</code>
</p>

<ul>
<li> <p><code>rotate()</code>: Rotate coordinates by <code>angle</code> (in radians) around the center
counter-clockwise.
</p>
</li>
<li> <p><code>stretch()</code>: Stretches the x and/or y dimension by multiplying it with
<code>x0</code>/<code>y0</code>.
</p>
</li>
<li> <p><code>shear()</code>: Shears the x and/or y dimension by <code>x0</code>/<code>y0</code>.
</p>
</li>
<li> <p><code>translate()</code>: Moves coordinates by <code>x0</code>/<code>y0</code>.
</p>
</li>
<li> <p><code>reflect()</code>: Reflects coordinates through the line that goes through <code style="white-space: pre;">&#8288;0, 0&#8288;</code>
and <code style="white-space: pre;">&#8288;x0, y0&#8288;</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>grid &lt;- long_grid(seq(1, 10, length.out = 1000), seq(1, 10, length.out = 1000))
grid$trans &lt;- trans_affine(grid$x, grid$y, rotate(pi/3), shear(-2), rotate(-pi/3))
grid$chess &lt;- gen_checkerboard(grid$trans$x, grid$trans$y)

plot(grid, chess)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
