<!DOCTYPE html><html><head><title>Help for package xrnet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {xrnet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#coef.tune_xrnet'><p>Get coefficient estimates from &quot;tune_xrnet&quot; model object</p></a></li>
<li><a href='#coef.xrnet'><p>Get coefficient estimates from &quot;xrnet&quot; model object</p></a></li>
<li><a href='#define_enet'><p>Define elastic net regularization object for predictor and external data</p></a></li>
<li><a href='#define_lasso'><p>Define lasso regularization object for predictor and external data</p></a></li>
<li><a href='#define_penalty'><p>Define regularization object for predictor and external data</p></a></li>
<li><a href='#define_ridge'><p>Define ridge regularization object for predictor and external data</p></a></li>
<li><a href='#ext_linear'><p>Simulated external data</p></a></li>
<li><a href='#plot.tune_xrnet'><p>Plot k-fold cross-validation error grid</p></a></li>
<li><a href='#predict.tune_xrnet'><p>Predict function for &quot;tune_xrnet&quot; object</p></a></li>
<li><a href='#predict.xrnet'><p>Predict function for &quot;xrnet&quot; object</p></a></li>
<li><a href='#tune_xrnet'><p>k-fold cross-validation for hierarchical regularized regression</p></a></li>
<li><a href='#x_linear'><p>Simulated example data for hierarchical regularized linear regression</p></a></li>
<li><a href='#xrnet'><p>Fit hierarchical regularized regression model</p></a></li>
<li><a href='#xrnet.control'><p>Control function for xrnet fitting</p></a></li>
<li><a href='#y_linear'><p>Simulated outcome data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Hierarchical Regularized Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.7</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/USCbiostats/xrnet">https://github.com/USCbiostats/xrnet</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Fits hierarchical regularized regression models
    to incorporate potentially informative external data, Weaver and Lewinger (2019) &lt;<a href="https://doi.org/10.21105%2Fjoss.01761">doi:10.21105/joss.01761</a>&gt;. 
    Utilizes coordinate descent to efficiently fit regularized regression models both with and without
    external information with the most common penalties used in practice (i.e. ridge, lasso, elastic net). 
    Support for standard R matrices, sparse matrices and big.matrix objects.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat, Matrix, doParallel</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen, BH, bigmemory</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.19), foreach, bigmemory, methods</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++11</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-02-29 23:54:54 UTC; gmweaver</td>
</tr>
<tr>
<td>Author:</td>
<td>Garrett Weaver <a href="https://orcid.org/0000-0002-9918-8386"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Juan Pablo Lewinger [ctb, ths]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Garrett Weaver &lt;gmweaver.usc@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-03-01 06:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='coef.tune_xrnet'>Get coefficient estimates from &quot;tune_xrnet&quot; model object</h2><span id='topic+coef.tune_xrnet'></span>

<h3>Description</h3>

<p>Returns coefficients from 'xrnet' model. Note that we currently only support returning
coefficient estimates that are in the original path(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tune_xrnet'
coef(object, p = "opt", pext = "opt", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.tune_xrnet_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+tune_xrnet">tune_xrnet</a></code> object</p>
</td></tr>
<tr><td><code id="coef.tune_xrnet_+3A_p">p</code></td>
<td>
<p>vector of penalty values to apply to predictor variables.
Default is optimal value in tune_xrnet object.</p>
</td></tr>
<tr><td><code id="coef.tune_xrnet_+3A_pext">pext</code></td>
<td>
<p>vector of penalty values to apply to external data variables.
Default is optimal value in tune_xrnet object.</p>
</td></tr>
<tr><td><code id="coef.tune_xrnet_+3A_...">...</code></td>
<td>
<p>pass other arguments to xrnet function (if needed)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with coefficient estimates at each of the requested penalty combinations
</p>
<table>
<tr><td><code>beta0</code></td>
<td>
<p>matrix of first-level intercepts indexed by penalty values, NULL if no first-level intercept in original model fit</p>
</td></tr>
<tr><td><code>betas</code></td>
<td>
<p>3-dimensional array of first-level penalized coefficients indexed by penalty values</p>
</td></tr>
<tr><td><code>gammas</code></td>
<td>
<p>3-dimensional array of first-level non-penalized coefficients indexed by penalty values, NULL if unpen NULL in original model fit</p>
</td></tr>
<tr><td><code>alpha0</code></td>
<td>
<p>matrix of second-level intercepts indexed by penalty values, NULL if no second-level intercept in original model fit</p>
</td></tr>
<tr><td><code>alphas</code></td>
<td>
<p>3-dimensional array of second-level external data coefficients indexed by penalty values, NULL if external NULL in original model fit</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## cross validation of hierarchical linear regression model
data(GaussianExample)

## 5-fold cross validation
cv_xrnet &lt;- tune_xrnet(
    x = x_linear,
    y = y_linear,
    external = ext_linear,
    family = "gaussian",
    control = xrnet.control(tolerance = 1e-6)
 )

 ## Get coefficient estimates at optimal penalty combination
 coef_opt &lt;- coef(cv_xrnet)

</code></pre>

<hr>
<h2 id='coef.xrnet'>Get coefficient estimates from &quot;xrnet&quot; model object</h2><span id='topic+coef.xrnet'></span>

<h3>Description</h3>

<p>Returns coefficients from 'xrnet' model. Note that we currently only support returning
coefficient estimates that are in the original path(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xrnet'
coef(object, p = NULL, pext = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.xrnet_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+xrnet">xrnet</a></code> object</p>
</td></tr>
<tr><td><code id="coef.xrnet_+3A_p">p</code></td>
<td>
<p>vector of penalty values to apply to predictor variables.</p>
</td></tr>
<tr><td><code id="coef.xrnet_+3A_pext">pext</code></td>
<td>
<p>vector of penalty values to apply to external data variables.</p>
</td></tr>
<tr><td><code id="coef.xrnet_+3A_...">...</code></td>
<td>
<p>pass other arguments to xrnet function (if needed)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with coefficient estimates at each of the requested penalty combinations
</p>
<table>
<tr><td><code>beta0</code></td>
<td>
<p>matrix of first-level intercepts indexed by penalty values, NULL if no first-level intercept in original model fit</p>
</td></tr>
<tr><td><code>betas</code></td>
<td>
<p>3-dimensional array of first-level penalized coefficients indexed by penalty values</p>
</td></tr>
<tr><td><code>gammas</code></td>
<td>
<p>3-dimensional array of first-level non-penalized coefficients indexed by penalty values, NULL if unpen NULL in original model fit</p>
</td></tr>
<tr><td><code>alpha0</code></td>
<td>
<p>matrix of second-level intercepts indexed by penalty values, NULL if no second-level intercept in original model fit</p>
</td></tr>
<tr><td><code>alphas</code></td>
<td>
<p>3-dimensional array of second-level external data coefficients indexed by penalty values, NULL if external NULL in original model fit</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(GaussianExample)

fit_xrnet &lt;- xrnet(
    x = x_linear,
    y = y_linear,
    external = ext_linear,
    family = "gaussian"
)

lambda1 &lt;- fit_xrnet$penalty[10]
lambda2 &lt;- fit_xrnet$penalty_ext[10]

coef_xrnet &lt;- coef(
    fit_xrnet,
    p = lambda1,
    pext = lambda2,
)


</code></pre>

<hr>
<h2 id='define_enet'>Define elastic net regularization object for predictor and external data</h2><span id='topic+define_enet'></span>

<h3>Description</h3>

<p>Helper function to define a elastic net penalty regularization object.
See <code>define_penalty</code> for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_enet(
  en_param = 0.5,
  num_penalty = 20,
  penalty_ratio = NULL,
  user_penalty = NULL,
  custom_multiplier = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_enet_+3A_en_param">en_param</code></td>
<td>
<p>elastic net parameter, between 0 and 1</p>
</td></tr>
<tr><td><code id="define_enet_+3A_num_penalty">num_penalty</code></td>
<td>
<p>number of penalty values to fit in grid. Default is 20.</p>
</td></tr>
<tr><td><code id="define_enet_+3A_penalty_ratio">penalty_ratio</code></td>
<td>
<p>ratio between minimum and maximum penalty for x.
Default is 1e-04 if <code class="reqn">n &gt; p</code> and 0.01 if <code class="reqn">n &lt;= p</code>.</p>
</td></tr>
<tr><td><code id="define_enet_+3A_user_penalty">user_penalty</code></td>
<td>
<p>user-defined vector of penalty values to use in penalty path.</p>
</td></tr>
<tr><td><code id="define_enet_+3A_custom_multiplier">custom_multiplier</code></td>
<td>
<p>variable-specific penalty multipliers to apply to overall penalty.
Default is 1 for all variables. 0 is no penalization.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object with regularization settings that are used to define the regularization
for predictors or external data in <code><a href="#topic+xrnet">xrnet</a></code> and <code><a href="#topic+tune_xrnet">tune_xrnet</a></code>. The list
elements will match those returned by <code><a href="#topic+define_penalty">define_penalty</a></code>, but with the penalty_type
set to match the value of <code>en_param</code>.
</p>

<hr>
<h2 id='define_lasso'>Define lasso regularization object for predictor and external data</h2><span id='topic+define_lasso'></span>

<h3>Description</h3>

<p>Helper function to define a lasso penalty regularization object.
See <code>define_penalty</code> for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_lasso(
  num_penalty = 20,
  penalty_ratio = NULL,
  user_penalty = NULL,
  custom_multiplier = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_lasso_+3A_num_penalty">num_penalty</code></td>
<td>
<p>number of penalty values to fit in grid. Default is 20.</p>
</td></tr>
<tr><td><code id="define_lasso_+3A_penalty_ratio">penalty_ratio</code></td>
<td>
<p>ratio between minimum and maximum penalty for x.
Default is 1e-04 if <code class="reqn">n &gt; p</code> and 0.01 if <code class="reqn">n &lt;= p</code>.</p>
</td></tr>
<tr><td><code id="define_lasso_+3A_user_penalty">user_penalty</code></td>
<td>
<p>user-defined vector of penalty values to use in penalty path.</p>
</td></tr>
<tr><td><code id="define_lasso_+3A_custom_multiplier">custom_multiplier</code></td>
<td>
<p>variable-specific penalty multipliers to apply to overall penalty.
Default is 1 for all variables. 0 is no penalization.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object with regularization settings that are used to define the regularization
for predictors or external data in <code><a href="#topic+xrnet">xrnet</a></code> and <code><a href="#topic+tune_xrnet">tune_xrnet</a></code>. The list
elements will match those returned by <code><a href="#topic+define_penalty">define_penalty</a></code>, but with the penalty_type
automatically set to 1.
</p>

<hr>
<h2 id='define_penalty'>Define regularization object for predictor and external data</h2><span id='topic+define_penalty'></span>

<h3>Description</h3>

<p>Defines regularization for predictors and external data variables in <code><a href="#topic+xrnet">xrnet</a></code> fitting.
Use helper functions define_lasso, define_ridge, or define_enet to specify a common penalty on x or external.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_penalty(
  penalty_type = 1,
  quantile = 0.5,
  num_penalty = 20,
  penalty_ratio = NULL,
  user_penalty = NULL,
  custom_multiplier = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_penalty_+3A_penalty_type">penalty_type</code></td>
<td>
<p>type of regularization. Default is 1 (Lasso).
Can supply either a scalar value or vector with length equal to the number of variables the matrix.
</p>

<ul>
<li><p> 0 = Ridge
</p>
</li>
<li><p> (0,1) = Elastic-Net
</p>
</li>
<li><p> 1 = Lasso / Quantile
</p>
</li></ul>
</td></tr>
<tr><td><code id="define_penalty_+3A_quantile">quantile</code></td>
<td>
<p>specifies quantile for quantile penalty. Default of 0.5 reduces to lasso (currently not implemented).</p>
</td></tr>
<tr><td><code id="define_penalty_+3A_num_penalty">num_penalty</code></td>
<td>
<p>number of penalty values to fit in grid. Default is 20.</p>
</td></tr>
<tr><td><code id="define_penalty_+3A_penalty_ratio">penalty_ratio</code></td>
<td>
<p>ratio between minimum and maximum penalty for x.
Default is 1e-04 if <code class="reqn">n &gt; p</code> and 0.01 if <code class="reqn">n &lt;= p</code>.</p>
</td></tr>
<tr><td><code id="define_penalty_+3A_user_penalty">user_penalty</code></td>
<td>
<p>user-defined vector of penalty values to use in penalty path.</p>
</td></tr>
<tr><td><code id="define_penalty_+3A_custom_multiplier">custom_multiplier</code></td>
<td>
<p>variable-specific penalty multipliers to apply to overall penalty.
Default is 1 for all variables. 0 is no penalization.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object with regularization settings that are used to define the regularization
for predictors or external data in <code><a href="#topic+xrnet">xrnet</a></code> and <code><a href="#topic+tune_xrnet">tune_xrnet</a></code>:
</p>
<table>
<tr><td><code>penalty_type</code></td>
<td>
<p>The penalty type, scalar with value in range [0, 1].</p>
</td></tr>
<tr><td><code>quantile</code></td>
<td>
<p>Quantile for quantile penalty, 0.5 defaults to lasso (not currently implemented).</p>
</td></tr>
<tr><td><code>num_penalty</code></td>
<td>
<p>The number of penalty values in the penalty path.</p>
</td></tr>
<tr><td><code>penalty_ratio</code></td>
<td>
<p>The ratio of the minimum penalty value compared to the maximum penalty value.</p>
</td></tr>
<tr><td><code>user_penalty</code></td>
<td>
<p>User-defined numeric vector of penalty values, NULL if not provided by user.</p>
</td></tr>
<tr><td><code>custom_multiplier</code></td>
<td>
<p>User-defined feature-specific penalty multipliers, NULL if not provided by user.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# define ridge penalty with penalty grid split into 30 values
my_penalty &lt;- define_penalty(penalty_type = 0, num_penalty = 30)

# define elastic net (0.5) penalty with user-defined penalty
my_custom_penalty &lt;- define_penalty(penalty_type = 0.5, user_penalty = c(100, 50, 10, 1, 0.1))
</code></pre>

<hr>
<h2 id='define_ridge'>Define ridge regularization object for predictor and external data</h2><span id='topic+define_ridge'></span>

<h3>Description</h3>

<p>Helper function to define a ridge penalty regularization object.
See <code>define_penalty</code> for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_ridge(
  num_penalty = 20,
  penalty_ratio = NULL,
  user_penalty = NULL,
  custom_multiplier = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_ridge_+3A_num_penalty">num_penalty</code></td>
<td>
<p>number of penalty values to fit in grid. Default is 20.</p>
</td></tr>
<tr><td><code id="define_ridge_+3A_penalty_ratio">penalty_ratio</code></td>
<td>
<p>ratio between minimum and maximum penalty for x.
Default is 1e-04 if <code class="reqn">n &gt; p</code> and 0.01 if <code class="reqn">n &lt;= p</code>.</p>
</td></tr>
<tr><td><code id="define_ridge_+3A_user_penalty">user_penalty</code></td>
<td>
<p>user-defined vector of penalty values to use in penalty path.</p>
</td></tr>
<tr><td><code id="define_ridge_+3A_custom_multiplier">custom_multiplier</code></td>
<td>
<p>variable-specific penalty multipliers to apply to overall penalty.
Default is 1 for all variables. 0 is no penalization.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object with regularization settings that are used to define the regularization
for predictors or external data in <code><a href="#topic+xrnet">xrnet</a></code> and <code><a href="#topic+tune_xrnet">tune_xrnet</a></code>. The list
elements will match those returned by <code><a href="#topic+define_penalty">define_penalty</a></code>, but with the penalty_type
automatically set to 0.
</p>

<hr>
<h2 id='ext_linear'>Simulated external data</h2><span id='topic+ext_linear'></span>

<h3>Description</h3>

<p>Simulated external data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ext_linear
</code></pre>


<h3>Format</h3>

<p>A matrix with 50 rows and 4 columns</p>

<hr>
<h2 id='plot.tune_xrnet'>Plot k-fold cross-validation error grid</h2><span id='topic+plot.tune_xrnet'></span>

<h3>Description</h3>

<p>Generates plots to visualize the mean cross-validation error. If no external
data was used in the model fit, a plot of the cross-validated error with standard error
bars is generated for all penalty values. If external data was used in the model fit, a
contour plot of the cross-validated errors is created. Error curves can also be
generated for a fixed value of the primary penalty on x (p) or the external penalty (pext) when
external data is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tune_xrnet'
plot(x, p = NULL, pext = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.tune_xrnet_+3A_x">x</code></td>
<td>
<p>A tune_xrnet class object</p>
</td></tr>
<tr><td><code id="plot.tune_xrnet_+3A_p">p</code></td>
<td>
<p>(optional) penalty value for x (for generating an error curve across external penalties).
Use value &quot;opt&quot; to use the optimal penalty value.</p>
</td></tr>
<tr><td><code id="plot.tune_xrnet_+3A_pext">pext</code></td>
<td>
<p>(optional) penalty value for external (for generating an error curve across primary penalties)
Use value &quot;opt&quot; to use the optimal penalty value.</p>
</td></tr>
<tr><td><code id="plot.tune_xrnet_+3A_...">...</code></td>
<td>
<p>Additional graphics parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter values p and pext can be used to generate profiled error curves by fixing either
the penalty on x or the penalty on external to a fixed value. You cannot specify
both at the same time as this would only return a single point.
</p>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example data
data(GaussianExample)

## 5-fold cross validation
cv_xrnet &lt;- tune_xrnet(
    x = x_linear,
    y = y_linear,
    external = ext_linear,
    family = "gaussian",
    control = xrnet.control(tolerance = 1e-6)
 )

 ## contour plot of cross-validated error
 plot(cv_xrnet)

 ## error curve of external penalties at optimal penalty value
 plot(cv_xrnet, p = "opt")

</code></pre>

<hr>
<h2 id='predict.tune_xrnet'>Predict function for &quot;tune_xrnet&quot; object</h2><span id='topic+predict.tune_xrnet'></span>

<h3>Description</h3>

<p>Extract coefficients or predict response in new data using fitted model from a <code><a href="#topic+tune_xrnet">tune_xrnet</a></code> object.
Note that we currently only support returning results that are in the original path(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tune_xrnet'
predict(
  object,
  newdata = NULL,
  newdata_fixed = NULL,
  p = "opt",
  pext = "opt",
  type = c("response", "link", "coefficients"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.tune_xrnet_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+tune_xrnet">tune_xrnet</a></code> object</p>
</td></tr>
<tr><td><code id="predict.tune_xrnet_+3A_newdata">newdata</code></td>
<td>
<p>matrix with new values for penalized variables</p>
</td></tr>
<tr><td><code id="predict.tune_xrnet_+3A_newdata_fixed">newdata_fixed</code></td>
<td>
<p>matrix with new values for unpenalized variables</p>
</td></tr>
<tr><td><code id="predict.tune_xrnet_+3A_p">p</code></td>
<td>
<p>vector of penalty values to apply to predictor variables.
Default is optimal value in tune_xrnet object.</p>
</td></tr>
<tr><td><code id="predict.tune_xrnet_+3A_pext">pext</code></td>
<td>
<p>vector of penalty values to apply to external data variables.
Default is optimal value in tune_xrnet object.</p>
</td></tr>
<tr><td><code id="predict.tune_xrnet_+3A_type">type</code></td>
<td>
<p>type of prediction to make using the xrnet model, options include:
</p>

<ul>
<li><p> response
</p>
</li>
<li><p> link (linear predictor)
</p>
</li>
<li><p> coefficients
</p>
</li></ul>
</td></tr>
<tr><td><code id="predict.tune_xrnet_+3A_...">...</code></td>
<td>
<p>pass other arguments to xrnet function (if needed)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object returned is based on the value of type as follows:
</p>

<ul>
<li><p> response: An array with the response predictions based on the data for each penalty combination
</p>
</li>
<li><p> link: An array with linear predictions based on the data for each penalty combination
</p>
</li>
<li><p> coefficients: A list with the coefficient estimates for each penalty combination. See <code><a href="#topic+coef.xrnet">coef.xrnet</a></code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(GaussianExample)

## 5-fold cross validation
cv_xrnet &lt;- tune_xrnet(
    x = x_linear,
    y = y_linear,
    external = ext_linear,
    family = "gaussian",
    control = xrnet.control(tolerance = 1e-6)
 )

## Get coefficients and predictions at optimal penalty combination
coef_xrnet &lt;- predict(cv_xrnet, type = "coefficients")
pred_xrnet &lt;- predict(cv_xrnet, newdata = x_linear, type = "response")

</code></pre>

<hr>
<h2 id='predict.xrnet'>Predict function for &quot;xrnet&quot; object</h2><span id='topic+predict.xrnet'></span>

<h3>Description</h3>

<p>Extract coefficients or  predict response in new data using fitted model from an <code><a href="#topic+xrnet">xrnet</a></code> object.
Note that we currently only support returning coefficient estimates that are in the original path(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xrnet'
predict(
  object,
  newdata = NULL,
  newdata_fixed = NULL,
  p = NULL,
  pext = NULL,
  type = c("response", "link", "coefficients"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.xrnet_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+xrnet">xrnet</a></code> object</p>
</td></tr>
<tr><td><code id="predict.xrnet_+3A_newdata">newdata</code></td>
<td>
<p>matrix with new values for penalized variables</p>
</td></tr>
<tr><td><code id="predict.xrnet_+3A_newdata_fixed">newdata_fixed</code></td>
<td>
<p>matrix with new values for unpenalized variables</p>
</td></tr>
<tr><td><code id="predict.xrnet_+3A_p">p</code></td>
<td>
<p>vector of penalty values to apply to predictor variables</p>
</td></tr>
<tr><td><code id="predict.xrnet_+3A_pext">pext</code></td>
<td>
<p>vector of penalty values to apply to external data variables</p>
</td></tr>
<tr><td><code id="predict.xrnet_+3A_type">type</code></td>
<td>
<p>type of prediction to make using the xrnet model, options include
</p>

<ul>
<li><p> response
</p>
</li>
<li><p> link (linear predictor)
</p>
</li>
<li><p> coefficients
</p>
</li></ul>
</td></tr>
<tr><td><code id="predict.xrnet_+3A_...">...</code></td>
<td>
<p>pass other arguments to xrnet function (if needed)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object returned is based on the value of type as follows:
</p>

<ul>
<li><p> response: An array with the response predictions based on the data for each penalty combination
</p>
</li>
<li><p> link: An array with linear predictions based on the data for each penalty combination
</p>
</li>
<li><p> coefficients: A list with the coefficient estimates for each penalty combination. See <code><a href="#topic+coef.xrnet">coef.xrnet</a></code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(GaussianExample)

fit_xrnet &lt;- xrnet(
    x = x_linear,
    y = y_linear,
    external = ext_linear,
    family = "gaussian"
)

lambda1 &lt;- fit_xrnet$penalty[10]
lambda2 &lt;- fit_xrnet$penalty_ext[10]

coef_xrnet &lt;- predict(
    fit_xrnet,
    p = lambda1,
    pext = lambda2,
    type = "coefficients"
)

pred_xrnet &lt;- predict(
    fit_xrnet,
    p = lambda1,
    pext = lambda2,
    newdata = x_linear,
    type = "response"
)

</code></pre>

<hr>
<h2 id='tune_xrnet'>k-fold cross-validation for hierarchical regularized regression</h2><span id='topic+tune_xrnet'></span>

<h3>Description</h3>

<p>k-fold cross-validation for hierarchical regularized regression <code><a href="#topic+xrnet">xrnet</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tune_xrnet(
  x,
  y,
  external = NULL,
  unpen = NULL,
  family = c("gaussian", "binomial"),
  penalty_main = define_penalty(),
  penalty_external = define_penalty(),
  weights = NULL,
  standardize = c(TRUE, TRUE),
  intercept = c(TRUE, FALSE),
  loss = c("deviance", "mse", "mae", "auc"),
  nfolds = 5,
  foldid = NULL,
  parallel = FALSE,
  control = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tune_xrnet_+3A_x">x</code></td>
<td>
<p>predictor design matrix of dimension <code class="reqn">n x p</code>, matrix options include:
</p>

<ul>
<li><p> matrix
</p>
</li>
<li><p> big.matrix
</p>
</li>
<li><p> filebacked.big.matrix
</p>
</li>
<li><p> sparse matrix (dgCMatrix)
</p>
</li></ul>
</td></tr>
<tr><td><code id="tune_xrnet_+3A_y">y</code></td>
<td>
<p>outcome vector of length <code class="reqn">n</code></p>
</td></tr>
<tr><td><code id="tune_xrnet_+3A_external">external</code></td>
<td>
<p>(optional) external data design matrix of dimension <code class="reqn">p x q</code>, matrix options include:
</p>

<ul>
<li><p> matrix
</p>
</li>
<li><p> sparse matrix (dgCMatrix)
</p>
</li></ul>
</td></tr>
<tr><td><code id="tune_xrnet_+3A_unpen">unpen</code></td>
<td>
<p>(optional) unpenalized predictor design matrix, matrix options include:
</p>

<ul>
<li><p> matrix
</p>
</li></ul>
</td></tr>
<tr><td><code id="tune_xrnet_+3A_family">family</code></td>
<td>
<p>error distribution for outcome variable, options include:
</p>

<ul>
<li><p> &quot;gaussian&quot;
</p>
</li>
<li><p> &quot;binomial&quot;
</p>
</li></ul>
</td></tr>
<tr><td><code id="tune_xrnet_+3A_penalty_main">penalty_main</code></td>
<td>
<p>specifies regularization object for x. See <code><a href="#topic+define_penalty">define_penalty</a></code> for more details.</p>
</td></tr>
<tr><td><code id="tune_xrnet_+3A_penalty_external">penalty_external</code></td>
<td>
<p>specifies regularization object for external. See <code><a href="#topic+define_penalty">define_penalty</a></code> for more details.
See <code><a href="#topic+define_penalty">define_penalty</a></code> for more details.</p>
</td></tr>
<tr><td><code id="tune_xrnet_+3A_weights">weights</code></td>
<td>
<p>optional vector of observation-specific weights.
Default is 1 for all observations.</p>
</td></tr>
<tr><td><code id="tune_xrnet_+3A_standardize">standardize</code></td>
<td>
<p>indicates whether x and/or external should be standardized.
Default is c(TRUE, TRUE).</p>
</td></tr>
<tr><td><code id="tune_xrnet_+3A_intercept">intercept</code></td>
<td>
<p>indicates whether an intercept term is included for x and/or external.
Default is c(TRUE, FALSE).</p>
</td></tr>
<tr><td><code id="tune_xrnet_+3A_loss">loss</code></td>
<td>
<p>loss function for cross-validation. Options include:
</p>

<ul>
<li><p> &quot;deviance&quot;
</p>
</li>
<li><p> &quot;mse&quot; (Mean Squared Error)
</p>
</li>
<li><p> &quot;mae&quot; (Mean Absolute Error)
</p>
</li>
<li><p> &quot;auc&quot; (Area under the curve)
</p>
</li></ul>
</td></tr>
<tr><td><code id="tune_xrnet_+3A_nfolds">nfolds</code></td>
<td>
<p>number of folds for cross-validation. Default is 5.</p>
</td></tr>
<tr><td><code id="tune_xrnet_+3A_foldid">foldid</code></td>
<td>
<p>(optional) vector that identifies user-specified fold for each observation.
If NULL, folds are automatically generated.</p>
</td></tr>
<tr><td><code id="tune_xrnet_+3A_parallel">parallel</code></td>
<td>
<p>use <code>foreach</code> function to fit folds in parallel if TRUE,
must register cluster (<code>doParallel</code>) before using.</p>
</td></tr>
<tr><td><code id="tune_xrnet_+3A_control">control</code></td>
<td>
<p>specifies xrnet control object. See <code><a href="#topic+xrnet.control">xrnet.control</a></code> for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>k-fold cross-validation is used to determine the 'optimal' combination of hyperparameter values, where
optimal is based on the optimal value obtained for the user-selected loss function across the k folds. To efficiently traverse all possible
combinations of the hyperparameter values, 'warm-starts' are used to traverse the penalty from largest
to smallest penalty value(s). Note that the penalty grid for the folds is generated
by fitting the model on the entire training data. Parallelization is enabled through the <code>foreach</code> and
<code>doParallel</code> R packages. To use parallelization, <code>parallel = TRUE</code>, you must first create the cluster
<code>makeCluster</code> and then register the cluster <code>registerDoParallel</code>. See the <code>parallel</code>, <code>foreach</code>,
and/or <code>doParallel</code> R packages for more details on how to setup parallelization.
</p>


<h3>Value</h3>

<p>A list of class <code>tune_xrnet</code> with components
</p>
<table>
<tr><td><code>cv_mean</code></td>
<td>
<p>mean cross-validated error for each penalty combination. Object returned is
a vector if there is no external data (external = NULL) and matrix if there is external data.</p>
</td></tr>
<tr><td><code>cv_sd</code></td>
<td>
<p>estimated standard deviation for cross-validated errorsObject returned is
a vector if there is no external data (external = NULL) and matrix if there is external data.</p>
</td></tr>
<tr><td><code>loss</code></td>
<td>
<p>loss function used to compute cross-validation error</p>
</td></tr>
<tr><td><code>opt_loss</code></td>
<td>
<p>the value of the loss function for the optimal cross-validated error</p>
</td></tr>
<tr><td><code>opt_penalty</code></td>
<td>
<p>first-level penalty value that achieves the optimal loss</p>
</td></tr>
<tr><td><code>opt_penalty_ext</code></td>
<td>
<p>second-level penalty value that achieves the optimal loss (if external data is present)</p>
</td></tr>
<tr><td><code>fitted_model</code></td>
<td>
<p>fitted xrnet object using all data, see <code><a href="#topic+xrnet">xrnet</a></code> for details of object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## cross validation of hierarchical linear regression model
data(GaussianExample)

## 5-fold cross validation
cv_xrnet &lt;- tune_xrnet(
    x = x_linear,
    y = y_linear,
    external = ext_linear,
    family = "gaussian",
    control = xrnet.control(tolerance = 1e-6)
 )

 ## contour plot of cross-validated error
 plot(cv_xrnet)

</code></pre>

<hr>
<h2 id='x_linear'>Simulated example data for hierarchical regularized linear regression</h2><span id='topic+x_linear'></span>

<h3>Description</h3>

<p>Simulated example data for hierarchical regularized linear regression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x_linear
</code></pre>


<h3>Format</h3>

<p>A matrix with 100 rows and 50 variables</p>

<hr>
<h2 id='xrnet'>Fit hierarchical regularized regression model</h2><span id='topic+xrnet'></span>

<h3>Description</h3>

<p>Fits hierarchical regularized regression model that enables the incorporation of external data
for predictor variables. Both the predictor variables and external data can be regularized
by the most common penalties (lasso, ridge, elastic net).
Solutions are computed across a two-dimensional grid of penalties (a separate penalty path is computed
for the predictors and external variables). Currently support regularized linear and logistic regression,
future extensions to other outcomes (i.e. Cox regression) will be implemented in the next major update.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xrnet(
  x,
  y,
  external = NULL,
  unpen = NULL,
  family = c("gaussian", "binomial"),
  penalty_main = define_penalty(),
  penalty_external = define_penalty(),
  weights = NULL,
  standardize = c(TRUE, TRUE),
  intercept = c(TRUE, FALSE),
  control = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xrnet_+3A_x">x</code></td>
<td>
<p>predictor design matrix of dimension <code class="reqn">n x p</code>, matrix options include:
</p>

<ul>
<li><p> matrix
</p>
</li>
<li><p> big.matrix
</p>
</li>
<li><p> filebacked.big.matrix
</p>
</li>
<li><p> sparse matrix (dgCMatrix)
</p>
</li></ul>
</td></tr>
<tr><td><code id="xrnet_+3A_y">y</code></td>
<td>
<p>outcome vector of length <code class="reqn">n</code></p>
</td></tr>
<tr><td><code id="xrnet_+3A_external">external</code></td>
<td>
<p>(optional) external data design matrix of dimension <code class="reqn">p x q</code>, matrix options include:
</p>

<ul>
<li><p> matrix
</p>
</li>
<li><p> sparse matrix (dgCMatrix)
</p>
</li></ul>
</td></tr>
<tr><td><code id="xrnet_+3A_unpen">unpen</code></td>
<td>
<p>(optional) unpenalized predictor design matrix, matrix options include:
</p>

<ul>
<li><p> matrix
</p>
</li></ul>
</td></tr>
<tr><td><code id="xrnet_+3A_family">family</code></td>
<td>
<p>error distribution for outcome variable, options include:
</p>

<ul>
<li><p> &quot;gaussian&quot;
</p>
</li>
<li><p> &quot;binomial&quot;
</p>
</li></ul>
</td></tr>
<tr><td><code id="xrnet_+3A_penalty_main">penalty_main</code></td>
<td>
<p>specifies regularization object for x. See <code><a href="#topic+define_penalty">define_penalty</a></code> for more details.</p>
</td></tr>
<tr><td><code id="xrnet_+3A_penalty_external">penalty_external</code></td>
<td>
<p>specifies regularization object for external. See <code><a href="#topic+define_penalty">define_penalty</a></code> for more details.</p>
</td></tr>
<tr><td><code id="xrnet_+3A_weights">weights</code></td>
<td>
<p>optional vector of observation-specific weights. Default is 1 for all observations.</p>
</td></tr>
<tr><td><code id="xrnet_+3A_standardize">standardize</code></td>
<td>
<p>indicates whether x and/or external should be standardized. Default is c(TRUE, TRUE).</p>
</td></tr>
<tr><td><code id="xrnet_+3A_intercept">intercept</code></td>
<td>
<p>indicates whether an intercept term is included for x and/or external.
Default is c(TRUE, FALSE).</p>
</td></tr>
<tr><td><code id="xrnet_+3A_control">control</code></td>
<td>
<p>specifies xrnet control object. See <code><a href="#topic+xrnet.control">xrnet.control</a></code> for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extends the coordinate descent algorithm of the R package <code>glmnet</code> to allow the
type of regularization (i.e. ridge, lasso) to be feature-specific. This extension is used to enable fitting
hierarchical regularized regression models, where external information for the predictors can be included in the
<code>external=</code> argument. In addition, elements of the R package <code>biglasso</code> are utilized to enable
the use of standard R matrices, memory-mapped matrices from the <code>bigmemory</code> package, or sparse matrices from the <code>Matrix</code> package.
</p>


<h3>Value</h3>

<p>A list of class <code>xrnet</code> with components:
</p>
<table>
<tr><td><code>beta0</code></td>
<td>
<p>matrix of first-level intercepts indexed by penalty values</p>
</td></tr>
<tr><td><code>betas</code></td>
<td>
<p>3-dimensional array of first-level penalized coefficients indexed by penalty values</p>
</td></tr>
<tr><td><code>gammas</code></td>
<td>
<p>3-dimensional array of first-level non-penalized coefficients indexed by penalty values</p>
</td></tr>
<tr><td><code>alpha0</code></td>
<td>
<p>matrix of second-level intercepts indexed by penalty values</p>
</td></tr>
<tr><td><code>alphas</code></td>
<td>
<p>3-dimensional array of second-level external data coefficients indexed by penalty values</p>
</td></tr>
<tr><td><code>penalty</code></td>
<td>
<p>vector of first-level penalty values</p>
</td></tr>
<tr><td><code>penalty_ext</code></td>
<td>
<p>vector of second-level penalty values</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>error distribution for outcome variable</p>
</td></tr>
<tr><td><code>num_passes</code></td>
<td>
<p>total number of passes over the data in the coordinate descent algorithm</p>
</td></tr>
<tr><td><code>status</code></td>
<td>
<p>error status for xrnet fitting</p>
</td></tr>
</table>

<ul>
<li><p> 0 = OK
</p>
</li>
<li><p> 1 = Error/Warning
</p>
</li></ul>

<table>
<tr><td><code>error_msg</code></td>
<td>
<p>description of error</p>
</td></tr>
</table>


<h3>References</h3>

<p>Jerome Friedman, Trevor Hastie, Robert Tibshirani (2010).
Regularization Paths for Generalized Linear Models via Coordinate Descent.
Journal of Statistical Software, 33(1), 1-22. URL http://www.jstatsoft.org/v33/i01/.
</p>
<p>Zeng, Y., and Breheny, P. (2017).
The biglasso Package: A Memory- and Computation-Efficient Solver for Lasso Model Fitting with Big Data in R.
arXiv preprint arXiv:1701.05936. URL https://arxiv.org/abs/1701.05936.
</p>
<p>Michael J. Kane, John Emerson, Stephen Weston (2013).
Scalable Strategies for Computing with Massive Data.
Journal of Statistical Software, 55(14), 1-19. URL http://www.jstatsoft.org/v55/i14/.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### hierarchical regularized linear regression ###
data(GaussianExample)

## define penalty for predictors and external variables
## default is ridge for predictors and lasso for external
## see define_penalty() function for more details

penMain &lt;- define_penalty(0, num_penalty = 20)
penExt &lt;- define_penalty(1, num_penalty = 20)

## fit model with defined regularization
fit_xrnet &lt;- xrnet(
    x = x_linear,
    y = y_linear,
    external = ext_linear,
    family = "gaussian",
    penalty_main = penMain,
    penalty_external = penExt
)
</code></pre>

<hr>
<h2 id='xrnet.control'>Control function for xrnet fitting</h2><span id='topic+xrnet.control'></span>

<h3>Description</h3>

<p>Control function for <code><a href="#topic+xrnet">xrnet</a></code> fitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xrnet.control(
  tolerance = 1e-08,
  max_iterations = 1e+05,
  dfmax = NULL,
  pmax = NULL,
  lower_limits = NULL,
  upper_limits = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xrnet.control_+3A_tolerance">tolerance</code></td>
<td>
<p>positive convergence criterion. Default is 1e-08.</p>
</td></tr>
<tr><td><code id="xrnet.control_+3A_max_iterations">max_iterations</code></td>
<td>
<p>maximum number of iterations to run coordinate gradient descent
across all penalties before returning an error. Default is 1e+05.</p>
</td></tr>
<tr><td><code id="xrnet.control_+3A_dfmax">dfmax</code></td>
<td>
<p>maximum number of variables allowed in model. Default
is <code class="reqn">ncol(x) + ncol(unpen) + ncol(external) + intercept[1] + intercept[2]</code>.</p>
</td></tr>
<tr><td><code id="xrnet.control_+3A_pmax">pmax</code></td>
<td>
<p>maximum number of variables with nonzero coefficient estimate.
Default is <code class="reqn">min(2 * dfmax + 20, ncol(x) + ncol(unpen) + ncol(external) + intercept[2])</code>.</p>
</td></tr>
<tr><td><code id="xrnet.control_+3A_lower_limits">lower_limits</code></td>
<td>
<p>vector of lower limits for each coefficient. Default is -Inf for all variables.</p>
</td></tr>
<tr><td><code id="xrnet.control_+3A_upper_limits">upper_limits</code></td>
<td>
<p>vector of upper limits for each coefficient. Default is Inf for all variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object with the following components:
</p>
<table>
<tr><td><code>tolerance</code></td>
<td>
<p>The coordinate descent stopping criterion.</p>
</td></tr>
<tr><td><code>dfmax</code></td>
<td>
<p>The maximum number of variables that will be allowed in the model.</p>
</td></tr>
<tr><td><code>pmax</code></td>
<td>
<p>The maximum number of variables with nonzero coefficient estimate.</p>
</td></tr>
<tr><td><code>lower_limits</code></td>
<td>
<p>Feature-specific numeric vector of lower bounds for coefficient estimates</p>
</td></tr>
<tr><td><code>upper_limits</code></td>
<td>
<p>Feature-specific numeric vector of upper bounds for coefficient estimates</p>
</td></tr>
</table>

<hr>
<h2 id='y_linear'>Simulated outcome data</h2><span id='topic+y_linear'></span>

<h3>Description</h3>

<p>Simulated outcome data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>y_linear
</code></pre>


<h3>Format</h3>

<p>A vector with 100 elements</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
