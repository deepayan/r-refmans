<!DOCTYPE html><html><head><title>Help for package geosphere</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {geosphere}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#geosphere-package'><p>Geosphere</p></a></li>
<li><a href='#alongTrackDistance'>
<p>Along Track Distance</p></a></li>
<li><a href='#antipode'>
<p>Antipodes</p></a></li>
<li><a href='#areaPolygon'>
<p>Area of a longitude/latitude polygon</p></a></li>
<li><a href='#bearing'>
<p>Direction of travel</p></a></li>
<li><a href='#bearingRhumb'>
<p>Rhumbline direction</p></a></li>
<li><a href='#centroid'><p>Centroid of spherical polygons</p></a></li>
<li><a href='#daylength'><p> Daylength</p></a></li>
<li><a href='#destPoint'>
<p>Destination given bearing (direction) and distance</p></a></li>
<li><a href='#destPointRhumb'>
<p>Destination along a rhumb line</p></a></li>
<li><a href='#dist2gc'>
<p>Cross Track Distance</p></a></li>
<li><a href='#dist2Line'>
<p>Distance between points and lines or the border of polygons.</p></a></li>
<li><a href='#distCosine'>
<p>'Law of cosines' great circle distance</p></a></li>
<li><a href='#distGeo'>
<p>Distance on an ellipsoid (the geodesic)</p></a></li>
<li><a href='#distHaversine'>
<p>'Haversine' great circle distance</p></a></li>
<li><a href='#distm'>
<p>Distance matrix</p></a></li>
<li><a href='#distMeeus'>
<p>'Meeus' great circle distance</p></a></li>
<li><a href='#distRhumb'>
<p>Distance along a rhumb line</p></a></li>
<li><a href='#distVincentyEllipsoid'>
<p>'Vincenty' (ellipsoid) great circle distance</p></a></li>
<li><a href='#distVincentySphere'>
<p>'Vincenty' (sphere) great circle distance</p></a></li>
<li><a href='#finalBearing'>
<p>Final direction</p></a></li>
<li><a href='#gcIntersect'>
<p>Intersections of two great circles</p></a></li>
<li><a href='#gcIntersectBearing'>
<p>Intersections of two great circles</p></a></li>
<li><a href='#gcLat'>
<p>Latitude on a Great Circle</p></a></li>
<li><a href='#gcLon'>
<p>Longitude on a Great Circle</p></a></li>
<li><a href='#gcMaxLat'>
<p>Highest latitude on a great circle</p></a></li>
<li><a href='#geodesic'>
<p>geodesic and inverse geodesic problem</p></a></li>
<li><a href='#geomean'>
<p>Mean location of sperhical coordinates</p></a></li>
<li><a href='#greatCircle'>
<p>Great circle</p></a></li>
<li><a href='#greatCircleBearing'>
<p>Great circle</p></a></li>
<li><a href='#horizon'><p>Distance to the horizon</p></a></li>
<li><a href='#intermediate'>
<p>Intermediate points on a great circle (sphere)</p></a></li>
<li><a href='#lengthLine'>
<p>Length of lines</p></a></li>
<li><a href='#makePoly'><p>Add vertices to a polygon or line</p></a></li>
<li><a href='#mercator'>
<p>Mercator projection</p></a></li>
<li><a href='#midPoint'><p>Mid-point</p></a></li>
<li><a href='#onGreatCircle'>
<p>Is a point on a given great circle?</p></a></li>
<li><a href='#perimeter'>
<p>Compute the perimeter of a longitude/latitude polygon</p></a></li>
<li><a href='#plotArrows'><p>Plot</p></a></li>
<li><a href='#randomCoordinates'>
<p>Random or regularly distributed coordinates on the globe</p></a></li>
<li><a href='#refEllipsoids'><p>Reference ellipsoids</p></a></li>
<li><a href='#span'><p>Span of polygons</p></a></li>
<li><a href='#wrld'><p>World countries</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Spherical Trigonometry</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5-18</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-11-13</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, sp</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>methods, raster</td>
</tr>
<tr>
<td>Description:</td>
<td>Spherical trigonometry for geographic applications. That is, compute distances and related measures for angular (longitude/latitude) locations. </td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rspatial/geosphere/issues/">https://github.com/rspatial/geosphere/issues/</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-13 17:35:52 UTC; rhijm</td>
</tr>
<tr>
<td>Author:</td>
<td>Robert J. Hijmans [cre, aut],
  Charles Karney [ctb] (GeographicLib),
  Ed Williams [ctb],
  Chris Vennes [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robert J. Hijmans &lt;r.hijmans@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-15 22:40:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='geosphere-package'>Geosphere</h2><span id='topic+geosphere-package'></span><span id='topic+geosphere'></span>

<h3>Description</h3>

<p>This package implements functions that compute various aspects of distance, direction, area, etc. for geographic (geodetic) coordinates. Some of the functions are based on an ellipsoid (spheroid) model of the world, other functions use a (simpler, but less accuarate) spherical model. Functions using an ellipsoid can be recognized by having arguments to specify the ellipsoid's radius and flattening (<code>a</code> and <code>f</code>). By setting the value for <code>f</code> to zero, the ellipsoid becomes a sphere. 
</p>
<p>There are also functions to compute intersections of of rhumb lines. There are also functions to compute the distance between points and polylines, and to characterize spherical polygons; for random sampling on a sphere, and to compute daylength. See the vignette <code>vignette('geosphere')</code> for examples.
</p>
<p>Geographic locations must be specified in latitude and longitude in degrees (NOT radians). Degrees are (obviously) in decimal notation. Thus 12 degrees, 30 minutes, 10 seconds = 12 + 30/60 + 10/3600 =  12.50278 degrees. The Southern and Western hemispheres have a negative sign.
</p>
<p>The default unit of distance is meter; but this can be adjusted by supplying a different radius <code>r</code> to functions.
</p>
<p>Directions are expressed in degrees (North = 0 and 360,  East = 90, Sout = 180, and West = 270 degrees).
</p>


<h3>Acknowledgements</h3>

<p>David Purdy, Bill Monahan and others for suggestions to improve the package.
</p>


<h3>Author(s)</h3>

<p>Robert Hijmans, using code by C.F.F. Karney and Chris Veness; formulas by Ed Williams; and with contributions from George Wang, Elias Pipping and others.
Maintainer: Robert J. Hijmans &lt;r.hijmans@gmail.com&gt;
</p>


<h3>References</h3>

<p>C.F.F. Karney, 2013. Algorithms for geodesics, J. Geodesy 87: 43-55. <a href="https://doi.org/10.1007/s00190-012-0578-z">doi:10.1007/s00190-012-0578-z</a>. Addenda: <a href="https://geographiclib.sourceforge.io/geod-addenda.html">https://geographiclib.sourceforge.io/geod-addenda.html</a>. Also see <a href="https://geographiclib.sourceforge.io/">https://geographiclib.sourceforge.io/</a>
</p>
<p><a href="https://www.edwilliams.org/avform147.htm">https://www.edwilliams.org/avform147.htm</a>
</p>
<p><a href="https://www.movable-type.co.uk/scripts/latlong.html">https://www.movable-type.co.uk/scripts/latlong.html</a>
</p>
<p><a href="https://en.wikipedia.org/wiki/Great_circle_distance">https://en.wikipedia.org/wiki/Great_circle_distance</a>
</p>
<p><a href="https://mathworld.wolfram.com/SphericalTrigonometry.html">https://mathworld.wolfram.com/SphericalTrigonometry.html</a>
</p>

<hr>
<h2 id='alongTrackDistance'>
Along Track Distance
</h2><span id='topic+alongTrackDistance'></span>

<h3>Description</h3>

<p>The &quot;along track distance&quot; is the distance from the start point (p1) to the closest point on the path to a third point (p3), 
following a great circle path defined by points p1 and p2. See <code><a href="#topic+dist2gc">dist2gc</a></code> for the &quot;cross track distance&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alongTrackDistance(p1, p2, p3, r=6378137)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alongTrackDistance_+3A_p1">p1</code></td>
<td>
<p>longitude/latitude of point(s). Can be a vector of two numbers, a matrix of 2 columns (first one is longitude, second is latitude) or a SpatialPoints* object</p>
</td></tr>
<tr><td><code id="alongTrackDistance_+3A_p2">p2</code></td>
<td>
<p>as above</p>
</td></tr>
<tr><td><code id="alongTrackDistance_+3A_p3">p3</code></td>
<td>
<p>as above</p>
</td></tr>
<tr><td><code id="alongTrackDistance_+3A_r">r</code></td>
<td>
<p>radius of the earth; default = 6378137m</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>A distance in units of r (default is meters)
</p>


<h3>Author(s)</h3>

<p> Ed Williams and Robert Hijmans </p>


<h3>See Also</h3>

<p><code> <a href="#topic+dist2gc">dist2gc</a>  </code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>alongTrackDistance(c(0,0),c(60,60),c(50,40))
</code></pre>

<hr>
<h2 id='antipode'>
Antipodes
</h2><span id='topic+antipode'></span><span id='topic+antipodal'></span>

<h3>Description</h3>

<p>Compute an antipode, or check whether two points are antipodes. Antipodes are places on Earth that are diametrically opposite to one another; 
and could be connected by a straight line through the centre of the Earth.
</p>
<p>Antipodal points are connected by an infinite number of great circles (e.g. the meridians connecting the poles), and can therefore not be used in some great circle based computations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>antipode(p)
antipodal(p1, p2, tol=1e-9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="antipode_+3A_p">p</code></td>
<td>
<p>Longitude/latitude of a single point, in degrees; can be a vector of two numbers, a matrix of 2 columns (first one is longitude, second is latitude) or a SpatialPoints* object</p>
</td></tr>
<tr><td><code id="antipode_+3A_p1">p1</code></td>
<td>
<p>as above</p>
</td></tr>
<tr><td><code id="antipode_+3A_p2">p2</code></td>
<td>
<p>as above</p>
</td></tr>
<tr><td><code id="antipode_+3A_tol">tol</code></td>
<td>
<p>tolerance for equality</p>
</td></tr>
</table>


<h3>Value</h3>

<p>antipodal points or a logical value (<code>TRUE</code> if antipodal)
</p>


<h3>Author(s)</h3>

<p> Robert Hijmans </p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Antipodes">https://en.wikipedia.org/wiki/Antipodes</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>antipode(rbind(c(5,52), c(-120,37), c(-60,0), c(0,70)))
antipodal(c(0,0), c(180,0))
</code></pre>

<hr>
<h2 id='areaPolygon'>
Area of a longitude/latitude polygon
</h2><span id='topic+areaPolygon'></span><span id='topic+areaPolygon+2Cmatrix-method'></span><span id='topic+areaPolygon+2Cdata.frame-method'></span><span id='topic+areaPolygon+2CSpatialPolygons-method'></span>

<h3>Description</h3>

<p>Compute the area of a polygon in angular coordinates (longitude/latitude) on an ellipsoid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'matrix'
areaPolygon(x, a=6378137, f=1/298.257223563, ...)

## S4 method for signature 'SpatialPolygons'
areaPolygon(x, a=6378137, f=1/298.257223563, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="areaPolygon_+3A_x">x</code></td>
<td>
<p>longitude/latitude of the points forming a polygon; Must be a matrix or data.frame of 2 columns (first one is longitude, second is latitude) or a SpatialPolygons* object</p>
</td></tr>
<tr><td><code id="areaPolygon_+3A_a">a</code></td>
<td>
<p>major (equatorial) radius of the ellipsoid</p>
</td></tr>
<tr><td><code id="areaPolygon_+3A_f">f</code></td>
<td>
<p>ellipsoid flattening. The default value is for WGS84 </p>
</td></tr>
<tr><td><code id="areaPolygon_+3A_...">...</code></td>
<td>
<p>Additional arguments. None implemented</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>area in square meters
</p>


<h3>Note</h3>

<p>Use raster::area for polygons that have a planar (projected) coordinate reference system. 
</p>


<h3>Author(s)</h3>

<p>This function calls GeographicLib code by C.F.F. Karney
</p>


<h3>References</h3>

<p>C.F.F. Karney, 2013. Algorithms for geodesics, J. Geodesy 87: 43-55. <a href="https://doi.org/10.1007/s00190-012-0578-z">doi:10.1007/s00190-012-0578-z</a>. Addenda: <a href="https://geographiclib.sourceforge.io/geod-addenda.html">https://geographiclib.sourceforge.io/geod-addenda.html</a>. Also see <a href="https://geographiclib.sourceforge.io/">https://geographiclib.sourceforge.io/</a>
</p>


<h3>See Also</h3>

<p><code> <a href="#topic+centroid">centroid</a>, <a href="#topic+perimeter">perimeter</a>  </code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- rbind(c(-180,-20), c(-140,55), c(10, 0), c(-140,-60), c(-180,-20))
areaPolygon(p)

# Be careful with very large polygons, as they may not be what they seem!
# For example, if you wanted a polygon to compute the area equal to about 1/4 of the ellipsoid
# this won't work:
b &lt;- matrix(c(-180, 0, 90, 90, 0, 0, -180, 0), ncol=2, byrow=TRUE)
areaPolygon(b)
# Becausee the shortest path between (-180,0) and (0,0) is 
# over one of the poles, not along the equator!
# Inserting a point along the equator fixes that
b &lt;- matrix(c(-180, 0, 0, 0, -90,0, -180, 0), ncol=2, byrow=TRUE)
areaPolygon(b)

</code></pre>

<hr>
<h2 id='bearing'>
Direction of travel
</h2><span id='topic+bearing'></span>

<h3>Description</h3>

<p>Get the initial bearing (direction; azimuth) to go from point <code>p1</code> to point <code>p2</code> (in longitude/latitude) following the shortest path on an ellipsoid (geodetic). Note that the bearing of travel changes continuously while going along the path. A route with constant bearing is a rhumb line (see  <code><a href="#topic+bearingRhumb">bearingRhumb</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bearing(p1, p2, a=6378137, f=1/298.257223563)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bearing_+3A_p1">p1</code></td>
<td>
<p>longitude/latitude of point(s). Can be a vector of two numbers, a matrix of 2 columns (first one is longitude, second is latitude) or a SpatialPoints* object</p>
</td></tr>
<tr><td><code id="bearing_+3A_p2">p2</code></td>
<td>
<p>as above. Can also be missing, in which case the bearing is computed going from the first point to the next and continuing along the following points</p>
</td></tr>
<tr><td><code id="bearing_+3A_a">a</code></td>
<td>
<p>major (equatorial) radius of the ellipsoid. The default value is for WGS84 </p>
</td></tr>
<tr><td><code id="bearing_+3A_f">f</code></td>
<td>
<p>ellipsoid flattening. The default value is for WGS84 </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Bearing in degrees
</p>


<h3>Note</h3>

<p>use <code>f=0</code> to get a bearing on a sphere (great circle)</p>


<h3>Author(s)</h3>

<p>Robert Hijmans
</p>


<h3>References</h3>

<p>C.F.F. Karney, 2013. Algorithms for geodesics, J. Geodesy 87: 43-55. <a href="https://doi.org/10.1007/s00190-012-0578-z">doi:10.1007/s00190-012-0578-z</a>. Addenda: <a href="https://geographiclib.sourceforge.io/geod-addenda.html">https://geographiclib.sourceforge.io/geod-addenda.html</a>. Also see <a href="https://geographiclib.sourceforge.io/">https://geographiclib.sourceforge.io/</a>
</p>


<h3>See Also</h3>

<p><code> <a href="#topic+bearingRhumb">bearingRhumb</a>  </code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bearing(c(10,10),c(20,20))
</code></pre>

<hr>
<h2 id='bearingRhumb'>
Rhumbline direction
</h2><span id='topic+bearingRhumb'></span>

<h3>Description</h3>

<p>Bearing (direction of travel; true course) along a rhumb line (loxodrome) between two points. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bearingRhumb(p1, p2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bearingRhumb_+3A_p1">p1</code></td>
<td>
<p>longitude/latitude of point(s). Can be a vector of two numbers, a matrix of 2 columns (first one is longitude, second is latitude) or a SpatialPoints* object</p>
</td></tr>
<tr><td><code id="bearingRhumb_+3A_p2">p2</code></td>
<td>
<p>as above</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A direction (bearing) in degrees
</p>


<h3>Note</h3>

<p>Unlike most great circles, a rhumb line is a line of constant bearing (direction), i.e. tracks of constant true course.
The meridians and the equator are both rhumb lines and great circles. Rhumb lines approaching a pole become a tightly wound spiral.
</p>


<h3>Author(s)</h3>

<p>Chris Veness and Robert Hijmans, based on formulae by Ed Williams
</p>


<h3>References</h3>

<p><a href="https://www.edwilliams.org/avform147.htm#Rhumb">https://www.edwilliams.org/avform147.htm#Rhumb</a>
</p>
<p><a href="https://en.wikipedia.org/wiki/Rhumb_line">https://en.wikipedia.org/wiki/Rhumb_line</a>
</p>


<h3>See Also</h3>

<p><code> <a href="#topic+bearing">bearing</a>,  <a href="#topic+distRhumb">distRhumb</a>  </code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bearingRhumb(c(10,10),c(20,20))
</code></pre>

<hr>
<h2 id='centroid'>Centroid of spherical polygons</h2><span id='topic+centroid'></span><span id='topic+centroid+2Cmatrix-method'></span><span id='topic+centroid+2Cdata.frame-method'></span><span id='topic+centroid+2CSpatialPolygons-method'></span>

<h3>Description</h3>

<p>Compute the centroid of longitude/latitude polygons. Unlike other functions in this package, there is no spherical trigonometry involved in the implementation of this function. Instead, the function projects the polygon to the (conformal) Mercator coordinate reference system, computes the centroid, and then inversely projects it to longitude and latitude. This approach fails for polygons that include one of the poles (and is rather biased for anything close to the poles). The function should work for polygons that cross the -180/180 meridian (date line). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centroid(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centroid_+3A_x">x</code></td>
<td>
<p>SpatialPolygons* object, or a 2-column matrix or data.frame reprenting a single polgyon (longitude/latitude)</p>
</td></tr>
<tr><td><code id="centroid_+3A_...">...</code></td>
<td>
<p>Additional arguments. None implemented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix (longitude/latitude)
</p>


<h3>Note</h3>

<p>For multi-part polygons, the centroid of the largest part is returned.
</p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans </p>


<h3>See Also</h3>

<p><code> <a href="#topic+area">area</a>, <a href="#topic+perimeter">perimeter</a>  </code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pol &lt;- rbind(c(-180,-20), c(-160,5), c(-60, 0), c(-160,-60), c(-180,-20))
centroid(pol) 
</code></pre>

<hr>
<h2 id='daylength'> Daylength </h2><span id='topic+daylength'></span>

<h3>Description</h3>

<p>Compute daylength (photoperiod) for a latitude and date.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>daylength(lat, doy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="daylength_+3A_lat">lat</code></td>
<td>
<p>latitude, in degrees. I.e. between -90.0 and 90.0 </p>
</td></tr>
<tr><td><code id="daylength_+3A_doy">doy</code></td>
<td>
<p>integer, day of the year (1..365) for common (non-leap) years; or an object of class Date; or a character that can be coerced into a date, using 'yyyy-mm-dd' format, e.g. '1982-11-23' </p>
</td></tr>  
</table>


<h3>Value</h3>

<p>Daylength in hours
</p>


<h3>Author(s)</h3>

<p> Robert J. Hijmans </p>


<h3>References</h3>

<p>Forsythe, William C., Edward J. Rykiel Jr., Randal S. Stahl, Hsin-i Wu and Robert M. Schoolfield, 1995. A model comparison for daylength as a function of latitude and day of the year. Ecological Modeling 80:87-95.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>daylength(-25, '2010-10-10')
daylength(45, 1:365)

# average monthly daylength
dl &lt;- daylength(45, 1:365)
tapply(dl, rep(1:12, c(31,28,31,30,31,30,31,31,30,31,30,31)), mean)

</code></pre>

<hr>
<h2 id='destPoint'>
Destination given bearing (direction) and distance
</h2><span id='topic+destPoint'></span>

<h3>Description</h3>

<p>Given a start point, initial bearing (direction), and distance, this function computes the destination point travelling along a the shortest path on an ellipsoid (the geodesic).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>destPoint(p, b, d, a=6378137, f=1/298.257223563, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="destPoint_+3A_p">p</code></td>
<td>
<p>Longitude and Latitude of point(s), in degrees. Can be a vector of two numbers, a matrix of 2 columns (first one is longitude, second is latitude) or a SpatialPoints* object</p>
</td></tr>
<tr><td><code id="destPoint_+3A_b">b</code></td>
<td>
<p>numeric. Bearing (direction) in degrees</p>
</td></tr>
<tr><td><code id="destPoint_+3A_d">d</code></td>
<td>
<p>numeric. Distance in meters</p>
</td></tr>
<tr><td><code id="destPoint_+3A_a">a</code></td>
<td>
<p>major (equatorial) radius of the ellipsoid. The default value is for WGS84 </p>
</td></tr>
<tr><td><code id="destPoint_+3A_f">f</code></td>
<td>
<p>ellipsoid flattening. The default value is for WGS84 </p>
</td></tr> 
<tr><td><code id="destPoint_+3A_...">...</code></td>
<td>
<p>additional arguments. If an argument 'r' is supplied, this is taken as the radius of the earth (e.g. 6378137 m) and computations are for a sphere (great circle) instead of an ellipsoid (geodetic). This is for backwards compatibility only</p>
</td></tr>    
</table>


<h3>Value</h3>

<p>A pair of coordinates (longitude/latitude)
</p>


<h3>Note</h3>

<p>Direction changes continuously when travelling along a geodesic. Therefore, the final direction is not the same as the initial direction. You can compute the final direction with <code><a href="#topic+finalBearing">finalBearing</a></code> (see examples, below)
</p>


<h3>Author(s)</h3>

<p>This function calls GeographicLib code by C.F.F. Karney
</p>


<h3>References</h3>

<p>C.F.F. Karney, 2013. Algorithms for geodesics, J. Geodesy 87: 43-55. <a href="https://doi.org/10.1007/s00190-012-0578-z">doi:10.1007/s00190-012-0578-z</a>. Addenda: <a href="https://geographiclib.sourceforge.io/geod-addenda.html">https://geographiclib.sourceforge.io/geod-addenda.html</a>. Also see <a href="https://geographiclib.sourceforge.io/">https://geographiclib.sourceforge.io/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- cbind(5,52)
d &lt;- destPoint(p,30,10000)
d

#final direction, when arriving at endpoint: 
finalBearing(d, p)
</code></pre>

<hr>
<h2 id='destPointRhumb'>
Destination along a rhumb line
</h2><span id='topic+destPointRhumb'></span>

<h3>Description</h3>

<p>Calculate the destination point when travelling along a 'rhumb line' (loxodrome), given a start point, direction, and distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>destPointRhumb(p, b, d, r = 6378137)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="destPointRhumb_+3A_p">p</code></td>
<td>
<p>longitude/latitude of point(s). Can be a vector of two numbers, a matrix of 2 columns (first one is longitude, second is latitude) or a SpatialPoints* object</p>
</td></tr>
<tr><td><code id="destPointRhumb_+3A_b">b</code></td>
<td>
<p>bearing (direction) in degrees</p>
</td></tr>
<tr><td><code id="destPointRhumb_+3A_d">d</code></td>
<td>
<p>distance; in the same unit as <code>r</code> (default is meters)</p>
</td></tr>
<tr><td><code id="destPointRhumb_+3A_r">r</code></td>
<td>
<p>radius of the earth; default = 6378137 m</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>Coordinates (longitude/latitude) of a point
</p>


<h3>Author(s)</h3>

<p>Chris Veness; ported to R by Robert Hijmans
</p>


<h3>References</h3>

<p><a href="https://www.edwilliams.org/avform147.htm#Rhumb">https://www.edwilliams.org/avform147.htm#Rhumb</a>
</p>
<p><a href="https://www.movable-type.co.uk/scripts/latlong.html">https://www.movable-type.co.uk/scripts/latlong.html</a>
</p>
<p><a href="https://en.wikipedia.org/wiki/Rhumb_line">https://en.wikipedia.org/wiki/Rhumb_line</a>
</p>


<h3>See Also</h3>

<p><code> <a href="#topic+destPoint">destPoint</a>  </code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>destPointRhumb(c(0,0), 30, 100000, r = 6378137)
</code></pre>

<hr>
<h2 id='dist2gc'>
Cross Track Distance
</h2><span id='topic+dist2gc'></span>

<h3>Description</h3>

<p>Compute the distance of a point to a great-circle path (also referred to as the cross track distance or cross track error). The great circle is defined by <code>p1</code> and <code>p2</code>, while <code>p3</code> is the point away from the path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist2gc(p1, p2, p3, r=6378137, sign=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist2gc_+3A_p1">p1</code></td>
<td>
<p>Start of great circle path. longitude/latitude of point(s). Can be a vector of two numbers, a matrix of 2 columns (first one is longitude, second is latitude) or a SpatialPoints* object</p>
</td></tr>
<tr><td><code id="dist2gc_+3A_p2">p2</code></td>
<td>
<p>End of great circle path. As above</p>
</td></tr>
<tr><td><code id="dist2gc_+3A_p3">p3</code></td>
<td>
<p>Point away from the great cricle path. As for p2</p>
</td></tr>
<tr><td><code id="dist2gc_+3A_r">r</code></td>
<td>
<p>radius of the earth; default = 6378137</p>
</td></tr>  
<tr><td><code id="dist2gc_+3A_sign">sign</code></td>
<td>
<p>logical. If <code>TRUE</code>, a negative sign is used to indicated that the points are to the left of the great circle</p>
</td></tr>    
</table>


<h3>Value</h3>

<p>A distance in units of <code>r</code> (default is meters)
If <code>sign=TRUE</code>, the sign indicates which side of the path p3 is on. Positive  means right of the course from p1 to p2, negative means left.
</p>


<h3>Author(s)</h3>

<p>Ed Williams and Robert Hijmans
</p>


<h3>References</h3>

<p><a href="https://www.movable-type.co.uk/scripts/latlong.html">https://www.movable-type.co.uk/scripts/latlong.html</a>
</p>
<p><a href="https://www.edwilliams.org/ftp/avsig/avform.txt">https://www.edwilliams.org/ftp/avsig/avform.txt</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dist2Line">dist2Line</a>, <a href="#topic+alongTrackDistance">alongTrackDistance</a>  </code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dist2gc(c(0,0),c(90,90),c(80,80))
</code></pre>

<hr>
<h2 id='dist2Line'>
Distance between points and lines or the border of polygons.
</h2><span id='topic+dist2Line'></span>

<h3>Description</h3>

<p>The shortest distance between points and polylines or polygons. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist2Line(p, line, distfun=distGeo)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist2Line_+3A_p">p</code></td>
<td>
<p>longitude/latitude of point(s). Can be a vector of two numbers, a matrix of 2 columns (first one is longitude, second is latitude) or a SpatialPoints* object</p>
</td></tr>
<tr><td><code id="dist2Line_+3A_line">line</code></td>
<td>
<p>longitude/latitude of line as a matrix of 2 columns (first one is longitude, second is latitude) or a SpatialLines* or SpatialPolygons* object</p>
</td></tr>
<tr><td><code id="dist2Line_+3A_distfun">distfun</code></td>
<td>
<p>A distance function, such as <a href="#topic+distGeo">distGeo</a></p>
</td></tr>  
</table>


<h3>Value</h3>

<p>matrix with distance and lon/lat of the nearest point on the line. Distance is in the same unit as <code>r</code> in the <code>distfun</code>(default is meters). If <code>line</code> is a <code>Spatial*</code> object, the ID (index) of (one of) the nearest objects is also returned. Thus if the objects are polygons and the point is inside a polygon the function may return the ID of a neighboring polygon that shares the nearest border. You can use the <code>intersect</code> function in packages <code>terra</code>.
</p>


<h3>Author(s)</h3>

<p>George Wang and Robert Hijmans
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dist2gc">dist2gc</a>, <a href="#topic+alongTrackDistance">alongTrackDistance</a>  </code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>line &lt;- rbind(c(-180,-20), c(-150,-10), c(-140,55), c(10, 0), c(-140,-60))
pnts &lt;- rbind(c(-170,0), c(-75,0), c(-70,-10), c(-80,20), c(-100,-50), 
         c(-100,-60), c(-100,-40), c(-100,-20), c(-100,-10), c(-100,0))
d = dist2Line(pnts, line)
plot( makeLine(line), type='l')
points(line)
points(pnts, col='blue', pch=20)
points(d[,2], d[,3], col='red', pch='x')
for (i in 1:nrow(d)) lines(gcIntermediate(pnts[i,], d[i,2:3], 10), lwd=2)
</code></pre>

<hr>
<h2 id='distCosine'>
'Law of cosines' great circle distance
</h2><span id='topic+distCosine'></span>

<h3>Description</h3>

<p>The shortest distance between two points (i.e., the 'great-circle-distance' or 'as the crow flies'), according to the 'law of the cosines'.
This method assumes a spherical earth, ignoring ellipsoidal effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distCosine(p1, p2, r=6378137)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distCosine_+3A_p1">p1</code></td>
<td>
<p>longitude/latitude of point(s). Can be a vector of two numbers, a matrix of 2 columns (first one is longitude, second is latitude) or a SpatialPoints* object</p>
</td></tr>
<tr><td><code id="distCosine_+3A_p2">p2</code></td>
<td>
<p>as above</p>
</td></tr>
<tr><td><code id="distCosine_+3A_r">r</code></td>
<td>
<p>radius of the earth; default = 6378137 m</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>Vector of distances in the same unit as <code>r</code> (default is meters)
</p>


<h3>Author(s)</h3>

<p>Robert Hijmans
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Great_circle_distance">https://en.wikipedia.org/wiki/Great_circle_distance</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distGeo">distGeo</a>, <a href="#topic+distHaversine">distHaversine</a>, <a href="#topic+distVincentySphere">distVincentySphere</a>, <a href="#topic+distVincentyEllipsoid">distVincentyEllipsoid</a>, <a href="#topic+distMeeus">distMeeus</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>distCosine(c(0,0),c(90,90))
</code></pre>

<hr>
<h2 id='distGeo'>
Distance on an ellipsoid (the geodesic)
</h2><span id='topic+distGeo'></span>

<h3>Description</h3>

<p>Highly accurate estimate of the shortest distance between two points on an ellipsoid (default is WGS84 ellipsoid).
The shortest path between two points on an ellipsoid is called the geodesic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distGeo(p1, p2, a=6378137, f=1/298.257223563)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distGeo_+3A_p1">p1</code></td>
<td>
<p>longitude/latitude of point(s). Can be a vector of two numbers, a matrix of 2 columns (first column is longitude, second column is latitude) or a SpatialPoints* object</p>
</td></tr>
<tr><td><code id="distGeo_+3A_p2">p2</code></td>
<td>
<p>as above; or missing, in which case the sequential distance between the points in p1 is computed</p>
</td></tr>
<tr><td><code id="distGeo_+3A_a">a</code></td>
<td>
<p>numeric. Major (equatorial) radius of the ellipsoid. The default value is for WGS84 </p>
</td></tr>
<tr><td><code id="distGeo_+3A_f">f</code></td>
<td>
<p>numeric. Ellipsoid flattening. The default value is for WGS84 </p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Parameters from the WGS84 ellipsoid are used by default. It is the best available global ellipsoid, but for some areas other ellipsoids could be preferable, or even necessary if you work with a printed map that refers to that ellipsoid. Here are parameters for some commonly used ellipsoids. Also see the <code><a href="#topic+refEllipsoids">refEllipsoids</a></code> function.
</p>

<table>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code> ellipsoid          </code> </td><td style="text-align: left;"> <code> a            </code> </td><td style="text-align: left;"> <code> f               </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code> WGS84	            </code> </td><td style="text-align: left;"> <code> 6378137      </code> </td><td style="text-align: left;"> <code> 1/298.257223563 </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code> GRS80	            </code> </td><td style="text-align: left;"> <code> 6378137      </code> </td><td style="text-align: left;"> <code> 1/298.257222101 </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code> GRS67              </code> </td><td style="text-align: left;"> <code> 6378160      </code> </td><td style="text-align: left;"> <code> 1/298.25        </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code> Airy 1830          </code> </td><td style="text-align: left;"> <code> 6377563.396  </code> </td><td style="text-align: left;"> <code> 1/299.3249646   </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code> Bessel 1841        </code> </td><td style="text-align: left;"> <code> 6377397.155  </code> </td><td style="text-align: left;"> <code> 1/299.1528434   </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code> Clarke 1880        </code> </td><td style="text-align: left;"> <code> 6378249.145  </code> </td><td style="text-align: left;"> <code> 1/293.465       </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code> Clarke 1866        </code> </td><td style="text-align: left;"> <code> 6378206.4    </code> </td><td style="text-align: left;"> <code> 1/294.9786982   </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code> International 1924 </code> </td><td style="text-align: left;"> <code> 6378388      </code> </td><td style="text-align: left;"> <code> 1/297           </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code> Krasovsky 1940     </code> </td><td style="text-align: left;"> <code> 6378245      </code> </td><td style="text-align: left;"> <code> 1/298.2997381   </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>

<p>more info: <a href="https://en.wikipedia.org/wiki/Reference_ellipsoid">https://en.wikipedia.org/wiki/Reference_ellipsoid</a>		
</p>


<h3>Value</h3>

<p>Vector of distances in meters
</p>


<h3>Author(s)</h3>

<p>This function calls GeographicLib code by C.F.F. Karney
</p>


<h3>References</h3>

<p>C.F.F. Karney, 2013. Algorithms for geodesics, J. Geodesy 87: 43-55. <a href="https://doi.org/10.1007/s00190-012-0578-z">doi:10.1007/s00190-012-0578-z</a>. Addenda: <a href="https://geographiclib.sourceforge.io/geod-addenda.html">https://geographiclib.sourceforge.io/geod-addenda.html</a>. Also see <a href="https://geographiclib.sourceforge.io/">https://geographiclib.sourceforge.io/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distCosine">distCosine</a>, <a href="#topic+distHaversine">distHaversine</a>, <a href="#topic+distVincentySphere">distVincentySphere</a>, <a href="#topic+distVincentyEllipsoid">distVincentyEllipsoid</a>, <a href="#topic+distMeeus">distMeeus</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>distGeo(c(0,0),c(90,90))
</code></pre>

<hr>
<h2 id='distHaversine'>
'Haversine' great circle distance
</h2><span id='topic+distHaversine'></span>

<h3>Description</h3>

<p>The shortest distance between two points (i.e., the 'great-circle-distance' or 'as the crow flies'), according to the 'haversine method'.
This method assumes a spherical earth, ignoring ellipsoidal effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distHaversine(p1, p2, r=6378137)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distHaversine_+3A_p1">p1</code></td>
<td>
<p>longitude/latitude of point(s). Can be a vector of two numbers, a matrix of 2 columns (first one is longitude, second is latitude) or a SpatialPoints* object</p>
</td></tr>
<tr><td><code id="distHaversine_+3A_p2">p2</code></td>
<td>
<p>as above; or missing, in which case the sequential distance between the points in p1 is computed</p>
</td></tr>
<tr><td><code id="distHaversine_+3A_r">r</code></td>
<td>
<p>radius of the earth; default = 6378137 m</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>The Haversine ('half-versed-sine') formula was published by R.W. Sinnott in 1984, although it has been known  for much longer. At that time computational precision was lower than today (15 digits precision). With current precision, the spherical law of cosines formula appears to give equally good results down to very small distances. If you want greater accuracy, you could use the <code><a href="#topic+distVincentyEllipsoid">distVincentyEllipsoid</a></code> method.
</p>


<h3>Value</h3>

<p>Vector of distances in the same unit as <code>r</code> (default is meters)
</p>


<h3>Author(s)</h3>

<p>Chris Veness and Robert Hijmans
</p>


<h3>References</h3>

<p>Sinnott, R.W, 1984. Virtues of the Haversine. Sky and Telescope 68(2): 159
</p>
<p><a href="https://www.movable-type.co.uk/scripts/latlong.html">https://www.movable-type.co.uk/scripts/latlong.html</a>
</p>
<p><a href="https://en.wikipedia.org/wiki/Great_circle_distance">https://en.wikipedia.org/wiki/Great_circle_distance</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distGeo">distGeo</a>, <a href="#topic+distCosine">distCosine</a>, <a href="#topic+distVincentySphere">distVincentySphere</a>, <a href="#topic+distVincentyEllipsoid">distVincentyEllipsoid</a>, <a href="#topic+distMeeus">distMeeus</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>distHaversine(c(0,0),c(90,90))
</code></pre>

<hr>
<h2 id='distm'>
Distance matrix
</h2><span id='topic+distm'></span>

<h3>Description</h3>

<p>Distance matrix of a set of points, or between two sets of points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distm(x, y, fun=distGeo)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distm_+3A_x">x</code></td>
<td>
<p>longitude/latitude of point(s). Can be a vector of two numbers, a matrix of 2 columns (first one is longitude, second is latitude) or a SpatialPoints* object</p>
</td></tr>
<tr><td><code id="distm_+3A_y">y</code></td>
<td>
<p>Same as <code>x</code>. If missing, y is the same as x</p>
</td></tr>
<tr><td><code id="distm_+3A_fun">fun</code></td>
<td>
<p>A function to compute distances (e.g., distCosine or distGeo)</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>Matrix of distances
</p>


<h3>Author(s)</h3>

<p>Robert Hijmans
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Great_circle_distance">https://en.wikipedia.org/wiki/Great_circle_distance</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distGeo">distGeo</a>, <a href="#topic+distCosine">distCosine</a>, <a href="#topic+distHaversine">distHaversine</a>, <a href="#topic+distVincentySphere">distVincentySphere</a>, <a href="#topic+distVincentyEllipsoid">distVincentyEllipsoid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xy &lt;- rbind(c(0,0),c(90,90),c(10,10),c(-120,-45))
distm(xy)
xy2 &lt;- rbind(c(0,0),c(10,-10))
distm(xy, xy2)
</code></pre>

<hr>
<h2 id='distMeeus'>
'Meeus' great circle distance
</h2><span id='topic+distMeeus'></span>

<h3>Description</h3>

<p>The shortest distance between two points on an ellipsoid (the 'geodetic'), according to the 'Meeus' method. <code><a href="#topic+distGeo">distGeo</a></code> should be more accurate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distMeeus(p1, p2, a=6378137, f=1/298.257223563)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distMeeus_+3A_p1">p1</code></td>
<td>
<p>longitude/latitude of point(s), in degrees 1; can be a vector of two numbers, a matrix of 2 columns (first one is longitude, second is latitude) or a SpatialPoints* object</p>
</td></tr>
<tr><td><code id="distMeeus_+3A_p2">p2</code></td>
<td>
<p>as above; or missing, in which case the sequential distance between the points in p1 is computed</p>
</td></tr>
<tr><td><code id="distMeeus_+3A_a">a</code></td>
<td>
<p>numeric. Major (equatorial) radius of the ellipsoid. The default value is for WGS84 </p>
</td></tr>
<tr><td><code id="distMeeus_+3A_f">f</code></td>
<td>
<p>numeric. Ellipsoid flattening. The default value is for WGS84 </p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Parameters from the WGS84 ellipsoid are used by default. It is the best available global ellipsoid, but for some areas other ellipsoids could be preferable, or even necessary if you work with a printed map that refers to that ellipsoid. Here are parameters for some commonly used ellipsoids:
</p>

<table>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code> ellipsoid          </code> </td><td style="text-align: left;"> <code> a            </code> </td><td style="text-align: left;"> <code> f               </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code> WGS84	            </code> </td><td style="text-align: left;"> <code> 6378137      </code> </td><td style="text-align: left;"> <code> 1/298.257223563 </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code> GRS80	            </code> </td><td style="text-align: left;"> <code> 6378137      </code> </td><td style="text-align: left;"> <code> 1/298.257222101 </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code> GRS67              </code> </td><td style="text-align: left;"> <code> 6378160      </code> </td><td style="text-align: left;"> <code> 1/298.25        </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code> Airy 1830          </code> </td><td style="text-align: left;"> <code> 6377563.396  </code> </td><td style="text-align: left;"> <code> 1/299.3249646   </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code> Bessel 1841        </code> </td><td style="text-align: left;"> <code> 6377397.155  </code> </td><td style="text-align: left;"> <code> 1/299.1528434   </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code> Clarke 1880        </code> </td><td style="text-align: left;"> <code> 6378249.145  </code> </td><td style="text-align: left;"> <code> 1/293.465       </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code> Clarke 1866        </code> </td><td style="text-align: left;"> <code> 6378206.4    </code> </td><td style="text-align: left;"> <code> 1/294.9786982   </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code> International 1924 </code> </td><td style="text-align: left;"> <code> 6378388      </code> </td><td style="text-align: left;"> <code> 1/297           </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code> Krasovsky 1940     </code> </td><td style="text-align: left;"> <code> 6378245      </code> </td><td style="text-align: left;"> <code> 1/298.2997381   </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>

<p>more info: <a href="https://en.wikipedia.org/wiki/Reference_ellipsoid">https://en.wikipedia.org/wiki/Reference_ellipsoid</a>
</p>


<h3>Value</h3>

<p>Distance value in the same units as parameter <code>a</code> of the ellipsoid (default is meters)
</p>


<h3>Note</h3>

<p> This algorithm is also used in the <code>spDists</code> function in the sp package </p>


<h3>Author(s)</h3>

<p>Robert Hijmans, based on a script by Stephen R. Schmitt
</p>


<h3>References</h3>

<p>Meeus, J., 1999 (2nd edition). Astronomical algoritms. Willman-Bell, 477p.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distGeo">distGeo</a>, <a href="#topic+distVincentyEllipsoid">distVincentyEllipsoid</a>, <a href="#topic+distVincentySphere">distVincentySphere</a>, <a href="#topic+distHaversine">distHaversine</a>, <a href="#topic+distCosine">distCosine</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>distMeeus(c(0,0),c(90,90))
# on a 'Clarke 1880' ellipsoid
distMeeus(c(0,0),c(90,90), a=6378249.145, f=1/293.465)
</code></pre>

<hr>
<h2 id='distRhumb'>
Distance along a rhumb line
</h2><span id='topic+distRhumb'></span>

<h3>Description</h3>

<p>A rhumb line (loxodrome) is a path of constant bearing (direction), which crosses all meridians at the same angle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distRhumb(p1, p2, r=6378137)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distRhumb_+3A_p1">p1</code></td>
<td>
<p>longitude/latitude of point(s). Can be a vector of two numbers, a matrix of 2 columns (first one is longitude, second is latitude) or a SpatialPoints* object</p>
</td></tr>
<tr><td><code id="distRhumb_+3A_p2">p2</code></td>
<td>
<p>as above; or missing, in which case the sequential distance between the points in p1 is computed</p>
</td></tr>
<tr><td><code id="distRhumb_+3A_r">r</code></td>
<td>
<p>radius of the earth; default = 6378137 m</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Rhumb (from the Spanish word for course, 'rumbo') lines are straight lines on a Mercator projection map. They were used in navigation because it is easier to follow a constant compass bearing than to continually adjust the bearing as is needed to follow a great circle, even though rhumb lines are normally longer than great-circle (orthodrome) routes. Most rhumb lines will gradually spiral towards one of the poles.
</p>


<h3>Value</h3>

<p>distance in units of r (default=meters)
</p>


<h3>Author(s)</h3>

<p>Robert Hijmans and Chris Veness
</p>


<h3>References</h3>

<p><a href="https://www.movable-type.co.uk/scripts/latlong.html">https://www.movable-type.co.uk/scripts/latlong.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distCosine">distCosine</a>, <a href="#topic+distHaversine">distHaversine</a>, <a href="#topic+distVincentySphere">distVincentySphere</a>, <a href="#topic+distVincentyEllipsoid">distVincentyEllipsoid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>distRhumb(c(10,10),c(20,20))
</code></pre>

<hr>
<h2 id='distVincentyEllipsoid'>
'Vincenty' (ellipsoid) great circle distance
</h2><span id='topic+distVincentyEllipsoid'></span>

<h3>Description</h3>

<p>The shortest distance between two points (i.e., the 'great-circle-distance' or 'as the crow flies'), according to the 'Vincenty (ellipsoid)' method. 
This method uses an ellipsoid and the results are very accurate. The method is computationally more intensive than the other great-circled methods in this package. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distVincentyEllipsoid(p1, p2, a=6378137, b=6356752.3142, f=1/298.257223563)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distVincentyEllipsoid_+3A_p1">p1</code></td>
<td>
<p>longitude/latitude of point(s), in degrees 1; can be a vector of two numbers, a matrix of 2 columns (first one is longitude, second is latitude) or a SpatialPoints* object</p>
</td></tr>
<tr><td><code id="distVincentyEllipsoid_+3A_p2">p2</code></td>
<td>
<p>as above; or missing, in which case the sequential distance between the points in p1 is computed</p>
</td></tr>
<tr><td><code id="distVincentyEllipsoid_+3A_a">a</code></td>
<td>
<p>Equatorial axis of ellipsoid</p>
</td></tr>
<tr><td><code id="distVincentyEllipsoid_+3A_b">b</code></td>
<td>
<p>Polar axis of ellipsoid</p>
</td></tr>
<tr><td><code id="distVincentyEllipsoid_+3A_f">f</code></td>
<td>
<p>Inverse flattening of ellipsoid</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The WGS84 ellipsoid is used by default. It is the best available global ellipsoid, but for some areas other ellipsoids could be preferable, or even necessary if you work with a printed map that refers to that ellipsoid. Here are parameters for some commonly used ellipsoids:
</p>

<table>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code> ellipsoid          </code> </td><td style="text-align: left;"> <code> a            </code> </td><td style="text-align: left;"> <code> b              </code> </td><td style="text-align: left;"> <code> f               </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code> WGS84	            </code> </td><td style="text-align: left;"> <code> 6378137      </code> </td><td style="text-align: left;"> <code> 6356752.3142   </code> </td><td style="text-align: left;"> <code> 1/298.257223563 </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code> GRS80	            </code> </td><td style="text-align: left;"> <code> 6378137      </code> </td><td style="text-align: left;"> <code> 6356752.3141   </code> </td><td style="text-align: left;"> <code> 1/298.257222101 </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code> GRS67              </code> </td><td style="text-align: left;"> <code> 6378160      </code> </td><td style="text-align: left;"> <code> 6356774.719    </code> </td><td style="text-align: left;"> <code> 1/298.25        </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code> Airy 1830          </code> </td><td style="text-align: left;"> <code> 6377563.396  </code> </td><td style="text-align: left;"> <code> 6356256.909    </code> </td><td style="text-align: left;"> <code> 1/299.3249646   </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code> Bessel 1841        </code> </td><td style="text-align: left;"> <code> 6377397.155  </code> </td><td style="text-align: left;"> <code> 6356078.965    </code> </td><td style="text-align: left;"> <code> 1/299.1528434   </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code> Clarke 1880        </code> </td><td style="text-align: left;"> <code> 6378249.145  </code> </td><td style="text-align: left;"> <code> 6356514.86955  </code> </td><td style="text-align: left;"> <code> 1/293.465       </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code> Clarke 1866        </code> </td><td style="text-align: left;"> <code> 6378206.4    </code> </td><td style="text-align: left;"> <code> 6356583.8      </code> </td><td style="text-align: left;"> <code> 1/294.9786982   </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code> International 1924 </code> </td><td style="text-align: left;"> <code> 6378388      </code> </td><td style="text-align: left;"> <code> 6356911.946    </code> </td><td style="text-align: left;"> <code> 1/297           </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code> Krasovsky 1940     </code> </td><td style="text-align: left;"> <code> 6378245      </code> </td><td style="text-align: left;"> <code> 6356863        </code> </td><td style="text-align: left;"> <code> 1/298.2997381   </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>

<p><code>a</code> is the 'semi-major axis', and <code>b</code> is the 'semi-minor axis' of the ellipsoid. <code>f</code> is the flattening.
Note that <code>f = (a-b)/a</code>
</p>
<p>more info: <a href="https://en.wikipedia.org/wiki/Reference_ellipsoid">https://en.wikipedia.org/wiki/Reference_ellipsoid</a>
</p>


<h3>Value</h3>

<p>Distance value in the same units as the ellipsoid (default is meters)
</p>


<h3>Author(s)</h3>

<p>Chris Veness and Robert Hijmans
</p>


<h3>References</h3>

<p>Vincenty, T. 1975. Direct and inverse solutions of geodesics on the ellipsoid with application of nested equations. Survey Review Vol. 23, No. 176, pp88-93.
Available here: 
</p>
<p><a href="https://www.movable-type.co.uk/scripts/latlong-vincenty.html">https://www.movable-type.co.uk/scripts/latlong-vincenty.html</a>
</p>
<p><a href="https://en.wikipedia.org/wiki/Great_circle_distance">https://en.wikipedia.org/wiki/Great_circle_distance</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distGeo">distGeo</a>, <a href="#topic+distVincentySphere">distVincentySphere</a>, <a href="#topic+distHaversine">distHaversine</a>, <a href="#topic+distCosine">distCosine</a>, <a href="#topic+distMeeus">distMeeus</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>distVincentyEllipsoid(c(0,0),c(90,90))
# on a 'Clarke 1880' ellipsoid
distVincentyEllipsoid(c(0,0),c(90,90), a=6378249.145, b=6356514.86955, f=1/293.465)
</code></pre>

<hr>
<h2 id='distVincentySphere'>
'Vincenty' (sphere) great circle distance
</h2><span id='topic+distVincentySphere'></span>

<h3>Description</h3>

<p>The shortest distance between two points (i.e., the 'great-circle-distance' or 'as the crow flies'), according to the 'Vincenty (sphere)' method. 
This method assumes a spherical earth, ignoring ellipsoidal effects and it is less accurate then the <code>distVicentyEllipsoid</code> method. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distVincentySphere(p1, p2, r=6378137)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distVincentySphere_+3A_p1">p1</code></td>
<td>
<p>longitude/latitude of point(s). Can be a vector of two numbers, a matrix of 2 columns (first one is longitude, second is latitude) or a SpatialPoints* object</p>
</td></tr>
<tr><td><code id="distVincentySphere_+3A_p2">p2</code></td>
<td>
<p>as above; or missing, in which case the sequential distance between the points in p1 is computed</p>
</td></tr>
<tr><td><code id="distVincentySphere_+3A_r">r</code></td>
<td>
<p>radius of the earth; default = 6378137 m</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>Distance value in the same unit as <code>r</code> (default is meters)
</p>


<h3>Author(s)</h3>

<p>Robert Hijmans
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Great_circle_distance">https://en.wikipedia.org/wiki/Great_circle_distance</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distGeo">distGeo</a>, <a href="#topic+distVincentyEllipsoid">distVincentyEllipsoid</a>, <a href="#topic+distHaversine">distHaversine</a>, <a href="#topic+distCosine">distCosine</a>, <a href="#topic+distMeeus">distMeeus</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>distVincentySphere(c(0,0),c(90,90))
</code></pre>

<hr>
<h2 id='finalBearing'>
Final direction
</h2><span id='topic+finalBearing'></span>

<h3>Description</h3>

<p>Get the final direction (bearing) when arriving at <code>p2</code> after starting from <code>p1</code> and following the shortest path on an ellipsoid (following a geodetic) or on a sphere (following a great circle).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>finalBearing(p1, p2, a=6378137, f=1/298.257223563, sphere=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="finalBearing_+3A_p1">p1</code></td>
<td>
<p>longitude/latitude of point(s). Can be a vector of two numbers, a matrix of 2 columns (first column is longitude, second column is latitude) or a SpatialPoints* object</p>
</td></tr>
<tr><td><code id="finalBearing_+3A_p2">p2</code></td>
<td>
<p>as above</p>
</td></tr>
<tr><td><code id="finalBearing_+3A_a">a</code></td>
<td>
<p>major (equatorial) radius of the ellipsoid. The default value is for WGS84 </p>
</td></tr>
<tr><td><code id="finalBearing_+3A_f">f</code></td>
<td>
<p>ellipsoid flattening. The default value is for WGS84 </p>
</td></tr>
<tr><td><code id="finalBearing_+3A_sphere">sphere</code></td>
<td>
<p>logical. If <code>TRUE</code>, the bearing is computed for a sphere, instead of for an ellipsoid</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>A vector of directions (bearings) in degrees
</p>


<h3>Author(s)</h3>

<p>This function calls GeographicLib code by C.F.F. Karney
</p>


<h3>References</h3>

<p>C.F.F. Karney, 2013. Algorithms for geodesics, J. Geodesy 87: 43-55. <a href="https://doi.org/10.1007/s00190-012-0578-z">doi:10.1007/s00190-012-0578-z</a>. Addenda: <a href="https://geographiclib.sourceforge.io/geod-addenda.html">https://geographiclib.sourceforge.io/geod-addenda.html</a>. Also see <a href="https://geographiclib.sourceforge.io/">https://geographiclib.sourceforge.io/</a>
</p>


<h3>See Also</h3>

<p><code> <a href="#topic+bearing">bearing</a>  </code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bearing(c(10,10),c(20,20))
finalBearing(c(10,10),c(20,20))
</code></pre>

<hr>
<h2 id='gcIntersect'>
Intersections of two great circles
</h2><span id='topic+gcIntersect'></span>

<h3>Description</h3>

<p>Get the two points where two great cricles cross each other. Great circles are defined by two points on it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gcIntersect(p1, p2, p3, p4) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gcIntersect_+3A_p1">p1</code></td>
<td>
<p>Longitude/latitude of a single point, in degrees; can be a vector of two numbers, a matrix of 2 columns (first one is longitude, second is latitude) or a SpatialPoints* object</p>
</td></tr>
<tr><td><code id="gcIntersect_+3A_p2">p2</code></td>
<td>
<p>As above</p>
</td></tr>
<tr><td><code id="gcIntersect_+3A_p3">p3</code></td>
<td>
<p>As above</p>
</td></tr>
<tr><td><code id="gcIntersect_+3A_p4">p4</code></td>
<td>
<p>As above</p>
</td></tr>
</table>


<h3>Value</h3>

<p>two points for each pair of great circles
</p>


<h3>Author(s)</h3>

<p>Robert Hijmans, based on equations by Ed Williams (see reference)
</p>


<h3>References</h3>

<p><a href="https://www.edwilliams.org/intersect.htm">https://www.edwilliams.org/intersect.htm</a>
</p>


<h3>See Also</h3>

<p><code> <a href="#topic+gcIntersectBearing">gcIntersectBearing</a>  </code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p1 &lt;- c(5,52); p2 &lt;- c(-120,37); p3 &lt;- c(-60,0); p4 &lt;- c(0,70)
gcIntersect(p1,p2,p3,p4)
</code></pre>

<hr>
<h2 id='gcIntersectBearing'>
Intersections of two great circles
</h2><span id='topic+gcIntersectBearing'></span>

<h3>Description</h3>

<p>Get the two points where two great cricles cross each other. In this function, great circles are defined by a points and an initial bearing. In function <code> <a href="#topic+gcIntersect">gcIntersect</a></code> they are defined by two sets of points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gcIntersectBearing(p1, brng1, p2, brng2) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gcIntersectBearing_+3A_p1">p1</code></td>
<td>
<p>longitude/latitude of point(s). Can be a vector of two numbers, a matrix of 2 columns (first one is longitude, second is latitude) or a SpatialPoints* object</p>
</td></tr>
<tr><td><code id="gcIntersectBearing_+3A_brng1">brng1</code></td>
<td>
<p>Bearing from p1</p>
</td></tr>
<tr><td><code id="gcIntersectBearing_+3A_p2">p2</code></td>
<td>
<p>As above. Should have same length as p1, or a single point (or vice versa when p1 is a single point</p>
</td></tr>
<tr><td><code id="gcIntersectBearing_+3A_brng2">brng2</code></td>
<td>
<p>Bearing from p2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with four columns (two points)
</p>


<h3>Author(s)</h3>

<p>Chris Veness and Robert Hijmans based on code by Ed Williams
</p>


<h3>References</h3>

<p><a href="https://www.edwilliams.org/avform147.htm#Intersection">https://www.edwilliams.org/avform147.htm#Intersection</a>
</p>
<p><a href="https://www.movable-type.co.uk/scripts/latlong.html">https://www.movable-type.co.uk/scripts/latlong.html</a>
</p>


<h3>See Also</h3>

<p><code> <a href="#topic+gcIntersect">gcIntersect</a>  </code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gcIntersectBearing(c(10,0), 10, c(-10,0), 10)
</code></pre>

<hr>
<h2 id='gcLat'>
Latitude on a Great Circle
</h2><span id='topic+gcLat'></span>

<h3>Description</h3>

<p>Latitude at which a great circle crosses a longitude
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gcLat(p1, p2, lon) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gcLat_+3A_p1">p1</code></td>
<td>
<p>Longitude/latitude of a single point, in degrees; can be a vector of two numbers, a matrix of 2 columns (first one is longitude, second is latitude) or a SpatialPoints* object</p>
</td></tr>
<tr><td><code id="gcLat_+3A_p2">p2</code></td>
<td>
<p>As above</p>
</td></tr>
<tr><td><code id="gcLat_+3A_lon">lon</code></td>
<td>
<p>Longitude</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric (latitude)
</p>


<h3>Author(s)</h3>

<p>Robert Hijmans based on a formula by Ed Williams
</p>


<h3>References</h3>

<p><a href="https://www.edwilliams.org/avform147.htm#Int">https://www.edwilliams.org/avform147.htm#Int</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gcLon">gcLon</a>, <a href="#topic+gcMaxLat">gcMaxLat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gcLat(c(5,52), c(-120,37), lon=-120)
</code></pre>

<hr>
<h2 id='gcLon'>
Longitude on a Great Circle
</h2><span id='topic+gcLon'></span>

<h3>Description</h3>

<p>Longitudes at which a great circle crosses a latitude (parallel)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gcLon(p1, p2, lat) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gcLon_+3A_p1">p1</code></td>
<td>
<p>longitude/latitude of point(s). Can be a vector of two numbers, a matrix of 2 columns (first one is longitude, second is latitude) or a SpatialPoints* object</p>
</td></tr>
<tr><td><code id="gcLon_+3A_p2">p2</code></td>
<td>
<p>as above</p>
</td></tr>
<tr><td><code id="gcLon_+3A_lat">lat</code></td>
<td>
<p>a latitude</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of two numbers (longitudes) 
</p>


<h3>Author(s)</h3>

<p>Robert Hijmans based on code by Ed Williams
</p>


<h3>References</h3>

<p><a href="https://www.edwilliams.org/avform147.htm#Intersection">https://www.edwilliams.org/avform147.htm#Intersection</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gcLat">gcLat</a>, <a href="#topic+gcMaxLat">gcMaxLat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gcLon(c(5,52), c(-120,37), 40)
</code></pre>

<hr>
<h2 id='gcMaxLat'>
Highest latitude on a great circle
</h2><span id='topic+gcMaxLat'></span>

<h3>Description</h3>

<p>What is northern most point that will be reached when following a great circle? Computed with Clairaut's formula. The southern most point is the <code><a href="#topic+antipode">antipode</a></code> of the northern-most point. This does not seem to be very precise; and you could use optimization instead to find this point (see examples)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gcMaxLat(p1, p2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gcMaxLat_+3A_p1">p1</code></td>
<td>
<p>longitude/latitude of point(s). Can be a vector of two numbers, a matrix of 2 columns (first one is longitude, second is latitude) or a SpatialPoints* object</p>
</td></tr>
<tr><td><code id="gcMaxLat_+3A_p2">p2</code></td>
<td>
<p>as above</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with coordinates (longitude/latitude)
</p>


<h3>Author(s)</h3>

<p>Ed Williams, Chris Veness, Robert Hijmans
</p>


<h3>References</h3>

<p><a href="https://www.edwilliams.org/ftp/avsig/avform.txt">https://www.edwilliams.org/ftp/avsig/avform.txt</a>
</p>
<p><a href="https://www.movable-type.co.uk/scripts/latlong.html">https://www.movable-type.co.uk/scripts/latlong.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gcLat">gcLat</a>, <a href="#topic+gcLon">gcLon</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gcMaxLat(c(5,52), c(-120,37))

# Another way to get there:
f &lt;- function(lon){gcLat(c(5,52), c(-120,37), lon)}
optimize(f, interval=c(-180, 180), maximum=TRUE)
</code></pre>

<hr>
<h2 id='geodesic'>
geodesic and inverse geodesic problem
</h2><span id='topic+geodesic'></span><span id='topic+geodesic_inverse'></span>

<h3>Description</h3>

<p>Highly accurate estimate of the 'geodesic problem' (find location and azimuth at arrival when departing from a location, given an  direction (azimuth) at departure and distance) and the 'inverse geodesic problem' (find the distance between two points and the azimuth of departure and arrival for the shortest path. Computations are for an ellipsoid (default is WGS84 ellipsoid). 
</p>
<p>This is a direct implementation of the the GeographicLib code by C.F.F. Karney that is also used in several other functions in this package (for example, in <code><a href="#topic+distGeo">distGeo</a></code> and <code><a href="#topic+areaPolygon">areaPolygon</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geodesic(p, azi, d, a=6378137, f=1/298.257223563, ...)

geodesic_inverse(p1, p2, a=6378137, f=1/298.257223563, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geodesic_+3A_p">p</code></td>
<td>
<p>longitude/latitude of point(s). Can be a vector of two numbers, a matrix of 2 columns (first column is longitude, second column is latitude) or a SpatialPoints* object</p>
</td></tr>
<tr><td><code id="geodesic_+3A_p1">p1</code></td>
<td>
<p>as above</p>
</td></tr>
<tr><td><code id="geodesic_+3A_p2">p2</code></td>
<td>
<p>as above</p>
</td></tr>
<tr><td><code id="geodesic_+3A_azi">azi</code></td>
<td>
<p>numeric. Azimuth of departure in degrees</p>
</td></tr>
<tr><td><code id="geodesic_+3A_d">d</code></td>
<td>
<p>numeric. Distance in meters</p>
</td></tr>
<tr><td><code id="geodesic_+3A_a">a</code></td>
<td>
<p>numeric. Major (equatorial) radius of the ellipsoid. The default value is for WGS84 </p>
</td></tr>
<tr><td><code id="geodesic_+3A_f">f</code></td>
<td>
<p>numeric. Ellipsoid flattening. The default value is for WGS84 </p>
</td></tr> 
<tr><td><code id="geodesic_+3A_...">...</code></td>
<td>
<p>additional arguments (none implemented)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Parameters from the WGS84 ellipsoid are used by default. It is the best available global ellipsoid, but for some areas other ellipsoids could be preferable, or even necessary if you work with a printed map that refers to that ellipsoid. Here are parameters for some commonly used ellipsoids.
</p>

<table>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code> ellipsoid          </code> </td><td style="text-align: left;"> <code> a            </code> </td><td style="text-align: left;"> <code> f               </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code> WGS84	            </code> </td><td style="text-align: left;"> <code> 6378137      </code> </td><td style="text-align: left;"> <code> 1/298.257223563 </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code> GRS80	            </code> </td><td style="text-align: left;"> <code> 6378137      </code> </td><td style="text-align: left;"> <code> 1/298.257222101 </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code> GRS67              </code> </td><td style="text-align: left;"> <code> 6378160      </code> </td><td style="text-align: left;"> <code> 1/298.25        </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code> Airy 1830          </code> </td><td style="text-align: left;"> <code> 6377563.396  </code> </td><td style="text-align: left;"> <code> 1/299.3249646   </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code> Bessel 1841        </code> </td><td style="text-align: left;"> <code> 6377397.155  </code> </td><td style="text-align: left;"> <code> 1/299.1528434   </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code> Clarke 1880        </code> </td><td style="text-align: left;"> <code> 6378249.145  </code> </td><td style="text-align: left;"> <code> 1/293.465       </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code> Clarke 1866        </code> </td><td style="text-align: left;"> <code> 6378206.4    </code> </td><td style="text-align: left;"> <code> 1/294.9786982   </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code> International 1924 </code> </td><td style="text-align: left;"> <code> 6378388      </code> </td><td style="text-align: left;"> <code> 1/297           </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td><td style="text-align: left;"> <code> Krasovsky 1940     </code> </td><td style="text-align: left;"> <code> 6378245      </code> </td><td style="text-align: left;"> <code> 1/298.2997381   </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>

<p>more info: <a href="https://en.wikipedia.org/wiki/Reference_ellipsoid">https://en.wikipedia.org/wiki/Reference_ellipsoid</a>		
</p>


<h3>Value</h3>

<p>Three column matrix with columns 'longitude', 'latitude', 'azimuth' (geodesic); or 'distance' (in meters), 'azimuth1' (of departure), 'azimuth2' (of arrival) (geodesic_inverse) 
</p>


<h3>Author(s)</h3>

<p>This function calls GeographicLib code by C.F.F. Karney
</p>


<h3>References</h3>

<p>C.F.F. Karney, 2013. Algorithms for geodesics, J. Geodesy 87: 43-55. <a href="https://doi.org/10.1007/s00190-012-0578-z">doi:10.1007/s00190-012-0578-z</a>. Addenda: <a href="https://geographiclib.sourceforge.io/geod-addenda.html">https://geographiclib.sourceforge.io/geod-addenda.html</a>. Also see <a href="https://geographiclib.sourceforge.io/">https://geographiclib.sourceforge.io/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distGeo">distGeo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>geodesic(cbind(0,0), 30, 1000000)
geodesic_inverse(cbind(0,0), cbind(90,90))
</code></pre>

<hr>
<h2 id='geomean'> 
Mean location of sperhical coordinates
</h2><span id='topic+geomean'></span>

<h3>Description</h3>

<p>mean location for spherical (longitude/latitude) coordinates that deals with the angularity. I.e., the mean of longitudes -179 and 178 is 179.5
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geomean(xy, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geomean_+3A_xy">xy</code></td>
<td>
<p>matrix with two columns (longitude/latitude), or a SpatialPoints or SpatialPolygons object with a longitude/latitude CRS</p>
</td></tr>
<tr><td><code id="geomean_+3A_w">w</code></td>
<td>
<p>weights (vector of numeric values, with a length that is equal to the number of spatial features in <code>x</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Ccoordinate pair (numeric)
</p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans</p>


<h3>Examples</h3>

<pre><code class='language-R'>xy &lt;- cbind(x=c(-179,179, 177), y=c(12,14,16))
xy
geomean(xy)
</code></pre>

<hr>
<h2 id='greatCircle'>
Great circle
</h2><span id='topic+greatCircle'></span>

<h3>Description</h3>

<p>Get points on a great circle as defined by the shortest distance between two specified points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>greatCircle(p1, p2, n=360, sp=FALSE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="greatCircle_+3A_p1">p1</code></td>
<td>
<p>longitude/latitude of point(s). Can be a vector of two numbers, a matrix of 2 columns (first one is longitude, second is latitude) or a SpatialPoints* object</p>
</td></tr>
<tr><td><code id="greatCircle_+3A_p2">p2</code></td>
<td>
<p>as above</p>
</td></tr>
<tr><td><code id="greatCircle_+3A_n">n</code></td>
<td>
<p>The requested number of points on the Great Circle</p>
</td></tr>
<tr><td><code id="greatCircle_+3A_sp">sp</code></td>
<td>
<p>Logical. Return a SpatialLines object?</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>A matrix of points, or a list of such matrices (e.g., if multiple bearings are supplied) 
</p>


<h3>Author(s)</h3>

<p> Robert Hijmans, based on a formula provided by Ed Williams </p>


<h3>References</h3>

<p><a href="https://www.edwilliams.org/avform147.htm#Int">https://www.edwilliams.org/avform147.htm#Int</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>greatCircle(c(5,52), c(-120,37), n=36)
</code></pre>

<hr>
<h2 id='greatCircleBearing'>
Great circle
</h2><span id='topic+greatCircleBearing'></span>

<h3>Description</h3>

<p>Get points on a great circle as defined by a point and an initial bearing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>greatCircleBearing(p, brng, n=360) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="greatCircleBearing_+3A_p">p</code></td>
<td>
<p>longitude/latitude of a single point. Can be a vector of two numbers, a matrix of 2 columns (first one is longitude, second is latitude) or a SpatialPoints* object</p>
</td></tr>
<tr><td><code id="greatCircleBearing_+3A_brng">brng</code></td>
<td>
<p>bearing</p>
</td></tr>
<tr><td><code id="greatCircleBearing_+3A_n">n</code></td>
<td>
<p>The requested number of points on the great circle</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of points, or a list of matrices (e.g., if multiple bearings are supplied) 
</p>


<h3>Author(s)</h3>

<p>Robert Hijmans based on formulae by Ed Williams
</p>


<h3>References</h3>

<p><a href="https://www.edwilliams.org/avform147.htm#Int">https://www.edwilliams.org/avform147.htm#Int</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>greatCircleBearing(c(5,52), 45, n=12)
</code></pre>

<hr>
<h2 id='horizon'>Distance to the horizon</h2><span id='topic+horizon'></span>

<h3>Description</h3>

<p>Empirical function to compute the distance to the horizon from a given altitude.  The earth is assumed to be smooth, i.e. mountains and other obstacles are ignored. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>horizon(h, r=6378137)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="horizon_+3A_h">h</code></td>
<td>
<p>altitude, numeric &gt;= 0. Should have the same unit as r</p>
</td></tr>
<tr><td><code id="horizon_+3A_r">r</code></td>
<td>
<p>radius of the earth; default value is 6378137 m</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>Distance in units of <code>h</code> (default is meters)
</p>


<h3>Author(s)</h3>

<p> Robert J. Hijmans </p>


<h3>References</h3>

<p><a href="https://www.edwilliams.org/avform147.htm#Horizon">https://www.edwilliams.org/avform147.htm#Horizon</a>
</p>
<p>Bowditch, 1995. American Practical Navigator. Table 12.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>horizon(1.80) # me
horizon(324)  # Eiffel tower
</code></pre>

<hr>
<h2 id='intermediate'>
Intermediate points on a great circle (sphere)
</h2><span id='topic+gcIntermediate'></span>

<h3>Description</h3>

<p>Get intermediate points (way points) between the two locations with longitude/latitude coordinates. gcIntermediate is based on a spherical model of the earth and internally uses <code><a href="#topic+distCosine">distCosine</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gcIntermediate(p1, p2, n=50, breakAtDateLine=FALSE, addStartEnd=FALSE, sp=FALSE, sepNA) 

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intermediate_+3A_p1">p1</code></td>
<td>
<p>longitude/latitude of a single point, in degrees. This can be a vector of two numbers, a matrix of 2 columns (first one is longitude, second is latitude) or a SpatialPoints* object</p>
</td></tr>
<tr><td><code id="intermediate_+3A_p2">p2</code></td>
<td>
<p>as for <code>p1</code></p>
</td></tr>
<tr><td><code id="intermediate_+3A_n">n</code></td>
<td>
<p>integer. The desired number of intermediate points</p>
</td></tr>
<tr><td><code id="intermediate_+3A_breakatdateline">breakAtDateLine</code></td>
<td>
<p>logical. Return two matrices if the dateline is crossed?</p>
</td></tr>
<tr><td><code id="intermediate_+3A_addstartend">addStartEnd</code></td>
<td>
<p>logical. Add p1 and p2 to the result?</p>
</td></tr>
<tr><td><code id="intermediate_+3A_sp">sp</code></td>
<td>
<p>logical. Return a SpatialLines object?</p>
</td></tr>
<tr><td><code id="intermediate_+3A_sepna">sepNA</code></td>
<td>
<p>logical. Rather than as a list, return the values as a two column matrix with lines seperated by a row of NA values? (for use in 'plot')</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix or list with intermediate points
</p>


<h3>Author(s)</h3>

<p>Robert Hijmans based on code by Ed Williams (great circle)
</p>


<h3>References</h3>

<p><a href="https://www.edwilliams.org/avform147.htm#Intermediate">https://www.edwilliams.org/avform147.htm#Intermediate</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gcIntermediate(c(5,52), c(-120,37), n=6, addStartEnd=TRUE)
</code></pre>

<hr>
<h2 id='lengthLine'>
Length of lines
</h2><span id='topic+lengthLine'></span>

<h3>Description</h3>

<p>Compute the length of lines
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lengthLine(line)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lengthLine_+3A_line">line</code></td>
<td>
<p>longitude/latitude of line as a matrix of 2 columns (first one is longitude, second is latitude) or a SpatialLines* or SpatialPolygons* object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>length (in meters) for each line 
</p>


<h3>See Also</h3>

<p>For planar coordinates, see the terra or sf packages
</p>


<h3>Examples</h3>

<pre><code class='language-R'>line &lt;- rbind(c(-180,-20), c(-150,-10), c(-140,55), c(10, 0), c(-140,-60))
d &lt;- lengthLine(line)
</code></pre>

<hr>
<h2 id='makePoly'>Add vertices to a polygon or line</h2><span id='topic+makePoly'></span><span id='topic+makeLine'></span>

<h3>Description</h3>

<p>Make a polygon or line by adding intermedate points (vertices) on the great circles inbetween the points supplied. This can be relevant when vertices are relatively far apart. 
It can make the shape of the object to be accurate, when plotted on a plane. <code>makePoly</code> will also close the polygon if needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makePoly(p, interval=10000, sp=FALSE, ...)
makeLine(p, interval=10000, sp=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makePoly_+3A_p">p</code></td>
<td>
<p>a 2-column matrix (longitude/latitude) or a SpatialPolygons or SpatialLines object</p>
</td></tr>
<tr><td><code id="makePoly_+3A_interval">interval</code></td>
<td>
<p>maximum interval of points, in units of r</p>
</td></tr>
<tr><td><code id="makePoly_+3A_sp">sp</code></td>
<td>
<p>Logical. If <code>TRUE</code>, a SpatialPolygons object is retunred (depends on the 'sp' package)</p>
</td></tr>
<tr><td><code id="makePoly_+3A_...">...</code></td>
<td>
<p>additional arguments passed to distGeo</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>A matrix 
</p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans </p>


<h3>Examples</h3>

<pre><code class='language-R'>pol &lt;- rbind(c(-180,-20), c(-160,5), c(-60, 0), c(-160,-60), c(-180,-20))
plot(pol)
lines(pol, col='red', lwd=3)
pol2 = makePoly(pol, interval=100000)
lines(pol2, col='blue', lwd=2)
</code></pre>

<hr>
<h2 id='mercator'>
Mercator projection
</h2><span id='topic+mercator'></span>

<h3>Description</h3>

<p>Transform longitude/latiude points to the Mercator projection. The main purpose of this function is to compute centroids, and to illustrate rhumb lines in the vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mercator(p, inverse=FALSE, r=6378137) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mercator_+3A_p">p</code></td>
<td>
<p>longitude/latitude of point(s). Can be a vector of two numbers, a matrix of 2 columns (first one is longitude, second is latitude) or a SpatialPoints* object</p>
</td></tr>
<tr><td><code id="mercator_+3A_inverse">inverse</code></td>
<td>
<p>Logical. If <code>TRUE</code>, do the inverse projection (from Mercator to longitude/latitude</p>
</td></tr>   
<tr><td><code id="mercator_+3A_r">r</code></td>
<td>
<p>Numeric. Radius of the earth; default = 6378137 m</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>matrix
</p>


<h3>Author(s)</h3>

<p> Robert Hijmans </p>


<h3>Examples</h3>

<pre><code class='language-R'>a = mercator(c(5,52))
a
mercator(a, inverse=TRUE)
</code></pre>

<hr>
<h2 id='midPoint'>Mid-point</h2><span id='topic+midPoint'></span>

<h3>Description</h3>

<p>Find the point half-way between two points along an ellipsoid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>midPoint(p1, p2, a=6378137, f = 1/298.257223563)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="midPoint_+3A_p1">p1</code></td>
<td>
<p>longitude/latitude of point(s). Can be a vector of two numbers, a matrix of 2 columns (first one is longitude, second is latitude) or a SpatialPoints* object</p>
</td></tr>
<tr><td><code id="midPoint_+3A_p2">p2</code></td>
<td>
<p>As above</p>
</td></tr>
<tr><td><code id="midPoint_+3A_a">a</code></td>
<td>
<p>major (equatorial) radius of the ellipsoid</p>
</td></tr>
<tr><td><code id="midPoint_+3A_f">f</code></td>
<td>
<p>ellipsoid flattening. The default value is for WGS84 </p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with coordinate pairs
</p>


<h3>Author(s)</h3>

<p> Elias Pipping and Robert Hijmans </p>


<h3>Examples</h3>

<pre><code class='language-R'>midPoint(c(0,0),c(90,90))  
midPoint(c(0,0),c(90,90), f=0)  
</code></pre>

<hr>
<h2 id='onGreatCircle'>
Is a point on a given great circle?
</h2><span id='topic+onGreatCircle'></span>

<h3>Description</h3>

<p>Test if a point is on a great circle defined by two other points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>onGreatCircle(p1, p2, p3, tol=0.0001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="onGreatCircle_+3A_p1">p1</code></td>
<td>
<p>Longitude/latitude of the first point defining a great circle, in degrees; can be a vector of two numbers, a matrix of 2 columns (first one is longitude, second is latitude) or a SpatialPoints* object</p>
</td></tr>
<tr><td><code id="onGreatCircle_+3A_p2">p2</code></td>
<td>
<p>as above for the second point</p>
</td></tr>
<tr><td><code id="onGreatCircle_+3A_p3">p3</code></td>
<td>
<p>the point(s) to be tested if they are on the great circle or not</p>
</td></tr>
<tr><td><code id="onGreatCircle_+3A_tol">tol</code></td>
<td>
<p>numeric. maximum distance from the great circle (in degrees) that is tolerated to be considered on the circle</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>logical
</p>


<h3>Author(s)</h3>

<p>Robert Hijmans
</p>


<h3>Examples</h3>

<pre><code class='language-R'>onGreatCircle(c(0,0), c(30,30), rbind(c(-10 -11.33812), c(10,20)))
</code></pre>

<hr>
<h2 id='perimeter'>
Compute the perimeter of a longitude/latitude polygon
</h2><span id='topic+perimeter'></span><span id='topic+perimeter+2Cmatrix-method'></span><span id='topic+perimeter+2Cdata.frame-method'></span><span id='topic+perimeter+2CSpatialPolygons-method'></span><span id='topic+perimeter+2CSpatialLines-method'></span>

<h3>Description</h3>

<p>Compute the perimeter of a polygon (or the length of a line) with longitude/latitude coordinates, on an ellipsoid (WGS84 by default) 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'matrix'
perimeter(x, a=6378137, f=1/298.257223563, ...)

## S4 method for signature 'SpatialPolygons'
perimeter(x, a=6378137, f=1/298.257223563, ...)

## S4 method for signature 'SpatialLines'
perimeter(x, a=6378137, f=1/298.257223563, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perimeter_+3A_x">x</code></td>
<td>
<p>Longitude/latitude of the points forming a polygon or line; Must be a matrix of 2 columns (first one is longitude, second is latitude) or a SpatialPolygons* or SpatialLines* object</p>
</td></tr>
<tr><td><code id="perimeter_+3A_a">a</code></td>
<td>
<p>major (equatorial) radius of the ellipsoid. The default value is for WGS84 </p>
</td></tr>
<tr><td><code id="perimeter_+3A_f">f</code></td>
<td>
<p>ellipsoid flattening. The default value is for WGS84 </p>
</td></tr>
<tr><td><code id="perimeter_+3A_...">...</code></td>
<td>
<p>Additional arguments. None implemented</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>Numeric. The perimeter or length in m.
</p>


<h3>Author(s)</h3>

<p>This function calls GeographicLib code by C.F.F. Karney
</p>


<h3>References</h3>

<p>C.F.F. Karney, 2013. Algorithms for geodesics, J. Geodesy 87: 43-55. <a href="https://doi.org/10.1007/s00190-012-0578-z">doi:10.1007/s00190-012-0578-z</a>. Addenda: <a href="https://geographiclib.sourceforge.io/geod-addenda.html">https://geographiclib.sourceforge.io/geod-addenda.html</a>. Also see <a href="https://geographiclib.sourceforge.io/">https://geographiclib.sourceforge.io/</a>
</p>


<h3>See Also</h3>

<p><code> <a href="#topic+areaPolygon">areaPolygon</a>, <a href="#topic+centroid">centroid</a>  </code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xy &lt;- rbind(c(-180,-20), c(-140,55), c(10, 0), c(-140,-60), c(-180,-20))
perimeter(xy)
</code></pre>

<hr>
<h2 id='plotArrows'>Plot</h2><span id='topic+plotArrows'></span>

<h3>Description</h3>

<p>Plot polygons with arrow heads on each line segment, pointing towards the next vertex. This shows the direction of each line segment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotArrows(p, fraction=0.9, length=0.15, first='', add=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotArrows_+3A_p">p</code></td>
<td>
<p>Polygons (either a 2 column matrix or data.frame; or a SpatialPolygons* object</p>
</td></tr>
<tr><td><code id="plotArrows_+3A_fraction">fraction</code></td>
<td>
<p>numeric between 0 and 1. When smaller then 1, interrupted lines are drawn</p>
</td></tr>
<tr><td><code id="plotArrows_+3A_length">length</code></td>
<td>
<p>length of the edges of the arrow head (in inches)</p>
</td></tr>
<tr><td><code id="plotArrows_+3A_first">first</code></td>
<td>
<p>Character to plot on first (and last) vertex </p>
</td></tr>
<tr><td><code id="plotArrows_+3A_add">add</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the plot is added to an existing plot</p>
</td></tr>
<tr><td><code id="plotArrows_+3A_...">...</code></td>
<td>
<p>Additional arguments, see Details</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Based on an example in Software for Data Analysis by John Chambers (pp 250-251) but adjusted such that the line segments follow great circles between vertices.
</p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans</p>


<h3>Examples</h3>

<pre><code class='language-R'>pol &lt;- rbind(c(-180,-20), c(-160,5), c(-60, 0), c(-160,-60), c(-180,-20))
plotArrows(pol)
</code></pre>

<hr>
<h2 id='randomCoordinates'>
Random or regularly distributed coordinates on the globe
</h2><span id='topic+randomCoordinates'></span><span id='topic+regularCoordinates'></span>

<h3>Description</h3>

<p>randomCoordinates returns a 'uniform random sample' in the sense that the probability that a point is drawn from any region is equal to the area of that region divided by the area of the entire sphere. This would not happen if you took a random uniform sample of longitude and latitude, as the sample would be biased towards the poles.
</p>
<p>regularCoordiaates returns a set of coordinates that are regularly distributed on the globe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomCoordinates(n)
regularCoordinates(N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randomCoordinates_+3A_n">n</code></td>
<td>
<p>Sample size (number of points (coordinate pairs)) </p>
</td></tr>
<tr><td><code id="randomCoordinates_+3A_n">N</code></td>
<td>
<p>Number of 'parts' in which the earth is subdived ) </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of lon/lat coordiantes
</p>


<h3>Author(s)</h3>

<p>Robert Hijmans, based on code by Nils Haeck (regularCoordinates) and on suggstions by Michael Orion (randomCoordinates)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>randomCoordinates(3)
regularCoordinates(1)
</code></pre>

<hr>
<h2 id='refEllipsoids'>Reference ellipsoids</h2><span id='topic+refEllipsoids'></span>

<h3>Description</h3>

<p>This function returns a data.frame with parameters <code>a</code> (semi-major axis) and <code>1/f</code> (inverse flattening) for a set of reference ellipsoids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>refEllipsoids()
</code></pre>


<h3>Value</h3>

<p>data.frame
</p>


<h3>Note</h3>

<p>To compute parameter <code>b</code> you can do  
</p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans </p>


<h3>See Also</h3>

<p><code> <a href="#topic+area">area</a>, <a href="#topic+perimeter">perimeter</a>  </code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>e &lt;- refEllipsoids()
e[e$code=='WE', ]

#to compute semi-minor axis b:
e$b &lt;- e$a - e$a / e$invf
</code></pre>

<hr>
<h2 id='span'>Span of polygons</h2><span id='topic+span'></span><span id='topic+span+2CSpatialPolygons-method'></span><span id='topic+span+2Cmatrix-method'></span>

<h3>Description</h3>

<p>Compute the approximate surface span of polygons in longitude and latitude direction. Span is computed by rasterizing the polygons; and precision increases with the number of 'scan lines'. You can either use a fixed number of scan lines for each polygon, or a fixed band-width.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>span(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="span_+3A_x">x</code></td>
<td>
<p>a SpatialPolygons* object or a 2-column matrix (longitude/latitude)</p>
</td></tr>
<tr><td><code id="span_+3A_...">...</code></td>
<td>
<p>Additional arguments, see Details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following additional arguments can be passed, to replace default values for this function
</p>

<table>
<tr>
 <td style="text-align: right;">
  </td><td style="text-align: left;"> <code>nbands</code>  </td><td style="text-align: left;"> Character. Method to determine the number of bands to 'scan' the polygon. Either 'fixed' or 'variable' </td>
</tr>
<tr>
 <td style="text-align: right;">
  </td><td style="text-align: left;"> <code>n</code> </td><td style="text-align: left;"> Integer &gt;= 1. If <code>nbands='fixed'</code>, how many bands should be used </td>
</tr>
<tr>
 <td style="text-align: right;">
  </td><td style="text-align: left;"> <code>res</code> </td><td style="text-align: left;"> Numeric. If <code>nbands='variable'</code>, what should the bandwidth be (in degrees)? </td>
</tr>
<tr>
 <td style="text-align: right;">
  </td><td style="text-align: left;"> <code>fun</code> </td><td style="text-align: left;"> Logical. A function such as mean or min. Mean computes the average span </td>
</tr>
<tr>
 <td style="text-align: right;">
  </td><td style="text-align: left;"> <code>...</code> </td><td style="text-align: left;"> further additional arguments passed to distGeo</td>
</tr>
<tr>
 <td style="text-align: right;">
 </td>
</tr>

</table>



<h3>Value</h3>

<p>A list, or a matrix if a function <code>fun</code> is specified. Values are in the units of <code>r</code> (default is meter)
</p>


<h3>Author(s)</h3>

<p>Robert J. Hijmans </p>


<h3>Examples</h3>

<pre><code class='language-R'>pol &lt;- rbind(c(-180,-20), c(-160,5), c(-60, 0), c(-160,-60), c(-180,-20))
plot(pol)
lines(pol)
# lon and lat span in m
span(pol, fun=max) 
x &lt;- span(pol) 
max(x$latspan)
mean(x$latspan)
plot(x$longitude, x$lonspan)
</code></pre>

<hr>
<h2 id='wrld'>World countries</h2><span id='topic+wrld'></span><span id='topic+merc'></span>

<h3>Description</h3>

<p>world coastline and country outlines in longitude/latitude (wrld) and in Mercator projection (merc). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wrld)
data(merc)
</code></pre>


<h3>Source</h3>

<p>Derived from the wrld_simpl data set in package maptools
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
