<!DOCTYPE html><html lang="en"><head><title>Help for package optR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {optR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cgm'><p>Optimization &amp; estimation based on Conjugate Gradient Method</p></a></li>
<li><a href='#choleskiDecomposition'><p>Function for Choleski Decomposition</p></a></li>
<li><a href='#choleskilm'><p>Function fits linear model using Choleski Decomposition</p></a></li>
<li><a href='#forwardsubsitution.optR'><p>Function to solve linear system using forward substitution</p></a></li>
<li><a href='#gaussSeidel'><p>Gauss-Seidel based Optimization &amp; estimation</p></a></li>
<li><a href='#hatMatrix'><p>Function determines the Hat matrix or projection matrix for given X</p></a></li>
<li><a href='#inv.optR'><p>Invert a matrix using LU decomposition</p></a></li>
<li><a href='#jacobian'><p>Function to evaluate jacobian matrix from functions</p></a></li>
<li><a href='#LU.decompose'><p>LU decomposition</p></a></li>
<li><a href='#LU.optR'><p>Solving system of equations using LU decomposition</p></a></li>
<li><a href='#LUsplit'><p>Function to extract Lower and Upper matrix from LU decomposition</p></a></li>
<li><a href='#machinePrecision'><p>Function to address machine precision error</p></a></li>
<li><a href='#newtonRapson'><p>Function for Newton Rapson roots for given equations</p></a></li>
<li><a href='#nonDiagMultipication'><p>Non-diagnoal multipication</p></a></li>
<li><a href='#opt.matrix.reorder'><p>Function to Re-order the matrix to make dominant diagnals</p></a></li>
<li><a href='#optR'><p>Optimization &amp; predictive modelling Toolsets</p></a></li>
<li><a href='#optR.backsubsitution'><p>Function to solve linear system using backsubsitution</p></a></li>
<li><a href='#optR.default'><p>Optimization &amp; predictive modelling Toolsets</p></a></li>
<li><a href='#optR.fit'><p>Fitter function for Linear/Non-linear system with form Ax=b</p></a></li>
<li><a href='#optR.formula'><p>Optimization &amp; predictive modelling Toolsets</p></a></li>
<li><a href='#optR.gauss'><p>gauss to solve linear systems</p></a></li>
<li><a href='#optR.multiplyfactor'><p>Function to estimate lambda</p></a></li>
<li><a href='#optRFun'><p>Function based optimization module</p></a></li>
<li><a href='#optRFun.newtonRapson'><p>Function based optimization module</p></a></li>
<li><a href='#predict.optR'><p>Prediction function based on optR class</p></a></li>
<li><a href='#print.optR'><p>print coefficients for optR class</p></a></li>
<li><a href='#summary.optR'><p>Generate Summary for optR class</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Optimization Toolbox for Solving Linear Systems</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2016-11-29</td>
</tr>
<tr>
<td>Author:</td>
<td>Prakash (PKS Prakash) &lt;prakash2@uwalumni.com&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Prakash &lt;prakash2@uwalumni.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Solves linear systems of form Ax=b via Gauss elimination, 
  LU decomposition, Gauss-Seidel, Conjugate Gradient Method (CGM) and Cholesky methods.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-11-29 12:31:37 UTC; prakash</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>graphics, stats</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-11-29 15:08:40</td>
</tr>
</table>
<hr>
<h2 id='cgm'>Optimization &amp; estimation based on Conjugate Gradient Method</h2><span id='topic+cgm'></span>

<h3>Description</h3>

<p>Function utilizes the Conjugate Gradient Method for optimization to solve equation Ax=b
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cgm(A, b, x = NULL, iter = 500, tol = 1e-07)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cgm_+3A_a">A</code></td>
<td>
<p>: Input matrix</p>
</td></tr>
<tr><td><code id="cgm_+3A_b">b</code></td>
<td>
<p>: Response vector</p>
</td></tr>
<tr><td><code id="cgm_+3A_x">x</code></td>
<td>
<p>: Initial solutions</p>
</td></tr>
<tr><td><code id="cgm_+3A_iter">iter</code></td>
<td>
<p>: Number of Iterations</p>
</td></tr>
<tr><td><code id="cgm_+3A_tol">tol</code></td>
<td>
<p>: Convergence tolerance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>optimal  : Optimal solutions
</p>
<p>initial  : initial solution
</p>
<p>itr.conv  : Number of iterations for convergence
</p>
<p>conv  : Convergence array
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A&lt;-matrix(c(4,-1,1, -1,4,-2,1,-2,4), nrow=3,ncol=3, byrow = TRUE)
b&lt;-matrix(c(12,-1, 5), nrow=3,ncol=1,byrow=TRUE)
Z&lt;-optR(A, b, method="cgm", iter=500, tol=1e-7)
</code></pre>

<hr>
<h2 id='choleskiDecomposition'>Function for Choleski Decomposition</h2><span id='topic+choleskiDecomposition'></span>

<h3>Description</h3>

<p>Function perform choleski decomposition for positive definate matrix (A=LL')
</p>


<h3>Usage</h3>

<pre><code class='language-R'>choleskiDecomposition(A, tol = 1e-07)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="choleskiDecomposition_+3A_a">A</code></td>
<td>
<p>:Input Matrix</p>
</td></tr>
<tr><td><code id="choleskiDecomposition_+3A_tol">tol</code></td>
<td>
<p>: Tolerance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>L: Decomposition matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A&lt;-matrix(c(4,-2,2, -2,2,-4,2,-4,11), nrow=3,ncol=3, byrow = TRUE)
chdA&lt;-choleskiDecomposition(A)
</code></pre>

<hr>
<h2 id='choleskilm'>Function fits linear model using Choleski Decomposition</h2><span id='topic+choleskilm'></span>

<h3>Description</h3>

<p>Function fits a linear model using Choleski Decomposition for positive definate matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>choleskilm(A, b, tol = 1e-07)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="choleskilm_+3A_a">A</code></td>
<td>
<p>: Input matrix</p>
</td></tr>
<tr><td><code id="choleskilm_+3A_b">b</code></td>
<td>
<p>: Response matrix</p>
</td></tr>
<tr><td><code id="choleskilm_+3A_tol">tol</code></td>
<td>
<p>: Tolerance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>U  : Upper part of the triangele is (U) and Lower part of the triangular is L (Diagnoal for the L matrix is 1)
</p>
<p>c  : Lc=b (where Ux=c)
</p>
<p>beta : Estimates
</p>
<p>examples
A&lt;-matrix(c(6,-4,1, -4,6,-4,1,-4,6), nrow=3,ncol=3, byrow = TRUE)
b&lt;-matrix(c(-14,36, 6), nrow=3,ncol=1,byrow=TRUE)
Z&lt;-optR(A, b, method=&quot;choleski&quot;) # Solve Linear model using Gauss Elimination
</p>

<hr>
<h2 id='forwardsubsitution.optR'>Function to solve linear system using forward substitution</h2><span id='topic+forwardsubsitution.optR'></span>

<h3>Description</h3>

<p>Function to solve linear system using backsubsitution using Upper Triangular Matrix (Ux=c)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forwardsubsitution.optR(L, b)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="forwardsubsitution.optR_+3A_l">L</code></td>
<td>
<p>: Lower triangular matrix</p>
</td></tr>
<tr><td><code id="forwardsubsitution.optR_+3A_b">b</code></td>
<td>
<p>: response</p>
</td></tr>
</table>


<h3>Value</h3>

<p>y  : Estiamted value
</p>

<hr>
<h2 id='gaussSeidel'>Gauss-Seidel based Optimization &amp; estimation</h2><span id='topic+gaussSeidel'></span>

<h3>Description</h3>

<p>Function utilizes the Gauss-Seidel optimization to solve equation Ax=b
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussSeidel(A, b, x = NULL, iter = 500, tol = 1e-07, w = 1,
  witr = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gaussSeidel_+3A_a">A</code></td>
<td>
<p>: Input matrix</p>
</td></tr>
<tr><td><code id="gaussSeidel_+3A_b">b</code></td>
<td>
<p>: Response</p>
</td></tr>
<tr><td><code id="gaussSeidel_+3A_x">x</code></td>
<td>
<p>: Initial solutions</p>
</td></tr>
<tr><td><code id="gaussSeidel_+3A_iter">iter</code></td>
<td>
<p>: Number of Iterations</p>
</td></tr>
<tr><td><code id="gaussSeidel_+3A_tol">tol</code></td>
<td>
<p>: Convergence tolerance</p>
</td></tr>
<tr><td><code id="gaussSeidel_+3A_w">w</code></td>
<td>
<p>: Relaxation paramter used to compute weighted avg. of previous solution. w=1 represent no relaxation</p>
</td></tr>
<tr><td><code id="gaussSeidel_+3A_witr">witr</code></td>
<td>
<p>: Iteration after which relaxation parameter become active</p>
</td></tr>
</table>


<h3>Value</h3>

<p>optimal  : Optimal solutions
</p>
<p>initial  : initial solution
</p>
<p>relaxationFactor : relaxation factor
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A&lt;-matrix(c(4,-1,1, -1,4,-2,1,-2,4), nrow=3,ncol=3, byrow = TRUE)
b&lt;-matrix(c(12,-1, 5), nrow=3,ncol=1,byrow=TRUE)
Z&lt;-optR(A, b, method="gaussseidel", iter=500, tol=1e-7)
</code></pre>

<hr>
<h2 id='hatMatrix'>Function determines the Hat matrix or projection matrix for given X</h2><span id='topic+hatMatrix'></span>

<h3>Description</h3>

<p>Function hatMatrix determines the projection matrix for X from the form yhat=Hy. The projection matrix defines the influce of each variable on fitted value
The diagonal elements of the projection matrix are the leverages or influence each sample has on the fitted value for that same observation. 
The projection matrix is evaluated with I.I.D assumtion ~N(0, 1)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hatMatrix(X, covmat = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hatMatrix_+3A_x">X</code></td>
<td>
<p>: Input Matrix</p>
</td></tr>
<tr><td><code id="hatMatrix_+3A_covmat">covmat</code></td>
<td>
<p>: covariance matrix for error, if the error are correlated for I.I.D covmat will be NULL matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>X: Projection Matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X&lt;-matrix(c(6,-4,1, -4,6,-4,1,-4,6), nrow=3,ncol=3, byrow = TRUE)
covmat &lt;- matrix(rnorm(3 * 3), 3, 3)
H&lt;-hatMatrix(X)
H&lt;-hatMatrix(X, covmat)
diag(H)
</code></pre>

<hr>
<h2 id='inv.optR'>Invert a matrix using LU decomposition</h2><span id='topic+inv.optR'></span>

<h3>Description</h3>

<p>function invert a matrix A using LU decomposition such that A*inv(A)=I
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inv.optR(A, tol = 1e-07)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inv.optR_+3A_a">A</code></td>
<td>
<p>: Input matrix</p>
</td></tr>
<tr><td><code id="inv.optR_+3A_tol">tol</code></td>
<td>
<p>: tolerance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A  : Inverse of Matrix A
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Invert the matrix using LU decomposition
A&lt;-matrix(c(0.6,-0.4,1, -0.3,0.2,0.5,0.6,-1,0.5), nrow=3,ncol=3, byrow = TRUE) 
InvA&lt;-inv.optR(A)
</code></pre>

<hr>
<h2 id='jacobian'>Function to evaluate jacobian matrix from functions</h2><span id='topic+jacobian'></span>

<h3>Description</h3>

<p>jacobian is function to determine the jacobian matrix for function f for input x
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jacobian(f, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jacobian_+3A_f">f</code></td>
<td>
<p>: function to optimize</p>
</td></tr>
<tr><td><code id="jacobian_+3A_x">x</code></td>
<td>
<p>: Initial Solution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>jacobiabMatrix: Jacobian matrix
</p>
<p>f0: Intial solution
</p>

<hr>
<h2 id='LU.decompose'>LU decomposition</h2><span id='topic+LU.decompose'></span>

<h3>Description</h3>

<p>The function decomposes matrix A into LU with L lower matrix and U as upper matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LU.decompose(A, tol = 1e-07)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LU.decompose_+3A_a">A</code></td>
<td>
<p>: Input Matrix</p>
</td></tr>
<tr><td><code id="LU.decompose_+3A_tol">tol</code></td>
<td>
<p>: tolerance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A  : Transformed matrix with Upper part of the triangele is (U) and Lower part of the triangular is L (Diagnoal for the L matrix is 1)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A&lt;-matrix(c(0,-1,1, -1,2,-1,2,-1,0), nrow=3,ncol=3, byrow = TRUE)
Z&lt;-optR(A, tol=1e-7, method="LU")
</code></pre>

<hr>
<h2 id='LU.optR'>Solving system of equations using LU decomposition</h2><span id='topic+LU.optR'></span>

<h3>Description</h3>

<p>The function solves Ax=b using LU decomposition (LUx=b). The function handles multple responses
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LU.optR(A, b, tol = 1e-07)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LU.optR_+3A_a">A</code></td>
<td>
<p>: Input Matrix</p>
</td></tr>
<tr><td><code id="LU.optR_+3A_b">b</code></td>
<td>
<p>: Response</p>
</td></tr>
<tr><td><code id="LU.optR_+3A_tol">tol</code></td>
<td>
<p>: tolerance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>U  : Upper part of the triangele is (U) and Lower part of the triangular is L (Diagnoal for the L matrix is 1)
</p>
<p>c  : Lc=b (where Ux=c)
</p>
<p>beta : Estimates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A&lt;-matrix(c(0,-1,1, -1,2,-1,2,-1,0), nrow=3,ncol=3, byrow = TRUE)
b&lt;-matrix(c(0,0, 1), nrow=3,ncol=1,byrow=TRUE)
Z&lt;-optR(A, b, method="LU")
</code></pre>

<hr>
<h2 id='LUsplit'>Function to extract Lower and Upper matrix from LU decomposition</h2><span id='topic+LUsplit'></span>

<h3>Description</h3>

<p>function to extract Lower and Upper matrix from LU decomposition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LUsplit(A)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LUsplit_+3A_a">A</code></td>
<td>
<p>: Input matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>U  : upper triangular matrix
</p>
<p>L  : Lower triangular matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A&lt;-matrix(c(0,-1,1, -1,2,-1,2,-1,0), nrow=3,ncol=3, byrow = TRUE) 
Z&lt;-optR(A, method="LU")
LUsplit(Z$U)
</code></pre>

<hr>
<h2 id='machinePrecision'>Function to address machine precision error</h2><span id='topic+machinePrecision'></span>

<h3>Description</h3>

<p>function to remove the machine precision error
</p>


<h3>Usage</h3>

<pre><code class='language-R'>machinePrecision(A)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="machinePrecision_+3A_a">A</code></td>
<td>
<p>: Input matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A  : return matrix
</p>

<hr>
<h2 id='newtonRapson'>Function for Newton Rapson roots for given equations</h2><span id='topic+newtonRapson'></span>

<h3>Description</h3>

<p>newtonRapson function perform optimization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newtonRapson(f, x, iteration = 30, tol = 1e-09)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="newtonRapson_+3A_f">f</code></td>
<td>
<p>: function to optimize</p>
</td></tr>
<tr><td><code id="newtonRapson_+3A_x">x</code></td>
<td>
<p>: Initial Solution</p>
</td></tr>
<tr><td><code id="newtonRapson_+3A_iteration">iteration</code></td>
<td>
<p>: Iterations</p>
</td></tr>
<tr><td><code id="newtonRapson_+3A_tol">tol</code></td>
<td>
<p>: Tolerance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x    : optimal roots
</p>

<hr>
<h2 id='nonDiagMultipication'>Non-diagnoal multipication</h2><span id='topic+nonDiagMultipication'></span>

<h3>Description</h3>

<p>Function for non-diagnoal multipication
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nonDiagMultipication(i, A, beta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nonDiagMultipication_+3A_i">i</code></td>
<td>
<p>: Column Index of Matrix A</p>
</td></tr>
<tr><td><code id="nonDiagMultipication_+3A_a">A</code></td>
<td>
<p>: Input matrix</p>
</td></tr>
<tr><td><code id="nonDiagMultipication_+3A_beta">beta</code></td>
<td>
<p>: Response</p>
</td></tr>
</table>


<h3>Value</h3>

<p>asum: Non-diagnol contribution
</p>

<hr>
<h2 id='opt.matrix.reorder'>Function to Re-order the matrix to make dominant diagnals</h2><span id='topic+opt.matrix.reorder'></span>

<h3>Description</h3>

<p>Function re-order the matrix to make matrix pivot.diag at each iteration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opt.matrix.reorder(A, tol = 1e-16)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opt.matrix.reorder_+3A_a">A</code></td>
<td>
<p>: Input Matrix</p>
</td></tr>
<tr><td><code id="opt.matrix.reorder_+3A_tol">tol</code></td>
<td>
<p>: tolerance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A        : Updated Matrix
</p>
<p>b.order  : Order sequence of A updated  matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A&lt;-matrix(c(0,-1,1, -1,2,-1,2,-1,0), nrow=3,ncol=3, byrow = TRUE)
b&lt;-matrix(c(0,0, 1), nrow=3,ncol=1,byrow=TRUE)
Z&lt;-optR(A, b, method="gauss")
</code></pre>

<hr>
<h2 id='optR'>Optimization &amp; predictive modelling Toolsets</h2><span id='topic+optR'></span>

<h3>Description</h3>

<p>optR function for solving linear systems using numerical approaches. 
Current toolbox supports Gauss Elimination, LU decomposition, Conjugate Gradiant Decent and Gauss-Sideal methods for solving the system of form AX=b
For optimization using numerical methods cgm method performed faster in comparision with gaussseidel.
For decomposition LU is utilized for multiple responses to enhance the speed of computation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optR(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optR_+3A_x">x</code></td>
<td>
<p>: Input matrix</p>
</td></tr>
<tr><td><code id="optR_+3A_...">...</code></td>
<td>
<p>: S3 method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>optR   : Return optR class
</p>


<h3>Author(s)</h3>

<p>PKS Prakash
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Solving equation Ax=b
A&lt;-matrix(c(6,-4,1, -4,6,-4,1,-4,6), nrow=3,ncol=3, byrow = TRUE)
b&lt;-matrix(c(-14,36, 6), nrow=3,ncol=1,byrow=TRUE)
Z&lt;-optR(A, b, method="gauss") # Solve Linear model using Gauss Elimination

# Solve Linear model using LU decomposition (Supports Multi-response)
Z&lt;-optR(A, b, method="LU") 

# Solve the matrix using Gauss Elimination (1, -1, 2)
A&lt;-matrix(c(2,-2,6, -2,4,3,-1,8,4), nrow=3,ncol=3, byrow = TRUE)
b&lt;-matrix(c(16,0, -1), nrow=3,ncol=1,byrow=TRUE)
Z&lt;-optR(A, b, method="gauss") # Solve Linear model using Gauss Elimination

require(utils)
set.seed(129)
n &lt;- 10 ; p &lt;- 4
X &lt;- matrix(rnorm(n * p), n, p) # no intercept!
y &lt;- rnorm(n)
Z&lt;-optR(X, y, method="cgm")
</code></pre>

<hr>
<h2 id='optR.backsubsitution'>Function to solve linear system using backsubsitution</h2><span id='topic+optR.backsubsitution'></span>

<h3>Description</h3>

<p>Function to solve linear system using backsubsitution using Upper Triangular Matrix (Ux=c)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'backsubsitution'
optR(U, c)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optR.backsubsitution_+3A_u">U</code></td>
<td>
<p>: Upper triangular matrix</p>
</td></tr>
<tr><td><code id="optR.backsubsitution_+3A_c">c</code></td>
<td>
<p>: response</p>
</td></tr>
</table>


<h3>Value</h3>

<p>beta : Estiamted value
</p>

<hr>
<h2 id='optR.default'>Optimization &amp; predictive modelling Toolsets</h2><span id='topic+optR.default'></span>

<h3>Description</h3>

<p>soptR is the default function for optimization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
optR(x, y = NULL, weights = NULL, method = c("gauss",
  "LU", "gaussseidel", "cgm", "choleski"), iter = 500, tol = 1e-07,
  keep.data = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optR.default_+3A_x">x</code></td>
<td>
<p>: Input data frame</p>
</td></tr>
<tr><td><code id="optR.default_+3A_y">y</code></td>
<td>
<p>: Response is data frame</p>
</td></tr>
<tr><td><code id="optR.default_+3A_weights">weights</code></td>
<td>
<p>: Observation weights</p>
</td></tr>
<tr><td><code id="optR.default_+3A_method">method</code></td>
<td>
<p>: &quot;gauss&quot; for gaussian elimination and &quot;LU&quot; for LU factorization</p>
</td></tr>
<tr><td><code id="optR.default_+3A_iter">iter</code></td>
<td>
<p>: Number of Iterations</p>
</td></tr>
<tr><td><code id="optR.default_+3A_tol">tol</code></td>
<td>
<p>: Convergence tolerance</p>
</td></tr>
<tr><td><code id="optR.default_+3A_keep.data">keep.data</code></td>
<td>
<p>: Returns Input dataset in object</p>
</td></tr>
<tr><td><code id="optR.default_+3A_...">...</code></td>
<td>
<p>: S3 Class</p>
</td></tr>
</table>


<h3>Value</h3>

<p>U    : Decomposed matrix for Gauss-ELimination Ax=b is converted into Ux=c where U is upper triangular matrix for LU decomposition U contain the values for L &amp; U decomposition LUx=b
</p>
<p>c    : transformed b &amp; for LU transformation c is y from equation Ux=y
</p>
<p>estimates  : Return x values for linear system
</p>
<p>seq        : sequence of A matrix re-ordered
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Solving equation Ax=b
A&lt;-matrix(c(6,-4,1, -4,6,-4,1,-4,6), nrow=3,ncol=3, byrow = TRUE)
b&lt;-matrix(c(-14,36, 6), nrow=3,ncol=1,byrow=TRUE)
Z&lt;-optR(A, b, method="gauss") 

# Solve Linear model using LU decomposition (Supports Multi-response)
Z&lt;-optR(A, b, method="LU")

# Solving the function using numerical method
Z&lt;-optR(A, b, method="cgm")

require(utils)
set.seed(129)
n &lt;- 7 ; p &lt;- 2
X &lt;- matrix(rnorm(n * p), n, p) # no intercept!
y &lt;- rnorm(n)
Z&lt;-optR(X, y, method="LU")
</code></pre>

<hr>
<h2 id='optR.fit'>Fitter function for Linear/Non-linear system with form Ax=b</h2><span id='topic+optR.fit'></span>

<h3>Description</h3>

<p>optR.fit is fit function for determing x for System with form Ax=b
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fit'
optR(x, y = NULL, method = c("gauss, LU, gaussseidel", "cgm"),
  iter = 500, tol = 1e-07, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optR.fit_+3A_x">x</code></td>
<td>
<p>: Input matrix</p>
</td></tr>
<tr><td><code id="optR.fit_+3A_y">y</code></td>
<td>
<p>: Response is matrix</p>
</td></tr>
<tr><td><code id="optR.fit_+3A_method">method</code></td>
<td>
<p>: &quot;gauss&quot; for gaussian elimination and &quot;LU&quot; for LU factorization</p>
</td></tr>
<tr><td><code id="optR.fit_+3A_iter">iter</code></td>
<td>
<p>: Number of Iterations</p>
</td></tr>
<tr><td><code id="optR.fit_+3A_tol">tol</code></td>
<td>
<p>: Convergence tolerance</p>
</td></tr>
<tr><td><code id="optR.fit_+3A_...">...</code></td>
<td>
<p>: S3 Class</p>
</td></tr>
</table>


<h3>Value</h3>

<p>U    : Decomposed matrix for Gauss-ELimination Ax=b is converted into Ux=c where U is upper triangular matrix for LU decomposition U contain the values for L &amp; U decomposition LUx=b
</p>
<p>c    : transformed b &amp; for LU transformation c is y from equation Ux=y
</p>
<p>estimates  : Return x values for linear system
</p>
<p>seq        : sequence of A matrix re-ordered
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Solving equation Ax=b
A&lt;-matrix(c(6,-4,1, -4,6,-4,1,-4,6), nrow=3,ncol=3, byrow = TRUE)
b&lt;-matrix(c(-14,36, 6), nrow=3,ncol=1,byrow=TRUE)
Z&lt;-optR(A, b, method="gauss") 

# Solve Linear model using LU decomposition (Supports Multi-response)
Z&lt;-optR(A, b, method="LU")

# Solving the function using numerical method
Z&lt;-optR(A, b, method="cgm")
</code></pre>

<hr>
<h2 id='optR.formula'>Optimization &amp; predictive modelling Toolsets</h2><span id='topic+optR.formula'></span>

<h3>Description</h3>

<p>optR package to perform the optimization using numerical methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula'
optR(formula, data = list(), weights = NULL,
  method = c("gauss, LU, gaussseidel", "cgm", "choleski"), iter = 500,
  tol = 1e-07, keep.data = TRUE, contrasts = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optR.formula_+3A_formula">formula</code></td>
<td>
<p>: formula to build model</p>
</td></tr>
<tr><td><code id="optR.formula_+3A_data">data</code></td>
<td>
<p>: data used to build model</p>
</td></tr>
<tr><td><code id="optR.formula_+3A_weights">weights</code></td>
<td>
<p>: Observation weights</p>
</td></tr>
<tr><td><code id="optR.formula_+3A_method">method</code></td>
<td>
<p>: &quot;gauss&quot; for gaussian elimination and &quot;LU&quot; for LU factorization</p>
</td></tr>
<tr><td><code id="optR.formula_+3A_iter">iter</code></td>
<td>
<p>: Number of Iterations</p>
</td></tr>
<tr><td><code id="optR.formula_+3A_tol">tol</code></td>
<td>
<p>: Convergence tolerance</p>
</td></tr>
<tr><td><code id="optR.formula_+3A_keep.data">keep.data</code></td>
<td>
<p>: If TRUE returns input data</p>
</td></tr>
<tr><td><code id="optR.formula_+3A_contrasts">contrasts</code></td>
<td>
<p>: Data frame contract values</p>
</td></tr>
<tr><td><code id="optR.formula_+3A_...">...</code></td>
<td>
<p>: S3 Class</p>
</td></tr>
</table>


<h3>Value</h3>

<p>U        : Decomposed matrix for Gauss-ELimination Ax=b is converted into Ux=c where U is upper triangular matrix for LU decomposition U contain the values for L &amp; U decomposition LUx=b
</p>
<p>c        : transformed b &amp; for LU transformation c is y from equation Ux=y
</p>
<p>estimates  : Return x values for linear system
</p>


<h3>Author(s)</h3>

<p>PKS Prakash
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Solving equation Ax=b
b&lt;-matrix(c(-14,36, 6), nrow=3,ncol=1,byrow=TRUE)
A&lt;-matrix(c(6,-4,1, -4,6,-4,1,-4,6), nrow=3,ncol=3, byrow = TRUE)
Z&lt;-optR(b~A-1, method="gauss") # -1 to remove the constant vector

Z&lt;-optR(b~A-1, method="LU") # -1 to remove the constant vector

require(utils)
set.seed(129)
n &lt;- 10 ; p &lt;- 4
X &lt;- matrix(rnorm(n * p), n, p) # no intercept!
y &lt;- rnorm(n)
data&lt;-cbind(X, y)
colnames(data)&lt;-c("var1", "var2", "var3", "var4", "y")
Z&lt;-optR(y~var1+var2+var3+var4+var1*var2-1, data=data.frame(data), method="cgm")

</code></pre>

<hr>
<h2 id='optR.gauss'>gauss to solve linear systems</h2><span id='topic+optR.gauss'></span>

<h3>Description</h3>

<p>Function solves linear systems using Gauss Elimination. The function solves equation of form Ax=b to Ux=c (where U is upper triangular matrix)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gauss'
optR(A, b, tol = 1e-07)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optR.gauss_+3A_a">A</code></td>
<td>
<p>: Input Matrix</p>
</td></tr>
<tr><td><code id="optR.gauss_+3A_b">b</code></td>
<td>
<p>: Response</p>
</td></tr>
<tr><td><code id="optR.gauss_+3A_tol">tol</code></td>
<td>
<p>: Tolerance</p>
</td></tr>
<tr><td><code id="optR.gauss_+3A_method">method</code></td>
<td>
<p>: To be used to perform factorization</p>
</td></tr>
</table>


<h3>Value</h3>

<p>U      : Upper triangular matrix
</p>
<p>c      : Transformed b
</p>
<p>beta   : Estimates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A&lt;-matrix(c(0,-1,1, -1,2,-1,2,-1,0), nrow=3,ncol=3, byrow = TRUE)
b&lt;-matrix(c(0,0, 1), nrow=3,ncol=1,byrow=TRUE)
Z&lt;-optR(A, b, method="gauss")
</code></pre>

<hr>
<h2 id='optR.multiplyfactor'>Function to estimate lambda</h2><span id='topic+optR.multiplyfactor'></span>

<h3>Description</h3>

<p>Function esimates the lambda or multiplier factor for Elimination using the pivot row/column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multiplyfactor'
optR(rowindex, A, pivotindex)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optR.multiplyfactor_+3A_rowindex">rowindex</code></td>
<td>
<p>: Row Index for the row to be used</p>
</td></tr>
<tr><td><code id="optR.multiplyfactor_+3A_a">A</code></td>
<td>
<p>: Input matrix</p>
</td></tr>
<tr><td><code id="optR.multiplyfactor_+3A_pivotindex">pivotindex</code></td>
<td>
<p>: Column index for the pivot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>lambda     : Lambda
</p>

<hr>
<h2 id='optRFun'>Function based optimization module</h2><span id='topic+optRFun'></span>

<h3>Description</h3>

<p>Function based optimization module
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optRFun(formula, x0, iteration = 30, method = c("newtonrapson"),
  tol = 1e-09)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optRFun_+3A_formula">formula</code></td>
<td>
<p>: Function to optimize</p>
</td></tr>
<tr><td><code id="optRFun_+3A_x0">x0</code></td>
<td>
<p>: Initial Solution</p>
</td></tr>
<tr><td><code id="optRFun_+3A_iteration">iteration</code></td>
<td>
<p>: Number of Iterations</p>
</td></tr>
<tr><td><code id="optRFun_+3A_method">method</code></td>
<td>
<p>: Method for solving the optimization</p>
</td></tr>
<tr><td><code id="optRFun_+3A_tol">tol</code></td>
<td>
<p>: Tolerance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>optRFun : Optimal Solution class
</p>

<hr>
<h2 id='optRFun.newtonRapson'>Function based optimization module</h2><span id='topic+optRFun.newtonRapson'></span>

<h3>Description</h3>

<p>Newton Rapshon based optimization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optRFun.newtonRapson(formula, x0, iteration = 30, tol = 1e-09)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optRFun.newtonRapson_+3A_formula">formula</code></td>
<td>
<p>: Function to optimize</p>
</td></tr>
<tr><td><code id="optRFun.newtonRapson_+3A_x0">x0</code></td>
<td>
<p>: Initial Solution</p>
</td></tr>
<tr><td><code id="optRFun.newtonRapson_+3A_iteration">iteration</code></td>
<td>
<p>: Number of Iterations</p>
</td></tr>
<tr><td><code id="optRFun.newtonRapson_+3A_tol">tol</code></td>
<td>
<p>: Tolerance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>optRFun : Optimal Solution
</p>

<hr>
<h2 id='predict.optR'>Prediction function based on optR class</h2><span id='topic+predict.optR'></span>

<h3>Description</h3>

<p>Function for making predictions using OptR class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'optR'
predict(object, newdata, na.action = na.pass, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.optR_+3A_object">object</code></td>
<td>
<p>: optR class fitted object</p>
</td></tr>
<tr><td><code id="predict.optR_+3A_newdata">newdata</code></td>
<td>
<p>: data for prediction</p>
</td></tr>
<tr><td><code id="predict.optR_+3A_na.action">na.action</code></td>
<td>
<p>: action for missing values</p>
</td></tr>
<tr><td><code id="predict.optR_+3A_...">...</code></td>
<td>
<p>: S3 class</p>
</td></tr>
</table>


<h3>Value</h3>

<p>fitted.val   : Predicted values
</p>
<p>terms       : terms used for fitting
</p>

<hr>
<h2 id='print.optR'>print coefficients for optR class</h2><span id='topic+print.optR'></span>

<h3>Description</h3>

<p>optR is the default function for optimization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'optR'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.optR_+3A_x">x</code></td>
<td>
<p>: Input of optR class</p>
</td></tr>
<tr><td><code id="print.optR_+3A_...">...</code></td>
<td>
<p>: S3 class</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Solving equation Ax=b
A&lt;-matrix(c(6,-4,1, -4,6,-4,1,-4,6), nrow=3,ncol=3, byrow = TRUE)
b&lt;-matrix(c(-14,36, 6), nrow=3,ncol=1,byrow=TRUE)
Z&lt;-optR(A, b, method="gauss")
print(Z)
</code></pre>

<hr>
<h2 id='summary.optR'>Generate Summary for optR class</h2><span id='topic+summary.optR'></span>

<h3>Description</h3>

<p>summary function generates the summary for the optR class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'optR'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.optR_+3A_object">object</code></td>
<td>
<p>: Input of optR class</p>
</td></tr>
<tr><td><code id="summary.optR_+3A_...">...</code></td>
<td>
<p>: S3 method</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Solving equation Ax=b
A&lt;-matrix(c(6,-4,1, -4,6,-4,1,-4,6), nrow=3,ncol=3, byrow = TRUE)
b&lt;-matrix(c(-14,36, 6), nrow=3,ncol=1,byrow=TRUE)
Z&lt;-optR(A, b, method="cgm")
summary(Z)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
