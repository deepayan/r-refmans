<!DOCTYPE html><html lang="en-US"><head><title>Help for package tibblify</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tibblify}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#tibblify-package'><p>tibblify: Rectangle Nested Lists</p></a></li>
<li><a href='#formatting'><p>Printing tibblify specifications</p></a></li>
<li><a href='#get_spec'><p>Examine the column specification</p></a></li>
<li><a href='#gh_repos'><p>GitHub Repositories</p></a></li>
<li><a href='#gh_users'><p>GitHub Users</p></a></li>
<li><a href='#got_chars'><p>Game of Thrones POV characters</p></a></li>
<li><a href='#guess_tspec'><p>Guess the <code>tibblify()</code> Specification</p></a></li>
<li><a href='#nest_tree'><p>Convert a data frame to a tree</p></a></li>
<li><a href='#parse_openapi_spec'><p>Parse an OpenAPI spec</p></a></li>
<li><a href='#politicians'><p>Politicians</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#should_inform_unspecified'><p>Determine whether to inform about unspecified fields in spec</p></a></li>
<li><a href='#tib_unspecified'><p>Create a Field Specification</p></a></li>
<li><a href='#tibblify'><p>Rectangle a nested list</p></a></li>
<li><a href='#tspec_combine'><p>Combine multiple specifications</p></a></li>
<li><a href='#tspec_df'><p>Create a Tibblify Specification</p></a></li>
<li><a href='#unnest_tree'><p>Unnest a recursive data frame</p></a></li>
<li><a href='#unpack_tspec'><p>Unpack a tibblify specification</p></a></li>
<li><a href='#untibblify'><p>Convert a data frame or object into a nested list</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Rectangle Nested Lists</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.1</td>
</tr>
<tr>
<td>Description:</td>
<td>A tool to rectangle a nested list, that is to convert it into
    a tibble. This is done automatically or according to a given
    specification.  A common use case is for nested lists coming from
    parsing JSON files or the JSON response of REST APIs. It is supported
    by the 'vctrs' package and therefore offers a wide support of vector
    types.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mgirlich/tibblify">https://github.com/mgirlich/tibblify</a>,
<a href="https://mgirlich.github.io/tibblify/">https://mgirlich.github.io/tibblify/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mgirlich/tibblify/issues">https://github.com/mgirlich/tibblify/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli (&ge; 3.6.2), lifecycle (&ge; 1.0.4), purrr (&ge; 1.0.2), rlang
(&ge; 1.1.3), tibble (&ge; 3.2.1), tidyselect (&ge; 1.2.0), vctrs (&ge;
0.6.5), withr (&ge; 2.5.2)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr (&ge; 3.6.1), jsonlite (&ge; 1.8.0), knitr (&ge; 1.40),
memoise (&ge; 2.0.1), rmarkdown (&ge; 2.16), spelling (&ge; 2.2),
testthat (&ge; 3.1.4), yaml (&ge; 2.3.6)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>vctrs (&ge; 0.6.5)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-11 07:07:59 UTC; mgirlich</td>
</tr>
<tr>
<td>Author:</td>
<td>Maximilian Girlich [aut, cre, cph],
  Kirill Müller [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Maximilian Girlich &lt;maximilian.girlich@outlook.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-11 07:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='tibblify-package'>tibblify: Rectangle Nested Lists</h2><span id='topic+tibblify-package'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p>A tool to rectangle a nested list, that is to convert it into a tibble. This is done automatically or according to a given specification. A common use case is for nested lists coming from parsing JSON files or the JSON response of REST APIs. It is supported by the 'vctrs' package and therefore offers a wide support of vector types.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Maximilian Girlich <a href="mailto:maximilian.girlich@outlook.com">maximilian.girlich@outlook.com</a> [copyright holder]
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Kirill Müller [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/mgirlich/tibblify">https://github.com/mgirlich/tibblify</a>
</p>
</li>
<li> <p><a href="https://mgirlich.github.io/tibblify/">https://mgirlich.github.io/tibblify/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/mgirlich/tibblify/issues">https://github.com/mgirlich/tibblify/issues</a>
</p>
</li></ul>


<hr>
<h2 id='formatting'>Printing tibblify specifications</h2><span id='topic+formatting'></span><span id='topic+print.tspec'></span><span id='topic+format.tspec_df'></span>

<h3>Description</h3>

<p>Printing tibblify specifications
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tspec'
print(x, width = NULL, ..., names = NULL)

## S3 method for class 'tspec_df'
format(x, width = NULL, ..., names = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="formatting_+3A_x">x</code></td>
<td>
<p>Spec to format or print</p>
</td></tr>
<tr><td><code id="formatting_+3A_width">width</code></td>
<td>
<p>Width of text output to generate.</p>
</td></tr>
<tr><td><code id="formatting_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="formatting_+3A_names">names</code></td>
<td>
<p>Should names be printed even if they can be deduced from the
spec?</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> is returned invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spec &lt;- tspec_df(
  a = tib_int("a"),
  new_name = tib_chr("b"),
  row = tib_row(
    "row",
    x = tib_int("x")
  )
)
print(spec, names = FALSE)
print(spec, names = TRUE)
</code></pre>

<hr>
<h2 id='get_spec'>Examine the column specification</h2><span id='topic+get_spec'></span>

<h3>Description</h3>

<p>Examine the column specification
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_spec(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_spec_+3A_x">x</code></td>
<td>
<p>The data frame object to extract from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibblify specification object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tibblify(list(list(x = 1, y = "a"), list(x = 2)))
get_spec(df)
</code></pre>

<hr>
<h2 id='gh_repos'>GitHub Repositories</h2><span id='topic+gh_repos'></span>

<h3>Description</h3>

<p>A dataset containing some basic information about some GitHub repositories.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gh_repos
</code></pre>


<h3>Format</h3>

<p>A list of lists.
</p>

<hr>
<h2 id='gh_users'>GitHub Users</h2><span id='topic+gh_users'></span>

<h3>Description</h3>

<p>A dataset containing some basic information about six GitHub users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gh_users
</code></pre>


<h3>Format</h3>

<p>A list of lists.
</p>

<hr>
<h2 id='got_chars'>Game of Thrones POV characters</h2><span id='topic+got_chars'></span>

<h3>Description</h3>

<p>The data is from the <a href="https://github.com/jennybc/repurrrsive">repurrrsive package</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>got_chars
</code></pre>


<h3>Format</h3>

<p>A unnamed list with 30 components, each representing a POV character.
Each character's component is a named list of length 18, containing
information such as name, aliases, and house allegiances.
</p>


<h3>Details</h3>

<p>Info on the point-of-view (POV) characters from the first five books in the
Song of Ice and Fire series by George R. R. Martin. Retrieved from An API Of
Ice And Fire.
</p>


<h3>Source</h3>

<p><a href="https://anapioficeandfire.com">https://anapioficeandfire.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>got_chars
str(lapply(got_chars, `[`, c("name", "culture")))
</code></pre>

<hr>
<h2 id='guess_tspec'>Guess the <code>tibblify()</code> Specification</h2><span id='topic+guess_tspec'></span><span id='topic+guess_tspec_df'></span><span id='topic+guess_tspec_object'></span>

<h3>Description</h3>

<p>Use <code>guess_tspec()</code> if you don't know the input type.
Use <code>guess_tspec_df()</code> if the input is a data frame or an object list.
Use <code>guess_tspec_objecte()</code> is the input is an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guess_tspec(
  x,
  ...,
  empty_list_unspecified = FALSE,
  simplify_list = FALSE,
  inform_unspecified = should_inform_unspecified(),
  call = rlang::current_call()
)

guess_tspec_df(
  x,
  ...,
  empty_list_unspecified = FALSE,
  simplify_list = FALSE,
  inform_unspecified = should_inform_unspecified(),
  call = rlang::current_call(),
  arg = rlang::caller_arg(x)
)

guess_tspec_object(
  x,
  ...,
  empty_list_unspecified = FALSE,
  simplify_list = FALSE,
  call = rlang::current_call()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="guess_tspec_+3A_x">x</code></td>
<td>
<p>A nested list.</p>
</td></tr>
<tr><td><code id="guess_tspec_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="guess_tspec_+3A_empty_list_unspecified">empty_list_unspecified</code></td>
<td>
<p>Treat empty lists as unspecified?</p>
</td></tr>
<tr><td><code id="guess_tspec_+3A_simplify_list">simplify_list</code></td>
<td>
<p>Should scalar lists be simplified to vectors?</p>
</td></tr>
<tr><td><code id="guess_tspec_+3A_inform_unspecified">inform_unspecified</code></td>
<td>
<p>Inform about fields whose type could not be
determined?</p>
</td></tr>
<tr><td><code id="guess_tspec_+3A_call">call</code></td>
<td>
<p>The execution environment of a currently running function, e.g.
<code>caller_env()</code>. The function will be mentioned in error messages as the
source of the error. See the <code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more
information.</p>
</td></tr>
<tr><td><code id="guess_tspec_+3A_arg">arg</code></td>
<td>
<p>An argument name as a string. This argument will be mentioned in
error messages as the input that is at the origin of a problem.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A specification object that can used in <code>tibblify()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>guess_tspec(list(x = 1, y = "a"))
guess_tspec(list(list(x = 1), list(x = 2)))

guess_tspec(gh_users)
</code></pre>

<hr>
<h2 id='nest_tree'>Convert a data frame to a tree</h2><span id='topic+nest_tree'></span>

<h3>Description</h3>

<p>Convert a data frame to a tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nest_tree(data, id_col, parent_col, children_to)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nest_tree_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="nest_tree_+3A_id_col">id_col</code></td>
<td>
<p>Id column. The values must be unique and non-missing.</p>
</td></tr>
<tr><td><code id="nest_tree_+3A_parent_col">parent_col</code></td>
<td>
<p>Parent column. Each value must either be missing (for the
root elements) or appear in the <code>id_col</code> column.</p>
</td></tr>
<tr><td><code id="nest_tree_+3A_children_to">children_to</code></td>
<td>
<p>Name of the column the children should be put.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tree like data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tibble::tibble(
  id = 1:5,
  x = letters[1:5],
  parent = c(NA, NA, 1L, 2L, 4L)
)
out &lt;- nest_tree(df, id, parent, "children")
out

out$children
out$children[[2]]$children
</code></pre>

<hr>
<h2 id='parse_openapi_spec'>Parse an OpenAPI spec</h2><span id='topic+parse_openapi_spec'></span><span id='topic+parse_openapi_schema'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
Use <code>parse_openapi_spec()</code> to parse a <a href="https://swagger.io/specification/">OpenAPI spec</a>
or use <code>parse_openapi_schema()</code> to parse a OpenAPI schema.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_openapi_spec(file)

parse_openapi_schema(file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_openapi_spec_+3A_file">file</code></td>
<td>
<p>Either a path to a file, a connection, or literal data (a
single string).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>parse_openapi_spec()</code> a data frame with the columns
</p>

<ul>
<li> <p><code>endpoint</code> <code style="white-space: pre;">&#8288;&lt;character&gt;&#8288;</code> Name of the endpoint.
</p>
</li>
<li> <p><code>operation</code> <code style="white-space: pre;">&#8288;&lt;character&gt;&#8288;</code> The http operation; one of <code>"get"</code>, <code>"put"</code>,
<code>"post"</code>, <code>"delete"</code>, <code>"options"</code>, <code>"head"</code>, <code>"patch"</code>, or <code>"trace"</code>.
</p>
</li>
<li> <p><code>status_code</code> <code style="white-space: pre;">&#8288;&lt;character&gt;&#8288;</code> The http status code. May contain wildcards like
<code style="white-space: pre;">&#8288;2xx&#8288;</code> for all response codes between <code>200</code> and <code>299</code>.
</p>
</li>
<li> <p><code>media_type</code> <code style="white-space: pre;">&#8288;&lt;character&gt;&#8288;</code> The media type.
</p>
</li>
<li> <p><code>spec</code> <code style="white-space: pre;">&#8288;&lt;list&gt;&#8288;</code> A list of tibblify specifications.
</p>
</li></ul>

<p>For <code>parse_openapi_schema()</code> a tibblify spec.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- '{
  "$schema": "http://json-schema.org/draft-04/schema",
  "title": "Starship",
  "description": "A vehicle.",
  "type": "object",
  "properties": {
    "name": {
      "type": "string",
      "description": "The name of this vehicle. The common name, e.g. Sand Crawler."
    },
    "model": {
      "type": "string",
      "description": "The model or official name of this vehicle."
    },
    "url": {
      "type": "string",
      "format": "uri",
      "description": "The hypermedia URL of this resource."
    },
    "edited": {
      "type": "string",
      "format": "date-time",
      "description": "the ISO 8601 date format of the time this resource was edited."
    }
  },
  "required": [
    "name",
    "model",
    "edited"
  ]
}'

parse_openapi_schema(file)
</code></pre>

<hr>
<h2 id='politicians'>Politicians</h2><span id='topic+politicians'></span>

<h3>Description</h3>

<p>A dataset containing some basic information about some politicians.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>politicians
</code></pre>


<h3>Format</h3>

<p>A list of lists.
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+zap'></span><span id='topic+tibble'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>rlang</dt><dd><p><code><a href="rlang.html#topic+zap">zap</a></code></p>
</dd>
<dt>tibble</dt><dd><p><code><a href="tibble.html#topic+tibble">tibble</a></code></p>
</dd>
</dl>

<hr>
<h2 id='should_inform_unspecified'>Determine whether to inform about unspecified fields in spec</h2><span id='topic+should_inform_unspecified'></span>

<h3>Description</h3>

<p>Wrapper around <code>getOption("tibblify.show_unspecified")</code> that implements some
#' fall back logic if the option is unset. This returns:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>should_inform_unspecified()
</code></pre>


<h3>Details</h3>


<ul>
<li> <p><code>TRUE</code> if the option is set to <code>TRUE</code>
</p>
</li>
<li> <p><code>FALSE</code> if the option is set to <code>FALSE</code>
</p>
</li>
<li> <p><code>FALSE</code> if the option is unset and we appear to be running tests
</p>
</li>
<li> <p><code>TRUE</code> otherwise
</p>
</li></ul>



<h3>Value</h3>

<p><code>TRUE</code> or <code>FALSE</code>.
</p>

<hr>
<h2 id='tib_unspecified'>Create a Field Specification</h2><span id='topic+tib_unspecified'></span><span id='topic+tib_scalar'></span><span id='topic+tib_lgl'></span><span id='topic+tib_int'></span><span id='topic+tib_dbl'></span><span id='topic+tib_chr'></span><span id='topic+tib_date'></span><span id='topic+tib_chr_date'></span><span id='topic+tib_vector'></span><span id='topic+tib_lgl_vec'></span><span id='topic+tib_int_vec'></span><span id='topic+tib_dbl_vec'></span><span id='topic+tib_chr_vec'></span><span id='topic+tib_date_vec'></span><span id='topic+tib_chr_date_vec'></span><span id='topic+tib_variant'></span><span id='topic+tib_recursive'></span><span id='topic+tib_row'></span><span id='topic+tib_df'></span>

<h3>Description</h3>

<p>Use these functions to specify how to convert the fields of an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tib_unspecified(key, ..., required = TRUE)

tib_scalar(
  key,
  ptype,
  ...,
  required = TRUE,
  fill = NULL,
  ptype_inner = ptype,
  transform = NULL
)

tib_lgl(
  key,
  ...,
  required = TRUE,
  fill = NULL,
  ptype_inner = logical(),
  transform = NULL
)

tib_int(
  key,
  ...,
  required = TRUE,
  fill = NULL,
  ptype_inner = integer(),
  transform = NULL
)

tib_dbl(
  key,
  ...,
  required = TRUE,
  fill = NULL,
  ptype_inner = double(),
  transform = NULL
)

tib_chr(
  key,
  ...,
  required = TRUE,
  fill = NULL,
  ptype_inner = character(),
  transform = NULL
)

tib_date(
  key,
  ...,
  required = TRUE,
  fill = NULL,
  ptype_inner = vctrs::new_date(),
  transform = NULL
)

tib_chr_date(key, ..., required = TRUE, fill = NULL, format = "%Y-%m-%d")

tib_vector(
  key,
  ptype,
  ...,
  required = TRUE,
  fill = NULL,
  ptype_inner = ptype,
  transform = NULL,
  elt_transform = NULL,
  input_form = c("vector", "scalar_list", "object"),
  values_to = NULL,
  names_to = NULL
)

tib_lgl_vec(
  key,
  ...,
  required = TRUE,
  fill = NULL,
  ptype_inner = logical(),
  transform = NULL,
  elt_transform = NULL,
  input_form = c("vector", "scalar_list", "object"),
  values_to = NULL,
  names_to = NULL
)

tib_int_vec(
  key,
  ...,
  required = TRUE,
  fill = NULL,
  ptype_inner = integer(),
  transform = NULL,
  elt_transform = NULL,
  input_form = c("vector", "scalar_list", "object"),
  values_to = NULL,
  names_to = NULL
)

tib_dbl_vec(
  key,
  ...,
  required = TRUE,
  fill = NULL,
  ptype_inner = double(),
  transform = NULL,
  elt_transform = NULL,
  input_form = c("vector", "scalar_list", "object"),
  values_to = NULL,
  names_to = NULL
)

tib_chr_vec(
  key,
  ...,
  required = TRUE,
  fill = NULL,
  ptype_inner = character(),
  transform = NULL,
  elt_transform = NULL,
  input_form = c("vector", "scalar_list", "object"),
  values_to = NULL,
  names_to = NULL
)

tib_date_vec(
  key,
  ...,
  required = TRUE,
  fill = NULL,
  ptype_inner = vctrs::new_date(),
  transform = NULL,
  elt_transform = NULL,
  input_form = c("vector", "scalar_list", "object"),
  values_to = NULL,
  names_to = NULL
)

tib_chr_date_vec(
  key,
  ...,
  required = TRUE,
  fill = NULL,
  input_form = c("vector", "scalar_list", "object"),
  values_to = NULL,
  names_to = NULL,
  format = "%Y-%m-%d"
)

tib_variant(
  key,
  ...,
  required = TRUE,
  fill = NULL,
  transform = NULL,
  elt_transform = NULL
)

tib_recursive(.key, ..., .children, .children_to = .children, .required = TRUE)

tib_row(.key, ..., .required = TRUE)

tib_df(.key, ..., .required = TRUE, .names_to = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tib_unspecified_+3A_key">key</code>, <code id="tib_unspecified_+3A_.key">.key</code></td>
<td>
<p>The path to the field in the object.</p>
</td></tr>
<tr><td><code id="tib_unspecified_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="tib_unspecified_+3A_required">required</code>, <code id="tib_unspecified_+3A_.required">.required</code></td>
<td>
<p>Throw an error if the field does not exist?</p>
</td></tr>
<tr><td><code id="tib_unspecified_+3A_ptype">ptype</code></td>
<td>
<p>A prototype of the desired output type of the field.</p>
</td></tr>
<tr><td><code id="tib_unspecified_+3A_fill">fill</code></td>
<td>
<p>Optionally, a value to use if the field does not exist.</p>
</td></tr>
<tr><td><code id="tib_unspecified_+3A_ptype_inner">ptype_inner</code></td>
<td>
<p>A prototype of the field.</p>
</td></tr>
<tr><td><code id="tib_unspecified_+3A_transform">transform</code></td>
<td>
<p>A function to apply to the whole vector after casting to
<code>ptype_inner</code>.</p>
</td></tr>
<tr><td><code id="tib_unspecified_+3A_format">format</code></td>
<td>
<p>Optional, a string passed to the <code>format</code> argument of <code>as.Date()</code>.</p>
</td></tr>
<tr><td><code id="tib_unspecified_+3A_elt_transform">elt_transform</code></td>
<td>
<p>A function to apply to each element before casting
to <code>ptype_inner</code>.</p>
</td></tr>
<tr><td><code id="tib_unspecified_+3A_input_form">input_form</code></td>
<td>
<p>A string that describes what structure the field has. Can
be one of:
</p>

<ul>
<li> <p><code>"vector"</code>: The field is a vector, e.g. <code>c(1, 2, 3)</code>.
</p>
</li>
<li> <p><code>"scalar_list"</code>: The field is a list of scalars, e.g. <code>list(1, 2, 3)</code>.
</p>
</li>
<li> <p><code>"object"</code>: The field is a named list of scalars, e.g. <code>list(a = 1, b = 2, c = 3)</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tib_unspecified_+3A_values_to">values_to</code></td>
<td>
<p>Can be one of the following:
</p>

<ul>
<li> <p><code>NULL</code>: the default. The field is converted to a <code>ptype</code> vector.
</p>
</li>
<li><p> A string: The field is converted to a tibble and the values go into the
specified column.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tib_unspecified_+3A_names_to">names_to</code></td>
<td>
<p>Can be one of the following:
</p>

<ul>
<li> <p><code>NULL</code>: the default. The inner names of the field are not used.
</p>
</li>
<li><p> A string: This can only be used if 1) for the input form is <code>"object"</code>
or <code>"vector"</code> and 2) <code>values_to</code> is a string. The inner names of the
field go into the specified column.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tib_unspecified_+3A_.children">.children</code></td>
<td>
<p>A string giving the name of field that contains the children.</p>
</td></tr>
<tr><td><code id="tib_unspecified_+3A_.children_to">.children_to</code></td>
<td>
<p>A string giving the column name to store the children.</p>
</td></tr>
<tr><td><code id="tib_unspecified_+3A_.names_to">.names_to</code></td>
<td>
<p>A string giving the name of the column which will contain
the names of elements of the object list. If <code>NULL</code>, the default, no name
column is created</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are basically five different <code style="white-space: pre;">&#8288;tib_*()&#8288;</code> functions
</p>

<ul>
<li> <p><code>tib_scalar(ptype)</code>: Cast the field to a length one vector of type <code>ptype</code>.
</p>
</li>
<li> <p><code>tib_vector(ptype)</code>: Cast the field to an arbitrary length vector of type <code>ptype</code>.
</p>
</li>
<li> <p><code>tib_variant()</code>: Cast the field to a list.
</p>
</li>
<li> <p><code>tib_row()</code>: Cast the field to a named list.
</p>
</li>
<li> <p><code>tib_df()</code>: Cast the field to a tibble.
</p>
</li></ul>

<p>There are some special shortcuts of <code>tib_scalar()</code> resp. <code>tib_vector()</code> for
the most common prototypes
</p>

<ul>
<li> <p><code>logical()</code>: <code>tib_lgl()</code> resp. <code>tib_lgl_vec()</code>
</p>
</li>
<li> <p><code>integer()</code>: <code>tib_int()</code> resp. <code>tib_int_vec()</code>
</p>
</li>
<li> <p><code>double()</code>: <code>tib_dbl()</code> resp. <code>tib_dbl_vec()</code>
</p>
</li>
<li> <p><code>character()</code>: <code>tib_chr()</code> resp. <code>tib_chr_vec()</code>
</p>
</li>
<li> <p><code>Date</code>: <code>tib_date()</code> resp. <code>tib_date_vec()</code>
</p>
</li></ul>

<p>Further, there is also a special shortcut for dates encoded as character:
<code>tib_chr_date()</code> resp. <code>tib_chr_date_vec()</code>.
</p>


<h3>Value</h3>

<p>A tibblify field collector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tib_int("int")
tib_int("int", required = FALSE, fill = 0)

tib_scalar("date", Sys.Date(), transform = function(x) as.Date(x, format = "%Y-%m-%d"))

tib_df(
  "data",
  .names_to = "id",
  age = tib_int("age"),
  name = tib_chr("name")
)
</code></pre>

<hr>
<h2 id='tibblify'>Rectangle a nested list</h2><span id='topic+tibblify'></span>

<h3>Description</h3>

<p>Rectangle a nested list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tibblify(x, spec = NULL, unspecified = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tibblify_+3A_x">x</code></td>
<td>
<p>A nested list.</p>
</td></tr>
<tr><td><code id="tibblify_+3A_spec">spec</code></td>
<td>
<p>A specification how to convert <code>x</code>. Generated with <code>tspec_row()</code>
or <code>tspec_df()</code>.</p>
</td></tr>
<tr><td><code id="tibblify_+3A_unspecified">unspecified</code></td>
<td>
<p>A string that describes what happens if the specification
contains unspecified fields. Can be one of
</p>

<ul>
<li> <p><code>"error"</code>: Throw an error.
</p>
</li>
<li> <p><code>"inform"</code>: Inform.
</p>
</li>
<li> <p><code>"drop"</code>: Do not parse these fields.
</p>
</li>
<li> <p><code>"list"</code>: Parse an unspecified field into a list.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a tibble or a list, depending on the specification
</p>


<h3>See Also</h3>

<p>Use <code><a href="#topic+untibblify">untibblify()</a></code> to undo the result of <code>tibblify()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># List of Objects -----------------------------------------------------------
x &lt;- list(
  list(id = 1, name = "Tyrion Lannister"),
  list(id = 2, name = "Victarion Greyjoy")
)
tibblify(x)

# Provide a specification
spec &lt;- tspec_df(
  id = tib_int("id"),
  name = tib_chr("name")
)
tibblify(x, spec)

# Object --------------------------------------------------------------------
# Provide a specification for a single object
tibblify(x[[1]], tspec_object(spec))

# Recursive Trees -----------------------------------------------------------
x &lt;- list(
  list(
    id = 1,
    name = "a",
    children = list(
      list(id = 11, name = "aa"),
      list(id = 12, name = "ab", children = list(
        list(id = 121, name = "aba")
      ))
    ))
)
spec &lt;- tspec_recursive(
  tib_int("id"),
  tib_chr("name"),
  .children = "children"
)
out &lt;- tibblify(x, spec)
out
out$children
out$children[[1]]$children[[2]]
</code></pre>

<hr>
<h2 id='tspec_combine'>Combine multiple specifications</h2><span id='topic+tspec_combine'></span>

<h3>Description</h3>

<p>Combine multiple specifications
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tspec_combine(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tspec_combine_+3A_...">...</code></td>
<td>
<p>Specifications to combine.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibblify specification.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># union of fields
tspec_combine(
  tspec_df(tib_int("a")),
  tspec_df(tib_chr("b"))
)

# unspecified + x -&gt; x
tspec_combine(
  tspec_df(tib_unspecified("a"), tib_chr("b")),
  tspec_df(tib_int("a"), tib_variant("b"))
)

# scalar + vector -&gt; vector
tspec_combine(
  tspec_df(tib_chr("a")),
  tspec_df(tib_chr_vec("a"))
)

# scalar/vector + variant -&gt; variant
tspec_combine(
  tspec_df(tib_chr("a")),
  tspec_df(tib_variant("a"))
)
</code></pre>

<hr>
<h2 id='tspec_df'>Create a Tibblify Specification</h2><span id='topic+tspec_df'></span><span id='topic+tspec_object'></span><span id='topic+tspec_recursive'></span><span id='topic+tspec_row'></span>

<h3>Description</h3>

<p>Use <code>tspec_df()</code> to specify how to convert a list of objects to a tibble.
Use <code>tspec_row()</code> resp. <code>tspec_object()</code> to specify how to convert an object
to a one row tibble resp. a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tspec_df(
  ...,
  .input_form = c("rowmajor", "colmajor"),
  .names_to = NULL,
  vector_allows_empty_list = FALSE
)

tspec_object(
  ...,
  .input_form = c("rowmajor", "colmajor"),
  vector_allows_empty_list = FALSE
)

tspec_recursive(
  ...,
  .children,
  .children_to = .children,
  .input_form = c("rowmajor", "colmajor"),
  vector_allows_empty_list = FALSE
)

tspec_row(
  ...,
  .input_form = c("rowmajor", "colmajor"),
  vector_allows_empty_list = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tspec_df_+3A_...">...</code></td>
<td>
<p>Column specification created by <code style="white-space: pre;">&#8288;tib_*()&#8288;</code> or <code style="white-space: pre;">&#8288;tspec_*()&#8288;</code>.</p>
</td></tr>
<tr><td><code id="tspec_df_+3A_.input_form">.input_form</code></td>
<td>
<p>The input form of data frame like lists. Can be one of:
</p>

<ul>
<li> <p><code>"rowmajor"</code>: The default. The data frame is formed by a list of rows.
</p>
</li>
<li> <p><code>"colmajor"</code>: The data frame is a named list of columns.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tspec_df_+3A_.names_to">.names_to</code></td>
<td>
<p>A string giving the name of the column which will contain
the names of elements of the object list. If <code>NULL</code>, the default, no name
column is created</p>
</td></tr>
<tr><td><code id="tspec_df_+3A_vector_allows_empty_list">vector_allows_empty_list</code></td>
<td>
<p>Should empty lists for <code>input_form = "vector"</code>
be accepted and treated as empty vector?</p>
</td></tr>
<tr><td><code id="tspec_df_+3A_.children">.children</code></td>
<td>
<p>A string giving the name of field that contains the children.</p>
</td></tr>
<tr><td><code id="tspec_df_+3A_.children_to">.children_to</code></td>
<td>
<p>A string giving the column name to store the children.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In column major format all fields are required, regardless of the <code>required</code>
argument.
</p>


<h3>Value</h3>

<p>A tibblify specification.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tspec_df(
  id = tib_int("id"),
  name = tib_chr("name"),
  aliases = tib_chr_vec("aliases")
)

# To create multiple columns of the same type use the bang-bang-bang (!!!)
# operator together with `purrr::map()`
tspec_df(
  !!!purrr::map(purrr::set_names(c("id", "age")), tib_int),
  !!!purrr::map(purrr::set_names(c("name", "title")), tib_chr)
)

# The `tspec_*()` functions can also be nested
spec1 &lt;- tspec_object(
  int = tib_int("int"),
  chr = tib_chr("chr")
)
spec2 &lt;- tspec_object(
  int2 = tib_int("int2"),
  chr2 = tib_chr("chr2")
)

tspec_df(spec1, spec2)
</code></pre>

<hr>
<h2 id='unnest_tree'>Unnest a recursive data frame</h2><span id='topic+unnest_tree'></span>

<h3>Description</h3>

<p>Unnest a recursive data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unnest_tree(
  data,
  id_col,
  child_col,
  level_to = "level",
  parent_to = "parent",
  ancestors_to = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unnest_tree_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="unnest_tree_+3A_id_col">id_col</code></td>
<td>
<p>A column that uniquely identifies each observation.</p>
</td></tr>
<tr><td><code id="unnest_tree_+3A_child_col">child_col</code></td>
<td>
<p>Column containing the children of an observation. This must
be a list where each element is either <code>NULL</code> or a data frame with the same
columns as <code>data</code>.</p>
</td></tr>
<tr><td><code id="unnest_tree_+3A_level_to">level_to</code></td>
<td>
<p>A string (<code>"level"</code> by default) specifying the new column to
store the level of an observation. Use <code>NULL</code> if you don't need this
information.</p>
</td></tr>
<tr><td><code id="unnest_tree_+3A_parent_to">parent_to</code></td>
<td>
<p>A string (<code>"parent"</code> by default) specifying the new column
storing the parent id of an observation. Use <code>NULL</code> if you don't need this
information.</p>
</td></tr>
<tr><td><code id="unnest_tree_+3A_ancestors_to">ancestors_to</code></td>
<td>
<p>A string (<code>NULL</code> by default) specifying the new column
storing the ids of its ancestors. Use <code>NULL</code> if you don't need this
information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- tibble(
  id = 1L,
  name = "a",
  children = list(
    tibble(
      id = 11:12,
      name = c("b", "c"),
      children = list(
        NULL,
        tibble(
          id = 121:122,
          name = c("d", "e")
        )
      )
    )
  )
)

unnest_tree(
  df,
  id_col = "id",
  child_col = "children",
  level_to = "level",
  parent_to = "parent",
  ancestors_to = "ancestors"
)
</code></pre>

<hr>
<h2 id='unpack_tspec'>Unpack a tibblify specification</h2><span id='topic+unpack_tspec'></span><span id='topic+camel_case_to_snake_case'></span>

<h3>Description</h3>

<p>Unpack a tibblify specification
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unpack_tspec(
  spec,
  ...,
  fields = NULL,
  recurse = TRUE,
  names_sep = NULL,
  names_repair = c("unique", "universal", "check_unique", "unique_quiet",
    "universal_quiet"),
  names_clean = NULL
)

camel_case_to_snake_case(names)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unpack_tspec_+3A_spec">spec</code></td>
<td>
<p>A tibblify specification.</p>
</td></tr>
<tr><td><code id="unpack_tspec_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="unpack_tspec_+3A_fields">fields</code></td>
<td>
<p>A string of the fields to unpack.</p>
</td></tr>
<tr><td><code id="unpack_tspec_+3A_recurse">recurse</code></td>
<td>
<p>Should unpack recursively?</p>
</td></tr>
<tr><td><code id="unpack_tspec_+3A_names_sep">names_sep</code></td>
<td>
<p>If <code>NULL</code>, the default, the inner names of fields are used.
If a string, the outer and inner names are pasted together, separated by
<code>names_sep</code>.</p>
</td></tr>
<tr><td><code id="unpack_tspec_+3A_names_repair">names_repair</code></td>
<td>
<p>Used to check that output data frame has valid names.
Must be one of the following options:
</p>

<ul>
<li> <p><code>"unique"</code> or <code>"unique_quiet"</code>: (the default) make sure names are unique and not empty,
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;"universal" or &#8288;</code>&quot;unique_quiet&quot;': make the names unique and syntactic
</p>
</li>
<li> <p><code>"check_unique"</code>: no name repair, but check they are unique,
</p>
</li>
<li><p> a function: apply custom name repair.
</p>
</li></ul>

<p>See <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="unpack_tspec_+3A_names_clean">names_clean</code></td>
<td>
<p>A function to clean names after repairing. For example
use <code><a href="#topic+camel_case_to_snake_case">camel_case_to_snake_case()</a></code>.</p>
</td></tr>
<tr><td><code id="unpack_tspec_+3A_names">names</code></td>
<td>
<p>Names to clean</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibblify spec.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spec &lt;- tspec_df(
  tib_lgl("a"),
  tib_row("x", tib_int("b"), tib_chr("c")),
  tib_row("y", tib_row("z", tib_chr("d")))
)

unpack_tspec(spec)
# only unpack `x`
unpack_tspec(spec, fields = "x")
# do not unpack the fields in `y`
unpack_tspec(spec, recurse = FALSE)
</code></pre>

<hr>
<h2 id='untibblify'>Convert a data frame or object into a nested list</h2><span id='topic+untibblify'></span>

<h3>Description</h3>

<p>The inverse operation to <code>tibblify()</code>. It converts a data frame or an object
into a nested list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>untibblify(x, spec = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="untibblify_+3A_x">x</code></td>
<td>
<p>A data frame or an object.</p>
</td></tr>
<tr><td><code id="untibblify_+3A_spec">spec</code></td>
<td>
<p>Optional. A spec object which was used to create <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A nested list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- tibble(
  a = 1:2,
  b = tibble(
    x = c("a", "b"),
    y = c(1.5, 2.5)
  )
)
untibblify(x)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
