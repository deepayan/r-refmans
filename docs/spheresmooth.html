<!DOCTYPE html><html><head><title>Help for package spheresmooth</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spheresmooth}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#apw_spherical'><p>A polar wander dataset</p></a></li>
<li><a href='#calculate_loss'><p>Calculate Loss Function</p></a></li>
<li><a href='#Cartesian_to_Spherical'><p>Convert Cartesian coordinates to cpherical coordinates</p></a></li>
<li><a href='#cross'><p>Compute the cross product of two vectors</p></a></li>
<li><a href='#cross_normalized'><p>Compute the normalized cross product of two vectors</p></a></li>
<li><a href='#dot'><p>Compute the dot product of two vectors</p></a></li>
<li><a href='#edp'><p>Compute the equal-distance projection of a point onto the xy plane</p></a></li>
<li><a href='#Exp'><p>Compute the exponential map on the unit sphere.</p></a></li>
<li><a href='#Geodesic'><p>Compute the value of the geodesic curve connecting two points on the unit sphere for a given set of time points t</p></a></li>
<li><a href='#goni_spherical'><p>A tropical cyclone dataset</p></a></li>
<li><a href='#knots_quantile'><p>Generate knots for the piecewise geodesic curve based on the quantiles</p></a></li>
<li><a href='#norm2'><p>Compute the L2 norm (Euclidean norm) of a vector</p></a></li>
<li><a href='#Normalize'><p>Normalize a matrix row-wise</p></a></li>
<li><a href='#penalized_linear_spherical_spline'><p>Penalized Linear Spherical Spline</p></a></li>
<li><a href='#piecewise_geodesic'><p>Piecewise Geodesic</p></a></li>
<li><a href='#spherical_dist'><p>Calculate spherical distance between two vectors</p></a></li>
<li><a href='#Spherical_to_Cartesian'><p>Convert spherical coordinates to Cartesian coordinates</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Piecewise Geodesic Smoothing for Spherical Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Fitting a smooth path to a given set of noisy spherical data observed at known time points. It implements a piecewise geodesic curve fitting method on the unit sphere based on a velocity-based penalization scheme. The proposed approach is implemented using the Riemannian block coordinate descent algorithm. To understand the method and algorithm, one can refer to Bak, K. Y., Shin, J. K., &amp; Koo, J. Y. (2023) &lt;<a href="https://doi.org/10.1080%2F02664763.2022.2054962">doi:10.1080/02664763.2022.2054962</a>&gt; for the case of order 1. Additionally, this package includes various functions necessary for handling spherical data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rgl, sphereplot</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-17 14:04:35 UTC; bak</td>
</tr>
<tr>
<td>Author:</td>
<td>Seyoung Lee [aut] (Sungshin Women's University),
  Kwan-Young Bak <a href="https://orcid.org/0000-0002-4541-160X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph] (Sungshin Women's University)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kwan-Young Bak &lt;kybak@sungshin.ac.kr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-18 14:32:48 UTC</td>
</tr>
</table>
<hr>
<h2 id='apw_spherical'>A polar wander dataset</h2><span id='topic+apw_spherical'></span>

<h3>Description</h3>

<p>A polar wander dataset presented in Kent and Irving (2010). The 17 Triassic/Jurassic cratonic poles from other major cratons are rotated into North American coordinates and combined with the 14 observations from North America. Our method is applied to these 31 observations ranging in age from 243 to 144 Ma (millions of years ago), which covers the late Triassic and Jurassic periods. The first column represents the time points, and the remaining two columns provides the observed spherical coordinates.
</p>

<hr>
<h2 id='calculate_loss'>Calculate Loss Function</h2><span id='topic+calculate_loss'></span>

<h3>Description</h3>

<p>This function calculates the loss function based on the squared spherical distances between observed values and predicted values on the curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_loss(y, gamma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_loss_+3A_y">y</code></td>
<td>
<p>Matrix of observed values.</p>
</td></tr>
<tr><td><code id="calculate_loss_+3A_gamma">gamma</code></td>
<td>
<p>Matrix of predicted values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Loss value.
</p>

<hr>
<h2 id='Cartesian_to_Spherical'>Convert Cartesian coordinates to cpherical coordinates</h2><span id='topic+Cartesian_to_Spherical'></span>

<h3>Description</h3>

<p>This function converts Cartesian coordinates to spherical coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Cartesian_to_Spherical(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Cartesian_to_Spherical_+3A_x">x</code></td>
<td>
<p>A matrix where each row represents a point in Cartesian coordinates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Cartesian coordinates (x, y, z) are converted to spherical coordinates (theta, phi).
Theta represents the inclination angle (0 to pi), and phi represents the azimuth angle (0 to 2*pi).
</p>


<h3>Value</h3>

<p>A matrix where each row represents a point in spherical coordinates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#example1
cartesian_points1 &lt;- matrix(c(1/sqrt(3), 1/sqrt(3), 1/sqrt(3),-1/sqrt(3), 1/sqrt(3), -1/sqrt(3)),
  ncol = 3, byrow = TRUE)
Cartesian_to_Spherical(cartesian_points1)
#example2
cartesian_points2 &lt;- matrix(c(1, 0, 0, 0, 1, 0, 0, 0, 1),ncol = 3, byrow = TRUE)
Cartesian_to_Spherical(cartesian_points2)
</code></pre>

<hr>
<h2 id='cross'>Compute the cross product of two vectors</h2><span id='topic+cross'></span>

<h3>Description</h3>

<p>This function computes the cross product of two input vectors u and v.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross(u, v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cross_+3A_u">u</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="cross_+3A_v">v</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector representing the cross product of u and v.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cross(c(1,0,0), c(0,1,0))
</code></pre>

<hr>
<h2 id='cross_normalized'>Compute the normalized cross product of two vectors</h2><span id='topic+cross_normalized'></span>

<h3>Description</h3>

<p>This function computes the cross product of two input vectors u and v,
normalizes the result, and returns the normalized vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross_normalized(u, v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cross_normalized_+3A_u">u</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="cross_normalized_+3A_v">v</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector representing the normalized cross product of u and v.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cross_normalized(c(1,0,0), c(0,1,0))
</code></pre>

<hr>
<h2 id='dot'>Compute the dot product of two vectors</h2><span id='topic+dot'></span>

<h3>Description</h3>

<p>This function computes the dot product of two input vectors u and v.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dot(u, v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dot_+3A_u">u</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="dot_+3A_v">v</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value representing the dot product of u and v.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dot(c(1,2,3), c(4,5,6))
</code></pre>

<hr>
<h2 id='edp'>Compute the equal-distance projection of a point onto the xy plane</h2><span id='topic+edp'></span>

<h3>Description</h3>

<p>This function computes the equal-distance projection of a point p onto the xy plane.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edp(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edp_+3A_p">p</code></td>
<td>
<p>Numeric vector representing a point in Cartesian coordinates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector representing the equal-distance projection of p onto the xy plane.
</p>

<hr>
<h2 id='Exp'>Compute the exponential map on the unit sphere.</h2><span id='topic+Exp'></span>

<h3>Description</h3>

<p>This function computes the exponential map on the unit sphere given a base point x and a vector v.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Exp(x, v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Exp_+3A_x">x</code></td>
<td>
<p>Numeric vector representing the base point.</p>
</td></tr>
<tr><td><code id="Exp_+3A_v">v</code></td>
<td>
<p>Numeric vector representing a point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector representing the result of the exponential map.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Exp(c(0,0,1), c(1,1,0))
</code></pre>

<hr>
<h2 id='Geodesic'>Compute the value of the geodesic curve connecting two points on the unit sphere for a given set of time points t</h2><span id='topic+Geodesic'></span>

<h3>Description</h3>

<p>This function computes the value of the geodesic curve connecting two points p and q on the unit sphere at specified time points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Geodesic(t, p, q, a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Geodesic_+3A_t">t</code></td>
<td>
<p>Numeric vector representing time points for the geodesic path.</p>
</td></tr>
<tr><td><code id="Geodesic_+3A_p">p</code></td>
<td>
<p>Numeric vector representing the starting point on the sphere.</p>
</td></tr>
<tr><td><code id="Geodesic_+3A_q">q</code></td>
<td>
<p>Numeric vector representing the ending point on the sphere.</p>
</td></tr>
<tr><td><code id="Geodesic_+3A_a">a</code></td>
<td>
<p>Start time parameter.</p>
</td></tr>
<tr><td><code id="Geodesic_+3A_b">b</code></td>
<td>
<p>End time parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric matrix representing points along the geodesic path at specified time points.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Geodesic(c(0.25, 0.5, 0.75), c(1,0,0), c(0,1,0), 0, 1)
</code></pre>

<hr>
<h2 id='goni_spherical'>A tropical cyclone dataset</h2><span id='topic+goni_spherical'></span>

<h3>Description</h3>

<p>A tropical cyclone dataset provided by the Regional Specialized Meteorological Center (RSMC) Tokyo Typhoon Center. We select a cyclone called 'Goni' observed over time  on August, 2015. The first column represents the time points, and the remaining two columns provides the observed spherical coordinates.
</p>

<hr>
<h2 id='knots_quantile'>Generate knots for the piecewise geodesic curve based on the quantiles</h2><span id='topic+knots_quantile'></span>

<h3>Description</h3>

<p>This generates a sequence of knots for a given set of time points based on the quantiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knots_quantile(x, dimension, tiny = 1e-05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knots_quantile_+3A_x">x</code></td>
<td>
<p>Numeric vector representing time points for the geodesic path.</p>
</td></tr>
<tr><td><code id="knots_quantile_+3A_dimension">dimension</code></td>
<td>
<p>Numeric vector the number of knots.</p>
</td></tr>
<tr><td><code id="knots_quantile_+3A_tiny">tiny</code></td>
<td>
<p>Numeric value representing a small constant that slightly expands the boundary.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector representing knots sequence in the time domain.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>knots_quantile(seq(0, 1, length.out = 100), 10)
</code></pre>

<hr>
<h2 id='norm2'>Compute the L2 norm (Euclidean norm) of a vector</h2><span id='topic+norm2'></span>

<h3>Description</h3>

<p>This function computes the L2 norm (Euclidean norm) of the input vector u.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm2(u)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norm2_+3A_u">u</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value representing the L2 norm of u.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>norm2(c(1,2,3))
</code></pre>

<hr>
<h2 id='Normalize'>Normalize a matrix row-wise</h2><span id='topic+Normalize'></span>

<h3>Description</h3>

<p>This function normalizes the rows of the input matrix x by dividing each row by its L2 norm (Euclidean norm).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Normalize(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Normalize_+3A_x">x</code></td>
<td>
<p>Numeric matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric matrix with normalized rows.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Normalize(matrix(c(1,2,3,4,5,6), nrow = 2, byrow = TRUE))
</code></pre>

<hr>
<h2 id='penalized_linear_spherical_spline'>Penalized Linear Spherical Spline</h2><span id='topic+penalized_linear_spherical_spline'></span>

<h3>Description</h3>

<p>This function fits a penalized piecewise geodesic curve (linear spherical spline) to the given data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>penalized_linear_spherical_spline(
  t,
  y,
  initial_control_points = NULL,
  dimension,
  initial_knots,
  lambdas,
  step_size = 1,
  maxiter = 1000,
  epsilon_iter = 0.001,
  jump_eps = 1e-04,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="penalized_linear_spherical_spline_+3A_t">t</code></td>
<td>
<p>A numeric vector representing the time or location.</p>
</td></tr>
<tr><td><code id="penalized_linear_spherical_spline_+3A_y">y</code></td>
<td>
<p>A matrix where each row represents a data point on the sphere.</p>
</td></tr>
<tr><td><code id="penalized_linear_spherical_spline_+3A_initial_control_points">initial_control_points</code></td>
<td>
<p>An optional matrix specifying initial control points. Default is NULL.</p>
</td></tr>
<tr><td><code id="penalized_linear_spherical_spline_+3A_dimension">dimension</code></td>
<td>
<p>An integer specifying the dimension of the spline.</p>
</td></tr>
<tr><td><code id="penalized_linear_spherical_spline_+3A_initial_knots">initial_knots</code></td>
<td>
<p>An optional numeric vector specifying initial knots. Default is NULL.</p>
</td></tr>
<tr><td><code id="penalized_linear_spherical_spline_+3A_lambdas">lambdas</code></td>
<td>
<p>A numeric vector specifying the penalization parameters.</p>
</td></tr>
<tr><td><code id="penalized_linear_spherical_spline_+3A_step_size">step_size</code></td>
<td>
<p>A numeric value specifying the step size for optimization. Default is 1.</p>
</td></tr>
<tr><td><code id="penalized_linear_spherical_spline_+3A_maxiter">maxiter</code></td>
<td>
<p>An integer specifying the maximum number of iterations. Default is 1000.</p>
</td></tr>
<tr><td><code id="penalized_linear_spherical_spline_+3A_epsilon_iter">epsilon_iter</code></td>
<td>
<p>A numeric value specifying the convergence criterion for iterations. Default is 1e-03.</p>
</td></tr>
<tr><td><code id="penalized_linear_spherical_spline_+3A_jump_eps">jump_eps</code></td>
<td>
<p>A numeric value specifying the threshold for pruning control points based on jump size. Default is 1e-04.</p>
</td></tr>
<tr><td><code id="penalized_linear_spherical_spline_+3A_verbose">verbose</code></td>
<td>
<p>A logical value indicating whether to print progress information. Default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The goal is to find the optimal piecewise geodesic curve for the given spherical data while controlling model complexity through penalty terms.
This function computes the optimal control points and knots for the given data and returns the fitted result.
Internally, coordinate-wise gradient descent is used to minimize the loss function, and a penalty term is added to control the complexity of the model.
The BIC (Bayesian Information Criterion) value is calculated according to the model's complexity to provide information for model selection.
The function constructs piecewise curves using the piecewise_geodesic function and employs penalty terms to control the complexity of the model by updating control points and knots.
To see how to use the function in practical applications, refer to the README or https://github.com/kybak90/spheresmooth.
</p>


<h3>Value</h3>

<p>A list containing the fitted result for each complexity parameter and BIC values for model selection. One might choose the element that corresponds to the minimum BIC values as illustrated in the example.
</p>

<hr>
<h2 id='piecewise_geodesic'>Piecewise Geodesic</h2><span id='topic+piecewise_geodesic'></span>

<h3>Description</h3>

<p>This function computes a piecewise geodesic path between control points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>piecewise_geodesic(t, control_points, knots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="piecewise_geodesic_+3A_t">t</code></td>
<td>
<p>A numeric vector representing the time or location.</p>
</td></tr>
<tr><td><code id="piecewise_geodesic_+3A_control_points">control_points</code></td>
<td>
<p>A matrix of control points where each row represents a control point.</p>
</td></tr>
<tr><td><code id="piecewise_geodesic_+3A_knots">knots</code></td>
<td>
<p>A numeric vector of knot values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the piecewise geodesic curve between control points based on the provided knots. The geodesic curve is computed segment by segment between adjacent control points. It interpolates the path between control points in a geodesic manner, ensuring the shortest path along the surface.
</p>


<h3>Value</h3>

<p>A matrix containing the piecewise geodesic path.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># `rgl` package and `sphereplot` pacakges are needed for the visualizaiton of the following example.
# Define control points and knots
library(rgl)
library(sphereplot)
control_points &lt;- matrix(c(1, 0, 0,                         # Control point 1
                          1/sqrt(2), 1/sqrt(2), 0,          # Control point 2
                          -1/sqrt(3), 1/sqrt(3), 1/sqrt(3), # Control point 3
                          0, 0, 1),                         # Control point 4
                          nrow = 4, byrow = TRUE)
knots &lt;- c(1, 2, 3, 3.5)  # Knots indicating transitions
# Example of generating piecewise geodesic curve
t_example &lt;- seq(0, 4, by = 0.01)
gamma_example &lt;- piecewise_geodesic(t_example, control_points, knots)
# Plotting the piecewise geodesic curve
rgl.sphgrid(deggap = 45, col.long = "skyblue", col.lat = "skyblue")
spheres3d(x = 0, y = 0, z = 0, radius = 1, col = "grey", alpha = 0.05)
pch3d(control_points, col = "blue", cex = 0.2, pch = 19)
lines3d(gamma_example, col = "red", lty = 1, lwd = 2)
</code></pre>

<hr>
<h2 id='spherical_dist'>Calculate spherical distance between two vectors</h2><span id='topic+spherical_dist'></span>

<h3>Description</h3>

<p>This function calculates the spherical distance between two vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spherical_dist(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spherical_dist_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="spherical_dist_+3A_y">y</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The distance between vectors x and y.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1, 0, 0)
y &lt;- c(0, 1, 0)
spherical_dist(x, y)
</code></pre>

<hr>
<h2 id='Spherical_to_Cartesian'>Convert spherical coordinates to Cartesian coordinates</h2><span id='topic+Spherical_to_Cartesian'></span>

<h3>Description</h3>

<p>This function converts spherical coordinates (theta, phi) to Cartesian coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Spherical_to_Cartesian(theta_phi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Spherical_to_Cartesian_+3A_theta_phi">theta_phi</code></td>
<td>
<p>A matrix where each row contains the spherical coordinates (theta, phi) of a point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix where each row contains the Cartesian coordinates (x, y, z) of a point.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>theta_phi &lt;- matrix(c(pi/4, pi/3, pi/6, pi/4), ncol = 2, byrow = TRUE)
Spherical_to_Cartesian(theta_phi)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
