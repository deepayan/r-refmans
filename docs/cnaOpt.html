<!DOCTYPE html><html><head><title>Help for package cnaOpt</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cnaOpt}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cnaOpt'><p>Find atomic solution formulas with optimal consistency and coverage</p></a></li>
<li><a href='#conCovOpt'>
<p>Find consistency and coverage optima for configurational data</p></a></li>
<li><a href='#conCovOpt_utils'>
<p>Build disjunctive normal forms realizing con-cov optima</p></a></li>
<li><a href='#ereduce'><p>Find all minimal disjunctive normal forms (DNF) of an input DNF</p></a></li>
<li><a href='#findOutcomes'>
<p>Identify the factors that can possibly be modeled as outcomes prior to running CNA</p></a></li>
<li><a href='#selectMax'>
<p>Select the con-cov optima from a '<code>conCovOpt</code>' object that maximize a specified optimality criterion</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Optimizing Consistency and Coverage in Configurational Causal
Modeling</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-07-06</td>
</tr>
<tr>
<td>Description:</td>
<td>This is an add-on to the 'cna' package <a href="https://CRAN.R-project.org/package=cna">https://CRAN.R-project.org/package=cna</a> comprising various functions for optimizing consistency and coverage scores of models of configurational comparative methods as Coincidence Analysis (CNA) and Qualitative Comparative Analysis (QCA). The function conCovOpt() calculates con-cov optima, selectMax() selects con-cov maxima among the con-cov optima, DNFbuild() can be used to build models actually reaching those optima, and findOutcomes() identifies those factor values in analyzed data that can be modeled as outcomes. For a theoretical introduction to these functions see Baumgartner and Ambuehl (2021) &lt;<a href="https://doi.org/10.1177%2F0049124121995554">doi:10.1177/0049124121995554</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), cna (&ge; 3.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.7), matrixStats, ggplot2, dplyr, stats, utils</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Author:</td>
<td>Mathias Ambuehl [aut, cre, cph],
  Michael Baumgartner [aut, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mathias Ambuehl &lt;mathias.ambuehl@consultag.ch&gt;</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-07-08 09:30:41 UTC; MAM</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-07-08 14:00:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='cnaOpt'>Find atomic solution formulas with optimal consistency and coverage
</h2><span id='topic+cnaOpt'></span>

<h3>Description</h3>

<p><code>cnaOpt</code> attempts to find atomic solution formulas (asfs) for a given <code>outcome</code> (inferred from crisp-set, <code>"cs"</code>, or multi-value, <code>"mv"</code>, data) that are optimal with respect to the model fit parameters consistency and coverage (cf. Baumgartner and Ambuehl 2021). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cnaOpt(x, outcome, ..., reduce = c("ereduce", "rreduce", "none"), 
       niter = 1, crit = quote(con * cov), cond = quote(TRUE), 
			 approx = FALSE, maxCombs = 1e7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cnaOpt_+3A_x">x</code></td>
<td>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> or <code>configTable</code> of type <code>"cs"</code> or <code>"mv"</code>.
</p>
</td></tr>
<tr><td><code id="cnaOpt_+3A_outcome">outcome</code></td>
<td>

<p>A character string specifying one outcome, i.e. one factor value in <code>x</code>.
</p>
</td></tr>
<tr><td><code id="cnaOpt_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code>configTable</code>, for instance <code>rm.dup.factors</code>, <code>rm.dup.factors</code>, or <code>case.cutoff</code>.
</p>
</td></tr>
<tr><td><code id="cnaOpt_+3A_reduce">reduce</code></td>
<td>

<p>A character string: if <code>"ereduce"</code> or <code>"rreduce"</code>, the canonical DNF realizing the con-cov optimum is freed of redundancies using <code><a href="#topic+ereduce">ereduce</a></code> or <code>rreduce</code> (possibly repeatedly, see <code>niter</code>), respectively; if <code>"none"</code>, the unreduced canonical DNF is returned. <code>reduce = TRUE</code> is interpreted as <code>"rreduce"</code>, <code>reduce = FALSE</code> and <code>reduce = NULL</code> as <code>"none"</code>.
</p>
</td></tr>
<tr><td><code id="cnaOpt_+3A_niter">niter</code></td>
<td>

<p>An integer value indicating the number of repetitive applications of <code>rreduce</code>. 
<code>niter</code> will be ignored (with a warning) if <code>reduce</code> is not equal to <code>"rreduce"</code>. 
Note that repeated applications may yield identical solutions and that duplicate solutions are eliminiated, so that the number of resulting solutions can be smaller than <code>niter</code>.
</p>
</td></tr>
<tr><td><code id="cnaOpt_+3A_crit">crit</code></td>
<td>

<p>Quoted expression specifying a numeric criterion to be maximized when selecting the best solutions among the ones that meet criterion <code>cond</code>, for example, <code>quote(min(con,cov))</code> or <code>quote(0.8*con + 0.2*cov)</code>, etc.</p>
</td></tr>
<tr><td><code id="cnaOpt_+3A_cond">cond</code></td>
<td>

<p>Quoted expression specifying a logical criterion to be imposed on the solutions inferred from <code>x</code> before selecting the best solutions on the basis of <code>crit</code>, for example, <code>quote(con &gt; 0.85)</code> or <code>quote(con &gt; cov)</code>, etc.
</p>
</td></tr>
<tr><td><code id="cnaOpt_+3A_approx">approx</code></td>
<td>

<p>As in <code><a href="#topic+conCovOpt">conCovOpt</a></code>.  
</p>
</td></tr>
<tr><td><code id="cnaOpt_+3A_maxcombs">maxCombs</code></td>
<td>

<p>Maximal number of combinations that will be tested for optimality. If the number of necessary iterations exceeds <code>maxCombs</code>, <code>cnaOpt</code> will stop executing and return an error message stating the necessary number of iterations. Early termination can then be avoided by increasing <code>maxCombs</code> accordingly. This argument is passed to <code><a href="#topic+conCovOpt">conCovOpt</a></code> and <code><a href="#topic+ereduce">ereduce</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>cnaOpt</code> implements a procedure introduced in Baumgartner and Ambuehl (2021). It infers causal models (atomic solution formulas, asf) for the <code>outcome</code> from data <code>x</code> that comply with the logical condition <code>cond</code> and maximize the numeric criterion <code>crit</code>. Data <code>x</code> may be crisp-set (<code>"cs"</code>) or multi-value (<code>"mv"</code>), but not fuzzy-set (<code>"fs"</code>). The function proceeds as follows:
</p>

<ol>
<li><p> it calculates consistency and coverage optima (con-cov optima) for <code>x</code>;
</p>
</li>
<li><p> it selects the optima that meet <code>cond</code>;
</p>
</li>
<li><p> among those optima, it selects those that maximize <code>crit</code>;
</p>
</li>
<li><p> it builds the canonical disjunctive normal forms (DNF) of the selected optima
</p>
</li>
<li><p> it generates all minimal forms of those canonical DNFs
</p>
</li></ol>


<p>Roughly speaking, running <code>cnaOpt</code> amounts to sequentially executing <code>configTable</code>, <code><a href="#topic+conCovOpt">conCovOpt</a></code>, <code><a href="#topic+selectMax">selectMax</a></code>, <code><a href="#topic+DNFbuild">DNFbuild</a></code> and <code>condTbl</code>.
</p>
<p>In the default setting, <code>cnaOpt</code> attempts to build all optimal solutions using <code><a href="#topic+ereduce">ereduce</a></code>. But that may be too computationally demanding because the space of optimal solutions can be very large. If the argument <code>reduce</code> is set to <code>"rreduce"</code>, <code>cnaOpt</code> builds one arbitrarily selected optimal solution, which typically terminates quickly. By giving the argument <code>niter</code> a non-default value, say, 20, the process of selecting one optimal solution under <code>reduce = "rreduce"</code> is repeated 20 times. As the same solutions will be generated on some iterations and duplicates are not returned, the output may contain less models than the value given to <code>niter</code>. If <code>reduce</code> is not set to <code>"rreduce"</code>, <code>niter</code> is ignored with a warning.
</p>


<h3>Value</h3>

<p><code>cnaOpt</code> returns a <code><a href="base.html#topic+data.frame">data.frame</a></code> with additional classes &quot;cnaOpt&quot; and &quot;condTbl&quot;. See the &quot;Value&quot; section in <code>?condTbl</code> for details.
</p>


<h3>References</h3>

<p>Baumgartner, Michael and Mathias Ambuehl. 2021. &ldquo;Optimizing Consistency and Coverage in Configurational Causal Modeling.&rdquo; <em>Sociological Methods &amp; Research</em>.<br /> doi:10.1177/0049124121995554. 
</p>


<h3>See Also</h3>

<p><code>cna</code>, <code><a href="#topic+conCovOpt">conCovOpt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1: Real-life crisp-set data, d.educate.
(res_opt1 &lt;- cnaOpt(d.educate, "E"))

# Using the pipe operator (%&gt;%), the steps processed by cnaOpt in the 
# call above can be reproduced as follows:
library(dplyr)
conCovOpt(d.educate, "E") %&gt;% selectMax %&gt;% DNFbuild(reduce = "ereduce") %&gt;% 
  paste("&lt;-&gt; E") %&gt;% condTbl(d.educate)

# Example 2: Simulated crisp-set data.
dat1 &lt;- data.frame(
  A = c(1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0), 
  B = c(0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0), 
  C = c(0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0), 
  D = c(1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1), 
  E = c(1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1), 
  F = c(0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1)
)

(res_opt2 &lt;- cnaOpt(dat1, "E"))

# Change the maximality criterion.
cnaOpt(dat1, "E", crit = quote(min(con, cov)))
# Change the selection condition.
cnaOpt(dat1, "E", cond = quote(con &gt;= 0.9))
# Build all con-cov optima with coverage above 0.9 that maximize min(con, cov).
cnaOpt(dat1, "E", crit = quote(min(con, cov)), cond = quote(cov &gt; 0.9))
# Different values of the reduce argument.
cnaOpt(dat1, "E", reduce = "none") # canonical DNF
cnaOpt(dat1, "E", reduce = "rreduce") # one randomly drawn optimal solution
# Iterate random solution generation 10 times.
cnaOpt(dat1, "E", reduce = "rreduce", niter = 10) 

# Example 3: All logically possible configurations.
(res_opt3 &lt;- cnaOpt(full.ct(4), "D"))  # All combinations are equally bad.

# Example 4: Real-life multi-value data, d.pban.
cnaOpt(d.pban, outcome = "PB=1")
cnaOpt(d.pban, outcome = "PB=1", crit = quote(0.8*con + 0.2*cov))
cnaOpt(d.pban, outcome = "PB=1", cond = quote(con &gt; 0.9))
cnaOpt(d.pban, outcome = "PB=0")
cnaOpt(d.pban, outcome = "PB=0", cond = quote(con &gt; 0.9))
cnaOpt(d.pban, outcome = "F=2")
cnaOpt(d.pban, outcome = "F=2", crit = quote(0.8*con + 0.2*cov))

# Example 5: High computational demand.
dat2 &lt;- configTable(d.performance[,1:8], frequency = d.performance$frequency)
try(cnaOpt(dat2, outcome = "SP"))   # error because too computationally demanding
# The following call does not terminate because of reduce = "ereduce".
try(cnaOpt(dat2, outcome = "SP", approx = TRUE))
# We could increase maxCombs, as in the line below
## Not run: cnaOpt(dat2, outcome = "SP", approx = TRUE, maxCombs = 1.08e+09) 
# but this takes very long to terminate.
# Alternative approach: Produce one (randomly selected) optimal solution using reduce = "rreduce".
cnaOpt(dat2, outcome = "SP",  approx = TRUE, reduce = "rreduce")
# Iterate the previous call 10 times.
cnaOpt(dat2, outcome = "SP", approx = TRUE, reduce = "rreduce", niter = 10)
# Another alternative: Use ereduce for minimization but introduce a case.cutoff.
cnaOpt(dat2, outcome = "SP", case.cutoff = 10)
</code></pre>

<hr>
<h2 id='conCovOpt'>
Find consistency and coverage optima for configurational data
</h2><span id='topic+conCovOpt'></span><span id='topic+print.conCovOpt'></span><span id='topic+plot.conCovOpt'></span>

<h3>Description</h3>

<p><code>conCovOpt</code> issues pairs of optimal consistency and coverage scores that atomic solution formulas (asf) of an outcome inferred from configurational data can possibly reach (cf. Baumgartner and Ambuehl 2021).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conCovOpt(x, outcome = NULL, ..., rm.dup.factors = FALSE, rm.const.factors = FALSE,
          maxCombs = 1e+07, approx = FALSE, allConCov)
## S3 method for class 'conCovOpt'
print(x, ...)
## S3 method for class 'conCovOpt'
plot(x, con = 1, cov = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conCovOpt_+3A_x">x</code></td>
<td>

<p>In <code>conCovOpt</code>: a <code><a href="base.html#topic+data.frame">data.frame</a></code> or <code>configTable</code>. In the <code>print</code>- and <code>plot</code>-method: an output of <code>conCovOpt</code>.
</p>
</td></tr>
<tr><td><code id="conCovOpt_+3A_outcome">outcome</code></td>
<td>

<p>A character vector of one or several factor values in <code>x</code>.
</p>
</td></tr>
<tr><td><code id="conCovOpt_+3A_...">...</code></td>
<td>

<p>In <code>conCovOpt</code>: arguments passed to <code>configTable</code>, e.g. <code>case.cutoff</code>. 
The &lsquo;<code>...</code>&rsquo; are currently not used in <code>plot.conCovOpt</code>.
</p>
</td></tr>
<tr><td><code id="conCovOpt_+3A_rm.dup.factors">rm.dup.factors</code></td>
<td>
<p>Logical; defaults to <code>FALSE</code> (which is different from <code>configTable</code>). If <code>TRUE</code>, all but the first of a set of factors with identical values in <code>x</code> are removed.</p>
</td></tr>
<tr><td><code id="conCovOpt_+3A_rm.const.factors">rm.const.factors</code></td>
<td>
<p>Logical;  defaults to <code>FALSE</code> (which is different from <code>configTable</code>). If <code>TRUE</code>, factors with constant values in <code>x</code> are removed.</p>
</td></tr>
<tr><td><code id="conCovOpt_+3A_maxcombs">maxCombs</code></td>
<td>

<p>Maximal number of combinations that will be tested for optimality. If the number of necessary iterations exceeds <code>maxCombs</code>, <code>conCovOpt</code> will stop executing and return an error message stating the necessary number of iterations. Early termination can then be avoided by increasing <code>maxCombs</code> accordingly.
</p>
</td></tr>
<tr><td><code id="conCovOpt_+3A_approx">approx</code></td>
<td>

<p>Logical; if TRUE, an exhaustive search is only approximated; if FALSE, an exhaustive search is conducted. 
</p>
</td></tr>
<tr><td><code id="conCovOpt_+3A_allconcov">allConCov</code></td>
<td>

<p>Defunct argument (as of package version 0.5.0). See the remark in <code>?<a href="#topic+multipleMax">multipleMax</a></code>.
</p>
</td></tr>
<tr><td><code id="conCovOpt_+3A_con">con</code>, <code id="conCovOpt_+3A_cov">cov</code></td>
<td>
<p>Numeric scalars between 0 and 1 indicating consistency and coverage thresholds marking the area of &quot;good&quot; models in a square drawn in the plot. Points within the square correspond to models reaching these thresholds.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>conCovOpt</code> implements a procedure introduced in Baumgartner and Ambuehl (2021). It  calculates consistency and coverage optima for models (i.e. atomic solution formulas, asf) of an <code>outcome</code> inferred from data <code>x</code> prior to actual CNA or QCA analyses.
</p>
<p>An ordered pair (con, cov) of consistency and coverage scores is a <strong>con-cov optimum</strong> for outcome Y=k in data <code>x</code> iff it is not excluded (based e.g. on the data structure) for an asf of Y=k inferred from <code>x</code> to reach (con, cov) but excluded to score better on one element of the pair and at least as well on the other.
</p>
<p><code>conCovOpt</code> calculates con-cov optima by executing the following steps:</p>
<ol>
<li><p> if <code>x</code> is a data frame, aggregate <code>x</code> in a <code>configTable</code>, </p>
</li>
<li><p> build exo-groups with constant values in all factors other than the <code>outcome</code>, </p>
</li>
<li><p> assign output values to each exo-group that reproduce the behavior of <code>outcome</code> as closely as possible, </p>
</li>
<li><p>  calculate con-cov scores for each assignment resulting in step 3, </p>
</li>
<li><p> eliminate all non-optimal scores.</p>
</li></ol>

<p>The implementation of step 4 calculates con-cov scores of about 10 million output value assignments in reasonable time, but step 3 may result in considerably more assignments. In such cases, the argument <code>approx</code> may be set to its non-default value <code>"TRUE"</code>, which determines that step 4 is only executed for those assignments closest to the <code>outcome</code>'s median value. This is an efficient approach for finding many, but possibly not all, con-cov optima.
</p>
<p>In case of crisp-set and multi-value data, at least one actual model (asf) inferrable from <code>x</code> and reaching an optimum's consistency and coverage scores is guaranteed to exist for every con-cov optimum. The function <code><a href="#topic+DNFbuild">DNFbuild</a></code> can be used to build these optimal models. The same does not hold for fuzzy-set data. In fuzzy-set data it merely holds that the existence of a model reaching an optimum's consistency and coverage scores cannot be excluded prior to an actual application of <code>cna</code>. 
</p>


<h3>Value</h3>

<p>An object of class 'conCovOpt'. The exo-groups resulting from step 2 are stored as attribute <code>"exoGroups"</code>, the lists of output values resulting from step 3 are stored as attribute <code>"reprodList"</code> (reproduction list).
</p>


<h3>References</h3>

<p>Baumgartner, Michael and Mathias Ambuehl. 2021. &ldquo;Optimizing Consistency and Coverage in Configurational Causal Modeling.&rdquo; <em>Sociological Methods &amp; Research</em>.<br /> doi:10.1177/0049124121995554. 
</p>


<h3>See Also</h3>

<p><code>configTable</code>, <code><a href="#topic+selectMax">selectMax</a></code>, <code><a href="#topic+DNFbuild">DNFbuild</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(cco.irrigate &lt;- conCovOpt(d.irrigate))
conCovOpt(d.irrigate, outcome = c("R","W"))
# Plot method.
plot(cco.irrigate)
plot(cco.irrigate, con = .8, cov = .8)

dat1 &lt;- d.autonomy[15:30, c("EM","SP","CO","AU")]
(cco1 &lt;- conCovOpt(dat1, outcome = "AU"))

print(cco1, digits = 3, row.names = TRUE)
plot(cco1)

# Exo-groups (configurations with constant values in all factors other than the outcome).
attr(cco1$A, "exoGroups")

# Rep-list (list of values optimally reproducing the outcome).
attr(cco1$A, "reprodList")

dat2 &lt;- d.pacts
# Maximal number of combinations exceeds maxCombs.
(cco2 &lt;- conCovOpt(dat2, outcome = "PACT")) # Generates a warning
# Increase maxCombs.
(cco2_full &lt;- try(conCovOpt(dat2, outcome = "PACT", 
  maxCombs=1e+08))) # Takes a long time to terminate
# Approximate an exhaustive search.
(cco2_approx1 &lt;- conCovOpt(dat2, outcome = "PACT", approx = TRUE))
selectMax(cco2_approx1)
# The search space can also be reduced by means of a case cutoff.
(cco2_approx2 &lt;- conCovOpt(dat2, outcome = "PACT", case.cutoff=2))
selectMax(cco2_approx2)

</code></pre>

<hr>
<h2 id='conCovOpt_utils'>
Build disjunctive normal forms realizing con-cov optima
</h2><span id='topic+reprodAssign'></span><span id='topic+DNFbuild'></span>

<h3>Description</h3>

<p><code>reprodAssign</code> generates the output values of disjunctive normal forms (DNFs) reaching con-cov optima. <code>DNFbuild</code> builds a DNF realizing a targeted con-cov optimum; it only works for crisp-set and multi-value data (cf. Baumgartner and Ambuehl 2021).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reprodAssign(x, outcome = names(x), id = xi$id)
DNFbuild(x, outcome = names(x), reduce = c("ereduce", "rreduce", "none"), 
         id = xi$id, maxCombs = 1e7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conCovOpt_utils_+3A_x">x</code></td>
<td>

<p>An object produced by <code><a href="#topic+selectMax">selectMax</a></code>.  
</p>
</td></tr>
<tr><td><code id="conCovOpt_utils_+3A_outcome">outcome</code></td>
<td>

<p>A character string specifying <em>one</em> outcome value in <code>attr(x, "configTable")</code>.
</p>
</td></tr>
<tr><td><code id="conCovOpt_utils_+3A_id">id</code></td>
<td>

<p>An integer vector referring to the identifier of the targeted con-cov optimum or optima.
</p>
</td></tr>
<tr><td><code id="conCovOpt_utils_+3A_reduce">reduce</code></td>
<td>

<p>A character string: if <code>"ereduce"</code> or <code>"rreduce"</code>, the canonical DNF realizing the con-cov optimum is freed of redundancies using <code><a href="#topic+ereduce">ereduce</a></code> or <code>rreduce</code>, respectively; if <code>"none"</code>, the unreduced canonical DNF is returned. <code>reduce=TRUE</code> is interpreted as <code>"rreduce"</code>, <code>reduce=FALSE</code> and <code>reduce=NULL</code> as <code>"none"</code>.
</p>
</td></tr>
<tr><td><code id="conCovOpt_utils_+3A_maxcombs">maxCombs</code></td>
<td>

<p>Passed to <code><a href="#topic+ereduce">ereduce</a></code> if <code>reduce = "ereduce"</code>; ignored otherwise. (See <code><a href="#topic+ereduce">ereduce</a></code> for details.)  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An atomic CNA model (asf) accounts for the behavior of the <code>outcome</code> in terms of a redundancy-free DNF. <code>reprodAssign</code> generates the output values such a DNF has to return in order to reach a con-cov optimum stored in an object of class '<code>selectMax</code>'. If the data stored in <code>attr(x, "configTable")</code> are crisp-set or multi-value, <code>DNFbuild</code> builds the DNFs realizing the targeted con-cov optimum. (For fuzzy-set data an error is returned.) If <code>reduce = "ereduce"</code> (default), <em>all</em> redundancy-free DNFs are built using <code><a href="#topic+ereduce">ereduce</a></code>; if <code>reduce = "rreduce"</code> (more computationally efficient), <em>one</em> (randomly selected) redundancy-free DNF is built using <code>rreduce</code>; if <code>reduce = "none"</code>, the non-reduced canonical DNF is returned.
The argument <code>id</code> allows for selecting a targeted con-cov optimum via its identifier (see examples below).
</p>


<h3>Value</h3>

<p><code>reprodAssign</code>: A matrix of scores.
<code>DNFbuild</code>: A Boolean formula in disjunctive normal form (DNF).
</p>


<h3>References</h3>

<p>Baumgartner, Michael and Mathias Ambuehl. 2021. &ldquo;Optimizing Consistency and Coverage in Configurational Causal Modeling.&rdquo; <em>Sociological Methods &amp; Research</em>.<br /> doi:10.1177/0049124121995554. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+conCovOpt">conCovOpt</a></code>, <code><a href="#topic+selectMax">selectMax</a></code>, <code>condTbl</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># CS data, d.educate
cco1 &lt;- conCovOpt(d.educate)
best1 &lt;- selectMax(cco1)
reprodAssign(best1, outcome =  "E")
DNFbuild(best1, outcome =  "E")
DNFbuild(best1, outcome =  "E", reduce = FALSE) # canonical DNF
DNFbuild(best1, outcome =  "E", reduce = "ereduce") # all redundancy-free DNFs
DNFbuild(best1, outcome =  "E", reduce = "rreduce") # one redundancy-free DNF
DNFbuild(best1, outcome =  "E", reduce = "none") # canonical DNF

# Simulated mv data
datMV &lt;- data.frame(
  A = c(3,2,1,1,2,3,2,2,2,1,1,2,3,2,2,2,1,2,3,3,3,1,1,1,3,1,2,1,2,3,3,2,2,2,1,2,2,3,2,1,2,1,3,3),
  B = c(1,2,3,2,1,1,2,1,2,2,3,1,1,1,2,3,1,3,3,3,1,1,3,2,2,1,1,3,3,2,3,1,2,1,2,2,1,1,2,2,3,3,3,3),
  C = c(1,3,3,3,1,1,1,2,2,3,3,1,1,2,2,2,3,1,1,2,1,2,2,3,3,1,2,2,2,3,2,1,1,2,2,2,1,1,1,2,2,1,1,2),
  D = c(3,1,2,2,1,1,1,1,1,1,1,2,2,2,2,2,2,3,3,3,1,1,1,1,1,2,2,2,2,2,3,1,1,1,1,1,2,2,2,2,2,3,3,3),
  E = c(3,2,2,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3)
)

# Apply conCovOpt and selectMax.
(cco2 &lt;- conCovOpt(datMV))
(best2 &lt;- selectMax(cco2))

# Apply DNFbuild to build the redundancy-free DNFs reaching best2.
(formula1 &lt;- DNFbuild(best2, outcome = "D=3"))
# Both DNFs in formula1 reache the con-cov score stored in best2 for outcome "D=3".
condTbl(paste0(formula1, "&lt;-&gt; D=3"), datMV)
# Build only one redundancy-free DNF reaching best2.
DNFbuild(best2, outcome = "D=3", reduce = "rreduce")
# Any factor value in datMV can be treated as outcome.
(formula2 &lt;- DNFbuild(best2, outcome =  "E=3", reduce = "rreduce"))
condTbl(paste0(formula2, "&lt;-&gt; E=3"), datMV)
# Any con-cov optimum in cco2 can be targeted via its identifier.
(formula3 &lt;- DNFbuild(best2, outcome =  "E=3", id = 508))
condTbl(paste0(formula3, "&lt;-&gt; E=3"), datMV)

# Simulated fs data
datFS &lt;- data.frame(
  A = c(.73, .85, .94, .36, .73, .79, .39, .82, .15, .12, .67, .27, .3), 
  B = c(.21, .03, .91, .64, .39, .12, .06, .7,  .73, .15, .88, .73, .36), 
  C = c(.61,  0,  .61,  1,  .94, .15, .88, .27, .12, .12, .27, .15, .15), 
  D = c(.64, .67, .3,  .06, .33, .03, .76, .94, .67, .76, .18, .27, .36), 
  E = c(.91, .94, .67, .85, .73, .79, .24, .09, .03, .21, .33, .36, .27)
)

# Apply conCovOpt and selectMax.
(cco3 &lt;- conCovOpt(datFS, outcome = "E"))
(best3 &lt;- selectMax(cco3))

# Apply reprodAssign.
reprodAssign(best3, outcome = "E")
# Select a con-cov optimum in cco3 via its identifier.
reprodAssign(best3, outcome = "E", id = 252)

# DNFbuild does not work for fs data; it generates an error.
try(DNFbuild(best3, outcome = "E"))
</code></pre>

<hr>
<h2 id='ereduce'>Find all minimal disjunctive normal forms (DNF) of an input DNF</h2><span id='topic+ereduce'></span>

<h3>Description</h3>

<p><code>ereduce</code> builds all minimal disjunctive normal forms corresponding to an input DNF. It is similar to <code><a href="cna.html#topic+rreduce">rreduce</a></code>, which, however, only builds one minimal DNF at random.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ereduce(cond, x = full.ct(cond), full = !missing(x), 
        simplify2constant = TRUE, maxCombs = 1e7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ereduce_+3A_cond">cond</code></td>
<td>

<p>A character string specifying a disjunctive normal form (DNF); can be either crisp-set or multi-value.
</p>
</td></tr>
<tr><td><code id="ereduce_+3A_x">x</code></td>
<td>
<p>A 
<code>configTable</code> or <code>data.frame</code>; can be either crisp-set or multi-value.
</p>
</td></tr>
<tr><td><code id="ereduce_+3A_full">full</code></td>
<td>

<p>Logical; if <code>TRUE</code>, redundancies are eliminated relative to <code>full.ct(x)</code>, otherwise relative to <code>x</code>.
</p>
</td></tr>
<tr><td><code id="ereduce_+3A_simplify2constant">simplify2constant</code></td>
<td>

<p>Logical; if <code>TRUE</code> (the default), a tautologous or contradictory <code>cond</code> is reduced to a constant <code>"1"</code> or <code>"0"</code>, respectively. If <code>FALSE</code>, a minimal tautology or contradiction, i.e. <code>"A+a"</code> or <code>"A*a"</code>, will result.
</p>
</td></tr>
<tr><td><code id="ereduce_+3A_maxcombs">maxCombs</code></td>
<td>

<p>Maximal number of iterations that will be ran in the most time-consuming step. If the number of necessary iterations exceeds <code>maxCombs</code>, <code>ereduce</code> will stop executing and return an error message stating the necessary number of iterations. Early termination can then be avoided by increasing <code>maxCombs</code> accordingly.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ereduce</code> eliminates conjuncts and disjuncts from a DNF <code>cond</code> as long as the result of <code>condition(cond, x)</code> remains the same. The only required argument is <code>cond</code>. If <code>x</code> is not provided, redundancies are eliminated relative to <code>full.ct(cond)</code>. 
</p>
<p><code>ereduce</code> generates all redundancy-free forms of <code>cond</code>, while <code><a href="cna.html#topic+rreduce">rreduce</a></code> only returns one randomly chosen one. <code>rreduce</code> is faster than <code>ereduce</code>, but often incomplete. In a nutshell,  <code>ereduce</code> searches for minimal hitting sets in <code>cond</code> preventing <code>cond</code> from being false in data <code>x</code>.
</p>


<h3>Value</h3>

<p>A vector of redundancy-free disjunctive normal forms (DNF).
</p>


<h3>See Also</h3>

<p><code><a href="cna.html#topic+rreduce">rreduce</a></code>, <code>full.ct</code>, <code><a href="#topic+conCovOpt">conCovOpt</a></code>, <code><a href="#topic+DNFbuild">DNFbuild</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Logical redundancies.
cond1 &lt;- "A*b + a*B + A*C + B*C"
ereduce(cond1)
rreduce(cond1) # repeated calls generate different outputs
cond2 &lt;- "A*b + a*B + A*B + a*b"
ereduce(cond2)
ereduce(cond2, simplify2constant = FALSE)

# Redundancy elimination relative to simulated cs data.
dat1 &lt;- data.frame(
  A = c(0, 0, 0, 0, 1, 1, 0, 1), 
  B = c(0, 1, 0, 1, 1, 0, 0, 0), 
  C = c(1, 1, 0, 1, 1, 0, 1, 1), 
  D = c(0, 0, 0, 0, 0, 1, 1, 1))
cco1 &lt;- conCovOpt(dat1, "D")
best1 &lt;- selectMax(cco1)
(formula1 &lt;- DNFbuild(best1, outcome = "D", reduce = FALSE))
# ereduce
ereduce(formula1, dat1, full = FALSE)
# rreduce
rreduce(formula1, dat1, full = FALSE)

# Redundancy elimination relative to simulated mv data.
dat2 &lt;- data.frame(
  A = c(3,2,1,1,2,3,2,2,2,1,1,2,3,2,2,2,1,2,3,3,3,1,1,1,3,1,2,1,2,3,3,2,2,2,1,2,2,3,2,1,2,1,3,3),
  B = c(1,2,3,2,1,1,2,1,2,2,3,1,1,1,2,3,1,3,3,3,1,1,3,2,2,1,1,3,3,2,3,1,2,1,2,2,1,1,2,2,3,3,3,3),
  C = c(1,3,3,3,1,1,1,2,2,3,3,1,1,2,2,2,3,1,1,2,1,2,2,3,3,1,2,2,2,3,2,1,1,2,2,2,1,1,1,2,2,1,1,2),
  D = c(3,1,2,2,1,1,1,1,1,1,1,2,2,2,2,2,2,3,3,3,1,1,1,1,1,2,2,2,2,2,3,1,1,1,1,1,2,2,2,2,2,3,3,3),
  E = c(3,2,2,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3)
)
cco2 &lt;- conCovOpt(dat2, "D=3")
best2 &lt;- selectMax(cco2)
(formula2 &lt;- DNFbuild(best2, outcome = "D=3", reduce = FALSE))
# ereduce
ereduce(formula2, dat2, full = FALSE)
# rreduce
rreduce(formula2, dat2, full = FALSE)

# Any Boolean expressions.
cond &lt;- "!(A*B*C)*!(a*b*c)" # or "A + B*!(D + e) &lt;-&gt; C" 
x &lt;- selectCases(cond) 
(cond &lt;- cna:::getCond(x)) # returns a DNF equivalent to cond, but with many redundancies
ereduce(cond)
rreduce(cond)
</code></pre>

<hr>
<h2 id='findOutcomes'>
Identify the factors that can possibly be modeled as outcomes prior to running CNA
</h2><span id='topic+findOutcomes'></span>

<h3>Description</h3>

<p>Prior to running CNA (or any other configurational comparative method), <code>findOutcomes</code> identifies those factors in data <code>x</code> that can be modeled as outcomes relative to specified consistency and coverage thresholds <code>con</code> and <code>cov</code>. 

</p>


<h3>Usage</h3>

<pre><code class='language-R'>findOutcomes(x, con = 1, cov = 1, 
             rm.dup.factors = FALSE, rm.const.factors = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findOutcomes_+3A_x">x</code></td>
<td>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> or <code>configTable</code>.
</p>
</td></tr>
<tr><td><code id="findOutcomes_+3A_con">con</code>, <code id="findOutcomes_+3A_cov">cov</code></td>
<td>

<p>Numeric scalars between 0 and 1 specifying consistency and coverage thresholds.
</p>
</td></tr>
<tr><td><code id="findOutcomes_+3A_rm.dup.factors">rm.dup.factors</code></td>
<td>
<p>Logical; defaults to <code>FALSE</code>. If <code>TRUE</code>, all but the first of a set of factors with identical values in <code>x</code> are removed.</p>
</td></tr>
<tr><td><code id="findOutcomes_+3A_rm.const.factors">rm.const.factors</code></td>
<td>
<p>Logical;  defaults to <code>FALSE</code>. If <code>TRUE</code>, factors with constant values in <code>x</code> are removed.</p>
</td></tr>
<tr><td><code id="findOutcomes_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code><a href="#topic+conCovOpt">conCovOpt</a></code> and <code>configTable</code>, for instance <code>approx</code> or <code>case.cutoff</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>findOutcomes</code> first runs <code><a href="#topic+conCovOpt">conCovOpt</a></code> to find the con-cov optima for all factors in <code>x</code> and then applies <code><a href="#topic+selectMax">selectMax</a></code> to select those factors with con-cov optima meeting the consistency and coverage thresholds specified in <code>con</code> and <code>cov</code>.
</p>
<p>In case of crisp-set and multi-value data, an actual model (asf) meeting the specified <code>con</code> and <code>cov</code> thresholds is guaranteed to exist for every factor value with an entry <code>TRUE</code> in the <code>outcome</code> column. The function <code><a href="#topic+DNFbuild">DNFbuild</a></code> can be used to build these models. The same does not hold for fuzzy-set data. In case of fuzzy-set data, an entry <code>TRUE</code> in the <code>outcome</code> column simply means that the existence of a model reaching the specified <code>con</code> and <code>cov</code> thresholds cannot be excluded prior to an actual application of <code>cna</code>. 
</p>


<h3>Value</h3>

<p>A data.frame.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+conCovOpt">conCovOpt</a></code>, <code><a href="#topic+selectMax">selectMax</a></code>, <code>selectCases</code>, <code><a href="#topic+DNFbuild">DNFbuild</a></code>, <code>full.ct</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Crisp-set data.
findOutcomes(d.educate)
findOutcomes(d.educate, con = 0.75, cov = 0.75)
x &lt;- configTable(d.performance[,1:8], frequency = d.performance$frequency)
findOutcomes(x, con = .7, cov = .7) # too computationally demanding
# Approximate by passing approx = TRUE to conCovOpt().
findOutcomes(x, con = .7, cov = .7, approx = TRUE) 
# Approximate by passing a case cutoff to configTable().
findOutcomes(x, con = .7, cov = .7, case.cutoff = 10)

# A causal chain.
target1 &lt;- "(A + B &lt;-&gt; C)*(C + D &lt;-&gt; E)"
dat1 &lt;- selectCases(target1)
findOutcomes(dat1)

# A causal cycle.
target2 &lt;- "(A + Y1 &lt;-&gt; B)*(B + Y2 &lt;-&gt; A)*(A + Y3 &lt;-&gt; C)" 
dat2 &lt;- selectCases(target2, full.ct(target2))
findOutcomes(dat2)

# Multi-value data.
findOutcomes(d.pban) # no possible outcomes at con = cov = 1 
findOutcomes(d.pban, con = 0.8) 
findOutcomes(d.pban, con = 0.8, cov= 0.8) 

# Fuzzy-set data.
findOutcomes(d.jobsecurity) # no possible outcomes at con = cov = 1 
findOutcomes(d.jobsecurity, con = 0.86) 
</code></pre>

<hr>
<h2 id='selectMax'>
Select the con-cov optima from a '<code>conCovOpt</code>' object that maximize a specified optimality criterion
</h2><span id='topic+selectMax'></span><span id='topic+multipleMax'></span>

<h3>Description</h3>

<p><code>selectMax</code> selects the optima from a '<code>conCovOpt</code>' object that maximize a specified optimality criterion (cf. Baumgartner and Ambuehl 2021). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectMax(x, crit = quote(con * cov), cond = quote(TRUE), warn = TRUE)
multipleMax(x, outcome)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectMax_+3A_x">x</code></td>
<td>

<p>An object output by <code><a href="#topic+conCovOpt">conCovOpt</a></code>.
</p>
</td></tr>
<tr><td><code id="selectMax_+3A_crit">crit</code></td>
<td>

<p>Quoted expression specifying a numeric criterion to be maximized when selecting from the con-cov optima that meet criterion <code>cond</code>, for example, <code>min(con,cov)</code> or <code>0.8*con + 0.2*cov</code>, etc.</p>
</td></tr>
<tr><td><code id="selectMax_+3A_cond">cond</code></td>
<td>
 
<p>Quoted expression specifying a logical criterion to be imposed on the con-cov optima in <code>x</code> before selecting the optima maximizing <code>crit</code>, for example, <code>con &gt; 0.85</code> or <code>con &gt; cov</code>, etc.
</p>
</td></tr>
<tr><td><code id="selectMax_+3A_warn">warn</code></td>
<td>

<p>Logical; if <code>TRUE</code>, <code>selectMax()</code> returns a warning if no solution is found.
</p>
</td></tr>
<tr><td><code id="selectMax_+3A_outcome">outcome</code></td>
<td>

<p>A character string specifying a single outcome value in the original data.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>While <code><a href="#topic+conCovOpt">conCovOpt</a></code> identifies <em>all</em> con-cov optima in an analyzed data set, <code>selectMax</code> selects those optima from a '<code>conCovOpt</code>'  object <code>x</code> that comply with a logical condition <code>cond</code> and fare best according to the numeric optimality criterion <code>crit</code>. The default is to select so-called <em>con-cov maxima</em>, meaning con-cov optima with highest product of consistency and coverage. 
But the argument <code>crit</code> allows for specifying any other numeric optimality criterion, e.g. <code>min(con, cov)</code>, <code>max(con, cov)</code>, or <code>0.8*con + 0.2*cov</code>, etc. (see Baumgartner and Ambuehl 2021). If <code>x</code> contains multiple outcomes, the selection of the best con-cov optima is done separately for each outcome.
</p>
<p>As of package version 0.5.0, the function <code>multipleMax</code> is obsolete. It is kept for backwards compatibility only. 
</p>
<p>Via the column <code>id</code> in the output of <code>selectMax</code> it is possible to select one among many equally good maxima, for instance, by means of <code><a href="#topic+reprodAssign">reprodAssign</a></code> (see the examples below).
</p>


<h3>Value</h3>

<p><code>selectMax</code> returns an object of class 'selectMax'. 
</p>


<h3>References</h3>

<p>Baumgartner, Michael and Mathias Ambuehl. 2021. &ldquo;Optimizing Consistency and Coverage in Configurational Causal Modeling.&rdquo; <em>Sociological Methods &amp; Research</em>.<br /> doi:10.1177/0049124121995554. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+conCovOpt">conCovOpt</a></code>, <code><a href="#topic+reprodAssign">reprodAssign</a></code>
</p>
<p>See also examples in <code><a href="#topic+conCovOpt">conCovOpt</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat1 &lt;- d.autonomy[15:30, c("EM","SP","CO","AU")]
(cco1 &lt;- conCovOpt(dat1, outcome = "AU"))
selectMax(cco1)
selectMax(cco1, cond = quote(con &gt; 0.95))
selectMax(cco1, cond = quote(cov &gt; 0.98))
selectMax(cco1, crit = quote(min(con, cov)))
selectMax(cco1, crit = quote(max(con, cov)), cond = quote(cov &gt; 0.9))

# Multiple equally good maxima.
(cco2 &lt;- conCovOpt(dat1, outcome = "AU")) 
(sm2 &lt;- selectMax(cco2, cond = quote(con &gt; 0.93)))
# Each maximum corresponds to a different rep-assignment, which can be selected
# using the id argument.
reprodAssign(sm2, "AU", id = 10)
reprodAssign(sm2, "AU", id = 11)
reprodAssign(sm2, "AU", id = 13)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
