<!DOCTYPE html><html><head><title>Help for package rdiversity</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rdiversity}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.binary'><p>as binary digit.</p></a></li>
<li><a href='#binAdd'><p>Binary Addition (+)</p></a></li>
<li><a href='#binary'><p>Binary digit.</p></a></li>
<li><a href='#binSeq'><p>Binary sequence</p></a></li>
<li><a href='#byte'><p>A simple helper function to return the size of one byte</p></a></li>
<li><a href='#bytesNeeded'><p>Minimum number of &quot;byte&quot; needed to hold n &quot;bit&quot;</p></a></li>
<li><a href='#chainsaw'><p>Function to cut the phylogeny to a specified depth from the tip with the</p>
greatest distance from the root.</a></li>
<li><a href='#dist2sim'><p>Distance to similarity</p></a></li>
<li><a href='#distance'><p>Generate distance object</p></a></li>
<li><a href='#distance-class'><p>distance-class</p></a></li>
<li><a href='#fillUpToBit'><p>Fill up to bit (000..)</p></a></li>
<li><a href='#fillUpToByte'><p>Fill up to Byte (00000000..)</p></a></li>
<li><a href='#gen2dist'><p>Genetic distance matrix</p></a></li>
<li><a href='#inddiv'><p>Calculate individual-level diversity</p></a></li>
<li><a href='#is.binary'><p>is Binary Vector</p></a></li>
<li><a href='#loadAttributes'><p>loadAttributes</p></a></li>
<li><a href='#meta_gamma'><p>Metacommunity gamma diversity</p></a></li>
<li><a href='#metacommunity'><p>Metacommunity</p></a></li>
<li><a href='#metacommunity-class'><p>metacommunity-class</p></a></li>
<li><a href='#metadiv'><p>Metacommunity-level diversity</p></a></li>
<li><a href='#negate'><p>Binary Negation (!)</p></a></li>
<li><a href='#norm_alpha'><p>Normalised alpha (low level diversity component)</p></a></li>
<li><a href='#norm_beta'><p>Normalised beta (low level diversity component)</p></a></li>
<li><a href='#norm_meta_alpha'><p>Normalised metacommunity alpha diversity</p></a></li>
<li><a href='#norm_meta_beta'><p>Normalised metacommunity beta diversity</p></a></li>
<li><a href='#norm_meta_rho'><p>Normalised metacommunity rho diversity</p></a></li>
<li><a href='#norm_rho'><p>Normalised rho (low level diversity component)</p></a></li>
<li><a href='#norm_sub_alpha'><p>Normalised subcommunity alpha diversity</p></a></li>
<li><a href='#norm_sub_beta'><p>Normalised subcommunity beta diversity</p></a></li>
<li><a href='#norm_sub_rho'><p>Normalised subcommunity rho diversity</p></a></li>
<li><a href='#Ops.binary'><p>Group Generic Ops</p></a></li>
<li><a href='#phy_abundance'><p>Relative abundance of historical species</p></a></li>
<li><a href='#phy_struct'><p>Calculate phylogenetic structure matrix</p></a></li>
<li><a href='#phy2branch'><p>Phylogenetic similarity</p></a></li>
<li><a href='#phy2dist'><p>Phylogenetic pairwise tip distance matrix</p></a></li>
<li><a href='#power_mean'><p>Power mean of vector elements</p></a></li>
<li><a href='#powermean-class'><p>powermean-class</p></a></li>
<li><a href='#print.binary'><p>Print method for binary number.</p></a></li>
<li><a href='#raw_alpha'><p>Raw alpha (low level diversity component)</p></a></li>
<li><a href='#raw_beta'><p>Raw beta (low level diversity component)</p></a></li>
<li><a href='#raw_gamma'><p>Gamma (low level diversity component)</p></a></li>
<li><a href='#raw_meta_alpha'><p>Raw metacommunity alpha diversity</p></a></li>
<li><a href='#raw_meta_beta'><p>Raw metacommunity beta diversity</p></a></li>
<li><a href='#raw_meta_rho'><p>Raw metacommunity rho diversity</p></a></li>
<li><a href='#raw_rho'><p>Raw rho (low level diversity component)</p></a></li>
<li><a href='#raw_sub_alpha'><p>Raw subcommunity alpha diversity</p></a></li>
<li><a href='#raw_sub_beta'><p>Raw subcommunity beta diversity</p></a></li>
<li><a href='#raw_sub_rho'><p>Raw subcommunity rho diversity</p></a></li>
<li><a href='#rdiversity-package'><p>rdiversity: diversity measurement in R</p></a></li>
<li><a href='#relativeentropy-class'><p>relativeentropy-class</p></a></li>
<li><a href='#repartition'><p>Repartition metacommunity</p></a></li>
<li><a href='#saveAttributes'><p>saveAttributes</p></a></li>
<li><a href='#similarity'><p>Generate similarity object</p></a></li>
<li><a href='#similarity-class'><p>similarity-class</p></a></li>
<li><a href='#sub_gamma'><p>Subcommunity gamma diversity</p></a></li>
<li><a href='#subdiv'><p>Calculate subcommunity-level diversity</p></a></li>
<li><a href='#summary.binary'><p>Summary method for binary number.</p></a></li>
<li><a href='#switchEndianess'><p>Switch Endianess.</p></a></li>
<li><a href='#tax2dist'><p>Generate taxonomic distance matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Measurement and Partitioning of Similarity-Sensitive
Biodiversity</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-04-29</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Richard Reeve &lt;richard.reeve@glasgow.ac.uk&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/boydorr/rdiversity">https://github.com/boydorr/rdiversity</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/boydorr/rdiversity/issues">https://github.com/boydorr/rdiversity/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a framework for the measurement and partitioning of
    the (similarity-sensitive) biodiversity of a metacommunity and its
    constituent subcommunities. Richard Reeve, et al. (2016) 
    &lt;<a href="https://arxiv.org/abs/1404.6520v3">arXiv:1404.6520v3</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, reshape2, stats, stringdist, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ape, testthat, knitr, markdown, rmarkdown, covr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Collate:</td>
<td>'ancestral_nodes.R' 'binary.R' 'chainsaw.R'
'check_partition.R' 'check_phypartition.R' 'check_similarity.R'
'class-distance.R' 'class-metacommunity.R' 'class-powermean.R'
'class-relativeentropy.R' 'class-similarity.R'
'descendant_tips.R' 'similarity.R' 'dist2sim.R' 'distance.R'
'metadiv.R' 'subdiv.R' 'metacommunity.R'
'diversity-components.R' 'diversity-measures.R' 'gen2dist.r'
'geneid.R' 'genevec.R' 'hs_parameters.R' 'inddiv.R'
'phy2branch.R' 'phy2dist.R' 'phy_abundance.R' 'phy_struct.R'
'power_mean.R' 'powermean.R' 'rdiversity-package.R'
'relativeentropy.R' 'repartition.R' 'smatrix.R' 'summarise.R'
'tax2dist.R' 'taxfac.R' 'taxid.R' 'taxmask.R' 'taxvec.R'
'tbar.R' 'zmatrix.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-05 23:28:39 UTC; richardr</td>
</tr>
<tr>
<td>Author:</td>
<td>Sonia Mitchell <a href="https://orcid.org/0000-0003-1536-2066"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Richard Reeve <a href="https://orcid.org/0000-0003-2589-8091"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut, ths],
  Tom White <a href="https://orcid.org/0000-0002-9639-3800"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Daniel Dörrhöfer [ctb],
  Aaron Rudkin [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-06 07:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.binary'>as binary digit.</h2><span id='topic+as.binary'></span>

<h3>Description</h3>

<p>Converts an integer (Base10)
to a binary (Base2) number. It also converts a logical vector
to a binary (Base2) number (see examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.binary(x, signed=FALSE, littleEndian=FALSE, size=2, n=0, logic=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.binary_+3A_x">x</code></td>
<td>
<p>integer or logical vector.</p>
</td></tr>
<tr><td><code id="as.binary_+3A_signed">signed</code></td>
<td>
<p>TRUE or FALSE. Unsigned by default. (two's complement)</p>
</td></tr>
<tr><td><code id="as.binary_+3A_littleendian">littleEndian</code></td>
<td>
<p>if TRUE. Big Endian if FALSE.</p>
</td></tr>
<tr><td><code id="as.binary_+3A_size">size</code></td>
<td>
<p>in Byte. Needed if <b>signed</b> is set. (by default 2 Byte)</p>
</td></tr>
<tr><td><code id="as.binary_+3A_n">n</code></td>
<td>
<p>in Bit. Can be set if <b>unsigned</b> is set to TRUE. (by default 0 Bit = auto)</p>
</td></tr>
<tr><td><code id="as.binary_+3A_logic">logic</code></td>
<td>
<p>If set to TRUE, x is expected as logical vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The binary number is represented by a logical vector.
The bit order usually follows the same endianess as the byte order.
No floating-point support. If logic is set to TRUE an integer vector
is intepreted as a logical vector (&gt;0 becomes TRUE and 0 becomes FALSE)
</p>

<ul>
<li><p> Little Endian    (LSB) &mdash;&gt; (MSB)
</p>
</li>
<li><p> Big Endian       (MSB) &lt;&mdash; (LSB)
</p>
</li></ul>

<p>Auto switch to signed if num &lt; 0.
</p>


<h3>Value</h3>

<p>a vector of class binary.
</p>


<h3>See Also</h3>

<p><a href="#topic+is.binary">is.binary</a> and <a href="#topic+binary">binary</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as.binary(0xAF)
as.binary(42)
as.binary(42, littleEndian=TRUE)
as.binary(c(0xAF, 0xBF, 0xFF))
as.binary(c(2,4,8,16,32), signed=TRUE, size=1)
as.binary(-1, signed=TRUE, size=1)
as.binary(1:7, n=3)
as.binary(sample(2^8,3),n=8)
as.binary(c(1,1,0), signed=TRUE, logic=TRUE)
as.binary(c(TRUE,TRUE,FALSE), logic=TRUE)
</code></pre>

<hr>
<h2 id='binAdd'>Binary Addition (+)</h2><span id='topic+binAdd'></span>

<h3>Description</h3>

<p>Adds two binary numbers. (x + y)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binAdd(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binAdd_+3A_x">x</code></td>
<td>
<p>summand 1 (binary vector)</p>
</td></tr>
<tr><td><code id="binAdd_+3A_y">y</code></td>
<td>
<p>summand 2 (binary vector)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Little-Endian and unsigned is not supported at the moment. No floating point supported.
if x or y is signed the return value will also be signed.
</p>


<h3>Value</h3>

<p>The sum of x and y. Returns a binary vector.
</p>


<h3>See Also</h3>

<p>base::as.logical , base::is.logical, base::raw
</p>


<h3>Examples</h3>

<pre><code class='language-R'>five &lt;- as.binary(5); ten &lt;- as.binary(10);
as.numeric(rdiversity:::binAdd(ten, five))
rdiversity:::binAdd(as.binary(c(0,1), logic=TRUE), as.binary(c(1,0), logic=TRUE))
</code></pre>

<hr>
<h2 id='binary'>Binary digit.</h2><span id='topic+binary'></span>

<h3>Description</h3>

<p>Create objects of type binary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binary(n, signed=FALSE, littleEndian=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binary_+3A_n">n</code></td>
<td>
<p>length of vector. Number of bits</p>
</td></tr>
<tr><td><code id="binary_+3A_signed">signed</code></td>
<td>
<p>TRUE or FALSE. Unsigned by default. (two's complement)</p>
</td></tr>
<tr><td><code id="binary_+3A_littleendian">littleEndian</code></td>
<td>
<p>if TRUE. Big Endian if FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The binary number is represented by a <em>logical</em> vector.
The bit order usually follows the same endianess as the byte order.
How to read:
</p>

<ul>
<li><p> Little Endian    (LSB) &mdash;&gt; (MSB)
</p>
</li>
<li><p> Big Endian       (MSB) &lt;&mdash; (LSB)
</p>
</li></ul>

<p>The Big Endian endianess stores its MSB at the lowest adress.
The Little Endian endianess stores its MSB at the highest adress.
</p>
<p>e.g. b &lt;-binary(8).
</p>

<ul>
<li><p> &quot;Little Endian&quot; : MSB at b[1] and LSB at b[8].
</p>
</li>
<li><p> &quot;Big Endian&quot; : LSB at b[1] and MSB at b[8].
</p>
</li></ul>

<p>No floating-point support.
</p>


<h3>Value</h3>

<p>a vector of class binary of length n. By default filled with zeros(0).
</p>


<h3>See Also</h3>

<p><a href="#topic+as.binary">as.binary</a> and <a href="#topic+is.binary">is.binary</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b &lt;- rdiversity:::binary(8)
summary(b)
b &lt;- rdiversity:::binary(16, signed=TRUE)
summary(b)
b &lt;- rdiversity:::binary(32, littleEndian=TRUE)
summary(b)
</code></pre>

<hr>
<h2 id='binSeq'>Binary sequence</h2><span id='topic+binSeq'></span>

<h3>Description</h3>

<p>Binary sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binSeq(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binSeq_+3A_x">x</code></td>
<td>
<p>a sequence.</p>
</td></tr>
<tr><td><code id="binSeq_+3A_...">...</code></td>
<td>
<p>used for dec2bin().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a sequence list of binary digits.
</p>


<h3>See Also</h3>

<p><a href="#topic+binary">binary</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rdiversity:::binSeq(0:4)
</code></pre>

<hr>
<h2 id='byte'>A simple helper function to return the size of one byte</h2><span id='topic+byte'></span>

<h3>Description</h3>

<p>Used to increase readabilaty
</p>


<h3>Usage</h3>

<pre><code class='language-R'>byte()
</code></pre>


<h3>Value</h3>

<p>The size of one byte (8)
</p>


<h3>See Also</h3>

<p><a href="#topic+fillUpToByte">fillUpToByte</a>
</p>

<hr>
<h2 id='bytesNeeded'>Minimum number of &quot;byte&quot; needed to hold n &quot;bit&quot;</h2><span id='topic+bytesNeeded'></span>

<h3>Description</h3>

<p>A simple helper function
that returns the minimum number of byte needed to hold the amount of n bit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bytesNeeded(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bytesNeeded_+3A_n">n</code></td>
<td>
<p>The number of bit.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of minimum byte needed to hold n bit.
</p>


<h3>See Also</h3>

<p><a href="#topic+fillUpToByte">fillUpToByte</a> or <a href="#topic+byte">byte</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ten &lt;- as.binary(10)
rdiversity:::bytesNeeded(length(ten))
</code></pre>

<hr>
<h2 id='chainsaw'>Function to cut the phylogeny to a specified depth from the tip with the
greatest distance from the root.</h2><span id='topic+chainsaw'></span>

<h3>Description</h3>

<p>Function to cut the phylogeny to a specified depth from the tip with the
greatest distance from the root.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chainsaw(partition, ps, depth)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chainsaw_+3A_partition">partition</code></td>
<td>
<p>two-dimensional <code>matrix</code> of mode <code>numeric</code>
with rows as types (species), columns as subcommunities, and each
element containing the relative abundance of types in each subcommunity
relative to the metacommunity as a whole. In the phylogenetic case, this
corresponds to the proportional abundance of historical species, which is
calculated from the proportional abundance of terminal taxa</p>
</td></tr>
<tr><td><code id="chainsaw_+3A_ps">ps</code></td>
<td>
<p><code>phy_struct()</code> output</p>
</td></tr>
<tr><td><code id="chainsaw_+3A_depth">depth</code></td>
<td>
<p>proportion of total tree height to be conserved (taken as
a proportion from the highest tip). Describes how far back we go in the tree,
with 0 marking the date of the most recent tip, and 1 marking the most
recent common ancestor. Numbers greater than 1 extend the root of the tree</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>chainsaw()</code> returns an object of class <code>metacommunity</code>
</p>

<hr>
<h2 id='dist2sim'>Distance to similarity</h2><span id='topic+dist2sim'></span>

<h3>Description</h3>

<p>Converts <code>distance</code> objects into <code>similarity</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist2sim(dist, transform, k = 1, normalise = TRUE, max_d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist2sim_+3A_dist">dist</code></td>
<td>
<p>object of class <code>distance</code></p>
</td></tr>
<tr><td><code id="dist2sim_+3A_transform">transform</code></td>
<td>
<p>object of class <code>character</code>, can be either &quot;linear&quot;
or &quot;exponential&quot;</p>
</td></tr>
<tr><td><code id="dist2sim_+3A_k">k</code></td>
<td>
<p>scaling parameter</p>
</td></tr>
<tr><td><code id="dist2sim_+3A_normalise">normalise</code></td>
<td>
<p>object of class <code>logical</code>, which when TRUE will
normalise distances to one</p>
</td></tr>
<tr><td><code id="dist2sim_+3A_max_d">max_d</code></td>
<td>
<p>object of class <code>numeric</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Distances can be transformed either *linearly* or *exponentially*. That is
<code>1 - k * dist</code> for non-negative values, or <code>exp(-k * dist)</code>,
respectively. If <code>normalise</code> is true, then <code>dist = dist/max_d</code>.
</p>


<h3>Value</h3>

<p><code>dist2sim(x)</code> returns an object of class <code>similarity</code>.
</p>

<hr>
<h2 id='distance'>Generate distance object</h2><span id='topic+distance'></span><span id='topic+distance+2Cmatrix+2Ccharacter-method'></span><span id='topic+distance+2Cmatrix+2Cmissing-method'></span>

<h3>Description</h3>

<p>Container for class <code>distance</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance(distance, dat_id)

## S4 method for signature 'matrix,character'
distance(distance, dat_id)

## S4 method for signature 'matrix,missing'
distance(distance, dat_id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distance_+3A_distance">distance</code></td>
<td>
<p>distance matrix</p>
</td></tr>
<tr><td><code id="distance_+3A_dat_id">dat_id</code></td>
<td>
<p>object of class <code>character</code> denoting the type of diversity
being calculated. This can be &quot;naive&quot;, &quot;genetic&quot;, &quot;taxonomic&quot;, and so on</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>distance()</code> returns an object of class <code>distance</code>.
</p>

<hr>
<h2 id='distance-class'>distance-class</h2><span id='topic+distance-class'></span><span id='topic+show+2Cdistance-method'></span>

<h3>Description</h3>

<p>Container for class <code>distance</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'distance'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distance-class_+3A_object">object</code></td>
<td>
<p>object of class <code>distance</code></p>
</td></tr>
</table>


<h3>Fields</h3>


<dl>
<dt><code>distance</code></dt><dd><p>two-dimensional <code>matrix</code> of mode <code>numeric</code>
with rows as types, columns as types, and elements containing the pairwise
distance of types</p>
</dd>
<dt><code>dat_id</code></dt><dd><p>object of class <code>character</code> describing the class of
distance / similarity being used, e.g. &quot;naive&quot;, &quot;taxonomic&quot;, and so on</p>
</dd>
<dt><code>components</code></dt><dd><p>list containing the components necessary to calculate
similarity. This list is empty when <code>precompute_dist = TRUE</code> when
calculating distance. When a pairwise distance matrix is too large and
<code>precompute_dist = FALSE</code>, this list contains all the information
required to calculate pairwise distance between types</p>
</dd>
</dl>

<hr>
<h2 id='fillUpToBit'>Fill up to bit (000..)</h2><span id='topic+fillUpToBit'></span>

<h3>Description</h3>

<p>Fills up the binary number with zeros(0) or ones(1), to the size n in bit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fillUpToBit(x, n, value=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fillUpToBit_+3A_x">x</code></td>
<td>
<p>The binary number to fill up with zeros. (Any binary vector).</p>
</td></tr>
<tr><td><code id="fillUpToBit_+3A_n">n</code></td>
<td>
<p>size in bit.</p>
</td></tr>
<tr><td><code id="fillUpToBit_+3A_value">value</code></td>
<td>
<p>to fill up with FALSE(0) or fill up with TRUE(1).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No floating point supported.
</p>


<h3>Value</h3>

<p>binary number. A binary vector with the desired size.
</p>


<h3>See Also</h3>

<p><a href="#topic+fillUpToByte">fillUpToByte</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rdiversity:::fillUpToBit(as.binary(c(1,1), logic=TRUE), n=4)
rdiversity:::fillUpToBit(as.binary(c(1,0,1), logic=TRUE), n=4, value=FALSE)
</code></pre>

<hr>
<h2 id='fillUpToByte'>Fill up to Byte (00000000..)</h2><span id='topic+fillUpToByte'></span>

<h3>Description</h3>

<p>Fills up the binary number with zeros(0) or ones(1), to the size in Byte.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fillUpToByte(x, size=0, value=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fillUpToByte_+3A_x">x</code></td>
<td>
<p>The binary number to fill up with zeros. (Any binary vector).</p>
</td></tr>
<tr><td><code id="fillUpToByte_+3A_size">size</code></td>
<td>
<p>in Byte. 0 = auto (smallest possible Byte).</p>
</td></tr>
<tr><td><code id="fillUpToByte_+3A_value">value</code></td>
<td>
<p>to fill up with FALSE(0) or fill up with TRUE(1).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No floating point supported.
</p>


<h3>Value</h3>

<p>binary number. A binary vector with the desired size.
</p>


<h3>See Also</h3>

<p><a href="#topic+fillUpToBit">fillUpToBit</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rdiversity:::fillUpToByte(as.binary(c(1,1), logic=TRUE), size=2)
rdiversity:::fillUpToByte(as.binary(c(1,0,1), logic=TRUE), size=2, value=FALSE)
</code></pre>

<hr>
<h2 id='gen2dist'>Genetic distance matrix</h2><span id='topic+gen2dist'></span>

<h3>Description</h3>

<p>Converts a vcfR object to a matrix of pairwise genetic distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen2dist(vcf, biallelic = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen2dist_+3A_vcf">vcf</code></td>
<td>
<p>object of class <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="gen2dist_+3A_biallelic">biallelic</code></td>
<td>
<p>logical describing whether the data is biallelic or not (default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>gen2dist(x)</code> returns an object of class <code>distance</code>
containing a <code>matrix</code> of pairwise genetic distances.
</p>

<hr>
<h2 id='inddiv'>Calculate individual-level diversity</h2><span id='topic+inddiv'></span><span id='topic+inddiv+2Cpowermean-method'></span><span id='topic+inddiv+2Crelativeentropy-method'></span><span id='topic+inddiv+2Cmetacommunity-method'></span>

<h3>Description</h3>

<p>Generic function for calculating individual-level diversity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inddiv(data, qs)

## S4 method for signature 'powermean'
inddiv(data, qs)

## S4 method for signature 'relativeentropy'
inddiv(data, qs)

## S4 method for signature 'metacommunity'
inddiv(data, qs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inddiv_+3A_data">data</code></td>
<td>
<p><code>matrix</code> of mode <code>numeric</code>; containing diversity
components</p>
</td></tr>
<tr><td><code id="inddiv_+3A_qs">qs</code></td>
<td>
<p><code>vector</code> of mode <code>numeric</code> containing <em>q</em> values</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>data</code> may be input as three different classes:
</p>

<ul>
<li><p><code>power_mean</code>: calculates raw and normalised subcommunity alpha, rho
or gamma diversity by taking the powermean of diversity components
</p>
</li>
<li><p><code>relativeentropy</code>: calculates raw or normalised subcommunity beta
diversity by taking the relative entropy of diversity components
</p>
</li>
<li><p><code>metacommunity</code>: calculates all subcommunity measures of diversity
</p>
</li></ul>



<h3>Value</h3>

<p><code>inddiv()</code> returns a standard output of class <code>rdiv</code>
</p>


<h3>References</h3>

<p>Reeve, R., T. Leinster, C. Cobbold, J. Thompson, N. Brummitt,
S. Mitchell, and L. Matthews. 2016. How to partition diversity.
arXiv 1404.6520v3:1–9.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+subdiv">subdiv</a></code> for subcommunity-level diversity and
<code><a href="#topic+metadiv">metadiv</a></code> for metacommunity-level diversity.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define metacommunity
pop &lt;- cbind.data.frame(A = c(1,1), B = c(2,0), C = c(3,1))
row.names(pop) &lt;- paste0("sp", 1:2)
pop &lt;- pop/sum(pop)
meta &lt;- metacommunity(pop)

# Calculate subcommunity gamma diversity (takes the power mean)
g &lt;- raw_gamma(meta)
inddiv(g, 0:2)

# Calculate subcommunity beta diversity (takes the relative entropy)
b &lt;- raw_beta(meta)
inddiv(b, 0:2)

# Calculate all measures of individual diversity
inddiv(meta, 0:2)

</code></pre>

<hr>
<h2 id='is.binary'>is Binary Vector</h2><span id='topic+is.binary'></span>

<h3>Description</h3>

<p>test for object &quot;binary&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.binary(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.binary_+3A_x">x</code></td>
<td>
<p>object to test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE or FALSE.
</p>


<h3>See Also</h3>

<p><a href="#topic+as.binary">as.binary</a> and <a href="#topic+binary">binary</a>
</p>

<hr>
<h2 id='loadAttributes'>loadAttributes</h2><span id='topic+loadAttributes'></span>

<h3>Description</h3>

<p>Helper function load Attributes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadAttributes(x, l)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadAttributes_+3A_x">x</code></td>
<td>
<p>x</p>
</td></tr>
<tr><td><code id="loadAttributes_+3A_l">l</code></td>
<td>
<p>l</p>
</td></tr>
</table>

<hr>
<h2 id='meta_gamma'>Metacommunity gamma diversity</h2><span id='topic+meta_gamma'></span>

<h3>Description</h3>

<p>Calculates similarity-sensitive metacommunity gamma diversity (the
metacommunity similarity-sensitive diversity). This measure may be
calculated for a series of orders, represented as a vector of <code>qs</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meta_gamma(meta, qs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meta_gamma_+3A_meta">meta</code></td>
<td>
<p>object of class <code>metacommunity</code></p>
</td></tr>
<tr><td><code id="meta_gamma_+3A_qs">qs</code></td>
<td>
<p><code>vector</code> of mode <code>numeric</code> containing <em>q</em> values</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>meta_gamma</code> returns a standard output of class <code>rdiv</code>
</p>


<h3>References</h3>

<p>R. Reeve, T. Leinster, C. Cobbold, J. Thompson, N. Brummitt,
S. Mitchell, and L. Matthews. 2016. How to partition diversity.
arXiv 1404.6520v3:1–9.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop &lt;- data.frame(a = c(1,3), b = c(1,1))
row.names(pop) &lt;- paste0("sp", 1:2)
pop &lt;- pop/sum(pop)
meta &lt;- metacommunity(pop)

# Calculate metacommunity gamma diversity
meta_gamma(meta, 0:2)

</code></pre>

<hr>
<h2 id='metacommunity'>Metacommunity</h2><span id='topic+metacommunity'></span><span id='topic+metacommunity+2Cdata.frame+2Cmissing-method'></span><span id='topic+metacommunity+2Cdata.frame-method'></span><span id='topic+metacommunity+2Cnumeric+2Cmissing-method'></span><span id='topic+metacommunity+2Cnumeric-method'></span><span id='topic+metacommunity+2Cmatrix+2Cmissing-method'></span><span id='topic+metacommunity+2Cmatrix-method'></span><span id='topic+metacommunity+2Cmissing+2Csimilarity-method'></span><span id='topic+metacommunity+2Csimilarity-method'></span><span id='topic+metacommunity+2Cnumeric+2Csimilarity-method'></span><span id='topic+metacommunity+2Cdata.frame+2Csimilarity-method'></span><span id='topic+metacommunity+2Cmatrix+2Csimilarity-method'></span>

<h3>Description</h3>

<p>Functions to generate a <code>metacommunity</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metacommunity(partition, similarity)

## S4 method for signature 'data.frame,missing'
metacommunity(partition)

## S4 method for signature 'numeric,missing'
metacommunity(partition)

## S4 method for signature 'matrix,missing'
metacommunity(partition)

## S4 method for signature 'missing,similarity'
metacommunity(partition, similarity)

## S4 method for signature 'numeric,similarity'
metacommunity(partition, similarity)

## S4 method for signature 'data.frame,similarity'
metacommunity(partition, similarity)

## S4 method for signature 'matrix,similarity'
metacommunity(partition, similarity)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metacommunity_+3A_partition">partition</code></td>
<td>
<p>two-dimensional <code>matrix</code> of mode <code>numeric</code>
with rows as types, columns as subcommunities, and elements containing
the relative abundances of types in subcommunities. For phylogenetic
diversity, see <em>Details</em></p>
</td></tr>
<tr><td><code id="metacommunity_+3A_similarity">similarity</code></td>
<td>
<p>(optional) object of class <code>similarity</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>metacommunity()</code> returns an object of class
<code>metacommunity</code> (see <em>Fields</em>).
</p>


<h3>Fields</h3>


<dl>
<dt><code>type_abundance</code></dt><dd><p>two-dimensional <code>matrix</code> of mode <code>numeric</code>
with rows as types (species), columns as subcommunities, and each
element containing the relative abundance of types in each subcommunity
relative to the metacommunity as a whole. In the phylogenetic case, this
corresponds to the proportional abundance of historical species, which is
calculated from the proportional abundance of terminal taxa</p>
</dd>
<dt><code>similarity</code></dt><dd><p>two-dimensional <code>matrix</code> of mode <code>numeric</code> with
rows as types, columns as types, and elements containing pairwise
similarities between types</p>
</dd>
<dt><code>similarity_components</code></dt><dd><p>list containing the components necessary to
calculate similarity. This list is empty when <code>precompute_dist = TRUE</code>
when calculating distance. When a pairwise distance matrix is too large and
<code>precompute_dist = FALSE</code>, this list contains all the information
required to calculate pairwise distance between types</p>
</dd>
<dt><code>similarity_parameters</code></dt><dd><p>list containing parameters associated with
converting pairwise distances to similarities (the <code>dist2sim()</code>
arguments)</p>
</dd>
<dt><code>ordinariness</code></dt><dd><p>two-dimensional <code>matrix</code> of mode <code>numeric</code>
with rows as types, columns as subcommunities, and elements containing the
ordinariness of types within subcommunities</p>
</dd>
<dt><code>subcommunity_weights</code></dt><dd><p><code>vector</code> of mode <code>numeric</code> containing
subcommunity weights</p>
</dd>
<dt><code>type_weights</code></dt><dd><p>two-dimensional <code>matrix</code> of mode <code>numeric</code>,
with rows as types, columns as subcommunities, and elements containing
weights of types within a subcommunity</p>
</dd>
<dt><code>dat_ID</code></dt><dd><p>object of class <code>character</code> denoting the type of diversity
being calculated. This can be &quot;naive&quot;, &quot;genetic&quot;, &quot;taxonomic&quot;, and so on</p>
</dd>
<dt><code>raw_abundance</code></dt><dd><p>[Phylogenetic] two-dimensional <code>matrix</code> of mode
<code>numeric</code> with rows as types, columns as subcommunities, and elements
containing the relative abundance of present day species</p>
</dd>
<dt><code>raw_structure</code></dt><dd><p>[Phylogenetic] two-dimensional <code>matrix</code> of mode
<code>numeric</code> with rows as historical species, columns as present day
species, and elements containing historical species lengths within lineages</p>
</dd>
<dt><code>parameters</code></dt><dd><p>[Phylogenetic] <code>data.frame</code> containing parameters
associated with each historic species in the phylogeny</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+metacommunity-class">metacommunity-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Naive-type
partition &lt;- cbind(a = c(1,1,1,0,0), b = c(0,1,0,1,1))
row.names(partition) &lt;- paste0("sp", 1:5)
partition &lt;- partition / sum(partition)
meta &lt;- metacommunity(partition)

</code></pre>

<hr>
<h2 id='metacommunity-class'>metacommunity-class</h2><span id='topic+metacommunity-class'></span><span id='topic+show+2Cmetacommunity-method'></span>

<h3>Description</h3>

<p>Container for class <code>metacommunity</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'metacommunity'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metacommunity-class_+3A_object">object</code></td>
<td>
<p>object of class <code>metacommunity</code></p>
</td></tr>
</table>


<h3>Fields</h3>


<dl>
<dt><code>type_abundance</code></dt><dd><p>two-dimensional <code>matrix</code> of mode <code>numeric</code>
with rows as types (species), columns as subcommunities, and each
element containing the relative abundance of types in each subcommunity
relative to the metacommunity as a whole. In the phylogenetic case, this
corresponds to the proportional abundance of historical species, which is
calculated from the proportional abundance of terminal taxa</p>
</dd>
<dt><code>similarity</code></dt><dd><p>two-dimensional <code>matrix</code> of mode <code>numeric</code>
with rows as types, columns as types, and elements containing the pairwise
similarity of types</p>
</dd>
<dt><code>similarity_components</code></dt><dd><p>list containing the components necessary to
calculate similarity. This list is empty when <code>precompute_dist = TRUE</code>
when calculating distance. When a pairwise distance matrix is too large and
<code>precompute_dist = FALSE</code>, this list contains all the information
required to calculate pairwise distance between types</p>
</dd>
<dt><code>similarity_parameters</code></dt><dd><p>list containing parameters associated with
converting pairwise distances to similarities (the <code>dist2sim()</code>
arguments)</p>
</dd>
<dt><code>ordinariness</code></dt><dd><p>two-dimensional <code>matrix</code> of mode <code>numeric</code>
with rows as types, columns as subcommunities, and elements containing the
ordinariness of types within subcommunities</p>
</dd>
<dt><code>subcommunity_weights</code></dt><dd><p><code>vector</code> of mode <code>numeric</code> containing
subcommunity weights</p>
</dd>
<dt><code>type_weights</code></dt><dd><p>two-dimensional <code>matrix</code> of mode <code>numeric</code>,
with rows as types, columns as subcommunities, and elements containing
weights of types within a subcommunity</p>
</dd>
<dt><code>dat_id</code></dt><dd><p>object of class <code>character</code> describing the class of
distance / similarity being used, e.g. &quot;naive&quot;, &quot;taxonomic&quot;, and so on</p>
</dd>
<dt><code>raw_abundance</code></dt><dd><p>[Phylogenetic] two-dimensional <code>matrix</code> of mode
<code>numeric</code> with rows as types, columns as subcommunities, and elements
containing the relative abundance of present day species</p>
</dd>
<dt><code>raw_structure</code></dt><dd><p>[Phylogenetic] two-dimensional <code>matrix</code> of mode
<code>numeric</code> with rows as historical species, columns as present day
species, and elements containing historical species lengths within lineages</p>
</dd>
<dt><code>parameters</code></dt><dd><p>[Phylogenetic] <code>data.frame</code> containing parameters
associated with each historic species in the phylogeny</p>
</dd>
</dl>

<hr>
<h2 id='metadiv'>Metacommunity-level diversity</h2><span id='topic+metadiv'></span><span id='topic+metadiv+2Cpowermean-method'></span><span id='topic+metadiv+2Crelativeentropy-method'></span><span id='topic+metadiv+2Cmetacommunity-method'></span>

<h3>Description</h3>

<p>Generic function for calculating metacommunity-level diversity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metadiv(data, qs)

## S4 method for signature 'powermean'
metadiv(data, qs)

## S4 method for signature 'relativeentropy'
metadiv(data, qs)

## S4 method for signature 'metacommunity'
metadiv(data, qs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metadiv_+3A_data">data</code></td>
<td>
<p><code>matrix</code> of mode <code>numeric</code>; containing diversity
components</p>
</td></tr>
<tr><td><code id="metadiv_+3A_qs">qs</code></td>
<td>
<p><code>vector</code> of mode <code>numeric</code> containing <em>q</em> values</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>data</code> may be input as one of three different classes:
</p>

<ul>
<li><p><code>powermean</code>: raw or normalised metacommunity alpha, rho or gamma
diversity components; will calculate metacommunity-level raw or normalised
metacommunity alpha, rho or gamma diversity
</p>
</li>
<li><p><code>relativeentropy</code>: raw or normalised metacommunity beta
diversity components; will calculate metacommunity-level raw or normalised
metacommunity beta diversity
</p>
</li>
<li><p><code>metacommunity</code>: will calculate all metacommunity measures of
diversity
</p>
</li></ul>



<h3>Value</h3>

<p><code>metadiv()</code> returns a standard output of class <code>rdiv</code>
</p>


<h3>References</h3>

<p>Reeve, R., T. Leinster, C. Cobbold, J. Thompson, N. Brummitt,
S. Mitchell, and L. Matthews. 2016. How to partition diversity.
arXiv 1404.6520v3:1–9.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inddiv">inddiv</a></code> for type-level diversity and
<code><a href="#topic+subdiv">subdiv</a></code> for subcommunity-level diversity.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define metacommunity
pop &lt;- data.frame(a = c(1,3), b = c(1,1))
pop &lt;- pop / sum(pop)
meta &lt;- metacommunity(pop)

# Calculate metacommunity gamma diversity (takes the power mean)
g &lt;- raw_gamma(meta)
metadiv(g, 0:2)

# Calculate metacommunity beta diversity (takes the relative entropy)
b &lt;- raw_beta(meta)
metadiv(b, 0:2)

# Calculate all measures of metacommunity diversity
metadiv(meta, 0:2)

</code></pre>

<hr>
<h2 id='negate'>Binary Negation (!)</h2><span id='topic+negate'></span>

<h3>Description</h3>

<p>Negates the binary number x. Negation x -&gt; -x or -x -&gt; x
</p>


<h3>Usage</h3>

<pre><code class='language-R'>negate(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="negate_+3A_x">x</code></td>
<td>
<p>The number to be negated. A binary vector is expected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An »unsigned« number will be returned as »signed« regardless of whether the value is negative.
No floating point supported.
</p>


<h3>Value</h3>

<p>The negated number of x. Returns a binary vector with signed=TRUE
</p>


<h3>See Also</h3>

<p><a href="#topic+switchEndianess">switchEndianess</a> or <a href="#topic+fillUpToByte">fillUpToByte</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(rdiversity:::negate(as.binary(5, signed=TRUE)))
summary(rdiversity:::negate(as.binary(-5, signed=TRUE)))
summary(rdiversity:::negate(as.binary(5, signed=FALSE)))
</code></pre>

<hr>
<h2 id='norm_alpha'>Normalised alpha (low level diversity component)</h2><span id='topic+norm_alpha'></span>

<h3>Description</h3>

<p>Calculates the low-level diversity component necessary for calculating
normalised alpha diversity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm_alpha(meta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norm_alpha_+3A_meta">meta</code></td>
<td>
<p>object of class <code>metacommunity</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Values generated from <code>norm_alpha()</code> may be input into <code>subdiv()</code>
and <code>metadiv()</code> to calculate normalised subcommunity and metacommunity
alpha diversity.
</p>


<h3>Value</h3>

<p><code>norm_alpha</code> returns an object of class <code>powermean</code>
</p>


<h3>References</h3>

<p>R. Reeve, T. Leinster, C. Cobbold, J. Thompson, N. Brummitt,
S. Mitchell, and L. Matthews. 2016. How to partition diversity.
arXiv 1404.6520v3:1–9.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop &lt;- data.frame(a = c(1,3), b = c(1,1))
row.names(pop) &lt;- paste0("sp", 1:2)
pop &lt;- pop/sum(pop)
meta &lt;- metacommunity(pop)

# Calculate normalised alpha component
a &lt;- norm_alpha(meta)
subdiv(a, 1)
metadiv(a, 1)

</code></pre>

<hr>
<h2 id='norm_beta'>Normalised beta (low level diversity component)</h2><span id='topic+norm_beta'></span>

<h3>Description</h3>

<p>Calculates the low-level diversity component necessary for calculating
normalised beta diversity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm_beta(meta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norm_beta_+3A_meta">meta</code></td>
<td>
<p>object of class <code>metacommunity</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Values generated from <code>norm_beta()</code> may be input into <code>subdiv()</code> and
<code>metadiv()</code> to calculate normalised subcommunity and metacommunity beta
diversity.
</p>


<h3>Value</h3>

<p><code>norm_beta</code> returns an object of class <code>relativeentropy</code>
</p>


<h3>References</h3>

<p>R. Reeve, T. Leinster, C. Cobbold, J. Thompson, N. Brummitt,
S. Mitchell, and L. Matthews. 2016. How to partition diversity.
arXiv 1404.6520v3:1–9.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop &lt;- data.frame(a = c(1,3), b = c(1,1))
row.names(pop) &lt;- paste0("sp", 1:2)
pop &lt;- pop/sum(pop)
meta &lt;- metacommunity(pop)

# Calculate normalised beta component
b &lt;- norm_beta(meta)
subdiv(b, 1)
metadiv(b, 1)

</code></pre>

<hr>
<h2 id='norm_meta_alpha'>Normalised metacommunity alpha diversity</h2><span id='topic+norm_meta_alpha'></span>

<h3>Description</h3>

<p>Calculates similarity-sensitive normalised metacommunity alpha diversity
(the average similarity-sensitive diversity of subcommunities). This
measure may be calculated for a series of orders, represented as a vector
of <code>qs</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm_meta_alpha(meta, qs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norm_meta_alpha_+3A_meta">meta</code></td>
<td>
<p>object of class <code>metacommunity</code></p>
</td></tr>
<tr><td><code id="norm_meta_alpha_+3A_qs">qs</code></td>
<td>
<p><code>vector</code> of mode <code>numeric</code> containing <em>q</em> values</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>norm_meta_alpha</code> returns a standard output of class <code>rdiv</code>
</p>


<h3>References</h3>

<p>R. Reeve, T. Leinster, C. Cobbold, J. Thompson, N. Brummitt,
S. Mitchell, and L. Matthews. 2016. How to partition diversity.
arXiv 1404.6520v3:1–9.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop &lt;- data.frame(a = c(1,3), b = c(1,1))
row.names(pop) &lt;- paste0("sp", 1:2)
pop &lt;- pop/sum(pop)
meta &lt;- metacommunity(pop)

# Calculate normalised metacommunity alpha diversity
norm_meta_alpha(meta, 0:2)

</code></pre>

<hr>
<h2 id='norm_meta_beta'>Normalised metacommunity beta diversity</h2><span id='topic+norm_meta_beta'></span>

<h3>Description</h3>

<p>Calculates similarity-sensitive normalised metacommunity beta diversity
(the effective number of distinct subcommunities. This measure may be
calculated for a series of orders, represented as a vector of <code>qs</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm_meta_beta(meta, qs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norm_meta_beta_+3A_meta">meta</code></td>
<td>
<p>object of class <code>metacommunity</code></p>
</td></tr>
<tr><td><code id="norm_meta_beta_+3A_qs">qs</code></td>
<td>
<p><code>vector</code> of mode <code>numeric</code> containing <em>q</em> values</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>norm_meta_beta</code> returns a standard output of class <code>rdiv</code>
</p>


<h3>References</h3>

<p>R. Reeve, T. Leinster, C. Cobbold, J. Thompson, N. Brummitt,
S. Mitchell, and L. Matthews. 2016. How to partition diversity.
arXiv 1404.6520v3:1–9.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop &lt;- data.frame(a = c(1,3), b = c(1,1))
row.names(pop) &lt;- paste0("sp", 1:2)
pop &lt;- pop/sum(pop)
meta &lt;- metacommunity(pop)

# Calculate normalised metacommunity beta diversity
norm_meta_beta(meta, 0:2)

</code></pre>

<hr>
<h2 id='norm_meta_rho'>Normalised metacommunity rho diversity</h2><span id='topic+norm_meta_rho'></span>

<h3>Description</h3>

<p>Calculates similarity-sensitive normalised metacommunity rho diversity (the
average representativeness of subcommunities. This measure may be
calculated for a series of orders, represented as a vector of <code>qs</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm_meta_rho(meta, qs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norm_meta_rho_+3A_meta">meta</code></td>
<td>
<p>object of class <code>metacommunity</code></p>
</td></tr>
<tr><td><code id="norm_meta_rho_+3A_qs">qs</code></td>
<td>
<p><code>vector</code> of mode <code>numeric</code> containing <em>q</em> values</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>norm_meta_rho</code> returns a standard output of class <code>rdiv</code>
</p>


<h3>References</h3>

<p>R. Reeve, T. Leinster, C. Cobbold, J. Thompson, N. Brummitt,
S. Mitchell, and L. Matthews. 2016. How to partition diversity.
arXiv 1404.6520v3:1–9.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop &lt;- data.frame(a = c(1,3), b = c(1,1))
row.names(pop) &lt;- paste0("sp", 1:2)
pop &lt;- pop/sum(pop)
meta &lt;- metacommunity(pop)

# Calculate normalised metacommunity rho diversity
norm_meta_rho(meta, 0:2)

</code></pre>

<hr>
<h2 id='norm_rho'>Normalised rho (low level diversity component)</h2><span id='topic+norm_rho'></span>

<h3>Description</h3>

<p>Calculates the low-level diversity component necessary for calculating
normalised rho diversity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm_rho(meta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norm_rho_+3A_meta">meta</code></td>
<td>
<p>object of class <code>metacommunity</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Values generated from <code>norm_rho()</code> may be input into <code>subdiv()</code> and
<code>metadiv()</code> to calculate normalised subcommunity and metacommunity rho
diversity.
</p>


<h3>Value</h3>

<p><code>norm_rho</code> returns an object of class <code>powermean</code>
</p>


<h3>References</h3>

<p>R. Reeve, T. Leinster, C. Cobbold, J. Thompson, N. Brummitt,
S. Mitchell, and L. Matthews. 2016. How to partition diversity.
arXiv 1404.6520v3:1–9.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop &lt;- data.frame(a = c(1,3), b = c(1,1))
row.names(pop) &lt;- paste0("sp", 1:2)
pop &lt;- pop/sum(pop)
meta &lt;- metacommunity(pop)

# Calculate normalised rho component
r &lt;- norm_rho(meta)
subdiv(r, 1)
metadiv(r, 1)

</code></pre>

<hr>
<h2 id='norm_sub_alpha'>Normalised subcommunity alpha diversity</h2><span id='topic+norm_sub_alpha'></span>

<h3>Description</h3>

<p>Calculates similarity-sensitive normalised subcommunity alpha diversity
(the diversity of subcommunity <em>j</em> in isolation. This measure may be
calculated for a series of orders, represented as a vector of <code>qs</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm_sub_alpha(meta, qs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norm_sub_alpha_+3A_meta">meta</code></td>
<td>
<p>object of class <code>metacommunity</code></p>
</td></tr>
<tr><td><code id="norm_sub_alpha_+3A_qs">qs</code></td>
<td>
<p><code>vector</code> of mode <code>numeric</code> containing <em>q</em> values</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>norm_sub_alpha</code> returns a standard output of class <code>rdiv</code>
</p>


<h3>References</h3>

<p>R. Reeve, T. Leinster, C. Cobbold, J. Thompson, N. Brummitt,
S. Mitchell, and L. Matthews. 2016. How to partition diversity.
arXiv 1404.6520v3:1–9.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop &lt;- data.frame(a = c(1,3), b = c(1,1))
row.names(pop) &lt;- paste0("sp", 1:2)
pop &lt;- pop/sum(pop)
meta &lt;- metacommunity(pop)

# Calculate normalised subcommunity alpha diversity
norm_sub_alpha(meta, 0:2)

</code></pre>

<hr>
<h2 id='norm_sub_beta'>Normalised subcommunity beta diversity</h2><span id='topic+norm_sub_beta'></span>

<h3>Description</h3>

<p>Calculates similarity-sensitive normalised subcommunity beta diversity (an
estimate of the effective number of distinct subcommunities). This
measure may be calculated for a series of orders, represented as a vector
of <code>qs</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm_sub_beta(meta, qs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norm_sub_beta_+3A_meta">meta</code></td>
<td>
<p>object of class <code>metacommunity</code></p>
</td></tr>
<tr><td><code id="norm_sub_beta_+3A_qs">qs</code></td>
<td>
<p><code>vector</code> of mode <code>numeric</code> containing <em>q</em> values</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>norm_sub_beta</code> returns a standard output of class <code>rdiv</code>
</p>


<h3>References</h3>

<p>R. Reeve, T. Leinster, C. Cobbold, J. Thompson, N. Brummitt,
S. Mitchell, and L. Matthews. 2016. How to partition diversity.
arXiv 1404.6520v3:1–9.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop &lt;- data.frame(a = c(1,3), b = c(1,1))
row.names(pop) &lt;- paste0("sp", 1:2)
pop &lt;- pop/sum(pop)
meta &lt;- metacommunity(pop)

# Calculate normalised subcommunity beta diversity
norm_sub_beta(meta, 0:2)

</code></pre>

<hr>
<h2 id='norm_sub_rho'>Normalised subcommunity rho diversity</h2><span id='topic+norm_sub_rho'></span>

<h3>Description</h3>

<p>Calculates similarity-sensitive normalised subcommunity rho diversity (the
representativeness of subcommunity <em>j</em>). This measure may be calculated
for a series of orders, represented as a vector of <code>qs</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm_sub_rho(meta, qs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norm_sub_rho_+3A_meta">meta</code></td>
<td>
<p>object of class <code>metacommunity</code></p>
</td></tr>
<tr><td><code id="norm_sub_rho_+3A_qs">qs</code></td>
<td>
<p><code>vector</code> of mode <code>numeric</code> containing <em>q</em> values</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>norm_sub_rho</code> returns a standard output of class <code>rdiv</code>
</p>


<h3>References</h3>

<p>R. Reeve, T. Leinster, C. Cobbold, J. Thompson, N. Brummitt,
S. Mitchell, and L. Matthews. 2016. How to partition diversity.
arXiv 1404.6520v3:1–9.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop &lt;- data.frame(a = c(1,3), b = c(1,1))
row.names(pop) &lt;- paste0("sp", 1:2)
pop &lt;- pop/sum(pop)
meta &lt;- metacommunity(pop)

# Calculate normalised subcommunity rho diversity
norm_sub_rho(meta, 0:2)

</code></pre>

<hr>
<h2 id='Ops.binary'>Group Generic Ops</h2><span id='topic+Ops.binary'></span>

<h3>Description</h3>

<p>Group generic Ops operators
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'binary'
Ops(e1, e2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ops.binary_+3A_e1">e1</code></td>
<td>
<p>e1</p>
</td></tr>
<tr><td><code id="Ops.binary_+3A_e2">e2</code></td>
<td>
<p>e2</p>
</td></tr>
</table>

<hr>
<h2 id='phy_abundance'>Relative abundance of historical species</h2><span id='topic+phy_abundance'></span>

<h3>Description</h3>

<p>Calculates the relative abundance of historical species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phy_abundance(partition, structure_matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phy_abundance_+3A_partition">partition</code></td>
<td>
<p>two-dimensional <code>matrix</code> of mode <code>numeric</code>
with rows as types (species), columns as subcommunities, and each
element containing the relative abundance of types in each subcommunity
relative to the metacommunity as a whole. In the phylogenetic case, this
corresponds to the proportional abundance of historical species, which is
calculated from the proportional abundance of terminal taxa</p>
</td></tr>
<tr><td><code id="phy_abundance_+3A_structure_matrix">structure_matrix</code></td>
<td>
<p><code>output$structure</code> of <code>phy_struct()</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='phy_struct'>Calculate phylogenetic structure matrix</h2><span id='topic+phy_struct'></span>

<h3>Description</h3>

<p>Converts an object into class <code>phylo</code> into class <code>phy_struct</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phy_struct(tree, partition)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phy_struct_+3A_tree">tree</code></td>
<td>
<p>object of class <code>phylo</code></p>
</td></tr>
<tr><td><code id="phy_struct_+3A_partition">partition</code></td>
<td>
<p>two-dimensional <code>matrix</code> of mode <code>numeric</code>
with rows as types (species), columns as subcommunities, and each
element containing the relative abundance of types in each subcommunity
relative to the metacommunity as a whole. In the phylogenetic case, this
corresponds to the proportional abundance of historical species, which is
calculated from the proportional abundance of terminal taxa</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>phy_struct()</code> returns a <code>list</code> containing:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>$structure</code> </td><td style="text-align: left;"> - each row denotes historical species, columns
denote terminal taxa, and elements contain 'branch lengths' </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>$tbar</code> - the average distance from root to tip for all terminal
taxa </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>$parameters</code> </td><td style="text-align: left;"> - information associated with each historical
species </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>$tree</code> </td><td style="text-align: left;"> - object of class <code>phylo</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<hr>
<h2 id='phy2branch'>Phylogenetic similarity</h2><span id='topic+phy2branch'></span>

<h3>Description</h3>

<p>Packages all inputs into an object of class <code>similarity</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phy2branch(tree, partition, depth = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phy2branch_+3A_tree">tree</code></td>
<td>
<p>object of class <code>phylo</code>.</p>
</td></tr>
<tr><td><code id="phy2branch_+3A_partition">partition</code></td>
<td>
<p>two-dimensional <code>matrix</code> of mode <code>numeric</code>
with rows as types (terminal taxa), columns as subcommunities, and each
element containing the relative abundance of types in each subcommunity
relative to the metacommunity as a whole.</p>
</td></tr>
<tr><td><code id="phy2branch_+3A_depth">depth</code></td>
<td>
<p>proportion of total tree height to be conserved (taken as
a proportion from the highest tip). Describes how much evolutionary history
should be retained, with 0 marking the date of the most recent tip, and 1
(the default) marking the most recent common ancestor. Numbers greater than
1 extend the root of the tree.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>phy2branch()</code> returns an object of class <code>similarity</code>.
</p>

<hr>
<h2 id='phy2dist'>Phylogenetic pairwise tip distance matrix</h2><span id='topic+phy2dist'></span>

<h3>Description</h3>

<p>Converts any <code>phylo</code> object to a matrix of pairwise tip-to-tip distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phy2dist(tree, precompute_dist = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phy2dist_+3A_tree">tree</code></td>
<td>
<p>object of class <code>phylo</code>.</p>
</td></tr>
<tr><td><code id="phy2dist_+3A_precompute_dist">precompute_dist</code></td>
<td>
<p>object of class <code>logical</code> or <code>numeric</code>.
When TRUE (by default) a distance matrix is generated and stored in slot
<code>distance</code>, when FALSE no distance matrix is generated, and when numeric
a distance matrix is generated until the number of species exceeds the
defined value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>phy2sim(x)</code> returns an object of class <code>distance</code>
containing a <code>matrix</code> of pairwise tip-to-tip distances.
</p>

<hr>
<h2 id='power_mean'>Power mean of vector elements</h2><span id='topic+power_mean'></span>

<h3>Description</h3>

<p><code>power_mean()</code> calculates the power mean of a set of values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power_mean(values, order = 1, weights = rep(1, length(values)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="power_mean_+3A_values">values</code></td>
<td>
<p>Values for which to calculate mean.</p>
</td></tr>
<tr><td><code id="power_mean_+3A_order">order</code></td>
<td>
<p>Order of power mean.</p>
</td></tr>
<tr><td><code id="power_mean_+3A_weights">weights</code></td>
<td>
<p>Weights of elements, normalised to 1 inside function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the order-th power mean of a single
set of non-negative values, weighted by weights; by default, weights are
equal and order is 1, so this is just the arithmetic mean. Equal weights
and a order of 0 gives the geometric mean, and an order of -1 gives the
harmonic mean.
</p>


<h3>Value</h3>

<p>Weighted power mean
</p>


<h3>Examples</h3>

<pre><code class='language-R'>values &lt;- sample(1:50, 5)
power_mean(values)

</code></pre>

<hr>
<h2 id='powermean-class'>powermean-class</h2><span id='topic+powermean-class'></span>

<h3>Description</h3>

<p>Container for class <code>powermean</code>.
</p>


<h3>Fields</h3>


<dl>
<dt><code>results</code></dt><dd><p><code>data.frame</code> containing rdiversity output</p>
</dd>
<dt><code>measure</code></dt><dd><p>object of class <code>character</code> naming the diversity
measure being calculated</p>
</dd>
<dt><code>type_abundance</code></dt><dd><p>two-dimensional <code>matrix</code> of mode <code>numeric</code>
with rows as types (species), columns as subcommunities, and each
element containing the relative abundance of types in each subcommunity
relative to the metacommunity as a whole. In the phylogenetic case, this
corresponds to the proportional abundance of historical species, which is
calculated from the proportional abundance of terminal taxa</p>
</dd>
<dt><code>ordinariness</code></dt><dd><p>two-dimensional <code>matrix</code> of mode <code>numeric</code>
with rows as types, columns as subcommunities, and elements containing the
ordinariness of types within subcommunities</p>
</dd>
<dt><code>subcommunity_weights</code></dt><dd><p><code>vector</code> of mode <code>numeric</code> containing
subcommunity weights</p>
</dd>
<dt><code>type_weights</code></dt><dd><p>two-dimensional <code>matrix</code> of mode <code>numeric</code>,
with rows as types, columns as subcommunities, and elements containing
weights of types within a subcommunity</p>
</dd>
<dt><code>dat_id</code></dt><dd><p>object of class <code>character</code> describing the class of
distance / similarity being used, e.g. &quot;naive&quot;, &quot;taxonomic&quot;, and so on</p>
</dd>
<dt><code>similarity_components</code></dt><dd><p>list containing the components necessary to
calculate similarity. This list is empty when <code>precompute_dist = TRUE</code>
when calculating distance. When a pairwise distance matrix is too large and
<code>precompute_dist = FALSE</code>, this list contains all the information
required to calculate pairwise distance between types</p>
</dd>
<dt><code>similarity_parameters</code></dt><dd><p>list containing parameters associated with
converting pairwise distances to similarities (the <code>dist2sim()</code>
arguments)</p>
</dd>
</dl>

<hr>
<h2 id='print.binary'>Print method for binary number.</h2><span id='topic+print.binary'></span>

<h3>Description</h3>

<p>This method prints the binary number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'binary'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.binary_+3A_x">x</code></td>
<td>
<p>any binary number.</p>
</td></tr>
<tr><td><code id="print.binary_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Output in ones and zeros (binary vector).
</p>


<h3>See Also</h3>

<p><a href="#topic+summary.binary">summary.binary</a> provides some additional information.
</p>

<hr>
<h2 id='raw_alpha'>Raw alpha (low level diversity component)</h2><span id='topic+raw_alpha'></span>

<h3>Description</h3>

<p>Calculates the low-level diversity component necessary for calculating alpha
diversity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raw_alpha(meta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raw_alpha_+3A_meta">meta</code></td>
<td>
<p>object of class <code>metacommunity</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Values generated from <code>raw_alpha()</code> may be input into <code>subdiv()</code> and
<code>metadiv()</code> to calculate raw subcommunity and metacommunity alpha
diversity.
</p>


<h3>Value</h3>

<p><code>raw_alpha</code> returns an object of class <code>powermean</code>
</p>


<h3>References</h3>

<p>R. Reeve, T. Leinster, C. Cobbold, J. Thompson, N. Brummitt,
S. Mitchell, and L. Matthews. 2016. How to partition diversity.
arXiv 1404.6520v3:1–9.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop &lt;- data.frame(a = c(1,3), b = c(1,1))
row.names(pop) &lt;- paste0("sp", 1:2)
pop &lt;- pop/sum(pop)
meta &lt;- metacommunity(pop)

# Calculate raw alpha component
a &lt;- raw_alpha(meta)
subdiv(a, 1)
metadiv(a, 1)

</code></pre>

<hr>
<h2 id='raw_beta'>Raw beta (low level diversity component)</h2><span id='topic+raw_beta'></span>

<h3>Description</h3>

<p>Calculates the low-level diversity component necessary for calculating raw beta
diversity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raw_beta(meta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raw_beta_+3A_meta">meta</code></td>
<td>
<p>object of class <code>metacommunity</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Values generated from <code>raw_beta()</code> may be input into <code>subdiv()</code> and
<code>metadiv()</code> to calculate raw subcommunity and metacommunity beta
diversity.
</p>


<h3>Value</h3>

<p><code>raw_beta</code> returns an object of class <code>relativeentropy</code>
</p>


<h3>References</h3>

<p>R. Reeve, T. Leinster, C. Cobbold, J. Thompson, N. Brummitt,
S. Mitchell, and L. Matthews. 2016. How to partition diversity.
arXiv 1404.6520v3:1–9.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop &lt;- data.frame(a = c(1,3), b = c(1,1))
row.names(pop) &lt;- paste0("sp", 1:2)
pop &lt;- pop/sum(pop)
meta &lt;- metacommunity(pop)

# Calculate raw beta component
b &lt;- raw_beta(meta)
subdiv(b, 1)
metadiv(b, 1)

</code></pre>

<hr>
<h2 id='raw_gamma'>Gamma (low level diversity component)</h2><span id='topic+raw_gamma'></span>

<h3>Description</h3>

<p>Calculates the low-level diversity component necessary for calculating gamma
diversity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raw_gamma(meta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raw_gamma_+3A_meta">meta</code></td>
<td>
<p>object of class <code>metacommunity</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Values generated from <code>raw_gamma()</code> may be input into <code>subdiv()</code> and
<code>metadiv()</code> to calculate subcommunity and metacommunity gamma diversity.
</p>


<h3>Value</h3>

<p><code>raw_gamma</code> returns an object of class <code>powermean</code>
</p>


<h3>References</h3>

<p>R. Reeve, T. Leinster, C. Cobbold, J. Thompson, N. Brummitt,
S. Mitchell, and L. Matthews. 2016. How to partition diversity.
arXiv 1404.6520v3:1–9.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop &lt;- cbind.data.frame(A = c(1,1), B = c(2,0), C = c(3,1))
row.names(pop) &lt;- paste0("sp", 1:2)
pop &lt;- pop/sum(pop)
meta &lt;- metacommunity(pop)

# Calculate gamma component
g &lt;- raw_gamma(meta)
subdiv(g, 1)
metadiv(g, 1)

</code></pre>

<hr>
<h2 id='raw_meta_alpha'>Raw metacommunity alpha diversity</h2><span id='topic+raw_meta_alpha'></span>

<h3>Description</h3>

<p>Calculates similarity-sensitive raw metacommunity alpha diversity (the
naive-community metacommunity diversity). This measure may be calculated
for a series of orders, represented as a vector of <code>qs</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raw_meta_alpha(meta, qs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raw_meta_alpha_+3A_meta">meta</code></td>
<td>
<p>object of class <code>metacommunity</code></p>
</td></tr>
<tr><td><code id="raw_meta_alpha_+3A_qs">qs</code></td>
<td>
<p><code>vector</code> of mode <code>numeric</code> containing <em>q</em> values</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>raw_meta_alpha</code> returns a standard output of class <code>rdiv</code>
</p>


<h3>References</h3>

<p>R. Reeve, T. Leinster, C. Cobbold, J. Thompson, N. Brummitt,
S. Mitchell, and L. Matthews. 2016. How to partition diversity.
arXiv 1404.6520v3:1–9.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop &lt;- data.frame(a = c(1,3), b = c(1,1))
row.names(pop) &lt;- paste0("sp", 1:2)
pop &lt;- pop/sum(pop)
meta &lt;- metacommunity(pop)

# Calculate raw metacommunity alpha diversity
raw_meta_alpha(meta, 0:2)

</code></pre>

<hr>
<h2 id='raw_meta_beta'>Raw metacommunity beta diversity</h2><span id='topic+raw_meta_beta'></span>

<h3>Description</h3>

<p>Calculates similarity-sensitive raw metacommunity beta diversity (the
average distinctiveness of subcommunities). This  measure may be
calculated for a series of orders, represented as a vector of <code>qs</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raw_meta_beta(meta, qs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raw_meta_beta_+3A_meta">meta</code></td>
<td>
<p>object of class <code>metacommunity</code></p>
</td></tr>
<tr><td><code id="raw_meta_beta_+3A_qs">qs</code></td>
<td>
<p><code>vector</code> of mode <code>numeric</code> containing <em>q</em> values</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>raw_meta_beta</code> returns a standard output of class <code>rdiv</code>
</p>


<h3>References</h3>

<p>R. Reeve, T. Leinster, C. Cobbold, J. Thompson, N. Brummitt,
S. Mitchell, and L. Matthews. 2016. How to partition diversity.
arXiv 1404.6520v3:1–9.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop &lt;- data.frame(a = c(1,3), b = c(1,1))
row.names(pop) &lt;- paste0("sp", 1:2)
pop &lt;- pop/sum(pop)
meta &lt;- metacommunity(pop)

# Calculate raw metacommunity beta diversity
raw_meta_beta(meta, 0:2)

</code></pre>

<hr>
<h2 id='raw_meta_rho'>Raw metacommunity rho diversity</h2><span id='topic+raw_meta_rho'></span>

<h3>Description</h3>

<p>Calculates similarity-sensitive raw metacommunity rho diversity (the
average redundancy of subcommunities. This measure may be calculated
for a series of orders, represented as a vector of <code>qs</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raw_meta_rho(meta, qs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raw_meta_rho_+3A_meta">meta</code></td>
<td>
<p>object of class <code>metacommunity</code></p>
</td></tr>
<tr><td><code id="raw_meta_rho_+3A_qs">qs</code></td>
<td>
<p><code>vector</code> of mode <code>numeric</code> containing <em>q</em> values</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>raw_meta_rho</code> returns a standard output of class <code>rdiv</code>
</p>


<h3>References</h3>

<p>R. Reeve, T. Leinster, C. Cobbold, J. Thompson, N. Brummitt,
S. Mitchell, and L. Matthews. 2016. How to partition diversity.
arXiv 1404.6520v3:1–9.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop &lt;- data.frame(a = c(1,3), b = c(1,1))
row.names(pop) &lt;- paste0("sp", 1:2)
pop &lt;- pop/sum(pop)
meta &lt;- metacommunity(pop)

# Calculate metacommunity rho diversity
raw_meta_rho(meta, 0:2)

</code></pre>

<hr>
<h2 id='raw_rho'>Raw rho (low level diversity component)</h2><span id='topic+raw_rho'></span>

<h3>Description</h3>

<p>Calculates the low-level diversity component necessary for calculating raw rho
diversity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raw_rho(meta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raw_rho_+3A_meta">meta</code></td>
<td>
<p>object of class <code>metacommunity</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Values generated from <code>raw_rho()</code> may be input into <code>subdiv()</code> and
<code>metadiv()</code> to calculate raw subcommunity and metacommunity rho
diversity.
</p>


<h3>Value</h3>

<p><code>raw_rho</code> returns an object of class <code>powermean</code>
</p>


<h3>References</h3>

<p>R. Reeve, T. Leinster, C. Cobbold, J. Thompson, N. Brummitt,
S. Mitchell, and L. Matthews. 2016. How to partition diversity.
arXiv 1404.6520v3:1–9.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop &lt;- data.frame(a = c(1,3), b = c(1,1))
row.names(pop) &lt;- paste0("sp", 1:2)
pop &lt;- pop/sum(pop)
meta &lt;- metacommunity(pop)

# Calculate raw rho component
r &lt;- raw_rho(meta)
subdiv(r, 1)
metadiv(r, 1)

</code></pre>

<hr>
<h2 id='raw_sub_alpha'>Raw subcommunity alpha diversity</h2><span id='topic+raw_sub_alpha'></span>

<h3>Description</h3>

<p>Calculates similarity sensitive raw subcommunity alpha diversity (an
estimate of naive-community metacommunity diversity). This measure may be
calculated for a series of orders, represented as a vector of <code>qs</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raw_sub_alpha(meta, qs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raw_sub_alpha_+3A_meta">meta</code></td>
<td>
<p>object of class <code>metacommunity</code></p>
</td></tr>
<tr><td><code id="raw_sub_alpha_+3A_qs">qs</code></td>
<td>
<p><code>vector</code> of mode <code>numeric</code> containing <em>q</em> values</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>raw_sub_alpha</code> returns a standard output of class <code>rdiv</code>
</p>


<h3>References</h3>

<p>R. Reeve, T. Leinster, C. Cobbold, J. Thompson, N. Brummitt,
S. Mitchell, and L. Matthews. 2016. How to partition diversity.
arXiv 1404.6520v3:1–9.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop &lt;- data.frame(a = c(1,3), b = c(1,1))
row.names(pop) &lt;- paste0("sp", 1:2)
pop &lt;- pop/sum(pop)
meta &lt;- metacommunity(pop)

# Calculate raw subcommunity alpha diversity
raw_sub_alpha(meta, 0:2)

</code></pre>

<hr>
<h2 id='raw_sub_beta'>Raw subcommunity beta diversity</h2><span id='topic+raw_sub_beta'></span>

<h3>Description</h3>

<p>Calculates similarity-sensitive raw subcommunity beta diversity (the
distinctiveness of subcommunity <em>j</em>). This measure may be calculated
for a series of orders, represented as a vector of <code>qs</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raw_sub_beta(meta, qs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raw_sub_beta_+3A_meta">meta</code></td>
<td>
<p>object of class <code>metacommunity</code></p>
</td></tr>
<tr><td><code id="raw_sub_beta_+3A_qs">qs</code></td>
<td>
<p><code>vector</code> of mode <code>numeric</code> containing <em>q</em> values</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>raw_sub_beta</code> returns a standard output of class <code>rdiv</code>
</p>


<h3>References</h3>

<p>R. Reeve, T. Leinster, C. Cobbold, J. Thompson, N. Brummitt,
S. Mitchell, and L. Matthews. 2016. How to partition diversity.
arXiv 1404.6520v3:1–9.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop &lt;- data.frame(a = c(1,3), b = c(1,1))
row.names(pop) &lt;- paste0("sp", 1:2)
pop &lt;- pop/sum(pop)
meta &lt;- metacommunity(pop)

# Calculate raw subcommunity beta diversity
raw_sub_beta(meta, 0:2)

</code></pre>

<hr>
<h2 id='raw_sub_rho'>Raw subcommunity rho diversity</h2><span id='topic+raw_sub_rho'></span>

<h3>Description</h3>

<p>Calculates similarity-sensitive raw subcommunity rho diversity (the
redundancy of subcommunity <em>j</em>. This measure may be calculated for
a series of orders, represented as a vector of <code>qs</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raw_sub_rho(meta, qs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raw_sub_rho_+3A_meta">meta</code></td>
<td>
<p>object of class <code>metacommunity</code></p>
</td></tr>
<tr><td><code id="raw_sub_rho_+3A_qs">qs</code></td>
<td>
<p><code>vector</code> of mode <code>numeric</code> containing <em>q</em> values</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>raw_sub_rho</code> returns a standard output of class <code>rdiv</code>
</p>


<h3>References</h3>

<p>R. Reeve, T. Leinster, C. Cobbold, J. Thompson, N. Brummitt,
S. Mitchell, and L. Matthews. 2016. How to partition diversity.
arXiv 1404.6520v3:1–9.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop &lt;- data.frame(a = c(1,3), b = c(1,1))
row.names(pop) &lt;- paste0("sp", 1:2)
pop &lt;- pop/sum(pop)
meta &lt;- metacommunity(pop)

# Calculate raw subcommunity rho diversity
raw_sub_rho(meta, 0:2)

</code></pre>

<hr>
<h2 id='rdiversity-package'>rdiversity: diversity measurement in R</h2><span id='topic+rdiversity-package'></span><span id='topic+rdiversity'></span>

<h3>Description</h3>

<p><code>rdiversity</code> is an R package based around a framework for measuring and
partitioning biodiversity using similarity-sensitive diversity measures. It
provides functionality for measuring alpha, beta and gamma diversity of
metacommunities (<em>e.g.</em> ecosystems) and their constituent subcommunities,
where similarity may be defined as taxonomic, phenotypic, genetic, phylogenetic,
functional, and so on. It uses the diversity measures described in the arXiv
paper, '<em>How to partition diversity</em>'.
</p>


<h3>Details</h3>


<ul>
<li><p> For more information go to our GitHub page;
<a href="https://github.com/boydorr/rdiversity">https://github.com/boydorr/rdiversity</a>
</p>
</li>
<li><p> Please raise an issue if you find any problems;
<a href="https://github.com/boydorr/rdiversity/issues">https://github.com/boydorr/rdiversity/issues</a>
</p>
</li>
<li><p> This package is cross-validated against our Julia package; <a href="https://github.com/EcoJulia/Diversity.jl">https://github.com/EcoJulia/Diversity.jl</a>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Sonia Mitchell <br />
Richard Reeve &lt;richard.reeve@glasgow.ac.uk&gt; (maintainer)
</p>


<h3>References</h3>

<p>Reeve, R., T. Leinster, C. Cobbold, J. Thompson, N. Brummitt,
S. Mitchell, and L. Matthews. 2016. How to partition diversity. (<a href="https://arxiv.org/abs/1404.6520">https://arxiv.org/abs/1404.6520</a>)
</p>

<hr>
<h2 id='relativeentropy-class'>relativeentropy-class</h2><span id='topic+relativeentropy-class'></span>

<h3>Description</h3>

<p>Container for class <code>relativeentropy</code>.
</p>


<h3>Fields</h3>


<dl>
<dt><code>results</code></dt><dd><p><code>data.frame</code> containing rdiversity output</p>
</dd>
<dt><code>measure</code></dt><dd><p>object of class <code>character</code> naming the diversity
measure being calculated</p>
</dd>
<dt><code>type_abundance</code></dt><dd><p>two-dimensional <code>matrix</code> of mode <code>numeric</code>
with rows as types (species), columns as subcommunities, and each
element containing the relative abundance of types in each subcommunity
relative to the metacommunity as a whole. In the phylogenetic case, this
corresponds to the proportional abundance of historical species, which is
calculated from the proportional abundance of terminal taxa</p>
</dd>
<dt><code>ordinariness</code></dt><dd><p>two-dimensional <code>matrix</code> of mode <code>numeric</code>
with rows as types, columns as subcommunities, and elements containing the
ordinariness of types within subcommunities</p>
</dd>
<dt><code>subcommunity_weights</code></dt><dd><p><code>vector</code> of mode <code>numeric</code> containing
subcommunity weights</p>
</dd>
<dt><code>type_weights</code></dt><dd><p>two-dimensional <code>matrix</code> of mode <code>numeric</code>,
with rows as types, columns as subcommunities, and elements containing
weights of types within a subcommunity</p>
</dd>
<dt><code>dat_id</code></dt><dd><p>object of class <code>character</code> describing the class of
distance / similarity being used, e.g. &quot;naive&quot;, &quot;taxonomic&quot;, and so on</p>
</dd>
<dt><code>similarity_components</code></dt><dd><p>list containing the components necessary to
calculate similarity. This list is empty when <code>precompute_dist = TRUE</code>
when calculating distance. When a pairwise distance matrix is too large and
<code>precompute_dist = FALSE</code>, this list contains all the information
required to calculate pairwise distance between types</p>
</dd>
<dt><code>similarity_parameters</code></dt><dd><p>list containing parameters associated with
converting pairwise distances to similarities (the <code>dist2sim()</code>
arguments)</p>
</dd>
</dl>

<hr>
<h2 id='repartition'>Repartition metacommunity</h2><span id='topic+repartition'></span>

<h3>Description</h3>

<p>Randomly reshuffles the relative abundance of types (<em>e.g</em>. species) in
a metacommunity (whilst maintaining the relationship between the relative
abundance of a particular species across subcommunities). In the case of a
phylogenetic metacommunity, the relative abundance of terminal taxa are
randomly reshuffled and the relative abundance of types (historical species)
are calculated from the resulting partition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repartition(meta, new_partition)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="repartition_+3A_meta">meta</code></td>
<td>
<p>object of class <code>metacommunity</code>.</p>
</td></tr>
<tr><td><code id="repartition_+3A_new_partition">new_partition</code></td>
<td>
<p>two-dimensional <code>matrix</code> of mode <code>numeric</code>
with rows as types (species), columns as subcommunities, and each
element containing the relative abundance of types in each subcommunity
relative to the metacommunity as a whole. In the phylogenetic case, this
corresponds to the proportional abundance of terminal taxa. If this argument
is missing, all species / tips will be shuffled</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>repartition()</code> returns an object of class <code>metacommunity</code>
</p>

<hr>
<h2 id='saveAttributes'>saveAttributes</h2><span id='topic+saveAttributes'></span>

<h3>Description</h3>

<p>Helper function save Attributes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveAttributes(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saveAttributes_+3A_x">x</code></td>
<td>
<p>x</p>
</td></tr>
</table>

<hr>
<h2 id='similarity'>Generate similarity object</h2><span id='topic+similarity'></span><span id='topic+similarity+2Cmatrix+2Ccharacter-method'></span><span id='topic+similarity+2Cmatrix+2Cmissing-method'></span>

<h3>Description</h3>

<p>Container for class <code>similarity</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>similarity(similarity, dat_id)

## S4 method for signature 'matrix,character'
similarity(similarity, dat_id)

## S4 method for signature 'matrix,missing'
similarity(similarity, dat_id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="similarity_+3A_similarity">similarity</code></td>
<td>
<p>similarity matrix</p>
</td></tr>
<tr><td><code id="similarity_+3A_dat_id">dat_id</code></td>
<td>
<p>object of class <code>character</code> denoting the type of diversity
being calculated. This can be &quot;naive&quot;, &quot;genetic&quot;, &quot;taxonomic&quot;, and so on</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>similarity()</code> returns an object of class <code>similarity</code>.
</p>

<hr>
<h2 id='similarity-class'>similarity-class</h2><span id='topic+similarity-class'></span><span id='topic+show+2Csimilarity-method'></span>

<h3>Description</h3>

<p>Container for class <code>similarity</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'similarity'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="similarity-class_+3A_object">object</code></td>
<td>
<p>object of class <code>similarity</code></p>
</td></tr>
</table>


<h3>Fields</h3>


<dl>
<dt><code>similarity</code></dt><dd><p>two-dimensional <code>matrix</code> of mode <code>numeric</code>
with rows as types, columns as types, and elements containing the pairwise
similarity of types</p>
</dd>
<dt><code>dat_id</code></dt><dd><p>object of class <code>character</code> describing the class of
distance / similarity being used, e.g. &quot;naive&quot;, &quot;taxonomic&quot;, and so on</p>
</dd>
<dt><code>components</code></dt><dd><p>list containing the components necessary to calculate
similarity. This list is empty when <code>precompute_dist = TRUE</code> when
calculating distance. When a pairwise distance matrix is too large and
<code>precompute_dist = FALSE</code>, this list contains all the information
required to calculate pairwise distance between types</p>
</dd>
<dt><code>parameters</code></dt><dd><p>list containing parameters associated with
converting pairwise distances to similarities (the <code>dist2sim()</code>
arguments)</p>
</dd>
</dl>

<hr>
<h2 id='sub_gamma'>Subcommunity gamma diversity</h2><span id='topic+sub_gamma'></span>

<h3>Description</h3>

<p>Calculates similarity-sensitive subcommunity gamma diversity (the
contribution per individual toward metacommunity diversity). This
measure may be calculated for a series of orders, represented as a vector
of <code>qs</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sub_gamma(meta, qs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sub_gamma_+3A_meta">meta</code></td>
<td>
<p>object of class <code>metacommunity</code></p>
</td></tr>
<tr><td><code id="sub_gamma_+3A_qs">qs</code></td>
<td>
<p><code>vector</code> of mode <code>numeric</code> containing <em>q</em> values</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>sub_gamma</code> returns a standard output of class <code>rdiv</code>
</p>


<h3>References</h3>

<p>R. Reeve, T. Leinster, C. Cobbold, J. Thompson, N. Brummitt,
S. Mitchell, and L. Matthews. 2016. How to partition diversity.
arXiv 1404.6520v3:1–9.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop &lt;- data.frame(a = c(1,3), b = c(1,1))
row.names(pop) &lt;- paste0("sp", 1:2)
pop &lt;- pop/sum(pop)
meta &lt;- metacommunity(pop)

# Calculate subcommunity gamma diversity
sub_gamma(meta, 0:2)

</code></pre>

<hr>
<h2 id='subdiv'>Calculate subcommunity-level diversity</h2><span id='topic+subdiv'></span><span id='topic+subdiv+2Cpowermean-method'></span><span id='topic+subdiv+2Crelativeentropy-method'></span><span id='topic+subdiv+2Cmetacommunity-method'></span>

<h3>Description</h3>

<p>Generic function for calculating subcommunity-level diversity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subdiv(data, qs)

## S4 method for signature 'powermean'
subdiv(data, qs)

## S4 method for signature 'relativeentropy'
subdiv(data, qs)

## S4 method for signature 'metacommunity'
subdiv(data, qs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subdiv_+3A_data">data</code></td>
<td>
<p><code>matrix</code> of mode <code>numeric</code>; containing diversity
components</p>
</td></tr>
<tr><td><code id="subdiv_+3A_qs">qs</code></td>
<td>
<p><code>vector</code> of mode <code>numeric</code> containing <em>q</em> values</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>data</code> may be input as one of three different classes:
</p>

<ul>
<li><p><code>powermean</code>: raw or normalised metacommunity alpha, rho or gamma
diversity components; will calculate subcommunity-level raw or normalised
metacommunity alpha, rho or gamma diversity
</p>
</li>
<li><p><code>relativeentropy</code>: raw or normalised metacommunity beta
diversity components; will calculate subcommunity-level raw or normalised
metacommunity beta diversity
</p>
</li>
<li><p><code>metacommunity</code>: will calculate all subcommunity measures of
diversity
</p>
</li></ul>



<h3>Value</h3>

<p><code>subdiv()</code> returns a standard output of class <code>rdiv</code>
</p>


<h3>References</h3>

<p>Reeve, R., T. Leinster, C. Cobbold, J. Thompson, N. Brummitt,
S. Mitchell, and L. Matthews. 2016. How to partition diversity.
arXiv 1404.6520v3:1–9.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inddiv">inddiv</a></code> for type-level diversity and
<code><a href="#topic+metadiv">metadiv</a></code> for metacommunity-level diversity.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define metacommunity
pop &lt;- data.frame(a = c(1,3), b = c(1,1))
row.names(pop) &lt;- paste0("sp", 1:2)
pop &lt;- pop/sum(pop)
meta &lt;- metacommunity(pop)

# Calculate subcommunity gamma diversity (takes the power mean)
g &lt;- raw_gamma(meta)
subdiv(g, 0:2)

# Calculate subcommunity beta diversity (takes the relative entropy)
b &lt;- raw_beta(meta)
subdiv(b, 0:2)

# Calculate all measures of subcommunity diversity
subdiv(meta, 0:2)

</code></pre>

<hr>
<h2 id='summary.binary'>Summary method for binary number.</h2><span id='topic+summary.binary'></span>

<h3>Description</h3>

<p>This method provides information about the attributes of the binary number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'binary'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.binary_+3A_object">object</code></td>
<td>
<p>binary number.</p>
</td></tr>
<tr><td><code id="summary.binary_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Contains the following information:
</p>

<ul>
<li><p> Signedness : unsigned or signed
</p>
</li>
<li><p> Endianess : Big-Endian or Little-Endian
</p>
</li>
<li><p> value&lt;0 : negative or positve number
</p>
</li>
<li><p> Size[bit] : Size in bit
</p>
</li>
<li><p> Base10 : Decimal(Base10) number.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+print.binary">print.binary</a>
</p>

<hr>
<h2 id='switchEndianess'>Switch Endianess.</h2><span id='topic+switchEndianess'></span>

<h3>Description</h3>

<p>Switch little-endian to big-endian and vice versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>switchEndianess(x, stickyBits=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="switchEndianess_+3A_x">x</code></td>
<td>
<p>binary number. Any binary number.</p>
</td></tr>
<tr><td><code id="switchEndianess_+3A_stickybits">stickyBits</code></td>
<td>
<p>Bits wont change if set TRUE. Only the attribute will be switched.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>switch little-endian to big-endian and vice versa.
</p>


<h3>See Also</h3>

<p><a href="#topic+fillUpToByte">fillUpToByte</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.binary(c(1,1,0,0), logic=TRUE); print(x); summary(x);
y &lt;- rdiversity:::switchEndianess(x); print(y); summary(y);
y &lt;- rdiversity:::switchEndianess(x, stickyBits=TRUE); print(y); summary(y);
</code></pre>

<hr>
<h2 id='tax2dist'>Generate taxonomic distance matrix</h2><span id='topic+tax2dist'></span>

<h3>Description</h3>

<p>Calculates taxonomic distances between species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tax2dist(lookup, tax_distance, precompute_dist = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tax2dist_+3A_lookup">lookup</code></td>
<td>
<p><code>data.frame</code> with colnames corresponding to nested
taxonomic levels, e.g. c('Species', 'Genus', 'Family', 'Subclass')</p>
</td></tr>
<tr><td><code id="tax2dist_+3A_tax_distance">tax_distance</code></td>
<td>
<p><code>vector</code> with the distances attributed to
taxonomic levels defined in <code>lookup</code>. The highest distance is the
distance attributed to species that are not the same at any recorded
taxonomic level. e.g. c(Species = 0, Genus = 1, Family = 2, Subclass = 3,
Other = 4) from Shimatani.</p>
</td></tr>
<tr><td><code id="tax2dist_+3A_precompute_dist">precompute_dist</code></td>
<td>
<p>object of class <code>logical</code> or <code>numeric</code>.
When TRUE (by default) a distance matrix is generated and stored in slot
<code>distance</code>, when FALSE no distance matrix is generated, and when numeric
a distance matrix is generated until the number of species exceeds the
defined value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>tax2dist()</code> returns an object of class <code>distance</code>
containing a <code>matrix</code> of pairwise taxonomic distances
</p>


<h3>References</h3>

<p>Shimatani, K. 2001. On the measurement of species diversity
incorporating species differences. Oikos 93:135–147.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create Lookup table
Species &lt;- c("tenuifolium", "asterolepis", "simplex var.grandiflora", "simplex var.ochnacea")
Genus &lt;- c("Protium", "Quararibea", "Swartzia", "Swartzia")
Family &lt;- c("Burseraceae", "Bombacaceae", "Fabaceae", "Fabaceae")
Subclass &lt;- c("Sapindales", "Malvales", "Fabales", "Fabales")
lookup &lt;- cbind.data.frame(Species, Genus, Family, Subclass)

# Assign values for each level (Shimatani's taxonomic distance)
tax_distance &lt;- c(Species = 0, Genus = 1, Family = 2, Subclass = 3, Other = 4)

# Generate pairwise distances
distance &lt;- tax2dist(lookup, tax_distance)
similarity &lt;- dist2sim(distance, "linear")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
