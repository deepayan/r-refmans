<!DOCTYPE html><html><head><title>Help for package harmony</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {harmony}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#cell_lines'><p>List of metadata table and scaled PCs matrix</p></a></li>
<li><a href='#cell_lines_small'><p>Same as cell_lines but smaller (300 cells).</p></a></li>
<li><a href='#harmony'><p>Harmony: fast, accurate, and robust single cell integration.</p></a></li>
<li><a href='#harmony_options'><p>Set advanced options for RunHarmony</p></a></li>
<li><a href='#HarmonyMatrix'><p>A proxy call to <code>RunHarmony()</code>. Deprecated.</p></a></li>
<li><a href='#moe_ridge_get_betas'><p>Get beta Utility</p></a></li>
<li><a href='#pbmc.ctrl'><p>Gene expression data of control PBMC from Kang et al. 2017. This</p>
contains a sample of 1000 cells from that condition and is used for
the Seurat Vignette.</a></li>
<li><a href='#pbmc.stim'><p>Gene expression data of stimulated PBMC from Kang et al. 2017. This</p>
contains a sample of 1000 cells from that condition and is used for
the Seurat Vignette.</a></li>
<li><a href='#RunHarmony'><p>Generic function that runs the harmony algorithm on single-cell</p>
genomics cell embeddings.</a></li>
<li><a href='#RunHarmony.default'><p>This is the primary harmony interface.</p></a></li>
<li><a href='#RunHarmony.Seurat'><p>Applies harmony on a Seurat object cell embedding.</p></a></li>
<li><a href='#RunHarmony.SingleCellExperiment'><p>Applies harmony on PCA cell embeddings of a SingleCellExperiment.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Fast, Sensitive, and Accurate Integration of Single Cell Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of the Harmony algorithm for single cell integration, described in Korsunsky et al &lt;<a href="https://doi.org/10.1038%2Fs41592-019-0619-0">doi:10.1038/s41592-019-0619-0</a>&gt;. Package includes a standalone Harmony function and interfaces to external frameworks.</td>
</tr>
<tr>
<td>URL:</td>
<td>software.broadinstitute.org/harmony</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.5.0), Rcpp</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>gzip</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppProgress</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, cowplot, ggplot2, Matrix, methods, tibble, rlang,
RhpcBLASctl</td>
</tr>
<tr>
<td>Suggests:</td>
<td>SingleCellExperiment, Seurat (&ge; 4.1.1), testthat, knitr,
rmarkdown, ggthemes, ggrepel, patchwork, tidyverse, tidyr,
data.table</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-28 23:29:19 UTC; main</td>
</tr>
<tr>
<td>Author:</td>
<td>Ilya Korsunsky <a href="https://orcid.org/0000-0003-4848-3948"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut],
  Martin Hemberg <a href="https://orcid.org/0000-0001-8895-5239"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Nikolaos Patikas <a href="https://orcid.org/0000-0002-3978-0134"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, ctb],
  Hongcheng Yao <a href="https://orcid.org/0000-0002-0743-4835"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, ctb],
  Nghia Millard <a href="https://orcid.org/0000-0002-0518-7674"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Jean Fan <a href="https://orcid.org/0000-0002-0212-5451"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    ctb],
  Kamil Slowikowski <a href="https://orcid.org/0000-0002-2843-6370"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, ctb],
  Miles Smith [ctb],
  Soumya Raychaudhuri
    <a href="https://orcid.org/0000-0002-1901-8265"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ilya Korsunsky &lt;ilya.korsunsky@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-29 08:30:04 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>Pipe operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Value</h3>

<p>return value of rhs function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 5 %&gt;% sum(10)

</code></pre>

<hr>
<h2 id='cell_lines'>List of metadata table and scaled PCs matrix</h2><span id='topic+cell_lines'></span>

<h3>Description</h3>

<p>List of metadata table and scaled PCs matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cell_lines
</code></pre>


<h3>Format</h3>

<p>:
meta_data: data.table of 9478 rows with defining dataset and cell_type
scaled_pcs: data.table of 9478 rows (cells) and 20 columns (PCs)
</p>


<h3>Source</h3>

<p><a href="https://www.10xgenomics.com">https://www.10xgenomics.com</a>
</p>

<hr>
<h2 id='cell_lines_small'>Same as cell_lines but smaller (300 cells).</h2><span id='topic+cell_lines_small'></span>

<h3>Description</h3>

<p>Same as cell_lines but smaller (300 cells).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cell_lines_small
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.
</p>


<h3>Source</h3>

<p><a href="https://www.10xgenomics.com">https://www.10xgenomics.com</a>
</p>

<hr>
<h2 id='harmony'>Harmony: fast, accurate, and robust single cell integration.</h2><span id='topic+harmony'></span>

<h3>Description</h3>

<p>Algorithm for single cell integration.
</p>


<h3>Usage</h3>

<p>?RunHarmony to run Harmony on cell embeddings matrix, Seurat or
SingleCellExperiment objects.
</p>


<h3>Useful links</h3>


<ol>
<li><p> Report bugs at <a href="https://github.com/immunogenomics/harmony/issues">https://github.com/immunogenomics/harmony/issues</a>
</p>
</li>
<li><p> Read the manuscript
<a href="https://doi.org/10.1038/s41592-019-0619-0">doi:10.1038/s41592-019-0619-0</a>
</p>
</li></ol>


<hr>
<h2 id='harmony_options'>Set advanced options for RunHarmony</h2><span id='topic+harmony_options'></span>

<h3>Description</h3>

<p>Set advanced options for RunHarmony
</p>


<h3>Usage</h3>

<pre><code class='language-R'>harmony_options(
  alpha = 0.2,
  tau = 0,
  block.size = 0.05,
  max.iter.cluster = 20,
  epsilon.cluster = 0.001,
  epsilon.harmony = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="harmony_options_+3A_alpha">alpha</code></td>
<td>
<p>When setting lambda = NULL and use lambda estimation mode, 
lambda would be determined by the expected number of cells assuming 
idependece between batches and clusters. i.e., lambda = alpha * expected
number of cells, default 0.2 and alpha should be 0 &lt; alpha &lt; 1</p>
</td></tr>
<tr><td><code id="harmony_options_+3A_tau">tau</code></td>
<td>
<p>Protection against overclustering small datasets with 
large ones. 'tau' is the expected number of cells per cluster.</p>
</td></tr>
<tr><td><code id="harmony_options_+3A_block.size">block.size</code></td>
<td>
<p>What proportion of cells to update during clustering. 
Between 0 to 1, default 0.05. Larger values may be faster but less 
accurate.</p>
</td></tr>
<tr><td><code id="harmony_options_+3A_max.iter.cluster">max.iter.cluster</code></td>
<td>
<p>Maximum number of rounds to run clustering 
at each round of Harmony.</p>
</td></tr>
<tr><td><code id="harmony_options_+3A_epsilon.cluster">epsilon.cluster</code></td>
<td>
<p>Convergence tolerance for clustering round 
of Harmony. Set to -Inf to never stop early.</p>
</td></tr>
<tr><td><code id="harmony_options_+3A_epsilon.harmony">epsilon.harmony</code></td>
<td>
<p>Convergence tolerance for Harmony. Set to -Inf to
never stop early. When 'epsilon.harmony' is set to not NULL, then
user-supplied values of 'early_stop' is ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a list for '.options' argument of 'RunHarmony'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## If want to set lambda to be fixed to 1, do
## Not run: 
RunHarmony(data_meta, meta_data, vars_use,
              .options = harmony_options(lambda = c(1, 1)))

## End(Not run)

</code></pre>

<hr>
<h2 id='HarmonyMatrix'>A proxy call to <code><a href="#topic+RunHarmony">RunHarmony()</a></code>. Deprecated.</h2><span id='topic+HarmonyMatrix'></span>

<h3>Description</h3>

<p>Maintain name backwards compatibility with version 0 of
harmony. However, API is not backwards compatible with version
0. This function will be deprecated in later versions of Harmony.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HarmonyMatrix(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HarmonyMatrix_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+RunHarmony.default">RunHarmony.default</a></code>
</p>

<dl>
<dt><code>data_mat</code></dt><dd><p>Matrix of cell embeddings. Cells can be rows or
columns and will be inferred by the rows of meta_data.</p>
</dd>
<dt><code>meta_data</code></dt><dd><p>Either (1) Dataframe with variables to integrate
or (2) vector with labels.</p>
</dd>
<dt><code>vars_use</code></dt><dd><p>If meta_data is dataframe, this defined which
variable(s) to remove (character vector).</p>
</dd>
<dt><code>theta</code></dt><dd><p>Diversity clustering penalty parameter. Specify for
each variable in vars_use Default theta=2. theta=0 does not
encourage any diversity. Larger values of theta result in more
diverse clusters.</p>
</dd>
<dt><code>sigma</code></dt><dd><p>Width of soft kmeans clusters. Default
sigma=0.1. Sigma scales the distance from a cell to cluster
centroids. Larger values of sigma result in cells assigned to
more clusters. Smaller values of sigma make soft kmeans cluster
approach hard clustering.</p>
</dd>
<dt><code>lambda</code></dt><dd><p>Ridge regression penalty. Default lambda=1. Bigger
values protect against over correction. If several covariates
are specified, then lambda can also be a vector which needs to
be equal length with the number of variables to be
corrected. In this scenario, each covariate level group will be
assigned the scalars specified by the user. If set to NULL,
harmony will start lambda estimation mode to determine lambdas
automatically and try to minimize overcorrection (Use with caution still
in beta testing).</p>
</dd>
<dt><code>nclust</code></dt><dd><p>Number of clusters in model. nclust=1 equivalent to
simple linear regression.</p>
</dd>
<dt><code>max_iter</code></dt><dd><p>Maximum number of rounds to run Harmony. One round
of Harmony involves one clustering and one correction step.</p>
</dd>
<dt><code>early_stop</code></dt><dd><p>Enable early stopping for harmony. The
harmonization process will stop when the change of objective
function between corrections drops below 1e-4</p>
</dd>
<dt><code>ncores</code></dt><dd><p>Number of processors to be used for math operations
when optimized BLAS is available. If BLAS is not supporting
multithreaded then this option has no effect. By default,
ncore=1 which runs as a single-threaded process. Although
Harmony supports multiple cores, it is not optimized for
multithreading. Increase this number for large datasets iff
single-core performance is not adequate.</p>
</dd>
<dt><code>plot_convergence</code></dt><dd><p>Whether to print the convergence plot of
the clustering objective function. TRUE to plot, FALSE to
suppress. This can be useful for debugging.</p>
</dd>
<dt><code>return_object</code></dt><dd><p>(Advanced Usage) Whether to return the Harmony
object or only the corrected PCA embeddings.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>Whether to print progress messages. TRUE to print,
FALSE to suppress.</p>
</dd>
<dt><code>.options</code></dt><dd><p>Advanced parameters of RunHarmony. This must be the
result from a call to 'harmony_options'. See ?'harmony_options'
for more details.</p>
</dd>
</dl>
</td></tr>
</table>

<hr>
<h2 id='moe_ridge_get_betas'>Get beta Utility</h2><span id='topic+moe_ridge_get_betas'></span>

<h3>Description</h3>

<p>Utility function to get ridge regression coefficients from trained
Harmony object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moe_ridge_get_betas(harmonyObj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moe_ridge_get_betas_+3A_harmonyobj">harmonyObj</code></td>
<td>
<p>Trained harmony object. Get this by running 
RunHarmony function with return_object=TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns nothing, modifies object in place.
</p>

<hr>
<h2 id='pbmc.ctrl'>Gene expression data of control PBMC from Kang et al. 2017. This
contains a sample of 1000 cells from that condition and is used for
the Seurat Vignette.</h2><span id='topic+pbmc.ctrl'></span>

<h3>Description</h3>

<p>Gene expression data of control PBMC from Kang et al. 2017. This
contains a sample of 1000 cells from that condition and is used for
the Seurat Vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pbmc.ctrl
</code></pre>


<h3>Format</h3>

<p>An object of class <code>dgCMatrix</code> with 9015 rows and 1000 columns.
</p>


<h3>Source</h3>

<p><a href="https://doi.org/10.1038/nbt.4042">doi:10.1038/nbt.4042</a>
</p>

<hr>
<h2 id='pbmc.stim'>Gene expression data of stimulated PBMC from Kang et al. 2017. This
contains a sample of 1000 cells from that condition and is used for
the Seurat Vignette.</h2><span id='topic+pbmc.stim'></span>

<h3>Description</h3>

<p>Gene expression data of stimulated PBMC from Kang et al. 2017. This
contains a sample of 1000 cells from that condition and is used for
the Seurat Vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pbmc.stim
</code></pre>


<h3>Format</h3>

<p>An object of class <code>dgCMatrix</code> with 9015 rows and 1000 columns.
</p>


<h3>Source</h3>

<p><a href="https://doi.org/10.1038/nbt.4042">doi:10.1038/nbt.4042</a>
</p>

<hr>
<h2 id='RunHarmony'>Generic function that runs the harmony algorithm on single-cell
genomics cell embeddings.</h2><span id='topic+RunHarmony'></span>

<h3>Description</h3>

<p>RunHarmony is generic function that runs the main Harmony
algorithm. If working with single cell R objects, please refer to
the documentation of the appropriate generic API:
(<code><a href="#topic+RunHarmony.Seurat">RunHarmony.Seurat()</a></code> or <code><a href="#topic+RunHarmony.SingleCellExperiment">RunHarmony.SingleCellExperiment()</a></code>). If
users work with other forms of cell embeddings, the can pass them
directly to harmony using <code><a href="#topic+RunHarmony.default">RunHarmony.default()</a></code> API. All the
function arguments listed here are common in all RunHarmony
interfaces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RunHarmony(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RunHarmony_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+RunHarmony.default">RunHarmony.default</a></code>
</p>

<dl>
<dt><code>theta</code></dt><dd><p>Diversity clustering penalty parameter. Specify for
each variable in vars_use Default theta=2. theta=0 does not
encourage any diversity. Larger values of theta result in more
diverse clusters.</p>
</dd>
<dt><code>sigma</code></dt><dd><p>Width of soft kmeans clusters. Default
sigma=0.1. Sigma scales the distance from a cell to cluster
centroids. Larger values of sigma result in cells assigned to
more clusters. Smaller values of sigma make soft kmeans cluster
approach hard clustering.</p>
</dd>
<dt><code>lambda</code></dt><dd><p>Ridge regression penalty. Default lambda=1. Bigger
values protect against over correction. If several covariates
are specified, then lambda can also be a vector which needs to
be equal length with the number of variables to be
corrected. In this scenario, each covariate level group will be
assigned the scalars specified by the user. If set to NULL,
harmony will start lambda estimation mode to determine lambdas
automatically and try to minimize overcorrection (Use with caution still
in beta testing).</p>
</dd>
<dt><code>nclust</code></dt><dd><p>Number of clusters in model. nclust=1 equivalent to
simple linear regression.</p>
</dd>
<dt><code>max_iter</code></dt><dd><p>Maximum number of rounds to run Harmony. One round
of Harmony involves one clustering and one correction step.</p>
</dd>
<dt><code>early_stop</code></dt><dd><p>Enable early stopping for harmony. The
harmonization process will stop when the change of objective
function between corrections drops below 1e-4</p>
</dd>
<dt><code>ncores</code></dt><dd><p>Number of processors to be used for math operations
when optimized BLAS is available. If BLAS is not supporting
multithreaded then this option has no effect. By default,
ncore=1 which runs as a single-threaded process. Although
Harmony supports multiple cores, it is not optimized for
multithreading. Increase this number for large datasets iff
single-core performance is not adequate.</p>
</dd>
<dt><code>plot_convergence</code></dt><dd><p>Whether to print the convergence plot of
the clustering objective function. TRUE to plot, FALSE to
suppress. This can be useful for debugging.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>Whether to print progress messages. TRUE to print,
FALSE to suppress.</p>
</dd>
<dt><code>.options</code></dt><dd><p>Advanced parameters of RunHarmony. This must be the
result from a call to 'harmony_options'. See ?'harmony_options'
for more details.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>If used with single-cell objects, it will return the
updated single-sell object. For standalone operation, it
returns the corrected cell embeddings or the R6 harmony object
(see <code><a href="#topic+RunHarmony.default">RunHarmony.default()</a></code>).
</p>


<h3>See Also</h3>

<p>Other RunHarmony: 
<code><a href="#topic+RunHarmony.Seurat">RunHarmony.Seurat</a>()</code>,
<code><a href="#topic+RunHarmony.SingleCellExperiment">RunHarmony.SingleCellExperiment</a>()</code>,
<code><a href="#topic+RunHarmony.default">RunHarmony.default</a>()</code>
</p>

<hr>
<h2 id='RunHarmony.default'>This is the primary harmony interface.</h2><span id='topic+RunHarmony.default'></span>

<h3>Description</h3>

<p>Use this generic with a cell embeddings matrix, a metadata table
and a categorical covariate to run the Harmony algorithm directly
on cell embedding matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
RunHarmony(
  data_mat,
  meta_data,
  vars_use,
  theta = NULL,
  sigma = 0.1,
  lambda = 1,
  nclust = NULL,
  max_iter = 10,
  early_stop = TRUE,
  ncores = 1,
  plot_convergence = FALSE,
  return_object = FALSE,
  verbose = TRUE,
  .options = harmony_options(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RunHarmony.default_+3A_data_mat">data_mat</code></td>
<td>
<p>Matrix of cell embeddings. Cells can be rows or
columns and will be inferred by the rows of meta_data.</p>
</td></tr>
<tr><td><code id="RunHarmony.default_+3A_meta_data">meta_data</code></td>
<td>
<p>Either (1) Dataframe with variables to integrate
or (2) vector with labels.</p>
</td></tr>
<tr><td><code id="RunHarmony.default_+3A_vars_use">vars_use</code></td>
<td>
<p>If meta_data is dataframe, this defined which
variable(s) to remove (character vector).</p>
</td></tr>
<tr><td><code id="RunHarmony.default_+3A_theta">theta</code></td>
<td>
<p>Diversity clustering penalty parameter. Specify for
each variable in vars_use Default theta=2. theta=0 does not
encourage any diversity. Larger values of theta result in more
diverse clusters.</p>
</td></tr>
<tr><td><code id="RunHarmony.default_+3A_sigma">sigma</code></td>
<td>
<p>Width of soft kmeans clusters. Default
sigma=0.1. Sigma scales the distance from a cell to cluster
centroids. Larger values of sigma result in cells assigned to
more clusters. Smaller values of sigma make soft kmeans cluster
approach hard clustering.</p>
</td></tr>
<tr><td><code id="RunHarmony.default_+3A_lambda">lambda</code></td>
<td>
<p>Ridge regression penalty. Default lambda=1. Bigger
values protect against over correction. If several covariates
are specified, then lambda can also be a vector which needs to
be equal length with the number of variables to be
corrected. In this scenario, each covariate level group will be
assigned the scalars specified by the user. If set to NULL,
harmony will start lambda estimation mode to determine lambdas
automatically and try to minimize overcorrection (Use with caution still
in beta testing).</p>
</td></tr>
<tr><td><code id="RunHarmony.default_+3A_nclust">nclust</code></td>
<td>
<p>Number of clusters in model. nclust=1 equivalent to
simple linear regression.</p>
</td></tr>
<tr><td><code id="RunHarmony.default_+3A_max_iter">max_iter</code></td>
<td>
<p>Maximum number of rounds to run Harmony. One round
of Harmony involves one clustering and one correction step.</p>
</td></tr>
<tr><td><code id="RunHarmony.default_+3A_early_stop">early_stop</code></td>
<td>
<p>Enable early stopping for harmony. The
harmonization process will stop when the change of objective
function between corrections drops below 1e-4</p>
</td></tr>
<tr><td><code id="RunHarmony.default_+3A_ncores">ncores</code></td>
<td>
<p>Number of processors to be used for math operations
when optimized BLAS is available. If BLAS is not supporting
multithreaded then this option has no effect. By default,
ncore=1 which runs as a single-threaded process. Although
Harmony supports multiple cores, it is not optimized for
multithreading. Increase this number for large datasets iff
single-core performance is not adequate.</p>
</td></tr>
<tr><td><code id="RunHarmony.default_+3A_plot_convergence">plot_convergence</code></td>
<td>
<p>Whether to print the convergence plot of
the clustering objective function. TRUE to plot, FALSE to
suppress. This can be useful for debugging.</p>
</td></tr>
<tr><td><code id="RunHarmony.default_+3A_return_object">return_object</code></td>
<td>
<p>(Advanced Usage) Whether to return the Harmony
object or only the corrected PCA embeddings.</p>
</td></tr>
<tr><td><code id="RunHarmony.default_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print progress messages. TRUE to print,
FALSE to suppress.</p>
</td></tr>
<tr><td><code id="RunHarmony.default_+3A_.options">.options</code></td>
<td>
<p>Advanced parameters of RunHarmony. This must be the
result from a call to 'harmony_options'. See ?'harmony_options'
for more details.</p>
</td></tr>
<tr><td><code id="RunHarmony.default_+3A_...">...</code></td>
<td>
<p>other parameters that are not part of the API</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default, matrix with corrected PCA embeddings. If
return_object is TRUE, returns the full Harmony object (R6
reference class type).
</p>


<h3>See Also</h3>

<p>Other RunHarmony: 
<code><a href="#topic+RunHarmony.Seurat">RunHarmony.Seurat</a>()</code>,
<code><a href="#topic+RunHarmony.SingleCellExperiment">RunHarmony.SingleCellExperiment</a>()</code>,
<code><a href="#topic+RunHarmony">RunHarmony</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## By default, Harmony inputs a cell embedding matrix
## Not run: 
harmony_embeddings &lt;- RunHarmony(cell_embeddings, meta_data, 'dataset')

## End(Not run)

## If PCA is the input, the PCs need to be scaled
data(cell_lines_small)
pca_matrix &lt;- cell_lines_small$scaled_pcs
meta_data &lt;- cell_lines_small$meta_data
harmony_embeddings &lt;- RunHarmony(pca_matrix, meta_data, 'dataset')

## Output is a matrix of corrected PC embeddings
dim(harmony_embeddings)
harmony_embeddings[seq_len(5), seq_len(5)]

## Finally, we can return an object with all the underlying data structures
harmony_object &lt;- RunHarmony(pca_matrix, meta_data, 'dataset', return_object=TRUE)
dim(harmony_object$Y) ## cluster centroids
dim(harmony_object$R) ## soft cluster assignment
dim(harmony_object$Z_corr) ## corrected PCA embeddings
head(harmony_object$O) ## batch by cluster co-occurence matrix

</code></pre>

<hr>
<h2 id='RunHarmony.Seurat'>Applies harmony on a Seurat object cell embedding.</h2><span id='topic+RunHarmony.Seurat'></span>

<h3>Description</h3>

<p>Applies harmony on a Seurat object cell embedding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Seurat'
RunHarmony(
  object,
  group.by.vars,
  reduction.use = "pca",
  dims.use = NULL,
  reduction.save = "harmony",
  project.dim = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RunHarmony.Seurat_+3A_object">object</code></td>
<td>
<p>the Seurat object. It needs to have the appropriate slot
of cell embeddings precomputed.</p>
</td></tr>
<tr><td><code id="RunHarmony.Seurat_+3A_group.by.vars">group.by.vars</code></td>
<td>
<p>the name(s) of covariates that harmony will remove
its effect on the data.</p>
</td></tr>
<tr><td><code id="RunHarmony.Seurat_+3A_reduction.use">reduction.use</code></td>
<td>
<p>Name of dimension reduction to use. Default is pca.</p>
</td></tr>
<tr><td><code id="RunHarmony.Seurat_+3A_dims.use">dims.use</code></td>
<td>
<p>indices of the cell embedding features to be used</p>
</td></tr>
<tr><td><code id="RunHarmony.Seurat_+3A_reduction.save">reduction.save</code></td>
<td>
<p>the name of the new slot that is going to be created by
harmony. By default, harmony.</p>
</td></tr>
<tr><td><code id="RunHarmony.Seurat_+3A_project.dim">project.dim</code></td>
<td>
<p>Project dimension reduction loadings. Default TRUE.</p>
</td></tr>
<tr><td><code id="RunHarmony.Seurat_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+RunHarmony.default">RunHarmony.default</a></code>
</p>

<dl>
<dt><code>theta</code></dt><dd><p>Diversity clustering penalty parameter. Specify for
each variable in vars_use Default theta=2. theta=0 does not
encourage any diversity. Larger values of theta result in more
diverse clusters.</p>
</dd>
<dt><code>sigma</code></dt><dd><p>Width of soft kmeans clusters. Default
sigma=0.1. Sigma scales the distance from a cell to cluster
centroids. Larger values of sigma result in cells assigned to
more clusters. Smaller values of sigma make soft kmeans cluster
approach hard clustering.</p>
</dd>
<dt><code>lambda</code></dt><dd><p>Ridge regression penalty. Default lambda=1. Bigger
values protect against over correction. If several covariates
are specified, then lambda can also be a vector which needs to
be equal length with the number of variables to be
corrected. In this scenario, each covariate level group will be
assigned the scalars specified by the user. If set to NULL,
harmony will start lambda estimation mode to determine lambdas
automatically and try to minimize overcorrection (Use with caution still
in beta testing).</p>
</dd>
<dt><code>nclust</code></dt><dd><p>Number of clusters in model. nclust=1 equivalent to
simple linear regression.</p>
</dd>
<dt><code>max_iter</code></dt><dd><p>Maximum number of rounds to run Harmony. One round
of Harmony involves one clustering and one correction step.</p>
</dd>
<dt><code>early_stop</code></dt><dd><p>Enable early stopping for harmony. The
harmonization process will stop when the change of objective
function between corrections drops below 1e-4</p>
</dd>
<dt><code>ncores</code></dt><dd><p>Number of processors to be used for math operations
when optimized BLAS is available. If BLAS is not supporting
multithreaded then this option has no effect. By default,
ncore=1 which runs as a single-threaded process. Although
Harmony supports multiple cores, it is not optimized for
multithreading. Increase this number for large datasets iff
single-core performance is not adequate.</p>
</dd>
<dt><code>plot_convergence</code></dt><dd><p>Whether to print the convergence plot of
the clustering objective function. TRUE to plot, FALSE to
suppress. This can be useful for debugging.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>Whether to print progress messages. TRUE to print,
FALSE to suppress.</p>
</dd>
<dt><code>.options</code></dt><dd><p>Advanced parameters of RunHarmony. This must be the
result from a call to 'harmony_options'. See ?'harmony_options'
for more details.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>Seurat object. Harmony dimensions placed into a new slot in the Seurat
object according to the reduction.save. For downstream Seurat analyses,
use reduction='harmony'.
</p>


<h3>See Also</h3>

<p>Other RunHarmony: 
<code><a href="#topic+RunHarmony.SingleCellExperiment">RunHarmony.SingleCellExperiment</a>()</code>,
<code><a href="#topic+RunHarmony.default">RunHarmony.default</a>()</code>,
<code><a href="#topic+RunHarmony">RunHarmony</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## seu is a Seurat single-Cell R object
seu &lt;- RunHarmony(seu, "donor_id")

## End(Not run)
</code></pre>

<hr>
<h2 id='RunHarmony.SingleCellExperiment'>Applies harmony on PCA cell embeddings of a SingleCellExperiment.</h2><span id='topic+RunHarmony.SingleCellExperiment'></span>

<h3>Description</h3>

<p>Applies harmony on PCA cell embeddings of a SingleCellExperiment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SingleCellExperiment'
RunHarmony(
  object,
  group.by.vars,
  dims.use = NULL,
  verbose = TRUE,
  reduction.save = "HARMONY",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RunHarmony.SingleCellExperiment_+3A_object">object</code></td>
<td>
<p>SingleCellExperiment with the PCA reducedDim cell embeddings populated</p>
</td></tr>
<tr><td><code id="RunHarmony.SingleCellExperiment_+3A_group.by.vars">group.by.vars</code></td>
<td>
<p>the name(s) of covariates that harmony will remove
its effect on the data.</p>
</td></tr>
<tr><td><code id="RunHarmony.SingleCellExperiment_+3A_dims.use">dims.use</code></td>
<td>
<p>a vector of indices that allows only selected cell embeddings
features to be used.</p>
</td></tr>
<tr><td><code id="RunHarmony.SingleCellExperiment_+3A_verbose">verbose</code></td>
<td>
<p>enable verbosity</p>
</td></tr>
<tr><td><code id="RunHarmony.SingleCellExperiment_+3A_reduction.save">reduction.save</code></td>
<td>
<p>the name of the new slot that is going to be created by
harmony. By default, HARMONY.</p>
</td></tr>
<tr><td><code id="RunHarmony.SingleCellExperiment_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+RunHarmony.default">RunHarmony.default</a></code>
</p>

<dl>
<dt><code>theta</code></dt><dd><p>Diversity clustering penalty parameter. Specify for
each variable in vars_use Default theta=2. theta=0 does not
encourage any diversity. Larger values of theta result in more
diverse clusters.</p>
</dd>
<dt><code>sigma</code></dt><dd><p>Width of soft kmeans clusters. Default
sigma=0.1. Sigma scales the distance from a cell to cluster
centroids. Larger values of sigma result in cells assigned to
more clusters. Smaller values of sigma make soft kmeans cluster
approach hard clustering.</p>
</dd>
<dt><code>lambda</code></dt><dd><p>Ridge regression penalty. Default lambda=1. Bigger
values protect against over correction. If several covariates
are specified, then lambda can also be a vector which needs to
be equal length with the number of variables to be
corrected. In this scenario, each covariate level group will be
assigned the scalars specified by the user. If set to NULL,
harmony will start lambda estimation mode to determine lambdas
automatically and try to minimize overcorrection (Use with caution still
in beta testing).</p>
</dd>
<dt><code>nclust</code></dt><dd><p>Number of clusters in model. nclust=1 equivalent to
simple linear regression.</p>
</dd>
<dt><code>max_iter</code></dt><dd><p>Maximum number of rounds to run Harmony. One round
of Harmony involves one clustering and one correction step.</p>
</dd>
<dt><code>early_stop</code></dt><dd><p>Enable early stopping for harmony. The
harmonization process will stop when the change of objective
function between corrections drops below 1e-4</p>
</dd>
<dt><code>ncores</code></dt><dd><p>Number of processors to be used for math operations
when optimized BLAS is available. If BLAS is not supporting
multithreaded then this option has no effect. By default,
ncore=1 which runs as a single-threaded process. Although
Harmony supports multiple cores, it is not optimized for
multithreading. Increase this number for large datasets iff
single-core performance is not adequate.</p>
</dd>
<dt><code>plot_convergence</code></dt><dd><p>Whether to print the convergence plot of
the clustering objective function. TRUE to plot, FALSE to
suppress. This can be useful for debugging.</p>
</dd>
<dt><code>.options</code></dt><dd><p>Advanced parameters of RunHarmony. This must be the
result from a call to 'harmony_options'. See ?'harmony_options'
for more details.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>SingleCellExperiment object. After running RunHarmony, the corrected
cell embeddings can be accessed with reducedDim(object, &quot;Harmony&quot;).
</p>


<h3>See Also</h3>

<p>Other RunHarmony: 
<code><a href="#topic+RunHarmony.Seurat">RunHarmony.Seurat</a>()</code>,
<code><a href="#topic+RunHarmony.default">RunHarmony.default</a>()</code>,
<code><a href="#topic+RunHarmony">RunHarmony</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## sce is a SingleCellExperiment R object
sce &lt;- RunHarmony(sce, "donor_id")

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
