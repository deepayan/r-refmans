<!DOCTYPE html><html><head><title>Help for package GpGp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GpGp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#GpGp'><p>GpGp: Fast Gaussian Process Computing.</p></a></li>
<li><a href='#argo2016'><p>Ocean temperatures from Argo profiling floats</p></a></li>
<li><a href='#cond_sim'><p>Conditional Simulation using Vecchia's approximation</p></a></li>
<li><a href='#condition_number'><p>compute condition number of matrix</p></a></li>
<li><a href='#expit'><p>expit function and integral of expit function</p></a></li>
<li><a href='#exponential_anisotropic2D'><p>Geometrically anisotropic exponential covariance function (two dimensions)</p></a></li>
<li><a href='#exponential_anisotropic3D'><p>Geometrically anisotropic exponential covariance function (three dimensions)</p></a></li>
<li><a href='#exponential_anisotropic3D_alt'><p>Geometrically anisotropic exponential covariance function (three dimensions, alternate parameterization)</p></a></li>
<li><a href='#exponential_isotropic'><p>Isotropic exponential covariance function</p></a></li>
<li><a href='#exponential_nonstat_var'><p>Isotropic exponential covariance function, nonstationary variances</p></a></li>
<li><a href='#exponential_scaledim'><p>Exponential covariance function, different range parameter for each dimension</p></a></li>
<li><a href='#exponential_spacetime'><p>Spatial-Temporal exponential covariance function</p></a></li>
<li><a href='#exponential_sphere'><p>Isotropic exponential covariance function on sphere</p></a></li>
<li><a href='#exponential_sphere_warp'><p>Deformed exponential covariance function on sphere</p></a></li>
<li><a href='#exponential_spheretime'><p>Exponential covariance function on sphere x time</p></a></li>
<li><a href='#exponential_spheretime_warp'><p>Deformed exponential covariance function on sphere</p></a></li>
<li><a href='#fast_Gp_sim'><p>Approximate GP simulation</p></a></li>
<li><a href='#fast_Gp_sim_Linv'><p>Approximate GP simulation with specified Linverse</p></a></li>
<li><a href='#find_ordered_nn'><p>Find ordered nearest neighbors.</p></a></li>
<li><a href='#find_ordered_nn_brute'><p>Naive brute force nearest neighbor finder</p></a></li>
<li><a href='#fisher_scoring'><p>Fisher scoring algorithm</p></a></li>
<li><a href='#fit_model'><p>Estimate mean and covariance parameters</p></a></li>
<li><a href='#get_linkfun'><p>get link function, whether locations are lonlat and space time</p></a></li>
<li><a href='#get_penalty'><p>get penalty function</p></a></li>
<li><a href='#get_start_parms'><p>get default starting values of covariance parameters</p></a></li>
<li><a href='#group_obs'><p>Automatic grouping (partitioning) of locations</p></a></li>
<li><a href='#jason3'><p>Windspeed measurements from Jason-3 Satellite</p></a></li>
<li><a href='#L_mult'><p>Multiply approximate Cholesky by a vector</p></a></li>
<li><a href='#L_t_mult'><p>Multiply transpose of approximate Cholesky by a vector</p></a></li>
<li><a href='#Linv_mult'><p>Multiply approximate inverse Cholesky by a vector</p></a></li>
<li><a href='#Linv_t_mult'><p>Multiply transpose of approximate inverse Cholesky by a vector</p></a></li>
<li><a href='#matern_anisotropic2D'><p>Geometrically anisotropic Matern covariance function (two dimensions)</p></a></li>
<li><a href='#matern_anisotropic3D'><p>Geometrically anisotropic Matern covariance function (three dimensions)</p></a></li>
<li><a href='#matern_anisotropic3D_alt'><p>Geometrically anisotropic Matern covariance function (three dimensions, alternate parameterization)</p></a></li>
<li><a href='#matern_categorical'><p>Isotropic Matern covariance function with random effects for categories</p></a></li>
<li><a href='#matern_isotropic'><p>Isotropic Matern covariance function</p></a></li>
<li><a href='#matern_nonstat_var'><p>Isotropic Matern covariance function, nonstationary variances</p></a></li>
<li><a href='#matern_scaledim'><p>Matern covariance function, different range parameter for each dimension</p></a></li>
<li><a href='#matern_spacetime'><p>Spatial-Temporal Matern covariance function</p></a></li>
<li><a href='#matern_spacetime_categorical'><p>Space-Time Matern covariance function with random effects for categories</p></a></li>
<li><a href='#matern_spacetime_categorical_local'><p>Space-Time Matern covariance function with local random effects for categories</p></a></li>
<li><a href='#matern_sphere'><p>Isotropic Matern covariance function on sphere</p></a></li>
<li><a href='#matern_sphere_warp'><p>Deformed Matern covariance function on sphere</p></a></li>
<li><a href='#matern_spheretime'><p>Matern covariance function on sphere x time</p></a></li>
<li><a href='#matern_spheretime_warp'><p>Deformed Matern covariance function on sphere</p></a></li>
<li><a href='#matern15_isotropic'><p>Isotropic Matern covariance function, smoothness = 1.5</p></a></li>
<li><a href='#matern15_scaledim'><p>Matern covariance function, smoothess = 1.5, different range parameter for each dimension</p></a></li>
<li><a href='#matern25_isotropic'><p>Isotropic Matern covariance function, smoothness = 2.5</p></a></li>
<li><a href='#matern25_scaledim'><p>Matern covariance function, smoothess = 2.5, different range parameter for each dimension</p></a></li>
<li><a href='#matern35_isotropic'><p>Isotropic Matern covariance function, smoothness = 3.5</p></a></li>
<li><a href='#matern35_scaledim'><p>Matern covariance function, smoothess = 3.5, different range parameter for each dimension</p></a></li>
<li><a href='#matern45_isotropic'><p>Isotropic Matern covariance function, smoothness = 4.5</p></a></li>
<li><a href='#matern45_scaledim'><p>Matern covariance function, smoothess = 3.5, different range parameter for each dimension</p></a></li>
<li><a href='#order_coordinate'><p>Sorted coordinate ordering</p></a></li>
<li><a href='#order_dist_to_point'><p>Distance to specified point ordering</p></a></li>
<li><a href='#order_maxmin'><p>Maximum minimum distance ordering</p></a></li>
<li><a href='#order_middleout'><p>Middle-out ordering</p></a></li>
<li><a href='#pen_hi'><p>penalize large values of parameter: penalty, 1st deriative, 2nd derivative</p></a></li>
<li><a href='#pen_lo'><p>penalize small values of parameter: penalty, 1st deriative, 2nd derivative</p></a></li>
<li><a href='#pen_loglo'><p>penalize small values of log parameter: penalty, 1st deriative, 2nd derivative</p></a></li>
<li><a href='#predictions'><p>Compute Gaussian process predictions using Vecchia's approximations</p></a></li>
<li><a href='#sph_grad_xyz'><p>compute gradient of spherical harmonics functions</p></a></li>
<li><a href='#summary.GpGp_fit'><p>Print summary of GpGp fit</p></a></li>
<li><a href='#test_likelihood_object'><p>test likelihood object for NA or Inf values</p></a></li>
<li><a href='#vecchia_grouped_meanzero_loglik'><p>Grouped Vecchia approximation to the Gaussian loglikelihood, zero mean</p></a></li>
<li><a href='#vecchia_grouped_profbeta_loglik'><p>Grouped Vecchia approximation, profiled regression coefficients</p></a></li>
<li><a href='#vecchia_grouped_profbeta_loglik_grad_info'><p>Grouped Vecchia loglikelihood, gradient, Fisher information</p></a></li>
<li><a href='#vecchia_Linv'><p>Entries of inverse Cholesky approximation</p></a></li>
<li><a href='#vecchia_meanzero_loglik'><p>Vecchia's approximation to the Gaussian loglikelihood, zero mean</p></a></li>
<li><a href='#vecchia_profbeta_loglik'><p>Vecchia's approximation to the Gaussian loglikelihood, with profiled</p>
regression coefficients.</a></li>
<li><a href='#vecchia_profbeta_loglik_grad_info'><p>Vecchia's loglikelihood, gradient, and Fisher information</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fast Gaussian Process Computation Using Vecchia's Approximation</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-17</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joseph Guinness &lt;joeguinness@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for fitting and doing predictions with
    Gaussian process models using Vecchia's (1988) approximation. 
    Package also includes functions for reordering input locations, 
    finding ordered nearest neighbors (with help from 'FNN' package), 
    grouping operations, and conditional simulations.
    Covariance functions for spatial and spatial-temporal data
    on Euclidean domains and spheres are provided. The original 
    approximation is due to Vecchia (1988) 
    <a href="http://www.jstor.org/stable/2345768">http://www.jstor.org/stable/2345768</a>, and the reordering and
    grouping methods are from Guinness (2018) 
    &lt;<a href="https://doi.org/10.1080%2F00401706.2018.1437476">doi:10.1080/00401706.2018.1437476</a>&gt;.
    Model fitting employs a Fisher scoring algorithm described
    in Guinness (2019) &lt;<a href="https://doi.org/10.48550/arXiv.1905.08374">doi:10.48550/arXiv.1905.08374</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.13), FNN</td>
</tr>
<tr>
<td>Suggests:</td>
<td>fields, knitr, rmarkdown, testthat, maps</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, BH</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.0</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-18 00:31:41 UTC; joe</td>
</tr>
<tr>
<td>Author:</td>
<td>Joseph Guinness [aut, cre],
  Matthias Katzfuss [aut],
  Youssef Fahmy [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-18 23:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='GpGp'>GpGp: Fast Gaussian Process Computing.</h2><span id='topic+GpGp'></span><span id='topic+GpGp-package'></span>

<h3>Description</h3>

<p>Vecchia's (1988)
Gaussian process approximation has emerged among its competitors
as a leader in computational scalability and accuracy. This package includes
implementations of the original approximation, as well as several
updates to it, including the reordered and grouped versions of the 
approximation outlined in Guinness (2018) and the Fisher scoring algorithm
described in Guinness (2019). The package supports spatial
models, spatial-temporal models, models on spheres, and some nonstationary models.
</p>


<h3>Details</h3>

<p>The main functions of the package are <code><a href="#topic+fit_model">fit_model</a></code>, 
and <code><a href="#topic+predictions">predictions</a></code>.
<code><a href="#topic+fit_model">fit_model</a></code> returns estimates of covariance parameters
and linear mean parameters. The user is expected to select a covariance function
and specify it with a string. Currently supported covariance functions are 
</p>

<ul>
<li> <p><code><a href="#topic+matern_isotropic">matern_isotropic</a></code>
</p>
</li>
<li> <p><code><a href="#topic+exponential_isotropic">exponential_isotropic</a></code>
</p>
</li>
<li> <p><code><a href="#topic+matern_anisotropic2D">matern_anisotropic2D</a></code>
</p>
</li>
<li> <p><code><a href="#topic+exponential_anisotropic2D">exponential_anisotropic2D</a></code>
</p>
</li>
<li> <p><code><a href="#topic+matern_anisotropic3D">matern_anisotropic3D</a></code>
</p>
</li>
<li> <p><code><a href="#topic+exponential_anisotropic3D">exponential_anisotropic3D</a></code>
</p>
</li>
<li> <p><code><a href="#topic+matern_anisotropic3D_alt">matern_anisotropic3D_alt</a></code>
</p>
</li>
<li> <p><code><a href="#topic+matern15_isotropic">matern15_isotropic</a></code>
</p>
</li>
<li> <p><code><a href="#topic+matern25_isotropic">matern25_isotropic</a></code>
</p>
</li>
<li> <p><code><a href="#topic+matern35_isotropic">matern35_isotropic</a></code>
</p>
</li>
<li> <p><code><a href="#topic+matern45_isotropic">matern45_isotropic</a></code>
</p>
</li>
<li> <p><code><a href="#topic+matern_scaledim">matern_scaledim</a></code>
</p>
</li>
<li> <p><code><a href="#topic+exponential_scaledim">exponential_scaledim</a></code>
</p>
</li>
<li> <p><code><a href="#topic+matern15_scaledim">matern15_scaledim</a></code>
</p>
</li>
<li> <p><code><a href="#topic+matern25_scaledim">matern25_scaledim</a></code>
</p>
</li>
<li> <p><code><a href="#topic+matern35_scaledim">matern35_scaledim</a></code>
</p>
</li>
<li> <p><code><a href="#topic+matern45_scaledim">matern45_scaledim</a></code>
</p>
</li>
<li> <p><code><a href="#topic+matern_spacetime">matern_spacetime</a></code>
</p>
</li>
<li> <p><code><a href="#topic+exponential_spacetime">exponential_spacetime</a></code>
</p>
</li>
<li> <p><code><a href="#topic+matern_nonstat_var">matern_nonstat_var</a></code>
</p>
</li>
<li> <p><code><a href="#topic+exponential_nonstat_var">exponential_nonstat_var</a></code>
</p>
</li>
<li> <p><code><a href="#topic+matern_sphere">matern_sphere</a></code>
</p>
</li>
<li> <p><code><a href="#topic+exponential_sphere">exponential_sphere</a></code>
</p>
</li>
<li> <p><code><a href="#topic+matern_spheretime">matern_spheretime</a></code>
</p>
</li>
<li> <p><code><a href="#topic+exponential_spheretime">exponential_spheretime</a></code>
</p>
</li>
<li> <p><code><a href="#topic+matern_sphere_warp">matern_sphere_warp</a></code>
</p>
</li>
<li> <p><code><a href="#topic+exponential_sphere_warp">exponential_sphere_warp</a></code>
</p>
</li>
<li> <p><code><a href="#topic+matern_spheretime_warp">matern_spheretime_warp</a></code>
</p>
</li>
<li> <p><code><a href="#topic+exponential_spheretime_warp">exponential_spheretime_warp</a></code>
</p>
</li></ul>

<p>If there are 
covariates, they can be expressed via a design matrix <code>X</code>, each row containing
the covariates corresponding to the same row in <code>locs</code>. 
</p>
<p>For <code><a href="#topic+predictions">predictions</a></code>, the user should specify prediction locations 
<code>locs_pred</code> and a prediction design matrix <code>X_pred</code>.
</p>
<p>The vignettes are intended to be helpful for getting a sense of how 
these functions work. 
</p>
<p>For Gaussian process researchers, the package also provides access to functions for
computing the likelihood, gradient, and Fisher information with respect
to covariance parameters; reordering functions, nearest neighbor-finding 
functions, grouping (partitioning) functions, and approximate simulation functions.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Joseph Guinness <a href="mailto:joeguinness@gmail.com">joeguinness@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Matthias Katzfuss <a href="mailto:katzfuss@gmail.com">katzfuss@gmail.com</a>
</p>
</li>
<li><p> Youssef Fahmy <a href="mailto:yf297@cornell.edu">yf297@cornell.edu</a>
</p>
</li></ul>


<hr>
<h2 id='argo2016'>Ocean temperatures from Argo profiling floats</h2><span id='topic+argo2016'></span>

<h3>Description</h3>

<p>A dataset containing ocean temperature measurements from
three pressure levels (depths), measured by profiling
floats from the Argo program. Data collected in Jan, Feb,
and March of 2016.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>argo2016
</code></pre>


<h3>Format</h3>

<p>A data frame with 32436 rows and 6 columns
</p>

<dl>
<dt>lon</dt><dd><p>longitude in degrees between 0 and 360</p>
</dd>
<dt>lat</dt><dd><p>latitude in degrees between -90 and 90</p>
</dd>
<dt>day</dt><dd><p>time in days</p>
</dd>
<dt>temp100</dt><dd><p>Temperature at 100 dbars (roughly 100 meters)</p>
</dd>
<dt>temp150</dt><dd><p>Temperature at 150 dbars (roughly 150 meters)</p>
</dd>
<dt>temp200</dt><dd><p>Temperature at 200 dbars (roughly 200 meters)</p>
</dd>
</dl>



<h3>Source</h3>

<p>Mikael Kuusela. Argo program: <a href="https://argo.ucsd.edu/">https://argo.ucsd.edu/</a>
</p>

<hr>
<h2 id='cond_sim'>Conditional Simulation using Vecchia's approximation</h2><span id='topic+cond_sim'></span>

<h3>Description</h3>

<p>With the prediction locations ordered after the observation locations,
an approximation for the inverse Cholesky of the covariance matrix
is computed, and standard formulas are applied to obtain
a conditional simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cond_sim(
  fit = NULL,
  locs_pred,
  X_pred,
  y_obs = fit$y,
  locs_obs = fit$locs,
  X_obs = fit$X,
  beta = fit$betahat,
  covparms = fit$covparms,
  covfun_name = fit$covfun_name,
  m = 60,
  reorder = TRUE,
  st_scale = NULL,
  nsims = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cond_sim_+3A_fit">fit</code></td>
<td>
<p>GpGp_fit object, the result of <code><a href="#topic+fit_model">fit_model</a></code></p>
</td></tr>
<tr><td><code id="cond_sim_+3A_locs_pred">locs_pred</code></td>
<td>
<p>prediction locations</p>
</td></tr>
<tr><td><code id="cond_sim_+3A_x_pred">X_pred</code></td>
<td>
<p>Design matrix for predictions</p>
</td></tr>
<tr><td><code id="cond_sim_+3A_y_obs">y_obs</code></td>
<td>
<p>Observations associated with locs_obs</p>
</td></tr>
<tr><td><code id="cond_sim_+3A_locs_obs">locs_obs</code></td>
<td>
<p>observation locations</p>
</td></tr>
<tr><td><code id="cond_sim_+3A_x_obs">X_obs</code></td>
<td>
<p>Design matrix for observations</p>
</td></tr>
<tr><td><code id="cond_sim_+3A_beta">beta</code></td>
<td>
<p>Linear mean parameters</p>
</td></tr>
<tr><td><code id="cond_sim_+3A_covparms">covparms</code></td>
<td>
<p>Covariance parameters</p>
</td></tr>
<tr><td><code id="cond_sim_+3A_covfun_name">covfun_name</code></td>
<td>
<p>Name of covariance function</p>
</td></tr>
<tr><td><code id="cond_sim_+3A_m">m</code></td>
<td>
<p>Number of nearest neighbors to use. Larger <code>m</code> gives
better approximations.</p>
</td></tr>
<tr><td><code id="cond_sim_+3A_reorder">reorder</code></td>
<td>
<p>TRUE/FALSE for whether reordering should be done. This should
generally be kept at TRUE, unless testing out the effect of
reordering.</p>
</td></tr>
<tr><td><code id="cond_sim_+3A_st_scale">st_scale</code></td>
<td>
<p>amount by which to scale the spatial and temporal
dimensions for the purpose of selecting neighbors. We recommend setting
this manually when using a spatial-temporal covariance function. When 
<code>lonlat = TRUE</code>, spatial scale is in radians (earth radius = 1).</p>
</td></tr>
<tr><td><code id="cond_sim_+3A_nsims">nsims</code></td>
<td>
<p>Number of conditional simulations to return.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We can specify either a GpGp_fit object (the result of 
<code><a href="#topic+fit_model">fit_model</a></code>), OR manually enter the covariance function and
parameters, the observations, observation locations, and design matrix. We 
must specify the prediction locations and the prediction design matrix.
</p>

<hr>
<h2 id='condition_number'>compute condition number of matrix</h2><span id='topic+condition_number'></span>

<h3>Description</h3>

<p>compute condition number of matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>condition_number(info)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="condition_number_+3A_info">info</code></td>
<td>
<p>matrix</p>
</td></tr>
</table>

<hr>
<h2 id='expit'>expit function and integral of expit function</h2><span id='topic+expit'></span><span id='topic+intexpit'></span>

<h3>Description</h3>

<p>expit function and integral of expit function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expit(x)

intexpit(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expit_+3A_x">x</code></td>
<td>
<p>argument to expit or intexpit function</p>
</td></tr>
</table>

<hr>
<h2 id='exponential_anisotropic2D'>Geometrically anisotropic exponential covariance function (two dimensions)</h2><span id='topic+exponential_anisotropic2D'></span><span id='topic+d_exponential_anisotropic2D'></span>

<h3>Description</h3>

<p>From a matrix of locations and covariance parameters of the form
(variance, L11, L21, L22, nugget), return the square matrix of
all pairwise covariances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exponential_anisotropic2D(covparms, locs)

d_exponential_anisotropic2D(covparms, locs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exponential_anisotropic2D_+3A_covparms">covparms</code></td>
<td>
<p>A vector with covariance parameters
in the form (variance, L11, L21, L22, nugget)</p>
</td></tr>
<tr><td><code id="exponential_anisotropic2D_+3A_locs">locs</code></td>
<td>
<p>A matrix with <code>n</code> rows and <code>2</code> columns.
Each row of locs is a point in R^2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>n</code> rows and <code>n</code> columns, with the i,j entry
containing the covariance between observations at <code>locs[i,]</code> and
<code>locs[j,]</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>d_exponential_anisotropic2D()</code>: Derivatives of anisotropic exponential covariance
</p>
</li></ul>


<h3>Parameterization</h3>

<p>The covariance parameter vector is (variance, L11, L21, L22, nugget)
where L11, L21, L22, are the three non-zero entries of a lower-triangular
matrix L. The covariances are 
</p>
<p style="text-align: center;"><code class="reqn"> M(x,y) = \sigma^2 exp(-|| L x - L y || ) </code>
</p>

<p>This means that L11 is interpreted as an inverse range parameter in the
first dimension.
The nugget value <code class="reqn"> \sigma^2 \tau^2 </code> is added to the diagonal of the covariance matrix.
NOTE: the nugget is <code class="reqn"> \sigma^2 \tau^2 </code>, not <code class="reqn"> \tau^2 </code>.
</p>

<hr>
<h2 id='exponential_anisotropic3D'>Geometrically anisotropic exponential covariance function (three dimensions)</h2><span id='topic+exponential_anisotropic3D'></span><span id='topic+d_exponential_anisotropic3D'></span>

<h3>Description</h3>

<p>From a matrix of locations and covariance parameters of the form
(variance, L11, L21, L22, L31, L32, L33, nugget), return the square matrix of
all pairwise covariances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exponential_anisotropic3D(covparms, locs)

d_exponential_anisotropic3D(covparms, locs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exponential_anisotropic3D_+3A_covparms">covparms</code></td>
<td>
<p>A vector with covariance parameters
in the form (variance, L11, L21, L22, L31, L32, L33, nugget)</p>
</td></tr>
<tr><td><code id="exponential_anisotropic3D_+3A_locs">locs</code></td>
<td>
<p>A matrix with <code>n</code> rows and <code>3</code> columns.
Each row of locs is a point in R^3.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>n</code> rows and <code>n</code> columns, with the i,j entry
containing the covariance between observations at <code>locs[i,]</code> and
<code>locs[j,]</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>d_exponential_anisotropic3D()</code>: Derivatives of anisotropic exponential covariance
</p>
</li></ul>


<h3>Parameterization</h3>

<p>The covariance parameter vector is (variance, L11, L21, L22, L31, L32, L33, nugget)
where L11, L21, L22, L31, L32, L33 are the six non-zero entries of a lower-triangular
matrix L. The covariances are 
</p>
<p style="text-align: center;"><code class="reqn"> M(x,y) = \sigma^2 exp(-|| L x - L y || ) </code>
</p>

<p>This means that L11 is interpreted as an inverse range parameter in the
first dimension.
The nugget value <code class="reqn"> \sigma^2 \tau^2 </code> is added to the diagonal of the covariance matrix.
NOTE: the nugget is <code class="reqn"> \sigma^2 \tau^2 </code>, not <code class="reqn"> \tau^2 </code>.
</p>

<hr>
<h2 id='exponential_anisotropic3D_alt'>Geometrically anisotropic exponential covariance function (three dimensions, alternate parameterization)</h2><span id='topic+exponential_anisotropic3D_alt'></span><span id='topic+d_exponential_anisotropic3D_alt'></span>

<h3>Description</h3>

<p>From a matrix of locations and covariance parameters of the form
(variance, B11, B12, B13, B22, B23, B33, smoothness, nugget), return the square matrix of
all pairwise covariances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exponential_anisotropic3D_alt(covparms, locs)

d_exponential_anisotropic3D_alt(covparms, locs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exponential_anisotropic3D_alt_+3A_covparms">covparms</code></td>
<td>
<p>A vector with covariance parameters
in the form (variance, B11, B12, B13, B22, B23, B33, smoothness, nugget)</p>
</td></tr>
<tr><td><code id="exponential_anisotropic3D_alt_+3A_locs">locs</code></td>
<td>
<p>A matrix with <code>n</code> rows and <code>3</code> columns.
Each row of locs is a point in R^3.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>n</code> rows and <code>n</code> columns, with the i,j entry
containing the covariance between observations at <code>locs[i,]</code> and
<code>locs[j,]</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>d_exponential_anisotropic3D_alt()</code>: Derivatives of anisotropic Matern covariance
</p>
</li></ul>


<h3></h3>

<p>NA
</p>

<hr>
<h2 id='exponential_isotropic'>Isotropic exponential covariance function</h2><span id='topic+exponential_isotropic'></span><span id='topic+d_exponential_isotropic'></span><span id='topic+d_matern15_isotropic'></span><span id='topic+d_matern25_isotropic'></span>

<h3>Description</h3>

<p>From a matrix of locations and covariance parameters of the form
(variance, range, nugget), return the square matrix of
all pairwise covariances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exponential_isotropic(covparms, locs)

d_exponential_isotropic(covparms, locs)

d_matern15_isotropic(covparms, locs)

d_matern25_isotropic(covparms, locs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exponential_isotropic_+3A_covparms">covparms</code></td>
<td>
<p>A vector with covariance parameters
in the form (variance, range, nugget)</p>
</td></tr>
<tr><td><code id="exponential_isotropic_+3A_locs">locs</code></td>
<td>
<p>A matrix with <code>n</code> rows and <code>d</code> columns.
Each row of locs is a point in R^d.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>n</code> rows and <code>n</code> columns, with the i,j entry
containing the covariance between observations at <code>locs[i,]</code> and
<code>locs[j,]</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>d_exponential_isotropic()</code>: Derivatives of isotropic exponential covariance
</p>
</li>
<li> <p><code>d_matern15_isotropic()</code>: Derivatives of isotropic 
matern covariance with smoothness 1.5
</p>
</li>
<li> <p><code>d_matern25_isotropic()</code>: Derivatives of isotropic
matern covariance function with smoothness 2.5
</p>
</li></ul>


<h3>Parameterization</h3>

<p>The covariance parameter vector is (variance, range, nugget)
= <code class="reqn">(\sigma^2,\alpha,\tau^2)</code>, and the covariance function is parameterized
as
</p>
<p style="text-align: center;"><code class="reqn"> M(x,y) = \sigma^2 exp( - || x - y ||/ \alpha )</code>
</p>

<p>The nugget value <code class="reqn"> \sigma^2 \tau^2 </code> is added to the diagonal of the covariance matrix.
NOTE: the nugget is <code class="reqn"> \sigma^2 \tau^2 </code>, not <code class="reqn"> \tau^2 </code>.
</p>

<hr>
<h2 id='exponential_nonstat_var'>Isotropic exponential covariance function, nonstationary variances</h2><span id='topic+exponential_nonstat_var'></span><span id='topic+d_exponential_nonstat_var'></span>

<h3>Description</h3>

<p>From a matrix of locations and covariance parameters of the form
(variance, range, nugget, &lt;nonstat variance parameters&gt;), 
return the square matrix of all pairwise covariances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exponential_nonstat_var(covparms, Z)

d_exponential_nonstat_var(covparms, Z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exponential_nonstat_var_+3A_covparms">covparms</code></td>
<td>
<p>A vector with covariance parameters
in the form (variance, range, nugget, &lt;nonstat variance parameters&gt;).
The number of nonstationary variance parameters should equal <code>p</code>.</p>
</td></tr>
<tr><td><code id="exponential_nonstat_var_+3A_z">Z</code></td>
<td>
<p>A matrix with <code>n</code> rows and <code>2</code> columns for spatial
locations + <code>p</code> columns describing spatial basis functions.
Each row of locs gives a point in R^2 (two dimensions only!) + the value
of <code>p</code> spatial basis functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>n</code> rows and <code>n</code> columns, with the i,j entry
containing the covariance between observations at <code>locs[i,]</code> and
<code>locs[j,]</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>d_exponential_nonstat_var()</code>: Derivatives with respect to parameters
</p>
</li></ul>


<h3>Parameterization</h3>

<p>This covariance function multiplies the isotropic exponential covariance
by a nonstationary variance function. The form of the covariance is
</p>
<p style="text-align: center;"><code class="reqn"> C(x,y) = exp( \phi(x) + \phi(y) ) M(x,y) </code>
</p>

<p>where M(x,y) is the isotropic exponential covariance, and 
</p>
<p style="text-align: center;"><code class="reqn"> \phi(x) = c_1 \phi_1(x) + ... + c_p \phi_p(x) </code>
</p>

<p>where <code class="reqn">\phi_1,...,\phi_p</code> are the spatial basis functions
contained in the last <code>p</code> columns of <code>Z</code>, and 
<code class="reqn">c_1,...,c_p</code> are the nonstationary variance parameters.
</p>

<hr>
<h2 id='exponential_scaledim'>Exponential covariance function, different range parameter for each dimension</h2><span id='topic+exponential_scaledim'></span><span id='topic+d_exponential_scaledim'></span>

<h3>Description</h3>

<p>From a matrix of locations and covariance parameters of the form
(variance, range_1, ..., range_d, nugget), return the square matrix of
all pairwise covariances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exponential_scaledim(covparms, locs)

d_exponential_scaledim(covparms, locs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exponential_scaledim_+3A_covparms">covparms</code></td>
<td>
<p>A vector with covariance parameters
in the form (variance, range_1, ..., range_d, nugget)</p>
</td></tr>
<tr><td><code id="exponential_scaledim_+3A_locs">locs</code></td>
<td>
<p>A matrix with <code>n</code> rows and <code>d</code> columns.
Each row of locs is a point in R^d.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>n</code> rows and <code>n</code> columns, with the i,j entry
containing the covariance between observations at <code>locs[i,]</code> and
<code>locs[j,]</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>d_exponential_scaledim()</code>: Derivatives with respect to parameters
</p>
</li></ul>


<h3>Parameterization</h3>

<p>The covariance parameter vector is (variance, range_1, ..., range_d, nugget).
The covariance function is parameterized as
</p>
<p style="text-align: center;"><code class="reqn"> M(x,y) = \sigma^2 exp( - || D^{-1}(x - y) || ) </code>
</p>

<p>where D is a diagonal matrix with (range_1, ..., range_d) on the diagonals.
The nugget value <code class="reqn"> \sigma^2 \tau^2 </code> is added to the diagonal of the covariance matrix.
NOTE: the nugget is <code class="reqn"> \sigma^2 \tau^2 </code>, not <code class="reqn"> \tau^2 </code>.
</p>

<hr>
<h2 id='exponential_spacetime'>Spatial-Temporal exponential covariance function</h2><span id='topic+exponential_spacetime'></span><span id='topic+d_exponential_spacetime'></span>

<h3>Description</h3>

<p>From a matrix of locations and covariance parameters of the form
(variance, range_1, range_2, nugget), return the square matrix of
all pairwise covariances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exponential_spacetime(covparms, locs)

d_exponential_spacetime(covparms, locs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exponential_spacetime_+3A_covparms">covparms</code></td>
<td>
<p>A vector with covariance parameters
in the form (variance, range_1, range_2, nugget). range_1 is the
spatial range, and range_2 is the temporal range.</p>
</td></tr>
<tr><td><code id="exponential_spacetime_+3A_locs">locs</code></td>
<td>
<p>A matrix with <code>n</code> rows and <code>d+1</code> columns.
Each row of locs is a point in R^(d+1). The first <code>d</code> columns
should contain the spatial coordinates. The last column contains the times.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>n</code> rows and <code>n</code> columns, with the i,j entry
containing the covariance between observations at <code>locs[i,]</code> and
<code>locs[j,]</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>d_exponential_spacetime()</code>: Derivatives with respect to parameters
</p>
</li></ul>


<h3>Parameterization</h3>

<p>The covariance parameter vector is (variance, range_1, range_2, nugget).
The covariance function is parameterized as
</p>
<p style="text-align: center;"><code class="reqn"> M(x,y) = \sigma^2 exp( - || D^{-1}(x - y) || ) </code>
</p>

<p>where D is a diagonal matrix with (range_1, ..., range_1, range_2) on the diagonals.
The nugget value <code class="reqn"> \sigma^2 \tau^2 </code> is added to the diagonal of the covariance matrix.
NOTE: the nugget is <code class="reqn"> \sigma^2 \tau^2 </code>, not <code class="reqn"> \tau^2 </code>.
</p>

<hr>
<h2 id='exponential_sphere'>Isotropic exponential covariance function on sphere</h2><span id='topic+exponential_sphere'></span><span id='topic+d_exponential_sphere'></span>

<h3>Description</h3>

<p>From a matrix of longitudes and latitudes and a vector covariance parameters of the form
(variance, range, nugget), return the square matrix of
all pairwise covariances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exponential_sphere(covparms, lonlat)

d_exponential_sphere(covparms, lonlat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exponential_sphere_+3A_covparms">covparms</code></td>
<td>
<p>A vector with covariance parameters
in the form (variance, range, nugget). Range parameter assumes that
the sphere has radius 1 (units are radians).</p>
</td></tr>
<tr><td><code id="exponential_sphere_+3A_lonlat">lonlat</code></td>
<td>
<p>A matrix with <code>n</code> rows and one column with longitudes in (-180,180)
and one column of latitudes in (-90,90).
Each row of lonlat describes a point on the sphere.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>n</code> rows and <code>n</code> columns, with the i,j entry
containing the covariance between observations at <code>lonlat[i,]</code> and
<code>lonlat[j,]</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>d_exponential_sphere()</code>: Derivatives with respect to parameters
</p>
</li></ul>


<h3>Covariances on spheres</h3>

<p>The function first calculates the (x,y,z) 3D coordinates, and then inputs
the resulting locations into <code>exponential_isotropic</code>. This means that we construct
covariances on the sphere by embedding the sphere in a 3D space. There has been some
concern expressed in the literature that such embeddings may produce distortions.
The source and nature of such distortions has never been articulated,
and to date, no such distortions have been documented. Guinness and
Fuentes (2016) argue that 3D embeddings produce reasonable models for data on spheres.
</p>

<hr>
<h2 id='exponential_sphere_warp'>Deformed exponential covariance function on sphere</h2><span id='topic+exponential_sphere_warp'></span><span id='topic+d_exponential_sphere_warp'></span>

<h3>Description</h3>

<p>From a matrix of longitudes and latitudes and a vector covariance parameters of the form
(variance, range, nugget, &lt;5 warping parameters&gt;), return the square matrix of
all pairwise covariances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exponential_sphere_warp(covparms, lonlat)

d_exponential_sphere_warp(covparms, lonlat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exponential_sphere_warp_+3A_covparms">covparms</code></td>
<td>
<p>A vector with covariance parameters
in the form (variance, range, nugget, &lt;5 warping parameters&gt;). 
Range parameter assumes that the sphere has radius 1 (units are radians).</p>
</td></tr>
<tr><td><code id="exponential_sphere_warp_+3A_lonlat">lonlat</code></td>
<td>
<p>A matrix with <code>n</code> rows and one column with longitudes in (-180,180)
and one column of latitudes in (-90,90).
Each row of lonlat describes a point on the sphere.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>n</code> rows and <code>n</code> columns, with the i,j entry
containing the covariance between observations at <code>lonlat[i,]</code> and
<code>lonlat[j,]</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>d_exponential_sphere_warp()</code>: Derivatives with respect to parameters
</p>
</li></ul>


<h3>Warpings</h3>

<p>The function first calculates the (x,y,z) 3D coordinates, and then &quot;warps&quot;
the locations to <code class="reqn">(x,y,z) + \Phi(x,y,z)</code>, where <code class="reqn">\Phi</code> is a warping
function composed of gradients of spherical harmonic functions of degree 2.
See Guinness (2019, &quot;Gaussian Process Learning via Fisher Scoring of 
Vecchia's Approximation&quot;) for details.
The warped locations are input into <code>exponential_isotropic</code>.
</p>

<hr>
<h2 id='exponential_spheretime'>Exponential covariance function on sphere x time</h2><span id='topic+exponential_spheretime'></span><span id='topic+d_exponential_spheretime'></span>

<h3>Description</h3>

<p>From a matrix of longitudes, latitudes, and times, and a vector covariance parameters of the form
(variance, range_1, range_2, nugget), return the square matrix of
all pairwise covariances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exponential_spheretime(covparms, lonlattime)

d_exponential_spheretime(covparms, lonlattime)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exponential_spheretime_+3A_covparms">covparms</code></td>
<td>
<p>A vector with covariance parameters
in the form (variance, range_1, range_2, nugget), where range_1 is a 
spatial range (assuming sphere of radius 1), and range_2 is a temporal range.</p>
</td></tr>
<tr><td><code id="exponential_spheretime_+3A_lonlattime">lonlattime</code></td>
<td>
<p>A matrix with <code>n</code> rows and three columns: longitudes in (-180,180),
latitudes in (-90,90), and times.
Each row of lonlattime describes a point on the sphere x time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>n</code> rows and <code>n</code> columns, with the i,j entry
containing the covariance between observations at <code>lonlattime[i,]</code> and
<code>lonlattime[j,]</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>d_exponential_spheretime()</code>: Derivatives with respect to parameters.
</p>
</li></ul>


<h3>Covariances on spheres</h3>

<p>The function first calculates the (x,y,z) 3D coordinates, and then inputs
the resulting locations into <code>exponential_spacetime</code>. This means that we construct
covariances on the sphere by embedding the sphere in a 3D space. There has been some
concern expressed in the literature that such embeddings may produce distortions.
The source and nature of such distortions has never been articulated,
and to date, no such distortions have been documented. Guinness and
Fuentes (2016) argue that 3D embeddings produce reasonable models for data on spheres.
</p>

<hr>
<h2 id='exponential_spheretime_warp'>Deformed exponential covariance function on sphere</h2><span id='topic+exponential_spheretime_warp'></span><span id='topic+d_exponential_spheretime_warp'></span>

<h3>Description</h3>

<p>From a matrix of longitudes, latitudes, times, and a vector covariance parameters of the form
(variance, range_1, range_2, nugget, &lt;5 warping parameters&gt;), return the square matrix of
all pairwise covariances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exponential_spheretime_warp(covparms, lonlattime)

d_exponential_spheretime_warp(covparms, lonlattime)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exponential_spheretime_warp_+3A_covparms">covparms</code></td>
<td>
<p>A vector with covariance parameters
in the form (variance, range_1, range_2, nugget, &lt;5 warping parameters&gt;). 
range_1 is a spatial range parameter that assumes that the sphere 
has radius 1 (units are radians). range_2 is a temporal range parameter.</p>
</td></tr>
<tr><td><code id="exponential_spheretime_warp_+3A_lonlattime">lonlattime</code></td>
<td>
<p>A matrix with <code>n</code> rows and three columns: longitudes in (-180,180),
latitudes in (-90,90), and times.
Each row of lonlattime describes a point on the sphere x time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>n</code> rows and <code>n</code> columns, with the i,j entry
containing the covariance between observations at <code>lonlat[i,]</code> and
<code>lonlat[j,]</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>d_exponential_spheretime_warp()</code>: Derivatives with respect to parameters
</p>
</li></ul>


<h3>Warpings</h3>

<p>The function first calculates the (x,y,z) 3D coordinates, and then &quot;warps&quot;
the locations to <code class="reqn">(x,y,z) + \Phi(x,y,z)</code>, where <code class="reqn">\Phi</code> is a warping
function composed of gradients of spherical harmonic functions of degree 2.
See Guinness (2019, &quot;Gaussian Process Learning via Fisher Scoring of 
Vecchia's Approximation&quot;) for details.
The warped locations are input into <code>exponential_spacetime</code>. The function
does not do temporal warping.
</p>

<hr>
<h2 id='fast_Gp_sim'>Approximate GP simulation</h2><span id='topic+fast_Gp_sim'></span>

<h3>Description</h3>

<p>Calculates an approximation to the inverse Cholesky
factor of the covariance matrix using Vecchia's approximation,
then the simulation is produced by solving a linear system
with a vector of uncorrelated standard normals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast_Gp_sim(covparms, covfun_name = "matern_isotropic", locs, m = 30)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fast_Gp_sim_+3A_covparms">covparms</code></td>
<td>
<p>A vector of covariance parameters appropriate
for the specified covariance function</p>
</td></tr>
<tr><td><code id="fast_Gp_sim_+3A_covfun_name">covfun_name</code></td>
<td>
<p>See <code><a href="#topic+GpGp">GpGp</a></code> for information about covariance
functions.</p>
</td></tr>
<tr><td><code id="fast_Gp_sim_+3A_locs">locs</code></td>
<td>
<p>matrix of locations. Row <code>i</code> of <code>locs</code> specifies the location
of element <code>i</code> of <code>y</code>, and so the length of <code>y</code> should equal
the number of rows of <code>locs</code>.</p>
</td></tr>
<tr><td><code id="fast_Gp_sim_+3A_m">m</code></td>
<td>
<p>Number of nearest neighbors to use in approximation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of simulated values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>locs &lt;- as.matrix( expand.grid( (1:50)/50, (1:50)/50 ) )
y &lt;- fast_Gp_sim(c(4,0.2,0.5,0), "matern_isotropic",  locs, 30 )
fields::image.plot( matrix(y,50,50) )
</code></pre>

<hr>
<h2 id='fast_Gp_sim_Linv'>Approximate GP simulation with specified Linverse</h2><span id='topic+fast_Gp_sim_Linv'></span>

<h3>Description</h3>

<p>In situations where we want to do many gaussian process
simulations from the same model, we can compute Linverse
once and reuse it, rather than recomputing for each identical simulation.
This function also allows the user to input the vector of standard normals <code>z</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast_Gp_sim_Linv(Linv, NNarray, z = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fast_Gp_sim_Linv_+3A_linv">Linv</code></td>
<td>
<p>Matrix containing the entries of Linverse, usually the output from
<code>vecchia_Linv</code>.</p>
</td></tr>
<tr><td><code id="fast_Gp_sim_Linv_+3A_nnarray">NNarray</code></td>
<td>
<p>Matrix of nearest neighbor indices, usually the output from <code><a href="#topic+find_ordered_nn">find_ordered_nn</a></code></p>
</td></tr>
<tr><td><code id="fast_Gp_sim_Linv_+3A_z">z</code></td>
<td>
<p>Optional vector of standard normals. If not specified,
these are computed within the function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of simulated values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>locs &lt;- as.matrix( expand.grid( (1:50)/50, (1:50)/50 ) )
ord &lt;- order_maxmin(locs)
locsord &lt;- locs[ord,]
m &lt;- 10
NNarray &lt;- find_ordered_nn(locsord,m)
covparms &lt;- c(2, 0.2, 1, 0)
Linv &lt;- vecchia_Linv( covparms, "matern_isotropic", locsord, NNarray )
y &lt;- fast_Gp_sim_Linv(Linv,NNarray)
y[ord] &lt;- y
fields::image.plot( matrix(y,50,50) )
</code></pre>

<hr>
<h2 id='find_ordered_nn'>Find ordered nearest neighbors.</h2><span id='topic+find_ordered_nn'></span>

<h3>Description</h3>

<p>Given a matrix of locations, find the <code>m</code> nearest neighbors
to each location, subject to the neighbors coming
previously in the ordering. The algorithm uses the kdtree
algorithm in the FNN package, adapted to the setting
where the nearest neighbors must come from previous
in the ordering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_ordered_nn(locs, m, lonlat = FALSE, st_scale = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_ordered_nn_+3A_locs">locs</code></td>
<td>
<p>A matrix of locations. Each row of <code>locs</code> contains a location, which can
be a point in Euclidean space R^d, a point in space-time R^d x T, 
a longitude and latitude (in degrees) giving a point on the sphere, 
or a longitude, latitude, and time giving a point in the sphere-time domain.</p>
</td></tr>
<tr><td><code id="find_ordered_nn_+3A_m">m</code></td>
<td>
<p>Number of neighbors to return</p>
</td></tr>
<tr><td><code id="find_ordered_nn_+3A_lonlat">lonlat</code></td>
<td>
<p>TRUE/FALSE whether locations are longitudes and latitudes.</p>
</td></tr>
<tr><td><code id="find_ordered_nn_+3A_st_scale">st_scale</code></td>
<td>
<p>factor by which to scale the spatial and temporal coordinates
for distance calculations. The function assumes that the last column of
the locations is the temporal dimension, and the rest of the columns
are spatial dimensions. The spatial dimensions are divided by <code>st_scale[1]</code>,
and the temporal dimension is divided by <code>st_scale[2]</code>, before distances are
calculated. If <code>st_scale</code> is <code>NULL</code>, no scaling is used. We 
recommend setting <code>st_scale</code> manually so that each observation gets
neighbors that hail multiple directions in space and time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An matrix containing the indices of the neighbors. Row <code>i</code> of the
returned matrix contains the indices of the nearest <code>m</code>
locations to the <code>i</code>'th location. Indices are ordered within a
row to be increasing in distance. By convention, we consider a location
to neighbor itself, so the first entry of row <code>i</code> is <code>i</code>, the
second entry is the index of the nearest location, and so on. Because each
location neighbors itself, the returned matrix has <code>m+1</code> columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>locs &lt;- as.matrix( expand.grid( (1:40)/40, (1:40)/40 ) )     
ord &lt;- order_maxmin(locs)        # calculate an ordering
locsord &lt;- locs[ord,]            # reorder locations
m &lt;- 20
NNarray &lt;- find_ordered_nn(locsord,20)  # find ordered nearest 20 neighbors
ind &lt;- 100
# plot all locations in gray, first ind locations in black,
# ind location with magenta circle, m neighhbors with blue circle
plot( locs[,1], locs[,2], pch = 16, col = "gray" )
points( locsord[1:ind,1], locsord[1:ind,2], pch = 16 )
points( locsord[ind,1], locsord[ind,2], col = "magenta", cex = 1.5 )
points( locsord[NNarray[ind,2:(m+1)],1], 
    locsord[NNarray[ind,2:(m+1)],2], col = "blue", cex = 1.5 )
</code></pre>

<hr>
<h2 id='find_ordered_nn_brute'>Naive brute force nearest neighbor finder</h2><span id='topic+find_ordered_nn_brute'></span>

<h3>Description</h3>

<p>Naive brute force nearest neighbor finder
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_ordered_nn_brute(locs, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_ordered_nn_brute_+3A_locs">locs</code></td>
<td>
<p>matrix of locations</p>
</td></tr>
<tr><td><code id="find_ordered_nn_brute_+3A_m">m</code></td>
<td>
<p>number of neighbors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An matrix containing the indices of the neighbors. Row <code>i</code> of the
returned matrix contains the indices of the nearest <code>m</code>
locations to the <code>i</code>'th location. Indices are ordered within a
row to be increasing in distance. By convention, we consider a location
to neighbor itself, so the first entry of row <code>i</code> is <code>i</code>, the
second entry is the index of the nearest location, and so on. Because each
location neighbors itself, the returned matrix has <code>m+1</code> columns.
</p>

<hr>
<h2 id='fisher_scoring'>Fisher scoring algorithm</h2><span id='topic+fisher_scoring'></span>

<h3>Description</h3>

<p>Fisher scoring algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fisher_scoring(
  likfun,
  start_parms,
  link,
  silent = FALSE,
  convtol = 1e-04,
  max_iter = 40
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fisher_scoring_+3A_likfun">likfun</code></td>
<td>
<p>likelihood function, returns likelihood, gradient, and hessian</p>
</td></tr>
<tr><td><code id="fisher_scoring_+3A_start_parms">start_parms</code></td>
<td>
<p>starting values of parameters</p>
</td></tr>
<tr><td><code id="fisher_scoring_+3A_link">link</code></td>
<td>
<p>link function for parameters (used for printing)</p>
</td></tr>
<tr><td><code id="fisher_scoring_+3A_silent">silent</code></td>
<td>
<p>TRUE/FALSE for suppressing output</p>
</td></tr>
<tr><td><code id="fisher_scoring_+3A_convtol">convtol</code></td>
<td>
<p>convergence tolerance on step dot grad</p>
</td></tr>
<tr><td><code id="fisher_scoring_+3A_max_iter">max_iter</code></td>
<td>
<p>maximum number of Fisher scoring iterations</p>
</td></tr>
</table>

<hr>
<h2 id='fit_model'>Estimate mean and covariance parameters</h2><span id='topic+fit_model'></span>

<h3>Description</h3>

<p>Given a response, set of locations, (optionally) a design matrix,
and a specified covariance function, return the maximum
Vecchia likelihood estimates, obtained with a Fisher scoring algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_model(
  y,
  locs,
  X = NULL,
  covfun_name = "matern_isotropic",
  NNarray = NULL,
  start_parms = NULL,
  reorder = TRUE,
  group = TRUE,
  m_seq = c(10, 30),
  max_iter = 40,
  fixed_parms = NULL,
  silent = FALSE,
  st_scale = NULL,
  convtol = 1e-04
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_model_+3A_y">y</code></td>
<td>
<p>response vector</p>
</td></tr>
<tr><td><code id="fit_model_+3A_locs">locs</code></td>
<td>
<p>matrix of locations. Each row is a single 
spatial or spatial-temporal
location. If using one of the covariance functions for data on a sphere,
the first column should be longitudes (-180,180) and the second column
should be latitudes (-90,90). 
If using a spatial-temporal covariance function,
the last column should contain the times.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_x">X</code></td>
<td>
<p>design matrix. Each row contains covariates for the corresponding
observation in <code>y</code>. If not specified, the function sets <code>X</code> to be a
matrix with a single column of ones, that is, a constant mean function.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_covfun_name">covfun_name</code></td>
<td>
<p>string name of a covariance function. 
See <code><a href="#topic+GpGp">GpGp</a></code> for information about supported covariance funtions.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_nnarray">NNarray</code></td>
<td>
<p>Optionally specified array of nearest neighbor indices, 
usually from the output of <code><a href="#topic+find_ordered_nn">find_ordered_nn</a></code>. If <code>NULL</code>, 
fit_model will compute the nearest neighbors. We recommend that the user
not specify this unless there is a good reason to (e.g. if doing a comparison
study where one wants to control 
<code>NNarray</code> across different approximations).</p>
</td></tr>
<tr><td><code id="fit_model_+3A_start_parms">start_parms</code></td>
<td>
<p>Optionally specified starting values for parameters. 
If <code>NULL</code>,
fit_model will select default starting values.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_reorder">reorder</code></td>
<td>
<p>TRUE/FALSE indicating whether maxmin ordering should be used
(TRUE) or whether no reordering should be done before fitting (FALSE). 
If you want
to use a customized reordering, then manually reorder <code>y</code>, <code>locs</code>, 
and <code>X</code>,
and then set <code>reorder</code> to <code>FALSE</code>. A random reordering is used
when <code>nrow(locs) &gt; 1e5</code>.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_group">group</code></td>
<td>
<p>TRUE/FALSE for whether to use the grouped version of
the approximation (Guinness, 2018) or not.  The grouped version
is used by default and is always recommended.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_m_seq">m_seq</code></td>
<td>
<p>Sequence of values for number of neighbors. By default, 
a 10-neighbor
approximation is maximized, then a 30-neighbor approximation is 
maximized using the
10 neighbor estimates as starting values. 
However, one can specify any sequence
of numbers of neighbors, e.g. <code>m_seq = c(10,30,60,90)</code>.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_max_iter">max_iter</code></td>
<td>
<p>maximum number of Fisher scoring iterations</p>
</td></tr>
<tr><td><code id="fit_model_+3A_fixed_parms">fixed_parms</code></td>
<td>
<p>Indices of covariance parameters you would like to fix
at specific values. If you decide to fix any parameters, you must specify
their values in <code>start_parms</code>, along with the starting values for
all other parameters. For example, to fix the nugget at zero in 
<code>exponential_isotropic</code>, set <code>fixed_parms</code> to <code>c(3)</code>, and set
<code>start_parms</code> to <code>c(4.7,3.1,0)</code>. The
last element of <code>start_parms</code> (the nugget parameter) is set to zero,
while the starting values for the other two parameters are 4.7 and 3.1.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_silent">silent</code></td>
<td>
<p>TRUE/FALSE for whether to print some information during fitting.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_st_scale">st_scale</code></td>
<td>
<p>Scaling for spatial and temporal ranges. Only applicable for
spatial-temporal models, where it is used in distance
calculations when selecting neighbors. <code>st_scale</code> must be specified
when <code>covfun_name</code> is a spatial-temporal covariance. 
See Argo vignette for an example.</p>
</td></tr>
<tr><td><code id="fit_model_+3A_convtol">convtol</code></td>
<td>
<p>Tolerance for exiting the optimization. 
Fisher scoring is stopped
when the dot product between the step and the gradient 
is less than <code>convtol</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fit_model</code> is a user-friendly model fitting function
that automatically performs many of the auxiliary tasks needed for
using Vecchia's approximation, including reordering, computing
nearest neighbors, grouping, and optimization. The likelihoods use a small
penalty on small nuggets, large spatial variances, 
and small smoothness parameter.
</p>
<p>The Jason-3 windspeed vignette and the Argo temperature 
vignette are useful sources for a
use-cases of the <code>fit_model</code> function for data on sphere. 
The example below shows a very small example with a simulated dataset in 2d.
</p>


<h3>Value</h3>

<p>An object of class <code>GpGp_fit</code>, which is a list containing
covariance parameter estimates, regression coefficients,
covariance matrix for mean parameter estimates, as well as some other
information relevant to the model fit.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n1 &lt;- 20
n2 &lt;- 20
n &lt;- n1*n2
locs &lt;- as.matrix( expand.grid( (1:n1)/n1, (1:n2)/n2 ) )
covparms &lt;- c(2,0.1,1/2,0)
y &lt;- 7 + fast_Gp_sim(covparms, "matern_isotropic", locs)
X &lt;- as.matrix( rep(1,n) )
## not run
# fit &lt;- fit_model(y, locs, X, "matern_isotropic")
# fit


</code></pre>

<hr>
<h2 id='get_linkfun'>get link function, whether locations are lonlat and space time</h2><span id='topic+get_linkfun'></span>

<h3>Description</h3>

<p>get link function, whether locations are lonlat and space time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_linkfun(covfun_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_linkfun_+3A_covfun_name">covfun_name</code></td>
<td>
<p>string name of covariance function</p>
</td></tr>
</table>

<hr>
<h2 id='get_penalty'>get penalty function</h2><span id='topic+get_penalty'></span>

<h3>Description</h3>

<p>get penalty function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_penalty(y, X, locs, covfun_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_penalty_+3A_y">y</code></td>
<td>
<p>response</p>
</td></tr>
<tr><td><code id="get_penalty_+3A_x">X</code></td>
<td>
<p>design matrix</p>
</td></tr>
<tr><td><code id="get_penalty_+3A_locs">locs</code></td>
<td>
<p>locations</p>
</td></tr>
<tr><td><code id="get_penalty_+3A_covfun_name">covfun_name</code></td>
<td>
<p>string name of covariance function</p>
</td></tr>
</table>

<hr>
<h2 id='get_start_parms'>get default starting values of covariance parameters</h2><span id='topic+get_start_parms'></span>

<h3>Description</h3>

<p>get default starting values of covariance parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_start_parms(y, X, locs, covfun_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_start_parms_+3A_y">y</code></td>
<td>
<p>response</p>
</td></tr>
<tr><td><code id="get_start_parms_+3A_x">X</code></td>
<td>
<p>design matrix</p>
</td></tr>
<tr><td><code id="get_start_parms_+3A_locs">locs</code></td>
<td>
<p>locations</p>
</td></tr>
<tr><td><code id="get_start_parms_+3A_covfun_name">covfun_name</code></td>
<td>
<p>string name of covariance function</p>
</td></tr>
</table>

<hr>
<h2 id='group_obs'>Automatic grouping (partitioning) of locations</h2><span id='topic+group_obs'></span>

<h3>Description</h3>

<p>Take in an array of nearest neighbors, and automatically partition
the array into groups that share neighbors.
This is helpful to speed the computations and improve their accuracy.
The function returns a list, with each list element containing one or
several rows of NNarray. The algorithm attempts to find groupings such that
observations within a group share many common neighbors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_obs(NNarray, exponent = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_obs_+3A_nnarray">NNarray</code></td>
<td>
<p>Matrix of nearest neighbor indices, usually the result of <code><a href="#topic+find_ordered_nn">find_ordered_nn</a></code>.</p>
</td></tr>
<tr><td><code id="group_obs_+3A_exponent">exponent</code></td>
<td>
<p>Within the algorithm, two groups are merged if the number of unique
neighbors raised to the <code>exponent</code> power is less than the sum of the unique numbers
raised to the <code>exponent</code> power from the two groups.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements defining the grouping. The list entries are:
</p>

<ul>
<li> <p><code>all_inds</code>: vector of all indices of all blocks.
</p>
</li>
<li> <p><code>last_ind_of_block</code>: The <code>i</code>th entry tells us the
location in <code>all_inds</code> of the last index of the <code>i</code>th block. Thus the length
of <code>last_ind_of_block</code> is the number of blocks, and <code>last_ind_of_block</code> can
be used to chop <code>all_inds</code> up into blocks.
</p>
</li>
<li> <p><code>global_resp_inds</code>: The <code>i</code>th entry tells us the
index of the <code>i</code>th response, as ordered in <code>all_inds</code>.
</p>
</li>
<li> <p><code>local_resp_inds</code>: The <code>i</code>th entry tells us the location within 
the block of the response index.
</p>
</li>
<li> <p><code>last_resp_of_block</code>: The <code>i</code>th entry tells us the
location within <code>local_resp_inds</code> and <code>global_resp_inds</code> of the last
index of the <code>i</code>th block. <code>last_resp_of_block</code> is to 
<code>global_resp_inds</code> and <code>local_resp_inds</code>
as <code>last_ind_of_block</code> is to <code>all_inds</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>locs &lt;- matrix( runif(200), 100, 2 )   # generate random locations
ord &lt;- order_maxmin(locs)              # calculate an ordering
locsord &lt;- locs[ord,]                  # reorder locations
m &lt;- 10
NNarray &lt;- find_ordered_nn(locsord,m)  # m nearest neighbor indices
NNlist2 &lt;- group_obs(NNarray)          # join blocks if joining reduces squares
NNlist3 &lt;- group_obs(NNarray,3)        # join blocks if joining reduces cubes
object.size(NNarray)
object.size(NNlist2)
object.size(NNlist3)
mean( NNlist2[["local_resp_inds"]] - 1 )   # average number of neighbors (exponent 2)
mean( NNlist3[["local_resp_inds"]] - 1 )   # average number of neighbors (exponent 3)

all_inds &lt;- NNlist2$all_inds
last_ind_of_block &lt;- NNlist2$last_ind_of_block
inds_of_block_2 &lt;- all_inds[ (last_ind_of_block[1] + 1):last_ind_of_block[2] ]

local_resp_inds &lt;- NNlist2$local_resp_inds
global_resp_inds &lt;- NNlist2$global_resp_inds
last_resp_of_block &lt;- NNlist2$last_resp_of_block
local_resp_of_block_2 &lt;- 
    local_resp_inds[(last_resp_of_block[1]+1):last_resp_of_block[2]]

global_resp_of_block_2 &lt;- 
    global_resp_inds[(last_resp_of_block[1]+1):last_resp_of_block[2]]
inds_of_block_2[local_resp_of_block_2]
# these last two should be the same

</code></pre>

<hr>
<h2 id='jason3'>Windspeed measurements from Jason-3 Satellite</h2><span id='topic+jason3'></span>

<h3>Description</h3>

<p>A dataset containing lightly preprocessed windspeed values
from the Jason-3 satellite. Observations near clouds and ice
have been removed, and the data have been aggregated 
(averaged) over 10 second intervals. Jason-3 reports
windspeeds over the ocean only. The data are from a six
day period between August 4 and 9 of 2016.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jason3
</code></pre>


<h3>Format</h3>

<p>A data frame with 18973 rows and 4 columns
</p>

<dl>
<dt>windspeed</dt><dd><p>wind speed, in maters per second</p>
</dd>
<dt>lon</dt><dd><p>longitude in degrees between 0 and 360</p>
</dd>
<dt>lat</dt><dd><p>latitude in degrees between -90 and 90</p>
</dd>
<dt>time</dt><dd><p>time in seconds from midnight August 4</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.ncei.noaa.gov/products/jason-satellite-products">https://www.ncei.noaa.gov/products/jason-satellite-products</a>
</p>

<hr>
<h2 id='L_mult'>Multiply approximate Cholesky by a vector</h2><span id='topic+L_mult'></span>

<h3>Description</h3>

<p>Vecchia's approximation implies a sparse approximation to the
inverse Cholesky factor of the covariance matrix. This function
returns the result of multiplying the inverse of that matrix by a vector
(i.e. an approximation to the Cholesky factor).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>L_mult(Linv, z, NNarray)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="L_mult_+3A_linv">Linv</code></td>
<td>
<p>Entries of the sparse inverse Cholesky factor,
usually the output from <code><a href="#topic+vecchia_Linv">vecchia_Linv</a></code>.</p>
</td></tr>
<tr><td><code id="L_mult_+3A_z">z</code></td>
<td>
<p>the vector to be multiplied</p>
</td></tr>
<tr><td><code id="L_mult_+3A_nnarray">NNarray</code></td>
<td>
<p>A matrix of indices, usually the output from <code><a href="#topic+find_ordered_nn">find_ordered_nn</a></code>.
Row <code>i</code> contains the indices
of the observations that observation <code>i</code> conditions on. By convention,
the first element of row <code>i</code> is <code>i</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the product of the Cholesky factor with a vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 2000
locs &lt;- matrix( runif(2*n), n, 2 )
covparms &lt;- c(2, 0.2, 0.75, 0.1)
ord &lt;- order_maxmin(locs)
NNarray &lt;- find_ordered_nn(locs,20)
Linv &lt;- vecchia_Linv( covparms, "matern_isotropic", locs, NNarray )
z &lt;- rnorm(n)
y1 &lt;- fast_Gp_sim_Linv(Linv,NNarray,z)
y2 &lt;- L_mult(Linv, z, NNarray)
print( sum( (y1-y2)^2 ) )
</code></pre>

<hr>
<h2 id='L_t_mult'>Multiply transpose of approximate Cholesky by a vector</h2><span id='topic+L_t_mult'></span>

<h3>Description</h3>

<p>Vecchia's approximation implies a sparse approximation to the
inverse Cholesky factor of the covariance matrix. This function
returns the result of multiplying the transpose of the
inverse of that matrix by a vector
(i.e. an approximation to the transpose of the Cholesky factor).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>L_t_mult(Linv, z, NNarray)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="L_t_mult_+3A_linv">Linv</code></td>
<td>
<p>Entries of the sparse inverse Cholesky factor,
usually the output from <code><a href="#topic+vecchia_Linv">vecchia_Linv</a></code>.</p>
</td></tr>
<tr><td><code id="L_t_mult_+3A_z">z</code></td>
<td>
<p>the vector to be multiplied</p>
</td></tr>
<tr><td><code id="L_t_mult_+3A_nnarray">NNarray</code></td>
<td>
<p>A matrix of indices, usually the output from <code><a href="#topic+find_ordered_nn">find_ordered_nn</a></code>.
Row <code>i</code> contains the indices
of the observations that observation <code>i</code> conditions on. By convention,
the first element of row <code>i</code> is <code>i</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the product of the transpose of the Cholesky factor with a vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 2000
locs &lt;- matrix( runif(2*n), n, 2 )
covparms &lt;- c(2, 0.2, 0.75, 0.1)
NNarray &lt;- find_ordered_nn(locs,20)
Linv &lt;- vecchia_Linv( covparms, "matern_isotropic", locs, NNarray )
z1 &lt;- rnorm(n)
z2 &lt;- L_t_mult(Linv, z1, NNarray)
</code></pre>

<hr>
<h2 id='Linv_mult'>Multiply approximate inverse Cholesky by a vector</h2><span id='topic+Linv_mult'></span>

<h3>Description</h3>

<p>Vecchia's approximation implies a sparse approximation to the
inverse Cholesky factor of the covariance matrix. This function
returns the result of multiplying that matrix by a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Linv_mult(Linv, z, NNarray)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Linv_mult_+3A_linv">Linv</code></td>
<td>
<p>Entries of the sparse inverse Cholesky factor,
usually the output from <code><a href="#topic+vecchia_Linv">vecchia_Linv</a></code>.</p>
</td></tr>
<tr><td><code id="Linv_mult_+3A_z">z</code></td>
<td>
<p>the vector to be multiplied</p>
</td></tr>
<tr><td><code id="Linv_mult_+3A_nnarray">NNarray</code></td>
<td>
<p>A matrix of indices, usually the output from <code><a href="#topic+find_ordered_nn">find_ordered_nn</a></code>.
Row <code>i</code> contains the indices
of the observations that observation <code>i</code> conditions on. By convention,
the first element of row <code>i</code> is <code>i</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the product of the sparse inverse Cholesky factor with a vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 2000
locs &lt;- matrix( runif(2*n), n, 2 )
covparms &lt;- c(2, 0.2, 0.75, 0.1)
ord &lt;- order_maxmin(locs)
NNarray &lt;- find_ordered_nn(locs,20)
Linv &lt;- vecchia_Linv( covparms, "matern_isotropic", locs, NNarray )
z1 &lt;- rnorm(n)
y &lt;- fast_Gp_sim_Linv(Linv,NNarray,z1)
z2 &lt;- Linv_mult(Linv, y, NNarray)
print( sum( (z1-z2)^2 ) )
</code></pre>

<hr>
<h2 id='Linv_t_mult'>Multiply transpose of approximate inverse Cholesky by a vector</h2><span id='topic+Linv_t_mult'></span>

<h3>Description</h3>

<p>Vecchia's approximation implies a sparse approximation to the
inverse Cholesky factor of the covariance matrix. This function
returns the result of multiplying the transpose of that matrix by a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Linv_t_mult(Linv, z, NNarray)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Linv_t_mult_+3A_linv">Linv</code></td>
<td>
<p>Entries of the sparse inverse Cholesky factor,
usually the output from <code><a href="#topic+vecchia_Linv">vecchia_Linv</a></code>.</p>
</td></tr>
<tr><td><code id="Linv_t_mult_+3A_z">z</code></td>
<td>
<p>the vector to be multiplied</p>
</td></tr>
<tr><td><code id="Linv_t_mult_+3A_nnarray">NNarray</code></td>
<td>
<p>A matrix of indices, usually the output from <code><a href="#topic+find_ordered_nn">find_ordered_nn</a></code>.
Row <code>i</code> contains the indices
of the observations that observation <code>i</code> conditions on. By convention,
the first element of row <code>i</code> is <code>i</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the product of the transpose of the 
sparse inverse Cholesky factor with a vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 2000
locs &lt;- matrix( runif(2*n), n, 2 )
covparms &lt;- c(2, 0.2, 0.75, 0.1)
NNarray &lt;- find_ordered_nn(locs,20)
Linv &lt;- vecchia_Linv( covparms, "matern_isotropic", locs, NNarray )
z1 &lt;- rnorm(n)
z2 &lt;- Linv_t_mult(Linv, z1, NNarray)
</code></pre>

<hr>
<h2 id='matern_anisotropic2D'>Geometrically anisotropic Matern covariance function (two dimensions)</h2><span id='topic+matern_anisotropic2D'></span><span id='topic+d_matern_anisotropic2D'></span>

<h3>Description</h3>

<p>From a matrix of locations and covariance parameters of the form
(variance, L11, L21, L22, smoothness, nugget), return the square matrix of
all pairwise covariances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matern_anisotropic2D(covparms, locs)

d_matern_anisotropic2D(covparms, locs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matern_anisotropic2D_+3A_covparms">covparms</code></td>
<td>
<p>A vector with covariance parameters
in the form (variance, L11, L21, L22, smoothness, nugget)</p>
</td></tr>
<tr><td><code id="matern_anisotropic2D_+3A_locs">locs</code></td>
<td>
<p>A matrix with <code>n</code> rows and <code>2</code> columns.
Each row of locs is a point in R^2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>n</code> rows and <code>n</code> columns, with the i,j entry
containing the covariance between observations at <code>locs[i,]</code> and
<code>locs[j,]</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>d_matern_anisotropic2D()</code>: Derivatives of anisotropic Matern covariance
</p>
</li></ul>


<h3>Parameterization</h3>

<p>The covariance parameter vector is (variance, L11, L21, L22, smoothness, nugget)
where L11, L21, L22, are the three non-zero entries of a lower-triangular
matrix L. The covariances are 
</p>
<p style="text-align: center;"><code class="reqn"> M(x,y) = \sigma^2 2^{1-\nu}/\Gamma(\nu) (|| L x - L y || )^\nu K_\nu(|| L x - L y ||) </code>
</p>

<p>This means that L11 is interpreted as an inverse range parameter in the
first dimension.
The nugget value <code class="reqn"> \sigma^2 \tau^2 </code> is added to the diagonal of the covariance matrix.
NOTE: the nugget is <code class="reqn"> \sigma^2 \tau^2 </code>, not <code class="reqn"> \tau^2 </code>.
</p>

<hr>
<h2 id='matern_anisotropic3D'>Geometrically anisotropic Matern covariance function (three dimensions)</h2><span id='topic+matern_anisotropic3D'></span><span id='topic+d_matern_anisotropic3D'></span><span id='topic+d_matern_anisotropic3D_alt'></span>

<h3>Description</h3>

<p>From a matrix of locations and covariance parameters of the form
(variance, L11, L21, L22, L31, L32, L33, smoothness, nugget), return the square matrix of
all pairwise covariances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matern_anisotropic3D(covparms, locs)

d_matern_anisotropic3D(covparms, locs)

d_matern_anisotropic3D_alt(covparms, locs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matern_anisotropic3D_+3A_covparms">covparms</code></td>
<td>
<p>A vector with covariance parameters
in the form (variance, L11, L21, L22, L31, L32, L33, smoothness, nugget)</p>
</td></tr>
<tr><td><code id="matern_anisotropic3D_+3A_locs">locs</code></td>
<td>
<p>A matrix with <code>n</code> rows and <code>3</code> columns.
Each row of locs is a point in R^3.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>n</code> rows and <code>n</code> columns, with the i,j entry
containing the covariance between observations at <code>locs[i,]</code> and
<code>locs[j,]</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>d_matern_anisotropic3D()</code>: Derivatives of anisotropic Matern covariance
</p>
</li>
<li> <p><code>d_matern_anisotropic3D_alt()</code>: Derivatives of anisotropic Matern covariance
</p>
</li></ul>


<h3>Parameterization</h3>

<p>The covariance parameter vector is (variance, L11, L21, L22, L31, L32, L33, smoothness, nugget)
where L11, L21, L22, L31, L32, L33 are the six non-zero entries of a lower-triangular
matrix L. The covariances are 
</p>
<p style="text-align: center;"><code class="reqn"> M(x,y) = \sigma^2 2^{1-\nu}/\Gamma(\nu) (|| L x - L y || )^\nu K_\nu(|| L x - L y ||) </code>
</p>

<p>This means that L11 is interpreted as an inverse range parameter in the
first dimension.
The nugget value <code class="reqn"> \sigma^2 \tau^2 </code> is added to the diagonal of the covariance matrix.
NOTE: the nugget is <code class="reqn"> \sigma^2 \tau^2 </code>, not <code class="reqn"> \tau^2 </code>.
</p>

<hr>
<h2 id='matern_anisotropic3D_alt'>Geometrically anisotropic Matern covariance function (three dimensions, alternate parameterization)</h2><span id='topic+matern_anisotropic3D_alt'></span>

<h3>Description</h3>

<p>From a matrix of locations and covariance parameters of the form
(variance, B11, B12, B13, B22, B23, B33, smoothness, nugget), return the square matrix of
all pairwise covariances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matern_anisotropic3D_alt(covparms, locs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matern_anisotropic3D_alt_+3A_covparms">covparms</code></td>
<td>
<p>A vector with covariance parameters
in the form (variance, B11, B12, B13, B22, B23, B33, smoothness, nugget)</p>
</td></tr>
<tr><td><code id="matern_anisotropic3D_alt_+3A_locs">locs</code></td>
<td>
<p>A matrix with <code>n</code> rows and <code>3</code> columns.
Each row of locs is a point in R^3.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>n</code> rows and <code>n</code> columns, with the i,j entry
containing the covariance between observations at <code>locs[i,]</code> and
<code>locs[j,]</code>.
</p>


<h3>Parameterization</h3>

<p>The covariance parameter vector is (variance, B11, B12, B13, B22, B23, B33, smoothness, nugget)
where B11, B12, B13, B22, B23, B33, transform the three coordinates as
</p>
<p style="text-align: center;"><code class="reqn"> u_1 = B11[ x_1 + B12 x_2 + (B13 + B12 B23) x_3] </code>
</p>

<p style="text-align: center;"><code class="reqn"> u_2 = B22[ x_2 + B23 x_3] </code>
</p>

<p style="text-align: center;"><code class="reqn"> u_3 = B33[ x_3 ] </code>
</p>

<p>NOTE: the u_1 transformation is different from previous versions of this function.
NOTE: now (B13,B23) can be interpreted as a drift vector in space over time.
Assuming x is transformed to u and y transformed to v, the covariances are 
</p>
<p style="text-align: center;"><code class="reqn"> M(x,y) = \sigma^2 2^{1-\nu}/\Gamma(\nu) (|| u - v || )^\nu K_\nu(|| u - v ||) </code>
</p>

<p>The nugget value <code class="reqn"> \sigma^2 \tau^2 </code> is added to the diagonal of the covariance matrix.
NOTE: the nugget is <code class="reqn"> \sigma^2 \tau^2 </code>, not <code class="reqn"> \tau^2 </code>.
</p>

<hr>
<h2 id='matern_categorical'>Isotropic Matern covariance function with random effects for categories</h2><span id='topic+matern_categorical'></span><span id='topic+d_matern_categorical'></span>

<h3>Description</h3>

<p>From a matrix of locations and covariance parameters of the form
(variance, range, smoothness, category variance, nugget), return the square matrix of
all pairwise covariances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matern_categorical(covparms, locs)

d_matern_categorical(covparms, locs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matern_categorical_+3A_covparms">covparms</code></td>
<td>
<p>A vector with covariance parameters
in the form (variance, range, smoothness, category variance, nugget)</p>
</td></tr>
<tr><td><code id="matern_categorical_+3A_locs">locs</code></td>
<td>
<p>A matrix with <code>n</code> rows and <code>d</code> columns.
Each row of locs gives a point in R^d.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>n</code> rows and <code>n</code> columns, with the i,j entry
containing the covariance between observations at <code>locs[i,]</code> and
<code>locs[j,]</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>d_matern_categorical()</code>: Derivatives of isotropic Matern covariance
</p>
</li></ul>


<h3>Parameterization</h3>

<p>The covariance parameter vector is (variance, range, smoothness, category variance, nugget)
= <code class="reqn">(\sigma^2,\alpha,\nu,c^2,\tau^2)</code>, and the covariance function is parameterized
as
</p>
<p style="text-align: center;"><code class="reqn"> M(x,y) = \sigma^2 2^{1-\nu}/\Gamma(\nu) (|| x - y ||/\alpha )^\nu K_\nu(|| x - y ||/\alpha ) </code>
</p>

<p>The nugget value <code class="reqn"> \sigma^2 \tau^2 </code> is added to the diagonal of the covariance matrix.
The category variance <code class="reqn">c^2</code> is added if two observation from same category
NOTE: the nugget is <code class="reqn"> \sigma^2 \tau^2 </code>, not <code class="reqn"> \tau^2 </code>.
</p>

<hr>
<h2 id='matern_isotropic'>Isotropic Matern covariance function</h2><span id='topic+matern_isotropic'></span><span id='topic+d_matern_isotropic'></span>

<h3>Description</h3>

<p>From a matrix of locations and covariance parameters of the form
(variance, range, smoothness, nugget), return the square matrix of
all pairwise covariances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matern_isotropic(covparms, locs)

d_matern_isotropic(covparms, locs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matern_isotropic_+3A_covparms">covparms</code></td>
<td>
<p>A vector with covariance parameters
in the form (variance, range, smoothness, nugget)</p>
</td></tr>
<tr><td><code id="matern_isotropic_+3A_locs">locs</code></td>
<td>
<p>A matrix with <code>n</code> rows and <code>d</code> columns.
Each row of locs gives a point in R^d.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>n</code> rows and <code>n</code> columns, with the i,j entry
containing the covariance between observations at <code>locs[i,]</code> and
<code>locs[j,]</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>d_matern_isotropic()</code>: Derivatives of isotropic Matern covariance
</p>
</li></ul>


<h3>Parameterization</h3>

<p>The covariance parameter vector is (variance, range, smoothness, nugget)
= <code class="reqn">(\sigma^2,\alpha,\nu,\tau^2)</code>, and the covariance function is parameterized
as
</p>
<p style="text-align: center;"><code class="reqn"> M(x,y) = \sigma^2 2^{1-\nu}/\Gamma(\nu) (|| x - y ||/\alpha )^\nu K_\nu(|| x - y ||/\alpha ) </code>
</p>

<p>The nugget value <code class="reqn"> \sigma^2 \tau^2 </code> is added to the diagonal of the covariance matrix.
NOTE: the nugget is <code class="reqn"> \sigma^2 \tau^2 </code>, not <code class="reqn"> \tau^2 </code>.
</p>

<hr>
<h2 id='matern_nonstat_var'>Isotropic Matern covariance function, nonstationary variances</h2><span id='topic+matern_nonstat_var'></span><span id='topic+d_matern_nonstat_var'></span>

<h3>Description</h3>

<p>From a matrix of locations and covariance parameters of the form
(variance, range, smoothness, nugget, &lt;nonstat variance parameters&gt;), 
return the square matrix of all pairwise covariances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matern_nonstat_var(covparms, Z)

d_matern_nonstat_var(covparms, Z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matern_nonstat_var_+3A_covparms">covparms</code></td>
<td>
<p>A vector with covariance parameters
in the form (variance, range, smoothness, nugget, &lt;nonstat variance parameters&gt;).
The number of nonstationary variance parameters should equal <code>p</code>.</p>
</td></tr>
<tr><td><code id="matern_nonstat_var_+3A_z">Z</code></td>
<td>
<p>A matrix with <code>n</code> rows and <code>2</code> columns for spatial
locations + <code>p</code> columns describing spatial basis functions.
Each row of locs gives a point in R^2 (two dimensions only!) + the value
of <code>p</code> spatial basis functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>n</code> rows and <code>n</code> columns, with the i,j entry
containing the covariance between observations at <code>locs[i,]</code> and
<code>locs[j,]</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>d_matern_nonstat_var()</code>: Derivatives with respect to parameters
</p>
</li></ul>


<h3>Parameterization</h3>

<p>This covariance function multiplies the isotropic Matern covariance
by a nonstationary variance function. The form of the covariance is
</p>
<p style="text-align: center;"><code class="reqn"> C(x,y) = exp( \phi(x) + \phi(y) ) M(x,y) </code>
</p>

<p>where M(x,y) is the isotropic Matern covariance, and 
</p>
<p style="text-align: center;"><code class="reqn"> \phi(x) = c_1 \phi_1(x) + ... + c_p \phi_p(x) </code>
</p>

<p>where <code class="reqn">\phi_1,...,\phi_p</code> are the spatial basis functions
contained in the last <code>p</code> columns of <code>Z</code>, and 
<code class="reqn">c_1,...,c_p</code> are the nonstationary variance parameters.
</p>

<hr>
<h2 id='matern_scaledim'>Matern covariance function, different range parameter for each dimension</h2><span id='topic+matern_scaledim'></span><span id='topic+d_matern_scaledim'></span>

<h3>Description</h3>

<p>From a matrix of locations and covariance parameters of the form
(variance, range_1, ..., range_d, smoothness, nugget), return the square matrix of
all pairwise covariances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matern_scaledim(covparms, locs)

d_matern_scaledim(covparms, locs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matern_scaledim_+3A_covparms">covparms</code></td>
<td>
<p>A vector with covariance parameters
in the form (variance, range_1, ..., range_d, smoothness, nugget)</p>
</td></tr>
<tr><td><code id="matern_scaledim_+3A_locs">locs</code></td>
<td>
<p>A matrix with <code>n</code> rows and <code>d</code> columns.
Each row of locs is a point in R^d.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>n</code> rows and <code>n</code> columns, with the i,j entry
containing the covariance between observations at <code>locs[i,]</code> and
<code>locs[j,]</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>d_matern_scaledim()</code>: Derivatives with respect to parameters
</p>
</li></ul>


<h3>Parameterization</h3>

<p>The covariance parameter vector is (variance, range_1, ..., range_d, smoothness, nugget).
The covariance function is parameterized as
</p>
<p style="text-align: center;"><code class="reqn"> M(x,y) = \sigma^2 2^{1-\nu}/\Gamma(\nu) (|| D^{-1}(x - y) || )^\nu K_\nu(|| D^{-1}(x - y) || ) </code>
</p>

<p>where D is a diagonal matrix with (range_1, ..., range_d) on the diagonals.
The nugget value <code class="reqn"> \sigma^2 \tau^2 </code> is added to the diagonal of the covariance matrix.
NOTE: the nugget is <code class="reqn"> \sigma^2 \tau^2 </code>, not <code class="reqn"> \tau^2 </code>.
</p>

<hr>
<h2 id='matern_spacetime'>Spatial-Temporal Matern covariance function</h2><span id='topic+matern_spacetime'></span><span id='topic+d_matern_spacetime'></span>

<h3>Description</h3>

<p>From a matrix of locations and covariance parameters of the form
(variance, range_1, range_2, smoothness, nugget), return the square matrix of
all pairwise covariances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matern_spacetime(covparms, locs)

d_matern_spacetime(covparms, locs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matern_spacetime_+3A_covparms">covparms</code></td>
<td>
<p>A vector with covariance parameters
in the form (variance, range_1, range_2, smoothness, nugget). range_1 is the
spatial range, and range_2 is the temporal range.</p>
</td></tr>
<tr><td><code id="matern_spacetime_+3A_locs">locs</code></td>
<td>
<p>A matrix with <code>n</code> rows and <code>d+1</code> columns.
Each row of locs is a point in R^(d+1). The first <code>d</code> columns
should contain the spatial coordinates. The last column contains the times.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>n</code> rows and <code>n</code> columns, with the i,j entry
containing the covariance between observations at <code>locs[i,]</code> and
<code>locs[j,]</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>d_matern_spacetime()</code>: Derivatives with respect to parameters
</p>
</li></ul>


<h3>Parameterization</h3>

<p>The covariance parameter vector is (variance, range_1, range_2, smoothness, nugget).
The covariance function is parameterized as
</p>
<p style="text-align: center;"><code class="reqn"> M(x,y) = \sigma^2 2^{1-\nu}/\Gamma(\nu) (|| D^{-1}(x - y) || )^\nu K_\nu(|| D^{-1}(x - y) || ) </code>
</p>

<p>where D is a diagonal matrix with (range_1, ..., range_1, range_2) on the diagonals.
The nugget value <code class="reqn"> \sigma^2 \tau^2 </code> is added to the diagonal of the covariance matrix.
NOTE: the nugget is <code class="reqn"> \sigma^2 \tau^2 </code>, not <code class="reqn"> \tau^2 </code>.
</p>

<hr>
<h2 id='matern_spacetime_categorical'>Space-Time Matern covariance function with random effects for categories</h2><span id='topic+matern_spacetime_categorical'></span><span id='topic+d_matern_spacetime_categorical'></span>

<h3>Description</h3>

<p>From a matrix of locations and covariance parameters of the form
(variance, spatial range, temporal range, smoothness, category, nugget), return the square matrix of
all pairwise covariances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matern_spacetime_categorical(covparms, locs)

d_matern_spacetime_categorical(covparms, locs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matern_spacetime_categorical_+3A_covparms">covparms</code></td>
<td>
<p>A vector with covariance parameters
in the form (variance, spatial range, temporal range, smoothness, category, nugget)</p>
</td></tr>
<tr><td><code id="matern_spacetime_categorical_+3A_locs">locs</code></td>
<td>
<p>A matrix with <code>n</code> rows and <code>d</code> columns.
Each row of locs gives a point in R^d.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>n</code> rows and <code>n</code> columns, with the i,j entry
containing the covariance between observations at <code>locs[i,]</code> and
<code>locs[j,]</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>d_matern_spacetime_categorical()</code>: Derivatives of isotropic Matern covariance
</p>
</li></ul>


<h3>Parameterization</h3>

<p>The covariance parameter vector is (variance, range, smoothness, category, nugget)
= <code class="reqn">(\sigma^2,\alpha_1,\alpha_2,\nu,c^2,\tau^2)</code>, and the covariance function is parameterized
as
</p>
<p style="text-align: center;"><code class="reqn"> d = ( || x - y ||^2/\alpha_1 + |s-t|^2/\alpha_2^2 )^{1/2} </code>
</p>

<p style="text-align: center;"><code class="reqn"> M(x,y) = \sigma^2 2^{1-\nu}/\Gamma(\nu) (d)^\nu K_\nu(d) </code>
</p>

<p>(x,s) and (y,t) are the space-time locations of a pair of observations.
The nugget value <code class="reqn"> \sigma^2 \tau^2 </code> is added to the diagonal of the covariance matrix.
The category variance <code class="reqn">c^2</code> is added if two observation from same category
NOTE: the nugget is <code class="reqn"> \sigma^2 \tau^2 </code>, not <code class="reqn"> \tau^2 </code>.
</p>

<hr>
<h2 id='matern_spacetime_categorical_local'>Space-Time Matern covariance function with local random effects for categories</h2><span id='topic+matern_spacetime_categorical_local'></span><span id='topic+d_matern_spacetime_categorical_local'></span>

<h3>Description</h3>

<p>From a matrix of locations and covariance parameters of the form
(variance, spatial range, temporal range, smoothness, cat variance, cat spatial range, cat temporal range, cat smoothness, nugget),
return the square matrix of
all pairwise covariances.
This is the covariance for the following model for data from cateogory k
</p>
<p style="text-align: center;"><code class="reqn"> Y_k(x_i,t_i) = Z_0(x_i,t_i) + Z_k(x_i,t_i) + e_i </code>
</p>

<p>where Z_0 is Matern with parameters (variance,spatial range,temporal range,smoothness)
and Z_1,...,Z_K are independent Materns with parameters
(cat variance, cat spatial range, cat temporal range, cat smoothness),
and e_1, ..., e_n are independent normals with variance (variance * nugget)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matern_spacetime_categorical_local(covparms, locs)

d_matern_spacetime_categorical_local(covparms, locs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matern_spacetime_categorical_local_+3A_covparms">covparms</code></td>
<td>
<p>A vector with covariance parameters
in the form (variance, spatial range, temporal range, smoothness, category, nugget)</p>
</td></tr>
<tr><td><code id="matern_spacetime_categorical_local_+3A_locs">locs</code></td>
<td>
<p>A matrix with <code>n</code> rows and <code>d</code> columns.
Each row of locs gives a point in R^d.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>n</code> rows and <code>n</code> columns, with the i,j entry
containing the covariance between observations at <code>locs[i,]</code> and
<code>locs[j,]</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>d_matern_spacetime_categorical_local()</code>: Derivatives of isotropic Matern covariance
</p>
</li></ul>


<h3>Parameterization</h3>

<p>The covariance parameter vector is (variance, range, smoothness, category, nugget)
= <code class="reqn">(\sigma^2,\alpha_1,\alpha_2,\nu,c^2,\tau^2)</code>, and the covariance function is parameterized
as
</p>
<p style="text-align: center;"><code class="reqn"> d = ( || x - y ||^2/\alpha_1 + |s-t|^2/\alpha_2^2 )^{1/2} </code>
</p>

<p style="text-align: center;"><code class="reqn"> M(x,y) = \sigma^2 2^{1-\nu}/\Gamma(\nu) (d)^\nu K_\nu(d) </code>
</p>

<p>(x,s) and (y,t) are the space-time locations of a pair of observations.
The nugget value <code class="reqn"> \sigma^2 \tau^2 </code> is added to the diagonal of the covariance matrix.
The category variance <code class="reqn">c^2</code> is added if two observation from same category
NOTE: the nugget is <code class="reqn"> \sigma^2 \tau^2 </code>, not <code class="reqn"> \tau^2 </code>.
</p>

<hr>
<h2 id='matern_sphere'>Isotropic Matern covariance function on sphere</h2><span id='topic+matern_sphere'></span><span id='topic+d_matern_sphere'></span>

<h3>Description</h3>

<p>From a matrix of longitudes and latitudes and a vector covariance parameters of the form
(variance, range, smoothness, nugget), return the square matrix of
all pairwise covariances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matern_sphere(covparms, lonlat)

d_matern_sphere(covparms, lonlat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matern_sphere_+3A_covparms">covparms</code></td>
<td>
<p>A vector with covariance parameters
in the form (variance, range, smoothness, nugget). Range parameter assumes that
the sphere has radius 1 (units are radians).</p>
</td></tr>
<tr><td><code id="matern_sphere_+3A_lonlat">lonlat</code></td>
<td>
<p>A matrix with <code>n</code> rows and one column with longitudes in (-180,180)
and one column of latitudes in (-90,90).
Each row of lonlat describes a point on the sphere.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>n</code> rows and <code>n</code> columns, with the i,j entry
containing the covariance between observations at <code>lonlat[i,]</code> and
<code>lonlat[j,]</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>d_matern_sphere()</code>: Derivatives with respect to parameters
</p>
</li></ul>


<h3>Matern on Sphere Domain</h3>

<p>The function first calculates the (x,y,z) 3D coordinates, and then inputs
the resulting locations into <code>matern_isotropic</code>. This means that we construct
covariances on the sphere by embedding the sphere in a 3D space. There has been some
concern expressed in the literature that such embeddings may produce distortions.
The source and nature of such distortions has never been articulated,
and to date, no such distortions have been documented. Guinness and
Fuentes (2016) argue that 3D embeddings produce reasonable models for data on spheres.
</p>

<hr>
<h2 id='matern_sphere_warp'>Deformed Matern covariance function on sphere</h2><span id='topic+matern_sphere_warp'></span><span id='topic+d_matern_sphere_warp'></span>

<h3>Description</h3>

<p>From a matrix of longitudes and latitudes and a vector covariance parameters of the form
(variance, range, smoothness, nugget, &lt;5 warping parameters&gt;), return the square matrix of
all pairwise covariances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matern_sphere_warp(covparms, lonlat)

d_matern_sphere_warp(covparms, lonlat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matern_sphere_warp_+3A_covparms">covparms</code></td>
<td>
<p>A vector with covariance parameters
in the form (variance, range, smoothness, nugget, &lt;5 warping parameters&gt;). 
Range parameter assumes that the sphere has radius 1 (units are radians).</p>
</td></tr>
<tr><td><code id="matern_sphere_warp_+3A_lonlat">lonlat</code></td>
<td>
<p>A matrix with <code>n</code> rows and one column with longitudes in (-180,180)
and one column of latitudes in (-90,90).
Each row of lonlat describes a point on the sphere.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>n</code> rows and <code>n</code> columns, with the i,j entry
containing the covariance between observations at <code>lonlat[i,]</code> and
<code>lonlat[j,]</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>d_matern_sphere_warp()</code>: Derivatives with respect to parameters.
</p>
</li></ul>


<h3>Warpings</h3>

<p>The function first calculates the (x,y,z) 3D coordinates, and then &quot;warps&quot;
the locations to <code class="reqn">(x,y,z) + \Phi(x,y,z)</code>, where <code class="reqn">\Phi</code> is a warping
function composed of gradients of spherical harmonic functions of degree 2.
See Guinness (2019, &quot;Gaussian Process Learning via Fisher Scoring of 
Vecchia's Approximation&quot;) for details.
The warped locations are input into <code>matern_isotropic</code>.
</p>

<hr>
<h2 id='matern_spheretime'>Matern covariance function on sphere x time</h2><span id='topic+matern_spheretime'></span><span id='topic+d_matern_spheretime'></span>

<h3>Description</h3>

<p>From a matrix of longitudes, latitudes, and times, and a vector covariance parameters of the form
(variance, range_1, range_2, smoothness, nugget), return the square matrix of
all pairwise covariances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matern_spheretime(covparms, lonlattime)

d_matern_spheretime(covparms, lonlattime)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matern_spheretime_+3A_covparms">covparms</code></td>
<td>
<p>A vector with covariance parameters
in the form (variance, range_1, range_2, smoothness, nugget), where range_1 is a 
spatial range (assuming sphere of radius 1), and range_2 is a temporal range.</p>
</td></tr>
<tr><td><code id="matern_spheretime_+3A_lonlattime">lonlattime</code></td>
<td>
<p>A matrix with <code>n</code> rows and three columns: longitudes in (-180,180),
latitudes in (-90,90), and times.
Each row of lonlattime describes a point on the sphere x time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>n</code> rows and <code>n</code> columns, with the i,j entry
containing the covariance between observations at <code>lonlattime[i,]</code> and
<code>lonlattime[j,]</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>d_matern_spheretime()</code>: Derivatives with respect to parameters
</p>
</li></ul>


<h3>Covariances on spheres</h3>

<p>The function first calculates the (x,y,z) 3D coordinates, and then inputs
the resulting locations into <code>matern_spacetime</code>. This means that we construct
covariances on the sphere by embedding the sphere in a 3D space. There has been some
concern expressed in the literature that such embeddings may produce distortions.
The source and nature of such distortions has never been articulated,
and to date, no such distortions have been documented. Guinness and
Fuentes (2016) argue that 3D embeddings produce reasonable models for data on spheres.
</p>

<hr>
<h2 id='matern_spheretime_warp'>Deformed Matern covariance function on sphere</h2><span id='topic+matern_spheretime_warp'></span><span id='topic+d_matern_spheretime_warp'></span>

<h3>Description</h3>

<p>From a matrix of longitudes, latitudes, times, and a vector covariance parameters of the form
(variance, range_1, range_2, smoothness, nugget, &lt;5 warping parameters&gt;), return the square matrix of
all pairwise covariances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matern_spheretime_warp(covparms, lonlattime)

d_matern_spheretime_warp(covparms, lonlattime)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matern_spheretime_warp_+3A_covparms">covparms</code></td>
<td>
<p>A vector with covariance parameters
in the form (variance, range_1, range_2, smoothness, nugget, &lt;5 warping parameters&gt;). 
range_1 is a spatial range parameter that assumes that the sphere 
has radius 1 (units are radians). range_2 is a temporal range parameter.</p>
</td></tr>
<tr><td><code id="matern_spheretime_warp_+3A_lonlattime">lonlattime</code></td>
<td>
<p>A matrix with <code>n</code> rows and three columns: longitudes in (-180,180),
latitudes in (-90,90), and times.
Each row of lonlattime describes a point on the sphere x time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>n</code> rows and <code>n</code> columns, with the i,j entry
containing the covariance between observations at <code>lonlat[i,]</code> and
<code>lonlat[j,]</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>d_matern_spheretime_warp()</code>: Derivatives with respect to parameters
</p>
</li></ul>


<h3>Warpings</h3>

<p>The function first calculates the (x,y,z) 3D coordinates, and then &quot;warps&quot;
the locations to <code class="reqn">(x,y,z) + \Phi(x,y,z)</code>, where <code class="reqn">\Phi</code> is a warping
function composed of gradients of spherical harmonic functions of degree 2.
See Guinness (2019, &quot;Gaussian Process Learning via Fisher Scoring of 
Vecchia's Approximation&quot;) for details.
The warped locations are input into <code>matern_spacetime</code>. The function
does not do temporal warping.
</p>

<hr>
<h2 id='matern15_isotropic'>Isotropic Matern covariance function, smoothness = 1.5</h2><span id='topic+matern15_isotropic'></span>

<h3>Description</h3>

<p>From a matrix of locations and covariance parameters of the form
(variance, range, nugget), return the square matrix of
all pairwise covariances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matern15_isotropic(covparms, locs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matern15_isotropic_+3A_covparms">covparms</code></td>
<td>
<p>A vector with covariance parameters
in the form (variance, range, nugget)</p>
</td></tr>
<tr><td><code id="matern15_isotropic_+3A_locs">locs</code></td>
<td>
<p>A matrix with <code>n</code> rows and <code>d</code> columns.
Each row of locs is a point in R^d.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>n</code> rows and <code>n</code> columns, with the i,j entry
containing the covariance between observations at <code>locs[i,]</code> and
<code>locs[j,]</code>.
</p>


<h3>Parameterization</h3>

<p>The covariance parameter vector is (variance, range, nugget)
= <code class="reqn">(\sigma^2,\alpha,\tau^2)</code>, and the covariance function is parameterized
as
</p>
<p style="text-align: center;"><code class="reqn"> M(x,y) = \sigma^2 (1 + || x - y || ) exp( - || x - y ||/ \alpha )</code>
</p>

<p>The nugget value <code class="reqn"> \sigma^2 \tau^2 </code> is added to the diagonal of the covariance matrix.
NOTE: the nugget is <code class="reqn"> \sigma^2 \tau^2 </code>, not <code class="reqn"> \tau^2 </code>.
</p>

<hr>
<h2 id='matern15_scaledim'>Matern covariance function, smoothess = 1.5, different range parameter for each dimension</h2><span id='topic+matern15_scaledim'></span><span id='topic+d_matern15_scaledim'></span>

<h3>Description</h3>

<p>From a matrix of locations and covariance parameters of the form
(variance, range_1, ..., range_d, nugget), return the square matrix of
all pairwise covariances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matern15_scaledim(covparms, locs)

d_matern15_scaledim(covparms, locs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matern15_scaledim_+3A_covparms">covparms</code></td>
<td>
<p>A vector with covariance parameters
in the form (variance, range_1, ..., range_d, nugget)</p>
</td></tr>
<tr><td><code id="matern15_scaledim_+3A_locs">locs</code></td>
<td>
<p>A matrix with <code>n</code> rows and <code>d</code> columns.
Each row of locs is a point in R^d.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>n</code> rows and <code>n</code> columns, with the i,j entry
containing the covariance between observations at <code>locs[i,]</code> and
<code>locs[j,]</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>d_matern15_scaledim()</code>: Derivatives with respect to parameters
</p>
</li></ul>


<h3>Parameterization</h3>

<p>The covariance parameter vector is (variance, range_1, ..., range_d, nugget).
The covariance function is parameterized as
</p>
<p style="text-align: center;"><code class="reqn"> M(x,y) = \sigma^2 (1 + || D^{-1}(x - y) || ) exp( - || D^{-1}(x - y) || ) </code>
</p>

<p>where D is a diagonal matrix with (range_1, ..., range_d) on the diagonals.
The nugget value <code class="reqn"> \sigma^2 \tau^2 </code> is added to the diagonal of the covariance matrix.
NOTE: the nugget is <code class="reqn"> \sigma^2 \tau^2 </code>, not <code class="reqn"> \tau^2 </code>.
</p>

<hr>
<h2 id='matern25_isotropic'>Isotropic Matern covariance function, smoothness = 2.5</h2><span id='topic+matern25_isotropic'></span>

<h3>Description</h3>

<p>From a matrix of locations and covariance parameters of the form
(variance, range, nugget), return the square matrix of
all pairwise covariances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matern25_isotropic(covparms, locs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matern25_isotropic_+3A_covparms">covparms</code></td>
<td>
<p>A vector with covariance parameters
in the form (variance, range, nugget)</p>
</td></tr>
<tr><td><code id="matern25_isotropic_+3A_locs">locs</code></td>
<td>
<p>A matrix with <code>n</code> rows and <code>d</code> columns.
Each row of locs is a point in R^d.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>n</code> rows and <code>n</code> columns, with the i,j entry
containing the covariance between observations at <code>locs[i,]</code> and
<code>locs[j,]</code>.
</p>


<h3>Parameterization</h3>

<p>The covariance parameter vector is (variance, range, nugget)
= <code class="reqn">(\sigma^2,\alpha,\tau^2)</code>, and the covariance function is parameterized
as
</p>
<p style="text-align: center;"><code class="reqn"> M(x,y) = \sigma^2 (1 + || x - y ||/ \alpha + || x - y ||^2/3\alpha^2 ) exp( - || x - y ||/ \alpha )</code>
</p>

<p>The nugget value <code class="reqn"> \sigma^2 \tau^2 </code> is added to the diagonal of the covariance matrix.
NOTE: the nugget is <code class="reqn"> \sigma^2 \tau^2 </code>, not <code class="reqn"> \tau^2 </code>.
</p>

<hr>
<h2 id='matern25_scaledim'>Matern covariance function, smoothess = 2.5, different range parameter for each dimension</h2><span id='topic+matern25_scaledim'></span><span id='topic+d_matern25_scaledim'></span>

<h3>Description</h3>

<p>From a matrix of locations and covariance parameters of the form
(variance, range_1, ..., range_d, nugget), return the square matrix of
all pairwise covariances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matern25_scaledim(covparms, locs)

d_matern25_scaledim(covparms, locs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matern25_scaledim_+3A_covparms">covparms</code></td>
<td>
<p>A vector with covariance parameters
in the form (variance, range_1, ..., range_d, nugget)</p>
</td></tr>
<tr><td><code id="matern25_scaledim_+3A_locs">locs</code></td>
<td>
<p>A matrix with <code>n</code> rows and <code>d</code> columns.
Each row of locs is a point in R^d.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>n</code> rows and <code>n</code> columns, with the i,j entry
containing the covariance between observations at <code>locs[i,]</code> and
<code>locs[j,]</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>d_matern25_scaledim()</code>: Derivatives with respect to parameters
</p>
</li></ul>


<h3>Parameterization</h3>

<p>The covariance parameter vector is (variance, range_1, ..., range_d, nugget).
The covariance function is parameterized as
</p>
<p style="text-align: center;"><code class="reqn"> M(x,y) = \sigma^2 (1 + || D^{-1}(x - y) || + || D^{-1}(x - y) ||^2/3.0) exp( - || D^{-1}(x - y) || ) </code>
</p>

<p>where D is a diagonal matrix with (range_1, ..., range_d) on the diagonals.
The nugget value <code class="reqn"> \sigma^2 \tau^2 </code> is added to the diagonal of the covariance matrix.
NOTE: the nugget is <code class="reqn"> \sigma^2 \tau^2 </code>, not <code class="reqn"> \tau^2 </code>.
</p>

<hr>
<h2 id='matern35_isotropic'>Isotropic Matern covariance function, smoothness = 3.5</h2><span id='topic+matern35_isotropic'></span><span id='topic+d_matern35_isotropic'></span><span id='topic+d_matern45_isotropic'></span>

<h3>Description</h3>

<p>From a matrix of locations and covariance parameters of the form
(variance, range, nugget), return the square matrix of
all pairwise covariances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matern35_isotropic(covparms, locs)

d_matern35_isotropic(covparms, locs)

d_matern45_isotropic(covparms, locs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matern35_isotropic_+3A_covparms">covparms</code></td>
<td>
<p>A vector with covariance parameters
in the form (variance, range, nugget)</p>
</td></tr>
<tr><td><code id="matern35_isotropic_+3A_locs">locs</code></td>
<td>
<p>A matrix with <code>n</code> rows and <code>d</code> columns.
Each row of locs is a point in R^d.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>n</code> rows and <code>n</code> columns, with the i,j entry
containing the covariance between observations at <code>locs[i,]</code> and
<code>locs[j,]</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>d_matern35_isotropic()</code>: Derivatives of isotropic
matern covariance function with smoothness 3.5
</p>
</li>
<li> <p><code>d_matern45_isotropic()</code>: Derivatives of isotropic
matern covariance function with smoothness 3.5
</p>
</li></ul>


<h3>Parameterization</h3>

<p>The covariance parameter vector is (variance, range, nugget)
= <code class="reqn">(\sigma^2,\alpha,\tau^2)</code>, and the covariance function is parameterized
as
</p>
<p style="text-align: center;"><code class="reqn"> M(x,y) = \sigma^2 ( \sum_{j=0}^3 c_j || x - y ||^j/ \alpha^j ) exp( - || x - y ||/ \alpha )</code>
</p>

<p>where c_0 = 1, c_1 = 1, c_2 = 2/5, c_3 = 1/15. 
The nugget value <code class="reqn"> \sigma^2 \tau^2 </code> is added to the diagonal of the covariance matrix.
NOTE: the nugget is <code class="reqn"> \sigma^2 \tau^2 </code>, not <code class="reqn"> \tau^2 </code>.
</p>

<hr>
<h2 id='matern35_scaledim'>Matern covariance function, smoothess = 3.5, different range parameter for each dimension</h2><span id='topic+matern35_scaledim'></span><span id='topic+d_matern35_scaledim'></span><span id='topic+d_matern45_scaledim'></span>

<h3>Description</h3>

<p>From a matrix of locations and covariance parameters of the form
(variance, range_1, ..., range_d, nugget), return the square matrix of
all pairwise covariances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matern35_scaledim(covparms, locs)

d_matern35_scaledim(covparms, locs)

d_matern45_scaledim(covparms, locs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matern35_scaledim_+3A_covparms">covparms</code></td>
<td>
<p>A vector with covariance parameters
in the form (variance, range_1, ..., range_d, nugget)</p>
</td></tr>
<tr><td><code id="matern35_scaledim_+3A_locs">locs</code></td>
<td>
<p>A matrix with <code>n</code> rows and <code>d</code> columns.
Each row of locs is a point in R^d.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>n</code> rows and <code>n</code> columns, with the i,j entry
containing the covariance between observations at <code>locs[i,]</code> and
<code>locs[j,]</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>d_matern35_scaledim()</code>: Derivatives with respect to parameters
</p>
</li>
<li> <p><code>d_matern45_scaledim()</code>: Derivatives with respect to parameters
</p>
</li></ul>


<h3>Parameterization</h3>

<p>The covariance parameter vector is (variance, range_1, ..., range_d, nugget).
The covariance function is parameterized as
</p>
<p style="text-align: center;"><code class="reqn"> M(x,y) = \sigma^2 ( \sum_{j=0}^3 c_j || D^{-1}(x - y) ||^j  ) exp( - || D^{-1}(x - y) || ) </code>
</p>

<p>where c_0 = 1, c_1 = 1, c_2 = 2/5, c_3 = 1/15.
where D is a diagonal matrix with (range_1, ..., range_d) on the diagonals.
The nugget value <code class="reqn"> \sigma^2 \tau^2 </code> is added to the diagonal of the covariance matrix.
NOTE: the nugget is <code class="reqn"> \sigma^2 \tau^2 </code>, not <code class="reqn"> \tau^2 </code>.
</p>

<hr>
<h2 id='matern45_isotropic'>Isotropic Matern covariance function, smoothness = 4.5</h2><span id='topic+matern45_isotropic'></span>

<h3>Description</h3>

<p>From a matrix of locations and covariance parameters of the form
(variance, range, nugget), return the square matrix of
all pairwise covariances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matern45_isotropic(covparms, locs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matern45_isotropic_+3A_covparms">covparms</code></td>
<td>
<p>A vector with covariance parameters
in the form (variance, range, nugget)</p>
</td></tr>
<tr><td><code id="matern45_isotropic_+3A_locs">locs</code></td>
<td>
<p>A matrix with <code>n</code> rows and <code>d</code> columns.
Each row of locs is a point in R^d.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>n</code> rows and <code>n</code> columns, with the i,j entry
containing the covariance between observations at <code>locs[i,]</code> and
<code>locs[j,]</code>.
</p>


<h3>Parameterization</h3>

<p>The covariance parameter vector is (variance, range, nugget)
= <code class="reqn">(\sigma^2,\alpha,\tau^2)</code>, and the covariance function is parameterized
as
</p>
<p style="text-align: center;"><code class="reqn"> M(x,y) = \sigma^2 ( \sum_{j=0}^4 c_j || x - y ||^j/ \alpha^j ) exp( - || x - y ||/ \alpha )</code>
</p>

<p>where c_0 = 1, c_1 = 1, c_2 = 3/7, c_3 = 2/21, c_4 = 1/105. 
The nugget value <code class="reqn"> \sigma^2 \tau^2 </code> is added to the diagonal of the covariance matrix.
NOTE: the nugget is <code class="reqn"> \sigma^2 \tau^2 </code>, not <code class="reqn"> \tau^2 </code>.
</p>

<hr>
<h2 id='matern45_scaledim'>Matern covariance function, smoothess = 3.5, different range parameter for each dimension</h2><span id='topic+matern45_scaledim'></span>

<h3>Description</h3>

<p>From a matrix of locations and covariance parameters of the form
(variance, range_1, ..., range_d, nugget), return the square matrix of
all pairwise covariances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matern45_scaledim(covparms, locs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matern45_scaledim_+3A_covparms">covparms</code></td>
<td>
<p>A vector with covariance parameters
in the form (variance, range_1, ..., range_d, nugget)</p>
</td></tr>
<tr><td><code id="matern45_scaledim_+3A_locs">locs</code></td>
<td>
<p>A matrix with <code>n</code> rows and <code>d</code> columns.
Each row of locs is a point in R^d.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>n</code> rows and <code>n</code> columns, with the i,j entry
containing the covariance between observations at <code>locs[i,]</code> and
<code>locs[j,]</code>.
</p>


<h3>Parameterization</h3>

<p>The covariance parameter vector is (variance, range_1, ..., range_d, nugget).
The covariance function is parameterized as
</p>
<p style="text-align: center;"><code class="reqn"> M(x,y) = \sigma^2 ( \sum_{j=0}^4 c_j || D^{-1}(x - y) ||^j  ) exp( - || D^{-1}(x - y) || ) </code>
</p>

<p>where c_0 = 1, c_1 = 1, c_2 = 3/7, c_3 = 2/21, c_4 = 1/105. 
where D is a diagonal matrix with (range_1, ..., range_d) on the diagonals.
The nugget value <code class="reqn"> \sigma^2 \tau^2 </code> is added to the diagonal of the covariance matrix.
NOTE: the nugget is <code class="reqn"> \sigma^2 \tau^2 </code>, not <code class="reqn"> \tau^2 </code>.
</p>

<hr>
<h2 id='order_coordinate'>Sorted coordinate ordering</h2><span id='topic+order_coordinate'></span>

<h3>Description</h3>

<p>Return the ordering of locations sorted along one of the
coordinates or the sum of multiple coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order_coordinate(locs, coordinate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="order_coordinate_+3A_locs">locs</code></td>
<td>
<p>A matrix of locations. Each row of <code>locs</code> contains a location, which can
be a point in Euclidean space R^d, a point in space-time R^d x T, 
a longitude and latitude (in degrees) giving a point on the sphere, 
or a longitude, latitude, and time giving a point in the sphere-time domain.</p>
</td></tr>
<tr><td><code id="order_coordinate_+3A_coordinate">coordinate</code></td>
<td>
<p>integer or vector of integers in (1,...,d). If a single integer,
coordinates are ordered along that coordinate. If multiple integers,
coordinates are ordered according to the sum of specified coordinate values. For example,
when <code>d=2</code>, <code>coordinate = c(1,2)</code> orders from bottom left to top right.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of indices giving the ordering, i.e. 
the first element of this vector is the index of the first location.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100             # Number of locations
d &lt;- 2               # dimension of domain
locs &lt;- matrix( runif(n*d), n, d )
ord1 &lt;- order_coordinate(locs, 1 )
ord12 &lt;- order_coordinate(locs, c(1,2) )
</code></pre>

<hr>
<h2 id='order_dist_to_point'>Distance to specified point ordering</h2><span id='topic+order_dist_to_point'></span>

<h3>Description</h3>

<p>Return the ordering of locations increasing in their
distance to some specified location
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order_dist_to_point(locs, loc0, lonlat = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="order_dist_to_point_+3A_locs">locs</code></td>
<td>
<p>A matrix of locations. Each row of <code>locs</code> contains a location, which can
be a point in Euclidean space R^d, a point in space-time R^d x T, 
a longitude and latitude (in degrees) giving a point on the sphere, 
or a longitude, latitude, and time giving a point in the sphere-time domain.</p>
</td></tr>
<tr><td><code id="order_dist_to_point_+3A_loc0">loc0</code></td>
<td>
<p>A vector containing a single location in R^d.</p>
</td></tr>
<tr><td><code id="order_dist_to_point_+3A_lonlat">lonlat</code></td>
<td>
<p>TRUE/FALSE whether locations are longitudes and latitudes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of indices giving the ordering, i.e. 
the first element of this vector is the index of the location nearest to <code>loc0</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100             # Number of locations
d &lt;- 2               # dimension of domain
locs &lt;- matrix( runif(n*d), n, d )
loc0 &lt;- c(1/2,1/2)
ord &lt;- order_dist_to_point(locs,loc0)
</code></pre>

<hr>
<h2 id='order_maxmin'>Maximum minimum distance ordering</h2><span id='topic+order_maxmin'></span>

<h3>Description</h3>

<p>Return the indices of an approximation to the maximum minimum distance ordering.
A point in the center is chosen first, and then each successive point
is chosen to maximize the minimum distance to previously selected points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order_maxmin(locs, lonlat = FALSE, space_time = FALSE, st_scale = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="order_maxmin_+3A_locs">locs</code></td>
<td>
<p>A matrix of locations. Each row of <code>locs</code> contains a location, which can
be a point in Euclidean space R^d, a point in space-time R^d x T, 
a longitude and latitude (in degrees) giving a point on the sphere, 
or a longitude, latitude, and time giving a point in the sphere-time domain.</p>
</td></tr>
<tr><td><code id="order_maxmin_+3A_lonlat">lonlat</code></td>
<td>
<p>TRUE/FALSE whether locations are longitudes and latitudes.</p>
</td></tr>
<tr><td><code id="order_maxmin_+3A_space_time">space_time</code></td>
<td>
<p>TRUE if locations are euclidean space-time locations, 
FALSE otherwise. If set to TRUE, temporal dimension is ignored.</p>
</td></tr>
<tr><td><code id="order_maxmin_+3A_st_scale">st_scale</code></td>
<td>
<p>two-vector giving the amount by which the spatial
and temporal coordinates are scaled. If <code>NULL</code>, the function
uses the locations to automatically select a scaling.
If set to FALSE, temporal dimension treated as another spatial dimension (not recommended).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of indices giving the ordering, i.e. 
the first element of this vector is the index of the first location.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># planar coordinates
nvec &lt;- c(50,50)
locs &lt;- as.matrix( expand.grid( 1:nvec[1]/nvec[1], 1:nvec[2]/nvec[2] ) )
ord &lt;- order_maxmin(locs)
par(mfrow=c(1,3))
plot( locs[ord[1:100],1], locs[ord[1:100],2], xlim = c(0,1), ylim = c(0,1) )
plot( locs[ord[1:300],1], locs[ord[1:300],2], xlim = c(0,1), ylim = c(0,1) )
plot( locs[ord[1:900],1], locs[ord[1:900],2], xlim = c(0,1), ylim = c(0,1) )

# longitude/latitude coordinates (sphere)
latvals &lt;- seq(-80, 80, length.out = 40 )
lonvals &lt;- seq( 0, 360, length.out = 81 )[1:80]
locs &lt;- as.matrix( expand.grid( lonvals, latvals ) )
ord &lt;- order_maxmin(locs, lonlat = TRUE)
par(mfrow=c(1,3))
plot( locs[ord[1:100],1], locs[ord[1:100],2], xlim = c(0,360), ylim = c(-90,90) )
plot( locs[ord[1:300],1], locs[ord[1:300],2], xlim = c(0,360), ylim = c(-90,90) )
plot( locs[ord[1:900],1], locs[ord[1:900],2], xlim = c(0,360), ylim = c(-90,90) )

</code></pre>

<hr>
<h2 id='order_middleout'>Middle-out ordering</h2><span id='topic+order_middleout'></span>

<h3>Description</h3>

<p>Return the ordering of locations increasing in their
distance to the average location
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order_middleout(locs, lonlat = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="order_middleout_+3A_locs">locs</code></td>
<td>
<p>A matrix of locations. Each row of <code>locs</code> contains a location, which can
be a point in Euclidean space R^d, a point in space-time R^d x T, 
a longitude and latitude (in degrees) giving a point on the sphere, 
or a longitude, latitude, and time giving a point in the sphere-time domain.</p>
</td></tr>
<tr><td><code id="order_middleout_+3A_lonlat">lonlat</code></td>
<td>
<p>TRUE/FALSE whether locations are longitudes and latitudes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of indices giving the ordering, i.e. 
the first element of this vector is the index of the location nearest the center.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100             # Number of locations
d &lt;- 2               # dimension of domain
locs &lt;- matrix( runif(n*d), n, d )
ord &lt;- order_middleout(locs)
</code></pre>

<hr>
<h2 id='pen_hi'>penalize large values of parameter: penalty, 1st deriative, 2nd derivative</h2><span id='topic+pen_hi'></span><span id='topic+dpen_hi'></span><span id='topic+ddpen_hi'></span>

<h3>Description</h3>

<p>penalize large values of parameter: penalty, 1st deriative, 2nd derivative
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pen_hi(x, tt, aa)

dpen_hi(x, tt, aa)

ddpen_hi(x, tt, aa)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pen_hi_+3A_x">x</code></td>
<td>
<p>argument to penalty</p>
</td></tr>
<tr><td><code id="pen_hi_+3A_tt">tt</code></td>
<td>
<p>scale parameter of penalty</p>
</td></tr>
<tr><td><code id="pen_hi_+3A_aa">aa</code></td>
<td>
<p>location parameter of penalty</p>
</td></tr>
</table>

<hr>
<h2 id='pen_lo'>penalize small values of parameter: penalty, 1st deriative, 2nd derivative</h2><span id='topic+pen_lo'></span><span id='topic+dpen_lo'></span><span id='topic+ddpen_lo'></span>

<h3>Description</h3>

<p>penalize small values of parameter: penalty, 1st deriative, 2nd derivative
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pen_lo(x, tt, aa)

dpen_lo(x, tt, aa)

ddpen_lo(x, tt, aa)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pen_lo_+3A_x">x</code></td>
<td>
<p>argument to penalty</p>
</td></tr>
<tr><td><code id="pen_lo_+3A_tt">tt</code></td>
<td>
<p>scale parameter of penalty</p>
</td></tr>
<tr><td><code id="pen_lo_+3A_aa">aa</code></td>
<td>
<p>location parameter of penalty</p>
</td></tr>
</table>

<hr>
<h2 id='pen_loglo'>penalize small values of log parameter: penalty, 1st deriative, 2nd derivative</h2><span id='topic+pen_loglo'></span><span id='topic+dpen_loglo'></span><span id='topic+ddpen_loglo'></span>

<h3>Description</h3>

<p>penalize small values of log parameter: penalty, 1st deriative, 2nd derivative
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pen_loglo(x, tt, aa)

dpen_loglo(x, tt, aa)

ddpen_loglo(x, tt, aa)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pen_loglo_+3A_x">x</code></td>
<td>
<p>argument to penalty</p>
</td></tr>
<tr><td><code id="pen_loglo_+3A_tt">tt</code></td>
<td>
<p>scale parameter of penalty</p>
</td></tr>
<tr><td><code id="pen_loglo_+3A_aa">aa</code></td>
<td>
<p>location parameter of penalty</p>
</td></tr>
</table>

<hr>
<h2 id='predictions'>Compute Gaussian process predictions using Vecchia's approximations</h2><span id='topic+predictions'></span>

<h3>Description</h3>

<p>With the prediction locations ordered after the observation locations,
an approximation for the inverse Cholesky of the covariance matrix
is computed, and standard formulas are applied to obtain
the conditional expectation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictions(
  fit = NULL,
  locs_pred,
  X_pred,
  y_obs = fit$y,
  locs_obs = fit$locs,
  X_obs = fit$X,
  beta = fit$betahat,
  covparms = fit$covparms,
  covfun_name = fit$covfun_name,
  m = 60,
  reorder = TRUE,
  st_scale = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictions_+3A_fit">fit</code></td>
<td>
<p>GpGp_fit object, the result of <code><a href="#topic+fit_model">fit_model</a></code></p>
</td></tr>
<tr><td><code id="predictions_+3A_locs_pred">locs_pred</code></td>
<td>
<p>prediction locations</p>
</td></tr>
<tr><td><code id="predictions_+3A_x_pred">X_pred</code></td>
<td>
<p>Design matrix for predictions</p>
</td></tr>
<tr><td><code id="predictions_+3A_y_obs">y_obs</code></td>
<td>
<p>Observations associated with locs_obs</p>
</td></tr>
<tr><td><code id="predictions_+3A_locs_obs">locs_obs</code></td>
<td>
<p>observation locations</p>
</td></tr>
<tr><td><code id="predictions_+3A_x_obs">X_obs</code></td>
<td>
<p>Design matrix for observations</p>
</td></tr>
<tr><td><code id="predictions_+3A_beta">beta</code></td>
<td>
<p>Linear mean parameters</p>
</td></tr>
<tr><td><code id="predictions_+3A_covparms">covparms</code></td>
<td>
<p>Covariance parameters</p>
</td></tr>
<tr><td><code id="predictions_+3A_covfun_name">covfun_name</code></td>
<td>
<p>Name of covariance function</p>
</td></tr>
<tr><td><code id="predictions_+3A_m">m</code></td>
<td>
<p>Number of nearest neighbors to use</p>
</td></tr>
<tr><td><code id="predictions_+3A_reorder">reorder</code></td>
<td>
<p>TRUE/FALSE for whether reordering should be done. This should
generally be kept at TRUE, unless testing out the effect of
reordering.</p>
</td></tr>
<tr><td><code id="predictions_+3A_st_scale">st_scale</code></td>
<td>
<p>amount by which to scale the spatial and temporal
dimensions for the purpose of selecting neighbors. We recommend setting
this manually when using a spatial-temporal covariance function. When 
<code>lonlat = TRUE</code>, spatial scale is in radians (earth radius = 1).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We can specify either a GpGp_fit object (the result of 
<code><a href="#topic+fit_model">fit_model</a></code>), OR manually enter the covariance function and
parameters, the observations, observation locations, and design matrix. We 
must specify the prediction locations and the prediction design matrix.
</p>

<hr>
<h2 id='sph_grad_xyz'>compute gradient of spherical harmonics functions</h2><span id='topic+sph_grad_xyz'></span>

<h3>Description</h3>

<p>compute gradient of spherical harmonics functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sph_grad_xyz(xyz, Lmax)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sph_grad_xyz_+3A_xyz">xyz</code></td>
<td>
<p>xyz coordinates of locations on sphere</p>
</td></tr>
<tr><td><code id="sph_grad_xyz_+3A_lmax">Lmax</code></td>
<td>
<p>largest degree of spherical harmonics. 
Current only Lmax=2 supported</p>
</td></tr>
</table>

<hr>
<h2 id='summary.GpGp_fit'>Print summary of GpGp fit</h2><span id='topic+summary.GpGp_fit'></span>

<h3>Description</h3>

<p>Print summary of GpGp fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GpGp_fit'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.GpGp_fit_+3A_object">object</code></td>
<td>
<p>Object of class &quot;GpGp_fit&quot;, usually the return value from
<code><a href="#topic+fit_model">fit_model</a></code></p>
</td></tr>
<tr><td><code id="summary.GpGp_fit_+3A_...">...</code></td>
<td>
<p>additional arguments, for compatability with S3 generic 'summary'</p>
</td></tr>
</table>

<hr>
<h2 id='test_likelihood_object'>test likelihood object for NA or Inf values</h2><span id='topic+test_likelihood_object'></span>

<h3>Description</h3>

<p>test likelihood object for NA or Inf values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_likelihood_object(likobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_likelihood_object_+3A_likobj">likobj</code></td>
<td>
<p>likelihood object</p>
</td></tr>
</table>

<hr>
<h2 id='vecchia_grouped_meanzero_loglik'>Grouped Vecchia approximation to the Gaussian loglikelihood, zero mean</h2><span id='topic+vecchia_grouped_meanzero_loglik'></span>

<h3>Description</h3>

<p>This function returns a grouped version (Guinness, 2018) of Vecchia's (1988) 
approximation to the Gaussian
loglikelihood. The approximation modifies the ordered conditional
specification of the joint density; rather than each term in the product
conditioning on all previous observations, each term conditions on
a small subset of previous observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vecchia_grouped_meanzero_loglik(covparms, covfun_name, y, locs, NNlist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vecchia_grouped_meanzero_loglik_+3A_covparms">covparms</code></td>
<td>
<p>A vector of covariance parameters appropriate
for the specified covariance function</p>
</td></tr>
<tr><td><code id="vecchia_grouped_meanzero_loglik_+3A_covfun_name">covfun_name</code></td>
<td>
<p>See <code><a href="#topic+GpGp">GpGp</a></code> for information about covariance
functions.</p>
</td></tr>
<tr><td><code id="vecchia_grouped_meanzero_loglik_+3A_y">y</code></td>
<td>
<p>vector of response values</p>
</td></tr>
<tr><td><code id="vecchia_grouped_meanzero_loglik_+3A_locs">locs</code></td>
<td>
<p>matrix of locations. Row <code>i</code> of <code>locs</code> specifies the location
of element <code>i</code> of <code>y</code>, and so the length of <code>y</code> should equal
the number of rows of <code>locs</code>.</p>
</td></tr>
<tr><td><code id="vecchia_grouped_meanzero_loglik_+3A_nnlist">NNlist</code></td>
<td>
<p>A neighbor list object, the output from <code><a href="#topic+group_obs">group_obs</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing
</p>

<ul>
<li> <p><code>loglik</code>: the loglikelihood
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>n1 &lt;- 20
n2 &lt;- 20
n &lt;- n1*n2
locs &lt;- as.matrix( expand.grid( (1:n1)/n1, (1:n2)/n2 ) )
covparms &lt;- c(2, 0.2, 0.75, 0)
y &lt;- fast_Gp_sim(covparms, "matern_isotropic", locs, 50 )
ord &lt;- order_maxmin(locs)
NNarray &lt;- find_ordered_nn(locs,20)
NNlist &lt;- group_obs(NNarray)
#loglik &lt;- vecchia_grouped_meanzero_loglik( covparms, "matern_isotropic", y, locs, NNlist )
</code></pre>

<hr>
<h2 id='vecchia_grouped_profbeta_loglik'>Grouped Vecchia approximation, profiled regression coefficients</h2><span id='topic+vecchia_grouped_profbeta_loglik'></span>

<h3>Description</h3>

<p>This function returns a grouped version (Guinness, 2018) of Vecchia's (1988) 
approximation to the Gaussian
loglikelihood and the profile likelihood estimate of the regression
coefficients. The approximation modifies the ordered conditional
specification of the joint density; rather than each term in the product
conditioning on all previous observations, each term conditions on
a small subset of previous observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vecchia_grouped_profbeta_loglik(covparms, covfun_name, y, X, locs, NNlist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vecchia_grouped_profbeta_loglik_+3A_covparms">covparms</code></td>
<td>
<p>A vector of covariance parameters appropriate
for the specified covariance function</p>
</td></tr>
<tr><td><code id="vecchia_grouped_profbeta_loglik_+3A_covfun_name">covfun_name</code></td>
<td>
<p>See <code><a href="#topic+GpGp">GpGp</a></code> for information about covariance
functions.</p>
</td></tr>
<tr><td><code id="vecchia_grouped_profbeta_loglik_+3A_y">y</code></td>
<td>
<p>vector of response values</p>
</td></tr>
<tr><td><code id="vecchia_grouped_profbeta_loglik_+3A_x">X</code></td>
<td>
<p>Design matrix of covariates. Row <code>i</code> of <code>X</code> contains
the covariates for the observation at row <code>i</code> of <code>locs</code>.</p>
</td></tr>
<tr><td><code id="vecchia_grouped_profbeta_loglik_+3A_locs">locs</code></td>
<td>
<p>matrix of locations. Row <code>i</code> of <code>locs</code> specifies the location
of element <code>i</code> of <code>y</code>, and so the length of <code>y</code> should equal
the number of rows of <code>locs</code>.</p>
</td></tr>
<tr><td><code id="vecchia_grouped_profbeta_loglik_+3A_nnlist">NNlist</code></td>
<td>
<p>A neighbor list object, the output from <code><a href="#topic+group_obs">group_obs</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing
</p>

<ul>
<li> <p><code>loglik</code>: the loglikelihood
</p>
</li>
<li> <p><code>betahat</code>: profile likelihood estimate of regression coefficients
</p>
</li>
<li> <p><code>betainfo</code>: information matrix for <code>betahat</code>.
</p>
</li></ul>

<p>The covariance
matrix for <code>$betahat</code> is the inverse of <code>$betainfo</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n1 &lt;- 20
n2 &lt;- 20
n &lt;- n1*n2
locs &lt;- as.matrix( expand.grid( (1:n1)/n1, (1:n2)/n2 ) )
X &lt;- cbind(rep(1,n),locs[,2])
covparms &lt;- c(2, 0.2, 0.75, 0)
y &lt;- fast_Gp_sim(covparms, "matern_isotropic", locs, 50 )
ord &lt;- order_maxmin(locs)
NNarray &lt;- find_ordered_nn(locs,20)
NNlist &lt;- group_obs(NNarray)
#loglik &lt;- vecchia_grouped_profbeta_loglik( 
#    covparms, "matern_isotropic", y, X, locs, NNlist )
</code></pre>

<hr>
<h2 id='vecchia_grouped_profbeta_loglik_grad_info'>Grouped Vecchia loglikelihood, gradient, Fisher information</h2><span id='topic+vecchia_grouped_profbeta_loglik_grad_info'></span>

<h3>Description</h3>

<p>This function returns a grouped version (Guinness, 2018) of Vecchia's (1988) 
approximation to the Gaussian
loglikelihood, the gradient, and Fisher information, 
and the profile likelihood estimate of the regression
coefficients. The approximation modifies the ordered conditional
specification of the joint density; rather than each term in the product
conditioning on all previous observations, each term conditions on
a small subset of previous observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vecchia_grouped_profbeta_loglik_grad_info(
  covparms,
  covfun_name,
  y,
  X,
  locs,
  NNlist
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vecchia_grouped_profbeta_loglik_grad_info_+3A_covparms">covparms</code></td>
<td>
<p>A vector of covariance parameters appropriate
for the specified covariance function</p>
</td></tr>
<tr><td><code id="vecchia_grouped_profbeta_loglik_grad_info_+3A_covfun_name">covfun_name</code></td>
<td>
<p>See <code><a href="#topic+GpGp">GpGp</a></code> for information about covariance
functions.</p>
</td></tr>
<tr><td><code id="vecchia_grouped_profbeta_loglik_grad_info_+3A_y">y</code></td>
<td>
<p>vector of response values</p>
</td></tr>
<tr><td><code id="vecchia_grouped_profbeta_loglik_grad_info_+3A_x">X</code></td>
<td>
<p>Design matrix of covariates. Row <code>i</code> of <code>X</code> contains
the covariates for the observation at row <code>i</code> of <code>locs</code>.</p>
</td></tr>
<tr><td><code id="vecchia_grouped_profbeta_loglik_grad_info_+3A_locs">locs</code></td>
<td>
<p>matrix of locations. Row <code>i</code> of <code>locs</code> specifies the location
of element <code>i</code> of <code>y</code>, and so the length of <code>y</code> should equal
the number of rows of <code>locs</code>.</p>
</td></tr>
<tr><td><code id="vecchia_grouped_profbeta_loglik_grad_info_+3A_nnlist">NNlist</code></td>
<td>
<p>A neighbor list object, the output from <code><a href="#topic+group_obs">group_obs</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing
</p>

<ul>
<li> <p><code>loglik</code>: the loglikelihood
</p>
</li>
<li> <p><code>grad</code>: gradient with respect to covariance parameters
</p>
</li>
<li> <p><code>info</code>: Fisher information for covariance parameters
</p>
</li>
<li> <p><code>betahat</code>: profile likelihood estimate of regression coefs
</p>
</li>
<li> <p><code>betainfo</code>: information matrix for <code>betahat</code>.
</p>
</li></ul>

<p>The covariance
matrix for <code>$betahat</code> is the inverse of <code>$betainfo</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n1 &lt;- 20
n2 &lt;- 20
n &lt;- n1*n2
locs &lt;- as.matrix( expand.grid( (1:n1)/n1, (1:n2)/n2 ) )
X &lt;- cbind(rep(1,n),locs[,2])
covparms &lt;- c(2, 0.2, 0.75, 0)
y &lt;- fast_Gp_sim(covparms, "matern_isotropic", locs, 50 )
ord &lt;- order_maxmin(locs)
NNarray &lt;- find_ordered_nn(locs,20)
NNlist &lt;- group_obs(NNarray)
#loglik &lt;- vecchia_grouped_profbeta_loglik_grad_info( 
#    covparms, "matern_isotropic", y, X, locs, NNlist )
</code></pre>

<hr>
<h2 id='vecchia_Linv'>Entries of inverse Cholesky approximation</h2><span id='topic+vecchia_Linv'></span>

<h3>Description</h3>

<p>This function returns the entries of the inverse Cholesky
factor of the covariance matrix implied by Vecchia's approximation.
For return matrix <code>Linv</code>, <code>Linv[i,]</code> contains 
the non-zero entries of row <code>i</code> of
the inverse Cholesky matrix. The columns of the non-zero entries
are specified in <code>NNarray[i,]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vecchia_Linv(covparms, covfun_name, locs, NNarray, start_ind = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vecchia_Linv_+3A_covparms">covparms</code></td>
<td>
<p>A vector of covariance parameters appropriate
for the specified covariance function</p>
</td></tr>
<tr><td><code id="vecchia_Linv_+3A_covfun_name">covfun_name</code></td>
<td>
<p>See <code><a href="#topic+GpGp">GpGp</a></code> for information about covariance
functions.</p>
</td></tr>
<tr><td><code id="vecchia_Linv_+3A_locs">locs</code></td>
<td>
<p>matrix of locations. Row <code>i</code> of <code>locs</code> specifies the location
of element <code>i</code> of <code>y</code>, and so the length of <code>y</code> should equal
the number of rows of <code>locs</code>.</p>
</td></tr>
<tr><td><code id="vecchia_Linv_+3A_nnarray">NNarray</code></td>
<td>
<p>A matrix of indices, usually the output from <code><a href="#topic+find_ordered_nn">find_ordered_nn</a></code>.
Row <code>i</code> contains the indices
of the observations that observation <code>i</code> conditions on. By convention,
the first element of row <code>i</code> is <code>i</code>.</p>
</td></tr>
<tr><td><code id="vecchia_Linv_+3A_start_ind">start_ind</code></td>
<td>
<p>Compute entries of Linv only for rows <code>start_ind</code>
until the last row.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix containing entries of inverse Cholesky
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n1 &lt;- 40
n2 &lt;- 40
n &lt;- n1*n2
locs &lt;- as.matrix( expand.grid( (1:n1)/n1, (1:n2)/n2 ) )
covparms &lt;- c(2, 0.2, 0.75, 0)
NNarray &lt;- find_ordered_nn(locs,20)
Linv &lt;- vecchia_Linv(covparms, "matern_isotropic", locs, NNarray)
</code></pre>

<hr>
<h2 id='vecchia_meanzero_loglik'>Vecchia's approximation to the Gaussian loglikelihood, zero mean</h2><span id='topic+vecchia_meanzero_loglik'></span>

<h3>Description</h3>

<p>This function returns Vecchia's (1988) approximation to the Gaussian
loglikelihood. The approximation modifies the ordered conditional
specification of the joint density; rather than each term in the product
conditioning on all previous observations, each term conditions on
a small subset of previous observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vecchia_meanzero_loglik(covparms, covfun_name, y, locs, NNarray)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vecchia_meanzero_loglik_+3A_covparms">covparms</code></td>
<td>
<p>A vector of covariance parameters appropriate
for the specified covariance function</p>
</td></tr>
<tr><td><code id="vecchia_meanzero_loglik_+3A_covfun_name">covfun_name</code></td>
<td>
<p>See <code><a href="#topic+GpGp">GpGp</a></code> for information about covariance
functions.</p>
</td></tr>
<tr><td><code id="vecchia_meanzero_loglik_+3A_y">y</code></td>
<td>
<p>vector of response values</p>
</td></tr>
<tr><td><code id="vecchia_meanzero_loglik_+3A_locs">locs</code></td>
<td>
<p>matrix of locations. Row <code>i</code> of <code>locs</code> specifies the location
of element <code>i</code> of <code>y</code>, and so the length of <code>y</code> should equal
the number of rows of <code>locs</code>.</p>
</td></tr>
<tr><td><code id="vecchia_meanzero_loglik_+3A_nnarray">NNarray</code></td>
<td>
<p>A matrix of indices, usually the output from <code><a href="#topic+find_ordered_nn">find_ordered_nn</a></code>.
Row <code>i</code> contains the indices
of the observations that observation <code>i</code> conditions on. By convention,
the first element of row <code>i</code> is <code>i</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing
</p>

<ul>
<li> <p><code>loglik</code>: the loglikelihood
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>n1 &lt;- 20
n2 &lt;- 20
n &lt;- n1*n2
locs &lt;- as.matrix( expand.grid( (1:n1)/n1, (1:n2)/n2 ) )
covparms &lt;- c(2, 0.2, 0.75, 0)
y &lt;- fast_Gp_sim(covparms, "matern_isotropic", locs, 50 )
ord &lt;- order_maxmin(locs)
NNarray &lt;- find_ordered_nn(locs,20)
#loglik &lt;- vecchia_meanzero_loglik( covparms, "matern_isotropic", y, locs, NNarray )
</code></pre>

<hr>
<h2 id='vecchia_profbeta_loglik'>Vecchia's approximation to the Gaussian loglikelihood, with profiled 
regression coefficients.</h2><span id='topic+vecchia_profbeta_loglik'></span>

<h3>Description</h3>

<p>This function returns Vecchia's (1988) approximation to the Gaussian
loglikelihood, profiling out the regression coefficients. 
The approximation modifies the ordered conditional
specification of the joint density; rather than each term in the product
conditioning on all previous observations, each term conditions on
a small subset of previous observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vecchia_profbeta_loglik(covparms, covfun_name, y, X, locs, NNarray)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vecchia_profbeta_loglik_+3A_covparms">covparms</code></td>
<td>
<p>A vector of covariance parameters appropriate
for the specified covariance function</p>
</td></tr>
<tr><td><code id="vecchia_profbeta_loglik_+3A_covfun_name">covfun_name</code></td>
<td>
<p>See <code><a href="#topic+GpGp">GpGp</a></code> for information about covariance
functions.</p>
</td></tr>
<tr><td><code id="vecchia_profbeta_loglik_+3A_y">y</code></td>
<td>
<p>vector of response values</p>
</td></tr>
<tr><td><code id="vecchia_profbeta_loglik_+3A_x">X</code></td>
<td>
<p>Design matrix of covariates. Row <code>i</code> of <code>X</code> contains
the covariates for the observation at row <code>i</code> of <code>locs</code>.</p>
</td></tr>
<tr><td><code id="vecchia_profbeta_loglik_+3A_locs">locs</code></td>
<td>
<p>matrix of locations. Row <code>i</code> of <code>locs</code> specifies the location
of element <code>i</code> of <code>y</code>, and so the length of <code>y</code> should equal
the number of rows of <code>locs</code>.</p>
</td></tr>
<tr><td><code id="vecchia_profbeta_loglik_+3A_nnarray">NNarray</code></td>
<td>
<p>A matrix of indices, usually the output from <code><a href="#topic+find_ordered_nn">find_ordered_nn</a></code>.
Row <code>i</code> contains the indices
of the observations that observation <code>i</code> conditions on. By convention,
the first element of row <code>i</code> is <code>i</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing
</p>

<ul>
<li> <p><code>loglik</code>: the loglikelihood
</p>
</li>
<li> <p><code>betahat</code>: profile likelihood estimate of regression coefficients
</p>
</li>
<li> <p><code>betainfo</code>: information matrix for <code>betahat</code>.
</p>
</li></ul>

<p>The covariance
matrix for <code>$betahat</code> is the inverse of <code>$betainfo</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n1 &lt;- 20
n2 &lt;- 20
n &lt;- n1*n2
locs &lt;- as.matrix( expand.grid( (1:n1)/n1, (1:n2)/n2 ) )
X &lt;- cbind(rep(1,n),locs[,2])
covparms &lt;- c(2, 0.2, 0.75, 0)
y &lt;- X %*% c(1,2) + fast_Gp_sim(covparms, "matern_isotropic", locs, 50 )
ord &lt;- order_maxmin(locs)
NNarray &lt;- find_ordered_nn(locs,20)
#loglik &lt;- vecchia_profbeta_loglik( covparms, "matern_isotropic", y, X, locs, NNarray )
</code></pre>

<hr>
<h2 id='vecchia_profbeta_loglik_grad_info'>Vecchia's loglikelihood, gradient, and Fisher information</h2><span id='topic+vecchia_profbeta_loglik_grad_info'></span>

<h3>Description</h3>

<p>This function returns Vecchia's (1988) approximation to the Gaussian
loglikelihood, profiling out the regression coefficients, and returning
the gradient and Fisher information. 
Vecchia's approximation modifies the ordered conditional
specification of the joint density; rather than each term in the product
conditioning on all previous observations, each term conditions on
a small subset of previous observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vecchia_profbeta_loglik_grad_info(covparms, covfun_name, y, X, locs, NNarray)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vecchia_profbeta_loglik_grad_info_+3A_covparms">covparms</code></td>
<td>
<p>A vector of covariance parameters appropriate
for the specified covariance function</p>
</td></tr>
<tr><td><code id="vecchia_profbeta_loglik_grad_info_+3A_covfun_name">covfun_name</code></td>
<td>
<p>See <code><a href="#topic+GpGp">GpGp</a></code> for information about covariance
functions.</p>
</td></tr>
<tr><td><code id="vecchia_profbeta_loglik_grad_info_+3A_y">y</code></td>
<td>
<p>vector of response values</p>
</td></tr>
<tr><td><code id="vecchia_profbeta_loglik_grad_info_+3A_x">X</code></td>
<td>
<p>Design matrix of covariates. Row <code>i</code> of <code>X</code> contains
the covariates for the observation at row <code>i</code> of <code>locs</code>.</p>
</td></tr>
<tr><td><code id="vecchia_profbeta_loglik_grad_info_+3A_locs">locs</code></td>
<td>
<p>matrix of locations. Row <code>i</code> of <code>locs</code> specifies the location
of element <code>i</code> of <code>y</code>, and so the length of <code>y</code> should equal
the number of rows of <code>locs</code>.</p>
</td></tr>
<tr><td><code id="vecchia_profbeta_loglik_grad_info_+3A_nnarray">NNarray</code></td>
<td>
<p>A matrix of indices, usually the output from <code><a href="#topic+find_ordered_nn">find_ordered_nn</a></code>.
Row <code>i</code> contains the indices
of the observations that observation <code>i</code> conditions on. By convention,
the first element of row <code>i</code> is <code>i</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing 
</p>

<ul>
<li> <p><code>loglik</code>: the loglikelihood
</p>
</li>
<li> <p><code>grad</code>: gradient with respect to covariance parameters
</p>
</li>
<li> <p><code>info</code>: Fisher information for covariance parameters
</p>
</li>
<li> <p><code>betahat</code>: profile likelihood estimate of regression coefs
</p>
</li>
<li> <p><code>betainfo</code>: information matrix for <code>betahat</code>.
</p>
</li></ul>

<p>The covariance matrix for <code>$betahat</code> is the inverse of <code>$betainfo</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n1 &lt;- 20
n2 &lt;- 20
n &lt;- n1*n2
locs &lt;- as.matrix( expand.grid( (1:n1)/n1, (1:n2)/n2 ) )
X &lt;- cbind(rep(1,n),locs[,2])
covparms &lt;- c(2, 0.2, 0.75, 0)
y &lt;- X %*% c(1,2) + fast_Gp_sim(covparms, "matern_isotropic", locs, 50 )
ord &lt;- order_maxmin(locs)
NNarray &lt;- find_ordered_nn(locs,20)
#loglik &lt;- vecchia_profbeta_loglik_grad_info( covparms, "matern_isotropic", 
#    y, X, locs, NNarray )
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
