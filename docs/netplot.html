<!DOCTYPE html><html><head><title>Help for package netplot</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {netplot}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#colorkey'><p>Function to create a color key</p></a></li>
<li><a href='#colorRamp2'><p>A faster implementation of grDevices::colorRamp for linear interpolation.</p></a></li>
<li><a href='#locate_vertex'><p>Find a vertex in the current plot</p></a></li>
<li><a href='#make_colors'><p>Create a vector of colors for vertices and edges</p></a></li>
<li><a href='#netplot-formulae'><p>Formulas in <code>netplot</code></p></a></li>
<li><a href='#nplot'><p>Plot a network</p></a></li>
<li><a href='#nplot_base'><p><code>nplot</code> using base graphics</p></a></li>
<li><a href='#nplot_legend'><p>Add legend to a netplot object</p></a></li>
<li><a href='#npolygon'><p>n-sided polygons</p>
Calculate the coordinates for an nsided polygon</a></li>
<li><a href='#piechart'><p>A flexible piechart.</p></a></li>
<li><a href='#segments_gradient'><p>Draw segments colored by gradients</p></a></li>
<li><a href='#set_gpar'><p>Set/retrieve graphical parameters of a <code>netplot</code> object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Beautiful Graph Drawing</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2-0</td>
</tr>
<tr>
<td>Description:</td>
<td>A graph visualization engine that puts an emphasis on 
  aesthetics at the same time of providing default parameters that yield
  out-of-the-box-nice visualizations. The package is built on top of
  'The Grid Graphics Package' and seamlessly work with 'igraph' and 
  'network' objects.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0), grid</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grDevices, igraph, network, sna, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, markdown, igraphdata, intergraph, ggraph,
gridGraphics, ggplot2, gridExtra, gridBase, magrittr, tinytest</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/USCCANA/netplot">https://github.com/USCCANA/netplot</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/USCCANA/netplot/issues">https://github.com/USCCANA/netplot/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-18 22:09:44 UTC; george</td>
</tr>
<tr>
<td>Author:</td>
<td>George Vega Yon <a href="https://orcid.org/0000-0002-3171-0844"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Porter Bischoff <a href="https://orcid.org/0009-0004-6742-6281"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>George Vega Yon &lt;g.vegayon@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-19 01:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='colorkey'>Function to create a color key</h2><span id='topic+colorkey'></span>

<h3>Description</h3>

<p>Function to create a color key
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colorkey(
  x0,
  y0,
  x1,
  y1,
  cols = c("white", "steelblue"),
  tick.range = c(0, 1),
  tick.marks = seq(tick.range[1], tick.range[2], length.out = 5L),
  label.from = NULL,
  label.to = NULL,
  nlevels = 100,
  main = NULL,
  relative = TRUE,
  tick.args = list(),
  label.args = list(),
  main.args = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colorkey_+3A_x0">x0</code>, <code id="colorkey_+3A_x1">x1</code>, <code id="colorkey_+3A_y0">y0</code>, <code id="colorkey_+3A_y1">y1</code></td>
<td>
<p>Numeric scalars. Coordinates of the lower left and
upper right points where the color key will be drawn as proportion of
the plotting region.</p>
</td></tr>
<tr><td><code id="colorkey_+3A_cols">cols</code></td>
<td>
<p>Character scalar. Colors specifications to create the
color palette.</p>
</td></tr>
<tr><td><code id="colorkey_+3A_tick.range">tick.range</code>, <code id="colorkey_+3A_tick.marks">tick.marks</code></td>
<td>
<p>Numeric vectors specifying the range and
the tickmarks respectively.</p>
</td></tr>
<tr><td><code id="colorkey_+3A_label.from">label.from</code>, <code id="colorkey_+3A_label.to">label.to</code></td>
<td>
<p>Character scalar. Labels of the lower and
upper values of the color key.</p>
</td></tr>
<tr><td><code id="colorkey_+3A_nlevels">nlevels</code></td>
<td>
<p>Integer scalar. Number of levels to extrapolate.</p>
</td></tr>
<tr><td><code id="colorkey_+3A_main">main</code></td>
<td>
<p>Character scalar. Title of the colorkey.</p>
</td></tr>
<tr><td><code id="colorkey_+3A_relative">relative</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> the color key is drawn relative
to the plotting region area taking <code style="white-space: pre;">&#8288;x0, x1, y0, y1&#8288;</code> as relative location.</p>
</td></tr>
<tr><td><code id="colorkey_+3A_tick.args">tick.args</code>, <code id="colorkey_+3A_label.args">label.args</code>, <code id="colorkey_+3A_main.args">main.args</code></td>
<td>
<p>Lists of arguments passed to
<a href="graphics.html#topic+text">graphics::text</a> for drawing ticks, labels and main respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(22231)

# A random figure
dat &lt;- matrix(runif(100*3), ncol = 3)
col &lt;- colorRamp2(c("blue", "white", "red"))

plot(
  dat[,1], dat[,2],
  col = rgb(col(dat[,3]), maxColorValue=255),
  cex=2, pch=20
  )

# Pretty color key
colorkey(
  x0 = .60, y0 = .80,
  x1 = .95, y1 = .95,
  cols = c("blue", "white", "red"),
  main = "Some color scale"
)
</code></pre>

<hr>
<h2 id='colorRamp2'>A faster implementation of <a href="grDevices.html#topic+colorRamp">grDevices::colorRamp</a> for linear interpolation.</h2><span id='topic+colorRamp2'></span>

<h3>Description</h3>

<p>A faster implementation of <a href="grDevices.html#topic+colorRamp">grDevices::colorRamp</a> for linear interpolation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colorRamp2(x, alpha = TRUE, thresholds = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colorRamp2_+3A_x">x</code></td>
<td>
<p>A vector of colors.</p>
</td></tr>
<tr><td><code id="colorRamp2_+3A_alpha">alpha</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code>
This implementation of <code>colorRamp</code> can be 2 or more times faster than the <code>grDevices</code>
version. It is intended for consecutive calls (i.e. in a loop) to improve
performance. It is equivalent to the linear interpolation of the function
<code>colorRamp</code>.</p>
</td></tr>
<tr><td><code id="colorRamp2_+3A_thresholds">thresholds</code></td>
<td>
<p>A numeric vector of length <code>length(x)</code>. Optional threshold
levels so that the mixing can be different that even.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function as in <a href="grDevices.html#topic+colorRamp">grDevices::colorRamp</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Creating a function for 2 colors
myf &lt;- colorRamp2(c("black", "steelblue"))
f   &lt;- colorRamp(c("black", "steelblue"))

plot.new()
plot.window(xlim = c(0,2), ylim = c(1, 11))

# These should be the same colors
rect(
  xleft   = 0,
  xright  = 1,
  ybottom = 1:10,
  ytop    = 2:11,
  col = rgb(myf((1:10)/10), maxColorValue = 255)
  )
rect(
  xleft   = 1,
  xright  = 2,
  ybottom = 1:10,
  ytop    = 2:11,
  col = rgb(f((1:10)/10), maxColorValue = 255)
)

# Another example setting different thresholds
myf  &lt;- colorRamp2(c("black", "steelblue"))
myf2 &lt;- colorRamp2(c("black", "steelblue"), thresholds=c(0, .7))

plot.new()
plot.window(xlim = c(0,2), ylim = c(1, 11))

# These should be the same colors
rect(
  xleft   = 0,
  xright  = 1,
  ybottom = 1:10,
  ytop    = 2:11,
  col = rgb(myf((1:10)/10), maxColorValue = 255)
  )
rect(
  xleft   = 1,
  xright  = 2,
  ybottom = 1:10,
  ytop    = 2:11,
  col = rgb(myf2((1:10)/10), maxColorValue = 255)
)



</code></pre>

<hr>
<h2 id='locate_vertex'>Find a vertex in the current plot</h2><span id='topic+locate_vertex'></span>

<h3>Description</h3>

<p>This function is a wrapper of <code><a href="grid.html#topic+grid.locator">grid::grid.locator()</a></code>, and provides a way to
find the coordinates of a vertex in the current plot. It is useful to
identify the vertex that is being clicked in a plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locate_vertex(x = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="locate_vertex_+3A_x">x</code></td>
<td>
<p>An object of class <code>netplot</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function only works in interactive mode. Once it is called,
the user can click on a vertex in the plot. The function will return the
name of the vertex, the x and y coordinates and the viewport where it is
located. If <code>x</code> is not specified, the last plotted <code>netplot</code> object will be
used.
</p>


<h3>Value</h3>

<p>A list with the name of the vertex, the x and y coordinates and the
viewport where it is located.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
library(netplot)
set.seed(1)
x &lt;- sample_smallworld(1, 200, 5, 0.03)

# Plotting
nplot(x)

# Clicking (only works in interactive mode)
if (interactive()) {
 res &lt;- locate_vertex()
 print(res)
}

</code></pre>

<hr>
<h2 id='make_colors'>Create a vector of colors for vertices and edges</h2><span id='topic+make_colors'></span><span id='topic+make_edges_colors'></span><span id='topic+make_vertex_colors'></span>

<h3>Description</h3>

<p>Using <code>vertex</code>/<code>edge</code> attributes, these functions return vectors of colors
that can be used either during the creation of the <a href="#topic+nplot">nplot</a> object, or
afterwards when changing <code>gpar</code> (graphical parameter) values with <a href="#topic+set_gpar">set_gpar</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_colors(dat, categorical = FALSE, color_map = grDevices::hcl.colors)

make_edges_colors(x, eattr, ...)

make_vertex_colors(x, vattr, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_colors_+3A_dat">dat</code></td>
<td>
<p>A vector of data to generate the color from.</p>
</td></tr>
<tr><td><code id="make_colors_+3A_categorical">categorical</code></td>
<td>
<p>Logical. When <code>TRUE</code> sets the colors as categories.</p>
</td></tr>
<tr><td><code id="make_colors_+3A_color_map">color_map</code></td>
<td>
<p>A function to generate a palette.</p>
</td></tr>
<tr><td><code id="make_colors_+3A_x">x</code></td>
<td>
<p>A graph of class <code>network</code> or <code>igraph</code>.</p>
</td></tr>
<tr><td><code id="make_colors_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>make_colors</code>.</p>
</td></tr>
<tr><td><code id="make_colors_+3A_vattr">vattr</code>, <code id="make_colors_+3A_eattr">eattr</code></td>
<td>
<p>Character. Names of either vertex or edge variables to be
used for generating the colors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no attribute is provided, then by defaul the colors are set according to
indegree.
</p>
<p><code>x</code> can be either a graph of class <code>igraph</code> or <code>network</code>.
</p>


<h3>Value</h3>

<p>A vector of colors with the attribute <code>color_map</code>. The color map used
to generate the colors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(UKfaculty, package="igraphdata")
col &lt;- make_vertex_colors(UKfaculty, "Group")

if (require(magrittr)) {

  nplot(UKfaculty) %&gt;%
    set_vertex_gpar("core", fill = col, col=col) %&gt;%
    set_vertex_gpar("frame", fill = col, col=col, alpha=.7) %&gt;%
    set_edge_gpar(col="gray50", fill="gray50", alpha=.5)
}
</code></pre>

<hr>
<h2 id='netplot-formulae'>Formulas in <code>netplot</code></h2><span id='topic+netplot-formulae'></span><span id='topic+color_formula'></span><span id='topic+ego'></span><span id='topic+alter'></span>

<h3>Description</h3>

<p>Edge colors in both <code><a href="#topic+nplot">nplot()</a></code> and <code><a href="#topic+set_edge_gpar">set_edge_gpar()</a></code> can be specified using
a formula based on <code>ego()</code> and <code>alter()</code> (source and target). This way the
user can set various types of combination varying the mixing of the colors,
the alpha levels, and the actual mixing colors to create edge colors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>color_formula(x, col, alpha, env, type, mix = 1, postfix = NULL)

ego(...)

alter(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="netplot-formulae_+3A_x">x</code></td>
<td>
<p>An object of class <a href="#topic+netplot">netplot</a>.</p>
</td></tr>
<tr><td><code id="netplot-formulae_+3A_col">col</code></td>
<td>
<p>Any valid color. Can be a single color or a vector.</p>
</td></tr>
<tr><td><code id="netplot-formulae_+3A_alpha">alpha</code></td>
<td>
<p>Number. Alpha levels</p>
</td></tr>
<tr><td><code id="netplot-formulae_+3A_env">env</code>, <code id="netplot-formulae_+3A_type">type</code>, <code id="netplot-formulae_+3A_postfix">postfix</code></td>
<td>
<p>For internal use only.</p>
</td></tr>
<tr><td><code id="netplot-formulae_+3A_mix">mix</code></td>
<td>
<p>Number. For mixing colors between <code>ego</code> and <code>alter</code></p>
</td></tr>
<tr><td><code id="netplot-formulae_+3A_...">...</code></td>
<td>
<p>Passed to <code>color_formula</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing. These functions are called internally when using
formulas. <code>color_formula</code> modifies the environment <code>env</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(gridExtra) &amp; require(magrittr)) {
  library(igraph)
  net &lt;- make_ring(4)

  set.seed(1)
  np &lt;- nplot(net, vertex.color = grDevices::hcl.colors(4), vertex.size.range=c(.1, .1))
  np %&lt;&gt;% set_edge_gpar(lwd = 4)

  grid.arrange(
    np,
    np %&gt;% set_edge_gpar(col =~ego + alter),
    np %&gt;% set_edge_gpar(col =~ego(alpha=0) + alter),
    np %&gt;% set_edge_gpar(col =~ego + alter(alpha=0)),
    np %&gt;% set_edge_gpar(col =~ego(mix=0) + alter(mix=1)),
    np %&gt;% set_edge_gpar(col =~ego(mix=1) + alter(mix=0))
  )
}
</code></pre>

<hr>
<h2 id='nplot'>Plot a network</h2><span id='topic+nplot'></span><span id='topic+netplot'></span><span id='topic+nplot.igraph'></span><span id='topic+nplot.network'></span><span id='topic+nplot.matrix'></span><span id='topic+nplot.default'></span><span id='topic+print.netplot'></span>

<h3>Description</h3>

<p>This is a description.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nplot(x, ..., edgelist)

## S3 method for class 'igraph'
nplot(
  x,
  layout = igraph::layout_nicely(x),
  vertex.size = igraph::degree(x, mode = "in"),
  vertex.label = igraph::vertex_attr(x, "name"),
  edge.width = igraph::edge_attr(x, "weight"),
  skip.arrows = !igraph::is_directed(x),
  ...,
  edgelist = NULL
)

## S3 method for class 'network'
nplot(
  x,
  layout = sna::gplot.layout.kamadakawai(x, NULL),
  vertex.size = sna::degree(x, cmode = "indegree"),
  vertex.label = network::get.vertex.attribute(x, "vertex.names"),
  skip.arrows = !network::is.directed(x),
  ...,
  edgelist = NULL
)

## S3 method for class 'matrix'
nplot(x, ..., edgelist = NULL)

## Default S3 method:
nplot(
  x,
  layout,
  vertex.size = 1,
  bg.col = "transparent",
  vertex.nsides = 10,
  vertex.color = grDevices::hcl.colors(1),
  vertex.size.range = c(0.01, 0.03),
  vertex.frame.color = NULL,
  vertex.rot = 0,
  vertex.frame.prop = 0.2,
  vertex.label = NULL,
  vertex.label.fontsize = NULL,
  vertex.label.color = "black",
  vertex.label.fontfamily = "HersheySans",
  vertex.label.fontface = "bold",
  vertex.label.show = 0.3,
  vertex.label.range = c(5, 15),
  edge.width = 1,
  edge.width.range = c(1, 2),
  edge.arrow.size = NULL,
  edge.color = ~ego(alpha = 0.1, col = "gray") + alter,
  edge.curvature = pi/3,
  edge.line.lty = "solid",
  edge.line.breaks = 5,
  sample.edges = 1,
  skip.vertex = FALSE,
  skip.edges = FALSE,
  skip.arrows = skip.edges,
  add = FALSE,
  zero.margins = TRUE,
  ...,
  edgelist
)

## S3 method for class 'netplot'
print(x, y = NULL, newpage = TRUE, legend = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nplot_+3A_x">x</code></td>
<td>
<p>A graph. It supports networks stored as <code>igraph</code>, <code>network</code>, and
matrices objects (see details).</p>
</td></tr>
<tr><td><code id="nplot_+3A_edgelist">edgelist</code></td>
<td>
<p>An edgelist.</p>
</td></tr>
<tr><td><code id="nplot_+3A_layout">layout</code></td>
<td>
<p>Numeric two-column matrix with the graph layout in x/y positions of the vertices.</p>
</td></tr>
<tr><td><code id="nplot_+3A_vertex.size">vertex.size</code></td>
<td>
<p>Numeric vector of length <code>vcount(x)</code>. Absolute size of the vertex from 0 to 1.</p>
</td></tr>
<tr><td><code id="nplot_+3A_vertex.label">vertex.label</code></td>
<td>
<p>Character vector of length <code>vcount(x)</code>. Labels.</p>
</td></tr>
<tr><td><code id="nplot_+3A_edge.width">edge.width</code></td>
<td>
<p>Vector of length <code>ecount(x)</code> from 0 to 1. All edges will be the same size.</p>
</td></tr>
<tr><td><code id="nplot_+3A_bg.col">bg.col</code></td>
<td>
<p>Color of the background.</p>
</td></tr>
<tr><td><code id="nplot_+3A_vertex.nsides">vertex.nsides</code></td>
<td>
<p>Numeric vector of length <code>vcount(x)</code>. Number of sizes of
the vertex. E.g. three is a triangle, and 100 approximates a circle.</p>
</td></tr>
<tr><td><code id="nplot_+3A_vertex.color">vertex.color</code></td>
<td>
<p>Vector of length <code>vcount(x)</code>. Vertex HEX or built in colors.</p>
</td></tr>
<tr><td><code id="nplot_+3A_vertex.size.range">vertex.size.range</code></td>
<td>
<p>Vector of length <code>vcount(x)</code> from 0 to 1.</p>
</td></tr>
<tr><td><code id="nplot_+3A_vertex.frame.color">vertex.frame.color</code></td>
<td>
<p>Vector of length <code>vcount(x)</code>. Border of vertex in HEX or built in colors.</p>
</td></tr>
<tr><td><code id="nplot_+3A_vertex.rot">vertex.rot</code></td>
<td>
<p>Vector of length <code>vcount(x)</code> in Radians. Passed to <a href="#topic+npolygon">npolygon</a>,
elevation degree from which the polygon is drawn.</p>
</td></tr>
<tr><td><code id="nplot_+3A_vertex.frame.prop">vertex.frame.prop</code></td>
<td>
<p>Vector of length <code>vcount(x)</code>. What proportion of the
vertex does the frame occupy (values between 0 and 1).</p>
</td></tr>
<tr><td><code id="nplot_+3A_vertex.label.fontsize">vertex.label.fontsize</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="nplot_+3A_vertex.label.color">vertex.label.color</code></td>
<td>
<p>Vector of colors of length <code>vcount(x)</code>.</p>
</td></tr>
<tr><td><code id="nplot_+3A_vertex.label.fontfamily">vertex.label.fontfamily</code></td>
<td>
<p>Character vector of length <code>vcount(x)</code>.</p>
</td></tr>
<tr><td><code id="nplot_+3A_vertex.label.fontface">vertex.label.fontface</code></td>
<td>
<p>See <a href="grid.html#topic+gpar">grid::gpar</a></p>
</td></tr>
<tr><td><code id="nplot_+3A_vertex.label.show">vertex.label.show</code></td>
<td>
<p>Numeric scalar. Proportion of labels to show as the
top ranking according to <code>vertex.size</code>.</p>
</td></tr>
<tr><td><code id="nplot_+3A_vertex.label.range">vertex.label.range</code></td>
<td>
<p>Numeric vector of size 2 or 3. Relative scale of
<code>vertex.label.fontsize</code> in points (see <a href="grid.html#topic+gpar">grid::gpar</a>).</p>
</td></tr>
<tr><td><code id="nplot_+3A_edge.width.range">edge.width.range</code></td>
<td>
<p>Vector of length <code>ecount(x)</code> from 0 to 1. Adjusting width according to weight.</p>
</td></tr>
<tr><td><code id="nplot_+3A_edge.arrow.size">edge.arrow.size</code></td>
<td>
<p>Vector of length <code>ecount(x)</code> from 0 to 1.</p>
</td></tr>
<tr><td><code id="nplot_+3A_edge.color">edge.color</code></td>
<td>
<p>A vector of length <code>ecount(x)</code>. In HEX or built in colors. Can be <code>NULL</code> in which case
the color is picked as a mixture between ego and alters' <code>vertex.color</code> values.</p>
</td></tr>
<tr><td><code id="nplot_+3A_edge.curvature">edge.curvature</code></td>
<td>
<p>Numeric vector of length <code>ecount(x)</code>. Curvature of edges
in terms of radians.</p>
</td></tr>
<tr><td><code id="nplot_+3A_edge.line.lty">edge.line.lty</code></td>
<td>
<p>Vector of length <code>ecount(x)</code>. Line types in R (e.g.- 1 = Solid, 2 = Dashed, etc)</p>
</td></tr>
<tr><td><code id="nplot_+3A_edge.line.breaks">edge.line.breaks</code></td>
<td>
<p>Vector of length <code>ecount(x)</code>. Number of vertices to
draw (approximate) the arc (edge).</p>
</td></tr>
<tr><td><code id="nplot_+3A_sample.edges">sample.edges</code></td>
<td>
<p>Numeric scalar between 0 and 1. Proportion of edges to sample.</p>
</td></tr>
<tr><td><code id="nplot_+3A_skip.vertex">skip.vertex</code>, <code id="nplot_+3A_skip.edges">skip.edges</code>, <code id="nplot_+3A_skip.arrows">skip.arrows</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> the object
is not plotted.</p>
</td></tr>
<tr><td><code id="nplot_+3A_add">add</code></td>
<td>
<p>Logical scalar.</p>
</td></tr>
<tr><td><code id="nplot_+3A_zero.margins">zero.margins</code></td>
<td>
<p>Logical scalar.</p>
</td></tr>
<tr><td><code id="nplot_+3A_y">y</code>, <code id="nplot_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="nplot_+3A_newpage">newpage</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> calls <a href="grid.html#topic+grid.newpage">grid::grid.newpage</a>.</p>
</td></tr>
<tr><td><code id="nplot_+3A_legend">legend</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> it adds a legend.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>x</code> is of class <a href="base.html#topic+matrix">matrix</a>, it will be passed to <code><a href="igraph.html#topic+graph_from_adjacency_matrix">igraph::graph_from_adjacency_matrix()</a></code>.
</p>
<p>In the case of <code>edge.color</code>, the user can specify colors using <a href="#topic+netplot-formulae">netplot-formulae</a>.
</p>


<h3>Value</h3>

<p>An object of class <code>c("netplot", "gTree", "grob", "gDesc")</code>. The object
has an additional set of attributes:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;.xlim, .ylim&#8288;</code> vector of size two with the x-asis/y-axis limits.
</p>
</li>
<li> <p><code>.layout</code> A numeric matrix of size <code>vcount(x) * 2</code> with the vertices positions
</p>
</li>
<li> <p><code>.edgelist</code> A numeric matrix, The edgelist.
</p>
</li></ul>

<p>In the case of <code>nplot.default</code>, an object of class <code>netplot</code> and <code>grob</code> (see
<a href="grid.html#topic+grid.grob">grid::grob</a>) with the following slots:
</p>

<ul>
<li> <p><code>children</code> The main <code>grob</code> of the object.
</p>
</li>
<li> <p><code>name</code> Character scalar. The name of the plot
</p>
</li>
<li> <p><code>.xlim</code> and <code>.ylim</code> Two vectors indicating the limits of the plot
</p>
</li>
<li> <p><code>.layout</code> A two-column matrix with the location of the vertices.
</p>
</li>
<li> <p><code>.edgelist</code> A two-column matrix, an edgelist.
</p>
</li>
<li> <p><code>.N</code> Integer. The number of vertices.
</p>
</li>
<li> <p><code>.M</code> Integer. The number of edges.
</p>
</li></ul>

<p>The <code>children</code> <code>grob</code> contains the following two objects:
</p>

<ul>
<li> <p><code>background</code> a <code>grob</code> rectangule.
</p>
</li>
<li> <p><code>graph</code> a <code>gTree</code> that contains each vertex and each edge
of the figure.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+nplot_base">nplot_base</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
library(netplot)
set.seed(1)
x &lt;- sample_smallworld(1, 200, 5, 0.03)

plot(x) # ala igraph
nplot(x) # ala netplot
</code></pre>

<hr>
<h2 id='nplot_base'><code>nplot</code> using base graphics</h2><span id='topic+nplot_base'></span>

<h3>Description</h3>

<p><code>nplot</code> using base graphics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nplot_base(
  x,
  layout = igraph::layout_nicely(x),
  vertex.size = igraph::degree(x, mode = "in"),
  bg.col = "transparent",
  vertex.nsides = 10,
  vertex.color = grDevices::hcl.colors(1),
  vertex.size.range = c(0.01, 0.03),
  vertex.frame.color = grDevices::adjustcolor(vertex.color, red.f = 0.75, green.f = 0.75,
    blue.f = 0.75),
  vertex.rot = 0,
  vertex.frame.prop = 0.1,
  edge.width = NULL,
  edge.width.range = c(1, 2),
  edge.arrow.size = NULL,
  edge.color = NULL,
  edge.color.mix = 0.5,
  edge.color.alpha = c(0.1, 0.5),
  edge.curvature = pi/3,
  edge.line.lty = "solid",
  edge.line.breaks = 5,
  sample.edges = 1,
  skip.vertex = FALSE,
  skip.edges = FALSE,
  skip.arrows = skip.edges,
  add = FALSE,
  zero.margins = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nplot_base_+3A_x">x</code></td>
<td>
<p>A graph. It supports networks stored as <code>igraph</code>, <code>network</code>, and
matrices objects (see details).</p>
</td></tr>
<tr><td><code id="nplot_base_+3A_layout">layout</code></td>
<td>
<p>Numeric two-column matrix with the graph layout in x/y positions of the vertices.</p>
</td></tr>
<tr><td><code id="nplot_base_+3A_vertex.size">vertex.size</code></td>
<td>
<p>Numeric vector of length <code>vcount(x)</code>. Absolute size of the vertex from 0 to 1.</p>
</td></tr>
<tr><td><code id="nplot_base_+3A_bg.col">bg.col</code></td>
<td>
<p>Color of the background.</p>
</td></tr>
<tr><td><code id="nplot_base_+3A_vertex.nsides">vertex.nsides</code></td>
<td>
<p>Numeric vector of length <code>vcount(x)</code>. Number of sizes of
the vertex. E.g. three is a triangle, and 100 approximates a circle.</p>
</td></tr>
<tr><td><code id="nplot_base_+3A_vertex.color">vertex.color</code></td>
<td>
<p>Vector of length <code>vcount(x)</code>. Vertex HEX or built in colors.</p>
</td></tr>
<tr><td><code id="nplot_base_+3A_vertex.size.range">vertex.size.range</code></td>
<td>
<p>Vector of length <code>vcount(x)</code> from 0 to 1.</p>
</td></tr>
<tr><td><code id="nplot_base_+3A_vertex.frame.color">vertex.frame.color</code></td>
<td>
<p>Vector of length <code>vcount(x)</code>. Border of vertex in HEX or built in colors.</p>
</td></tr>
<tr><td><code id="nplot_base_+3A_vertex.rot">vertex.rot</code></td>
<td>
<p>Vector of length <code>vcount(x)</code> in Radians. Passed to <a href="#topic+npolygon">npolygon</a>,
elevation degree from which the polygon is drawn.</p>
</td></tr>
<tr><td><code id="nplot_base_+3A_vertex.frame.prop">vertex.frame.prop</code></td>
<td>
<p>Vector of length <code>vcount(x)</code>. What proportion of the
vertex does the frame occupy (values between 0 and 1).</p>
</td></tr>
<tr><td><code id="nplot_base_+3A_edge.width">edge.width</code></td>
<td>
<p>Vector of length <code>ecount(x)</code> from 0 to 1. All edges will be the same size.</p>
</td></tr>
<tr><td><code id="nplot_base_+3A_edge.width.range">edge.width.range</code></td>
<td>
<p>Vector of length <code>ecount(x)</code> from 0 to 1. Adjusting width according to weight.</p>
</td></tr>
<tr><td><code id="nplot_base_+3A_edge.arrow.size">edge.arrow.size</code></td>
<td>
<p>Vector of length <code>ecount(x)</code> from 0 to 1.</p>
</td></tr>
<tr><td><code id="nplot_base_+3A_edge.color">edge.color</code></td>
<td>
<p>A vector of length <code>ecount(x)</code>. In HEX or built in colors. Can be <code>NULL</code> in which case
the color is picked as a mixture between ego and alters' <code>vertex.color</code> values.</p>
</td></tr>
<tr><td><code id="nplot_base_+3A_edge.color.mix">edge.color.mix</code></td>
<td>
<p>Proportion of the mixing.</p>
</td></tr>
<tr><td><code id="nplot_base_+3A_edge.color.alpha">edge.color.alpha</code></td>
<td>
<p>Either a vector of length 1 or 2, or a matrix of
size <code>ecount(x)*2</code> with values in <code style="white-space: pre;">&#8288;[0,1]&#8288;</code>. Alpha (transparency) levels (see
details)</p>
</td></tr>
<tr><td><code id="nplot_base_+3A_edge.curvature">edge.curvature</code></td>
<td>
<p>Numeric vector of length <code>ecount(x)</code>. Curvature of edges
in terms of radians.</p>
</td></tr>
<tr><td><code id="nplot_base_+3A_edge.line.lty">edge.line.lty</code></td>
<td>
<p>Vector of length <code>ecount(x)</code>. Line types in R (e.g.- 1 = Solid, 2 = Dashed, etc)</p>
</td></tr>
<tr><td><code id="nplot_base_+3A_edge.line.breaks">edge.line.breaks</code></td>
<td>
<p>Vector of length <code>ecount(x)</code>. Number of vertices to
draw (approximate) the arc (edge).</p>
</td></tr>
<tr><td><code id="nplot_base_+3A_sample.edges">sample.edges</code></td>
<td>
<p>Numeric scalar between 0 and 1. Proportion of edges to sample.</p>
</td></tr>
<tr><td><code id="nplot_base_+3A_skip.vertex">skip.vertex</code>, <code id="nplot_base_+3A_skip.edges">skip.edges</code>, <code id="nplot_base_+3A_skip.arrows">skip.arrows</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> the object
is not plotted.</p>
</td></tr>
<tr><td><code id="nplot_base_+3A_add">add</code></td>
<td>
<p>Logical scalar.</p>
</td></tr>
<tr><td><code id="nplot_base_+3A_zero.margins">zero.margins</code></td>
<td>
<p>Logical scalar.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>nplot_base</code> returns a list with the following components:
</p>

<ul>
<li> <p><code>vertex.coords</code> A list of length <code>N</code> where each element describes the
geomtry of each vertex.
</p>
</li>
<li> <p><code>vertex.color</code> A vector of colors
</p>
</li>
<li> <p><code>vertex.frame.coords</code> Similar to <code>vertex.coords</code>, but for the frame.
</p>
</li>
<li> <p><code>vertex.frame.color</code> Similar to <code>vertex.color</code>, but for the frame.
</p>
</li>
<li> <p><code>edge.color</code> Vector of functions used to compute the edge colors.
</p>
</li>
<li> <p><code>edge.coords</code> Similar to <code>vertex.coords</code>, the points that describe each
edge.
</p>
</li>
<li> <p><code>edge.arrow.coords</code> A list of matrices describing the geometry of the
tip of the edges.
</p>
</li>
<li> <p><code>edge.width</code> A numeric vector with edges' widths.
</p>
</li>
<li> <p><code>xlim</code>, <code>ylim</code> Limits of the plot area.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+nplot">nplot</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Same example as in nplot
library(igraph)
library(netplot)
set.seed(1)
x &lt;- sample_smallworld(1, 200, 5, 0.03)

nplot_base(x) # ala netplot (using base)
</code></pre>

<hr>
<h2 id='nplot_legend'>Add legend to a netplot object</h2><span id='topic+nplot_legend'></span><span id='topic+print.netplot_legend'></span>

<h3>Description</h3>

<p>Legends in <a href="graphics.html#topic+grid">grid</a> graphics is a bit more complicated than in base graphics.
The function <code>nplot_legend</code> is a wrapper of <code><a href="grid.html#topic+legendGrob">grid::legendGrob()</a></code> that makes
the process easier. Besides <code>labels</code>, the main visual arguments for the
figure ar passed through the <code>gp</code> argument (see examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nplot_legend(
  g,
  labels,
  pch,
  gp = grid::gpar(),
  ...,
  packgrob.args = list(side = "left")
)

## S3 method for class 'netplot_legend'
print(x, y = NULL, newpage = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nplot_legend_+3A_g">g</code></td>
<td>
<p>An object of class <a href="#topic+netplot">netplot</a>.</p>
</td></tr>
<tr><td><code id="nplot_legend_+3A_labels">labels</code></td>
<td>
<p>Character vector of labels.</p>
</td></tr>
<tr><td><code id="nplot_legend_+3A_pch">pch</code></td>
<td>
<p>See <code><a href="graphics.html#topic+points">graphics::points()</a></code>.</p>
</td></tr>
<tr><td><code id="nplot_legend_+3A_gp">gp</code></td>
<td>
<p>An object of class <code><a href="grid.html#topic+gpar">grid::gpar()</a></code></p>
</td></tr>
<tr><td><code id="nplot_legend_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="grid.html#topic+legendGrob">grid::legendGrob()</a></code>.</p>
</td></tr>
<tr><td><code id="nplot_legend_+3A_packgrob.args">packgrob.args</code></td>
<td>
<p>List of arguments passed to <code><a href="grid.html#topic+grid.pack">grid::packGrob()</a></code>.</p>
</td></tr>
<tr><td><code id="nplot_legend_+3A_x">x</code></td>
<td>
<p>An object of class <code>netplot_legend</code>.</p>
</td></tr>
<tr><td><code id="nplot_legend_+3A_y">y</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="nplot_legend_+3A_newpage">newpage</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> it calls <code><a href="grid.html#topic+grid.newpage">grid::grid.newpage()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A frame grob.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
library(netplot)
set.seed(1)
x &lt;- sample_smallworld(1, 200, 5, 0.03)
V(x)$nsides &lt;- sample(c(10, 4), 200, replace = TRUE)

g &lt;- nplot(
  x,
  vertex.nsides = V(x)$nsides,
  vertex.color  = ifelse(V(x)$nsides == 4, "red", "steelblue"),
  edge.line.breaks = 5
  )

nplot_legend(
  g,
  labels = c("circle", "diamond", "edge"),
  pch    = c(21, 23, NA),
  gp     = gpar(
    fill = c("steelblue", "red", NA),
    lwd  = c(NA, NA, 1),
    col  = c(NA, NA, "purple")
    )
  )
grid.text("Legend to the left (default)", y = unit(.95, "npc"), just = "bottom")

nplot_legend(
  g,
  labels = c("circle", "diamond", "edge"),
  pch    = c(21, 23, NA),
  gp     = gpar(
    fill = c("steelblue", "red", NA),
    lwd  = c(NA, NA, 1),
    col  = c(NA, NA, "purple")
    ),
  # These two extra options set the legend to the bottom
  packgrob.args = list(side = "bottom"),
  ncol = 3
  )
grid.text("Legend bottom", y = unit(.95, "npc"), just = "bottom")


</code></pre>

<hr>
<h2 id='npolygon'>n-sided polygons
Calculate the coordinates for an nsided polygon</h2><span id='topic+npolygon'></span>

<h3>Description</h3>

<p>n-sided polygons
Calculate the coordinates for an nsided polygon
</p>


<h3>Usage</h3>

<pre><code class='language-R'>npolygon(x = 0, y = 0, n = 6L, r = 1, d = 2 * pi/(n)/2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="npolygon_+3A_x">x</code>, <code id="npolygon_+3A_y">y</code></td>
<td>
<p>Numeric scalar. Origin of the polygon.</p>
</td></tr>
<tr><td><code id="npolygon_+3A_n">n</code></td>
<td>
<p>Integer scalar. Number of sides.</p>
</td></tr>
<tr><td><code id="npolygon_+3A_r">r</code></td>
<td>
<p>Numeric scalar. Radious of the polygon.</p>
</td></tr>
<tr><td><code id="npolygon_+3A_d">d</code></td>
<td>
<p>Numeric scalar. Starting degree in radians.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A two column matrix with the coordinates to draw a n sided polygon.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>graphics.off()
oldpar &lt;- par(no.readonly = TRUE)

par(xpd = NA, mfrow = c(3, 3), mai = rep(0, 4))
for (n in c(2, 3, 4, 5, 6, 8, 12, 20, 50)) {

  plot.new()
  plot.window(c(-1.25,1.25), c(-1.25,1.25))

  for (i in seq(1, .0005, length.out = 200)) {
    col &lt;- adjustcolor("tomato", alpha.f = i)
    polygon(npolygon(x=(i-1)/4, y = (i-1)/4, r = i, d = i-1, n = n),
            col = NA, border=col)
  }

  mtext(sprintf("n = %i", n), side = 1, line = -3)
}

par(oldpar)
</code></pre>

<hr>
<h2 id='piechart'>A flexible piechart.</h2><span id='topic+piechart'></span>

<h3>Description</h3>

<p>While similar to <code><a href="graphics.html#topic+pie">graphics::pie()</a></code>, this function is much more
flexible as it allows providing different parameters for each slice of the pie.
Furthermore, it allows adding the plot to the current device, making it possible
to create compound piecharts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>piechart(
  x,
  labels = names(x),
  radius = 1,
  doughnut = 0,
  origin = c(0, 0),
  edges = 200,
  slice.off = 0,
  init.angle = 0,
  last.angle = 360,
  tick.len = 0.1,
  text.args = list(),
  segments.args = list(),
  skip.plot.slices = FALSE,
  add = FALSE,
  rescale = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="piechart_+3A_x">x</code></td>
<td>
<p>Numeric vector. Values that specify the area of the slices.</p>
</td></tr>
<tr><td><code id="piechart_+3A_labels">labels</code></td>
<td>
<p>Character vector of length <code>length(x)</code>. Passed to
<code><a href="graphics.html#topic+text">graphics::text()</a></code>.</p>
</td></tr>
<tr><td><code id="piechart_+3A_radius">radius</code></td>
<td>
<p>Numeric vector. Radious of each slice (can be a scalar).</p>
</td></tr>
<tr><td><code id="piechart_+3A_doughnut">doughnut</code></td>
<td>
<p>Numeric scalar. Radious of each inner circle (doughnut) (can be a scalar).</p>
</td></tr>
<tr><td><code id="piechart_+3A_origin">origin</code></td>
<td>
<p>Numeric vector of length 2. Coordinates of the origin.</p>
</td></tr>
<tr><td><code id="piechart_+3A_edges">edges</code></td>
<td>
<p>Numeric scalar. Smoothness of the slices curve (can be a vector).</p>
</td></tr>
<tr><td><code id="piechart_+3A_slice.off">slice.off</code></td>
<td>
<p>Numeric vector. When <code style="white-space: pre;">&#8288;!=0&#8288;</code>, specifies how much to
move the slice away from the origin. When scalar is recycled.</p>
</td></tr>
<tr><td><code id="piechart_+3A_init.angle">init.angle</code></td>
<td>
<p>Numeric scalar. Angle from where to start drawing in degrees.</p>
</td></tr>
<tr><td><code id="piechart_+3A_last.angle">last.angle</code></td>
<td>
<p>Numeric scalar. Angle where to finish drawing in degrees.</p>
</td></tr>
<tr><td><code id="piechart_+3A_tick.len">tick.len</code></td>
<td>
<p>Numeric scalar. Size of the tick marks as proportion of the radius.</p>
</td></tr>
<tr><td><code id="piechart_+3A_text.args">text.args</code></td>
<td>
<p>List. Further arguments passed to <code><a href="graphics.html#topic+text">graphics::text()</a></code>.</p>
</td></tr>
<tr><td><code id="piechart_+3A_segments.args">segments.args</code></td>
<td>
<p>List. Further arguments passed to <code><a href="graphics.html#topic+segments">graphics::segments()</a></code>
when drawing the tickmarks.</p>
</td></tr>
<tr><td><code id="piechart_+3A_skip.plot.slices">skip.plot.slices</code></td>
<td>
<p>Logical scalar. When <code>FALSE</code>, slices are not drawn.
This can be useful if, for example, the user only wants to draw the labels.</p>
</td></tr>
<tr><td><code id="piechart_+3A_add">add</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> it is added to the current device.</p>
</td></tr>
<tr><td><code id="piechart_+3A_rescale">rescale</code></td>
<td>
<p>Logical scalar. When <code>TRUE</code> (default), the y-coordinates of
the polygons (slices), text and tickmarks will be rescaled such that the
aspectt ratio is preserved, i.e. looks like a circle.</p>
</td></tr>
<tr><td><code id="piechart_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="graphics.html#topic+polygon">graphics::polygon()</a></code>
(see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is a wrapper of <code><a href="graphics.html#topic+polygon">graphics::polygon()</a></code>,
so all parameters such as color, density, border, etc. are passed directly
by <code><a href="base.html#topic+mapply">mapply()</a></code> so that are specified one per slice. The coordinates
of the slices are computed internally.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>slices</code></td>
<td>
<p>A list of length <code>length(x)</code> with the coordinates of each
slice.</p>
</td></tr>
<tr><td><code>textcoords</code></td>
<td>
<p>A numeric matrix of size <code>length(x)*2</code> with
coordinates where the labels can be put at.</p>
</td></tr>
<tr><td><code>alpha0</code></td>
<td>
<p>A numeric vector of size <code>length(x)</code> with the starting
degree in radians of the slice.</p>
</td></tr>
<tr><td><code>alpha1</code></td>
<td>
<p>A numeric vector of size <code>length(x)</code> with the ending
degree in radians of the slice.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>https://commons.wikimedia.org/wiki/File:Nightingale-mortality.jpg
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1 -----------------------------------------------------------------
# A set of 3 nested rings rings starting at 315 deg. and ending at 270 deg.

# Values to plot
vals &lt;- c(1,2,3,10)

# Outer (includes labels)
piechart(vals, col=grDevices::blues9[5:8], border=NA, doughnut = .5,
    radius=.75, labels=vals, init.angle = 315, last.angle = 270)

# Middle
piechart(vals, col=grDevices::blues9[3:6], border=NA, doughnut = .3,
    radius=.5, add=TRUE, init.angle = 315, last.angle = 270)

# Inner
piechart(vals, col=grDevices::blues9[1:4], border="gray", doughnut = .1,
    radius=.3, add=TRUE, init.angle = 315, last.angle = 270)

# Example 2 -----------------------------------------------------------------
# Passing values to polygon and playing with the radius and slice.off

piechart(1:10, density=(1:10)^2/2, slice.off = (1:10)/30, doughnut = .5,
  radius = sqrt(10:1),
  # Here we are setting random labels...
  labels=sapply(1:10, function(x) paste(sample(letters, x, TRUE), collapse=""))
  )

</code></pre>

<hr>
<h2 id='segments_gradient'>Draw segments colored by gradients</h2><span id='topic+segments_gradient'></span>

<h3>Description</h3>

<p>Draw segments colored by gradients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segments_gradient(
  x,
  y = NULL,
  col = colorRamp2(c("transparent", "black"), TRUE),
  lend = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segments_gradient_+3A_x">x</code>, <code id="segments_gradient_+3A_y">y</code></td>
<td>
<p>Coordinates passed to <a href="grDevices.html#topic+xy.coords">grDevices::xy.coords</a>.</p>
</td></tr>
<tr><td><code id="segments_gradient_+3A_col">col</code></td>
<td>
<p>Color ramp function (see <a href="grDevices.html#topic+colorRamp">grDevices::colorRamp</a>).</p>
</td></tr>
<tr><td><code id="segments_gradient_+3A_lend">lend</code></td>
<td>
<p>Passed to <a href="graphics.html#topic+segments">graphics::segments</a>.</p>
</td></tr>
<tr><td><code id="segments_gradient_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>segments</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>See <a href="graphics.html#topic+segments">graphics::segments</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
x &lt;- cbind(cumsum(rnorm(1e3, sd=.1)), cumsum(rnorm(1e3, sd=.4)))
plot(x, type="n")
segments_gradient(x)
</code></pre>

<hr>
<h2 id='set_gpar'>Set/retrieve graphical parameters of a <code>netplot</code> object</h2><span id='topic+set_gpar'></span><span id='topic+set_edge_gpar'></span><span id='topic+set_vertex_gpar'></span><span id='topic+get_vertex_gpar'></span><span id='topic+get_edge_gpar'></span><span id='topic+get_gpar'></span>

<h3>Description</h3>

<p>Set/retrieve graphical parameters of a <code>netplot</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_gpar(x, type, element, idx, ...)

set_edge_gpar(x, element, idx, ...)

set_vertex_gpar(x, element, idx, ...)

get_vertex_gpar(x, element, ..., idx)

get_edge_gpar(x, element, ..., idx)

get_gpar(x, type, element, ..., idx, simplify = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_gpar_+3A_x">x</code></td>
<td>
<p>An object of class <code>netplot</code>.</p>
</td></tr>
<tr><td><code id="set_gpar_+3A_type">type</code></td>
<td>
<p>Character. Either <code>"edge"</code> or <code>"vertex"</code>.</p>
</td></tr>
<tr><td><code id="set_gpar_+3A_element">element</code></td>
<td>
<p>Character. If <code>"edge"</code>, then it can be either <code>"line"</code> or
<code>"arrow"</code>, otherwise it can be either <code>"core"</code> or <code>"frame"</code>.</p>
</td></tr>
<tr><td><code id="set_gpar_+3A_idx">idx</code></td>
<td>
<p>(optional) Integer vector. Indices of the elements to be modified.
When missing, all elements are modified.</p>
</td></tr>
<tr><td><code id="set_gpar_+3A_...">...</code></td>
<td>
<p>Parameters to be modified/retrieved. This is passed to <a href="grid.html#topic+grid.edit">grid::editGrob</a>
via <a href="grid.html#topic+gpar">grid::gpar</a>.</p>
</td></tr>
<tr><td><code id="set_gpar_+3A_simplify">simplify</code></td>
<td>
<p>Logical. When <code>TRUE</code> it tries to simplify the result.
Otherwise it returns a nested list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>set_edge_gpar</code> and <code>set_vertex_gpar</code> are shorthands for
<code>set_gpar(type = "edge", ...)</code> and <code>set_gpar(type = "vertex", ...)</code>
respectively.
</p>
<p><code>get_edge_gpar</code> and <code>get_vertex_gpar</code> are shorthands for
<code>get_gpar(type = "edge", ...)</code> and <code>get_gpar(type = "vertex", ...)</code>
respectively.
</p>


<h3>Value</h3>

<p>An object of class <code>netplot</code> with modified parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
library(netplot)

x &lt;- make_ring(5)

g &lt;- nplot(x)

# Updating edge color
g &lt;- set_edge_gpar(g, col = "gray80")

# Retrieving the color of the vertices (core)
get_vertex_gpar(g, element = "core", "fill", "lwd")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
