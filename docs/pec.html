<!DOCTYPE html><html lang="en"><head><title>Help for package pec</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pec}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#calPlot'><p>Calibration plots for right censored data</p></a></li>
<li><a href='#cindex'><p>Concordance index for right censored survival time data</p></a></li>
<li><a href='#cost'><p>Copenhagen Stroke Study</p></a></li>
<li><a href='#coxboost'><p>Formula interface for function <code>CoxBoost</code> of package <code>CoxBoost</code>.</p></a></li>
<li><a href='#crps'><p>Summarizing prediction error curves</p></a></li>
<li><a href='#GBSG2'><p>German Breast Cancer Study Group 2</p></a></li>
<li><a href='#ipcw'><p>Estimation of censoring probabilities</p></a></li>
<li><a href='#Pbc3'><p>Pbc3 data</p></a></li>
<li><a href='#pec'><p>Prediction error curves</p></a></li>
<li><a href='#pecCforest'><p>S3-wrapper function for cforest from the party package</p></a></li>
<li><a href='#pecCtree'><p>S3-Wrapper for ctree.</p></a></li>
<li><a href='#pecRpart'><p>Predict survival based on rpart tree object</p></a></li>
<li><a href='#plot.calibrationPlot'><p>Plot objects obtained with <code>calPlot</code></p></a></li>
<li><a href='#plot.pec'><p>Plotting prediction error curves</p></a></li>
<li><a href='#plotPredictEventProb'><p>Plotting predicted survival curves.</p></a></li>
<li><a href='#plotPredictSurvProb'><p>Plotting predicted survival curves.</p></a></li>
<li><a href='#predictEventProb'><p>Predicting event probabilities (cumulative incidences) in competing risk</p>
models.</a></li>
<li><a href='#predictLifeYearsLost'><p>Predicting life years lost (cumulative cumulative incidences) in competing</p>
risk models.</a></li>
<li><a href='#predictRestrictedMeanTime'><p>Predicting restricted mean time</p></a></li>
<li><a href='#predictSurvProb'><p>Predicting survival probabilities</p></a></li>
<li><a href='#print.pec'><p>Printing a &lsquo;pec&rsquo; (prediction error curve) object.</p></a></li>
<li><a href='#R2'><p>Explained variation for survival models</p></a></li>
<li><a href='#reclass'><p>Retrospective risk reclassification table</p></a></li>
<li><a href='#resolvesplitMethod'><p>Resolve the splitMethod for estimation of prediction performance</p></a></li>
<li><a href='#selectCox'><p>Backward variable selection in the Cox regression model</p></a></li>
<li><a href='#simCost'><p>Simulate COST alike data</p></a></li>
<li><a href='#Special'><p>Drawing bootstrapped cross-validation curves and the .632 or .632plus error</p>
of models. The prediction error for an optional benchmark model can be added
together with bootstrapped cross-validation error and apparent errors.</a></li>
<li><a href='#threecity'><p>threecity data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Prediction Error Curves for Risk Prediction Models in Survival
Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>2023.04.12</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas A. Gerds</td>
</tr>
<tr>
<td>Description:</td>
<td>Validation of risk predictions obtained from survival models and
    competing risk models based on censored data using inverse weighting and
    cross-validation. Most of the 'pec' functionality has been moved to 'riskRegression'.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.9.0), prodlim (&ge; 1.4.9)</td>
</tr>
<tr>
<td>Imports:</td>
<td>foreach (&ge; 1.4.2), rms (&ge; 4.2-0), survival (&ge; 2.37-7),
riskRegression (&ge; 2020.02.05), lava (&ge; 1.4.1), timereg (&ge;
1.8.9),</td>
</tr>
<tr>
<td>Suggests:</td>
<td>party, cmprsk (&ge; 2.2-7), rpart, Hmisc (&ge; 3.14-4)</td>
</tr>
<tr>
<td>Enhances:</td>
<td>randomForestSRC</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas A. Gerds &lt;tag@biostat.ku.dk&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-11 11:29:45 UTC; tag</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-11 12:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='calPlot'>Calibration plots for right censored data</h2><span id='topic+calPlot'></span>

<h3>Description</h3>

<p>Calibration plots for risk prediction models in right censored survival and
competing risks data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calPlot(
  object,
  time,
  formula,
  data,
  splitMethod = "none",
  B = 1,
  M,
  pseudo,
  type,
  showPseudo,
  pseudo.col = NULL,
  pseudo.pch = NULL,
  method = "nne",
  round = TRUE,
  bandwidth = NULL,
  q = 10,
  bars = FALSE,
  hanging = FALSE,
  names = "quantiles",
  showFrequencies = FALSE,
  jack.density = 55,
  plot = TRUE,
  add = FALSE,
  diag = !add,
  legend = !add,
  axes = !add,
  xlim = c(0, 1),
  ylim = c(0, 1),
  xlab,
  ylab,
  col,
  lwd,
  lty,
  pch,
  cause = 1,
  percent = TRUE,
  giveToModel = NULL,
  na.action = na.fail,
  cores = 1,
  verbose = FALSE,
  cex = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calPlot_+3A_object">object</code></td>
<td>
<p>A named list of prediction models, where allowed
entries are (1) R-objects for which a <a href="#topic+predictSurvProb">predictSurvProb</a> method
exists (see details), (2) a <code>call</code> that evaluates to such an
R-object (see examples), (3) a matrix with predicted probabilities
having as many rows as <code>data</code> and as many columns as
<code>times</code>. For cross-validation all objects in this list must
include their <code>call</code>.</p>
</td></tr>
<tr><td><code id="calPlot_+3A_time">time</code></td>
<td>
<p>The evaluation time point at predicted event
probabilities are plotted against pseudo-observed event status.</p>
</td></tr>
<tr><td><code id="calPlot_+3A_formula">formula</code></td>
<td>
<p>A survival or event history formula. The left hand
side is used to compute the expected event status. If
<code>formula</code> is <code>missing</code>, try to extract a formula from the
first element in object.</p>
</td></tr>
<tr><td><code id="calPlot_+3A_data">data</code></td>
<td>
<p>A data frame in which to validate the prediction models
and to fit the censoring model. If <code>data</code> is missing, try to
extract a data set from the first element in object.</p>
</td></tr>
<tr><td><code id="calPlot_+3A_splitmethod">splitMethod</code></td>
<td>
<p>Defines the internal validation design:
</p>
<p><code>none/noPlan</code>: Assess the models in the give <code>data</code>, usually
either in the same data where they are fitted, or in independent test data.
</p>
<p><code>BootCv</code>: Bootstrap cross validation. The prediction models
are trained on <code>B</code> bootstrap samples, that are either drawn
with replacement of the same size as the original data or without
replacement from <code>data</code> of the size <code>M</code>.  The models are
assessed in the observations that are NOT in the bootstrap sample.</p>
</td></tr>
<tr><td><code id="calPlot_+3A_b">B</code></td>
<td>
<p>The number of cross-validation steps.</p>
</td></tr>
<tr><td><code id="calPlot_+3A_m">M</code></td>
<td>
<p>The size of the subsamples for cross-validation.</p>
</td></tr>
<tr><td><code id="calPlot_+3A_pseudo">pseudo</code></td>
<td>
<p>Logical. Determines the method for estimating expected event status:
</p>
<p><code>TRUE</code>: Use average pseudo-values.  <code>FALSE</code>: Use
the product-limit estimate, i.e., apply the Kaplan-Meier method for
right censored survival and the Aalen-Johansen method for right
censored competing risks data.</p>
</td></tr>
<tr><td><code id="calPlot_+3A_type">type</code></td>
<td>
<p>Either &quot;risk&quot; or &quot;survival&quot;.</p>
</td></tr>
<tr><td><code id="calPlot_+3A_showpseudo">showPseudo</code></td>
<td>
<p>If <code>TRUE</code> the
pseudo-values are shown as dots on the plot (only when <code>pseudo=TRUE</code>).</p>
</td></tr>
<tr><td><code id="calPlot_+3A_pseudo.col">pseudo.col</code></td>
<td>
<p>Colour for pseudo-values.</p>
</td></tr>
<tr><td><code id="calPlot_+3A_pseudo.pch">pseudo.pch</code></td>
<td>
<p>Dot type (see par) for pseudo-values.</p>
</td></tr>
<tr><td><code id="calPlot_+3A_method">method</code></td>
<td>
<p>The method for estimating the calibration curve(s):
</p>
<p><code>"nne"</code>: The expected event status is obtained in the nearest
neighborhood around the predicted event probabilities.
</p>
<p><code>"quantile"</code>: The expected event status is obtained in groups
defined by quantiles of the predicted event probabilities.</p>
</td></tr>
<tr><td><code id="calPlot_+3A_round">round</code></td>
<td>
<p>If <code>TRUE</code> predicted probabilities are rounded to
two digits before smoothing. This may have a considerable effect on
computing efficiency in large data sets.</p>
</td></tr>
<tr><td><code id="calPlot_+3A_bandwidth">bandwidth</code></td>
<td>
<p>The bandwidth for <code>method="nne"</code></p>
</td></tr>
<tr><td><code id="calPlot_+3A_q">q</code></td>
<td>
<p>The number of quantiles for <code>method="quantile"</code> and <code>bars=TRUE</code>.</p>
</td></tr>
<tr><td><code id="calPlot_+3A_bars">bars</code></td>
<td>
<p>If <code>TRUE</code>, use barplots to show calibration.</p>
</td></tr>
<tr><td><code id="calPlot_+3A_hanging">hanging</code></td>
<td>
<p>Barplots only. If <code>TRUE</code>, hang bars corresponding to observed frequencies
at the value of the corresponding prediction.</p>
</td></tr>
<tr><td><code id="calPlot_+3A_names">names</code></td>
<td>
<p>Barplots only. Names argument passed to <code>names.arg</code> of <code>barplot</code>.</p>
</td></tr>
<tr><td><code id="calPlot_+3A_showfrequencies">showFrequencies</code></td>
<td>
<p>Barplots only. If <code>TRUE</code>, show frequencies above the bars.</p>
</td></tr>
<tr><td><code id="calPlot_+3A_jack.density">jack.density</code></td>
<td>
<p>Gray scale for pseudo-observations.</p>
</td></tr>
<tr><td><code id="calPlot_+3A_plot">plot</code></td>
<td>
<p>If <code>FALSE</code>, do not plot the results, just return a plottable object.</p>
</td></tr>
<tr><td><code id="calPlot_+3A_add">add</code></td>
<td>
<p>If <code>TRUE</code> the line(s) are added to an existing
plot.</p>
</td></tr>
<tr><td><code id="calPlot_+3A_diag">diag</code></td>
<td>
<p>If <code>FALSE</code> no diagonal line is drawn.</p>
</td></tr>
<tr><td><code id="calPlot_+3A_legend">legend</code></td>
<td>
<p>If <code>FALSE</code> no legend is drawn.</p>
</td></tr>
<tr><td><code id="calPlot_+3A_axes">axes</code></td>
<td>
<p>If <code>FALSE</code> no axes are drawn.</p>
</td></tr>
<tr><td><code id="calPlot_+3A_xlim">xlim</code></td>
<td>
<p>Limits of x-axis.</p>
</td></tr>
<tr><td><code id="calPlot_+3A_ylim">ylim</code></td>
<td>
<p>Limits of y-axis.</p>
</td></tr>
<tr><td><code id="calPlot_+3A_xlab">xlab</code></td>
<td>
<p>Label for y-axis.</p>
</td></tr>
<tr><td><code id="calPlot_+3A_ylab">ylab</code></td>
<td>
<p>Label for x-axis.</p>
</td></tr>
<tr><td><code id="calPlot_+3A_col">col</code></td>
<td>
<p>Vector with colors, one for each element of
object. Passed to <code><a href="graphics.html#topic+lines">lines</a></code>.</p>
</td></tr>
<tr><td><code id="calPlot_+3A_lwd">lwd</code></td>
<td>
<p>Vector with line widths, one for each element of
object. Passed to <code><a href="graphics.html#topic+lines">lines</a></code>.</p>
</td></tr>
<tr><td><code id="calPlot_+3A_lty">lty</code></td>
<td>
<p>lwd Vector with line style, one for each element of
object.  Passed to <code><a href="graphics.html#topic+lines">lines</a></code>.</p>
</td></tr>
<tr><td><code id="calPlot_+3A_pch">pch</code></td>
<td>
<p>Passed to <code><a href="graphics.html#topic+points">points</a></code>.</p>
</td></tr>
<tr><td><code id="calPlot_+3A_cause">cause</code></td>
<td>
<p>For competing risks models, the cause of failure or
event of interest</p>
</td></tr>
<tr><td><code id="calPlot_+3A_percent">percent</code></td>
<td>
<p>If TRUE axes labels are multiplied by 100 and thus
interpretable on a percent scale.</p>
</td></tr>
<tr><td><code id="calPlot_+3A_givetomodel">giveToModel</code></td>
<td>
<p>List of with exactly one entry for each entry in
<code>object</code>. Each entry names parts of the value of the fitted
models that should be extracted and added to the value.</p>
</td></tr>
<tr><td><code id="calPlot_+3A_na.action">na.action</code></td>
<td>
<p>Passed to <code><a href="stats.html#topic+model.frame">model.frame</a></code></p>
</td></tr>
<tr><td><code id="calPlot_+3A_cores">cores</code></td>
<td>
<p>Number of cores for parallel computing.  Passed as
value of argument <code>mc.cores</code> to <code><a href="parallel.html#topic+mclapply">mclapply</a></code>.</p>
</td></tr>
<tr><td><code id="calPlot_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> report details of the progress,
e.g. count the steps in cross-validation.</p>
</td></tr>
<tr><td><code id="calPlot_+3A_cex">cex</code></td>
<td>
<p>Default cex used for legend and labels.</p>
</td></tr>
<tr><td><code id="calPlot_+3A_...">...</code></td>
<td>
<p>Used to control the subroutines: plot, axis, lines, barplot,
legend. See <code><a href="prodlim.html#topic+SmartControl">SmartControl</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For method &quot;nne&quot; the optimal bandwidth with respect to is obtained with the
function <code>dpik</code> from the package <code>KernSmooth</code> for a box
kernel function.
</p>


<h3>Value</h3>

<p>list with elements: time, pseudoFrame and bandwidth (NULL for method
quantile).
</p>


<h3>Author(s)</h3>

<p>Thomas Alexander Gerds <a href="mailto:tag@biostat.ku.dk">tag@biostat.ku.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(prodlim)
library(lava)
library(riskRegression)
library(survival)
# survival
dlearn &lt;- SimSurv(40)
dval &lt;- SimSurv(100)
f &lt;- coxph(Surv(time,status)~X1+X2,data=dlearn,x=TRUE,y=TRUE)
cf=calPlot(f,time=3,data=dval)
print(cf)
plot(cf)

g &lt;- coxph(Surv(time,status)~X2,data=dlearn,x=TRUE,y=TRUE)
cf2=calPlot(list("Cox regression X1+X2"=f,"Cox regression X2"=g),
    time=3,
    type="risk",
    data=dval)
print(cf2)
plot(cf2)
calPlot(f,time=3,data=dval,type="survival")
calPlot(f,time=3,data=dval,bars=TRUE,pseudo=FALSE)
calPlot(f,time=3,data=dval,bars=TRUE,type="risk",pseudo=FALSE)

## show a red line which follows the hanging bars
calPlot(f,time=3,data=dval,bars=TRUE,hanging=TRUE)
a &lt;- calPlot(f,time=3,data=dval,bars=TRUE,hanging=TRUE,abline.col=NULL)
lines(c(0,1,ceiling(a$xcoord)),
      c(a$offset[1],a$offset,a$offset[length(a$offset)]),
      col=2,lwd=5,type="s")

calPlot(f,time=3,data=dval,bars=TRUE,type="risk",hanging=TRUE)

set.seed(13)
m &lt;- crModel()
regression(m, from = "X1", to = "eventtime1") &lt;- 1
regression(m, from = "X2", to = "eventtime1") &lt;- 1
m &lt;- addvar(m,c("X3","X4","X5"))
distribution(m, "X1") &lt;- binomial.lvm()
distribution(m, "X4") &lt;- binomial.lvm()
d1 &lt;- sim(m,100)
d2 &lt;- sim(m,100)
csc &lt;- CSC(Hist(time,event)~X1+X2+X3+X4+X5,data=d1)
fgr &lt;- FGR(Hist(time,event)~X1+X2+X3+X4+X5,data=d1,cause=1)
if ((requireNamespace("cmprsk",quietly=TRUE))){
predict.crr &lt;- cmprsk:::predict.crr
cf3=calPlot(list("Cause-specific Cox"=csc,"Fine-Gray"=fgr),
        time=5,
        legend.x=-0.3,
        legend.y=1.35,
        ylab="Observed event status",
        legend.legend=c("Cause-specific Cox regression","Fine-Gray regression"),
        legend.xpd=NA)
print(cf3)
plot(cf3)

b1 &lt;- calPlot(list("Fine-Gray"=fgr),time=5,bars=TRUE,hanging=FALSE)
print(b1)
plot(b1)

calPlot(fgr,time=5,bars=TRUE,hanging=TRUE)
}

</code></pre>

<hr>
<h2 id='cindex'>Concordance index for right censored survival time data</h2><span id='topic+cindex'></span>

<h3>Description</h3>

<p>In survival analysis, a pair of patients is called concordant if the risk of
the event predicted by a model is lower for the patient who experiences the
event at a later timepoint. The concordance probability (C-index) is the
frequency of concordant pairs among all pairs of subjects. It can be used to
measure and compare the discriminative power of a risk prediction models.
The function provides an inverse of the probability of censoring weigthed
estimate of the concordance probability to adjust for right censoring.
Cross-validation based on bootstrap resampling or bootstrap subsampling can
be applied to assess and compare the discriminative power of various
regression modelling strategies on the same set of data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cindex(
  object,
  formula,
  data,
  eval.times,
  pred.times,
  cause,
  lyl = FALSE,
  cens.model = "marginal",
  ipcw.refit = FALSE,
  ipcw.args = NULL,
  ipcw.limit,
  tiedPredictionsIn = TRUE,
  tiedOutcomeIn = TRUE,
  tiedMatchIn = TRUE,
  splitMethod = "noPlan",
  B,
  M,
  model.args = NULL,
  model.parms = NULL,
  keep.models = FALSE,
  keep.residuals = FALSE,
  keep.pvalues = FALSE,
  keep.weights = FALSE,
  keep.index = FALSE,
  keep.matrix = FALSE,
  multiSplitTest = FALSE,
  testTimes,
  confInt = FALSE,
  confLevel = 0.95,
  verbose = TRUE,
  savePath = NULL,
  slaveseed = NULL,
  na.action = na.fail,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cindex_+3A_object">object</code></td>
<td>
<p>A named list of prediction models, where allowed entries are
(1) R-objects for which a <a href="#topic+predictSurvProb">predictSurvProb</a> method exists (see
details), (2) a <code>call</code> that evaluates to such an R-object (see
examples), (3) a matrix with predicted probabilities having as many rows as
<code>data</code> and as many columns as <code>times</code>. For cross-validation all
objects in this list must include their <code>call</code>.</p>
</td></tr>
<tr><td><code id="cindex_+3A_formula">formula</code></td>
<td>
<p>A survival formula. The left hand side is used to finde the
status response variable in <code>data</code>. For right censored data, the right
hand side of the formula is used to specify conditional censoring models.
For example, set <code>Surv(time,status)~x1+x2</code> and <code>cens.model="cox"</code>.
Then the weights are based on a Cox regression model for the censoring times
with predictors x1 and x2.  Note that the usual coding is assumed:
<code>status=0</code> for censored times and that each variable name that appears
in <code>formula</code> must be the column name in <code>data</code>. If there are no
covariates, i.e. <code>formula=Surv(time,status)~1</code> the <code>cens.model</code> is
coerced to <code>"marginal"</code> and the Kaplan-Meier estimator for the
censoring times is used to calculate the weights.  If <code>formula</code> is
<code>missing</code>, try to extract a formula from the first element in object.</p>
</td></tr>
<tr><td><code id="cindex_+3A_data">data</code></td>
<td>
<p>A data frame in which to validate the prediction models and to
fit the censoring model.  If <code>data</code> is missing, try to extract a data
set from the first element in object.</p>
</td></tr>
<tr><td><code id="cindex_+3A_eval.times">eval.times</code></td>
<td>
<p>A vector of timepoints for evaluating the discriminative
ability. At each timepoint the c-index is computed using only those pairs
where one of the event times is known to be earlier than this timepoint. If
<code>eval.times</code> is <code>missing</code> then the largest
uncensored event time is used.</p>
</td></tr>
<tr><td><code id="cindex_+3A_pred.times">pred.times</code></td>
<td>
<p>A vector of timepoints for evaluating the prediction
models. This should either be exactly one timepoint used for all
<code>eval.times</code>, or be as long as <code>eval.times</code>, in which case the
predicted order of risk for the jth entry of <code>eval.times</code> is based on
the jth entry of <code>pred.times</code> corresponding</p>
</td></tr>
<tr><td><code id="cindex_+3A_cause">cause</code></td>
<td>
<p>For competing risks, the event of interest. Defaults to the
first state of the response, which is obtained by evaluating the left hand
side of <code>formula</code> in <code>data</code>.</p>
</td></tr>
<tr><td><code id="cindex_+3A_lyl">lyl</code></td>
<td>
<p>If <code>TRUE</code> rank subjects accoring to predicted
life-years-lost (See Andersen due to this cause instead of predicted risk.</p>
</td></tr>
<tr><td><code id="cindex_+3A_cens.model">cens.model</code></td>
<td>
<p>Method for estimating inverse probability of censoring
weigths:
</p>
<p><code>cox</code>: A semi-parametric Cox proportional hazard model is fitted to the
censoring times
</p>
<p><code>marginal</code>: The Kaplan-Meier estimator for the censoring times
</p>
<p><code>nonpar</code>: Nonparametric extension of the Kaplan-Meier for the censoring
times using symmetric nearest neighborhoods &ndash; available for arbitrary many
strata variables on the right hand side of argument <code>formula</code> but at
most one continuous variable. See the documentation of the functions
<code>prodlim</code> and <code>neighborhood</code> from the prodlim package.
</p>
<p><code>aalen</code>: The nonparametric Aalen additive model fitted to the censoring
times. Requires the timereg package maintained by Thomas Scheike.</p>
</td></tr>
<tr><td><code id="cindex_+3A_ipcw.refit">ipcw.refit</code></td>
<td>
<p>If <code>TRUE</code> the inverse probability of censoring
weigths are estimated separately in each training set during
cross-validation.</p>
</td></tr>
<tr><td><code id="cindex_+3A_ipcw.args">ipcw.args</code></td>
<td>
<p>List of arguments passed to function specified by argument <code>cens.model</code>.</p>
</td></tr>
<tr><td><code id="cindex_+3A_ipcw.limit">ipcw.limit</code></td>
<td>
<p>Value between 0 and 1 (but no equal to 0!) used to cut for
small weights in order to stabilize the estimate at late times were few
individuals are observed.</p>
</td></tr>
<tr><td><code id="cindex_+3A_tiedpredictionsin">tiedPredictionsIn</code></td>
<td>
<p>If <code>FALSE</code> pairs with identical predictions
are excluded, unless also the event times are identical and uncensored and
<code>tiedMatchIn</code> is set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="cindex_+3A_tiedoutcomein">tiedOutcomeIn</code></td>
<td>
<p>If <code>TRUE</code> pairs with identical and uncensored
event times are excluded, unless also the predictions are identical and
<code>tiedMatchIn</code> is set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="cindex_+3A_tiedmatchin">tiedMatchIn</code></td>
<td>
<p>If <code>TRUE</code> then pairs with identical predictions and
identical and uncensored event times are counted as concordant pairs.</p>
</td></tr>
<tr><td><code id="cindex_+3A_splitmethod">splitMethod</code></td>
<td>
<p>Defines the internal validation design:
</p>
<p><code>none/noPlan</code>: Assess the models in the give <code>data</code>, usually
either in the same data where they are fitted, or in independent test data.
</p>
<p><code>BootCv</code>: Bootstrap cross validation. The prediction models are trained
on <code>B</code> bootstrap samples, that are either drawn with replacement of the
same size as the original data or without replacement from <code>data</code> of
the size <code>M</code>.  The models are assessed in the observations that are NOT
in the bootstrap sample.
</p>
<p><code>Boot632</code>: Linear combination of AppCindex and OutOfBagCindex using the
constant weight .632.</p>
</td></tr>
<tr><td><code id="cindex_+3A_b">B</code></td>
<td>
<p>Number of bootstrap samples. The default depends on argument
<code>splitMethod</code>.  When <code>splitMethod</code> in c(&quot;BootCv&quot;,&quot;Boot632&quot;) the
default is 100.  For <code>splitMethod="none"</code> <code>B</code> is the number of
bootstrap simulations e.g. to obtain bootstrap confidence limits &ndash; default
is 0.</p>
</td></tr>
<tr><td><code id="cindex_+3A_m">M</code></td>
<td>
<p>The size of the bootstrap samples for resampling without
replacement. Ignored for resampling with replacement.</p>
</td></tr>
<tr><td><code id="cindex_+3A_model.args">model.args</code></td>
<td>
<p>List of extra arguments that can be passed to the
<code>predictSurvProb</code> methods. The list must have an entry for each entry
in <code>object</code>.</p>
</td></tr>
<tr><td><code id="cindex_+3A_model.parms">model.parms</code></td>
<td>
<p>Experimental.  List of with exactly one entry for each
entry in <code>object</code>.  Each entry names parts of the value of the fitted
models that should be extracted and added to the value.</p>
</td></tr>
<tr><td><code id="cindex_+3A_keep.models">keep.models</code></td>
<td>
<p>Logical. If <code>TRUE</code> keep the models in object. Since
fitted models can be large objects the default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="cindex_+3A_keep.residuals">keep.residuals</code></td>
<td>
<p>Experimental.</p>
</td></tr>
<tr><td><code id="cindex_+3A_keep.pvalues">keep.pvalues</code></td>
<td>
<p>Experimental.</p>
</td></tr>
<tr><td><code id="cindex_+3A_keep.weights">keep.weights</code></td>
<td>
<p>Experimental.</p>
</td></tr>
<tr><td><code id="cindex_+3A_keep.index">keep.index</code></td>
<td>
<p>Logical. If <code>FALSE</code> remove the bootstrap or
cross-validation index from the output list which otherwise is included in
the method part of the output list.</p>
</td></tr>
<tr><td><code id="cindex_+3A_keep.matrix">keep.matrix</code></td>
<td>
<p>Logical. If <code>TRUE</code> add all <code>B</code> prediction error
curves from bootstrapping or cross-validation to the output.</p>
</td></tr>
<tr><td><code id="cindex_+3A_multisplittest">multiSplitTest</code></td>
<td>
<p>Experimental.</p>
</td></tr>
<tr><td><code id="cindex_+3A_testtimes">testTimes</code></td>
<td>
<p>A vector of time points for testing differences between
models in the time-point specific Brier scores.</p>
</td></tr>
<tr><td><code id="cindex_+3A_confint">confInt</code></td>
<td>
<p>Experimental.</p>
</td></tr>
<tr><td><code id="cindex_+3A_conflevel">confLevel</code></td>
<td>
<p>Experimental.</p>
</td></tr>
<tr><td><code id="cindex_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> report details of the progress, e.g. count the
steps in cross-validation.</p>
</td></tr>
<tr><td><code id="cindex_+3A_savepath">savePath</code></td>
<td>
<p>Place in your filesystem (directory) where training models
fitted during cross-validation are saved. If <code>missing</code> training models
are not saved.</p>
</td></tr>
<tr><td><code id="cindex_+3A_slaveseed">slaveseed</code></td>
<td>
<p>Vector of seeds, as long as <code>B</code>, to be given to the
slaves in parallel computing.</p>
</td></tr>
<tr><td><code id="cindex_+3A_na.action">na.action</code></td>
<td>
<p>Passed immediately to model.frame. Defaults to na.fail. If
set otherwise most prediction models will not work.</p>
</td></tr>
<tr><td><code id="cindex_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Pairs with identical observed times, where one is uncensored and one is
censored, are always considered usuable (independent of the value of
<code>tiedOutcomeIn</code>), as it can be assumed that the event occurs at a later
timepoint for the censored observation.
</p>
<p>For uncensored response the result equals the one obtained with the
functions <code>rcorr.cens</code> and <code>rcorrcens</code> from the <code>Hmisc</code>
package (see examples).
</p>


<h3>Value</h3>

<p>Estimates of the C-index.
</p>


<h3>Author(s)</h3>

<p>Thomas A Gerds <a href="mailto:tag@biostat.ku.dk">tag@biostat.ku.dk</a>
</p>


<h3>References</h3>

<p>TA Gerds, MW Kattan, M Schumacher, and C Yu. Estimating a time-dependent
concordance index for survival prediction models with covariate dependent
censoring. Statistics in Medicine, Ahead of print:to appear, 2013. DOI =
10.1002/sim.5681
</p>
<p>Wolbers, M and Koller, MT and Witteman, JCM and Gerds, TA (2013) Concordance
for prognostic models with competing risks Research report 13/3. Department
of Biostatistics, University of Copenhagen
</p>
<p>Andersen, PK (2012) A note on the decomposition of number of life years lost
according to causes of death Research report 12/2. Department of
Biostatistics, University of Copenhagen
</p>
<p>Paul Blanche, Michael W Kattan, and Thomas A Gerds. The c-index is not
proper for the evaluation of-year predicted risks. Biostatistics, 20(2):
347&ndash;357, 2018.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # simulate data based on Weibull regression  
library(prodlim)
 set.seed(13)
 dat &lt;- SimSurv(100)
 # fit three different Cox models and a random survival forest
 # note: low number of trees for the purpose of illustration 
 library(survival)
 cox12 &lt;- coxph(Surv(time,status)~X1+X2,data=dat,x=TRUE,y=TRUE)
 cox1 &lt;- coxph(Surv(time,status)~X1,data=dat,x=TRUE,y=TRUE)
 cox2 &lt;- coxph(Surv(time,status)~X2,data=dat,x=TRUE,y=TRUE)
 #
 # compute the apparent estimate of the C-index at a single time point
 #
A1  &lt;- pec::cindex(list("Cox X1"=cox1),
		  formula=Surv(time,status)~X1+X2,
		  data=dat,
		  eval.times=10)
 #
 # compute the apparent estimate of the C-index at different time points
 #
ApparrentCindex  &lt;- pec::cindex(list("Cox X1"=cox1,
		       "Cox X2"=cox2,
		       "Cox X1+X2"=cox12),
		  formula=Surv(time,status)~X1+X2,
		  data=dat,
		  eval.times=seq(1,15,1))
  print(ApparrentCindex)
  plot(ApparrentCindex)
 #
 # compute the bootstrap-crossvalidation estimate of
 # the C-index at different time points
 #
set.seed(142)
bcvCindex  &lt;- pec::cindex(list("Cox X1"=cox1,
		       "Cox X2"=cox2,
		       "Cox X1+X2"=cox12),
		  formula=Surv(time,status)~X1+X2,
		  data=dat,
                  splitMethod="bootcv",
                  B=5,
 		  eval.times=seq(1,15,1))
  print(bcvCindex)
  plot(bcvCindex)
 # for uncensored data the results are the same
 # as those obtained with the function rcorr.cens from Hmisc

set.seed(16)
dat &lt;- SimSurv(30)
dat$staus=1
fit12 &lt;- coxph(Surv(time,status)~X1+X2,data=dat,x=TRUE,y=TRUE)
fit1 &lt;- coxph(Surv(time,status)~X1,data=dat,x=TRUE,y=TRUE)
fit2 &lt;- coxph(Surv(time,status)~X2,data=dat,x=TRUE,y=TRUE)
Cpec &lt;- pec::cindex(list("Cox X1+X2"=fit12,"Cox X1"=fit1,"Cox X2"=fit2),
	       formula=Surv(time,status)~1,
	       data=dat) 	       
p1 &lt;- predictSurvProb(fit1,newdata=dat,times=10)
p2 &lt;- predictSurvProb(fit2,newdata=dat,times=10)
p12 &lt;- predictSurvProb(fit12,newdata=dat,times=10)
if (requireNamespace("Hmisc",quietly=TRUE)){
library(Hmisc)
harrelC1 &lt;- rcorr.cens(p1,with(dat,Surv(time,status)))
harrelC2 &lt;- rcorr.cens(p2,with(dat,Surv(time,status)))
harrelC12 &lt;- rcorr.cens(p12,with(dat,Surv(time,status)))
harrelC1[["C Index"]]==Cpec$AppCindex[["Cox.X1"]]
harrelC2[["C Index"]]==Cpec$AppCindex[["Cox.X2"]]
harrelC12[["C Index"]]==Cpec$AppCindex[["Cox.X1.X2"]]
}
 #
 # competing risks 
 #
library(riskRegression)
library(prodlim)
set.seed(30)
dcr.learn &lt;- SimCompRisk(30)
dcr.val &lt;- SimCompRisk(30)
pec::cindex(CSC(Hist(time,event)~X1+X2,data=dcr.learn),data=dcr.val)
fit &lt;- CSC(Hist(time,event)~X1+X2,data=dcr.learn)
cif &lt;- predictRisk(fit,newdata=dcr.val,times=3,cause=1)
pec::cindex(list(fit),data=dcr.val,times=3)
</code></pre>

<hr>
<h2 id='cost'>Copenhagen Stroke Study</h2><span id='topic+cost'></span>

<h3>Description</h3>

<p>This data set contains a subset of the data from the Copenhagen stroke
study.
</p>


<h3>Format</h3>

<p>This data frame contains the observations of 518 stroke patients :
</p>
 <dl>
<dt>age</dt><dd><p>Age of the patients in years.</p>
</dd> <dt>sex</dt><dd><p>A factor
with two levels <code>female</code> and <code>male</code>.</p>
</dd> <dt>hypTen</dt><dd><p>Hypertension,
a factor with two levels <code>no</code> and <code>yes</code>.</p>
</dd> <dt>ihd</dt><dd><p>History of
ischemic heart disease at admission, a factor with two levels <code>no</code> and
<code>yes</code>.</p>
</dd> <dt>prevStroke</dt><dd><p>History of previous strokes before admission,
a factor with two levels <code>no</code> and <code>yes</code>.</p>
</dd>
<dt>othDisease</dt><dd><p>History of other disabling diseases (e.g. severe
dementia), a factor with two levels <code>no</code> and <code>yes</code>.</p>
</dd>
<dt>alcohol</dt><dd><p>Daily alcohol consumption, a factor with two levels <code>no</code>
and <code>yes</code>.</p>
</dd> <dt>diabetes</dt><dd><p>Diabetes mellitus status indicating if the
glucose level was higher than 11 mmol/L, a factor with two levels <code>no</code>
and <code>yes</code>.</p>
</dd> <dt>smoke</dt><dd><p>Daily smoking status, a factor with two levels
<code>no</code> and <code>yes</code>.</p>
</dd> <dt>atrialFib</dt><dd><p>Atrial fibrillation, a factor
with two levels <code>no</code> and <code>yes</code>.</p>
</dd> <dt>hemor</dt><dd><p>Hemorrhage (stroke
subtype), a factor with two levels <code>no</code> (infarction) and <code>yes</code>
(hemorrhage).</p>
</dd> <dt>strokeScore</dt><dd><p>Scandinavian stroke score at admission to
the hospital. Ranges from 0 (worst) to 58 (best).</p>
</dd>
<dt>cholest</dt><dd><p>Cholesterol level</p>
</dd> <dt>time</dt><dd><p>Survival time (in days).</p>
</dd>
<dt>status</dt><dd><p>Status (<code>0</code>: censored, <code>1</code>: event).</p>
</dd> </dl>



<h3>References</h3>

<p>Joergensen HS, Nakayama H, Reith J, Raaschou HO, and Olsen TS.
Acute stroke with atrial fibrillation. The Copenhagen Stroke Study. Stroke,
27(10):1765-9, 1996.
</p>
<p>Mogensen UB, Ishwaran H, and Gerds TA. Evaluating random forests for
survival analysis using prediction error curves. Technical Report 8,
University of Copenhagen, Department of Biostatistics, 2010.
</p>

<hr>
<h2 id='coxboost'>Formula interface for function <code>CoxBoost</code> of package <code>CoxBoost</code>.</h2><span id='topic+coxboost'></span>

<h3>Description</h3>

<p>Formula interface for function <code>CoxBoost</code> of package <code>CoxBoost</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxboost(formula, data, cv = TRUE, cause = 1, penalty, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coxboost_+3A_formula">formula</code></td>
<td>
<p>An event-history formula for competing risks of the
form <code>Hist(time,status)~sex+age</code> where <code>status</code> defines
competing events and right censored data. The code for right
censored can be controlled with argument <code>cens.code</code>, see man
page the function <code><a href="prodlim.html#topic+Hist">Hist</a></code>.</p>
</td></tr>
<tr><td><code id="coxboost_+3A_data">data</code></td>
<td>
<p>A data.frame in which the variables of formula are
defined.</p>
</td></tr>
<tr><td><code id="coxboost_+3A_cv">cv</code></td>
<td>
<p>If <code>TRUE</code> perform cross-validation to optimize the
parameter <code>stepno</code>. This calls the function <code>cv.CoxBoost</code>
whose arguments are prefix controlled, that is <code>cv.K=7</code> sets
the argument <code>K</code> of <code>cv.CoxBoost</code> to <code>7</code>.  If
<code>FALSE</code> use <code>stepno</code>.</p>
</td></tr>
<tr><td><code id="coxboost_+3A_cause">cause</code></td>
<td>
<p>The cause of interest in competing risk models.</p>
</td></tr>
<tr><td><code id="coxboost_+3A_penalty">penalty</code></td>
<td>
<p>See <code>CoxBoost</code>.</p>
</td></tr>
<tr><td><code id="coxboost_+3A_...">...</code></td>
<td>
<p>Arguments passed to either <code>CoxBoost</code> via
<code>CoxBoost.arg</code> or to <code>cv.CoxBoost</code> via
<code>cv.CoxBoost.arg</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>CoxBoost</code>.
</p>


<h3>Value</h3>

<p>See <code>CoxBoost</code>.
</p>


<h3>Author(s)</h3>

<p>Thomas Alexander Gerds <a href="mailto:tag@biostat.ku.dk">tag@biostat.ku.dk</a>
</p>


<h3>References</h3>

<p>See <code>CoxBoost</code>.
</p>


<h3>See Also</h3>

<p>See <code>CoxBoost</code>.
</p>

<hr>
<h2 id='crps'>Summarizing prediction error curves</h2><span id='topic+crps'></span><span id='topic+ibs'></span>

<h3>Description</h3>

<p>Computes the cumulative prediction error curves, aka integrated Brier
scores, in ranges of time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crps(object, models, what, times, start)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crps_+3A_object">object</code></td>
<td>
<p>An object with estimated prediction error curves obtained with
the function <a href="#topic+pec">pec</a></p>
</td></tr>
<tr><td><code id="crps_+3A_models">models</code></td>
<td>
<p>Which models in <code>object$models</code> should be considered.</p>
</td></tr>
<tr><td><code id="crps_+3A_what">what</code></td>
<td>
<p>The name of the entry in <code>x</code> to be cumulated. Defauls to
<code>PredErr</code> Other choices are <code>AppErr</code>, <code>BootCvErr</code>,
<code>Boot632</code>, <code>Boot632plus</code>.</p>
</td></tr>
<tr><td><code id="crps_+3A_times">times</code></td>
<td>
<p>Time points at which the integration of the prediction error
curve stops.</p>
</td></tr>
<tr><td><code id="crps_+3A_start">start</code></td>
<td>
<p>The time point at which the integration of the prediction error
curve is started.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The cumulative prediction error (continuous ranked probability score) is
defined as the area under the prediction error curve, hence the alias name,
ibs, which is short for integrated Brier score.
</p>


<h3>Value</h3>

<p>A matrix with a column for the crps (ibs) at every requested time
point and a row for each model
</p>


<h3>Author(s)</h3>

<p>Thomas A. Gerds <a href="mailto:tag@biostat.ku.dk">tag@biostat.ku.dk</a>
</p>


<h3>References</h3>

<p>E. Graf et al.  (1999), Assessment and comparison of prognostic
classification schemes for survival data. Statistics in Medicine, vol 18,
pp= 2529&ndash;2545.
</p>
<p>Gerds TA, Cai T &amp; Schumacher M (2008) The performance of risk prediction
models Biometrical Journal, 50(4), 457&ndash;479
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pec">pec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(18713)
library(prodlim)
library(survival)
dat=SimSurv(100)
pmodel=coxph(Surv(time,status)~X1+X2,data=dat,x=TRUE,y=TRUE)
perror=pec(list(Cox=pmodel),Hist(time,status)~1,data=dat)

## cumulative prediction error
crps(perror,times=1) # between min time and 1
## same thing:
ibs(perror,times=1) # between min time and 1
crps(perror,times=1,start=0) # between 0 and 1
crps(perror,times=seq(0,1,.2),start=0) # between 0 and seq(0,1,.2)


</code></pre>

<hr>
<h2 id='GBSG2'>German Breast Cancer Study Group 2</h2><span id='topic+GBSG2'></span>

<h3>Description</h3>

<p>A data frame containing the observations from the GBSG2 study.
</p>


<h3>Format</h3>

<p>This data frame contains the observations of 686 women: </p>

<dl>
<dt>horTh</dt><dd><p>hormonal therapy, a factor at two levels <code>no</code> and
<code>yes</code>.</p>
</dd> <dt>age</dt><dd><p>of the patients in years.</p>
</dd>
<dt>menostat</dt><dd><p>menopausal status, a factor at two levels <code>pre</code>
(premenopausal) and <code>post</code> (postmenopausal).</p>
</dd> <dt>tsize</dt><dd><p>tumor size
(in mm).</p>
</dd> <dt>tgrade</dt><dd><p>tumor grade, a ordered factor at levels <code>I &lt; II
&lt; III</code>.</p>
</dd> <dt>pnodes</dt><dd><p>number of positive nodes.</p>
</dd>
<dt>progrec</dt><dd><p>progesterone receptor (in fmol).</p>
</dd> <dt>estrec</dt><dd><p>estrogen
receptor (in fmol).</p>
</dd> <dt>time</dt><dd><p>recurrence free survival time (in days).</p>
</dd>
<dt>cens</dt><dd><p>censoring indicator (0- censored, 1- event).</p>
</dd> </dl>



<h3>References</h3>

<p>M. Schumacher, G. Basert, H. Bojar, K. Huebner, M. Olschewski,
W. Sauerbrei, C. Schmoor, C. Beyerle, R.L.A. Neumann and H.F. Rauschecker
for the German Breast Cancer Study Group (1994), Randomized <code class="reqn">2\times2</code>
trial evaluating hormonal treatment and the duration of chemotherapy in
node-positive breast cancer patients.  <em>Journal of Clinical Oncology</em>,
<b>12</b>, 2086&ndash;2093.
</p>

<hr>
<h2 id='ipcw'>Estimation of censoring probabilities</h2><span id='topic+ipcw'></span><span id='topic+ipcw.none'></span><span id='topic+ipcw.marginal'></span><span id='topic+ipcw.nonpar'></span><span id='topic+ipcw.cox'></span><span id='topic+ipcw.aalen'></span>

<h3>Description</h3>

<p>This function is used internally by the function <code>pec</code> to obtain
inverse of the probability of censoring weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ipcw(
  formula,
  data,
  method,
  args,
  times,
  subjectTimes,
  subjectTimesLag = 1,
  what
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ipcw_+3A_formula">formula</code></td>
<td>
<p>A survival formula like, <code>Surv(time,status)~1</code>, where
as usual status=0 means censored. The status variable is internally
reversed for estimation of censoring rather than survival
probabilities. Some of the available models (see argument
<code>model</code>) will use predictors on the right hand side of the
formula.</p>
</td></tr>
<tr><td><code id="ipcw_+3A_data">data</code></td>
<td>
<p>The data used for fitting the censoring model</p>
</td></tr>
<tr><td><code id="ipcw_+3A_method">method</code></td>
<td>
<p>Censoring model used for estimation of the
(conditional) censoring distribution.</p>
</td></tr>
<tr><td><code id="ipcw_+3A_args">args</code></td>
<td>
<p>A list of arguments which is passed to method</p>
</td></tr>
<tr><td><code id="ipcw_+3A_times">times</code></td>
<td>
<p>For <code>what="IPCW.times"</code> a vector of times at
which to compute the probabilities of not being censored.</p>
</td></tr>
<tr><td><code id="ipcw_+3A_subjecttimes">subjectTimes</code></td>
<td>
<p>For <code>what="IPCW.subjectTimes"</code> a vector of
individual times at which the probabilities of not being censored
are computed.</p>
</td></tr>
<tr><td><code id="ipcw_+3A_subjecttimeslag">subjectTimesLag</code></td>
<td>
<p>If equal to <code>1</code> then obtain
<code>G(T_i-|X_i)</code>, if equal to <code>0</code> estimate the conditional
censoring distribution at the subjectTimes,
i.e. (<code>G(T_i|X_i)</code>).</p>
</td></tr>
<tr><td><code id="ipcw_+3A_what">what</code></td>
<td>
<p>Decide about what to do: If equal to
<code>"IPCW.times"</code> then weights are estimated at given
<code>times</code>.  If equal to <code>"IPCW.subjectTimes"</code> then weights
are estimated at individual <code>subjectTimes</code>.  If missing then
produce both.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Inverse of the probability of censoring weights (IPCW) usually refer to the
probabilities of not being censored at certain time points. These
probabilities are also the values of the conditional survival function of
the censoring time given covariates. The function ipcw estimates the
conditional survival function of the censoring times and derives the
weights.
</p>
<p>IMPORTANT: the data set should be ordered, <code>order(time,-status)</code> in
order to get the values <code>IPCW.subjectTimes</code> in the right order for some
choices of <code>method</code>.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>times</code></td>
<td>
<p>The times at which weights are estimated</p>
</td></tr>
<tr><td><code>IPCW.times</code></td>
<td>
<p>Estimated weights at <code>times</code></p>
</td></tr>
<tr><td><code>IPCW.subjectTimes</code></td>
<td>
<p>Estimated weights at individual time values
<code>subjectTimes</code></p>
</td></tr> <tr><td><code>fit</code></td>
<td>
<p>The fitted censoring model</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The method for modelling the censoring distribution</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The call</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas A. Gerds <a href="mailto:tag@biostat.ku.dk">tag@biostat.ku.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pec">pec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(prodlim)
library(rms)
library(survival)
dat=SimSurv(30)

dat &lt;- dat[order(dat$time),]

# using the marginal Kaplan-Meier for the censoring times

WKM=ipcw(Hist(time,status)~X2,
  data=dat,
  method="marginal",
  times=sort(unique(dat$time)),
  subjectTimes=dat$time)
plot(WKM$fit)
WKM$fit

# using the Cox model for the censoring times given X2
library(survival)
WCox=ipcw(Hist(time=time,event=status)~X2,
  data=dat,
  method="cox",
  times=sort(unique(dat$time)),
  subjectTimes=dat$time)
WCox$fit

plot(WKM$fit)
lines(sort(unique(dat$time)),
      1-WCox$IPCW.times[1,],
      type="l",
      col=2,
      lty=3,
      lwd=3)
lines(sort(unique(dat$time)),
      1-WCox$IPCW.times[5,],
      type="l",
      col=3,
      lty=3,
      lwd=3)

# using the stratified Kaplan-Meier
# for the censoring times given X2

WKM2=ipcw(Hist(time,status)~X2,
  data=dat,
  method="nonpar",
  times=sort(unique(dat$time)),
  subjectTimes=dat$time)
plot(WKM2$fit,add=FALSE)


</code></pre>

<hr>
<h2 id='Pbc3'>Pbc3 data</h2><span id='topic+Pbc3'></span>

<h3>Description</h3>

<p>PBC3 was a multi-centre randomized clinical trial conducted in six European
hospitals. Between 1 Jan. 1983 and 1 Jan. 1987, 349 patients with the liver
disease primary biliary cirrhosis (PBC) were randomized to either treatment
with Cyclosporin A (CyA, 176 patients) or placebo (173 patients). The
purpose of the trial was to study the effect of treatment on the survival
time. However, during the course of the trial an increased use of liver
transplantation for patients with this disease made the investigators
redefine the main response variable to be time to &ldquo;failure of medical
treatment&rdquo; defined as either death or liver transplantation. Patients were
then followed from randomization until treatment failure, drop-out or 1 Jan,
1989; 61 patients died (CyA: 30, placebo: 31), another 29 were transplanted
(CyA: 14, placebo: 15) and 4 patients were lost to follow-up before 1 Jan.
1989. At entry a number of clinical, biochemical and histological variables,
including serum bilirubin, serum albumin, sex, age were recorded.
</p>


<h3>Format</h3>

<p>A data frame with 349 observations on the following 15 variables.
</p>
 <dl>
<dt>ptno</dt><dd><p>patient identification</p>
</dd>
<dt>unit</dt><dd><p>hospital (1: Hvidovre, 2: London, 3: Copenhagen, 4:
Barcelona, 5: Munich, 6: Lyon)</p>
</dd> <dt>tment</dt><dd><p>treatment (0: placebo,
1: CyA)</p>
</dd> <dt>sex</dt><dd><p>(1: males, 0: females)</p>
</dd> <dt>age</dt><dd><p>age
in years</p>
</dd> <dt>stage</dt><dd><p>histological stage (1, 2, 3, 4)</p>
</dd>
<dt>gibleed</dt><dd><p>previous gastrointestinal bleeding (1: yes, 0: no)</p>
</dd>
<dt>crea</dt><dd><p>creatinine (micromoles/L)</p>
</dd> <dt>alb</dt><dd><p>albumin
(g/L)</p>
</dd> <dt>bili</dt><dd><p>bilirubin (micromoles/L)</p>
</dd>
<dt>alkph</dt><dd><p>alkaline phosphatase (IU/L)</p>
</dd>
<dt>asptr</dt><dd><p>aspartate transaminase (IU/L)</p>
</dd>
<dt>weight</dt><dd><p>body weight (kg)</p>
</dd> <dt>days</dt><dd><p>observation time
(days)</p>
</dd> <dt>status</dt><dd><p>status at observation time (0: censored, 1:
liver transplantation, 2 : dead)</p>
</dd> </dl>



<h3>Source</h3>

<p>Andersen and Skovgaard. Regression with linear predictors.
</p>


<h3>References</h3>

<p>Andersen and Skovgaard. Regression with linear predictors.
Springer, 2010.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Pbc3)

</code></pre>

<hr>
<h2 id='pec'>Prediction error curves</h2><span id='topic+pec'></span>

<h3>Description</h3>

<p>Evaluating the performance of risk prediction models in survival analysis.
The Brier score is a weighted average of the squared distances between the
observed survival status and the predicted survival probability of a model.
Roughly the weights correspond to the probabilities of not being censored.
The weights can be estimated depend on covariates. Prediction error curves
are obtained when the Brier score is followed over time.  Cross-validation
based on bootstrap resampling or bootstrap subsampling can be applied to
assess and compare the predictive power of various regression modelling
strategies on the same set of data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pec(
  object,
  formula,
  data,
  traindata,
  times,
  cause,
  start,
  maxtime,
  exact = TRUE,
  exactness = 100,
  fillChar = NA,
  cens.model = "cox",
  ipcw.refit = FALSE,
  ipcw.args = NULL,
  splitMethod = "none",
  B,
  M,
  reference = TRUE,
  model.args = NULL,
  model.parms = NULL,
  keep.index = FALSE,
  keep.matrix = FALSE,
  keep.models = FALSE,
  keep.residuals = FALSE,
  keep.pvalues = FALSE,
  noinf.permute = FALSE,
  multiSplitTest = FALSE,
  testIBS,
  testTimes,
  confInt = FALSE,
  confLevel = 0.95,
  verbose = TRUE,
  savePath = NULL,
  slaveseed = NULL,
  na.action = na.fail,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pec_+3A_object">object</code></td>
<td>
<p>A named list of prediction models, where allowed entries are
(1) R-objects for which a <a href="#topic+predictSurvProb">predictSurvProb</a> method exists (see
details), (2) a <code>call</code> that evaluates to such an R-object (see
examples), (3) a matrix with predicted probabilities having as many rows as
<code>data</code> and as many columns as <code>times</code>. For cross-validation all
objects in this list must include their <code>call</code>.</p>
</td></tr>
<tr><td><code id="pec_+3A_formula">formula</code></td>
<td>
<p>A survival formula as obtained either
with <code>prodlim::Hist</code> or <code>survival::Surv</code>.
The left hand side is used to find the status response variable in <code>data</code>. For right censored data, the right
hand side of the formula is used to specify conditional censoring models.
For example, set <code>Surv(time,status)~x1+x2</code> and <code>cens.model="cox"</code>.
Then the weights are based on a Cox regression model for the censoring times
with predictors x1 and x2.  Note that the usual coding is assumed:
<code>status=0</code> for censored times and that each variable name that appears
in <code>formula</code> must be the column name in <code>data</code>. If there are no
covariates, i.e. <code>formula=Surv(time,status)~1</code> the <code>cens.model</code> is
coerced to <code>"marginal"</code> and the Kaplan-Meier estimator for the
censoring times is used to calculate the weights.  If <code>formula</code> is
<code>missing</code>, try to extract a formula from the first element in object.</p>
</td></tr>
<tr><td><code id="pec_+3A_data">data</code></td>
<td>
<p>A data frame in which to validate the prediction models and to
fit the censoring model.  If <code>data</code> is missing, try to extract a data
set from the first element in object.</p>
</td></tr>
<tr><td><code id="pec_+3A_traindata">traindata</code></td>
<td>
<p>A data frame in which the models are trained. This argument
is used only in the absence of crossvalidation, in which case it is
passed to the predictHandler function predictSurvProb</p>
</td></tr>
<tr><td><code id="pec_+3A_times">times</code></td>
<td>
<p>A vector of time points. At each time point the prediction
error curves are estimated. If <code>exact==TRUE</code> the <code>times</code> are
merged with all the unique values of the response variable.  If <code>times</code>
is missing and <code>exact==TRUE</code> all the unique values of the response
variable are used.  If missing and <code>exact==FALSE</code> use a equidistant
grid of values between <code>start</code> and <code>maxtime</code>.  The distance is
determined by <code>exactness</code>.</p>
</td></tr>
<tr><td><code id="pec_+3A_cause">cause</code></td>
<td>
<p>For competing risks, the event of interest. Defaults to the
first state of the response, which is obtained by evaluating the left hand
side of <code>formula</code> in <code>data</code>.</p>
</td></tr>
<tr><td><code id="pec_+3A_start">start</code></td>
<td>
<p>Minimal time for estimating the prediction error curves.  If
missing and <code>formula</code> defines a <code>Surv</code> or <code>Hist</code> object then
<code>start</code> defaults to <code>0</code>, otherwise to the smallest observed value
of the response variable. <code>start</code> is ignored if <code>times</code> are given.</p>
</td></tr>
<tr><td><code id="pec_+3A_maxtime">maxtime</code></td>
<td>
<p>Maximal time for estimating the prediction error curves. If
missing the largest value of the response variable is used.</p>
</td></tr>
<tr><td><code id="pec_+3A_exact">exact</code></td>
<td>
<p>Logical. If <code>TRUE</code> estimate the prediction error curves at
all the unique values of the response variable. If <code>times</code> are given
and <code>exact=TRUE</code> then the <code>times</code> are merged with the unique
values of the response variable.</p>
</td></tr>
<tr><td><code id="pec_+3A_exactness">exactness</code></td>
<td>
<p>An integer that determines how many equidistant gridpoints
are used between <code>start</code> and <code>maxtime</code>.  The default is 100.</p>
</td></tr>
<tr><td><code id="pec_+3A_fillchar">fillChar</code></td>
<td>
<p>Symbol used to fill-in places where the values of the
prediction error curves are not available. The default is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="pec_+3A_cens.model">cens.model</code></td>
<td>
<p>Method for estimating inverse probability of censoring
weigths:
</p>
<p><code>cox</code>: A semi-parametric Cox proportional hazard model is fitted to the
censoring times
</p>
<p><code>marginal</code>: The Kaplan-Meier estimator for the censoring times
</p>
<p><code>nonpar</code>: Nonparametric extension of the Kaplan-Meier for the censoring
times using symmetric nearest neighborhoods &ndash; available for arbitrary many
strata variables on the right hand side of argument <code>formula</code> but at
most one continuous variable. See the documentation of the functions
<code>prodlim</code> and <code>neighborhood</code> from the prodlim package.
</p>
<p><code>aalen</code>: The nonparametric Aalen additive model fitted to the censoring
times. Requires the <code>timereg</code> package.</p>
</td></tr>
<tr><td><code id="pec_+3A_ipcw.refit">ipcw.refit</code></td>
<td>
<p>If <code>TRUE</code> the inverse probability of censoring
weigths are estimated separately in each training set during
cross-validation.</p>
</td></tr>
<tr><td><code id="pec_+3A_ipcw.args">ipcw.args</code></td>
<td>
<p>List of arguments passed to function specified by argument <code>cens.model</code>.</p>
</td></tr>
<tr><td><code id="pec_+3A_splitmethod">splitMethod</code></td>
<td>
<p>SplitMethod for estimating the prediction error curves.
</p>
<p><code>none/noPlan</code>: Assess the models in the same data where they are
fitted.  <code>boot</code>: DEPRECIATED.
</p>
<p><code>cvK</code>: K-fold cross-validation, i.e. <code>cv10</code> for 10-fold
cross-validation.  After splitting the data in K subsets, the prediction
models (ie those specified in <code>object</code>) are evaluated on the data
omitting the Kth subset (training step). The prediction error is estimated
with the Kth subset (validation step).
</p>
<p>The random splitting is repeated <code>B</code> times and the estimated prediction
error curves are obtained by averaging.
</p>
<p><code>BootCv</code>: Bootstrap cross validation. The prediction models are trained
on <code>B</code> bootstrap samples, that are either drawn with replacement of the
same size as the original data or without replacement from <code>data</code> of
the size <code>M</code>.  The models are assessed in the observations that are NOT
in the bootstrap sample.
</p>
<p><code>Boot632</code>: Linear combination of AppErr and BootCvErr using the
constant weight .632.
</p>
<p><code>Boot632plus</code>: Linear combination of AppErr and BootCv using weights
dependent on how the models perform in permuted data.
</p>
<p><code>loocv</code>: Leave one out cross-validation.
</p>
<p><code>NoInf</code>: Assess the models in permuted data.</p>
</td></tr>
<tr><td><code id="pec_+3A_b">B</code></td>
<td>
<p>Number of bootstrap samples. The default depends on argument
<code>splitMethod</code>.  When <code>splitMethod</code> in
c(&quot;BootCv&quot;,&quot;Boot632&quot;,&quot;Boot632plus&quot;) the default is 100. For
<code>splitMethod="cvK"</code> <code>B</code> is the number of cross-validation cycles,
and &ndash; default is 1.  For <code>splitMethod="none"</code> <code>B</code> is the number
of bootstrap simulations e.g. to obtain bootstrap confidence limits &ndash;
default is 0.</p>
</td></tr>
<tr><td><code id="pec_+3A_m">M</code></td>
<td>
<p>The size of the bootstrap samples for resampling without
replacement. Ignored for resampling with replacement.</p>
</td></tr>
<tr><td><code id="pec_+3A_reference">reference</code></td>
<td>
<p>Logical. If <code>TRUE</code> add the marginal Kaplan-Meier
prediction model as a reference to the list of models.</p>
</td></tr>
<tr><td><code id="pec_+3A_model.args">model.args</code></td>
<td>
<p>List of extra arguments that can be passed to the
<code>predictSurvProb</code> methods. The list must have an entry for each entry
in <code>object</code>.</p>
</td></tr>
<tr><td><code id="pec_+3A_model.parms">model.parms</code></td>
<td>
<p>Experimental.  List of with exactly one entry for each
entry in <code>object</code>.  Each entry names parts of the value of the fitted
models that should be extracted and added to the value.</p>
</td></tr>
<tr><td><code id="pec_+3A_keep.index">keep.index</code></td>
<td>
<p>Logical. If <code>FALSE</code> remove the bootstrap or
cross-validation index from the output list which otherwise is included in
the splitMethod part of the output list.</p>
</td></tr>
<tr><td><code id="pec_+3A_keep.matrix">keep.matrix</code></td>
<td>
<p>Logical. If <code>TRUE</code> add all <code>B</code> prediction error
curves from bootstrapping or cross-validation to the output.</p>
</td></tr>
<tr><td><code id="pec_+3A_keep.models">keep.models</code></td>
<td>
<p>Logical. If <code>TRUE</code> keep the models in object. Since
fitted models can be large objects the default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="pec_+3A_keep.residuals">keep.residuals</code></td>
<td>
<p>Logical. If <code>TRUE</code> keep the patient individual
residuals at <code>testTimes</code>.</p>
</td></tr>
<tr><td><code id="pec_+3A_keep.pvalues">keep.pvalues</code></td>
<td>
<p>For <code>multiSplitTest</code>. If <code>TRUE</code> keep the
pvalues from the single splits.</p>
</td></tr>
<tr><td><code id="pec_+3A_noinf.permute">noinf.permute</code></td>
<td>
<p>If <code>TRUE</code> the noinformation error is approximated
using permutation.</p>
</td></tr>
<tr><td><code id="pec_+3A_multisplittest">multiSplitTest</code></td>
<td>
<p>If <code>TRUE</code> the test proposed by van de Wiel et al.
(2009) is applied. Requires subsampling bootstrap cross-validation, i.e.
that <code>splitMethod</code> equals <code>bootcv</code> and that <code>M</code> is specified.</p>
</td></tr>
<tr><td><code id="pec_+3A_testibs">testIBS</code></td>
<td>
<p>A range of time points for testing differences between models
in the integrated Brier scores.</p>
</td></tr>
<tr><td><code id="pec_+3A_testtimes">testTimes</code></td>
<td>
<p>A vector of time points for testing differences between
models in the time-point specific Brier scores.</p>
</td></tr>
<tr><td><code id="pec_+3A_confint">confInt</code></td>
<td>
<p>Experimental.</p>
</td></tr>
<tr><td><code id="pec_+3A_conflevel">confLevel</code></td>
<td>
<p>Experimental.</p>
</td></tr>
<tr><td><code id="pec_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> report details of the progress, e.g. count the
steps in cross-validation.</p>
</td></tr>
<tr><td><code id="pec_+3A_savepath">savePath</code></td>
<td>
<p>Place in your file system (i.e., a directory on your
computer) where training models fitted during cross-validation are saved. If
<code>missing</code> training models are not saved.</p>
</td></tr>
<tr><td><code id="pec_+3A_slaveseed">slaveseed</code></td>
<td>
<p>Vector of seeds, as long as <code>B</code>, to be given to the
slaves in parallel computing.</p>
</td></tr>
<tr><td><code id="pec_+3A_na.action">na.action</code></td>
<td>
<p>Passed immediately to model.frame. Defaults to na.fail. If
set otherwise most prediction models will not work.</p>
</td></tr>
<tr><td><code id="pec_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that package riskRegression provides very similar
functionality (and much more) but not yet every feature of pec.
</p>
<p>Missing data in the response or in the input matrix cause a failure.
</p>
<p>The status of the continuous response variable at cutpoints (<code>times</code>),
ie status=1 if the response value exceeds the cutpoint and status=0
otherwise, is compared to predicted event status probabilities which are
provided by the prediction models on the basis of covariates.  The
comparison is done with the Brier score: the quadratic difference between
0-1 response status and predicted probability.
</p>
<p>There are two different sources for bias when estimating prediction error in
right censored survival problems: censoring and high flexibility of the
prediction model. The first is controlled by inverse probability of
censoring weighting, the second can be controlled by special Monte Carlo
simulation. In each step, the resampling procedures reevaluate the
prediction model.  Technically this is done by replacing the argument
<code>object$call$data</code> by the current subset or bootstrap sample of the
full data.
</p>
<p>For each prediction model there must be a <code>predictSurvProb</code> method: for
example, to assess a prediction model which evaluates to a <code>myclass</code>
object one defines a function called <code>predictSurvProb.myclass</code> with
arguments <code>object,newdata,cutpoints,...</code>
</p>
<p>Such a function takes the object and
derives a matrix with predicted event status probabilities for each subject
in newdata (rows) and each cutpoint (column) of the response variable that
defines an event status.
</p>
<p>Currently, <code>predictSurvProb</code> methods are readily available for 
various survival models, see <code>methods(predictSurvProb)</code>
</p>


<h3>Value</h3>

<p>A <code>pec</code> object. See also the help pages of the corresponding
<code>print</code>, <code>summary</code>, and <code>plot</code> methods.  The object includes
the following components: </p>
<table role = "presentation">
<tr><td><code>PredErr</code></td>
<td>
<p> The estimated prediction error
according to the <code>splitMethod</code>. A matrix where each column represents
the estimated prediction error of a fit at the time points in time.  </p>
</td></tr>
<tr><td><code>AppErr</code></td>
<td>
<p> The training error or apparent error obtained when the
model(s) are evaluated in the same data where they were trained. Only if
<code>splitMethod</code> is one of &quot;NoInf&quot;, &quot;cvK&quot;, &quot;BootCv&quot;, &quot;Boot632&quot; or
&quot;Boot632plus&quot;.  </p>
</td></tr> <tr><td><code>BootCvErr</code></td>
<td>
<p> The prediction error when the model(s)
are trained in the bootstrap sample and evaluated in the data that are not
in the bootstrap sample.  Only if <code>splitMethod</code> is one of &quot;Boot632&quot; or
&quot;Boot632plus&quot;. When <code>splitMethod="BootCv"</code> then the <code>BootCvErr</code> is
stored in the component <code>PredErr</code>.  </p>
</td></tr> <tr><td><code>NoInfErr</code></td>
<td>
<p> The prediction
error when the model(s) are evaluated in the permuted data.  Only if
<code>splitMethod</code> is one of &quot;BootCv&quot;, &quot;Boot632&quot;, or &quot;Boot632plus&quot;.  For
<code>splitMethod="NoInf"</code> the <code>NoInfErr</code> is stored in the component
<code>PredErr</code>.  </p>
</td></tr> <tr><td><code>weight</code></td>
<td>
<p> The weight used to linear combine the
<code>AppErr</code> and the <code>BootCvErr</code> Only if <code>splitMethod</code> is one of
&quot;Boot632&quot;, or &quot;Boot632plus&quot;.  </p>
</td></tr> <tr><td><code>overfit</code></td>
<td>
<p> Estimated <code>overfit</code> of
the model(s).  See Efron and Tibshirani (1997, Journal of the American
Statistical Association) and Gerds and Schumacher (2007, Biometrics).  Only
if <code>splitMethod</code> is one of &quot;Boot632&quot;, or &quot;Boot632plus&quot;.  </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The call that produced the object</p>
</td></tr> <tr><td><code>time</code></td>
<td>
<p>The time points
at which the prediction error curves change.</p>
</td></tr> <tr><td><code>ipcw.fit</code></td>
<td>
<p>The fitted
censoring model that was used for re-weighting the Brier score residuals.
See Gerds and Schumacher (2006, Biometrical Journal)</p>
</td></tr> <tr><td><code>n.risk</code></td>
<td>
<p>The
number of subjects at risk for all time points.</p>
</td></tr> <tr><td><code>models</code></td>
<td>
<p>The
prediction models fitted in their own data.</p>
</td></tr> <tr><td><code>cens.model</code></td>
<td>
<p>The censoring
models.</p>
</td></tr> <tr><td><code>maxtime</code></td>
<td>
<p>The latest timepoint where the prediction error
curves are estimated.</p>
</td></tr> <tr><td><code>start</code></td>
<td>
<p>The earliest timepoint where the
prediction error curves are estimated.</p>
</td></tr> <tr><td><code>exact</code></td>
<td>
<p><code>TRUE</code> if the
prediction error curves are estimated at all unique values of the response
in the full data.</p>
</td></tr> <tr><td><code>splitMethod</code></td>
<td>
<p>The splitMethod used for estimation of
the overfitting bias.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Alexander Gerds <a href="mailto:tag@biostat.ku.dk">tag@biostat.ku.dk</a>
</p>


<h3>References</h3>

<p>Gerds TA, Kattan MW.
Medical Risk Prediction Models: With Ties to Machine Learning.
Chapman and Hall/CRC
https://www.routledge.com/9781138384477
</p>
<p>Ulla B. Mogensen, Hemant Ishwaran, Thomas A. Gerds (2012).
Evaluating Random Forests for Survival Analysis Using Prediction Error
Curves. Journal of Statistical Software, 50(11), 1-23. DOI
10.18637/jss.v050.i11
</p>
<p>E. Graf et al.  (1999), Assessment and comparison of prognostic
classification schemes for survival data. Statistics in Medicine, vol 18,
pp= 2529&ndash;2545.
</p>
<p>Efron, Tibshirani (1997) Journal of the American Statistical Association 92,
548&ndash;560 Improvement On Cross-Validation: The .632+ Bootstrap Method.
</p>
<p>Gerds, Schumacher (2006), Consistent estimation of the expected Brier score
in general survival models with right-censored event times. Biometrical
Journal, vol 48, 1029&ndash;1040.
</p>
<p>Thomas A. Gerds, Martin Schumacher (2007) Efron-Type Measures of Prediction
Error for Survival Analysis Biometrics, 63(4), 1283&ndash;1287
doi:10.1111/j.1541-0420.2007.00832.x
</p>
<p>Martin Schumacher, Harald Binder, and Thomas Gerds. Assessment of survival
prediction models based on microarray data. Bioinformatics, 23(14):1768-74,
2007.
</p>
<p>Mark A. van de Wiel, Johannes Berkhof, and Wessel N. van Wieringen Testing
the prediction error difference between 2 predictors Biostatistics (2009)
10(3): 550-560 doi:10.1093/biostatistics/kxp011
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.pec">plot.pec</a></code>, <code><a href="#topic+summary.pec">summary.pec</a></code>,
<code><a href="#topic+R2">R2</a></code>, <code><a href="#topic+crps">crps</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# simulate an artificial data frame
# with survival response and two predictors

set.seed(130971)
library(prodlim)
library(survival)
dat &lt;- SimSurv(100)

# fit some candidate Cox models and compute the Kaplan-Meier estimate 

Models &lt;- list("Cox.X1"=coxph(Surv(time,status)~X1,data=dat,x=TRUE,y=TRUE),
              "Cox.X2"=coxph(Surv(time,status)~X2,data=dat,x=TRUE,y=TRUE),
              "Cox.X1.X2"=coxph(Surv(time,status)~X1+X2,data=dat,x=TRUE,y=TRUE))

# compute the apparent prediction error 
PredError &lt;- pec(object=Models,
                  formula=Surv(time,status)~X1+X2,
                  data=dat,
                  exact=TRUE,
                  cens.model="marginal",
                  splitMethod="none",
                  B=0,
                  verbose=TRUE)

print(PredError,times=seq(5,30,5))
summary(PredError)
plot(PredError,xlim=c(0,30))

# Comparison of Weibull model and Cox model
library(survival)
library(rms)
library(pec)
data(pbc)
pbc &lt;- pbc[sample(1:NROW(pbc),size=100),]
f1 &lt;- psm(Surv(time,status!=0)~edema+log(bili)+age+sex+albumin,data=pbc)
f2 &lt;- coxph(Surv(time,status!=0)~edema+log(bili)+age+sex+albumin,data=pbc,x=TRUE,y=TRUE)
f3 &lt;- cph(Surv(time,status!=0)~edema+log(bili)+age+sex+albumin,data=pbc,surv=TRUE)
brier &lt;- pec(list("Weibull"=f1,"CoxPH"=f2,"CPH"=f3),data=pbc,formula=Surv(time,status!=0)~1)
print(brier)
plot(brier)

# compute the .632+ estimate of the generalization error
set.seed(130971)
library(prodlim)
library(survival)
dat &lt;- SimSurv(100)
set.seed(17100)
PredError.632plus &lt;- pec(object=Models,
                  formula=Surv(time,status)~X1+X2,
                  data=dat,
                  exact=TRUE,
                  cens.model="marginal",
                  splitMethod="Boot632plus",
                  B=3,
                  verbose=TRUE)

print(PredError.632plus,times=seq(4,12,4))
summary(PredError.632plus)
plot(PredError.632plus,xlim=c(0,30))
# do the same again but now in parallel
## Not run: set.seed(17100)
# library(doMC)
# registerDoMC()
PredError.632plus &lt;- pec(object=Models,
                  formula=Surv(time,status)~X1+X2,
                  data=dat,
                  exact=TRUE,
                  cens.model="marginal",
                  splitMethod="Boot632plus",
                  B=3,
                  verbose=TRUE)

## End(Not run)
# assessing parametric survival models in learn/validation setting
learndat &lt;- SimSurv(50)
testdat &lt;- SimSurv(30)
library(survival)
library(rms)
f1 &lt;- psm(Surv(time,status)~X1+X2,data=learndat)
f2 &lt;- psm(Surv(time,status)~X1,data=learndat)
pf &lt;- pec(list(f1,f2),formula=Surv(time,status)~1,data=testdat,maxtime=200)
plot(pf)
summary(pf)

# ---------------- competing risks -----------------

library(survival)
library(riskRegression)
if(requireNamespace("cmprsk",quietly=TRUE)){
library(cmprsk)
library(pec)
cdat &lt;- SimCompRisk(100)
f1  &lt;- CSC(Hist(time,event)~X1+X2,cause=2,data=cdat)
f2  &lt;- CSC(Hist(time,event)~X1,data=cdat,cause=2)
f3  &lt;- FGR(Hist(time,event)~X1+X2,cause=2,data=cdat)
f4  &lt;- FGR(Hist(time,event)~X1+X2,cause=2,data=cdat)
p1 &lt;- pec(list(f1,f2,f3,f4),formula=Hist(time,event)~1,data=cdat,cause=2)
}

</code></pre>

<hr>
<h2 id='pecCforest'>S3-wrapper function for cforest from the party package</h2><span id='topic+pecCforest'></span>

<h3>Description</h3>

<p>S3-wrapper function for cforest from the party package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pecCforest(formula, data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pecCforest_+3A_formula">formula</code></td>
<td>
<p>Passed on as is. See <code>cforest</code> of the <code>party</code> package</p>
</td></tr>
<tr><td><code id="pecCforest_+3A_data">data</code></td>
<td>
<p>Passed on as is. See <code>cforest</code> of the <code>party</code> package</p>
</td></tr>
<tr><td><code id="pecCforest_+3A_...">...</code></td>
<td>
<p>Passed on as they are. See <code>cforest</code> of the <code>party</code> package</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>cforest</code> of the <code>party</code> package.
</p>


<h3>Value</h3>

<p>list with two elements: cforest and call
</p>


<h3>References</h3>

<p>Ulla B. Mogensen, Hemant Ishwaran, Thomas A. Gerds (2012).
Evaluating Random Forests for Survival Analysis Using Prediction Error
Curves. Journal of Statistical Software, 50(11), 1-23. DOI
10.18637/jss.v050.i11
</p>

<hr>
<h2 id='pecCtree'>S3-Wrapper for ctree.</h2><span id='topic+pecCtree'></span>

<h3>Description</h3>

<p>The call is added to an ctree object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pecCtree(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pecCtree_+3A_...">...</code></td>
<td>
<p>passed to ctree</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with two elements: ctree and call
</p>


<h3>Author(s)</h3>

<p>Thomas A. Gerds &lt;tag@biostat.ku.dk&gt;
</p>


<h3>See Also</h3>

<p>pecCforest
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("party",quietly=TRUE)){
library(prodlim)
library(survival)
set.seed(50)
d &lt;- SimSurv(50)
nd &lt;- data.frame(X1=c(0,1,0),X2=c(-1,0,1))
f &lt;- pecCtree(Surv(time,status)~X1+X2,data=d)
predictSurvProb(f,newdata=nd,times=c(3,8))
}

</code></pre>

<hr>
<h2 id='pecRpart'>Predict survival based on rpart tree object</h2><span id='topic+pecRpart'></span>

<h3>Description</h3>

<p>Combines the rpart result with a stratified Kaplan-Meier (prodlim) to predict survival
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pecRpart(formula, data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pecRpart_+3A_formula">formula</code></td>
<td>
<p>passed to rpart</p>
</td></tr>
<tr><td><code id="pecRpart_+3A_data">data</code></td>
<td>
<p>passed to rpart</p>
</td></tr>
<tr><td><code id="pecRpart_+3A_...">...</code></td>
<td>
<p>passed to rpart</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with three elements: ctree and call
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(prodlim)
if (!requireNamespace("rpart",quietly=TRUE)){
library(rpart)
library(survival)
set.seed(50)
d &lt;- SimSurv(50)
nd &lt;- data.frame(X1=c(0,1,0),X2=c(-1,0,1))
f &lt;- pecRpart(Surv(time,status)~X1+X2,data=d)
predictSurvProb(f,newdata=nd,times=c(3,8))
}
</code></pre>

<hr>
<h2 id='plot.calibrationPlot'>Plot objects obtained with <code>calPlot</code></h2><span id='topic+plot.calibrationPlot'></span>

<h3>Description</h3>

<p>Calibration plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'calibrationPlot'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.calibrationPlot_+3A_x">x</code></td>
<td>
<p>Object obtained with <code>calPlot</code></p>
</td></tr>
<tr><td><code id="plot.calibrationPlot_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Author(s)</h3>

<p>Thomas A. Gerds &lt;tag@biostat.ku.dk&gt;
</p>


<h3>See Also</h3>

<p><code>calPlot</code>
</p>

<hr>
<h2 id='plot.pec'>Plotting prediction error curves</h2><span id='topic+plot.pec'></span>

<h3>Description</h3>

<p>Plotting prediction error curves for one or more prediction models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pec'
plot(
  x,
  what,
  models,
  xlim = c(x$start, x$minmaxtime),
  ylim = c(0, 0.3),
  xlab = "Time",
  ylab,
  axes = TRUE,
  col,
  lty,
  lwd,
  type,
  smooth = FALSE,
  add.refline = FALSE,
  add = FALSE,
  legend = ifelse(add, FALSE, TRUE),
  special = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.pec_+3A_x">x</code></td>
<td>
<p>Object of class <code>pec</code> obtained with function
<code><a href="#topic+pec">pec</a></code>.</p>
</td></tr>
<tr><td><code id="plot.pec_+3A_what">what</code></td>
<td>
<p>The name of the entry in <code>x</code>. Defauls to <code>PredErr</code>
Other choices are <code>AppErr</code>, <code>BootCvErr</code>, <code>Boot632</code>,
<code>Boot632plus</code>.</p>
</td></tr>
<tr><td><code id="plot.pec_+3A_models">models</code></td>
<td>
<p>Specifies models in <code>x$models</code> for which the prediction
error curves are drawn. Defaults to all models.</p>
</td></tr>
<tr><td><code id="plot.pec_+3A_xlim">xlim</code></td>
<td>
<p>Plotting range on the x-axis.</p>
</td></tr>
<tr><td><code id="plot.pec_+3A_ylim">ylim</code></td>
<td>
<p>Plotting range on the y-axis.</p>
</td></tr>
<tr><td><code id="plot.pec_+3A_xlab">xlab</code></td>
<td>
<p>Label given to the x-axis.</p>
</td></tr>
<tr><td><code id="plot.pec_+3A_ylab">ylab</code></td>
<td>
<p>Label given to the y-axis.</p>
</td></tr>
<tr><td><code id="plot.pec_+3A_axes">axes</code></td>
<td>
<p>Logical. If <code>FALSE</code> no axes are drawn.</p>
</td></tr>
<tr><td><code id="plot.pec_+3A_col">col</code></td>
<td>
<p>Vector of colors given to the curves of <code>models</code> in the
order determined by <code>models</code>.</p>
</td></tr>
<tr><td><code id="plot.pec_+3A_lty">lty</code></td>
<td>
<p>Vector of lty's given to the curves of <code>models</code> in the order
determined by <code>models</code>.</p>
</td></tr>
<tr><td><code id="plot.pec_+3A_lwd">lwd</code></td>
<td>
<p>Vector of lwd's given to the curves of <code>models</code> in the order
determined by <code>models</code>.</p>
</td></tr>
<tr><td><code id="plot.pec_+3A_type">type</code></td>
<td>
<p>Plotting type: either <code>"l"</code> or <code>"s"</code>, see
<code>lines</code>.</p>
</td></tr>
<tr><td><code id="plot.pec_+3A_smooth">smooth</code></td>
<td>
<p>Logical. If <code>TRUE</code> the plotting type for lines is <code>'l'</code> else <code>'s'</code>.</p>
</td></tr>
<tr><td><code id="plot.pec_+3A_add.refline">add.refline</code></td>
<td>
<p>Logical. If <code>TRUE</code> a dotted horizontal line is drawn
as a symbol for the naive rule that predicts probability .5 at all cutpoints
(i.e. time points in survival analysis).</p>
</td></tr>
<tr><td><code id="plot.pec_+3A_add">add</code></td>
<td>
<p>Logical. If <code>TRUE</code> only lines are added to an existing
device</p>
</td></tr>
<tr><td><code id="plot.pec_+3A_legend">legend</code></td>
<td>
<p>if TRUE a legend is plotted by calling the function legend.
Optional arguments of the function <code>legend</code> can be given in the form
<code>legend.x=val</code> where x is the name of the argument and val the desired
value. See also Details.</p>
</td></tr>
<tr><td><code id="plot.pec_+3A_special">special</code></td>
<td>
<p>Logical. If <code>TRUE</code> the bootstrap curves of <code>models</code>
are plotted together with <code>predErr</code> of <code>models</code> by invoking the
function <code>Special</code>. Optional arguments of the function <code>Special</code>
can be given in the form <code>special.x=val</code> as with legend. See also
Details.</p>
</td></tr>
<tr><td><code id="plot.pec_+3A_...">...</code></td>
<td>
<p>Extra arguments that are passed to <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>From version 2.0.1 on the arguments legend.text, legend.args, lines.type,
lwd.lines, specials are obsolete and only available for backward
compatibility. Instead arguments for the invoked functions <code>legend</code>,
<code>axis</code>, <code>Special</code> are simply specified as <code>legend.lty=2</code>. The
specification is not case sensitive, thus <code>Legend.lty=2</code> or
<code>LEGEND.lty=2</code> will have the same effect.  The function <code>axis</code> is
called twice, and arguments of the form <code>axis1.labels</code>, <code>axis1.at</code>
are used for the time axis whereas <code>axis2.pos</code>, <code>axis1.labels</code>,
etc. are used for the y-axis.
</p>
<p>These arguments are processed via <code>...{}</code> of <code>plot.pec</code> and
inside by using the function <code>resolveSmartArgs</code>.  Documentation of
these arguments can be found in the help pages of the corresponding
functions.
</p>


<h3>Value</h3>

<p>The (invisible) object.
</p>


<h3>Author(s)</h3>

<p>Ulla B. Mogensen <a href="mailto:ulmo@biostat.ku.dk">ulmo@biostat.ku.dk</a>, Thomas A. Gerds
<a href="mailto:tag@biostat.ku.dk">tag@biostat.ku.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pec">pec</a></code><code><a href="#topic+summary.pec">summary.pec</a></code><code><a href="#topic+Special">Special</a></code><code><a href="prodlim.html#topic+prodlim">prodlim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# simulate data
# with a survival response and two predictors
library(prodlim)
library(survival)
set.seed(280180)
dat &lt;- SimSurv(100)

# fit some candidate Cox models and
# compute the Kaplan-Meier estimate 

Models &lt;- list("Kaplan.Meier"=survfit(Surv(time,status)~1,data=dat),
               "Cox.X1"=coxph(Surv(time,status)~X1,data=dat,x=TRUE,y=TRUE),
               "Cox.X2"=coxph(Surv(time,status)~X2,data=dat,x=TRUE,y=TRUE),
               "Cox.X1.X2"=coxph(Surv(time,status)~X1+X2,data=dat,x=TRUE,y=TRUE))
Models &lt;- list("Cox.X1"=coxph(Surv(time,status)~X1,data=dat,x=TRUE,y=TRUE),
               "Cox.X2"=coxph(Surv(time,status)~X2,data=dat,x=TRUE,y=TRUE),
               "Cox.X1.X2"=coxph(Surv(time,status)~X1+X2,data=dat,x=TRUE,y=TRUE))


# compute the .632+ estimate of the generalization error 
set.seed(17100)
PredError.632plus &lt;- pec(object=Models,
                         formula=Surv(time,status)~X1+X2,
                         data=dat,
                         exact=TRUE,
                         cens.model="marginal",
                         splitMethod="boot632plus",
                         B=5,
                         keep.matrix=TRUE,
                         verbose=TRUE)

# plot the .632+ estimates of the generalization error 
plot(PredError.632plus,xlim=c(0,30))

# plot the bootstrapped curves, .632+ estimates of the generalization error
# and Apparent error for the Cox model 'Cox.X1' with the 'Cox.X2' model
# as benchmark
plot(PredError.632plus,
     xlim=c(0,30),
     models="Cox.X1",
     special=TRUE,
     special.bench="Cox.X2",
     special.benchcol=2,
     special.addprederr="AppErr")


</code></pre>

<hr>
<h2 id='plotPredictEventProb'>Plotting predicted survival curves.</h2><span id='topic+plotPredictEventProb'></span>

<h3>Description</h3>

<p>Ploting time-dependent event risk predictions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPredictEventProb(
  x,
  newdata,
  times,
  cause = 1,
  xlim,
  ylim,
  xlab,
  ylab,
  axes = TRUE,
  col,
  density,
  lty,
  lwd,
  add = FALSE,
  legend = TRUE,
  percent = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotPredictEventProb_+3A_x">x</code></td>
<td>
<p>Object specifying an event risk prediction model.</p>
</td></tr>
<tr><td><code id="plotPredictEventProb_+3A_newdata">newdata</code></td>
<td>
<p>A data frame with the same variable names as those that were
used to fit the model <code>x</code>.</p>
</td></tr>
<tr><td><code id="plotPredictEventProb_+3A_times">times</code></td>
<td>
<p>Vector of times at which to return the estimated probabilities.</p>
</td></tr>
<tr><td><code id="plotPredictEventProb_+3A_cause">cause</code></td>
<td>
<p>Show predicted risk of events of this cause</p>
</td></tr>
<tr><td><code id="plotPredictEventProb_+3A_xlim">xlim</code></td>
<td>
<p>Plotting range on the x-axis.</p>
</td></tr>
<tr><td><code id="plotPredictEventProb_+3A_ylim">ylim</code></td>
<td>
<p>Plotting range on the y-axis.</p>
</td></tr>
<tr><td><code id="plotPredictEventProb_+3A_xlab">xlab</code></td>
<td>
<p>Label given to the x-axis.</p>
</td></tr>
<tr><td><code id="plotPredictEventProb_+3A_ylab">ylab</code></td>
<td>
<p>Label given to the y-axis.</p>
</td></tr>
<tr><td><code id="plotPredictEventProb_+3A_axes">axes</code></td>
<td>
<p>Logical. If <code>FALSE</code> no axes are drawn.</p>
</td></tr>
<tr><td><code id="plotPredictEventProb_+3A_col">col</code></td>
<td>
<p>Vector of colors given to the survival curve.</p>
</td></tr>
<tr><td><code id="plotPredictEventProb_+3A_density">density</code></td>
<td>
<p>Densitiy of the color &ndash; useful for showing many
(overlapping) curves.</p>
</td></tr>
<tr><td><code id="plotPredictEventProb_+3A_lty">lty</code></td>
<td>
<p>Vector of lty's given to the survival curve.</p>
</td></tr>
<tr><td><code id="plotPredictEventProb_+3A_lwd">lwd</code></td>
<td>
<p>Vector of lwd's given to the survival curve.</p>
</td></tr>
<tr><td><code id="plotPredictEventProb_+3A_add">add</code></td>
<td>
<p>Logical. If <code>TRUE</code> only lines are added to an existing
device</p>
</td></tr>
<tr><td><code id="plotPredictEventProb_+3A_legend">legend</code></td>
<td>
<p>Logical. If TRUE a legend is plotted by calling the function
legend.  Optional arguments of the function <code>legend</code> can be given in
the form <code>legend.x=val</code> where x is the name of the argument and val the
desired value. See also Details.</p>
</td></tr>
<tr><td><code id="plotPredictEventProb_+3A_percent">percent</code></td>
<td>
<p>Logical. If <code>TRUE</code> the y-axis is labeled in percent.</p>
</td></tr>
<tr><td><code id="plotPredictEventProb_+3A_...">...</code></td>
<td>
<p>Parameters that are filtered by <code><a href="prodlim.html#topic+SmartControl">SmartControl</a></code> and
then passed to the functions: <code><a href="base.html#topic+plot">plot</a></code>, <code><a href="graphics.html#topic+axis">axis</a></code>,
<code><a href="graphics.html#topic+legend">legend</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Arguments for the invoked functions <code>legend</code> and <code>axis</code> are simply
specified as <code>legend.lty=2</code>. The specification is not case sensitive,
thus <code>Legend.lty=2</code> or <code>LEGEND.lty=2</code> will have the same effect.
The function <code>axis</code> is called twice, and arguments of the form
<code>axis1.labels</code>, <code>axis1.at</code> are used for the time axis whereas
<code>axis2.pos</code>, <code>axis1.labels</code>, etc.  are used for the y-axis.
</p>
<p>These arguments are processed via <code>...{}</code> of
<code>plotPredictEventProb</code> and inside by using the function
<code>SmartControl</code>.
</p>


<h3>Value</h3>

<p>The (invisible) object.
</p>


<h3>Author(s)</h3>

<p>Ulla B. Mogensen <a href="mailto:ulmo@biostat.ku.dk">ulmo@biostat.ku.dk</a>, Thomas A. Gerds
<a href="mailto:tag@biostat.ku.dk">tag@biostat.ku.dk</a>
</p>


<h3>References</h3>

<p>Ulla B. Mogensen, Hemant Ishwaran, Thomas A. Gerds (2012).
Evaluating Random Forests for Survival Analysis Using Prediction Error
Curves. Journal of Statistical Software, 50(11), 1-23. DOI
10.18637/jss.v050.i11
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predictEventProb">predictEventProb</a></code><code><a href="prodlim.html#topic+prodlim">prodlim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# competing risk data
library(riskRegression)
library(pec)
set.seed(9)
d=sampleData(80)
csc1 &lt;- CSC(Hist(time,event)~X1+X8, data=d)
nd=sampleData(3)
plotPredictEventProb(csc1, newdata=nd, cause=1, col=1:3)

</code></pre>

<hr>
<h2 id='plotPredictSurvProb'>Plotting predicted survival curves.</h2><span id='topic+plotPredictSurvProb'></span>

<h3>Description</h3>

<p>Ploting prediction survival curves for one prediction model using
<code>predictSurvProb</code> .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPredictSurvProb(
  x,
  newdata,
  times,
  xlim,
  ylim,
  xlab,
  ylab,
  axes = TRUE,
  col,
  density,
  lty,
  lwd,
  add = FALSE,
  legend = TRUE,
  percent = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotPredictSurvProb_+3A_x">x</code></td>
<td>
<p>A survival prediction model including <code>call</code> and
<code>formula</code> object.</p>
</td></tr>
<tr><td><code id="plotPredictSurvProb_+3A_newdata">newdata</code></td>
<td>
<p>A data frame with the same variable names as those that were
used to fit the model <code>x</code>.</p>
</td></tr>
<tr><td><code id="plotPredictSurvProb_+3A_times">times</code></td>
<td>
<p>Vector of times at which to return the estimated probabilities.</p>
</td></tr>
<tr><td><code id="plotPredictSurvProb_+3A_xlim">xlim</code></td>
<td>
<p>Plotting range on the x-axis.</p>
</td></tr>
<tr><td><code id="plotPredictSurvProb_+3A_ylim">ylim</code></td>
<td>
<p>Plotting range on the y-axis.</p>
</td></tr>
<tr><td><code id="plotPredictSurvProb_+3A_xlab">xlab</code></td>
<td>
<p>Label given to the x-axis.</p>
</td></tr>
<tr><td><code id="plotPredictSurvProb_+3A_ylab">ylab</code></td>
<td>
<p>Label given to the y-axis.</p>
</td></tr>
<tr><td><code id="plotPredictSurvProb_+3A_axes">axes</code></td>
<td>
<p>Logical. If <code>FALSE</code> no axes are drawn.</p>
</td></tr>
<tr><td><code id="plotPredictSurvProb_+3A_col">col</code></td>
<td>
<p>Vector of colors given to the survival curve.</p>
</td></tr>
<tr><td><code id="plotPredictSurvProb_+3A_density">density</code></td>
<td>
<p>Densitiy of the color &ndash; useful for showing many
(overlapping) curves.</p>
</td></tr>
<tr><td><code id="plotPredictSurvProb_+3A_lty">lty</code></td>
<td>
<p>Vector of lty's given to the survival curve.</p>
</td></tr>
<tr><td><code id="plotPredictSurvProb_+3A_lwd">lwd</code></td>
<td>
<p>Vector of lwd's given to the survival curve.</p>
</td></tr>
<tr><td><code id="plotPredictSurvProb_+3A_add">add</code></td>
<td>
<p>Logical. If <code>TRUE</code> only lines are added to an existing
device</p>
</td></tr>
<tr><td><code id="plotPredictSurvProb_+3A_legend">legend</code></td>
<td>
<p>Logical. If TRUE a legend is plotted by calling the function
legend.  Optional arguments of the function <code>legend</code> can be given in
the form <code>legend.x=val</code> where x is the name of the argument and val the
desired value. See also Details.</p>
</td></tr>
<tr><td><code id="plotPredictSurvProb_+3A_percent">percent</code></td>
<td>
<p>Logical. If <code>TRUE</code> the y-axis is labeled in percent.</p>
</td></tr>
<tr><td><code id="plotPredictSurvProb_+3A_...">...</code></td>
<td>
<p>Parameters that are filtered by <code><a href="prodlim.html#topic+SmartControl">SmartControl</a></code> and
then passed to the functions: <code><a href="base.html#topic+plot">plot</a></code>, <code><a href="graphics.html#topic+axis">axis</a></code>,
<code><a href="graphics.html#topic+legend">legend</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Arguments for the invoked functions <code>legend</code> and <code>axis</code> are simply
specified as <code>legend.lty=2</code>. The specification is not case sensitive,
thus <code>Legend.lty=2</code> or <code>LEGEND.lty=2</code> will have the same effect.
The function <code>axis</code> is called twice, and arguments of the form
<code>axis1.labels</code>, <code>axis1.at</code> are used for the time axis whereas
<code>axis2.pos</code>, <code>axis1.labels</code>, etc.  are used for the y-axis.
</p>
<p>These arguments are processed via <code>...{}</code> of
<code>plotPredictSurvProb</code> and inside by using the function
<code>SmartControl</code>.
</p>


<h3>Value</h3>

<p>The (invisible) object.
</p>


<h3>Author(s)</h3>

<p>Ulla B. Mogensen <a href="mailto:ulmo@biostat.ku.dk">ulmo@biostat.ku.dk</a>, Thomas A. Gerds
<a href="mailto:tag@biostat.ku.dk">tag@biostat.ku.dk</a>
</p>


<h3>References</h3>

<p>Ulla B. Mogensen, Hemant Ishwaran, Thomas A. Gerds (2012).
Evaluating Random Forests for Survival Analysis Using Prediction Error
Curves. Journal of Statistical Software, 50(11), 1-23. DOI
10.18637/jss.v050.i11
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predictSurvProb">predictSurvProb</a></code><code><a href="prodlim.html#topic+prodlim">prodlim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# generate some survival data
library(prodlim)
d &lt;- SimSurv(100)
# then fit a Cox model
library(survival)
library(rms)
coxmodel &lt;- cph(Surv(time,status)~X1+X2,data=d,surv=TRUE)
# plot predicted survival probabilities for all time points
ttt &lt;- sort(unique(d$time))
# and for selected predictor values:
 ndat &lt;- data.frame(X1=c(0.25,0.25,-0.05,0.05),X2=c(0,1,0,1))
plotPredictSurvProb(coxmodel,newdata=ndat,times=ttt)

</code></pre>

<hr>
<h2 id='predictEventProb'>Predicting event probabilities (cumulative incidences) in competing risk
models.</h2><span id='topic+predictEventProb'></span><span id='topic+predictEventProb.CauseSpecificCox'></span><span id='topic+predictEventProb.riskRegression'></span><span id='topic+predictEventProb.FGR'></span><span id='topic+predictEventProb.prodlim'></span><span id='topic+predictEventProb.rfsrc'></span>

<h3>Description</h3>

<p>Function to extract event probability predictions from various modeling
approaches. The most prominent one is the combination of cause-specific Cox
regression models which can be fitted with the function <code>cumincCox</code>
from the package <code>compRisk</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictEventProb(object, newdata, times, cause, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predictEventProb_+3A_object">object</code></td>
<td>
<p>A fitted model from which to extract predicted event
probabilities</p>
</td></tr>
<tr><td><code id="predictEventProb_+3A_newdata">newdata</code></td>
<td>
<p>A data frame containing predictor variable combinations for
which to compute predicted event probabilities.</p>
</td></tr>
<tr><td><code id="predictEventProb_+3A_times">times</code></td>
<td>
<p>A vector of times in the range of the response variable, for
which the cumulative incidences event probabilities are computed.</p>
</td></tr>
<tr><td><code id="predictEventProb_+3A_cause">cause</code></td>
<td>
<p>Identifies the cause of interest among the competing events.</p>
</td></tr>
<tr><td><code id="predictEventProb_+3A_...">...</code></td>
<td>
<p>Additional arguments that are passed on to the current method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function predictEventProb is a generic function that means it invokes
specifically designed functions depending on the 'class' of the first
argument.
</p>
<p>See <code><a href="#topic+predictSurvProb">predictSurvProb</a></code>.
</p>


<h3>Value</h3>

<p>A matrix with as many rows as <code>NROW(newdata)</code> and as many
columns as <code>length(times)</code>. Each entry should be a probability and in
rows the values should be increasing.
</p>


<h3>Author(s)</h3>

<p>Thomas A. Gerds <a href="mailto:tag@biostat.ku.dk">tag@biostat.ku.dk</a>
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+predictSurvProb">predictSurvProb</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(pec)
library(survival)
library(riskRegression)
library(prodlim)
train &lt;- SimCompRisk(100)
test &lt;- SimCompRisk(10)
cox.fit  &lt;- CSC(Hist(time,cause)~X1+X2,data=train)
predictEventProb(cox.fit,newdata=test,times=seq(1:10),cause=1)

## with strata
cox.fit2  &lt;- CSC(list(Hist(time,cause)~strata(X1)+X2,Hist(time,cause)~X1+X2),data=train)
predictEventProb(cox.fit2,newdata=test,times=seq(1:10),cause=1)

</code></pre>

<hr>
<h2 id='predictLifeYearsLost'>Predicting life years lost (cumulative cumulative incidences) in competing
risk models.</h2><span id='topic+predictLifeYearsLost'></span><span id='topic+predictLifeYearsLost.CauseSpecificCox'></span><span id='topic+predictLifeYearsLost.riskRegression'></span><span id='topic+predictLifeYearsLost.FGR'></span><span id='topic+predictLifeYearsLost.prodlim'></span><span id='topic+predictLifeYearsLost.rfsrc'></span>

<h3>Description</h3>

<p>Function to extract predicted life years lost from various modeling
approaches. The most prominent one is the combination of cause-specific Cox
regression models which can be fitted with the function <code>cumincCox</code>
from the package <code>compRisk</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictLifeYearsLost(object, newdata, times, cause, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predictLifeYearsLost_+3A_object">object</code></td>
<td>
<p>A fitted model from which to extract predicted event
probabilities</p>
</td></tr>
<tr><td><code id="predictLifeYearsLost_+3A_newdata">newdata</code></td>
<td>
<p>A data frame containing predictor variable combinations for
which to compute predicted event probabilities.</p>
</td></tr>
<tr><td><code id="predictLifeYearsLost_+3A_times">times</code></td>
<td>
<p>A vector of times in the range of the response variable, for
which the cumulative incidences event probabilities are computed.</p>
</td></tr>
<tr><td><code id="predictLifeYearsLost_+3A_cause">cause</code></td>
<td>
<p>Identifies the cause of interest among the competing events.</p>
</td></tr>
<tr><td><code id="predictLifeYearsLost_+3A_...">...</code></td>
<td>
<p>Additional arguments that are passed on to the current method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function predictLifeYearsLost is a generic function that means it
invokes specifically designed functions depending on the 'class' of the
first argument.
</p>
<p>See <code><a href="#topic+predictSurvProb">predictSurvProb</a></code>.
</p>


<h3>Value</h3>

<p>A matrix with as many rows as <code>NROW(newdata)</code> and as many
columns as <code>length(times)</code>. Each entry should be a positive value and
in rows the values should be increasing.
</p>


<h3>Author(s)</h3>

<p>Thomas A. Gerds <a href="mailto:tag@biostat.ku.dk">tag@biostat.ku.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predictSurvProb">predictSurvProb</a></code>, <code><a href="#topic+predictEventProb">predictEventProb</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(pec)
library(riskRegression)
library(survival)
library(prodlim)
train &lt;- SimCompRisk(100)
test &lt;- SimCompRisk(10)
fit &lt;- CSC(Hist(time,cause)~X1+X2,data=train,cause=1)
predictLifeYearsLost(fit,newdata=test,times=seq(1:10),cv=FALSE,cause=1)

</code></pre>

<hr>
<h2 id='predictRestrictedMeanTime'>Predicting restricted mean time</h2><span id='topic+predictRestrictedMeanTime'></span><span id='topic+predictRestrictedMeanTime.aalen'></span><span id='topic+predictRestrictedMeanTime.riskRegression'></span><span id='topic+predictRestrictedMeanTime.cox.aalen'></span><span id='topic+predictRestrictedMeanTime.coxph'></span><span id='topic+predictRestrictedMeanTime.cph'></span><span id='topic+predictRestrictedMeanTime.default'></span><span id='topic+predictRestrictedMeanTime.rfsrc'></span><span id='topic+predictRestrictedMeanTime.matrix'></span><span id='topic+predictRestrictedMeanTime.pecCtree'></span><span id='topic+predictRestrictedMeanTime.prodlim'></span><span id='topic+predictRestrictedMeanTime.psm'></span><span id='topic+predictRestrictedMeanTime.selectCox'></span><span id='topic+predictRestrictedMeanTime.survfit'></span><span id='topic+predictRestrictedMeanTime.pecRpart'></span>

<h3>Description</h3>

<p>Function to extract predicted mean times from various modeling
approaches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'aalen'
predictRestrictedMeanTime(object,newdata,times,...)
## S3 method for class 'riskRegression'
predictRestrictedMeanTime(object,newdata,times,...)
## S3 method for class 'cox.aalen'
predictRestrictedMeanTime(object,newdata,times,...)
## S3 method for class 'cph'
predictRestrictedMeanTime(object,newdata,times,...)
## S3 method for class 'coxph'
predictRestrictedMeanTime(object,newdata,times,...)
## S3 method for class 'matrix'
predictRestrictedMeanTime(object,newdata,times,...)
## S3 method for class 'selectCox'
predictRestrictedMeanTime(object,newdata,times,...)
## S3 method for class 'prodlim'
predictRestrictedMeanTime(object,newdata,times,...)
## S3 method for class 'psm'
predictRestrictedMeanTime(object,newdata,times,...)
## S3 method for class 'survfit'
predictRestrictedMeanTime(object,newdata,times,...)
## S3 method for class 'pecRpart'
predictRestrictedMeanTime(object,newdata,times,...)
#' \method{predictRestrictedMeanTime}{pecCtree}(object,newdata,times,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predictRestrictedMeanTime_+3A_object">object</code></td>
<td>
<p>A fitted model from which to extract predicted survival
probabilities</p>
</td></tr>
<tr><td><code id="predictRestrictedMeanTime_+3A_newdata">newdata</code></td>
<td>
<p>A data frame containing predictor variable combinations for
which to compute predicted survival probabilities.</p>
</td></tr>
<tr><td><code id="predictRestrictedMeanTime_+3A_times">times</code></td>
<td>
<p>A vector of times in the range of the response variable, e.g.
times when the response is a survival object, at which to return the
survival probabilities.</p>
</td></tr>
<tr><td><code id="predictRestrictedMeanTime_+3A_...">...</code></td>
<td>
<p>Additional arguments that are passed on to the current method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function predictRestrictedMeanTime is a generic function, meaning that it
invokes a different function dependent on the 'class' of the
first argument. 
</p>
<p>See also <code><a href="#topic+predictSurvProb">predictSurvProb</a></code>.
</p>


<h3>Value</h3>

<p>A matrix with as many rows as <code>NROW(newdata)</code> and as many
columns as <code>length(times)</code>. Each entry should be a probability and in
rows the values should be decreasing.
</p>


<h3>Note</h3>

<p>In order to assess the predictive performance of a new survival model
a specific <code>predictRestrictedMeanTime</code> S3 method has to be written. For examples,
see the bodies of the existing methods.
</p>
<p>The performance of the assessment procedure, in particular for resampling
where the model is repeatedly evaluated, will be improved by supressing in
the call to the model all the computations that are not needed for
probability prediction. For example, <code>se.fit=FALSE</code> can be set in the
call to <code>cph</code>.
</p>


<h3>Author(s)</h3>

<p>Thomas A. Gerds <a href="mailto:tag@biostat.ku.dk">tag@biostat.ku.dk</a>
</p>


<h3>References</h3>

<p>Ulla B. Mogensen, Hemant Ishwaran, Thomas A. Gerds (2012).
Evaluating Random Forests for Survival Analysis Using Prediction Error
Curves. Journal of Statistical Software, 50(11), 1-23. DOI
10.18637/jss.v050.i11
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+predict">predict</a></code>,<code><a href="survival.html#topic+survfit">survfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# generate some survival data
library(prodlim)
set.seed(100)
d &lt;- SimSurv(100)
# then fit a Cox model
library(rms)
library(survival)
coxmodel &lt;- cph(Surv(time,status)~X1+X2,data=d,surv=TRUE)

# predicted survival probabilities can be extracted
# at selected time-points:
ttt &lt;- quantile(d$time)
# for selected predictor values:
ndat &lt;- data.frame(X1=c(0.25,0.25,-0.05,0.05),X2=c(0,1,0,1))
# as follows
predictRestrictedMeanTime(coxmodel,newdata=ndat,times=ttt)

# stratified cox model
sfit &lt;- coxph(Surv(time,status)~strata(X1)+X2,data=d,x=TRUE,y=TRUE)
predictRestrictedMeanTime(sfit,newdata=d[1:3,],times=c(1,3,5,10))

## simulate some learning and some validation data
learndat &lt;- SimSurv(100)
valdat &lt;- SimSurv(100)
## use the learning data to fit a Cox model
library(survival)
fitCox &lt;- coxph(Surv(time,status)~X1+X2,data=learndat,x=TRUE,y=TRUE)
## suppose we want to predict the survival probabilities for all patients
## in the validation data at the following time points:
## 0, 12, 24, 36, 48, 60
psurv &lt;- predictRestrictedMeanTime(fitCox,newdata=valdat,times=seq(0,60,12))
## This is a matrix with survival probabilities
## one column for each of the 5 time points
## one row for each validation set individual

</code></pre>

<hr>
<h2 id='predictSurvProb'>Predicting survival probabilities</h2><span id='topic+predictSurvProb'></span><span id='topic+predictSurvProb.aalen'></span><span id='topic+predictSurvProb.riskRegression'></span><span id='topic+predictSurvProb.cox.aalen'></span><span id='topic+predictSurvProb.coxph'></span><span id='topic+predictSurvProb.cph'></span><span id='topic+predictSurvProb.default'></span><span id='topic+predictSurvProb.rfsrc'></span><span id='topic+predictSurvProb.matrix'></span><span id='topic+predictSurvProb.pecCtree'></span><span id='topic+predictSurvProb.pecCforest'></span><span id='topic+predictSurvProb.prodlim'></span><span id='topic+predictSurvProb.psm'></span><span id='topic+predictSurvProb.selectCox'></span><span id='topic+predictSurvProb.survfit'></span><span id='topic+predictSurvProb.pecRpart'></span>

<h3>Description</h3>

<p>Function to extract survival probability predictions from various modeling
approaches. The most prominent one is the Cox regression model which can be
fitted for example with &lsquo;coxph&rsquo; and with &lsquo;cph&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'aalen'
predictSurvProb(object,newdata,times,...)
## S3 method for class 'riskRegression'
predictSurvProb(object,newdata,times,...)
## S3 method for class 'cox.aalen'
predictSurvProb(object,newdata,times,...)
## S3 method for class 'cph'
predictSurvProb(object,newdata,times,...)
## S3 method for class 'coxph'
predictSurvProb(object,newdata,times,...)
## S3 method for class 'matrix'
predictSurvProb(object,newdata,times,...)
## S3 method for class 'selectCox'
predictSurvProb(object,newdata,times,...)
## S3 method for class 'pecCforest'
predictSurvProb(object,newdata,times,...)
## S3 method for class 'prodlim'
predictSurvProb(object,newdata,times,...)
## S3 method for class 'psm'
predictSurvProb(object,newdata,times,...)
## S3 method for class 'survfit'
predictSurvProb(object,newdata,times,...)
## S3 method for class 'pecRpart'
predictSurvProb(object,newdata,times,...)
#' \method{predictSurvProb}{pecCtree}(object,newdata,times,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predictSurvProb_+3A_object">object</code></td>
<td>
<p>A fitted model from which to extract predicted survival
probabilities</p>
</td></tr>
<tr><td><code id="predictSurvProb_+3A_newdata">newdata</code></td>
<td>
<p>A data frame containing predictor variable combinations for
which to compute predicted survival probabilities.</p>
</td></tr>
<tr><td><code id="predictSurvProb_+3A_times">times</code></td>
<td>
<p>A vector of times in the range of the response variable, e.g.
times when the response is a survival object, at which to return the
survival probabilities.</p>
</td></tr>
<tr><td><code id="predictSurvProb_+3A_...">...</code></td>
<td>
<p>Additional arguments that are passed on to the current method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function predictSurvProb is a generic function that means it invokes
specifically designed functions depending on the 'class' of the first
argument.
</p>
<p>The function <code>pec</code> requires survival probabilities for each row in
newdata at requested times. These probabilities are extracted from a fitted
model of class <code>CLASS</code> with the function <code>predictSurvProb.CLASS</code>.
</p>
<p>Currently there are <code>predictSurvProb</code> methods for objects of class cph
(library rms), coxph (library survival), aalen (library timereg), cox.aalen
(library timereg), 
rpart (library rpart), product.limit (library prodlim),
survfit (library survival), psm (library rms)
</p>


<h3>Value</h3>

<p>A matrix with as many rows as <code>NROW(newdata)</code> and as many
columns as <code>length(times)</code>. Each entry should be a probability and in
rows the values should be decreasing.
</p>


<h3>Note</h3>

<p>In order to assess the predictive performance of a new survival model
a specific <code>predictSurvProb</code> S3 method has to be written. For examples,
see the bodies of the existing methods.
</p>
<p>The performance of the assessment procedure, in particular for resampling
where the model is repeatedly evaluated, will be improved by supressing in
the call to the model all the computations that are not needed for
probability prediction. For example, <code>se.fit=FALSE</code> can be set in the
call to <code>cph</code>.
</p>


<h3>Author(s)</h3>

<p>Thomas A. Gerds <a href="mailto:tag@biostat.ku.dk">tag@biostat.ku.dk</a>
</p>


<h3>References</h3>

<p>Ulla B. Mogensen, Hemant Ishwaran, Thomas A. Gerds (2012).
Evaluating Random Forests for Survival Analysis Using Prediction Error
Curves. Journal of Statistical Software, 50(11), 1-23. DOI
10.18637/jss.v050.i11
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+predict">predict</a></code>,<code><a href="survival.html#topic+survfit">survfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# generate some survival data
library(prodlim)
set.seed(100)
d &lt;- SimSurv(100)
# then fit a Cox model
library(survival)
library(rms)
coxmodel &lt;- cph(Surv(time,status)~X1+X2,data=d,surv=TRUE)

# Extract predicted survival probabilities 
# at selected time-points:
ttt &lt;- quantile(d$time)
# for selected predictor values:
ndat &lt;- data.frame(X1=c(0.25,0.25,-0.05,0.05),X2=c(0,1,0,1))
# as follows
predictSurvProb(coxmodel,newdata=ndat,times=ttt)

# stratified cox model
sfit &lt;- coxph(Surv(time,status)~strata(X1)+X2,data=d,,x=TRUE,y=TRUE)
predictSurvProb(sfit,newdata=d[1:3,],times=c(1,3,5,10))

## simulate some learning and some validation data
learndat &lt;- SimSurv(100)
valdat &lt;- SimSurv(100)
## use the learning data to fit a Cox model
library(survival)
fitCox &lt;- coxph(Surv(time,status)~X1+X2,data=learndat,x=TRUE,y=TRUE)
## suppose we want to predict the survival probabilities for all patients
## in the validation data at the following time points:
## 0, 12, 24, 36, 48, 60
psurv &lt;- predictSurvProb(fitCox,newdata=valdat,times=seq(0,60,12))
## This is a matrix with survival probabilities
## one column for each of the 5 time points
## one row for each validation set individual

## Cox with ridge option
f1 &lt;- coxph(Surv(time,status)~X1+X2,data=learndat,x=TRUE,y=TRUE)
f2 &lt;- coxph(Surv(time,status)~ridge(X1)+ridge(X2),data=learndat,x=TRUE,y=TRUE)
plot(predictSurvProb(f1,newdata=valdat,times=10),
     pec:::predictSurvProb.coxph(f2,newdata=valdat,times=10),
     xlim=c(0,1),
     ylim=c(0,1),
     xlab="Unpenalized predicted survival chance at 10",
     ylab="Ridge predicted survival chance at 10")


</code></pre>

<hr>
<h2 id='print.pec'>Printing a &lsquo;pec&rsquo; (prediction error curve) object.</h2><span id='topic+print.pec'></span><span id='topic+summary.pec'></span>

<h3>Description</h3>

<p>Print the important arguments of call and the prediction error values at
selected time points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pec'
print(x, times, digits = 3, what = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.pec_+3A_x">x</code></td>
<td>
<p>Object of class <code>pec</code></p>
</td></tr>
<tr><td><code id="print.pec_+3A_times">times</code></td>
<td>
<p>Time points at which to show the values of the prediction error
curve(s)</p>
</td></tr>
<tr><td><code id="print.pec_+3A_digits">digits</code></td>
<td>
<p>Number of decimals used in tables.</p>
</td></tr>
<tr><td><code id="print.pec_+3A_what">what</code></td>
<td>
<p>What estimate of the prediction error curve to show. Should be a
string matching an element of x. The default is determined by
splitMethod.</p>
</td></tr>
<tr><td><code id="print.pec_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
<tr><td><code id="print.pec_+3A_print">print</code></td>
<td>
<p>Set to FALSE to suppress printing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The first argument in the invisible cloak.
</p>


<h3>Author(s)</h3>

<p>Thomas A. Gerds <a href="mailto:tag@biostat.ku.dk">tag@biostat.ku.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pec">pec</a></code>
</p>

<hr>
<h2 id='R2'>Explained variation for survival models</h2><span id='topic+R2'></span>

<h3>Description</h3>

<p>This function computes a time-dependent $R^2$ like measure of the variation
explained by a survival prediction model, by dividing the mean squared error
(Brier score) of the model by the mean squared error (Brier score) of a
reference model which ignores all the covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R2(object, models, what, times, reference = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="R2_+3A_object">object</code></td>
<td>
<p>An object with estimated prediction error curves obtained with
the function <a href="#topic+pec">pec</a></p>
</td></tr>
<tr><td><code id="R2_+3A_models">models</code></td>
<td>
<p>For which of the models in <code>object$models</code> should we
compute $R^2(t). By default all models are used except for the reference
model.</p>
</td></tr>
<tr><td><code id="R2_+3A_what">what</code></td>
<td>
<p>The name of the entry in <code>x</code> to be used. Defauls to
<code>PredErr</code> Other choices are <code>AppErr</code>, <code>BootCvErr</code>,
<code>Boot632</code>, <code>Boot632plus</code>.</p>
</td></tr>
<tr><td><code id="R2_+3A_times">times</code></td>
<td>
<p>Time points at which the summaries are shown.</p>
</td></tr>
<tr><td><code id="R2_+3A_reference">reference</code></td>
<td>
<p>Position of the model whose prediction error is used as the
reference in the denominator when constructing $R^2$</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In survival analysis the prediction error of the Kaplan-Meier estimator
plays a similar role as the total sum of squares in linear regression.
Hence, it is a sensible reference model for $R^2$.
</p>


<h3>Value</h3>

<p>A matrix where the first column holds the times and the following
columns are the corresponding $R^2$ values for the requested prediction
models.
</p>


<h3>Author(s)</h3>

<p>Thomas A. Gerds <a href="mailto:tag@biostat.ku.dk">tag@biostat.ku.dk</a>
</p>


<h3>References</h3>

<p>E. Graf et al.  (1999), Assessment and comparison of prognostic
classification schemes for survival data. Statistics in Medicine, vol 18,
pp= 2529&ndash;2545.
</p>
<p>Gerds TA, Cai T and Schumacher M (2008) The performance of risk prediction
models Biometrical Journal, 50(4), 457&ndash;479
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pec">pec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(18713)
library(prodlim)
library(survival)
dat=SimSurv(100)
nullmodel=prodlim(Hist(time,status)~1,data=dat)
pmodel1=coxph(Surv(time,status)~X1+X2,data=dat,x=TRUE,y=TRUE)
pmodel2=coxph(Surv(time,status)~X2,data=dat,x=TRUE,y=TRUE)
perror=pec(list(Cox1=pmodel1,Cox2=pmodel2),Hist(time,status)~1,data=dat,reference=TRUE)
R2(perror,times=seq(0,1,.1),reference=1)

</code></pre>

<hr>
<h2 id='reclass'>Retrospective risk reclassification table</h2><span id='topic+reclass'></span>

<h3>Description</h3>

<p>Retrospective table of risks predicted by two different methods, models, algorithms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reclass(
  object,
  reference,
  formula,
  data,
  time,
  cause,
  cuts = seq(0, 100, 25),
  digits = 2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reclass_+3A_object">object</code></td>
<td>
<p>Either a 
list with two elements. Each element should either
be a vector with probabilities, or an object for which
<code>predictSurvProb</code> or <code>predictEventProb</code> can extract predicted risk based on data.</p>
</td></tr>
<tr><td><code id="reclass_+3A_reference">reference</code></td>
<td>
<p>Reference prediction model.</p>
</td></tr>
<tr><td><code id="reclass_+3A_formula">formula</code></td>
<td>
<p>A survival formula as obtained either with
<code>prodlim::Hist</code> or <code>survival::Surv</code> which defines the
response in the <code>data</code>.</p>
</td></tr>
<tr><td><code id="reclass_+3A_data">data</code></td>
<td>
<p>Used to extract the response from the data and passed
on to <code>predictEventProb</code> to extract predicted event
probabilities.</p>
</td></tr>
<tr><td><code id="reclass_+3A_time">time</code></td>
<td>
<p>Time interest for prediction.</p>
</td></tr>
<tr><td><code id="reclass_+3A_cause">cause</code></td>
<td>
<p>For competing risk models the cause of
interest. Defaults to all available causes.</p>
</td></tr>
<tr><td><code id="reclass_+3A_cuts">cuts</code></td>
<td>
<p>Risk quantiles to group risks.</p>
</td></tr>
<tr><td><code id="reclass_+3A_digits">digits</code></td>
<td>
<p>Number of digits to show for the predicted risks</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All risks are multiplied by 100 before
</p>


<h3>Value</h3>

<p>reclassification tables: overall table and one conditional table for each cause and for subjects event free at time interest.
</p>


<h3>Author(s)</h3>

<p>Thomas A. Gerds &lt;tag@biostat.ku.dk&gt;
</p>


<h3>See Also</h3>

<p>predictStatusProb
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(survival)
set.seed(40)
d &lt;- prodlim::SimSurv(400)
nd &lt;- prodlim::SimSurv(400)
Models &lt;- list("Cox.X2"=coxph(Surv(time,status)~X2,data=d,x=TRUE,y=TRUE),
               "Cox.X1.X2"=coxph(Surv(time,status)~X1+X2,data=d,x=TRUE,y=TRUE))
rc &lt;- reclass(Models,formula=Surv(time,status)~1,data=nd,time=5)
print(rc)
plot(rc)

set.seed(40)
library(riskRegression)
library(prodlim)
dcr &lt;- prodlim::SimCompRisk(400)
ndcr &lt;- prodlim::SimCompRisk(400)
crPred5 &lt;- list("X2"=predictEventProb(CSC(Hist(time,event)~X2,data=dcr),newdata=ndcr,times=5),
                "X1+X2"=predictEventProb(CSC(Hist(time,event)~X1+X2,data=dcr),newdata=ndcr,times=5))
rc &lt;- reclass(crPred5,Hist(time,event)~1,data=ndcr,time=3)
print(rc)

reclass(crPred5,Hist(time,event)~1,data=ndcr,time=5,cuts=100*c(0,0.05,0.1,0.2,1))

## End(Not run)
</code></pre>

<hr>
<h2 id='resolvesplitMethod'>Resolve the splitMethod for estimation of prediction performance</h2><span id='topic+resolvesplitMethod'></span>

<h3>Description</h3>

<p>The function computes a matrix of random indices obtained by drawing from
the row numbers of a data set either with or without replacement.  The
matrix can be used to repeatedly set up independent training and validation
sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resolvesplitMethod(splitMethod, B, N, M)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resolvesplitMethod_+3A_splitmethod">splitMethod</code></td>
<td>
<p>String that determines the splitMethod to use. Available
splitMethods are none/noPlan (no splitting), bootcv or outofbag (bootstrap
cross-validation), cvK (K-fold cross-validation, e.g. cv10 gives 10-fold),
boot632, boot632plus or boot632+, loocv (leave-one-out)</p>
</td></tr>
<tr><td><code id="resolvesplitMethod_+3A_b">B</code></td>
<td>
<p>The number of repetitions.</p>
</td></tr>
<tr><td><code id="resolvesplitMethod_+3A_n">N</code></td>
<td>
<p>The sample size</p>
</td></tr>
<tr><td><code id="resolvesplitMethod_+3A_m">M</code></td>
<td>
<p>For subsampling bootstrap the size of the subsample. Note M&lt;N.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components </p>
<table role = "presentation">
<tr><td><code>name</code></td>
<td>
<p>the official name
of the splitMethod</p>
</td></tr> <tr><td><code>internal.name</code></td>
<td>
<p>the internal name of the
splitMethod</p>
</td></tr> <tr><td><code>index</code></td>
<td>
<p>a matrix of indices with B columns and either N or
M rows, dependent on splitMethod</p>
</td></tr> <tr><td><code>B</code></td>
<td>
<p>the value of the argument B</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>the value of the argument N</p>
</td></tr> <tr><td><code>M</code></td>
<td>
<p>the value of the argument M</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Alexander Gerds <a href="mailto:tag@biostat.ku.dk">tag@biostat.ku.dk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # BootstrapCrossValidation: Sampling with replacement   
  resolvesplitMethod("BootCv",N=10,B=10)

  # 10-fold cross-validation: repeated 2 times
  resolvesplitMethod("cv10",N=10,B=2)

  # leave-one-out cross-validation
  resolvesplitMethod("loocv",N=10)

  resolvesplitMethod("bootcv632plus",N=10,B=2)
  
  
</code></pre>

<hr>
<h2 id='selectCox'>Backward variable selection in the Cox regression model</h2><span id='topic+selectCox'></span>

<h3>Description</h3>

<p>This is a wrapper function which first selects variables in the Cox
regression model using <code>fastbw</code> from the <code>rms</code> package and then
returns a fitted Cox regression model with the selected variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectCox(formula, data, rule = "aic")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="selectCox_+3A_formula">formula</code></td>
<td>
<p>A formula object with a <code>Surv</code> object on the left-hand
side and all the variables on the right-hand side.</p>
</td></tr>
<tr><td><code id="selectCox_+3A_data">data</code></td>
<td>
<p>Name of an data frame containing all needed variables.</p>
</td></tr>
<tr><td><code id="selectCox_+3A_rule">rule</code></td>
<td>
<p>The method for selecting variables. See <code><a href="rms.html#topic+fastbw">fastbw</a></code> for
details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function first calls <code>cph</code> then <code>fastbw</code> and finally
<code>cph</code> again.
</p>


<h3>References</h3>

<p>Ulla B. Mogensen, Hemant Ishwaran, Thomas A. Gerds (2012).
Evaluating Random Forests for Survival Analysis Using Prediction Error
Curves. Journal of Statistical Software, 50(11), 1-23. DOI
10.18637/jss.v050.i11
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(GBSG2)
library(survival)
f &lt;- selectCox(Surv(time,cens)~horTh+age+menostat+tsize+tgrade+pnodes+progrec+estrec ,
	       data=GBSG2)

</code></pre>

<hr>
<h2 id='simCost'>Simulate COST alike data</h2><span id='topic+simCost'></span>

<h3>Description</h3>

<p>Simulate data alike the data from the Copenhagen stroke study (COST)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simCost(N)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simCost_+3A_n">N</code></td>
<td>
<p>Sample size</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This uses functionality of the lava package.
</p>


<h3>Value</h3>

<p>Data frame
</p>


<h3>Author(s)</h3>

<p>Thomas Alexander Gerds
</p>

<hr>
<h2 id='Special'>Drawing bootstrapped cross-validation curves and the .632 or .632plus error
of models. The prediction error for an optional benchmark model can be added
together with bootstrapped cross-validation error and apparent errors.</h2><span id='topic+Special'></span>

<h3>Description</h3>

<p>This function is invoked and controlled by <code>plot.pec</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Special(
  x,
  y,
  addprederr,
  models,
  bench,
  benchcol,
  times,
  maxboot,
  bootcol,
  col,
  lty,
  lwd
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Special_+3A_x">x</code></td>
<td>
<p>an object of class 'pec' as returned by the <code>pec</code> function.</p>
</td></tr>
<tr><td><code id="Special_+3A_y">y</code></td>
<td>
<p>Prediction error values.</p>
</td></tr>
<tr><td><code id="Special_+3A_addprederr">addprederr</code></td>
<td>
<p>Additional prediction errors. The options are bootstrap
cross-validation errors or apparent errors.</p>
</td></tr>
<tr><td><code id="Special_+3A_models">models</code></td>
<td>
<p>One model also specified in <code>pec</code> for which the
<code>predErr</code> in <code>plot.pec</code> is to be drawn.</p>
</td></tr>
<tr><td><code id="Special_+3A_bench">bench</code></td>
<td>
<p>A benchmark model (also specified in <code>pec</code>) for which the
<code>predErr</code> in <code>plot.pec</code> is to be drawn.</p>
</td></tr>
<tr><td><code id="Special_+3A_benchcol">benchcol</code></td>
<td>
<p>Color of the benchmark curve.</p>
</td></tr>
<tr><td><code id="Special_+3A_times">times</code></td>
<td>
<p>Time points at which the curves must be plotted.</p>
</td></tr>
<tr><td><code id="Special_+3A_maxboot">maxboot</code></td>
<td>
<p>Maximum number of bootstrap curves to be added. Default is
all.</p>
</td></tr>
<tr><td><code id="Special_+3A_bootcol">bootcol</code></td>
<td>
<p>Color of the bootstrapped curves. Default is 'gray77'.</p>
</td></tr>
<tr><td><code id="Special_+3A_col">col</code></td>
<td>
<p>Color of the different error curves for <code>models</code>.</p>
</td></tr>
<tr><td><code id="Special_+3A_lty">lty</code></td>
<td>
<p>Line type of the different error curves for <code>models</code>.</p>
</td></tr>
<tr><td><code id="Special_+3A_lwd">lwd</code></td>
<td>
<p>Line width of the different error curves for <code>models</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function should not be called directly. The arguments can be specified
as <code>Special.arg</code> in the call to <code>plot.pec</code>.
</p>


<h3>Value</h3>

<p>Invisible object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.pec">plot.pec</a></code>
</p>

<hr>
<h2 id='threecity'>threecity data</h2><span id='topic+threecity'></span>

<h3>Description</h3>

<p>Extracted data from a french population based cohort (Three-City cohort). The dataset includes 
followup information on dementia outcome and predicted 5-year risks based on 
based on the subject specific information which includes age, gender,
education level and cognitive decline measured by a psychometric test
(Mini Mental State Examination). The prediction model from which the
predictions have been computed has been fitted on independent training
data from the Paquid cohort, another french population based cohort with similar design (see Reference Blanche et al. 2015 for details) .
</p>


<h3>Format</h3>

<p>A subsample consisting of 2000 observations on the following 3 variables.
</p>
 <dl>
<dt>pi</dt><dd><p>5-year absolute risk predictions of dementia.</p>
</dd>
<dt>status</dt><dd><p>0=censored, 1=dementia, 2=death dementia free</p>
</dd>
<dt>time</dt><dd><p>time to event (i.e., time to
either dementia, death dementia free or loss of follow-up)</p>
</dd></dl>



<h3>Source</h3>

<p>Web-appendix of Blanche et al. (2015).
</p>


<h3>References</h3>

<p>Blanche, P., Proust-Lima, C., Loubere, L., Berr, C., Dartigues, J. F., Jacqmin-Gadda, H. (2015).
Quantifying and comparing dynamic
predictive accuracy of joint models for longitudinal marker and
time-to-event in presence of censoring and competing risks. 
Biometrics, 71(1), 102-113.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(threecity)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
