<!DOCTYPE html><html lang="en"><head><title>Help for package IDetect</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {IDetect}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#IDetect'><p>IDetect: Multiple generalised change-point detection using the Isolate-Detect methodology</p></a></li>
<li><a href='#cplm_ic'><p>Multiple change-point detection in a continuous piecewise-linear signal</p>
via minimising an information criterion</a></li>
<li><a href='#cplm_th'><p>Multiple change-point detection in a continuous, piecewise-linear signal</p>
via thresholding</a></li>
<li><a href='#est_signal'><p>Estimate the signal</p></a></li>
<li><a href='#ht_ID_cplm'><p>Apply the Isolate-Detect methodology for multiple change-point detection in a</p>
continuous, piecewise-linear vector with non Gaussian noise</a></li>
<li><a href='#ht_ID_pcm'><p>Apply the Isolate-Detect methodology for multiple change-point detection in the</p>
mean of a vector with non Gaussian noise</a></li>
<li><a href='#ID'><p>Multiple change-point detection in piecewise-constant or continuous, piecewise-linear</p>
signals using the Isolate-Detect methodology</a></li>
<li><a href='#ID_cplm'><p>Multiple change-point detection for a continuous, piecewise-linear signal</p>
using the Isolate-Detect methodology</a></li>
<li><a href='#ID_pcm'><p>Multiple change-point detection in the mean of a vector using the</p>
Isolate-Detect methodology</a></li>
<li><a href='#normalise'><p>Transform the noise to be closer to the Gaussian distribution</p></a></li>
<li><a href='#pcm_ic'><p>Multiple change-point detection in the mean via minimising an information</p>
criterion</a></li>
<li><a href='#pcm_th'><p>Multiple change-point detection in the mean via thresholding</p></a></li>
<li><a href='#resid_ID'><p>Calculate the residuals related to the estimated signal</p></a></li>
<li><a href='#s_e_points'><p>Derives a subset of integers from a given set</p></a></li>
<li><a href='#sol_path_cplm'><p>The solution path for the case of continuous piecewise-linear signals</p></a></li>
<li><a href='#sol_path_pcm'><p>The solution path for the case of piecewise-constant signals</p></a></li>
<li><a href='#win_cplm_th'><p>A windows-based approach for multiple change-point detection in a continuous,</p>
piecewise-linear signal via thresholding</a></li>
<li><a href='#win_pcm_th'><p>A windows-based approach for multiple change-point detection in the mean via</p>
thresholding</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Isolate-Detect Methodology for Multiple Change-Point Detection</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>splines</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides efficient implementation of the Isolate-Detect
    methodology for the consistent estimation of the number and location of multiple 
    change-points in one-dimensional data sequences from the "deterministic 
    + noise" model. For details on the Isolate-Detect methodology, please see Anastasiou and
    Fryzlewicz (2018) <a href="https://docs.wixstatic.com/ugd/24cdcc_6a0866c574654163b8255e272bc0001b.pdf">https://docs.wixstatic.com/ugd/24cdcc_6a0866c574654163b8255e272bc0001b.pdf</a>.
    Currently implemented scenarios are: piecewise-constant signal with Gaussian
    noise, piecewise-constant signal with heavy-tailed noise, continuous piecewise-linear 
    signal with Gaussian noise, continuous piecewise-linear signal with heavy-tailed noise.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-03-07 14:50:13 UTC; ANASTAS7</td>
</tr>
<tr>
<td>Author:</td>
<td>Andreas Anastasiou [aut, cre],
  Piotr Fryzlewicz [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andreas Anastasiou &lt;a.anastasiou@lse.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-03-09 10:02:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='IDetect'>IDetect: Multiple generalised change-point detection using the Isolate-Detect methodology</h2><span id='topic+IDetect'></span><span id='topic+IDetect-package'></span>

<h3>Description</h3>

<p>The <code>IDetect</code> package implements the Isolate-Detect methodology for
multiple generalised change-point detection, or sequence segmentation, in one-dimensional data
following the &ldquo;deterministic signal + noise&rdquo; model. The different structures that
are implemented are: piecewise-constant signal with Gaussian noise, piecewise-constant signal with
heavy tailed noise, piecewise-linear and continuous signal with Gaussian noise,
and piecewise-linear and continuous signal with heavy-tailed noise. The main routine
of the package is <code><a href="#topic+ID">ID</a></code>.
</p>


<h3>Author(s)</h3>

<p>Andreas Anastasiou, <a href="mailto:a.anastasiou@lse.ac.uk">a.anastasiou@lse.ac.uk</a>, Piotr Fryzlewicz, <a href="mailto:p.fryzlewicz@lse.ac.uk">p.fryzlewicz@lse.ac.uk</a>
</p>


<h3>References</h3>

<p>&ldquo;Detecting multiple generalized change-points by isolating single ones&rdquo;, Anastasiou
and Fryzlewicz (2018), preprint.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ID">ID</a></code>, <code><a href="#topic+ID_pcm">ID_pcm</a></code>, <code><a href="#topic+ID_cplm">ID_cplm</a></code>, <code><a href="#topic+ht_ID_pcm">ht_ID_pcm</a></code>,
and <code><a href="#topic+ht_ID_cplm">ht_ID_cplm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#See Examples for ID.
</code></pre>

<hr>
<h2 id='cplm_ic'>Multiple change-point detection in a continuous piecewise-linear signal
via minimising an information criterion</h2><span id='topic+cplm_ic'></span>

<h3>Description</h3>

<p>This function performs the Isolate-Detect methodology based on an information
criterion approach, in order to detect multiple change-points in a noisy, continuous,
piecewise-linear data sequence, with the noise being Gaussian. More information on
how this approach works as well as the relevant literature reference are given in Details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cplm_ic(x, th_const = 1.25, Kmax = 200, penalty = c("ssic_pen",
  "sic_pen"), points = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cplm_ic_+3A_x">x</code></td>
<td>
<p>A numeric vector containing the data in which you would like to find
change-points.</p>
</td></tr>
<tr><td><code id="cplm_ic_+3A_th_const">th_const</code></td>
<td>
<p>A positive real number with default value equal to 1.25. It is
used to define the threshold value that will be used at the first step of the
model selection based Isolate-Detect method; see Details for more information.</p>
</td></tr>
<tr><td><code id="cplm_ic_+3A_kmax">Kmax</code></td>
<td>
<p>A positive integer with default value equal to 200. It is the
maximum allowed number of estimated change-points in the solution path; see
<code><a href="#topic+sol_path_cplm">sol_path_cplm</a></code> for more details.</p>
</td></tr>
<tr><td><code id="cplm_ic_+3A_penalty">penalty</code></td>
<td>
<p>A character vector with names of penalty functions used.</p>
</td></tr>
<tr><td><code id="cplm_ic_+3A_points">points</code></td>
<td>
<p>A positive integer with default value equal to 10. It defines
the distance between two consecutive end- or start-points of the right- or
left-expanding intervals, respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The approach followed in <code><a href="#topic+cplm_ic">cplm_ic</a></code> in order to detect the
change-points is based on identifying the set of change-points that minimise an
information criterion. At first, we employ <code><a href="#topic+sol_path_cplm">sol_path_cplm</a></code>, which
overestimates the number of change-points using <code>th_const</code> in order to define the
threshold and then sorts the obtained estimates in a way that the estimate,
which is most likely to be correct appears first, whereas the least likely
to be correct, appears last. Let <code class="reqn">J</code> be the number of estimates
that this overestimation approach returns. We will obtain a vector
<code class="reqn">b = (b_1, b_2, ..., b_J)</code>, with the estimates ordered as explained above. We
define the collection <code class="reqn">\left\{M_j\right\}_{j = 0,1,\ldots,J}</code>, where <code class="reqn">M_0</code>
is the empty set and <code class="reqn">M_j = \left\{b_1,b_2,...,b_j\right\}</code>. Among the collection
of models <code class="reqn">M_j, j=0,1,...,J</code>, we select the one that minimises a predefined
Information Criterion. The obtained set of change-points is apparently a subset of
the solution path given in <code><a href="#topic+sol_path_cplm">sol_path_cplm</a></code>. More details can be found
in &ldquo;Detecting multiple generalized change-points by isolating single ones&rdquo;,
Anastasiou and Fryzlewicz (2018), preprint.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>

<table>
<tr>
 <td style="text-align: left;">
   </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>sol_path</code> </td><td style="text-align: left;"> A vector containing the solution path.
   </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>ic_curve</code> </td><td style="text-align: left;"> A list with values of the chosen information criteria.
   </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>cpt_ic</code> </td><td style="text-align: left;"> A list with the change-points detected for each information
  criterion considered.
   </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>no_cpt_ic</code> </td><td style="text-align: left;"> The number of change-points detected for each information
  criterion considered.
   </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Andreas Anastasiou, <a href="mailto:a.anastasiou@lse.ac.uk">a.anastasiou@lse.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ID_cplm">ID_cplm</a></code> and <code><a href="#topic+ID">ID</a></code>, which employ this function.
In addition, see <code><a href="#topic+pcm_ic">pcm_ic</a></code> for the case of detecting changes in
a piecewise-constant signal using the information criterion based approach.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>single.cpt &lt;- c(seq(0, 999, 1), seq(998.5, 499, -0.5))
single.cpt.noise &lt;- single.cpt + rnorm(2000)
cpt.single.ic &lt;- cplm_ic(single.cpt.noise)

three.cpt &lt;- c(seq(0, 499, 1), seq(498.5, 249, -0.5), seq(250,1249,2), seq(1248,749,-1))
three.cpt.noise &lt;- three.cpt + rnorm(2000)
cpt.three.ic &lt;- cplm_ic(three.cpt.noise)
</code></pre>

<hr>
<h2 id='cplm_th'>Multiple change-point detection in a continuous, piecewise-linear signal
via thresholding</h2><span id='topic+cplm_th'></span>

<h3>Description</h3>

<p>This function performs the Isolate-Detect methodology with the thresholding-based
stopping rule in order to detect multiple change-points in a continuous, piecewise-linear
noisy data sequence, with noise that is Gaussian. See Details for a brief explanation of the
Isolate-Detect methodology (with the relevant reference) and of the thresholding-based
stopping rule.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cplm_th(x, sigma = stats::mad(diff(diff(x)))/sqrt(6), thr_const = 1.4,
  thr_fin = sigma * thr_const * sqrt(2 * log(length(x))), s = 1,
  e = length(x), points = 3, k_l = 1, k_r = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cplm_th_+3A_x">x</code></td>
<td>
<p>A numeric vector containing the data in which you would like to find
change-points.</p>
</td></tr>
<tr><td><code id="cplm_th_+3A_sigma">sigma</code></td>
<td>
<p>A positive real number. It is the estimate of the standard deviation
of the noise in <code>x</code>. The default value is <code>mad(diff(diff(x)))/sqrt(6)</code>, where
<code>mad(x)</code> denotes the median absolute deviation of <code>x</code> computed under the
assumption that the noise is independent and identically distributed from the
Gaussian distribution.</p>
</td></tr>
<tr><td><code id="cplm_th_+3A_thr_const">thr_const</code></td>
<td>
<p>A positive real number with default value equal to 1.4. It is
used to define the threshold; see <code>thr_fin</code>.</p>
</td></tr>
<tr><td><code id="cplm_th_+3A_thr_fin">thr_fin</code></td>
<td>
<p>With <code>T</code> the length of the data sequence, this is a positive real number
with default value equal to <code>sigma * thr_const * sqrt(2 * log(T))</code>. It is the threshold,
which is used in the detection process.</p>
</td></tr>
<tr><td><code id="cplm_th_+3A_s">s</code>, <code id="cplm_th_+3A_e">e</code></td>
<td>
<p>Positive integers with <code>s</code> less than <code>e</code>, which indicate
that you want to check for change-points in the data sequence with subscripts
in <code>[s,e]</code>. The default values are <code>s</code> equal to 1 and
<code>e</code> equal to <code>T</code>, with <code>T</code> the length of the data sequence.</p>
</td></tr>
<tr><td><code id="cplm_th_+3A_points">points</code></td>
<td>
<p>A positive integer with default value equal to 3. It defines
the distance between two consecutive end- or start-points of the right- or
left-expanding intervals, respectively; see Details for more information.</p>
</td></tr>
<tr><td><code id="cplm_th_+3A_k_l">k_l</code>, <code id="cplm_th_+3A_k_r">k_r</code></td>
<td>
<p>Positive integer numbers that get updated whenever the function
calls itself during the detection process. They are not essential for the
function to work, and we include them only to reduce the computational time.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The change-point detection algorithm that is used in <code><a href="#topic+cplm_th">cplm_th</a></code> is the
Isolate-Detect methodology described in &ldquo;Detecting multiple generalized
change-points by isolating single ones&rdquo;, Anastasiou and Fryzlewicz (2018), preprint.
The concept is simple and is split into two stages; firstly, isolation of each
of the true change-points in subintervals of the data domain, and secondly their detection.
ID first creates two ordered sets of <code class="reqn">K = \lceil T/\code{points}\rceil</code> right- and left-expanding
intervals as follows. The <code class="reqn">j^{th}</code> right-expanding interval is <code class="reqn">R_j = [1, j\times \code{points}]</code>,
while the <code class="reqn">j^{th}</code> left-expanding interval is <code class="reqn">L_j = [T - j\times \code{points} + 1, T]</code>.
We collect these intervals in the ordered set <code class="reqn">S_{RL} = \lbrace R_1, L_1, R_2, L_2, ... , R_K, L_K\rbrace</code>.
For a suitably chosen contrast function, ID first identifies the point with the maximum contrast
value in <code class="reqn">R_1</code>. If its value exceeds a certain threshold, then it is taken as a change-point.
If not, then the process tests the next interval in <code class="reqn">S_{RL}</code> and repeats the above process.
Upon detection, the algorithm makes a new start from estimated location.
</p>


<h3>Value</h3>

<p>A numeric vector with the detected change-points.
</p>


<h3>Author(s)</h3>

<p>Andreas Anastasiou, <a href="mailto:a.anastasiou@lse.ac.uk">a.anastasiou@lse.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+win_cplm_th">win_cplm_th</a></code>, <code><a href="#topic+ID_cplm">ID_cplm</a></code>, and <code><a href="#topic+ID">ID</a></code>, which employ
this function. In addition, see <code><a href="#topic+pcm_th">pcm_th</a></code> for the case of detecting changes in
a piecewise-constant signal via thresholding.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>single.cpt &lt;- c(seq(0, 999, 1), seq(998.5, 499, -0.5))
single.cpt.noise &lt;- single.cpt + rnorm(2000)
cpt.single.th &lt;- cplm_th(single.cpt.noise)

three.cpt &lt;- c(seq(0, 499, 1), seq(498.5, 249, -0.5), seq(251,1249,2), seq(1248,749,-1))
three.cpt.noise &lt;- three.cpt + rnorm(2000)
cpt.three.th &lt;- cplm_th(three.cpt.noise)

multi.cpt &lt;- rep(c(seq(0,49,1), seq(48,0,-1)),20)
multi.cpt.noise &lt;- multi.cpt + rnorm(1980)
cpt.multi.th &lt;- cplm_th(multi.cpt.noise)
</code></pre>

<hr>
<h2 id='est_signal'>Estimate the signal</h2><span id='topic+est_signal'></span>

<h3>Description</h3>

<p>This function estimates the signal in a given data sequence <code>x</code> with change-points
at <code>cpt</code>. The type of the signal depends on whether the change-points represent changes
in a piecewise-constant or continuous, piecewise-linear signal. For more information see
Details below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_signal(x, cpt, type = c("mean", "slope"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="est_signal_+3A_x">x</code></td>
<td>
<p>A numeric vector containing the given data.</p>
</td></tr>
<tr><td><code id="est_signal_+3A_cpt">cpt</code></td>
<td>
<p>A positive integer vector with the locations of the change-points.
If missing, the <code><a href="#topic+ID_pcm">ID_pcm</a></code> or the <code><a href="#topic+ID_cplm">ID_cplm</a></code> function
(depending on the type of the signal) is called internally to extract the
change-points in <code>x</code>.</p>
</td></tr>
<tr><td><code id="est_signal_+3A_type">type</code></td>
<td>
<p>A character string, which defines the type of the detected change-points.
If <code>type = ``mean''</code>, then the change-points represent the locations of changes
in the mean of a piecewise-constant signal. If <code>type = ``slope''</code>, then the
change-points represent the locations of changes in the slope of a continuous, piecewise-linear
signal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data points provided in <code>x</code> are assumed to follow </p>
<p style="text-align: center;"><code class="reqn">X_t = f_t + \sigma\epsilon_t; t = 1,2,...,T,</code>
</p>

<p>where <code class="reqn">T</code> is the total length of the data sequence, <code class="reqn">X_t</code> are the observed
data, <code class="reqn">f_t</code> is a one-dimensional, deterministic signal with abrupt structural
changes at certain points, and <code class="reqn">\epsilon_t</code> is white noise. We denote by
<code class="reqn">r_1, r_2, ..., r_N</code> the elements in <code>cpt</code> and by <code class="reqn">r_0 = 0</code> and
<code class="reqn">r_{N+1} = T</code>. Depending on the value that has been passed to <code>type</code>, the returned
value is calculated as follows.
</p>

<ul>
<li> <p>For <code>type = ``mean''</code>, in each segment <code class="reqn">(r_j + 1, r_{j+1})</code>, <code class="reqn">f_t</code> for
<code class="reqn">t \in (r_j + 1, r_{j+1})</code> is approximated by the mean of <code class="reqn">X_t</code> calculated
over <code class="reqn">t \in (r_j + 1, r_{j+1})</code>.
</p>
</li>
<li> <p>For <code>type = ``slope''</code>, <code class="reqn">f_t</code> is approximated by the linear spline fit with
knots at <code class="reqn">r_1, r_2, ..., r_N</code> minimising the <code class="reqn">l_2</code> distance between the fit and the data.
</p>
</li></ul>



<h3>Value</h3>

<p>A numeric vector with the estimated signal.
</p>


<h3>Author(s)</h3>

<p>Andreas Anastasiou, <a href="mailto:a.anastasiou@lse.ac.uk">a.anastasiou@lse.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>single.cpt.pcm &lt;- c(rep(4,1000),rep(0,1000))
single.cpt.pcm.noise &lt;- single.cpt.pcm + rnorm(2000)
cpt.single.pcm &lt;- ID_pcm(single.cpt.pcm.noise)
fit.cpt.single.pcm &lt;- est_signal(single.cpt.pcm.noise, cpt.single.pcm$cpt, type = "mean")

three.cpt.pcm &lt;- c(rep(4,500),rep(0,500),rep(-4,500),rep(1,500))
three.cpt.pcm.noise &lt;- three.cpt.pcm + rnorm(2000)
cpt.three.pcm &lt;- ID_pcm(three.cpt.pcm.noise)
fit.cpt.three.pcm &lt;- est_signal(three.cpt.pcm.noise, cpt.three.pcm$pcm, type = "mean")

single.cpt.plm &lt;- c(seq(0,999,1),seq(998.5,499,-0.5))
single.cpt.plm.noise &lt;- single.cpt.plm + rnorm(2000)
cpt.single.plm &lt;- ID_cplm(single.cpt.plm.noise)
fit.cpt.single.plm &lt;- est_signal(single.cpt.plm.noise, cpt.single.plm$cpt, type = "slope")
</code></pre>

<hr>
<h2 id='ht_ID_cplm'>Apply the Isolate-Detect methodology for multiple change-point detection in a
continuous, piecewise-linear vector with non Gaussian noise</h2><span id='topic+ht_ID_cplm'></span>

<h3>Description</h3>

<p>Using the Isolate-Detect methodology, this function estimates the number and locations
of multiple change-points in the noisy, continuous, piecewise-linear input vector <code>x</code>,
with noise that is not normally distributed. It also gives the estimated signal, as well as
the solution path defined in <code><a href="#topic+sol_path_cplm">sol_path_cplm</a></code> (see Details for the relevant
literature reference).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ht_ID_cplm(x, s.ht = 3, q_ht = 300, ht_thr_id = 1.4, ht_th_ic_id = 1.25,
  p_thr = 1, p_ic = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ht_ID_cplm_+3A_x">x</code></td>
<td>
<p>A numeric vector containing the data in which you would like to find
change-points.</p>
</td></tr>
<tr><td><code id="ht_ID_cplm_+3A_s.ht">s.ht</code></td>
<td>
<p>A positive integer number with default value equal to 3. It is
used to define the way we pre-average the given data sequence. For more information
see Details.</p>
</td></tr>
<tr><td><code id="ht_ID_cplm_+3A_q_ht">q_ht</code></td>
<td>
<p>A positive integer number with default value equal to 300. If the
length of <code>x</code> is less than or equal to <code>q_ht</code>, then no pre-averaging
will take place.</p>
</td></tr>
<tr><td><code id="ht_ID_cplm_+3A_ht_thr_id">ht_thr_id</code></td>
<td>
<p>A positive real number with default value equal to 1.4. It is
used to define the threshold, if the thresholding approach (described in <code><a href="#topic+cplm_th">cplm_th</a></code>)
is to be followed.</p>
</td></tr>
<tr><td><code id="ht_ID_cplm_+3A_ht_th_ic_id">ht_th_ic_id</code></td>
<td>
<p>A positive real number with default value equal to 1.25. It is
useful only if the model selection based Isolate-Detect method is to be followed
and it is used to define the threshold value that will be used at the first step
(change-point overestimation) of the model selection approach described in
<code><a href="#topic+cplm_ic">cplm_ic</a></code>. It is applied to the new data, which are obtained
after we take average values on <code>x</code>.</p>
</td></tr>
<tr><td><code id="ht_ID_cplm_+3A_p_thr">p_thr</code></td>
<td>
<p>A positive integer with default value equal to 1. It is used only
when the threshold based approach (described in <code><a href="#topic+cplm_th">cplm_th</a></code>) is to
be followed and it defines the distance between two consecutive end- or start-points
of the right- or left-expanding intervals, respectively.</p>
</td></tr>
<tr><td><code id="ht_ID_cplm_+3A_p_ic">p_ic</code></td>
<td>
<p>A positive integer with default value equal to 3. It is used only
when the information criterion based approach (described in <code><a href="#topic+cplm_ic">cplm_ic</a></code>) is
to be followed and it defines the distance between two consecutive end- or start-points
of the right- or left-expanding intervals, respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Firstly, in this function we call <code><a href="#topic+normalise">normalise</a></code>, in order to
create a new data sequence, <code class="reqn">\tilde{x}</code>, by taking averages of observations in
<code>x</code>. Then, we employ <code><a href="#topic+ID_cplm">ID_cplm</a></code> on <code class="reqn">\tilde{x}_q</code> to obtain the
change-points, namely <code class="reqn">\tilde{r}_1, \tilde{r}_2, ..., \tilde{r}_{\hat{N}}</code> in
increasing order. To obtain the original location of the change-points with,
on average, the highest accuracy we define
</p>
<p style="text-align: center;"><code class="reqn">\hat{r}_k = (\tilde{r}_{k}-1)*\code{s.ht} + \lfloor \code{s.ht}/2 + 0.5 \rfloor, k=1, 2,..., \hat{N}.</code>
</p>

<p>More details can be found in &ldquo;Detecting multiple generalized change-points by
isolating single ones&rdquo;, Anastasiou and Fryzlewicz (2018), preprint.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>

<table>
<tr>
 <td style="text-align: left;">
   </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>cpt</code> </td><td style="text-align: left;"> A vector with the detected change-points.
   </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>no_cpt</code> </td><td style="text-align: left;"> The number of change-points detected.
   </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>fit</code> </td><td style="text-align: left;"> A numeric vector with the estimated continuous piecewise-linear signal.
   </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>solution_path</code> </td><td style="text-align: left;"> A vector containing the solution path.
 </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Andreas Anastasiou, <a href="mailto:a.anastasiou@lse.ac.uk">a.anastasiou@lse.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ID_cplm">ID_cplm</a></code> and <code><a href="#topic+normalise">normalise</a></code>, which are functions that are
used in <code><a href="#topic+ht_ID_cplm">ht_ID_cplm</a></code>. In addition, see <code><a href="#topic+ht_ID_pcm">ht_ID_pcm</a></code> for the case
of piecewise-constant mean signals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>single.cpt &lt;- c(seq(0, 1999, 1), seq(1998, -1, -1))
single.cpt.student &lt;- single.cpt + rt(4000, df = 5)
cpt.single &lt;- ht_ID_cplm(single.cpt.student)

three.cpt &lt;- c(seq(0, 3998, 2), seq(3996, -2, -2), seq(0,3998,2), seq(3996,-2,-2))
three.cpt.student &lt;- three.cpt + rt(8000, df = 5)
cpt.three &lt;- ht_ID_cplm(three.cpt.student)
</code></pre>

<hr>
<h2 id='ht_ID_pcm'>Apply the Isolate-Detect methodology for multiple change-point detection in the
mean of a vector with non Gaussian noise</h2><span id='topic+ht_ID_pcm'></span>

<h3>Description</h3>

<p>Using the Isolate-Detect methodology, this function estimates the number and locations
of multiple change-points in the mean of the noisy, piecewise-constant input vector <code>x</code>,
with noise that is not normally distributed. It also gives the estimated signal, as well as
the solution path defined in <code><a href="#topic+sol_path_pcm">sol_path_pcm</a></code>. See Details for the relevant literature reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ht_ID_pcm(x, s.ht = 3, q_ht = 300, ht_thr_id = 1, ht_th_ic_id = 0.9,
  p_thr = 1, p_ic = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ht_ID_pcm_+3A_x">x</code></td>
<td>
<p>A numeric vector containing the data in which you would like to find
change-points.</p>
</td></tr>
<tr><td><code id="ht_ID_pcm_+3A_s.ht">s.ht</code></td>
<td>
<p>A positive integer number with default value equal to 3. It is
used to define the way we pre-average the given data sequence (see Details).</p>
</td></tr>
<tr><td><code id="ht_ID_pcm_+3A_q_ht">q_ht</code></td>
<td>
<p>A positive integer number with default value equal to 300. If the
length of <code>x</code> is less than or equal to <code>q_ht</code>, then no pre-averaging
will take place.</p>
</td></tr>
<tr><td><code id="ht_ID_pcm_+3A_ht_thr_id">ht_thr_id</code></td>
<td>
<p>A positive real number with default value equal to 1. It is
used to define the threshold, if the thresholding approach is to be followed; see
<code><a href="#topic+pcm_th">pcm_th</a></code> for more details on the thresholding approach.</p>
</td></tr>
<tr><td><code id="ht_ID_pcm_+3A_ht_th_ic_id">ht_th_ic_id</code></td>
<td>
<p>A positive real number with default value equal to 0.9. It is
useful only if the model selection based Isolate-Detect method is to be followed
and it is used to define the threshold value that will be used at the first step
(change-point overestimation) of the model selection approach described in
<code><a href="#topic+pcm_ic">pcm_ic</a></code>. It is applied to the new data, which are obtained after
we pre-average <code>x</code>.</p>
</td></tr>
<tr><td><code id="ht_ID_pcm_+3A_p_thr">p_thr</code></td>
<td>
<p>A positive integer with default value equal to 1. It is used only
when the threshold based approach (as described in <code><a href="#topic+pcm_th">pcm_th</a></code>) is to be followed
and it defines the distance between two consecutive end- or start-points of the right- or
left-expanding intervals, respectively.</p>
</td></tr>
<tr><td><code id="ht_ID_pcm_+3A_p_ic">p_ic</code></td>
<td>
<p>A positive integer with default value equal to 3. It is used only
when the information criterion based approach (described in <code><a href="#topic+pcm_ic">pcm_ic</a></code>)
is to be followed and it defines the distance between two consecutive end- or start-points
of the right- or left-expanding intervals, respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Firstly, in this function we call <code><a href="#topic+normalise">normalise</a></code>, in order to
create a new data sequence, <code class="reqn">\tilde{x}</code>, by taking averages of observations in
<code>x</code>. Then, we employ <code><a href="#topic+ID_pcm">ID_pcm</a></code> on <code class="reqn">\tilde{x}_q</code> to obtain the
change-points, namely <code class="reqn">\tilde{r}_1, \tilde{r}_2, ..., \tilde{r}_{\hat{N}}</code> in
increasing order. To obtain the original location of the change-points with,
on average, the highest accuracy we define
<code class="reqn">\hat{r}_k = (\tilde{r}_{k}-1)*\code{s.ht} + \lfloor \code{s.ht}/2 + 0.5 \rfloor, k=1, 2,..., \hat{N}.</code>
More details can be found in &ldquo;Detecting multiple generalized change-points by
isolating single ones&rdquo;, Anastasiou and Fryzlewicz (2018), preprint.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>

<table>
<tr>
 <td style="text-align: left;">
   </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>cpt</code> </td><td style="text-align: left;"> A vector with the detected change-points.
   </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>no_cpt</code> </td><td style="text-align: left;"> The number of change-points detected.
   </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>fit</code> </td><td style="text-align: left;"> A numeric vector with the estimated piecewise-constant signal.
   </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>solution_path</code> </td><td style="text-align: left;"> A vector containing the solution path.
 </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Andreas Anastasiou, <a href="mailto:a.anastasiou@lse.ac.uk">a.anastasiou@lse.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ID_pcm">ID_pcm</a></code> and <code><a href="#topic+normalise">normalise</a></code>, which are functions that are
used in <code><a href="#topic+ht_ID_pcm">ht_ID_pcm</a></code>. In addition, see <code><a href="#topic+ht_ID_cplm">ht_ID_cplm</a></code> for the case
of continuous and piecewise-linear signals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>single.cpt &lt;- c(rep(4,3000),rep(0,3000))
single.cpt.student &lt;- single.cpt + rt(6000, df = 5)
cpts_detect &lt;- ht_ID_pcm(single.cpt.student)

three.cpt &lt;- c(rep(4,2000),rep(0,2000),rep(-4,2000),rep(0,2000))
three.cpt.student &lt;- three.cpt + rt(8000, df = 5)
cpts_detect_three &lt;- ht_ID_pcm(three.cpt.student)
</code></pre>

<hr>
<h2 id='ID'>Multiple change-point detection in piecewise-constant or continuous, piecewise-linear
signals using the Isolate-Detect methodology</h2><span id='topic+ID'></span>

<h3>Description</h3>

<p>This is the main, general function of the package. It employs more specialised functions in
order to estimate the number and locations of multiple change-points in the noisy, piecewise-constant
or continuous, piecewise-linear input vector <code>xd</code>. The noise can either follow the Gaussian
distribution or not. The approach that is followed is a hybrid between the thresholding approach
(explained in <code><a href="#topic+pcm_th">pcm_th</a></code> and <code><a href="#topic+cplm_th">cplm_th</a></code>) and the information criterion approach
(explained in <code><a href="#topic+pcm_ic">pcm_ic</a></code> and <code><a href="#topic+cplm_ic">cplm_ic</a></code>) and estimates the change-points
taking into account both these approaches. Further to the number and the location of the estimated
change-points, <code><a href="#topic+ID">ID</a></code>, returns the estimated signal, as well as the solution path.
For more information and the relevant literature reference, see Details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ID(xd, th.cons = 1, th.cons_lin = 1.4, th.ic = 0.9, th.ic.lin = 1.25,
  lambda = 3, lambda.ic = 10, contrast = c("mean", "slope"), ht = FALSE,
  scale = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ID_+3A_xd">xd</code></td>
<td>
<p>A numeric vector containing the data in which you would like to find
change-points.</p>
</td></tr>
<tr><td><code id="ID_+3A_th.cons">th.cons</code></td>
<td>
<p>A positive real number with default value equal to 1. It is
used to define the threshold, if the thresholding approach (explained in <code><a href="#topic+pcm_th">pcm_th</a></code>)
is to be followed to detect the change-points in the scenario of piecewise-constant signals.</p>
</td></tr>
<tr><td><code id="ID_+3A_th.cons_lin">th.cons_lin</code></td>
<td>
<p>A positive real number with default value equal to 1.4. It is
used to define the threshold, if the thresholding approach (explained in <code><a href="#topic+cplm_th">cplm_th</a></code>)
is to be followed to detect the change-points in the scenario of continuous, piecewise-linear signals.</p>
</td></tr>
<tr><td><code id="ID_+3A_th.ic">th.ic</code></td>
<td>
<p>A positive real number with default value equal to 0.9. It is
useful only if the model selection based Isolate-Detect method (described in
<code><a href="#topic+pcm_ic">pcm_ic</a></code>) is to be followed for the scenario of piecewise-constant signals.
It is used to define the threshold value that will be used at the first step (change-point
overestimation) of the model selection approach.</p>
</td></tr>
<tr><td><code id="ID_+3A_th.ic.lin">th.ic.lin</code></td>
<td>
<p>A positive real number with default value equal to 1.25. It is
useful only if the model selection based Isolate-Detect method (described in
<code><a href="#topic+cplm_ic">cplm_ic</a></code>) is to be followed for the scenario of continuous, piecewise-linear signals.
It is used to define the threshold value that will be used at the first step (change-point
overestimation) of the model selection approach.</p>
</td></tr>
<tr><td><code id="ID_+3A_lambda">lambda</code></td>
<td>
<p>A positive integer with default value equal to 3. It is used only
when the threshold based approach is to be followed and it defines the distance
between two consecutive end- or start-points of the right- or left-expanding intervals,
respectively.</p>
</td></tr>
<tr><td><code id="ID_+3A_lambda.ic">lambda.ic</code></td>
<td>
<p>A positive integer with default value equal to 10. It is used only
when the information criterion based approach is to be followed and it defines
the distance between two consecutive end- or start-points of the right- or
left-expanding intervals, respectively.</p>
</td></tr>
<tr><td><code id="ID_+3A_contrast">contrast</code></td>
<td>
<p>A character string, which defines the type of the contrast function to
be used in the Isolate-Detect algorithm. If <code>contrast = ``mean''</code>, then the algorithm
looks for changes in a piecewise-constant signal. If <code>contrast = ``slope''</code>,
then the algorithm looks for changes in a continuous, piecewise-linear signal.</p>
</td></tr>
<tr><td><code id="ID_+3A_ht">ht</code></td>
<td>
<p>A logical variable with default value equal to <code>FALSE</code>. If <code>FALSE</code>,
the noise is assumed to follow the Gaussian distribution. If <code>TRUE</code>, then the
noise is assumed to follow a distribution that has tails heavier than those of the
Gaussian distribution.</p>
</td></tr>
<tr><td><code id="ID_+3A_scale">scale</code></td>
<td>
<p>A positive integer number with default value equal to 3. It is
used to define the way we pre-average the given data sequence only if
<code>ht = TRUE</code>. See the Details in <code><a href="#topic+ht_ID_pcm">ht_ID_pcm</a></code> for more information on
how we pre-average.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data points provided in <code>xd</code> are assumed to follow </p>
<p style="text-align: center;"><code class="reqn">X_t = f_t + \sigma\epsilon_t; t = 1,2,...,T,</code>
</p>

<p>where <code class="reqn">T</code> is the total length of the data sequence, <code class="reqn">X_t</code> are the observed
data, <code class="reqn">f_t</code> is a one-dimensional, deterministic signal with abrupt structural
changes at certain points, and <code class="reqn">\epsilon_t</code> are independent and identically
distributed random variables with mean zero and variance one. In this function,
the following scenarios for <code class="reqn">f_t</code> are implemented.
</p>

<ul>
<li> <p>Piecewise-constant signal with Gaussian noise.
</p>
<p>Use <code>contrast = ``mean''</code> and <code>ht = FALSE</code> here.
</p>
</li>
<li> <p>Piecewise-constant signal with heavy-tailed noise.
</p>
<p>Use <code>contrast = ``mean''</code> and <code>ht = TRUE</code> here.
</p>
</li>
<li> <p>Continuous, piecewise-linear signal with Gaussian noise.
</p>
<p>Use <code>contrast = ``slope''</code> and <code>ht = FALSE</code> here.
</p>
</li>
<li> <p>Continuous, piecewise-linear signal with heavy-tailed noise.
</p>
<p>Use <code>contrast = ``slope''</code> and <code>ht = TRUE</code> here.
</p>
</li></ul>

<p>In the case where <code>ht = FALSE</code>: the function firstly detects the change-points using
<code><a href="#topic+win_pcm_th">win_pcm_th</a></code> (for the case of piecewise-constant signal) or <code><a href="#topic+win_cplm_th">win_cplm_th</a></code>
(for the case of continuous, piecewise-linear signal). If the estimated number of change-points
is greater than 100, then the result is returned and we stop. Otherwise, <code><a href="#topic+ID">ID</a></code> proceeds
to detect the change-points using <code><a href="#topic+pcm_ic">pcm_ic</a></code> (for the case of piecewise-constant signal)
or <code><a href="#topic+cplm_ic">cplm_ic</a></code> (for the case of continuous, piecewise-linear signal) and this is what is
returned.<br />
In the case where <code>ht = TRUE</code>: First we pre-average the given data sequence using <code><a href="#topic+normalise">normalise</a></code>
and then, on the obtained data sequence, we follow exactly the same procedure as the one when <code>ht = FALSE</code>
above.<br />
More details can be found in &ldquo;Detecting multiple generalized change-points by isolating single ones&rdquo;,
Anastasiou and Fryzlewicz (2018), preprint.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>

<table>
<tr>
 <td style="text-align: left;">
   </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>cpt</code> </td><td style="text-align: left;"> A vector with the detected change-points.
   </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>no_cpt</code> </td><td style="text-align: left;"> The number of change-points detected.
   </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>fit</code> </td><td style="text-align: left;"> A numeric vector with the estimated signal.
   </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>solution_path</code> </td><td style="text-align: left;"> A vector containing the solution path.
 </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Andreas Anastasiou, <a href="mailto:a.anastasiou@lse.ac.uk">a.anastasiou@lse.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ID_pcm">ID_pcm</a></code>, <code><a href="#topic+ID_cplm">ID_cplm</a></code>, <code><a href="#topic+ht_ID_pcm">ht_ID_pcm</a></code>, and
<code><a href="#topic+ht_ID_cplm">ht_ID_cplm</a></code>, which are the functions that are employed
in <code><a href="#topic+ID">ID</a></code>, depending on which scenario is imposed by the input arguments.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>single.cpt.mean &lt;- c(rep(4,3000),rep(0,3000))
single.cpt.mean.normal &lt;- single.cpt.mean + rnorm(6000)
single.cpt.mean.student &lt;- single.cpt.mean + rt(6000, df = 5)
cpt.single.mean.normal &lt;- ID(single.cpt.mean.normal)
cpt.single.mean.student &lt;- ID(single.cpt.mean.student, ht = TRUE)

single.cpt.slope &lt;- c(seq(0, 1999, 1), seq(1998, -1, -1))
single.cpt.slope.normal &lt;- single.cpt.slope + rnorm(4000)
single.cpt.slope.student &lt;- single.cpt.slope + rt(4000, df = 5)
cpt.single.slope.normal &lt;- ID(single.cpt.slope.normal, contrast = "slope")
cpt.single.slope.student &lt;- ID(single.cpt.slope.student, contrast = "slope", ht = TRUE)
</code></pre>

<hr>
<h2 id='ID_cplm'>Multiple change-point detection for a continuous, piecewise-linear signal
using the Isolate-Detect methodology</h2><span id='topic+ID_cplm'></span>

<h3>Description</h3>

<p>This function estimates the number and locations of multiple change-points in the noisy,
continuous and piecewise-linear input vector <code>x</code>, using the Isolate-Detect methodology. The noise
follows the normal distribution. The estimated signal, as well as the solution path defined
in <code><a href="#topic+sol_path_cplm">sol_path_cplm</a></code> are also given. The function is a hybrid between the thresholding
approach of <code><a href="#topic+win_cplm_th">win_cplm_th</a></code> and the information criterion approach of
<code><a href="#topic+cplm_ic">cplm_ic</a></code> and estimates the change-points taking into account both these
approaches (see Details for more information and the relevant literature reference).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ID_cplm(x, thr_id = 1.4, th_ic_id = 1.25, pointsth = 3, pointsic = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ID_cplm_+3A_x">x</code></td>
<td>
<p>A numeric vector containing the data in which you would like to find
change-points.</p>
</td></tr>
<tr><td><code id="ID_cplm_+3A_thr_id">thr_id</code></td>
<td>
<p>A positive real number with default value equal to 1.4. It is
used to define the threshold, if the thresholding approach is to be followed; see
<code><a href="#topic+cplm_th">cplm_th</a></code> for more details.</p>
</td></tr>
<tr><td><code id="ID_cplm_+3A_th_ic_id">th_ic_id</code></td>
<td>
<p>A positive real number with default value equal to 1.25. It is
useful only if the model selection based Isolate-Detect method is to be followed
and it is used to define the threshold value that will be used at the first step
(change-point overestimation) of the model selection approach described in
<code><a href="#topic+cplm_ic">cplm_ic</a></code>.</p>
</td></tr>
<tr><td><code id="ID_cplm_+3A_pointsth">pointsth</code></td>
<td>
<p>A positive integer with default value equal to 3. It is used only
when the threshold based approach is to be followed and it defines the distance
between two consecutive end- or start-points of the right- or left-expanding intervals,
respectively.</p>
</td></tr>
<tr><td><code id="ID_cplm_+3A_pointsic">pointsic</code></td>
<td>
<p>A positive integer with default value equal to 10. It is used only
when the information criterion based approach is to be followed and it defines
the distance between two consecutive end- or start-points of the right- or
left-expanding intervals, respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Firstly, this function detects the change-points using <code><a href="#topic+win_cplm_th">win_cplm_th</a></code>.
If the estimated number of change-points is larger than 100, then the
result is returned and we stop. Otherwise, <code><a href="#topic+ID_cplm">ID_cplm</a></code> proceeds to detect the
change-points using <code><a href="#topic+cplm_ic">cplm_ic</a></code> and this is what is returned. To sum up,
<code><a href="#topic+ID_cplm">ID_cplm</a></code> returns a result based on <code><a href="#topic+cplm_ic">cplm_ic</a></code> if the estimated number
of change-points is less than 100. Otherwise, the result comes from thresholding.
More details can be found in &ldquo;Detecting multiple generalized change-points by
isolating single ones&rdquo;, Anastasiou and Fryzlewicz (2018), preprint.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>

<table>
<tr>
 <td style="text-align: left;">
   </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>cpt</code> </td><td style="text-align: left;"> A vector with the detected change-points.
   </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>no_cpt</code> </td><td style="text-align: left;"> The number of change-points detected.
   </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>fit</code> </td><td style="text-align: left;"> A numeric vector with the estimated continuous piecewise-linear signal.
   </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>solution_path</code> </td><td style="text-align: left;"> A vector containing the solution path.
 </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Andreas Anastasiou, <a href="mailto:a.anastasiou@lse.ac.uk">a.anastasiou@lse.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+win_cplm_th">win_cplm_th</a></code> and <code><a href="#topic+cplm_ic">cplm_ic</a></code> which are the functions that
<code><a href="#topic+ID_cplm">ID_cplm</a></code> is based on. In addition, see <code><a href="#topic+ID_pcm">ID_pcm</a></code> for the case of detecting changes
in the mean of a piecewise-constant signal. The main function <code><a href="#topic+ID">ID</a></code> of the package
employs <code><a href="#topic+ID_cplm">ID_cplm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>single.cpt &lt;- c(seq(0, 999, 1), seq(998.5, 499, -0.5))
single.cpt.noise &lt;- single.cpt + rnorm(2000)
cpt.single &lt;- ID_cplm(single.cpt.noise)

three.cpt &lt;- c(seq(0, 499, 1), seq(498.5, 249, -0.5), seq(250,1249,2), seq(1248,749,-1))
three.cpt.noise &lt;- three.cpt + rnorm(2000)
cpt.three &lt;- ID_cplm(three.cpt.noise)

multi.cpt &lt;- rep(c(seq(0,49,1), seq(48,0,-1)),20)
multi.cpt.noise &lt;- multi.cpt + rnorm(1980)
cpt.multi &lt;- ID_cplm(multi.cpt.noise)
</code></pre>

<hr>
<h2 id='ID_pcm'>Multiple change-point detection in the mean of a vector using the
Isolate-Detect methodology</h2><span id='topic+ID_pcm'></span>

<h3>Description</h3>

<p>This function estimates the number and locations of multiple change-points in the mean
of the noisy piecewise-constant input vector <code>x</code>, using the Isolate-Detect methodology. The noise
is Gaussian. The estimated signal, as well as the solution path defined in <code><a href="#topic+sol_path_pcm">sol_path_pcm</a></code> are
also given. The function is a hybrid between the thresholding approach of <code><a href="#topic+win_pcm_th">win_pcm_th</a></code> and the
information criterion approach of <code><a href="#topic+pcm_ic">pcm_ic</a></code> and estimates the change-points taking into
account both these approaches (see Details for more information and the relevant literature reference).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ID_pcm(x, thr_id = 1, th_ic_id = 0.9, pointsth = 3, pointsic = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ID_pcm_+3A_x">x</code></td>
<td>
<p>A numeric vector containing the data in which you would like to find
change-points.</p>
</td></tr>
<tr><td><code id="ID_pcm_+3A_thr_id">thr_id</code></td>
<td>
<p>A positive real number with default value equal to 1. It is
used to define the threshold, if the thresholding approach is to be followed; see <code><a href="#topic+pcm_th">pcm_th</a></code>
for more details.</p>
</td></tr>
<tr><td><code id="ID_pcm_+3A_th_ic_id">th_ic_id</code></td>
<td>
<p>A positive real number with default value equal to 0.9. It is
useful only if the model selection based Isolate-Detect method is to be followed.
It is used to define the threshold value that will be used at the first step
(change-point overestimation) of the model selection approach described in <code><a href="#topic+pcm_ic">pcm_ic</a></code>.</p>
</td></tr>
<tr><td><code id="ID_pcm_+3A_pointsth">pointsth</code></td>
<td>
<p>A positive integer with default value equal to 3. It is used only
when the threshold based approach is to be followed and it defines the distance
between two consecutive end- or start-points of the right- or left-expanding intervals,
respectively.</p>
</td></tr>
<tr><td><code id="ID_pcm_+3A_pointsic">pointsic</code></td>
<td>
<p>A positive integer with default value equal to 10. It is used only
when the information criterion based approach is to be followed and it defines
the distance between two consecutive end- or start-points of the right- or
left-expanding intervals, respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Firstly, this function detects the change-points using <code><a href="#topic+win_pcm_th">win_pcm_th</a></code>.
If the estimated number of change-points is larger than 100, then the
result is returned and we stop. Otherwise, <code><a href="#topic+ID_pcm">ID_pcm</a></code> proceeds to detect the
change-points using <code><a href="#topic+pcm_ic">pcm_ic</a></code> and this is what is returned. To sum up,
<code><a href="#topic+ID_pcm">ID_pcm</a></code> returns a result based on <code><a href="#topic+pcm_ic">pcm_ic</a></code> if the estimated number
of change-points is less than 100. Otherwise, the result comes from thresholding.
More details can be found in &ldquo;Detecting multiple generalized change-points by
isolating single ones&rdquo;, Anastasiou and Fryzlewicz (2018), preprint.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>

<table>
<tr>
 <td style="text-align: left;">
   </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>cpt</code> </td><td style="text-align: left;"> A vector with the detected change-points.
   </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>no_cpt</code>    </td><td style="text-align: left;"> The number of change-points detected.
   </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>fit</code> </td><td style="text-align: left;"> A numeric vector with the estimated piecewise-constant signal.
   </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>solution_path</code> </td><td style="text-align: left;"> A vector containing the solution path.
  </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Andreas Anastasiou, <a href="mailto:a.anastasiou@lse.ac.uk">a.anastasiou@lse.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+win_pcm_th">win_pcm_th</a></code> and <code><a href="#topic+pcm_ic">pcm_ic</a></code> which are the functions that <code><a href="#topic+ID_pcm">ID_pcm</a></code>
is based on. In addition, see <code><a href="#topic+ID_cplm">ID_cplm</a></code> for the case of detecting changes
in a continuous, piecewise-linear signal. The main function <code><a href="#topic+ID">ID</a></code>
of the package employs <code><a href="#topic+ID_pcm">ID_pcm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>single.cpt &lt;- c(rep(4,1000),rep(0,1000))
single.cpt.noise &lt;- single.cpt + rnorm(2000)
cpts_detect &lt;- ID_pcm(single.cpt.noise)

three.cpt &lt;- c(rep(4,500),rep(0,500),rep(-4,500),rep(1,500))
three.cpt.noise &lt;- three.cpt + rnorm(2000)
cpts_detect_three &lt;- ID_pcm(three.cpt.noise)

multi.cpt &lt;- rep(c(rep(0,50),rep(3,50)),20)
multi.cpt.noise &lt;- multi.cpt + rnorm(2000)
cpts_detect_multi &lt;- ID_pcm(multi.cpt.noise)
</code></pre>

<hr>
<h2 id='normalise'>Transform the noise to be closer to the Gaussian distribution</h2><span id='topic+normalise'></span>

<h3>Description</h3>

<p>This function pre-processes the given data in order to obtain a noise structure
that is closer to satisfying the Gaussianity assumption. See details for more information
and for the relevant literature reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalise(x, sc = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normalise_+3A_x">x</code></td>
<td>
<p>A numeric vector containing the data.</p>
</td></tr>
<tr><td><code id="normalise_+3A_sc">sc</code></td>
<td>
<p>A positive integer number with default value equal to 3. It is
used to define the way we pre-average the given data sequence.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a given natural number <code>sc</code> and data <code>x</code> of length <code class="reqn">T</code>, let us
denote by <code class="reqn">Q = \lceil T/sc \rceil</code>. Then, <code><a href="#topic+normalise">normalise</a></code> calculates
</p>
<p style="text-align: center;"><code class="reqn">\tilde{x}_q = 1/sc\sum_{t=(q-1) * sc + 1}^{q * sc}x_t,</code>
</p>
<p> for <code class="reqn">q=1, 2, ..., Q-1</code>, while
</p>
<p style="text-align: center;"><code class="reqn">\tilde{x}_Q = (T - (Q-1) * sc)^{-1}\sum_{t = (Q-1) * sc + 1}^{T}x_t.</code>
</p>

<p>More details can be found in the preprint &ldquo;Detecting multiple generalized
change-points by isolating single ones&rdquo;, Anastasiou and Fryzlewicz (2018).
</p>


<h3>Value</h3>

<p>The &ldquo;normalised&rdquo; vector <code class="reqn">\tilde{x}</code> of length <code class="reqn">Q</code>, as explained in Details.
</p>


<h3>Author(s)</h3>

<p>Andreas Anastasiou, <a href="mailto:a.anastasiou@lse.ac.uk">a.anastasiou@lse.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ht_ID_pcm">ht_ID_pcm</a></code> and <code><a href="#topic+ht_ID_cplm">ht_ID_cplm</a></code>, which are
functions that employ <code><a href="#topic+normalise">normalise</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t5 &lt;- rt(n = 10000, df = 5)
n5 &lt;- normalise(t5, sc = 3)
</code></pre>

<hr>
<h2 id='pcm_ic'>Multiple change-point detection in the mean via minimising an information
criterion</h2><span id='topic+pcm_ic'></span>

<h3>Description</h3>

<p>This function performs the Isolate-Detect methodology based on an information
criterion approach, in order to detect multiple change-points in the mean of
a noisy data sequence, with the noise following the Gaussian distribution.
More information on how this approach works as well as the relevant literature
reference are given in Details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcm_ic(x, th_const = 0.9, Kmax = 200, penalty = c("ssic_pen", "sic_pen"),
  points = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pcm_ic_+3A_x">x</code></td>
<td>
<p>A numeric vector containing the data in which you would like to find
change-points.</p>
</td></tr>
<tr><td><code id="pcm_ic_+3A_th_const">th_const</code></td>
<td>
<p>A positive real number with default value equal to 0.9. It is
used to define the threshold value that will be used at the first step of the
model selection based Isolate-Detect method; see Details for more information.</p>
</td></tr>
<tr><td><code id="pcm_ic_+3A_kmax">Kmax</code></td>
<td>
<p>A positive integer with default value equal to 200. It is the
maximum allowed number of estimated change-points in the solution path algorithm,
described in Details below.</p>
</td></tr>
<tr><td><code id="pcm_ic_+3A_penalty">penalty</code></td>
<td>
<p>A character vector with names of the penalty functions used.</p>
</td></tr>
<tr><td><code id="pcm_ic_+3A_points">points</code></td>
<td>
<p>A positive integer with default value equal to 10. It defines
the distance between two consecutive end- or start-points of the right- or
left-expanding intervals, respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The approach followed in <code><a href="#topic+pcm_ic">pcm_ic</a></code> in order to detect
the change-points is based on identifying the set of change-points that
minimise an information criterion. At first, we employ <code><a href="#topic+sol_path_pcm">sol_path_pcm</a></code>,
which overestimates the number of change-points using <code>th_const</code> in order to define the
threshold, and then sorts the obtained estimates in a way that the estimate, which
is most likely to be correct appears first, whereas the least likely to
be correct, appears last. Let <code class="reqn">J</code> be the number of estimates
that this overestimation approach returns. We will obtain a vector
<code class="reqn">b = (b_1, b_2, ..., b_J)</code>, with the estimates ordered as explained above. We define
the collection <code class="reqn">\left\{M_j\right\}_{j = 0,1,\ldots,J}</code>, where <code class="reqn">M_0</code> is the empty set
and <code class="reqn">M_j = \left\{b_1,b_2,...,b_j\right\}</code>. Among the collection of models
<code class="reqn">M_j, j=0,1,...,J</code>, we select the one that minimises a predefined Information
Criterion. The obtained set of change-points is apparently a subset of the solution path
given in <code><a href="#topic+sol_path_pcm">sol_path_pcm</a></code>. More details can be found in
&ldquo;Detecting multiple generalized change-points by isolating single ones&rdquo;,
Anastasiou and Fryzlewicz (2018), preprint.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>

<table>
<tr>
 <td style="text-align: left;">
   </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>sol_path</code> </td><td style="text-align: left;"> A vector containing the solution path.
   </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>ic_curve</code>   </td><td style="text-align: left;"> A list with values of the chosen information criteria.
   </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>cpt_ic</code> </td><td style="text-align: left;"> A list with the change-points detected for each information
  criterion considered.
   </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>no_cpt_ic </code> </td><td style="text-align: left;"> The number of change-points detected for each information
  criterion considered.
 </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Andreas Anastasiou, <a href="mailto:a.anastasiou@lse.ac.uk">a.anastasiou@lse.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ID_pcm">ID_pcm</a></code> and <code><a href="#topic+ID">ID</a></code>, which employ this function.
In addition, see <code><a href="#topic+cplm_ic">cplm_ic</a></code> for the case of detecting changes in
a continuous, piecewise-linear signal using the information criterion based approach.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>single.cpt &lt;- c(rep(4,1000),rep(0,1000))
single.cpt.noise &lt;- single.cpt + rnorm(2000)
cpt.single.ic &lt;- pcm_ic(single.cpt.noise)

three.cpt &lt;- c(rep(4,500),rep(0,500),rep(-4,500),rep(1,500))
three.cpt.noise &lt;- three.cpt + rnorm(2000)
cpt.three.ic &lt;- pcm_ic(three.cpt.noise)
</code></pre>

<hr>
<h2 id='pcm_th'>Multiple change-point detection in the mean via thresholding</h2><span id='topic+pcm_th'></span>

<h3>Description</h3>

<p>This function performs the Isolate-Detect methodology (see Details for the
relevant literature reference) with the thresholding-based stopping rule
in order to detect multiple change-points in the mean of a noisy input vector
<code>x</code>, with Gaussian noise. See Details for a brief explanation of the
Isolate-Detect methodology, and of the thresholding-based stopping rule.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcm_th(x, sigma = stats::mad(diff(x)/sqrt(2)), thr_const = 1,
  thr_fin = sigma * thr_const * sqrt(2 * log(length(x))), s = 1,
  e = length(x), points = 3, k_l = 1, k_r = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pcm_th_+3A_x">x</code></td>
<td>
<p>A numeric vector containing the data in which you would like to find
change-points.</p>
</td></tr>
<tr><td><code id="pcm_th_+3A_sigma">sigma</code></td>
<td>
<p>A positive real number. It is the estimate of the standard deviation
of the noise in <code>x</code>. The default value is the median absolute deviation of <code>x</code>
computed under the assumption that the noise is independent and identically distributed
from the Gaussian distribution.</p>
</td></tr>
<tr><td><code id="pcm_th_+3A_thr_const">thr_const</code></td>
<td>
<p>A positive real number with default value equal to 1. It is
used to define the threshold; see <code>thr_fin</code>.</p>
</td></tr>
<tr><td><code id="pcm_th_+3A_thr_fin">thr_fin</code></td>
<td>
<p>With <code>T</code> the length of the data sequence, this is a positive real
number with default value equal to <code>sigma * thr_const * sqrt(2 * log(T))</code>. It is
the threshold, which is used in the detection process.</p>
</td></tr>
<tr><td><code id="pcm_th_+3A_s">s</code>, <code id="pcm_th_+3A_e">e</code></td>
<td>
<p>Positive integers with <code>s</code> less than <code>e</code>, which indicate
that you want to check for change-points in the data sequence with subscripts
in <code>[s,e]</code>. The default values are <code>s</code> equal to 1 and
<code>e</code> equal to <code>T</code>, with <code>T</code> the length of the data sequence.</p>
</td></tr>
<tr><td><code id="pcm_th_+3A_points">points</code></td>
<td>
<p>A positive integer with default value equal to 3. It defines
the distance between two consecutive end- or start-points of the right- or
left-expanding intervals, respectively; see Details for more information.</p>
</td></tr>
<tr><td><code id="pcm_th_+3A_k_l">k_l</code>, <code id="pcm_th_+3A_k_r">k_r</code></td>
<td>
<p>Positive integer numbers that get updated whenever the function
calls itself during the detection process. They are not essential for the
function to work, and we include them only to reduce the computational time.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The change-point detection algorithm that is used in <code><a href="#topic+pcm_th">pcm_th</a></code> is the
Isolate-Detect methodology described in &ldquo;Detecting multiple generalized
change-points by isolating single ones&rdquo;, Anastasiou and Fryzlewicz (2018), preprint.
The concept is simple and is split into two stages; firstly, isolation of each
of the true change-points in subintervals of the data domain, and secondly their detection.
ID first creates two ordered sets of <code class="reqn">K = \lceil T/\code{points}\rceil</code> right- and left-expanding
intervals as follows. The <code class="reqn">j^{th}</code> right-expanding interval is <code class="reqn">R_j = [1, j\times \code{points}]</code>,
while the <code class="reqn">j^{th}</code> left-expanding interval is <code class="reqn">L_j = [T - j\times \code{points} + 1, T]</code>.
We collect these intervals in the ordered set <code class="reqn">S_{RL} = \lbrace R_1, L_1, R_2, L_2, ... , R_K, L_K\rbrace</code>.
For a suitably chosen contrast function, ID first identifies the point with the maximum contrast
value in <code class="reqn">R_1</code>. If its value exceeds a certain threshold, then it is taken as a change-point.
If not, then the process tests the next interval in <code class="reqn">S_{RL}</code> and repeats the above process.
Upon detection, the algorithm makes a new start from estimated location.
</p>


<h3>Value</h3>

<p>A numeric vector with the detected change-points.
</p>


<h3>Author(s)</h3>

<p>Andreas Anastasiou, <a href="mailto:a.anastasiou@lse.ac.uk">a.anastasiou@lse.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+win_pcm_th">win_pcm_th</a></code>, <code><a href="#topic+ID_pcm">ID_pcm</a></code>, and <code><a href="#topic+ID">ID</a></code>, which employ
this function. In addition, see <code><a href="#topic+cplm_th">cplm_th</a></code> for the case of detecting changes in
a continuous, piecewise-linear signal via thresholding.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>single.cpt &lt;- c(rep(4,1000),rep(0,1000))
single.cpt.noise &lt;- single.cpt + rnorm(2000)
cpt.single.th &lt;- pcm_th(single.cpt.noise)

three.cpt &lt;- c(rep(4,500),rep(0,500),rep(-4,500),rep(1,500))
three.cpt.noise &lt;- three.cpt + rnorm(2000)
cpt.three.th &lt;- pcm_th(three.cpt.noise)

multi.cpt &lt;- rep(c(rep(0,50),rep(3,50)),20)
multi.cpt.noise &lt;- multi.cpt + rnorm(2000)
cpt.multi.th &lt;- pcm_th(multi.cpt.noise)
</code></pre>

<hr>
<h2 id='resid_ID'>Calculate the residuals related to the estimated signal</h2><span id='topic+resid_ID'></span>

<h3>Description</h3>

<p>This function returns the difference between <code>x</code> and the estimated signal
with change-points at <code>cpt</code>. The input in the argument <code>type_chg</code> will
indicate the type of changes in the signal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resid_ID(x, cpt, type_chg = c("mean", "slope"), type_res = c("raw",
  "standardised"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resid_ID_+3A_x">x</code></td>
<td>
<p>A numeric vector containing the data.</p>
</td></tr>
<tr><td><code id="resid_ID_+3A_cpt">cpt</code></td>
<td>
<p>A positive integer vector with the locations of the change-points.
If missing, the <code><a href="#topic+ID">ID</a></code> function is called internally to detect any change-points
that might be present in <code>x</code>.</p>
</td></tr>
<tr><td><code id="resid_ID_+3A_type_chg">type_chg</code></td>
<td>
<p>A character string, which defines the type of the detected change-points.
If <code>type_chg = ``mean''</code>, then the change-points represent the locations of changes
in the mean of a piecewise-constant signal. If <code>type_chg = ``slope''</code>, then the
change-points represent the locations of changes in the slope of a piecewise-linear
and continuous signal.</p>
</td></tr>
<tr><td><code id="resid_ID_+3A_type_res">type_res</code></td>
<td>
<p>A choice of <code>``raw''</code> and <code>``standardised''</code> residuals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>type_res = ``raw''</code>, the function returns the difference between the data
and the estimated signal. If <code>type_res = ``standardised''</code>, then the function
returns the difference between the data and the estimated signal, divided by
the estimated standard deviation.
</p>


<h3>Author(s)</h3>

<p>Andreas Anastasiou, <a href="mailto:a.anastasiou@lse.ac.uk">a.anastasiou@lse.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>single.cpt.pcm &lt;- c(rep(4,1000),rep(0,1000))
single.cpt.pcm.noise &lt;- single.cpt.pcm + rnorm(2000)
cpt_detect &lt;- ID(single.cpt.pcm.noise, contrast = "mean")

residuals_cpt_raw &lt;- resid_ID(single.cpt.pcm.noise, cpt = cpt_detect$cpt, type_chg = "mean",
type_res = "raw")

residuals_cpt_stand. &lt;- resid_ID(single.cpt.pcm.noise, cpt = cpt_detect$cpt, type_chg = "mean",
type_res = "standardised")

plot(residuals_cpt_raw)
plot(residuals_cpt_stand.)
</code></pre>

<hr>
<h2 id='s_e_points'>Derives a subset of integers from a given set</h2><span id='topic+s_e_points'></span>

<h3>Description</h3>

<p>This function finds two subsets of integers in a given interval <code>[s,e]</code>.
The routine is typically not called directly by the user; its result
is used in order to construct the expanding intervals, where the Isolate-Detect method
is going to be applied. For more details on how the Isolate-Detect methodology works, see
References.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s_e_points(r, l, s, e)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="s_e_points_+3A_r">r</code></td>
<td>
<p>A positive integer vector containing the set, from which the end-points
of the expanding intervals are to be chosen.</p>
</td></tr>
<tr><td><code id="s_e_points_+3A_l">l</code></td>
<td>
<p>A positive integer vector containing the set, from which the start-points
of the expanding intervals are to be chosen.</p>
</td></tr>
<tr><td><code id="s_e_points_+3A_s">s</code></td>
<td>
<p>A positive integer indicating the starting position, in the sense that we will
choose the elements from <code>r</code> and <code>l</code> that are greater than <code>s</code>.</p>
</td></tr>
<tr><td><code id="s_e_points_+3A_e">e</code></td>
<td>
<p>A positive integer indicating the finishing position, in the sense that we will
choose the elements from <code>r</code> and <code>l</code> that are less than <code>e</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>e_points</code>  A vector containing the points that will be used as end-points,
in order to create the left-expanding intervals. It consists of the input <code>e</code> and
all the elements in the input vector <code>r</code> that are in <code>(s,e)</code>.
</p>
<p><code>s_points</code>  A vector containing the points that will be used as start-points,
in order to create the left-expanding intervals. It consists of the input <code>s</code> and
all the elements in the input vector <code>l</code> that are in <code>(s,e)</code>
</p>


<h3>Author(s)</h3>

<p>Andreas Anastasiou, <a href="mailto:a.anastasiou@lse.ac.uk">a.anastasiou@lse.ac.uk</a>
</p>


<h3>References</h3>

<p>Anastasiou, A. and Fryzlewicz, P. (2018). Detecting multiple generalized change-points
by isolating single ones.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s_e_points(r = seq(10,1000,10), l = seq(991,1,-10), s=435, e = 786)
s_e_points(r = seq(3,100,3), l = seq(98,1,-3), s=43, e = 86)
</code></pre>

<hr>
<h2 id='sol_path_cplm'>The solution path for the case of continuous piecewise-linear signals</h2><span id='topic+sol_path_cplm'></span>

<h3>Description</h3>

<p>This function starts by over-estimating the number of true change-points.
After that, following an approach based on the values of a suitable contrast function,
it sorts the estimated change-points in a way that the estimation, which is
most-likely to be correct appears first, whereas the least likely to be correct,
appears last. The routine is typically not called directly by the user; it is
employed in <code><a href="#topic+cplm_ic">cplm_ic</a></code>. For more details, see References.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sol_path_cplm(x, thr_ic = 1.25, points = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sol_path_cplm_+3A_x">x</code></td>
<td>
<p>A numeric vector containing the data in which you would like to find
change-points.</p>
</td></tr>
<tr><td><code id="sol_path_cplm_+3A_thr_ic">thr_ic</code></td>
<td>
<p>A positive real number with default value equal to 1.25. It is
used to define the threshold. The change-points are estimated by thresholding
with threshold equal to <code>sigma * thr_ic * sqrt(2 * log(T))</code>, where
<code>T</code> is the length of the data sequence <code>x</code> and <code>sigma = mad(diff(diff(x)))/6</code>.
Because, we would like to overestimate the number of the true change-points in <code>x</code>, it is
suggested to keep <code>thr_ic</code> smaller than 1.4, which is the default value used as
the threshold constant in the function <code><a href="#topic+win_cplm_th">win_cplm_th</a></code>.</p>
</td></tr>
<tr><td><code id="sol_path_cplm_+3A_points">points</code></td>
<td>
<p>A positive integer with default value equal to 3. It defines
the distance between two consecutive end- or start-points of the right- or
left-expanding intervals, respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The solution path for the case of continuous piecewise-linear signals.
</p>


<h3>Author(s)</h3>

<p>Andreas Anastasiou, <a href="mailto:a.anastasiou@lse.ac.uk">a.anastasiou@lse.ac.uk</a>
</p>


<h3>References</h3>

<p>Anastasiou, A. and Fryzlewicz, P. (2018). Detecting multiple generalized change-points
by isolating single ones.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>three.cpt &lt;- c(seq(0, 499, 1), seq(498.5, 249, -0.5), seq(250.5,999,1.5), seq(998,499,-1))
three.cpt.noise &lt;- three.cpt + rnorm(2000)
solution.path &lt;- sol_path_cplm(three.cpt.noise)
</code></pre>

<hr>
<h2 id='sol_path_pcm'>The solution path for the case of piecewise-constant signals</h2><span id='topic+sol_path_pcm'></span>

<h3>Description</h3>

<p>This function starts by overestimating the number of true change-points.
After that, following a CUSUM-based approach, it sorts the estimated change-points
in a way that the estimate, which is most-likely to be correct appears first, whereas
the least likely to be correct, appears last. The routine is typically not called
directly by the user; it is employed in <code><a href="#topic+pcm_ic">pcm_ic</a></code>. For more information, see
References.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sol_path_pcm(x, thr_ic = 0.9, points = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sol_path_pcm_+3A_x">x</code></td>
<td>
<p>A numeric vector containing the data in which you would like to find
change-points.</p>
</td></tr>
<tr><td><code id="sol_path_pcm_+3A_thr_ic">thr_ic</code></td>
<td>
<p>A positive real number with default value equal to 0.9. It is
used to define the threshold. The change-points are estimated by thresholding
with threshold equal to <code>sigma * thr_ic * sqrt(2 * log(T))</code>, where
<code>T</code> is the length of the data sequence <code>x</code> and <code>sigma = mad(diff(x)/sqrt(2))</code>.
Because we would like to overestimate the number of true change-points in <code>x</code>, it is
suggested to keep <code>thr_ic</code> smaller than 1, which is the default value used as
the threshold constant in the function <code><a href="#topic+pcm_th">pcm_th</a></code>.</p>
</td></tr>
<tr><td><code id="sol_path_pcm_+3A_points">points</code></td>
<td>
<p>A positive integer with default value equal to 3. It defines
the distance between two consecutive end- or start-points of the right- or
left-expanding intervals, respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The solution path for the case of piecewise-constant signals.
</p>


<h3>Author(s)</h3>

<p>Andreas Anastasiou, <a href="mailto:a.anastasiou@lse.ac.uk">a.anastasiou@lse.ac.uk</a>
</p>


<h3>References</h3>

<p>Anastasiou, A. and Fryzlewicz, P. (2018). Detecting multiple generalized change-points
by isolating single ones.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>three.cpt &lt;- c(rep(4,4000),rep(0,4000),rep(-4,4000),rep(1,4000))
three.cpt.noise &lt;- three.cpt + rnorm(16000)
solution.path &lt;- sol_path_pcm(three.cpt.noise)
</code></pre>

<hr>
<h2 id='win_cplm_th'>A windows-based approach for multiple change-point detection in a continuous,
piecewise-linear signal via thresholding</h2><span id='topic+win_cplm_th'></span>

<h3>Description</h3>

<p>This function performs the windows-based variant of the Isolate-Detect methodology
with the thresholding-based stopping rule in order to detect multiple change-points
in a continuous, piecewise-linear noisy data sequence, with the noise being Gaussian.
It is particularly helpful for very long data sequences, as due to applying Isolate-Detect
on moving windows, the computational time is reduced. See Details for a brief explanation of
this approach and for the relevant literature reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>win_cplm_th(xd, sigma = stats::mad(diff(diff(xd)))/sqrt(6), thr_con = 1.4,
  c_win = 3000, w_points = 3, l_win = 12000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="win_cplm_th_+3A_xd">xd</code></td>
<td>
<p>A numeric vector containing the data in which you would like to find
change-points.</p>
</td></tr>
<tr><td><code id="win_cplm_th_+3A_sigma">sigma</code></td>
<td>
<p>A positive real number. It is the estimate of the standard deviation
of the noise in <code>xd</code>. The default value is <code>mad(diff(diff(xd)))/sqrt(6)</code>, where
<code>mad(xd)</code> denotes the median absolute deviation of <code>xd</code> computed under the
assumption that the noise is independent and identically distributed from the
Gaussian distribution.</p>
</td></tr>
<tr><td><code id="win_cplm_th_+3A_thr_con">thr_con</code></td>
<td>
<p>A positive real number with default value equal to 1.4. It is
used to define the threshold. The change-points are estimated by thresholding
with threshold equal to <code>sigma * thr_con * sqrt(2 * log(T))</code>, where
<code>T</code> is the length of the data sequence <code>xd</code>.</p>
</td></tr>
<tr><td><code id="win_cplm_th_+3A_c_win">c_win</code></td>
<td>
<p>A positive integer with default value equal to 3000. It is the length
of each window for the data sequence in hand. Isolate-Detect will be applied
in segments of the form <code>[(i-1) * c_win + 1, i * c_win]</code>, for <code class="reqn">i=1,2,...,K</code>,
where <code class="reqn">K</code> depends on the length <code>T</code> of the data sequence.</p>
</td></tr>
<tr><td><code id="win_cplm_th_+3A_w_points">w_points</code></td>
<td>
<p>A positive integer with default value equal to 3. It defines
the distance between two consecutive end- or start-points of the right- or
left-expanding intervals, respectively.</p>
</td></tr>
<tr><td><code id="win_cplm_th_+3A_l_win">l_win</code></td>
<td>
<p>A positive integer with default value equal to 12000. If the length of
the data sequence is less than or equal to <code>l_win</code>, then the windows-based approach
will not be applied and the result will be obtained by the classical Isolate-Detect
methodology based on thresholding.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method that is implemented by this function is based on splitting the given
data sequence uniformly into smaller parts (windows), to which Isolate-Detect, based on the
thresholding stopping rule (see <code><a href="#topic+cplm_th">cplm_th</a></code>), is then applied.
</p>


<h3>Value</h3>

<p>A numeric vector with the detected change-points.
</p>


<h3>Author(s)</h3>

<p>Andreas Anastasiou, <a href="mailto:a.anastasiou@lse.ac.uk">a.anastasiou@lse.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cplm_th">cplm_th</a></code>, which is the function that <code><a href="#topic+win_cplm_th">win_cplm_th</a></code> is based on. Also,
see <code><a href="#topic+ID_cplm">ID_cplm</a></code> and <code><a href="#topic+ID">ID</a></code>, which employ <code><a href="#topic+win_cplm_th">win_cplm_th</a></code>. In addition,
see <code><a href="#topic+win_pcm_th">win_pcm_th</a></code> for the case of detecting changes in a piecewise-constant signal via
thresholding.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>single.cpt &lt;- c(seq(0, 999, 1), seq(998.5, 499, -0.5))
single.cpt.noise &lt;- single.cpt + rnorm(2000)
cpt.single.th &lt;- win_cplm_th(single.cpt.noise)

three.cpt &lt;- c(seq(0, 3999, 1), seq(3998.5, 1999, -0.5), seq(2001,9999,2), seq(9998,5999,-1))
three.cpt.noise &lt;- three.cpt + rnorm(16000)
cpt.three.th &lt;- win_cplm_th(three.cpt.noise)
</code></pre>

<hr>
<h2 id='win_pcm_th'>A windows-based approach for multiple change-point detection in the mean via
thresholding</h2><span id='topic+win_pcm_th'></span>

<h3>Description</h3>

<p>This function performs the windows-based variant of the Isolate-Detect methodology
with the thresholding-based stopping rule in order to detect multiple change-points
in the mean of a noisy data sequence, with noise that is Gaussian. It is particularly
helpful for very long data sequences, as due to applying Isolate-Detect on moving windows,
the computational time is reduced. See Details for a brief explanation of this approach and
for the relevant literature reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>win_pcm_th(xd, sigma = stats::mad(diff(xd)/sqrt(2)), thr_con = 1,
  c_win = 3000, w_points = 3, l_win = 12000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="win_pcm_th_+3A_xd">xd</code></td>
<td>
<p>A numeric vector containing the data in which you would like to find
change-points.</p>
</td></tr>
<tr><td><code id="win_pcm_th_+3A_sigma">sigma</code></td>
<td>
<p>A positive real number. It is the estimate of the standard deviation
of the noise in <code>xd</code>. The default value is the median absolute deviation of <code>xd</code>
computed under the assumption that the noise is independent and identically distributed
from the Gaussian distribution.</p>
</td></tr>
<tr><td><code id="win_pcm_th_+3A_thr_con">thr_con</code></td>
<td>
<p>A positive real number with default value equal to 1. It is
used to define the threshold, which is equal to <code>sigma * thr_con * sqrt(2 * log(T))</code>,
where <code>T</code> is the length of the data sequence <code>xd</code>.</p>
</td></tr>
<tr><td><code id="win_pcm_th_+3A_c_win">c_win</code></td>
<td>
<p>A positive integer with default value equal to 3000. It is the length
of each window for the data sequence in hand. Isolate-Detect will be applied
in segments of the form <code>[(i-1) * c_win + 1, i * c_win]</code>, for <code class="reqn">i=1,2,...,K</code>,
where <code class="reqn">K</code> depends on the length <code>T</code> of the data sequence.</p>
</td></tr>
<tr><td><code id="win_pcm_th_+3A_w_points">w_points</code></td>
<td>
<p>A positive integer with default value equal to 3. It defines
the distance between two consecutive end- or start-points of the right- or
left-expanding intervals, respectively.</p>
</td></tr>
<tr><td><code id="win_pcm_th_+3A_l_win">l_win</code></td>
<td>
<p>A positive integer with default value equal to 12000. If the length of
the data sequence is less than or equal to <code>l_win</code>, then the windows-based approach
will not be applied and the result will be obtained by the classical Isolate-Detect
methodology based on thresholding.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method that is implemented by this function is based on splitting the given
data sequence uniformly into smaller parts (windows), to which Isolate-Detect, based on the
threshold stopping rule (see <code><a href="#topic+pcm_th">pcm_th</a></code>), is then applied. An idea of the computational
improvement that this structure offers over the classical Isolate-Detect in the case of large data
sequences is given in the supplement of &ldquo;Detecting multiple generalized change-points by isolating
single ones&rdquo;, Anastasiou and Fryzlewicz (2018), preprint.
</p>


<h3>Value</h3>

<p>A numeric vector with the detected change-points.
</p>


<h3>Author(s)</h3>

<p>Andreas Anastasiou, <a href="mailto:a.anastasiou@lse.ac.uk">a.anastasiou@lse.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pcm_th">pcm_th</a></code>, which is the function that <code><a href="#topic+win_pcm_th">win_pcm_th</a></code> is based on. Also,
see <code><a href="#topic+ID_pcm">ID_pcm</a></code> and <code><a href="#topic+ID">ID</a></code>, which employ <code><a href="#topic+win_pcm_th">win_pcm_th</a></code>. In addition,
see <code><a href="#topic+win_cplm_th">win_cplm_th</a></code> for the case of detecting changes in the slope of a
piecewise-linear and continuous signal via thresholding.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>single.cpt &lt;- c(rep(4,1000),rep(0,1000))
single.cpt.noise &lt;- single.cpt + rnorm(2000)
cpt.single.th &lt;- win_pcm_th(single.cpt.noise)

three.cpt &lt;- c(rep(4,4000),rep(0,4000),rep(-4,4000),rep(1,4000))
three.cpt.noise &lt;- three.cpt + rnorm(16000)
cpt.three.th &lt;- win_pcm_th(three.cpt.noise)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
