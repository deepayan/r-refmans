<!DOCTYPE html><html><head><title>Help for package dreamer</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dreamer}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#diagnostics'><p>Calculate MCMC Diagnostics for Parameters</p></a></li>
<li><a href='#dreamer_data'><p>Generate Data from Dose Response Models</p></a></li>
<li><a href='#dreamer_mcmc'><p>Bayesian Model Averaging of Dose Response Models</p></a></li>
<li><a href='#dreamer_plot_prior'><p>Plot Prior</p></a></li>
<li><a href='#dreamerplot'><p>Posterior Plot of Bayesian Model Averaging</p></a></li>
<li><a href='#model'><p>Model Creation</p></a></li>
<li><a href='#model_longitudinal'><p>Model Creation: Longitudinal Models</p></a></li>
<li><a href='#plot_comparison'><p>Compare Posterior Fits</p></a></li>
<li><a href='#plot_trace'><p>Traceplots</p></a></li>
<li><a href='#post_medx'><p>Posterior Distribution of Minimum X% Effective Dose</p></a></li>
<li><a href='#post_perc_effect'><p>Calculate Posterior of a Dose's Percentage Effect</p></a></li>
<li><a href='#posterior'><p>Posterior Quantities from Bayesian Model Averaging</p></a></li>
<li><a href='#pr_eoi'><p>Calculate Probability of Meeting Effect of Interest (EOI)</p></a></li>
<li><a href='#pr_med'><p>Pr(minimum efficacious dose)</p></a></li>
<li><a href='#pr_medx'><p>Probability of minimum X% effective dose</p></a></li>
<li><a href='#summary.dreamer_bma'><p>Summarize Bayesian Model Averaging MCMC Output</p></a></li>
<li><a href='#summary.dreamer_mcmc'><p>Summarize Model Output</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Dose Response Models for Bayesian Model Averaging</td>
</tr>
<tr>
<td>Version:</td>
<td>3.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Fits (longitudinal) dose-response models utilizing a Bayesian model
  averaging approach as outlined in Gould (2019) &lt;<a href="https://doi.org/10.1002%2Fbimj.201700211">doi:10.1002/bimj.201700211</a>&gt;
  for both continuous and binary responses.  Functions
  for plotting and calculating various posterior quantities
  (e.g. posterior mean, quantiles, probability of minimum efficacious dose,
  etc.) are also implemented.  Copyright Eli Lilly and Company (2019).</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/rich-payne/dreamer">https://github.com/rich-payne/dreamer</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rich-payne/dreamer/issues">https://github.com/rich-payne/dreamer/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Imports:</td>
<td>coda, dplyr (&ge; 1.0.0), ellipsis (&ge; 0.3), ggplot2, graphics,
purrr, rootSolve, rjags (&ge; 4-8), rlang (&ge; 0.4.5), stats,
tidyr (&ge; 1.0.2), tidyselect (&ge; 1.1)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0), fs (&ge; 1.5), knitr, rmarkdown, tibble,
spelling</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-31 14:46:52 UTC; c263386</td>
</tr>
<tr>
<td>Author:</td>
<td>Richard Daniel Payne [aut, cre],
  William Michael Landau [rev],
  Mitch Thomann [rev],
  Eli Lilly and Company [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Richard Daniel Payne &lt;paynestatistics@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-01 09:10:49 UTC</td>
</tr>
</table>
<hr>
<h2 id='diagnostics'>Calculate MCMC Diagnostics for Parameters</h2><span id='topic+diagnostics'></span>

<h3>Description</h3>

<p>Calculate MCMC diagnostics for individual parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagnostics(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagnostics_+3A_x">x</code></td>
<td>
<p>MCMC output from a dreamer model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble listing the Gelman point estimates and upper bounds
(obtained from coda::gelman.diag) and effective sample size
(obtained from coda::effectiveSize) for each parameter within each
model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(888)
data &lt;- dreamer_data_linear(
  n_cohorts = c(20, 20, 20),
  dose = c(0, 3, 10),
  b1 = 1,
  b2 = 3,
  sigma = 5
)

# Bayesian model averaging
output &lt;- dreamer_mcmc(
 data = data,
 n_adapt = 1e3,
 n_burn = 1e3,
 n_iter = 1e4,
 n_chains = 2,
 silent = FALSE,
 mod_linear = model_linear(
   mu_b1 = 0,
   sigma_b1 = 1,
   mu_b2 = 0,
   sigma_b2 = 1,
   shape = 1,
   rate = .001,
   w_prior = 1 / 2
 ),
 mod_quad = model_quad(
   mu_b1 = 0,
   sigma_b1 = 1,
   mu_b2 = 0,
   sigma_b2 = 1,
   mu_b3 = 0,
   sigma_b3 = 1,
   shape = 1,
   rate = .001,
   w_prior = 1 / 2
 )
)

# for all models
diagnostics(output)

# for a single model
diagnostics(output$mod_quad)
</code></pre>

<hr>
<h2 id='dreamer_data'>Generate Data from Dose Response Models</h2><span id='topic+dreamer_data'></span><span id='topic+dreamer_data_linear'></span><span id='topic+dreamer_data_linear_binary'></span><span id='topic+dreamer_data_quad'></span><span id='topic+dreamer_data_quad_binary'></span><span id='topic+dreamer_data_loglinear'></span><span id='topic+dreamer_data_loglinear_binary'></span><span id='topic+dreamer_data_logquad'></span><span id='topic+dreamer_data_logquad_binary'></span><span id='topic+dreamer_data_emax'></span><span id='topic+dreamer_data_emax_binary'></span><span id='topic+dreamer_data_exp'></span><span id='topic+dreamer_data_exp_binary'></span><span id='topic+dreamer_data_beta'></span><span id='topic+dreamer_data_beta_binary'></span><span id='topic+dreamer_data_independent'></span><span id='topic+dreamer_data_independent_binary'></span>

<h3>Description</h3>

<p>See the model definitions below for specifics for each model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dreamer_data_linear(
  n_cohorts,
  doses,
  b1,
  b2,
  sigma,
  times,
  t_max,
  longitudinal = NULL,
  ...
)

dreamer_data_linear_binary(
  n_cohorts,
  doses,
  b1,
  b2,
  link,
  times,
  t_max,
  longitudinal = NULL,
  ...
)

dreamer_data_quad(
  n_cohorts,
  doses,
  b1,
  b2,
  b3,
  sigma,
  times,
  t_max,
  longitudinal = NULL,
  ...
)

dreamer_data_quad_binary(
  n_cohorts,
  doses,
  b1,
  b2,
  b3,
  link,
  times,
  t_max,
  longitudinal = NULL,
  ...
)

dreamer_data_loglinear(
  n_cohorts,
  doses,
  b1,
  b2,
  sigma,
  times,
  t_max,
  longitudinal = NULL,
  ...
)

dreamer_data_loglinear_binary(
  n_cohorts,
  doses,
  b1,
  b2,
  link,
  times,
  t_max,
  longitudinal = NULL,
  ...
)

dreamer_data_logquad(
  n_cohorts,
  doses,
  b1,
  b2,
  b3,
  sigma,
  times,
  t_max,
  longitudinal = NULL,
  ...
)

dreamer_data_logquad_binary(
  n_cohorts,
  doses,
  b1,
  b2,
  b3,
  link,
  times,
  t_max,
  longitudinal = NULL,
  ...
)

dreamer_data_emax(
  n_cohorts,
  doses,
  b1,
  b2,
  b3,
  b4,
  sigma,
  times,
  t_max,
  longitudinal = NULL,
  ...
)

dreamer_data_emax_binary(
  n_cohorts,
  doses,
  b1,
  b2,
  b3,
  b4,
  link,
  times,
  t_max,
  longitudinal = NULL,
  ...
)

dreamer_data_exp(
  n_cohorts,
  doses,
  b1,
  b2,
  b3,
  sigma,
  times,
  t_max,
  longitudinal = NULL,
  ...
)

dreamer_data_exp_binary(
  n_cohorts,
  doses,
  b1,
  b2,
  b3,
  link,
  times,
  t_max,
  longitudinal = NULL,
  ...
)

dreamer_data_beta(
  n_cohorts,
  doses,
  b1,
  b2,
  b3,
  b4,
  scale,
  sigma,
  times,
  t_max,
  longitudinal = NULL,
  ...
)

dreamer_data_beta_binary(
  n_cohorts,
  doses,
  b1,
  b2,
  b3,
  b4,
  scale,
  link,
  times,
  t_max,
  longitudinal = NULL,
  ...
)

dreamer_data_independent(
  n_cohorts,
  doses,
  b1,
  sigma,
  times,
  t_max,
  longitudinal = NULL,
  ...
)

dreamer_data_independent_binary(
  n_cohorts,
  doses,
  b1,
  link,
  times,
  t_max,
  longitudinal = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dreamer_data_+3A_n_cohorts">n_cohorts</code></td>
<td>
<p>a vector listing the size of each cohort.</p>
</td></tr>
<tr><td><code id="dreamer_data_+3A_doses">doses</code></td>
<td>
<p>a vector listing the dose for each cohort.</p>
</td></tr>
<tr><td><code id="dreamer_data_+3A_b1">b1</code>, <code id="dreamer_data_+3A_b2">b2</code>, <code id="dreamer_data_+3A_b3">b3</code>, <code id="dreamer_data_+3A_b4">b4</code></td>
<td>
<p>parameters in the models.  See sections below for
each parameter's interpretation in a given model.</p>
</td></tr>
<tr><td><code id="dreamer_data_+3A_sigma">sigma</code></td>
<td>
<p>standard deviation.</p>
</td></tr>
<tr><td><code id="dreamer_data_+3A_times">times</code></td>
<td>
<p>the times at which data should be simulated if a longitudinal
model is specified.</p>
</td></tr>
<tr><td><code id="dreamer_data_+3A_t_max">t_max</code></td>
<td>
<p>the t_max parameter used in the longitudinal model.</p>
</td></tr>
<tr><td><code id="dreamer_data_+3A_longitudinal">longitudinal</code></td>
<td>
<p>a string indicating the longitudinal model to be used.
Can be &quot;linear&quot;, &quot;itp&quot;, or &quot;idp&quot;.</p>
</td></tr>
<tr><td><code id="dreamer_data_+3A_...">...</code></td>
<td>
<p>additional longitudinal parameters.</p>
</td></tr>
<tr><td><code id="dreamer_data_+3A_link">link</code></td>
<td>
<p>character vector indicating the link function for binary models.</p>
</td></tr>
<tr><td><code id="dreamer_data_+3A_scale">scale</code></td>
<td>
<p>a scaling parameter (fixed, specified by the user) for the
beta models.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of random subjects from the specified model and
parameters.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>dreamer_data_linear()</code>: generate data from linear dose response.
</p>
</li>
<li> <p><code>dreamer_data_linear_binary()</code>: generate data from linear binary dose response.
</p>
</li>
<li> <p><code>dreamer_data_quad()</code>: generate data from quadratic dose response.
</p>
</li>
<li> <p><code>dreamer_data_quad_binary()</code>: generate data from quadratic binary dose response.
</p>
</li>
<li> <p><code>dreamer_data_loglinear()</code>: generate data from log-linear dose response.
</p>
</li>
<li> <p><code>dreamer_data_loglinear_binary()</code>: generate data from binary log-linear dose response.
</p>
</li>
<li> <p><code>dreamer_data_logquad()</code>: generate data from log-quadratic dose response.
</p>
</li>
<li> <p><code>dreamer_data_logquad_binary()</code>: generate data from log-quadratic binary dose
response.
</p>
</li>
<li> <p><code>dreamer_data_emax()</code>: generate data from EMAX dose response.
</p>
</li>
<li> <p><code>dreamer_data_emax_binary()</code>: generate data from EMAX binary dose response.
</p>
</li>
<li> <p><code>dreamer_data_exp()</code>: generate data from exponential dose response.
</p>
</li>
<li> <p><code>dreamer_data_exp_binary()</code>: generate data from exponential binary dose response.
</p>
</li>
<li> <p><code>dreamer_data_beta()</code>: generate data from Beta dose response.
</p>
</li>
<li> <p><code>dreamer_data_beta_binary()</code>: generate data from binary Beta dose response.
</p>
</li>
<li> <p><code>dreamer_data_independent()</code>: generate data from an independent dose response.
</p>
</li>
<li> <p><code>dreamer_data_independent_binary()</code>: generate data from an independent dose response.
</p>
</li></ul>


<h3>Linear</h3>

<p style="text-align: center;"><code class="reqn">y \sim N(f(d), \sigma^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">f(d) = b_1 + b_2 * d</code>
</p>

<p style="text-align: center;"><code class="reqn">b_1 \sim N(mu_b1, sigma_b1 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_2 \sim N(mu_b2, sigma_b2 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">1 / \sigma^2 \sim Gamma(shape, rate)</code>
</p>



<h3>Quadratic</h3>

<p style="text-align: center;"><code class="reqn">y \sim N(f(d), \sigma^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">f(d) = b_1 + b_2 * d + b_3 * d^2</code>
</p>

<p style="text-align: center;"><code class="reqn">b_1 \sim N(mu_b1, sigma_b1 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_2 \sim N(mu_b2, sigma_b2 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_3 \sim N(mu_b3, sigma_b3 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">1 / \sigma^2 \sim Gamma(shape, rate)</code>
</p>



<h3>Log-linear</h3>

<p style="text-align: center;"><code class="reqn">y \sim N(f(d), \sigma^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">f(d) = b_1 + b_2 * log(d + 1)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_1 \sim N(mu_b1, sigma_b1 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_2 \sim N(mu_b2, sigma_b2 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">1 / \sigma^2 \sim Gamma(shape, rate)</code>
</p>



<h3>Log-quadratic</h3>

<p style="text-align: center;"><code class="reqn">y \sim N(f(d), \sigma^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">f(d) = b_1 + b_2 * log(d + 1) + b_3 * log(d + 1)^2</code>
</p>

<p style="text-align: center;"><code class="reqn">b_1 \sim N(mu_b1, sigma_b1 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_2 \sim N(mu_b2, sigma_b2 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_3 \sim N(mu_b3, sigma_b3 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">1 / \sigma^2 \sim Gamma(shape, rate)</code>
</p>



<h3>EMAX</h3>

<p style="text-align: center;"><code class="reqn">y \sim N(f(d), \sigma^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">f(d) = b_1 + (b_2 - b_1) * d ^ b_4 / (exp(b_3 * b_4) + d ^ b_4)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_1 \sim N(mu_b1, sigma_b1 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_2 \sim N(mu_b2, sigma_b2 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_3 \sim N(mu_b3, sigma_b3 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_4 \sim N(mu_b4, sigma_b4 ^ 2), (Truncated above 0)</code>
</p>

<p style="text-align: center;"><code class="reqn">1 / \sigma^2 \sim Gamma(shape, rate)</code>
</p>

<p>Here, <code class="reqn">b_1</code> is the placebo effect (dose = 0), <code class="reqn">b_2</code> is the
maximum treatment effect, <code class="reqn">b_3</code> is the <code class="reqn">log(ED50)</code>, and
<code class="reqn">b_4</code> is the hill or rate parameter.
</p>


<h3>Exponential</h3>

<p style="text-align: center;"><code class="reqn">y \sim N(f(d), \sigma^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">f(d) = b_1 + b_2 * (1 - exp(- b_3 * d))</code>
</p>

<p style="text-align: center;"><code class="reqn">b_1 \sim N(mu_b1, sigma_b1 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_2 \sim N(mu_b2, sigma_b2 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_3 \sim N(mu_b3, sigma_b3 ^ 2), (truncated to be positive)</code>
</p>

<p style="text-align: center;"><code class="reqn">1 / \sigma^2 \sim Gamma(shape, rate)</code>
</p>



<h3>Linear Binary</h3>

<p style="text-align: center;"><code class="reqn">y \sim Binomial(n, f(d))</code>
</p>

<p style="text-align: center;"><code class="reqn">link(f(d)) = b_1 + b_2 * d</code>
</p>

<p style="text-align: center;"><code class="reqn">b_1 \sim N(mu_b1, sigma_b1 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_2 \sim N(mu_b2, sigma_b2 ^ 2)</code>
</p>



<h3>Quadratic Binary</h3>

<p style="text-align: center;"><code class="reqn">y \sim Binomial(n, f(d))</code>
</p>

<p style="text-align: center;"><code class="reqn">link(f(d)) = b_1 + b_2 * d + b_3 * d^2</code>
</p>

<p style="text-align: center;"><code class="reqn">b_1 \sim N(mu_b1, sigma_b1 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_2 \sim N(mu_b2, sigma_b2 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_3 \sim N(mu_b3, sigma_b3 ^ 2)</code>
</p>



<h3>Log-linear Binary</h3>

<p style="text-align: center;"><code class="reqn">y \sim Binomial(n, f(d))</code>
</p>

<p style="text-align: center;"><code class="reqn">link(f(d)) = b_1 + b_2 * log(d + 1)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_1 \sim N(mu_b1, sigma_b1 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_2 \sim N(mu_b2, sigma_b2 ^ 2)</code>
</p>



<h3>Log-quadratic Binary</h3>

<p style="text-align: center;"><code class="reqn">y \sim Binomial(n, f(d))</code>
</p>

<p style="text-align: center;"><code class="reqn">link(f(d)) = b_1 + b_2 * log(d + 1) + b_3 * log(d + 1)^2</code>
</p>

<p style="text-align: center;"><code class="reqn">b_1 \sim N(mu_b1, sigma_b1 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_2 \sim N(mu_b2, sigma_b2 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_3 \sim N(mu_b3, sigma_b3 ^ 2)</code>
</p>



<h3>EMAX Binary</h3>

<p style="text-align: center;"><code class="reqn">y \sim Binomial(n, f(d))</code>
</p>

<p style="text-align: center;"><code class="reqn">link(f(d)) = b_1 + (b_2 - b_1) * d ^ b_4 /
    (exp(b_3 * b_4) + d ^ b_4)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_1 \sim N(mu_b1, sigma_b1 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_2 \sim N(mu_b2, sigma_b2 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_3 \sim N(mu_b3, sigma_b3 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_4 \sim N(mu_b4, sigma_b4 ^ 2), (Truncated above 0)</code>
</p>

<p>Here, on the <code class="reqn">link(f(d))</code> scale,
<code class="reqn">b_1</code> is the placebo effect (dose = 0), <code class="reqn">b_2</code> is the
maximum treatment effect, <code class="reqn">b_3</code> is the <code class="reqn">log(ED50)</code>, and
<code class="reqn">b_4</code> is the hill or rate parameter.
</p>


<h3>Exponential Binary</h3>

<p style="text-align: center;"><code class="reqn">y \sim Binomial(n, f(d))</code>
</p>

<p style="text-align: center;"><code class="reqn">link(f(d)) = b_1 + b_2 * (exp(b_3 * d) - 1)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_1 \sim N(mu_b1, sigma_b1 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_2 \sim N(mu_b2, sigma_b2 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_3 \sim N(mu_b3, sigma_b3 ^ 2), (Truncated below 0)</code>
</p>



<h3>Independent</h3>

<p style="text-align: center;"><code class="reqn">y \sim N(f(d), \sigma^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">f(d) = b_{1d}</code>
</p>

<p style="text-align: center;"><code class="reqn">b_{1d} \sim N(mu_b1[d], sigma_b1[d] ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">1 / \sigma^2 \sim Gamma(shape, rate)</code>
</p>



<h3>Independent Binary</h3>

<p style="text-align: center;"><code class="reqn">y \sim Binomial(n, f(d))</code>
</p>

<p style="text-align: center;"><code class="reqn">link(f(d)) = b_{1d}</code>
</p>

<p style="text-align: center;"><code class="reqn">b_{1d} \sim N(mu_b1[d], sigma_b1[d]) ^ 2</code>
</p>



<h3>Longitudinal Linear</h3>

<p>Let <code class="reqn">f(d)</code> be a dose response model.  The expected value of the
response, y, is:
</p>
<p style="text-align: center;"><code class="reqn">E(y) = g(d, t)</code>
</p>

<p style="text-align: center;"><code class="reqn">g(d, t) = a + (t / t_max) * f(d)</code>
</p>

<p style="text-align: center;"><code class="reqn">a \sim N(mu_a, sigma_a)</code>
</p>



<h3>Longitudinal ITP</h3>

<p>Let <code class="reqn">f(d)</code> be a dose response model.  The expected value of the
response, y, is:
</p>
<p style="text-align: center;"><code class="reqn">E(y) = g(d, t)</code>
</p>

<p style="text-align: center;"><code class="reqn">g(d, t) = a + f(d) * ((1 - exp(- c1 * t))/(1 - exp(- c1 * t_max)))</code>
</p>

<p style="text-align: center;"><code class="reqn">a \sim N(mu_a, sigma_a)</code>
</p>

<p style="text-align: center;"><code class="reqn">c1 \sim Uniform(a_c1, b_c1)</code>
</p>



<h3>Longitudinal IDP</h3>

<p>Increasing-Decreasing-Plateau (IDP).
</p>
<p>Let <code class="reqn">f(d)</code> be a dose response model.  The expected value of the
response, y, is:
</p>
<p style="text-align: center;"><code class="reqn">E(y) = g(d, t)</code>
</p>

<p style="text-align: center;"><code class="reqn">g(d, t) = a + f(d) * (((1 - exp(- c1 * t))/(1 - exp(- c1 * d1))) *
    I(t &lt; d1) + (1 - gam * ((1 - exp(- c2 * (t - d1))) /
    (1 - exp(- c2 * (d2 - d1))))) *
    I(d1 &lt;= t &lt;= d2) + (1 - gam) * I(t &gt; d2))</code>
</p>

<p style="text-align: center;"><code class="reqn">a \sim N(mu_a, sigma_a)</code>
</p>

<p style="text-align: center;"><code class="reqn">c1 \sim Uniform(a_c1, b_c1)</code>
</p>

<p style="text-align: center;"><code class="reqn">c2 \sim Uniform(a_c2, b_c2)</code>
</p>

<p style="text-align: center;"><code class="reqn">d1 \sim Uniform(0, t_max)</code>
</p>

<p style="text-align: center;"><code class="reqn">d2 \sim Uniform(d1, t_max)</code>
</p>

<p style="text-align: center;"><code class="reqn">gam \sim Uniform(0, 1)</code>
</p>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(888)
data &lt;- dreamer_data_linear(
  n_cohorts = c(20, 20, 20),
  dose = c(0, 3, 10),
  b1 = 1,
  b2 = 3,
  sigma = 5
)

head(data)

plot(data$dose, data$response)
abline(a = 1, b = 3)

# longitudinal data
set.seed(889)
data_long &lt;- dreamer_data_linear(
  n_cohorts = c(10, 10, 10, 10), # number of subjects in each cohort
  doses = c(.25, .5, .75, 1.5), # dose administered to each cohort
  b1 = 0, # intercept
  b2 = 2, # slope
  sigma = .5, # standard deviation,
  longitudinal = "itp",
  times = c(0, 12, 24, 52),
  t_max = 52, # maximum time
  a = .5,
  c1 = .1
)

## Not run: 
  ggplot(data_long, aes(time, response, group = dose, color = factor(dose))) +
    geom_point()

## End(Not run)
</code></pre>

<hr>
<h2 id='dreamer_mcmc'>Bayesian Model Averaging of Dose Response Models</h2><span id='topic+dreamer_mcmc'></span>

<h3>Description</h3>

<p>This function performs Bayesian model averaging with a selection
of dose response models.  See <a href="#topic+model">model</a> for all possible
models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dreamer_mcmc(
  data,
  ...,
  n_adapt = 1000,
  n_burn = 1000,
  n_iter = 10000,
  n_chains = 4,
  silent = FALSE,
  convergence_warn = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dreamer_mcmc_+3A_data">data</code></td>
<td>
<p>a dataframe with column names of &quot;dose&quot; and &quot;response&quot; for
individual patient data.  Optional columns &quot;n&quot; and &quot;sample_var&quot; can
be specified if aggregate data is supplied, but it is recommended that
patient-level data be supplied where possible for continuous models, as the
posterior weights differ if aggregated data is used.
For aggregated continuous
data, &quot;response&quot; should be the average of &quot;n&quot; subjects with a sample
variance of &quot;sample_var&quot;.  For aggregated binary data, &quot;response&quot; should
be the number of successes, &quot;n&quot; should be the total number of subjects
(the &quot;sample_var&quot; column is irrelevant in binary cases and is ignored).</p>
</td></tr>
<tr><td><code id="dreamer_mcmc_+3A_...">...</code></td>
<td>
<p>model definitions created using the model creation functions
in <a href="#topic+model">model</a>.  If arguments are named, the names are
retained in the return values.</p>
</td></tr>
<tr><td><code id="dreamer_mcmc_+3A_n_adapt">n_adapt</code></td>
<td>
<p>the number of MCMC iterations to tune the MCMC algorithm.</p>
</td></tr>
<tr><td><code id="dreamer_mcmc_+3A_n_burn">n_burn</code></td>
<td>
<p>the number of burn-in MCMC samples.</p>
</td></tr>
<tr><td><code id="dreamer_mcmc_+3A_n_iter">n_iter</code></td>
<td>
<p>the number of MCMC samples to collect after tuning and burn-in.</p>
</td></tr>
<tr><td><code id="dreamer_mcmc_+3A_n_chains">n_chains</code></td>
<td>
<p>the number of separate, independent, MCMC chains to run.</p>
</td></tr>
<tr><td><code id="dreamer_mcmc_+3A_silent">silent</code></td>
<td>
<p>logical indicating if MCMC progress bars should be suppressed.</p>
</td></tr>
<tr><td><code id="dreamer_mcmc_+3A_convergence_warn">convergence_warn</code></td>
<td>
<p>logical (default <code>TRUE</code>) indicating if the
Gelman-Rubin diagnostics should be run to detect convergence issues.
Warnings are thrown if the upper bound of the Gelman-Rubin statistic
is greater than 1.1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Bayesian model averaging approach uses data, multiple models,
priors on each model's parameters, and a prior weight for each model.
Using these inputs, each model is fit independently, and the output from
the models is used to calculate posterior weights for each model.
See Gould (2018) for details.
</p>


<h3>Value</h3>

<p>A named list with S3 class &quot;dreamer_bma&quot; and &quot;dreamer&quot;.  The list
contains the following fields:
</p>

<ul>
<li><p> doses: a vector of the unique ordered doses in the data.
</p>
</li>
<li><p> times: a vector of the unique ordered times in the data.
</p>
</li>
<li><p> w_prior: a named vector with the prior probabilities of each model.
</p>
</li>
<li><p> w_post: a named vector with the posterior probabilities of each model.
</p>
</li>
<li><p> The individual MCMC fits for each model.
</p>
</li></ul>



<h3>References</h3>

<p>Gould, A. L. (2019).  BMA-Mod: A Bayesian model averaging strategy for
determining dose-response relationships in the presence of model
uncertainty. Biometrical Journal, 61(5), 1141-1159.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(888)
data &lt;- dreamer_data_linear(
  n_cohorts = c(20, 20, 20),
  dose = c(0, 3, 10),
  b1 = 1,
  b2 = 3,
  sigma = 5
)

# Bayesian model averaging
output &lt;- dreamer_mcmc(
  data = data,
  n_adapt = 1e3,
  n_burn = 1e2,
  n_iter = 1e3,
  n_chains = 2,
  silent = TRUE,
  mod_linear = model_linear(
    mu_b1 = 0,
    sigma_b1 = 1,
    mu_b2 = 0,
    sigma_b2 = 1,
    shape = 1,
    rate = .001,
    w_prior = 1 / 2
  ),
  mod_quad = model_quad(
    mu_b1 = 0,
    sigma_b1 = 1,
    mu_b2 = 0,
    sigma_b2 = 1,
    mu_b3 = 0,
    sigma_b3 = 1,
    shape = 1,
    rate = .001,
    w_prior = 1 / 2
  )
)
# posterior weights
output$w_post
# plot posterior dose response
plot(output)

# LONGITUDINAL
library(ggplot2)
set.seed(889)
data_long &lt;- dreamer_data_linear(
  n_cohorts = c(10, 10, 10, 10), # number of subjects in each cohort
  doses = c(.25, .5, .75, 1.5), # dose administered to each cohort
  b1 = 0, # intercept
  b2 = 2, # slope
  sigma = .5, # standard deviation,
  longitudinal = "itp",
  times = c(0, 12, 24, 52),
  t_max = 52, # maximum time
  a = .5,
  c1 = .1
)

## Not run: 
ggplot(data_long, aes(time, response, group = dose, color = factor(dose))) +
   geom_point()

## End(Not run)

output_long &lt;- dreamer_mcmc(
   data = data_long,
   n_adapt = 1e3,
   n_burn = 1e2,
   n_iter = 1e3,
   n_chains = 2,
   silent = TRUE, # make rjags be quiet,
   mod_linear = model_linear(
      mu_b1 = 0,
      sigma_b1 = 1,
      mu_b2 = 0,
      sigma_b2 = 1,
      shape = 1,
      rate = .001,
      w_prior = 1 / 2, # prior probability of the model
      longitudinal = model_longitudinal_itp(
         mu_a = 0,
         sigma_a = 1,
         a_c1 = 0,
         b_c1 = 1,
         t_max = 52
      )
   ),
   mod_quad = model_quad(
      mu_b1 = 0,
      sigma_b1 = 1,
      mu_b2 = 0,
      sigma_b2 = 1,
      mu_b3 = 0,
      sigma_b3 = 1,
      shape = 1,
      rate = .001,
      w_prior = 1 / 2,
      longitudinal = model_longitudinal_linear(
         mu_a = 0,
         sigma_a = 1,
         t_max = 52
      )
   )
)

## Not run: 
# plot longitudinal dose-response profile
plot(output_long, data = data_long)
plot(output_long$mod_quad, data = data_long) # single model

# plot dose response at final timepoint
plot(output_long, data = data_long, times = 52)
plot(output_long$mod_quad, data = data_long, times = 52) # single model

## End(Not run)
</code></pre>

<hr>
<h2 id='dreamer_plot_prior'>Plot Prior</h2><span id='topic+dreamer_plot_prior'></span>

<h3>Description</h3>

<p>Plot the prior over the dose range.  This is intended to
help the user choose appropriate priors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dreamer_plot_prior(
  n_samples = 10000,
  probs = c(0.025, 0.975),
  doses,
  n_chains = 1,
  ...,
  times = NULL,
  plot_draws = FALSE,
  alpha = 0.2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dreamer_plot_prior_+3A_n_samples">n_samples</code></td>
<td>
<p>the number of MCMC samples per MCMC chain used to generate
the plot.</p>
</td></tr>
<tr><td><code id="dreamer_plot_prior_+3A_probs">probs</code></td>
<td>
<p>A vector of length 2 indicating the lower and upper percentiles
to plot.  Not applicable when <code>plot_draws = TRUE</code>.</p>
</td></tr>
<tr><td><code id="dreamer_plot_prior_+3A_doses">doses</code></td>
<td>
<p>a vector of doses at which to evaluate and interpolate
between.</p>
</td></tr>
<tr><td><code id="dreamer_plot_prior_+3A_n_chains">n_chains</code></td>
<td>
<p>the number of MCMC chains.</p>
</td></tr>
<tr><td><code id="dreamer_plot_prior_+3A_...">...</code></td>
<td>
<p>model objects.  See <code><a href="#topic+model">model</a></code> and
examples below.</p>
</td></tr>
<tr><td><code id="dreamer_plot_prior_+3A_times">times</code></td>
<td>
<p>a vector of times at which to plot the prior.</p>
</td></tr>
<tr><td><code id="dreamer_plot_prior_+3A_plot_draws">plot_draws</code></td>
<td>
<p>if <code>TRUE</code>, the individual draws from the prior are plotted.
If <code>FALSE</code>, only the prior mean and quantiles are drawn.</p>
</td></tr>
<tr><td><code id="dreamer_plot_prior_+3A_alpha">alpha</code></td>
<td>
<p>the transparency setting for the prior draws in (0, 1].
Only applies if <code>plot_draws = TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The ggplot object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Plot prior for one model
set.seed(8111)
dreamer_plot_prior(
 doses = c(0, 2.5, 5),
 mod_quad_binary = model_quad_binary(
   mu_b1 = -.5,
   sigma_b1 = .2,
   mu_b2 = -.5,
   sigma_b2 = .2,
   mu_b3 = .5,
   sigma_b3 = .1,
   link = "logit",
   w_prior = 1
 )
)

# plot individual draws
dreamer_plot_prior(
 doses = seq(from = 0, to = 5, length.out = 50),
 n_samples = 100,
 plot_draws = TRUE,
 mod_quad_binary = model_quad_binary(
   mu_b1 = -.5,
   sigma_b1 = .2,
   mu_b2 = -.5,
   sigma_b2 = .2,
   mu_b3 = .5,
   sigma_b3 = .1,
   link = "logit",
   w_prior = 1
 )
)

# plot prior from mixture of models
dreamer_plot_prior(
 doses = c(0, 2.5, 5),
 mod_linear_binary = model_linear_binary(
   mu_b1 = -1,
   sigma_b1 = .1,
   mu_b2 = 1,
   sigma_b2 = .1,
   link = "logit",
   w_prior = .75
 ),
 mod_quad_binary = model_quad_binary(
   mu_b1 = -.5,
   sigma_b1 = .2,
   mu_b2 = -.5,
   sigma_b2 = .2,
   mu_b3 = .5,
   sigma_b3 = .1,
   link = "logit",
   w_prior = .25
 )
)
</code></pre>

<hr>
<h2 id='dreamerplot'>Posterior Plot of Bayesian Model Averaging</h2><span id='topic+dreamerplot'></span><span id='topic+plot.dreamer_mcmc'></span>

<h3>Description</h3>

<p>Plots the posterior mean and quantiles over the dose range and
plots error bars at the observed doses. If the <code>data</code> argument is
specified, the observed means at each dose are also plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dreamer_mcmc'
plot(
  x,
  doses = attr(x, "doses"),
  times = attr(x, "times"),
  probs = c(0.025, 0.975),
  data = NULL,
  n_smooth = 50,
  predictive = 0,
  width = bar_width(doses),
  reference_dose = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dreamerplot_+3A_x">x</code></td>
<td>
<p>output from a call to <code><a href="#topic+dreamer_mcmc">dreamer_mcmc</a></code>.</p>
</td></tr>
<tr><td><code id="dreamerplot_+3A_doses">doses</code></td>
<td>
<p>a vector of doses at which to plot the dose response curve.</p>
</td></tr>
<tr><td><code id="dreamerplot_+3A_times">times</code></td>
<td>
<p>a vector of the times at which to plot the posterior (for
longitudinal models only).</p>
</td></tr>
<tr><td><code id="dreamerplot_+3A_probs">probs</code></td>
<td>
<p>quantiles of the posterior to be calculated.</p>
</td></tr>
<tr><td><code id="dreamerplot_+3A_data">data</code></td>
<td>
<p>a dataframe with column names of &quot;dose&quot; and &quot;response&quot; for
individual patient data.  Optional columns &quot;n&quot; and &quot;sample_var&quot; can
be specified if aggregate data is supplied, but it is recommended that
patient-level data be supplied where possible for continuous models, as the
posterior weights differ if aggregated data is used.
For aggregated continuous
data, &quot;response&quot; should be the average of &quot;n&quot; subjects with a sample
variance of &quot;sample_var&quot;.  For aggregated binary data, &quot;response&quot; should
be the number of successes, &quot;n&quot; should be the total number of subjects
(the &quot;sample_var&quot; column is irrelevant in binary cases and is ignored).</p>
</td></tr>
<tr><td><code id="dreamerplot_+3A_n_smooth">n_smooth</code></td>
<td>
<p>the number of points to calculate the smooth dose response
interpolation.  Must be sufficiently high to accurately depict the
dose response curve.</p>
</td></tr>
<tr><td><code id="dreamerplot_+3A_predictive">predictive</code></td>
<td>
<p>the size of sample for which to plot posterior predictive
intervals for the mean.</p>
</td></tr>
<tr><td><code id="dreamerplot_+3A_width">width</code></td>
<td>
<p>the width of the error bars.</p>
</td></tr>
<tr><td><code id="dreamerplot_+3A_reference_dose">reference_dose</code></td>
<td>
<p>the dose at which to adjust the posterior plot.
Specifying
a dose returns the plot of pr(trt_dose - trt_reference_dose | data).</p>
</td></tr>
<tr><td><code id="dreamerplot_+3A_...">...</code></td>
<td>
<p>model definitions created using the model creation functions
in <a href="#topic+model">model</a>.  If arguments are named, the names are
retained in the return values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the ggplot object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(888)
data &lt;- dreamer_data_linear(
  n_cohorts = c(20, 20, 20),
  dose = c(0, 3, 10),
  b1 = 1,
  b2 = 3,
  sigma = 5
)

# Bayesian model averaging
output &lt;- dreamer_mcmc(
 data = data,
 n_adapt = 1e3,
 n_burn = 1e3,
 n_iter = 1e4,
 n_chains = 2,
 silent = FALSE,
 mod_linear = model_linear(
   mu_b1 = 0,
   sigma_b1 = 1,
   mu_b2 = 0,
   sigma_b2 = 1,
   shape = 1,
   rate = .001,
   w_prior = 1 / 2
 ),
 mod_quad = model_quad(
   mu_b1 = 0,
   sigma_b1 = 1,
   mu_b2 = 0,
   sigma_b2 = 1,
   mu_b3 = 0,
   sigma_b3 = 1,
   shape = 1,
   rate = .001,
   w_prior = 1 / 2
 )
)

plot(output)

## Not run: 
# with data
plot(output, data = data)

# predictive distribution
plot(output, data = data, predictive = 1)

# single model
plot(output$mod_linear)

## End(Not run)
</code></pre>

<hr>
<h2 id='model'>Model Creation</h2><span id='topic+model'></span><span id='topic+model_linear'></span><span id='topic+model_quad'></span><span id='topic+model_loglinear'></span><span id='topic+model_logquad'></span><span id='topic+model_emax'></span><span id='topic+model_exp'></span><span id='topic+model_beta'></span><span id='topic+model_independent'></span><span id='topic+model_linear_binary'></span><span id='topic+model_quad_binary'></span><span id='topic+model_loglinear_binary'></span><span id='topic+model_logquad_binary'></span><span id='topic+model_emax_binary'></span><span id='topic+model_exp_binary'></span><span id='topic+model_beta_binary'></span><span id='topic+model_independent_binary'></span>

<h3>Description</h3>

<p>Functions which set the hyperparameters, seeds, and prior
weight for each model to be used in Bayesian model averaging
via <code>dreamer_mcmc()</code>.
</p>
<p>See each function's section below for the model's details.  In the
following, <code class="reqn">y</code> denotes the response variable and <code class="reqn">d</code> represents
the dose.
</p>
<p>For the longitudinal specifications, see documentation on
<code><a href="#topic+model_longitudinal">model_longitudinal</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_linear(
  mu_b1,
  sigma_b1,
  mu_b2,
  sigma_b2,
  shape,
  rate,
  w_prior = 1,
  longitudinal = NULL
)

model_quad(
  mu_b1,
  sigma_b1,
  mu_b2,
  sigma_b2,
  mu_b3,
  sigma_b3,
  shape,
  rate,
  w_prior = 1,
  longitudinal = NULL
)

model_loglinear(
  mu_b1,
  sigma_b1,
  mu_b2,
  sigma_b2,
  shape,
  rate,
  w_prior = 1,
  longitudinal = NULL
)

model_logquad(
  mu_b1,
  sigma_b1,
  mu_b2,
  sigma_b2,
  mu_b3,
  sigma_b3,
  shape,
  rate,
  w_prior = 1,
  longitudinal = NULL
)

model_emax(
  mu_b1,
  sigma_b1,
  mu_b2,
  sigma_b2,
  mu_b3,
  sigma_b3,
  mu_b4,
  sigma_b4,
  shape,
  rate,
  w_prior = 1,
  longitudinal = NULL
)

model_exp(
  mu_b1,
  sigma_b1,
  mu_b2,
  sigma_b2,
  mu_b3,
  sigma_b3,
  shape,
  rate,
  w_prior = 1,
  longitudinal = NULL
)

model_beta(
  mu_b1,
  sigma_b1,
  mu_b2,
  sigma_b2,
  mu_b3,
  sigma_b3,
  mu_b4,
  sigma_b4,
  shape,
  rate,
  scale = NULL,
  w_prior = 1,
  longitudinal = NULL
)

model_independent(
  mu_b1,
  sigma_b1,
  shape,
  rate,
  doses = NULL,
  w_prior = 1,
  longitudinal = NULL
)

model_linear_binary(
  mu_b1,
  sigma_b1,
  mu_b2,
  sigma_b2,
  link,
  w_prior = 1,
  longitudinal = NULL
)

model_quad_binary(
  mu_b1,
  sigma_b1,
  mu_b2,
  sigma_b2,
  mu_b3,
  sigma_b3,
  link,
  w_prior = 1,
  longitudinal = NULL
)

model_loglinear_binary(
  mu_b1,
  sigma_b1,
  mu_b2,
  sigma_b2,
  link,
  w_prior = 1,
  longitudinal = NULL
)

model_logquad_binary(
  mu_b1,
  sigma_b1,
  mu_b2,
  sigma_b2,
  mu_b3,
  sigma_b3,
  link,
  w_prior = 1,
  longitudinal = NULL
)

model_emax_binary(
  mu_b1,
  sigma_b1,
  mu_b2,
  sigma_b2,
  mu_b3,
  sigma_b3,
  mu_b4,
  sigma_b4,
  link,
  w_prior = 1,
  longitudinal = NULL
)

model_exp_binary(
  mu_b1,
  sigma_b1,
  mu_b2,
  sigma_b2,
  mu_b3,
  sigma_b3,
  link,
  w_prior = 1,
  longitudinal = NULL
)

model_beta_binary(
  mu_b1,
  sigma_b1,
  mu_b2,
  sigma_b2,
  mu_b3,
  sigma_b3,
  mu_b4,
  sigma_b4,
  scale = NULL,
  link,
  w_prior = 1,
  longitudinal = NULL
)

model_independent_binary(
  mu_b1,
  sigma_b1,
  doses = NULL,
  link,
  w_prior = 1,
  longitudinal = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_+3A_mu_b1">mu_b1</code>, <code id="model_+3A_sigma_b1">sigma_b1</code>, <code id="model_+3A_mu_b2">mu_b2</code>, <code id="model_+3A_sigma_b2">sigma_b2</code>, <code id="model_+3A_mu_b3">mu_b3</code>, <code id="model_+3A_sigma_b3">sigma_b3</code>, <code id="model_+3A_mu_b4">mu_b4</code>, <code id="model_+3A_sigma_b4">sigma_b4</code>, <code id="model_+3A_shape">shape</code>, <code id="model_+3A_rate">rate</code></td>
<td>
<p>models parameters.  See sections below for interpretation in
specific models.</p>
</td></tr>
<tr><td><code id="model_+3A_w_prior">w_prior</code></td>
<td>
<p>a scalar between 0 and 1 indicating the prior weight of the
model.</p>
</td></tr>
<tr><td><code id="model_+3A_longitudinal">longitudinal</code></td>
<td>
<p>output from a call to one of the model_longitudinal_*()
functions.  This is used to specify a longitudinal dose-response model.</p>
</td></tr>
<tr><td><code id="model_+3A_scale">scale</code></td>
<td>
<p>a scale parameter in the Beta model. Default is 1.2 * max(dose).</p>
</td></tr>
<tr><td><code id="model_+3A_doses">doses</code></td>
<td>
<p>the doses in the dataset to be modeled.  The order of the
doses corresponds to the order in which the priors are specified in
<code>mu_b1</code> and <code>sigma_b1</code>.</p>
</td></tr>
<tr><td><code id="model_+3A_link">link</code></td>
<td>
<p>a character string of either &quot;logit&quot; or &quot;probit&quot; indicating
the link function for binary model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of the arguments in the function call.  The list has
S3 classes assigned which are used internally within <code>dreamer_mcmc()</code>.
</p>


<h3>Linear</h3>

<p style="text-align: center;"><code class="reqn">y \sim N(f(d), \sigma^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">f(d) = b_1 + b_2 * d</code>
</p>

<p style="text-align: center;"><code class="reqn">b_1 \sim N(mu_b1, sigma_b1 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_2 \sim N(mu_b2, sigma_b2 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">1 / \sigma^2 \sim Gamma(shape, rate)</code>
</p>



<h3>Quadratic</h3>

<p style="text-align: center;"><code class="reqn">y \sim N(f(d), \sigma^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">f(d) = b_1 + b_2 * d + b_3 * d^2</code>
</p>

<p style="text-align: center;"><code class="reqn">b_1 \sim N(mu_b1, sigma_b1 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_2 \sim N(mu_b2, sigma_b2 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_3 \sim N(mu_b3, sigma_b3 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">1 / \sigma^2 \sim Gamma(shape, rate)</code>
</p>



<h3>Log-linear</h3>

<p style="text-align: center;"><code class="reqn">y \sim N(f(d), \sigma^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">f(d) = b_1 + b_2 * log(d + 1)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_1 \sim N(mu_b1, sigma_b1 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_2 \sim N(mu_b2, sigma_b2 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">1 / \sigma^2 \sim Gamma(shape, rate)</code>
</p>



<h3>Log-quadratic</h3>

<p style="text-align: center;"><code class="reqn">y \sim N(f(d), \sigma^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">f(d) = b_1 + b_2 * log(d + 1) + b_3 * log(d + 1)^2</code>
</p>

<p style="text-align: center;"><code class="reqn">b_1 \sim N(mu_b1, sigma_b1 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_2 \sim N(mu_b2, sigma_b2 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_3 \sim N(mu_b3, sigma_b3 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">1 / \sigma^2 \sim Gamma(shape, rate)</code>
</p>



<h3>EMAX</h3>

<p style="text-align: center;"><code class="reqn">y \sim N(f(d), \sigma^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">f(d) = b_1 + (b_2 - b_1) * d ^ b_4 / (exp(b_3 * b_4) + d ^ b_4)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_1 \sim N(mu_b1, sigma_b1 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_2 \sim N(mu_b2, sigma_b2 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_3 \sim N(mu_b3, sigma_b3 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_4 \sim N(mu_b4, sigma_b4 ^ 2), (Truncated above 0)</code>
</p>

<p style="text-align: center;"><code class="reqn">1 / \sigma^2 \sim Gamma(shape, rate)</code>
</p>

<p>Here, <code class="reqn">b_1</code> is the placebo effect (dose = 0), <code class="reqn">b_2</code> is the
maximum treatment effect, <code class="reqn">b_3</code> is the <code class="reqn">log(ED50)</code>, and
<code class="reqn">b_4</code> is the hill or rate parameter.
</p>


<h3>Exponential</h3>

<p style="text-align: center;"><code class="reqn">y \sim N(f(d), \sigma^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">f(d) = b_1 + b_2 * (1 - exp(- b_3 * d))</code>
</p>

<p style="text-align: center;"><code class="reqn">b_1 \sim N(mu_b1, sigma_b1 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_2 \sim N(mu_b2, sigma_b2 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_3 \sim N(mu_b3, sigma_b3 ^ 2), (truncated to be positive)</code>
</p>

<p style="text-align: center;"><code class="reqn">1 / \sigma^2 \sim Gamma(shape, rate)</code>
</p>



<h3>Beta</h3>

<p style="text-align: center;"><code class="reqn">y \sim N(f(d), \sigma^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">f(d) = b_1 + b_2 * ((b3 + b4) ^ (b3 + b4)) /
    (b3 ^ b3 * b4 ^ b4) * (d / scale) ^ b3 *
    (1 - d / scale) ^ b4</code>
</p>

<p style="text-align: center;"><code class="reqn">b_1 \sim N(mu_b1, sigma_b1 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_2 \sim N(mu_b2, sigma_b2 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_3 \sim N(mu_b3, sigma_b3 ^ 2), Truncated above 0</code>
</p>

<p style="text-align: center;"><code class="reqn">b_4 \sim N(mu_b4, sigma_b4 ^ 2), Truncated above 0</code>
</p>

<p style="text-align: center;"><code class="reqn">1 / \sigma^2 \sim Gamma(shape, rate)</code>
</p>

<p>Note that <code class="reqn">scale</code> is a hyperparameter specified by the
user.
</p>


<h3>Independent</h3>

<p style="text-align: center;"><code class="reqn">y \sim N(f(d), \sigma^2)</code>
</p>

<p style="text-align: center;"><code class="reqn">f(d) = b_{1d}</code>
</p>

<p style="text-align: center;"><code class="reqn">b_{1d} \sim N(mu_b1[d], sigma_b1[d] ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">1 / \sigma^2 \sim Gamma(shape, rate)</code>
</p>



<h3>Independent Details</h3>

<p>The independent model models the effect of each dose independently.
Vectors can be supplied to <code>mu_b1</code> and <code>sigma_b1</code> to set a different
prior for each dose in the order the doses are supplied to <code>doses</code>.
If scalars are supplied to <code>mu_b1</code> and <code>sigma_b1</code>, then the same prior
is used for each dose, and the <code>doses</code> argument is not needed.
</p>


<h3>Linear Binary</h3>

<p style="text-align: center;"><code class="reqn">y \sim Binomial(n, f(d))</code>
</p>

<p style="text-align: center;"><code class="reqn">link(f(d)) = b_1 + b_2 * d</code>
</p>

<p style="text-align: center;"><code class="reqn">b_1 \sim N(mu_b1, sigma_b1 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_2 \sim N(mu_b2, sigma_b2 ^ 2)</code>
</p>



<h3>Quadratic Binary</h3>

<p style="text-align: center;"><code class="reqn">y \sim Binomial(n, f(d))</code>
</p>

<p style="text-align: center;"><code class="reqn">link(f(d)) = b_1 + b_2 * d + b_3 * d^2</code>
</p>

<p style="text-align: center;"><code class="reqn">b_1 \sim N(mu_b1, sigma_b1 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_2 \sim N(mu_b2, sigma_b2 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_3 \sim N(mu_b3, sigma_b3 ^ 2)</code>
</p>



<h3>Log-linear Binary</h3>

<p style="text-align: center;"><code class="reqn">y \sim Binomial(n, f(d))</code>
</p>

<p style="text-align: center;"><code class="reqn">link(f(d)) = b_1 + b_2 * log(d + 1)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_1 \sim N(mu_b1, sigma_b1 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_2 \sim N(mu_b2, sigma_b2 ^ 2)</code>
</p>



<h3>Log-quadratic Binary</h3>

<p style="text-align: center;"><code class="reqn">y \sim Binomial(n, f(d))</code>
</p>

<p style="text-align: center;"><code class="reqn">link(f(d)) = b_1 + b_2 * log(d + 1) + b_3 * log(d + 1)^2</code>
</p>

<p style="text-align: center;"><code class="reqn">b_1 \sim N(mu_b1, sigma_b1 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_2 \sim N(mu_b2, sigma_b2 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_3 \sim N(mu_b3, sigma_b3 ^ 2)</code>
</p>



<h3>EMAX Binary</h3>

<p style="text-align: center;"><code class="reqn">y \sim Binomial(n, f(d))</code>
</p>

<p style="text-align: center;"><code class="reqn">link(f(d)) = b_1 + (b_2 - b_1) * d ^ b_4 /
    (exp(b_3 * b_4) + d ^ b_4)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_1 \sim N(mu_b1, sigma_b1 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_2 \sim N(mu_b2, sigma_b2 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_3 \sim N(mu_b3, sigma_b3 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_4 \sim N(mu_b4, sigma_b4 ^ 2), (Truncated above 0)</code>
</p>

<p>Here, on the <code class="reqn">link(f(d))</code> scale,
<code class="reqn">b_1</code> is the placebo effect (dose = 0), <code class="reqn">b_2</code> is the
maximum treatment effect, <code class="reqn">b_3</code> is the <code class="reqn">log(ED50)</code>, and
<code class="reqn">b_4</code> is the hill or rate parameter.
</p>


<h3>Exponential Binary</h3>

<p style="text-align: center;"><code class="reqn">y \sim Binomial(n, f(d))</code>
</p>

<p style="text-align: center;"><code class="reqn">link(f(d)) = b_1 + b_2 * (exp(b_3 * d) - 1)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_1 \sim N(mu_b1, sigma_b1 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_2 \sim N(mu_b2, sigma_b2 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_3 \sim N(mu_b3, sigma_b3 ^ 2), (Truncated below 0)</code>
</p>



<h3>Beta Binary</h3>

<p style="text-align: center;"><code class="reqn">y \sim Binomial(n, f(d)</code>
</p>

<p style="text-align: center;"><code class="reqn">link(f(d)) = b_1 + b_2 * ((b3 + b4) ^ (b3 + b4)) /
    (b3 ^ b3 * b4 ^ b4) * (d / scale) ^ b3 *
    (1 - d / scale) ^ b4</code>
</p>

<p style="text-align: center;"><code class="reqn">b_1 \sim N(mu_b1, sigma_b1 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_2 \sim N(mu_b2, sigma_b2 ^ 2)</code>
</p>

<p style="text-align: center;"><code class="reqn">b_3 \sim N(mu_b3, sigma_b3 ^ 2), Truncated above 0</code>
</p>

<p style="text-align: center;"><code class="reqn">b_4 \sim N(mu_b4, sigma_b4 ^ 2), Truncated above 0</code>
</p>

<p>Note that <code class="reqn">scale</code> is a hyperparameter specified by the
user.
</p>


<h3>Independent Binary</h3>

<p style="text-align: center;"><code class="reqn">y \sim Binomial(n, f(d))</code>
</p>

<p style="text-align: center;"><code class="reqn">link(f(d)) = b_{1d}</code>
</p>

<p style="text-align: center;"><code class="reqn">b_{1d} \sim N(mu_b1[d], sigma_b1[d]) ^ 2</code>
</p>



<h3>Independent Binary Details</h3>

<p>The independent model models the effect of each dose independently.
Vectors can be supplied to <code>mu_b1</code> and <code>sigma_b1</code> to set a different
prior for each dose in the order the doses are supplied to <code>doses</code>.
If scalars are supplied to <code>mu_b1</code> and <code>sigma_b1</code>, then the same prior
is used for each dose, and the <code>doses</code> argument is not needed.
</p>


<h3>Longitudinal Linear</h3>

<p>Let <code class="reqn">f(d)</code> be a dose response model.  The expected value of the
response, y, is:
</p>
<p style="text-align: center;"><code class="reqn">E(y) = g(d, t)</code>
</p>

<p style="text-align: center;"><code class="reqn">g(d, t) = a + (t / t_max) * f(d)</code>
</p>

<p style="text-align: center;"><code class="reqn">a \sim N(mu_a, sigma_a)</code>
</p>



<h3>Longitudinal ITP</h3>

<p>Let <code class="reqn">f(d)</code> be a dose response model.  The expected value of the
response, y, is:
</p>
<p style="text-align: center;"><code class="reqn">E(y) = g(d, t)</code>
</p>

<p style="text-align: center;"><code class="reqn">g(d, t) = a + f(d) * ((1 - exp(- c1 * t))/(1 - exp(- c1 * t_max)))</code>
</p>

<p style="text-align: center;"><code class="reqn">a \sim N(mu_a, sigma_a)</code>
</p>

<p style="text-align: center;"><code class="reqn">c1 \sim Uniform(a_c1, b_c1)</code>
</p>



<h3>Longitudinal IDP</h3>

<p>Increasing-Decreasing-Plateau (IDP).
</p>
<p>Let <code class="reqn">f(d)</code> be a dose response model.  The expected value of the
response, y, is:
</p>
<p style="text-align: center;"><code class="reqn">E(y) = g(d, t)</code>
</p>

<p style="text-align: center;"><code class="reqn">g(d, t) = a + f(d) * (((1 - exp(- c1 * t))/(1 - exp(- c1 * d1))) *
    I(t &lt; d1) + (1 - gam * ((1 - exp(- c2 * (t - d1))) /
    (1 - exp(- c2 * (d2 - d1))))) *
    I(d1 &lt;= t &lt;= d2) + (1 - gam) * I(t &gt; d2))</code>
</p>

<p style="text-align: center;"><code class="reqn">a \sim N(mu_a, sigma_a)</code>
</p>

<p style="text-align: center;"><code class="reqn">c1 \sim Uniform(a_c1, b_c1)</code>
</p>

<p style="text-align: center;"><code class="reqn">c2 \sim Uniform(a_c2, b_c2)</code>
</p>

<p style="text-align: center;"><code class="reqn">d1 \sim Uniform(0, t_max)</code>
</p>

<p style="text-align: center;"><code class="reqn">d2 \sim Uniform(d1, t_max)</code>
</p>

<p style="text-align: center;"><code class="reqn">gam \sim Uniform(0, 1)</code>
</p>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(888)
data &lt;- dreamer_data_linear(
  n_cohorts = c(20, 20, 20),
  dose = c(0, 3, 10),
  b1 = 1,
  b2 = 3,
  sigma = 5
)

# Bayesian model averaging
output &lt;- dreamer_mcmc(
  data = data,
  n_adapt = 1e3,
  n_burn = 1e2,
  n_iter = 1e3,
  n_chains = 2,
  silent = TRUE,
  mod_linear = model_linear(
    mu_b1 = 0,
    sigma_b1 = 1,
    mu_b2 = 0,
    sigma_b2 = 1,
    shape = 1,
    rate = .001,
    w_prior = 1 / 2
  ),
  mod_quad = model_quad(
    mu_b1 = 0,
    sigma_b1 = 1,
    mu_b2 = 0,
    sigma_b2 = 1,
    mu_b3 = 0,
    sigma_b3 = 1,
    shape = 1,
    rate = .001,
    w_prior = 1 / 2
  )
)
# posterior weights
output$w_post
# plot posterior dose response
plot(output)

# LONGITUDINAL
library(ggplot2)
set.seed(889)
data_long &lt;- dreamer_data_linear(
  n_cohorts = c(10, 10, 10, 10), # number of subjects in each cohort
  doses = c(.25, .5, .75, 1.5), # dose administered to each cohort
  b1 = 0, # intercept
  b2 = 2, # slope
  sigma = .5, # standard deviation,
  longitudinal = "itp",
  times = c(0, 12, 24, 52),
  t_max = 52, # maximum time
  a = .5,
  c1 = .1
)

## Not run: 
ggplot(data_long, aes(time, response, group = dose, color = factor(dose))) +
   geom_point()

## End(Not run)

output_long &lt;- dreamer_mcmc(
   data = data_long,
   n_adapt = 1e3,
   n_burn = 1e2,
   n_iter = 1e3,
   n_chains = 2,
   silent = TRUE, # make rjags be quiet,
   mod_linear = model_linear(
      mu_b1 = 0,
      sigma_b1 = 1,
      mu_b2 = 0,
      sigma_b2 = 1,
      shape = 1,
      rate = .001,
      w_prior = 1 / 2, # prior probability of the model
      longitudinal = model_longitudinal_itp(
         mu_a = 0,
         sigma_a = 1,
         a_c1 = 0,
         b_c1 = 1,
         t_max = 52
      )
   ),
   mod_quad = model_quad(
      mu_b1 = 0,
      sigma_b1 = 1,
      mu_b2 = 0,
      sigma_b2 = 1,
      mu_b3 = 0,
      sigma_b3 = 1,
      shape = 1,
      rate = .001,
      w_prior = 1 / 2,
      longitudinal = model_longitudinal_linear(
         mu_a = 0,
         sigma_a = 1,
         t_max = 52
      )
   )
)

## Not run: 
# plot longitudinal dose-response profile
plot(output_long, data = data_long)
plot(output_long$mod_quad, data = data_long) # single model

# plot dose response at final timepoint
plot(output_long, data = data_long, times = 52)
plot(output_long$mod_quad, data = data_long, times = 52) # single model

## End(Not run)
</code></pre>

<hr>
<h2 id='model_longitudinal'>Model Creation: Longitudinal Models</h2><span id='topic+model_longitudinal'></span><span id='topic+model_longitudinal_linear'></span><span id='topic+model_longitudinal_itp'></span><span id='topic+model_longitudinal_idp'></span>

<h3>Description</h3>

<p>Assign hyperparameters and other values for longitudinal
modeling.  The output of this function is intended to be used as
the input to the <code>longitudinal</code> argument of the dose response model
functions, e.g., <code>model_linear</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_longitudinal_linear(mu_a, sigma_a, t_max)

model_longitudinal_itp(mu_a, sigma_a, a_c1 = 0, b_c1 = 1, t_max)

model_longitudinal_idp(
  mu_a,
  sigma_a,
  a_c1 = 0,
  b_c1 = 1,
  a_c2 = -1,
  b_c2 = 0,
  t_max
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_longitudinal_+3A_mu_a">mu_a</code>, <code id="model_longitudinal_+3A_sigma_a">sigma_a</code>, <code id="model_longitudinal_+3A_a_c1">a_c1</code>, <code id="model_longitudinal_+3A_b_c1">b_c1</code>, <code id="model_longitudinal_+3A_a_c2">a_c2</code>, <code id="model_longitudinal_+3A_b_c2">b_c2</code></td>
<td>
<p>hyperparameters of the specified
longitudinal model.  See below for parameterization.</p>
</td></tr>
<tr><td><code id="model_longitudinal_+3A_t_max">t_max</code></td>
<td>
<p>a scalar, typically indicating the latest observed time
for subjects.  This will influence the interpretation of the
parameters of each model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of the arguments in the function call.  The list has
S3 classes assigned which are used internally within <code>dreamer_mcmc()</code>.
</p>


<h3>Longitudinal Linear</h3>

<p>Let <code class="reqn">f(d)</code> be a dose response model.  The expected value of the
response, y, is:
</p>
<p style="text-align: center;"><code class="reqn">E(y) = g(d, t)</code>
</p>

<p style="text-align: center;"><code class="reqn">g(d, t) = a + (t / t_max) * f(d)</code>
</p>

<p style="text-align: center;"><code class="reqn">a \sim N(mu_a, sigma_a)</code>
</p>



<h3>Longitudinal ITP</h3>

<p>Let <code class="reqn">f(d)</code> be a dose response model.  The expected value of the
response, y, is:
</p>
<p style="text-align: center;"><code class="reqn">E(y) = g(d, t)</code>
</p>

<p style="text-align: center;"><code class="reqn">g(d, t) = a + f(d) * ((1 - exp(- c1 * t))/(1 - exp(- c1 * t_max)))</code>
</p>

<p style="text-align: center;"><code class="reqn">a \sim N(mu_a, sigma_a)</code>
</p>

<p style="text-align: center;"><code class="reqn">c1 \sim Uniform(a_c1, b_c1)</code>
</p>



<h3>Longitudinal IDP</h3>

<p>Increasing-Decreasing-Plateau (IDP).
</p>
<p>Let <code class="reqn">f(d)</code> be a dose response model.  The expected value of the
response, y, is:
</p>
<p style="text-align: center;"><code class="reqn">E(y) = g(d, t)</code>
</p>

<p style="text-align: center;"><code class="reqn">g(d, t) = a + f(d) * (((1 - exp(- c1 * t))/(1 - exp(- c1 * d1))) *
    I(t &lt; d1) + (1 - gam * ((1 - exp(- c2 * (t - d1))) /
    (1 - exp(- c2 * (d2 - d1))))) *
    I(d1 &lt;= t &lt;= d2) + (1 - gam) * I(t &gt; d2))</code>
</p>

<p style="text-align: center;"><code class="reqn">a \sim N(mu_a, sigma_a)</code>
</p>

<p style="text-align: center;"><code class="reqn">c1 \sim Uniform(a_c1, b_c1)</code>
</p>

<p style="text-align: center;"><code class="reqn">c2 \sim Uniform(a_c2, b_c2)</code>
</p>

<p style="text-align: center;"><code class="reqn">d1 \sim Uniform(0, t_max)</code>
</p>

<p style="text-align: center;"><code class="reqn">d2 \sim Uniform(d1, t_max)</code>
</p>

<p style="text-align: center;"><code class="reqn">gam \sim Uniform(0, 1)</code>
</p>


<hr>
<h2 id='plot_comparison'>Compare Posterior Fits</h2><span id='topic+plot_comparison'></span><span id='topic+plot_comparison.default'></span><span id='topic+plot_comparison.dreamer_bma'></span>

<h3>Description</h3>

<p>Compare Posterior Fits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_comparison(..., doses, times, probs, data, n_smooth, width)

## Default S3 method:
plot_comparison(
  ...,
  doses = attr(list(...)[[1]], "doses"),
  times = NULL,
  probs = c(0.025, 0.975),
  data = NULL,
  n_smooth = 50,
  width = bar_width(doses)
)

## S3 method for class 'dreamer_bma'
plot_comparison(
  ...,
  doses = x$doses,
  times = NULL,
  probs = c(0.025, 0.975),
  data = NULL,
  n_smooth = 50,
  width = bar_width(doses)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_comparison_+3A_...">...</code></td>
<td>
<p><code>dreamer_mcmc</code> objects to be used for plotting.</p>
</td></tr>
<tr><td><code id="plot_comparison_+3A_doses">doses</code></td>
<td>
<p>a vector of doses at which to plot the dose response curve.</p>
</td></tr>
<tr><td><code id="plot_comparison_+3A_times">times</code></td>
<td>
<p>the times at which to do the comparison.</p>
</td></tr>
<tr><td><code id="plot_comparison_+3A_probs">probs</code></td>
<td>
<p>quantiles of the posterior to be calculated.</p>
</td></tr>
<tr><td><code id="plot_comparison_+3A_data">data</code></td>
<td>
<p>a dataframe with column names of &quot;dose&quot; and &quot;response&quot; for
individual patient data.  Optional columns &quot;n&quot; and &quot;sample_var&quot; can
be specified if aggregate data is supplied, but it is recommended that
patient-level data be supplied where possible for continuous models, as the
posterior weights differ if aggregated data is used.
For aggregated continuous
data, &quot;response&quot; should be the average of &quot;n&quot; subjects with a sample
variance of &quot;sample_var&quot;.  For aggregated binary data, &quot;response&quot; should
be the number of successes, &quot;n&quot; should be the total number of subjects
(the &quot;sample_var&quot; column is irrelevant in binary cases and is ignored).</p>
</td></tr>
<tr><td><code id="plot_comparison_+3A_n_smooth">n_smooth</code></td>
<td>
<p>the number of points to calculate the smooth dose response
interpolation.  Must be sufficiently high to accurately depict the
dose response curve.</p>
</td></tr>
<tr><td><code id="plot_comparison_+3A_width">width</code></td>
<td>
<p>the width of the error bars.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a Bayesian model averaging object is supplied first, all
individual fits and the Bayesian model averaging fit will be plotted, with
the model averaging fit in black (other model colors specified in the
legend).  Otherwise,
named arguments must be supplied for each model, and only the models
provided will be plotted.
</p>


<h3>Value</h3>

<p>a ggplot object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(888)
data &lt;- dreamer_data_linear(
  n_cohorts = c(20, 20, 20),
  dose = c(0, 3, 10),
  b1 = 1,
  b2 = 3,
  sigma = 5
)

# Bayesian model averaging
output &lt;- dreamer_mcmc(
 data = data,
 n_adapt = 1e3,
 n_burn = 1e3,
 n_iter = 1e3,
 n_chains = 2,
 silent = FALSE,
 mod_linear = model_linear(
   mu_b1 = 0,
   sigma_b1 = 1,
   mu_b2 = 0,
   sigma_b2 = 1,
   shape = 1,
   rate = .001,
   w_prior = 1 / 2
 ),
 mod_quad = model_quad(
   mu_b1 = 0,
   sigma_b1 = 1,
   mu_b2 = 0,
   sigma_b2 = 1,
   mu_b3 = 0,
   sigma_b3 = 1,
   shape = 1,
   rate = .001,
   w_prior = 1 / 2
 )
)

plot_comparison(output)

# compare individual models
plot_comparison(linear = output$mod_linear, quad = output$mod_quad)
</code></pre>

<hr>
<h2 id='plot_trace'>Traceplots</h2><span id='topic+plot_trace'></span>

<h3>Description</h3>

<p>Produces traceplots for each parameter for each model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_trace(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_trace_+3A_x">x</code></td>
<td>
<p>output from a call to <code>dreamer_mcmc()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called to create plots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(888)
data &lt;- dreamer_data_linear(
  n_cohorts = c(20, 20, 20),
  dose = c(0, 3, 10),
  b1 = 1,
  b2 = 3,
  sigma = 5
)

# Bayesian model averaging
output &lt;- dreamer_mcmc(
 data = data,
 n_adapt = 1e3,
 n_burn = 1e3,
 n_iter = 1e4,
 n_chains = 2,
 silent = FALSE,
 mod_linear = model_linear(
   mu_b1 = 0,
   sigma_b1 = 1,
   mu_b2 = 0,
   sigma_b2 = 1,
   shape = 1,
   rate = .001,
   w_prior = 1 / 2
 ),
 mod_quad = model_quad(
   mu_b1 = 0,
   sigma_b1 = 1,
   mu_b2 = 0,
   sigma_b2 = 1,
   mu_b3 = 0,
   sigma_b3 = 1,
   shape = 1,
   rate = .001,
   w_prior = 1 / 2
 )
)

# all parameters from all models
plot_trace(output)

# from a single model
plot_trace(output$mod_linear)
</code></pre>

<hr>
<h2 id='post_medx'>Posterior Distribution of Minimum X% Effective Dose</h2><span id='topic+post_medx'></span><span id='topic+post_medx.dreamer_bma'></span><span id='topic+post_medx.dreamer_mcmc'></span>

<h3>Description</h3>

<p>Posterior Distribution of Minimum X% Effective Dose
</p>


<h3>Usage</h3>

<pre><code class='language-R'>post_medx(
  x,
  ed,
  probs,
  time,
  lower,
  upper,
  greater,
  small_bound,
  return_samples,
  ...
)

## S3 method for class 'dreamer_bma'
post_medx(
  x,
  ed,
  probs = c(0.025, 0.975),
  time = NULL,
  lower = min(x$doses),
  upper = max(x$doses),
  greater = TRUE,
  small_bound = 0,
  return_samples = FALSE,
  ...
)

## S3 method for class 'dreamer_mcmc'
post_medx(
  x,
  ed,
  probs = c(0.025, 0.975),
  time = NULL,
  lower = min(attr(x, "doses")),
  upper = max(attr(x, "doses")),
  greater = TRUE,
  small_bound = 0,
  return_samples = FALSE,
  index = 1:(nrow(x[[1]]) * length(x)),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="post_medx_+3A_x">x</code></td>
<td>
<p>output from <code>dreamer_mcmc()</code>.</p>
</td></tr>
<tr><td><code id="post_medx_+3A_ed">ed</code></td>
<td>
<p>a number between 0 and 100 indicating the ed% dose that is
being sought.</p>
</td></tr>
<tr><td><code id="post_medx_+3A_probs">probs</code></td>
<td>
<p>a vector of quantiles to calculate on the posterior.</p>
</td></tr>
<tr><td><code id="post_medx_+3A_time">time</code></td>
<td>
<p>the slice of time for which to calculate the posterior EDX dose.
Applies to longitudinal models only.</p>
</td></tr>
<tr><td><code id="post_medx_+3A_lower">lower</code></td>
<td>
<p>the lower bound of the doses for calculating EDX.</p>
</td></tr>
<tr><td><code id="post_medx_+3A_upper">upper</code></td>
<td>
<p>the upper bound of the doses for calculating EDX.</p>
</td></tr>
<tr><td><code id="post_medx_+3A_greater">greater</code></td>
<td>
<p>if <code>TRUE</code>, higher values indicate better efficacy.  If
<code>FALSE</code>, lower responses indicate better efficacy.</p>
</td></tr>
<tr><td><code id="post_medx_+3A_small_bound">small_bound</code></td>
<td>
<p>the minimum (<code>greater = TRUE</code>) or maximum
(<code>greater = FALSE</code>) bound of the response.</p>
</td></tr>
<tr><td><code id="post_medx_+3A_return_samples">return_samples</code></td>
<td>
<p>logical indicating if the posterior samples should be
returned.</p>
</td></tr>
<tr><td><code id="post_medx_+3A_...">...</code></td>
<td>
<p>additional arguments for specific methods.</p>
</td></tr>
<tr><td><code id="post_medx_+3A_index">index</code></td>
<td>
<p>a vector indicating which MCMC samples to use in the
calculation.  If <code>NULL</code> (default), all MCMC samples are used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The minimum X% effective dose is the dose that has X% of the
largest effect for doses between <code>lower</code> and <code>upper</code>.  When <code>greater</code>
is <code>TRUE</code>, larger positive responses are considered more effective and
vice versa.  The X% response is calculated as <code>small_bound</code> +
<code>ed</code> / 100 * (max_effect - <code>small_bound</code>) where &quot;max_effect&quot; is the
maximum response for doses between <code>lower</code> and <code>upper</code>.  The X% effective
dose is the smallest dose which has X% response within the dose range.
It is possible that for some MCMC samples, an X% effective dose may
not exist, so probabilities are not guaranteed to sum to one.
</p>


<h3>Value</h3>

<p>Posterior quantities and samples (if applicable),
generally in the form of a list.  The <code>pr_edx_exists</code> column gives the
posterior probability that an EDX% effect exists.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(888)
data &lt;- dreamer_data_linear(
  n_cohorts = c(20, 20, 20),
  dose = c(0, 3, 10),
  b1 = 1,
  b2 = 3,
  sigma = 5
)

# Bayesian model averaging
output &lt;- dreamer_mcmc(
 data = data,
 n_adapt = 1e3,
 n_burn = 1e3,
 n_iter = 1e3,
 n_chains = 2,
 silent = FALSE,
 mod_linear = model_linear(
   mu_b1 = 0,
   sigma_b1 = 1,
   mu_b2 = 0,
   sigma_b2 = 1,
   shape = 1,
   rate = .001,
   w_prior = 1 / 2
 ),
 mod_quad = model_quad(
   mu_b1 = 0,
   sigma_b1 = 1,
   mu_b2 = 0,
   sigma_b2 = 1,
   mu_b3 = 0,
   sigma_b3 = 1,
   shape = 1,
   rate = .001,
   w_prior = 1 / 2
 )
)

post_medx(output, ed = c(50, 90))

# from a single model
post_medx(output$mod_linear, ed = c(50, 90))
</code></pre>

<hr>
<h2 id='post_perc_effect'>Calculate Posterior of a Dose's Percentage Effect</h2><span id='topic+post_perc_effect'></span><span id='topic+post_perc_effect.dreamer_bma'></span><span id='topic+post_perc_effect.dreamer_mcmc'></span>

<h3>Description</h3>

<p>Given a dose, the &quot;percentage effect&quot; is defined as
(effect of the given dose - small_bound) / (maximum effect in dose range -
small_bound).  This function returns the posterior statistics and/or
samples of this effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>post_perc_effect(
  x,
  dose,
  probs,
  time,
  lower,
  upper,
  greater,
  small_bound,
  index,
  return_samples
)

## S3 method for class 'dreamer_bma'
post_perc_effect(
  x,
  dose,
  probs = c(0.025, 0.975),
  time = NULL,
  lower = min(x$doses),
  upper = max(x$doses),
  greater = TRUE,
  small_bound = 0,
  index = NA,
  return_samples = FALSE
)

## S3 method for class 'dreamer_mcmc'
post_perc_effect(
  x,
  dose,
  probs = c(0.025, 0.975),
  time = NULL,
  lower = min(attr(x, "doses")),
  upper = max(attr(x, "doses")),
  greater = TRUE,
  small_bound = 0,
  index = 1:(nrow(x[[1]]) * length(x)),
  return_samples = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="post_perc_effect_+3A_x">x</code></td>
<td>
<p>output from a call to <code>dreamer_mcmc()</code>, or
the MCMC samples from a single model of output from
a <code>dreamer_mcmc()</code> call.</p>
</td></tr>
<tr><td><code id="post_perc_effect_+3A_dose">dose</code></td>
<td>
<p>the dose at which to calculate the posterior percentage
effect.</p>
</td></tr>
<tr><td><code id="post_perc_effect_+3A_probs">probs</code></td>
<td>
<p>a vector of quantiles to calculate on the posterior.</p>
</td></tr>
<tr><td><code id="post_perc_effect_+3A_time">time</code></td>
<td>
<p>the slice of time for which to calculate the posterior
percentage effect.  Applies to longitudinal models only.</p>
</td></tr>
<tr><td><code id="post_perc_effect_+3A_lower">lower</code></td>
<td>
<p>the lower bound of the dose range under consideration.</p>
</td></tr>
<tr><td><code id="post_perc_effect_+3A_upper">upper</code></td>
<td>
<p>the upper bound of the dose range under consideration.</p>
</td></tr>
<tr><td><code id="post_perc_effect_+3A_greater">greater</code></td>
<td>
<p>logical indicating if the response is desired to
be increasing (<code>TRUE</code>) or decreasing (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="post_perc_effect_+3A_small_bound">small_bound</code></td>
<td>
<p>the lower (if <code>greater = TRUE</code>) or upper
(if <code>greater = FALSE</code>) bound that the effect is expected to
take.</p>
</td></tr>
<tr><td><code id="post_perc_effect_+3A_index">index</code></td>
<td>
<p>an index on which MCMC samples should be used.  Generally
the user should not specify anything for this argument as <code>dreamer</code>
will handle this automatically.</p>
</td></tr>
<tr><td><code id="post_perc_effect_+3A_return_samples">return_samples</code></td>
<td>
<p>logical indicating if the posterior samples should
be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with the following components:
</p>

<ul>
<li><p> stats: a tibble listing the dose, time (where relevant),
probability a percentage effect exists, the average percentage effect,
and the specified quantiles of the percentage effect.
</p>
</li>
<li><p> samps: a tibble with the posterior samples for each dose/time
combination.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(888)
data &lt;- dreamer_data_linear(
  n_cohorts = c(20, 20, 20),
  dose = c(0, 3, 10),
  b1 = 1,
  b2 = 3,
  sigma = 5
)

# Bayesian model averaging
output &lt;- dreamer_mcmc(
 data = data,
 n_adapt = 1e3,
 n_burn = 1e3,
 n_iter = 1e3,
 n_chains = 2,
 silent = FALSE,
 mod_linear = model_linear(
   mu_b1 = 0,
   sigma_b1 = 1,
   mu_b2 = 0,
   sigma_b2 = 1,
   shape = 1,
   rate = .001,
   w_prior = 1 / 2
 ),
 mod_quad = model_quad(
   mu_b1 = 0,
   sigma_b1 = 1,
   mu_b2 = 0,
   sigma_b2 = 1,
   mu_b3 = 0,
   sigma_b3 = 1,
   shape = 1,
   rate = .001,
   w_prior = 1 / 2
 )
)

post_perc_effect(output, dose = c(3, 5))

# from a single model
post_perc_effect(output$mod_linear, dose = c(3, 5))
</code></pre>

<hr>
<h2 id='posterior'>Posterior Quantities from Bayesian Model Averaging</h2><span id='topic+posterior'></span><span id='topic+posterior.dreamer_mcmc'></span><span id='topic+posterior.dreamer_mcmc_independent'></span><span id='topic+posterior.dreamer_bma'></span>

<h3>Description</h3>

<p>Calculate posterior mean (and quantiles for specific
doses for each MCMC iteration of the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posterior(
  x,
  doses,
  times,
  probs,
  reference_dose,
  predictive,
  return_samples,
  iter,
  return_stats
)

## S3 method for class 'dreamer_mcmc'
posterior(
  x,
  doses = attr(x, "doses"),
  times = attr(x, "times"),
  probs = c(0.025, 0.975),
  reference_dose = NULL,
  predictive = 0,
  return_samples = FALSE,
  iter = NULL,
  return_stats = TRUE
)

## S3 method for class 'dreamer_mcmc_independent'
posterior(
  x,
  doses = attr(x, "doses"),
  times = attr(x, "times"),
  probs = c(0.025, 0.975),
  reference_dose = NULL,
  predictive = 0,
  return_samples = FALSE,
  iter = NULL,
  return_stats = TRUE
)

## S3 method for class 'dreamer_bma'
posterior(
  x,
  doses = x$doses,
  times = x$times,
  probs = c(0.025, 0.975),
  reference_dose = NULL,
  predictive = 0,
  return_samples = FALSE,
  iter = NULL,
  return_stats = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior_+3A_x">x</code></td>
<td>
<p>output from a call to <code><a href="#topic+dreamer_mcmc">dreamer_mcmc</a></code>.</p>
</td></tr>
<tr><td><code id="posterior_+3A_doses">doses</code></td>
<td>
<p>doses at which to estimate posterior quantities.</p>
</td></tr>
<tr><td><code id="posterior_+3A_times">times</code></td>
<td>
<p>a vector of times at which to calculate the posterior response
(for longitudinal models only).</p>
</td></tr>
<tr><td><code id="posterior_+3A_probs">probs</code></td>
<td>
<p>quantiles of the posterior to be calculated.</p>
</td></tr>
<tr><td><code id="posterior_+3A_reference_dose">reference_dose</code></td>
<td>
<p>the dose at which to adjust the posterior plot.
Specifying
a dose returns the plot of pr(trt_dose - trt_reference_dose | data).</p>
</td></tr>
<tr><td><code id="posterior_+3A_predictive">predictive</code></td>
<td>
<p>An integer.  If greater than 0, the return values will
be from the predictive distribution of the mean of <code>predictive</code>
observations.
If 0 (default), the posterior on the dose response mean is returned.</p>
</td></tr>
<tr><td><code id="posterior_+3A_return_samples">return_samples</code></td>
<td>
<p>logical indicating if the weighted raw
MCMC samples from the Bayesian model averaging used to calculate the
mean and quantiles should be returned.</p>
</td></tr>
<tr><td><code id="posterior_+3A_iter">iter</code></td>
<td>
<p>an index on which iterations of the MCMC should be used
in the calculations.  By default, all MCMC iterations are used.</p>
</td></tr>
<tr><td><code id="posterior_+3A_return_stats">return_stats</code></td>
<td>
<p>logical indicating whether or not the posterior
statistics should be calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with the following elements:
</p>

<ul>
<li><p> stats: a tibble the dose, posterior mean, and posterior quantiles.
</p>
</li>
<li><p> samps: the weighted posterior samples.  Only returned if
<code>return_samples = TRUE</code>.
</p>
</li></ul>



<h3>Methods (by class)</h3>


<ul>
<li> <p><code>posterior(dreamer_mcmc)</code>: posterior summary for linear model.
</p>
</li>
<li> <p><code>posterior(dreamer_mcmc_independent)</code>: posterior summary for independent model.
</p>
</li>
<li> <p><code>posterior(dreamer_bma)</code>: posterior summary for Bayesian model averaging fit.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(888)
data &lt;- dreamer_data_linear(
  n_cohorts = c(20, 20, 20),
  dose = c(0, 3, 10),
  b1 = 1,
  b2 = 3,
  sigma = 5
)

# Bayesian model averaging
output &lt;- dreamer_mcmc(
 data = data,
 n_adapt = 1e3,
 n_burn = 1e3,
 n_iter = 1e4,
 n_chains = 2,
 silent = FALSE,
 mod_linear = model_linear(
   mu_b1 = 0,
   sigma_b1 = 1,
   mu_b2 = 0,
   sigma_b2 = 1,
   shape = 1,
   rate = .001,
   w_prior = 1 / 2
 ),
 mod_quad = model_quad(
   mu_b1 = 0,
   sigma_b1 = 1,
   mu_b2 = 0,
   sigma_b2 = 1,
   mu_b3 = 0,
   sigma_b3 = 1,
   shape = 1,
   rate = .001,
   w_prior = 1 / 2
 )
)

posterior(output)

# return posterior samples of the mean
post &lt;- posterior(output, return_samples = TRUE)
head(post$samps)

# from a single model
posterior(output$mod_quad)

# posterior of difference of doses
posterior(output, reference_dose = 0)
</code></pre>

<hr>
<h2 id='pr_eoi'>Calculate Probability of Meeting Effect of Interest (EOI)</h2><span id='topic+pr_eoi'></span>

<h3>Description</h3>

<p>Calculate Pr(effect_dose - effect_reference_dose &gt; EOI | data)
or Pr(effect_dose &gt; EOI | data).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pr_eoi(x, eoi, dose, reference_dose = NULL, time = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pr_eoi_+3A_x">x</code></td>
<td>
<p>output from a call to <code>dreamer_mcmc()</code>.</p>
</td></tr>
<tr><td><code id="pr_eoi_+3A_eoi">eoi</code></td>
<td>
<p>a vector of the effects of interest (EOI) in the probability
function.</p>
</td></tr>
<tr><td><code id="pr_eoi_+3A_dose">dose</code></td>
<td>
<p>a vector of the doses for which to calculate the
posterior probabilities.</p>
</td></tr>
<tr><td><code id="pr_eoi_+3A_reference_dose">reference_dose</code></td>
<td>
<p>a vector of doses for relative effects of interest.</p>
</td></tr>
<tr><td><code id="pr_eoi_+3A_time">time</code></td>
<td>
<p>the time at which to calculate the posterior quantity.  Defaults
to the latest timepoint.  Applies to longitudinal models only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble listing the doses, times, and
Pr(effect_dose - effect_reference_dose &gt; eoi) if <code>reference_dose</code>
is specified; otherwise, Pr(effect_dose &gt; eoi).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(888)
data &lt;- dreamer_data_linear(
  n_cohorts = c(20, 20, 20),
  dose = c(0, 3, 10),
  b1 = 1,
  b2 = 3,
  sigma = 5
)

# Bayesian model averaging
output &lt;- dreamer_mcmc(
 data = data,
 n_adapt = 1e3,
 n_burn = 1e3,
 n_iter = 1e4,
 n_chains = 2,
 silent = FALSE,
 mod_linear = model_linear(
   mu_b1 = 0,
   sigma_b1 = 1,
   mu_b2 = 0,
   sigma_b2 = 1,
   shape = 1,
   rate = .001,
   w_prior = 1 / 2
 ),
 mod_quad = model_quad(
   mu_b1 = 0,
   sigma_b1 = 1,
   mu_b2 = 0,
   sigma_b2 = 1,
   mu_b3 = 0,
   sigma_b3 = 1,
   shape = 1,
   rate = .001,
   w_prior = 1 / 2
 )
)

pr_eoi(output, dose = 3, eoi = 10)

# difference of two doses
pr_eoi(output, dose = 3, eoi = 10, reference_dose = 0)

# single model
pr_eoi(output$mod_linear, dose = 3, eoi = 10)
</code></pre>

<hr>
<h2 id='pr_med'>Pr(minimum efficacious dose)</h2><span id='topic+pr_med'></span>

<h3>Description</h3>

<p>Calculates the posterior probability that each specified doses
are the minimum effective dose in the set; i.e. the smallest
dose that has a clinically significant difference (CSD).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pr_med(
  x,
  doses = attr(x, "doses"),
  csd = NULL,
  reference_dose = NULL,
  greater = TRUE,
  time = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pr_med_+3A_x">x</code></td>
<td>
<p>output from a call to <code>dreamer_mcmc()</code>.</p>
</td></tr>
<tr><td><code id="pr_med_+3A_doses">doses</code></td>
<td>
<p>the doses for which pr(MED) is to be calculated.</p>
</td></tr>
<tr><td><code id="pr_med_+3A_csd">csd</code></td>
<td>
<p>the treatment effect that is clinically relevant.</p>
</td></tr>
<tr><td><code id="pr_med_+3A_reference_dose">reference_dose</code></td>
<td>
<p>a single dose that is used as the reference when
defining the MED relative to a dose (rather than in absolute terms).  When
<code>reference_dose</code> is specified, this function calculates the
posterior probability
that each dose is the smallest dose such that
(effect_dose - effect_reference_dose &gt; CSD).</p>
</td></tr>
<tr><td><code id="pr_med_+3A_greater">greater</code></td>
<td>
<p>if <code>TRUE</code>, higher responses indicate better efficacy.  If
<code>FALSE</code>, lower responses indicate better efficacy.'</p>
</td></tr>
<tr><td><code id="pr_med_+3A_time">time</code></td>
<td>
<p>the time (scalar) at which the Pr(MED) should be calculated.
Applies only to longitudinal models.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble listing each dose and the posterior probability that
each dose is the minimum efficacious dose.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(888)
data &lt;- dreamer_data_linear(
  n_cohorts = c(20, 20, 20),
  dose = c(0, 3, 10),
  b1 = 1,
  b2 = 3,
  sigma = 5
)

# Bayesian model averaging
output &lt;- dreamer_mcmc(
 data = data,
 n_adapt = 1e3,
 n_burn = 1e3,
 n_iter = 1e3,
 n_chains = 2,
 silent = FALSE,
 mod_linear = model_linear(
   mu_b1 = 0,
   sigma_b1 = 1,
   mu_b2 = 0,
   sigma_b2 = 1,
   shape = 1,
   rate = .001,
   w_prior = 1 / 2
 ),
 mod_quad = model_quad(
   mu_b1 = 0,
   sigma_b1 = 1,
   mu_b2 = 0,
   sigma_b2 = 1,
   mu_b3 = 0,
   sigma_b3 = 1,
   shape = 1,
   rate = .001,
   w_prior = 1 / 2
 )
)

pr_med(output, csd = 10)

# difference of two doses
pr_med(output, csd = 3, reference_dose = 0)

# single model
pr_med(output$mod_quad, csd = 10)
</code></pre>

<hr>
<h2 id='pr_medx'>Probability of minimum X% effective dose</h2><span id='topic+pr_medx'></span>

<h3>Description</h3>

<p>Calculate the probability a dose being the smallest dose
that has at least X% of the maximum efficacy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pr_medx(
  x,
  doses = attr(x, "doses"),
  ed,
  greater = TRUE,
  small_bound = 0,
  time = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pr_medx_+3A_x">x</code></td>
<td>
<p>output from a call to <code>dreamer_mcmc()</code>.</p>
</td></tr>
<tr><td><code id="pr_medx_+3A_doses">doses</code></td>
<td>
<p>the doses for which pr(minimum effective X% dose) is to be
calculated.</p>
</td></tr>
<tr><td><code id="pr_medx_+3A_ed">ed</code></td>
<td>
<p>a number between 0 and 100 indicating the ed% dose that is
being sought.</p>
</td></tr>
<tr><td><code id="pr_medx_+3A_greater">greater</code></td>
<td>
<p>if <code>TRUE</code>, higher responses indicate better efficacy.  If
<code>FALSE</code>, lower responses indicate better efficacy.'</p>
</td></tr>
<tr><td><code id="pr_medx_+3A_small_bound">small_bound</code></td>
<td>
<p>the lower (upper) bound of the response variable
when <code>greater = TRUE</code> (<code>FALSE</code>).  This is used to calculate the
<code>ed</code>% effect as <code>ed / 100 * (effect_100 - small_bound) + small_bound</code>.</p>
</td></tr>
<tr><td><code id="pr_medx_+3A_time">time</code></td>
<td>
<p>the time (scalar) at which the Pr(MEDX) should be calculated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Obtaining the probability of a particular does being the
minimum efficacious dose achieving <code>ed</code>% efficacy is dependent on
the doses specified.
</p>
<p>For a given MCMC sample of parameters, the 100% efficacy value is defined
as the highest efficacy of the doses specified.  For each posterior draw
of MCMC parameters, the minimum <code>ed</code>% efficacious dose is defined as the
lowest dose what has at least <code>ed</code>% efficacy relative to the 100%
efficacy value.
</p>
<p>The <code>ed</code>% effect is calculated as
<code>ed / 100 * (effect_100 - small_bound) + small_bound</code> where <code>effect_100</code>
is the largest mean response among <code>doses</code> for a given MCMC iteration.
</p>


<h3>Value</h3>

<p>A data frame with the following columns:
</p>

<ul>
<li> <p><code>dose</code>: numeric dose levels.
</p>
</li>
<li> <p><code>prob</code>: Prob(EDX | data) for each dose. Note: these probabilities do
not necessarily sum to 1 because the EDX may not exist. In fact,
Pr(EDX does not exist | data) = <code>1 - sum(prob)</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(888)
data &lt;- dreamer_data_linear(
  n_cohorts = c(20, 20, 20),
  dose = c(0, 3, 10),
  b1 = 1,
  b2 = .1,
  sigma = 5
)

# Bayesian model averaging
output &lt;- dreamer_mcmc(
 data = data,
 n_adapt = 1e3,
 n_burn = 1e3,
 n_iter = 1e3,
 n_chains = 2,
 silent = FALSE,
 mod_linear = model_linear(
   mu_b1 = 0,
   sigma_b1 = 1,
   mu_b2 = 0,
   sigma_b2 = 1,
   shape = 1,
   rate = .001,
   w_prior = 1 / 2
 ),
 mod_quad = model_quad(
   mu_b1 = 0,
   sigma_b1 = 1,
   mu_b2 = 0,
   sigma_b2 = 1,
   mu_b3 = 0,
   sigma_b3 = 1,
   shape = 1,
   rate = .001,
   w_prior = 1 / 2
 )
)

pr_medx(output, ed = 80)

# single model
pr_medx(output$mod_linear, ed = 80)
</code></pre>

<hr>
<h2 id='summary.dreamer_bma'>Summarize Bayesian Model Averaging MCMC Output</h2><span id='topic+summary.dreamer_bma'></span>

<h3>Description</h3>

<p>Summarize parameter inference and convergence diagnostics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dreamer_bma'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.dreamer_bma_+3A_object">object</code></td>
<td>
<p>a dreamer MCMC object.</p>
</td></tr>
<tr><td><code id="summary.dreamer_bma_+3A_...">...</code></td>
<td>
<p>additional arguments (which are ignored).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a named list with elements <code>model_weights</code> and <code>summary</code>
containing the prior and posterior weights for each model and inference
on parameters for each model as well as MCMC diagnostics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(888)
data &lt;- dreamer_data_linear(
  n_cohorts = c(20, 20, 20),
  dose = c(0, 3, 10),
  b1 = 1,
  b2 = 3,
  sigma = 5
)

# Bayesian model averaging
output &lt;- dreamer_mcmc(
 data = data,
 n_adapt = 1e3,
 n_burn = 1e3,
 n_iter = 1e4,
 n_chains = 2,
 silent = FALSE,
 mod_linear = model_linear(
   mu_b1 = 0,
   sigma_b1 = 1,
   mu_b2 = 0,
   sigma_b2 = 1,
   shape = 1,
   rate = .001,
   w_prior = 1 / 2
 ),
 mod_quad = model_quad(
   mu_b1 = 0,
   sigma_b1 = 1,
   mu_b2 = 0,
   sigma_b2 = 1,
   mu_b3 = 0,
   sigma_b3 = 1,
   shape = 1,
   rate = .001,
   w_prior = 1 / 2
 )
)

# all models (also show model weights)
summary(output)

# single model
summary(output$mod_linear)
</code></pre>

<hr>
<h2 id='summary.dreamer_mcmc'>Summarize Model Output</h2><span id='topic+summary.dreamer_mcmc'></span>

<h3>Description</h3>

<p>Produces summaries for inference and diagnosing MCMC chains.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dreamer_mcmc'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.dreamer_mcmc_+3A_object">object</code></td>
<td>
<p>MCMC output from a dreamer model.</p>
</td></tr>
<tr><td><code id="summary.dreamer_mcmc_+3A_...">...</code></td>
<td>
<p>additional arguments which are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with inference and diagnostics information for each
parameter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(888)
data &lt;- dreamer_data_linear(
  n_cohorts = c(20, 20, 20),
  dose = c(0, 3, 10),
  b1 = 1,
  b2 = 3,
  sigma = 5
)

# Bayesian model averaging
output &lt;- dreamer_mcmc(
 data = data,
 n_adapt = 1e3,
 n_burn = 1e3,
 n_iter = 1e4,
 n_chains = 2,
 silent = FALSE,
 mod_linear = model_linear(
   mu_b1 = 0,
   sigma_b1 = 1,
   mu_b2 = 0,
   sigma_b2 = 1,
   shape = 1,
   rate = .001,
   w_prior = 1 / 2
 ),
 mod_quad = model_quad(
   mu_b1 = 0,
   sigma_b1 = 1,
   mu_b2 = 0,
   sigma_b2 = 1,
   mu_b3 = 0,
   sigma_b3 = 1,
   shape = 1,
   rate = .001,
   w_prior = 1 / 2
 )
)

# all models (also show model weights)
summary(output)

# single model
summary(output$mod_linear)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
