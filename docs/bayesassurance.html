<!DOCTYPE html><html><head><title>Help for package bayesassurance</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bayesassurance}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#assurance_nd_na'><p>Bayesian Assurance Computation</p></a></li>
<li><a href='#bayes_adcock'><p>Bayesian Assurance Computation in the Precision-Based Setting</p></a></li>
<li><a href='#bayes_goal_func'><p>Decision Making using Rate of Correct Classification</p></a></li>
<li><a href='#bayes_sim'><p>Bayesian Simulation in Conjugate Linear Model Framework</p></a></li>
<li><a href='#bayes_sim_betabin'><p>Bayesian Assurance Computation in the Beta-Binomial Setting</p></a></li>
<li><a href='#bayes_sim_unbalanced'><p>Unbalanced Bayesian Simulation in Conjugate Linear Model Framework</p></a></li>
<li><a href='#bayes_sim_unknownvar'><p>Bayesian Simulation with Composite Sampling</p></a></li>
<li><a href='#gen_Xn'><p>Design Matrix Generator</p></a></li>
<li><a href='#gen_Xn_longitudinal'><p>Design Matrix Generator in Longitudinal Setting</p></a></li>
<li><a href='#pwr_curve'><p>Plotting Power and Assurance Curves Simultaneously</p></a></li>
<li><a href='#pwr_freq'><p>Frequentist Power Computation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Assurance Computation</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Computes Bayesian assurance under various 
    settings characterized by different assumptions and objectives, including 
    precision-based conditions, credible intervals, and goal functions. 
    All simulation-based functions included in this package rely on a two-stage 
    Bayesian method that assigns two distinct priors to evaluate the 
    probability of observing a positive outcome, which addresses subtle 
    limitations that take place when using the standard single-prior approach. 
    For more information, please refer to Pan and Banerjee (2021)
    &lt;<a href="https://doi.org/10.48550/arXiv.2112.03509">doi:10.48550/arXiv.2112.03509</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jpan928/bayesassurance_rpackage">https://github.com/jpan928/bayesassurance_rpackage</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0),</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2 (&ge; 3.3.5), plotly (&ge; 4.10.0), plot3D (&ge; 1.4),
pbapply (&ge; 1.5.0), dplyr (&ge; 1.0.8), MASS (&ge; 7.3.55), rlang
(&ge; 1.0.2), stats (&ge; 4.0.5), mathjaxr (&ge; 1.5.2)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jane Pan &lt;jpan1@ucla.edu&gt;</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-06-17 04:09:53 UTC; janepan</td>
</tr>
<tr>
<td>Author:</td>
<td>Jane Pan [cre, aut],
  Sudipto Banerjee [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-06-17 10:40:17 UTC</td>
</tr>
</table>
<hr>
<h2 id='assurance_nd_na'>Bayesian Assurance Computation</h2><span id='topic+assurance_nd_na'></span>

<h3>Description</h3>

<p>Takes in a set of parameters and returns the exact Bayesian
assurance based on a closed-formed solution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assurance_nd_na(n, n_a, n_d, theta_0, theta_1, sigsq, alt, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assurance_nd_na_+3A_n">n</code></td>
<td>
<p>sample size (either scalar or vector)</p>
</td></tr>
<tr><td><code id="assurance_nd_na_+3A_n_a">n_a</code></td>
<td>
<p>sample size at analysis stage that quantifies the amount
of prior information we have for parameter <code class="reqn">\theta</code>. This should
be a single scalar value.</p>
</td></tr>
<tr><td><code id="assurance_nd_na_+3A_n_d">n_d</code></td>
<td>
<p>sample size at design stage that quantifies the amount of
prior information we have for where the data is being generated from.
This should be a single scalar value.</p>
</td></tr>
<tr><td><code id="assurance_nd_na_+3A_theta_0">theta_0</code></td>
<td>
<p>parameter value that is known a priori
(typically provided by the client)</p>
</td></tr>
<tr><td><code id="assurance_nd_na_+3A_theta_1">theta_1</code></td>
<td>
<p>alternative parameter value that will be
tested in comparison to theta_0. See alt for specification options.</p>
</td></tr>
<tr><td><code id="assurance_nd_na_+3A_sigsq">sigsq</code></td>
<td>
<p>known variance <code class="reqn">\sigma^2</code>.</p>
</td></tr>
<tr><td><code id="assurance_nd_na_+3A_alt">alt</code></td>
<td>
<p>specifies alternative test case, where <code>alt = "greater"</code>
tests if <code class="reqn">\theta_1 &gt; \theta_0</code>, <code>alt = "less"</code> tests if
<code class="reqn">\theta_1 &lt; \theta_0</code>, and <code>alt = "two.sided"</code>
performs a two-sided test. <code>alt = "greater"</code> by default.</p>
</td></tr>
<tr><td><code id="assurance_nd_na_+3A_alpha">alpha</code></td>
<td>
<p>significance level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>objects corresponding to the assurance
</p>

<ul>
<li><p>assurance_table: table of sample sizes and
corresponding assurance values.
</p>
</li>
<li><p>assurance_plot: assurance curve that is only
returned if n is a vector. This curve covers a wider range
of sample sizes than the inputted values specified
for n, where specific assurance values are marked in red.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
## Assign the following fixed parameters to determine the Bayesian assurance
## for the given vector of sample sizes.
n &lt;- seq(10, 250, 5)
n_a &lt;- 1e-8
n_d &lt;- 1e+8
theta_0 &lt;- 0.15
theta_1 &lt;- 0.25
sigsq &lt;- 0.104
assur_vals &lt;- assurance_nd_na(n = n, n_a = n_a, n_d = n_d, 
theta_0 = theta_0, theta_1 = theta_1,
sigsq = sigsq, alt = "two.sided", alpha = 0.05)
assur_vals$assurance_plot
</code></pre>

<hr>
<h2 id='bayes_adcock'>Bayesian Assurance Computation in the Precision-Based Setting</h2><span id='topic+bayes_adcock'></span>

<h3>Description</h3>

<p>Returns the Bayesian assurance of observing that the
absolute difference between the true underlying
population parameter and the sample estimate falls within a margin
of error no greater than a fixed precision level, d.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayes_adcock(
  n,
  d,
  mu_beta_a,
  mu_beta_d,
  n_a,
  n_d,
  sig_sq,
  alpha,
  mc_iter = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bayes_adcock_+3A_n">n</code></td>
<td>
<p>sample size (either vector or scalar).</p>
</td></tr>
<tr><td><code id="bayes_adcock_+3A_d">d</code></td>
<td>
<p>fixed precision level</p>
</td></tr>
<tr><td><code id="bayes_adcock_+3A_mu_beta_a">mu_beta_a</code></td>
<td>
<p>analysis stage mean</p>
</td></tr>
<tr><td><code id="bayes_adcock_+3A_mu_beta_d">mu_beta_d</code></td>
<td>
<p>design stage mean</p>
</td></tr>
<tr><td><code id="bayes_adcock_+3A_n_a">n_a</code></td>
<td>
<p>sample size at analysis stage. Also quantifies the amount of
prior information we have for parameter <code class="reqn">\mu</code>.</p>
</td></tr>
<tr><td><code id="bayes_adcock_+3A_n_d">n_d</code></td>
<td>
<p>sample size at design stage. Also quantifies the amount
of prior information we have for where the data is being generated from.</p>
</td></tr>
<tr><td><code id="bayes_adcock_+3A_sig_sq">sig_sq</code></td>
<td>
<p>known variance <code class="reqn">\sigma^2</code>.</p>
</td></tr>
<tr><td><code id="bayes_adcock_+3A_alpha">alpha</code></td>
<td>
<p>significance level</p>
</td></tr>
<tr><td><code id="bayes_adcock_+3A_mc_iter">mc_iter</code></td>
<td>
<p>number of MC samples evaluated under the analysis objective</p>
</td></tr>
</table>


<h3>Value</h3>

<p>approximate Bayesian assurance under precision-based conditions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- seq(20, 145, 5)
out &lt;- bayes_adcock(n = n, d = 0.20, mu_beta_a = 0.64, mu_beta_d = 0.9,
                      n_a = 20, n_d = 10, sig_sq = 0.265,
                      alpha = 0.05, mc_iter = 1000)
head(out$assurance_table)
out$assurance_plot
</code></pre>

<hr>
<h2 id='bayes_goal_func'>Decision Making using Rate of Correct Classification</h2><span id='topic+bayes_goal_func'></span>

<h3>Description</h3>

<p>Determines the rate of correctly classifying the linear hypothesis
as true or false, where the hypothesis test is specified as
</p>
<p style="text-align: center;"><code class="reqn">H0: u'\beta = c0</code>
</p>
 <p style="text-align: center;"><code class="reqn">vs.</code>
</p>
 <p style="text-align: center;"><code class="reqn">H1: u'\beta = c1</code>
</p>
<p>. See
vignette for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayes_goal_func(n, Xn = NULL, K, pi, sigsq, u, beta_0, beta_1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bayes_goal_func_+3A_n">n</code></td>
<td>
<p>sample size (vector or scalar).</p>
</td></tr>
<tr><td><code id="bayes_goal_func_+3A_xn">Xn</code></td>
<td>
<p>design matrix that characterizing the data. This is
specifically given by the normal linear regression model
</p>
<p style="text-align: center;"><code class="reqn">yn = Xn\beta + \epsilon,</code>
</p>
 <p style="text-align: center;"><code class="reqn">\epsilon ~ N(0, \sigma^2 I_n),</code>
</p>

<p>where <code class="reqn">I_n</code> is an <code class="reqn">n</code> by <code class="reqn">n</code> identity matrix.
When set to <code>NULL</code>, an appropriate <code>Xn</code> is automatically generated
<code>bayesassurance::gen_Xn()</code>. Note that setting <code>Xn = NULL</code>
also enables user to pass in a vector of sample sizes to undergo
evaluation as the function will automatically adjust <code>Xn</code> accordingly
based on the sample size.</p>
</td></tr>
<tr><td><code id="bayes_goal_func_+3A_k">K</code></td>
<td>
<p>The amount of utility associated with <code class="reqn">H0</code> being correctly
accepted.The null hypothesis is not rejected if the posterior probability
of <code class="reqn">H0</code> is at least <code class="reqn">1/(1+K)</code>.</p>
</td></tr>
<tr><td><code id="bayes_goal_func_+3A_pi">pi</code></td>
<td>
<p>constant corresponding to the prior on parameter <code class="reqn">\beta</code>
such that <code class="reqn">P(u'\beta_0) = 1 - P(u'\beta_1) = \pi</code>.</p>
</td></tr>
<tr><td><code id="bayes_goal_func_+3A_sigsq">sigsq</code></td>
<td>
<p>variance constant of the linear regression model</p>
</td></tr>
<tr><td><code id="bayes_goal_func_+3A_u">u</code></td>
<td>
<p>fixed scalar or vector of the same dimension as <code class="reqn">\beta_0</code> and
<code class="reqn">\beta_1</code></p>
</td></tr>
<tr><td><code id="bayes_goal_func_+3A_beta_0">beta_0</code></td>
<td>
<p>fixed scalar or vector that null hypothesis is set to</p>
</td></tr>
<tr><td><code id="bayes_goal_func_+3A_beta_1">beta_1</code></td>
<td>
<p>fixed scalar or vector that alternative hypothesis is set to</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of objects corresponding to the rate of classifications
</p>

<ul>
<li><p>rc_table: table of sample size and corresponding correct
classification rates
</p>
</li>
<li><p>rc_plot: plot of correct classification rates for varying
sample sizes
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Example
n &lt;- seq(100, 1200, 10)
out &lt;- bayesassurance::bayes_goal_func(n, Xn = NULL, K = 1, pi = 0.5,
sigsq = 1, u = 1, beta_0 = 0.5, beta_1 = 0.6)
out$rc_plot
</code></pre>

<hr>
<h2 id='bayes_sim'>Bayesian Simulation in Conjugate Linear Model Framework</h2><span id='topic+bayes_sim'></span>

<h3>Description</h3>

<p>Approximates the Bayesian assurance of attaining either <code class="reqn">u'\beta &gt; C</code>,
<code class="reqn">u'\beta &lt; C</code>, or <code class="reqn">u'\beta \neq C</code>,
for equal-sized samples through Monte Carlo sampling.
The function also carries the capability to process longitudinal data.
See Argument descriptions for more detail.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayes_sim(
  n,
  p = NULL,
  u,
  C,
  Xn = NULL,
  Vn = NULL,
  Vbeta_d,
  Vbeta_a_inv,
  sigsq,
  mu_beta_d,
  mu_beta_a,
  alt = "two.sided",
  alpha,
  mc_iter,
  longitudinal = FALSE,
  ids = NULL,
  from = NULL,
  to = NULL,
  poly_degree = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bayes_sim_+3A_n">n</code></td>
<td>
<p>sample size (either scalar or vector). When <code>longitudinal = TRUE</code>,
<code>n</code> denotes the number of observations per subject.</p>
</td></tr>
<tr><td><code id="bayes_sim_+3A_p">p</code></td>
<td>
<p>column dimension of design matrix <code>Xn</code>. If <code>Xn = NULL</code>,
<code>p</code> must be specified to denote the column dimension of the default
design matrix generated by the function.</p>
</td></tr>
<tr><td><code id="bayes_sim_+3A_u">u</code></td>
<td>
<p>a scalar or vector included in the expression to be evaluated,
e.g. </p>
<p style="text-align: center;"><code class="reqn">u'\beta &gt; C,</code>
</p>
<p> where <code class="reqn">\beta</code> is an unknown parameter
that is to be estimated.</p>
</td></tr>
<tr><td><code id="bayes_sim_+3A_c">C</code></td>
<td>
<p>constant to be compared</p>
</td></tr>
<tr><td><code id="bayes_sim_+3A_xn">Xn</code></td>
<td>
<p>design matrix that characterizes where the data is to be
generated from. This is specifically given by the normal linear
regression model </p>
<p style="text-align: center;"><code class="reqn">yn = Xn\beta + \epsilon,</code>
</p>

<p style="text-align: center;"><code class="reqn">\epsilon ~ N(0, \sigma^2 Vn).</code>
</p>
<p> When set to <code>NULL</code>, <code>Xn</code> is generated
in-function using either <code>bayesassurance::gen_Xn()</code> or
<code>bayesassurance::gen_Xn_longitudinal()</code>. Note that setting <code>Xn = NULL</code>
also enables user to pass in a vector of sample sizes to undergo evaluation
as the function will automatically adjust <code>Xn</code> accordingly based on the
sample size.</p>
</td></tr>
<tr><td><code id="bayes_sim_+3A_vn">Vn</code></td>
<td>
<p>a correlation matrix for the marginal distribution of the sample
data <code class="reqn">yn</code>. Takes on an identity matrix when set to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="bayes_sim_+3A_vbeta_d">Vbeta_d</code></td>
<td>
<p>correlation matrix that helps describe the prior information
on <code class="reqn">\beta</code> in the design stage</p>
</td></tr>
<tr><td><code id="bayes_sim_+3A_vbeta_a_inv">Vbeta_a_inv</code></td>
<td>
<p>inverse-correlation matrix that helps describe the prior
information on <code class="reqn">\beta</code> in the analysis stage</p>
</td></tr>
<tr><td><code id="bayes_sim_+3A_sigsq">sigsq</code></td>
<td>
<p>a known and fixed constant preceding all correlation matrices
<code>Vn</code>, <code>Vbeta_d</code>, and <code>Vbeta_a_inv</code>.</p>
</td></tr>
<tr><td><code id="bayes_sim_+3A_mu_beta_d">mu_beta_d</code></td>
<td>
<p>design stage mean</p>
</td></tr>
<tr><td><code id="bayes_sim_+3A_mu_beta_a">mu_beta_a</code></td>
<td>
<p>analysis stage mean</p>
</td></tr>
<tr><td><code id="bayes_sim_+3A_alt">alt</code></td>
<td>
<p>specifies alternative test case, where alt = &quot;greater&quot; tests if
<code class="reqn">u'\beta &gt; C</code>, alt = &quot;less&quot; tests if <code class="reqn">u'\beta &lt; C</code>, and
alt = &quot;two.sided&quot; performs a two-sided test. By default, alt = &quot;greater&quot;.</p>
</td></tr>
<tr><td><code id="bayes_sim_+3A_alpha">alpha</code></td>
<td>
<p>significance level</p>
</td></tr>
<tr><td><code id="bayes_sim_+3A_mc_iter">mc_iter</code></td>
<td>
<p>number of MC samples evaluated under the analysis objective</p>
</td></tr>
<tr><td><code id="bayes_sim_+3A_longitudinal">longitudinal</code></td>
<td>
<p>when set to <code>TRUE</code>, constructs design matrix using
inputs that correspond to a balanced longitudinal study design.</p>
</td></tr>
<tr><td><code id="bayes_sim_+3A_ids">ids</code></td>
<td>
<p>vector of unique subject ids, usually of length 2
for study design purposes.</p>
</td></tr>
<tr><td><code id="bayes_sim_+3A_from">from</code></td>
<td>
<p>start time of repeated measures for
each subject</p>
</td></tr>
<tr><td><code id="bayes_sim_+3A_to">to</code></td>
<td>
<p>end time of repeated measures for each
subject</p>
</td></tr>
<tr><td><code id="bayes_sim_+3A_poly_degree">poly_degree</code></td>
<td>
<p>only needed if <code>longitudinal = TRUE</code>, specifies
highest degree taken in the longitudinal model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of objects corresponding to the assurance approximations
</p>

<ul>
<li><p>assurance_table: table of sample size and corresponding assurance
values
</p>
</li>
<li><p>assur_plot: plot of assurance values
</p>
</li>
<li><p>mc_samples: number of Monte Carlo samples that were generated
and evaluated
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+pwr_freq">pwr_freq</a></code> for frequentist power function,
<code><a href="#topic+assurance_nd_na">assurance_nd_na</a></code> for a closed form assurance function, and
<code><a href="#topic+bayes_sim_unknownvar">bayes_sim_unknownvar</a></code> for a Bayesian assurance function
assumes unvariance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example 1
## A single Bayesian assurance value obtained given a scalar sample size
## n and p=1. Note that setting p=1 implies that
## beta is a scalar parameter.

bayesassurance::bayes_sim(n=100, p = 1, u = 1, C = 0.15, Xn = NULL, 
Vbeta_d = 1e-8, Vbeta_a_inv = 0, Vn = NULL, sigsq = 0.265, mu_beta_d = 0.3, 
mu_beta_a = 0, alt = "two.sided", alpha = 0.05, mc_iter = 5000)


## Example 2
## Illustrates a scenario in which weak analysis priors and strong 
## design priors are assigned to enable overlap between the frequentist 
## power and Bayesian assurance.


library(ggplot2)
n &lt;- seq(100, 250, 5)

 ## Frequentist Power
 power &lt;- bayesassurance::pwr_freq(n, sigsq = 0.265, theta_0 = 0.15,
 theta_1 = 0.25, alt = "greater", alpha = 0.05)

 ## Bayesian simulation values with specified values from the n vector
 assurance &lt;- bayesassurance::bayes_sim(n, p = 1, u = 1, C = 0.15, Xn = NULL,
 Vbeta_d = 1e-8, Vbeta_a_inv = 0, Vn = NULL, sigsq = 0.265, mu_beta_d = 0.25,
 mu_beta_a = 0, alt = "greater", alpha = 0.05, mc_iter = 1000)

## Visual representation of plots overlayed on top of one another
df1 &lt;- as.data.frame(cbind(n, power = power$pwr_table$Power))
df2 &lt;- as.data.frame(cbind(n, assurance = 
assurance$assurance_table$Assurance))

plot_curves &lt;- ggplot2::ggplot(df1, alpha = 0.5, ggplot2::aes(x = n, y = power,
color="Frequentist")) + ggplot2::geom_line(lwd=1.2)
plot_curves &lt;- plot_curves + ggplot2::geom_point(data = df2, alpha = 0.5,
aes(x = n, y = assurance, color="Bayesian"),lwd=1.2) +
ggplot2::ggtitle("Bayesian Simulation vs. Frequentist Power Computation")
plot_curves


## Example 3
## Longitudinal example where n now denotes the number of repeated measures 
## per subject and design matrix is determined accordingly.

## subject ids
n &lt;- seq(10, 100, 5)
ids &lt;- c(1,2)
sigsq &lt;- 100
Vbeta_a_inv &lt;- matrix(rep(0, 16), nrow = 4, ncol = 4)
Vbeta_d &lt;- (1 / sigsq) * 
matrix(c(4, 0, 3, 0, 0, 6, 0, 0, 3, 0, 4, 0, 0, 0, 0, 6), 
nrow = 4, ncol = 4)

assur_out &lt;- bayes_sim(n = n, p = NULL, u = c(1, -1, 1, -1), C = 0, 
                      Xn = NULL, Vbeta_d = Vbeta_d, 
                      Vbeta_a_inv = Vbeta_a_inv,
                      Vn = NULL, sigsq = 100,
                      mu_beta_d = as.matrix(c(5, 6.5, 62, 84)),
                      mu_beta_a = as.matrix(rep(0, 4)), mc_iter = 1000,
                      alt = "two.sided", alpha = 0.05, 
                      longitudinal = TRUE, ids = ids,
                      from = 10, to = 120)
assur_out$assurance_plot

</code></pre>

<hr>
<h2 id='bayes_sim_betabin'>Bayesian Assurance Computation in the Beta-Binomial Setting</h2><span id='topic+bayes_sim_betabin'></span>

<h3>Description</h3>

<p>Returns the Bayesian assurance corresponding to a hypothesis test for
difference in two independent proportions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayes_sim_betabin(
  n1,
  n2,
  p1,
  p2,
  alpha_1,
  alpha_2,
  beta_1,
  beta_2,
  sig_level,
  alt,
  mc_iter
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bayes_sim_betabin_+3A_n1">n1</code></td>
<td>
<p>sample size of first group</p>
</td></tr>
<tr><td><code id="bayes_sim_betabin_+3A_n2">n2</code></td>
<td>
<p>sample size of second group</p>
</td></tr>
<tr><td><code id="bayes_sim_betabin_+3A_p1">p1</code></td>
<td>
<p>proportion of successes in first group. Takes on a NULL (default)
assignment if unknown.</p>
</td></tr>
<tr><td><code id="bayes_sim_betabin_+3A_p2">p2</code></td>
<td>
<p>proportion of successes in second group. Takes on a NULL
(default) assignment if unknown.</p>
</td></tr>
<tr><td><code id="bayes_sim_betabin_+3A_alpha_1">alpha_1</code>, <code id="bayes_sim_betabin_+3A_beta_1">beta_1</code></td>
<td>
<p>shape parameters for the distribution of <code>p1</code>
if <code>p1</code> is unknown: <code class="reqn">p1 ~ Beta(\alpha_1, \beta_1)</code></p>
</td></tr>
<tr><td><code id="bayes_sim_betabin_+3A_alpha_2">alpha_2</code>, <code id="bayes_sim_betabin_+3A_beta_2">beta_2</code></td>
<td>
<p>shape parameters for the distribution of p2 if
p2 is unknown: <code class="reqn">p2 ~ Beta(\alpha_2, \beta_2)</code></p>
</td></tr>
<tr><td><code id="bayes_sim_betabin_+3A_sig_level">sig_level</code></td>
<td>
<p>significance level</p>
</td></tr>
<tr><td><code id="bayes_sim_betabin_+3A_alt">alt</code></td>
<td>
<p>a character string specifying the alternative hypothesis,
must select one of following choices: <code>"two.sided"</code> (default),
<code>"greater"</code> or <code>"less"</code>.</p>
</td></tr>
<tr><td><code id="bayes_sim_betabin_+3A_mc_iter">mc_iter</code></td>
<td>
<p>number of MC samples evaluated under the analysis objective</p>
</td></tr>
</table>


<h3>Value</h3>

<p>approximate Bayesian assurance of independent two-sample proportion
test
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#########################################################
# alpha1 = 0.5, beta1 = 0.5, alpha2 = 0.5, beta2 = 0.5 ##
#########################################################
n &lt;- seq(200, 1000, 10)
assur_vals &lt;- bayesassurance::bayes_sim_betabin(n1 = n, n2 = n, 
p1 = 0.25, p2 = 0.2, alpha_1 = 0.5, beta_1 = 0.5, alpha_2 = 0.5, 
beta_2 = 0.5, sig_level = 0.05, alt = "greater", mc_iter = 1000)

assur_vals$assurance_table
assur_vals$assurance_plot

</code></pre>

<hr>
<h2 id='bayes_sim_unbalanced'>Unbalanced Bayesian Simulation in Conjugate Linear Model Framework</h2><span id='topic+bayes_sim_unbalanced'></span>

<h3>Description</h3>

<p>Approximates the Bayesian assurance of attaining <code class="reqn">u'\beta &gt; C</code>
for unbalanced study designs through Monte Carlo sampling.
See Argument descriptions for more detail.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayes_sim_unbalanced(
  n1,
  n2,
  repeats = 1,
  u,
  C,
  Xn = NULL,
  Vn = NULL,
  Vbeta_d,
  Vbeta_a_inv,
  sigsq,
  mu_beta_d,
  mu_beta_a,
  alt,
  alpha,
  mc_iter,
  surface_plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bayes_sim_unbalanced_+3A_n1">n1</code></td>
<td>
<p>first sample size (vector or scalar).</p>
</td></tr>
<tr><td><code id="bayes_sim_unbalanced_+3A_n2">n2</code></td>
<td>
<p>second sample size (vector or scalar).</p>
</td></tr>
<tr><td><code id="bayes_sim_unbalanced_+3A_repeats">repeats</code></td>
<td>
<p>an positive integer specifying number of times to repeat
<code>c(n1, n2)</code>. Applicable for studies that consider multiple measures
within each group. Default setting is <code>repeats = 1</code> if not applicable.</p>
</td></tr>
<tr><td><code id="bayes_sim_unbalanced_+3A_u">u</code></td>
<td>
<p>a scalar or vector to evaluate </p>
<p style="text-align: center;"><code class="reqn">u'\beta &gt; C,</code>
</p>

<p>where <code class="reqn">\beta</code> is an unknown parameter that is to be estimated.
Default setting is <code>u = 1</code>.</p>
</td></tr>
<tr><td><code id="bayes_sim_unbalanced_+3A_c">C</code></td>
<td>
<p>constant value to be compared to when evaluating <code class="reqn">u'\beta &gt; C</code></p>
</td></tr>
<tr><td><code id="bayes_sim_unbalanced_+3A_xn">Xn</code></td>
<td>
<p>design matrix that characterizes where the data is to be
generated from. This is specifically designed under the normal linear
regression model </p>
<p style="text-align: center;"><code class="reqn">yn = Xn\beta + \epsilon,</code>
</p>

<p style="text-align: center;"><code class="reqn">\epsilon ~ N(0, \sigma^2 Vn).</code>
</p>
<p> When set to <code>NULL</code>,
<code>Xn</code> is generated in-function using <code>bayesassurance::gen_Xn()</code>.
Note that setting <code>Xn = NULL</code> also enables user to pass in a
vector of sample sizes to undergo evaluation.</p>
</td></tr>
<tr><td><code id="bayes_sim_unbalanced_+3A_vn">Vn</code></td>
<td>
<p>a correlation matrix for the marginal distribution of the
sample data <code>yn</code>. Takes on an identity matrix when set to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="bayes_sim_unbalanced_+3A_vbeta_d">Vbeta_d</code></td>
<td>
<p>correlation matrix that helps describe the prior
information on <code class="reqn">\beta</code> in the design stage</p>
</td></tr>
<tr><td><code id="bayes_sim_unbalanced_+3A_vbeta_a_inv">Vbeta_a_inv</code></td>
<td>
<p>inverse-correlation matrix that helps describe the prior
information on <code class="reqn">\beta</code> in the analysis stage</p>
</td></tr>
<tr><td><code id="bayes_sim_unbalanced_+3A_sigsq">sigsq</code></td>
<td>
<p>a known and fixed constant preceding all correlation matrices
<code>Vn</code>, <code>Vbeta_d</code> and <code>Vbeta_a_inv</code>.</p>
</td></tr>
<tr><td><code id="bayes_sim_unbalanced_+3A_mu_beta_d">mu_beta_d</code></td>
<td>
<p>design stage mean</p>
</td></tr>
<tr><td><code id="bayes_sim_unbalanced_+3A_mu_beta_a">mu_beta_a</code></td>
<td>
<p>analysis stage mean</p>
</td></tr>
<tr><td><code id="bayes_sim_unbalanced_+3A_alt">alt</code></td>
<td>
<p>specifies alternative test case, where alt = &quot;greater&quot; tests if
<code class="reqn">u'\beta &gt; C</code>,
alt = &quot;less&quot; tests if <code class="reqn">u'\beta &lt; C</code>, and alt = &quot;two.sided&quot;
performs a two-sided test. By default, alt = &quot;greater&quot;.</p>
</td></tr>
<tr><td><code id="bayes_sim_unbalanced_+3A_alpha">alpha</code></td>
<td>
<p>significance level</p>
</td></tr>
<tr><td><code id="bayes_sim_unbalanced_+3A_mc_iter">mc_iter</code></td>
<td>
<p>number of MC samples evaluated under the analysis objective</p>
</td></tr>
<tr><td><code id="bayes_sim_unbalanced_+3A_surface_plot">surface_plot</code></td>
<td>
<p>when set to <code>TRUE</code> and <code class="reqn">n1</code> and <code class="reqn">n2</code> are vectors,
a contour map showcasing various assurance values corresponding to
different combinations of <code class="reqn">n1</code> and <code class="reqn">n2</code> is produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of objects corresponding to the assurance approximations
</p>

<ul>
<li><p>assurance_table: table of sample size and corresponding assurance
values
</p>
</li>
<li><p>contourplot: contour map of assurance values
</p>
</li>
<li><p>mc_samples: number of Monte Carlo samples that were generated
and evaluated
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Example 1
## Sample size vectors are passed in for n1 and n2 to evaluate
## assurance. 
n1 &lt;- seq(20, 75, 5)
n2 &lt;- seq(50, 160, 10)

assur_out &lt;- bayes_sim_unbalanced(n1 = n1, n2 = n2, repeats = 1, u = c(1, -1),
C = 0, Xn = NULL, Vbeta_d = matrix(c(50, 0, 0, 10),nrow = 2, ncol = 2),
Vbeta_a_inv = matrix(rep(0, 4), nrow = 2, ncol = 2),
Vn = NULL, sigsq = 100,  mu_beta_d = c(1.17, 1.25),
mu_beta_a = c(0, 0), alt = "two.sided", alpha = 0.05, mc_iter = 1000,
surface_plot = FALSE)

assur_out$assurance_table


## Example 2
## We can produce a contour plot that evaluates unique combinations of n1
## and n2 simply by setting `surfaceplot = TRUE`.

n1 &lt;- seq(20, 75, 5)
n2 &lt;- seq(50, 160, 10)
assur_out &lt;- bayes_sim_unbalanced(n1 = n1, n2 = n2, repeats = 1, 
u = c(1, -1), C = 0, Xn = NULL, Vbeta_d = matrix(c(50, 0, 0, 10),
nrow = 2, ncol = 2), Vbeta_a_inv = matrix(rep(0, 4), nrow = 2, ncol = 2),
Vn = NULL, sigsq = 100,  mu_beta_d = c(1.17, 1.25),
mu_beta_a = c(0, 0), alt = "two.sided", alpha = 0.05, mc_iter = 1000,
surface_plot = TRUE)

assur_out$assurance_table
assur_out$contourplot

</code></pre>

<hr>
<h2 id='bayes_sim_unknownvar'>Bayesian Simulation with Composite Sampling</h2><span id='topic+bayes_sim_unknownvar'></span>

<h3>Description</h3>

<p>Approximates the Bayesian assurance of a one-sided hypothesis test
through Monte Carlo sampling with the added assumption that
the variance is unknown.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayes_sim_unknownvar(
  n,
  p = NULL,
  u,
  C,
  R,
  Xn = NULL,
  Vn,
  Vbeta_d,
  Vbeta_a_inv,
  mu_beta_d,
  mu_beta_a,
  a_sig_a,
  b_sig_a,
  a_sig_d,
  b_sig_d,
  alt = "greater",
  alpha,
  mc_iter
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bayes_sim_unknownvar_+3A_n">n</code></td>
<td>
<p>sample size (either vector or scalar)</p>
</td></tr>
<tr><td><code id="bayes_sim_unknownvar_+3A_p">p</code></td>
<td>
<p>column dimension of design matrix <code>Xn</code>. If <code>Xn = NULL</code>,
<code>p</code> must be specified to denote the column dimension of the default
design matrix generated
by the function.</p>
</td></tr>
<tr><td><code id="bayes_sim_unknownvar_+3A_u">u</code></td>
<td>
<p>a scalar or vector to evaluate </p>
<p style="text-align: center;"><code class="reqn">u'\beta &gt; C,</code>
</p>

<p>where <code class="reqn">\beta</code> is an unknown parameter that is to be estimated.</p>
</td></tr>
<tr><td><code id="bayes_sim_unknownvar_+3A_c">C</code></td>
<td>
<p>constant value to be compared to when evaluating <code class="reqn">u'\beta &gt; C</code></p>
</td></tr>
<tr><td><code id="bayes_sim_unknownvar_+3A_r">R</code></td>
<td>
<p>number of iterations we want to pass through to check for
satisfaction of the analysis stage objective. The proportion of those
iterations meeting the analysis objective corresponds to the approximated
Bayesian assurance.</p>
</td></tr>
<tr><td><code id="bayes_sim_unknownvar_+3A_xn">Xn</code></td>
<td>
<p>design matrix that characterizes where the data is to be generated
from. This is specifically given by the normal linear regression model
</p>
<p style="text-align: center;"><code class="reqn">yn = Xn\beta + \epsilon,</code>
</p>
 <p style="text-align: center;"><code class="reqn">\epsilon ~ N(0, \sigma^2 Vn),</code>
</p>

<p>where <code class="reqn">\sigma^2</code> is unknown in this setting. Note that
<code>Xn</code> must have column dimension <code>p</code>.</p>
</td></tr>
<tr><td><code id="bayes_sim_unknownvar_+3A_vn">Vn</code></td>
<td>
<p>an <code>n</code> by <code>n</code> correlation matrix for the marginal distribution
of the sample data <code>yn</code>. Takes on an identity matrix when set to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="bayes_sim_unknownvar_+3A_vbeta_d">Vbeta_d</code></td>
<td>
<p>correlation matrix that helps describe the prior information
on <code class="reqn">\beta</code> in the design stage</p>
</td></tr>
<tr><td><code id="bayes_sim_unknownvar_+3A_vbeta_a_inv">Vbeta_a_inv</code></td>
<td>
<p>inverse-correlation matrix that helps describe the prior
information on <code class="reqn">\beta</code> in the analysis stage</p>
</td></tr>
<tr><td><code id="bayes_sim_unknownvar_+3A_mu_beta_d">mu_beta_d</code></td>
<td>
<p>design stage mean</p>
</td></tr>
<tr><td><code id="bayes_sim_unknownvar_+3A_mu_beta_a">mu_beta_a</code></td>
<td>
<p>analysis stage mean</p>
</td></tr>
<tr><td><code id="bayes_sim_unknownvar_+3A_a_sig_a">a_sig_a</code>, <code id="bayes_sim_unknownvar_+3A_b_sig_a">b_sig_a</code></td>
<td>
<p>shape and scale parameters of the inverse
gamma distribution where variance <code class="reqn">\sigma^2</code>
is sampled from in the analysis stage</p>
</td></tr>
<tr><td><code id="bayes_sim_unknownvar_+3A_a_sig_d">a_sig_d</code>, <code id="bayes_sim_unknownvar_+3A_b_sig_d">b_sig_d</code></td>
<td>
<p>shape and scale parameters of the inverse gamma
distribution where variance <code class="reqn">\sigma^2</code> is sampled from in the design
stage</p>
</td></tr>
<tr><td><code id="bayes_sim_unknownvar_+3A_alt">alt</code></td>
<td>
<p>specifies alternative test case, where <code>alt = "greater"</code>
tests if <code class="reqn">u'\beta &gt; C</code>, <code>alt = "less"</code> tests if <code class="reqn">u'\beta &lt; C</code>,
and <code>alt = "two.sided"</code> performs a two-sided test. By default,
<code>alt = "greater"</code>.</p>
</td></tr>
<tr><td><code id="bayes_sim_unknownvar_+3A_alpha">alpha</code></td>
<td>
<p>significance level</p>
</td></tr>
<tr><td><code id="bayes_sim_unknownvar_+3A_mc_iter">mc_iter</code></td>
<td>
<p>number of MC samples evaluated under the analysis objective</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of objects corresponding to the assurance approximations
</p>

<ul>
<li><p>assurance_table: table of sample size and corresponding assurance
values
</p>
</li>
<li><p>assur_plot: plot of assurance values
</p>
</li>
<li><p>mc_samples: number of Monte Carlo samples that were generated
and evaluated
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+bayes_sim">bayes_sim</a></code> for the Bayesian assurance function
for known variance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## O'Hagan and Stevens (2001) include a series of examples with 
## pre-specified parameters that we will be using to replicate their 
## results through our Bayesian assurance simulation.
## The inputs are as follows:

n &lt;- 285
p &lt;- 4 ## includes two parameter measures (cost and efficacy) for each of 
       ## the two treatments, for a total of p = 4 parameters. 
K &lt;- 20000
C &lt;- 0
u &lt;- as.matrix(c(-K, 1, K, -1))

## Set up correlation matrices
Vbeta_a_inv &lt;- matrix(rep(0, p^2), nrow = p, ncol = p)

sigsq &lt;- 4.04^2
tau1 &lt;- tau2 &lt;- 8700
sig &lt;- sqrt(sigsq)
Vn &lt;- matrix(0, nrow = n*p, ncol = n*p)
Vn[1:n, 1:n] &lt;- diag(n)
Vn[(2*n - (n-1)):(2*n), (2*n - (n-1)):(2*n)] &lt;- (tau1 / sig)^2 * diag(n)
Vn[(3*n - (n-1)):(3*n), (3*n - (n-1)):(3*n)] &lt;- diag(n)
Vn[(4*n - (n-1)):(4*n), (4*n - (n-1)):(4*n)] &lt;- (tau2 / sig)^2 * diag(n)

Vbeta_d &lt;- (1 / sigsq) * 
matrix(c(4, 0, 3, 0, 0, 10^7, 0, 0, 3, 0, 4, 0, 0, 0, 0, 10^7),
nrow = 4, ncol = 4)
mu_beta_d &lt;- as.matrix(c(5, 6000, 6.5, 7200))
mu_beta_a &lt;- as.matrix(rep(0, p))
alpha &lt;- 0.05
epsilon &lt;- 10e-7
a_sig_d &lt;- (sigsq / epsilon) + 2
b_sig_d &lt;- sigsq * (a_sig_d - 1)
a_sig_a &lt;- -p / 2
b_sig_a &lt;- 0

bayesassurance::bayes_sim_unknownvar(n = n, p = 4, 
u = as.matrix(c(-K, 1, K, -1)), C = 0, R = 40,
Xn = NULL, Vn = Vn, Vbeta_d = Vbeta_d, 
Vbeta_a_inv = Vbeta_a_inv, mu_beta_d = mu_beta_d,
mu_beta_a = mu_beta_a, a_sig_a = a_sig_a, b_sig_a = b_sig_a, 
a_sig_d = a_sig_d, b_sig_d = b_sig_d, alt = "two.sided", alpha = 0.05, 
mc_iter = 500)

</code></pre>

<hr>
<h2 id='gen_Xn'>Design Matrix Generator</h2><span id='topic+gen_Xn'></span>

<h3>Description</h3>

<p>Constructs design matrix using given sample size(s).
Used for assurance analysis in the Bayesian setting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_Xn(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_Xn_+3A_n">n</code></td>
<td>
<p>vector of sample sizes. Length of <code>n</code> corresponds
to the number of groups being assessed in the study design
as well as the column dimension of the design matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Xn: a design matrix that can be used to assess the
Bayesian assurance through Monte Carlo sampling using
functions presented in this package.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen_Xn_longitudinal">gen_Xn_longitudinal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## In the following example, notice that passing in a vector
## of length 4 returns a design matrix of column dimension 4, where
## each column is comprised of ones vectors with lengths that correspond
## to the inputted sample sizes.

n &lt;- c(1,3,5,8)
gen_Xn(n = n)
</code></pre>

<hr>
<h2 id='gen_Xn_longitudinal'>Design Matrix Generator in Longitudinal Setting</h2><span id='topic+gen_Xn_longitudinal'></span>

<h3>Description</h3>

<p>Constructs design matrix using inputs that correspond
to a balanced longitudinal study design.
Used for power and sample size analysis in the Bayesian setting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_Xn_longitudinal(ids, from, to, num_repeated_measures, poly_degree = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_Xn_longitudinal_+3A_ids">ids</code></td>
<td>
<p>vector of unique subject ids, usually of length 2
for study design purposes.</p>
</td></tr>
<tr><td><code id="gen_Xn_longitudinal_+3A_from">from</code></td>
<td>
<p>start time of repeated measures for
each subject</p>
</td></tr>
<tr><td><code id="gen_Xn_longitudinal_+3A_to">to</code></td>
<td>
<p>end time of repeated measures for each
subject</p>
</td></tr>
<tr><td><code id="gen_Xn_longitudinal_+3A_num_repeated_measures">num_repeated_measures</code></td>
<td>
<p>desired length of the repeated measures
sequence. Should be a non-negative number, will be rounded up if fractional.</p>
</td></tr>
<tr><td><code id="gen_Xn_longitudinal_+3A_poly_degree">poly_degree</code></td>
<td>
<p>degree of polynomial in longitudinal model, set to 1 by
default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Xn: a design matrix that can be used to assess the
Bayesian assurance through Monte Carlo sampling using
functions presented in this package.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen_Xn">gen_Xn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example 1
## We pass in a vector of subject IDs and specify the start and end
## timepoints along with the desired length of the sequence.
## The resulting design matrix contains vectors of
## ones with lengths that correspond to the number of repeated
## measures for each unique subject.

ids &lt;- c(1,2,3,4)
gen_Xn_longitudinal(ids, from = 1, to = 10, num_repeated_measures = 4)

## Example 2
## If we wish to fit a longitudinal model of a higher degree (e.g. 
## parabolic, cubic), we need to adjust the `poly_degree` variable

# parabolic
ids &lt;- c(1,2,3,4)
gen_Xn_longitudinal(ids, from = 1, to = 10, num_repeated_measures = 4,
poly_degree = 2)

# cubic
ids &lt;- c(1,2,3,4)
gen_Xn_longitudinal(ids, from = 1, to = 10, num_repeated_measures = 4,
poly_degree = 3)
</code></pre>

<hr>
<h2 id='pwr_curve'>Plotting Power and Assurance Curves Simultaneously</h2><span id='topic+pwr_curve'></span>

<h3>Description</h3>

<p>Constructs a single plot based on the combined set of inputs used to
compute the frequentist power and Bayesian assurance. The plot includes
three curves that include the power curve, the assurance curve obtained
under a closed-form solution, and optionally, the assurance curve
obtained under a simulation setting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pwr_curve(
  n,
  n_a,
  n_d,
  theta_0,
  theta_1,
  sigsq,
  alt = "greater",
  alpha,
  bayes_sim = FALSE,
  mc_iter = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pwr_curve_+3A_n">n</code></td>
<td>
<p>sample size (either a scalar or vector)</p>
</td></tr>
<tr><td><code id="pwr_curve_+3A_n_a">n_a</code></td>
<td>
<p>sample size at analysis stage (setting n_a close to 0 corresponds
to a weak analysis prior)</p>
</td></tr>
<tr><td><code id="pwr_curve_+3A_n_d">n_d</code></td>
<td>
<p>sample size at design stage</p>
</td></tr>
<tr><td><code id="pwr_curve_+3A_theta_0">theta_0</code></td>
<td>
<p>parameter value that is known a priori (typically
provided by the client)</p>
</td></tr>
<tr><td><code id="pwr_curve_+3A_theta_1">theta_1</code></td>
<td>
<p>alternative parameter value that will be tested in
comparison to theta_0. See alt for specification options.</p>
</td></tr>
<tr><td><code id="pwr_curve_+3A_sigsq">sigsq</code></td>
<td>
<p>known variance <code class="reqn">\sigma^2</code></p>
</td></tr>
<tr><td><code id="pwr_curve_+3A_alt">alt</code></td>
<td>
<p>specifies alternative test case, where alt = &quot;greater&quot;
tests if theta_1 &gt; theta_0, &quot;less&quot; tests if theta_1 &lt; theta_0, and
&quot;two.sided&quot; performs a two-sided test. alt = &quot;greater&quot; by default.</p>
</td></tr>
<tr><td><code id="pwr_curve_+3A_alpha">alpha</code></td>
<td>
<p>significance level</p>
</td></tr>
<tr><td><code id="pwr_curve_+3A_bayes_sim">bayes_sim</code></td>
<td>
<p>when set to &quot;TRUE&quot;, this indicates that the user wants
to include simulated assurance results in the outputted plot.
Default setting is &quot;FALSE&quot;.</p>
</td></tr>
<tr><td><code id="pwr_curve_+3A_mc_iter">mc_iter</code></td>
<td>
<p>number of MC samples provided that bayes_sim = TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plot of overlayed power and assurance curves produced using ggplot2
</p>
<p>a list of objects corresponding to the power/assurance curves
</p>

<ul>
<li><p>power: table of sample sizes and corresponding power values
obtained from bayesassurance::pwr_freq().
</p>
</li>
<li><p>assurance_table: table of sample sizes and corresponding
assurance values obtained from bayesassurance::assurance_nd_na().
</p>
</li>
<li><p>bayes_sim_table: table of sample sizes and corresponding
assurance values obtained from MC sampling using
bayesassurance::bayes_sim(). Returned only if bayes_sim = TRUE.
</p>
</li>
<li><p>mc_samples: number of Monte Carlo samples that were generated
and evaluated if bayes_sim = TRUE.
</p>
</li>
<li><p>plot: plot of overlayed power/assurance curves.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code>, <code><a href="#topic+pwr_freq">pwr_freq</a></code> for
frequentist power function and <code><a href="#topic+bayes_sim">bayes_sim</a></code> for the
Bayesian assurance function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Case 1: Weak Analysis Prior (n_a set to be small) + Strong Design Prior
## (n_d set to be large) that results in the Bayesian assurance and 
## frequentist curve perfectly overlapping one another.

n &lt;- seq(10, 200, 10)
n_a &lt;- 1e-8
n_d &lt;- 1e+8
theta_0 &lt;- 0.15
theta_1 &lt;- 0.25
sigsq &lt;- 0.104
alpha &lt;- 0.05

## outputs all three plots
out &lt;- bayesassurance::pwr_curve(n = n, n_a = n_a, n_d = n_d, 
theta_0 = theta_0, theta_1 = theta_1, sigsq = sigsq, alt = "greater", 
alpha = alpha, bayes_sim = TRUE, mc_iter = 5000)

## only outputs the closed-form solution power and assurance curves
pwr_curve(n = n, n_a = n_a, n_d = n_d, theta_0 = theta_0, theta_1 = theta_1,
sigsq = sigsq, alt = "greater", alpha = alpha, bayes_sim = FALSE)



## Case 2: Weak Analysis Prior (n_a set to be small) + Weak Design Prior
## (n_d set to be small) that results in a assurance curve,
## which illustrates the noninformative prior setting.
n &lt;- seq(10, 200, 10)
n_a &lt;- 1e-8
n_d &lt;- 1e-8
theta_0 &lt;- 0.15
theta_1 &lt;- 0.25
sigsq &lt;- 0.104
alpha &lt;- 0.05

bayesassurance::pwr_curve(n = n, n_a = n_a, n_d = n_d, theta_0 = theta_0,
theta_1 = theta_1, sigsq = sigsq, alt = "greater", alpha = alpha, 
bayes_sim = TRUE, mc_iter = 1000)

</code></pre>

<hr>
<h2 id='pwr_freq'>Frequentist Power Computation</h2><span id='topic+pwr_freq'></span>

<h3>Description</h3>

<p>Constructs a simple hypothesis testing framework based on the parameters
specified and returns the corresponding frequentist power.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pwr_freq(n, theta_0, theta_1, sigsq, alt, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pwr_freq_+3A_n">n</code></td>
<td>
<p>sample size (either scalar or vector)</p>
</td></tr>
<tr><td><code id="pwr_freq_+3A_theta_0">theta_0</code></td>
<td>
<p>initial value the parameter is set equal to in the null
hypothesis, where <code class="reqn">H0: \theta = \theta 0</code>.</p>
</td></tr>
<tr><td><code id="pwr_freq_+3A_theta_1">theta_1</code></td>
<td>
<p>alternative value to be compared to theta_0.
See alt for specification options.</p>
</td></tr>
<tr><td><code id="pwr_freq_+3A_sigsq">sigsq</code></td>
<td>
<p>known variance <code class="reqn">\sigma^2</code></p>
</td></tr>
<tr><td><code id="pwr_freq_+3A_alt">alt</code></td>
<td>
<p>specifies comparison between <code class="reqn">\theta_1</code> and <code class="reqn">\theta_0</code>,
where <code>alt = "greater"</code> tests if <code class="reqn">\theta_1 &gt; \theta_0</code>,
<code>alt = "less"</code> tests if <code class="reqn">\theta_1 &lt; \theta_0</code>, and <code>alt = "two.sided"</code>
performs a two-sided test. <code>alt = "greater"</code> by
default.</p>
</td></tr>
<tr><td><code id="pwr_freq_+3A_alpha">alpha</code></td>
<td>
<p>significance level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>objects corresponding to the power
</p>

<ul>
<li><p>pwr_table: table of sample sizes and corresponding power
values.
</p>
</li>
<li><p>pwr_plot: power curve that is only returned if n is a vector.
This power curve covers a wider range of sample sizes than the
inputted values specified for n, where specific power values are marked
in red.
</p>
</li>
<li><p>power_val: single power value that is returned if n is a scalar.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- seq(10, 140, 5)
theta_0 &lt;- 0.15
theta_1 &lt;- 0.35
sigsq &lt;- 0.3

pwr_vals &lt;- pwr_freq(n = n, theta_0 = theta_0, theta_1 = theta_1, 
sigsq = sigsq, alt = "greater", alpha = 0.05)
pwr_vals$pwr_plot
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
