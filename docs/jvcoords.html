<!DOCTYPE html><html><head><title>Help for package jvcoords</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {jvcoords}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#jvcoords-package'><p>Package overview</p></a></li>
<li><a href='#coords'><p>An S3 class to represent affine coordinate transforms</p></a></li>
<li><a href='#PCA'><p>Perform Principal Component Analysis (PCA)</p></a></li>
<li><a href='#standardize'><p>Standardize data</p></a></li>
<li><a href='#whiten'><p>Whiten data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Principal Component Analysis (PCA) and Whitening</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-06-05</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/seehuhn/jvcoords">https://github.com/seehuhn/jvcoords</a></td>
</tr>
<tr>
<td>Description:</td>
<td>
  Provides functions to standardize and whiten data, and to perform
  Principal Component Analysis (PCA).  The main advantage of this
  package over alternatives like prcomp() is, that jvcoords makes it
  easy to convert (additional) data between the original and the
  transformed coordinates.  The package also provides a class coords,
  which can represent affine coordinate transformations.  This class
  forms the basis of the transformations provided by the package, but
  can also be used independently.  The implementation has been
  optimized to be of comparable speed (and sometimes even faster) than
  existing alternatives.</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-06-05 16:43:19 UTC; voss</td>
</tr>
<tr>
<td>Author:</td>
<td>Jochen Voss <a href="https://orcid.org/0000-0002-2323-3814"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jochen Voss &lt;voss@seehuhn.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-06-05 17:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='jvcoords-package'>Package overview</h2><span id='topic+jvcoords-package'></span>

<h3>Description</h3>

<p>The jvcoords package provides functions to standardize and whiten
data, and an implementation of Principal Component Analysis (PCA).
All three transformations are implemented using a common class
<code style="white-space: pre;">&#8288;coords&#8288;</code> which allows to easily convert data from and to the
new coordinate systems.
</p>
<p>See the documentation for <code><a href="#topic+standardize">standardize</a></code>, <code><a href="#topic+whiten">whiten</a></code>,
and <code><a href="#topic+PCA">PCA</a></code> for information on how to use this package.
</p>


<h3>Author(s)</h3>

<p>Jochen Voss &lt;voss@seehuhn.de&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+standardize">standardize</a></code>,
<code><a href="#topic+whiten">whiten</a></code>,
<code><a href="#topic+PCA">PCA</a></code>,
<code><a href="#topic+coords">coords</a></code>
</p>

<hr>
<h2 id='coords'>An S3 class to represent affine coordinate transforms</h2><span id='topic+coords'></span><span id='topic+appendTrfm'></span><span id='topic+fromCoords'></span><span id='topic+toCoords'></span>

<h3>Description</h3>

<p>Perform affine coordinate transformations.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  coords(p, name = NULL, shift = 0)
  appendTrfm(trfm, op = c("diag", "orth"), val)
  toCoords(trfm, x)
  fromCoords(trfm, y, apply.shift = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coords_+3A_p">p</code></td>
<td>
<p>The number of variables in the original data.</p>
</td></tr>
<tr><td><code id="coords_+3A_name">name</code></td>
<td>
<p>A short name for the coordinate transformation (optional).</p>
</td></tr>
<tr><td><code id="coords_+3A_shift">shift</code></td>
<td>
<p>A value subtracted from the data as the first step of the
coordinate transformation.  Usually, this will be the mean of the data
(optional).</p>
</td></tr>
<tr><td><code id="coords_+3A_trfm">trfm</code></td>
<td>
<p>An object of class <code>coords</code>.</p>
</td></tr>
<tr><td><code id="coords_+3A_op">op</code></td>
<td>
<p>The type of transformation to append.</p>
</td></tr>
<tr><td><code id="coords_+3A_val">val</code></td>
<td>
<p>Data for the transformation to append.</p>
</td></tr>
<tr><td><code id="coords_+3A_x">x</code></td>
<td>
<p>Data matrix, rows are observations, columns are variables.</p>
</td></tr>
<tr><td><code id="coords_+3A_y">y</code></td>
<td>
<p>Transformed data matrix, rows are observations, columns are variables.</p>
</td></tr>
<tr><td><code id="coords_+3A_apply.shift">apply.shift</code></td>
<td>
<p>Whether to apply the final shift of coordinates.
Set this to <code>FALSE</code> in order to only apply the linear part of the
transformation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>coords()</code> creates a new object representing an
affine coordinate transformation.  Initially, the object represents a
shift by the amount <code>shift</code>, mapping <code>p</code>-dimensional vectors
<code>x</code> to <code>x-shift</code>.  The function <code>appendTrfm()</code> can then
be used to modify the transformation.  The optional argument
<code>name</code>, if set, is used when printing objects of class
<code>coords</code>.
</p>
<p>The function <code>toCoords()</code> applies the affine transformation <code>trfm</code>
to the data <code>x</code>.  The data <code>x</code> must either be a vector of
length <code>trfm$p</code>, in which case the result is a vector of
length <code>trfm$q</code>, or a matrix with <code>trfm$p</code> columns, in which case
the transformation is applied to each row of the matrix separately.
</p>
<p>The function <code>fromCoords()</code> implements the inverse transform
to <code>toCoords()</code>.  The output always satisfies
<code>toCoords(trfm, fromCoords(trfm, y)) == y</code>.  If
<code>trfm$p == trfm$q</code>, <em>i.e.</em> if the transformation is bijective,
the <code>fromCoords(trfm, toCoords(trfm, x)) == x</code> also holds.
The argument <code>apply.shift</code> can be set to false to apply only
the linear part of the (inverse) transformation, leaving out the
final shift.
</p>
<p>The function <code>appendTrfm()</code> concatenates <code>trfm</code> with an
additional, linear transformation and returns the result.  The
arguments <code>op</code> and <code>val</code> specify which kind of linear
transformation to append.  There are two choices for <code>op</code>:
</p>

<ul>
<li> <p><code>diag</code> denotes multiplication with a diagonal matrix: an input
vector <code>x</code> is mapped to the output <code>x * val</code>.  The scaling factor
<code>val</code> can either be a vector of length <code>trfm$q</code> (for element-wise
scaling), or a number.
</p>
</li>
<li> <p><code>orth</code> denotes multiplication with an orthogonal matrix.
<code>val</code> must be a matrix with orthogonal columns (not necessarily
square) and <code>trfm$q</code> rows.  An input vector <code>x</code> is mapped
to the output <code>x %*% orth</code>.
</p>
</li></ul>

<p>The new transformation is applied after any other transformations
already associated with <code>trfm</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>coords</code>, as a list with the following
components:
</p>
<table>
<tr><td><code>p</code></td>
<td>
<p>the number of variables in the original data set</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>the number of variables in the transformed data set</p>
</td></tr>
<tr><td><code>shift</code></td>
<td>
<p>the affine part of the transformation</p>
</td></tr>
<tr><td><code>name</code></td>
<td>
<p>the name of the transformation</p>
</td></tr>
<tr><td><code>cmds</code></td>
<td>
<p>a representation of the transformation (internal use only)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jochen Voss &lt;voss@seehuhn.de&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+standardize">standardize</a></code>,
<code><a href="#topic+whiten">whiten</a></code>,
<code><a href="#topic+PCA">PCA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  pc &lt;- PCA(iris[, 1:4], n.comp = 3)
  toCoords(pc, c(5, 3, 4, 1))
  fromCoords(pc, c(1, 0, 0))
</code></pre>

<hr>
<h2 id='PCA'>Perform Principal Component Analysis (PCA)</h2><span id='topic+PCA'></span>

<h3>Description</h3>

<p>Perform principal components analysis on a data
matrix and return the results as an object of class <code>coords</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  PCA(x, n.comp, scale = FALSE, compute.scores = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PCA_+3A_x">x</code></td>
<td>
<p>A data matrix, rows are observations, columns are variables.</p>
</td></tr>
<tr><td><code id="PCA_+3A_n.comp">n.comp</code></td>
<td>
<p>How many principal components to compute.</p>
</td></tr>
<tr><td><code id="PCA_+3A_scale">scale</code></td>
<td>
<p>Whether to standardize the columns before doing PCA.</p>
</td></tr>
<tr><td><code id="PCA_+3A_compute.scores">compute.scores</code></td>
<td>
<p>Whether to compute the scores (i.e. x in the new
basis).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs Principal Component Analysis (PCA) on the
data.  Variables are always centred before
the PCA is performed and, if <code>scale</code> is set, the variables
will also be rescaled to unit variance.
</p>
<p>If <code>compute.scores</code> is set to <code>FALSE</code>, only the information
required for the <code>toPC()</code> and <code>fromPC()</code> to work is stored
in the returned <code>coords</code> object; otherwise the scores will
be stored in the <code>$y</code> field of the <code>coords</code> object.
</p>
<p>The <code>PCA()</code> function is an alternative to
the <code>prcomp()</code> command from the standard library.
The main advantage of <code>PCA()</code> is that the <code>coords</code>
class provides functions to convert between the original basis and the
principal component basis.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+coords">coords</a></code>, with the following
additional components added:
</p>
<table>
<tr><td><code>loadings</code></td>
<td>
<p>the loadings, each column is one of the new basis vectors</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>if <code>compute.scores==TRUE</code>, this is <code>x</code> expressed in
the new basis</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>the variance of the data along each of the new basis vectors</p>
</td></tr>
<tr><td><code>total.var</code></td>
<td>
<p>the total variance of the data</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jochen Voss &lt;voss@seehuhn.de&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coords">coords</a></code>;
alternative implementations: <code><a href="stats.html#topic+prcomp">prcomp</a></code>, <code><a href="stats.html#topic+princomp">princomp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  pc &lt;- PCA(iris[, 1:4], scale = TRUE, n.comp = 2)
  pc
  plot(pc$y, col=iris$Species)
</code></pre>

<hr>
<h2 id='standardize'>Standardize data</h2><span id='topic+standardize'></span>

<h3>Description</h3>

<p>Standardize each column of a data matrix and return the
results as an object of class <code>coords</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  standardize(x, compute.scores = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standardize_+3A_x">x</code></td>
<td>
<p>A data matrix, rows are observations, columns are variables.</p>
</td></tr>
<tr><td><code id="standardize_+3A_compute.scores">compute.scores</code></td>
<td>
<p>Whether to compute the scores (i.e. <code>x</code>
in the new basis).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function standardizes the columns of <code>x</code> by subtracting the
mean of each column and then dividing by the standard deviation.  The
transformed data is stored in the <code>$y</code> field of the returned
<code>coords</code> object.
</p>
<p>If <code>compute.scores</code> is set to <code>FALSE</code>, only the information
required for the <code>toCoords()</code> and <code>fromCoords()</code> to work is
stored in the returned <code>coords</code> object; otherwise the scores
(transformed data) will be stored in the <code>$y</code> field of the
<code>coords</code> object.
</p>


<h3>Value</h3>

<p>An object of class <code>coords</code>, with the following additional
components added:
</p>
<table>
<tr><td><code>y</code></td>
<td>
<p>if <code>compute.scores==TRUE</code>, this is <code>x</code> expressed in
the new basis</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jochen Voss &lt;voss@seehuhn.de&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coords">coords</a></code>;
alternative implementation <code><a href="base.html#topic+scale">scale</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  w &lt;- standardize(iris[, 1:4])
  colMeans(w$y)
  apply(w$y, 2, sd)
</code></pre>

<hr>
<h2 id='whiten'>Whiten data</h2><span id='topic+whiten'></span>

<h3>Description</h3>

<p>Whiten data and return the results as an object of class
<code>coords</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  whiten(x, compute.scores = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="whiten_+3A_x">x</code></td>
<td>
<p>A data matrix, rows are observations, columns are variables.</p>
</td></tr>
<tr><td><code id="whiten_+3A_compute.scores">compute.scores</code></td>
<td>
<p>Whether to compute the scores (i.e. <code>x</code> in
the new basis).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function whitens the data by finding an affine transformation such
that the transformed data has mean 0 and identity covariance matrix.
</p>
<p>If <code>compute.scores</code> is set to <code>FALSE</code>, only the
information required for the <code>toCoords()</code> and
<code>fromCoords()</code> to work is stored in the returned <code>coords</code>
object; otherwise the scores (transformed data) will be stored in
the <code>$y</code> field of the <code>coords</code> object.
</p>


<h3>Value</h3>

<p>An object of class <code>coords</code>, with the following additional
components added:
</p>
<table>
<tr><td><code>loadings</code></td>
<td>
<p>the loadings, each column is one of the new basis vectors</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>if <code>compute.scores==TRUE</code>, this is <code>x</code> expressed in
the new basis</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jochen Voss &lt;voss@seehuhn.de&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coords">coords</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  w &lt;- whiten(iris[, 1:4])
  colMeans(w$y)
  round(cov(w$y), 3)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
