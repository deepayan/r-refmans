<!DOCTYPE html><html><head><title>Help for package QuantBondCurves</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {QuantBondCurves}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#accrued.interests'><p>Accrued interest</p></a></li>
<li><a href='#average.life'><p>Weighted Average Life</p></a></li>
<li><a href='#basis.curve'><p>Basis Curve</p></a></li>
<li><a href='#bond.price2rate'><p>From a price to a rate</p></a></li>
<li><a href='#coupon.dates'><p>Coupon date payments</p></a></li>
<li><a href='#coupons'><p>Coupon payment calculation</p></a></li>
<li><a href='#curve.calculation'><p>Curve calculation</p></a></li>
<li><a href='#curve.calibration'><p>Curve calibration</p></a></li>
<li><a href='#discount.factors'><p>Discount factors</p></a></li>
<li><a href='#discount.time'><p>Quantil's discount time convention</p></a></li>
<li><a href='#fwd2spot'><p>Forward curve conversion</p></a></li>
<li><a href='#price.dirty2clean'><p>From one price to another</p></a></li>
<li><a href='#sens.bonds'><p>Bond Sensitivity</p></a></li>
<li><a href='#spot2forward'><p>Spot curve conversion</p></a></li>
<li><a href='#valuation.bonds'><p>Bond valuation</p></a></li>
<li><a href='#valuation.swaps'><p>Swap valuation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Calculates Bond Values and Interest Rate Curves for Finance</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Camilo Díaz &lt;camilo.diaz@quantil.com.co&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Values different types of assets and calibrates discount curves 
    for quantitative financial analysis. It covers fixed coupon assets, 
    floating note assets, interest and cross currency swaps with different 
    payment frequencies. Enables the calibration of spot, instantaneous forward 
    and basis curves, making it a powerful tool for accurate and flexible bond 
    valuation and curve generation. The valuation and calibration techniques 
    presented here are consistent with industry standards and incorporates 
    author's own calculations. Tuckman, B., Serrat, A. (2022, ISBN: 978-1-119-83555-4).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>lubridate, quantdates, Rsolnp</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), knitr, rmarkdown, ggplot2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-20 00:01:11 UTC; kmo</td>
</tr>
<tr>
<td>Author:</td>
<td>Camilo Díaz [aut, cre, com],
  Andrés Galeano [aut],
  Julián Rojas [aut],
  Quantil S.A.S [aut, cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-20 00:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='accrued.interests'>Accrued interest</h2><span id='topic+accrued.interests'></span>

<h3>Description</h3>

<p>Calculates the accumulated coupon or accrued interests of the
asset, from its last coupon or cash flow payment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>accrued.interests(
  maturity,
  analysis.date = Sys.Date(),
  coupon.rate,
  principal = 1,
  asset.type = "TES",
  freq = NULL,
  daycount = "ACT/360"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="accrued.interests_+3A_maturity">maturity</code></td>
<td>
<p>Last day of the contract: YYYY-MM-DD.
Alternatively, it can be a numeric value that represents the duration of the contract in years.</p>
</td></tr>
<tr><td><code id="accrued.interests_+3A_analysis.date">analysis.date</code></td>
<td>
<p>Date in which the asset is valued. By default, the
current date.</p>
</td></tr>
<tr><td><code id="accrued.interests_+3A_coupon.rate">coupon.rate</code></td>
<td>
<p>Coupon rate of the asset. Can be an unique numeric
value or a vector corresponding to each coupon payment date.</p>
</td></tr>
<tr><td><code id="accrued.interests_+3A_principal">principal</code></td>
<td>
<p>Notional amount for the asset.</p>
</td></tr>
<tr><td><code id="accrued.interests_+3A_asset.type">asset.type</code></td>
<td>
<p>String that determines the asset type to value. See also
'Details'.</p>
</td></tr>
<tr><td><code id="accrued.interests_+3A_freq">freq</code></td>
<td>
<p>Frequency of payments of a given asset in a year. For LIBOR and
IBR the default frequency is four (quarterly payments). TES has a default
frequency of one (annual payments).</p>
</td></tr>
<tr><td><code id="accrued.interests_+3A_daycount">daycount</code></td>
<td>
<p>Day count convention. See also 'Details'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>asset.type</code> makes reference to the following type of assets:
</p>

<ul>
<li><p> &quot;TES&quot; for Colombian Treasury Bonds (default).
</p>
</li>
<li><p> &quot;FixedIncome&quot; for assets that are indexed to a fixed income with
different frequency of payments.
</p>
</li>
<li><p> &quot;IBR&quot; for bonds and assets indexed to 3M IBR rate.
</p>
</li>
<li><p> &quot;IBRSwaps&quot; for swaps indexed to IBR rate.
</p>
</li>
<li><p> &quot;LIBOR&quot; for bonds and assets indexed to 3M LIBOR.
</p>
</li>
<li><p> &quot;UVRSwaps&quot; for cross-currency swaps indexed to UVR-IBR rate.
</p>
</li>
<li><p> &quot;LIBORSwaps&quot; for Interest Rate Swaps (IRS) indexed to 3M LIBOR.
</p>
</li></ul>

<p><code>daycount</code> convention accepts the following values:
</p>

<ul>
<li><p> 30/360.
</p>
</li>
<li><p> ACT/365.
</p>
</li>
<li><p> ACT/360 (Default).
</p>
</li>
<li><p> ACT/365L.
</p>
</li>
<li><p> NL/365.
</p>
</li>
<li><p> ACT/ACT-ISDA
</p>
</li>
<li><p> ACT/ACT-AFB
</p>
</li></ul>



<h3>Value</h3>

<p>Accrued interest of the bond from the last coupon payment to the
liquidation (valuation date).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>accrued.interests(coupon.rate = 0.04, maturity = '2029-08-10',
                  asset.type = 'LIBOR', daycount = "30/360")
accrued.interests(coupon.rate = 0.04, maturity = '2029-08-10',
                  daycount = "NL/365")
accrued.interests(coupon.rate = 0.04, maturity = '2029-08-10',
                  asset.type= 'IBR', daycount = "ACT/360")
accrued.interests(coupon.rate = 0.04, maturity = '2029-08-10', freq= 2,
                  asset.type= 'FixedIncome', daycount = "ACT/365")


</code></pre>

<hr>
<h2 id='average.life'>Weighted Average Life</h2><span id='topic+average.life'></span>

<h3>Description</h3>

<p>Calculates the weighted average life of a given bond by dividing the weighted
total payments by the total payments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>average.life(
  input,
  price,
  maturity,
  analysis.date = Sys.Date(),
  coupon.rate,
  principal = 1,
  asset.type = "TES",
  freq = 1,
  rate.type = 1,
  spread = 0,
  daycount = "ACT/365",
  dirty = 1,
  convention = "F",
  trade.date = NULL,
  coupon.schedule = "SF"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="average.life_+3A_input">input</code></td>
<td>
<p>String that establishes if the price input corresponds to the
Internal Rate of Return (IRR) of the bond or the market price. Set
<code>"rate"</code> for the IRR. Otherwise, <code>"price"</code>.</p>
</td></tr>
<tr><td><code id="average.life_+3A_price">price</code></td>
<td>
<p>Numeric value of either market price or Internal Rate of Return (IRR) of a
given bond. Instead of IRR, can also be a rates vector that corresponds to coupon dates.</p>
</td></tr>
<tr><td><code id="average.life_+3A_maturity">maturity</code></td>
<td>
<p>Last day of the contract: YYYY-MM-DD.
Alternatively, it can be a numeric value that represents the duration of the contract in years.</p>
</td></tr>
<tr><td><code id="average.life_+3A_analysis.date">analysis.date</code></td>
<td>
<p>Date in which the asset is valued. By default, the
current date.</p>
</td></tr>
<tr><td><code id="average.life_+3A_coupon.rate">coupon.rate</code></td>
<td>
<p>Coupon rate of the asset. Can be an unique numeric
value or a vector corresponding to each coupon payment date.</p>
</td></tr>
<tr><td><code id="average.life_+3A_principal">principal</code></td>
<td>
<p>Notional amount for the asset.</p>
</td></tr>
<tr><td><code id="average.life_+3A_asset.type">asset.type</code></td>
<td>
<p>String that determines the asset type to value. See also
'Details'.</p>
</td></tr>
<tr><td><code id="average.life_+3A_freq">freq</code></td>
<td>
<p>Frequency of payments of a given asset in a year. For LIBOR and
IBR the default frequency is four (quarterly payments). TES has a default
frequency of one (annual payments).</p>
</td></tr>
<tr><td><code id="average.life_+3A_rate.type">rate.type</code></td>
<td>
<p>(1) for discrete compounded discount rates and (0) for continuosly
compounded discount rates. By default rates are assumed to be discrete.</p>
</td></tr>
<tr><td><code id="average.life_+3A_spread">spread</code></td>
<td>
<p>Decimal value of spread added to coupon payment rate. By
default, <code>0</code>.</p>
</td></tr>
<tr><td><code id="average.life_+3A_daycount">daycount</code></td>
<td>
<p>Day count convention. See also 'Details'.</p>
</td></tr>
<tr><td><code id="average.life_+3A_dirty">dirty</code></td>
<td>
<p>Numeric value to determine if the calculated price is dirty or
clean. To calculate dirty price, set <code>dirty = 1</code>. Otherwise,
<code>dirty = 0</code>.</p>
</td></tr>
<tr><td><code id="average.life_+3A_convention">convention</code></td>
<td>
<p>String that establishes if the effective dates are
calculated using Following, Modified Following, Backward or Backward Following.
See also 'Details'.</p>
</td></tr>
<tr><td><code id="average.life_+3A_trade.date">trade.date</code></td>
<td>
<p>The date on which the transaction occurs. It is used to calculate
maturity as a date, when given in years. Also required for non-trivial cases such as
bonds with long first coupon.</p>
</td></tr>
<tr><td><code id="average.life_+3A_coupon.schedule">coupon.schedule</code></td>
<td>
<p>String that establishes if a bond first coupon period is a long
first coupon or a short first coupon. On the contrary, establishes if last coupon period
is long last coupon or a short last coupon. See also 'Details'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>asset.type</code> makes reference to the following type of assets:
</p>

<ul>
<li><p> &quot;TES&quot; for Colombian Treasury Bonds (default).
</p>
</li>
<li><p> &quot;FixedIncome&quot; for assets that are indexed to a fixed income with
different frequency of payments.
</p>
</li>
<li><p> &quot;IBR&quot; for bonds and assets indexed to 3M IBR rate.
</p>
</li>
<li><p> &quot;LIBOR&quot; for bonds and assets indexed to 3M LIBOR.
</p>
</li></ul>

<p><code>daycount</code> convention accepts the following values:
</p>

<ul>
<li><p> 30/360.
</p>
</li>
<li><p> ACT/365.
</p>
</li>
<li><p> ACT/360 (Default).
</p>
</li>
<li><p> ACT/365L.
</p>
</li>
<li><p> NL/365.
</p>
</li>
<li><p> ACT/ACT-ISDA
</p>
</li>
<li><p> ACT/ACT-AFB
</p>
</li></ul>

<p><code>convention</code> makes reference to the following type of business day conventions:
</p>

<ul>
<li><p> &quot;F&quot; for Following business day convention.
</p>
</li>
<li><p> &quot;MF&quot; for Modified Following business day convention.
</p>
</li>
<li><p> &quot;B&quot; for Backward business day convention.
</p>
</li>
<li><p> &quot;MB&quot; for Modified Backward business day convention.
</p>
</li></ul>

<p><code>coupon.schedule</code> makes reference to the following type of coupon payment schedule
of a bond:
</p>

<ul>
<li><p> &quot;LF&quot; for Long First coupon payment.
</p>
</li>
<li><p> &quot;LL&quot; for Long Last coupon payment.
</p>
</li>
<li><p> &quot;SF&quot; for Short First coupon payment.
</p>
</li>
<li><p> &quot;SL&quot; for Short Last coupon payment.
</p>
</li></ul>



<h3>Value</h3>

<p>Weighted average life of given bond
</p>


<h3>Examples</h3>

<pre><code class='language-R'>average.life(input = c("rate"), price = 0.08, maturity = "2026-06-01",
             analysis.date = "2025-06-01", coupon.rate = 0.06, principal = 1000,
             asset.type = "IBR", freq = 4)
average.life(input = c("rate"), price = c(0.043,0.05), maturity = "2023-01-03",
             analysis.date = "2021-01-03", coupon.rate = 0.04, principal = 1,
             asset.type = "FixedIncome", freq = 1, rate.type = 0)

</code></pre>

<hr>
<h2 id='basis.curve'>Basis Curve</h2><span id='topic+basis.curve'></span>

<h3>Description</h3>

<p>Function that calibrates a &quot;discount basis rate&quot; curve according
to data of cross currency swaps. Available methods are bootstrapping or residual
sum of squares (RSS) between the value of a given or inferred fixed foreign leg
and the value of the local leg.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basis.curve(
  swaps,
  ex.rate = NULL,
  analysis.date = Sys.Date(),
  rates,
  rates2,
  freq = 1,
  rate.type = 1,
  daycount = "ACT/365",
  npieces = NULL,
  obj = "Price",
  Weights = NULL,
  nsimul = 1,
  piece.term = NULL,
  nodes = seq(0, 15, 0.001),
  approximation = "constant"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="basis.curve_+3A_swaps">swaps</code></td>
<td>
<p>Matrix containing relevant information of cross currency swaps where each
row represents a swap and each column represents the next attributes: maturity, legs,
coupon rate of local leg, coupon rate of foreign leg, spread of local leg, spread of
variable leg, principal of local and principal of variable leg. <code>colnames(swaps)</code>
must be defined as the following: <code>c("Mat", "Legs", "C1", "C2", "spread1", "spread2", "prin1", "prin2")</code>.</p>
</td></tr>
<tr><td><code id="basis.curve_+3A_ex.rate">ex.rate</code></td>
<td>
<p>Exchange rate on analysis date. Format has to be local currency divided
by foreign currency.</p>
</td></tr>
<tr><td><code id="basis.curve_+3A_analysis.date">analysis.date</code></td>
<td>
<p>Date in which the asset is valued. By default, the
current date.</p>
</td></tr>
<tr><td><code id="basis.curve_+3A_rates">rates</code></td>
<td>
<p>Discount rates given by the local zero coupon rate curve. The curve has to
have nodes with at least, with 3 decimals.</p>
</td></tr>
<tr><td><code id="basis.curve_+3A_rates2">rates2</code></td>
<td>
<p>Discount rates given by the foreign zero coupon rate curve. The curve has to
have nodes with at least, with 3 decimals.</p>
</td></tr>
<tr><td><code id="basis.curve_+3A_freq">freq</code></td>
<td>
<p>Frequency of payments of a given asset in a year. For LIBOR and
IBR the default frequency is four (quarterly payments). TES has a default
frequency of one (annual payments).</p>
</td></tr>
<tr><td><code id="basis.curve_+3A_rate.type">rate.type</code></td>
<td>
<p>(1) for discrete compounded discount rates and (0) for continuosly
compounded discount rates. By default rates are assumed to be discrete.</p>
</td></tr>
<tr><td><code id="basis.curve_+3A_daycount">daycount</code></td>
<td>
<p>Day count convention. See also 'Details'.</p>
</td></tr>
<tr><td><code id="basis.curve_+3A_npieces">npieces</code></td>
<td>
<p>Number of constant or linear segments for the curve to have. By
default <code>NULL</code>, and bootstrapping method is used, otherwise, minimization of
RSS is used.</p>
</td></tr>
<tr><td><code id="basis.curve_+3A_obj">obj</code></td>
<td>
<p>String related to the definition of the error in the RSS methodology.
Set <code>"Price"</code> for minimization of error by price or <code>"Rate"</code> for
minimization of error by rate.</p>
</td></tr>
<tr><td><code id="basis.curve_+3A_weights">Weights</code></td>
<td>
<p>Vector of weights used to dot product with residual squares in order to
calculate residual sum of squares. By default, each residual is assigned the same weight.</p>
</td></tr>
<tr><td><code id="basis.curve_+3A_nsimul">nsimul</code></td>
<td>
<p>Number of simulations for the terms of the pieces. The more simulations,
the more likely to find a better local solution. By default <code>1</code>, and terms are
defined in such way each piece occupies the same length in the abscissa axis.</p>
</td></tr>
<tr><td><code id="basis.curve_+3A_piece.term">piece.term</code></td>
<td>
<p>Vector that establishes a unique term structure for optimization to take place.
Each piece or segment must have a unique maturity, as numeric value in years,
that signifies the end of the segment. Last segment maturity must not be introduced, it is assumed to be equivalent to
the last term introduced on analysis date. Therefore, the <code>piece.term</code> vector must always have a length equal to <code>npieces</code> - 1.</p>
</td></tr>
<tr><td><code id="basis.curve_+3A_nodes">nodes</code></td>
<td>
<p>Desired output nodes of the curve.</p>
</td></tr>
<tr><td><code id="basis.curve_+3A_approximation">approximation</code></td>
<td>
<p>String that establish the approximation. Set <code>'linear'</code> for a
linear approximation, or <code>'constant'</code> for a piecewise constant function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>daycount</code> convention accepts the following values:
</p>

<ul>
<li><p> 30/360.
</p>
</li>
<li><p> ACT/365.
</p>
</li>
<li><p> ACT/360 (Default).
</p>
</li>
<li><p> ACT/365L.
</p>
</li>
<li><p> NL/365.
</p>
</li>
<li><p> ACT/ACT-ISDA
</p>
</li>
<li><p> ACT/ACT-AFB
</p>
</li></ul>

<p><code>swaps["Legs"]</code> makes reference to the following types of legs composition of the
cross currency swaps.
</p>

<ul>
<li><p> &quot;FF&quot; for fixed leg in local currency and fixed leg in foreign currency.
</p>
</li>
<li><p> &quot;FV&quot; for fixed leg in local currency and variable leg in foreign currency.
</p>
</li>
<li><p> &quot;VF&quot; for variable leg in local currency and fixed leg in foreign currency.
</p>
</li>
<li><p> &quot;VV&quot; for variable leg in local currency and variable leg in foreign currency.
</p>
</li></ul>



<h3>Value</h3>

<p>Constant or Linear piecewise basis curve.
</p>


<h3>Author(s)</h3>

<p>Camilo Díaz
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Inputs for calibration of spot curve
yield.curve  &lt;- c(0.015,0.0175, 0.0225, 0.0275, 0.0325, 0.0375,0.04,0.0425,0.045,0.0475,0.05)
names(yield.curve) &lt;- c(0.5,1,2,3,4,5,6,7,8,9,10)
nodes &lt;- seq(0,10,0.001)
# Calibration of local spot curve
rates &lt;- curve.calibration (yield.curve = yield.curve, market.assets = NULL,
                            analysis.date = "2019-01-03" , asset.type = "IBRSwaps",
                            freq = 4, rate.type = 0, fwd = 0, npieces = NULL,
                            obj = "Price", nodes = nodes, approximation = "linear")
# Input for Basis Curve
ex.rate &lt;- 4814
swaps &lt;- rbind(c("2024-03-01", "FF", 0.07 , 0.0325, NA   , NA    , 2000 * ex.rate, 2000),
               c("2025-03-01", "VV", NA   , NA    , 0.015, 0.0175, 2000 * ex.rate, 2000),
               c("2026-03-01", "FF", 0.075, 0.03  , NA   ,  NA   , 5000000, 5000000 / ex.rate),
               c("2027-03-01", "VV", NA   , NA    , 0.01 , 0.015 , 5000000, 5000000 / ex.rate),
               c("2028-03-01", "FF", 0.08 ,0.035  , NA   , NA    , 3000000, 3000000 / ex.rate),
               c("2029-03-01", "VV", NA   , NA    , 0.01 , 0.0125, 3000000, 3000000 / ex.rate))
colnames(swaps) &lt;- c("Mat"  ,"Legs", "C1" , "C2", "spread1", "spread2", "prin1", "prin2")
# Function
basis.curve(swaps = swaps, ex.rate = 4814, analysis.date = "2023-03-01",
            rates = rates, rates2 = rates / 4, freq = c(2,2,2,2,1,1),
            rate.type = 1, npieces = 4, obj = "Price", Weights = NULL,
            nsimul = 1, nodes = nodes, approximation = "linear")
</code></pre>

<hr>
<h2 id='bond.price2rate'>From a price to a rate</h2><span id='topic+bond.price2rate'></span>

<h3>Description</h3>

<p>Calculates the Internal Rate of Return (IRR) of a given asset
taking into account the market price, maturity, face value, and analysis
date.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bond.price2rate(
  maturity,
  analysis.date = Sys.Date(),
  price,
  coupon.rate,
  principal = 1,
  asset.type = "TES",
  freq = NULL,
  rate.type = 1,
  spread = 0,
  dirty = 1,
  daycount = "NL/365",
  convention = "F",
  trade.date = NULL,
  coupon.schedule = "SF"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bond.price2rate_+3A_maturity">maturity</code></td>
<td>
<p>Last day of the contract: YYYY-MM-DD.
Alternatively, it can be a numeric value that represents the duration of the contract in years.</p>
</td></tr>
<tr><td><code id="bond.price2rate_+3A_analysis.date">analysis.date</code></td>
<td>
<p>Date in which the asset is valued. By default, the
current date.</p>
</td></tr>
<tr><td><code id="bond.price2rate_+3A_price">price</code></td>
<td>
<p>Numeric value. Price of the bond to convert.</p>
</td></tr>
<tr><td><code id="bond.price2rate_+3A_coupon.rate">coupon.rate</code></td>
<td>
<p>Coupon rate of the asset. Can be an unique numeric
value or a vector corresponding to each coupon payment date.</p>
</td></tr>
<tr><td><code id="bond.price2rate_+3A_principal">principal</code></td>
<td>
<p>Notional amount for the asset.</p>
</td></tr>
<tr><td><code id="bond.price2rate_+3A_asset.type">asset.type</code></td>
<td>
<p>String that determines the asset type to value. See also
'Details'.</p>
</td></tr>
<tr><td><code id="bond.price2rate_+3A_freq">freq</code></td>
<td>
<p>Frequency of payments of a given asset in a year. For LIBOR and
IBR the default frequency is four (quarterly payments). TES has a default
frequency of one (annual payments).</p>
</td></tr>
<tr><td><code id="bond.price2rate_+3A_rate.type">rate.type</code></td>
<td>
<p>(1) for discrete compounded discount rates and (0) for continuosly
compounded discount rates. By default rates are assumed to be discrete.</p>
</td></tr>
<tr><td><code id="bond.price2rate_+3A_spread">spread</code></td>
<td>
<p>Decimal value of spread added to coupon payment rate. By
default, <code>0</code>.</p>
</td></tr>
<tr><td><code id="bond.price2rate_+3A_dirty">dirty</code></td>
<td>
<p>Numeric value to determine if the calculated price is dirty or
clean. To calculate dirty price, set <code>dirty = 1</code>. Otherwise,
<code>dirty = 0</code>.</p>
</td></tr>
<tr><td><code id="bond.price2rate_+3A_daycount">daycount</code></td>
<td>
<p>Day count convention. See also 'Details'.</p>
</td></tr>
<tr><td><code id="bond.price2rate_+3A_convention">convention</code></td>
<td>
<p>String that establishes if the effective dates are
calculated using Following, Modified Following, Backward or Backward Following.
See also 'Details'.</p>
</td></tr>
<tr><td><code id="bond.price2rate_+3A_trade.date">trade.date</code></td>
<td>
<p>The date on which the transaction occurs. It is used to calculate
maturity as a date, when given in years. Also required for non-trivial cases such as
bonds with long first coupon.</p>
</td></tr>
<tr><td><code id="bond.price2rate_+3A_coupon.schedule">coupon.schedule</code></td>
<td>
<p>String that establishes if a bond first coupon period is a long
first coupon or a short first coupon. On the contrary, establishes if last coupon period
is long last coupon or a short last coupon. See also 'Details'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>asset.type</code> makes reference to the following type of assets:
</p>

<ul>
<li><p> &quot;TES&quot; for Colombian Treasury Bonds (default).
</p>
</li>
<li><p> &quot;FixedIncome&quot; for assets that are indexed to a fixed income with
different frequency of payments.
</p>
</li>
<li><p> &quot;IBR&quot; for bonds and assets indexed to 3M IBR rate.
</p>
</li>
<li><p> &quot;LIBOR&quot; for bonds and assets indexed to 3M LIBOR.
</p>
</li></ul>

<p><code>daycount</code> convention accepts the following values:
</p>

<ul>
<li><p> 30/360.
</p>
</li>
<li><p> ACT/365.
</p>
</li>
<li><p> ACT/360 (Default).
</p>
</li>
<li><p> ACT/365L.
</p>
</li>
<li><p> NL/365.
</p>
</li>
<li><p> ACT/ACT-ISDA
</p>
</li>
<li><p> ACT/ACT-AFB
</p>
</li></ul>

<p><code>convention</code> makes reference to the following type of business day conventions:
</p>

<ul>
<li><p> &quot;F&quot; for Following business day convention.
</p>
</li>
<li><p> &quot;MF&quot; for Modified Following business day convention.
</p>
</li>
<li><p> &quot;B&quot; for Backward business day convention.
</p>
</li>
<li><p> &quot;MB&quot; for Modified Backward business day convention.
</p>
</li></ul>

<p><code>coupon.schedule</code> makes reference to the following type of coupon payment schedule
of a bond:
</p>

<ul>
<li><p> &quot;LF&quot; for Long First coupon payment.
</p>
</li>
<li><p> &quot;LL&quot; for Long Last coupon payment.
</p>
</li>
<li><p> &quot;SF&quot; for Short First coupon payment.
</p>
</li>
<li><p> &quot;SL&quot; for Short Last coupon payment.
</p>
</li></ul>



<h3>Value</h3>

<p>The Yield to Maturity or Internal Rate of Return of a given asset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bond.price2rate(maturity = "2023-01-03", analysis.date = "2021-01-03",
                price = 1, coupon.rate = 0.04, principal = 1,
                asset.type = "TES", freq = 1)

</code></pre>

<hr>
<h2 id='coupon.dates'>Coupon date payments</h2><span id='topic+coupon.dates'></span>

<h3>Description</h3>

<p>Function to calculate the upcoming coupon payment dates of a given asset,
based on its payment frequency. The list of payment dates encompass
the time period between the analysis date and the maturity of the asset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coupon.dates(
  maturity,
  analysis.date = Sys.Date(),
  asset.type = "TES",
  freq = NULL,
  convention = "F",
  loc = "BOG",
  trade.date = NULL,
  coupon.schedule = "SF"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coupon.dates_+3A_maturity">maturity</code></td>
<td>
<p>Last day of the contract: YYYY-MM-DD.
Alternatively, it can be a numeric value that represents the duration of the contract in years.</p>
</td></tr>
<tr><td><code id="coupon.dates_+3A_analysis.date">analysis.date</code></td>
<td>
<p>Date in which the asset is valued. By default, the
current date.</p>
</td></tr>
<tr><td><code id="coupon.dates_+3A_asset.type">asset.type</code></td>
<td>
<p>String that determines the asset type to value. See also
'Details'.</p>
</td></tr>
<tr><td><code id="coupon.dates_+3A_freq">freq</code></td>
<td>
<p>Frequency of payments of a given asset in a year. For LIBOR and
IBR the default frequency is four (quarterly payments). TES has a default
frequency of one (annual payments).</p>
</td></tr>
<tr><td><code id="coupon.dates_+3A_convention">convention</code></td>
<td>
<p>String that establishes if the effective dates are
calculated using Following, Modified Following, Backward or Backward Following.
See also 'Details'.</p>
</td></tr>
<tr><td><code id="coupon.dates_+3A_loc">loc</code></td>
<td>
<p>String related to the location of the asset. It is used to
calculate the effective dates, taking into account the business days
of the given location. See also 'Details'.</p>
</td></tr>
<tr><td><code id="coupon.dates_+3A_trade.date">trade.date</code></td>
<td>
<p>The date on which the transaction occurs. It is used to calculate
maturity as a date, when given in years. Also required for non-trivial cases such as
bonds with long first coupon.</p>
</td></tr>
<tr><td><code id="coupon.dates_+3A_coupon.schedule">coupon.schedule</code></td>
<td>
<p>String that establishes if a bond first coupon period is a long
first coupon or a short first coupon. On the contrary, establishes if last coupon period
is long last coupon or a short last coupon. See also 'Details'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>asset.type</code> makes reference to the following type of assets:
</p>

<ul>
<li><p> &quot;TES&quot; for Colombian Treasury Bonds (default).
</p>
</li>
<li><p> &quot;FixedIncome&quot; for assets that are indexed to a fixed income with
different frequency of payments.
</p>
</li>
<li><p> &quot;IBR&quot; for bonds and assets indexed to 3M IBR rate.
</p>
</li>
<li><p> &quot;IBRSwaps&quot; for swaps indexed to IBR rate.
</p>
</li>
<li><p> &quot;LIBOR&quot; for bonds and assets indexed to 3M LIBOR.
</p>
</li>
<li><p> &quot;UVRSwaps&quot; for cross-currency swaps indexed to UVR-IBR rate.
</p>
</li>
<li><p> &quot;LIBORSwaps&quot; for Interest Rate Swaps (IRS) indexed to 3M LIBOR.
</p>
</li></ul>

<p><code>loc</code> makes reference to the following locations:
</p>

<ul>
<li><p> &quot;BOG&quot; for colombian issued assets and national business days
(default).
</p>
</li>
<li><p> &quot;LDN&quot; for business days of London.
</p>
</li>
<li><p> &quot;NY&quot; for business days of New York
</p>
</li>
<li><p> &quot;NYLDN&quot; for the intersection of business days in New York and
London.
</p>
</li>
<li><p> &quot;BOGNY&quot; for the intersection of business days in Bogota and
New York.
</p>
</li></ul>

<p><code>convention</code> makes reference to the following type of business day conventions:
</p>

<ul>
<li><p> &quot;F&quot; for Following business day convention.
</p>
</li>
<li><p> &quot;MF&quot; for Modified Following business day convention.
</p>
</li>
<li><p> &quot;B&quot; for Backward business day convention.
</p>
</li>
<li><p> &quot;MB&quot; for Modified Backward business day convention.
</p>
</li></ul>

<p><code>coupon.schedule</code> makes reference to the following type of coupon payment schedule
of a bond:
</p>

<ul>
<li><p> &quot;LF&quot; for Long First coupon payment.
</p>
</li>
<li><p> &quot;LL&quot; for Long Last coupon payment.
</p>
</li>
<li><p> &quot;SF&quot; for Short First coupon payment.
</p>
</li>
<li><p> &quot;SL&quot; for Short Last coupon payment.
</p>
</li></ul>



<h3>Value</h3>

<p>Upcoming coupon dates and dates of payment according to business day conventions.
</p>


<h3>Note</h3>

<p>If only maturity is given, function assumes that the coupon payments have
already started. If <code>maturity</code> and <code>trade.date</code> are included,
coupon dates are calculated from <code>trade.date</code> to <code>maturity</code>.
If by doing so, <code>trade.date</code> doesn't converge to <code>maturity</code>, month remainder
is adjusted according to <code>coupon.schedule</code>.
For LIBOR assets, function adds 2 business days to <code>trade.date</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coupon.dates("2028-04-03")
coupon.dates(maturity = 2, analysis.date = "2021-10-01")
coupon.dates(maturity = "2029-10-01", asset.type = "FixedIncome", freq = 2, convention = "MB")
coupon.dates(maturity = "2028-02-29", analysis.date = "2022-07-29", trade.date = "2022-07-29",
             asset.type = "TES", coupon.schedule = "SF")
coupon.dates(maturity = "2025-11-30", analysis.date = "2022-03-01", trade.date = "2021-05-31",
             asset.type = "IBR", loc = "NY", convention = "F")
</code></pre>

<hr>
<h2 id='coupons'>Coupon payment calculation</h2><span id='topic+coupons'></span>

<h3>Description</h3>

<p>Function that returns coupon values according to specified payment dates and
a day count convention. Yields the values of cash flows for the remaining
duration of assets, following a date payment structure, face value -or
principal- and a specified coupon rate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coupons(
  dates = NULL,
  coupon.rate,
  principal = 1,
  asset.type = "TES",
  freq = NULL,
  daycount = "ACT/360",
  loc = "BOG",
  maturity = NULL,
  analysis.date = Sys.Date(),
  trade.date = NULL,
  coupon.schedule = "SF"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coupons_+3A_dates">dates</code></td>
<td>
<p>Coupon payment dates.</p>
</td></tr>
<tr><td><code id="coupons_+3A_coupon.rate">coupon.rate</code></td>
<td>
<p>Coupon rate of the asset. Can be an unique numeric
value or a vector corresponding to each coupon payment date.</p>
</td></tr>
<tr><td><code id="coupons_+3A_principal">principal</code></td>
<td>
<p>Notional amount for the asset.</p>
</td></tr>
<tr><td><code id="coupons_+3A_asset.type">asset.type</code></td>
<td>
<p>String that determines the asset type to value. See also
'Details'.</p>
</td></tr>
<tr><td><code id="coupons_+3A_freq">freq</code></td>
<td>
<p>Frequency of payments of a given asset in a year. For LIBOR and
IBR the default frequency is four (quarterly payments). TES has a default
frequency of one (annual payments).</p>
</td></tr>
<tr><td><code id="coupons_+3A_daycount">daycount</code></td>
<td>
<p>Day count convention. See also 'Details'.</p>
</td></tr>
<tr><td><code id="coupons_+3A_loc">loc</code></td>
<td>
<p>String related to the location of the asset. It is used to
calculate the effective dates, taking into account the business days
of the given location. See also 'Details'.</p>
</td></tr>
<tr><td><code id="coupons_+3A_maturity">maturity</code></td>
<td>
<p>Only necessary in cases where coupon payment dates are not provided in the <code>dates</code> parameter.
Last day of the contract. Can be a numeric value that represents the duration of the contract in years.</p>
</td></tr>
<tr><td><code id="coupons_+3A_analysis.date">analysis.date</code></td>
<td>
<p>Date in which the asset is valued. By default, the
current date.</p>
</td></tr>
<tr><td><code id="coupons_+3A_trade.date">trade.date</code></td>
<td>
<p>The date on which the transaction occurs. It is used to calculate
maturity as a date, when given in years. Also required for non-trivial cases such as
bonds with long first coupon.</p>
</td></tr>
<tr><td><code id="coupons_+3A_coupon.schedule">coupon.schedule</code></td>
<td>
<p>String that establishes if a bond first coupon period is a long
first coupon or a short first coupon. On the contrary, establishes if last coupon period
is long last coupon or a short last coupon. See also 'Details'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>asset.type</code> makes reference to the following type of assets:
</p>

<ul>
<li><p> &quot;TES&quot; for Colombian Treasury Bonds (default).
</p>
</li>
<li><p> &quot;FixedIncome&quot; for assets that are indexed to a fixed income with
different frequency of payments.
</p>
</li>
<li><p> &quot;IBR&quot; for bonds and assets indexed to 3M IBR rate.
</p>
</li>
<li><p> &quot;IBRSwaps&quot; for swaps indexed to IBR rate.
</p>
</li>
<li><p> &quot;LIBOR&quot; for bonds and assets indexed to 3M LIBOR.
</p>
</li>
<li><p> &quot;UVRSwaps&quot; for cross-currency swaps indexed to UVR-IBR rate.
</p>
</li>
<li><p> &quot;LIBORSwaps&quot; for Interest Rate Swaps (IRS) indexed to 3M LIBOR.
</p>
</li></ul>

<p><code>daycount</code> convention accepts the following values:
</p>

<ul>
<li><p> 30/360.
</p>
</li>
<li><p> ACT/365.
</p>
</li>
<li><p> ACT/360 (Default).
</p>
</li>
<li><p> ACT/365L.
</p>
</li>
<li><p> NL/365.
</p>
</li>
<li><p> ACT/ACT-ISDA
</p>
</li>
<li><p> ACT/ACT-AFB
</p>
</li></ul>

<p><code>coupon.schedule</code> makes reference to the following type of coupon payment schedule
of a bond:
</p>

<ul>
<li><p> &quot;LF&quot; for Long First coupon payment.
</p>
</li>
<li><p> &quot;LL&quot; for Long Last coupon payment.
</p>
</li>
<li><p> &quot;SF&quot; for Short First coupon payment.
</p>
</li>
<li><p> &quot;SL&quot; for Short Last coupon payment.
</p>
</li></ul>



<h3>Value</h3>

<p>$Coupons or $Cash flows of the asset in analysis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coupons(dates = c("2020-09-10", "2020-12-10", "2021-03-10"),
        coupon.rate = 0.06)
coupons(dates = c("2020-09-10", "2020-12-10", "2021-03-10"),
        coupon.rate = 0.08, principal = 1000,
        asset.type = "LIBOR", daycount = "ACT/365")
coupons(dates = c("2020-09-10","2020-12-10", "2021-03-10"),
        coupon.rate = 0.07, asset.type = "FixedIncome",
        freq = 4, daycount = "NL/365")
coupons(coupon.rate = c(0.04,0.04,0.42,0.045,0.05),
        maturity = "2024-01-05", analysis.date = "2023-01-03",
        asset.type = "IBR")
coupons(coupon.rate = 0.03, maturity = 1.08,
        analysis.date = "2020-02-29", trade.date = "2020-02-29",
        asset.type = "IBR", coupon.schedule = "LF")

</code></pre>

<hr>
<h2 id='curve.calculation'>Curve calculation</h2><span id='topic+curve.calculation'></span>

<h3>Description</h3>

<p>Function that calculates zero coupon or instantaneous
forward curves for multiple analysis dates, according to historical data of internal rates
of return (IRR) and coupon rates of assets.
Extends previous market rate curves by minimizing Mean Absolute Errors (MAE) following a
bootstrapping recursive method. Alternatively, methodology of residual sum of squares (RSS)
can be employed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curve.calculation(
  serie,
  market.assets = NULL,
  noSpots = 1,
  previous.curve = NULL,
  asset.type = "TES",
  freq = 1,
  rate.type = 1,
  daycount = NULL,
  fwd = 0,
  npieces = NULL,
  obj = "Price",
  Weights = NULL,
  nsimul = 1,
  piece.term = NULL,
  nodes = seq(0, 10, 0.001),
  approximation = "constant"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curve.calculation_+3A_serie">serie</code></td>
<td>
<p>A time series matrix that encompasses a sequence of IRR's emitted on distinct dates.
The columns correspond to different maturity periods, expressed in years,
while the row names indicate the precise dates when the rates were emitted.</p>
</td></tr>
<tr><td><code id="curve.calculation_+3A_market.assets">market.assets</code></td>
<td>
<p>A matrix containing market assets data, where the first column represents
the coupon rates of the assets and the second column represents their corresponding maturities as dates.
This input is required only if the IRR's of assets differs from their coupon rates.</p>
</td></tr>
<tr><td><code id="curve.calculation_+3A_nospots">noSpots</code></td>
<td>
<p>Number of spot interest rates introduced in the <code>serie</code> input per row.
Function assumes spots are the first entries on the <code>serie</code> vector for every row.</p>
</td></tr>
<tr><td><code id="curve.calculation_+3A_previous.curve">previous.curve</code></td>
<td>
<p>A matrix that stores historical curve values up to the earliest calibration date
on <code>serie</code>. The row names correspond to the dates on which the curve was calculated,
while the columns represent maturities as years.</p>
</td></tr>
<tr><td><code id="curve.calculation_+3A_asset.type">asset.type</code></td>
<td>
<p>String that determines the asset type to value. See also
'Details'.</p>
</td></tr>
<tr><td><code id="curve.calculation_+3A_freq">freq</code></td>
<td>
<p>Frequency of payments of a given asset in a year. For LIBOR and
IBR the default frequency is four (quarterly payments). TES has a default
frequency of one (annual payments).</p>
</td></tr>
<tr><td><code id="curve.calculation_+3A_rate.type">rate.type</code></td>
<td>
<p>(1) for annual compounded discount rates and (0) for continuosly
compounded discount rates. By default, rates are assumed to be the former.</p>
</td></tr>
<tr><td><code id="curve.calculation_+3A_daycount">daycount</code></td>
<td>
<p>Day count convention. See also 'Details'.</p>
</td></tr>
<tr><td><code id="curve.calculation_+3A_fwd">fwd</code></td>
<td>
<p>Numeric value that determines if the desired output curve is a
forward or a spot curve. Set <code>0</code> for spot curve (default), <code>1</code>
otherwise.</p>
</td></tr>
<tr><td><code id="curve.calculation_+3A_npieces">npieces</code></td>
<td>
<p>Number of constant or linear segments for the curve to incorporate. By
default <code>NULL</code>, and bootstrapping method is used, otherwise, minimization of
RSS is used.</p>
</td></tr>
<tr><td><code id="curve.calculation_+3A_obj">obj</code></td>
<td>
<p>String related to the definition of the error in the RSS methodology.
Set <code>"Price"</code> for minimization of error by price or <code>"Rate"</code> for
minimization of error by rate.</p>
</td></tr>
<tr><td><code id="curve.calculation_+3A_weights">Weights</code></td>
<td>
<p>Vector of weights used to dot product with residual squares in order to
calculate residual sum of squares. By default, each residual is assigned the same weight.</p>
</td></tr>
<tr><td><code id="curve.calculation_+3A_nsimul">nsimul</code></td>
<td>
<p>Number of simulations for the terms of the pieces. The more simulations,
the more likely to find a better local solution. By default <code>1</code>, and terms are
defined in such way each piece occupies the same length in the abscissa axis.</p>
</td></tr>
<tr><td><code id="curve.calculation_+3A_piece.term">piece.term</code></td>
<td>
<p>Vector that establishes a unique term structure for optimization to take place.
Each piece or segment must have a unique maturity, as numeric value in years,
that signifies the end of the segment. Last segment maturity must not be introduced, it is assumed to be equivalent to
the last term introduced on analysis date. Therefore, the <code>piece.term</code> vector must always have a length equal to <code>npieces</code> - 1.</p>
</td></tr>
<tr><td><code id="curve.calculation_+3A_nodes">nodes</code></td>
<td>
<p>Desired output nodes of the curve.</p>
</td></tr>
<tr><td><code id="curve.calculation_+3A_approximation">approximation</code></td>
<td>
<p>String that establish the approximation. Set
<code>'linear'</code> for a piecewise linear approximation, or <code>'constant'</code> for a
piecewise constant curve.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>asset.type</code> makes reference to the following type of assets:
</p>

<ul>
<li><p> &quot;TES&quot; for Colombian Treasury Bonds (default).
</p>
</li>
<li><p> &quot;IBRSwaps&quot; for swaps indexed to IBR rate.
</p>
</li>
<li><p> &quot;LIBORSwaps&quot; for Interest Rate Swaps (IRS) indexed to 3M LIBOR.
</p>
</li>
<li><p> &quot;FixedIncome&quot; for assets that are indexed to a fixed income with
different frequency of payments.
</p>
</li></ul>

<p>If <code>npieces = NULL</code> uses a recursive iteration process based in
bootstrapping where the curve is constructed through a minimization of the MAE
between the dirty price of historical assets and an approximation of the theoretical
price of assets of same maturity. Uses the &quot;L-BFGS-B&quot; optimization method
to minimize the expected MAE. Otherwise, curve is constructed through minimization
of RSS where the error can be defined via price or rate.
</p>


<h3>Value</h3>

<p>Zero Coupon curves for the corresponding analysis dates.
If <code>fwd = 1</code>, returns forward curves.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Previous curve input
previous.curve &lt;- matrix(0.04,nrow = 2,ncol = 8)
rownames(previous.curve) &lt;- c("2014-01-01","2015-01-01")
colnames(previous.curve) &lt;- c(0, 0.25, 0.5, 1:5)
# IRR's input
serie &lt;- matrix(NA,nrow = 4,ncol = 6)
rownames(serie) &lt;- c("2014-01-01","2015-01-01","2016-01-01","2017-01-01")
colnames(serie) &lt;- c(0, 0.08333, 0.25, 0.5, 1, 2)
serie[1,1] &lt;- 0.040; serie[1,2] &lt;- 0.050; serie[1,3] &lt;- 0.060; serie[1,4] &lt;- 0.065
serie[1,5] &lt;- 0.070; serie[1,6] &lt;- 0.075
serie[2,1] &lt;- 0.030; serie[2,2] &lt;- 0.040; serie[2,3] &lt;- 0.050; serie[2,4] &lt;- 0.063
serie[2,5] &lt;- 0.074; serie[2,6] &lt;- 0.080
serie[3,1] &lt;- 0.060; serie[3,2] &lt;- 0.065; serie[3,3] &lt;- 0.070; serie[3,4] &lt;- 0.080
serie[3,5] &lt;- 0.084; serie[3,6] &lt;- 0.090
serie[4,1] &lt;- 0.020; serie[4,2] &lt;- 0.030; serie[4,3] &lt;- 0.040; serie[4,4] &lt;- 0.042
serie[4,5] &lt;- 0.045; serie[4,6] &lt;- 0.050
# Market Assets input
market.assets &lt;- matrix(NA,nrow = 10,ncol = 2)
market.assets[1,1]  &lt;- 0.040 ; market.assets[2,1]  &lt;- 0.05
market.assets[3,1]  &lt;- 0.060 ; market.assets[4,1]  &lt;- 0.07
market.assets[5,1]  &lt;- 0.080 ; market.assets[6,1]  &lt;- 0.09
market.assets[7,1]  &lt;- 0.060 ; market.assets[8,1]  &lt;- 0.07
market.assets[9,1]  &lt;- 0.075 ; market.assets[10,1] &lt;- 0.07
market.assets[1,2]  &lt;- "2016-01-01" ; market.assets[2,2]  &lt;- "2016-02-01"
market.assets[3,2]  &lt;- "2016-04-01" ; market.assets[4,2]  &lt;- "2016-07-01"
market.assets[5,2]  &lt;- "2017-01-01" ; market.assets[6,2]  &lt;- "2017-02-01"
market.assets[7,2]  &lt;- "2017-04-01" ; market.assets[8,2]  &lt;- "2017-07-01"
market.assets[9,2]  &lt;- "2018-01-01" ; market.assets[10,2] &lt;- "2019-01-01"
#Calculation
curve.calculation(serie = serie, market.assets = market.assets,
                  previous.curve = previous.curve, asset.type = "TES",
                  freq = 1, rate.type = 1, fwd = 0,
                  nodes = c(0, 0.25, 0.5, 1:5), approximation = "linear")


</code></pre>

<hr>
<h2 id='curve.calibration'>Curve calibration</h2><span id='topic+curve.calibration'></span>

<h3>Description</h3>

<p>Function that calibrates and returns a Zero Coupon curve based
on the coupon rates and IRR's of the assets. Uses the bootstrap method to find, recursively, the
corresponding Zero Coupon rates given by the market data. This rates are
then optimized by the minimization of the MAE between bond values given by
the constructed rates and bond market value. Alternatively, uses minimization of
residual sum of squares (RSS), allowing user to optimize or define an specific
term structure of the segments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curve.calibration(
  yield.curve,
  market.assets = NULL,
  noSpots = NULL,
  analysis.date = Sys.Date(),
  asset.type = "IBRSwaps",
  freq = 4,
  rate.type = 0,
  daycount = NULL,
  fwd = 0,
  npieces = NULL,
  obj = "Price",
  Weights = NULL,
  nsimul = 1,
  piece.term = NULL,
  nodes = seq(0, 10, 0.001),
  approximation = "linear"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curve.calibration_+3A_yield.curve">yield.curve</code></td>
<td>
<p>Internal rates of return of the market assets.
Series of rates with different maturities that adjust to the
time structure of the curve to calibrate and construct. <code>names(yield.curve)</code> needs to
include the numeric maturities in years of each rate, unless the input <code>market.assets</code> includes the maturities
as dates.</p>
</td></tr>
<tr><td><code id="curve.calibration_+3A_market.assets">market.assets</code></td>
<td>
<p>Matrix containing the market assets. The first column
contains the coupon rates of the assets and the second column represents their
corresponding maturities as a date. This input is only required if IRR's of assets differ from
coupon rate.</p>
</td></tr>
<tr><td><code id="curve.calibration_+3A_nospots">noSpots</code></td>
<td>
<p>Number of spot interest rates introduced in the <code>yield.curve</code> input. Function assumes spots are the
first entries on the <code>yield.curve</code> vector.</p>
</td></tr>
<tr><td><code id="curve.calibration_+3A_analysis.date">analysis.date</code></td>
<td>
<p>Date for which the curve is going to be calibrated and,
thus, constructed.</p>
</td></tr>
<tr><td><code id="curve.calibration_+3A_asset.type">asset.type</code></td>
<td>
<p>String that determines the asset type to value. See also
'Details'.</p>
</td></tr>
<tr><td><code id="curve.calibration_+3A_freq">freq</code></td>
<td>
<p>Frequency of payments of a given asset in a year. For LIBOR and
IBR the default frequency is four (quarterly payments). TES has a default
frequency of one (annual payments).</p>
</td></tr>
<tr><td><code id="curve.calibration_+3A_rate.type">rate.type</code></td>
<td>
<p>(1) for annual compounded discount rates and (0) for continuosly
compounded discount rates. By default, rates are assumed to be the former.</p>
</td></tr>
<tr><td><code id="curve.calibration_+3A_daycount">daycount</code></td>
<td>
<p>Day count convention. See also 'Details'.</p>
</td></tr>
<tr><td><code id="curve.calibration_+3A_fwd">fwd</code></td>
<td>
<p>Numeric value that determines if the desired output curve is a
forward or a spot curve. Set <code>0</code> for spot curve (default), <code>1</code>
otherwise.</p>
</td></tr>
<tr><td><code id="curve.calibration_+3A_npieces">npieces</code></td>
<td>
<p>Number of constant or linear segments for the curve to incorporate. By
default <code>NULL</code>, and bootstrapping method is used, otherwise, minimization of
RSS is used.</p>
</td></tr>
<tr><td><code id="curve.calibration_+3A_obj">obj</code></td>
<td>
<p>String related to the definition of the error in the RSS methodology.
Set <code>"Price"</code> for minimization of error by price or <code>"Rate"</code> for
minimization of error by rate.</p>
</td></tr>
<tr><td><code id="curve.calibration_+3A_weights">Weights</code></td>
<td>
<p>Vector of weights used to dot product with residual squares in order to
calculate residual sum of squares. By default, each residual is assigned the same weight.</p>
</td></tr>
<tr><td><code id="curve.calibration_+3A_nsimul">nsimul</code></td>
<td>
<p>Number of simulations for the terms of the pieces. The more simulations,
the more likely to find a better local solution. By default <code>1</code>, and terms are
defined in such way each piece occupies the same length in the abscissa axis.</p>
</td></tr>
<tr><td><code id="curve.calibration_+3A_piece.term">piece.term</code></td>
<td>
<p>Vector that establishes a unique term structure for optimization to take place.
Each piece or segment must have a unique maturity, as numeric value in years,
that signifies the end of the segment. Last segment maturity must not be introduced, it is assumed to be equivalent to
the last term introduced on analysis date. Therefore, the <code>piece.term</code> vector must always have a length equal to <code>npieces</code> - 1.</p>
</td></tr>
<tr><td><code id="curve.calibration_+3A_nodes">nodes</code></td>
<td>
<p>Desired output nodes of the curve.</p>
</td></tr>
<tr><td><code id="curve.calibration_+3A_approximation">approximation</code></td>
<td>
<p>String that establish the approximation. Set
<code>'linear'</code> for a piecewise linear approximation, or <code>'constant'</code> for a
piecewise constant curve.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>asset.type</code> makes reference to the following type of assets:
</p>

<ul>
<li><p> &quot;TES&quot; for Colombian Treasury Bonds (default).
</p>
</li>
<li><p> &quot;IBRSwaps&quot; for swaps indexed to IBR rate.
</p>
</li>
<li><p> &quot;LIBORSwaps&quot; for Interest Rate Swaps (IRS) indexed to 3M LIBOR.
</p>
</li>
<li><p> &quot;FixedIncome&quot; for assets that are indexed to a fixed income with
different frequency of payments.
</p>
</li></ul>

<p>If <code>npieces = NULL</code> uses a recursive iteration process based in
bootstrapping where the curve is constructed through a minimization of the MAE
between the dirty price of historical market assets and an approximation of the theoretical
price of assets of same maturity. Uses the &quot;L-BFGS-B&quot; optimization method
to minimize the expected MAE. Otherwise, curve is constructed through minimization
of RSS where the error can be defined via price or rate.
</p>


<h3>Value</h3>

<p>Zero Coupon curve for a specific date based on historical spot rates
and bond structures.
</p>


<h3>Author(s)</h3>

<p>Andres Galeano &amp; Camilo Díaz
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create input
yield.curve &lt;- c(0.103,0.1034,0.1092, 0.1161, 0.1233, 0.1280, 0.1310, 0.1320, 0.1325, 0.1320)
names(yield.curve) &lt;- c(0,0.08,0.25,0.5,1,2,3,5,7,10)
nodes &lt;- seq(0,10,0.001)

market.assets &lt;- matrix(NA,nrow = 10,ncol = 2)
market.assets[1,1] &lt;- 0.1030 ; market.assets[2,1]  &lt;- 0.1044
market.assets[3,1] &lt;- 0.1083 ; market.assets[4,1]  &lt;- 0.1010
market.assets[5,1] &lt;- 0.1120 ; market.assets[6,1]  &lt;- 0.1130
market.assets[7,1] &lt;- 0.1150 ; market.assets[8,1]  &lt;- 0.1160
market.assets[9,1] &lt;- 0.1150 ; market.assets[10,1] &lt;- 0.13
market.assets[1,2] &lt;- "2019-01-03" ; market.assets[2,2]  &lt;- "2019-02-03"
market.assets[3,2] &lt;- "2019-04-03" ; market.assets[4,2]  &lt;- "2019-07-03"
market.assets[5,2] &lt;- "2020-01-03" ; market.assets[6,2]  &lt;- "2021-01-03"
market.assets[7,2] &lt;- "2022-01-03" ; market.assets[8,2]  &lt;- "2024-07-03"
market.assets[9,2] &lt;- "2026-01-03" ; market.assets[10,2] &lt;- "2029-01-03"

# Function
curve.calibration (yield.curve = yield.curve, market.assets = market.assets,
                  analysis.date = "2019-01-03" , asset.type = "IBRSwaps",
                  freq = 4, daycount = "ACT/365", fwd = 0, nodes = nodes,
                  approximation = "linear")


</code></pre>

<hr>
<h2 id='discount.factors'>Discount factors</h2><span id='topic+discount.factors'></span>

<h3>Description</h3>

<p>Function that calculates discount factors given effective payment dates
and a discount rate. Optional parameters available to calculate discrete
or continuous discount factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discount.factors(
  dates,
  rates,
  analysis.date = Sys.Date(),
  rate.type = 1,
  freq = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discount.factors_+3A_dates">dates</code></td>
<td>
<p>Coupon payment dates.</p>
</td></tr>
<tr><td><code id="discount.factors_+3A_rates">rates</code></td>
<td>
<p>Discount rates given by the zero coupon rate curve.
Can also be a unique discount rate.</p>
</td></tr>
<tr><td><code id="discount.factors_+3A_analysis.date">analysis.date</code></td>
<td>
<p>Date in which the asset is valued. By default, the
current date.</p>
</td></tr>
<tr><td><code id="discount.factors_+3A_rate.type">rate.type</code></td>
<td>
<p>(1) for discrete compounded discount rates and (0) for continuosly
compounded discount rates. By default rates are assumed to be discrete.</p>
</td></tr>
<tr><td><code id="discount.factors_+3A_freq">freq</code></td>
<td>
<p>Frequency of payments of a given asset in a year. For LIBOR and
IBR the default frequency is four (quarterly payments). TES has a default
frequency of one (annual payments).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Discount factors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>discount.factors(dates = c("2020-09-10", "2020-12-10", "2021-03-10"), rates = c(0.07, 0.075, 0.08),
                 analysis.date = "2010-09-01")
discount.factors(dates = c("2025-09-01", "2025-12-01", "2026-03-01", "2026-06-01"),
                 rates = c(0.01, 0.015, 0.017, 0.02), analysis.date = "2025-06-01",
                 rate.type = 1, freq = 4)

</code></pre>

<hr>
<h2 id='discount.time'>Quantil's discount time convention</h2><span id='topic+discount.time'></span>

<h3>Description</h3>

<p>Function to count the number of years between dates according
to Quantil's discount convention. A year is defined as the difference in one year,
between two dates with the exact month and day. Meanwhile, partial years are defined as the
quotient between the number of elapsed days within a year and the total number of days that
make up that year. Total number of years between the two dates is then the sum between complete full
years and the partial portion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discount.time(tinitial, tfinal)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discount.time_+3A_tinitial">tinitial</code></td>
<td>
<p>Initial date of analysis.</p>
</td></tr>
<tr><td><code id="discount.time_+3A_tfinal">tfinal</code></td>
<td>
<p>Final date of analysis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There is an exception. For example, for initial date 29-February, a year is defined as the
28 of February of the next year. Meanwhile four years, is defined as 29 of February four years after.
</p>


<h3>Value</h3>

<p>Number of years between the specified dates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>discount.time(tinitial = "2024-07-13", tfinal = "2025-03-01")
discount.time(tinitial = "2024-02-29", tfinal = "2025-02-28")
discount.time(tinitial = "2024-02-29", tfinal = "2028-02-29")

</code></pre>

<hr>
<h2 id='fwd2spot'>Forward curve conversion</h2><span id='topic+fwd2spot'></span>

<h3>Description</h3>

<p>Uses a recursive method to calculate the implicit spot rates of
a given forward curve. Calculations and formulas based on the definition of
forward rates where <code class="reqn">\exp{-rT} = \exp{-\int{f(t)dt}}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fwd2spot(dates, fwd, approximation = "constant")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fwd2spot_+3A_dates">dates</code></td>
<td>
<p>Term structure of rates.</p>
</td></tr>
<tr><td><code id="fwd2spot_+3A_fwd">fwd</code></td>
<td>
<p>Numeric vector of forward rates to be converted.</p>
</td></tr>
<tr><td><code id="fwd2spot_+3A_approximation">approximation</code></td>
<td>
<p>String that establish the approximation. Set
<code>'linear'</code> for a piecewise linear approximation, or <code>'constant'</code> for a
piecewise constant curve.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Requires continuous rates. Recommended that the input forward curve
starts with maturity 0, if not, function will approximate zero node
as equal to node 1 (first term structure). Output forward
curve slightly differs from empirical curve as it calculates an implicit
forward curve.
</p>


<h3>Value</h3>

<p>Implicit spot curve based on the input forward rates and input term
structure.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Inputs for calibration of forward curve
yield.curve &lt;- c(0.015,0.0175, 0.0225, 0.0275, 0.0325, 0.0375,0.04,0.0425,0.045,0.0475,0.05)
names(yield.curve) &lt;- c(0.5,1,2,3,4,5,6,7,8,9,10)
nodes &lt;- seq(0,10,0.5)
# Calibration
fwd &lt;- curve.calibration (yield.curve = yield.curve, market.assets = NULL,
                          analysis.date = "2019-01-03", asset.type = "IBRSwaps",
                          freq = 4, rate.type = 0, daycount = "ACT/365",  fwd = 1,
                          npieces = NULL, nodes = nodes, approximation = "constant")
# Forward to Spot
dates &lt;- names(fwd)
fwd2spot(dates, fwd, approximation = "constant")

</code></pre>

<hr>
<h2 id='price.dirty2clean'>From one price to another</h2><span id='topic+price.dirty2clean'></span>

<h3>Description</h3>

<p>Converts bond prices from dirty to clean and viceversa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>price.dirty2clean(
  maturity,
  analysis.date = Sys.Date(),
  price,
  dirty = 1,
  coupon.rate,
  principal = 1,
  asset.type = "TES",
  freq = NULL,
  daycount = "NL/365"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="price.dirty2clean_+3A_maturity">maturity</code></td>
<td>
<p>Last day of the contract: YYYY-MM-DD.
Alternatively, it can be a numeric value that represents the duration of the contract in years.</p>
</td></tr>
<tr><td><code id="price.dirty2clean_+3A_analysis.date">analysis.date</code></td>
<td>
<p>Date in which the asset is valued. By default, the
current date.</p>
</td></tr>
<tr><td><code id="price.dirty2clean_+3A_price">price</code></td>
<td>
<p>Numeric value. Price of the bond to convert.</p>
</td></tr>
<tr><td><code id="price.dirty2clean_+3A_dirty">dirty</code></td>
<td>
<p>Numeric value. Determines if the input price corresponds to the
dirty price or the clean price. For dirty price, set <code>dirty = 1</code>.
Otherwise, <code>dirty = 0</code></p>
</td></tr>
<tr><td><code id="price.dirty2clean_+3A_coupon.rate">coupon.rate</code></td>
<td>
<p>Coupon rate of the asset. Can be an unique numeric
value or a vector corresponding to each coupon payment date.</p>
</td></tr>
<tr><td><code id="price.dirty2clean_+3A_principal">principal</code></td>
<td>
<p>Notional amount for the asset.</p>
</td></tr>
<tr><td><code id="price.dirty2clean_+3A_asset.type">asset.type</code></td>
<td>
<p>String that determines the asset type to value. See also
'Details'.</p>
</td></tr>
<tr><td><code id="price.dirty2clean_+3A_freq">freq</code></td>
<td>
<p>Frequency of payments of a given asset in a year. For LIBOR and
IBR the default frequency is four (quarterly payments). TES has a default
frequency of one (annual payments).</p>
</td></tr>
<tr><td><code id="price.dirty2clean_+3A_daycount">daycount</code></td>
<td>
<p>Day count convention. See also 'Details'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>asset.type</code> makes reference to the following type of assets:
</p>

<ul>
<li><p> &quot;TES&quot; for Colombian Treasury Bonds (default).
</p>
</li>
<li><p> &quot;FixedIncome&quot; for assets that are indexed to a fixed income with
different frequency of payments.
</p>
</li>
<li><p> &quot;IBR&quot; for bonds and assets indexed to 3M IBR rate.
</p>
</li>
<li><p> &quot;LIBOR&quot; for bonds and assets indexed to 3M LIBOR.
</p>
</li></ul>

<p><code>daycount</code> convention accepts the following values:
</p>

<ul>
<li><p> 30/360.
</p>
</li>
<li><p> ACT/365.
</p>
</li>
<li><p> ACT/360 (Default).
</p>
</li>
<li><p> ACT/365L.
</p>
</li>
<li><p> NL/365.
</p>
</li>
<li><p> ACT/ACT-ISDA
</p>
</li>
<li><p> ACT/ACT-AFB
</p>
</li></ul>



<h3>Value</h3>

<p>The dirty price or clean price of a bond.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>price.dirty2clean(maturity = "2026-01-03", analysis.date = "2023-01-02",
                  price = 1, dirty = 1, coupon.rate = 0.04, principal = 1)
price.dirty2clean(maturity = "2026-01-03", analysis.date = "2023-01-02",
                  price = 0.9601096, dirty = 0, coupon.rate = 0.04, principal = 1)
</code></pre>

<hr>
<h2 id='sens.bonds'>Bond Sensitivity</h2><span id='topic+sens.bonds'></span>

<h3>Description</h3>

<p>Calculates the sensitivity of a given bond by numerically averaging
the percentage change in bonds price when moving upwards and downwards, by 1 basic point,
the Yield to Maturity vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sens.bonds(
  input,
  price,
  maturity,
  analysis.date = Sys.Date(),
  coupon.rate,
  principal = 1,
  asset.type = "TES",
  freq = 1,
  rate.type = 1,
  spread = 0,
  daycount = "ACT/365",
  dirty = 1,
  convention = "F",
  trade.date = NULL,
  coupon.schedule = "SF"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sens.bonds_+3A_input">input</code></td>
<td>
<p>String that establishes if the <code>price</code> input corresponds to the
Internal Rate of Return (IRR) of the bond or the market price. Set
<code>"rate"</code> for the IRR. Otherwise, <code>"price"</code>.</p>
</td></tr>
<tr><td><code id="sens.bonds_+3A_price">price</code></td>
<td>
<p>Numeric value of either market price or Internal Rate of Return of a
given bond. Instead of IRR, can also be a vector of multiple rates, one for every
coupon date.</p>
</td></tr>
<tr><td><code id="sens.bonds_+3A_maturity">maturity</code></td>
<td>
<p>Last day of the contract: YYYY-MM-DD.
Alternatively, it can be a numeric value that represents the duration of the contract in years.</p>
</td></tr>
<tr><td><code id="sens.bonds_+3A_analysis.date">analysis.date</code></td>
<td>
<p>Date in which the asset is valued. By default, the
current date.</p>
</td></tr>
<tr><td><code id="sens.bonds_+3A_coupon.rate">coupon.rate</code></td>
<td>
<p>Coupon rate of the asset. Can be an unique numeric
value or a vector corresponding to each coupon payment date.</p>
</td></tr>
<tr><td><code id="sens.bonds_+3A_principal">principal</code></td>
<td>
<p>Notional amount for the asset.</p>
</td></tr>
<tr><td><code id="sens.bonds_+3A_asset.type">asset.type</code></td>
<td>
<p>String that determines the asset type to value. See also
'Details'.</p>
</td></tr>
<tr><td><code id="sens.bonds_+3A_freq">freq</code></td>
<td>
<p>Frequency of payments of a given asset in a year. For LIBOR and
IBR the default frequency is four (quarterly payments). TES has a default
frequency of one (annual payments).</p>
</td></tr>
<tr><td><code id="sens.bonds_+3A_rate.type">rate.type</code></td>
<td>
<p>(1) for discrete compounded discount rates and (0) for continuosly
compounded discount rates. By default rates are assumed to be discrete.</p>
</td></tr>
<tr><td><code id="sens.bonds_+3A_spread">spread</code></td>
<td>
<p>Decimal value of spread added to coupon payment rate. By
default, <code>0</code>.</p>
</td></tr>
<tr><td><code id="sens.bonds_+3A_daycount">daycount</code></td>
<td>
<p>Day count convention. See also 'Details'.</p>
</td></tr>
<tr><td><code id="sens.bonds_+3A_dirty">dirty</code></td>
<td>
<p>Numeric value to determine if the calculated price is dirty or
clean. To calculate dirty price, set <code>dirty = 1</code>. Otherwise,
<code>dirty = 0</code>.</p>
</td></tr>
<tr><td><code id="sens.bonds_+3A_convention">convention</code></td>
<td>
<p>String that establishes if the effective dates are
calculated using Following, Modified Following, Backward or Backward Following.
See also 'Details'.</p>
</td></tr>
<tr><td><code id="sens.bonds_+3A_trade.date">trade.date</code></td>
<td>
<p>The date on which the transaction occurs. It is used to calculate
maturity as a date, when given in years. Also required for non-trivial cases such as
bonds with long first coupon.</p>
</td></tr>
<tr><td><code id="sens.bonds_+3A_coupon.schedule">coupon.schedule</code></td>
<td>
<p>String that establishes if a bond first coupon period is a long
first coupon or a short first coupon. On the contrary, establishes if last coupon period
is long last coupon or a short last coupon. See also 'Details'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>asset.type</code> makes reference to the following type of assets:
</p>

<ul>
<li><p> &quot;TES&quot; for Colombian Treasury Bonds (default).
</p>
</li>
<li><p> &quot;FixedIncome&quot; for assets that are indexed to a fixed income with
different frequency of payments.
</p>
</li>
<li><p> &quot;IBR&quot; for bonds and assets indexed to 3M IBR rate.
</p>
</li>
<li><p> &quot;LIBOR&quot; for bonds and assets indexed to 3M LIBOR.
</p>
</li></ul>

<p><code>daycount</code> convention accepts the following values:
</p>

<ul>
<li><p> 30/360.
</p>
</li>
<li><p> ACT/365.
</p>
</li>
<li><p> ACT/360 (Default).
</p>
</li>
<li><p> ACT/365L.
</p>
</li>
<li><p> NL/365.
</p>
</li>
<li><p> ACT/ACT-ISDA
</p>
</li>
<li><p> ACT/ACT-AFB
</p>
</li></ul>

<p><code>convention</code> makes reference to the following type of business day conventions:
</p>

<ul>
<li><p> &quot;F&quot; for Following business day convention.
</p>
</li>
<li><p> &quot;MF&quot; for Modified Following business day convention.
</p>
</li>
<li><p> &quot;B&quot; for Backward business day convention.
</p>
</li>
<li><p> &quot;MB&quot; for Modified Backward business day convention.
</p>
</li></ul>

<p><code>coupon.schedule</code> makes reference to the following type of coupon payment schedule
of a bond:
</p>

<ul>
<li><p> &quot;LF&quot; for Long First coupon payment.
</p>
</li>
<li><p> &quot;LL&quot; for Long Last coupon payment.
</p>
</li>
<li><p> &quot;SF&quot; for Short First coupon payment.
</p>
</li>
<li><p> &quot;SL&quot; for Short Last coupon payment.
</p>
</li></ul>



<h3>Value</h3>

<p>Bond sensitivity
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sens.bonds(input = c("price"), price = 0.98, maturity = "2023-01-03",
           analysis.date = "2019-01-05", coupon.rate = 0.04,
           principal = 1, asset.type = "IBR", rate.type = 1)
sens.bonds(input = c("rate"), price = rep(0.08,8), maturity = "2023-01-03",
           analysis.date = "2015-02-03", coupon.rate = 0.04,
           principal = 1, asset.type = "FixedIncome", freq = 1,
           rate.type = 1, daycount = "ACT/365", dirty = 1,
           convention = "MB", trade.date = "2015-02-03",
           coupon.schedule = "LF")

</code></pre>

<hr>
<h2 id='spot2forward'>Spot curve conversion</h2><span id='topic+spot2forward'></span>

<h3>Description</h3>

<p>Uses a recursive method to calculate the instantaneous forward
rates of a given spot curve. Calculations and formulas based on the
definition of forward rates where <code class="reqn">\exp{-rT} = \exp{-\int{f(t)dt}}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spot2forward(dates, spot, approximation = "constant")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spot2forward_+3A_dates">dates</code></td>
<td>
<p>Term structure of rates.</p>
</td></tr>
<tr><td><code id="spot2forward_+3A_spot">spot</code></td>
<td>
<p>Vector of spot rates to be converted.</p>
</td></tr>
<tr><td><code id="spot2forward_+3A_approximation">approximation</code></td>
<td>
<p>String that establish the approximation. Set
<code>'linear'</code> for a piecewise linear approximation, or <code>'constant'</code> for a
piecewise constant curve.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Requires continuous rates. Recommended that the input spot curve
starts with maturity 0, if not, input function will approximate zero node
as equal to node 1 (first term structure). The time partition and available
data affects calculation and precision of resulting forward curve. Output
forward curve slightly differs from empirical curve as it calculates an
implied instantaneous forward curve.
</p>


<h3>Value</h3>

<p>Instantaneous forward curve based on the input spot and the input term
structure.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Inputs for calibration of spot curve
yield.curve &lt;- c(0.015,0.0175, 0.0225, 0.0275, 0.0325, 0.0375,0.04,0.0425,0.045,0.0475,0.05)
names(yield.curve) &lt;- c(0.5,1,2,3,4,5,6,7,8,9,10)
nodes &lt;- seq(0,10,0.001)
# Calibration
spot &lt;- curve.calibration (yield.curve = yield.curve, market.assets = NULL,
                           analysis.date = "2019-01-03", asset.type = "IBRSwaps",
                           freq = 4, rate.type = 0, fwd = 0, npieces = NULL,
                           obj = "Price", nodes = nodes, approximation = "linear")
# Spot to Forward
dates &lt;- names(spot)
spot2forward(dates, spot, approximation = "linear")

</code></pre>

<hr>
<h2 id='valuation.bonds'>Bond valuation</h2><span id='topic+valuation.bonds'></span>

<h3>Description</h3>

<p>Function that values various asset types with varying payment frequencies.
It covers fixed-coupon assets, spread income assets, floating notes and fixed legs of
interest rate swaps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>valuation.bonds(
  maturity,
  coupon.rate,
  rates,
  principal = 1,
  analysis.date = Sys.Date(),
  asset.type = "TES",
  freq = NULL,
  rate.type = 1,
  spread = 0,
  daycount = "NL/365",
  dirty = 1,
  convention = "F",
  trade.date = NULL,
  coupon.schedule = "SF",
  spread.only = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="valuation.bonds_+3A_maturity">maturity</code></td>
<td>
<p>Last day of the contract: YYYY-MM-DD.
Alternatively, it can be a numeric value that represents the duration of the contract in years.</p>
</td></tr>
<tr><td><code id="valuation.bonds_+3A_coupon.rate">coupon.rate</code></td>
<td>
<p>Coupon rate of the asset. Can be an unique numeric
value or a vector corresponding to each coupon payment date.</p>
</td></tr>
<tr><td><code id="valuation.bonds_+3A_rates">rates</code></td>
<td>
<p>Discount rates given by the zero coupon rate curve.
Can also be a unique discount rate.</p>
</td></tr>
<tr><td><code id="valuation.bonds_+3A_principal">principal</code></td>
<td>
<p>Notional amount for the asset.</p>
</td></tr>
<tr><td><code id="valuation.bonds_+3A_analysis.date">analysis.date</code></td>
<td>
<p>Date in which the asset is valued. By default, the
current date.</p>
</td></tr>
<tr><td><code id="valuation.bonds_+3A_asset.type">asset.type</code></td>
<td>
<p>String that determines the asset type to value. See also
'Details'.</p>
</td></tr>
<tr><td><code id="valuation.bonds_+3A_freq">freq</code></td>
<td>
<p>Frequency of payments of a given asset in a year. For LIBOR and
IBR the default frequency is four (quarterly payments). TES has a default
frequency of one (annual payments).</p>
</td></tr>
<tr><td><code id="valuation.bonds_+3A_rate.type">rate.type</code></td>
<td>
<p>(1) for annual compounded discount rates and (0) for continuosly
compounded discount rates. By default, rates are assumed to be the former.</p>
</td></tr>
<tr><td><code id="valuation.bonds_+3A_spread">spread</code></td>
<td>
<p>Decimal value of spread added to coupon payment rate. By
default, <code>0</code>.</p>
</td></tr>
<tr><td><code id="valuation.bonds_+3A_daycount">daycount</code></td>
<td>
<p>Day count convention. See also 'Details'.</p>
</td></tr>
<tr><td><code id="valuation.bonds_+3A_dirty">dirty</code></td>
<td>
<p>Numeric value to determine if the calculated price is dirty or
clean. To calculate dirty price, set <code>dirty = 1</code>. Otherwise,
<code>dirty = 0</code>.</p>
</td></tr>
<tr><td><code id="valuation.bonds_+3A_convention">convention</code></td>
<td>
<p>String that establishes if the effective dates are
calculated using Following, Modified Following, Backward or Backward Following.
See also 'Details'.</p>
</td></tr>
<tr><td><code id="valuation.bonds_+3A_trade.date">trade.date</code></td>
<td>
<p>The date on which the transaction occurs. It is used to calculate
maturity as a date, when given in years. Also required for non-trivial cases such as
bonds with long first coupon.</p>
</td></tr>
<tr><td><code id="valuation.bonds_+3A_coupon.schedule">coupon.schedule</code></td>
<td>
<p>String that establishes if a bond first coupon period is a long
first coupon or a short first coupon. On the contrary, establishes if last coupon period
is long last coupon or a short last coupon. See also 'Details'.</p>
</td></tr>
<tr><td><code id="valuation.bonds_+3A_spread.only">spread.only</code></td>
<td>
<p>Logical condition that establishes if the output should just include
the spread or the complete bond value. By default, <code>FALSE</code>, referring to the
output being bond value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>asset.type</code> makes reference to the following type of assets:
</p>

<ul>
<li><p> &quot;TES&quot; for Colombian Treasury Bonds (default).
</p>
</li>
<li><p> &quot;FixedIncome&quot; for assets that are indexed to a fixed income with
different frequency of payments.
</p>
</li>
<li><p> &quot;IBR&quot; for bonds and assets indexed to 3M IBR rate.
</p>
</li>
<li><p> &quot;LIBOR&quot; for bonds and assets indexed to 3M LIBOR.
</p>
</li></ul>

<p><code>daycount</code> convention accepts the following values:
</p>

<ul>
<li><p> 30/360.
</p>
</li>
<li><p> ACT/365.
</p>
</li>
<li><p> ACT/360 (Default).
</p>
</li>
<li><p> ACT/365L.
</p>
</li>
<li><p> NL/365.
</p>
</li>
<li><p> ACT/ACT-ISDA
</p>
</li>
<li><p> ACT/ACT-AFB
</p>
</li></ul>

<p><code>convention</code> makes reference to the following type of business day conventions:
</p>

<ul>
<li><p> &quot;F&quot; for Following business day convention.
</p>
</li>
<li><p> &quot;MF&quot; for Modified Following business day convention.
</p>
</li>
<li><p> &quot;B&quot; for Backward business day convention.
</p>
</li>
<li><p> &quot;MB&quot; for Modified Backward business day convention.
</p>
</li></ul>

<p><code>coupon.schedule</code> makes reference to the following type of coupon payment schedule
of a bond:
</p>

<ul>
<li><p> &quot;LF&quot; for Long First coupon payment.
</p>
</li>
<li><p> &quot;LL&quot; for Long Last coupon payment.
</p>
</li>
<li><p> &quot;SF&quot; for Short First coupon payment.
</p>
</li>
<li><p> &quot;SL&quot; for Short Last coupon payment.
</p>
</li></ul>



<h3>Value</h3>

<p>Bond value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>valuation.bonds(maturity = "2026-06-01", coupon.rate = 0.06, rates = 0.08,
                analysis.date = "2022-06-01")
valuation.bonds(maturity = "2026-06-01", coupon.rate = 0.06, rates = rep(0.08,4),
                analysis.date = "2022-06-01", rate.type = 0)
valuation.bonds(maturity = "2026-06-01", analysis.date= "2025-02-27",
                coupon.rate = c(0.06, 0.062, 0.063, 0.065, 0.066, 0.068),
                rates = c(0.08, 0.082, 0.078, 0.09, 0.077, 0.085),
                asset.type = "IBR")
valuation.bonds(maturity = "2026-06-01", coupon.rate = 0.06,
                rates = 0.08, asset.type = "IBR", freq = 4,
                spread = 0.03)
valuation.bonds(maturity = 4.58, coupon.rate = 0.1256, rates = seq(0.05, 0.14, by = 0.005),
                analysis.date = "2019-07-14", asset.type = "FixedIncome", freq = 4,
                principal = 567, daycount = "ACT/360", rate.type = 0, trade.date = "2019-07-14",
                coupon.schedule = "LL")
</code></pre>

<hr>
<h2 id='valuation.swaps'>Swap valuation</h2><span id='topic+valuation.swaps'></span>

<h3>Description</h3>

<p>Function that values Interest Rate Swaps (IRS) and Cross Currency
Swaps (CCS).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>valuation.swaps(
  maturity,
  analysis.date = Sys.Date(),
  asset.type = "IBRSwaps",
  freq = 4,
  coupon.rate,
  rates,
  float.rate = NULL,
  spread = 0,
  principal = 1,
  Legs = "FF",
  ex.rate = NULL,
  basis.rates = NULL,
  coupon.rate2 = NULL,
  rates2 = NULL,
  float.rate2 = NULL,
  spread2 = 0,
  principal2 = NULL,
  rate.type = 1,
  daycount = "NL/365",
  loc = "BOG",
  convention = "F",
  trade.date = NULL,
  coupon.schedule = "SF"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="valuation.swaps_+3A_maturity">maturity</code></td>
<td>
<p>Last day of the contract: YYYY-MM-DD.
Alternatively, it can be a numeric value that represents the duration of the contract in years.</p>
</td></tr>
<tr><td><code id="valuation.swaps_+3A_analysis.date">analysis.date</code></td>
<td>
<p>Date in which the asset is valued. By default, the
current date.</p>
</td></tr>
<tr><td><code id="valuation.swaps_+3A_asset.type">asset.type</code></td>
<td>
<p>String that determines the asset type to value. See also
'Details'.</p>
</td></tr>
<tr><td><code id="valuation.swaps_+3A_freq">freq</code></td>
<td>
<p>Frequency of payments of a given asset in a year. For LIBOR and
IBR the default frequency is four (quarterly payments). TES has a default
frequency of one (annual payments).</p>
</td></tr>
<tr><td><code id="valuation.swaps_+3A_coupon.rate">coupon.rate</code></td>
<td>
<p>For (IRS), coupon rate of the fixed leg. For (CCS), coupon rate
of local fixed leg.</p>
</td></tr>
<tr><td><code id="valuation.swaps_+3A_rates">rates</code></td>
<td>
<p>For (IRS) discount rates given by the zero coupon rate curve. For (CCS),
represents discount rates for local currency. Can be a vector that corresponds
to each coupon date or a curve with at least, nodes with 3 decimals.</p>
</td></tr>
<tr><td><code id="valuation.swaps_+3A_float.rate">float.rate</code></td>
<td>
<p>For (IRS), last observed floating rate, necessary for variable leg when swap valuation
date doesn't belong to a coupon date. For (CCS), last observed local floating rate. By default,
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="valuation.swaps_+3A_spread">spread</code></td>
<td>
<p>Decimal value of spread added to coupon payment rate. By
default, <code>0</code>.</p>
</td></tr>
<tr><td><code id="valuation.swaps_+3A_principal">principal</code></td>
<td>
<p>For (IRS), notional amount for both legs. For (CCS), notional
amount of local leg.</p>
</td></tr>
<tr><td><code id="valuation.swaps_+3A_legs">Legs</code></td>
<td>
<p>For (CCS), string that establishes the type of both legs that makeup
the Cross Currency Swap. See also 'Details'.</p>
</td></tr>
<tr><td><code id="valuation.swaps_+3A_ex.rate">ex.rate</code></td>
<td>
<p>Exchange rate on analysis date. Format has to be local currency divided
by foreign currency.</p>
</td></tr>
<tr><td><code id="valuation.swaps_+3A_basis.rates">basis.rates</code></td>
<td>
<p>&quot;Discount rates&quot; given by the basis curve. Can be a vector
that corresponds to each coupon date or a curve with at least,
nodes with 3 decimals.</p>
</td></tr>
<tr><td><code id="valuation.swaps_+3A_coupon.rate2">coupon.rate2</code></td>
<td>
<p>Coupon rate of the foreign leg. By default, <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="valuation.swaps_+3A_rates2">rates2</code></td>
<td>
<p>Discount rates given by the foreign zero coupon rate curve.
Can be a vector that corresponds to each coupon date or a curve with at least,
nodes with 3 decimals.</p>
</td></tr>
<tr><td><code id="valuation.swaps_+3A_float.rate2">float.rate2</code></td>
<td>
<p>Last observed foreign floating rate. By
default, <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="valuation.swaps_+3A_spread2">spread2</code></td>
<td>
<p>Decimal value of spread added to foreign floating rate. By
default, <code>0</code>.</p>
</td></tr>
<tr><td><code id="valuation.swaps_+3A_principal2">principal2</code></td>
<td>
<p>Notional amount for the foreign leg. By
default, <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="valuation.swaps_+3A_rate.type">rate.type</code></td>
<td>
<p>(1) for annual compounded discount rates and (0) for continuosly
compounded discount rates. By default, rates are assumed to be the former.</p>
</td></tr>
<tr><td><code id="valuation.swaps_+3A_daycount">daycount</code></td>
<td>
<p>Day count convention. See also 'Details'.</p>
</td></tr>
<tr><td><code id="valuation.swaps_+3A_loc">loc</code></td>
<td>
<p>String related to the location of the asset. It is used to
calculate the effective dates, taking into account the business days
of the given location. See also 'Details'.</p>
</td></tr>
<tr><td><code id="valuation.swaps_+3A_convention">convention</code></td>
<td>
<p>String that establishes if the effective dates are
calculated using Following, Modified Following, Backward or Backward Following.
See also 'Details'.</p>
</td></tr>
<tr><td><code id="valuation.swaps_+3A_trade.date">trade.date</code></td>
<td>
<p>The date on which the transaction occurs. It is used to calculate
maturity as a date, when given in years. Also required for non-trivial cases such as
bonds with long first coupon.</p>
</td></tr>
<tr><td><code id="valuation.swaps_+3A_coupon.schedule">coupon.schedule</code></td>
<td>
<p>String that establishes if a bond first coupon period is a long
first coupon or a short first coupon. On the contrary, establishes if last coupon period
is long last coupon or a short last coupon. See also 'Details'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>asset.type</code> makes reference to the following type of assets:
</p>

<ul>
<li><p> &quot;IBRSwaps&quot; for swaps indexed to IBR rate.
</p>
</li>
<li><p> &quot;LIBORSwaps&quot; for Interest Rate Swaps (IRS) indexed to 3M LIBOR.
</p>
</li>
<li><p> &quot;CCS&quot; for cross currency swaps.
</p>
</li></ul>

<p><code>daycount</code> convention accepts the following values:
</p>

<ul>
<li><p> 30/360.
</p>
</li>
<li><p> ACT/365.
</p>
</li>
<li><p> ACT/360 (Default).
</p>
</li>
<li><p> ACT/365L.
</p>
</li>
<li><p> NL/365.
</p>
</li>
<li><p> ACT/ACT-ISDA
</p>
</li>
<li><p> ACT/ACT-AFB
</p>
</li></ul>

<p><code>convention</code> makes reference to the following type of business day conventions:
</p>

<ul>
<li><p> &quot;F&quot; for Following business day convention.
</p>
</li>
<li><p> &quot;MF&quot; for Modified Following business day convention.
</p>
</li>
<li><p> &quot;B&quot; for Backward business day convention.
</p>
</li>
<li><p> &quot;MB&quot; for Modified Backward business day convention.
</p>
</li></ul>

<p><code>coupon.schedule</code> makes reference to the following type of coupon payment schedule
of a bond:
</p>

<ul>
<li><p> &quot;LF&quot; for Long First coupon payment.
</p>
</li>
<li><p> &quot;LL&quot; for Long Last coupon payment.
</p>
</li>
<li><p> &quot;SF&quot; for Short First coupon payment.
</p>
</li>
<li><p> &quot;SL&quot; for Short Last coupon payment.
</p>
</li></ul>

<p><code>Legs</code> makes reference to the following types of legs composition of the
cross currency swap
</p>

<ul>
<li><p> &quot;FF&quot; for fixed leg in local currency and fixed leg in foreign currency.
</p>
</li>
<li><p> &quot;FV&quot; for fixed leg in local currency and variable leg in foreign currency.
</p>
</li>
<li><p> &quot;VF&quot; for variable leg in local currency and fixed leg in foreign currency.
</p>
</li>
<li><p> &quot;VV&quot; for variable leg in local currency and variable leg in foreign currency.
</p>
</li></ul>



<h3>Value</h3>

<p>Swap value for Interest Rate Swap (IRS) or Cross Currency Swap (CCR).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># (IRS) ----------------------------------------------------------------------
valuation.swaps(maturity = "2026-06-01", analysis.date= Sys.Date(),
                coupon.rate = 0.06, rates = 0.08, float.rate = 0.03)
valuation.swaps(maturity = "2021-03-09", analysis.date= "2018-03-09",
                coupon.rate = 0.05, rates = 0.08, rate.type = 0)
valuation.swaps(maturity = "2026-07-01", analysis.date = "2023-01-02",
                asset.type = "IBRSwaps", freq = 4,
                coupon.rate = 0.04, rates = rep(0.05,14),
                float.rate = 0.03, spread = 0)
# (CCS) ----------------------------------------------------------------------
# Curve Calibration for rates input
yield.curve &lt;- c(0.103,0.1034,0.1092, 0.1161, 0.1233, 0.1280, 0.1310, 0.1320, 0.1325)
names(yield.curve) &lt;- c(0,0.08,0.25,0.5,1,2,3,5,6)
nodes &lt;- seq(0, 10, by = 0.001) # Our curve has nodes with three decimals.
rates &lt;- curve.calibration (yield.curve = yield.curve, market.assets = NULL,
                            analysis.date = "2023-03-01", asset.type = "IBRSwaps",
                            freq = 4, rate.type = 0, daycount= "ACT/365",
                            fwd = 0, npieces = NULL, nodes = nodes, approximation = "constant")

# Curve Calibration for basis.rates input
nodes  &lt;- seq(0, 10, by = 0.001)
rates2 &lt;- rates/4 # It is assumed foreign curve is proportional to local spot curve.
# Swaps input for calibration
ex.rate &lt;- 4814
swaps &lt;- rbind(c("2024-03-01", "FF", 0.07 , 0.0325, NA   , NA    , 2000 * ex.rate, 2000),
c("2025-03-01", "VV", NA   , NA    , 0.015, 0.0175, 2000 * ex.rate, 2000),
c("2026-03-01", "FF", 0.075, 0.03  , NA   ,  NA   , 500000, 5000000 / ex.rate),
c("2027-03-01", "VV", NA   , NA    , 0.01 , 0.015 , 5000000, 5000000 / ex.rate),
c("2028-03-01", "FF", 0.08 ,0.035  , NA   , NA    , 3000000, 3000000 / ex.rate),
c("2029-03-01", "VV", NA   , NA    , 0.01 , 0.0125, 3000000, 3000000 / ex.rate))
colnames(swaps) &lt;- c("Mat"  ,"Legs", "C1" , "C2", "spread1", "spread2", "prin1", "prin2")
# Calibration
basis.rates &lt;- basis.curve(swaps, ex.rate = 4814, analysis.date = "2023-03-01",
                           freq = c(2,2,2,2,1,1), rates = rates, rates2 = rates2,
                           rate.type = 1, npieces = NULL, obj = "Price",
                           Weights = NULL, nodes = nodes, approximation = "linear")

# Valuation
valuation.swaps (maturity = "2024-03-01", analysis.date = "2023-03-01",
                 asset.type = "CCS", freq = 2, Legs = "FF", ex.rate = 4814,
                 coupon.rate = 0.07, coupon.rate2 = 0.0325,
                 rates = rates, rates2 = rates2, basis.rates = basis.rates,
                 float.rate = NULL, float.rate2 = NULL, spread = 0,
                 spread2 = 0, principal = 2000 * 4814, principal2 = 2000,
                 rate.type = 0, daycount = "ACT/365", loc = "BOG",
                 convention = "F")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
