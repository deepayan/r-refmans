<!DOCTYPE html><html><head><title>Help for package LTRCforests</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {LTRCforests}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#LTRCforests-package'><p>Constructs forest methods for left-truncated and right-censored (LTRC) survival data</p></a></li>
<li><a href='#ltrccif'><p>Fit a LTRC conditional inference forest</p></a></li>
<li><a href='#ltrcrrf'><p>Fit a LTRC relative risk forest</p></a></li>
<li><a href='#pbcsample'><p>Sample Mayo Clinic Primary Biliary Cirrhosis Data</p></a></li>
<li><a href='#predictProb'><p>Compute a Survival Curve from a LTRCCIF model or a LTRCRRF model</p></a></li>
<li><a href='#print'><p>Print Summary Output of a ltrccif object or a ltrcrrf object</p></a></li>
<li><a href='#sbrier_ltrc'><p>Model fit evaluation for LTRC forests.</p></a></li>
<li><a href='#tune.ltrccif'><p>Tune <code>mtry</code> to the optimal value with respect to out-of-bag error for a LTRCCIF model</p></a></li>
<li><a href='#tune.ltrcrrf'><p>Tune <code>mtry</code> to the optimal value with respect to out-of-bag error for a LTRCRRF model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.7.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-29</td>
</tr>
<tr>
<td>Title:</td>
<td>Ensemble Methods for Survival Data with Time-Varying Covariates</td>
</tr>
<tr>
<td>Author:</td>
<td>Weichi Yao [aut, cre],
  Halina Frydman [aut],
  Denis Larocque [aut],
  Jeffrey S. Simonoff [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Weichi Yao &lt;weichi.yao@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils, survival, ipred, parallel, prodlim, partykit</td>
</tr>
<tr>
<td>Suggests:</td>
<td>randomForestSRC, LTRCtrees</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements the conditional inference forest and relative risk forest 
             algorithm to modeling left-truncated right-censored data with time-invariant        
             covariates, and (left-truncated) right-censored survival data with time-varying 
             covariates. It also provides functions to tune the parameters and evaluate the 
             model fit. See Yao et al. (2022) &lt;<a href="https://doi.org/10.1177%2F09622802221111549">doi:10.1177/09622802221111549</a>&gt;.</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-30 03:33:00 UTC; weichiyao</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-30 03:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='LTRCforests-package'>Constructs forest methods for left-truncated and right-censored (LTRC) survival data</h2><span id='topic+LTRCforests-package'></span>

<h3>Description</h3>

<p>Constructs a LTRC conditional inference forest (LTRCCIF) or
a LTRC relative risk forest (LTRCRRF) for left-truncated and right-censored data,
it also allows for (left-truncated) right-censored survival data with
time-varying covariates (Yao et al. 2022).
The main functions of this package are <code><a href="#topic+ltrccif">ltrccif</a></code> and <code><a href="#topic+ltrcrrf">ltrcrrf</a></code>.
</p>


<h3>Details</h3>



<h4>Problem setup and existing methods</h4>

<p>Continuous-time survival data with time-varying covariates are common in practice.
Methods like the Cox proportional hazards model rely on restrictive assumptions such as
proportional hazards and a log-linear relationship between the hazard function and
covariates. Furthermore, because these methods are often parametric, nonlinear effects
of variables must be modeled by transformations or expanding the design matrix to
include specialized basis functions for more complex data structures in real world
applications. The functions <code><a href="LTRCtrees.html#topic+LTRCIT">LTRCIT</a></code> and
<code><a href="LTRCtrees.html#topic+LTRCART">LTRCART</a></code> provide a conditional inference tree method and 
a relative risk tree method for
left-truncated right-censored survival data, which also allows for right-censored
survival data with time-varying covariates. Tree estimators are nonparametric and 
as such often exhibit
low bias and high variance. Ensemble methods like bagging and random forest can
reduce variance while preserving low bias. 
The most popular survival forest methods, including conditional inference forest
(see <code><a href="partykit.html#topic+cforest">cforest</a></code>), relative risk forest, and random survival 
forest method (see <code><a href="randomForestSRC.html#topic+rfsrc">rfsrc</a></code>) can only be applied to 
right-censored survival data with time-invariant covariates.</p>



<h4>LTRC forests</h4>

<p>This package implements <code><a href="#topic+ltrccif">ltrccif</a></code> and <code><a href="#topic+ltrcrrf">ltrcrrf</a></code>.
<code><a href="#topic+ltrccif">ltrccif</a></code> extends the conditional inference forest
(see <code><a href="partykit.html#topic+cforest">cforest</a></code>) to LTRC survival data.
It uses LTRC conditional inference survival trees
as base learners.
<code><a href="#topic+ltrcrrf">ltrcrrf</a></code> extends the relative risk forest
(Ishwaran et al. 2004) to left-truncated right-censored survival data.
It uses LTRC risk relative tree
as base learners.
The main functions <code><a href="#topic+ltrccif">ltrccif</a></code> and <code><a href="#topic+ltrcrrf">ltrcrrf</a></code> 
fit a corresponding LTRC forest for LTRC data, with parameter
<code>mtry</code> tuned by <code><a href="#topic+tune.ltrccif">tune.ltrccif</a></code> or <code><a href="#topic+tune.ltrcrrf">tune.ltrcrrf</a></code>. This tuning
procedure relies on the evaluation of the out-of-bag errors, which is performed by the
function <code><a href="#topic+sbrier_ltrc">sbrier_ltrc</a></code>. <code><a href="#topic+print">print</a></code>
prints summary output for <code>ltrccif</code> objects and <code>ltrcrrf</code> objects.
<code><a href="#topic+predictProb">predictProb</a></code>
constructs survival function estimates for <code>ltrccif</code> objects and <code>ltrcrrf</code> objects.
</p>
<p>For (left-truncated) right-censored survival data with time-varying covariates,
one can first reformat the data structure to one with LTRC observations,
where the multiple records of a subject become a list of pseudo-subjects and
are treated independently. This procedure is usually referred to as the
Andersen-Gill method (Andersen and Gill, 1982). Then LTRC forest methods
can be applied on this reformatted dataset.
</p>

<p>Overall, the methods in this package can handle all combinations of left truncation,
right censoring, time-invariant covariates, and time-varying covariates.
If one is in the traditional case with right-censored data
and time-invariant covariates, however, then it is recommended to use
the functions <code><a href="partykit.html#topic+cforest">cforest</a></code> and <code><a href="randomForestSRC.html#topic+rfsrc">rfsrc</a></code>
directly to construct conditional inference forests and random survival forests,
respectively.
</p>


<h3>References</h3>

<p>Yao, W., Frydman, H., Larocque, D. and Simonoff, J. S. (2022). 
Ensemble methods for survival function estimation with time-varying covariates.
<em>Statistical Methods in Medical Research</em>, <strong>31</strong>(11):2217-2236.
</p>
<p>Andersen, P. and Gill, R. (1982). Cox’s regression model for counting
processes, a large sample study. <em>Annals of Statistics</em>, <strong>10</strong>:1100-1120.
</p>
<p>Ishwaran, H., Blackstone, E. H., Pothier, C., and Lauer, M. S. (2004).
Relative risk forests for exercise heart rate recovery as a predictor of mortality.
<em>Journal of the American StatisticalAssociation</em>, <strong>99</strong>(1):591–600.
</p>
<p>Fu, W. and Simonoff, J. S. (2016). Survival trees for left-truncated and 
right-censored data, with application to time-varying covariate data. 
<em>Biostatistics</em>, <strong>18</strong>(2):352–369.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ltrccif">ltrccif</a></code>, <code><a href="#topic+ltrcrrf">ltrcrrf</a></code>,
<code><a href="#topic+predictProb">predictProb</a></code>, <code><a href="#topic+print">print</a></code>,
<code><a href="#topic+tune.ltrccif">tune.ltrccif</a></code>, <code><a href="#topic+tune.ltrcrrf">tune.ltrcrrf</a></code>, <code><a href="#topic+sbrier_ltrc">sbrier_ltrc</a></code>.
</p>

<hr>
<h2 id='ltrccif'>Fit a LTRC conditional inference forest</h2><span id='topic+ltrccif'></span>

<h3>Description</h3>

<p>An implementation of the random forest and bagging ensemble algorithms utilizing
LTRC conditional inference trees <code><a href="LTRCtrees.html#topic+LTRCIT">LTRCIT</a></code> as base learners for
left-truncated right-censored survival data with time-invariant covariates.
It also allows for (left-truncated) right-censored survival data with
time-varying covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ltrccif(
  formula,
  data,
  id,
  mtry = NULL,
  ntree = 100L,
  bootstrap = c("by.sub", "by.root", "by.user", "none"),
  samptype = c("swor", "swr"),
  sampfrac = 0.632,
  samp = NULL,
  na.action = "na.omit",
  stepFactor = 2,
  trace = TRUE,
  applyfun = NULL,
  cores = NULL,
  control = partykit::ctree_control(teststat = "quad", testtype = "Univ", minsplit =
    max(ceiling(sqrt(nrow(data))), 20), minbucket = max(ceiling(sqrt(nrow(data))), 7),
    minprob = 0.01, mincriterion = 0, saveinfo = FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ltrccif_+3A_formula">formula</code></td>
<td>
<p>a formula object, with the response being a <code><a href="survival.html#topic+Surv">Surv</a></code>
object, with form
</p>
<p><code>Surv(tleft, tright, event)</code>.</p>
</td></tr>
<tr><td><code id="ltrccif_+3A_data">data</code></td>
<td>
<p>a data frame containing <code>n</code> rows of
left-truncated right-censored observations.
For time-varying data, this should be
a data frame containing pseudo-subject observations based on the Andersen-Gill
reformulation.</p>
</td></tr>
<tr><td><code id="ltrccif_+3A_id">id</code></td>
<td>
<p>variable name of subject identifiers. If this is present, it will be
searched for in the <code>data</code> data frame. Each group of rows in <code>data</code>
with the same subject <code>id</code> represents the covariate path through time of
a single subject. If not specified, the algorithm then assumes <code>data</code>
contains left-truncated and right-censored survival data with time-invariant
covariates.</p>
</td></tr>
<tr><td><code id="ltrccif_+3A_mtry">mtry</code></td>
<td>
<p>number of input variables randomly sampled as candidates at each node for
random forest algorithms. The default <code>mtry</code> is tuned by <code><a href="#topic+tune.ltrccif">tune.ltrccif</a></code>.</p>
</td></tr>
<tr><td><code id="ltrccif_+3A_ntree">ntree</code></td>
<td>
<p>an integer, the number of the trees to grow for the forest.
<code>ntree = 100L</code> is set by default.</p>
</td></tr>
<tr><td><code id="ltrccif_+3A_bootstrap">bootstrap</code></td>
<td>
<p>bootstrap protocol.
(1) If <code>id</code> is present,
the choices are: <code>"by.sub"</code> (by default) which bootstraps subjects,
<code>"by.root"</code> which bootstraps pseudo-subjects.
Both can be with or without replacement (by default sampling is without
replacement; see the option <code>perturb</code> below);
(2) If <code>id</code> is not specified, it
bootstraps the <code>data</code> by sampling with or without replacement.
Regardless of the presence of <code>id</code>, if <code>"none"</code> is chosen,
<code>data</code> is not bootstrapped at all, and is used in
every individual tree. If <code>"by.user"</code> is choosen,
the bootstrap specified by <code>samp</code> is used.</p>
</td></tr>
<tr><td><code id="ltrccif_+3A_samptype">samptype</code></td>
<td>
<p>choices are <code>swor</code> (sampling without replacement) and
<code>swr</code> (sampling with replacement). The default action here is sampling
without replacement.</p>
</td></tr>
<tr><td><code id="ltrccif_+3A_sampfrac">sampfrac</code></td>
<td>
<p>a fraction, determining the proportion of subjects to draw
without replacement when <code>samptype = "swor"</code>. The default value is <code>0.632</code>.
To be more specific, if <code>id</code> is present, <code>0.632 * N</code> of subjects with their
pseudo-subject observations are drawn without replacement (<code>N</code> denotes the
number of subjects); otherwise, <code>0.632 * n</code> is the requested size
of the sample.</p>
</td></tr>
<tr><td><code id="ltrccif_+3A_samp">samp</code></td>
<td>
<p>Bootstrap specification when <code>bootstype = "by.user"</code>.
Array of dim <code>n x ntree</code> specifying how many times each record appears
in each bootstrap sample.</p>
</td></tr>
<tr><td><code id="ltrccif_+3A_na.action">na.action</code></td>
<td>
<p>action taken if the data contains <code>NA</code>’s. The default
<code>"na.omit"</code> removes the entire record if any of its entries is
<code>NA</code> (for x-variables this applies only to those specifically listed
in <code>formula</code>). See function <code><a href="partykit.html#topic+cforest">cforest</a></code> for
other available options.</p>
</td></tr>
<tr><td><code id="ltrccif_+3A_stepfactor">stepFactor</code></td>
<td>
<p>at each iteration, <code>mtry</code> is inflated (or deflated)
by this value, used when <code>mtry</code> is not specified (see <code><a href="#topic+tune.ltrccif">tune.ltrccif</a></code>).
The default value is <code>2</code>.</p>
</td></tr>
<tr><td><code id="ltrccif_+3A_trace">trace</code></td>
<td>
<p>whether to print the progress of the search of the optimal value of
<code>mtry</code>, when <code>mtry</code> is not specified (see <code><a href="#topic+tune.ltrccif">tune.ltrccif</a></code>).
<code>trace = TRUE</code> is set by default.</p>
</td></tr>
<tr><td><code id="ltrccif_+3A_applyfun">applyfun</code></td>
<td>
<p>an optional <code>lapply</code>-style function with arguments
<code>function(X, FUN, ...)</code>.
It is used for computing the variable selection criterion. The default is to use the
basic <code>lapply</code> function unless the <code>cores</code> argument is specified (see below).
See <code><a href="partykit.html#topic+ctree_control">ctree_control</a></code>.</p>
</td></tr>
<tr><td><code id="ltrccif_+3A_cores">cores</code></td>
<td>
<p>numeric. See <code><a href="partykit.html#topic+ctree_control">ctree_control</a></code>.</p>
</td></tr>
<tr><td><code id="ltrccif_+3A_control">control</code></td>
<td>
<p>a list of control parameters, see <code><a href="partykit.html#topic+ctree_control">ctree_control</a></code>.
<code>control</code> parameters <code>minsplit</code>, <code>minbucket</code> have been adjusted from the
<code><a href="partykit.html#topic+cforest">cforest</a></code> defaults. Other default values correspond to those of the
default values used by <code><a href="partykit.html#topic+ctree_control">ctree_control</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extends the conditional inference survival forest algorithm in
<code><a href="partykit.html#topic+cforest">cforest</a></code> to fit left-truncated and right-censored data,
which allow for time-varying covariates.
</p>


<h3>Value</h3>

<p>An object belongs to the class <code>ltrccif</code>, as a subclass of
<code><a href="partykit.html#topic+cforest">cforest</a></code>.
</p>


<h3>References</h3>

<p>Andersen, P. and Gill, R. (1982). Cox's regression model for counting
processes, a large sample study. <em>Annals of Statistics</em>, <strong>10</strong>:1100-1120.
</p>
<p>Fu, W. and Simonoff, J.S. (2016). Survival trees for left-truncated and 
right-censored data, with application to time-varying covariate data. 
<em>Biostatistics</em>, <strong>18</strong>(2):352–369.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predictProb">predictProb</a></code> for prediction and <code><a href="#topic+tune.ltrccif">tune.ltrccif</a></code>
for <code>mtry</code> tuning.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### Example with time-varying data pbcsample
library(survival)
Formula = Surv(Start, Stop, Event) ~ age + alk.phos + ast + chol + edema
## Fit an LTRCCIF on the time-invariant data, with mtry tuned with stepFactor = 3.
LTRCCIFobj = ltrccif(formula = Formula, data = pbcsample, ntree = 20L, stepFactor = 3)
</code></pre>

<hr>
<h2 id='ltrcrrf'>Fit a LTRC relative risk forest</h2><span id='topic+ltrcrrf'></span>

<h3>Description</h3>

<p>An implementation of the random forest algorithms utilizing LTRC <code>rpart</code>
trees <code><a href="LTRCtrees.html#topic+LTRCART">LTRCART</a></code> as base learners for left-truncated right-censored
survival data with time-invariant covariates. It also allows for (left-truncated)
right-censored survival data with time-varying covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ltrcrrf(
  formula,
  data,
  id,
  ntree = 100L,
  mtry = NULL,
  nodesize = max(ceiling(sqrt(nrow(data))), 15),
  bootstrap = c("by.sub", "by.root", "by.node", "by.user", "none"),
  samptype = c("swor", "swr"),
  sampfrac = 0.632,
  samp = NULL,
  na.action = "na.omit",
  stepFactor = 2,
  trace = TRUE,
  nodedepth = NULL,
  nsplit = 10L,
  ntime
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ltrcrrf_+3A_formula">formula</code></td>
<td>
<p>a formula object, with the response being a <code><a href="survival.html#topic+Surv">Surv</a></code>
object, with form
</p>
<p><code>Surv(tleft, tright, event)</code>.</p>
</td></tr>
<tr><td><code id="ltrcrrf_+3A_data">data</code></td>
<td>
<p>a data frame containing <code>n</code> rows of
left-truncated right-censored observations.
For time-varying data, this should be
a data frame containing pseudo-subject observations based on the Andersen-Gill
reformulation.</p>
</td></tr>
<tr><td><code id="ltrcrrf_+3A_id">id</code></td>
<td>
<p>variable name of subject identifiers. If this is present, it will be
searched for in the <code>data</code> data frame. Each group of rows in <code>data</code>
with the same subject <code>id</code> represents the covariate path through time of
a single subject. If not specified, the algorithm then assumes <code>data</code>
contains left-truncated and right-censored survival data with time-invariant
covariates.</p>
</td></tr>
<tr><td><code id="ltrcrrf_+3A_ntree">ntree</code></td>
<td>
<p>an integer, the number of the trees to grow for the forest.
<code>ntree = 100L</code> is set by default.</p>
</td></tr>
<tr><td><code id="ltrcrrf_+3A_mtry">mtry</code></td>
<td>
<p>number of input variables randomly sampled as candidates at each node for
random forest like algorithms. The default <code>mtry</code> is tuned by
<code><a href="#topic+tune.ltrcrrf">tune.ltrcrrf</a></code>.</p>
</td></tr>
<tr><td><code id="ltrcrrf_+3A_nodesize">nodesize</code></td>
<td>
<p>an integer, forest average terminal node size.</p>
</td></tr>
<tr><td><code id="ltrcrrf_+3A_bootstrap">bootstrap</code></td>
<td>
<p>bootstrap protocol.
(1) If <code>id</code> is present,
the choices are: <code>"by.sub"</code> (by default) which bootstraps subjects,
<code>"by.root"</code> which bootstraps pseudo-subjects.
Both can be with or without replacement (by default sampling is without
replacement; see the option <code>samptype</code> below).
(2) If <code>id</code> is not specified, the default is <code>"by.root"</code> which
bootstraps the <code>data</code> by sampling with or without replacement;
if <code>"by.node"</code> is choosen, <code>data</code> is bootstrapped with replacement
at each node while growing the tree.
Regardless of the presence of <code>id</code>, if <code>"none"</code> is chosen,
<code>data</code> is not bootstrapped at all, and is used in
every individual tree. If <code>"by.user"</code> is choosen,
the bootstrap specified by <code>samp</code> is used.</p>
</td></tr>
<tr><td><code id="ltrcrrf_+3A_samptype">samptype</code></td>
<td>
<p>choices are <code>swor</code> (sampling without replacement) and
<code>swr</code> (sampling with replacement). The default action here is sampling
without replacement.</p>
</td></tr>
<tr><td><code id="ltrcrrf_+3A_sampfrac">sampfrac</code></td>
<td>
<p>a fraction, determining the proportion of subjects to draw
without replacement when <code>samptype = "swor"</code>. The default value is <code>0.632</code>.
To be more specific, if <code>id</code> is present, <code>0.632 * N</code> of subjects with their
pseudo-subject observations are drawn without replacement (<code>N</code> denotes the
number of subjects); otherwise, <code>0.632 * n</code> is the requested size
of the sample.</p>
</td></tr>
<tr><td><code id="ltrcrrf_+3A_samp">samp</code></td>
<td>
<p>Bootstrap specification when <code>bootstype = "by.user"</code>.
Array of dim <code>n x ntree</code> specifying how many times each record appears
in each bootstrap sample.</p>
</td></tr>
<tr><td><code id="ltrcrrf_+3A_na.action">na.action</code></td>
<td>
<p>action taken if the data contains <code>NA</code>’s. The default
<code>"na.omit"</code> removes the entire record if any of its entries is
<code>NA</code> (for x-variables this applies only to those specifically listed
in <code>formula</code>). See function <code><a href="randomForestSRC.html#topic+rfsrc">rfsrc</a></code> for
other available options.</p>
</td></tr>
<tr><td><code id="ltrcrrf_+3A_stepfactor">stepFactor</code></td>
<td>
<p>at each iteration, <code>mtry</code> is inflated (or deflated)
by this value, used when <code>mtry</code> is not specified (see <code><a href="#topic+tune.ltrcrrf">tune.ltrcrrf</a></code>).
The default value is <code>2</code>.</p>
</td></tr>
<tr><td><code id="ltrcrrf_+3A_trace">trace</code></td>
<td>
<p>whether to print the progress of the search of the optimal value
of <code>mtry</code> if <code>mtry</code> is not specified (see <code><a href="#topic+tune.ltrcrrf">tune.ltrcrrf</a></code>).
<code>trace = TRUE</code> is set by default.</p>
</td></tr>
<tr><td><code id="ltrcrrf_+3A_nodedepth">nodedepth</code></td>
<td>
<p>maximum depth to which a tree should be grown. The default behaviour
is that this parameter is ignored.</p>
</td></tr>
<tr><td><code id="ltrcrrf_+3A_nsplit">nsplit</code></td>
<td>
<p>an non-negative integer value for number of random splits to consider
for each candidate splitting variable. This significantly increases speed.
When zero or <code>NULL</code>, the algorithm uses much slower deterministic splitting where
all possible splits are considered. <code>nsplit = 10L</code> by default.</p>
</td></tr>
<tr><td><code id="ltrcrrf_+3A_ntime">ntime</code></td>
<td>
<p>an integer value used for survival to constrain ensemble calculations
to a grid of <code>ntime</code> time points. Alternatively if a vector of values
of length greater than one is supplied, it is assumed these are the time points
to be used to constrain the calculations (note that the constrained time points
used will be the observed event times closest to the user supplied time points).
If no value is specified, the default action is to use all observed event times.
Further demails can be found in <code><a href="randomForestSRC.html#topic+rfsrc">rfsrc</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extends the relative risk forest algorithm (Ishwaran et al. 2004) 
to fit left-truncated and right-censored data,
which allows for time-varying covariates. The algorithm is built based on employing
the fast C code from <code><a href="randomForestSRC.html#topic+rfsrc">rfsrc</a></code>.
</p>


<h3>Value</h3>

<p>An object belongs to the class <code>ltrcrrf</code>, as a subclass of
<code><a href="randomForestSRC.html#topic+rfsrc">rfsrc</a></code>.
</p>


<h3>References</h3>

<p>Andersen, P. and Gill, R. (1982). Cox’s regression model for counting
processes, a large sample study. <em>Annals of Statistics</em>, <strong>10</strong>:1100-1120.
</p>
<p>H. Ishwaran, E. H. Blackstone, C. Pothier, and M. S. Lauer. (2004).
Relative risk forests for exercise heart rate recovery as a predictor of mortality.
<em>Journal of the American StatisticalAssociation</em>, <strong>99</strong>(1):591–600.
</p>
<p>Fu, W. and Simonoff, J.S. (2016). Survival trees for left-truncated and 
right-censored data, with application to time-varying covariate data. 
<em>Biostatistics</em>, <strong>18</strong>(2):352–369.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predictProb">predictProb</a></code> for prediction and <code><a href="#topic+tune.ltrcrrf">tune.ltrcrrf</a></code>
for <code>mtry</code> tuning.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### Example with time-varying data pbcsample
library(survival)
Formula = Surv(Start, Stop, Event) ~ age + alk.phos + ast + chol + edema
# Built a LTRCRRF forest (based on bootstrapping subjects without replacement)
# on the time-varying data by specifying id:
LTRCRRFobj = ltrcrrf(formula = Formula, data = pbcsample, id = ID, stepFactor = 3,
                     ntree = 10L)


</code></pre>

<hr>
<h2 id='pbcsample'>Sample Mayo Clinic Primary Biliary Cirrhosis Data</h2><span id='topic+pbcsample'></span>

<h3>Description</h3>

<p>A sample real dataset with time varying covariates. It contains multiple records
of measurements of risk factors at multiple time points from 10 patients
with primary biliary cirrhosis (PBC), constructed from
<code><a href="survival.html#topic+pbcseq">pbcseq</a></code> in the R package <span class="pkg">survival</span>. The data
structure has been reformatted with left-truncated right-censored
pseudo-subject observations based on the Andersen-Gill reformulation method.
</p>


<h3>Value</h3>

<p>A data frame with 57 rows and 9 variables:
</p>
<table>
<tr><td><code>ID</code></td>
<td>
<p>patient id.</p>
</td></tr>
<tr><td><code>Start</code></td>
<td>
<p>the left truncation time point for the corresponding
pseudo-subject observation.</p>
</td></tr>
<tr><td><code>Stop</code></td>
<td>
<p>the right censoring time point for the corresponding
pseudo-subject observation.</p>
</td></tr>
<tr><td><code>Event</code></td>
<td>
<p>a binary value, with <code>1</code> indicating the event occurring at
the corresponding <code>Stop</code>, <code>0</code> indicating right-censored.</p>
</td></tr>
<tr><td><code>age</code></td>
<td>
<p>patient's age at entry, in years.</p>
</td></tr>
<tr><td><code>alk.phos</code></td>
<td>
<p>alkaline phosphotase (U/liter).</p>
</td></tr>
<tr><td><code>ast</code></td>
<td>
<p>aspartate aminotransferase (U/ml).</p>
</td></tr>
<tr><td><code>chol</code></td>
<td>
<p>serum cholesterol (mg/dl).</p>
</td></tr>
<tr><td><code>edema</code></td>
<td>
<p><code>0</code>&ndash;no edema, <code>0.5</code>&ndash;untreated or successfully treated,
<code>1</code>&ndash;edema despite diuretic therapy.</p>
</td></tr>
</table>


<h3>Source</h3>

<p>P. A. Murtaugh, E. R. Dickson, G. M. V. Dam,
M. Malinchoc, P. M. Grambsch, A. L. Langworthy, and C. H. Gips. (1989).
Primary biliary cirrhosis: Prediction of shortterm survival based on
repeated patient visits. <em>Hepatology</em>, <strong>20</strong>, 126-134.
</p>


<h3>References</h3>

<p>Andersen, P. and Gill, R. (1982). Cox's regression model for counting
processes, a large sample study. <em>Annals of Statistics</em>, <strong>10</strong>, 1100-1120.
</p>

<hr>
<h2 id='predictProb'>Compute a Survival Curve from a LTRCCIF model or a LTRCRRF model</h2><span id='topic+predictProb'></span><span id='topic+predictProb.ltrccif+2C'></span><span id='topic+predictProb.ltrcrrf'></span>

<h3>Description</h3>

<p>Constructs a monotone nonincreasing estimated survival curve from a LTRCCIF model or a 
LTRCRRF model for any given (left-truncated) right-censored survival data with time-varying 
covariates.
It can also compute survival function estimates for left-truncated right-censored data
with time-invariant covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictProb(
  object,
  newdata = NULL,
  newdata.id,
  OOB = FALSE,
  time.eval,
  time.tau = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictProb_+3A_object">object</code></td>
<td>
<p>an object as returned by <code><a href="#topic+ltrccif">ltrccif</a></code> or by <code><a href="#topic+ltrcrrf">ltrcrrf</a></code>.</p>
</td></tr>
<tr><td><code id="predictProb_+3A_newdata">newdata</code></td>
<td>
<p>an optional data frame containing the test data
(with the names of the variables the same as those in <code>data</code> from <code>object</code>).</p>
</td></tr>
<tr><td><code id="predictProb_+3A_newdata.id">newdata.id</code></td>
<td>
<p>optional variable name of subject identifiers for <code>newdata</code>.
If this is present, it will be searched for in the <code>newdata</code> data frame.
Each group of rows in <code>newdata</code> with the same subject <code>id</code> represents
the covariate path through time of a single subject, and the result will
contain one curve per subject. If it is not specified, then an estimated survival
curve is returned for each row of <code>newdata</code>.</p>
</td></tr>
<tr><td><code id="predictProb_+3A_oob">OOB</code></td>
<td>
<p>a logical specifying whether out-of-bag predictions are desired
</p>
<p>(only if <code>newdata = NULL</code>).</p>
</td></tr>
<tr><td><code id="predictProb_+3A_time.eval">time.eval</code></td>
<td>
<p>a vector of time points, at which the estimated survival probabilities
will be computed.</p>
</td></tr>
<tr><td><code id="predictProb_+3A_time.tau">time.tau</code></td>
<td>
<p>an optional vector, with the <em>i</em>-th entry giving the upper time limit for the
computed survival probabilities for the <em>i</em>-th data of interest (i.e., only computes
survival probabilies at <code>time.eval[time.eval &lt;= time.tau[i]]</code> for the <em>i</em>-th
data of interest). If <code>OOB = TRUE</code>, the length of <code>time.tau</code> is equal to the size of
<code>data</code> used to train the <code>object</code>;
If <code>OOB = FALSE</code>, the length of <code>time.tau</code> is equal to the size
of <code>newdata</code>, or equal to the size of <code>data</code> if <code>newdata</code> is not given.
The default <code>NULL</code> is simply to set all entries of <code>time.tau</code> equal to the maximum
value of <code>time.eval</code>, so that all estimated survival probabilities are computed at the
same <code>time.eval</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>survival.id</code></td>
<td>
<p>subject identifiers.</p>
</td></tr>
<tr><td><code>survival.obj</code></td>
<td>
<p>an object of class <code><a href="survival.html#topic+Surv">Surv</a></code>.</p>
</td></tr>
<tr><td><code>survival.probs</code></td>
<td>
<p>the estimated survival probabilities for each data of interest.
It is a list if the length of the estimated values differs from one to another;
otherwise, it is a matrix with the number of columns equal to the number of the data
of interest, number of rows equal to the number of the time points at which the estimated
survival probabilities are computed.</p>
</td></tr>
<tr><td><code>survival.tau</code></td>
<td>
<p>the input value <code>time.tau</code>.</p>
</td></tr>
<tr><td><code>survival.times</code></td>
<td>
<p>the input value <code>time.eval</code>. </p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+sbrier_ltrc">sbrier_ltrc</a></code> for evaluation of model fit
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### Example with data pbcsample
library(survival)
Formula &lt;- Surv(Start, Stop, Event) ~ age + alk.phos + ast + chol + edema
## Fit an LTRC conditional inference forest on time-varying data
LTRCCIFobj &lt;- ltrccif(formula = Formula, data = pbcsample, id = ID,
                      mtry = 3, ntree = 50L)


## Construct an estimated survival estimate for the second subject
tpnt &lt;- seq(0, max(pbcsample$Stop), length.out = 50)
newData &lt;- pbcsample[pbcsample$ID == 2, ]
Pred &lt;- predictProb(object = LTRCCIFobj, newdata = newData, newdata.id = ID,
                    time.eval = tpnt)
## Since time.tau = NULL, Pred$survival.probs is in the matrix format, with dimensions:
dim(Pred$survival.probs) # length(time.eval) x nrow(newdata)
## Plot the estimated survival curve
plot(Pred$survival.times, Pred$survival.probs, type = "l", col = "red",
     xlab = "Time", ylab = "Survival probabilities")



</code></pre>

<hr>
<h2 id='print'>Print Summary Output of a ltrccif object or a ltrcrrf object</h2><span id='topic+print'></span><span id='topic+print.ltrccif+2C'></span><span id='topic+print.ltrcrrf'></span>

<h3>Description</h3>

<p>Print summary output after a LTRCCIF or a LTRCRRF model is built.
This is the default print method for objects in the class of <code><a href="#topic+ltrccif">ltrccif</a></code> or 
<code><a href="#topic+ltrcrrf">ltrcrrf</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+ltrccif">ltrccif</a></code> or <code><a href="#topic+ltrcrrf">ltrcrrf</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A printout object containing the following components:
</p>
<table>
<tr><td><code>Number of (pseudo-subject) observations</code></td>
<td>
<p>number of left-truncated 
right-censored pseudo-subject observations based on the Andersen-Gill reformulation.</p>
</td></tr>
<tr><td><code>Number of subjects</code></td>
<td>
<p>number of independent subject observations.</p>
</td></tr>
<tr><td><code>Number of deaths</code></td>
<td>
<p>number of times that an event occurs in the whole dataset.</p>
</td></tr>
<tr><td><code>Number of trees</code></td>
<td>
<p>the value set for argument <code>ntree</code>, 
see <code><a href="#topic+ltrccif">ltrccif</a></code> and <code><a href="#topic+ltrcrrf">ltrcrrf</a></code>.</p>
</td></tr>
<tr><td><code>minsplit</code></td>
<td>
<p>the value set for argument <code>minsplit</code> that controls 
the growth of individual trees; see <code><a href="partykit.html#topic+ctree_control">ctree_control</a></code>.</p>
</td></tr>
<tr><td><code>minbucket</code></td>
<td>
<p>the value set for argument <code>minbucket</code> 
that controls the growth of individual trees; see <code><a href="partykit.html#topic+ctree_control">ctree_control</a></code>.</p>
</td></tr>
<tr><td><code>minprob</code></td>
<td>
<p>the value set for argument <code>minprob</code> 
that controls the growth of individual trees; see <code><a href="partykit.html#topic+ctree_control">ctree_control</a></code>.</p>
</td></tr>
<tr><td><code>maxdepth</code></td>
<td>
<p>the value set for argument <code>maxdepth</code> 
that controls the maximum depth of individual trees; see <code><a href="partykit.html#topic+ctree_control">ctree_control</a></code>.</p>
</td></tr>
<tr><td><code>No. of variables tried at each split</code></td>
<td>
<p>number of input variables 
randomly sampled as candidates at each node for random forest algorithms, 
which is either set as an argument <code>mtry</code> in <code><a href="#topic+ltrccif">ltrccif</a></code> and <code><a href="#topic+ltrcrrf">ltrcrrf</a></code>, 
or tuned by <code><a href="#topic+tune.ltrccif">tune.ltrccif</a></code> or <code><a href="#topic+tune.ltrcrrf">tune.ltrcrrf</a></code>, respectively.</p>
</td></tr>
<tr><td><code>Total no. of variables</code></td>
<td>
<p>the number of features provided in <code>data</code>.</p>
</td></tr>
<tr><td><code>Bootstrap type to grow trees</code></td>
<td>
<p>the values set for augument <code>bootstrap</code>, 
see <code><a href="#topic+ltrccif">ltrccif</a></code> and <code><a href="#topic+ltrcrrf">ltrcrrf</a></code>.</p>
</td></tr>
<tr><td><code>Resampling used to grow trees</code></td>
<td>
<p>the value set for argument <code>samptype</code>, 
see <code><a href="#topic+ltrccif">ltrccif</a></code> and <code><a href="#topic+ltrcrrf">ltrcrrf</a></code>.</p>
</td></tr>
<tr><td><code>Resampling rate used to grow trees</code></td>
<td>
<p>the values set for argument <code>sampfrac</code>, 
see <code><a href="#topic+ltrccif">ltrccif</a></code> and <code><a href="#topic+ltrcrrf">ltrcrrf</a></code>.</p>
</td></tr>
<tr><td><code>Analysis</code></td>
<td>
<p>LTRCCIF for a <code><a href="#topic+ltrccif">ltrccif</a></code> object or LTRCRRF for <code><a href="#topic+ltrcrrf">ltrcrrf</a></code>.</p>
</td></tr>
<tr><td><code>Family</code></td>
<td>
<p>the family used in the analysis, <code>surv</code>.</p>
</td></tr>
<tr><td><code>Splitting rule</code></td>
<td>
<p>the splitting rule that is implemented, 
conditional inference framework for a <code><a href="#topic+ltrccif">ltrccif</a></code> object or 
Poisson splitting for <code><a href="#topic+ltrcrrf">ltrcrrf</a></code>.</p>
</td></tr>
<tr><td><code>Number of random split points</code></td>
<td>
<p>the values set for argument <code>nsplit</code> in <code><a href="#topic+ltrcrrf">ltrcrrf</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ltrccif">ltrccif</a></code>, <code><a href="#topic+ltrcrrf">ltrcrrf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(survival)
Formula = Surv(Start, Stop, Event) ~ age + alk.phos + ast + chol + edema
# Built a LTRCCIF forest on the time-varying data by specifying id, with mtry specified:
LTRCCIFobj = ltrccif(formula = Formula, data = pbcsample, id = ID, mtry = 3, ntree = 50L)
print(LTRCCIFobj)

# Built a LTRCCIF forest on the time-invariant data, with resampling, with mtry specified:
LTRCCIFobj = ltrccif(formula = Formula, data = pbcsample, samptype = "swr",
                     mtry = 3, ntree = 50L)
print(LTRCCIFobj)
</code></pre>

<hr>
<h2 id='sbrier_ltrc'>Model fit evaluation for LTRC forests.</h2><span id='topic+sbrier_ltrc'></span>

<h3>Description</h3>

<p>Compute the (integrated) Brier score to evaluate the model fit for
(left-truncated) right-censored survival data with time-varying covariates,
as well as left-truncated right-censored data with time-invariant covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sbrier_ltrc(obj, id = NULL, pred, type = c("IBS", "BS"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sbrier_ltrc_+3A_obj">obj</code></td>
<td>
<p>an object of class <code><a href="survival.html#topic+Surv">Surv</a></code>, formed on
left-truncated right-censored observations (which are pseudo-subject
observations in the time-varying case).</p>
</td></tr>
<tr><td><code id="sbrier_ltrc_+3A_id">id</code></td>
<td>
<p>an optional vector as subject identifiers for <code>obj</code>.</p>
</td></tr>
<tr><td><code id="sbrier_ltrc_+3A_pred">pred</code></td>
<td>
<p>a list. This should contain 1) either a matrix
or a list of survival probabilies named <code>survival.probs</code>; 2) a sequence
of time points <code>survival.times</code>; 3) a vector of upper time limits
<code>survival.tau</code>.
See the values returned by <code><a href="#topic+predictProb">predictProb</a></code>.</p>
</td></tr>
<tr><td><code id="sbrier_ltrc_+3A_type">type</code></td>
<td>
<p>a character string denoting the type of scores returned. If <code>type = "IBS"</code>,
the integrated Brier score up to the last time point in <code>pred$surv.times</code> that is
not larger than the minimum value of <code>pred$surv.tau</code> is returned.
If <code>type = "BS"</code>, the Brier score at every time point in <code>pred$surv.times</code> up to
the minimum value of <code>pred$surv.tau</code> is returned. <code>type = "IBS"</code> is set by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>type = "IBS"</code>, this returns the integrated Brier score.
</p>
<p>If <code>type = "BS"</code>, this returns <code>BScore</code>, the Brier scores
and <code>Time</code>, the time points at which the scores are computed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Example with dataset pbcsample
library(survival)
Formula = Surv(Start, Stop, Event) ~ age + alk.phos + ast + chol + edema
## Fit an LTRC conditional inference forest on time-varying data
LTRCCIFobj = ltrccif(formula = Formula, data = pbcsample, id = ID, mtry = 3, ntree = 50L)

# Time points
tpnt = seq(0, 6000, by = 100)
# Set different upper time limits for each of the subjects
tau = seq(4001, 6200, length.out = length(unique(pbcsample$ID)))
## Obstain estimation at time points tpnt
Predobj = predictProb(object = LTRCCIFobj, time.eval = tpnt, time.tau = tau)

## Compute the integrated Brier score:
pbcobj = Surv(pbcsample$Start, pbcsample$Stop, pbcsample$Event)
IBS = sbrier_ltrc(obj = pbcobj, id = pbcsample$ID, pred = Predobj, type = "IBS")

## Compute the Brier score at each value of tpnt
BS = sbrier_ltrc(obj = pbcobj, id = pbcsample$ID, pred = Predobj, type = "BS")
## Plot the Brier scores
plot(BS$Time, BS$BScore, pch = 20, xlab = "Time", ylab = "Brier score", col = 2)
## As one can see, the Brier scores are returned at all tpnt up to 4000,
## this is because the algorithm set the last evaluation time point
## to be 4000 based on the value of time.eval and time.tau
## (max(tpnt[tpnt &lt;= min(tau)]) == 4000).
</code></pre>

<hr>
<h2 id='tune.ltrccif'>Tune <code>mtry</code> to the optimal value with respect to out-of-bag error for a LTRCCIF model</h2><span id='topic+tune.ltrccif'></span>

<h3>Description</h3>

<p>Starting with the default value of <code>mtry</code>, search for the optimal value
(with respect to out-of-bag error estimate) of <code>mtry</code> for <code><a href="#topic+ltrccif">ltrccif</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tune.ltrccif(
  formula,
  data,
  id,
  mtryStart = NULL,
  stepFactor = 2,
  time.eval = NULL,
  time.tau = NULL,
  ntreeTry = 100L,
  bootstrap = c("by.sub", "by.root", "none", "by.user"),
  samptype = c("swor", "swr"),
  sampfrac = 0.632,
  samp = NULL,
  na.action = "na.omit",
  trace = TRUE,
  doBest = FALSE,
  plot = FALSE,
  applyfun = NULL,
  cores = NULL,
  control = partykit::ctree_control(teststat = "quad", testtype = "Univ", mincriterion =
    0, saveinfo = FALSE, minsplit = max(ceiling(sqrt(nrow(data))), 20), minbucket =
    max(ceiling(sqrt(nrow(data))), 7), minprob = 0.01)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tune.ltrccif_+3A_formula">formula</code></td>
<td>
<p>a formula object, with the response being a <code><a href="survival.html#topic+Surv">Surv</a></code>
object, with form
</p>
<p><code>Surv(tleft, tright, event)</code>.</p>
</td></tr>
<tr><td><code id="tune.ltrccif_+3A_data">data</code></td>
<td>
<p>a data frame containing <code>n</code> rows of
left-truncated right-censored observations.</p>
</td></tr>
<tr><td><code id="tune.ltrccif_+3A_id">id</code></td>
<td>
<p>variable name of subject identifiers. If this is present, it will be
searched for in the <code>data</code> data frame. Each group of rows in <code>data</code>
with the same subject <code>id</code> represents the covariate path through time of
a single subject. If not specified, the algorithm then assumes <code>data</code>
contains left-truncated and right-censored survival data with time-invariant
covariates.</p>
</td></tr>
<tr><td><code id="tune.ltrccif_+3A_mtrystart">mtryStart</code></td>
<td>
<p>starting value of <code>mtry</code>; default is <code>sqrt(nvar)</code>.</p>
</td></tr>
<tr><td><code id="tune.ltrccif_+3A_stepfactor">stepFactor</code></td>
<td>
<p>at each iteration, <code>mtry</code> is inflated (or deflated)
by this value. The default value is <code>2</code>.</p>
</td></tr>
<tr><td><code id="tune.ltrccif_+3A_time.eval">time.eval</code></td>
<td>
<p>a vector of time points, at which the estimated survival probabilities
are evaluated.</p>
</td></tr>
<tr><td><code id="tune.ltrccif_+3A_time.tau">time.tau</code></td>
<td>
<p>an optional vector, with the <em>i</em>-th entry giving the upper time limit for the
computed survival probabilities for the <em>i</em>-th data (i.e., only computes
survival probabilies at <code>time.eval[time.eval &lt;= time.tau[i]]</code> for the <em>i</em>-th
data of interest).</p>
</td></tr>
<tr><td><code id="tune.ltrccif_+3A_ntreetry">ntreeTry</code></td>
<td>
<p>number of trees used at the tuning step.</p>
</td></tr>
<tr><td><code id="tune.ltrccif_+3A_bootstrap">bootstrap</code></td>
<td>
<p>bootstrap protocol.
(1) If <code>id</code> is present,
the choices are: <code>"by.sub"</code> (by default) which bootstraps subjects,
<code>"by.root"</code> which bootstraps pseudo-subjects.
Both can be with or without replacement (by default sampling is without
replacement; see the option <code>perturb</code> below);
(2) If <code>id</code> is not specified, it bootstraps the <code>data</code> by
sampling with or without replacement.
Regardless of the presence of <code>id</code>, if <code>"none"</code> is chosen,
<code>data</code> is not bootstrapped at all, and is used in
every individual tree. If <code>"by.user"</code> is choosen,
the bootstrap specified by <code>samp</code> is used.</p>
</td></tr>
<tr><td><code id="tune.ltrccif_+3A_samptype">samptype</code></td>
<td>
<p>choices are <code>swor</code> (sampling without replacement) and
<code>swr</code> (sampling with replacement). The default action here is sampling
without replacement.</p>
</td></tr>
<tr><td><code id="tune.ltrccif_+3A_sampfrac">sampfrac</code></td>
<td>
<p>a fraction, determining the proportion of subjects to draw
without replacement when <code>samptype = "swor"</code>. The default value is <code>0.632</code>.
To be more specific, if <code>id</code> is present, <code>0.632 * N</code> of subjects with their
pseudo-subject observations are drawn without replacement (<code>N</code> denotes the
number of subjects); otherwise, <code>0.632 * n</code> is the requested size
of the sample.</p>
</td></tr>
<tr><td><code id="tune.ltrccif_+3A_samp">samp</code></td>
<td>
<p>Bootstrap specification when <code>bootstype = "by.user"</code>.
Array of dim <code>n x ntree</code> specifying how many times each record appears
in each bootstrap sample.</p>
</td></tr>
<tr><td><code id="tune.ltrccif_+3A_na.action">na.action</code></td>
<td>
<p>action taken if the data contains <code>NA</code>’s. The default
<code>"na.omit"</code> removes the entire record if any of its entries is
<code>NA</code> (for x-variables this applies only to those specifically listed
in <code>formula</code>). See function <code><a href="partykit.html#topic+cforest">cforest</a></code> for
other available options.</p>
</td></tr>
<tr><td><code id="tune.ltrccif_+3A_trace">trace</code></td>
<td>
<p>whether to print the progress of the search. <code>trace = TRUE</code> is set by default.</p>
</td></tr>
<tr><td><code id="tune.ltrccif_+3A_dobest">doBest</code></td>
<td>
<p>whether to run a <code><a href="#topic+ltrccif">ltrccif</a></code> object using the optimal <code>mtry</code> found.
<code>doBest = FALSE</code> is set by default.</p>
</td></tr>
<tr><td><code id="tune.ltrccif_+3A_plot">plot</code></td>
<td>
<p>whether to plot the out-of-bag error as a function of <code>mtry</code>.
<code>plot = FALSE</code> is set by default.</p>
</td></tr>
<tr><td><code id="tune.ltrccif_+3A_applyfun">applyfun</code></td>
<td>
<p>an optional <code>lapply</code>-style function with arguments
<code>function(X, FUN, ...)</code>.
It is used for computing the variable selection criterion. The default is to use the
basic <code>lapply</code> function unless the <code>cores</code> argument is specified (see below).
See <code><a href="partykit.html#topic+ctree_control">ctree_control</a></code>.</p>
</td></tr>
<tr><td><code id="tune.ltrccif_+3A_cores">cores</code></td>
<td>
<p>numeric. See <code><a href="partykit.html#topic+ctree_control">ctree_control</a></code>.</p>
</td></tr>
<tr><td><code id="tune.ltrccif_+3A_control">control</code></td>
<td>
<p>a list with control parameters, see <code><a href="partykit.html#topic+cforest">cforest</a></code>.
The default values correspond to those of the default values used by <code><a href="#topic+ltrccif">ltrccif</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>doBest = FALSE</code> (default), this returns the optimal mtry value of those searched.
</p>
<p>If <code>doBest = TRUE</code>, this returns the <code><a href="#topic+ltrccif">ltrccif</a></code> object produced with the optimal <code>mtry</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sbrier_ltrc">sbrier_ltrc</a></code> for evaluation of model fit when searching
for the optimal value of <code>mtry</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Example with data pbcsample
library(survival)
Formula = Surv(Start, Stop, Event) ~ age + alk.phos + ast + chol + edema
## mtry tuned by the OOB procedure with stepFactor 3, number of trees built 10.
mtryT = tune.ltrccif(formula = Formula, data = pbcsample, id = ID, stepFactor = 3,
                     ntreeTry = 10L)


</code></pre>

<hr>
<h2 id='tune.ltrcrrf'>Tune <code>mtry</code> to the optimal value with respect to out-of-bag error for a LTRCRRF model</h2><span id='topic+tune.ltrcrrf'></span>

<h3>Description</h3>

<p>Starting with the default value of <code>mtry</code>, search for the optimal value
(with respect to out-of-bag error estimate) of <code>mtry</code> for <code><a href="#topic+ltrcrrf">ltrcrrf</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tune.ltrcrrf(
  formula,
  data,
  id,
  mtryStart = NULL,
  stepFactor = 2,
  time.eval = NULL,
  time.tau = NULL,
  ntreeTry = 100L,
  bootstrap = c("by.sub", "by.root", "by.node", "by.user", "none"),
  samptype = c("swor", "swr"),
  sampfrac = 0.632,
  samp = NULL,
  na.action = "na.omit",
  trace = TRUE,
  doBest = FALSE,
  plot = FALSE,
  ntime,
  nsplit = 10L,
  nodesizeTry = max(ceiling(sqrt(nrow(data))), 15),
  nodedepth = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tune.ltrcrrf_+3A_formula">formula</code></td>
<td>
<p>a formula object, with the response being a <code><a href="survival.html#topic+Surv">Surv</a></code>
object, with form
</p>
<p><code>Surv(tleft, tright, event)</code>.</p>
</td></tr>
<tr><td><code id="tune.ltrcrrf_+3A_data">data</code></td>
<td>
<p>a a data frame containing <code>n</code> rows of
left-truncated right-censored observations.</p>
</td></tr>
<tr><td><code id="tune.ltrcrrf_+3A_id">id</code></td>
<td>
<p>variable name of subject identifiers. If this is present, it will be
searched for in the <code>data</code> data frame. Each group of rows in <code>data</code>
with the same subject <code>id</code> represents the covariate path through time of
a single subject. If not specified, the algorithm then assumes <code>data</code>
contains left-truncated and right-censored survival data with time-invariant
covariates.</p>
</td></tr>
<tr><td><code id="tune.ltrcrrf_+3A_mtrystart">mtryStart</code></td>
<td>
<p>starting value of <code>mtry</code>; default is <code>sqrt(nvar)</code>.</p>
</td></tr>
<tr><td><code id="tune.ltrcrrf_+3A_stepfactor">stepFactor</code></td>
<td>
<p>at each iteration, <code>mtry</code> is inflated (or deflated)
by this value, used when <code>mtry</code> is not specified (see <code><a href="#topic+ltrcrrf">ltrcrrf</a></code>).
The default value is <code>2</code>.</p>
</td></tr>
<tr><td><code id="tune.ltrcrrf_+3A_time.eval">time.eval</code></td>
<td>
<p>a vector of time points, at which the estimated survival probabilities
are evaluated.</p>
</td></tr>
<tr><td><code id="tune.ltrcrrf_+3A_time.tau">time.tau</code></td>
<td>
<p>an optional vector, with the <em>i</em>-th entry giving the upper time limit for the
computed survival probabilities for the <em>i</em>-th data (i.e., only computes
survival probabilies at <code>time.eval[time.eval &lt;= time.tau[i]]</code> for the <em>i</em>-th
data of interest).</p>
</td></tr>
<tr><td><code id="tune.ltrcrrf_+3A_ntreetry">ntreeTry</code></td>
<td>
<p>number of trees used at the tuning step.</p>
</td></tr>
<tr><td><code id="tune.ltrcrrf_+3A_bootstrap">bootstrap</code></td>
<td>
<p>bootstrap protocol.
(1) If <code>id</code> is present,
the choices are: <code>"by.sub"</code> (by default) which bootstraps subjects,
<code>"by.root"</code> which bootstraps pseudo-subjects.
Both can be with or without replacement (by default sampling is without
replacement; see the option <code>samptype</code> below).
(2) If <code>id</code> is not specified, the default is <code>"by.root"</code> which
bootstraps the <code>data</code> by sampling with or without replacement;
if <code>"by.node"</code> is choosen, <code>data</code> is bootstrapped with replacement
at each node while growing the tree.
Regardless of the presence of <code>id</code>, if <code>"none"</code> is chosen, the
<code>data</code> is not bootstrapped at all. If <code>"by.user"</code> is choosen,
the bootstrap specified by <code>samp</code> is used.</p>
</td></tr>
<tr><td><code id="tune.ltrcrrf_+3A_samptype">samptype</code></td>
<td>
<p>choices are <code>swor</code> (sampling without replacement) and
<code>swr</code> (sampling with replacement). The default action here is sampling
without replacement.</p>
</td></tr>
<tr><td><code id="tune.ltrcrrf_+3A_sampfrac">sampfrac</code></td>
<td>
<p>a fraction, determining the proportion of subjects to draw
without replacement when <code>samptype = "swor"</code>. The default value is <code>0.632</code>.
To be more specific, if <code>id</code> is present, <code>0.632 * N</code> of subjects with their
pseudo-subject observations are drawn without replacement (<code>N</code> denotes the
number of subjects); otherwise, <code>0.632 * n</code> is the requested size
of the sample.</p>
</td></tr>
<tr><td><code id="tune.ltrcrrf_+3A_samp">samp</code></td>
<td>
<p>Bootstrap specification when <code>bootstype = "by.user"</code>.
Array of dim <code>n x ntree</code> specifying how many times each record appears
in each bootstrap sample.</p>
</td></tr>
<tr><td><code id="tune.ltrcrrf_+3A_na.action">na.action</code></td>
<td>
<p>action taken if the data contains <code>NA</code>’s. The default
<code>"na.omit"</code> removes the entire record if any of its entries is
<code>NA</code> (for x-variables this applies only to those specifically listed
in <code>formula</code>). See function <code><a href="randomForestSRC.html#topic+rfsrc">rfsrc</a></code> for
other available options.</p>
</td></tr>
<tr><td><code id="tune.ltrcrrf_+3A_trace">trace</code></td>
<td>
<p>whether to print the progress of the search. <code>trace = TRUE</code> is set by default.</p>
</td></tr>
<tr><td><code id="tune.ltrcrrf_+3A_dobest">doBest</code></td>
<td>
<p>whether to run a <code><a href="#topic+ltrcrrf">ltrcrrf</a></code> object using the optimal <code>mtry</code> found.
<code>doBest = FALSE</code> is set by default.</p>
</td></tr>
<tr><td><code id="tune.ltrcrrf_+3A_plot">plot</code></td>
<td>
<p>whether to plot the out-of-bag error as a function of <code>mtry</code>.
<code>plot = FALSE</code> is set by default.</p>
</td></tr>
<tr><td><code id="tune.ltrcrrf_+3A_ntime">ntime</code></td>
<td>
<p>an integer value used for survival to constrain ensemble calculations
to a grid of <code>ntime</code> time points. Alternatively if a vector of values
of length greater than one is supplied, it is assumed these are the time points
to be used to constrain the calculations (note that the constrained time points
used will be the observed event times closest to the user supplied time points).
If no value is specified, the default action is to use all observed event times.</p>
</td></tr>
<tr><td><code id="tune.ltrcrrf_+3A_nsplit">nsplit</code></td>
<td>
<p>an non-negative integer value for number of random splits to consider
for each candidate splitting variable. This significantly increases speed.
When zero or <code>NULL</code>, the algorithm uses much slower deterministic splitting
where all possible splits are considered. <code>nsplit = 10L</code> by default.</p>
</td></tr>
<tr><td><code id="tune.ltrcrrf_+3A_nodesizetry">nodesizeTry</code></td>
<td>
<p>forest average terminal node size used at the tuning step.</p>
</td></tr>
<tr><td><code id="tune.ltrcrrf_+3A_nodedepth">nodedepth</code></td>
<td>
<p>maximum depth to which a tree should be grown. The default behaviour
is that this parameter is ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>doBest = FALSE</code> (default), this returns the optimal mtry value of those searched.
</p>
<p>If <code>doBest = TRUE</code>, this returns the <code><a href="#topic+ltrcrrf">ltrcrrf</a></code> object produced with the optimal <code>mtry</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sbrier_ltrc">sbrier_ltrc</a></code> for evaluation of model fit for the optimal value of <code>mtry</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Example with data pbcsample
library(survival)
Formula = Surv(Start, Stop, Event) ~ age + alk.phos + ast + chol + edema
## mtry tuned by the OOB procedure with stepFactor 3, number of trees built 10.
mtryT = tune.ltrcrrf(formula = Formula, data = pbcsample, stepFactor = 3,
                     ntreeTry = 10L)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
