<!DOCTYPE html><html lang="en"><head><title>Help for package JoF</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {JoF}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#MINERVA2'><p>Modeling Judgments of Frequency with MINERVA 2</p></a></li>
<li><a href='#PASS1'><p>Modeling Judgments of Frequency with PASS 1</p></a></li>
<li><a href='#PASS2'><p>Modelling Judgments of Frequency with PASS 2</p></a></li>
<li><a href='#plot.JoF'><p>plot progress of judgment of frequency simulation</p></a></li>
<li><a href='#print.JoF'><p>Output of judgment of frequecny simulation</p></a></li>
<li><a href='#TODAM2'><p>Modeling Judgments of Frequency with TODAM 2</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Modelling and Simulating Judgments of Frequency</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Markus Burkhardt &lt;markus.burkhardt@psychologie.tu-chemnitz.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>In a typical experiment for the intuitive judgment of frequencies (JoF) different stimuli with different frequencies are presented. The participants consider these stimuli with a constant duration and give a judgment of frequency. These judgments can be simulated by formal models: PASS 1 and PASS 2 based on Sedlmeier (2002, ISBN:978-0198508632), MINERVA 2 baesd on Hintzman (1984) &lt;<a href="https://doi.org/10.3758%2FBF03202365">doi:10.3758/BF03202365</a>&gt; and TODAM 2 based on Murdock, Smith &amp; Bai (2001) &lt;<a href="https://doi.org/10.1006%2Fjmps.2000.1339">doi:10.1006/jmps.2000.1339</a>&gt;. The package provides an assessment of the frequency by determining the core aspects of these four models (attention, decay, and presented frequency) that can be compared to empirical results.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-04-02 07:20:53 UTC; burma</td>
</tr>
<tr>
<td>Author:</td>
<td>Markus Burkhardt [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-04-03 14:10:36 UTC</td>
</tr>
</table>
<hr>
<h2 id='MINERVA2'>Modeling Judgments of Frequency with MINERVA 2</h2><span id='topic+MINERVA2'></span>

<h3>Description</h3>

<p>Modeling Judgments of Frequency with MINERVA 2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MINERVA2(x, y, ..., sqc, L, dec = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MINERVA2_+3A_x">x</code></td>
<td>
<p>input handled by MINERVA 2. Values -1, 0 and 1 are
allowed. -1 represents the absence of a feature, 0 the
irrelevance of a feature and 1 the presence of a feature.</p>
</td></tr>
<tr><td><code id="MINERVA2_+3A_y">y</code></td>
<td>
<p>another input handled by MINERVA 2. At least two
inputs are needed for the simulation.</p>
</td></tr>
<tr><td><code id="MINERVA2_+3A_...">...</code></td>
<td>
<p>other inputs for modeling.</p>
</td></tr>
<tr><td><code id="MINERVA2_+3A_sqc">sqc</code></td>
<td>
<p>sequence of the different objects. Each input gets
an ascending number. <code>x</code> gets the value <code>1</code>,
<code>y</code> gets the value <code>2</code>, <code>...</code> gets the value
<code>3</code> and so on.
The argument <code>sqc = c(1, 2, 3, 2)</code> means: first
input <code>x</code> is processed, second input <code>y</code> is
processed followed by processing input number three and
fourth, th input <code>y</code> is used again.
So <code>sqc</code> contains the frequency information too.
In <code>c(1, 2, 3, 2)</code>, <code>x</code> and  the third input
are presented once. The input <code>y</code> is presented twice.</p>
</td></tr>
<tr><td><code id="MINERVA2_+3A_l">L</code></td>
<td>
<p>learning parameter. This is the proportion of a
correctly stored vector. <code>L = 1</code> means 100 % of the input
is processed correctly. If <code>L</code> is a vector, each input
could be handled differently. So <code>L = c(.5, .6, .9)</code> means,
input <code>x</code> is correctly stored to 50 %, input
<code>y</code> is stored to 60 % and the third input (inserted
in <code>...</code>) is stored with 90 % probability.</p>
</td></tr>
<tr><td><code id="MINERVA2_+3A_dec">dec</code></td>
<td>
<p>decay is not part of the original version of MINERVA 2.
This is just implemented for a better comparison with the other
models of JoF. In <code>dec = NULL</code>, decay has no effect.
For <code>dec = 'curve'</code> decay uses a forgetting curve.
If dec is a numeric Vector e. g. <code>dec = c(.8, .9, 1)</code>
the memory traces are weighted. The first represented trace is
weighted by .8 the second by .9 and the youngest trace by 1.
The value <code>dec = 1</code> corresponds with the original model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculations of MINERVA 2 contain four steps.
</p>
<p style="text-align: center;"><code class="reqn">S_{i} = \frac{\sum_{j=1}^{N}{P_{j}T_{ij}}}{N_{i}}</code>
</p>

<p style="text-align: center;"><code class="reqn">A_{i} = S_{i}^{3}</code>
</p>

<p style="text-align: center;"><code class="reqn">I = \sum_{i=1}^{M}{A_{i}}</code>
</p>

<p style="text-align: center;"><code class="reqn">relative JoF = \frac{I_{j}}{\sum_{j}^{K}{I_{j}}}</code>
</p>



<h3>Value</h3>

<p>MINERVA2 returns the relative judgment of frequency
</p>


<h3>References</h3>

<p>Dougherty, M. R., Gettys, C. F., &amp; Ogden, E. E.
(1999). MINERVA-DM: A memory processes model for judgments
of likelihood. <em>Psychological Review, 106</em>(1), 180.
</p>
<p>Hintzman, D. L. (1984). MINERVA 2: A simulation model of human
memory. <em>Behavior Research Methods, Instruments, and
Computers, 16,</em>  96–101.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This example is presented in Dougherty,
#Gettys, &amp; Ogden, 1999 (p. 185)
H1 &lt;- c(-1, 1, 0, 1, 0, -1, 1, -1, 0)
H2 &lt;- c(-1, 0, 0, 1, 0, 0, 1, 0, 0)
x &lt;- MINERVA2(H1, H2, sqc = c(2, 1), L = 1)
</code></pre>

<hr>
<h2 id='PASS1'>Modeling Judgments of Frequency with PASS 1</h2><span id='topic+PASS1'></span>

<h3>Description</h3>

<p>Modeling Judgments of Frequency with PASS 1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PASS1(x, y, ..., sqc, att, dec, ifc, rdm_weights = TRUE, noise = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PASS1_+3A_x">x</code></td>
<td>
<p>input handled by PASS 1. Only binary input is allowed.</p>
</td></tr>
<tr><td><code id="PASS1_+3A_y">y</code></td>
<td>
<p>a second binary input handled by PASS 1. At least
two inputs are needed for the simulation.</p>
</td></tr>
<tr><td><code id="PASS1_+3A_...">...</code></td>
<td>
<p>other binary inputs for modeling.</p>
</td></tr>
<tr><td><code id="PASS1_+3A_sqc">sqc</code></td>
<td>
<p>sequence of the different objects. Each input gets
an ascending number. <code>x</code> gets the value <code>1</code>,
<code>y</code> gets the value <code>2</code>, <code>...</code> gets the value
<code>3</code> and so on.
The argument <code>sqc = c(1, 2, 3, 2)</code> means: first
input <code>x</code> is processed, second input <code>y</code> is
processed followed by processing input number three and
fourth, th input <code>y</code> is used again.
So <code>sqc</code> contains the frequency information too.
In <code>c(1, 2, 3, 2)</code>, <code>x</code> and  the third input
are presented once. The input <code>y</code> is presented twice.</p>
</td></tr>
<tr><td><code id="PASS1_+3A_att">att</code></td>
<td>
<p>attention is a vector with numeric values
between 0 and 1. <code>att</code> has the same length like
<code>sqc</code>, so each input processing have its own value
and PASS 1 can modulate attention by time or input.
If  <code>att</code> is exact one numeric value
(e.g. <code> att = .1</code>), all inputs get the
same parameter of attention.</p>
</td></tr>
<tr><td><code id="PASS1_+3A_dec">dec</code></td>
<td>
<p>decay is a vector with numeric values between
-1 and 0. <code>dec</code> has the same length as <code>sqc</code>, so each
input processing have its own value and PASS 1 can modulate
decay by time. If <code>dec</code> is exact
one numeric value (e.g. <code>dec = -.1</code>), all inputs get the
same parameter of decay.</p>
</td></tr>
<tr><td><code id="PASS1_+3A_ifc">ifc</code></td>
<td>
<p>interference is a vector with numeric values
between -1 and 0. <code>ifc</code> must have the same length as
<code>sqc</code>. So each inputprocessing have its own value and
PASS 1 can modulate inference by time. If <code>ifc</code> is exact
one numeric value (e.g. <code> ifc = -.1</code>), all inputs get the
same parameter of inference.</p>
</td></tr>
<tr><td><code id="PASS1_+3A_rdm_weights">rdm_weights</code></td>
<td>
<p>a logical value indicating whether random
weights in the neural network are used or not. If
<code>rdm_weights = FALSE</code> all network connections are zero
at the beginning.</p>
</td></tr>
<tr><td><code id="PASS1_+3A_noise">noise</code></td>
<td>
<p>a proportion between 0 and 1 which determine
the number of randome activiated inputunits (hihger numbers
indicate higher noise).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>PASS 1 is a simple neural pattern associator learning
by delta rule.
</p>
<p>Learning:
</p>
<p style="text-align: center;"><code class="reqn">if U_{i} and U_{j} are activated, then
\Delta w_{ij} = \Theta_{1} ( 1 - w_{ij})</code>
</p>

<p>Interference:
</p>
<p style="text-align: center;"><code class="reqn">if either U_{i} or U_{j} is activated, then
\Delta w_{ij} = \Theta_{2} * w_{ij}</code>
</p>

<p>Decay:
</p>
<p style="text-align: center;"><code class="reqn">if neither U_{i} nor U_{j} is activated, then
\Delta w_{ij} = \Theta_{3} * w_{ij}</code>
</p>



<h3>Value</h3>

<p><code>PASS1</code> returns the relative judgment of frequency
for each input.
</p>


<h3>References</h3>

<p>Sedlmeier, P. (2002). Associative learning and
frequency judgements: The PASS model. In P. Sedlmeier,
T. Betsch (Eds.), <em>Etc.: Frequency processing and cognition</em>
(pp. 137-152). New York: Oxford University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>o1 &lt;- c(1, 0, 0, 0)
o2 &lt;- c(0, 1, 0, 0)
o3 &lt;- c(0, 0, 1, 0)
o4 &lt;- c(0, 0, 0, 1)
PASS1(o1, o2, o3, o4,
      sqc = rep(1:4, 4:1), att = .1, dec = -.05,
      ifc = -.025, rdm_weights = FALSE, noise = 0)
</code></pre>

<hr>
<h2 id='PASS2'>Modelling Judgments of Frequency with PASS 2</h2><span id='topic+PASS2'></span>

<h3>Description</h3>

<p>Modelling Judgments of Frequency with PASS 2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PASS2(x, y, ..., sqc, att, n_output_units = "half", rdm_weights = F, noise = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PASS2_+3A_x">x</code></td>
<td>
<p>input handled by PASS 2. Only binary input is allowed.</p>
</td></tr>
<tr><td><code id="PASS2_+3A_y">y</code></td>
<td>
<p>a second binary input handled by PASS 1. At least
two inputs are needed for the simulation.</p>
</td></tr>
<tr><td><code id="PASS2_+3A_...">...</code></td>
<td>
<p>other binary inputs for modeling.</p>
</td></tr>
<tr><td><code id="PASS2_+3A_sqc">sqc</code></td>
<td>
<p>sequence of the different objects. Each input gets
an ascending number. <code>x</code> gets the value <code>1</code>,
<code>y</code> gets the value <code>2</code>, <code>...</code> gets the value
<code>3</code> and so on.
The argument <code>sqc = c(1, 2, 3, 2)</code> means: first
input <code>x</code> is processed, second input <code>y</code> is
processed followed by processing input number three and
fourth, th input <code>y</code> is used again.
So <code>sqc</code> contains the frequency information too.
In <code>c(1, 2, 3, 2)</code>, <code>x</code> and  the third input
are presented once. The input <code>y</code> is presented twice.</p>
</td></tr>
<tr><td><code id="PASS2_+3A_att">att</code></td>
<td>
<p>attention is a vector with numeric values
between 0 and 1. <code>att</code> has the same length like
<code>sqc</code>, so each input processing have its own value
and PASS 1 can modulate attention by time or input.
If  <code>att</code> is exact one numeric value
(e.g. <code> att = .1</code>), all inputs get the
same parameter of attention.</p>
</td></tr>
<tr><td><code id="PASS2_+3A_n_output_units">n_output_units</code></td>
<td>
<p>number of output units as numeric value.
This must be between 1 and the maximum number of input units.
<code>n_output_units = 'half'</code> determines the half of the input
units.</p>
</td></tr>
<tr><td><code id="PASS2_+3A_rdm_weights">rdm_weights</code></td>
<td>
<p>a logical value indicating whether random
weights in the neural network are used or not. If
<code>rdm_weights = FALSE</code> all network connections are zero
at the beginning.</p>
</td></tr>
<tr><td><code id="PASS2_+3A_noise">noise</code></td>
<td>
<p>a proportion between 0 and 1 which determines
the number of random activated input units (higher numbers
indicate higher noise).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>PASS 2 uses a competitive learning algorithm, which
usually clusters the input as side effect. If weights are
equal, the winning unit is chosen randomly, because of this,
each simulation is slightly different.
</p>
<p style="text-align: center;"><code class="reqn">if an outputuni O_{i} losses:  \Delta w_{ij} = 0</code>
</p>

<p style="text-align: center;"><code class="reqn">if an outputuni O_{i} wins:  \Delta w_{ij} = g_{w}
\frac{a_{i}}{\sum_{i}^{n}{a_{i}}} - g_{w}w_{ij}</code>
</p>



<h3>Value</h3>

<p><code>PASS2</code> returns the relative judgment of frequency
for each input.
</p>


<h3>References</h3>

<p>Sedlmeier, P. (2002). Associative learning and
frequency judgements: The PASS model. In P. Sedlmeier,
T. Betsch (Eds.), <em>Etc.: Frequency processing and cognition</em>
(pp. 137-152). New York: Oxford University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>o1 &lt;- c(1, 0, 0, 0)
o2 &lt;- c(0, 1, 0, 0)
o3 &lt;- c(0, 0, 1, 0)
o4 &lt;- c(0, 0, 0, 1)
PASS2(o1, o2, o3, o4,
      sqc = rep(1:4, 4:1), att = .1, n_output_units = 2,
      rdm_weights = FALSE, noise = 0)
</code></pre>

<hr>
<h2 id='plot.JoF'>plot progress of judgment of frequency simulation</h2><span id='topic+plot.JoF'></span>

<h3>Description</h3>

<p>plot progress of judgment of frequency simulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'JoF'
plot(x, type = "l", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.JoF_+3A_x">x</code></td>
<td>
<p>output of JoF simulation</p>
</td></tr>
<tr><td><code id="plot.JoF_+3A_type">type</code></td>
<td>
<p>&quot;l&quot; for lines, &quot;p&quot; for points, &quot;b&quot; for both</p>
</td></tr>
<tr><td><code id="plot.JoF_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Displays the judgment of frequency as proportion of all
inputs
</p>

<hr>
<h2 id='print.JoF'>Output of judgment of frequecny simulation</h2><span id='topic+print.JoF'></span>

<h3>Description</h3>

<p>Output of judgment of frequecny simulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'JoF'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.JoF_+3A_x">x</code></td>
<td>
<p>output of JoF simulation</p>
</td></tr>
<tr><td><code id="print.JoF_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Displays the judgment of frequency as proportion of all
inputs
</p>

<hr>
<h2 id='TODAM2'>Modeling Judgments of Frequency with TODAM 2</h2><span id='topic+TODAM2'></span>

<h3>Description</h3>

<p>Modeling Judgments of Frequency with TODAM 2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TODAM2(x, y, ..., sqc, gamma = 1, alpha = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TODAM2_+3A_x">x</code></td>
<td>
<p>input handled by TODAM 2. Normal distributed inputs
with mean = 0 and sd = 1 / n are allowed. This representation
enables discrimination and similarity between different items.
See vignette for details.</p>
</td></tr>
<tr><td><code id="TODAM2_+3A_y">y</code></td>
<td>
<p>another input handled by TODAM 2. At least two
inputs are needed for the simulation.</p>
</td></tr>
<tr><td><code id="TODAM2_+3A_...">...</code></td>
<td>
<p>other inputs handled by TODAM 2.</p>
</td></tr>
<tr><td><code id="TODAM2_+3A_sqc">sqc</code></td>
<td>
<p>sequence of the different objects. Each input gets
an ascending number. <code>x</code> gets the value <code>1</code>,
<code>y</code> gets the value <code>2</code>, <code>...</code> gets the value
<code>3</code> and so on.
The argument <code>sqc = c(1, 2, 3, 2)</code> means: first
input <code>x</code> is processed, second input <code>y</code> is
processed followed by processing input number three and
fourth, th input <code>y</code> is used again.
So <code>sqc</code> contains the frequency information too.
In <code>c(1, 2, 3, 2)</code>, <code>x</code> and  the third input
are presented once. The input <code>y</code> is presented twice.</p>
</td></tr>
<tr><td><code id="TODAM2_+3A_gamma">gamma</code></td>
<td>
<p>is the atttention- or learningparameter. Values
between 0 and 1 are allowed. 1 represents perfect learning.
If <code>gamma</code> iis a vector, each input
could be handled differently. So <code>gamma = c(.5, .6, 1)</code>
means, the third input is stored correctly and betther than
the <code>y</code> better than first input <code>x</code>).</p>
</td></tr>
<tr><td><code id="TODAM2_+3A_alpha">alpha</code></td>
<td>
<p>represents the decay. If <code>alpha = 1</code>,
the complete memory vector is used (and no forgetting takes
place). If <code>alpha</code> is an numeric Vector e. g.
<code>alpha = c(.8, .9, 1)</code>, the memory vector is weighted.
The memory for the first input is weaker than the second
than the third.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the original publication TODAM 2 is more complex
and has more parameters. Especially the design for the input
is a concatenation between item and context. The normal
distributed input has a <em>mean = 0</em> and <em>sd = 1/n</em>.
A pragmatic solution to make the models input comparable is
to use a binary input like in PASS. There is no explicit argument
for noise.
</p>
<p>Convolution:
</p>
<p style="text-align: center;"><code class="reqn"> F_{i}^{2}  = \sum_{i=1} f_{i} * f_{m-i+1} and m = 2n - 1</code>
</p>

<p>Memory:
</p>
<p style="text-align: center;"><code class="reqn">M_{t} = \alpha M_{t-1} + \gamma F_{t}^{2} </code>
</p>

<p>Correlation
</p>
<p style="text-align: center;"><code class="reqn">R_{m} = \sum_{(i;j)\in S(m)} F_{t}^{2} there
S(m)(i;j)| -(n-1)/2 \le i,j \le (n-1)/2 and i-j = m </code>
</p>



<h3>References</h3>

<p>Murdock, B. B., Smith, D., &amp; Bai, J. (2001). Judgments of frequency
and recency in a distributed memory model. <em>Journal of
Mathematical Psychology, 45,</em> 564–602.
<a href="https://doi.org/10.1006/jmps.2000.1339">https://doi.org/10.1006/jmps.2000.1339</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>o1 &lt;- c(-0.27, -0.24, -0.24, 0.75)
o2 &lt;- c(-0.06, -0.55,  0.66, -0.06)
o3 &lt;- c(0.04,  0.57, -0.65,  0.04)
o4 &lt;- c(0.73, -0.39, -0.20, -0.14)
TODAM2(o1, o2, o3, o4, gamma = rep(c(0.7, 0.8), 5),
alpha = 0.95, sqc = rep(1:4, 4:1))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
